{
  "metadata": {
    "timestamp": 1736567218504,
    "page": 813,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "xanzy/go-gitlab",
      "stars": 2433,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3330078125,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n# IDE specific files and folders\n.idea\n*.iml\n*.swp\n*.swo\n\n# vendor\nvendor\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 1.0673828125,
          "content": "# This file contains all available configuration options\n# with their default values.\n\n# Options for analysis running\nrun:\n  concurrency: 4\n  timeout: 10m\n  issues-exit-code: 1\n  tests: true\n\n# Output configuration options\noutput:\n  formats:\n    - format: line-number\n\n# All available settings of specific linters\nlinters-settings:\n  misspell:\n    locale: US\n    ignore-words:\n    - noteable\n  revive:\n    enable-all-rules: false\n    rules:\n      - name: deep-exit\n\nlinters:\n  enable:\n    - asciicheck\n    - dogsled\n    - errorlint\n    - exportloopref\n    - goconst\n    - gosimple\n    - govet\n    - ineffassign\n    - misspell\n    - nakedret\n    - nolintlint\n    - revive\n    - staticcheck\n    - typecheck\n    - unconvert\n    - unused\n    - whitespace\n  disable:\n    - errcheck\n  disable-all: false\n  fast: false\n\nissues:\n  # List of regexps of issue texts to exclude.\n  exclude:\n    - \"^.*, make it a constant$\"\n\n  # Maximum issues count per one linter (set to 0 to disable)\n  max-issues-per-linter: 0\n\n  # Maximum count of issues with the same text (set to 0 to disable)\n  max-same-issues: 0\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.9423828125,
          "content": "# How to Contribute\n\nWe want to make contributing to this project as easy as possible.\n\n## Reporting Issues\n\nIf you have an issue, please report it on the [issue tracker](https://github.com/xanzy/go-gitlab/issues).\n\nWhen you are up for writing a PR to solve the issue you encountered, it's not\nneeded to first open a separate issue. In that case only opening a PR with a\ndescription of the issue you are trying to solve is just fine.\n\n## Contributing Code\n\nPull requests are always welcome. When in doubt if your contribution fits within\nthe rest of the project, feel free to first open an issue to discuss your idea.\n\nThis is not needed when fixing a bug or adding an enhancement, as long as the\nenhancement you are trying to add can be found in the public GitLab API docs as\nthis project only supports what is in the public API docs.\n\n## Coding style\n\nWe try to follow the Go best practices, where it makes sense, and use\n[`gofumpt`](https://github.com/mvdan/gofumpt) to format code in this project.\nAs a general rule of thumb we prefer to keep line width for comments below 80\nchars and for code (where possible and sensible) below 100 chars.\n\nBefore making a PR, please look at the rest this package and try to make sure\nyour contribution is consistent with the rest of the coding style.\n\nNew struct field or methods should be placed (as much as possible) in the same\norder as the ordering used in the public API docs. The idea is that this makes it\neasier to find things.\n\n### Setting up your local development environment to Contribute to `go-gitlab`\n\n1. [Fork](https://github.com/xanzy/go-gitlab/fork), then clone the repository.\n   ```sh\n   git clone https://github.com/<your-username>/go-gitlab.git\n   # or via ssh\n   git clone git@github.com:<your-username>/go-gitlab.git\n   ```\n1. Install dependencies:\n   ```sh\n   make setup\n   ```\n1. Make your changes on your feature branch\n1. Run the tests and `gofumpt`\n   ```sh\n   make test && make fmt\n   ```\n1. Open up your pull request\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright {yyyy} {name of copyright owner}\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.5849609375,
          "content": "##@ General\n\n.PHONY: help\nhelp: ## Display this help\n\t@awk 'BEGIN {FS = \":.*##\"; printf \"\\nUsage:\\n  make \\033[36m<target>\\033[0m\\n\"} /^[a-zA-Z_0-9-]+:.*?##/ { printf \"  \\033[36m%-15s\\033[0m %s\\n\", $$1, $$2 } /^##@/ { printf \"\\n\\033[1m%s\\033[0m\\n\", substr($$0, 5) } ' $(MAKEFILE_LIST)\n\n##@ Development\n\nfmt: ## Format code\n\t@gofumpt -l -w .\n\nlint: ## Run linter\n\t@golangci-lint run\n\nsetup: ## Setup your local environment\n\tgo mod tidy\n\t@go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\t@go install mvdan.cc/gofumpt@latest\n.PHONY: setup\n\ntest: ## Run tests\n\tgo test ./... -race\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.7978515625,
          "content": "This repository is archived as it's development has been moved to GitLab!\n\n# go-gitlab (deprecated)\n\n🚧 **Project moved to https://gitlab.com/gitlab-org/api/client-go** 🚧\n\nThis package, `github.com/xanzy/go-gitlab`, has been moved to\n[`gitlab.com/gitlab-org/api/client-go`](https://gitlab.com/gitlab-org/api/client-go).\n\nThe project will continue to be a primarily community-maintained project,\nmore about it [here](https://gitlab.com/gitlab-org/client.go/-/blob/main/README.md#maintenance).\n\n**References**:\n\n- [GitLab Project](https://gitlab.com/gitlab-org/api/client-go)\n- [Issue Tracker](https://gitlab.com/gitlab-org/api/client-go/-/issues)\n\n## Migration Steps\n\n- Replace `github.com/xanzy/go-gitlab` with `gitlab.com/gitlab-org/api/client-go` in your code base.\n- Profit 🎉\n- *(the code is fully backwards-compatible, no breaking changes are expected)*\n\n<details><summary>Former README contents</summary>\n\nA GitLab API client enabling Go programs to interact with GitLab in a simple and uniform way\n\n[![Build Status](https://github.com/xanzy/go-gitlab/workflows/Lint%20and%20Test/badge.svg)](https://github.com/xanzy/go-gitlab/actions?workflow=Lint%20and%20Test)\n[![Sourcegraph](https://sourcegraph.com/github.com/xanzy/go-gitlab/-/badge.svg)](https://sourcegraph.com/github.com/xanzy/go-gitlab?badge)\n[![GoDoc](https://godoc.org/github.com/xanzy/go-gitlab?status.svg)](https://godoc.org/github.com/xanzy/go-gitlab)\n[![Go Report Card](https://goreportcard.com/badge/github.com/xanzy/go-gitlab)](https://goreportcard.com/report/github.com/xanzy/go-gitlab)\n[![Coverage](https://github.com/xanzy/go-gitlab/wiki/coverage.svg)](https://raw.githack.com/wiki/xanzy/go-gitlab/coverage.html)\n\n## NOTE\n\nRelease v0.6.0 (released on 25-08-2017) no longer supports the older V3 GitLab API. If\nyou need V3 support, please use the `f-api-v3` branch. This release contains some backwards\nincompatible changes that were needed to fully support the V4 GitLab API.\n\n## Coverage\n\nThis API client package covers most of the existing GitLab API calls and is updated regularly\nto add new and/or missing endpoints. Currently, the following services are supported:\n\n- [x] Applications\n- [x] Award Emojis\n- [x] Branches\n- [x] Broadcast Messages\n- [x] Commits\n- [x] Container Registry\n- [x] Custom Attributes\n- [x] Dependency List Export\n- [x] Deploy Keys\n- [x] Deployments\n- [x] Discussions (threaded comments)\n- [x] Environments\n- [x] Epic Issues\n- [x] Epics\n- [x] Error Tracking\n- [x] Events\n- [x] Feature Flags\n- [x] Geo Nodes\n- [x] Generic Packages\n- [x] GitLab CI Config Templates\n- [x] Gitignores Templates\n- [x] Group Access Requests\n- [x] Group Issue Boards\n- [x] Group Members\n- [x] Group Milestones\n- [x] Group Wikis\n- [x] Group-Level Variables\n- [x] Groups\n- [x] Instance Clusters\n- [x] Invites\n- [x] Issue Boards\n- [x] Issues\n- [x] Jobs\n- [x] Keys\n- [x] Labels\n- [x] License\n- [x] Markdown\n- [x] Merge Request Approvals\n- [x] Merge Requests\n- [x] Namespaces\n- [x] Notes (comments)\n- [x] Notification Settings\n- [x] Open Source License Templates\n- [x] Packages\n- [x] Pages\n- [x] Pages Domains\n- [x] Personal Access Tokens\n- [x] Pipeline Schedules\n- [x] Pipeline Triggers\n- [x] Pipelines\n- [x] Plan limits\n- [x] Project Access Requests\n- [x] Project Badges\n- [x] Project Clusters\n- [x] Project Import/export\n- [x] Project Members\n- [x] Project Milestones\n- [x] Project Repository Storage Moves\n- [x] Project Snippets\n- [x] Project Vulnerabilities\n- [x] Project-Level Variables\n- [x] Projects (including setting Webhooks)\n- [x] Protected Branches\n- [x] Protected Environments\n- [x] Protected Tags\n- [x] Repositories\n- [x] Repository Files\n- [x] Repository Submodules\n- [x] Runners\n- [x] Search\n- [x] Services\n- [x] Settings\n- [x] Sidekiq Metrics\n- [x] System Hooks\n- [x] Tags\n- [x] Todos\n- [x] Topics\n- [x] Users\n- [x] Validate CI Configuration\n- [x] Version\n- [x] Wikis\n\n## Usage\n\n```go\nimport \"github.com/xanzy/go-gitlab\"\n```\n\nConstruct a new GitLab client, then use the various services on the client to\naccess different parts of the GitLab API. For example, to list all\nusers:\n\n```go\ngit, err := gitlab.NewClient(\"yourtokengoeshere\")\nif err != nil {\n  log.Fatalf(\"Failed to create client: %v\", err)\n}\nusers, _, err := git.Users.ListUsers(&gitlab.ListUsersOptions{})\n```\n\nThere are a few `With...` option functions that can be used to customize\nthe API client. For example, to set a custom base URL:\n\n```go\ngit, err := gitlab.NewClient(\"yourtokengoeshere\", gitlab.WithBaseURL(\"https://git.mydomain.com/api/v4\"))\nif err != nil {\n  log.Fatalf(\"Failed to create client: %v\", err)\n}\nusers, _, err := git.Users.ListUsers(&gitlab.ListUsersOptions{})\n```\n\nSome API methods have optional parameters that can be passed. For example,\nto list all projects for user \"svanharmelen\":\n\n```go\ngit := gitlab.NewClient(\"yourtokengoeshere\")\nopt := &gitlab.ListProjectsOptions{Search: gitlab.Ptr(\"svanharmelen\")}\nprojects, _, err := git.Projects.ListProjects(opt)\n```\n\n### Examples\n\nThe [examples](https://github.com/xanzy/go-gitlab/tree/master/examples) directory\ncontains a couple for clear examples, of which one is partially listed here as well:\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/xanzy/go-gitlab\"\n)\n\nfunc main() {\n\tgit, err := gitlab.NewClient(\"yourtokengoeshere\")\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\t// Create new project\n\tp := &gitlab.CreateProjectOptions{\n\t\tName:                     gitlab.Ptr(\"My Project\"),\n\t\tDescription:              gitlab.Ptr(\"Just a test project to play with\"),\n\t\tMergeRequestsAccessLevel: gitlab.Ptr(gitlab.EnabledAccessControl),\n\t\tSnippetsAccessLevel:      gitlab.Ptr(gitlab.EnabledAccessControl),\n\t\tVisibility:               gitlab.Ptr(gitlab.PublicVisibility),\n\t}\n\tproject, _, err := git.Projects.CreateProject(p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Add a new snippet\n\ts := &gitlab.CreateProjectSnippetOptions{\n\t\tTitle:           gitlab.Ptr(\"Dummy Snippet\"),\n\t\tFileName:        gitlab.Ptr(\"snippet.go\"),\n\t\tContent:         gitlab.Ptr(\"package main....\"),\n\t\tVisibility:      gitlab.Ptr(gitlab.PublicVisibility),\n\t}\n\t_, _, err = git.ProjectSnippets.CreateSnippet(project.ID, s)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n\nFor complete usage of go-gitlab, see the full [package docs](https://godoc.org/github.com/xanzy/go-gitlab).\n\n## ToDo\n\n- The biggest thing this package still needs is tests :disappointed:\n\n## Issues\n\n- If you have an issue: report it on the [issue tracker](https://github.com/xanzy/go-gitlab/issues)\n\n## Author\n\nSander van Harmelen (<sander@vanharmelen.nl>)\n\n## Contributing\n\nContributions are always welcome. For more information, check out the [contributing guide](https://github.com/xanzy/go-gitlab/blob/master/CONTRIBUTING.md)\n\n## License\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at <http://www.apache.org/licenses/LICENSE-2.0>\n\n</details>\n"
        },
        {
          "name": "access_requests.go",
          "type": "blob",
          "size": 7.6318359375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// AccessRequest represents a access request for a group or project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html\ntype AccessRequest struct {\n\tID          int              `json:\"id\"`\n\tUsername    string           `json:\"username\"`\n\tName        string           `json:\"name\"`\n\tState       string           `json:\"state\"`\n\tCreatedAt   *time.Time       `json:\"created_at\"`\n\tRequestedAt *time.Time       `json:\"requested_at\"`\n\tAccessLevel AccessLevelValue `json:\"access_level\"`\n}\n\n// AccessRequestsService handles communication with the project/group\n// access requests related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/access_requests.html\ntype AccessRequestsService struct {\n\tclient *Client\n}\n\n// ListAccessRequestsOptions represents the available\n// ListProjectAccessRequests() or ListGroupAccessRequests() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#list-access-requests-for-a-group-or-project\ntype ListAccessRequestsOptions ListOptions\n\n// ListProjectAccessRequests gets a list of access requests\n// viewable by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#list-access-requests-for-a-group-or-project\nfunc (s *AccessRequestsService) ListProjectAccessRequests(pid interface{}, opt *ListAccessRequestsOptions, options ...RequestOptionFunc) ([]*AccessRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_requests\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ars []*AccessRequest\n\tresp, err := s.client.Do(req, &ars)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ars, resp, nil\n}\n\n// ListGroupAccessRequests gets a list of access requests\n// viewable by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#list-access-requests-for-a-group-or-project\nfunc (s *AccessRequestsService) ListGroupAccessRequests(gid interface{}, opt *ListAccessRequestsOptions, options ...RequestOptionFunc) ([]*AccessRequest, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_requests\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ars []*AccessRequest\n\tresp, err := s.client.Do(req, &ars)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ars, resp, nil\n}\n\n// RequestProjectAccess requests access for the authenticated user\n// to a group or project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#request-access-to-a-group-or-project\nfunc (s *AccessRequestsService) RequestProjectAccess(pid interface{}, options ...RequestOptionFunc) (*AccessRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_requests\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tar := new(AccessRequest)\n\tresp, err := s.client.Do(req, ar)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ar, resp, nil\n}\n\n// RequestGroupAccess requests access for the authenticated user\n// to a group or project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#request-access-to-a-group-or-project\nfunc (s *AccessRequestsService) RequestGroupAccess(gid interface{}, options ...RequestOptionFunc) (*AccessRequest, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_requests\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tar := new(AccessRequest)\n\tresp, err := s.client.Do(req, ar)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ar, resp, nil\n}\n\n// ApproveAccessRequestOptions represents the available\n// ApproveProjectAccessRequest() and ApproveGroupAccessRequest() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#approve-an-access-request\ntype ApproveAccessRequestOptions struct {\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n}\n\n// ApproveProjectAccessRequest approves an access request for the given user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#approve-an-access-request\nfunc (s *AccessRequestsService) ApproveProjectAccessRequest(pid interface{}, user int, opt *ApproveAccessRequestOptions, options ...RequestOptionFunc) (*AccessRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_requests/%d/approve\", PathEscape(project), user)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tar := new(AccessRequest)\n\tresp, err := s.client.Do(req, ar)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ar, resp, nil\n}\n\n// ApproveGroupAccessRequest approves an access request for the given user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#approve-an-access-request\nfunc (s *AccessRequestsService) ApproveGroupAccessRequest(gid interface{}, user int, opt *ApproveAccessRequestOptions, options ...RequestOptionFunc) (*AccessRequest, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_requests/%d/approve\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tar := new(AccessRequest)\n\tresp, err := s.client.Do(req, ar)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ar, resp, nil\n}\n\n// DenyProjectAccessRequest denies an access request for the given user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#deny-an-access-request\nfunc (s *AccessRequestsService) DenyProjectAccessRequest(pid interface{}, user int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_requests/%d\", PathEscape(project), user)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DenyGroupAccessRequest denies an access request for the given user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/access_requests.html#deny-an-access-request\nfunc (s *AccessRequestsService) DenyGroupAccessRequest(gid interface{}, user int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_requests/%d\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "access_requests_test.go",
          "type": "blob",
          "size": 12.1826171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListProjectAccessRequests(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"raymond_smith\",\n\t\t\t  \"name\": \"Raymond Smith\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t  \"requested_at\": \"2012-10-22T14:13:35Z\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"username\": \"john_doe\",\n\t\t\t  \"name\": \"John Doe\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t  \"requested_at\": \"2012-10-22T14:13:35Z\"\n\t\t\t}\n\t\t]`)\n\t})\n\n\tcreated := time.Date(2012, 10, 22, 14, 13, 35, 0, time.UTC)\n\texpected := []*AccessRequest{\n\t\t{\n\t\t\tID:          1,\n\t\t\tUsername:    \"raymond_smith\",\n\t\t\tName:        \"Raymond Smith\",\n\t\t\tState:       \"active\",\n\t\t\tCreatedAt:   &created,\n\t\t\tRequestedAt: &created,\n\t\t},\n\t\t{\n\t\t\tID:          2,\n\t\t\tUsername:    \"john_doe\",\n\t\t\tName:        \"John Doe\",\n\t\t\tState:       \"active\",\n\t\t\tCreatedAt:   &created,\n\t\t\tRequestedAt: &created,\n\t\t},\n\t}\n\n\trequests, resp, err := client.AccessRequests.ListProjectAccessRequests(1, nil)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\tassert.Equal(t, expected, requests)\n\n\trequests, resp, err = client.AccessRequests.ListProjectAccessRequests(1.5, nil)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, requests)\n\n\trequests, resp, err = client.AccessRequests.ListProjectAccessRequests(2, nil)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\tassert.Nil(t, requests)\n\n\trequests, resp, err = client.AccessRequests.ListProjectAccessRequests(1, nil, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, requests)\n}\n\nfunc TestListGroupAccessRequests(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"raymond_smith\",\n\t\t\t  \"name\": \"Raymond Smith\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t  \"requested_at\": \"2012-10-22T14:13:35Z\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"username\": \"john_doe\",\n\t\t\t  \"name\": \"John Doe\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t  \"requested_at\": \"2012-10-22T14:13:35Z\"\n\t\t\t}\n\t\t]`)\n\t})\n\n\tcreated := time.Date(2012, 10, 22, 14, 13, 35, 0, time.UTC)\n\texpected := []*AccessRequest{\n\t\t{\n\t\t\tID:          1,\n\t\t\tUsername:    \"raymond_smith\",\n\t\t\tName:        \"Raymond Smith\",\n\t\t\tState:       \"active\",\n\t\t\tCreatedAt:   &created,\n\t\t\tRequestedAt: &created,\n\t\t},\n\t\t{\n\t\t\tID:          2,\n\t\t\tUsername:    \"john_doe\",\n\t\t\tName:        \"John Doe\",\n\t\t\tState:       \"active\",\n\t\t\tCreatedAt:   &created,\n\t\t\tRequestedAt: &created,\n\t\t},\n\t}\n\n\trequests, resp, err := client.AccessRequests.ListGroupAccessRequests(1, nil)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\tassert.Equal(t, expected, requests)\n\n\trequests, resp, err = client.AccessRequests.ListGroupAccessRequests(1.5, nil)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, requests)\n\n\trequests, resp, err = client.AccessRequests.ListGroupAccessRequests(2, nil)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\tassert.Nil(t, requests)\n\n\trequests, resp, err = client.AccessRequests.ListGroupAccessRequests(1, nil, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, requests)\n}\n\nfunc TestRequestProjectAccess(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t\t\"requested_at\": \"2012-10-22T14:13:35Z\"\n\t\t\t}`)\n\t})\n\n\tcreated := time.Date(2012, 10, 22, 14, 13, 35, 0, time.UTC)\n\texpected := &AccessRequest{\n\t\tID:          1,\n\t\tUsername:    \"raymond_smith\",\n\t\tName:        \"Raymond Smith\",\n\t\tState:       \"active\",\n\t\tCreatedAt:   &created,\n\t\tRequestedAt: &created,\n\t}\n\n\taccessRequest, resp, err := client.AccessRequests.RequestProjectAccess(1, nil)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\tassert.Equal(t, expected, accessRequest)\n\n\taccessRequest, resp, err = client.AccessRequests.RequestProjectAccess(1.5, nil)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, accessRequest)\n\n\taccessRequest, resp, err = client.AccessRequests.RequestProjectAccess(2, nil)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\tassert.Nil(t, accessRequest)\n\n\taccessRequest, resp, err = client.AccessRequests.RequestProjectAccess(1, nil, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, accessRequest)\n}\n\nfunc TestRequestGroupAccess(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t\t\"requested_at\": \"2012-10-22T14:13:35Z\"\n\t\t\t}`)\n\t})\n\n\tcreated := time.Date(2012, 10, 22, 14, 13, 35, 0, time.UTC)\n\texpected := &AccessRequest{\n\t\tID:          1,\n\t\tUsername:    \"raymond_smith\",\n\t\tName:        \"Raymond Smith\",\n\t\tState:       \"active\",\n\t\tCreatedAt:   &created,\n\t\tRequestedAt: &created,\n\t}\n\n\taccessRequest, resp, err := client.AccessRequests.RequestGroupAccess(1, nil)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\tassert.Equal(t, expected, accessRequest)\n\n\taccessRequest, resp, err = client.AccessRequests.RequestGroupAccess(1.5, nil)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, accessRequest)\n\n\taccessRequest, resp, err = client.AccessRequests.RequestGroupAccess(2, nil)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\tassert.Nil(t, accessRequest)\n\n\taccessRequest, resp, err = client.AccessRequests.RequestGroupAccess(1, nil, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, accessRequest)\n}\n\nfunc TestApproveProjectAccessRequest(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_requests/10/approve\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\n\t\tvar opt ApproveAccessRequestOptions\n\t\terr := json.NewDecoder(r.Body).Decode(&opt)\n\t\tassert.NoError(t, err)\n\t\tdefer r.Body.Close()\n\n\t\tfmt.Fprintf(w, `{\n\t\t\t\t\"id\": 10,\n\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t\t\"requested_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t\t\"access_level\": %d\n\t\t\t}`,\n\t\t\t*opt.AccessLevel)\n\t})\n\n\tcreated := time.Date(2012, 10, 22, 14, 13, 35, 0, time.UTC)\n\texpected := &AccessRequest{\n\t\tID:          10,\n\t\tUsername:    \"raymond_smith\",\n\t\tName:        \"Raymond Smith\",\n\t\tState:       \"active\",\n\t\tCreatedAt:   &created,\n\t\tRequestedAt: &created,\n\t\tAccessLevel: DeveloperPermissions,\n\t}\n\n\topt := &ApproveAccessRequestOptions{\n\t\tAccessLevel: Ptr(DeveloperPermissions),\n\t}\n\n\trequest, resp, err := client.AccessRequests.ApproveProjectAccessRequest(1, 10, opt)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\tassert.Equal(t, expected, request)\n\n\trequest, resp, err = client.AccessRequests.ApproveProjectAccessRequest(1.5, 10, opt)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, request)\n\n\trequest, resp, err = client.AccessRequests.ApproveProjectAccessRequest(2, 10, opt)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\tassert.Nil(t, request)\n\n\trequest, resp, err = client.AccessRequests.ApproveProjectAccessRequest(1, 10, opt, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, request)\n}\n\nfunc TestApproveGroupAccessRequest(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_requests/10/approve\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\n\t\tvar opt ApproveAccessRequestOptions\n\t\terr := json.NewDecoder(r.Body).Decode(&opt)\n\t\tassert.NoError(t, err)\n\t\tdefer r.Body.Close()\n\n\t\tfmt.Fprintf(w, `{\n\t\t\t\t\"id\": 10,\n\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"created_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t\t\"requested_at\": \"2012-10-22T14:13:35Z\",\n\t\t\t\t\"access_level\": %d\n\t\t\t}`,\n\t\t\t*opt.AccessLevel)\n\t})\n\n\tcreated := time.Date(2012, 10, 22, 14, 13, 35, 0, time.UTC)\n\texpected := &AccessRequest{\n\t\tID:          10,\n\t\tUsername:    \"raymond_smith\",\n\t\tName:        \"Raymond Smith\",\n\t\tState:       \"active\",\n\t\tCreatedAt:   &created,\n\t\tRequestedAt: &created,\n\t\tAccessLevel: DeveloperPermissions,\n\t}\n\n\topt := &ApproveAccessRequestOptions{\n\t\tAccessLevel: Ptr(DeveloperPermissions),\n\t}\n\n\trequest, resp, err := client.AccessRequests.ApproveGroupAccessRequest(1, 10, opt)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\tassert.Equal(t, expected, request)\n\n\trequest, resp, err = client.AccessRequests.ApproveGroupAccessRequest(1.5, 10, opt)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, request)\n\n\trequest, resp, err = client.AccessRequests.ApproveGroupAccessRequest(2, 10, opt)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\tassert.Nil(t, request)\n\n\trequest, resp, err = client.AccessRequests.ApproveGroupAccessRequest(1, 10, opt, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n\tassert.Nil(t, request)\n}\n\nfunc TestDenyProjectAccessRequest(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_requests/10\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AccessRequests.DenyProjectAccessRequest(1, 10)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\n\tresp, err = client.AccessRequests.DenyProjectAccessRequest(1.5, 10)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\n\tresp, err = client.AccessRequests.DenyProjectAccessRequest(2, 10)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\n\tresp, err = client.AccessRequests.DenyProjectAccessRequest(1, 10, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n}\n\nfunc TestDenyGroupAccessRequest(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_requests/10\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AccessRequests.DenyGroupAccessRequest(1, 10)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, resp)\n\n\tresp, err = client.AccessRequests.DenyGroupAccessRequest(1.5, 10)\n\tassert.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\tassert.Nil(t, resp)\n\n\tresp, err = client.AccessRequests.DenyGroupAccessRequest(2, 10)\n\tassert.Error(t, err)\n\tassert.Equal(t, http.StatusNotFound, resp.StatusCode)\n\n\tresp, err = client.AccessRequests.DenyGroupAccessRequest(1, 10, errorOption)\n\tassert.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\tassert.Nil(t, resp)\n}\n"
        },
        {
          "name": "appearance.go",
          "type": "blob",
          "size": 4.9228515625,
          "content": "//\n// Copyright 2023, 徐晓伟 <xuxiaowei@xuxiaowei.com.cn>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport \"net/http\"\n\n// AppearanceService handles communication with appearance of the Gitlab API.\n//\n// Gitlab API docs : https://docs.gitlab.com/ee/api/appearance.html\ntype AppearanceService struct {\n\tclient *Client\n}\n\n// Appearance represents a GitLab appearance.\n//\n// Gitlab API docs : https://docs.gitlab.com/ee/api/appearance.html\ntype Appearance struct {\n\tTitle                       string `json:\"title\"`\n\tDescription                 string `json:\"description\"`\n\tPWAName                     string `json:\"pwa_name\"`\n\tPWAShortName                string `json:\"pwa_short_name\"`\n\tPWADescription              string `json:\"pwa_description\"`\n\tPWAIcon                     string `json:\"pwa_icon\"`\n\tLogo                        string `json:\"logo\"`\n\tHeaderLogo                  string `json:\"header_logo\"`\n\tFavicon                     string `json:\"favicon\"`\n\tNewProjectGuidelines        string `json:\"new_project_guidelines\"`\n\tProfileImageGuidelines      string `json:\"profile_image_guidelines\"`\n\tHeaderMessage               string `json:\"header_message\"`\n\tFooterMessage               string `json:\"footer_message\"`\n\tMessageBackgroundColor      string `json:\"message_background_color\"`\n\tMessageFontColor            string `json:\"message_font_color\"`\n\tEmailHeaderAndFooterEnabled bool   `json:\"email_header_and_footer_enabled\"`\n}\n\n// GetAppearance gets the current appearance configuration of the GitLab instance.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/appearance.html#get-current-appearance-configuration\nfunc (s *AppearanceService) GetAppearance(options ...RequestOptionFunc) (*Appearance, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"application/appearance\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tas := new(Appearance)\n\tresp, err := s.client.Do(req, as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n\n// ChangeAppearanceOptions represents the available ChangeAppearance() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/appearance.html#change-appearance-configuration\ntype ChangeAppearanceOptions struct {\n\tTitle                       *string `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription                 *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPWAName                     *string `url:\"pwa_name,omitempty\" json:\"pwa_name,omitempty\"`\n\tPWAShortName                *string `url:\"pwa_short_name,omitempty\" json:\"pwa_short_name,omitempty\"`\n\tPWADescription              *string `url:\"pwa_description,omitempty\" json:\"pwa_description,omitempty\"`\n\tPWAIcon                     *string `url:\"pwa_icon,omitempty\" json:\"pwa_icon,omitempty\"`\n\tLogo                        *string `url:\"logo,omitempty\" json:\"logo,omitempty\"`\n\tHeaderLogo                  *string `url:\"header_logo,omitempty\" json:\"header_logo,omitempty\"`\n\tFavicon                     *string `url:\"favicon,omitempty\" json:\"favicon,omitempty\"`\n\tNewProjectGuidelines        *string `url:\"new_project_guidelines,omitempty\" json:\"new_project_guidelines,omitempty\"`\n\tProfileImageGuidelines      *string `url:\"profile_image_guidelines,omitempty\" json:\"profile_image_guidelines,omitempty\"`\n\tHeaderMessage               *string `url:\"header_message,omitempty\" json:\"header_message,omitempty\"`\n\tFooterMessage               *string `url:\"footer_message,omitempty\" json:\"footer_message,omitempty\"`\n\tMessageBackgroundColor      *string `url:\"message_background_color,omitempty\" json:\"message_background_color,omitempty\"`\n\tMessageFontColor            *string `url:\"message_font_color,omitempty\" json:\"message_font_color,omitempty\"`\n\tEmailHeaderAndFooterEnabled *bool   `url:\"email_header_and_footer_enabled,omitempty\" json:\"email_header_and_footer_enabled,omitempty\"`\n\tURL                         *string `url:\"url,omitempty\" json:\"url,omitempty\"`\n}\n\n// ChangeAppearance changes the appearance configuration.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/appearance.html#change-appearance-configuration\nfunc (s *AppearanceService) ChangeAppearance(opt *ChangeAppearanceOptions, options ...RequestOptionFunc) (*Appearance, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPut, \"application/appearance\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tas := new(Appearance)\n\tresp, err := s.client.Do(req, as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n"
        },
        {
          "name": "appearance_test.go",
          "type": "blob",
          "size": 6.0849609375,
          "content": "//\n// Copyright 2023, 徐晓伟 <xuxiaowei@xuxiaowei.com.cn>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetAppearance(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/appearance\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n \t\t \t\"title\": \"GitLab Test Instance\",\n \t\t \t\"description\": \"gitlab-test.example.com\",\n \t\t \t\"pwa_name\": \"GitLab PWA\",\n \t\t \t\"pwa_short_name\": \"GitLab\",\n \t\t \t\"pwa_description\": \"GitLab as PWA\",\n \t\t \t\"pwa_icon\": \"/uploads/-/system/appearance/pwa_icon/1/pwa_logo.png\",\n \t\t \t\"logo\": \"/uploads/-/system/appearance/logo/1/logo.png\",\n \t\t \t\"header_logo\": \"/uploads/-/system/appearance/header_logo/1/header.png\",\n \t\t \t\"favicon\": \"/uploads/-/system/appearance/favicon/1/favicon.png\",\n \t\t \t\"new_project_guidelines\": \"Please read the FAQs for help.\",\n \t\t \t\"profile_image_guidelines\": \"Custom profile image guidelines\",\n \t\t \t\"header_message\": \"\",\n \t\t \t\"footer_message\": \"\",\n \t\t \t\"message_background_color\": \"#e75e40\",\n \t\t \t\"message_font_color\": \"#ffffff\",\n \t\t \t\"email_header_and_footer_enabled\": false\n \t\t}`)\n\t})\n\n\tappearance, _, err := client.Appearance.GetAppearance()\n\tif err != nil {\n\t\tt.Errorf(\"Appearance.GetAppearance returned error: %v\", err)\n\t}\n\n\twant := &Appearance{\n\t\tTitle:                       \"GitLab Test Instance\",\n\t\tDescription:                 \"gitlab-test.example.com\",\n\t\tPWAName:                     \"GitLab PWA\",\n\t\tPWAShortName:                \"GitLab\",\n\t\tPWADescription:              \"GitLab as PWA\",\n\t\tPWAIcon:                     \"/uploads/-/system/appearance/pwa_icon/1/pwa_logo.png\",\n\t\tLogo:                        \"/uploads/-/system/appearance/logo/1/logo.png\",\n\t\tHeaderLogo:                  \"/uploads/-/system/appearance/header_logo/1/header.png\",\n\t\tFavicon:                     \"/uploads/-/system/appearance/favicon/1/favicon.png\",\n\t\tNewProjectGuidelines:        \"Please read the FAQs for help.\",\n\t\tProfileImageGuidelines:      \"Custom profile image guidelines\",\n\t\tHeaderMessage:               \"\",\n\t\tFooterMessage:               \"\",\n\t\tMessageBackgroundColor:      \"#e75e40\",\n\t\tMessageFontColor:            \"#ffffff\",\n\t\tEmailHeaderAndFooterEnabled: false,\n\t}\n\n\tif !reflect.DeepEqual(want, appearance) {\n\t\tt.Errorf(\"Appearance.GetAppearance returned %+v, want %+v\", appearance, want)\n\t}\n}\n\nfunc TestChangeAppearance(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/appearance\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\n\t\t \t\"title\": \"GitLab Test Instance - 001\",\n \t\t \t\"description\": \"gitlab-test.example.com\",\n \t\t \t\"pwa_name\": \"GitLab PWA\",\n \t\t \t\"pwa_short_name\": \"GitLab\",\n \t\t \t\"pwa_description\": \"GitLab as PWA\",\n \t\t \t\"pwa_icon\": \"/uploads/-/system/appearance/pwa_icon/1/pwa_logo.png\",\n \t\t \t\"logo\": \"/uploads/-/system/appearance/logo/1/logo.png\",\n \t\t \t\"header_logo\": \"/uploads/-/system/appearance/header_logo/1/header.png\",\n \t\t \t\"favicon\": \"/uploads/-/system/appearance/favicon/1/favicon.png\",\n \t\t \t\"new_project_guidelines\": \"Please read the FAQs for help.\",\n \t\t \t\"profile_image_guidelines\": \"Custom profile image guidelines\",\n \t\t \t\"header_message\": \"\",\n \t\t \t\"footer_message\": \"\",\n \t\t \t\"message_background_color\": \"#e75e40\",\n \t\t \t\"message_font_color\": \"#ffffff\",\n \t\t \t\"email_header_and_footer_enabled\": false\n \t\t}`)\n\t})\n\n\topt := &ChangeAppearanceOptions{\n\t\tTitle:                       String(\"GitLab Test Instance - 001\"),\n\t\tDescription:                 String(\"gitlab-test.example.com\"),\n\t\tPWAName:                     String(\"GitLab PWA\"),\n\t\tPWAShortName:                String(\"GitLab\"),\n\t\tPWADescription:              String(\"GitLab as PWA\"),\n\t\tPWAIcon:                     String(\"/uploads/-/system/appearance/pwa_icon/1/pwa_logo.png\"),\n\t\tLogo:                        String(\"/uploads/-/system/appearance/logo/1/logo.png\"),\n\t\tHeaderLogo:                  String(\"/uploads/-/system/appearance/header_logo/1/header.png\"),\n\t\tFavicon:                     String(\"/uploads/-/system/appearance/favicon/1/favicon.png\"),\n\t\tNewProjectGuidelines:        String(\"Please read the FAQs for help.\"),\n\t\tProfileImageGuidelines:      String(\"Custom profile image guidelines\"),\n\t\tHeaderMessage:               String(\"\"),\n\t\tFooterMessage:               String(\"\"),\n\t\tMessageBackgroundColor:      String(\"#e75e40\"),\n\t\tMessageFontColor:            String(\"#ffffff\"),\n\t\tEmailHeaderAndFooterEnabled: Bool(false),\n\t}\n\n\tappearance, _, err := client.Appearance.ChangeAppearance(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Appearance.ChangeAppearance returned error: %v\", err)\n\t}\n\n\twant := &Appearance{\n\t\tTitle:                       \"GitLab Test Instance - 001\",\n\t\tDescription:                 \"gitlab-test.example.com\",\n\t\tPWAName:                     \"GitLab PWA\",\n\t\tPWAShortName:                \"GitLab\",\n\t\tPWADescription:              \"GitLab as PWA\",\n\t\tPWAIcon:                     \"/uploads/-/system/appearance/pwa_icon/1/pwa_logo.png\",\n\t\tLogo:                        \"/uploads/-/system/appearance/logo/1/logo.png\",\n\t\tHeaderLogo:                  \"/uploads/-/system/appearance/header_logo/1/header.png\",\n\t\tFavicon:                     \"/uploads/-/system/appearance/favicon/1/favicon.png\",\n\t\tNewProjectGuidelines:        \"Please read the FAQs for help.\",\n\t\tProfileImageGuidelines:      \"Custom profile image guidelines\",\n\t\tHeaderMessage:               \"\",\n\t\tFooterMessage:               \"\",\n\t\tMessageBackgroundColor:      \"#e75e40\",\n\t\tMessageFontColor:            \"#ffffff\",\n\t\tEmailHeaderAndFooterEnabled: false,\n\t}\n\n\tif !reflect.DeepEqual(want, appearance) {\n\t\tt.Errorf(\"Appearance.GetAppearance returned %+v, want %+v\", appearance, want)\n\t}\n}\n"
        },
        {
          "name": "applications.go",
          "type": "blob",
          "size": 3.392578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ApplicationsService handles communication with administrables applications\n// of the Gitlab API.\n//\n// Gitlab API docs : https://docs.gitlab.com/ee/api/applications.html\ntype ApplicationsService struct {\n\tclient *Client\n}\n\n// Application represents a GitLab application\ntype Application struct {\n\tID              int    `json:\"id\"`\n\tApplicationID   string `json:\"application_id\"`\n\tApplicationName string `json:\"application_name\"`\n\tSecret          string `json:\"secret\"`\n\tCallbackURL     string `json:\"callback_url\"`\n\tConfidential    bool   `json:\"confidential\"`\n}\n\n// CreateApplicationOptions represents the available CreateApplication() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/applications.html#create-an-application\ntype CreateApplicationOptions struct {\n\tName         *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tRedirectURI  *string `url:\"redirect_uri,omitempty\" json:\"redirect_uri,omitempty\"`\n\tScopes       *string `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n\tConfidential *bool   `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n}\n\n// CreateApplication creates a new application owned by the authenticated user.\n//\n// Gitlab API docs : https://docs.gitlab.com/ee/api/applications.html#create-an-application\nfunc (s *ApplicationsService) CreateApplication(opt *CreateApplicationOptions, options ...RequestOptionFunc) (*Application, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"applications\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(Application)\n\tresp, err := s.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// ListApplicationsOptions represents the available\n// ListApplications() options.\ntype ListApplicationsOptions ListOptions\n\n// ListApplications get a list of administrables applications by the authenticated user\n//\n// Gitlab API docs : https://docs.gitlab.com/ee/api/applications.html#list-all-applications\nfunc (s *ApplicationsService) ListApplications(opt *ListApplicationsOptions, options ...RequestOptionFunc) ([]*Application, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"applications\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar as []*Application\n\tresp, err := s.client.Do(req, &as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n\n// DeleteApplication removes a specific application.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/applications.html#delete-an-application\nfunc (s *ApplicationsService) DeleteApplication(application int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"applications/%d\", application)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "applications_test.go",
          "type": "blob",
          "size": 2.4619140625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCreateApplication(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/applications\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"id\":1,\n\t\"application_name\":\"testApplication\"\n}`)\n\t\t},\n\t)\n\n\topt := &CreateApplicationOptions{\n\t\tName: Ptr(\"testApplication\"),\n\t}\n\tapp, _, err := client.Applications.CreateApplication(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Applications.CreateApplication returned error: %v\", err)\n\t}\n\n\twant := &Application{\n\t\tID:              1,\n\t\tApplicationName: \"testApplication\",\n\t}\n\tif !reflect.DeepEqual(want, app) {\n\t\tt.Errorf(\"Applications.CreateApplication returned %+v, want %+v\", app, want)\n\t}\n}\n\nfunc TestListApplications(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/applications\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[\n\t{\"id\":1},\n\t{\"id\":2}\n]`)\n\t\t},\n\t)\n\n\tapps, _, err := client.Applications.ListApplications(&ListApplicationsOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Applications.ListApplications returned error: %v\", err)\n\t}\n\n\twant := []*Application{\n\t\t{ID: 1},\n\t\t{ID: 2},\n\t}\n\tif !reflect.DeepEqual(want, apps) {\n\t\tt.Errorf(\"Applications.ListApplications returned %+v, want %+v\", apps, want)\n\t}\n}\n\nfunc TestDeleteApplication(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/applications/4\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t},\n\t)\n\n\tresp, err := client.Applications.DeleteApplication(4)\n\tif err != nil {\n\t\tt.Errorf(\"Applications.DeleteApplication returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"Applications.DeleteApplication returned status code %d, want %d\", got, want)\n\t}\n}\n"
        },
        {
          "name": "audit_events.go",
          "type": "blob",
          "size": 6.4755859375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// AuditEvent represents an audit event for a group, a project or the instance.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html\ntype AuditEvent struct {\n\tID         int               `json:\"id\"`\n\tAuthorID   int               `json:\"author_id\"`\n\tEntityID   int               `json:\"entity_id\"`\n\tEntityType string            `json:\"entity_type\"`\n\tEventName  string            `json:\"event_name\"`\n\tDetails    AuditEventDetails `json:\"details\"`\n\tCreatedAt  *time.Time        `json:\"created_at\"`\n\tEventType  string            `json:\"event_type\"`\n}\n\n// AuditEventDetails represents the details portion of an audit event for\n// a group, a project or the instance. The exact fields that are returned\n// for an audit event depend on the action being recorded.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html\ntype AuditEventDetails struct {\n\tWith          string      `json:\"with\"`\n\tAdd           string      `json:\"add\"`\n\tAs            string      `json:\"as\"`\n\tChange        string      `json:\"change\"`\n\tFrom          string      `json:\"from\"`\n\tTo            string      `json:\"to\"`\n\tRemove        string      `json:\"remove\"`\n\tCustomMessage string      `json:\"custom_message\"`\n\tAuthorName    string      `json:\"author_name\"`\n\tAuthorEmail   string      `json:\"author_email\"`\n\tAuthorClass   string      `json:\"author_class\"`\n\tTargetID      interface{} `json:\"target_id\"`\n\tTargetType    string      `json:\"target_type\"`\n\tTargetDetails string      `json:\"target_details\"`\n\tIPAddress     string      `json:\"ip_address\"`\n\tEntityPath    string      `json:\"entity_path\"`\n\tFailedLogin   string      `json:\"failed_login\"`\n\tEventName     string      `json:\"event_name\"`\n}\n\n// AuditEventsService handles communication with the project/group/instance\n// audit event related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html\ntype AuditEventsService struct {\n\tclient *Client\n}\n\n// ListAuditEventsOptions represents the available ListProjectAuditEvents(),\n// ListGroupAuditEvents() or ListInstanceAuditEvents() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html\ntype ListAuditEventsOptions struct {\n\tListOptions\n\tCreatedAfter  *time.Time `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore *time.Time `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n}\n\n// ListInstanceAuditEvents gets a list of audit events for instance.\n// Authentication as Administrator is required.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html#retrieve-all-instance-audit-events\nfunc (s *AuditEventsService) ListInstanceAuditEvents(opt *ListAuditEventsOptions, options ...RequestOptionFunc) ([]*AuditEvent, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"audit_events\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar aes []*AuditEvent\n\tresp, err := s.client.Do(req, &aes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn aes, resp, nil\n}\n\n// GetInstanceAuditEvent gets a specific instance audit event.\n// Authentication as Administrator is required.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html#retrieve-single-instance-audit-event\nfunc (s *AuditEventsService) GetInstanceAuditEvent(event int, options ...RequestOptionFunc) (*AuditEvent, *Response, error) {\n\tu := fmt.Sprintf(\"audit_events/%d\", event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tae := new(AuditEvent)\n\tresp, err := s.client.Do(req, ae)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ae, resp, nil\n}\n\n// ListGroupAuditEvents gets a list of audit events for the specified group\n// viewable by the authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html#retrieve-all-group-audit-events\nfunc (s *AuditEventsService) ListGroupAuditEvents(gid interface{}, opt *ListAuditEventsOptions, options ...RequestOptionFunc) ([]*AuditEvent, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/audit_events\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar aes []*AuditEvent\n\tresp, err := s.client.Do(req, &aes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn aes, resp, nil\n}\n\n// GetGroupAuditEvent gets a specific group audit event.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html#retrieve-a-specific-group-audit-event\nfunc (s *AuditEventsService) GetGroupAuditEvent(gid interface{}, event int, options ...RequestOptionFunc) (*AuditEvent, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/audit_events/%d\", PathEscape(group), event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tae := new(AuditEvent)\n\tresp, err := s.client.Do(req, ae)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ae, resp, nil\n}\n\n// ListProjectAuditEvents gets a list of audit events for the specified project\n// viewable by the authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/audit_events.html#retrieve-all-project-audit-events\nfunc (s *AuditEventsService) ListProjectAuditEvents(pid interface{}, opt *ListAuditEventsOptions, options ...RequestOptionFunc) ([]*AuditEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/audit_events\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar aes []*AuditEvent\n\tresp, err := s.client.Do(req, &aes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn aes, resp, nil\n}\n\n// GetProjectAuditEvent gets a specific project audit event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/audit_events.html#retrieve-a-specific-project-audit-event\nfunc (s *AuditEventsService) GetProjectAuditEvent(pid interface{}, event int, options ...RequestOptionFunc) (*AuditEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/audit_events/%d\", PathEscape(project), event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tae := new(AuditEvent)\n\tresp, err := s.client.Do(req, ae)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ae, resp, nil\n}\n"
        },
        {
          "name": "audit_events_test.go",
          "type": "blob",
          "size": 10.9716796875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAuditEventsService_ListInstanceAuditEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/audit_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"author_id\": 1,\n\t\t\t\t\"entity_id\": 6,\n\t\t\t\t\"entity_type\": \"Project\",\n\t\t\t\t\"event_name\": \"project_archived\",\n\t\t\t\t\"details\": {\n\t\t\t\t  \"event_name\": \"project_archived\",\n\t\t\t\t  \"custom_message\": \"Project archived\",\n\t\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"target_id\": \"flightjs/flight\",\n\t\t\t\t  \"target_type\": \"Project\",\n\t\t\t\t  \"target_details\": \"flightjs/flight\",\n\t\t\t\t  \"ip_address\": \"127.0.0.1\",\n\t\t\t\t  \"entity_path\": \"flightjs/flight\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AuditEvent{{\n\t\tID:         1,\n\t\tAuthorID:   1,\n\t\tEntityID:   6,\n\t\tEntityType: \"Project\",\n\t\tEventName:  \"project_archived\",\n\t\tDetails: AuditEventDetails{\n\t\t\tEventName:     \"project_archived\",\n\t\t\tCustomMessage: \"Project archived\",\n\t\t\tAuthorName:    \"Venkatesh Thalluri\",\n\t\t\tTargetID:      \"flightjs/flight\",\n\t\t\tTargetType:    \"Project\",\n\t\t\tTargetDetails: \"flightjs/flight\",\n\t\t\tIPAddress:     \"127.0.0.1\",\n\t\t\tEntityPath:    \"flightjs/flight\",\n\t\t},\n\t}}\n\n\taes, resp, err := client.AuditEvents.ListInstanceAuditEvents(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AuditEvents.ListInstanceAuditEvents(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n}\n\nfunc TestAuditEventsService_ListInstanceAuditEvents_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/audit_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\taes, resp, err := client.AuditEvents.ListInstanceAuditEvents(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAuditEventsService_GetInstanceAuditEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/audit_events/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 1,\n\t\t\t\"author_id\": 1,\n\t\t\t\"entity_id\": 6,\n\t\t\t\"entity_type\": \"Project\",\n\t\t\t\"event_name\": \"project_archived\",\n\t\t\t\"details\": {\n\t\t\t  \"event_name\": \"project_archived\",\n\t\t\t  \"custom_message\": \"Project archived\",\n\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t  \"target_id\": \"flightjs/flight\",\n\t\t\t  \"target_type\": \"Project\",\n\t\t\t  \"target_details\": \"flightjs/flight\",\n\t\t\t  \"ip_address\": \"127.0.0.1\",\n\t\t\t  \"entity_path\": \"flightjs/flight\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AuditEvent{\n\t\tID:         1,\n\t\tAuthorID:   1,\n\t\tEntityID:   6,\n\t\tEventName:  \"project_archived\",\n\t\tEntityType: \"Project\",\n\t\tDetails: AuditEventDetails{\n\t\t\tEventName:     \"project_archived\",\n\t\t\tCustomMessage: \"Project archived\",\n\t\t\tAuthorName:    \"Venkatesh Thalluri\",\n\t\t\tTargetID:      \"flightjs/flight\",\n\t\t\tTargetType:    \"Project\",\n\t\t\tTargetDetails: \"flightjs/flight\",\n\t\t\tIPAddress:     \"127.0.0.1\",\n\t\t\tEntityPath:    \"flightjs/flight\",\n\t\t},\n\t}\n\n\tae, resp, err := client.AuditEvents.GetInstanceAuditEvent(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AuditEvents.GetInstanceAuditEvent(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AuditEvents.GetInstanceAuditEvent(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAuditEventsService_ListGroupAuditEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/6/audit_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"author_id\": 1,\n\t\t\t\t\"entity_id\": 6,\n\t\t\t\t\"entity_type\": \"Group\",\n\t\t\t    \"event_name\": \"group_archived\",\n\t\t\t\t\"details\": {\n\t\t\t      \"event_name\": \"group_archived\",\n\t\t\t\t  \"custom_message\": \"Group archived\",\n\t\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"target_id\": \"flightjs/flight\",\n\t\t\t\t  \"target_type\": \"Group\",\n\t\t\t\t  \"target_details\": \"flightjs/flight\",\n\t\t\t\t  \"ip_address\": \"127.0.0.1\",\n\t\t\t\t  \"entity_path\": \"flightjs/flight\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AuditEvent{{\n\t\tID:         1,\n\t\tAuthorID:   1,\n\t\tEntityID:   6,\n\t\tEntityType: \"Group\",\n\t\tEventName:  \"group_archived\",\n\t\tDetails: AuditEventDetails{\n\t\t\tEventName:     \"group_archived\",\n\t\t\tCustomMessage: \"Group archived\",\n\t\t\tAuthorName:    \"Venkatesh Thalluri\",\n\t\t\tTargetID:      \"flightjs/flight\",\n\t\t\tTargetType:    \"Group\",\n\t\t\tTargetDetails: \"flightjs/flight\",\n\t\t\tIPAddress:     \"127.0.0.1\",\n\t\t\tEntityPath:    \"flightjs/flight\",\n\t\t},\n\t}}\n\n\taes, resp, err := client.AuditEvents.ListGroupAuditEvents(6, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AuditEvents.ListGroupAuditEvents(6.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 6.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AuditEvents.ListGroupAuditEvents(6, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AuditEvents.ListGroupAuditEvents(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAuditEventsService_GetGroupAuditEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/6/audit_events/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 1,\n\t\t\t\"author_id\": 1,\n\t\t\t\"entity_id\": 6,\n\t\t\t\"entity_type\": \"Group\",\n\t\t\t\"event_name\": \"group_archived\",\n\t\t\t\"details\": {\n\t\t\t  \"event_name\": \"group_archived\",\n\t\t\t  \"custom_message\": \"Group archived\",\n\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t  \"target_id\": \"flightjs/flight\",\n\t\t\t  \"target_type\": \"Group\",\n\t\t\t  \"target_details\": \"flightjs/flight\",\n\t\t\t  \"ip_address\": \"127.0.0.1\",\n\t\t\t  \"entity_path\": \"flightjs/flight\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AuditEvent{\n\t\tID:         1,\n\t\tAuthorID:   1,\n\t\tEntityID:   6,\n\t\tEntityType: \"Group\",\n\t\tEventName:  \"group_archived\",\n\t\tDetails: AuditEventDetails{\n\t\t\tEventName:     \"group_archived\",\n\t\t\tCustomMessage: \"Group archived\",\n\t\t\tAuthorName:    \"Venkatesh Thalluri\",\n\t\t\tTargetID:      \"flightjs/flight\",\n\t\t\tTargetType:    \"Group\",\n\t\t\tTargetDetails: \"flightjs/flight\",\n\t\t\tIPAddress:     \"127.0.0.1\",\n\t\t\tEntityPath:    \"flightjs/flight\",\n\t\t},\n\t}\n\n\tae, resp, err := client.AuditEvents.GetGroupAuditEvent(6, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AuditEvents.GetGroupAuditEvent(6.01, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 6.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AuditEvents.GetGroupAuditEvent(6, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AuditEvents.GetGroupAuditEvent(3, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAuditEventsService_ListProjectAuditEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/6/audit_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"author_id\": 1,\n\t\t\t\t\"entity_id\": 6,\n\t\t\t\t\"entity_type\": \"Project\",\n\t\t\t\t\"event_name\": \"project_archived\",\n\t\t\t\t\"details\": {\n\t\t\t\t  \"event_name\": \"project_archived\",\n\t\t\t\t  \"custom_message\": \"Project archived\",\n\t\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"target_id\": \"flightjs/flight\",\n\t\t\t\t  \"target_type\": \"Project\",\n\t\t\t\t  \"target_details\": \"flightjs/flight\",\n\t\t\t\t  \"ip_address\": \"127.0.0.1\",\n\t\t\t\t  \"entity_path\": \"flightjs/flight\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AuditEvent{{\n\t\tID:         1,\n\t\tAuthorID:   1,\n\t\tEntityID:   6,\n\t\tEntityType: \"Project\",\n\t\tEventName:  \"project_archived\",\n\t\tDetails: AuditEventDetails{\n\t\t\tEventName:     \"project_archived\",\n\t\t\tCustomMessage: \"Project archived\",\n\t\t\tAuthorName:    \"Venkatesh Thalluri\",\n\t\t\tTargetID:      \"flightjs/flight\",\n\t\t\tTargetType:    \"Project\",\n\t\t\tTargetDetails: \"flightjs/flight\",\n\t\t\tIPAddress:     \"127.0.0.1\",\n\t\t\tEntityPath:    \"flightjs/flight\",\n\t\t},\n\t}}\n\n\taes, resp, err := client.AuditEvents.ListProjectAuditEvents(6, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AuditEvents.ListProjectAuditEvents(6.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 6.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AuditEvents.ListProjectAuditEvents(6, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AuditEvents.ListProjectAuditEvents(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAuditEventsService_GetProjectAuditEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/6/audit_events/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 1,\n\t\t\t\"author_id\": 1,\n\t\t\t\"entity_id\": 6,\n\t\t\t\"entity_type\": \"Project\",\n\t\t\t\"event_name\": \"project_archived\",\n\t\t\t\"details\": {\n\t\t\t  \"event_name\": \"project_archived\",\n\t\t\t  \"custom_message\": \"Project archived\",\n\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t  \"target_id\": \"flightjs/flight\",\n\t\t\t  \"target_type\": \"Project\",\n\t\t\t  \"target_details\": \"flightjs/flight\",\n\t\t\t  \"ip_address\": \"127.0.0.1\",\n\t\t\t  \"entity_path\": \"flightjs/flight\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AuditEvent{\n\t\tID:         1,\n\t\tAuthorID:   1,\n\t\tEntityID:   6,\n\t\tEntityType: \"Project\",\n\t\tEventName:  \"project_archived\",\n\t\tDetails: AuditEventDetails{\n\t\t\tEventName:     \"project_archived\",\n\t\t\tCustomMessage: \"Project archived\",\n\t\t\tAuthorName:    \"Venkatesh Thalluri\",\n\t\t\tTargetID:      \"flightjs/flight\",\n\t\t\tTargetType:    \"Project\",\n\t\t\tTargetDetails: \"flightjs/flight\",\n\t\t\tIPAddress:     \"127.0.0.1\",\n\t\t\tEntityPath:    \"flightjs/flight\",\n\t\t},\n\t}\n\n\tae, resp, err := client.AuditEvents.GetProjectAuditEvent(6, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AuditEvents.GetProjectAuditEvent(6.01, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 6.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AuditEvents.GetProjectAuditEvent(6, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AuditEvents.GetProjectAuditEvent(3, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "avatar.go",
          "type": "blob",
          "size": 1.8544921875,
          "content": "//\n// Copyright 2021, Pavel Kostohrys\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n)\n\n// AvatarRequestsService handles communication with the avatar related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/avatar.html\ntype AvatarRequestsService struct {\n\tclient *Client\n}\n\n// Avatar represents a GitLab avatar.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/avatar.html\ntype Avatar struct {\n\tAvatarURL string `json:\"avatar_url\"`\n}\n\n// GetAvatarOptions represents the available GetAvatar() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/avatar.html#get-a-single-avatar-url\ntype GetAvatarOptions struct {\n\tEmail *string `url:\"email,omitempty\" json:\"email,omitempty\"`\n\tSize  *int    `url:\"size,omitempty\" json:\"size,omitempty\"`\n}\n\n// GetAvatar gets the avatar URL for a user with the given email address.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/avatar.html#get-a-single-avatar-url\nfunc (s *AvatarRequestsService) GetAvatar(opt *GetAvatarOptions, options ...RequestOptionFunc) (*Avatar, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"avatar\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tavatar := new(Avatar)\n\tresponse, err := s.client.Do(req, avatar)\n\tif err != nil {\n\t\treturn nil, response, err\n\t}\n\n\treturn avatar, response, nil\n}\n"
        },
        {
          "name": "avatar_test.go",
          "type": "blob",
          "size": 1.4560546875,
          "content": "//\n// Copyright 2021, Pavel Kostohrys\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestGetAvatar(t *testing.T) {\n\tmux, client := setup(t)\n\n\tconst url = \"https://www.gravatar.com/avatar/10e6bf7bcf22c2f00a3ef684b4ada178\"\n\n\tmux.HandleFunc(\"/api/v4/avatar\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t\tavatar := Avatar{AvatarURL: url}\n\t\t\tresp, _ := json.Marshal(avatar)\n\t\t\t_, _ = w.Write(resp)\n\t\t},\n\t)\n\n\topt := &GetAvatarOptions{Email: Ptr(\"sander@vanharmelen.nnl\")}\n\tavatar, resp, err := client.Avatar.GetAvatar(opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Avatar.GetAvatar returned error: %v\", err)\n\t}\n\n\tif resp.Status != \"202 Accepted\" {\n\t\tt.Fatalf(\"Avatar.GetAvatar returned wrong status code: %v\", resp.Status)\n\t}\n\n\tif url != avatar.AvatarURL {\n\t\tt.Errorf(\"Avatar.GetAvatar wrong result %s, want %s\", avatar.AvatarURL, url)\n\t}\n}\n"
        },
        {
          "name": "award_emojis.go",
          "type": "blob",
          "size": 17.2001953125,
          "content": "//\n// Copyright 2021, Arkbriar\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// AwardEmojiService handles communication with the emoji awards related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/award_emoji.html\ntype AwardEmojiService struct {\n\tclient *Client\n}\n\n// AwardEmoji represents a GitLab Award Emoji.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/award_emoji.html\ntype AwardEmoji struct {\n\tID   int    `json:\"id\"`\n\tName string `json:\"name\"`\n\tUser struct {\n\t\tName      string `json:\"name\"`\n\t\tUsername  string `json:\"username\"`\n\t\tID        int    `json:\"id\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"user\"`\n\tCreatedAt     *time.Time `json:\"created_at\"`\n\tUpdatedAt     *time.Time `json:\"updated_at\"`\n\tAwardableID   int        `json:\"awardable_id\"`\n\tAwardableType string     `json:\"awardable_type\"`\n}\n\nconst (\n\tawardMergeRequest = \"merge_requests\"\n\tawardIssue        = \"issues\"\n\tawardSnippets     = \"snippets\"\n)\n\n// ListAwardEmojiOptions represents the available options for listing emoji\n// for each resources\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html\ntype ListAwardEmojiOptions ListOptions\n\n// ListMergeRequestAwardEmoji gets a list of all award emoji on the merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#list-an-awardables-award-emojis\nfunc (s *AwardEmojiService) ListMergeRequestAwardEmoji(pid interface{}, mergeRequestIID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\treturn s.listAwardEmoji(pid, awardMergeRequest, mergeRequestIID, opt, options...)\n}\n\n// ListIssueAwardEmoji gets a list of all award emoji on the issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#list-an-awardables-award-emojis\nfunc (s *AwardEmojiService) ListIssueAwardEmoji(pid interface{}, issueIID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\treturn s.listAwardEmoji(pid, awardIssue, issueIID, opt, options...)\n}\n\n// ListSnippetAwardEmoji gets a list of all award emoji on the snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#list-an-awardables-award-emojis\nfunc (s *AwardEmojiService) ListSnippetAwardEmoji(pid interface{}, snippetID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\treturn s.listAwardEmoji(pid, awardSnippets, snippetID, opt, options...)\n}\n\nfunc (s *AwardEmojiService) listAwardEmoji(pid interface{}, resource string, resourceID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/award_emoji\",\n\t\tPathEscape(project),\n\t\tresource,\n\t\tresourceID,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar as []*AwardEmoji\n\tresp, err := s.client.Do(req, &as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n\n// GetMergeRequestAwardEmoji get an award emoji from merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#get-single-award-emoji\nfunc (s *AwardEmojiService) GetMergeRequestAwardEmoji(pid interface{}, mergeRequestIID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.getAwardEmoji(pid, awardMergeRequest, mergeRequestIID, awardID, options...)\n}\n\n// GetIssueAwardEmoji get an award emoji from issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#get-single-award-emoji\nfunc (s *AwardEmojiService) GetIssueAwardEmoji(pid interface{}, issueIID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.getAwardEmoji(pid, awardIssue, issueIID, awardID, options...)\n}\n\n// GetSnippetAwardEmoji get an award emoji from snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#get-single-award-emoji\nfunc (s *AwardEmojiService) GetSnippetAwardEmoji(pid interface{}, snippetID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.getAwardEmoji(pid, awardSnippets, snippetID, awardID, options...)\n}\n\nfunc (s *AwardEmojiService) getAwardEmoji(pid interface{}, resource string, resourceID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/award_emoji/%d\",\n\t\tPathEscape(project),\n\t\tresource,\n\t\tresourceID,\n\t\tawardID,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(AwardEmoji)\n\tresp, err := s.client.Do(req, &a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// CreateAwardEmojiOptions represents the available options for awarding emoji\n// for a resource\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji\ntype CreateAwardEmojiOptions struct {\n\tName string `json:\"name\"`\n}\n\n// CreateMergeRequestAwardEmoji get an award emoji from merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji\nfunc (s *AwardEmojiService) CreateMergeRequestAwardEmoji(pid interface{}, mergeRequestIID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.createAwardEmoji(pid, awardMergeRequest, mergeRequestIID, opt, options...)\n}\n\n// CreateIssueAwardEmoji get an award emoji from issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji\nfunc (s *AwardEmojiService) CreateIssueAwardEmoji(pid interface{}, issueIID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.createAwardEmoji(pid, awardIssue, issueIID, opt, options...)\n}\n\n// CreateSnippetAwardEmoji get an award emoji from snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji\nfunc (s *AwardEmojiService) CreateSnippetAwardEmoji(pid interface{}, snippetID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.createAwardEmoji(pid, awardSnippets, snippetID, opt, options...)\n}\n\nfunc (s *AwardEmojiService) createAwardEmoji(pid interface{}, resource string, resourceID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/award_emoji\",\n\t\tPathEscape(project),\n\t\tresource,\n\t\tresourceID,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(AwardEmoji)\n\tresp, err := s.client.Do(req, &a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// DeleteIssueAwardEmoji delete award emoji on an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji\nfunc (s *AwardEmojiService) DeleteIssueAwardEmoji(pid interface{}, issueIID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteAwardEmoji(pid, awardIssue, issueIID, awardID, options...)\n}\n\n// DeleteMergeRequestAwardEmoji delete award emoji on a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji\nfunc (s *AwardEmojiService) DeleteMergeRequestAwardEmoji(pid interface{}, mergeRequestIID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteAwardEmoji(pid, awardMergeRequest, mergeRequestIID, awardID, options...)\n}\n\n// DeleteSnippetAwardEmoji delete award emoji on a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji\nfunc (s *AwardEmojiService) DeleteSnippetAwardEmoji(pid interface{}, snippetID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteAwardEmoji(pid, awardSnippets, snippetID, awardID, options...)\n}\n\n// DeleteAwardEmoji Delete an award emoji on the specified resource.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji\nfunc (s *AwardEmojiService) deleteAwardEmoji(pid interface{}, resource string, resourceID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/award_emoji/%d\", PathEscape(project), resource,\n\t\tresourceID, awardID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.client.Do(req, nil)\n}\n\n// ListIssuesAwardEmojiOnNote gets a list of all award emoji on a note from the\n// issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#list-a-comments-award-emojis\nfunc (s *AwardEmojiService) ListIssuesAwardEmojiOnNote(pid interface{}, issueID, noteID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\treturn s.listAwardEmojiOnNote(pid, awardIssue, issueID, noteID, opt, options...)\n}\n\n// ListMergeRequestAwardEmojiOnNote gets a list of all award emoji on a note\n// from the merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#list-a-comments-award-emojis\nfunc (s *AwardEmojiService) ListMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID, noteID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\treturn s.listAwardEmojiOnNote(pid, awardMergeRequest, mergeRequestIID, noteID, opt, options...)\n}\n\n// ListSnippetAwardEmojiOnNote gets a list of all award emoji on a note from the\n// snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#list-a-comments-award-emojis\nfunc (s *AwardEmojiService) ListSnippetAwardEmojiOnNote(pid interface{}, snippetIID, noteID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\treturn s.listAwardEmojiOnNote(pid, awardSnippets, snippetIID, noteID, opt, options...)\n}\n\nfunc (s *AwardEmojiService) listAwardEmojiOnNote(pid interface{}, resources string, ressourceID, noteID int, opt *ListAwardEmojiOptions, options ...RequestOptionFunc) ([]*AwardEmoji, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/notes/%d/award_emoji\", PathEscape(project), resources,\n\t\tressourceID, noteID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar as []*AwardEmoji\n\tresp, err := s.client.Do(req, &as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n\n// GetIssuesAwardEmojiOnNote gets an award emoji on a note from an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#get-an-award-emoji-for-a-comment\nfunc (s *AwardEmojiService) GetIssuesAwardEmojiOnNote(pid interface{}, issueID, noteID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.getSingleNoteAwardEmoji(pid, awardIssue, issueID, noteID, awardID, options...)\n}\n\n// GetMergeRequestAwardEmojiOnNote gets an award emoji on a note from a\n// merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#get-an-award-emoji-for-a-comment\nfunc (s *AwardEmojiService) GetMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID, noteID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.getSingleNoteAwardEmoji(pid, awardMergeRequest, mergeRequestIID, noteID, awardID,\n\t\toptions...)\n}\n\n// GetSnippetAwardEmojiOnNote gets an award emoji on a note from a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#get-an-award-emoji-for-a-comment\nfunc (s *AwardEmojiService) GetSnippetAwardEmojiOnNote(pid interface{}, snippetIID, noteID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.getSingleNoteAwardEmoji(pid, awardSnippets, snippetIID, noteID, awardID, options...)\n}\n\nfunc (s *AwardEmojiService) getSingleNoteAwardEmoji(pid interface{}, ressource string, resourceID, noteID, awardID int, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/notes/%d/award_emoji/%d\",\n\t\tPathEscape(project),\n\t\tressource,\n\t\tresourceID,\n\t\tnoteID,\n\t\tawardID,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(AwardEmoji)\n\tresp, err := s.client.Do(req, &a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// CreateIssuesAwardEmojiOnNote gets an award emoji on a note from an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji-on-a-comment\nfunc (s *AwardEmojiService) CreateIssuesAwardEmojiOnNote(pid interface{}, issueID, noteID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.createAwardEmojiOnNote(pid, awardIssue, issueID, noteID, opt, options...)\n}\n\n// CreateMergeRequestAwardEmojiOnNote gets an award emoji on a note from a\n// merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji-on-a-comment\nfunc (s *AwardEmojiService) CreateMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID, noteID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.createAwardEmojiOnNote(pid, awardMergeRequest, mergeRequestIID, noteID, opt, options...)\n}\n\n// CreateSnippetAwardEmojiOnNote gets an award emoji on a note from a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji-on-a-comment\nfunc (s *AwardEmojiService) CreateSnippetAwardEmojiOnNote(pid interface{}, snippetIID, noteID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\treturn s.createAwardEmojiOnNote(pid, awardSnippets, snippetIID, noteID, opt, options...)\n}\n\n// CreateAwardEmojiOnNote award emoji on a note.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#award-a-new-emoji-on-a-comment\nfunc (s *AwardEmojiService) createAwardEmojiOnNote(pid interface{}, resource string, resourceID, noteID int, opt *CreateAwardEmojiOptions, options ...RequestOptionFunc) (*AwardEmoji, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/notes/%d/award_emoji\",\n\t\tPathEscape(project),\n\t\tresource,\n\t\tresourceID,\n\t\tnoteID,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(AwardEmoji)\n\tresp, err := s.client.Do(req, &a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// DeleteIssuesAwardEmojiOnNote deletes an award emoji on a note from an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji-from-a-comment\nfunc (s *AwardEmojiService) DeleteIssuesAwardEmojiOnNote(pid interface{}, issueID, noteID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteAwardEmojiOnNote(pid, awardIssue, issueID, noteID, awardID, options...)\n}\n\n// DeleteMergeRequestAwardEmojiOnNote deletes an award emoji on a note from a\n// merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji-from-a-comment\nfunc (s *AwardEmojiService) DeleteMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID, noteID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteAwardEmojiOnNote(pid, awardMergeRequest, mergeRequestIID, noteID, awardID,\n\t\toptions...)\n}\n\n// DeleteSnippetAwardEmojiOnNote deletes an award emoji on a note from a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/award_emoji.html#delete-an-award-emoji-from-a-comment\nfunc (s *AwardEmojiService) DeleteSnippetAwardEmojiOnNote(pid interface{}, snippetIID, noteID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteAwardEmojiOnNote(pid, awardSnippets, snippetIID, noteID, awardID, options...)\n}\n\nfunc (s *AwardEmojiService) deleteAwardEmojiOnNote(pid interface{}, resource string, resourceID, noteID, awardID int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/notes/%d/award_emoji/%d\",\n\t\tPathEscape(project),\n\t\tresource,\n\t\tresourceID,\n\t\tnoteID,\n\t\tawardID,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "award_emojis_test.go",
          "type": "blob",
          "size": 41.390625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestAwardEmojiService_ListMergeRequestAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"1234\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"awardable_id\": 80,\n\t\t\t\t\"awardable_type\": \"Merge request\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AwardEmoji{{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Merge request\",\n\t}}\n\n\taes, resp, err := client.AwardEmoji.ListMergeRequestAwardEmoji(1, 80, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AwardEmoji.ListMergeRequestAwardEmoji(1.01, 80, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListMergeRequestAwardEmoji(1, 80, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListMergeRequestAwardEmoji(3, 80, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_ListIssueAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"1234\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"awardable_id\": 80,\n\t\t\t\t\"awardable_type\": \"Issue\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AwardEmoji{{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Issue\",\n\t}}\n\n\taes, resp, err := client.AwardEmoji.ListIssueAwardEmoji(1, 80, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AwardEmoji.ListIssueAwardEmoji(1.01, 80, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListIssueAwardEmoji(1, 80, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListIssueAwardEmoji(3, 80, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_ListSnippetAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"1234\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"awardable_id\": 80,\n\t\t\t\t\"awardable_type\": \"Snippet\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AwardEmoji{{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Snippet\",\n\t}}\n\n\taes, resp, err := client.AwardEmoji.ListSnippetAwardEmoji(1, 80, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AwardEmoji.ListSnippetAwardEmoji(1.01, 80, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListSnippetAwardEmoji(1, 80, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListSnippetAwardEmoji(3, 80, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_GetMergeRequestAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/award_emoji/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Merge request\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Merge request\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.GetMergeRequestAwardEmoji(1, 80, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.GetMergeRequestAwardEmoji(1.01, 80, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetMergeRequestAwardEmoji(1, 80, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetMergeRequestAwardEmoji(3, 80, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_GetIssueAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/award_emoji/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Issue\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Issue\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.GetIssueAwardEmoji(1, 80, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.GetIssueAwardEmoji(1.01, 80, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetIssueAwardEmoji(1, 80, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetIssueAwardEmoji(3, 80, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_GetSnippetAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/award_emoji/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Snippet\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Snippet\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.GetSnippetAwardEmoji(1, 80, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.GetSnippetAwardEmoji(1.01, 80, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetSnippetAwardEmoji(1, 80, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetSnippetAwardEmoji(3, 80, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_CreateMergeRequestAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Merge request\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Merge request\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.CreateMergeRequestAwardEmoji(1, 80, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateMergeRequestAwardEmoji(1.01, 80, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateMergeRequestAwardEmoji(1, 80, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateMergeRequestAwardEmoji(3, 80, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_CreateIssueAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Issue\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Issue\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.CreateIssueAwardEmoji(1, 80, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateIssueAwardEmoji(1.01, 80, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateIssueAwardEmoji(1, 80, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateIssueAwardEmoji(3, 80, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_CreateSnippetAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Snippet\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Snippet\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.CreateSnippetAwardEmoji(1, 80, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateSnippetAwardEmoji(1.01, 80, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateSnippetAwardEmoji(1, 80, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateSnippetAwardEmoji(3, 80, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_DeleteMergeRequestAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/award_emoji/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AwardEmoji.DeleteMergeRequestAwardEmoji(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteMergeRequestAwardEmoji(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteMergeRequestAwardEmoji(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteMergeRequestAwardEmoji(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_DeleteIssueAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/award_emoji/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AwardEmoji.DeleteIssueAwardEmoji(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteIssueAwardEmoji(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteIssueAwardEmoji(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteIssueAwardEmoji(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_DeleteSnippetAwardEmoji(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/award_emoji/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AwardEmoji.DeleteSnippetAwardEmoji(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteSnippetAwardEmoji(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteSnippetAwardEmoji(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteSnippetAwardEmoji(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_ListMergeRequestAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/notes/1/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"1234\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"awardable_id\": 80,\n\t\t\t\t\"awardable_type\": \"Merge request\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AwardEmoji{{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Merge request\",\n\t}}\n\n\taes, resp, err := client.AwardEmoji.ListMergeRequestAwardEmojiOnNote(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AwardEmoji.ListMergeRequestAwardEmojiOnNote(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListMergeRequestAwardEmojiOnNote(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListMergeRequestAwardEmojiOnNote(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_ListIssuesAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/notes/1/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"1234\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"awardable_id\": 80,\n\t\t\t\t\"awardable_type\": \"Issue\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AwardEmoji{{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Issue\",\n\t}}\n\n\taes, resp, err := client.AwardEmoji.ListIssuesAwardEmojiOnNote(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AwardEmoji.ListIssuesAwardEmojiOnNote(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListIssuesAwardEmojiOnNote(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListIssuesAwardEmojiOnNote(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_ListSnippetAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/notes/1/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"1234\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"awardable_id\": 80,\n\t\t\t\t\"awardable_type\": \"Snippet\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*AwardEmoji{{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Snippet\",\n\t}}\n\n\taes, resp, err := client.AwardEmoji.ListSnippetAwardEmojiOnNote(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, aes)\n\n\taes, resp, err = client.AwardEmoji.ListSnippetAwardEmojiOnNote(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListSnippetAwardEmojiOnNote(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, aes)\n\n\taes, resp, err = client.AwardEmoji.ListSnippetAwardEmojiOnNote(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, aes)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_GetMergeRequestAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/notes/1/award_emoji/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Merge request\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Merge request\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.GetMergeRequestAwardEmojiOnNote(1, 80, 1, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.GetMergeRequestAwardEmojiOnNote(1.01, 80, 1, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetMergeRequestAwardEmojiOnNote(1, 80, 1, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetMergeRequestAwardEmojiOnNote(3, 80, 1, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_GetIssuesAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/notes/1/award_emoji/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Issue\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Issue\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.GetIssuesAwardEmojiOnNote(1, 80, 1, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.GetIssuesAwardEmojiOnNote(1.01, 80, 1, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetIssuesAwardEmojiOnNote(1, 80, 1, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetIssuesAwardEmojiOnNote(3, 80, 1, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_GetSnippetAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/notes/1/award_emoji/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Snippet\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Snippet\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.GetSnippetAwardEmojiOnNote(1, 80, 1, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.GetSnippetAwardEmojiOnNote(1.01, 80, 1, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetSnippetAwardEmojiOnNote(1, 80, 1, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.GetSnippetAwardEmojiOnNote(3, 80, 1, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_CCreateMergeRequestAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/notes/1/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Merge request\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Merge request\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.CreateMergeRequestAwardEmojiOnNote(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateMergeRequestAwardEmojiOnNote(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateMergeRequestAwardEmojiOnNote(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateMergeRequestAwardEmojiOnNote(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_CreateIssuesAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/notes/1/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Issue\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Issue\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.CreateIssuesAwardEmojiOnNote(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateIssuesAwardEmojiOnNote(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateIssuesAwardEmojiOnNote(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateIssuesAwardEmojiOnNote(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_CreateSnippetAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/notes/1/award_emoji\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 4,\n\t\t\t\"name\": \"1234\",\n\t\t\t\"user\": {\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/venky333\"\n\t\t\t},\n\t\t\t\"awardable_id\": 80,\n\t\t\t\"awardable_type\": \"Snippet\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &AwardEmoji{\n\t\tID:   4,\n\t\tName: \"1234\",\n\t\tUser: struct {\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tID        int    `json:\"id\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tUsername:  \"venky333\",\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/venky333\",\n\t\t},\n\t\tCreatedAt:     nil,\n\t\tUpdatedAt:     nil,\n\t\tAwardableID:   80,\n\t\tAwardableType: \"Snippet\",\n\t}\n\n\tae, resp, err := client.AwardEmoji.CreateSnippetAwardEmojiOnNote(1, 80, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateSnippetAwardEmojiOnNote(1.01, 80, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateSnippetAwardEmojiOnNote(1, 80, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ae)\n\n\tae, resp, err = client.AwardEmoji.CreateSnippetAwardEmojiOnNote(3, 80, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ae)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_DeleteMergeRequestAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/80/notes/1/award_emoji/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AwardEmoji.DeleteMergeRequestAwardEmojiOnNote(1, 80, 1, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteMergeRequestAwardEmojiOnNote(1.01, 80, 1, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteMergeRequestAwardEmojiOnNote(1, 80, 1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteMergeRequestAwardEmojiOnNote(3, 80, 1, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_DeleteIssuesAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/80/notes/1/award_emoji/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AwardEmoji.DeleteIssuesAwardEmojiOnNote(1, 80, 1, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteIssuesAwardEmojiOnNote(1.01, 80, 1, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteIssuesAwardEmojiOnNote(1, 80, 1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteIssuesAwardEmojiOnNote(3, 80, 1, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAwardEmojiService_DeleteSnippetAwardEmojiOnNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/80/notes/1/award_emoji/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.AwardEmoji.DeleteSnippetAwardEmojiOnNote(1, 80, 1, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteSnippetAwardEmojiOnNote(1.01, 80, 1, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteSnippetAwardEmojiOnNote(1, 80, 1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.AwardEmoji.DeleteSnippetAwardEmojiOnNote(3, 80, 1, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "boards.go",
          "type": "blob",
          "size": 10.9697265625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// IssueBoardsService handles communication with the issue board related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html\ntype IssueBoardsService struct {\n\tclient *Client\n}\n\n// IssueBoard represents a GitLab issue board.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html\ntype IssueBoard struct {\n\tID        int        `json:\"id\"`\n\tName      string     `json:\"name\"`\n\tProject   *Project   `json:\"project\"`\n\tMilestone *Milestone `json:\"milestone\"`\n\tAssignee  *struct {\n\t\tID        int    `json:\"id\"`\n\t\tUsername  string `json:\"username\"`\n\t\tName      string `json:\"name\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"assignee\"`\n\tLists  []*BoardList    `json:\"lists\"`\n\tWeight int             `json:\"weight\"`\n\tLabels []*LabelDetails `json:\"labels\"`\n}\n\nfunc (b IssueBoard) String() string {\n\treturn Stringify(b)\n}\n\n// BoardList represents a GitLab board list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html\ntype BoardList struct {\n\tID       int `json:\"id\"`\n\tAssignee *struct {\n\t\tID       int    `json:\"id\"`\n\t\tName     string `json:\"name\"`\n\t\tUsername string `json:\"username\"`\n\t} `json:\"assignee\"`\n\tIteration      *ProjectIteration `json:\"iteration\"`\n\tLabel          *Label            `json:\"label\"`\n\tMaxIssueCount  int               `json:\"max_issue_count\"`\n\tMaxIssueWeight int               `json:\"max_issue_weight\"`\n\tMilestone      *Milestone        `json:\"milestone\"`\n\tPosition       int               `json:\"position\"`\n}\n\nfunc (b BoardList) String() string {\n\treturn Stringify(b)\n}\n\n// CreateIssueBoardOptions represents the available CreateIssueBoard() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#create-an-issue-board\ntype CreateIssueBoardOptions struct {\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// CreateIssueBoard creates a new issue board.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#create-an-issue-board\nfunc (s *IssueBoardsService) CreateIssueBoard(pid interface{}, opt *CreateIssueBoardOptions, options ...RequestOptionFunc) (*IssueBoard, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tboard := new(IssueBoard)\n\tresp, err := s.client.Do(req, board)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn board, resp, nil\n}\n\n// UpdateIssueBoardOptions represents the available UpdateIssueBoard() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#update-an-issue-board\ntype UpdateIssueBoardOptions struct {\n\tName        *string       `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tAssigneeID  *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tMilestoneID *int          `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tLabels      *LabelOptions `url:\"labels,omitempty\" json:\"labels,omitempty\"`\n\tWeight      *int          `url:\"weight,omitempty\" json:\"weight,omitempty\"`\n}\n\n// UpdateIssueBoard update an issue board.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#update-an-issue-board\nfunc (s *IssueBoardsService) UpdateIssueBoard(pid interface{}, board int, opt *UpdateIssueBoardOptions, options ...RequestOptionFunc) (*IssueBoard, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d\", PathEscape(project), board)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tis := new(IssueBoard)\n\tresp, err := s.client.Do(req, is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// DeleteIssueBoard deletes an issue board.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#delete-an-issue-board\nfunc (s *IssueBoardsService) DeleteIssueBoard(pid interface{}, board int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d\", PathEscape(project), board)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListIssueBoardsOptions represents the available ListIssueBoards() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#list-project-issue-boards\ntype ListIssueBoardsOptions ListOptions\n\n// ListIssueBoards gets a list of all issue boards in a project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#list-project-issue-boards\nfunc (s *IssueBoardsService) ListIssueBoards(pid interface{}, opt *ListIssueBoardsOptions, options ...RequestOptionFunc) ([]*IssueBoard, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar is []*IssueBoard\n\tresp, err := s.client.Do(req, &is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// GetIssueBoard gets a single issue board of a project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#show-a-single-issue-board\nfunc (s *IssueBoardsService) GetIssueBoard(pid interface{}, board int, options ...RequestOptionFunc) (*IssueBoard, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d\", PathEscape(project), board)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tib := new(IssueBoard)\n\tresp, err := s.client.Do(req, ib)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ib, resp, nil\n}\n\n// GetIssueBoardListsOptions represents the available GetIssueBoardLists() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#list-board-lists-in-a-project-issue-board\ntype GetIssueBoardListsOptions ListOptions\n\n// GetIssueBoardLists gets a list of the issue board's lists. Does not include\n// backlog and closed lists.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#list-board-lists-in-a-project-issue-board\nfunc (s *IssueBoardsService) GetIssueBoardLists(pid interface{}, board int, opt *GetIssueBoardListsOptions, options ...RequestOptionFunc) ([]*BoardList, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d/lists\", PathEscape(project), board)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bl []*BoardList\n\tresp, err := s.client.Do(req, &bl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bl, resp, nil\n}\n\n// GetIssueBoardList gets a single issue board list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#show-a-single-board-list\nfunc (s *IssueBoardsService) GetIssueBoardList(pid interface{}, board, list int, options ...RequestOptionFunc) (*BoardList, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d/lists/%d\",\n\t\tPathEscape(project),\n\t\tboard,\n\t\tlist,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tbl := new(BoardList)\n\tresp, err := s.client.Do(req, bl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bl, resp, nil\n}\n\n// CreateIssueBoardListOptions represents the available CreateIssueBoardList()\n// options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#create-a-board-list\ntype CreateIssueBoardListOptions struct {\n\tLabelID     *int `url:\"label_id,omitempty\" json:\"label_id,omitempty\"`\n\tAssigneeID  *int `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tMilestoneID *int `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tIterationID *int `url:\"iteration_id,omitempty\" json:\"iteration_id,omitempty\"`\n}\n\n// CreateIssueBoardList creates a new issue board list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#create-a-board-list\nfunc (s *IssueBoardsService) CreateIssueBoardList(pid interface{}, board int, opt *CreateIssueBoardListOptions, options ...RequestOptionFunc) (*BoardList, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d/lists\", PathEscape(project), board)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tbl := new(BoardList)\n\tresp, err := s.client.Do(req, bl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bl, resp, nil\n}\n\n// UpdateIssueBoardListOptions represents the available UpdateIssueBoardList()\n// options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#reorder-a-list-in-a-board\ntype UpdateIssueBoardListOptions struct {\n\tPosition *int `url:\"position\" json:\"position\"`\n}\n\n// UpdateIssueBoardList updates the position of an existing issue board list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/boards.html#reorder-a-list-in-a-board\nfunc (s *IssueBoardsService) UpdateIssueBoardList(pid interface{}, board, list int, opt *UpdateIssueBoardListOptions, options ...RequestOptionFunc) (*BoardList, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d/lists/%d\",\n\t\tPathEscape(project),\n\t\tboard,\n\t\tlist,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tbl := new(BoardList)\n\tresp, err := s.client.Do(req, bl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bl, resp, nil\n}\n\n// DeleteIssueBoardList soft deletes an issue board list. Only for admins and\n// project owners.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/boards.html#delete-a-board-list-from-a-board\nfunc (s *IssueBoardsService) DeleteIssueBoardList(pid interface{}, board, list int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/boards/%d/lists/%d\",\n\t\tPathEscape(project),\n\t\tboard,\n\t\tlist,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "boards_test.go",
          "type": "blob",
          "size": 17.31640625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIssueBoardsService_CreateIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"project\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"name\": \"Diaspora Project Site\",\n\t\t\t\t  \"name_with_namespace\": \"Diaspora / Diaspora Project Site\",\n\t\t\t\t  \"path\": \"diaspora-project-site\",\n\t\t\t\t  \"path_with_namespace\": \"diaspora/diaspora-project-site\",\n\t\t\t\t  \"http_url_to_repo\": \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\t\t  \"web_url\": \"http://example.com/diaspora/diaspora-project-site\"\n\t\t\t\t},\n\t\t\t\t\"name\": \"newboard\",\n\t\t\t\t\"lists\" : [],\n\t\t\t\t\"group\": null,\n\t\t\t\t\"milestone\": null,\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [],\n\t\t\t\t\"weight\" : null\n\t\t\t  }\n\t\t`)\n\t})\n\n\twant := &IssueBoard{\n\t\tID:   1,\n\t\tName: \"newboard\",\n\t\tProject: &Project{\n\t\t\tID:                5,\n\t\t\tHTTPURLToRepo:     \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\tWebURL:            \"http://example.com/diaspora/diaspora-project-site\",\n\t\t\tName:              \"Diaspora Project Site\",\n\t\t\tNameWithNamespace: \"Diaspora / Diaspora Project Site\",\n\t\t\tPath:              \"diaspora-project-site\",\n\t\t\tPathWithNamespace: \"diaspora/diaspora-project-site\",\n\t\t},\n\t\tLists:  []*BoardList{},\n\t\tLabels: []*LabelDetails{},\n\t}\n\n\tib, resp, err := client.Boards.CreateIssueBoard(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ib)\n\n\tib, resp, err = client.Boards.CreateIssueBoard(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ib)\n\n\tib, resp, err = client.Boards.CreateIssueBoard(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ib)\n\n\tib, resp, err = client.Boards.CreateIssueBoard(7, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_UpdateIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"project\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"name\": \"Diaspora Project Site\",\n\t\t\t\t  \"name_with_namespace\": \"Diaspora / Diaspora Project Site\",\n\t\t\t\t  \"path\": \"diaspora-project-site\",\n\t\t\t\t  \"path_with_namespace\": \"diaspora/diaspora-project-site\",\n\t\t\t\t  \"http_url_to_repo\": \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\t\t  \"web_url\": \"http://example.com/diaspora/diaspora-project-site\"\n\t\t\t\t},\n\t\t\t\t\"name\": \"new_name\",\n\t\t\t\t\"lists\" : [],\n\t\t\t\t\"group\": null,\n\t\t\t\t\"milestone\": null,\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [],\n\t\t\t\t\"weight\" : null\n\t\t\t  }\n\t\t`)\n\t})\n\n\twant := &IssueBoard{\n\t\tID:   1,\n\t\tName: \"new_name\",\n\t\tProject: &Project{\n\t\t\tID:                5,\n\t\t\tHTTPURLToRepo:     \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\tWebURL:            \"http://example.com/diaspora/diaspora-project-site\",\n\t\t\tName:              \"Diaspora Project Site\",\n\t\t\tNameWithNamespace: \"Diaspora / Diaspora Project Site\",\n\t\t\tPath:              \"diaspora-project-site\",\n\t\t\tPathWithNamespace: \"diaspora/diaspora-project-site\",\n\t\t},\n\t\tLists:  []*BoardList{},\n\t\tLabels: []*LabelDetails{},\n\t}\n\n\tib, resp, err := client.Boards.UpdateIssueBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ib)\n\n\tib, resp, err = client.Boards.UpdateIssueBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ib)\n\n\tib, resp, err = client.Boards.UpdateIssueBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ib)\n\n\tib, resp, err = client.Boards.UpdateIssueBoard(7, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_DeleteIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Boards.DeleteIssueBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Boards.DeleteIssueBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Boards.DeleteIssueBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Boards.DeleteIssueBoard(7, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_ListIssueBoards(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"name\": \"board1\",\n\t\t\t\t\"project\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"name\": \"Diaspora Project Site\",\n\t\t\t\t  \"name_with_namespace\": \"Diaspora / Diaspora Project Site\",\n\t\t\t\t  \"path\": \"diaspora-project-site\",\n\t\t\t\t  \"path_with_namespace\": \"diaspora/diaspora-project-site\",\n\t\t\t\t  \"http_url_to_repo\": \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\t\t  \"web_url\": \"http://example.com/diaspora/diaspora-project-site\"\n\t\t\t\t},\n\t\t\t\t\"milestone\":   {\n\t\t\t\t  \"id\": 12,\n\t\t\t\t  \"title\": \"10.0\"\n\t\t\t\t},\n\t\t\t\t\"lists\" : [\n\t\t\t\t  {\n\t\t\t\t\t\"id\" : 1,\n\t\t\t\t\t\"label\" : {\n\t\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t\t  \"description\" : null\n\t\t\t\t\t},\n\t\t\t\t\t\"position\" : 1,\n\t\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\t\"limit_metric\": null\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"id\" : 2,\n\t\t\t\t\t\"label\" : {\n\t\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t\t  \"description\" : null\n\t\t\t\t\t},\n\t\t\t\t\t\"position\" : 2,\n\t\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\t\"limit_metric\":  null\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"id\" : 3,\n\t\t\t\t\t\"label\" : {\n\t\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t\t  \"description\" : null\n\t\t\t\t\t},\n\t\t\t\t\t\"position\" : 3,\n\t\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\t\"limit_metric\":  null\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*IssueBoard{{\n\t\tID:   1,\n\t\tName: \"board1\",\n\t\tProject: &Project{\n\t\t\tID:                5,\n\t\t\tHTTPURLToRepo:     \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\tWebURL:            \"http://example.com/diaspora/diaspora-project-site\",\n\t\t\tName:              \"Diaspora Project Site\",\n\t\t\tNameWithNamespace: \"Diaspora / Diaspora Project Site\",\n\t\t\tPath:              \"diaspora-project-site\",\n\t\t\tPathWithNamespace: \"diaspora/diaspora-project-site\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:    12,\n\t\t\tTitle: \"10.0\",\n\t\t},\n\t\tLists: []*BoardList{\n\t\t\t{\n\t\t\t\tID: 1,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:  \"Testing\",\n\t\t\t\t\tColor: \"#F0AD4E\",\n\t\t\t\t}, Position: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 2,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:  \"Ready\",\n\t\t\t\t\tColor: \"#FF0000\",\n\t\t\t\t},\n\t\t\t\tPosition: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 3,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:  \"Production\",\n\t\t\t\t\tColor: \"#FF5F00\",\n\t\t\t\t},\n\t\t\t\tPosition: 3,\n\t\t\t},\n\t\t},\n\t}}\n\n\tibs, resp, err := client.Boards.ListIssueBoards(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ibs)\n\n\tibs, resp, err = client.Boards.ListIssueBoards(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ibs)\n\n\tibs, resp, err = client.Boards.ListIssueBoards(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ibs)\n\n\tibs, resp, err = client.Boards.ListIssueBoards(7, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ibs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_GetIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\" : 1,\n\t\t\t\"name\": \"board1\",\n\t\t\t\"project\": {\n\t\t\t  \"id\": 5,\n\t\t\t  \"name\": \"Diaspora Project Site\",\n\t\t\t  \"name_with_namespace\": \"Diaspora / Diaspora Project Site\",\n\t\t\t  \"path\": \"diaspora-project-site\",\n\t\t\t  \"path_with_namespace\": \"diaspora/diaspora-project-site\",\n\t\t\t  \"http_url_to_repo\": \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\t  \"web_url\": \"http://example.com/diaspora/diaspora-project-site\"\n\t\t\t},\n\t\t\t\"milestone\":   {\n\t\t\t  \"id\": 12,\n\t\t\t  \"title\": \"10.0\"\n\t\t\t},\n\t\t\t\"lists\" : [\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 1,\n\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\"limit_metric\": null\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 2,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 2,\n\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\"limit_metric\":  null\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 3,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 3,\n\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\"limit_metric\":  null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &IssueBoard{\n\t\tID:   1,\n\t\tName: \"board1\",\n\t\tProject: &Project{\n\t\t\tID:                5,\n\t\t\tHTTPURLToRepo:     \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\tWebURL:            \"http://example.com/diaspora/diaspora-project-site\",\n\t\t\tName:              \"Diaspora Project Site\",\n\t\t\tNameWithNamespace: \"Diaspora / Diaspora Project Site\",\n\t\t\tPath:              \"diaspora-project-site\",\n\t\t\tPathWithNamespace: \"diaspora/diaspora-project-site\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:    12,\n\t\t\tTitle: \"10.0\",\n\t\t},\n\t\tLists: []*BoardList{\n\t\t\t{\n\t\t\t\tID: 1,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:  \"Testing\",\n\t\t\t\t\tColor: \"#F0AD4E\",\n\t\t\t\t},\n\t\t\t\tPosition: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 2,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:  \"Ready\",\n\t\t\t\t\tColor: \"#FF0000\",\n\t\t\t\t},\n\t\t\t\tPosition: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 3,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:  \"Production\",\n\t\t\t\t\tColor: \"#FF5F00\",\n\t\t\t\t},\n\t\t\t\tPosition: 3,\n\t\t\t},\n\t\t},\n\t}\n\n\tib, resp, err := client.Boards.GetIssueBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ib)\n\n\tib, resp, err = client.Boards.GetIssueBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ib)\n\n\tib, resp, err = client.Boards.GetIssueBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ib)\n\n\tib, resp, err = client.Boards.GetIssueBoard(7, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_GetIssueBoardLists(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1/lists\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 1,\n\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\"limit_metric\":  null\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 2,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 2,\n\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\"limit_metric\":  null\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 3,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 3,\n\t\t\t\t\"max_issue_count\": 0,\n\t\t\t\t\"max_issue_weight\": 0,\n\t\t\t\t\"limit_metric\":  null\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*BoardList{\n\t\t{\n\t\t\tID: 1,\n\t\t\tLabel: &Label{\n\t\t\t\tName:  \"Testing\",\n\t\t\t\tColor: \"#F0AD4E\",\n\t\t\t},\n\t\t\tPosition: 1,\n\t\t},\n\t\t{\n\t\t\tID: 2,\n\t\t\tLabel: &Label{\n\t\t\t\tName:  \"Ready\",\n\t\t\t\tColor: \"#FF0000\",\n\t\t\t},\n\t\t\tPosition: 2,\n\t\t},\n\t\t{\n\t\t\tID: 3,\n\t\t\tLabel: &Label{\n\t\t\t\tName:  \"Production\",\n\t\t\t\tColor: \"#FF5F00\",\n\t\t\t},\n\t\t\tPosition: 3,\n\t\t},\n\t}\n\n\tbls, resp, err := client.Boards.GetIssueBoardLists(5, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bls)\n\n\tbls, resp, err = client.Boards.GetIssueBoardLists(5.01, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bls)\n\n\tbls, resp, err = client.Boards.GetIssueBoardLists(5, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bls)\n\n\tbls, resp, err = client.Boards.GetIssueBoardLists(3, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bls)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_GetIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1/lists/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\" : 1,\n\t\t\t\"label\" : {\n\t\t\t  \"name\" : \"Testing\",\n\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t  \"description\" : null\n\t\t\t},\n\t\t\t\"position\" : 1,\n\t\t\t\"max_issue_count\": 0,\n\t\t\t\"max_issue_weight\": 0,\n\t\t\t\"limit_metric\":  null\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &BoardList{\n\t\tID: 1,\n\t\tLabel: &Label{\n\t\t\tName:  \"Testing\",\n\t\t\tColor: \"#F0AD4E\",\n\t\t},\n\t\tPosition: 1,\n\t}\n\n\tbl, resp, err := client.Boards.GetIssueBoardList(5, 1, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bl)\n\n\tbl, resp, err = client.Boards.GetIssueBoardList(5.01, 1, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.Boards.GetIssueBoardList(5, 1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.Boards.GetIssueBoardList(3, 1, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bl)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_CreateIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1/lists\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\" : 1,\n\t\t\t\"label\" : {\n\t\t\t  \"name\" : \"Testing\",\n\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t  \"description\" : null\n\t\t\t},\n\t\t\t\"position\" : 1,\n\t\t\t\"max_issue_count\": 0,\n\t\t\t\"max_issue_weight\": 0,\n\t\t\t\"limit_metric\":  null\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &BoardList{\n\t\tID: 1,\n\t\tLabel: &Label{\n\t\t\tName:  \"Testing\",\n\t\t\tColor: \"#F0AD4E\",\n\t\t},\n\t\tPosition: 1,\n\t}\n\n\tbl, resp, err := client.Boards.CreateIssueBoardList(5, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bl)\n\n\tbl, resp, err = client.Boards.CreateIssueBoardList(5.01, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.Boards.CreateIssueBoardList(5, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.Boards.CreateIssueBoardList(3, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bl)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_UpdateIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1/lists/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\" : 1,\n\t\t\t\"label\" : {\n\t\t\t  \"name\" : \"Testing\",\n\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t  \"description\" : null\n\t\t\t},\n\t\t\t\"position\" : 1,\n\t\t\t\"max_issue_count\": 0,\n\t\t\t\"max_issue_weight\": 0,\n\t\t\t\"limit_metric\":  null\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &BoardList{\n\t\tID: 1,\n\t\tLabel: &Label{\n\t\t\tName:  \"Testing\",\n\t\t\tColor: \"#F0AD4E\",\n\t\t},\n\t\tPosition: 1,\n\t}\n\n\tbl, resp, err := client.Boards.UpdateIssueBoardList(5, 1, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bl)\n\n\tbl, resp, err = client.Boards.UpdateIssueBoardList(5.01, 1, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.Boards.UpdateIssueBoardList(5, 1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.Boards.UpdateIssueBoardList(3, 1, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bl)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueBoardsService_DeleteIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/boards/1/lists/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Boards.DeleteIssueBoardList(5, 1, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Boards.DeleteIssueBoardList(5.01, 1, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Boards.DeleteIssueBoardList(5, 1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Boards.DeleteIssueBoardList(3, 1, 1, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "branches.go",
          "type": "blob",
          "size": 7.580078125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// BranchesService handles communication with the branch related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/branches.html\ntype BranchesService struct {\n\tclient *Client\n}\n\n// Branch represents a GitLab branch.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/branches.html\ntype Branch struct {\n\tCommit             *Commit `json:\"commit\"`\n\tName               string  `json:\"name\"`\n\tProtected          bool    `json:\"protected\"`\n\tMerged             bool    `json:\"merged\"`\n\tDefault            bool    `json:\"default\"`\n\tCanPush            bool    `json:\"can_push\"`\n\tDevelopersCanPush  bool    `json:\"developers_can_push\"`\n\tDevelopersCanMerge bool    `json:\"developers_can_merge\"`\n\tWebURL             string  `json:\"web_url\"`\n}\n\nfunc (b Branch) String() string {\n\treturn Stringify(b)\n}\n\n// ListBranchesOptions represents the available ListBranches() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#list-repository-branches\ntype ListBranchesOptions struct {\n\tListOptions\n\tSearch *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tRegex  *string `url:\"regex,omitempty\" json:\"regex,omitempty\"`\n}\n\n// ListBranches gets a list of repository branches from a project, sorted by\n// name alphabetically.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#list-repository-branches\nfunc (s *BranchesService) ListBranches(pid interface{}, opts *ListBranchesOptions, options ...RequestOptionFunc) ([]*Branch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/branches\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b []*Branch\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// GetBranch gets a single project repository branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#get-single-repository-branch\nfunc (s *BranchesService) GetBranch(pid interface{}, branch string, options ...RequestOptionFunc) (*Branch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/branches/%s\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(Branch)\n\tresp, err := s.client.Do(req, b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// ProtectBranchOptions represents the available ProtectBranch() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#protect-repository-branch\ntype ProtectBranchOptions struct {\n\tDevelopersCanPush  *bool `url:\"developers_can_push,omitempty\" json:\"developers_can_push,omitempty\"`\n\tDevelopersCanMerge *bool `url:\"developers_can_merge,omitempty\" json:\"developers_can_merge,omitempty\"`\n}\n\n// ProtectBranch protects a single project repository branch. This is an\n// idempotent function, protecting an already protected repository branch\n// still returns a 200 OK status code.\n//\n// Deprecated: This endpoint has been replaced by\n// ProtectedBranchesService.ProtectRepositoryBranches()\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#protect-repository-branch\nfunc (s *BranchesService) ProtectBranch(pid interface{}, branch string, opts *ProtectBranchOptions, options ...RequestOptionFunc) (*Branch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/branches/%s/protect\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(Branch)\n\tresp, err := s.client.Do(req, b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// UnprotectBranch unprotects a single project repository branch. This is an\n// idempotent function, unprotecting an already unprotected repository branch\n// still returns a 200 OK status code.\n//\n// Deprecated: This endpoint has been replaced by\n// ProtectedBranchesService.UnprotectRepositoryBranches()\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#unprotect-repository-branch\nfunc (s *BranchesService) UnprotectBranch(pid interface{}, branch string, options ...RequestOptionFunc) (*Branch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/branches/%s/unprotect\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(Branch)\n\tresp, err := s.client.Do(req, b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// CreateBranchOptions represents the available CreateBranch() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#create-repository-branch\ntype CreateBranchOptions struct {\n\tBranch *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tRef    *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\n// CreateBranch creates branch from commit SHA or existing branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#create-repository-branch\nfunc (s *BranchesService) CreateBranch(pid interface{}, opt *CreateBranchOptions, options ...RequestOptionFunc) (*Branch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/branches\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(Branch)\n\tresp, err := s.client.Do(req, b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// DeleteBranch deletes an existing branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#delete-repository-branch\nfunc (s *BranchesService) DeleteBranch(pid interface{}, branch string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/branches/%s\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteMergedBranches deletes all branches that are merged into the project's default branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/branches.html#delete-merged-branches\nfunc (s *BranchesService) DeleteMergedBranches(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/merged_branches\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "branches_test.go",
          "type": "blob",
          "size": 10.78515625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGetBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/branches/master\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_branch.json\")\n\t})\n\n\tbranch, resp, err := client.Branches.GetBranch(1, \"master\")\n\tif err != nil {\n\t\tt.Fatalf(\"Branches.GetBranch returned error: %v, response %v\", err, resp)\n\t}\n\n\tauthoredDate := time.Date(2012, 6, 27, 5, 51, 39, 0, time.UTC)\n\tcommittedDate := time.Date(2012, 6, 28, 3, 44, 20, 0, time.UTC)\n\twant := &Branch{\n\t\tName:               \"master\",\n\t\tMerged:             false,\n\t\tProtected:          true,\n\t\tDefault:            true,\n\t\tDevelopersCanPush:  false,\n\t\tDevelopersCanMerge: false,\n\t\tCanPush:            true,\n\t\tCommit: &Commit{\n\t\t\tAuthorEmail:    \"john@example.com\",\n\t\t\tAuthorName:     exampleEventUserName,\n\t\t\tAuthoredDate:   &authoredDate,\n\t\t\tCommittedDate:  &committedDate,\n\t\t\tCommitterEmail: \"john@example.com\",\n\t\t\tCommitterName:  exampleEventUserName,\n\t\t\tID:             \"7b5c3cc8be40ee161ae89a06bba6229da1032a0c\",\n\t\t\tShortID:        \"7b5c3cc\",\n\t\t\tTitle:          \"add projects API\",\n\t\t\tMessage:        \"add projects API\",\n\t\t\tParentIDs:      []string{\"4ad91d3c1144c406e50c7b33bae684bd6837faf8\"},\n\t\t},\n\t}\n\n\tassert.Equal(t, want, branch)\n}\n\nfunc TestBranchesService_ListBranches(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/branches\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_branches.json\")\n\t})\n\n\tauthoredDate := time.Date(2012, 6, 27, 5, 51, 39, 0, time.UTC)\n\tcommittedDate := time.Date(2012, 6, 28, 3, 44, 20, 0, time.UTC)\n\twant := []*Branch{{\n\t\tName:               \"master\",\n\t\tMerged:             false,\n\t\tProtected:          true,\n\t\tDefault:            true,\n\t\tDevelopersCanPush:  false,\n\t\tDevelopersCanMerge: false,\n\t\tCanPush:            true,\n\t\tWebURL:             \"https://gitlab.example.com/my-group/my-project/-/tree/master\",\n\t\tCommit: &Commit{\n\t\t\tAuthorEmail:    \"john@example.com\",\n\t\t\tAuthorName:     exampleEventUserName,\n\t\t\tAuthoredDate:   &authoredDate,\n\t\t\tCommittedDate:  &committedDate,\n\t\t\tCommitterEmail: \"john@example.com\",\n\t\t\tCommitterName:  exampleEventUserName,\n\t\t\tID:             \"7b5c3cc8be40ee161ae89a06bba6229da1032a0c\",\n\t\t\tShortID:        \"7b5c3cc\",\n\t\t\tTitle:          \"add projects API\",\n\t\t\tMessage:        \"add projects API\",\n\t\t\tParentIDs:      []string{\"4ad91d3c1144c406e50c7b33bae684bd6837faf8\"},\n\t\t},\n\t}}\n\n\tb, resp, err := client.Branches.ListBranches(5, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Branches.ListBranches(5.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.ListBranches(5, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.ListBranches(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestBranchesService_ProtectBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/branches/master/protect\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_branch.json\")\n\t})\n\n\tauthoredDate := time.Date(2012, 6, 27, 5, 51, 39, 0, time.UTC)\n\tcommittedDate := time.Date(2012, 6, 28, 3, 44, 20, 0, time.UTC)\n\twant := &Branch{\n\t\tName:               \"master\",\n\t\tMerged:             false,\n\t\tProtected:          true,\n\t\tDefault:            true,\n\t\tDevelopersCanPush:  false,\n\t\tDevelopersCanMerge: false,\n\t\tCanPush:            true,\n\t\tCommit: &Commit{\n\t\t\tAuthorEmail:    \"john@example.com\",\n\t\t\tAuthorName:     exampleEventUserName,\n\t\t\tAuthoredDate:   &authoredDate,\n\t\t\tCommittedDate:  &committedDate,\n\t\t\tCommitterEmail: \"john@example.com\",\n\t\t\tCommitterName:  exampleEventUserName,\n\t\t\tID:             \"7b5c3cc8be40ee161ae89a06bba6229da1032a0c\",\n\t\t\tShortID:        \"7b5c3cc\",\n\t\t\tTitle:          \"add projects API\",\n\t\t\tMessage:        \"add projects API\",\n\t\t\tParentIDs:      []string{\"4ad91d3c1144c406e50c7b33bae684bd6837faf8\"},\n\t\t},\n\t}\n\n\tb, resp, err := client.Branches.ProtectBranch(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Branches.ProtectBranch(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.ProtectBranch(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.ProtectBranch(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestBranchesService_UnprotectBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/branches/master/unprotect\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_branch.json\")\n\t})\n\n\tauthoredDate := time.Date(2012, 6, 27, 5, 51, 39, 0, time.UTC)\n\tcommittedDate := time.Date(2012, 6, 28, 3, 44, 20, 0, time.UTC)\n\twant := &Branch{\n\t\tName:               \"master\",\n\t\tMerged:             false,\n\t\tProtected:          true,\n\t\tDefault:            true,\n\t\tDevelopersCanPush:  false,\n\t\tDevelopersCanMerge: false,\n\t\tCanPush:            true,\n\t\tCommit: &Commit{\n\t\t\tAuthorEmail:    \"john@example.com\",\n\t\t\tAuthorName:     exampleEventUserName,\n\t\t\tAuthoredDate:   &authoredDate,\n\t\t\tCommittedDate:  &committedDate,\n\t\t\tCommitterEmail: \"john@example.com\",\n\t\t\tCommitterName:  exampleEventUserName,\n\t\t\tID:             \"7b5c3cc8be40ee161ae89a06bba6229da1032a0c\",\n\t\t\tShortID:        \"7b5c3cc\",\n\t\t\tTitle:          \"add projects API\",\n\t\t\tMessage:        \"add projects API\",\n\t\t\tParentIDs:      []string{\"4ad91d3c1144c406e50c7b33bae684bd6837faf8\"},\n\t\t},\n\t}\n\n\tb, resp, err := client.Branches.UnprotectBranch(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Branches.UnprotectBranch(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.UnprotectBranch(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.UnprotectBranch(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestBranchesService_CreateBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/branches\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_branch.json\")\n\t})\n\n\tauthoredDate := time.Date(2012, 6, 27, 5, 51, 39, 0, time.UTC)\n\tcommittedDate := time.Date(2012, 6, 28, 3, 44, 20, 0, time.UTC)\n\twant := &Branch{\n\t\tName:               \"master\",\n\t\tMerged:             false,\n\t\tProtected:          true,\n\t\tDefault:            true,\n\t\tDevelopersCanPush:  false,\n\t\tDevelopersCanMerge: false,\n\t\tCanPush:            true,\n\t\tCommit: &Commit{\n\t\t\tAuthorEmail:    \"john@example.com\",\n\t\t\tAuthorName:     exampleEventUserName,\n\t\t\tAuthoredDate:   &authoredDate,\n\t\t\tCommittedDate:  &committedDate,\n\t\t\tCommitterEmail: \"john@example.com\",\n\t\t\tCommitterName:  exampleEventUserName,\n\t\t\tID:             \"7b5c3cc8be40ee161ae89a06bba6229da1032a0c\",\n\t\t\tShortID:        \"7b5c3cc\",\n\t\t\tTitle:          \"add projects API\",\n\t\t\tMessage:        \"add projects API\",\n\t\t\tParentIDs:      []string{\"4ad91d3c1144c406e50c7b33bae684bd6837faf8\"},\n\t\t},\n\t}\n\n\tb, resp, err := client.Branches.CreateBranch(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Branches.CreateBranch(1.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.CreateBranch(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Branches.CreateBranch(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestBranchesService_DeleteBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/branches/master\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Branches.DeleteBranch(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Branches.DeleteBranch(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Branches.DeleteBranch(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Branches.DeleteBranch(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestBranchesService_DeleteMergedBranches(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/merged_branches\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Branches.DeleteMergedBranches(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Branches.DeleteMergedBranches(1.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Branches.DeleteMergedBranches(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Branches.DeleteMergedBranches(3, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "broadcast_messages.go",
          "type": "blob",
          "size": 7.04296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// BroadcastMessagesService handles communication with the broadcast\n// messages methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/broadcast_messages.html\ntype BroadcastMessagesService struct {\n\tclient *Client\n}\n\n// BroadcastMessage represents a GitLab issue board.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#get-all-broadcast-messages\ntype BroadcastMessage struct {\n\tMessage            string             `json:\"message\"`\n\tStartsAt           *time.Time         `json:\"starts_at\"`\n\tEndsAt             *time.Time         `json:\"ends_at\"`\n\tFont               string             `json:\"font\"`\n\tID                 int                `json:\"id\"`\n\tActive             bool               `json:\"active\"`\n\tTargetAccessLevels []AccessLevelValue `json:\"target_access_levels\"`\n\tTargetPath         string             `json:\"target_path\"`\n\tBroadcastType      string             `json:\"broadcast_type\"`\n\tDismissable        bool               `json:\"dismissable\"`\n\n\t// Deprecated: This parameter was removed in GitLab 15.6.\n\tColor string `json:\"color\"`\n}\n\n// ListBroadcastMessagesOptions represents the available ListBroadcastMessages()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#get-all-broadcast-messages\ntype ListBroadcastMessagesOptions ListOptions\n\n// ListBroadcastMessages gets a list of all broadcasted messages.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#get-all-broadcast-messages\nfunc (s *BroadcastMessagesService) ListBroadcastMessages(opt *ListBroadcastMessagesOptions, options ...RequestOptionFunc) ([]*BroadcastMessage, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"broadcast_messages\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bs []*BroadcastMessage\n\tresp, err := s.client.Do(req, &bs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bs, resp, nil\n}\n\n// GetBroadcastMessage gets a single broadcast message.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#get-a-specific-broadcast-message\nfunc (s *BroadcastMessagesService) GetBroadcastMessage(broadcast int, options ...RequestOptionFunc) (*BroadcastMessage, *Response, error) {\n\tu := fmt.Sprintf(\"broadcast_messages/%d\", broadcast)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(BroadcastMessage)\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// CreateBroadcastMessageOptions represents the available CreateBroadcastMessage()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#create-a-broadcast-message\ntype CreateBroadcastMessageOptions struct {\n\tMessage            *string            `url:\"message\" json:\"message\"`\n\tStartsAt           *time.Time         `url:\"starts_at,omitempty\" json:\"starts_at,omitempty\"`\n\tEndsAt             *time.Time         `url:\"ends_at,omitempty\" json:\"ends_at,omitempty\"`\n\tFont               *string            `url:\"font,omitempty\" json:\"font,omitempty\"`\n\tTargetAccessLevels []AccessLevelValue `url:\"target_access_levels,omitempty\" json:\"target_access_levels,omitempty\"`\n\tTargetPath         *string            `url:\"target_path,omitempty\" json:\"target_path,omitempty\"`\n\tBroadcastType      *string            `url:\"broadcast_type,omitempty\" json:\"broadcast_type,omitempty\"`\n\tDismissable        *bool              `url:\"dismissable,omitempty\" json:\"dismissable,omitempty\"`\n\n\t// Deprecated: This parameter was removed in GitLab 15.6.\n\tColor *string `url:\"color,omitempty\" json:\"color,omitempty\"`\n}\n\n// CreateBroadcastMessage creates a message to broadcast.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#create-a-broadcast-message\nfunc (s *BroadcastMessagesService) CreateBroadcastMessage(opt *CreateBroadcastMessageOptions, options ...RequestOptionFunc) (*BroadcastMessage, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"broadcast_messages\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(BroadcastMessage)\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// UpdateBroadcastMessageOptions represents the available CreateBroadcastMessage()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#update-a-broadcast-message\ntype UpdateBroadcastMessageOptions struct {\n\tMessage            *string            `url:\"message,omitempty\" json:\"message,omitempty\"`\n\tStartsAt           *time.Time         `url:\"starts_at,omitempty\" json:\"starts_at,omitempty\"`\n\tEndsAt             *time.Time         `url:\"ends_at,omitempty\" json:\"ends_at,omitempty\"`\n\tFont               *string            `url:\"font,omitempty\" json:\"font,omitempty\"`\n\tTargetAccessLevels []AccessLevelValue `url:\"target_access_levels,omitempty\" json:\"target_access_levels,omitempty\"`\n\tTargetPath         *string            `url:\"target_path,omitempty\" json:\"target_path,omitempty\"`\n\tBroadcastType      *string            `url:\"broadcast_type,omitempty\" json:\"broadcast_type,omitempty\"`\n\tDismissable        *bool              `url:\"dismissable,omitempty\" json:\"dismissable,omitempty\"`\n\n\t// Deprecated: This parameter was removed in GitLab 15.6.\n\tColor *string `url:\"color,omitempty\" json:\"color,omitempty\"`\n}\n\n// UpdateBroadcastMessage update a broadcasted message.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#update-a-broadcast-message\nfunc (s *BroadcastMessagesService) UpdateBroadcastMessage(broadcast int, opt *UpdateBroadcastMessageOptions, options ...RequestOptionFunc) (*BroadcastMessage, *Response, error) {\n\tu := fmt.Sprintf(\"broadcast_messages/%d\", broadcast)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tb := new(BroadcastMessage)\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b, resp, nil\n}\n\n// DeleteBroadcastMessage deletes a broadcasted message.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/broadcast_messages.html#delete-a-broadcast-message\nfunc (s *BroadcastMessagesService) DeleteBroadcastMessage(broadcast int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"broadcast_messages/%d\", broadcast)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "broadcast_messages_test.go",
          "type": "blob",
          "size": 8.3125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListBroadcastMessages(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/broadcast_messages\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[{\n\t\t\t\"message\": \"Some Message\",\n\t\t\t\"starts_at\": \"2017-06-26T06:00:00.000Z\",\n\t\t\t\"ends_at\": \"2017-06-27T12:59:00.000Z\",\n\t\t\t\"color\": \"#E75E40\",\n\t\t\t\"font\": \"#FFFFFF\",\n\t\t\t\"id\": 1,\n\t\t\t\"active\": false,\n\t\t\t\"target_access_levels\": [10,30],\n\t\t\t\"target_path\": \"*/welcome\",\n\t\t\t\"broadcast_type\": \"banner\",\n\t\t\t\"dismissable\": false\n\t\t},{\n\t\t\t\"message\": \"SomeMessage2\",\n\t\t\t\"starts_at\": \"2015-04-27T06:43:00.000Z\",\n\t\t\t\"ends_at\": \"2015-04-28T20:43:00.000Z\",\n\t\t\t\"color\": \"#AA33EE\",\n\t\t\t\"font\": \"#224466\",\n\t\t\t\"id\": 2,\n\t\t\t\"active\": true,\n\t\t\t\"target_access_levels\": [],\n\t\t\t\"target_path\": \"*/*\",\n\t\t\t\"broadcast_type\": \"notification\",\n\t\t\t\"dismissable\": true\n\t\t}]`)\n\t})\n\n\tgot, _, err := client.BroadcastMessage.ListBroadcastMessages(nil, nil)\n\tif err != nil {\n\t\tt.Errorf(\"ListBroadcastMessages returned error: %v\", err)\n\t}\n\n\twantedFirstStartsAt := time.Date(2017, 0o6, 26, 6, 0, 0, 0, time.UTC)\n\twantedFirstEndsAt := time.Date(2017, 0o6, 27, 12, 59, 0, 0, time.UTC)\n\n\twantedSecondStartsAt := time.Date(2015, 0o4, 27, 6, 43, 0, 0, time.UTC)\n\twantedSecondEndsAt := time.Date(2015, 0o4, 28, 20, 43, 0, 0, time.UTC)\n\n\twant := []*BroadcastMessage{{\n\t\tMessage:            \"Some Message\",\n\t\tStartsAt:           &wantedFirstStartsAt,\n\t\tEndsAt:             &wantedFirstEndsAt,\n\t\tColor:              \"#E75E40\",\n\t\tFont:               \"#FFFFFF\",\n\t\tID:                 1,\n\t\tActive:             false,\n\t\tTargetAccessLevels: []AccessLevelValue{GuestPermissions, DeveloperPermissions},\n\t\tTargetPath:         \"*/welcome\",\n\t\tBroadcastType:      \"banner\",\n\t\tDismissable:        false,\n\t}, {\n\t\tMessage:            \"SomeMessage2\",\n\t\tStartsAt:           &wantedSecondStartsAt,\n\t\tEndsAt:             &wantedSecondEndsAt,\n\t\tColor:              \"#AA33EE\",\n\t\tFont:               \"#224466\",\n\t\tID:                 2,\n\t\tActive:             true,\n\t\tTargetAccessLevels: []AccessLevelValue{},\n\t\tTargetPath:         \"*/*\",\n\t\tBroadcastType:      \"notification\",\n\t\tDismissable:        true,\n\t}}\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"ListBroadcastMessages returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t}\n}\n\nfunc TestGetBroadcastMessages(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/broadcast_messages/1/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"message\": \"Some Message\",\n\t\t\t\"starts_at\": \"2017-06-26T06:00:00.000Z\",\n\t\t\t\"ends_at\": \"2017-06-27T12:59:00.000Z\",\n\t\t\t\"color\": \"#E75E40\",\n\t\t\t\"font\": \"#FFFFFF\",\n\t\t\t\"id\": 1,\n\t\t\t\"active\": false,\n\t\t\t\"target_access_levels\": [10,30],\n\t\t\t\"target_path\": \"*/welcome\",\n\t\t\t\"broadcast_type\": \"banner\",\n\t\t\t\"dismissable\": false\n\t\t}`)\n\t})\n\n\tgot, _, err := client.BroadcastMessage.GetBroadcastMessage(1)\n\tif err != nil {\n\t\tt.Errorf(\"GetBroadcastMessage returned error: %v\", err)\n\t}\n\n\twantedStartsAt := time.Date(2017, time.June, 26, 6, 0, 0, 0, time.UTC)\n\twantedEndsAt := time.Date(2017, time.June, 27, 12, 59, 0, 0, time.UTC)\n\n\twant := &BroadcastMessage{\n\t\tMessage:            \"Some Message\",\n\t\tStartsAt:           &wantedStartsAt,\n\t\tEndsAt:             &wantedEndsAt,\n\t\tColor:              \"#E75E40\",\n\t\tFont:               \"#FFFFFF\",\n\t\tID:                 1,\n\t\tActive:             false,\n\t\tTargetAccessLevels: []AccessLevelValue{GuestPermissions, DeveloperPermissions},\n\t\tTargetPath:         \"*/welcome\",\n\t\tBroadcastType:      \"banner\",\n\t\tDismissable:        false,\n\t}\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"GetBroadcastMessage returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t}\n}\n\nfunc TestCreateBroadcastMessages(t *testing.T) {\n\tmux, client := setup(t)\n\n\twantedStartsAt := time.Date(2017, time.June, 26, 6, 0, 0, 0, time.UTC)\n\twantedEndsAt := time.Date(2017, time.June, 27, 12, 59, 0, 0, time.UTC)\n\n\tmux.HandleFunc(\"/api/v4/broadcast_messages\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"message\": \"Some Message\",\n\t\t\t\"starts_at\": \"2017-06-26T06:00:00.000Z\",\n\t\t\t\"ends_at\": \"2017-06-27T12:59:00.000Z\",\n\t\t\t\"color\": \"#E75E40\",\n\t\t\t\"font\": \"#FFFFFF\",\n\t\t\t\"id\": 42,\n\t\t\t\"active\": false,\n\t\t\t\"target_access_levels\": [10,30],\n\t\t\t\"target_path\": \"*/welcome\",\n\t\t\t\"broadcast_type\": \"banner\",\n\t\t\t\"dismissable\": false\n\t\t}`)\n\t})\n\n\topt := &CreateBroadcastMessageOptions{\n\t\tMessage:            Ptr(\"Some Message\"),\n\t\tStartsAt:           &wantedStartsAt,\n\t\tEndsAt:             &wantedEndsAt,\n\t\tColor:              Ptr(\"#E75E40\"),\n\t\tFont:               Ptr(\"#FFFFFF\"),\n\t\tTargetAccessLevels: []AccessLevelValue{GuestPermissions, DeveloperPermissions},\n\t\tTargetPath:         Ptr(\"*/welcome\"),\n\t\tBroadcastType:      Ptr(\"banner\"),\n\t\tDismissable:        Ptr(false),\n\t}\n\n\tgot, _, err := client.BroadcastMessage.CreateBroadcastMessage(opt)\n\tif err != nil {\n\t\tt.Errorf(\"CreateBroadcastMessage returned error: %v\", err)\n\t}\n\n\twant := &BroadcastMessage{\n\t\tMessage:            \"Some Message\",\n\t\tStartsAt:           &wantedStartsAt,\n\t\tEndsAt:             &wantedEndsAt,\n\t\tColor:              \"#E75E40\",\n\t\tFont:               \"#FFFFFF\",\n\t\tID:                 42,\n\t\tActive:             false,\n\t\tTargetAccessLevels: []AccessLevelValue{GuestPermissions, DeveloperPermissions},\n\t\tTargetPath:         \"*/welcome\",\n\t\tBroadcastType:      \"banner\",\n\t\tDismissable:        false,\n\t}\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"CreateBroadcastMessage returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t}\n}\n\nfunc TestUpdateBroadcastMessages(t *testing.T) {\n\tmux, client := setup(t)\n\n\twantedStartsAt := time.Date(2017, time.June, 26, 6, 0, 0, 0, time.UTC)\n\twantedEndsAt := time.Date(2017, time.June, 27, 12, 59, 0, 0, time.UTC)\n\n\tmux.HandleFunc(\"/api/v4/broadcast_messages/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"message\": \"Some Message Updated\",\n\t\t\t\"starts_at\": \"2017-06-26T06:00:00.000Z\",\n\t\t\t\"ends_at\": \"2017-06-27T12:59:00.000Z\",\n\t\t\t\"color\": \"#E75E40\",\n\t\t\t\"font\": \"#FFFFFF\",\n\t\t\t\"id\": 42,\n\t\t\t\"active\": false,\n\t\t\t\"target_access_levels\": [10,30],\n\t\t\t\"target_path\": \"*/welcome\",\n\t\t\t\"broadcast_type\": \"banner\",\n\t\t\t\"dismissable\": false\n\t\t}`)\n\t})\n\n\topt := &UpdateBroadcastMessageOptions{\n\t\tMessage:            Ptr(\"Some Message Updated\"),\n\t\tStartsAt:           &wantedStartsAt,\n\t\tEndsAt:             &wantedEndsAt,\n\t\tColor:              Ptr(\"#E75E40\"),\n\t\tFont:               Ptr(\"#FFFFFF\"),\n\t\tTargetAccessLevels: []AccessLevelValue{GuestPermissions, DeveloperPermissions},\n\t\tTargetPath:         Ptr(\"*/welcome\"),\n\t\tBroadcastType:      Ptr(\"banner\"),\n\t\tDismissable:        Ptr(false),\n\t}\n\n\tgot, _, err := client.BroadcastMessage.UpdateBroadcastMessage(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"UpdateBroadcastMessage returned error: %v\", err)\n\t}\n\n\twant := &BroadcastMessage{\n\t\tMessage:            \"Some Message Updated\",\n\t\tStartsAt:           &wantedStartsAt,\n\t\tEndsAt:             &wantedEndsAt,\n\t\tColor:              \"#E75E40\",\n\t\tFont:               \"#FFFFFF\",\n\t\tID:                 42,\n\t\tActive:             false,\n\t\tTargetAccessLevels: []AccessLevelValue{GuestPermissions, DeveloperPermissions},\n\t\tTargetPath:         \"*/welcome\",\n\t\tBroadcastType:      \"banner\",\n\t\tDismissable:        false,\n\t}\n\n\tif !reflect.DeepEqual(got, want) {\n\t\tt.Errorf(\"UpdateBroadcastMessage returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t}\n}\n\nfunc TestDeleteBroadcastMessages(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/broadcast_messages/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.BroadcastMessage.DeleteBroadcastMessage(1)\n\tif err != nil {\n\t\tt.Errorf(\"UpdateBroadcastMessage returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "ci_yml_templates.go",
          "type": "blob",
          "size": 2.7822265625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// CIYMLTemplatesService handles communication with the gitlab\n// CI YML templates related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitlab_ci_ymls.html\ntype CIYMLTemplatesService struct {\n\tclient *Client\n}\n\n// CIYMLTemplate represents a GitLab CI YML template.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitlab_ci_ymls.html\ntype CIYMLTemplate struct {\n\tName    string `json:\"name\"`\n\tContent string `json:\"content\"`\n}\n\n// CIYMLTemplateListItem represents a GitLab CI YML template from the list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitlab_ci_ymls.html\ntype CIYMLTemplateListItem struct {\n\tKey  string `json:\"key\"`\n\tName string `json:\"name\"`\n}\n\n// ListCIYMLTemplatesOptions represents the available ListAllTemplates() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitlab_ci_ymls.html#list-gitlab-ci-yaml-templates\ntype ListCIYMLTemplatesOptions ListOptions\n\n// ListAllTemplates get all GitLab CI YML templates.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitlab_ci_ymls.html#list-gitlab-ci-yaml-templates\nfunc (s *CIYMLTemplatesService) ListAllTemplates(opt *ListCIYMLTemplatesOptions, options ...RequestOptionFunc) ([]*CIYMLTemplateListItem, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"templates/gitlab_ci_ymls\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cts []*CIYMLTemplateListItem\n\tresp, err := s.client.Do(req, &cts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cts, resp, nil\n}\n\n// GetTemplate get a single GitLab CI YML template.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitlab_ci_ymls.html#single-gitlab-ci-yaml-template\nfunc (s *CIYMLTemplatesService) GetTemplate(key string, options ...RequestOptionFunc) (*CIYMLTemplate, *Response, error) {\n\tu := fmt.Sprintf(\"templates/gitlab_ci_ymls/%s\", PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tct := new(CIYMLTemplate)\n\tresp, err := s.client.Do(req, ct)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ct, resp, nil\n}\n"
        },
        {
          "name": "ci_yml_templates_test.go",
          "type": "blob",
          "size": 2.509765625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListAllTemplates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/gitlab_ci_ymls\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t   \"key\":\"5-Minute-Production-App\",\n\t\t\t   \"name\":\"5-Minute-Production-App\"\n\t\t\t},\n\t\t\t{\n\t\t\t   \"key\":\"Android\",\n\t\t\t   \"name\":\"Android\"\n\t\t\t},\n\t\t\t{\n\t\t\t   \"key\":\"Android-Fastlane\",\n\t\t\t   \"name\":\"Android-Fastlane\"\n\t\t\t},\n\t\t\t{\n\t\t\t   \"key\":\"Auto-DevOps\",\n\t\t\t   \"name\":\"Auto-DevOps\"\n\t\t\t}\n\t\t ]`)\n\t})\n\n\ttemplates, _, err := client.CIYMLTemplate.ListAllTemplates(&ListCIYMLTemplatesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"CIYMLTemplates.ListAllTemplates returned error: %v\", err)\n\t}\n\n\twant := []*CIYMLTemplateListItem{\n\t\t{\n\t\t\tKey:  \"5-Minute-Production-App\",\n\t\t\tName: \"5-Minute-Production-App\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Android\",\n\t\t\tName: \"Android\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Android-Fastlane\",\n\t\t\tName: \"Android-Fastlane\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Auto-DevOps\",\n\t\t\tName: \"Auto-DevOps\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, templates) {\n\t\tt.Errorf(\"CIYMLTemplates.ListAllTemplates returned %+v, want %+v\", templates, want)\n\t}\n}\n\nfunc TestGetTemplate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/gitlab_ci_ymls/Ruby\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"name\": \"Ruby\",\n\t\t\t\"content\": \"# This file is a template, and might need editing before it works on your project.\"\n\t\t  }`)\n\t})\n\n\ttemplate, _, err := client.CIYMLTemplate.GetTemplate(\"Ruby\")\n\tif err != nil {\n\t\tt.Errorf(\"CIYMLTemplates.GetTemplate returned error: %v\", err)\n\t}\n\n\twant := &CIYMLTemplate{\n\t\tName:    \"Ruby\",\n\t\tContent: \"# This file is a template, and might need editing before it works on your project.\",\n\t}\n\tif !reflect.DeepEqual(want, template) {\n\t\tt.Errorf(\"CIYMLTemplates.GetTemplate returned %+v, want %+v\", template, want)\n\t}\n}\n"
        },
        {
          "name": "client_options.go",
          "type": "blob",
          "size": 4.0283203125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"time\"\n\n\tretryablehttp \"github.com/hashicorp/go-retryablehttp\"\n)\n\n// ClientOptionFunc can be used to customize a new GitLab API client.\ntype ClientOptionFunc func(*Client) error\n\n// WithBaseURL sets the base URL for API requests to a custom endpoint.\nfunc WithBaseURL(urlStr string) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\treturn c.setBaseURL(urlStr)\n\t}\n}\n\n// WithCustomBackoff can be used to configure a custom backoff policy.\nfunc WithCustomBackoff(backoff retryablehttp.Backoff) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.Backoff = backoff\n\t\treturn nil\n\t}\n}\n\n// WithCustomLeveledLogger can be used to configure a custom retryablehttp\n// leveled logger.\nfunc WithCustomLeveledLogger(leveledLogger retryablehttp.LeveledLogger) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.Logger = leveledLogger\n\t\treturn nil\n\t}\n}\n\n// WithCustomLimiter injects a custom rate limiter to the client.\nfunc WithCustomLimiter(limiter RateLimiter) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.configureLimiterOnce.Do(func() {})\n\t\tc.limiter = limiter\n\t\treturn nil\n\t}\n}\n\n// WithCustomLogger can be used to configure a custom retryablehttp logger.\nfunc WithCustomLogger(logger retryablehttp.Logger) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.Logger = logger\n\t\treturn nil\n\t}\n}\n\n// WithCustomRetry can be used to configure a custom retry policy.\nfunc WithCustomRetry(checkRetry retryablehttp.CheckRetry) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.CheckRetry = checkRetry\n\t\treturn nil\n\t}\n}\n\n// WithCustomRetryMax can be used to configure a custom maximum number of retries.\nfunc WithCustomRetryMax(retryMax int) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.RetryMax = retryMax\n\t\treturn nil\n\t}\n}\n\n// WithCustomRetryWaitMinMax can be used to configure a custom minimum and\n// maximum time to wait between retries.\nfunc WithCustomRetryWaitMinMax(waitMin, waitMax time.Duration) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.RetryWaitMin = waitMin\n\t\tc.client.RetryWaitMax = waitMax\n\t\treturn nil\n\t}\n}\n\n// WithErrorHandler can be used to configure a custom error handler.\nfunc WithErrorHandler(handler retryablehttp.ErrorHandler) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.ErrorHandler = handler\n\t\treturn nil\n\t}\n}\n\n// WithHTTPClient can be used to configure a custom HTTP client.\nfunc WithHTTPClient(httpClient *http.Client) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.HTTPClient = httpClient\n\t\treturn nil\n\t}\n}\n\n// WithRequestLogHook can be used to configure a custom request log hook.\nfunc WithRequestLogHook(hook retryablehttp.RequestLogHook) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.RequestLogHook = hook\n\t\treturn nil\n\t}\n}\n\n// WithResponseLogHook can be used to configure a custom response log hook.\nfunc WithResponseLogHook(hook retryablehttp.ResponseLogHook) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.client.ResponseLogHook = hook\n\t\treturn nil\n\t}\n}\n\n// WithoutRetries disables the default retry logic.\nfunc WithoutRetries() ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.disableRetries = true\n\t\treturn nil\n\t}\n}\n\n// WithRequestOptions can be used to configure default request options applied to every request.\nfunc WithRequestOptions(options ...RequestOptionFunc) ClientOptionFunc {\n\treturn func(c *Client) error {\n\t\tc.defaultRequestOptions = append(c.defaultRequestOptions, options...)\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "cluster_agents.go",
          "type": "blob",
          "size": 8.6123046875,
          "content": "//\n// Copyright 2022, Timo Furrer <tuxtimo@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ClusterAgentsService handles communication with the cluster agents related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/cluster_agents.html\ntype ClusterAgentsService struct {\n\tclient *Client\n}\n\n// Agent represents a GitLab agent for Kubernetes.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/cluster_agents.html\ntype Agent struct {\n\tID              int           `json:\"id\"`\n\tName            string        `json:\"name\"`\n\tCreatedAt       *time.Time    `json:\"created_at\"`\n\tCreatedByUserID int           `json:\"created_by_user_id\"`\n\tConfigProject   ConfigProject `json:\"config_project\"`\n}\n\ntype ConfigProject struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n}\n\nfunc (a Agent) String() string {\n\treturn Stringify(a)\n}\n\n// AgentToken represents a GitLab agent token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#list-tokens-for-an-agent\ntype AgentToken struct {\n\tID              int        `json:\"id\"`\n\tName            string     `json:\"name\"`\n\tDescription     string     `json:\"description\"`\n\tAgentID         int        `json:\"agent_id\"`\n\tStatus          string     `json:\"status\"`\n\tCreatedAt       *time.Time `json:\"created_at\"`\n\tCreatedByUserID int        `json:\"created_by_user_id\"`\n\tLastUsedAt      *time.Time `json:\"last_used_at\"`\n\tToken           string     `json:\"token\"`\n}\n\nfunc (a AgentToken) String() string {\n\treturn Stringify(a)\n}\n\n// ListAgentsOptions represents the available ListAgents() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#list-the-agents-for-a-project\ntype ListAgentsOptions ListOptions\n\n// ListAgents returns a list of agents registered for the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#list-the-agents-for-a-project\nfunc (s *ClusterAgentsService) ListAgents(pid interface{}, opt *ListAgentsOptions, options ...RequestOptionFunc) ([]*Agent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, uri, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar as []*Agent\n\tresp, err := s.client.Do(req, &as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n\n// GetAgent gets a single agent details.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#get-details-about-an-agent\nfunc (s *ClusterAgentsService) GetAgent(pid interface{}, id int, options ...RequestOptionFunc) (*Agent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents/%d\", PathEscape(project), id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, uri, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(Agent)\n\tresp, err := s.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// RegisterAgentOptions represents the available RegisterAgent()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#register-an-agent-with-a-project\ntype RegisterAgentOptions struct {\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// RegisterAgent registers an agent to the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#register-an-agent-with-a-project\nfunc (s *ClusterAgentsService) RegisterAgent(pid interface{}, opt *RegisterAgentOptions, options ...RequestOptionFunc) (*Agent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, uri, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(Agent)\n\tresp, err := s.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// DeleteAgent deletes an existing agent registration.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#delete-a-registered-agent\nfunc (s *ClusterAgentsService) DeleteAgent(pid interface{}, id int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents/%d\", PathEscape(project), id)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, uri, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListAgentTokensOptions represents the available ListAgentTokens() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#list-tokens-for-an-agent\ntype ListAgentTokensOptions ListOptions\n\n// ListAgentTokens returns a list of tokens for an agent.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#list-tokens-for-an-agent\nfunc (s *ClusterAgentsService) ListAgentTokens(pid interface{}, aid int, opt *ListAgentTokensOptions, options ...RequestOptionFunc) ([]*AgentToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents/%d/tokens\", PathEscape(project), aid)\n\n\treq, err := s.client.NewRequest(http.MethodGet, uri, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ats []*AgentToken\n\tresp, err := s.client.Do(req, &ats)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ats, resp, nil\n}\n\n// GetAgentToken gets a single agent token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#get-a-single-agent-token\nfunc (s *ClusterAgentsService) GetAgentToken(pid interface{}, aid int, id int, options ...RequestOptionFunc) (*AgentToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents/%d/tokens/%d\", PathEscape(project), aid, id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, uri, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tat := new(AgentToken)\n\tresp, err := s.client.Do(req, at)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn at, resp, nil\n}\n\n// CreateAgentTokenOptions represents the available CreateAgentToken() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#create-an-agent-token\ntype CreateAgentTokenOptions struct {\n\tName        *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n}\n\n// CreateAgentToken creates a new token for an agent.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#create-an-agent-token\nfunc (s *ClusterAgentsService) CreateAgentToken(pid interface{}, aid int, opt *CreateAgentTokenOptions, options ...RequestOptionFunc) (*AgentToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents/%d/tokens\", PathEscape(project), aid)\n\n\treq, err := s.client.NewRequest(http.MethodPost, uri, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tat := new(AgentToken)\n\tresp, err := s.client.Do(req, at)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn at, resp, nil\n}\n\n// RevokeAgentToken revokes an agent token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/cluster_agents.html#revoke-an-agent-token\nfunc (s *ClusterAgentsService) RevokeAgentToken(pid interface{}, aid int, id int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\turi := fmt.Sprintf(\"projects/%s/cluster_agents/%d/tokens/%d\", PathEscape(project), aid, id)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, uri, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "cluster_agents_test.go",
          "type": "blob",
          "size": 9.48046875,
          "content": "//\n// Copyright 2022, Timo Furrer <tuxtimo@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc ListClusterAgents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/20/cluster_agents\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"agent-1\",\n\t\t\t  \"config_project\": {\n\t\t\t\t\"id\": 20,\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"name\": \"test\",\n\t\t\t\t\"name_with_namespace\": \"Administrator / test\",\n\t\t\t\t\"path\": \"test\",\n\t\t\t\t\"path_with_namespace\": \"root/test\",\n\t\t\t\t\"created_at\": \"2022-03-20T20:42:40.221Z\"\n\t\t\t  },\n\t\t\t  \"created_at\": \"2022-04-20T20:42:40.221Z\",\n\t\t\t  \"created_by_user_id\": 42\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"name\": \"agent-2\",\n\t\t\t  \"config_project\": {\n\t\t\t\t\"id\": 20,\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"name\": \"test\",\n\t\t\t\t\"name_with_namespace\": \"Administrator / test\",\n\t\t\t\t\"path\": \"test\",\n\t\t\t\t\"path_with_namespace\": \"root/test\",\n\t\t\t\t\"created_at\": \"2022-03-20T20:42:40.221Z\"\n\t\t\t  },\n\t\t\t  \"created_at\": \"2022-04-20T20:42:40.221Z\",\n\t\t\t  \"created_by_user_id\": 42\n\t\t\t}\n\t\t  ]\n\t\t`)\n\t})\n\n\topt := &ListAgentsOptions{}\n\tclusterAgents, _, err := client.ClusterAgents.ListAgents(20, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ClusterAgents.ListClusterAgents returned error: %v\", err)\n\t}\n\n\twant := []*Agent{\n\t\t{\n\t\t\tID:   1,\n\t\t\tName: \"agent-1\",\n\t\t\tConfigProject: ConfigProject{\n\t\t\t\tID:                20,\n\t\t\t\tDescription:       \"\",\n\t\t\t\tName:              \"test\",\n\t\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\t\tPath:              \"test\",\n\t\t\t\tPathWithNamespace: \"root/test\",\n\t\t\t\tCreatedAt:         Ptr(time.Date(2022, time.March, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t\t},\n\t\t\tCreatedAt:       Ptr(time.Date(2022, time.April, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t\tCreatedByUserID: 42,\n\t\t},\n\t\t{\n\t\t\tID:   2,\n\t\t\tName: \"agent-2\",\n\t\t\tConfigProject: ConfigProject{\n\t\t\t\tID:                20,\n\t\t\t\tDescription:       \"\",\n\t\t\t\tName:              \"test\",\n\t\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\t\tPath:              \"test\",\n\t\t\t\tPathWithNamespace: \"root/test\",\n\t\t\t\tCreatedAt:         Ptr(time.Date(2022, time.March, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t\t},\n\t\t\tCreatedAt:       Ptr(time.Date(2022, time.April, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t\tCreatedByUserID: 42,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, clusterAgents) {\n\t\tt.Errorf(\"ClusterAgents.ListClusterAgents returned %+v, want %+v\", clusterAgents, want)\n\t}\n}\n\nfunc GetClusterAgent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/20/cluster_agents/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"agent-1\",\n\t\t\t\t\"config_project\": {\n\t\t\t\t\"id\": 20,\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"name\": \"test\",\n\t\t\t\t\"name_with_namespace\": \"Administrator / test\",\n\t\t\t\t\"path\": \"test\",\n\t\t\t\t\"path_with_namespace\": \"root/test\",\n\t\t\t\t\"created_at\": \"2022-03-20T20:42:40.221Z\"\n\t\t\t\t},\n\t\t\t\t\"created_at\": \"2022-04-20T20:42:40.221Z\",\n\t\t\t\t\"created_by_user_id\": 42\n\t\t\t}\n    \t`)\n\t})\n\n\tclusterAgent, _, err := client.ClusterAgents.GetAgent(20, 1)\n\tif err != nil {\n\t\tt.Errorf(\"ClusterAgents.GetClusterAgent returned error: %v\", err)\n\t}\n\n\twant := &Agent{\n\t\tID:   1,\n\t\tName: \"agent-1\",\n\t\tConfigProject: ConfigProject{\n\t\t\tID:                20,\n\t\t\tDescription:       \"\",\n\t\t\tName:              \"test\",\n\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\tPath:              \"test\",\n\t\t\tPathWithNamespace: \"root/test\",\n\t\t\tCreatedAt:         Ptr(time.Date(2022, time.March, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t},\n\t\tCreatedAt:       Ptr(time.Date(2022, time.April, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\tCreatedByUserID: 42,\n\t}\n\tif !reflect.DeepEqual(want, clusterAgent) {\n\t\tt.Errorf(\"ClusterAgents.GetClusterAgent returned %+v, want %+v\", clusterAgent, want)\n\t}\n}\n\nfunc RegisterClusterAgent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/20/cluster_agents\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"agent-1\",\n\t\t\t\t\"config_project\": {\n\t\t\t\t  \"id\": 20,\n\t\t\t\t  \"description\": \"\",\n\t\t\t\t  \"name\": \"test\",\n\t\t\t\t  \"name_with_namespace\": \"Administrator / test\",\n\t\t\t\t  \"path\": \"test\",\n\t\t\t\t  \"path_with_namespace\": \"root/test\",\n\t\t\t\t  \"created_at\": \"2022-03-20T20:42:40.221Z\"\n\t\t\t\t},\n\t\t\t\t\"created_at\": \"2022-04-20T20:42:40.221Z\",\n\t\t\t\t\"created_by_user_id\": 42\n\t\t\t  }\n    \t`)\n\t})\n\n\topt := &RegisterAgentOptions{Name: Ptr(\"agent-1\")}\n\tclusterAgent, _, err := client.ClusterAgents.RegisterAgent(20, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ClusterAgents.RegisterClusterAgent returned error: %v\", err)\n\t}\n\n\twant := &Agent{\n\t\tID:   1,\n\t\tName: \"agent-1\",\n\t\tConfigProject: ConfigProject{\n\t\t\tID:                20,\n\t\t\tDescription:       \"\",\n\t\t\tName:              \"test\",\n\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\tPath:              \"test\",\n\t\t\tPathWithNamespace: \"root/test\",\n\t\t\tCreatedAt:         Ptr(time.Date(2022, time.March, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t},\n\t\tCreatedAt:       Ptr(time.Date(2022, time.April, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\tCreatedByUserID: 42,\n\t}\n\tif !reflect.DeepEqual(want, clusterAgent) {\n\t\tt.Errorf(\"ClusterAgents.RegisterClusterAgent returned %+v, want %+v\", clusterAgent, want)\n\t}\n}\n\nfunc ListAgentTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/20/cluster_agents/5/tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"abcd\",\n\t\t\t  \"description\": \"Some token\",\n\t\t\t  \"agent_id\": 5,\n\t\t\t  \"status\": \"active\",\n\t\t\t  \"created_at\": \"2022-03-25T14:12:11.497Z\",\n\t\t\t  \"created_by_user_id\": 1\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"name\": \"foobar\",\n\t\t\t  \"description\": null,\n\t\t\t  \"agent_id\": 5,\n\t\t\t  \"status\": \"active\",\n\t\t\t  \"created_at\": \"2022-03-25T14:12:11.497Z\",\n\t\t\t  \"created_by_user_id\": 1\n\t\t\t}\n\t\t]\n\t\t`)\n\t})\n\n\topt := &ListAgentTokensOptions{}\n\tclusterAgentTokens, _, err := client.ClusterAgents.ListAgentTokens(20, 5, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ClusterAgents.ListAgentTokens returned error: %v\", err)\n\t}\n\n\twant := []*AgentToken{\n\t\t{\n\t\t\tID:              1,\n\t\t\tName:            \"abcd\",\n\t\t\tDescription:     \"Some token\",\n\t\t\tAgentID:         5,\n\t\t\tStatus:          \"active\",\n\t\t\tCreatedAt:       Ptr(time.Date(2022, time.March, 25, 14, 12, 11, 497000000, time.UTC)),\n\t\t\tCreatedByUserID: 1,\n\t\t},\n\t\t{\n\t\t\tID:              2,\n\t\t\tName:            \"foobar\",\n\t\t\tDescription:     \"\",\n\t\t\tAgentID:         5,\n\t\t\tStatus:          \"active\",\n\t\t\tCreatedAt:       Ptr(time.Date(2022, time.March, 25, 14, 12, 11, 497000000, time.UTC)),\n\t\t\tCreatedByUserID: 1,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, clusterAgentTokens) {\n\t\tt.Errorf(\"ClusterAgents.ListAgentTokens returned %+v, want %+v\", clusterAgentTokens, want)\n\t}\n}\n\nfunc GetAgentToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/20/cluster_agents/5/tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"abcd\",\n\t\t\t\"description\": \"Some token\",\n\t\t\t\"agent_id\": 5,\n\t\t\t\"status\": \"active\",\n\t\t\t\"created_at\": \"2022-03-25T14:12:11.497Z\",\n\t\t\t\"created_by_user_id\": 1,\n\t\t\t\"last_used_at\": null\n\t\t }\n    \t`)\n\t})\n\n\tclusterAgentToken, _, err := client.ClusterAgents.GetAgentToken(20, 5, 1)\n\tif err != nil {\n\t\tt.Errorf(\"ClusterAgents.GetAgentToken returned error: %v\", err)\n\t}\n\n\twant := &AgentToken{\n\t\tID:              1,\n\t\tName:            \"abcd\",\n\t\tDescription:     \"Some token\",\n\t\tAgentID:         5,\n\t\tStatus:          \"active\",\n\t\tCreatedAt:       Ptr(time.Date(2022, time.March, 25, 14, 12, 11, 497000000, time.UTC)),\n\t\tCreatedByUserID: 1,\n\t\tLastUsedAt:      nil,\n\t}\n\tif !reflect.DeepEqual(want, clusterAgentToken) {\n\t\tt.Errorf(\"ClusterAgents.GetAgentToken returned %+v, want %+v\", clusterAgentToken, want)\n\t}\n}\n\nfunc RegisterAgentToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/20/cluster_agents/5/tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"abcd\",\n\t\t\t\"description\": \"Some token\",\n\t\t\t\"agent_id\": 5,\n\t\t\t\"status\": \"active\",\n\t\t\t\"created_at\": \"2022-03-25T14:12:11.497Z\",\n\t\t\t\"created_by_user_id\": 1,\n\t\t\t\"last_used_at\": null,\n\t\t\t\"token\": \"qeY8UVRisx9y3Loxo1scLxFuRxYcgeX3sxsdrpP_fR3Loq4xyg\"\n\t\t}\n    \t`)\n\t})\n\n\topt := &CreateAgentTokenOptions{Name: Ptr(\"abcd\"), Description: Ptr(\"Some token\")}\n\tclusterAgentToken, _, err := client.ClusterAgents.CreateAgentToken(20, 5, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ClusterAgents.CreateAgentToken returned error: %v\", err)\n\t}\n\n\twant := &AgentToken{\n\t\tID:              1,\n\t\tName:            \"abcd\",\n\t\tDescription:     \"Some token\",\n\t\tAgentID:         5,\n\t\tStatus:          \"active\",\n\t\tCreatedAt:       Ptr(time.Date(2022, time.March, 25, 14, 12, 11, 497000000, time.UTC)),\n\t\tCreatedByUserID: 1,\n\t\tLastUsedAt:      nil,\n\t\tToken:           \"qeY8UVRisx9y3Loxo1scLxFuRxYcgeX3sxsdrpP_fR3Loq4xyg\",\n\t}\n\tif !reflect.DeepEqual(want, clusterAgentToken) {\n\t\tt.Errorf(\"ClusterAgents.CreateAgentToken returned %+v, want %+v\", clusterAgentToken, want)\n\t}\n}\n"
        },
        {
          "name": "commits.go",
          "type": "blob",
          "size": 20.66015625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"time\"\n)\n\n// CommitsService handles communication with the commit related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html\ntype CommitsService struct {\n\tclient *Client\n}\n\n// Commit represents a GitLab commit.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html\ntype Commit struct {\n\tID               string            `json:\"id\"`\n\tShortID          string            `json:\"short_id\"`\n\tTitle            string            `json:\"title\"`\n\tAuthorName       string            `json:\"author_name\"`\n\tAuthorEmail      string            `json:\"author_email\"`\n\tAuthoredDate     *time.Time        `json:\"authored_date\"`\n\tCommitterName    string            `json:\"committer_name\"`\n\tCommitterEmail   string            `json:\"committer_email\"`\n\tCommittedDate    *time.Time        `json:\"committed_date\"`\n\tCreatedAt        *time.Time        `json:\"created_at\"`\n\tMessage          string            `json:\"message\"`\n\tParentIDs        []string          `json:\"parent_ids\"`\n\tStats            *CommitStats      `json:\"stats\"`\n\tStatus           *BuildStateValue  `json:\"status\"`\n\tLastPipeline     *PipelineInfo     `json:\"last_pipeline\"`\n\tProjectID        int               `json:\"project_id\"`\n\tTrailers         map[string]string `json:\"trailers\"`\n\tExtendedTrailers map[string]string `json:\"extended_trailers\"`\n\tWebURL           string            `json:\"web_url\"`\n}\n\n// CommitStats represents the number of added and deleted files in a commit.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html\ntype CommitStats struct {\n\tAdditions int `json:\"additions\"`\n\tDeletions int `json:\"deletions\"`\n\tTotal     int `json:\"total\"`\n}\n\nfunc (c Commit) String() string {\n\treturn Stringify(c)\n}\n\n// ListCommitsOptions represents the available ListCommits() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#list-repository-commits\ntype ListCommitsOptions struct {\n\tListOptions\n\tRefName     *string    `url:\"ref_name,omitempty\" json:\"ref_name,omitempty\"`\n\tSince       *time.Time `url:\"since,omitempty\" json:\"since,omitempty\"`\n\tUntil       *time.Time `url:\"until,omitempty\" json:\"until,omitempty\"`\n\tPath        *string    `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tAuthor      *string    `url:\"author,omitempty\" json:\"author,omitempty\"`\n\tAll         *bool      `url:\"all,omitempty\" json:\"all,omitempty\"`\n\tWithStats   *bool      `url:\"with_stats,omitempty\" json:\"with_stats,omitempty\"`\n\tFirstParent *bool      `url:\"first_parent,omitempty\" json:\"first_parent,omitempty\"`\n\tTrailers    *bool      `url:\"trailers,omitempty\" json:\"trailers,omitempty\"`\n}\n\n// ListCommits gets a list of repository commits in a project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#list-repository-commits\nfunc (s *CommitsService) ListCommits(pid interface{}, opt *ListCommitsOptions, options ...RequestOptionFunc) ([]*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar c []*Commit\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// CommitRef represents the reference of branches/tags in a commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-references-a-commit-is-pushed-to\ntype CommitRef struct {\n\tType string `json:\"type\"`\n\tName string `json:\"name\"`\n}\n\n// GetCommitRefsOptions represents the available GetCommitRefs() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-references-a-commit-is-pushed-to\ntype GetCommitRefsOptions struct {\n\tListOptions\n\tType *string `url:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\n// GetCommitRefs gets all references (from branches or tags) a commit is pushed to\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-references-a-commit-is-pushed-to\nfunc (s *CommitsService) GetCommitRefs(pid interface{}, sha string, opt *GetCommitRefsOptions, options ...RequestOptionFunc) ([]*CommitRef, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/refs\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cs []*CommitRef\n\tresp, err := s.client.Do(req, &cs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cs, resp, nil\n}\n\n// GetCommitOptions represents the available GetCommit() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-a-single-commit\ntype GetCommitOptions struct {\n\tStats *bool `url:\"stats,omitempty\" json:\"stats,omitempty\"`\n}\n\n// GetCommit gets a specific commit identified by the commit hash or name of a\n// branch or tag.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#get-a-single-commit\nfunc (s *CommitsService) GetCommit(pid interface{}, sha string, opt *GetCommitOptions, options ...RequestOptionFunc) (*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif sha == \"\" {\n\t\treturn nil, nil, fmt.Errorf(\"SHA must be a non-empty string\")\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(Commit)\n\tresp, err := s.client.Do(req, c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// CreateCommitOptions represents the available options for a new commit.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#create-a-commit-with-multiple-files-and-actions\ntype CreateCommitOptions struct {\n\tBranch        *string                `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tCommitMessage *string                `url:\"commit_message,omitempty\" json:\"commit_message,omitempty\"`\n\tStartBranch   *string                `url:\"start_branch,omitempty\" json:\"start_branch,omitempty\"`\n\tStartSHA      *string                `url:\"start_sha,omitempty\" json:\"start_sha,omitempty\"`\n\tStartProject  *string                `url:\"start_project,omitempty\" json:\"start_project,omitempty\"`\n\tActions       []*CommitActionOptions `url:\"actions\" json:\"actions\"`\n\tAuthorEmail   *string                `url:\"author_email,omitempty\" json:\"author_email,omitempty\"`\n\tAuthorName    *string                `url:\"author_name,omitempty\" json:\"author_name,omitempty\"`\n\tStats         *bool                  `url:\"stats,omitempty\" json:\"stats,omitempty\"`\n\tForce         *bool                  `url:\"force,omitempty\" json:\"force,omitempty\"`\n}\n\n// CommitActionOptions represents the available options for a new single\n// file action.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#create-a-commit-with-multiple-files-and-actions\ntype CommitActionOptions struct {\n\tAction          *FileActionValue `url:\"action,omitempty\" json:\"action,omitempty\"`\n\tFilePath        *string          `url:\"file_path,omitempty\" json:\"file_path,omitempty\"`\n\tPreviousPath    *string          `url:\"previous_path,omitempty\" json:\"previous_path,omitempty\"`\n\tContent         *string          `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tEncoding        *string          `url:\"encoding,omitempty\" json:\"encoding,omitempty\"`\n\tLastCommitID    *string          `url:\"last_commit_id,omitempty\" json:\"last_commit_id,omitempty\"`\n\tExecuteFilemode *bool            `url:\"execute_filemode,omitempty\" json:\"execute_filemode,omitempty\"`\n}\n\n// CreateCommit creates a commit with multiple files and actions.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#create-a-commit-with-multiple-files-and-actions\nfunc (s *CommitsService) CreateCommit(pid interface{}, opt *CreateCommitOptions, options ...RequestOptionFunc) (*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(Commit)\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// Diff represents a GitLab diff.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html\ntype Diff struct {\n\tDiff        string `json:\"diff\"`\n\tNewPath     string `json:\"new_path\"`\n\tOldPath     string `json:\"old_path\"`\n\tAMode       string `json:\"a_mode\"`\n\tBMode       string `json:\"b_mode\"`\n\tNewFile     bool   `json:\"new_file\"`\n\tRenamedFile bool   `json:\"renamed_file\"`\n\tDeletedFile bool   `json:\"deleted_file\"`\n}\n\nfunc (d Diff) String() string {\n\treturn Stringify(d)\n}\n\n// GetCommitDiffOptions represents the available GetCommitDiff() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-the-diff-of-a-commit\ntype GetCommitDiffOptions struct {\n\tListOptions\n\tUnidiff *bool `url:\"unidiff,omitempty\" json:\"unidiff,omitempty\"`\n}\n\n// GetCommitDiff gets the diff of a commit in a project..\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-the-diff-of-a-commit\nfunc (s *CommitsService) GetCommitDiff(pid interface{}, sha string, opt *GetCommitDiffOptions, options ...RequestOptionFunc) ([]*Diff, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/diff\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar d []*Diff\n\tresp, err := s.client.Do(req, &d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CommitComment represents a GitLab commit comment.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html\ntype CommitComment struct {\n\tNote     string `json:\"note\"`\n\tPath     string `json:\"path\"`\n\tLine     int    `json:\"line\"`\n\tLineType string `json:\"line_type\"`\n\tAuthor   Author `json:\"author\"`\n}\n\n// Author represents a GitLab commit author\ntype Author struct {\n\tID        int        `json:\"id\"`\n\tUsername  string     `json:\"username\"`\n\tEmail     string     `json:\"email\"`\n\tName      string     `json:\"name\"`\n\tState     string     `json:\"state\"`\n\tBlocked   bool       `json:\"blocked\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n}\n\nfunc (c CommitComment) String() string {\n\treturn Stringify(c)\n}\n\n// GetCommitCommentsOptions represents the available GetCommitComments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-the-comments-of-a-commit\ntype GetCommitCommentsOptions ListOptions\n\n// GetCommitComments gets the comments of a commit in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-the-comments-of-a-commit\nfunc (s *CommitsService) GetCommitComments(pid interface{}, sha string, opt *GetCommitCommentsOptions, options ...RequestOptionFunc) ([]*CommitComment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/comments\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar c []*CommitComment\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// PostCommitCommentOptions represents the available PostCommitComment()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#post-comment-to-commit\ntype PostCommitCommentOptions struct {\n\tNote     *string `url:\"note,omitempty\" json:\"note,omitempty\"`\n\tPath     *string `url:\"path\" json:\"path\"`\n\tLine     *int    `url:\"line\" json:\"line\"`\n\tLineType *string `url:\"line_type\" json:\"line_type\"`\n}\n\n// PostCommitComment adds a comment to a commit. Optionally you can post\n// comments on a specific line of a commit. Therefor both path, line_new and\n// line_old are required.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#post-comment-to-commit\nfunc (s *CommitsService) PostCommitComment(pid interface{}, sha string, opt *PostCommitCommentOptions, options ...RequestOptionFunc) (*CommitComment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/comments\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(CommitComment)\n\tresp, err := s.client.Do(req, c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// GetCommitStatusesOptions represents the available GetCommitStatuses() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#list-the-statuses-of-a-commit\ntype GetCommitStatusesOptions struct {\n\tListOptions\n\tRef   *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tStage *string `url:\"stage,omitempty\" json:\"stage,omitempty\"`\n\tName  *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tAll   *bool   `url:\"all,omitempty\" json:\"all,omitempty\"`\n}\n\n// CommitStatus represents a GitLab commit status.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#commit-status\ntype CommitStatus struct {\n\tID           int        `json:\"id\"`\n\tSHA          string     `json:\"sha\"`\n\tRef          string     `json:\"ref\"`\n\tStatus       string     `json:\"status\"`\n\tCreatedAt    *time.Time `json:\"created_at\"`\n\tStartedAt    *time.Time `json:\"started_at\"`\n\tFinishedAt   *time.Time `json:\"finished_at\"`\n\tName         string     `json:\"name\"`\n\tAllowFailure bool       `json:\"allow_failure\"`\n\tCoverage     float64    `json:\"coverage\"`\n\tPipelineId   int        `json:\"pipeline_id\"`\n\tAuthor       Author     `json:\"author\"`\n\tDescription  string     `json:\"description\"`\n\tTargetURL    string     `json:\"target_url\"`\n}\n\n// GetCommitStatuses gets the statuses of a commit in a project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#list-the-statuses-of-a-commit\nfunc (s *CommitsService) GetCommitStatuses(pid interface{}, sha string, opt *GetCommitStatusesOptions, options ...RequestOptionFunc) ([]*CommitStatus, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/statuses\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cs []*CommitStatus\n\tresp, err := s.client.Do(req, &cs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cs, resp, nil\n}\n\n// SetCommitStatusOptions represents the available SetCommitStatus() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#set-the-pipeline-status-of-a-commit\ntype SetCommitStatusOptions struct {\n\tState       BuildStateValue `url:\"state\" json:\"state\"`\n\tRef         *string         `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tName        *string         `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tContext     *string         `url:\"context,omitempty\" json:\"context,omitempty\"`\n\tTargetURL   *string         `url:\"target_url,omitempty\" json:\"target_url,omitempty\"`\n\tDescription *string         `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tCoverage    *float64        `url:\"coverage,omitempty\" json:\"coverage,omitempty\"`\n\tPipelineID  *int            `url:\"pipeline_id,omitempty\" json:\"pipeline_id,omitempty\"`\n}\n\n// SetCommitStatus sets the status of a commit in a project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#set-the-pipeline-status-of-a-commit\nfunc (s *CommitsService) SetCommitStatus(pid interface{}, sha string, opt *SetCommitStatusOptions, options ...RequestOptionFunc) (*CommitStatus, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/statuses/%s\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcs := new(CommitStatus)\n\tresp, err := s.client.Do(req, &cs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cs, resp, nil\n}\n\n// ListMergeRequestsByCommit gets merge request associated with a commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#list-merge-requests-associated-with-a-commit\nfunc (s *CommitsService) ListMergeRequestsByCommit(pid interface{}, sha string, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/merge_requests\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mrs []*MergeRequest\n\tresp, err := s.client.Do(req, &mrs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mrs, resp, nil\n}\n\n// CherryPickCommitOptions represents the available CherryPickCommit() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#cherry-pick-a-commit\ntype CherryPickCommitOptions struct {\n\tBranch  *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tDryRun  *bool   `url:\"dry_run,omitempty\" json:\"dry_run,omitempty\"`\n\tMessage *string `url:\"message,omitempty\" json:\"message,omitempty\"`\n}\n\n// CherryPickCommit cherry picks a commit to a given branch.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#cherry-pick-a-commit\nfunc (s *CommitsService) CherryPickCommit(pid interface{}, sha string, opt *CherryPickCommitOptions, options ...RequestOptionFunc) (*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/cherry_pick\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(Commit)\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// RevertCommitOptions represents the available RevertCommit() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#revert-a-commit\ntype RevertCommitOptions struct {\n\tBranch *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n}\n\n// RevertCommit reverts a commit in a given branch.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#revert-a-commit\nfunc (s *CommitsService) RevertCommit(pid interface{}, sha string, opt *RevertCommitOptions, options ...RequestOptionFunc) (*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/revert\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(Commit)\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// GPGSignature represents a Gitlab commit's GPG Signature.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#get-gpg-signature-of-a-commit\ntype GPGSignature struct {\n\tKeyID              int    `json:\"gpg_key_id\"`\n\tKeyPrimaryKeyID    string `json:\"gpg_key_primary_keyid\"`\n\tKeyUserName        string `json:\"gpg_key_user_name\"`\n\tKeyUserEmail       string `json:\"gpg_key_user_email\"`\n\tVerificationStatus string `json:\"verification_status\"`\n\tKeySubkeyID        int    `json:\"gpg_key_subkey_id\"`\n}\n\n// GetGPGSignature gets a GPG signature of a commit.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/commits.html#get-gpg-signature-of-a-commit\nfunc (s *CommitsService) GetGPGSignature(pid interface{}, sha string, options ...RequestOptionFunc) (*GPGSignature, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/signature\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsig := new(GPGSignature)\n\tresp, err := s.client.Do(req, &sig)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn sig, resp, nil\n}\n"
        },
        {
          "name": "commits_test.go",
          "type": "blob",
          "size": 29.2255859375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar testRevertCommitTargetBranch = \"release\"\n\nfunc TestGetCommit(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/b0b3a907f41409829b307a28b82fdbd552ee5a27\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_commit.json\")\n\t})\n\n\tcommit, resp, err := client.Commits.GetCommit(\"1\", \"b0b3a907f41409829b307a28b82fdbd552ee5a27\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Commits.GetCommit returned error: %v, response: %v\", err, resp)\n\t}\n\n\tupdatedAt := time.Date(2019, 11, 4, 15, 39, 0o3, 935000000, time.UTC)\n\tcreatedAt := time.Date(2019, 11, 4, 15, 38, 53, 154000000, time.UTC)\n\twant := &Commit{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Sanitize for network graph\",\n\t\tAuthorName:     \"randx\",\n\t\tAuthorEmail:    \"dmitriy.zaporozhets@gmail.com\",\n\t\tCommitterName:  \"Dmitriy\",\n\t\tCommitterEmail: \"dmitriy.zaporozhets@gmail.com\",\n\t\tMessage:        \"Sanitize for network graph\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStats:          &CommitStats{Additions: 15, Deletions: 10, Total: 25},\n\t\tStatus:         Ptr(Running),\n\t\tLastPipeline: &PipelineInfo{\n\t\t\tID:        8,\n\t\t\tRef:       \"master\",\n\t\t\tSHA:       \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\tStatus:    \"created\",\n\t\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\tUpdatedAt: &updatedAt,\n\t\t\tCreatedAt: &createdAt,\n\t\t},\n\t\tProjectID: 13083,\n\t}\n\n\tassert.Equal(t, want, commit)\n}\n\nfunc TestGetCommitStatuses(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/b0b3a907f41409829b307a28b82fdbd552ee5a27/statuses\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1}]`)\n\t})\n\n\topt := &GetCommitStatusesOptions{\n\t\tRef:   Ptr(\"master\"),\n\t\tStage: Ptr(\"test\"),\n\t\tName:  Ptr(\"ci/jenkins\"),\n\t\tAll:   Ptr(true),\n\t}\n\tstatuses, _, err := client.Commits.GetCommitStatuses(\"1\", \"b0b3a907f41409829b307a28b82fdbd552ee5a27\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Commits.GetCommitStatuses returned error: %v\", err)\n\t}\n\n\twant := []*CommitStatus{{ID: 1}}\n\tif !reflect.DeepEqual(want, statuses) {\n\t\tt.Errorf(\"Commits.GetCommitStatuses returned %+v, want %+v\", statuses, want)\n\t}\n}\n\nfunc TestSetCommitStatus(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/statuses/b0b3a907f41409829b307a28b82fdbd552ee5a27\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tbody, err := io.ReadAll(r.Body)\n\t\trequire.NoError(t, err)\n\n\t\tvar content SetCommitStatusOptions\n\t\terr = json.Unmarshal(body, &content)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"ci/jenkins\", *content.Name)\n\t\tassert.Equal(t, 99.9, *content.Coverage)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\n\tcov := 99.9\n\topt := &SetCommitStatusOptions{\n\t\tState:       Running,\n\t\tRef:         Ptr(\"master\"),\n\t\tName:        Ptr(\"ci/jenkins\"),\n\t\tContext:     Ptr(\"\"),\n\t\tTargetURL:   Ptr(\"http://abc\"),\n\t\tDescription: Ptr(\"build\"),\n\t\tCoverage:    &cov,\n\t}\n\tstatus, _, err := client.Commits.SetCommitStatus(\"1\", \"b0b3a907f41409829b307a28b82fdbd552ee5a27\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Commits.SetCommitStatus returned error: %v\", err)\n\t}\n\n\twant := &CommitStatus{ID: 1}\n\tif !reflect.DeepEqual(want, status) {\n\t\tt.Errorf(\"Commits.SetCommitStatus returned %+v, want %+v\", status, want)\n\t}\n}\n\nfunc TestRevertCommit_NoOptions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/b0b3a907f41409829b307a28b82fdbd552ee5a27/revert\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_commit.json\")\n\t})\n\n\tcommit, resp, err := client.Commits.RevertCommit(\"1\", \"b0b3a907f41409829b307a28b82fdbd552ee5a27\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Commits.RevertCommit returned error: %v, response: %v\", err, resp)\n\t}\n\n\tupdatedAt := time.Date(2019, 11, 4, 15, 39, 0o3, 935000000, time.UTC)\n\tcreatedAt := time.Date(2019, 11, 4, 15, 38, 53, 154000000, time.UTC)\n\twant := &Commit{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Sanitize for network graph\",\n\t\tAuthorName:     \"randx\",\n\t\tAuthorEmail:    \"dmitriy.zaporozhets@gmail.com\",\n\t\tCommitterName:  \"Dmitriy\",\n\t\tCommitterEmail: \"dmitriy.zaporozhets@gmail.com\",\n\t\tMessage:        \"Sanitize for network graph\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStats:          &CommitStats{Additions: 15, Deletions: 10, Total: 25},\n\t\tStatus:         Ptr(Running),\n\t\tLastPipeline: &PipelineInfo{\n\t\t\tID:        8,\n\t\t\tRef:       \"master\",\n\t\t\tSHA:       \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\tStatus:    \"created\",\n\t\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\tUpdatedAt: &updatedAt,\n\t\t\tCreatedAt: &createdAt,\n\t\t},\n\t\tProjectID: 13083,\n\t}\n\n\tassert.Equal(t, want, commit)\n}\n\nfunc TestRevertCommit_WithOptions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/b0b3a907f41409829b307a28b82fdbd552ee5a27/revert\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestBody(t, r, `{\"branch\":\"release\"}`)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_commit.json\")\n\t})\n\n\tcommit, resp, err := client.Commits.RevertCommit(\"1\", \"b0b3a907f41409829b307a28b82fdbd552ee5a27\", &RevertCommitOptions{\n\t\tBranch: &testRevertCommitTargetBranch,\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Commits.RevertCommit returned error: %v, response: %v\", err, resp)\n\t}\n\n\tupdatedAt := time.Date(2019, 11, 4, 15, 39, 0o3, 935000000, time.UTC)\n\tcreatedAt := time.Date(2019, 11, 4, 15, 38, 53, 154000000, time.UTC)\n\twant := &Commit{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Sanitize for network graph\",\n\t\tAuthorName:     \"randx\",\n\t\tAuthorEmail:    \"dmitriy.zaporozhets@gmail.com\",\n\t\tCommitterName:  \"Dmitriy\",\n\t\tCommitterEmail: \"dmitriy.zaporozhets@gmail.com\",\n\t\tMessage:        \"Sanitize for network graph\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStats:          &CommitStats{Additions: 15, Deletions: 10, Total: 25},\n\t\tStatus:         Ptr(Running),\n\t\tLastPipeline: &PipelineInfo{\n\t\t\tID:        8,\n\t\t\tRef:       \"master\",\n\t\t\tSHA:       \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\tStatus:    \"created\",\n\t\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\tUpdatedAt: &updatedAt,\n\t\t\tCreatedAt: &createdAt,\n\t\t},\n\t\tProjectID: 13083,\n\t}\n\n\tassert.Equal(t, want, commit)\n}\n\nfunc TestGetGPGSignature(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/b0b3a907f41409829b307a28b82fdbd552ee5a27/signature\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_signature.json\")\n\t})\n\n\tsig, resp, err := client.Commits.GetGPGSignature(\"1\", \"b0b3a907f41409829b307a28b82fdbd552ee5a27\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Commits.GetGPGSignature returned error: %v, response: %v\", err, resp)\n\t}\n\n\twant := &GPGSignature{\n\t\tKeyID:              7977,\n\t\tKeyPrimaryKeyID:    \"627C5F589F467F17\",\n\t\tKeyUserName:        \"Dmitriy Zaporozhets\",\n\t\tKeyUserEmail:       \"dmitriy.zaporozhets@gmail.com\",\n\t\tVerificationStatus: \"verified\",\n\t\tKeySubkeyID:        0,\n\t}\n\n\tassert.Equal(t, want, sig)\n}\n\nfunc TestCommitsService_ListCommits(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\t\t\t\t\"short_id\": \"6104942438c\",\n\t\t\t\t\t\"title\": \"Sanitize for network graph\",\n\t\t\t\t\t\"author_name\": \"randx\",\n\t\t\t\t\t\"author_email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t\t\"committer_name\": \"Venkatesh\",\n\t\t\t\t\t\"committer_email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t\t\"message\": \"Sanitize for network graph\",\n\t\t\t\t\t\"parent_ids\": [\n\t\t\t\t\t\t\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"\n\t\t\t\t\t],\n\t\t\t\t\t\"last_pipeline\": {\n\t\t\t\t\t\t\"id\": 8,\n\t\t\t\t\t\t\"ref\": \"master\",\n\t\t\t\t\t\t\"sha\": \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\t\t\t\t\"status\": \"created\",\n\t\t\t\t\t\t\"web_url\": \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\t\t\t\t\"created_at\": \"2019-11-04T15:38:53.154Z\",\n\t\t\t\t\t\t\"updated_at\": \"2019-11-04T15:39:03.935Z\"\n\t\t\t\t\t},\n\t\t\t\t\t\"stats\": {\n\t\t\t\t\t\t\"additions\": 15,\n\t\t\t\t\t\t\"deletions\": 10,\n\t\t\t\t\t\t\"total\": 25\n\t\t\t\t\t},\n\t\t\t\t\t\"status\": \"running\",\n\t\t\t\t\t\"project_id\": 13083\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\tupdatedAt := time.Date(2019, 11, 4, 15, 39, 0o3, 935000000, time.UTC)\n\tcreatedAt := time.Date(2019, 11, 4, 15, 38, 53, 154000000, time.UTC)\n\twant := []*Commit{{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Sanitize for network graph\",\n\t\tAuthorName:     \"randx\",\n\t\tAuthorEmail:    \"venkateshthalluri123@gmail.com\",\n\t\tCommitterName:  \"Venkatesh\",\n\t\tCommitterEmail: \"venkateshthalluri123@gmail.com\",\n\t\tMessage:        \"Sanitize for network graph\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStats:          &CommitStats{Additions: 15, Deletions: 10, Total: 25},\n\t\tStatus:         Ptr(Running),\n\t\tLastPipeline: &PipelineInfo{\n\t\t\tID:        8,\n\t\t\tRef:       \"master\",\n\t\t\tSHA:       \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\tStatus:    \"created\",\n\t\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\tUpdatedAt: &updatedAt,\n\t\t\tCreatedAt: &createdAt,\n\t\t},\n\t\tProjectID: 13083,\n\t}}\n\n\tcs, resp, err := client.Commits.ListCommits(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, cs)\n\n\tcs, resp, err = client.Commits.ListCommits(1.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cs)\n\n\tcs, resp, err = client.Commits.ListCommits(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cs)\n\n\tcs, resp, err = client.Commits.ListCommits(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, cs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_GetCommitRefs(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/5937ac0a7beb003549fc5fd26fc247adbce4a52e/refs\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\"type\": \"branch\", \"name\": \"test\"},\n\t\t\t  {\"type\": \"branch\", \"name\": \"add-balsamiq-file\"},\n\t\t\t  {\"type\": \"branch\", \"name\": \"wip\"},\n\t\t\t  {\"type\": \"tag\", \"name\": \"v1.1.0\"}\n\t\t\t ]\n\t\t`)\n\t})\n\n\twant := []*CommitRef{\n\t\t{\n\t\t\tType: \"branch\",\n\t\t\tName: \"test\",\n\t\t},\n\t\t{\n\t\t\tType: \"branch\",\n\t\t\tName: \"add-balsamiq-file\",\n\t\t},\n\t\t{\n\t\t\tType: \"branch\",\n\t\t\tName: \"wip\",\n\t\t},\n\t\t{\n\t\t\tType: \"tag\",\n\t\t\tName: \"v1.1.0\",\n\t\t},\n\t}\n\n\tcrs, resp, err := client.Commits.GetCommitRefs(1, \"5937ac0a7beb003549fc5fd26fc247adbce4a52e\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, crs)\n\n\tcrs, resp, err = client.Commits.GetCommitRefs(1.01, \"5937ac0a7beb003549fc5fd26fc247adbce4a52e\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, crs)\n\n\tcrs, resp, err = client.Commits.GetCommitRefs(1, \"5937ac0a7beb003549fc5fd26fc247adbce4a52e\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, crs)\n\n\tcrs, resp, err = client.Commits.GetCommitRefs(3, \"5937ac0a7beb003549fc5fd26fc247adbce4a52e\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, crs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_CreateCommit(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\t\t\t\"short_id\": \"6104942438c\",\n\t\t\t\t\"title\": \"Sanitize for network graph\",\n\t\t\t\t\"author_name\": \"randx\",\n\t\t\t\t\"author_email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t\"committer_name\": \"Venkatesh\",\n\t\t\t\t\"committer_email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t\"message\": \"Sanitize for network graph\",\n\t\t\t\t\"parent_ids\": [\n\t\t\t\t\t\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"\n\t\t\t\t],\n\t\t\t\t\"last_pipeline\": {\n\t\t\t\t\t\"id\": 8,\n\t\t\t\t\t\"ref\": \"master\",\n\t\t\t\t\t\"sha\": \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\t\t\t\"status\": \"created\",\n\t\t\t\t\t\"web_url\": \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\t\t\t\"created_at\": \"2019-11-04T15:38:53.154Z\",\n\t\t\t\t\t\"updated_at\": \"2019-11-04T15:39:03.935Z\"\n\t\t\t\t},\n\t\t\t\t\"stats\": {\n\t\t\t\t\t\"additions\": 15,\n\t\t\t\t\t\"deletions\": 10,\n\t\t\t\t\t\"total\": 25\n\t\t\t\t},\n\t\t\t\t\"status\": \"running\",\n\t\t\t\t\"project_id\": 13083\n\t\t\t}\n\t\t`)\n\t})\n\n\tupdatedAt := time.Date(2019, 11, 4, 15, 39, 0o3, 935000000, time.UTC)\n\tcreatedAt := time.Date(2019, 11, 4, 15, 38, 53, 154000000, time.UTC)\n\twant := &Commit{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Sanitize for network graph\",\n\t\tAuthorName:     \"randx\",\n\t\tAuthorEmail:    \"venkateshthalluri123@gmail.com\",\n\t\tCommitterName:  \"Venkatesh\",\n\t\tCommitterEmail: \"venkateshthalluri123@gmail.com\",\n\t\tMessage:        \"Sanitize for network graph\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStats:          &CommitStats{Additions: 15, Deletions: 10, Total: 25},\n\t\tStatus:         Ptr(Running),\n\t\tLastPipeline: &PipelineInfo{\n\t\t\tID:        8,\n\t\t\tRef:       \"master\",\n\t\t\tSHA:       \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\tStatus:    \"created\",\n\t\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\tUpdatedAt: &updatedAt,\n\t\t\tCreatedAt: &createdAt,\n\t\t},\n\t\tProjectID: 13083,\n\t}\n\n\tc, resp, err := client.Commits.CreateCommit(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, c)\n\n\tc, resp, err = client.Commits.CreateCommit(1.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Commits.CreateCommit(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Commits.CreateCommit(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, c)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_GetCommitDiff(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/master/diff\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"diff\": \"--- a/doc/update/5.4-to-6.0.md\\n+++ b/doc/update/5.4-to-6.0.md\\n@@ -71,6 +71,8 @@\\n sudo -u git -H bundle exec rake migrate_keys RAILS_ENV=production\\n sudo -u git -H bundle exec rake migrate_inline_notes RAILS_ENV=production\\n \\n+sudo -u git -H bundle exec rake gitlab:assets:compile RAILS_ENV=production\\n+\\n \\n \\n ### 6. Update config files\",\n\t\t\t\t\"new_path\": \"doc/update/5.4-to-6.0.md\",\n\t\t\t\t\"old_path\": \"doc/update/5.4-to-6.0.md\",\n\t\t\t\t\"a_mode\": null,\n\t\t\t\t\"b_mode\": \"100644\",\n\t\t\t\t\"new_file\": false,\n\t\t\t\t\"renamed_file\": false,\n\t\t\t\t\"deleted_file\": false\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Diff{{\n\t\tDiff:    \"--- a/doc/update/5.4-to-6.0.md\\n+++ b/doc/update/5.4-to-6.0.md\\n@@ -71,6 +71,8 @@\\n sudo -u git -H bundle exec rake migrate_keys RAILS_ENV=production\\n sudo -u git -H bundle exec rake migrate_inline_notes RAILS_ENV=production\\n \\n+sudo -u git -H bundle exec rake gitlab:assets:compile RAILS_ENV=production\\n+\\n \\n \\n ### 6. Update config files\",\n\t\tNewPath: \"doc/update/5.4-to-6.0.md\",\n\t\tOldPath: \"doc/update/5.4-to-6.0.md\",\n\t\tBMode:   \"100644\",\n\t}}\n\n\tds, resp, err := client.Commits.GetCommitDiff(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Commits.GetCommitDiff(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Commits.GetCommitDiff(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Commits.GetCommitDiff(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_GetCommitComments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/master/comments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"note\": \"this code is really nice\",\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 11,\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"state\": \"active\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*CommitComment{{\n\t\tNote: \"this code is really nice\",\n\t\tAuthor: Author{\n\t\t\tID:       11,\n\t\t\tUsername: \"venky333\",\n\t\t\tEmail:    \"venkateshthalluri123@gmail.com\",\n\t\t\tName:     \"Venkatesh Thalluri\",\n\t\t\tState:    \"active\",\n\t\t},\n\t}}\n\n\tccs, resp, err := client.Commits.GetCommitComments(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ccs)\n\n\tccs, resp, err = client.Commits.GetCommitComments(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ccs)\n\n\tccs, resp, err = client.Commits.GetCommitComments(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ccs)\n\n\tccs, resp, err = client.Commits.GetCommitComments(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ccs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_PostCommitComment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/master/comments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"note\": \"this code is really nice\",\n\t\t\t\"author\": {\n\t\t\t  \"id\": 11,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"state\": \"active\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &CommitComment{\n\t\tNote: \"this code is really nice\",\n\t\tAuthor: Author{\n\t\t\tID:       11,\n\t\t\tUsername: \"venky333\",\n\t\t\tEmail:    \"venkateshthalluri123@gmail.com\",\n\t\t\tName:     \"Venkatesh Thalluri\",\n\t\t\tState:    \"active\",\n\t\t},\n\t}\n\n\tcc, resp, err := client.Commits.PostCommitComment(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, cc)\n\n\tcc, resp, err = client.Commits.PostCommitComment(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cc)\n\n\tcc, resp, err = client.Commits.PostCommitComment(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cc)\n\n\tcc, resp, err = client.Commits.PostCommitComment(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, cc)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_ListMergeRequestsByCommit(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/master/merge_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"iid\": 1,\n\t\t\t\t\"project_id\": 3,\n\t\t\t\t\"title\": \"test1\",\n\t\t\t\t\"description\": \"fixed login page css paddings\",\n\t\t\t\t\"state\": \"merged\",\n\t\t\t\t\"merged_by\": {\n\t\t\t\t  \"id\": 87854,\n\t\t\t\t  \"name\": \"Douwe Maan\",\n\t\t\t\t  \"username\": \"DouweM\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://gitlab.example.com/uploads/-/system/user/avatar/87854/avatar.png\",\n\t\t\t\t  \"web_url\": \"https://gitlab.com/DouweM\"\n\t\t\t\t},\n\t\t\t\t\"closed_by\": null,\n\t\t\t\t\"closed_at\": null,\n\t\t\t\t\"target_branch\": \"master\",\n\t\t\t\t\"source_branch\": \"test1\",\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"admin\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": null,\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/admin\"\n\t\t\t\t},\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"admin\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": null,\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/admin\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venkatesh.thalluri\",\n\t\t\t\t  \"id\": 12,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/46f6f7dc858ada7be1853f7fb96e81da?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/axel.block\"\n\t\t\t\t}],\n\t\t\t\t\"reviewers\": [{\n\t\t\t\t  \"id\": 2,\n\t\t\t\t  \"name\": \"Sam Bauch\",\n\t\t\t\t  \"username\": \"kenyatta_oconnell\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/956c92487c6f6f7616b536927e22c9a0?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com//kenyatta_oconnell\"\n\t\t\t\t}],\n\t\t\t\t\"source_project_id\": 2,\n\t\t\t\t\"target_project_id\": 3,\n\t\t\t\t\"draft\": false,\n\t\t\t\t\"work_in_progress\": false,\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"iid\": 1,\n\t\t\t\t  \"project_id\": 3,\n\t\t\t\t  \"title\": \"v2.0\",\n\t\t\t\t  \"description\": \"Assumenda aut placeat expedita exercitationem labore sunt enim earum.\",\n\t\t\t\t  \"state\": \"closed\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/my-group/my-project/milestones/1\"\n\t\t\t\t},\n\t\t\t\t\"merge_when_pipeline_succeeds\": true,\n\t\t\t\t\"detailed_merge_status\": \"mergeable\",\n\t\t\t\t\"sha\": \"8888888888888888888888888888888888888888\",\n\t\t\t\t\"merge_commit_sha\": null,\n\t\t\t\t\"squash_commit_sha\": null,\n\t\t\t\t\"user_notes_count\": 1,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"should_remove_source_branch\": true,\n\t\t\t\t\"force_remove_source_branch\": false,\n\t\t\t\t\"allow_collaboration\": false,\n\t\t\t\t\"allow_maintainer_to_push\": false,\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/my-group/my-project/merge_requests/1\",\n\t\t\t\t\"references\": {\n\t\t\t\t  \"short\": \"!1\",\n\t\t\t\t  \"relative\": \"my-group/my-project!1\",\n\t\t\t\t  \"full\": \"my-group/my-project!1\"\n\t\t\t\t},\n\t\t\t\t\"squash\": false,\n\t\t\t\t\"task_completion_status\":{\n\t\t\t\t  \"count\":0,\n\t\t\t\t  \"completed_count\":0\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*MergeRequest{{\n\t\tID:           1,\n\t\tIID:          1,\n\t\tTargetBranch: \"master\",\n\t\tSourceBranch: \"test1\",\n\t\tProjectID:    3,\n\t\tTitle:        \"test1\",\n\t\tState:        \"merged\",\n\t\tUpvotes:      0,\n\t\tDownvotes:    0,\n\t\tAuthor: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"admin\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tCreatedAt: nil,\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"https://gitlab.example.com/admin\",\n\t\t},\n\t\tAssignee: &BasicUser{\n\t\t\tID: 1, Username: \"admin\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"https://gitlab.example.com/admin\",\n\t\t},\n\t\tAssignees: []*BasicUser{{\n\t\t\tID:        12,\n\t\t\tUsername:  \"venkatesh.thalluri\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/46f6f7dc858ada7be1853f7fb96e81da?s=80&d=identicon\", WebURL: \"https://gitlab.example.com/axel.block\",\n\t\t}},\n\t\tReviewers: []*BasicUser{{\n\t\t\tID:        2,\n\t\t\tUsername:  \"kenyatta_oconnell\",\n\t\t\tName:      \"Sam Bauch\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/956c92487c6f6f7616b536927e22c9a0?s=80&d=identicon\", WebURL: \"http://gitlab.example.com//kenyatta_oconnell\",\n\t\t}},\n\t\tSourceProjectID: 2,\n\t\tTargetProjectID: 3,\n\t\tDescription:     \"fixed login page css paddings\",\n\t\tWorkInProgress:  false,\n\t\tMilestone: &Milestone{\n\t\t\tID:          5,\n\t\t\tIID:         1,\n\t\t\tProjectID:   3,\n\t\t\tTitle:       \"v2.0\",\n\t\t\tDescription: \"Assumenda aut placeat expedita exercitationem labore sunt enim earum.\",\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"https://gitlab.example.com/my-group/my-project/milestones/1\",\n\t\t},\n\t\tMergeWhenPipelineSucceeds: true,\n\t\tDetailedMergeStatus:       \"mergeable\",\n\t\tMergeError:                \"\",\n\t\tMergedBy: &BasicUser{\n\t\t\tID:        87854,\n\t\t\tUsername:  \"DouweM\",\n\t\t\tName:      \"Douwe Maan\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://gitlab.example.com/uploads/-/system/user/avatar/87854/avatar.png\",\n\t\t\tWebURL:    \"https://gitlab.com/DouweM\",\n\t\t},\n\t\tSubscribed:               false,\n\t\tSHA:                      \"8888888888888888888888888888888888888888\",\n\t\tMergeCommitSHA:           \"\",\n\t\tSquashCommitSHA:          \"\",\n\t\tUserNotesCount:           1,\n\t\tChangesCount:             \"\",\n\t\tShouldRemoveSourceBranch: true,\n\t\tForceRemoveSourceBranch:  false,\n\t\tAllowCollaboration:       false,\n\t\tWebURL:                   \"http://gitlab.example.com/my-group/my-project/merge_requests/1\",\n\t\tReferences: &IssueReferences{\n\t\t\tShort:    \"!1\",\n\t\t\tRelative: \"my-group/my-project!1\",\n\t\t\tFull:     \"my-group/my-project!1\",\n\t\t},\n\t\tDiscussionLocked:     false,\n\t\tSquash:               false,\n\t\tDivergedCommitsCount: 0,\n\t\tRebaseInProgress:     false,\n\t\tApprovalsBeforeMerge: 0,\n\t\tReference:            \"\",\n\t\tFirstContribution:    false,\n\t\tTaskCompletionStatus: &TasksCompletionStatus{\n\t\t\tCount:          0,\n\t\t\tCompletedCount: 0,\n\t\t},\n\t\tHasConflicts:                false,\n\t\tBlockingDiscussionsResolved: false,\n\t\tOverflow:                    false,\n\t}}\n\n\tmrs, resp, err := client.Commits.ListMergeRequestsByCommit(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, mrs)\n\n\tmrs, resp, err = client.Commits.ListMergeRequestsByCommit(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, mrs)\n\n\tmrs, resp, err = client.Commits.ListMergeRequestsByCommit(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, mrs)\n\n\tmrs, resp, err = client.Commits.ListMergeRequestsByCommit(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, mrs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestCommitsService_CherryPickCommit(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/commits/master/cherry_pick\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\t\t\t\"short_id\": \"6104942438c\",\n\t\t\t\t\"title\": \"Sanitize for network graph\",\n\t\t\t\t\"author_name\": \"randx\",\n\t\t\t\t\"author_email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t\"committer_name\": \"Venkatesh\",\n\t\t\t\t\"committer_email\": \"venkateshthalluri123@gmail.com\",\n\t\t\t\t\"message\": \"Sanitize for network graph\",\n\t\t\t\t\"parent_ids\": [\n\t\t\t\t\t\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"\n\t\t\t\t],\n\t\t\t\t\"last_pipeline\": {\n\t\t\t\t\t\"id\": 8,\n\t\t\t\t\t\"ref\": \"master\",\n\t\t\t\t\t\"sha\": \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\t\t\t\"status\": \"created\",\n\t\t\t\t\t\"web_url\": \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\t\t\t\"created_at\": \"2019-11-04T15:38:53.154Z\",\n\t\t\t\t\t\"updated_at\": \"2019-11-04T15:39:03.935Z\"\n\t\t\t\t},\n\t\t\t\t\"stats\": {\n\t\t\t\t\t\"additions\": 15,\n\t\t\t\t\t\"deletions\": 10,\n\t\t\t\t\t\"total\": 25\n\t\t\t\t},\n\t\t\t\t\"status\": \"running\",\n\t\t\t\t\"project_id\": 13083\n\t\t\t}\n\t\t`)\n\t})\n\n\tupdatedAt := time.Date(2019, 11, 4, 15, 39, 0o3, 935000000, time.UTC)\n\tcreatedAt := time.Date(2019, 11, 4, 15, 38, 53, 154000000, time.UTC)\n\twant := &Commit{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Sanitize for network graph\",\n\t\tAuthorName:     \"randx\",\n\t\tAuthorEmail:    \"venkateshthalluri123@gmail.com\",\n\t\tCommitterName:  \"Venkatesh\",\n\t\tCommitterEmail: \"venkateshthalluri123@gmail.com\",\n\t\tMessage:        \"Sanitize for network graph\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStats:          &CommitStats{Additions: 15, Deletions: 10, Total: 25},\n\t\tStatus:         Ptr(Running),\n\t\tLastPipeline: &PipelineInfo{\n\t\t\tID:        8,\n\t\t\tRef:       \"master\",\n\t\t\tSHA:       \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\",\n\t\t\tStatus:    \"created\",\n\t\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ce/pipelines/54268416\",\n\t\t\tUpdatedAt: &updatedAt,\n\t\t\tCreatedAt: &createdAt,\n\t\t},\n\t\tProjectID: 13083,\n\t}\n\n\tc, resp, err := client.Commits.CherryPickCommit(1, \"master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, c)\n\n\tc, resp, err = client.Commits.CherryPickCommit(1.01, \"master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Commits.CherryPickCommit(1, \"master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Commits.CherryPickCommit(3, \"master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, c)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "container_registry.go",
          "type": "blob",
          "size": 10.177734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ContainerRegistryService handles communication with the container registry\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/container_registry.html\ntype ContainerRegistryService struct {\n\tclient *Client\n}\n\n// RegistryRepository represents a GitLab content registry repository.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/container_registry.html\ntype RegistryRepository struct {\n\tID                     int                      `json:\"id\"`\n\tName                   string                   `json:\"name\"`\n\tPath                   string                   `json:\"path\"`\n\tProjectID              int                      `json:\"project_id\"`\n\tLocation               string                   `json:\"location\"`\n\tCreatedAt              *time.Time               `json:\"created_at\"`\n\tCleanupPolicyStartedAt *time.Time               `json:\"cleanup_policy_started_at\"`\n\tStatus                 *ContainerRegistryStatus `json:\"status\"`\n\tTagsCount              int                      `json:\"tags_count\"`\n\tTags                   []*RegistryRepositoryTag `json:\"tags\"`\n}\n\nfunc (s RegistryRepository) String() string {\n\treturn Stringify(s)\n}\n\n// RegistryRepositoryTag represents a GitLab registry image tag.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/container_registry.html\ntype RegistryRepositoryTag struct {\n\tName          string     `json:\"name\"`\n\tPath          string     `json:\"path\"`\n\tLocation      string     `json:\"location\"`\n\tRevision      string     `json:\"revision\"`\n\tShortRevision string     `json:\"short_revision\"`\n\tDigest        string     `json:\"digest\"`\n\tCreatedAt     *time.Time `json:\"created_at\"`\n\tTotalSize     int        `json:\"total_size\"`\n}\n\nfunc (s RegistryRepositoryTag) String() string {\n\treturn Stringify(s)\n}\n\n// ListRegistryRepositoriesOptions represents the available\n// ListRegistryRepositories() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#list-registry-repositories\ntype ListRegistryRepositoriesOptions struct {\n\tListOptions\n\n\t// Deprecated: These options are deprecated for ListGroupRegistryRepositories calls. (Removed in GitLab 15.0)\n\tTags      *bool `url:\"tags,omitempty\" json:\"tags,omitempty\"`\n\tTagsCount *bool `url:\"tags_count,omitempty\" json:\"tags_count,omitempty\"`\n}\n\n// ListProjectRegistryRepositories gets a list of registry repositories in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#within-a-project\nfunc (s *ContainerRegistryService) ListProjectRegistryRepositories(pid interface{}, opt *ListRegistryRepositoriesOptions, options ...RequestOptionFunc) ([]*RegistryRepository, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/registry/repositories\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar repos []*RegistryRepository\n\tresp, err := s.client.Do(req, &repos)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn repos, resp, nil\n}\n\n// ListGroupRegistryRepositories gets a list of registry repositories in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#within-a-group\nfunc (s *ContainerRegistryService) ListGroupRegistryRepositories(gid interface{}, opt *ListRegistryRepositoriesOptions, options ...RequestOptionFunc) ([]*RegistryRepository, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/registry/repositories\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar repos []*RegistryRepository\n\tresp, err := s.client.Do(req, &repos)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn repos, resp, nil\n}\n\n// GetSingleRegistryRepositoryOptions represents the available\n// GetSingleRegistryRepository() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#get-details-of-a-single-repository\ntype GetSingleRegistryRepositoryOptions struct {\n\tTags      *bool `url:\"tags,omitempty\" json:\"tags,omitempty\"`\n\tTagsCount *bool `url:\"tags_count,omitempty\" json:\"tags_count,omitempty\"`\n}\n\n// GetSingleRegistryRepository gets the details of single registry repository.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#get-details-of-a-single-repository\nfunc (s *ContainerRegistryService) GetSingleRegistryRepository(pid interface{}, opt *GetSingleRegistryRepositoryOptions, options ...RequestOptionFunc) (*RegistryRepository, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"registry/repositories/%s\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trepo := new(RegistryRepository)\n\tresp, err := s.client.Do(req, repo)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn repo, resp, nil\n}\n\n// DeleteRegistryRepository deletes a repository in a registry.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#delete-registry-repository\nfunc (s *ContainerRegistryService) DeleteRegistryRepository(pid interface{}, repository int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/registry/repositories/%d\", PathEscape(project), repository)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListRegistryRepositoryTagsOptions represents the available\n// ListRegistryRepositoryTags() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#list-registry-repository-tags\ntype ListRegistryRepositoryTagsOptions ListOptions\n\n// ListRegistryRepositoryTags gets a list of tags for given registry repository.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#list-registry-repository-tags\nfunc (s *ContainerRegistryService) ListRegistryRepositoryTags(pid interface{}, repository int, opt *ListRegistryRepositoryTagsOptions, options ...RequestOptionFunc) ([]*RegistryRepositoryTag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/registry/repositories/%d/tags\",\n\t\tPathEscape(project),\n\t\trepository,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar tags []*RegistryRepositoryTag\n\tresp, err := s.client.Do(req, &tags)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn tags, resp, nil\n}\n\n// GetRegistryRepositoryTagDetail get details of a registry repository tag\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#get-details-of-a-registry-repository-tag\nfunc (s *ContainerRegistryService) GetRegistryRepositoryTagDetail(pid interface{}, repository int, tagName string, options ...RequestOptionFunc) (*RegistryRepositoryTag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/registry/repositories/%d/tags/%s\",\n\t\tPathEscape(project),\n\t\trepository,\n\t\ttagName,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ttag := new(RegistryRepositoryTag)\n\tresp, err := s.client.Do(req, &tag)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn tag, resp, nil\n}\n\n// DeleteRegistryRepositoryTag deletes a registry repository tag.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#delete-a-registry-repository-tag\nfunc (s *ContainerRegistryService) DeleteRegistryRepositoryTag(pid interface{}, repository int, tagName string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/registry/repositories/%d/tags/%s\",\n\t\tPathEscape(project),\n\t\trepository,\n\t\ttagName,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteRegistryRepositoryTagsOptions represents the available\n// DeleteRegistryRepositoryTags() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#delete-registry-repository-tags-in-bulk\ntype DeleteRegistryRepositoryTagsOptions struct {\n\tNameRegexpDelete *string `url:\"name_regex_delete,omitempty\" json:\"name_regex_delete,omitempty\"`\n\tNameRegexpKeep   *string `url:\"name_regex_keep,omitempty\" json:\"name_regex_keep,omitempty\"`\n\tKeepN            *int    `url:\"keep_n,omitempty\" json:\"keep_n,omitempty\"`\n\tOlderThan        *string `url:\"older_than,omitempty\" json:\"older_than,omitempty\"`\n\n\t// Deprecated: NameRegexp is deprecated in favor of NameRegexpDelete.\n\tNameRegexp *string `url:\"name_regex,omitempty\" json:\"name_regex,omitempty\"`\n}\n\n// DeleteRegistryRepositoryTags deletes repository tags in bulk based on\n// given criteria.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#delete-registry-repository-tags-in-bulk\nfunc (s *ContainerRegistryService) DeleteRegistryRepositoryTags(pid interface{}, repository int, opt *DeleteRegistryRepositoryTagsOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/registry/repositories/%d/tags\",\n\t\tPathEscape(project),\n\t\trepository,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "container_registry_test.go",
          "type": "blob",
          "size": 12.1884765625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListProjectRegistryRepositories(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/registry/repositories\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"\",\n\t\t\t  \"path\": \"group/project\",\n\t\t\t  \"project_id\": 9,\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project\",\n\t\t\t  \"created_at\": \"2019-01-10T13:38:57.391Z\",\n\t\t\t  \"cleanup_policy_started_at\": \"2020-01-10T15:40:57.391Z\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"name\": \"releases\",\n\t\t\t  \"path\": \"group/project/releases\",\n\t\t\t  \"project_id\": 9,\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project/releases\",\n\t\t\t  \"created_at\": \"2019-01-10T13:39:08.229Z\",\n\t\t\t  \"cleanup_policy_started_at\": \"2020-08-17T03:12:35.489Z\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\trepositories, _, err := client.ContainerRegistry.ListProjectRegistryRepositories(5, &ListRegistryRepositoriesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRegistry.ListProjectRegistryRepositories returned error: %v\", err)\n\t}\n\n\tcreatedAt1, err := time.Parse(time.RFC3339, \"2019-01-10T13:38:57.391Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListProjectRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\tcreatedAt2, err := time.Parse(time.RFC3339, \"2019-01-10T13:39:08.229Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListProjectRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\tcleanupPolicyStartedAt1, err := time.Parse(time.RFC3339, \"2020-01-10T15:40:57.391Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListProjectRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\tcleanupPolicyStartedAt2, err := time.Parse(time.RFC3339, \"2020-08-17T03:12:35.489Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListProjectRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\twant := []*RegistryRepository{\n\t\t{\n\t\t\tID:                     1,\n\t\t\tName:                   \"\",\n\t\t\tPath:                   \"group/project\",\n\t\t\tProjectID:              9,\n\t\t\tLocation:               \"gitlab.example.com:5000/group/project\",\n\t\t\tCreatedAt:              &createdAt1,\n\t\t\tCleanupPolicyStartedAt: &cleanupPolicyStartedAt1,\n\t\t},\n\t\t{\n\t\t\tID:                     2,\n\t\t\tName:                   \"releases\",\n\t\t\tPath:                   \"group/project/releases\",\n\t\t\tProjectID:              9,\n\t\t\tLocation:               \"gitlab.example.com:5000/group/project/releases\",\n\t\t\tCreatedAt:              &createdAt2,\n\t\t\tCleanupPolicyStartedAt: &cleanupPolicyStartedAt2,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, repositories) {\n\t\tt.Errorf(\"ContainerRepository.ListProjectRegistryRepositories returned %+v, want %+v\", repositories, want)\n\t}\n}\n\nfunc TestListGroupRegistryRepositories(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/registry/repositories\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"\",\n\t\t\t  \"path\": \"group/project\",\n\t\t\t  \"project_id\": 9,\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project\",\n\t\t\t  \"created_at\": \"2019-01-10T13:38:57.391Z\",\n\t\t\t  \"cleanup_policy_started_at\": \"2020-01-10T15:40:57.391Z\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"name\": \"releases\",\n\t\t\t  \"path\": \"group/project/releases\",\n\t\t\t  \"project_id\": 9,\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project/releases\",\n\t\t\t  \"created_at\": \"2019-01-10T13:39:08.229Z\",\n\t\t\t  \"cleanup_policy_started_at\": \"2020-08-17T03:12:35.489Z\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\trepositories, _, err := client.ContainerRegistry.ListGroupRegistryRepositories(5, &ListRegistryRepositoriesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRegistry.ListGroupRegistryRepositories returned error: %v\", err)\n\t}\n\n\tcreatedAt1, err := time.Parse(time.RFC3339, \"2019-01-10T13:38:57.391Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListGroupRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\tcreatedAt2, err := time.Parse(time.RFC3339, \"2019-01-10T13:39:08.229Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListGroupRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\tcleanupPolicyStartedAt1, err := time.Parse(time.RFC3339, \"2020-01-10T15:40:57.391Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListGroupRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\tcleanupPolicyStartedAt2, err := time.Parse(time.RFC3339, \"2020-08-17T03:12:35.489Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListGroupRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\twant := []*RegistryRepository{\n\t\t{\n\t\t\tID:                     1,\n\t\t\tName:                   \"\",\n\t\t\tPath:                   \"group/project\",\n\t\t\tProjectID:              9,\n\t\t\tLocation:               \"gitlab.example.com:5000/group/project\",\n\t\t\tCreatedAt:              &createdAt1,\n\t\t\tCleanupPolicyStartedAt: &cleanupPolicyStartedAt1,\n\t\t},\n\t\t{\n\t\t\tID:                     2,\n\t\t\tName:                   \"releases\",\n\t\t\tPath:                   \"group/project/releases\",\n\t\t\tProjectID:              9,\n\t\t\tLocation:               \"gitlab.example.com:5000/group/project/releases\",\n\t\t\tCreatedAt:              &createdAt2,\n\t\t\tCleanupPolicyStartedAt: &cleanupPolicyStartedAt2,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, repositories) {\n\t\tt.Errorf(\"ContainerRepository.ListGroupRegistryRepositories returned %+v, want %+v\", repositories, want)\n\t}\n}\n\nfunc TestGetSingleRegistryRepository(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/registry/repositories/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"\",\n\t\t\t  \"path\": \"group/project\",\n\t\t\t  \"project_id\": 9,\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project\",\n\t\t\t  \"created_at\": \"2019-01-10T13:38:57.391Z\",\n\t\t\t  \"cleanup_policy_started_at\": \"2020-01-10T15:40:57.391Z\"\n\t\t  }`)\n\t})\n\n\trepository, _, err := client.ContainerRegistry.GetSingleRegistryRepository(5, &GetSingleRegistryRepositoryOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRegistry.GetSingleRegistryRepository returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(time.RFC3339, \"2019-01-10T13:38:57.391Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.GetSingleRegistryRepository error while parsing time: %v\", err)\n\t}\n\tcleanupPolicyStartedAt, err := time.Parse(time.RFC3339, \"2020-01-10T15:40:57.391Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.GetSingleRegistryRepository error while parsing time: %v\", err)\n\t}\n\n\twant := &RegistryRepository{\n\t\tID:                     1,\n\t\tName:                   \"\",\n\t\tPath:                   \"group/project\",\n\t\tProjectID:              9,\n\t\tLocation:               \"gitlab.example.com:5000/group/project\",\n\t\tCreatedAt:              &createdAt,\n\t\tCleanupPolicyStartedAt: &cleanupPolicyStartedAt,\n\t}\n\tif !reflect.DeepEqual(want, repository) {\n\t\tt.Errorf(\"ContainerRepository.GetSingleRegistryRepository returned %+v, want %+v\", repository, want)\n\t}\n}\n\nfunc TestDeleteRegistryRepository(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/registry/repositories/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.ContainerRegistry.DeleteRegistryRepository(5, 2)\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRegistry.DeleteRegistryRepository returned error: %v\", err)\n\t}\n}\n\nfunc TestListRegistryRepositoryTags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/registry/repositories/2/tags\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"name\": \"A\",\n\t\t\t  \"path\": \"group/project:A\",\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project:A\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"name\": \"latest\",\n\t\t\t  \"path\": \"group/project:latest\",\n\t\t\t  \"location\": \"gitlab.example.com:5000/group/project:latest\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\topt := &ListRegistryRepositoryTagsOptions{}\n\tregistryRepositoryTags, _, err := client.ContainerRegistry.ListRegistryRepositoryTags(5, 2, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRegistry.ListRegistryRepositoryTags returned error: %v\", err)\n\t}\n\n\twant := []*RegistryRepositoryTag{\n\t\t{\n\t\t\tName:     \"A\",\n\t\t\tPath:     \"group/project:A\",\n\t\t\tLocation: \"gitlab.example.com:5000/group/project:A\",\n\t\t},\n\t\t{\n\t\t\tName:     \"latest\",\n\t\t\tPath:     \"group/project:latest\",\n\t\t\tLocation: \"gitlab.example.com:5000/group/project:latest\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, registryRepositoryTags) {\n\t\tt.Errorf(\"ContainerRepository.ListRegistryRepositoryTags returned %+v, want %+v\", registryRepositoryTags, want)\n\t}\n}\n\nfunc TestGetRegistryRepositoryTagDetail(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/registry/repositories/2/tags/v10.0.0\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"name\": \"v10.0.0\",\n\t\t\t\"path\": \"group/project:latest\",\n\t\t\t\"location\": \"gitlab.example.com:5000/group/project:latest\",\n\t\t\t\"revision\": \"e9ed9d87c881d8c2fd3a31b41904d01ba0b836e7fd15240d774d811a1c248181\",\n\t\t\t\"short_revision\": \"e9ed9d87c\",\n\t\t\t\"digest\": \"sha256:c3490dcf10ffb6530c1303522a1405dfaf7daecd8f38d3e6a1ba19ea1f8a1751\",\n\t\t\t\"created_at\": \"2019-01-06T16:49:51.272+00:00\",\n\t\t\t\"total_size\": 350224384\n\t\t  }`)\n\t})\n\n\trepositoryTag, _, err := client.ContainerRegistry.GetRegistryRepositoryTagDetail(5, 2, \"v10.0.0\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRegistry.GetRegistryRepositoryTagDetail returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2019-01-06T16:49:51.272+00:00\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.ListRegistryRepositories error while parsing time: %v\", err)\n\t}\n\n\twant := &RegistryRepositoryTag{\n\t\tName:          \"v10.0.0\",\n\t\tPath:          \"group/project:latest\",\n\t\tLocation:      \"gitlab.example.com:5000/group/project:latest\",\n\t\tRevision:      \"e9ed9d87c881d8c2fd3a31b41904d01ba0b836e7fd15240d774d811a1c248181\",\n\t\tShortRevision: \"e9ed9d87c\",\n\t\tDigest:        \"sha256:c3490dcf10ffb6530c1303522a1405dfaf7daecd8f38d3e6a1ba19ea1f8a1751\",\n\t\tCreatedAt:     &createdAt,\n\t\tTotalSize:     350224384,\n\t}\n\tif !reflect.DeepEqual(want, repositoryTag) {\n\t\tt.Errorf(\"ContainerRepository.ListRegistryRepositories returned %+v, want %+v\", repositoryTag, want)\n\t}\n}\n\nfunc TestDeleteRegistryRepositoryTag(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/registry/repositories/2/tags/v10.0.0\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.ContainerRegistry.DeleteRegistryRepositoryTag(5, 2, \"v10.0.0\")\n\tif err != nil {\n\t\tt.Errorf(\"ContainerRepository.DeleteRegistryRepositoryTag returned error: %v\", err)\n\t}\n}\n\nfunc TestDeleteRegistryRepositoryTags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/registry/repositories/2/tags\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\ttests := []struct {\n\t\tevent           string\n\t\tnameRegexDelete string\n\t\tkeepN           int\n\t\tnameRegexKeep   string\n\t\tolderThan       string\n\t}{\n\t\t{\n\t\t\t\"keep_atleast_5_remove_2_days_old\",\n\t\t\t\"[0-9a-z]{40}\",\n\t\t\t0,\n\t\t\t\"\",\n\t\t\t\"2d\",\n\t\t},\n\t\t{\n\t\t\t\"remove_all_keep_5\",\n\t\t\t\".*\",\n\t\t\t5,\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"remove_all_tags_keep_tags_beginning_with_stable\",\n\t\t\t\".*\",\n\t\t\t0,\n\t\t\t\"stable.*\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"remove_all_tags_older_than_1_month\",\n\t\t\t\".*\",\n\t\t\t0,\n\t\t\t\"\",\n\t\t\t\"1month\",\n\t\t},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\topt := &DeleteRegistryRepositoryTagsOptions{\n\t\t\t\tNameRegexpDelete: &tc.nameRegexDelete,\n\t\t\t\tNameRegexpKeep:   &tc.nameRegexKeep,\n\t\t\t\tKeepN:            &tc.keepN,\n\t\t\t\tOlderThan:        &tc.olderThan,\n\t\t\t}\n\t\t\t_, err := client.ContainerRegistry.DeleteRegistryRepositoryTags(5, 2, opt)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"ContainerRegistry.DeleteRegistryRepositoryTags returned error: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "custom_attributes.go",
          "type": "blob",
          "size": 7.4775390625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// CustomAttributesService handles communication with the group, project and\n// user custom attributes related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/custom_attributes.html\ntype CustomAttributesService struct {\n\tclient *Client\n}\n\n// CustomAttribute struct is used to unmarshal response to api calls.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/custom_attributes.html\ntype CustomAttribute struct {\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\n// ListCustomUserAttributes lists the custom attributes of the specified user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#list-custom-attributes\nfunc (s *CustomAttributesService) ListCustomUserAttributes(user int, options ...RequestOptionFunc) ([]*CustomAttribute, *Response, error) {\n\treturn s.listCustomAttributes(\"users\", user, options...)\n}\n\n// ListCustomGroupAttributes lists the custom attributes of the specified group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#list-custom-attributes\nfunc (s *CustomAttributesService) ListCustomGroupAttributes(group int, options ...RequestOptionFunc) ([]*CustomAttribute, *Response, error) {\n\treturn s.listCustomAttributes(\"groups\", group, options...)\n}\n\n// ListCustomProjectAttributes lists the custom attributes of the specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#list-custom-attributes\nfunc (s *CustomAttributesService) ListCustomProjectAttributes(project int, options ...RequestOptionFunc) ([]*CustomAttribute, *Response, error) {\n\treturn s.listCustomAttributes(\"projects\", project, options...)\n}\n\nfunc (s *CustomAttributesService) listCustomAttributes(resource string, id int, options ...RequestOptionFunc) ([]*CustomAttribute, *Response, error) {\n\tu := fmt.Sprintf(\"%s/%d/custom_attributes\", resource, id)\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cas []*CustomAttribute\n\tresp, err := s.client.Do(req, &cas)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn cas, resp, nil\n}\n\n// GetCustomUserAttribute returns the user attribute with a speciifc key.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#single-custom-attribute\nfunc (s *CustomAttributesService) GetCustomUserAttribute(user int, key string, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\treturn s.getCustomAttribute(\"users\", user, key, options...)\n}\n\n// GetCustomGroupAttribute returns the group attribute with a speciifc key.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#single-custom-attribute\nfunc (s *CustomAttributesService) GetCustomGroupAttribute(group int, key string, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\treturn s.getCustomAttribute(\"groups\", group, key, options...)\n}\n\n// GetCustomProjectAttribute returns the project attribute with a speciifc key.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#single-custom-attribute\nfunc (s *CustomAttributesService) GetCustomProjectAttribute(project int, key string, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\treturn s.getCustomAttribute(\"projects\", project, key, options...)\n}\n\nfunc (s *CustomAttributesService) getCustomAttribute(resource string, id int, key string, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\tu := fmt.Sprintf(\"%s/%d/custom_attributes/%s\", resource, id, key)\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ca *CustomAttribute\n\tresp, err := s.client.Do(req, &ca)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn ca, resp, nil\n}\n\n// SetCustomUserAttribute sets the custom attributes of the specified user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#set-custom-attribute\nfunc (s *CustomAttributesService) SetCustomUserAttribute(user int, c CustomAttribute, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\treturn s.setCustomAttribute(\"users\", user, c, options...)\n}\n\n// SetCustomGroupAttribute sets the custom attributes of the specified group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#set-custom-attribute\nfunc (s *CustomAttributesService) SetCustomGroupAttribute(group int, c CustomAttribute, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\treturn s.setCustomAttribute(\"groups\", group, c, options...)\n}\n\n// SetCustomProjectAttribute sets the custom attributes of the specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#set-custom-attribute\nfunc (s *CustomAttributesService) SetCustomProjectAttribute(project int, c CustomAttribute, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\treturn s.setCustomAttribute(\"projects\", project, c, options...)\n}\n\nfunc (s *CustomAttributesService) setCustomAttribute(resource string, id int, c CustomAttribute, options ...RequestOptionFunc) (*CustomAttribute, *Response, error) {\n\tu := fmt.Sprintf(\"%s/%d/custom_attributes/%s\", resource, id, c.Key)\n\treq, err := s.client.NewRequest(http.MethodPut, u, c, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tca := new(CustomAttribute)\n\tresp, err := s.client.Do(req, ca)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn ca, resp, nil\n}\n\n// DeleteCustomUserAttribute removes the custom attribute of the specified user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#delete-custom-attribute\nfunc (s *CustomAttributesService) DeleteCustomUserAttribute(user int, key string, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteCustomAttribute(\"users\", user, key, options...)\n}\n\n// DeleteCustomGroupAttribute removes the custom attribute of the specified group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#delete-custom-attribute\nfunc (s *CustomAttributesService) DeleteCustomGroupAttribute(group int, key string, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteCustomAttribute(\"groups\", group, key, options...)\n}\n\n// DeleteCustomProjectAttribute removes the custom attribute of the specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/custom_attributes.html#delete-custom-attribute\nfunc (s *CustomAttributesService) DeleteCustomProjectAttribute(project int, key string, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.deleteCustomAttribute(\"projects\", project, key, options...)\n}\n\nfunc (s *CustomAttributesService) deleteCustomAttribute(resource string, id int, key string, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"%s/%d/custom_attributes/%s\", resource, id, key)\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "custom_attributes_test.go",
          "type": "blob",
          "size": 8.2109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListCustomUserAttributes(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/2/custom_attributes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"key\":\"testkey1\", \"value\":\"testvalue1\"}, {\"key\":\"testkey2\", \"value\":\"testvalue2\"}]`)\n\t})\n\n\tcustomAttributes, _, err := client.CustomAttribute.ListCustomUserAttributes(2)\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.ListCustomUserAttributes returned error: %v\", err)\n\t}\n\n\twant := []*CustomAttribute{{Key: \"testkey1\", Value: \"testvalue1\"}, {Key: \"testkey2\", Value: \"testvalue2\"}}\n\tif !reflect.DeepEqual(want, customAttributes) {\n\t\tt.Errorf(\"CustomAttribute.ListCustomUserAttributes returned %+v, want %+v\", customAttributes, want)\n\t}\n}\n\nfunc TestListCustomGroupAttributes(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/2/custom_attributes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"key\":\"testkey1\", \"value\":\"testvalue1\"}, {\"key\":\"testkey2\", \"value\":\"testvalue2\"}]`)\n\t})\n\n\tcustomAttributes, _, err := client.CustomAttribute.ListCustomGroupAttributes(2)\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.ListCustomGroupAttributes returned error: %v\", err)\n\t}\n\n\twant := []*CustomAttribute{{Key: \"testkey1\", Value: \"testvalue1\"}, {Key: \"testkey2\", Value: \"testvalue2\"}}\n\tif !reflect.DeepEqual(want, customAttributes) {\n\t\tt.Errorf(\"CustomAttribute.ListCustomGroupAttributes returned %+v, want %+v\", customAttributes, want)\n\t}\n}\n\nfunc TestListCustomProjectAttributes(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/2/custom_attributes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"key\":\"testkey1\", \"value\":\"testvalue1\"}, {\"key\":\"testkey2\", \"value\":\"testvalue2\"}]`)\n\t})\n\n\tcustomAttributes, _, err := client.CustomAttribute.ListCustomProjectAttributes(2)\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.ListCustomProjectAttributes returned error: %v\", err)\n\t}\n\n\twant := []*CustomAttribute{{Key: \"testkey1\", Value: \"testvalue1\"}, {Key: \"testkey2\", Value: \"testvalue2\"}}\n\tif !reflect.DeepEqual(want, customAttributes) {\n\t\tt.Errorf(\"CustomAttribute.ListCustomProjectAttributes returned %+v, want %+v\", customAttributes, want)\n\t}\n}\n\nfunc TestGetCustomUserAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"key\":\"testkey1\", \"value\":\"testvalue1\"}`)\n\t})\n\n\tcustomAttribute, _, err := client.CustomAttribute.GetCustomUserAttribute(2, \"testkey1\")\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.GetCustomUserAttribute returned error: %v\", err)\n\t}\n\n\twant := &CustomAttribute{Key: \"testkey1\", Value: \"testvalue1\"}\n\tif !reflect.DeepEqual(want, customAttribute) {\n\t\tt.Errorf(\"CustomAttribute.GetCustomUserAttribute returned %+v, want %+v\", customAttribute, want)\n\t}\n}\n\nfunc TestGetCustomGropupAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"key\":\"testkey1\", \"value\":\"testvalue1\"}`)\n\t})\n\n\tcustomAttribute, _, err := client.CustomAttribute.GetCustomGroupAttribute(2, \"testkey1\")\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.GetCustomGroupAttribute returned error: %v\", err)\n\t}\n\n\twant := &CustomAttribute{Key: \"testkey1\", Value: \"testvalue1\"}\n\tif !reflect.DeepEqual(want, customAttribute) {\n\t\tt.Errorf(\"CustomAttribute.GetCustomGroupAttribute returned %+v, want %+v\", customAttribute, want)\n\t}\n}\n\nfunc TestGetCustomProjectAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"key\":\"testkey1\", \"value\":\"testvalue1\"}`)\n\t})\n\n\tcustomAttribute, _, err := client.CustomAttribute.GetCustomProjectAttribute(2, \"testkey1\")\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.GetCustomProjectAttribute returned error: %v\", err)\n\t}\n\n\twant := &CustomAttribute{Key: \"testkey1\", Value: \"testvalue1\"}\n\tif !reflect.DeepEqual(want, customAttribute) {\n\t\tt.Errorf(\"CustomAttribute.GetCustomProjectAttribute returned %+v, want %+v\", customAttribute, want)\n\t}\n}\n\nfunc TestSetCustomUserAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"key\":\"testkey1\", \"value\":\"testvalue1\"}`)\n\t})\n\n\tcustomAttribute, _, err := client.CustomAttribute.SetCustomUserAttribute(2, CustomAttribute{\n\t\tKey:   \"testkey1\",\n\t\tValue: \"testvalue1\",\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.SetCustomUserAttributes returned error: %v\", err)\n\t}\n\n\twant := &CustomAttribute{Key: \"testkey1\", Value: \"testvalue1\"}\n\tif !reflect.DeepEqual(want, customAttribute) {\n\t\tt.Errorf(\"CustomAttribute.SetCustomUserAttributes returned %+v, want %+v\", customAttribute, want)\n\t}\n}\n\nfunc TestSetCustomGroupAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"key\":\"testkey1\", \"value\":\"testvalue1\"}`)\n\t})\n\n\tcustomAttribute, _, err := client.CustomAttribute.SetCustomGroupAttribute(2, CustomAttribute{\n\t\tKey:   \"testkey1\",\n\t\tValue: \"testvalue1\",\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.SetCustomGroupAttributes returned error: %v\", err)\n\t}\n\n\twant := &CustomAttribute{Key: \"testkey1\", Value: \"testvalue1\"}\n\tif !reflect.DeepEqual(want, customAttribute) {\n\t\tt.Errorf(\"CustomAttribute.SetCustomGroupAttributes returned %+v, want %+v\", customAttribute, want)\n\t}\n}\n\nfunc TestDeleteCustomUserAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.CustomAttribute.DeleteCustomUserAttribute(2, \"testkey1\")\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.DeleteCustomUserAttribute returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"CustomAttribute.DeleteCustomUserAttribute returned %d, want %d\", got, want)\n\t}\n}\n\nfunc TestDeleteCustomGroupAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.CustomAttribute.DeleteCustomGroupAttribute(2, \"testkey1\")\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.DeleteCustomGroupAttribute returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"CustomAttribute.DeleteCustomGroupAttribute returned %d, want %d\", got, want)\n\t}\n}\n\nfunc TestDeleteCustomProjectAttribute(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/2/custom_attributes/testkey1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.CustomAttribute.DeleteCustomProjectAttribute(2, \"testkey1\")\n\tif err != nil {\n\t\tt.Errorf(\"CustomAttribute.DeleteCustomProjectAttribute returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"CustomAttribute.DeleteCustomProjectAttribute returned %d, want %d\", got, want)\n\t}\n}\n"
        },
        {
          "name": "dependency_list_export.go",
          "type": "blob",
          "size": 3.720703125,
          "content": "package gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n)\n\ntype DependencyListExportService struct {\n\tclient *Client\n}\n\n// CreateDependencyListExportOptions represents the available CreateDependencyListExport()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/dependency_list_export.html#create-a-pipeline-level-dependency-list-export\ntype CreateDependencyListExportOptions struct {\n\tExportType *string `url:\"export_type\" json:\"export_type\"`\n}\n\n// DependencyListExport represents a request for a GitLab project's dependency list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/dependency_list_export.html#create-a-pipeline-level-dependency-list-export\ntype DependencyListExport struct {\n\tID          int    `json:\"id\"`\n\tHasFinished bool   `json:\"has_finished\"`\n\tSelf        string `json:\"self\"`\n\tDownload    string `json:\"download\"`\n}\n\nconst defaultExportType = \"sbom\"\n\n// CreateDependencyListExport creates a new CycloneDX JSON export for all the project dependencies\n// detected in a pipeline.\n//\n// If an authenticated user does not have permission to read_dependency, this request returns a 403\n// Forbidden status code.\n//\n// SBOM exports can be only accessed by the export’s author.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/api/dependency_list_export.html#create-a-pipeline-level-dependency-list-export\nfunc (s *DependencyListExportService) CreateDependencyListExport(pipelineID int, opt *CreateDependencyListExportOptions, options ...RequestOptionFunc) (*DependencyListExport, *Response, error) {\n\t// POST /pipelines/:id/dependency_list_exports\n\tcreateExportPath := fmt.Sprintf(\"pipelines/%d/dependency_list_exports\", pipelineID)\n\n\tif opt == nil {\n\t\topt = &CreateDependencyListExportOptions{}\n\t}\n\tif opt.ExportType == nil {\n\t\topt.ExportType = Ptr(defaultExportType)\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodPost, createExportPath, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\texport := new(DependencyListExport)\n\tresp, err := s.client.Do(req, &export)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn export, resp, nil\n}\n\n// GetDependencyListExport gets metadata about a single dependency list export.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/api/dependency_list_export.html#get-single-dependency-list-export\nfunc (s *DependencyListExportService) GetDependencyListExport(id int, options ...RequestOptionFunc) (*DependencyListExport, *Response, error) {\n\t// GET /dependency_list_exports/:id\n\tgetExportPath := fmt.Sprintf(\"dependency_list_exports/%d\", id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, getExportPath, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\texport := new(DependencyListExport)\n\tresp, err := s.client.Do(req, &export)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn export, resp, nil\n}\n\n// DownloadDependencyListExport downloads a single dependency list export.\n//\n// The github.com/CycloneDX/cyclonedx-go package can be used to parse the data from the returned io.Reader.\n//\n//\tsbom := new(cdx.BOM)\n//\tdecoder := cdx.NewBOMDecoder(reader, cdx.BOMFileFormatJSON)\n//\n//\tif err = decoder.Decode(sbom); err != nil {\n//\t\tpanic(err)\n//\t}\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/api/dependency_list_export.html#download-dependency-list-export\nfunc (s *DependencyListExportService) DownloadDependencyListExport(id int, options ...RequestOptionFunc) (io.Reader, *Response, error) {\n\t// GET /dependency_list_exports/:id/download\n\tdownloadExportPath := fmt.Sprintf(\"dependency_list_exports/%d/download\", id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, downloadExportPath, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar sbomBuffer bytes.Buffer\n\tresp, err := s.client.Do(req, &sbomBuffer)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn &sbomBuffer, resp, nil\n}\n"
        },
        {
          "name": "dependency_list_export_test.go",
          "type": "blob",
          "size": 2.4013671875,
          "content": "package gitlab\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCreateDependencyListExport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/pipelines/1234/dependency_list_exports\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tbody, err := io.ReadAll(r.Body)\n\t\trequire.NoError(t, err)\n\n\t\tvar content CreateDependencyListExportOptions\n\t\terr = json.Unmarshal(body, &content)\n\t\trequire.NoError(t, err)\n\n\t\tassert.Equal(t, \"sbom\", *content.ExportType)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_dependency_list_export.json\")\n\t})\n\n\td := &CreateDependencyListExportOptions{\n\t\tExportType: Ptr(\"sbom\"),\n\t}\n\n\texport, _, err := client.DependencyListExport.CreateDependencyListExport(1234, d)\n\trequire.NoError(t, err)\n\n\twant := &DependencyListExport{\n\t\tID:          5678,\n\t\tHasFinished: false,\n\t\tSelf:        \"http://gitlab.example.com/api/v4/dependency_list_exports/5678\",\n\t\tDownload:    \"http://gitlab.example.com/api/v4/dependency_list_exports/5678/download\",\n\t}\n\trequire.Equal(t, want, export)\n}\n\nfunc TestGetDependencyListExport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/dependency_list_exports/5678\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_dependency_list_export.json\")\n\t})\n\n\texport, _, err := client.DependencyListExport.GetDependencyListExport(5678)\n\trequire.NoError(t, err)\n\n\twant := &DependencyListExport{\n\t\tID:          5678,\n\t\tHasFinished: true,\n\t\tSelf:        \"http://gitlab.example.com/api/v4/dependency_list_exports/5678\",\n\t\tDownload:    \"http://gitlab.example.com/api/v4/dependency_list_exports/5678/download\",\n\t}\n\trequire.Equal(t, want, export)\n}\n\nfunc TestDownloadDependencyListExport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/dependency_list_exports/5678/download\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/download_dependency_list_export.json\")\n\t})\n\n\tsbomReader, _, err := client.DependencyListExport.DownloadDependencyListExport(5678)\n\trequire.NoError(t, err)\n\n\texpectedSbom, err := os.ReadFile(\"testdata/download_dependency_list_export.json\")\n\trequire.NoError(t, err)\n\n\tvar want bytes.Buffer\n\twant.Write(expectedSbom)\n\n\trequire.Equal(t, &want, sbomReader)\n}\n"
        },
        {
          "name": "deploy_keys.go",
          "type": "blob",
          "size": 8.357421875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// DeployKeysService handles communication with the keys related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/deploy_keys.html\ntype DeployKeysService struct {\n\tclient *Client\n}\n\n// InstanceDeployKey represents a GitLab deploy key with the associated\n// projects it has write access to.\ntype InstanceDeployKey struct {\n\tID                      int                 `json:\"id\"`\n\tTitle                   string              `json:\"title\"`\n\tCreatedAt               *time.Time          `json:\"created_at\"`\n\tKey                     string              `json:\"key\"`\n\tFingerprint             string              `json:\"fingerprint\"`\n\tProjectsWithWriteAccess []*DeployKeyProject `json:\"projects_with_write_access\"`\n}\n\nfunc (k InstanceDeployKey) String() string {\n\treturn Stringify(k)\n}\n\n// DeployKeyProject refers to a project an InstanceDeployKey has write access to.\ntype DeployKeyProject struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n}\n\nfunc (k DeployKeyProject) String() string {\n\treturn Stringify(k)\n}\n\n// ProjectDeployKey represents a GitLab project deploy key.\ntype ProjectDeployKey struct {\n\tID        int        `json:\"id\"`\n\tTitle     string     `json:\"title\"`\n\tKey       string     `json:\"key\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tCanPush   bool       `json:\"can_push\"`\n\tExpiresAt *time.Time `json:\"expires_at\"`\n}\n\nfunc (k ProjectDeployKey) String() string {\n\treturn Stringify(k)\n}\n\n// ListProjectDeployKeysOptions represents the available ListAllDeployKeys()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#list-all-deploy-keys\ntype ListInstanceDeployKeysOptions struct {\n\tListOptions\n\tPublic *bool `url:\"public,omitempty\" json:\"public,omitempty\"`\n}\n\n// ListAllDeployKeys gets a list of all deploy keys\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#list-all-deploy-keys\nfunc (s *DeployKeysService) ListAllDeployKeys(opt *ListInstanceDeployKeysOptions, options ...RequestOptionFunc) ([]*InstanceDeployKey, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"deploy_keys\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ks []*InstanceDeployKey\n\tresp, err := s.client.Do(req, &ks)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ks, resp, nil\n}\n\n// ListProjectDeployKeysOptions represents the available ListProjectDeployKeys()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#list-deploy-keys-for-project\ntype ListProjectDeployKeysOptions ListOptions\n\n// ListProjectDeployKeys gets a list of a project's deploy keys\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#list-deploy-keys-for-project\nfunc (s *DeployKeysService) ListProjectDeployKeys(pid interface{}, opt *ListProjectDeployKeysOptions, options ...RequestOptionFunc) ([]*ProjectDeployKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_keys\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ks []*ProjectDeployKey\n\tresp, err := s.client.Do(req, &ks)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ks, resp, nil\n}\n\n// GetDeployKey gets a single deploy key.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#get-a-single-deploy-key\nfunc (s *DeployKeysService) GetDeployKey(pid interface{}, deployKey int, options ...RequestOptionFunc) (*ProjectDeployKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_keys/%d\", PathEscape(project), deployKey)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(ProjectDeployKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// AddDeployKeyOptions represents the available ADDDeployKey() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#add-deploy-key-for-a-project\ntype AddDeployKeyOptions struct {\n\tKey       *string    `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tTitle     *string    `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tCanPush   *bool      `url:\"can_push,omitempty\" json:\"can_push,omitempty\"`\n\tExpiresAt *time.Time `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// AddDeployKey creates a new deploy key for a project. If deploy key already\n// exists in another project - it will be joined to project but only if\n// original one was is accessible by same user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#add-deploy-key-for-a-project\nfunc (s *DeployKeysService) AddDeployKey(pid interface{}, opt *AddDeployKeyOptions, options ...RequestOptionFunc) (*ProjectDeployKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_keys\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(ProjectDeployKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// DeleteDeployKey deletes a deploy key from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#delete-deploy-key\nfunc (s *DeployKeysService) DeleteDeployKey(pid interface{}, deployKey int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_keys/%d\", PathEscape(project), deployKey)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// EnableDeployKey enables a deploy key.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#enable-a-deploy-key\nfunc (s *DeployKeysService) EnableDeployKey(pid interface{}, deployKey int, options ...RequestOptionFunc) (*ProjectDeployKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_keys/%d/enable\", PathEscape(project), deployKey)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(ProjectDeployKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// UpdateDeployKeyOptions represents the available UpdateDeployKey() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#update-deploy-key\ntype UpdateDeployKeyOptions struct {\n\tTitle   *string `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tCanPush *bool   `url:\"can_push,omitempty\" json:\"can_push,omitempty\"`\n}\n\n// UpdateDeployKey updates a deploy key for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_keys.html#update-deploy-key\nfunc (s *DeployKeysService) UpdateDeployKey(pid interface{}, deployKey int, opt *UpdateDeployKeyOptions, options ...RequestOptionFunc) (*ProjectDeployKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_keys/%d\", PathEscape(project), deployKey)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(ProjectDeployKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n"
        },
        {
          "name": "deploy_keys_test.go",
          "type": "blob",
          "size": 10.7578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListAllDeployKeys(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/deploy_keys\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"title\": \"Public key\",\n\t\t\t\"key\": \"ssh-rsa AAAA...\",\n\t\t\t\"fingerprint\": \"7f:72:08:7d:0e:47:48:ec:37:79:b2:76:68:b5:87:65\",\n\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t\"projects_with_write_access\": [\n\t\t\t{\n\t\t\t\t\"id\": 73,\n\t\t\t\t\"description\": null,\n\t\t\t\t\"name\": \"project2\",\n\t\t\t\t\"name_with_namespace\": \"Sidney Jones / project2\",\n\t\t\t\t\"path\": \"project2\",\n\t\t\t\t\"path_with_namespace\": \"sidney_jones/project2\",\n\t\t\t\t\"created_at\": \"2021-10-25T18:33:17.550Z\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": 74,\n\t\t\t\t\"description\": null,\n\t\t\t\t\"name\": \"project3\",\n\t\t\t\t\"name_with_namespace\": \"Sidney Jones / project3\",\n\t\t\t\t\"path\": \"project3\",\n\t\t\t\t\"path_with_namespace\": \"sidney_jones/project3\",\n\t\t\t\t\"created_at\": \"2021-10-25T18:33:17.666Z\"\n\t\t\t}\n\t\t\t]\n\t\t},\n\t\t\t{\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"title\": \"Another Public key\",\n\t\t\t\t\"key\": \"ssh-rsa AAAA...\",\n\t\t\t\t\"fingerprint\": \"64:d3:73:d4:83:70:ab:41:96:68:d5:3d:a5:b0:34:ea\",\n\t\t\t\t\"created_at\": \"2013-10-02T11:12:29Z\",\n\t\t\t\t\"projects_with_write_access\": []\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\tdeployKeys, _, err := client.DeployKeys.ListAllDeployKeys(&ListInstanceDeployKeysOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned error: %v\", err)\n\t}\n\n\tcreatedAtKey1, _ := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\tcreatedAtKey1Enable1, _ := time.Parse(timeLayout, \"2021-10-25T18:33:17.550Z\")\n\tcreatedAtKey1Enable2, _ := time.Parse(timeLayout, \"2021-10-25T18:33:17.666Z\")\n\tcreatedAtKey2, _ := time.Parse(timeLayout, \"2013-10-02T11:12:29Z\")\n\n\twant := []*InstanceDeployKey{\n\t\t{\n\t\t\tID:          1,\n\t\t\tTitle:       \"Public key\",\n\t\t\tKey:         \"ssh-rsa AAAA...\",\n\t\t\tCreatedAt:   &createdAtKey1,\n\t\t\tFingerprint: \"7f:72:08:7d:0e:47:48:ec:37:79:b2:76:68:b5:87:65\",\n\t\t\tProjectsWithWriteAccess: []*DeployKeyProject{\n\t\t\t\t{\n\t\t\t\t\tID:                73,\n\t\t\t\t\tDescription:       \"\",\n\t\t\t\t\tName:              \"project2\",\n\t\t\t\t\tNameWithNamespace: \"Sidney Jones / project2\",\n\t\t\t\t\tPath:              \"project2\",\n\t\t\t\t\tPathWithNamespace: \"sidney_jones/project2\",\n\t\t\t\t\tCreatedAt:         &createdAtKey1Enable1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                74,\n\t\t\t\t\tDescription:       \"\",\n\t\t\t\t\tName:              \"project3\",\n\t\t\t\t\tNameWithNamespace: \"Sidney Jones / project3\",\n\t\t\t\t\tPath:              \"project3\",\n\t\t\t\t\tPathWithNamespace: \"sidney_jones/project3\",\n\t\t\t\t\tCreatedAt:         &createdAtKey1Enable2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:                      3,\n\t\t\tTitle:                   \"Another Public key\",\n\t\t\tKey:                     \"ssh-rsa AAAA...\",\n\t\t\tFingerprint:             \"64:d3:73:d4:83:70:ab:41:96:68:d5:3d:a5:b0:34:ea\",\n\t\t\tCreatedAt:               &createdAtKey2,\n\t\t\tProjectsWithWriteAccess: []*DeployKeyProject{},\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, deployKeys) {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned %+v, want %+v\", deployKeys, want)\n\t}\n}\n\nfunc TestListProjectDeployKeys(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"Public key\",\n\t\t\t  \"key\": \"ssh-rsa AAAA...\",\n\t\t\t  \"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t  \"can_push\": false\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 3,\n\t\t\t  \"title\": \"Another Public key\",\n\t\t\t  \"key\": \"ssh-rsa AAAA...\",\n\t\t\t  \"created_at\": \"2013-10-02T11:12:29Z\",\n\t\t\t  \"can_push\": false\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\tdeployKeys, _, err := client.DeployKeys.ListProjectDeployKeys(5, &ListProjectDeployKeysOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListProjectDeployKeys returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\tcreatedAt2, err := time.Parse(timeLayout, \"2013-10-02T11:12:29Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := []*ProjectDeployKey{\n\t\t{\n\t\t\tID:        1,\n\t\t\tTitle:     \"Public key\",\n\t\t\tKey:       \"ssh-rsa AAAA...\",\n\t\t\tCreatedAt: &createdAt,\n\t\t\tCanPush:   false,\n\t\t},\n\t\t{\n\t\t\tID:        3,\n\t\t\tTitle:     \"Another Public key\",\n\t\t\tKey:       \"ssh-rsa AAAA...\",\n\t\t\tCreatedAt: &createdAt2,\n\t\t\tCanPush:   false,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, deployKeys) {\n\t\tt.Errorf(\"DeployKeys.ListProjectDeployKeys returned %+v, want %+v\", deployKeys, want)\n\t}\n}\n\nfunc TestGetDeployKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys/11\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"title\": \"Public key\",\n\t\t\t\"key\": \"ssh-rsa AAAA...\",\n\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t\"can_push\": false\n\t\t  }`)\n\t})\n\n\tdeployKey, _, err := client.DeployKeys.GetDeployKey(5, 11)\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.GetDeployKey returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &ProjectDeployKey{\n\t\tID:        1,\n\t\tTitle:     \"Public key\",\n\t\tKey:       \"ssh-rsa AAAA...\",\n\t\tCreatedAt: &createdAt,\n\t\tCanPush:   false,\n\t}\n\tif !reflect.DeepEqual(want, deployKey) {\n\t\tt.Errorf(\"DeployKeys.GetDeployKey returned %+v, want %+v\", deployKey, want)\n\t}\n}\n\nfunc TestAddDeployKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"key\" : \"ssh-rsa AAAA...\",\n\t\t\t\"id\" : 12,\n\t\t\t\"title\" : \"My deploy key\",\n\t\t\t\"can_push\": true,\n\t\t\t\"created_at\" : \"2015-08-29T12:44:31.550Z\",\n\t\t\t\"expires_at\": null\n\t\t }`)\n\t})\n\n\topt := &AddDeployKeyOptions{\n\t\tKey:     Ptr(\"ssh-rsa AAAA...\"),\n\t\tTitle:   Ptr(\"My deploy key\"),\n\t\tCanPush: Ptr(true),\n\t}\n\tdeployKey, _, err := client.DeployKeys.AddDeployKey(5, opt)\n\tif err != nil {\n\t\tt.Errorf(\"DeployKey.AddDeployKey returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2015-08-29T12:44:31.550Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &ProjectDeployKey{\n\t\tTitle:     \"My deploy key\",\n\t\tID:        12,\n\t\tKey:       \"ssh-rsa AAAA...\",\n\t\tCreatedAt: &createdAt,\n\t\tCanPush:   true,\n\t}\n\tif !reflect.DeepEqual(want, deployKey) {\n\t\tt.Errorf(\"DeployKeys.AddDeployKey returned %+v, want %+v\", deployKey, want)\n\t}\n}\n\nfunc TestAddDeployKey_withExpiresAt(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"key\" : \"ssh-rsa AAAA...\",\n\t\t\t\"id\" : 12,\n\t\t\t\"title\" : \"My deploy key\",\n\t\t\t\"can_push\": true,\n\t\t\t\"created_at\" : \"2015-08-29T12:44:31.550Z\",\n\t\t\t\"expires_at\": \"2999-03-01T00:00:00.000Z\"\n\t\t }`)\n\t})\n\n\texpiresAt, err := time.Parse(timeLayout, \"2999-03-01T00:00:00.000Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.AddDeployKey returned an error while parsing time: %v\", err)\n\t}\n\n\topt := &AddDeployKeyOptions{\n\t\tKey:       Ptr(\"ssh-rsa AAAA...\"),\n\t\tTitle:     Ptr(\"My deploy key\"),\n\t\tCanPush:   Ptr(true),\n\t\tExpiresAt: &expiresAt,\n\t}\n\tdeployKey, _, err := client.DeployKeys.AddDeployKey(5, opt)\n\tif err != nil {\n\t\tt.Errorf(\"DeployKey.AddDeployKey returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2015-08-29T12:44:31.550Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.AddDeployKey returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &ProjectDeployKey{\n\t\tTitle:     \"My deploy key\",\n\t\tID:        12,\n\t\tKey:       \"ssh-rsa AAAA...\",\n\t\tCreatedAt: &createdAt,\n\t\tCanPush:   true,\n\t\tExpiresAt: &expiresAt,\n\t}\n\tif !reflect.DeepEqual(want, deployKey) {\n\t\tt.Errorf(\"DeployKeys.AddDeployKey returned %+v, want %+v\", deployKey, want)\n\t}\n}\n\nfunc TestDeleteDeployKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys/13\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.DeployKeys.DeleteDeployKey(5, 13)\n\tif err != nil {\n\t\tt.Errorf(\"Deploykeys.DeleteDeployKey returned error: %v\", err)\n\t}\n}\n\nfunc TestEnableDeployKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys/13/enable\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"key\" : \"ssh-rsa AAAA...\",\n\t\t\t\"id\" : 12,\n\t\t\t\"title\" : \"My deploy key\",\n\t\t\t\"created_at\" : \"2015-08-29T12:44:31.550Z\"\n\t\t }`)\n\t})\n\n\tdeployKey, _, err := client.DeployKeys.EnableDeployKey(5, 13)\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.EnableDeployKey returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2015-08-29T12:44:31.550Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &ProjectDeployKey{\n\t\tID:        12,\n\t\tTitle:     \"My deploy key\",\n\t\tKey:       \"ssh-rsa AAAA...\",\n\t\tCreatedAt: &createdAt,\n\t}\n\tif !reflect.DeepEqual(want, deployKey) {\n\t\tt.Errorf(\"DeployKeys.EnableDeployKey returned %+v, want %+v\", deployKey, want)\n\t}\n}\n\nfunc TestUpdateDeployKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_keys/11\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"id\": 11,\n\t\t\t\"title\": \"New deploy key\",\n\t\t\t\"key\": \"ssh-rsa AAAA...\",\n\t\t\t\"created_at\": \"2015-08-29T12:44:31.550Z\",\n\t\t\t\"can_push\": true\n\t\t }`)\n\t})\n\n\topt := &UpdateDeployKeyOptions{\n\t\tTitle:   Ptr(\"New deploy key\"),\n\t\tCanPush: Ptr(true),\n\t}\n\tdeployKey, _, err := client.DeployKeys.UpdateDeployKey(5, 11, opt)\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.UpdateDeployKey returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2015-08-29T12:44:31.550Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &ProjectDeployKey{\n\t\tID:        11,\n\t\tTitle:     \"New deploy key\",\n\t\tKey:       \"ssh-rsa AAAA...\",\n\t\tCreatedAt: &createdAt,\n\t\tCanPush:   true,\n\t}\n\tif !reflect.DeepEqual(want, deployKey) {\n\t\tt.Errorf(\"DeployKeys.UpdateDeployKey returned %+v, want %+v\", deployKey, want)\n\t}\n}\n"
        },
        {
          "name": "deploy_tokens.go",
          "type": "blob",
          "size": 8.7109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// DeployTokensService handles communication with the deploy tokens related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/deploy_tokens.html\ntype DeployTokensService struct {\n\tclient *Client\n}\n\n// DeployToken represents a GitLab deploy token.\ntype DeployToken struct {\n\tID        int        `json:\"id\"`\n\tName      string     `json:\"name\"`\n\tUsername  string     `json:\"username\"`\n\tExpiresAt *time.Time `json:\"expires_at\"`\n\tRevoked   bool       `json:\"revoked\"`\n\tExpired   bool       `json:\"expired\"`\n\tToken     string     `json:\"token,omitempty\"`\n\tScopes    []string   `json:\"scopes\"`\n}\n\nfunc (k DeployToken) String() string {\n\treturn Stringify(k)\n}\n\n// ListAllDeployTokens gets a list of all deploy tokens.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#list-all-deploy-tokens\nfunc (s *DeployTokensService) ListAllDeployTokens(options ...RequestOptionFunc) ([]*DeployToken, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"deploy_tokens\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ts []*DeployToken\n\tresp, err := s.client.Do(req, &ts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ts, resp, nil\n}\n\n// ListProjectDeployTokensOptions represents the available ListProjectDeployTokens()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#list-project-deploy-tokens\ntype ListProjectDeployTokensOptions ListOptions\n\n// ListProjectDeployTokens gets a list of a project's deploy tokens.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#list-project-deploy-tokens\nfunc (s *DeployTokensService) ListProjectDeployTokens(pid interface{}, opt *ListProjectDeployTokensOptions, options ...RequestOptionFunc) ([]*DeployToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_tokens\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ts []*DeployToken\n\tresp, err := s.client.Do(req, &ts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ts, resp, nil\n}\n\n// GetProjectDeployToken gets a single deploy token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#get-a-project-deploy-token\nfunc (s *DeployTokensService) GetProjectDeployToken(pid interface{}, deployToken int, options ...RequestOptionFunc) (*DeployToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_tokens/%d\", PathEscape(project), deployToken)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(DeployToken)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// CreateProjectDeployTokenOptions represents the available CreateProjectDeployToken() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#create-a-project-deploy-token\ntype CreateProjectDeployTokenOptions struct {\n\tName      *string    `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tExpiresAt *time.Time `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n\tUsername  *string    `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tScopes    *[]string  `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n}\n\n// CreateProjectDeployToken creates a new deploy token for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#create-a-project-deploy-token\nfunc (s *DeployTokensService) CreateProjectDeployToken(pid interface{}, opt *CreateProjectDeployTokenOptions, options ...RequestOptionFunc) (*DeployToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_tokens\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(DeployToken)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// DeleteProjectDeployToken removes a deploy token from the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#delete-a-project-deploy-token\nfunc (s *DeployTokensService) DeleteProjectDeployToken(pid interface{}, deployToken int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deploy_tokens/%d\", PathEscape(project), deployToken)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListGroupDeployTokensOptions represents the available ListGroupDeployTokens()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#list-group-deploy-tokens\ntype ListGroupDeployTokensOptions ListOptions\n\n// ListGroupDeployTokens gets a list of a group’s deploy tokens.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#list-group-deploy-tokens\nfunc (s *DeployTokensService) ListGroupDeployTokens(gid interface{}, opt *ListGroupDeployTokensOptions, options ...RequestOptionFunc) ([]*DeployToken, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/deploy_tokens\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ts []*DeployToken\n\tresp, err := s.client.Do(req, &ts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ts, resp, nil\n}\n\n// GetGroupDeployToken gets a single deploy token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#get-a-group-deploy-token\nfunc (s *DeployTokensService) GetGroupDeployToken(gid interface{}, deployToken int, options ...RequestOptionFunc) (*DeployToken, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/deploy_tokens/%d\", PathEscape(group), deployToken)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(DeployToken)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// CreateGroupDeployTokenOptions represents the available CreateGroupDeployToken() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#create-a-group-deploy-token\ntype CreateGroupDeployTokenOptions struct {\n\tName      *string    `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tExpiresAt *time.Time `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n\tUsername  *string    `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tScopes    *[]string  `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n}\n\n// CreateGroupDeployToken creates a new deploy token for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#create-a-group-deploy-token\nfunc (s *DeployTokensService) CreateGroupDeployToken(gid interface{}, opt *CreateGroupDeployTokenOptions, options ...RequestOptionFunc) (*DeployToken, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/deploy_tokens\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(DeployToken)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// DeleteGroupDeployToken removes a deploy token from the group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deploy_tokens.html#delete-a-group-deploy-token\nfunc (s *DeployTokensService) DeleteGroupDeployToken(gid interface{}, deployToken int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/deploy_tokens/%d\", PathEscape(group), deployToken)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "deploy_tokens_test.go",
          "type": "blob",
          "size": 9.1279296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListAllDeployTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/deploy_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n[\n\t{\n\t\t\"id\": 1,\n\t\t\"name\": \"MyToken\",\n\t\t\"username\": \"gitlab+deploy-token-1\",\n\t\t\"expires_at\": \"2020-02-14T00:00:00.000Z\",\n\t\t\"revoked\": true,\n\t\t\"expired\": true,\n\t\t\"scopes\": [\n\t\t\t\"read_repository\",\n\t\t\t\"read_registry\"\n\t\t]\n\t}\n]\n`)\n\t})\n\n\tdeployTokens, _, err := client.DeployTokens.ListAllDeployTokens()\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.ListAllDeployTokens returned an error: %v\", err)\n\t}\n\n\twantExpiresAt := time.Date(2020, 0o2, 14, 0, 0, 0, 0, time.UTC)\n\n\twant := []*DeployToken{\n\t\t{\n\t\t\tID:        1,\n\t\t\tName:      \"MyToken\",\n\t\t\tUsername:  \"gitlab+deploy-token-1\",\n\t\t\tExpiresAt: &wantExpiresAt,\n\t\t\tRevoked:   true,\n\t\t\tExpired:   true,\n\t\t\tScopes: []string{\n\t\t\t\t\"read_repository\",\n\t\t\t\t\"read_registry\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployTokens) {\n\t\tt.Errorf(\"DeployTokens.ListAllDeployTokens returned %+v, want %+v\", deployTokens, want)\n\t}\n}\n\nfunc TestListProjectDeployTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/deploy_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n[\n  {\n    \"id\": 1,\n    \"name\": \"MyToken\",\n    \"username\": \"gitlab+deploy-token-1\",\n    \"expires_at\": \"2020-02-14T00:00:00.000Z\",\n    \"scopes\": [\n      \"read_repository\",\n      \"read_registry\"\n    ]\n  }\n]\n`)\n\t})\n\n\tdeployTokens, _, err := client.DeployTokens.ListProjectDeployTokens(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.ListProjectDeployTokens returned an error: %v\", err)\n\t}\n\n\twantExpiresAt := time.Date(2020, 0o2, 14, 0, 0, 0, 0, time.UTC)\n\n\twant := []*DeployToken{\n\t\t{\n\t\t\tID:        1,\n\t\t\tName:      \"MyToken\",\n\t\t\tUsername:  \"gitlab+deploy-token-1\",\n\t\t\tExpiresAt: &wantExpiresAt,\n\t\t\tScopes: []string{\n\t\t\t\t\"read_repository\",\n\t\t\t\t\"read_registry\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployTokens) {\n\t\tt.Errorf(\"DeployTokens.ListProjectDeployTokens returned %+v, want %+v\", deployTokens, want)\n\t}\n}\n\nfunc TestGetProjectDeployTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/deploy_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n{\n  \"id\": 1,\n  \"name\": \"MyToken\",\n  \"username\": \"gitlab+deploy-token-1\",\n  \"expires_at\": \"2020-02-14T00:00:00.000Z\",\n  \"scopes\": [\n    \"read_repository\",\n    \"read_registry\"\n  ]\n}\n`)\n\t})\n\n\tdeployToken, _, err := client.DeployTokens.GetProjectDeployToken(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.GetProjectDeployToken returned an error: %v\", err)\n\t}\n\n\twantExpiresAt := time.Date(2020, 0o2, 14, 0, 0, 0, 0, time.UTC)\n\n\twant := &DeployToken{\n\t\tID:        1,\n\t\tName:      \"MyToken\",\n\t\tUsername:  \"gitlab+deploy-token-1\",\n\t\tExpiresAt: &wantExpiresAt,\n\t\tScopes: []string{\n\t\t\t\"read_repository\",\n\t\t\t\"read_registry\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployToken) {\n\t\tt.Errorf(\"DeployTokens.GetProjectDeployToken returned %+v, want %+v\", deployToken, want)\n\t}\n}\n\nfunc TestCreateProjectDeployToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n{\n\t\"id\": 1,\n\t\"name\": \"My deploy token\",\n\t\"username\": \"custom-user\",\n\t\"expires_at\": \"2021-01-01T00:00:00.000Z\",\n\t\"token\": \"jMRvtPNxrn3crTAGukpZ\",\n\t\"scopes\": [\n\t\t\"read_repository\"\n\t]\n}\n`)\n\t})\n\n\texpiresAt := time.Date(2021, 0o1, 0o1, 0, 0, 0, 0, time.UTC)\n\n\tdeployToken, _, err := client.DeployTokens.CreateProjectDeployToken(5, &CreateProjectDeployTokenOptions{\n\t\tName:      Ptr(\"My deploy token\"),\n\t\tUsername:  Ptr(\"custom-user\"),\n\t\tExpiresAt: &expiresAt,\n\t\tScopes: &[]string{\n\t\t\t\"read_repository\",\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.CreateProjectDeployToken returned an error: %v\", err)\n\t}\n\n\twant := &DeployToken{\n\t\tID:        1,\n\t\tName:      \"My deploy token\",\n\t\tUsername:  \"custom-user\",\n\t\tExpiresAt: &expiresAt,\n\t\tToken:     \"jMRvtPNxrn3crTAGukpZ\",\n\t\tScopes: []string{\n\t\t\t\"read_repository\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployToken) {\n\t\tt.Errorf(\"DeployTokens.CreateProjectDeployToken returned %+v, want %+v\", deployToken, want)\n\t}\n}\n\nfunc TestDeleteProjectDeployToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/deploy_tokens/13\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.DeployTokens.DeleteProjectDeployToken(5, 13)\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.DeleteProjectDeployToken returned an error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\n\tif want != got {\n\t\tt.Errorf(\"DeployTokens.DeleteProjectDeployToken returned %+v, want %+v\", got, want)\n\t}\n}\n\nfunc TestListGroupDeployTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/deploy_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n[\n  {\n    \"id\": 1,\n    \"name\": \"MyToken\",\n    \"username\": \"gitlab+deploy-token-1\",\n    \"expires_at\": \"2020-02-14T00:00:00.000Z\",\n    \"scopes\": [\n      \"read_repository\",\n      \"read_registry\"\n    ]\n  }\n]\n`)\n\t})\n\n\tdeployTokens, _, err := client.DeployTokens.ListGroupDeployTokens(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.ListGroupDeployTokens returned an error: %v\", err)\n\t}\n\n\twantExpiresAt := time.Date(2020, 0o2, 14, 0, 0, 0, 0, time.UTC)\n\n\twant := []*DeployToken{\n\t\t{\n\t\t\tID:        1,\n\t\t\tName:      \"MyToken\",\n\t\t\tUsername:  \"gitlab+deploy-token-1\",\n\t\t\tExpiresAt: &wantExpiresAt,\n\t\t\tScopes: []string{\n\t\t\t\t\"read_repository\",\n\t\t\t\t\"read_registry\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployTokens) {\n\t\tt.Errorf(\"DeployTokens.ListGroupDeployTokens returned %+v, want %+v\", deployTokens, want)\n\t}\n}\n\nfunc TestGetGroupDeployTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/deploy_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n{\n  \"id\": 1,\n  \"name\": \"MyToken\",\n  \"username\": \"gitlab+deploy-token-1\",\n  \"expires_at\": \"2020-02-14T00:00:00.000Z\",\n  \"scopes\": [\n    \"read_repository\",\n    \"read_registry\"\n  ]\n}\n`)\n\t})\n\n\tdeployToken, _, err := client.DeployTokens.GetGroupDeployToken(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.GetGroupDeployToken returned an error: %v\", err)\n\t}\n\n\twantExpiresAt := time.Date(2020, 0o2, 14, 0, 0, 0, 0, time.UTC)\n\n\twant := &DeployToken{\n\t\tID:        1,\n\t\tName:      \"MyToken\",\n\t\tUsername:  \"gitlab+deploy-token-1\",\n\t\tExpiresAt: &wantExpiresAt,\n\t\tScopes: []string{\n\t\t\t\"read_repository\",\n\t\t\t\"read_registry\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployToken) {\n\t\tt.Errorf(\"DeployTokens.GetGroupDeployToken returned %+v, want %+v\", deployToken, want)\n\t}\n}\n\nfunc TestCreateGroupDeployToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/deploy_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n{\n\t\"id\": 1,\n\t\"name\": \"My deploy token\",\n\t\"username\": \"custom-user\",\n\t\"expires_at\": \"2021-01-01T00:00:00.000Z\",\n\t\"token\": \"jMRvtPNxrn3crTAGukpZ\",\n\t\"scopes\": [\n\t\t\"read_repository\"\n\t]\n}\n`)\n\t})\n\n\texpiresAt := time.Date(2021, 0o1, 0o1, 0, 0, 0, 0, time.UTC)\n\n\tdeployToken, _, err := client.DeployTokens.CreateGroupDeployToken(5, &CreateGroupDeployTokenOptions{\n\t\tName:      Ptr(\"My deploy token\"),\n\t\tUsername:  Ptr(\"custom-user\"),\n\t\tExpiresAt: &expiresAt,\n\t\tScopes: &[]string{\n\t\t\t\"read_repository\",\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.CreateGroupDeployToken returned an error: %v\", err)\n\t}\n\n\twant := &DeployToken{\n\t\tID:        1,\n\t\tName:      \"My deploy token\",\n\t\tUsername:  \"custom-user\",\n\t\tExpiresAt: &expiresAt,\n\t\tToken:     \"jMRvtPNxrn3crTAGukpZ\",\n\t\tScopes: []string{\n\t\t\t\"read_repository\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, deployToken) {\n\t\tt.Errorf(\"DeployTokens.CreateGroupDeployToken returned %+v, want %+v\", deployToken, want)\n\t}\n}\n\nfunc TestDeleteGroupDeployToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/deploy_tokens/13\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.DeployTokens.DeleteGroupDeployToken(5, 13)\n\tif err != nil {\n\t\tt.Errorf(\"DeployTokens.DeleteGroupDeployToken returned an error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\n\tif want != got {\n\t\tt.Errorf(\"DeployTokens.DeleteGroupDeployToken returned %+v, want %+v\", got, want)\n\t}\n}\n"
        },
        {
          "name": "deployments.go",
          "type": "blob",
          "size": 8.64453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// DeploymentsService handles communication with the deployment related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/deployments.html\ntype DeploymentsService struct {\n\tclient *Client\n}\n\n// Deployment represents the Gitlab deployment\ntype Deployment struct {\n\tID          int          `json:\"id\"`\n\tIID         int          `json:\"iid\"`\n\tRef         string       `json:\"ref\"`\n\tSHA         string       `json:\"sha\"`\n\tStatus      string       `json:\"status\"`\n\tCreatedAt   *time.Time   `json:\"created_at\"`\n\tUpdatedAt   *time.Time   `json:\"updated_at\"`\n\tUser        *ProjectUser `json:\"user\"`\n\tEnvironment *Environment `json:\"environment\"`\n\tDeployable  struct {\n\t\tID         int        `json:\"id\"`\n\t\tStatus     string     `json:\"status\"`\n\t\tStage      string     `json:\"stage\"`\n\t\tName       string     `json:\"name\"`\n\t\tRef        string     `json:\"ref\"`\n\t\tTag        bool       `json:\"tag\"`\n\t\tCoverage   float64    `json:\"coverage\"`\n\t\tCreatedAt  *time.Time `json:\"created_at\"`\n\t\tStartedAt  *time.Time `json:\"started_at\"`\n\t\tFinishedAt *time.Time `json:\"finished_at\"`\n\t\tDuration   float64    `json:\"duration\"`\n\t\tUser       *User      `json:\"user\"`\n\t\tCommit     *Commit    `json:\"commit\"`\n\t\tPipeline   struct {\n\t\t\tID        int        `json:\"id\"`\n\t\t\tSHA       string     `json:\"sha\"`\n\t\t\tRef       string     `json:\"ref\"`\n\t\t\tStatus    string     `json:\"status\"`\n\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t} `json:\"pipeline\"`\n\t\tRunner *Runner `json:\"runner\"`\n\t} `json:\"deployable\"`\n}\n\n// ListProjectDeploymentsOptions represents the available ListProjectDeployments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#list-project-deployments\ntype ListProjectDeploymentsOptions struct {\n\tListOptions\n\tOrderBy     *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort        *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tEnvironment *string `url:\"environment,omitempty\" json:\"environment,omitempty\"`\n\tStatus      *string `url:\"status,omitempty\" json:\"status,omitempty\"`\n\n\t// Only for Gitlab versions less than 14\n\tUpdatedAfter  *time.Time `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore *time.Time `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\n\t// Only for Gitlab 14 or higher\n\tFinishedAfter  *time.Time `url:\"finished_after,omitempty\" json:\"finished_after,omitempty\"`\n\tFinishedBefore *time.Time `url:\"finished_before,omitempty\" json:\"finished_before,omitempty\"`\n}\n\n// ListProjectDeployments gets a list of deployments in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#list-project-deployments\nfunc (s *DeploymentsService) ListProjectDeployments(pid interface{}, opts *ListProjectDeploymentsOptions, options ...RequestOptionFunc) ([]*Deployment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ds []*Deployment\n\tresp, err := s.client.Do(req, &ds)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ds, resp, nil\n}\n\n// GetProjectDeployment get a deployment for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#get-a-specific-deployment\nfunc (s *DeploymentsService) GetProjectDeployment(pid interface{}, deployment int, options ...RequestOptionFunc) (*Deployment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments/%d\", PathEscape(project), deployment)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Deployment)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CreateProjectDeploymentOptions represents the available\n// CreateProjectDeployment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#create-a-deployment\ntype CreateProjectDeploymentOptions struct {\n\tEnvironment *string                `url:\"environment,omitempty\" json:\"environment,omitempty\"`\n\tRef         *string                `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tSHA         *string                `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n\tTag         *bool                  `url:\"tag,omitempty\" json:\"tag,omitempty\"`\n\tStatus      *DeploymentStatusValue `url:\"status,omitempty\" json:\"status,omitempty\"`\n}\n\n// CreateProjectDeployment creates a project deployment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#create-a-deployment\nfunc (s *DeploymentsService) CreateProjectDeployment(pid interface{}, opt *CreateProjectDeploymentOptions, options ...RequestOptionFunc) (*Deployment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Deployment)\n\tresp, err := s.client.Do(req, &d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// UpdateProjectDeploymentOptions represents the available\n// UpdateProjectDeployment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#update-a-deployment\ntype UpdateProjectDeploymentOptions struct {\n\tStatus *DeploymentStatusValue `url:\"status,omitempty\" json:\"status,omitempty\"`\n}\n\n// UpdateProjectDeployment updates a project deployment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#update-a-deployment\nfunc (s *DeploymentsService) UpdateProjectDeployment(pid interface{}, deployment int, opt *UpdateProjectDeploymentOptions, options ...RequestOptionFunc) (*Deployment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments/%d\", PathEscape(project), deployment)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Deployment)\n\tresp, err := s.client.Do(req, &d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// ApproveOrRejectProjectDeploymentOptions represents the available\n// ApproveOrRejectProjectDeployment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#approve-or-reject-a-blocked-deployment\ntype ApproveOrRejectProjectDeploymentOptions struct {\n\tStatus        *DeploymentApprovalStatus `url:\"status,omitempty\" json:\"status,omitempty\"`\n\tComment       *string                   `url:\"comment,omitempty\" json:\"comment,omitempty\"`\n\tRepresentedAs *string                   `url:\"represented_as,omitempty\" json:\"represented_as,omitempty\"`\n}\n\n// ApproveOrRejectProjectDeployment approve or reject a blocked deployment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#approve-or-reject-a-blocked-deployment\nfunc (s *DeploymentsService) ApproveOrRejectProjectDeployment(pid interface{}, deployment int,\n\topt *ApproveOrRejectProjectDeploymentOptions, options ...RequestOptionFunc,\n) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments/%d/approval\", PathEscape(project), deployment)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteProjectDeployment delete a project deployment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#delete-a-specific-deployment\nfunc (s *DeploymentsService) DeleteProjectDeployment(pid interface{}, deployment int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments/%d\", PathEscape(project), deployment)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "deployments_merge_requests.go",
          "type": "blob",
          "size": 1.7431640625,
          "content": "// Copyright 2022, Daniela Filipe Bento\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// DeploymentMergeRequestsService handles communication with the deployment's\n// merge requests related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#list-of-merge-requests-associated-with-a-deployment\ntype DeploymentMergeRequestsService struct {\n\tclient *Client\n}\n\n// ListDeploymentMergeRequests get the merge requests associated with deployment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/deployments.html#list-of-merge-requests-associated-with-a-deployment\nfunc (s *DeploymentMergeRequestsService) ListDeploymentMergeRequests(pid interface{}, deployment int, opts *ListMergeRequestsOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/deployments/%d/merge_requests\", PathEscape(project), deployment)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mrs []*MergeRequest\n\tresp, err := s.client.Do(req, &mrs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mrs, resp, nil\n}\n"
        },
        {
          "name": "deployments_merge_requests_test.go",
          "type": "blob",
          "size": 1.9775390625,
          "content": "package gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDeploymentMergeRequestsService_ListDeploymentMergeRequests(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/278964/deployments/2/merge_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"assignee_id=Any&with_labels_details=true&with_merge_status_recheck=true\")\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_merge_requests.json\")\n\t})\n\n\topts := ListMergeRequestsOptions{\n\t\tAssigneeID:             AssigneeID(UserIDAny),\n\t\tWithLabelsDetails:      Ptr(true),\n\t\tWithMergeStatusRecheck: Ptr(true),\n\t}\n\n\tmergeRequests, _, err := client.DeploymentMergeRequests.ListDeploymentMergeRequests(278964, 2, &opts)\n\trequire.NoError(t, err)\n\trequire.Equal(t, 3, len(mergeRequests))\n\n\tvalidStates := []string{\"opened\", \"closed\", \"locked\", \"merged\"}\n\tdetailedMergeStatuses := []string{\n\t\t\"blocked_status\",\n\t\t\"broken_status\",\n\t\t\"checking\",\n\t\t\"ci_must_pass\",\n\t\t\"ci_still_running\",\n\t\t\"discussions_not_resolved\",\n\t\t\"draft_status\",\n\t\t\"external_status_checks\",\n\t\t\"mergeable\",\n\t\t\"not_approved\",\n\t\t\"not_open\",\n\t\t\"policies_denied\",\n\t\t\"unchecked\",\n\t}\n\tallCreatedBefore := time.Date(2019, 8, 21, 0, 0, 0, 0, time.UTC)\n\tallCreatedAfter := time.Date(2019, 8, 17, 0, 0, 0, 0, time.UTC)\n\n\tfor _, mr := range mergeRequests {\n\t\trequire.Equal(t, 278964, mr.ProjectID)\n\t\trequire.Contains(t, validStates, mr.State)\n\t\tassert.Less(t, mr.CreatedAt.Unix(), allCreatedBefore.Unix())\n\t\tassert.Greater(t, mr.CreatedAt.Unix(), allCreatedAfter.Unix())\n\t\tassert.LessOrEqual(t, mr.CreatedAt.Unix(), mr.UpdatedAt.Unix())\n\t\tassert.LessOrEqual(t, mr.TaskCompletionStatus.CompletedCount, mr.TaskCompletionStatus.Count)\n\t\trequire.Contains(t, detailedMergeStatuses, mr.DetailedMergeStatus)\n\n\t\t// list requests do not provide these fields:\n\t\tassert.Nil(t, mr.Pipeline)\n\t\tassert.Nil(t, mr.HeadPipeline)\n\t\tassert.Equal(t, \"\", mr.DiffRefs.HeadSha)\n\t}\n}\n"
        },
        {
          "name": "deployments_test.go",
          "type": "blob",
          "size": 22.8056640625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDeploymentsService_ListProjectDeployments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/deployments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"status\": \"created\",\n\t\t\t\t\"deployable\": {\n\t\t\t\t  \"commit\": {\n\t\t\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\t\t\"id\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\t\"message\": \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\t\t\"short_id\": \"99d03678\",\n\t\t\t\t\t\"title\": \"Merge branch 'new-title' into 'main'\\r\"\n\t\t\t\t  },\n\t\t\t\t  \"coverage\": null,\n\t\t\t\t  \"id\": 657,\n\t\t\t\t  \"name\": \"deploy\",\n\t\t\t\t  \"ref\": \"main\",\n\t\t\t\t  \"runner\": null,\n\t\t\t\t  \"stage\": \"deploy\",\n\t\t\t\t  \"status\": \"success\",\n\t\t\t\t  \"tag\": false,\n\t\t\t\t  \"user\": {\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\t\"username\": \"root\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://gitlab.dev/root\",\n\t\t\t\t\t\"bio\": null,\n\t\t\t\t\t\"location\": null,\n\t\t\t\t\t\"public_email\": \"\",\n\t\t\t\t\t\"skype\": \"\",\n\t\t\t\t\t\"linkedin\": \"\",\n\t\t\t\t\t\"twitter\": \"\",\n\t\t\t\t\t\"website_url\": \"\",\n\t\t\t\t\t\"organization\": \"\"\n\t\t\t\t  },\n\t\t\t\t  \"pipeline\": {\n\t\t\t\t\t\"id\": 36,\n\t\t\t\t\t\"ref\": \"main\",\n\t\t\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\t\"status\": \"success\",\n\t\t\t\t\t\"web_url\": \"http://gitlab.dev/root/project/pipelines/12\"\n\t\t\t\t  }\n\t\t\t\t},\n\t\t\t\t\"environment\": {\n\t\t\t\t  \"external_url\": \"https://about.gitlab.com\",\n\t\t\t\t  \"id\": 9,\n\t\t\t\t  \"name\": \"production\"\n\t\t\t\t},\n\t\t\t\t\"id\": 41,\n\t\t\t\t\"iid\": 1,\n\t\t\t\t\"ref\": \"main\",\n\t\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/root\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Deployment{{\n\t\tID:     41,\n\t\tIID:    1,\n\t\tRef:    \"main\",\n\t\tSHA:    \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\tStatus: \"created\",\n\t\tUser: &ProjectUser{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://localhost:3000/root\",\n\t\t},\n\t\tEnvironment: &Environment{\n\t\t\tID:             9,\n\t\t\tName:           \"production\",\n\t\t\tSlug:           \"\",\n\t\t\tState:          \"\",\n\t\t\tExternalURL:    \"https://about.gitlab.com\",\n\t\t\tProject:        nil,\n\t\t\tLastDeployment: nil,\n\t\t},\n\t\tDeployable: struct {\n\t\t\tID         int        `json:\"id\"`\n\t\t\tStatus     string     `json:\"status\"`\n\t\t\tStage      string     `json:\"stage\"`\n\t\t\tName       string     `json:\"name\"`\n\t\t\tRef        string     `json:\"ref\"`\n\t\t\tTag        bool       `json:\"tag\"`\n\t\t\tCoverage   float64    `json:\"coverage\"`\n\t\t\tCreatedAt  *time.Time `json:\"created_at\"`\n\t\t\tStartedAt  *time.Time `json:\"started_at\"`\n\t\t\tFinishedAt *time.Time `json:\"finished_at\"`\n\t\t\tDuration   float64    `json:\"duration\"`\n\t\t\tUser       *User      `json:\"user\"`\n\t\t\tCommit     *Commit    `json:\"commit\"`\n\t\t\tPipeline   struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t} `json:\"pipeline\"`\n\t\t\tRunner *Runner `json:\"runner\"`\n\t\t}{\n\t\t\tID:         657,\n\t\t\tStatus:     \"success\",\n\t\t\tStage:      \"deploy\",\n\t\t\tName:       \"deploy\",\n\t\t\tRef:        \"main\",\n\t\t\tTag:        false,\n\t\t\tCoverage:   0,\n\t\t\tCreatedAt:  nil,\n\t\t\tStartedAt:  nil,\n\t\t\tFinishedAt: nil,\n\t\t\tDuration:   0,\n\t\t\tUser: &User{\n\t\t\t\tID:        1,\n\t\t\t\tName:      \"Administrator\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://gitlab.dev/root\",\n\t\t\t},\n\t\t\tCommit: &Commit{\n\t\t\t\tID:             \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tShortID:        \"99d03678\",\n\t\t\t\tTitle:          \"Merge branch 'new-title' into 'main'\\r\",\n\t\t\t\tAuthorName:     \"Administrator\",\n\t\t\t\tAuthorEmail:    \"admin@example.com\",\n\t\t\t\tAuthoredDate:   nil,\n\t\t\t\tCommitterName:  \"\",\n\t\t\t\tCommitterEmail: \"\",\n\t\t\t\tCommittedDate:  nil,\n\t\t\t\tCreatedAt:      nil,\n\t\t\t\tMessage:        \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\tParentIDs:      nil,\n\t\t\t\tStats:          nil,\n\t\t\t\tStatus:         nil,\n\t\t\t\tLastPipeline:   nil,\n\t\t\t\tProjectID:      0,\n\t\t\t\tWebURL:         \"\",\n\t\t\t},\n\t\t\tPipeline: struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t}{\n\t\t\t\tID:        36,\n\t\t\t\tSHA:       \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tRef:       \"main\",\n\t\t\t\tStatus:    \"success\",\n\t\t\t\tCreatedAt: nil,\n\t\t\t\tUpdatedAt: nil,\n\t\t\t},\n\t\t\tRunner: nil,\n\t\t},\n\t}}\n\n\tds, resp, err := client.Deployments.ListProjectDeployments(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Deployments.ListProjectDeployments(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Deployments.ListProjectDeployments(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Deployments.ListProjectDeployments(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDeploymentsService_GetProjectDeployment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/deployments/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"status\": \"created\",\n\t\t\t\"deployable\": {\n\t\t\t  \"commit\": {\n\t\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\t\"id\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"message\": \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\t\"short_id\": \"99d03678\",\n\t\t\t\t\"title\": \"Merge branch 'new-title' into 'main'\\r\"\n\t\t\t  },\n\t\t\t  \"coverage\": null,\n\t\t\t  \"id\": 657,\n\t\t\t  \"name\": \"deploy\",\n\t\t\t  \"ref\": \"main\",\n\t\t\t  \"runner\": null,\n\t\t\t  \"stage\": \"deploy\",\n\t\t\t  \"status\": \"success\",\n\t\t\t  \"tag\": false,\n\t\t\t  \"user\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.dev/root\",\n\t\t\t\t\"bio\": null,\n\t\t\t\t\"location\": null,\n\t\t\t\t\"public_email\": \"\",\n\t\t\t\t\"skype\": \"\",\n\t\t\t\t\"linkedin\": \"\",\n\t\t\t\t\"twitter\": \"\",\n\t\t\t\t\"website_url\": \"\",\n\t\t\t\t\"organization\": \"\"\n\t\t\t  },\n\t\t\t  \"pipeline\": {\n\t\t\t\t\"id\": 36,\n\t\t\t\t\"ref\": \"main\",\n\t\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"status\": \"success\",\n\t\t\t\t\"web_url\": \"http://gitlab.dev/root/project/pipelines/12\"\n\t\t\t  }\n\t\t\t},\n\t\t\t\"environment\": {\n\t\t\t  \"external_url\": \"https://about.gitlab.com\",\n\t\t\t  \"id\": 9,\n\t\t\t  \"name\": \"production\"\n\t\t\t},\n\t\t\t\"id\": 41,\n\t\t\t\"iid\": 1,\n\t\t\t\"ref\": \"main\",\n\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\"user\": {\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"web_url\": \"http://localhost:3000/root\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Deployment{\n\t\tID:     41,\n\t\tIID:    1,\n\t\tRef:    \"main\",\n\t\tSHA:    \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\tStatus: \"created\",\n\t\tUser: &ProjectUser{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://localhost:3000/root\",\n\t\t},\n\t\tEnvironment: &Environment{\n\t\t\tID:             9,\n\t\t\tName:           \"production\",\n\t\t\tSlug:           \"\",\n\t\t\tState:          \"\",\n\t\t\tExternalURL:    \"https://about.gitlab.com\",\n\t\t\tProject:        nil,\n\t\t\tLastDeployment: nil,\n\t\t},\n\t\tDeployable: struct {\n\t\t\tID         int        `json:\"id\"`\n\t\t\tStatus     string     `json:\"status\"`\n\t\t\tStage      string     `json:\"stage\"`\n\t\t\tName       string     `json:\"name\"`\n\t\t\tRef        string     `json:\"ref\"`\n\t\t\tTag        bool       `json:\"tag\"`\n\t\t\tCoverage   float64    `json:\"coverage\"`\n\t\t\tCreatedAt  *time.Time `json:\"created_at\"`\n\t\t\tStartedAt  *time.Time `json:\"started_at\"`\n\t\t\tFinishedAt *time.Time `json:\"finished_at\"`\n\t\t\tDuration   float64    `json:\"duration\"`\n\t\t\tUser       *User      `json:\"user\"`\n\t\t\tCommit     *Commit    `json:\"commit\"`\n\t\t\tPipeline   struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t} `json:\"pipeline\"`\n\t\t\tRunner *Runner `json:\"runner\"`\n\t\t}{\n\t\t\tID:         657,\n\t\t\tStatus:     \"success\",\n\t\t\tStage:      \"deploy\",\n\t\t\tName:       \"deploy\",\n\t\t\tRef:        \"main\",\n\t\t\tTag:        false,\n\t\t\tCoverage:   0,\n\t\t\tCreatedAt:  nil,\n\t\t\tStartedAt:  nil,\n\t\t\tFinishedAt: nil,\n\t\t\tDuration:   0,\n\t\t\tUser: &User{\n\t\t\t\tID:        1,\n\t\t\t\tName:      \"Administrator\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://gitlab.dev/root\",\n\t\t\t},\n\t\t\tCommit: &Commit{\n\t\t\t\tID:             \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tShortID:        \"99d03678\",\n\t\t\t\tTitle:          \"Merge branch 'new-title' into 'main'\\r\",\n\t\t\t\tAuthorName:     \"Administrator\",\n\t\t\t\tAuthorEmail:    \"admin@example.com\",\n\t\t\t\tAuthoredDate:   nil,\n\t\t\t\tCommitterName:  \"\",\n\t\t\t\tCommitterEmail: \"\",\n\t\t\t\tCommittedDate:  nil,\n\t\t\t\tCreatedAt:      nil,\n\t\t\t\tMessage:        \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\tParentIDs:      nil,\n\t\t\t\tStats:          nil,\n\t\t\t\tStatus:         nil,\n\t\t\t\tLastPipeline:   nil,\n\t\t\t\tProjectID:      0,\n\t\t\t\tWebURL:         \"\",\n\t\t\t},\n\t\t\tPipeline: struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t}{\n\t\t\t\tID:        36,\n\t\t\t\tSHA:       \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tRef:       \"main\",\n\t\t\t\tStatus:    \"success\",\n\t\t\t\tCreatedAt: nil,\n\t\t\t\tUpdatedAt: nil,\n\t\t\t},\n\t\t\tRunner: nil,\n\t\t},\n\t}\n\n\td, resp, err := client.Deployments.GetProjectDeployment(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Deployments.GetProjectDeployment(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Deployments.GetProjectDeployment(1, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Deployments.GetProjectDeployment(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDeploymentsService_CreateProjectDeployment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/deployments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"status\": \"created\",\n\t\t\t\"deployable\": {\n\t\t\t  \"commit\": {\n\t\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\t\"id\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"message\": \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\t\"short_id\": \"99d03678\",\n\t\t\t\t\"title\": \"Merge branch 'new-title' into 'main'\\r\"\n\t\t\t  },\n\t\t\t  \"coverage\": null,\n\t\t\t  \"id\": 657,\n\t\t\t  \"name\": \"deploy\",\n\t\t\t  \"ref\": \"main\",\n\t\t\t  \"runner\": null,\n\t\t\t  \"stage\": \"deploy\",\n\t\t\t  \"status\": \"success\",\n\t\t\t  \"tag\": false,\n\t\t\t  \"user\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.dev/root\",\n\t\t\t\t\"bio\": null,\n\t\t\t\t\"location\": null,\n\t\t\t\t\"public_email\": \"\",\n\t\t\t\t\"skype\": \"\",\n\t\t\t\t\"linkedin\": \"\",\n\t\t\t\t\"twitter\": \"\",\n\t\t\t\t\"website_url\": \"\",\n\t\t\t\t\"organization\": \"\"\n\t\t\t  },\n\t\t\t  \"pipeline\": {\n\t\t\t\t\"id\": 36,\n\t\t\t\t\"ref\": \"main\",\n\t\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"status\": \"success\",\n\t\t\t\t\"web_url\": \"http://gitlab.dev/root/project/pipelines/12\"\n\t\t\t  }\n\t\t\t},\n\t\t\t\"environment\": {\n\t\t\t  \"external_url\": \"https://about.gitlab.com\",\n\t\t\t  \"id\": 9,\n\t\t\t  \"name\": \"production\"\n\t\t\t},\n\t\t\t\"id\": 41,\n\t\t\t\"iid\": 1,\n\t\t\t\"ref\": \"main\",\n\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\"user\": {\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"web_url\": \"http://localhost:3000/root\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Deployment{\n\t\tID:     41,\n\t\tIID:    1,\n\t\tRef:    \"main\",\n\t\tSHA:    \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\tStatus: \"created\",\n\t\tUser: &ProjectUser{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://localhost:3000/root\",\n\t\t},\n\t\tEnvironment: &Environment{\n\t\t\tID:             9,\n\t\t\tName:           \"production\",\n\t\t\tSlug:           \"\",\n\t\t\tState:          \"\",\n\t\t\tExternalURL:    \"https://about.gitlab.com\",\n\t\t\tProject:        nil,\n\t\t\tLastDeployment: nil,\n\t\t},\n\t\tDeployable: struct {\n\t\t\tID         int        `json:\"id\"`\n\t\t\tStatus     string     `json:\"status\"`\n\t\t\tStage      string     `json:\"stage\"`\n\t\t\tName       string     `json:\"name\"`\n\t\t\tRef        string     `json:\"ref\"`\n\t\t\tTag        bool       `json:\"tag\"`\n\t\t\tCoverage   float64    `json:\"coverage\"`\n\t\t\tCreatedAt  *time.Time `json:\"created_at\"`\n\t\t\tStartedAt  *time.Time `json:\"started_at\"`\n\t\t\tFinishedAt *time.Time `json:\"finished_at\"`\n\t\t\tDuration   float64    `json:\"duration\"`\n\t\t\tUser       *User      `json:\"user\"`\n\t\t\tCommit     *Commit    `json:\"commit\"`\n\t\t\tPipeline   struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t} `json:\"pipeline\"`\n\t\t\tRunner *Runner `json:\"runner\"`\n\t\t}{\n\t\t\tID:         657,\n\t\t\tStatus:     \"success\",\n\t\t\tStage:      \"deploy\",\n\t\t\tName:       \"deploy\",\n\t\t\tRef:        \"main\",\n\t\t\tTag:        false,\n\t\t\tCoverage:   0,\n\t\t\tCreatedAt:  nil,\n\t\t\tStartedAt:  nil,\n\t\t\tFinishedAt: nil,\n\t\t\tDuration:   0,\n\t\t\tUser: &User{\n\t\t\t\tID:        1,\n\t\t\t\tName:      \"Administrator\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://gitlab.dev/root\",\n\t\t\t},\n\t\t\tCommit: &Commit{\n\t\t\t\tID:             \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tShortID:        \"99d03678\",\n\t\t\t\tTitle:          \"Merge branch 'new-title' into 'main'\\r\",\n\t\t\t\tAuthorName:     \"Administrator\",\n\t\t\t\tAuthorEmail:    \"admin@example.com\",\n\t\t\t\tAuthoredDate:   nil,\n\t\t\t\tCommitterName:  \"\",\n\t\t\t\tCommitterEmail: \"\",\n\t\t\t\tCommittedDate:  nil,\n\t\t\t\tCreatedAt:      nil,\n\t\t\t\tMessage:        \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\tParentIDs:      nil,\n\t\t\t\tStats:          nil,\n\t\t\t\tStatus:         nil,\n\t\t\t\tLastPipeline:   nil,\n\t\t\t\tProjectID:      0,\n\t\t\t\tWebURL:         \"\",\n\t\t\t},\n\t\t\tPipeline: struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t}{\n\t\t\t\tID:        36,\n\t\t\t\tSHA:       \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tRef:       \"main\",\n\t\t\t\tStatus:    \"success\",\n\t\t\t\tCreatedAt: nil,\n\t\t\t\tUpdatedAt: nil,\n\t\t\t},\n\t\t\tRunner: nil,\n\t\t},\n\t}\n\n\td, resp, err := client.Deployments.CreateProjectDeployment(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Deployments.CreateProjectDeployment(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Deployments.CreateProjectDeployment(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Deployments.CreateProjectDeployment(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDeploymentsService_UpdateProjectDeployment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/deployments/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"status\": \"created\",\n\t\t\t\"deployable\": {\n\t\t\t  \"commit\": {\n\t\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\t\"id\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"message\": \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\t\"short_id\": \"99d03678\",\n\t\t\t\t\"title\": \"Merge branch 'new-title' into 'main'\\r\"\n\t\t\t  },\n\t\t\t  \"coverage\": null,\n\t\t\t  \"id\": 657,\n\t\t\t  \"name\": \"deploy\",\n\t\t\t  \"ref\": \"main\",\n\t\t\t  \"runner\": null,\n\t\t\t  \"stage\": \"deploy\",\n\t\t\t  \"status\": \"success\",\n\t\t\t  \"tag\": false,\n\t\t\t  \"user\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.dev/root\",\n\t\t\t\t\"bio\": null,\n\t\t\t\t\"location\": null,\n\t\t\t\t\"public_email\": \"\",\n\t\t\t\t\"skype\": \"\",\n\t\t\t\t\"linkedin\": \"\",\n\t\t\t\t\"twitter\": \"\",\n\t\t\t\t\"website_url\": \"\",\n\t\t\t\t\"organization\": \"\"\n\t\t\t  },\n\t\t\t  \"pipeline\": {\n\t\t\t\t\"id\": 36,\n\t\t\t\t\"ref\": \"main\",\n\t\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\t\"status\": \"success\",\n\t\t\t\t\"web_url\": \"http://gitlab.dev/root/project/pipelines/12\"\n\t\t\t  }\n\t\t\t},\n\t\t\t\"environment\": {\n\t\t\t  \"external_url\": \"https://about.gitlab.com\",\n\t\t\t  \"id\": 9,\n\t\t\t  \"name\": \"production\"\n\t\t\t},\n\t\t\t\"id\": 41,\n\t\t\t\"iid\": 1,\n\t\t\t\"ref\": \"main\",\n\t\t\t\"sha\": \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\"user\": {\n\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"web_url\": \"http://localhost:3000/root\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Deployment{\n\t\tID:     41,\n\t\tIID:    1,\n\t\tRef:    \"main\",\n\t\tSHA:    \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\tStatus: \"created\",\n\t\tUser: &ProjectUser{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://localhost:3000/root\",\n\t\t},\n\t\tEnvironment: &Environment{\n\t\t\tID:             9,\n\t\t\tName:           \"production\",\n\t\t\tSlug:           \"\",\n\t\t\tState:          \"\",\n\t\t\tExternalURL:    \"https://about.gitlab.com\",\n\t\t\tProject:        nil,\n\t\t\tLastDeployment: nil,\n\t\t},\n\t\tDeployable: struct {\n\t\t\tID         int        `json:\"id\"`\n\t\t\tStatus     string     `json:\"status\"`\n\t\t\tStage      string     `json:\"stage\"`\n\t\t\tName       string     `json:\"name\"`\n\t\t\tRef        string     `json:\"ref\"`\n\t\t\tTag        bool       `json:\"tag\"`\n\t\t\tCoverage   float64    `json:\"coverage\"`\n\t\t\tCreatedAt  *time.Time `json:\"created_at\"`\n\t\t\tStartedAt  *time.Time `json:\"started_at\"`\n\t\t\tFinishedAt *time.Time `json:\"finished_at\"`\n\t\t\tDuration   float64    `json:\"duration\"`\n\t\t\tUser       *User      `json:\"user\"`\n\t\t\tCommit     *Commit    `json:\"commit\"`\n\t\t\tPipeline   struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t} `json:\"pipeline\"`\n\t\t\tRunner *Runner `json:\"runner\"`\n\t\t}{\n\t\t\tID:         657,\n\t\t\tStatus:     \"success\",\n\t\t\tStage:      \"deploy\",\n\t\t\tName:       \"deploy\",\n\t\t\tRef:        \"main\",\n\t\t\tTag:        false,\n\t\t\tCoverage:   0,\n\t\t\tCreatedAt:  nil,\n\t\t\tStartedAt:  nil,\n\t\t\tFinishedAt: nil,\n\t\t\tDuration:   0,\n\t\t\tUser: &User{\n\t\t\t\tID:        1,\n\t\t\t\tName:      \"Administrator\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://gitlab.dev/root\",\n\t\t\t},\n\t\t\tCommit: &Commit{\n\t\t\t\tID:             \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tShortID:        \"99d03678\",\n\t\t\t\tTitle:          \"Merge branch 'new-title' into 'main'\\r\",\n\t\t\t\tAuthorName:     \"Administrator\",\n\t\t\t\tAuthorEmail:    \"admin@example.com\",\n\t\t\t\tAuthoredDate:   nil,\n\t\t\t\tCommitterName:  \"\",\n\t\t\t\tCommitterEmail: \"\",\n\t\t\t\tCommittedDate:  nil,\n\t\t\t\tCreatedAt:      nil,\n\t\t\t\tMessage:        \"Merge branch 'new-title' into 'main'\\r\\n\\r\\nUpdate README\\r\\n\\r\\n\\r\\n\\r\\nSee merge request !1\",\n\t\t\t\tParentIDs:      nil,\n\t\t\t\tStats:          nil,\n\t\t\t\tStatus:         nil,\n\t\t\t\tLastPipeline:   nil,\n\t\t\t\tProjectID:      0,\n\t\t\t\tWebURL:         \"\",\n\t\t\t},\n\t\t\tPipeline: struct {\n\t\t\t\tID        int        `json:\"id\"`\n\t\t\t\tSHA       string     `json:\"sha\"`\n\t\t\t\tRef       string     `json:\"ref\"`\n\t\t\t\tStatus    string     `json:\"status\"`\n\t\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t\t\tUpdatedAt *time.Time `json:\"updated_at\"`\n\t\t\t}{\n\t\t\t\tID:        36,\n\t\t\t\tSHA:       \"99d03678b90d914dbb1b109132516d71a4a03ea8\",\n\t\t\t\tRef:       \"main\",\n\t\t\t\tStatus:    \"success\",\n\t\t\t\tCreatedAt: nil,\n\t\t\t\tUpdatedAt: nil,\n\t\t\t},\n\t\t\tRunner: nil,\n\t\t},\n\t}\n\n\td, resp, err := client.Deployments.UpdateProjectDeployment(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Deployments.UpdateProjectDeployment(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Deployments.UpdateProjectDeployment(1, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Deployments.UpdateProjectDeployment(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "discussions.go",
          "type": "blob",
          "size": 34.380859375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// DiscussionsService handles communication with the discussions related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/discussions.html\ntype DiscussionsService struct {\n\tclient *Client\n}\n\n// Discussion represents a GitLab discussion.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/discussions.html\ntype Discussion struct {\n\tID             string  `json:\"id\"`\n\tIndividualNote bool    `json:\"individual_note\"`\n\tNotes          []*Note `json:\"notes\"`\n}\n\nfunc (d Discussion) String() string {\n\treturn Stringify(d)\n}\n\n// ListIssueDiscussionsOptions represents the available ListIssueDiscussions()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-issue-discussion-items\ntype ListIssueDiscussionsOptions ListOptions\n\n// ListIssueDiscussions gets a list of all discussions for a single\n// issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-issue-discussion-items\nfunc (s *DiscussionsService) ListIssueDiscussions(pid interface{}, issue int, opt *ListIssueDiscussionsOptions, options ...RequestOptionFunc) ([]*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/discussions\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ds []*Discussion\n\tresp, err := s.client.Do(req, &ds)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ds, resp, nil\n}\n\n// GetIssueDiscussion returns a single discussion for a specific project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#get-single-issue-discussion-item\nfunc (s *DiscussionsService) GetIssueDiscussion(pid interface{}, issue int, discussion string, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/discussions/%s\",\n\t\tPathEscape(project),\n\t\tissue,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CreateIssueDiscussionOptions represents the available CreateIssueDiscussion()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-issue-thread\ntype CreateIssueDiscussionOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// CreateIssueDiscussion creates a new discussion to a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-issue-thread\nfunc (s *DiscussionsService) CreateIssueDiscussion(pid interface{}, issue int, opt *CreateIssueDiscussionOptions, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/discussions\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// AddIssueDiscussionNoteOptions represents the available AddIssueDiscussionNote()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-issue-thread\ntype AddIssueDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// AddIssueDiscussionNote creates a new discussion to a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-issue-thread\nfunc (s *DiscussionsService) AddIssueDiscussionNote(pid interface{}, issue int, discussion string, opt *AddIssueDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/discussions/%s/notes\",\n\t\tPathEscape(project),\n\t\tissue,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateIssueDiscussionNoteOptions represents the available\n// UpdateIssueDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-existing-issue-thread-note\ntype UpdateIssueDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// UpdateIssueDiscussionNote modifies existing discussion of an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-existing-issue-thread-note\nfunc (s *DiscussionsService) UpdateIssueDiscussionNote(pid interface{}, issue int, discussion string, note int, opt *UpdateIssueDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tissue,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteIssueDiscussionNote deletes an existing discussion of an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#delete-an-issue-thread-note\nfunc (s *DiscussionsService) DeleteIssueDiscussionNote(pid interface{}, issue int, discussion string, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tissue,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListSnippetDiscussionsOptions represents the available ListSnippetDiscussions()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-snippet-discussion-items\ntype ListSnippetDiscussionsOptions ListOptions\n\n// ListSnippetDiscussions gets a list of all discussions for a single\n// snippet. Snippet discussions are comments users can post to a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-snippet-discussion-items\nfunc (s *DiscussionsService) ListSnippetDiscussions(pid interface{}, snippet int, opt *ListSnippetDiscussionsOptions, options ...RequestOptionFunc) ([]*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/discussions\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ds []*Discussion\n\tresp, err := s.client.Do(req, &ds)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ds, resp, nil\n}\n\n// GetSnippetDiscussion returns a single discussion for a given snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#get-single-snippet-discussion-item\nfunc (s *DiscussionsService) GetSnippetDiscussion(pid interface{}, snippet int, discussion string, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/discussions/%s\",\n\t\tPathEscape(project),\n\t\tsnippet,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CreateSnippetDiscussionOptions represents the available\n// CreateSnippetDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-snippet-thread\ntype CreateSnippetDiscussionOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// CreateSnippetDiscussion creates a new discussion for a single snippet.\n// Snippet discussions are comments users can post to a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-snippet-thread\nfunc (s *DiscussionsService) CreateSnippetDiscussion(pid interface{}, snippet int, opt *CreateSnippetDiscussionOptions, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/discussions\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// AddSnippetDiscussionNoteOptions represents the available\n// AddSnippetDiscussionNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-snippet-thread\ntype AddSnippetDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// AddSnippetDiscussionNote creates a new discussion to a single project\n// snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-snippet-thread\nfunc (s *DiscussionsService) AddSnippetDiscussionNote(pid interface{}, snippet int, discussion string, opt *AddSnippetDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/discussions/%s/notes\",\n\t\tPathEscape(project),\n\t\tsnippet,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateSnippetDiscussionNoteOptions represents the available\n// UpdateSnippetDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-existing-snippet-thread-note\ntype UpdateSnippetDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// UpdateSnippetDiscussionNote modifies existing discussion of a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-existing-snippet-thread-note\nfunc (s *DiscussionsService) UpdateSnippetDiscussionNote(pid interface{}, snippet int, discussion string, note int, opt *UpdateSnippetDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tsnippet,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteSnippetDiscussionNote deletes an existing discussion of a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#delete-a-snippet-thread-note\nfunc (s *DiscussionsService) DeleteSnippetDiscussionNote(pid interface{}, snippet int, discussion string, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tsnippet,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListGroupEpicDiscussionsOptions represents the available\n// ListEpicDiscussions() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-group-epic-discussion-items\ntype ListGroupEpicDiscussionsOptions ListOptions\n\n// ListGroupEpicDiscussions gets a list of all discussions for a single\n// epic. Epic discussions are comments users can post to a epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-group-epic-discussion-items\nfunc (s *DiscussionsService) ListGroupEpicDiscussions(gid interface{}, epic int, opt *ListGroupEpicDiscussionsOptions, options ...RequestOptionFunc) ([]*Discussion, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/discussions\",\n\t\tPathEscape(group),\n\t\tepic,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ds []*Discussion\n\tresp, err := s.client.Do(req, &ds)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ds, resp, nil\n}\n\n// GetEpicDiscussion returns a single discussion for a given epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#get-single-epic-discussion-item\nfunc (s *DiscussionsService) GetEpicDiscussion(gid interface{}, epic int, discussion string, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/discussions/%s\",\n\t\tPathEscape(group),\n\t\tepic,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CreateEpicDiscussionOptions represents the available CreateEpicDiscussion()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-epic-thread\ntype CreateEpicDiscussionOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// CreateEpicDiscussion creates a new discussion for a single epic. Epic\n// discussions are comments users can post to a epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-epic-thread\nfunc (s *DiscussionsService) CreateEpicDiscussion(gid interface{}, epic int, opt *CreateEpicDiscussionOptions, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/discussions\",\n\t\tPathEscape(group),\n\t\tepic,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// AddEpicDiscussionNoteOptions represents the available\n// AddEpicDiscussionNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-epic-thread\ntype AddEpicDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// AddEpicDiscussionNote creates a new discussion to a single project epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-epic-thread\nfunc (s *DiscussionsService) AddEpicDiscussionNote(gid interface{}, epic int, discussion string, opt *AddEpicDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/discussions/%s/notes\",\n\t\tPathEscape(group),\n\t\tepic,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateEpicDiscussionNoteOptions represents the available UpdateEpicDiscussion()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-existing-epic-thread-note\ntype UpdateEpicDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// UpdateEpicDiscussionNote modifies existing discussion of a epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-existing-epic-thread-note\nfunc (s *DiscussionsService) UpdateEpicDiscussionNote(gid interface{}, epic int, discussion string, note int, opt *UpdateEpicDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(group),\n\t\tepic,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteEpicDiscussionNote deletes an existing discussion of a epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#delete-an-epic-thread-note\nfunc (s *DiscussionsService) DeleteEpicDiscussionNote(gid interface{}, epic int, discussion string, note int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(group),\n\t\tepic,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListMergeRequestDiscussionsOptions represents the available\n// ListMergeRequestDiscussions() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-merge-request-discussion-items\ntype ListMergeRequestDiscussionsOptions ListOptions\n\n// ListMergeRequestDiscussions gets a list of all discussions for a single\n// merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-merge-request-discussion-items\nfunc (s *DiscussionsService) ListMergeRequestDiscussions(pid interface{}, mergeRequest int, opt *ListMergeRequestDiscussionsOptions, options ...RequestOptionFunc) ([]*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ds []*Discussion\n\tresp, err := s.client.Do(req, &ds)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ds, resp, nil\n}\n\n// GetMergeRequestDiscussion returns a single discussion for a given merge\n// request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#get-single-merge-request-discussion-item\nfunc (s *DiscussionsService) GetMergeRequestDiscussion(pid interface{}, mergeRequest int, discussion string, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions/%s\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CreateMergeRequestDiscussionOptions represents the available\n// CreateMergeRequestDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-merge-request-thread\ntype CreateMergeRequestDiscussionOptions struct {\n\tBody      *string          `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCommitID  *string          `url:\"commit_id,omitempty\" json:\"commit_id,omitempty\"`\n\tCreatedAt *time.Time       `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n\tPosition  *PositionOptions `url:\"position,omitempty\" json:\"position,omitempty\"`\n}\n\n// PositionOptions represents the position option of a discussion.\ntype PositionOptions struct {\n\tBaseSHA      *string           `url:\"base_sha,omitempty\" json:\"base_sha,omitempty\"`\n\tHeadSHA      *string           `url:\"head_sha,omitempty\" json:\"head_sha,omitempty\"`\n\tStartSHA     *string           `url:\"start_sha,omitempty\" json:\"start_sha,omitempty\"`\n\tNewPath      *string           `url:\"new_path,omitempty\" json:\"new_path,omitempty\"`\n\tOldPath      *string           `url:\"old_path,omitempty\" json:\"old_path,omitempty\"`\n\tPositionType *string           `url:\"position_type,omitempty\" json:\"position_type\"`\n\tNewLine      *int              `url:\"new_line,omitempty\" json:\"new_line,omitempty\"`\n\tOldLine      *int              `url:\"old_line,omitempty\" json:\"old_line,omitempty\"`\n\tLineRange    *LineRangeOptions `url:\"line_range,omitempty\" json:\"line_range,omitempty\"`\n\tWidth        *int              `url:\"width,omitempty\" json:\"width,omitempty\"`\n\tHeight       *int              `url:\"height,omitempty\" json:\"height,omitempty\"`\n\tX            *float64          `url:\"x,omitempty\" json:\"x,omitempty\"`\n\tY            *float64          `url:\"y,omitempty\" json:\"y,omitempty\"`\n}\n\n// LineRangeOptions represents the line range option of a discussion.\ntype LineRangeOptions struct {\n\tStart *LinePositionOptions `url:\"start,omitempty\" json:\"start,omitempty\"`\n\tEnd   *LinePositionOptions `url:\"end,omitempty\" json:\"end,omitempty\"`\n}\n\n// LinePositionOptions represents the line position option of a discussion.\ntype LinePositionOptions struct {\n\tLineCode *string `url:\"line_code,omitempty\" json:\"line_code,omitempty\"`\n\tType     *string `url:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\n// CreateMergeRequestDiscussion creates a new discussion for a single merge\n// request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-merge-request-thread\nfunc (s *DiscussionsService) CreateMergeRequestDiscussion(pid interface{}, mergeRequest int, opt *CreateMergeRequestDiscussionOptions, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// ResolveMergeRequestDiscussionOptions represents the available\n// ResolveMergeRequestDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#resolve-a-merge-request-thread\ntype ResolveMergeRequestDiscussionOptions struct {\n\tResolved *bool `url:\"resolved,omitempty\" json:\"resolved,omitempty\"`\n}\n\n// ResolveMergeRequestDiscussion resolves/unresolves whole discussion of a merge\n// request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#resolve-a-merge-request-thread\nfunc (s *DiscussionsService) ResolveMergeRequestDiscussion(pid interface{}, mergeRequest int, discussion string, opt *ResolveMergeRequestDiscussionOptions, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions/%s\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// AddMergeRequestDiscussionNoteOptions represents the available\n// AddMergeRequestDiscussionNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-merge-request-thread\ntype AddMergeRequestDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// AddMergeRequestDiscussionNote creates a new discussion to a single project\n// merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-merge-request-thread\nfunc (s *DiscussionsService) AddMergeRequestDiscussionNote(pid interface{}, mergeRequest int, discussion string, opt *AddMergeRequestDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions/%s/notes\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateMergeRequestDiscussionNoteOptions represents the available\n// UpdateMergeRequestDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-an-existing-merge-request-thread-note\ntype UpdateMergeRequestDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n\tResolved  *bool      `url:\"resolved,omitempty\" json:\"resolved,omitempty\"`\n}\n\n// UpdateMergeRequestDiscussionNote modifies existing discussion of a merge\n// request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-an-existing-merge-request-thread-note\nfunc (s *DiscussionsService) UpdateMergeRequestDiscussionNote(pid interface{}, mergeRequest int, discussion string, note int, opt *UpdateMergeRequestDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteMergeRequestDiscussionNote deletes an existing discussion of a merge\n// request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#delete-a-merge-request-thread-note\nfunc (s *DiscussionsService) DeleteMergeRequestDiscussionNote(pid interface{}, mergeRequest int, discussion string, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tmergeRequest,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListCommitDiscussionsOptions represents the available\n// ListCommitDiscussions() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-commit-discussion-items\ntype ListCommitDiscussionsOptions ListOptions\n\n// ListCommitDiscussions gets a list of all discussions for a single\n// commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#list-project-commit-discussion-items\nfunc (s *DiscussionsService) ListCommitDiscussions(pid interface{}, commit string, opt *ListCommitDiscussionsOptions, options ...RequestOptionFunc) ([]*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/discussions\",\n\t\tPathEscape(project),\n\t\tcommit,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ds []*Discussion\n\tresp, err := s.client.Do(req, &ds)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ds, resp, nil\n}\n\n// GetCommitDiscussion returns a single discussion for a specific project\n// commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#get-single-commit-discussion-item\nfunc (s *DiscussionsService) GetCommitDiscussion(pid interface{}, commit string, discussion string, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/discussions/%s\",\n\t\tPathEscape(project),\n\t\tcommit,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// CreateCommitDiscussionOptions represents the available\n// CreateCommitDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-commit-thread\ntype CreateCommitDiscussionOptions struct {\n\tBody      *string       `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time    `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n\tPosition  *NotePosition `url:\"position,omitempty\" json:\"position,omitempty\"`\n}\n\n// CreateCommitDiscussion creates a new discussion to a single project commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#create-new-commit-thread\nfunc (s *DiscussionsService) CreateCommitDiscussion(pid interface{}, commit string, opt *CreateCommitDiscussionOptions, options ...RequestOptionFunc) (*Discussion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/discussions\",\n\t\tPathEscape(project),\n\t\tcommit,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\td := new(Discussion)\n\tresp, err := s.client.Do(req, d)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn d, resp, nil\n}\n\n// AddCommitDiscussionNoteOptions represents the available\n// AddCommitDiscussionNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-commit-thread\ntype AddCommitDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// AddCommitDiscussionNote creates a new discussion to a single project commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#add-note-to-existing-commit-thread\nfunc (s *DiscussionsService) AddCommitDiscussionNote(pid interface{}, commit string, discussion string, opt *AddCommitDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/discussions/%s/notes\",\n\t\tPathEscape(project),\n\t\tcommit,\n\t\tdiscussion,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateCommitDiscussionNoteOptions represents the available\n// UpdateCommitDiscussion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-an-existing-commit-thread-note\ntype UpdateCommitDiscussionNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// UpdateCommitDiscussionNote modifies existing discussion of an commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#modify-an-existing-commit-thread-note\nfunc (s *DiscussionsService) UpdateCommitDiscussionNote(pid interface{}, commit string, discussion string, note int, opt *UpdateCommitDiscussionNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tcommit,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteCommitDiscussionNote deletes an existing discussion of an commit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/discussions.html#delete-a-commit-thread-note\nfunc (s *DiscussionsService) DeleteCommitDiscussionNote(pid interface{}, commit string, discussion string, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/commits/%s/discussions/%s/notes/%d\",\n\t\tPathEscape(project),\n\t\tcommit,\n\t\tdiscussion,\n\t\tnote,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "discussions_test.go",
          "type": "blob",
          "size": 80.8701171875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDiscussionsService_ListIssueDiscussions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\t\"individual_note\": false,\n\t\t\t\t\"notes\": [\n\t\t\t\t  {\n\t\t\t\t\t\"id\": 1126,\n\t\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\t\"attachment\": null,\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t  \"id\": 1,\n\t\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t\t  \"state\": \"active\",\n\t\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t\t},\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\t\"noteable_type\": \"Issue\",\n\t\t\t\t\t\"noteable_iid\": null\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Discussion{{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Issue\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}}\n\n\tds, resp, err := client.Discussions.ListIssueDiscussions(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Discussions.ListIssueDiscussions(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListIssueDiscussions(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListIssueDiscussions(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_GetIssueDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Issue\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Issue\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.GetIssueDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.GetIssueDiscussion(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetIssueDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetIssueDiscussion(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_CreateIssueDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Issue\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Issue\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.CreateIssueDiscussion(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.CreateIssueDiscussion(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateIssueDiscussion(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateIssueDiscussion(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_AddIssueDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Issue\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Issue\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.AddIssueDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.AddIssueDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddIssueDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddIssueDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_UpdateIssueDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Issue\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Issue\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.UpdateIssueDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.UpdateIssueDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateIssueDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateIssueDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_DeleteIssueDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Discussions.DeleteIssueDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Discussions.DeleteIssueDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteIssueDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteIssueDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_ListSnippetDiscussions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/snippets/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\t\"individual_note\": false,\n\t\t\t\t\"notes\": [\n\t\t\t\t  {\n\t\t\t\t\t\"id\": 1126,\n\t\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\t\"attachment\": null,\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t  \"id\": 1,\n\t\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t\t  \"state\": \"active\",\n\t\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t\t},\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\t\"noteable_type\": \"Snippet\",\n\t\t\t\t\t\"noteable_iid\": null\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Discussion{{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Snippet\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}}\n\n\tds, resp, err := client.Discussions.ListSnippetDiscussions(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Discussions.ListSnippetDiscussions(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListSnippetDiscussions(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListSnippetDiscussions(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_GetSnippetDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/snippets/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Snippet\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Snippet\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.GetSnippetDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.GetSnippetDiscussion(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetSnippetDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetSnippetDiscussion(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_CreateSnippetDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/snippets/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Snippet\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Snippet\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.CreateSnippetDiscussion(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.CreateSnippetDiscussion(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateSnippetDiscussion(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateSnippetDiscussion(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_AddSnippetDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/snippets/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Snippet\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Snippet\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.AddSnippetDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.AddSnippetDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddSnippetDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddSnippetDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_UpdateSnippetDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/snippets/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Snippet\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Snippet\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.UpdateSnippetDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.UpdateSnippetDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateSnippetDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateSnippetDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_DeleteSnippetDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/snippets/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Discussions.DeleteSnippetDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Discussions.DeleteSnippetDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteSnippetDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteSnippetDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_ListGroupEpicDiscussions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epics/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\t\"individual_note\": false,\n\t\t\t\t\"notes\": [\n\t\t\t\t  {\n\t\t\t\t\t\"id\": 1126,\n\t\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\t\"attachment\": null,\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t  \"id\": 1,\n\t\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t\t  \"state\": \"active\",\n\t\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t\t},\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\t\"noteable_type\": \"Epic\",\n\t\t\t\t\t\"noteable_iid\": null\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Discussion{{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Epic\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}}\n\n\tds, resp, err := client.Discussions.ListGroupEpicDiscussions(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Discussions.ListGroupEpicDiscussions(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListGroupEpicDiscussions(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListGroupEpicDiscussions(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_GetEpicDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epics/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Epic\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Epic\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.GetEpicDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.GetEpicDiscussion(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetEpicDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetEpicDiscussion(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_CreateEpicDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epics/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Epic\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Epic\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.CreateEpicDiscussion(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.CreateEpicDiscussion(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateEpicDiscussion(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateEpicDiscussion(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_AddEpicDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epics/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Epic\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Epic\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.AddEpicDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.AddEpicDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddEpicDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddEpicDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_UpdateEpicDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epics/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Epic\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Epic\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.UpdateEpicDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.UpdateEpicDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateEpicDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateEpicDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_DeleteEpicDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epics/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Discussions.DeleteEpicDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Discussions.DeleteEpicDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteEpicDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteEpicDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_ListMergeRequestDiscussions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\t\"individual_note\": false,\n\t\t\t\t\"notes\": [\n\t\t\t\t  {\n\t\t\t\t\t\"id\": 1126,\n\t\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\t\"attachment\": null,\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t  \"id\": 1,\n\t\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t\t  \"state\": \"active\",\n\t\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t\t},\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\t\"noteable_type\": \"Merge request\",\n\t\t\t\t\t\"noteable_iid\": null\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Discussion{{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Merge request\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}}\n\n\tds, resp, err := client.Discussions.ListMergeRequestDiscussions(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Discussions.ListMergeRequestDiscussions(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListMergeRequestDiscussions(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListMergeRequestDiscussions(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_GetMergeRequestDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Merge request\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Merge request\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.GetMergeRequestDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.GetMergeRequestDiscussion(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetMergeRequestDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetMergeRequestDiscussion(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_CreateMergeRequestDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Merge request\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Merge request\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.CreateMergeRequestDiscussion(5, 11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.CreateMergeRequestDiscussion(5.01, 11, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateMergeRequestDiscussion(5, 11, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateMergeRequestDiscussion(3, 11, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_ResolveMergeRequestDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Merge request\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Merge request\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.ResolveMergeRequestDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.ResolveMergeRequestDiscussion(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.ResolveMergeRequestDiscussion(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.ResolveMergeRequestDiscussion(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_AddMergeRequestDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Merge request\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Merge request\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.AddMergeRequestDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.AddMergeRequestDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddMergeRequestDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddMergeRequestDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_UpdateMergeRequestDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Merge request\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Merge request\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.UpdateMergeRequestDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.UpdateMergeRequestDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateMergeRequestDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateMergeRequestDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_DeleteMergeRequestDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Discussions.DeleteMergeRequestDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Discussions.DeleteMergeRequestDiscussionNote(5.01, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteMergeRequestDiscussionNote(5, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteMergeRequestDiscussionNote(3, 11, \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_ListCommitDiscussions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/commits/abc123/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\t\"individual_note\": false,\n\t\t\t\t\"notes\": [\n\t\t\t\t  {\n\t\t\t\t\t\"id\": 1126,\n\t\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\t\"attachment\": null,\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t  \"id\": 1,\n\t\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t\t  \"state\": \"active\",\n\t\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t\t},\n\t\t\t\t\t\"system\": false,\n\t\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\t\"noteable_type\": \"Commit\",\n\t\t\t\t\t\"noteable_iid\": null\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Discussion{{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Commit\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}}\n\n\tds, resp, err := client.Discussions.ListCommitDiscussions(5, \"abc123\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ds)\n\n\tds, resp, err = client.Discussions.ListCommitDiscussions(5.01, \"abc123\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListCommitDiscussions(5, \"abc123\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ds)\n\n\tds, resp, err = client.Discussions.ListCommitDiscussions(3, \"abc123\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_GetCommitDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/commits/abc123/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Commit\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Commit\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.GetCommitDiscussion(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.GetCommitDiscussion(5.01, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetCommitDiscussion(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.GetCommitDiscussion(3, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_CreateCommitDiscussion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/commits/abc123/discussions\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\t\t\"individual_note\": false,\n\t\t\t\"notes\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1126,\n\t\t\t\t\"type\": \"DiscussionNote\",\n\t\t\t\t\"body\": \"discussion text\",\n\t\t\t\t\"attachment\": null,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"system\": false,\n\t\t\t\t\"noteable_id\": 3,\n\t\t\t\t\"noteable_type\": \"Commit\",\n\t\t\t\t\"noteable_iid\": null\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Discussion{\n\t\tID:             \"6a9c1750b37d513a43987b574953fceb50b03ce7\",\n\t\tIndividualNote: false,\n\t\tNotes: []*Note{{\n\t\t\tID:         1126,\n\t\t\tType:       \"DiscussionNote\",\n\t\t\tBody:       \"discussion text\",\n\t\t\tAttachment: \"\",\n\t\t\tTitle:      \"\",\n\t\t\tFileName:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tID:        1,\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tEmail:     \"\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/00afb8fb6ab07c3ee3e9c1f38777e2f4?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tSystem:       false,\n\t\t\tExpiresAt:    nil,\n\t\t\tUpdatedAt:    nil,\n\t\t\tCreatedAt:    nil,\n\t\t\tNoteableID:   3,\n\t\t\tNoteableType: \"Commit\",\n\t\t\tCommitID:     \"\",\n\t\t\tPosition:     nil,\n\t\t\tResolvable:   false,\n\t\t\tResolved:     false,\n\t\t\tResolvedBy: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tEmail     string `json:\"email\"`\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{},\n\t\t\tNoteableIID: 0,\n\t\t}},\n\t}\n\n\td, resp, err := client.Discussions.CreateCommitDiscussion(5, \"abc123\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n\n\td, resp, err = client.Discussions.CreateCommitDiscussion(5.01, \"abc123\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateCommitDiscussion(5, \"abc123\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, d)\n\n\td, resp, err = client.Discussions.CreateCommitDiscussion(3, \"abc123\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, d)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_AddCommitDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/commits/abc123/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Commit\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Commit\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.AddCommitDiscussionNote(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.AddCommitDiscussionNote(5.01, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddCommitDiscussionNote(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.AddCommitDiscussionNote(3, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_UpdateCommitDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/commits/abc123/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 302,\n\t\t\t\"body\": \"closed\",\n\t\t\t\"attachment\": null,\n\t\t\t\"author\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venky333\",\n\t\t\t  \"email\": \"venky333@example.com\",\n\t\t\t  \"name\": \"venky333\",\n\t\t\t  \"state\": \"active\"\n\t\t\t},\n\t\t\t\"system\": true,\n\t\t\t\"noteable_id\": 377,\n\t\t\t\"noteable_type\": \"Commit\",\n\t\t\t\"noteable_iid\": 377,\n\t\t\t\"resolvable\": false,\n\t\t\t\"confidential\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Note{\n\t\tID:         302,\n\t\tType:       \"\",\n\t\tBody:       \"closed\",\n\t\tAttachment: \"\",\n\t\tTitle:      \"\",\n\t\tFileName:   \"\",\n\t\tAuthor: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tUsername:  \"venky333\",\n\t\t\tEmail:     \"venky333@example.com\",\n\t\t\tName:      \"venky333\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"\",\n\t\t},\n\t\tSystem:       true,\n\t\tExpiresAt:    nil,\n\t\tUpdatedAt:    nil,\n\t\tCreatedAt:    nil,\n\t\tNoteableID:   377,\n\t\tNoteableType: \"Commit\",\n\t\tCommitID:     \"\",\n\t\tPosition:     nil,\n\t\tResolvable:   false,\n\t\tResolved:     false,\n\t\tResolvedBy: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{},\n\t\tNoteableIID: 377,\n\t}\n\n\tn, resp, err := client.Discussions.UpdateCommitDiscussionNote(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, n)\n\n\tn, resp, err = client.Discussions.UpdateCommitDiscussionNote(5.01, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateCommitDiscussionNote(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, n)\n\n\tn, resp, err = client.Discussions.UpdateCommitDiscussionNote(3, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, n)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestDiscussionsService_DeleteCommitDiscussionNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/repository/commits/abc123/discussions/6a9c1750b37d513a43987b574953fceb50b03ce7/notes/302\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Discussions.DeleteCommitDiscussionNote(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Discussions.DeleteCommitDiscussionNote(5.01, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteCommitDiscussionNote(5, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Discussions.DeleteCommitDiscussionNote(3, \"abc123\", \"6a9c1750b37d513a43987b574953fceb50b03ce7\", 302, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "dockerfile_templates.go",
          "type": "blob",
          "size": 2.822265625,
          "content": "//\n// Copyright 2022, FantasyTeddy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// DockerfileTemplatesService handles communication with the Dockerfile\n// templates related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/dockerfiles.html\ntype DockerfileTemplatesService struct {\n\tclient *Client\n}\n\n// DockerfileTemplate represents a GitLab Dockerfile template.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/dockerfiles.html\ntype DockerfileTemplate struct {\n\tName    string `json:\"name\"`\n\tContent string `json:\"content\"`\n}\n\n// DockerfileTemplateListItem represents a GitLab Dockerfile template from the list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/dockerfiles.html\ntype DockerfileTemplateListItem struct {\n\tKey  string `json:\"key\"`\n\tName string `json:\"name\"`\n}\n\n// ListDockerfileTemplatesOptions represents the available ListAllTemplates() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/dockerfiles.html#list-dockerfile-templates\ntype ListDockerfileTemplatesOptions ListOptions\n\n// ListTemplates get a list of available Dockerfile templates.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/dockerfiles.html#list-dockerfile-templates\nfunc (s *DockerfileTemplatesService) ListTemplates(opt *ListDockerfileTemplatesOptions, options ...RequestOptionFunc) ([]*DockerfileTemplateListItem, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"templates/dockerfiles\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*DockerfileTemplateListItem\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// GetTemplate get a single Dockerfile template.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/dockerfiles.html#single-dockerfile-template\nfunc (s *DockerfileTemplatesService) GetTemplate(key string, options ...RequestOptionFunc) (*DockerfileTemplate, *Response, error) {\n\tu := fmt.Sprintf(\"templates/dockerfiles/%s\", url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(DockerfileTemplate)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n"
        },
        {
          "name": "dockerfile_templates_test.go",
          "type": "blob",
          "size": 2.7626953125,
          "content": "//\n// Copyright 2022, FantasyTeddy\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestDockerfileTemplatesService_ListTemplates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/dockerfiles\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"key\":\"Binary\",\n\t\t\t  \"name\":\"Binary\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\":\"Binary-alpine\",\n\t\t\t  \"name\":\"Binary-alpine\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\":\"Binary-scratch\",\n\t\t\t  \"name\":\"Binary-scratch\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\":\"Golang\",\n\t\t\t  \"name\":\"Golang\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\":\"Golang-alpine\",\n\t\t\t  \"name\":\"Golang-alpine\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\":\"Golang-scratch\",\n\t\t\t  \"name\":\"Golang-scratch\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\ttemplates, _, err := client.DockerfileTemplate.ListTemplates(&ListDockerfileTemplatesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"DockerfileTemplate.ListTemplates returned error: %v\", err)\n\t}\n\n\twant := []*DockerfileTemplateListItem{\n\t\t{\n\t\t\tKey:  \"Binary\",\n\t\t\tName: \"Binary\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Binary-alpine\",\n\t\t\tName: \"Binary-alpine\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Binary-scratch\",\n\t\t\tName: \"Binary-scratch\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Golang\",\n\t\t\tName: \"Golang\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Golang-alpine\",\n\t\t\tName: \"Golang-alpine\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Golang-scratch\",\n\t\t\tName: \"Golang-scratch\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, templates) {\n\t\tt.Errorf(\"DockerfileTemplate.ListTemplates returned %+v, want %+v\", templates, want)\n\t}\n}\n\nfunc TestDockerfileTemplatesService_GetTemplate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/dockerfiles/Binary\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"name\": \"Binary\",\n\t\t\t\"content\": \"# This file is a template, and might need editing before it works on your project.\"\n\t\t  }`)\n\t})\n\n\ttemplate, _, err := client.DockerfileTemplate.GetTemplate(\"Binary\")\n\tif err != nil {\n\t\tt.Errorf(\"DockerfileTemplate.GetTemplate returned error: %v\", err)\n\t}\n\n\twant := &DockerfileTemplate{\n\t\tName:    \"Binary\",\n\t\tContent: \"# This file is a template, and might need editing before it works on your project.\",\n\t}\n\tif !reflect.DeepEqual(want, template) {\n\t\tt.Errorf(\"DockerfileTemplate.GetTemplate returned %+v, want %+v\", template, want)\n\t}\n}\n"
        },
        {
          "name": "dora_metrics.go",
          "type": "blob",
          "size": 3.4521484375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// DORAMetricsService handles communication with the DORA metrics related methods\n// of the GitLab API.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\ntype DORAMetricsService struct {\n\tclient *Client\n}\n\n// DORAMetric represents a single DORA metric data point.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\ntype DORAMetric struct {\n\tDate  string  `json:\"date\"`\n\tValue float64 `json:\"value\"`\n}\n\n// Gets a string representation of a DORAMetric data point\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\nfunc (m DORAMetric) String() string {\n\treturn Stringify(m)\n}\n\n// GetDORAMetricsOptions represent the request body options for getting\n// DORA metrics\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\ntype GetDORAMetricsOptions struct {\n\tMetric           *DORAMetricType     `url:\"metric,omitempty\" json:\"metric,omitempty\"`\n\tEndDate          *ISOTime            `url:\"end_date,omitempty\" json:\"end_date,omitempty\"`\n\tEnvironmentTiers *[]string           `url:\"environment_tiers,comma,omitempty\" json:\"environment_tiers,omitempty\"`\n\tInterval         *DORAMetricInterval `url:\"interval,omitempty\" json:\"interval,omitempty\"`\n\tStartDate        *ISOTime            `url:\"start_date,omitempty\" json:\"start_date,omitempty\"`\n\n\t// Deprecated, use environment tiers instead\n\tEnvironmentTier *string `url:\"environment_tier,omitempty\" json:\"environment_tier,omitempty\"`\n}\n\n// GetProjectDORAMetrics gets the DORA metrics for a project.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/dora/metrics.html#get-project-level-dora-metrics\nfunc (s *DORAMetricsService) GetProjectDORAMetrics(pid interface{}, opt GetDORAMetricsOptions, options ...RequestOptionFunc) ([]DORAMetric, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/dora/metrics\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar metrics []DORAMetric\n\tresp, err := s.client.Do(req, &metrics)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn metrics, resp, err\n}\n\n// GetGroupDORAMetrics gets the DORA metrics for a group.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/dora/metrics.html#get-group-level-dora-metrics\nfunc (s *DORAMetricsService) GetGroupDORAMetrics(gid interface{}, opt GetDORAMetricsOptions, options ...RequestOptionFunc) ([]DORAMetric, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/dora/metrics\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar metrics []DORAMetric\n\tresp, err := s.client.Do(req, &metrics)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn metrics, resp, err\n}\n"
        },
        {
          "name": "dora_metrics_test.go",
          "type": "blob",
          "size": 3.1884765625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestDORAMetrics_GetProjectDORAMetrics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/dora/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tquery := r.URL.Query()\n\t\tfor k, v := range map[string]string{\n\t\t\t\"metric\":     \"deployment_frequency\",\n\t\t\t\"start_date\": \"2021-03-01\",\n\t\t\t\"end_date\":   \"2021-03-08\",\n\t\t} {\n\t\t\tif query.Get(k) != v {\n\t\t\t\tt.Errorf(\"Query parameter %s: %s, want %s\", k, query.Get(k), v)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{ \"date\": \"2021-03-01\", \"value\": 3 },\n\t\t\t\t{ \"date\": \"2021-03-02\", \"value\": 6 },\n\t\t\t\t{ \"date\": \"2021-03-03\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-04\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-05\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-06\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-07\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-08\", \"value\": 4 }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []DORAMetric{\n\t\t{Date: \"2021-03-01\", Value: 3},\n\t\t{Date: \"2021-03-02\", Value: 6},\n\t\t{Date: \"2021-03-03\", Value: 0},\n\t\t{Date: \"2021-03-04\", Value: 0},\n\t\t{Date: \"2021-03-05\", Value: 0},\n\t\t{Date: \"2021-03-06\", Value: 0},\n\t\t{Date: \"2021-03-07\", Value: 0},\n\t\t{Date: \"2021-03-08\", Value: 4},\n\t}\n\n\tstartDate := ISOTime(time.Date(2021, time.March, 1, 0, 0, 0, 0, time.UTC))\n\tendDate := ISOTime(time.Date(2021, time.March, 8, 0, 0, 0, 0, time.UTC))\n\n\td, resp, err := client.DORAMetrics.GetProjectDORAMetrics(1, GetDORAMetricsOptions{\n\t\tMetric:    Ptr(DORAMetricDeploymentFrequency),\n\t\tStartDate: &startDate,\n\t\tEndDate:   &endDate,\n\t})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n}\n\nfunc TestDORAMetrics_GetGroupDORAMetrics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/dora/metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tquery := r.URL.Query()\n\t\tfor k, v := range map[string]string{\n\t\t\t\"metric\":     \"deployment_frequency\",\n\t\t\t\"start_date\": \"2021-03-01\",\n\t\t\t\"end_date\":   \"2021-03-08\",\n\t\t} {\n\t\t\tif query.Get(k) != v {\n\t\t\t\tt.Errorf(\"Query parameter %s: %s, want %s\", k, query.Get(k), v)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{ \"date\": \"2021-03-01\", \"value\": 3 },\n\t\t\t\t{ \"date\": \"2021-03-02\", \"value\": 6 },\n\t\t\t\t{ \"date\": \"2021-03-03\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-04\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-05\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-06\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-07\", \"value\": 0 },\n\t\t\t\t{ \"date\": \"2021-03-08\", \"value\": 4 }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []DORAMetric{\n\t\t{Date: \"2021-03-01\", Value: 3},\n\t\t{Date: \"2021-03-02\", Value: 6},\n\t\t{Date: \"2021-03-03\", Value: 0},\n\t\t{Date: \"2021-03-04\", Value: 0},\n\t\t{Date: \"2021-03-05\", Value: 0},\n\t\t{Date: \"2021-03-06\", Value: 0},\n\t\t{Date: \"2021-03-07\", Value: 0},\n\t\t{Date: \"2021-03-08\", Value: 4},\n\t}\n\n\tstartDate := ISOTime(time.Date(2021, time.March, 1, 0, 0, 0, 0, time.UTC))\n\tendDate := ISOTime(time.Date(2021, time.March, 8, 0, 0, 0, 0, time.UTC))\n\n\td, resp, err := client.DORAMetrics.GetGroupDORAMetrics(1, GetDORAMetricsOptions{\n\t\tMetric:    Ptr(DORAMetricDeploymentFrequency),\n\t\tStartDate: &startDate,\n\t\tEndDate:   &endDate,\n\t})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, d)\n}\n"
        },
        {
          "name": "draft_notes.go",
          "type": "blob",
          "size": 7.5361328125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\ntype DraftNote struct {\n\tID                int           `json:\"id\"`\n\tAuthorID          int           `json:\"author_id\"`\n\tMergeRequestID    int           `json:\"merge_request_id\"`\n\tResolveDiscussion bool          `json:\"resolve_discussion\"`\n\tDiscussionID      string        `json:\"discussion_id\"`\n\tNote              string        `json:\"note\"`\n\tCommitID          string        `json:\"commit_id\"`\n\tLineCode          string        `json:\"line_code\"`\n\tPosition          *NotePosition `json:\"position\"`\n}\n\n// DraftNotesService handles communication with the draft notes related methods\n// of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#list-all-merge-request-draft-notes\ntype DraftNotesService struct {\n\tclient *Client\n}\n\n// ListDraftNotesOptions represents the available ListDraftNotes()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#list-all-merge-request-draft-notes\ntype ListDraftNotesOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListDraftNotes gets a list of all draft notes for a merge request.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#list-all-merge-request-draft-notes\nfunc (s *DraftNotesService) ListDraftNotes(pid interface{}, mergeRequest int, opt *ListDraftNotesOptions, options ...RequestOptionFunc) ([]*DraftNote, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*DraftNote\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// GetDraftNote gets a single draft note for a merge request.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#get-a-single-draft-note\nfunc (s *DraftNotesService) GetDraftNote(pid interface{}, mergeRequest int, note int, options ...RequestOptionFunc) (*DraftNote, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes/%d\", PathEscape(project), mergeRequest, note)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(DraftNote)\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// CreateDraftNoteOptions represents the available CreateDraftNote()\n// options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#create-a-draft-note\ntype CreateDraftNoteOptions struct {\n\tNote                  *string          `url:\"note\" json:\"note\"`\n\tCommitID              *string          `url:\"commit_id,omitempty\" json:\"commit_id,omitempty\"`\n\tInReplyToDiscussionID *string          `url:\"in_reply_to_discussion_id,omitempty\" json:\"in_reply_to_discussion_id,omitempty\"`\n\tResolveDiscussion     *bool            `url:\"resolve_discussion,omitempty\" json:\"resolve_discussion,omitempty\"`\n\tPosition              *PositionOptions `url:\"position,omitempty\" json:\"position,omitempty\"`\n}\n\n// CreateDraftNote creates a draft note for a merge request.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#create-a-draft-note\nfunc (s *DraftNotesService) CreateDraftNote(pid interface{}, mergeRequest int, opt *CreateDraftNoteOptions, options ...RequestOptionFunc) (*DraftNote, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(DraftNote)\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateDraftNoteOptions represents the available UpdateDraftNote()\n// options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#create-a-draft-note\ntype UpdateDraftNoteOptions struct {\n\tNote     *string          `url:\"note,omitempty\" json:\"note,omitempty\"`\n\tPosition *PositionOptions `url:\"position,omitempty\" json:\"position,omitempty\"`\n}\n\n// UpdateDraftNote updates a draft note for a merge request.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/draft_notes.html#create-a-draft-note\nfunc (s *DraftNotesService) UpdateDraftNote(pid interface{}, mergeRequest int, note int, opt *UpdateDraftNoteOptions, options ...RequestOptionFunc) (*DraftNote, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes/%d\", PathEscape(project), mergeRequest, note)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(DraftNote)\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteDraftNote deletes a single draft note for a merge request.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#delete-a-draft-note\nfunc (s *DraftNotesService) DeleteDraftNote(pid interface{}, mergeRequest int, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes/%d\", PathEscape(project), mergeRequest, note)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// PublishDraftNote publishes a single draft note for a merge request.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#publish-a-draft-note\nfunc (s *DraftNotesService) PublishDraftNote(pid interface{}, mergeRequest int, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes/%d/publish\", PathEscape(project), mergeRequest, note)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// PublishAllDraftNotes publishes all draft notes for a merge request that belong to the user.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/draft_notes.html#publish-a-draft-note\nfunc (s *DraftNotesService) PublishAllDraftNotes(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/draft_notes/bulk_publish\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "draft_notes_test.go",
          "type": "blob",
          "size": 5.9794921875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetDraftNote(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_draft_note.json\")\n\t})\n\n\tnote, _, err := client.DraftNotes.GetDraftNote(\"1\", 4329, 3)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &DraftNote{\n\t\tID:                37349978,\n\t\tAuthorID:          10271899,\n\t\tMergeRequestID:    291473309,\n\t\tResolveDiscussion: false,\n\t\tDiscussionID:      \"\",\n\t\tNote:              \"Some draft note\",\n\t\tCommitID:          \"\",\n\t\tLineCode:          \"\",\n\t\tPosition:          nil,\n\t}\n\n\tif !reflect.DeepEqual(note, want) {\n\t\tt.Errorf(\"DraftNotes.GetDraftNote want %#v, got %#v\", note, want)\n\t}\n}\n\nfunc TestListDraftNotes(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_draft_notes.json\")\n\t})\n\n\tnotes, _, err := client.DraftNotes.ListDraftNotes(\"1\", 4329, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*DraftNote{\n\t\t{\n\t\t\tID:                37349978,\n\t\t\tAuthorID:          10271899,\n\t\t\tMergeRequestID:    291473309,\n\t\t\tResolveDiscussion: false,\n\t\t\tDiscussionID:      \"\",\n\t\t\tNote:              \"Some draft note\",\n\t\t\tCommitID:          \"\",\n\t\t\tLineCode:          \"\",\n\t\t\tPosition:          nil,\n\t\t},\n\t\t{\n\t\t\tID:                37349979,\n\t\t\tAuthorID:          10271899,\n\t\t\tMergeRequestID:    291473309,\n\t\t\tResolveDiscussion: false,\n\t\t\tDiscussionID:      \"\",\n\t\t\tNote:              \"Some draft note 2\",\n\t\t\tCommitID:          \"\",\n\t\t\tLineCode:          \"3dacf79e0d779e2baa1c700cf56510e42f55cf85_10_9\",\n\t\t\tPosition: &NotePosition{\n\t\t\t\tBaseSHA:      \"64581c4ee41beb44d943d7801f82d9038e25e453\",\n\t\t\t\tStartSHA:     \"87bffbff93bf334889780f54ae1922355661f867\",\n\t\t\t\tHeadSHA:      \"2c972dbf9094c380f5f00dcd8112d2c69b24c859\",\n\t\t\t\tOldPath:      \"src/some-dir/some-file.js\",\n\t\t\t\tNewPath:      \"src/some-dir/some-file.js\",\n\t\t\t\tPositionType: \"text\",\n\t\t\t\tNewLine:      9,\n\t\t\t\tLineRange: &LineRange{\n\t\t\t\t\tStartRange: &LinePosition{\n\t\t\t\t\t\tLineCode: \"3dacf79e0d779e2baa1c700cf56510e42f55cf85_10_9\",\n\t\t\t\t\t\tType:     \"new\",\n\t\t\t\t\t\tNewLine:  9,\n\t\t\t\t\t},\n\t\t\t\t\tEndRange: &LinePosition{\n\t\t\t\t\t\tLineCode: \"3dacf79e0d779e2baa1c700cf56510e42f55cf85_10_9\",\n\t\t\t\t\t\tType:     \"new\",\n\t\t\t\t\t\tNewLine:  9,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(notes, want) {\n\t\tt.Errorf(\"DraftNotes.GetDraftNote want %#v, got %#v\", notes, want)\n\t}\n}\n\nfunc TestCreateDraftNote(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_draft_note.json\")\n\t})\n\n\tnote, _, err := client.DraftNotes.CreateDraftNote(\"1\", 4329, &CreateDraftNoteOptions{\n\t\tNote: Ptr(\"Some new draft note\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &DraftNote{\n\t\tID:                37349980,\n\t\tAuthorID:          10271899,\n\t\tMergeRequestID:    291473309,\n\t\tResolveDiscussion: false,\n\t\tDiscussionID:      \"\",\n\t\tNote:              \"Some new draft note\",\n\t\tCommitID:          \"\",\n\t\tLineCode:          \"\",\n\t\tPosition:          nil,\n\t}\n\n\tif !reflect.DeepEqual(note, want) {\n\t\tt.Errorf(\"DraftNotes.GetDraftNote want %#v, got %#v\", note, want)\n\t}\n}\n\nfunc TestUpdateDraftNote(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/update_draft_note.json\")\n\t})\n\n\tnote, _, err := client.DraftNotes.UpdateDraftNote(\"1\", 4329, 3, &UpdateDraftNoteOptions{\n\t\tNote: Ptr(\"Some changed draft note\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &DraftNote{\n\t\tID:                37349980,\n\t\tAuthorID:          10271899,\n\t\tMergeRequestID:    291473309,\n\t\tResolveDiscussion: false,\n\t\tDiscussionID:      \"\",\n\t\tNote:              \"Some changed draft note\",\n\t\tCommitID:          \"\",\n\t\tLineCode:          \"\",\n\t\tPosition:          nil,\n\t}\n\n\tif !reflect.DeepEqual(note, want) {\n\t\tt.Errorf(\"DraftNotes.UpdateDraftNote want %#v, got %#v\", note, want)\n\t}\n}\n\nfunc TestDeleteDraftNote(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.DraftNotes.DeleteDraftNote(\"1\", 4329, 3)\n\tif err != nil {\n\t\tt.Errorf(\"DraftNotes.DeleteDraftNote returned error: %v\", err)\n\t}\n}\n\nfunc TestPublishDraftNote(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes/3/publish\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t})\n\n\t_, err := client.DraftNotes.PublishDraftNote(\"1\", 4329, 3)\n\tif err != nil {\n\t\tt.Errorf(\"DraftNotes.PublishDraftNote returned error: %v\", err)\n\t}\n}\n\nfunc TestPublishAllDraftNotes(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/draft_notes/bulk_publish\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t})\n\n\t_, err := client.DraftNotes.PublishAllDraftNotes(\"1\", 4329)\n\tif err != nil {\n\t\tt.Errorf(\"DraftNotes.PublishAllDraftNotes returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "environments.go",
          "type": "blob",
          "size": 8.48046875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// EnvironmentsService handles communication with the environment related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/environments.html\ntype EnvironmentsService struct {\n\tclient *Client\n}\n\n// Environment represents a GitLab environment.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/environments.html\ntype Environment struct {\n\tID                  int         `json:\"id\"`\n\tName                string      `json:\"name\"`\n\tSlug                string      `json:\"slug\"`\n\tDescription         string      `json:\"description\"`\n\tState               string      `json:\"state\"`\n\tTier                string      `json:\"tier\"`\n\tExternalURL         string      `json:\"external_url\"`\n\tProject             *Project    `json:\"project\"`\n\tCreatedAt           *time.Time  `json:\"created_at\"`\n\tUpdatedAt           *time.Time  `json:\"updated_at\"`\n\tLastDeployment      *Deployment `json:\"last_deployment\"`\n\tClusterAgent        *Agent      `json:\"cluster_agent\"`\n\tKubernetesNamespace string      `json:\"kubernetes_namespace\"`\n\tFluxResourcePath    string      `json:\"flux_resource_path\"`\n}\n\nfunc (env Environment) String() string {\n\treturn Stringify(env)\n}\n\n// ListEnvironmentsOptions represents the available ListEnvironments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#list-environments\ntype ListEnvironmentsOptions struct {\n\tListOptions\n\tName   *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tSearch *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tStates *string `url:\"states,omitempty\" json:\"states,omitempty\"`\n}\n\n// ListEnvironments gets a list of environments from a project, sorted by name\n// alphabetically.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#list-environments\nfunc (s *EnvironmentsService) ListEnvironments(pid interface{}, opts *ListEnvironmentsOptions, options ...RequestOptionFunc) ([]*Environment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/environments\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar envs []*Environment\n\tresp, err := s.client.Do(req, &envs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn envs, resp, nil\n}\n\n// GetEnvironment gets a specific environment from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#get-a-specific-environment\nfunc (s *EnvironmentsService) GetEnvironment(pid interface{}, environment int, options ...RequestOptionFunc) (*Environment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/environments/%d\", PathEscape(project), environment)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tenv := new(Environment)\n\tresp, err := s.client.Do(req, env)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn env, resp, nil\n}\n\n// CreateEnvironmentOptions represents the available CreateEnvironment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#create-a-new-environment\ntype CreateEnvironmentOptions struct {\n\tName                *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription         *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tExternalURL         *string `url:\"external_url,omitempty\" json:\"external_url,omitempty\"`\n\tTier                *string `url:\"tier,omitempty\" json:\"tier,omitempty\"`\n\tClusterAgentID      *int    `url:\"cluster_agent_id,omitempty\" json:\"cluster_agent_id,omitempty\"`\n\tKubernetesNamespace *string `url:\"kubernetes_namespace,omitempty\" json:\"kubernetes_namespace,omitempty\"`\n\tFluxResourcePath    *string `url:\"flux_resource_path,omitempty\" json:\"flux_resource_path,omitempty\"`\n}\n\n// CreateEnvironment adds an environment to a project. This is an idempotent\n// method and can be called multiple times with the same parameters. Createing\n// an environment that is already a environment does not affect the\n// existing environmentship.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#create-a-new-environment\nfunc (s *EnvironmentsService) CreateEnvironment(pid interface{}, opt *CreateEnvironmentOptions, options ...RequestOptionFunc) (*Environment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/environments\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tenv := new(Environment)\n\tresp, err := s.client.Do(req, env)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn env, resp, nil\n}\n\n// EditEnvironmentOptions represents the available EditEnvironment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#update-an-existing-environment\ntype EditEnvironmentOptions struct {\n\tName                *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription         *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tExternalURL         *string `url:\"external_url,omitempty\" json:\"external_url,omitempty\"`\n\tTier                *string `url:\"tier,omitempty\" json:\"tier,omitempty\"`\n\tClusterAgentID      *int    `url:\"cluster_agent_id,omitempty\" json:\"cluster_agent_id,omitempty\"`\n\tKubernetesNamespace *string `url:\"kubernetes_namespace,omitempty\" json:\"kubernetes_namespace,omitempty\"`\n\tFluxResourcePath    *string `url:\"flux_resource_path,omitempty\" json:\"flux_resource_path,omitempty\"`\n}\n\n// EditEnvironment updates a project team environment to a specified access level..\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#update-an-existing-environment\nfunc (s *EnvironmentsService) EditEnvironment(pid interface{}, environment int, opt *EditEnvironmentOptions, options ...RequestOptionFunc) (*Environment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/environments/%d\", PathEscape(project), environment)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tenv := new(Environment)\n\tresp, err := s.client.Do(req, env)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn env, resp, nil\n}\n\n// DeleteEnvironment removes an environment from a project team.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#delete-an-environment\nfunc (s *EnvironmentsService) DeleteEnvironment(pid interface{}, environment int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/environments/%d\", PathEscape(project), environment)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// StopEnvironmentOptions represents the available StopEnvironment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#stop-an-environment\ntype StopEnvironmentOptions struct {\n\tForce *bool `url:\"force,omitempty\" json:\"force,omitempty\"`\n}\n\n// StopEnvironment stops an environment within a specific project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/environments.html#stop-an-environment\nfunc (s *EnvironmentsService) StopEnvironment(pid interface{}, environmentID int, opt *StopEnvironmentOptions, options ...RequestOptionFunc) (*Environment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/environments/%d/stop\", PathEscape(project), environmentID)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tenv := new(Environment)\n\tresp, err := s.client.Do(req, env)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn env, resp, nil\n}\n"
        },
        {
          "name": "environments_test.go",
          "type": "blob",
          "size": 12.3154296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/environments?name=review%2Ffix-foo&page=1&per_page=10\")\n\t\tfmt.Fprint(w, `[\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"review/fix-foo\",\n\t\t\t\t\"description\": \"test\",\n\t\t\t\t\"slug\": \"review-fix-foo-dfjre3\",\n\t\t\t\t\"external_url\": \"https://review-fix-foo-dfjre3.example.gitlab.com\",\n\t\t\t\t\"state\": \"stopped\",\n\t\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t\t\"updated_at\": \"2013-12-02T10:12:29Z\",\n\t\t\t\t\"cluster_agent\": {\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"name\": \"agent-1\",\n\t\t\t\t\t\"config_project\": {\n\t\t\t\t\t\t\"id\": 20,\n\t\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\t\"name\": \"test\",\n\t\t\t\t\t\t\"name_with_namespace\": \"Administrator / test\",\n\t\t\t\t\t\t\"path\": \"test\",\n\t\t\t\t\t\t\"path_with_namespace\": \"root/test\",\n\t\t\t\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\"\n\t\t\t\t\t},\n\t\t\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t\t\t\"created_by_user_id\": 42\n\t\t\t\t},\n\t\t\t\t\"kubernetes_namespace\": \"flux-system\",\n\t\t\t\t\"flux_resource_path\": \"HelmRelease/flux-system\"\n\t\t\t}\n\t\t]`)\n\t})\n\n\tenvs, _, err := client.Environments.ListEnvironments(1, &ListEnvironmentsOptions{Name: Ptr(\"review/fix-foo\"), ListOptions: ListOptions{Page: 1, PerPage: 10}})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreatedAtWant, _ := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\tupdatedAtWant, _ := time.Parse(timeLayout, \"2013-12-02T10:12:29Z\")\n\twant := []*Environment{{\n\t\tID:          1,\n\t\tName:        \"review/fix-foo\",\n\t\tSlug:        \"review-fix-foo-dfjre3\",\n\t\tDescription: \"test\",\n\t\tExternalURL: \"https://review-fix-foo-dfjre3.example.gitlab.com\",\n\t\tState:       \"stopped\",\n\t\tCreatedAt:   &createdAtWant,\n\t\tUpdatedAt:   &updatedAtWant,\n\t\tClusterAgent: &Agent{\n\t\t\tID:   1,\n\t\t\tName: \"agent-1\",\n\t\t\tConfigProject: ConfigProject{\n\t\t\t\tID:                20,\n\t\t\t\tName:              \"test\",\n\t\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\t\tPath:              \"test\",\n\t\t\t\tPathWithNamespace: \"root/test\",\n\t\t\t\tCreatedAt:         &createdAtWant,\n\t\t\t},\n\t\t\tCreatedAt:       &createdAtWant,\n\t\t\tCreatedByUserID: 42,\n\t\t},\n\t\tKubernetesNamespace: \"flux-system\",\n\t\tFluxResourcePath:    \"HelmRelease/flux-system\",\n\t}}\n\tif !reflect.DeepEqual(want, envs) {\n\t\tt.Errorf(\"Environments.ListEnvironments returned %+v, want %+v\", envs, want)\n\t}\n}\n\nfunc TestGetEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/environments/5949167\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"review/fix-foo\",\n\t\t\t\"description\": \"test\",\n\t\t\t\"slug\": \"review-fix-foo-dfjre3\",\n\t\t\t\"external_url\": \"https://review-fix-foo-dfjre3.example.gitlab.com\",\n\t\t\t\"state\": \"stopped\",\n\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t\"updated_at\": \"2013-12-02T10:12:29Z\",\n\t\t\t\"cluster_agent\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"agent-1\",\n\t\t\t\t\"config_project\": {\n\t\t\t\t\t\"id\": 20,\n\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\"name\": \"test\",\n\t\t\t\t\t\"name_with_namespace\": \"Administrator / test\",\n\t\t\t\t\t\"path\": \"test\",\n\t\t\t\t\t\"path_with_namespace\": \"root/test\",\n\t\t\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\"\n\t\t\t\t},\n\t\t\t\t\"created_at\": \"2013-10-02T10:12:29Z\",\n\t\t\t\t\"created_by_user_id\": 42\n\t\t\t},\n\t\t\t\"kubernetes_namespace\": \"flux-system\",\n\t\t\t\"flux_resource_path\": \"HelmRelease/flux-system\"\n\t\t}`)\n\t})\n\n\tenv, _, err := client.Environments.GetEnvironment(1, 5949167)\n\tif err != nil {\n\t\tt.Errorf(\"Environemtns.GetEnvironment returned error: %v\", err)\n\t}\n\n\tcreatedAtWant, _ := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\tupdatedAtWant, _ := time.Parse(timeLayout, \"2013-12-02T10:12:29Z\")\n\twant := &Environment{\n\t\tID:          1,\n\t\tName:        \"review/fix-foo\",\n\t\tSlug:        \"review-fix-foo-dfjre3\",\n\t\tDescription: \"test\",\n\t\tExternalURL: \"https://review-fix-foo-dfjre3.example.gitlab.com\",\n\t\tState:       \"stopped\",\n\t\tCreatedAt:   &createdAtWant,\n\t\tUpdatedAt:   &updatedAtWant,\n\t\tClusterAgent: &Agent{\n\t\t\tID:   1,\n\t\t\tName: \"agent-1\",\n\t\t\tConfigProject: ConfigProject{\n\t\t\t\tID:                20,\n\t\t\t\tName:              \"test\",\n\t\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\t\tPath:              \"test\",\n\t\t\t\tPathWithNamespace: \"root/test\",\n\t\t\t\tCreatedAt:         &createdAtWant,\n\t\t\t},\n\t\t\tCreatedAt:       &createdAtWant,\n\t\t\tCreatedByUserID: 42,\n\t\t},\n\t\tKubernetesNamespace: \"flux-system\",\n\t\tFluxResourcePath:    \"HelmRelease/flux-system\",\n\t}\n\tif !reflect.DeepEqual(want, env) {\n\t\tt.Errorf(\"Environments.GetEnvironment returned %+v, want %+v\", env, want)\n\t}\n}\n\nfunc TestCreateEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestURL(t, r, \"/api/v4/projects/1/environments\")\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"name\": \"deploy\",\n\t  \"description\": \"test\",\n      \"slug\": \"deploy\",\n      \"external_url\": \"https://deploy.example.gitlab.com\",\n      \"tier\": \"production\",\n      \"cluster_agent\": {\n        \"id\": 1,\n        \"name\": \"agent-1\",\n        \"config_project\": {\n          \"id\": 20,\n          \"description\": \"\",\n          \"name\": \"test\",\n          \"name_with_namespace\": \"Administrator / test\",\n          \"path\": \"test\",\n          \"path_with_namespace\": \"root/test\",\n          \"created_at\": \"2013-10-02T10:12:29Z\"\n        },\n        \"created_at\": \"2013-10-02T10:12:29Z\",\n        \"created_by_user_id\": 42\n      },\n      \"kubernetes_namespace\": \"flux-system\",\n      \"flux_resource_path\": \"HelmRelease/flux-system\"\n    }`)\n\t})\n\n\tenvs, _, err := client.Environments.CreateEnvironment(1, &CreateEnvironmentOptions{\n\t\tName:                Ptr(\"deploy\"),\n\t\tDescription:         Ptr(\"test\"),\n\t\tExternalURL:         Ptr(\"https://deploy.example.gitlab.com\"),\n\t\tTier:                Ptr(\"production\"),\n\t\tClusterAgentID:      Ptr(1),\n\t\tKubernetesNamespace: Ptr(\"flux-system\"),\n\t\tFluxResourcePath:    Ptr(\"HelmRelease/flux-system\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreatedAtWant, _ := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\twant := &Environment{\n\t\tID:          1,\n\t\tName:        \"deploy\",\n\t\tSlug:        \"deploy\",\n\t\tDescription: \"test\",\n\t\tExternalURL: \"https://deploy.example.gitlab.com\",\n\t\tTier:        \"production\",\n\t\tClusterAgent: &Agent{\n\t\t\tID:   1,\n\t\t\tName: \"agent-1\",\n\t\t\tConfigProject: ConfigProject{\n\t\t\t\tID:                20,\n\t\t\t\tName:              \"test\",\n\t\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\t\tPath:              \"test\",\n\t\t\t\tPathWithNamespace: \"root/test\",\n\t\t\t\tCreatedAt:         &createdAtWant,\n\t\t\t},\n\t\t\tCreatedAt:       &createdAtWant,\n\t\t\tCreatedByUserID: 42,\n\t\t},\n\t\tKubernetesNamespace: \"flux-system\",\n\t\tFluxResourcePath:    \"HelmRelease/flux-system\",\n\t}\n\tif !reflect.DeepEqual(want, envs) {\n\t\tt.Errorf(\"Environments.CreateEnvironment returned %+v, want %+v\", envs, want)\n\t}\n}\n\nfunc TestEditEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/environments/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\ttestURL(t, r, \"/api/v4/projects/1/environments/1\")\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"name\": \"staging\",\n\t  \"description\": \"test\",\n      \"slug\": \"staging\",\n      \"external_url\": \"https://staging.example.gitlab.com\",\n      \"tier\": \"staging\",\n      \"cluster_agent\": {\n        \"id\": 1,\n        \"name\": \"agent-1\",\n        \"config_project\": {\n          \"id\": 20,\n          \"description\": \"\",\n          \"name\": \"test\",\n          \"name_with_namespace\": \"Administrator / test\",\n          \"path\": \"test\",\n          \"path_with_namespace\": \"root/test\",\n          \"created_at\": \"2013-10-02T10:12:29Z\"\n        },\n        \"created_at\": \"2013-10-02T10:12:29Z\",\n        \"created_by_user_id\": 42\n    },\n\t  \"kubernetes_namespace\": \"flux-system\",\n\t  \"flux_resource_path\": \"HelmRelease/flux-system\"\n    }`)\n\t})\n\n\tenvs, _, err := client.Environments.EditEnvironment(1, 1, &EditEnvironmentOptions{\n\t\tName:                Ptr(\"staging\"),\n\t\tDescription:         Ptr(\"test\"),\n\t\tExternalURL:         Ptr(\"https://staging.example.gitlab.com\"),\n\t\tTier:                Ptr(\"staging\"),\n\t\tClusterAgentID:      Ptr(1),\n\t\tKubernetesNamespace: Ptr(\"flux-system\"),\n\t\tFluxResourcePath:    Ptr(\"HelmRelease/flux-system\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreatedAtWant, _ := time.Parse(timeLayout, \"2013-10-02T10:12:29Z\")\n\twant := &Environment{\n\t\tID:          1,\n\t\tName:        \"staging\",\n\t\tSlug:        \"staging\",\n\t\tDescription: \"test\",\n\t\tExternalURL: \"https://staging.example.gitlab.com\",\n\t\tTier:        \"staging\",\n\t\tClusterAgent: &Agent{\n\t\t\tID:   1,\n\t\t\tName: \"agent-1\",\n\t\t\tConfigProject: ConfigProject{\n\t\t\t\tID:                20,\n\t\t\t\tName:              \"test\",\n\t\t\t\tNameWithNamespace: \"Administrator / test\",\n\t\t\t\tPath:              \"test\",\n\t\t\t\tPathWithNamespace: \"root/test\",\n\t\t\t\tCreatedAt:         &createdAtWant,\n\t\t\t},\n\t\t\tCreatedAt:       &createdAtWant,\n\t\t\tCreatedByUserID: 42,\n\t\t},\n\t\tKubernetesNamespace: \"flux-system\",\n\t\tFluxResourcePath:    \"HelmRelease/flux-system\",\n\t}\n\tif !reflect.DeepEqual(want, envs) {\n\t\tt.Errorf(\"Environments.EditEnvironment returned %+v, want %+v\", envs, want)\n\t}\n}\n\nfunc TestDeleteEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/environments/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\ttestURL(t, r, \"/api/v4/projects/1/environments/1\")\n\t})\n\t_, err := client.Environments.DeleteEnvironment(1, 1)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestStopEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/environments/1/stop\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestURL(t, r, \"/api/v4/projects/1/environments/1/stop\")\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"name\": \"staging\",\n      \"state\": \"stopping\",\n      \"slug\": \"staging\",\n      \"external_url\": \"https://staging.example.gitlab.com\",\n      \"tier\": \"staging\"\n    }`)\n\t})\n\t_, _, err := client.Environments.StopEnvironment(1, 1, &StopEnvironmentOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestUnmarshal(t *testing.T) {\n\tjsonObject := `\n    {\n        \"id\": 10,\n        \"name\": \"production\",\n\t\t\"description\": \"test\",\n        \"slug\": \"production\",\n        \"external_url\": \"https://example.com\",\n        \"project\": {\n            \"id\": 1,\n            \"description\": \"\",\n            \"name\": \"Awesome Project\",\n            \"name_with_namespace\": \"FooBar Group / Awesome Project\",\n            \"path\": \"awesome-project\",\n            \"path_with_namespace\": \"foobar-group/awesome-project\",\n            \"created_at\": \"2017-09-30T11:10:08.476-04:00\",\n            \"default_branch\": \"develop\",\n            \"tag_list\": [],\n            \"ssh_url_to_repo\": \"git@example.gitlab.com:foobar-group/api.git\",\n            \"http_url_to_repo\": \"https://example.gitlab.com/foobar-group/api.git\",\n            \"web_url\": \"https://example.gitlab.com/foobar-group/api\",\n            \"readme_url\": null,\n            \"avatar_url\": null,\n            \"star_count\": 0,\n            \"forks_count\": 1,\n            \"last_activity_at\": \"2019-11-03T22:22:46.564-05:00\",\n            \"namespace\": {\n                \"id\": 15,\n                \"name\": \"FooBar Group\",\n                \"path\": \"foobar-group\",\n                \"kind\": \"group\",\n                \"full_path\": \"foobar-group\",\n                \"parent_id\": null,\n                \"avatar_url\": null,\n                \"web_url\": \"https://example.gitlab.com/groups/foobar-group\"\n            }\n        },\n        \"state\": \"available\"\n    }`\n\n\tvar env Environment\n\terr := json.Unmarshal([]byte(jsonObject), &env)\n\n\tif assert.NoError(t, err) {\n\t\tassert.Equal(t, 10, env.ID)\n\t\tassert.Equal(t, \"production\", env.Name)\n\t\tassert.Equal(t, \"test\", env.Description)\n\t\tassert.Equal(t, \"https://example.com\", env.ExternalURL)\n\t\tassert.Equal(t, \"available\", env.State)\n\t\tif assert.NotNil(t, env.Project) {\n\t\t\tassert.Equal(t, \"Awesome Project\", env.Project.Name)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "epic_issues.go",
          "type": "blob",
          "size": 4.380859375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// EpicIssuesService handles communication with the epic issue related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epic_issues.html\ntype EpicIssuesService struct {\n\tclient *Client\n}\n\n// EpicIssueAssignment contains both the epic and issue objects returned from\n// Gitlab with the assignment ID.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epic_issues.html\ntype EpicIssueAssignment struct {\n\tID    int    `json:\"id\"`\n\tEpic  *Epic  `json:\"epic\"`\n\tIssue *Issue `json:\"issue\"`\n}\n\n// ListEpicIssues get a list of epic issues.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/epic_issues.html#list-issues-for-an-epic\nfunc (s *EpicIssuesService) ListEpicIssues(gid interface{}, epic int, opt *ListOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/issues\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar is []*Issue\n\tresp, err := s.client.Do(req, &is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// AssignEpicIssue assigns an existing issue to an epic.\n//\n// Gitlab API Docs:\n// https://docs.gitlab.com/ee/api/epic_issues.html#assign-an-issue-to-the-epic\nfunc (s *EpicIssuesService) AssignEpicIssue(gid interface{}, epic, issue int, options ...RequestOptionFunc) (*EpicIssueAssignment, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/issues/%d\", PathEscape(group), epic, issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(EpicIssueAssignment)\n\tresp, err := s.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// RemoveEpicIssue removes an issue from an epic.\n//\n// Gitlab API Docs:\n// https://docs.gitlab.com/ee/api/epic_issues.html#remove-an-issue-from-the-epic\nfunc (s *EpicIssuesService) RemoveEpicIssue(gid interface{}, epic, epicIssue int, options ...RequestOptionFunc) (*EpicIssueAssignment, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/issues/%d\", PathEscape(group), epic, epicIssue)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(EpicIssueAssignment)\n\tresp, err := s.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// UpdateEpicIsssueAssignmentOptions describes the UpdateEpicIssueAssignment()\n// options.\n//\n// Gitlab API Docs:\n// https://docs.gitlab.com/ee/api/epic_issues.html#update-epic---issue-association\ntype UpdateEpicIsssueAssignmentOptions struct {\n\t*ListOptions\n\tMoveBeforeID *int `url:\"move_before_id,omitempty\" json:\"move_before_id,omitempty\"`\n\tMoveAfterID  *int `url:\"move_after_id,omitempty\" json:\"move_after_id,omitempty\"`\n}\n\n// UpdateEpicIssueAssignment moves an issue before or after another issue in an\n// epic issue list.\n//\n// Gitlab API Docs:\n// https://docs.gitlab.com/ee/api/epic_issues.html#update-epic---issue-association\nfunc (s *EpicIssuesService) UpdateEpicIssueAssignment(gid interface{}, epic, epicIssue int, opt *UpdateEpicIsssueAssignmentOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/issues/%d\", PathEscape(group), epic, epicIssue)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar is []*Issue\n\tresp, err := s.client.Do(req, &is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n"
        },
        {
          "name": "epic_issues_test.go",
          "type": "blob",
          "size": 22.029296875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestEpicIssuesService_ListEpicIssues(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/5/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 76,\n\t\t\t\t\"iid\": 6,\n\t\t\t\t\"project_id\": 8,\n\t\t\t\t\"title\" : \"Consequatur vero maxime deserunt laboriosam est voluptas dolorem.\",\n\t\t\t\t\"description\" : \"Ratione dolores corrupti mollitia soluta quia.\",\n\t\t\t\t\"state\": \"opened\",\n\t\t\t\t\"closed_at\": null,\n\t\t\t\t\"labels\": [],\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 38,\n\t\t\t\t  \"iid\": 3,\n\t\t\t\t  \"project_id\": 8,\n\t\t\t\t  \"title\": \"v2.0\",\n\t\t\t\t  \"description\": \"In tempore culpa inventore quo accusantium.\",\n\t\t\t\t  \"state\": \"closed\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"id\": 7,\n\t\t\t\t  \"name\": \"Pamella Huel\",\n\t\t\t\t  \"username\": \"arnita\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/arnita\"\n\t\t\t\t}],\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 7,\n\t\t\t\t  \"name\": \"Pamella Huel\",\n\t\t\t\t  \"username\": \"arnita\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/arnita\"\n\t\t\t\t},\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 13,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/30e3b2122ccd6b8e45e8e14a3ffb58fc?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/venky333\"\n\t\t\t\t},\n\t\t\t\t\"user_notes_count\": 8,\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"web_url\": \"http://localhost:3001/h5bp/html5-boilerplate/issues/6\",\n\t\t\t\t\"time_stats\": {\n\t\t\t\t  \"time_estimate\": 0,\n\t\t\t\t  \"total_time_spent\": 0,\n\t\t\t\t  \"human_time_estimate\": null,\n\t\t\t\t  \"human_total_time_spent\": null\n\t\t\t\t},\n\t\t\t\t\"_links\":{\n\t\t\t\t  \"self\": \"http://localhost:3001/api/v4/projects/8/issues/6\",\n\t\t\t\t  \"notes\": \"http://localhost:3001/api/v4/projects/8/issues/6/notes\",\n\t\t\t\t  \"award_emoji\": \"http://localhost:3001/api/v4/projects/8/issues/6/award_emoji\",\n\t\t\t\t  \"project\": \"http://localhost:3001/api/v4/projects/8\"\n\t\t\t\t},\n\t\t\t\t\"epic_issue_id\": 2\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Issue{{\n\t\tID:          76,\n\t\tIID:         6,\n\t\tExternalID:  \"\",\n\t\tState:       \"opened\",\n\t\tDescription: \"Ratione dolores corrupti mollitia soluta quia.\",\n\t\tAuthor: &IssueAuthor{\n\t\t\tID:        13,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"http://localhost:3001/venky333\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/30e3b2122ccd6b8e45e8e14a3ffb58fc?s=80&d=identicon\",\n\t\t\tUsername:  \"venky333\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          38,\n\t\t\tIID:         3,\n\t\t\tProjectID:   8,\n\t\t\tTitle:       \"v2.0\",\n\t\t\tDescription: \"In tempore culpa inventore quo accusantium.\",\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"\",\n\t\t},\n\t\tProjectID: 8,\n\t\tAssignees: []*IssueAssignee{{\n\t\t\tID:        7,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"http://localhost:3001/arnita\",\n\t\t\tName:      \"Pamella Huel\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\tUsername:  \"arnita\",\n\t\t}},\n\t\tAssignee: &IssueAssignee{\n\t\t\tID:        7,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"http://localhost:3001/arnita\",\n\t\t\tName:      \"Pamella Huel\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\tUsername:  \"arnita\",\n\t\t},\n\t\tClosedBy:     nil,\n\t\tTitle:        \"Consequatur vero maxime deserunt laboriosam est voluptas dolorem.\",\n\t\tCreatedAt:    nil,\n\t\tMovedToID:    0,\n\t\tLabels:       Labels{},\n\t\tLabelDetails: nil,\n\t\tUpvotes:      0,\n\t\tDownvotes:    0,\n\t\tDueDate:      nil,\n\t\tWebURL:       \"http://localhost:3001/h5bp/html5-boilerplate/issues/6\",\n\t\tReferences:   nil,\n\t\tTimeStats: &TimeStats{\n\t\t\tHumanTimeEstimate:   \"\",\n\t\t\tHumanTotalTimeSpent: \"\",\n\t\t\tTimeEstimate:        0,\n\t\t\tTotalTimeSpent:      0,\n\t\t},\n\t\tConfidential:     false,\n\t\tWeight:           0,\n\t\tDiscussionLocked: false,\n\t\tIssueType:        nil,\n\t\tSubscribed:       false,\n\t\tUserNotesCount:   8,\n\t\tLinks: &IssueLinks{\n\t\t\tSelf:       \"http://localhost:3001/api/v4/projects/8/issues/6\",\n\t\t\tNotes:      \"http://localhost:3001/api/v4/projects/8/issues/6/notes\",\n\t\t\tAwardEmoji: \"http://localhost:3001/api/v4/projects/8/issues/6/award_emoji\",\n\t\t\tProject:    \"http://localhost:3001/api/v4/projects/8\",\n\t\t},\n\t\tIssueLinkID:          0,\n\t\tMergeRequestCount:    0,\n\t\tEpicIssueID:          2,\n\t\tEpic:                 nil,\n\t\tTaskCompletionStatus: nil,\n\t}}\n\n\tis, resp, err := client.EpicIssues.ListEpicIssues(1, 5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, is)\n\n\tis, resp, err = client.EpicIssues.ListEpicIssues(1.01, 5, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.EpicIssues.ListEpicIssues(1, 5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.EpicIssues.ListEpicIssues(3, 5, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, is)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestEpicIssuesService_AssignEpicIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/5/issues/55\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 11,\n\t\t\t  \"epic\": {\n\t\t\t\t\"id\": 30,\n\t\t\t\t\"iid\": 5,\n\t\t\t\t\"title\": \"Ea cupiditate dolores ut vero consequatur quasi veniam voluptatem et non.\",\n\t\t\t\t\"description\": \"Molestias dolorem eos vitae expedita impedit necessitatibus quo voluptatum.\",\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 7,\n\t\t\t\t  \"name\": \"Pamella Huel\",\n\t\t\t\t  \"username\": \"arnita\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/arnita\"\n\t\t\t\t}\n\t\t\t  },\n\t\t\t  \"issue\": {\n\t\t\t\t\"id\": 55,\n\t\t\t\t\"iid\": 13,\n\t\t\t\t\"project_id\": 8,\n\t\t\t\t\"title\": \"Beatae laborum voluptatem voluptate eligendi ex accusamus.\",\n\t\t\t\t\"description\": \"Quam veritatis debitis omnis aliquam sit.\",\n\t\t\t\t\"state\": \"opened\",\n\t\t\t\t\"labels\": [],\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 48,\n\t\t\t\t  \"iid\": 6,\n\t\t\t\t  \"project_id\": 8,\n\t\t\t\t  \"title\": \"Sprint - Sed sed maxime temporibus ipsa ullam qui sit.\",\n\t\t\t\t  \"description\": \"Quos veritatis qui expedita sunt deleniti accusamus.\",\n\t\t\t\t  \"state\": \"active\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"id\": 10,\n\t\t\t\t  \"name\": \"Lu Mayer\",\n\t\t\t\t  \"username\": \"kam\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/kam\"\n\t\t\t\t}],\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 10,\n\t\t\t\t  \"name\": \"Lu Mayer\",\n\t\t\t\t  \"username\": \"kam\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/kam\"\n\t\t\t\t},\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 25,\n\t\t\t\t  \"name\": \"User 3\",\n\t\t\t\t  \"username\": \"user3\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/97d6d9441ff85fdc730e02a6068d267b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/user3\"\n\t\t\t\t},\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"web_url\": \"http://localhost:3001/h5bp/html5-boilerplate/issues/13\",\n\t\t\t\t\"time_stats\": {\n\t\t\t\t  \"time_estimate\": 0,\n\t\t\t\t  \"total_time_spent\": 0,\n\t\t\t\t  \"human_time_estimate\": null,\n\t\t\t\t  \"human_total_time_spent\": null\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &EpicIssueAssignment{\n\t\tID: 11,\n\t\tEpic: &Epic{\n\t\t\tID:          30,\n\t\t\tIID:         5,\n\t\t\tGroupID:     0,\n\t\t\tParentID:    0,\n\t\t\tTitle:       \"Ea cupiditate dolores ut vero consequatur quasi veniam voluptatem et non.\",\n\t\t\tDescription: \"Molestias dolorem eos vitae expedita impedit necessitatibus quo voluptatum.\",\n\t\t\tState:       \"\",\n\t\t\tWebURL:      \"\",\n\t\t\tAuthor: &EpicAuthor{\n\t\t\t\tID:        7,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"http://localhost:3001/arnita\",\n\t\t\t\tName:      \"Pamella Huel\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\tUsername:  \"arnita\",\n\t\t\t},\n\t\t\tStartDateIsFixed: false,\n\t\t\tDueDateIsFixed:   false,\n\t\t\tUpvotes:          0, Downvotes: 0,\n\t\t\tUserNotesCount: 0,\n\t\t\tURL:            \"\",\n\t\t},\n\t\tIssue: &Issue{\n\t\t\tID:          55,\n\t\t\tIID:         13,\n\t\t\tExternalID:  \"\",\n\t\t\tState:       \"opened\",\n\t\t\tDescription: \"Quam veritatis debitis omnis aliquam sit.\",\n\t\t\tAuthor: &IssueAuthor{\n\t\t\t\tID:        25,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"http://localhost:3001/user3\",\n\t\t\t\tName:      \"User 3\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/97d6d9441ff85fdc730e02a6068d267b?s=80&d=identicon\",\n\t\t\t\tUsername:  \"user3\",\n\t\t\t},\n\t\t\tMilestone: &Milestone{\n\t\t\t\tID:          48,\n\t\t\t\tIID:         6,\n\t\t\t\tProjectID:   8,\n\t\t\t\tTitle:       \"Sprint - Sed sed maxime temporibus ipsa ullam qui sit.\",\n\t\t\t\tDescription: \"Quos veritatis qui expedita sunt deleniti accusamus.\",\n\t\t\t\tState:       \"active\",\n\t\t\t\tWebURL:      \"\",\n\t\t\t},\n\t\t\tProjectID: 8,\n\t\t\tAssignees: []*IssueAssignee{\n\t\t\t\t{\n\t\t\t\t\tID:        10,\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tWebURL:    \"http://localhost:3001/kam\",\n\t\t\t\t\tName:      \"Lu Mayer\",\n\t\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\t\tUsername:  \"kam\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAssignee: &IssueAssignee{\n\t\t\t\tID:        10,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"http://localhost:3001/kam\",\n\t\t\t\tName:      \"Lu Mayer\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\tUsername:  \"kam\",\n\t\t\t},\n\t\t\tTitle:     \"Beatae laborum voluptatem voluptate eligendi ex accusamus.\",\n\t\t\tMovedToID: 0,\n\t\t\tLabels:    Labels{},\n\t\t\tUpvotes:   0,\n\t\t\tDownvotes: 0,\n\t\t\tWebURL:    \"http://localhost:3001/h5bp/html5-boilerplate/issues/13\",\n\t\t\tTimeStats: &TimeStats{\n\t\t\t\tHumanTimeEstimate:   \"\",\n\t\t\t\tHumanTotalTimeSpent: \"\",\n\t\t\t\tTimeEstimate:        0,\n\t\t\t\tTotalTimeSpent:      0,\n\t\t\t},\n\t\t\tConfidential:      false,\n\t\t\tWeight:            0,\n\t\t\tDiscussionLocked:  false,\n\t\t\tSubscribed:        false,\n\t\t\tUserNotesCount:    0,\n\t\t\tIssueLinkID:       0,\n\t\t\tMergeRequestCount: 0,\n\t\t\tEpicIssueID:       0,\n\t\t},\n\t}\n\n\teia, resp, err := client.EpicIssues.AssignEpicIssue(1, 5, 55, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, eia)\n\n\teia, resp, err = client.EpicIssues.AssignEpicIssue(1.01, 5, 55, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, eia)\n\n\teia, resp, err = client.EpicIssues.AssignEpicIssue(1, 5, 55, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, eia)\n\n\teia, resp, err = client.EpicIssues.AssignEpicIssue(3, 5, 55, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, eia)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestEpicIssuesService_RemoveEpicIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/5/issues/55\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 11,\n\t\t\t  \"epic\": {\n\t\t\t\t\"id\": 30,\n\t\t\t\t\"iid\": 5,\n\t\t\t\t\"title\": \"Ea cupiditate dolores ut vero consequatur quasi veniam voluptatem et non.\",\n\t\t\t\t\"description\": \"Molestias dolorem eos vitae expedita impedit necessitatibus quo voluptatum.\",\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 7,\n\t\t\t\t  \"name\": \"Pamella Huel\",\n\t\t\t\t  \"username\": \"arnita\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/arnita\"\n\t\t\t\t}\n\t\t\t  },\n\t\t\t  \"issue\": {\n\t\t\t\t\"id\": 55,\n\t\t\t\t\"iid\": 13,\n\t\t\t\t\"project_id\": 8,\n\t\t\t\t\"title\": \"Beatae laborum voluptatem voluptate eligendi ex accusamus.\",\n\t\t\t\t\"description\": \"Quam veritatis debitis omnis aliquam sit.\",\n\t\t\t\t\"state\": \"opened\",\n\t\t\t\t\"labels\": [],\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 48,\n\t\t\t\t  \"iid\": 6,\n\t\t\t\t  \"project_id\": 8,\n\t\t\t\t  \"title\": \"Sprint - Sed sed maxime temporibus ipsa ullam qui sit.\",\n\t\t\t\t  \"description\": \"Quos veritatis qui expedita sunt deleniti accusamus.\",\n\t\t\t\t  \"state\": \"active\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"id\": 10,\n\t\t\t\t  \"name\": \"Lu Mayer\",\n\t\t\t\t  \"username\": \"kam\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/kam\"\n\t\t\t\t}],\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 10,\n\t\t\t\t  \"name\": \"Lu Mayer\",\n\t\t\t\t  \"username\": \"kam\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/kam\"\n\t\t\t\t},\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 25,\n\t\t\t\t  \"name\": \"User 3\",\n\t\t\t\t  \"username\": \"user3\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/97d6d9441ff85fdc730e02a6068d267b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/user3\"\n\t\t\t\t},\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"web_url\": \"http://localhost:3001/h5bp/html5-boilerplate/issues/13\",\n\t\t\t\t\"time_stats\": {\n\t\t\t\t  \"time_estimate\": 0,\n\t\t\t\t  \"total_time_spent\": 0,\n\t\t\t\t  \"human_time_estimate\": null,\n\t\t\t\t  \"human_total_time_spent\": null\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &EpicIssueAssignment{\n\t\tID: 11,\n\t\tEpic: &Epic{\n\t\t\tID:          30,\n\t\t\tIID:         5,\n\t\t\tGroupID:     0,\n\t\t\tParentID:    0,\n\t\t\tTitle:       \"Ea cupiditate dolores ut vero consequatur quasi veniam voluptatem et non.\",\n\t\t\tDescription: \"Molestias dolorem eos vitae expedita impedit necessitatibus quo voluptatum.\",\n\t\t\tState:       \"\",\n\t\t\tWebURL:      \"\",\n\t\t\tAuthor: &EpicAuthor{\n\t\t\t\tID:        7,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"http://localhost:3001/arnita\",\n\t\t\t\tName:      \"Pamella Huel\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\tUsername:  \"arnita\",\n\t\t\t},\n\t\t\tStartDateIsFixed: false,\n\t\t\tDueDateIsFixed:   false,\n\t\t\tUpvotes:          0, Downvotes: 0,\n\t\t\tUserNotesCount: 0,\n\t\t\tURL:            \"\",\n\t\t},\n\t\tIssue: &Issue{\n\t\t\tID:          55,\n\t\t\tIID:         13,\n\t\t\tExternalID:  \"\",\n\t\t\tState:       \"opened\",\n\t\t\tDescription: \"Quam veritatis debitis omnis aliquam sit.\",\n\t\t\tAuthor: &IssueAuthor{\n\t\t\t\tID:        25,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"http://localhost:3001/user3\",\n\t\t\t\tName:      \"User 3\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/97d6d9441ff85fdc730e02a6068d267b?s=80&d=identicon\",\n\t\t\t\tUsername:  \"user3\",\n\t\t\t},\n\t\t\tMilestone: &Milestone{\n\t\t\t\tID:          48,\n\t\t\t\tIID:         6,\n\t\t\t\tProjectID:   8,\n\t\t\t\tTitle:       \"Sprint - Sed sed maxime temporibus ipsa ullam qui sit.\",\n\t\t\t\tDescription: \"Quos veritatis qui expedita sunt deleniti accusamus.\",\n\t\t\t\tState:       \"active\",\n\t\t\t\tWebURL:      \"\",\n\t\t\t},\n\t\t\tProjectID: 8,\n\t\t\tAssignees: []*IssueAssignee{\n\t\t\t\t{\n\t\t\t\t\tID:        10,\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tWebURL:    \"http://localhost:3001/kam\",\n\t\t\t\t\tName:      \"Lu Mayer\",\n\t\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\t\tUsername:  \"kam\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAssignee: &IssueAssignee{\n\t\t\t\tID:        10,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"http://localhost:3001/kam\",\n\t\t\t\tName:      \"Lu Mayer\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/018729e129a6f31c80a6327a30196823?s=80&d=identicon\",\n\t\t\t\tUsername:  \"kam\",\n\t\t\t},\n\t\t\tTitle:     \"Beatae laborum voluptatem voluptate eligendi ex accusamus.\",\n\t\t\tMovedToID: 0,\n\t\t\tLabels:    Labels{},\n\t\t\tUpvotes:   0,\n\t\t\tDownvotes: 0,\n\t\t\tWebURL:    \"http://localhost:3001/h5bp/html5-boilerplate/issues/13\",\n\t\t\tTimeStats: &TimeStats{\n\t\t\t\tHumanTimeEstimate:   \"\",\n\t\t\t\tHumanTotalTimeSpent: \"\",\n\t\t\t\tTimeEstimate:        0,\n\t\t\t\tTotalTimeSpent:      0,\n\t\t\t},\n\t\t\tConfidential:      false,\n\t\t\tWeight:            0,\n\t\t\tDiscussionLocked:  false,\n\t\t\tSubscribed:        false,\n\t\t\tUserNotesCount:    0,\n\t\t\tIssueLinkID:       0,\n\t\t\tMergeRequestCount: 0,\n\t\t\tEpicIssueID:       0,\n\t\t},\n\t}\n\n\teia, resp, err := client.EpicIssues.RemoveEpicIssue(1, 5, 55, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, eia)\n\n\teia, resp, err = client.EpicIssues.RemoveEpicIssue(1.01, 5, 55, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, eia)\n\n\teia, resp, err = client.EpicIssues.RemoveEpicIssue(1, 5, 55, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, eia)\n\n\teia, resp, err = client.EpicIssues.RemoveEpicIssue(3, 5, 55, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, eia)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestEpicIssuesService_UpdateEpicIssueAssignment(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/5/issues/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 76,\n\t\t\t\t\"iid\": 6,\n\t\t\t\t\"project_id\": 8,\n\t\t\t\t\"title\" : \"Consequatur vero maxime deserunt laboriosam est voluptas dolorem.\",\n\t\t\t\t\"description\" : \"Ratione dolores corrupti mollitia soluta quia.\",\n\t\t\t\t\"state\": \"opened\",\n\t\t\t\t\"closed_at\": null,\n\t\t\t\t\"labels\": [],\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 38,\n\t\t\t\t  \"iid\": 3,\n\t\t\t\t  \"project_id\": 8,\n\t\t\t\t  \"title\": \"v2.0\",\n\t\t\t\t  \"description\": \"In tempore culpa inventore quo accusantium.\",\n\t\t\t\t  \"state\": \"closed\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"id\": 7,\n\t\t\t\t  \"name\": \"Pamella Huel\",\n\t\t\t\t  \"username\": \"arnita\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/arnita\"\n\t\t\t\t}],\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 7,\n\t\t\t\t  \"name\": \"Pamella Huel\",\n\t\t\t\t  \"username\": \"arnita\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/arnita\"\n\t\t\t\t},\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 13,\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/30e3b2122ccd6b8e45e8e14a3ffb58fc?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://localhost:3001/venky333\"\n\t\t\t\t},\n\t\t\t\t\"user_notes_count\": 8,\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"web_url\": \"http://localhost:3001/h5bp/html5-boilerplate/issues/6\",\n\t\t\t\t\"time_stats\": {\n\t\t\t\t  \"time_estimate\": 0,\n\t\t\t\t  \"total_time_spent\": 0,\n\t\t\t\t  \"human_time_estimate\": null,\n\t\t\t\t  \"human_total_time_spent\": null\n\t\t\t\t},\n\t\t\t\t\"_links\":{\n\t\t\t\t  \"self\": \"http://localhost:3001/api/v4/projects/8/issues/6\",\n\t\t\t\t  \"notes\": \"http://localhost:3001/api/v4/projects/8/issues/6/notes\",\n\t\t\t\t  \"award_emoji\": \"http://localhost:3001/api/v4/projects/8/issues/6/award_emoji\",\n\t\t\t\t  \"project\": \"http://localhost:3001/api/v4/projects/8\"\n\t\t\t\t},\n\t\t\t\t\"epic_issue_id\": 2\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Issue{{\n\t\tID:          76,\n\t\tIID:         6,\n\t\tExternalID:  \"\",\n\t\tState:       \"opened\",\n\t\tDescription: \"Ratione dolores corrupti mollitia soluta quia.\",\n\t\tAuthor: &IssueAuthor{\n\t\t\tID:        13,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"http://localhost:3001/venky333\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/30e3b2122ccd6b8e45e8e14a3ffb58fc?s=80&d=identicon\",\n\t\t\tUsername:  \"venky333\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          38,\n\t\t\tIID:         3,\n\t\t\tProjectID:   8,\n\t\t\tTitle:       \"v2.0\",\n\t\t\tDescription: \"In tempore culpa inventore quo accusantium.\",\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"\",\n\t\t},\n\t\tProjectID: 8,\n\t\tAssignees: []*IssueAssignee{{\n\t\t\tID:        7,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"http://localhost:3001/arnita\",\n\t\t\tName:      \"Pamella Huel\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\tUsername:  \"arnita\",\n\t\t}},\n\t\tAssignee: &IssueAssignee{\n\t\t\tID:        7,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"http://localhost:3001/arnita\",\n\t\t\tName:      \"Pamella Huel\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/a2f5c6fcef64c9c69cb8779cb292be1b?s=80&d=identicon\",\n\t\t\tUsername:  \"arnita\",\n\t\t},\n\t\tClosedBy:     nil,\n\t\tTitle:        \"Consequatur vero maxime deserunt laboriosam est voluptas dolorem.\",\n\t\tCreatedAt:    nil,\n\t\tMovedToID:    0,\n\t\tLabels:       Labels{},\n\t\tLabelDetails: nil,\n\t\tUpvotes:      0,\n\t\tDownvotes:    0,\n\t\tDueDate:      nil,\n\t\tWebURL:       \"http://localhost:3001/h5bp/html5-boilerplate/issues/6\",\n\t\tReferences:   nil,\n\t\tTimeStats: &TimeStats{\n\t\t\tHumanTimeEstimate:   \"\",\n\t\t\tHumanTotalTimeSpent: \"\",\n\t\t\tTimeEstimate:        0,\n\t\t\tTotalTimeSpent:      0,\n\t\t},\n\t\tConfidential:     false,\n\t\tWeight:           0,\n\t\tDiscussionLocked: false,\n\t\tIssueType:        nil,\n\t\tSubscribed:       false,\n\t\tUserNotesCount:   8,\n\t\tLinks: &IssueLinks{\n\t\t\tSelf:       \"http://localhost:3001/api/v4/projects/8/issues/6\",\n\t\t\tNotes:      \"http://localhost:3001/api/v4/projects/8/issues/6/notes\",\n\t\t\tAwardEmoji: \"http://localhost:3001/api/v4/projects/8/issues/6/award_emoji\",\n\t\t\tProject:    \"http://localhost:3001/api/v4/projects/8\",\n\t\t},\n\t\tIssueLinkID:          0,\n\t\tMergeRequestCount:    0,\n\t\tEpicIssueID:          2,\n\t\tEpic:                 nil,\n\t\tTaskCompletionStatus: nil,\n\t}}\n\n\tis, resp, err := client.EpicIssues.UpdateEpicIssueAssignment(1, 5, 2, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, is)\n\n\tis, resp, err = client.EpicIssues.UpdateEpicIssueAssignment(1.01, 5, 2, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.EpicIssues.UpdateEpicIssueAssignment(1, 5, 2, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.EpicIssues.UpdateEpicIssueAssignment(3, 5, 2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, is)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "epics.go",
          "type": "blob",
          "size": 10.5966796875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// EpicsService handles communication with the epic related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html\ntype EpicsService struct {\n\tclient *Client\n}\n\n// EpicAuthor represents a author of the epic.\ntype EpicAuthor struct {\n\tID        int    `json:\"id\"`\n\tState     string `json:\"state\"`\n\tWebURL    string `json:\"web_url\"`\n\tName      string `json:\"name\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tUsername  string `json:\"username\"`\n}\n\n// Epic represents a GitLab epic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html\ntype Epic struct {\n\tID                      int         `json:\"id\"`\n\tIID                     int         `json:\"iid\"`\n\tGroupID                 int         `json:\"group_id\"`\n\tParentID                int         `json:\"parent_id\"`\n\tTitle                   string      `json:\"title\"`\n\tDescription             string      `json:\"description\"`\n\tState                   string      `json:\"state\"`\n\tConfidential            bool        `json:\"confidential\"`\n\tWebURL                  string      `json:\"web_url\"`\n\tAuthor                  *EpicAuthor `json:\"author\"`\n\tStartDate               *ISOTime    `json:\"start_date\"`\n\tStartDateIsFixed        bool        `json:\"start_date_is_fixed\"`\n\tStartDateFixed          *ISOTime    `json:\"start_date_fixed\"`\n\tStartDateFromMilestones *ISOTime    `json:\"start_date_from_milestones\"`\n\tDueDate                 *ISOTime    `json:\"due_date\"`\n\tDueDateIsFixed          bool        `json:\"due_date_is_fixed\"`\n\tDueDateFixed            *ISOTime    `json:\"due_date_fixed\"`\n\tDueDateFromMilestones   *ISOTime    `json:\"due_date_from_milestones\"`\n\tCreatedAt               *time.Time  `json:\"created_at\"`\n\tUpdatedAt               *time.Time  `json:\"updated_at\"`\n\tClosedAt                *time.Time  `json:\"closed_at\"`\n\tLabels                  []string    `json:\"labels\"`\n\tUpvotes                 int         `json:\"upvotes\"`\n\tDownvotes               int         `json:\"downvotes\"`\n\tUserNotesCount          int         `json:\"user_notes_count\"`\n\tURL                     string      `json:\"url\"`\n}\n\nfunc (e Epic) String() string {\n\treturn Stringify(e)\n}\n\n// ListGroupEpicsOptions represents the available ListGroupEpics() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#list-epics-for-a-group\ntype ListGroupEpicsOptions struct {\n\tListOptions\n\tAuthorID                *int          `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tLabels                  *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tWithLabelDetails        *bool         `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tOrderBy                 *string       `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                    *string       `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tSearch                  *string       `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tState                   *string       `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tCreatedAfter            *time.Time    `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore           *time.Time    `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter            *time.Time    `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore           *time.Time    `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tIncludeAncestorGroups   *bool         `url:\"include_ancestor_groups,omitempty\" json:\"include_ancestor_groups,omitempty\"`\n\tIncludeDescendantGroups *bool         `url:\"include_descendant_groups,omitempty\" json:\"include_descendant_groups,omitempty\"`\n\tMyReactionEmoji         *string       `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n}\n\n// ListGroupEpics gets a list of group epics. This function accepts pagination\n// parameters page and per_page to return the list of group epics.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#list-epics-for-a-group\nfunc (s *EpicsService) ListGroupEpics(gid interface{}, opt *ListGroupEpicsOptions, options ...RequestOptionFunc) ([]*Epic, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar es []*Epic\n\tresp, err := s.client.Do(req, &es)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn es, resp, nil\n}\n\n// GetEpic gets a single group epic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#single-epic\nfunc (s *EpicsService) GetEpic(gid interface{}, epic int, options ...RequestOptionFunc) (*Epic, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\te := new(Epic)\n\tresp, err := s.client.Do(req, e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// GetEpicLinks gets all child epics of an epic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epic_links.html\nfunc (s *EpicsService) GetEpicLinks(gid interface{}, epic int, options ...RequestOptionFunc) ([]*Epic, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/epics\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar e []*Epic\n\tresp, err := s.client.Do(req, &e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// CreateEpicOptions represents the available CreateEpic() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#new-epic\ntype CreateEpicOptions struct {\n\tTitle            *string       `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tLabels           *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tDescription      *string       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tColor            *string       `url:\"color,omitempty\" json:\"color,omitempty\"`\n\tConfidential     *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n\tCreatedAt        *time.Time    `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n\tStartDateIsFixed *bool         `url:\"start_date_is_fixed,omitempty\" json:\"start_date_is_fixed,omitempty\"`\n\tStartDateFixed   *ISOTime      `url:\"start_date_fixed,omitempty\" json:\"start_date_fixed,omitempty\"`\n\tDueDateIsFixed   *bool         `url:\"due_date_is_fixed,omitempty\" json:\"due_date_is_fixed,omitempty\"`\n\tDueDateFixed     *ISOTime      `url:\"due_date_fixed,omitempty\" json:\"due_date_fixed,omitempty\"`\n\tParentID         *int          `url:\"parent_id,omitempty\" json:\"parent_id,omitempty\"`\n}\n\n// CreateEpic creates a new group epic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#new-epic\nfunc (s *EpicsService) CreateEpic(gid interface{}, opt *CreateEpicOptions, options ...RequestOptionFunc) (*Epic, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\te := new(Epic)\n\tresp, err := s.client.Do(req, e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// UpdateEpicOptions represents the available UpdateEpic() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#update-epic\ntype UpdateEpicOptions struct {\n\tAddLabels        *LabelOptions `url:\"add_labels,omitempty\" json:\"add_labels,omitempty\"`\n\tConfidential     *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n\tDescription      *string       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tDueDateFixed     *ISOTime      `url:\"due_date_fixed,omitempty\" json:\"due_date_fixed,omitempty\"`\n\tDueDateIsFixed   *bool         `url:\"due_date_is_fixed,omitempty\" json:\"due_date_is_fixed,omitempty\"`\n\tLabels           *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tParentID         *int          `url:\"parent_id,omitempty\" json:\"parent_id,omitempty\"`\n\tRemoveLabels     *LabelOptions `url:\"remove_labels,omitempty\" json:\"remove_labels,omitempty\"`\n\tStartDateFixed   *ISOTime      `url:\"start_date_fixed,omitempty\" json:\"start_date_fixed,omitempty\"`\n\tStartDateIsFixed *bool         `url:\"start_date_is_fixed,omitempty\" json:\"start_date_is_fixed,omitempty\"`\n\tStateEvent       *string       `url:\"state_event,omitempty\" json:\"state_event,omitempty\"`\n\tTitle            *string       `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tUpdatedAt        *time.Time    `url:\"updated_at,omitempty\" json:\"updated_at,omitempty\"`\n\tColor            *string       `url:\"color,omitempty\" json:\"color,omitempty\"`\n}\n\n// UpdateEpic updates an existing group epic. This function is also used\n// to mark an epic as closed.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#update-epic\nfunc (s *EpicsService) UpdateEpic(gid interface{}, epic int, opt *UpdateEpicOptions, options ...RequestOptionFunc) (*Epic, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\te := new(Epic)\n\tresp, err := s.client.Do(req, e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// DeleteEpic deletes a single group epic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/epics.html#delete-epic\nfunc (s *EpicsService) DeleteEpic(gid interface{}, epic int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "epics_test.go",
          "type": "blob",
          "size": 4.0751953125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetEpic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/7/epics/8\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":8, \"title\": \"Incredible idea\", \"description\": \"This is a test epic\", \"author\" : {\"id\" : 26, \"name\": \"jramsay\"}}`)\n\t})\n\n\tepic, _, err := client.Epics.GetEpic(\"7\", 8)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Epic{\n\t\tID:          8,\n\t\tTitle:       \"Incredible idea\",\n\t\tDescription: \"This is a test epic\",\n\t\tAuthor:      &EpicAuthor{ID: 26, Name: \"jramsay\"},\n\t}\n\n\tif !reflect.DeepEqual(want, epic) {\n\t\tt.Errorf(\"Epics.GetEpic returned %+v, want %+v\", epic, want)\n\t}\n}\n\nfunc TestDeleteEpic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/7/epics/8\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Epics.DeleteEpic(\"7\", 8)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListGroupEpics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/7/epics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/groups/7/epics?author_id=26&state=opened\")\n\t\tfmt.Fprint(w, `[{\"id\":8, \"title\": \"Incredible idea\", \"description\": \"This is a test epic\", \"author\" : {\"id\" : 26, \"name\": \"jramsay\"}}]`)\n\t})\n\n\tlistGroupEpics := &ListGroupEpicsOptions{\n\t\tAuthorID: Ptr(26),\n\t\tState:    Ptr(\"opened\"),\n\t}\n\n\tepics, _, err := client.Epics.ListGroupEpics(\"7\", listGroupEpics)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Epic{{\n\t\tID:          8,\n\t\tTitle:       \"Incredible idea\",\n\t\tDescription: \"This is a test epic\",\n\t\tAuthor:      &EpicAuthor{ID: 26, Name: \"jramsay\"},\n\t}}\n\n\tif !reflect.DeepEqual(want, epics) {\n\t\tt.Errorf(\"Epics.ListGroupEpics returned %+v, want %+v\", epics, want)\n\t}\n}\n\nfunc TestCreateEpic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/7/epics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":8, \"title\": \"Incredible idea\", \"description\": \"This is a test epic\", \"author\" : {\"id\" : 26, \"name\": \"jramsay\"}}`)\n\t})\n\n\tcreateEpicOptions := &CreateEpicOptions{\n\t\tTitle:       Ptr(\"Incredible idea\"),\n\t\tDescription: Ptr(\"This is a test epic\"),\n\t}\n\n\tepic, _, err := client.Epics.CreateEpic(\"7\", createEpicOptions)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Epic{\n\t\tID:          8,\n\t\tTitle:       \"Incredible idea\",\n\t\tDescription: \"This is a test epic\",\n\t\tAuthor:      &EpicAuthor{ID: 26, Name: \"jramsay\"},\n\t}\n\n\tif !reflect.DeepEqual(want, epic) {\n\t\tt.Errorf(\"Epics.CreateEpic returned %+v, want %+v\", epic, want)\n\t}\n}\n\nfunc TestUpdateEpic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/7/epics/8\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":8, \"title\": \"Incredible idea\", \"description\": \"This is a test epic\", \"author\" : {\"id\" : 26, \"name\": \"jramsay\"}}`)\n\t})\n\n\tupdateEpicOptions := &UpdateEpicOptions{\n\t\tTitle:       Ptr(\"Incredible idea\"),\n\t\tDescription: Ptr(\"This is a test epic\"),\n\t}\n\n\tepic, _, err := client.Epics.UpdateEpic(\"7\", 8, updateEpicOptions)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Epic{\n\t\tID:          8,\n\t\tTitle:       \"Incredible idea\",\n\t\tDescription: \"This is a test epic\",\n\t\tAuthor:      &EpicAuthor{ID: 26, Name: \"jramsay\"},\n\t}\n\n\tif !reflect.DeepEqual(want, epic) {\n\t\tt.Errorf(\"Epics.UpdateEpic returned %+v, want %+v\", epic, want)\n\t}\n}\n"
        },
        {
          "name": "error_tracking.go",
          "type": "blob",
          "size": 5.923828125,
          "content": "//\n// Copyright 2022, Ryan Glab <ryan.j.glab@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ErrorTrackingService handles communication with the error tracking\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/error_tracking.html\ntype ErrorTrackingService struct {\n\tclient *Client\n}\n\n// ErrorTrackingClientKey represents an error tracking client key.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#error-tracking-client-keys\ntype ErrorTrackingClientKey struct {\n\tID        int    `json:\"id\"`\n\tActive    bool   `json:\"active\"`\n\tPublicKey string `json:\"public_key\"`\n\tSentryDsn string `json:\"sentry_dsn\"`\n}\n\nfunc (p ErrorTrackingClientKey) String() string {\n\treturn Stringify(p)\n}\n\n// ErrorTrackingSettings represents error tracking settings for a GitLab project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/error_tracking.html#error-tracking-project-settings\ntype ErrorTrackingSettings struct {\n\tActive            bool   `json:\"active\"`\n\tProjectName       string `json:\"project_name\"`\n\tSentryExternalURL string `json:\"sentry_external_url\"`\n\tAPIURL            string `json:\"api_url\"`\n\tIntegrated        bool   `json:\"integrated\"`\n}\n\nfunc (p ErrorTrackingSettings) String() string {\n\treturn Stringify(p)\n}\n\n// GetErrorTrackingSettings gets error tracking settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#get-error-tracking-settings\nfunc (s *ErrorTrackingService) GetErrorTrackingSettings(pid interface{}, options ...RequestOptionFunc) (*ErrorTrackingSettings, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/error_tracking/settings\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tets := new(ErrorTrackingSettings)\n\tresp, err := s.client.Do(req, ets)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ets, resp, nil\n}\n\n// EnableDisableErrorTrackingOptions represents the available\n// EnableDisableErrorTracking() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#enable-or-disable-the-error-tracking-project-settings\ntype EnableDisableErrorTrackingOptions struct {\n\tActive     *bool `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tIntegrated *bool `url:\"integrated,omitempty\" json:\"integrated,omitempty\"`\n}\n\n// EnableDisableErrorTracking allows you to enable or disable the error tracking\n// settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#enable-or-disable-the-error-tracking-project-settings\nfunc (s *ErrorTrackingService) EnableDisableErrorTracking(pid interface{}, opt *EnableDisableErrorTrackingOptions, options ...RequestOptionFunc) (*ErrorTrackingSettings, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/error_tracking/settings\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPatch, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tets := new(ErrorTrackingSettings)\n\tresp, err := s.client.Do(req, &ets)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ets, resp, nil\n}\n\n// ListClientKeysOptions represents the available ListClientKeys() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#list-project-client-keys\ntype ListClientKeysOptions ListOptions\n\n// ListClientKeys lists error tracking project client keys.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#list-project-client-keys\nfunc (s *ErrorTrackingService) ListClientKeys(pid interface{}, opt *ListClientKeysOptions, options ...RequestOptionFunc) ([]*ErrorTrackingClientKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/error_tracking/client_keys\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cks []*ErrorTrackingClientKey\n\tresp, err := s.client.Do(req, &cks)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cks, resp, nil\n}\n\n// CreateClientKey creates a new client key for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#create-a-client-key\nfunc (s *ErrorTrackingService) CreateClientKey(pid interface{}, options ...RequestOptionFunc) (*ErrorTrackingClientKey, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/error_tracking/client_keys\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tck := new(ErrorTrackingClientKey)\n\tresp, err := s.client.Do(req, ck)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ck, resp, nil\n}\n\n// DeleteClientKey removes a client key from the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/error_tracking.html#delete-a-client-key\nfunc (s *ErrorTrackingService) DeleteClientKey(pid interface{}, keyID int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/error_tracking/client_keys/%d\", PathEscape(project), keyID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "error_tracking_test.go",
          "type": "blob",
          "size": 5.212890625,
          "content": "//\n// Copyright 2022, Ryan Glab <ryan.j.glab@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetErrorTracking(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/error_tracking/settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"active\": true,\n\t\t\t\"project_name\": \"sample sentry project\",\n\t\t\t\"sentry_external_url\": \"https://sentry.io/myawesomeproject/project\",\n\t\t\t\"api_url\": \"https://sentry.io/api/1/projects/myawesomeproject/project\",\n\t\t\t\"integrated\": false\n\t\t}`)\n\t})\n\n\tet, _, err := client.ErrorTracking.GetErrorTrackingSettings(1)\n\tif err != nil {\n\t\tt.Errorf(\"ErrorTracking.GetErrorTracking returned error: %v\", err)\n\t}\n\n\twant := &ErrorTrackingSettings{\n\t\tActive:            true,\n\t\tProjectName:       \"sample sentry project\",\n\t\tSentryExternalURL: \"https://sentry.io/myawesomeproject/project\",\n\t\tAPIURL:            \"https://sentry.io/api/1/projects/myawesomeproject/project\",\n\t\tIntegrated:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, et) {\n\t\tt.Errorf(\"ErrorTracking.GetErrorTracking returned %+v, want %+v\", et, want)\n\t}\n}\n\nfunc TestDisableErrorTracking(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/error_tracking/settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPatch)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"active\": false,\n\t\t\t\"project_name\": \"sample sentry project\",\n\t\t\t\"sentry_external_url\": \"https://sentry.io/myawesomeproject/project\",\n\t\t\t\"api_url\": \"https://sentry.io/api/1/projects/myawesomeproject/project\",\n\t\t\t\"integrated\": false\n\t\t}`)\n\t})\n\n\tet, _, err := client.ErrorTracking.EnableDisableErrorTracking(\n\t\t1,\n\t\t&EnableDisableErrorTrackingOptions{\n\t\t\tActive:     Ptr(false),\n\t\t\tIntegrated: Ptr(false),\n\t\t},\n\t)\n\tif err != nil {\n\t\tt.Errorf(\"ErrorTracking.EnableDisableErrorTracking returned error: %v\", err)\n\t}\n\n\twant := &ErrorTrackingSettings{\n\t\tActive:            false,\n\t\tProjectName:       \"sample sentry project\",\n\t\tSentryExternalURL: \"https://sentry.io/myawesomeproject/project\",\n\t\tAPIURL:            \"https://sentry.io/api/1/projects/myawesomeproject/project\",\n\t\tIntegrated:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, et) {\n\t\tt.Errorf(\"ErrorTracking.EnableDisableErrorTracking returned %+v, want %+v\", et, want)\n\t}\n}\n\nfunc TestListErrorTrackingClientKeys(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/error_tracking/client_keys\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"active\": true,\n\t\t\t\t\"public_key\": \"glet_aa77551d849c083f76d0bc545ed053a3\",\n\t\t\t\t\"sentry_dsn\": \"https://glet_aa77551d849c083f76d0bc545ed053a3@gitlab.example.com/api/v4/error_tracking/collector/5\"\n\t\t\t}\n\t\t]`)\n\t})\n\n\tcks, _, err := client.ErrorTracking.ListClientKeys(1, &ListClientKeysOptions{Page: 1, PerPage: 10})\n\tif err != nil {\n\t\tt.Errorf(\"ErrorTracking.ListErrorTrackingClientKeys returned error: %v\", err)\n\t}\n\n\twant := []*ErrorTrackingClientKey{{\n\t\tID:        1,\n\t\tActive:    true,\n\t\tPublicKey: \"glet_aa77551d849c083f76d0bc545ed053a3\",\n\t\tSentryDsn: \"https://glet_aa77551d849c083f76d0bc545ed053a3@gitlab.example.com/api/v4/error_tracking/collector/5\",\n\t}}\n\n\tif !reflect.DeepEqual(want, cks) {\n\t\tt.Errorf(\"ErrorTracking.ListErrorTrackingClientKeys returned %+v, want %+v\", cks, want)\n\t}\n}\n\nfunc TestCreateClientKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/error_tracking/client_keys\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"active\": true,\n\t\t\t\"public_key\": \"glet_aa77551d849c083f76d0bc545ed053a3\",\n\t\t\t\"sentry_dsn\": \"https://glet_aa77551d849c083f76d0bc545ed053a3@gitlab.example.com/api/v4/error_tracking/collector/5\"\n\t\t}`)\n\t})\n\n\tck, _, err := client.ErrorTracking.CreateClientKey(1)\n\tif err != nil {\n\t\tt.Errorf(\"ErrorTracking.CreateClientKey returned error: %v\", err)\n\t}\n\n\twant := &ErrorTrackingClientKey{\n\t\tID:        1,\n\t\tActive:    true,\n\t\tPublicKey: \"glet_aa77551d849c083f76d0bc545ed053a3\",\n\t\tSentryDsn: \"https://glet_aa77551d849c083f76d0bc545ed053a3@gitlab.example.com/api/v4/error_tracking/collector/5\",\n\t}\n\n\tif !reflect.DeepEqual(want, ck) {\n\t\tt.Errorf(\"ErrorTracking.CreateClientKey returned %+v, want %+v\", ck, want)\n\t}\n}\n\nfunc TestDeleteClientKey(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/error_tracking/client_keys/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\ttestURL(t, r, \"/api/v4/projects/1/error_tracking/client_keys/3\")\n\t})\n\n\t_, err := client.ErrorTracking.DeleteClientKey(1, 3)\n\tif err != nil {\n\t\tt.Errorf(\"ErrorTracking.DeleteClientKey returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "event_parsing.go",
          "type": "blob",
          "size": 8.6923828125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// EventType represents a Gitlab event type.\ntype EventType string\n\n// List of available event types.\nconst (\n\tEventConfidentialIssue       EventType = \"Confidential Issue Hook\"\n\tEventConfidentialNote        EventType = \"Confidential Note Hook\"\n\tEventTypeBuild               EventType = \"Build Hook\"\n\tEventTypeDeployment          EventType = \"Deployment Hook\"\n\tEventTypeFeatureFlag         EventType = \"Feature Flag Hook\"\n\tEventTypeIssue               EventType = \"Issue Hook\"\n\tEventTypeJob                 EventType = \"Job Hook\"\n\tEventTypeMember              EventType = \"Member Hook\"\n\tEventTypeMergeRequest        EventType = \"Merge Request Hook\"\n\tEventTypeNote                EventType = \"Note Hook\"\n\tEventTypePipeline            EventType = \"Pipeline Hook\"\n\tEventTypePush                EventType = \"Push Hook\"\n\tEventTypeRelease             EventType = \"Release Hook\"\n\tEventTypeResourceAccessToken EventType = \"Resource Access Token Hook\"\n\tEventTypeServiceHook         EventType = \"Service Hook\"\n\tEventTypeSubGroup            EventType = \"Subgroup Hook\"\n\tEventTypeSystemHook          EventType = \"System Hook\"\n\tEventTypeTagPush             EventType = \"Tag Push Hook\"\n\tEventTypeWikiPage            EventType = \"Wiki Page Hook\"\n)\n\nconst (\n\teventObjectKindPush         = \"push\"\n\teventObjectKindTagPush      = \"tag_push\"\n\teventObjectKindMergeRequest = \"merge_request\"\n)\n\nconst (\n\tnoteableTypeCommit       = \"Commit\"\n\tnoteableTypeIssue        = \"Issue\"\n\tnoteableTypeMergeRequest = \"MergeRequest\"\n\tnoteableTypeSnippet      = \"Snippet\"\n)\n\ntype noteEvent struct {\n\tObjectKind       string `json:\"object_kind\"`\n\tObjectAttributes struct {\n\t\tNoteableType string `json:\"noteable_type\"`\n\t} `json:\"object_attributes\"`\n}\n\ntype serviceEvent struct {\n\tObjectKind string `json:\"object_kind\"`\n}\n\nconst eventTokenHeader = \"X-Gitlab-Token\"\n\n// HookEventToken returns the token for the given request.\nfunc HookEventToken(r *http.Request) string {\n\treturn r.Header.Get(eventTokenHeader)\n}\n\nconst eventTypeHeader = \"X-Gitlab-Event\"\n\n// HookEventType returns the event type for the given request.\nfunc HookEventType(r *http.Request) EventType {\n\treturn EventType(r.Header.Get(eventTypeHeader))\n}\n\n// ParseHook tries to parse both web- and system hooks.\n//\n// Example usage:\n//\n//\tfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n//\t    payload, err := io.ReadAll(r.Body)\n//\t    if err != nil { ... }\n//\t    event, err := gitlab.ParseHook(gitlab.HookEventType(r), payload)\n//\t    if err != nil { ... }\n//\t    switch event := event.(type) {\n//\t    case *gitlab.PushEvent:\n//\t        processPushEvent(event)\n//\t    case *gitlab.MergeEvent:\n//\t        processMergeEvent(event)\n//\t    ...\n//\t    }\n//\t}\nfunc ParseHook(eventType EventType, payload []byte) (event interface{}, err error) {\n\tswitch eventType {\n\tcase EventTypeSystemHook:\n\t\treturn ParseSystemhook(payload)\n\tdefault:\n\t\treturn ParseWebhook(eventType, payload)\n\t}\n}\n\n// ParseSystemhook parses the event payload. For recognized event types, a\n// value of the corresponding struct type will be returned. An error will be\n// returned for unrecognized event types.\n//\n// Example usage:\n//\n//\tfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n//\t    payload, err := io.ReadAll(r.Body)\n//\t    if err != nil { ... }\n//\t    event, err := gitlab.ParseSystemhook(payload)\n//\t    if err != nil { ... }\n//\t    switch event := event.(type) {\n//\t    case *gitlab.PushSystemEvent:\n//\t        processPushSystemEvent(event)\n//\t    case *gitlab.MergeSystemEvent:\n//\t        processMergeSystemEvent(event)\n//\t    ...\n//\t    }\n//\t}\nfunc ParseSystemhook(payload []byte) (event interface{}, err error) {\n\te := &systemHookEvent{}\n\terr = json.Unmarshal(payload, e)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tswitch e.EventName {\n\tcase eventObjectKindPush:\n\t\tevent = &PushSystemEvent{}\n\tcase eventObjectKindTagPush:\n\t\tevent = &TagPushSystemEvent{}\n\tcase \"repository_update\":\n\t\tevent = &RepositoryUpdateSystemEvent{}\n\tcase\n\t\t\"project_create\",\n\t\t\"project_update\",\n\t\t\"project_destroy\",\n\t\t\"project_transfer\",\n\t\t\"project_rename\":\n\t\tevent = &ProjectSystemEvent{}\n\tcase\n\t\t\"group_create\",\n\t\t\"group_destroy\",\n\t\t\"group_rename\":\n\t\tevent = &GroupSystemEvent{}\n\tcase \"key_create\", \"key_destroy\":\n\t\tevent = &KeySystemEvent{}\n\tcase\n\t\t\"user_create\",\n\t\t\"user_destroy\",\n\t\t\"user_rename\",\n\t\t\"user_failed_login\":\n\t\tevent = &UserSystemEvent{}\n\tcase\n\t\t\"user_add_to_group\",\n\t\t\"user_remove_from_group\",\n\t\t\"user_update_for_group\":\n\t\tevent = &UserGroupSystemEvent{}\n\tcase\n\t\t\"user_add_to_team\",\n\t\t\"user_remove_from_team\",\n\t\t\"user_update_for_team\":\n\t\tevent = &UserTeamSystemEvent{}\n\tdefault:\n\t\tswitch e.ObjectKind {\n\t\tcase string(MergeRequestEventTargetType):\n\t\t\tevent = &MergeEvent{}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected system hook type %s\", e.EventName)\n\t\t}\n\t}\n\n\tif err := json.Unmarshal(payload, event); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn event, nil\n}\n\n// WebhookEventType returns the event type for the given request.\nfunc WebhookEventType(r *http.Request) EventType {\n\treturn EventType(r.Header.Get(eventTypeHeader))\n}\n\n// ParseWebhook parses the event payload. For recognized event types, a\n// value of the corresponding struct type will be returned. An error will\n// be returned for unrecognized event types.\n//\n// Example usage:\n//\n//\tfunc (s *Server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n//\t    payload, err := io.ReadAll(r.Body)\n//\t    if err != nil { ... }\n//\t    event, err := gitlab.ParseWebhook(gitlab.HookEventType(r), payload)\n//\t    if err != nil { ... }\n//\t    switch event := event.(type) {\n//\t    case *gitlab.PushEvent:\n//\t        processPushEvent(event)\n//\t    case *gitlab.MergeEvent:\n//\t        processMergeEvent(event)\n//\t    ...\n//\t    }\n//\t}\nfunc ParseWebhook(eventType EventType, payload []byte) (event interface{}, err error) {\n\tswitch eventType {\n\tcase EventTypeBuild:\n\t\tevent = &BuildEvent{}\n\tcase EventTypeDeployment:\n\t\tevent = &DeploymentEvent{}\n\tcase EventTypeFeatureFlag:\n\t\tevent = &FeatureFlagEvent{}\n\tcase EventTypeIssue, EventConfidentialIssue:\n\t\tevent = &IssueEvent{}\n\tcase EventTypeJob:\n\t\tevent = &JobEvent{}\n\tcase EventTypeMember:\n\t\tevent = &MemberEvent{}\n\tcase EventTypeMergeRequest:\n\t\tevent = &MergeEvent{}\n\tcase EventTypeNote, EventConfidentialNote:\n\t\tnote := &noteEvent{}\n\t\terr := json.Unmarshal(payload, note)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif note.ObjectKind != string(NoteEventTargetType) {\n\t\t\treturn nil, fmt.Errorf(\"unexpected object kind %s\", note.ObjectKind)\n\t\t}\n\n\t\tswitch note.ObjectAttributes.NoteableType {\n\t\tcase noteableTypeCommit:\n\t\t\tevent = &CommitCommentEvent{}\n\t\tcase noteableTypeMergeRequest:\n\t\t\tevent = &MergeCommentEvent{}\n\t\tcase noteableTypeIssue:\n\t\t\tevent = &IssueCommentEvent{}\n\t\tcase noteableTypeSnippet:\n\t\t\tevent = &SnippetCommentEvent{}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected noteable type %s\", note.ObjectAttributes.NoteableType)\n\t\t}\n\tcase EventTypePipeline:\n\t\tevent = &PipelineEvent{}\n\tcase EventTypePush:\n\t\tevent = &PushEvent{}\n\tcase EventTypeRelease:\n\t\tevent = &ReleaseEvent{}\n\tcase EventTypeResourceAccessToken:\n\t\tdata := map[string]interface{}{}\n\t\terr := json.Unmarshal(payload, &data)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t_, groupEvent := data[\"group\"]\n\t\t_, projectEvent := data[\"project\"]\n\n\t\tswitch {\n\t\tcase groupEvent:\n\t\t\tevent = &GroupResourceAccessTokenEvent{}\n\t\tcase projectEvent:\n\t\t\tevent = &ProjectResourceAccessTokenEvent{}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected resource access token payload\")\n\t\t}\n\tcase EventTypeServiceHook:\n\t\tservice := &serviceEvent{}\n\t\terr := json.Unmarshal(payload, service)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tswitch service.ObjectKind {\n\t\tcase eventObjectKindPush:\n\t\t\tevent = &PushEvent{}\n\t\tcase eventObjectKindTagPush:\n\t\t\tevent = &TagEvent{}\n\t\tcase eventObjectKindMergeRequest:\n\t\t\tevent = &MergeEvent{}\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"unexpected service type %s\", service.ObjectKind)\n\t\t}\n\tcase EventTypeSubGroup:\n\t\tevent = &SubGroupEvent{}\n\tcase EventTypeTagPush:\n\t\tevent = &TagEvent{}\n\tcase EventTypeWikiPage:\n\t\tevent = &WikiPageEvent{}\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unexpected event type: %s\", eventType)\n\t}\n\n\tif err := json.Unmarshal(payload, event); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn event, nil\n}\n"
        },
        {
          "name": "event_parsing_systemhook_test.go",
          "type": "blob",
          "size": 6.8017578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestParseSystemhookPush(t *testing.T) {\n\tpayload := loadFixture(t, \"testdata/systemhooks/push.json\")\n\n\tparsedEvent, err := ParseSystemhook(payload)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*PushSystemEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected PushSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t}\n\tassert.Equal(t, eventObjectKindPush, event.EventName)\n}\n\nfunc TestParseSystemhookTagPush(t *testing.T) {\n\tpayload := loadFixture(t, \"testdata/systemhooks/tag_push.json\")\n\n\tparsedEvent, err := ParseSystemhook(payload)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*TagPushSystemEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected TagPushSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t}\n\tassert.Equal(t, eventObjectKindTagPush, event.EventName)\n}\n\nfunc TestParseSystemhookMergeRequest(t *testing.T) {\n\tpayload := loadFixture(t, \"testdata/systemhooks/merge_request.json\")\n\n\tparsedEvent, err := ParseSystemhook(payload)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*MergeEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected MergeRequestSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t}\n\tassert.Equal(t, eventObjectKindMergeRequest, event.ObjectKind)\n}\n\nfunc TestParseSystemhookRepositoryUpdate(t *testing.T) {\n\tpayload := loadFixture(t, \"testdata/systemhooks/repository_update.json\")\n\n\tparsedEvent, err := ParseSystemhook(payload)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*RepositoryUpdateSystemEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected RepositoryUpdateSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t}\n\tassert.Equal(t, \"repository_update\", event.EventName)\n}\n\nfunc TestParseSystemhookProject(t *testing.T) {\n\ttests := []struct {\n\t\tevent   string\n\t\tpayload []byte\n\t}{\n\t\t{\"project_create\", loadFixture(t, \"testdata/systemhooks/project_create.json\")},\n\t\t{\"project_update\", loadFixture(t, \"testdata/systemhooks/project_update.json\")},\n\t\t{\"project_destroy\", loadFixture(t, \"testdata/systemhooks/project_destroy.json\")},\n\t\t{\"project_transfer\", loadFixture(t, \"testdata/systemhooks/project_transfer.json\")},\n\t\t{\"project_rename\", loadFixture(t, \"testdata/systemhooks/project_rename.json\")},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\tparsedEvent, err := ParseSystemhook(tc.payload)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t\t\t}\n\t\t\tevent, ok := parsedEvent.(*ProjectSystemEvent)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"Expected ProjectSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.event, event.EventName)\n\t\t})\n\t}\n}\n\nfunc TestParseSystemhookGroup(t *testing.T) {\n\ttests := []struct {\n\t\tevent   string\n\t\tpayload []byte\n\t}{\n\t\t{\"group_create\", loadFixture(t, \"testdata/systemhooks/group_create.json\")},\n\t\t{\"group_destroy\", loadFixture(t, \"testdata/systemhooks/group_destroy.json\")},\n\t\t{\"group_rename\", loadFixture(t, \"testdata/systemhooks/group_rename.json\")},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\tparsedEvent, err := ParseSystemhook(tc.payload)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t\t\t}\n\t\t\tevent, ok := parsedEvent.(*GroupSystemEvent)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"Expected GroupSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.event, event.EventName)\n\t\t})\n\t}\n}\n\nfunc TestParseSystemhookUser(t *testing.T) {\n\ttests := []struct {\n\t\tevent   string\n\t\tpayload []byte\n\t}{\n\t\t{\"user_create\", loadFixture(t, \"testdata/systemhooks/user_create.json\")},\n\t\t{\"user_destroy\", loadFixture(t, \"testdata/systemhooks/user_destroy.json\")},\n\t\t{\"user_rename\", loadFixture(t, \"testdata/systemhooks/user_rename.json\")},\n\t\t{\"user_failed_login\", loadFixture(t, \"testdata/systemhooks/user_failed_login.json\")},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\tparsedEvent, err := ParseSystemhook(tc.payload)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t\t\t}\n\t\t\tevent, ok := parsedEvent.(*UserSystemEvent)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"Expected UserSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.event, event.EventName)\n\t\t})\n\t}\n}\n\nfunc TestParseSystemhookUserGroup(t *testing.T) {\n\ttests := []struct {\n\t\tevent   string\n\t\tpayload []byte\n\t}{\n\t\t{\"user_add_to_group\", loadFixture(t, \"testdata/systemhooks/user_add_to_group.json\")},\n\t\t{\"user_remove_from_group\", loadFixture(t, \"testdata/systemhooks/user_remove_from_group.json\")},\n\t\t{\"user_update_for_group\", loadFixture(t, \"testdata/systemhooks/user_update_for_group.json\")},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\tparsedEvent, err := ParseSystemhook(tc.payload)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t\t\t}\n\t\t\tevent, ok := parsedEvent.(*UserGroupSystemEvent)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"Expected UserGroupSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.event, event.EventName)\n\t\t})\n\t}\n}\n\nfunc TestParseSystemhookUserTeam(t *testing.T) {\n\ttests := []struct {\n\t\tevent   string\n\t\tpayload []byte\n\t}{\n\t\t{\"user_add_to_team\", loadFixture(t, \"testdata/systemhooks/user_add_to_team.json\")},\n\t\t{\"user_remove_from_team\", loadFixture(t, \"testdata/systemhooks/user_remove_from_team.json\")},\n\t\t{\"user_update_for_team\", loadFixture(t, \"testdata/systemhooks/user_update_for_team.json\")},\n\t}\n\tfor _, tc := range tests {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\tparsedEvent, err := ParseSystemhook(tc.payload)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t\t\t}\n\t\t\tevent, ok := parsedEvent.(*UserTeamSystemEvent)\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"Expected UserTeamSystemHookEvent, but parsing produced %T\", parsedEvent)\n\t\t\t}\n\t\t\tassert.Equal(t, tc.event, event.EventName)\n\t\t})\n\t}\n}\n\nfunc TestParseHookSystemHook(t *testing.T) {\n\tparsedEvent1, err := ParseHook(\"System Hook\", loadFixture(t, \"testdata/systemhooks/merge_request.json\"))\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\tparsedEvent2, err := ParseSystemhook(loadFixture(t, \"testdata/systemhooks/merge_request.json\"))\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\tassert.Equal(t, parsedEvent1, parsedEvent2)\n}\n"
        },
        {
          "name": "event_parsing_webhook_test.go",
          "type": "blob",
          "size": 17.943359375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWebhookEventType(t *testing.T) {\n\treq, err := http.NewRequest(http.MethodGet, \"https://gitlab.com\", nil)\n\tif err != nil {\n\t\tt.Errorf(\"Error creating HTTP request: %s\", err)\n\t}\n\treq.Header.Set(\"X-Gitlab-Event\", \"Push Hook\")\n\n\teventType := HookEventType(req)\n\tif eventType != \"Push Hook\" {\n\t\tt.Errorf(\"WebhookEventType is %s, want %s\", eventType, \"Push Hook\")\n\t}\n}\n\nfunc TestWebhookEventToken(t *testing.T) {\n\treq, err := http.NewRequest(http.MethodGet, \"https://gitlab.com\", nil)\n\tif err != nil {\n\t\tt.Errorf(\"Error creating HTTP request: %s\", err)\n\t}\n\treq.Header.Set(\"X-Gitlab-Token\", \"798d3dd3-67f5-41df-ad19-7882cc6263bf\")\n\n\tactualToken := HookEventToken(req)\n\tif actualToken != \"798d3dd3-67f5-41df-ad19-7882cc6263bf\" {\n\t\tt.Errorf(\"WebhookEventToken is %q, want %q\", actualToken, \"798d3dd3-67f5-41df-ad19-7882cc6263bf\")\n\t}\n}\n\nfunc TestParseBuildHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/build.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Build Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*BuildEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected BuildEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"build\" {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"build\")\n\t}\n\n\tif event.BuildID != 1977 {\n\t\tt.Errorf(\"BuildID is %v, want %v\", event.BuildID, 1977)\n\t}\n\n\tif event.BuildAllowFailure {\n\t\tt.Errorf(\"BuildAllowFailure is %v, want %v\", event.BuildAllowFailure, false)\n\t}\n\n\tif event.Commit.SHA != \"2293ada6b400935a1378653304eaf6221e0fdb8f\" {\n\t\tt.Errorf(\"Commit SHA is %v, want %v\", event.Commit.SHA, \"2293ada6b400935a1378653304eaf6221e0fdb8f\")\n\t}\n\n\tif event.BuildCreatedAt != \"2021-02-23T02:41:37.886Z\" {\n\t\tt.Errorf(\"BuildCreatedAt is %s, want %s\", event.User.Name, expectedName)\n\t}\n}\n\nfunc TestParseCommitCommentHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/note_commit.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Note Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing note hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*CommitCommentEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected CommitCommentEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != string(NoteEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, NoteEventTargetType)\n\t}\n\n\tif event.ProjectID != 5 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 5)\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"Commit\" {\n\t\tt.Errorf(\"NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"Commit\")\n\t}\n\n\tif event.Commit.ID != \"cfe32cf61b73a0d5e9f13e774abde7ff789b1660\" {\n\t\tt.Errorf(\"CommitID is %v, want %v\", event.Commit.ID, \"cfe32cf61b73a0d5e9f13e774abde7ff789b1660\")\n\t}\n}\n\nfunc TestParseFeatureFlagHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/feature_flag.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Feature Flag Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing feature flag hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*FeatureFlagEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected FeatureFlagEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"feature_flag\" {\n\t\tt.Errorf(\"ObjectKind is %s, want %s\", event.ObjectKind, \"feature_flag\")\n\t}\n\n\tif event.Project.ID != 1 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 1)\n\t}\n\n\tif event.User.ID != 1 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 1)\n\t}\n\n\tif event.User.Name != \"Administrator\" {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, \"Administrator\")\n\t}\n\n\tif event.ObjectAttributes.ID != 6 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %d, want %d\", event.ObjectAttributes.ID, 6)\n\t}\n\n\tif event.ObjectAttributes.Name != \"test-feature-flag\" {\n\t\tt.Errorf(\"ObjectAttributes.Name is %s, want %s\", event.ObjectAttributes.Name, \"test-feature-flag\")\n\t}\n\n\tif event.ObjectAttributes.Description != \"test-feature-flag-description\" {\n\t\tt.Errorf(\"ObjectAttributes.Description is %s, want %s\", event.ObjectAttributes.Description, \"test-feature-flag-description\")\n\t}\n\n\tif event.ObjectAttributes.Active != true {\n\t\tt.Errorf(\"ObjectAttributes.Active is %t, want %t\", event.ObjectAttributes.Active, true)\n\t}\n}\n\nfunc TestParseGroupResourceAccessTokenHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/resource_access_token_group.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Resource Access Token Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing group resource access token hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*GroupResourceAccessTokenEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected GroupResourceAccessTokenEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\texpectedEventName := \"expiring_access_token\"\n\n\tif event.EventName != expectedEventName {\n\t\tt.Errorf(\"EventName is %v, want %v\", event.EventName, expectedEventName)\n\t}\n}\n\nfunc TestParseHookWebHook(t *testing.T) {\n\tparsedEvent1, err := ParseHook(\"Merge Request Hook\", loadFixture(t, \"testdata/webhooks/merge_request.json\"))\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\tparsedEvent2, err := ParseWebhook(\"Merge Request Hook\", loadFixture(t, \"testdata/webhooks/merge_request.json\"))\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing build hook: %s\", err)\n\t}\n\tassert.Equal(t, parsedEvent1, parsedEvent2)\n}\n\nfunc TestParseIssueCommentHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/note_issue.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Note Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing note hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*IssueCommentEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected IssueCommentEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != string(NoteEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, NoteEventTargetType)\n\t}\n\n\tif event.ProjectID != 5 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 5)\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"Issue\" {\n\t\tt.Errorf(\"NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"Issue\")\n\t}\n\n\tif event.Issue.Title != \"test_issue\" {\n\t\tt.Errorf(\"Issue title is %v, want %v\", event.Issue.Title, \"test_issue\")\n\t}\n\tassert.Equal(t, 2, len(event.Issue.Labels))\n}\n\nfunc TestParseIssueHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/issue.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Issue Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing issue hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*IssueEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected IssueEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"issue\" {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"issue\")\n\t}\n\n\tif event.Project.Name != \"Gitlab Test\" {\n\t\tt.Errorf(\"Project name is %v, want %v\", event.Project.Name, \"Gitlab Test\")\n\t}\n\n\tif event.ObjectAttributes.State != \"opened\" {\n\t\tt.Errorf(\"Issue state is %v, want %v\", event.ObjectAttributes.State, \"opened\")\n\t}\n\n\tif event.Assignee.Username != \"user1\" {\n\t\tt.Errorf(\"Assignee username is %v, want %v\", event.Assignee.Username, \"user1\")\n\t}\n\tassert.Equal(t, 1, len(event.Labels))\n\tassert.Equal(t, 0, event.Changes.UpdatedByID.Previous)\n\tassert.Equal(t, 1, event.Changes.UpdatedByID.Current)\n\tassert.Equal(t, 1, len(event.Changes.Labels.Previous))\n\tassert.Equal(t, 1, len(event.Changes.Labels.Current))\n\tassert.Equal(t, \"\", event.Changes.Description.Previous)\n\tassert.Equal(t, \"New description\", event.Changes.Description.Current)\n\tassert.Equal(t, \"\", event.Changes.Title.Previous)\n\tassert.Equal(t, \"New title\", event.Changes.Title.Current)\n}\n\nfunc TestParseMergeRequestCommentHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/note_merge_request.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Note Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing note hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*MergeCommentEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected MergeCommentEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != string(NoteEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"note\")\n\t}\n\n\tif event.ProjectID != 5 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 5)\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"MergeRequest\" {\n\t\tt.Errorf(\"NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"MergeRequest\")\n\t}\n\n\tif event.MergeRequest.ID != 7 {\n\t\tt.Errorf(\"MergeRequest ID is %v, want %v\", event.MergeRequest.ID, 7)\n\t}\n\n\texpectedTitle := \"Merge branch 'another-branch' into 'master'\"\n\tif event.MergeRequest.LastCommit.Title != expectedTitle {\n\t\tt.Errorf(\"MergeRequest Title is %v, want %v\", event.MergeRequest.Title, expectedTitle)\n\t}\n}\n\nfunc TestParseMemberHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/member.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Member Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing member hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*MemberEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected MemberEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.EventName != \"user_add_to_group\" {\n\t\tt.Errorf(\"EventName is %v, want %v\", event.EventName, \"user_add_to_group\")\n\t}\n}\n\nfunc TestParseMergeRequestHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/merge_request.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Merge Request Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing merge request hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*MergeEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected MergeEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"merge_request\" {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"merge_request\")\n\t}\n\n\tif event.ObjectAttributes.MergeStatus != \"unchecked\" {\n\t\tt.Errorf(\"MergeStatus is %v, want %v\", event.ObjectAttributes.MergeStatus, \"unchecked\")\n\t}\n\n\tif event.ObjectAttributes.LastCommit.ID != \"da1560886d4f094c3e6c9ef40349f7d38b5d27d7\" {\n\t\tt.Errorf(\"LastCommit ID is %v, want %v\", event.ObjectAttributes.LastCommit.ID, \"da1560886d4f094c3e6c9ef40349f7d38b5d27d7\")\n\t}\n\n\tif event.ObjectAttributes.WorkInProgress {\n\t\tt.Errorf(\"WorkInProgress is %v, want %v\", event.ObjectAttributes.WorkInProgress, false)\n\t}\n\tassert.Equal(t, 1, len(event.Labels))\n\tassert.Equal(t, 0, event.Changes.UpdatedByID.Previous)\n\tassert.Equal(t, 1, event.Changes.UpdatedByID.Current)\n\tassert.Equal(t, 1, len(event.Changes.Labels.Previous))\n\tassert.Equal(t, 1, len(event.Changes.Labels.Current))\n}\n\nfunc TestParsePipelineHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/pipeline.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Pipeline Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing pipeline hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*PipelineEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected PipelineEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"pipeline\" {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"pipeline\")\n\t}\n\n\tif event.ObjectAttributes.Duration != 63 {\n\t\tt.Errorf(\"Duration is %v, want %v\", event.ObjectAttributes.Duration, 63)\n\t}\n\n\tif event.Commit.ID != \"bcbb5ec396a2c0f828686f14fac9b80b780504f2\" {\n\t\tt.Errorf(\"Commit ID is %v, want %v\", event.Commit.ID, \"bcbb5ec396a2c0f828686f14fac9b80b780504f2\")\n\t}\n\n\tif event.Builds[0].ID != 380 {\n\t\tt.Errorf(\"Builds[0] ID is %v, want %v\", event.Builds[0].ID, 380)\n\t}\n\n\tif event.Builds[0].Runner.RunnerType != \"instance_type\" {\n\t\tt.Errorf(\"Builds[0] Runner RunnerType is %v, want %v\", event.Builds[0].Runner.RunnerType, \"instance_type\")\n\t}\n}\n\nfunc TestParseProjectResourceAccessTokenHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/resource_access_token_project.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Resource Access Token Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing project resource access token hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*ProjectResourceAccessTokenEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected ProjectResourceAccessTokenEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\texpectedEventName := \"expiring_access_token\"\n\n\tif event.EventName != expectedEventName {\n\t\tt.Errorf(\"EventName is %v, want %v\", event.EventName, expectedEventName)\n\t}\n}\n\nfunc TestParsePushHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/push.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Push Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing push hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*PushEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected PushEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != eventObjectKindPush {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, eventObjectKindPush)\n\t}\n\n\tif event.ProjectID != 15 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 15)\n\t}\n\n\tif event.UserName != exampleEventUserName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.UserName, exampleEventUserName)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Timestamp == nil {\n\t\tt.Errorf(\"Commit Timestamp isn't nil\")\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Author.Name != \"Jordi Mallach\" {\n\t\tt.Errorf(\"Commit Username is %s, want %s\", event.UserName, \"Jordi Mallach\")\n\t}\n}\n\nfunc TestParseReleaseHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/release.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Release Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing release hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*ReleaseEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected ReleaseEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"release\" {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"release\")\n\t}\n\n\tif event.Project.Name != \"Project Name\" {\n\t\tt.Errorf(\"Project name is %v, want %v\", event.Project.Name, \"Project Name\")\n\t}\n}\n\nfunc TestParseServiceWebHook(t *testing.T) {\n\tparsedEvent, err := ParseWebhook(\"Service Hook\", loadFixture(t, \"testdata/webhooks/service_merge_request.json\"))\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing service hook merge request: %s\", err)\n\t}\n\n\tswitch event := parsedEvent.(type) {\n\tcase *MergeEvent:\n\t\tassert.EqualValues(t, &EventUser{\n\t\t\tID:        2,\n\t\t\tName:      \"the test\",\n\t\t\tUsername:  \"test\",\n\t\t\tEmail:     \"test@test.test\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/dd46a756faad4727fb679320751f6dea?s=80&d=identicon\",\n\t\t}, event.User)\n\t\tassert.EqualValues(t, \"unchecked\", event.ObjectAttributes.MergeStatus)\n\t\tassert.EqualValues(t, \"next-feature\", event.ObjectAttributes.SourceBranch)\n\t\tassert.EqualValues(t, \"master\", event.ObjectAttributes.TargetBranch)\n\tdefault:\n\t\tt.Errorf(\"unexpected event type: %s\", reflect.TypeOf(parsedEvent))\n\t}\n}\n\nfunc TestParseSnippetCommentHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/note_snippet.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Note Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing note hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*SnippetCommentEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected SnippetCommentEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != string(NoteEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, NoteEventTargetType)\n\t}\n\n\tif event.ProjectID != 5 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 5)\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"Snippet\" {\n\t\tt.Errorf(\"NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"Snippet\")\n\t}\n\n\tif event.Snippet.Title != \"test\" {\n\t\tt.Errorf(\"Snippet title is %v, want %v\", event.Snippet.Title, \"test\")\n\t}\n}\n\nfunc TestParseSubGroupHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/subgroup.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Subgroup Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing subgroup hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*SubGroupEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected SubGroupEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.EventName != \"subgroup_create\" {\n\t\tt.Errorf(\"EventName is %v, want %v\", event.EventName, \"subgroup_create\")\n\t}\n}\n\nfunc TestParseTagHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/tag_push.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Tag Push Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing tag hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*TagEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected TagEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != eventObjectKindTagPush {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, eventObjectKindTagPush)\n\t}\n\n\tif event.ProjectID != 1 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 1)\n\t}\n\n\tif event.UserName != exampleEventUserName {\n\t\tt.Errorf(\"Name is %s, want %s\", event.UserName, exampleEventUserName)\n\t}\n\n\tif event.UserUsername != exampleEventUserUsername {\n\t\tt.Errorf(\"Username is %s, want %s\", event.UserUsername, exampleEventUserUsername)\n\t}\n\n\tif event.Ref != \"refs/tags/v1.0.0\" {\n\t\tt.Errorf(\"Ref is %s, want %s\", event.Ref, \"refs/tags/v1.0.0\")\n\t}\n}\n\nfunc TestParseWikiPageHook(t *testing.T) {\n\traw := loadFixture(t, \"testdata/webhooks/wiki_page.json\")\n\n\tparsedEvent, err := ParseWebhook(\"Wiki Page Hook\", raw)\n\tif err != nil {\n\t\tt.Errorf(\"Error parsing wiki page hook: %s\", err)\n\t}\n\n\tevent, ok := parsedEvent.(*WikiPageEvent)\n\tif !ok {\n\t\tt.Errorf(\"Expected WikiPageEvent, but parsing produced %T\", parsedEvent)\n\t}\n\n\tif event.ObjectKind != \"wiki_page\" {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, \"wiki_page\")\n\t}\n\n\tif event.Project.Name != \"awesome-project\" {\n\t\tt.Errorf(\"Project name is %v, want %v\", event.Project.Name, \"awesome-project\")\n\t}\n\n\tif event.Wiki.WebURL != \"http://example.com/root/awesome-project/wikis/home\" {\n\t\tt.Errorf(\"Wiki web URL is %v, want %v\", event.Wiki.WebURL, \"http://example.com/root/awesome-project/wikis/home\")\n\t}\n\n\tif event.ObjectAttributes.Message != \"adding an awesome page to the wiki\" {\n\t\tt.Errorf(\"Message is %v, want %v\", event.ObjectAttributes.Message, \"adding an awesome page to the wiki\")\n\t}\n}\n"
        },
        {
          "name": "event_systemhook_types.go",
          "type": "blob",
          "size": 8.5654296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport \"time\"\n\n// systemHookEvent is used to pre-process events to determine the\n// system hook event type.\ntype systemHookEvent struct {\n\tBaseSystemEvent\n\tObjectKind string `json:\"object_kind\"`\n}\n\n// BaseSystemEvent contains system hook's common properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype BaseSystemEvent struct {\n\tEventName string `json:\"event_name\"`\n\tCreatedAt string `json:\"created_at\"`\n\tUpdatedAt string `json:\"updated_at\"`\n}\n\n// ProjectSystemEvent represents a project system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype ProjectSystemEvent struct {\n\tBaseSystemEvent\n\tName                 string `json:\"name\"`\n\tPath                 string `json:\"path\"`\n\tPathWithNamespace    string `json:\"path_with_namespace\"`\n\tProjectID            int    `json:\"project_id\"`\n\tOwnerName            string `json:\"owner_name\"`\n\tOwnerEmail           string `json:\"owner_email\"`\n\tProjectVisibility    string `json:\"project_visibility\"`\n\tOldPathWithNamespace string `json:\"old_path_with_namespace,omitempty\"`\n}\n\n// GroupSystemEvent represents a group system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype GroupSystemEvent struct {\n\tBaseSystemEvent\n\tName                 string `json:\"name\"`\n\tPath                 string `json:\"path\"`\n\tPathWithNamespace    string `json:\"full_path\"`\n\tGroupID              int    `json:\"group_id\"`\n\tOwnerName            string `json:\"owner_name\"`\n\tOwnerEmail           string `json:\"owner_email\"`\n\tProjectVisibility    string `json:\"project_visibility\"`\n\tOldPath              string `json:\"old_path,omitempty\"`\n\tOldPathWithNamespace string `json:\"old_full_path,omitempty\"`\n}\n\n// KeySystemEvent represents a key system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype KeySystemEvent struct {\n\tBaseSystemEvent\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tKey      string `json:\"key\"`\n}\n\n// UserSystemEvent represents a user system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype UserSystemEvent struct {\n\tBaseSystemEvent\n\tID          int    `json:\"user_id\"`\n\tName        string `json:\"name\"`\n\tUsername    string `json:\"username\"`\n\tOldUsername string `json:\"old_username,omitempty\"`\n\tEmail       string `json:\"email\"`\n\tState       string `json:\"state,omitempty\"`\n}\n\n// UserGroupSystemEvent represents a user group system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype UserGroupSystemEvent struct {\n\tBaseSystemEvent\n\tID          int    `json:\"user_id\"`\n\tName        string `json:\"user_name\"`\n\tUsername    string `json:\"user_username\"`\n\tEmail       string `json:\"user_email\"`\n\tGroupID     int    `json:\"group_id\"`\n\tGroupName   string `json:\"group_name\"`\n\tGroupPath   string `json:\"group_path\"`\n\tGroupAccess string `json:\"group_access\"`\n}\n\n// UserTeamSystemEvent represents a user team system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html\ntype UserTeamSystemEvent struct {\n\tBaseSystemEvent\n\tID                       int    `json:\"user_id\"`\n\tName                     string `json:\"user_name\"`\n\tUsername                 string `json:\"user_username\"`\n\tEmail                    string `json:\"user_email\"`\n\tProjectID                int    `json:\"project_id\"`\n\tProjectName              string `json:\"project_name\"`\n\tProjectPath              string `json:\"project_path\"`\n\tProjectPathWithNamespace string `json:\"project_path_with_namespace\"`\n\tProjectVisibility        string `json:\"project_visibility\"`\n\tAccessLevel              string `json:\"access_level\"`\n}\n\n// PushSystemEvent represents a push system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html#push-events\ntype PushSystemEvent struct {\n\tBaseSystemEvent\n\tBefore       string `json:\"before\"`\n\tAfter        string `json:\"after\"`\n\tRef          string `json:\"ref\"`\n\tCheckoutSHA  string `json:\"checkout_sha\"`\n\tUserID       int    `json:\"user_id\"`\n\tUserName     string `json:\"user_name\"`\n\tUserUsername string `json:\"user_username\"`\n\tUserEmail    string `json:\"user_email\"`\n\tUserAvatar   string `json:\"user_avatar\"`\n\tProjectID    int    `json:\"project_id\"`\n\tProject      struct {\n\t\tName              string `json:\"name\"`\n\t\tDescription       string `json:\"description\"`\n\t\tWebURL            string `json:\"web_url\"`\n\t\tAvatarURL         string `json:\"avatar_url\"`\n\t\tGitHTTPURL        string `json:\"git_http_url\"`\n\t\tGitSSHURL         string `json:\"git_ssh_url\"`\n\t\tNamespace         string `json:\"namespace\"`\n\t\tVisibilityLevel   int    `json:\"visibility_level\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string `json:\"default_branch\"`\n\t\tHomepage          string `json:\"homepage\"`\n\t\tURL               string `json:\"url\"`\n\t} `json:\"project\"`\n\tCommits []struct {\n\t\tID        string    `json:\"id\"`\n\t\tMessage   string    `json:\"message\"`\n\t\tTimestamp time.Time `json:\"timestamp\"`\n\t\tURL       string    `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t} `json:\"commits\"`\n\tTotalCommitsCount int `json:\"total_commits_count\"`\n}\n\n// TagPushSystemEvent represents a tag push system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html#tag-events\ntype TagPushSystemEvent struct {\n\tBaseSystemEvent\n\tBefore       string `json:\"before\"`\n\tAfter        string `json:\"after\"`\n\tRef          string `json:\"ref\"`\n\tCheckoutSHA  string `json:\"checkout_sha\"`\n\tUserID       int    `json:\"user_id\"`\n\tUserName     string `json:\"user_name\"`\n\tUserUsername string `json:\"user_username\"`\n\tUserEmail    string `json:\"user_email\"`\n\tUserAvatar   string `json:\"user_avatar\"`\n\tProjectID    int    `json:\"project_id\"`\n\tProject      struct {\n\t\tName              string `json:\"name\"`\n\t\tDescription       string `json:\"description\"`\n\t\tWebURL            string `json:\"web_url\"`\n\t\tAvatarURL         string `json:\"avatar_url\"`\n\t\tGitHTTPURL        string `json:\"git_http_url\"`\n\t\tGitSSHURL         string `json:\"git_ssh_url\"`\n\t\tNamespace         string `json:\"namespace\"`\n\t\tVisibilityLevel   int    `json:\"visibility_level\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string `json:\"default_branch\"`\n\t\tHomepage          string `json:\"homepage\"`\n\t\tURL               string `json:\"url\"`\n\t} `json:\"project\"`\n\tCommits []struct {\n\t\tID        string    `json:\"id\"`\n\t\tMessage   string    `json:\"message\"`\n\t\tTimestamp time.Time `json:\"timestamp\"`\n\t\tURL       string    `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t} `json:\"commits\"`\n\tTotalCommitsCount int `json:\"total_commits_count\"`\n}\n\n// RepositoryUpdateSystemEvent represents a repository updated system event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/administration/system_hooks.html#repository-update-events\ntype RepositoryUpdateSystemEvent struct {\n\tBaseSystemEvent\n\tUserID     int    `json:\"user_id\"`\n\tUserName   string `json:\"user_name\"`\n\tUserEmail  string `json:\"user_email\"`\n\tUserAvatar string `json:\"user_avatar\"`\n\tProjectID  int    `json:\"project_id\"`\n\tProject    struct {\n\t\tID                int    `json:\"id\"`\n\t\tName              string `json:\"name\"`\n\t\tDescription       string `json:\"description\"`\n\t\tWebURL            string `json:\"web_url\"`\n\t\tAvatarURL         string `json:\"avatar_url\"`\n\t\tGitHTTPURL        string `json:\"git_http_url\"`\n\t\tGitSSHURL         string `json:\"git_ssh_url\"`\n\t\tNamespace         string `json:\"namespace\"`\n\t\tVisibilityLevel   int    `json:\"visibility_level\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string `json:\"default_branch\"`\n\t\tCiConfigPath      string `json:\"ci_config_path\"`\n\t\tHomepage          string `json:\"homepage\"`\n\t\tURL               string `json:\"url\"`\n\t} `json:\"project\"`\n\tChanges []struct {\n\t\tBefore string `json:\"before\"`\n\t\tAfter  string `json:\"after\"`\n\t\tRef    string `json:\"ref\"`\n\t} `json:\"changes\"`\n\tRefs []string `json:\"refs\"`\n}\n"
        },
        {
          "name": "event_webhook_types.go",
          "type": "blob",
          "size": 51.412109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// StateID identifies the state of an issue or merge request.\n//\n// There are no GitLab API docs on the subject, but the mappings can be found in\n// GitLab's codebase:\n// https://gitlab.com/gitlab-org/gitlab-foss/-/blob/ba5be4989e/app/models/concerns/issuable.rb#L39-42\ntype StateID int\n\nconst (\n\tStateIDNone   StateID = 0\n\tStateIDOpen   StateID = 1\n\tStateIDClosed StateID = 2\n\tStateIDMerged StateID = 3\n\tStateIDLocked StateID = 4\n)\n\n// BuildEvent represents a build event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#job-events\ntype BuildEvent struct {\n\tObjectKind        string     `json:\"object_kind\"`\n\tRef               string     `json:\"ref\"`\n\tTag               bool       `json:\"tag\"`\n\tBeforeSHA         string     `json:\"before_sha\"`\n\tSHA               string     `json:\"sha\"`\n\tBuildID           int        `json:\"build_id\"`\n\tBuildName         string     `json:\"build_name\"`\n\tBuildStage        string     `json:\"build_stage\"`\n\tBuildStatus       string     `json:\"build_status\"`\n\tBuildCreatedAt    string     `json:\"build_created_at\"`\n\tBuildStartedAt    string     `json:\"build_started_at\"`\n\tBuildFinishedAt   string     `json:\"build_finished_at\"`\n\tBuildDuration     float64    `json:\"build_duration\"`\n\tBuildAllowFailure bool       `json:\"build_allow_failure\"`\n\tProjectID         int        `json:\"project_id\"`\n\tProjectName       string     `json:\"project_name\"`\n\tUser              *EventUser `json:\"user\"`\n\tCommit            struct {\n\t\tID          int    `json:\"id\"`\n\t\tSHA         string `json:\"sha\"`\n\t\tMessage     string `json:\"message\"`\n\t\tAuthorName  string `json:\"author_name\"`\n\t\tAuthorEmail string `json:\"author_email\"`\n\t\tStatus      string `json:\"status\"`\n\t\tDuration    int    `json:\"duration\"`\n\t\tStartedAt   string `json:\"started_at\"`\n\t\tFinishedAt  string `json:\"finished_at\"`\n\t} `json:\"commit\"`\n\tRepository *Repository `json:\"repository\"`\n}\n\n// CommitCommentEvent represents a comment on a commit event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#comment-on-a-commit\ntype CommitCommentEvent struct {\n\tObjectKind string `json:\"object_kind\"`\n\tEventType  string `json:\"event_type\"`\n\tUser       *User  `json:\"user\"`\n\tProjectID  int    `json:\"project_id\"`\n\tProject    struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tRepository       *Repository `json:\"repository\"`\n\tObjectAttributes struct {\n\t\tID           int                `json:\"id\"`\n\t\tNote         string             `json:\"note\"`\n\t\tNoteableType string             `json:\"noteable_type\"`\n\t\tAuthorID     int                `json:\"author_id\"`\n\t\tCreatedAt    string             `json:\"created_at\"`\n\t\tUpdatedAt    string             `json:\"updated_at\"`\n\t\tProjectID    int                `json:\"project_id\"`\n\t\tAttachment   string             `json:\"attachment\"`\n\t\tLineCode     string             `json:\"line_code\"`\n\t\tCommitID     string             `json:\"commit_id\"`\n\t\tNoteableID   int                `json:\"noteable_id\"`\n\t\tSystem       bool               `json:\"system\"`\n\t\tStDiff       *Diff              `json:\"st_diff\"`\n\t\tDescription  string             `json:\"description\"`\n\t\tAction       CommentEventAction `json:\"action\"`\n\t\tURL          string             `json:\"url\"`\n\t} `json:\"object_attributes\"`\n\tCommit *struct {\n\t\tID        string     `json:\"id\"`\n\t\tTitle     string     `json:\"title\"`\n\t\tMessage   string     `json:\"message\"`\n\t\tTimestamp *time.Time `json:\"timestamp\"`\n\t\tURL       string     `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t} `json:\"commit\"`\n}\n\n// DeploymentEvent represents a deployment event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#deployment-events\ntype DeploymentEvent struct {\n\tObjectKind             string `json:\"object_kind\"`\n\tStatus                 string `json:\"status\"`\n\tStatusChangedAt        string `json:\"status_changed_at\"`\n\tDeploymentID           int    `json:\"deployment_id\"`\n\tDeployableID           int    `json:\"deployable_id\"`\n\tDeployableURL          string `json:\"deployable_url\"`\n\tEnvironment            string `json:\"environment\"`\n\tEnvironmentSlug        string `json:\"environment_slug\"`\n\tEnvironmentExternalURL string `json:\"environment_external_url\"`\n\tProject                struct {\n\t\tID                int     `json:\"id\"`\n\t\tName              string  `json:\"name\"`\n\t\tDescription       string  `json:\"description\"`\n\t\tWebURL            string  `json:\"web_url\"`\n\t\tAvatarURL         *string `json:\"avatar_url\"`\n\t\tGitSSHURL         string  `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string  `json:\"git_http_url\"`\n\t\tNamespace         string  `json:\"namespace\"`\n\t\tVisibilityLevel   int     `json:\"visibility_level\"`\n\t\tPathWithNamespace string  `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string  `json:\"default_branch\"`\n\t\tCIConfigPath      string  `json:\"ci_config_path\"`\n\t\tHomepage          string  `json:\"homepage\"`\n\t\tURL               string  `json:\"url\"`\n\t\tSSHURL            string  `json:\"ssh_url\"`\n\t\tHTTPURL           string  `json:\"http_url\"`\n\t} `json:\"project\"`\n\tRef         string     `json:\"ref\"`\n\tShortSHA    string     `json:\"short_sha\"`\n\tUser        *EventUser `json:\"user\"`\n\tUserURL     string     `json:\"user_url\"`\n\tCommitURL   string     `json:\"commit_url\"`\n\tCommitTitle string     `json:\"commit_title\"`\n}\n\n// FeatureFlagEvent represents a feature flag event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#feature-flag-events\ntype FeatureFlagEvent struct {\n\tObjectKind string `json:\"object_kind\"`\n\tProject    struct {\n\t\tID                int     `json:\"id\"`\n\t\tName              string  `json:\"name\"`\n\t\tDescription       string  `json:\"description\"`\n\t\tWebURL            string  `json:\"web_url\"`\n\t\tAvatarURL         *string `json:\"avatar_url\"`\n\t\tGitSSHURL         string  `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string  `json:\"git_http_url\"`\n\t\tNamespace         string  `json:\"namespace\"`\n\t\tVisibilityLevel   int     `json:\"visibility_level\"`\n\t\tPathWithNamespace string  `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string  `json:\"default_branch\"`\n\t\tCIConfigPath      string  `json:\"ci_config_path\"`\n\t\tHomepage          string  `json:\"homepage\"`\n\t\tURL               string  `json:\"url\"`\n\t\tSSHURL            string  `json:\"ssh_url\"`\n\t\tHTTPURL           string  `json:\"http_url\"`\n\t} `json:\"project\"`\n\tUser             *EventUser `json:\"user\"`\n\tUserURL          string     `json:\"user_url\"`\n\tObjectAttributes struct {\n\t\tID          int    `json:\"id\"`\n\t\tName        string `json:\"name\"`\n\t\tDescription string `json:\"description\"`\n\t\tActive      bool   `json:\"active\"`\n\t} `json:\"object_attributes\"`\n}\n\n// GroupResourceAccessTokenEvent represents a resource access token event for a\n// group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#project-and-group-access-token-events\ntype GroupResourceAccessTokenEvent struct {\n\tEventName  string `json:\"event_name\"`\n\tObjectKind string `json:\"object_kind\"`\n\tGroup      struct {\n\t\tGroupID   int    `json:\"group_id\"`\n\t\tGroupName string `json:\"group_name\"`\n\t\tGroupPath string `json:\"group_path\"`\n\t} `json:\"group\"`\n\tObjectAttributes struct {\n\t\tID        int      `json:\"id\"`\n\t\tUserID    int      `json:\"user_id\"`\n\t\tName      string   `json:\"name\"`\n\t\tCreatedAt string   `json:\"created_at\"`\n\t\tExpiresAt *ISOTime `json:\"expires_at\"`\n\t} `json:\"object_attributes\"`\n}\n\n// IssueCommentEvent represents a comment on an issue event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#comment-on-an-issue\ntype IssueCommentEvent struct {\n\tObjectKind string `json:\"object_kind\"`\n\tEventType  string `json:\"event_type\"`\n\tUser       *User  `json:\"user\"`\n\tProjectID  int    `json:\"project_id\"`\n\tProject    struct {\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tRepository       *Repository `json:\"repository\"`\n\tObjectAttributes struct {\n\t\tID           int                `json:\"id\"`\n\t\tNote         string             `json:\"note\"`\n\t\tNoteableType string             `json:\"noteable_type\"`\n\t\tAuthorID     int                `json:\"author_id\"`\n\t\tCreatedAt    string             `json:\"created_at\"`\n\t\tUpdatedAt    string             `json:\"updated_at\"`\n\t\tProjectID    int                `json:\"project_id\"`\n\t\tAttachment   string             `json:\"attachment\"`\n\t\tLineCode     string             `json:\"line_code\"`\n\t\tCommitID     string             `json:\"commit_id\"`\n\t\tDiscussionID string             `json:\"discussion_id\"`\n\t\tNoteableID   int                `json:\"noteable_id\"`\n\t\tSystem       bool               `json:\"system\"`\n\t\tStDiff       []*Diff            `json:\"st_diff\"`\n\t\tDescription  string             `json:\"description\"`\n\t\tAction       CommentEventAction `json:\"action\"`\n\t\tURL          string             `json:\"url\"`\n\t} `json:\"object_attributes\"`\n\tIssue struct {\n\t\tID                  int           `json:\"id\"`\n\t\tIID                 int           `json:\"iid\"`\n\t\tProjectID           int           `json:\"project_id\"`\n\t\tMilestoneID         int           `json:\"milestone_id\"`\n\t\tAuthorID            int           `json:\"author_id\"`\n\t\tPosition            int           `json:\"position\"`\n\t\tBranchName          string        `json:\"branch_name\"`\n\t\tDescription         string        `json:\"description\"`\n\t\tState               string        `json:\"state\"`\n\t\tTitle               string        `json:\"title\"`\n\t\tLabels              []*EventLabel `json:\"labels\"`\n\t\tLastEditedAt        string        `json:\"last_edit_at\"`\n\t\tLastEditedByID      int           `json:\"last_edited_by_id\"`\n\t\tUpdatedAt           string        `json:\"updated_at\"`\n\t\tUpdatedByID         int           `json:\"updated_by_id\"`\n\t\tCreatedAt           string        `json:\"created_at\"`\n\t\tClosedAt            string        `json:\"closed_at\"`\n\t\tDueDate             *ISOTime      `json:\"due_date\"`\n\t\tURL                 string        `json:\"url\"`\n\t\tTimeEstimate        int           `json:\"time_estimate\"`\n\t\tConfidential        bool          `json:\"confidential\"`\n\t\tTotalTimeSpent      int           `json:\"total_time_spent\"`\n\t\tHumanTotalTimeSpent string        `json:\"human_total_time_spent\"`\n\t\tHumanTimeEstimate   string        `json:\"human_time_estimate\"`\n\t\tAssigneeIDs         []int         `json:\"assignee_ids\"`\n\t\tAssigneeID          int           `json:\"assignee_id\"`\n\t} `json:\"issue\"`\n}\n\n// IssueEvent represents a issue event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#issue-events\ntype IssueEvent struct {\n\tObjectKind string     `json:\"object_kind\"`\n\tEventType  string     `json:\"event_type\"`\n\tUser       *EventUser `json:\"user\"`\n\tProject    struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tRepository       *Repository `json:\"repository\"`\n\tObjectAttributes struct {\n\t\tID                  int      `json:\"id\"`\n\t\tTitle               string   `json:\"title\"`\n\t\tAssigneeIDs         []int    `json:\"assignee_ids\"`\n\t\tAssigneeID          int      `json:\"assignee_id\"`\n\t\tAuthorID            int      `json:\"author_id\"`\n\t\tProjectID           int      `json:\"project_id\"`\n\t\tCreatedAt           string   `json:\"created_at\"` // Should be *time.Time (see Gitlab issue #21468)\n\t\tUpdatedAt           string   `json:\"updated_at\"` // Should be *time.Time (see Gitlab issue #21468)\n\t\tUpdatedByID         int      `json:\"updated_by_id\"`\n\t\tLastEditedAt        string   `json:\"last_edited_at\"`\n\t\tLastEditedByID      int      `json:\"last_edited_by_id\"`\n\t\tRelativePosition    int      `json:\"relative_position\"`\n\t\tBranchName          string   `json:\"branch_name\"`\n\t\tDescription         string   `json:\"description\"`\n\t\tMilestoneID         int      `json:\"milestone_id\"`\n\t\tStateID             StateID  `json:\"state_id\"`\n\t\tConfidential        bool     `json:\"confidential\"`\n\t\tDiscussionLocked    bool     `json:\"discussion_locked\"`\n\t\tDueDate             *ISOTime `json:\"due_date\"`\n\t\tMovedToID           int      `json:\"moved_to_id\"`\n\t\tDuplicatedToID      int      `json:\"duplicated_to_id\"`\n\t\tTimeEstimate        int      `json:\"time_estimate\"`\n\t\tTotalTimeSpent      int      `json:\"total_time_spent\"`\n\t\tTimeChange          int      `json:\"time_change\"`\n\t\tHumanTotalTimeSpent string   `json:\"human_total_time_spent\"`\n\t\tHumanTimeEstimate   string   `json:\"human_time_estimate\"`\n\t\tHumanTimeChange     string   `json:\"human_time_change\"`\n\t\tWeight              int      `json:\"weight\"`\n\t\tIID                 int      `json:\"iid\"`\n\t\tURL                 string   `json:\"url\"`\n\t\tState               string   `json:\"state\"`\n\t\tAction              string   `json:\"action\"`\n\t\tSeverity            string   `json:\"severity\"`\n\t\tEscalationStatus    string   `json:\"escalation_status\"`\n\t\tEscalationPolicy    struct {\n\t\t\tID   int    `json:\"id\"`\n\t\t\tName string `json:\"name\"`\n\t\t} `json:\"escalation_policy\"`\n\t\tLabels []*EventLabel `json:\"labels\"`\n\t} `json:\"object_attributes\"`\n\tAssignee  *EventUser    `json:\"assignee\"`\n\tAssignees *[]EventUser  `json:\"assignees\"`\n\tLabels    []*EventLabel `json:\"labels\"`\n\tChanges   struct {\n\t\tAssignees struct {\n\t\t\tPrevious []*EventUser `json:\"previous\"`\n\t\t\tCurrent  []*EventUser `json:\"current\"`\n\t\t} `json:\"assignees\"`\n\t\tDescription struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"description\"`\n\t\tLabels struct {\n\t\t\tPrevious []*EventLabel `json:\"previous\"`\n\t\t\tCurrent  []*EventLabel `json:\"current\"`\n\t\t} `json:\"labels\"`\n\t\tTitle struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"title\"`\n\t\tClosedAt struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"closed_at\"`\n\t\tStateID struct {\n\t\t\tPrevious StateID `json:\"previous\"`\n\t\t\tCurrent  StateID `json:\"current\"`\n\t\t} `json:\"state_id\"`\n\t\tUpdatedAt struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"updated_at\"`\n\t\tUpdatedByID struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"updated_by_id\"`\n\t\tTotalTimeSpent struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"total_time_spent\"`\n\t} `json:\"changes\"`\n}\n\n// JobEvent represents a job event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#job-events\ntype JobEvent struct {\n\tObjectKind          string     `json:\"object_kind\"`\n\tRef                 string     `json:\"ref\"`\n\tTag                 bool       `json:\"tag\"`\n\tBeforeSHA           string     `json:\"before_sha\"`\n\tSHA                 string     `json:\"sha\"`\n\tBuildID             int        `json:\"build_id\"`\n\tBuildName           string     `json:\"build_name\"`\n\tBuildStage          string     `json:\"build_stage\"`\n\tBuildStatus         string     `json:\"build_status\"`\n\tBuildCreatedAt      string     `json:\"build_created_at\"`\n\tBuildStartedAt      string     `json:\"build_started_at\"`\n\tBuildFinishedAt     string     `json:\"build_finished_at\"`\n\tBuildDuration       float64    `json:\"build_duration\"`\n\tBuildQueuedDuration float64    `json:\"build_queued_duration\"`\n\tBuildAllowFailure   bool       `json:\"build_allow_failure\"`\n\tBuildFailureReason  string     `json:\"build_failure_reason\"`\n\tRetriesCount        int        `json:\"retries_count\"`\n\tPipelineID          int        `json:\"pipeline_id\"`\n\tProjectID           int        `json:\"project_id\"`\n\tProjectName         string     `json:\"project_name\"`\n\tUser                *EventUser `json:\"user\"`\n\tCommit              struct {\n\t\tID          int    `json:\"id\"`\n\t\tName        string `json:\"name\"`\n\t\tSHA         string `json:\"sha\"`\n\t\tMessage     string `json:\"message\"`\n\t\tAuthorName  string `json:\"author_name\"`\n\t\tAuthorEmail string `json:\"author_email\"`\n\t\tAuthorURL   string `json:\"author_url\"`\n\t\tStatus      string `json:\"status\"`\n\t\tDuration    int    `json:\"duration\"`\n\t\tStartedAt   string `json:\"started_at\"`\n\t\tFinishedAt  string `json:\"finished_at\"`\n\t} `json:\"commit\"`\n\tRepository *Repository `json:\"repository\"`\n\tRunner     struct {\n\t\tID          int      `json:\"id\"`\n\t\tActive      bool     `json:\"active\"`\n\t\tRunnerType  string   `json:\"runner_type\"`\n\t\tIsShared    bool     `json:\"is_shared\"`\n\t\tDescription string   `json:\"description\"`\n\t\tTags        []string `json:\"tags\"`\n\t} `json:\"runner\"`\n\tEnvironment struct {\n\t\tName           string `json:\"name\"`\n\t\tAction         string `json:\"action\"`\n\t\tDeploymentTier string `json:\"deployment_tier\"`\n\t} `json:\"environment\"`\n}\n\n// MemberEvent represents a member event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#group-member-events\ntype MemberEvent struct {\n\tCreatedAt    *time.Time `json:\"created_at\"`\n\tUpdatedAt    *time.Time `json:\"updated_at\"`\n\tGroupName    string     `json:\"group_name\"`\n\tGroupPath    string     `json:\"group_path\"`\n\tGroupID      int        `json:\"group_id\"`\n\tUserUsername string     `json:\"user_username\"`\n\tUserName     string     `json:\"user_name\"`\n\tUserEmail    string     `json:\"user_email\"`\n\tUserID       int        `json:\"user_id\"`\n\tGroupAccess  string     `json:\"group_access\"`\n\tGroupPlan    string     `json:\"group_plan\"`\n\tExpiresAt    *time.Time `json:\"expires_at\"`\n\tEventName    string     `json:\"event_name\"`\n}\n\n// MergeCommentEvent represents a comment on a merge event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#comment-on-a-merge-request\ntype MergeCommentEvent struct {\n\tObjectKind string     `json:\"object_kind\"`\n\tEventType  string     `json:\"event_type\"`\n\tUser       *EventUser `json:\"user\"`\n\tProjectID  int        `json:\"project_id\"`\n\tProject    struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tObjectAttributes struct {\n\t\tAttachment       string             `json:\"attachment\"`\n\t\tAuthorID         int                `json:\"author_id\"`\n\t\tChangePosition   *NotePosition      `json:\"change_position\"`\n\t\tCommitID         string             `json:\"commit_id\"`\n\t\tCreatedAt        string             `json:\"created_at\"`\n\t\tDiscussionID     string             `json:\"discussion_id\"`\n\t\tID               int                `json:\"id\"`\n\t\tLineCode         string             `json:\"line_code\"`\n\t\tNote             string             `json:\"note\"`\n\t\tNoteableID       int                `json:\"noteable_id\"`\n\t\tNoteableType     string             `json:\"noteable_type\"`\n\t\tOriginalPosition *NotePosition      `json:\"original_position\"`\n\t\tPosition         *NotePosition      `json:\"position\"`\n\t\tProjectID        int                `json:\"project_id\"`\n\t\tResolvedAt       string             `json:\"resolved_at\"`\n\t\tResolvedByID     int                `json:\"resolved_by_id\"`\n\t\tResolvedByPush   bool               `json:\"resolved_by_push\"`\n\t\tStDiff           *Diff              `json:\"st_diff\"`\n\t\tSystem           bool               `json:\"system\"`\n\t\tType             string             `json:\"type\"`\n\t\tUpdatedAt        string             `json:\"updated_at\"`\n\t\tUpdatedByID      int                `json:\"updated_by_id\"`\n\t\tDescription      string             `json:\"description\"`\n\t\tAction           CommentEventAction `json:\"action\"`\n\t\tURL              string             `json:\"url\"`\n\t} `json:\"object_attributes\"`\n\tRepository   *Repository `json:\"repository\"`\n\tMergeRequest struct {\n\t\tID                        int           `json:\"id\"`\n\t\tTargetBranch              string        `json:\"target_branch\"`\n\t\tSourceBranch              string        `json:\"source_branch\"`\n\t\tSourceProjectID           int           `json:\"source_project_id\"`\n\t\tAuthorID                  int           `json:\"author_id\"`\n\t\tAssigneeID                int           `json:\"assignee_id\"`\n\t\tAssigneeIDs               []int         `json:\"assignee_ids\"`\n\t\tTitle                     string        `json:\"title\"`\n\t\tCreatedAt                 string        `json:\"created_at\"`\n\t\tUpdatedAt                 string        `json:\"updated_at\"`\n\t\tMilestoneID               int           `json:\"milestone_id\"`\n\t\tState                     string        `json:\"state\"`\n\t\tMergeStatus               string        `json:\"merge_status\"`\n\t\tTargetProjectID           int           `json:\"target_project_id\"`\n\t\tIID                       int           `json:\"iid\"`\n\t\tDescription               string        `json:\"description\"`\n\t\tPosition                  int           `json:\"position\"`\n\t\tLabels                    []*EventLabel `json:\"labels\"`\n\t\tLockedAt                  string        `json:\"locked_at\"`\n\t\tUpdatedByID               int           `json:\"updated_by_id\"`\n\t\tMergeError                string        `json:\"merge_error\"`\n\t\tMergeParams               *MergeParams  `json:\"merge_params\"`\n\t\tMergeWhenPipelineSucceeds bool          `json:\"merge_when_pipeline_succeeds\"`\n\t\tMergeUserID               int           `json:\"merge_user_id\"`\n\t\tMergeCommitSHA            string        `json:\"merge_commit_sha\"`\n\t\tDeletedAt                 string        `json:\"deleted_at\"`\n\t\tInProgressMergeCommitSHA  string        `json:\"in_progress_merge_commit_sha\"`\n\t\tLockVersion               int           `json:\"lock_version\"`\n\t\tApprovalsBeforeMerge      string        `json:\"approvals_before_merge\"`\n\t\tRebaseCommitSHA           string        `json:\"rebase_commit_sha\"`\n\t\tTimeEstimate              int           `json:\"time_estimate\"`\n\t\tSquash                    bool          `json:\"squash\"`\n\t\tLastEditedAt              string        `json:\"last_edited_at\"`\n\t\tLastEditedByID            int           `json:\"last_edited_by_id\"`\n\t\tSource                    *Repository   `json:\"source\"`\n\t\tTarget                    *Repository   `json:\"target\"`\n\t\tLastCommit                struct {\n\t\t\tID        string     `json:\"id\"`\n\t\t\tTitle     string     `json:\"title\"`\n\t\t\tMessage   string     `json:\"message\"`\n\t\t\tTimestamp *time.Time `json:\"timestamp\"`\n\t\t\tURL       string     `json:\"url\"`\n\t\t\tAuthor    struct {\n\t\t\t\tName  string `json:\"name\"`\n\t\t\t\tEmail string `json:\"email\"`\n\t\t\t} `json:\"author\"`\n\t\t} `json:\"last_commit\"`\n\t\tWorkInProgress      bool       `json:\"work_in_progress\"`\n\t\tTotalTimeSpent      int        `json:\"total_time_spent\"`\n\t\tHeadPipelineID      int        `json:\"head_pipeline_id\"`\n\t\tAssignee            *EventUser `json:\"assignee\"`\n\t\tDetailedMergeStatus string     `json:\"detailed_merge_status\"`\n\t} `json:\"merge_request\"`\n}\n\n// MergeEvent represents a merge event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#merge-request-events\ntype MergeEvent struct {\n\tObjectKind string     `json:\"object_kind\"`\n\tEventType  string     `json:\"event_type\"`\n\tUser       *EventUser `json:\"user\"`\n\tProject    struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tCIConfigPath      string          `json:\"ci_config_path\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tObjectAttributes struct {\n\t\tID                       int          `json:\"id\"`\n\t\tTargetBranch             string       `json:\"target_branch\"`\n\t\tSourceBranch             string       `json:\"source_branch\"`\n\t\tSourceProjectID          int          `json:\"source_project_id\"`\n\t\tAuthorID                 int          `json:\"author_id\"`\n\t\tAssigneeID               int          `json:\"assignee_id\"`\n\t\tAssigneeIDs              []int        `json:\"assignee_ids\"`\n\t\tReviewerIDs              []int        `json:\"reviewer_ids\"`\n\t\tTitle                    string       `json:\"title\"`\n\t\tCreatedAt                string       `json:\"created_at\"` // Should be *time.Time (see Gitlab issue #21468)\n\t\tUpdatedAt                string       `json:\"updated_at\"` // Should be *time.Time (see Gitlab issue #21468)\n\t\tStCommits                []*Commit    `json:\"st_commits\"`\n\t\tStDiffs                  []*Diff      `json:\"st_diffs\"`\n\t\tLastEditedAt             string       `json:\"last_edited_at\"`\n\t\tLastEditedByID           int          `json:\"last_edited_by_id\"`\n\t\tMilestoneID              int          `json:\"milestone_id\"`\n\t\tStateID                  StateID      `json:\"state_id\"`\n\t\tState                    string       `json:\"state\"`\n\t\tMergeStatus              string       `json:\"merge_status\"`\n\t\tTargetProjectID          int          `json:\"target_project_id\"`\n\t\tIID                      int          `json:\"iid\"`\n\t\tDescription              string       `json:\"description\"`\n\t\tPosition                 int          `json:\"position\"`\n\t\tLockedAt                 string       `json:\"locked_at\"`\n\t\tUpdatedByID              int          `json:\"updated_by_id\"`\n\t\tMergeError               string       `json:\"merge_error\"`\n\t\tMergeParams              *MergeParams `json:\"merge_params\"`\n\t\tMergeWhenBuildSucceeds   bool         `json:\"merge_when_build_succeeds\"`\n\t\tMergeUserID              int          `json:\"merge_user_id\"`\n\t\tMergeCommitSHA           string       `json:\"merge_commit_sha\"`\n\t\tDeletedAt                string       `json:\"deleted_at\"`\n\t\tApprovalsBeforeMerge     string       `json:\"approvals_before_merge\"`\n\t\tRebaseCommitSHA          string       `json:\"rebase_commit_sha\"`\n\t\tInProgressMergeCommitSHA string       `json:\"in_progress_merge_commit_sha\"`\n\t\tLockVersion              int          `json:\"lock_version\"`\n\t\tTimeEstimate             int          `json:\"time_estimate\"`\n\t\tSource                   *Repository  `json:\"source\"`\n\t\tTarget                   *Repository  `json:\"target\"`\n\t\tHeadPipelineID           *int         `json:\"head_pipeline_id\"`\n\t\tLastCommit               struct {\n\t\t\tID        string     `json:\"id\"`\n\t\t\tMessage   string     `json:\"message\"`\n\t\t\tTitle     string     `json:\"title\"`\n\t\t\tTimestamp *time.Time `json:\"timestamp\"`\n\t\t\tURL       string     `json:\"url\"`\n\t\t\tAuthor    struct {\n\t\t\t\tName  string `json:\"name\"`\n\t\t\t\tEmail string `json:\"email\"`\n\t\t\t} `json:\"author\"`\n\t\t} `json:\"last_commit\"`\n\t\tBlockingDiscussionsResolved bool          `json:\"blocking_discussions_resolved\"`\n\t\tWorkInProgress              bool          `json:\"work_in_progress\"`\n\t\tDraft                       bool          `json:\"draft\"`\n\t\tTotalTimeSpent              int           `json:\"total_time_spent\"`\n\t\tTimeChange                  int           `json:\"time_change\"`\n\t\tHumanTotalTimeSpent         string        `json:\"human_total_time_spent\"`\n\t\tHumanTimeChange             string        `json:\"human_time_change\"`\n\t\tHumanTimeEstimate           string        `json:\"human_time_estimate\"`\n\t\tFirstContribution           bool          `json:\"first_contribution\"`\n\t\tURL                         string        `json:\"url\"`\n\t\tLabels                      []*EventLabel `json:\"labels\"`\n\t\tAction                      string        `json:\"action\"`\n\t\tDetailedMergeStatus         string        `json:\"detailed_merge_status\"`\n\t\tOldRev                      string        `json:\"oldrev\"`\n\t} `json:\"object_attributes\"`\n\tRepository *Repository   `json:\"repository\"`\n\tLabels     []*EventLabel `json:\"labels\"`\n\tChanges    struct {\n\t\tAssignees struct {\n\t\t\tPrevious []*EventUser `json:\"previous\"`\n\t\t\tCurrent  []*EventUser `json:\"current\"`\n\t\t} `json:\"assignees\"`\n\t\tReviewers struct {\n\t\t\tPrevious []*EventUser `json:\"previous\"`\n\t\t\tCurrent  []*EventUser `json:\"current\"`\n\t\t} `json:\"reviewers\"`\n\t\tDescription struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"description\"`\n\t\tDraft struct {\n\t\t\tPrevious bool `json:\"previous\"`\n\t\t\tCurrent  bool `json:\"current\"`\n\t\t} `json:\"draft\"`\n\t\tLabels struct {\n\t\t\tPrevious []*EventLabel `json:\"previous\"`\n\t\t\tCurrent  []*EventLabel `json:\"current\"`\n\t\t} `json:\"labels\"`\n\t\tLastEditedAt struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"last_edited_at\"`\n\t\tLastEditedByID struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"last_edited_by_id\"`\n\t\tMergeStatus struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"merge_status\"`\n\t\tMilestoneID struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"milestone_id\"`\n\t\tSourceBranch struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"source_branch\"`\n\t\tSourceProjectID struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"source_project_id\"`\n\t\tStateID struct {\n\t\t\tPrevious StateID `json:\"previous\"`\n\t\t\tCurrent  StateID `json:\"current\"`\n\t\t} `json:\"state_id\"`\n\t\tTargetBranch struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"target_branch\"`\n\t\tTargetProjectID struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"target_project_id\"`\n\t\tTitle struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"title\"`\n\t\tUpdatedAt struct {\n\t\t\tPrevious string `json:\"previous\"`\n\t\t\tCurrent  string `json:\"current\"`\n\t\t} `json:\"updated_at\"`\n\t\tUpdatedByID struct {\n\t\t\tPrevious int `json:\"previous\"`\n\t\t\tCurrent  int `json:\"current\"`\n\t\t} `json:\"updated_by_id\"`\n\t} `json:\"changes\"`\n\tAssignees []*EventUser `json:\"assignees\"`\n\tReviewers []*EventUser `json:\"reviewers\"`\n}\n\n// EventUser represents a user record in an event and is used as an even\n// initiator or a merge assignee.\ntype EventUser struct {\n\tID        int    `json:\"id\"`\n\tName      string `json:\"name\"`\n\tUsername  string `json:\"username\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tEmail     string `json:\"email\"`\n}\n\n// MergeParams represents the merge params.\ntype MergeParams struct {\n\tForceRemoveSourceBranch bool `json:\"force_remove_source_branch\"`\n}\n\n// UnmarshalJSON decodes the merge parameters\n//\n// This allows support of ForceRemoveSourceBranch for both type\n// bool (>11.9) and string (<11.9)\nfunc (p *MergeParams) UnmarshalJSON(b []byte) error {\n\ttype Alias MergeParams\n\traw := struct {\n\t\t*Alias\n\t\tForceRemoveSourceBranch interface{} `json:\"force_remove_source_branch\"`\n\t}{\n\t\tAlias: (*Alias)(p),\n\t}\n\n\terr := json.Unmarshal(b, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch v := raw.ForceRemoveSourceBranch.(type) {\n\tcase nil:\n\t\t// No action needed.\n\tcase bool:\n\t\tp.ForceRemoveSourceBranch = v\n\tcase string:\n\t\tp.ForceRemoveSourceBranch, err = strconv.ParseBool(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"failed to unmarshal ForceRemoveSourceBranch of type: %T\", v)\n\t}\n\n\treturn nil\n}\n\n// PipelineEvent represents a pipeline event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#pipeline-events\ntype PipelineEvent struct {\n\tObjectKind       string `json:\"object_kind\"`\n\tObjectAttributes struct {\n\t\tID             int      `json:\"id\"`\n\t\tIID            int      `json:\"iid\"`\n\t\tName           string   `json:\"name\"`\n\t\tRef            string   `json:\"ref\"`\n\t\tTag            bool     `json:\"tag\"`\n\t\tSHA            string   `json:\"sha\"`\n\t\tBeforeSHA      string   `json:\"before_sha\"`\n\t\tSource         string   `json:\"source\"`\n\t\tStatus         string   `json:\"status\"`\n\t\tDetailedStatus string   `json:\"detailed_status\"`\n\t\tStages         []string `json:\"stages\"`\n\t\tCreatedAt      string   `json:\"created_at\"`\n\t\tFinishedAt     string   `json:\"finished_at\"`\n\t\tDuration       int      `json:\"duration\"`\n\t\tQueuedDuration int      `json:\"queued_duration\"`\n\t\tURL            string   `json:\"url\"`\n\t\tVariables      []struct {\n\t\t\tKey   string `json:\"key\"`\n\t\t\tValue string `json:\"value\"`\n\t\t} `json:\"variables\"`\n\t} `json:\"object_attributes\"`\n\tMergeRequest struct {\n\t\tID                  int    `json:\"id\"`\n\t\tIID                 int    `json:\"iid\"`\n\t\tTitle               string `json:\"title\"`\n\t\tSourceBranch        string `json:\"source_branch\"`\n\t\tSourceProjectID     int    `json:\"source_project_id\"`\n\t\tTargetBranch        string `json:\"target_branch\"`\n\t\tTargetProjectID     int    `json:\"target_project_id\"`\n\t\tState               string `json:\"state\"`\n\t\tMergeRequestStatus  string `json:\"merge_status\"`\n\t\tDetailedMergeStatus string `json:\"detailed_merge_status\"`\n\t\tURL                 string `json:\"url\"`\n\t} `json:\"merge_request\"`\n\tUser    *EventUser `json:\"user\"`\n\tProject struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tCommit struct {\n\t\tID        string     `json:\"id\"`\n\t\tMessage   string     `json:\"message\"`\n\t\tTitle     string     `json:\"title\"`\n\t\tTimestamp *time.Time `json:\"timestamp\"`\n\t\tURL       string     `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t} `json:\"commit\"`\n\tSourcePipline struct {\n\t\tProject struct {\n\t\t\tID                int    `json:\"id\"`\n\t\t\tWebURL            string `json:\"web_url\"`\n\t\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t\t} `json:\"project\"`\n\t\tPipelineID int `json:\"pipeline_id\"`\n\t\tJobID      int `json:\"job_id\"`\n\t} `json:\"source_pipeline\"`\n\tBuilds []struct {\n\t\tID             int        `json:\"id\"`\n\t\tStage          string     `json:\"stage\"`\n\t\tName           string     `json:\"name\"`\n\t\tStatus         string     `json:\"status\"`\n\t\tCreatedAt      string     `json:\"created_at\"`\n\t\tStartedAt      string     `json:\"started_at\"`\n\t\tFinishedAt     string     `json:\"finished_at\"`\n\t\tDuration       float64    `json:\"duration\"`\n\t\tQueuedDuration float64    `json:\"queued_duration\"`\n\t\tFailureReason  string     `json:\"failure_reason\"`\n\t\tWhen           string     `json:\"when\"`\n\t\tManual         bool       `json:\"manual\"`\n\t\tAllowFailure   bool       `json:\"allow_failure\"`\n\t\tUser           *EventUser `json:\"user\"`\n\t\tRunner         struct {\n\t\t\tID          int      `json:\"id\"`\n\t\t\tDescription string   `json:\"description\"`\n\t\t\tActive      bool     `json:\"active\"`\n\t\t\tIsShared    bool     `json:\"is_shared\"`\n\t\t\tRunnerType  string   `json:\"runner_type\"`\n\t\t\tTags        []string `json:\"tags\"`\n\t\t} `json:\"runner\"`\n\t\tArtifactsFile struct {\n\t\t\tFilename string `json:\"filename\"`\n\t\t\tSize     int    `json:\"size\"`\n\t\t} `json:\"artifacts_file\"`\n\t\tEnvironment struct {\n\t\t\tName           string `json:\"name\"`\n\t\t\tAction         string `json:\"action\"`\n\t\t\tDeploymentTier string `json:\"deployment_tier\"`\n\t\t} `json:\"environment\"`\n\t} `json:\"builds\"`\n}\n\n// ProjectResourceAccessTokenEvent represents a resource access token event for\n// a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#project-and-group-access-token-events\ntype ProjectResourceAccessTokenEvent struct {\n\tEventName  string `json:\"event_name\"`\n\tObjectKind string `json:\"object_kind\"`\n\tProject    struct {\n\t\tID                int    `json:\"id\"`\n\t\tName              string `json:\"name\"`\n\t\tDescription       string `json:\"description\"`\n\t\tWebURL            string `json:\"web_url\"`\n\t\tAvatarURL         string `json:\"avatar_url\"`\n\t\tGitSSHURL         string `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string `json:\"git_http_url\"`\n\t\tNamespace         string `json:\"namespace\"`\n\t\tVisibilityLevel   int    `json:\"visibility_level\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string `json:\"default_branch\"`\n\t\tCIConfigPath      string `json:\"ci_config_path\"`\n\t\tHomepage          string `json:\"homepage\"`\n\t\tURL               string `json:\"url\"`\n\t\tSSHURL            string `json:\"ssh_url\"`\n\t\tHTTPURL           string `json:\"http_url\"`\n\t} `json:\"project\"`\n\tObjectAttributes struct {\n\t\tID        int      `json:\"id\"`\n\t\tUserID    int      `json:\"user_id\"`\n\t\tName      string   `json:\"name\"`\n\t\tCreatedAt string   `json:\"created_at\"`\n\t\tExpiresAt *ISOTime `json:\"expires_at\"`\n\t} `json:\"object_attributes\"`\n}\n\n// PushEvent represents a push event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#push-events\ntype PushEvent struct {\n\tObjectKind   string `json:\"object_kind\"`\n\tEventName    string `json:\"event_name\"`\n\tBefore       string `json:\"before\"`\n\tAfter        string `json:\"after\"`\n\tRef          string `json:\"ref\"`\n\tCheckoutSHA  string `json:\"checkout_sha\"`\n\tUserID       int    `json:\"user_id\"`\n\tUserName     string `json:\"user_name\"`\n\tUserUsername string `json:\"user_username\"`\n\tUserEmail    string `json:\"user_email\"`\n\tUserAvatar   string `json:\"user_avatar\"`\n\tProjectID    int    `json:\"project_id\"`\n\tProject      struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tRepository *Repository `json:\"repository\"`\n\tCommits    []*struct {\n\t\tID        string     `json:\"id\"`\n\t\tMessage   string     `json:\"message\"`\n\t\tTitle     string     `json:\"title\"`\n\t\tTimestamp *time.Time `json:\"timestamp\"`\n\t\tURL       string     `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t\tAdded    []string `json:\"added\"`\n\t\tModified []string `json:\"modified\"`\n\t\tRemoved  []string `json:\"removed\"`\n\t} `json:\"commits\"`\n\tTotalCommitsCount int `json:\"total_commits_count\"`\n}\n\n// ReleaseEvent represents a release event\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#release-events\ntype ReleaseEvent struct {\n\tID          int    `json:\"id\"`\n\tCreatedAt   string `json:\"created_at\"` // Should be *time.Time (see Gitlab issue #21468)\n\tDescription string `json:\"description\"`\n\tName        string `json:\"name\"`\n\tTag         string `json:\"tag\"`\n\tReleasedAt  string `json:\"released_at\"` // Should be *time.Time (see Gitlab issue #21468)\n\tObjectKind  string `json:\"object_kind\"`\n\tProject     struct {\n\t\tID                int     `json:\"id\"`\n\t\tName              string  `json:\"name\"`\n\t\tDescription       string  `json:\"description\"`\n\t\tWebURL            string  `json:\"web_url\"`\n\t\tAvatarURL         *string `json:\"avatar_url\"`\n\t\tGitSSHURL         string  `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string  `json:\"git_http_url\"`\n\t\tNamespace         string  `json:\"namespace\"`\n\t\tVisibilityLevel   int     `json:\"visibility_level\"`\n\t\tPathWithNamespace string  `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string  `json:\"default_branch\"`\n\t\tCIConfigPath      string  `json:\"ci_config_path\"`\n\t\tHomepage          string  `json:\"homepage\"`\n\t\tURL               string  `json:\"url\"`\n\t\tSSHURL            string  `json:\"ssh_url\"`\n\t\tHTTPURL           string  `json:\"http_url\"`\n\t} `json:\"project\"`\n\tURL    string `json:\"url\"`\n\tAction string `json:\"action\"`\n\tAssets struct {\n\t\tCount int `json:\"count\"`\n\t\tLinks []struct {\n\t\t\tID       int    `json:\"id\"`\n\t\t\tExternal bool   `json:\"external\"`\n\t\t\tLinkType string `json:\"link_type\"`\n\t\t\tName     string `json:\"name\"`\n\t\t\tURL      string `json:\"url\"`\n\t\t} `json:\"links\"`\n\t\tSources []struct {\n\t\t\tFormat string `json:\"format\"`\n\t\t\tURL    string `json:\"url\"`\n\t\t} `json:\"sources\"`\n\t} `json:\"assets\"`\n\tCommit struct {\n\t\tID        string `json:\"id\"`\n\t\tMessage   string `json:\"message\"`\n\t\tTitle     string `json:\"title\"`\n\t\tTimestamp string `json:\"timestamp\"` // Should be *time.Time (see Gitlab issue #21468)\n\t\tURL       string `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t} `json:\"commit\"`\n}\n\n// SnippetCommentEvent represents a comment on a snippet event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#comment-on-a-code-snippet\ntype SnippetCommentEvent struct {\n\tObjectKind string     `json:\"object_kind\"`\n\tEventType  string     `json:\"event_type\"`\n\tUser       *EventUser `json:\"user\"`\n\tProjectID  int        `json:\"project_id\"`\n\tProject    struct {\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tRepository       *Repository `json:\"repository\"`\n\tObjectAttributes struct {\n\t\tID           int                `json:\"id\"`\n\t\tNote         string             `json:\"note\"`\n\t\tNoteableType string             `json:\"noteable_type\"`\n\t\tAuthorID     int                `json:\"author_id\"`\n\t\tCreatedAt    string             `json:\"created_at\"`\n\t\tUpdatedAt    string             `json:\"updated_at\"`\n\t\tProjectID    int                `json:\"project_id\"`\n\t\tAttachment   string             `json:\"attachment\"`\n\t\tLineCode     string             `json:\"line_code\"`\n\t\tCommitID     string             `json:\"commit_id\"`\n\t\tNoteableID   int                `json:\"noteable_id\"`\n\t\tSystem       bool               `json:\"system\"`\n\t\tStDiff       *Diff              `json:\"st_diff\"`\n\t\tDescription  string             `json:\"description\"`\n\t\tAction       CommentEventAction `json:\"action\"`\n\t\tURL          string             `json:\"url\"`\n\t} `json:\"object_attributes\"`\n\tSnippet *struct {\n\t\tID                 int    `json:\"id\"`\n\t\tTitle              string `json:\"title\"`\n\t\tContent            string `json:\"content\"`\n\t\tAuthorID           int    `json:\"author_id\"`\n\t\tProjectID          int    `json:\"project_id\"`\n\t\tCreatedAt          string `json:\"created_at\"`\n\t\tUpdatedAt          string `json:\"updated_at\"`\n\t\tFilename           string `json:\"file_name\"`\n\t\tExpiresAt          string `json:\"expires_at\"`\n\t\tType               string `json:\"type\"`\n\t\tVisibilityLevel    int    `json:\"visibility_level\"`\n\t\tDescription        string `json:\"description\"`\n\t\tSecret             bool   `json:\"secret\"`\n\t\tRepositoryReadOnly bool   `json:\"repository_read_only\"`\n\t} `json:\"snippet\"`\n}\n\n// SubGroupEvent represents a subgroup event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#subgroup-events\ntype SubGroupEvent struct {\n\tCreatedAt      *time.Time `json:\"created_at\"`\n\tUpdatedAt      *time.Time `json:\"updated_at\"`\n\tEventName      string     `json:\"event_name\"`\n\tName           string     `json:\"name\"`\n\tPath           string     `json:\"path\"`\n\tFullPath       string     `json:\"full_path\"`\n\tGroupID        int        `json:\"group_id\"`\n\tParentGroupID  int        `json:\"parent_group_id\"`\n\tParentName     string     `json:\"parent_name\"`\n\tParentPath     string     `json:\"parent_path\"`\n\tParentFullPath string     `json:\"parent_full_path\"`\n}\n\n// TagEvent represents a tag event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#tag-events\ntype TagEvent struct {\n\tObjectKind   string `json:\"object_kind\"`\n\tEventName    string `json:\"event_name\"`\n\tBefore       string `json:\"before\"`\n\tAfter        string `json:\"after\"`\n\tRef          string `json:\"ref\"`\n\tCheckoutSHA  string `json:\"checkout_sha\"`\n\tUserID       int    `json:\"user_id\"`\n\tUserName     string `json:\"user_name\"`\n\tUserUsername string `json:\"user_username\"`\n\tUserAvatar   string `json:\"user_avatar\"`\n\tUserEmail    string `json:\"user_email\"`\n\tProjectID    int    `json:\"project_id\"`\n\tMessage      string `json:\"message\"`\n\tProject      struct {\n\t\tID                int             `json:\"id\"`\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tRepository *Repository `json:\"repository\"`\n\tCommits    []*struct {\n\t\tID        string     `json:\"id\"`\n\t\tMessage   string     `json:\"message\"`\n\t\tTitle     string     `json:\"title\"`\n\t\tTimestamp *time.Time `json:\"timestamp\"`\n\t\tURL       string     `json:\"url\"`\n\t\tAuthor    struct {\n\t\t\tName  string `json:\"name\"`\n\t\t\tEmail string `json:\"email\"`\n\t\t} `json:\"author\"`\n\t\tAdded    []string `json:\"added\"`\n\t\tModified []string `json:\"modified\"`\n\t\tRemoved  []string `json:\"removed\"`\n\t} `json:\"commits\"`\n\tTotalCommitsCount int `json:\"total_commits_count\"`\n}\n\n// WikiPageEvent represents a wiki page event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#wiki-page-events\ntype WikiPageEvent struct {\n\tObjectKind string     `json:\"object_kind\"`\n\tUser       *EventUser `json:\"user\"`\n\tProject    struct {\n\t\tName              string          `json:\"name\"`\n\t\tDescription       string          `json:\"description\"`\n\t\tAvatarURL         string          `json:\"avatar_url\"`\n\t\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string          `json:\"git_http_url\"`\n\t\tNamespace         string          `json:\"namespace\"`\n\t\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string          `json:\"default_branch\"`\n\t\tHomepage          string          `json:\"homepage\"`\n\t\tURL               string          `json:\"url\"`\n\t\tSSHURL            string          `json:\"ssh_url\"`\n\t\tHTTPURL           string          `json:\"http_url\"`\n\t\tWebURL            string          `json:\"web_url\"`\n\t\tVisibility        VisibilityValue `json:\"visibility\"`\n\t} `json:\"project\"`\n\tWiki struct {\n\t\tWebURL            string `json:\"web_url\"`\n\t\tGitSSHURL         string `json:\"git_ssh_url\"`\n\t\tGitHTTPURL        string `json:\"git_http_url\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t\tDefaultBranch     string `json:\"default_branch\"`\n\t} `json:\"wiki\"`\n\tObjectAttributes struct {\n\t\tTitle   string `json:\"title\"`\n\t\tContent string `json:\"content\"`\n\t\tFormat  string `json:\"format\"`\n\t\tMessage string `json:\"message\"`\n\t\tSlug    string `json:\"slug\"`\n\t\tURL     string `json:\"url\"`\n\t\tAction  string `json:\"action\"`\n\t\tDiffURL string `json:\"diff_url\"`\n\t} `json:\"object_attributes\"`\n}\n\n// EventLabel represents a label inside a webhook event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#issue-events\ntype EventLabel struct {\n\tID          int    `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tColor       string `json:\"color\"`\n\tProjectID   int    `json:\"project_id\"`\n\tCreatedAt   string `json:\"created_at\"`\n\tUpdatedAt   string `json:\"updated_at\"`\n\tTemplate    bool   `json:\"template\"`\n\tDescription string `json:\"description\"`\n\tType        string `json:\"type\"`\n\tGroupID     int    `json:\"group_id\"`\n}\n"
        },
        {
          "name": "event_webhook_types_test.go",
          "type": "blob",
          "size": 38.61328125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nconst (\n\tExpectedGroup     = \"webhook-test\"\n\texcpectedAvatar   = \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\\u0026d=identicon\"\n\texpectedEmail     = \"user1@example.com\"\n\texpectedEventName = \"user_add_to_group\"\n\texpectedID        = 1\n\texpectedName      = \"User1\"\n\texpectedUsername  = \"user1\"\n)\n\nfunc TestBuildEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/build.json\")\n\n\tvar event *BuildEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Build Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Build Event is null\")\n\t}\n\n\tif event.BuildID != 1977 {\n\t\tt.Errorf(\"BuildID is %v, want %v\", event.BuildID, 1977)\n\t}\n\n\tif event.User.ID != 42 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 42)\n\t}\n\n\tif event.User.Name != expectedName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, expectedName)\n\t}\n\n\tif event.BuildCreatedAt != \"2021-02-23T02:41:37.886Z\" {\n\t\tt.Errorf(\"BuildCreatedAt is %s, want 2021-02-23T02:41:37.886Z\", event.BuildCreatedAt)\n\t}\n}\n\nfunc TestCommitCommentEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/note_commit.json\")\n\n\tvar event *CommitCommentEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Commit Comment Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Commit Comment Event is null\")\n\t}\n\n\tif event.ObjectKind != string(NoteEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, NoteEventTargetType)\n\t}\n\n\tif event.EventType != \"note\" {\n\t\tt.Errorf(\"EventType is %v, want %v\", event.EventType, \"note\")\n\t}\n\n\tif event.ProjectID != 5 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 5)\n\t}\n\n\tif event.User.ID != 42 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 42)\n\t}\n\n\tif event.Repository.Name != \"Gitlab Test\" {\n\t\tt.Errorf(\"Repository name is %v, want %v\", event.Repository.Name, \"Gitlab Test\")\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"Commit\" {\n\t\tt.Errorf(\"NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"Commit\")\n\t}\n\n\tif event.ObjectAttributes.Action != CommentEventActionCreate {\n\t\tt.Errorf(\"Action is %v, want %v\", event.ObjectAttributes.Action, \"create\")\n\t}\n\n\tif event.Commit.Title != \"Add submodule\" {\n\t\tt.Errorf(\"Issue title is %v, want %v\", event.Commit.Title, \"Add submodule\")\n\t}\n}\n\nfunc TestJobEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/job.json\")\n\n\tvar event *JobEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Job Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Job Event is null\")\n\t}\n\n\texpectedEvent := JobEvent{\n\t\tObjectKind:          \"build\",\n\t\tRef:                 \"main\",\n\t\tTag:                 false,\n\t\tBeforeSHA:           \"0000000000000000000000000000000000000000\",\n\t\tSHA:                 \"95d49d1efbd941908580e79d65e4b5ecaf4a8305\",\n\t\tBuildID:             3580121225,\n\t\tBuildName:           \"auto_deploy:start\",\n\t\tBuildStage:          \"coordinated:tag\",\n\t\tBuildStatus:         \"success\",\n\t\tBuildCreatedAt:      \"2023-01-10 13:50:02 UTC\",\n\t\tBuildStartedAt:      \"2023-01-10 13:50:05 UTC\",\n\t\tBuildFinishedAt:     \"2023-01-10 13:50:54 UTC\",\n\t\tBuildDuration:       49.503592,\n\t\tBuildQueuedDuration: 0.193009,\n\t\tBuildAllowFailure:   false,\n\t\tBuildFailureReason:  \"unknown_failure\",\n\t\tRetriesCount:        1,\n\t\tPipelineID:          743121198,\n\t\tProjectID:           31537070,\n\t\tProjectName:         \"John Smith / release-tools-fake\",\n\t\tUser: &EventUser{\n\t\t\tID:        2967854,\n\t\t\tName:      \"John Smith\",\n\t\t\tUsername:  \"jsmithy2\",\n\t\t\tAvatarURL: \"https://gitlab.com/uploads/-/system/user/avatar/2967852/avatar.png\",\n\t\t\tEmail:     \"john@smith.com\",\n\t\t},\n\t\tRepository: &Repository{\n\t\t\tName:              \"release-tools-fake\",\n\t\t\tDescription:       \"\",\n\t\t\tWebURL:            \"\",\n\t\t\tAvatarURL:         \"\",\n\t\t\tGitSSHURL:         \"git@gitlab.com:jsmithy2/release-tools-fake.git\",\n\t\t\tGitHTTPURL:        \"https://gitlab.com/jsmithy2/release-tools-fake.git\",\n\t\t\tNamespace:         \"\",\n\t\t\tVisibility:        \"\",\n\t\t\tPathWithNamespace: \"\",\n\t\t\tDefaultBranch:     \"\",\n\t\t\tHomepage:          \"https://gitlab.com/jsmithy2/release-tools-fake\",\n\t\t\tURL:               \"git@gitlab.com:jsmithy2/release-tools-fake.git\",\n\t\t\tSSHURL:            \"\",\n\t\t\tHTTPURL:           \"\",\n\t\t},\n\t}\n\texpectedEvent.Commit.ID = 743121198\n\texpectedEvent.Commit.Name = \"Build pipeline\"\n\texpectedEvent.Commit.SHA = \"95d49d1efbd941908580e79d65e4b5ecaf4a8305\"\n\texpectedEvent.Commit.Message = \"Remove test jobs and add back other jobs\"\n\texpectedEvent.Commit.AuthorName = \"John Smith\"\n\texpectedEvent.Commit.AuthorEmail = \"john@smith.com\"\n\texpectedEvent.Commit.AuthorURL = \"https://gitlab.com/jsmithy2\"\n\texpectedEvent.Commit.Status = \"running\"\n\texpectedEvent.Commit.Duration = 128\n\texpectedEvent.Commit.StartedAt = \"2023-01-10 13:50:05 UTC\"\n\texpectedEvent.Commit.FinishedAt = \"2022-10-12 08:09:29 UTC\"\n\n\texpectedEvent.Runner.ID = 12270837\n\texpectedEvent.Runner.Description = \"4-blue.shared.runners-manager.gitlab.com/default\"\n\texpectedEvent.Runner.RunnerType = \"instance_type\"\n\texpectedEvent.Runner.Active = true\n\texpectedEvent.Runner.IsShared = true\n\texpectedEvent.Runner.Tags = []string{\"linux\", \"docker\"}\n\n\texpectedEvent.Environment.Name = \"production\"\n\texpectedEvent.Environment.Action = \"start\"\n\texpectedEvent.Environment.DeploymentTier = \"production\"\n\n\tassert.Equal(t, expectedEvent, *event, \"event should be equal to the expected one\")\n}\n\nfunc TestDeploymentEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/deployment.json\")\n\n\tvar event *DeploymentEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Deployment Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Deployment Event is null\")\n\t}\n\n\tif event.Project.ID != 30 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 30)\n\t}\n\n\tif event.User.ID != 42 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 42)\n\t}\n\n\tif event.User.Name != expectedName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, expectedName)\n\t}\n\n\tif event.CommitTitle != \"Add new file\" {\n\t\tt.Errorf(\"CommitTitle is %s, want %s\", event.CommitTitle, \"Add new file\")\n\t}\n\n\tif event.Ref != \"1.0.0\" {\n\t\tt.Errorf(\"Ref is %s, want %s\", event.Ref, \"1.0.0\")\n\t}\n\n\tif event.StatusChangedAt != \"2021-04-28 21:50:00 +0200\" {\n\t\tt.Errorf(\"StatusChangedAt is %s, want %s\", event.StatusChangedAt, \"2021-04-28 21:50:00 +0200\")\n\t}\n\n\tif event.DeploymentID != 15 {\n\t\tt.Errorf(\"DeploymentID is %d, want %d\", event.DeploymentID, 15)\n\t}\n\n\tif event.EnvironmentSlug != \"staging\" {\n\t\tt.Errorf(\"EnvironmentSlug is %s, want %s\", event.EnvironmentSlug, \"staging\")\n\t}\n\n\tif event.EnvironmentExternalURL != \"https://staging.example.com\" {\n\t\tt.Errorf(\"EnvironmentExternalURL is %s, want %s\", event.EnvironmentExternalURL, \"https://staging.example.com\")\n\t}\n}\n\nfunc TestFeatureFlagEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/feature_flag.json\")\n\n\tvar event *FeatureFlagEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"FeatureFlag Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"FeatureFlag Event is null\")\n\t}\n\n\tif event.ObjectKind != \"feature_flag\" {\n\t\tt.Errorf(\"ObjectKind is %s, want %s\", event.ObjectKind, \"feature_flag\")\n\t}\n\n\tif event.Project.ID != 1 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 1)\n\t}\n\n\tif event.User.ID != 1 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 1)\n\t}\n\n\tif event.User.Name != \"Administrator\" {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, \"Administrator\")\n\t}\n\n\tif event.ObjectAttributes.ID != 6 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %d, want %d\", event.ObjectAttributes.ID, 6)\n\t}\n\n\tif event.ObjectAttributes.Name != \"test-feature-flag\" {\n\t\tt.Errorf(\"ObjectAttributes.Name is %s, want %s\", event.ObjectAttributes.Name, \"test-feature-flag\")\n\t}\n\n\tif event.ObjectAttributes.Description != \"test-feature-flag-description\" {\n\t\tt.Errorf(\"ObjectAttributes.Description is %s, want %s\", event.ObjectAttributes.Description, \"test-feature-flag-description\")\n\t}\n\n\tif event.ObjectAttributes.Active != true {\n\t\tt.Errorf(\"ObjectAttributes.Active is %t, want %t\", event.ObjectAttributes.Active, true)\n\t}\n}\n\nfunc TestGroupResourceAccessTokenEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/resource_access_token_group.json\")\n\tvar event *GroupResourceAccessTokenEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"could not unmarshal event: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"event is null\")\n\t}\n\n\texpiresAt, err := ParseISOTime(\"2024-01-26\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not parse ISO time: %v\", err)\n\t}\n\n\texpected := &GroupResourceAccessTokenEvent{\n\t\tObjectKind: \"access_token\",\n\t\tEventName:  \"expiring_access_token\",\n\t}\n\n\texpected.Group.GroupID = 35\n\texpected.Group.GroupName = \"Twitter\"\n\texpected.Group.GroupPath = \"twitter\"\n\n\texpected.ObjectAttributes.ID = 25\n\texpected.ObjectAttributes.UserID = 90\n\texpected.ObjectAttributes.Name = \"acd\"\n\texpected.ObjectAttributes.CreatedAt = \"2024-01-24 16:27:40 UTC\"\n\texpected.ObjectAttributes.ExpiresAt = &expiresAt\n\n\tassert.Equal(t, expected, event)\n}\n\nfunc TestIssueCommentEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/note_issue.json\")\n\n\tvar event *IssueCommentEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Issue Comment Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event.ObjectKind != string(NoteEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, NoteEventTargetType)\n\t}\n\n\tif event.EventType != \"note\" {\n\t\tt.Errorf(\"EventType is %v, want %v\", event.EventType, \"note\")\n\t}\n\n\tif event.ProjectID != 5 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 5)\n\t}\n\n\tif event.User.ID != 42 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 42)\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"Issue\" {\n\t\tt.Errorf(\"NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"Issue\")\n\t}\n\n\tif event.ObjectAttributes.Action != CommentEventActionCreate {\n\t\tt.Errorf(\"Action is %v, want %v\", event.ObjectAttributes.Action, \"create\")\n\t}\n\n\tif event.Issue.Title != \"test_issue\" {\n\t\tt.Errorf(\"Issue title is %v, want %v\", event.Issue.Title, \"test_issue\")\n\t}\n\n\tif event.Issue.Position != 0 {\n\t\tt.Errorf(\"Issue position is %v, want %v\", event.Issue.Position, 0)\n\t}\n\n\tif event.Issue.BranchName != \"\" {\n\t\tt.Errorf(\"Issue branch name is %v, want %v\", event.Issue.BranchName, \"\")\n\t}\n\n\tif len(event.Issue.Labels) == 0 || event.Issue.Labels[0].ID != 25 {\n\t\tt.Errorf(\"Label id is null\")\n\t}\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          25,\n\t\t\tTitle:       \"Afterpod\",\n\t\t\tColor:       \"#3e8068\",\n\t\t\tProjectID:   0,\n\t\t\tCreatedAt:   \"2019-06-05T14:32:20.211Z\",\n\t\t\tUpdatedAt:   \"2019-06-05T14:32:20.211Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"\",\n\t\t\tType:        \"GroupLabel\",\n\t\t\tGroupID:     4,\n\t\t},\n\t\t{\n\t\t\tID:          86,\n\t\t\tTitle:       \"Element\",\n\t\t\tColor:       \"#231afe\",\n\t\t\tProjectID:   4,\n\t\t\tCreatedAt:   \"2019-06-05T14:32:20.637Z\",\n\t\t\tUpdatedAt:   \"2019-06-05T14:32:20.637Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     0,\n\t\t},\n\t}, event.Issue.Labels)\n}\n\nfunc TestIssueEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/issue.json\")\n\n\tvar event *IssueEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Issue Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event.ObjectKind != string(IssueEventTargetType) {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, IssueEventTargetType)\n\t}\n\n\tif event.EventType != \"issue\" {\n\t\tt.Errorf(\"EventType is %v, want %v\", event.EventType, \"issue\")\n\t}\n\n\tif event.Project.ID != 1 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 1)\n\t}\n\n\tif event.User.ID != 1 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 1)\n\t}\n\n\tif event.Assignee.Username != \"user1\" {\n\t\tt.Errorf(\"Assignee username is %s, want %s\", event.Assignee.Username, \"user1\")\n\t}\n\n\tif event.ObjectAttributes.ID != 301 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %v, want %v\", event.ObjectAttributes.ID, 301)\n\t}\n\n\tif event.ObjectAttributes.Title != \"New API: create/update/delete file\" {\n\t\tt.Errorf(\"ObjectAttributes.Title is %v, want %v\", event.ObjectAttributes.Title, \"New API: create/update/delete file\")\n\t}\n\n\tif event.ObjectAttributes.StateID != StateIDOpen {\n\t\tt.Errorf(\"ObjectAttributes.StateID is %v, want %v\", event.ObjectAttributes.StateID, StateIDOpen)\n\t}\n\n\tif event.ObjectAttributes.State != \"opened\" {\n\t\tt.Errorf(\"ObjectAttributes.State is %v, want %v\", event.ObjectAttributes.State, \"opened\")\n\t}\n\tif event.ObjectAttributes.Confidential != false {\n\t\tt.Errorf(\"ObjectAttributes.Confidential is %v, want %v\", event.ObjectAttributes.Confidential, false)\n\t}\n\n\tif event.ObjectAttributes.TotalTimeSpent != 0 {\n\t\tt.Errorf(\"ObjectAttributes.TotalTimeSpent is %v, want %v\", event.ObjectAttributes.TotalTimeSpent, 0)\n\t}\n\n\tif event.ObjectAttributes.Action != \"open\" {\n\t\tt.Errorf(\"ObjectAttributes.Action is %v, want %v\", event.ObjectAttributes.Action, \"open\")\n\t}\n\n\tif event.ObjectAttributes.EscalationStatus != \"triggered\" {\n\t\tt.Errorf(\"ObjectAttributes.EscalationStatus is %v, want %v\", event.ObjectAttributes.EscalationStatus, \"triggered\")\n\t}\n\n\tif event.ObjectAttributes.EscalationPolicy.ID != 18 {\n\t\tt.Errorf(\"ObjectAttributes.EscalationPolicy.ID is %v, want %v\", event.ObjectAttributes.EscalationPolicy.ID, 18)\n\t}\n\n\tif event.Changes.TotalTimeSpent.Previous != 8100 {\n\t\tt.Errorf(\"Changes.TotalTimeSpent.Previous is %v , want %v\", event.Changes.TotalTimeSpent.Previous, 8100)\n\t}\n\n\tif event.Changes.TotalTimeSpent.Current != 9900 {\n\t\tt.Errorf(\"Changes.TotalTimeSpent.Current is %v , want %v\", event.Changes.TotalTimeSpent.Current, 8100)\n\t}\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          206,\n\t\t\tTitle:       \"API\",\n\t\t\tColor:       \"#ffffff\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"API related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.Labels)\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          206,\n\t\t\tTitle:       \"API\",\n\t\t\tColor:       \"#ffffff\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"API related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.Changes.Labels.Previous)\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          205,\n\t\t\tTitle:       \"Platform\",\n\t\t\tColor:       \"#123123\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"Platform related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.Changes.Labels.Current)\n\n\tassert.Equal(t, \"2017-09-15 16:54:55 UTC\", event.Changes.ClosedAt.Previous)\n\tassert.Equal(t, \"2017-09-15 16:56:00 UTC\", event.Changes.ClosedAt.Current)\n\n\tassert.Equal(t, StateIDNone, event.Changes.StateID.Previous)\n\tassert.Equal(t, StateIDOpen, event.Changes.StateID.Current)\n\n\tassert.Equal(t, \"2017-09-15 16:50:55 UTC\", event.Changes.UpdatedAt.Previous)\n\tassert.Equal(t, \"2017-09-15 16:52:00 UTC\", event.Changes.UpdatedAt.Current)\n}\n\n// Generate unit test for MergeCommentEvent\nfunc TestMergeCommentEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/note_merge_request.json\")\n\n\tvar event *MergeCommentEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Merge Comment Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Merge Comment Event is null\")\n\t}\n\n\tif event.ObjectAttributes.ID != 1244 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %v, want %v\", event.ObjectAttributes.ID, 1244)\n\t}\n\n\tif event.ObjectAttributes.Note != \"This MR needs work.\" {\n\t\tt.Errorf(\"ObjectAttributes.Note is %v, want %v\", event.ObjectAttributes.Note, \"This MR needs work.\")\n\t}\n\n\tif event.ObjectAttributes.NoteableType != \"MergeRequest\" {\n\t\tt.Errorf(\"ObjectAttributes.NoteableType is %v, want %v\", event.ObjectAttributes.NoteableType, \"MergeRequest\")\n\t}\n\n\tif event.ObjectAttributes.Action != CommentEventActionCreate {\n\t\tt.Errorf(\"Action is %v, want %v\", event.ObjectAttributes.Action, \"create\")\n\t}\n\n\tif event.ObjectAttributes.AuthorID != 1 {\n\t\tt.Errorf(\"ObjectAttributes.AuthorID is %v, want %v\", event.ObjectAttributes.AuthorID, 1)\n\t}\n\n\tif event.ObjectAttributes.CreatedAt != \"2015-05-17 18:21:36 UTC\" {\n\t\tt.Errorf(\"ObjectAttributes.CreatedAt is %v, want %v\", event.ObjectAttributes.CreatedAt, \"2015-05-17 18:21:36 UTC\")\n\t}\n\n\tif event.ObjectAttributes.UpdatedAt != \"2015-05-17 18:21:36 UTC\" {\n\t\tt.Errorf(\"ObjectAttributes.UpdatedAt is %v, want %v\", event.ObjectAttributes.UpdatedAt, \"2015-05-17 18:21:36 UTC\")\n\t}\n\n\tif event.ObjectAttributes.ProjectID != 5 {\n\t\tt.Errorf(\"ObjectAttributes.ProjectID is %v, want %v\", event.ObjectAttributes.ProjectID, 5)\n\t}\n\n\tif event.MergeRequest.ID != 7 {\n\t\tt.Errorf(\"MergeRequest.ID is %v, want %v\", event.MergeRequest.ID, 7)\n\t}\n\n\tif event.MergeRequest.TargetBranch != \"markdown\" {\n\t\tt.Errorf(\"MergeRequest.TargetBranch is %v, want %v\", event.MergeRequest.TargetBranch, \"markdown\")\n\t}\n\n\t// generate test code for rest of the event.MergeRequest fields\n\tif event.MergeRequest.SourceBranch != \"master\" {\n\t\tt.Errorf(\"MergeRequest.SourceBranch is %v, want %v\", event.MergeRequest.SourceBranch, \"ms-viewport\")\n\t}\n\n\tif event.MergeRequest.SourceProjectID != 5 {\n\t\tt.Errorf(\"MergeRequest.SourceProjectID is %v, want %v\", event.MergeRequest.SourceProjectID, 5)\n\t}\n\n\tif event.MergeRequest.AuthorID != 8 {\n\t\tt.Errorf(\"MergeRequest.AuthorID is %v, want %v\", event.MergeRequest.AuthorID, 8)\n\t}\n\n\tif event.MergeRequest.AssigneeID != 28 {\n\t\tt.Errorf(\"MergeRequest.AssigneeID is %v, want %v\", event.MergeRequest.AssigneeID, 28)\n\t}\n\n\tif event.MergeRequest.State != \"opened\" {\n\t\tt.Errorf(\"MergeRequest.state is %v, want %v\", event.MergeRequest.State, \"opened\")\n\t}\n\n\tif event.MergeRequest.MergeStatus != \"cannot_be_merged\" {\n\t\tt.Errorf(\"MergeRequest.merge_status is %v, want %v\", event.MergeRequest.MergeStatus, \"cannot_be_merged\")\n\t}\n\n\tif event.MergeRequest.TargetProjectID != 5 {\n\t\tt.Errorf(\"MergeRequest.target_project_id is %v, want %v\", event.MergeRequest.TargetProjectID, 5)\n\t}\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          206,\n\t\t\tTitle:       \"Afterpod\",\n\t\t\tColor:       \"#3e8068\",\n\t\t\tProjectID:   0,\n\t\t\tCreatedAt:   \"2019-06-05T14:32:20.211Z\",\n\t\t\tUpdatedAt:   \"2019-06-05T14:32:20.211Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"\",\n\t\t\tType:        \"GroupLabel\",\n\t\t\tGroupID:     4,\n\t\t},\n\t\t{\n\t\t\tID:          86,\n\t\t\tTitle:       \"Element\",\n\t\t\tColor:       \"#231afe\",\n\t\t\tProjectID:   4,\n\t\t\tCreatedAt:   \"2019-06-05T14:32:20.637Z\",\n\t\t\tUpdatedAt:   \"2019-06-05T14:32:20.637Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     0,\n\t\t},\n\t}, event.MergeRequest.Labels)\n\n\tassert.Equal(t, &EventUser{\n\t\tID:        0,\n\t\tName:      \"User1\",\n\t\tUsername:  \"user1\",\n\t\tAvatarURL: \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=40\\u0026d=identicon\",\n\t\tEmail:     \"\",\n\t}, event.MergeRequest.Assignee)\n\n\tif event.MergeRequest.DetailedMergeStatus != \"checking\" {\n\t\tt.Errorf(\"MergeRequest.DetailedMergeStatus is %v, want %v\", event.MergeRequest.DetailedMergeStatus, \"checking\")\n\t}\n}\n\nfunc TestMergeEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/merge_request.json\")\n\n\tvar event *MergeEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Merge Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Merge Event is null\")\n\t}\n\n\tif event.EventType != \"merge_request\" {\n\t\tt.Errorf(\"EventType is %v, want %v\", event.EventType, \"merge_request\")\n\t}\n\n\tif event.Project.CIConfigPath != \"\" {\n\t\tt.Errorf(\"Project.CIConfigPath is %v, want %v\", event.Project.CIConfigPath, \"\")\n\t}\n\n\tif event.ObjectAttributes.ID != 99 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %v, want %v\", event.ObjectAttributes.ID, 99)\n\t}\n\n\tif event.ObjectAttributes.Source.Homepage != \"http://example.com/awesome_space/awesome_project\" {\n\t\tt.Errorf(\"ObjectAttributes.Source.Homepage is %v, want %v\", event.ObjectAttributes.Source.Homepage, \"http://example.com/awesome_space/awesome_project\")\n\t}\n\n\tif event.ObjectAttributes.LastCommit.ID != \"da1560886d4f094c3e6c9ef40349f7d38b5d27d7\" {\n\t\tt.Errorf(\"ObjectAttributes.LastCommit.ID is %v, want %s\", event.ObjectAttributes.LastCommit.ID, \"da1560886d4f094c3e6c9ef40349f7d38b5d27d7\")\n\t}\n\n\tif event.ObjectAttributes.TotalTimeSpent != 0 {\n\t\tt.Errorf(\"ObjectAttributes.TotalTimeSpent is %v, want %v\", event.ObjectAttributes.TotalTimeSpent, 0)\n\t}\n\n\tif event.ObjectAttributes.TimeChange != 0 {\n\t\tt.Errorf(\"ObjectAttributes.TimeChange is %v, want %v\", event.ObjectAttributes.TimeChange, 0)\n\t}\n\n\tif event.ObjectAttributes.HumanTotalTimeSpent != \"30m\" {\n\t\tt.Errorf(\"ObjectAttributes.HumanTotalTimeSpent is %v, want %v\", event.ObjectAttributes.HumanTotalTimeSpent, \"30m\")\n\t}\n\n\tif event.ObjectAttributes.HumanTimeChange != \"30m\" {\n\t\tt.Errorf(\"ObjectAttributes.HumanTimeChange is %v, want %v\", event.ObjectAttributes.HumanTimeChange, \"30m\")\n\t}\n\n\tif event.ObjectAttributes.HumanTimeEstimate != \"1h\" {\n\t\tt.Errorf(\"ObjectAttributes.HumanTimeEstimate is %v, want %v\", event.ObjectAttributes.HumanTimeEstimate, \"1h\")\n\t}\n\n\tif event.Assignees[0].Name != expectedName {\n\t\tt.Errorf(\"Assignee.Name is %v, want %v\", event.Assignees[0].Name, expectedName)\n\t}\n\n\tif event.Assignees[0].Username != expectedUsername {\n\t\tt.Errorf(\"ObjectAttributes is %v, want %v\", event.Assignees[0].Username, expectedUsername)\n\t}\n\n\tif event.User.ID != expectedID {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, expectedID)\n\t}\n\n\tif event.User.Name != expectedName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, expectedName)\n\t}\n\n\tif event.User.Email != expectedEmail {\n\t\tt.Errorf(\"User email is %s, want %s\", event.User.Email, expectedEmail)\n\t}\n\n\tif event.ObjectAttributes.LastCommit.Timestamp == nil {\n\t\tt.Errorf(\"Timestamp isn't nil\")\n\t}\n\n\tif name := event.ObjectAttributes.LastCommit.Author.Name; name != \"GitLab dev user\" {\n\t\tt.Errorf(\"Commit Username is %s, want %s\", name, \"GitLab dev user\")\n\t}\n\n\tif event.ObjectAttributes.BlockingDiscussionsResolved != true {\n\t\tt.Errorf(\"BlockingDiscussionsResolved isn't true\")\n\t}\n\n\tif event.ObjectAttributes.FirstContribution != true {\n\t\tt.Errorf(\"FirstContribution isn't true\")\n\t}\n\n\tif event.Assignees[0].ID != expectedID {\n\t\tt.Errorf(\"Assignees[0].ID is %v, want %v\", event.Assignees[0].ID, expectedID)\n\t}\n\n\tif event.Assignees[0].Name != expectedName {\n\t\tt.Errorf(\"Assignees[0].Name is %v, want %v\", event.Assignees[0].Name, expectedName)\n\t}\n\n\tif event.Assignees[0].Username != expectedUsername {\n\t\tt.Errorf(\"Assignees[0].Username is %v, want %v\", event.Assignees[0].Username, expectedName)\n\t}\n\n\tif event.Assignees[0].AvatarURL != excpectedAvatar {\n\t\tt.Errorf(\"Assignees[0].AvatarURL is %v, want %v\", event.Assignees[0].AvatarURL, excpectedAvatar)\n\t}\n\n\tif len(event.Reviewers) < 1 {\n\t\tt.Errorf(\"Reviewers length is %d, want %d\", len(event.Reviewers), 1)\n\t}\n\n\tif event.Reviewers[0].Name != expectedName {\n\t\tt.Errorf(\"Reviewers[0].Name is %v, want %v\", event.Reviewers[0].Name, expectedName)\n\t}\n\n\tif event.Reviewers[0].Username != expectedUsername {\n\t\tt.Errorf(\"Reviewer[0].Username is %v, want %v\", event.Reviewers[0].Username, expectedUsername)\n\t}\n\n\tif event.Reviewers[0].AvatarURL != excpectedAvatar {\n\t\tt.Errorf(\"Reviewers[0].AvatarURL is %v, want %v\", event.Reviewers[0].AvatarURL, excpectedAvatar)\n\t}\n\n\tif event.ObjectAttributes.DetailedMergeStatus != \"mergeable\" {\n\t\tt.Errorf(\"DetailedMergeStatus is %s, want %s\", event.ObjectAttributes.DetailedMergeStatus, \"mergeable\")\n\t}\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          206,\n\t\t\tTitle:       \"API\",\n\t\t\tColor:       \"#ffffff\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"API related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.Labels)\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          206,\n\t\t\tTitle:       \"API\",\n\t\t\tColor:       \"#ffffff\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"API related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.ObjectAttributes.Labels)\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          206,\n\t\t\tTitle:       \"API\",\n\t\t\tColor:       \"#ffffff\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"API related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.Changes.Labels.Previous)\n\n\tassert.Equal(t, []*EventLabel{\n\t\t{\n\t\t\tID:          205,\n\t\t\tTitle:       \"Platform\",\n\t\t\tColor:       \"#123123\",\n\t\t\tProjectID:   14,\n\t\t\tCreatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tUpdatedAt:   \"2013-12-03T17:15:43Z\",\n\t\t\tTemplate:    false,\n\t\t\tDescription: \"Platform related issues\",\n\t\t\tType:        \"ProjectLabel\",\n\t\t\tGroupID:     41,\n\t\t},\n\t}, event.Changes.Labels.Current)\n\n\tassert.Equal(t, StateIDLocked, event.Changes.StateID.Previous)\n\tassert.Equal(t, StateIDMerged, event.Changes.StateID.Current)\n\n\tassert.Equal(t, \"2017-09-15 16:50:55 UTC\", event.Changes.UpdatedAt.Previous)\n\tassert.Equal(t, \"2017-09-15 16:52:00 UTC\", event.Changes.UpdatedAt.Current)\n}\n\nfunc TestMemberEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/member.json\")\n\n\tvar event *MemberEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Member Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Member Event is null\")\n\t}\n\n\tif event.GroupName != ExpectedGroup {\n\t\tt.Errorf(\"Name is %v, want %v\", event.GroupName, ExpectedGroup)\n\t}\n\n\tif event.GroupPath != ExpectedGroup {\n\t\tt.Errorf(\"GroupPath is %v, want %v\", event.GroupPath, ExpectedGroup)\n\t}\n\n\tif event.GroupID != 100 {\n\t\tt.Errorf(\n\t\t\t\"GroupID is %v, want %v\", event.GroupID, 100)\n\t}\n\n\tif event.UserUsername != expectedUsername {\n\t\tt.Errorf(\n\t\t\t\"UserUsername is %v, want %v\", event.UserUsername, expectedUsername)\n\t}\n\n\tif event.UserName != expectedName {\n\t\tt.Errorf(\n\t\t\t\"UserName is %v, want %v\", event.UserName, expectedName)\n\t}\n\n\tif event.UserEmail != \"testuser@webhooktest.com\" {\n\t\tt.Errorf(\n\t\t\t\"UserEmail is %v, want %v\", event.UserEmail, \"testuser@webhooktest.com\")\n\t}\n\n\tif event.UserID != 64 {\n\t\tt.Errorf(\n\t\t\t\"UserID is %v, want %v\", event.UserID, 64)\n\t}\n\n\tif event.GroupAccess != \"Guest\" {\n\t\tt.Errorf(\n\t\t\t\"GroupAccess is %v, want %v\", event.GroupAccess, \"Guest\")\n\t}\n\n\tif event.EventName != expectedEventName {\n\t\tt.Errorf(\n\t\t\t\"EventName is %v, want %v\", event.EventName, expectedEventName)\n\t}\n\n\tif event.CreatedAt.Format(time.RFC3339) != \"2020-12-11T04:57:22Z\" {\n\t\tt.Errorf(\"CreatedAt is %v, want %v\", event.CreatedAt.Format(time.RFC3339), \"2020-12-11T04:57:22Z\")\n\t}\n\n\tif event.UpdatedAt.Format(time.RFC3339) != \"2020-12-11T04:57:22Z\" {\n\t\tt.Errorf(\"UpdatedAt is %v, want %v\", event.UpdatedAt.Format(time.RFC3339), \"2020-12-11T04:57:22Z\")\n\t}\n\n\tif event.ExpiresAt.Format(time.RFC3339) != \"2020-12-14T00:00:00Z\" {\n\t\tt.Errorf(\"ExpiresAt is %v, want %v\", event.ExpiresAt.Format(time.RFC3339), \"2020-12-14T00:00:00Z\")\n\t}\n}\n\nfunc TestMergeEventUnmarshalFromGroup(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/group_merge_request.json\")\n\n\tvar event *MergeEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Group Merge Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Group Merge Event is null\")\n\t}\n\n\tif event.ObjectKind != eventObjectKindMergeRequest {\n\t\tt.Errorf(\"ObjectKind is %v, want %v\", event.ObjectKind, eventObjectKindMergeRequest)\n\t}\n\n\tif event.User.Username != expectedUsername {\n\t\tt.Errorf(\"User.Username is %v, want %v\", event.User.Username, expectedUsername)\n\t}\n\n\tif event.Project.Name != exampleProjectName {\n\t\tt.Errorf(\"Project.Name is %v, want %v\", event.Project.Name, exampleProjectName)\n\t}\n\n\tif event.ObjectAttributes.ID != 15917 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %v, want %v\", event.ObjectAttributes.ID, 15917)\n\t}\n\n\tif event.ObjectAttributes.Source.Name != exampleProjectName {\n\t\tt.Errorf(\"ObjectAttributes.Source.Name is %v, want %v\", event.ObjectAttributes.Source.Name, exampleProjectName)\n\t}\n\n\tif event.ObjectAttributes.LastCommit.Author.Email != \"test.user@mail.com\" {\n\t\tt.Errorf(\"ObjectAttributes.LastCommit.Author.Email is %v, want %v\", event.ObjectAttributes.LastCommit.Author.Email, \"test.user@mail.com\")\n\t}\n\n\tif event.Repository.Name != exampleProjectName {\n\t\tt.Errorf(\"Repository.Name is %v, want %v\", event.Repository.Name, exampleProjectName)\n\t}\n\n\tif event.User.Name != expectedName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, expectedName)\n\t}\n\n\tif event.ObjectAttributes.LastCommit.Timestamp == nil {\n\t\tt.Errorf(\"Timestamp isn't nil\")\n\t}\n\n\tif name := event.ObjectAttributes.LastCommit.Author.Name; name != \"Test User\" {\n\t\tt.Errorf(\"Commit Username is %s, want %s\", name, \"Test User\")\n\t}\n}\n\nfunc TestPipelineEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/pipeline.json\")\n\n\tvar event *PipelineEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Pipeline Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Pipeline Event is null\")\n\t}\n\n\tif event.ObjectAttributes.ID != 31 {\n\t\tt.Errorf(\"ObjectAttributes.ID is %v, want %v\", event.ObjectAttributes.ID, 31)\n\t}\n\n\tif event.ObjectAttributes.IID != 123 {\n\t\tt.Errorf(\"ObjectAttributes.IID is %v, want %v\", event.ObjectAttributes.ID, 123)\n\t}\n\n\tif event.ObjectAttributes.DetailedStatus != \"passed\" {\n\t\tt.Errorf(\"ObjectAttributes.DetailedStatus is %v, want %v\", event.ObjectAttributes.DetailedStatus, \"passed\")\n\t}\n\n\tif event.ObjectAttributes.QueuedDuration != 12 {\n\t\tt.Errorf(\"ObjectAttributes.QueuedDuration is %v, want %v\", event.ObjectAttributes.QueuedDuration, 12)\n\t}\n\n\tif event.ObjectAttributes.Variables[0].Key != \"NESTOR_PROD_ENVIRONMENT\" {\n\t\tt.Errorf(\"ObjectAttributes.Variables[0].Key is %v, want %v\", event.ObjectAttributes.Variables[0].Key, \"NESTOR_PROD_ENVIRONMENT\")\n\t}\n\n\tif event.User.ID != 42 {\n\t\tt.Errorf(\"User ID is %d, want %d\", event.User.ID, 42)\n\t}\n\n\tif event.User.Name != expectedName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.User.Name, expectedName)\n\t}\n\n\tif event.Commit.Timestamp == nil {\n\t\tt.Errorf(\"Timestamp isn't nil\")\n\t}\n\n\tif name := event.Commit.Author.Name; name != \"User\" {\n\t\tt.Errorf(\"Commit Username is %s, want %s\", name, \"User\")\n\t}\n\n\tif len(event.Builds) != 5 {\n\t\tt.Errorf(\"Builds length is %d, want %d\", len(event.Builds), 5)\n\t}\n\n\tif event.Builds[0].AllowFailure != true {\n\t\tt.Errorf(\"Builds.0.AllowFailure is %v, want %v\", event.Builds[0].AllowFailure, true)\n\t}\n\n\tif event.Builds[0].Environment.Name != \"production\" {\n\t\tt.Errorf(\"Builds.0.Environment.Name is %v, want %v\", event.Builds[0].Environment.Name, \"production\")\n\t}\n\n\tif event.Builds[0].Duration != 17.1 {\n\t\tt.Errorf(\"Builds[0].Duration is %v, want %v\", event.Builds[0].Duration, 17.1)\n\t}\n\n\tif event.Builds[0].QueuedDuration != 3.5 {\n\t\tt.Errorf(\"Builds[0].QueuedDuration is %v, want %v\", event.Builds[0].QueuedDuration, 3.5)\n\t}\n\n\tif event.Builds[0].FailureReason != \"script_failure\" {\n\t\tt.Errorf(\"Builds[0].Failurereason is %v, want %v\", event.Builds[0].FailureReason, \"script_failure\")\n\t}\n\n\tif event.Builds[1].FailureReason != \"\" {\n\t\tt.Errorf(\"Builds[0].Failurereason is %v, want %v\", event.Builds[0].FailureReason, \"''\")\n\t}\n\n\tif event.SourcePipline.PipelineID != 30 {\n\t\tt.Errorf(\"Source Pipline ID is %v, want %v\", event.SourcePipline.PipelineID, 30)\n\t}\n\n\tif event.SourcePipline.JobID != 3401 {\n\t\tt.Errorf(\"Source Pipline JobID is %v, want %v\", event.SourcePipline.JobID, 3401)\n\t}\n\n\tif event.SourcePipline.Project.ID != 41 {\n\t\tt.Errorf(\"Source Pipline Project ID is %v, want %v\", event.SourcePipline.Project.ID, 41)\n\t}\n\n\tif event.MergeRequest.DetailedMergeStatus != \"mergeable\" {\n\t\tt.Errorf(\"MergeRequest.DetailedMergeStatus is %v, want %v\", event.MergeRequest.DetailedMergeStatus, \"mergeable\")\n\t}\n}\n\nfunc TestProjectResourceAccessTokenEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/resource_access_token_project.json\")\n\tvar event *ProjectResourceAccessTokenEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"could not unmarshal event: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"event is null\")\n\t}\n\n\texpiresAt, err := ParseISOTime(\"2024-01-26\")\n\tif err != nil {\n\t\tt.Fatalf(\"could not parse ISO time: %v\", err)\n\t}\n\n\texpected := &ProjectResourceAccessTokenEvent{\n\t\tObjectKind: \"access_token\",\n\t\tEventName:  \"expiring_access_token\",\n\t}\n\n\texpected.ObjectAttributes.ID = 25\n\texpected.ObjectAttributes.UserID = 90\n\texpected.ObjectAttributes.Name = \"acd\"\n\texpected.ObjectAttributes.CreatedAt = \"2024-01-24 16:27:40 UTC\"\n\texpected.ObjectAttributes.ExpiresAt = &expiresAt\n\n\texpected.Project.ID = 7\n\texpected.Project.Name = \"Flight\"\n\texpected.Project.Description = \"Eum dolore maxime atque reprehenderit voluptatem.\"\n\texpected.Project.WebURL = \"https://example.com/flightjs/Flight\"\n\texpected.Project.AvatarURL = \"\"\n\texpected.Project.GitSSHURL = \"ssh://git@example.com/flightjs/Flight.git\"\n\texpected.Project.GitHTTPURL = \"https://example.com/flightjs/Flight.git\"\n\texpected.Project.Namespace = \"Flightjs\"\n\texpected.Project.VisibilityLevel = 0\n\texpected.Project.PathWithNamespace = \"flightjs/Flight\"\n\texpected.Project.DefaultBranch = \"master\"\n\texpected.Project.CIConfigPath = \"\"\n\texpected.Project.Homepage = \"https://example.com/flightjs/Flight\"\n\texpected.Project.URL = \"ssh://git@example.com/flightjs/Flight.git\"\n\texpected.Project.SSHURL = \"ssh://git@example.com/flightjs/Flight.git\"\n\texpected.Project.HTTPURL = \"https://example.com/flightjs/Flight.git\"\n\n\tassert.Equal(t, expected, event)\n}\n\nfunc TestPushEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/push.json\")\n\tvar event *PushEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Push Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Push Event is null\")\n\t}\n\n\tif event.EventName != \"push\" {\n\t\tt.Errorf(\"EventName is %v, want %v\", event.EventName, \"push\")\n\t}\n\n\tif event.ProjectID != 15 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 15)\n\t}\n\n\tif event.UserName != exampleEventUserName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.UserName, exampleEventUserName)\n\t}\n\n\tif event.Project.ID != 15 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 15)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Timestamp == nil {\n\t\tt.Errorf(\"Commit Timestamp isn't nil\")\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Message != exampleCommitMessage {\n\t\tt.Errorf(\"Commit Message is %s, want %s\", event.Commits[0].Message, exampleCommitMessage)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Title != exampleCommitTitle {\n\t\tt.Errorf(\"Commit Title is %s, want %s\", event.Commits[0].Title, exampleCommitTitle)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Author.Name != \"Jordi Mallach\" {\n\t\tt.Errorf(\"Commit Username is %s, want %s\", event.UserName, \"Jordi Mallach\")\n\t}\n}\n\nfunc TestReleaseEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/release.json\")\n\n\tvar event *ReleaseEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Release Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Release Event is null\")\n\t}\n\n\tif event.Project.ID != 327622 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 327622)\n\t}\n\n\tif event.Commit.Title != \"Merge branch 'example-branch' into 'master'\" {\n\t\tt.Errorf(\"Commit title is %s, want %s\", event.Commit.Title, \"Merge branch 'example-branch' into 'master'\")\n\t}\n\n\tif len(event.Assets.Sources) != 4 {\n\t\tt.Errorf(\"Asset sources length is %d, want %d\", len(event.Assets.Sources), 4)\n\t}\n\n\tif event.Assets.Sources[0].Format != \"zip\" {\n\t\tt.Errorf(\"First asset source format is %s, want %s\", event.Assets.Sources[0].Format, \"zip\")\n\t}\n\n\tif len(event.Assets.Links) != 1 {\n\t\tt.Errorf(\"Asset links length is %d, want %d\", len(event.Assets.Links), 1)\n\t}\n\n\tif event.Assets.Links[0].Name != \"Changelog\" {\n\t\tt.Errorf(\"First asset link name is %s, want %s\", event.Assets.Links[0].Name, \"Changelog\")\n\t}\n\n\tif event.Commit.Author.Name != \"User\" {\n\t\tt.Errorf(\"Commit author name is %s, want %s\", event.Commit.Author.Name, \"User\")\n\t}\n}\n\nfunc TestSubGroupEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/subgroup.json\")\n\n\tvar event *SubGroupEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"SubGroup Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"SubGroup Event is null\")\n\t}\n\n\tif event.Name != \"SubGroup 1\" {\n\t\tt.Errorf(\"Name is %v, want %v\", event.Name, \"SubGroup 1\")\n\t}\n\n\tif event.GroupID != 2 {\n\t\tt.Errorf(\"GroupID is %v, want %v\", event.GroupID, 2)\n\t}\n\n\tif event.ParentGroupID != 1 {\n\t\tt.Errorf(\"ParentGroupID is %v, want %v\", event.ParentGroupID, 1)\n\t}\n\n\tif event.CreatedAt.Format(time.RFC3339) != \"2022-01-24T14:23:59Z\" {\n\t\tt.Errorf(\"CreatedAt is %v, want %v\", event.CreatedAt.Format(time.RFC3339), \"2022-01-24T14:23:59Z\")\n\t}\n}\n\nfunc TestTagEventUnmarshal(t *testing.T) {\n\tjsonObject := loadFixture(t, \"testdata/webhooks/tag_push.json\")\n\tvar event *TagEvent\n\terr := json.Unmarshal(jsonObject, &event)\n\tif err != nil {\n\t\tt.Errorf(\"Tag Event can not unmarshaled: %v\\n \", err.Error())\n\t}\n\n\tif event == nil {\n\t\tt.Errorf(\"Tag Event is null\")\n\t}\n\n\tif event.EventName != \"tag_push\" {\n\t\tt.Errorf(\"EventName is %v, want %v\", event.EventName, \"tag_push\")\n\t}\n\n\tif event.ProjectID != 1 {\n\t\tt.Errorf(\"ProjectID is %v, want %v\", event.ProjectID, 1)\n\t}\n\n\tif event.Project.ID != 1 {\n\t\tt.Errorf(\"Project.ID is %v, want %v\", event.Project.ID, 1)\n\t}\n\n\tif event.UserName != exampleEventUserName {\n\t\tt.Errorf(\"Username is %s, want %s\", event.UserName, exampleEventUserName)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Timestamp == nil {\n\t\tt.Errorf(\"Commit Timestamp isn't nil\")\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Message != exampleCommitMessage {\n\t\tt.Errorf(\"Commit Message is %s, want %s\", event.Commits[0].Message, exampleCommitMessage)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Title != exampleCommitTitle {\n\t\tt.Errorf(\"Commit Title is %s, want %s\", event.Commits[0].Title, exampleCommitTitle)\n\t}\n\n\tif event.Commits[0] == nil || event.Commits[0].Author.Name != exampleEventUserName {\n\t\tt.Errorf(\"Commit Username is %s, want %s\", event.UserName, exampleEventUserName)\n\t}\n}\n"
        },
        {
          "name": "events.go",
          "type": "blob",
          "size": 7.7236328125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// EventsService handles communication with the event related methods of\n// the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/events.html\ntype EventsService struct {\n\tclient *Client\n}\n\n// ContributionEvent represents a user's contribution\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/events.html#get-user-contribution-events\ntype ContributionEvent struct {\n\tID          int        `json:\"id\"`\n\tTitle       string     `json:\"title\"`\n\tProjectID   int        `json:\"project_id\"`\n\tActionName  string     `json:\"action_name\"`\n\tTargetID    int        `json:\"target_id\"`\n\tTargetIID   int        `json:\"target_iid\"`\n\tTargetType  string     `json:\"target_type\"`\n\tAuthorID    int        `json:\"author_id\"`\n\tTargetTitle string     `json:\"target_title\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tPushData    struct {\n\t\tCommitCount int    `json:\"commit_count\"`\n\t\tAction      string `json:\"action\"`\n\t\tRefType     string `json:\"ref_type\"`\n\t\tCommitFrom  string `json:\"commit_from\"`\n\t\tCommitTo    string `json:\"commit_to\"`\n\t\tRef         string `json:\"ref\"`\n\t\tCommitTitle string `json:\"commit_title\"`\n\t} `json:\"push_data\"`\n\tNote   *Note `json:\"note\"`\n\tAuthor struct {\n\t\tName      string `json:\"name\"`\n\t\tUsername  string `json:\"username\"`\n\t\tID        int    `json:\"id\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"author\"`\n\tAuthorUsername string `json:\"author_username\"`\n}\n\n// ListContributionEventsOptions represents the options for GetUserContributionEvents\n//\n// GitLap API docs:\n// https://docs.gitlab.com/ee/api/events.html#get-user-contribution-events\ntype ListContributionEventsOptions struct {\n\tListOptions\n\tAction     *EventTypeValue       `url:\"action,omitempty\" json:\"action,omitempty\"`\n\tTargetType *EventTargetTypeValue `url:\"target_type,omitempty\" json:\"target_type,omitempty\"`\n\tBefore     *ISOTime              `url:\"before,omitempty\" json:\"before,omitempty\"`\n\tAfter      *ISOTime              `url:\"after,omitempty\" json:\"after,omitempty\"`\n\tSort       *string               `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListUserContributionEvents retrieves user contribution events\n// for the specified user, sorted from newest to oldest.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/events.html#get-user-contribution-events\nfunc (s *UsersService) ListUserContributionEvents(uid interface{}, opt *ListContributionEventsOptions, options ...RequestOptionFunc) ([]*ContributionEvent, *Response, error) {\n\tuser, err := parseID(uid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"users/%s/events\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cs []*ContributionEvent\n\tresp, err := s.client.Do(req, &cs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cs, resp, nil\n}\n\n// ListCurrentUserContributionEvents gets a list currently authenticated user's events\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/events.html#list-currently-authenticated-users-events\nfunc (s *EventsService) ListCurrentUserContributionEvents(opt *ListContributionEventsOptions, options ...RequestOptionFunc) ([]*ContributionEvent, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"events\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar cs []*ContributionEvent\n\tresp, err := s.client.Do(req, &cs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cs, resp, nil\n}\n\n// ProjectEvent represents a GitLab project event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/events.html#list-a-projects-visible-events\ntype ProjectEvent struct {\n\tID          int    `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tProjectID   int    `json:\"project_id\"`\n\tActionName  string `json:\"action_name\"`\n\tTargetID    int    `json:\"target_id\"`\n\tTargetIID   int    `json:\"target_iid\"`\n\tTargetType  string `json:\"target_type\"`\n\tAuthorID    int    `json:\"author_id\"`\n\tTargetTitle string `json:\"target_title\"`\n\tCreatedAt   string `json:\"created_at\"`\n\tAuthor      struct {\n\t\tName      string `json:\"name\"`\n\t\tUsername  string `json:\"username\"`\n\t\tID        int    `json:\"id\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"author\"`\n\tAuthorUsername string `json:\"author_username\"`\n\tData           struct {\n\t\tBefore            string      `json:\"before\"`\n\t\tAfter             string      `json:\"after\"`\n\t\tRef               string      `json:\"ref\"`\n\t\tUserID            int         `json:\"user_id\"`\n\t\tUserName          string      `json:\"user_name\"`\n\t\tRepository        *Repository `json:\"repository\"`\n\t\tCommits           []*Commit   `json:\"commits\"`\n\t\tTotalCommitsCount int         `json:\"total_commits_count\"`\n\t} `json:\"data\"`\n\tNote struct {\n\t\tID         int    `json:\"id\"`\n\t\tBody       string `json:\"body\"`\n\t\tAttachment string `json:\"attachment\"`\n\t\tAuthor     struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tEmail     string `json:\"email\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t} `json:\"author\"`\n\t\tCreatedAt    *time.Time `json:\"created_at\"`\n\t\tSystem       bool       `json:\"system\"`\n\t\tNoteableID   int        `json:\"noteable_id\"`\n\t\tNoteableType string     `json:\"noteable_type\"`\n\t\tNoteableIID  int        `json:\"noteable_iid\"`\n\t} `json:\"note\"`\n\tPushData struct {\n\t\tCommitCount int    `json:\"commit_count\"`\n\t\tAction      string `json:\"action\"`\n\t\tRefType     string `json:\"ref_type\"`\n\t\tCommitFrom  string `json:\"commit_from\"`\n\t\tCommitTo    string `json:\"commit_to\"`\n\t\tRef         string `json:\"ref\"`\n\t\tCommitTitle string `json:\"commit_title\"`\n\t} `json:\"push_data\"`\n}\n\nfunc (s ProjectEvent) String() string {\n\treturn Stringify(s)\n}\n\n// ListProjectVisibleEventsOptions represents the available\n// ListProjectVisibleEvents() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/events.html#list-a-projects-visible-events\ntype ListProjectVisibleEventsOptions struct {\n\tListOptions\n\tAction     *EventTypeValue       `url:\"action,omitempty\" json:\"action,omitempty\"`\n\tTargetType *EventTargetTypeValue `url:\"target_type,omitempty\" json:\"target_type,omitempty\"`\n\tBefore     *ISOTime              `url:\"before,omitempty\" json:\"before,omitempty\"`\n\tAfter      *ISOTime              `url:\"after,omitempty\" json:\"after,omitempty\"`\n\tSort       *string               `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListProjectVisibleEvents gets the events for the specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/events.html#list-a-projects-visible-events\nfunc (s *EventsService) ListProjectVisibleEvents(pid interface{}, opt *ListProjectVisibleEventsOptions, options ...RequestOptionFunc) ([]*ProjectEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/events\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*ProjectEvent\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n"
        },
        {
          "name": "events_test.go",
          "type": "blob",
          "size": 9.150390625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestUsersService_ListUserContributionEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/1/events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"title\": null,\n\t\t\t\t\"project_id\": 15,\n\t\t\t\t\"action_name\": \"closed\",\n\t\t\t\t\"target_id\": 830,\n\t\t\t\t\"target_type\": \"Issue\",\n\t\t\t\t\"author_id\": 1,\n\t\t\t\t\"target_title\": \"Public project search field\",\n\t\t\t\t\"author\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://localhost:3000/uploads/user/avatar/1/fox_avatar.png\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"author_username\": \"venky333\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ContributionEvent{\n\t\t{\n\t\t\tID:          3,\n\t\t\tTitle:       \"\",\n\t\t\tProjectID:   15,\n\t\t\tActionName:  \"closed\",\n\t\t\tTargetID:    830,\n\t\t\tTargetIID:   0,\n\t\t\tTargetType:  \"Issue\",\n\t\t\tAuthorID:    1,\n\t\t\tTargetTitle: \"Public project search field\",\n\t\t\tNote:        nil,\n\t\t\tAuthor: struct {\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tID:        1,\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://localhost:3000/uploads/user/avatar/1/fox_avatar.png\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tAuthorUsername: \"venky333\",\n\t\t},\n\t}\n\n\tces, resp, err := client.Users.ListUserContributionEvents(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ces)\n\n\tces, resp, err = client.Users.ListUserContributionEvents(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ces)\n\n\tces, resp, err = client.Users.ListUserContributionEvents(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ces)\n\n\tces, resp, err = client.Users.ListUserContributionEvents(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ces)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestEventsService_ListCurrentUserContributionEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"title\":null,\n\t\t\t\t\"project_id\":1,\n\t\t\t\t\"action_name\":\"opened\",\n\t\t\t\t\"target_id\":160,\n\t\t\t\t\"target_type\":\"Issue\",\n\t\t\t\t\"author_id\":25,\n\t\t\t\t\"target_title\":\"Qui natus eos odio tempore et quaerat consequuntur ducimus cupiditate quis.\",\n\t\t\t\t\"author\":{\n\t\t\t\t  \"name\":\"Venkatesh Thalluri\",\n\t\t\t\t  \"username\":\"venky333\",\n\t\t\t\t  \"id\":25,\n\t\t\t\t  \"state\":\"active\",\n\t\t\t\t  \"avatar_url\":\"http://www.gravatar.com/avatar/97d6d9441ff85fdc730e02a6068d267b?s=80u0026d=identicon\",\n\t\t\t\t  \"web_url\":\"https://gitlab.example.com/venky333\"\n\t\t\t\t},\n\t\t\t\t\"author_username\":\"venky333\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ContributionEvent{\n\t\t{\n\t\t\tID:          1,\n\t\t\tTitle:       \"\",\n\t\t\tProjectID:   1,\n\t\t\tActionName:  \"opened\",\n\t\t\tTargetID:    160,\n\t\t\tTargetIID:   0,\n\t\t\tTargetType:  \"Issue\",\n\t\t\tAuthorID:    25,\n\t\t\tTargetTitle: \"Qui natus eos odio tempore et quaerat consequuntur ducimus cupiditate quis.\",\n\t\t\tNote:        nil,\n\t\t\tAuthor: struct {\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tID:        25,\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/97d6d9441ff85fdc730e02a6068d267b?s=80u0026d=identicon\",\n\t\t\t\tWebURL:    \"https://gitlab.example.com/venky333\",\n\t\t\t},\n\t\t\tAuthorUsername: \"venky333\",\n\t\t},\n\t}\n\n\tces, resp, err := client.Events.ListCurrentUserContributionEvents(nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ces)\n\n\tces, resp, err = client.Events.ListCurrentUserContributionEvents(nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ces)\n}\n\nfunc TestEventsService_ListCurrentUserContributionEvents_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tces, resp, err := client.Events.ListCurrentUserContributionEvents(nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ces)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestEventsService_ListProjectVisibleEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/15/events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"title\": null,\n\t\t\t\t\"project_id\": 15,\n\t\t\t\t\"action_name\": \"closed\",\n\t\t\t\t\"target_id\": 830,\n\t\t\t\t\"target_type\": \"Issue\",\n\t\t\t\t\"author_id\": 1,\n\t\t\t\t\"target_title\": \"Public project search field\",\n\t\t\t\t\"author\": {\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venky333\",\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://localhost:3000/uploads/user/avatar/1/fox_avatar.png\",\n\t\t\t\t  \"web_url\": \"http://localhost:3000/venky333\"\n\t\t\t\t},\n\t\t\t\t\"author_username\": \"venky333\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"title\": null,\n\t\t\t\t\"project_id\": 15,\n\t\t\t\t\"action_name\": \"pushed\",\n\t\t\t\t\"target_id\": null,\n\t\t\t\t\"target_type\": null,\n\t\t\t\t\"author_id\": 1,\n\t\t\t\t\"author\": {\n\t\t\t\t\"name\": \"Dmitriy Zaporozhets\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"http://localhost:3000/uploads/user/avatar/1/fox_avatar.png\",\n\t\t\t\t\"web_url\": \"http://localhost:3000/root\"\n\t\t\t\t},\n\t\t\t\t\"author_username\": \"john\",\n\t\t\t\t\"push_data\": {\n\t\t\t\t\"commit_count\": 1,\n\t\t\t\t\"action\": \"pushed\",\n\t\t\t\t\"ref_type\": \"branch\",\n\t\t\t\t\"commit_from\": \"50d4420237a9de7be1304607147aec22e4a14af7\",\n\t\t\t\t\"commit_to\": \"c5feabde2d8cd023215af4d2ceeb7a64839fc428\",\n\t\t\t\t\"ref\": \"master\",\n\t\t\t\t\"commit_title\": \"Add simple search to projects in public area\"\n\t\t\t\t},\n\t\t\t\t\"target_title\": null\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectEvent{\n\t\t{\n\t\t\tID:          3,\n\t\t\tTitle:       \"\",\n\t\t\tProjectID:   15,\n\t\t\tActionName:  \"closed\",\n\t\t\tTargetID:    830,\n\t\t\tTargetIID:   0,\n\t\t\tTargetType:  \"Issue\",\n\t\t\tAuthorID:    1,\n\t\t\tTargetTitle: \"Public project search field\",\n\t\t\tAuthor: struct {\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tUsername:  \"venky333\",\n\t\t\t\tID:        1,\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://localhost:3000/uploads/user/avatar/1/fox_avatar.png\",\n\t\t\t\tWebURL:    \"http://localhost:3000/venky333\",\n\t\t\t},\n\t\t\tAuthorUsername: \"venky333\",\n\t\t},\n\t\t// example from https://docs.gitlab.com/ee/api/events.html#get-user-contribution-events\n\t\t{\n\t\t\tID:          4,\n\t\t\tTitle:       \"\",\n\t\t\tProjectID:   15,\n\t\t\tActionName:  \"pushed\",\n\t\t\tTargetID:    0,\n\t\t\tTargetIID:   0,\n\t\t\tTargetType:  \"\",\n\t\t\tAuthorID:    1,\n\t\t\tTargetTitle: \"\",\n\t\t\tCreatedAt:   \"\",\n\t\t\tAuthor: struct {\n\t\t\t\tName      string `json:\"name\"`\n\t\t\t\tUsername  string `json:\"username\"`\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tState     string `json:\"state\"`\n\t\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\t\tWebURL    string `json:\"web_url\"`\n\t\t\t}{\n\t\t\t\tName:      \"Dmitriy Zaporozhets\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tID:        1,\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"http://localhost:3000/uploads/user/avatar/1/fox_avatar.png\",\n\t\t\t\tWebURL:    \"http://localhost:3000/root\",\n\t\t\t},\n\t\t\tAuthorUsername: \"john\",\n\t\t\tPushData: struct {\n\t\t\t\tCommitCount int    `json:\"commit_count\"`\n\t\t\t\tAction      string `json:\"action\"`\n\t\t\t\tRefType     string `json:\"ref_type\"`\n\t\t\t\tCommitFrom  string `json:\"commit_from\"`\n\t\t\t\tCommitTo    string `json:\"commit_to\"`\n\t\t\t\tRef         string `json:\"ref\"`\n\t\t\t\tCommitTitle string `json:\"commit_title\"`\n\t\t\t}{\n\t\t\t\tCommitCount: 1,\n\t\t\t\tAction:      \"pushed\",\n\t\t\t\tRefType:     \"branch\",\n\t\t\t\tCommitFrom:  \"50d4420237a9de7be1304607147aec22e4a14af7\",\n\t\t\t\tCommitTo:    \"c5feabde2d8cd023215af4d2ceeb7a64839fc428\",\n\t\t\t\tRef:         \"master\",\n\t\t\t\tCommitTitle: \"Add simple search to projects in public area\",\n\t\t\t},\n\t\t},\n\t}\n\n\tces, resp, err := client.Events.ListProjectVisibleEvents(15, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ces)\n\n\tces, resp, err = client.Events.ListProjectVisibleEvents(15.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 15.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ces)\n\n\tces, resp, err = client.Events.ListProjectVisibleEvents(15, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ces)\n\n\tces, resp, err = client.Events.ListProjectVisibleEvents(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ces)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "external_status_checks.go",
          "type": "blob",
          "size": 7.5380859375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ExternalStatusChecksService handles communication with the external\n// status check related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/status_checks.html\ntype ExternalStatusChecksService struct {\n\tclient *Client\n}\n\ntype MergeStatusCheck struct {\n\tID          int    `json:\"id\"`\n\tName        string `json:\"name\"`\n\tExternalURL string `json:\"external_url\"`\n\tStatus      string `json:\"status\"`\n}\n\ntype ProjectStatusCheck struct {\n\tID                int                          `json:\"id\"`\n\tName              string                       `json:\"name\"`\n\tProjectID         int                          `json:\"project_id\"`\n\tExternalURL       string                       `json:\"external_url\"`\n\tProtectedBranches []StatusCheckProtectedBranch `json:\"protected_branches\"`\n}\n\ntype StatusCheckProtectedBranch struct {\n\tID                        int        `json:\"id\"`\n\tProjectID                 int        `json:\"project_id\"`\n\tName                      string     `json:\"name\"`\n\tCreatedAt                 *time.Time `json:\"created_at\"`\n\tUpdatedAt                 *time.Time `json:\"updated_at\"`\n\tCodeOwnerApprovalRequired bool       `json:\"code_owner_approval_required\"`\n}\n\n// ListMergeStatusChecks lists the external status checks that apply to it\n// and their status for a single merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#list-status-checks-for-a-merge-request\nfunc (s *ExternalStatusChecksService) ListMergeStatusChecks(pid interface{}, mr int, opt *ListOptions, options ...RequestOptionFunc) ([]*MergeStatusCheck, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/status_checks\", PathEscape(project), mr)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mscs []*MergeStatusCheck\n\tresp, err := s.client.Do(req, &mscs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mscs, resp, nil\n}\n\n// SetExternalStatusCheckStatusOptions represents the available\n// SetExternalStatusCheckStatus() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#set-status-of-an-external-status-check\ntype SetExternalStatusCheckStatusOptions struct {\n\tSHA                   *string `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n\tExternalStatusCheckID *int    `url:\"external_status_check_id,omitempty\" json:\"external_status_check_id,omitempty\"`\n\tStatus                *string `url:\"status,omitempty\" json:\"status,omitempty\"`\n}\n\n// SetExternalStatusCheckStatus sets the status of an external status check.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#set-status-of-an-external-status-check\nfunc (s *ExternalStatusChecksService) SetExternalStatusCheckStatus(pid interface{}, mergeRequest int, opt *SetExternalStatusCheckStatusOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/status_check_responses\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListProjectStatusChecks lists the project external status checks.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#get-project-external-status-checks\nfunc (s *ExternalStatusChecksService) ListProjectStatusChecks(pid interface{}, opt *ListOptions, options ...RequestOptionFunc) ([]*ProjectStatusCheck, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/external_status_checks\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pscs []*ProjectStatusCheck\n\tresp, err := s.client.Do(req, &pscs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pscs, resp, nil\n}\n\n// CreateExternalStatusCheckOptions represents the available\n// CreateExternalStatusCheck() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#create-external-status-check\ntype CreateExternalStatusCheckOptions struct {\n\tName               *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tExternalURL        *string `url:\"external_url,omitempty\" json:\"external_url,omitempty\"`\n\tProtectedBranchIDs *[]int  `url:\"protected_branch_ids,omitempty\" json:\"protected_branch_ids,omitempty\"`\n}\n\n// CreateExternalStatusCheck creates an external status check.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#create-external-status-check\nfunc (s *ExternalStatusChecksService) CreateExternalStatusCheck(pid interface{}, opt *CreateExternalStatusCheckOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/external_status_checks\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteExternalStatusCheck deletes an external status check.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#delete-external-status-check\nfunc (s *ExternalStatusChecksService) DeleteExternalStatusCheck(pid interface{}, check int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/external_status_checks/%d\", PathEscape(project), check)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// UpdateExternalStatusCheckOptions represents the available\n// UpdateExternalStatusCheck() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#update-external-status-check\ntype UpdateExternalStatusCheckOptions struct {\n\tName               *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tExternalURL        *string `url:\"external_url,omitempty\" json:\"external_url,omitempty\"`\n\tProtectedBranchIDs *[]int  `url:\"protected_branch_ids,omitempty\" json:\"protected_branch_ids,omitempty\"`\n}\n\n// UpdateExternalStatusCheck updates an external status check.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#update-external-status-check\nfunc (s *ExternalStatusChecksService) UpdateExternalStatusCheck(pid interface{}, check int, opt *UpdateExternalStatusCheckOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/external_status_checks/%d\", PathEscape(project), check)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// UpdateExternalStatusCheck updates an external status check.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/status_checks.html#retry-failed-status-check-for-a-merge-request\nfunc (s *ExternalStatusChecksService) RetryFailedStatusCheckForAMergeRequest(pid interface{}, mergeRequest int, externalStatusCheck int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/status_checks/%d/retry\", PathEscape(project), mergeRequest, externalStatusCheck)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "external_status_checks_test.go",
          "type": "blob",
          "size": 2.6220703125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListMergeStatusChecks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/status_checks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, exampleStatusChecks)\n\t})\n\n\tstatusChecks, _, err := client.ExternalStatusChecks.ListMergeStatusChecks(1, 1, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"ExternalStatusChecks.ListMergeStatusChecks returns an error: %v\", err)\n\t}\n\n\texpectedStatusChecks := []*MergeStatusCheck{\n\t\t{\n\t\t\tID:          2,\n\t\t\tName:        \"Rule 1\",\n\t\t\tExternalURL: \"https://gitlab.com/test-endpoint\",\n\t\t\tStatus:      \"approved\",\n\t\t},\n\t\t{\n\t\t\tID:          1,\n\t\t\tName:        \"Rule 2\",\n\t\t\tExternalURL: \"https://gitlab.com/test-endpoint-2\",\n\t\t\tStatus:      \"pending\",\n\t\t},\n\t}\n\n\tassert.Equal(t, expectedStatusChecks, statusChecks)\n}\n\nfunc TestListProjectStatusChecks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/external_status_checks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, exampleProjectStatusChecks)\n\t})\n\n\tprojectStatusChecks, _, err := client.ExternalStatusChecks.ListProjectStatusChecks(1, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"ExternalStatusChecks.ListProjectStatusChecks returns an error: %v\", err)\n\t}\n\n\ttime1, err := time.Parse(time.RFC3339, \"2020-10-12T14:04:50.787Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ExternalStatusChecks.ListProjectStatusChecks returns an error: %v\", err)\n\t}\n\n\texpectedProjectStatusChecks := []*ProjectStatusCheck{\n\t\t{\n\t\t\tID:          1,\n\t\t\tName:        \"Compliance Check\",\n\t\t\tProjectID:   6,\n\t\t\tExternalURL: \"https://gitlab.com/example/test.json\",\n\t\t\tProtectedBranches: []StatusCheckProtectedBranch{\n\t\t\t\t{\n\t\t\t\t\tID:                        14,\n\t\t\t\t\tProjectID:                 6,\n\t\t\t\t\tName:                      \"master\",\n\t\t\t\t\tCreatedAt:                 &time1,\n\t\t\t\t\tUpdatedAt:                 &time1,\n\t\t\t\t\tCodeOwnerApprovalRequired: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tassert.Equal(t, expectedProjectStatusChecks, projectStatusChecks)\n}\n\nfunc TestRetryFailedStatusCheckForAMergeRequest(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/2/status_checks/3/retry\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"message\": \"202 Accepted\"}`)\n\t})\n\n\tresp, err := client.ExternalStatusChecks.RetryFailedStatusCheckForAMergeRequest(1, 2, 3)\n\tif err != nil {\n\t\tt.Fatalf(\"ExternalStatusChecks.RetryFailedStatusCheckForAMergeRequest returns an error: %v\", err)\n\t}\n\n\tassert.NotNil(t, resp)\n}\n"
        },
        {
          "name": "feature_flags.go",
          "type": "blob",
          "size": 2.44140625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// FeaturesService handles the communication with the application FeaturesService\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/features.html\ntype FeaturesService struct {\n\tclient *Client\n}\n\n// Feature represents a GitLab feature flag.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/features.html\ntype Feature struct {\n\tName  string `json:\"name\"`\n\tState string `json:\"state\"`\n\tGates []Gate\n}\n\n// Gate represents a gate of a GitLab feature flag.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/features.html\ntype Gate struct {\n\tKey   string      `json:\"key\"`\n\tValue interface{} `json:\"value\"`\n}\n\nfunc (f Feature) String() string {\n\treturn Stringify(f)\n}\n\n// ListFeatures gets a list of feature flags\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/features.html#list-all-features\nfunc (s *FeaturesService) ListFeatures(options ...RequestOptionFunc) ([]*Feature, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"features\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar f []*Feature\n\tresp, err := s.client.Do(req, &f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn f, resp, nil\n}\n\n// SetFeatureFlag sets or creates a feature flag gate\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/features.html#set-or-create-a-feature\nfunc (s *FeaturesService) SetFeatureFlag(name string, value interface{}, options ...RequestOptionFunc) (*Feature, *Response, error) {\n\tu := fmt.Sprintf(\"features/%s\", url.PathEscape(name))\n\n\topt := struct {\n\t\tValue interface{} `url:\"value\" json:\"value\"`\n\t}{\n\t\tvalue,\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tf := &Feature{}\n\tresp, err := s.client.Do(req, f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\treturn f, resp, nil\n}\n"
        },
        {
          "name": "feature_flags_test.go",
          "type": "blob",
          "size": 2.33984375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListFeatureFlags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/features\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t[\n\t\t\t{\n\t\t\t  \"name\": \"experimental_feature\",\n\t\t\t  \"state\": \"off\",\n\t\t\t  \"gates\": [\n\t\t\t\t{\n\t\t\t\t  \"key\": \"boolean\",\n\t\t\t\t  \"value\": false\n\t\t\t\t}\n\t\t\t  ]\n\t\t\t},\n\t\t\t{\n\t\t\t  \"name\": \"new_library\",\n\t\t\t  \"state\": \"on\"\n\t\t\t}\n\t\t  ]\n\t`)\n\t})\n\n\tfeatures, _, err := client.Features.ListFeatures()\n\tif err != nil {\n\t\tt.Errorf(\"Features.ListFeatures returned error: %v\", err)\n\t}\n\n\twant := []*Feature{\n\t\t{Name: \"experimental_feature\", State: \"off\", Gates: []Gate{\n\t\t\t{Key: \"boolean\", Value: false},\n\t\t}},\n\t\t{Name: \"new_library\", State: \"on\"},\n\t}\n\tif !reflect.DeepEqual(want, features) {\n\t\tt.Errorf(\"Features.ListFeatures returned %+v, want %+v\", features, want)\n\t}\n}\n\nfunc TestSetFeatureFlag(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/features/new_library\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"name\": \"new_library\",\n\t\t\t\"state\": \"conditional\",\n\t\t\t\"gates\": [\n\t\t\t  {\n\t\t\t\t\"key\": \"boolean\",\n\t\t\t\t\"value\": false\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"key\": \"percentage_of_time\",\n\t\t\t\t\"value\": 30\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\tfeature, _, err := client.Features.SetFeatureFlag(\"new_library\", \"30\")\n\tif err != nil {\n\t\tt.Errorf(\"Features.SetFeatureFlag returned error: %v\", err)\n\t}\n\n\twant := &Feature{\n\t\tName:  \"new_library\",\n\t\tState: \"conditional\",\n\t\tGates: []Gate{\n\t\t\t{Key: \"boolean\", Value: false},\n\t\t\t{Key: \"percentage_of_time\", Value: 30.0},\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, feature) {\n\t\tt.Errorf(\"Features.SetFeatureFlag returned %+v, want %+v\", feature, want)\n\t}\n}\n"
        },
        {
          "name": "fixtures_test.go",
          "type": "blob",
          "size": 12.291015625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nconst (\n\t// exampleChangelogResponse provides fixture for Changelog tests.\n\texampleChangelogResponse = `{\n    \"notes\": \"## 1.0.0 (2021-11-17)\\n\\n### feature (2 changes)\\n\\n- [Title 2](namespace13/project13@ad608eb642124f5b3944ac0ac772fecaf570a6bf) ([merge request](namespace13/project13!2))\\n- [Title 1](namespace13/project13@3c6b80ff7034fa0d585314e1571cc780596ce3c8) ([merge request](namespace13/project13!1))\\n\"\n  }`\n\n\t// exampleCommitMessage provides fixture for a commit message.\n\texampleCommitMessage = \"Merge branch 'some-feature' into 'master'\\n\\nRelease v1.0.0\\n\\nSee merge request jsmith/example!1\"\n\n\t// exampleCommitTitle provides fixture for a commit title.\n\texampleCommitTitle = \"Merge branch 'some-feature' into 'master'\"\n\n\t// exampleDetailResponse provides fixture for Runners tests.\n\texampleDetailResponse = `{\n\t\t\"active\": true,\n\t\t\"architecture\": null,\n\t\t\"description\": \"test-1-20150125-test\",\n\t\t\"run_untagged\": true,\n\t\t\"id\": 6,\n\t\t\"is_shared\": false,\n\t\t\"runner_type\": \"project_type\",\n\t\t\"contacted_at\": \"2016-01-25T16:39:48.166Z\",\n\t\t\"name\": null,\n\t\t\"online\": true,\n\t\t\"status\": \"online\",\n\t\t\"platform\": null,\n\t\t\"projects\": [\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"GitLab Community Edition\",\n\t\t\t\t\"name_with_namespace\": \"GitLab.org / GitLab Community Edition\",\n\t\t\t\t\"path\": \"gitlab-ce\",\n\t\t\t\t\"path_with_namespace\": \"gitlab-org/gitlab-ce\"\n\t\t\t}\n\t\t],\n\t\t\"token\": \"205086a8e3b9a2b818ffac9b89d102\",\n\t\t\"revision\": null,\n\t\t\"tag_list\": [\n\t\t\t\"ruby\",\n\t\t\t\"mysql\"\n\t\t],\n\t\t\"version\": null,\n\t\t\"access_level\": \"ref_protected\",\n\t\t\"maximum_timeout\": 3600,\n\t\t\"locked\": false\n\t}`\n\n\t// exampleEventUserName provides a fixture for a event user's name.\n\texampleEventUserName = \"John Smith\"\n\n\t// exampleEventUserUsername provides a ficture for the event username.\n\texampleEventUserUsername = \"jsmith\"\n\n\t// exampleRunnerJob provides fixture for the list runner jobs test.\n\texampleListRunnerJobs = `\n  [\n    {\n      \"id\": 1,\n      \"status\": \"failed\",\n      \"stage\": \"test\",\n      \"name\": \"run_tests\",\n      \"ref\": \"master\",\n      \"tag\": false,\n      \"coverage\": null,\n      \"allow_failure\": false,\n      \"created_at\": \"2021-10-22T11:59:25.201Z\",\n      \"started_at\": \"2021-10-22T11:59:33.660Z\",\n      \"finished_at\": \"2021-10-22T15:59:25.201Z\",\n      \"duration\": 171.540594,\n      \"queued_duration\": 2.535766,\n      \"user\": {\n        \"id\": 368,\n        \"name\": \"John SMITH\",\n        \"username\": \"john.smith\",\n        \"state\": \"blocked\",\n        \"avatar_url\": \"https://gitlab.example.com/uploads/-/system/user/avatar/368/avatar.png\",\n        \"web_url\": \"https://gitlab.example.com/john.smith\",\n        \"bio\": \"\",\n        \"location\": \"\",\n        \"public_email\": \"john.smith@example.com\",\n        \"skype\": \"\",\n        \"linkedin\": \"\",\n        \"twitter\": \"\",\n        \"website_url\": \"\",\n        \"organization\": \"\",\n        \"job_title\": \"\",\n        \"pronouns\": null,\n        \"bot\": false,\n        \"work_information\": null,\n        \"bio_html\": \"\"\n      },\n      \"commit\": {\n        \"id\": \"6c016b801a88f4bd31f927fc045b5c746a6f823e\",\n        \"short_id\": \"6c016b80\",\n        \"created_at\": \"2018-03-21T14:41:00.000Z\",\n        \"parent_ids\": [\n          \"6008b4902d40799ab11688e502d9f1f27f6d2e18\"\n        ],\n        \"title\": \"Update env for specific runner\",\n        \"message\": \"Update env for specific runner\\n\",\n        \"author_name\": \"John SMITH\",\n        \"author_email\": \"john.smith@example.com\",\n        \"authored_date\": \"2018-03-21T14:41:00.000Z\",\n        \"committer_name\": \"John SMITH\",\n        \"committer_email\": \"john.smith@example.com\",\n        \"committed_date\": \"2018-03-21T14:41:00.000Z\",\n        \"web_url\": \"https://gitlab.example.com/awesome/packages/common/-/commit/6c016b801a88f4bd31f927fc045b5c746a6f823e\"\n      },\n      \"pipeline\": {\n        \"id\": 8777,\n        \"project_id\": 3252,\n        \"sha\": \"6c016b801a88f4bd31f927fc045b5c746a6f823e\",\n        \"ref\": \"master\",\n        \"status\": \"failed\",\n        \"source\": \"push\",\n        \"created_at\": \"2018-03-21T13:41:15.356Z\",\n        \"updated_at\": \"2018-03-21T15:12:52.021Z\",\n        \"web_url\": \"https://gitlab.example.com/awesome/packages/common/-/pipelines/8777\"\n      },\n      \"web_url\": \"https://gitlab.example.com/awesome/packages/common/-/jobs/14606\",\n      \"project\": {\n        \"id\": 3252,\n        \"description\": \"Common nodejs paquet for producer\",\n        \"name\": \"common\",\n        \"name_with_namespace\": \"awesome\",\n        \"path\": \"common\",\n        \"path_with_namespace\": \"awesome\",\n        \"created_at\": \"2018-02-13T09:21:48.107Z\"\n      }\n    }\n  ]`\n\n\t// exampleProjectName provides a fixture for a project name.\n\texampleProjectName = \"example-project\"\n\n\t// exampleProjectStatusChecks provides a fixture for a project status checks.\n\texampleProjectStatusChecks = `[\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Compliance Check\",\n\t\t\t\"project_id\": 6,\n\t\t\t\"external_url\": \"https://gitlab.com/example/test.json\",\n\t\t\t\"protected_branches\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 14,\n\t\t\t\t\t\"project_id\": 6,\n\t\t\t\t\t\"name\": \"master\",\n\t\t\t\t\t\"created_at\": \"2020-10-12T14:04:50.787Z\",\n\t\t\t\t\t\"updated_at\": \"2020-10-12T14:04:50.787Z\",\n\t\t\t\t\t\"code_owner_approval_required\": false\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t]`\n\n\t// exampleRegisterNewRunner provides fixture for Runners tests.\n\texampleRegisterNewRunner = `{\n\t\t\"id\": 12345,\n\t\t\"token\": \"6337ff461c94fd3fa32ba3b1ff4125\",\n\t\t\"token_expires_at\": \"2016-01-25T16:39:48.166Z\"\n\t}`\n\n\t// exampleReleaseLink provides fixture for Release Links tests.\n\texampleReleaseLink = `{\n\t\t\"id\":1,\n\t\t\"name\":\"awesome-v0.2.dmg\",\n\t\t\"url\":\"http://192.168.10.15:3000\",\n\t\t\"direct_asset_url\": \"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/awesome-v0.2.dmg\",\n\t\t\"external\":true,\n\t\t\"link_type\": \"other\"\n\t}`\n\n\t// exampleReleaseLinkList provides fixture for Release Links tests.\n\texampleReleaseLinkList = `[\n\t\t{\n\t\t\t\"id\": 2,\n\t\t\t\"name\": \"awesome-v0.2.msi\",\n\t\t\t\"url\": \"http://192.168.10.15:3000/msi\",\n\t\t\t\"external\": true\n\t\t},\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"awesome-v0.2.dmg\",\n\t\t\t\"url\": \"http://192.168.10.15:3000\",\n\t\t\t\"direct_asset_url\": \"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/awesome-v0.2.dmg\",\n\t\t\t\"external\": false,\n\t\t\t\"link_type\": \"other\"\n\t\t}\n\t]`\n\n\t// exampleReleaseListResponse provides fixture for Releases tests.\n\texampleReleaseListResponse = `[\n\t\t{\n\t\t\t\"tag_name\": \"v0.2\",\n\t\t\t\"description\": \"description\",\n\t\t\t\"name\": \"Awesome app v0.2 beta\",\n\t\t\t\"description_html\": \"html\",\n\t\t\t\"created_at\": \"2019-01-03T01:56:19.539Z\",\n\t\t\t\"author\": {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Administrator\",\n\t\t\t\"username\": \"root\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar\",\n\t\t\t\"web_url\": \"http://localhost:3000/root\"\n\t\t\t},\n\t\t\t\"commit\": {\n\t\t\t\"id\": \"079e90101242458910cccd35eab0e211dfc359c0\",\n\t\t\t\"short_id\": \"079e9010\",\n\t\t\t\"title\": \"Update README.md\",\n\t\t\t\"created_at\": \"2019-01-03T01:55:38.000Z\",\n\t\t\t\"parent_ids\": [\n\t\t\t\t\"f8d3d94cbd347e924aa7b715845e439d00e80ca4\"\n\t\t\t],\n\t\t\t\"message\": \"Update README.md\",\n\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\"authored_date\": \"2019-01-03T01:55:38.000Z\",\n\t\t\t\"committer_name\": \"Administrator\",\n\t\t\t\"committer_email\": \"admin@example.com\",\n\t\t\t\"committed_date\": \"2019-01-03T01:55:38.000Z\"\n\t\t\t},\n\t\t\t\"assets\": {\n\t\t\t\"count\": 4,\n\t\t\t\"sources\": [\n\t\t\t\t{\n\t\t\t\t\"format\": \"zip\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.2/awesome-app-v0.2.zip\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\"format\": \"tar.gz\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.2/awesome-app-v0.2.tar.gz\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"links\": [\n\t\t\t\t{\n\t\t\t\t\"id\": 2,\n\t\t\t\t\"name\": \"awesome-v0.2.msi\",\n\t\t\t\t\"url\": \"http://192.168.10.15:3000/msi\",\n\t\t\t\t\"external\": true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"awesome-v0.2.dmg\",\n\t\t\t\t\"url\": \"http://192.168.10.15:3000\",\n\t\t\t\t\"external\": true\n\t\t\t\t}\n\t\t\t]\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"tag_name\": \"v0.1\",\n\t\t\t\"description\": \"description\",\n\t\t\t\"name\": \"Awesome app v0.1 alpha\",\n\t\t\t\"description_html\": \"description_html\",\n\t\t\t\"created_at\": \"2019-01-03T01:55:18.203Z\",\n\t\t\t\"author\": {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Administrator\",\n\t\t\t\"username\": \"root\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar\",\n\t\t\t\"web_url\": \"http://localhost:3000/root\"\n\t\t\t},\n\t\t\t\"commit\": {\n\t\t\t\"id\": \"f8d3d94cbd347e924aa7b715845e439d00e80ca4\",\n\t\t\t\"short_id\": \"f8d3d94c\",\n\t\t\t\"title\": \"Initial commit\",\n\t\t\t\"created_at\": \"2019-01-03T01:53:28.000Z\",\n\t\t\t\"parent_ids\": [],\n\t\t\t\"message\": \"Initial commit\",\n\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\"authored_date\": \"2019-01-03T01:53:28.000Z\",\n\t\t\t\"committer_name\": \"Administrator\",\n\t\t\t\"committer_email\": \"admin@example.com\",\n\t\t\t\"committed_date\": \"2019-01-03T01:53:28.000Z\"\n\t\t\t},\n\t\t\t\"assets\": {\n\t\t\t\"count\": 2,\n\t\t\t\"sources\": [\n\t\t\t\t{\n\t\t\t\t\"format\": \"zip\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.1/awesome-app-v0.1.zip\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\"format\": \"tar.gz\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.1/awesome-app-v0.1.tar.gz\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"links\": []\n\t\t\t}\n\t\t}\n\t]`\n\n\t// exampleReleaseName provides a fixture for a release name.\n\texampleReleaseName = \"awesome-v0.2.dmg\"\n\n\t// exampleReleaseResponse provides fixture for Releases tests.\n\texampleReleaseResponse = `{\n\t\t\"tag_name\": \"v0.1\",\n\t\t\"description\": \"description\",\n\t\t\"name\": \"Awesome app v0.1 alpha\",\n\t\t\"description_html\": \"description_html\",\n\t\t\"created_at\": \"2019-01-03T01:55:18.203Z\",\n\t\t\"author\": {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Administrator\",\n\t\t\t\"username\": \"root\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/\",\n\t\t\t\"web_url\": \"http://localhost:3000/root\"\n\t\t},\n\t\t\"commit\": {\n\t\t\t\"id\": \"f8d3d94cbd347e924aa7b715845e439d00e80ca4\",\n\t\t\t\"short_id\": \"f8d3d94c\",\n\t\t\t\"title\": \"Initial commit\",\n\t\t\t\"created_at\": \"2019-01-03T01:53:28.000Z\",\n\t\t\t\"parent_ids\": [],\n\t\t\t\"message\": \"Initial commit\",\n\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\"authored_date\": \"2019-01-03T01:53:28.000Z\",\n\t\t\t\"committer_name\": \"Administrator\",\n\t\t\t\"committer_email\": \"admin@example.com\",\n\t\t\t\"committed_date\": \"2019-01-03T01:53:28.000Z\"\n\t\t},\n\t\t\"assets\": {\n\t\t\t\"count\": 2,\n\t\t\t\"sources\": [\n\t\t\t{\n\t\t\t\t\"format\": \"zip\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.1/awesome-app-v0.1.zip\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"format\": \"tar.gz\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.1/awesome-app-v0.1.tar.gz\"\n\t\t\t}\n\t\t\t],\n\t\t\t\"links\": []\n\t\t}\n\t}`\n\n\t// exampleReleaseResponse provides fixture for Releases tests.\n\texampleReleaseWithMetadataResponse = `{\n\t\t\"tag_name\": \"v0.1.2+example-metadata\",\n\t\t\"description\": \"description\",\n\t\t\"name\": \"Awesome app v0.1 alpha\",\n\t\t\"description_html\": \"description_html\",\n\t\t\"created_at\": \"2019-01-03T01:55:18.203Z\",\n\t\t\"author\": {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Administrator\",\n\t\t\t\"username\": \"root\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/\",\n\t\t\t\"web_url\": \"http://localhost:3000/root\"\n\t\t},\n\t\t\"commit\": {\n\t\t\t\"id\": \"f8d3d94cbd347e924aa7b715845e439d00e80ca4\",\n\t\t\t\"short_id\": \"f8d3d94c\",\n\t\t\t\"title\": \"Initial commit\",\n\t\t\t\"created_at\": \"2019-01-03T01:53:28.000Z\",\n\t\t\t\"parent_ids\": [],\n\t\t\t\"message\": \"Initial commit\",\n\t\t\t\"author_name\": \"Administrator\",\n\t\t\t\"author_email\": \"admin@example.com\",\n\t\t\t\"authored_date\": \"2019-01-03T01:53:28.000Z\",\n\t\t\t\"committer_name\": \"Administrator\",\n\t\t\t\"committer_email\": \"admin@example.com\",\n\t\t\t\"committed_date\": \"2019-01-03T01:53:28.000Z\"\n\t\t},\n\t\t\"assets\": {\n\t\t\t\"count\": 2,\n\t\t\t\"sources\": [\n\t\t\t{\n\t\t\t\t\"format\": \"zip\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.1/awesome-app-v0.1.zip\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"format\": \"tar.gz\",\n\t\t\t\t\"url\": \"http://localhost:3000/archive/v0.1/awesome-app-v0.1.tar.gz\"\n\t\t\t}\n\t\t\t],\n\t\t\t\"links\": []\n\t\t}\n\t}`\n\n\t// exampleStatusChecks provides a fixture for status checks for a merge request.\n\texampleStatusChecks = `[\n    {\n        \"id\": 2,\n        \"name\": \"Rule 1\",\n        \"external_url\": \"https://gitlab.com/test-endpoint\",\n        \"status\": \"approved\"\n    },\n    {\n        \"id\": 1,\n        \"name\": \"Rule 2\",\n        \"external_url\": \"https://gitlab.com/test-endpoint-2\",\n        \"status\": \"pending\"\n    }\n\t]`\n\n\t// exampleTagName provides a fixture for a tag name.\n\texampleTagName = \"v0.1\"\n\n\t// exampleTagName provides a fixture for a tag name.\n\texampleTagNameWithMetadata = \"v0.1.2+example-metadata\"\n)\n"
        },
        {
          "name": "freeze_periods.go",
          "type": "blob",
          "size": 6.013671875,
          "content": "//\n// Copyright 2021 Paul Cioanca\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// FreezePeriodsService handles the communication with the freeze periods\n// related methods of the GitLab API.\n//\n// https://docs.gitlab.com/ee/api/freeze_periods.html\ntype FreezePeriodsService struct {\n\tclient *Client\n}\n\n// FreezePeriod represents a freeze period object.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#list-freeze-periods\ntype FreezePeriod struct {\n\tID           int        `json:\"id\"`\n\tFreezeStart  string     `json:\"freeze_start\"`\n\tFreezeEnd    string     `json:\"freeze_end\"`\n\tCronTimezone string     `json:\"cron_timezone\"`\n\tCreatedAt    *time.Time `json:\"created_at\"`\n\tUpdatedAt    *time.Time `json:\"updated_at\"`\n}\n\n// ListFreezePeriodsOptions represents the available ListFreezePeriodsOptions()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#list-freeze-periods\ntype ListFreezePeriodsOptions ListOptions\n\n// ListFreezePeriods gets a list of project project freeze periods.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#list-freeze-periods\nfunc (s *FreezePeriodsService) ListFreezePeriods(pid interface{}, opt *ListFreezePeriodsOptions, options ...RequestOptionFunc) ([]*FreezePeriod, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/freeze_periods\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar fp []*FreezePeriod\n\tresp, err := s.client.Do(req, &fp)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn fp, resp, nil\n}\n\n// GetFreezePeriod gets a specific freeze period for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#get-a-freeze-period-by-a-freeze_period_id\nfunc (s *FreezePeriodsService) GetFreezePeriod(pid interface{}, freezePeriod int, options ...RequestOptionFunc) (*FreezePeriod, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/freeze_periods/%d\", PathEscape(project), freezePeriod)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfp := new(FreezePeriod)\n\tresp, err := s.client.Do(req, fp)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn fp, resp, nil\n}\n\n// CreateFreezePeriodOptions represents the available CreateFreezePeriodOptions()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#create-a-freeze-period\ntype CreateFreezePeriodOptions struct {\n\tFreezeStart  *string `url:\"freeze_start,omitempty\" json:\"freeze_start,omitempty\"`\n\tFreezeEnd    *string `url:\"freeze_end,omitempty\" json:\"freeze_end,omitempty\"`\n\tCronTimezone *string `url:\"cron_timezone,omitempty\" json:\"cron_timezone,omitempty\"`\n}\n\n// CreateFreezePeriodOptions adds a freeze period to a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#create-a-freeze-period\nfunc (s *FreezePeriodsService) CreateFreezePeriodOptions(pid interface{}, opt *CreateFreezePeriodOptions, options ...RequestOptionFunc) (*FreezePeriod, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/freeze_periods\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfp := new(FreezePeriod)\n\tresp, err := s.client.Do(req, fp)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn fp, resp, nil\n}\n\n// UpdateFreezePeriodOptions represents the available UpdateFreezePeriodOptions()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#update-a-freeze-period\ntype UpdateFreezePeriodOptions struct {\n\tFreezeStart  *string `url:\"freeze_start,omitempty\" json:\"freeze_start,omitempty\"`\n\tFreezeEnd    *string `url:\"freeze_end,omitempty\" json:\"freeze_end,omitempty\"`\n\tCronTimezone *string `url:\"cron_timezone,omitempty\" json:\"cron_timezone,omitempty\"`\n}\n\n// UpdateFreezePeriodOptions edits a freeze period for a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#update-a-freeze-period\nfunc (s *FreezePeriodsService) UpdateFreezePeriodOptions(pid interface{}, freezePeriod int, opt *UpdateFreezePeriodOptions, options ...RequestOptionFunc) (*FreezePeriod, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/freeze_periods/%d\", PathEscape(project), freezePeriod)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tfp := new(FreezePeriod)\n\tresp, err := s.client.Do(req, fp)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn fp, resp, nil\n}\n\n// DeleteFreezePeriod removes a freeze period from a project. This is an\n// idempotent method and can be called multiple times. Either the hook is\n// available or not.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/freeze_periods.html#delete-a-freeze-period\nfunc (s *FreezePeriodsService) DeleteFreezePeriod(pid interface{}, freezePeriod int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/freeze_periods/%d\", PathEscape(project), freezePeriod)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "freeze_periods_test.go",
          "type": "blob",
          "size": 5.8408203125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestFreezePeriodsService_ListFreezePeriods(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/19/freeze_periods\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t   {\n\t\t\t\t  \"id\":1,\n\t\t\t\t  \"freeze_start\":\"0 23 * * 5\",\n\t\t\t\t  \"freeze_end\":\"0 8 * * 1\",\n\t\t\t\t  \"cron_timezone\":\"UTC\"\n\t\t\t   }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*FreezePeriod{\n\t\t{\n\t\t\tID:           1,\n\t\t\tFreezeStart:  \"0 23 * * 5\",\n\t\t\tFreezeEnd:    \"0 8 * * 1\",\n\t\t\tCronTimezone: \"UTC\",\n\t\t},\n\t}\n\n\tfps, resp, err := client.FreezePeriods.ListFreezePeriods(19, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fps)\n\n\tfps, resp, err = client.FreezePeriods.ListFreezePeriods(19.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 19.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fps)\n\n\tfps, resp, err = client.FreezePeriods.ListFreezePeriods(19, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fps)\n\n\tfps, resp, err = client.FreezePeriods.ListFreezePeriods(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fps)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestFreezePeriodsService_GetFreezePeriod(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/19/freeze_periods/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t   {\n\t\t\t  \"id\":1,\n\t\t\t  \"freeze_start\":\"0 23 * * 5\",\n\t\t\t  \"freeze_end\":\"0 8 * * 1\",\n\t\t\t  \"cron_timezone\":\"UTC\"\n\t\t   }\n\t\t`)\n\t})\n\n\twant := &FreezePeriod{\n\t\tID:           1,\n\t\tFreezeStart:  \"0 23 * * 5\",\n\t\tFreezeEnd:    \"0 8 * * 1\",\n\t\tCronTimezone: \"UTC\",\n\t}\n\n\tfp, resp, err := client.FreezePeriods.GetFreezePeriod(19, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fp)\n\n\tfp, resp, err = client.FreezePeriods.GetFreezePeriod(19.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 19.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fp)\n\n\tfp, resp, err = client.FreezePeriods.GetFreezePeriod(19, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fp)\n\n\tfp, resp, err = client.FreezePeriods.GetFreezePeriod(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fp)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestFreezePeriodsService_CreateFreezePeriodOptions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/19/freeze_periods\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t   {\n\t\t\t  \"id\":1,\n\t\t\t  \"freeze_start\":\"0 23 * * 5\",\n\t\t\t  \"freeze_end\":\"0 8 * * 1\",\n\t\t\t  \"cron_timezone\":\"UTC\"\n\t\t   }\n\t\t`)\n\t})\n\n\twant := &FreezePeriod{\n\t\tID:           1,\n\t\tFreezeStart:  \"0 23 * * 5\",\n\t\tFreezeEnd:    \"0 8 * * 1\",\n\t\tCronTimezone: \"UTC\",\n\t}\n\n\tfp, resp, err := client.FreezePeriods.CreateFreezePeriodOptions(19, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fp)\n\n\tfp, resp, err = client.FreezePeriods.CreateFreezePeriodOptions(19.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 19.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fp)\n\n\tfp, resp, err = client.FreezePeriods.CreateFreezePeriodOptions(19, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fp)\n\n\tfp, resp, err = client.FreezePeriods.CreateFreezePeriodOptions(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fp)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestFreezePeriodsService_UpdateFreezePeriodOptions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/19/freeze_periods/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t   {\n\t\t\t  \"id\":1,\n\t\t\t  \"freeze_start\":\"0 23 * * 5\",\n\t\t\t  \"freeze_end\":\"0 8 * * 1\",\n\t\t\t  \"cron_timezone\":\"UTC\"\n\t\t   }\n\t\t`)\n\t})\n\n\twant := &FreezePeriod{\n\t\tID:           1,\n\t\tFreezeStart:  \"0 23 * * 5\",\n\t\tFreezeEnd:    \"0 8 * * 1\",\n\t\tCronTimezone: \"UTC\",\n\t}\n\n\tfp, resp, err := client.FreezePeriods.UpdateFreezePeriodOptions(19, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fp)\n\n\tfp, resp, err = client.FreezePeriods.UpdateFreezePeriodOptions(19.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 19.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fp)\n\n\tfp, resp, err = client.FreezePeriods.UpdateFreezePeriodOptions(19, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fp)\n\n\tfp, resp, err = client.FreezePeriods.UpdateFreezePeriodOptions(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fp)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestFreezePeriodsService_DeleteFreezePeriod(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/19/freeze_periods/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.FreezePeriods.DeleteFreezePeriod(19, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.FreezePeriods.DeleteFreezePeriod(19.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 19.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.FreezePeriods.DeleteFreezePeriod(19, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.FreezePeriods.DeleteFreezePeriod(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "generic_packages.go",
          "type": "blob",
          "size": 5.02734375,
          "content": "//\n// Copyright 2021, Sune Keller\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GenericPackagesService handles communication with the packages related\n// methods of the GitLab API.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/user/packages/generic_packages/index.html\ntype GenericPackagesService struct {\n\tclient *Client\n}\n\n// GenericPackagesFile represents a GitLab generic package file.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/packages/generic_packages/index.html#publish-a-package-file\ntype GenericPackagesFile struct {\n\tID        int        `json:\"id\"`\n\tPackageID int        `json:\"package_id\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tUpdatedAt *time.Time `json:\"updated_at\"`\n\tSize      int        `json:\"size\"`\n\tFileStore int        `json:\"file_store\"`\n\tFileMD5   string     `json:\"file_md5\"`\n\tFileSHA1  string     `json:\"file_sha1\"`\n\tFileName  string     `json:\"file_name\"`\n\tFile      struct {\n\t\tURL string `json:\"url\"`\n\t} `json:\"file\"`\n\tFileSHA256             string     `json:\"file_sha256\"`\n\tVerificationRetryAt    *time.Time `json:\"verification_retry_at\"`\n\tVerifiedAt             *time.Time `json:\"verified_at\"`\n\tVerificationFailure    bool       `json:\"verification_failure\"`\n\tVerificationRetryCount int        `json:\"verification_retry_count\"`\n\tVerificationChecksum   string     `json:\"verification_checksum\"`\n\tVerificationState      int        `json:\"verification_state\"`\n\tVerificationStartedAt  *time.Time `json:\"verification_started_at\"`\n\tNewFilePath            string     `json:\"new_file_path\"`\n}\n\n// FormatPackageURL returns the GitLab Package Registry URL for the given artifact metadata, without the BaseURL.\n// This does not make a GitLab API request, but rather computes it based on their documentation.\nfunc (s *GenericPackagesService) FormatPackageURL(pid interface{}, packageName, packageVersion, fileName string) (string, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/packages/generic/%s/%s/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(packageName),\n\t\tPathEscape(packageVersion),\n\t\tPathEscape(fileName),\n\t)\n\treturn u, nil\n}\n\n// PublishPackageFileOptions represents the available PublishPackageFile()\n// options.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/user/packages/generic_packages/index.html#publish-a-package-file\ntype PublishPackageFileOptions struct {\n\tStatus *GenericPackageStatusValue `url:\"status,omitempty\" json:\"status,omitempty\"`\n\tSelect *GenericPackageSelectValue `url:\"select,omitempty\" json:\"select,omitempty\"`\n}\n\n// PublishPackageFile uploads a file to a project's package registry.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/user/packages/generic_packages/index.html#publish-a-package-file\nfunc (s *GenericPackagesService) PublishPackageFile(pid interface{}, packageName, packageVersion, fileName string, content io.Reader, opt *PublishPackageFileOptions, options ...RequestOptionFunc) (*GenericPackagesFile, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/packages/generic/%s/%s/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(packageName),\n\t\tPathEscape(packageVersion),\n\t\tPathEscape(fileName),\n\t)\n\n\t// We need to create the request as a GET request to make sure the options\n\t// are set correctly. After the request is created we will overwrite both\n\t// the method and the body.\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Overwrite the method and body.\n\treq.Method = http.MethodPut\n\treq.SetBody(content)\n\n\tf := new(GenericPackagesFile)\n\tresp, err := s.client.Do(req, f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f, resp, nil\n}\n\n// DownloadPackageFile allows you to download the package file.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/user/packages/generic_packages/index.html#download-package-file\nfunc (s *GenericPackagesService) DownloadPackageFile(pid interface{}, packageName, packageVersion, fileName string, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/packages/generic/%s/%s/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(packageName),\n\t\tPathEscape(packageVersion),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar f bytes.Buffer\n\tresp, err := s.client.Do(req, &f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f.Bytes(), resp, err\n}\n"
        },
        {
          "name": "generic_packages_test.go",
          "type": "blob",
          "size": 1.8408203125,
          "content": "//\n// Copyright 2021, Sune Keller\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPublishPackageFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/packages/generic/foo/0.1.2/bar-baz.txt\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"message\": \"201 Created\"\n\t\t}\n\t`)\n\t})\n\n\t_, _, err := client.GenericPackages.PublishPackageFile(1234, \"foo\", \"0.1.2\", \"bar-baz.txt\", strings.NewReader(\"bar = baz\"), &PublishPackageFileOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GenericPackages.PublishPackageFile returned error: %v\", err)\n\t}\n}\n\nfunc TestDownloadPackageFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/packages/generic/foo/0.1.2/bar-baz.txt\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, strings.TrimSpace(`\n\t\tbar = baz\n\t`))\n\t})\n\n\tpackageBytes, _, err := client.GenericPackages.DownloadPackageFile(1234, \"foo\", \"0.1.2\", \"bar-baz.txt\")\n\tif err != nil {\n\t\tt.Errorf(\"GenericPackages.DownloadPackageFile returned error: %v\", err)\n\t}\n\n\twant := []byte(\"bar = baz\")\n\tif !reflect.DeepEqual(want, packageBytes) {\n\t\tt.Errorf(\"GenericPackages.DownloadPackageFile returned %+v, want %+v\", packageBytes, want)\n\t}\n}\n"
        },
        {
          "name": "geo_nodes.go",
          "type": "blob",
          "size": 25.5107421875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GeoNode represents a GitLab Geo Node.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/geo_nodes.html\ntype GeoNode struct {\n\tID                               int          `json:\"id\"`\n\tName                             string       `json:\"name\"`\n\tURL                              string       `json:\"url\"`\n\tInternalURL                      string       `json:\"internal_url\"`\n\tPrimary                          bool         `json:\"primary\"`\n\tEnabled                          bool         `json:\"enabled\"`\n\tCurrent                          bool         `json:\"current\"`\n\tFilesMaxCapacity                 int          `json:\"files_max_capacity\"`\n\tReposMaxCapacity                 int          `json:\"repos_max_capacity\"`\n\tVerificationMaxCapacity          int          `json:\"verification_max_capacity\"`\n\tSelectiveSyncType                string       `json:\"selective_sync_type\"`\n\tSelectiveSyncShards              []string     `json:\"selective_sync_shards\"`\n\tSelectiveSyncNamespaceIds        []int        `json:\"selective_sync_namespace_ids\"`\n\tMinimumReverificationInterval    int          `json:\"minimum_reverification_interval\"`\n\tContainerRepositoriesMaxCapacity int          `json:\"container_repositories_max_capacity\"`\n\tSyncObjectStorage                bool         `json:\"sync_object_storage\"`\n\tCloneProtocol                    string       `json:\"clone_protocol\"`\n\tWebEditURL                       string       `json:\"web_edit_url\"`\n\tWebGeoProjectsURL                string       `json:\"web_geo_projects_url\"`\n\tLinks                            GeoNodeLinks `json:\"_links\"`\n}\n\n// GeoNodeLinks represents links for GitLab GeoNode.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/geo_nodes.html\ntype GeoNodeLinks struct {\n\tSelf   string `json:\"self\"`\n\tStatus string `json:\"status\"`\n\tRepair string `json:\"repair\"`\n}\n\n// GeoNodesService handles communication with Geo Nodes related methods\n// of GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/geo_nodes.html\ntype GeoNodesService struct {\n\tclient *Client\n}\n\n// CreateGeoNodesOptions represents the available CreateGeoNode() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#create-a-new-geo-node\ntype CreateGeoNodesOptions struct {\n\tPrimary                          *bool     `url:\"primary,omitempty\" json:\"primary,omitempty\"`\n\tEnabled                          *bool     `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\tName                             *string   `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tURL                              *string   `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tInternalURL                      *string   `url:\"internal_url,omitempty\" json:\"internal_url,omitempty\"`\n\tFilesMaxCapacity                 *int      `url:\"files_max_capacity,omitempty\" json:\"files_max_capacity,omitempty\"`\n\tReposMaxCapacity                 *int      `url:\"repos_max_capacity,omitempty\" json:\"repos_max_capacity,omitempty\"`\n\tVerificationMaxCapacity          *int      `url:\"verification_max_capacity,omitempty\" json:\"verification_max_capacity,omitempty\"`\n\tContainerRepositoriesMaxCapacity *int      `url:\"container_repositories_max_capacity,omitempty\" json:\"container_repositories_max_capacity,omitempty\"`\n\tSyncObjectStorage                *bool     `url:\"sync_object_storage,omitempty\" json:\"sync_object_storage,omitempty\"`\n\tSelectiveSyncType                *string   `url:\"selective_sync_type,omitempty\" json:\"selective_sync_type,omitempty\"`\n\tSelectiveSyncShards              *[]string `url:\"selective_sync_shards,omitempty\" json:\"selective_sync_shards,omitempty\"`\n\tSelectiveSyncNamespaceIds        *[]int    `url:\"selective_sync_namespace_ids,omitempty\" json:\"selective_sync_namespace_ids,omitempty\"`\n\tMinimumReverificationInterval    *int      `url:\"minimum_reverification_interval,omitempty\" json:\"minimum_reverification_interval,omitempty\"`\n}\n\n// CreateGeoNode creates a new Geo Node.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#create-a-new-geo-node\nfunc (s *GeoNodesService) CreateGeoNode(opt *CreateGeoNodesOptions, options ...RequestOptionFunc) (*GeoNode, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"geo_nodes\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(GeoNode)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// ListGeoNodesOptions represents the available ListGeoNodes() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#retrieve-configuration-about-all-geo-nodes\ntype ListGeoNodesOptions ListOptions\n\n// ListGeoNodes gets a list of geo nodes.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#retrieve-configuration-about-all-geo-nodes\nfunc (s *GeoNodesService) ListGeoNodes(opt *ListGeoNodesOptions, options ...RequestOptionFunc) ([]*GeoNode, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"geo_nodes\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*GeoNode\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// GetGeoNode gets a specific geo node.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#retrieve-configuration-about-a-specific-geo-node\nfunc (s *GeoNodesService) GetGeoNode(id int, options ...RequestOptionFunc) (*GeoNode, *Response, error) {\n\tu := fmt.Sprintf(\"geo_nodes/%d\", id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(GeoNode)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// UpdateGeoNodesOptions represents the available EditGeoNode() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#edit-a-geo-node\ntype UpdateGeoNodesOptions struct {\n\tID                               *int      `url:\"primary,omitempty\" json:\"primary,omitempty\"`\n\tEnabled                          *bool     `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\tName                             *string   `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tURL                              *string   `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tInternalURL                      *string   `url:\"internal_url,omitempty\" json:\"internal_url,omitempty\"`\n\tFilesMaxCapacity                 *int      `url:\"files_max_capacity,omitempty\" json:\"files_max_capacity,omitempty\"`\n\tReposMaxCapacity                 *int      `url:\"repos_max_capacity,omitempty\" json:\"repos_max_capacity,omitempty\"`\n\tVerificationMaxCapacity          *int      `url:\"verification_max_capacity,omitempty\" json:\"verification_max_capacity,omitempty\"`\n\tContainerRepositoriesMaxCapacity *int      `url:\"container_repositories_max_capacity,omitempty\" json:\"container_repositories_max_capacity,omitempty\"`\n\tSyncObjectStorage                *bool     `url:\"sync_object_storage,omitempty\" json:\"sync_object_storage,omitempty\"`\n\tSelectiveSyncType                *string   `url:\"selective_sync_type,omitempty\" json:\"selective_sync_type,omitempty\"`\n\tSelectiveSyncShards              *[]string `url:\"selective_sync_shards,omitempty\" json:\"selective_sync_shards,omitempty\"`\n\tSelectiveSyncNamespaceIds        *[]int    `url:\"selective_sync_namespace_ids,omitempty\" json:\"selective_sync_namespace_ids,omitempty\"`\n\tMinimumReverificationInterval    *int      `url:\"minimum_reverification_interval,omitempty\" json:\"minimum_reverification_interval,omitempty\"`\n}\n\n// EditGeoNode updates settings of an existing Geo node.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#edit-a-geo-node\nfunc (s *GeoNodesService) EditGeoNode(id int, opt *UpdateGeoNodesOptions, options ...RequestOptionFunc) (*GeoNode, *Response, error) {\n\tu := fmt.Sprintf(\"geo_nodes/%d\", id)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(GeoNode)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// DeleteGeoNode removes the Geo node.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#delete-a-geo-node\nfunc (s *GeoNodesService) DeleteGeoNode(id int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"geo_nodes/%d\", id)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// RepairGeoNode to repair the OAuth authentication of a Geo node.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#repair-a-geo-node\nfunc (s *GeoNodesService) RepairGeoNode(id int, options ...RequestOptionFunc) (*GeoNode, *Response, error) {\n\tu := fmt.Sprintf(\"geo_nodes/%d/repair\", id)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(GeoNode)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// GeoNodeStatus represents the status of Geo Node.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#retrieve-status-about-all-geo-nodes\ntype GeoNodeStatus struct {\n\tGeoNodeID                                     int    `json:\"geo_node_id\"`\n\tHealthy                                       bool   `json:\"healthy\"`\n\tHealth                                        string `json:\"health\"`\n\tHealthStatus                                  string `json:\"health_status\"`\n\tMissingOauthApplication                       bool   `json:\"missing_oauth_application\"`\n\tAttachmentsCount                              int    `json:\"attachments_count\"`\n\tAttachmentsSyncedCount                        int    `json:\"attachments_synced_count\"`\n\tAttachmentsFailedCount                        int    `json:\"attachments_failed_count\"`\n\tAttachmentsSyncedMissingOnPrimaryCount        int    `json:\"attachments_synced_missing_on_primary_count\"`\n\tAttachmentsSyncedInPercentage                 string `json:\"attachments_synced_in_percentage\"`\n\tDbReplicationLagSeconds                       int    `json:\"db_replication_lag_seconds\"`\n\tLfsObjectsCount                               int    `json:\"lfs_objects_count\"`\n\tLfsObjectsSyncedCount                         int    `json:\"lfs_objects_synced_count\"`\n\tLfsObjectsFailedCount                         int    `json:\"lfs_objects_failed_count\"`\n\tLfsObjectsSyncedMissingOnPrimaryCount         int    `json:\"lfs_objects_synced_missing_on_primary_count\"`\n\tLfsObjectsSyncedInPercentage                  string `json:\"lfs_objects_synced_in_percentage\"`\n\tJobArtifactsCount                             int    `json:\"job_artifacts_count\"`\n\tJobArtifactsSyncedCount                       int    `json:\"job_artifacts_synced_count\"`\n\tJobArtifactsFailedCount                       int    `json:\"job_artifacts_failed_count\"`\n\tJobArtifactsSyncedMissingOnPrimaryCount       int    `json:\"job_artifacts_synced_missing_on_primary_count\"`\n\tJobArtifactsSyncedInPercentage                string `json:\"job_artifacts_synced_in_percentage\"`\n\tContainerRepositoriesCount                    int    `json:\"container_repositories_count\"`\n\tContainerRepositoriesSyncedCount              int    `json:\"container_repositories_synced_count\"`\n\tContainerRepositoriesFailedCount              int    `json:\"container_repositories_failed_count\"`\n\tContainerRepositoriesSyncedInPercentage       string `json:\"container_repositories_synced_in_percentage\"`\n\tDesignRepositoriesCount                       int    `json:\"design_repositories_count\"`\n\tDesignRepositoriesSyncedCount                 int    `json:\"design_repositories_synced_count\"`\n\tDesignRepositoriesFailedCount                 int    `json:\"design_repositories_failed_count\"`\n\tDesignRepositoriesSyncedInPercentage          string `json:\"design_repositories_synced_in_percentage\"`\n\tProjectsCount                                 int    `json:\"projects_count\"`\n\tRepositoriesCount                             int    `json:\"repositories_count\"`\n\tRepositoriesFailedCount                       int    `json:\"repositories_failed_count\"`\n\tRepositoriesSyncedCount                       int    `json:\"repositories_synced_count\"`\n\tRepositoriesSyncedInPercentage                string `json:\"repositories_synced_in_percentage\"`\n\tWikisCount                                    int    `json:\"wikis_count\"`\n\tWikisFailedCount                              int    `json:\"wikis_failed_count\"`\n\tWikisSyncedCount                              int    `json:\"wikis_synced_count\"`\n\tWikisSyncedInPercentage                       string `json:\"wikis_synced_in_percentage\"`\n\tReplicationSlotsCount                         int    `json:\"replication_slots_count\"`\n\tReplicationSlotsUsedCount                     int    `json:\"replication_slots_used_count\"`\n\tReplicationSlotsUsedInPercentage              string `json:\"replication_slots_used_in_percentage\"`\n\tReplicationSlotsMaxRetainedWalBytes           int    `json:\"replication_slots_max_retained_wal_bytes\"`\n\tRepositoriesCheckedCount                      int    `json:\"repositories_checked_count\"`\n\tRepositoriesCheckedFailedCount                int    `json:\"repositories_checked_failed_count\"`\n\tRepositoriesCheckedInPercentage               string `json:\"repositories_checked_in_percentage\"`\n\tRepositoriesChecksummedCount                  int    `json:\"repositories_checksummed_count\"`\n\tRepositoriesChecksumFailedCount               int    `json:\"repositories_checksum_failed_count\"`\n\tRepositoriesChecksummedInPercentage           string `json:\"repositories_checksummed_in_percentage\"`\n\tWikisChecksummedCount                         int    `json:\"wikis_checksummed_count\"`\n\tWikisChecksumFailedCount                      int    `json:\"wikis_checksum_failed_count\"`\n\tWikisChecksummedInPercentage                  string `json:\"wikis_checksummed_in_percentage\"`\n\tRepositoriesVerifiedCount                     int    `json:\"repositories_verified_count\"`\n\tRepositoriesVerificationFailedCount           int    `json:\"repositories_verification_failed_count\"`\n\tRepositoriesVerifiedInPercentage              string `json:\"repositories_verified_in_percentage\"`\n\tRepositoriesChecksumMismatchCount             int    `json:\"repositories_checksum_mismatch_count\"`\n\tWikisVerifiedCount                            int    `json:\"wikis_verified_count\"`\n\tWikisVerificationFailedCount                  int    `json:\"wikis_verification_failed_count\"`\n\tWikisVerifiedInPercentage                     string `json:\"wikis_verified_in_percentage\"`\n\tWikisChecksumMismatchCount                    int    `json:\"wikis_checksum_mismatch_count\"`\n\tRepositoriesRetryingVerificationCount         int    `json:\"repositories_retrying_verification_count\"`\n\tWikisRetryingVerificationCount                int    `json:\"wikis_retrying_verification_count\"`\n\tLastEventID                                   int    `json:\"last_event_id\"`\n\tLastEventTimestamp                            int    `json:\"last_event_timestamp\"`\n\tCursorLastEventID                             int    `json:\"cursor_last_event_id\"`\n\tCursorLastEventTimestamp                      int    `json:\"cursor_last_event_timestamp\"`\n\tLastSuccessfulStatusCheckTimestamp            int    `json:\"last_successful_status_check_timestamp\"`\n\tVersion                                       string `json:\"version\"`\n\tRevision                                      string `json:\"revision\"`\n\tMergeRequestDiffsCount                        int    `json:\"merge_request_diffs_count\"`\n\tMergeRequestDiffsChecksumTotalCount           int    `json:\"merge_request_diffs_checksum_total_count\"`\n\tMergeRequestDiffsChecksummedCount             int    `json:\"merge_request_diffs_checksummed_count\"`\n\tMergeRequestDiffsChecksumFailedCount          int    `json:\"merge_request_diffs_checksum_failed_count\"`\n\tMergeRequestDiffsSyncedCount                  int    `json:\"merge_request_diffs_synced_count\"`\n\tMergeRequestDiffsFailedCount                  int    `json:\"merge_request_diffs_failed_count\"`\n\tMergeRequestDiffsRegistryCount                int    `json:\"merge_request_diffs_registry_count\"`\n\tMergeRequestDiffsVerificationTotalCount       int    `json:\"merge_request_diffs_verification_total_count\"`\n\tMergeRequestDiffsVerifiedCount                int    `json:\"merge_request_diffs_verified_count\"`\n\tMergeRequestDiffsVerificationFailedCount      int    `json:\"merge_request_diffs_verification_failed_count\"`\n\tMergeRequestDiffsSyncedInPercentage           string `json:\"merge_request_diffs_synced_in_percentage\"`\n\tMergeRequestDiffsVerifiedInPercentage         string `json:\"merge_request_diffs_verified_in_percentage\"`\n\tPackageFilesCount                             int    `json:\"package_files_count\"`\n\tPackageFilesChecksumTotalCount                int    `json:\"package_files_checksum_total_count\"`\n\tPackageFilesChecksummedCount                  int    `json:\"package_files_checksummed_count\"`\n\tPackageFilesChecksumFailedCount               int    `json:\"package_files_checksum_failed_count\"`\n\tPackageFilesSyncedCount                       int    `json:\"package_files_synced_count\"`\n\tPackageFilesFailedCount                       int    `json:\"package_files_failed_count\"`\n\tPackageFilesRegistryCount                     int    `json:\"package_files_registry_count\"`\n\tPackageFilesVerificationTotalCount            int    `json:\"package_files_verification_total_count\"`\n\tPackageFilesVerifiedCount                     int    `json:\"package_files_verified_count\"`\n\tPackageFilesVerificationFailedCount           int    `json:\"package_files_verification_failed_count\"`\n\tPackageFilesSyncedInPercentage                string `json:\"package_files_synced_in_percentage\"`\n\tPackageFilesVerifiedInPercentage              string `json:\"package_files_verified_in_percentage\"`\n\tPagesDeploymentsCount                         int    `json:\"pages_deployments_count\"`\n\tPagesDeploymentsChecksumTotalCount            int    `json:\"pages_deployments_checksum_total_count\"`\n\tPagesDeploymentsChecksummedCount              int    `json:\"pages_deployments_checksummed_count\"`\n\tPagesDeploymentsChecksumFailedCount           int    `json:\"pages_deployments_checksum_failed_count\"`\n\tPagesDeploymentsSyncedCount                   int    `json:\"pages_deployments_synced_count\"`\n\tPagesDeploymentsFailedCount                   int    `json:\"pages_deployments_failed_count\"`\n\tPagesDeploymentsRegistryCount                 int    `json:\"pages_deployments_registry_count\"`\n\tPagesDeploymentsVerificationTotalCount        int    `json:\"pages_deployments_verification_total_count\"`\n\tPagesDeploymentsVerifiedCount                 int    `json:\"pages_deployments_verified_count\"`\n\tPagesDeploymentsVerificationFailedCount       int    `json:\"pages_deployments_verification_failed_count\"`\n\tPagesDeploymentsSyncedInPercentage            string `json:\"pages_deployments_synced_in_percentage\"`\n\tPagesDeploymentsVerifiedInPercentage          string `json:\"pages_deployments_verified_in_percentage\"`\n\tTerraformStateVersionsCount                   int    `json:\"terraform_state_versions_count\"`\n\tTerraformStateVersionsChecksumTotalCount      int    `json:\"terraform_state_versions_checksum_total_count\"`\n\tTerraformStateVersionsChecksummedCount        int    `json:\"terraform_state_versions_checksummed_count\"`\n\tTerraformStateVersionsChecksumFailedCount     int    `json:\"terraform_state_versions_checksum_failed_count\"`\n\tTerraformStateVersionsSyncedCount             int    `json:\"terraform_state_versions_synced_count\"`\n\tTerraformStateVersionsFailedCount             int    `json:\"terraform_state_versions_failed_count\"`\n\tTerraformStateVersionsRegistryCount           int    `json:\"terraform_state_versions_registry_count\"`\n\tTerraformStateVersionsVerificationTotalCount  int    `json:\"terraform_state_versions_verification_total_count\"`\n\tTerraformStateVersionsVerifiedCount           int    `json:\"terraform_state_versions_verified_count\"`\n\tTerraformStateVersionsVerificationFailedCount int    `json:\"terraform_state_versions_verification_failed_count\"`\n\tTerraformStateVersionsSyncedInPercentage      string `json:\"terraform_state_versions_synced_in_percentage\"`\n\tTerraformStateVersionsVerifiedInPercentage    string `json:\"terraform_state_versions_verified_in_percentage\"`\n\tSnippetRepositoriesCount                      int    `json:\"snippet_repositories_count\"`\n\tSnippetRepositoriesChecksumTotalCount         int    `json:\"snippet_repositories_checksum_total_count\"`\n\tSnippetRepositoriesChecksummedCount           int    `json:\"snippet_repositories_checksummed_count\"`\n\tSnippetRepositoriesChecksumFailedCount        int    `json:\"snippet_repositories_checksum_failed_count\"`\n\tSnippetRepositoriesSyncedCount                int    `json:\"snippet_repositories_synced_count\"`\n\tSnippetRepositoriesFailedCount                int    `json:\"snippet_repositories_failed_count\"`\n\tSnippetRepositoriesRegistryCount              int    `json:\"snippet_repositories_registry_count\"`\n\tSnippetRepositoriesVerificationTotalCount     int    `json:\"snippet_repositories_verification_total_count\"`\n\tSnippetRepositoriesVerifiedCount              int    `json:\"snippet_repositories_verified_count\"`\n\tSnippetRepositoriesVerificationFailedCount    int    `json:\"snippet_repositories_verification_failed_count\"`\n\tSnippetRepositoriesSyncedInPercentage         string `json:\"snippet_repositories_synced_in_percentage\"`\n\tSnippetRepositoriesVerifiedInPercentage       string `json:\"snippet_repositories_verified_in_percentage\"`\n\tGroupWikiRepositoriesCount                    int    `json:\"group_wiki_repositories_count\"`\n\tGroupWikiRepositoriesChecksumTotalCount       int    `json:\"group_wiki_repositories_checksum_total_count\"`\n\tGroupWikiRepositoriesChecksummedCount         int    `json:\"group_wiki_repositories_checksummed_count\"`\n\tGroupWikiRepositoriesChecksumFailedCount      int    `json:\"group_wiki_repositories_checksum_failed_count\"`\n\tGroupWikiRepositoriesSyncedCount              int    `json:\"group_wiki_repositories_synced_count\"`\n\tGroupWikiRepositoriesFailedCount              int    `json:\"group_wiki_repositories_failed_count\"`\n\tGroupWikiRepositoriesRegistryCount            int    `json:\"group_wiki_repositories_registry_count\"`\n\tGroupWikiRepositoriesVerificationTotalCount   int    `json:\"group_wiki_repositories_verification_total_count\"`\n\tGroupWikiRepositoriesVerifiedCount            int    `json:\"group_wiki_repositories_verified_count\"`\n\tGroupWikiRepositoriesVerificationFailedCount  int    `json:\"group_wiki_repositories_verification_failed_count\"`\n\tGroupWikiRepositoriesSyncedInPercentage       string `json:\"group_wiki_repositories_synced_in_percentage\"`\n\tGroupWikiRepositoriesVerifiedInPercentage     string `json:\"group_wiki_repositories_verified_in_percentage\"`\n\tPipelineArtifactsCount                        int    `json:\"pipeline_artifacts_count\"`\n\tPipelineArtifactsChecksumTotalCount           int    `json:\"pipeline_artifacts_checksum_total_count\"`\n\tPipelineArtifactsChecksummedCount             int    `json:\"pipeline_artifacts_checksummed_count\"`\n\tPipelineArtifactsChecksumFailedCount          int    `json:\"pipeline_artifacts_checksum_failed_count\"`\n\tPipelineArtifactsSyncedCount                  int    `json:\"pipeline_artifacts_synced_count\"`\n\tPipelineArtifactsFailedCount                  int    `json:\"pipeline_artifacts_failed_count\"`\n\tPipelineArtifactsRegistryCount                int    `json:\"pipeline_artifacts_registry_count\"`\n\tPipelineArtifactsVerificationTotalCount       int    `json:\"pipeline_artifacts_verification_total_count\"`\n\tPipelineArtifactsVerifiedCount                int    `json:\"pipeline_artifacts_verified_count\"`\n\tPipelineArtifactsVerificationFailedCount      int    `json:\"pipeline_artifacts_verification_failed_count\"`\n\tPipelineArtifactsSyncedInPercentage           string `json:\"pipeline_artifacts_synced_in_percentage\"`\n\tPipelineArtifactsVerifiedInPercentage         string `json:\"pipeline_artifacts_verified_in_percentage\"`\n\tUploadsCount                                  int    `json:\"uploads_count\"`\n\tUploadsSyncedCount                            int    `json:\"uploads_synced_count\"`\n\tUploadsFailedCount                            int    `json:\"uploads_failed_count\"`\n\tUploadsRegistryCount                          int    `json:\"uploads_registry_count\"`\n\tUploadsSyncedInPercentage                     string `json:\"uploads_synced_in_percentage\"`\n}\n\n// RetrieveStatusOfAllGeoNodes get the list of status of all Geo Nodes.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#retrieve-status-about-all-geo-nodes\nfunc (s *GeoNodesService) RetrieveStatusOfAllGeoNodes(options ...RequestOptionFunc) ([]*GeoNodeStatus, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"geo_nodes/status\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gnss []*GeoNodeStatus\n\tresp, err := s.client.Do(req, &gnss)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gnss, resp, nil\n}\n\n// RetrieveStatusOfGeoNode get the of status of a specific Geo Nodes.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/geo_nodes.html#retrieve-status-about-a-specific-geo-node\nfunc (s *GeoNodesService) RetrieveStatusOfGeoNode(id int, options ...RequestOptionFunc) (*GeoNodeStatus, *Response, error) {\n\tu := fmt.Sprintf(\"geo_nodes/%d/status\", id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgns := new(GeoNodeStatus)\n\tresp, err := s.client.Do(req, gns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gns, resp, nil\n}\n"
        },
        {
          "name": "geo_nodes_test.go",
          "type": "blob",
          "size": 25.708984375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGeoNodesService_CreateGeoNode(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 3,\n\t\t\t  \"name\": \"Test Node 1\",\n\t\t\t  \"url\": \"https://secondary.example.com/\",\n\t\t\t  \"internal_url\": \"https://secondary.example.com/\",\n\t\t\t  \"primary\": false,\n\t\t\t  \"enabled\": true,\n\t\t\t  \"current\": false,\n\t\t\t  \"files_max_capacity\": 10,\n\t\t\t  \"repos_max_capacity\": 25,\n\t\t\t  \"verification_max_capacity\": 100,\n\t\t\t  \"selective_sync_type\": \"namespaces\",\n\t\t\t  \"selective_sync_shards\": null,\n\t\t\t  \"selective_sync_namespace_ids\": [1, 25],\n\t\t\t  \"minimum_reverification_interval\": 7,\n\t\t\t  \"container_repositories_max_capacity\": 10,\n\t\t\t  \"sync_object_storage\": false,\n\t\t\t  \"clone_protocol\": \"http\",\n\t\t\t  \"web_edit_url\": \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\t\t  \"web_geo_projects_url\": \"http://secondary.example.com/admin/geo/projects\",\n\t\t\t  \"_links\": {\n\t\t\t\t \"self\": \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\t\t \"status\": \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\t\t \"repair\": \"https://primary.example.com/api/v4/geo_nodes/3/repair\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &GeoNode{\n\t\tID:                               3,\n\t\tName:                             \"Test Node 1\",\n\t\tURL:                              \"https://secondary.example.com/\",\n\t\tInternalURL:                      \"https://secondary.example.com/\",\n\t\tPrimary:                          false,\n\t\tEnabled:                          true,\n\t\tCurrent:                          false,\n\t\tFilesMaxCapacity:                 10,\n\t\tReposMaxCapacity:                 25,\n\t\tVerificationMaxCapacity:          100,\n\t\tSelectiveSyncType:                \"namespaces\",\n\t\tSelectiveSyncShards:              nil,\n\t\tSelectiveSyncNamespaceIds:        []int{1, 25},\n\t\tMinimumReverificationInterval:    7,\n\t\tContainerRepositoriesMaxCapacity: 10,\n\t\tSyncObjectStorage:                false,\n\t\tCloneProtocol:                    \"http\",\n\t\tWebEditURL:                       \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\tWebGeoProjectsURL:                \"http://secondary.example.com/admin/geo/projects\",\n\t\tLinks: GeoNodeLinks{\n\t\t\tSelf:   \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\tStatus: \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\tRepair: \"https://primary.example.com/api/v4/geo_nodes/3/repair\",\n\t\t},\n\t}\n\n\tg, resp, err := client.GeoNodes.CreateGeoNode(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, g)\n\n\tg, resp, err = client.GeoNodes.CreateGeoNode(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, g)\n}\n\nfunc TestGeoNodesService_CreateGeoNode_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tg, resp, err := client.GeoNodes.CreateGeoNode(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, g)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_ListGeoNodes(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t  \"id\": 3,\n\t\t\t\t  \"name\": \"in-node\",\n\t\t\t\t  \"url\": \"https://secondary.example.com/\",\n\t\t\t\t  \"internal_url\": \"https://secondary.example.com/\",\n\t\t\t\t  \"primary\": false,\n\t\t\t\t  \"enabled\": true,\n\t\t\t\t  \"current\": false,\n\t\t\t\t  \"files_max_capacity\": 10,\n\t\t\t\t  \"repos_max_capacity\": 25,\n\t\t\t\t  \"verification_max_capacity\": 100,\n\t\t\t\t  \"selective_sync_type\": \"namespaces\",\n\t\t\t\t  \"selective_sync_shards\": null,\n\t\t\t\t  \"selective_sync_namespace_ids\": [1, 25],\n\t\t\t\t  \"minimum_reverification_interval\": 7,\n\t\t\t\t  \"container_repositories_max_capacity\": 10,\n\t\t\t\t  \"sync_object_storage\": false,\n\t\t\t\t  \"clone_protocol\": \"http\",\n\t\t\t\t  \"web_edit_url\": \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\t\t\t  \"web_geo_projects_url\": \"http://secondary.example.com/admin/geo/projects\",\n\t\t\t\t  \"_links\": {\n\t\t\t\t\t \"self\": \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\t\t\t \"status\": \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\t\t\t \"repair\": \"https://primary.example.com/api/v4/geo_nodes/3/repair\"\n\t\t\t\t  }\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*GeoNode{\n\t\t{\n\t\t\tID:                               3,\n\t\t\tName:                             \"in-node\",\n\t\t\tURL:                              \"https://secondary.example.com/\",\n\t\t\tInternalURL:                      \"https://secondary.example.com/\",\n\t\t\tPrimary:                          false,\n\t\t\tEnabled:                          true,\n\t\t\tCurrent:                          false,\n\t\t\tFilesMaxCapacity:                 10,\n\t\t\tReposMaxCapacity:                 25,\n\t\t\tVerificationMaxCapacity:          100,\n\t\t\tSelectiveSyncType:                \"namespaces\",\n\t\t\tSelectiveSyncShards:              nil,\n\t\t\tSelectiveSyncNamespaceIds:        []int{1, 25},\n\t\t\tMinimumReverificationInterval:    7,\n\t\t\tContainerRepositoriesMaxCapacity: 10,\n\t\t\tSyncObjectStorage:                false,\n\t\t\tCloneProtocol:                    \"http\",\n\t\t\tWebEditURL:                       \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\t\tWebGeoProjectsURL:                \"http://secondary.example.com/admin/geo/projects\",\n\t\t\tLinks: GeoNodeLinks{\n\t\t\t\tSelf:   \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\t\tStatus: \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\t\tRepair: \"https://primary.example.com/api/v4/geo_nodes/3/repair\",\n\t\t\t},\n\t\t},\n\t}\n\n\tgs, resp, err := client.GeoNodes.ListGeoNodes(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gs)\n\n\tgs, resp, err = client.GeoNodes.ListGeoNodes(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gs)\n}\n\nfunc TestGeoNodesService_ListGeoNodes_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tgs, resp, err := client.GeoNodes.ListGeoNodes(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_GetGeoNode(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 3,\n\t\t\t  \"name\": \"in-node\",\n\t\t\t  \"url\": \"https://secondary.example.com/\",\n\t\t\t  \"internal_url\": \"https://secondary.example.com/\",\n\t\t\t  \"primary\": false,\n\t\t\t  \"enabled\": true,\n\t\t\t  \"current\": false,\n\t\t\t  \"files_max_capacity\": 10,\n\t\t\t  \"repos_max_capacity\": 25,\n\t\t\t  \"verification_max_capacity\": 100,\n\t\t\t  \"selective_sync_type\": \"namespaces\",\n\t\t\t  \"selective_sync_shards\": null,\n\t\t\t  \"selective_sync_namespace_ids\": [1, 25],\n\t\t\t  \"minimum_reverification_interval\": 7,\n\t\t\t  \"container_repositories_max_capacity\": 10,\n\t\t\t  \"sync_object_storage\": false,\n\t\t\t  \"clone_protocol\": \"http\",\n\t\t\t  \"web_edit_url\": \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\t\t  \"web_geo_projects_url\": \"http://secondary.example.com/admin/geo/projects\",\n\t\t\t  \"_links\": {\n\t\t\t\t \"self\": \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\t\t \"status\": \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\t\t \"repair\": \"https://primary.example.com/api/v4/geo_nodes/3/repair\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &GeoNode{\n\t\tID:                               3,\n\t\tName:                             \"in-node\",\n\t\tURL:                              \"https://secondary.example.com/\",\n\t\tInternalURL:                      \"https://secondary.example.com/\",\n\t\tPrimary:                          false,\n\t\tEnabled:                          true,\n\t\tCurrent:                          false,\n\t\tFilesMaxCapacity:                 10,\n\t\tReposMaxCapacity:                 25,\n\t\tVerificationMaxCapacity:          100,\n\t\tSelectiveSyncType:                \"namespaces\",\n\t\tSelectiveSyncShards:              nil,\n\t\tSelectiveSyncNamespaceIds:        []int{1, 25},\n\t\tMinimumReverificationInterval:    7,\n\t\tContainerRepositoriesMaxCapacity: 10,\n\t\tSyncObjectStorage:                false,\n\t\tCloneProtocol:                    \"http\",\n\t\tWebEditURL:                       \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\tWebGeoProjectsURL:                \"http://secondary.example.com/admin/geo/projects\",\n\t\tLinks: GeoNodeLinks{\n\t\t\tSelf:   \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\tStatus: \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\tRepair: \"https://primary.example.com/api/v4/geo_nodes/3/repair\",\n\t\t},\n\t}\n\n\tg, resp, err := client.GeoNodes.GetGeoNode(3, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, g)\n\n\tg, resp, err = client.GeoNodes.GetGeoNode(3, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, g)\n\n\tg, resp, err = client.GeoNodes.GetGeoNode(5, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, g)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_EditGeoNode(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 3,\n\t\t\t  \"name\": \"in-node\",\n\t\t\t  \"url\": \"https://secondary.example.com/\",\n\t\t\t  \"internal_url\": \"https://secondary.example.com/\",\n\t\t\t  \"primary\": false,\n\t\t\t  \"enabled\": true,\n\t\t\t  \"current\": false,\n\t\t\t  \"files_max_capacity\": 10,\n\t\t\t  \"repos_max_capacity\": 25,\n\t\t\t  \"verification_max_capacity\": 100,\n\t\t\t  \"selective_sync_type\": \"namespaces\",\n\t\t\t  \"selective_sync_shards\": null,\n\t\t\t  \"selective_sync_namespace_ids\": [1, 25],\n\t\t\t  \"minimum_reverification_interval\": 7,\n\t\t\t  \"container_repositories_max_capacity\": 10,\n\t\t\t  \"sync_object_storage\": false,\n\t\t\t  \"clone_protocol\": \"http\",\n\t\t\t  \"web_edit_url\": \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\t\t  \"web_geo_projects_url\": \"http://secondary.example.com/admin/geo/projects\",\n\t\t\t  \"_links\": {\n\t\t\t\t \"self\": \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\t\t \"status\": \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\t\t \"repair\": \"https://primary.example.com/api/v4/geo_nodes/3/repair\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &GeoNode{\n\t\tID:                               3,\n\t\tName:                             \"in-node\",\n\t\tURL:                              \"https://secondary.example.com/\",\n\t\tInternalURL:                      \"https://secondary.example.com/\",\n\t\tPrimary:                          false,\n\t\tEnabled:                          true,\n\t\tCurrent:                          false,\n\t\tFilesMaxCapacity:                 10,\n\t\tReposMaxCapacity:                 25,\n\t\tVerificationMaxCapacity:          100,\n\t\tSelectiveSyncType:                \"namespaces\",\n\t\tSelectiveSyncShards:              nil,\n\t\tSelectiveSyncNamespaceIds:        []int{1, 25},\n\t\tMinimumReverificationInterval:    7,\n\t\tContainerRepositoriesMaxCapacity: 10,\n\t\tSyncObjectStorage:                false,\n\t\tCloneProtocol:                    \"http\",\n\t\tWebEditURL:                       \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\tWebGeoProjectsURL:                \"http://secondary.example.com/admin/geo/projects\",\n\t\tLinks: GeoNodeLinks{\n\t\t\tSelf:   \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\tStatus: \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\tRepair: \"https://primary.example.com/api/v4/geo_nodes/3/repair\",\n\t\t},\n\t}\n\n\tg, resp, err := client.GeoNodes.EditGeoNode(3, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, g)\n\n\tg, resp, err = client.GeoNodes.EditGeoNode(3, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, g)\n\n\tg, resp, err = client.GeoNodes.EditGeoNode(5, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, g)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_DeleteGeoNode(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.GeoNodes.DeleteGeoNode(3, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.GeoNodes.DeleteGeoNode(3, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GeoNodes.DeleteGeoNode(5, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_RepairGeoNode(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/3/repair\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 3,\n\t\t\t  \"name\": \"in-node\",\n\t\t\t  \"url\": \"https://secondary.example.com/\",\n\t\t\t  \"internal_url\": \"https://secondary.example.com/\",\n\t\t\t  \"primary\": false,\n\t\t\t  \"enabled\": true,\n\t\t\t  \"current\": false,\n\t\t\t  \"files_max_capacity\": 10,\n\t\t\t  \"repos_max_capacity\": 25,\n\t\t\t  \"verification_max_capacity\": 100,\n\t\t\t  \"selective_sync_type\": \"namespaces\",\n\t\t\t  \"selective_sync_shards\": null,\n\t\t\t  \"selective_sync_namespace_ids\": [1, 25],\n\t\t\t  \"minimum_reverification_interval\": 7,\n\t\t\t  \"container_repositories_max_capacity\": 10,\n\t\t\t  \"sync_object_storage\": false,\n\t\t\t  \"clone_protocol\": \"http\",\n\t\t\t  \"web_edit_url\": \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\t\t  \"web_geo_projects_url\": \"http://secondary.example.com/admin/geo/projects\",\n\t\t\t  \"_links\": {\n\t\t\t\t \"self\": \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\t\t \"status\": \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\t\t \"repair\": \"https://primary.example.com/api/v4/geo_nodes/3/repair\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &GeoNode{\n\t\tID:                               3,\n\t\tName:                             \"in-node\",\n\t\tURL:                              \"https://secondary.example.com/\",\n\t\tInternalURL:                      \"https://secondary.example.com/\",\n\t\tPrimary:                          false,\n\t\tEnabled:                          true,\n\t\tCurrent:                          false,\n\t\tFilesMaxCapacity:                 10,\n\t\tReposMaxCapacity:                 25,\n\t\tVerificationMaxCapacity:          100,\n\t\tSelectiveSyncType:                \"namespaces\",\n\t\tSelectiveSyncShards:              nil,\n\t\tSelectiveSyncNamespaceIds:        []int{1, 25},\n\t\tMinimumReverificationInterval:    7,\n\t\tContainerRepositoriesMaxCapacity: 10,\n\t\tSyncObjectStorage:                false,\n\t\tCloneProtocol:                    \"http\",\n\t\tWebEditURL:                       \"https://primary.example.com/admin/geo/nodes/3/edit\",\n\t\tWebGeoProjectsURL:                \"http://secondary.example.com/admin/geo/projects\",\n\t\tLinks: GeoNodeLinks{\n\t\t\tSelf:   \"https://primary.example.com/api/v4/geo_nodes/3\",\n\t\t\tStatus: \"https://primary.example.com/api/v4/geo_nodes/3/status\",\n\t\t\tRepair: \"https://primary.example.com/api/v4/geo_nodes/3/repair\",\n\t\t},\n\t}\n\n\tg, resp, err := client.GeoNodes.RepairGeoNode(3, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, g)\n\n\tg, resp, err = client.GeoNodes.RepairGeoNode(3, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, g)\n\n\tg, resp, err = client.GeoNodes.RepairGeoNode(5, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, g)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_RetrieveStatusOfAllGeoNodes(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/status\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_geo_nodes_status.json\")\n\t})\n\n\twant := []*GeoNodeStatus{\n\t\t{\n\t\t\tGeoNodeID:                                  1,\n\t\t\tHealthy:                                    true,\n\t\t\tHealth:                                     \"Healthy\",\n\t\t\tHealthStatus:                               \"Healthy\",\n\t\t\tMissingOauthApplication:                    false,\n\t\t\tAttachmentsCount:                           1,\n\t\t\tAttachmentsSyncedInPercentage:              \"0.00%\",\n\t\t\tLfsObjectsSyncedInPercentage:               \"0.00%\",\n\t\t\tJobArtifactsCount:                          2,\n\t\t\tJobArtifactsSyncedInPercentage:             \"0.00%\",\n\t\t\tContainerRepositoriesCount:                 3,\n\t\t\tContainerRepositoriesSyncedInPercentage:    \"0.00%\",\n\t\t\tDesignRepositoriesCount:                    3,\n\t\t\tDesignRepositoriesSyncedInPercentage:       \"0.00%\",\n\t\t\tProjectsCount:                              41,\n\t\t\tRepositoriesCount:                          41,\n\t\t\tRepositoriesSyncedInPercentage:             \"0.00%\",\n\t\t\tWikisCount:                                 41,\n\t\t\tWikisSyncedInPercentage:                    \"0.00%\",\n\t\t\tReplicationSlotsCount:                      1,\n\t\t\tReplicationSlotsUsedCount:                  1,\n\t\t\tReplicationSlotsUsedInPercentage:           \"100.00%\",\n\t\t\tRepositoriesCheckedCount:                   20,\n\t\t\tRepositoriesCheckedFailedCount:             20,\n\t\t\tRepositoriesCheckedInPercentage:            \"100.00%\",\n\t\t\tRepositoriesChecksummedCount:               20,\n\t\t\tRepositoriesChecksumFailedCount:            5,\n\t\t\tRepositoriesChecksummedInPercentage:        \"48.78%\",\n\t\t\tWikisChecksummedCount:                      10,\n\t\t\tWikisChecksumFailedCount:                   3,\n\t\t\tWikisChecksummedInPercentage:               \"24.39%\",\n\t\t\tRepositoriesVerifiedCount:                  20,\n\t\t\tRepositoriesVerificationFailedCount:        5,\n\t\t\tRepositoriesVerifiedInPercentage:           \"48.78%\",\n\t\t\tRepositoriesChecksumMismatchCount:          3,\n\t\t\tWikisVerifiedCount:                         10,\n\t\t\tWikisVerificationFailedCount:               3,\n\t\t\tWikisVerifiedInPercentage:                  \"24.39%\",\n\t\t\tWikisChecksumMismatchCount:                 1,\n\t\t\tRepositoriesRetryingVerificationCount:      1,\n\t\t\tWikisRetryingVerificationCount:             3,\n\t\t\tLastEventID:                                23,\n\t\t\tLastEventTimestamp:                         1509681166,\n\t\t\tLastSuccessfulStatusCheckTimestamp:         1510125024,\n\t\t\tVersion:                                    \"10.3.0\",\n\t\t\tRevision:                                   \"33d33a096a\",\n\t\t\tMergeRequestDiffsCount:                     5,\n\t\t\tMergeRequestDiffsChecksumTotalCount:        5,\n\t\t\tMergeRequestDiffsChecksummedCount:          5,\n\t\t\tMergeRequestDiffsSyncedInPercentage:        \"0.00%\",\n\t\t\tMergeRequestDiffsVerifiedInPercentage:      \"0.00%\",\n\t\t\tPackageFilesCount:                          5,\n\t\t\tPackageFilesChecksumTotalCount:             5,\n\t\t\tPackageFilesChecksummedCount:               5,\n\t\t\tPackageFilesSyncedInPercentage:             \"0.00%\",\n\t\t\tPackageFilesVerifiedInPercentage:           \"0.00%\",\n\t\t\tPagesDeploymentsCount:                      5,\n\t\t\tPagesDeploymentsChecksumTotalCount:         5,\n\t\t\tPagesDeploymentsChecksummedCount:           5,\n\t\t\tPagesDeploymentsSyncedInPercentage:         \"0.00%\",\n\t\t\tPagesDeploymentsVerifiedInPercentage:       \"0.00%\",\n\t\t\tTerraformStateVersionsCount:                5,\n\t\t\tTerraformStateVersionsChecksumTotalCount:   5,\n\t\t\tTerraformStateVersionsChecksummedCount:     5,\n\t\t\tTerraformStateVersionsSyncedInPercentage:   \"0.00%\",\n\t\t\tTerraformStateVersionsVerifiedInPercentage: \"0.00%\",\n\t\t\tSnippetRepositoriesCount:                   5,\n\t\t\tSnippetRepositoriesChecksumTotalCount:      5,\n\t\t\tSnippetRepositoriesChecksummedCount:        5,\n\t\t\tSnippetRepositoriesSyncedInPercentage:      \"0.00%\",\n\t\t\tSnippetRepositoriesVerifiedInPercentage:    \"0.00%\",\n\t\t\tGroupWikiRepositoriesCount:                 5,\n\t\t\tGroupWikiRepositoriesChecksumTotalCount:    5,\n\t\t\tGroupWikiRepositoriesChecksummedCount:      5,\n\t\t\tGroupWikiRepositoriesSyncedInPercentage:    \"0.00%\",\n\t\t\tGroupWikiRepositoriesVerifiedInPercentage:  \"0.00%\",\n\t\t\tPipelineArtifactsCount:                     5,\n\t\t\tPipelineArtifactsChecksumTotalCount:        5,\n\t\t\tPipelineArtifactsChecksummedCount:          5,\n\t\t\tPipelineArtifactsSyncedInPercentage:        \"0.00%\",\n\t\t\tPipelineArtifactsVerifiedInPercentage:      \"0.00%\",\n\t\t\tUploadsCount:                               5,\n\t\t\tUploadsSyncedInPercentage:                  \"0.00%\",\n\t\t},\n\t}\n\n\tgnss, resp, err := client.GeoNodes.RetrieveStatusOfAllGeoNodes(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gnss)\n\n\tgnss, resp, err = client.GeoNodes.RetrieveStatusOfAllGeoNodes(errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gnss)\n}\n\nfunc TestGeoNodesService_RetrieveStatusOfAllGeoNodes_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/status\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tgnss, resp, err := client.GeoNodes.RetrieveStatusOfAllGeoNodes(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gnss)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGeoNodesService_RetrieveStatusOfGeoNode(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/geo_nodes/1/status\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_geo_node_status.json\")\n\t})\n\n\twant := &GeoNodeStatus{\n\t\tGeoNodeID:                                  1,\n\t\tHealthy:                                    true,\n\t\tHealth:                                     \"Healthy\",\n\t\tHealthStatus:                               \"Healthy\",\n\t\tMissingOauthApplication:                    false,\n\t\tAttachmentsCount:                           1,\n\t\tAttachmentsSyncedInPercentage:              \"0.00%\",\n\t\tLfsObjectsSyncedInPercentage:               \"0.00%\",\n\t\tJobArtifactsCount:                          2,\n\t\tJobArtifactsSyncedInPercentage:             \"0.00%\",\n\t\tContainerRepositoriesCount:                 3,\n\t\tContainerRepositoriesSyncedInPercentage:    \"0.00%\",\n\t\tDesignRepositoriesCount:                    3,\n\t\tDesignRepositoriesSyncedInPercentage:       \"0.00%\",\n\t\tProjectsCount:                              41,\n\t\tRepositoriesCount:                          41,\n\t\tRepositoriesSyncedInPercentage:             \"0.00%\",\n\t\tWikisCount:                                 41,\n\t\tWikisSyncedInPercentage:                    \"0.00%\",\n\t\tReplicationSlotsCount:                      1,\n\t\tReplicationSlotsUsedCount:                  1,\n\t\tReplicationSlotsUsedInPercentage:           \"100.00%\",\n\t\tRepositoriesCheckedCount:                   20,\n\t\tRepositoriesCheckedFailedCount:             20,\n\t\tRepositoriesCheckedInPercentage:            \"100.00%\",\n\t\tRepositoriesChecksummedCount:               20,\n\t\tRepositoriesChecksumFailedCount:            5,\n\t\tRepositoriesChecksummedInPercentage:        \"48.78%\",\n\t\tWikisChecksummedCount:                      10,\n\t\tWikisChecksumFailedCount:                   3,\n\t\tWikisChecksummedInPercentage:               \"24.39%\",\n\t\tRepositoriesVerifiedCount:                  20,\n\t\tRepositoriesVerificationFailedCount:        5,\n\t\tRepositoriesVerifiedInPercentage:           \"48.78%\",\n\t\tRepositoriesChecksumMismatchCount:          3,\n\t\tWikisVerifiedCount:                         10,\n\t\tWikisVerificationFailedCount:               3,\n\t\tWikisVerifiedInPercentage:                  \"24.39%\",\n\t\tWikisChecksumMismatchCount:                 1,\n\t\tRepositoriesRetryingVerificationCount:      1,\n\t\tWikisRetryingVerificationCount:             3,\n\t\tLastEventID:                                23,\n\t\tLastEventTimestamp:                         1509681166,\n\t\tLastSuccessfulStatusCheckTimestamp:         1510125024,\n\t\tVersion:                                    \"10.3.0\",\n\t\tRevision:                                   \"33d33a096a\",\n\t\tMergeRequestDiffsCount:                     5,\n\t\tMergeRequestDiffsChecksumTotalCount:        5,\n\t\tMergeRequestDiffsChecksummedCount:          5,\n\t\tMergeRequestDiffsSyncedInPercentage:        \"0.00%\",\n\t\tMergeRequestDiffsVerifiedInPercentage:      \"0.00%\",\n\t\tPackageFilesCount:                          5,\n\t\tPackageFilesChecksumTotalCount:             5,\n\t\tPackageFilesChecksummedCount:               5,\n\t\tPackageFilesSyncedInPercentage:             \"0.00%\",\n\t\tPackageFilesVerifiedInPercentage:           \"0.00%\",\n\t\tPagesDeploymentsCount:                      5,\n\t\tPagesDeploymentsChecksumTotalCount:         5,\n\t\tPagesDeploymentsChecksummedCount:           5,\n\t\tPagesDeploymentsSyncedInPercentage:         \"0.00%\",\n\t\tPagesDeploymentsVerifiedInPercentage:       \"0.00%\",\n\t\tTerraformStateVersionsCount:                5,\n\t\tTerraformStateVersionsChecksumTotalCount:   5,\n\t\tTerraformStateVersionsChecksummedCount:     5,\n\t\tTerraformStateVersionsSyncedInPercentage:   \"0.00%\",\n\t\tTerraformStateVersionsVerifiedInPercentage: \"0.00%\",\n\t\tSnippetRepositoriesCount:                   5,\n\t\tSnippetRepositoriesChecksumTotalCount:      5,\n\t\tSnippetRepositoriesChecksummedCount:        5,\n\t\tSnippetRepositoriesSyncedInPercentage:      \"0.00%\",\n\t\tSnippetRepositoriesVerifiedInPercentage:    \"0.00%\",\n\t\tGroupWikiRepositoriesCount:                 5,\n\t\tGroupWikiRepositoriesChecksumTotalCount:    5,\n\t\tGroupWikiRepositoriesChecksummedCount:      5,\n\t\tGroupWikiRepositoriesSyncedInPercentage:    \"0.00%\",\n\t\tGroupWikiRepositoriesVerifiedInPercentage:  \"0.00%\",\n\t\tPipelineArtifactsCount:                     5,\n\t\tPipelineArtifactsChecksumTotalCount:        5,\n\t\tPipelineArtifactsChecksummedCount:          5,\n\t\tPipelineArtifactsSyncedInPercentage:        \"0.00%\",\n\t\tPipelineArtifactsVerifiedInPercentage:      \"0.00%\",\n\t\tUploadsCount:                               5,\n\t\tUploadsSyncedInPercentage:                  \"0.00%\",\n\t}\n\n\tgns, resp, err := client.GeoNodes.RetrieveStatusOfGeoNode(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gns)\n\n\tgns, resp, err = client.GeoNodes.RetrieveStatusOfGeoNode(1, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gns)\n\n\tgns, resp, err = client.GeoNodes.RetrieveStatusOfGeoNode(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gns)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "gitignore_templates.go",
          "type": "blob",
          "size": 2.77734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// GitIgnoreTemplatesService handles communication with the gitignore\n// templates related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/gitignores.html\ntype GitIgnoreTemplatesService struct {\n\tclient *Client\n}\n\n// GitIgnoreTemplate represents a GitLab gitignore template.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/gitignores.html\ntype GitIgnoreTemplate struct {\n\tName    string `json:\"name\"`\n\tContent string `json:\"content\"`\n}\n\n// GitIgnoreTemplateListItem represents a GitLab gitignore template from the list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/gitignores.html\ntype GitIgnoreTemplateListItem struct {\n\tKey  string `json:\"key\"`\n\tName string `json:\"name\"`\n}\n\n// ListTemplatesOptions represents the available ListAllTemplates() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitignores.html#get-all-gitignore-templates\ntype ListTemplatesOptions ListOptions\n\n// ListTemplates get a list of available git ignore templates\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitignores.html#get-all-gitignore-templates\nfunc (s *GitIgnoreTemplatesService) ListTemplates(opt *ListTemplatesOptions, options ...RequestOptionFunc) ([]*GitIgnoreTemplateListItem, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"templates/gitignores\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*GitIgnoreTemplateListItem\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// GetTemplate get a git ignore template\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/gitignores.html#get-a-single-gitignore-template\nfunc (s *GitIgnoreTemplatesService) GetTemplate(key string, options ...RequestOptionFunc) (*GitIgnoreTemplate, *Response, error) {\n\tu := fmt.Sprintf(\"templates/gitignores/%s\", url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(GitIgnoreTemplate)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n"
        },
        {
          "name": "gitignore_templates_test.go",
          "type": "blob",
          "size": 4.15234375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListTemplates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/gitignores\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"key\": \"Actionscript\",\n\t\t\t  \"name\": \"Actionscript\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Ada\",\n\t\t\t  \"name\": \"Ada\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Agda\",\n\t\t\t  \"name\": \"Agda\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Android\",\n\t\t\t  \"name\": \"Android\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"AppEngine\",\n\t\t\t  \"name\": \"AppEngine\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"AppceleratorTitanium\",\n\t\t\t  \"name\": \"AppceleratorTitanium\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"ArchLinuxPackages\",\n\t\t\t  \"name\": \"ArchLinuxPackages\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Autotools\",\n\t\t\t  \"name\": \"Autotools\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"C\",\n\t\t\t  \"name\": \"C\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"C++\",\n\t\t\t  \"name\": \"C++\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"CFWheels\",\n\t\t\t  \"name\": \"CFWheels\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"CMake\",\n\t\t\t  \"name\": \"CMake\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"CUDA\",\n\t\t\t  \"name\": \"CUDA\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"CakePHP\",\n\t\t\t  \"name\": \"CakePHP\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"ChefCookbook\",\n\t\t\t  \"name\": \"ChefCookbook\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Clojure\",\n\t\t\t  \"name\": \"Clojure\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"CodeIgniter\",\n\t\t\t  \"name\": \"CodeIgniter\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"CommonLisp\",\n\t\t\t  \"name\": \"CommonLisp\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Composer\",\n\t\t\t  \"name\": \"Composer\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"key\": \"Concrete5\",\n\t\t\t  \"name\": \"Concrete5\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\ttemplates, _, err := client.GitIgnoreTemplates.ListTemplates(&ListTemplatesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GitIgnoreTemplates.ListTemplates returned error: %v\", err)\n\t}\n\n\twant := []*GitIgnoreTemplateListItem{\n\t\t{\n\t\t\tKey:  \"Actionscript\",\n\t\t\tName: \"Actionscript\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Ada\",\n\t\t\tName: \"Ada\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Agda\",\n\t\t\tName: \"Agda\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Android\",\n\t\t\tName: \"Android\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"AppEngine\",\n\t\t\tName: \"AppEngine\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"AppceleratorTitanium\",\n\t\t\tName: \"AppceleratorTitanium\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"ArchLinuxPackages\",\n\t\t\tName: \"ArchLinuxPackages\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Autotools\",\n\t\t\tName: \"Autotools\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"C\",\n\t\t\tName: \"C\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"C++\",\n\t\t\tName: \"C++\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"CFWheels\",\n\t\t\tName: \"CFWheels\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"CMake\",\n\t\t\tName: \"CMake\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"CUDA\",\n\t\t\tName: \"CUDA\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"CakePHP\",\n\t\t\tName: \"CakePHP\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"ChefCookbook\",\n\t\t\tName: \"ChefCookbook\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Clojure\",\n\t\t\tName: \"Clojure\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"CodeIgniter\",\n\t\t\tName: \"CodeIgniter\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"CommonLisp\",\n\t\t\tName: \"CommonLisp\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Composer\",\n\t\t\tName: \"Composer\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"Concrete5\",\n\t\t\tName: \"Concrete5\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, templates) {\n\t\tt.Errorf(\"GitIgnoreTemplates.ListTemplates returned %+v, want %+v\", templates, want)\n\t}\n}\n\nfunc TestGetTemplates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/gitignores/Ruby\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"name\": \"Ruby\",\n\t\t\t\"content\": \"*.gem\\n*.rbc\\n/.config\\n/coverage/\\n/InstalledFiles\\n/pkg/\\n/spec/reports/\"\n\t\t  }`)\n\t})\n\n\ttemplate, _, err := client.GitIgnoreTemplates.GetTemplate(\"Ruby\")\n\tif err != nil {\n\t\tt.Errorf(\"GitIgnoreTempaltes.GetTemplate returned an error: %v\", err)\n\t}\n\n\twant := &GitIgnoreTemplate{\n\t\tName:    \"Ruby\",\n\t\tContent: \"*.gem\\n*.rbc\\n/.config\\n/coverage/\\n/InstalledFiles\\n/pkg/\\n/spec/reports/\",\n\t}\n\tif !reflect.DeepEqual(want, template) {\n\t\tt.Errorf(\"GitIgnoreTemplates.GetTemplate returned %+v, want %+v\", template, want)\n\t}\n}\n"
        },
        {
          "name": "gitlab.go",
          "type": "blob",
          "size": 36.408203125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\n// Package gitlab implements a GitLab API client.\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-cleanhttp\"\n\n\t\"github.com/google/go-querystring/query\"\n\tretryablehttp \"github.com/hashicorp/go-retryablehttp\"\n\t\"golang.org/x/oauth2\"\n\t\"golang.org/x/time/rate\"\n)\n\nconst (\n\tdefaultBaseURL = \"https://gitlab.com/\"\n\tapiVersionPath = \"api/v4/\"\n\tuserAgent      = \"go-gitlab\"\n\n\theaderRateLimit = \"RateLimit-Limit\"\n\theaderRateReset = \"RateLimit-Reset\"\n)\n\n// AuthType represents an authentication type within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\ntype AuthType int\n\n// List of available authentication types.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\nconst (\n\tBasicAuth AuthType = iota\n\tJobToken\n\tOAuthToken\n\tPrivateToken\n)\n\nvar ErrNotFound = errors.New(\"404 Not Found\")\n\n// A Client manages communication with the GitLab API.\n//\n// Deprecated: use gitlab.com/gitlab-org/api/client-go instead.\n// See https://gitlab.com/gitlab-org/api/client-go\n//\n// This package is completely frozen, nothing will be added, removed or changed.\ntype Client struct {\n\t// HTTP client used to communicate with the API.\n\tclient *retryablehttp.Client\n\n\t// Base URL for API requests. Defaults to the public GitLab API, but can be\n\t// set to a domain endpoint to use with a self hosted GitLab server. baseURL\n\t// should always be specified with a trailing slash.\n\tbaseURL *url.URL\n\n\t// disableRetries is used to disable the default retry logic.\n\tdisableRetries bool\n\n\t// configureLimiterOnce is used to make sure the limiter is configured exactly\n\t// once and block all other calls until the initial (one) call is done.\n\tconfigureLimiterOnce sync.Once\n\n\t// Limiter is used to limit API calls and prevent 429 responses.\n\tlimiter RateLimiter\n\n\t// Token type used to make authenticated API calls.\n\tauthType AuthType\n\n\t// Username and password used for basic authentication.\n\tusername, password string\n\n\t// Token used to make authenticated API calls.\n\ttoken string\n\n\t// Protects the token field from concurrent read/write accesses.\n\ttokenLock sync.RWMutex\n\n\t// Default request options applied to every request.\n\tdefaultRequestOptions []RequestOptionFunc\n\n\t// User agent used when communicating with the GitLab API.\n\tUserAgent string\n\n\t// Services used for talking to different parts of the GitLab API.\n\tAccessRequests               *AccessRequestsService\n\tAppearance                   *AppearanceService\n\tApplications                 *ApplicationsService\n\tAuditEvents                  *AuditEventsService\n\tAvatar                       *AvatarRequestsService\n\tAwardEmoji                   *AwardEmojiService\n\tBoards                       *IssueBoardsService\n\tBranches                     *BranchesService\n\tBroadcastMessage             *BroadcastMessagesService\n\tCIYMLTemplate                *CIYMLTemplatesService\n\tClusterAgents                *ClusterAgentsService\n\tCommits                      *CommitsService\n\tContainerRegistry            *ContainerRegistryService\n\tCustomAttribute              *CustomAttributesService\n\tDependencyListExport         *DependencyListExportService\n\tDeployKeys                   *DeployKeysService\n\tDeployTokens                 *DeployTokensService\n\tDeploymentMergeRequests      *DeploymentMergeRequestsService\n\tDeployments                  *DeploymentsService\n\tDiscussions                  *DiscussionsService\n\tDockerfileTemplate           *DockerfileTemplatesService\n\tDORAMetrics                  *DORAMetricsService\n\tDraftNotes                   *DraftNotesService\n\tEnvironments                 *EnvironmentsService\n\tEpicIssues                   *EpicIssuesService\n\tEpics                        *EpicsService\n\tErrorTracking                *ErrorTrackingService\n\tEvents                       *EventsService\n\tExternalStatusChecks         *ExternalStatusChecksService\n\tFeatures                     *FeaturesService\n\tFreezePeriods                *FreezePeriodsService\n\tGenericPackages              *GenericPackagesService\n\tGeoNodes                     *GeoNodesService\n\tGitIgnoreTemplates           *GitIgnoreTemplatesService\n\tGroupAccessTokens            *GroupAccessTokensService\n\tGroupBadges                  *GroupBadgesService\n\tGroupCluster                 *GroupClustersService\n\tGroupEpicBoards              *GroupEpicBoardsService\n\tGroupImportExport            *GroupImportExportService\n\tGroupIssueBoards             *GroupIssueBoardsService\n\tGroupIterations              *GroupIterationsService\n\tGroupLabels                  *GroupLabelsService\n\tGroupMembers                 *GroupMembersService\n\tGroupMilestones              *GroupMilestonesService\n\tGroupProtectedEnvironments   *GroupProtectedEnvironmentsService\n\tGroupRepositoryStorageMove   *GroupRepositoryStorageMoveService\n\tGroupSSHCertificates         *GroupSSHCertificatesService\n\tGroupVariables               *GroupVariablesService\n\tGroupWikis                   *GroupWikisService\n\tGroups                       *GroupsService\n\tImport                       *ImportService\n\tInstanceCluster              *InstanceClustersService\n\tInstanceVariables            *InstanceVariablesService\n\tInvites                      *InvitesService\n\tIssueLinks                   *IssueLinksService\n\tIssues                       *IssuesService\n\tIssuesStatistics             *IssuesStatisticsService\n\tJobs                         *JobsService\n\tJobTokenScope                *JobTokenScopeService\n\tKeys                         *KeysService\n\tLabels                       *LabelsService\n\tLicense                      *LicenseService\n\tLicenseTemplates             *LicenseTemplatesService\n\tManagedLicenses              *ManagedLicensesService\n\tMarkdown                     *MarkdownService\n\tMemberRolesService           *MemberRolesService\n\tMergeRequestApprovals        *MergeRequestApprovalsService\n\tMergeRequests                *MergeRequestsService\n\tMergeTrains                  *MergeTrainsService\n\tMetadata                     *MetadataService\n\tMilestones                   *MilestonesService\n\tNamespaces                   *NamespacesService\n\tNotes                        *NotesService\n\tNotificationSettings         *NotificationSettingsService\n\tPackages                     *PackagesService\n\tPages                        *PagesService\n\tPagesDomains                 *PagesDomainsService\n\tPersonalAccessTokens         *PersonalAccessTokensService\n\tPipelineSchedules            *PipelineSchedulesService\n\tPipelineTriggers             *PipelineTriggersService\n\tPipelines                    *PipelinesService\n\tPlanLimits                   *PlanLimitsService\n\tProjectAccessTokens          *ProjectAccessTokensService\n\tProjectBadges                *ProjectBadgesService\n\tProjectCluster               *ProjectClustersService\n\tProjectFeatureFlags          *ProjectFeatureFlagService\n\tProjectImportExport          *ProjectImportExportService\n\tProjectIterations            *ProjectIterationsService\n\tProjectMarkdownUploads       *ProjectMarkdownUploadsService\n\tProjectMembers               *ProjectMembersService\n\tProjectMirrors               *ProjectMirrorService\n\tProjectRepositoryStorageMove *ProjectRepositoryStorageMoveService\n\tProjectSnippets              *ProjectSnippetsService\n\tProjectTemplates             *ProjectTemplatesService\n\tProjectVariables             *ProjectVariablesService\n\tProjectVulnerabilities       *ProjectVulnerabilitiesService\n\tProjects                     *ProjectsService\n\tProtectedBranches            *ProtectedBranchesService\n\tProtectedEnvironments        *ProtectedEnvironmentsService\n\tProtectedTags                *ProtectedTagsService\n\tReleaseLinks                 *ReleaseLinksService\n\tReleases                     *ReleasesService\n\tRepositories                 *RepositoriesService\n\tRepositoryFiles              *RepositoryFilesService\n\tRepositorySubmodules         *RepositorySubmodulesService\n\tResourceGroup                *ResourceGroupService\n\tResourceIterationEvents      *ResourceIterationEventsService\n\tResourceLabelEvents          *ResourceLabelEventsService\n\tResourceMilestoneEvents      *ResourceMilestoneEventsService\n\tResourceStateEvents          *ResourceStateEventsService\n\tResourceWeightEvents         *ResourceWeightEventsService\n\tRunners                      *RunnersService\n\tSearch                       *SearchService\n\tServices                     *ServicesService\n\tSettings                     *SettingsService\n\tSidekiq                      *SidekiqService\n\tSnippetRepositoryStorageMove *SnippetRepositoryStorageMoveService\n\tSnippets                     *SnippetsService\n\tSystemHooks                  *SystemHooksService\n\tTags                         *TagsService\n\tTodos                        *TodosService\n\tTopics                       *TopicsService\n\tUsers                        *UsersService\n\tValidate                     *ValidateService\n\tVersion                      *VersionService\n\tWikis                        *WikisService\n}\n\n// ListOptions specifies the optional parameters to various List methods that\n// support pagination.\ntype ListOptions struct {\n\t// For keyset-based paginated result sets, the value must be `\"keyset\"`\n\tPagination string `url:\"pagination,omitempty\" json:\"pagination,omitempty\"`\n\t// For offset-based and keyset-based paginated result sets, the number of results to include per page.\n\tPerPage int `url:\"per_page,omitempty\" json:\"per_page,omitempty\"`\n\t// For offset-based paginated result sets, page of results to retrieve.\n\tPage int `url:\"page,omitempty\" json:\"page,omitempty\"`\n\t// For keyset-based paginated result sets, tree record ID at which to fetch the next page.\n\tPageToken string `url:\"page_token,omitempty\" json:\"page_token,omitempty\"`\n\t// For keyset-based paginated result sets, name of the column by which to order\n\tOrderBy string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\t// For keyset-based paginated result sets, sort order (`\"asc\"`` or `\"desc\"`)\n\tSort string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// RateLimiter describes the interface that all (custom) rate limiters must implement.\ntype RateLimiter interface {\n\tWait(context.Context) error\n}\n\n// NewClient returns a new GitLab API client. To use API methods which require\n// authentication, provide a valid private or personal token.\n//\n// Deprecated: This module has been migrated to gitlab.com/gitlab-org/api/client-go.\n// See https://gitlab.com/gitlab-org/api/client-go\n//\n// This package is completely frozen, nothing will be added, removed or changed.\nfunc NewClient(token string, options ...ClientOptionFunc) (*Client, error) {\n\tclient, err := newClient(options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.authType = PrivateToken\n\tclient.token = token\n\treturn client, nil\n}\n\n// NewBasicAuthClient returns a new GitLab API client. To use API methods which\n// require authentication, provide a valid username and password.\n//\n// Deprecated: This module has been migrated to gitlab.com/gitlab-org/api/client-go.\n// See https://gitlab.com/gitlab-org/api/client-go\n//\n// This package is completely frozen, nothing will be added, removed or changed.\nfunc NewBasicAuthClient(username, password string, options ...ClientOptionFunc) (*Client, error) {\n\tclient, err := newClient(options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tclient.authType = BasicAuth\n\tclient.username = username\n\tclient.password = password\n\n\treturn client, nil\n}\n\n// NewJobClient returns a new GitLab API client. To use API methods which require\n// authentication, provide a valid job token.\n//\n// Deprecated: This module has been migrated to gitlab.com/gitlab-org/api/client-go.\n// See https://gitlab.com/gitlab-org/api/client-go\n//\n// This package is completely frozen, nothing will be added, removed or changed.\nfunc NewJobClient(token string, options ...ClientOptionFunc) (*Client, error) {\n\tclient, err := newClient(options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.authType = JobToken\n\tclient.token = token\n\treturn client, nil\n}\n\n// NewOAuthClient returns a new GitLab API client. To use API methods which\n// require authentication, provide a valid oauth token.\n//\n// Deprecated: This module has been migrated to gitlab.com/gitlab-org/api/client-go.\n// See https://gitlab.com/gitlab-org/api/client-go\n//\n// This package is completely frozen, nothing will be added, removed or changed.\nfunc NewOAuthClient(token string, options ...ClientOptionFunc) (*Client, error) {\n\tclient, err := newClient(options...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclient.authType = OAuthToken\n\tclient.token = token\n\treturn client, nil\n}\n\nfunc newClient(options ...ClientOptionFunc) (*Client, error) {\n\tc := &Client{UserAgent: userAgent}\n\n\t// Configure the HTTP client.\n\tc.client = &retryablehttp.Client{\n\t\tBackoff:      c.retryHTTPBackoff,\n\t\tCheckRetry:   c.retryHTTPCheck,\n\t\tErrorHandler: retryablehttp.PassthroughErrorHandler,\n\t\tHTTPClient:   cleanhttp.DefaultPooledClient(),\n\t\tRetryWaitMin: 100 * time.Millisecond,\n\t\tRetryWaitMax: 400 * time.Millisecond,\n\t\tRetryMax:     5,\n\t}\n\n\t// Set the default base URL.\n\tc.setBaseURL(defaultBaseURL)\n\n\t// Apply any given client options.\n\tfor _, fn := range options {\n\t\tif fn == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := fn(c); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// If no custom limiter was set using a client option, configure\n\t// the default rate limiter with values that implicitly disable\n\t// rate limiting until an initial HTTP call is done and we can\n\t// use the headers to try and properly configure the limiter.\n\tif c.limiter == nil {\n\t\tc.limiter = rate.NewLimiter(rate.Inf, 0)\n\t}\n\n\t// Create the internal timeStats service.\n\ttimeStats := &timeStatsService{client: c}\n\n\t// Create all the public services.\n\tc.AccessRequests = &AccessRequestsService{client: c}\n\tc.Appearance = &AppearanceService{client: c}\n\tc.Applications = &ApplicationsService{client: c}\n\tc.AuditEvents = &AuditEventsService{client: c}\n\tc.Avatar = &AvatarRequestsService{client: c}\n\tc.AwardEmoji = &AwardEmojiService{client: c}\n\tc.Boards = &IssueBoardsService{client: c}\n\tc.Branches = &BranchesService{client: c}\n\tc.BroadcastMessage = &BroadcastMessagesService{client: c}\n\tc.CIYMLTemplate = &CIYMLTemplatesService{client: c}\n\tc.ClusterAgents = &ClusterAgentsService{client: c}\n\tc.Commits = &CommitsService{client: c}\n\tc.ContainerRegistry = &ContainerRegistryService{client: c}\n\tc.CustomAttribute = &CustomAttributesService{client: c}\n\tc.DependencyListExport = &DependencyListExportService{client: c}\n\tc.DeployKeys = &DeployKeysService{client: c}\n\tc.DeployTokens = &DeployTokensService{client: c}\n\tc.DeploymentMergeRequests = &DeploymentMergeRequestsService{client: c}\n\tc.Deployments = &DeploymentsService{client: c}\n\tc.Discussions = &DiscussionsService{client: c}\n\tc.DockerfileTemplate = &DockerfileTemplatesService{client: c}\n\tc.DORAMetrics = &DORAMetricsService{client: c}\n\tc.DraftNotes = &DraftNotesService{client: c}\n\tc.Environments = &EnvironmentsService{client: c}\n\tc.EpicIssues = &EpicIssuesService{client: c}\n\tc.Epics = &EpicsService{client: c}\n\tc.ErrorTracking = &ErrorTrackingService{client: c}\n\tc.Events = &EventsService{client: c}\n\tc.ExternalStatusChecks = &ExternalStatusChecksService{client: c}\n\tc.Features = &FeaturesService{client: c}\n\tc.FreezePeriods = &FreezePeriodsService{client: c}\n\tc.GenericPackages = &GenericPackagesService{client: c}\n\tc.GeoNodes = &GeoNodesService{client: c}\n\tc.GitIgnoreTemplates = &GitIgnoreTemplatesService{client: c}\n\tc.GroupAccessTokens = &GroupAccessTokensService{client: c}\n\tc.GroupBadges = &GroupBadgesService{client: c}\n\tc.GroupCluster = &GroupClustersService{client: c}\n\tc.GroupEpicBoards = &GroupEpicBoardsService{client: c}\n\tc.GroupImportExport = &GroupImportExportService{client: c}\n\tc.GroupIssueBoards = &GroupIssueBoardsService{client: c}\n\tc.GroupIterations = &GroupIterationsService{client: c}\n\tc.GroupLabels = &GroupLabelsService{client: c}\n\tc.GroupMembers = &GroupMembersService{client: c}\n\tc.GroupMilestones = &GroupMilestonesService{client: c}\n\tc.GroupProtectedEnvironments = &GroupProtectedEnvironmentsService{client: c}\n\tc.GroupRepositoryStorageMove = &GroupRepositoryStorageMoveService{client: c}\n\tc.GroupSSHCertificates = &GroupSSHCertificatesService{client: c}\n\tc.GroupVariables = &GroupVariablesService{client: c}\n\tc.GroupWikis = &GroupWikisService{client: c}\n\tc.Groups = &GroupsService{client: c}\n\tc.Import = &ImportService{client: c}\n\tc.InstanceCluster = &InstanceClustersService{client: c}\n\tc.InstanceVariables = &InstanceVariablesService{client: c}\n\tc.Invites = &InvitesService{client: c}\n\tc.IssueLinks = &IssueLinksService{client: c}\n\tc.Issues = &IssuesService{client: c, timeStats: timeStats}\n\tc.IssuesStatistics = &IssuesStatisticsService{client: c}\n\tc.Jobs = &JobsService{client: c}\n\tc.JobTokenScope = &JobTokenScopeService{client: c}\n\tc.Keys = &KeysService{client: c}\n\tc.Labels = &LabelsService{client: c}\n\tc.License = &LicenseService{client: c}\n\tc.LicenseTemplates = &LicenseTemplatesService{client: c}\n\tc.ManagedLicenses = &ManagedLicensesService{client: c}\n\tc.Markdown = &MarkdownService{client: c}\n\tc.MemberRolesService = &MemberRolesService{client: c}\n\tc.MergeRequestApprovals = &MergeRequestApprovalsService{client: c}\n\tc.MergeRequests = &MergeRequestsService{client: c, timeStats: timeStats}\n\tc.MergeTrains = &MergeTrainsService{client: c}\n\tc.Metadata = &MetadataService{client: c}\n\tc.Milestones = &MilestonesService{client: c}\n\tc.Namespaces = &NamespacesService{client: c}\n\tc.Notes = &NotesService{client: c}\n\tc.NotificationSettings = &NotificationSettingsService{client: c}\n\tc.Packages = &PackagesService{client: c}\n\tc.Pages = &PagesService{client: c}\n\tc.PagesDomains = &PagesDomainsService{client: c}\n\tc.PersonalAccessTokens = &PersonalAccessTokensService{client: c}\n\tc.PipelineSchedules = &PipelineSchedulesService{client: c}\n\tc.PipelineTriggers = &PipelineTriggersService{client: c}\n\tc.Pipelines = &PipelinesService{client: c}\n\tc.PlanLimits = &PlanLimitsService{client: c}\n\tc.ProjectAccessTokens = &ProjectAccessTokensService{client: c}\n\tc.ProjectBadges = &ProjectBadgesService{client: c}\n\tc.ProjectCluster = &ProjectClustersService{client: c}\n\tc.ProjectFeatureFlags = &ProjectFeatureFlagService{client: c}\n\tc.ProjectImportExport = &ProjectImportExportService{client: c}\n\tc.ProjectIterations = &ProjectIterationsService{client: c}\n\tc.ProjectMarkdownUploads = &ProjectMarkdownUploadsService{client: c}\n\tc.ProjectMembers = &ProjectMembersService{client: c}\n\tc.ProjectMirrors = &ProjectMirrorService{client: c}\n\tc.ProjectRepositoryStorageMove = &ProjectRepositoryStorageMoveService{client: c}\n\tc.ProjectSnippets = &ProjectSnippetsService{client: c}\n\tc.ProjectTemplates = &ProjectTemplatesService{client: c}\n\tc.ProjectVariables = &ProjectVariablesService{client: c}\n\tc.ProjectVulnerabilities = &ProjectVulnerabilitiesService{client: c}\n\tc.Projects = &ProjectsService{client: c}\n\tc.ProtectedBranches = &ProtectedBranchesService{client: c}\n\tc.ProtectedEnvironments = &ProtectedEnvironmentsService{client: c}\n\tc.ProtectedTags = &ProtectedTagsService{client: c}\n\tc.ReleaseLinks = &ReleaseLinksService{client: c}\n\tc.Releases = &ReleasesService{client: c}\n\tc.Repositories = &RepositoriesService{client: c}\n\tc.RepositoryFiles = &RepositoryFilesService{client: c}\n\tc.RepositorySubmodules = &RepositorySubmodulesService{client: c}\n\tc.ResourceGroup = &ResourceGroupService{client: c}\n\tc.ResourceIterationEvents = &ResourceIterationEventsService{client: c}\n\tc.ResourceLabelEvents = &ResourceLabelEventsService{client: c}\n\tc.ResourceMilestoneEvents = &ResourceMilestoneEventsService{client: c}\n\tc.ResourceStateEvents = &ResourceStateEventsService{client: c}\n\tc.ResourceWeightEvents = &ResourceWeightEventsService{client: c}\n\tc.Runners = &RunnersService{client: c}\n\tc.Search = &SearchService{client: c}\n\tc.Services = &ServicesService{client: c}\n\tc.Settings = &SettingsService{client: c}\n\tc.Sidekiq = &SidekiqService{client: c}\n\tc.Snippets = &SnippetsService{client: c}\n\tc.SnippetRepositoryStorageMove = &SnippetRepositoryStorageMoveService{client: c}\n\tc.SystemHooks = &SystemHooksService{client: c}\n\tc.Tags = &TagsService{client: c}\n\tc.Todos = &TodosService{client: c}\n\tc.Topics = &TopicsService{client: c}\n\tc.Users = &UsersService{client: c}\n\tc.Validate = &ValidateService{client: c}\n\tc.Version = &VersionService{client: c}\n\tc.Wikis = &WikisService{client: c}\n\n\treturn c, nil\n}\n\n// retryHTTPCheck provides a callback for Client.CheckRetry which\n// will retry both rate limit (429) and server (>= 500) errors.\nfunc (c *Client) retryHTTPCheck(ctx context.Context, resp *http.Response, err error) (bool, error) {\n\tif ctx.Err() != nil {\n\t\treturn false, ctx.Err()\n\t}\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tif !c.disableRetries && (resp.StatusCode == 429 || resp.StatusCode >= 500) {\n\t\treturn true, nil\n\t}\n\treturn false, nil\n}\n\n// retryHTTPBackoff provides a generic callback for Client.Backoff which\n// will pass through all calls based on the status code of the response.\nfunc (c *Client) retryHTTPBackoff(min, max time.Duration, attemptNum int, resp *http.Response) time.Duration {\n\t// Use the rate limit backoff function when we are rate limited.\n\tif resp != nil && resp.StatusCode == 429 {\n\t\treturn rateLimitBackoff(min, max, attemptNum, resp)\n\t}\n\n\t// Set custom duration's when we experience a service interruption.\n\tmin = 700 * time.Millisecond\n\tmax = 900 * time.Millisecond\n\n\treturn retryablehttp.LinearJitterBackoff(min, max, attemptNum, resp)\n}\n\n// rateLimitBackoff provides a callback for Client.Backoff which will use the\n// RateLimit-Reset header to determine the time to wait. We add some jitter\n// to prevent a thundering herd.\n//\n// min and max are mainly used for bounding the jitter that will be added to\n// the reset time retrieved from the headers. But if the final wait time is\n// less then min, min will be used instead.\nfunc rateLimitBackoff(min, max time.Duration, attemptNum int, resp *http.Response) time.Duration {\n\t// rnd is used to generate pseudo-random numbers.\n\trnd := rand.New(rand.NewSource(time.Now().UnixNano()))\n\n\t// First create some jitter bounded by the min and max durations.\n\tjitter := time.Duration(rnd.Float64() * float64(max-min))\n\n\tif resp != nil {\n\t\tif v := resp.Header.Get(headerRateReset); v != \"\" {\n\t\t\tif reset, _ := strconv.ParseInt(v, 10, 64); reset > 0 {\n\t\t\t\t// Only update min if the given time to wait is longer.\n\t\t\t\tif wait := time.Until(time.Unix(reset, 0)); wait > min {\n\t\t\t\t\tmin = wait\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// In case the RateLimit-Reset header is not set, back off an additional\n\t\t\t// 100% exponentially. With the default milliseconds being set to 100 for\n\t\t\t// `min`, this makes the 5th retry wait 3.2 seconds (3,200 ms) by default.\n\t\t\tmin = time.Duration(float64(min) * math.Pow(2, float64(attemptNum)))\n\t\t}\n\t}\n\n\treturn min + jitter\n}\n\n// configureLimiter configures the rate limiter.\nfunc (c *Client) configureLimiter(ctx context.Context, headers http.Header) {\n\tif v := headers.Get(headerRateLimit); v != \"\" {\n\t\tif rateLimit, _ := strconv.ParseFloat(v, 64); rateLimit > 0 {\n\t\t\t// The rate limit is based on requests per minute, so for our limiter to\n\t\t\t// work correctly we divide the limit by 60 to get the limit per second.\n\t\t\trateLimit /= 60\n\n\t\t\t// Configure the limit and burst using a split of 2/3 for the limit and\n\t\t\t// 1/3 for the burst. This enables clients to burst 1/3 of the allowed\n\t\t\t// calls before the limiter kicks in. The remaining calls will then be\n\t\t\t// spread out evenly using intervals of time.Second / limit which should\n\t\t\t// prevent hitting the rate limit.\n\t\t\tlimit := rate.Limit(rateLimit * 0.66)\n\t\t\tburst := int(rateLimit * 0.33)\n\n\t\t\t// Need at least one allowed to burst or x/time will throw an error\n\t\t\tif burst == 0 {\n\t\t\t\tburst = 1\n\t\t\t}\n\n\t\t\t// Create a new limiter using the calculated values.\n\t\t\tc.limiter = rate.NewLimiter(limit, burst)\n\n\t\t\t// Call the limiter once as we have already made a request\n\t\t\t// to get the headers and the limiter is not aware of this.\n\t\t\tc.limiter.Wait(ctx)\n\t\t}\n\t}\n}\n\n// BaseURL return a copy of the baseURL.\nfunc (c *Client) BaseURL() *url.URL {\n\tu := *c.baseURL\n\treturn &u\n}\n\n// setBaseURL sets the base URL for API requests to a custom endpoint.\nfunc (c *Client) setBaseURL(urlStr string) error {\n\t// Make sure the given URL end with a slash\n\tif !strings.HasSuffix(urlStr, \"/\") {\n\t\turlStr += \"/\"\n\t}\n\n\tbaseURL, err := url.Parse(urlStr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !strings.HasSuffix(baseURL.Path, apiVersionPath) {\n\t\tbaseURL.Path += apiVersionPath\n\t}\n\n\t// Update the base URL of the client.\n\tc.baseURL = baseURL\n\n\treturn nil\n}\n\n// NewRequest creates a new API request. The method expects a relative URL\n// path that will be resolved relative to the base URL of the Client.\n// Relative URL paths should always be specified without a preceding slash.\n// If specified, the value pointed to by body is JSON encoded and included\n// as the request body.\nfunc (c *Client) NewRequest(method, path string, opt interface{}, options []RequestOptionFunc) (*retryablehttp.Request, error) {\n\tu := *c.baseURL\n\tunescaped, err := url.PathUnescape(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the encoded path data\n\tu.RawPath = c.baseURL.Path + path\n\tu.Path = c.baseURL.Path + unescaped\n\n\t// Create a request specific headers map.\n\treqHeaders := make(http.Header)\n\treqHeaders.Set(\"Accept\", \"application/json\")\n\n\tif c.UserAgent != \"\" {\n\t\treqHeaders.Set(\"User-Agent\", c.UserAgent)\n\t}\n\n\tvar body interface{}\n\tswitch {\n\tcase method == http.MethodPatch || method == http.MethodPost || method == http.MethodPut:\n\t\treqHeaders.Set(\"Content-Type\", \"application/json\")\n\n\t\tif opt != nil {\n\t\t\tbody, err = json.Marshal(opt)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\tcase opt != nil:\n\t\tq, err := query.Values(opt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tu.RawQuery = q.Encode()\n\t}\n\n\treq, err := retryablehttp.NewRequest(method, u.String(), body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, fn := range append(c.defaultRequestOptions, options...) {\n\t\tif fn == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := fn(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Set the request specific headers.\n\tfor k, v := range reqHeaders {\n\t\treq.Header[k] = v\n\t}\n\n\treturn req, nil\n}\n\n// UploadRequest creates an API request for uploading a file. The method\n// expects a relative URL path that will be resolved relative to the base\n// URL of the Client. Relative URL paths should always be specified without\n// a preceding slash. If specified, the value pointed to by body is JSON\n// encoded and included as the request body.\nfunc (c *Client) UploadRequest(method, path string, content io.Reader, filename string, uploadType UploadType, opt interface{}, options []RequestOptionFunc) (*retryablehttp.Request, error) {\n\tu := *c.baseURL\n\tunescaped, err := url.PathUnescape(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the encoded path data\n\tu.RawPath = c.baseURL.Path + path\n\tu.Path = c.baseURL.Path + unescaped\n\n\t// Create a request specific headers map.\n\treqHeaders := make(http.Header)\n\treqHeaders.Set(\"Accept\", \"application/json\")\n\n\tif c.UserAgent != \"\" {\n\t\treqHeaders.Set(\"User-Agent\", c.UserAgent)\n\t}\n\n\tb := new(bytes.Buffer)\n\tw := multipart.NewWriter(b)\n\n\tfw, err := w.CreateFormFile(string(uploadType), filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif _, err := io.Copy(fw, content); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif opt != nil {\n\t\tfields, err := query.Values(opt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor name := range fields {\n\t\t\tif err = w.WriteField(name, fmt.Sprintf(\"%v\", fields.Get(name))); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err = w.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treqHeaders.Set(\"Content-Type\", w.FormDataContentType())\n\n\treq, err := retryablehttp.NewRequest(method, u.String(), b)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, fn := range append(c.defaultRequestOptions, options...) {\n\t\tif fn == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := fn(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Set the request specific headers.\n\tfor k, v := range reqHeaders {\n\t\treq.Header[k] = v\n\t}\n\n\treturn req, nil\n}\n\n// Response is a GitLab API response. This wraps the standard http.Response\n// returned from GitLab and provides convenient access to things like\n// pagination links.\ntype Response struct {\n\t*http.Response\n\n\t// Fields used for offset-based pagination.\n\tTotalItems   int\n\tTotalPages   int\n\tItemsPerPage int\n\tCurrentPage  int\n\tNextPage     int\n\tPreviousPage int\n\n\t// Fields used for keyset-based pagination.\n\tPreviousLink string\n\tNextLink     string\n\tFirstLink    string\n\tLastLink     string\n}\n\n// newResponse creates a new Response for the provided http.Response.\nfunc newResponse(r *http.Response) *Response {\n\tresponse := &Response{Response: r}\n\tresponse.populatePageValues()\n\tresponse.populateLinkValues()\n\treturn response\n}\n\nconst (\n\t// Headers used for offset-based pagination.\n\txTotal      = \"X-Total\"\n\txTotalPages = \"X-Total-Pages\"\n\txPerPage    = \"X-Per-Page\"\n\txPage       = \"X-Page\"\n\txNextPage   = \"X-Next-Page\"\n\txPrevPage   = \"X-Prev-Page\"\n\n\t// Headers used for keyset-based pagination.\n\tlinkPrev  = \"prev\"\n\tlinkNext  = \"next\"\n\tlinkFirst = \"first\"\n\tlinkLast  = \"last\"\n)\n\n// populatePageValues parses the HTTP Link response headers and populates the\n// various pagination link values in the Response.\nfunc (r *Response) populatePageValues() {\n\tif totalItems := r.Header.Get(xTotal); totalItems != \"\" {\n\t\tr.TotalItems, _ = strconv.Atoi(totalItems)\n\t}\n\tif totalPages := r.Header.Get(xTotalPages); totalPages != \"\" {\n\t\tr.TotalPages, _ = strconv.Atoi(totalPages)\n\t}\n\tif itemsPerPage := r.Header.Get(xPerPage); itemsPerPage != \"\" {\n\t\tr.ItemsPerPage, _ = strconv.Atoi(itemsPerPage)\n\t}\n\tif currentPage := r.Header.Get(xPage); currentPage != \"\" {\n\t\tr.CurrentPage, _ = strconv.Atoi(currentPage)\n\t}\n\tif nextPage := r.Header.Get(xNextPage); nextPage != \"\" {\n\t\tr.NextPage, _ = strconv.Atoi(nextPage)\n\t}\n\tif previousPage := r.Header.Get(xPrevPage); previousPage != \"\" {\n\t\tr.PreviousPage, _ = strconv.Atoi(previousPage)\n\t}\n}\n\nfunc (r *Response) populateLinkValues() {\n\tif link := r.Header.Get(\"Link\"); link != \"\" {\n\t\tfor _, link := range strings.Split(link, \",\") {\n\t\t\tparts := strings.Split(link, \";\")\n\t\t\tif len(parts) < 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlinkType := strings.Trim(strings.Split(parts[1], \"=\")[1], \"\\\"\")\n\t\t\tlinkValue := strings.Trim(parts[0], \"< >\")\n\n\t\t\tswitch linkType {\n\t\t\tcase linkPrev:\n\t\t\t\tr.PreviousLink = linkValue\n\t\t\tcase linkNext:\n\t\t\t\tr.NextLink = linkValue\n\t\t\tcase linkFirst:\n\t\t\t\tr.FirstLink = linkValue\n\t\t\tcase linkLast:\n\t\t\t\tr.LastLink = linkValue\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Do sends an API request and returns the API response. The API response is\n// JSON decoded and stored in the value pointed to by v, or returned as an\n// error if an API error has occurred. If v implements the io.Writer\n// interface, the raw response body will be written to v, without attempting to\n// first decode it.\nfunc (c *Client) Do(req *retryablehttp.Request, v interface{}) (*Response, error) {\n\t// Wait will block until the limiter can obtain a new token.\n\terr := c.limiter.Wait(req.Context())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the correct authentication header. If using basic auth, then check\n\t// if we already have a token and if not first authenticate and get one.\n\tvar basicAuthToken string\n\tswitch c.authType {\n\tcase BasicAuth:\n\t\tc.tokenLock.RLock()\n\t\tbasicAuthToken = c.token\n\t\tc.tokenLock.RUnlock()\n\t\tif basicAuthToken == \"\" {\n\t\t\t// If we don't have a token yet, we first need to request one.\n\t\t\tbasicAuthToken, err = c.requestOAuthToken(req.Context(), basicAuthToken)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\treq.Header.Set(\"Authorization\", \"Bearer \"+basicAuthToken)\n\tcase JobToken:\n\t\tif values := req.Header.Values(\"JOB-TOKEN\"); len(values) == 0 {\n\t\t\treq.Header.Set(\"JOB-TOKEN\", c.token)\n\t\t}\n\tcase OAuthToken:\n\t\tif values := req.Header.Values(\"Authorization\"); len(values) == 0 {\n\t\t\treq.Header.Set(\"Authorization\", \"Bearer \"+c.token)\n\t\t}\n\tcase PrivateToken:\n\t\tif values := req.Header.Values(\"PRIVATE-TOKEN\"); len(values) == 0 {\n\t\t\treq.Header.Set(\"PRIVATE-TOKEN\", c.token)\n\t\t}\n\t}\n\n\tresp, err := c.client.Do(req)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif resp.StatusCode == http.StatusUnauthorized && c.authType == BasicAuth {\n\t\tresp.Body.Close()\n\t\t// The token most likely expired, so we need to request a new one and try again.\n\t\tif _, err := c.requestOAuthToken(req.Context(), basicAuthToken); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn c.Do(req, v)\n\t}\n\tdefer resp.Body.Close()\n\tdefer io.Copy(io.Discard, resp.Body)\n\n\t// If not yet configured, try to configure the rate limiter\n\t// using the response headers we just received. Fail silently\n\t// so the limiter will remain disabled in case of an error.\n\tc.configureLimiterOnce.Do(func() { c.configureLimiter(req.Context(), resp.Header) })\n\n\tresponse := newResponse(resp)\n\n\terr = CheckResponse(resp)\n\tif err != nil {\n\t\t// Even though there was an error, we still return the response\n\t\t// in case the caller wants to inspect it further.\n\t\treturn response, err\n\t}\n\n\tif v != nil {\n\t\tif w, ok := v.(io.Writer); ok {\n\t\t\t_, err = io.Copy(w, resp.Body)\n\t\t} else {\n\t\t\terr = json.NewDecoder(resp.Body).Decode(v)\n\t\t}\n\t}\n\n\treturn response, err\n}\n\nfunc (c *Client) requestOAuthToken(ctx context.Context, token string) (string, error) {\n\tc.tokenLock.Lock()\n\tdefer c.tokenLock.Unlock()\n\n\t// Return early if the token was updated while waiting for the lock.\n\tif c.token != token {\n\t\treturn c.token, nil\n\t}\n\n\tconfig := &oauth2.Config{\n\t\tEndpoint: oauth2.Endpoint{\n\t\t\tAuthURL:  strings.TrimSuffix(c.baseURL.String(), apiVersionPath) + \"oauth/authorize\",\n\t\t\tTokenURL: strings.TrimSuffix(c.baseURL.String(), apiVersionPath) + \"oauth/token\",\n\t\t},\n\t}\n\n\tctx = context.WithValue(ctx, oauth2.HTTPClient, c.client.HTTPClient)\n\tt, err := config.PasswordCredentialsToken(ctx, c.username, c.password)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tc.token = t.AccessToken\n\n\treturn c.token, nil\n}\n\n// Helper function to accept and format both the project ID or name as project\n// identifier for all API calls.\nfunc parseID(id interface{}) (string, error) {\n\tswitch v := id.(type) {\n\tcase int:\n\t\treturn strconv.Itoa(v), nil\n\tcase string:\n\t\treturn v, nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"invalid ID type %#v, the ID must be an int or a string\", id)\n\t}\n}\n\n// Helper function to escape a project identifier.\nfunc PathEscape(s string) string {\n\treturn strings.ReplaceAll(url.PathEscape(s), \".\", \"%2E\")\n}\n\n// An ErrorResponse reports one or more errors caused by an API request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/index.html#data-validation-and-error-reporting\ntype ErrorResponse struct {\n\tBody     []byte\n\tResponse *http.Response\n\tMessage  string\n}\n\nfunc (e *ErrorResponse) Error() string {\n\tpath, _ := url.QueryUnescape(e.Response.Request.URL.Path)\n\turl := fmt.Sprintf(\"%s://%s%s\", e.Response.Request.URL.Scheme, e.Response.Request.URL.Host, path)\n\n\tif e.Message == \"\" {\n\t\treturn fmt.Sprintf(\"%s %s: %d\", e.Response.Request.Method, url, e.Response.StatusCode)\n\t} else {\n\t\treturn fmt.Sprintf(\"%s %s: %d %s\", e.Response.Request.Method, url, e.Response.StatusCode, e.Message)\n\t}\n}\n\n// CheckResponse checks the API response for errors, and returns them if present.\nfunc CheckResponse(r *http.Response) error {\n\tswitch r.StatusCode {\n\tcase 200, 201, 202, 204, 304:\n\t\treturn nil\n\tcase 404:\n\t\treturn ErrNotFound\n\t}\n\n\terrorResponse := &ErrorResponse{Response: r}\n\n\tdata, err := io.ReadAll(r.Body)\n\tif err == nil && strings.TrimSpace(string(data)) != \"\" {\n\t\terrorResponse.Body = data\n\n\t\tvar raw interface{}\n\t\tif err := json.Unmarshal(data, &raw); err != nil {\n\t\t\terrorResponse.Message = fmt.Sprintf(\"failed to parse unknown error format: %s\", data)\n\t\t} else {\n\t\t\terrorResponse.Message = parseError(raw)\n\t\t}\n\t}\n\n\treturn errorResponse\n}\n\n// Format:\n//\n//\t{\n//\t    \"message\": {\n//\t        \"<property-name>\": [\n//\t            \"<error-message>\",\n//\t            \"<error-message>\",\n//\t            ...\n//\t        ],\n//\t        \"<embed-entity>\": {\n//\t            \"<property-name>\": [\n//\t                \"<error-message>\",\n//\t                \"<error-message>\",\n//\t                ...\n//\t            ],\n//\t        }\n//\t    },\n//\t    \"error\": \"<error-message>\"\n//\t}\nfunc parseError(raw interface{}) string {\n\tswitch raw := raw.(type) {\n\tcase string:\n\t\treturn raw\n\n\tcase []interface{}:\n\t\tvar errs []string\n\t\tfor _, v := range raw {\n\t\t\terrs = append(errs, parseError(v))\n\t\t}\n\t\treturn fmt.Sprintf(\"[%s]\", strings.Join(errs, \", \"))\n\n\tcase map[string]interface{}:\n\t\tvar errs []string\n\t\tfor k, v := range raw {\n\t\t\terrs = append(errs, fmt.Sprintf(\"{%s: %s}\", k, parseError(v)))\n\t\t}\n\t\tsort.Strings(errs)\n\t\treturn strings.Join(errs, \", \")\n\n\tdefault:\n\t\treturn fmt.Sprintf(\"failed to parse unexpected error type: %T\", raw)\n\t}\n}\n"
        },
        {
          "name": "gitlab_test.go",
          "type": "blob",
          "size": 11.189453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tretryablehttp \"github.com/hashicorp/go-retryablehttp\"\n)\n\nvar timeLayout = \"2006-01-02T15:04:05Z07:00\"\n\n// setup sets up a test HTTP server along with a gitlab.Client that is\n// configured to talk to that test server.  Tests should register handlers on\n// mux which provide mock responses for the API method being tested.\nfunc setup(t *testing.T) (*http.ServeMux, *Client) {\n\t// mux is the HTTP request multiplexer used with the test server.\n\tmux := http.NewServeMux()\n\n\t// server is a test HTTP server used to provide mock API responses.\n\tserver := httptest.NewServer(mux)\n\tt.Cleanup(server.Close)\n\n\t// client is the Gitlab client being tested.\n\tclient, err := NewClient(\"\",\n\t\tWithBaseURL(server.URL),\n\t\t// Disable backoff to speed up tests that expect errors.\n\t\tWithCustomBackoff(func(_, _ time.Duration, _ int, _ *http.Response) time.Duration {\n\t\t\treturn 0\n\t\t}),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\treturn mux, client\n}\n\nfunc testURL(t *testing.T, r *http.Request, want string) {\n\tif got := r.RequestURI; got != want {\n\t\tt.Errorf(\"Request url: %+v, want %s\", got, want)\n\t}\n}\n\nfunc testMethod(t *testing.T, r *http.Request, want string) {\n\tif got := r.Method; got != want {\n\t\tt.Errorf(\"Request method: %s, want %s\", got, want)\n\t}\n}\n\nfunc testBody(t *testing.T, r *http.Request, want string) {\n\tbuffer := new(bytes.Buffer)\n\t_, err := buffer.ReadFrom(r.Body)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to Read Body: %v\", err)\n\t}\n\n\tif got := buffer.String(); got != want {\n\t\tt.Errorf(\"Request body: %s, want %s\", got, want)\n\t}\n}\n\nfunc testParams(t *testing.T, r *http.Request, want string) {\n\tif got := r.URL.RawQuery; got != want {\n\t\tt.Errorf(\"Request query: %s, want %s\", got, want)\n\t}\n}\n\nfunc mustWriteHTTPResponse(t *testing.T, w io.Writer, fixturePath string) {\n\tf, err := os.Open(fixturePath)\n\tif err != nil {\n\t\tt.Fatalf(\"error opening fixture file: %v\", err)\n\t}\n\n\tif _, err = io.Copy(w, f); err != nil {\n\t\tt.Fatalf(\"error writing response: %v\", err)\n\t}\n}\n\nfunc errorOption(*retryablehttp.Request) error {\n\treturn errors.New(\"RequestOptionFunc returns an error\")\n}\n\nfunc TestNewClient(t *testing.T) {\n\tc, err := NewClient(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\texpectedBaseURL := defaultBaseURL + apiVersionPath\n\n\tif c.BaseURL().String() != expectedBaseURL {\n\t\tt.Errorf(\"NewClient BaseURL is %s, want %s\", c.BaseURL().String(), expectedBaseURL)\n\t}\n\tif c.UserAgent != userAgent {\n\t\tt.Errorf(\"NewClient UserAgent is %s, want %s\", c.UserAgent, userAgent)\n\t}\n}\n\nfunc TestCheckResponse(t *testing.T) {\n\tc, err := NewClient(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\treq, err := c.NewRequest(http.MethodGet, \"test\", nil, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\n\tresp := &http.Response{\n\t\tRequest:    req.Request,\n\t\tStatusCode: http.StatusBadRequest,\n\t\tBody: io.NopCloser(strings.NewReader(`\n\t\t{\n\t\t\t\"message\": {\n\t\t\t\t\"prop1\": [\n\t\t\t\t\t\"message 1\",\n\t\t\t\t\t\"message 2\"\n\t\t\t\t],\n\t\t\t\t\"prop2\":[\n\t\t\t\t\t\"message 3\"\n\t\t\t\t],\n\t\t\t\t\"embed1\": {\n\t\t\t\t\t\"prop3\": [\n\t\t\t\t\t\t\"msg 1\",\n\t\t\t\t\t\t\"msg2\"\n\t\t\t\t\t]\n\t\t\t\t},\n\t\t\t\t\"embed2\": {\n\t\t\t\t\t\"prop4\": [\n\t\t\t\t\t\t\"some msg\"\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"error\": \"message 1\"\n\t\t}`)),\n\t}\n\n\terrResp := CheckResponse(resp)\n\tif errResp == nil {\n\t\tt.Fatal(\"Expected error response.\")\n\t}\n\n\twant := \"GET https://gitlab.com/api/v4/test: 400 {error: message 1}, {message: {embed1: {prop3: [msg 1, msg2]}}, {embed2: {prop4: [some msg]}}, {prop1: [message 1, message 2]}, {prop2: [message 3]}}\"\n\n\tif errResp.Error() != want {\n\t\tt.Errorf(\"Expected error: %s, got %s\", want, errResp.Error())\n\t}\n}\n\nfunc TestCheckResponseOnUnknownErrorFormat(t *testing.T) {\n\tc, err := NewClient(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\treq, err := c.NewRequest(http.MethodGet, \"test\", nil, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\n\tresp := &http.Response{\n\t\tRequest:    req.Request,\n\t\tStatusCode: http.StatusBadRequest,\n\t\tBody:       io.NopCloser(strings.NewReader(\"some error message but not JSON\")),\n\t}\n\n\terrResp := CheckResponse(resp)\n\tif errResp == nil {\n\t\tt.Fatal(\"Expected error response.\")\n\t}\n\n\twant := \"GET https://gitlab.com/api/v4/test: 400 failed to parse unknown error format: some error message but not JSON\"\n\n\tif errResp.Error() != want {\n\t\tt.Errorf(\"Expected error: %s, got %s\", want, errResp.Error())\n\t}\n}\n\nfunc TestCheckResponseOnHeadRequestError(t *testing.T) {\n\tc, err := NewClient(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\treq, err := c.NewRequest(http.MethodHead, \"test\", nil, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\n\tresp := &http.Response{\n\t\tRequest:    req.Request,\n\t\tStatusCode: http.StatusNotFound,\n\t\tBody:       nil,\n\t}\n\n\terrResp := CheckResponse(resp)\n\tif errResp == nil {\n\t\tt.Fatal(\"Expected error response.\")\n\t}\n\n\twant := \"404 Not Found\"\n\n\tif errResp.Error() != want {\n\t\tt.Errorf(\"Expected error: %s, got %s\", want, errResp.Error())\n\t}\n}\n\nfunc TestRequestWithContext(t *testing.T) {\n\tc, err := NewClient(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\tctx, cancel := context.WithCancel(context.Background())\n\treq, err := c.NewRequest(http.MethodGet, \"test\", nil, []RequestOptionFunc{WithContext(ctx)})\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create request: %v\", err)\n\t}\n\tdefer cancel()\n\n\tif req.Context() != ctx {\n\t\tt.Fatal(\"Context was not set correctly\")\n\t}\n}\n\nfunc loadFixture(t *testing.T, filePath string) []byte {\n\tt.Helper()\n\tcontent, err := os.ReadFile(filePath)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\treturn content\n}\n\nfunc TestPathEscape(t *testing.T) {\n\twant := \"diaspora%2Fdiaspora\"\n\tgot := PathEscape(\"diaspora/diaspora\")\n\tif want != got {\n\t\tt.Errorf(\"Expected: %s, got %s\", want, got)\n\t}\n}\n\nfunc TestPaginationPopulatePageValuesEmpty(t *testing.T) {\n\twantPageHeaders := map[string]int{\n\t\txTotal:      0,\n\t\txTotalPages: 0,\n\t\txPerPage:    0,\n\t\txPage:       0,\n\t\txNextPage:   0,\n\t\txPrevPage:   0,\n\t}\n\twantLinkHeaders := map[string]string{\n\t\tlinkPrev:  \"\",\n\t\tlinkNext:  \"\",\n\t\tlinkFirst: \"\",\n\t\tlinkLast:  \"\",\n\t}\n\n\tr := newResponse(&http.Response{\n\t\tHeader: http.Header{},\n\t})\n\n\tgotPageHeaders := map[string]int{\n\t\txTotal:      r.TotalItems,\n\t\txTotalPages: r.TotalPages,\n\t\txPerPage:    r.ItemsPerPage,\n\t\txPage:       r.CurrentPage,\n\t\txNextPage:   r.NextPage,\n\t\txPrevPage:   r.PreviousPage,\n\t}\n\tfor k, v := range wantPageHeaders {\n\t\tif v != gotPageHeaders[k] {\n\t\t\tt.Errorf(\"For %s, expected %d, got %d\", k, v, gotPageHeaders[k])\n\t\t}\n\t}\n\n\tgotLinkHeaders := map[string]string{\n\t\tlinkPrev:  r.PreviousLink,\n\t\tlinkNext:  r.NextLink,\n\t\tlinkFirst: r.FirstLink,\n\t\tlinkLast:  r.LastLink,\n\t}\n\tfor k, v := range wantLinkHeaders {\n\t\tif v != gotLinkHeaders[k] {\n\t\t\tt.Errorf(\"For %s, expected %s, got %s\", k, v, gotLinkHeaders[k])\n\t\t}\n\t}\n}\n\nfunc TestPaginationPopulatePageValuesOffset(t *testing.T) {\n\twantPageHeaders := map[string]int{\n\t\txTotal:      100,\n\t\txTotalPages: 5,\n\t\txPerPage:    20,\n\t\txPage:       2,\n\t\txNextPage:   3,\n\t\txPrevPage:   1,\n\t}\n\twantLinkHeaders := map[string]string{\n\t\tlinkPrev:  \"https://gitlab.example.com/api/v4/projects/8/issues/8/notes?page=1&per_page=3\",\n\t\tlinkNext:  \"https://gitlab.example.com/api/v4/projects/8/issues/8/notes?page=3&per_page=3\",\n\t\tlinkFirst: \"https://gitlab.example.com/api/v4/projects/8/issues/8/notes?page=1&per_page=3\",\n\t\tlinkLast:  \"https://gitlab.example.com/api/v4/projects/8/issues/8/notes?page=3&per_page=3\",\n\t}\n\n\th := http.Header{}\n\tfor k, v := range wantPageHeaders {\n\t\th.Add(k, fmt.Sprint(v))\n\t}\n\tvar linkHeaderComponents []string\n\tfor k, v := range wantLinkHeaders {\n\t\tif v != \"\" {\n\t\t\tlinkHeaderComponents = append(linkHeaderComponents, fmt.Sprintf(\"<%s>; rel=\\\"%s\\\"\", v, k))\n\t\t}\n\t}\n\th.Add(\"Link\", strings.Join(linkHeaderComponents, \", \"))\n\n\tr := newResponse(&http.Response{\n\t\tHeader: h,\n\t})\n\n\tgotPageHeaders := map[string]int{\n\t\txTotal:      r.TotalItems,\n\t\txTotalPages: r.TotalPages,\n\t\txPerPage:    r.ItemsPerPage,\n\t\txPage:       r.CurrentPage,\n\t\txNextPage:   r.NextPage,\n\t\txPrevPage:   r.PreviousPage,\n\t}\n\tfor k, v := range wantPageHeaders {\n\t\tif v != gotPageHeaders[k] {\n\t\t\tt.Errorf(\"For %s, expected %d, got %d\", k, v, gotPageHeaders[k])\n\t\t}\n\t}\n\n\tgotLinkHeaders := map[string]string{\n\t\tlinkPrev:  r.PreviousLink,\n\t\tlinkNext:  r.NextLink,\n\t\tlinkFirst: r.FirstLink,\n\t\tlinkLast:  r.LastLink,\n\t}\n\tfor k, v := range wantLinkHeaders {\n\t\tif v != gotLinkHeaders[k] {\n\t\t\tt.Errorf(\"For %s, expected %s, got %s\", k, v, gotLinkHeaders[k])\n\t\t}\n\t}\n}\n\nfunc TestPaginationPopulatePageValuesKeyset(t *testing.T) {\n\twantPageHeaders := map[string]int{\n\t\txTotal:      0,\n\t\txTotalPages: 0,\n\t\txPerPage:    0,\n\t\txPage:       0,\n\t\txNextPage:   0,\n\t\txPrevPage:   0,\n\t}\n\twantLinkHeaders := map[string]string{\n\t\tlinkPrev:  \"\",\n\t\tlinkFirst: \"\",\n\t\tlinkLast:  \"\",\n\t}\n\n\th := http.Header{}\n\tfor k, v := range wantPageHeaders {\n\t\th.Add(k, fmt.Sprint(v))\n\t}\n\tvar linkHeaderComponents []string\n\tfor k, v := range wantLinkHeaders {\n\t\tif v != \"\" {\n\t\t\tlinkHeaderComponents = append(linkHeaderComponents, fmt.Sprintf(\"<%s>; rel=\\\"%s\\\"\", v, k))\n\t\t}\n\t}\n\th.Add(\"Link\", strings.Join(linkHeaderComponents, \", \"))\n\n\tr := newResponse(&http.Response{\n\t\tHeader: h,\n\t})\n\n\tgotPageHeaders := map[string]int{\n\t\txTotal:      r.TotalItems,\n\t\txTotalPages: r.TotalPages,\n\t\txPerPage:    r.ItemsPerPage,\n\t\txPage:       r.CurrentPage,\n\t\txNextPage:   r.NextPage,\n\t\txPrevPage:   r.PreviousPage,\n\t}\n\tfor k, v := range wantPageHeaders {\n\t\tif v != gotPageHeaders[k] {\n\t\t\tt.Errorf(\"For %s, expected %d, got %d\", k, v, gotPageHeaders[k])\n\t\t}\n\t}\n}\n\nfunc TestExponentialBackoffLogic(t *testing.T) {\n\t// Can't use the default `setup` because it disabled the backoff\n\tmux := http.NewServeMux()\n\tserver := httptest.NewServer(mux)\n\tt.Cleanup(server.Close)\n\tclient, err := NewClient(\"\",\n\t\tWithBaseURL(server.URL),\n\t)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create client: %v\", err)\n\t}\n\n\t// Create a method that returns 429\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusTooManyRequests)\n\t})\n\n\t// Measure the time at the start of the test\n\tstart := time.Now()\n\n\t// Send a request (which will get a bunch of 429s)\n\t// None of the responses matter, so ignore them all\n\t_, resp, _ := client.Projects.GetProject(1, nil)\n\tend := time.Now()\n\n\t// The test should run for _at least_ 3,200 milliseconds\n\tduration := float64(end.Sub(start))\n\tif duration < float64(3200*time.Millisecond) {\n\t\tt.Fatal(\"Wait was shorter than expected. Expected a minimum of 5 retries taking 3200 milliseconds, got:\", duration)\n\t}\n\tif resp.StatusCode != 429 {\n\t\tt.Fatal(\"Expected to get a 429 code given the server is hard-coded to return this. Received instead:\", resp.StatusCode)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.7177734375,
          "content": "// Deprecated: This module has been migrated to gitlab.com/gitlab-org/api/client-go. See https://gitlab.com/gitlab-org/api/client-go\nmodule github.com/xanzy/go-gitlab\n\ngo 1.19\n\nrequire (\n\tgithub.com/google/go-querystring v1.1.0\n\tgithub.com/hashicorp/go-cleanhttp v0.5.2\n\tgithub.com/hashicorp/go-retryablehttp v0.7.7\n\tgithub.com/stretchr/testify v1.8.1\n\tgolang.org/x/oauth2 v0.6.0\n\tgolang.org/x/time v0.3.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/golang/protobuf v1.5.3 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.org/x/net v0.8.0 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgoogle.golang.org/protobuf v1.29.1 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.671875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/fatih/color v1.16.0 h1:zmkK9Ngbjj+K0yRhTVONQh1p/HknKYSlNT+vZCzyokM=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.3 h1:KhyjKVUg7Usr/dYsdSqoFveMYd5ko72D+zANwlG1mmg=\ngithub.com/golang/protobuf v1.5.3/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.8 h1:e6P7q2lk1O+qJJb4BtCQXlK8vWEO8V1ZeuEdJNOqZyg=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngithub.com/hashicorp/go-cleanhttp v0.5.2 h1:035FKYIWjmULyFRBKPs8TBQoi0x6d9G4xc9neXJWAZQ=\ngithub.com/hashicorp/go-cleanhttp v0.5.2/go.mod h1:kO/YDlP8L1346E6Sodw+PrpBSV4/SoxCXGY6BqNFT48=\ngithub.com/hashicorp/go-hclog v1.6.3 h1:Qr2kF+eVWjTiYmU7Y31tYlP1h0q/X3Nl3tPGdaB11/k=\ngithub.com/hashicorp/go-retryablehttp v0.7.7 h1:C8hUCYzor8PIfXHa4UrZkU4VvK8o9ISHxT2Q8+VepXU=\ngithub.com/hashicorp/go-retryablehttp v0.7.7/go.mod h1:pkQpWZeYWskR+D1tR2O5OcBFOxfA7DoAO6xtkuQnHTk=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngithub.com/stretchr/testify v1.8.1 h1:w7B6lhMri9wdJUVmEZPGGhZzrYTPvgJArz7wNPgYKsk=\ngithub.com/stretchr/testify v1.8.1/go.mod h1:w2LPCIKwWwSfY2zedu0+kehJoqGctiVI29o6fzry7u4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.8.0 h1:Zrh2ngAOFYneWTAIAPethzeaQLuHwhuBkuV6ZiRnUaQ=\ngolang.org/x/net v0.8.0/go.mod h1:QVkue5JL9kW//ek3r6jTKnTFis1tRmNAW2P1shuFdJc=\ngolang.org/x/oauth2 v0.6.0 h1:Lh8GPgSKBfWSwFvtuWOfeI3aAAnbXTSutYxJiOJFgIw=\ngolang.org/x/oauth2 v0.6.0/go.mod h1:ycmewcwgD4Rpr3eZJLSB4Kyyljb3qDh40vJ8STE5HKw=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/time v0.3.0 h1:rg5rLMjNzMS1RkNLzCG38eapWhnYLFYXDXj2gOlr8j4=\ngolang.org/x/time v0.3.0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6c=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.29.1 h1:7QBf+IK2gx70Ap/hDsOmam3GE0v9HicjfEdAxE62UoM=\ngoogle.golang.org/protobuf v1.29.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "group_access_tokens.go",
          "type": "blob",
          "size": 6.3056640625,
          "content": "//\n// Copyright 2022, Masahiro Yoshida\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupAccessTokensService handles communication with the\n// groups access tokens related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_access_tokens.html\ntype GroupAccessTokensService struct {\n\tclient *Client\n}\n\n// GroupAccessToken represents a GitLab group access token.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_access_tokens.html\ntype GroupAccessToken struct {\n\tID          int              `json:\"id\"`\n\tUserID      int              `json:\"user_id\"`\n\tName        string           `json:\"name\"`\n\tScopes      []string         `json:\"scopes\"`\n\tCreatedAt   *time.Time       `json:\"created_at\"`\n\tExpiresAt   *ISOTime         `json:\"expires_at\"`\n\tLastUsedAt  *time.Time       `json:\"last_used_at\"`\n\tActive      bool             `json:\"active\"`\n\tRevoked     bool             `json:\"revoked\"`\n\tToken       string           `json:\"token\"`\n\tAccessLevel AccessLevelValue `json:\"access_level\"`\n}\n\nfunc (v GroupAccessToken) String() string {\n\treturn Stringify(v)\n}\n\n// ListGroupAccessTokensOptions represents the available options for\n// listing variables in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#list-group-access-tokens\ntype ListGroupAccessTokensOptions ListOptions\n\n// ListGroupAccessTokens gets a list of all group access tokens in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#list-group-access-tokens\nfunc (s *GroupAccessTokensService) ListGroupAccessTokens(gid interface{}, opt *ListGroupAccessTokensOptions, options ...RequestOptionFunc) ([]*GroupAccessToken, *Response, error) {\n\tgroups, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_tokens\", PathEscape(groups))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gats []*GroupAccessToken\n\tresp, err := s.client.Do(req, &gats)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gats, resp, nil\n}\n\n// GetGroupAccessToken gets a single group access tokens in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#get-a-group-access-token\nfunc (s *GroupAccessTokensService) GetGroupAccessToken(gid interface{}, id int, options ...RequestOptionFunc) (*GroupAccessToken, *Response, error) {\n\tgroups, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_tokens/%d\", PathEscape(groups), id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgat := new(GroupAccessToken)\n\tresp, err := s.client.Do(req, &gat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gat, resp, nil\n}\n\n// CreateGroupAccessTokenOptions represents the available CreateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#create-a-group-access-token\ntype CreateGroupAccessTokenOptions struct {\n\tName        *string           `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tScopes      *[]string         `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt   *ISOTime          `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// CreateGroupAccessToken creates a new group access token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#create-a-group-access-token\nfunc (s *GroupAccessTokensService) CreateGroupAccessToken(gid interface{}, opt *CreateGroupAccessTokenOptions, options ...RequestOptionFunc) (*GroupAccessToken, *Response, error) {\n\tgroups, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_tokens\", PathEscape(groups))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(GroupAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RotateGroupAccessTokenOptions represents the available RotateGroupAccessToken()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#rotate-a-group-access-token\ntype RotateGroupAccessTokenOptions struct {\n\tExpiresAt *ISOTime `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// RotateGroupAccessToken revokes a group access token and returns a new group\n// access token that expires in one week per default.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#rotate-a-group-access-token\nfunc (s *GroupAccessTokensService) RotateGroupAccessToken(gid interface{}, id int, opt *RotateGroupAccessTokenOptions, options ...RequestOptionFunc) (*GroupAccessToken, *Response, error) {\n\tgroups, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_tokens/%d/rotate\", PathEscape(groups), id)\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgat := new(GroupAccessToken)\n\tresp, err := s.client.Do(req, gat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gat, resp, nil\n}\n\n// RevokeGroupAccessToken revokes a group access token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_access_tokens.html#revoke-a-group-access-token\nfunc (s *GroupAccessTokensService) RevokeGroupAccessToken(gid interface{}, id int, options ...RequestOptionFunc) (*Response, error) {\n\tgroups, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/access_tokens/%d\", PathEscape(groups), id)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_access_tokens_test.go",
          "type": "blob",
          "size": 6.033203125,
          "content": "//\n// Copyright 2022, Masahiro Yoshida\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListGroupAccessTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_group_access_tokens.json\")\n\t})\n\n\tgroupAccessTokens, _, err := client.GroupAccessTokens.ListGroupAccessTokens(1, &ListGroupAccessTokensOptions{Page: 1, PerPage: 20})\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.ListGroupAccessTokens returned error: %v\", err)\n\t}\n\n\ttime1, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.ListGroupAccessTokens returned error: %v\", err)\n\t}\n\ttime2, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.340Z\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.ListGroupAccessTokens returned error: %v\", err)\n\t}\n\ttime3, err := time.Parse(time.RFC3339, \"2021-03-10T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.ListGroupAccessTokens returned error: %v\", err)\n\t}\n\n\twant := []*GroupAccessToken{\n\t\t{\n\t\t\tID:          1876,\n\t\t\tUserID:      2453,\n\t\t\tName:        \"token 10\",\n\t\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\t\tCreatedAt:   &time1,\n\t\t\tLastUsedAt:  &time3,\n\t\t\tActive:      true,\n\t\t\tRevoked:     false,\n\t\t\tAccessLevel: AccessLevelValue(40),\n\t\t},\n\t\t{\n\t\t\tID:          1877,\n\t\t\tUserID:      2456,\n\t\t\tName:        \"token 8\",\n\t\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\t\tCreatedAt:   &time2,\n\t\t\tActive:      true,\n\t\t\tRevoked:     false,\n\t\t\tAccessLevel: AccessLevelValue(30),\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, groupAccessTokens) {\n\t\tt.Errorf(\"GroupAccessTokens.ListGroupAccessTokens returned %+v, want %+v\", groupAccessTokens, want)\n\t}\n}\n\nfunc TestGetGroupAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_group_access_token.json\")\n\t})\n\n\tgroupAccessToken, _, err := client.GroupAccessTokens.GetGroupAccessToken(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.GetGroupAccessToken returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.GetGroupAccessToken returned error: %v\", err)\n\t}\n\n\twant := &GroupAccessToken{\n\t\tID:          1,\n\t\tUserID:      2453,\n\t\tName:        \"token 10\",\n\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\tCreatedAt:   &createdAt,\n\t\tActive:      true,\n\t\tRevoked:     false,\n\t\tAccessLevel: AccessLevelValue(40),\n\t}\n\n\tif !reflect.DeepEqual(want, groupAccessToken) {\n\t\tt.Errorf(\"GroupAccessTokens.GetGroupAccessToken returned %+v, want %+v\", groupAccessToken, want)\n\t}\n}\n\nfunc TestCreateGroupAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_group_access_token.json\")\n\t})\n\n\tgroupAccessToken, _, err := client.GroupAccessTokens.CreateGroupAccessToken(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.CreateGroupAccessToken returned error: %v\", err)\n\t}\n\n\ttime1, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.CreateGroupAccessToken returned error: %v\", err)\n\t}\n\twant := &GroupAccessToken{\n\t\tID:          1876,\n\t\tUserID:      2453,\n\t\tName:        \"token 10\",\n\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\tExpiresAt:   nil,\n\t\tCreatedAt:   &time1,\n\t\tActive:      true,\n\t\tRevoked:     false,\n\t\tToken:       \"2UsevZE1x1ZdFZW4MNzH\",\n\t\tAccessLevel: AccessLevelValue(40),\n\t}\n\n\tif !reflect.DeepEqual(want, groupAccessToken) {\n\t\tt.Errorf(\"GroupAccessTokens.CreateGroupAccessToken returned %+v, want %+v\", groupAccessToken, want)\n\t}\n}\n\nfunc TestRotateGroupAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/groups/1/access_tokens/42/rotate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/rotate_group_access_token.json\")\n\t})\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2023-08-01T15:00:00.00Z\")\n\texpiration := ISOTime(time.Date(2023, time.August, 15, 0, 0, 0, 0, time.UTC))\n\topts := &RotateGroupAccessTokenOptions{ExpiresAt: &expiration}\n\trotatedToken, _, err := client.GroupAccessTokens.RotateGroupAccessToken(1, 42, opts)\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.RotateGroupAccessToken returned error: %v\", err)\n\t}\n\n\twant := &GroupAccessToken{\n\t\tID:          42,\n\t\tUserID:      1337,\n\t\tName:        \"Rotated Token\",\n\t\tScopes:      []string{\"api\"},\n\t\tExpiresAt:   &expiration,\n\t\tCreatedAt:   &createdAt,\n\t\tActive:      true,\n\t\tRevoked:     false,\n\t\tToken:       \"s3cr3t\",\n\t\tAccessLevel: AccessLevelValue(30),\n\t}\n\n\tif !reflect.DeepEqual(want, rotatedToken) {\n\t\tt.Errorf(\"GroupAccessTokens.RotateGroupAccessToken returned %+v, want %+v\", rotatedToken, want)\n\t}\n}\n\nfunc TestRevokeGroupAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/access_tokens/1234\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.GroupAccessTokens.RevokeGroupAccessToken(\"1\", 1234)\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.RevokeGroupAccessToken returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "group_badges.go",
          "type": "blob",
          "size": 6.892578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GroupBadgesService handles communication with the group badges\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html\ntype GroupBadgesService struct {\n\tclient *Client\n}\n\n// BadgeKind represents a GitLab Badge Kind\ntype BadgeKind string\n\n// all possible values Badge Kind\nconst (\n\tProjectBadgeKind BadgeKind = \"project\"\n\tGroupBadgeKind   BadgeKind = \"group\"\n)\n\n// GroupBadge represents a group badge.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html\ntype GroupBadge struct {\n\tID               int       `json:\"id\"`\n\tName             string    `json:\"name\"`\n\tLinkURL          string    `json:\"link_url\"`\n\tImageURL         string    `json:\"image_url\"`\n\tRenderedLinkURL  string    `json:\"rendered_link_url\"`\n\tRenderedImageURL string    `json:\"rendered_image_url\"`\n\tKind             BadgeKind `json:\"kind\"`\n}\n\n// ListGroupBadgesOptions represents the available ListGroupBadges() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#list-all-badges-of-a-group\ntype ListGroupBadgesOptions struct {\n\tListOptions\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// ListGroupBadges gets a list of a group badges.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#list-all-badges-of-a-group\nfunc (s *GroupBadgesService) ListGroupBadges(gid interface{}, opt *ListGroupBadgesOptions, options ...RequestOptionFunc) ([]*GroupBadge, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/badges\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gb []*GroupBadge\n\tresp, err := s.client.Do(req, &gb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gb, resp, nil\n}\n\n// GetGroupBadge gets a group badge.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#get-a-badge-of-a-group\nfunc (s *GroupBadgesService) GetGroupBadge(gid interface{}, badge int, options ...RequestOptionFunc) (*GroupBadge, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/badges/%d\", PathEscape(group), badge)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgb := new(GroupBadge)\n\tresp, err := s.client.Do(req, gb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gb, resp, nil\n}\n\n// AddGroupBadgeOptions represents the available AddGroupBadge() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#add-a-badge-to-a-group\ntype AddGroupBadgeOptions struct {\n\tLinkURL  *string `url:\"link_url,omitempty\" json:\"link_url,omitempty\"`\n\tImageURL *string `url:\"image_url,omitempty\" json:\"image_url,omitempty\"`\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// AddGroupBadge adds a badge to a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#add-a-badge-to-a-group\nfunc (s *GroupBadgesService) AddGroupBadge(gid interface{}, opt *AddGroupBadgeOptions, options ...RequestOptionFunc) (*GroupBadge, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/badges\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgb := new(GroupBadge)\n\tresp, err := s.client.Do(req, gb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gb, resp, nil\n}\n\n// EditGroupBadgeOptions represents the available EditGroupBadge() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#edit-a-badge-of-a-group\ntype EditGroupBadgeOptions struct {\n\tLinkURL  *string `url:\"link_url,omitempty\" json:\"link_url,omitempty\"`\n\tImageURL *string `url:\"image_url,omitempty\" json:\"image_url,omitempty\"`\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// EditGroupBadge updates a badge of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#edit-a-badge-of-a-group\nfunc (s *GroupBadgesService) EditGroupBadge(gid interface{}, badge int, opt *EditGroupBadgeOptions, options ...RequestOptionFunc) (*GroupBadge, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/badges/%d\", PathEscape(group), badge)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgb := new(GroupBadge)\n\tresp, err := s.client.Do(req, gb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gb, resp, nil\n}\n\n// DeleteGroupBadge removes a badge from a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#remove-a-badge-from-a-group\nfunc (s *GroupBadgesService) DeleteGroupBadge(gid interface{}, badge int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/badges/%d\", PathEscape(group), badge)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GroupBadgePreviewOptions represents the available PreviewGroupBadge() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#preview-a-badge-from-a-group\ntype GroupBadgePreviewOptions struct {\n\tLinkURL  *string `url:\"link_url,omitempty\" json:\"link_url,omitempty\"`\n\tImageURL *string `url:\"image_url,omitempty\" json:\"image_url,omitempty\"`\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// PreviewGroupBadge returns how the link_url and image_url final URLs would be after\n// resolving the placeholder interpolation.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_badges.html#preview-a-badge-from-a-group\nfunc (s *GroupBadgesService) PreviewGroupBadge(gid interface{}, opt *GroupBadgePreviewOptions, options ...RequestOptionFunc) (*GroupBadge, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/badges/render\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgb := new(GroupBadge)\n\tresp, err := s.client.Do(req, &gb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gb, resp, nil\n}\n"
        },
        {
          "name": "group_badges_test.go",
          "type": "blob",
          "size": 3.927734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListGroupBadges(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/badges\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[{\"id\":1, \"name\":\"one\", \"kind\":\"group\"},{\"id\":2, \"name\":\"two\", \"kind\":\"group\"}]`)\n\t\t})\n\n\tbadges, _, err := client.GroupBadges.ListGroupBadges(1, &ListGroupBadgesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupBadges.ListGroupBadges returned error: %v\", err)\n\t}\n\n\twant := []*GroupBadge{{ID: 1, Name: \"one\", Kind: GroupBadgeKind}, {ID: 2, Name: \"two\", Kind: GroupBadgeKind}}\n\tif !reflect.DeepEqual(want, badges) {\n\t\tt.Errorf(\"GroupBadges.ListGroupBadges returned %+v, want %+v\", badges, want)\n\t}\n}\n\nfunc TestGetGroupBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/badges/2\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\"id\":2, \"name\":\"two\", \"kind\":\"group\"}`)\n\t\t})\n\n\tbadge, _, err := client.GroupBadges.GetGroupBadge(1, 2)\n\tif err != nil {\n\t\tt.Errorf(\"GroupBadges.GetGroupBadge returned error: %v\", err)\n\t}\n\n\twant := &GroupBadge{ID: 2, Name: \"two\", Kind: GroupBadgeKind}\n\tif !reflect.DeepEqual(want, badge) {\n\t\tt.Errorf(\"GroupBadges.GetGroupBadge returned %+v, want %+v\", badge, want)\n\t}\n}\n\nfunc TestAddGroupBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/badges\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"id\":3, \"name\":\"three\", \"link_url\":\"LINK\", \"image_url\":\"IMAGE\", \"kind\":\"group\"}`)\n\t\t})\n\n\topt := &AddGroupBadgeOptions{ImageURL: Ptr(\"IMAGE\"), LinkURL: Ptr(\"LINK\")}\n\tbadge, _, err := client.GroupBadges.AddGroupBadge(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"GroupBadges.AddGroupBadge returned error: %v\", err)\n\t}\n\n\twant := &GroupBadge{ID: 3, Name: \"three\", ImageURL: \"IMAGE\", LinkURL: \"LINK\", Kind: GroupBadgeKind}\n\tif !reflect.DeepEqual(want, badge) {\n\t\tt.Errorf(\"GroupBadges.AddGroupBadge returned %+v, want %+v\", badge, want)\n\t}\n}\n\nfunc TestEditGroupBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/badges/2\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\"id\":2, \"name\":\"two\", \"link_url\":\"NEW_LINK\", \"image_url\":\"NEW_IMAGE\", \"kind\":\"group\"}`)\n\t\t})\n\n\topt := &EditGroupBadgeOptions{ImageURL: Ptr(\"NEW_IMAGE\"), LinkURL: Ptr(\"NEW_LINK\")}\n\tbadge, _, err := client.GroupBadges.EditGroupBadge(1, 2, opt)\n\tif err != nil {\n\t\tt.Errorf(\"GroupBadges.EditGroupBadge returned error: %v\", err)\n\t}\n\n\twant := &GroupBadge{ID: 2, Name: \"two\", ImageURL: \"NEW_IMAGE\", LinkURL: \"NEW_LINK\", Kind: GroupBadgeKind}\n\tif !reflect.DeepEqual(want, badge) {\n\t\tt.Errorf(\"GroupBadges.EditGroupBadge returned %+v, want %+v\", badge, want)\n\t}\n}\n\nfunc TestRemoveGroupBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/badges/2\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t},\n\t)\n\n\tresp, err := client.GroupBadges.DeleteGroupBadge(1, 2)\n\tif err != nil {\n\t\tt.Errorf(\"GroupBadges.DeleteGroupBadge returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"GroupsBadges.DeleteGroupBadge returned %d, want %d\", got, want)\n\t}\n}\n"
        },
        {
          "name": "group_boards.go",
          "type": "blob",
          "size": 10.23828125,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GroupIssueBoardsService handles communication with the group issue board\n// related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html\ntype GroupIssueBoardsService struct {\n\tclient *Client\n}\n\n// GroupIssueBoard represents a GitLab group issue board.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html\ntype GroupIssueBoard struct {\n\tID        int           `json:\"id\"`\n\tName      string        `json:\"name\"`\n\tGroup     *Group        `json:\"group\"`\n\tMilestone *Milestone    `json:\"milestone\"`\n\tLabels    []*GroupLabel `json:\"labels\"`\n\tLists     []*BoardList  `json:\"lists\"`\n}\n\nfunc (b GroupIssueBoard) String() string {\n\treturn Stringify(b)\n}\n\n// ListGroupIssueBoardsOptions represents the available\n// ListGroupIssueBoards() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#list-all-group-issue-boards-in-a-group\ntype ListGroupIssueBoardsOptions ListOptions\n\n// ListGroupIssueBoards gets a list of all issue boards in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#list-all-group-issue-boards-in-a-group\nfunc (s *GroupIssueBoardsService) ListGroupIssueBoards(gid interface{}, opt *ListGroupIssueBoardsOptions, options ...RequestOptionFunc) ([]*GroupIssueBoard, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*GroupIssueBoard\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// CreateGroupIssueBoardOptions represents the available\n// CreateGroupIssueBoard() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#create-a-group-issue-board\ntype CreateGroupIssueBoardOptions struct {\n\tName *string `url:\"name\" json:\"name\"`\n}\n\n// CreateGroupIssueBoard creates a new issue board.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#create-a-group-issue-board\nfunc (s *GroupIssueBoardsService) CreateGroupIssueBoard(gid interface{}, opt *CreateGroupIssueBoardOptions, options ...RequestOptionFunc) (*GroupIssueBoard, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgib := new(GroupIssueBoard)\n\tresp, err := s.client.Do(req, gib)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gib, resp, nil\n}\n\n// GetGroupIssueBoard gets a single issue board of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#single-group-issue-board\nfunc (s *GroupIssueBoardsService) GetGroupIssueBoard(gid interface{}, board int, options ...RequestOptionFunc) (*GroupIssueBoard, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d\", PathEscape(group), board)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgib := new(GroupIssueBoard)\n\tresp, err := s.client.Do(req, gib)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gib, resp, nil\n}\n\n// UpdateGroupIssueBoardOptions represents a group issue board.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#update-a-group-issue-board\ntype UpdateGroupIssueBoardOptions struct {\n\tName        *string       `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tAssigneeID  *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tMilestoneID *int          `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tLabels      *LabelOptions `url:\"labels,omitempty\" json:\"labels,omitempty\"`\n\tWeight      *int          `url:\"weight,omitempty\" json:\"weight,omitempty\"`\n}\n\n// UpdateIssueBoard updates a single issue board of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#update-a-group-issue-board\nfunc (s *GroupIssueBoardsService) UpdateIssueBoard(gid interface{}, board int, opt *UpdateGroupIssueBoardOptions, options ...RequestOptionFunc) (*GroupIssueBoard, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d\", PathEscape(group), board)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgib := new(GroupIssueBoard)\n\tresp, err := s.client.Do(req, gib)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gib, resp, nil\n}\n\n// DeleteIssueBoard delete a single issue board of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#delete-a-group-issue-board\nfunc (s *GroupIssueBoardsService) DeleteIssueBoard(gid interface{}, board int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d\", PathEscape(group), board)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListGroupIssueBoardListsOptions represents the available\n// ListGroupIssueBoardLists() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#list-group-issue-board-lists\ntype ListGroupIssueBoardListsOptions ListOptions\n\n// ListGroupIssueBoardLists gets a list of the issue board's lists. Does not include\n// backlog and closed lists.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_boards.html#list-group-issue-board-lists\nfunc (s *GroupIssueBoardsService) ListGroupIssueBoardLists(gid interface{}, board int, opt *ListGroupIssueBoardListsOptions, options ...RequestOptionFunc) ([]*BoardList, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d/lists\", PathEscape(group), board)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gbl []*BoardList\n\tresp, err := s.client.Do(req, &gbl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gbl, resp, nil\n}\n\n// GetGroupIssueBoardList gets a single issue board list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#single-group-issue-board-list\nfunc (s *GroupIssueBoardsService) GetGroupIssueBoardList(gid interface{}, board, list int, options ...RequestOptionFunc) (*BoardList, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d/lists/%d\",\n\t\tPathEscape(group),\n\t\tboard,\n\t\tlist,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgbl := new(BoardList)\n\tresp, err := s.client.Do(req, gbl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gbl, resp, nil\n}\n\n// CreateGroupIssueBoardListOptions represents the available\n// CreateGroupIssueBoardList() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#new-group-issue-board-list\ntype CreateGroupIssueBoardListOptions struct {\n\tLabelID *int `url:\"label_id\" json:\"label_id\"`\n}\n\n// CreateGroupIssueBoardList creates a new issue board list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#new-group-issue-board-list\nfunc (s *GroupIssueBoardsService) CreateGroupIssueBoardList(gid interface{}, board int, opt *CreateGroupIssueBoardListOptions, options ...RequestOptionFunc) (*BoardList, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d/lists\", PathEscape(group), board)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgbl := new(BoardList)\n\tresp, err := s.client.Do(req, gbl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gbl, resp, nil\n}\n\n// UpdateGroupIssueBoardListOptions represents the available\n// UpdateGroupIssueBoardList() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#edit-group-issue-board-list\ntype UpdateGroupIssueBoardListOptions struct {\n\tPosition *int `url:\"position\" json:\"position\"`\n}\n\n// UpdateIssueBoardList updates the position of an existing\n// group issue board list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#edit-group-issue-board-list\nfunc (s *GroupIssueBoardsService) UpdateIssueBoardList(gid interface{}, board, list int, opt *UpdateGroupIssueBoardListOptions, options ...RequestOptionFunc) ([]*BoardList, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d/lists/%d\",\n\t\tPathEscape(group),\n\t\tboard,\n\t\tlist,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gbl []*BoardList\n\tresp, err := s.client.Do(req, &gbl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gbl, resp, nil\n}\n\n// DeleteGroupIssueBoardList soft deletes a group issue board list.\n// Only for admins and group owners.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_boards.html#delete-a-group-issue-board-list\nfunc (s *GroupIssueBoardsService) DeleteGroupIssueBoardList(gid interface{}, board, list int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/boards/%d/lists/%d\",\n\t\tPathEscape(group),\n\t\tboard,\n\t\tlist,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_boards_test.go",
          "type": "blob",
          "size": 17.96875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGroupIssueBoardsService_ListGroupIssueBoards(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"group issue board\",\n\t\t\t\t\"group\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"name\": \"Documentcloud\",\n\t\t\t\t  \"web_url\": \"http://example.com/groups/documentcloud\"\n\t\t\t\t},\n\t\t\t\t\"milestone\":   {\n\t\t\t\t  \"id\": 12,\n\t\t\t\t  \"title\": \"10.0\"\n\t\t\t\t},\n\t\t\t\t\"lists\" : [\n\t\t\t\t  {\n\t\t\t\t\t\"id\" : 1,\n\t\t\t\t\t\"label\" : {\n\t\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t\t  \"description\" : null\n\t\t\t\t\t},\n\t\t\t\t\t\"position\" : 1\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"id\" : 2,\n\t\t\t\t\t\"label\" : {\n\t\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t\t  \"description\" : null\n\t\t\t\t\t},\n\t\t\t\t\t\"position\" : 2\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"id\" : 3,\n\t\t\t\t\t\"label\" : {\n\t\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t\t  \"description\" : null\n\t\t\t\t\t},\n\t\t\t\t\t\"position\" : 3\n\t\t\t\t  }\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*GroupIssueBoard{{\n\t\tID:   1,\n\t\tName: \"group issue board\",\n\t\tGroup: &Group{\n\t\t\tID:     5,\n\t\t\tName:   \"Documentcloud\",\n\t\t\tWebURL: \"http://example.com/groups/documentcloud\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          12,\n\t\t\tIID:         0,\n\t\t\tProjectID:   0,\n\t\t\tTitle:       \"10.0\",\n\t\t\tDescription: \"\",\n\t\t},\n\t\tLists: []*BoardList{\n\t\t\t{\n\t\t\t\tID: 1,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:        \"Testing\",\n\t\t\t\t\tColor:       \"#F0AD4E\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 2,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:        \"Ready\",\n\t\t\t\t\tColor:       \"#FF0000\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 3,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:        \"Production\",\n\t\t\t\t\tColor:       \"#FF5F00\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 3,\n\t\t\t},\n\t\t},\n\t}}\n\n\tgibs, resp, err := client.GroupIssueBoards.ListGroupIssueBoards(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gibs)\n\n\tgibs, resp, err = client.GroupIssueBoards.ListGroupIssueBoards(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gibs)\n\n\tgibs, resp, err = client.GroupIssueBoards.ListGroupIssueBoards(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gibs)\n\n\tgibs, resp, err = client.GroupIssueBoards.ListGroupIssueBoards(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gibs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_CreateGroupIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"newboard\",\n\t\t\t\t\"project\": null,\n\t\t\t\t\"lists\" : [],\n\t\t\t\t\"group\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"name\": \"Documentcloud\",\n\t\t\t\t  \"web_url\": \"http://example.com/groups/documentcloud\"\n\t\t\t\t},\n\t\t\t\t\"milestone\": null,\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [],\n\t\t\t\t\"weight\" : null\n\t\t\t  }\n\t\t`)\n\t})\n\n\twant := &GroupIssueBoard{\n\t\tID:   1,\n\t\tName: \"newboard\",\n\t\tGroup: &Group{\n\t\t\tID:     5,\n\t\t\tName:   \"Documentcloud\",\n\t\t\tWebURL: \"http://example.com/groups/documentcloud\",\n\t\t},\n\t\tMilestone: nil,\n\t\tLabels:    []*GroupLabel{},\n\t\tLists:     []*BoardList{},\n\t}\n\n\tgib, resp, err := client.GroupIssueBoards.CreateGroupIssueBoard(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.CreateGroupIssueBoard(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.CreateGroupIssueBoard(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.CreateGroupIssueBoard(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_GetGroupIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"group issue board\",\n\t\t\t\"group\": {\n\t\t\t  \"id\": 5,\n\t\t\t  \"name\": \"Documentcloud\",\n\t\t\t  \"web_url\": \"http://example.com/groups/documentcloud\"\n\t\t\t},\n\t\t\t\"milestone\":   {\n\t\t\t  \"id\": 12,\n\t\t\t  \"title\": \"10.0\"\n\t\t\t},\n\t\t\t\"labels\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\":1749,\n\t\t\t\t\t\"name\":\"my-scope1\",\n\t\t\t\t\t\"description\":null,\n\t\t\t\t\t\"description_html\":\"\",\n\t\t\t\t\t\"text_color\":\"#FFFFFF\",\n\t\t\t\t\t\"color\":\"#6699cc\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\":1747,\n\t\t\t\t\t\"name\":\"my-scope2\",\n\t\t\t\t\t\"description\":null,\n\t\t\t\t\t\"description_html\":\"\",\n\t\t\t\t\t\"text_color\":\"#FFFFFF\",\n\t\t\t\t\t\"color\":\"#FF0000\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"lists\" : [\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 1\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 2,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 2\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 3,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 3\n\t\t\t  }\n\t\t\t]\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &GroupIssueBoard{\n\t\tID:   1,\n\t\tName: \"group issue board\",\n\t\tGroup: &Group{\n\t\t\tID:     5,\n\t\t\tName:   \"Documentcloud\",\n\t\t\tWebURL: \"http://example.com/groups/documentcloud\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          12,\n\t\t\tIID:         0,\n\t\t\tProjectID:   0,\n\t\t\tTitle:       \"10.0\",\n\t\t\tDescription: \"\",\n\t\t},\n\t\tLabels: []*GroupLabel{\n\t\t\t{\n\t\t\t\tID:        1749,\n\t\t\t\tName:      \"my-scope1\",\n\t\t\t\tTextColor: \"#FFFFFF\",\n\t\t\t\tColor:     \"#6699cc\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:        1747,\n\t\t\t\tName:      \"my-scope2\",\n\t\t\t\tTextColor: \"#FFFFFF\",\n\t\t\t\tColor:     \"#FF0000\",\n\t\t\t},\n\t\t},\n\t\tLists: []*BoardList{\n\t\t\t{\n\t\t\t\tID: 1,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:        \"Testing\",\n\t\t\t\t\tColor:       \"#F0AD4E\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 2,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:        \"Ready\",\n\t\t\t\t\tColor:       \"#FF0000\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 3,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tName:        \"Production\",\n\t\t\t\t\tColor:       \"#FF5F00\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 3,\n\t\t\t},\n\t\t},\n\t}\n\n\tgib, resp, err := client.GroupIssueBoards.GetGroupIssueBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.GetGroupIssueBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.GetGroupIssueBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.GetGroupIssueBoard(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_UpdateIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"project\": null,\n\t\t\t\t\"lists\": [],\n\t\t\t\t\"name\": \"new_name\",\n\t\t\t\t\"group\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"name\": \"Documentcloud\",\n\t\t\t\t  \"web_url\": \"http://example.com/groups/documentcloud\"\n\t\t\t\t},\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 44,\n\t\t\t\t  \"iid\": 1,\n\t\t\t\t  \"group_id\": 5,\n\t\t\t\t  \"title\": \"Group Milestone\",\n\t\t\t\t  \"description\": \"Group Milestone Desc\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"web_url\": \"http://example.com/groups/documentcloud/-/milestones/1\"\n\t\t\t\t},\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"labels\": [{\n\t\t\t\t  \"id\": 11,\n\t\t\t\t  \"name\": \"GroupLabel\",\n\t\t\t\t  \"color\": \"#428BCA\",\n\t\t\t\t  \"description\": \"\"\n\t\t\t\t}],\n\t\t\t\t\"weight\": 4\n\t\t\t  }\n\t\t`)\n\t})\n\n\twant := &GroupIssueBoard{\n\t\tID:   1,\n\t\tName: \"new_name\",\n\t\tGroup: &Group{\n\t\t\tID:     5,\n\t\t\tName:   \"Documentcloud\",\n\t\t\tWebURL: \"http://example.com/groups/documentcloud\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          44,\n\t\t\tIID:         1,\n\t\t\tGroupID:     5,\n\t\t\tTitle:       \"Group Milestone\",\n\t\t\tDescription: \"Group Milestone Desc\",\n\t\t\tState:       \"active\",\n\t\t\tWebURL:      \"http://example.com/groups/documentcloud/-/milestones/1\",\n\t\t},\n\t\tLabels: []*GroupLabel{\n\t\t\t{\n\t\t\t\tID:          11,\n\t\t\t\tName:        \"GroupLabel\",\n\t\t\t\tColor:       \"#428BCA\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t},\n\t\tLists: []*BoardList{},\n\t}\n\n\tgib, resp, err := client.GroupIssueBoards.UpdateIssueBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.UpdateIssueBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.UpdateIssueBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupIssueBoards.UpdateIssueBoard(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_DeleteIssueBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.GroupIssueBoards.DeleteIssueBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.GroupIssueBoards.DeleteIssueBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GroupIssueBoards.DeleteIssueBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GroupIssueBoards.DeleteIssueBoard(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_ListGroupIssueBoardLists(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1/lists\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 1\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 2,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 2\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 3,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 3\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*BoardList{\n\t\t{\n\t\t\tID: 1,\n\t\t\tLabel: &Label{\n\t\t\t\tName:        \"Testing\",\n\t\t\t\tColor:       \"#F0AD4E\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t\tPosition: 1,\n\t\t},\n\t\t{\n\t\t\tID: 2,\n\t\t\tLabel: &Label{\n\t\t\t\tName:        \"Ready\",\n\t\t\t\tColor:       \"#FF0000\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t\tPosition: 2,\n\t\t},\n\t\t{\n\t\t\tID: 3,\n\t\t\tLabel: &Label{\n\t\t\t\tName:        \"Production\",\n\t\t\t\tColor:       \"#FF5F00\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t\tPosition: 3,\n\t\t},\n\t}\n\n\tbls, resp, err := client.GroupIssueBoards.ListGroupIssueBoardLists(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bls)\n\n\tbls, resp, err = client.GroupIssueBoards.ListGroupIssueBoardLists(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bls)\n\n\tbls, resp, err = client.GroupIssueBoards.ListGroupIssueBoardLists(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bls)\n\n\tbls, resp, err = client.GroupIssueBoards.ListGroupIssueBoardLists(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bls)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_GetGroupIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1/lists/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\" : 1,\n\t\t\t\"label\" : {\n\t\t\t  \"name\" : \"Testing\",\n\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t  \"description\" : null\n\t\t\t},\n\t\t\t\"position\" : 1\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &BoardList{\n\t\tID: 1,\n\t\tLabel: &Label{\n\t\t\tName:        \"Testing\",\n\t\t\tColor:       \"#F0AD4E\",\n\t\t\tDescription: \"\",\n\t\t},\n\t\tPosition: 1,\n\t}\n\n\tbl, resp, err := client.GroupIssueBoards.GetGroupIssueBoardList(5, 1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.GetGroupIssueBoardList(5.01, 1, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.GetGroupIssueBoardList(5, 1, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.GetGroupIssueBoardList(3, 1, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bl)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_CreateGroupIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1/lists\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 9,\n\t\t\t  \"label\": null,\n\t\t\t  \"position\": 0,\n\t\t\t  \"milestone\": {\n\t\t\t\t\"id\": 7,\n\t\t\t\t\"iid\": 3,\n\t\t\t\t\"group_id\": 12,\n\t\t\t\t\"title\": \"Milestone with due date\",\n\t\t\t\t\"description\": \"\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"web_url\": \"https://gitlab.example.com/groups/issue-reproduce/-/milestones/3\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &BoardList{\n\t\tID:       9,\n\t\tLabel:    nil,\n\t\tPosition: 0,\n\t\tMilestone: &Milestone{\n\t\t\tID:          7,\n\t\t\tIID:         3,\n\t\t\tGroupID:     12,\n\t\t\tTitle:       \"Milestone with due date\",\n\t\t\tDescription: \"\",\n\t\t\tState:       \"active\",\n\t\t\tWebURL:      \"https://gitlab.example.com/groups/issue-reproduce/-/milestones/3\",\n\t\t},\n\t}\n\n\tbl, resp, err := client.GroupIssueBoards.CreateGroupIssueBoardList(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.CreateGroupIssueBoardList(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.CreateGroupIssueBoardList(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.CreateGroupIssueBoardList(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bl)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_UpdateIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1/lists/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 1\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 2,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 2\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 3,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 3\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*BoardList{\n\t\t{\n\t\t\tID: 1,\n\t\t\tLabel: &Label{\n\t\t\t\tName:        \"Testing\",\n\t\t\t\tColor:       \"#F0AD4E\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t\tPosition: 1,\n\t\t},\n\t\t{\n\t\t\tID: 2,\n\t\t\tLabel: &Label{\n\t\t\t\tName:        \"Ready\",\n\t\t\t\tColor:       \"#FF0000\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t\tPosition: 2,\n\t\t},\n\t\t{\n\t\t\tID: 3,\n\t\t\tLabel: &Label{\n\t\t\t\tName:        \"Production\",\n\t\t\t\tColor:       \"#FF5F00\",\n\t\t\t\tDescription: \"\",\n\t\t\t},\n\t\t\tPosition: 3,\n\t\t},\n\t}\n\n\tbl, resp, err := client.GroupIssueBoards.UpdateIssueBoardList(5, 1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.UpdateIssueBoardList(5.01, 1, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.UpdateIssueBoardList(5, 1, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bl)\n\n\tbl, resp, err = client.GroupIssueBoards.UpdateIssueBoardList(3, 1, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bl)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupIssueBoardsService_DeleteGroupIssueBoardList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/boards/1/lists/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.GroupIssueBoards.DeleteGroupIssueBoardList(5, 1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.GroupIssueBoards.DeleteGroupIssueBoardList(5.01, 1, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GroupIssueBoards.DeleteGroupIssueBoardList(5, 1, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GroupIssueBoards.DeleteGroupIssueBoardList(3, 1, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "group_clusters.go",
          "type": "blob",
          "size": 7.8251953125,
          "content": "//\n// Copyright 2021, Paul Shoemaker\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupClustersService handles communication with the\n// group clusters related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html\ntype GroupClustersService struct {\n\tclient *Client\n}\n\n// GroupCluster represents a GitLab Group Cluster.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_clusters.html\ntype GroupCluster struct {\n\tID                 int                 `json:\"id\"`\n\tName               string              `json:\"name\"`\n\tDomain             string              `json:\"domain\"`\n\tCreatedAt          *time.Time          `json:\"created_at\"`\n\tManaged            bool                `json:\"managed\"`\n\tEnabled            bool                `json:\"enabled\"`\n\tProviderType       string              `json:\"provider_type\"`\n\tPlatformType       string              `json:\"platform_type\"`\n\tEnvironmentScope   string              `json:\"environment_scope\"`\n\tClusterType        string              `json:\"cluster_type\"`\n\tUser               *User               `json:\"user\"`\n\tPlatformKubernetes *PlatformKubernetes `json:\"platform_kubernetes\"`\n\tManagementProject  *ManagementProject  `json:\"management_project\"`\n\tGroup              *Group              `json:\"group\"`\n}\n\nfunc (v GroupCluster) String() string {\n\treturn Stringify(v)\n}\n\n// ListClusters gets a list of all clusters in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#list-group-clusters\nfunc (s *GroupClustersService) ListClusters(pid interface{}, options ...RequestOptionFunc) ([]*GroupCluster, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/clusters\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pcs []*GroupCluster\n\tresp, err := s.client.Do(req, &pcs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pcs, resp, nil\n}\n\n// GetCluster gets a cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#get-a-single-group-cluster\nfunc (s *GroupClustersService) GetCluster(pid interface{}, cluster int, options ...RequestOptionFunc) (*GroupCluster, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/clusters/%d\", PathEscape(group), cluster)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgc := new(GroupCluster)\n\tresp, err := s.client.Do(req, &gc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gc, resp, nil\n}\n\n// AddGroupClusterOptions represents the available AddCluster() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#add-existing-cluster-to-group\ntype AddGroupClusterOptions struct {\n\tName                *string                            `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDomain              *string                            `url:\"domain,omitempty\" json:\"domain,omitempty\"`\n\tManagementProjectID *string                            `url:\"management_project_id,omitempty\" json:\"management_project_id,omitempty\"`\n\tEnabled             *bool                              `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\tManaged             *bool                              `url:\"managed,omitempty\" json:\"managed,omitempty\"`\n\tEnvironmentScope    *string                            `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tPlatformKubernetes  *AddGroupPlatformKubernetesOptions `url:\"platform_kubernetes_attributes,omitempty\" json:\"platform_kubernetes_attributes,omitempty\"`\n}\n\n// AddGroupPlatformKubernetesOptions represents the available PlatformKubernetes options for adding.\ntype AddGroupPlatformKubernetesOptions struct {\n\tAPIURL            *string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tToken             *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tCaCert            *string `url:\"ca_cert,omitempty\" json:\"ca_cert,omitempty\"`\n\tNamespace         *string `url:\"namespace,omitempty\" json:\"namespace,omitempty\"`\n\tAuthorizationType *string `url:\"authorization_type,omitempty\" json:\"authorization_type,omitempty\"`\n}\n\n// AddCluster adds an existing cluster to the group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#add-existing-cluster-to-group\nfunc (s *GroupClustersService) AddCluster(pid interface{}, opt *AddGroupClusterOptions, options ...RequestOptionFunc) (*GroupCluster, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/clusters/user\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgc := new(GroupCluster)\n\tresp, err := s.client.Do(req, gc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gc, resp, nil\n}\n\n// EditGroupClusterOptions represents the available EditCluster() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#edit-group-cluster\ntype EditGroupClusterOptions struct {\n\tName                *string                             `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDomain              *string                             `url:\"domain,omitempty\" json:\"domain,omitempty\"`\n\tEnvironmentScope    *string                             `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tPlatformKubernetes  *EditGroupPlatformKubernetesOptions `url:\"platform_kubernetes_attributes,omitempty\" json:\"platform_kubernetes_attributes,omitempty\"`\n\tManagementProjectID *string                             `url:\"management_project_id,omitempty\" json:\"management_project_id,omitempty\"`\n}\n\n// EditGroupPlatformKubernetesOptions represents the available PlatformKubernetes options for editing.\ntype EditGroupPlatformKubernetesOptions struct {\n\tAPIURL *string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tToken  *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tCaCert *string `url:\"ca_cert,omitempty\" json:\"ca_cert,omitempty\"`\n}\n\n// EditCluster updates an existing group cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#edit-group-cluster\nfunc (s *GroupClustersService) EditCluster(pid interface{}, cluster int, opt *EditGroupClusterOptions, options ...RequestOptionFunc) (*GroupCluster, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/clusters/%d\", PathEscape(group), cluster)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgc := new(GroupCluster)\n\tresp, err := s.client.Do(req, gc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gc, resp, nil\n}\n\n// DeleteCluster deletes an existing group cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_clusters.html#delete-group-cluster\nfunc (s *GroupClustersService) DeleteCluster(pid interface{}, cluster int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/clusters/%d\", PathEscape(group), cluster)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_clusters_test.go",
          "type": "blob",
          "size": 12.779296875,
          "content": "//\n// Copyright 2021, Paul Shoemaker\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestGroupListClusters(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/26/clusters\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\":18,\n\t\t\t  \"name\":\"cluster-1\",\n\t\t\t  \"domain\":\"example.com\",\n\t\t\t  \"created_at\":\"2019-01-02T20:18:12.563Z\",\n\t\t\t  \"managed\": true,\n\t\t\t  \"enabled\": true,\n\t\t\t  \"provider_type\":\"user\",\n\t\t\t  \"platform_type\":\"kubernetes\",\n\t\t\t  \"environment_scope\":\"*\",\n\t\t\t  \"cluster_type\":\"group_type\",\n\t\t\t  \"user\":\n\t\t\t  {\n\t\t\t\t\"id\":1,\n\t\t\t\t\"name\":\"Administrator\",\n\t\t\t\t\"username\":\"root\",\n\t\t\t\t\"state\":\"active\",\n\t\t\t\t\"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\t\t\"web_url\":\"https://gitlab.example.com/root\"\n\t\t\t  },\n\t\t\t  \"platform_kubernetes\":\n\t\t\t  {\n\t\t\t\t\"api_url\":\"https://104.197.68.152\",\n\t\t\t\t\"authorization_type\":\"rbac\",\n\t\t\t    \"ca_cert\":\"-----BEGIN CERTIFICATE-----\\r\\nAAAAA\\r\\n-----END CERTIFICATE-----\"\n\t\t\t  },\n\t\t\t  \"management_project\":\n\t\t\t  {\n\t\t\t\t\"id\":2,\n\t\t\t\t\"description\": \"sdhfgnbsdjfhg\",\n\t\t\t\t\"name\":\"project2\",\n\t\t\t\t\"name_with_namespace\":\"John Doe8 / project2\",\n\t\t\t\t\"path\":\"project2\",\n\t\t\t\t\"path_with_namespace\":\"namespace2/project2\",\n\t\t\t\t\"created_at\":\"2019-10-11T02:55:54.138Z\"\n\t\t\t  }\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\":19,\n\t\t\t  \"name\":\"cluster-2\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\tclusters, _, err := client.GroupCluster.ListClusters(26)\n\tif err != nil {\n\t\tt.Errorf(\"GroupCluster.ListClusters returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2019-01-02T20:18:12.563Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\tcreatedAt2, err := time.Parse(timeLayout, \"2019-10-11T02:55:54.138Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := []*GroupCluster{\n\t\t{\n\t\t\tID:               18,\n\t\t\tName:             \"cluster-1\",\n\t\t\tDomain:           \"example.com\",\n\t\t\tCreatedAt:        &createdAt,\n\t\t\tManaged:          true,\n\t\t\tEnabled:          true,\n\t\t\tProviderType:     \"user\",\n\t\t\tPlatformType:     \"kubernetes\",\n\t\t\tEnvironmentScope: \"*\",\n\t\t\tClusterType:      \"group_type\",\n\t\t\tUser: &User{\n\t\t\t\tID:        1,\n\t\t\t\tName:      \"Administrator\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\t},\n\t\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\t\tAPIURL:            \"https://104.197.68.152\",\n\t\t\t\tAuthorizationType: \"rbac\",\n\t\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----\\r\\nAAAAA\\r\\n-----END CERTIFICATE-----\",\n\t\t\t},\n\t\t\tManagementProject: &ManagementProject{\n\t\t\t\tID:                2,\n\t\t\t\tDescription:       \"sdhfgnbsdjfhg\",\n\t\t\t\tName:              \"project2\",\n\t\t\t\tNameWithNamespace: \"John Doe8 / project2\",\n\t\t\t\tPath:              \"project2\",\n\t\t\t\tPathWithNamespace: \"namespace2/project2\",\n\t\t\t\tCreatedAt:         &createdAt2,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:   19,\n\t\t\tName: \"cluster-2\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, clusters) {\n\t\tt.Errorf(\"GroupCluster.ListClusters returned %+v, want %+v\", clusters, want)\n\t}\n}\n\nfunc TestGetGroupCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/26/clusters/18\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"id\":18,\n\t\t\t\"name\":\"cluster-1\",\n\t\t\t\"domain\":\"example.com\",\n\t\t\t\"created_at\":\"2019-01-02T20:18:12.563Z\",\n\t\t\t\"managed\": true,\n\t\t\t\"enabled\": true,\n\t\t\t\"provider_type\":\"user\",\n\t\t\t\"platform_type\":\"kubernetes\",\n\t\t\t\"environment_scope\":\"*\",\n\t\t\t\"cluster_type\":\"group_type\",\n\t\t\t\"user\":\n\t\t\t{\n\t\t\t  \"id\":1,\n\t\t\t  \"name\":\"Administrator\",\n\t\t\t  \"username\":\"root\",\n\t\t\t  \"state\":\"active\",\n\t\t\t  \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\t  \"web_url\":\"https://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"platform_kubernetes\":\n\t\t\t{\n\t\t\t  \"api_url\":\"https://104.197.68.152\",\n\t\t\t  \"authorization_type\":\"rbac\",\n\t\t\t  \"ca_cert\":\"-----BEGIN CERTIFICATE-----\\r\\nAAAAA\\r\\n-----END CERTIFICATE-----\"\n\t\t\t},\n\t\t\t\"management_project\":\n\t\t\t{\n\t\t\t  \"id\":2,\n\t\t\t  \"description\": \"skjdfgsdfg\",\n\t\t\t  \"name\":\"project2\",\n\t\t\t  \"name_with_namespace\":\"John Doe8 / project2\",\n\t\t\t  \"path\":\"project2\",\n\t\t\t  \"path_with_namespace\":\"namespace2/project2\",\n\t\t\t  \"created_at\":\"2019-10-11T02:55:54.138Z\"\n\t\t\t},\n\t\t\t\"group\":\n\t\t\t{\n\t\t\t  \"id\":26,\n\t\t\t  \"name\":\"group-with-clusters-api\",\n\t\t\t  \"web_url\":\"https://gitlab.example.com/group-with-clusters-api\"\n\t\t\t}\n\t\t  }`)\n\t})\n\n\tcluster, _, err := client.GroupCluster.GetCluster(26, 18)\n\tif err != nil {\n\t\tt.Errorf(\"GroupCluster.GetCluster returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2019-01-02T20:18:12.563Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\tcreatedAt2, err := time.Parse(timeLayout, \"2019-10-11T02:55:54.138Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &GroupCluster{\n\t\tID:               18,\n\t\tName:             \"cluster-1\",\n\t\tDomain:           \"example.com\",\n\t\tCreatedAt:        &createdAt,\n\t\tManaged:          true,\n\t\tEnabled:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"group_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://104.197.68.152\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----\\r\\nAAAAA\\r\\n-----END CERTIFICATE-----\",\n\t\t},\n\t\tManagementProject: &ManagementProject{\n\t\t\tID:                2,\n\t\t\tDescription:       \"skjdfgsdfg\",\n\t\t\tName:              \"project2\",\n\t\t\tNameWithNamespace: \"John Doe8 / project2\",\n\t\t\tPath:              \"project2\",\n\t\t\tPathWithNamespace: \"namespace2/project2\",\n\t\t\tCreatedAt:         &createdAt2,\n\t\t},\n\t\tGroup: &Group{\n\t\t\tID:     26,\n\t\t\tName:   \"group-with-clusters-api\",\n\t\t\tWebURL: \"https://gitlab.example.com/group-with-clusters-api\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, cluster) {\n\t\tt.Errorf(\"GroupCluster.GetCluster returned %+v, want %+v\", cluster, want)\n\t}\n}\n\nfunc TestAddGroupCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/26/clusters/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"id\":24,\n\t\t\t\"name\":\"cluster-5\",\n\t\t\t\"created_at\":\"2019-01-03T21:53:40.610Z\",\n\t\t\t\"managed\": true,\n\t\t\t\"enabled\": true,\n\t\t\t\"provider_type\":\"user\",\n\t\t\t\"platform_type\":\"kubernetes\",\n\t\t\t\"environment_scope\":\"*\",\n\t\t\t\"cluster_type\":\"group_type\",\n\t\t\t\"user\":\n\t\t\t{\n\t\t\t  \"id\":1,\n\t\t\t  \"name\":\"Administrator\",\n\t\t\t  \"username\":\"root\",\n\t\t\t  \"state\":\"active\",\n\t\t\t  \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\t  \"web_url\":\"https://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"platform_kubernetes\":\n\t\t\t{\n\t\t\t  \"api_url\":\"https://35.111.51.20\",\n\t\t\t  \"authorization_type\":\"rbac\",\n\t\t\t  \"ca_cert\":\"-----BEGIN CERTIFICATE-----\\r\\nAAAAA\\r\\n-----END CERTIFICATE-----\"\n\t\t\t},\n\t\t\t\"management_project\":null,\n\t\t\t\"group\":\n\t\t\t{\n\t\t\t  \"id\":26,\n\t\t\t  \"name\":\"group-with-clusters-api\",\n\t\t\t  \"web_url\":\"https://gitlab.example.com/root/group-with-clusters-api\"\n\t\t\t}\n\t\t  }`)\n\t})\n\n\tcluster, _, err := client.GroupCluster.AddCluster(26, &AddGroupClusterOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupCluster.AddCluster returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2019-01-03T21:53:40.610Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &GroupCluster{\n\t\tID:               24,\n\t\tName:             \"cluster-5\",\n\t\tCreatedAt:        &createdAt,\n\t\tManaged:          true,\n\t\tEnabled:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"group_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://35.111.51.20\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----\\r\\nAAAAA\\r\\n-----END CERTIFICATE-----\",\n\t\t},\n\t\tManagementProject: nil,\n\t\tGroup: &Group{\n\t\t\tID:     26,\n\t\t\tName:   \"group-with-clusters-api\",\n\t\t\tWebURL: \"https://gitlab.example.com/root/group-with-clusters-api\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, cluster) {\n\t\tt.Errorf(\"GroupCluster.AddCluster returned %+v, want %+v\", cluster, want)\n\t}\n}\n\nfunc TestEditGroupCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/26/clusters/24\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"id\":24,\n\t\t\t\"name\":\"new-cluster-name\",\n\t\t\t\"domain\":\"new-domain.com\",\n\t\t\t\"created_at\":\"2019-01-03T21:53:40.610Z\",\n\t\t\t\"managed\": true,\n\t\t\t\"enabled\": true,\n\t\t\t\"provider_type\":\"user\",\n\t\t\t\"platform_type\":\"kubernetes\",\n\t\t\t\"environment_scope\":\"*\",\n\t\t\t\"cluster_type\":\"group_type\",\n\t\t\t\"user\":\n\t\t\t{\n\t\t\t  \"id\":1,\n\t\t\t  \"name\":\"Administrator\",\n\t\t\t  \"username\":\"root\",\n\t\t\t  \"state\":\"active\",\n\t\t\t  \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\t  \"web_url\":\"https://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"platform_kubernetes\":\n\t\t\t{\n\t\t\t  \"api_url\":\"https://new-api-url.com\",\n\t\t\t  \"authorization_type\":\"rbac\"\n\t\t\t},\n\t\t\t\"management_project\":\n\t\t\t{\n\t\t\t  \"id\":2,\n\t\t\t  \"description\":\"sjdkfngjkdsfngdfgndfg\",\n\t\t\t  \"name\":\"project2\",\n\t\t\t  \"name_with_namespace\":\"John Doe8 / project2\",\n\t\t\t  \"path\":\"project2\",\n\t\t\t  \"path_with_namespace\":\"namespace2/project2\",\n\t\t\t  \"created_at\":\"2019-10-11T02:55:54.138Z\"\n\t\t\t},\n\t\t\t\"group\":\n\t\t\t{\n\t\t\t  \"id\":26,\n\t\t\t  \"name\":\"group-with-clusters-api\",\n\t\t\t  \"web_url\":\"https://gitlab.example.com/group-with-clusters-api\"\n\t\t\t}\n\t\t  }`)\n\t})\n\n\tname := \"new-cluster-name\"\n\tdomain := \"new-domain.com\"\n\tenviromentScope := \"*\"\n\tapiURL := \"https://new-api-url.com\"\n\topt := &EditGroupClusterOptions{\n\t\tName:             &name,\n\t\tDomain:           &domain,\n\t\tEnvironmentScope: &enviromentScope,\n\t\tPlatformKubernetes: &EditGroupPlatformKubernetesOptions{\n\t\t\tAPIURL: &apiURL,\n\t\t},\n\t}\n\tcluster, _, err := client.GroupCluster.EditCluster(26, 24, opt)\n\tif err != nil {\n\t\tt.Errorf(\"GroupCluster.EditCluster returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(timeLayout, \"2019-01-03T21:53:40.610Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\tcreatedAt2, err := time.Parse(timeLayout, \"2019-10-11T02:55:54.138Z\")\n\tif err != nil {\n\t\tt.Errorf(\"DeployKeys.ListAllDeployKeys returned an error while parsing time: %v\", err)\n\t}\n\n\twant := &GroupCluster{\n\t\tID:               24,\n\t\tName:             \"new-cluster-name\",\n\t\tDomain:           \"new-domain.com\",\n\t\tCreatedAt:        &createdAt,\n\t\tManaged:          true,\n\t\tEnabled:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"group_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/4249f4df72b..\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://new-api-url.com\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t},\n\t\tManagementProject: &ManagementProject{\n\t\t\tID:                2,\n\t\t\tDescription:       \"sjdkfngjkdsfngdfgndfg\",\n\t\t\tName:              \"project2\",\n\t\t\tNameWithNamespace: \"John Doe8 / project2\",\n\t\t\tPath:              \"project2\",\n\t\t\tPathWithNamespace: \"namespace2/project2\",\n\t\t\tCreatedAt:         &createdAt2,\n\t\t},\n\t\tGroup: &Group{\n\t\t\tID:     26,\n\t\t\tName:   \"group-with-clusters-api\",\n\t\t\tWebURL: \"https://gitlab.example.com/group-with-clusters-api\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, cluster) {\n\t\tt.Errorf(\"GroupCluster.EditCluster returned %+v, want %+v\", cluster, want)\n\t}\n}\n\nfunc TestDeleteGroupCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/26/clusters/23\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.GroupCluster.DeleteCluster(26, 23)\n\tif err != nil {\n\t\tt.Errorf(\"GroupCluster.DeleteCluster returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "group_epic_boards.go",
          "type": "blob",
          "size": 2.9208984375,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GroupEpicBoardsService handles communication with the group epic board\n// related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_epic_boards.html\ntype GroupEpicBoardsService struct {\n\tclient *Client\n}\n\n// GroupEpicBoard represents a GitLab group epic board.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_epic_boards.html\ntype GroupEpicBoard struct {\n\tID     int             `json:\"id\"`\n\tName   string          `json:\"name\"`\n\tGroup  *Group          `json:\"group\"`\n\tLabels []*LabelDetails `json:\"labels\"`\n\tLists  []*BoardList    `json:\"lists\"`\n}\n\nfunc (b GroupEpicBoard) String() string {\n\treturn Stringify(b)\n}\n\n// ListGroupEpicBoardsOptions represents the available\n// ListGroupEpicBoards() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_epic_boards.html#list-all-epic-boards-in-a-group\ntype ListGroupEpicBoardsOptions ListOptions\n\n// ListGroupEpicBoards gets a list of all epic boards in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_epic_boards.html#list-all-epic-boards-in-a-group\nfunc (s *GroupEpicBoardsService) ListGroupEpicBoards(gid interface{}, opt *ListGroupEpicBoardsOptions, options ...RequestOptionFunc) ([]*GroupEpicBoard, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epic_boards\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*GroupEpicBoard\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// GetGroupEpicBoard gets a single epic board of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_epic_boards.html#single-group-epic-board\nfunc (s *GroupEpicBoardsService) GetGroupEpicBoard(gid interface{}, board int, options ...RequestOptionFunc) (*GroupEpicBoard, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epic_boards/%d\", PathEscape(group), board)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgib := new(GroupEpicBoard)\n\tresp, err := s.client.Do(req, gib)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gib, resp, nil\n}\n"
        },
        {
          "name": "group_epic_boards_test.go",
          "type": "blob",
          "size": 5.724609375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGroupEpicBoardsService_ListGroupEpicBoards(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epic_boards\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"group epic board\",\n\t\t\t  \"group\": {\n\t\t\t\t\"id\": 5,\n\t\t\t\t\"name\": \"Documentcloud\",\n\t\t\t\t\"web_url\": \"http://example.com/groups/documentcloud\"\n\t\t\t  },\n\t\t\t  \"hide_backlog_list\": false,\n\t\t\t  \"hide_closed_list\": false,\n\t\t\t  \"labels\": [\n\t\t\t\t{\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Board Label\",\n\t\t\t\t  \"color\": \"#c21e56\",\n\t\t\t\t  \"group_id\": 5,\n\t\t\t\t  \"description\": \"label applied to the epic board\"\n\t\t\t\t}\n\t\t\t  ],\n\t\t\t  \"lists\": [\n\t\t\t\t{\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"label\": {\n\t\t\t\t\t\"id\": 69,\n\t\t\t\t\t\"name\": \"Testing\",\n\t\t\t\t\t\"color\": \"#F0AD4E\",\n\t\t\t\t\t\"description\": null\n\t\t\t\t  },\n\t\t\t\t  \"position\": 1,\n\t\t\t\t  \"list_type\": \"label\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t  \"id\": 2,\n\t\t\t\t  \"label\": {\n\t\t\t\t\t\"id\": 70,\n\t\t\t\t\t\"name\": \"Ready\",\n\t\t\t\t\t\"color\": \"#FF0000\",\n\t\t\t\t\t\"description\": null\n\t\t\t\t  },\n\t\t\t\t  \"position\": 2,\n\t\t\t\t  \"list_type\": \"label\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t  \"id\": 3,\n\t\t\t\t  \"label\": {\n\t\t\t\t\t\"id\": 71,\n\t\t\t\t\t\"name\": \"Production\",\n\t\t\t\t\t\"color\": \"#FF5F00\",\n\t\t\t\t\t\"description\": null\n\t\t\t\t  },\n\t\t\t\t  \"position\": 3,\n\t\t\t\t  \"list_type\": \"label\"\n\t\t\t\t}\n\t\t\t  ]\n\t\t\t}\n\t\t  ]\t\t  \n\t\t`)\n\t})\n\n\twant := []*GroupEpicBoard{{\n\t\tID:   1,\n\t\tName: \"group epic board\",\n\t\tGroup: &Group{\n\t\t\tID:     5,\n\t\t\tName:   \"Documentcloud\",\n\t\t\tWebURL: \"http://example.com/groups/documentcloud\",\n\t\t},\n\t\tLabels: []*LabelDetails{\n\t\t\t{\n\t\t\t\tID:          1,\n\t\t\t\tName:        \"Board Label\",\n\t\t\t\tColor:       \"#c21e56\",\n\t\t\t\tDescription: \"label applied to the epic board\",\n\t\t\t},\n\t\t},\n\t\tLists: []*BoardList{\n\t\t\t{\n\t\t\t\tID: 1,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tID:          69,\n\t\t\t\t\tName:        \"Testing\",\n\t\t\t\t\tColor:       \"#F0AD4E\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 2,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tID:          70,\n\t\t\t\t\tName:        \"Ready\",\n\t\t\t\t\tColor:       \"#FF0000\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 3,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tID:          71,\n\t\t\t\t\tName:        \"Production\",\n\t\t\t\t\tColor:       \"#FF5F00\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 3,\n\t\t\t},\n\t\t},\n\t}}\n\n\tgibs, resp, err := client.GroupEpicBoards.ListGroupEpicBoards(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gibs)\n\n\tgibs, resp, err = client.GroupEpicBoards.ListGroupEpicBoards(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gibs)\n\n\tgibs, resp, err = client.GroupEpicBoards.ListGroupEpicBoards(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gibs)\n\n\tgibs, resp, err = client.GroupEpicBoards.ListGroupEpicBoards(3, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gibs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupEpicBoardsService_GetGroupEpicBoard(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/epic_boards/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"group epic board\",\n\t\t\t\"group\": {\n\t\t\t  \"id\": 5,\n\t\t\t  \"name\": \"Documentcloud\",\n\t\t\t  \"web_url\": \"http://example.com/groups/documentcloud\"\n\t\t\t},\n\t\t\t\"labels\": [\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Board Label\",\n\t\t\t\t\"color\": \"#c21e56\",\n\t\t\t\t\"group_id\": 5,\n\t\t\t\t\"description\": \"label applied to the epic board\"\n\t\t\t  }\n\t\t\t],\n\t\t\t\"lists\" : [\n\t\t\t  {\n\t\t\t\t\"id\" : 1,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"id\": 69,\n\t\t\t\t  \"name\" : \"Testing\",\n\t\t\t\t  \"color\" : \"#F0AD4E\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 1,\n\t\t\t\t\"list_type\": \"label\"\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 2,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"id\": 70,\n\t\t\t\t  \"name\" : \"Ready\",\n\t\t\t\t  \"color\" : \"#FF0000\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 2,\n\t\t\t\t\"list_type\": \"label\"\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"id\" : 3,\n\t\t\t\t\"label\" : {\n\t\t\t\t  \"id\": 71,\n\t\t\t\t  \"name\" : \"Production\",\n\t\t\t\t  \"color\" : \"#FF5F00\",\n\t\t\t\t  \"description\" : null\n\t\t\t\t},\n\t\t\t\t\"position\" : 3,\n\t\t\t\t\"list_type\": \"label\"\n\t\t\t  }\n\t\t\t]\n\t\t  }\t\t\n\t\t`)\n\t})\n\n\twant := &GroupEpicBoard{\n\t\tID:   1,\n\t\tName: \"group epic board\",\n\t\tGroup: &Group{\n\t\t\tID:     5,\n\t\t\tName:   \"Documentcloud\",\n\t\t\tWebURL: \"http://example.com/groups/documentcloud\",\n\t\t},\n\t\tLabels: []*LabelDetails{\n\t\t\t{\n\t\t\t\tID:          1,\n\t\t\t\tName:        \"Board Label\",\n\t\t\t\tColor:       \"#c21e56\",\n\t\t\t\tDescription: \"label applied to the epic board\",\n\t\t\t},\n\t\t},\n\t\tLists: []*BoardList{\n\t\t\t{\n\t\t\t\tID: 1,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tID:          69,\n\t\t\t\t\tName:        \"Testing\",\n\t\t\t\t\tColor:       \"#F0AD4E\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 1,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 2,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tID:          70,\n\t\t\t\t\tName:        \"Ready\",\n\t\t\t\t\tColor:       \"#FF0000\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 2,\n\t\t\t},\n\t\t\t{\n\t\t\t\tID: 3,\n\t\t\t\tLabel: &Label{\n\t\t\t\t\tID:          71,\n\t\t\t\t\tName:        \"Production\",\n\t\t\t\t\tColor:       \"#FF5F00\",\n\t\t\t\t\tDescription: \"\",\n\t\t\t\t},\n\t\t\t\tPosition: 3,\n\t\t\t},\n\t\t},\n\t}\n\n\tgib, resp, err := client.GroupEpicBoards.GetGroupEpicBoard(5, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gib)\n\n\tgib, resp, err = client.GroupEpicBoards.GetGroupEpicBoard(5.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupEpicBoards.GetGroupEpicBoard(5, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gib)\n\n\tgib, resp, err = client.GroupEpicBoards.GetGroupEpicBoard(3, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gib)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "group_hooks.go",
          "type": "blob",
          "size": 12.8193359375,
          "content": "//\n// Copyright 2021, Eric Stevens\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupHook represents a GitLab group hook.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#list-group-hooks\ntype GroupHook struct {\n\tID                        int                 `json:\"id\"`\n\tURL                       string              `json:\"url\"`\n\tGroupID                   int                 `json:\"group_id\"`\n\tPushEvents                bool                `json:\"push_events\"`\n\tPushEventsBranchFilter    string              `json:\"push_events_branch_filter\"`\n\tIssuesEvents              bool                `json:\"issues_events\"`\n\tConfidentialIssuesEvents  bool                `json:\"confidential_issues_events\"`\n\tConfidentialNoteEvents    bool                `json:\"confidential_note_events\"`\n\tMergeRequestsEvents       bool                `json:\"merge_requests_events\"`\n\tTagPushEvents             bool                `json:\"tag_push_events\"`\n\tNoteEvents                bool                `json:\"note_events\"`\n\tJobEvents                 bool                `json:\"job_events\"`\n\tPipelineEvents            bool                `json:\"pipeline_events\"`\n\tWikiPageEvents            bool                `json:\"wiki_page_events\"`\n\tDeploymentEvents          bool                `json:\"deployment_events\"`\n\tReleasesEvents            bool                `json:\"releases_events\"`\n\tSubGroupEvents            bool                `json:\"subgroup_events\"`\n\tMemberEvents              bool                `json:\"member_events\"`\n\tEnableSSLVerification     bool                `json:\"enable_ssl_verification\"`\n\tAlertStatus               string              `json:\"alert_status\"`\n\tCreatedAt                 *time.Time          `json:\"created_at\"`\n\tCustomWebhookTemplate     string              `json:\"custom_webhook_template\"`\n\tResourceAccessTokenEvents bool                `json:\"resource_access_token_events\"`\n\tCustomHeaders             []*HookCustomHeader `url:\"custom_headers,omitempty\" json:\"custom_headers,omitempty\"`\n}\n\n// ListGroupHooksOptions represents the available ListGroupHooks() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#list-group-hooks\ntype ListGroupHooksOptions ListOptions\n\n// ListGroupHooks gets a list of group hooks.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#list-group-hooks\nfunc (s *GroupsService) ListGroupHooks(gid interface{}, opt *ListGroupHooksOptions, options ...RequestOptionFunc) ([]*GroupHook, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tvar gh []*GroupHook\n\tresp, err := s.client.Do(req, &gh)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gh, resp, nil\n}\n\n// GetGroupHook gets a specific hook for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#get-group-hook\nfunc (s *GroupsService) GetGroupHook(pid interface{}, hook int, options ...RequestOptionFunc) (*GroupHook, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks/%d\", PathEscape(group), hook)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgh := new(GroupHook)\n\tresp, err := s.client.Do(req, gh)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gh, resp, nil\n}\n\n// AddGroupHookOptions represents the available AddGroupHook() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#add-group-hook\ntype AddGroupHookOptions struct {\n\tURL                       *string              `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tPushEvents                *bool                `url:\"push_events,omitempty\"  json:\"push_events,omitempty\"`\n\tPushEventsBranchFilter    *string              `url:\"push_events_branch_filter,omitempty\"  json:\"push_events_branch_filter,omitempty\"`\n\tIssuesEvents              *bool                `url:\"issues_events,omitempty\"  json:\"issues_events,omitempty\"`\n\tConfidentialIssuesEvents  *bool                `url:\"confidential_issues_events,omitempty\"  json:\"confidential_issues_events,omitempty\"`\n\tConfidentialNoteEvents    *bool                `url:\"confidential_note_events,omitempty\"  json:\"confidential_note_events,omitempty\"`\n\tMergeRequestsEvents       *bool                `url:\"merge_requests_events,omitempty\"  json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents             *bool                `url:\"tag_push_events,omitempty\"  json:\"tag_push_events,omitempty\"`\n\tNoteEvents                *bool                `url:\"note_events,omitempty\"  json:\"note_events,omitempty\"`\n\tJobEvents                 *bool                `url:\"job_events,omitempty\"  json:\"job_events,omitempty\"`\n\tPipelineEvents            *bool                `url:\"pipeline_events,omitempty\"  json:\"pipeline_events,omitempty\"`\n\tWikiPageEvents            *bool                `url:\"wiki_page_events,omitempty\"  json:\"wiki_page_events,omitempty\"`\n\tDeploymentEvents          *bool                `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tReleasesEvents            *bool                `url:\"releases_events,omitempty\" json:\"releases_events,omitempty\"`\n\tSubGroupEvents            *bool                `url:\"subgroup_events,omitempty\" json:\"subgroup_events,omitempty\"`\n\tMemberEvents              *bool                `url:\"member_events,omitempty\" json:\"member_events,omitempty\"`\n\tEnableSSLVerification     *bool                `url:\"enable_ssl_verification,omitempty\"  json:\"enable_ssl_verification,omitempty\"`\n\tToken                     *string              `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tResourceAccessTokenEvents *bool                `url:\"resource_access_token_events,omitempty\" json:\"resource_access_token_events,omitempty\"`\n\tCustomWebhookTemplate     *string              `url:\"custom_webhook_template,omitempty\" json:\"custom_webhook_template,omitempty\"`\n\tCustomHeaders             *[]*HookCustomHeader `url:\"custom_headers,omitempty\" json:\"custom_headers,omitempty\"`\n}\n\n// AddGroupHook create a new group scoped webhook.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#add-group-hook\nfunc (s *GroupsService) AddGroupHook(gid interface{}, opt *AddGroupHookOptions, options ...RequestOptionFunc) (*GroupHook, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgh := new(GroupHook)\n\tresp, err := s.client.Do(req, gh)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gh, resp, nil\n}\n\n// EditGroupHookOptions represents the available EditGroupHook() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#edit-group-hook\ntype EditGroupHookOptions struct {\n\tURL                       *string              `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tPushEvents                *bool                `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tPushEventsBranchFilter    *string              `url:\"push_events_branch_filter,omitempty\"  json:\"push_events_branch_filter,omitempty\"`\n\tIssuesEvents              *bool                `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tConfidentialIssuesEvents  *bool                `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tConfidentialNoteEvents    *bool                `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tMergeRequestsEvents       *bool                `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents             *bool                `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tNoteEvents                *bool                `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tJobEvents                 *bool                `url:\"job_events,omitempty\" json:\"job_events,omitempty\"`\n\tPipelineEvents            *bool                `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tWikiPageEvents            *bool                `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n\tDeploymentEvents          *bool                `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tReleasesEvents            *bool                `url:\"releases_events,omitempty\" json:\"releases_events,omitempty\"`\n\tSubGroupEvents            *bool                `url:\"subgroup_events,omitempty\" json:\"subgroup_events,omitempty\"`\n\tMemberEvents              *bool                `url:\"member_events,omitempty\" json:\"member_events,omitempty\"`\n\tEnableSSLVerification     *bool                `url:\"enable_ssl_verification,omitempty\" json:\"enable_ssl_verification,omitempty\"`\n\tToken                     *string              `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tResourceAccessTokenEvents *bool                `url:\"resource_access_token_events,omitempty\" json:\"resource_access_token_events,omitempty\"`\n\tCustomWebhookTemplate     *string              `url:\"custom_webhook_template,omitempty\" json:\"custom_webhook_template,omitempty\"`\n\tCustomHeaders             *[]*HookCustomHeader `url:\"custom_headers,omitempty\" json:\"custom_headers,omitempty\"`\n}\n\n// EditGroupHook edits a hook for a specified group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#edit-group-hook\nfunc (s *GroupsService) EditGroupHook(pid interface{}, hook int, opt *EditGroupHookOptions, options ...RequestOptionFunc) (*GroupHook, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks/%d\", PathEscape(group), hook)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgh := new(GroupHook)\n\tresp, err := s.client.Do(req, gh)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gh, resp, nil\n}\n\n// DeleteGroupHook removes a hook from a group. This is an idempotent\n// method and can be called multiple times.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-group-hook\nfunc (s *GroupsService) DeleteGroupHook(pid interface{}, hook int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks/%d\", PathEscape(group), hook)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// TriggerTestGroupHook triggers a test hook for a specified group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_webhooks.html#trigger-a-test-group-hook\nfunc (s *GroupsService) TriggerTestGroupHook(pid interface{}, hook int, trigger GroupHookTrigger, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks/%d/test/%s\", PathEscape(group), hook, trigger)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SetGroupCustomHeader creates or updates a group custom webhook header.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#set-a-custom-header\nfunc (s *GroupsService) SetGroupCustomHeader(gid interface{}, hook int, key string, opt *SetHookCustomHeaderOptions, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks/%d/custom_headers/%s\", PathEscape(group), hook, key)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteGroupCustomHeader deletes a group custom webhook header.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-a-custom-header\nfunc (s *GroupsService) DeleteGroupCustomHeader(gid interface{}, hook int, key string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/hooks/%d/custom_headers/%s\", PathEscape(group), hook, key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_hooks_test.go",
          "type": "blob",
          "size": 13.2822265625,
          "content": "//\n// Copyright 2021, Eric Stevens\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListGroupHooks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n[\n\t{\n\t\t\"id\": 1,\n\t\t\"url\": \"http://example.com/hook\",\n\t\t\"group_id\": 3,\n\t\t\"push_events\": true,\n\t\t\"push_events_branch_filter\": \"main\",\n\t\t\"issues_events\": true,\n\t\t\"confidential_issues_events\": true,\n\t\t\"merge_requests_events\": true,\n\t\t\"tag_push_events\": true,\n\t\t\"note_events\": true,\n\t\t\"job_events\": true,\n\t\t\"pipeline_events\": true,\n\t\t\"wiki_page_events\": true,\n\t\t\"deployment_events\": true,\n\t\t\"releases_events\": true,\n\t\t\"subgroup_events\": true,\n\t\t\"member_events\": true,\n\t\t\"enable_ssl_verification\": true,\n\t\t\"alert_status\": \"executable\",\n\t\t\"created_at\": \"2012-10-12T17:04:47Z\",\n\t\t\"resource_access_token_events\": true,\n\t\t\"custom_headers\": [\n\t\t\t{\"key\": \"Authorization\"},\n\t\t\t{\"key\": \"OtherHeader\"}\n\t\t]\n\t}\n]`)\n\t})\n\n\tgroupHooks, _, err := client.Groups.ListGroupHooks(1, nil)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdatePointer := time.Date(2012, 10, 12, 17, 4, 47, 0, time.UTC)\n\twant := []*GroupHook{{\n\t\tID:                        1,\n\t\tURL:                       \"http://example.com/hook\",\n\t\tGroupID:                   3,\n\t\tPushEvents:                true,\n\t\tPushEventsBranchFilter:    \"main\",\n\t\tIssuesEvents:              true,\n\t\tConfidentialIssuesEvents:  true,\n\t\tMergeRequestsEvents:       true,\n\t\tTagPushEvents:             true,\n\t\tNoteEvents:                true,\n\t\tJobEvents:                 true,\n\t\tPipelineEvents:            true,\n\t\tWikiPageEvents:            true,\n\t\tDeploymentEvents:          true,\n\t\tReleasesEvents:            true,\n\t\tSubGroupEvents:            true,\n\t\tMemberEvents:              true,\n\t\tEnableSSLVerification:     true,\n\t\tAlertStatus:               \"executable\",\n\t\tCreatedAt:                 &datePointer,\n\t\tResourceAccessTokenEvents: true,\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey: \"Authorization\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey: \"OtherHeader\",\n\t\t\t},\n\t\t},\n\t}}\n\n\tif !reflect.DeepEqual(groupHooks, want) {\n\t\tt.Errorf(\"listGroupHooks returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(groupHooks), Stringify(want))\n\t}\n}\n\nfunc TestGetGroupHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n{\n\t\"id\": 1,\n\t\"url\": \"http://example.com/hook\",\n\t\"group_id\": 3,\n\t\"push_events\": true,\n\t\"push_events_branch_filter\": \"main\",\n\t\"issues_events\": true,\n\t\"confidential_issues_events\": true,\n\t\"merge_requests_events\": true,\n\t\"tag_push_events\": true,\n\t\"note_events\": true,\n\t\"job_events\": true,\n\t\"pipeline_events\": true,\n\t\"wiki_page_events\": true,\n\t\"deployment_events\": true,\n\t\"releases_events\": true,\n\t\"subgroup_events\": true,\n\t\"member_events\": true,\n\t\"enable_ssl_verification\": true,\n\t\"alert_status\": \"executable\",\n\t\"created_at\": \"2012-10-12T17:04:47Z\",\n\t\"resource_access_token_events\": true,\n\t\"custom_headers\": [\n\t\t{\"key\": \"Authorization\"},\n\t\t{\"key\": \"OtherHeader\"}\n\t]\n}`)\n\t})\n\n\tgroupHook, _, err := client.Groups.GetGroupHook(1, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdatePointer := time.Date(2012, 10, 12, 17, 4, 47, 0, time.UTC)\n\twant := &GroupHook{\n\t\tID:                        1,\n\t\tURL:                       \"http://example.com/hook\",\n\t\tGroupID:                   3,\n\t\tPushEvents:                true,\n\t\tPushEventsBranchFilter:    \"main\",\n\t\tIssuesEvents:              true,\n\t\tConfidentialIssuesEvents:  true,\n\t\tMergeRequestsEvents:       true,\n\t\tTagPushEvents:             true,\n\t\tNoteEvents:                true,\n\t\tJobEvents:                 true,\n\t\tPipelineEvents:            true,\n\t\tWikiPageEvents:            true,\n\t\tDeploymentEvents:          true,\n\t\tReleasesEvents:            true,\n\t\tSubGroupEvents:            true,\n\t\tMemberEvents:              true,\n\t\tEnableSSLVerification:     true,\n\t\tAlertStatus:               \"executable\",\n\t\tCreatedAt:                 &datePointer,\n\t\tResourceAccessTokenEvents: true,\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey: \"Authorization\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey: \"OtherHeader\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(groupHook, want) {\n\t\tt.Errorf(\"getGroupHooks returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(groupHook), Stringify(want))\n\t}\n}\n\nfunc TestAddGroupHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n{\n\t\"id\": 1,\n\t\"url\": \"http://example.com/hook\",\n\t\"group_id\": 3,\n\t\"push_events\": true,\n\t\"push_events_branch_filter\": \"main\",\n\t\"issues_events\": true,\n\t\"confidential_issues_events\": true,\n\t\"merge_requests_events\": true,\n\t\"tag_push_events\": true,\n\t\"note_events\": true,\n\t\"job_events\": true,\n\t\"pipeline_events\": true,\n\t\"wiki_page_events\": true,\n\t\"deployment_events\": true,\n\t\"releases_events\": true,\n\t\"subgroup_events\": true,\n\t\"member_events\": true,\n\t\"enable_ssl_verification\": true,\n\t\"created_at\": \"2012-10-12T17:04:47Z\",\n\t\"custom_webhook_template\": \"addTestValue\",\n\t\"resource_access_token_events\": true,\n\t\"custom_headers\": [\n\t\t{\"key\": \"Authorization\", \"value\": \"testMe\"},\n\t\t{\"key\": \"OtherHeader\", \"value\": \"otherTest\"}\n\t]\n}`)\n\t})\n\n\turl := \"http://www.example.com/hook\"\n\topt := &AddGroupHookOptions{\n\t\tURL: &url,\n\t}\n\n\tgroupHooks, _, err := client.Groups.AddGroupHook(1, opt)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdatePointer := time.Date(2012, 10, 12, 17, 4, 47, 0, time.UTC)\n\twant := &GroupHook{\n\t\tID:                        1,\n\t\tURL:                       \"http://example.com/hook\",\n\t\tGroupID:                   3,\n\t\tPushEvents:                true,\n\t\tPushEventsBranchFilter:    \"main\",\n\t\tIssuesEvents:              true,\n\t\tConfidentialIssuesEvents:  true,\n\t\tConfidentialNoteEvents:    false,\n\t\tMergeRequestsEvents:       true,\n\t\tTagPushEvents:             true,\n\t\tNoteEvents:                true,\n\t\tJobEvents:                 true,\n\t\tPipelineEvents:            true,\n\t\tWikiPageEvents:            true,\n\t\tDeploymentEvents:          true,\n\t\tReleasesEvents:            true,\n\t\tSubGroupEvents:            true,\n\t\tMemberEvents:              true,\n\t\tEnableSSLVerification:     true,\n\t\tCreatedAt:                 &datePointer,\n\t\tCustomWebhookTemplate:     \"addTestValue\",\n\t\tResourceAccessTokenEvents: true,\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey:   \"Authorization\",\n\t\t\t\tValue: \"testMe\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey:   \"OtherHeader\",\n\t\t\t\tValue: \"otherTest\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(groupHooks, want) {\n\t\tt.Errorf(\"AddGroupHook returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(groupHooks), Stringify(want))\n\t}\n}\n\nfunc TestEditGroupHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `\n{\n\t\"id\": 1,\n\t\"url\": \"http://example.com/hook\",\n\t\"group_id\": 3,\n\t\"push_events\": true,\n\t\"push_events_branch_filter\": \"main\",\n\t\"issues_events\": true,\n\t\"confidential_issues_events\": true,\n\t\"merge_requests_events\": true,\n\t\"tag_push_events\": true,\n\t\"note_events\": true,\n\t\"job_events\": true,\n\t\"pipeline_events\": true,\n\t\"wiki_page_events\": true,\n\t\"deployment_events\": true,\n\t\"releases_events\": true,\n\t\"subgroup_events\": true,\n\t\"member_events\": true,\n\t\"enable_ssl_verification\": true,\n\t\"created_at\": \"2012-10-12T17:04:47Z\",\n\t\"custom_webhook_template\": \"testValue\",\n\t\"resource_access_token_events\": true,\n\t\"custom_headers\": [\n\t\t{\"key\": \"Authorization\", \"value\": \"testMe\"},\n\t\t{\"key\": \"OtherHeader\", \"value\": \"otherTest\"}\n\t]\n}`)\n\t})\n\n\turl := \"http://www.example.com/hook\"\n\topt := &EditGroupHookOptions{\n\t\tURL: &url,\n\t}\n\n\tgroupHooks, _, err := client.Groups.EditGroupHook(1, 1, opt)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdatePointer := time.Date(2012, 10, 12, 17, 4, 47, 0, time.UTC)\n\twant := &GroupHook{\n\t\tID:                        1,\n\t\tURL:                       \"http://example.com/hook\",\n\t\tGroupID:                   3,\n\t\tPushEvents:                true,\n\t\tPushEventsBranchFilter:    \"main\",\n\t\tIssuesEvents:              true,\n\t\tConfidentialIssuesEvents:  true,\n\t\tConfidentialNoteEvents:    false,\n\t\tMergeRequestsEvents:       true,\n\t\tTagPushEvents:             true,\n\t\tNoteEvents:                true,\n\t\tJobEvents:                 true,\n\t\tPipelineEvents:            true,\n\t\tWikiPageEvents:            true,\n\t\tDeploymentEvents:          true,\n\t\tReleasesEvents:            true,\n\t\tSubGroupEvents:            true,\n\t\tMemberEvents:              true,\n\t\tEnableSSLVerification:     true,\n\t\tCreatedAt:                 &datePointer,\n\t\tCustomWebhookTemplate:     \"testValue\",\n\t\tResourceAccessTokenEvents: true,\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey:   \"Authorization\",\n\t\t\t\tValue: \"testMe\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey:   \"OtherHeader\",\n\t\t\t\tValue: \"otherTest\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(groupHooks, want) {\n\t\tt.Errorf(\"EditGroupHook returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(groupHooks), Stringify(want))\n\t}\n}\n\nfunc TestTriggerTestGroupHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1/test/push_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\"message\":\"201 Created\"}`)\n\t})\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1/test/invalid_trigger\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tfmt.Fprint(w, `{\"error\": \"trigger does not have a valid value\"}`)\n\t})\n\n\ttests := []struct {\n\t\tname       string\n\t\tgroupID    interface{}\n\t\thookID     int\n\t\ttrigger    GroupHookTrigger\n\t\twantErr    bool\n\t\twantStatus int\n\t\twantErrMsg string\n\t}{\n\t\t{\n\t\t\tname:       \"Valid trigger\",\n\t\t\tgroupID:    1,\n\t\t\thookID:     1,\n\t\t\ttrigger:    GroupHookTriggerPush,\n\t\t\twantErr:    false,\n\t\t\twantStatus: http.StatusCreated,\n\t\t},\n\t\t{\n\t\t\tname:       \"Invalid group ID\",\n\t\t\tgroupID:    \"invalid\",\n\t\t\thookID:     1,\n\t\t\ttrigger:    GroupHookTriggerPush,\n\t\t\twantErr:    true,\n\t\t\twantStatus: http.StatusNotFound,\n\t\t},\n\t\t{\n\t\t\tname:       \"Invalid trigger type\",\n\t\t\tgroupID:    1,\n\t\t\thookID:     1,\n\t\t\ttrigger:    \"invalid_trigger\",\n\t\t\twantErr:    true,\n\t\t\twantStatus: http.StatusBadRequest,\n\t\t\twantErrMsg: \"trigger does not have a valid value\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresp, err := client.Groups.TriggerTestGroupHook(tt.groupID, tt.hookID, tt.trigger)\n\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t\tif tt.wantStatus != 0 {\n\t\t\t\t\tassert.Equal(t, tt.wantStatus, resp.StatusCode)\n\t\t\t\t}\n\t\t\t\tif tt.wantErrMsg != \"\" {\n\t\t\t\t\tassert.Contains(t, err.Error(), tt.wantErrMsg)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t\tassert.NotNil(t, resp)\n\t\t\t\tassert.Equal(t, tt.wantStatus, resp.StatusCode)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDeleteGroupHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Groups.DeleteGroupHook(1, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc TestGetGroupWebhookHeader(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Removed most of the arguments to keep test slim\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"custom_webhook_template\": \"{\\\"event\\\":\\\"{{object_kind}}\\\"}\",\n\t\t\t\"custom_headers\": [\n\t\t\t  {\n\t\t\t\t\"key\": \"Authorization\"\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"key\": \"OtherKey\"\n\t\t\t  }\n\t\t\t]\n\t\t  }`)\n\t})\n\n\thook, _, err := client.Groups.GetGroupHook(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetGroupHook returned error: %v\", err)\n\t}\n\n\twant := &GroupHook{\n\t\tID:                    1,\n\t\tCustomWebhookTemplate: \"{\\\"event\\\":\\\"{{object_kind}}\\\"}\",\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey: \"Authorization\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey: \"OtherKey\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, hook) {\n\t\tt.Errorf(\"Projects.GetGroupHook returned %+v, want %+v\", hook, want)\n\t}\n}\n\nfunc TestSetGroupWebhookHeader(t *testing.T) {\n\tmux, client := setup(t)\n\tvar bodyJson map[string]interface{}\n\n\t// Removed most of the arguments to keep test slim\n\tmux.HandleFunc(\"/api/v4/groups/1/hooks/1/custom_headers/Authorization\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tw.WriteHeader(http.StatusNoContent)\n\n\t\t// validate that the `value` body is sent properly\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to read body properly. Error: %v\", err)\n\t\t}\n\n\t\t// Unmarshal the body into JSON so we can check it\n\t\t_ = json.Unmarshal(body, &bodyJson)\n\n\t\tfmt.Fprint(w, ``)\n\t})\n\n\treq, err := client.Groups.SetGroupCustomHeader(1, 1, \"Authorization\", &SetHookCustomHeaderOptions{Value: Ptr(\"testValue\")})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.SetGroupCustomHeader returned error: %v\", err)\n\t}\n\n\tassert.Equal(t, bodyJson[\"value\"], \"testValue\")\n\tassert.Equal(t, http.StatusNoContent, req.StatusCode)\n}\n"
        },
        {
          "name": "group_import_export.go",
          "type": "blob",
          "size": 4.4814453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n)\n\n// GroupImportExportService handles communication with the group import export\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_import_export.html\ntype GroupImportExportService struct {\n\tclient *Client\n}\n\n// ScheduleExport starts a new group export.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_import_export.html#schedule-new-export\nfunc (s *GroupImportExportService) ScheduleExport(gid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/export\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ExportDownload downloads the finished export.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_import_export.html#export-download\nfunc (s *GroupImportExportService) ExportDownload(gid interface{}, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/export/download\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\texportDownload := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, exportDownload)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(exportDownload.Bytes()), resp, err\n}\n\n// GroupImportFileOptions represents the available ImportFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_import_export.html#import-a-file\ntype GroupImportFileOptions struct {\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tPath     *string `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tFile     *string `url:\"file,omitempty\" json:\"file,omitempty\"`\n\tParentID *int    `url:\"parent_id,omitempty\" json:\"parent_id,omitempty\"`\n}\n\n// ImportFile imports a file.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_import_export.html#import-a-file\nfunc (s *GroupImportExportService) ImportFile(opt *GroupImportFileOptions, options ...RequestOptionFunc) (*Response, error) {\n\t// First check if we got all required options.\n\tif opt.Name == nil || *opt.Name == \"\" {\n\t\treturn nil, fmt.Errorf(\"Missing required option: Name\")\n\t}\n\tif opt.Path == nil || *opt.Path == \"\" {\n\t\treturn nil, fmt.Errorf(\"Missing required option: Path\")\n\t}\n\tif opt.File == nil || *opt.File == \"\" {\n\t\treturn nil, fmt.Errorf(\"Missing required option: File\")\n\t}\n\n\tf, err := os.Open(*opt.File)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\tb := &bytes.Buffer{}\n\tw := multipart.NewWriter(b)\n\n\t_, filename := filepath.Split(*opt.File)\n\tfw, err := w.CreateFormFile(\"file\", filename)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = io.Copy(fw, f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Populate the additional fields.\n\tfw, err = w.CreateFormField(\"name\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = fw.Write([]byte(*opt.Name))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfw, err = w.CreateFormField(\"path\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = fw.Write([]byte(*opt.Path))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif opt.ParentID != nil {\n\t\tfw, err = w.CreateFormField(\"parent_id\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t_, err = fw.Write([]byte(strconv.Itoa(*opt.ParentID)))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif err = w.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodPost, \"groups/import\", nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Set the buffer as the request body.\n\tif err = req.SetBody(b); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Overwrite the default content type.\n\treq.Header.Set(\"Content-Type\", w.FormDataContentType())\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_import_export_test.go",
          "type": "blob",
          "size": 1.9990234375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGroupScheduleExport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/export\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"message\": \"202 Accepted\"}`)\n\t\t})\n\n\t_, err := client.GroupImportExport.ScheduleExport(1)\n\tif err != nil {\n\t\tt.Errorf(\"GroupImportExport.ScheduleExport returned error: %v\", err)\n\t}\n}\n\nfunc TestGroupExportDownload(t *testing.T) {\n\tmux, client := setup(t)\n\tcontent := []byte(\"fake content\")\n\n\tmux.HandleFunc(\"/api/v4/groups/1/export/download\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tw.Write(content)\n\t\t})\n\n\texport, _, err := client.GroupImportExport.ExportDownload(1)\n\tif err != nil {\n\t\tt.Errorf(\"GroupImportExport.ExportDownload returned error: %v\", err)\n\t}\n\n\tdata, err := io.ReadAll(export)\n\tif err != nil {\n\t\tt.Errorf(\"Error reading export: %v\", err)\n\t}\n\n\twant := []byte(\"fake content\")\n\tif !reflect.DeepEqual(want, data) {\n\t\tt.Errorf(\"GroupImportExport.GroupExportDownload returned %+v, want %+v\", data, want)\n\t}\n}\n\nfunc TestGroupImport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tcontent := []byte(\"temporary file's content\")\n\ttmpfile, err := os.CreateTemp(os.TempDir(), \"example.*.tar.gz\")\n\tif err != nil {\n\t\ttmpfile.Close()\n\t\tt.Fatal(err)\n\t}\n\tif _, err := tmpfile.Write(content); err != nil {\n\t\ttmpfile.Close()\n\t\tt.Fatal(err)\n\t}\n\tif err := tmpfile.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.Remove(tmpfile.Name()) // clean up\n\n\tmux.HandleFunc(\"/api/v4/groups/import\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"message\": \"202 Accepted\"}`)\n\t\t})\n\n\topt := &GroupImportFileOptions{\n\t\tName:     Ptr(\"test\"),\n\t\tPath:     Ptr(\"path\"),\n\t\tFile:     Ptr(tmpfile.Name()),\n\t\tParentID: Ptr(1),\n\t}\n\n\t_, err = client.GroupImportExport.ImportFile(opt)\n\tif err != nil {\n\t\tt.Errorf(\"GroupImportExport.ImportFile returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "group_iterations.go",
          "type": "blob",
          "size": 2.7333984375,
          "content": "//\n// Copyright 2022, Daniel Steinke\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// IterationsAPI handles communication with the iterations related methods\n// of the GitLab API\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_iterations.html\ntype GroupIterationsService struct {\n\tclient *Client\n}\n\n// GroupInteration represents a GitLab iteration.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_iterations.html\ntype GroupIteration struct {\n\tID          int        `json:\"id\"`\n\tIID         int        `json:\"iid\"`\n\tSequence    int        `json:\"sequence\"`\n\tGroupID     int        `json:\"group_id\"`\n\tTitle       string     `json:\"title\"`\n\tDescription string     `json:\"description\"`\n\tState       int        `json:\"state\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tDueDate     *ISOTime   `json:\"due_date\"`\n\tStartDate   *ISOTime   `json:\"start_date\"`\n\tWebURL      string     `json:\"web_url\"`\n}\n\nfunc (i GroupIteration) String() string {\n\treturn Stringify(i)\n}\n\n// ListGroupIterationsOptions contains the available ListGroupIterations()\n// options\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_iterations.html#list-group-iterations\ntype ListGroupIterationsOptions struct {\n\tListOptions\n\tState            *string `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tSearch           *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIncludeAncestors *bool   `url:\"include_ancestors,omitempty\" json:\"include_ancestors,omitempty\"`\n}\n\n// ListGroupIterations returns a list of group iterations.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_iterations.html#list-group-iterations\nfunc (s *GroupIterationsService) ListGroupIterations(gid interface{}, opt *ListGroupIterationsOptions, options ...RequestOptionFunc) ([]*GroupIteration, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/iterations\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gis []*GroupIteration\n\tresp, err := s.client.Do(req, &gis)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn gis, resp, nil\n}\n"
        },
        {
          "name": "group_iterations_test.go",
          "type": "blob",
          "size": 1.177734375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListGroupIterations(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/iterations\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprintf(w, `[\n        {\n          \"id\": 53,\n          \"iid\": 13,\n          \"sequence\": 1,\n          \"group_id\": 5,\n          \"title\": \"Iteration II\",\n          \"description\": \"Ipsum Lorem ipsum\",\n          \"state\": 2,\n          \"web_url\": \"http://gitlab.example.com/groups/my-group/-/iterations/13\"\n        }\n      ]`)\n\t\t})\n\n\titerations, _, err := client.GroupIterations.ListGroupIterations(5, &ListGroupIterationsOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupIterations.ListGroupIterations returned error: %v\", err)\n\t}\n\n\twant := []*GroupIteration{{\n\t\tID:          53,\n\t\tIID:         13,\n\t\tSequence:    1,\n\t\tGroupID:     5,\n\t\tTitle:       \"Iteration II\",\n\t\tDescription: \"Ipsum Lorem ipsum\",\n\t\tState:       2,\n\t\tWebURL:      \"http://gitlab.example.com/groups/my-group/-/iterations/13\",\n\t}}\n\tif !reflect.DeepEqual(want, iterations) {\n\t\tt.Errorf(\"GroupIterations.ListGroupIterations returned %+v, want %+v\", iterations, want)\n\t}\n}\n"
        },
        {
          "name": "group_labels.go",
          "type": "blob",
          "size": 8.51171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GroupLabelsService handles communication with the label related methods of the\n// GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_labels.html\ntype GroupLabelsService struct {\n\tclient *Client\n}\n\n// GroupLabel represents a GitLab group label.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_labels.html\ntype GroupLabel Label\n\nfunc (l GroupLabel) String() string {\n\treturn Stringify(l)\n}\n\n// ListGroupLabelsOptions represents the available ListGroupLabels() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_labels.html#list-group-labels\ntype ListGroupLabelsOptions struct {\n\tListOptions\n\tWithCounts               *bool   `url:\"with_counts,omitempty\" json:\"with_counts,omitempty\"`\n\tIncludeAncestorGroups    *bool   `url:\"include_ancestor_groups,omitempty\" json:\"include_ancestor_groups,omitempty\"`\n\tIncludeDescendantGrouops *bool   `url:\"include_descendant_groups,omitempty\" json:\"include_descendant_groups,omitempty\"`\n\tOnlyGroupLabels          *bool   `url:\"only_group_labels,omitempty\" json:\"only_group_labels,omitempty\"`\n\tSearch                   *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n}\n\n// ListGroupLabels gets all labels for given group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#list-group-labels\nfunc (s *GroupLabelsService) ListGroupLabels(gid interface{}, opt *ListGroupLabelsOptions, options ...RequestOptionFunc) ([]*GroupLabel, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar l []*GroupLabel\n\tresp, err := s.client.Do(req, &l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// GetGroupLabel get a single label for a given group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#get-a-single-group-label\nfunc (s *GroupLabelsService) GetGroupLabel(gid interface{}, lid interface{}, options ...RequestOptionFunc) (*GroupLabel, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels/%s\", PathEscape(group), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar l *GroupLabel\n\tresp, err := s.client.Do(req, &l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// CreateGroupLabelOptions represents the available CreateGroupLabel() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#create-a-new-group-label\ntype CreateGroupLabelOptions struct {\n\tName        *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tColor       *string `url:\"color,omitempty\" json:\"color,omitempty\"`\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPriority    *int    `url:\"priority,omitempty\" json:\"priority,omitempty\"`\n}\n\n// CreateGroupLabel creates a new label for given group with given name and\n// color.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#create-a-new-group-label\nfunc (s *GroupLabelsService) CreateGroupLabel(gid interface{}, opt *CreateGroupLabelOptions, options ...RequestOptionFunc) (*GroupLabel, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(GroupLabel)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// DeleteGroupLabelOptions represents the available DeleteGroupLabel() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#delete-a-group-label\ntype DeleteGroupLabelOptions struct {\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// DeleteGroupLabel deletes a group label given by its name or ID.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#delete-a-group-label\nfunc (s *GroupLabelsService) DeleteGroupLabel(gid interface{}, lid interface{}, opt *DeleteGroupLabelOptions, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels\", PathEscape(group))\n\n\tif lid != nil {\n\t\tlabel, err := parseID(lid)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tu = fmt.Sprintf(\"groups/%s/labels/%s\", PathEscape(group), PathEscape(label))\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// UpdateGroupLabelOptions represents the available UpdateGroupLabel() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#update-a-group-label\ntype UpdateGroupLabelOptions struct {\n\tName        *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tNewName     *string `url:\"new_name,omitempty\" json:\"new_name,omitempty\"`\n\tColor       *string `url:\"color,omitempty\" json:\"color,omitempty\"`\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPriority    *int    `url:\"priority,omitempty\" json:\"priority,omitempty\"`\n}\n\n// UpdateGroupLabel updates an existing label with new name or now color. At least\n// one parameter is required, to update the label.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#update-a-group-label\nfunc (s *GroupLabelsService) UpdateGroupLabel(gid interface{}, lid interface{}, opt *UpdateGroupLabelOptions, options ...RequestOptionFunc) (*GroupLabel, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels\", PathEscape(group))\n\n\tif lid != nil {\n\t\tlabel, err := parseID(lid)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tu = fmt.Sprintf(\"groups/%s/labels/%s\", PathEscape(group), PathEscape(label))\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(GroupLabel)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// SubscribeToGroupLabel subscribes the authenticated user to a label to receive\n// notifications. If the user is already subscribed to the label, the status\n// code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#subscribe-to-a-group-label\nfunc (s *GroupLabelsService) SubscribeToGroupLabel(gid interface{}, lid interface{}, options ...RequestOptionFunc) (*GroupLabel, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels/%s/subscribe\", PathEscape(group), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(GroupLabel)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// UnsubscribeFromGroupLabel unsubscribes the authenticated user from a label to not\n// receive notifications from it. If the user is not subscribed to the label, the\n// status code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_labels.html#unsubscribe-from-a-group-label\nfunc (s *GroupLabelsService) UnsubscribeFromGroupLabel(gid interface{}, lid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/labels/%s/unsubscribe\", PathEscape(group), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_labels_test.go",
          "type": "blob",
          "size": 5.701171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCreateGroupGroupLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"name\": \"MyGroupLabel\", \"color\" : \"#11FF22\"}`)\n\t})\n\n\tl := &CreateGroupLabelOptions{\n\t\tName:  Ptr(\"MyGroupLabel\"),\n\t\tColor: Ptr(\"#11FF22\"),\n\t}\n\tlabel, _, err := client.GroupLabels.CreateGroupLabel(\"1\", l)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &GroupLabel{ID: 1, Name: \"MyGroupLabel\", Color: \"#11FF22\"}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"GroupLabels.CreateGroupLabel returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestDeleteGroupLabelByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.GroupLabels.DeleteGroupLabel(\"1\", \"1\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDeleteGroupLabelByName(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels/MyGroupLabel\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.GroupLabels.DeleteGroupLabel(\"1\", \"MyGroupLabel\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestUpdateGroupLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels/MyGroupLabel\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"name\": \"NewLabel\", \"color\" : \"#11FF23\" , \"description\":\"This is updated label\"}`)\n\t})\n\n\tl := &UpdateGroupLabelOptions{\n\t\tNewName:     Ptr(\"NewLabel\"),\n\t\tColor:       Ptr(\"#11FF23\"),\n\t\tDescription: Ptr(\"This is updated label\"),\n\t}\n\n\tlabel, resp, err := client.GroupLabels.UpdateGroupLabel(\"1\", \"MyGroupLabel\", l)\n\n\tif resp == nil {\n\t\tt.Fatal(err)\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &GroupLabel{ID: 1, Name: \"NewLabel\", Color: \"#11FF23\", Description: \"This is updated label\"}\n\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"GroupLabels.UpdateGroupLabel returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestSubscribeToGroupLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels/5/subscribe\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{  \"id\" : 5, \"name\" : \"kind/bug\", \"color\" : \"#d9534f\", \"description\": \"Bug reported by user\", \"open_issues_count\": 1, \"closed_issues_count\": 0, \"open_merge_requests_count\": 1, \"subscribed\": true,\"priority\": null}`)\n\t})\n\n\tlabel, _, err := client.GroupLabels.SubscribeToGroupLabel(\"1\", \"5\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &GroupLabel{ID: 5, Name: \"kind/bug\", Color: \"#d9534f\", Description: \"Bug reported by user\", OpenIssuesCount: 1, ClosedIssuesCount: 0, OpenMergeRequestsCount: 1, Subscribed: true}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"GroupLabels.SubscribeToGroupLabel returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestUnsubscribeFromGroupLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels/5/unsubscribe\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t})\n\n\t_, err := client.GroupLabels.UnsubscribeFromGroupLabel(\"1\", \"5\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListGroupLabels(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{  \"id\" : 5, \"name\" : \"kind/bug\", \"color\" : \"#d9534f\", \"description\": \"Bug reported by user\", \"open_issues_count\": 1, \"closed_issues_count\": 0, \"open_merge_requests_count\": 1, \"subscribed\": true,\"priority\": null}]`)\n\t})\n\n\to := &ListGroupLabelsOptions{\n\t\tListOptions: ListOptions{\n\t\t\tPage:    1,\n\t\t\tPerPage: 10,\n\t\t},\n\t}\n\tlabel, _, err := client.GroupLabels.ListGroupLabels(\"1\", o)\n\tif err != nil {\n\t\tt.Log(err.Error() == \"invalid ID type 1.1, the ID must be an int or a string\")\n\t}\n\twant := []*GroupLabel{{ID: 5, Name: \"kind/bug\", Color: \"#d9534f\", Description: \"Bug reported by user\", OpenIssuesCount: 1, ClosedIssuesCount: 0, OpenMergeRequestsCount: 1, Subscribed: true}}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"GroupLabels.ListGroupLabels returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestGetGroupLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/labels/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{  \"id\" : 5, \"name\" : \"kind/bug\", \"color\" : \"#d9534f\", \"description\": \"Bug reported by user\", \"open_issues_count\": 1, \"closed_issues_count\": 0, \"open_merge_requests_count\": 1, \"subscribed\": true,\"priority\": null}`)\n\t})\n\n\tlabel, _, err := client.GroupLabels.GetGroupLabel(\"1\", 5)\n\tif err != nil {\n\t\tt.Log(err)\n\t}\n\n\twant := &GroupLabel{ID: 5, Name: \"kind/bug\", Color: \"#d9534f\", Description: \"Bug reported by user\", OpenIssuesCount: 1, ClosedIssuesCount: 0, OpenMergeRequestsCount: 1, Subscribed: true}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"GroupLabels.GetGroupLabel returned %+v, want %+v\", label, want)\n\t}\n}\n"
        },
        {
          "name": "group_members.go",
          "type": "blob",
          "size": 14.5302734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupMembersService handles communication with the group members\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/members.html\ntype GroupMembersService struct {\n\tclient *Client\n}\n\n// GroupMember represents a GitLab group member.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/members.html\ntype GroupMember struct {\n\tID                int                      `json:\"id\"`\n\tUsername          string                   `json:\"username\"`\n\tName              string                   `json:\"name\"`\n\tState             string                   `json:\"state\"`\n\tAvatarURL         string                   `json:\"avatar_url\"`\n\tWebURL            string                   `json:\"web_url\"`\n\tCreatedAt         *time.Time               `json:\"created_at\"`\n\tExpiresAt         *ISOTime                 `json:\"expires_at\"`\n\tAccessLevel       AccessLevelValue         `json:\"access_level\"`\n\tEmail             string                   `json:\"email,omitempty\"`\n\tGroupSAMLIdentity *GroupMemberSAMLIdentity `json:\"group_saml_identity\"`\n\tMemberRole        *MemberRole              `json:\"member_role\"`\n}\n\n// GroupMemberSAMLIdentity represents the SAML Identity link for the group member.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project\ntype GroupMemberSAMLIdentity struct {\n\tExternUID      string `json:\"extern_uid\"`\n\tProvider       string `json:\"provider\"`\n\tSAMLProviderID int    `json:\"saml_provider_id\"`\n}\n\n// BillableGroupMember represents a GitLab billable group member.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-billable-members-of-a-group\ntype BillableGroupMember struct {\n\tID             int        `json:\"id\"`\n\tUsername       string     `json:\"username\"`\n\tName           string     `json:\"name\"`\n\tState          string     `json:\"state\"`\n\tAvatarURL      string     `json:\"avatar_url\"`\n\tWebURL         string     `json:\"web_url\"`\n\tEmail          string     `json:\"email\"`\n\tLastActivityOn *ISOTime   `json:\"last_activity_on\"`\n\tMembershipType string     `json:\"membership_type\"`\n\tRemovable      bool       `json:\"removable\"`\n\tCreatedAt      *time.Time `json:\"created_at\"`\n\tIsLastOwner    bool       `json:\"is_last_owner\"`\n\tLastLoginAt    *time.Time `json:\"last_login_at\"`\n}\n\n// BillableUserMembership represents a Membership of a billable user of a group\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-memberships-for-a-billable-member-of-a-group\ntype BillableUserMembership struct {\n\tID               int                 `json:\"id\"`\n\tSourceID         int                 `json:\"source_id\"`\n\tSourceFullName   string              `json:\"source_full_name\"`\n\tSourceMembersURL string              `json:\"source_members_url\"`\n\tCreatedAt        *time.Time          `json:\"created_at\"`\n\tExpiresAt        *time.Time          `json:\"expires_at\"`\n\tAccessLevel      *AccessLevelDetails `json:\"access_level\"`\n}\n\n// ListGroupMembersOptions represents the available ListGroupMembers() and\n// ListAllGroupMembers() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project\ntype ListGroupMembersOptions struct {\n\tListOptions\n\tQuery   *string `url:\"query,omitempty\" json:\"query,omitempty\"`\n\tUserIDs *[]int  `url:\"user_ids[],omitempty\" json:\"user_ids,omitempty\"`\n}\n\n// ListGroupMembers get a list of group members viewable by the authenticated\n// user. Inherited members through ancestor groups are not included.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project\nfunc (s *GroupsService) ListGroupMembers(gid interface{}, opt *ListGroupMembersOptions, options ...RequestOptionFunc) ([]*GroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gm []*GroupMember\n\tresp, err := s.client.Do(req, &gm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gm, resp, nil\n}\n\n// ListAllGroupMembers get a list of group members viewable by the authenticated\n// user. Returns a list including inherited members through ancestor groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project-including-inherited-and-invited-members\nfunc (s *GroupsService) ListAllGroupMembers(gid interface{}, opt *ListGroupMembersOptions, options ...RequestOptionFunc) ([]*GroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members/all\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gm []*GroupMember\n\tresp, err := s.client.Do(req, &gm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gm, resp, nil\n}\n\n// AddGroupMemberOptions represents the available AddGroupMember() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#add-a-member-to-a-group-or-project\ntype AddGroupMemberOptions struct {\n\tUserID       *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tUsername     *string           `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tAccessLevel  *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt    *string           `url:\"expires_at,omitempty\" json:\"expires_at\"`\n\tMemberRoleID *int              `url:\"member_role_id,omitempty\" json:\"member_role_id,omitempty\"`\n}\n\n// GetGroupMember gets a member of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#get-a-member-of-a-group-or-project\nfunc (s *GroupMembersService) GetGroupMember(gid interface{}, user int, options ...RequestOptionFunc) (*GroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members/%d\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgm := new(GroupMember)\n\tresp, err := s.client.Do(req, gm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gm, resp, nil\n}\n\n// GetInheritedGroupMember get a member of a group or project, including\n// inherited and invited members\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#get-a-member-of-a-group-or-project-including-inherited-and-invited-members\nfunc (s *GroupMembersService) GetInheritedGroupMember(gid interface{}, user int, options ...RequestOptionFunc) (*GroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members/all/%d\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgm := new(GroupMember)\n\tresp, err := s.client.Do(req, gm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gm, resp, err\n}\n\n// ListBillableGroupMembersOptions represents the available\n// ListBillableGroupMembers() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-billable-members-of-a-group\ntype ListBillableGroupMembersOptions struct {\n\tListOptions\n\tSearch *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tSort   *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListBillableGroupMembers Gets a list of group members that count as billable.\n// The list includes members in the subgroup or subproject.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-billable-members-of-a-group\nfunc (s *GroupsService) ListBillableGroupMembers(gid interface{}, opt *ListBillableGroupMembersOptions, options ...RequestOptionFunc) ([]*BillableGroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/billable_members\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bgm []*BillableGroupMember\n\tresp, err := s.client.Do(req, &bgm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bgm, resp, nil\n}\n\n// ListMembershipsForBillableGroupMemberOptions represents the available\n// ListMembershipsForBillableGroupMember() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-memberships-for-a-billable-member-of-a-group\ntype ListMembershipsForBillableGroupMemberOptions = ListOptions\n\n// ListMembershipsForBillableGroupMember gets a list of memberships for a\n// billable member of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-memberships-for-a-billable-member-of-a-group\nfunc (s *GroupsService) ListMembershipsForBillableGroupMember(gid interface{}, user int, opt *ListMembershipsForBillableGroupMemberOptions, options ...RequestOptionFunc) ([]*BillableUserMembership, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/billable_members/%d/memberships\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bum []*BillableUserMembership\n\tresp, err := s.client.Do(req, &bum)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bum, resp, nil\n}\n\n// RemoveBillableGroupMember removes a given group members that count as billable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#remove-a-billable-member-from-a-group\nfunc (s *GroupsService) RemoveBillableGroupMember(gid interface{}, user int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/billable_members/%d\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// AddGroupMember adds a user to the list of group members.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#add-a-member-to-a-group-or-project\nfunc (s *GroupMembersService) AddGroupMember(gid interface{}, opt *AddGroupMemberOptions, options ...RequestOptionFunc) (*GroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgm := new(GroupMember)\n\tresp, err := s.client.Do(req, gm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gm, resp, nil\n}\n\n// ShareWithGroup shares a group with the group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#share-groups-with-groups\nfunc (s *GroupMembersService) ShareWithGroup(gid interface{}, opt *ShareWithGroupOptions, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/share\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// DeleteShareWithGroup allows to unshare a group from a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-link-sharing-group-with-another-group\nfunc (s *GroupMembersService) DeleteShareWithGroup(gid interface{}, groupID int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/share/%d\", PathEscape(group), groupID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// EditGroupMemberOptions represents the available EditGroupMember()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#edit-a-member-of-a-group-or-project\ntype EditGroupMemberOptions struct {\n\tAccessLevel  *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt    *string           `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n\tMemberRoleID *int              `url:\"member_role_id,omitempty\" json:\"member_role_id,omitempty\"`\n}\n\n// EditGroupMember updates a member of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#edit-a-member-of-a-group-or-project\nfunc (s *GroupMembersService) EditGroupMember(gid interface{}, user int, opt *EditGroupMemberOptions, options ...RequestOptionFunc) (*GroupMember, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members/%d\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgm := new(GroupMember)\n\tresp, err := s.client.Do(req, gm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gm, resp, nil\n}\n\n// RemoveGroupMemberOptions represents the available options to remove a group member.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#remove-a-member-from-a-group-or-project\ntype RemoveGroupMemberOptions struct {\n\tSkipSubresources  *bool `url:\"skip_subresources,omitempty\" json:\"skip_subresources,omitempty\"`\n\tUnassignIssuables *bool `url:\"unassign_issuables,omitempty\" json:\"unassign_issuables,omitempty\"`\n}\n\n// RemoveGroupMember removes user from user team.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#remove-a-member-from-a-group-or-project\nfunc (s *GroupMembersService) RemoveGroupMember(gid interface{}, user int, opt *RemoveGroupMemberOptions, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/members/%d\", PathEscape(group), user)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_members_test.go",
          "type": "blob",
          "size": 13.240234375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestListBillableGroupMembers(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/billable_members\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w,\n\t\t\t\t`[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\":1,\n\t\t\t\t\t\t\"username\":\"ray\",\n\t\t\t\t\t\t\"name\":\"Raymond\",\n\t\t\t\t\t\t\"state\":\"active\",\n\t\t\t\t\t\t\"avatar_url\":\"https://foo.bar/mypic\",\n\t\t\t\t\t\t\"web_url\":\"http://192.168.1.8:3000/root\",\n\t\t\t\t\t\t\"last_activity_on\":\"2021-01-27\",\n\t\t\t\t\t\t\"membership_type\": \"group_member\",\n\t\t\t\t\t\t\"removable\": true,\n\t\t\t\t\t\t\"created_at\": \"2017-10-23T11:41:28.793Z\",\n\t\t\t\t\t\t\"is_last_owner\": false,\n\t\t\t\t\t\t\"last_login_at\": \"2022-12-12T09:22:51.581Z\"\n\t\t\t\t\t}\n\t\t\t\t]`)\n\t\t})\n\n\tbillableMembers, _, err := client.Groups.ListBillableGroupMembers(1, &ListBillableGroupMembersOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListBillableGroupMembers returned error: %v\", err)\n\t}\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2017-10-23T11:41:28.793Z\")\n\tlastLoginAt, _ := time.Parse(time.RFC3339, \"2022-12-12T09:22:51.581Z\")\n\tlastActivityOn, _ := time.Parse(time.RFC3339, \"2021-01-27T00:00:00Z\")\n\tlastActivityOnISOTime := ISOTime(lastActivityOn)\n\n\twant := []*BillableGroupMember{\n\t\t{\n\t\t\tID:             1,\n\t\t\tUsername:       \"ray\",\n\t\t\tName:           \"Raymond\",\n\t\t\tState:          \"active\",\n\t\t\tAvatarURL:      \"https://foo.bar/mypic\",\n\t\t\tWebURL:         \"http://192.168.1.8:3000/root\",\n\t\t\tLastActivityOn: &lastActivityOnISOTime,\n\t\t\tMembershipType: \"group_member\",\n\t\t\tRemovable:      true,\n\t\t\tCreatedAt:      &createdAt,\n\t\t\tIsLastOwner:    false,\n\t\t\tLastLoginAt:    &lastLoginAt,\n\t\t},\n\t}\n\tassert.Equal(t, want, billableMembers, \"Expected returned Groups.ListBillableGroupMembers to equal\")\n}\n\nfunc TestListMembershipsForBillableGroupMember(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/groups/1/billable_members/42/memberships\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w,\n\t\t\t\t`[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\":21,\n\t\t\t\t\t\t\"source_id\":36,\n\t\t\t\t\t\t\"source_full_name\":\"Root Group / Test Group\",\n\t\t\t\t\t\t\"source_members_url\":\"https://gitlab.example.com/groups/root-group/test-group/-/group_members\",\n\t\t\t\t\t\t\"created_at\":\"2021-03-31T17:28:44.812Z\",\n\t\t\t\t\t\t\"access_level\": {\n\t\t\t\t\t\t\t\"string_value\": \"Developer\",\n\t\t\t\t\t\t\t\"integer_value\": 30\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]`)\n\t\t})\n\n\tmemberships, _, err := client.Groups.ListMembershipsForBillableGroupMember(1, 42, &ListMembershipsForBillableGroupMemberOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListMembershipsForBillableGroupMember returned error: %v\", err)\n\t}\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2021-03-31T17:28:44.812Z\")\n\n\twant := []*BillableUserMembership{\n\t\t{\n\t\t\tID:               21,\n\t\t\tSourceID:         36,\n\t\t\tSourceFullName:   \"Root Group / Test Group\",\n\t\t\tSourceMembersURL: \"https://gitlab.example.com/groups/root-group/test-group/-/group_members\",\n\t\t\tCreatedAt:        &createdAt,\n\t\t\tAccessLevel: &AccessLevelDetails{\n\t\t\t\tIntegerValue: 30,\n\t\t\t\tStringValue:  \"Developer\",\n\t\t\t},\n\t\t},\n\t}\n\tassert.Equal(t, want, memberships, \"Expected returned Groups.ListMembershipsForBillableGroupMember to equal\")\n}\n\nfunc TestListGroupMembersWithoutEmail(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/members\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w,\n\t\t\t\t`[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t\t\t\t\"created_at\": \"2012-10-21T14:13:35Z\",\n\t\t\t\t\t\t\"expires_at\": \"2012-10-22\",\n\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\"group_saml_identity\": null\n\t\t\t\t\t}\n\t\t\t\t]`)\n\t\t})\n\n\tmembers, _, err := client.Groups.ListGroupMembers(1, &ListGroupMembersOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupMembers returned error: %v\", err)\n\t}\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2012-10-21T14:13:35Z\")\n\texpiresAt, _ := time.Parse(time.RFC3339, \"2012-10-22T00:00:00Z\")\n\texpiresAtISOTime := ISOTime(expiresAt)\n\twant := []*GroupMember{\n\t\t{\n\t\t\tID:          1,\n\t\t\tUsername:    \"raymond_smith\",\n\t\t\tName:        \"Raymond Smith\",\n\t\t\tState:       \"active\",\n\t\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\t\tCreatedAt:   &createdAt,\n\t\t\tExpiresAt:   &expiresAtISOTime,\n\t\t\tAccessLevel: 30,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, members) {\n\t\tt.Errorf(\"Groups.ListBillableGroupMembers returned %+v, want %+v\", members[0], want[0])\n\t}\n}\n\nfunc TestListGroupMembersWithEmail(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/members\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w,\n\t\t\t\t`[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t\t\t\t\"created_at\": \"2012-10-21T14:13:35Z\",\n\t\t\t\t\t\t\"expires_at\": \"2012-10-22\",\n\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\"email\": \"john@example.com\",\n\t\t\t\t\t\t\"group_saml_identity\": null\n\t\t\t\t\t}\n\t\t\t\t]`)\n\t\t})\n\n\tmembers, _, err := client.Groups.ListGroupMembers(1, &ListGroupMembersOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupMembers returned error: %v\", err)\n\t}\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2012-10-21T14:13:35Z\")\n\texpiresAt, _ := time.Parse(time.RFC3339, \"2012-10-22T00:00:00Z\")\n\texpiresAtISOTime := ISOTime(expiresAt)\n\twant := []*GroupMember{\n\t\t{\n\t\t\tID:          1,\n\t\t\tUsername:    \"raymond_smith\",\n\t\t\tName:        \"Raymond Smith\",\n\t\t\tState:       \"active\",\n\t\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\t\tCreatedAt:   &createdAt,\n\t\t\tExpiresAt:   &expiresAtISOTime,\n\t\t\tAccessLevel: 30,\n\t\t\tEmail:       \"john@example.com\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, members) {\n\t\tt.Errorf(\"Groups.ListBillableGroupMembers returned %+v, want %+v\", members[0], want[0])\n\t}\n}\n\nfunc TestListGroupMembersWithoutSAML(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/members\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w,\n\t\t\t\t`[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"username\": \"raymond_smith\",\n\t\t\t\t\t\t\"name\": \"Raymond Smith\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t\t\t\t\"created_at\": \"2012-10-21T14:13:35Z\",\n\t\t\t\t\t\t\"expires_at\": \"2012-10-22\",\n\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\"group_saml_identity\": null\n\t\t\t\t\t}\n\t\t\t\t]`)\n\t\t})\n\n\tmembers, _, err := client.Groups.ListGroupMembers(1, &ListGroupMembersOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupMembers returned error: %v\", err)\n\t}\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2012-10-21T14:13:35Z\")\n\texpiresAt, _ := time.Parse(time.RFC3339, \"2012-10-22T00:00:00Z\")\n\texpiresAtISOTime := ISOTime(expiresAt)\n\twant := []*GroupMember{\n\t\t{\n\t\t\tID:                1,\n\t\t\tUsername:          \"raymond_smith\",\n\t\t\tName:              \"Raymond Smith\",\n\t\t\tState:             \"active\",\n\t\t\tAvatarURL:         \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\tWebURL:            \"http://192.168.1.8:3000/root\",\n\t\t\tCreatedAt:         &createdAt,\n\t\t\tExpiresAt:         &expiresAtISOTime,\n\t\t\tAccessLevel:       30,\n\t\t\tGroupSAMLIdentity: nil,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, members) {\n\t\tt.Errorf(\"Groups.ListBillableGroupMembers returned %+v, want %+v\", members[0], want[0])\n\t}\n}\n\nfunc TestListGroupMembersWithSAML(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/members\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w,\n\t\t\t\t`[\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 2,\n\t\t\t\t\t\t\"username\": \"john_doe\",\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t\t\t\t\"created_at\": \"2012-10-21T14:13:35Z\",\n\t\t\t\t\t\t\"expires_at\": \"2012-10-22\",\n\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\"group_saml_identity\": {\n\t\t\t\t\t\t\t\"extern_uid\":\"ABC-1234567890\",\n\t\t\t\t\t\t\t\"provider\": \"group_saml\",\n\t\t\t\t\t\t\t\"saml_provider_id\": 10\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]`)\n\t\t})\n\n\tmembers, _, err := client.Groups.ListGroupMembers(1, &ListGroupMembersOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupMembers returned error: %v\", err)\n\t}\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2012-10-21T14:13:35Z\")\n\texpiresAt, _ := time.Parse(time.RFC3339, \"2012-10-22T00:00:00Z\")\n\texpiresAtISOTime := ISOTime(expiresAt)\n\twant := []*GroupMember{\n\t\t{\n\t\t\tID:          2,\n\t\t\tUsername:    \"john_doe\",\n\t\t\tName:        \"John Doe\",\n\t\t\tState:       \"active\",\n\t\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\t\tCreatedAt:   &createdAt,\n\t\t\tExpiresAt:   &expiresAtISOTime,\n\t\t\tAccessLevel: 30,\n\t\t\tGroupSAMLIdentity: &GroupMemberSAMLIdentity{\n\t\t\t\tExternUID:      \"ABC-1234567890\",\n\t\t\t\tProvider:       \"group_saml\",\n\t\t\t\tSAMLProviderID: 10,\n\t\t\t},\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, members) {\n\t\tt.Errorf(\"Groups.ListBillableGroupMembers returned %+v, want %+v\", members[0], want[0])\n\t}\n}\n\nfunc TestGetGroupMemberCustomRole(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%sgroups/1/members/2\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\n\t\t// This is pulled straight from a `/group/<group_id>/members/<user_id>` call, then obfuscated.\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"id\":1,\n\t\t\t\"username\":\"test\",\n\t\t\t\"name\":\"testName\",\n\t\t\t\"access_level\":30,\n\t\t\t\"member_role\":{\n\t\t\t\t\"id\":1,\n\t\t\t\t\"group_id\":2,\n\t\t\t\t\"name\":\"TestingCustomRole\",\n\t\t\t\t\"description\":\"\",\n\t\t\t\t\"base_access_level\":30,\n\t\t\t\t\"admin_cicd_variables\":true,\n\t\t\t\t\"admin_group_member\":null,\n\t\t\t\t\"admin_merge_request\":null,\n\t\t\t\t\"admin_push_rules\":null,\n\t\t\t\t\"admin_terraform_state\":null,\n\t\t\t\t\"admin_vulnerability\":null,\n\t\t\t\t\"archive_project\":null,\n\t\t\t\t\"manage_group_access_tokens\":null,\n\t\t\t\t\"manage_project_access_tokens\":null,\n\t\t\t\t\"read_code\":null,\n\t\t\t\t\"read_dependency\":null,\n\t\t\t\t\"read_vulnerability\":null,\n\t\t\t\t\"remove_group\":null,\n\t\t\t\t\"remove_project\":null\n\t\t\t}\n\t\t}\n\t\t`)\n\t})\n\n\twant := &GroupMember{\n\t\tID:          1,\n\t\tUsername:    \"test\",\n\t\tName:        \"testName\",\n\t\tAccessLevel: AccessLevelValue(30),\n\t\tMemberRole: &MemberRole{\n\t\t\tID:                 1,\n\t\t\tGroupID:            2,\n\t\t\tName:               \"TestingCustomRole\",\n\t\t\tDescription:        \"\",\n\t\t\tBaseAccessLevel:    AccessLevelValue(30),\n\t\t\tAdminCICDVariables: true,\n\t\t},\n\t}\n\tmember, _, err := client.GroupMembers.GetGroupMember(1, 2)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, member)\n}\n\nfunc TestGetGroupMemberAll(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%sgroups/1/members/all/2\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\": 2,\n\t\t  \"name\": \"aaa\",\n\t\t  \"username\": \"aaaName\",\n\t\t  \"state\": \"active\",\n\t\t  \"avatar_url\": \"https://secure.gravatar.com/avatar/e547676d82f1e16954b2280a5b4cbe79?s=80&d=identicon\",\n\t\t  \"web_url\": \"https://gitlab.example.cn/aaa\",\n\t\t  \"access_level\": 30,\n\t\t  \"created_at\": \"2024-06-19T07:14:02.793Z\",\n\t\t  \"expires_at\": null\n\t\t}\n\t\t`)\n\t})\n\n\tcreateAt, _ := time.Parse(time.RFC3339, \"2024-06-19T07:14:02.793Z\")\n\n\twant := &GroupMember{\n\t\tID:          2,\n\t\tName:        \"aaa\",\n\t\tUsername:    \"aaaName\",\n\t\tState:       \"active\",\n\t\tAvatarURL:   \"https://secure.gravatar.com/avatar/e547676d82f1e16954b2280a5b4cbe79?s=80&d=identicon\",\n\t\tWebURL:      \"https://gitlab.example.cn/aaa\",\n\t\tAccessLevel: AccessLevelValue(30),\n\t\tCreatedAt:   &createAt,\n\t}\n\n\tpm, resp, err := client.GroupMembers.GetInheritedGroupMember(1, 2, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tmember, resp, err := client.GroupMembers.GetInheritedGroupMember(1.01, 2, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, member)\n\n\tmember, resp, err = client.GroupMembers.GetInheritedGroupMember(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, member)\n\n\tmember, resp, err = client.GroupMembers.GetInheritedGroupMember(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, member)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "group_milestones.go",
          "type": "blob",
          "size": 11.0673828125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupMilestonesService handles communication with the milestone related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_milestones.html\ntype GroupMilestonesService struct {\n\tclient *Client\n}\n\n// GroupMilestone represents a GitLab milestone.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_milestones.html\ntype GroupMilestone struct {\n\tID          int        `json:\"id\"`\n\tIID         int        `json:\"iid\"`\n\tGroupID     int        `json:\"group_id\"`\n\tTitle       string     `json:\"title\"`\n\tDescription string     `json:\"description\"`\n\tStartDate   *ISOTime   `json:\"start_date\"`\n\tDueDate     *ISOTime   `json:\"due_date\"`\n\tState       string     `json:\"state\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tExpired     *bool      `json:\"expired\"`\n}\n\nfunc (m GroupMilestone) String() string {\n\treturn Stringify(m)\n}\n\n// ListGroupMilestonesOptions represents the available\n// ListGroupMilestones() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#list-group-milestones\ntype ListGroupMilestonesOptions struct {\n\tListOptions\n\tIIDs                    *[]int   `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tState                   *string  `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tTitle                   *string  `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tSearch                  *string  `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tSearchTitle             *string  `url:\"search_title,omitempty\" json:\"search_title,omitempty\"`\n\tIncludeParentMilestones *bool    `url:\"include_parent_milestones,omitempty\" json:\"include_parent_milestones,omitempty\"`\n\tIncludeAncestors        *bool    `url:\"include_ancestors,omitempty\" json:\"include_ancestors,omitempty\"`\n\tIncludeDescendents      *bool    `url:\"include_descendents,omitempty\" json:\"include_descendents,omitempty\"`\n\tUpdatedBefore           *ISOTime `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tUpdatedAfter            *ISOTime `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tContainingDate          *ISOTime `url:\"containing_date,omitempty\" json:\"containing_date,omitempty\"`\n\tStartDate               *ISOTime `url:\"start_date,omitempty\" json:\"start_date,omitempty\"`\n\tEndDate                 *ISOTime `url:\"end_date,omitempty\" json:\"end_date,omitempty\"`\n}\n\n// ListGroupMilestones returns a list of group milestones.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#list-group-milestones\nfunc (s *GroupMilestonesService) ListGroupMilestones(gid interface{}, opt *ListGroupMilestonesOptions, options ...RequestOptionFunc) ([]*GroupMilestone, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*GroupMilestone\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// GetGroupMilestone gets a single group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-single-milestone\nfunc (s *GroupMilestonesService) GetGroupMilestone(gid interface{}, milestone int, options ...RequestOptionFunc) (*GroupMilestone, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones/%d\", PathEscape(group), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(GroupMilestone)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// CreateGroupMilestoneOptions represents the available CreateGroupMilestone() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#create-new-milestone\ntype CreateGroupMilestoneOptions struct {\n\tTitle       *string  `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription *string  `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tStartDate   *ISOTime `url:\"start_date,omitempty\" json:\"start_date,omitempty\"`\n\tDueDate     *ISOTime `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n}\n\n// CreateGroupMilestone creates a new group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#create-new-milestone\nfunc (s *GroupMilestonesService) CreateGroupMilestone(gid interface{}, opt *CreateGroupMilestoneOptions, options ...RequestOptionFunc) (*GroupMilestone, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(GroupMilestone)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// UpdateGroupMilestoneOptions represents the available UpdateGroupMilestone() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#edit-milestone\ntype UpdateGroupMilestoneOptions struct {\n\tTitle       *string  `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription *string  `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tStartDate   *ISOTime `url:\"start_date,omitempty\" json:\"start_date,omitempty\"`\n\tDueDate     *ISOTime `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tStateEvent  *string  `url:\"state_event,omitempty\" json:\"state_event,omitempty\"`\n}\n\n// UpdateGroupMilestone updates an existing group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#edit-milestone\nfunc (s *GroupMilestonesService) UpdateGroupMilestone(gid interface{}, milestone int, opt *UpdateGroupMilestoneOptions, options ...RequestOptionFunc) (*GroupMilestone, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones/%d\", PathEscape(group), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(GroupMilestone)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// DeleteGroupMilestone deletes a specified group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#delete-group-milestone\nfunc (s *GroupMilestonesService) DeleteGroupMilestone(pid interface{}, milestone int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones/%d\", PathEscape(project), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.client.Do(req, nil)\n}\n\n// GetGroupMilestoneIssuesOptions represents the available GetGroupMilestoneIssues() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-issues-assigned-to-a-single-milestone\ntype GetGroupMilestoneIssuesOptions ListOptions\n\n// GetGroupMilestoneIssues gets all issues assigned to a single group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-issues-assigned-to-a-single-milestone\nfunc (s *GroupMilestonesService) GetGroupMilestoneIssues(gid interface{}, milestone int, opt *GetGroupMilestoneIssuesOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones/%d/issues\", PathEscape(group), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar i []*Issue\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// GetGroupMilestoneMergeRequestsOptions represents the available\n// GetGroupMilestoneMergeRequests() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-merge-requests-assigned-to-a-single-milestone\ntype GetGroupMilestoneMergeRequestsOptions ListOptions\n\n// GetGroupMilestoneMergeRequests gets all merge requests assigned to a\n// single group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-merge-requests-assigned-to-a-single-milestone\nfunc (s *GroupMilestonesService) GetGroupMilestoneMergeRequests(gid interface{}, milestone int, opt *GetGroupMilestoneMergeRequestsOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones/%d/merge_requests\", PathEscape(group), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mr []*MergeRequest\n\tresp, err := s.client.Do(req, &mr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mr, resp, nil\n}\n\n// BurndownChartEvent reprensents a burnout chart event\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-burndown-chart-events-for-a-single-milestone\ntype BurndownChartEvent struct {\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tWeight    *int       `json:\"weight\"`\n\tAction    *string    `json:\"action\"`\n}\n\n// GetGroupMilestoneBurndownChartEventsOptions represents the available\n// GetGroupMilestoneBurndownChartEventsOptions() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-burndown-chart-events-for-a-single-milestone\ntype GetGroupMilestoneBurndownChartEventsOptions ListOptions\n\n// GetGroupMilestoneBurndownChartEvents gets all merge requests assigned to a\n// single group milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_milestones.html#get-all-burndown-chart-events-for-a-single-milestone\nfunc (s *GroupMilestonesService) GetGroupMilestoneBurndownChartEvents(gid interface{}, milestone int, opt *GetGroupMilestoneBurndownChartEventsOptions, options ...RequestOptionFunc) ([]*BurndownChartEvent, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/milestones/%d/burndown_events\", PathEscape(group), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar be []*BurndownChartEvent\n\tresp, err := s.client.Do(req, &be)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn be, resp, nil\n}\n"
        },
        {
          "name": "group_milestones_test.go",
          "type": "blob",
          "size": 17.4814453125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGroupMilestonesService_ListGroupMilestones(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/milestones\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 12,\n\t\t\t\t\"iid\": 3,\n\t\t\t\t\"group_id\": 5,\n\t\t\t\t\"title\": \"10.0\",\n\t\t\t\t\"description\": \"Version\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"expired\": false,\n\t\t\t\t\"web_url\": \"https://gitlab.com/groups/gitlab-org/-/milestones/42\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*GroupMilestone{{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tGroupID:     5,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tExpired:     Ptr(false),\n\t}}\n\n\tgms, resp, err := client.GroupMilestones.ListGroupMilestones(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gms)\n\n\tgms, resp, err = client.GroupMilestones.ListGroupMilestones(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gms)\n\n\tgms, resp, err = client.GroupMilestones.ListGroupMilestones(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gms)\n\n\tgms, resp, err = client.GroupMilestones.ListGroupMilestones(7, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gms)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_GetGroupMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/milestones/12\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 12,\n\t\t\t\"iid\": 3,\n\t\t\t\"group_id\": 5,\n\t\t\t\"title\": \"10.0\",\n\t\t\t\"description\": \"Version\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"expired\": false,\n\t\t\t\"web_url\": \"https://gitlab.com/groups/gitlab-org/-/milestones/42\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &GroupMilestone{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tGroupID:     5,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tExpired:     Ptr(false),\n\t}\n\n\tgm, resp, err := client.GroupMilestones.GetGroupMilestone(5, 12, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gm)\n\n\tgm, resp, err = client.GroupMilestones.GetGroupMilestone(5.01, 12, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gm)\n\n\tgm, resp, err = client.GroupMilestones.GetGroupMilestone(5, 12, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gm)\n\n\tgm, resp, err = client.GroupMilestones.GetGroupMilestone(7, 12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_CreateGroupMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/milestones\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 12,\n\t\t\t\"iid\": 3,\n\t\t\t\"group_id\": 5,\n\t\t\t\"title\": \"10.0\",\n\t\t\t\"description\": \"Version\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"expired\": false,\n\t\t\t\"web_url\": \"https://gitlab.com/groups/gitlab-org/-/milestones/42\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &GroupMilestone{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tGroupID:     5,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tExpired:     Ptr(false),\n\t}\n\n\tgm, resp, err := client.GroupMilestones.CreateGroupMilestone(5, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gm)\n\n\tgm, resp, err = client.GroupMilestones.CreateGroupMilestone(5.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gm)\n\n\tgm, resp, err = client.GroupMilestones.CreateGroupMilestone(5, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gm)\n\n\tgm, resp, err = client.GroupMilestones.CreateGroupMilestone(7, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_UpdateGroupMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/milestones/12\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 12,\n\t\t\t\"iid\": 3,\n\t\t\t\"group_id\": 5,\n\t\t\t\"title\": \"10.0\",\n\t\t\t\"description\": \"Version\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"expired\": false,\n\t\t\t\"web_url\": \"https://gitlab.com/groups/gitlab-org/-/milestones/42\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &GroupMilestone{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tGroupID:     5,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tExpired:     Ptr(false),\n\t}\n\n\tgm, resp, err := client.GroupMilestones.UpdateGroupMilestone(5, 12, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gm)\n\n\tgm, resp, err = client.GroupMilestones.UpdateGroupMilestone(5.01, 12, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gm)\n\n\tgm, resp, err = client.GroupMilestones.UpdateGroupMilestone(5, 12, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gm)\n\n\tgm, resp, err = client.GroupMilestones.UpdateGroupMilestone(7, 12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, gm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_DeleteGroupMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/milestones/12\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.GroupMilestones.DeleteGroupMilestone(5, 12, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.GroupMilestones.DeleteGroupMilestone(5.01, 12, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GroupMilestones.DeleteGroupMilestone(5, 12, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.GroupMilestones.DeleteGroupMilestone(3, 12, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_GetGroupMilestoneIssues(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/5/milestones/12/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t   {\n\t\t\t\t  \"project_id\" : 5,\n\t\t\t\t  \"milestone\" : {\n\t\t\t\t\t \"due_date\" : null,\n\t\t\t\t\t \"project_id\" : 5,\n\t\t\t\t\t \"state\" : \"closed\",\n\t\t\t\t\t \"description\" : \"Rerum est voluptatem provident consequuntur molestias similique ipsum dolor.\",\n\t\t\t\t\t \"iid\" : 3,\n\t\t\t\t\t \"id\" : 11,\n\t\t\t\t\t \"title\" : \"v3.0\"\n\t\t\t\t  },\n\t\t\t\t  \"author\" : {\n\t\t\t\t\t \"state\" : \"active\",\n\t\t\t\t\t \"web_url\" : \"https://gitlab.example.com/root\",\n\t\t\t\t\t \"avatar_url\" : null,\n\t\t\t\t\t \"username\" : \"root\",\n\t\t\t\t\t \"id\" : 1,\n\t\t\t\t\t \"name\" : \"Administrator\"\n\t\t\t\t  },\n\t\t\t\t  \"description\" : \"Omnis vero earum sunt corporis dolor et placeat.\",\n\t\t\t\t  \"state\" : \"closed\",\n\t\t\t\t  \"iid\" : 1,\n\t\t\t\t  \"assignees\" : [{\n\t\t\t\t\t \"avatar_url\" : null,\n\t\t\t\t\t \"web_url\" : \"https://gitlab.example.com/venky333\",\n\t\t\t\t\t \"state\" : \"active\",\n\t\t\t\t\t \"username\" : \"venky333\",\n\t\t\t\t\t \"id\" : 9,\n\t\t\t\t\t \"name\" : \"Venkatesh Thalluri\"\n\t\t\t\t  }],\n\t\t\t\t  \"assignee\" : {\n\t\t\t\t\t \"avatar_url\" : null,\n\t\t\t\t\t \"web_url\" : \"https://gitlab.example.com/venky333\",\n\t\t\t\t\t \"state\" : \"active\",\n\t\t\t\t\t \"username\" : \"venky333\",\n\t\t\t\t\t \"id\" : 9,\n\t\t\t\t\t \"name\" : \"Venkatesh Thalluri\"\n\t\t\t\t  },\n\t\t\t\t  \"id\" : 41\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Issue{{\n\t\tID:          41,\n\t\tIID:         1,\n\t\tExternalID:  \"\",\n\t\tState:       \"closed\",\n\t\tDescription: \"Omnis vero earum sunt corporis dolor et placeat.\",\n\t\tAuthor: &IssueAuthor{\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"root\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          11,\n\t\t\tIID:         3,\n\t\t\tProjectID:   5,\n\t\t\tTitle:       \"v3.0\",\n\t\t\tDescription: \"Rerum est voluptatem provident consequuntur molestias similique ipsum dolor.\",\n\t\t\tStartDate:   nil,\n\t\t\tDueDate:     nil,\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"\",\n\t\t\tUpdatedAt:   nil,\n\t\t\tCreatedAt:   nil,\n\t\t\tExpired:     nil,\n\t\t},\n\t\tProjectID: 5,\n\t\tAssignees: []*IssueAssignee{{\n\t\t\tID:        9,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/venky333\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"venky333\",\n\t\t}},\n\t\tAssignee: &IssueAssignee{\n\t\t\tID:        9,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/venky333\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"venky333\",\n\t\t},\n\t}}\n\n\tis, resp, err := client.GroupMilestones.GetGroupMilestoneIssues(5, 12, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, is)\n\n\tis, resp, err = client.GroupMilestones.GetGroupMilestoneIssues(5.01, 12, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.GroupMilestones.GetGroupMilestoneIssues(5, 12, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.GroupMilestones.GetGroupMilestoneIssues(7, 12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, is)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_GetGroupMilestoneMergeRequests(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/3/milestones/12/merge_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"iid\": 1,\n\t\t\t\t\"project_id\": 3,\n\t\t\t\t\"title\": \"test1\",\n\t\t\t\t\"description\": \"fixed login page css paddings\",\n\t\t\t\t\"state\": \"merged\",\n\t\t\t\t\"merged_by\": {\n\t\t\t\t  \"id\": 87854,\n\t\t\t\t  \"name\": \"Douwe Maan\",\n\t\t\t\t  \"username\": \"DouweM\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://gitlab.example.com/uploads/-/system/user/avatar/87854/avatar.png\",\n\t\t\t\t  \"web_url\": \"https://gitlab.com/DouweM\"\n\t\t\t\t},\n\t\t\t\t\"closed_by\": null,\n\t\t\t\t\"closed_at\": null,\n\t\t\t\t\"target_branch\": \"master\",\n\t\t\t\t\"source_branch\": \"test1\",\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"admin\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": null,\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/admin\"\n\t\t\t\t},\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"admin\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": null,\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/admin\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venkatesh.thalluri\",\n\t\t\t\t  \"id\": 12,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/46f6f7dc858ada7be1853f7fb96e81da?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/axel.block\"\n\t\t\t\t}],\n\t\t\t\t\"reviewers\": [{\n\t\t\t\t  \"id\": 2,\n\t\t\t\t  \"name\": \"Sam Bauch\",\n\t\t\t\t  \"username\": \"kenyatta_oconnell\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/956c92487c6f6f7616b536927e22c9a0?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com//kenyatta_oconnell\"\n\t\t\t\t}],\n\t\t\t\t\"source_project_id\": 2,\n\t\t\t\t\"target_project_id\": 3,\n\t\t\t\t\"draft\": false,\n\t\t\t\t\"work_in_progress\": false,\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"iid\": 1,\n\t\t\t\t  \"project_id\": 3,\n\t\t\t\t  \"title\": \"v2.0\",\n\t\t\t\t  \"description\": \"Assumenda aut placeat expedita exercitationem labore sunt enim earum.\",\n\t\t\t\t  \"state\": \"closed\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/my-group/my-project/milestones/1\"\n\t\t\t\t},\n\t\t\t\t\"merge_when_pipeline_succeeds\": true,\n\t\t\t\t\"detailed_merge_status\": \"mergeable\",\n\t\t\t\t\"sha\": \"8888888888888888888888888888888888888888\",\n\t\t\t\t\"merge_commit_sha\": null,\n\t\t\t\t\"squash_commit_sha\": null,\n\t\t\t\t\"user_notes_count\": 1,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"should_remove_source_branch\": true,\n\t\t\t\t\"force_remove_source_branch\": false,\n\t\t\t\t\"allow_collaboration\": false,\n\t\t\t\t\"allow_maintainer_to_push\": false,\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/my-group/my-project/merge_requests/1\",\n\t\t\t\t\"references\": {\n\t\t\t\t  \"short\": \"!1\",\n\t\t\t\t  \"relative\": \"my-group/my-project!1\",\n\t\t\t\t  \"full\": \"my-group/my-project!1\"\n\t\t\t\t},\n\t\t\t\t\"squash\": false,\n\t\t\t\t\"task_completion_status\":{\n\t\t\t\t  \"count\":0,\n\t\t\t\t  \"completed_count\":0\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*MergeRequest{{\n\t\tID:           1,\n\t\tIID:          1,\n\t\tTargetBranch: \"master\",\n\t\tSourceBranch: \"test1\",\n\t\tProjectID:    3,\n\t\tTitle:        \"test1\",\n\t\tState:        \"merged\",\n\t\tUpvotes:      0,\n\t\tDownvotes:    0,\n\t\tAuthor: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"admin\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tCreatedAt: nil,\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"https://gitlab.example.com/admin\",\n\t\t},\n\t\tAssignee: &BasicUser{\n\t\t\tID: 1, Username: \"admin\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"https://gitlab.example.com/admin\",\n\t\t},\n\t\tAssignees: []*BasicUser{{\n\t\t\tID:        12,\n\t\t\tUsername:  \"venkatesh.thalluri\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/46f6f7dc858ada7be1853f7fb96e81da?s=80&d=identicon\", WebURL: \"https://gitlab.example.com/axel.block\",\n\t\t}},\n\t\tReviewers: []*BasicUser{{\n\t\t\tID:        2,\n\t\t\tUsername:  \"kenyatta_oconnell\",\n\t\t\tName:      \"Sam Bauch\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/956c92487c6f6f7616b536927e22c9a0?s=80&d=identicon\", WebURL: \"http://gitlab.example.com//kenyatta_oconnell\",\n\t\t}},\n\t\tSourceProjectID: 2,\n\t\tTargetProjectID: 3,\n\t\tDescription:     \"fixed login page css paddings\",\n\t\tWorkInProgress:  false,\n\t\tMilestone: &Milestone{\n\t\t\tID:          5,\n\t\t\tIID:         1,\n\t\t\tProjectID:   3,\n\t\t\tTitle:       \"v2.0\",\n\t\t\tDescription: \"Assumenda aut placeat expedita exercitationem labore sunt enim earum.\",\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"https://gitlab.example.com/my-group/my-project/milestones/1\",\n\t\t},\n\t\tMergeWhenPipelineSucceeds: true,\n\t\tDetailedMergeStatus:       \"mergeable\",\n\t\tMergeError:                \"\",\n\t\tMergedBy: &BasicUser{\n\t\t\tID:        87854,\n\t\t\tUsername:  \"DouweM\",\n\t\t\tName:      \"Douwe Maan\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://gitlab.example.com/uploads/-/system/user/avatar/87854/avatar.png\",\n\t\t\tWebURL:    \"https://gitlab.com/DouweM\",\n\t\t},\n\t\tSubscribed:               false,\n\t\tSHA:                      \"8888888888888888888888888888888888888888\",\n\t\tMergeCommitSHA:           \"\",\n\t\tSquashCommitSHA:          \"\",\n\t\tUserNotesCount:           1,\n\t\tChangesCount:             \"\",\n\t\tShouldRemoveSourceBranch: true,\n\t\tForceRemoveSourceBranch:  false,\n\t\tAllowCollaboration:       false,\n\t\tWebURL:                   \"http://gitlab.example.com/my-group/my-project/merge_requests/1\",\n\t\tReferences: &IssueReferences{\n\t\t\tShort:    \"!1\",\n\t\t\tRelative: \"my-group/my-project!1\",\n\t\t\tFull:     \"my-group/my-project!1\",\n\t\t},\n\t\tDiscussionLocked:     false,\n\t\tSquash:               false,\n\t\tDivergedCommitsCount: 0,\n\t\tRebaseInProgress:     false,\n\t\tApprovalsBeforeMerge: 0,\n\t\tReference:            \"\",\n\t\tFirstContribution:    false,\n\t\tTaskCompletionStatus: &TasksCompletionStatus{\n\t\t\tCount:          0,\n\t\t\tCompletedCount: 0,\n\t\t},\n\t\tHasConflicts:                false,\n\t\tBlockingDiscussionsResolved: false,\n\t\tOverflow:                    false,\n\t}}\n\n\tmrs, resp, err := client.GroupMilestones.GetGroupMilestoneMergeRequests(3, 12, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, mrs)\n\n\tmrs, resp, err = client.GroupMilestones.GetGroupMilestoneMergeRequests(3.01, 12, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 3.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, mrs)\n\n\tmrs, resp, err = client.GroupMilestones.GetGroupMilestoneMergeRequests(3, 12, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, mrs)\n\n\tmrs, resp, err = client.GroupMilestones.GetGroupMilestoneMergeRequests(7, 12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, mrs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestGroupMilestonesService_GetGroupMilestoneBurndownChartEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/3/milestones/12/burndown_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"weight\": 10,\n\t\t\t\t\t\"action\": \"update\" \n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*BurndownChartEvent{{\n\t\tWeight: Ptr(10),\n\t\tAction: Ptr(\"update\"),\n\t}}\n\n\tbces, resp, err := client.GroupMilestones.GetGroupMilestoneBurndownChartEvents(3, 12, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bces)\n\n\tbces, resp, err = client.GroupMilestones.GetGroupMilestoneBurndownChartEvents(3.01, 12, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 3.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bces)\n\n\tbces, resp, err = client.GroupMilestones.GetGroupMilestoneBurndownChartEvents(3, 12, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bces)\n\n\tbces, resp, err = client.GroupMilestones.GetGroupMilestoneBurndownChartEvents(7, 12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, bces)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "group_protected_environments.go",
          "type": "blob",
          "size": 12.1435546875,
          "content": "//\n// Copyright 2023, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GroupProtectedEnvironmentsService handles communication with the group-level\n// protected environment methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html\ntype GroupProtectedEnvironmentsService struct {\n\tclient *Client\n}\n\n// GroupProtectedEnvironment represents a group-level protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html\ntype GroupProtectedEnvironment struct {\n\tName                  string                               `json:\"name\"`\n\tDeployAccessLevels    []*GroupEnvironmentAccessDescription `json:\"deploy_access_levels\"`\n\tRequiredApprovalCount int                                  `json:\"required_approval_count\"`\n\tApprovalRules         []*GroupEnvironmentApprovalRule      `json:\"approval_rules\"`\n}\n\n// GroupEnvironmentAccessDescription represents the access decription for a\n// group-level protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html\ntype GroupEnvironmentAccessDescription struct {\n\tID                     int              `json:\"id\"`\n\tAccessLevel            AccessLevelValue `json:\"access_level\"`\n\tAccessLevelDescription string           `json:\"access_level_description\"`\n\tUserID                 int              `json:\"user_id\"`\n\tGroupID                int              `json:\"group_id\"`\n\tGroupInheritanceType   int              `json:\"group_inheritance_type\"`\n}\n\n// GroupEnvironmentApprovalRule represents the approval rules for a group-level\n// protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#protect-a-single-environment\ntype GroupEnvironmentApprovalRule struct {\n\tID                     int              `json:\"id\"`\n\tUserID                 int              `json:\"user_id\"`\n\tGroupID                int              `json:\"group_id\"`\n\tAccessLevel            AccessLevelValue `json:\"access_level\"`\n\tAccessLevelDescription string           `json:\"access_level_description\"`\n\tRequiredApprovalCount  int              `json:\"required_approvals\"`\n\tGroupInheritanceType   int              `json:\"group_inheritance_type\"`\n}\n\n// ListGroupProtectedEnvironmentsOptions represents the available\n// ListGroupProtectedEnvironments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#list-group-level-protected-environments\ntype ListGroupProtectedEnvironmentsOptions ListOptions\n\n// ListGroupProtectedEnvironments returns a list of protected environments from\n// a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#list-group-level-protected-environments\nfunc (s *GroupProtectedEnvironmentsService) ListGroupProtectedEnvironments(gid interface{}, opt *ListGroupProtectedEnvironmentsOptions, options ...RequestOptionFunc) ([]*GroupProtectedEnvironment, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/protected_environments\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pes []*GroupProtectedEnvironment\n\tresp, err := s.client.Do(req, &pes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pes, resp, nil\n}\n\n// GetGroupProtectedEnvironment returns a single group-level protected\n// environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#get-a-single-protected-environment\nfunc (s *GroupProtectedEnvironmentsService) GetGroupProtectedEnvironment(gid interface{}, environment string, options ...RequestOptionFunc) (*GroupProtectedEnvironment, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/protected_environments/%s\", PathEscape(group), environment)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpe := new(GroupProtectedEnvironment)\n\tresp, err := s.client.Do(req, pe)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pe, resp, nil\n}\n\n// ProtectGroupEnvironmentOptions represents the available\n// ProtectGroupEnvironment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#protect-a-single-environment\ntype ProtectGroupEnvironmentOptions struct {\n\tName                  *string                                 `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDeployAccessLevels    *[]*GroupEnvironmentAccessOptions       `url:\"deploy_access_levels,omitempty\" json:\"deploy_access_levels,omitempty\"`\n\tRequiredApprovalCount *int                                    `url:\"required_approval_count,omitempty\" json:\"required_approval_count,omitempty\"`\n\tApprovalRules         *[]*GroupEnvironmentApprovalRuleOptions `url:\"approval_rules,omitempty\" json:\"approval_rules,omitempty\"`\n}\n\n// GroupEnvironmentAccessOptions represents the options for an access decription\n// for a group-level protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#protect-a-single-environment\ntype GroupEnvironmentAccessOptions struct {\n\tAccessLevel          *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tUserID               *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID              *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tGroupInheritanceType *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n}\n\n// GroupEnvironmentApprovalRuleOptions represents the approval rules for a\n// group-level protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#protect-a-single-environment\ntype GroupEnvironmentApprovalRuleOptions struct {\n\tUserID                 *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID                *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tAccessLevel            *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tAccessLevelDescription *string           `url:\"access_level_description,omitempty\" json:\"access_level_description,omitempty\"`\n\tRequiredApprovalCount  *int              `url:\"required_approvals,omitempty\" json:\"required_approvals,omitempty\"`\n\tGroupInheritanceType   *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n}\n\n// ProtectGroupEnvironment protects a single group-level environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#protect-a-single-environment\nfunc (s *GroupProtectedEnvironmentsService) ProtectGroupEnvironment(gid interface{}, opt *ProtectGroupEnvironmentOptions, options ...RequestOptionFunc) (*GroupProtectedEnvironment, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/protected_environments\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpe := new(GroupProtectedEnvironment)\n\tresp, err := s.client.Do(req, pe)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pe, resp, nil\n}\n\n// UpdateGroupProtectedEnvironmentOptions represents the available\n// UpdateGroupProtectedEnvironment() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#update-a-protected-environment\ntype UpdateGroupProtectedEnvironmentOptions struct {\n\tName                  *string                                       `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDeployAccessLevels    *[]*UpdateGroupEnvironmentAccessOptions       `url:\"deploy_access_levels,omitempty\" json:\"deploy_access_levels,omitempty\"`\n\tRequiredApprovalCount *int                                          `url:\"required_approval_count,omitempty\" json:\"required_approval_count,omitempty\"`\n\tApprovalRules         *[]*UpdateGroupEnvironmentApprovalRuleOptions `url:\"approval_rules,omitempty\" json:\"approval_rules,omitempty\"`\n}\n\n// UpdateGroupEnvironmentAccessOptions represents the options for updates to the\n// access decription for a group-level protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#update-a-protected-environment\ntype UpdateGroupEnvironmentAccessOptions struct {\n\tAccessLevel          *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tID                   *int              `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tUserID               *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID              *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tGroupInheritanceType *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n\tDestroy              *bool             `url:\"_destroy,omitempty\" json:\"_destroy,omitempty\"`\n}\n\n// UpdateGroupEnvironmentApprovalRuleOptions represents the updates to the\n// approval rules for a group-level protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#update-a-protected-environment\ntype UpdateGroupEnvironmentApprovalRuleOptions struct {\n\tID                     *int              `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tUserID                 *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID                *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tAccessLevel            *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tAccessLevelDescription *string           `url:\"access_level_description,omitempty\" json:\"access_level_description,omitempty\"`\n\tRequiredApprovalCount  *int              `url:\"required_approvals,omitempty\" json:\"required_approvals,omitempty\"`\n\tGroupInheritanceType   *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n\tDestroy                *bool             `url:\"_destroy,omitempty\" json:\"_destroy,omitempty\"`\n}\n\n// UpdateGroupProtectedEnvironment updates a single group-level protected\n// environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#update-a-protected-environment\nfunc (s *GroupProtectedEnvironmentsService) UpdateGroupProtectedEnvironment(gid interface{}, environment string, opt *UpdateGroupProtectedEnvironmentOptions, options ...RequestOptionFunc) (*GroupProtectedEnvironment, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/protected_environments/%s\", PathEscape(group), environment)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpe := new(GroupProtectedEnvironment)\n\tresp, err := s.client.Do(req, pe)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pe, resp, nil\n}\n\n// UnprotectGroupEnvironment unprotects the given protected group-level\n// environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_protected_environments.html#unprotect-a-single-environment\nfunc (s *GroupProtectedEnvironmentsService) UnprotectGroupEnvironment(gid interface{}, environment string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/protected_environments/%s\", PathEscape(group), environment)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_protected_environments_test.go",
          "type": "blob",
          "size": 16.546875,
          "content": "//\n// Copyright 2023, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGroupListProtectedEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/protected_environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\n      \"name\":\"staging\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 40,\n          \"access_level_description\": \"Maintainers\",\n          \"group_inheritance_type\": 0\n        }\n      ],\n      \"required_approval_count\": 1,\n      \"approval_rules\": [\n        {\n           \"id\": 38,\n           \"user_id\": 42,\n           \"group_id\": null,\n           \"access_level\": null,\n           \"access_level_description\": \"qa-group\",\n           \"required_approvals\": 1,\n           \"group_inheritance_type\": 0\n        },\n        {\n           \"id\": 39,\n           \"user_id\": null,\n           \"group_id\": 135,\n           \"access_level\": 30,\n           \"access_level_description\": \"security-group\",\n           \"required_approvals\": 2,\n           \"group_inheritance_type\": 1\n        }\n      ]\n    },{\n      \"name\":\"production\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ]\n    }]`)\n\t})\n\n\texpected := []*GroupProtectedEnvironment{\n\t\t{\n\t\t\tName: \"staging\",\n\t\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequiredApprovalCount: 1,\n\t\t\tApprovalRules: []*GroupEnvironmentApprovalRule{\n\t\t\t\t{\n\t\t\t\t\tID:                     38,\n\t\t\t\t\tUserID:                 42,\n\t\t\t\t\tAccessLevelDescription: \"qa-group\",\n\t\t\t\t\tRequiredApprovalCount:  1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                     39,\n\t\t\t\t\tGroupID:                135,\n\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\tAccessLevelDescription: \"security-group\",\n\t\t\t\t\tRequiredApprovalCount:  2,\n\t\t\t\t\tGroupInheritanceType:   1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"production\",\n\t\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &ListGroupProtectedEnvironmentsOptions{}\n\tenvironments, _, err := client.GroupProtectedEnvironments.ListGroupProtectedEnvironments(1, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environments)\n}\n\nfunc TestGroupGetProtectedEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Test with RequiredApprovalCount\n\tenvironmentName := \"development\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/1/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ],\n      \"required_approval_count\": 1,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected := &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   1,\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 1,\n\t\tApprovalRules: []*GroupEnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err := client.GroupProtectedEnvironments.GetGroupProtectedEnvironment(1, environmentName)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test without RequiredApprovalCount nor ApprovalRules\n\tenvironmentName = \"testing\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/2/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected = &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   1,\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err = client.GroupProtectedEnvironments.GetGroupProtectedEnvironment(2, environmentName)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n}\n\nfunc TestGroupProtectEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Test with RequiredApprovalCount and ApprovalRules\n\tenvironmentName := \"other\"\n\n\tmux.HandleFunc(\"/api/v4/groups/1/protected_environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 0\n        }\n      ],\n      \"required_approval_count\": 2,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected := &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t\tApprovalRules: []*GroupEnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &ProtectGroupEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*GroupEnvironmentAccessOptions{\n\t\t\t{AccessLevel: Ptr(AccessLevelValue(30))},\n\t\t},\n\t\tRequiredApprovalCount: Ptr(2),\n\t\tApprovalRules: &[]*GroupEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tGroupID:                Ptr(10),\n\t\t\t\tAccessLevel:            Ptr(AccessLevelValue(0)),\n\t\t\t\tAccessLevelDescription: Ptr(\"devops\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err := client.GroupProtectedEnvironments.ProtectGroupEnvironment(1, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test without RequiredApprovalCount nor ApprovalRules\n\tenvironmentName = \"staging\"\n\n\tmux.HandleFunc(\"/api/v4/groups/2/protected_environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected = &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt = &ProtectGroupEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*GroupEnvironmentAccessOptions{\n\t\t\t{AccessLevel: Ptr(AccessLevelValue(30))},\n\t\t},\n\t}\n\tenvironment, _, err = client.GroupProtectedEnvironments.ProtectGroupEnvironment(2, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n}\n\nfunc TestGroupUpdateProtectedEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Test with DeployAccessLevels, RequiredApprovalCount, and ApprovalRules as if adding new to existing protected environment\n\tenvironmentName := \"other\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/1/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ],\n      \"required_approval_count\": 2,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected := &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   1,\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t\tApprovalRules: []*GroupEnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &UpdateGroupProtectedEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*UpdateGroupEnvironmentAccessOptions{\n\t\t\t{\n\t\t\t\tAccessLevel:          Ptr(AccessLevelValue(30)),\n\t\t\t\tGroupInheritanceType: Ptr(1),\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: Ptr(2),\n\t\tApprovalRules: &[]*UpdateGroupEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tGroupID:                Ptr(10),\n\t\t\t\tAccessLevel:            Ptr(AccessLevelValue(5)),\n\t\t\t\tAccessLevelDescription: Ptr(\"devops\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err := client.GroupProtectedEnvironments.UpdateGroupProtectedEnvironment(1, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test with DeployAccessLevels only, as if adding new to existing protected environment\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/2/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected = &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt = &UpdateGroupProtectedEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*UpdateGroupEnvironmentAccessOptions{\n\t\t\t{AccessLevel: Ptr(AccessLevelValue(30))},\n\t\t},\n\t}\n\tenvironment, _, err = client.GroupProtectedEnvironments.UpdateGroupProtectedEnvironment(2, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test update to DeployAccessLevel\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/3/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 0\n        }\n      ],\n\t  \"required_approval_count\": 2\n    }`, environmentName)\n\t})\n\n\texpected = &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   0,\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t}\n\n\topt = &UpdateGroupProtectedEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*UpdateGroupEnvironmentAccessOptions{\n\t\t\t{\n\t\t\t\tID:                   Ptr(42),\n\t\t\t\tAccessLevel:          Ptr(AccessLevelValue(30)),\n\t\t\t\tGroupInheritanceType: Ptr(0),\n\t\t\t},\n\t\t},\n\t}\n\tenvironment, _, err = client.GroupProtectedEnvironments.UpdateGroupProtectedEnvironment(3, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test update to ApprovalRules\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/4/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ],\n      \"required_approval_count\": 2,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected = &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t\tApprovalRules: []*GroupEnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt = &UpdateGroupProtectedEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tApprovalRules: &[]*UpdateGroupEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tID:                     Ptr(1),\n\t\t\t\tGroupID:                Ptr(10),\n\t\t\t\tAccessLevel:            Ptr(AccessLevelValue(5)),\n\t\t\t\tAccessLevelDescription: Ptr(\"devops\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err = client.GroupProtectedEnvironments.UpdateGroupProtectedEnvironment(4, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test destroy ApprovalRule\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/groups/5/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ],\n      \"required_approval_count\": 0,\n      \"approval_rules\": []\n    }`, environmentName)\n\t})\n\n\texpected = &GroupProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*GroupEnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 0,\n\t\tApprovalRules:         []*GroupEnvironmentApprovalRule{},\n\t}\n\n\topt = &UpdateGroupProtectedEnvironmentOptions{\n\t\tName: Ptr(environmentName),\n\t\tApprovalRules: &[]*UpdateGroupEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tID:      Ptr(1),\n\t\t\t\tDestroy: Ptr(true),\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: Ptr(0),\n\t}\n\n\tenvironment, _, err = client.GroupProtectedEnvironments.UpdateGroupProtectedEnvironment(5, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n}\n\nfunc TestGroupUnprotectEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/protected_environments/staging\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.GroupProtectedEnvironments.UnprotectGroupEnvironment(1, \"staging\")\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n}\n"
        },
        {
          "name": "group_repository_storage_move.go",
          "type": "blob",
          "size": 7.013671875,
          "content": "//\n// Copyright 2023, Nick Westbury\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupRepositoryStorageMoveService handles communication with the\n// group repositories related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html\ntype GroupRepositoryStorageMoveService struct {\n\tclient *Client\n}\n\n// GroupRepositoryStorageMove represents the status of a repository move.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html\ntype GroupRepositoryStorageMove struct {\n\tID                     int              `json:\"id\"`\n\tCreatedAt              *time.Time       `json:\"created_at\"`\n\tState                  string           `json:\"state\"`\n\tSourceStorageName      string           `json:\"source_storage_name\"`\n\tDestinationStorageName string           `json:\"destination_storage_name\"`\n\tGroup                  *RepositoryGroup `json:\"group\"`\n}\n\ntype RepositoryGroup struct {\n\tID     int    `json:\"id\"`\n\tName   string `json:\"name\"`\n\tWebURL string `json:\"web_url\"`\n}\n\n// RetrieveAllGroupStorageMovesOptions represents the available\n// RetrieveAllStorageMoves() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#retrieve-all-group-repository-storage-moves\ntype RetrieveAllGroupStorageMovesOptions ListOptions\n\n// RetrieveAllStorageMoves retrieves all group repository storage moves\n// accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#retrieve-all-group-repository-storage-moves\nfunc (g GroupRepositoryStorageMoveService) RetrieveAllStorageMoves(opts RetrieveAllGroupStorageMovesOptions, options ...RequestOptionFunc) ([]*GroupRepositoryStorageMove, *Response, error) {\n\treq, err := g.client.NewRequest(http.MethodGet, \"group_repository_storage_moves\", opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gsms []*GroupRepositoryStorageMove\n\tresp, err := g.client.Do(req, &gsms)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gsms, resp, err\n}\n\n// RetrieveAllStorageMovesForGroup retrieves all repository storage moves for\n// a single group accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#retrieve-all-repository-storage-moves-for-a-single-group\nfunc (g GroupRepositoryStorageMoveService) RetrieveAllStorageMovesForGroup(group int, opts RetrieveAllGroupStorageMovesOptions, options ...RequestOptionFunc) ([]*GroupRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"groups/%d/repository_storage_moves\", group)\n\n\treq, err := g.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gsms []*GroupRepositoryStorageMove\n\tresp, err := g.client.Do(req, &gsms)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gsms, resp, err\n}\n\n// GetStorageMove gets a single group repository storage move.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#get-a-single-group-repository-storage-move\nfunc (g GroupRepositoryStorageMoveService) GetStorageMove(repositoryStorage int, options ...RequestOptionFunc) (*GroupRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"group_repository_storage_moves/%d\", repositoryStorage)\n\n\treq, err := g.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgsm := new(GroupRepositoryStorageMove)\n\tresp, err := g.client.Do(req, gsm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gsm, resp, err\n}\n\n// GetStorageMoveForGroup gets a single repository storage move for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#get-a-single-repository-storage-move-for-a-group\nfunc (g GroupRepositoryStorageMoveService) GetStorageMoveForGroup(group int, repositoryStorage int, options ...RequestOptionFunc) (*GroupRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"groups/%d/repository_storage_moves/%d\", group, repositoryStorage)\n\n\treq, err := g.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgsm := new(GroupRepositoryStorageMove)\n\tresp, err := g.client.Do(req, gsm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gsm, resp, err\n}\n\n// ScheduleStorageMoveForGroupOptions represents the available\n// ScheduleStorageMoveForGroup() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#schedule-a-repository-storage-move-for-a-group\ntype ScheduleStorageMoveForGroupOptions struct {\n\tDestinationStorageName *string `url:\"destination_storage_name,omitempty\" json:\"destination_storage_name,omitempty\"`\n}\n\n// ScheduleStorageMoveForGroup schedule a repository to be moved for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#schedule-a-repository-storage-move-for-a-group\nfunc (g GroupRepositoryStorageMoveService) ScheduleStorageMoveForGroup(group int, opts ScheduleStorageMoveForGroupOptions, options ...RequestOptionFunc) (*GroupRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"groups/%d/repository_storage_moves\", group)\n\n\treq, err := g.client.NewRequest(http.MethodPost, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgsm := new(GroupRepositoryStorageMove)\n\tresp, err := g.client.Do(req, gsm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gsm, resp, err\n}\n\n// ScheduleAllGroupStorageMovesOptions represents the available\n// ScheduleAllStorageMoves() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#schedule-repository-storage-moves-for-all-groups-on-a-storage-shard\ntype ScheduleAllGroupStorageMovesOptions struct {\n\tSourceStorageName      *string `url:\"source_storage_name,omitempty\" json:\"source_storage_name,omitempty\"`\n\tDestinationStorageName *string `url:\"destination_storage_name,omitempty\" json:\"destination_storage_name,omitempty\"`\n}\n\n// ScheduleAllStorageMoves schedules all group repositories to be moved.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_repository_storage_moves.html#schedule-repository-storage-moves-for-all-groups-on-a-storage-shard\nfunc (g GroupRepositoryStorageMoveService) ScheduleAllStorageMoves(opts ScheduleAllGroupStorageMovesOptions, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := g.client.NewRequest(http.MethodPost, \"group_repository_storage_moves\", opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn g.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_repository_storage_move_test.go",
          "type": "blob",
          "size": 5.302734375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGroupRepositoryStorageMove_RetrieveAllGroupStorageMoves(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/group_repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"group\":{\n\t\t\t\"id\":283,\n\t\t\t\"Name\":\"Test Group\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group\"\n\t\t  }\n\t\t},\n\t\t{\n\t\t  \"id\":122,\n\t\t  \"state\":\"finished\",\n\t\t  \"group\":{\n\t\t\t\"id\":284,\n\t\t\t\"Name\":\"Test Group 2\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group_2\"\n\t\t  }\n\t\t}]`)\n\t})\n\n\topts := RetrieveAllGroupStorageMovesOptions{Page: 1, PerPage: 2}\n\n\tgsms, _, err := client.GroupRepositoryStorageMove.RetrieveAllStorageMoves(opts)\n\trequire.NoError(t, err)\n\n\twant := []*GroupRepositoryStorageMove{\n\t\t{\n\t\t\tID:    123,\n\t\t\tState: \"scheduled\",\n\t\t\tGroup: &RepositoryGroup{\n\t\t\t\tID:     283,\n\t\t\t\tName:   \"Test Group\",\n\t\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:    122,\n\t\t\tState: \"finished\",\n\t\t\tGroup: &RepositoryGroup{\n\t\t\t\tID:     284,\n\t\t\t\tName:   \"Test Group 2\",\n\t\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group_2\",\n\t\t\t},\n\t\t},\n\t}\n\trequire.Equal(t, want, gsms)\n}\n\nfunc TestGroupRepositoryStorageMove_RetrieveAllStorageMovesForGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/283/repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"group\":{\n\t\t\t\"id\":283,\n\t\t\t\"Name\":\"Test Group\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group\"\n\t\t  }\n\t\t},\n\t\t{\n\t\t  \"id\":122,\n\t\t  \"state\":\"finished\",\n\t\t  \"group\":{\n\t\t\t\"id\":283,\n\t\t\t\"Name\":\"Test Group\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group\"\n\t\t  }\n\t\t}]`)\n\t})\n\n\topts := RetrieveAllGroupStorageMovesOptions{Page: 1, PerPage: 2}\n\n\tgsms, _, err := client.GroupRepositoryStorageMove.RetrieveAllStorageMovesForGroup(283, opts)\n\trequire.NoError(t, err)\n\n\twant := []*GroupRepositoryStorageMove{\n\t\t{\n\t\t\tID:    123,\n\t\t\tState: \"scheduled\",\n\t\t\tGroup: &RepositoryGroup{\n\t\t\t\tID:     283,\n\t\t\t\tName:   \"Test Group\",\n\t\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:    122,\n\t\t\tState: \"finished\",\n\t\t\tGroup: &RepositoryGroup{\n\t\t\t\tID:     283,\n\t\t\t\tName:   \"Test Group\",\n\t\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group\",\n\t\t\t},\n\t\t},\n\t}\n\trequire.Equal(t, want, gsms)\n}\n\nfunc TestGroupRepositoryStorageMove_GetStorageMove(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/group_repository_storage_moves/123\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"group\":{\n\t\t\t\"id\":283,\n\t\t\t\"Name\":\"Test Group\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tgsm, _, err := client.GroupRepositoryStorageMove.GetStorageMove(123)\n\trequire.NoError(t, err)\n\n\twant := &GroupRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tGroup: &RepositoryGroup{\n\t\t\tID:     283,\n\t\t\tName:   \"Test Group\",\n\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group\",\n\t\t},\n\t}\n\trequire.Equal(t, want, gsm)\n}\n\nfunc TestGroupRepositoryStorageMove_GetStorageMoveForGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/283/repository_storage_moves/123\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"group\":{\n\t\t\t\"id\":283,\n\t\t\t\"Name\":\"Test Group\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tgsm, _, err := client.GroupRepositoryStorageMove.GetStorageMoveForGroup(283, 123)\n\trequire.NoError(t, err)\n\n\twant := &GroupRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tGroup: &RepositoryGroup{\n\t\t\tID:     283,\n\t\t\tName:   \"Test Group\",\n\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group\",\n\t\t},\n\t}\n\trequire.Equal(t, want, gsm)\n}\n\nfunc TestGroupRepositoryStorageMove_ScheduleStorageMoveForGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/283/repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"group\":{\n\t\t\t\"id\":283,\n\t\t\t\"Name\":\"Test Group\",\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test_group\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.GroupRepositoryStorageMove.ScheduleStorageMoveForGroup(283, ScheduleStorageMoveForGroupOptions{})\n\trequire.NoError(t, err)\n\n\twant := &GroupRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tGroup: &RepositoryGroup{\n\t\t\tID:     283,\n\t\t\tName:   \"Test Group\",\n\t\t\tWebURL: \"https://gitlab.example.com/groups/test_group\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestGroupRepositoryStorageMove_ScheduleAllStorageMoves(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/group_repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"message\": \"202 Accepted\"}`)\n\t})\n\n\t_, err := client.GroupRepositoryStorageMove.ScheduleAllStorageMoves(\n\t\tScheduleAllGroupStorageMovesOptions{\n\t\t\tSourceStorageName: Ptr(\"default\"),\n\t\t},\n\t)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "group_serviceaccounts.go",
          "type": "blob",
          "size": 6.0654296875,
          "content": "//\n// Copyright 2023, James Hong\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// GroupServiceAccount represents a GitLab service account user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#create-service-account-user\ntype GroupServiceAccount struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tUserName string `json:\"username\"`\n}\n\n// ListServiceAccountsOptions represents the available ListServiceAccounts() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_service_accounts.html#list-service-account-users\ntype ListServiceAccountsOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListServiceAccounts gets a list of service acxcounts.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_service_accounts.html#list-service-account-users\nfunc (s *GroupsService) ListServiceAccounts(gid interface{}, opt *ListServiceAccountsOptions, options ...RequestOptionFunc) ([]*GroupServiceAccount, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/service_accounts\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar sa []*GroupServiceAccount\n\tresp, err := s.client.Do(req, &sa)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn sa, resp, nil\n}\n\n// CreateServiceAccountOptions represents the available CreateServiceAccount() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_service_accounts.html#create-a-service-account-user\ntype CreateServiceAccountOptions struct {\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tUsername *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n}\n\n// Creates a service account user.\n//\n// This API endpoint works on top-level groups only. It does not work on subgroups.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#create-service-account-user\nfunc (s *GroupsService) CreateServiceAccount(gid interface{}, opt *CreateServiceAccountOptions, options ...RequestOptionFunc) (*GroupServiceAccount, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/service_accounts\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsa := new(GroupServiceAccount)\n\tresp, err := s.client.Do(req, sa)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn sa, resp, nil\n}\n\n// CreateServiceAccountPersonalAccessTokenOptions represents the available\n// CreateServiceAccountPersonalAccessToken() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_service_accounts.html#create-a-personal-access-token-for-a-service-account-user\ntype CreateServiceAccountPersonalAccessTokenOptions struct {\n\tScopes    *[]string `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n\tName      *string   `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tExpiresAt *ISOTime  `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// CreateServiceAccountPersonalAccessToken add a new Personal Access Token for a\n// service account user for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_service_accounts.html#create-a-personal-access-token-for-a-service-account-user\nfunc (s *GroupsService) CreateServiceAccountPersonalAccessToken(gid interface{}, serviceAccount int, opt *CreateServiceAccountPersonalAccessTokenOptions, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/service_accounts/%d/personal_access_tokens\", PathEscape(group), serviceAccount)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RotateServiceAccountPersonalAccessToken rotates a Personal Access Token for a\n// service account user for a group.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#create-personal-access-token-for-service-account-user\nfunc (s *GroupsService) RotateServiceAccountPersonalAccessToken(gid interface{}, serviceAccount, token int, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/service_accounts/%d/personal_access_tokens/%d/rotate\", PathEscape(group), serviceAccount, token)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// DeleteServiceAccount Deletes a service account user.\n//\n// This API endpoint works on top-level groups only. It does not work on subgroups.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_service_accounts.html#delete-a-service-account-user\nfunc (s *GroupsService) DeleteServiceAccount(gid interface{}, serviceAccount int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/service_accounts/%d\", PathEscape(group), serviceAccount)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_serviceaccounts_test.go",
          "type": "blob",
          "size": 4.3662109375,
          "content": "//\n// Copyright 2023, James Hong\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestCreateServiceAccount(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/service_accounts\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n      {\n\t      \"id\": 57,\n\t      \"username\": \"service_account_group_345_6018816a18e515214e0c34c2b33523fc\",\n\t      \"name\": \"Service account user\"\n      }`)\n\t})\n\n\tsa, _, err := client.Groups.CreateServiceAccount(1, &CreateServiceAccountOptions{\n\t\tName:     Ptr(\"Service account user\"),\n\t\tUsername: Ptr(\"service_account_group_345_6018816a18e515214e0c34c2b33523fc\"),\n\t})\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\twant := &GroupServiceAccount{\n\t\tID:       57,\n\t\tUserName: \"service_account_group_345_6018816a18e515214e0c34c2b33523fc\",\n\t\tName:     \"Service account user\",\n\t}\n\n\tif !reflect.DeepEqual(sa, want) {\n\t\tt.Errorf(\"CreateServiceAccount returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(sa), Stringify(want))\n\t}\n}\n\nfunc TestCreateServiceAccountPersonalAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/service_accounts/57/personal_access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n      {\n      \t\"id\":6,\n      \t\"name\":\"service_account_token\",\n      \t\"revoked\":false,\n      \t\"created_at\":\"2023-06-13T07:47:13.000Z\",\n      \t\"scopes\":[\"api\"],\n      \t\"user_id\":71,\n      \t\"last_used_at\":null,\n      \t\"active\":true,\n      \t\"expires_at\":\"2024-06-12\",\n      \t\"token\":\"random_token\"\n      }`)\n\t})\n\n\texpireTime, err := ParseISOTime(\"2024-06-12\")\n\trequire.NoError(t, err)\n\n\toptions := &CreateServiceAccountPersonalAccessTokenOptions{\n\t\tScopes:    Ptr([]string{\"api\"}),\n\t\tName:      Ptr(\"service_account_token\"),\n\t\tExpiresAt: Ptr(expireTime),\n\t}\n\tpat, _, err := client.Groups.CreateServiceAccountPersonalAccessToken(1, 57, options)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdatePointer := time.Date(2023, 0o6, 13, 0o7, 47, 13, 0, time.UTC)\n\texpiresAt := ISOTime(time.Date(2024, time.June, 12, 0, 0, 0, 0, time.UTC))\n\n\twant := &PersonalAccessToken{\n\t\tID:         6,\n\t\tName:       \"service_account_token\",\n\t\tRevoked:    false,\n\t\tCreatedAt:  &datePointer,\n\t\tScopes:     []string{\"api\"},\n\t\tUserID:     71,\n\t\tLastUsedAt: nil,\n\t\tActive:     true,\n\t\tExpiresAt:  &expiresAt,\n\t\tToken:      \"random_token\",\n\t}\n\n\tif !reflect.DeepEqual(pat, want) {\n\t\tt.Errorf(\"CreateServiceAccountPersonalAccessToken returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(pat), Stringify(want))\n\t}\n}\n\nfunc TestRotateServiceAccountPersonalAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/service_accounts/57/personal_access_tokens/6/rotate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n      {\n      \t\"id\":7,\n      \t\"name\":\"service_account_token\",\n      \t\"revoked\":false,\n      \t\"created_at\":\"2023-06-13T07:54:49.000Z\",\n      \t\"scopes\":[\"api\"],\n      \t\"user_id\":71,\n      \t\"last_used_at\":null,\n      \t\"active\":true,\n      \t\"expires_at\":\"2025-06-20\",\n      \t\"token\":\"random_token_2\"\n      }`)\n\t})\n\n\tpat, _, err := client.Groups.RotateServiceAccountPersonalAccessToken(1, 57, 6)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\n\tdatePointer := time.Date(2023, 0o6, 13, 0o7, 54, 49, 0, time.UTC)\n\texpiresAt := ISOTime(time.Date(2025, time.June, 20, 0, 0, 0, 0, time.UTC))\n\n\twant := &PersonalAccessToken{\n\t\tID:         7,\n\t\tName:       \"service_account_token\",\n\t\tRevoked:    false,\n\t\tCreatedAt:  &datePointer,\n\t\tScopes:     []string{\"api\"},\n\t\tUserID:     71,\n\t\tLastUsedAt: nil,\n\t\tActive:     true,\n\t\tExpiresAt:  &expiresAt,\n\t\tToken:      \"random_token_2\",\n\t}\n\n\tif !reflect.DeepEqual(pat, want) {\n\t\tt.Errorf(\"RotateServiceAccountPersonalAccessToken returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(pat), Stringify(want))\n\t}\n}\n"
        },
        {
          "name": "group_ssh_certificates.go",
          "type": "blob",
          "size": 3.09765625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// GroupSSHCertificatesService handles communication with the group\n// SSH certificate related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_ssh_certificates.html\ntype GroupSSHCertificatesService struct {\n\tclient *Client\n}\n\n// GroupSSHCertificate represents a GitLab Group SSH certificate.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/member_roles.html\ntype GroupSSHCertificate struct {\n\tID        int        `json:\"id\"`\n\tTitle     string     `json:\"title\"`\n\tKey       string     `json:\"key\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n}\n\n// ListGroupSSHCertificates gets a list of SSH certificates for a specified\n// group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/group_ssh_certificates.html#get-all-ssh-certificates-for-a-particular-group\nfunc (s *GroupSSHCertificatesService) ListGroupSSHCertificates(gid interface{}, options ...RequestOptionFunc) ([]*GroupSSHCertificate, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ssh_certificates\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar certs []*GroupSSHCertificate\n\tresp, err := s.client.Do(req, &certs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn certs, resp, nil\n}\n\n// CreateGroupSSHCertificateOptions represents the available\n// CreateGroupSSHCertificate() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_ssh_certificates.html#create-ssh-certificate\ntype CreateGroupSSHCertificateOptions struct {\n\tKey   *string `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tTitle *string `url:\"title,omitempty\" json:\"title,omitempty\"`\n}\n\n// CreateMemberRole creates a new member role for a specified group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/group_ssh_certificates.html#create-ssh-certificate\nfunc (s *GroupSSHCertificatesService) CreateGroupSSHCertificate(gid interface{}, opt *CreateGroupSSHCertificateOptions, options ...RequestOptionFunc) (*GroupSSHCertificate, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ssh_certificates\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert := new(GroupSSHCertificate)\n\tresp, err := s.client.Do(req, cert)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cert, resp, nil\n}\n\n// DeleteGroupSSHCertificate deletes a SSH certificate from a specified group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/group_ssh_certificates.html#delete-group-ssh-certificate\nfunc (s *GroupSSHCertificatesService) DeleteGroupSSHCertificate(gid interface{}, cert int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ssh_certificates/%d\", PathEscape(group), cert)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_ssh_certificates_test.go",
          "type": "blob",
          "size": 1.8779296875,
          "content": "package gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestListGroupSSHCertificates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/groups/1/ssh_certificates\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_group_ssh_certificates.json\")\n\t})\n\n\tcertificates, _, err := client.GroupSSHCertificates.ListGroupSSHCertificates(1)\n\trequire.NoError(t, err)\n\n\twant := []*GroupSSHCertificate{\n\t\t{\n\t\t\tID:        1876,\n\t\t\tTitle:     \"SSH Certificate\",\n\t\t\tKey:       \"ssh-rsa FAKE-KEY example@gitlab.com\",\n\t\t\tCreatedAt: Ptr(time.Date(2022, time.March, 20, 20, 42, 40, 221000000, time.UTC)),\n\t\t},\n\t}\n\n\trequire.Equal(t, want, certificates)\n}\n\nfunc TestCreateGroupSSHCertificate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/groups/84/ssh_certificates\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_group_ssh_certificates.json\")\n\t})\n\n\tcert, _, err := client.GroupSSHCertificates.CreateGroupSSHCertificate(84, &CreateGroupSSHCertificateOptions{\n\t\tKey:   Ptr(\"ssh-rsa FAKE-KEY example@gitlab.com\"),\n\t\tTitle: Ptr(\"SSH Certificate\"),\n\t})\n\trequire.NoError(t, err)\n\n\twant := &GroupSSHCertificate{\n\t\tID:        1876,\n\t\tTitle:     \"SSH Certificate\",\n\t\tKey:       \"ssh-rsa FAKE-KEY example@gitlab.com\",\n\t\tCreatedAt: Ptr(time.Date(2022, time.March, 20, 20, 42, 40, 221000000, time.UTC)),\n\t}\n\n\trequire.Equal(t, want, cert)\n}\n\nfunc TestDeleteGroupSSHCertificate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/groups/1/ssh_certificates/1876\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.GroupSSHCertificates.DeleteGroupSSHCertificate(1, 1876)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "group_variables.go",
          "type": "blob",
          "size": 7.32421875,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// GroupVariablesService handles communication with the\n// group variables related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html\ntype GroupVariablesService struct {\n\tclient *Client\n}\n\n// GroupVariable represents a GitLab group Variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html\ntype GroupVariable struct {\n\tKey              string            `json:\"key\"`\n\tValue            string            `json:\"value\"`\n\tVariableType     VariableTypeValue `json:\"variable_type\"`\n\tProtected        bool              `json:\"protected\"`\n\tMasked           bool              `json:\"masked\"`\n\tHidden           bool              `json:\"hidden\"`\n\tRaw              bool              `json:\"raw\"`\n\tEnvironmentScope string            `json:\"environment_scope\"`\n\tDescription      string            `json:\"description\"`\n}\n\nfunc (v GroupVariable) String() string {\n\treturn Stringify(v)\n}\n\n// ListGroupVariablesOptions represents the available options for listing variables\n// for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#list-group-variables\ntype ListGroupVariablesOptions ListOptions\n\n// ListVariables gets a list of all variables for a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#list-group-variables\nfunc (s *GroupVariablesService) ListVariables(gid interface{}, opt *ListGroupVariablesOptions, options ...RequestOptionFunc) ([]*GroupVariable, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/variables\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar vs []*GroupVariable\n\tresp, err := s.client.Do(req, &vs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn vs, resp, nil\n}\n\n// GetGroupVariableOptions represents the available GetVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#show-variable-details\ntype GetGroupVariableOptions struct {\n\tFilter *VariableFilter `url:\"filter,omitempty\" json:\"filter,omitempty\"`\n}\n\n// GetVariable gets a variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#show-variable-details\nfunc (s *GroupVariablesService) GetVariable(gid interface{}, key string, opt *GetGroupVariableOptions, options ...RequestOptionFunc) (*GroupVariable, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/variables/%s\", PathEscape(group), url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(GroupVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// CreateGroupVariableOptions represents the available CreateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#create-variable\ntype CreateGroupVariableOptions struct {\n\tKey              *string            `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tValue            *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tDescription      *string            `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tEnvironmentScope *string            `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tMasked           *bool              `url:\"masked,omitempty\" json:\"masked,omitempty\"`\n\tMaskedAndHidden  *bool              `url:\"masked_and_hidden,omitempty\" json:\"hidden,omitempty\"`\n\tProtected        *bool              `url:\"protected,omitempty\" json:\"protected,omitempty\"`\n\tRaw              *bool              `url:\"raw,omitempty\" json:\"raw,omitempty\"`\n\tVariableType     *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// CreateVariable creates a new group variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#create-variable\nfunc (s *GroupVariablesService) CreateVariable(gid interface{}, opt *CreateGroupVariableOptions, options ...RequestOptionFunc) (*GroupVariable, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/variables\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(GroupVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// UpdateGroupVariableOptions represents the available UpdateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#update-variable\ntype UpdateGroupVariableOptions struct {\n\tValue            *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tDescription      *string            `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tEnvironmentScope *string            `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tMasked           *bool              `url:\"masked,omitempty\" json:\"masked,omitempty\"`\n\tProtected        *bool              `url:\"protected,omitempty\" json:\"protected,omitempty\"`\n\tRaw              *bool              `url:\"raw,omitempty\" json:\"raw,omitempty\"`\n\tVariableType     *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// UpdateVariable updates the position of an existing\n// group issue board list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#update-variable\nfunc (s *GroupVariablesService) UpdateVariable(gid interface{}, key string, opt *UpdateGroupVariableOptions, options ...RequestOptionFunc) (*GroupVariable, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/variables/%s\", PathEscape(group), url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(GroupVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// RemoveVariable removes a group's variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_level_variables.html#remove-variable\nfunc (s *GroupVariablesService) RemoveVariable(gid interface{}, key string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/variables/%s\", PathEscape(group), url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_variables_test.go",
          "type": "blob",
          "size": 6.12890625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListGroupVariabless(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[{\"key\": \"TEST_VARIABLE_1\",\"value\": \"test1\",\"protected\": false,\"masked\": true,\"hidden\": true}]`)\n\t\t})\n\n\tvariables, _, err := client.GroupVariables.ListVariables(1, &ListGroupVariablesOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.ListVariables returned error: %v\", err)\n\t}\n\n\twant := []*GroupVariable{\n\t\t{\n\t\t\tKey:       \"TEST_VARIABLE_1\",\n\t\t\tValue:     \"test1\",\n\t\t\tProtected: false,\n\t\t\tMasked:    true,\n\t\t\tHidden:    true,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, variables) {\n\t\tt.Errorf(\"GroupVariables.ListVariablesreturned %+v, want %+v\", variables, want)\n\t}\n}\n\nfunc TestGetGroupVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables/TEST_VARIABLE_1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\ttestParams(t, r, \"filter%5Benvironment_scope%5D=prod\")\n\t\t\tfmt.Fprint(w, `{\"key\": \"TEST_VARIABLE_1\",\"value\": \"test1\",\"protected\": false,\"masked\": true,\"hidden\": false}`)\n\t\t})\n\n\tvariable, _, err := client.GroupVariables.GetVariable(1, \"TEST_VARIABLE_1\", &GetGroupVariableOptions{Filter: &VariableFilter{EnvironmentScope: \"prod\"}})\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.GetVariable returned error: %v\", err)\n\t}\n\n\twant := &GroupVariable{Key: \"TEST_VARIABLE_1\", Value: \"test1\", Protected: false, Masked: true, Hidden: false}\n\tif !reflect.DeepEqual(want, variable) {\n\t\tt.Errorf(\"GroupVariables.GetVariable returned %+v, want %+v\", variable, want)\n\t}\n}\n\nfunc TestCreateGroupVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"key\": \"TEST_VARIABLE_1\",\"value\":\"test1\",\"protected\": false,\"masked\": true,\"hidden\": false}`)\n\t\t})\n\n\topt := &CreateGroupVariableOptions{\n\t\tKey:             Ptr(\"TEST_VARIABLE_1\"),\n\t\tValue:           Ptr(\"test1\"),\n\t\tProtected:       Ptr(false),\n\t\tMasked:          Ptr(true),\n\t\tMaskedAndHidden: Ptr(false),\n\t}\n\n\tvariable, _, err := client.GroupVariables.CreateVariable(1, opt, nil)\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.CreateVariable returned error: %v\", err)\n\t}\n\n\twant := &GroupVariable{Key: \"TEST_VARIABLE_1\", Value: \"test1\", Protected: false, Masked: true, Hidden: false}\n\tif !reflect.DeepEqual(want, variable) {\n\t\tt.Errorf(\"GroupVariables.CreateVariable returned %+v, want %+v\", variable, want)\n\t}\n}\n\nfunc TestCreateGroupVariable_MaskedAndHidden(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"key\": \"TEST_VARIABLE_1\",\"protected\": false,\"masked\": true,\"hidden\": true}`)\n\t\t})\n\n\topt := &CreateGroupVariableOptions{\n\t\tKey:             Ptr(\"TEST_VARIABLE_1\"),\n\t\tValue:           Ptr(\"test1\"),\n\t\tProtected:       Ptr(false),\n\t\tMasked:          Ptr(true),\n\t\tMaskedAndHidden: Ptr(true),\n\t}\n\n\tvariable, _, err := client.GroupVariables.CreateVariable(1, opt, nil)\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.CreateVariable returned error: %v\", err)\n\t}\n\n\twant := &GroupVariable{Key: \"TEST_VARIABLE_1\", Protected: false, Masked: true, Hidden: true}\n\tif !reflect.DeepEqual(want, variable) {\n\t\tt.Errorf(\"GroupVariables.CreateVariable returned %+v, want %+v\", variable, want)\n\t}\n}\n\nfunc TestDeleteGroupVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables/TEST_VARIABLE_1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t})\n\n\tresp, err := client.GroupVariables.RemoveVariable(1, \"TEST_VARIABLE_1\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.RemoveVariable returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"GroupVariables.RemoveVariable returned %d, want %d\", got, want)\n\t}\n}\n\nfunc TestUpdateGroupVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables/TEST_VARIABLE_1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\"key\": \"TEST_VARIABLE_1\",\"value\": \"test1\",\"protected\": false,\"masked\": true,\"hidden\": false}`)\n\t\t})\n\n\tvariable, _, err := client.GroupVariables.UpdateVariable(1, \"TEST_VARIABLE_1\", &UpdateGroupVariableOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.UpdateVariable returned error: %v\", err)\n\t}\n\n\twant := &GroupVariable{Key: \"TEST_VARIABLE_1\", Value: \"test1\", Protected: false, Masked: true, Hidden: false}\n\tif !reflect.DeepEqual(want, variable) {\n\t\tt.Errorf(\"Groups.UpdatedGroup returned %+v, want %+v\", variable, want)\n\t}\n}\n\nfunc TestUpdateGroupVariable_MaskedAndHidden(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/variables/TEST_VARIABLE_1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\"key\": \"TEST_VARIABLE_1\",\"protected\": false,\"masked\": true,\"hidden\": true}`)\n\t\t})\n\n\tvariable, _, err := client.GroupVariables.UpdateVariable(1, \"TEST_VARIABLE_1\", &UpdateGroupVariableOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupVariables.UpdateVariable returned error: %v\", err)\n\t}\n\n\twant := &GroupVariable{Key: \"TEST_VARIABLE_1\", Protected: false, Masked: true, Hidden: true}\n\tif !reflect.DeepEqual(want, variable) {\n\t\tt.Errorf(\"Groups.UpdatedGroup returned %+v, want %+v\", variable, want)\n\t}\n}\n"
        },
        {
          "name": "group_wikis.go",
          "type": "blob",
          "size": 6.1826171875,
          "content": "//\n// Copyright 2021, Markus Lackner\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// GroupWikisService handles communication with the group wikis related methods of\n// the Gitlab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_wikis.html\ntype GroupWikisService struct {\n\tclient *Client\n}\n\n// GroupWiki represents a GitLab groups wiki.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/group_wikis.html\ntype GroupWiki struct {\n\tContent  string          `json:\"content\"`\n\tEncoding string          `json:\"encoding\"`\n\tFormat   WikiFormatValue `json:\"format\"`\n\tSlug     string          `json:\"slug\"`\n\tTitle    string          `json:\"title\"`\n}\n\nfunc (w GroupWiki) String() string {\n\treturn Stringify(w)\n}\n\n// ListGroupWikisOptions represents the available ListGroupWikis options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#list-wiki-pages\ntype ListGroupWikisOptions struct {\n\tWithContent *bool `url:\"with_content,omitempty\" json:\"with_content,omitempty\"`\n}\n\n// ListGroupWikis lists all pages of the wiki of the given group id.\n// When with_content is set, it also returns the content of the pages.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#list-wiki-pages\nfunc (s *GroupWikisService) ListGroupWikis(gid interface{}, opt *ListGroupWikisOptions, options ...RequestOptionFunc) ([]*GroupWiki, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/wikis\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gws []*GroupWiki\n\tresp, err := s.client.Do(req, &gws)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gws, resp, nil\n}\n\n// GetGroupWikiPageOptions represents options to GetGroupWikiPage\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#get-a-wiki-page\ntype GetGroupWikiPageOptions struct {\n\tRenderHTML *bool   `url:\"render_html,omitempty\" json:\"render_html,omitempty\"`\n\tVersion    *string `url:\"version,omitempty\" json:\"version,omitempty\"`\n}\n\n// GetGroupWikiPage gets a wiki page for a given group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#get-a-wiki-page\nfunc (s *GroupWikisService) GetGroupWikiPage(gid interface{}, slug string, opt *GetGroupWikiPageOptions, options ...RequestOptionFunc) (*GroupWiki, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/wikis/%s\", PathEscape(group), url.PathEscape(slug))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgw := new(GroupWiki)\n\tresp, err := s.client.Do(req, gw)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gw, resp, nil\n}\n\n// CreateGroupWikiPageOptions represents options to CreateGroupWikiPage.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#create-a-new-wiki-page\ntype CreateGroupWikiPageOptions struct {\n\tContent *string          `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tTitle   *string          `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFormat  *WikiFormatValue `url:\"format,omitempty\" json:\"format,omitempty\"`\n}\n\n// CreateGroupWikiPage creates a new wiki page for the given group with\n// the given title, slug, and content.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#create-a-new-wiki-page\nfunc (s *GroupWikisService) CreateGroupWikiPage(gid interface{}, opt *CreateGroupWikiPageOptions, options ...RequestOptionFunc) (*GroupWiki, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/wikis\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tw := new(GroupWiki)\n\tresp, err := s.client.Do(req, w)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn w, resp, nil\n}\n\n// EditGroupWikiPageOptions represents options to EditGroupWikiPage.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#edit-an-existing-wiki-page\ntype EditGroupWikiPageOptions struct {\n\tContent *string          `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tTitle   *string          `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFormat  *WikiFormatValue `url:\"format,omitempty\" json:\"format,omitempty\"`\n}\n\n// EditGroupWikiPage Updates an existing wiki page. At least one parameter is\n// required to update the wiki page.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#edit-an-existing-wiki-page\nfunc (s *GroupWikisService) EditGroupWikiPage(gid interface{}, slug string, opt *EditGroupWikiPageOptions, options ...RequestOptionFunc) (*GroupWiki, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/wikis/%s\", PathEscape(group), url.PathEscape(slug))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tw := new(GroupWiki)\n\tresp, err := s.client.Do(req, w)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn w, resp, nil\n}\n\n// DeleteGroupWikiPage deletes a wiki page with a given slug.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/group_wikis.html#delete-a-wiki-page\nfunc (s *GroupWikisService) DeleteGroupWikiPage(gid interface{}, slug string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/wikis/%s\", PathEscape(group), url.PathEscape(slug))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "group_wikis_test.go",
          "type": "blob",
          "size": 3.88671875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListGroupWikis(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/wikis\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[\n\t\t\t\t{\n\t\t\t\t\t\"content\": \"content here\",\n\t\t\t\t\t\"format\": \"markdown\",\n\t\t\t\t\t\"slug\": \"deploy\",\n\t\t\t\t\t\"title\": \"deploy title\"\n\t\t\t\t}\n\t\t\t]`)\n\t\t})\n\n\tgroupwikis, _, err := client.GroupWikis.ListGroupWikis(1, &ListGroupWikisOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupWikis.ListGroupWikis returned error: %v\", err)\n\t}\n\n\twant := []*GroupWiki{\n\t\t{\n\t\t\tContent: \"content here\",\n\t\t\tFormat:  WikiFormatMarkdown,\n\t\t\tSlug:    \"deploy\",\n\t\t\tTitle:   \"deploy title\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, groupwikis) {\n\t\tt.Errorf(\"GroupWikis.ListGroupWikis returned %+v, want %+v\", groupwikis, want)\n\t}\n}\n\nfunc TestGetGroupWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/wikis/deploy\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\n\t\t\t\t\"content\": \"content here\",\n\t\t\t\t\"format\": \"asciidoc\",\n\t\t\t\t\"slug\": \"deploy\",\n\t\t\t\t\"title\": \"deploy title\",\n\t\t\t\t\"encoding\": \"UTF-8\"\n\t\t\t}`)\n\t\t})\n\n\tgroupwiki, _, err := client.GroupWikis.GetGroupWikiPage(1, \"deploy\", &GetGroupWikiPageOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupWikis.GetGroupWikiPage returned error: %v\", err)\n\t}\n\n\twant := &GroupWiki{\n\t\tContent:  \"content here\",\n\t\tEncoding: \"UTF-8\",\n\t\tFormat:   WikiFormatASCIIDoc,\n\t\tSlug:     \"deploy\",\n\t\tTitle:    \"deploy title\",\n\t}\n\tif !reflect.DeepEqual(want, groupwiki) {\n\t\tt.Errorf(\"GroupWikis.GetGroupWikiPage returned %+v, want %+v\", groupwiki, want)\n\t}\n}\n\nfunc TestCreateGroupWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/wikis\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\n\t\t\t\t\"content\": \"content here\",\n\t\t\t\t\"format\": \"rdoc\",\n\t\t\t\t\"slug\": \"deploy\",\n\t\t\t\t\"title\": \"deploy title\"\n\t\t\t}`)\n\t\t})\n\n\tgroupwiki, _, err := client.GroupWikis.CreateGroupWikiPage(1, &CreateGroupWikiPageOptions{\n\t\tContent: Ptr(\"content here\"),\n\t\tTitle:   Ptr(\"deploy title\"),\n\t\tFormat:  Ptr(WikiFormatRDoc),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"GroupWikis.CreateGroupWikiPage returned error: %v\", err)\n\t}\n\n\twant := &GroupWiki{\n\t\tContent: \"content here\",\n\t\tFormat:  WikiFormatRDoc,\n\t\tSlug:    \"deploy\",\n\t\tTitle:   \"deploy title\",\n\t}\n\tif !reflect.DeepEqual(want, groupwiki) {\n\t\tt.Errorf(\"GroupWikis.CreateGroupWikiPage returned %+v, want %+v\", groupwiki, want)\n\t}\n}\n\nfunc TestEditGroupWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/wikis/deploy\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\n\t\t\t\t\"content\": \"content here\",\n\t\t\t\t\"format\": \"asciidoc\",\n\t\t\t\t\"slug\": \"deploy\",\n\t\t\t\t\"title\": \"deploy title\"\n\t\t\t}`)\n\t\t})\n\n\tgroupwiki, _, err := client.GroupWikis.EditGroupWikiPage(1, \"deploy\", &EditGroupWikiPageOptions{\n\t\tContent: Ptr(\"content here\"),\n\t\tTitle:   Ptr(\"deploy title\"),\n\t\tFormat:  Ptr(WikiFormatRDoc),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"GroupWikis.EditGroupWikiPage returned error: %v\", err)\n\t}\n\n\twant := &GroupWiki{\n\t\tContent: \"content here\",\n\t\tFormat:  WikiFormatASCIIDoc,\n\t\tSlug:    \"deploy\",\n\t\tTitle:   \"deploy title\",\n\t}\n\tif !reflect.DeepEqual(want, groupwiki) {\n\t\tt.Errorf(\"GroupWikis.EditGroupWikiPage returned %+v, want %+v\", groupwiki, want)\n\t}\n}\n\nfunc TestDeleteGroupWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/wikis/deploy\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(204)\n\t\t})\n\n\tr, err := client.GroupWikis.DeleteGroupWikiPage(1, \"deploy\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupWikis.DeleteGroupWikiPage returned error: %v\", err)\n\t}\n\tif r.StatusCode != 204 {\n\t\tt.Errorf(\"GroupWikis.DeleteGroupWikiPage returned wrong status code %d != 204\", r.StatusCode)\n\t}\n}\n"
        },
        {
          "name": "groups.go",
          "type": "blob",
          "size": 47.5224609375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\tretryablehttp \"github.com/hashicorp/go-retryablehttp\"\n)\n\n// GroupsService handles communication with the group related methods of\n// the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html\ntype GroupsService struct {\n\tclient *Client\n}\n\n// Group represents a GitLab group.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html\ntype Group struct {\n\tID                              int                        `json:\"id\"`\n\tName                            string                     `json:\"name\"`\n\tPath                            string                     `json:\"path\"`\n\tDescription                     string                     `json:\"description\"`\n\tMembershipLock                  bool                       `json:\"membership_lock\"`\n\tVisibility                      VisibilityValue            `json:\"visibility\"`\n\tLFSEnabled                      bool                       `json:\"lfs_enabled\"`\n\tDefaultBranch                   string                     `json:\"default_branch\"`\n\tDefaultBranchProtectionDefaults *BranchProtectionDefaults  `json:\"default_branch_protection_defaults\"`\n\tAvatarURL                       string                     `json:\"avatar_url\"`\n\tWebURL                          string                     `json:\"web_url\"`\n\tRequestAccessEnabled            bool                       `json:\"request_access_enabled\"`\n\tRepositoryStorage               string                     `json:\"repository_storage\"`\n\tFullName                        string                     `json:\"full_name\"`\n\tFullPath                        string                     `json:\"full_path\"`\n\tFileTemplateProjectID           int                        `json:\"file_template_project_id\"`\n\tParentID                        int                        `json:\"parent_id\"`\n\tProjects                        []*Project                 `json:\"projects\"`\n\tStatistics                      *Statistics                `json:\"statistics\"`\n\tCustomAttributes                []*CustomAttribute         `json:\"custom_attributes\"`\n\tShareWithGroupLock              bool                       `json:\"share_with_group_lock\"`\n\tRequireTwoFactorAuth            bool                       `json:\"require_two_factor_authentication\"`\n\tTwoFactorGracePeriod            int                        `json:\"two_factor_grace_period\"`\n\tProjectCreationLevel            ProjectCreationLevelValue  `json:\"project_creation_level\"`\n\tAutoDevopsEnabled               bool                       `json:\"auto_devops_enabled\"`\n\tSubGroupCreationLevel           SubGroupCreationLevelValue `json:\"subgroup_creation_level\"`\n\tEmailsEnabled                   bool                       `json:\"emails_enabled\"`\n\tMentionsDisabled                bool                       `json:\"mentions_disabled\"`\n\tRunnersToken                    string                     `json:\"runners_token\"`\n\tSharedProjects                  []*Project                 `json:\"shared_projects\"`\n\tSharedRunnersSetting            SharedRunnersSettingValue  `json:\"shared_runners_setting\"`\n\tSharedWithGroups                []struct {\n\t\tGroupID          int      `json:\"group_id\"`\n\t\tGroupName        string   `json:\"group_name\"`\n\t\tGroupFullPath    string   `json:\"group_full_path\"`\n\t\tGroupAccessLevel int      `json:\"group_access_level\"`\n\t\tExpiresAt        *ISOTime `json:\"expires_at\"`\n\t} `json:\"shared_with_groups\"`\n\tLDAPCN                         string             `json:\"ldap_cn\"`\n\tLDAPAccess                     AccessLevelValue   `json:\"ldap_access\"`\n\tLDAPGroupLinks                 []*LDAPGroupLink   `json:\"ldap_group_links\"`\n\tSAMLGroupLinks                 []*SAMLGroupLink   `json:\"saml_group_links\"`\n\tSharedRunnersMinutesLimit      int                `json:\"shared_runners_minutes_limit\"`\n\tExtraSharedRunnersMinutesLimit int                `json:\"extra_shared_runners_minutes_limit\"`\n\tPreventForkingOutsideGroup     bool               `json:\"prevent_forking_outside_group\"`\n\tMarkedForDeletionOn            *ISOTime           `json:\"marked_for_deletion_on\"`\n\tCreatedAt                      *time.Time         `json:\"created_at\"`\n\tIPRestrictionRanges            string             `json:\"ip_restriction_ranges\"`\n\tAllowedEmailDomainsList        string             `json:\"allowed_email_domains_list\"`\n\tWikiAccessLevel                AccessControlValue `json:\"wiki_access_level\"`\n\n\t// Deprecated: Use EmailsEnabled instead\n\tEmailsDisabled bool `json:\"emails_disabled\"`\n\n\t// Deprecated: Use DefaultBranchProtectionDefaults instead\n\tDefaultBranchProtection int `json:\"default_branch_protection\"`\n}\n\n// BranchProtectionDefaults represents default Git protected branch permissions.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#options-for-default_branch_protection_defaults\ntype BranchProtectionDefaults struct {\n\tAllowedToPush           []*GroupAccessLevel `json:\"allowed_to_push,omitempty\"`\n\tAllowForcePush          bool                `json:\"allow_force_push,omitempty\"`\n\tAllowedToMerge          []*GroupAccessLevel `json:\"allowed_to_merge,omitempty\"`\n\tDeveloperCanInitialPush bool                `json:\"developer_can_initial_push,omitempty\"`\n}\n\n// GroupAccessLevel represents default branch protection defaults access levels.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#options-for-default_branch_protection_defaults\ntype GroupAccessLevel struct {\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n}\n\n// GroupAvatar represents a GitLab group avatar.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html\ntype GroupAvatar struct {\n\tFilename string\n\tImage    io.Reader\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a *GroupAvatar) MarshalJSON() ([]byte, error) {\n\tif a.Filename == \"\" && a.Image == nil {\n\t\treturn []byte(`\"\"`), nil\n\t}\n\ttype alias GroupAvatar\n\treturn json.Marshal((*alias)(a))\n}\n\n// LDAPGroupLink represents a GitLab LDAP group link.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#ldap-group-links\ntype LDAPGroupLink struct {\n\tCN          string           `json:\"cn\"`\n\tFilter      string           `json:\"filter\"`\n\tGroupAccess AccessLevelValue `json:\"group_access\"`\n\tProvider    string           `json:\"provider\"`\n}\n\n// SAMLGroupLink represents a GitLab SAML group link.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#saml-group-links\ntype SAMLGroupLink struct {\n\tName         string           `json:\"name\"`\n\tAccessLevel  AccessLevelValue `json:\"access_level\"`\n\tMemberRoleID int              `json:\"member_role_id,omitempty\"`\n}\n\n// ListGroupsOptions represents the available ListGroups() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#list-groups\ntype ListGroupsOptions struct {\n\tListOptions\n\tSkipGroups           *[]int            `url:\"skip_groups,omitempty\" del:\",\" json:\"skip_groups,omitempty\"`\n\tAllAvailable         *bool             `url:\"all_available,omitempty\" json:\"all_available,omitempty\"`\n\tSearch               *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tOrderBy              *string           `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                 *string           `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tStatistics           *bool             `url:\"statistics,omitempty\" json:\"statistics,omitempty\"`\n\tWithCustomAttributes *bool             `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n\tOwned                *bool             `url:\"owned,omitempty\" json:\"owned,omitempty\"`\n\tMinAccessLevel       *AccessLevelValue `url:\"min_access_level,omitempty\" json:\"min_access_level,omitempty\"`\n\tTopLevelOnly         *bool             `url:\"top_level_only,omitempty\" json:\"top_level_only,omitempty\"`\n\tRepositoryStorage    *string           `url:\"repository_storage,omitempty\" json:\"repository_storage,omitempty\"`\n}\n\n// ListGroups gets a list of groups (as user: my groups, as admin: all groups).\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-groups\nfunc (s *GroupsService) ListGroups(opt *ListGroupsOptions, options ...RequestOptionFunc) ([]*Group, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"groups\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*Group\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// ListSubGroupsOptions represents the available ListSubGroups() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-a-groups-subgroups\ntype ListSubGroupsOptions ListGroupsOptions\n\n// ListSubGroups gets a list of subgroups for a given group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-a-groups-subgroups\nfunc (s *GroupsService) ListSubGroups(gid interface{}, opt *ListSubGroupsOptions, options ...RequestOptionFunc) ([]*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/subgroups\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*Group\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// ListDescendantGroupsOptions represents the available ListDescendantGroups()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-a-groups-descendant-groups\ntype ListDescendantGroupsOptions ListGroupsOptions\n\n// ListDescendantGroups gets a list of subgroups for a given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-a-groups-descendant-groups\nfunc (s *GroupsService) ListDescendantGroups(gid interface{}, opt *ListDescendantGroupsOptions, options ...RequestOptionFunc) ([]*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/descendant_groups\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*Group\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// ListGroupProjectsOptions represents the available ListGroup() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-a-groups-projects\ntype ListGroupProjectsOptions struct {\n\tListOptions\n\tArchived                 *bool             `url:\"archived,omitempty\" json:\"archived,omitempty\"`\n\tIncludeSubGroups         *bool             `url:\"include_subgroups,omitempty\" json:\"include_subgroups,omitempty\"`\n\tMinAccessLevel           *AccessLevelValue `url:\"min_access_level,omitempty\" json:\"min_access_level,omitempty\"`\n\tOrderBy                  *string           `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tOwned                    *bool             `url:\"owned,omitempty\" json:\"owned,omitempty\"`\n\tSearch                   *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tSimple                   *bool             `url:\"simple,omitempty\" json:\"simple,omitempty\"`\n\tSort                     *string           `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tStarred                  *bool             `url:\"starred,omitempty\" json:\"starred,omitempty\"`\n\tTopic                    *string           `url:\"topic,omitempty\" json:\"topic,omitempty\"`\n\tVisibility               *VisibilityValue  `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tWithCustomAttributes     *bool             `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n\tWithIssuesEnabled        *bool             `url:\"with_issues_enabled,omitempty\" json:\"with_issues_enabled,omitempty\"`\n\tWithMergeRequestsEnabled *bool             `url:\"with_merge_requests_enabled,omitempty\" json:\"with_merge_requests_enabled,omitempty\"`\n\tWithSecurityReports      *bool             `url:\"with_security_reports,omitempty\" json:\"with_security_reports,omitempty\"`\n\tWithShared               *bool             `url:\"with_shared,omitempty\" json:\"with_shared,omitempty\"`\n}\n\n// ListGroupProjects get a list of group projects\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-a-groups-projects\nfunc (s *GroupsService) ListGroupProjects(gid interface{}, opt *ListGroupProjectsOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/projects\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Project\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// GetGroupOptions represents the available GetGroup() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#details-of-a-group\ntype GetGroupOptions struct {\n\tListOptions\n\tWithCustomAttributes *bool `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n\tWithProjects         *bool `url:\"with_projects,omitempty\" json:\"with_projects,omitempty\"`\n}\n\n// GetGroup gets all details of a group.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#details-of-a-group\nfunc (s *GroupsService) GetGroup(gid interface{}, opt *GetGroupOptions, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// DownloadAvatar downloads a group avatar.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#download-a-group-avatar\nfunc (s *GroupsService) DownloadAvatar(gid interface{}, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/avatar\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tavatar := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, avatar)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(avatar.Bytes()), resp, err\n}\n\n// CreateGroupOptions represents the available CreateGroup() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#new-group\ntype CreateGroupOptions struct {\n\tName                            *string                                 `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tPath                            *string                                 `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tAvatar                          *GroupAvatar                            `url:\"-\" json:\"-\"`\n\tDefaultBranch                   *string                                 `url:\"default_branch,omitempty\" json:\"default_branch,omitempty\"`\n\tDescription                     *string                                 `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tMembershipLock                  *bool                                   `url:\"membership_lock,omitempty\" json:\"membership_lock,omitempty\"`\n\tVisibility                      *VisibilityValue                        `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tShareWithGroupLock              *bool                                   `url:\"share_with_group_lock,omitempty\" json:\"share_with_group_lock,omitempty\"`\n\tRequireTwoFactorAuth            *bool                                   `url:\"require_two_factor_authentication,omitempty\" json:\"require_two_factor_authentication,omitempty\"`\n\tTwoFactorGracePeriod            *int                                    `url:\"two_factor_grace_period,omitempty\" json:\"two_factor_grace_period,omitempty\"`\n\tProjectCreationLevel            *ProjectCreationLevelValue              `url:\"project_creation_level,omitempty\" json:\"project_creation_level,omitempty\"`\n\tAutoDevopsEnabled               *bool                                   `url:\"auto_devops_enabled,omitempty\" json:\"auto_devops_enabled,omitempty\"`\n\tSubGroupCreationLevel           *SubGroupCreationLevelValue             `url:\"subgroup_creation_level,omitempty\" json:\"subgroup_creation_level,omitempty\"`\n\tEmailsEnabled                   *bool                                   `url:\"emails_enabled,omitempty\" json:\"emails_enabled,omitempty\"`\n\tMentionsDisabled                *bool                                   `url:\"mentions_disabled,omitempty\" json:\"mentions_disabled,omitempty\"`\n\tLFSEnabled                      *bool                                   `url:\"lfs_enabled,omitempty\" json:\"lfs_enabled,omitempty\"`\n\tDefaultBranchProtectionDefaults *DefaultBranchProtectionDefaultsOptions `url:\"default_branch_protection_defaults,omitempty\" json:\"default_branch_protection_defaults,omitempty\"`\n\tRequestAccessEnabled            *bool                                   `url:\"request_access_enabled,omitempty\" json:\"request_access_enabled,omitempty\"`\n\tParentID                        *int                                    `url:\"parent_id,omitempty\" json:\"parent_id,omitempty\"`\n\tSharedRunnersMinutesLimit       *int                                    `url:\"shared_runners_minutes_limit,omitempty\" json:\"shared_runners_minutes_limit,omitempty\"`\n\tExtraSharedRunnersMinutesLimit  *int                                    `url:\"extra_shared_runners_minutes_limit,omitempty\" json:\"extra_shared_runners_minutes_limit,omitempty\"`\n\tWikiAccessLevel                 *AccessControlValue                     `url:\"wiki_access_level,omitempty\" json:\"wiki_access_level,omitempty\"`\n\n\t// Deprecated: Use EmailsEnabled instead\n\tEmailsDisabled *bool `url:\"emails_disabled,omitempty\" json:\"emails_disabled,omitempty\"`\n\n\t// Deprecated: User DefaultBranchProtectionDefaults instead\n\tDefaultBranchProtection *int `url:\"default_branch_protection,omitempty\" json:\"default_branch_protection,omitempty\"`\n}\n\n// DefaultBranchProtectionDefaultsOptions represents the available options for\n// using default_branch_protection_defaults in CreateGroup() or UpdateGroup()\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#options-for-default_branch_protection_defaults\ntype DefaultBranchProtectionDefaultsOptions struct {\n\tAllowedToPush           *[]*GroupAccessLevel `url:\"allowed_to_push,omitempty\" json:\"allowed_to_push,omitempty\"`\n\tAllowForcePush          *bool                `url:\"allow_force_push,omitempty\" json:\"allow_force_push,omitempty\"`\n\tAllowedToMerge          *[]*GroupAccessLevel `url:\"allowed_to_merge,omitempty\" json:\"allowed_to_merge,omitempty\"`\n\tDeveloperCanInitialPush *bool                `url:\"developer_can_initial_push,omitempty\" json:\"developer_can_initial_push,omitempty\"`\n}\n\n// CreateGroup creates a new project group. Available only for users who can\n// create groups.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#new-group\nfunc (s *GroupsService) CreateGroup(opt *CreateGroupOptions, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tvar err error\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil {\n\t\treq, err = s.client.NewRequest(http.MethodPost, \"groups\", opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPost,\n\t\t\t\"groups\",\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// TransferGroup transfers a project to the Group namespace. Available only\n// for admin.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#transfer-project-to-group\nfunc (s *GroupsService) TransferGroup(gid interface{}, pid interface{}, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/projects/%s\", PathEscape(group), PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// TransferSubGroupOptions represents the available TransferSubGroup() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#transfer-a-group-to-a-new-parent-group--turn-a-subgroup-to-a-top-level-group\ntype TransferSubGroupOptions struct {\n\tGroupID *int `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n}\n\n// TransferSubGroup transfers a group to a new parent group or turn a subgroup\n// to a top-level group. Available to administrators and users.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#transfer-a-group-to-a-new-parent-group--turn-a-subgroup-to-a-top-level-group\nfunc (s *GroupsService) TransferSubGroup(gid interface{}, opt *TransferSubGroupOptions, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/transfer\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// UpdateGroupOptions represents the available UpdateGroup() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#update-group\ntype UpdateGroupOptions struct {\n\tName                                 *string                                 `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tPath                                 *string                                 `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tAvatar                               *GroupAvatar                            `url:\"-\" json:\"avatar,omitempty\"`\n\tDefaultBranch                        *string                                 `url:\"default_branch,omitempty\" json:\"default_branch,omitempty\"`\n\tDescription                          *string                                 `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tMembershipLock                       *bool                                   `url:\"membership_lock,omitempty\" json:\"membership_lock,omitempty\"`\n\tVisibility                           *VisibilityValue                        `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tShareWithGroupLock                   *bool                                   `url:\"share_with_group_lock,omitempty\" json:\"share_with_group_lock,omitempty\"`\n\tRequireTwoFactorAuth                 *bool                                   `url:\"require_two_factor_authentication,omitempty\" json:\"require_two_factor_authentication,omitempty\"`\n\tTwoFactorGracePeriod                 *int                                    `url:\"two_factor_grace_period,omitempty\" json:\"two_factor_grace_period,omitempty\"`\n\tProjectCreationLevel                 *ProjectCreationLevelValue              `url:\"project_creation_level,omitempty\" json:\"project_creation_level,omitempty\"`\n\tAutoDevopsEnabled                    *bool                                   `url:\"auto_devops_enabled,omitempty\" json:\"auto_devops_enabled,omitempty\"`\n\tSubGroupCreationLevel                *SubGroupCreationLevelValue             `url:\"subgroup_creation_level,omitempty\" json:\"subgroup_creation_level,omitempty\"`\n\tEmailsEnabled                        *bool                                   `url:\"emails_enabled,omitempty\" json:\"emails_enabled,omitempty\"`\n\tMentionsDisabled                     *bool                                   `url:\"mentions_disabled,omitempty\" json:\"mentions_disabled,omitempty\"`\n\tLFSEnabled                           *bool                                   `url:\"lfs_enabled,omitempty\" json:\"lfs_enabled,omitempty\"`\n\tRequestAccessEnabled                 *bool                                   `url:\"request_access_enabled,omitempty\" json:\"request_access_enabled,omitempty\"`\n\tDefaultBranchProtectionDefaults      *DefaultBranchProtectionDefaultsOptions `url:\"default_branch_protection_defaults,omitempty\" json:\"default_branch_protection_defaults,omitempty\"`\n\tFileTemplateProjectID                *int                                    `url:\"file_template_project_id,omitempty\" json:\"file_template_project_id,omitempty\"`\n\tSharedRunnersMinutesLimit            *int                                    `url:\"shared_runners_minutes_limit,omitempty\" json:\"shared_runners_minutes_limit,omitempty\"`\n\tExtraSharedRunnersMinutesLimit       *int                                    `url:\"extra_shared_runners_minutes_limit,omitempty\" json:\"extra_shared_runners_minutes_limit,omitempty\"`\n\tPreventForkingOutsideGroup           *bool                                   `url:\"prevent_forking_outside_group,omitempty\" json:\"prevent_forking_outside_group,omitempty\"`\n\tSharedRunnersSetting                 *SharedRunnersSettingValue              `url:\"shared_runners_setting,omitempty\" json:\"shared_runners_setting,omitempty\"`\n\tPreventSharingGroupsOutsideHierarchy *bool                                   `url:\"prevent_sharing_groups_outside_hierarchy,omitempty\" json:\"prevent_sharing_groups_outside_hierarchy,omitempty\"`\n\tIPRestrictionRanges                  *string                                 `url:\"ip_restriction_ranges,omitempty\" json:\"ip_restriction_ranges,omitempty\"`\n\tAllowedEmailDomainsList              *string                                 `url:\"allowed_email_domains_list,omitempty\" json:\"allowed_email_domains_list,omitempty\"`\n\tWikiAccessLevel                      *AccessControlValue                     `url:\"wiki_access_level,omitempty\" json:\"wiki_access_level,omitempty\"`\n\n\t// Deprecated: Use EmailsEnabled instead\n\tEmailsDisabled *bool `url:\"emails_disabled,omitempty\" json:\"emails_disabled,omitempty\"`\n\n\t// Deprecated: Use DefaultBranchProtectionDefaults instead\n\tDefaultBranchProtection *int `url:\"default_branch_protection,omitempty\" json:\"default_branch_protection,omitempty\"`\n}\n\n// UpdateGroup updates an existing group; only available to group owners and\n// administrators.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#update-group\nfunc (s *GroupsService) UpdateGroup(gid interface{}, opt *UpdateGroupOptions, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s\", PathEscape(group))\n\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil || (opt.Avatar.Filename == \"\" && opt.Avatar.Image == nil) {\n\t\treq, err = s.client.NewRequest(http.MethodPut, u, opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPut,\n\t\t\tu,\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// UploadAvatar uploads a group avatar.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#upload-a-group-avatar\nfunc (s *GroupsService) UploadAvatar(gid interface{}, avatar io.Reader, filename string, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s\", PathEscape(group))\n\n\treq, err := s.client.UploadRequest(\n\t\thttp.MethodPut,\n\t\tu,\n\t\tavatar,\n\t\tfilename,\n\t\tUploadAvatar,\n\t\tnil,\n\t\toptions,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// DeleteGroupOptions represents the available DeleteGroup() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#update-group\ntype DeleteGroupOptions struct {\n\tPermanentlyRemove *bool   `url:\"permanently_remove,omitempty\" json:\"permanently_remove,omitempty\"`\n\tFullPath          *string `url:\"full_path,omitempty\" json:\"full_path,omitempty\"`\n}\n\n// DeleteGroup removes group with all projects inside.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#remove-group\nfunc (s *GroupsService) DeleteGroup(gid interface{}, opt *DeleteGroupOptions, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// RestoreGroup restores a previously deleted group\n//\n// GitLap API docs:\n// https://docs.gitlab.com/ee/api/groups.html#restore-group-marked-for-deletion\nfunc (s *GroupsService) RestoreGroup(gid interface{}, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/restore\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// SearchGroup get all groups that match your string in their name or path.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/groups.html#search-for-group\nfunc (s *GroupsService) SearchGroup(query string, options ...RequestOptionFunc) ([]*Group, *Response, error) {\n\tvar q struct {\n\t\tSearch string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\t}\n\tq.Search = query\n\n\treq, err := s.client.NewRequest(http.MethodGet, \"groups\", &q, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gs []*Group\n\tresp, err := s.client.Do(req, &gs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gs, resp, nil\n}\n\n// ListProvisionedUsersOptions represents the available ListProvisionedUsers()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-provisioned-users\ntype ListProvisionedUsersOptions struct {\n\tListOptions\n\tUsername      *string    `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tSearch        *string    `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tActive        *bool      `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tBlocked       *bool      `url:\"blocked,omitempty\" json:\"blocked,omitempty\"`\n\tCreatedAfter  *time.Time `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore *time.Time `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n}\n\n// ListProvisionedUsers gets a list of users provisioned by the given group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-provisioned-users\nfunc (s *GroupsService) ListProvisionedUsers(gid interface{}, opt *ListProvisionedUsersOptions, options ...RequestOptionFunc) ([]*User, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/provisioned_users\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar us []*User\n\tresp, err := s.client.Do(req, &us)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn us, resp, nil\n}\n\n// ListGroupLDAPLinks lists the group's LDAP links. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-ldap-group-links\nfunc (s *GroupsService) ListGroupLDAPLinks(gid interface{}, options ...RequestOptionFunc) ([]*LDAPGroupLink, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ldap_group_links\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gls []*LDAPGroupLink\n\tresp, err := s.client.Do(req, &gls)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gls, resp, nil\n}\n\n// AddGroupLDAPLinkOptions represents the available AddGroupLDAPLink() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#add-ldap-group-link-with-cn-or-filter\ntype AddGroupLDAPLinkOptions struct {\n\tCN          *string           `url:\"cn,omitempty\" json:\"cn,omitempty\"`\n\tFilter      *string           `url:\"filter,omitempty\" json:\"filter,omitempty\"`\n\tGroupAccess *AccessLevelValue `url:\"group_access,omitempty\" json:\"group_access,omitempty\"`\n\tProvider    *string           `url:\"provider,omitempty\" json:\"provider,omitempty\"`\n}\n\n// DeleteGroupLDAPLinkWithCNOrFilterOptions represents the available DeleteGroupLDAPLinkWithCNOrFilter() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-ldap-group-link-with-cn-or-filter\ntype DeleteGroupLDAPLinkWithCNOrFilterOptions struct {\n\tCN       *string `url:\"cn,omitempty\" json:\"cn,omitempty\"`\n\tFilter   *string `url:\"filter,omitempty\" json:\"filter,omitempty\"`\n\tProvider *string `url:\"provider,omitempty\" json:\"provider,omitempty\"`\n}\n\n// AddGroupLDAPLink creates a new group LDAP link. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#add-ldap-group-link-with-cn-or-filter\nfunc (s *GroupsService) AddGroupLDAPLink(gid interface{}, opt *AddGroupLDAPLinkOptions, options ...RequestOptionFunc) (*LDAPGroupLink, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ldap_group_links\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgl := new(LDAPGroupLink)\n\tresp, err := s.client.Do(req, gl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gl, resp, nil\n}\n\n// DeleteGroupLDAPLink deletes a group LDAP link. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-ldap-group-link\nfunc (s *GroupsService) DeleteGroupLDAPLink(gid interface{}, cn string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ldap_group_links/%s\", PathEscape(group), PathEscape(cn))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteGroupLDAPLinkWithCNOrFilter deletes a group LDAP link. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-ldap-group-link-with-cn-or-filter\nfunc (s *GroupsService) DeleteGroupLDAPLinkWithCNOrFilter(gid interface{}, opts *DeleteGroupLDAPLinkWithCNOrFilterOptions, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/ldap_group_links\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteGroupLDAPLinkForProvider deletes a group LDAP link from a specific\n// provider. Available only for users who can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-ldap-group-link\nfunc (s *GroupsService) DeleteGroupLDAPLinkForProvider(gid interface{}, provider, cn string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"groups/%s/ldap_group_links/%s/%s\",\n\t\tPathEscape(group),\n\t\tPathEscape(provider),\n\t\tPathEscape(cn),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListGroupSAMLLinks lists the group's SAML links. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#list-saml-group-links\nfunc (s *GroupsService) ListGroupSAMLLinks(gid interface{}, options ...RequestOptionFunc) ([]*SAMLGroupLink, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/saml_group_links\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar gl []*SAMLGroupLink\n\tresp, err := s.client.Do(req, &gl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gl, resp, nil\n}\n\n// GetGroupSAMLLink get a specific group SAML link. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#get-saml-group-link\nfunc (s *GroupsService) GetGroupSAMLLink(gid interface{}, samlGroupName string, options ...RequestOptionFunc) (*SAMLGroupLink, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/saml_group_links/%s\", PathEscape(group), PathEscape(samlGroupName))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgl := new(SAMLGroupLink)\n\tresp, err := s.client.Do(req, &gl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gl, resp, nil\n}\n\n// AddGroupSAMLLinkOptions represents the available AddGroupSAMLLink() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#add-saml-group-link\ntype AddGroupSAMLLinkOptions struct {\n\tSAMLGroupName *string           `url:\"saml_group_name,omitempty\" json:\"saml_group_name,omitempty\"`\n\tAccessLevel   *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tMemberRoleID  *int              `url:\"member_role_id,omitempty\" json:\"member_role_id,omitempty\"`\n}\n\n// AddGroupSAMLLink creates a new group SAML link. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#add-saml-group-link\nfunc (s *GroupsService) AddGroupSAMLLink(gid interface{}, opt *AddGroupSAMLLinkOptions, options ...RequestOptionFunc) (*SAMLGroupLink, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/saml_group_links\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgl := new(SAMLGroupLink)\n\tresp, err := s.client.Do(req, &gl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gl, resp, nil\n}\n\n// DeleteGroupSAMLLink deletes a group SAML link. Available only for users who\n// can edit groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-saml-group-link\nfunc (s *GroupsService) DeleteGroupSAMLLink(gid interface{}, samlGroupName string, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/saml_group_links/%s\", PathEscape(group), PathEscape(samlGroupName))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ShareGroupWithGroupOptions represents the available ShareGroupWithGroup() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#share-groups-with-groups\ntype ShareGroupWithGroupOptions struct {\n\tGroupID     *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tGroupAccess *AccessLevelValue `url:\"group_access,omitempty\" json:\"group_access,omitempty\"`\n\tExpiresAt   *ISOTime          `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// ShareGroupWithGroup shares a group with another group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#create-a-link-to-share-a-group-with-another-group\nfunc (s *GroupsService) ShareGroupWithGroup(gid interface{}, opt *ShareGroupWithGroupOptions, options ...RequestOptionFunc) (*Group, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/share\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tg := new(Group)\n\tresp, err := s.client.Do(req, g)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn g, resp, nil\n}\n\n// UnshareGroupFromGroup unshares a group from another group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-link-sharing-group-with-another-group\nfunc (s *GroupsService) UnshareGroupFromGroup(gid interface{}, groupID int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/share/%d\", PathEscape(group), groupID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GroupPushRules represents a group push rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#get-group-push-rules\ntype GroupPushRules struct {\n\tID                         int        `json:\"id\"`\n\tCreatedAt                  *time.Time `json:\"created_at\"`\n\tCommitMessageRegex         string     `json:\"commit_message_regex\"`\n\tCommitMessageNegativeRegex string     `json:\"commit_message_negative_regex\"`\n\tBranchNameRegex            string     `json:\"branch_name_regex\"`\n\tDenyDeleteTag              bool       `json:\"deny_delete_tag\"`\n\tMemberCheck                bool       `json:\"member_check\"`\n\tPreventSecrets             bool       `json:\"prevent_secrets\"`\n\tAuthorEmailRegex           string     `json:\"author_email_regex\"`\n\tFileNameRegex              string     `json:\"file_name_regex\"`\n\tMaxFileSize                int        `json:\"max_file_size\"`\n\tCommitCommitterCheck       bool       `json:\"commit_committer_check\"`\n\tCommitCommitterNameCheck   bool       `json:\"commit_committer_name_check\"`\n\tRejectUnsignedCommits      bool       `json:\"reject_unsigned_commits\"`\n\tRejectNonDCOCommits        bool       `json:\"reject_non_dco_commits\"`\n}\n\n// GetGroupPushRules gets the push rules of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#get-group-push-rules\nfunc (s *GroupsService) GetGroupPushRules(gid interface{}, options ...RequestOptionFunc) (*GroupPushRules, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/push_rule\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgpr := new(GroupPushRules)\n\tresp, err := s.client.Do(req, gpr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gpr, resp, nil\n}\n\n// AddGroupPushRuleOptions represents the available AddGroupPushRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#add-group-push-rule\ntype AddGroupPushRuleOptions struct {\n\tAuthorEmailRegex           *string `url:\"author_email_regex,omitempty\" json:\"author_email_regex,omitempty\"`\n\tBranchNameRegex            *string `url:\"branch_name_regex,omitempty\" json:\"branch_name_regex,omitempty\"`\n\tCommitCommitterCheck       *bool   `url:\"commit_committer_check,omitempty\" json:\"commit_committer_check,omitempty\"`\n\tCommitCommitterNameCheck   *bool   `url:\"commit_committer_name_check,omitempty\" json:\"commit_committer_name_check,omitempty\"`\n\tCommitMessageNegativeRegex *string `url:\"commit_message_negative_regex,omitempty\" json:\"commit_message_negative_regex,omitempty\"`\n\tCommitMessageRegex         *string `url:\"commit_message_regex,omitempty\" json:\"commit_message_regex,omitempty\"`\n\tDenyDeleteTag              *bool   `url:\"deny_delete_tag,omitempty\" json:\"deny_delete_tag,omitempty\"`\n\tFileNameRegex              *string `url:\"file_name_regex,omitempty\" json:\"file_name_regex,omitempty\"`\n\tMaxFileSize                *int    `url:\"max_file_size,omitempty\" json:\"max_file_size,omitempty\"`\n\tMemberCheck                *bool   `url:\"member_check,omitempty\" json:\"member_check,omitempty\"`\n\tPreventSecrets             *bool   `url:\"prevent_secrets,omitempty\" json:\"prevent_secrets,omitempty\"`\n\tRejectUnsignedCommits      *bool   `url:\"reject_unsigned_commits,omitempty\" json:\"reject_unsigned_commits,omitempty\"`\n\tRejectNonDCOCommits        *bool   `url:\"reject_non_dco_commits,omitempty\" json:\"reject_non_dco_commits,omitempty\"`\n}\n\n// AddGroupPushRule adds push rules to the specified group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#add-group-push-rule\nfunc (s *GroupsService) AddGroupPushRule(gid interface{}, opt *AddGroupPushRuleOptions, options ...RequestOptionFunc) (*GroupPushRules, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/push_rule\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgpr := new(GroupPushRules)\n\tresp, err := s.client.Do(req, gpr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gpr, resp, nil\n}\n\n// EditGroupPushRuleOptions represents the available EditGroupPushRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#edit-group-push-rule\ntype EditGroupPushRuleOptions struct {\n\tAuthorEmailRegex           *string `url:\"author_email_regex,omitempty\" json:\"author_email_regex,omitempty\"`\n\tBranchNameRegex            *string `url:\"branch_name_regex,omitempty\" json:\"branch_name_regex,omitempty\"`\n\tCommitCommitterCheck       *bool   `url:\"commit_committer_check,omitempty\" json:\"commit_committer_check,omitempty\"`\n\tCommitCommitterNameCheck   *bool   `url:\"commit_committer_name_check,omitempty\" json:\"commit_committer_name_check,omitempty\"`\n\tCommitMessageNegativeRegex *string `url:\"commit_message_negative_regex,omitempty\" json:\"commit_message_negative_regex,omitempty\"`\n\tCommitMessageRegex         *string `url:\"commit_message_regex,omitempty\" json:\"commit_message_regex,omitempty\"`\n\tDenyDeleteTag              *bool   `url:\"deny_delete_tag,omitempty\" json:\"deny_delete_tag,omitempty\"`\n\tFileNameRegex              *string `url:\"file_name_regex,omitempty\" json:\"file_name_regex,omitempty\"`\n\tMaxFileSize                *int    `url:\"max_file_size,omitempty\" json:\"max_file_size,omitempty\"`\n\tMemberCheck                *bool   `url:\"member_check,omitempty\" json:\"member_check,omitempty\"`\n\tPreventSecrets             *bool   `url:\"prevent_secrets,omitempty\" json:\"prevent_secrets,omitempty\"`\n\tRejectUnsignedCommits      *bool   `url:\"reject_unsigned_commits,omitempty\" json:\"reject_unsigned_commits,omitempty\"`\n\tRejectNonDCOCommits        *bool   `url:\"reject_non_dco_commits,omitempty\" json:\"reject_non_dco_commits,omitempty\"`\n}\n\n// EditGroupPushRule edits a push rule for a specified group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#edit-group-push-rule\nfunc (s *GroupsService) EditGroupPushRule(gid interface{}, opt *EditGroupPushRuleOptions, options ...RequestOptionFunc) (*GroupPushRules, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/push_rule\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgpr := new(GroupPushRules)\n\tresp, err := s.client.Do(req, gpr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gpr, resp, nil\n}\n\n// DeleteGroupPushRule deletes the push rules of a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#delete-group-push-rule\nfunc (s *GroupsService) DeleteGroupPushRule(gid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/push_rule\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "groups_test.go",
          "type": "blob",
          "size": 31.1328125,
          "content": "package gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListGroups(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t\t})\n\n\tgroups, _, err := client.Groups.ListGroups(&ListGroupsOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroups returned error: %v\", err)\n\t}\n\n\twant := []*Group{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, groups) {\n\t\tt.Errorf(\"Groups.ListGroups returned %+v, want %+v\", groups, want)\n\t}\n}\n\nfunc TestGetGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/g\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"name\": \"g\", \"default_branch\": \"branch\"}`)\n\t\t})\n\n\tgroup, _, err := client.Groups.GetGroup(\"g\", &GetGroupOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.GetGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, Name: \"g\", DefaultBranch: \"branch\"}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.GetGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestGetGroupWithFileTemplateId(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/g\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"name\": \"g\",\"file_template_project_id\": 12345}`)\n\t\t})\n\n\tgroup, _, err := client.Groups.GetGroup(\"g\", &GetGroupOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.GetGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, Name: \"g\", FileTemplateProjectID: 12345}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.GetGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestCreateGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"name\": \"g\", \"path\": \"g\"}`)\n\t\t})\n\n\topt := &CreateGroupOptions{\n\t\tName: Ptr(\"g\"),\n\t\tPath: Ptr(\"g\"),\n\t}\n\n\tgroup, _, err := client.Groups.CreateGroup(opt, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.CreateGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, Name: \"g\", Path: \"g\"}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.CreateGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestCreateGroupWithDefaultBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"name\": \"g\", \"path\": \"g\", \"default_branch\": \"branch\"}`)\n\t\t})\n\n\topt := &CreateGroupOptions{\n\t\tName:          Ptr(\"g\"),\n\t\tPath:          Ptr(\"g\"),\n\t\tDefaultBranch: Ptr(\"branch\"),\n\t}\n\n\tgroup, _, err := client.Groups.CreateGroup(opt, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.CreateGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, Name: \"g\", Path: \"g\", DefaultBranch: \"branch\"}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.CreateGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestCreateGroupDefaultBranchSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\tvar jsonRequestBody CreateGroupOptions\n\tmux.HandleFunc(\"/api/v4/groups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\n\t\t\ttestData, _ := io.ReadAll(r.Body)\n\t\t\terr := json.Unmarshal(testData, &jsonRequestBody)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Failed to unmarshal request body into an interface.\")\n\t\t\t}\n\n\t\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"g\",\n\t\t\t\t\"path\": \"g\",\n\t\t\t\t\"default_branch_protection_defaults\": {\n\t\t\t\t\t\"allowed_to_push\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"access_level\": 40\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"allow_force_push\": false,\n\t\t\t\t\t\"allowed_to_merge\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"access_level\": 40\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t\t`)\n\t\t})\n\n\topt := &CreateGroupOptions{\n\t\tName: Ptr(\"g\"),\n\t\tPath: Ptr(\"g\"),\n\t\tDefaultBranchProtectionDefaults: &DefaultBranchProtectionDefaultsOptions{\n\t\t\tAllowedToPush: &[]*GroupAccessLevel{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel: Ptr(AccessLevelValue(40)),\n\t\t\t\t},\n\t\t\t},\n\t\t\tAllowedToMerge: &[]*GroupAccessLevel{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel: Ptr(AccessLevelValue(40)),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tgroup, _, err := client.Groups.CreateGroup(opt, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.CreateGroup returned error: %v\", err)\n\t}\n\n\t// Create the group that we want to get back\n\twant := &Group{\n\t\tID:   1,\n\t\tName: \"g\",\n\t\tPath: \"g\",\n\t\tDefaultBranchProtectionDefaults: &BranchProtectionDefaults{\n\t\t\tAllowedToMerge: []*GroupAccessLevel{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel: Ptr(MaintainerPermissions),\n\t\t\t\t},\n\t\t\t},\n\t\t\tAllowedToPush: []*GroupAccessLevel{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel: Ptr(MaintainerPermissions),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.CreateGroup returned %+v, want %+v\", group, want)\n\t}\n\n\t// Validate the request does what we want it to\n\tallowedToMerge := *jsonRequestBody.DefaultBranchProtectionDefaults.AllowedToMerge\n\tallowedToPush := *jsonRequestBody.DefaultBranchProtectionDefaults.AllowedToPush\n\tassert.Equal(t, Ptr(MaintainerPermissions), allowedToMerge[0].AccessLevel)\n\tassert.Equal(t, Ptr(MaintainerPermissions), allowedToPush[0].AccessLevel)\n}\n\nfunc TestTransferGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/projects/2\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprintf(w, `{\"id\": 1}`)\n\t\t})\n\n\tgroup, _, err := client.Groups.TransferGroup(1, 2)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.TransferGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1}\n\tif !reflect.DeepEqual(group, want) {\n\t\tt.Errorf(\"Groups.TransferGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestTransferSubGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/transfer\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprintf(w, `{\"id\": 1, \"parent_id\": 2}`)\n\t\t})\n\n\topt := &TransferSubGroupOptions{\n\t\tGroupID: Ptr(2),\n\t}\n\n\tgroup, _, err := client.Groups.TransferSubGroup(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.TransferSubGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, ParentID: 2}\n\tif !reflect.DeepEqual(group, want) {\n\t\tt.Errorf(\"Groups.TransferSubGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestDeleteGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\t\t})\n\n\tresp, err := client.Groups.DeleteGroup(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.DeleteGroup returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"Groups.DeleteGroup returned %d, want %d\", got, want)\n\t}\n}\n\nfunc TestDeleteGroup_WithPermanentDelete(t *testing.T) {\n\tmux, client := setup(t)\n\tvar params url.Values\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(http.StatusAccepted)\n\n\t\t\t// Get the request parameters\n\t\t\tparsedParams, err := url.ParseQuery(r.URL.RawQuery)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Groups.DeleteGroup returned error when parsing test parameters: %v\", err)\n\t\t\t}\n\t\t\tparams = parsedParams\n\t\t})\n\n\tresp, err := client.Groups.DeleteGroup(1, &DeleteGroupOptions{\n\t\tPermanentlyRemove: Ptr(true),\n\t\tFullPath:          Ptr(\"testPath\"),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.DeleteGroup returned error: %v\", err)\n\t}\n\n\t// Test that our status code matches\n\tif resp.StatusCode != http.StatusAccepted {\n\t\tt.Errorf(\"Groups.DeleteGroup returned %d, want %d\", resp.StatusCode, http.StatusAccepted)\n\t}\n\n\t// Test that \"permanently_remove\" is set to true\n\tif params.Get(\"permanently_remove\") != \"true\" {\n\t\tt.Errorf(\"Groups.DeleteGroup returned %v, want %v\", params.Get(\"permanently_remove\"), true)\n\t}\n\n\t// Test that \"full_path\" is set to \"testPath\"\n\tif params.Get(\"full_path\") != \"testPath\" {\n\t\tt.Errorf(\"Groups.DeleteGroup returned %v, want %v\", params.Get(\"full_path\"), \"testPath\")\n\t}\n}\n\nfunc TestSearchGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[{\"id\": 1, \"name\": \"Foobar Group\"}]`)\n\t\t})\n\n\tgroups, _, err := client.Groups.SearchGroup(\"foobar\")\n\tif err != nil {\n\t\tt.Errorf(\"Groups.SearchGroup returned error: %v\", err)\n\t}\n\n\twant := []*Group{{ID: 1, Name: \"Foobar Group\"}}\n\tif !reflect.DeepEqual(want, groups) {\n\t\tt.Errorf(\"Groups.SearchGroup returned +%v, want %+v\", groups, want)\n\t}\n}\n\nfunc TestUpdateGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\"id\": 1}`)\n\t\t})\n\n\tgroup, _, err := client.Groups.UpdateGroup(1, &UpdateGroupOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UpdateGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.UpdatedGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestUpdateGroupWithDefaultBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"default_branch\": \"branch\"}`)\n\t\t})\n\n\topt := &UpdateGroupOptions{\n\t\tDefaultBranch: Ptr(\"branch\"),\n\t}\n\n\tgroup, _, err := client.Groups.UpdateGroup(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UpdateGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, DefaultBranch: \"branch\"}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.UpdatedGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestListGroupProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/22/projects\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t\t})\n\n\tprojects, _, err := client.Groups.ListGroupProjects(22,\n\t\t&ListGroupProjectsOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Groups.ListGroupProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListSubGroups(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/subgroups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[{\"id\": 1}, {\"id\": 2}]`)\n\t\t})\n\n\tgroups, _, err := client.Groups.ListSubGroups(1, &ListSubGroupsOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListSubGroups returned error: %v\", err)\n\t}\n\n\twant := []*Group{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, groups) {\n\t\tt.Errorf(\"Groups.ListSubGroups returned %+v, want %+v\", groups, want)\n\t}\n}\n\nfunc TestListGroupLDAPLinks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/ldap_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[\n\t{\n\t\t\"cn\":\"gitlab_group_example_30\",\n\t\t\"group_access\":30,\n\t\t\"provider\":\"example_ldap_provider\"\n\t},\n\t{\n\t\t\"cn\":\"gitlab_group_example_40\",\n\t\t\"group_access\":40,\n\t\t\"provider\":\"example_ldap_provider\"\n\t}\n]`)\n\t\t})\n\n\tlinks, _, err := client.Groups.ListGroupLDAPLinks(1)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupLDAPLinks returned error: %v\", err)\n\t}\n\n\twant := []*LDAPGroupLink{\n\t\t{\n\t\t\tCN:          \"gitlab_group_example_30\",\n\t\t\tGroupAccess: 30,\n\t\t\tProvider:    \"example_ldap_provider\",\n\t\t},\n\t\t{\n\t\t\tCN:          \"gitlab_group_example_40\",\n\t\t\tGroupAccess: 40,\n\t\t\tProvider:    \"example_ldap_provider\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, links) {\n\t\tt.Errorf(\"Groups.ListGroupLDAPLinks returned %+v, want %+v\", links, want)\n\t}\n}\n\nfunc TestAddGroupLDAPLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/ldap_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"cn\":\"gitlab_group_example_30\",\n\t\"group_access\":30,\n\t\"provider\":\"example_ldap_provider\"\n}`)\n\t\t})\n\n\topt := &AddGroupLDAPLinkOptions{\n\t\tCN:          Ptr(\"gitlab_group_example_30\"),\n\t\tGroupAccess: Ptr(AccessLevelValue(30)),\n\t\tProvider:    Ptr(\"example_ldap_provider\"),\n\t}\n\n\tlink, _, err := client.Groups.AddGroupLDAPLink(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.AddGroupLDAPLink returned error: %v\", err)\n\t}\n\n\twant := &LDAPGroupLink{\n\t\tCN:          \"gitlab_group_example_30\",\n\t\tGroupAccess: 30,\n\t\tProvider:    \"example_ldap_provider\",\n\t}\n\tif !reflect.DeepEqual(want, link) {\n\t\tt.Errorf(\"Groups.AddGroupLDAPLink returned %+v, want %+v\", link, want)\n\t}\n}\n\nfunc TestAddGroupLDAPLinkFilter(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/ldap_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"filter\":\"(memberOf=example_group_dn)\",\n\t\"group_access\":30,\n\t\"provider\":\"example_ldap_provider\"\n}`)\n\t\t})\n\n\topt := &AddGroupLDAPLinkOptions{\n\t\tFilter:      Ptr(\"(memberOf=example_group_dn)\"),\n\t\tGroupAccess: Ptr(AccessLevelValue(30)),\n\t\tProvider:    Ptr(\"example_ldap_provider\"),\n\t}\n\n\tlink, _, err := client.Groups.AddGroupLDAPLink(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.AddGroupLDAPLink returned error: %v\", err)\n\t}\n\n\twant := &LDAPGroupLink{\n\t\tFilter:      \"(memberOf=example_group_dn)\",\n\t\tGroupAccess: 30,\n\t\tProvider:    \"example_ldap_provider\",\n\t}\n\tif !reflect.DeepEqual(want, link) {\n\t\tt.Errorf(\"Groups.AddGroupLDAPLink returned %+v, want %+v\", link, want)\n\t}\n}\n\nfunc TestListGroupSAMLLinks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/saml_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[\n\t{\n\t\t\"access_level\":30,\n\t\t\"name\":\"gitlab_group_example_developer\"\n\t},\n\t{\n\t\t\"access_level\":40,\n\t\t\"name\":\"gitlab_group_example_maintainer\"\n\t}\n]`)\n\t\t})\n\n\tlinks, _, err := client.Groups.ListGroupSAMLLinks(1)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupSAMLLinks returned error: %v\", err)\n\t}\n\n\twant := []*SAMLGroupLink{\n\t\t{\n\t\t\tAccessLevel: DeveloperPermissions,\n\t\t\tName:        \"gitlab_group_example_developer\",\n\t\t},\n\t\t{\n\t\t\tAccessLevel: MaintainerPermissions,\n\t\t\tName:        \"gitlab_group_example_maintainer\",\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, links) {\n\t\tt.Errorf(\"Groups.ListGroupSAMLLinks returned %+v, want %+v\", links, want)\n\t}\n}\n\nfunc TestListGroupSAMLLinksCustomRole(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/saml_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `[\n\t{\n\t\t\"access_level\":30,\n\t\t\"name\":\"gitlab_group_example_developer\",\n\t\t\"member_role_id\":123\n\t}\n]`)\n\t\t})\n\n\tlinks, _, err := client.Groups.ListGroupSAMLLinks(1)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ListGroupSAMLLinks returned error: %v\", err)\n\t}\n\n\twant := []*SAMLGroupLink{\n\t\t{\n\t\t\tAccessLevel:  DeveloperPermissions,\n\t\t\tName:         \"gitlab_group_example_developer\",\n\t\t\tMemberRoleID: 123,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, links) {\n\t\tt.Errorf(\"Groups.ListGroupSAMLLinks returned %+v, want %+v\", links, want)\n\t}\n}\n\nfunc TestGetGroupSAMLLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/saml_group_links/gitlab_group_example_developer\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"access_level\":30,\n\t\"name\":\"gitlab_group_example_developer\"\n}`)\n\t\t})\n\n\tlinks, _, err := client.Groups.GetGroupSAMLLink(1, \"gitlab_group_example_developer\")\n\tif err != nil {\n\t\tt.Errorf(\"Groups.GetGroupSAMLLinks returned error: %v\", err)\n\t}\n\n\twant := &SAMLGroupLink{\n\t\tAccessLevel: DeveloperPermissions,\n\t\tName:        \"gitlab_group_example_developer\",\n\t}\n\tif !reflect.DeepEqual(want, links) {\n\t\tt.Errorf(\"Groups.GetGroupSAMLLink returned %+v, want %+v\", links, want)\n\t}\n}\n\nfunc TestGetGroupSAMLLinkCustomRole(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/saml_group_links/gitlab_group_example_developer\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"access_level\":30,\n\t\"name\":\"gitlab_group_example_developer\",\n\t\"member_role_id\":123\n}`)\n\t\t})\n\n\tlinks, _, err := client.Groups.GetGroupSAMLLink(1, \"gitlab_group_example_developer\")\n\tif err != nil {\n\t\tt.Errorf(\"Groups.GetGroupSAMLLinks returned error: %v\", err)\n\t}\n\n\twant := &SAMLGroupLink{\n\t\tAccessLevel:  DeveloperPermissions,\n\t\tName:         \"gitlab_group_example_developer\",\n\t\tMemberRoleID: 123,\n\t}\n\tif !reflect.DeepEqual(want, links) {\n\t\tt.Errorf(\"Groups.GetGroupSAMLLink returned %+v, want %+v\", links, want)\n\t}\n}\n\nfunc TestAddGroupSAMLLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/saml_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"access_level\":30,\n\t\"name\":\"gitlab_group_example_developer\"\n}`)\n\t\t})\n\n\topt := &AddGroupSAMLLinkOptions{\n\t\tSAMLGroupName: Ptr(\"gitlab_group_example_developer\"),\n\t\tAccessLevel:   Ptr(DeveloperPermissions),\n\t}\n\n\tlink, _, err := client.Groups.AddGroupSAMLLink(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.AddGroupSAMLLink returned error: %v\", err)\n\t}\n\n\twant := &SAMLGroupLink{\n\t\tAccessLevel: DeveloperPermissions,\n\t\tName:        \"gitlab_group_example_developer\",\n\t}\n\tif !reflect.DeepEqual(want, link) {\n\t\tt.Errorf(\"Groups.AddGroupSAMLLink returned %+v, want %+v\", link, want)\n\t}\n}\n\nfunc TestAddGroupSAMLLinkCustomRole(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/saml_group_links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `\n{\n\t\"access_level\":30,\n\t\"name\":\"gitlab_group_example_developer\",\n\t\"member_role_id\":123\n}`)\n\t\t})\n\n\topt := &AddGroupSAMLLinkOptions{\n\t\tSAMLGroupName: Ptr(\"gitlab_group_example_developer\"),\n\t\tAccessLevel:   Ptr(DeveloperPermissions),\n\t\tMemberRoleID:  Ptr(123),\n\t}\n\n\tlink, _, err := client.Groups.AddGroupSAMLLink(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.AddGroupSAMLLink returned error: %v\", err)\n\t}\n\n\twant := &SAMLGroupLink{\n\t\tAccessLevel:  DeveloperPermissions,\n\t\tName:         \"gitlab_group_example_developer\",\n\t\tMemberRoleID: 123,\n\t}\n\tif !reflect.DeepEqual(want, link) {\n\t\tt.Errorf(\"Groups.AddGroupSAMLLink returned %+v, want %+v\", link, want)\n\t}\n}\n\nfunc TestRestoreGroup(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/groups/1/restore\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"name\": \"g\"}`)\n\t\t})\n\n\tgroup, _, err := client.Groups.RestoreGroup(1)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.RestoreGroup returned error: %v\", err)\n\t}\n\twant := &Group{ID: 1, Name: \"g\"}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.RestoreGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestShareGroupWithGroup(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/groups/1/share\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"id\": 1, \"name\": \"g\"}`)\n\t\t})\n\n\tgroup, _, err := client.Groups.ShareGroupWithGroup(1, &ShareGroupWithGroupOptions{\n\t\tGroupID:     Ptr(1),\n\t\tGroupAccess: Ptr(DeveloperPermissions),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.ShareGroupWithGroup returned error: %v\", err)\n\t}\n\twant := &Group{ID: 1, Name: \"g\"}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.ShareGroupWithGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestUnshareGroupFromGroup(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/groups/1/share/2\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tw.WriteHeader(204)\n\t\t})\n\n\tr, err := client.Groups.UnshareGroupFromGroup(1, 2)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UnshareGroupFromGroup returned error: %v\", err)\n\t}\n\tif r.StatusCode != 204 {\n\t\tt.Errorf(\"Groups.UnshareGroupFromGroup returned status code %d\", r.StatusCode)\n\t}\n}\n\nfunc TestUpdateGroupWithIPRestrictionRanges(t *testing.T) {\n\tmux, client := setup(t)\n\tconst ipRange = \"192.168.0.0/24\"\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to read the request body. Error: %v\", err)\n\t\t\t}\n\n\t\t\tvar bodyJson map[string]interface{}\n\t\t\terr = json.Unmarshal(body, &bodyJson)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse the request body into JSON. Error: %v\", err)\n\t\t\t}\n\n\t\t\tif bodyJson[\"ip_restriction_ranges\"] != ipRange {\n\t\t\t\tt.Fatalf(\"Test failed. `ip_restriction_ranges` expected to be '%v', got %v\", ipRange, bodyJson[\"ip_restriction_ranges\"])\n\t\t\t}\n\n\t\t\tfmt.Fprintf(w, `{\"id\": 1, \"ip_restriction_ranges\" : \"%v\"}`, ipRange)\n\t\t})\n\n\tgroup, _, err := client.Groups.UpdateGroup(1, &UpdateGroupOptions{\n\t\tIPRestrictionRanges: Ptr(ipRange),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UpdateGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, IPRestrictionRanges: ipRange}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.UpdatedGroup returned %+v, want %+v\", group, want)\n\t}\n}\n\nfunc TestGetGroupWithEmailsEnabled(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\n\t\t\t// Modified from https://docs.gitlab.com/ee/api/groups.html#details-of-a-group\n\t\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"test\",\n\t\t\t\t\"path\": \"test\",\n\t\t\t\t\"emails_enabled\": true,\n\t\t\t\t\"description\": \"Aliquid qui quis dignissimos distinctio ut commodi voluptas est.\",\n\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\"web_url\": \"https://gitlab.example.com/groups/test\",\n\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\"repository_storage\": \"default\",\n\t\t\t\t\"full_name\": \"test\",\n\t\t\t\t\"full_path\": \"test\",\n\t\t\t\t\"runners_token\": \"ba324ca7b1c77fc20bb9\",\n\t\t\t\t\"file_template_project_id\": 1,\n\t\t\t\t\"parent_id\": null,\n\t\t\t\t\"enabled_git_access_protocol\": \"all\",\n\t\t\t\t\"created_at\": \"2020-01-15T12:36:29.590Z\",\n\t\t\t\t\"prevent_sharing_groups_outside_hierarchy\": false,\n\t\t\t\t\"ip_restriction_ranges\": null,\n\t\t\t\t\"math_rendering_limits_enabled\": true,\n\t\t\t\t\"lock_math_rendering_limits_enabled\": false\n\t\t\t  }`)\n\t\t})\n\n\tgroup, _, err := client.Groups.GetGroup(1, &GetGroupOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UpdateGroup returned error: %v\", err)\n\t}\n\n\tif !group.EmailsEnabled {\n\t\tt.Fatalf(\"Failed to parse `emails_enabled`. Wanted true, got %v\", group.EmailsEnabled)\n\t}\n}\n\nfunc TestCreateGroupWithEmailsEnabled(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to read the request body. Error: %v\", err)\n\t\t\t}\n\n\t\t\t// unmarshal into generic JSON since we don't want to test CreateGroupOptions using itself to validate.\n\t\t\tvar bodyJson map[string]interface{}\n\t\t\terr = json.Unmarshal(body, &bodyJson)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse the request body into JSON. Error: %v\", err)\n\t\t\t}\n\n\t\t\tif bodyJson[\"emails_enabled\"] != true {\n\t\t\t\tt.Fatalf(\"Test failed. `emails_enabled` expected to be true, got %v\", bodyJson[\"emails_enabled\"])\n\t\t\t}\n\n\t\t\t// Response is tested via the \"GET\" test, only test the actual request here.\n\t\t\tfmt.Fprint(w, `\n\t\t\t{}`)\n\t\t})\n\n\t_, _, err := client.Groups.CreateGroup(&CreateGroupOptions{EmailsEnabled: Ptr(true)})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.CreateGroup returned error: %v\", err)\n\t}\n}\n\nfunc TestUpdateGroupWithEmailsEnabled(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to read the request body. Error: %v\", err)\n\t\t\t}\n\n\t\t\t// unmarshal into generic JSON since we don't want to test UpdateGroupOptions using itself to validate.\n\t\t\tvar bodyJson map[string]interface{}\n\t\t\terr = json.Unmarshal(body, &bodyJson)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse the request body into JSON. Error: %v\", err)\n\t\t\t}\n\n\t\t\tif bodyJson[\"emails_enabled\"] != true {\n\t\t\t\tt.Fatalf(\"Test failed. `emails_enabled` expected to be true, got %v\", bodyJson[\"emails_enabled\"])\n\t\t\t}\n\n\t\t\t// Response is tested via the \"GET\" test, only test the actual request here.\n\t\t\tfmt.Fprint(w, `\n\t\t\t{}`)\n\t\t})\n\n\t_, _, err := client.Groups.UpdateGroup(1, &UpdateGroupOptions{EmailsEnabled: Ptr(true)})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UpdateGroup returned error: %v\", err)\n\t}\n}\n\nfunc TestGetGroupPushRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/push_rule\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"commit_message_regex\": \"Fixes \\\\d+\\\\..*\",\n\t\t\t\"commit_message_negative_regex\": \"ssh\\\\:\\\\/\\\\/\",\n\t\t\t\"branch_name_regex\": \"(feat|fix)\\\\/*\",\n\t\t\t\"deny_delete_tag\": false,\n\t\t\t\"member_check\": false,\n\t\t\t\"prevent_secrets\": false,\n\t\t\t\"author_email_regex\": \"@company.com$\",\n\t\t\t\"file_name_regex\": \"(jar|exe)$\",\n\t\t\t\"max_file_size\": 5,\n\t\t\t\"commit_committer_check\": false,\n\t\t\t\"commit_committer_name_check\": false,\n\t\t\t\"reject_unsigned_commits\": false,\n\t\t\t\"reject_non_dco_commits\": false\n\t\t  }`)\n\t})\n\n\trule, _, err := client.Groups.GetGroupPushRules(1)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.GetGroupPushRules returned error: %v\", err)\n\t}\n\n\twant := &GroupPushRules{\n\t\tID:                         1,\n\t\tCommitMessageRegex:         \"Fixes \\\\d+\\\\..*\",\n\t\tCommitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n\t\tBranchNameRegex:            \"(feat|fix)\\\\/*\",\n\t\tDenyDeleteTag:              false,\n\t\tMemberCheck:                false,\n\t\tPreventSecrets:             false,\n\t\tAuthorEmailRegex:           \"@company.com$\",\n\t\tFileNameRegex:              \"(jar|exe)$\",\n\t\tMaxFileSize:                5,\n\t\tCommitCommitterCheck:       false,\n\t\tCommitCommitterNameCheck:   false,\n\t\tRejectUnsignedCommits:      false,\n\t\tRejectNonDCOCommits:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Groups.GetGroupPushRules returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestAddGroupPushRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/push_rule\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"commit_message_regex\": \"Fixes \\\\d+\\\\..*\",\n\t\t\t\"commit_message_negative_regex\": \"ssh\\\\:\\\\/\\\\/\",\n\t\t\t\"branch_name_regex\": \"(feat|fix)\\\\/*\",\n\t\t\t\"deny_delete_tag\": false,\n\t\t\t\"member_check\": false,\n\t\t\t\"prevent_secrets\": false,\n\t\t\t\"author_email_regex\": \"@company.com$\",\n\t\t\t\"file_name_regex\": \"(jar|exe)$\",\n\t\t\t\"max_file_size\": 5,\n\t\t\t\"commit_committer_check\": false,\n\t\t\t\"commit_committer_name_check\": false,\n\t\t\t\"reject_unsigned_commits\": false,\n\t\t\t\"reject_non_dco_commits\": false\n\t\t  }`)\n\t})\n\n\topt := &AddGroupPushRuleOptions{\n\t\tCommitMessageRegex:         Ptr(\"Fixes \\\\d+\\\\..*\"),\n\t\tCommitMessageNegativeRegex: Ptr(\"ssh\\\\:\\\\/\\\\/\"),\n\t\tBranchNameRegex:            Ptr(\"(feat|fix)\\\\/*\"),\n\t\tDenyDeleteTag:              Ptr(false),\n\t\tMemberCheck:                Ptr(false),\n\t\tPreventSecrets:             Ptr(false),\n\t\tAuthorEmailRegex:           Ptr(\"@company.com$\"),\n\t\tFileNameRegex:              Ptr(\"(jar|exe)$\"),\n\t\tMaxFileSize:                Ptr(5),\n\t\tCommitCommitterCheck:       Ptr(false),\n\t\tCommitCommitterNameCheck:   Ptr(false),\n\t\tRejectUnsignedCommits:      Ptr(false),\n\t\tRejectNonDCOCommits:        Ptr(false),\n\t}\n\n\trule, _, err := client.Groups.AddGroupPushRule(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.AddGroupPushRule returned error: %v\", err)\n\t}\n\n\twant := &GroupPushRules{\n\t\tID:                         1,\n\t\tCommitMessageRegex:         \"Fixes \\\\d+\\\\..*\",\n\t\tCommitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n\t\tBranchNameRegex:            \"(feat|fix)\\\\/*\",\n\t\tDenyDeleteTag:              false,\n\t\tMemberCheck:                false,\n\t\tPreventSecrets:             false,\n\t\tAuthorEmailRegex:           \"@company.com$\",\n\t\tFileNameRegex:              \"(jar|exe)$\",\n\t\tMaxFileSize:                5,\n\t\tCommitCommitterCheck:       false,\n\t\tCommitCommitterNameCheck:   false,\n\t\tRejectUnsignedCommits:      false,\n\t\tRejectNonDCOCommits:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Groups.AddGroupPushRule returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestEditGroupPushRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/push_rule\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"commit_message_regex\": \"Fixes \\\\d+\\\\..*\",\n\t\t\t\"commit_message_negative_regex\": \"ssh\\\\:\\\\/\\\\/\",\n\t\t\t\"branch_name_regex\": \"(feat|fix)\\\\/*\",\n\t\t\t\"deny_delete_tag\": false,\n\t\t\t\"member_check\": false,\n\t\t\t\"prevent_secrets\": false,\n\t\t\t\"author_email_regex\": \"@company.com$\",\n\t\t\t\"file_name_regex\": \"(jar|exe)$\",\n\t\t\t\"max_file_size\": 5,\n\t\t\t\"commit_committer_check\": false,\n\t\t\t\"commit_committer_name_check\": false,\n\t\t\t\"reject_unsigned_commits\": false,\n\t\t\t\"reject_non_dco_commits\": false\n\t\t  }`)\n\t})\n\n\topt := &EditGroupPushRuleOptions{\n\t\tCommitMessageRegex:         Ptr(\"Fixes \\\\d+\\\\..*\"),\n\t\tCommitMessageNegativeRegex: Ptr(\"ssh\\\\:\\\\/\\\\/\"),\n\t\tBranchNameRegex:            Ptr(\"(feat|fix)\\\\/*\"),\n\t\tDenyDeleteTag:              Ptr(false),\n\t\tMemberCheck:                Ptr(false),\n\t\tPreventSecrets:             Ptr(false),\n\t\tAuthorEmailRegex:           Ptr(\"@company.com$\"),\n\t\tFileNameRegex:              Ptr(\"(jar|exe)$\"),\n\t\tMaxFileSize:                Ptr(5),\n\t\tCommitCommitterCheck:       Ptr(false),\n\t\tCommitCommitterNameCheck:   Ptr(false),\n\t\tRejectUnsignedCommits:      Ptr(false),\n\t\tRejectNonDCOCommits:        Ptr(false),\n\t}\n\n\trule, _, err := client.Groups.EditGroupPushRule(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Groups.EditGroupPushRule returned error: %v\", err)\n\t}\n\n\twant := &GroupPushRules{\n\t\tID:                         1,\n\t\tCommitMessageRegex:         \"Fixes \\\\d+\\\\..*\",\n\t\tCommitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n\t\tBranchNameRegex:            \"(feat|fix)\\\\/*\",\n\t\tDenyDeleteTag:              false,\n\t\tMemberCheck:                false,\n\t\tPreventSecrets:             false,\n\t\tAuthorEmailRegex:           \"@company.com$\",\n\t\tFileNameRegex:              \"(jar|exe)$\",\n\t\tMaxFileSize:                5,\n\t\tCommitCommitterCheck:       false,\n\t\tCommitCommitterNameCheck:   false,\n\t\tRejectUnsignedCommits:      false,\n\t\tRejectNonDCOCommits:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Groups.EditGroupPushRule returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestUpdateGroupWithAllowedEmailDomainsList(t *testing.T) {\n\tmux, client := setup(t)\n\tconst domain = \"example.com\"\n\n\tmux.HandleFunc(\"/api/v4/groups/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to read the request body. Error: %v\", err)\n\t\t\t}\n\n\t\t\tvar bodyJson map[string]interface{}\n\t\t\terr = json.Unmarshal(body, &bodyJson)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Failed to parse the request body into JSON. Error: %v\", err)\n\t\t\t}\n\n\t\t\tif bodyJson[\"allowed_email_domains_list\"] != domain {\n\t\t\t\tt.Fatalf(\"Test failed. `allowed_email_domains_list` expected to be '%v', got %v\", domain, bodyJson[\"allowed_email_domains_list\"])\n\t\t\t}\n\n\t\t\tfmt.Fprintf(w, `{\"id\": 1, \"allowed_email_domains_list\" : \"%v\"}`, domain)\n\t\t})\n\n\tgroup, _, err := client.Groups.UpdateGroup(1, &UpdateGroupOptions{\n\t\tAllowedEmailDomainsList: Ptr(domain),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Groups.UpdateGroup returned error: %v\", err)\n\t}\n\n\twant := &Group{ID: 1, AllowedEmailDomainsList: domain}\n\tif !reflect.DeepEqual(want, group) {\n\t\tt.Errorf(\"Groups.UpdatedGroup returned %+v, want %+v\", group, want)\n\t}\n}\n"
        },
        {
          "name": "import.go",
          "type": "blob",
          "size": 10.212890625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n)\n\n// ImportService handles communication with the import\n// related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html\ntype ImportService struct {\n\tclient *Client\n}\n\n// GitHubImport represents the response from an import from GitHub.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-github\ntype GitHubImport struct {\n\tID                    int    `json:\"id\"`\n\tName                  string `json:\"name\"`\n\tFullPath              string `json:\"full_path\"`\n\tFullName              string `json:\"full_name\"`\n\tRefsUrl               string `json:\"refs_url\"`\n\tImportSource          string `json:\"import_source\"`\n\tImportStatus          string `json:\"import_status\"`\n\tHumanImportStatusName string `json:\"human_import_status_name\"`\n\tProviderLink          string `json:\"provider_link\"`\n\tRelationType          string `json:\"relation_type\"`\n\tImportWarning         string `json:\"import_warning\"`\n}\n\nfunc (s GitHubImport) String() string {\n\treturn Stringify(s)\n}\n\n// ImportRepositoryFromGitHubOptions represents the available\n// ImportRepositoryFromGitHub() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-github\ntype ImportRepositoryFromGitHubOptions struct {\n\tPersonalAccessToken *string `url:\"personal_access_token,omitempty\" json:\"personal_access_token,omitempty\"`\n\tRepoID              *int    `url:\"repo_id,omitempty\" json:\"repo_id,omitempty\"`\n\tNewName             *string `url:\"new_name,omitempty\" json:\"new_name,omitempty\"`\n\tTargetNamespace     *string `url:\"target_namespace,omitempty\" json:\"target_namespace,omitempty\"`\n\tGitHubHostname      *string `url:\"github_hostname,omitempty\" json:\"github_hostname,omitempty\"`\n\tOptionalStages      struct {\n\t\tSingleEndpointNotesImport *bool `url:\"single_endpoint_notes_import,omitempty\" json:\"single_endpoint_notes_import,omitempty\"`\n\t\tAttachmentsImport         *bool `url:\"attachments_import,omitempty\" json:\"attachments_import,omitempty\"`\n\t\tCollaboratorsImport       *bool `url:\"collaborators_import,omitempty\" json:\"collaborators_import,omitempty\"`\n\t} `url:\"optional_stages,omitempty\" json:\"optional_stages,omitempty\"`\n\tTimeoutStrategy *string `url:\"timeout_strategy,omitempty\" json:\"timeout_strategy,omitempty\"`\n}\n\n// Import a repository from GitHub.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-github\nfunc (s *ImportService) ImportRepositoryFromGitHub(opt *ImportRepositoryFromGitHubOptions, options ...RequestOptionFunc) (*GitHubImport, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"import/github\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tgi := new(GitHubImport)\n\tresp, err := s.client.Do(req, gi)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn gi, resp, nil\n}\n\n// CancelledGitHubImport represents the response when canceling\n// an import from GitHub.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#cancel-github-project-import\ntype CancelledGitHubImport struct {\n\tID                    int    `json:\"id\"`\n\tName                  string `json:\"name\"`\n\tFullPath              string `json:\"full_path\"`\n\tFullName              string `json:\"full_name\"`\n\tImportSource          string `json:\"import_source\"`\n\tImportStatus          string `json:\"import_status\"`\n\tHumanImportStatusName string `json:\"human_import_status_name\"`\n\tProviderLink          string `json:\"provider_link\"`\n}\n\nfunc (s CancelledGitHubImport) String() string {\n\treturn Stringify(s)\n}\n\n// CancelGitHubProjectImportOptions represents the available\n// CancelGitHubProjectImport() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#cancel-github-project-import\ntype CancelGitHubProjectImportOptions struct {\n\tProjectID *int `url:\"project_id,omitempty\" json:\"project_id,omitempty\"`\n}\n\n// Cancel an import of a repository from GitHub.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#cancel-github-project-import\nfunc (s *ImportService) CancelGitHubProjectImport(opt *CancelGitHubProjectImportOptions, options ...RequestOptionFunc) (*CancelledGitHubImport, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"import/github/cancel\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcgi := new(CancelledGitHubImport)\n\tresp, err := s.client.Do(req, cgi)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cgi, resp, nil\n}\n\n// ImportGitHubGistsIntoGitLabSnippetsOptions represents the available\n// ImportGitHubGistsIntoGitLabSnippets() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-github-gists-into-gitlab-snippets\ntype ImportGitHubGistsIntoGitLabSnippetsOptions struct {\n\tPersonalAccessToken *string `url:\"personal_access_token,omitempty\" json:\"personal_access_token,omitempty\"`\n}\n\n// Import personal GitHub Gists into personal GitLab Snippets.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-github-gists-into-gitlab-snippets\nfunc (s *ImportService) ImportGitHubGistsIntoGitLabSnippets(opt *ImportGitHubGistsIntoGitLabSnippetsOptions, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"import/github/gists\", opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// BitbucketServerImport represents the response from an import from Bitbucket\n// Server.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-bitbucket-server\ntype BitbucketServerImport struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tFullPath string `json:\"full_path\"`\n\tFullName string `json:\"full_name\"`\n\tRefsUrl  string `json:\"refs_url\"`\n}\n\nfunc (s BitbucketServerImport) String() string {\n\treturn Stringify(s)\n}\n\n// ImportRepositoryFromBitbucketServerOptions represents the available ImportRepositoryFromBitbucketServer() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-bitbucket-server\ntype ImportRepositoryFromBitbucketServerOptions struct {\n\tBitbucketServerUrl      *string `url:\"bitbucket_server_url,omitempty\" json:\"bitbucket_server_url,omitempty\"`\n\tBitbucketServerUsername *string `url:\"bitbucket_server_username,omitempty\" json:\"bitbucket_server_username,omitempty\"`\n\tPersonalAccessToken     *string `url:\"personal_access_token,omitempty\" json:\"personal_access_token,omitempty\"`\n\tBitbucketServerProject  *string `url:\"bitbucket_server_project,omitempty\" json:\"bitbucket_server_project,omitempty\"`\n\tBitbucketServerRepo     *string `url:\"bitbucket_server_repo,omitempty\" json:\"bitbucket_server_repo,omitempty\"`\n\tNewName                 *string `url:\"new_name,omitempty\" json:\"new_name,omitempty\"`\n\tNewNamespace            *string `url:\"new_namespace,omitempty\" json:\"new_namespace,omitempty\"`\n\tTimeoutStrategy         *string `url:\"timeout_strategy,omitempty\" json:\"timeout_strategy,omitempty\"`\n}\n\n// Import a repository from Bitbucket Server.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-bitbucket-server\nfunc (s *ImportService) ImportRepositoryFromBitbucketServer(opt *ImportRepositoryFromBitbucketServerOptions, options ...RequestOptionFunc) (*BitbucketServerImport, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"import/bitbucket_server\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tbsi := new(BitbucketServerImport)\n\tresp, err := s.client.Do(req, bsi)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bsi, resp, nil\n}\n\n// BitbucketCloudImport represents the response from an import from Bitbucket\n// Cloud.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-bitbucket-cloud\ntype BitbucketCloudImport struct {\n\tID                    int    `json:\"id\"`\n\tName                  string `json:\"name\"`\n\tFullPath              string `json:\"full_path\"`\n\tFullName              string `json:\"full_name\"`\n\tRefsUrl               string `json:\"refs_url\"`\n\tImportSource          string `json:\"import_source\"`\n\tImportStatus          string `json:\"import_status\"`\n\tHumanImportStatusName string `json:\"human_import_status_name\"`\n\tProviderLink          string `json:\"provider_link\"`\n\tRelationType          string `json:\"relation_type\"`\n\tImportWarning         string `json:\"import_warning\"`\n}\n\nfunc (s BitbucketCloudImport) String() string {\n\treturn Stringify(s)\n}\n\n// ImportRepositoryFromBitbucketCloudOptions represents the available\n// ImportRepositoryFromBitbucketCloud() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-bitbucket-cloud\ntype ImportRepositoryFromBitbucketCloudOptions struct {\n\tBitbucketUsername    *string `url:\"bitbucket_username,omitempty\" json:\"bitbucket_username,omitempty\"`\n\tBitbucketAppPassword *string `url:\"bitbucket_app_password,omitempty\" json:\"bitbucket_app_password,omitempty\"`\n\tRepoPath             *string `url:\"repo_path,omitempty\" json:\"repo_path,omitempty\"`\n\tTargetNamespace      *string `url:\"target_namespace,omitempty\" json:\"target_namespace,omitempty\"`\n\tNewName              *string `url:\"new_name,omitempty\" json:\"new_name,omitempty\"`\n}\n\n// Import a repository from Bitbucket Cloud.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/import.html#import-repository-from-bitbucket-cloud\nfunc (s *ImportService) ImportRepositoryFromBitbucketCloud(opt *ImportRepositoryFromBitbucketCloudOptions, options ...RequestOptionFunc) (*BitbucketCloudImport, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"import/bitbucket\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tbci := new(BitbucketCloudImport)\n\tresp, err := s.client.Do(req, bci)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bci, resp, nil\n}\n"
        },
        {
          "name": "import_test.go",
          "type": "blob",
          "size": 6.3896484375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestImportService_ImportRepositoryFromGitHub(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/import/github\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": 27,\n\t\t\t\t\"name\": \"my-repo\",\n\t\t\t\t\"full_path\": \"/root/my-repo\",\n\t\t\t\t\"full_name\": \"Administrator / my-repo\",\n\t\t\t\t\"refs_url\": \"/root/my-repo/refs\",\n\t\t\t\t\"import_source\": \"my-github/repo\",\n\t\t\t\t\"import_status\": \"scheduled\",\n\t\t\t\t\"human_import_status_name\": \"scheduled\",\n\t\t\t\t\"provider_link\": \"/my-github/repo\",\n\t\t\t\t\"relation_type\": null,\n\t\t\t\t\"import_warning\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &GitHubImport{\n\t\tID:                    27,\n\t\tName:                  \"my-repo\",\n\t\tFullPath:              \"/root/my-repo\",\n\t\tFullName:              \"Administrator / my-repo\",\n\t\tRefsUrl:               \"/root/my-repo/refs\",\n\t\tImportSource:          \"my-github/repo\",\n\t\tImportStatus:          \"scheduled\",\n\t\tHumanImportStatusName: \"scheduled\",\n\t\tProviderLink:          \"/my-github/repo\",\n\t}\n\n\topt := &ImportRepositoryFromGitHubOptions{\n\t\tPersonalAccessToken: Ptr(\"token\"),\n\t\tRepoID:              Ptr(34),\n\t\tTargetNamespace:     Ptr(\"root\"),\n\t}\n\n\tgi, resp, err := client.Import.ImportRepositoryFromGitHub(opt)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, gi)\n\n\tgi, resp, err = client.Import.ImportRepositoryFromGitHub(opt, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, gi)\n}\n\nfunc TestImportService_CancelGitHubProjectImport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/import/github/cancel\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": 27,\n\t\t\t\t\"name\": \"my-repo\",\n\t\t\t\t\"full_path\": \"/root/my-repo\",\n\t\t\t\t\"full_name\": \"Administrator / my-repo\",\n\t\t\t\t\"import_source\": \"my-github/repo\",\n\t\t\t\t\"import_status\": \"scheduled\",\n\t\t\t\t\"human_import_status_name\": \"scheduled\",\n\t\t\t\t\"provider_link\": \"/my-github/repo\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &CancelledGitHubImport{\n\t\tID:                    27,\n\t\tName:                  \"my-repo\",\n\t\tFullPath:              \"/root/my-repo\",\n\t\tFullName:              \"Administrator / my-repo\",\n\t\tImportSource:          \"my-github/repo\",\n\t\tImportStatus:          \"scheduled\",\n\t\tHumanImportStatusName: \"scheduled\",\n\t\tProviderLink:          \"/my-github/repo\",\n\t}\n\n\topt := &CancelGitHubProjectImportOptions{\n\t\tProjectID: Ptr(27),\n\t}\n\n\tcgi, resp, err := client.Import.CancelGitHubProjectImport(opt)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, cgi)\n\n\tcgi, resp, err = client.Import.CancelGitHubProjectImport(opt, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cgi)\n}\n\nfunc TestImportService_ImportGitHubGistsIntoGitLabSnippets(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/import/github/gists\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t})\n\n\topt := &ImportGitHubGistsIntoGitLabSnippetsOptions{PersonalAccessToken: Ptr(\"token\")}\n\n\tresp, err := client.Import.ImportGitHubGistsIntoGitLabSnippets(opt)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Import.ImportGitHubGistsIntoGitLabSnippets(opt, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n}\n\nfunc TestImportService_ImportRepositoryFromBitbucketServer(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/import/bitbucket_server\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": 27,\n\t\t\t\t\"name\": \"my-repo\",\n\t\t\t\t\"full_path\": \"/root/my-repo\",\n\t\t\t\t\"full_name\": \"Administrator / my-repo\",\n\t\t\t\t\"refs_url\": \"/root/my-repo/refs\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &BitbucketServerImport{\n\t\tID:       27,\n\t\tName:     \"my-repo\",\n\t\tFullPath: \"/root/my-repo\",\n\t\tFullName: \"Administrator / my-repo\",\n\t\tRefsUrl:  \"/root/my-repo/refs\",\n\t}\n\n\topt := &ImportRepositoryFromBitbucketServerOptions{\n\t\tBitbucketServerUrl:      Ptr(\"https://bitbucket.example.com\"),\n\t\tBitbucketServerUsername: Ptr(\"username\"),\n\t\tPersonalAccessToken:     Ptr(\"token\"),\n\t\tBitbucketServerProject:  Ptr(\"root\"),\n\t\tBitbucketServerRepo:     Ptr(\"my-repo\"),\n\t\tNewName:                 Ptr(\"my-repo\"),\n\t\tNewNamespace:            Ptr(\"root\"),\n\t\tTimeoutStrategy:         Ptr(\"pessimistic\"),\n\t}\n\n\tbsi, resp, err := client.Import.ImportRepositoryFromBitbucketServer(opt)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bsi)\n\n\tbsi, resp, err = client.Import.ImportRepositoryFromBitbucketServer(opt, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bsi)\n}\n\nfunc TestImportService_ImportRepositoryFromBitbucketCloud(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/import/bitbucket\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": 27,\n\t\t\t\t\"name\": \"my-repo\",\n\t\t\t\t\"full_path\": \"/root/my-repo\",\n\t\t\t\t\"full_name\": \"Administrator / my-repo\",\n\t\t\t\t\"refs_url\": \"/root/my-repo/refs\",\n\t\t\t\t\"import_source\": \"my-bitbucket/repo\",\n\t\t\t\t\"import_status\": \"scheduled\",\n\t\t\t\t\"human_import_status_name\": \"scheduled\",\n\t\t\t\t\"provider_link\": \"/my-bitbucket/repo\",\n\t\t\t\t\"relation_type\": null,\n\t\t\t\t\"import_warning\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &BitbucketCloudImport{\n\t\tID:                    27,\n\t\tName:                  \"my-repo\",\n\t\tFullPath:              \"/root/my-repo\",\n\t\tFullName:              \"Administrator / my-repo\",\n\t\tRefsUrl:               \"/root/my-repo/refs\",\n\t\tImportSource:          \"my-bitbucket/repo\",\n\t\tImportStatus:          \"scheduled\",\n\t\tHumanImportStatusName: \"scheduled\",\n\t\tProviderLink:          \"/my-bitbucket/repo\",\n\t}\n\n\topt := &ImportRepositoryFromBitbucketCloudOptions{\n\t\tBitbucketUsername:    Ptr(\"username\"),\n\t\tBitbucketAppPassword: Ptr(\"password\"),\n\t\tRepoPath:             Ptr(\"/root/my-repo\"),\n\t\tTargetNamespace:      Ptr(\"/root/\"),\n\t\tNewName:              Ptr(\"my-repo\"),\n\t}\n\n\tbci, resp, err := client.Import.ImportRepositoryFromBitbucketCloud(opt)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bci)\n\n\tbci, resp, err = client.Import.ImportRepositoryFromBitbucketCloud(opt, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, bci)\n}\n"
        },
        {
          "name": "instance_clusters.go",
          "type": "blob",
          "size": 4.50390625,
          "content": "//\n// Copyright 2021, Serena Fang\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// InstanceClustersService handles communication with the\n// instance clusters related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_clusters.html\ntype InstanceClustersService struct {\n\tclient *Client\n}\n\n// InstanceCluster represents a GitLab Instance Cluster.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/instance_clusters.html\ntype InstanceCluster struct {\n\tID                 int                 `json:\"id\"`\n\tName               string              `json:\"name\"`\n\tDomain             string              `json:\"domain\"`\n\tManaged            bool                `json:\"managed\"`\n\tCreatedAt          *time.Time          `json:\"created_at\"`\n\tProviderType       string              `json:\"provider_type\"`\n\tPlatformType       string              `json:\"platform_type\"`\n\tEnvironmentScope   string              `json:\"environment_scope\"`\n\tClusterType        string              `json:\"cluster_type\"`\n\tUser               *User               `json:\"user\"`\n\tPlatformKubernetes *PlatformKubernetes `json:\"platform_kubernetes\"`\n\tManagementProject  *ManagementProject  `json:\"management_project\"`\n}\n\nfunc (v InstanceCluster) String() string {\n\treturn Stringify(v)\n}\n\n// ListClusters gets a list of all instance clusters.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_clusters.html#list-instance-clusters\nfunc (s *InstanceClustersService) ListClusters(options ...RequestOptionFunc) ([]*InstanceCluster, *Response, error) {\n\tu := \"admin/clusters\"\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ics []*InstanceCluster\n\tresp, err := s.client.Do(req, &ics)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ics, resp, nil\n}\n\n// GetCluster gets an instance cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_clusters.html#get-a-single-instance-cluster\nfunc (s *InstanceClustersService) GetCluster(cluster int, options ...RequestOptionFunc) (*InstanceCluster, *Response, error) {\n\tu := fmt.Sprintf(\"admin/clusters/%d\", cluster)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tic := new(InstanceCluster)\n\tresp, err := s.client.Do(req, &ic)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ic, resp, nil\n}\n\n// AddCluster adds an existing cluster to the instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_clusters.html#add-existing-instance-cluster\nfunc (s *InstanceClustersService) AddCluster(opt *AddClusterOptions, options ...RequestOptionFunc) (*InstanceCluster, *Response, error) {\n\tu := \"admin/clusters/add\"\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tic := new(InstanceCluster)\n\tresp, err := s.client.Do(req, ic)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ic, resp, nil\n}\n\n// EditCluster updates an existing instance cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_clusters.html#edit-instance-cluster\nfunc (s *InstanceClustersService) EditCluster(cluster int, opt *EditClusterOptions, options ...RequestOptionFunc) (*InstanceCluster, *Response, error) {\n\tu := fmt.Sprintf(\"admin/clusters/%d\", cluster)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tic := new(InstanceCluster)\n\tresp, err := s.client.Do(req, ic)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ic, resp, nil\n}\n\n// DeleteCluster deletes an existing instance cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_clusters.html#delete-instance-cluster\nfunc (s *InstanceClustersService) DeleteCluster(cluster int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"admin/clusters/%d\", cluster)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "instance_clusters_test.go",
          "type": "blob",
          "size": 10.5107421875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestInstanceClustersService_ListClusters(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 9,\n\t\t\t\t\"name\": \"cluster-1\",\n\t\t\t\t\"managed\": true,\n\t\t\t\t\"enabled\": true,\n\t\t\t\t\"domain\": null,\n\t\t\t\t\"provider_type\": \"user\",\n\t\t\t\t\"platform_type\": \"kubernetes\",\n\t\t\t\t\"environment_scope\": \"*\",\n\t\t\t\t\"cluster_type\": \"instance_type\",\n\t\t\t\t\"user\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"platform_kubernetes\": {\n\t\t\t\t  \"api_url\": \"https://example.com\",\n\t\t\t\t  \"namespace\": null,\n\t\t\t\t  \"authorization_type\": \"rbac\",\n\t\t\t\t  \"ca_cert\":\"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\"\n\t\t\t\t},\n\t\t\t\t\"provider_gcp\": null,\n\t\t\t\t\"management_project\": null\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*InstanceCluster{{\n\t\tID:               9,\n\t\tName:             \"cluster-1\",\n\t\tDomain:           \"\",\n\t\tManaged:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"instance_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tEmail:     \"\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://example.com\",\n\t\t\tToken:             \"\",\n\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\",\n\t\t\tNamespace:         \"\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t},\n\t\tManagementProject: nil,\n\t}}\n\n\tics, resp, err := client.InstanceCluster.ListClusters(nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ics)\n\n\tics, resp, err = client.InstanceCluster.ListClusters(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ics)\n}\n\nfunc TestInstanceClustersService_ListClusters_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tics, resp, err := client.InstanceCluster.ListClusters(nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ics)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestInstanceClustersService_GetCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters/9\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 9,\n\t\t\t\"name\": \"cluster-1\",\n\t\t\t\"managed\": true,\n\t\t\t\"enabled\": true,\n\t\t\t\"domain\": null,\n\t\t\t\"provider_type\": \"user\",\n\t\t\t\"platform_type\": \"kubernetes\",\n\t\t\t\"environment_scope\": \"*\",\n\t\t\t\"cluster_type\": \"instance_type\",\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"https://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"platform_kubernetes\": {\n\t\t\t  \"api_url\": \"https://example.com\",\n\t\t\t  \"namespace\": null,\n\t\t\t  \"authorization_type\": \"rbac\",\n\t\t\t  \"ca_cert\":\"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\"\n\t\t\t},\n\t\t\t\"provider_gcp\": null,\n\t\t\t\"management_project\": null\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &InstanceCluster{\n\t\tID:               9,\n\t\tName:             \"cluster-1\",\n\t\tDomain:           \"\",\n\t\tManaged:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"instance_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tEmail:     \"\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://example.com\",\n\t\t\tToken:             \"\",\n\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\",\n\t\t\tNamespace:         \"\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t},\n\t\tManagementProject: nil,\n\t}\n\n\tic, resp, err := client.InstanceCluster.GetCluster(9, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ic)\n\n\tic, resp, err = client.InstanceCluster.GetCluster(9, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ic)\n\n\tic, resp, err = client.InstanceCluster.GetCluster(10, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ic)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestInstanceClustersService_AddCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters/add\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 11,\n\t\t\t\"name\": \"cluster-1\",\n\t\t\t\"managed\": true,\n\t\t\t\"enabled\": true,\n\t\t\t\"domain\": null,\n\t\t\t\"provider_type\": \"user\",\n\t\t\t\"platform_type\": \"kubernetes\",\n\t\t\t\"environment_scope\": \"*\",\n\t\t\t\"cluster_type\": \"instance_type\",\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"https://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"platform_kubernetes\": {\n\t\t\t  \"api_url\": \"https://example.com\",\n\t\t\t  \"namespace\": null,\n\t\t\t  \"authorization_type\": \"rbac\",\n\t\t\t  \"ca_cert\":\"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\"\n\t\t\t},\n\t\t\t\"provider_gcp\": null,\n\t\t\t\"management_project\": null\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &InstanceCluster{\n\t\tID:               11,\n\t\tName:             \"cluster-1\",\n\t\tDomain:           \"\",\n\t\tManaged:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"instance_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tEmail:     \"\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://example.com\",\n\t\t\tToken:             \"\",\n\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\",\n\t\t\tNamespace:         \"\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t},\n\t\tManagementProject: nil,\n\t}\n\n\tic, resp, err := client.InstanceCluster.AddCluster(nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ic)\n\n\tic, resp, err = client.InstanceCluster.AddCluster(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ic)\n}\n\nfunc TestInstanceClustersService_AddCluster_StatusInternalServerError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters/add\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t})\n\n\tic, resp, err := client.InstanceCluster.AddCluster(nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ic)\n\trequire.Equal(t, http.StatusInternalServerError, resp.StatusCode)\n}\n\nfunc TestInstanceClustersService_EditCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters/11\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 11,\n\t\t\t\"name\": \"cluster-1\",\n\t\t\t\"managed\": true,\n\t\t\t\"enabled\": true,\n\t\t\t\"domain\": null,\n\t\t\t\"provider_type\": \"user\",\n\t\t\t\"platform_type\": \"kubernetes\",\n\t\t\t\"environment_scope\": \"*\",\n\t\t\t\"cluster_type\": \"instance_type\",\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"https://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"platform_kubernetes\": {\n\t\t\t  \"api_url\": \"https://example.com\",\n\t\t\t  \"namespace\": null,\n\t\t\t  \"authorization_type\": \"rbac\",\n\t\t\t  \"ca_cert\":\"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\"\n\t\t\t},\n\t\t\t\"provider_gcp\": null,\n\t\t\t\"management_project\": null\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &InstanceCluster{\n\t\tID:               11,\n\t\tName:             \"cluster-1\",\n\t\tDomain:           \"\",\n\t\tManaged:          true,\n\t\tProviderType:     \"user\",\n\t\tPlatformType:     \"kubernetes\",\n\t\tEnvironmentScope: \"*\",\n\t\tClusterType:      \"instance_type\",\n\t\tUser: &User{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tEmail:     \"\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t},\n\t\tPlatformKubernetes: &PlatformKubernetes{\n\t\t\tAPIURL:            \"https://example.com\",\n\t\t\tToken:             \"\",\n\t\t\tCaCert:            \"-----BEGIN CERTIFICATE-----IxMDM1MV0ZDJkZjM...-----END CERTIFICATE-----\",\n\t\t\tNamespace:         \"\",\n\t\t\tAuthorizationType: \"rbac\",\n\t\t},\n\t\tManagementProject: nil,\n\t}\n\n\tic, resp, err := client.InstanceCluster.EditCluster(11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ic)\n\n\tic, resp, err = client.InstanceCluster.EditCluster(11, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ic)\n\n\tic, resp, err = client.InstanceCluster.EditCluster(12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ic)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestInstanceClustersService_DeleteCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/clusters/11\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.InstanceCluster.DeleteCluster(11, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.InstanceCluster.DeleteCluster(11, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.InstanceCluster.DeleteCluster(12, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "instance_variables.go",
          "type": "blob",
          "size": 6.2216796875,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// InstanceVariablesService handles communication with the\n// instance level CI variables related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html\ntype InstanceVariablesService struct {\n\tclient *Client\n}\n\n// InstanceVariable represents a GitLab instance level CI Variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html\ntype InstanceVariable struct {\n\tKey          string            `json:\"key\"`\n\tValue        string            `json:\"value\"`\n\tVariableType VariableTypeValue `json:\"variable_type\"`\n\tProtected    bool              `json:\"protected\"`\n\tMasked       bool              `json:\"masked\"`\n\tRaw          bool              `json:\"raw\"`\n\tDescription  string            `json:\"description\"`\n}\n\nfunc (v InstanceVariable) String() string {\n\treturn Stringify(v)\n}\n\n// ListInstanceVariablesOptions represents the available options for listing variables\n// for an instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#list-all-instance-variables\ntype ListInstanceVariablesOptions ListOptions\n\n// ListVariables gets a list of all variables for an instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#list-all-instance-variables\nfunc (s *InstanceVariablesService) ListVariables(opt *ListInstanceVariablesOptions, options ...RequestOptionFunc) ([]*InstanceVariable, *Response, error) {\n\tu := \"admin/ci/variables\"\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar vs []*InstanceVariable\n\tresp, err := s.client.Do(req, &vs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn vs, resp, nil\n}\n\n// GetVariable gets a variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#show-instance-variable-details\nfunc (s *InstanceVariablesService) GetVariable(key string, options ...RequestOptionFunc) (*InstanceVariable, *Response, error) {\n\tu := fmt.Sprintf(\"admin/ci/variables/%s\", url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(InstanceVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// CreateInstanceVariableOptions represents the available CreateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#create-instance-variable\ntype CreateInstanceVariableOptions struct {\n\tKey          *string            `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tValue        *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tDescription  *string            `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tMasked       *bool              `url:\"masked,omitempty\" json:\"masked,omitempty\"`\n\tProtected    *bool              `url:\"protected,omitempty\" json:\"protected,omitempty\"`\n\tRaw          *bool              `url:\"raw,omitempty\" json:\"raw,omitempty\"`\n\tVariableType *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// CreateVariable creates a new instance level CI variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#create-instance-variable\nfunc (s *InstanceVariablesService) CreateVariable(opt *CreateInstanceVariableOptions, options ...RequestOptionFunc) (*InstanceVariable, *Response, error) {\n\tu := \"admin/ci/variables\"\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(InstanceVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// UpdateInstanceVariableOptions represents the available UpdateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#update-instance-variable\ntype UpdateInstanceVariableOptions struct {\n\tValue        *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tDescription  *string            `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tMasked       *bool              `url:\"masked,omitempty\" json:\"masked,omitempty\"`\n\tProtected    *bool              `url:\"protected,omitempty\" json:\"protected,omitempty\"`\n\tRaw          *bool              `url:\"raw,omitempty\" json:\"raw,omitempty\"`\n\tVariableType *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// UpdateVariable updates the position of an existing\n// instance level CI variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#update-instance-variable\nfunc (s *InstanceVariablesService) UpdateVariable(key string, opt *UpdateInstanceVariableOptions, options ...RequestOptionFunc) (*InstanceVariable, *Response, error) {\n\tu := fmt.Sprintf(\"admin/ci/variables/%s\", url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(InstanceVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// RemoveVariable removes an instance level CI variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/instance_level_ci_variables.html#remove-instance-variable\nfunc (s *InstanceVariablesService) RemoveVariable(key string, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"admin/ci/variables/%s\", url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "instance_variables_test.go",
          "type": "blob",
          "size": 5.720703125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestInstanceVariablesService_ListVariables(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"key\": \"TEST_VARIABLE_1\",\n\t\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\t\"value\": \"TEST_1\",\n\t\t\t\t\t\"protected\": false,\n\t\t\t\t\t\"masked\": false,\n\t\t\t\t\t\"raw\": true\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*InstanceVariable{{\n\t\tKey:          \"TEST_VARIABLE_1\",\n\t\tValue:        \"TEST_1\",\n\t\tVariableType: \"env_var\",\n\t\tProtected:    false,\n\t\tMasked:       false,\n\t\tRaw:          true,\n\t}}\n\n\tivs, resp, err := client.InstanceVariables.ListVariables(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ivs)\n\n\tivs, resp, err = client.InstanceVariables.ListVariables(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ivs)\n}\n\nfunc TestInstanceVariablesService_ListVariables_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tivs, resp, err := client.InstanceVariables.ListVariables(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ivs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestInstanceVariablesService_GetVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables/TEST_VARIABLE_1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"TEST_VARIABLE_1\",\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"value\": \"TEST_1\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"masked\": false,\n\t\t\t\t\"raw\": true\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &InstanceVariable{\n\t\tKey:          \"TEST_VARIABLE_1\",\n\t\tValue:        \"TEST_1\",\n\t\tVariableType: \"env_var\",\n\t\tProtected:    false,\n\t\tMasked:       false,\n\t\tRaw:          true,\n\t}\n\n\tiv, resp, err := client.InstanceVariables.GetVariable(\"TEST_VARIABLE_1\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, iv)\n\n\tiv, resp, err = client.InstanceVariables.GetVariable(\"TEST_VARIABLE_1\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, iv)\n\n\tiv, resp, err = client.InstanceVariables.GetVariable(\"TEST_VARIABLE_2\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, iv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestInstanceVariablesService_CreateVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"NEW_VARIABLE\",\n\t\t\t\t\"value\": \"new value\",\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"masked\": false,\n\t\t\t\t\"raw\": true\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &InstanceVariable{\n\t\tKey:          \"NEW_VARIABLE\",\n\t\tValue:        \"new value\",\n\t\tVariableType: \"env_var\",\n\t\tProtected:    false,\n\t\tMasked:       false,\n\t\tRaw:          true,\n\t}\n\n\tiv, resp, err := client.InstanceVariables.CreateVariable(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, iv)\n\n\tiv, resp, err = client.InstanceVariables.CreateVariable(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, iv)\n}\n\nfunc TestInstanceVariablesService_StatusInternalServerError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t})\n\n\tiv, resp, err := client.InstanceVariables.CreateVariable(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, iv)\n\trequire.Equal(t, http.StatusInternalServerError, resp.StatusCode)\n}\n\nfunc TestInstanceVariablesService_UpdateVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables/NEW_VARIABLE\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"NEW_VARIABLE\",\n\t\t\t\t\"value\": \"updated value\",\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"masked\": false,\n\t\t\t\t\"raw\": true\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &InstanceVariable{\n\t\tKey:          \"NEW_VARIABLE\",\n\t\tValue:        \"updated value\",\n\t\tVariableType: \"env_var\",\n\t\tProtected:    false,\n\t\tMasked:       false,\n\t\tRaw:          true,\n\t}\n\n\tiv, resp, err := client.InstanceVariables.UpdateVariable(\"NEW_VARIABLE\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, iv)\n\n\tiv, resp, err = client.InstanceVariables.UpdateVariable(\"NEW_VARIABLE\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, iv)\n\n\tiv, resp, err = client.InstanceVariables.UpdateVariable(\"NEW_VARIABLE_1\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, iv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestInstanceVariablesService_RemoveVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/admin/ci/variables/NEW_VARIABLE\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.InstanceVariables.RemoveVariable(\"NEW_VARIABLE\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.InstanceVariables.RemoveVariable(\"NEW_VARIABLE\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.InstanceVariables.RemoveVariable(\"NEW_VARIABLE_1\", nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "invites.go",
          "type": "blob",
          "size": 5.427734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// InvitesService handles communication with the invitation related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/invitations.html\ntype InvitesService struct {\n\tclient *Client\n}\n\n// PendingInvite represents a pending invite.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/invitations.html\ntype PendingInvite struct {\n\tID            int              `json:\"id\"`\n\tInviteEmail   string           `json:\"invite_email\"`\n\tCreatedAt     *time.Time       `json:\"created_at\"`\n\tAccessLevel   AccessLevelValue `json:\"access_level\"`\n\tExpiresAt     *time.Time       `json:\"expires_at\"`\n\tUserName      string           `json:\"user_name\"`\n\tCreatedByName string           `json:\"created_by_name\"`\n}\n\n// ListPendingInvitationsOptions represents the available\n// ListPendingInvitations() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#list-all-invitations-pending-for-a-group-or-project\ntype ListPendingInvitationsOptions struct {\n\tListOptions\n\tQuery *string `url:\"query,omitempty\" json:\"query,omitempty\"`\n}\n\n// ListPendingGroupInvitations gets a list of invited group members.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#list-all-invitations-pending-for-a-group-or-project\nfunc (s *InvitesService) ListPendingGroupInvitations(gid interface{}, opt *ListPendingInvitationsOptions, options ...RequestOptionFunc) ([]*PendingInvite, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/invitations\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pis []*PendingInvite\n\tresp, err := s.client.Do(req, &pis)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pis, resp, nil\n}\n\n// ListPendingProjectInvitations gets a list of invited project members.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#list-all-invitations-pending-for-a-group-or-project\nfunc (s *InvitesService) ListPendingProjectInvitations(pid interface{}, opt *ListPendingInvitationsOptions, options ...RequestOptionFunc) ([]*PendingInvite, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/invitations\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pis []*PendingInvite\n\tresp, err := s.client.Do(req, &pis)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pis, resp, nil\n}\n\n// InvitesOptions represents the available GroupInvites() and ProjectInvites()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#add-a-member-to-a-group-or-project\ntype InvitesOptions struct {\n\tID          interface{}       `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tEmail       *string           `url:\"email,omitempty\" json:\"email,omitempty\"`\n\tUserID      interface{}       `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt   *ISOTime          `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// InvitesResult represents an invitations result.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#add-a-member-to-a-group-or-project\ntype InvitesResult struct {\n\tStatus  string            `json:\"status\"`\n\tMessage map[string]string `json:\"message,omitempty\"`\n}\n\n// GroupInvites invites new users by email to join a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#add-a-member-to-a-group-or-project\nfunc (s *InvitesService) GroupInvites(gid interface{}, opt *InvitesOptions, options ...RequestOptionFunc) (*InvitesResult, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/invitations\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tir := new(InvitesResult)\n\tresp, err := s.client.Do(req, ir)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ir, resp, nil\n}\n\n// ProjectInvites invites new users by email to join a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/invitations.html#add-a-member-to-a-group-or-project\nfunc (s *InvitesService) ProjectInvites(pid interface{}, opt *InvitesOptions, options ...RequestOptionFunc) (*InvitesResult, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/invitations\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tir := new(InvitesResult)\n\tresp, err := s.client.Do(req, ir)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ir, resp, nil\n}\n"
        },
        {
          "name": "invites_test.go",
          "type": "blob",
          "size": 4.099609375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListGroupPendingInvites(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/test/invitations\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListPendingInvitationsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t}\n\n\tprojects, _, err := client.Invites.ListPendingGroupInvitations(\"test\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Invites.ListPendingGroupInvitations returned error: %v\", err)\n\t}\n\n\twant := []*PendingInvite{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Invites.ListPendingGroupInvitations returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestGroupInvites(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/test/invitations\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"status\": \"success\"}`)\n\t})\n\n\topt := &InvitesOptions{\n\t\tEmail: Ptr(\"example@member.org\"),\n\t}\n\n\tprojects, _, err := client.Invites.GroupInvites(\"test\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Invites.GroupInvites returned error: %v\", err)\n\t}\n\n\twant := &InvitesResult{Status: \"success\"}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Invites.GroupInvites returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestGroupInvitesError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/test/invitations\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"status\": \"error\",\"message\": {\"example@member.org\": \"Already invited\"}}`)\n\t})\n\n\topt := &InvitesOptions{\n\t\tEmail: Ptr(\"example@member.org\"),\n\t}\n\n\tprojects, _, err := client.Invites.GroupInvites(\"test\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Invites.GroupInvites returned error: %v\", err)\n\t}\n\n\twant := &InvitesResult{Status: \"error\", Message: map[string]string{\"example@member.org\": \"Already invited\"}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Invites.GroupInvites returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListProjectPendingInvites(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/test/invitations\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListPendingInvitationsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t}\n\n\tprojects, _, err := client.Invites.ListPendingProjectInvitations(\"test\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Invites.ListPendingProjectInvitations returned error: %v\", err)\n\t}\n\n\twant := []*PendingInvite{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Invites.ListPendingProjectInvitations returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestProjectInvites(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/test/invitations\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"status\": \"success\"}`)\n\t})\n\n\topt := &InvitesOptions{\n\t\tEmail: Ptr(\"example@member.org\"),\n\t}\n\n\tprojects, _, err := client.Invites.ProjectInvites(\"test\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Invites.ProjectInvites returned error: %v\", err)\n\t}\n\n\twant := &InvitesResult{Status: \"success\"}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Invites.ProjectInvites returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestProjectInvitesError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/test/invitations\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"status\": \"error\",\"message\": {\"example@member.org\": \"Already invited\"}}`)\n\t})\n\n\topt := &InvitesOptions{\n\t\tEmail: Ptr(\"example@member.org\"),\n\t}\n\n\tprojects, _, err := client.Invites.ProjectInvites(\"test\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Invites.ProjectInvites returned error: %v\", err)\n\t}\n\n\twant := &InvitesResult{Status: \"error\", Message: map[string]string{\"example@member.org\": \"Already invited\"}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Invites.ProjectInvites returned %+v, want %+v\", projects, want)\n\t}\n}\n"
        },
        {
          "name": "issue_links.go",
          "type": "blob",
          "size": 5.7744140625,
          "content": "//\n// Copyright 2021, Arkbriar\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// IssueLinksService handles communication with the issue relations related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issue_links.html\ntype IssueLinksService struct {\n\tclient *Client\n}\n\n// IssueLink represents a two-way relation between two issues.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issue_links.html\ntype IssueLink struct {\n\tSourceIssue *Issue `json:\"source_issue\"`\n\tTargetIssue *Issue `json:\"target_issue\"`\n\tLinkType    string `json:\"link_type\"`\n}\n\n// IssueRelation gets a relation between two issues.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issue_links.html#list-issue-relations\ntype IssueRelation struct {\n\tID             int              `json:\"id\"`\n\tIID            int              `json:\"iid\"`\n\tState          string           `json:\"state\"`\n\tDescription    string           `json:\"description\"`\n\tConfidential   bool             `json:\"confidential\"`\n\tAuthor         *IssueAuthor     `json:\"author\"`\n\tMilestone      *Milestone       `json:\"milestone\"`\n\tProjectID      int              `json:\"project_id\"`\n\tAssignees      []*IssueAssignee `json:\"assignees\"`\n\tAssignee       *IssueAssignee   `json:\"assignee\"`\n\tUpdatedAt      *time.Time       `json:\"updated_at\"`\n\tTitle          string           `json:\"title\"`\n\tCreatedAt      *time.Time       `json:\"created_at\"`\n\tLabels         Labels           `json:\"labels\"`\n\tDueDate        *ISOTime         `json:\"due_date\"`\n\tWebURL         string           `json:\"web_url\"`\n\tReferences     *IssueReferences `json:\"references\"`\n\tWeight         int              `json:\"weight\"`\n\tUserNotesCount int              `json:\"user_notes_count\"`\n\tIssueLinkID    int              `json:\"issue_link_id\"`\n\tLinkType       string           `json:\"link_type\"`\n\tLinkCreatedAt  *time.Time       `json:\"link_created_at\"`\n\tLinkUpdatedAt  *time.Time       `json:\"link_updated_at\"`\n}\n\n// ListIssueRelations gets a list of related issues of a given issue,\n// sorted by the relationship creation datetime (ascending).\n//\n// Issues will be filtered according to the user authorizations.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issue_links.html#list-issue-relations\nfunc (s *IssueLinksService) ListIssueRelations(pid interface{}, issue int, options ...RequestOptionFunc) ([]*IssueRelation, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/links\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar is []*IssueRelation\n\tresp, err := s.client.Do(req, &is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// GetIssueLink gets a specific issue link.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issue_links.html#get-an-issue-link\nfunc (s *IssueLinksService) GetIssueLink(pid interface{}, issue, issueLink int, options ...RequestOptionFunc) (*IssueLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/links/%d\", PathEscape(project), issue, issueLink)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\til := new(IssueLink)\n\tresp, err := s.client.Do(req, il)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn il, resp, nil\n}\n\n// CreateIssueLinkOptions represents the available CreateIssueLink() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issue_links.html#create-an-issue-link\ntype CreateIssueLinkOptions struct {\n\tTargetProjectID *string `json:\"target_project_id\"`\n\tTargetIssueIID  *string `json:\"target_issue_iid\"`\n\tLinkType        *string `json:\"link_type\"`\n}\n\n// CreateIssueLink creates a two-way relation between two issues.\n// User must be allowed to update both issues in order to succeed.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issue_links.html#create-an-issue-link\nfunc (s *IssueLinksService) CreateIssueLink(pid interface{}, issue int, opt *CreateIssueLinkOptions, options ...RequestOptionFunc) (*IssueLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/links\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(IssueLink)\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// DeleteIssueLink deletes an issue link, thus removes the two-way relationship.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issue_links.html#delete-an-issue-link\nfunc (s *IssueLinksService) DeleteIssueLink(pid interface{}, issue, issueLink int, options ...RequestOptionFunc) (*IssueLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/links/%d\",\n\t\tPathEscape(project),\n\t\tissue,\n\t\tissueLink)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\til := new(IssueLink)\n\tresp, err := s.client.Do(req, &il)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn il, resp, nil\n}\n"
        },
        {
          "name": "issue_links_test.go",
          "type": "blob",
          "size": 10.423828125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestIssueLinksService_ListIssueRelations(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/4/issues/14/links\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\" : 84,\n\t\t\t\t\"iid\" : 14,\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"issue_link_id\": 1,\n\t\t\t\t\"project_id\" : 4,\n\t\t\t\t\"title\" : \"Issues with auth\",\n\t\t\t\t\"state\" : \"opened\",\n\t\t\t\t\"assignees\" : [],\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [\n\t\t\t\t  \"bug\"\n\t\t\t\t],\n\t\t\t\t\"author\" : {\n\t\t\t\t  \"name\" : \"Venkatesh Thalluri\",\n\t\t\t\t  \"avatar_url\" : null,\n\t\t\t\t  \"state\" : \"active\",\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\t  \"id\" : 18,\n\t\t\t\t  \"username\" : \"venkatesh.thalluri\"\n\t\t\t\t},\n\t\t\t\t\"description\" : null,\n\t\t\t\t\"milestone\" : null,\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"web_url\": \"http://example.com/example/example/issues/14\",\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null,\n\t\t\t\t\"link_type\": \"relates_to\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*IssueRelation{{\n\t\tID:           84,\n\t\tIID:          14,\n\t\tState:        \"opened\",\n\t\tDescription:  \"\",\n\t\tConfidential: false,\n\t\tAuthor: &IssueAuthor{\n\t\t\tID:        18,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/eileen.lowe\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"venkatesh.thalluri\",\n\t\t},\n\t\tMilestone:   nil,\n\t\tProjectID:   4,\n\t\tAssignees:   []*IssueAssignee{},\n\t\tAssignee:    nil,\n\t\tTitle:       \"Issues with auth\",\n\t\tLabels:      []string{\"bug\"},\n\t\tWebURL:      \"http://example.com/example/example/issues/14\",\n\t\tWeight:      0,\n\t\tIssueLinkID: 1,\n\t\tLinkType:    \"relates_to\",\n\t}}\n\n\tis, resp, err := client.IssueLinks.ListIssueRelations(4, 14, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, is)\n\n\tis, resp, err = client.IssueLinks.ListIssueRelations(4.01, 14, nil)\n\trequire.EqualError(t, err, \"invalid ID type 4.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.IssueLinks.ListIssueRelations(4, 14, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.IssueLinks.ListIssueRelations(8, 14, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, is)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueLinksService_CreateIssueLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/4/issues/1/links\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"source_issue\" : {\n\t\t\t\t\"id\" : 83,\n\t\t\t\t\"iid\" : 11,\n\t\t\t\t\"project_id\" : 4,\n\t\t\t\t\"title\" : \"Issues with auth\",\n\t\t\t\t\"state\" : \"opened\",\n\t\t\t\t\"assignees\" : [],\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [\n\t\t\t\t  \"bug\"\n\t\t\t\t],\n\t\t\t\t\"author\" : {\n\t\t\t\t  \"name\" : \"Venkatesh Thalluri\",\n\t\t\t\t  \"avatar_url\" : null,\n\t\t\t\t  \"state\" : \"active\",\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\t  \"id\" : 18,\n\t\t\t\t  \"username\" : \"venkatesh.thalluri\"\n\t\t\t\t},\n\t\t\t\t\"description\" : null,\n\t\t\t\t\"milestone\" : null,\n\t\t\t\t\"subscribed\" : true,\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"web_url\": \"http://example.com/example/example/issues/11\",\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null\n\t\t\t  },\n\t\t\t  \"target_issue\" : {\n\t\t\t\t\"id\" : 84,\n\t\t\t\t\"iid\" : 14,\n\t\t\t\t\"project_id\" : 4,\n\t\t\t\t\"title\" : \"Issues with auth\",\n\t\t\t\t\"state\" : \"opened\",\n\t\t\t\t\"assignees\" : [],\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [\n\t\t\t\t  \"bug\"\n\t\t\t\t],\n\t\t\t\t\"author\" : {\n\t\t\t\t  \"name\" : \"Alexandra Bashirian\",\n\t\t\t\t  \"avatar_url\" : null,\n\t\t\t\t  \"state\" : \"active\",\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\t  \"id\" : 18,\n\t\t\t\t  \"username\" : \"eileen.lowe\"\n\t\t\t\t},\n\t\t\t\t\"description\" : null,\n\t\t\t\t\"milestone\" : null,\n\t\t\t\t\"subscribed\" : true,\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"web_url\": \"http://example.com/example/example/issues/14\",\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null\n\t\t\t  },\n\t\t\t  \"link_type\": \"relates_to\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &IssueLink{\n\t\tSourceIssue: &Issue{\n\t\t\tID:          83,\n\t\t\tIID:         11,\n\t\t\tExternalID:  \"\",\n\t\t\tState:       \"opened\",\n\t\t\tDescription: \"\",\n\t\t\tAuthor: &IssueAuthor{\n\t\t\t\tID:        18,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tAvatarURL: \"\",\n\t\t\t\tUsername:  \"venkatesh.thalluri\",\n\t\t\t},\n\t\t\tProjectID:         4,\n\t\t\tAssignees:         []*IssueAssignee{},\n\t\t\tTitle:             \"Issues with auth\",\n\t\t\tMovedToID:         0,\n\t\t\tLabels:            []string{\"bug\"},\n\t\t\tUpvotes:           0,\n\t\t\tDownvotes:         0,\n\t\t\tWebURL:            \"http://example.com/example/example/issues/11\",\n\t\t\tConfidential:      false,\n\t\t\tWeight:            0,\n\t\t\tDiscussionLocked:  false,\n\t\t\tSubscribed:        true,\n\t\t\tUserNotesCount:    0,\n\t\t\tIssueLinkID:       0,\n\t\t\tMergeRequestCount: 0,\n\t\t\tEpicIssueID:       0,\n\t\t},\n\t\tTargetIssue: &Issue{\n\t\t\tID:          84,\n\t\t\tIID:         14,\n\t\t\tExternalID:  \"\",\n\t\t\tState:       \"opened\",\n\t\t\tDescription: \"\",\n\t\t\tAuthor: &IssueAuthor{\n\t\t\t\tID:        18,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\tName:      \"Alexandra Bashirian\",\n\t\t\t\tAvatarURL: \"\",\n\t\t\t\tUsername:  \"eileen.lowe\",\n\t\t\t},\n\t\t\tProjectID:         4,\n\t\t\tAssignees:         []*IssueAssignee{},\n\t\t\tTitle:             \"Issues with auth\",\n\t\t\tMovedToID:         0,\n\t\t\tLabels:            []string{\"bug\"},\n\t\t\tUpvotes:           0,\n\t\t\tDownvotes:         0,\n\t\t\tWebURL:            \"http://example.com/example/example/issues/14\",\n\t\t\tConfidential:      false,\n\t\t\tWeight:            0,\n\t\t\tDiscussionLocked:  false,\n\t\t\tSubscribed:        true,\n\t\t\tUserNotesCount:    0,\n\t\t\tIssueLinkID:       0,\n\t\t\tMergeRequestCount: 0,\n\t\t\tEpicIssueID:       0,\n\t\t},\n\t\tLinkType: \"relates_to\",\n\t}\n\n\ti, resp, err := client.IssueLinks.CreateIssueLink(4, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, i)\n\n\ti, resp, err = client.IssueLinks.CreateIssueLink(4.01, 1, nil)\n\trequire.EqualError(t, err, \"invalid ID type 4.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, i)\n\n\ti, resp, err = client.IssueLinks.CreateIssueLink(4, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, i)\n\n\ti, resp, err = client.IssueLinks.CreateIssueLink(8, 1, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, i)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestIssueLinksService_DeleteIssueLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/4/issues/1/links/83\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"source_issue\" : {\n\t\t\t\t\"id\" : 83,\n\t\t\t\t\"iid\" : 11,\n\t\t\t\t\"project_id\" : 4,\n\t\t\t\t\"title\" : \"Issues with auth\",\n\t\t\t\t\"state\" : \"opened\",\n\t\t\t\t\"assignees\" : [],\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [\n\t\t\t\t  \"bug\"\n\t\t\t\t],\n\t\t\t\t\"author\" : {\n\t\t\t\t  \"name\" : \"Venkatesh Thalluri\",\n\t\t\t\t  \"avatar_url\" : null,\n\t\t\t\t  \"state\" : \"active\",\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\t  \"id\" : 18,\n\t\t\t\t  \"username\" : \"venkatesh.thalluri\"\n\t\t\t\t},\n\t\t\t\t\"description\" : null,\n\t\t\t\t\"milestone\" : null,\n\t\t\t\t\"subscribed\" : true,\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"web_url\": \"http://example.com/example/example/issues/11\",\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null\n\t\t\t  },\n\t\t\t  \"target_issue\" : {\n\t\t\t\t\"id\" : 84,\n\t\t\t\t\"iid\" : 14,\n\t\t\t\t\"project_id\" : 4,\n\t\t\t\t\"title\" : \"Issues with auth\",\n\t\t\t\t\"state\" : \"opened\",\n\t\t\t\t\"assignees\" : [],\n\t\t\t\t\"assignee\" : null,\n\t\t\t\t\"labels\" : [\n\t\t\t\t  \"bug\"\n\t\t\t\t],\n\t\t\t\t\"author\" : {\n\t\t\t\t  \"name\" : \"Alexandra Bashirian\",\n\t\t\t\t  \"avatar_url\" : null,\n\t\t\t\t  \"state\" : \"active\",\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\t  \"id\" : 18,\n\t\t\t\t  \"username\" : \"eileen.lowe\"\n\t\t\t\t},\n\t\t\t\t\"description\" : null,\n\t\t\t\t\"milestone\" : null,\n\t\t\t\t\"subscribed\" : true,\n\t\t\t\t\"user_notes_count\": 0,\n\t\t\t\t\"due_date\": null,\n\t\t\t\t\"web_url\": \"http://example.com/example/example/issues/14\",\n\t\t\t\t\"confidential\": false,\n\t\t\t\t\"weight\": null\n\t\t\t  },\n\t\t\t  \"link_type\": \"relates_to\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &IssueLink{\n\t\tSourceIssue: &Issue{\n\t\t\tID:          83,\n\t\t\tIID:         11,\n\t\t\tExternalID:  \"\",\n\t\t\tState:       \"opened\",\n\t\t\tDescription: \"\",\n\t\t\tAuthor: &IssueAuthor{\n\t\t\t\tID:        18,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\t\tAvatarURL: \"\",\n\t\t\t\tUsername:  \"venkatesh.thalluri\",\n\t\t\t},\n\t\t\tProjectID:         4,\n\t\t\tAssignees:         []*IssueAssignee{},\n\t\t\tTitle:             \"Issues with auth\",\n\t\t\tMovedToID:         0,\n\t\t\tLabels:            []string{\"bug\"},\n\t\t\tUpvotes:           0,\n\t\t\tDownvotes:         0,\n\t\t\tWebURL:            \"http://example.com/example/example/issues/11\",\n\t\t\tConfidential:      false,\n\t\t\tWeight:            0,\n\t\t\tDiscussionLocked:  false,\n\t\t\tSubscribed:        true,\n\t\t\tUserNotesCount:    0,\n\t\t\tIssueLinkID:       0,\n\t\t\tMergeRequestCount: 0,\n\t\t\tEpicIssueID:       0,\n\t\t},\n\t\tTargetIssue: &Issue{\n\t\t\tID:          84,\n\t\t\tIID:         14,\n\t\t\tExternalID:  \"\",\n\t\t\tState:       \"opened\",\n\t\t\tDescription: \"\",\n\t\t\tAuthor: &IssueAuthor{\n\t\t\t\tID:        18,\n\t\t\t\tState:     \"active\",\n\t\t\t\tWebURL:    \"https://gitlab.example.com/eileen.lowe\",\n\t\t\t\tName:      \"Alexandra Bashirian\",\n\t\t\t\tAvatarURL: \"\",\n\t\t\t\tUsername:  \"eileen.lowe\",\n\t\t\t},\n\t\t\tProjectID:         4,\n\t\t\tAssignees:         []*IssueAssignee{},\n\t\t\tTitle:             \"Issues with auth\",\n\t\t\tMovedToID:         0,\n\t\t\tLabels:            []string{\"bug\"},\n\t\t\tUpvotes:           0,\n\t\t\tDownvotes:         0,\n\t\t\tWebURL:            \"http://example.com/example/example/issues/14\",\n\t\t\tConfidential:      false,\n\t\t\tWeight:            0,\n\t\t\tDiscussionLocked:  false,\n\t\t\tSubscribed:        true,\n\t\t\tUserNotesCount:    0,\n\t\t\tIssueLinkID:       0,\n\t\t\tMergeRequestCount: 0,\n\t\t\tEpicIssueID:       0,\n\t\t},\n\t\tLinkType: \"relates_to\",\n\t}\n\n\ti, resp, err := client.IssueLinks.DeleteIssueLink(4, 1, 83, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, i)\n\n\ti, resp, err = client.IssueLinks.DeleteIssueLink(4.01, 1, 83, nil)\n\trequire.EqualError(t, err, \"invalid ID type 4.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, i)\n\n\ti, resp, err = client.IssueLinks.DeleteIssueLink(4, 1, 83, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, i)\n\n\ti, resp, err = client.IssueLinks.DeleteIssueLink(8, 1, 83, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, i)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "issues.go",
          "type": "blob",
          "size": 32.595703125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"time\"\n)\n\n// IssuesService handles communication with the issue related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html\ntype IssuesService struct {\n\tclient    *Client\n\ttimeStats *timeStatsService\n}\n\n// IssueAuthor represents a author of the issue.\ntype IssueAuthor struct {\n\tID        int    `json:\"id\"`\n\tState     string `json:\"state\"`\n\tWebURL    string `json:\"web_url\"`\n\tName      string `json:\"name\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tUsername  string `json:\"username\"`\n}\n\n// IssueAssignee represents a assignee of the issue.\ntype IssueAssignee struct {\n\tID        int    `json:\"id\"`\n\tState     string `json:\"state\"`\n\tWebURL    string `json:\"web_url\"`\n\tName      string `json:\"name\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tUsername  string `json:\"username\"`\n}\n\n// IssueReferences represents references of the issue.\ntype IssueReferences struct {\n\tShort    string `json:\"short\"`\n\tRelative string `json:\"relative\"`\n\tFull     string `json:\"full\"`\n}\n\n// IssueCloser represents a closer of the issue.\ntype IssueCloser struct {\n\tID        int    `json:\"id\"`\n\tState     string `json:\"state\"`\n\tWebURL    string `json:\"web_url\"`\n\tName      string `json:\"name\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tUsername  string `json:\"username\"`\n}\n\n// IssueLinks represents links of the issue.\ntype IssueLinks struct {\n\tSelf       string `json:\"self\"`\n\tNotes      string `json:\"notes\"`\n\tAwardEmoji string `json:\"award_emoji\"`\n\tProject    string `json:\"project\"`\n}\n\n// Issue represents a GitLab issue.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html\ntype Issue struct {\n\tID                   int                    `json:\"id\"`\n\tIID                  int                    `json:\"iid\"`\n\tExternalID           string                 `json:\"external_id\"`\n\tState                string                 `json:\"state\"`\n\tDescription          string                 `json:\"description\"`\n\tHealthStatus         string                 `json:\"health_status\"`\n\tAuthor               *IssueAuthor           `json:\"author\"`\n\tMilestone            *Milestone             `json:\"milestone\"`\n\tProjectID            int                    `json:\"project_id\"`\n\tAssignees            []*IssueAssignee       `json:\"assignees\"`\n\tAssignee             *IssueAssignee         `json:\"assignee\"`\n\tUpdatedAt            *time.Time             `json:\"updated_at\"`\n\tClosedAt             *time.Time             `json:\"closed_at\"`\n\tClosedBy             *IssueCloser           `json:\"closed_by\"`\n\tTitle                string                 `json:\"title\"`\n\tCreatedAt            *time.Time             `json:\"created_at\"`\n\tMovedToID            int                    `json:\"moved_to_id\"`\n\tLabels               Labels                 `json:\"labels\"`\n\tLabelDetails         []*LabelDetails        `json:\"label_details\"`\n\tUpvotes              int                    `json:\"upvotes\"`\n\tDownvotes            int                    `json:\"downvotes\"`\n\tDueDate              *ISOTime               `json:\"due_date\"`\n\tWebURL               string                 `json:\"web_url\"`\n\tReferences           *IssueReferences       `json:\"references\"`\n\tTimeStats            *TimeStats             `json:\"time_stats\"`\n\tConfidential         bool                   `json:\"confidential\"`\n\tWeight               int                    `json:\"weight\"`\n\tDiscussionLocked     bool                   `json:\"discussion_locked\"`\n\tIssueType            *string                `json:\"issue_type,omitempty\"`\n\tSubscribed           bool                   `json:\"subscribed\"`\n\tUserNotesCount       int                    `json:\"user_notes_count\"`\n\tLinks                *IssueLinks            `json:\"_links\"`\n\tIssueLinkID          int                    `json:\"issue_link_id\"`\n\tMergeRequestCount    int                    `json:\"merge_requests_count\"`\n\tEpicIssueID          int                    `json:\"epic_issue_id\"`\n\tEpic                 *Epic                  `json:\"epic\"`\n\tIteration            *GroupIteration        `json:\"iteration\"`\n\tTaskCompletionStatus *TasksCompletionStatus `json:\"task_completion_status\"`\n}\n\nfunc (i Issue) String() string {\n\treturn Stringify(i)\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (i *Issue) UnmarshalJSON(data []byte) error {\n\ttype alias Issue\n\n\traw := make(map[string]interface{})\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif reflect.TypeOf(raw[\"id\"]).Kind() == reflect.String {\n\t\traw[\"external_id\"] = raw[\"id\"]\n\t\tdelete(raw, \"id\")\n\t}\n\n\tlabelDetails, ok := raw[\"labels\"].([]interface{})\n\tif ok && len(labelDetails) > 0 {\n\t\t// We only want to change anything if we got label details.\n\t\tif _, ok := labelDetails[0].(map[string]interface{}); ok {\n\t\t\tlabels := make([]interface{}, len(labelDetails))\n\t\t\tfor i, details := range labelDetails {\n\t\t\t\tlabels[i] = details.(map[string]interface{})[\"name\"]\n\t\t\t}\n\n\t\t\t// Set the correct values\n\t\t\traw[\"labels\"] = labels\n\t\t\traw[\"label_details\"] = labelDetails\n\t\t}\n\t}\n\n\tdata, err = json.Marshal(raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn json.Unmarshal(data, (*alias)(i))\n}\n\n// LabelDetails represents detailed label information.\ntype LabelDetails struct {\n\tID              int    `json:\"id\"`\n\tName            string `json:\"name\"`\n\tColor           string `json:\"color\"`\n\tDescription     string `json:\"description\"`\n\tDescriptionHTML string `json:\"description_html\"`\n\tTextColor       string `json:\"text_color\"`\n}\n\n// ListIssuesOptions represents the available ListIssues() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#list-issues\ntype ListIssuesOptions struct {\n\tListOptions\n\tState               *string          `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tLabels              *LabelOptions    `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tNotLabels           *LabelOptions    `url:\"not[labels],comma,omitempty\" json:\"not[labels],omitempty\"`\n\tWithLabelDetails    *bool            `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tMilestone           *string          `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tNotMilestone        *string          `url:\"not[milestone],omitempty\" json:\"not[milestone],omitempty\"`\n\tScope               *string          `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID            *int             `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername      *string          `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tNotAuthorUsername   *string          `url:\"not[author_username],omitempty\" json:\"not[author_username],omitempty\"`\n\tNotAuthorID         *[]int           `url:\"not[author_id],omitempty\" json:\"not[author_id],omitempty\"`\n\tAssigneeID          *AssigneeIDValue `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tNotAssigneeID       *[]int           `url:\"not[assignee_id],omitempty\" json:\"not[assignee_id],omitempty\"`\n\tAssigneeUsername    *string          `url:\"assignee_username,omitempty\" json:\"assignee_username,omitempty\"`\n\tNotAssigneeUsername *string          `url:\"not[assignee_username],omitempty\" json:\"not[assignee_username],omitempty\"`\n\tMyReactionEmoji     *string          `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tNotMyReactionEmoji  *[]string        `url:\"not[my_reaction_emoji],omitempty\" json:\"not[my_reaction_emoji],omitempty\"`\n\tIIDs                *[]int           `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tIn                  *string          `url:\"in,omitempty\" json:\"in,omitempty\"`\n\tNotIn               *string          `url:\"not[in],omitempty\" json:\"not[in],omitempty\"`\n\tOrderBy             *string          `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                *string          `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tSearch              *string          `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tNotSearch           *string          `url:\"not[search],omitempty\" json:\"not[search],omitempty\"`\n\tCreatedAfter        *time.Time       `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore       *time.Time       `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tDueDate             *string          `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tUpdatedAfter        *time.Time       `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore       *time.Time       `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tConfidential        *bool            `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n\tIssueType           *string          `url:\"issue_type,omitempty\" json:\"issue_type,omitempty\"`\n\tIterationID         *int             `url:\"iteration_id,omitempty\" json:\"iteration_id,omitempty\"`\n}\n\n// ListIssues gets all issues created by authenticated user. This function\n// takes pagination parameters page and per_page to restrict the list of issues.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#list-issues\nfunc (s *IssuesService) ListIssues(opt *ListIssuesOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"issues\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar i []*Issue\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// ListGroupIssuesOptions represents the available ListGroupIssues() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#list-group-issues\ntype ListGroupIssuesOptions struct {\n\tListOptions\n\tState             *string       `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tLabels            *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tNotLabels         *LabelOptions `url:\"not[labels],comma,omitempty\" json:\"not[labels],omitempty\"`\n\tWithLabelDetails  *bool         `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tIIDs              *[]int        `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tMilestone         *string       `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tNotMilestone      *string       `url:\"not[milestone],omitempty\" json:\"not[milestone],omitempty\"`\n\tScope             *string       `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID          *int          `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tNotAuthorID       *[]int        `url:\"not[author_id],omitempty\" json:\"not[author_id],omitempty\"`\n\tAuthorUsername    *string       `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tNotAuthorUsername *string       `url:\"not[author_username],omitempty\" json:\"not[author_username],omitempty\"`\n\n\tAssigneeID          *AssigneeIDValue `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tNotAssigneeID       *[]int           `url:\"not[assignee_id],omitempty\" json:\"not[assignee_id],omitempty\"`\n\tAssigneeUsername    *string          `url:\"assignee_username,omitempty\" json:\"assignee_username,omitempty\"`\n\tNotAssigneeUsername *string          `url:\"not[assignee_username],omitempty\" json:\"not[assignee_username],omitempty\"`\n\tMyReactionEmoji     *string          `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tNotMyReactionEmoji  *[]string        `url:\"not[my_reaction_emoji],omitempty\" json:\"not[my_reaction_emoji],omitempty\"`\n\tOrderBy             *string          `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                *string          `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tSearch              *string          `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tNotSearch           *string          `url:\"not[search],omitempty\" json:\"not[search],omitempty\"`\n\tIn                  *string          `url:\"in,omitempty\" json:\"in,omitempty\"`\n\tNotIn               *string          `url:\"not[in],omitempty\" json:\"not[in],omitempty\"`\n\tCreatedAfter        *time.Time       `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore       *time.Time       `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tDueDate             *string          `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tUpdatedAfter        *time.Time       `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore       *time.Time       `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tIssueType           *string          `url:\"issue_type,omitempty\" json:\"issue_type,omitempty\"`\n\tIterationID         *int             `url:\"iteration_id,omitempty\" json:\"iteration_id,omitempty\"`\n}\n\n// ListGroupIssues gets a list of group issues. This function accepts\n// pagination parameters page and per_page to return the list of group issues.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#list-group-issues\nfunc (s *IssuesService) ListGroupIssues(pid interface{}, opt *ListGroupIssuesOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/issues\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar i []*Issue\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// ListProjectIssuesOptions represents the available ListProjectIssues() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#list-project-issues\ntype ListProjectIssuesOptions struct {\n\tListOptions\n\tIIDs                *[]int           `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tState               *string          `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tLabels              *LabelOptions    `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tNotLabels           *LabelOptions    `url:\"not[labels],comma,omitempty\" json:\"not[labels],omitempty\"`\n\tWithLabelDetails    *bool            `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tMilestone           *string          `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tNotMilestone        *string          `url:\"not[milestone],omitempty\" json:\"not[milestone],omitempty\"`\n\tScope               *string          `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID            *int             `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername      *string          `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tNotAuthorUsername   *string          `url:\"not[author_username],omitempty\" json:\"not[author_username],omitempty\"`\n\tNotAuthorID         *[]int           `url:\"not[author_id],omitempty\" json:\"not[author_id],omitempty\"`\n\tAssigneeID          *AssigneeIDValue `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tNotAssigneeID       *[]int           `url:\"not[assignee_id],omitempty\" json:\"not[assignee_id],omitempty\"`\n\tAssigneeUsername    *string          `url:\"assignee_username,omitempty\" json:\"assignee_username,omitempty\"`\n\tNotAssigneeUsername *string          `url:\"not[assignee_username],omitempty\" json:\"not[assignee_username],omitempty\"`\n\tMyReactionEmoji     *string          `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tNotMyReactionEmoji  *[]string        `url:\"not[my_reaction_emoji],omitempty\" json:\"not[my_reaction_emoji],omitempty\"`\n\tOrderBy             *string          `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                *string          `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tSearch              *string          `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIn                  *string          `url:\"in,omitempty\" json:\"in,omitempty\"`\n\tNotIn               *string          `url:\"not[in],omitempty\" json:\"not[in],omitempty\"`\n\tCreatedAfter        *time.Time       `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore       *time.Time       `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tDueDate             *string          `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tUpdatedAfter        *time.Time       `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore       *time.Time       `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tConfidential        *bool            `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n\tIssueType           *string          `url:\"issue_type,omitempty\" json:\"issue_type,omitempty\"`\n\tIterationID         *int             `url:\"iteration_id,omitempty\" json:\"iteration_id,omitempty\"`\n}\n\n// ListProjectIssues gets a list of project issues. This function accepts\n// pagination parameters page and per_page to return the list of project issues.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#list-project-issues\nfunc (s *IssuesService) ListProjectIssues(pid interface{}, opt *ListProjectIssuesOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar i []*Issue\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// GetIssueByID gets a single issue.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#single-issue\nfunc (s *IssuesService) GetIssueByID(issue int, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tu := fmt.Sprintf(\"issues/%d\", issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// GetIssue gets a single project issue.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#single-project-issue\nfunc (s *IssuesService) GetIssue(pid interface{}, issue int, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// CreateIssueOptions represents the available CreateIssue() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#new-issue\ntype CreateIssueOptions struct {\n\tIID                                *int          `url:\"iid,omitempty\" json:\"iid,omitempty\"`\n\tTitle                              *string       `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription                        *string       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tConfidential                       *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n\tAssigneeIDs                        *[]int        `url:\"assignee_ids,omitempty\" json:\"assignee_ids,omitempty\"`\n\tMilestoneID                        *int          `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tLabels                             *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tCreatedAt                          *time.Time    `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n\tDueDate                            *ISOTime      `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tEpicID                             *int          `url:\"epic_id,omitempty\" json:\"epic_id,omitempty\"`\n\tMergeRequestToResolveDiscussionsOf *int          `url:\"merge_request_to_resolve_discussions_of,omitempty\" json:\"merge_request_to_resolve_discussions_of,omitempty\"`\n\tDiscussionToResolve                *string       `url:\"discussion_to_resolve,omitempty\" json:\"discussion_to_resolve,omitempty\"`\n\tWeight                             *int          `url:\"weight,omitempty\" json:\"weight,omitempty\"`\n\tIssueType                          *string       `url:\"issue_type,omitempty\" json:\"issue_type,omitempty\"`\n}\n\n// CreateIssue creates a new project issue.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#new-issue\nfunc (s *IssuesService) CreateIssue(pid interface{}, opt *CreateIssueOptions, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// UpdateIssueOptions represents the available UpdateIssue() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#edit-issue\ntype UpdateIssueOptions struct {\n\tTitle            *string       `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription      *string       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tConfidential     *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n\tAssigneeIDs      *[]int        `url:\"assignee_ids,omitempty\" json:\"assignee_ids,omitempty\"`\n\tMilestoneID      *int          `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tLabels           *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tAddLabels        *LabelOptions `url:\"add_labels,comma,omitempty\" json:\"add_labels,omitempty\"`\n\tRemoveLabels     *LabelOptions `url:\"remove_labels,comma,omitempty\" json:\"remove_labels,omitempty\"`\n\tStateEvent       *string       `url:\"state_event,omitempty\" json:\"state_event,omitempty\"`\n\tUpdatedAt        *time.Time    `url:\"updated_at,omitempty\" json:\"updated_at,omitempty\"`\n\tDueDate          *ISOTime      `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tEpicID           *int          `url:\"epic_id,omitempty\" json:\"epic_id,omitempty\"`\n\tWeight           *int          `url:\"weight,omitempty\" json:\"weight,omitempty\"`\n\tDiscussionLocked *bool         `url:\"discussion_locked,omitempty\" json:\"discussion_locked,omitempty\"`\n\tIssueType        *string       `url:\"issue_type,omitempty\" json:\"issue_type,omitempty\"`\n}\n\n// UpdateIssue updates an existing project issue. This function is also used\n// to mark an issue as closed.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#edit-issues\nfunc (s *IssuesService) UpdateIssue(pid interface{}, issue int, opt *UpdateIssueOptions, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// DeleteIssue deletes a single project issue.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#delete-an-issue\nfunc (s *IssuesService) DeleteIssue(pid interface{}, issue int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ReorderIssueOptions represents the available ReorderIssue() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#reorder-an-issue\ntype ReorderIssueOptions struct {\n\tMoveAfterID  *int `url:\"move_after_id,omitempty\" json:\"move_after_id,omitempty\"`\n\tMoveBeforeID *int `url:\"move_before_id,omitempty\" json:\"move_before_id,omitempty\"`\n}\n\n// ReorderIssue reorders an issue.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#reorder-an-issue\nfunc (s *IssuesService) ReorderIssue(pid interface{}, issue int, opt *ReorderIssueOptions, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/reorder\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// MoveIssueOptions represents the available MoveIssue() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#move-an-issue\ntype MoveIssueOptions struct {\n\tToProjectID *int `url:\"to_project_id,omitempty\" json:\"to_project_id,omitempty\"`\n}\n\n// MoveIssue updates an existing project issue. This function is also used\n// to mark an issue as closed.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues.html#move-an-issue\nfunc (s *IssuesService) MoveIssue(pid interface{}, issue int, opt *MoveIssueOptions, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/move\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// SubscribeToIssue subscribes the authenticated user to the given issue to\n// receive notifications. If the user is already subscribed to the issue, the\n// status code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#subscribe-to-an-issue\nfunc (s *IssuesService) SubscribeToIssue(pid interface{}, issue int, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/subscribe\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// UnsubscribeFromIssue unsubscribes the authenticated user from the given\n// issue to not receive notifications from that merge request. If the user\n// is not subscribed to the issue, status code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#unsubscribe-from-an-issue\nfunc (s *IssuesService) UnsubscribeFromIssue(pid interface{}, issue int, options ...RequestOptionFunc) (*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/unsubscribe\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ti := new(Issue)\n\tresp, err := s.client.Do(req, i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// CreateTodo creates a todo for the current user for an issue.\n// If there already exists a todo for the user on that issue, status code\n// 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#create-a-to-do-item\nfunc (s *IssuesService) CreateTodo(pid interface{}, issue int, options ...RequestOptionFunc) (*Todo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/todo\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Todo)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// ListMergeRequestsClosingIssueOptions represents the available\n// ListMergeRequestsClosingIssue() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#list-merge-requests-that-close-a-particular-issue-on-merge\ntype ListMergeRequestsClosingIssueOptions ListOptions\n\n// ListMergeRequestsClosingIssue gets all the merge requests that will close\n// issue when merged.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#list-merge-requests-that-close-a-particular-issue-on-merge\nfunc (s *IssuesService) ListMergeRequestsClosingIssue(pid interface{}, issue int, opt *ListMergeRequestsClosingIssueOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/closed_by\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*MergeRequest\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// ListMergeRequestsRelatedToIssueOptions represents the available\n// ListMergeRequestsRelatedToIssue() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#list-merge-requests-related-to-issue\ntype ListMergeRequestsRelatedToIssueOptions ListOptions\n\n// ListMergeRequestsRelatedToIssue gets all the merge requests that are\n// related to the issue\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#list-merge-requests-related-to-issue\nfunc (s *IssuesService) ListMergeRequestsRelatedToIssue(pid interface{}, issue int, opt *ListMergeRequestsRelatedToIssueOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/related_merge_requests\",\n\t\tPathEscape(project),\n\t\tissue,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*MergeRequest\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// SetTimeEstimate sets the time estimate for a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#set-a-time-estimate-for-an-issue\nfunc (s *IssuesService) SetTimeEstimate(pid interface{}, issue int, opt *SetTimeEstimateOptions, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.setTimeEstimate(pid, \"issues\", issue, opt, options...)\n}\n\n// ResetTimeEstimate resets the time estimate for a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#reset-the-time-estimate-for-an-issue\nfunc (s *IssuesService) ResetTimeEstimate(pid interface{}, issue int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.resetTimeEstimate(pid, \"issues\", issue, options...)\n}\n\n// AddSpentTime adds spent time for a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#add-spent-time-for-an-issue\nfunc (s *IssuesService) AddSpentTime(pid interface{}, issue int, opt *AddSpentTimeOptions, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.addSpentTime(pid, \"issues\", issue, opt, options...)\n}\n\n// ResetSpentTime resets the spent time for a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#reset-spent-time-for-an-issue\nfunc (s *IssuesService) ResetSpentTime(pid interface{}, issue int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.resetSpentTime(pid, \"issues\", issue, options...)\n}\n\n// GetTimeSpent gets the spent time for a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#get-time-tracking-stats\nfunc (s *IssuesService) GetTimeSpent(pid interface{}, issue int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.getTimeSpent(pid, \"issues\", issue, options...)\n}\n\n// GetParticipants gets a list of issue participants.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues.html#participants-on-issues\nfunc (s *IssuesService) GetParticipants(pid interface{}, issue int, options ...RequestOptionFunc) ([]*BasicUser, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/participants\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bu []*BasicUser\n\tresp, err := s.client.Do(req, &bu)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bu, resp, nil\n}\n"
        },
        {
          "name": "issues_statistics.go",
          "type": "blob",
          "size": 8.1796875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// IssuesStatisticsService handles communication with the issues statistics\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues_statistics.html\ntype IssuesStatisticsService struct {\n\tclient *Client\n}\n\n// IssuesStatistics represents a GitLab issues statistic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/issues_statistics.html\ntype IssuesStatistics struct {\n\tStatistics struct {\n\t\tCounts struct {\n\t\t\tAll    int `json:\"all\"`\n\t\t\tClosed int `json:\"closed\"`\n\t\t\tOpened int `json:\"opened\"`\n\t\t} `json:\"counts\"`\n\t} `json:\"statistics\"`\n}\n\nfunc (n IssuesStatistics) String() string {\n\treturn Stringify(n)\n}\n\n// GetIssuesStatisticsOptions represents the available GetIssuesStatistics() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues_statistics.html#get-issues-statistics\ntype GetIssuesStatisticsOptions struct {\n\tLabels           *LabelOptions `url:\"labels,omitempty\" json:\"labels,omitempty\"`\n\tMilestone        *string       `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tScope            *string       `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID         *int          `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername   *string       `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tAssigneeID       *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tAssigneeUsername *[]string     `url:\"assignee_username,omitempty\" json:\"assignee_username,omitempty\"`\n\tMyReactionEmoji  *string       `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tIIDs             *[]int        `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tSearch           *string       `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIn               *string       `url:\"in,omitempty\" json:\"in,omitempty\"`\n\tCreatedAfter     *time.Time    `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore    *time.Time    `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter     *time.Time    `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore    *time.Time    `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tConfidential     *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n}\n\n// GetIssuesStatistics gets issues statistics on all issues the authenticated\n// user has access to.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues_statistics.html#get-issues-statistics\nfunc (s *IssuesStatisticsService) GetIssuesStatistics(opt *GetIssuesStatisticsOptions, options ...RequestOptionFunc) (*IssuesStatistics, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"issues_statistics\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tis := new(IssuesStatistics)\n\tresp, err := s.client.Do(req, is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// GetGroupIssuesStatisticsOptions represents the available GetGroupIssuesStatistics()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues_statistics.html#get-group-issues-statistics\ntype GetGroupIssuesStatisticsOptions struct {\n\tLabels           *LabelOptions `url:\"labels,omitempty\" json:\"labels,omitempty\"`\n\tIIDs             *[]int        `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tMilestone        *string       `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tScope            *string       `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID         *int          `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername   *string       `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tAssigneeID       *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tAssigneeUsername *[]string     `url:\"assignee_username,omitempty\" json:\"assignee_username,omitempty\"`\n\tMyReactionEmoji  *string       `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tSearch           *string       `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tCreatedAfter     *time.Time    `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore    *time.Time    `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter     *time.Time    `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore    *time.Time    `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tConfidential     *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n}\n\n// GetGroupIssuesStatistics gets issues count statistics for given group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues_statistics.html#get-group-issues-statistics\nfunc (s *IssuesStatisticsService) GetGroupIssuesStatistics(gid interface{}, opt *GetGroupIssuesStatisticsOptions, options ...RequestOptionFunc) (*IssuesStatistics, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/issues_statistics\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tis := new(IssuesStatistics)\n\tresp, err := s.client.Do(req, is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// GetProjectIssuesStatisticsOptions represents the available\n// GetProjectIssuesStatistics() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues_statistics.html#get-project-issues-statistics\ntype GetProjectIssuesStatisticsOptions struct {\n\tIIDs             *[]int        `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tLabels           *LabelOptions `url:\"labels,omitempty\" json:\"labels,omitempty\"`\n\tMilestone        *string       `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tScope            *string       `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID         *int          `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername   *string       `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tAssigneeID       *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tAssigneeUsername *[]string     `url:\"assignee_username,omitempty\" json:\"assignee_username,omitempty\"`\n\tMyReactionEmoji  *string       `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tSearch           *string       `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tCreatedAfter     *time.Time    `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore    *time.Time    `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter     *time.Time    `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore    *time.Time    `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tConfidential     *bool         `url:\"confidential,omitempty\" json:\"confidential,omitempty\"`\n}\n\n// GetProjectIssuesStatistics gets issues count statistics for given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/issues_statistics.html#get-project-issues-statistics\nfunc (s *IssuesStatisticsService) GetProjectIssuesStatistics(pid interface{}, opt *GetProjectIssuesStatisticsOptions, options ...RequestOptionFunc) (*IssuesStatistics, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues_statistics\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tis := new(IssuesStatistics)\n\tresp, err := s.client.Do(req, is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n"
        },
        {
          "name": "issues_statistics_test.go",
          "type": "blob",
          "size": 3.7041015625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetIssuesStatistics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues_statistics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/issues_statistics?assignee_id=1&author_id=1\")\n\t\tfmt.Fprint(w, `{\"statistics\": {\"counts\": {\"all\": 20,\"closed\": 5,\"opened\": 15}}}`)\n\t})\n\n\topt := &GetIssuesStatisticsOptions{\n\t\tAssigneeID: Ptr(1),\n\t\tAuthorID:   Ptr(1),\n\t}\n\n\tissue, _, err := client.IssuesStatistics.GetIssuesStatistics(opt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &IssuesStatistics{\n\t\tStatistics: struct {\n\t\t\tCounts struct {\n\t\t\t\tAll    int `json:\"all\"`\n\t\t\t\tClosed int `json:\"closed\"`\n\t\t\t\tOpened int `json:\"opened\"`\n\t\t\t} `json:\"counts\"`\n\t\t}{\n\t\t\tCounts: struct {\n\t\t\t\tAll    int `json:\"all\"`\n\t\t\t\tClosed int `json:\"closed\"`\n\t\t\t\tOpened int `json:\"opened\"`\n\t\t\t}{\n\t\t\t\t20, 5, 15,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"IssuesStatistics.GetIssuesStatistics returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestGetGroupIssuesStatistics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/issues_statistics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/groups/1/issues_statistics?assignee_id=1&author_id=1\")\n\t\tfmt.Fprint(w, `{\"statistics\": {\"counts\": {\"all\": 20,\"closed\": 5,\"opened\": 15}}}`)\n\t})\n\n\topt := &GetGroupIssuesStatisticsOptions{\n\t\tAssigneeID: Ptr(1),\n\t\tAuthorID:   Ptr(1),\n\t}\n\n\tissue, _, err := client.IssuesStatistics.GetGroupIssuesStatistics(1, opt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &IssuesStatistics{\n\t\tStatistics: struct {\n\t\t\tCounts struct {\n\t\t\t\tAll    int `json:\"all\"`\n\t\t\t\tClosed int `json:\"closed\"`\n\t\t\t\tOpened int `json:\"opened\"`\n\t\t\t} `json:\"counts\"`\n\t\t}{\n\t\t\tCounts: struct {\n\t\t\t\tAll    int `json:\"all\"`\n\t\t\t\tClosed int `json:\"closed\"`\n\t\t\t\tOpened int `json:\"opened\"`\n\t\t\t}{\n\t\t\t\t20, 5, 15,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"IssuesStatistics.GetGroupIssuesStatistics returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestGetProjectIssuesStatistics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues_statistics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues_statistics?assignee_id=1&author_id=1\")\n\t\tfmt.Fprint(w, `{\"statistics\": {\"counts\": {\"all\": 20,\"closed\": 5,\"opened\": 15}}}`)\n\t})\n\n\topt := &GetProjectIssuesStatisticsOptions{\n\t\tAssigneeID: Ptr(1),\n\t\tAuthorID:   Ptr(1),\n\t}\n\n\tissue, _, err := client.IssuesStatistics.GetProjectIssuesStatistics(1, opt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &IssuesStatistics{\n\t\tStatistics: struct {\n\t\t\tCounts struct {\n\t\t\t\tAll    int `json:\"all\"`\n\t\t\t\tClosed int `json:\"closed\"`\n\t\t\t\tOpened int `json:\"opened\"`\n\t\t\t} `json:\"counts\"`\n\t\t}{\n\t\t\tCounts: struct {\n\t\t\t\tAll    int `json:\"all\"`\n\t\t\t\tClosed int `json:\"closed\"`\n\t\t\t\tOpened int `json:\"opened\"`\n\t\t\t}{\n\t\t\t\t20, 5, 15,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"IssuesStatistics.GetProjectIssuesStatistics returned %+v, want %+v\", issue, want)\n\t}\n}\n"
        },
        {
          "name": "issues_test.go",
          "type": "blob",
          "size": 26.4619140625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}],\"merge_requests_count\": 1}`)\n\t})\n\n\tissue, _, err := client.Issues.GetIssue(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:                1,\n\t\tDescription:       \"This is test project\",\n\t\tAuthor:            &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:         []*IssueAssignee{{ID: 1}},\n\t\tMergeRequestCount: 1,\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.GetIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestGetIssueByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":5, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}],\"merge_requests_count\": 1}`)\n\t})\n\n\tissue, _, err := client.Issues.GetIssueByID(5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:                5,\n\t\tDescription:       \"This is test project\",\n\t\tAuthor:            &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:         []*IssueAssignee{{ID: 1}},\n\t\tMergeRequestCount: 1,\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.GetIssueByID returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestDeleteIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tfmt.Fprint(w, `{\"id\":1, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}`)\n\t})\n\n\t_, err := client.Issues.DeleteIssue(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestReorderIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/reorder\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\" : \"Reordered issue\", \"description\": \"This is the description of a reordered issue\", \"author\" : {\"id\" : 1, \"name\": \"corrie\"}, \"assignees\":[{\"id\":1}]}`)\n\t})\n\n\tafterID := 100\n\topt := ReorderIssueOptions{MoveAfterID: &afterID}\n\n\tissue, _, err := client.Issues.ReorderIssue(\"1\", 5, &opt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:          1,\n\t\tTitle:       \"Reordered issue\",\n\t\tDescription: \"This is the description of a reordered issue\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"corrie\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.ReorderIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestMoveIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/11/move\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/issue_move.json\")\n\t})\n\n\tissue, _, err := client.Issues.MoveIssue(\"1\", 11, &MoveIssueOptions{ToProjectID: Ptr(5)})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:        92,\n\t\tIID:       11,\n\t\tProjectID: 5,\n\t\tMovedToID: 0,\n\t}\n\n\tassert.Equal(t, want.IID, issue.IID)\n\tassert.Equal(t, want.ProjectID, issue.ProjectID)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/11\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"iid\": 11,\n\t\t\t\t\"project_id\": 1,\n\t\t\t\t\"moved_to_id\": 92\n\t\t}`,\n\t\t)\n\t})\n\tmovedIssue, _, err := client.Issues.GetIssue(\"1\", 11)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twantedMovedIssue := &Issue{\n\t\tID:        1,\n\t\tIID:       11,\n\t\tProjectID: 1,\n\t\tMovedToID: 92,\n\t}\n\n\tif !reflect.DeepEqual(wantedMovedIssue, movedIssue) {\n\t\tt.Errorf(\"Issues.GetIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestListIssues(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/issues?assignee_id=2&author_id=1\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"description\": \"This is test project\",\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"name\": \"snehal\"\n\t\t\t\t\t},\n\t\t\t\t\t\"assignees\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": 1\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"labels\": [\n\t\t\t\t\t\t\"foo\",\n\t\t\t\t\t\t\"bar\"\n\t\t\t\t\t]\n\t\t\t  }\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListIssuesOptions{\n\t\tAuthorID:   Ptr(0o1),\n\t\tAssigneeID: AssigneeID(0o2),\n\t}\n\n\tissues, _, err := client.Issues.ListIssues(listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tDescription: \"This is test project\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t\tLabels:      []string{\"foo\", \"bar\"},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListIssuesWithLabelDetails(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/issues?assignee_id=2&author_id=1\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"description\": \"This is test project\",\n\t\t\t\t\t\"author\": {\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"name\": \"snehal\"\n\t\t\t\t\t},\n\t\t\t\t\t\"assignees\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": 1\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"labels\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\t\"name\": \"foo\",\n\t\t\t\t\t\t\t\"color\": \"green\",\n\t\t\t\t\t\t\t\"description\": \"Issue\",\n\t\t\t\t\t\t\t\"description_html\": \"Issue Label\",\n\t\t\t\t\t\t\t\"text_color\": \"black\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\"id\": 2,\n\t\t\t\t\t\t\t\"name\": \"bar\",\n\t\t\t\t\t\t\t\"color\": \"red\",\n\t\t\t\t\t\t\t\"description\": \"Bug\",\n\t\t\t\t\t\t\t\"description_html\": \"Bug Label\",\n\t\t\t\t\t\t\t\"text_color\": \"black\"\n\t\t\t\t\t\t}\n\t\t\t    ]\n\t\t\t  }\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListIssuesOptions{\n\t\tAuthorID:   Ptr(0o1),\n\t\tAssigneeID: AssigneeID(0o2),\n\t}\n\n\tissues, _, err := client.Issues.ListIssues(listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tDescription: \"This is test project\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t\tLabels:      []string{\"foo\", \"bar\"},\n\t\tLabelDetails: []*LabelDetails{\n\t\t\t{ID: 1, Name: \"foo\", Color: \"green\", Description: \"Issue\", DescriptionHTML: \"Issue Label\", TextColor: \"black\"},\n\t\t\t{ID: 2, Name: \"bar\", Color: \"red\", Description: \"Bug\", DescriptionHTML: \"Bug Label\", TextColor: \"black\"},\n\t\t},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListIssuesSearchInTitle(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/issues?in=title&search=Title\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"title\": \"A Test Issue Title\",\n\t\t\t\t\t\"description\": \"This is the description for the issue\"\n\t\t\t  }\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListIssuesOptions{\n\t\tSearch: Ptr(\"Title\"),\n\t\tIn:     Ptr(\"title\"),\n\t}\n\n\tissues, _, err := client.Issues.ListIssues(listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tTitle:       \"A Test Issue Title\",\n\t\tDescription: \"This is the description for the issue\",\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListIssuesSearchInDescription(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/issues?in=description&search=description\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"title\": \"A Test Issue Title\",\n\t\t\t\t\t\"description\": \"This is the description for the issue\"\n\t\t\t  }\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListIssuesOptions{\n\t\tSearch: Ptr(\"description\"),\n\t\tIn:     Ptr(\"description\"),\n\t}\n\n\tissues, _, err := client.Issues.ListIssues(listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tTitle:       \"A Test Issue Title\",\n\t\tDescription: \"This is the description for the issue\",\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListIssuesSearchByIterationID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/issues?iteration_id=90\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"title\": \"A Test Issue Title\",\n\t\t\t\t\t\"description\": \"This is the description for the issue\",\n\t\t\t\t\t\"iteration\": {\n\t\t\t\t\t\t\"id\":90,\n\t\t\t\t\t\t\"iid\":4,\n\t\t\t\t\t\t\"sequence\":2,\n\t\t\t\t\t\t\"group_id\":162,\n\t\t\t\t\t\t\"state\":2,\n\t\t\t\t\t\t\"web_url\":\"https://gitlab.com/groups/my-group/-/iterations/90\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListIssuesOptions{\n\t\tIterationID: Ptr(90),\n\t}\n\n\tissues, _, err := client.Issues.ListIssues(listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tTitle:       \"A Test Issue Title\",\n\t\tDescription: \"This is the description for the issue\",\n\t\tIteration: &GroupIteration{\n\t\t\tID:       90,\n\t\t\tIID:      4,\n\t\t\tSequence: 2,\n\t\t\tGroupID:  162,\n\t\t\tState:    2,\n\t\t\tWebURL:   \"https://gitlab.com/groups/my-group/-/iterations/90\",\n\t\t},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListProjectIssues(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues?assignee_id=2&author_id=1\")\n\t\tfmt.Fprint(w, `[{\"id\":1, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}]`)\n\t})\n\n\tlistProjectIssue := &ListProjectIssuesOptions{\n\t\tAuthorID:   Ptr(0o1),\n\t\tAssigneeID: AssigneeID(0o2),\n\t}\n\tissues, _, err := client.Issues.ListProjectIssues(\"1\", listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tDescription: \"This is test project\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListProjectIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListProjectIssuesSearchByIterationID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues?iteration_id=90\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"title\": \"A Test Issue Title\",\n\t\t\t\t\t\"description\": \"This is the description for the issue\",\n\t\t\t\t\t\"iteration\": {\n\t\t\t\t\t\t\"id\":90,\n\t\t\t\t\t\t\"iid\":4,\n\t\t\t\t\t\t\"sequence\":2,\n\t\t\t\t\t\t\"group_id\":162,\n\t\t\t\t\t\t\"state\":2,\n\t\t\t\t\t\t\"web_url\":\"https://gitlab.com/groups/my-group/-/iterations/90\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListProjectIssuesOptions{\n\t\tIterationID: Ptr(90),\n\t}\n\n\tissues, _, err := client.Issues.ListProjectIssues(1, listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tTitle:       \"A Test Issue Title\",\n\t\tDescription: \"This is the description for the issue\",\n\t\tIteration: &GroupIteration{\n\t\t\tID:       90,\n\t\t\tIID:      4,\n\t\t\tSequence: 2,\n\t\t\tGroupID:  162,\n\t\t\tState:    2,\n\t\t\tWebURL:   \"https://gitlab.com/groups/my-group/-/iterations/90\",\n\t\t},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListGroupIssues(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/groups/1/issues?assignee_id=2&author_id=1&state=Open\")\n\t\tfmt.Fprint(w, `[{\"id\":1, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}]`)\n\t})\n\n\tlistGroupIssue := &ListGroupIssuesOptions{\n\t\tState:      Ptr(\"Open\"),\n\t\tAuthorID:   Ptr(0o1),\n\t\tAssigneeID: AssigneeID(0o2),\n\t}\n\n\tissues, _, err := client.Issues.ListGroupIssues(\"1\", listGroupIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tDescription: \"This is test project\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListGroupIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestListGroupIssuesSearchByIterationID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/groups/1/issues?iteration_id=90\")\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"title\": \"A Test Issue Title\",\n\t\t\t\t\t\"description\": \"This is the description for the issue\",\n\t\t\t\t\t\"iteration\": {\n\t\t\t\t\t\t\"id\":90,\n\t\t\t\t\t\t\"iid\":4,\n\t\t\t\t\t\t\"sequence\":2,\n\t\t\t\t\t\t\"group_id\":162,\n\t\t\t\t\t\t\"state\":2,\n\t\t\t\t\t\t\"web_url\":\"https://gitlab.com/groups/my-group/-/iterations/90\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]`,\n\t\t)\n\t})\n\n\tlistProjectIssue := &ListGroupIssuesOptions{\n\t\tIterationID: Ptr(90),\n\t}\n\n\tissues, _, err := client.Issues.ListGroupIssues(1, listProjectIssue)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*Issue{{\n\t\tID:          1,\n\t\tTitle:       \"A Test Issue Title\",\n\t\tDescription: \"This is the description for the issue\",\n\t\tIteration: &GroupIteration{\n\t\t\tID:       90,\n\t\t\tIID:      4,\n\t\t\tSequence: 2,\n\t\t\tGroupID:  162,\n\t\t\tState:    2,\n\t\t\tWebURL:   \"https://gitlab.com/groups/my-group/-/iterations/90\",\n\t\t},\n\t}}\n\n\tif !reflect.DeepEqual(want, issues) {\n\t\tt.Errorf(\"Issues.ListIssues returned %+v, want %+v\", issues, want)\n\t}\n}\n\nfunc TestCreateIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\" : \"Title of issue\", \"description\": \"This is description of an issue\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}`)\n\t})\n\n\tcreateIssueOptions := &CreateIssueOptions{\n\t\tTitle:       Ptr(\"Title of issue\"),\n\t\tDescription: Ptr(\"This is description of an issue\"),\n\t}\n\n\tissue, _, err := client.Issues.CreateIssue(\"1\", createIssueOptions)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:          1,\n\t\tTitle:       \"Title of issue\",\n\t\tDescription: \"This is description of an issue\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.CreateIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestUpdateIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\" : \"Title of issue\", \"description\": \"This is description of an issue\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}`)\n\t})\n\n\tupdateIssueOpt := &UpdateIssueOptions{\n\t\tTitle:       Ptr(\"Title of issue\"),\n\t\tDescription: Ptr(\"This is description of an issue\"),\n\t}\n\tissue, _, err := client.Issues.UpdateIssue(1, 5, updateIssueOpt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:          1,\n\t\tTitle:       \"Title of issue\",\n\t\tDescription: \"This is description of an issue\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.UpdateIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestSubscribeToIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/subscribe\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\" : \"Title of issue\", \"description\": \"This is description of an issue\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}`)\n\t})\n\n\tissue, _, err := client.Issues.SubscribeToIssue(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:          1,\n\t\tTitle:       \"Title of issue\",\n\t\tDescription: \"This is description of an issue\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.SubscribeToIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestUnsubscribeFromIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/unsubscribe\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\" : \"Title of issue\", \"description\": \"This is description of an issue\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}]}`)\n\t})\n\n\tissue, _, err := client.Issues.UnsubscribeFromIssue(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:          1,\n\t\tTitle:       \"Title of issue\",\n\t\tDescription: \"This is description of an issue\",\n\t\tAuthor:      &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:   []*IssueAssignee{{ID: 1}},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.UnsubscribeFromIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestListMergeRequestsClosingIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/closed_by\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues/5/closed_by?page=1&per_page=10\")\n\n\t\tfmt.Fprint(w, `[{\"id\":1, \"title\" : \"test merge one\"},{\"id\":2, \"title\" : \"test merge two\"}]`)\n\t})\n\n\tlistMergeRequestsClosingIssueOpt := &ListMergeRequestsClosingIssueOptions{\n\t\tPage:    1,\n\t\tPerPage: 10,\n\t}\n\tmergeRequest, _, err := client.Issues.ListMergeRequestsClosingIssue(\"1\", 5, listMergeRequestsClosingIssueOpt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*MergeRequest{{ID: 1, Title: \"test merge one\"}, {ID: 2, Title: \"test merge two\"}}\n\n\tif !reflect.DeepEqual(want, mergeRequest) {\n\t\tt.Errorf(\"Issues.ListMergeRequestsClosingIssue returned %+v, want %+v\", mergeRequest, want)\n\t}\n}\n\nfunc TestListMergeRequestsRelatedToIssue(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/related_merge_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues/5/related_merge_requests?page=1&per_page=10\")\n\n\t\tfmt.Fprint(w, `[{\"id\":1, \"title\" : \"test merge one\"},{\"id\":2, \"title\" : \"test merge two\"}]`)\n\t})\n\n\tlistMergeRequestsRelatedToIssueOpt := &ListMergeRequestsRelatedToIssueOptions{\n\t\tPage:    1,\n\t\tPerPage: 10,\n\t}\n\tmergeRequest, _, err := client.Issues.ListMergeRequestsRelatedToIssue(\"1\", 5, listMergeRequestsRelatedToIssueOpt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*MergeRequest{{ID: 1, Title: \"test merge one\"}, {ID: 2, Title: \"test merge two\"}}\n\n\tif !reflect.DeepEqual(want, mergeRequest) {\n\t\tt.Errorf(\"Issues.ListMergeRequestsClosingIssue returned %+v, want %+v\", mergeRequest, want)\n\t}\n}\n\nfunc TestSetTimeEstimate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/time_estimate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"human_time_estimate\": \"3h 30m\", \"human_total_time_spent\": null, \"time_estimate\": 12600, \"total_time_spent\": 0}`)\n\t})\n\n\tsetTimeEstiOpt := &SetTimeEstimateOptions{\n\t\tDuration: Ptr(\"3h 30m\"),\n\t}\n\n\ttimeState, _, err := client.Issues.SetTimeEstimate(\"1\", 5, setTimeEstiOpt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &TimeStats{HumanTimeEstimate: \"3h 30m\", HumanTotalTimeSpent: \"\", TimeEstimate: 12600, TotalTimeSpent: 0}\n\n\tif !reflect.DeepEqual(want, timeState) {\n\t\tt.Errorf(\"Issues.SetTimeEstimate returned %+v, want %+v\", timeState, want)\n\t}\n}\n\nfunc TestResetTimeEstimate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/reset_time_estimate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"human_time_estimate\": null, \"human_total_time_spent\": null, \"time_estimate\": 0, \"total_time_spent\": 0}`)\n\t})\n\n\ttimeState, _, err := client.Issues.ResetTimeEstimate(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &TimeStats{HumanTimeEstimate: \"\", HumanTotalTimeSpent: \"\", TimeEstimate: 0, TotalTimeSpent: 0}\n\n\tif !reflect.DeepEqual(want, timeState) {\n\t\tt.Errorf(\"Issues.ResetTimeEstimate returned %+v, want %+v\", timeState, want)\n\t}\n}\n\nfunc TestAddSpentTime(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/add_spent_time\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues/5/add_spent_time\")\n\t\ttestBody(t, r, `{\"duration\":\"1h\",\"summary\":\"test\"}`)\n\t\tfmt.Fprint(w, `{\"human_time_estimate\": null, \"human_total_time_spent\": \"1h\", \"time_estimate\": 0, \"total_time_spent\": 3600}`)\n\t})\n\taddSpentTimeOpt := &AddSpentTimeOptions{\n\t\tDuration: Ptr(\"1h\"),\n\t\tSummary:  Ptr(\"test\"),\n\t}\n\n\ttimeState, _, err := client.Issues.AddSpentTime(\"1\", 5, addSpentTimeOpt)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &TimeStats{HumanTimeEstimate: \"\", HumanTotalTimeSpent: \"1h\", TimeEstimate: 0, TotalTimeSpent: 3600}\n\n\tif !reflect.DeepEqual(want, timeState) {\n\t\tt.Errorf(\"Issues.AddSpentTime returned %+v, want %+v\", timeState, want)\n\t}\n}\n\nfunc TestResetSpentTime(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/reset_spent_time\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues/5/reset_spent_time\")\n\t\tfmt.Fprint(w, `{\"human_time_estimate\": null, \"human_total_time_spent\": \"\", \"time_estimate\": 0, \"total_time_spent\": 0}`)\n\t})\n\n\ttimeState, _, err := client.Issues.ResetSpentTime(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &TimeStats{HumanTimeEstimate: \"\", HumanTotalTimeSpent: \"\", TimeEstimate: 0, TotalTimeSpent: 0}\n\tif !reflect.DeepEqual(want, timeState) {\n\t\tt.Errorf(\"Issues.ResetSpentTime returned %+v, want %+v\", timeState, want)\n\t}\n}\n\nfunc TestGetTimeSpent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/time_stats\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues/5/time_stats\")\n\t\tfmt.Fprint(w, `{\"human_time_estimate\": \"2h\", \"human_total_time_spent\": \"1h\", \"time_estimate\": 7200, \"total_time_spent\": 3600}`)\n\t})\n\n\ttimeState, _, err := client.Issues.GetTimeSpent(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &TimeStats{HumanTimeEstimate: \"2h\", HumanTotalTimeSpent: \"1h\", TimeEstimate: 7200, TotalTimeSpent: 3600}\n\tif !reflect.DeepEqual(want, timeState) {\n\t\tt.Errorf(\"Issues.GetTimeSpent returned %+v, want %+v\", timeState, want)\n\t}\n}\n\nfunc TestGetIssueParticipants(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5/participants\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/issues/5/participants\")\n\n\t\tfmt.Fprint(w, `[{\"id\":1,\"name\":\"User1\",\"username\":\"User1\",\"state\":\"active\",\"avatar_url\":\"\",\"web_url\":\"https://localhost/User1\"},\n\t\t{\"id\":2,\"name\":\"User2\",\"username\":\"User2\",\"state\":\"active\",\"avatar_url\":\"https://localhost/uploads/-/system/user/avatar/2/avatar.png\",\"web_url\":\"https://localhost/User2\"}]`)\n\t})\n\n\tissueParticipants, _, err := client.Issues.GetParticipants(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*BasicUser{\n\t\t{ID: 1, Name: \"User1\", Username: \"User1\", State: \"active\", AvatarURL: \"\", WebURL: \"https://localhost/User1\"},\n\t\t{ID: 2, Name: \"User2\", Username: \"User2\", State: \"active\", AvatarURL: \"https://localhost/uploads/-/system/user/avatar/2/avatar.png\", WebURL: \"https://localhost/User2\"},\n\t}\n\n\tif !reflect.DeepEqual(want, issueParticipants) {\n\t\tt.Errorf(\"Issues.GetIssueParticipants returned %+v, want %+v\", issueParticipants, want)\n\t}\n}\n\nfunc TestGetIssueMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}],\"merge_requests_count\": 1,\n\t\t\t\"milestone\": {\"due_date\": null, \"project_id\": 1, \"state\": \"closed\", \"description\": \"test\", \"iid\": 3, \"id\": 11, \"title\": \"v3.0\"}}`)\n\t})\n\n\tissue, _, err := client.Issues.GetIssue(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:                1,\n\t\tDescription:       \"This is test project\",\n\t\tAuthor:            &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:         []*IssueAssignee{{ID: 1}},\n\t\tMergeRequestCount: 1,\n\t\tMilestone: &Milestone{\n\t\t\tDueDate:     nil,\n\t\t\tProjectID:   1,\n\t\t\tState:       \"closed\",\n\t\t\tDescription: \"test\",\n\t\t\tIID:         3,\n\t\t\tID:          11,\n\t\t\tTitle:       \"v3.0\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.GetIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n\nfunc TestGetIssueGroupMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/issues/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"description\": \"This is test project\", \"author\" : {\"id\" : 1, \"name\": \"snehal\"}, \"assignees\":[{\"id\":1}],\"merge_requests_count\": 1,\n\t\t\t\"milestone\": {\"due_date\": null, \"group_id\": 13, \"state\": \"closed\", \"description\": \"test\", \"iid\": 3, \"id\": 11, \"title\": \"v3.0\"}}`)\n\t})\n\n\tissue, _, err := client.Issues.GetIssue(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Issue{\n\t\tID:                1,\n\t\tDescription:       \"This is test project\",\n\t\tAuthor:            &IssueAuthor{ID: 1, Name: \"snehal\"},\n\t\tAssignees:         []*IssueAssignee{{ID: 1}},\n\t\tMergeRequestCount: 1,\n\t\tMilestone: &Milestone{\n\t\t\tDueDate:     nil,\n\t\t\tGroupID:     13,\n\t\t\tState:       \"closed\",\n\t\t\tDescription: \"test\",\n\t\t\tIID:         3,\n\t\t\tID:          11,\n\t\t\tTitle:       \"v3.0\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, issue) {\n\t\tt.Errorf(\"Issues.GetIssue returned %+v, want %+v\", issue, want)\n\t}\n}\n"
        },
        {
          "name": "job_token_scope.go",
          "type": "blob",
          "size": 9.5458984375,
          "content": "// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// JobTokenScopeService handles communication with project CI settings\n// such as token permissions.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_job_token_scopes.html\ntype JobTokenScopeService struct {\n\tclient *Client\n}\n\n// JobTokenAccessSettings represents job token access attributes for this project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_job_token_scopes.html\ntype JobTokenAccessSettings struct {\n\tInboundEnabled  bool `json:\"inbound_enabled\"`\n\tOutboundEnabled bool `json:\"outbound_enabled\"`\n}\n\n// GetProjectJobTokenAccessSettings fetch the CI/CD job token access settings (job token scope) of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#get-a-projects-cicd-job-token-access-settings\nfunc (j *JobTokenScopeService) GetProjectJobTokenAccessSettings(pid interface{}, options ...RequestOptionFunc) (*JobTokenAccessSettings, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope`, PathEscape(project))\n\n\treq, err := j.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjt := new(JobTokenAccessSettings)\n\tresp, err := j.client.Do(req, jt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn jt, resp, err\n}\n\n// PatchProjectJobTokenAccessSettingsOptions represents the available\n// PatchProjectJobTokenAccessSettings() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#patch-a-projects-cicd-job-token-access-settings\ntype PatchProjectJobTokenAccessSettingsOptions struct {\n\tEnabled bool `json:\"enabled\"`\n}\n\n// PatchProjectJobTokenAccessSettings patch the Limit access to this project setting (job token scope) of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#patch-a-projects-cicd-job-token-access-settings\nfunc (j *JobTokenScopeService) PatchProjectJobTokenAccessSettings(pid interface{}, opt *PatchProjectJobTokenAccessSettingsOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope`, PathEscape(project))\n\n\treq, err := j.client.NewRequest(http.MethodPatch, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn j.client.Do(req, nil)\n}\n\n// JobTokenInboundAllowItem represents a single job token inbound allowlist item.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_job_token_scopes.html\ntype JobTokenInboundAllowItem struct {\n\tSourceProjectID int `json:\"source_project_id\"`\n\tTargetProjectID int `json:\"target_project_id\"`\n}\n\n// GetJobTokenInboundAllowListOptions represents the available\n// GetJobTokenInboundAllowList() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#get-a-projects-cicd-job-token-inbound-allowlist\ntype GetJobTokenInboundAllowListOptions struct {\n\tListOptions\n}\n\n// GetProjectJobTokenInboundAllowList fetches the CI/CD job token inbound\n// allowlist (job token scope) of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#get-a-projects-cicd-job-token-inbound-allowlist\nfunc (j *JobTokenScopeService) GetProjectJobTokenInboundAllowList(pid interface{}, opt *GetJobTokenInboundAllowListOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope/allowlist`, PathEscape(project))\n\n\treq, err := j.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Project\n\tresp, err := j.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// AddProjectToJobScopeAllowListOptions represents the available\n// AddProjectToJobScopeAllowList() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#create-a-new-project-to-a-projects-cicd-job-token-inbound-allowlist\ntype JobTokenInboundAllowOptions struct {\n\tTargetProjectID *int `url:\"target_project_id,omitempty\" json:\"target_project_id,omitempty\"`\n}\n\n// AddProjectToJobScopeAllowList adds a new project to a project's job token\n// inbound allow list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#create-a-new-project-to-a-projects-cicd-job-token-inbound-allowlist\nfunc (j *JobTokenScopeService) AddProjectToJobScopeAllowList(pid interface{}, opt *JobTokenInboundAllowOptions, options ...RequestOptionFunc) (*JobTokenInboundAllowItem, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope/allowlist`, PathEscape(project))\n\n\treq, err := j.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjt := new(JobTokenInboundAllowItem)\n\tresp, err := j.client.Do(req, jt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn jt, resp, nil\n}\n\n// RemoveProjectFromJobScopeAllowList removes a project from a project's job\n// token inbound allow list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#remove-a-project-from-a-projects-cicd-job-token-inbound-allowlist\nfunc (j *JobTokenScopeService) RemoveProjectFromJobScopeAllowList(pid interface{}, targetProject int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope/allowlist/%d`, PathEscape(project), targetProject)\n\n\treq, err := j.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn j.client.Do(req, nil)\n}\n\n// JobTokenAllowlistItem represents a single job token allowlist item.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_job_token_scopes.html\ntype JobTokenAllowlistItem struct {\n\tSourceProjectID int `json:\"source_project_id\"`\n\tTargetGroupID   int `json:\"target_group_id\"`\n}\n\n// GetJobTokenAllowlistGroupsOptions represents the available\n// GetJobTokenAllowlistGroups() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#get-a-projects-cicd-job-token-allowlist-of-groups\ntype GetJobTokenAllowlistGroupsOptions struct {\n\tListOptions\n}\n\n// GetJobTokenAllowListGroups fetches the CI/CD job token allowlist groups\n// (job token scopes) of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#get-a-projects-cicd-job-token-allowlist-of-groups\nfunc (j *JobTokenScopeService) GetJobTokenAllowlistGroups(pid interface{}, opt *GetJobTokenAllowlistGroupsOptions, options ...RequestOptionFunc) ([]*Group, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope/groups_allowlist`, PathEscape(project))\n\n\treq, err := j.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Group\n\tresp, err := j.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// AddGroupToJobTokenAllowlistOptions represents the available\n// AddGroupToJobTokenAllowlist() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#add-a-group-to-a-cicd-job-token-allowlist\ntype AddGroupToJobTokenAllowlistOptions struct {\n\tTargetGroupID *int `url:\"target_group_id,omitempty\" json:\"target_group_id,omitempty\"`\n}\n\n// AddProjectToJobScopeGroupsAllowList adds a new group to a project's job token\n// inbound groups allow list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#add-a-group-to-a-cicd-job-token-allowlist\nfunc (j *JobTokenScopeService) AddGroupToJobTokenAllowlist(pid interface{}, opt *AddGroupToJobTokenAllowlistOptions, options ...RequestOptionFunc) (*JobTokenAllowlistItem, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope/groups_allowlist`, PathEscape(project))\n\n\treq, err := j.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjt := new(JobTokenAllowlistItem)\n\tresp, err := j.client.Do(req, jt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn jt, resp, nil\n}\n\n// RemoveGroupFromJopTokenAllowlist removes a group from a project's job\n// token inbound groups allow list.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_job_token_scopes.html#remove-a-group-from-a-cicd-job-token-allowlist\nfunc (j *JobTokenScopeService) RemoveGroupFromJobTokenAllowlist(pid interface{}, targetGroup int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(`projects/%s/job_token_scope/groups_allowlist/%d`, PathEscape(project), targetGroup)\n\n\treq, err := j.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn j.client.Do(req, nil)\n}\n"
        },
        {
          "name": "job_token_scope_test.go",
          "type": "blob",
          "size": 8.501953125,
          "content": "// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestGetProjectTokenAccessSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Handle project ID 1, and print a result of access settings\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\n\t\t// Print on the response\n\t\tfmt.Fprint(w, `{\"inbound_enabled\":true,\"outbound_enabled\":false}`)\n\t})\n\n\twant := &JobTokenAccessSettings{\n\t\tInboundEnabled:  true,\n\t\tOutboundEnabled: false,\n\t}\n\n\tsettings, _, err := client.JobTokenScope.GetProjectJobTokenAccessSettings(1)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, settings)\n}\n\nfunc TestPatchProjectJobTokenAccessSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPatch)\n\n\t\t// Read the request to determine which target project is passed in\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.PatchProjectJobTokenAccessSettings failed to read body\")\n\t\t}\n\n\t\t// Parse to object to ensure it's sent on the request appropriately.\n\t\tvar options PatchProjectJobTokenAccessSettingsOptions\n\t\terr = json.Unmarshal(body, &options)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.PatchProjectJobTokenAccessSettings failed to unmarshal body: %v\", err)\n\t\t}\n\n\t\t// Ensure we provide the proper response\n\t\tw.WriteHeader(http.StatusNoContent)\n\n\t\t// Print an empty body, since that's what the API provides.\n\t\tfmt.Fprint(w, \"\")\n\t})\n\n\tresp, err := client.JobTokenScope.PatchProjectJobTokenAccessSettings(\n\t\t1,\n\t\t&PatchProjectJobTokenAccessSettingsOptions{\n\t\t\tEnabled: false,\n\t\t},\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 204, resp.StatusCode)\n}\n\n// This tests that when calling the GetProjectJobTokenInboundAllowList, we get a\n// list of projects back properly. There isn't a \"deep\" test with every attribute\n// specifieid, because the object returned is a *Project object, which is already\n// tested in project.go.\nfunc TestGetProjectJobTokenInboundAllowList(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Handle project ID 1, and print a result of two projects\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope/allowlist\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\n\t\t// Print on the response\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tprojects, _, err := client.JobTokenScope.GetProjectJobTokenInboundAllowList(\n\t\t1,\n\t\t&GetJobTokenInboundAllowListOptions{},\n\t)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, projects)\n}\n\nfunc TestAddProjectToJobScopeAllowList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope/allowlist\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\n\t\t// Read the request to determine which target project is passed in\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.AddProjectToJobScopeAllowList failed to read body\")\n\t\t}\n\n\t\t// Parse to object to ensure it's sent on the request appropriately.\n\t\tvar createTokenRequest JobTokenInboundAllowOptions\n\t\terr = json.Unmarshal(body, &createTokenRequest)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.AddProjectToJobScopeAllowList failed to unmarshal body: %v\", err)\n\t\t}\n\n\t\t// Ensure we provide the proper response\n\t\tw.WriteHeader(http.StatusCreated)\n\n\t\t// Print on the response with the proper target project\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"source_project_id\": 1,\n\t\t\t\"target_project_id\": %d\n\t\t}`, *createTokenRequest.TargetProjectID)\n\t})\n\n\twant := &JobTokenInboundAllowItem{\n\t\tSourceProjectID: 1,\n\t\tTargetProjectID: 2,\n\t}\n\n\taddTokenResponse, resp, err := client.JobTokenScope.AddProjectToJobScopeAllowList(\n\t\t1,\n\t\t&JobTokenInboundAllowOptions{TargetProjectID: Ptr(2)},\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, addTokenResponse)\n\tassert.Equal(t, 201, resp.StatusCode)\n}\n\nfunc TestRemoveProjectFromJobScopeAllowList(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope/allowlist/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\n\t\t// Read the request to determine which target project is passed in\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.RemoveProjectFromJobScopeAllowList failed to read body\")\n\t\t}\n\n\t\t// The body should be empty since all attributes are passed in the path\n\t\tif body != nil && string(body) != \"\" {\n\t\t\tt.Fatalf(\"JobTokenScope.RemoveProjectFromJobScopeAllowList failed to unmarshal body: %v\", err)\n\t\t}\n\n\t\t// Ensure we provide the proper response\n\t\tw.WriteHeader(http.StatusNoContent)\n\n\t\t// Print an empty body, since that's what the API provides.\n\t\tfmt.Fprint(w, \"\")\n\t})\n\n\tresp, err := client.JobTokenScope.RemoveProjectFromJobScopeAllowList(1, 2)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 204, resp.StatusCode)\n}\n\n// This tests that when calling the GetJobTokenAllowlistGroups, we get a list\n// of groups back. There isn't a \"deep\" test with every attribute specified,\n// because the object returned is a *Group object, which is already tested in\n// groups.go.\nfunc TestGetJobTokenAllowlistGroups(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Handle project ID 1, and print a result of two groups\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope/groups_allowlist\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\n\t\t// Print on the response\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\twant := []*Group{{ID: 1}, {ID: 2}}\n\tgroups, _, err := client.JobTokenScope.GetJobTokenAllowlistGroups(\n\t\t1,\n\t\t&GetJobTokenAllowlistGroupsOptions{},\n\t)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, groups)\n}\n\nfunc TestAddGroupToJobTokenAllowlist(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope/groups_allowlist\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\n\t\t// Read the request to determine which target group is passed in\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.AddGroupToJobTokenAllowlist failed to read body\")\n\t\t}\n\n\t\t// Parse to object to ensure it's sent on the request appropriately.\n\t\tvar createTokenRequest AddGroupToJobTokenAllowlistOptions\n\t\terr = json.Unmarshal(body, &createTokenRequest)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.AddGroupToJobTokenAllowlist failed to unmarshal body: %v\", err)\n\t\t}\n\n\t\t// Ensure we provide the proper response\n\t\tw.WriteHeader(http.StatusCreated)\n\n\t\t// Print on the response with the proper target group\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"source_project_id\": 1,\n\t\t\t\"target_group_id\": %d\n\t\t}`, *createTokenRequest.TargetGroupID)\n\t})\n\n\twant := &JobTokenAllowlistItem{\n\t\tSourceProjectID: 1,\n\t\tTargetGroupID:   2,\n\t}\n\n\taddTokenResponse, resp, err := client.JobTokenScope.AddGroupToJobTokenAllowlist(\n\t\t1,\n\t\t&AddGroupToJobTokenAllowlistOptions{TargetGroupID: Ptr(2)},\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, want, addTokenResponse)\n\tassert.Equal(t, 201, resp.StatusCode)\n}\n\nfunc TestRemoveGroupFromJobTokenAllowlist(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/job_token_scope/groups_allowlist/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\n\t\t// Read the request to determine which target group is passed in\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"JobTokenScope.RemoveGroupFromJobTokenAllowlist failed to read body\")\n\t\t}\n\n\t\t// The body should be empty since all attributes are passed in the path\n\t\tif body != nil && string(body) != \"\" {\n\t\t\tt.Fatalf(\"JobTokenScope.RemoveGroupFromJobTokenAllowlist failed to unmarshal body: %v\", err)\n\t\t}\n\n\t\t// Ensure we provide the proper response\n\t\tw.WriteHeader(http.StatusNoContent)\n\n\t\t// Print an empty body, since that's what the API provides.\n\t\tfmt.Fprint(w, \"\")\n\t})\n\n\tresp, err := client.JobTokenScope.RemoveGroupFromJobTokenAllowlist(1, 2)\n\tassert.NoError(t, err)\n\tassert.Equal(t, 204, resp.StatusCode)\n}\n"
        },
        {
          "name": "jobs.go",
          "type": "blob",
          "size": 17.36328125,
          "content": "//\n// Copyright 2021, Arkbriar\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// JobsService handles communication with the ci builds related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/jobs.html\ntype JobsService struct {\n\tclient *Client\n}\n\n// Job represents a ci build.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/jobs.html\ntype Job struct {\n\tCommit            *Commit    `json:\"commit\"`\n\tCoverage          float64    `json:\"coverage\"`\n\tAllowFailure      bool       `json:\"allow_failure\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n\tStartedAt         *time.Time `json:\"started_at\"`\n\tFinishedAt        *time.Time `json:\"finished_at\"`\n\tErasedAt          *time.Time `json:\"erased_at\"`\n\tDuration          float64    `json:\"duration\"`\n\tQueuedDuration    float64    `json:\"queued_duration\"`\n\tArtifactsExpireAt *time.Time `json:\"artifacts_expire_at\"`\n\tTagList           []string   `json:\"tag_list\"`\n\tID                int        `json:\"id\"`\n\tName              string     `json:\"name\"`\n\tPipeline          struct {\n\t\tID        int    `json:\"id\"`\n\t\tProjectID int    `json:\"project_id\"`\n\t\tRef       string `json:\"ref\"`\n\t\tSha       string `json:\"sha\"`\n\t\tStatus    string `json:\"status\"`\n\t} `json:\"pipeline\"`\n\tRef       string `json:\"ref\"`\n\tArtifacts []struct {\n\t\tFileType   string `json:\"file_type\"`\n\t\tFilename   string `json:\"filename\"`\n\t\tSize       int    `json:\"size\"`\n\t\tFileFormat string `json:\"file_format\"`\n\t} `json:\"artifacts\"`\n\tArtifactsFile struct {\n\t\tFilename string `json:\"filename\"`\n\t\tSize     int    `json:\"size\"`\n\t} `json:\"artifacts_file\"`\n\tRunner struct {\n\t\tID          int    `json:\"id\"`\n\t\tDescription string `json:\"description\"`\n\t\tActive      bool   `json:\"active\"`\n\t\tIsShared    bool   `json:\"is_shared\"`\n\t\tName        string `json:\"name\"`\n\t} `json:\"runner\"`\n\tStage         string   `json:\"stage\"`\n\tStatus        string   `json:\"status\"`\n\tFailureReason string   `json:\"failure_reason\"`\n\tTag           bool     `json:\"tag\"`\n\tWebURL        string   `json:\"web_url\"`\n\tProject       *Project `json:\"project\"`\n\tUser          *User    `json:\"user\"`\n}\n\n// Bridge represents a pipeline bridge.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/jobs.html#list-pipeline-bridges\ntype Bridge struct {\n\tCommit             *Commit       `json:\"commit\"`\n\tCoverage           float64       `json:\"coverage\"`\n\tAllowFailure       bool          `json:\"allow_failure\"`\n\tCreatedAt          *time.Time    `json:\"created_at\"`\n\tStartedAt          *time.Time    `json:\"started_at\"`\n\tFinishedAt         *time.Time    `json:\"finished_at\"`\n\tErasedAt           *time.Time    `json:\"erased_at\"`\n\tDuration           float64       `json:\"duration\"`\n\tQueuedDuration     float64       `json:\"queued_duration\"`\n\tID                 int           `json:\"id\"`\n\tName               string        `json:\"name\"`\n\tPipeline           PipelineInfo  `json:\"pipeline\"`\n\tRef                string        `json:\"ref\"`\n\tStage              string        `json:\"stage\"`\n\tStatus             string        `json:\"status\"`\n\tFailureReason      string        `json:\"failure_reason\"`\n\tTag                bool          `json:\"tag\"`\n\tWebURL             string        `json:\"web_url\"`\n\tUser               *User         `json:\"user\"`\n\tDownstreamPipeline *PipelineInfo `json:\"downstream_pipeline\"`\n}\n\n// ListJobsOptions represents the available ListProjectJobs() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#list-project-jobs\ntype ListJobsOptions struct {\n\tListOptions\n\tScope          *[]BuildStateValue `url:\"scope[],omitempty\" json:\"scope,omitempty\"`\n\tIncludeRetried *bool              `url:\"include_retried,omitempty\" json:\"include_retried,omitempty\"`\n}\n\n// ListProjectJobs gets a list of jobs in a project.\n//\n// The scope of jobs to show, one or array of: created, pending, running,\n// failed, success, canceled, skipped; showing all jobs if none provided\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#list-project-jobs\nfunc (s *JobsService) ListProjectJobs(pid interface{}, opts *ListJobsOptions, options ...RequestOptionFunc) ([]*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar jobs []*Job\n\tresp, err := s.client.Do(req, &jobs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn jobs, resp, nil\n}\n\n// ListPipelineJobs gets a list of jobs for specific pipeline in a\n// project. If the pipeline ID is not found, it will respond with 404.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#list-pipeline-jobs\nfunc (s *JobsService) ListPipelineJobs(pid interface{}, pipelineID int, opts *ListJobsOptions, options ...RequestOptionFunc) ([]*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/jobs\", PathEscape(project), pipelineID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar jobs []*Job\n\tresp, err := s.client.Do(req, &jobs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn jobs, resp, nil\n}\n\n// ListPipelineBridges gets a list of bridges for specific pipeline in a\n// project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#list-pipeline-jobs\nfunc (s *JobsService) ListPipelineBridges(pid interface{}, pipelineID int, opts *ListJobsOptions, options ...RequestOptionFunc) ([]*Bridge, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/bridges\", PathEscape(project), pipelineID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bridges []*Bridge\n\tresp, err := s.client.Do(req, &bridges)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bridges, resp, nil\n}\n\n// GetJobTokensJobOptions represents the available GetJobTokensJob() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/jobs.html#get-job-tokens-job\ntype GetJobTokensJobOptions struct {\n\tJobToken *string `url:\"job_token,omitempty\" json:\"job_token,omitempty\"`\n}\n\n// GetJobTokensJob retrieves the job that generated a job token.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/jobs.html#get-job-tokens-job\nfunc (s *JobsService) GetJobTokensJob(opts *GetJobTokensJobOptions, options ...RequestOptionFunc) (*Job, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"job\", opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// GetJob gets a single job of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#get-a-single-job\nfunc (s *JobsService) GetJob(pid interface{}, jobID int, options ...RequestOptionFunc) (*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// GetJobArtifacts get jobs artifacts of a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#get-job-artifacts\nfunc (s *JobsService) GetJobArtifacts(pid interface{}, jobID int, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/artifacts\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tartifactsBuf := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, artifactsBuf)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(artifactsBuf.Bytes()), resp, err\n}\n\n// DownloadArtifactsFileOptions represents the available DownloadArtifactsFile()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#download-the-artifacts-archive\ntype DownloadArtifactsFileOptions struct {\n\tJob *string `url:\"job\" json:\"job\"`\n}\n\n// DownloadArtifactsFile download the artifacts file from the given\n// reference name and job provided the job finished successfully.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#download-the-artifacts-archive\nfunc (s *JobsService) DownloadArtifactsFile(pid interface{}, refName string, opt *DownloadArtifactsFileOptions, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/artifacts/%s/download\", PathEscape(project), refName)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tartifactsBuf := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, artifactsBuf)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(artifactsBuf.Bytes()), resp, err\n}\n\n// DownloadSingleArtifactsFile download a file from the artifacts from the\n// given reference name and job provided the job finished successfully.\n// Only a single file is going to be extracted from the archive and streamed\n// to a client.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#download-a-single-artifact-file-by-job-id\nfunc (s *JobsService) DownloadSingleArtifactsFile(pid interface{}, jobID int, artifactPath string, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/jobs/%d/artifacts/%s\",\n\t\tPathEscape(project),\n\t\tjobID,\n\t\tartifactPath,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tartifactBuf := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, artifactBuf)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(artifactBuf.Bytes()), resp, err\n}\n\n// DownloadSingleArtifactsFile download a single artifact file for a specific\n// job of the latest successful pipeline for the given reference name from\n// inside the job’s artifacts archive. The file is extracted from the archive\n// and streamed to the client.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#download-a-single-artifact-file-from-specific-tag-or-branch\nfunc (s *JobsService) DownloadSingleArtifactsFileByTagOrBranch(pid interface{}, refName string, artifactPath string, opt *DownloadArtifactsFileOptions, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/jobs/artifacts/%s/raw/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(refName),\n\t\tartifactPath,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tartifactBuf := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, artifactBuf)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(artifactBuf.Bytes()), resp, err\n}\n\n// GetTraceFile gets a trace of a specific job of a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#get-a-log-file\nfunc (s *JobsService) GetTraceFile(pid interface{}, jobID int, options ...RequestOptionFunc) (*bytes.Reader, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/trace\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ttraceBuf := new(bytes.Buffer)\n\tresp, err := s.client.Do(req, traceBuf)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bytes.NewReader(traceBuf.Bytes()), resp, err\n}\n\n// CancelJob cancels a single job of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#cancel-a-job\nfunc (s *JobsService) CancelJob(pid interface{}, jobID int, options ...RequestOptionFunc) (*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/cancel\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// RetryJob retries a single job of a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#retry-a-job\nfunc (s *JobsService) RetryJob(pid interface{}, jobID int, options ...RequestOptionFunc) (*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/retry\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// EraseJob erases a single job of a project, removes a job\n// artifacts and a job trace.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#erase-a-job\nfunc (s *JobsService) EraseJob(pid interface{}, jobID int, options ...RequestOptionFunc) (*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/erase\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// KeepArtifacts prevents artifacts from being deleted when\n// expiration is set.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#keep-artifacts\nfunc (s *JobsService) KeepArtifacts(pid interface{}, jobID int, options ...RequestOptionFunc) (*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/artifacts/keep\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// PlayJobOptions represents the available PlayJob() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#run-a-job\ntype PlayJobOptions struct {\n\tJobVariablesAttributes *[]*JobVariableOptions `url:\"job_variables_attributes,omitempty\" json:\"job_variables_attributes,omitempty\"`\n}\n\n// JobVariableOptions represents a single job variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#run-a-job\ntype JobVariableOptions struct {\n\tKey          *string            `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tValue        *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tVariableType *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// PlayJob triggers a manual action to start a job.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/jobs.html#run-a-job\nfunc (s *JobsService) PlayJob(pid interface{}, jobID int, opt *PlayJobOptions, options ...RequestOptionFunc) (*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/play\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tjob := new(Job)\n\tresp, err := s.client.Do(req, job)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn job, resp, nil\n}\n\n// DeleteArtifacts delete artifacts of a job\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#delete-job-artifacts\nfunc (s *JobsService) DeleteArtifacts(pid interface{}, jobID int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/jobs/%d/artifacts\", PathEscape(project), jobID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteProjectArtifacts delete artifacts eligible for deletion in a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/job_artifacts.html#delete-project-artifacts\nfunc (s *JobsService) DeleteProjectArtifacts(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/artifacts\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "jobs_test.go",
          "type": "blob",
          "size": 6.01953125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListPipelineJobs(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/1/jobs\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\tjobs, _, err := client.Jobs.ListPipelineJobs(1, 1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Jobs.ListPipelineJobs returned error: %v\", err)\n\t}\n\n\twant := []*Job{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, jobs) {\n\t\tt.Errorf(\"Jobs.ListPipelineJobs returned %+v, want %+v\", jobs, want)\n\t}\n}\n\nfunc TestJobsService_ListProjectJobs(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/jobs\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n  {\n    \"commit\": {\n      \"author_email\": \"admin@example.com\",\n      \"author_name\": \"Administrator\",\n      \"id\": \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n      \"short_id\": \"0ff3ae19\",\n      \"title\": \"Test the CI integration.\"\n    },\n    \"allow_failure\": false,\n    \"tag_list\": [\n      \"docker runner\",\n      \"ubuntu18\"\n    ],\n    \"id\": 7,\n    \"name\": \"teaspoon\",\n    \"pipeline\": {\n      \"id\": 6,\n      \"project_id\": 1,\n      \"ref\": \"master\",\n      \"sha\": \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n      \"status\": \"pending\"\n    },\n    \"ref\": \"master\",\n    \"stage\": \"test\",\n    \"status\": \"failed\",\n\t  \"failure_reason\": \"script_failure\",\n    \"tag\": false,\n    \"web_url\": \"https://example.com/foo/bar/-/jobs/7\"\n  },\n  {\n    \"commit\": {\n      \"author_email\": \"admin@example.com\",\n      \"author_name\": \"Administrator\",\n      \"id\": \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n      \"message\": \"Test the CI integration.\",\n      \"short_id\": \"0ff3ae19\",\n      \"title\": \"Test the CI integration.\"\n    },\n    \"allow_failure\": false,\n    \"duration\": 0.192,\n    \"tag_list\": [\n      \"docker runner\",\n      \"win10-2004\"\n    ],\n    \"id\": 6,\n    \"name\": \"rspec:other\",\n    \"pipeline\": {\n      \"id\": 6,\n      \"project_id\": 1,\n      \"ref\": \"master\",\n      \"sha\": \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n      \"status\": \"pending\"\n    },\n    \"ref\": \"master\",\n    \"runner\": null,\n    \"stage\": \"test\",\n    \"status\": \"failed\",\n    \"tag\": false,\n    \"web_url\": \"https://example.com/foo/bar/-/jobs/6\"\n  }\n]`)\n\t})\n\n\tjobs, _, err := client.Jobs.ListProjectJobs(1, nil, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Jobs.ListProjectJobs returned error: %v\", err)\n\t}\n\n\twant := []*Job{\n\t\t{\n\t\t\tCommit: &Commit{\n\t\t\t\tID:          \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n\t\t\t\tShortID:     \"0ff3ae19\",\n\t\t\t\tTitle:       \"Test the CI integration.\",\n\t\t\t\tAuthorName:  \"Administrator\",\n\t\t\t\tAuthorEmail: \"admin@example.com\",\n\t\t\t},\n\t\t\tAllowFailure: false,\n\t\t\tID:           7,\n\t\t\tName:         \"teaspoon\",\n\t\t\tTagList:      []string{\"docker runner\", \"ubuntu18\"},\n\t\t\tPipeline: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tProjectID int    `json:\"project_id\"`\n\t\t\t\tRef       string `json:\"ref\"`\n\t\t\t\tSha       string `json:\"sha\"`\n\t\t\t\tStatus    string `json:\"status\"`\n\t\t\t}{\n\t\t\t\tID:        6,\n\t\t\t\tProjectID: 1,\n\t\t\t\tRef:       \"master\",\n\t\t\t\tSha:       \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n\t\t\t\tStatus:    \"pending\",\n\t\t\t},\n\t\t\tRef:           \"master\",\n\t\t\tStage:         \"test\",\n\t\t\tStatus:        \"failed\",\n\t\t\tFailureReason: \"script_failure\",\n\t\t\tTag:           false,\n\t\t\tWebURL:        \"https://example.com/foo/bar/-/jobs/7\",\n\t\t},\n\t\t{\n\t\t\tCommit: &Commit{\n\t\t\t\tID:          \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n\t\t\t\tShortID:     \"0ff3ae19\",\n\t\t\t\tTitle:       \"Test the CI integration.\",\n\t\t\t\tAuthorName:  \"Administrator\",\n\t\t\t\tAuthorEmail: \"admin@example.com\",\n\t\t\t\tMessage:     \"Test the CI integration.\",\n\t\t\t},\n\t\t\tAllowFailure: false,\n\t\t\tDuration:     0.192,\n\t\t\tID:           6,\n\t\t\tName:         \"rspec:other\",\n\t\t\tTagList:      []string{\"docker runner\", \"win10-2004\"},\n\t\t\tPipeline: struct {\n\t\t\t\tID        int    `json:\"id\"`\n\t\t\t\tProjectID int    `json:\"project_id\"`\n\t\t\t\tRef       string `json:\"ref\"`\n\t\t\t\tSha       string `json:\"sha\"`\n\t\t\t\tStatus    string `json:\"status\"`\n\t\t\t}{\n\t\t\t\tID:        6,\n\t\t\t\tProjectID: 1,\n\t\t\t\tRef:       \"master\",\n\t\t\t\tSha:       \"0ff3ae198f8601a285adcf5c0fff204ee6fba5fd\",\n\t\t\t\tStatus:    \"pending\",\n\t\t\t},\n\t\t\tRef:    \"master\",\n\t\t\tStage:  \"test\",\n\t\t\tStatus: \"failed\",\n\t\t\tTag:    false,\n\t\t\tWebURL: \"https://example.com/foo/bar/-/jobs/6\",\n\t\t},\n\t}\n\tassert.Equal(t, want, jobs)\n}\n\nfunc TestDownloadSingleArtifactsFileByTagOrBranch(t *testing.T) {\n\tmux, client := setup(t)\n\n\twantContent := []byte(\"This is the file content\")\n\tmux.HandleFunc(\"/api/v4/projects/9/jobs/artifacts/abranch/raw/foo/bar.pdf\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(wantContent)\n\t})\n\n\topt := &DownloadArtifactsFileOptions{Job: Ptr(\"publish\")}\n\treader, resp, err := client.Jobs.DownloadSingleArtifactsFileByTagOrBranch(9, \"abranch\", \"foo/bar.pdf\", opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Jobs.DownloadSingleArtifactsFileByTagOrBranch returns an error: %v\", err)\n\t}\n\n\tcontent, err := io.ReadAll(reader)\n\tif err != nil {\n\t\tt.Fatalf(\"Jobs.DownloadSingleArtifactsFileByTagOrBranch error reading: %v\", err)\n\t}\n\tif !reflect.DeepEqual(content, wantContent) {\n\t\tt.Errorf(\"Jobs.DownloadSingleArtifactsFileByTagOrBranch returned %+v, want %+v\", content, wantContent)\n\t}\n\n\twantCode := 200\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Jobs.DownloadSingleArtifactsFileByTagOrBranch returned returned status code  %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n"
        },
        {
          "name": "keys.go",
          "type": "blob",
          "size": 2.7109375,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// KeysService handles communication with the\n// keys related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/keys.html\ntype KeysService struct {\n\tclient *Client\n}\n\n// Key represents a GitLab user's SSH key.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/keys.html\ntype Key struct {\n\tID        int        `json:\"id\"`\n\tTitle     string     `json:\"title\"`\n\tKey       string     `json:\"key\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tUser      User       `json:\"user\"`\n}\n\n// GetKeyWithUser gets a single key by id along with the associated\n// user information.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/keys.html#get-ssh-key-with-user-by-id-of-an-ssh-key\nfunc (s *KeysService) GetKeyWithUser(key int, options ...RequestOptionFunc) (*Key, *Response, error) {\n\tu := fmt.Sprintf(\"keys/%d\", key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(Key)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// GetKeyByFingerprintOptions represents the available GetKeyByFingerprint()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/keys.html#get-user-by-fingerprint-of-ssh-key\n// https://docs.gitlab.com/ee/api/keys.html#get-user-by-deploy-key-fingerprint\ntype GetKeyByFingerprintOptions struct {\n\tFingerprint string `url:\"fingerprint\" json:\"fingerprint\"`\n}\n\n// GetKeyByFingerprint gets a specific SSH key or deploy key by fingerprint\n// along with the associated user information.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/keys.html#get-user-by-fingerprint-of-ssh-key\n// https://docs.gitlab.com/ee/api/keys.html#get-user-by-deploy-key-fingerprint\nfunc (s *KeysService) GetKeyByFingerprint(opt *GetKeyByFingerprintOptions, options ...RequestOptionFunc) (*Key, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"keys\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(Key)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n"
        },
        {
          "name": "keys_test.go",
          "type": "blob",
          "size": 5.841796875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetKeyWithUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/keys/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"Sample key 25\",\n\t\t\t  \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAIEAiPWx6WM4lhHNedGfBpPJNPpZ7yKu+dnn1SJejgt1256k6YjzGGphH2TUxwKzxcKDKKezwkpfnxPkSMkuEspGRt/aZZ9wa++Oi7Qkr8prgHc4soW6NUlfDzpvZK2H5E7eQaSeP3SAwGmQKUFHCddNaP0L+hM7zhFNzjFvpaMgJw0=\",\n\t\t\t  \"user\": {\n\t\t\t    \"id\": 25,\n\t\t\t    \"username\": \"john_smith\",\n\t\t\t    \"name\": \"John Smith\",\n\t\t\t    \"email\": \"john@example.com\",\n\t\t\t    \"state\": \"active\",\n\t\t\t    \"bio\": null,\n\t\t\t    \"location\": null,\n\t\t\t    \"skype\": \"\",\n\t\t\t    \"linkedin\": \"\",\n\t\t\t    \"twitter\": \"\",\n\t\t\t    \"website_url\": \"http://localhost:3000/john_smith\",\n\t\t\t    \"organization\": null,\n\t\t\t    \"theme_id\": 2,\n\t\t\t    \"color_scheme_id\": 1,\n\t\t\t    \"avatar_url\": \"http://www.gravatar.com/avatar/cfa35b8cd2ec278026357769582fa563?s=40\\u0026d=identicon\",\n\t\t\t    \"can_create_group\": true,\n\t\t\t    \"can_create_project\": true,\n\t\t\t    \"projects_limit\": 10,\n\t\t\t    \"two_factor_enabled\": false,\n\t\t\t    \"identities\": [],\n\t\t\t    \"external\": false,\n\t\t\t    \"public_email\": \"john@example.com\"\n\t\t\t  }\n\t\t\t}`)\n\t\t})\n\n\tkey, _, err := client.Keys.GetKeyWithUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Keys.GetKeyWithUser returned error: %v\", err)\n\t}\n\n\twant := &Key{\n\t\tID:    1,\n\t\tTitle: \"Sample key 25\",\n\t\tKey:   \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAIEAiPWx6WM4lhHNedGfBpPJNPpZ7yKu+dnn1SJejgt1256k6YjzGGphH2TUxwKzxcKDKKezwkpfnxPkSMkuEspGRt/aZZ9wa++Oi7Qkr8prgHc4soW6NUlfDzpvZK2H5E7eQaSeP3SAwGmQKUFHCddNaP0L+hM7zhFNzjFvpaMgJw0=\",\n\t\tUser: User{\n\t\t\tID:               25,\n\t\t\tUsername:         \"john_smith\",\n\t\t\tEmail:            \"john@example.com\",\n\t\t\tName:             exampleEventUserName,\n\t\t\tState:            \"active\",\n\t\t\tBio:              \"\",\n\t\t\tLocation:         \"\",\n\t\t\tSkype:            \"\",\n\t\t\tLinkedin:         \"\",\n\t\t\tTwitter:          \"\",\n\t\t\tWebsiteURL:       \"http://localhost:3000/john_smith\",\n\t\t\tOrganization:     \"\",\n\t\t\tThemeID:          2,\n\t\t\tColorSchemeID:    1,\n\t\t\tAvatarURL:        \"http://www.gravatar.com/avatar/cfa35b8cd2ec278026357769582fa563?s=40\\u0026d=identicon\",\n\t\t\tCanCreateGroup:   true,\n\t\t\tCanCreateProject: true,\n\t\t\tProjectsLimit:    10,\n\t\t\tTwoFactorEnabled: false,\n\t\t\tIdentities:       []*UserIdentity{},\n\t\t\tExternal:         false,\n\t\t\tPublicEmail:      \"john@example.com\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, key) {\n\t\tt.Errorf(\"Keys.GetKeyWithUser returned %+v, want %+v\", key, want)\n\t}\n}\n\nfunc TestGetKeyByFingerprint(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/keys\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tif r.URL.Query().Get(\"fingerprint\") == \"07:51:20:af:17:e4:a8:ab:22:79:9b:31:ae:a9:61:f3\" {\n\t\t\t\tfmt.Fprint(w, `{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"Sample key 25\",\n\t\t\t  \"key\": \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAIEAiPWx6WM4lhHNedGfBpPJNPpZ7yKu+dnn1SJejgt1256k6YjzGGphH2TUxwKzxcKDKKezwkpfnxPkSMkuEspGRt/aZZ9wa++Oi7Qkr8prgHc4soW6NUlfDzpvZK2H5E7eQaSeP3SAwGmQKUFHCddNaP0L+hM7zhFNzjFvpaMgJw0=\",\n\t\t\t  \"user\": {\n\t\t\t    \"id\": 25,\n\t\t\t    \"username\": \"john_smith\",\n\t\t\t    \"name\": \"John Smith\",\n\t\t\t    \"email\": \"john@example.com\",\n\t\t\t    \"state\": \"active\",\n\t\t\t    \"bio\": null,\n\t\t\t    \"location\": null,\n\t\t\t    \"skype\": \"\",\n\t\t\t    \"linkedin\": \"\",\n\t\t\t    \"twitter\": \"\",\n\t\t\t    \"website_url\": \"http://localhost:3000/john_smith\",\n\t\t\t    \"organization\": null,\n\t\t\t    \"theme_id\": 2,\n\t\t\t    \"color_scheme_id\": 1,\n\t\t\t    \"avatar_url\": \"http://www.gravatar.com/avatar/cfa35b8cd2ec278026357769582fa563?s=40\\u0026d=identicon\",\n\t\t\t    \"can_create_group\": true,\n\t\t\t    \"can_create_project\": true,\n\t\t\t    \"projects_limit\": 10,\n\t\t\t    \"two_factor_enabled\": false,\n\t\t\t    \"identities\": [],\n\t\t\t    \"external\": false,\n\t\t\t    \"public_email\": \"john@example.com\"\n\t\t\t  }\n\t\t\t}`)\n\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tfmt.Fprint(w, `{}`)\n\t\t})\n\n\tkey, _, err := client.Keys.GetKeyByFingerprint(&GetKeyByFingerprintOptions{\n\t\tFingerprint: \"07:51:20:af:17:e4:a8:ab:22:79:9b:31:ae:a9:61:f3\",\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Keys.GetKeyWithUserByFingerprint returned error: %v\", err)\n\t}\n\n\twant := &Key{\n\t\tID:    1,\n\t\tTitle: \"Sample key 25\",\n\t\tKey:   \"ssh-rsa AAAAB3NzaC1yc2EAAAABJQAAAIEAiPWx6WM4lhHNedGfBpPJNPpZ7yKu+dnn1SJejgt1256k6YjzGGphH2TUxwKzxcKDKKezwkpfnxPkSMkuEspGRt/aZZ9wa++Oi7Qkr8prgHc4soW6NUlfDzpvZK2H5E7eQaSeP3SAwGmQKUFHCddNaP0L+hM7zhFNzjFvpaMgJw0=\",\n\t\tUser: User{\n\t\t\tID:               25,\n\t\t\tUsername:         \"john_smith\",\n\t\t\tEmail:            \"john@example.com\",\n\t\t\tName:             exampleEventUserName,\n\t\t\tState:            \"active\",\n\t\t\tBio:              \"\",\n\t\t\tLocation:         \"\",\n\t\t\tSkype:            \"\",\n\t\t\tLinkedin:         \"\",\n\t\t\tTwitter:          \"\",\n\t\t\tWebsiteURL:       \"http://localhost:3000/john_smith\",\n\t\t\tOrganization:     \"\",\n\t\t\tThemeID:          2,\n\t\t\tColorSchemeID:    1,\n\t\t\tAvatarURL:        \"http://www.gravatar.com/avatar/cfa35b8cd2ec278026357769582fa563?s=40\\u0026d=identicon\",\n\t\t\tCanCreateGroup:   true,\n\t\t\tCanCreateProject: true,\n\t\t\tProjectsLimit:    10,\n\t\t\tTwoFactorEnabled: false,\n\t\t\tIdentities:       []*UserIdentity{},\n\t\t\tExternal:         false,\n\t\t\tPublicEmail:      \"john@example.com\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, key) {\n\t\tt.Errorf(\"Keys.GetKeyWithUserByFingerprint returned %+v, want %+v\", key, want)\n\t}\n}\n"
        },
        {
          "name": "labels.go",
          "type": "blob",
          "size": 9.564453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// LabelsService handles communication with the label related methods of the\n// GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html\ntype LabelsService struct {\n\tclient *Client\n}\n\n// Label represents a GitLab label.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html\ntype Label struct {\n\tID                     int    `json:\"id\"`\n\tName                   string `json:\"name\"`\n\tColor                  string `json:\"color\"`\n\tTextColor              string `json:\"text_color\"`\n\tDescription            string `json:\"description\"`\n\tOpenIssuesCount        int    `json:\"open_issues_count\"`\n\tClosedIssuesCount      int    `json:\"closed_issues_count\"`\n\tOpenMergeRequestsCount int    `json:\"open_merge_requests_count\"`\n\tSubscribed             bool   `json:\"subscribed\"`\n\tPriority               int    `json:\"priority\"`\n\tIsProjectLabel         bool   `json:\"is_project_label\"`\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (l *Label) UnmarshalJSON(data []byte) error {\n\ttype alias Label\n\tif err := json.Unmarshal(data, (*alias)(l)); err != nil {\n\t\treturn err\n\t}\n\n\tif l.Name == \"\" {\n\t\tvar raw map[string]interface{}\n\t\tif err := json.Unmarshal(data, &raw); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif title, ok := raw[\"title\"].(string); ok {\n\t\t\tl.Name = title\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (l Label) String() string {\n\treturn Stringify(l)\n}\n\n// ListLabelsOptions represents the available ListLabels() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#list-labels\ntype ListLabelsOptions struct {\n\tListOptions\n\tWithCounts            *bool   `url:\"with_counts,omitempty\" json:\"with_counts,omitempty\"`\n\tIncludeAncestorGroups *bool   `url:\"include_ancestor_groups,omitempty\" json:\"include_ancestor_groups,omitempty\"`\n\tSearch                *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n}\n\n// ListLabels gets all labels for given project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#list-labels\nfunc (s *LabelsService) ListLabels(pid interface{}, opt *ListLabelsOptions, options ...RequestOptionFunc) ([]*Label, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar l []*Label\n\tresp, err := s.client.Do(req, &l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// GetLabel get a single label for a given project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#get-a-single-project-label\nfunc (s *LabelsService) GetLabel(pid interface{}, lid interface{}, options ...RequestOptionFunc) (*Label, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels/%s\", PathEscape(project), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar l *Label\n\tresp, err := s.client.Do(req, &l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// CreateLabelOptions represents the available CreateLabel() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#create-a-new-label\ntype CreateLabelOptions struct {\n\tName        *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tColor       *string `url:\"color,omitempty\" json:\"color,omitempty\"`\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPriority    *int    `url:\"priority,omitempty\" json:\"priority,omitempty\"`\n}\n\n// CreateLabel creates a new label for given repository with given name and\n// color.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#create-a-new-label\nfunc (s *LabelsService) CreateLabel(pid interface{}, opt *CreateLabelOptions, options ...RequestOptionFunc) (*Label, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(Label)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// DeleteLabelOptions represents the available DeleteLabel() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#delete-a-label\ntype DeleteLabelOptions struct {\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// DeleteLabel deletes a label given by its name or ID.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#delete-a-label\nfunc (s *LabelsService) DeleteLabel(pid interface{}, lid interface{}, opt *DeleteLabelOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels\", PathEscape(project))\n\n\tif lid != nil {\n\t\tlabel, err := parseID(lid)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tu = fmt.Sprintf(\"projects/%s/labels/%s\", PathEscape(project), PathEscape(label))\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// UpdateLabelOptions represents the available UpdateLabel() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#edit-an-existing-label\ntype UpdateLabelOptions struct {\n\tName        *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tNewName     *string `url:\"new_name,omitempty\" json:\"new_name,omitempty\"`\n\tColor       *string `url:\"color,omitempty\" json:\"color,omitempty\"`\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPriority    *int    `url:\"priority,omitempty\" json:\"priority,omitempty\"`\n}\n\n// UpdateLabel updates an existing label with new name or now color. At least\n// one parameter is required, to update the label.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/labels.html#edit-an-existing-label\nfunc (s *LabelsService) UpdateLabel(pid interface{}, lid interface{}, opt *UpdateLabelOptions, options ...RequestOptionFunc) (*Label, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels\", PathEscape(project))\n\n\tif lid != nil {\n\t\tlabel, err := parseID(lid)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tu = fmt.Sprintf(\"projects/%s/labels/%s\", PathEscape(project), PathEscape(label))\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(Label)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// SubscribeToLabel subscribes the authenticated user to a label to receive\n// notifications. If the user is already subscribed to the label, the status\n// code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/labels.html#subscribe-to-a-label\nfunc (s *LabelsService) SubscribeToLabel(pid interface{}, lid interface{}, options ...RequestOptionFunc) (*Label, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels/%s/subscribe\", PathEscape(project), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(Label)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// UnsubscribeFromLabel unsubscribes the authenticated user from a label to not\n// receive notifications from it. If the user is not subscribed to the label, the\n// status code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/labels.html#unsubscribe-from-a-label\nfunc (s *LabelsService) UnsubscribeFromLabel(pid interface{}, lid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels/%s/unsubscribe\", PathEscape(project), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// PromoteLabel Promotes a project label to a group label.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/labels.html#promote-a-project-label-to-a-group-label\nfunc (s *LabelsService) PromoteLabel(pid interface{}, lid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlabel, err := parseID(lid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/labels/%s/promote\", PathEscape(project), PathEscape(label))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "labels_test.go",
          "type": "blob",
          "size": 5.7099609375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestCreateLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"name\": \"MyLabel\", \"color\" : \"#11FF22\", \"priority\": 2}`)\n\t})\n\n\t// Create new label\n\tl := &CreateLabelOptions{\n\t\tName:     Ptr(\"MyLabel\"),\n\t\tColor:    Ptr(\"#11FF22\"),\n\t\tPriority: Ptr(2),\n\t}\n\tlabel, _, err := client.Labels.CreateLabel(\"1\", l)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &Label{ID: 1, Name: \"MyLabel\", Color: \"#11FF22\", Priority: 2}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"Labels.CreateLabel returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestDeleteLabelbyID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t// Delete label\n\t_, err := client.Labels.DeleteLabel(\"1\", \"1\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDeleteLabelbyName(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels/MyLabel\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t// Delete label\n\tlabel := &DeleteLabelOptions{\n\t\tName: Ptr(\"MyLabel\"),\n\t}\n\n\t_, err := client.Labels.DeleteLabel(\"1\", \"MyLabel\", label)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestUpdateLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels/MyLabel\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"name\": \"New Label\", \"color\" : \"#11FF23\" , \"description\":\"This is updated label\", \"priority\": 42}`)\n\t})\n\n\t// Update label\n\tl := &UpdateLabelOptions{\n\t\tNewName:     Ptr(\"New Label\"),\n\t\tColor:       Ptr(\"#11FF23\"),\n\t\tDescription: Ptr(\"This is updated label\"),\n\t\tPriority:    Ptr(42),\n\t}\n\n\tlabel, resp, err := client.Labels.UpdateLabel(\"1\", \"MyLabel\", l)\n\n\tif resp == nil {\n\t\tt.Fatal(err)\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Label{ID: 1, Name: \"New Label\", Color: \"#11FF23\", Description: \"This is updated label\", Priority: 42}\n\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"Labels.UpdateLabel returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestSubscribeToLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels/5/subscribe\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{  \"id\" : 5, \"name\" : \"kind/bug\", \"color\" : \"#d9534f\", \"description\": \"Bug reported by user\", \"open_issues_count\": 1, \"closed_issues_count\": 0, \"open_merge_requests_count\": 1, \"subscribed\": true,\"priority\": null}`)\n\t})\n\n\tlabel, _, err := client.Labels.SubscribeToLabel(\"1\", \"5\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\twant := &Label{ID: 5, Name: \"kind/bug\", Color: \"#d9534f\", Description: \"Bug reported by user\", OpenIssuesCount: 1, ClosedIssuesCount: 0, OpenMergeRequestsCount: 1, Subscribed: true}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"Labels.SubscribeToLabel returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestUnsubscribeFromLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels/5/unsubscribe\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t})\n\n\t_, err := client.Labels.UnsubscribeFromLabel(\"1\", \"5\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestListLabels(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{  \"id\" : 5, \"name\" : \"kind/bug\", \"color\" : \"#d9534f\", \"description\": \"Bug reported by user\", \"open_issues_count\": 1, \"closed_issues_count\": 0, \"open_merge_requests_count\": 1, \"subscribed\": true,\"priority\": null}]`)\n\t})\n\n\to := &ListLabelsOptions{\n\t\tListOptions: ListOptions{\n\t\t\tPage:    1,\n\t\t\tPerPage: 10,\n\t\t},\n\t}\n\tlabel, _, err := client.Labels.ListLabels(\"1\", o)\n\tif err != nil {\n\t\tt.Log(err.Error() == \"invalid ID type 1.1, the ID must be an int or a string\")\n\t}\n\twant := []*Label{{ID: 5, Name: \"kind/bug\", Color: \"#d9534f\", Description: \"Bug reported by user\", OpenIssuesCount: 1, ClosedIssuesCount: 0, OpenMergeRequestsCount: 1, Subscribed: true}}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"Labels.ListLabels returned %+v, want %+v\", label, want)\n\t}\n}\n\nfunc TestGetLabel(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/labels/5\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{  \"id\" : 5, \"name\" : \"kind/bug\", \"color\" : \"#d9534f\", \"description\": \"Bug reported by user\", \"open_issues_count\": 1, \"closed_issues_count\": 0, \"open_merge_requests_count\": 1, \"subscribed\": true,\"priority\": null}`)\n\t})\n\n\tlabel, _, err := client.Labels.GetLabel(\"1\", 5)\n\tif err != nil {\n\t\tt.Log(err)\n\t}\n\twant := &Label{ID: 5, Name: \"kind/bug\", Color: \"#d9534f\", Description: \"Bug reported by user\", OpenIssuesCount: 1, ClosedIssuesCount: 0, OpenMergeRequestsCount: 1, Subscribed: true}\n\tif !reflect.DeepEqual(want, label) {\n\t\tt.Errorf(\"Labels.GetLabel returned %+v, want %+v\", label, want)\n\t}\n}\n"
        },
        {
          "name": "license.go",
          "type": "blob",
          "size": 3.73828125,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// LicenseService handles communication with the license\n// related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/license.html\ntype LicenseService struct {\n\tclient *Client\n}\n\n// License represents a GitLab license.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/license.html\ntype License struct {\n\tID               int        `json:\"id\"`\n\tPlan             string     `json:\"plan\"`\n\tCreatedAt        *time.Time `json:\"created_at\"`\n\tStartsAt         *ISOTime   `json:\"starts_at\"`\n\tExpiresAt        *ISOTime   `json:\"expires_at\"`\n\tHistoricalMax    int        `json:\"historical_max\"`\n\tMaximumUserCount int        `json:\"maximum_user_count\"`\n\tExpired          bool       `json:\"expired\"`\n\tOverage          int        `json:\"overage\"`\n\tUserLimit        int        `json:\"user_limit\"`\n\tActiveUsers      int        `json:\"active_users\"`\n\tLicensee         struct {\n\t\tName    string `json:\"Name\"`\n\t\tCompany string `json:\"Company\"`\n\t\tEmail   string `json:\"Email\"`\n\t} `json:\"licensee\"`\n\t// Add on codes that may occur in legacy licenses that don't have a plan yet.\n\t// https://gitlab.com/gitlab-org/gitlab/-/blob/master/ee/app/models/license.rb\n\tAddOns struct {\n\t\tGitLabAuditorUser int `json:\"GitLab_Auditor_User\"`\n\t\tGitLabDeployBoard int `json:\"GitLab_DeployBoard\"`\n\t\tGitLabFileLocks   int `json:\"GitLab_FileLocks\"`\n\t\tGitLabGeo         int `json:\"GitLab_Geo\"`\n\t\tGitLabServiceDesk int `json:\"GitLab_ServiceDesk\"`\n\t} `json:\"add_ons\"`\n}\n\nfunc (l License) String() string {\n\treturn Stringify(l)\n}\n\n// GetLicense retrieves information about the current license.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/license.html#retrieve-information-about-the-current-license\nfunc (s *LicenseService) GetLicense(options ...RequestOptionFunc) (*License, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"license\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(License)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// AddLicenseOptions represents the available AddLicense() options.\n//\n// https://docs.gitlab.com/ee/api/license.html#add-a-new-license\ntype AddLicenseOptions struct {\n\tLicense *string `url:\"license\" json:\"license\"`\n}\n\n// AddLicense adds a new license.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/license.html#add-a-new-license\nfunc (s *LicenseService) AddLicense(opt *AddLicenseOptions, options ...RequestOptionFunc) (*License, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"license\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(License)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// DeleteLicense deletes an existing license.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/license.html#delete-a-license\nfunc (s *LicenseService) DeleteLicense(licenseID int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"license/%d\", licenseID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "license_templates.go",
          "type": "blob",
          "size": 3.3876953125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// LicenseTemplate represents a license template.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/licenses.html\ntype LicenseTemplate struct {\n\tKey         string   `json:\"key\"`\n\tName        string   `json:\"name\"`\n\tNickname    string   `json:\"nickname\"`\n\tFeatured    bool     `json:\"featured\"`\n\tHTMLURL     string   `json:\"html_url\"`\n\tSourceURL   string   `json:\"source_url\"`\n\tDescription string   `json:\"description\"`\n\tConditions  []string `json:\"conditions\"`\n\tPermissions []string `json:\"permissions\"`\n\tLimitations []string `json:\"limitations\"`\n\tContent     string   `json:\"content\"`\n}\n\n// LicenseTemplatesService handles communication with the license templates\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/templates/licenses.html\ntype LicenseTemplatesService struct {\n\tclient *Client\n}\n\n// ListLicenseTemplatesOptions represents the available\n// ListLicenseTemplates() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/licenses.html#list-license-templates\ntype ListLicenseTemplatesOptions struct {\n\tListOptions\n\tPopular *bool `url:\"popular,omitempty\" json:\"popular,omitempty\"`\n}\n\n// ListLicenseTemplates get all license templates.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/licenses.html#list-license-templates\nfunc (s *LicenseTemplatesService) ListLicenseTemplates(opt *ListLicenseTemplatesOptions, options ...RequestOptionFunc) ([]*LicenseTemplate, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"templates/licenses\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar lts []*LicenseTemplate\n\tresp, err := s.client.Do(req, &lts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn lts, resp, nil\n}\n\n// GetLicenseTemplateOptions represents the available\n// GetLicenseTemplate() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/licenses.html#single-license-template\ntype GetLicenseTemplateOptions struct {\n\tProject  *string `url:\"project,omitempty\" json:\"project,omitempty\"`\n\tFullname *string `url:\"fullname,omitempty\" json:\"fullname,omitempty\"`\n}\n\n// GetLicenseTemplate get a single license template. You can pass parameters\n// to replace the license placeholder.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/templates/licenses.html#single-license-template\nfunc (s *LicenseTemplatesService) GetLicenseTemplate(template string, opt *GetLicenseTemplateOptions, options ...RequestOptionFunc) (*LicenseTemplate, *Response, error) {\n\tu := fmt.Sprintf(\"templates/licenses/%s\", template)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tlt := new(LicenseTemplate)\n\tresp, err := s.client.Do(req, lt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn lt, resp, nil\n}\n"
        },
        {
          "name": "license_templates_test.go",
          "type": "blob",
          "size": 4.677734375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestLicenseTemplatesService_ListLicenseTemplates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/licenses\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"key\": \"apache-2.0\",\n\t\t\t\t\t\"name\": \"Apache License 2.0\",\n\t\t\t\t\t\"nickname\": null,\n\t\t\t\t\t\"featured\": true,\n\t\t\t\t\t\"html_url\": \"http://choosealicense.com/licenses/apache-2.0/\",\n\t\t\t\t\t\"source_url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\",\n\t\t\t\t\t\"description\": \"A permissive license that also provides an express grant of patent rights from contributors to users.\",\n\t\t\t\t\t\"conditions\": [\n\t\t\t\t\t\t\"include-copyright\",\n\t\t\t\t\t\t\"document-changes\"\n\t\t\t\t\t],\n\t\t\t\t\t\"permissions\": [\n\t\t\t\t\t\t\"commercial-use\",\n\t\t\t\t\t\t\"modifications\",\n\t\t\t\t\t\t\"distribution\",\n\t\t\t\t\t\t\"patent-use\",\n\t\t\t\t\t\t\"private-use\"\n\t\t\t\t\t],\n\t\t\t\t\t\"limitations\": [\n\t\t\t\t\t\t\"trademark-use\",\n\t\t\t\t\t\t\"no-liability\"\n\t\t\t\t\t],\n\t\t\t\t\t\"content\": \"Apache License\\n Version 2.0, January 2004\\n [...]\"\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*LicenseTemplate{{\n\t\tKey:         \"apache-2.0\",\n\t\tName:        \"Apache License 2.0\",\n\t\tNickname:    \"\",\n\t\tFeatured:    true,\n\t\tHTMLURL:     \"http://choosealicense.com/licenses/apache-2.0/\",\n\t\tSourceURL:   \"http://www.apache.org/licenses/LICENSE-2.0.html\",\n\t\tDescription: \"A permissive license that also provides an express grant of patent rights from contributors to users.\",\n\t\tConditions:  []string{\"include-copyright\", \"document-changes\"},\n\t\tPermissions: []string{\"commercial-use\", \"modifications\", \"distribution\", \"patent-use\", \"private-use\"},\n\t\tLimitations: []string{\"trademark-use\", \"no-liability\"},\n\t\tContent:     \"Apache License\\n Version 2.0, January 2004\\n [...]\",\n\t}}\n\n\tlts, resp, err := client.LicenseTemplates.ListLicenseTemplates(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, lts)\n\n\tlts, resp, err = client.LicenseTemplates.ListLicenseTemplates(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, lts)\n}\n\nfunc TestLicenseTemplatesService_ListLicenseTemplates_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/licenses\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tlts, resp, err := client.LicenseTemplates.ListLicenseTemplates(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, lts)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestLicenseTemplatesService_GetLicenseTemplate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/templates/licenses/apache-2.0\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"apache-2.0\",\n\t\t\t\t\"name\": \"Apache License 2.0\",\n\t\t\t\t\"nickname\": null,\n\t\t\t\t\"featured\": true,\n\t\t\t\t\"html_url\": \"http://choosealicense.com/licenses/apache-2.0/\",\n\t\t\t\t\"source_url\": \"http://www.apache.org/licenses/LICENSE-2.0.html\",\n\t\t\t\t\"description\": \"A permissive license that also provides an express grant of patent rights from contributors to users.\",\n\t\t\t\t\"conditions\": [\n\t\t\t\t\t\"include-copyright\",\n\t\t\t\t\t\"document-changes\"\n\t\t\t\t],\n\t\t\t\t\"permissions\": [\n\t\t\t\t\t\"commercial-use\",\n\t\t\t\t\t\"modifications\",\n\t\t\t\t\t\"distribution\",\n\t\t\t\t\t\"patent-use\",\n\t\t\t\t\t\"private-use\"\n\t\t\t\t],\n\t\t\t\t\"limitations\": [\n\t\t\t\t\t\"trademark-use\",\n\t\t\t\t\t\"no-liability\"\n\t\t\t\t],\n\t\t\t\t\"content\": \"Apache License\\n Version 2.0, January 2004\\n [...]\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &LicenseTemplate{\n\t\tKey:         \"apache-2.0\",\n\t\tName:        \"Apache License 2.0\",\n\t\tNickname:    \"\",\n\t\tFeatured:    true,\n\t\tHTMLURL:     \"http://choosealicense.com/licenses/apache-2.0/\",\n\t\tSourceURL:   \"http://www.apache.org/licenses/LICENSE-2.0.html\",\n\t\tDescription: \"A permissive license that also provides an express grant of patent rights from contributors to users.\",\n\t\tConditions:  []string{\"include-copyright\", \"document-changes\"},\n\t\tPermissions: []string{\"commercial-use\", \"modifications\", \"distribution\", \"patent-use\", \"private-use\"},\n\t\tLimitations: []string{\"trademark-use\", \"no-liability\"},\n\t\tContent:     \"Apache License\\n Version 2.0, January 2004\\n [...]\",\n\t}\n\n\tlt, resp, err := client.LicenseTemplates.GetLicenseTemplate(\"apache-2.0\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, lt)\n\n\tlt, resp, err = client.LicenseTemplates.GetLicenseTemplate(\"apache-2.0\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, lt)\n\n\tlt, resp, err = client.LicenseTemplates.GetLicenseTemplate(\"mit\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, lt)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "license_test.go",
          "type": "blob",
          "size": 4.0126953125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestLicenseService_GetLicense(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/license\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"plan\": \"gold\",\n\t\t\t  \"historical_max\": 300,\n\t\t\t  \"maximum_user_count\": 300,\n\t\t\t  \"expired\": false,\n\t\t\t  \"overage\": 200,\n\t\t\t  \"user_limit\": 100,\n\t\t\t  \"active_users\": 300,\n\t\t\t  \"licensee\": {\n\t\t\t\t\"Name\": \"Venkatesh Thalluri\"\n\t\t\t  },\n\t\t\t  \"add_ons\": {\n\t\t\t\t\"GitLab_FileLocks\": 1,\n\t\t\t\t\"GitLab_Auditor_User\": 1\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &License{\n\t\tID:               2,\n\t\tPlan:             \"gold\",\n\t\tHistoricalMax:    300,\n\t\tMaximumUserCount: 300,\n\t\tExpired:          false,\n\t\tOverage:          200,\n\t\tUserLimit:        100,\n\t\tActiveUsers:      300,\n\t\tLicensee: struct {\n\t\t\tName    string `json:\"Name\"`\n\t\t\tCompany string `json:\"Company\"`\n\t\t\tEmail   string `json:\"Email\"`\n\t\t}{\n\t\t\tName:    \"Venkatesh Thalluri\",\n\t\t\tCompany: \"\",\n\t\t\tEmail:   \"\",\n\t\t},\n\t\tAddOns: struct {\n\t\t\tGitLabAuditorUser int `json:\"GitLab_Auditor_User\"`\n\t\t\tGitLabDeployBoard int `json:\"GitLab_DeployBoard\"`\n\t\t\tGitLabFileLocks   int `json:\"GitLab_FileLocks\"`\n\t\t\tGitLabGeo         int `json:\"GitLab_Geo\"`\n\t\t\tGitLabServiceDesk int `json:\"GitLab_ServiceDesk\"`\n\t\t}{\n\t\t\tGitLabAuditorUser: 1,\n\t\t\tGitLabDeployBoard: 0,\n\t\t\tGitLabFileLocks:   1,\n\t\t\tGitLabGeo:         0,\n\t\t\tGitLabServiceDesk: 0,\n\t\t},\n\t}\n\n\tl, resp, err := client.License.GetLicense()\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, l)\n}\n\nfunc TestLicenseService_GetLicense_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/license\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tl, resp, err := client.License.GetLicense()\n\trequire.Error(t, err)\n\trequire.Nil(t, l)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestLicenseService_AddLicense(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/license\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"plan\": \"gold\",\n\t\t\t  \"historical_max\": 300,\n\t\t\t  \"maximum_user_count\": 300,\n\t\t\t  \"expired\": false,\n\t\t\t  \"overage\": 200,\n\t\t\t  \"user_limit\": 100,\n\t\t\t  \"active_users\": 300,\n\t\t\t  \"licensee\": {\n\t\t\t\t\"Name\": \"Venkatesh Thalluri\"\n\t\t\t  },\n\t\t\t  \"add_ons\": {\n\t\t\t\t\"GitLab_FileLocks\": 1,\n\t\t\t\t\"GitLab_Auditor_User\": 1\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &License{\n\t\tID:               2,\n\t\tPlan:             \"gold\",\n\t\tHistoricalMax:    300,\n\t\tMaximumUserCount: 300,\n\t\tExpired:          false,\n\t\tOverage:          200,\n\t\tUserLimit:        100,\n\t\tActiveUsers:      300,\n\t\tLicensee: struct {\n\t\t\tName    string `json:\"Name\"`\n\t\t\tCompany string `json:\"Company\"`\n\t\t\tEmail   string `json:\"Email\"`\n\t\t}{\n\t\t\tName:    \"Venkatesh Thalluri\",\n\t\t\tCompany: \"\",\n\t\t\tEmail:   \"\",\n\t\t},\n\t\tAddOns: struct {\n\t\t\tGitLabAuditorUser int `json:\"GitLab_Auditor_User\"`\n\t\t\tGitLabDeployBoard int `json:\"GitLab_DeployBoard\"`\n\t\t\tGitLabFileLocks   int `json:\"GitLab_FileLocks\"`\n\t\t\tGitLabGeo         int `json:\"GitLab_Geo\"`\n\t\t\tGitLabServiceDesk int `json:\"GitLab_ServiceDesk\"`\n\t\t}{\n\t\t\tGitLabAuditorUser: 1,\n\t\t\tGitLabDeployBoard: 0,\n\t\t\tGitLabFileLocks:   1,\n\t\t\tGitLabGeo:         0,\n\t\t\tGitLabServiceDesk: 0,\n\t\t},\n\t}\n\n\tl, resp, err := client.License.AddLicense(nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, l)\n\n\tl, resp, err = client.License.AddLicense(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, l)\n}\n\nfunc TestLicenseService_AddLicense_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/license\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tl, resp, err := client.License.AddLicense(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, l)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "markdown.go",
          "type": "blob",
          "size": 1.3427734375,
          "content": "package gitlab\n\nimport \"net/http\"\n\n// MarkdownService handles communication with the markdown related methods of\n// the GitLab API.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/markdown.html\ntype MarkdownService struct {\n\tclient *Client\n}\n\n// Markdown represents a markdown document.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/markdown.html\ntype Markdown struct {\n\tHTML string `json:\"html\"`\n}\n\n// RenderOptions represents the available Render() options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/markdown.html#render-an-arbitrary-markdown-document\ntype RenderOptions struct {\n\tText                    *string `url:\"text,omitempty\" json:\"text,omitempty\"`\n\tGitlabFlavouredMarkdown *bool   `url:\"gfm,omitempty\" json:\"gfm,omitempty\"`\n\tProject                 *string `url:\"project,omitempty\" json:\"project,omitempty\"`\n}\n\n// Render an arbitrary markdown document.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/markdown.html#render-an-arbitrary-markdown-document\nfunc (s *MarkdownService) Render(opt *RenderOptions, options ...RequestOptionFunc) (*Markdown, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"markdown\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tmd := new(Markdown)\n\tresponse, err := s.client.Do(req, md)\n\tif err != nil {\n\t\treturn nil, response, err\n\t}\n\n\treturn md, response, nil\n}\n"
        },
        {
          "name": "markdown_test.go",
          "type": "blob",
          "size": 1.0185546875,
          "content": "package gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nconst markdownHTMLResponse = \"<h1>Testing</h1>\"\n\nfunc TestRender(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/markdown\", func(writer http.ResponseWriter, request *http.Request) {\n\t\ttestMethod(t, request, http.MethodPost)\n\t\twriter.WriteHeader(http.StatusOK)\n\t\tmarkdown := Markdown{HTML: markdownHTMLResponse}\n\t\tresp, _ := json.Marshal(markdown)\n\t\t_, _ = writer.Write(resp)\n\t})\n\n\topt := &RenderOptions{\n\t\tText:                    Ptr(\"# Testing\"),\n\t\tGitlabFlavouredMarkdown: Ptr(true),\n\t\tProject:                 Ptr(\"some/sub/group/project\"),\n\t}\n\tmarkdown, resp, err := client.Markdown.Render(opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Render returned error: %v\", err)\n\t}\n\n\tif resp.StatusCode != http.StatusOK {\n\t\tt.Fatalf(\"Render returned status, expected %q but got %q\", http.StatusOK, resp.Status)\n\t}\n\n\tif markdown.HTML != markdownHTMLResponse {\n\t\tt.Fatalf(\"Render returned wrong response, expected %q but got %q\",\n\t\t\tmarkdownHTMLResponse, markdown.HTML)\n\t}\n}\n"
        },
        {
          "name": "member_roles.go",
          "type": "blob",
          "size": 7.0341796875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// MemberRolesService handles communication with the member roles related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/member_roles.html\ntype MemberRolesService struct {\n\tclient *Client\n}\n\n// MemberRole represents a GitLab member role.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/member_roles.html\ntype MemberRole struct {\n\tID                         int              `json:\"id\"`\n\tName                       string           `json:\"name\"`\n\tDescription                string           `json:\"description,omitempty\"`\n\tGroupID                    int              `json:\"group_id\"`\n\tBaseAccessLevel            AccessLevelValue `json:\"base_access_level\"`\n\tAdminCICDVariables         bool             `json:\"admin_cicd_variables,omitempty\"`\n\tAdminComplianceFramework   bool             `json:\"admin_compliance_framework,omitempty\"`\n\tAdminGroupMembers          bool             `json:\"admin_group_member,omitempty\"`\n\tAdminMergeRequests         bool             `json:\"admin_merge_request,omitempty\"`\n\tAdminPushRules             bool             `json:\"admin_push_rules,omitempty\"`\n\tAdminTerraformState        bool             `json:\"admin_terraform_state,omitempty\"`\n\tAdminVulnerability         bool             `json:\"admin_vulnerability,omitempty\"`\n\tAdminWebHook               bool             `json:\"admin_web_hook,omitempty\"`\n\tArchiveProject             bool             `json:\"archive_project,omitempty\"`\n\tManageDeployTokens         bool             `json:\"manage_deploy_tokens,omitempty\"`\n\tManageGroupAccesToken      bool             `json:\"manage_group_access_tokens,omitempty\"`\n\tManageMergeRequestSettings bool             `json:\"manage_merge_request_settings,omitempty\"`\n\tManageProjectAccessToken   bool             `json:\"manage_project_access_tokens,omitempty\"`\n\tManageSecurityPolicyLink   bool             `json:\"manage_security_policy_link,omitempty\"`\n\tReadCode                   bool             `json:\"read_code,omitempty\"`\n\tReadRunners                bool             `json:\"read_runners,omitempty\"`\n\tReadDependency             bool             `json:\"read_dependency,omitempty\"`\n\tReadVulnerability          bool             `json:\"read_vulnerability,omitempty\"`\n\tRemoveGroup                bool             `json:\"remove_group,omitempty\"`\n\tRemoveProject              bool             `json:\"remove_project,omitempty\"`\n}\n\n// ListMemberRoles gets a list of member roles for a specified group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/member_roles.html#list-all-member-roles-of-a-group\nfunc (s *MemberRolesService) ListMemberRoles(gid interface{}, options ...RequestOptionFunc) ([]*MemberRole, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/member_roles\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mrs []*MemberRole\n\tresp, err := s.client.Do(req, &mrs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mrs, resp, nil\n}\n\n// CreateMemberRoleOptions represents the available CreateMemberRole() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/member_roles.html#add-a-member-role-to-a-group\ntype CreateMemberRoleOptions struct {\n\tName                       *string           `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tBaseAccessLevel            *AccessLevelValue `url:\"base_access_level,omitempty\" json:\"base_access_level,omitempty\"`\n\tDescription                *string           `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tAdminCICDVariables         *bool             `url:\"admin_cicd_variables\" json:\"admin_cicd_variables,omitempty\"`\n\tAdminComplianceFramework   *bool             `url:\"admin_compliance_framework\" json:\"admin_compliance_framework,omitempty\"`\n\tAdminGroupMembers          *bool             `url:\"admin_group_member\" json:\"admin_group_member,omitempty\"`\n\tAdminMergeRequest          *bool             `url:\"admin_merge_request,omitempty\" json:\"admin_merge_request,omitempty\"`\n\tAdminPushRules             *bool             `url:\"admin_push_rules\" json:\"admin_push_rules,omitempty\"`\n\tAdminTerraformState        *bool             `url:\"admin_terraform_state\" json:\"admin_terraform_state,omitempty\"`\n\tAdminVulnerability         *bool             `url:\"admin_vulnerability,omitempty\" json:\"admin_vulnerability,omitempty\"`\n\tAdminWebHook               *bool             `url:\"admin_web_hook\" json:\"admin_web_hook,omitempty\"`\n\tArchiveProject             *bool             `url:\"archive_project\" json:\"archive_project,omitempty\"`\n\tManageDeployTokens         *bool             `url:\"manage_deploy_tokens\" json:\"manage_deploy_tokens,omitempty\"`\n\tManageGroupAccesToken      *bool             `url:\"manage_group_access_tokens\" json:\"manage_group_access_tokens,omitempty\"`\n\tManageMergeRequestSettings *bool             `url:\"manage_merge_request_settings\" json:\"manage_merge_request_settings,omitempty\"`\n\tManageProjectAccessToken   *bool             `url:\"manage_project_access_tokens\" json:\"manage_project_access_tokens,omitempty\"`\n\tManageSecurityPolicyLink   *bool             `url:\"manage_security_policy_link\" json:\"manage_security_policy_link,omitempty\"`\n\tReadCode                   *bool             `url:\"read_code,omitempty\" json:\"read_code,omitempty\"`\n\tReadRunners                *bool             `url:\"read_runners\" json:\"read_runners,omitempty\"`\n\tReadDependency             *bool             `url:\"read_dependency,omitempty\" json:\"read_dependency,omitempty\"`\n\tReadVulnerability          *bool             `url:\"read_vulnerability,omitempty\" json:\"read_vulnerability,omitempty\"`\n\tRemoveGroup                *bool             `url:\"remove_group\" json:\"remove_group,omitempty\"`\n\tRemoveProject              *bool             `url:\"remove_project\" json:\"remove_project,omitempty\"`\n}\n\n// CreateMemberRole creates a new member role for a specified group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/member_roles.html#add-a-member-role-to-a-group\nfunc (s *MemberRolesService) CreateMemberRole(gid interface{}, opt *CreateMemberRoleOptions, options ...RequestOptionFunc) (*MemberRole, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/member_roles\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tmr := new(MemberRole)\n\tresp, err := s.client.Do(req, mr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mr, resp, nil\n}\n\n// DeleteMemberRole deletes a member role from a specified group.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/member_roles.html#remove-member-role-of-a-group\nfunc (s *MemberRolesService) DeleteMemberRole(gid interface{}, memberRole int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/member_roles/%d\", PathEscape(group), memberRole)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "member_roles_test.go",
          "type": "blob",
          "size": 3.6640625,
          "content": "package gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestListMemberRoles(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/groups/1/member_roles\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_member_roles.json\")\n\t})\n\n\tmemberRoles, _, err := client.MemberRolesService.ListMemberRoles(1)\n\trequire.NoError(t, err)\n\n\twant := []*MemberRole{\n\t\t{\n\t\t\tID:              1,\n\t\t\tName:            \"GuestCodeReader\",\n\t\t\tDescription:     \"A Guest user that can read code\",\n\t\t\tGroupID:         1,\n\t\t\tBaseAccessLevel: 10, // Guest Base Level\n\t\t\tReadCode:        true,\n\t\t},\n\t\t{\n\t\t\tID:                2,\n\t\t\tName:              \"GuestVulnerabilityReader\",\n\t\t\tDescription:       \"A Guest user that can read vulnerabilities\",\n\t\t\tGroupID:           1,\n\t\t\tBaseAccessLevel:   10, // Guest Base Level\n\t\t\tReadVulnerability: true,\n\t\t},\n\t}\n\n\trequire.Equal(t, want, memberRoles)\n}\n\nfunc TestCreateMemberRole(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/groups/84/member_roles\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_member_role.json\")\n\t})\n\n\tmemberRole, _, err := client.MemberRolesService.CreateMemberRole(84, &CreateMemberRoleOptions{\n\t\tName:                       Ptr(\"Custom guest\"),\n\t\tBaseAccessLevel:            Ptr(GuestPermissions),\n\t\tDescription:                Ptr(\"a sample custom role\"),\n\t\tAdminCICDVariables:         Ptr(false),\n\t\tAdminComplianceFramework:   Ptr(false),\n\t\tAdminGroupMembers:          Ptr(false),\n\t\tAdminMergeRequest:          Ptr(false),\n\t\tAdminPushRules:             Ptr(false),\n\t\tAdminTerraformState:        Ptr(false),\n\t\tAdminVulnerability:         Ptr(false),\n\t\tAdminWebHook:               Ptr(false),\n\t\tArchiveProject:             Ptr(false),\n\t\tManageDeployTokens:         Ptr(false),\n\t\tManageGroupAccesToken:      Ptr(false),\n\t\tManageMergeRequestSettings: Ptr(false),\n\t\tManageProjectAccessToken:   Ptr(false),\n\t\tManageSecurityPolicyLink:   Ptr(false),\n\t\tReadCode:                   Ptr(true),\n\t\tReadRunners:                Ptr(false),\n\t\tReadDependency:             Ptr(false),\n\t\tReadVulnerability:          Ptr(false),\n\t\tRemoveGroup:                Ptr(false),\n\t\tRemoveProject:              Ptr(false),\n\t})\n\trequire.NoError(t, err)\n\n\twant := &MemberRole{\n\t\tID:                         3,\n\t\tName:                       \"Custom guest\",\n\t\tDescription:                \"a sample custom role\",\n\t\tBaseAccessLevel:            GuestPermissions,\n\t\tGroupID:                    84,\n\t\tAdminCICDVariables:         false,\n\t\tAdminComplianceFramework:   false,\n\t\tAdminGroupMembers:          false,\n\t\tAdminMergeRequests:         false,\n\t\tAdminPushRules:             false,\n\t\tAdminTerraformState:        false,\n\t\tAdminVulnerability:         false,\n\t\tAdminWebHook:               false,\n\t\tArchiveProject:             false,\n\t\tManageDeployTokens:         false,\n\t\tManageGroupAccesToken:      false,\n\t\tManageMergeRequestSettings: false,\n\t\tManageProjectAccessToken:   false,\n\t\tManageSecurityPolicyLink:   false,\n\t\tReadCode:                   true,\n\t\tReadRunners:                false,\n\t\tReadDependency:             false,\n\t\tReadVulnerability:          false,\n\t\tRemoveGroup:                false,\n\t\tRemoveProject:              false,\n\t}\n\n\trequire.Equal(t, want, memberRole)\n}\n\nfunc TestDeleteMemberRole(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/groups/1/member_roles/2\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.MemberRolesService.DeleteMemberRole(1, 2)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "merge_request_approvals.go",
          "type": "blob",
          "size": 16.6865234375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// MergeRequestApprovalsService handles communication with the merge request\n// approvals related methods of the GitLab API. This includes reading/updating\n// approval settings and approve/unapproving merge requests\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/merge_request_approvals.html\ntype MergeRequestApprovalsService struct {\n\tclient *Client\n}\n\n// MergeRequestApprovals represents GitLab merge request approvals.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#merge-request-level-mr-approvals\ntype MergeRequestApprovals struct {\n\tID                             int                          `json:\"id\"`\n\tIID                            int                          `json:\"iid\"`\n\tProjectID                      int                          `json:\"project_id\"`\n\tTitle                          string                       `json:\"title\"`\n\tDescription                    string                       `json:\"description\"`\n\tState                          string                       `json:\"state\"`\n\tCreatedAt                      *time.Time                   `json:\"created_at\"`\n\tUpdatedAt                      *time.Time                   `json:\"updated_at\"`\n\tMergeStatus                    string                       `json:\"merge_status\"`\n\tApproved                       bool                         `json:\"approved\"`\n\tApprovalsBeforeMerge           int                          `json:\"approvals_before_merge\"`\n\tApprovalsRequired              int                          `json:\"approvals_required\"`\n\tApprovalsLeft                  int                          `json:\"approvals_left\"`\n\tRequirePasswordToApprove       bool                         `json:\"require_password_to_approve\"`\n\tApprovedBy                     []*MergeRequestApproverUser  `json:\"approved_by\"`\n\tSuggestedApprovers             []*BasicUser                 `json:\"suggested_approvers\"`\n\tApprovers                      []*MergeRequestApproverUser  `json:\"approvers\"`\n\tApproverGroups                 []*MergeRequestApproverGroup `json:\"approver_groups\"`\n\tUserHasApproved                bool                         `json:\"user_has_approved\"`\n\tUserCanApprove                 bool                         `json:\"user_can_approve\"`\n\tApprovalRulesLeft              []*MergeRequestApprovalRule  `json:\"approval_rules_left\"`\n\tHasApprovalRules               bool                         `json:\"has_approval_rules\"`\n\tMergeRequestApproversAvailable bool                         `json:\"merge_request_approvers_available\"`\n\tMultipleApprovalRulesAvailable bool                         `json:\"multiple_approval_rules_available\"`\n}\n\nfunc (m MergeRequestApprovals) String() string {\n\treturn Stringify(m)\n}\n\n// MergeRequestApproverGroup  represents GitLab project level merge request approver group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#project-level-mr-approvals\ntype MergeRequestApproverGroup struct {\n\tGroup struct {\n\t\tID                   int    `json:\"id\"`\n\t\tName                 string `json:\"name\"`\n\t\tPath                 string `json:\"path\"`\n\t\tDescription          string `json:\"description\"`\n\t\tVisibility           string `json:\"visibility\"`\n\t\tAvatarURL            string `json:\"avatar_url\"`\n\t\tWebURL               string `json:\"web_url\"`\n\t\tFullName             string `json:\"full_name\"`\n\t\tFullPath             string `json:\"full_path\"`\n\t\tLFSEnabled           bool   `json:\"lfs_enabled\"`\n\t\tRequestAccessEnabled bool   `json:\"request_access_enabled\"`\n\t}\n}\n\n// MergeRequestApprovalRule represents a GitLab merge request approval rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-merge-request-level-rules\ntype MergeRequestApprovalRule struct {\n\tID                   int                  `json:\"id\"`\n\tName                 string               `json:\"name\"`\n\tRuleType             string               `json:\"rule_type\"`\n\tReportType           string               `json:\"report_type\"`\n\tEligibleApprovers    []*BasicUser         `json:\"eligible_approvers\"`\n\tApprovalsRequired    int                  `json:\"approvals_required\"`\n\tSourceRule           *ProjectApprovalRule `json:\"source_rule\"`\n\tUsers                []*BasicUser         `json:\"users\"`\n\tGroups               []*Group             `json:\"groups\"`\n\tContainsHiddenGroups bool                 `json:\"contains_hidden_groups\"`\n\tSection              string               `json:\"section\"`\n\tApprovedBy           []*BasicUser         `json:\"approved_by\"`\n\tApproved             bool                 `json:\"approved\"`\n}\n\n// MergeRequestApprovalState represents a GitLab merge request approval state.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-the-approval-state-of-merge-requests\ntype MergeRequestApprovalState struct {\n\tApprovalRulesOverwritten bool                        `json:\"approval_rules_overwritten\"`\n\tRules                    []*MergeRequestApprovalRule `json:\"rules\"`\n}\n\n// String is a stringify for MergeRequestApprovalRule\nfunc (s MergeRequestApprovalRule) String() string {\n\treturn Stringify(s)\n}\n\n// MergeRequestApproverUser  represents GitLab project level merge request approver user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#project-level-mr-approvals\ntype MergeRequestApproverUser struct {\n\tUser *BasicUser\n}\n\n// ApproveMergeRequestOptions represents the available ApproveMergeRequest() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#approve-merge-request\ntype ApproveMergeRequestOptions struct {\n\tSHA *string `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n}\n\n// ApproveMergeRequest approves a merge request on GitLab. If a non-empty sha\n// is provided then it must match the sha at the HEAD of the MR.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#approve-merge-request\nfunc (s *MergeRequestApprovalsService) ApproveMergeRequest(pid interface{}, mr int, opt *ApproveMergeRequestOptions, options ...RequestOptionFunc) (*MergeRequestApprovals, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approve\", PathEscape(project), mr)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequestApprovals)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// UnapproveMergeRequest unapproves a previously approved merge request on GitLab.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#unapprove-merge-request\nfunc (s *MergeRequestApprovalsService) UnapproveMergeRequest(pid interface{}, mr int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/unapprove\", PathEscape(project), mr)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ResetApprovalsOfMergeRequest clear all approvals of merge request on GitLab.\n// Available only for bot users based on project or group tokens.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#reset-approvals-of-a-merge-request\nfunc (s *MergeRequestApprovalsService) ResetApprovalsOfMergeRequest(pid interface{}, mr int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/reset_approvals\", PathEscape(project), mr)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ChangeMergeRequestApprovalConfigurationOptions represents the available\n// ChangeMergeRequestApprovalConfiguration() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-approval-configuration-deprecated\ntype ChangeMergeRequestApprovalConfigurationOptions struct {\n\tApprovalsRequired *int `url:\"approvals_required,omitempty\" json:\"approvals_required,omitempty\"`\n}\n\n// GetConfiguration shows information about single merge request approvals\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-configuration-1\nfunc (s *MergeRequestApprovalsService) GetConfiguration(pid interface{}, mr int, options ...RequestOptionFunc) (*MergeRequestApprovals, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approvals\", PathEscape(project), mr)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequestApprovals)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// ChangeApprovalConfiguration updates the approval configuration of a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-approval-configuration-deprecated\nfunc (s *MergeRequestApprovalsService) ChangeApprovalConfiguration(pid interface{}, mergeRequest int, opt *ChangeMergeRequestApprovalConfigurationOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approvals\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// ChangeMergeRequestAllowedApproversOptions represents the available\n// ChangeMergeRequestAllowedApprovers() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-allowed-approvers-for-merge-request\ntype ChangeMergeRequestAllowedApproversOptions struct {\n\tApproverIDs      []int `url:\"approver_ids\" json:\"approver_ids\"`\n\tApproverGroupIDs []int `url:\"approver_group_ids\" json:\"approver_group_ids\"`\n}\n\n// ChangeAllowedApprovers updates the approvers for a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-allowed-approvers-for-merge-request\nfunc (s *MergeRequestApprovalsService) ChangeAllowedApprovers(pid interface{}, mergeRequest int, opt *ChangeMergeRequestAllowedApproversOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approvers\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// GetApprovalRules requests information about a merge request’s approval rules\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-merge-request-level-rules\nfunc (s *MergeRequestApprovalsService) GetApprovalRules(pid interface{}, mergeRequest int, options ...RequestOptionFunc) ([]*MergeRequestApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approval_rules\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar par []*MergeRequestApprovalRule\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// GetApprovalState requests information about a merge request’s approval state\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-the-approval-state-of-merge-requests\nfunc (s *MergeRequestApprovalsService) GetApprovalState(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*MergeRequestApprovalState, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approval_state\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pas *MergeRequestApprovalState\n\tresp, err := s.client.Do(req, &pas)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pas, resp, nil\n}\n\n// CreateMergeRequestApprovalRuleOptions represents the available CreateApprovalRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#create-merge-request-level-rule\ntype CreateMergeRequestApprovalRuleOptions struct {\n\tName                  *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tApprovalsRequired     *int    `url:\"approvals_required,omitempty\" json:\"approvals_required,omitempty\"`\n\tApprovalProjectRuleID *int    `url:\"approval_project_rule_id,omitempty\" json:\"approval_project_rule_id,omitempty\"`\n\tUserIDs               *[]int  `url:\"user_ids,omitempty\" json:\"user_ids,omitempty\"`\n\tGroupIDs              *[]int  `url:\"group_ids,omitempty\" json:\"group_ids,omitempty\"`\n}\n\n// CreateApprovalRule creates a new MR level approval rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#create-merge-request-level-rule\nfunc (s *MergeRequestApprovalsService) CreateApprovalRule(pid interface{}, mergeRequest int, opt *CreateMergeRequestApprovalRuleOptions, options ...RequestOptionFunc) (*MergeRequestApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approval_rules\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpar := new(MergeRequestApprovalRule)\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// UpdateMergeRequestApprovalRuleOptions represents the available UpdateApprovalRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#update-merge-request-level-rule\ntype UpdateMergeRequestApprovalRuleOptions struct {\n\tName              *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tApprovalsRequired *int    `url:\"approvals_required,omitempty\" json:\"approvals_required,omitempty\"`\n\tUserIDs           *[]int  `url:\"user_ids,omitempty\" json:\"user_ids,omitempty\"`\n\tGroupIDs          *[]int  `url:\"group_ids,omitempty\" json:\"group_ids,omitempty\"`\n}\n\n// UpdateApprovalRule updates an existing approval rule with new options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#update-merge-request-level-rule\nfunc (s *MergeRequestApprovalsService) UpdateApprovalRule(pid interface{}, mergeRequest int, approvalRule int, opt *UpdateMergeRequestApprovalRuleOptions, options ...RequestOptionFunc) (*MergeRequestApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approval_rules/%d\", PathEscape(project), mergeRequest, approvalRule)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpar := new(MergeRequestApprovalRule)\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// DeleteApprovalRule deletes a mr level approval rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#delete-merge-request-level-rule\nfunc (s *MergeRequestApprovalsService) DeleteApprovalRule(pid interface{}, mergeRequest int, approvalRule int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approval_rules/%d\", PathEscape(project), mergeRequest, approvalRule)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "merge_request_approvals_test.go",
          "type": "blob",
          "size": 11.0927734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetApprovalState(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/approval_state\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"approval_rules_overwritten\": true,\n\t\t\t\"rules\": [\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"security\",\n\t\t\t\t\"rule_type\": \"regular\",\n\t\t\t\t\"eligible_approvers\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 50,\n\t\t\t\t\t\t\"name\": \"Group Member 1\",\n\t\t\t\t\t\t\"username\": \"group_member_1\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/group_member_1\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"approvals_required\": 3,\n\t\t\t\t\"source_rule\": null,\n\t\t\t\t\"users\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"groups\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"group1\",\n\t\t\t\t\t\t\"path\": \"group1\",\n\t\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\t\t\"lfs_enabled\": false,\n\t\t\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\t\t\"web_url\": \"http://localhost/groups/group1\",\n\t\t\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\t\t\"full_name\": \"group1\",\n\t\t\t\t\t\t\"full_path\": \"group1\",\n\t\t\t\t\t\t\"parent_id\": null,\n\t\t\t\t\t\t\"ldap_cn\": null,\n\t\t\t\t\t\t\"ldap_access\": null\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"contains_hidden_groups\": false,\n\t\t\t\t\"section\": \"test\",\n\t\t\t\t\"approved_by\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"approved\": false\n\t\t\t}\n\t\t]\n\t\t}`)\n\t})\n\n\tapprovals, _, err := client.MergeRequestApprovals.GetApprovalState(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"MergeRequestApprovals.GetApprovalState returned error: %v\", err)\n\t}\n\n\twant := &MergeRequestApprovalState{\n\t\tApprovalRulesOverwritten: true,\n\t\tRules: []*MergeRequestApprovalRule{\n\t\t\t{\n\t\t\t\tID:       1,\n\t\t\t\tName:     \"security\",\n\t\t\t\tRuleType: \"regular\",\n\t\t\t\tEligibleApprovers: []*BasicUser{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:        5,\n\t\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\t\tState:     \"active\",\n\t\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tID:        50,\n\t\t\t\t\t\tName:      \"Group Member 1\",\n\t\t\t\t\t\tUsername:  \"group_member_1\",\n\t\t\t\t\t\tState:     \"active\",\n\t\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\tWebURL:    \"http://localhost/group_member_1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tApprovalsRequired: 3,\n\t\t\t\tUsers: []*BasicUser{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:        5,\n\t\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\t\tState:     \"active\",\n\t\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tGroups: []*Group{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:                   5,\n\t\t\t\t\t\tName:                 \"group1\",\n\t\t\t\t\t\tPath:                 \"group1\",\n\t\t\t\t\t\tDescription:          \"\",\n\t\t\t\t\t\tVisibility:           PublicVisibility,\n\t\t\t\t\t\tLFSEnabled:           false,\n\t\t\t\t\t\tAvatarURL:            \"\",\n\t\t\t\t\t\tWebURL:               \"http://localhost/groups/group1\",\n\t\t\t\t\t\tRequestAccessEnabled: false,\n\t\t\t\t\t\tFullName:             \"group1\",\n\t\t\t\t\t\tFullPath:             \"group1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tSection: \"test\",\n\t\t\t\tApprovedBy: []*BasicUser{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:        5,\n\t\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\t\tState:     \"active\",\n\t\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tApproved: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"MergeRequestApprovals.GetApprovalState returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestGetApprovalRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/approval_rules\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"security\",\n\t\t\t\t\"rule_type\": \"regular\",\n\t\t\t\t\"eligible_approvers\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 50,\n\t\t\t\t\t\t\"name\": \"Group Member 1\",\n\t\t\t\t\t\t\"username\": \"group_member_1\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/group_member_1\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"approvals_required\": 3,\n\t\t\t\t\"source_rule\": null,\n\t\t\t\t\"users\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"groups\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"group1\",\n\t\t\t\t\t\t\"path\": \"group1\",\n\t\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\t\t\"lfs_enabled\": false,\n\t\t\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\t\t\"web_url\": \"http://localhost/groups/group1\",\n\t\t\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\t\t\"full_name\": \"group1\",\n\t\t\t\t\t\t\"full_path\": \"group1\",\n\t\t\t\t\t\t\"parent_id\": null,\n\t\t\t\t\t\t\"ldap_cn\": null,\n\t\t\t\t\t\t\"ldap_access\": null\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"contains_hidden_groups\": false,\n\t\t\t\t\"section\": \"test\"\n\t\t\t}\n\t\t]`)\n\t})\n\n\tapprovals, _, err := client.MergeRequestApprovals.GetApprovalRules(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"MergeRequestApprovals.GetApprovalRules returned error: %v\", err)\n\t}\n\n\twant := []*MergeRequestApprovalRule{\n\t\t{\n\t\t\tID:       1,\n\t\t\tName:     \"security\",\n\t\t\tRuleType: \"regular\",\n\t\t\tEligibleApprovers: []*BasicUser{\n\t\t\t\t{\n\t\t\t\t\tID:        5,\n\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:        50,\n\t\t\t\t\tName:      \"Group Member 1\",\n\t\t\t\t\tUsername:  \"group_member_1\",\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\tWebURL:    \"http://localhost/group_member_1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tApprovalsRequired: 3,\n\t\t\tUsers: []*BasicUser{\n\t\t\t\t{\n\t\t\t\t\tID:        5,\n\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tGroups: []*Group{\n\t\t\t\t{\n\t\t\t\t\tID:                   5,\n\t\t\t\t\tName:                 \"group1\",\n\t\t\t\t\tPath:                 \"group1\",\n\t\t\t\t\tDescription:          \"\",\n\t\t\t\t\tVisibility:           PublicVisibility,\n\t\t\t\t\tLFSEnabled:           false,\n\t\t\t\t\tAvatarURL:            \"\",\n\t\t\t\t\tWebURL:               \"http://localhost/groups/group1\",\n\t\t\t\t\tRequestAccessEnabled: false,\n\t\t\t\t\tFullName:             \"group1\",\n\t\t\t\t\tFullPath:             \"group1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tSection: \"test\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"MergeRequestApprovals.GetApprovalRules returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestCreateApprovalRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/approval_rules\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"security\",\n\t\t\t\"rule_type\": \"regular\",\n\t\t\t\"eligible_approvers\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": 50,\n\t\t\t\t\t\"name\": \"Group Member 1\",\n\t\t\t\t\t\"username\": \"group_member_1\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/group_member_1\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"approvals_required\": 3,\n\t\t\t\"source_rule\": null,\n\t\t\t\"users\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"groups\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"group1\",\n\t\t\t\t\t\"path\": \"group1\",\n\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\t\"lfs_enabled\": false,\n\t\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\t\"web_url\": \"http://localhost/groups/group1\",\n\t\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\t\"full_name\": \"group1\",\n\t\t\t\t\t\"full_path\": \"group1\",\n\t\t\t\t\t\"parent_id\": null,\n\t\t\t\t\t\"ldap_cn\": null,\n\t\t\t\t\t\"ldap_access\": null\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"contains_hidden_groups\": false\n\t\t}`)\n\t})\n\n\topt := &CreateMergeRequestApprovalRuleOptions{\n\t\tName:              Ptr(\"security\"),\n\t\tApprovalsRequired: Ptr(3),\n\t\tUserIDs:           &[]int{5, 50},\n\t\tGroupIDs:          &[]int{5},\n\t}\n\n\trule, _, err := client.MergeRequestApprovals.CreateApprovalRule(1, 1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"MergeRequestApprovals.CreateApprovalRule returned error: %v\", err)\n\t}\n\n\twant := &MergeRequestApprovalRule{\n\t\tID:       1,\n\t\tName:     \"security\",\n\t\tRuleType: \"regular\",\n\t\tEligibleApprovers: []*BasicUser{\n\t\t\t{\n\t\t\t\tID:        5,\n\t\t\t\tName:      \"John Doe\",\n\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:        50,\n\t\t\t\tName:      \"Group Member 1\",\n\t\t\t\tUsername:  \"group_member_1\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/group_member_1\",\n\t\t\t},\n\t\t},\n\t\tApprovalsRequired: 3,\n\t\tUsers: []*BasicUser{\n\t\t\t{\n\t\t\t\tID:        5,\n\t\t\t\tName:      \"John Doe\",\n\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t},\n\t\t},\n\t\tGroups: []*Group{\n\t\t\t{\n\t\t\t\tID:                   5,\n\t\t\t\tName:                 \"group1\",\n\t\t\t\tPath:                 \"group1\",\n\t\t\t\tDescription:          \"\",\n\t\t\t\tVisibility:           PublicVisibility,\n\t\t\t\tLFSEnabled:           false,\n\t\t\t\tAvatarURL:            \"\",\n\t\t\t\tWebURL:               \"http://localhost/groups/group1\",\n\t\t\t\tRequestAccessEnabled: false,\n\t\t\t\tFullName:             \"group1\",\n\t\t\t\tFullPath:             \"group1\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"MergeRequestApprovals.CreateApprovalRule returned %+v, want %+v\", rule, want)\n\t}\n}\n"
        },
        {
          "name": "merge_requests.go",
          "type": "blob",
          "size": 44.6708984375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// MergeRequestsService handles communication with the merge requests related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/merge_requests.html\ntype MergeRequestsService struct {\n\tclient    *Client\n\ttimeStats *timeStatsService\n}\n\n// MergeRequest represents a GitLab merge request.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/merge_requests.html\ntype MergeRequest struct {\n\tID                        int                 `json:\"id\"`\n\tIID                       int                 `json:\"iid\"`\n\tTargetBranch              string              `json:\"target_branch\"`\n\tSourceBranch              string              `json:\"source_branch\"`\n\tProjectID                 int                 `json:\"project_id\"`\n\tTitle                     string              `json:\"title\"`\n\tState                     string              `json:\"state\"`\n\tCreatedAt                 *time.Time          `json:\"created_at\"`\n\tUpdatedAt                 *time.Time          `json:\"updated_at\"`\n\tUpvotes                   int                 `json:\"upvotes\"`\n\tDownvotes                 int                 `json:\"downvotes\"`\n\tAuthor                    *BasicUser          `json:\"author\"`\n\tAssignee                  *BasicUser          `json:\"assignee\"`\n\tAssignees                 []*BasicUser        `json:\"assignees\"`\n\tReviewers                 []*BasicUser        `json:\"reviewers\"`\n\tSourceProjectID           int                 `json:\"source_project_id\"`\n\tTargetProjectID           int                 `json:\"target_project_id\"`\n\tLabels                    Labels              `json:\"labels\"`\n\tLabelDetails              []*LabelDetails     `json:\"label_details\"`\n\tDescription               string              `json:\"description\"`\n\tDraft                     bool                `json:\"draft\"`\n\tWorkInProgress            bool                `json:\"work_in_progress\"`\n\tMilestone                 *Milestone          `json:\"milestone\"`\n\tMergeWhenPipelineSucceeds bool                `json:\"merge_when_pipeline_succeeds\"`\n\tDetailedMergeStatus       string              `json:\"detailed_merge_status\"`\n\tMergeError                string              `json:\"merge_error\"`\n\tMergedBy                  *BasicUser          `json:\"merged_by\"`\n\tMergedAt                  *time.Time          `json:\"merged_at\"`\n\tClosedBy                  *BasicUser          `json:\"closed_by\"`\n\tClosedAt                  *time.Time          `json:\"closed_at\"`\n\tSubscribed                bool                `json:\"subscribed\"`\n\tSHA                       string              `json:\"sha\"`\n\tMergeCommitSHA            string              `json:\"merge_commit_sha\"`\n\tSquashCommitSHA           string              `json:\"squash_commit_sha\"`\n\tUserNotesCount            int                 `json:\"user_notes_count\"`\n\tChangesCount              string              `json:\"changes_count\"`\n\tShouldRemoveSourceBranch  bool                `json:\"should_remove_source_branch\"`\n\tForceRemoveSourceBranch   bool                `json:\"force_remove_source_branch\"`\n\tAllowCollaboration        bool                `json:\"allow_collaboration\"`\n\tWebURL                    string              `json:\"web_url\"`\n\tReferences                *IssueReferences    `json:\"references\"`\n\tDiscussionLocked          bool                `json:\"discussion_locked\"`\n\tChanges                   []*MergeRequestDiff `json:\"changes\"`\n\tUser                      struct {\n\t\tCanMerge bool `json:\"can_merge\"`\n\t} `json:\"user\"`\n\tTimeStats    *TimeStats    `json:\"time_stats\"`\n\tSquash       bool          `json:\"squash\"`\n\tPipeline     *PipelineInfo `json:\"pipeline\"`\n\tHeadPipeline *Pipeline     `json:\"head_pipeline\"`\n\tDiffRefs     struct {\n\t\tBaseSha  string `json:\"base_sha\"`\n\t\tHeadSha  string `json:\"head_sha\"`\n\t\tStartSha string `json:\"start_sha\"`\n\t} `json:\"diff_refs\"`\n\tDivergedCommitsCount        int                    `json:\"diverged_commits_count\"`\n\tRebaseInProgress            bool                   `json:\"rebase_in_progress\"`\n\tApprovalsBeforeMerge        int                    `json:\"approvals_before_merge\"`\n\tReference                   string                 `json:\"reference\"`\n\tFirstContribution           bool                   `json:\"first_contribution\"`\n\tTaskCompletionStatus        *TasksCompletionStatus `json:\"task_completion_status\"`\n\tHasConflicts                bool                   `json:\"has_conflicts\"`\n\tBlockingDiscussionsResolved bool                   `json:\"blocking_discussions_resolved\"`\n\tOverflow                    bool                   `json:\"overflow\"`\n\n\t// Deprecated: This parameter is replaced by DetailedMergeStatus in GitLab 15.6.\n\tMergeStatus string `json:\"merge_status\"`\n}\n\nfunc (m MergeRequest) String() string {\n\treturn Stringify(m)\n}\n\nfunc (m *MergeRequest) UnmarshalJSON(data []byte) error {\n\ttype alias MergeRequest\n\n\traw := make(map[string]interface{})\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlabelDetails, ok := raw[\"labels\"].([]interface{})\n\tif ok && len(labelDetails) > 0 {\n\t\t// We only want to change anything if we got label details.\n\t\tif _, ok := labelDetails[0].(map[string]interface{}); !ok {\n\t\t\treturn json.Unmarshal(data, (*alias)(m))\n\t\t}\n\n\t\tlabels := make([]interface{}, len(labelDetails))\n\t\tfor i, details := range labelDetails {\n\t\t\tlabels[i] = details.(map[string]interface{})[\"name\"]\n\t\t}\n\n\t\t// Set the correct values\n\t\traw[\"labels\"] = labels\n\t\traw[\"label_details\"] = labelDetails\n\n\t\tdata, err = json.Marshal(raw)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn json.Unmarshal(data, (*alias)(m))\n}\n\n// MergeRequestDiff represents Gitlab merge request diff.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-request-diffs\ntype MergeRequestDiff struct {\n\tOldPath     string `json:\"old_path\"`\n\tNewPath     string `json:\"new_path\"`\n\tAMode       string `json:\"a_mode\"`\n\tBMode       string `json:\"b_mode\"`\n\tDiff        string `json:\"diff\"`\n\tNewFile     bool   `json:\"new_file\"`\n\tRenamedFile bool   `json:\"renamed_file\"`\n\tDeletedFile bool   `json:\"deleted_file\"`\n}\n\n// MergeRequestDiffVersion represents Gitlab merge request version.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-merge-request-diff-versions\ntype MergeRequestDiffVersion struct {\n\tID             int        `json:\"id\"`\n\tHeadCommitSHA  string     `json:\"head_commit_sha,omitempty\"`\n\tBaseCommitSHA  string     `json:\"base_commit_sha,omitempty\"`\n\tStartCommitSHA string     `json:\"start_commit_sha,omitempty\"`\n\tCreatedAt      *time.Time `json:\"created_at,omitempty\"`\n\tMergeRequestID int        `json:\"merge_request_id,omitempty\"`\n\tState          string     `json:\"state,omitempty\"`\n\tRealSize       string     `json:\"real_size,omitempty\"`\n\tCommits        []*Commit  `json:\"commits,omitempty\"`\n\tDiffs          []*Diff    `json:\"diffs,omitempty\"`\n}\n\nfunc (m MergeRequestDiffVersion) String() string {\n\treturn Stringify(m)\n}\n\n// ListMergeRequestsOptions represents the available ListMergeRequests()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-requests\ntype ListMergeRequestsOptions struct {\n\tListOptions\n\tApproved               *string           `url:\"approved,omitempty\" json:\"approved,omitempty\"`\n\tState                  *string           `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tOrderBy                *string           `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                   *string           `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tMilestone              *string           `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tView                   *string           `url:\"view,omitempty\" json:\"view,omitempty\"`\n\tLabels                 *LabelOptions     `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tNotLabels              *LabelOptions     `url:\"not[labels],comma,omitempty\" json:\"not[labels],omitempty\"`\n\tWithLabelsDetails      *bool             `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tWithMergeStatusRecheck *bool             `url:\"with_merge_status_recheck,omitempty\" json:\"with_merge_status_recheck,omitempty\"`\n\tCreatedAfter           *time.Time        `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore          *time.Time        `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter           *time.Time        `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore          *time.Time        `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tScope                  *string           `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID               *int              `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername         *string           `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tNotAuthorUsername      *string           `url:\"not[author_username],omitempty\" json:\"not[author_username],omitempty\"`\n\tAssigneeID             *AssigneeIDValue  `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tApproverIDs            *ApproverIDsValue `url:\"approver_ids,omitempty\" json:\"approver_ids,omitempty\"`\n\tApprovedByIDs          *ApproverIDsValue `url:\"approved_by_ids,omitempty\" json:\"approved_by_ids,omitempty\"`\n\tReviewerID             *ReviewerIDValue  `url:\"reviewer_id,omitempty\" json:\"reviewer_id,omitempty\"`\n\tReviewerUsername       *string           `url:\"reviewer_username,omitempty\" json:\"reviewer_username,omitempty\"`\n\tMyReactionEmoji        *string           `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tSourceBranch           *string           `url:\"source_branch,omitempty\" json:\"source_branch,omitempty\"`\n\tTargetBranch           *string           `url:\"target_branch,omitempty\" json:\"target_branch,omitempty\"`\n\tSearch                 *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIn                     *string           `url:\"in,omitempty\" json:\"in,omitempty\"`\n\tDraft                  *bool             `url:\"draft,omitempty\" json:\"draft,omitempty\"`\n\tWIP                    *string           `url:\"wip,omitempty\" json:\"wip,omitempty\"`\n}\n\n// ListMergeRequests gets all merge requests. The state parameter can be used\n// to get only merge requests with a given state (opened, closed, or merged)\n// or all of them (all). The pagination parameters page and per_page can be\n// used to restrict the list of merge requests.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-requests\nfunc (s *MergeRequestsService) ListMergeRequests(opt *ListMergeRequestsOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"merge_requests\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*MergeRequest\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// ListProjectMergeRequestsOptions represents the available ListMergeRequests()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-project-merge-requests\ntype ListProjectMergeRequestsOptions struct {\n\tListOptions\n\tIIDs                   *[]int            `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tState                  *string           `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tOrderBy                *string           `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                   *string           `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tMilestone              *string           `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tView                   *string           `url:\"view,omitempty\" json:\"view,omitempty\"`\n\tLabels                 *LabelOptions     `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tNotLabels              *LabelOptions     `url:\"not[labels],comma,omitempty\" json:\"not[labels],omitempty\"`\n\tWithLabelsDetails      *bool             `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tWithMergeStatusRecheck *bool             `url:\"with_merge_status_recheck,omitempty\" json:\"with_merge_status_recheck,omitempty\"`\n\tCreatedAfter           *time.Time        `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore          *time.Time        `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter           *time.Time        `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore          *time.Time        `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tScope                  *string           `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID               *int              `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername         *string           `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tNotAuthorUsername      *string           `url:\"not[author_username],omitempty\" json:\"not[author_username],omitempty\"`\n\tAssigneeID             *AssigneeIDValue  `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tApproverIDs            *ApproverIDsValue `url:\"approver_ids,omitempty\" json:\"approver_ids,omitempty\"`\n\tApprovedByIDs          *ApproverIDsValue `url:\"approved_by_ids,omitempty\" json:\"approved_by_ids,omitempty\"`\n\tReviewerID             *ReviewerIDValue  `url:\"reviewer_id,omitempty\" json:\"reviewer_id,omitempty\"`\n\tReviewerUsername       *string           `url:\"reviewer_username,omitempty\" json:\"reviewer_username,omitempty\"`\n\tMyReactionEmoji        *string           `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tSourceBranch           *string           `url:\"source_branch,omitempty\" json:\"source_branch,omitempty\"`\n\tTargetBranch           *string           `url:\"target_branch,omitempty\" json:\"target_branch,omitempty\"`\n\tSearch                 *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tDraft                  *bool             `url:\"draft,omitempty\" json:\"draft,omitempty\"`\n\tWIP                    *string           `url:\"wip,omitempty\" json:\"wip,omitempty\"`\n}\n\n// ListProjectMergeRequests gets all merge requests for this project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-project-merge-requests\nfunc (s *MergeRequestsService) ListProjectMergeRequests(pid interface{}, opt *ListProjectMergeRequestsOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*MergeRequest\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// ListGroupMergeRequestsOptions represents the available ListGroupMergeRequests()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-group-merge-requests\ntype ListGroupMergeRequestsOptions struct {\n\tListOptions\n\tState                  *string           `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tOrderBy                *string           `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                   *string           `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tMilestone              *string           `url:\"milestone,omitempty\" json:\"milestone,omitempty\"`\n\tView                   *string           `url:\"view,omitempty\" json:\"view,omitempty\"`\n\tLabels                 *LabelOptions     `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tNotLabels              *LabelOptions     `url:\"not[labels],comma,omitempty\" json:\"not[labels],omitempty\"`\n\tWithLabelsDetails      *bool             `url:\"with_labels_details,omitempty\" json:\"with_labels_details,omitempty\"`\n\tWithMergeStatusRecheck *bool             `url:\"with_merge_status_recheck,omitempty\" json:\"with_merge_status_recheck,omitempty\"`\n\tCreatedAfter           *time.Time        `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore          *time.Time        `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tUpdatedAfter           *time.Time        `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore          *time.Time        `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tScope                  *string           `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tAuthorID               *int              `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tAuthorUsername         *string           `url:\"author_username,omitempty\" json:\"author_username,omitempty\"`\n\tNotAuthorUsername      *string           `url:\"not[author_username],omitempty\" json:\"not[author_username],omitempty\"`\n\tAssigneeID             *AssigneeIDValue  `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tApproverIDs            *ApproverIDsValue `url:\"approver_ids,omitempty\" json:\"approver_ids,omitempty\"`\n\tApprovedByIDs          *ApproverIDsValue `url:\"approved_by_ids,omitempty\" json:\"approved_by_ids,omitempty\"`\n\tReviewerID             *ReviewerIDValue  `url:\"reviewer_id,omitempty\" json:\"reviewer_id,omitempty\"`\n\tReviewerUsername       *string           `url:\"reviewer_username,omitempty\" json:\"reviewer_username,omitempty\"`\n\tMyReactionEmoji        *string           `url:\"my_reaction_emoji,omitempty\" json:\"my_reaction_emoji,omitempty\"`\n\tSourceBranch           *string           `url:\"source_branch,omitempty\" json:\"source_branch,omitempty\"`\n\tTargetBranch           *string           `url:\"target_branch,omitempty\" json:\"target_branch,omitempty\"`\n\tSearch                 *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIn                     *string           `url:\"in,omitempty\" json:\"in,omitempty\"`\n\tDraft                  *bool             `url:\"draft,omitempty\" json:\"draft,omitempty\"`\n\tWIP                    *string           `url:\"wip,omitempty\" json:\"wip,omitempty\"`\n}\n\n// ListGroupMergeRequests gets all merge requests for this group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-group-merge-requests\nfunc (s *MergeRequestsService) ListGroupMergeRequests(gid interface{}, opt *ListGroupMergeRequestsOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/merge_requests\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*MergeRequest\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// GetMergeRequestsOptions represents the available GetMergeRequests()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr\ntype GetMergeRequestsOptions struct {\n\tRenderHTML                  *bool `url:\"render_html,omitempty\" json:\"render_html,omitempty\"`\n\tIncludeDivergedCommitsCount *bool `url:\"include_diverged_commits_count,omitempty\" json:\"include_diverged_commits_count,omitempty\"`\n\tIncludeRebaseInProgress     *bool `url:\"include_rebase_in_progress,omitempty\" json:\"include_rebase_in_progress,omitempty\"`\n}\n\n// GetMergeRequest shows information about a single merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-mr\nfunc (s *MergeRequestsService) GetMergeRequest(pid interface{}, mergeRequest int, opt *GetMergeRequestsOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// GetMergeRequestApprovals gets information about a merge requests approvals\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#merge-request-level-mr-approvals\nfunc (s *MergeRequestsService) GetMergeRequestApprovals(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*MergeRequestApprovals, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/approvals\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ta := new(MergeRequestApprovals)\n\tresp, err := s.client.Do(req, a)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn a, resp, nil\n}\n\n// GetMergeRequestCommitsOptions represents the available GetMergeRequestCommits()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-commits\ntype GetMergeRequestCommitsOptions ListOptions\n\n// GetMergeRequestCommits gets a list of merge request commits.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-commits\nfunc (s *MergeRequestsService) GetMergeRequestCommits(pid interface{}, mergeRequest int, opt *GetMergeRequestCommitsOptions, options ...RequestOptionFunc) ([]*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/commits\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar c []*Commit\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// GetMergeRequestChangesOptions represents the available GetMergeRequestChanges()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-changes\ntype GetMergeRequestChangesOptions struct {\n\tAccessRawDiffs *bool `url:\"access_raw_diffs,omitempty\" json:\"access_raw_diffs,omitempty\"`\n\tUnidiff        *bool `url:\"unidiff,omitempty\" json:\"unidiff,omitempty\"`\n}\n\n// GetMergeRequestChanges shows information about the merge request including\n// its files and changes.\n//\n// Deprecated: This endpoint has been replaced by\n// MergeRequestsService.ListMergeRequestDiffs()\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-changes\nfunc (s *MergeRequestsService) GetMergeRequestChanges(pid interface{}, mergeRequest int, opt *GetMergeRequestChangesOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/changes\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// ListMergeRequestDiffsOptions represents the available ListMergeRequestDiffs()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-request-diffs\ntype ListMergeRequestDiffsOptions struct {\n\tListOptions\n\tUnidiff *bool `url:\"unidiff,omitempty\" json:\"unidiff,omitempty\"`\n}\n\n// ListMergeRequestDiffs List diffs of the files changed in a merge request\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-request-diffs\nfunc (s *MergeRequestsService) ListMergeRequestDiffs(pid interface{}, mergeRequest int, opt *ListMergeRequestDiffsOptions, options ...RequestOptionFunc) ([]*MergeRequestDiff, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/diffs\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*MergeRequestDiff\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// GetMergeRequestParticipants gets a list of merge request participants.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-participants\nfunc (s *MergeRequestsService) GetMergeRequestParticipants(pid interface{}, mergeRequest int, options ...RequestOptionFunc) ([]*BasicUser, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/participants\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar bu []*BasicUser\n\tresp, err := s.client.Do(req, &bu)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn bu, resp, nil\n}\n\n// MergeRequestReviewer represents a GitLab merge request reviewer.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-reviewers\ntype MergeRequestReviewer struct {\n\tUser      *BasicUser `json:\"user\"`\n\tState     string     `json:\"state\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n}\n\n// GetMergeRequestReviewers gets a list of merge request reviewers.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-single-merge-request-reviewers\nfunc (s *MergeRequestsService) GetMergeRequestReviewers(pid interface{}, mergeRequest int, options ...RequestOptionFunc) ([]*MergeRequestReviewer, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/reviewers\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mrr []*MergeRequestReviewer\n\tresp, err := s.client.Do(req, &mrr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mrr, resp, nil\n}\n\n// ListMergeRequestPipelines gets all pipelines for the provided merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-merge-request-pipelines\nfunc (s *MergeRequestsService) ListMergeRequestPipelines(pid interface{}, mergeRequest int, options ...RequestOptionFunc) ([]*PipelineInfo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/pipelines\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*PipelineInfo\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CreateMergeRequestPipeline creates a new pipeline for a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#create-merge-request-pipeline\nfunc (s *MergeRequestsService) CreateMergeRequestPipeline(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*PipelineInfo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/pipelines\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineInfo)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetIssuesClosedOnMergeOptions represents the available GetIssuesClosedOnMerge()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-issues-that-close-on-merge\ntype GetIssuesClosedOnMergeOptions ListOptions\n\n// GetIssuesClosedOnMerge gets all the issues that would be closed by merging the\n// provided merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#list-issues-that-close-on-merge\nfunc (s *MergeRequestsService) GetIssuesClosedOnMerge(pid interface{}, mergeRequest int, opt *GetIssuesClosedOnMergeOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/closes_issues\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar i []*Issue\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// CreateMergeRequestOptions represents the available CreateMergeRequest()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#create-mr\ntype CreateMergeRequestOptions struct {\n\tTitle                *string       `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription          *string       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tSourceBranch         *string       `url:\"source_branch,omitempty\" json:\"source_branch,omitempty\"`\n\tTargetBranch         *string       `url:\"target_branch,omitempty\" json:\"target_branch,omitempty\"`\n\tLabels               *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tAssigneeID           *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tAssigneeIDs          *[]int        `url:\"assignee_ids,omitempty\" json:\"assignee_ids,omitempty\"`\n\tReviewerIDs          *[]int        `url:\"reviewer_ids,omitempty\" json:\"reviewer_ids,omitempty\"`\n\tTargetProjectID      *int          `url:\"target_project_id,omitempty\" json:\"target_project_id,omitempty\"`\n\tMilestoneID          *int          `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tRemoveSourceBranch   *bool         `url:\"remove_source_branch,omitempty\" json:\"remove_source_branch,omitempty\"`\n\tSquash               *bool         `url:\"squash,omitempty\" json:\"squash,omitempty\"`\n\tAllowCollaboration   *bool         `url:\"allow_collaboration,omitempty\" json:\"allow_collaboration,omitempty\"`\n\tApprovalsBeforeMerge *int          `url:\"approvals_before_merge,omitempty\" json:\"approvals_before_merge,omitempty\"`\n}\n\n// CreateMergeRequest creates a new merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#create-mr\nfunc (s *MergeRequestsService) CreateMergeRequest(pid interface{}, opt *CreateMergeRequestOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// UpdateMergeRequestOptions represents the available UpdateMergeRequest()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#update-mr\ntype UpdateMergeRequestOptions struct {\n\tTitle              *string       `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription        *string       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tTargetBranch       *string       `url:\"target_branch,omitempty\" json:\"target_branch,omitempty\"`\n\tAssigneeID         *int          `url:\"assignee_id,omitempty\" json:\"assignee_id,omitempty\"`\n\tAssigneeIDs        *[]int        `url:\"assignee_ids,omitempty\" json:\"assignee_ids,omitempty\"`\n\tReviewerIDs        *[]int        `url:\"reviewer_ids,omitempty\" json:\"reviewer_ids,omitempty\"`\n\tLabels             *LabelOptions `url:\"labels,comma,omitempty\" json:\"labels,omitempty\"`\n\tAddLabels          *LabelOptions `url:\"add_labels,comma,omitempty\" json:\"add_labels,omitempty\"`\n\tRemoveLabels       *LabelOptions `url:\"remove_labels,comma,omitempty\" json:\"remove_labels,omitempty\"`\n\tMilestoneID        *int          `url:\"milestone_id,omitempty\" json:\"milestone_id,omitempty\"`\n\tStateEvent         *string       `url:\"state_event,omitempty\" json:\"state_event,omitempty\"`\n\tRemoveSourceBranch *bool         `url:\"remove_source_branch,omitempty\" json:\"remove_source_branch,omitempty\"`\n\tSquash             *bool         `url:\"squash,omitempty\" json:\"squash,omitempty\"`\n\tDiscussionLocked   *bool         `url:\"discussion_locked,omitempty\" json:\"discussion_locked,omitempty\"`\n\tAllowCollaboration *bool         `url:\"allow_collaboration,omitempty\" json:\"allow_collaboration,omitempty\"`\n}\n\n// UpdateMergeRequest updates an existing project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#update-mr\nfunc (s *MergeRequestsService) UpdateMergeRequest(pid interface{}, mergeRequest int, opt *UpdateMergeRequestOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// DeleteMergeRequest deletes a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#delete-a-merge-request\nfunc (s *MergeRequestsService) DeleteMergeRequest(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// AcceptMergeRequestOptions represents the available AcceptMergeRequest()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#merge-a-merge-request\ntype AcceptMergeRequestOptions struct {\n\tMergeCommitMessage        *string `url:\"merge_commit_message,omitempty\" json:\"merge_commit_message,omitempty\"`\n\tSquashCommitMessage       *string `url:\"squash_commit_message,omitempty\" json:\"squash_commit_message,omitempty\"`\n\tSquash                    *bool   `url:\"squash,omitempty\" json:\"squash,omitempty\"`\n\tShouldRemoveSourceBranch  *bool   `url:\"should_remove_source_branch,omitempty\" json:\"should_remove_source_branch,omitempty\"`\n\tMergeWhenPipelineSucceeds *bool   `url:\"merge_when_pipeline_succeeds,omitempty\" json:\"merge_when_pipeline_succeeds,omitempty\"`\n\tSHA                       *string `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n}\n\n// AcceptMergeRequest merges changes submitted with MR using this API. If merge\n// success you get 200 OK. If it has some conflicts and can not be merged - you\n// get 405 and error message 'Branch cannot be merged'. If merge request is\n// already merged or closed - you get 405 and error message 'Method Not Allowed'\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#merge-a-merge-request\nfunc (s *MergeRequestsService) AcceptMergeRequest(pid interface{}, mergeRequest int, opt *AcceptMergeRequestOptions, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/merge\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// CancelMergeWhenPipelineSucceeds cancels a merge when pipeline succeeds. If\n// you don't have permissions to accept this merge request - you'll get a 401.\n// If the merge request is already merged or closed - you get 405 and error\n// message 'Method Not Allowed'. In case the merge request is not set to be\n// merged when the pipeline succeeds, you'll also get a 406 error.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#cancel-merge-when-pipeline-succeeds\nfunc (s *MergeRequestsService) CancelMergeWhenPipelineSucceeds(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/cancel_merge_when_pipeline_succeeds\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// RebaseMergeRequestOptions represents the available RebaseMergeRequest()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#rebase-a-merge-request\ntype RebaseMergeRequestOptions struct {\n\tSkipCI *bool `url:\"skip_ci,omitempty\" json:\"skip_ci,omitempty\"`\n}\n\n// RebaseMergeRequest automatically rebases the source_branch of the merge\n// request against its target_branch. If you don’t have permissions to push\n// to the merge request’s source branch, you’ll get a 403 Forbidden response.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#rebase-a-merge-request\nfunc (s *MergeRequestsService) RebaseMergeRequest(pid interface{}, mergeRequest int, opt *RebaseMergeRequestOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/rebase\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GetMergeRequestDiffVersionsOptions represents the available\n// GetMergeRequestDiffVersions() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-merge-request-diff-versions\ntype GetMergeRequestDiffVersionsOptions ListOptions\n\n// GetMergeRequestDiffVersions get a list of merge request diff versions.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-merge-request-diff-versions\nfunc (s *MergeRequestsService) GetMergeRequestDiffVersions(pid interface{}, mergeRequest int, opt *GetMergeRequestDiffVersionsOptions, options ...RequestOptionFunc) ([]*MergeRequestDiffVersion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/versions\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar v []*MergeRequestDiffVersion\n\tresp, err := s.client.Do(req, &v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// GetSingleMergeRequestDiffVersionOptions represents the available\n// GetSingleMergeRequestDiffVersion() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-a-single-merge-request-diff-version\ntype GetSingleMergeRequestDiffVersionOptions struct {\n\tUnidiff *bool `url:\"unidiff,omitempty\" json:\"unidiff,omitempty\"`\n}\n\n// GetSingleMergeRequestDiffVersion get a single MR diff version\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-a-single-merge-request-diff-version\nfunc (s *MergeRequestsService) GetSingleMergeRequestDiffVersion(pid interface{}, mergeRequest, version int, opt *GetSingleMergeRequestDiffVersionOptions, options ...RequestOptionFunc) (*MergeRequestDiffVersion, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/versions/%d\", PathEscape(project), mergeRequest, version)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(MergeRequestDiffVersion)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// SubscribeToMergeRequest subscribes the authenticated user to the given merge\n// request to receive notifications. If the user is already subscribed to the\n// merge request, the status code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#subscribe-to-a-merge-request\nfunc (s *MergeRequestsService) SubscribeToMergeRequest(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/subscribe\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// UnsubscribeFromMergeRequest unsubscribes the authenticated user from the\n// given merge request to not receive notifications from that merge request.\n// If the user is not subscribed to the merge request, status code 304 is\n// returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#unsubscribe-from-a-merge-request\nfunc (s *MergeRequestsService) UnsubscribeFromMergeRequest(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/unsubscribe\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(MergeRequest)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// CreateTodo manually creates a todo for the current user on a merge request.\n// If there already exists a todo for the user on that merge request,\n// status code 304 is returned.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#create-a-to-do-item\nfunc (s *MergeRequestsService) CreateTodo(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*Todo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/todo\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Todo)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// SetTimeEstimate sets the time estimate for a single project merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#set-a-time-estimate-for-a-merge-request\nfunc (s *MergeRequestsService) SetTimeEstimate(pid interface{}, mergeRequest int, opt *SetTimeEstimateOptions, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.setTimeEstimate(pid, \"merge_requests\", mergeRequest, opt, options...)\n}\n\n// ResetTimeEstimate resets the time estimate for a single project merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#reset-the-time-estimate-for-a-merge-request\nfunc (s *MergeRequestsService) ResetTimeEstimate(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.resetTimeEstimate(pid, \"merge_requests\", mergeRequest, options...)\n}\n\n// AddSpentTime adds spent time for a single project merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#add-spent-time-for-a-merge-request\nfunc (s *MergeRequestsService) AddSpentTime(pid interface{}, mergeRequest int, opt *AddSpentTimeOptions, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.addSpentTime(pid, \"merge_requests\", mergeRequest, opt, options...)\n}\n\n// ResetSpentTime resets the spent time for a single project merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#reset-spent-time-for-a-merge-request\nfunc (s *MergeRequestsService) ResetSpentTime(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.resetSpentTime(pid, \"merge_requests\", mergeRequest, options...)\n}\n\n// GetTimeSpent gets the spent time for a single project merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_requests.html#get-time-tracking-stats\nfunc (s *MergeRequestsService) GetTimeSpent(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\treturn s.timeStats.getTimeSpent(pid, \"merge_requests\", mergeRequest, options...)\n}\n"
        },
        {
          "name": "merge_requests_test.go",
          "type": "blob",
          "size": 17.73046875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/google/go-querystring/query\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar (\n\tajk = BasicUser{\n\t\tID:        3614858,\n\t\tName:      \"Alex Kalderimis\",\n\t\tUsername:  \"alexkalderimis\",\n\t\tState:     \"active\",\n\t\tAvatarURL: \"https://assets.gitlab-static.net/uploads/-/system/user/avatar/3614858/avatar.png\",\n\t\tWebURL:    \"https://gitlab.com/alexkalderimis\",\n\t}\n\ttk = BasicUser{\n\t\tID:        2535118,\n\t\tName:      \"Thong Kuah\",\n\t\tUsername:  \"tkuah\",\n\t\tState:     \"active\",\n\t\tAvatarURL: \"https://secure.gravatar.com/avatar/f7b51bdd49a4914d29504d7ff4c3f7b9?s=80&d=identicon\",\n\t\tWebURL:    \"https://gitlab.com/tkuah\",\n\t}\n\tgetOpts = GetMergeRequestsOptions{}\n\tlabels  = Labels{\n\t\t\"GitLab Enterprise Edition\",\n\t\t\"backend\",\n\t\t\"database\",\n\t\t\"database::reviewed\",\n\t\t\"design management\",\n\t\t\"feature\",\n\t\t\"frontend\",\n\t\t\"group::knowledge\",\n\t\t\"missed:12.1\",\n\t}\n\tpipelineCreation = time.Date(2019, 8, 19, 9, 50, 58, 157000000, time.UTC)\n\tpipelineUpdate   = time.Date(2019, 8, 19, 19, 22, 29, 647000000, time.UTC)\n\tpipelineBasic    = PipelineInfo{\n\t\tID:        77056819,\n\t\tSHA:       \"8e0b45049b6253b8984cde9241830d2851168142\",\n\t\tRef:       \"delete-designs-v2\",\n\t\tStatus:    \"success\",\n\t\tWebURL:    \"https://gitlab.com/gitlab-org/gitlab-ee/pipelines/77056819\",\n\t\tCreatedAt: &pipelineCreation,\n\t\tUpdatedAt: &pipelineUpdate,\n\t}\n\tpipelineStarted  = time.Date(2019, 8, 19, 9, 51, 6, 545000000, time.UTC)\n\tpipelineFinished = time.Date(2019, 8, 19, 19, 22, 29, 632000000, time.UTC)\n\tpipelineDetailed = Pipeline{\n\t\tID:         77056819,\n\t\tSHA:        \"8e0b45049b6253b8984cde9241830d2851168142\",\n\t\tRef:        \"delete-designs-v2\",\n\t\tStatus:     \"success\",\n\t\tWebURL:     \"https://gitlab.com/gitlab-org/gitlab-ee/pipelines/77056819\",\n\t\tBeforeSHA:  \"3fe568caacb261b63090886f5b879ca0d9c6f4c3\",\n\t\tTag:        false,\n\t\tUser:       &ajk,\n\t\tCreatedAt:  &pipelineCreation,\n\t\tUpdatedAt:  &pipelineUpdate,\n\t\tStartedAt:  &pipelineStarted,\n\t\tFinishedAt: &pipelineFinished,\n\t\tDuration:   4916,\n\t\tCoverage:   \"82.68\",\n\t\tDetailedStatus: &DetailedStatus{\n\t\t\tIcon:        \"status_warning\",\n\t\t\tText:        \"passed\",\n\t\t\tLabel:       \"passed with warnings\",\n\t\t\tGroup:       \"success-with-warnings\",\n\t\t\tTooltip:     \"passed\",\n\t\t\tHasDetails:  true,\n\t\t\tDetailsPath: \"/gitlab-org/gitlab-ee/pipelines/77056819\",\n\t\t\tFavicon:     \"https://gitlab.com/assets/ci_favicons/favicon_status_success-8451333011eee8ce9f2ab25dc487fe24a8758c694827a582f17f42b0a90446a2.png\",\n\t\t},\n\t}\n)\n\nfunc TestGetMergeRequest(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/projects/namespace/name/merge_requests/123\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_merge_request.json\")\n\t})\n\n\tmergeRequest, _, err := client.MergeRequests.GetMergeRequest(\"namespace/name\", 123, &getOpts)\n\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, mergeRequest.ID, 33092005)\n\trequire.Equal(t, mergeRequest.SHA, \"8e0b45049b6253b8984cde9241830d2851168142\")\n\trequire.Equal(t, mergeRequest.IID, 14656)\n\trequire.Equal(t, mergeRequest.Reference, \"!14656\")\n\trequire.Equal(t, mergeRequest.ProjectID, 278964)\n\trequire.Equal(t, mergeRequest.SourceBranch, \"delete-designs-v2\")\n\trequire.Equal(t, mergeRequest.TaskCompletionStatus.Count, 9)\n\trequire.Equal(t, mergeRequest.TaskCompletionStatus.CompletedCount, 8)\n\trequire.Equal(t, mergeRequest.Title, \"Add deletion support for designs\")\n\trequire.Equal(t, mergeRequest.Description,\n\t\t\"## What does this MR do?\\r\\n\\r\\nThis adds the capability to destroy/hide designs.\")\n\trequire.Equal(t, mergeRequest.WebURL,\n\t\t\"https://gitlab.com/gitlab-org/gitlab-ee/merge_requests/14656\")\n\trequire.Equal(t, mergeRequest.DetailedMergeStatus, \"mergeable\")\n\trequire.Equal(t, mergeRequest.Author, &ajk)\n\trequire.Equal(t, mergeRequest.Assignee, &tk)\n\trequire.Equal(t, mergeRequest.Assignees, []*BasicUser{&tk})\n\trequire.Equal(t, mergeRequest.Reviewers, []*BasicUser{&tk})\n\trequire.Equal(t, mergeRequest.Labels, labels)\n\trequire.Equal(t, mergeRequest.Squash, true)\n\trequire.Equal(t, mergeRequest.UserNotesCount, 245)\n\trequire.Equal(t, mergeRequest.Pipeline, &pipelineBasic)\n\trequire.Equal(t, mergeRequest.HeadPipeline, &pipelineDetailed)\n\tmrCreation := time.Date(2019, 7, 11, 22, 34, 43, 500000000, time.UTC)\n\trequire.Equal(t, mergeRequest.CreatedAt, &mrCreation)\n\tmrUpdate := time.Date(2019, 8, 20, 9, 9, 56, 690000000, time.UTC)\n\trequire.Equal(t, mergeRequest.UpdatedAt, &mrUpdate)\n\trequire.Equal(t, mergeRequest.FirstContribution, true)\n\trequire.Equal(t, mergeRequest.HasConflicts, true)\n\trequire.Equal(t, mergeRequest.Draft, true)\n}\n\nfunc TestListProjectMergeRequests(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/projects/278964/merge_requests\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"assignee_id=Any&with_labels_details=true&with_merge_status_recheck=true\")\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_merge_requests.json\")\n\t})\n\n\topts := ListProjectMergeRequestsOptions{\n\t\tAssigneeID:             AssigneeID(UserIDAny),\n\t\tWithLabelsDetails:      Ptr(true),\n\t\tWithMergeStatusRecheck: Ptr(true),\n\t}\n\n\tmergeRequests, _, err := client.MergeRequests.ListProjectMergeRequests(278964, &opts)\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, 3, len(mergeRequests))\n\n\tvalidStates := []string{\"opened\", \"closed\", \"locked\", \"merged\"}\n\tdetailedMergeStatuses := []string{\n\t\t\"blocked_status\",\n\t\t\"broken_status\",\n\t\t\"checking\",\n\t\t\"ci_must_pass\",\n\t\t\"ci_still_running\",\n\t\t\"discussions_not_resolved\",\n\t\t\"draft_status\",\n\t\t\"external_status_checks\",\n\t\t\"mergeable\",\n\t\t\"not_approved\",\n\t\t\"not_open\",\n\t\t\"policies_denied\",\n\t\t\"unchecked\",\n\t}\n\tallCreatedBefore := time.Date(2019, 8, 21, 0, 0, 0, 0, time.UTC)\n\tallCreatedAfter := time.Date(2019, 8, 17, 0, 0, 0, 0, time.UTC)\n\n\tfor _, mr := range mergeRequests {\n\t\trequire.Equal(t, 278964, mr.ProjectID)\n\t\trequire.Contains(t, validStates, mr.State)\n\t\tassert.Less(t, mr.CreatedAt.Unix(), allCreatedBefore.Unix())\n\t\tassert.Greater(t, mr.CreatedAt.Unix(), allCreatedAfter.Unix())\n\t\tassert.LessOrEqual(t, mr.CreatedAt.Unix(), mr.UpdatedAt.Unix())\n\t\tassert.LessOrEqual(t, mr.TaskCompletionStatus.CompletedCount, mr.TaskCompletionStatus.Count)\n\t\trequire.Contains(t, detailedMergeStatuses, mr.DetailedMergeStatus)\n\t\t// list requests do not provide these fields:\n\t\tassert.Nil(t, mr.Pipeline)\n\t\tassert.Nil(t, mr.HeadPipeline)\n\t\tassert.Equal(t, \"\", mr.DiffRefs.HeadSha)\n\t}\n}\n\nfunc TestListProjectMergeRequestsAuthorUsername(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/projects/278964/merge_requests\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"assignee_id=Any&author_username=hfyngvason&with_labels_details=true&with_merge_status_recheck=true\")\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_merge_requests_author_username.json\")\n\t})\n\n\topts := ListProjectMergeRequestsOptions{\n\t\tAssigneeID:             AssigneeID(UserIDAny),\n\t\tAuthorUsername:         String(\"hfyngvason\"),\n\t\tWithLabelsDetails:      Bool(true),\n\t\tWithMergeStatusRecheck: Bool(true),\n\t}\n\n\tmergeRequests, _, err := client.MergeRequests.ListProjectMergeRequests(278964, &opts)\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, 1, len(mergeRequests))\n\n\tvalidStates := []string{\"opened\", \"closed\", \"locked\", \"merged\"}\n\tdetailedMergeStatuses := []string{\n\t\t\"blocked_status\",\n\t\t\"broken_status\",\n\t\t\"checking\",\n\t\t\"ci_must_pass\",\n\t\t\"ci_still_running\",\n\t\t\"discussions_not_resolved\",\n\t\t\"draft_status\",\n\t\t\"external_status_checks\",\n\t\t\"mergeable\",\n\t\t\"not_approved\",\n\t\t\"not_open\",\n\t\t\"policies_denied\",\n\t\t\"unchecked\",\n\t}\n\tallCreatedBefore := time.Date(2019, 8, 21, 0, 0, 0, 0, time.UTC)\n\tallCreatedAfter := time.Date(2019, 8, 17, 0, 0, 0, 0, time.UTC)\n\n\tfor _, mr := range mergeRequests {\n\t\trequire.Equal(t, 278964, mr.ProjectID)\n\t\trequire.Contains(t, validStates, mr.State)\n\t\tassert.Less(t, mr.CreatedAt.Unix(), allCreatedBefore.Unix())\n\t\tassert.Greater(t, mr.CreatedAt.Unix(), allCreatedAfter.Unix())\n\t\tassert.LessOrEqual(t, mr.CreatedAt.Unix(), mr.UpdatedAt.Unix())\n\t\tassert.LessOrEqual(t, mr.TaskCompletionStatus.CompletedCount, mr.TaskCompletionStatus.Count)\n\t\trequire.Contains(t, detailedMergeStatuses, mr.DetailedMergeStatus)\n\t\t// list requests do not provide these fields:\n\t\tassert.Nil(t, mr.Pipeline)\n\t\tassert.Nil(t, mr.HeadPipeline)\n\t\tassert.Equal(t, \"\", mr.DiffRefs.HeadSha)\n\t}\n}\n\nfunc TestListProjectMergeRequestsNotAuthorUsername(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/projects/278964/merge_requests\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"assignee_id=Any&not%5Bauthor_username%5D=hfyngvason&with_labels_details=true&with_merge_status_recheck=true\")\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_merge_requests_not_author_username.json\")\n\t})\n\n\topts := ListProjectMergeRequestsOptions{\n\t\tAssigneeID:             AssigneeID(UserIDAny),\n\t\tNotAuthorUsername:      String(\"hfyngvason\"),\n\t\tWithLabelsDetails:      Bool(true),\n\t\tWithMergeStatusRecheck: Bool(true),\n\t}\n\n\tmergeRequests, _, err := client.MergeRequests.ListProjectMergeRequests(278964, &opts)\n\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2, len(mergeRequests))\n\n\tvalidStates := []string{\"opened\", \"closed\", \"locked\", \"merged\"}\n\tdetailedMergeStatuses := []string{\n\t\t\"blocked_status\",\n\t\t\"broken_status\",\n\t\t\"checking\",\n\t\t\"ci_must_pass\",\n\t\t\"ci_still_running\",\n\t\t\"discussions_not_resolved\",\n\t\t\"draft_status\",\n\t\t\"external_status_checks\",\n\t\t\"mergeable\",\n\t\t\"not_approved\",\n\t\t\"not_open\",\n\t\t\"policies_denied\",\n\t\t\"unchecked\",\n\t}\n\tallCreatedBefore := time.Date(2019, 8, 21, 0, 0, 0, 0, time.UTC)\n\tallCreatedAfter := time.Date(2019, 8, 17, 0, 0, 0, 0, time.UTC)\n\n\tfor _, mr := range mergeRequests {\n\t\trequire.Equal(t, 278964, mr.ProjectID)\n\t\trequire.Contains(t, validStates, mr.State)\n\t\tassert.Less(t, mr.CreatedAt.Unix(), allCreatedBefore.Unix())\n\t\tassert.Greater(t, mr.CreatedAt.Unix(), allCreatedAfter.Unix())\n\t\tassert.LessOrEqual(t, mr.CreatedAt.Unix(), mr.UpdatedAt.Unix())\n\t\tassert.LessOrEqual(t, mr.TaskCompletionStatus.CompletedCount, mr.TaskCompletionStatus.Count)\n\t\trequire.Contains(t, detailedMergeStatuses, mr.DetailedMergeStatus)\n\t\t// list requests do not provide these fields:\n\t\tassert.Nil(t, mr.Pipeline)\n\t\tassert.Nil(t, mr.HeadPipeline)\n\t\tassert.Equal(t, \"\", mr.DiffRefs.HeadSha)\n\t}\n}\n\nfunc TestCreateMergeRequestPipeline(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/pipelines\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"status\":\"pending\"}`)\n\t})\n\n\tpipeline, _, err := client.MergeRequests.CreateMergeRequestPipeline(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"MergeRequests.CreateMergeRequestPipeline returned error: %v\", err)\n\t}\n\n\tassert.Equal(t, 1, pipeline.ID)\n\tassert.Equal(t, \"pending\", pipeline.Status)\n}\n\nfunc TestGetMergeRequestParticipants(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/5/participants\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/merge_requests/5/participants\")\n\n\t\tfmt.Fprint(w, `[{\"id\":1,\"name\":\"User1\",\"username\":\"User1\",\"state\":\"active\",\"avatar_url\":\"\",\"web_url\":\"https://localhost/User1\"},\n\t\t{\"id\":2,\"name\":\"User2\",\"username\":\"User2\",\"state\":\"active\",\"avatar_url\":\"https://localhost/uploads/-/system/user/avatar/2/avatar.png\",\"web_url\":\"https://localhost/User2\"}]`)\n\t})\n\n\tmergeRequestParticipants, _, err := client.MergeRequests.GetMergeRequestParticipants(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := []*BasicUser{\n\t\t{ID: 1, Name: \"User1\", Username: \"User1\", State: \"active\", AvatarURL: \"\", WebURL: \"https://localhost/User1\"},\n\t\t{ID: 2, Name: \"User2\", Username: \"User2\", State: \"active\", AvatarURL: \"https://localhost/uploads/-/system/user/avatar/2/avatar.png\", WebURL: \"https://localhost/User2\"},\n\t}\n\n\tif !reflect.DeepEqual(want, mergeRequestParticipants) {\n\t\tt.Errorf(\"Issues.GetMergeRequestParticipants returned %+v, want %+v\", mergeRequestParticipants, want)\n\t}\n}\n\nfunc TestGetMergeRequestReviewers(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/5/reviewers\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestURL(t, r, \"/api/v4/projects/1/merge_requests/5/reviewers\")\n\n\t\tfmt.Fprint(w, `[{\"user\":{\"id\":1,\"name\":\"John Doe1\",\"username\":\"user1\",\"state\":\"active\",\"avatar_url\":\"http://www.gravatar.com/avatar/c922747a93b40d1ea88262bf1aebee62?s=80&d=identicon\",\"web_url\":\"http://localhost/user1\"},\"state\":\"unreviewed\",\"created_at\":\"2022-07-27T17:03:27.684Z\"},{\"user\":{\"id\":2,\"name\":\"John Doe2\",\"username\":\"user2\",\"state\":\"active\",\"avatar_url\":\"http://www.gravatar.com/avatar/10fc7f102be8de7657fb4d80898bbfe3?s=80&d=identicon\",\"web_url\":\"http://localhost/user2\"},\"state\":\"reviewed\",\"created_at\":\"2022-07-27T17:03:27.684Z\"}]`)\n\t})\n\n\tmergeRequestReviewers, _, err := client.MergeRequests.GetMergeRequestReviewers(\"1\", 5)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcreatedAt := time.Date(2022, 0o7, 27, 17, 3, 27, 684000000, time.UTC)\n\tuser1 := BasicUser{ID: 1, Name: \"John Doe1\", Username: \"user1\", State: \"active\", AvatarURL: \"http://www.gravatar.com/avatar/c922747a93b40d1ea88262bf1aebee62?s=80&d=identicon\", WebURL: \"http://localhost/user1\"}\n\tuser2 := BasicUser{ID: 2, Name: \"John Doe2\", Username: \"user2\", State: \"active\", AvatarURL: \"http://www.gravatar.com/avatar/10fc7f102be8de7657fb4d80898bbfe3?s=80&d=identicon\", WebURL: \"http://localhost/user2\"}\n\n\tassert.Len(t, mergeRequestReviewers, 2)\n\tassert.Equal(t, \"unreviewed\", mergeRequestReviewers[0].State)\n\trequire.Equal(t, &user1, mergeRequestReviewers[0].User)\n\trequire.Equal(t, &createdAt, mergeRequestReviewers[0].CreatedAt)\n\tassert.Equal(t, \"reviewed\", mergeRequestReviewers[1].State)\n\trequire.Equal(t, &user2, mergeRequestReviewers[1].User)\n\trequire.Equal(t, &createdAt, mergeRequestReviewers[1].CreatedAt)\n}\n\nfunc TestGetIssuesClosedOnMerge_Jira(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/closes_issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, \"GET\")\n\t\tfmt.Fprint(w, `[{\"id\":\"PROJECT-123\",\"title\":\"Title of this issue\"}]`)\n\t})\n\n\tissues, _, err := client.MergeRequests.GetIssuesClosedOnMerge(1, 1, nil)\n\n\tassert.NoError(t, err)\n\tassert.Len(t, issues, 1)\n\tassert.Equal(t, \"PROJECT-123\", issues[0].ExternalID)\n\tassert.Equal(t, \"Title of this issue\", issues[0].Title)\n}\n\nfunc TestListMergeRequestDiffs(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/1/diffs\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_merge_request_diff.json\")\n\t})\n\n\topts := &ListMergeRequestDiffsOptions{\n\t\tListOptions: ListOptions{Page: 1, PerPage: 2},\n\t}\n\n\tdiffs, _, err := client.MergeRequests.ListMergeRequestDiffs(1, 1, opts)\n\tif err != nil {\n\t\tt.Errorf(\"MergeRequests.ListMergeRequestDiffs returned error: %v\", err)\n\t}\n\n\twant := []*MergeRequestDiff{\n\t\t{\n\t\t\tOldPath:     \"README\",\n\t\t\tNewPath:     \"README\",\n\t\t\tAMode:       \"100644\",\n\t\t\tBMode:       \"100644\",\n\t\t\tDiff:        \"@@ -1 +1 @@ -Title +README\",\n\t\t\tNewFile:     false,\n\t\t\tRenamedFile: false,\n\t\t\tDeletedFile: false,\n\t\t},\n\t\t{\n\t\t\tOldPath:     \"VERSION\",\n\t\t\tNewPath:     \"VERSION\",\n\t\t\tAMode:       \"100644\",\n\t\t\tBMode:       \"100644\",\n\t\t\tDiff:        \"@@ -1.9.7 +1.9.8\",\n\t\t\tNewFile:     false,\n\t\t\tRenamedFile: false,\n\t\t\tDeletedFile: false,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, diffs) {\n\t\tt.Errorf(\"MergeRequests.ListMergeRequestDiffs returned %+v, want %+v\", diffs, want)\n\t}\n}\n\nfunc TestIntSliceOrString(t *testing.T) {\n\tt.Run(\"any\", func(t *testing.T) {\n\t\topts := &ListMergeRequestsOptions{}\n\t\topts.ApprovedByIDs = ApproverIDs(UserIDAny)\n\t\tq, err := query.Values(opts)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"Any\", q.Get(\"approved_by_ids\"))\n\t})\n\tt.Run(\"none\", func(t *testing.T) {\n\t\topts := &ListMergeRequestsOptions{}\n\t\topts.ApprovedByIDs = ApproverIDs(UserIDNone)\n\t\tq, err := query.Values(opts)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"None\", q.Get(\"approved_by_ids\"))\n\t})\n\tt.Run(\"ids\", func(t *testing.T) {\n\t\topts := &ListMergeRequestsOptions{}\n\t\topts.ApprovedByIDs = ApproverIDs([]int{1, 2, 3})\n\t\tq, err := query.Values(opts)\n\t\tassert.NoError(t, err)\n\t\tincludedIDs := q[\"approved_by_ids[]\"]\n\t\tassert.Equal(t, []string{\"1\", \"2\", \"3\"}, includedIDs)\n\t})\n}\n\nfunc TestAssigneeIDMarshalling(t *testing.T) {\n\tt.Run(\"any\", func(t *testing.T) {\n\t\topts := &ListMergeRequestsOptions{}\n\t\topts.AssigneeID = AssigneeID(UserIDAny)\n\t\tq, err := query.Values(opts)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"Any\", q.Get(\"assignee_id\"))\n\t\tjs, _ := json.Marshal(opts)\n\t\tassert.Equal(t, `{\"assignee_id\":\"Any\"}`, string(js))\n\t})\n\tt.Run(\"none\", func(t *testing.T) {\n\t\topts := &ListMergeRequestsOptions{}\n\t\topts.AssigneeID = AssigneeID(UserIDNone)\n\t\tq, err := query.Values(opts)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"None\", q.Get(\"assignee_id\"))\n\t\tjs, _ := json.Marshal(opts)\n\t\tassert.Equal(t, `{\"assignee_id\":\"None\"}`, string(js))\n\t})\n\tt.Run(\"id\", func(t *testing.T) {\n\t\topts := &ListMergeRequestsOptions{}\n\t\topts.AssigneeID = AssigneeID(5)\n\t\tq, err := query.Values(opts)\n\t\tassert.NoError(t, err)\n\t\tassert.Equal(t, \"5\", q.Get(\"assignee_id\"))\n\t\tjs, _ := json.Marshal(opts)\n\t\tassert.Equal(t, `{\"assignee_id\":5}`, string(js))\n\t})\n}\n"
        },
        {
          "name": "merge_trains.go",
          "type": "blob",
          "size": 5.494140625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// MergeTrainsService handles communication with the merge trains related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/merge_trains.html\ntype MergeTrainsService struct {\n\tclient *Client\n}\n\n// MergeTrain represents a Gitlab merge train.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/merge_trains.html\ntype MergeTrain struct {\n\tID           int                     `json:\"id\"`\n\tMergeRequest *MergeTrainMergeRequest `json:\"merge_request\"`\n\tUser         *BasicUser              `json:\"user\"`\n\tPipeline     *Pipeline               `json:\"pipeline\"`\n\tCreatedAt    *time.Time              `json:\"created_at\"`\n\tUpdatedAt    *time.Time              `json:\"updated_at\"`\n\tTargetBranch string                  `json:\"target_branch\"`\n\tStatus       string                  `json:\"status\"`\n\tMergedAt     *time.Time              `json:\"merged_at\"`\n\tDuration     int                     `json:\"duration\"`\n}\n\n// MergeTrainMergeRequest represents a Gitlab merge request inside merge train.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/merge_trains.html\ntype MergeTrainMergeRequest struct {\n\tID          int        `json:\"id\"`\n\tIID         int        `json:\"iid\"`\n\tProjectID   int        `json:\"project_id\"`\n\tTitle       string     `json:\"title\"`\n\tDescription string     `json:\"description\"`\n\tState       string     `json:\"state\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tWebURL      string     `json:\"web_url\"`\n}\n\n// ListMergeTrainsOptions represents the available ListMergeTrain() options.\n//\n// Gitab API docs:\n// https://docs.gitlab.com/ee/api/merge_trains.html#list-merge-trains-for-a-project\ntype ListMergeTrainsOptions struct {\n\tListOptions\n\tScope *string `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tSort  *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListProjectMergeTrains get a list of merge trains in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_trains.html#list-merge-trains-for-a-project\nfunc (s *MergeTrainsService) ListProjectMergeTrains(pid interface{}, opt *ListMergeTrainsOptions, options ...RequestOptionFunc) ([]*MergeTrain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_trains\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mts []*MergeTrain\n\tresp, err := s.client.Do(req, &mts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mts, resp, nil\n}\n\n// ListMergeRequestInMergeTrain gets a list of merge requests added to a merge\n// train for the requested target branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_trains.html#list-merge-requests-in-a-merge-train\nfunc (s *MergeTrainsService) ListMergeRequestInMergeTrain(pid interface{}, targetBranch string, opts *ListMergeTrainsOptions, options ...RequestOptionFunc) ([]*MergeTrain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_trains/%s\", PathEscape(project), targetBranch)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mts []*MergeTrain\n\tresp, err := s.client.Do(req, &mts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mts, resp, nil\n}\n\n// GetMergeRequestOnAMergeTrain Get merge train information for the requested\n// merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_trains.html#get-the-status-of-a-merge-request-on-a-merge-train\nfunc (s *MergeTrainsService) GetMergeRequestOnAMergeTrain(pid interface{}, mergeRequest int, options ...RequestOptionFunc) (*MergeTrain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_trains/merge_requests/%d\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tmt := new(MergeTrain)\n\tresp, err := s.client.Do(req, mt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mt, resp, nil\n}\n\n// AddMergeRequestToMergeTrainOptions represents the available\n// AddMergeRequestToMergeTrain() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_trains.html#add-a-merge-request-to-a-merge-train\ntype AddMergeRequestToMergeTrainOptions struct {\n\tWhenPipelineSucceeds *bool   `url:\"when_pipeline_succeeds,omitempty\" json:\"when_pipeline_succeeds,omitempty\"`\n\tSHA                  *string `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n\tSquash               *bool   `url:\"squash,omitempty\" json:\"squash,omitempty\"`\n}\n\n// AddMergeRequestToMergeTrain Add a merge request to the merge train targeting\n// the merge request’s target branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_trains.html#add-a-merge-request-to-a-merge-train\nfunc (s *MergeTrainsService) AddMergeRequestToMergeTrain(pid interface{}, mergeRequest int, opts *AddMergeRequestToMergeTrainOptions, options ...RequestOptionFunc) ([]*MergeTrain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_trains/merge_requests/%d\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mts []*MergeTrain\n\tresp, err := s.client.Do(req, &mts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mts, resp, nil\n}\n"
        },
        {
          "name": "merge_trains_test.go",
          "type": "blob",
          "size": 9.4072265625,
          "content": "package gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListProjectMergeTrains(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_trains\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_merge_trains_in_project.json\")\n\t})\n\n\topts := &ListMergeTrainsOptions{}\n\n\tmergeTrains, _, err := client.MergeTrains.ListProjectMergeTrains(1, opts)\n\tif err != nil {\n\t\tt.Errorf(\"MergeTrains.ListProjectMergeTrains returned error: %v\", err)\n\t}\n\n\tmergeRequestCreatedAt := time.Date(2020, 2, 6, 8, 39, 14, 883000000, time.UTC)\n\tmergeRequestUpdatedAt := time.Date(2020, 0o2, 6, 8, 40, 57, 38000000, time.UTC)\n\n\tpipelineCreatedAt := time.Date(2020, 2, 6, 8, 40, 42, 410000000, time.UTC)\n\tpipelineUpdatedAt := time.Date(2020, 2, 6, 8, 40, 46, 912000000, time.UTC)\n\n\tmergeTrainCreatedAt := time.Date(2020, 2, 6, 8, 39, 47, 217000000, time.UTC)\n\tmergeTrainUpdatedAt := time.Date(2020, 2, 6, 8, 40, 57, 720000000, time.UTC)\n\tmergeTrainMergedAt := time.Date(2020, 2, 6, 8, 40, 57, 719000000, time.UTC)\n\n\twant := []*MergeTrain{\n\t\t{\n\t\t\tID: 110,\n\t\t\tMergeRequest: &MergeTrainMergeRequest{\n\t\t\t\tID:          126,\n\t\t\t\tIID:         59,\n\t\t\t\tProjectID:   20,\n\t\t\t\tTitle:       \"Test MR 1580978354\",\n\t\t\t\tDescription: \"\",\n\t\t\t\tState:       \"merged\",\n\t\t\t\tCreatedAt:   &mergeRequestCreatedAt,\n\t\t\t\tUpdatedAt:   &mergeRequestUpdatedAt,\n\t\t\t\tWebURL:      \"http://local.gitlab.test:8181/root/merge-train-race-condition/-/merge_requests/59\",\n\t\t\t},\n\t\t\tUser: &BasicUser{\n\t\t\t\tID:        1,\n\t\t\t\tName:      \"Administrator\",\n\t\t\t\tUsername:  \"root\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://local.gitlab.test:8181/root\",\n\t\t\t},\n\t\t\tPipeline: &Pipeline{\n\t\t\t\tID:        246,\n\t\t\t\tSHA:       \"bcc17a8ffd51be1afe45605e714085df28b80b13\",\n\t\t\t\tRef:       \"refs/merge-requests/59/train\",\n\t\t\t\tStatus:    \"success\",\n\t\t\t\tCreatedAt: &pipelineCreatedAt,\n\t\t\t\tUpdatedAt: &pipelineUpdatedAt,\n\t\t\t\tWebURL:    \"http://local.gitlab.test:8181/root/merge-train-race-condition/pipelines/246\",\n\t\t\t},\n\t\t\tCreatedAt:    &mergeTrainCreatedAt,\n\t\t\tUpdatedAt:    &mergeTrainUpdatedAt,\n\t\t\tTargetBranch: \"feature-1580973432\",\n\t\t\tStatus:       \"merged\",\n\t\t\tMergedAt:     &mergeTrainMergedAt,\n\t\t\tDuration:     70,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, mergeTrains) {\n\t\tt.Errorf(\"MergeTrains.ListProjectMergeTrains returned %+v, want %+v\", mergeTrains, want)\n\t}\n}\n\nfunc TestListMergeRequestInMergeTrain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/597/merge_trains/main\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_merge_requests_in_merge_train.json\")\n\t})\n\n\topts := &ListMergeTrainsOptions{}\n\n\tmergeTrains, _, err := client.MergeTrains.ListMergeRequestInMergeTrain(597, \"main\", opts)\n\tif err != nil {\n\t\tt.Errorf(\"MergeTrains.ListMergeRequestInMergeTrain returned error: %v\", err)\n\t}\n\n\tmergeRequestCreatedAt := time.Date(2022, 10, 31, 19, 6, 5, 725000000, time.UTC)\n\tmergeRequestUpdatedAt := time.Date(2022, 10, 31, 19, 6, 5, 725000000, time.UTC)\n\n\tpipelineCreatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 231000000, time.UTC)\n\tpipelineUpdatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 231000000, time.UTC)\n\n\tmergeTrainCreatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 237000000, time.UTC)\n\tmergeTrainUpdatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 237000000, time.UTC)\n\n\twant := []*MergeTrain{\n\t\t{\n\t\t\tID: 267,\n\t\t\tMergeRequest: &MergeTrainMergeRequest{\n\t\t\t\tID:          273,\n\t\t\t\tIID:         1,\n\t\t\t\tProjectID:   597,\n\t\t\t\tTitle:       \"My title 9\",\n\t\t\t\tDescription: \"\",\n\t\t\t\tState:       \"opened\",\n\t\t\t\tCreatedAt:   &mergeRequestCreatedAt,\n\t\t\t\tUpdatedAt:   &mergeRequestUpdatedAt,\n\t\t\t\tWebURL:      \"http://localhost/namespace18/project21/-/merge_requests/1\",\n\t\t\t},\n\t\t\tUser: &BasicUser{\n\t\t\t\tID:        933,\n\t\t\t\tUsername:  \"user12\",\n\t\t\t\tName:      \"Sidney Jones31\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/6c8365de387cb3db10ecc7b1880203c4?s=80\\u0026d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/user12\",\n\t\t\t},\n\t\t\tPipeline: &Pipeline{\n\t\t\t\tID:        273,\n\t\t\t\tIID:       1,\n\t\t\t\tProjectID: 598,\n\t\t\t\tSHA:       \"b83d6e391c22777fca1ed3012fce84f633d7fed0\",\n\t\t\t\tRef:       \"main\",\n\t\t\t\tStatus:    \"pending\",\n\t\t\t\tSource:    \"push\",\n\t\t\t\tCreatedAt: &pipelineCreatedAt,\n\t\t\t\tUpdatedAt: &pipelineUpdatedAt,\n\t\t\t\tWebURL:    \"http://localhost/namespace19/project22/-/pipelines/273\",\n\t\t\t},\n\t\t\tCreatedAt:    &mergeTrainCreatedAt,\n\t\t\tUpdatedAt:    &mergeTrainUpdatedAt,\n\t\t\tTargetBranch: \"main\",\n\t\t\tStatus:       \"idle\",\n\t\t\tMergedAt:     nil,\n\t\t\tDuration:     0,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, mergeTrains) {\n\t\tt.Errorf(\"MergeTrains.ListMergeRequestInMergeTrain returned %+v, want %+v\", mergeTrains, want)\n\t}\n}\n\nfunc TestGetMergeRequestOnAMergeTrain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/597/merge_trains/merge_requests/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_merge_request_in_merge_train.json\")\n\t})\n\n\tmergeTrain, _, err := client.MergeTrains.GetMergeRequestOnAMergeTrain(597, 1)\n\tif err != nil {\n\t\tt.Errorf(\"MergeTrains.GetMergeRequestOnAMergeTrain returned error: %v\", err)\n\t}\n\n\tmergeRequestCreatedAt := time.Date(2022, 10, 31, 19, 6, 5, 725000000, time.UTC)\n\tmergeRequestUpdatedAt := time.Date(2022, 10, 31, 19, 6, 5, 725000000, time.UTC)\n\n\tpipelineCreatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 231000000, time.UTC)\n\tpipelineUpdatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 231000000, time.UTC)\n\n\tmergeTrainCreatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 237000000, time.UTC)\n\tmergeTrainUpdatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 237000000, time.UTC)\n\n\twant := &MergeTrain{\n\t\tID: 267,\n\t\tMergeRequest: &MergeTrainMergeRequest{\n\t\t\tID:          273,\n\t\t\tIID:         1,\n\t\t\tProjectID:   597,\n\t\t\tTitle:       \"My title 9\",\n\t\t\tDescription: \"\",\n\t\t\tState:       \"opened\",\n\t\t\tCreatedAt:   &mergeRequestCreatedAt,\n\t\t\tUpdatedAt:   &mergeRequestUpdatedAt,\n\t\t\tWebURL:      \"http://localhost/namespace18/project21/-/merge_requests/1\",\n\t\t},\n\t\tUser: &BasicUser{\n\t\t\tID:        933,\n\t\t\tUsername:  \"user12\",\n\t\t\tName:      \"Sidney Jones31\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/6c8365de387cb3db10ecc7b1880203c4?s=80\\u0026d=identicon\",\n\t\t\tWebURL:    \"http://localhost/user12\",\n\t\t},\n\t\tPipeline: &Pipeline{\n\t\t\tID:        273,\n\t\t\tIID:       1,\n\t\t\tProjectID: 598,\n\t\t\tSHA:       \"b83d6e391c22777fca1ed3012fce84f633d7fed0\",\n\t\t\tRef:       \"main\",\n\t\t\tStatus:    \"pending\",\n\t\t\tSource:    \"push\",\n\t\t\tCreatedAt: &pipelineCreatedAt,\n\t\t\tUpdatedAt: &pipelineUpdatedAt,\n\t\t\tWebURL:    \"http://localhost/namespace19/project22/-/pipelines/273\",\n\t\t},\n\t\tCreatedAt:    &mergeTrainCreatedAt,\n\t\tUpdatedAt:    &mergeTrainUpdatedAt,\n\t\tTargetBranch: \"main\",\n\t\tStatus:       \"idle\",\n\t\tMergedAt:     nil,\n\t\tDuration:     0,\n\t}\n\n\tif !reflect.DeepEqual(want, mergeTrain) {\n\t\tt.Errorf(\"MergeTrains.GetMergeRequestOnAMergeTrain returned %+v, want %+v\", mergeTrain, want)\n\t}\n}\n\nfunc TestAddMergeRequestToMergeTrain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/597/merge_trains/merge_requests/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/add_merge_request_in_merge_train.json\")\n\t})\n\n\topt := &AddMergeRequestToMergeTrainOptions{WhenPipelineSucceeds: Ptr(true), Squash: Ptr(true)}\n\n\tmergeTrains, _, err := client.MergeTrains.AddMergeRequestToMergeTrain(597, 1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"MergeTrains.AddMergeRequestToMergeTrain returned error: %v\", err)\n\t}\n\n\tmergeRequestCreatedAt := time.Date(2022, 10, 31, 19, 6, 5, 725000000, time.UTC)\n\tmergeRequestUpdatedAt := time.Date(2022, 10, 31, 19, 6, 5, 725000000, time.UTC)\n\n\tpipelineCreatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 231000000, time.UTC)\n\tpipelineUpdatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 231000000, time.UTC)\n\n\tmergeTrainCreatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 237000000, time.UTC)\n\tmergeTrainUpdatedAt := time.Date(2022, 10, 31, 19, 0o6, 0o6, 237000000, time.UTC)\n\n\twant := []*MergeTrain{\n\t\t{\n\t\t\tID: 267,\n\t\t\tMergeRequest: &MergeTrainMergeRequest{\n\t\t\t\tID:          273,\n\t\t\t\tIID:         1,\n\t\t\t\tProjectID:   597,\n\t\t\t\tTitle:       \"My title 9\",\n\t\t\t\tDescription: \"\",\n\t\t\t\tState:       \"opened\",\n\t\t\t\tCreatedAt:   &mergeRequestCreatedAt,\n\t\t\t\tUpdatedAt:   &mergeRequestUpdatedAt,\n\t\t\t\tWebURL:      \"http://localhost/namespace18/project21/-/merge_requests/1\",\n\t\t\t},\n\t\t\tUser: &BasicUser{\n\t\t\t\tID:        933,\n\t\t\t\tUsername:  \"user12\",\n\t\t\t\tName:      \"Sidney Jones31\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/6c8365de387cb3db10ecc7b1880203c4?s=80\\u0026d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/user12\",\n\t\t\t},\n\t\t\tPipeline: &Pipeline{\n\t\t\t\tID:        273,\n\t\t\t\tIID:       1,\n\t\t\t\tProjectID: 598,\n\t\t\t\tSHA:       \"b83d6e391c22777fca1ed3012fce84f633d7fed0\",\n\t\t\t\tRef:       \"main\",\n\t\t\t\tStatus:    \"pending\",\n\t\t\t\tSource:    \"push\",\n\t\t\t\tCreatedAt: &pipelineCreatedAt,\n\t\t\t\tUpdatedAt: &pipelineUpdatedAt,\n\t\t\t\tWebURL:    \"http://localhost/namespace19/project22/-/pipelines/273\",\n\t\t\t},\n\t\t\tCreatedAt:    &mergeTrainCreatedAt,\n\t\t\tUpdatedAt:    &mergeTrainUpdatedAt,\n\t\t\tTargetBranch: \"main\",\n\t\t\tStatus:       \"idle\",\n\t\t\tMergedAt:     nil,\n\t\t\tDuration:     0,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, mergeTrains) {\n\t\tt.Errorf(\"MergeTrains.AddMergeRequestToMergeTrain returned %+v, want %+v\", mergeTrains, want)\n\t}\n}\n"
        },
        {
          "name": "metadata.go",
          "type": "blob",
          "size": 1.8662109375,
          "content": "//\n// Copyright 2022, Timo Furrer <tuxtimo@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport \"net/http\"\n\n// MetadataService handles communication with the GitLab server instance to\n// retrieve its metadata information via the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/metadata.html\ntype MetadataService struct {\n\tclient *Client\n}\n\n// Metadata represents a GitLab instance version.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/metadata.html\ntype Metadata struct {\n\tVersion  string `json:\"version\"`\n\tRevision string `json:\"revision\"`\n\tKAS      struct {\n\t\tEnabled             bool   `json:\"enabled\"`\n\t\tExternalURL         string `json:\"externalUrl\"`\n\t\tExternalK8SProxyURL string `json:\"externalK8sProxyUrl\"`\n\t\tVersion             string `json:\"version\"`\n\t} `json:\"kas\"`\n\tEnterprise bool `json:\"enterprise\"`\n}\n\nfunc (s Metadata) String() string {\n\treturn Stringify(s)\n}\n\n// GetMetadata gets a GitLab server instance meteadata.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/metadata.html\nfunc (s *MetadataService) GetMetadata(options ...RequestOptionFunc) (*Metadata, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"metadata\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(Metadata)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n"
        },
        {
          "name": "metadata_test.go",
          "type": "blob",
          "size": 1.9375,
          "content": "//\n// Copyright 2022, Timo Furrer <tuxtimo@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetMetadata(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/metadata\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\n        \"version\": \"15.6.0-pre\",\n        \"revision\": \"016e8d8bdc3\",\n        \"enterprise\": true,\n        \"kas\": {\n          \"enabled\": true,\n          \"externalUrl\": \"wss://kas.gitlab.example.com\",\n          \"externalK8sProxyUrl\": \"https://kas.gitlab.example.com/k8s-proxy\",\n          \"version\": \"15.6.0-rc2\"\n        }\n      }`)\n\t\t})\n\n\tversion, _, err := client.Metadata.GetMetadata()\n\tif err != nil {\n\t\tt.Errorf(\"Metadata.GetMetadata returned error: %v\", err)\n\t}\n\n\twant := &Metadata{\n\t\tVersion: \"15.6.0-pre\", Revision: \"016e8d8bdc3\", KAS: struct {\n\t\t\tEnabled             bool   `json:\"enabled\"`\n\t\t\tExternalURL         string `json:\"externalUrl\"`\n\t\t\tExternalK8SProxyURL string `json:\"externalK8sProxyUrl\"`\n\t\t\tVersion             string `json:\"version\"`\n\t\t}{\n\t\t\tEnabled:             true,\n\t\t\tExternalURL:         \"wss://kas.gitlab.example.com\",\n\t\t\tExternalK8SProxyURL: \"https://kas.gitlab.example.com/k8s-proxy\",\n\t\t\tVersion:             \"15.6.0-rc2\",\n\t\t},\n\t\tEnterprise: true,\n\t}\n\tif !reflect.DeepEqual(want, version) {\n\t\tt.Errorf(\"Metadata.GetMetadata returned %+v, want %+v\", version, want)\n\t}\n}\n"
        },
        {
          "name": "milestones.go",
          "type": "blob",
          "size": 8.5859375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// MilestonesService handles communication with the milestone related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/milestones.html\ntype MilestonesService struct {\n\tclient *Client\n}\n\n// Milestone represents a GitLab milestone.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/milestones.html\ntype Milestone struct {\n\tID          int        `json:\"id\"`\n\tIID         int        `json:\"iid\"`\n\tGroupID     int        `json:\"group_id\"`\n\tProjectID   int        `json:\"project_id\"`\n\tTitle       string     `json:\"title\"`\n\tDescription string     `json:\"description\"`\n\tStartDate   *ISOTime   `json:\"start_date\"`\n\tDueDate     *ISOTime   `json:\"due_date\"`\n\tState       string     `json:\"state\"`\n\tWebURL      string     `json:\"web_url\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tExpired     *bool      `json:\"expired\"`\n}\n\nfunc (m Milestone) String() string {\n\treturn Stringify(m)\n}\n\n// ListMilestonesOptions represents the available ListMilestones() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#list-project-milestones\ntype ListMilestonesOptions struct {\n\tListOptions\n\tIIDs                    *[]int  `url:\"iids[],omitempty\" json:\"iids,omitempty\"`\n\tTitle                   *string `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tState                   *string `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tSearch                  *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIncludeParentMilestones *bool   `url:\"include_parent_milestones,omitempty\" json:\"include_parent_milestones,omitempty\"`\n}\n\n// ListMilestones returns a list of project milestones.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#list-project-milestones\nfunc (s *MilestonesService) ListMilestones(pid interface{}, opt *ListMilestonesOptions, options ...RequestOptionFunc) ([]*Milestone, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*Milestone\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// GetMilestone gets a single project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#get-single-milestone\nfunc (s *MilestonesService) GetMilestone(pid interface{}, milestone int, options ...RequestOptionFunc) (*Milestone, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones/%d\", PathEscape(project), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(Milestone)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// CreateMilestoneOptions represents the available CreateMilestone() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#create-new-milestone\ntype CreateMilestoneOptions struct {\n\tTitle       *string  `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription *string  `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tStartDate   *ISOTime `url:\"start_date,omitempty\" json:\"start_date,omitempty\"`\n\tDueDate     *ISOTime `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n}\n\n// CreateMilestone creates a new project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#create-new-milestone\nfunc (s *MilestonesService) CreateMilestone(pid interface{}, opt *CreateMilestoneOptions, options ...RequestOptionFunc) (*Milestone, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(Milestone)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// UpdateMilestoneOptions represents the available UpdateMilestone() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#edit-milestone\ntype UpdateMilestoneOptions struct {\n\tTitle       *string  `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription *string  `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tStartDate   *ISOTime `url:\"start_date,omitempty\" json:\"start_date,omitempty\"`\n\tDueDate     *ISOTime `url:\"due_date,omitempty\" json:\"due_date,omitempty\"`\n\tStateEvent  *string  `url:\"state_event,omitempty\" json:\"state_event,omitempty\"`\n}\n\n// UpdateMilestone updates an existing project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#edit-milestone\nfunc (s *MilestonesService) UpdateMilestone(pid interface{}, milestone int, opt *UpdateMilestoneOptions, options ...RequestOptionFunc) (*Milestone, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones/%d\", PathEscape(project), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tm := new(Milestone)\n\tresp, err := s.client.Do(req, m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// DeleteMilestone deletes a specified project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#delete-project-milestone\nfunc (s *MilestonesService) DeleteMilestone(pid interface{}, milestone int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones/%d\", PathEscape(project), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.client.Do(req, nil)\n}\n\n// GetMilestoneIssuesOptions represents the available GetMilestoneIssues() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#get-all-issues-assigned-to-a-single-milestone\ntype GetMilestoneIssuesOptions ListOptions\n\n// GetMilestoneIssues gets all issues assigned to a single project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#get-all-issues-assigned-to-a-single-milestone\nfunc (s *MilestonesService) GetMilestoneIssues(pid interface{}, milestone int, opt *GetMilestoneIssuesOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones/%d/issues\", PathEscape(project), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar i []*Issue\n\tresp, err := s.client.Do(req, &i)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn i, resp, nil\n}\n\n// GetMilestoneMergeRequestsOptions represents the available\n// GetMilestoneMergeRequests() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#get-all-merge-requests-assigned-to-a-single-milestone\ntype GetMilestoneMergeRequestsOptions ListOptions\n\n// GetMilestoneMergeRequests gets all merge requests assigned to a single\n// project milestone.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/milestones.html#get-all-merge-requests-assigned-to-a-single-milestone\nfunc (s *MilestonesService) GetMilestoneMergeRequests(pid interface{}, milestone int, opt *GetMilestoneMergeRequestsOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/milestones/%d/merge_requests\", PathEscape(project), milestone)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mr []*MergeRequest\n\tresp, err := s.client.Do(req, &mr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mr, resp, nil\n}\n"
        },
        {
          "name": "milestones_test.go",
          "type": "blob",
          "size": 15.5654296875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestMilestonesService_ListMilestones(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/milestones\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 12,\n\t\t\t\t\"iid\": 3,\n\t\t\t\t\"project_id\": 16,\n\t\t\t\t\"title\": \"10.0\",\n\t\t\t\t\"description\": \"Version\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"expired\": false\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Milestone{{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tProjectID:   16,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tWebURL:      \"\",\n\t\tExpired:     Ptr(false),\n\t}}\n\n\tms, resp, err := client.Milestones.ListMilestones(5, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ms)\n\n\tms, resp, err = client.Milestones.ListMilestones(5.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ms)\n\n\tms, resp, err = client.Milestones.ListMilestones(5, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ms)\n\n\tms, resp, err = client.Milestones.ListMilestones(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ms)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestMilestonesService_GetMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/milestones/12\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 12,\n\t\t\t\"iid\": 3,\n\t\t\t\"project_id\": 16,\n\t\t\t\"title\": \"10.0\",\n\t\t\t\"description\": \"Version\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"expired\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Milestone{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tProjectID:   16,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tWebURL:      \"\",\n\t\tExpired:     Ptr(false),\n\t}\n\n\tm, resp, err := client.Milestones.GetMilestone(5, 12, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, m)\n\n\tm, resp, err = client.Milestones.GetMilestone(5.01, 12, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, m)\n\n\tm, resp, err = client.Milestones.GetMilestone(5, 12, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, m)\n\n\tm, resp, err = client.Milestones.GetMilestone(3, 12, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, m)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestMilestonesService_CreateMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/milestones\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 12,\n\t\t\t\"iid\": 3,\n\t\t\t\"project_id\": 16,\n\t\t\t\"title\": \"10.0\",\n\t\t\t\"description\": \"Version\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"expired\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Milestone{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tProjectID:   16,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tWebURL:      \"\",\n\t\tExpired:     Ptr(false),\n\t}\n\n\tm, resp, err := client.Milestones.CreateMilestone(5, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, m)\n\n\tm, resp, err = client.Milestones.CreateMilestone(5.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, m)\n\n\tm, resp, err = client.Milestones.CreateMilestone(5, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, m)\n\n\tm, resp, err = client.Milestones.CreateMilestone(3, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, m)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestMilestonesService_UpdateMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/milestones/12\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"id\": 12,\n\t\t\t\"iid\": 3,\n\t\t\t\"project_id\": 16,\n\t\t\t\"title\": \"10.0\",\n\t\t\t\"description\": \"Version\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"expired\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Milestone{\n\t\tID:          12,\n\t\tIID:         3,\n\t\tProjectID:   16,\n\t\tTitle:       \"10.0\",\n\t\tDescription: \"Version\",\n\t\tState:       \"active\",\n\t\tWebURL:      \"\",\n\t\tExpired:     Ptr(false),\n\t}\n\n\tm, resp, err := client.Milestones.UpdateMilestone(5, 12, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, m)\n\n\tm, resp, err = client.Milestones.UpdateMilestone(5.01, 12, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, m)\n\n\tm, resp, err = client.Milestones.UpdateMilestone(5, 12, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, m)\n\n\tm, resp, err = client.Milestones.UpdateMilestone(3, 12, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, m)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestMilestonesService_DeleteMilestone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/milestones/12\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Milestones.DeleteMilestone(5, 12, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Milestones.DeleteMilestone(5.01, 12, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Milestones.DeleteMilestone(5, 12, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Milestones.DeleteMilestone(3, 12, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestMilestonesService_GetMilestoneIssues(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/milestones/12/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t   {\n\t\t\t\t  \"project_id\" : 5,\n\t\t\t\t  \"milestone\" : {\n\t\t\t\t\t \"due_date\" : null,\n\t\t\t\t\t \"project_id\" : 5,\n\t\t\t\t\t \"state\" : \"closed\",\n\t\t\t\t\t \"description\" : \"Rerum est voluptatem provident consequuntur molestias similique ipsum dolor.\",\n\t\t\t\t\t \"iid\" : 3,\n\t\t\t\t\t \"id\" : 11,\n\t\t\t\t\t \"title\" : \"v3.0\"\n\t\t\t\t  },\n\t\t\t\t  \"author\" : {\n\t\t\t\t\t \"state\" : \"active\",\n\t\t\t\t\t \"web_url\" : \"https://gitlab.example.com/root\",\n\t\t\t\t\t \"avatar_url\" : null,\n\t\t\t\t\t \"username\" : \"root\",\n\t\t\t\t\t \"id\" : 1,\n\t\t\t\t\t \"name\" : \"Administrator\"\n\t\t\t\t  },\n\t\t\t\t  \"description\" : \"Omnis vero earum sunt corporis dolor et placeat.\",\n\t\t\t\t  \"state\" : \"closed\",\n\t\t\t\t  \"iid\" : 1,\n\t\t\t\t  \"assignees\" : [{\n\t\t\t\t\t \"avatar_url\" : null,\n\t\t\t\t\t \"web_url\" : \"https://gitlab.example.com/venky333\",\n\t\t\t\t\t \"state\" : \"active\",\n\t\t\t\t\t \"username\" : \"venky333\",\n\t\t\t\t\t \"id\" : 9,\n\t\t\t\t\t \"name\" : \"Venkatesh Thalluri\"\n\t\t\t\t  }],\n\t\t\t\t  \"assignee\" : {\n\t\t\t\t\t \"avatar_url\" : null,\n\t\t\t\t\t \"web_url\" : \"https://gitlab.example.com/venky333\",\n\t\t\t\t\t \"state\" : \"active\",\n\t\t\t\t\t \"username\" : \"venky333\",\n\t\t\t\t\t \"id\" : 9,\n\t\t\t\t\t \"name\" : \"Venkatesh Thalluri\"\n\t\t\t\t  },\n\t\t\t\t  \"id\" : 41\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Issue{{\n\t\tID:          41,\n\t\tIID:         1,\n\t\tExternalID:  \"\",\n\t\tState:       \"closed\",\n\t\tDescription: \"Omnis vero earum sunt corporis dolor et placeat.\",\n\t\tAuthor: &IssueAuthor{\n\t\t\tID:        1,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"root\",\n\t\t},\n\t\tMilestone: &Milestone{\n\t\t\tID:          11,\n\t\t\tIID:         3,\n\t\t\tProjectID:   5,\n\t\t\tTitle:       \"v3.0\",\n\t\t\tDescription: \"Rerum est voluptatem provident consequuntur molestias similique ipsum dolor.\",\n\t\t\tStartDate:   nil,\n\t\t\tDueDate:     nil,\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"\",\n\t\t\tUpdatedAt:   nil,\n\t\t\tCreatedAt:   nil,\n\t\t\tExpired:     nil,\n\t\t},\n\t\tProjectID: 5,\n\t\tAssignees: []*IssueAssignee{{\n\t\t\tID:        9,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/venky333\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"venky333\",\n\t\t}},\n\t\tAssignee: &IssueAssignee{\n\t\t\tID:        9,\n\t\t\tState:     \"active\",\n\t\t\tWebURL:    \"https://gitlab.example.com/venky333\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tAvatarURL: \"\",\n\t\t\tUsername:  \"venky333\",\n\t\t},\n\t}}\n\n\tis, resp, err := client.Milestones.GetMilestoneIssues(5, 12, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, is)\n\n\tis, resp, err = client.Milestones.GetMilestoneIssues(5.01, 12, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.Milestones.GetMilestoneIssues(5, 12, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, is)\n\n\tis, resp, err = client.Milestones.GetMilestoneIssues(3, 12, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, is)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestMilestonesService_GetMilestoneMergeRequests(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/3/milestones/12/merge_requests\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"iid\": 1,\n\t\t\t\t\"project_id\": 3,\n\t\t\t\t\"title\": \"test1\",\n\t\t\t\t\"description\": \"fixed login page css paddings\",\n\t\t\t\t\"state\": \"merged\",\n\t\t\t\t\"merged_by\": {\n\t\t\t\t  \"id\": 87854,\n\t\t\t\t  \"name\": \"Douwe Maan\",\n\t\t\t\t  \"username\": \"DouweM\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://gitlab.example.com/uploads/-/system/user/avatar/87854/avatar.png\",\n\t\t\t\t  \"web_url\": \"https://gitlab.com/DouweM\"\n\t\t\t\t},\n\t\t\t\t\"closed_by\": null,\n\t\t\t\t\"closed_at\": null,\n\t\t\t\t\"target_branch\": \"master\",\n\t\t\t\t\"source_branch\": \"test1\",\n\t\t\t\t\"upvotes\": 0,\n\t\t\t\t\"downvotes\": 0,\n\t\t\t\t\"author\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"admin\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": null,\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/admin\"\n\t\t\t\t},\n\t\t\t\t\"assignee\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"admin\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": null,\n\t\t\t\t  \"web_url\" : \"https://gitlab.example.com/admin\"\n\t\t\t\t},\n\t\t\t\t\"assignees\": [{\n\t\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"username\": \"venkatesh.thalluri\",\n\t\t\t\t  \"id\": 12,\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"http://www.gravatar.com/avatar/46f6f7dc858ada7be1853f7fb96e81da?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/axel.block\"\n\t\t\t\t}],\n\t\t\t\t\"reviewers\": [{\n\t\t\t\t  \"id\": 2,\n\t\t\t\t  \"name\": \"Sam Bauch\",\n\t\t\t\t  \"username\": \"kenyatta_oconnell\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/956c92487c6f6f7616b536927e22c9a0?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com//kenyatta_oconnell\"\n\t\t\t\t}],\n\t\t\t\t\"source_project_id\": 2,\n\t\t\t\t\"target_project_id\": 3,\n\t\t\t\t\"draft\": false,\n\t\t\t\t\"work_in_progress\": false,\n\t\t\t\t\"milestone\": {\n\t\t\t\t  \"id\": 5,\n\t\t\t\t  \"iid\": 1,\n\t\t\t\t  \"project_id\": 3,\n\t\t\t\t  \"title\": \"v2.0\",\n\t\t\t\t  \"description\": \"Assumenda aut placeat expedita exercitationem labore sunt enim earum.\",\n\t\t\t\t  \"state\": \"closed\",\n\t\t\t\t  \"web_url\": \"https://gitlab.example.com/my-group/my-project/milestones/1\"\n\t\t\t\t},\n\t\t\t\t\"merge_when_pipeline_succeeds\": true,\n\t\t\t\t\"detailed_merge_status\": \"mergeable\",\n\t\t\t\t\"sha\": \"8888888888888888888888888888888888888888\",\n\t\t\t\t\"merge_commit_sha\": null,\n\t\t\t\t\"squash_commit_sha\": null,\n\t\t\t\t\"user_notes_count\": 1,\n\t\t\t\t\"discussion_locked\": null,\n\t\t\t\t\"should_remove_source_branch\": true,\n\t\t\t\t\"force_remove_source_branch\": false,\n\t\t\t\t\"allow_collaboration\": false,\n\t\t\t\t\"allow_maintainer_to_push\": false,\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/my-group/my-project/merge_requests/1\",\n\t\t\t\t\"references\": {\n\t\t\t\t  \"short\": \"!1\",\n\t\t\t\t  \"relative\": \"my-group/my-project!1\",\n\t\t\t\t  \"full\": \"my-group/my-project!1\"\n\t\t\t\t},\n\t\t\t\t\"squash\": false,\n\t\t\t\t\"task_completion_status\":{\n\t\t\t\t  \"count\":0,\n\t\t\t\t  \"completed_count\":0\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*MergeRequest{{\n\t\tID:           1,\n\t\tIID:          1,\n\t\tTargetBranch: \"master\",\n\t\tSourceBranch: \"test1\",\n\t\tProjectID:    3,\n\t\tTitle:        \"test1\",\n\t\tState:        \"merged\",\n\t\tUpvotes:      0,\n\t\tDownvotes:    0,\n\t\tAuthor: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"admin\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tCreatedAt: nil,\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"https://gitlab.example.com/admin\",\n\t\t},\n\t\tAssignee: &BasicUser{\n\t\t\tID: 1, Username: \"admin\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"\",\n\t\t\tWebURL:    \"https://gitlab.example.com/admin\",\n\t\t},\n\t\tAssignees: []*BasicUser{{\n\t\t\tID:        12,\n\t\t\tUsername:  \"venkatesh.thalluri\",\n\t\t\tName:      \"Venkatesh Thalluri\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"http://www.gravatar.com/avatar/46f6f7dc858ada7be1853f7fb96e81da?s=80&d=identicon\", WebURL: \"https://gitlab.example.com/axel.block\",\n\t\t}},\n\t\tReviewers: []*BasicUser{{\n\t\t\tID:        2,\n\t\t\tUsername:  \"kenyatta_oconnell\",\n\t\t\tName:      \"Sam Bauch\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/956c92487c6f6f7616b536927e22c9a0?s=80&d=identicon\", WebURL: \"http://gitlab.example.com//kenyatta_oconnell\",\n\t\t}},\n\t\tSourceProjectID: 2,\n\t\tTargetProjectID: 3,\n\t\tDescription:     \"fixed login page css paddings\",\n\t\tWorkInProgress:  false,\n\t\tMilestone: &Milestone{\n\t\t\tID:          5,\n\t\t\tIID:         1,\n\t\t\tProjectID:   3,\n\t\t\tTitle:       \"v2.0\",\n\t\t\tDescription: \"Assumenda aut placeat expedita exercitationem labore sunt enim earum.\",\n\t\t\tState:       \"closed\",\n\t\t\tWebURL:      \"https://gitlab.example.com/my-group/my-project/milestones/1\",\n\t\t},\n\t\tMergeWhenPipelineSucceeds: true,\n\t\tDetailedMergeStatus:       \"mergeable\",\n\t\tMergeError:                \"\",\n\t\tMergedBy: &BasicUser{\n\t\t\tID:        87854,\n\t\t\tUsername:  \"DouweM\",\n\t\t\tName:      \"Douwe Maan\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://gitlab.example.com/uploads/-/system/user/avatar/87854/avatar.png\",\n\t\t\tWebURL:    \"https://gitlab.com/DouweM\",\n\t\t},\n\t\tSubscribed:               false,\n\t\tSHA:                      \"8888888888888888888888888888888888888888\",\n\t\tMergeCommitSHA:           \"\",\n\t\tSquashCommitSHA:          \"\",\n\t\tUserNotesCount:           1,\n\t\tChangesCount:             \"\",\n\t\tShouldRemoveSourceBranch: true,\n\t\tForceRemoveSourceBranch:  false,\n\t\tAllowCollaboration:       false,\n\t\tWebURL:                   \"http://gitlab.example.com/my-group/my-project/merge_requests/1\",\n\t\tReferences: &IssueReferences{\n\t\t\tShort:    \"!1\",\n\t\t\tRelative: \"my-group/my-project!1\",\n\t\t\tFull:     \"my-group/my-project!1\",\n\t\t},\n\t\tDiscussionLocked:     false,\n\t\tSquash:               false,\n\t\tDivergedCommitsCount: 0,\n\t\tRebaseInProgress:     false,\n\t\tApprovalsBeforeMerge: 0,\n\t\tReference:            \"\",\n\t\tFirstContribution:    false,\n\t\tTaskCompletionStatus: &TasksCompletionStatus{\n\t\t\tCount:          0,\n\t\t\tCompletedCount: 0,\n\t\t},\n\t\tHasConflicts:                false,\n\t\tBlockingDiscussionsResolved: false,\n\t\tOverflow:                    false,\n\t}}\n\n\tmrs, resp, err := client.Milestones.GetMilestoneMergeRequests(3, 12, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, mrs)\n\n\tmrs, resp, err = client.Milestones.GetMilestoneMergeRequests(3.01, 12, nil)\n\trequire.EqualError(t, err, \"invalid ID type 3.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, mrs)\n\n\tmrs, resp, err = client.Milestones.GetMilestoneMergeRequests(3, 12, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, mrs)\n\n\tmrs, resp, err = client.Milestones.GetMilestoneMergeRequests(5, 12, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, mrs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "namespaces.go",
          "type": "blob",
          "size": 5.23828125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// NamespacesService handles communication with the namespace related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/namespaces.html\ntype NamespacesService struct {\n\tclient *Client\n}\n\n// Namespace represents a GitLab namespace.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/namespaces.html\ntype Namespace struct {\n\tID                          int      `json:\"id\"`\n\tName                        string   `json:\"name\"`\n\tPath                        string   `json:\"path\"`\n\tKind                        string   `json:\"kind\"`\n\tFullPath                    string   `json:\"full_path\"`\n\tParentID                    int      `json:\"parent_id\"`\n\tAvatarURL                   *string  `json:\"avatar_url\"`\n\tWebURL                      string   `json:\"web_url\"`\n\tMembersCountWithDescendants int      `json:\"members_count_with_descendants\"`\n\tBillableMembersCount        int      `json:\"billable_members_count\"`\n\tPlan                        string   `json:\"plan\"`\n\tTrialEndsOn                 *ISOTime `json:\"trial_ends_on\"`\n\tTrial                       bool     `json:\"trial\"`\n\tMaxSeatsUsed                *int     `json:\"max_seats_used\"`\n\tSeatsInUse                  *int     `json:\"seats_in_use\"`\n}\n\nfunc (n Namespace) String() string {\n\treturn Stringify(n)\n}\n\n// ListNamespacesOptions represents the available ListNamespaces() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/namespaces.html#list-namespaces\ntype ListNamespacesOptions struct {\n\tListOptions\n\tSearch    *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tOwnedOnly *bool   `url:\"owned_only,omitempty\" json:\"owned_only,omitempty\"`\n}\n\n// ListNamespaces gets a list of projects accessible by the authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/namespaces.html#list-namespaces\nfunc (s *NamespacesService) ListNamespaces(opt *ListNamespacesOptions, options ...RequestOptionFunc) ([]*Namespace, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"namespaces\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*Namespace\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// SearchNamespace gets all namespaces that match your string in their name\n// or path.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/namespaces.html#list-namespaces\nfunc (s *NamespacesService) SearchNamespace(query string, options ...RequestOptionFunc) ([]*Namespace, *Response, error) {\n\tvar q struct {\n\t\tSearch string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\t}\n\tq.Search = query\n\n\treq, err := s.client.NewRequest(http.MethodGet, \"namespaces\", &q, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*Namespace\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// GetNamespace gets a namespace by id.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/namespaces.html#get-namespace-by-id\nfunc (s *NamespacesService) GetNamespace(id interface{}, options ...RequestOptionFunc) (*Namespace, *Response, error) {\n\tnamespace, err := parseID(id)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"namespaces/%s\", PathEscape(namespace))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Namespace)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// NamespaceExistance represents a namespace exists result.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/namespaces.html#get-existence-of-a-namespace\ntype NamespaceExistance struct {\n\tExists   bool     `json:\"exists\"`\n\tSuggests []string `json:\"suggests\"`\n}\n\n// NamespaceExistsOptions represents the available NamespaceExists() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/namespaces.html#get-existence-of-a-namespace\ntype NamespaceExistsOptions struct {\n\tParentID *int `url:\"parent_id,omitempty\" json:\"parent_id,omitempty\"`\n}\n\n// NamespaceExists checks the existence of a namespace.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/namespaces.html#get-existence-of-a-namespace\nfunc (s *NamespacesService) NamespaceExists(id interface{}, opt *NamespaceExistsOptions, options ...RequestOptionFunc) (*NamespaceExistance, *Response, error) {\n\tnamespace, err := parseID(id)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"namespaces/%s/exists\", namespace)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(NamespaceExistance)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n"
        },
        {
          "name": "namespaces_test.go",
          "type": "blob",
          "size": 8.7802734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListNamespaces(t *testing.T) {\n\tmux, client := setup(t)\n\n\ttrialEndsOn, _ := time.Parse(time.RFC3339, \"2022-05-08T00:00:00Z\")\n\ttrialEndsOnISOTime := ISOTime(trialEndsOn)\n\n\tmux.HandleFunc(\"/api/v4/namespaces\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"user1\",\n\t\t\t  \"path\": \"user1\",\n\t\t\t  \"kind\": \"user\",\n\t\t\t  \"full_path\": \"user1\",\n\t\t\t  \"avatar_url\": \"https://secure.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"https://gitlab.example.com/user1\",\n\t\t\t  \"billable_members_count\": 1,\n\t\t\t  \"plan\": \"default\",\n\t\t\t  \"trial_ends_on\": null,\n\t\t\t  \"trial\": false\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 2,\n\t\t\t  \"name\": \"group1\",\n\t\t\t  \"path\": \"group1\",\n\t\t\t  \"kind\": \"group\",\n\t\t\t  \"full_path\": \"group1\",\n\t\t\t  \"web_url\": \"https://gitlab.example.com/groups/group1\",\n\t\t\t  \"members_count_with_descendants\": 2,\n\t\t\t  \"billable_members_count\": 2,\n\t\t\t  \"plan\": \"default\",\n\t\t\t  \"trial_ends_on\": null,\n\t\t\t  \"trial\": false\n\t\t\t},\n\t\t\t{\n\t\t\t  \"id\": 3,\n\t\t\t  \"name\": \"bar\",\n\t\t\t  \"path\": \"bar\",\n\t\t\t  \"kind\": \"group\",\n\t\t\t  \"full_path\": \"foo/bar\",\n\t\t\t  \"parent_id\": 9,\n\t\t\t  \"web_url\": \"https://gitlab.example.com/groups/foo/bar\",\n\t\t\t  \"members_count_with_descendants\": 5,\n\t\t\t  \"billable_members_count\": 5,\n\t\t\t  \"plan\": \"default\",\n\t\t\t  \"trial_ends_on\": null,\n\t\t\t  \"trial\": false\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"id\": 4,\n\t\t\t\t\"name\": \"group2\",\n\t\t\t\t\"path\": \"group2\",\n\t\t\t\t\"kind\": \"group\",\n\t\t\t\t\"full_path\": \"group2\",\n\t\t\t\t\"avatar_url\": \"https://gitlab.example.com/groups/group2\",\n\t\t\t\t\"web_url\": \"https://gitlab.example.com/group2\",\n\t\t\t\t\"billable_members_count\": 1,\n\t\t\t\t\"plan\": \"default\",\n\t\t\t\t\"trial_ends_on\": \"2022-05-08\",\n\t\t\t\t\"trial\": true\n\t\t\t  }\n\t\t  ]`)\n\t})\n\n\ttestCases := []struct {\n\t\tevent     string\n\t\tsearch    *string\n\t\townedOnly *bool\n\t}{\n\t\t{\"with_nothing\", nil, nil},\n\t\t{\"with_search\", Ptr(\"foobar\"), nil},\n\t\t{\"with_owned_only\", nil, Ptr(false)},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.event, func(t *testing.T) {\n\t\t\tnamespaces, _, err := client.Namespaces.ListNamespaces(&ListNamespacesOptions{Search: tc.search, OwnedOnly: tc.ownedOnly})\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Namespaces.ListNamespaces returned error: %v\", err)\n\t\t\t}\n\n\t\t\twant := []*Namespace{\n\t\t\t\t{\n\t\t\t\t\tID:                   1,\n\t\t\t\t\tName:                 \"user1\",\n\t\t\t\t\tPath:                 \"user1\",\n\t\t\t\t\tKind:                 \"user\",\n\t\t\t\t\tFullPath:             \"user1\",\n\t\t\t\t\tAvatarURL:            Ptr(\"https://secure.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\"),\n\t\t\t\t\tWebURL:               \"https://gitlab.example.com/user1\",\n\t\t\t\t\tPlan:                 \"default\",\n\t\t\t\t\tBillableMembersCount: 1,\n\t\t\t\t\tTrialEndsOn:          nil,\n\t\t\t\t\tTrial:                false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                          2,\n\t\t\t\t\tName:                        \"group1\",\n\t\t\t\t\tPath:                        \"group1\",\n\t\t\t\t\tKind:                        \"group\",\n\t\t\t\t\tFullPath:                    \"group1\",\n\t\t\t\t\tAvatarURL:                   nil,\n\t\t\t\t\tWebURL:                      \"https://gitlab.example.com/groups/group1\",\n\t\t\t\t\tMembersCountWithDescendants: 2,\n\t\t\t\t\tBillableMembersCount:        2,\n\t\t\t\t\tPlan:                        \"default\",\n\t\t\t\t\tTrialEndsOn:                 nil,\n\t\t\t\t\tTrial:                       false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                          3,\n\t\t\t\t\tName:                        \"bar\",\n\t\t\t\t\tPath:                        \"bar\",\n\t\t\t\t\tKind:                        \"group\",\n\t\t\t\t\tFullPath:                    \"foo/bar\",\n\t\t\t\t\tParentID:                    9,\n\t\t\t\t\tAvatarURL:                   nil,\n\t\t\t\t\tWebURL:                      \"https://gitlab.example.com/groups/foo/bar\",\n\t\t\t\t\tMembersCountWithDescendants: 5,\n\t\t\t\t\tBillableMembersCount:        5,\n\t\t\t\t\tPlan:                        \"default\",\n\t\t\t\t\tTrialEndsOn:                 nil,\n\t\t\t\t\tTrial:                       false,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                   4,\n\t\t\t\t\tName:                 \"group2\",\n\t\t\t\t\tPath:                 \"group2\",\n\t\t\t\t\tKind:                 \"group\",\n\t\t\t\t\tFullPath:             \"group2\",\n\t\t\t\t\tAvatarURL:            Ptr(\"https://gitlab.example.com/groups/group2\"),\n\t\t\t\t\tWebURL:               \"https://gitlab.example.com/group2\",\n\t\t\t\t\tPlan:                 \"default\",\n\t\t\t\t\tBillableMembersCount: 1,\n\t\t\t\t\tTrialEndsOn:          &trialEndsOnISOTime,\n\t\t\t\t\tTrial:                true,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tif !reflect.DeepEqual(namespaces, want) {\n\t\t\t\tt.Errorf(\"Namespaces.ListNamespaces returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(namespaces), Stringify(want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestGetNamespace(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/namespaces/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"id\": 2,\n\t\t\t\"name\": \"group1\",\n\t\t\t\"path\": \"group1\",\n\t\t\t\"kind\": \"group\",\n\t\t\t\"full_path\": \"group1\",\n\t\t\t\"avatar_url\": null,\n\t\t\t\"web_url\": \"https://gitlab.example.com/groups/group1\",\n\t\t\t\"members_count_with_descendants\": 2,\n\t\t\t\"billable_members_count\": 2,\n\t\t\t\"max_seats_used\": 0,\n\t\t\t\"seats_in_use\": 0,\n\t\t\t\"plan\": \"default\",\n\t\t\t\"trial_ends_on\": null,\n\t\t\t\"trial\": false\n\t\t  }`)\n\t})\n\n\tnamespace, _, err := client.Namespaces.GetNamespace(2)\n\tif err != nil {\n\t\tt.Errorf(\"Namespaces.GetNamespace returned error: %v\", err)\n\t}\n\n\twant := &Namespace{\n\t\tID:                          2,\n\t\tName:                        \"group1\",\n\t\tPath:                        \"group1\",\n\t\tKind:                        \"group\",\n\t\tFullPath:                    \"group1\",\n\t\tAvatarURL:                   nil,\n\t\tWebURL:                      \"https://gitlab.example.com/groups/group1\",\n\t\tMembersCountWithDescendants: 2,\n\t\tBillableMembersCount:        2,\n\t\tMaxSeatsUsed:                Ptr(0),\n\t\tSeatsInUse:                  Ptr(0),\n\t\tPlan:                        \"default\",\n\t\tTrialEndsOn:                 nil,\n\t\tTrial:                       false,\n\t}\n\n\tif !reflect.DeepEqual(namespace, want) {\n\t\tt.Errorf(\"Namespaces.ListNamespaces returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(namespace), Stringify(want))\n\t}\n}\n\nfunc TestNamespaceExists(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/namespaces/my-group/exists\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"exists\": true,\n\t\t\t\"suggests\": [\n\t\t\t\t\"my-group1\"\n\t\t\t]\n\t\t}`)\n\t})\n\n\topt := &NamespaceExistsOptions{\n\t\tParentID: Ptr(1),\n\t}\n\texists, _, err := client.Namespaces.NamespaceExists(\"my-group\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Namespaces.NamespaceExists returned error: %v\", err)\n\t}\n\n\twant := &NamespaceExistance{\n\t\tExists:   true,\n\t\tSuggests: []string{\"my-group1\"},\n\t}\n\tif !reflect.DeepEqual(exists, want) {\n\t\tt.Errorf(\"Namespaces.NamespaceExists returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(exists), Stringify(want))\n\t}\n}\n\nfunc TestSearchNamespace(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/namespaces\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 4,\n\t\t\t  \"name\": \"twitter\",\n\t\t\t  \"path\": \"twitter\",\n\t\t\t  \"kind\": \"group\",\n\t\t\t  \"full_path\": \"twitter\",\n\t\t\t  \"avatar_url\": null,\n\t\t\t  \"web_url\": \"https://gitlab.example.com/groups/twitter\",\n\t\t\t  \"members_count_with_descendants\": 2,\n\t\t\t  \"billable_members_count\": 2,\n\t\t\t  \"max_seats_used\": 0,\n\t\t\t  \"seats_in_use\": 0,\n\t\t\t  \"plan\": \"default\",\n\t\t\t  \"trial_ends_on\": null,\n\t\t\t  \"trial\": false\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\tnamespaces, _, err := client.Namespaces.SearchNamespace(\"?search=twitter\")\n\tif err != nil {\n\t\tt.Errorf(\"Namespaces.SearchNamespaces returned error: %v\", err)\n\t}\n\n\twant := []*Namespace{\n\t\t{\n\t\t\tID:                          4,\n\t\t\tName:                        \"twitter\",\n\t\t\tPath:                        \"twitter\",\n\t\t\tKind:                        \"group\",\n\t\t\tFullPath:                    \"twitter\",\n\t\t\tAvatarURL:                   nil,\n\t\t\tWebURL:                      \"https://gitlab.example.com/groups/twitter\",\n\t\t\tMembersCountWithDescendants: 2,\n\t\t\tBillableMembersCount:        2,\n\t\t\tMaxSeatsUsed:                Ptr(0),\n\t\t\tSeatsInUse:                  Ptr(0),\n\t\t\tPlan:                        \"default\",\n\t\t\tTrialEndsOn:                 nil,\n\t\t\tTrial:                       false,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(namespaces, want) {\n\t\tt.Errorf(\"Namespaces.SearchNamespaces returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(namespaces), Stringify(want))\n\t}\n}\n"
        },
        {
          "name": "notes.go",
          "type": "blob",
          "size": 20.33984375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// NotesService handles communication with the notes related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/notes.html\ntype NotesService struct {\n\tclient *Client\n}\n\n// Note represents a GitLab note.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/notes.html\ntype Note struct {\n\tID         int           `json:\"id\"`\n\tType       NoteTypeValue `json:\"type\"`\n\tBody       string        `json:\"body\"`\n\tAttachment string        `json:\"attachment\"`\n\tTitle      string        `json:\"title\"`\n\tFileName   string        `json:\"file_name\"`\n\tAuthor     struct {\n\t\tID        int    `json:\"id\"`\n\t\tUsername  string `json:\"username\"`\n\t\tEmail     string `json:\"email\"`\n\t\tName      string `json:\"name\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"author\"`\n\tSystem       bool          `json:\"system\"`\n\tCreatedAt    *time.Time    `json:\"created_at\"`\n\tUpdatedAt    *time.Time    `json:\"updated_at\"`\n\tExpiresAt    *time.Time    `json:\"expires_at\"`\n\tCommitID     string        `json:\"commit_id\"`\n\tPosition     *NotePosition `json:\"position\"`\n\tNoteableID   int           `json:\"noteable_id\"`\n\tNoteableType string        `json:\"noteable_type\"`\n\tProjectID    int           `json:\"project_id\"`\n\tNoteableIID  int           `json:\"noteable_iid\"`\n\tResolvable   bool          `json:\"resolvable\"`\n\tResolved     bool          `json:\"resolved\"`\n\tResolvedAt   *time.Time    `json:\"resolved_at\"`\n\tResolvedBy   struct {\n\t\tID        int    `json:\"id\"`\n\t\tUsername  string `json:\"username\"`\n\t\tEmail     string `json:\"email\"`\n\t\tName      string `json:\"name\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"resolved_by\"`\n\tConfidential bool `json:\"confidential\"`\n\tInternal     bool `json:\"internal\"`\n}\n\n// NotePosition represents the position attributes of a note.\ntype NotePosition struct {\n\tBaseSHA      string     `json:\"base_sha\"`\n\tStartSHA     string     `json:\"start_sha\"`\n\tHeadSHA      string     `json:\"head_sha\"`\n\tPositionType string     `json:\"position_type\"`\n\tNewPath      string     `json:\"new_path,omitempty\"`\n\tNewLine      int        `json:\"new_line,omitempty\"`\n\tOldPath      string     `json:\"old_path,omitempty\"`\n\tOldLine      int        `json:\"old_line,omitempty\"`\n\tLineRange    *LineRange `json:\"line_range,omitempty\"`\n}\n\n// LineRange represents the range of a note.\ntype LineRange struct {\n\tStartRange *LinePosition `json:\"start\"`\n\tEndRange   *LinePosition `json:\"end\"`\n}\n\n// LinePosition represents a position in a line range.\ntype LinePosition struct {\n\tLineCode string `json:\"line_code\"`\n\tType     string `json:\"type\"`\n\tOldLine  int    `json:\"old_line\"`\n\tNewLine  int    `json:\"new_line\"`\n}\n\nfunc (n Note) String() string {\n\treturn Stringify(n)\n}\n\n// ListIssueNotesOptions represents the available ListIssueNotes() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-project-issue-notes\ntype ListIssueNotesOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListIssueNotes gets a list of all notes for a single issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-project-issue-notes\nfunc (s *NotesService) ListIssueNotes(pid interface{}, issue int, opt *ListIssueNotesOptions, options ...RequestOptionFunc) ([]*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/notes\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*Note\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// GetIssueNote returns a single note for a specific project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#get-single-issue-note\nfunc (s *NotesService) GetIssueNote(pid interface{}, issue, note int, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/notes/%d\", PathEscape(project), issue, note)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// CreateIssueNoteOptions represents the available CreateIssueNote()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-issue-note\ntype CreateIssueNoteOptions struct {\n\tBody      *string    `url:\"body,omitempty\" json:\"body,omitempty\"`\n\tCreatedAt *time.Time `url:\"created_at,omitempty\" json:\"created_at,omitempty\"`\n}\n\n// CreateIssueNote creates a new note to a single project issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-issue-note\nfunc (s *NotesService) CreateIssueNote(pid interface{}, issue int, opt *CreateIssueNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/notes\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateIssueNoteOptions represents the available UpdateIssueNote()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-issue-note\ntype UpdateIssueNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// UpdateIssueNote modifies existing note of an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-issue-note\nfunc (s *NotesService) UpdateIssueNote(pid interface{}, issue, note int, opt *UpdateIssueNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/notes/%d\", PathEscape(project), issue, note)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteIssueNote deletes an existing note of an issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#delete-an-issue-note\nfunc (s *NotesService) DeleteIssueNote(pid interface{}, issue, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/notes/%d\", PathEscape(project), issue, note)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListSnippetNotesOptions represents the available ListSnippetNotes() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-all-snippet-notes\ntype ListSnippetNotesOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListSnippetNotes gets a list of all notes for a single snippet. Snippet\n// notes are comments users can post to a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-all-snippet-notes\nfunc (s *NotesService) ListSnippetNotes(pid interface{}, snippet int, opt *ListSnippetNotesOptions, options ...RequestOptionFunc) ([]*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/notes\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*Note\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// GetSnippetNote returns a single note for a given snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#get-single-snippet-note\nfunc (s *NotesService) GetSnippetNote(pid interface{}, snippet, note int, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/notes/%d\", PathEscape(project), snippet, note)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// CreateSnippetNoteOptions represents the available CreateSnippetNote()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-snippet-note\ntype CreateSnippetNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// CreateSnippetNote creates a new note for a single snippet. Snippet notes are\n// comments users can post to a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-snippet-note\nfunc (s *NotesService) CreateSnippetNote(pid interface{}, snippet int, opt *CreateSnippetNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/notes\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateSnippetNoteOptions represents the available UpdateSnippetNote()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-snippet-note\ntype UpdateSnippetNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// UpdateSnippetNote modifies existing note of a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-snippet-note\nfunc (s *NotesService) UpdateSnippetNote(pid interface{}, snippet, note int, opt *UpdateSnippetNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/notes/%d\", PathEscape(project), snippet, note)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteSnippetNote deletes an existing note of a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#delete-a-snippet-note\nfunc (s *NotesService) DeleteSnippetNote(pid interface{}, snippet, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/notes/%d\", PathEscape(project), snippet, note)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListMergeRequestNotesOptions represents the available ListMergeRequestNotes()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-all-merge-request-notes\ntype ListMergeRequestNotesOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListMergeRequestNotes gets a list of all notes for a single merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-all-merge-request-notes\nfunc (s *NotesService) ListMergeRequestNotes(pid interface{}, mergeRequest int, opt *ListMergeRequestNotesOptions, options ...RequestOptionFunc) ([]*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/notes\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*Note\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// GetMergeRequestNote returns a single note for a given merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#get-single-merge-request-note\nfunc (s *NotesService) GetMergeRequestNote(pid interface{}, mergeRequest, note int, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/notes/%d\", PathEscape(project), mergeRequest, note)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// CreateMergeRequestNoteOptions represents the available\n// CreateMergeRequestNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-merge-request-note\ntype CreateMergeRequestNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// CreateMergeRequestNote creates a new note for a single merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-merge-request-note\nfunc (s *NotesService) CreateMergeRequestNote(pid interface{}, mergeRequest int, opt *CreateMergeRequestNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/notes\", PathEscape(project), mergeRequest)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateMergeRequestNoteOptions represents the available\n// UpdateMergeRequestNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-merge-request-note\ntype UpdateMergeRequestNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// UpdateMergeRequestNote modifies existing note of a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-merge-request-note\nfunc (s *NotesService) UpdateMergeRequestNote(pid interface{}, mergeRequest, note int, opt *UpdateMergeRequestNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/merge_requests/%d/notes/%d\", PathEscape(project), mergeRequest, note)\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteMergeRequestNote deletes an existing note of a merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#delete-a-merge-request-note\nfunc (s *NotesService) DeleteMergeRequestNote(pid interface{}, mergeRequest, note int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/merge_requests/%d/notes/%d\", PathEscape(project), mergeRequest, note)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListEpicNotesOptions represents the available ListEpicNotes() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-all-epic-notes\ntype ListEpicNotesOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListEpicNotes gets a list of all notes for a single epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#list-all-epic-notes\nfunc (s *NotesService) ListEpicNotes(gid interface{}, epic int, opt *ListEpicNotesOptions, options ...RequestOptionFunc) ([]*Note, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/notes\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar n []*Note\n\tresp, err := s.client.Do(req, &n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// GetEpicNote returns a single note for an epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#get-single-epic-note\nfunc (s *NotesService) GetEpicNote(gid interface{}, epic, note int, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/notes/%d\", PathEscape(group), epic, note)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// CreateEpicNoteOptions represents the available CreateEpicNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-epic-note\ntype CreateEpicNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// CreateEpicNote creates a new note for a single merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#create-new-epic-note\nfunc (s *NotesService) CreateEpicNote(gid interface{}, epic int, opt *CreateEpicNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/notes\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// UpdateEpicNoteOptions represents the available UpdateEpicNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-epic-note\ntype UpdateEpicNoteOptions struct {\n\tBody *string `url:\"body,omitempty\" json:\"body,omitempty\"`\n}\n\n// UpdateEpicNote modifies existing note of an epic.\n//\n// https://docs.gitlab.com/ee/api/notes.html#modify-existing-epic-note\nfunc (s *NotesService) UpdateEpicNote(gid interface{}, epic, note int, opt *UpdateEpicNoteOptions, options ...RequestOptionFunc) (*Note, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/notes/%d\", PathEscape(group), epic, note)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tn := new(Note)\n\tresp, err := s.client.Do(req, n)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn n, resp, nil\n}\n\n// DeleteEpicNote deletes an existing note of a merge request.\n//\n// https://docs.gitlab.com/ee/api/notes.html#delete-an-epic-note\nfunc (s *NotesService) DeleteEpicNote(gid interface{}, epic, note int, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/notes/%d\", PathEscape(group), epic, note)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "notes_test.go",
          "type": "blob",
          "size": 2.1650390625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetEpicNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/4329/notes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":3,\"type\":null,\"body\":\"foo bar\",\"attachment\":null,\"system\":false,\"noteable_id\":4392,\"noteable_type\":\"Epic\",\"resolvable\":false,\"noteable_iid\":null}`)\n\t})\n\n\tnote, _, err := client.Notes.GetEpicNote(\"1\", 4329, 3, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Note{\n\t\tID:           3,\n\t\tBody:         \"foo bar\",\n\t\tAttachment:   \"\",\n\t\tTitle:        \"\",\n\t\tFileName:     \"\",\n\t\tSystem:       false,\n\t\tNoteableID:   4392,\n\t\tNoteableType: \"Epic\",\n\t}\n\n\tif !reflect.DeepEqual(note, want) {\n\t\tt.Errorf(\"Notes.GetEpicNote want %#v, got %#v\", note, want)\n\t}\n}\n\nfunc TestGetMergeRequestNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/merge_requests/4329/notes/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":3,\"type\":\"DiffNote\",\"body\":\"foo bar\",\"attachment\":null,\"system\":false,\"noteable_id\":4392,\"noteable_type\":\"Epic\",\"resolvable\":false,\"noteable_iid\":null}`)\n\t})\n\n\tnote, _, err := client.Notes.GetMergeRequestNote(\"1\", 4329, 3, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Note{\n\t\tID:           3,\n\t\tType:         DiffNote,\n\t\tBody:         \"foo bar\",\n\t\tSystem:       false,\n\t\tNoteableID:   4392,\n\t\tNoteableType: \"Epic\",\n\t}\n\n\tif !reflect.DeepEqual(note, want) {\n\t\tt.Errorf(\"Notes.GetEpicNote want %#v, got %#v\", note, want)\n\t}\n}\n"
        },
        {
          "name": "notifications.go",
          "type": "blob",
          "size": 9.4482421875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// NotificationSettingsService handles communication with the notification settings\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/notification_settings.html\ntype NotificationSettingsService struct {\n\tclient *Client\n}\n\n// NotificationSettings represents the Gitlab notification setting.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#valid-notification-levels\ntype NotificationSettings struct {\n\tLevel             NotificationLevelValue `json:\"level\"`\n\tNotificationEmail string                 `json:\"notification_email\"`\n\tEvents            *NotificationEvents    `json:\"events\"`\n}\n\n// NotificationEvents represents the available notification setting events.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#valid-notification-levels\ntype NotificationEvents struct {\n\tCloseIssue                bool `json:\"close_issue\"`\n\tCloseMergeRequest         bool `json:\"close_merge_request\"`\n\tFailedPipeline            bool `json:\"failed_pipeline\"`\n\tFixedPipeline             bool `json:\"fixed_pipeline\"`\n\tIssueDue                  bool `json:\"issue_due\"`\n\tMergeWhenPipelineSucceeds bool `json:\"merge_when_pipeline_succeeds\"`\n\tMergeMergeRequest         bool `json:\"merge_merge_request\"`\n\tMovedProject              bool `json:\"moved_project\"`\n\tNewIssue                  bool `json:\"new_issue\"`\n\tNewMergeRequest           bool `json:\"new_merge_request\"`\n\tNewEpic                   bool `json:\"new_epic\"`\n\tNewNote                   bool `json:\"new_note\"`\n\tPushToMergeRequest        bool `json:\"push_to_merge_request\"`\n\tReassignIssue             bool `json:\"reassign_issue\"`\n\tReassignMergeRequest      bool `json:\"reassign_merge_request\"`\n\tReopenIssue               bool `json:\"reopen_issue\"`\n\tReopenMergeRequest        bool `json:\"reopen_merge_request\"`\n\tSuccessPipeline           bool `json:\"success_pipeline\"`\n}\n\nfunc (ns NotificationSettings) String() string {\n\treturn Stringify(ns)\n}\n\n// GetGlobalSettings returns current notification settings and email address.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#global-notification-settings\nfunc (s *NotificationSettingsService) GetGlobalSettings(options ...RequestOptionFunc) (*NotificationSettings, *Response, error) {\n\tu := \"notification_settings\"\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tns := new(NotificationSettings)\n\tresp, err := s.client.Do(req, ns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ns, resp, nil\n}\n\n// NotificationSettingsOptions represents the available options that can be passed\n// to the API when updating the notification settings.\ntype NotificationSettingsOptions struct {\n\tLevel                     *NotificationLevelValue `url:\"level,omitempty\" json:\"level,omitempty\"`\n\tNotificationEmail         *string                 `url:\"notification_email,omitempty\" json:\"notification_email,omitempty\"`\n\tCloseIssue                *bool                   `url:\"close_issue,omitempty\" json:\"close_issue,omitempty\"`\n\tCloseMergeRequest         *bool                   `url:\"close_merge_request,omitempty\" json:\"close_merge_request,omitempty\"`\n\tFailedPipeline            *bool                   `url:\"failed_pipeline,omitempty\" json:\"failed_pipeline,omitempty\"`\n\tFixedPipeline             *bool                   `url:\"fixed_pipeline,omitempty\" json:\"fixed_pipeline,omitempty\"`\n\tIssueDue                  *bool                   `url:\"issue_due,omitempty\" json:\"issue_due,omitempty\"`\n\tMergeMergeRequest         *bool                   `url:\"merge_merge_request,omitempty\" json:\"merge_merge_request,omitempty\"`\n\tMergeWhenPipelineSucceeds *bool                   `url:\"merge_when_pipeline_succeeds,omitempty\" json:\"merge_when_pipeline_succeeds,omitempty\"`\n\tMovedProject              *bool                   `url:\"moved_project,omitempty\" json:\"moved_project,omitempty\"`\n\tNewEpic                   *bool                   `url:\"new_epic,omitempty\" json:\"new_epic,omitempty\"`\n\tNewIssue                  *bool                   `url:\"new_issue,omitempty\" json:\"new_issue,omitempty\"`\n\tNewMergeRequest           *bool                   `url:\"new_merge_request,omitempty\" json:\"new_merge_request,omitempty\"`\n\tNewNote                   *bool                   `url:\"new_note,omitempty\" json:\"new_note,omitempty\"`\n\tPushToMergeRequest        *bool                   `url:\"push_to_merge_request,omitempty\" json:\"push_to_merge_request,omitempty\"`\n\tReassignIssue             *bool                   `url:\"reassign_issue,omitempty\" json:\"reassign_issue,omitempty\"`\n\tReassignMergeRequest      *bool                   `url:\"reassign_merge_request,omitempty\" json:\"reassign_merge_request,omitempty\"`\n\tReopenIssue               *bool                   `url:\"reopen_issue,omitempty\" json:\"reopen_issue,omitempty\"`\n\tReopenMergeRequest        *bool                   `url:\"reopen_merge_request,omitempty\" json:\"reopen_merge_request,omitempty\"`\n\tSuccessPipeline           *bool                   `url:\"success_pipeline,omitempty\" json:\"success_pipeline,omitempty\"`\n}\n\n// UpdateGlobalSettings updates current notification settings and email address.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#update-global-notification-settings\nfunc (s *NotificationSettingsService) UpdateGlobalSettings(opt *NotificationSettingsOptions, options ...RequestOptionFunc) (*NotificationSettings, *Response, error) {\n\tif opt.Level != nil && *opt.Level == GlobalNotificationLevel {\n\t\treturn nil, nil, errors.New(\n\t\t\t\"notification level 'global' is not valid for global notification settings\")\n\t}\n\n\tu := \"notification_settings\"\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tns := new(NotificationSettings)\n\tresp, err := s.client.Do(req, ns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ns, resp, nil\n}\n\n// GetSettingsForGroup returns current group notification settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#group--project-level-notification-settings\nfunc (s *NotificationSettingsService) GetSettingsForGroup(gid interface{}, options ...RequestOptionFunc) (*NotificationSettings, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/notification_settings\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tns := new(NotificationSettings)\n\tresp, err := s.client.Do(req, ns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ns, resp, nil\n}\n\n// GetSettingsForProject returns current project notification settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#group--project-level-notification-settings\nfunc (s *NotificationSettingsService) GetSettingsForProject(pid interface{}, options ...RequestOptionFunc) (*NotificationSettings, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/notification_settings\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tns := new(NotificationSettings)\n\tresp, err := s.client.Do(req, ns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ns, resp, nil\n}\n\n// UpdateSettingsForGroup updates current group notification settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#update-groupproject-level-notification-settings\nfunc (s *NotificationSettingsService) UpdateSettingsForGroup(gid interface{}, opt *NotificationSettingsOptions, options ...RequestOptionFunc) (*NotificationSettings, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/notification_settings\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tns := new(NotificationSettings)\n\tresp, err := s.client.Do(req, ns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ns, resp, nil\n}\n\n// UpdateSettingsForProject updates current project notification settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/notification_settings.html#update-groupproject-level-notification-settings\nfunc (s *NotificationSettingsService) UpdateSettingsForProject(pid interface{}, opt *NotificationSettingsOptions, options ...RequestOptionFunc) (*NotificationSettings, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/notification_settings\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tns := new(NotificationSettings)\n\tresp, err := s.client.Do(req, ns)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ns, resp, nil\n}\n"
        },
        {
          "name": "notifications_test.go",
          "type": "blob",
          "size": 5.7451171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetGlobalSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/notification_settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"level\": \"participating\",\n\t\t\t\"notification_email\": \"admin@example.com\"\n\t\t  }`)\n\t})\n\n\tsettings, _, err := client.NotificationSettings.GetGlobalSettings()\n\tif err != nil {\n\t\tt.Errorf(\"NotifcationSettings.GetGlobalSettings returned error: %v\", err)\n\t}\n\n\twant := &NotificationSettings{\n\t\tLevel:             1,\n\t\tNotificationEmail: \"admin@example.com\",\n\t}\n\tif !reflect.DeepEqual(settings, want) {\n\t\tt.Errorf(\"NotificationSettings.GetGlobalSettings returned %+v, want %+v\", settings, want)\n\t}\n}\n\nfunc TestGetProjectSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/notification_settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\"level\":\"custom\",\n\t\t\"events\":{\n\t\t\t\"new_note\":true,\n\t\t\t\"new_issue\":true,\n\t\t\t\"reopen_issue\":true,\n\t\t\t\"close_issue\":true,\n\t\t\t\"reassign_issue\":true,\n\t\t\t\"issue_due\":true,\n\t\t\t\"new_merge_request\":true,\n\t\t\t\"push_to_merge_request\":true,\n\t\t\t\"reopen_merge_request\":true,\n\t\t\t\"close_merge_request\":true,\n\t\t\t\"reassign_merge_request\":true,\n\t\t\t\"merge_merge_request\":true,\n\t\t\t\"failed_pipeline\":true,\n\t\t\t\"fixed_pipeline\":true,\n\t\t\t\"success_pipeline\":true,\n\t\t\t\"moved_project\":true,\n\t\t\t\"merge_when_pipeline_succeeds\":true,\n\t\t\t\"new_epic\":true\n\t\t\t}\n\t\t}`)\n\t})\n\n\tsettings, _, err := client.NotificationSettings.GetSettingsForProject(1)\n\tif err != nil {\n\t\tt.Errorf(\"NotifcationSettings.GetSettingsForProject returned error: %v\", err)\n\t}\n\n\twant := &NotificationSettings{\n\t\tLevel: 5, // custom\n\t\tEvents: &NotificationEvents{\n\t\t\tNewEpic:                   true,\n\t\t\tNewNote:                   true,\n\t\t\tNewIssue:                  true,\n\t\t\tReopenIssue:               true,\n\t\t\tCloseIssue:                true,\n\t\t\tReassignIssue:             true,\n\t\t\tIssueDue:                  true,\n\t\t\tNewMergeRequest:           true,\n\t\t\tPushToMergeRequest:        true,\n\t\t\tReopenMergeRequest:        true,\n\t\t\tCloseMergeRequest:         true,\n\t\t\tReassignMergeRequest:      true,\n\t\t\tMergeMergeRequest:         true,\n\t\t\tFailedPipeline:            true,\n\t\t\tFixedPipeline:             true,\n\t\t\tSuccessPipeline:           true,\n\t\t\tMovedProject:              true,\n\t\t\tMergeWhenPipelineSucceeds: true,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(settings, want) {\n\t\tt.Errorf(\"NotificationSettings.GetSettingsForProject returned %+v, want %+v\", settings, want)\n\t}\n}\n\nfunc TestUpdateProjectSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Create the request to send\n\tvar reqBody NotificationSettingsOptions\n\tcustomLevel := notificationLevelTypes[\"custom\"]\n\toptions := NotificationSettingsOptions{\n\t\tLevel:        &customLevel,\n\t\tNewEpic:      Bool(true),\n\t\tMovedProject: Bool(true),\n\t\tCloseIssue:   Bool(true),\n\t}\n\n\t// Handle the request on the server, and return a fully hydrated response\n\tmux.HandleFunc(\"/api/v4/projects/1/notification_settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\n\t\t// Store the body for later, so we can check only some values are marshaled properly for update\n\t\tbody, _ := io.ReadAll(r.Body)\n\t\tjson.Unmarshal(body, &reqBody)\n\n\t\tfmt.Fprintf(w, `{\n\t\t\"level\":\"custom\",\n\t\t\"events\":{\n\t\t\t\"new_note\":true,\n\t\t\t\"new_issue\":true,\n\t\t\t\"reopen_issue\":true,\n\t\t\t\"close_issue\":true,\n\t\t\t\"reassign_issue\":true,\n\t\t\t\"issue_due\":true,\n\t\t\t\"new_merge_request\":true,\n\t\t\t\"push_to_merge_request\":true,\n\t\t\t\"reopen_merge_request\":true,\n\t\t\t\"close_merge_request\":true,\n\t\t\t\"reassign_merge_request\":true,\n\t\t\t\"merge_merge_request\":true,\n\t\t\t\"failed_pipeline\":true,\n\t\t\t\"fixed_pipeline\":true,\n\t\t\t\"success_pipeline\":true,\n\t\t\t\"moved_project\":true,\n\t\t\t\"merge_when_pipeline_succeeds\":true,\n\t\t\t\"new_epic\":true\n\t\t\t}\n\t\t}`)\n\t})\n\n\t// Make the actual request\n\tsettings, _, err := client.NotificationSettings.UpdateSettingsForProject(1, &options)\n\tif err != nil {\n\t\tt.Errorf(\"NotifcationSettings.UpdateSettingsForProject returned error: %v\", err)\n\t}\n\n\t// Test the response and the request\n\twantResponse := &NotificationSettings{\n\t\tLevel: customLevel,\n\t\tEvents: &NotificationEvents{\n\t\t\tNewEpic:                   true,\n\t\t\tNewNote:                   true,\n\t\t\tNewIssue:                  true,\n\t\t\tReopenIssue:               true,\n\t\t\tCloseIssue:                true,\n\t\t\tReassignIssue:             true,\n\t\t\tIssueDue:                  true,\n\t\t\tNewMergeRequest:           true,\n\t\t\tPushToMergeRequest:        true,\n\t\t\tReopenMergeRequest:        true,\n\t\t\tCloseMergeRequest:         true,\n\t\t\tReassignMergeRequest:      true,\n\t\t\tMergeMergeRequest:         true,\n\t\t\tFailedPipeline:            true,\n\t\t\tFixedPipeline:             true,\n\t\t\tSuccessPipeline:           true,\n\t\t\tMovedProject:              true,\n\t\t\tMergeWhenPipelineSucceeds: true,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(settings, wantResponse) {\n\t\tt.Errorf(\"NotificationSettings.UpdateSettingsForProject returned for the response %+v, want %+v\", settings, wantResponse)\n\t}\n\tif !reflect.DeepEqual(settings, wantResponse) {\n\t\tt.Errorf(\"NotificationSettings.UpdateSettingsForProject send for the request %+v, want %+v\", reqBody, options)\n\t}\n}\n"
        },
        {
          "name": "packages.go",
          "type": "blob",
          "size": 7.9130859375,
          "content": "//\n// Copyright 2021, Kordian Bruck\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// PackagesService handles communication with the packages related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/packages.html\ntype PackagesService struct {\n\tclient *Client\n}\n\n// Package represents a GitLab package.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/packages.html\ntype Package struct {\n\tID               int           `json:\"id\"`\n\tName             string        `json:\"name\"`\n\tVersion          string        `json:\"version\"`\n\tPackageType      string        `json:\"package_type\"`\n\tStatus           string        `json:\"status\"`\n\tLinks            *PackageLinks `json:\"_links\"`\n\tCreatedAt        *time.Time    `json:\"created_at\"`\n\tLastDownloadedAt *time.Time    `json:\"last_downloaded_at\"`\n\tTags             []PackageTag  `json:\"tags\"`\n}\n\nfunc (s Package) String() string {\n\treturn Stringify(s)\n}\n\n// GroupPackage represents a GitLab group package.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/packages.html\ntype GroupPackage struct {\n\tPackage\n\tProjectID   int    `json:\"project_id\"`\n\tProjectPath string `json:\"project_path\"`\n}\n\nfunc (s GroupPackage) String() string {\n\treturn Stringify(s)\n}\n\n// PackageLinks holds links for itself and deleting.\ntype PackageLinks struct {\n\tWebPath       string `json:\"web_path\"`\n\tDeleteAPIPath string `json:\"delete_api_path\"`\n}\n\nfunc (s PackageLinks) String() string {\n\treturn Stringify(s)\n}\n\n// PackageTag holds label information about the package\ntype PackageTag struct {\n\tID        int        `json:\"id\"`\n\tPackageID int        `json:\"package_id\"`\n\tName      string     `json:\"name\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tUpdatedAt *time.Time `json:\"updated_at\"`\n}\n\nfunc (s PackageTag) String() string {\n\treturn Stringify(s)\n}\n\n// PackageFile represents one file contained within a package.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/packages.html\ntype PackageFile struct {\n\tID         int         `json:\"id\"`\n\tPackageID  int         `json:\"package_id\"`\n\tCreatedAt  *time.Time  `json:\"created_at\"`\n\tFileName   string      `json:\"file_name\"`\n\tSize       int         `json:\"size\"`\n\tFileMD5    string      `json:\"file_md5\"`\n\tFileSHA1   string      `json:\"file_sha1\"`\n\tFileSHA256 string      `json:\"file_sha256\"`\n\tPipeline   *[]Pipeline `json:\"pipelines\"`\n}\n\nfunc (s PackageFile) String() string {\n\treturn Stringify(s)\n}\n\n// ListProjectPackagesOptions represents the available ListProjectPackages()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#within-a-project\ntype ListProjectPackagesOptions struct {\n\tListOptions\n\tOrderBy            *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort               *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tPackageType        *string `url:\"package_type,omitempty\" json:\"package_type,omitempty\"`\n\tPackageName        *string `url:\"package_name,omitempty\" json:\"package_name,omitempty\"`\n\tPackageVersion     *string `url:\"package_version,omitempty\" json:\"package_version,omitempty\"`\n\tIncludeVersionless *bool   `url:\"include_versionless,omitempty\" json:\"include_versionless,omitempty\"`\n\tStatus             *string `url:\"status,omitempty\" json:\"status,omitempty\"`\n}\n\n// ListProjectPackages gets a list of packages in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#within-a-project\nfunc (s *PackagesService) ListProjectPackages(pid interface{}, opt *ListProjectPackagesOptions, options ...RequestOptionFunc) ([]*Package, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/packages\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Package\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// ListGroupPackagesOptions represents the available ListGroupPackages()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#within-a-group\ntype ListGroupPackagesOptions struct {\n\tListOptions\n\tExcludeSubGroups   *bool   `url:\"exclude_subgroups,omitempty\" json:\"exclude_subgroups,omitempty\"`\n\tOrderBy            *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort               *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tPackageType        *string `url:\"package_type,omitempty\" json:\"package_type,omitempty\"`\n\tPackageName        *string `url:\"package_name,omitempty\" json:\"package_name,omitempty\"`\n\tIncludeVersionless *bool   `url:\"include_versionless,omitempty\" json:\"include_versionless,omitempty\"`\n\tStatus             *string `url:\"status,omitempty\" json:\"status,omitempty\"`\n}\n\n// ListGroupPackages gets a list of packages in a group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#within-a-group\nfunc (s *PackagesService) ListGroupPackages(gid interface{}, opt *ListGroupPackagesOptions, options ...RequestOptionFunc) ([]*GroupPackage, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/packages\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*GroupPackage\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// ListPackageFilesOptions represents the available ListPackageFiles()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#list-package-files\ntype ListPackageFilesOptions ListOptions\n\n// ListPackageFiles gets a list of files that are within a package\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#list-package-files\nfunc (s *PackagesService) ListPackageFiles(pid interface{}, pkg int, opt *ListPackageFilesOptions, options ...RequestOptionFunc) ([]*PackageFile, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/packages/%d/package_files\",\n\t\tPathEscape(project),\n\t\tpkg,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pfs []*PackageFile\n\tresp, err := s.client.Do(req, &pfs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pfs, resp, nil\n}\n\n// DeleteProjectPackage deletes a package in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#delete-a-project-package\nfunc (s *PackagesService) DeleteProjectPackage(pid interface{}, pkg int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/packages/%d\", PathEscape(project), pkg)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeletePackageFile deletes a file in project package\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/packages.html#delete-a-package-file\nfunc (s *PackagesService) DeletePackageFile(pid interface{}, pkg, file int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/packages/%d/package_files/%d\", PathEscape(project), pkg, file)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "packages_test.go",
          "type": "blob",
          "size": 4.4228515625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPackagesService_ListProjectPackages(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/3/packages\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"name\": \"Hello/0.1@mycompany/stable\",\n\t\t\t\t\"conan_package_name\": \"Hello\",\n\t\t\t\t\"version\": \"0.1\",\n\t\t\t\t\"package_type\": \"conan\",\n\t\t\t\t\"last_downloaded_at\": \"2023-01-04T20:00:00.000Z\",\n\t\t\t\t\"_links\": {\n\t\t\t\t  \"web_path\": \"/foo/bar/-/packages/3\",\n\t\t\t\t  \"delete_api_path\": \"https://gitlab.example.com/api/v4/projects/1/packages/3\"\n\t\t\t\t},\n\t\t\t\t\"tags\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"package_id\": 37,\n\t\t\t\t\t\t\"name\": \"Some Label\",\n\t\t\t\t\t\t\"created_at\": \"2023-01-04T20:00:00.000Z\",\n\t\t\t\t\t\t\"updated_at\": \"2023-01-04T20:00:00.000Z\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\ttimestamp := time.Date(2023, 1, 4, 20, 0, 0, 0, time.UTC)\n\twant := []*Package{{\n\t\tID:               3,\n\t\tName:             \"Hello/0.1@mycompany/stable\",\n\t\tVersion:          \"0.1\",\n\t\tPackageType:      \"conan\",\n\t\tLastDownloadedAt: &timestamp,\n\t\tLinks: &PackageLinks{\n\t\t\tWebPath:       \"/foo/bar/-/packages/3\",\n\t\t\tDeleteAPIPath: \"https://gitlab.example.com/api/v4/projects/1/packages/3\",\n\t\t},\n\t\tTags: []PackageTag{\n\t\t\t{\n\t\t\t\tID:        1,\n\t\t\t\tPackageID: 37,\n\t\t\t\tName:      \"Some Label\",\n\t\t\t\tCreatedAt: &timestamp,\n\t\t\t\tUpdatedAt: &timestamp,\n\t\t\t},\n\t\t},\n\t}}\n\n\tps, resp, err := client.Packages.ListProjectPackages(3, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ps)\n\n\tps, resp, err = client.Packages.ListProjectPackages(3.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 3.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ps)\n\n\tps, resp, err = client.Packages.ListProjectPackages(3, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ps)\n\n\tps, resp, err = client.Packages.ListProjectPackages(5, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ps)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPackagesService_ListPackageFiles(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/3/packages/4/package_files\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 25,\n\t\t\t\t\"package_id\": 4,\n\t\t\t\t\"file_name\": \"my-app-1.5-20181107.152550-1.jar\",\n\t\t\t\t\"size\": 2421,\n\t\t\t\t\"file_md5\": \"58e6a45a629910c6ff99145a688971ac\",\n\t\t\t\t\"file_sha1\": \"ebd193463d3915d7e22219f52740056dfd26cbfe\",\n\t\t\t\t\"file_sha256\": \"a903393463d3915d7e22219f52740056dfd26cbfeff321b\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*PackageFile{{\n\t\tID:         25,\n\t\tPackageID:  4,\n\t\tFileName:   \"my-app-1.5-20181107.152550-1.jar\",\n\t\tSize:       2421,\n\t\tFileMD5:    \"58e6a45a629910c6ff99145a688971ac\",\n\t\tFileSHA1:   \"ebd193463d3915d7e22219f52740056dfd26cbfe\",\n\t\tFileSHA256: \"a903393463d3915d7e22219f52740056dfd26cbfeff321b\",\n\t}}\n\n\tps, resp, err := client.Packages.ListPackageFiles(3, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ps)\n\n\tps, resp, err = client.Packages.ListPackageFiles(3.01, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 3.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ps)\n\n\tps, resp, err = client.Packages.ListPackageFiles(3, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ps)\n\n\tps, resp, err = client.Packages.ListPackageFiles(5, 4, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ps)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPackagesService_DeleteProjectPackage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/3/packages/4\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.Packages.DeleteProjectPackage(3, 4, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Packages.DeleteProjectPackage(3.01, 4, nil)\n\trequire.EqualError(t, err, \"invalid ID type 3.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Packages.DeleteProjectPackage(3, 4, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Packages.DeleteProjectPackage(5, 4, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "pages.go",
          "type": "blob",
          "size": 3.6669921875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\ntype PagesService struct {\n\tclient *Client\n}\n\n// Pages represents the Pages of a project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pages.html\ntype Pages struct {\n\tURL                   string             `json:\"url\"`\n\tIsUniqueDomainEnabled bool               `json:\"is_unique_domain_enabled\"`\n\tForceHTTPS            bool               `json:\"force_https\"`\n\tDeployments           []*PagesDeployment `json:\"deployments\"`\n}\n\n// PagesDeployment represents a Pages deployment.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pages.html\ntype PagesDeployment struct {\n\tCreatedAt     time.Time `json:\"created_at\"`\n\tURL           string    `json:\"url\"`\n\tPathPrefix    string    `json:\"path_prefix\"`\n\tRootDirectory string    `json:\"root_directory\"`\n}\n\n// UnpublishPages unpublished pages. The user must have admin privileges.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages.html#unpublish-pages\nfunc (s *PagesService) UnpublishPages(gid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tpage, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages\", PathEscape(page))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GetPages lists Pages settings for a project. The user must have at least\n// maintainer privileges.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/pages.html#get-pages-settings-for-a-project\nfunc (s *PagesService) GetPages(gid interface{}, options ...RequestOptionFunc) (*Pages, *Response, error) {\n\tproject, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pages)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// UpdatePages represents the available UpdatePages() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages.html#update-pages-settings-for-a-project\ntype UpdatePagesOptions struct {\n\tPagesUniqueDomainEnabled *bool `url:\"pages_unique_domain_enabled,omitempty\" json:\"pages_unique_domain_enabled,omitempty\"`\n\tPagesHTTPSOnly           *bool `url:\"pages_https_only,omitempty\" json:\"pages_https_only,omitempty\"`\n}\n\n// UpdatePages updates Pages settings for a project. The user must have\n// administrator privileges.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/pages.html#update-pages-settings-for-a-project\nfunc (s *PagesService) UpdatePages(pid interface{}, opt UpdatePagesOptions, options ...RequestOptionFunc) (*Pages, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPatch, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pages)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n"
        },
        {
          "name": "pages_domains.go",
          "type": "blob",
          "size": 6.654296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// PagesDomainsService handles communication with the pages domains\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pages_domains.html\ntype PagesDomainsService struct {\n\tclient *Client\n}\n\n// PagesDomain represents a pages domain.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pages_domains.html\ntype PagesDomain struct {\n\tDomain           string     `json:\"domain\"`\n\tAutoSslEnabled   bool       `json:\"auto_ssl_enabled\"`\n\tURL              string     `json:\"url\"`\n\tProjectID        int        `json:\"project_id\"`\n\tVerified         bool       `json:\"verified\"`\n\tVerificationCode string     `json:\"verification_code\"`\n\tEnabledUntil     *time.Time `json:\"enabled_until\"`\n\tCertificate      struct {\n\t\tSubject         string     `json:\"subject\"`\n\t\tExpired         bool       `json:\"expired\"`\n\t\tExpiration      *time.Time `json:\"expiration\"`\n\t\tCertificate     string     `json:\"certificate\"`\n\t\tCertificateText string     `json:\"certificate_text\"`\n\t} `json:\"certificate\"`\n}\n\n// ListPagesDomainsOptions represents the available ListPagesDomains() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#list-pages-domains\ntype ListPagesDomainsOptions ListOptions\n\n// ListPagesDomains gets a list of project pages domains.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#list-pages-domains\nfunc (s *PagesDomainsService) ListPagesDomains(pid interface{}, opt *ListPagesDomainsOptions, options ...RequestOptionFunc) ([]*PagesDomain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages/domains\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pd []*PagesDomain\n\tresp, err := s.client.Do(req, &pd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pd, resp, nil\n}\n\n// ListAllPagesDomains gets a list of all pages domains.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#list-all-pages-domains\nfunc (s *PagesDomainsService) ListAllPagesDomains(options ...RequestOptionFunc) ([]*PagesDomain, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"pages/domains\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pd []*PagesDomain\n\tresp, err := s.client.Do(req, &pd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pd, resp, nil\n}\n\n// GetPagesDomain get a specific pages domain for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#single-pages-domain\nfunc (s *PagesDomainsService) GetPagesDomain(pid interface{}, domain string, options ...RequestOptionFunc) (*PagesDomain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages/domains/%s\", PathEscape(project), domain)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpd := new(PagesDomain)\n\tresp, err := s.client.Do(req, pd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pd, resp, nil\n}\n\n// CreatePagesDomainOptions represents the available CreatePagesDomain() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#create-new-pages-domain\ntype CreatePagesDomainOptions struct {\n\tDomain         *string `url:\"domain,omitempty\" json:\"domain,omitempty\"`\n\tAutoSslEnabled *bool   `url:\"auto_ssl_enabled,omitempty\" json:\"auto_ssl_enabled,omitempty\"`\n\tCertificate    *string `url:\"certificate,omitempty\" json:\"certificate,omitempty\"`\n\tKey            *string `url:\"key,omitempty\" json:\"key,omitempty\"`\n}\n\n// CreatePagesDomain creates a new project pages domain.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#create-new-pages-domain\nfunc (s *PagesDomainsService) CreatePagesDomain(pid interface{}, opt *CreatePagesDomainOptions, options ...RequestOptionFunc) (*PagesDomain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages/domains\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpd := new(PagesDomain)\n\tresp, err := s.client.Do(req, pd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pd, resp, nil\n}\n\n// UpdatePagesDomainOptions represents the available UpdatePagesDomain() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#update-pages-domain\ntype UpdatePagesDomainOptions struct {\n\tAutoSslEnabled *bool   `url:\"auto_ssl_enabled,omitempty\" json:\"auto_ssl_enabled,omitempty\"`\n\tCertificate    *string `url:\"certificate,omitempty\" json:\"certificate,omitempty\"`\n\tKey            *string `url:\"key,omitempty\" json:\"key,omitempty\"`\n}\n\n// UpdatePagesDomain updates an existing project pages domain.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#update-pages-domain\nfunc (s *PagesDomainsService) UpdatePagesDomain(pid interface{}, domain string, opt *UpdatePagesDomainOptions, options ...RequestOptionFunc) (*PagesDomain, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages/domains/%s\", PathEscape(project), domain)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpd := new(PagesDomain)\n\tresp, err := s.client.Do(req, pd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pd, resp, nil\n}\n\n// DeletePagesDomain deletes an existing prject pages domain.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pages_domains.html#delete-pages-domain\nfunc (s *PagesDomainsService) DeletePagesDomain(pid interface{}, domain string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pages/domains/%s\", PathEscape(project), domain)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "pages_domains_test.go",
          "type": "blob",
          "size": 11.3076171875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPagesDomainsService_ListPagesDomains(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/pages/domains\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"domain\": \"ssl.domain.example\",\n\t\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\t\"auto_ssl_enabled\": false,\n\t\t\t\t\"certificate\": {\n\t\t\t\t  \"subject\": \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\t\t  \"expired\": false,\n\t\t\t\t  \"certificate\": \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\t\t  \"certificate_text\": \"Certificate:\\n … \\n\"\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*PagesDomain{{\n\t\tDomain:           \"ssl.domain.example\",\n\t\tAutoSslEnabled:   false,\n\t\tURL:              \"https://ssl.domain.example\",\n\t\tProjectID:        0,\n\t\tVerified:         false,\n\t\tVerificationCode: \"\",\n\t\tEnabledUntil:     nil,\n\t\tCertificate: struct {\n\t\t\tSubject         string     `json:\"subject\"`\n\t\t\tExpired         bool       `json:\"expired\"`\n\t\t\tExpiration      *time.Time `json:\"expiration\"`\n\t\t\tCertificate     string     `json:\"certificate\"`\n\t\t\tCertificateText string     `json:\"certificate_text\"`\n\t\t}{\n\t\t\tExpired:         false,\n\t\t\tExpiration:      nil,\n\t\t\tSubject:         \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\tCertificate:     \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\tCertificateText: \"Certificate:\\n … \\n\",\n\t\t},\n\t}}\n\n\tpds, resp, err := client.PagesDomains.ListPagesDomains(5, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pds)\n\n\tpds, resp, err = client.PagesDomains.ListPagesDomains(5.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pds)\n\n\tpds, resp, err = client.PagesDomains.ListPagesDomains(5, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pds)\n\n\tpds, resp, err = client.PagesDomains.ListPagesDomains(7, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPagesDomainsService_ListAllPagesDomains(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/pages/domains\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"domain\": \"ssl.domain.example\",\n\t\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\t\"project_id\": 1337,\n\t\t\t\t\"auto_ssl_enabled\": false,\n\t\t\t\t\"certificate\": {\n\t\t\t\t  \"expired\": false\n\t\t\t\t}\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*PagesDomain{{\n\t\tDomain:           \"ssl.domain.example\",\n\t\tAutoSslEnabled:   false,\n\t\tURL:              \"https://ssl.domain.example\",\n\t\tProjectID:        1337,\n\t\tVerified:         false,\n\t\tVerificationCode: \"\",\n\t\tEnabledUntil:     nil,\n\t\tCertificate: struct {\n\t\t\tSubject         string     `json:\"subject\"`\n\t\t\tExpired         bool       `json:\"expired\"`\n\t\t\tExpiration      *time.Time `json:\"expiration\"`\n\t\t\tCertificate     string     `json:\"certificate\"`\n\t\t\tCertificateText string     `json:\"certificate_text\"`\n\t\t}{\n\t\t\tExpired:    false,\n\t\t\tExpiration: nil,\n\t\t},\n\t}}\n\n\tpds, resp, err := client.PagesDomains.ListAllPagesDomains(nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pds)\n\n\tpds, resp, err = client.PagesDomains.ListAllPagesDomains(nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pds)\n}\n\nfunc TestPagesDomainsService_ListAllPagesDomains_StatusNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/pages/domains\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tpds, resp, err := client.PagesDomains.ListAllPagesDomains(nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pds)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPagesDomainsService_GetPagesDomain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/pages/domains/www.domain.example\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"domain\": \"www.domain.example\",\n\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\"auto_ssl_enabled\": false,\n\t\t\t\"certificate\": {\n\t\t\t  \"subject\": \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\t  \"expired\": false,\n\t\t\t  \"certificate\": \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\t  \"certificate_text\": \"Certificate:\\n … \\n\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &PagesDomain{\n\t\tDomain:           \"www.domain.example\",\n\t\tAutoSslEnabled:   false,\n\t\tURL:              \"https://ssl.domain.example\",\n\t\tProjectID:        0,\n\t\tVerified:         false,\n\t\tVerificationCode: \"\",\n\t\tEnabledUntil:     nil,\n\t\tCertificate: struct {\n\t\t\tSubject         string     `json:\"subject\"`\n\t\t\tExpired         bool       `json:\"expired\"`\n\t\t\tExpiration      *time.Time `json:\"expiration\"`\n\t\t\tCertificate     string     `json:\"certificate\"`\n\t\t\tCertificateText string     `json:\"certificate_text\"`\n\t\t}{\n\t\t\tExpired:         false,\n\t\t\tExpiration:      nil,\n\t\t\tSubject:         \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\tCertificate:     \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\tCertificateText: \"Certificate:\\n … \\n\",\n\t\t},\n\t}\n\n\tpd, resp, err := client.PagesDomains.GetPagesDomain(5, \"www.domain.example\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pd)\n\n\tpd, resp, err = client.PagesDomains.GetPagesDomain(5.01, \"www.domain.example\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pd)\n\n\tpd, resp, err = client.PagesDomains.GetPagesDomain(5, \"www.domain.example\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pd)\n\n\tpd, resp, err = client.PagesDomains.GetPagesDomain(7, \"www.domain.example\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pd)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPagesDomainsService_CreatePagesDomain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/pages/domains\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"domain\": \"ssl.domain.example\",\n\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\"auto_ssl_enabled\": false,\n\t\t\t\"certificate\": {\n\t\t\t  \"subject\": \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\t  \"expired\": false,\n\t\t\t  \"certificate\": \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\t  \"certificate_text\": \"Certificate:\\n … \\n\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &PagesDomain{\n\t\tDomain:           \"ssl.domain.example\",\n\t\tAutoSslEnabled:   false,\n\t\tURL:              \"https://ssl.domain.example\",\n\t\tProjectID:        0,\n\t\tVerified:         false,\n\t\tVerificationCode: \"\",\n\t\tEnabledUntil:     nil,\n\t\tCertificate: struct {\n\t\t\tSubject         string     `json:\"subject\"`\n\t\t\tExpired         bool       `json:\"expired\"`\n\t\t\tExpiration      *time.Time `json:\"expiration\"`\n\t\t\tCertificate     string     `json:\"certificate\"`\n\t\t\tCertificateText string     `json:\"certificate_text\"`\n\t\t}{\n\t\t\tExpired:         false,\n\t\t\tExpiration:      nil,\n\t\t\tSubject:         \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\tCertificate:     \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\tCertificateText: \"Certificate:\\n … \\n\",\n\t\t},\n\t}\n\n\tpd, resp, err := client.PagesDomains.CreatePagesDomain(5, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pd)\n\n\tpd, resp, err = client.PagesDomains.CreatePagesDomain(5.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pd)\n\n\tpd, resp, err = client.PagesDomains.CreatePagesDomain(5, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pd)\n\n\tpd, resp, err = client.PagesDomains.CreatePagesDomain(7, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pd)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPagesDomainsService_UpdatePagesDomain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/pages/domains/ssl.domain.example\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"domain\": \"ssl.domain.example\",\n\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\"auto_ssl_enabled\": false,\n\t\t\t\"certificate\": {\n\t\t\t  \"subject\": \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\t  \"expired\": false,\n\t\t\t  \"certificate\": \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\t  \"certificate_text\": \"Certificate:\\n … \\n\"\n\t\t\t}\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &PagesDomain{\n\t\tDomain:           \"ssl.domain.example\",\n\t\tAutoSslEnabled:   false,\n\t\tURL:              \"https://ssl.domain.example\",\n\t\tProjectID:        0,\n\t\tVerified:         false,\n\t\tVerificationCode: \"\",\n\t\tEnabledUntil:     nil,\n\t\tCertificate: struct {\n\t\t\tSubject         string     `json:\"subject\"`\n\t\t\tExpired         bool       `json:\"expired\"`\n\t\t\tExpiration      *time.Time `json:\"expiration\"`\n\t\t\tCertificate     string     `json:\"certificate\"`\n\t\t\tCertificateText string     `json:\"certificate_text\"`\n\t\t}{\n\t\t\tExpired:         false,\n\t\t\tExpiration:      nil,\n\t\t\tSubject:         \"/O=Example, Inc./OU=Example Origin CA/CN=Example Origin Certificate\",\n\t\t\tCertificate:     \"-----BEGIN CERTIFICATE-----\\n … \\n-----END CERTIFICATE-----\",\n\t\t\tCertificateText: \"Certificate:\\n … \\n\",\n\t\t},\n\t}\n\n\tpd, resp, err := client.PagesDomains.UpdatePagesDomain(5, \"ssl.domain.example\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pd)\n\n\tpd, resp, err = client.PagesDomains.UpdatePagesDomain(5.01, \"ssl.domain.example\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pd)\n\n\tpd, resp, err = client.PagesDomains.UpdatePagesDomain(5, \"ssl.domain.example\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pd)\n\n\tpd, resp, err = client.PagesDomains.UpdatePagesDomain(7, \"ssl.domain.example\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pd)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestPagesDomainsService_DeletePagesDomain(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/pages/domains/ssl.domain.example\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.PagesDomains.DeletePagesDomain(5, \"ssl.domain.example\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.PagesDomains.DeletePagesDomain(5.01, \"ssl.domain.example\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 5.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.PagesDomains.DeletePagesDomain(5, \"ssl.domain.example\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.PagesDomains.DeletePagesDomain(7, \"ssl.domain.example\", nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "pages_test.go",
          "type": "blob",
          "size": 3.06640625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestUnpublishPages(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/2/pages\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Pages.UnpublishPages(2)\n\tif err != nil {\n\t\tt.Errorf(\"Pages.UnpublishPages returned error: %v\", err)\n\t}\n}\n\nfunc TestGetPages(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/2/pages\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t  {\n\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\"deployments\": [\n\t\t\t  {\n\t\t\t\t\"created_at\": \"2021-04-27T21:27:38.584Z\",\n\t\t\t\t\"url\": \"https://ssl.domain.example/\",\n\t\t\t\t\"path_prefix\": \"\",\n\t\t\t\t\"root_directory\": null\n\t\t\t  }\n\t\t\t],\n\t\t\t\"is_unique_domain_enabled\": false,\n\t\t\t\"force_https\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Pages{\n\t\tURL:                   \"https://ssl.domain.example\",\n\t\tIsUniqueDomainEnabled: false,\n\t\tForceHTTPS:            false,\n\t\tDeployments: []*PagesDeployment{\n\t\t\t{\n\t\t\t\tCreatedAt:     time.Date(2021, time.April, 27, 21, 27, 38, 584000000, time.UTC),\n\t\t\t\tURL:           \"https://ssl.domain.example/\",\n\t\t\t\tPathPrefix:    \"\",\n\t\t\t\tRootDirectory: \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tp, resp, err := client.Pages.GetPages(2)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, p)\n}\n\nfunc TestUpdatePages(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/2/pages\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPatch)\n\t\tfmt.Fprint(w, `\n\t\t  {\n\t\t\t\"url\": \"https://ssl.domain.example\",\n\t\t\t\"deployments\": [\n\t\t\t  {\n\t\t\t\t\"created_at\": \"2021-04-27T21:27:38.584Z\",\n\t\t\t\t\"url\": \"https://ssl.domain.example/\",\n\t\t\t\t\"path_prefix\": \"\",\n\t\t\t\t\"root_directory\": null\n\t\t\t  }\n\t\t\t],\n\t\t\t\"is_unique_domain_enabled\": true,\n\t\t\t\"force_https\": false\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &Pages{\n\t\tURL:                   \"https://ssl.domain.example\",\n\t\tIsUniqueDomainEnabled: true,\n\t\tForceHTTPS:            false,\n\t\tDeployments: []*PagesDeployment{\n\t\t\t{\n\t\t\t\tCreatedAt:     time.Date(2021, time.April, 27, 21, 27, 38, 584000000, time.UTC),\n\t\t\t\tURL:           \"https://ssl.domain.example/\",\n\t\t\t\tPathPrefix:    \"\",\n\t\t\t\tRootDirectory: \"\",\n\t\t\t},\n\t\t},\n\t}\n\n\tp, resp, err := client.Pages.UpdatePages(2, UpdatePagesOptions{\n\t\tPagesUniqueDomainEnabled: Ptr(true),\n\t\tPagesHTTPSOnly:           Ptr(false),\n\t})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, p)\n}\n"
        },
        {
          "name": "personal_access_tokens.go",
          "type": "blob",
          "size": 7.7421875,
          "content": "//\n// Copyright 2022, Ryan Glab <ryan.j.glab@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// PersonalAccessTokensService handles communication with the personal access\n// tokens related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/personal_access_tokens.html\ntype PersonalAccessTokensService struct {\n\tclient *Client\n}\n\n// PersonalAccessToken represents a personal access token.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/personal_access_tokens.html\ntype PersonalAccessToken struct {\n\tID         int        `json:\"id\"`\n\tName       string     `json:\"name\"`\n\tRevoked    bool       `json:\"revoked\"`\n\tCreatedAt  *time.Time `json:\"created_at\"`\n\tScopes     []string   `json:\"scopes\"`\n\tUserID     int        `json:\"user_id\"`\n\tLastUsedAt *time.Time `json:\"last_used_at,omitempty\"`\n\tActive     bool       `json:\"active\"`\n\tExpiresAt  *ISOTime   `json:\"expires_at\"`\n\tToken      string     `json:\"token,omitempty\"`\n}\n\nfunc (p PersonalAccessToken) String() string {\n\treturn Stringify(p)\n}\n\n// ListPersonalAccessTokensOptions represents the available\n// ListPersonalAccessTokens() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#list-personal-access-tokens\ntype ListPersonalAccessTokensOptions struct {\n\tListOptions\n\tCreatedAfter   *ISOTime `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore  *ISOTime `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tLastUsedAfter  *ISOTime `url:\"last_used_after,omitempty\" json:\"last_used_after,omitempty\"`\n\tLastUsedBefore *ISOTime `url:\"last_used_before,omitempty\" json:\"last_used_before,omitempty\"`\n\tRevoked        *bool    `url:\"revoked,omitempty\" json:\"revoked,omitempty\"`\n\tSearch         *string  `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tState          *string  `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tUserID         *int     `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n}\n\n// ListPersonalAccessTokens gets a list of all personal access tokens.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#list-personal-access-tokens\nfunc (s *PersonalAccessTokensService) ListPersonalAccessTokens(opt *ListPersonalAccessTokensOptions, options ...RequestOptionFunc) ([]*PersonalAccessToken, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"personal_access_tokens\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pats []*PersonalAccessToken\n\tresp, err := s.client.Do(req, &pats)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pats, resp, nil\n}\n\n// GetSinglePersonalAccessTokenByID get a single personal access token by its ID.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#using-a-personal-access-token-id\nfunc (s *PersonalAccessTokensService) GetSinglePersonalAccessTokenByID(token int, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tu := fmt.Sprintf(\"personal_access_tokens/%d\", token)\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// GetSinglePersonalAccessToken get a single personal access token by using\n// passing the token in a header.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#using-a-request-header\nfunc (s *PersonalAccessTokensService) GetSinglePersonalAccessToken(options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tu := \"personal_access_tokens/self\"\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RotatePersonalAccessTokenOptions represents the available RotatePersonalAccessToken()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#rotate-a-personal-access-token\ntype RotatePersonalAccessTokenOptions struct {\n\tExpiresAt *ISOTime `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// RotatePersonalAccessToken is a backwards-compat shim for RotatePersonalAccessTokenByID.\nfunc (s *PersonalAccessTokensService) RotatePersonalAccessToken(token int, opt *RotatePersonalAccessTokenOptions, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\treturn s.RotatePersonalAccessTokenByID(token, opt, options...)\n}\n\n// RotatePersonalAccessTokenByID revokes a token and returns a new token that\n// expires in one week per default.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#use-a-personal-access-token-id\nfunc (s *PersonalAccessTokensService) RotatePersonalAccessTokenByID(token int, opt *RotatePersonalAccessTokenOptions, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tu := fmt.Sprintf(\"personal_access_tokens/%d/rotate\", token)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RotatePersonalAccessTokenSelf revokes the currently authenticated token\n// and returns a new token that expires in one week per default.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#use-a-request-header\nfunc (s *PersonalAccessTokensService) RotatePersonalAccessTokenSelf(opt *RotatePersonalAccessTokenOptions, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tu := \"personal_access_tokens/self/rotate\"\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RevokePersonalAccessToken is a backwards-compat shim for RevokePersonalAccessTokenByID.\nfunc (s *PersonalAccessTokensService) RevokePersonalAccessToken(token int, options ...RequestOptionFunc) (*Response, error) {\n\treturn s.RevokePersonalAccessTokenByID(token, options...)\n}\n\n// RevokePersonalAccessTokenByID revokes a personal access token by its ID.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#using-a-personal-access-token-id-1\nfunc (s *PersonalAccessTokensService) RevokePersonalAccessTokenByID(token int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"personal_access_tokens/%d\", token)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// RevokePersonalAccessTokenSelf revokes the currently authenticated\n// personal access token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/personal_access_tokens.html#using-a-request-header-1\nfunc (s *PersonalAccessTokensService) RevokePersonalAccessTokenSelf(options ...RequestOptionFunc) (*Response, error) {\n\tu := \"personal_access_tokens/self\"\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "personal_access_tokens_test.go",
          "type": "blob",
          "size": 11.3740234375,
          "content": "//\n// Copyright 2022, Ryan Glab <ryan.j.glab@gmail.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListPersonalAccessTokensWithUserFilter(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_personal_access_tokens_with_user_filter.json\")\n\t})\n\n\tpersonalAccessTokens, _, err := client.PersonalAccessTokens.ListPersonalAccessTokens(\n\t\t&ListPersonalAccessTokensOptions{UserID: Ptr(1), ListOptions: ListOptions{Page: 1, PerPage: 10}},\n\t)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\tcreatedAt1, err := time.Parse(time.RFC3339, \"2020-02-20T14:58:56.238Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\tlastUsedAt1, err := time.Parse(time.RFC3339, \"2021-04-20T16:31:39.105Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\texpiresAt1 := ISOTime(time.Date(2022, time.March, 21, 0, 0, 0, 0, time.UTC))\n\n\tcreatedAt2, err := time.Parse(time.RFC3339, \"2022-03-20T03:56:18.968Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\texpiresAt2 := ISOTime(time.Date(2022, time.March, 20, 0, 0, 0, 0, time.UTC))\n\n\twant := []*PersonalAccessToken{\n\t\t{\n\t\t\tID:         1,\n\t\t\tName:       \"test 1\",\n\t\t\tRevoked:    true,\n\t\t\tCreatedAt:  &createdAt1,\n\t\t\tScopes:     []string{\"api\"},\n\t\t\tUserID:     1,\n\t\t\tLastUsedAt: &lastUsedAt1,\n\t\t\tActive:     false,\n\t\t\tExpiresAt:  &expiresAt1,\n\t\t},\n\t\t{\n\t\t\tID:         2,\n\t\t\tName:       \"test 2\",\n\t\t\tRevoked:    false,\n\t\t\tCreatedAt:  &createdAt2,\n\t\t\tScopes:     []string{\"api\", \"read_user\"},\n\t\t\tUserID:     1,\n\t\t\tLastUsedAt: nil,\n\t\t\tActive:     false,\n\t\t\tExpiresAt:  &expiresAt2,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, personalAccessTokens) {\n\t\tt.Errorf(\n\t\t\t\"PersonalAccessTokens.ListPersonalAccessTokens returned %+v, want %+v\", personalAccessTokens, want,\n\t\t)\n\t}\n}\n\nfunc TestListPersonalAccessTokensNoUserFilter(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_personal_access_tokens_without_user_filter.json\")\n\t})\n\n\tpersonalAccessTokens, _, err := client.PersonalAccessTokens.ListPersonalAccessTokens(\n\t\t&ListPersonalAccessTokensOptions{ListOptions: ListOptions{Page: 1, PerPage: 10}},\n\t)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\tcreatedAt1, err := time.Parse(time.RFC3339, \"2020-02-20T14:58:56.238Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\tlastUsedAt1, err := time.Parse(time.RFC3339, \"2021-04-20T16:31:39.105Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\texpiresAt1 := ISOTime(time.Date(2022, time.March, 21, 0, 0, 0, 0, time.UTC))\n\n\tcreatedAt2, err := time.Parse(time.RFC3339, \"2022-03-20T03:56:18.968Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\texpiresAt2 := ISOTime(time.Date(2022, time.March, 20, 0, 0, 0, 0, time.UTC))\n\n\twant := []*PersonalAccessToken{\n\t\t{\n\t\t\tID:         1,\n\t\t\tName:       \"test 1\",\n\t\t\tRevoked:    true,\n\t\t\tCreatedAt:  &createdAt1,\n\t\t\tScopes:     []string{\"api\"},\n\t\t\tUserID:     1,\n\t\t\tLastUsedAt: &lastUsedAt1,\n\t\t\tActive:     false,\n\t\t\tExpiresAt:  &expiresAt1,\n\t\t},\n\t\t{\n\t\t\tID:         2,\n\t\t\tName:       \"test 2\",\n\t\t\tRevoked:    false,\n\t\t\tCreatedAt:  &createdAt2,\n\t\t\tScopes:     []string{\"api\", \"read_user\"},\n\t\t\tUserID:     2,\n\t\t\tLastUsedAt: nil,\n\t\t\tActive:     false,\n\t\t\tExpiresAt:  &expiresAt2,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, personalAccessTokens) {\n\t\tt.Errorf(\n\t\t\t\"PersonalAccessTokens.ListPersonalAccessTokens returned %+v, want %+v\", personalAccessTokens, want,\n\t\t)\n\t}\n}\n\nfunc TestGetSinglePersonalAccessTokenByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_personal_access_tokens_single.json\")\n\t})\n\n\ttoken, _, err := client.PersonalAccessTokens.GetSinglePersonalAccessTokenByID(1)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RevokePersonalAccessToken returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(time.RFC3339, \"2020-07-23T14:31:47.729Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\tlastUsedAt, err := time.Parse(time.RFC3339, \"2021-10-06T17:58:37.550Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\twant := &PersonalAccessToken{\n\t\tID:         1,\n\t\tName:       \"Test Token\",\n\t\tRevoked:    false,\n\t\tCreatedAt:  &createdAt,\n\t\tScopes:     []string{\"api\"},\n\t\tUserID:     1,\n\t\tLastUsedAt: &lastUsedAt,\n\t\tActive:     true,\n\t}\n\n\tif !reflect.DeepEqual(want, token) {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned %+v, want %+v\", token, want)\n\t}\n}\n\nfunc TestGetSinglePersonalAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/self\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_personal_access_tokens_single.json\")\n\t})\n\n\ttoken, _, err := client.PersonalAccessTokens.GetSinglePersonalAccessToken()\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RevokePersonalAccessToken returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(time.RFC3339, \"2020-07-23T14:31:47.729Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\tlastUsedAt, err := time.Parse(time.RFC3339, \"2021-10-06T17:58:37.550Z\")\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned error: %v\", err)\n\t}\n\n\twant := &PersonalAccessToken{\n\t\tID:         1,\n\t\tName:       \"Test Token\",\n\t\tRevoked:    false,\n\t\tCreatedAt:  &createdAt,\n\t\tScopes:     []string{\"api\"},\n\t\tUserID:     1,\n\t\tLastUsedAt: &lastUsedAt,\n\t\tActive:     true,\n\t}\n\n\tif !reflect.DeepEqual(want, token) {\n\t\tt.Errorf(\"PersonalAccessTokens.ListPersonalAccessTokens returned %+v, want %+v\", token, want)\n\t}\n}\n\nfunc TestRotatePersonalAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/42/rotate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/rotate_personal_access_token.json\")\n\t})\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2023-08-01T15:00:00.000Z\")\n\texpiration := ISOTime(time.Date(2023, time.August, 15, 0, 0, 0, 0, time.UTC))\n\topts := &RotatePersonalAccessTokenOptions{ExpiresAt: &expiration}\n\trotatedToken, _, err := client.PersonalAccessTokens.RotatePersonalAccessToken(42, opts)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RotatePersonalAccessToken returned error: %v\", err)\n\t}\n\n\twant := &PersonalAccessToken{\n\t\tID:        42,\n\t\tUserID:    1337,\n\t\tName:      \"Rotated Token\",\n\t\tScopes:    []string{\"api\"},\n\t\tExpiresAt: &expiration,\n\t\tCreatedAt: &createdAt,\n\t\tActive:    true,\n\t\tRevoked:   false,\n\t\tToken:     \"s3cr3t\",\n\t}\n\n\tif !reflect.DeepEqual(want, rotatedToken) {\n\t\tt.Errorf(\n\t\t\t\"PersonalAccessTokens.RotatePersonalAccessToken returned %+v, want %+v\", rotatedToken, want,\n\t\t)\n\t}\n}\n\nfunc TestRotatePersonalAccessTokenByID(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/42/rotate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/rotate_personal_access_token.json\")\n\t})\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2023-08-01T15:00:00.000Z\")\n\texpiration := ISOTime(time.Date(2023, time.August, 15, 0, 0, 0, 0, time.UTC))\n\topts := &RotatePersonalAccessTokenOptions{ExpiresAt: &expiration}\n\trotatedToken, _, err := client.PersonalAccessTokens.RotatePersonalAccessTokenByID(42, opts)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RotatePersonalAccessTokenByID returned error: %v\", err)\n\t}\n\n\twant := &PersonalAccessToken{\n\t\tID:        42,\n\t\tUserID:    1337,\n\t\tName:      \"Rotated Token\",\n\t\tScopes:    []string{\"api\"},\n\t\tExpiresAt: &expiration,\n\t\tCreatedAt: &createdAt,\n\t\tActive:    true,\n\t\tRevoked:   false,\n\t\tToken:     \"s3cr3t\",\n\t}\n\n\tif !reflect.DeepEqual(want, rotatedToken) {\n\t\tt.Errorf(\n\t\t\t\"PersonalAccessTokens.RotatePersonalAccessTokenByID returned %+v, want %+v\", rotatedToken, want,\n\t\t)\n\t}\n}\n\nfunc TestRotatePersonalAccessTokenSelf(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/self/rotate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/rotate_personal_access_token.json\")\n\t})\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2023-08-01T15:00:00.000Z\")\n\texpiration := ISOTime(time.Date(2023, time.August, 15, 0, 0, 0, 0, time.UTC))\n\topts := &RotatePersonalAccessTokenOptions{ExpiresAt: &expiration}\n\trotatedToken, _, err := client.PersonalAccessTokens.RotatePersonalAccessTokenSelf(opts)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RotatePersonalAccessTokenSelf returned error: %v\", err)\n\t}\n\n\twant := &PersonalAccessToken{\n\t\tID:        42,\n\t\tUserID:    1337,\n\t\tName:      \"Rotated Token\",\n\t\tScopes:    []string{\"api\"},\n\t\tExpiresAt: &expiration,\n\t\tCreatedAt: &createdAt,\n\t\tActive:    true,\n\t\tRevoked:   false,\n\t\tToken:     \"s3cr3t\",\n\t}\n\n\tif !reflect.DeepEqual(want, rotatedToken) {\n\t\tt.Errorf(\"PersonalAccessTokens.RotatePersonalAccessTokenSelf returned %+v, want %+v\", rotatedToken, want)\n\t}\n}\n\nfunc TestRevokePersonalAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.PersonalAccessTokens.RevokePersonalAccessToken(1)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RevokePersonalAccessToken returned error: %v\", err)\n\t}\n}\n\nfunc TestRevokePersonalAccessTokenByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.PersonalAccessTokens.RevokePersonalAccessTokenByID(1)\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RevokePersonalAccessTokenByID returned error: %v\", err)\n\t}\n}\n\nfunc TestRevokePersonalAccessTokenSelf(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/personal_access_tokens/self\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.PersonalAccessTokens.RevokePersonalAccessTokenSelf()\n\tif err != nil {\n\t\tt.Errorf(\"PersonalAccessTokens.RevokePersonalAccessTokenSelf returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "pipeline_schedules.go",
          "type": "blob",
          "size": 12.6015625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// PipelineSchedulesService handles communication with the pipeline\n// schedules related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pipeline_schedules.html\ntype PipelineSchedulesService struct {\n\tclient *Client\n}\n\n// PipelineSchedule represents a pipeline schedule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html\ntype PipelineSchedule struct {\n\tID           int                 `json:\"id\"`\n\tDescription  string              `json:\"description\"`\n\tRef          string              `json:\"ref\"`\n\tCron         string              `json:\"cron\"`\n\tCronTimezone string              `json:\"cron_timezone\"`\n\tNextRunAt    *time.Time          `json:\"next_run_at\"`\n\tActive       bool                `json:\"active\"`\n\tCreatedAt    *time.Time          `json:\"created_at\"`\n\tUpdatedAt    *time.Time          `json:\"updated_at\"`\n\tOwner        *User               `json:\"owner\"`\n\tLastPipeline *LastPipeline       `json:\"last_pipeline\"`\n\tVariables    []*PipelineVariable `json:\"variables\"`\n}\n\n// LastPipeline represents the last pipeline ran by schedule\n// this will be returned only for individual schedule get operation\ntype LastPipeline struct {\n\tID     int    `json:\"id\"`\n\tSHA    string `json:\"sha\"`\n\tRef    string `json:\"ref\"`\n\tStatus string `json:\"status\"`\n\tWebURL string `json:\"web_url\"`\n}\n\n// ListPipelineSchedulesOptions represents the available ListPipelineTriggers() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#get-all-pipeline-schedules\ntype ListPipelineSchedulesOptions ListOptions\n\n// ListPipelineSchedules gets a list of project triggers.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#get-all-pipeline-schedules\nfunc (s *PipelineSchedulesService) ListPipelineSchedules(pid interface{}, opt *ListPipelineSchedulesOptions, options ...RequestOptionFunc) ([]*PipelineSchedule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*PipelineSchedule\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// GetPipelineSchedule gets a pipeline schedule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#get-a-single-pipeline-schedule\nfunc (s *PipelineSchedulesService) GetPipelineSchedule(pid interface{}, schedule int, options ...RequestOptionFunc) (*PipelineSchedule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineSchedule)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ListPipelinesTriggeredByScheduleOptions represents the available\n// ListPipelinesTriggeredBySchedule() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#get-all-pipelines-triggered-by-a-pipeline-schedule\ntype ListPipelinesTriggeredByScheduleOptions ListOptions\n\n// ListPipelinesTriggeredBySchedule gets all pipelines triggered by a pipeline\n// schedule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#get-all-pipelines-triggered-by-a-pipeline-schedule\nfunc (s *PipelineSchedulesService) ListPipelinesTriggeredBySchedule(pid interface{}, schedule int, opt *ListPipelinesTriggeredByScheduleOptions, options ...RequestOptionFunc) ([]*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d/pipelines\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*Pipeline\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CreatePipelineScheduleOptions represents the available\n// CreatePipelineSchedule() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#create-a-new-pipeline-schedule\ntype CreatePipelineScheduleOptions struct {\n\tDescription  *string `url:\"description\" json:\"description\"`\n\tRef          *string `url:\"ref\" json:\"ref\"`\n\tCron         *string `url:\"cron\" json:\"cron\"`\n\tCronTimezone *string `url:\"cron_timezone,omitempty\" json:\"cron_timezone,omitempty\"`\n\tActive       *bool   `url:\"active,omitempty\" json:\"active,omitempty\"`\n}\n\n// CreatePipelineSchedule creates a pipeline schedule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#create-a-new-pipeline-schedule\nfunc (s *PipelineSchedulesService) CreatePipelineSchedule(pid interface{}, opt *CreatePipelineScheduleOptions, options ...RequestOptionFunc) (*PipelineSchedule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineSchedule)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// EditPipelineScheduleOptions represents the available\n// EditPipelineSchedule() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#edit-a-pipeline-schedule\ntype EditPipelineScheduleOptions struct {\n\tDescription  *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tRef          *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tCron         *string `url:\"cron,omitempty\" json:\"cron,omitempty\"`\n\tCronTimezone *string `url:\"cron_timezone,omitempty\" json:\"cron_timezone,omitempty\"`\n\tActive       *bool   `url:\"active,omitempty\" json:\"active,omitempty\"`\n}\n\n// EditPipelineSchedule edits a pipeline schedule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#edit-a-pipeline-schedule\nfunc (s *PipelineSchedulesService) EditPipelineSchedule(pid interface{}, schedule int, opt *EditPipelineScheduleOptions, options ...RequestOptionFunc) (*PipelineSchedule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineSchedule)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// TakeOwnershipOfPipelineSchedule sets the owner of the specified\n// pipeline schedule to the user issuing the request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#take-ownership-of-a-pipeline-schedule\nfunc (s *PipelineSchedulesService) TakeOwnershipOfPipelineSchedule(pid interface{}, schedule int, options ...RequestOptionFunc) (*PipelineSchedule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d/take_ownership\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineSchedule)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// DeletePipelineSchedule deletes a pipeline schedule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#delete-a-pipeline-schedule\nfunc (s *PipelineSchedulesService) DeletePipelineSchedule(pid interface{}, schedule int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// RunPipelineSchedule triggers a new scheduled pipeline to run immediately.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#run-a-scheduled-pipeline-immediately\nfunc (s *PipelineSchedulesService) RunPipelineSchedule(pid interface{}, schedule int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d/play\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// CreatePipelineScheduleVariableOptions represents the available\n// CreatePipelineScheduleVariable() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#create-a-new-pipeline-schedule\ntype CreatePipelineScheduleVariableOptions struct {\n\tKey          *string            `url:\"key\" json:\"key\"`\n\tValue        *string            `url:\"value\" json:\"value\"`\n\tVariableType *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// CreatePipelineScheduleVariable creates a pipeline schedule variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#create-a-new-pipeline-schedule\nfunc (s *PipelineSchedulesService) CreatePipelineScheduleVariable(pid interface{}, schedule int, opt *CreatePipelineScheduleVariableOptions, options ...RequestOptionFunc) (*PipelineVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d/variables\", PathEscape(project), schedule)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineVariable)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// EditPipelineScheduleVariableOptions represents the available\n// EditPipelineScheduleVariable() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#edit-a-pipeline-schedule-variable\ntype EditPipelineScheduleVariableOptions struct {\n\tValue        *string            `url:\"value\" json:\"value\"`\n\tVariableType *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// EditPipelineScheduleVariable creates a pipeline schedule variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#edit-a-pipeline-schedule-variable\nfunc (s *PipelineSchedulesService) EditPipelineScheduleVariable(pid interface{}, schedule int, key string, opt *EditPipelineScheduleVariableOptions, options ...RequestOptionFunc) (*PipelineVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d/variables/%s\", PathEscape(project), schedule, key)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineVariable)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// DeletePipelineScheduleVariable creates a pipeline schedule variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_schedules.html#delete-a-pipeline-schedule-variable\nfunc (s *PipelineSchedulesService) DeletePipelineScheduleVariable(pid interface{}, schedule int, key string, options ...RequestOptionFunc) (*PipelineVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline_schedules/%d/variables/%s\", PathEscape(project), schedule, key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineVariable)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n"
        },
        {
          "name": "pipeline_schedules_test.go",
          "type": "blob",
          "size": 1.259765625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestRunPipelineSchedule(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipeline_schedules/1/play\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\"message\": \"201 Created\"}`)\n\t})\n\n\tres, err := client.PipelineSchedules.RunPipelineSchedule(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"PipelineTriggers.RunPipelineTrigger returned error: %v\", err)\n\t}\n\n\tif res.StatusCode != http.StatusCreated {\n\t\tt.Errorf(\"PipelineSchedules.RunPipelineSchedule returned status %v, want %v\", res.StatusCode, http.StatusCreated)\n\t}\n}\n"
        },
        {
          "name": "pipeline_triggers.go",
          "type": "blob",
          "size": 7.517578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// PipelineTriggersService handles Project pipeline triggers.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html\ntype PipelineTriggersService struct {\n\tclient *Client\n}\n\n// PipelineTrigger represents a project pipeline trigger.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html\ntype PipelineTrigger struct {\n\tID          int        `json:\"id\"`\n\tDescription string     `json:\"description\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tDeletedAt   *time.Time `json:\"deleted_at\"`\n\tLastUsed    *time.Time `json:\"last_used\"`\n\tToken       string     `json:\"token\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tOwner       *User      `json:\"owner\"`\n}\n\n// ListPipelineTriggersOptions represents the available ListPipelineTriggers() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#list-project-trigger-tokens\ntype ListPipelineTriggersOptions ListOptions\n\n// ListPipelineTriggers gets a list of project triggers.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#list-project-trigger-tokens\nfunc (s *PipelineTriggersService) ListPipelineTriggers(pid interface{}, opt *ListPipelineTriggersOptions, options ...RequestOptionFunc) ([]*PipelineTrigger, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/triggers\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pt []*PipelineTrigger\n\tresp, err := s.client.Do(req, &pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// GetPipelineTrigger gets a specific pipeline trigger for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#get-trigger-token-details\nfunc (s *PipelineTriggersService) GetPipelineTrigger(pid interface{}, trigger int, options ...RequestOptionFunc) (*PipelineTrigger, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/triggers/%d\", PathEscape(project), trigger)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(PipelineTrigger)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// AddPipelineTriggerOptions represents the available AddPipelineTrigger() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#create-a-trigger-token\ntype AddPipelineTriggerOptions struct {\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n}\n\n// AddPipelineTrigger adds a pipeline trigger to a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#create-a-trigger-token\nfunc (s *PipelineTriggersService) AddPipelineTrigger(pid interface{}, opt *AddPipelineTriggerOptions, options ...RequestOptionFunc) (*PipelineTrigger, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/triggers\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(PipelineTrigger)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// EditPipelineTriggerOptions represents the available EditPipelineTrigger() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#update-a-project-trigger-token\ntype EditPipelineTriggerOptions struct {\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n}\n\n// EditPipelineTrigger edits a trigger for a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#update-a-project-trigger-token\nfunc (s *PipelineTriggersService) EditPipelineTrigger(pid interface{}, trigger int, opt *EditPipelineTriggerOptions, options ...RequestOptionFunc) (*PipelineTrigger, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/triggers/%d\", PathEscape(project), trigger)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(PipelineTrigger)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// TakeOwnershipOfPipelineTrigger sets the owner of the specified\n// pipeline trigger to the user issuing the request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#take-ownership-of-a-project-trigger\nfunc (s *PipelineTriggersService) TakeOwnershipOfPipelineTrigger(pid interface{}, trigger int, options ...RequestOptionFunc) (*PipelineTrigger, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/triggers/%d/take_ownership\", PathEscape(project), trigger)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(PipelineTrigger)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// DeletePipelineTrigger removes a trigger from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#remove-a-project-trigger-token\nfunc (s *PipelineTriggersService) DeletePipelineTrigger(pid interface{}, trigger int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/triggers/%d\", PathEscape(project), trigger)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// RunPipelineTriggerOptions represents the available RunPipelineTrigger() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#trigger-a-pipeline-with-a-token\ntype RunPipelineTriggerOptions struct {\n\tRef       *string           `url:\"ref\" json:\"ref\"`\n\tToken     *string           `url:\"token\" json:\"token\"`\n\tVariables map[string]string `url:\"variables,omitempty\" json:\"variables,omitempty\"`\n}\n\n// RunPipelineTrigger starts a trigger from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipeline_triggers.html#trigger-a-pipeline-with-a-token\nfunc (s *PipelineTriggersService) RunPipelineTrigger(pid interface{}, opt *RunPipelineTriggerOptions, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/trigger/pipeline\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(Pipeline)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n"
        },
        {
          "name": "pipeline_triggers_test.go",
          "type": "blob",
          "size": 1.2978515625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestRunPipeline(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/trigger/pipeline\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"status\":\"pending\"}`)\n\t})\n\n\topt := &RunPipelineTriggerOptions{Ref: Ptr(\"master\")}\n\tpipeline, _, err := client.PipelineTriggers.RunPipelineTrigger(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"PipelineTriggers.RunPipelineTrigger returned error: %v\", err)\n\t}\n\n\twant := &Pipeline{ID: 1, Status: \"pending\"}\n\tif !reflect.DeepEqual(want, pipeline) {\n\t\tt.Errorf(\"PipelineTriggers.RunPipelineTrigger returned %+v, want %+v\", pipeline, want)\n\t}\n}\n"
        },
        {
          "name": "pipelines.go",
          "type": "blob",
          "size": 14.5322265625,
          "content": "//\n// Copyright 2021, Igor Varavko\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// PipelinesService handles communication with the repositories related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pipelines.html\ntype PipelinesService struct {\n\tclient *Client\n}\n\n// PipelineVariable represents a pipeline variable.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pipelines.html\ntype PipelineVariable struct {\n\tKey          string            `json:\"key\"`\n\tValue        string            `json:\"value\"`\n\tVariableType VariableTypeValue `json:\"variable_type\"`\n}\n\n// Pipeline represents a GitLab pipeline.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pipelines.html\ntype Pipeline struct {\n\tID             int             `json:\"id\"`\n\tIID            int             `json:\"iid\"`\n\tProjectID      int             `json:\"project_id\"`\n\tStatus         string          `json:\"status\"`\n\tSource         string          `json:\"source\"`\n\tRef            string          `json:\"ref\"`\n\tName           string          `json:\"name\"`\n\tSHA            string          `json:\"sha\"`\n\tBeforeSHA      string          `json:\"before_sha\"`\n\tTag            bool            `json:\"tag\"`\n\tYamlErrors     string          `json:\"yaml_errors\"`\n\tUser           *BasicUser      `json:\"user\"`\n\tUpdatedAt      *time.Time      `json:\"updated_at\"`\n\tCreatedAt      *time.Time      `json:\"created_at\"`\n\tStartedAt      *time.Time      `json:\"started_at\"`\n\tFinishedAt     *time.Time      `json:\"finished_at\"`\n\tCommittedAt    *time.Time      `json:\"committed_at\"`\n\tDuration       int             `json:\"duration\"`\n\tQueuedDuration int             `json:\"queued_duration\"`\n\tCoverage       string          `json:\"coverage\"`\n\tWebURL         string          `json:\"web_url\"`\n\tDetailedStatus *DetailedStatus `json:\"detailed_status\"`\n}\n\n// DetailedStatus contains detailed information about the status of a pipeline.\ntype DetailedStatus struct {\n\tIcon         string `json:\"icon\"`\n\tText         string `json:\"text\"`\n\tLabel        string `json:\"label\"`\n\tGroup        string `json:\"group\"`\n\tTooltip      string `json:\"tooltip\"`\n\tHasDetails   bool   `json:\"has_details\"`\n\tDetailsPath  string `json:\"details_path\"`\n\tIllustration struct {\n\t\tImage string `json:\"image\"`\n\t} `json:\"illustration\"`\n\tFavicon string `json:\"favicon\"`\n}\n\nfunc (p Pipeline) String() string {\n\treturn Stringify(p)\n}\n\n// PipelineTestReport contains a detailed report of a test run.\ntype PipelineTestReport struct {\n\tTotalTime    float64               `json:\"total_time\"`\n\tTotalCount   int                   `json:\"total_count\"`\n\tSuccessCount int                   `json:\"success_count\"`\n\tFailedCount  int                   `json:\"failed_count\"`\n\tSkippedCount int                   `json:\"skipped_count\"`\n\tErrorCount   int                   `json:\"error_count\"`\n\tTestSuites   []*PipelineTestSuites `json:\"test_suites\"`\n}\n\n// PipelineTestSuites contains test suites results.\ntype PipelineTestSuites struct {\n\tName         string               `json:\"name\"`\n\tTotalTime    float64              `json:\"total_time\"`\n\tTotalCount   int                  `json:\"total_count\"`\n\tSuccessCount int                  `json:\"success_count\"`\n\tFailedCount  int                  `json:\"failed_count\"`\n\tSkippedCount int                  `json:\"skipped_count\"`\n\tErrorCount   int                  `json:\"error_count\"`\n\tTestCases    []*PipelineTestCases `json:\"test_cases\"`\n}\n\n// PipelineTestCases contains test cases details.\ntype PipelineTestCases struct {\n\tStatus         string          `json:\"status\"`\n\tName           string          `json:\"name\"`\n\tClassname      string          `json:\"classname\"`\n\tFile           string          `json:\"file\"`\n\tExecutionTime  float64         `json:\"execution_time\"`\n\tSystemOutput   interface{}     `json:\"system_output\"`\n\tStackTrace     string          `json:\"stack_trace\"`\n\tAttachmentURL  string          `json:\"attachment_url\"`\n\tRecentFailures *RecentFailures `json:\"recent_failures\"`\n}\n\n// RecentFailures contains failures count for the project's default branch.\ntype RecentFailures struct {\n\tCount      int    `json:\"count\"`\n\tBaseBranch string `json:\"base_branch\"`\n}\n\nfunc (p PipelineTestReport) String() string {\n\treturn Stringify(p)\n}\n\n// PipelineInfo shows the basic entities of a pipeline, mostly used as fields\n// on other assets, like Commit.\ntype PipelineInfo struct {\n\tID        int        `json:\"id\"`\n\tIID       int        `json:\"iid\"`\n\tProjectID int        `json:\"project_id\"`\n\tStatus    string     `json:\"status\"`\n\tSource    string     `json:\"source\"`\n\tRef       string     `json:\"ref\"`\n\tSHA       string     `json:\"sha\"`\n\tWebURL    string     `json:\"web_url\"`\n\tUpdatedAt *time.Time `json:\"updated_at\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n}\n\nfunc (p PipelineInfo) String() string {\n\treturn Stringify(p)\n}\n\n// ListProjectPipelinesOptions represents the available ListProjectPipelines()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#list-project-pipelines\ntype ListProjectPipelinesOptions struct {\n\tListOptions\n\tScope         *string          `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n\tStatus        *BuildStateValue `url:\"status,omitempty\" json:\"status,omitempty\"`\n\tSource        *string          `url:\"source,omitempty\" json:\"source,omitempty\"`\n\tRef           *string          `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tSHA           *string          `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n\tYamlErrors    *bool            `url:\"yaml_errors,omitempty\" json:\"yaml_errors,omitempty\"`\n\tName          *string          `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tUsername      *string          `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tUpdatedAfter  *time.Time       `url:\"updated_after,omitempty\" json:\"updated_after,omitempty\"`\n\tUpdatedBefore *time.Time       `url:\"updated_before,omitempty\" json:\"updated_before,omitempty\"`\n\tOrderBy       *string          `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort          *string          `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListProjectPipelines gets a list of project piplines.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#list-project-pipelines\nfunc (s *PipelinesService) ListProjectPipelines(pid interface{}, opt *ListProjectPipelinesOptions, options ...RequestOptionFunc) ([]*PipelineInfo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*PipelineInfo\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetPipeline gets a single project pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#get-a-single-pipeline\nfunc (s *PipelinesService) GetPipeline(pid interface{}, pipeline int, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pipeline)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetPipelineVariables gets the variables of a single project pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#get-variables-of-a-pipeline\nfunc (s *PipelinesService) GetPipelineVariables(pid interface{}, pipeline int, options ...RequestOptionFunc) ([]*PipelineVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/variables\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*PipelineVariable\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetPipelineTestReport gets the test report of a single project pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#get-a-pipelines-test-report\nfunc (s *PipelinesService) GetPipelineTestReport(pid interface{}, pipeline int, options ...RequestOptionFunc) (*PipelineTestReport, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/test_report\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(PipelineTestReport)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetLatestPipelineOptions represents the available GetLatestPipeline() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#get-the-latest-pipeline\ntype GetLatestPipelineOptions struct {\n\tRef *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\n// GetLatestPipeline gets the latest pipeline for a specific ref in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#get-the-latest-pipeline\nfunc (s *PipelinesService) GetLatestPipeline(pid interface{}, opt *GetLatestPipelineOptions, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/latest\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pipeline)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CreatePipelineOptions represents the available CreatePipeline() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#create-a-new-pipeline\ntype CreatePipelineOptions struct {\n\tRef       *string                     `url:\"ref\" json:\"ref\"`\n\tVariables *[]*PipelineVariableOptions `url:\"variables,omitempty\" json:\"variables,omitempty\"`\n}\n\n// PipelineVariable represents a pipeline variable.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/pipelines.html#create-a-new-pipeline\ntype PipelineVariableOptions struct {\n\tKey          *string            `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tValue        *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tVariableType *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// CreatePipeline creates a new project pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#create-a-new-pipeline\nfunc (s *PipelinesService) CreatePipeline(pid interface{}, opt *CreatePipelineOptions, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipeline\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pipeline)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// RetryPipelineBuild retries failed builds in a pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#retry-jobs-in-a-pipeline\nfunc (s *PipelinesService) RetryPipelineBuild(pid interface{}, pipeline int, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/retry\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pipeline)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CancelPipelineBuild cancels a pipeline builds.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#cancel-a-pipelines-jobs\nfunc (s *PipelinesService) CancelPipelineBuild(pid interface{}, pipeline int, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/cancel\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pipeline)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// DeletePipeline deletes an existing pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#delete-a-pipeline\nfunc (s *PipelinesService) DeletePipeline(pid interface{}, pipeline int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// UpdatePipelineMetadataOptions represents the available UpdatePipelineMetadata()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#update-pipeline-metadata\ntype UpdatePipelineMetadataOptions struct {\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// UpdatePipelineMetadata You can update the metadata of a pipeline. The metadata\n// contains the name of the pipeline.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/pipelines.html#update-pipeline-metadata\nfunc (s *PipelinesService) UpdatePipelineMetadata(pid interface{}, pipeline int, opt *UpdatePipelineMetadataOptions, options ...RequestOptionFunc) (*Pipeline, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/pipelines/%d/metadata\", PathEscape(project), pipeline)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Pipeline)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n"
        },
        {
          "name": "pipelines_test.go",
          "type": "blob",
          "size": 8.595703125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListProjectPipelines(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectPipelinesOptions{Ref: Ptr(\"master\")}\n\tpiplines, _, err := client.Pipelines.ListProjectPipelines(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.ListProjectPipelines returned error: %v\", err)\n\t}\n\n\twant := []*PipelineInfo{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, piplines) {\n\t\tt.Errorf(\"Pipelines.ListProjectPipelines returned %+v, want %+v\", piplines, want)\n\t}\n}\n\nfunc TestGetPipeline(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/5949167\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1,\"status\":\"success\"}`)\n\t})\n\n\tpipeline, _, err := client.Pipelines.GetPipeline(1, 5949167)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.GetPipeline returned error: %v\", err)\n\t}\n\n\twant := &Pipeline{ID: 1, Status: \"success\"}\n\tif !reflect.DeepEqual(want, pipeline) {\n\t\tt.Errorf(\"Pipelines.GetPipeline returned %+v, want %+v\", pipeline, want)\n\t}\n}\n\nfunc TestGetPipelineVariables(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/5949167/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"key\":\"RUN_NIGHTLY_BUILD\",\"variable_type\":\"env_var\",\"value\":\"true\"},{\"key\":\"foo\",\"value\":\"bar\"}]`)\n\t})\n\n\tvariables, _, err := client.Pipelines.GetPipelineVariables(1, 5949167)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.GetPipelineVariables returned error: %v\", err)\n\t}\n\n\twant := []*PipelineVariable{{Key: \"RUN_NIGHTLY_BUILD\", Value: \"true\", VariableType: \"env_var\"}, {Key: \"foo\", Value: \"bar\"}}\n\tif !reflect.DeepEqual(want, variables) {\n\t\tt.Errorf(\"Pipelines.GetPipelineVariables returned %+v, want %+v\", variables, want)\n\t}\n}\n\nfunc TestGetPipelineTestReport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/123456/test_report\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_pipeline_testreport.json\")\n\t})\n\n\ttestreport, _, err := client.Pipelines.GetPipelineTestReport(1, 123456)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.GetPipelineTestReport returned error: %v\", err)\n\t}\n\n\twant := &PipelineTestReport{\n\t\tTotalTime:    61.502,\n\t\tTotalCount:   9,\n\t\tSuccessCount: 5,\n\t\tErrorCount:   4,\n\t\tTestSuites: []*PipelineTestSuites{\n\t\t\t{\n\t\t\t\tName:         \"Failing\",\n\t\t\t\tTotalTime:    60.494,\n\t\t\t\tTotalCount:   8,\n\t\t\t\tSuccessCount: 4,\n\t\t\t\tErrorCount:   4,\n\t\t\t\tTestCases: []*PipelineTestCases{\n\t\t\t\t\t{\n\t\t\t\t\t\tStatus:        \"error\",\n\t\t\t\t\t\tName:          \"Error testcase 1\",\n\t\t\t\t\t\tClassname:     \"MyClassOne\",\n\t\t\t\t\t\tFile:          \"/path/file.ext\",\n\t\t\t\t\t\tExecutionTime: 19.987,\n\t\t\t\t\t\tSystemOutput:  \"Failed test\",\n\t\t\t\t\t\tStackTrace:    \"java.lang.Exception: Stack trace\\nat java.base/java.lang.Thread.dumpStack(Thread.java:1383)\",\n\t\t\t\t\t\tAttachmentURL: \"http://foo.bar\",\n\t\t\t\t\t\tRecentFailures: &RecentFailures{\n\t\t\t\t\t\t\tCount:      10,\n\t\t\t\t\t\t\tBaseBranch: \"master\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tStatus:        \"error\",\n\t\t\t\t\t\tName:          \"Error testcase 2\",\n\t\t\t\t\t\tClassname:     \"MyClass\",\n\t\t\t\t\t\tExecutionTime: 19.984,\n\t\t\t\t\t\tSystemOutput: map[string]interface{}{\n\t\t\t\t\t\t\t\"message\": \"Failed test\",\n\t\t\t\t\t\t\t\"type\":    \"MultipleExceptionError\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tStatus:    \"error\",\n\t\t\t\t\t\tName:      \"Error testcase 3\",\n\t\t\t\t\t\tClassname: \"MyClass\",\n\t\t\t\t\t\tSystemOutput: []interface{}{\n\t\t\t\t\t\t\t\"Failed test a\",\n\t\t\t\t\t\t\t\"Failed test b\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tStatus:        \"success\",\n\t\t\t\t\t\tName:          \"Succes full testcase\",\n\t\t\t\t\t\tClassname:     \"MyClass\",\n\t\t\t\t\t\tExecutionTime: 19.7799999999999985,\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tName:         \"Succes suite\",\n\t\t\t\tTotalTime:    1.008,\n\t\t\t\tTotalCount:   1,\n\t\t\t\tSuccessCount: 1,\n\t\t\t\tTestCases: []*PipelineTestCases{{\n\t\t\t\t\tStatus:        \"success\",\n\t\t\t\t\tName:          \"Succesfull testcase\",\n\t\t\t\t\tClassname:     \"MyClass\",\n\t\t\t\t\tExecutionTime: 1.008,\n\t\t\t\t}},\n\t\t\t},\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, testreport) {\n\t\tt.Errorf(\"Pipelines.GetPipelineTestReport returned %+v, want %+v\", testreport, want)\n\t}\n}\n\nfunc TestGetLatestPipeline(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/latest\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"\")\n\t\tfmt.Fprint(w, `{\"id\":1,\"status\":\"success\"}`)\n\t})\n\n\tpipeline, _, err := client.Pipelines.GetLatestPipeline(1, nil)\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, &Pipeline{ID: 1, Status: \"success\"}, pipeline)\n}\n\nfunc TestGetLatestPipeline_WithRef(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/latest\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"ref=abc\")\n\t\tfmt.Fprint(w, `{\"id\":1,\"status\":\"success\"}`)\n\t})\n\n\tpipeline, _, err := client.Pipelines.GetLatestPipeline(1, &GetLatestPipelineOptions{\n\t\tRef: Ptr(\"abc\"),\n\t})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, &Pipeline{ID: 1, Status: \"success\"}, pipeline)\n}\n\nfunc TestCreatePipeline(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipeline\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"status\":\"pending\"}`)\n\t})\n\n\topt := &CreatePipelineOptions{Ref: Ptr(\"master\")}\n\tpipeline, _, err := client.Pipelines.CreatePipeline(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.CreatePipeline returned error: %v\", err)\n\t}\n\n\twant := &Pipeline{ID: 1, Status: \"pending\"}\n\tif !reflect.DeepEqual(want, pipeline) {\n\t\tt.Errorf(\"Pipelines.CreatePipeline returned %+v, want %+v\", pipeline, want)\n\t}\n}\n\nfunc TestRetryPipelineBuild(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/5949167/retry\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintln(w, `{\"id\":1, \"status\":\"pending\"}`)\n\t})\n\n\tpipeline, _, err := client.Pipelines.RetryPipelineBuild(1, 5949167)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.RetryPipelineBuild returned error: %v\", err)\n\t}\n\n\twant := &Pipeline{ID: 1, Status: \"pending\"}\n\tif !reflect.DeepEqual(want, pipeline) {\n\t\tt.Errorf(\"Pipelines.RetryPipelineBuild returned %+v, want %+v\", pipeline, want)\n\t}\n}\n\nfunc TestCancelPipelineBuild(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/5949167/cancel\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintln(w, `{\"id\":1, \"status\":\"canceled\"}`)\n\t})\n\n\tpipeline, _, err := client.Pipelines.CancelPipelineBuild(1, 5949167)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.CancelPipelineBuild returned error: %v\", err)\n\t}\n\n\twant := &Pipeline{ID: 1, Status: \"canceled\"}\n\tif !reflect.DeepEqual(want, pipeline) {\n\t\tt.Errorf(\"Pipelines.CancelPipelineBuild returned %+v, want %+v\", pipeline, want)\n\t}\n}\n\nfunc TestDeletePipeline(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/5949167\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Pipelines.DeletePipeline(\"1\", 5949167)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.DeletePipeline returned error: %v\", err)\n\t}\n}\n\nfunc TestUpdateMetadata(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/pipelines/234/metadata\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"status\":\"running\"}`)\n\t})\n\n\topt := &UpdatePipelineMetadataOptions{Name: Ptr(\"new pipeline title\")}\n\tpipeline, _, err := client.Pipelines.UpdatePipelineMetadata(\"1\", 234, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Pipelines.UpdatePipelineMetadata returned error: %v\", err)\n\t}\n\n\twant := &Pipeline{ID: 1, Status: \"running\"}\n\tif !reflect.DeepEqual(want, pipeline) {\n\t\tt.Errorf(\"Pipelines.UpdatePipelineMetadata returned %+v, want %+v\", pipeline, want)\n\t}\n}\n"
        },
        {
          "name": "plan_limits.go",
          "type": "blob",
          "size": 4.1484375,
          "content": "//\n// Copyright 2021, Igor Varavko\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport \"net/http\"\n\n// PlanLimitsService handles communication with the repositories related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/plan_limits.html\ntype PlanLimitsService struct {\n\tclient *Client\n}\n\n// PlanLimit represents a GitLab pipeline.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/plan_limits.html\ntype PlanLimit struct {\n\tConanMaxFileSize           int `json:\"conan_max_file_size,omitempty\"`\n\tGenericPackagesMaxFileSize int `json:\"generic_packages_max_file_size,omitempty\"`\n\tHelmMaxFileSize            int `json:\"helm_max_file_size,omitempty\"`\n\tMavenMaxFileSize           int `json:\"maven_max_file_size,omitempty\"`\n\tNPMMaxFileSize             int `json:\"npm_max_file_size,omitempty\"`\n\tNugetMaxFileSize           int `json:\"nuget_max_file_size,omitempty\"`\n\tPyPiMaxFileSize            int `json:\"pypi_max_file_size,omitempty\"`\n\tTerraformModuleMaxFileSize int `json:\"terraform_module_max_file_size,omitempty\"`\n}\n\n// GetCurrentPlanLimitsOptions represents the available GetCurrentPlanLimits()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/plan_limits.html#get-current-plan-limits\ntype GetCurrentPlanLimitsOptions struct {\n\tPlanName *string `url:\"plan_name,omitempty\" json:\"plan_name,omitempty\"`\n}\n\n// List the current limits of a plan on the GitLab instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/plan_limits.html#get-current-plan-limits\nfunc (s *PlanLimitsService) GetCurrentPlanLimits(opt *GetCurrentPlanLimitsOptions, options ...RequestOptionFunc) (*PlanLimit, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"application/plan_limits\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpl := new(PlanLimit)\n\tresp, err := s.client.Do(req, pl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pl, resp, nil\n}\n\n// ChangePlanLimitOptions represents the available ChangePlanLimits() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/plan_limits.html#change-plan-limits\ntype ChangePlanLimitOptions struct {\n\tPlanName                   *string `url:\"plan_name,omitempty\" json:\"plan_name,omitempty\"`\n\tConanMaxFileSize           *int    `url:\"conan_max_file_size,omitempty\" json:\"conan_max_file_size,omitempty\"`\n\tGenericPackagesMaxFileSize *int    `url:\"generic_packages_max_file_size,omitempty\" json:\"generic_packages_max_file_size,omitempty\"`\n\tHelmMaxFileSize            *int    `url:\"helm_max_file_size,omitempty\" json:\"helm_max_file_size,omitempty\"`\n\tMavenMaxFileSize           *int    `url:\"maven_max_file_size,omitempty\" json:\"maven_max_file_size,omitempty\"`\n\tNPMMaxFileSize             *int    `url:\"npm_max_file_size,omitempty\" json:\"npm_max_file_size,omitempty\"`\n\tNugetMaxFileSize           *int    `url:\"nuget_max_file_size,omitempty\" json:\"nuget_max_file_size,omitempty\"`\n\tPyPiMaxFileSize            *int    `url:\"pypi_max_file_size,omitempty\" json:\"pypi_max_file_size,omitempty\"`\n\tTerraformModuleMaxFileSize *int    `url:\"terraform_module_max_file_size,omitempty\" json:\"terraform_module_max_file_size,omitempty\"`\n}\n\n// ChangePlanLimits modifies the limits of a plan on the GitLab instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/plan_limits.html#change-plan-limits\nfunc (s *PlanLimitsService) ChangePlanLimits(opt *ChangePlanLimitOptions, options ...RequestOptionFunc) (*PlanLimit, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPut, \"application/plan_limits\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpl := new(PlanLimit)\n\tresp, err := s.client.Do(req, pl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pl, resp, nil\n}\n"
        },
        {
          "name": "plan_limits_test.go",
          "type": "blob",
          "size": 3.1533203125,
          "content": "//\n// Copyright 2021, Igor Varavko\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetCurrentPlanLimits(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/plan_limits\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"conan_max_file_size\": 3221225472,\n\t\t\t\"generic_packages_max_file_size\": 5368709120,\n\t\t\t\"helm_max_file_size\": 5242880,\n\t\t\t\"maven_max_file_size\": 3221225472,\n\t\t\t\"npm_max_file_size\": 524288000,\n\t\t\t\"nuget_max_file_size\": 524288000,\n\t\t\t\"pypi_max_file_size\": 3221225472,\n\t\t\t\"terraform_module_max_file_size\": 1073741824\n\t\t  }`)\n\t})\n\n\topt := &GetCurrentPlanLimitsOptions{\n\t\tPlanName: Ptr(\"default\"),\n\t}\n\tplanlimit, _, err := client.PlanLimits.GetCurrentPlanLimits(opt)\n\tif err != nil {\n\t\tt.Errorf(\"PlanLimits.GetCurrentPlanLimits returned error: %v\", err)\n\t}\n\n\twant := &PlanLimit{\n\t\tConanMaxFileSize:           3221225472,\n\t\tGenericPackagesMaxFileSize: 5368709120,\n\t\tHelmMaxFileSize:            5242880,\n\t\tMavenMaxFileSize:           3221225472,\n\t\tNPMMaxFileSize:             524288000,\n\t\tNugetMaxFileSize:           524288000,\n\t\tPyPiMaxFileSize:            3221225472,\n\t\tTerraformModuleMaxFileSize: 1073741824,\n\t}\n\n\tif !reflect.DeepEqual(want, planlimit) {\n\t\tt.Errorf(\"PlanLimits.GetCurrentPlanLimits returned %+v, want %+v\", planlimit, want)\n\t}\n}\n\nfunc TestChangePlanLimits(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/plan_limits\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"conan_max_file_size\": 3221225472,\n\t\t\t\"generic_packages_max_file_size\": 5368709120,\n\t\t\t\"helm_max_file_size\": 5242880,\n\t\t\t\"maven_max_file_size\": 3221225472,\n\t\t\t\"npm_max_file_size\": 524288000,\n\t\t\t\"nuget_max_file_size\": 524288000,\n\t\t\t\"pypi_max_file_size\": 3221225472,\n\t\t\t\"terraform_module_max_file_size\": 1073741824\n\t\t  }`)\n\t})\n\n\topt := &ChangePlanLimitOptions{\n\t\tPlanName:         Ptr(\"default\"),\n\t\tConanMaxFileSize: Ptr(3221225472),\n\t}\n\tplanlimit, _, err := client.PlanLimits.ChangePlanLimits(opt)\n\tif err != nil {\n\t\tt.Errorf(\"PlanLimits.ChangePlanLimits returned error: %v\", err)\n\t}\n\n\twant := &PlanLimit{\n\t\tConanMaxFileSize:           3221225472,\n\t\tGenericPackagesMaxFileSize: 5368709120,\n\t\tHelmMaxFileSize:            5242880,\n\t\tMavenMaxFileSize:           3221225472,\n\t\tNPMMaxFileSize:             524288000,\n\t\tNugetMaxFileSize:           524288000,\n\t\tPyPiMaxFileSize:            3221225472,\n\t\tTerraformModuleMaxFileSize: 1073741824,\n\t}\n\n\tif !reflect.DeepEqual(want, planlimit) {\n\t\tt.Errorf(\"PlanLimits.ChangePlanLimits returned %+v, want %+v\", planlimit, want)\n\t}\n}\n"
        },
        {
          "name": "project_access_tokens.go",
          "type": "blob",
          "size": 6.4501953125,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectAccessTokensService handles communication with the\n// project access tokens related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_access_tokens.html\ntype ProjectAccessTokensService struct {\n\tclient *Client\n}\n\n// ProjectAccessToken represents a GitLab project access token.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_access_tokens.html\ntype ProjectAccessToken struct {\n\tID          int              `json:\"id\"`\n\tUserID      int              `json:\"user_id\"`\n\tName        string           `json:\"name\"`\n\tScopes      []string         `json:\"scopes\"`\n\tCreatedAt   *time.Time       `json:\"created_at\"`\n\tLastUsedAt  *time.Time       `json:\"last_used_at\"`\n\tExpiresAt   *ISOTime         `json:\"expires_at\"`\n\tActive      bool             `json:\"active\"`\n\tRevoked     bool             `json:\"revoked\"`\n\tToken       string           `json:\"token\"`\n\tAccessLevel AccessLevelValue `json:\"access_level\"`\n}\n\nfunc (v ProjectAccessToken) String() string {\n\treturn Stringify(v)\n}\n\n// ListProjectAccessTokensOptions represents the available\n// ListProjectAccessTokens() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#list-project-access-tokens\ntype ListProjectAccessTokensOptions ListOptions\n\n// ListProjectAccessTokens gets a list of all project access tokens in a\n// project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#list-project-access-tokens\nfunc (s *ProjectAccessTokensService) ListProjectAccessTokens(pid interface{}, opt *ListProjectAccessTokensOptions, options ...RequestOptionFunc) ([]*ProjectAccessToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_tokens\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pats []*ProjectAccessToken\n\tresp, err := s.client.Do(req, &pats)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pats, resp, nil\n}\n\n// GetProjectAccessToken gets a single project access tokens in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#get-a-project-access-token\nfunc (s *ProjectAccessTokensService) GetProjectAccessToken(pid interface{}, id int, options ...RequestOptionFunc) (*ProjectAccessToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_tokens/%d\", PathEscape(project), id)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(ProjectAccessToken)\n\tresp, err := s.client.Do(req, &pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// CreateProjectAccessTokenOptions represents the available CreateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#create-a-project-access-token\ntype CreateProjectAccessTokenOptions struct {\n\tName        *string           `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tScopes      *[]string         `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt   *ISOTime          `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// CreateProjectAccessToken creates a new project access token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#create-a-project-access-token\nfunc (s *ProjectAccessTokensService) CreateProjectAccessToken(pid interface{}, opt *CreateProjectAccessTokenOptions, options ...RequestOptionFunc) (*ProjectAccessToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_tokens\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(ProjectAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RotateProjectAccessTokenOptions represents the available RotateProjectAccessToken()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#rotate-a-project-access-token\ntype RotateProjectAccessTokenOptions struct {\n\tExpiresAt *ISOTime `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// RotateProjectAccessToken revokes a project access token and returns a new\n// project access token that expires in one week per default.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#rotate-a-project-access-token\nfunc (s *ProjectAccessTokensService) RotateProjectAccessToken(pid interface{}, id int, opt *RotateProjectAccessTokenOptions, options ...RequestOptionFunc) (*ProjectAccessToken, *Response, error) {\n\tprojects, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_tokens/%d/rotate\", PathEscape(projects), id)\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpat := new(ProjectAccessToken)\n\tresp, err := s.client.Do(req, pat)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pat, resp, nil\n}\n\n// RevokeProjectAccessToken revokes a project access token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_access_tokens.html#revoke-a-project-access-token\nfunc (s *ProjectAccessTokensService) RevokeProjectAccessToken(pid interface{}, id int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/access_tokens/%d\", PathEscape(project), id)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_access_tokens_test.go",
          "type": "blob",
          "size": 6.1611328125,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListProjectAccessTokens(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_project_access_tokens.json\")\n\t})\n\n\tprojectAccessTokens, _, err := client.ProjectAccessTokens.ListProjectAccessTokens(1, &ListProjectAccessTokensOptions{Page: 1, PerPage: 20})\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.ListProjectAccessTokens returned error: %v\", err)\n\t}\n\n\ttime1, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.ListProjectAccessTokens returned error: %v\", err)\n\t}\n\ttime2, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.340Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.ListProjectAccessTokens returned error: %v\", err)\n\t}\n\ttime3, err := time.Parse(time.RFC3339, \"2021-03-10T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"GroupAccessTokens.ListGroupAccessTokens returned error: %v\", err)\n\t}\n\n\twant := []*ProjectAccessToken{\n\t\t{\n\t\t\tID:          1876,\n\t\t\tUserID:      2453,\n\t\t\tName:        \"token 10\",\n\t\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\t\tCreatedAt:   &time1,\n\t\t\tLastUsedAt:  &time3,\n\t\t\tActive:      true,\n\t\t\tRevoked:     false,\n\t\t\tAccessLevel: AccessLevelValue(40),\n\t\t},\n\t\t{\n\t\t\tID:          1877,\n\t\t\tUserID:      2456,\n\t\t\tName:        \"token 8\",\n\t\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\t\tCreatedAt:   &time2,\n\t\t\tActive:      true,\n\t\t\tRevoked:     false,\n\t\t\tAccessLevel: AccessLevelValue(30),\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, projectAccessTokens) {\n\t\tt.Errorf(\"ProjectAccessTokens.ListProjectAccessTokens returned %+v, want %+v\", projectAccessTokens, want)\n\t}\n}\n\nfunc TestGetProjectAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_tokens/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_project_access_token.json\")\n\t})\n\n\tprojectAccessToken, _, err := client.ProjectAccessTokens.GetProjectAccessToken(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.GetProjectAccessToken returned error: %v\", err)\n\t}\n\n\tcreatedAt, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.GetProjectAccessToken returned error: %v\", err)\n\t}\n\n\twant := &ProjectAccessToken{\n\t\tID:          1,\n\t\tUserID:      2453,\n\t\tName:        \"token 10\",\n\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\tCreatedAt:   &createdAt,\n\t\tActive:      true,\n\t\tRevoked:     false,\n\t\tAccessLevel: AccessLevelValue(40),\n\t}\n\n\tif !reflect.DeepEqual(want, projectAccessToken) {\n\t\tt.Errorf(\"ProjectAccessTokens.GetProjectAccessToken returned %+v, want %+v\", projectAccessToken, want)\n\t}\n}\n\nfunc TestCreateProjectAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_tokens\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_project_access_token.json\")\n\t})\n\n\tprojectAccessToken, _, err := client.ProjectAccessTokens.CreateProjectAccessToken(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.CreateProjectAccessToken returned error: %v\", err)\n\t}\n\n\ttime1, err := time.Parse(time.RFC3339, \"2021-03-09T21:11:47.271Z\")\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.CreateProjectAccessToken returned error: %v\", err)\n\t}\n\twant := &ProjectAccessToken{\n\t\tID:          1876,\n\t\tUserID:      2453,\n\t\tName:        \"token 10\",\n\t\tScopes:      []string{\"api\", \"read_api\", \"read_repository\", \"write_repository\"},\n\t\tExpiresAt:   nil,\n\t\tCreatedAt:   &time1,\n\t\tActive:      true,\n\t\tRevoked:     false,\n\t\tToken:       \"2UsevZE1x1ZdFZW4MNzH\",\n\t\tAccessLevel: AccessLevelValue(40),\n\t}\n\n\tif !reflect.DeepEqual(want, projectAccessToken) {\n\t\tt.Errorf(\"ProjectAccessTokens.CreateProjectAccessToken returned %+v, want %+v\", projectAccessToken, want)\n\t}\n}\n\nfunc TestRotateProjectAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/projects/1/access_tokens/42/rotate\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/rotate_project_access_token.json\")\n\t})\n\n\tcreatedAt, _ := time.Parse(time.RFC3339, \"2023-08-01T15:00:00.000Z\")\n\texpiration := ISOTime(time.Date(2023, time.August, 15, 0, 0, 0, 0, time.UTC))\n\topts := &RotateProjectAccessTokenOptions{ExpiresAt: &expiration}\n\trotatedToken, _, err := client.ProjectAccessTokens.RotateProjectAccessToken(1, 42, opts)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.RotateProjectAccessToken returned error: %v\", err)\n\t}\n\n\twant := &ProjectAccessToken{\n\t\tID:          42,\n\t\tUserID:      1337,\n\t\tName:        \"Rotated Token\",\n\t\tScopes:      []string{\"api\"},\n\t\tExpiresAt:   &expiration,\n\t\tCreatedAt:   &createdAt,\n\t\tActive:      true,\n\t\tRevoked:     false,\n\t\tAccessLevel: AccessLevelValue(30),\n\t\tToken:       \"s3cr3t\",\n\t}\n\n\tif !reflect.DeepEqual(want, rotatedToken) {\n\t\tt.Errorf(\"ProjectAccessTokens.RotateProjectAccessTokens returned %+v, want %+v\", rotatedToken, want)\n\t}\n}\n\nfunc TestRevokeProjectAccessToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/access_tokens/1234\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.ProjectAccessTokens.RevokeProjectAccessToken(\"1\", 1234)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectAccessTokens.RevokeProjectAccessToken returned error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "project_badges.go",
          "type": "blob",
          "size": 7.037109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ProjectBadge represents a project badge.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#list-all-badges-of-a-project\ntype ProjectBadge struct {\n\tID               int    `json:\"id\"`\n\tName             string `json:\"name\"`\n\tLinkURL          string `json:\"link_url\"`\n\tImageURL         string `json:\"image_url\"`\n\tRenderedLinkURL  string `json:\"rendered_link_url\"`\n\tRenderedImageURL string `json:\"rendered_image_url\"`\n\t// Kind represents a project badge kind. Can be empty, when used PreviewProjectBadge().\n\tKind string `json:\"kind\"`\n}\n\n// ProjectBadgesService handles communication with the project badges\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_badges.html\ntype ProjectBadgesService struct {\n\tclient *Client\n}\n\n// ListProjectBadgesOptions represents the available ListProjectBadges()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#list-all-badges-of-a-project\ntype ListProjectBadgesOptions struct {\n\tListOptions\n\tName *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// ListProjectBadges gets a list of a project's badges and its group badges.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#list-all-badges-of-a-project\nfunc (s *ProjectBadgesService) ListProjectBadges(pid interface{}, opt *ListProjectBadgesOptions, options ...RequestOptionFunc) ([]*ProjectBadge, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/badges\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pb []*ProjectBadge\n\tresp, err := s.client.Do(req, &pb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pb, resp, nil\n}\n\n// GetProjectBadge gets a project badge.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#get-a-badge-of-a-project\nfunc (s *ProjectBadgesService) GetProjectBadge(pid interface{}, badge int, options ...RequestOptionFunc) (*ProjectBadge, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/badges/%d\", PathEscape(project), badge)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpb := new(ProjectBadge)\n\tresp, err := s.client.Do(req, pb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pb, resp, nil\n}\n\n// AddProjectBadgeOptions represents the available AddProjectBadge() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#add-a-badge-to-a-project\ntype AddProjectBadgeOptions struct {\n\tLinkURL  *string `url:\"link_url,omitempty\" json:\"link_url,omitempty\"`\n\tImageURL *string `url:\"image_url,omitempty\" json:\"image_url,omitempty\"`\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// AddProjectBadge adds a badge to a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#add-a-badge-to-a-project\nfunc (s *ProjectBadgesService) AddProjectBadge(pid interface{}, opt *AddProjectBadgeOptions, options ...RequestOptionFunc) (*ProjectBadge, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/badges\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpb := new(ProjectBadge)\n\tresp, err := s.client.Do(req, pb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pb, resp, nil\n}\n\n// EditProjectBadgeOptions represents the available EditProjectBadge() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#edit-a-badge-of-a-project\ntype EditProjectBadgeOptions struct {\n\tLinkURL  *string `url:\"link_url,omitempty\" json:\"link_url,omitempty\"`\n\tImageURL *string `url:\"image_url,omitempty\" json:\"image_url,omitempty\"`\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n}\n\n// EditProjectBadge updates a badge of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#edit-a-badge-of-a-project\nfunc (s *ProjectBadgesService) EditProjectBadge(pid interface{}, badge int, opt *EditProjectBadgeOptions, options ...RequestOptionFunc) (*ProjectBadge, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/badges/%d\", PathEscape(project), badge)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpb := new(ProjectBadge)\n\tresp, err := s.client.Do(req, pb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pb, resp, nil\n}\n\n// DeleteProjectBadge removes a badge from a project. Only project's\n// badges will be removed by using this endpoint.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#remove-a-badge-from-a-project\nfunc (s *ProjectBadgesService) DeleteProjectBadge(pid interface{}, badge int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/badges/%d\", PathEscape(project), badge)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ProjectBadgePreviewOptions represents the available PreviewProjectBadge() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#preview-a-badge-from-a-project\ntype ProjectBadgePreviewOptions struct {\n\tLinkURL  *string `url:\"link_url,omitempty\" json:\"link_url,omitempty\"`\n\tImageURL *string `url:\"image_url,omitempty\" json:\"image_url,omitempty\"`\n}\n\n// PreviewProjectBadge returns how the link_url and image_url final URLs would be after\n// resolving the placeholder interpolation.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_badges.html#preview-a-badge-from-a-project\nfunc (s *ProjectBadgesService) PreviewProjectBadge(pid interface{}, opt *ProjectBadgePreviewOptions, options ...RequestOptionFunc) (*ProjectBadge, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/badges/render\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpb := new(ProjectBadge)\n\tresp, err := s.client.Do(req, &pb)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pb, resp, nil\n}\n"
        },
        {
          "name": "project_badges_test.go",
          "type": "blob",
          "size": 9.35546875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectBadgesService_ListProjectBadges(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/badges\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"name\": \"Coverage\",\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"link_url\": \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\t\t\t\"image_url\": \"https://shields.io/my/badge\",\n\t\t\t\t\"rendered_link_url\": \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\t\t\t\"rendered_image_url\": \"https://shields.io/my/badge\",\n\t\t\t\t\"kind\": \"project\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectBadge{{\n\t\tID:               1,\n\t\tName:             \"Coverage\",\n\t\tLinkURL:          \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\tImageURL:         \"https://shields.io/my/badge\",\n\t\tRenderedLinkURL:  \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\tRenderedImageURL: \"https://shields.io/my/badge\",\n\t\tKind:             \"project\",\n\t}}\n\n\tpbs, resp, err := client.ProjectBadges.ListProjectBadges(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pbs)\n\n\tpbs, resp, err = client.ProjectBadges.ListProjectBadges(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pbs)\n\n\tpbs, resp, err = client.ProjectBadges.ListProjectBadges(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pbs)\n\n\tpbs, resp, err = client.ProjectBadges.ListProjectBadges(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pbs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectBadgesService_GetProjectBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/badges/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"name\": \"Coverage\",\n\t\t\t\"id\": 1,\n\t\t\t\"link_url\": \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\t\t\"image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"rendered_link_url\": \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\t\t\"rendered_image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"kind\": \"project\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &ProjectBadge{\n\t\tID:               1,\n\t\tName:             \"Coverage\",\n\t\tLinkURL:          \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\tImageURL:         \"https://shields.io/my/badge\",\n\t\tRenderedLinkURL:  \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\tRenderedImageURL: \"https://shields.io/my/badge\",\n\t\tKind:             \"project\",\n\t}\n\n\tpb, resp, err := client.ProjectBadges.GetProjectBadge(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pb)\n\n\tpb, resp, err = client.ProjectBadges.GetProjectBadge(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.GetProjectBadge(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.GetProjectBadge(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pb)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectBadgesService_AddProjectBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/badges\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"name\": \"mybadge\",\n\t\t\t\"id\": 1,\n\t\t\t\"link_url\": \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\t\t\"image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"rendered_link_url\": \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\t\t\"rendered_image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"kind\": \"project\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &ProjectBadge{\n\t\tID:               1,\n\t\tName:             \"mybadge\",\n\t\tLinkURL:          \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\tImageURL:         \"https://shields.io/my/badge\",\n\t\tRenderedLinkURL:  \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\tRenderedImageURL: \"https://shields.io/my/badge\",\n\t\tKind:             \"project\",\n\t}\n\n\tpb, resp, err := client.ProjectBadges.AddProjectBadge(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pb)\n\n\tpb, resp, err = client.ProjectBadges.AddProjectBadge(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.AddProjectBadge(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.AddProjectBadge(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pb)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectBadgesService_EditProjectBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/badges/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"name\": \"mybadge\",\n\t\t\t\"id\": 1,\n\t\t\t\"link_url\": \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\t\t\"image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"rendered_link_url\": \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\t\t\"rendered_image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"kind\": \"project\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &ProjectBadge{\n\t\tID:               1,\n\t\tName:             \"mybadge\",\n\t\tLinkURL:          \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\tImageURL:         \"https://shields.io/my/badge\",\n\t\tRenderedLinkURL:  \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\tRenderedImageURL: \"https://shields.io/my/badge\",\n\t\tKind:             \"project\",\n\t}\n\n\tpb, resp, err := client.ProjectBadges.EditProjectBadge(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pb)\n\n\tpb, resp, err = client.ProjectBadges.EditProjectBadge(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.EditProjectBadge(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.EditProjectBadge(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pb)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectBadgesService_DeleteProjectBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/badges/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.ProjectBadges.DeleteProjectBadge(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.ProjectBadges.DeleteProjectBadge(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectBadges.DeleteProjectBadge(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectBadges.DeleteProjectBadge(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectBadgesService_PreviewProjectBadge(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/badges/render\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t  {\n\t\t\t\"link_url\": \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\t\t\"image_url\": \"https://shields.io/my/badge\",\n\t\t\t\"rendered_link_url\": \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\t\t\"rendered_image_url\": \"https://shields.io/my/badge\"\n\t\t  }\n\t\t`)\n\t})\n\n\twant := &ProjectBadge{\n\t\tLinkURL:          \"http://example.com/ci_status.svg?project={project_path}&ref={default_branch}\",\n\t\tImageURL:         \"https://shields.io/my/badge\",\n\t\tRenderedLinkURL:  \"http://example.com/ci_status.svg?project=example-org/example-project&ref=master\",\n\t\tRenderedImageURL: \"https://shields.io/my/badge\",\n\t}\n\n\tpb, resp, err := client.ProjectBadges.PreviewProjectBadge(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pb)\n\n\tpb, resp, err = client.ProjectBadges.PreviewProjectBadge(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.PreviewProjectBadge(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pb)\n\n\tpb, resp, err = client.ProjectBadges.PreviewProjectBadge(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pb)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_clusters.go",
          "type": "blob",
          "size": 8.580078125,
          "content": "//\n// Copyright 2021, Matej Velikonja\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectClustersService handles communication with the\n// project clusters related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html\ntype ProjectClustersService struct {\n\tclient *Client\n}\n\n// ProjectCluster represents a GitLab Project Cluster.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_clusters.html\ntype ProjectCluster struct {\n\tID                 int                 `json:\"id\"`\n\tName               string              `json:\"name\"`\n\tDomain             string              `json:\"domain\"`\n\tCreatedAt          *time.Time          `json:\"created_at\"`\n\tProviderType       string              `json:\"provider_type\"`\n\tPlatformType       string              `json:\"platform_type\"`\n\tEnvironmentScope   string              `json:\"environment_scope\"`\n\tClusterType        string              `json:\"cluster_type\"`\n\tUser               *User               `json:\"user\"`\n\tPlatformKubernetes *PlatformKubernetes `json:\"platform_kubernetes\"`\n\tManagementProject  *ManagementProject  `json:\"management_project\"`\n\tProject            *Project            `json:\"project\"`\n}\n\nfunc (v ProjectCluster) String() string {\n\treturn Stringify(v)\n}\n\n// PlatformKubernetes represents a GitLab Project Cluster PlatformKubernetes.\ntype PlatformKubernetes struct {\n\tAPIURL            string `json:\"api_url\"`\n\tToken             string `json:\"token\"`\n\tCaCert            string `json:\"ca_cert\"`\n\tNamespace         string `json:\"namespace\"`\n\tAuthorizationType string `json:\"authorization_type\"`\n}\n\n// ManagementProject represents a GitLab Project Cluster management_project.\ntype ManagementProject struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n}\n\n// ListClusters gets a list of all clusters in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#list-project-clusters\nfunc (s *ProjectClustersService) ListClusters(pid interface{}, options ...RequestOptionFunc) ([]*ProjectCluster, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/clusters\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pcs []*ProjectCluster\n\tresp, err := s.client.Do(req, &pcs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pcs, resp, nil\n}\n\n// GetCluster gets a cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#get-a-single-project-cluster\nfunc (s *ProjectClustersService) GetCluster(pid interface{}, cluster int, options ...RequestOptionFunc) (*ProjectCluster, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/clusters/%d\", PathEscape(project), cluster)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpc := new(ProjectCluster)\n\tresp, err := s.client.Do(req, &pc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pc, resp, nil\n}\n\n// AddClusterOptions represents the available AddCluster() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#add-existing-cluster-to-project\ntype AddClusterOptions struct {\n\tName                *string                       `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDomain              *string                       `url:\"domain,omitempty\" json:\"domain,omitempty\"`\n\tEnabled             *bool                         `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\tManaged             *bool                         `url:\"managed,omitempty\" json:\"managed,omitempty\"`\n\tEnvironmentScope    *string                       `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tPlatformKubernetes  *AddPlatformKubernetesOptions `url:\"platform_kubernetes_attributes,omitempty\" json:\"platform_kubernetes_attributes,omitempty\"`\n\tManagementProjectID *string                       `url:\"management_project_id,omitempty\" json:\"management_project_id,omitempty\"`\n}\n\n// AddPlatformKubernetesOptions represents the available PlatformKubernetes options for adding.\ntype AddPlatformKubernetesOptions struct {\n\tAPIURL            *string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tToken             *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tCaCert            *string `url:\"ca_cert,omitempty\" json:\"ca_cert,omitempty\"`\n\tNamespace         *string `url:\"namespace,omitempty\" json:\"namespace,omitempty\"`\n\tAuthorizationType *string `url:\"authorization_type,omitempty\" json:\"authorization_type,omitempty\"`\n}\n\n// AddCluster adds an existing cluster to the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#add-existing-cluster-to-project\nfunc (s *ProjectClustersService) AddCluster(pid interface{}, opt *AddClusterOptions, options ...RequestOptionFunc) (*ProjectCluster, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/clusters/user\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpc := new(ProjectCluster)\n\tresp, err := s.client.Do(req, pc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pc, resp, nil\n}\n\n// EditClusterOptions represents the available EditCluster() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#edit-project-cluster\ntype EditClusterOptions struct {\n\tName                *string                        `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDomain              *string                        `url:\"domain,omitempty\" json:\"domain,omitempty\"`\n\tEnvironmentScope    *string                        `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tManagementProjectID *string                        `url:\"management_project_id,omitempty\" json:\"management_project_id,omitempty\"`\n\tPlatformKubernetes  *EditPlatformKubernetesOptions `url:\"platform_kubernetes_attributes,omitempty\" json:\"platform_kubernetes_attributes,omitempty\"`\n}\n\n// EditPlatformKubernetesOptions represents the available PlatformKubernetes options for editing.\ntype EditPlatformKubernetesOptions struct {\n\tAPIURL    *string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tToken     *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tCaCert    *string `url:\"ca_cert,omitempty\" json:\"ca_cert,omitempty\"`\n\tNamespace *string `url:\"namespace,omitempty\" json:\"namespace,omitempty\"`\n}\n\n// EditCluster updates an existing project cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#edit-project-cluster\nfunc (s *ProjectClustersService) EditCluster(pid interface{}, cluster int, opt *EditClusterOptions, options ...RequestOptionFunc) (*ProjectCluster, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/clusters/%d\", PathEscape(project), cluster)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpc := new(ProjectCluster)\n\tresp, err := s.client.Do(req, pc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pc, resp, nil\n}\n\n// DeleteCluster deletes an existing project cluster.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_clusters.html#delete-project-cluster\nfunc (s *ProjectClustersService) DeleteCluster(pid interface{}, cluster int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/clusters/%d\", PathEscape(project), cluster)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_clusters_test.go",
          "type": "blob",
          "size": 9.318359375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n)\n\nfunc TestListClusters(t *testing.T) {\n\tmux, client := setup(t)\n\tpid := 1234\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/clusters\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tresponse := `[\n  {\n    \"id\":18,\n    \"name\":\"cluster-1\",\n    \"domain\":\"example.com\",\n    \"created_at\":\"2019-01-02T20:18:12.563Z\",\n    \"provider_type\":\"user\",\n    \"platform_type\":\"kubernetes\",\n    \"environment_scope\":\"*\",\n    \"cluster_type\":\"project_type\",\n    \"user\":\n    {\n      \"id\":1,\n      \"name\":\"Administrator\",\n      \"username\":\"root\",\n      \"state\":\"active\",\n      \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n      \"web_url\":\"https://gitlab.example.com/root\"\n    },\n    \"platform_kubernetes\":\n    {\n      \"api_url\":\"https://104.197.68.152\",\n      \"namespace\":\"cluster-1-namespace\",\n      \"authorization_type\":\"rbac\",\n      \"ca_cert\":\"-----BEGIN CERTIFICATE-----\\r\\nhFiK1L61owwDQYJKoZIhvcNAQELBQAw\\r\\nLzEtMCsGA1UEAxMkZDA1YzQ1YjctNzdiMS00NDY0LThjNmEtMTQ0ZDJkZjM4ZDBj\\r\\nMB4XDTE4MTIyNzIwMDM1MVoXDTIzMTIyNjIxMDM1MVowLzEtMCsGA1UEAxMkZDA1\\r\\nYzQ1YjctNzdiMS00NDY0LThjNmEtMTQ0ZDJkZjM.......-----END CERTIFICATE-----\"\n    }\n  }\n]`\n\t\tfmt.Fprint(w, response)\n\t})\n\n\tclusters, _, err := client.ProjectCluster.ListClusters(pid)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectClusters.ListClusters returned error: %v\", err)\n\t}\n\n\tif len(clusters) != 1 {\n\t\tt.Errorf(\"expected 1 cluster; got %d\", len(clusters))\n\t}\n\n\tif clusters[0].ID != 18 {\n\t\tt.Errorf(\"expected clusterID 1; got %d\", clusters[0].ID)\n\t}\n\n\tif clusters[0].Domain != \"example.com\" {\n\t\tt.Errorf(\"expected cluster domain example.com; got %q\", clusters[0].Domain)\n\t}\n}\n\nfunc TestGetCluster(t *testing.T) {\n\tmux, client := setup(t)\n\tpid := 1234\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/clusters/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tresponse := `{\n  \"id\":18,\n  \"name\":\"cluster-1\",\n  \"domain\":\"example.com\",\n  \"created_at\":\"2019-01-02T20:18:12.563Z\",\n  \"provider_type\":\"user\",\n  \"platform_type\":\"kubernetes\",\n  \"environment_scope\":\"*\",\n  \"cluster_type\":\"project_type\",\n  \"user\":\n  {\n    \"id\":1,\n    \"name\":\"Administrator\",\n    \"username\":\"root\",\n    \"state\":\"active\",\n    \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n    \"web_url\":\"https://gitlab.example.com/root\"\n  },\n  \"platform_kubernetes\":\n  {\n    \"api_url\":\"https://104.197.68.152\",\n    \"namespace\":\"cluster-1-namespace\",\n    \"authorization_type\":\"rbac\",\n    \"ca_cert\":\"-----BEGIN CERTIFICATE-----\\r\\nhFiK1L61owwDQYJKoZIhvcNAQELBQAw\\r\\nLzEtMCsGA1UEAxMkZDA1YzQ1YjctNzdiMS00NDY0LThjNmEtMTQ0ZDJkZjM4ZDBj\\r\\nMB4XDTE4MTIyNzIwMDM1MVoXDTIzMTIyNjIxMDM1MVowLzEtMCsGA1UEAxMkZDA1\\r\\nYzQ1YjctNzdiMS00NDY0LThjNmEtMTQ0ZDJkZjM.......-----END CERTIFICATE-----\"\n  },\n  \"project\":\n  {\n    \"id\":26,\n    \"description\":\"\",\n    \"name\":\"project-with-clusters-api\",\n    \"name_with_namespace\":\"Administrator / project-with-clusters-api\",\n    \"path\":\"project-with-clusters-api\",\n    \"path_with_namespace\":\"root/project-with-clusters-api\",\n    \"created_at\":\"2019-01-02T20:13:32.600Z\",\n    \"default_branch\":null,\n    \"tag_list\":[],\n    \"ssh_url_to_repo\":\"ssh://gitlab.example.com/root/project-with-clusters-api.git\",\n    \"http_url_to_repo\":\"https://gitlab.example.com/root/project-with-clusters-api.git\",\n    \"web_url\":\"https://gitlab.example.com/root/project-with-clusters-api\",\n    \"readme_url\":null,\n    \"avatar_url\":null,\n    \"star_count\":0,\n    \"forks_count\":0,\n    \"last_activity_at\":\"2019-01-02T20:13:32.600Z\",\n    \"namespace\":\n    {\n      \"id\":1,\n      \"name\":\"root\",\n      \"path\":\"root\",\n      \"kind\":\"user\",\n      \"full_path\":\"root\",\n      \"parent_id\":null\n    }\n  }\n}`\n\t\tfmt.Fprint(w, response)\n\t})\n\n\tcluster, _, err := client.ProjectCluster.GetCluster(pid, 1)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectClusters.ListClusters returned error: %v\", err)\n\t}\n\n\tif cluster.ID != 18 {\n\t\tt.Errorf(\"expected clusterID 18; got %d\", cluster.ID)\n\t}\n\n\tif cluster.Domain != \"example.com\" {\n\t\tt.Errorf(\"expected cluster domain example.com; got %q\", cluster.Domain)\n\t}\n}\n\nfunc TestAddCluster(t *testing.T) {\n\tmux, client := setup(t)\n\tpid := 1234\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/clusters/user\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tresponse := `{\n  \"id\":24,\n  \"name\":\"cluster-5\",\n  \"domain\":\"example.com\",\n  \"created_at\":\"2019-01-03T21:53:40.610Z\",\n  \"provider_type\":\"user\",\n  \"platform_type\":\"kubernetes\",\n  \"environment_scope\":\"*\",\n  \"cluster_type\":\"project_type\",\n  \"user\":\n  {\n    \"id\":1,\n    \"name\":\"Administrator\",\n    \"username\":\"root\",\n    \"state\":\"active\",\n    \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n    \"web_url\":\"https://gitlab.example.com/root\"\n  },\n  \"platform_kubernetes\":\n  {\n    \"api_url\":\"https://35.111.51.20\",\n    \"namespace\":\"cluster-5-namespace\",\n    \"authorization_type\":\"rbac\",\n    \"ca_cert\":\"-----BEGIN CERTIFICATE-----\\r\\nhFiK1L61owwDQYJKoZIhvcNAQELBQAw\\r\\nLzEtMCsGA1UEAxMkZDA1YzQ1YjctNzdiMS00NDY0LThjNmEtMTQ0ZDJkZjM4ZDBj\\r\\nMB4XDTE4MTIyNzIwMDM1MVoXDTIzMTIyNjIxMDM1MVowLzEtMCsGA1UEAxMkZDA1\\r\\nYzQ1YjctNzdiMS00NDY0LThjNmEtMTQ0ZDJkZjM.......-----END CERTIFICATE-----\"\n  },\n  \"project\":\n  {\n    \"id\":26,\n    \"description\":\"\",\n    \"name\":\"project-with-clusters-api\",\n    \"name_with_namespace\":\"Administrator / project-with-clusters-api\",\n    \"path\":\"project-with-clusters-api\",\n    \"path_with_namespace\":\"root/project-with-clusters-api\",\n    \"created_at\":\"2019-01-02T20:13:32.600Z\",\n    \"default_branch\":null,\n    \"tag_list\":[],\n    \"ssh_url_to_repo\":\"ssh:://gitlab.example.com/root/project-with-clusters-api.git\",\n    \"http_url_to_repo\":\"https://gitlab.example.com/root/project-with-clusters-api.git\",\n    \"web_url\":\"https://gitlab.example.com/root/project-with-clusters-api\",\n    \"readme_url\":null,\n    \"avatar_url\":null,\n    \"star_count\":0,\n    \"forks_count\":0,\n    \"last_activity_at\":\"2019-01-02T20:13:32.600Z\",\n    \"namespace\":\n    {\n      \"id\":1,\n      \"name\":\"root\",\n      \"path\":\"root\",\n      \"kind\":\"user\",\n      \"full_path\":\"root\",\n      \"parent_id\":null\n    }\n  }\n}`\n\t\tfmt.Fprint(w, response)\n\t})\n\n\tcluster, _, err := client.ProjectCluster.AddCluster(pid, &AddClusterOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ProjectClusters.AddCluster returned error: %v\", err)\n\t}\n\n\tif cluster.ID != 24 {\n\t\tt.Errorf(\"expected ClusterID 24; got %d\", cluster.ID)\n\t}\n}\n\nfunc TestEditCluster(t *testing.T) {\n\tmux, client := setup(t)\n\tpid := 1234\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/clusters/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tresponse := `{\n  \"id\":24,\n  \"name\":\"new-cluster-name\",\n  \"domain\":\"example.com\",\n  \"created_at\":\"2019-01-03T21:53:40.610Z\",\n  \"provider_type\":\"user\",\n  \"platform_type\":\"kubernetes\",\n  \"environment_scope\":\"*\",\n  \"cluster_type\":\"project_type\",\n  \"user\":\n  {\n    \"id\":1,\n    \"name\":\"Administrator\",\n    \"username\":\"root\",\n    \"state\":\"active\",\n    \"avatar_url\":\"https://www.gravatar.com/avatar/4249f4df72b..\",\n    \"web_url\":\"https://gitlab.example.com/root\"\n  },\n  \"platform_kubernetes\":\n  {\n    \"api_url\":\"https://new-api-url.com\",\n    \"namespace\":\"cluster-5-namespace\",\n    \"authorization_type\":\"rbac\",\n    \"ca_cert\":null\n  },\n  \"project\":\n  {\n    \"id\":26,\n    \"description\":\"\",\n    \"name\":\"project-with-clusters-api\",\n    \"name_with_namespace\":\"Administrator / project-with-clusters-api\",\n    \"path\":\"project-with-clusters-api\",\n    \"path_with_namespace\":\"root/project-with-clusters-api\",\n    \"created_at\":\"2019-01-02T20:13:32.600Z\",\n    \"default_branch\":null,\n    \"tag_list\":[],\n    \"ssh_url_to_repo\":\"ssh:://gitlab.example.com/root/project-with-clusters-api.git\",\n    \"http_url_to_repo\":\"https://gitlab.example.com/root/project-with-clusters-api.git\",\n    \"web_url\":\"https://gitlab.example.com/root/project-with-clusters-api\",\n    \"readme_url\":null,\n    \"avatar_url\":null,\n    \"star_count\":0,\n    \"forks_count\":0,\n    \"last_activity_at\":\"2019-01-02T20:13:32.600Z\",\n    \"namespace\":\n    {\n      \"id\":1,\n      \"name\":\"root\",\n      \"path\":\"root\",\n      \"kind\":\"user\",\n      \"full_path\":\"root\",\n      \"parent_id\":null\n    }\n  }\n}`\n\t\tfmt.Fprint(w, response)\n\t})\n\n\tcluster, _, err := client.ProjectCluster.EditCluster(pid, 1, &EditClusterOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ProjectClusters.EditCluster returned error: %v\", err)\n\t}\n\n\tif cluster.ID != 24 {\n\t\tt.Errorf(\"expected ClusterID 24; got %d\", cluster.ID)\n\t}\n}\n\nfunc TestDeleteCluster(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1234/clusters/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.ProjectCluster.DeleteCluster(1234, 1)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectCluster.DeleteCluster returned error: %v\", err)\n\t}\n\n\twant := http.StatusAccepted\n\tgot := resp.StatusCode\n\tif got != want {\n\t\tt.Errorf(\"ProjectCluster.DeleteCluster returned %d, want %d\", got, want)\n\t}\n}\n"
        },
        {
          "name": "project_feature_flags.go",
          "type": "blob",
          "size": 8.4375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectFeatureFlagService handles operations on gitlab project feature\n// flags using the following api:\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/feature_flags.html\ntype ProjectFeatureFlagService struct {\n\tclient *Client\n}\n\n// ProjectFeatureFlag represents a GitLab project iteration.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/feature_flags.html\ntype ProjectFeatureFlag struct {\n\tName        string                        `json:\"name\"`\n\tDescription string                        `json:\"description\"`\n\tActive      bool                          `json:\"active\"`\n\tVersion     string                        `json:\"version\"`\n\tCreatedAt   *time.Time                    `json:\"created_at\"`\n\tUpdatedAt   *time.Time                    `json:\"updated_at\"`\n\tScopes      []*ProjectFeatureFlagScope    `json:\"scopes\"`\n\tStrategies  []*ProjectFeatureFlagStrategy `json:\"strategies\"`\n}\n\n// ProjectFeatureFlagScope defines the scopes of a feature flag\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/feature_flags.html\ntype ProjectFeatureFlagScope struct {\n\tID               int    `json:\"id\"`\n\tEnvironmentScope string `json:\"environment_scope\"`\n}\n\n// ProjectFeatureFlagStrategy defines the strategy used for a feature flag\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/feature_flags.html\ntype ProjectFeatureFlagStrategy struct {\n\tID         int                                  `json:\"id\"`\n\tName       string                               `json:\"name\"`\n\tParameters *ProjectFeatureFlagStrategyParameter `json:\"parameters\"`\n\tScopes     []*ProjectFeatureFlagScope           `json:\"scopes\"`\n}\n\n// ProjectFeatureFlagStrategyParameter is used in updating and creating feature flags\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/feature_flags.html\ntype ProjectFeatureFlagStrategyParameter struct {\n\tGroupID    string `json:\"groupId,omitempty\"`\n\tUserIDs    string `json:\"userIds,omitempty\"`\n\tPercentage string `json:\"percentage,omitempty\"`\n\n\t// Following fields aren't documented in Gitlab API docs,\n\t// but are present in Gitlab API since 13.5.\n\t// Docs: https://docs.getunleash.io/reference/activation-strategies#gradual-rollout\n\tRollout    string `json:\"rollout,omitempty\"`\n\tStickiness string `json:\"stickiness,omitempty\"`\n}\n\nfunc (i ProjectFeatureFlag) String() string {\n\treturn Stringify(i)\n}\n\n// ListProjectFeatureFlagOptions contains the options for ListProjectFeatureFlags\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#list-feature-flags-for-a-project\ntype ListProjectFeatureFlagOptions struct {\n\tListOptions\n\tScope *string `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n}\n\n// ListProjectFeatureFlags returns a list with the feature flags of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#list-feature-flags-for-a-project\nfunc (s *ProjectFeatureFlagService) ListProjectFeatureFlags(pid interface{}, opt *ListProjectFeatureFlagOptions, options ...RequestOptionFunc) ([]*ProjectFeatureFlag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/feature_flags\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pffs []*ProjectFeatureFlag\n\tresp, err := s.client.Do(req, &pffs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pffs, resp, nil\n}\n\n// GetProjectFeatureFlag gets a single feature flag for the specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#get-a-single-feature-flag\nfunc (s *ProjectFeatureFlagService) GetProjectFeatureFlag(pid interface{}, name string, options ...RequestOptionFunc) (*ProjectFeatureFlag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/feature_flags/%s\", PathEscape(project), name)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tflag := new(ProjectFeatureFlag)\n\tresp, err := s.client.Do(req, flag)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn flag, resp, nil\n}\n\n// CreateProjectFeatureFlagOptions represents the available\n// CreateProjectFeatureFlag() options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#create-a-feature-flag\ntype CreateProjectFeatureFlagOptions struct {\n\tName        *string                        `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription *string                        `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tVersion     *string                        `url:\"version,omitempty\" json:\"version,omitempty\"`\n\tActive      *bool                          `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tStrategies  *[]*FeatureFlagStrategyOptions `url:\"strategies,omitempty\" json:\"strategies,omitempty\"`\n}\n\n// FeatureFlagStrategyOptions represents the available feature flag strategy\n// options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#create-a-feature-flag\ntype FeatureFlagStrategyOptions struct {\n\tID         *int                                 `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tName       *string                              `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tParameters *ProjectFeatureFlagStrategyParameter `url:\"parameters,omitempty\" json:\"parameters,omitempty\"`\n\tScopes     *[]*ProjectFeatureFlagScope          `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n}\n\n// ProjectFeatureFlagScopeOptions represents the available feature flag scope\n// options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#create-a-feature-flag\ntype ProjectFeatureFlagScopeOptions struct {\n\tID               *int    `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tEnvironmentScope *string `url:\"id,omitempty\" json:\"environment_scope,omitempty\"`\n}\n\n// CreateProjectFeatureFlag creates a feature flag\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#create-a-feature-flag\nfunc (s *ProjectFeatureFlagService) CreateProjectFeatureFlag(pid interface{}, opt *CreateProjectFeatureFlagOptions, options ...RequestOptionFunc) (*ProjectFeatureFlag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/feature_flags\",\n\t\tPathEscape(project),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tflag := new(ProjectFeatureFlag)\n\tresp, err := s.client.Do(req, flag)\n\tif err != nil {\n\t\treturn flag, resp, err\n\t}\n\n\treturn flag, resp, nil\n}\n\n// UpdateProjectFeatureFlagOptions represents the available\n// UpdateProjectFeatureFlag() options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#update-a-feature-flag\ntype UpdateProjectFeatureFlagOptions struct {\n\tName        *string                        `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription *string                        `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tActive      *bool                          `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tStrategies  *[]*FeatureFlagStrategyOptions `url:\"strategies,omitempty\" json:\"strategies,omitempty\"`\n}\n\n// UpdateProjectFeatureFlag updates a feature flag\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#update-a-feature-flag\nfunc (s *ProjectFeatureFlagService) UpdateProjectFeatureFlag(pid interface{}, name string, opt *UpdateProjectFeatureFlagOptions, options ...RequestOptionFunc) (*ProjectFeatureFlag, *Response, error) {\n\tgroup, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/feature_flags/%s\",\n\t\tPathEscape(group),\n\t\tname,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tflag := new(ProjectFeatureFlag)\n\tresp, err := s.client.Do(req, flag)\n\tif err != nil {\n\t\treturn flag, resp, err\n\t}\n\n\treturn flag, resp, nil\n}\n\n// DeleteProjectFeatureFlag deletes a feature flag\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/feature_flags.html#delete-a-feature-flag\nfunc (s *ProjectFeatureFlagService) DeleteProjectFeatureFlag(pid interface{}, name string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/feature_flags/%s\", PathEscape(project), name)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_feature_flags_test.go",
          "type": "blob",
          "size": 6.5244140625,
          "content": "package gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListProjectFeatureFlags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/333/feature_flags\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tmustWriteHTTPResponse(t, w, \"testdata/list_project_feature_flags.json\")\n\t\t})\n\n\tactual, _, err := client.ProjectFeatureFlags.ListProjectFeatureFlags(333, &ListProjectFeatureFlagOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ProjectFeatureFlags.ListProjectFeatureFlags returned error: %v\", err)\n\t\treturn\n\t}\n\n\tcreatedAt1 := time.Date(2019, 11, 4, 8, 13, 51, 0, time.UTC)\n\tupdatedAt1 := time.Date(2019, 11, 4, 8, 13, 11, 0, time.UTC)\n\n\tcreatedAt2 := time.Date(2019, 11, 4, 8, 13, 10, 0, time.UTC)\n\tupdatedAt2 := time.Date(2019, 11, 4, 8, 13, 10, 0, time.UTC)\n\n\texpected := []*ProjectFeatureFlag{\n\t\t{\n\t\t\tName:        \"merge_train\",\n\t\t\tDescription: \"This feature is about merge train\",\n\t\t\tActive:      true,\n\t\t\tVersion:     \"new_version_flag\",\n\t\t\tCreatedAt:   &createdAt1,\n\t\t\tUpdatedAt:   &updatedAt1,\n\t\t\tScopes:      []*ProjectFeatureFlagScope{},\n\t\t\tStrategies: []*ProjectFeatureFlagStrategy{\n\t\t\t\t{\n\t\t\t\t\tID:   1,\n\t\t\t\t\tName: \"userWithId\",\n\t\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{\n\t\t\t\t\t\tUserIDs: \"user1\",\n\t\t\t\t\t},\n\t\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tID:               1,\n\t\t\t\t\t\t\tEnvironmentScope: \"production\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName:        \"new_live_trace\",\n\t\t\tDescription: \"This is a new live trace feature\",\n\t\t\tActive:      true,\n\t\t\tVersion:     \"new_version_flag\",\n\t\t\tCreatedAt:   &createdAt2,\n\t\t\tUpdatedAt:   &updatedAt2,\n\t\t\tScopes:      []*ProjectFeatureFlagScope{},\n\t\t\tStrategies: []*ProjectFeatureFlagStrategy{\n\t\t\t\t{\n\t\t\t\t\tID:         2,\n\t\t\t\t\tName:       \"default\",\n\t\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{},\n\t\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tID:               2,\n\t\t\t\t\t\t\tEnvironmentScope: \"staging\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tassert.Equal(t, len(expected), len(actual))\n\tfor i := range expected {\n\t\tassert.Equal(t, expected[i], actual[i])\n\t}\n}\n\nfunc TestGetProjectFeatureFlag(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/feature_flags/testing\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_project_feature_flag.json\")\n\t})\n\n\tactual, resp, err := client.ProjectFeatureFlags.GetProjectFeatureFlag(1, \"testing\")\n\tif err != nil {\n\t\tt.Fatalf(\"ProjectFeatureFlags.GetProjectFeatureFlag returned error: %v, response %v\", err, resp)\n\t}\n\n\tdate := time.Date(2020, 0o5, 13, 19, 56, 33, 0, time.UTC)\n\texpected := &ProjectFeatureFlag{\n\t\tName:      \"awesome_feature\",\n\t\tActive:    true,\n\t\tVersion:   \"new_version_flag\",\n\t\tCreatedAt: &date,\n\t\tUpdatedAt: &date,\n\t\tScopes:    []*ProjectFeatureFlagScope{},\n\t\tStrategies: []*ProjectFeatureFlagStrategy{\n\t\t\t{\n\t\t\t\tID:         36,\n\t\t\t\tName:       \"default\",\n\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{},\n\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:               37,\n\t\t\t\t\t\tEnvironmentScope: \"production\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:   24,\n\t\t\t\tName: \"flexibleRollout\",\n\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{\n\t\t\t\t\tGroupID:    \"default\",\n\t\t\t\t\tRollout:    \"50\",\n\t\t\t\t\tStickiness: \"default\",\n\t\t\t\t},\n\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:               52,\n\t\t\t\t\t\tEnvironmentScope: \"*\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tassert.Equal(t, expected, actual)\n}\n\nfunc TestCreateProjectFeatureFlag(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/feature_flags/testing\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_project_feature_flag.json\")\n\t})\n\n\tactual, _, err := client.ProjectFeatureFlags.UpdateProjectFeatureFlag(1, \"testing\", &UpdateProjectFeatureFlagOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ProjectFeatureFlags.UpdateProjectFeatureFlag returned error: %v\", err)\n\t\treturn\n\t}\n\n\tcreatedAt := time.Date(2020, 5, 13, 19, 56, 33, 0, time.UTC)\n\tupdatedAt := time.Date(2020, 5, 13, 19, 56, 33, 0, time.UTC)\n\n\texpected := &ProjectFeatureFlag{\n\t\tName:      \"awesome_feature\",\n\t\tActive:    true,\n\t\tVersion:   \"new_version_flag\",\n\t\tCreatedAt: &createdAt,\n\t\tUpdatedAt: &updatedAt,\n\t\tScopes:    []*ProjectFeatureFlagScope{},\n\t\tStrategies: []*ProjectFeatureFlagStrategy{\n\t\t\t{\n\t\t\t\tID:         36,\n\t\t\t\tName:       \"default\",\n\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{},\n\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:               37,\n\t\t\t\t\t\tEnvironmentScope: \"production\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tassert.Equal(t, expected, actual)\n}\n\nfunc TestUpdateProjectFeatureFlag(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/feature_flags/testing\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/update_project_feature_flag.json\")\n\t})\n\n\tactual, _, err := client.ProjectFeatureFlags.UpdateProjectFeatureFlag(1, \"testing\", &UpdateProjectFeatureFlagOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"ProjectFeatureFlags.UpdateProjectFeatureFlag returned error: %v\", err)\n\t\treturn\n\t}\n\n\tcreatedAt := time.Date(2020, 5, 13, 20, 10, 32, 0, time.UTC)\n\tupdatedAt := time.Date(2020, 5, 13, 20, 10, 32, 0, time.UTC)\n\n\texpected := &ProjectFeatureFlag{\n\t\tName:      \"awesome_feature\",\n\t\tActive:    true,\n\t\tVersion:   \"new_version_flag\",\n\t\tCreatedAt: &createdAt,\n\t\tUpdatedAt: &updatedAt,\n\t\tScopes:    []*ProjectFeatureFlagScope{},\n\t\tStrategies: []*ProjectFeatureFlagStrategy{\n\t\t\t{\n\t\t\t\tID:   38,\n\t\t\t\tName: \"gradualRolloutUserId\",\n\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{\n\t\t\t\t\tGroupID:    \"default\",\n\t\t\t\t\tPercentage: \"25\",\n\t\t\t\t},\n\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:               40,\n\t\t\t\t\t\tEnvironmentScope: \"staging\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:         37,\n\t\t\t\tName:       \"default\",\n\t\t\t\tParameters: &ProjectFeatureFlagStrategyParameter{},\n\t\t\t\tScopes: []*ProjectFeatureFlagScope{\n\t\t\t\t\t{\n\t\t\t\t\t\tID:               39,\n\t\t\t\t\t\tEnvironmentScope: \"production\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tassert.Equal(t, expected, actual)\n}\n\nfunc TestDeleteProjectFeatureFlag(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/feature_flags/testing\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.ProjectFeatureFlags.DeleteProjectFeatureFlag(1, \"testing\")\n\tif err != nil {\n\t\tt.Errorf(\"ProjectFeatureFlags.DeleteProjectFeatureFlag returned error: %v\", err)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "project_import_export.go",
          "type": "blob",
          "size": 6.7041015625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectImportExportService handles communication with the project\n// import/export related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html\ntype ProjectImportExportService struct {\n\tclient *Client\n}\n\n// ImportStatus represents a project import status.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#import-status\ntype ImportStatus struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreateAt          *time.Time `json:\"create_at\"`\n\tImportStatus      string     `json:\"import_status\"`\n\tImportType        string     `json:\"import_type\"`\n\tCorrelationID     string     `json:\"correlation_id\"`\n\tImportError       string     `json:\"import_error\"`\n}\n\nfunc (s ImportStatus) String() string {\n\treturn Stringify(s)\n}\n\n// ExportStatus represents a project export status.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#export-status\ntype ExportStatus struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n\tExportStatus      string     `json:\"export_status\"`\n\tMessage           string     `json:\"message\"`\n\tLinks             struct {\n\t\tAPIURL string `json:\"api_url\"`\n\t\tWebURL string `json:\"web_url\"`\n\t} `json:\"_links\"`\n}\n\nfunc (s ExportStatus) String() string {\n\treturn Stringify(s)\n}\n\n// ScheduleExportOptions represents the available ScheduleExport() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#schedule-an-export\ntype ScheduleExportOptions struct {\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tUpload      struct {\n\t\tURL        *string `url:\"url,omitempty\" json:\"url,omitempty\"`\n\t\tHTTPMethod *string `url:\"http_method,omitempty\" json:\"http_method,omitempty\"`\n\t} `url:\"upload,omitempty\" json:\"upload,omitempty\"`\n}\n\n// ScheduleExport schedules a project export.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#schedule-an-export\nfunc (s *ProjectImportExportService) ScheduleExport(pid interface{}, opt *ScheduleExportOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/export\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ExportStatus get the status of export.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#export-status\nfunc (s *ProjectImportExportService) ExportStatus(pid interface{}, options ...RequestOptionFunc) (*ExportStatus, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/export\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tes := new(ExportStatus)\n\tresp, err := s.client.Do(req, es)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn es, resp, nil\n}\n\n// ExportDownload download the finished export.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#export-download\nfunc (s *ProjectImportExportService) ExportDownload(pid interface{}, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/export/download\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n\n// ImportFileOptions represents the available ImportFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#import-a-file\ntype ImportFileOptions struct {\n\tNamespace      *string               `url:\"namespace,omitempty\" json:\"namespace,omitempty\"`\n\tName           *string               `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tPath           *string               `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tOverwrite      *bool                 `url:\"overwrite,omitempty\" json:\"overwrite,omitempty\"`\n\tOverrideParams *CreateProjectOptions `url:\"override_params,omitempty\" json:\"override_params,omitempty\"`\n}\n\n// Import a project from an archive file.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#import-a-file\nfunc (s *ProjectImportExportService) ImportFromFile(archive io.Reader, opt *ImportFileOptions, options ...RequestOptionFunc) (*ImportStatus, *Response, error) {\n\treq, err := s.client.UploadRequest(\n\t\thttp.MethodPost,\n\t\t\"projects/import\",\n\t\tarchive,\n\t\t\"archive.tar.gz\",\n\t\tUploadFile,\n\t\topt,\n\t\toptions,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tis := new(ImportStatus)\n\tresp, err := s.client.Do(req, is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n\n// ImportStatus get the status of an import.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_import_export.html#import-status\nfunc (s *ProjectImportExportService) ImportStatus(pid interface{}, options ...RequestOptionFunc) (*ImportStatus, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/import\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tis := new(ImportStatus)\n\tresp, err := s.client.Do(req, is)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn is, resp, nil\n}\n"
        },
        {
          "name": "project_import_export_test.go",
          "type": "blob",
          "size": 6.7890625,
          "content": "package gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectImportExportService_ScheduleExport(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/export\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tresp, err := client.ProjectImportExport.ScheduleExport(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.ProjectImportExport.ScheduleExport(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectImportExport.ScheduleExport(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectImportExport.ScheduleExport(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectImportExportService_ExportStatus(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/export\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"description\": \"Itaque perspiciatis minima aspernatur corporis consequatur.\",\n\t\t\t  \"name\": \"Gitlab Test\",\n\t\t\t  \"name_with_namespace\": \"Gitlab Org / Gitlab Test\",\n\t\t\t  \"path\": \"gitlab-test\",\n\t\t\t  \"path_with_namespace\": \"gitlab-org/gitlab-test\",\n\t\t\t  \"export_status\": \"finished\",\n\t\t\t  \"_links\": {\n\t\t\t\t\"api_url\": \"https://gitlab.example.com/api/v4/projects/1/export/download\",\n\t\t\t\t\"web_url\": \"https://gitlab.example.com/gitlab-org/gitlab-test/download_export\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ExportStatus{\n\t\tID:                1,\n\t\tDescription:       \"Itaque perspiciatis minima aspernatur corporis consequatur.\",\n\t\tName:              \"Gitlab Test\",\n\t\tNameWithNamespace: \"Gitlab Org / Gitlab Test\",\n\t\tPath:              \"gitlab-test\",\n\t\tPathWithNamespace: \"gitlab-org/gitlab-test\",\n\t\tExportStatus:      \"finished\",\n\t\tMessage:           \"\",\n\t\tLinks: struct {\n\t\t\tAPIURL string `json:\"api_url\"`\n\t\t\tWebURL string `json:\"web_url\"`\n\t\t}{\n\t\t\tAPIURL: \"https://gitlab.example.com/api/v4/projects/1/export/download\",\n\t\t\tWebURL: \"https://gitlab.example.com/gitlab-org/gitlab-test/download_export\",\n\t\t},\n\t}\n\n\tes, resp, err := client.ProjectImportExport.ExportStatus(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, es)\n\n\tes, resp, err = client.ProjectImportExport.ExportStatus(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n\n\tes, resp, err = client.ProjectImportExport.ExportStatus(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n\n\tes, resp, err = client.ProjectImportExport.ExportStatus(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, es)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectImportExportService_ExportDownload(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/export/download\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, \"file.tar.gz\")\n\t})\n\n\twant := []byte(\"file.tar.gz\")\n\n\tes, resp, err := client.ProjectImportExport.ExportDownload(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, es)\n\n\tes, resp, err = client.ProjectImportExport.ExportDownload(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n\n\tes, resp, err = client.ProjectImportExport.ExportDownload(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n\n\tes, resp, err = client.ProjectImportExport.ExportDownload(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, es)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectImportExportService_ImportFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/import\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"description\": null,\n\t\t\t  \"name\": \"api-project\",\n\t\t\t  \"name_with_namespace\": \"Administrator / api-project\",\n\t\t\t  \"path\": \"api-project\",\n\t\t\t  \"path_with_namespace\": \"root/api-project\",\n\t\t\t  \"import_status\": \"scheduled\",\n\t\t\t  \"correlation_id\": \"mezklWso3Za\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ImportStatus{\n\t\tID:                1,\n\t\tDescription:       \"\",\n\t\tName:              \"api-project\",\n\t\tNameWithNamespace: \"Administrator / api-project\",\n\t\tPath:              \"api-project\",\n\t\tPathWithNamespace: \"root/api-project\",\n\t\tImportStatus:      \"scheduled\",\n\t\tCorrelationID:     \"mezklWso3Za\",\n\t}\n\n\tfile := bytes.NewBufferString(\"dummy\")\n\tes, resp, err := client.ProjectImportExport.ImportFromFile(file, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, es)\n\n\tes, resp, err = client.ProjectImportExport.ImportFromFile(file, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n}\n\nfunc TestProjectImportExportService_ImportStatus(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/import\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"description\": \"Itaque perspiciatis minima aspernatur corporis consequatur.\",\n\t\t\t  \"name\": \"Gitlab Test\",\n\t\t\t  \"name_with_namespace\": \"Gitlab Org / Gitlab Test\",\n\t\t\t  \"path\": \"gitlab-test\",\n\t\t\t  \"path_with_namespace\": \"gitlab-org/gitlab-test\",\n\t\t\t  \"import_status\": \"started\",\n\t\t\t  \"correlation_id\": \"mezklWso3Za\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ImportStatus{\n\t\tID:                1,\n\t\tDescription:       \"Itaque perspiciatis minima aspernatur corporis consequatur.\",\n\t\tName:              \"Gitlab Test\",\n\t\tNameWithNamespace: \"Gitlab Org / Gitlab Test\",\n\t\tPath:              \"gitlab-test\",\n\t\tPathWithNamespace: \"gitlab-org/gitlab-test\",\n\t\tImportStatus:      \"started\",\n\t\tCorrelationID:     \"mezklWso3Za\",\n\t}\n\n\tes, resp, err := client.ProjectImportExport.ImportStatus(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, es)\n\n\tes, resp, err = client.ProjectImportExport.ImportStatus(1.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n\n\tes, resp, err = client.ProjectImportExport.ImportStatus(1, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, es)\n\n\tes, resp, err = client.ProjectImportExport.ImportStatus(2, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, es)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_iterations.go",
          "type": "blob",
          "size": 2.763671875,
          "content": "//\n// Copyright 2022, Daniel Steinke\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// IterationsAPI handles communication with the project iterations related\n// methods of the GitLab API\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/iterations.html\ntype ProjectIterationsService struct {\n\tclient *Client\n}\n\n// ProjectIteration represents a GitLab project iteration.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/iterations.html\ntype ProjectIteration struct {\n\tID          int        `json:\"id\"`\n\tIID         int        `json:\"iid\"`\n\tSequence    int        `json:\"sequence\"`\n\tGroupID     int        `json:\"group_id\"`\n\tTitle       string     `json:\"title\"`\n\tDescription string     `json:\"description\"`\n\tState       int        `json:\"state\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tDueDate     *ISOTime   `json:\"due_date\"`\n\tStartDate   *ISOTime   `json:\"start_date\"`\n\tWebURL      string     `json:\"web_url\"`\n}\n\nfunc (i ProjectIteration) String() string {\n\treturn Stringify(i)\n}\n\n// ListProjectIterationsOptions contains the available ListProjectIterations()\n// options\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/iterations.html#list-project-iterations\ntype ListProjectIterationsOptions struct {\n\tListOptions\n\tState            *string `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tSearch           *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tIncludeAncestors *bool   `url:\"include_ancestors,omitempty\" json:\"include_ancestors,omitempty\"`\n}\n\n// ListProjectIterations returns a list of projects iterations.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/iterations.html#list-project-iterations\nfunc (i *ProjectIterationsService) ListProjectIterations(pid interface{}, opt *ListProjectIterationsOptions, options ...RequestOptionFunc) ([]*ProjectIteration, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/iterations\", PathEscape(project))\n\n\treq, err := i.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pis []*ProjectIteration\n\tresp, err := i.client.Do(req, &pis)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pis, resp, nil\n}\n"
        },
        {
          "name": "project_iterations_test.go",
          "type": "blob",
          "size": 1.1953125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListProjectIterations(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/42/iterations\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprintf(w, `[\n        {\n          \"id\": 53,\n          \"iid\": 13,\n          \"sequence\": 1,\n          \"group_id\": 5,\n          \"title\": \"Iteration II\",\n          \"description\": \"Ipsum Lorem ipsum\",\n          \"state\": 2,\n          \"web_url\": \"http://gitlab.example.com/groups/my-group/-/iterations/13\"\n        }\n      ]`)\n\t\t})\n\n\titerations, _, err := client.ProjectIterations.ListProjectIterations(42, &ListProjectIterationsOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"GroupIterations.ListGroupIterations returned error: %v\", err)\n\t}\n\n\twant := []*ProjectIteration{{\n\t\tID:          53,\n\t\tIID:         13,\n\t\tSequence:    1,\n\t\tGroupID:     5,\n\t\tTitle:       \"Iteration II\",\n\t\tDescription: \"Ipsum Lorem ipsum\",\n\t\tState:       2,\n\t\tWebURL:      \"http://gitlab.example.com/groups/my-group/-/iterations/13\",\n\t}}\n\tif !reflect.DeepEqual(want, iterations) {\n\t\tt.Errorf(\"ProjectIterations.ListProjectIterations returned %+v, want %+v\", iterations, want)\n\t}\n}\n"
        },
        {
          "name": "project_managed_licenses.go",
          "type": "blob",
          "size": 5.625,
          "content": "//\n// Copyright 2021, Andrea Perizzato\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ManagedLicensesService handles communication with the managed licenses\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/managed_licenses.html\ntype ManagedLicensesService struct {\n\tclient *Client\n}\n\n// ManagedLicense represents a managed license.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/managed_licenses.html\ntype ManagedLicense struct {\n\tID             int                        `json:\"id\"`\n\tName           string                     `json:\"name\"`\n\tApprovalStatus LicenseApprovalStatusValue `json:\"approval_status\"`\n}\n\n// ListManagedLicenses returns a list of managed licenses from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#list-managed-licenses\nfunc (s *ManagedLicensesService) ListManagedLicenses(pid interface{}, options ...RequestOptionFunc) ([]*ManagedLicense, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/managed_licenses\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mls []*ManagedLicense\n\tresp, err := s.client.Do(req, &mls)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mls, resp, nil\n}\n\n// GetManagedLicense returns an existing managed license.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#show-an-existing-managed-license\nfunc (s *ManagedLicensesService) GetManagedLicense(pid, mlid interface{}, options ...RequestOptionFunc) (*ManagedLicense, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlicense, err := parseID(mlid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/managed_licenses/%s\", PathEscape(project), PathEscape(license))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tml := new(ManagedLicense)\n\tresp, err := s.client.Do(req, ml)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ml, resp, nil\n}\n\n// AddManagedLicenseOptions represents the available AddManagedLicense() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#create-a-new-managed-license\ntype AddManagedLicenseOptions struct {\n\tName           *string                     `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tApprovalStatus *LicenseApprovalStatusValue `url:\"approval_status,omitempty\" json:\"approval_status,omitempty\"`\n}\n\n// AddManagedLicense adds a managed license to a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#create-a-new-managed-license\nfunc (s *ManagedLicensesService) AddManagedLicense(pid interface{}, opt *AddManagedLicenseOptions, options ...RequestOptionFunc) (*ManagedLicense, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/managed_licenses\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tml := new(ManagedLicense)\n\tresp, err := s.client.Do(req, ml)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ml, resp, nil\n}\n\n// DeleteManagedLicense deletes a managed license with a given ID.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#delete-a-managed-license\nfunc (s *ManagedLicensesService) DeleteManagedLicense(pid, mlid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tlicense, err := parseID(mlid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/managed_licenses/%s\", PathEscape(project), PathEscape(license))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// EditManagedLicenceOptions represents the available EditManagedLicense() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#edit-an-existing-managed-license\ntype EditManagedLicenceOptions struct {\n\tApprovalStatus *LicenseApprovalStatusValue `url:\"approval_status,omitempty\" json:\"approval_status,omitempty\"`\n}\n\n// EditManagedLicense updates an existing managed license with a new approval\n// status.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/managed_licenses.html#edit-an-existing-managed-license\nfunc (s *ManagedLicensesService) EditManagedLicense(pid, mlid interface{}, opt *EditManagedLicenceOptions, options ...RequestOptionFunc) (*ManagedLicense, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tlicense, err := parseID(mlid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/managed_licenses/%s\", PathEscape(project), PathEscape(license))\n\n\treq, err := s.client.NewRequest(http.MethodPatch, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tml := new(ManagedLicense)\n\tresp, err := s.client.Do(req, ml)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ml, resp, nil\n}\n"
        },
        {
          "name": "project_managed_licenses_test.go",
          "type": "blob",
          "size": 4.158203125,
          "content": "//\n// Copyright 2021, Andrea Perizzato\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListManagedLicenses(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/managed_licenses\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_project_managed_licenses.json\")\n\t})\n\n\tlicenses, _, err := client.ManagedLicenses.ListManagedLicenses(1)\n\tif err != nil {\n\t\tt.Errorf(\"ManagedLicenses.ListManagedLicenses returned error: %v\", err)\n\t}\n\n\twant := []*ManagedLicense{\n\t\t{\n\t\t\tID:             1,\n\t\t\tName:           \"MIT\",\n\t\t\tApprovalStatus: LicenseApproved,\n\t\t},\n\t\t{\n\t\t\tID:             3,\n\t\t\tName:           \"ISC\",\n\t\t\tApprovalStatus: LicenseBlacklisted,\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, licenses) {\n\t\tt.Errorf(\"ManagedLicenses.ListManagedLicenses returned %+v, want %+v\", licenses, want)\n\t}\n}\n\nfunc TestGetManagedLicenses(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/managed_licenses/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_project_managed_license.json\")\n\t})\n\n\tlicense, _, err := client.ManagedLicenses.GetManagedLicense(1, 3)\n\tif err != nil {\n\t\tt.Errorf(\"ManagedLicenses.GetManagedLicense returned error: %v\", err)\n\t}\n\n\twant := &ManagedLicense{\n\t\tID:             3,\n\t\tName:           \"ISC\",\n\t\tApprovalStatus: LicenseBlacklisted,\n\t}\n\n\tif !reflect.DeepEqual(want, license) {\n\t\tt.Errorf(\"ManagedLicenses.GetManagedLicense returned %+v, want %+v\", license, want)\n\t}\n}\n\nfunc TestAddManagedLicenses(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/managed_licenses\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestBody(t, r, `{\"name\":\"MIT\",\"approval_status\":\"approved\"}`)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/add_project_managed_license.json\")\n\t})\n\n\tops := AddManagedLicenseOptions{\n\t\tName:           Ptr(\"MIT\"),\n\t\tApprovalStatus: Ptr(LicenseApproved),\n\t}\n\tlicense, _, err := client.ManagedLicenses.AddManagedLicense(1, &ops)\n\tif err != nil {\n\t\tt.Errorf(\"ManagedLicenses.AddManagedLicense returned error: %v\", err)\n\t}\n\n\twant := &ManagedLicense{\n\t\tID:             123,\n\t\tName:           \"MIT\",\n\t\tApprovalStatus: LicenseApproved,\n\t}\n\n\tif !reflect.DeepEqual(want, license) {\n\t\tt.Errorf(\"ManagedLicenses.AddManagedLicense returned %+v, want %+v\", license, want)\n\t}\n}\n\nfunc TestDeleteManagedLicenses(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/managed_licenses/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.ManagedLicenses.DeleteManagedLicense(1, 3)\n\tif err != nil {\n\t\tt.Errorf(\"ManagedLicenses.RemoveManagedLicense returned error: %v\", err)\n\t}\n}\n\nfunc TestEditManagedLicenses(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/managed_licenses/3\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPatch)\n\t\ttestBody(t, r, `{\"approval_status\":\"blacklisted\"}`)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/edit_project_managed_license.json\")\n\t})\n\n\tops := EditManagedLicenceOptions{\n\t\tApprovalStatus: Ptr(LicenseBlacklisted),\n\t}\n\tlicense, _, err := client.ManagedLicenses.EditManagedLicense(1, 3, &ops)\n\tif err != nil {\n\t\tt.Errorf(\"ManagedLicenses.EditManagedLicense returned error: %v\", err)\n\t}\n\n\twant := &ManagedLicense{\n\t\tID:             3,\n\t\tName:           \"CUSTOM\",\n\t\tApprovalStatus: LicenseBlacklisted,\n\t}\n\n\tif !reflect.DeepEqual(want, license) {\n\t\tt.Errorf(\"ManagedLicenses.EditManagedLicense returned %+v, want %+v\", license, want)\n\t}\n}\n"
        },
        {
          "name": "project_markdown_uploads.go",
          "type": "blob",
          "size": 6.4677734375,
          "content": "//\n// Copyright 2024, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectMarkdownUploadsService handles communication with the project markdown uploads\n// related methods of the GitLab API.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/project_markdown_uploads.html\ntype ProjectMarkdownUploadsService struct {\n\tclient *Client\n}\n\n// ProjectMarkdownUploadedFile represents a single project markdown uploaded file.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/project_markdown_uploads.html\ntype ProjectMarkdownUploadedFile struct {\n\tID       int    `json:\"id\"`\n\tAlt      string `json:\"alt\"`\n\tURL      string `json:\"url\"`\n\tFullPath string `json:\"full_path\"`\n\tMarkdown string `json:\"markdown\"`\n}\n\n// ProjectMarkdownUpload represents a single project markdown upload.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/project_markdown_uploads.html\ntype ProjectMarkdownUpload struct {\n\tID         int        `json:\"id\"`\n\tSize       int        `json:\"size\"`\n\tFilename   string     `json:\"filename\"`\n\tCreatedAt  *time.Time `json:\"created_at\"`\n\tUploadedBy *User      `json:\"uploaded_by\"`\n}\n\n// Gets a string representation of a ProjectMarkdownUpload.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_markdown_uploads.html\nfunc (m ProjectMarkdownUpload) String() string {\n\treturn Stringify(m)\n}\n\n// UploadProjectMarkdown uploads a markdown file to a project.\n//\n// GitLab docs:\n// https://docs.gitlab.com/ee/api/project_markdown_uploads.html#upload-a-file\nfunc (s *ProjectMarkdownUploadsService) UploadProjectMarkdown(pid interface{}, content io.Reader, options ...RequestOptionFunc) (*ProjectMarkdownUploadedFile, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads\", PathEscape(project))\n\n\t// We need to create the request as a GET request to make sure the options\n\t// are set correctly. After the request is created we will overwrite both\n\t// the method and the body.\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Overwrite the method and body.\n\treq.Method = http.MethodPost\n\treq.SetBody(content)\n\n\tf := new(ProjectMarkdownUploadedFile)\n\tresp, err := s.client.Do(req, f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f, resp, nil\n}\n\n// ListProjectMarkdownUploads gets all markdown uploads for a project.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/project_markdown_uploads.html#list-uploads\nfunc (s *ProjectMarkdownUploadsService) ListProjectMarkdownUploads(pid interface{}, options ...RequestOptionFunc) ([]*ProjectMarkdownUpload, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar uploads []*ProjectMarkdownUpload\n\tresp, err := s.client.Do(req, &uploads)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn uploads, resp, err\n}\n\n// DownloadProjectMarkdownUploadByID downloads a specific upload by ID.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/project_markdown_uploads.html#download-an-uploaded-file-by-id\nfunc (s *ProjectMarkdownUploadsService) DownloadProjectMarkdownUploadByID(pid interface{}, uploadID int, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads/%d\", PathEscape(project), uploadID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar f bytes.Buffer\n\tresp, err := s.client.Do(req, &f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f.Bytes(), resp, err\n}\n\n// DownloadProjectMarkdownUploadBySecretAndFilename downloads a specific upload\n// by secret and filename.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/project_markdown_uploads.html#download-an-uploaded-file-by-secret-and-filename\nfunc (s *ProjectMarkdownUploadsService) DownloadProjectMarkdownUploadBySecretAndFilename(pid interface{}, secret string, filename string, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads/%s/%s\", PathEscape(project), PathEscape(secret), PathEscape(filename))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar f bytes.Buffer\n\tresp, err := s.client.Do(req, &f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f.Bytes(), resp, err\n}\n\n// DeleteProjectMarkdownUploadByID deletes an upload by ID.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/project_markdown_uploads.html#delete-an-uploaded-file-by-id\nfunc (s *ProjectMarkdownUploadsService) DeleteProjectMarkdownUploadByID(pid interface{}, uploadID int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads/%d\", PathEscape(project), uploadID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteProjectMarkdownUploadBySecretAndFilename deletes an upload\n// by secret and filename.\n//\n// GitLab API Docs:\n// https://docs.gitlab.com/ee/api/project_markdown_uploads.html#delete-an-uploaded-file-by-secret-and-filename\nfunc (s *ProjectMarkdownUploadsService) DeleteProjectMarkdownUploadBySecretAndFilename(pid interface{}, secret string, filename string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads/%s/%s\",\n\t\tPathEscape(project), PathEscape(secret), PathEscape(filename))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_markdown_uploads_test.go",
          "type": "blob",
          "size": 4.3359375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectMarkdownUploads_UploadProjectMarkdown(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 5,\n\t\t\t\t\"alt\": \"dk\",\n\t\t\t\t\"url\": \"/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png\",\n\t\t\t\t\"full_path\": \"/-/project/1234/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png\",\n\t\t\t\t\"markdown\": \"![dk](/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png)\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMarkdownUploadedFile{\n\t\tID:       5,\n\t\tAlt:      \"dk\",\n\t\tURL:      \"/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png\",\n\t\tFullPath: \"/-/project/1234/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png\",\n\t\tMarkdown: \"![dk](/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png)\",\n\t}\n\n\tcontent := strings.NewReader(\"bar = baz\")\n\tupload, resp, err := client.ProjectMarkdownUploads.UploadProjectMarkdown(1, content)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, upload)\n}\n\nfunc TestProjectMarkdownUploads_ListProjectMarkdownUploads(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"size\": 1024,\n\t\t\t\t\t\"filename\": \"image.png\",\n\t\t\t\t\t\"created_at\":\"2024-06-20T15:53:03.000Z\",\n\t\t\t\t\t\"uploaded_by\": {\n\t\t\t\t\t\"id\": 18,\n\t\t\t\t\t\"name\" : \"Alexandra Bashirian\",\n\t\t\t\t\t\"username\" : \"eileen.lowe\"\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": 2,\n\t\t\t\t\t\"size\": 512,\n\t\t\t\t\t\"filename\": \"other-image.png\",\n\t\t\t\t\t\"created_at\":\"2024-06-19T15:53:03.000Z\",\n\t\t\t\t\t\"uploaded_by\": null\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\tcreated1 := time.Date(2024, 6, 20, 15, 53, 3, 0, time.UTC)\n\tcreated2 := time.Date(2024, 6, 19, 15, 53, 3, 0, time.UTC)\n\twant := []*ProjectMarkdownUpload{\n\t\t{\n\t\t\tID:        1,\n\t\t\tSize:      1024,\n\t\t\tFilename:  \"image.png\",\n\t\t\tCreatedAt: &created1,\n\t\t\tUploadedBy: &User{\n\t\t\t\tID:       18,\n\t\t\t\tName:     \"Alexandra Bashirian\",\n\t\t\t\tUsername: \"eileen.lowe\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:        2,\n\t\t\tSize:      512,\n\t\t\tFilename:  \"other-image.png\",\n\t\t\tCreatedAt: &created2,\n\t\t},\n\t}\n\n\tuploads, resp, err := client.ProjectMarkdownUploads.ListProjectMarkdownUploads(1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, uploads)\n}\n\nfunc TestProjectMarkdownUploads_DownloadProjectMarkdownUploadByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, strings.TrimSpace(`\n\t\t\tbar = baz\n\t\t`))\n\t})\n\n\twant := []byte(\"bar = baz\")\n\n\tbytes, resp, err := client.ProjectMarkdownUploads.DownloadProjectMarkdownUploadByID(1, 2)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bytes)\n}\n\nfunc TestProjectMarkdownUploads_DownloadProjectMarkdownUploadBySecretAndFilename(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads/secret/filename\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, strings.TrimSpace(`\n\t\t\tbar = baz\n\t\t`))\n\t})\n\n\twant := []byte(\"bar = baz\")\n\n\tbytes, resp, err := client.ProjectMarkdownUploads.DownloadProjectMarkdownUploadBySecretAndFilename(1, \"secret\", \"filename\")\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, bytes)\n}\n\nfunc TestProjectMarkdownUploads_DeleteProjectMarkdownUploadByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(204)\n\t})\n\n\tresp, err := client.ProjectMarkdownUploads.DeleteProjectMarkdownUploadByID(1, 2)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, 204, resp.StatusCode)\n}\n\nfunc TestProjectMarkdownUploads_DeleteProjectMarkdownUploadBySecretAndFilename(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads/secret/filename\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(204)\n\t})\n\n\tresp, err := client.ProjectMarkdownUploads.DeleteProjectMarkdownUploadBySecretAndFilename(1, \"secret\", \"filename\")\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, 204, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_members.go",
          "type": "blob",
          "size": 7.5859375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ProjectMembersService handles communication with the project members\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/members.html\ntype ProjectMembersService struct {\n\tclient *Client\n}\n\n// ListProjectMembersOptions represents the available ListProjectMembers() and\n// ListAllProjectMembers() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project\ntype ListProjectMembersOptions struct {\n\tListOptions\n\tQuery   *string `url:\"query,omitempty\" json:\"query,omitempty\"`\n\tUserIDs *[]int  `url:\"user_ids[],omitempty\" json:\"user_ids,omitempty\"`\n}\n\n// ListProjectMembers gets a list of a project's team members viewable by the\n// authenticated user. Returns only direct members and not inherited members\n// through ancestors groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project\nfunc (s *ProjectMembersService) ListProjectMembers(pid interface{}, opt *ListProjectMembersOptions, options ...RequestOptionFunc) ([]*ProjectMember, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pm []*ProjectMember\n\tresp, err := s.client.Do(req, &pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// ListAllProjectMembers gets a list of a project's team members viewable by the\n// authenticated user. Returns a list including inherited members through\n// ancestor groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project-including-inherited-and-invited-members\nfunc (s *ProjectMembersService) ListAllProjectMembers(pid interface{}, opt *ListProjectMembersOptions, options ...RequestOptionFunc) ([]*ProjectMember, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members/all\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pm []*ProjectMember\n\tresp, err := s.client.Do(req, &pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// GetProjectMember gets a project team member.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#get-a-member-of-a-group-or-project\nfunc (s *ProjectMembersService) GetProjectMember(pid interface{}, user int, options ...RequestOptionFunc) (*ProjectMember, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members/%d\", PathEscape(project), user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMember)\n\tresp, err := s.client.Do(req, pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// GetInheritedProjectMember gets a project team member, including inherited\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#get-a-member-of-a-group-or-project-including-inherited-and-invited-members\nfunc (s *ProjectMembersService) GetInheritedProjectMember(pid interface{}, user int, options ...RequestOptionFunc) (*ProjectMember, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members/all/%d\", PathEscape(project), user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMember)\n\tresp, err := s.client.Do(req, pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// AddProjectMemberOptions represents the available AddProjectMember() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#add-a-member-to-a-group-or-project\ntype AddProjectMemberOptions struct {\n\tUserID       interface{}       `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tAccessLevel  *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt    *string           `url:\"expires_at,omitempty\" json:\"expires_at\"`\n\tMemberRoleID *int              `url:\"member_role_id,omitempty\" json:\"member_role_id,omitempty\"`\n}\n\n// AddProjectMember adds a user to a project team. This is an idempotent\n// method and can be called multiple times with the same parameters. Adding\n// team membership to a user that is already a member does not affect the\n// existing membership.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#add-a-member-to-a-group-or-project\nfunc (s *ProjectMembersService) AddProjectMember(pid interface{}, opt *AddProjectMemberOptions, options ...RequestOptionFunc) (*ProjectMember, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMember)\n\tresp, err := s.client.Do(req, pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// EditProjectMemberOptions represents the available EditProjectMember() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#edit-a-member-of-a-group-or-project\ntype EditProjectMemberOptions struct {\n\tAccessLevel  *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tExpiresAt    *string           `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n\tMemberRoleID *int              `url:\"member_role_id,omitempty\" json:\"member_role_id,omitempty\"`\n}\n\n// EditProjectMember updates a project team member to a specified access level..\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#edit-a-member-of-a-group-or-project\nfunc (s *ProjectMembersService) EditProjectMember(pid interface{}, user int, opt *EditProjectMemberOptions, options ...RequestOptionFunc) (*ProjectMember, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members/%d\", PathEscape(project), user)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMember)\n\tresp, err := s.client.Do(req, pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// DeleteProjectMember removes a user from a project team.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#remove-a-member-from-a-group-or-project\nfunc (s *ProjectMembersService) DeleteProjectMember(pid interface{}, user int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/members/%d\", PathEscape(project), user)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_members_test.go",
          "type": "blob",
          "size": 11.4814453125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectMembersService_ListProjectMembers(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t\t\"access_level\": 30,\n\t\t\t\t\"group_saml_identity\": null\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectMember{{\n\t\tID:          1,\n\t\tUsername:    \"venkatesh_thalluri\",\n\t\tEmail:       \"\",\n\t\tName:        \"Venkatesh Thalluri\",\n\t\tState:       \"active\",\n\t\tAccessLevel: 30,\n\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t}}\n\n\tpms, resp, err := client.ProjectMembers.ListProjectMembers(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pms)\n\n\tpms, resp, err = client.ProjectMembers.ListProjectMembers(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pms)\n\n\tpms, resp, err = client.ProjectMembers.ListProjectMembers(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pms)\n\n\tpms, resp, err = client.ProjectMembers.ListProjectMembers(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pms)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMembersService_ListAllProjectMembers(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members/all\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t\t\"access_level\": 30,\n\t\t\t\t\"group_saml_identity\": null\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectMember{{\n\t\tID:          1,\n\t\tUsername:    \"venkatesh_thalluri\",\n\t\tEmail:       \"\",\n\t\tName:        \"Venkatesh Thalluri\",\n\t\tState:       \"active\",\n\t\tAccessLevel: 30,\n\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t}}\n\n\tpms, resp, err := client.ProjectMembers.ListAllProjectMembers(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pms)\n\n\tpms, resp, err = client.ProjectMembers.ListAllProjectMembers(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pms)\n\n\tpms, resp, err = client.ProjectMembers.ListAllProjectMembers(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pms)\n\n\tpms, resp, err = client.ProjectMembers.ListAllProjectMembers(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pms)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMembersService_GetProjectMember(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venkatesh_thalluri\",\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t  \"access_level\": 30,\n\t\t\t  \"email\": \"venkatesh.thalluri@example.com\",\n\t\t\t  \"expires_at\": null,\n\t\t\t  \"group_saml_identity\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMember{\n\t\tID:          1,\n\t\tUsername:    \"venkatesh_thalluri\",\n\t\tEmail:       \"venkatesh.thalluri@example.com\",\n\t\tName:        \"Venkatesh Thalluri\",\n\t\tState:       \"active\",\n\t\tExpiresAt:   nil,\n\t\tAccessLevel: 30,\n\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t}\n\n\tpm, resp, err := client.ProjectMembers.GetProjectMember(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tpm, resp, err = client.ProjectMembers.GetProjectMember(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.GetProjectMember(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.GetProjectMember(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMembersService_GetInheritedProjectMember(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members/all/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venkatesh_thalluri\",\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t  \"access_level\": 30,\n\t\t\t  \"email\": \"venkatesh.thalluri@example.com\",\n\t\t\t  \"expires_at\": null,\n\t\t\t  \"group_saml_identity\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMember{\n\t\tID:          1,\n\t\tUsername:    \"venkatesh_thalluri\",\n\t\tEmail:       \"venkatesh.thalluri@example.com\",\n\t\tName:        \"Venkatesh Thalluri\",\n\t\tState:       \"active\",\n\t\tExpiresAt:   nil,\n\t\tAccessLevel: 30,\n\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t}\n\n\tpm, resp, err := client.ProjectMembers.GetInheritedProjectMember(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tpm, resp, err = client.ProjectMembers.GetInheritedProjectMember(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.GetInheritedProjectMember(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.GetInheritedProjectMember(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMembersService_AddProjectMember(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venkatesh_thalluri\",\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t  \"access_level\": 30,\n\t\t\t  \"email\": \"venkatesh.thalluri@example.com\",\n\t\t\t  \"expires_at\": null,\n\t\t\t  \"group_saml_identity\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMember{\n\t\tID:          1,\n\t\tUsername:    \"venkatesh_thalluri\",\n\t\tEmail:       \"venkatesh.thalluri@example.com\",\n\t\tName:        \"Venkatesh Thalluri\",\n\t\tState:       \"active\",\n\t\tExpiresAt:   nil,\n\t\tAccessLevel: 30,\n\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t}\n\n\tpm, resp, err := client.ProjectMembers.AddProjectMember(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tpm, resp, err = client.ProjectMembers.AddProjectMember(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.AddProjectMember(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.AddProjectMember(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMembersService_EditProjectMember(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venkatesh_thalluri\",\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t  \"access_level\": 30,\n\t\t\t  \"email\": \"venkatesh.thalluri@example.com\",\n\t\t\t  \"expires_at\": null,\n\t\t\t  \"group_saml_identity\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMember{\n\t\tID:          1,\n\t\tUsername:    \"venkatesh_thalluri\",\n\t\tEmail:       \"venkatesh.thalluri@example.com\",\n\t\tName:        \"Venkatesh Thalluri\",\n\t\tState:       \"active\",\n\t\tExpiresAt:   nil,\n\t\tAccessLevel: 30,\n\t\tWebURL:      \"http://192.168.1.8:3000/root\",\n\t\tAvatarURL:   \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t}\n\n\tpm, resp, err := client.ProjectMembers.EditProjectMember(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tpm, resp, err = client.ProjectMembers.EditProjectMember(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.EditProjectMember(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMembers.EditProjectMember(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMembersService_DeleteProjectMember(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/members/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"username\": \"venkatesh_thalluri\",\n\t\t\t  \"name\": \"Venkatesh Thalluri\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/c2525a7f58ae3776070e44c106c48e15?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://192.168.1.8:3000/root\",\n\t\t\t  \"access_level\": 30,\n\t\t\t  \"email\": \"venkatesh.thalluri@example.com\",\n\t\t\t  \"expires_at\": null,\n\t\t\t  \"group_saml_identity\": null\n\t\t\t}\n\t\t`)\n\t})\n\n\tresp, err := client.ProjectMembers.DeleteProjectMember(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.ProjectMembers.DeleteProjectMember(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectMembers.DeleteProjectMember(1, 1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectMembers.DeleteProjectMember(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_mirror.go",
          "type": "blob",
          "size": 6.54296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectMirrorService handles communication with the project mirror\n// related methods of the GitLab API.\n//\n// GitLAb API docs: https://docs.gitlab.com/ee/api/remote_mirrors.html\ntype ProjectMirrorService struct {\n\tclient *Client\n}\n\n// ProjectMirror represents a project mirror configuration.\n//\n// GitLAb API docs: https://docs.gitlab.com/ee/api/remote_mirrors.html\ntype ProjectMirror struct {\n\tEnabled                bool       `json:\"enabled\"`\n\tID                     int        `json:\"id\"`\n\tLastError              string     `json:\"last_error\"`\n\tLastSuccessfulUpdateAt *time.Time `json:\"last_successful_update_at\"`\n\tLastUpdateAt           *time.Time `json:\"last_update_at\"`\n\tLastUpdateStartedAt    *time.Time `json:\"last_update_started_at\"`\n\tMirrorBranchRegex      string     `json:\"mirror_branch_regex\"`\n\tOnlyProtectedBranches  bool       `json:\"only_protected_branches\"`\n\tKeepDivergentRefs      bool       `json:\"keep_divergent_refs\"`\n\tUpdateStatus           string     `json:\"update_status\"`\n\tURL                    string     `json:\"url\"`\n}\n\n// ListProjectMirrorOptions represents the available ListProjectMirror() options.\ntype ListProjectMirrorOptions ListOptions\n\n// ListProjectMirror gets a list of mirrors configured on the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#list-a-projects-remote-mirrors\nfunc (s *ProjectMirrorService) ListProjectMirror(pid interface{}, opt *ListProjectMirrorOptions, options ...RequestOptionFunc) ([]*ProjectMirror, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/remote_mirrors\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pm []*ProjectMirror\n\tresp, err := s.client.Do(req, &pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// GetProjectMirror gets a single mirror configured on the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#get-a-single-projects-remote-mirror\nfunc (s *ProjectMirrorService) GetProjectMirror(pid interface{}, mirror int, options ...RequestOptionFunc) (*ProjectMirror, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/remote_mirrors/%d\", PathEscape(project), mirror)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMirror)\n\tresp, err := s.client.Do(req, &pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// AddProjectMirrorOptions contains the properties requires to create\n// a new project mirror.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#create-a-push-mirror\ntype AddProjectMirrorOptions struct {\n\tURL                   *string `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tEnabled               *bool   `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\tKeepDivergentRefs     *bool   `url:\"keep_divergent_refs,omitempty\" json:\"keep_divergent_refs,omitempty\"`\n\tOnlyProtectedBranches *bool   `url:\"only_protected_branches,omitempty\" json:\"only_protected_branches,omitempty\"`\n\tMirrorBranchRegex     *string `url:\"mirror_branch_regex,omitempty\" json:\"mirror_branch_regex,omitempty\"`\n}\n\n// AddProjectMirror creates a new mirror on the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#create-a-push-mirror\nfunc (s *ProjectMirrorService) AddProjectMirror(pid interface{}, opt *AddProjectMirrorOptions, options ...RequestOptionFunc) (*ProjectMirror, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/remote_mirrors\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMirror)\n\tresp, err := s.client.Do(req, pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// EditProjectMirrorOptions contains the properties requires to edit\n// an existing project mirror.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#update-a-remote-mirrors-attributes\ntype EditProjectMirrorOptions struct {\n\tEnabled               *bool   `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\tKeepDivergentRefs     *bool   `url:\"keep_divergent_refs,omitempty\" json:\"keep_divergent_refs,omitempty\"`\n\tOnlyProtectedBranches *bool   `url:\"only_protected_branches,omitempty\" json:\"only_protected_branches,omitempty\"`\n\tMirrorBranchRegex     *string `url:\"mirror_branch_regex,omitempty\" json:\"mirror_branch_regex,omitempty\"`\n}\n\n// EditProjectMirror updates a project team member to a specified access level..\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#update-a-remote-mirrors-attributes\nfunc (s *ProjectMirrorService) EditProjectMirror(pid interface{}, mirror int, opt *EditProjectMirrorOptions, options ...RequestOptionFunc) (*ProjectMirror, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/remote_mirrors/%d\", PathEscape(project), mirror)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpm := new(ProjectMirror)\n\tresp, err := s.client.Do(req, pm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pm, resp, nil\n}\n\n// DeleteProjectMirror deletes a project mirror.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/remote_mirrors.html#delete-a-remote-mirror\nfunc (s *ProjectMirrorService) DeleteProjectMirror(pid interface{}, mirror int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/remote_mirrors/%d\", PathEscape(project), mirror)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_mirror_test.go",
          "type": "blob",
          "size": 5.7705078125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectMirrorService_ListProjectMirror(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/42/remote_mirrors\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"enabled\": true,\n\t\t\t\t\"id\": 101486,\n\t\t\t\t\"last_error\": null,\n\t\t\t\t\"only_protected_branches\": true,\n\t\t\t\t\"keep_divergent_refs\": true,\n\t\t\t\t\"update_status\": \"finished\",\n\t\t\t\t\"url\": \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectMirror{{\n\t\tEnabled:               true,\n\t\tID:                    101486,\n\t\tLastError:             \"\",\n\t\tOnlyProtectedBranches: true,\n\t\tKeepDivergentRefs:     true,\n\t\tUpdateStatus:          \"finished\",\n\t\tURL:                   \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\",\n\t}}\n\n\tpms, resp, err := client.ProjectMirrors.ListProjectMirror(42, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pms)\n\n\tpms, resp, err = client.ProjectMirrors.ListProjectMirror(42.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 42.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pms)\n\n\tpms, resp, err = client.ProjectMirrors.ListProjectMirror(42, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pms)\n\n\tpms, resp, err = client.ProjectMirrors.ListProjectMirror(43, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pms)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMirrorService_GetProjectMirror(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/42/remote_mirrors/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"enabled\": true,\n\t\t\t\t\"id\": 101486,\n\t\t\t\t\"last_error\": null,\n\t\t\t\t\"only_protected_branches\": true,\n\t\t\t\t\"keep_divergent_refs\": true,\n\t\t\t\t\"update_status\": \"finished\",\n\t\t\t\t\"url\": \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMirror{\n\t\tEnabled:               true,\n\t\tID:                    101486,\n\t\tLastError:             \"\",\n\t\tOnlyProtectedBranches: true,\n\t\tKeepDivergentRefs:     true,\n\t\tUpdateStatus:          \"finished\",\n\t\tURL:                   \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\",\n\t}\n\n\tpm, resp, err := client.ProjectMirrors.GetProjectMirror(42, 1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n}\n\nfunc TestProjectMirrorService_AddProjectMirror(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/42/remote_mirrors\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"enabled\": false,\n\t\t\t\t\"id\": 101486,\n\t\t\t\t\"last_error\": null,\n\t\t\t\t\"last_successful_update_at\": null,\n\t\t\t\t\"last_update_at\": null,\n\t\t\t\t\"last_update_started_at\": null,\n\t\t\t\t\"only_protected_branches\": false,\n\t\t\t\t\"keep_divergent_refs\": false,\n\t\t\t\t\"update_status\": \"none\",\n\t\t\t\t\"url\": \"https://*****:*****@example.com/gitlab/example.git\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMirror{\n\t\tEnabled:                false,\n\t\tID:                     101486,\n\t\tLastError:              \"\",\n\t\tLastSuccessfulUpdateAt: nil,\n\t\tLastUpdateAt:           nil,\n\t\tLastUpdateStartedAt:    nil,\n\t\tOnlyProtectedBranches:  false,\n\t\tKeepDivergentRefs:      false,\n\t\tUpdateStatus:           \"none\",\n\t\tURL:                    \"https://*****:*****@example.com/gitlab/example.git\",\n\t}\n\n\tpm, resp, err := client.ProjectMirrors.AddProjectMirror(42, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tpm, resp, err = client.ProjectMirrors.AddProjectMirror(42.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 42.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMirrors.AddProjectMirror(42, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMirrors.AddProjectMirror(43, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectMirrorService_EditProjectMirror(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/42/remote_mirrors/101486\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"enabled\": false,\n\t\t\t\t\"id\": 101486,\n\t\t\t\t\"last_error\": null,\n\t\t\t\t\"only_protected_branches\": true,\n\t\t\t\t\"keep_divergent_refs\": true,\n\t\t\t\t\"update_status\": \"finished\",\n\t\t\t\t\"url\": \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectMirror{\n\t\tEnabled:               false,\n\t\tID:                    101486,\n\t\tLastError:             \"\",\n\t\tOnlyProtectedBranches: true,\n\t\tKeepDivergentRefs:     true,\n\t\tUpdateStatus:          \"finished\",\n\t\tURL:                   \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\",\n\t}\n\n\tpm, resp, err := client.ProjectMirrors.EditProjectMirror(42, 101486, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pm)\n\n\tpm, resp, err = client.ProjectMirrors.EditProjectMirror(42.01, 101486, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 42.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMirrors.EditProjectMirror(42, 101486, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pm)\n\n\tpm, resp, err = client.ProjectMirrors.EditProjectMirror(43, 101486, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pm)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_repository_storage_move.go",
          "type": "blob",
          "size": 7.41015625,
          "content": "//\n// Copyright 2023, Nick Westbury\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectRepositoryStorageMoveService handles communication with the\n// repositories related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html\ntype ProjectRepositoryStorageMoveService struct {\n\tclient *Client\n}\n\n// ProjectRepositoryStorageMove represents the status of a repository move.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html\ntype ProjectRepositoryStorageMove struct {\n\tID                     int                `json:\"id\"`\n\tCreatedAt              *time.Time         `json:\"created_at\"`\n\tState                  string             `json:\"state\"`\n\tSourceStorageName      string             `json:\"source_storage_name\"`\n\tDestinationStorageName string             `json:\"destination_storage_name\"`\n\tProject                *RepositoryProject `json:\"project\"`\n}\n\ntype RepositoryProject struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n}\n\n// RetrieveAllProjectStorageMovesOptions represents the available\n// RetrieveAllStorageMoves() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#retrieve-all-project-repository-storage-moves\ntype RetrieveAllProjectStorageMovesOptions ListOptions\n\n// RetrieveAllStorageMoves retrieves all project repository storage moves\n// accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#retrieve-all-project-repository-storage-moves\nfunc (p ProjectRepositoryStorageMoveService) RetrieveAllStorageMoves(opts RetrieveAllProjectStorageMovesOptions, options ...RequestOptionFunc) ([]*ProjectRepositoryStorageMove, *Response, error) {\n\treq, err := p.client.NewRequest(http.MethodGet, \"project_repository_storage_moves\", opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar psms []*ProjectRepositoryStorageMove\n\tresp, err := p.client.Do(req, &psms)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn psms, resp, err\n}\n\n// RetrieveAllStorageMovesForProject retrieves all repository storage moves for\n// a single project accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#retrieve-all-repository-storage-moves-for-a-project\nfunc (p ProjectRepositoryStorageMoveService) RetrieveAllStorageMovesForProject(project int, opts RetrieveAllProjectStorageMovesOptions, options ...RequestOptionFunc) ([]*ProjectRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"projects/%d/repository_storage_moves\", project)\n\n\treq, err := p.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar psms []*ProjectRepositoryStorageMove\n\tresp, err := p.client.Do(req, &psms)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn psms, resp, err\n}\n\n// GetStorageMove gets a single project repository storage move.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#get-a-single-project-repository-storage-move\nfunc (p ProjectRepositoryStorageMoveService) GetStorageMove(repositoryStorage int, options ...RequestOptionFunc) (*ProjectRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"project_repository_storage_moves/%d\", repositoryStorage)\n\n\treq, err := p.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpsm := new(ProjectRepositoryStorageMove)\n\tresp, err := p.client.Do(req, psm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn psm, resp, err\n}\n\n// GetStorageMoveForProject gets a single repository storage move for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#get-a-single-repository-storage-move-for-a-project\nfunc (p ProjectRepositoryStorageMoveService) GetStorageMoveForProject(project int, repositoryStorage int, options ...RequestOptionFunc) (*ProjectRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"projects/%d/repository_storage_moves/%d\", project, repositoryStorage)\n\n\treq, err := p.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpsm := new(ProjectRepositoryStorageMove)\n\tresp, err := p.client.Do(req, psm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn psm, resp, err\n}\n\n// ScheduleStorageMoveForProjectOptions represents the available\n// ScheduleStorageMoveForProject() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#schedule-a-repository-storage-move-for-a-project\ntype ScheduleStorageMoveForProjectOptions struct {\n\tDestinationStorageName *string `url:\"destination_storage_name,omitempty\" json:\"destination_storage_name,omitempty\"`\n}\n\n// ScheduleStorageMoveForProject schedule a repository to be moved for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#schedule-a-repository-storage-move-for-a-project\nfunc (p ProjectRepositoryStorageMoveService) ScheduleStorageMoveForProject(project int, opts ScheduleStorageMoveForProjectOptions, options ...RequestOptionFunc) (*ProjectRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"projects/%d/repository_storage_moves\", project)\n\n\treq, err := p.client.NewRequest(http.MethodPost, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpsm := new(ProjectRepositoryStorageMove)\n\tresp, err := p.client.Do(req, psm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn psm, resp, err\n}\n\n// ScheduleAllProjectStorageMovesOptions represents the available\n// ScheduleAllStorageMoves() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#schedule-repository-storage-moves-for-all-projects-on-a-storage-shard\ntype ScheduleAllProjectStorageMovesOptions struct {\n\tSourceStorageName      *string `url:\"source_storage_name,omitempty\" json:\"source_storage_name,omitempty\"`\n\tDestinationStorageName *string `url:\"destination_storage_name,omitempty\" json:\"destination_storage_name,omitempty\"`\n}\n\n// ScheduleAllStorageMoves schedules all repositories to be moved.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_repository_storage_moves.html#schedule-repository-storage-moves-for-all-projects-on-a-storage-shard\nfunc (p ProjectRepositoryStorageMoveService) ScheduleAllStorageMoves(opts ScheduleAllProjectStorageMovesOptions, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := p.client.NewRequest(http.MethodPost, \"project_repository_storage_moves\", opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn p.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_repository_storage_move_test.go",
          "type": "blob",
          "size": 4.5361328125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectRepositoryStorageMove_RetrieveAllProjectStorageMoves(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/project_repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"project\":{\n\t\t\t\"id\":1,\n\t\t\t\"name\":\"Test Project\"\n\t\t  }\n\t\t},\n\t\t{\n\t\t  \"id\":122,\n\t\t  \"state\":\"finished\",\n\t\t  \"project\":{\n\t\t\t\"id\":2,\n\t\t\t\"name\":\"Test Project 2\"\n\t\t  }\n\t\t}]`)\n\t})\n\n\topts := RetrieveAllProjectStorageMovesOptions{Page: 1, PerPage: 2}\n\n\tssms, _, err := client.ProjectRepositoryStorageMove.RetrieveAllStorageMoves(opts)\n\trequire.NoError(t, err)\n\n\twant := []*ProjectRepositoryStorageMove{\n\t\t{\n\t\t\tID:    123,\n\t\t\tState: \"scheduled\",\n\t\t\tProject: &RepositoryProject{\n\t\t\t\tID:   1,\n\t\t\t\tName: \"Test Project\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:    122,\n\t\t\tState: \"finished\",\n\t\t\tProject: &RepositoryProject{\n\t\t\t\tID:   2,\n\t\t\t\tName: \"Test Project 2\",\n\t\t\t},\n\t\t},\n\t}\n\trequire.Equal(t, want, ssms)\n}\n\nfunc TestProjectRepositoryStorageMove_RetrieveAllStorageMovesForProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"project\":{\n\t\t\t\"id\":1,\n\t\t\t\"name\":\"Test Project\"\n\t\t  }\n\t\t},\n\t\t{\n\t\t  \"id\":122,\n\t\t  \"state\":\"finished\",\n\t\t  \"project\":{\n\t\t\t\"id\":1,\n\t\t\t\"name\":\"Test Project\"\n\t\t  }\n\t\t}]`)\n\t})\n\n\topts := RetrieveAllProjectStorageMovesOptions{Page: 1, PerPage: 2}\n\n\tssms, _, err := client.ProjectRepositoryStorageMove.RetrieveAllStorageMovesForProject(1, opts)\n\trequire.NoError(t, err)\n\n\twant := []*ProjectRepositoryStorageMove{\n\t\t{\n\t\t\tID:    123,\n\t\t\tState: \"scheduled\",\n\t\t\tProject: &RepositoryProject{\n\t\t\t\tID:   1,\n\t\t\t\tName: \"Test Project\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:    122,\n\t\t\tState: \"finished\",\n\t\t\tProject: &RepositoryProject{\n\t\t\t\tID:   1,\n\t\t\t\tName: \"Test Project\",\n\t\t\t},\n\t\t},\n\t}\n\trequire.Equal(t, want, ssms)\n}\n\nfunc TestProjectRepositoryStorageMove_GetStorageMove(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/project_repository_storage_moves/123\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"project\":{\n\t\t\t\"id\":1,\n\t\t\t\"name\":\"Test Project\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.ProjectRepositoryStorageMove.GetStorageMove(123)\n\trequire.NoError(t, err)\n\n\twant := &ProjectRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tProject: &RepositoryProject{\n\t\t\tID:   1,\n\t\t\tName: \"Test Project\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestProjectRepositoryStorageMove_GetStorageMoveForProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository_storage_moves/123\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"project\":{\n\t\t\t\"id\":1,\n\t\t\t\"name\":\"Test Project\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.ProjectRepositoryStorageMove.GetStorageMoveForProject(1, 123)\n\trequire.NoError(t, err)\n\n\twant := &ProjectRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tProject: &RepositoryProject{\n\t\t\tID:   1,\n\t\t\tName: \"Test Project\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestProjectRepositoryStorageMove_ScheduleStorageMoveForProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":124,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"project\":{\n\t\t\t\"id\":1,\n\t\t\t\"name\":\"Test Project\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.ProjectRepositoryStorageMove.ScheduleStorageMoveForProject(1, ScheduleStorageMoveForProjectOptions{})\n\trequire.NoError(t, err)\n\n\twant := &ProjectRepositoryStorageMove{\n\t\tID:    124,\n\t\tState: \"scheduled\",\n\t\tProject: &RepositoryProject{\n\t\t\tID:   1,\n\t\t\tName: \"Test Project\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestProjectRepositoryStorageMove_ScheduleAllStorageMoves(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/project_repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"message\": \"202 Accepted\"}`)\n\t})\n\n\t_, err := client.ProjectRepositoryStorageMove.ScheduleAllStorageMoves(\n\t\tScheduleAllProjectStorageMovesOptions{\n\t\t\tSourceStorageName: Ptr(\"default\"),\n\t\t},\n\t)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "project_snippets.go",
          "type": "blob",
          "size": 6.7275390625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ProjectSnippetsService handles communication with the project snippets\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_snippets.html\ntype ProjectSnippetsService struct {\n\tclient *Client\n}\n\n// ListProjectSnippetsOptions represents the available ListSnippets() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_snippets.html#list-snippets\ntype ListProjectSnippetsOptions ListOptions\n\n// ListSnippets gets a list of project snippets.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_snippets.html#list-snippets\nfunc (s *ProjectSnippetsService) ListSnippets(pid interface{}, opt *ListProjectSnippetsOptions, options ...RequestOptionFunc) ([]*Snippet, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Snippet\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// GetSnippet gets a single project snippet\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#single-snippet\nfunc (s *ProjectSnippetsService) GetSnippet(pid interface{}, snippet int, options ...RequestOptionFunc) (*Snippet, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tps := new(Snippet)\n\tresp, err := s.client.Do(req, ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// CreateProjectSnippetOptions represents the available CreateSnippet() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#create-new-snippet\ntype CreateProjectSnippetOptions struct {\n\tTitle       *string                      `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFileName    *string                      `url:\"file_name,omitempty\" json:\"file_name,omitempty\"`\n\tDescription *string                      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tContent     *string                      `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tVisibility  *VisibilityValue             `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tFiles       *[]*CreateSnippetFileOptions `url:\"files,omitempty\" json:\"files,omitempty\"`\n}\n\n// CreateSnippet creates a new project snippet. The user must have permission\n// to create new snippets.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#create-new-snippet\nfunc (s *ProjectSnippetsService) CreateSnippet(pid interface{}, opt *CreateProjectSnippetOptions, options ...RequestOptionFunc) (*Snippet, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tps := new(Snippet)\n\tresp, err := s.client.Do(req, ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// UpdateProjectSnippetOptions represents the available UpdateSnippet() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#update-snippet\ntype UpdateProjectSnippetOptions struct {\n\tTitle       *string                      `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFileName    *string                      `url:\"file_name,omitempty\" json:\"file_name,omitempty\"`\n\tDescription *string                      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tContent     *string                      `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tVisibility  *VisibilityValue             `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tFiles       *[]*UpdateSnippetFileOptions `url:\"files,omitempty\" json:\"files,omitempty\"`\n}\n\n// UpdateSnippet updates an existing project snippet. The user must have\n// permission to change an existing snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#update-snippet\nfunc (s *ProjectSnippetsService) UpdateSnippet(pid interface{}, snippet int, opt *UpdateProjectSnippetOptions, options ...RequestOptionFunc) (*Snippet, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tps := new(Snippet)\n\tresp, err := s.client.Do(req, ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// DeleteSnippet deletes an existing project snippet. This is an idempotent\n// function and deleting a non-existent snippet still returns a 200 OK status\n// code.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#delete-snippet\nfunc (s *ProjectSnippetsService) DeleteSnippet(pid interface{}, snippet int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SnippetContent returns the raw project snippet as plain text.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_snippets.html#snippet-content\nfunc (s *ProjectSnippetsService) SnippetContent(pid interface{}, snippet int, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/snippets/%d/raw\", PathEscape(project), snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n"
        },
        {
          "name": "project_snippets_test.go",
          "type": "blob",
          "size": 11.3173828125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectSnippetsService_ListSnippets(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"title\": \"test\",\n\t\t\t\t  \"file_name\": \"add.rb\",\n\t\t\t\t  \"description\": \"Ruby test snippet\",\n\t\t\t\t  \"author\": {\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\t\"email\": \"venky@example.com\",\n\t\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\t\"state\": \"active\"\n\t\t\t\t  },\n\t\t\t\t  \"project_id\": 1,\n\t\t\t\t  \"web_url\": \"http://example.com/example/example/snippets/1\",\n\t\t\t\t  \"raw_url\": \"http://example.com/example/example/snippets/1/raw\"\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*Snippet{{\n\t\tID:          1,\n\t\tTitle:       \"test\",\n\t\tFileName:    \"add.rb\",\n\t\tDescription: \"Ruby test snippet\",\n\t\tAuthor: struct {\n\t\t\tID        int        `json:\"id\"`\n\t\t\tUsername  string     `json:\"username\"`\n\t\t\tEmail     string     `json:\"email\"`\n\t\t\tName      string     `json:\"name\"`\n\t\t\tState     string     `json:\"state\"`\n\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t}{\n\t\t\tID:       1,\n\t\t\tUsername: \"venkatesh_thalluri\",\n\t\t\tEmail:    \"venky@example.com\",\n\t\t\tName:     \"Venkatesh Thalluri\",\n\t\t\tState:    \"active\",\n\t\t},\n\t\tProjectID: 1,\n\t\tWebURL:    \"http://example.com/example/example/snippets/1\",\n\t\tRawURL:    \"http://example.com/example/example/snippets/1/raw\",\n\t}}\n\n\tss, resp, err := client.ProjectSnippets.ListSnippets(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ss)\n\n\tss, resp, err = client.ProjectSnippets.ListSnippets(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ss)\n\n\tss, resp, err = client.ProjectSnippets.ListSnippets(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, ss)\n\n\tss, resp, err = client.ProjectSnippets.ListSnippets(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, ss)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectSnippetsService_GetSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"test\",\n\t\t\t  \"file_name\": \"add.rb\",\n\t\t\t  \"description\": \"Ruby test snippet\",\n\t\t\t  \"author\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\"email\": \"venky@example.com\",\n\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\"state\": \"active\"\n\t\t\t  },\n\t\t\t  \"project_id\": 1,\n\t\t\t  \"web_url\": \"http://example.com/example/example/snippets/1\",\n\t\t\t  \"raw_url\": \"http://example.com/example/example/snippets/1/raw\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &Snippet{\n\t\tID:          1,\n\t\tTitle:       \"test\",\n\t\tFileName:    \"add.rb\",\n\t\tDescription: \"Ruby test snippet\",\n\t\tAuthor: struct {\n\t\t\tID        int        `json:\"id\"`\n\t\t\tUsername  string     `json:\"username\"`\n\t\t\tEmail     string     `json:\"email\"`\n\t\t\tName      string     `json:\"name\"`\n\t\t\tState     string     `json:\"state\"`\n\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t}{\n\t\t\tID:       1,\n\t\t\tUsername: \"venkatesh_thalluri\",\n\t\t\tEmail:    \"venky@example.com\",\n\t\t\tName:     \"Venkatesh Thalluri\",\n\t\t\tState:    \"active\",\n\t\t},\n\t\tProjectID: 1,\n\t\tWebURL:    \"http://example.com/example/example/snippets/1\",\n\t\tRawURL:    \"http://example.com/example/example/snippets/1/raw\",\n\t}\n\n\ts, resp, err := client.ProjectSnippets.GetSnippet(1, 1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, s)\n\n\ts, resp, err = client.ProjectSnippets.GetSnippet(1.01, 1, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.GetSnippet(1, 1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.GetSnippet(2, 1, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, s)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectSnippetsService_CreateSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"test\",\n\t\t\t  \"file_name\": \"add.rb\",\n\t\t\t  \"description\": \"Ruby test snippet\",\n\t\t\t  \"author\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\"email\": \"venky@example.com\",\n\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\"state\": \"active\"\n\t\t\t  },\n\t\t\t  \"project_id\": 1,\n\t\t\t  \"web_url\": \"http://example.com/example/example/snippets/1\",\n\t\t\t  \"raw_url\": \"http://example.com/example/example/snippets/1/raw\",\n\t\t\t  \"files\": [\n\t\t\t\t{\n\t\t\t\t\t\"path\": \"add.rb\",\n\t\t\t\t\t\"raw_url\": \"http://example.com/example/example/-/snippets/1/raw/main/add.rb\"\n\t\t\t\t}\n\t   \t\t  ]\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &Snippet{\n\t\tID:          1,\n\t\tTitle:       \"test\",\n\t\tFileName:    \"add.rb\",\n\t\tDescription: \"Ruby test snippet\",\n\t\tAuthor: struct {\n\t\t\tID        int        `json:\"id\"`\n\t\t\tUsername  string     `json:\"username\"`\n\t\t\tEmail     string     `json:\"email\"`\n\t\t\tName      string     `json:\"name\"`\n\t\t\tState     string     `json:\"state\"`\n\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t}{\n\t\t\tID:       1,\n\t\t\tUsername: \"venkatesh_thalluri\",\n\t\t\tEmail:    \"venky@example.com\",\n\t\t\tName:     \"Venkatesh Thalluri\",\n\t\t\tState:    \"active\",\n\t\t},\n\t\tProjectID: 1,\n\t\tWebURL:    \"http://example.com/example/example/snippets/1\",\n\t\tRawURL:    \"http://example.com/example/example/snippets/1/raw\",\n\t\tFiles: []struct {\n\t\t\tPath   string `json:\"path\"`\n\t\t\tRawURL string `json:\"raw_url\"`\n\t\t}{\n\t\t\t{\n\t\t\t\tPath:   \"add.rb\",\n\t\t\t\tRawURL: \"http://example.com/example/example/-/snippets/1/raw/main/add.rb\",\n\t\t\t},\n\t\t},\n\t}\n\n\ts, resp, err := client.ProjectSnippets.CreateSnippet(1, nil, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, s)\n\n\ts, resp, err = client.ProjectSnippets.CreateSnippet(1.01, nil, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.CreateSnippet(1, nil, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.CreateSnippet(2, nil, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, s)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectSnippetsService_UpdateSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"test\",\n\t\t\t  \"file_name\": \"add.rb\",\n\t\t\t  \"description\": \"Ruby test snippet\",\n\t\t\t  \"author\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\"email\": \"venky@example.com\",\n\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\"state\": \"active\"\n\t\t\t  },\n\t\t\t  \"project_id\": 1,\n\t\t\t  \"web_url\": \"http://example.com/example/example/snippets/1\",\n\t\t\t  \"raw_url\": \"http://example.com/example/example/snippets/1/raw\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &Snippet{\n\t\tID:          1,\n\t\tTitle:       \"test\",\n\t\tFileName:    \"add.rb\",\n\t\tDescription: \"Ruby test snippet\",\n\t\tAuthor: struct {\n\t\t\tID        int        `json:\"id\"`\n\t\t\tUsername  string     `json:\"username\"`\n\t\t\tEmail     string     `json:\"email\"`\n\t\t\tName      string     `json:\"name\"`\n\t\t\tState     string     `json:\"state\"`\n\t\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t\t}{\n\t\t\tID:       1,\n\t\t\tUsername: \"venkatesh_thalluri\",\n\t\t\tEmail:    \"venky@example.com\",\n\t\t\tName:     \"Venkatesh Thalluri\",\n\t\t\tState:    \"active\",\n\t\t},\n\t\tProjectID: 1,\n\t\tWebURL:    \"http://example.com/example/example/snippets/1\",\n\t\tRawURL:    \"http://example.com/example/example/snippets/1/raw\",\n\t}\n\n\ts, resp, err := client.ProjectSnippets.UpdateSnippet(1, 1, nil, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, s)\n\n\ts, resp, err = client.ProjectSnippets.UpdateSnippet(1.01, 1, nil, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.UpdateSnippet(1, 1, nil, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.UpdateSnippet(2, 1, nil, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, s)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectSnippetsService_DeleteSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"test\",\n\t\t\t  \"file_name\": \"add.rb\",\n\t\t\t  \"description\": \"Ruby test snippet\",\n\t\t\t  \"author\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"username\": \"venkatesh_thalluri\",\n\t\t\t\t\"email\": \"venky@example.com\",\n\t\t\t\t\"name\": \"Venkatesh Thalluri\",\n\t\t\t\t\"state\": \"active\"\n\t\t\t  },\n\t\t\t  \"project_id\": 1,\n\t\t\t  \"web_url\": \"http://example.com/example/example/snippets/1\",\n\t\t\t  \"raw_url\": \"http://example.com/example/example/snippets/1/raw\"\n\t\t\t}\n\t\t`)\n\t})\n\n\tresp, err := client.ProjectSnippets.DeleteSnippet(1, 1, nil, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.ProjectSnippets.DeleteSnippet(1.01, 1, nil, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectSnippets.DeleteSnippet(1, 1, nil, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectSnippets.DeleteSnippet(2, 1, nil, nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectSnippetsService_SnippetContent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/snippets/1/raw\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, \"{\"+\n\t\t\t\"id: 1,\"+\n\t\t\t\"title: test,\"+\n\t\t\t\"file_name: add.rb,\"+\n\t\t\t\"description: Ruby test snippet,\"+\n\t\t\t\"project_id: 1,\"+\n\t\t\t\"web_url: http://example.com/example/example/snippets/1,\"+\n\t\t\t\"raw_url: http://example.com/example/example/snippets/1/raw}\")\n\t})\n\n\twant := []byte(\"{\" +\n\t\t\"id: 1,\" +\n\t\t\"title: test,\" +\n\t\t\"file_name: add.rb,\" +\n\t\t\"description: Ruby test snippet,\" +\n\t\t\"project_id: 1,\" +\n\t\t\"web_url: http://example.com/example/example/snippets/1,\" +\n\t\t\"raw_url: http://example.com/example/example/snippets/1/raw}\")\n\n\ts, resp, err := client.ProjectSnippets.SnippetContent(1, 1, nil, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, s)\n\n\ts, resp, err = client.ProjectSnippets.SnippetContent(1.01, 1, nil, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.SnippetContent(1, 1, nil, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, s)\n\n\ts, resp, err = client.ProjectSnippets.SnippetContent(2, 1, nil, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, s)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_templates.go",
          "type": "blob",
          "size": 3.3896484375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ProjectTemplatesService handles communication with the project templates\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_templates.html\ntype ProjectTemplatesService struct {\n\tclient *Client\n}\n\n// ProjectTemplate represents a GitLab ProjectTemplate.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_templates.html\ntype ProjectTemplate struct {\n\tKey         string   `json:\"key\"`\n\tName        string   `json:\"name\"`\n\tNickname    string   `json:\"nickname\"`\n\tPopular     bool     `json:\"popular\"`\n\tHTMLURL     string   `json:\"html_url\"`\n\tSourceURL   string   `json:\"source_url\"`\n\tDescription string   `json:\"description\"`\n\tConditions  []string `json:\"conditions\"`\n\tPermissions []string `json:\"permissions\"`\n\tLimitations []string `json:\"limitations\"`\n\tContent     string   `json:\"content\"`\n}\n\nfunc (s ProjectTemplate) String() string {\n\treturn Stringify(s)\n}\n\n// ListProjectTemplatesOptions represents the available ListSnippets() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_templates.html#get-all-templates-of-a-particular-type\ntype ListProjectTemplatesOptions struct {\n\tListOptions\n\tID   *int    `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tType *string `url:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\n// ListTemplates gets a list of project templates.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_templates.html#get-all-templates-of-a-particular-type\nfunc (s *ProjectTemplatesService) ListTemplates(pid interface{}, templateType string, opt *ListProjectTemplatesOptions, options ...RequestOptionFunc) ([]*ProjectTemplate, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/templates/%s\", PathEscape(project), templateType)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pt []*ProjectTemplate\n\tresp, err := s.client.Do(req, &pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// GetProjectTemplate gets a single project template.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_templates.html#get-one-template-of-a-particular-type\nfunc (s *ProjectTemplatesService) GetProjectTemplate(pid interface{}, templateType string, templateName string, options ...RequestOptionFunc) (*ProjectTemplate, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/templates/%s/%s\", PathEscape(project), templateType, templateName)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tptd := new(ProjectTemplate)\n\tresp, err := s.client.Do(req, ptd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ptd, resp, nil\n}\n"
        },
        {
          "name": "project_templates_test.go",
          "type": "blob",
          "size": 1.4345703125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectTemplatesService_ListTemplates(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/templates/issues\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"key\": \"epl-1.0\",\n\t\t\t\t\t\"name\": \"Eclipse Public License 1.0\"\n\t\t\t\t  },\n\t\t\t\t  {\n\t\t\t\t\t\"key\": \"lgpl-3.0\",\n\t\t\t\t\t\"name\": \"GNU Lesser General Public License v3.0\"\n\t\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectTemplate{\n\t\t{\n\t\t\tKey:  \"epl-1.0\",\n\t\t\tName: \"Eclipse Public License 1.0\",\n\t\t},\n\t\t{\n\t\t\tKey:  \"lgpl-3.0\",\n\t\t\tName: \"GNU Lesser General Public License v3.0\",\n\t\t},\n\t}\n\n\tss, resp, err := client.ProjectTemplates.ListTemplates(1, \"issues\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ss)\n}\n\nfunc TestProjectTemplatesService_GetProjectTemplate(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/templates/issues/test_issue\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"name\": \"test_issue\",\n\t\t\t  \"content\": \"## Test\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectTemplate{\n\t\tName:    \"test_issue\",\n\t\tContent: \"## Test\",\n\t}\n\n\tss, resp, err := client.ProjectTemplates.GetProjectTemplate(1, \"issues\", \"test_issue\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, ss)\n}\n"
        },
        {
          "name": "project_variables.go",
          "type": "blob",
          "size": 8.0546875,
          "content": "//\n// Copyright 2021, Patrick Webster\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// ProjectVariablesService handles communication with the\n// project variables related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html\ntype ProjectVariablesService struct {\n\tclient *Client\n}\n\n// ProjectVariable represents a GitLab Project Variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html\ntype ProjectVariable struct {\n\tKey              string            `json:\"key\"`\n\tValue            string            `json:\"value\"`\n\tVariableType     VariableTypeValue `json:\"variable_type\"`\n\tProtected        bool              `json:\"protected\"`\n\tMasked           bool              `json:\"masked\"`\n\tHidden           bool              `json:\"hidden\"`\n\tRaw              bool              `json:\"raw\"`\n\tEnvironmentScope string            `json:\"environment_scope\"`\n\tDescription      string            `json:\"description\"`\n}\n\nfunc (v ProjectVariable) String() string {\n\treturn Stringify(v)\n}\n\n// VariableFilter filters available for project variable related functions\ntype VariableFilter struct {\n\tEnvironmentScope string `url:\"environment_scope, omitempty\" json:\"environment_scope,omitempty\"`\n}\n\n// ListProjectVariablesOptions represents the available options for listing variables\n// in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#list-project-variables\ntype ListProjectVariablesOptions ListOptions\n\n// ListVariables gets a list of all variables in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#list-project-variables\nfunc (s *ProjectVariablesService) ListVariables(pid interface{}, opt *ListProjectVariablesOptions, options ...RequestOptionFunc) ([]*ProjectVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/variables\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar vs []*ProjectVariable\n\tresp, err := s.client.Do(req, &vs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn vs, resp, nil\n}\n\n// GetProjectVariableOptions represents the available GetVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#get-a-single-variable\ntype GetProjectVariableOptions struct {\n\tFilter *VariableFilter `url:\"filter,omitempty\" json:\"filter,omitempty\"`\n}\n\n// GetVariable gets a variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#get-a-single-variable\nfunc (s *ProjectVariablesService) GetVariable(pid interface{}, key string, opt *GetProjectVariableOptions, options ...RequestOptionFunc) (*ProjectVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/variables/%s\", PathEscape(project), url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(ProjectVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// CreateProjectVariableOptions represents the available CreateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#create-a-variable\ntype CreateProjectVariableOptions struct {\n\tKey              *string            `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tValue            *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tDescription      *string            `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tEnvironmentScope *string            `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tMasked           *bool              `url:\"masked,omitempty\" json:\"masked,omitempty\"`\n\tMaskedAndHidden  *bool              `url:\"masked_and_hidden,omitempty\" json:\"masked_and_hidden,omitempty\"`\n\tProtected        *bool              `url:\"protected,omitempty\" json:\"protected,omitempty\"`\n\tRaw              *bool              `url:\"raw,omitempty\" json:\"raw,omitempty\"`\n\tVariableType     *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// CreateVariable creates a new project variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#create-a-variable\nfunc (s *ProjectVariablesService) CreateVariable(pid interface{}, opt *CreateProjectVariableOptions, options ...RequestOptionFunc) (*ProjectVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/variables\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(ProjectVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// UpdateProjectVariableOptions represents the available UpdateVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#update-a-variable\ntype UpdateProjectVariableOptions struct {\n\tValue            *string            `url:\"value,omitempty\" json:\"value,omitempty\"`\n\tDescription      *string            `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tEnvironmentScope *string            `url:\"environment_scope,omitempty\" json:\"environment_scope,omitempty\"`\n\tFilter           *VariableFilter    `url:\"filter,omitempty\" json:\"filter,omitempty\"`\n\tMasked           *bool              `url:\"masked,omitempty\" json:\"masked,omitempty\"`\n\tProtected        *bool              `url:\"protected,omitempty\" json:\"protected,omitempty\"`\n\tRaw              *bool              `url:\"raw,omitempty\" json:\"raw,omitempty\"`\n\tVariableType     *VariableTypeValue `url:\"variable_type,omitempty\" json:\"variable_type,omitempty\"`\n}\n\n// UpdateVariable updates a project's variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#update-a-variable\nfunc (s *ProjectVariablesService) UpdateVariable(pid interface{}, key string, opt *UpdateProjectVariableOptions, options ...RequestOptionFunc) (*ProjectVariable, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/variables/%s\", PathEscape(project), url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(ProjectVariable)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n\n// RemoveProjectVariableOptions represents the available RemoveVariable()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#delete-a-variable\ntype RemoveProjectVariableOptions struct {\n\tFilter *VariableFilter `url:\"filter,omitempty\" json:\"filter,omitempty\"`\n}\n\n// RemoveVariable removes a project's variable.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_level_variables.html#delete-a-variable\nfunc (s *ProjectVariablesService) RemoveVariable(pid interface{}, key string, opt *RemoveProjectVariableOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/variables/%s\", PathEscape(project), url.PathEscape(key))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "project_variables_test.go",
          "type": "blob",
          "size": 10.5361328125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestProjectVariablesService_ListVariables(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\t\"key\": \"TEST_VARIABLE_1\",\n\t\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\t\"value\": \"TEST_1\",\n\t\t\t\t\t\"description\": \"test variable 1\"\n\t\t\t\t}\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*ProjectVariable{{\n\t\tKey:              \"TEST_VARIABLE_1\",\n\t\tValue:            \"TEST_1\",\n\t\tVariableType:     \"env_var\",\n\t\tProtected:        false,\n\t\tMasked:           false,\n\t\tHidden:           false,\n\t\tEnvironmentScope: \"\",\n\t\tDescription:      \"test variable 1\",\n\t}}\n\n\tpvs, resp, err := client.ProjectVariables.ListVariables(1, nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pvs)\n\n\tpvs, resp, err = client.ProjectVariables.ListVariables(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pvs)\n\n\tpvs, resp, err = client.ProjectVariables.ListVariables(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pvs)\n\n\tpvs, resp, err = client.ProjectVariables.ListVariables(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pvs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectVariablesService_GetVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables/TEST_VARIABLE_1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\ttestParams(t, r, \"filter%5Benvironment_scope%5D=prod\")\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"TEST_VARIABLE_1\",\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"value\": \"TEST_1\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"masked\": true,\n\t\t\t\t\"hidden\": true,\n\t\t\t\t\"description\": \"test variable 1\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectVariable{\n\t\tKey:              \"TEST_VARIABLE_1\",\n\t\tValue:            \"TEST_1\",\n\t\tVariableType:     \"env_var\",\n\t\tProtected:        false,\n\t\tMasked:           true,\n\t\tHidden:           true,\n\t\tEnvironmentScope: \"\",\n\t\tDescription:      \"test variable 1\",\n\t}\n\n\tpv, resp, err := client.ProjectVariables.GetVariable(1, \"TEST_VARIABLE_1\", &GetProjectVariableOptions{Filter: &VariableFilter{EnvironmentScope: \"prod\"}}, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pv)\n\n\tpv, resp, err = client.ProjectVariables.GetVariable(1.01, \"TEST_VARIABLE_1\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.GetVariable(1, \"TEST_VARIABLE_1\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.GetVariable(2, \"TEST_VARIABLE_1\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectVariablesService_CreateVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestBody(t, r, `{\"description\":\"new variable\"}`)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"NEW_VARIABLE\",\n\t\t\t\t\"value\": \"new value\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"masked\": false,\n\t\t\t\t\"masked_and_hidden\": false,\n\t\t\t\t\"environment_scope\": \"*\",\n\t\t\t\t\"description\": \"new variable\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectVariable{\n\t\tKey:              \"NEW_VARIABLE\",\n\t\tValue:            \"new value\",\n\t\tVariableType:     \"env_var\",\n\t\tProtected:        false,\n\t\tMasked:           false,\n\t\tHidden:           false,\n\t\tEnvironmentScope: \"*\",\n\t\tDescription:      \"new variable\",\n\t}\n\n\tpv, resp, err := client.ProjectVariables.CreateVariable(1, &CreateProjectVariableOptions{Description: Ptr(\"new variable\")}, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pv)\n\n\tpv, resp, err = client.ProjectVariables.CreateVariable(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.CreateVariable(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.CreateVariable(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectVariablesService_CreateVariable_MaskedAndHidden(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestBody(t, r, `{\"description\":\"new variable\"}`)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"NEW_VARIABLE\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"masked\": true,\n\t\t\t\t\"hidden\": true,\n\t\t\t\t\"environment_scope\": \"*\",\n\t\t\t\t\"description\": \"new variable\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectVariable{\n\t\tKey:              \"NEW_VARIABLE\",\n\t\tVariableType:     \"env_var\",\n\t\tProtected:        false,\n\t\tMasked:           true,\n\t\tHidden:           true,\n\t\tEnvironmentScope: \"*\",\n\t\tDescription:      \"new variable\",\n\t}\n\n\tpv, resp, err := client.ProjectVariables.CreateVariable(1, &CreateProjectVariableOptions{Description: Ptr(\"new variable\")}, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pv)\n\n\tpv, resp, err = client.ProjectVariables.CreateVariable(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.CreateVariable(1, nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.CreateVariable(2, nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectVariablesService_UpdateVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables/NEW_VARIABLE\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\ttestBody(t, r, `{\"description\":\"updated description\",\"filter\":{\"environment_scope\":\"prod\"}}`)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"NEW_VARIABLE\",\n\t\t\t\t\"value\": \"updated value\",\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"masked\": false,\n\t\t\t\t\"environment_scope\": \"*\",\n\t\t\t\t\"description\": \"updated description\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectVariable{\n\t\tKey:              \"NEW_VARIABLE\",\n\t\tValue:            \"updated value\",\n\t\tVariableType:     \"env_var\",\n\t\tProtected:        false,\n\t\tMasked:           false,\n\t\tHidden:           false,\n\t\tEnvironmentScope: \"*\",\n\t\tDescription:      \"updated description\",\n\t}\n\n\tpv, resp, err := client.ProjectVariables.UpdateVariable(1, \"NEW_VARIABLE\", &UpdateProjectVariableOptions{\n\t\tFilter:      &VariableFilter{EnvironmentScope: \"prod\"},\n\t\tDescription: Ptr(\"updated description\"),\n\t}, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pv)\n\n\tpv, resp, err = client.ProjectVariables.UpdateVariable(1.01, \"NEW_VARIABLE\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.UpdateVariable(1, \"NEW_VARIABLE\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.UpdateVariable(2, \"NEW_VARIABLE\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectVariablesService_UpdateVariable_MaskedAndHidden(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables/NEW_VARIABLE\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\ttestBody(t, r, `{\"description\":\"updated description\",\"filter\":{\"environment_scope\":\"prod\"}}`)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"key\": \"NEW_VARIABLE\",\n\t\t\t\t\"value\": null,\n\t\t\t\t\"protected\": false,\n\t\t\t\t\"variable_type\": \"env_var\",\n\t\t\t\t\"masked\": true,\n\t\t\t\t\"hidden\": true,\n\t\t\t\t\"environment_scope\": \"*\",\n\t\t\t\t\"description\": \"updated description\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &ProjectVariable{\n\t\tKey:              \"NEW_VARIABLE\",\n\t\tVariableType:     \"env_var\",\n\t\tProtected:        false,\n\t\tMasked:           true,\n\t\tHidden:           true,\n\t\tEnvironmentScope: \"*\",\n\t\tDescription:      \"updated description\",\n\t}\n\n\tpv, resp, err := client.ProjectVariables.UpdateVariable(1, \"NEW_VARIABLE\", &UpdateProjectVariableOptions{\n\t\tFilter:      &VariableFilter{EnvironmentScope: \"prod\"},\n\t\tDescription: Ptr(\"updated description\"),\n\t}, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, pv)\n\n\tpv, resp, err = client.ProjectVariables.UpdateVariable(1.01, \"NEW_VARIABLE\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.UpdateVariable(1, \"NEW_VARIABLE\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, pv)\n\n\tpv, resp, err = client.ProjectVariables.UpdateVariable(2, \"NEW_VARIABLE\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, pv)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestProjectVariablesService_RemoveVariable(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/variables/VARIABLE_1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\ttestParams(t, r, \"filter%5Benvironment_scope%5D=prod\")\n\t})\n\n\tresp, err := client.ProjectVariables.RemoveVariable(1, \"VARIABLE_1\", &RemoveProjectVariableOptions{Filter: &VariableFilter{EnvironmentScope: \"prod\"}}, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.ProjectVariables.RemoveVariable(1.01, \"VARIABLE_1\", nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectVariables.RemoveVariable(1, \"VARIABLE_1\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.ProjectVariables.RemoveVariable(2, \"VARIABLE_1\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "project_vulnerabilities.go",
          "type": "blob",
          "size": 5.439453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ProjectVulnerabilitiesService handles communication with the projects\n// vulnerabilities related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_vulnerabilities.html\ntype ProjectVulnerabilitiesService struct {\n\tclient *Client\n}\n\n// Project represents a GitLab project vulnerability.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_vulnerabilities.html\ntype ProjectVulnerability struct {\n\tAuthorID                int        `json:\"author_id\"`\n\tConfidence              string     `json:\"confidence\"`\n\tCreatedAt               *time.Time `json:\"created_at\"`\n\tDescription             string     `json:\"description\"`\n\tDismissedAt             *time.Time `json:\"dismissed_at\"`\n\tDismissedByID           int        `json:\"dismissed_by_id\"`\n\tDueDate                 *time.Time `json:\"due_date\"`\n\tFinding                 *Finding   `json:\"finding\"`\n\tID                      int        `json:\"id\"`\n\tLastEditedAt            *time.Time `json:\"last_edited_at\"`\n\tLastEditedByID          int        `json:\"last_edited_by_id\"`\n\tProject                 *Project   `json:\"project\"`\n\tProjectDefaultBranch    string     `json:\"project_default_branch\"`\n\tReportType              string     `json:\"report_type\"`\n\tResolvedAt              *time.Time `json:\"resolved_at\"`\n\tResolvedByID            int        `json:\"resolved_by_id\"`\n\tResolvedOnDefaultBranch bool       `json:\"resolved_on_default_branch\"`\n\tSeverity                string     `json:\"severity\"`\n\tStartDate               *time.Time `json:\"start_date\"`\n\tState                   string     `json:\"state\"`\n\tTitle                   string     `json:\"title\"`\n\tUpdatedAt               *time.Time `json:\"updated_at\"`\n\tUpdatedByID             int        `json:\"updated_by_id\"`\n}\n\n// Project represents a GitLab project vulnerability finding.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/project_vulnerabilities.html\ntype Finding struct {\n\tConfidence          string     `json:\"confidence\"`\n\tCreatedAt           *time.Time `json:\"created_at\"`\n\tID                  int        `json:\"id\"`\n\tLocationFingerprint string     `json:\"location_fingerprint\"`\n\tMetadataVersion     string     `json:\"metadata_version\"`\n\tName                string     `json:\"name\"`\n\tPrimaryIdentifierID int        `json:\"primary_identifier_id\"`\n\tProjectFingerprint  string     `json:\"project_fingerprint\"`\n\tProjectID           int        `json:\"project_id\"`\n\tRawMetadata         string     `json:\"raw_metadata\"`\n\tReportType          string     `json:\"report_type\"`\n\tScannerID           int        `json:\"scanner_id\"`\n\tSeverity            string     `json:\"severity\"`\n\tUpdatedAt           *time.Time `json:\"updated_at\"`\n\tUUID                string     `json:\"uuid\"`\n\tVulnerabilityID     int        `json:\"vulnerability_id\"`\n}\n\n// ListProjectVulnerabilitiesOptions represents the available\n// ListProjectVulnerabilities() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_vulnerabilities.html#list-project-vulnerabilities\ntype ListProjectVulnerabilitiesOptions struct {\n\tListOptions\n}\n\n// ListProjectVulnerabilities gets a list of all project vulnerabilities.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_vulnerabilities.html#list-project-vulnerabilities\nfunc (s *ProjectVulnerabilitiesService) ListProjectVulnerabilities(pid interface{}, opt *ListProjectVulnerabilitiesOptions, options ...RequestOptionFunc) ([]*ProjectVulnerability, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/vulnerabilities\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*ProjectVulnerability\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CreateVulnerabilityOptions represents the available CreateVulnerability()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_vulnerabilities.html#new-vulnerability\ntype CreateVulnerabilityOptions struct {\n\tFindingID *int `url:\"finding_id,omitempty\" json:\"finding_id,omitempty\"`\n}\n\n// CreateVulnerability creates a new vulnerability on the selected project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/project_vulnerabilities.html#new-vulnerability\nfunc (s *ProjectVulnerabilitiesService) CreateVulnerability(pid interface{}, opt *CreateVulnerabilityOptions, options ...RequestOptionFunc) (*ProjectVulnerability, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/vulnerabilities\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(ProjectVulnerability)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n"
        },
        {
          "name": "project_vulnerabilities_test.go",
          "type": "blob",
          "size": 2.115234375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListProjectVulnerabilities(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/vulnerabilities\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectVulnerabilitiesOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t}\n\n\tprojectVulnerabilities, _, err := client.ProjectVulnerabilities.ListProjectVulnerabilities(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectVulnerabilities.ListProjectVulnerabilities returned error: %v\", err)\n\t}\n\n\twant := []*ProjectVulnerability{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projectVulnerabilities) {\n\t\tt.Errorf(\"ProjectVulnerabilities.ListProjectVulnerabilities returned %+v, want %+v\", projectVulnerabilities, want)\n\t}\n}\n\nfunc TestCreateVulnerability(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/vulnerabilities\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\n\topt := &CreateVulnerabilityOptions{\n\t\tFindingID: Ptr(1),\n\t}\n\n\tprojectVulnerability, _, err := client.ProjectVulnerabilities.CreateVulnerability(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"ProjectVulnerabilities.CreateVulnerability returned error: %v\", err)\n\t}\n\n\twant := &ProjectVulnerability{ID: 1}\n\tif !reflect.DeepEqual(want, projectVulnerability) {\n\t\tt.Errorf(\"ProjectVulnerabilities.CreateVulnerability returned %+v, want %+v\", projectVulnerability, want)\n\t}\n}\n"
        },
        {
          "name": "projects.go",
          "type": "blob",
          "size": 112.8974609375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-retryablehttp\"\n)\n\n// ProjectsService handles communication with the repositories related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html\ntype ProjectsService struct {\n\tclient *Client\n}\n\n// Project represents a GitLab project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html\ntype Project struct {\n\tID                                        int                        `json:\"id\"`\n\tDescription                               string                     `json:\"description\"`\n\tDefaultBranch                             string                     `json:\"default_branch\"`\n\tVisibility                                VisibilityValue            `json:\"visibility\"`\n\tSSHURLToRepo                              string                     `json:\"ssh_url_to_repo\"`\n\tHTTPURLToRepo                             string                     `json:\"http_url_to_repo\"`\n\tWebURL                                    string                     `json:\"web_url\"`\n\tReadmeURL                                 string                     `json:\"readme_url\"`\n\tTagList                                   []string                   `json:\"tag_list\"`\n\tTopics                                    []string                   `json:\"topics\"`\n\tOwner                                     *User                      `json:\"owner\"`\n\tName                                      string                     `json:\"name\"`\n\tNameWithNamespace                         string                     `json:\"name_with_namespace\"`\n\tPath                                      string                     `json:\"path\"`\n\tPathWithNamespace                         string                     `json:\"path_with_namespace\"`\n\tIssuesEnabled                             bool                       `json:\"issues_enabled\"`\n\tOpenIssuesCount                           int                        `json:\"open_issues_count\"`\n\tMergeRequestsEnabled                      bool                       `json:\"merge_requests_enabled\"`\n\tApprovalsBeforeMerge                      int                        `json:\"approvals_before_merge\"`\n\tJobsEnabled                               bool                       `json:\"jobs_enabled\"`\n\tWikiEnabled                               bool                       `json:\"wiki_enabled\"`\n\tSnippetsEnabled                           bool                       `json:\"snippets_enabled\"`\n\tResolveOutdatedDiffDiscussions            bool                       `json:\"resolve_outdated_diff_discussions\"`\n\tContainerExpirationPolicy                 *ContainerExpirationPolicy `json:\"container_expiration_policy,omitempty\"`\n\tContainerRegistryEnabled                  bool                       `json:\"container_registry_enabled\"`\n\tContainerRegistryAccessLevel              AccessControlValue         `json:\"container_registry_access_level\"`\n\tContainerRegistryImagePrefix              string                     `json:\"container_registry_image_prefix,omitempty\"`\n\tCreatedAt                                 *time.Time                 `json:\"created_at,omitempty\"`\n\tUpdatedAt                                 *time.Time                 `json:\"updated_at,omitempty\"`\n\tLastActivityAt                            *time.Time                 `json:\"last_activity_at,omitempty\"`\n\tCreatorID                                 int                        `json:\"creator_id\"`\n\tNamespace                                 *ProjectNamespace          `json:\"namespace\"`\n\tPermissions                               *Permissions               `json:\"permissions\"`\n\tMarkedForDeletionAt                       *ISOTime                   `json:\"marked_for_deletion_at\"`\n\tEmptyRepo                                 bool                       `json:\"empty_repo\"`\n\tArchived                                  bool                       `json:\"archived\"`\n\tAvatarURL                                 string                     `json:\"avatar_url\"`\n\tLicenseURL                                string                     `json:\"license_url\"`\n\tLicense                                   *ProjectLicense            `json:\"license\"`\n\tSharedRunnersEnabled                      bool                       `json:\"shared_runners_enabled\"`\n\tGroupRunnersEnabled                       bool                       `json:\"group_runners_enabled\"`\n\tRunnerTokenExpirationInterval             int                        `json:\"runner_token_expiration_interval\"`\n\tForksCount                                int                        `json:\"forks_count\"`\n\tStarCount                                 int                        `json:\"star_count\"`\n\tRunnersToken                              string                     `json:\"runners_token\"`\n\tAllowMergeOnSkippedPipeline               bool                       `json:\"allow_merge_on_skipped_pipeline\"`\n\tAllowPipelineTriggerApproveDeployment     bool                       `json:\"allow_pipeline_trigger_approve_deployment\"`\n\tOnlyAllowMergeIfPipelineSucceeds          bool                       `json:\"only_allow_merge_if_pipeline_succeeds\"`\n\tOnlyAllowMergeIfAllDiscussionsAreResolved bool                       `json:\"only_allow_merge_if_all_discussions_are_resolved\"`\n\tRemoveSourceBranchAfterMerge              bool                       `json:\"remove_source_branch_after_merge\"`\n\tPreventMergeWithoutJiraIssue              bool                       `json:\"prevent_merge_without_jira_issue\"`\n\tPrintingMergeRequestLinkEnabled           bool                       `json:\"printing_merge_request_link_enabled\"`\n\tLFSEnabled                                bool                       `json:\"lfs_enabled\"`\n\tRepositoryStorage                         string                     `json:\"repository_storage\"`\n\tRequestAccessEnabled                      bool                       `json:\"request_access_enabled\"`\n\tMergeMethod                               MergeMethodValue           `json:\"merge_method\"`\n\tCanCreateMergeRequestIn                   bool                       `json:\"can_create_merge_request_in\"`\n\tForkedFromProject                         *ForkParent                `json:\"forked_from_project\"`\n\tMirror                                    bool                       `json:\"mirror\"`\n\tMirrorUserID                              int                        `json:\"mirror_user_id\"`\n\tMirrorTriggerBuilds                       bool                       `json:\"mirror_trigger_builds\"`\n\tOnlyMirrorProtectedBranches               bool                       `json:\"only_mirror_protected_branches\"`\n\tMirrorOverwritesDivergedBranches          bool                       `json:\"mirror_overwrites_diverged_branches\"`\n\tPackagesEnabled                           bool                       `json:\"packages_enabled\"`\n\tServiceDeskEnabled                        bool                       `json:\"service_desk_enabled\"`\n\tServiceDeskAddress                        string                     `json:\"service_desk_address\"`\n\tIssuesAccessLevel                         AccessControlValue         `json:\"issues_access_level\"`\n\tReleasesAccessLevel                       AccessControlValue         `json:\"releases_access_level,omitempty\"`\n\tRepositoryAccessLevel                     AccessControlValue         `json:\"repository_access_level\"`\n\tMergeRequestsAccessLevel                  AccessControlValue         `json:\"merge_requests_access_level\"`\n\tForkingAccessLevel                        AccessControlValue         `json:\"forking_access_level\"`\n\tWikiAccessLevel                           AccessControlValue         `json:\"wiki_access_level\"`\n\tBuildsAccessLevel                         AccessControlValue         `json:\"builds_access_level\"`\n\tSnippetsAccessLevel                       AccessControlValue         `json:\"snippets_access_level\"`\n\tPagesAccessLevel                          AccessControlValue         `json:\"pages_access_level\"`\n\tOperationsAccessLevel                     AccessControlValue         `json:\"operations_access_level\"`\n\tAnalyticsAccessLevel                      AccessControlValue         `json:\"analytics_access_level\"`\n\tEnvironmentsAccessLevel                   AccessControlValue         `json:\"environments_access_level\"`\n\tFeatureFlagsAccessLevel                   AccessControlValue         `json:\"feature_flags_access_level\"`\n\tInfrastructureAccessLevel                 AccessControlValue         `json:\"infrastructure_access_level\"`\n\tMonitorAccessLevel                        AccessControlValue         `json:\"monitor_access_level\"`\n\tAutocloseReferencedIssues                 bool                       `json:\"autoclose_referenced_issues\"`\n\tSuggestionCommitMessage                   string                     `json:\"suggestion_commit_message\"`\n\tSquashOption                              SquashOptionValue          `json:\"squash_option\"`\n\tEnforceAuthChecksOnUploads                bool                       `json:\"enforce_auth_checks_on_uploads,omitempty\"`\n\tSharedWithGroups                          []struct {\n\t\tGroupID          int    `json:\"group_id\"`\n\t\tGroupName        string `json:\"group_name\"`\n\t\tGroupFullPath    string `json:\"group_full_path\"`\n\t\tGroupAccessLevel int    `json:\"group_access_level\"`\n\t} `json:\"shared_with_groups\"`\n\tStatistics                               *Statistics                                 `json:\"statistics\"`\n\tLinks                                    *Links                                      `json:\"_links,omitempty\"`\n\tImportURL                                string                                      `json:\"import_url\"`\n\tImportType                               string                                      `json:\"import_type\"`\n\tImportStatus                             string                                      `json:\"import_status\"`\n\tImportError                              string                                      `json:\"import_error\"`\n\tCIDefaultGitDepth                        int                                         `json:\"ci_default_git_depth\"`\n\tCIForwardDeploymentEnabled               bool                                        `json:\"ci_forward_deployment_enabled\"`\n\tCIForwardDeploymentRollbackAllowed       bool                                        `json:\"ci_forward_deployment_rollback_allowed\"`\n\tCISeperateCache                          bool                                        `json:\"ci_separated_caches\"`\n\tCIJobTokenScopeEnabled                   bool                                        `json:\"ci_job_token_scope_enabled\"`\n\tCIOptInJWT                               bool                                        `json:\"ci_opt_in_jwt\"`\n\tCIAllowForkPipelinesToRunInParentProject bool                                        `json:\"ci_allow_fork_pipelines_to_run_in_parent_project\"`\n\tCIRestrictPipelineCancellationRole       AccessControlValue                          `json:\"ci_restrict_pipeline_cancellation_role\"`\n\tPublicJobs                               bool                                        `json:\"public_jobs\"`\n\tBuildTimeout                             int                                         `json:\"build_timeout\"`\n\tAutoCancelPendingPipelines               string                                      `json:\"auto_cancel_pending_pipelines\"`\n\tCIConfigPath                             string                                      `json:\"ci_config_path\"`\n\tCustomAttributes                         []*CustomAttribute                          `json:\"custom_attributes\"`\n\tComplianceFrameworks                     []string                                    `json:\"compliance_frameworks\"`\n\tBuildCoverageRegex                       string                                      `json:\"build_coverage_regex\"`\n\tIssuesTemplate                           string                                      `json:\"issues_template\"`\n\tMergeRequestsTemplate                    string                                      `json:\"merge_requests_template\"`\n\tIssueBranchTemplate                      string                                      `json:\"issue_branch_template\"`\n\tKeepLatestArtifact                       bool                                        `json:\"keep_latest_artifact\"`\n\tMergePipelinesEnabled                    bool                                        `json:\"merge_pipelines_enabled\"`\n\tMergeTrainsEnabled                       bool                                        `json:\"merge_trains_enabled\"`\n\tRestrictUserDefinedVariables             bool                                        `json:\"restrict_user_defined_variables\"`\n\tCIPipelineVariablesMinimumOverrideRole   CIPipelineVariablesMinimumOverrideRoleValue `json:\"ci_pipeline_variables_minimum_override_role\"`\n\tMergeCommitTemplate                      string                                      `json:\"merge_commit_template\"`\n\tSquashCommitTemplate                     string                                      `json:\"squash_commit_template\"`\n\tAutoDevopsDeployStrategy                 string                                      `json:\"auto_devops_deploy_strategy\"`\n\tAutoDevopsEnabled                        bool                                        `json:\"auto_devops_enabled\"`\n\tBuildGitStrategy                         string                                      `json:\"build_git_strategy\"`\n\tEmailsEnabled                            bool                                        `json:\"emails_enabled\"`\n\tExternalAuthorizationClassificationLabel string                                      `json:\"external_authorization_classification_label\"`\n\tRequirementsEnabled                      bool                                        `json:\"requirements_enabled\"`\n\tRequirementsAccessLevel                  AccessControlValue                          `json:\"requirements_access_level\"`\n\tSecurityAndComplianceEnabled             bool                                        `json:\"security_and_compliance_enabled\"`\n\tSecurityAndComplianceAccessLevel         AccessControlValue                          `json:\"security_and_compliance_access_level\"`\n\tMergeRequestDefaultTargetSelf            bool                                        `json:\"mr_default_target_self\"`\n\tModelExperimentsAccessLevel              AccessControlValue                          `json:\"model_experiments_access_level\"`\n\tModelRegistryAccessLevel                 AccessControlValue                          `json:\"model_registry_access_level\"`\n\tPreReceiveSecretDetectionEnabled         bool                                        `json:\"pre_receive_secret_detection_enabled\"`\n\n\t// Deprecated: Use EmailsEnabled instead\n\tEmailsDisabled bool `json:\"emails_disabled\"`\n\t// Deprecated: This parameter has been renamed to PublicJobs in GitLab 9.0.\n\tPublicBuilds bool `json:\"public_builds\"`\n}\n\n// BasicProject included in other service responses (such as todos).\ntype BasicProject struct {\n\tID                int        `json:\"id\"`\n\tDescription       string     `json:\"description\"`\n\tName              string     `json:\"name\"`\n\tNameWithNamespace string     `json:\"name_with_namespace\"`\n\tPath              string     `json:\"path\"`\n\tPathWithNamespace string     `json:\"path_with_namespace\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n}\n\n// ContainerExpirationPolicy represents the container expiration policy.\ntype ContainerExpirationPolicy struct {\n\tCadence         string     `json:\"cadence\"`\n\tKeepN           int        `json:\"keep_n\"`\n\tOlderThan       string     `json:\"older_than\"`\n\tNameRegex       string     `json:\"name_regex\"`\n\tNameRegexDelete string     `json:\"name_regex_delete\"`\n\tNameRegexKeep   string     `json:\"name_regex_keep\"`\n\tEnabled         bool       `json:\"enabled\"`\n\tNextRunAt       *time.Time `json:\"next_run_at\"`\n}\n\n// ForkParent represents the parent project when this is a fork.\ntype ForkParent struct {\n\tID                int    `json:\"id\"`\n\tName              string `json:\"name\"`\n\tNameWithNamespace string `json:\"name_with_namespace\"`\n\tPath              string `json:\"path\"`\n\tPathWithNamespace string `json:\"path_with_namespace\"`\n\tHTTPURLToRepo     string `json:\"http_url_to_repo\"`\n\tWebURL            string `json:\"web_url\"`\n\tRepositoryStorage string `json:\"repository_storage\"`\n}\n\n// GroupAccess represents group access.\ntype GroupAccess struct {\n\tAccessLevel       AccessLevelValue       `json:\"access_level\"`\n\tNotificationLevel NotificationLevelValue `json:\"notification_level\"`\n}\n\n// Links represents a project web links for self, issues, merge_requests,\n// repo_branches, labels, events, members.\ntype Links struct {\n\tSelf          string `json:\"self\"`\n\tIssues        string `json:\"issues\"`\n\tMergeRequests string `json:\"merge_requests\"`\n\tRepoBranches  string `json:\"repo_branches\"`\n\tLabels        string `json:\"labels\"`\n\tEvents        string `json:\"events\"`\n\tMembers       string `json:\"members\"`\n\tClusterAgents string `json:\"cluster_agents\"`\n}\n\n// Permissions represents permissions.\ntype Permissions struct {\n\tProjectAccess *ProjectAccess `json:\"project_access\"`\n\tGroupAccess   *GroupAccess   `json:\"group_access\"`\n}\n\n// ProjectAccess represents project access.\ntype ProjectAccess struct {\n\tAccessLevel       AccessLevelValue       `json:\"access_level\"`\n\tNotificationLevel NotificationLevelValue `json:\"notification_level\"`\n}\n\n// ProjectLicense represent the license for a project.\ntype ProjectLicense struct {\n\tKey       string `json:\"key\"`\n\tName      string `json:\"name\"`\n\tNickname  string `json:\"nickname\"`\n\tHTMLURL   string `json:\"html_url\"`\n\tSourceURL string `json:\"source_url\"`\n}\n\n// ProjectNamespace represents a project namespace.\ntype ProjectNamespace struct {\n\tID        int    `json:\"id\"`\n\tName      string `json:\"name\"`\n\tPath      string `json:\"path\"`\n\tKind      string `json:\"kind\"`\n\tFullPath  string `json:\"full_path\"`\n\tParentID  int    `json:\"parent_id\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tWebURL    string `json:\"web_url\"`\n}\n\n// Repository represents a repository.\ntype Repository struct {\n\tName              string          `json:\"name\"`\n\tDescription       string          `json:\"description\"`\n\tWebURL            string          `json:\"web_url\"`\n\tAvatarURL         string          `json:\"avatar_url\"`\n\tGitSSHURL         string          `json:\"git_ssh_url\"`\n\tGitHTTPURL        string          `json:\"git_http_url\"`\n\tNamespace         string          `json:\"namespace\"`\n\tVisibility        VisibilityValue `json:\"visibility\"`\n\tPathWithNamespace string          `json:\"path_with_namespace\"`\n\tDefaultBranch     string          `json:\"default_branch\"`\n\tHomepage          string          `json:\"homepage\"`\n\tURL               string          `json:\"url\"`\n\tSSHURL            string          `json:\"ssh_url\"`\n\tHTTPURL           string          `json:\"http_url\"`\n}\n\n// Statistics represents a statistics record for a group or project.\ntype Statistics struct {\n\tCommitCount           int64 `json:\"commit_count\"`\n\tStorageSize           int64 `json:\"storage_size\"`\n\tRepositorySize        int64 `json:\"repository_size\"`\n\tWikiSize              int64 `json:\"wiki_size\"`\n\tLFSObjectsSize        int64 `json:\"lfs_objects_size\"`\n\tJobArtifactsSize      int64 `json:\"job_artifacts_size\"`\n\tPipelineArtifactsSize int64 `json:\"pipeline_artifacts_size\"`\n\tPackagesSize          int64 `json:\"packages_size\"`\n\tSnippetsSize          int64 `json:\"snippets_size\"`\n\tUploadsSize           int64 `json:\"uploads_size\"`\n\tContainerRegistrySize int64 `json:\"container_registry_size\"`\n}\n\nfunc (s Project) String() string {\n\treturn Stringify(s)\n}\n\n// ProjectApprovalRule represents a GitLab project approval rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-project-level-rules\ntype ProjectApprovalRule struct {\n\tID                            int                `json:\"id\"`\n\tName                          string             `json:\"name\"`\n\tRuleType                      string             `json:\"rule_type\"`\n\tReportType                    string             `json:\"report_type\"`\n\tEligibleApprovers             []*BasicUser       `json:\"eligible_approvers\"`\n\tApprovalsRequired             int                `json:\"approvals_required\"`\n\tUsers                         []*BasicUser       `json:\"users\"`\n\tGroups                        []*Group           `json:\"groups\"`\n\tContainsHiddenGroups          bool               `json:\"contains_hidden_groups\"`\n\tProtectedBranches             []*ProtectedBranch `json:\"protected_branches\"`\n\tAppliesToAllProtectedBranches bool               `json:\"applies_to_all_protected_branches\"`\n}\n\nfunc (s ProjectApprovalRule) String() string {\n\treturn Stringify(s)\n}\n\n// ListProjectsOptions represents the available ListProjects() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#list-all-projects\ntype ListProjectsOptions struct {\n\tListOptions\n\tArchived                 *bool             `url:\"archived,omitempty\" json:\"archived,omitempty\"`\n\tIDAfter                  *int              `url:\"id_after,omitempty\" json:\"id_after,omitempty\"`\n\tIDBefore                 *int              `url:\"id_before,omitempty\" json:\"id_before,omitempty\"`\n\tImported                 *bool             `url:\"imported,omitempty\" json:\"imported,omitempty\"`\n\tIncludeHidden            *bool             `url:\"include_hidden,omitempty\" json:\"include_hidden,omitempty\"`\n\tIncludePendingDelete     *bool             `url:\"include_pending_delete,omitempty\" json:\"include_pending_delete,omitempty\"`\n\tLastActivityAfter        *time.Time        `url:\"last_activity_after,omitempty\" json:\"last_activity_after,omitempty\"`\n\tLastActivityBefore       *time.Time        `url:\"last_activity_before,omitempty\" json:\"last_activity_before,omitempty\"`\n\tMembership               *bool             `url:\"membership,omitempty\" json:\"membership,omitempty\"`\n\tMinAccessLevel           *AccessLevelValue `url:\"min_access_level,omitempty\" json:\"min_access_level,omitempty\"`\n\tOrderBy                  *string           `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tOwned                    *bool             `url:\"owned,omitempty\" json:\"owned,omitempty\"`\n\tRepositoryChecksumFailed *bool             `url:\"repository_checksum_failed,omitempty\" json:\"repository_checksum_failed,omitempty\"`\n\tRepositoryStorage        *string           `url:\"repository_storage,omitempty\" json:\"repository_storage,omitempty\"`\n\tSearch                   *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tSearchNamespaces         *bool             `url:\"search_namespaces,omitempty\" json:\"search_namespaces,omitempty\"`\n\tSimple                   *bool             `url:\"simple,omitempty\" json:\"simple,omitempty\"`\n\tSort                     *string           `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tStarred                  *bool             `url:\"starred,omitempty\" json:\"starred,omitempty\"`\n\tStatistics               *bool             `url:\"statistics,omitempty\" json:\"statistics,omitempty\"`\n\tTopic                    *string           `url:\"topic,omitempty\" json:\"topic,omitempty\"`\n\tVisibility               *VisibilityValue  `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tWikiChecksumFailed       *bool             `url:\"wiki_checksum_failed,omitempty\" json:\"wiki_checksum_failed,omitempty\"`\n\tWithCustomAttributes     *bool             `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n\tWithIssuesEnabled        *bool             `url:\"with_issues_enabled,omitempty\" json:\"with_issues_enabled,omitempty\"`\n\tWithMergeRequestsEnabled *bool             `url:\"with_merge_requests_enabled,omitempty\" json:\"with_merge_requests_enabled,omitempty\"`\n\tWithProgrammingLanguage  *string           `url:\"with_programming_language,omitempty\" json:\"with_programming_language,omitempty\"`\n}\n\n// ListProjects gets a list of projects accessible by the authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#list-all-projects\nfunc (s *ProjectsService) ListProjects(opt *ListProjectsOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"projects\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*Project\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ListUserProjects gets a list of projects for the given user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-user-projects\nfunc (s *ProjectsService) ListUserProjects(uid interface{}, opt *ListProjectsOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tuser, err := parseID(uid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"users/%s/projects\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*Project\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ListUserContributedProjects gets a list of visible projects a given user has contributed to.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-projects-a-user-has-contributed-to\nfunc (s *ProjectsService) ListUserContributedProjects(uid interface{}, opt *ListProjectsOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tuser, err := parseID(uid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"users/%s/contributed_projects\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*Project\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ListUserStarredProjects gets a list of projects starred by the given user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-projects-starred-by-a-user\nfunc (s *ProjectsService) ListUserStarredProjects(uid interface{}, opt *ListProjectsOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tuser, err := parseID(uid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"users/%s/starred_projects\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*Project\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ProjectUser represents a GitLab project user.\ntype ProjectUser struct {\n\tID        int    `json:\"id\"`\n\tName      string `json:\"name\"`\n\tUsername  string `json:\"username\"`\n\tState     string `json:\"state\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tWebURL    string `json:\"web_url\"`\n}\n\n// ListProjectUserOptions represents the available ListProjectsUsers() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#get-project-users\ntype ListProjectUserOptions struct {\n\tListOptions\n\tSearch *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n}\n\n// ListProjectsUsers gets a list of users for the given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-project-users\nfunc (s *ProjectsService) ListProjectsUsers(pid interface{}, opt *ListProjectUserOptions, options ...RequestOptionFunc) ([]*ProjectUser, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/users\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*ProjectUser\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ProjectGroup represents a GitLab project group.\ntype ProjectGroup struct {\n\tID        int    `json:\"id\"`\n\tName      string `json:\"name\"`\n\tAvatarURL string `json:\"avatar_url\"`\n\tWebURL    string `json:\"web_url\"`\n\tFullName  string `json:\"full_name\"`\n\tFullPath  string `json:\"full_path\"`\n}\n\n// ListProjectGroupOptions represents the available ListProjectsGroups() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#list-a-projects-groups\ntype ListProjectGroupOptions struct {\n\tListOptions\n\tSearch               *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tSharedMinAccessLevel *AccessLevelValue `url:\"shared_min_access_level,omitempty\" json:\"shared_min_access_level,omitempty\"`\n\tSharedVisiableOnly   *bool             `url:\"shared_visible_only,omitempty\" json:\"shared_visible_only,omitempty\"`\n\tSkipGroups           *[]int            `url:\"skip_groups,omitempty\" json:\"skip_groups,omitempty\"`\n\tWithShared           *bool             `url:\"with_shared,omitempty\" json:\"with_shared,omitempty\"`\n}\n\n// ListProjectsGroups gets a list of groups for the given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-a-projects-groups\nfunc (s *ProjectsService) ListProjectsGroups(pid interface{}, opt *ListProjectGroupOptions, options ...RequestOptionFunc) ([]*ProjectGroup, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/groups\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*ProjectGroup\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ProjectLanguages is a map of strings because the response is arbitrary\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/projects.html#languages\ntype ProjectLanguages map[string]float32\n\n// GetProjectLanguages gets a list of languages used by the project\n//\n// GitLab API docs:  https://docs.gitlab.com/ee/api/projects.html#languages\nfunc (s *ProjectsService) GetProjectLanguages(pid interface{}, options ...RequestOptionFunc) (*ProjectLanguages, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/languages\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(ProjectLanguages)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetProjectOptions represents the available GetProject() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#get-single-project\ntype GetProjectOptions struct {\n\tLicense              *bool `url:\"license,omitempty\" json:\"license,omitempty\"`\n\tStatistics           *bool `url:\"statistics,omitempty\" json:\"statistics,omitempty\"`\n\tWithCustomAttributes *bool `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n}\n\n// GetProject gets a specific project, identified by project ID or\n// NAMESPACE/PROJECT_NAME, which is owned by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-single-project\nfunc (s *ProjectsService) GetProject(pid interface{}, opt *GetProjectOptions, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CreateProjectOptions represents the available CreateProject() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#create-project\ntype CreateProjectOptions struct {\n\tAllowMergeOnSkippedPipeline               *bool                                `url:\"allow_merge_on_skipped_pipeline,omitempty\" json:\"allow_merge_on_skipped_pipeline,omitempty\"`\n\tOnlyAllowMergeIfAllStatusChecksPassed     *bool                                `url:\"only_allow_merge_if_all_status_checks_passed,omitempty\" json:\"only_allow_merge_if_all_status_checks_passed,omitempty\"`\n\tAnalyticsAccessLevel                      *AccessControlValue                  `url:\"analytics_access_level,omitempty\" json:\"analytics_access_level,omitempty\"`\n\tApprovalsBeforeMerge                      *int                                 `url:\"approvals_before_merge,omitempty\" json:\"approvals_before_merge,omitempty\"`\n\tAutoCancelPendingPipelines                *string                              `url:\"auto_cancel_pending_pipelines,omitempty\" json:\"auto_cancel_pending_pipelines,omitempty\"`\n\tAutoDevopsDeployStrategy                  *string                              `url:\"auto_devops_deploy_strategy,omitempty\" json:\"auto_devops_deploy_strategy,omitempty\"`\n\tAutoDevopsEnabled                         *bool                                `url:\"auto_devops_enabled,omitempty\" json:\"auto_devops_enabled,omitempty\"`\n\tAutocloseReferencedIssues                 *bool                                `url:\"autoclose_referenced_issues,omitempty\" json:\"autoclose_referenced_issues,omitempty\"`\n\tAvatar                                    *ProjectAvatar                       `url:\"-\" json:\"-\"`\n\tBuildCoverageRegex                        *string                              `url:\"build_coverage_regex,omitempty\" json:\"build_coverage_regex,omitempty\"`\n\tBuildGitStrategy                          *string                              `url:\"build_git_strategy,omitempty\" json:\"build_git_strategy,omitempty\"`\n\tBuildTimeout                              *int                                 `url:\"build_timeout,omitempty\" json:\"build_timeout,omitempty\"`\n\tBuildsAccessLevel                         *AccessControlValue                  `url:\"builds_access_level,omitempty\" json:\"builds_access_level,omitempty\"`\n\tCIConfigPath                              *string                              `url:\"ci_config_path,omitempty\" json:\"ci_config_path,omitempty\"`\n\tContainerExpirationPolicyAttributes       *ContainerExpirationPolicyAttributes `url:\"container_expiration_policy_attributes,omitempty\" json:\"container_expiration_policy_attributes,omitempty\"`\n\tContainerRegistryAccessLevel              *AccessControlValue                  `url:\"container_registry_access_level,omitempty\" json:\"container_registry_access_level,omitempty\"`\n\tDefaultBranch                             *string                              `url:\"default_branch,omitempty\" json:\"default_branch,omitempty\"`\n\tDescription                               *string                              `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tEmailsEnabled                             *bool                                `url:\"emails_enabled,omitempty\" json:\"emails_enabled,omitempty\"`\n\tEnforceAuthChecksOnUploads                *bool                                `url:\"enforce_auth_checks_on_uploads,omitempty\" json:\"enforce_auth_checks_on_uploads,omitempty\"`\n\tExternalAuthorizationClassificationLabel  *string                              `url:\"external_authorization_classification_label,omitempty\" json:\"external_authorization_classification_label,omitempty\"`\n\tForkingAccessLevel                        *AccessControlValue                  `url:\"forking_access_level,omitempty\" json:\"forking_access_level,omitempty\"`\n\tGroupWithProjectTemplatesID               *int                                 `url:\"group_with_project_templates_id,omitempty\" json:\"group_with_project_templates_id,omitempty\"`\n\tImportURL                                 *string                              `url:\"import_url,omitempty\" json:\"import_url,omitempty\"`\n\tInitializeWithReadme                      *bool                                `url:\"initialize_with_readme,omitempty\" json:\"initialize_with_readme,omitempty\"`\n\tIssuesAccessLevel                         *AccessControlValue                  `url:\"issues_access_level,omitempty\" json:\"issues_access_level,omitempty\"`\n\tIssueBranchTemplate                       *string                              `url:\"issue_branch_template,omitempty\" json:\"issue_branch_template,omitempty\"`\n\tLFSEnabled                                *bool                                `url:\"lfs_enabled,omitempty\" json:\"lfs_enabled,omitempty\"`\n\tMergeCommitTemplate                       *string                              `url:\"merge_commit_template,omitempty\" json:\"merge_commit_template,omitempty\"`\n\tMergeMethod                               *MergeMethodValue                    `url:\"merge_method,omitempty\" json:\"merge_method,omitempty\"`\n\tMergePipelinesEnabled                     *bool                                `url:\"merge_pipelines_enabled,omitempty\" json:\"merge_pipelines_enabled,omitempty\"`\n\tMergeRequestsAccessLevel                  *AccessControlValue                  `url:\"merge_requests_access_level,omitempty\" json:\"merge_requests_access_level,omitempty\"`\n\tMergeTrainsEnabled                        *bool                                `url:\"merge_trains_enabled,omitempty\" json:\"merge_trains_enabled,omitempty\"`\n\tMirror                                    *bool                                `url:\"mirror,omitempty\" json:\"mirror,omitempty\"`\n\tMirrorTriggerBuilds                       *bool                                `url:\"mirror_trigger_builds,omitempty\" json:\"mirror_trigger_builds,omitempty\"`\n\tModelExperimentsAccessLevel               *AccessControlValue                  `url:\"model_experiments_access_level,omitempty\" json:\"model_experiments_access_level,omitempty\"`\n\tModelRegistryAccessLevel                  *AccessControlValue                  `url:\"model_registry_access_level,omitempty\" json:\"model_registry_access_level,omitempty\"`\n\tName                                      *string                              `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tNamespaceID                               *int                                 `url:\"namespace_id,omitempty\" json:\"namespace_id,omitempty\"`\n\tOnlyAllowMergeIfAllDiscussionsAreResolved *bool                                `url:\"only_allow_merge_if_all_discussions_are_resolved,omitempty\" json:\"only_allow_merge_if_all_discussions_are_resolved,omitempty\"`\n\tOnlyAllowMergeIfPipelineSucceeds          *bool                                `url:\"only_allow_merge_if_pipeline_succeeds,omitempty\" json:\"only_allow_merge_if_pipeline_succeeds,omitempty\"`\n\tOperationsAccessLevel                     *AccessControlValue                  `url:\"operations_access_level,omitempty\" json:\"operations_access_level,omitempty\"`\n\tPackagesEnabled                           *bool                                `url:\"packages_enabled,omitempty\" json:\"packages_enabled,omitempty\"`\n\tPagesAccessLevel                          *AccessControlValue                  `url:\"pages_access_level,omitempty\" json:\"pages_access_level,omitempty\"`\n\tPath                                      *string                              `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tPublicBuilds                              *bool                                `url:\"public_builds,omitempty\" json:\"public_builds,omitempty\"`\n\tReleasesAccessLevel                       *AccessControlValue                  `url:\"releases_access_level,omitempty\" json:\"releases_access_level,omitempty\"`\n\tEnvironmentsAccessLevel                   *AccessControlValue                  `url:\"environments_access_level,omitempty\" json:\"environments_access_level,omitempty\"`\n\tFeatureFlagsAccessLevel                   *AccessControlValue                  `url:\"feature_flags_access_level,omitempty\" json:\"feature_flags_access_level,omitempty\"`\n\tInfrastructureAccessLevel                 *AccessControlValue                  `url:\"infrastructure_access_level,omitempty\" json:\"infrastructure_access_level,omitempty\"`\n\tMonitorAccessLevel                        *AccessControlValue                  `url:\"monitor_access_level,omitempty\" json:\"monitor_access_level,omitempty\"`\n\tRemoveSourceBranchAfterMerge              *bool                                `url:\"remove_source_branch_after_merge,omitempty\" json:\"remove_source_branch_after_merge,omitempty\"`\n\tPrintingMergeRequestLinkEnabled           *bool                                `url:\"printing_merge_request_link_enabled,omitempty\" json:\"printing_merge_request_link_enabled,omitempty\"`\n\tRepositoryAccessLevel                     *AccessControlValue                  `url:\"repository_access_level,omitempty\" json:\"repository_access_level,omitempty\"`\n\tRepositoryStorage                         *string                              `url:\"repository_storage,omitempty\" json:\"repository_storage,omitempty\"`\n\tRequestAccessEnabled                      *bool                                `url:\"request_access_enabled,omitempty\" json:\"request_access_enabled,omitempty\"`\n\tRequirementsAccessLevel                   *AccessControlValue                  `url:\"requirements_access_level,omitempty\" json:\"requirements_access_level,omitempty\"`\n\tResolveOutdatedDiffDiscussions            *bool                                `url:\"resolve_outdated_diff_discussions,omitempty\" json:\"resolve_outdated_diff_discussions,omitempty\"`\n\tSecurityAndComplianceAccessLevel          *AccessControlValue                  `url:\"security_and_compliance_access_level,omitempty\" json:\"security_and_compliance_access_level,omitempty\"`\n\tSharedRunnersEnabled                      *bool                                `url:\"shared_runners_enabled,omitempty\" json:\"shared_runners_enabled,omitempty\"`\n\tGroupRunnersEnabled                       *bool                                `url:\"group_runners_enabled,omitempty\" json:\"group_runners_enabled,omitempty\"`\n\tShowDefaultAwardEmojis                    *bool                                `url:\"show_default_award_emojis,omitempty\" json:\"show_default_award_emojis,omitempty\"`\n\tSnippetsAccessLevel                       *AccessControlValue                  `url:\"snippets_access_level,omitempty\" json:\"snippets_access_level,omitempty\"`\n\tSquashCommitTemplate                      *string                              `url:\"squash_commit_template,omitempty\" json:\"squash_commit_template,omitempty\"`\n\tSquashOption                              *SquashOptionValue                   `url:\"squash_option,omitempty\" json:\"squash_option,omitempty\"`\n\tSuggestionCommitMessage                   *string                              `url:\"suggestion_commit_message,omitempty\" json:\"suggestion_commit_message,omitempty\"`\n\tTemplateName                              *string                              `url:\"template_name,omitempty\" json:\"template_name,omitempty\"`\n\tTemplateProjectID                         *int                                 `url:\"template_project_id,omitempty\" json:\"template_project_id,omitempty\"`\n\tTopics                                    *[]string                            `url:\"topics,omitempty\" json:\"topics,omitempty\"`\n\tUseCustomTemplate                         *bool                                `url:\"use_custom_template,omitempty\" json:\"use_custom_template,omitempty\"`\n\tVisibility                                *VisibilityValue                     `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tWikiAccessLevel                           *AccessControlValue                  `url:\"wiki_access_level,omitempty\" json:\"wiki_access_level,omitempty\"`\n\n\t// Deprecated: No longer supported in recent versions.\n\tCIForwardDeploymentEnabled *bool `url:\"ci_forward_deployment_enabled,omitempty\" json:\"ci_forward_deployment_enabled,omitempty\"`\n\t// Deprecated: Use ContainerRegistryAccessLevel instead.\n\tContainerRegistryEnabled *bool `url:\"container_registry_enabled,omitempty\" json:\"container_registry_enabled,omitempty\"`\n\t// Deprecated: Use EmailsEnabled instead\n\tEmailsDisabled *bool `url:\"emails_disabled,omitempty\" json:\"emails_disabled,omitempty\"`\n\t// Deprecated: Use IssuesAccessLevel instead.\n\tIssuesEnabled *bool `url:\"issues_enabled,omitempty\" json:\"issues_enabled,omitempty\"`\n\t// Deprecated: No longer supported in recent versions.\n\tIssuesTemplate *string `url:\"issues_template,omitempty\" json:\"issues_template,omitempty\"`\n\t// Deprecated: Use BuildsAccessLevel instead.\n\tJobsEnabled *bool `url:\"jobs_enabled,omitempty\" json:\"jobs_enabled,omitempty\"`\n\t// Deprecated: Use MergeRequestsAccessLevel instead.\n\tMergeRequestsEnabled *bool `url:\"merge_requests_enabled,omitempty\" json:\"merge_requests_enabled,omitempty\"`\n\t// Deprecated: No longer supported in recent versions.\n\tMergeRequestsTemplate *string `url:\"merge_requests_template,omitempty\" json:\"merge_requests_template,omitempty\"`\n\t// Deprecated: No longer supported in recent versions.\n\tServiceDeskEnabled *bool `url:\"service_desk_enabled,omitempty\" json:\"service_desk_enabled,omitempty\"`\n\t// Deprecated: Use SnippetsAccessLevel instead.\n\tSnippetsEnabled *bool `url:\"snippets_enabled,omitempty\" json:\"snippets_enabled,omitempty\"`\n\t// Deprecated: Use Topics instead. (Deprecated in GitLab 14.0)\n\tTagList *[]string `url:\"tag_list,omitempty\" json:\"tag_list,omitempty\"`\n\t// Deprecated: Use WikiAccessLevel instead.\n\tWikiEnabled *bool `url:\"wiki_enabled,omitempty\" json:\"wiki_enabled,omitempty\"`\n}\n\n// ContainerExpirationPolicyAttributes represents the available container\n// expiration policy attributes.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#create-project\ntype ContainerExpirationPolicyAttributes struct {\n\tCadence         *string `url:\"cadence,omitempty\" json:\"cadence,omitempty\"`\n\tKeepN           *int    `url:\"keep_n,omitempty\" json:\"keep_n,omitempty\"`\n\tOlderThan       *string `url:\"older_than,omitempty\" json:\"older_than,omitempty\"`\n\tNameRegexDelete *string `url:\"name_regex_delete,omitempty\" json:\"name_regex_delete,omitempty\"`\n\tNameRegexKeep   *string `url:\"name_regex_keep,omitempty\" json:\"name_regex_keep,omitempty\"`\n\tEnabled         *bool   `url:\"enabled,omitempty\" json:\"enabled,omitempty\"`\n\n\t// Deprecated: Is replaced by NameRegexDelete and is internally hardwired to its value.\n\tNameRegex *string `url:\"name_regex,omitempty\" json:\"name_regex,omitempty\"`\n}\n\n// ProjectAvatar represents a GitLab project avatar.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#create-project\ntype ProjectAvatar struct {\n\tFilename string\n\tImage    io.Reader\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a *ProjectAvatar) MarshalJSON() ([]byte, error) {\n\tif a.Filename == \"\" && a.Image == nil {\n\t\treturn []byte(`\"\"`), nil\n\t}\n\ttype alias ProjectAvatar\n\treturn json.Marshal((*alias)(a))\n}\n\n// CreateProject creates a new project owned by the authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#create-project\nfunc (s *ProjectsService) CreateProject(opt *CreateProjectOptions, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tif opt.ContainerExpirationPolicyAttributes != nil {\n\t\t// This is needed to satisfy the API. Should be deleted\n\t\t// when NameRegex is removed (it's now deprecated).\n\t\topt.ContainerExpirationPolicyAttributes.NameRegex = opt.ContainerExpirationPolicyAttributes.NameRegexDelete\n\t}\n\n\tvar err error\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil {\n\t\treq, err = s.client.NewRequest(http.MethodPost, \"projects\", opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPost,\n\t\t\t\"projects\",\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// CreateProjectForUserOptions represents the available CreateProjectForUser()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#create-project-for-user\ntype CreateProjectForUserOptions CreateProjectOptions\n\n// CreateProjectForUser creates a new project owned by the specified user.\n// Available only for admins.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#create-project-for-user\nfunc (s *ProjectsService) CreateProjectForUser(user int, opt *CreateProjectForUserOptions, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tif opt.ContainerExpirationPolicyAttributes != nil {\n\t\t// This is needed to satisfy the API. Should be deleted\n\t\t// when NameRegex is removed (it's now deprecated).\n\t\topt.ContainerExpirationPolicyAttributes.NameRegex = opt.ContainerExpirationPolicyAttributes.NameRegexDelete\n\t}\n\n\tvar err error\n\tvar req *retryablehttp.Request\n\tu := fmt.Sprintf(\"projects/user/%d\", user)\n\n\tif opt.Avatar == nil {\n\t\treq, err = s.client.NewRequest(http.MethodPost, u, opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPost,\n\t\t\tu,\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// EditProjectOptions represents the available EditProject() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#edit-project\ntype EditProjectOptions struct {\n\tAllowMergeOnSkippedPipeline               *bool                                        `url:\"allow_merge_on_skipped_pipeline,omitempty\" json:\"allow_merge_on_skipped_pipeline,omitempty\"`\n\tAllowPipelineTriggerApproveDeployment     *bool                                        `url:\"allow_pipeline_trigger_approve_deployment,omitempty\" json:\"allow_pipeline_trigger_approve_deployment,omitempty\"`\n\tOnlyAllowMergeIfAllStatusChecksPassed     *bool                                        `url:\"only_allow_merge_if_all_status_checks_passed,omitempty\" json:\"only_allow_merge_if_all_status_checks_passed,omitempty\"`\n\tAnalyticsAccessLevel                      *AccessControlValue                          `url:\"analytics_access_level,omitempty\" json:\"analytics_access_level,omitempty\"`\n\tApprovalsBeforeMerge                      *int                                         `url:\"approvals_before_merge,omitempty\" json:\"approvals_before_merge,omitempty\"`\n\tAutoCancelPendingPipelines                *string                                      `url:\"auto_cancel_pending_pipelines,omitempty\" json:\"auto_cancel_pending_pipelines,omitempty\"`\n\tAutoDevopsDeployStrategy                  *string                                      `url:\"auto_devops_deploy_strategy,omitempty\" json:\"auto_devops_deploy_strategy,omitempty\"`\n\tAutoDevopsEnabled                         *bool                                        `url:\"auto_devops_enabled,omitempty\" json:\"auto_devops_enabled,omitempty\"`\n\tAutocloseReferencedIssues                 *bool                                        `url:\"autoclose_referenced_issues,omitempty\" json:\"autoclose_referenced_issues,omitempty\"`\n\tAvatar                                    *ProjectAvatar                               `url:\"-\" json:\"avatar,omitempty\"`\n\tBuildCoverageRegex                        *string                                      `url:\"build_coverage_regex,omitempty\" json:\"build_coverage_regex,omitempty\"`\n\tBuildGitStrategy                          *string                                      `url:\"build_git_strategy,omitempty\" json:\"build_git_strategy,omitempty\"`\n\tBuildTimeout                              *int                                         `url:\"build_timeout,omitempty\" json:\"build_timeout,omitempty\"`\n\tBuildsAccessLevel                         *AccessControlValue                          `url:\"builds_access_level,omitempty\" json:\"builds_access_level,omitempty\"`\n\tCIConfigPath                              *string                                      `url:\"ci_config_path,omitempty\" json:\"ci_config_path,omitempty\"`\n\tCIDefaultGitDepth                         *int                                         `url:\"ci_default_git_depth,omitempty\" json:\"ci_default_git_depth,omitempty\"`\n\tCIForwardDeploymentEnabled                *bool                                        `url:\"ci_forward_deployment_enabled,omitempty\" json:\"ci_forward_deployment_enabled,omitempty\"`\n\tCIForwardDeploymentRollbackAllowed        *bool                                        `url:\"ci_forward_deployment_rollback_allowed,omitempty\" json:\"ci_forward_deployment_rollback_allowed,omitempty\"`\n\tCISeperateCache                           *bool                                        `url:\"ci_separated_caches,omitempty\" json:\"ci_separated_caches,omitempty\"`\n\tCIRestrictPipelineCancellationRole        *AccessControlValue                          `url:\"ci_restrict_pipeline_cancellation_role,omitempty\" json:\"ci_restrict_pipeline_cancellation_role,omitempty\"`\n\tCIPipelineVariablesMinimumOverrideRole    *CIPipelineVariablesMinimumOverrideRoleValue `url:\"ci_pipeline_variables_minimum_override_role,omitempty\" json:\"ci_pipeline_variables_minimum_override_role,omitempty\"`\n\tContainerExpirationPolicyAttributes       *ContainerExpirationPolicyAttributes         `url:\"container_expiration_policy_attributes,omitempty\" json:\"container_expiration_policy_attributes,omitempty\"`\n\tContainerRegistryAccessLevel              *AccessControlValue                          `url:\"container_registry_access_level,omitempty\" json:\"container_registry_access_level,omitempty\"`\n\tDefaultBranch                             *string                                      `url:\"default_branch,omitempty\" json:\"default_branch,omitempty\"`\n\tDescription                               *string                                      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tEmailsEnabled                             *bool                                        `url:\"emails_enabled,omitempty\" json:\"emails_enabled,omitempty\"`\n\tEnforceAuthChecksOnUploads                *bool                                        `url:\"enforce_auth_checks_on_uploads,omitempty\" json:\"enforce_auth_checks_on_uploads,omitempty\"`\n\tExternalAuthorizationClassificationLabel  *string                                      `url:\"external_authorization_classification_label,omitempty\" json:\"external_authorization_classification_label,omitempty\"`\n\tForkingAccessLevel                        *AccessControlValue                          `url:\"forking_access_level,omitempty\" json:\"forking_access_level,omitempty\"`\n\tImportURL                                 *string                                      `url:\"import_url,omitempty\" json:\"import_url,omitempty\"`\n\tIssuesAccessLevel                         *AccessControlValue                          `url:\"issues_access_level,omitempty\" json:\"issues_access_level,omitempty\"`\n\tIssueBranchTemplate                       *string                                      `url:\"issue_branch_template,omitempty\" json:\"issue_branch_template,omitempty\"`\n\tIssuesTemplate                            *string                                      `url:\"issues_template,omitempty\" json:\"issues_template,omitempty\"`\n\tKeepLatestArtifact                        *bool                                        `url:\"keep_latest_artifact,omitempty\" json:\"keep_latest_artifact,omitempty\"`\n\tLFSEnabled                                *bool                                        `url:\"lfs_enabled,omitempty\" json:\"lfs_enabled,omitempty\"`\n\tMergeCommitTemplate                       *string                                      `url:\"merge_commit_template,omitempty\" json:\"merge_commit_template,omitempty\"`\n\tMergeRequestDefaultTargetSelf             *bool                                        `url:\"mr_default_target_self,omitempty\" json:\"mr_default_target_self,omitempty\"`\n\tMergeMethod                               *MergeMethodValue                            `url:\"merge_method,omitempty\" json:\"merge_method,omitempty\"`\n\tMergePipelinesEnabled                     *bool                                        `url:\"merge_pipelines_enabled,omitempty\" json:\"merge_pipelines_enabled,omitempty\"`\n\tMergeRequestsAccessLevel                  *AccessControlValue                          `url:\"merge_requests_access_level,omitempty\" json:\"merge_requests_access_level,omitempty\"`\n\tMergeRequestsTemplate                     *string                                      `url:\"merge_requests_template,omitempty\" json:\"merge_requests_template,omitempty\"`\n\tMergeTrainsEnabled                        *bool                                        `url:\"merge_trains_enabled,omitempty\" json:\"merge_trains_enabled,omitempty\"`\n\tMirror                                    *bool                                        `url:\"mirror,omitempty\" json:\"mirror,omitempty\"`\n\tMirrorBranchRegex                         *string                                      `url:\"mirror_branch_regex,omitempty\" json:\"mirror_branch_regex,omitempty\"`\n\tMirrorOverwritesDivergedBranches          *bool                                        `url:\"mirror_overwrites_diverged_branches,omitempty\" json:\"mirror_overwrites_diverged_branches,omitempty\"`\n\tMirrorTriggerBuilds                       *bool                                        `url:\"mirror_trigger_builds,omitempty\" json:\"mirror_trigger_builds,omitempty\"`\n\tMirrorUserID                              *int                                         `url:\"mirror_user_id,omitempty\" json:\"mirror_user_id,omitempty\"`\n\tModelExperimentsAccessLevel               *AccessControlValue                          `url:\"model_experiments_access_level,omitempty\" json:\"model_experiments_access_level,omitempty\"`\n\tModelRegistryAccessLevel                  *AccessControlValue                          `url:\"model_registry_access_level,omitempty\" json:\"model_registry_access_level,omitempty\"`\n\tName                                      *string                                      `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tOnlyAllowMergeIfAllDiscussionsAreResolved *bool                                        `url:\"only_allow_merge_if_all_discussions_are_resolved,omitempty\" json:\"only_allow_merge_if_all_discussions_are_resolved,omitempty\"`\n\tOnlyAllowMergeIfPipelineSucceeds          *bool                                        `url:\"only_allow_merge_if_pipeline_succeeds,omitempty\" json:\"only_allow_merge_if_pipeline_succeeds,omitempty\"`\n\tOnlyMirrorProtectedBranches               *bool                                        `url:\"only_mirror_protected_branches,omitempty\" json:\"only_mirror_protected_branches,omitempty\"`\n\tOperationsAccessLevel                     *AccessControlValue                          `url:\"operations_access_level,omitempty\" json:\"operations_access_level,omitempty\"`\n\tPackagesEnabled                           *bool                                        `url:\"packages_enabled,omitempty\" json:\"packages_enabled,omitempty\"`\n\tPagesAccessLevel                          *AccessControlValue                          `url:\"pages_access_level,omitempty\" json:\"pages_access_level,omitempty\"`\n\tPath                                      *string                                      `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tPublicBuilds                              *bool                                        `url:\"public_builds,omitempty\" json:\"public_builds,omitempty\"`\n\tReleasesAccessLevel                       *AccessControlValue                          `url:\"releases_access_level,omitempty\" json:\"releases_access_level,omitempty\"`\n\tEnvironmentsAccessLevel                   *AccessControlValue                          `url:\"environments_access_level,omitempty\" json:\"environments_access_level,omitempty\"`\n\tFeatureFlagsAccessLevel                   *AccessControlValue                          `url:\"feature_flags_access_level,omitempty\" json:\"feature_flags_access_level,omitempty\"`\n\tInfrastructureAccessLevel                 *AccessControlValue                          `url:\"infrastructure_access_level,omitempty\" json:\"infrastructure_access_level,omitempty\"`\n\tMonitorAccessLevel                        *AccessControlValue                          `url:\"monitor_access_level,omitempty\" json:\"monitor_access_level,omitempty\"`\n\tRemoveSourceBranchAfterMerge              *bool                                        `url:\"remove_source_branch_after_merge,omitempty\" json:\"remove_source_branch_after_merge,omitempty\"`\n\tPreventMergeWithoutJiraIssue              *bool                                        `url:\"prevent_merge_without_jira_issue,omitempty\" json:\"prevent_merge_without_jira_issue,omitempty\"`\n\tPrintingMergeRequestLinkEnabled           *bool                                        `url:\"printing_merge_request_link_enabled,omitempty\" json:\"printing_merge_request_link_enabled,omitempty\"`\n\tRepositoryAccessLevel                     *AccessControlValue                          `url:\"repository_access_level,omitempty\" json:\"repository_access_level,omitempty\"`\n\tRepositoryStorage                         *string                                      `url:\"repository_storage,omitempty\" json:\"repository_storage,omitempty\"`\n\tRequestAccessEnabled                      *bool                                        `url:\"request_access_enabled,omitempty\" json:\"request_access_enabled,omitempty\"`\n\tRequirementsAccessLevel                   *AccessControlValue                          `url:\"requirements_access_level,omitempty\" json:\"requirements_access_level,omitempty\"`\n\tResolveOutdatedDiffDiscussions            *bool                                        `url:\"resolve_outdated_diff_discussions,omitempty\" json:\"resolve_outdated_diff_discussions,omitempty\"`\n\tRestrictUserDefinedVariables              *bool                                        `url:\"restrict_user_defined_variables,omitempty\" json:\"restrict_user_defined_variables,omitempty\"`\n\tSecurityAndComplianceAccessLevel          *AccessControlValue                          `url:\"security_and_compliance_access_level,omitempty\" json:\"security_and_compliance_access_level,omitempty\"`\n\tServiceDeskEnabled                        *bool                                        `url:\"service_desk_enabled,omitempty\" json:\"service_desk_enabled,omitempty\"`\n\tSharedRunnersEnabled                      *bool                                        `url:\"shared_runners_enabled,omitempty\" json:\"shared_runners_enabled,omitempty\"`\n\tGroupRunnersEnabled                       *bool                                        `url:\"group_runners_enabled,omitempty\" json:\"group_runners_enabled,omitempty\"`\n\tShowDefaultAwardEmojis                    *bool                                        `url:\"show_default_award_emojis,omitempty\" json:\"show_default_award_emojis,omitempty\"`\n\tSnippetsAccessLevel                       *AccessControlValue                          `url:\"snippets_access_level,omitempty\" json:\"snippets_access_level,omitempty\"`\n\tSquashCommitTemplate                      *string                                      `url:\"squash_commit_template,omitempty\" json:\"squash_commit_template,omitempty\"`\n\tSquashOption                              *SquashOptionValue                           `url:\"squash_option,omitempty\" json:\"squash_option,omitempty\"`\n\tSuggestionCommitMessage                   *string                                      `url:\"suggestion_commit_message,omitempty\" json:\"suggestion_commit_message,omitempty\"`\n\tTopics                                    *[]string                                    `url:\"topics,omitempty\" json:\"topics,omitempty\"`\n\tVisibility                                *VisibilityValue                             `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tWikiAccessLevel                           *AccessControlValue                          `url:\"wiki_access_level,omitempty\" json:\"wiki_access_level,omitempty\"`\n\n\t// Deprecated: Use ContainerRegistryAccessLevel instead.\n\tContainerRegistryEnabled *bool `url:\"container_registry_enabled,omitempty\" json:\"container_registry_enabled,omitempty\"`\n\t// Deprecated: Use EmailsEnabled instead\n\tEmailsDisabled *bool `url:\"emails_disabled,omitempty\" json:\"emails_disabled,omitempty\"`\n\t// Deprecated: Use IssuesAccessLevel instead.\n\tIssuesEnabled *bool `url:\"issues_enabled,omitempty\" json:\"issues_enabled,omitempty\"`\n\t// Deprecated: Use BuildsAccessLevel instead.\n\tJobsEnabled *bool `url:\"jobs_enabled,omitempty\" json:\"jobs_enabled,omitempty\"`\n\t// Deprecated: Use MergeRequestsAccessLevel instead.\n\tMergeRequestsEnabled *bool `url:\"merge_requests_enabled,omitempty\" json:\"merge_requests_enabled,omitempty\"`\n\t// Deprecated: Use SnippetsAccessLevel instead.\n\tSnippetsEnabled *bool `url:\"snippets_enabled,omitempty\" json:\"snippets_enabled,omitempty\"`\n\t// Deprecated: Use Topics instead. (Deprecated in GitLab 14.0)\n\tTagList *[]string `url:\"tag_list,omitempty\" json:\"tag_list,omitempty\"`\n\t// Deprecated: Use WikiAccessLevel instead.\n\tWikiEnabled *bool `url:\"wiki_enabled,omitempty\" json:\"wiki_enabled,omitempty\"`\n}\n\n// EditProject updates an existing project.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#edit-project\nfunc (s *ProjectsService) EditProject(pid interface{}, opt *EditProjectOptions, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tif opt.ContainerExpirationPolicyAttributes != nil {\n\t\t// This is needed to satisfy the API. Should be deleted\n\t\t// when NameRegex is removed (it's now deprecated).\n\t\topt.ContainerExpirationPolicyAttributes.NameRegex = opt.ContainerExpirationPolicyAttributes.NameRegexDelete\n\t}\n\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s\", PathEscape(project))\n\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil || (opt.Avatar.Filename == \"\" && opt.Avatar.Image == nil) {\n\t\treq, err = s.client.NewRequest(http.MethodPut, u, opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPut,\n\t\t\tu,\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ForkProjectOptions represents the available ForkProject() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#fork-project\ntype ForkProjectOptions struct {\n\tDescription                   *string          `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tMergeRequestDefaultTargetSelf *bool            `url:\"mr_default_target_self,omitempty\" json:\"mr_default_target_self,omitempty\"`\n\tName                          *string          `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tNamespaceID                   *int             `url:\"namespace_id,omitempty\" json:\"namespace_id,omitempty\"`\n\tNamespacePath                 *string          `url:\"namespace_path,omitempty\" json:\"namespace_path,omitempty\"`\n\tPath                          *string          `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tVisibility                    *VisibilityValue `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\n\t// Deprecated: This parameter has been split into NamespaceID and NamespacePath.\n\tNamespace *string `url:\"namespace,omitempty\" json:\"namespace,omitempty\"`\n}\n\n// ForkProject forks a project into the user namespace of the authenticated\n// user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#fork-project\nfunc (s *ProjectsService) ForkProject(pid interface{}, opt *ForkProjectOptions, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/fork\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// StarProject stars a given the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#star-a-project\nfunc (s *ProjectsService) StarProject(pid interface{}, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/star\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ListProjectInvidedGroupOptions represents the available\n// ListProjectsInvitedGroups() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-a-projects-invited-groups\ntype ListProjectInvidedGroupOptions struct {\n\tListOptions\n\tSearch               *string           `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tMinAccessLevel       *AccessLevelValue `url:\"min_access_level,omitempty\" json:\"min_access_level,omitempty\"`\n\tRelation             *[]string         `url:\"relation,omitempty\" json:\"relation,omitempty\"`\n\tWithCustomAttributes *bool             `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n}\n\n// ListProjectsInvitedGroups lists invited groups of a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-a-projects-invited-groups\nfunc (s *ProjectsService) ListProjectsInvitedGroups(pid interface{}, opt *ListProjectInvidedGroupOptions, options ...RequestOptionFunc) ([]*ProjectGroup, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/invited_groups\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pg []*ProjectGroup\n\tresp, err := s.client.Do(req, &pg)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pg, resp, nil\n}\n\n// UnstarProject unstars a given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#unstar-a-project\nfunc (s *ProjectsService) UnstarProject(pid interface{}, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/unstar\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ArchiveProject archives the project if the user is either admin or the\n// project owner of this project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#archive-a-project\nfunc (s *ProjectsService) ArchiveProject(pid interface{}, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/archive\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// UnarchiveProject unarchives the project if the user is either admin or\n// the project owner of this project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#unarchive-a-project\nfunc (s *ProjectsService) UnarchiveProject(pid interface{}, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/unarchive\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// DeleteProjectOptions represents the available DeleteProject() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#delete-project\ntype DeleteProjectOptions struct {\n\tFullPath          *string `url:\"full_path\" json:\"full_path\"`\n\tPermanentlyRemove *bool   `url:\"permanently_remove\" json:\"permanently_remove\"`\n}\n\n// DeleteProject removes a project including all associated resources\n// (issues, merge requests etc.)\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#delete-project\nfunc (s *ProjectsService) DeleteProject(pid interface{}, opt *DeleteProjectOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ShareWithGroupOptions represents the available SharedWithGroup() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#share-project-with-group\ntype ShareWithGroupOptions struct {\n\tExpiresAt   *string           `url:\"expires_at\" json:\"expires_at\"`\n\tGroupAccess *AccessLevelValue `url:\"group_access\" json:\"group_access\"`\n\tGroupID     *int              `url:\"group_id\" json:\"group_id\"`\n}\n\n// ShareProjectWithGroup allows to share a project with a group.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#share-project-with-group\nfunc (s *ProjectsService) ShareProjectWithGroup(pid interface{}, opt *ShareWithGroupOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/share\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteSharedProjectFromGroup allows to unshare a project from a group.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#delete-a-shared-project-link-within-a-group\nfunc (s *ProjectsService) DeleteSharedProjectFromGroup(pid interface{}, groupID int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/share/%d\", PathEscape(project), groupID)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ProjectMember represents a project member.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/members.html#list-all-members-of-a-group-or-project\ntype ProjectMember struct {\n\tID          int              `json:\"id\"`\n\tUsername    string           `json:\"username\"`\n\tEmail       string           `json:\"email\"`\n\tName        string           `json:\"name\"`\n\tState       string           `json:\"state\"`\n\tCreatedAt   *time.Time       `json:\"created_at\"`\n\tExpiresAt   *ISOTime         `json:\"expires_at\"`\n\tAccessLevel AccessLevelValue `json:\"access_level\"`\n\tWebURL      string           `json:\"web_url\"`\n\tAvatarURL   string           `json:\"avatar_url\"`\n}\n\n// HookCustomHeader represents a project or group hook custom header\n// Note: \"Key\" is returned from the Get operation, but \"Value\" is not\n// The List operation doesn't return any headers at all for Projects,\n// but does return headers for Groups\ntype HookCustomHeader struct {\n\tKey   string `json:\"key\"`\n\tValue string `json:\"value\"`\n}\n\n// ProjectHook represents a project hook.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-project-hooks\ntype ProjectHook struct {\n\tID                        int                 `json:\"id\"`\n\tURL                       string              `json:\"url\"`\n\tName                      string              `json:\"name\"`\n\tDescription               string              `json:\"description\"`\n\tConfidentialNoteEvents    bool                `json:\"confidential_note_events\"`\n\tProjectID                 int                 `json:\"project_id\"`\n\tPushEvents                bool                `json:\"push_events\"`\n\tPushEventsBranchFilter    string              `json:\"push_events_branch_filter\"`\n\tIssuesEvents              bool                `json:\"issues_events\"`\n\tConfidentialIssuesEvents  bool                `json:\"confidential_issues_events\"`\n\tMergeRequestsEvents       bool                `json:\"merge_requests_events\"`\n\tTagPushEvents             bool                `json:\"tag_push_events\"`\n\tNoteEvents                bool                `json:\"note_events\"`\n\tJobEvents                 bool                `json:\"job_events\"`\n\tPipelineEvents            bool                `json:\"pipeline_events\"`\n\tWikiPageEvents            bool                `json:\"wiki_page_events\"`\n\tDeploymentEvents          bool                `json:\"deployment_events\"`\n\tReleasesEvents            bool                `json:\"releases_events\"`\n\tEnableSSLVerification     bool                `json:\"enable_ssl_verification\"`\n\tAlertStatus               string              `json:\"alert_status\"`\n\tCreatedAt                 *time.Time          `json:\"created_at\"`\n\tResourceAccessTokenEvents bool                `json:\"resource_access_token_events\"`\n\tCustomWebhookTemplate     string              `json:\"custom_webhook_template\"`\n\tCustomHeaders             []*HookCustomHeader `json:\"custom_headers\"`\n}\n\n// ListProjectHooksOptions represents the available ListProjectHooks() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#list-project-hooks\ntype ListProjectHooksOptions ListOptions\n\n// ListProjectHooks gets a list of project hooks.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-project-hooks\nfunc (s *ProjectsService) ListProjectHooks(pid interface{}, opt *ListProjectHooksOptions, options ...RequestOptionFunc) ([]*ProjectHook, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ph []*ProjectHook\n\tresp, err := s.client.Do(req, &ph)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ph, resp, nil\n}\n\n// GetProjectHook gets a specific hook for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-project-hook\nfunc (s *ProjectsService) GetProjectHook(pid interface{}, hook int, options ...RequestOptionFunc) (*ProjectHook, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks/%d\", PathEscape(project), hook)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tph := new(ProjectHook)\n\tresp, err := s.client.Do(req, ph)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ph, resp, nil\n}\n\n// AddProjectHookOptions represents the available AddProjectHook() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#add-project-hook\ntype AddProjectHookOptions struct {\n\tName                      *string              `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription               *string              `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tConfidentialIssuesEvents  *bool                `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tConfidentialNoteEvents    *bool                `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tDeploymentEvents          *bool                `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tEnableSSLVerification     *bool                `url:\"enable_ssl_verification,omitempty\" json:\"enable_ssl_verification,omitempty\"`\n\tIssuesEvents              *bool                `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tJobEvents                 *bool                `url:\"job_events,omitempty\" json:\"job_events,omitempty\"`\n\tMergeRequestsEvents       *bool                `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tNoteEvents                *bool                `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tPipelineEvents            *bool                `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tPushEvents                *bool                `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tPushEventsBranchFilter    *string              `url:\"push_events_branch_filter,omitempty\" json:\"push_events_branch_filter,omitempty\"`\n\tReleasesEvents            *bool                `url:\"releases_events,omitempty\" json:\"releases_events,omitempty\"`\n\tTagPushEvents             *bool                `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tToken                     *string              `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tURL                       *string              `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tWikiPageEvents            *bool                `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n\tResourceAccessTokenEvents *bool                `url:\"resource_access_token_events,omitempty\" json:\"resource_access_token_events,omitempty\"`\n\tCustomWebhookTemplate     *string              `url:\"custom_webhook_template,omitempty\" json:\"custom_webhook_template,omitempty\"`\n\tCustomHeaders             *[]*HookCustomHeader `url:\"custom_headers,omitempty\" json:\"custom_headers,omitempty\"`\n}\n\n// AddProjectHook adds a hook to a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#add-project-hook\nfunc (s *ProjectsService) AddProjectHook(pid interface{}, opt *AddProjectHookOptions, options ...RequestOptionFunc) (*ProjectHook, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tph := new(ProjectHook)\n\tresp, err := s.client.Do(req, ph)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ph, resp, nil\n}\n\n// EditProjectHookOptions represents the available EditProjectHook() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#edit-project-hook\ntype EditProjectHookOptions struct {\n\tName                      *string              `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDescription               *string              `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tConfidentialIssuesEvents  *bool                `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tConfidentialNoteEvents    *bool                `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tDeploymentEvents          *bool                `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tEnableSSLVerification     *bool                `url:\"enable_ssl_verification,omitempty\" json:\"enable_ssl_verification,omitempty\"`\n\tIssuesEvents              *bool                `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tJobEvents                 *bool                `url:\"job_events,omitempty\" json:\"job_events,omitempty\"`\n\tMergeRequestsEvents       *bool                `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tNoteEvents                *bool                `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tPipelineEvents            *bool                `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tPushEvents                *bool                `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tPushEventsBranchFilter    *string              `url:\"push_events_branch_filter,omitempty\" json:\"push_events_branch_filter,omitempty\"`\n\tReleasesEvents            *bool                `url:\"releases_events,omitempty\" json:\"releases_events,omitempty\"`\n\tTagPushEvents             *bool                `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tToken                     *string              `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tURL                       *string              `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tWikiPageEvents            *bool                `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n\tResourceAccessTokenEvents *bool                `url:\"resource_access_token_events,omitempty\" json:\"resource_access_token_events,omitempty\"`\n\tCustomWebhookTemplate     *string              `url:\"custom_webhook_template,omitempty\" json:\"custom_webhook_template,omitempty\"`\n\tCustomHeaders             *[]*HookCustomHeader `url:\"custom_headers,omitempty\" json:\"custom_headers,omitempty\"`\n}\n\n// EditProjectHook edits a hook for a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#edit-project-hook\nfunc (s *ProjectsService) EditProjectHook(pid interface{}, hook int, opt *EditProjectHookOptions, options ...RequestOptionFunc) (*ProjectHook, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks/%d\", PathEscape(project), hook)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tph := new(ProjectHook)\n\tresp, err := s.client.Do(req, ph)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ph, resp, nil\n}\n\n// DeleteProjectHook removes a hook from a project. This is an idempotent\n// method and can be called multiple times. Either the hook is available or not.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#delete-project-hook\nfunc (s *ProjectsService) DeleteProjectHook(pid interface{}, hook int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks/%d\", PathEscape(project), hook)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// TriggerTestProjectHook Trigger a test hook for a specified project.\n//\n// In GitLab 17.0 and later, this endpoint has a special rate limit.\n// In GitLab 17.0 the rate was three requests per minute for each project hook.\n// In GitLab 17.1 this was changed to five requests per minute for each project\n// and authenticated user.\n//\n// To disable this limit on self-managed GitLab and GitLab Dedicated,\n// an administrator can disable the feature flag named web_hook_test_api_endpoint_rate_limit.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#trigger-a-test-project-hook\nfunc (s *ProjectsService) TriggerTestProjectHook(pid interface{}, hook int, event ProjectHookEvent, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks/%d/test/%s\", PathEscape(project), hook, string(event))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SetHookCustomHeaderOptions represents the available SetProjectCustomHeader()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#set-a-custom-header\ntype SetHookCustomHeaderOptions struct {\n\tValue *string `json:\"value,omitempty\"`\n}\n\n// SetProjectCustomHeader creates or updates a project custom webhook header.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#set-a-custom-header\nfunc (s *ProjectsService) SetProjectCustomHeader(pid interface{}, hook int, key string, opt *SetHookCustomHeaderOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks/%d/custom_headers/%s\", PathEscape(project), hook, key)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteProjectCustomHeader deletes a project custom webhook header.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#delete-a-custom-header\nfunc (s *ProjectsService) DeleteProjectCustomHeader(pid interface{}, hook int, key string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/hooks/%d/custom_headers/%s\", PathEscape(project), hook, key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ProjectForkRelation represents a project fork relationship.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#admin-fork-relation\ntype ProjectForkRelation struct {\n\tID                  int        `json:\"id\"`\n\tForkedToProjectID   int        `json:\"forked_to_project_id\"`\n\tForkedFromProjectID int        `json:\"forked_from_project_id\"`\n\tCreatedAt           *time.Time `json:\"created_at\"`\n\tUpdatedAt           *time.Time `json:\"updated_at\"`\n}\n\n// CreateProjectForkRelation creates a forked from/to relation between\n// existing projects.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#create-a-forked-fromto-relation-between-existing-projects.\nfunc (s *ProjectsService) CreateProjectForkRelation(pid interface{}, fork int, options ...RequestOptionFunc) (*ProjectForkRelation, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/fork/%d\", PathEscape(project), fork)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpfr := new(ProjectForkRelation)\n\tresp, err := s.client.Do(req, pfr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pfr, resp, nil\n}\n\n// DeleteProjectForkRelation deletes an existing forked from relationship.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#delete-an-existing-forked-from-relationship\nfunc (s *ProjectsService) DeleteProjectForkRelation(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/fork\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ProjectFile represents an uploaded project file.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#upload-a-file\ntype ProjectFile struct {\n\tAlt      string `json:\"alt\"`\n\tURL      string `json:\"url\"`\n\tFullPath string `json:\"full_path\"`\n\tMarkdown string `json:\"markdown\"`\n}\n\n// UploadFile uploads a file.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#upload-a-file\nfunc (s *ProjectsService) UploadFile(pid interface{}, content io.Reader, filename string, options ...RequestOptionFunc) (*ProjectFile, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/uploads\", PathEscape(project))\n\n\treq, err := s.client.UploadRequest(\n\t\thttp.MethodPost,\n\t\tu,\n\t\tcontent,\n\t\tfilename,\n\t\tUploadFile,\n\t\tnil,\n\t\toptions,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpf := new(ProjectFile)\n\tresp, err := s.client.Do(req, pf)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pf, resp, nil\n}\n\n// UploadAvatar uploads an avatar.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#upload-a-project-avatar\nfunc (s *ProjectsService) UploadAvatar(pid interface{}, avatar io.Reader, filename string, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s\", PathEscape(project))\n\n\treq, err := s.client.UploadRequest(\n\t\thttp.MethodPut,\n\t\tu,\n\t\tavatar,\n\t\tfilename,\n\t\tUploadAvatar,\n\t\tnil,\n\t\toptions,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ListProjectForks gets a list of project forks.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#list-forks-of-a-project\nfunc (s *ProjectsService) ListProjectForks(pid interface{}, opt *ListProjectsOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/forks\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar forks []*Project\n\tresp, err := s.client.Do(req, &forks)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn forks, resp, nil\n}\n\n// ProjectPushRules represents a project push rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#push-rules\ntype ProjectPushRules struct {\n\tID                         int        `json:\"id\"`\n\tProjectID                  int        `json:\"project_id\"`\n\tCommitMessageRegex         string     `json:\"commit_message_regex\"`\n\tCommitMessageNegativeRegex string     `json:\"commit_message_negative_regex\"`\n\tBranchNameRegex            string     `json:\"branch_name_regex\"`\n\tDenyDeleteTag              bool       `json:\"deny_delete_tag\"`\n\tCreatedAt                  *time.Time `json:\"created_at\"`\n\tMemberCheck                bool       `json:\"member_check\"`\n\tPreventSecrets             bool       `json:\"prevent_secrets\"`\n\tAuthorEmailRegex           string     `json:\"author_email_regex\"`\n\tFileNameRegex              string     `json:\"file_name_regex\"`\n\tMaxFileSize                int        `json:\"max_file_size\"`\n\tCommitCommitterCheck       bool       `json:\"commit_committer_check\"`\n\tCommitCommitterNameCheck   bool       `json:\"commit_committer_name_check\"`\n\tRejectUnsignedCommits      bool       `json:\"reject_unsigned_commits\"`\n\tRejectNonDCOCommits        bool       `json:\"reject_non_dco_commits\"`\n}\n\n// GetProjectPushRules gets the push rules of a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-project-push-rules\nfunc (s *ProjectsService) GetProjectPushRules(pid interface{}, options ...RequestOptionFunc) (*ProjectPushRules, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/push_rule\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tppr := new(ProjectPushRules)\n\tresp, err := s.client.Do(req, ppr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ppr, resp, nil\n}\n\n// AddProjectPushRuleOptions represents the available AddProjectPushRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#add-project-push-rule\ntype AddProjectPushRuleOptions struct {\n\tAuthorEmailRegex           *string `url:\"author_email_regex,omitempty\" json:\"author_email_regex,omitempty\"`\n\tBranchNameRegex            *string `url:\"branch_name_regex,omitempty\" json:\"branch_name_regex,omitempty\"`\n\tCommitCommitterCheck       *bool   `url:\"commit_committer_check,omitempty\" json:\"commit_committer_check,omitempty\"`\n\tCommitCommitterNameCheck   *bool   `url:\"commit_committer_name_check,omitempty\" json:\"commit_committer_name_check,omitempty\"`\n\tCommitMessageNegativeRegex *string `url:\"commit_message_negative_regex,omitempty\" json:\"commit_message_negative_regex,omitempty\"`\n\tCommitMessageRegex         *string `url:\"commit_message_regex,omitempty\" json:\"commit_message_regex,omitempty\"`\n\tDenyDeleteTag              *bool   `url:\"deny_delete_tag,omitempty\" json:\"deny_delete_tag,omitempty\"`\n\tFileNameRegex              *string `url:\"file_name_regex,omitempty\" json:\"file_name_regex,omitempty\"`\n\tMaxFileSize                *int    `url:\"max_file_size,omitempty\" json:\"max_file_size,omitempty\"`\n\tMemberCheck                *bool   `url:\"member_check,omitempty\" json:\"member_check,omitempty\"`\n\tPreventSecrets             *bool   `url:\"prevent_secrets,omitempty\" json:\"prevent_secrets,omitempty\"`\n\tRejectUnsignedCommits      *bool   `url:\"reject_unsigned_commits,omitempty\" json:\"reject_unsigned_commits,omitempty\"`\n\tRejectNonDCOCommits        *bool   `url:\"reject_non_dco_commits,omitempty\" json:\"reject_non_dco_commits,omitempty\"`\n}\n\n// AddProjectPushRule adds a push rule to a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#add-project-push-rule\nfunc (s *ProjectsService) AddProjectPushRule(pid interface{}, opt *AddProjectPushRuleOptions, options ...RequestOptionFunc) (*ProjectPushRules, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/push_rule\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tppr := new(ProjectPushRules)\n\tresp, err := s.client.Do(req, ppr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ppr, resp, nil\n}\n\n// EditProjectPushRuleOptions represents the available EditProjectPushRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#edit-project-push-rule\ntype EditProjectPushRuleOptions struct {\n\tAuthorEmailRegex           *string `url:\"author_email_regex,omitempty\" json:\"author_email_regex,omitempty\"`\n\tBranchNameRegex            *string `url:\"branch_name_regex,omitempty\" json:\"branch_name_regex,omitempty\"`\n\tCommitCommitterCheck       *bool   `url:\"commit_committer_check,omitempty\" json:\"commit_committer_check,omitempty\"`\n\tCommitCommitterNameCheck   *bool   `url:\"commit_committer_name_check,omitempty\" json:\"commit_committer_name_check,omitempty\"`\n\tCommitMessageNegativeRegex *string `url:\"commit_message_negative_regex,omitempty\" json:\"commit_message_negative_regex,omitempty\"`\n\tCommitMessageRegex         *string `url:\"commit_message_regex,omitempty\" json:\"commit_message_regex,omitempty\"`\n\tDenyDeleteTag              *bool   `url:\"deny_delete_tag,omitempty\" json:\"deny_delete_tag,omitempty\"`\n\tFileNameRegex              *string `url:\"file_name_regex,omitempty\" json:\"file_name_regex,omitempty\"`\n\tMaxFileSize                *int    `url:\"max_file_size,omitempty\" json:\"max_file_size,omitempty\"`\n\tMemberCheck                *bool   `url:\"member_check,omitempty\" json:\"member_check,omitempty\"`\n\tPreventSecrets             *bool   `url:\"prevent_secrets,omitempty\" json:\"prevent_secrets,omitempty\"`\n\tRejectUnsignedCommits      *bool   `url:\"reject_unsigned_commits,omitempty\" json:\"reject_unsigned_commits,omitempty\"`\n\tRejectNonDCOCommits        *bool   `url:\"reject_non_dco_commits,omitempty\" json:\"reject_non_dco_commits,omitempty\"`\n}\n\n// EditProjectPushRule edits a push rule for a specified project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#edit-project-push-rule\nfunc (s *ProjectsService) EditProjectPushRule(pid interface{}, opt *EditProjectPushRuleOptions, options ...RequestOptionFunc) (*ProjectPushRules, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/push_rule\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tppr := new(ProjectPushRules)\n\tresp, err := s.client.Do(req, ppr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ppr, resp, nil\n}\n\n// DeleteProjectPushRule removes a push rule from a project. This is an\n// idempotent method and can be called multiple times. Either the push rule is\n// available or not.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#delete-project-push-rule\nfunc (s *ProjectsService) DeleteProjectPushRule(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/push_rule\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ProjectApprovals represents GitLab project level merge request approvals.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#project-level-mr-approvals\ntype ProjectApprovals struct {\n\tApprovers                                 []*MergeRequestApproverUser  `json:\"approvers\"`\n\tApproverGroups                            []*MergeRequestApproverGroup `json:\"approver_groups\"`\n\tApprovalsBeforeMerge                      int                          `json:\"approvals_before_merge\"`\n\tResetApprovalsOnPush                      bool                         `json:\"reset_approvals_on_push\"`\n\tDisableOverridingApproversPerMergeRequest bool                         `json:\"disable_overriding_approvers_per_merge_request\"`\n\tMergeRequestsAuthorApproval               bool                         `json:\"merge_requests_author_approval\"`\n\tMergeRequestsDisableCommittersApproval    bool                         `json:\"merge_requests_disable_committers_approval\"`\n\tRequirePasswordToApprove                  bool                         `json:\"require_password_to_approve\"`\n\tSelectiveCodeOwnerRemovals                bool                         `json:\"selective_code_owner_removals,omitempty\"`\n}\n\n// GetApprovalConfiguration get the approval configuration for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-configuration\nfunc (s *ProjectsService) GetApprovalConfiguration(pid interface{}, options ...RequestOptionFunc) (*ProjectApprovals, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approvals\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpa := new(ProjectApprovals)\n\tresp, err := s.client.Do(req, pa)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pa, resp, nil\n}\n\n// ChangeApprovalConfigurationOptions represents the available\n// ApprovalConfiguration() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-configuration\ntype ChangeApprovalConfigurationOptions struct {\n\tApprovalsBeforeMerge                      *int  `url:\"approvals_before_merge,omitempty\" json:\"approvals_before_merge,omitempty\"`\n\tDisableOverridingApproversPerMergeRequest *bool `url:\"disable_overriding_approvers_per_merge_request,omitempty\" json:\"disable_overriding_approvers_per_merge_request,omitempty\"`\n\tMergeRequestsAuthorApproval               *bool `url:\"merge_requests_author_approval,omitempty\" json:\"merge_requests_author_approval,omitempty\"`\n\tMergeRequestsDisableCommittersApproval    *bool `url:\"merge_requests_disable_committers_approval,omitempty\" json:\"merge_requests_disable_committers_approval,omitempty\"`\n\tRequirePasswordToApprove                  *bool `url:\"require_password_to_approve,omitempty\" json:\"require_password_to_approve,omitempty\"`\n\tResetApprovalsOnPush                      *bool `url:\"reset_approvals_on_push,omitempty\" json:\"reset_approvals_on_push,omitempty\"`\n\tSelectiveCodeOwnerRemovals                *bool `url:\"selective_code_owner_removals,omitempty\" json:\"selective_code_owner_removals,omitempty\"`\n}\n\n// ChangeApprovalConfiguration updates the approval configuration for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-configuration\nfunc (s *ProjectsService) ChangeApprovalConfiguration(pid interface{}, opt *ChangeApprovalConfigurationOptions, options ...RequestOptionFunc) (*ProjectApprovals, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approvals\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpa := new(ProjectApprovals)\n\tresp, err := s.client.Do(req, pa)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pa, resp, nil\n}\n\n// GetProjectApprovalRulesListsOptions represents the available\n// GetProjectApprovalRules() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-project-level-rules\ntype GetProjectApprovalRulesListsOptions ListOptions\n\n// GetProjectApprovalRules looks up the list of project level approver rules.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-project-level-rules\nfunc (s *ProjectsService) GetProjectApprovalRules(pid interface{}, opt *GetProjectApprovalRulesListsOptions, options ...RequestOptionFunc) ([]*ProjectApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approval_rules\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar par []*ProjectApprovalRule\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// GetProjectApprovalRule gets the project level approvers.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#get-a-single-project-level-rule\nfunc (s *ProjectsService) GetProjectApprovalRule(pid interface{}, ruleID int, options ...RequestOptionFunc) (*ProjectApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approval_rules/%d\", PathEscape(project), ruleID)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpar := new(ProjectApprovalRule)\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// CreateProjectLevelRuleOptions represents the available CreateProjectApprovalRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#create-project-level-rule\ntype CreateProjectLevelRuleOptions struct {\n\tName                          *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tApprovalsRequired             *int    `url:\"approvals_required,omitempty\" json:\"approvals_required,omitempty\"`\n\tReportType                    *string `url:\"report_type,omitempty\" json:\"report_type,omitempty\"`\n\tRuleType                      *string `url:\"rule_type,omitempty\" json:\"rule_type,omitempty\"`\n\tUserIDs                       *[]int  `url:\"user_ids,omitempty\" json:\"user_ids,omitempty\"`\n\tGroupIDs                      *[]int  `url:\"group_ids,omitempty\" json:\"group_ids,omitempty\"`\n\tProtectedBranchIDs            *[]int  `url:\"protected_branch_ids,omitempty\" json:\"protected_branch_ids,omitempty\"`\n\tAppliesToAllProtectedBranches *bool   `url:\"applies_to_all_protected_branches,omitempty\" json:\"applies_to_all_protected_branches,omitempty\"`\n}\n\n// CreateProjectApprovalRule creates a new project-level approval rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#create-project-level-rule\nfunc (s *ProjectsService) CreateProjectApprovalRule(pid interface{}, opt *CreateProjectLevelRuleOptions, options ...RequestOptionFunc) (*ProjectApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approval_rules\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpar := new(ProjectApprovalRule)\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// UpdateProjectLevelRuleOptions represents the available UpdateProjectApprovalRule()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#update-project-level-rule\ntype UpdateProjectLevelRuleOptions struct {\n\tName                          *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tApprovalsRequired             *int    `url:\"approvals_required,omitempty\" json:\"approvals_required,omitempty\"`\n\tUserIDs                       *[]int  `url:\"user_ids,omitempty\" json:\"user_ids,omitempty\"`\n\tGroupIDs                      *[]int  `url:\"group_ids,omitempty\" json:\"group_ids,omitempty\"`\n\tProtectedBranchIDs            *[]int  `url:\"protected_branch_ids,omitempty\" json:\"protected_branch_ids,omitempty\"`\n\tAppliesToAllProtectedBranches *bool   `url:\"applies_to_all_protected_branches,omitempty\" json:\"applies_to_all_protected_branches,omitempty\"`\n}\n\n// UpdateProjectApprovalRule updates an existing approval rule with new options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#update-project-level-rule\nfunc (s *ProjectsService) UpdateProjectApprovalRule(pid interface{}, approvalRule int, opt *UpdateProjectLevelRuleOptions, options ...RequestOptionFunc) (*ProjectApprovalRule, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approval_rules/%d\", PathEscape(project), approvalRule)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpar := new(ProjectApprovalRule)\n\tresp, err := s.client.Do(req, &par)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn par, resp, nil\n}\n\n// DeleteProjectApprovalRule deletes a project-level approval rule.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#delete-project-level-rule\nfunc (s *ProjectsService) DeleteProjectApprovalRule(pid interface{}, approvalRule int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approval_rules/%d\", PathEscape(project), approvalRule)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ChangeAllowedApproversOptions represents the available ChangeAllowedApprovers()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-allowed-approvers\ntype ChangeAllowedApproversOptions struct {\n\tApproverGroupIDs *[]int `url:\"approver_group_ids,omitempty\" json:\"approver_group_ids,omitempty\"`\n\tApproverIDs      *[]int `url:\"approver_ids,omitempty\" json:\"approver_ids,omitempty\"`\n}\n\n// ChangeAllowedApprovers updates the list of approvers and approver groups.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/merge_request_approvals.html#change-allowed-approvers\nfunc (s *ProjectsService) ChangeAllowedApprovers(pid interface{}, opt *ChangeAllowedApproversOptions, options ...RequestOptionFunc) (*ProjectApprovals, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/approvers\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpa := new(ProjectApprovals)\n\tresp, err := s.client.Do(req, pa)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pa, resp, nil\n}\n\n// ProjectPullMirrorDetails represent the details of the configuration pull\n// mirror and its update status.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-a-projects-pull-mirror-details\ntype ProjectPullMirrorDetails struct {\n\tID                     int        `json:\"id\"`\n\tLastError              string     `json:\"last_error\"`\n\tLastSuccessfulUpdateAt *time.Time `json:\"last_successful_update_at\"`\n\tLastUpdateAt           *time.Time `json:\"last_update_at\"`\n\tLastUpdateStartedAt    *time.Time `json:\"last_update_started_at\"`\n\tUpdateStatus           string     `json:\"update_status\"`\n\tURL                    string     `json:\"url\"`\n}\n\n// GetProjectPullMirrorDetails returns the pull mirror details.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-a-projects-pull-mirror-details\nfunc (s *ProjectsService) GetProjectPullMirrorDetails(pid interface{}, options ...RequestOptionFunc) (*ProjectPullMirrorDetails, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/mirror/pull\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpmd := new(ProjectPullMirrorDetails)\n\tresp, err := s.client.Do(req, pmd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pmd, resp, nil\n}\n\n// StartMirroringProject start the pull mirroring process for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#start-the-pull-mirroring-process-for-a-project\nfunc (s *ProjectsService) StartMirroringProject(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/mirror/pull\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil {\n\t\treturn resp, err\n\t}\n\n\treturn resp, nil\n}\n\n// TransferProjectOptions represents the available TransferProject() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#transfer-a-project-to-a-new-namespace\ntype TransferProjectOptions struct {\n\tNamespace interface{} `url:\"namespace,omitempty\" json:\"namespace,omitempty\"`\n}\n\n// TransferProject transfer a project into the specified namespace\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#transfer-a-project-to-a-new-namespace\nfunc (s *ProjectsService) TransferProject(pid interface{}, opt *TransferProjectOptions, options ...RequestOptionFunc) (*Project, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/transfer\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(Project)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// StartHousekeepingProject start the Housekeeping task for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#start-the-housekeeping-task-for-a-project\nfunc (s *ProjectsService) StartHousekeepingProject(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/housekeeping\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GetRepositoryStorage Get the path to repository storage.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/projects.html#get-the-path-to-repository-storage\ntype ProjectReposityStorage struct {\n\tProjectID         int        `json:\"project_id\"`\n\tDiskPath          string     `json:\"disk_path\"`\n\tCreatedAt         *time.Time `json:\"created_at\"`\n\tRepositoryStorage string     `json:\"repository_storage\"`\n}\n\nfunc (s *ProjectsService) GetRepositoryStorage(pid interface{}, options ...RequestOptionFunc) (*ProjectReposityStorage, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/storage\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tprs := new(ProjectReposityStorage)\n\tresp, err := s.client.Do(req, prs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn prs, resp, nil\n}\n"
        },
        {
          "name": "projects_test.go",
          "type": "blob",
          "size": 55.705078125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tArchived:    Ptr(true),\n\t\tOrderBy:     Ptr(\"name\"),\n\t\tSort:        Ptr(\"asc\"),\n\t\tSearch:      Ptr(\"query\"),\n\t\tSimple:      Ptr(true),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\tprojects, _, err := client.Projects.ListProjects(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListUserProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/1/projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tArchived:    Ptr(true),\n\t\tOrderBy:     Ptr(\"name\"),\n\t\tSort:        Ptr(\"asc\"),\n\t\tSearch:      Ptr(\"query\"),\n\t\tSimple:      Ptr(true),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\tprojects, _, err := client.Projects.ListUserProjects(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListUserProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListUserProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListUserContributedProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/1/contributed_projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tArchived:    Bool(true),\n\t\tOrderBy:     String(\"name\"),\n\t\tSort:        String(\"asc\"),\n\t\tSearch:      String(\"query\"),\n\t\tSimple:      Bool(true),\n\t\tVisibility:  Visibility(PublicVisibility),\n\t}\n\n\tprojects, _, err := client.Projects.ListUserContributedProjects(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListUserContributedProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListUserContributedProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListUserStarredProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/1/starred_projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tArchived:    Ptr(true),\n\t\tOrderBy:     Ptr(\"name\"),\n\t\tSort:        Ptr(\"asc\"),\n\t\tSearch:      Ptr(\"query\"),\n\t\tSimple:      Ptr(true),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\tprojects, _, err := client.Projects.ListUserStarredProjects(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListUserStarredProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListUserStarredProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListProjectsUsersByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestURL(t, r, \"/api/v4/projects/1/users?page=2&per_page=3&search=query\")\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectUserOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tSearch:      Ptr(\"query\"),\n\t}\n\n\tprojects, _, err := client.Projects.ListProjectsUsers(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjectsUsers returned error: %v\", err)\n\t}\n\n\twant := []*ProjectUser{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListProjectsUsers returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListProjectsUsersByName(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestURL(t, r, \"/api/v4/projects/namespace%2Fname/users?page=2&per_page=3&search=query\")\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectUserOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tSearch:      Ptr(\"query\"),\n\t}\n\n\tprojects, _, err := client.Projects.ListProjectsUsers(\"namespace/name\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjectsUsers returned error: %v\", err)\n\t}\n\n\twant := []*ProjectUser{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListProjectsUsers returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestListProjectsGroupsByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestURL(t, r, \"/api/v4/projects/1/groups?page=2&per_page=3&search=query\")\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectGroupOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tSearch:      Ptr(\"query\"),\n\t}\n\n\tgroups, _, err := client.Projects.ListProjectsGroups(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjectsGroups returned error: %v\", err)\n\t}\n\n\twant := []*ProjectGroup{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, groups) {\n\t\tt.Errorf(\"Projects.ListProjectsGroups returned %+v, want %+v\", groups, want)\n\t}\n}\n\nfunc TestListProjectsGroupsByName(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestURL(t, r, \"/api/v4/projects/namespace%2Fname/groups?page=2&per_page=3&search=query\")\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectGroupOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tSearch:      Ptr(\"query\"),\n\t}\n\n\tgroups, _, err := client.Projects.ListProjectsGroups(\"namespace/name\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjectsGroups returned error: %v\", err)\n\t}\n\n\twant := []*ProjectGroup{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, groups) {\n\t\tt.Errorf(\"Projects.ListProjectsGroups returned %+v, want %+v\", groups, want)\n\t}\n}\n\nfunc TestListOwnedProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tArchived:    Ptr(true),\n\t\tOrderBy:     Ptr(\"name\"),\n\t\tSort:        Ptr(\"asc\"),\n\t\tSearch:      Ptr(\"query\"),\n\t\tSimple:      Ptr(true),\n\t\tOwned:       Ptr(true),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\tprojects, _, err := client.Projects.ListProjects(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListOwnedProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListOwnedProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestEditProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tvar developerRole AccessControlValue = \"developer\"\n\tdeveloperPipelineVariablesRole := CIPipelineVariablesDeveloperRole\n\topt := &EditProjectOptions{\n\t\tCIRestrictPipelineCancellationRole:     Ptr(developerRole),\n\t\tCIPipelineVariablesMinimumOverrideRole: Ptr(developerPipelineVariablesRole),\n\t}\n\n\t// Store whether we've seen all the attributes we set\n\tattributesFound := false\n\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\n\t\t// Check that our request properly included ci_restrict_pipeline_cancellation_role\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to read body properly. Error: %v\", err)\n\t\t}\n\n\t\t// Set the value to check if our value is included\n\t\tattributesFound = strings.Contains(string(body), \"ci_restrict_pipeline_cancellation_role\") &&\n\t\t\tstrings.Contains(string(body), \"ci_pipeline_variables_minimum_override_role\")\n\n\t\t// Print the start of the mock example from https://docs.gitlab.com/ee/api/projects.html#edit-project\n\t\t// including the attribute we edited\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n\t\t\t\"description_html\": \"<p data-sourcepos=\\\"1:1-1:56\\\" dir=\\\"auto\\\">Lorem ipsum dolor sit amet, consectetur adipiscing elit.</p>\",\n\t\t\t\"default_branch\": \"main\",\n\t\t\t\"visibility\": \"private\",\n\t\t\t\"ssh_url_to_repo\": \"git@example.com:diaspora/diaspora-project-site.git\",\n\t\t\t\"http_url_to_repo\": \"http://example.com/diaspora/diaspora-project-site.git\",\n\t\t\t\"web_url\": \"http://example.com/diaspora/diaspora-project-site\",\n\t\t\t\"readme_url\": \"http://example.com/diaspora/diaspora-project-site/blob/main/README.md\",\n\t\t\t\"ci_restrict_pipeline_cancellation_role\": \"developer\",\n\t\t\t\"ci_pipeline_variables_minimum_override_role\": \"developer\"\n\t\t}`)\n\t})\n\n\tproject, resp, err := client.Projects.EditProject(1, opt)\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\tassert.Equal(t, true, attributesFound)\n\tassert.Equal(t, developerRole, project.CIRestrictPipelineCancellationRole)\n\tassert.Equal(t, developerPipelineVariablesRole, project.CIPipelineVariablesMinimumOverrideRole)\n}\n\nfunc TestListStarredProjects(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{\n\t\tListOptions: ListOptions{Page: 2, PerPage: 3},\n\t\tArchived:    Ptr(true),\n\t\tOrderBy:     Ptr(\"name\"),\n\t\tSort:        Ptr(\"asc\"),\n\t\tSearch:      Ptr(\"query\"),\n\t\tSimple:      Ptr(true),\n\t\tStarred:     Ptr(true),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\tprojects, _, err := client.Projects.ListProjects(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListStarredProjects returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListStarredProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestGetProjectByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"container_registry_enabled\": true,\n\t\t\t\"container_expiration_policy\": {\n\t\t\t  \"cadence\": \"7d\",\n\t\t\t  \"enabled\": false,\n\t\t\t  \"keep_n\": null,\n\t\t\t  \"older_than\": null,\n\t\t\t  \"name_regex_delete\": null,\n\t\t\t  \"name_regex_keep\": null,\n\t\t\t  \"next_run_at\": \"2020-01-07T21:42:58.658Z\"\n\t\t\t},\n\t\t\t\"ci_forward_deployment_enabled\": true,\n\t\t\t\"ci_forward_deployment_rollback_allowed\": true,\n\t\t\t\"ci_restrict_pipeline_cancellation_role\": \"developer\",\n\t\t\t\"ci_pipeline_variables_minimum_override_role\": \"no_one_allowed\",\n\t\t\t\"packages_enabled\": false,\n\t\t\t\"build_coverage_regex\": \"Total.*([0-9]{1,3})%\"\n\t\t  }`)\n\t})\n\n\twantTimestamp := time.Date(2020, 0o1, 0o7, 21, 42, 58, 658000000, time.UTC)\n\twant := &Project{\n\t\tID:                       1,\n\t\tContainerRegistryEnabled: true,\n\t\tContainerExpirationPolicy: &ContainerExpirationPolicy{\n\t\t\tCadence:   \"7d\",\n\t\t\tNextRunAt: &wantTimestamp,\n\t\t},\n\t\tPackagesEnabled:                        false,\n\t\tBuildCoverageRegex:                     `Total.*([0-9]{1,3})%`,\n\t\tCIForwardDeploymentEnabled:             true,\n\t\tCIForwardDeploymentRollbackAllowed:     true,\n\t\tCIRestrictPipelineCancellationRole:     \"developer\",\n\t\tCIPipelineVariablesMinimumOverrideRole: \"no_one_allowed\",\n\t}\n\n\tproject, _, err := client.Projects.GetProject(1, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.GetProject returns an error: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(want, project) {\n\t\tt.Errorf(\"Projects.GetProject returned %+v, want %+v\", project, want)\n\t}\n}\n\nfunc TestGetProjectByName(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestURL(t, r, \"/api/v4/projects/namespace%2Fname\")\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &Project{ID: 1}\n\n\tproject, _, err := client.Projects.GetProject(\"namespace/name\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.GetProject returns an error: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(want, project) {\n\t\tt.Errorf(\"Projects.GetProject returned %+v, want %+v\", project, want)\n\t}\n}\n\nfunc TestGetProjectWithOptions(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\":1,\n\t\t\t\"statistics\": {\n\t\t\t\t\"commit_count\": 37,\n\t\t\t\t\"storage_size\": 1038090,\n\t\t\t\t\"repository_size\": 1038090,\n\t\t\t\t\"wiki_size\": 10,\n\t\t\t\t\"lfs_objects_size\": 0,\n\t\t\t\t\"job_artifacts_size\": 0,\n\t\t\t\t\"pipeline_artifacts_size\": 0,\n\t\t\t\t\"packages_size\": 238906167,\n\t\t\t\t\"snippets_size\": 146800,\n\t\t\t\t\"uploads_size\": 6523619,\n\t\t\t\t\"container_registry_size\": 284453\n\t\t\t}}`)\n\t})\n\twant := &Project{ID: 1, Statistics: &Statistics{\n\t\tCommitCount:           37,\n\t\tStorageSize:           1038090,\n\t\tRepositorySize:        1038090,\n\t\tWikiSize:              10,\n\t\tLFSObjectsSize:        0,\n\t\tJobArtifactsSize:      0,\n\t\tPipelineArtifactsSize: 0,\n\t\tPackagesSize:          238906167,\n\t\tSnippetsSize:          146800,\n\t\tUploadsSize:           6523619,\n\t\tContainerRegistrySize: 284453,\n\t}}\n\n\tproject, _, err := client.Projects.GetProject(1, &GetProjectOptions{Statistics: Ptr(true)})\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.GetProject returns an error: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(want, project) {\n\t\tt.Errorf(\"Projects.GetProject returned %+v, want %+v\", project, want)\n\t}\n}\n\nfunc TestCreateProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\n\topt := &CreateProjectOptions{\n\t\tName:        Ptr(\"n\"),\n\t\tMergeMethod: Ptr(RebaseMerge),\n\t}\n\n\tproject, _, err := client.Projects.CreateProject(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.CreateProject returned error: %v\", err)\n\t}\n\n\twant := &Project{ID: 1}\n\tif !reflect.DeepEqual(want, project) {\n\t\tt.Errorf(\"Projects.CreateProject returned %+v, want %+v\", project, want)\n\t}\n}\n\nfunc TestUploadFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data;\") {\n\t\t\tt.Fatalf(\"Projects.UploadFile request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Projects.UploadFile request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{\n\t\t  \"alt\": \"dk\",\n\t\t\t\"url\": \"/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.md\",\n\t\t\t\"markdown\": \"![dk](/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png)\"\n\t\t}`)\n\t})\n\n\twant := &ProjectFile{\n\t\tAlt:      \"dk\",\n\t\tURL:      \"/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.md\",\n\t\tMarkdown: \"![dk](/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png)\",\n\t}\n\n\tfile := bytes.NewBufferString(\"dummy\")\n\tprojectFile, _, err := client.Projects.UploadFile(1, file, \"test.txt\")\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.UploadFile returns an error: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(want, projectFile) {\n\t\tt.Errorf(\"Projects.UploadFile returned %+v, want %+v\", projectFile, want)\n\t}\n}\n\nfunc TestUploadFile_Retry(t *testing.T) {\n\tmux, client := setup(t)\n\n\ttf, _ := os.CreateTemp(os.TempDir(), \"test\")\n\tdefer os.Remove(tf.Name())\n\n\tisFirstRequest := true\n\tmux.HandleFunc(\"/api/v4/projects/1/uploads\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif isFirstRequest {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\tisFirstRequest = false\n\t\t\treturn\n\t\t}\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data;\") {\n\t\t\tt.Fatalf(\"Projects.UploadFile request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Projects.UploadFile request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{\n                  \"alt\": \"dk\",\n                    \"url\": \"/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.md\",\n                    \"markdown\": \"![dk](/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png)\"\n                }`)\n\t})\n\n\twant := &ProjectFile{\n\t\tAlt:      \"dk\",\n\t\tURL:      \"/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.md\",\n\t\tMarkdown: \"![dk](/uploads/66dbcd21ec5d24ed6ea225176098d52b/dk.png)\",\n\t}\n\n\tfile := bytes.NewBufferString(\"dummy\")\n\tprojectFile, _, err := client.Projects.UploadFile(1, file, \"test.txt\")\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.UploadFile returns an error: %v\", err)\n\t}\n\n\tif !reflect.DeepEqual(want, projectFile) {\n\t\tt.Errorf(\"Projects.UploadFile returned %+v, want %+v\", projectFile, want)\n\t}\n}\n\nfunc TestUploadAvatar(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data;\") {\n\t\t\tt.Fatalf(\"Projects.UploadAvatar request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Projects.UploadAvatar request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{}`)\n\t})\n\n\tavatar := new(bytes.Buffer)\n\t_, _, err := client.Projects.UploadAvatar(1, avatar, \"avatar.png\")\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.UploadAvatar returns an error: %v\", err)\n\t}\n}\n\nfunc TestUploadAvatar_Retry(t *testing.T) {\n\tmux, client := setup(t)\n\n\tisFirstRequest := true\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif isFirstRequest {\n\t\t\thttp.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)\n\t\t\tisFirstRequest = false\n\t\t\treturn\n\t\t}\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data;\") {\n\t\t\tt.Fatalf(\"Projects.UploadAvatar request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Projects.UploadAvatar request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{}`)\n\t})\n\n\tavatar := new(bytes.Buffer)\n\t_, _, err := client.Projects.UploadAvatar(1, avatar, \"avatar.png\")\n\tif err != nil {\n\t\tt.Fatalf(\"Projects.UploadAvatar returns an error: %v\", err)\n\t}\n}\n\nfunc TestListProjectForks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestURL(t, r, \"/api/v4/projects/namespace%2Fname/forks?archived=true&order_by=name&page=2&per_page=3&search=query&simple=true&sort=asc&visibility=public\")\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\n\topt := &ListProjectsOptions{}\n\topt.ListOptions = ListOptions{Page: 2, PerPage: 3}\n\topt.Archived = Ptr(true)\n\topt.OrderBy = Ptr(\"name\")\n\topt.Sort = Ptr(\"asc\")\n\topt.Search = Ptr(\"query\")\n\topt.Simple = Ptr(true)\n\topt.Visibility = Ptr(PublicVisibility)\n\n\tprojects, _, err := client.Projects.ListProjectForks(\"namespace/name\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjectForks returned error: %v\", err)\n\t}\n\n\twant := []*Project{{ID: 1}, {ID: 2}}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestDeleteProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\topt := &DeleteProjectOptions{\n\t\tFullPath:          Ptr(\"group/project\"),\n\t\tPermanentlyRemove: Ptr(true),\n\t}\n\n\t_, err := client.Projects.DeleteProject(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.DeleteProject returned error: %v\", err)\n\t}\n}\n\nfunc TestShareProjectWithGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/share\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t})\n\n\topt := &ShareWithGroupOptions{\n\t\tGroupID:     Ptr(1),\n\t\tGroupAccess: Ptr(AccessLevelValue(50)),\n\t}\n\n\t_, err := client.Projects.ShareProjectWithGroup(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ShareProjectWithGroup returned error: %v\", err)\n\t}\n}\n\nfunc TestDeleteSharedProjectFromGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/share/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Projects.DeleteSharedProjectFromGroup(1, 2)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.DeleteSharedProjectFromGroup returned error: %v\", err)\n\t}\n}\n\nfunc TestGetApprovalConfiguration(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approvals\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"approvers\": [],\n\t\t\t\"approver_groups\": [],\n\t\t\t\"approvals_before_merge\": 3,\n\t\t\t\"reset_approvals_on_push\": false,\n\t\t\t\"disable_overriding_approvers_per_merge_request\": false,\n\t\t\t\"merge_requests_author_approval\": true,\n\t\t\t\"merge_requests_disable_committers_approval\": true,\n\t\t\t\"require_password_to_approve\": true\n\t\t}`)\n\t})\n\n\tapprovals, _, err := client.Projects.GetApprovalConfiguration(1)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetApprovalConfiguration returned error: %v\", err)\n\t}\n\n\twant := &ProjectApprovals{\n\t\tApprovers:            []*MergeRequestApproverUser{},\n\t\tApproverGroups:       []*MergeRequestApproverGroup{},\n\t\tApprovalsBeforeMerge: 3,\n\t\tResetApprovalsOnPush: false,\n\t\tDisableOverridingApproversPerMergeRequest: false,\n\t\tMergeRequestsAuthorApproval:               true,\n\t\tMergeRequestsDisableCommittersApproval:    true,\n\t\tRequirePasswordToApprove:                  true,\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"Projects.GetApprovalConfiguration returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestChangeApprovalConfiguration(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approvals\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestBody(t, r, `{\"approvals_before_merge\":3}`)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"approvers\": [],\n\t\t\t\"approver_groups\": [],\n\t\t\t\"approvals_before_merge\": 3,\n\t\t\t\"reset_approvals_on_push\": false,\n\t\t\t\"disable_overriding_approvers_per_merge_request\": false,\n\t\t\t\"merge_requests_author_approval\": true,\n\t\t\t\"merge_requests_disable_committers_approval\": true,\n\t\t\t\"require_password_to_approve\": true\n\t\t}`)\n\t})\n\n\topt := &ChangeApprovalConfigurationOptions{\n\t\tApprovalsBeforeMerge: Ptr(3),\n\t}\n\n\tapprovals, _, err := client.Projects.ChangeApprovalConfiguration(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ChangeApprovalConfigurationOptions returned error: %v\", err)\n\t}\n\n\twant := &ProjectApprovals{\n\t\tApprovers:            []*MergeRequestApproverUser{},\n\t\tApproverGroups:       []*MergeRequestApproverGroup{},\n\t\tApprovalsBeforeMerge: 3,\n\t\tResetApprovalsOnPush: false,\n\t\tDisableOverridingApproversPerMergeRequest: false,\n\t\tMergeRequestsAuthorApproval:               true,\n\t\tMergeRequestsDisableCommittersApproval:    true,\n\t\tRequirePasswordToApprove:                  true,\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"Projects.ChangeApprovalConfigurationOptions  returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestChangeAllowedApprovers(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approvers\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\ttestBody(t, r, `{\"approver_group_ids\":[1],\"approver_ids\":[2]}`)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"approver_groups\": [{\"group\":{\"id\":1}}],\n\t\t\t\"approvers\": [{\"user\":{\"id\":2}}]\n\t\t}`)\n\t})\n\n\topt := &ChangeAllowedApproversOptions{\n\t\tApproverGroupIDs: &[]int{1},\n\t\tApproverIDs:      &[]int{2},\n\t}\n\n\tapprovals, _, err := client.Projects.ChangeAllowedApprovers(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ChangeApproversConfigurationOptions returned error: %v\", err)\n\t}\n\n\twant := &ProjectApprovals{\n\t\tApproverGroups: []*MergeRequestApproverGroup{\n\t\t\t{\n\t\t\t\tGroup: struct {\n\t\t\t\t\tID                   int    `json:\"id\"`\n\t\t\t\t\tName                 string `json:\"name\"`\n\t\t\t\t\tPath                 string `json:\"path\"`\n\t\t\t\t\tDescription          string `json:\"description\"`\n\t\t\t\t\tVisibility           string `json:\"visibility\"`\n\t\t\t\t\tAvatarURL            string `json:\"avatar_url\"`\n\t\t\t\t\tWebURL               string `json:\"web_url\"`\n\t\t\t\t\tFullName             string `json:\"full_name\"`\n\t\t\t\t\tFullPath             string `json:\"full_path\"`\n\t\t\t\t\tLFSEnabled           bool   `json:\"lfs_enabled\"`\n\t\t\t\t\tRequestAccessEnabled bool   `json:\"request_access_enabled\"`\n\t\t\t\t}{\n\t\t\t\t\tID: 1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tApprovers: []*MergeRequestApproverUser{\n\t\t\t{\n\t\t\t\tUser: &BasicUser{\n\t\t\t\t\tID: 2,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"Projects.ChangeAllowedApprovers returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestForkProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tnamespaceID := 42\n\tname := \"myreponame\"\n\tpath := \"myrepopath\"\n\n\tmux.HandleFunc(\"/api/v4/projects/1/fork\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\ttestBody(t, r, fmt.Sprintf(`{\"name\":\"%s\",\"namespace_id\":%d,\"path\":\"%s\"}`, name, namespaceID, path))\n\t\tfmt.Fprint(w, `{\"id\":2}`)\n\t})\n\n\tproject, _, err := client.Projects.ForkProject(1, &ForkProjectOptions{\n\t\tNamespaceID: Ptr(namespaceID),\n\t\tName:        Ptr(name),\n\t\tPath:        Ptr(path),\n\t})\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ForkProject returned error: %v\", err)\n\t}\n\n\twant := &Project{ID: 2}\n\tif !reflect.DeepEqual(want, project) {\n\t\tt.Errorf(\"Projects.ForProject returned %+v, want %+v\", project, want)\n\t}\n}\n\nfunc TestGetProjectApprovalRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approval_rules\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t\t{\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"security\",\n\t\t\t\t\"rule_type\": \"regular\",\n\t\t\t\t\"eligible_approvers\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 50,\n\t\t\t\t\t\t\"name\": \"Group Member 1\",\n\t\t\t\t\t\t\"username\": \"group_member_1\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/group_member_1\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"approvals_required\": 3,\n\t\t\t\t\"users\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"groups\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\t\"name\": \"group1\",\n\t\t\t\t\t\t\"path\": \"group1\",\n\t\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\t\t\"lfs_enabled\": false,\n\t\t\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\t\t\"web_url\": \"http://localhost/groups/group1\",\n\t\t\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\t\t\"full_name\": \"group1\",\n\t\t\t\t\t\t\"full_path\": \"group1\",\n\t\t\t\t\t\t\"parent_id\": null,\n\t\t\t\t\t\t\"ldap_cn\": null,\n\t\t\t\t\t\t\"ldap_access\": null\n\t\t\t\t\t}\n\t\t\t\t],\n\t\t\t\t\"protected_branches\": [\n\t\t\t\t\t  {\n\t\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\t\"name\": \"master\",\n\t\t\t\t\t\t\"push_access_levels\": [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\t\"access_level_description\": \"Developers + Maintainers\"\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"merge_access_levels\": [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\t\"access_level_description\": \"Developers + Maintainers\"\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"unprotect_access_levels\": [\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\"access_level\": 40,\n\t\t\t\t\t\t\t\"access_level_description\": \"Maintainers\"\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t],\n\t\t\t\t\t\t\"code_owner_approval_required\": false\n\t\t\t\t\t  }\n                ],\n\t\t\t\t\"contains_hidden_groups\": false\n\t\t\t}\n\t\t]`)\n\t})\n\n\tapprovals, _, err := client.Projects.GetProjectApprovalRules(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetProjectApprovalRules returned error: %v\", err)\n\t}\n\n\twant := []*ProjectApprovalRule{\n\t\t{\n\t\t\tID:       1,\n\t\t\tName:     \"security\",\n\t\t\tRuleType: \"regular\",\n\t\t\tEligibleApprovers: []*BasicUser{\n\t\t\t\t{\n\t\t\t\t\tID:        5,\n\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:        50,\n\t\t\t\t\tName:      \"Group Member 1\",\n\t\t\t\t\tUsername:  \"group_member_1\",\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\tWebURL:    \"http://localhost/group_member_1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tApprovalsRequired: 3,\n\t\t\tUsers: []*BasicUser{\n\t\t\t\t{\n\t\t\t\t\tID:        5,\n\t\t\t\t\tName:      \"John Doe\",\n\t\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\t\tState:     \"active\",\n\t\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tGroups: []*Group{\n\t\t\t\t{\n\t\t\t\t\tID:                   5,\n\t\t\t\t\tName:                 \"group1\",\n\t\t\t\t\tPath:                 \"group1\",\n\t\t\t\t\tDescription:          \"\",\n\t\t\t\t\tVisibility:           PublicVisibility,\n\t\t\t\t\tLFSEnabled:           false,\n\t\t\t\t\tAvatarURL:            \"\",\n\t\t\t\t\tWebURL:               \"http://localhost/groups/group1\",\n\t\t\t\t\tRequestAccessEnabled: false,\n\t\t\t\t\tFullName:             \"group1\",\n\t\t\t\t\tFullPath:             \"group1\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tProtectedBranches: []*ProtectedBranch{\n\t\t\t\t{\n\t\t\t\t\tID:   1,\n\t\t\t\t\tName: \"master\",\n\t\t\t\t\tPushAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tMergeAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tUnprotectAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tAllowForcePush:            false,\n\t\t\t\t\tCodeOwnerApprovalRequired: false,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"Projects.GetProjectApprovalRules returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestGetProjectApprovalRule(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approval_rules/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"security\",\n\t\t\t\"rule_type\": \"regular\",\n\t\t\t\"eligible_approvers\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": 50,\n\t\t\t\t\t\"name\": \"Group Member 1\",\n\t\t\t\t\t\"username\": \"group_member_1\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/group_member_1\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"approvals_required\": 3,\n\t\t\t\"users\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"groups\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"group1\",\n\t\t\t\t\t\"path\": \"group1\",\n\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\t\"lfs_enabled\": false,\n\t\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\t\"web_url\": \"http://localhost/groups/group1\",\n\t\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\t\"full_name\": \"group1\",\n\t\t\t\t\t\"full_path\": \"group1\",\n\t\t\t\t\t\"parent_id\": null,\n\t\t\t\t\t\"ldap_cn\": null,\n\t\t\t\t\t\"ldap_access\": null\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"protected_branches\": [\n\t\t\t\t\t{\n\t\t\t\t\t\"id\": 1,\n\t\t\t\t\t\"name\": \"master\",\n\t\t\t\t\t\"push_access_levels\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\"access_level_description\": \"Developers + Maintainers\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"merge_access_levels\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"access_level\": 30,\n\t\t\t\t\t\t\"access_level_description\": \"Developers + Maintainers\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"unprotect_access_levels\": [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\"access_level\": 40,\n\t\t\t\t\t\t\"access_level_description\": \"Maintainers\"\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t\"code_owner_approval_required\": false\n\t\t\t\t\t}\n\t\t\t],\n\t\t\t\"contains_hidden_groups\": false\n\t\t}`)\n\t})\n\n\tapprovals, _, err := client.Projects.GetProjectApprovalRule(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetProjectApprovalRule returned error: %v\", err)\n\t}\n\n\twant := &ProjectApprovalRule{\n\t\tID:       1,\n\t\tName:     \"security\",\n\t\tRuleType: \"regular\",\n\t\tEligibleApprovers: []*BasicUser{\n\t\t\t{\n\t\t\t\tID:        5,\n\t\t\t\tName:      \"John Doe\",\n\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:        50,\n\t\t\t\tName:      \"Group Member 1\",\n\t\t\t\tUsername:  \"group_member_1\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/group_member_1\",\n\t\t\t},\n\t\t},\n\t\tApprovalsRequired: 3,\n\t\tUsers: []*BasicUser{\n\t\t\t{\n\t\t\t\tID:        5,\n\t\t\t\tName:      \"John Doe\",\n\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t},\n\t\t},\n\t\tGroups: []*Group{\n\t\t\t{\n\t\t\t\tID:                   5,\n\t\t\t\tName:                 \"group1\",\n\t\t\t\tPath:                 \"group1\",\n\t\t\t\tDescription:          \"\",\n\t\t\t\tVisibility:           PublicVisibility,\n\t\t\t\tLFSEnabled:           false,\n\t\t\t\tAvatarURL:            \"\",\n\t\t\t\tWebURL:               \"http://localhost/groups/group1\",\n\t\t\t\tRequestAccessEnabled: false,\n\t\t\t\tFullName:             \"group1\",\n\t\t\t\tFullPath:             \"group1\",\n\t\t\t},\n\t\t},\n\t\tProtectedBranches: []*ProtectedBranch{\n\t\t\t{\n\t\t\t\tID:   1,\n\t\t\t\tName: \"master\",\n\t\t\t\tPushAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tMergeAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tUnprotectAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAllowForcePush:            false,\n\t\t\t\tCodeOwnerApprovalRequired: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, approvals) {\n\t\tt.Errorf(\"Projects.GetProjectApprovalRule returned %+v, want %+v\", approvals, want)\n\t}\n}\n\nfunc TestCreateProjectApprovalRule(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approval_rules\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"security\",\n\t\t\t\"rule_type\": \"regular\",\n\t\t\t\"eligible_approvers\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"id\": 50,\n\t\t\t\t\t\"name\": \"Group Member 1\",\n\t\t\t\t\t\"username\": \"group_member_1\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/group_member_1\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"approvals_required\": 3,\n\t\t\t\"users\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"John Doe\",\n\t\t\t\t\t\"username\": \"jdoe\",\n\t\t\t\t\t\"state\": \"active\",\n\t\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\t\t\"web_url\": \"http://localhost/jdoe\"\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"groups\": [\n\t\t\t\t{\n\t\t\t\t\t\"id\": 5,\n\t\t\t\t\t\"name\": \"group1\",\n\t\t\t\t\t\"path\": \"group1\",\n\t\t\t\t\t\"description\": \"\",\n\t\t\t\t\t\"visibility\": \"public\",\n\t\t\t\t\t\"lfs_enabled\": false,\n\t\t\t\t\t\"avatar_url\": null,\n\t\t\t\t\t\"web_url\": \"http://localhost/groups/group1\",\n\t\t\t\t\t\"request_access_enabled\": false,\n\t\t\t\t\t\"full_name\": \"group1\",\n\t\t\t\t\t\"full_path\": \"group1\",\n\t\t\t\t\t\"parent_id\": null,\n\t\t\t\t\t\"ldap_cn\": null,\n\t\t\t\t\t\"ldap_access\": null\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"protected_branches\": [\n\t\t\t\t{\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"master\",\n\t\t\t\t  \"push_access_levels\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"access_level\": 30,\n\t\t\t\t\t  \"access_level_description\": \"Developers + Maintainers\"\n\t\t\t\t\t}\n\t\t\t\t  ],\n\t\t\t\t  \"merge_access_levels\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"access_level\": 30,\n\t\t\t\t\t  \"access_level_description\": \"Developers + Maintainers\"\n\t\t\t\t\t}\n\t\t\t\t  ],\n\t\t\t\t  \"unprotect_access_levels\": [\n\t\t\t\t\t{\n\t\t\t\t\t  \"access_level\": 40,\n\t\t\t\t\t  \"access_level_description\": \"Maintainers\"\n\t\t\t\t\t}\n\t\t\t\t  ],\n\t\t\t\t  \"code_owner_approval_required\": false\n\t\t\t\t}\n\t\t\t],\n\t\t\t\"contains_hidden_groups\": false\n\t\t}`)\n\t})\n\n\topt := &CreateProjectLevelRuleOptions{\n\t\tName:              Ptr(\"security\"),\n\t\tApprovalsRequired: Ptr(3),\n\t\tUserIDs:           &[]int{5, 50},\n\t\tGroupIDs:          &[]int{5},\n\t\tReportType:        String(\"code_coverage\"),\n\t}\n\n\trule, _, err := client.Projects.CreateProjectApprovalRule(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.CreateProjectApprovalRule returned error: %v\", err)\n\t}\n\n\twant := &ProjectApprovalRule{\n\t\tID:       1,\n\t\tName:     \"security\",\n\t\tRuleType: \"regular\",\n\t\tEligibleApprovers: []*BasicUser{\n\t\t\t{\n\t\t\t\tID:        5,\n\t\t\t\tName:      \"John Doe\",\n\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tID:        50,\n\t\t\t\tName:      \"Group Member 1\",\n\t\t\t\tUsername:  \"group_member_1\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/group_member_1\",\n\t\t\t},\n\t\t},\n\t\tApprovalsRequired: 3,\n\t\tUsers: []*BasicUser{\n\t\t\t{\n\t\t\t\tID:        5,\n\t\t\t\tName:      \"John Doe\",\n\t\t\t\tUsername:  \"jdoe\",\n\t\t\t\tState:     \"active\",\n\t\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/0?s=80&d=identicon\",\n\t\t\t\tWebURL:    \"http://localhost/jdoe\",\n\t\t\t},\n\t\t},\n\t\tGroups: []*Group{\n\t\t\t{\n\t\t\t\tID:                   5,\n\t\t\t\tName:                 \"group1\",\n\t\t\t\tPath:                 \"group1\",\n\t\t\t\tDescription:          \"\",\n\t\t\t\tVisibility:           PublicVisibility,\n\t\t\t\tLFSEnabled:           false,\n\t\t\t\tAvatarURL:            \"\",\n\t\t\t\tWebURL:               \"http://localhost/groups/group1\",\n\t\t\t\tRequestAccessEnabled: false,\n\t\t\t\tFullName:             \"group1\",\n\t\t\t\tFullPath:             \"group1\",\n\t\t\t},\n\t\t},\n\t\tProtectedBranches: []*ProtectedBranch{\n\t\t\t{\n\t\t\t\tID:   1,\n\t\t\t\tName: \"master\",\n\t\t\t\tPushAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tMergeAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tUnprotectAccessLevels: []*BranchAccessDescription{\n\t\t\t\t\t{\n\t\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tAllowForcePush:            false,\n\t\t\t\tCodeOwnerApprovalRequired: false,\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Projects.CreateProjectApprovalRule returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestGetProjectPullMirrorDetails(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/mirror/pull\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t  \"id\": 101486,\n\t\t  \"last_error\": null,\n\t\t  \"last_successful_update_at\": \"2020-01-06T17:32:02.823Z\",\n\t\t  \"last_update_at\": \"2020-01-06T17:32:02.823Z\",\n\t\t  \"last_update_started_at\": \"2020-01-06T17:31:55.864Z\",\n\t\t  \"update_status\": \"finished\",\n\t\t  \"url\": \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\"\n\t\t}`)\n\t})\n\n\tpullMirror, _, err := client.Projects.GetProjectPullMirrorDetails(1)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetProjectPullMirrorDetails returned error: %v\", err)\n\t}\n\n\twantLastSuccessfulUpdateAtTimestamp := time.Date(2020, 0o1, 0o6, 17, 32, 0o2, 823000000, time.UTC)\n\twantLastUpdateAtTimestamp := time.Date(2020, 0o1, 0o6, 17, 32, 0o2, 823000000, time.UTC)\n\twantLastUpdateStartedAtTimestamp := time.Date(2020, 0o1, 0o6, 17, 31, 55, 864000000, time.UTC)\n\twant := &ProjectPullMirrorDetails{\n\t\tID:                     101486,\n\t\tLastError:              \"\",\n\t\tLastSuccessfulUpdateAt: &wantLastSuccessfulUpdateAtTimestamp,\n\t\tLastUpdateAt:           &wantLastUpdateAtTimestamp,\n\t\tLastUpdateStartedAt:    &wantLastUpdateStartedAtTimestamp,\n\t\tUpdateStatus:           \"finished\",\n\t\tURL:                    \"https://*****:*****@gitlab.com/gitlab-org/security/gitlab.git\",\n\t}\n\n\tif !reflect.DeepEqual(want, pullMirror) {\n\t\tt.Errorf(\"Projects.GetProjectPullMirrorDetails returned %+v, want %+v\", pullMirror, want)\n\t}\n}\n\nfunc TestCreateProjectApprovalRuleEligibleApprovers(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/approval_rules\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Any name\",\n\t\t\t\"rule_type\": \"any_approver\",\n\t\t\t\"eligible_approvers\": [],\n\t\t\t\"approvals_required\": 1,\n\t\t\t\"users\": [],\n\t\t\t\"groups\": [],\n\t\t\t\"contains_hidden_groups\": false,\n\t\t\t\"protected_branches\": []\n\t\t}`)\n\t})\n\n\topt := &CreateProjectLevelRuleOptions{\n\t\tName:              Ptr(\"Any name\"),\n\t\tApprovalsRequired: Ptr(1),\n\t}\n\n\trule, _, err := client.Projects.CreateProjectApprovalRule(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.CreateProjectApprovalRule returned error: %v\", err)\n\t}\n\n\twant := &ProjectApprovalRule{\n\t\tID:                1,\n\t\tName:              \"Any name\",\n\t\tRuleType:          \"any_approver\",\n\t\tEligibleApprovers: []*BasicUser{},\n\t\tApprovalsRequired: 1,\n\t\tUsers:             []*BasicUser{},\n\t\tGroups:            []*Group{},\n\t\tProtectedBranches: []*ProtectedBranch{},\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Projects.CreateProjectApprovalRule returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestProjectModelsOptionalMergeAttribute(t *testing.T) {\n\t// Create a `CreateProjectOptions` struct, ensure that merge attribute doesn't serialize\n\tjsonString, err := json.Marshal(&CreateProjectOptions{\n\t\tName: Ptr(\"testProject\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(\"Failed to marshal object\", err)\n\t}\n\tassert.False(t, strings.Contains(string(jsonString), \"only_allow_merge_if_all_status_checks_passed\"))\n\n\t// Test the same thing but for `EditProjectOptions` struct\n\tjsonString, err = json.Marshal(&EditProjectOptions{\n\t\tName: Ptr(\"testProject\"),\n\t})\n\tif err != nil {\n\t\tt.Fatal(\"Failed to marshal object\", err)\n\t}\n\tassert.False(t, strings.Contains(string(jsonString), \"only_allow_merge_if_all_status_checks_passed\"))\n}\n\nfunc TestListProjectHooks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/hooks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t{\n\t\t\"id\": 1,\n\t\t\"url\": \"http://example.com/hook\",\n\t\t\"name\": \"This is the name of an example hook\",\n\t\t\"description\": \"This is the description of an example hook\",\n\t\t\"confidential_note_events\": true,\n\t\t\"project_id\": 1,\n\t\t\"push_events\": true,\n\t\t\"push_events_branch_filter\": \"main\",\n\t\t\"issues_events\": true,\n\t\t\"confidential_issues_events\": true,\n\t\t\"merge_requests_events\": true,\n\t\t\"tag_push_events\": true,\n\t\t\"note_events\": true,\n\t\t\"job_events\": true,\n\t\t\"pipeline_events\": true,\n\t\t\"wiki_page_events\": true,\n\t\t\"deployment_events\": true,\n\t\t\"releases_events\": true,\n\t\t\"enable_ssl_verification\": true,\n\t\t\"alert_status\": \"executable\",\n\t\t\"created_at\": \"2024-10-13T13:37:00Z\",\n\t\t\"resource_access_token_events\": true,\n\t\t\"custom_webhook_template\": \"my custom template\",\n\t\t\"custom_headers\": [\n\t\t\t{\"key\": \"Authorization\"},\n\t\t\t{\"key\": \"OtherHeader\"}\n\t\t]\n\t}\n]`)\n\t})\n\n\thooks, _, err := client.Projects.ListProjectHooks(1, nil)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.ListProjectHooks returned error: %v\", err)\n\t}\n\n\tcreatedAt := time.Date(2024, 10, 13, 13, 37, 0, 0, time.UTC)\n\twant := []*ProjectHook{{\n\t\tID:                        1,\n\t\tURL:                       \"http://example.com/hook\",\n\t\tName:                      \"This is the name of an example hook\",\n\t\tDescription:               \"This is the description of an example hook\",\n\t\tConfidentialNoteEvents:    true,\n\t\tProjectID:                 1,\n\t\tPushEvents:                true,\n\t\tPushEventsBranchFilter:    \"main\",\n\t\tIssuesEvents:              true,\n\t\tConfidentialIssuesEvents:  true,\n\t\tMergeRequestsEvents:       true,\n\t\tTagPushEvents:             true,\n\t\tNoteEvents:                true,\n\t\tJobEvents:                 true,\n\t\tPipelineEvents:            true,\n\t\tWikiPageEvents:            true,\n\t\tDeploymentEvents:          true,\n\t\tReleasesEvents:            true,\n\t\tEnableSSLVerification:     true,\n\t\tCreatedAt:                 &createdAt,\n\t\tAlertStatus:               \"executable\",\n\t\tResourceAccessTokenEvents: true,\n\t\tCustomWebhookTemplate:     \"my custom template\",\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey: \"Authorization\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey: \"OtherHeader\",\n\t\t\t},\n\t\t},\n\t}}\n\n\tif !reflect.DeepEqual(hooks, want) {\n\t\tt.Errorf(\"Projects.ListProjectHooks returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(hooks), Stringify(want))\n\t}\n}\n\n// Test that the \"CustomWebhookTemplate\" serializes properly\nfunc TestProjectAddWebhook_CustomTemplateStuff(t *testing.T) {\n\tmux, client := setup(t)\n\tcustomWebhookSet := false\n\tauthValueSet := false\n\n\tmux.HandleFunc(\"/api/v4/projects/1/hooks\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tw.WriteHeader(http.StatusCreated)\n\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unable to read body properly. Error: %v\", err)\n\t\t\t}\n\t\t\tcustomWebhookSet = strings.Contains(string(body), \"custom_webhook_template\")\n\t\t\tauthValueSet = strings.Contains(string(body), `\"value\":\"stuff\"`)\n\n\t\t\tfmt.Fprint(w, `{\n\t\t\t\t\"custom_webhook_template\": \"testValue\",\n\t\t\t\t\"custom_headers\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"key\": \"Authorization\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"key\": \"Favorite-Pet\"\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t}`)\n\t\t},\n\t)\n\n\thook, resp, err := client.Projects.AddProjectHook(1, &AddProjectHookOptions{\n\t\tCustomWebhookTemplate: Ptr(`{\"example\":\"{{object_kind}}\"}`),\n\t\tCustomHeaders: &[]*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey:   \"Authorization\",\n\t\t\t\tValue: \"stuff\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey:   \"Favorite-Pet\",\n\t\t\t\tValue: \"Cats\",\n\t\t\t},\n\t\t},\n\t})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusCreated, resp.StatusCode)\n\tassert.Equal(t, true, customWebhookSet)\n\tassert.Equal(t, true, authValueSet)\n\tassert.Equal(t, \"testValue\", hook.CustomWebhookTemplate)\n\tassert.Equal(t, 2, len(hook.CustomHeaders))\n}\n\n// Test that the \"CustomWebhookTemplate\" serializes properly when editing\nfunc TestProjectEditWebhook_CustomTemplateStuff(t *testing.T) {\n\tmux, client := setup(t)\n\tcustomWebhookSet := false\n\tauthValueSet := false\n\n\tmux.HandleFunc(\"/api/v4/projects/1/hooks/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tw.WriteHeader(http.StatusOK)\n\n\t\t\tbody, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Unable to read body properly. Error: %v\", err)\n\t\t\t}\n\t\t\tcustomWebhookSet = strings.Contains(string(body), \"custom_webhook_template\")\n\t\t\tauthValueSet = strings.Contains(string(body), `\"value\":\"stuff\"`)\n\n\t\t\tfmt.Fprint(w, `{\n\t\t\t\t\"custom_webhook_template\": \"testValue\",\n\t\t\t\t\"custom_headers\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"key\": \"Authorization\"\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"key\": \"Favorite-Pet\"\n\t\t\t\t\t}\n\t\t\t\t]}`)\n\t\t},\n\t)\n\n\thook, resp, err := client.Projects.EditProjectHook(1, 1, &EditProjectHookOptions{\n\t\tCustomWebhookTemplate: Ptr(`{\"example\":\"{{object_kind}}\"}`),\n\t\tCustomHeaders: &[]*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey:   \"Authorization\",\n\t\t\t\tValue: \"stuff\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey:   \"Favorite-Pet\",\n\t\t\t\tValue: \"Cats\",\n\t\t\t},\n\t\t},\n\t})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\tassert.Equal(t, true, customWebhookSet)\n\tassert.Equal(t, true, authValueSet)\n\tassert.Equal(t, \"testValue\", hook.CustomWebhookTemplate)\n\tassert.Equal(t, 2, len(hook.CustomHeaders))\n}\n\nfunc TestGetProjectPushRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/push_rule\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"commit_message_regex\": \"Fixes \\\\d+\\\\..*\",\n\t\t\t\"commit_message_negative_regex\": \"ssh\\\\:\\\\/\\\\/\",\n\t\t\t\"branch_name_regex\": \"(feat|fix)\\\\/*\",\n\t\t\t\"deny_delete_tag\": false,\n\t\t\t\"member_check\": false,\n\t\t\t\"prevent_secrets\": false,\n\t\t\t\"author_email_regex\": \"@company.com$\",\n\t\t\t\"file_name_regex\": \"(jar|exe)$\",\n\t\t\t\"max_file_size\": 5,\n\t\t\t\"commit_committer_check\": false,\n\t\t\t\"commit_committer_name_check\": false,\n\t\t\t\"reject_unsigned_commits\": false,\n\t\t\t\"reject_non_dco_commits\": false\n\t\t  }`)\n\t})\n\n\trule, _, err := client.Projects.GetProjectPushRules(1)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetProjectPushRules returned error: %v\", err)\n\t}\n\n\twant := &ProjectPushRules{\n\t\tID:                         1,\n\t\tCommitMessageRegex:         \"Fixes \\\\d+\\\\..*\",\n\t\tCommitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n\t\tBranchNameRegex:            \"(feat|fix)\\\\/*\",\n\t\tDenyDeleteTag:              false,\n\t\tMemberCheck:                false,\n\t\tPreventSecrets:             false,\n\t\tAuthorEmailRegex:           \"@company.com$\",\n\t\tFileNameRegex:              \"(jar|exe)$\",\n\t\tMaxFileSize:                5,\n\t\tCommitCommitterCheck:       false,\n\t\tCommitCommitterNameCheck:   false,\n\t\tRejectUnsignedCommits:      false,\n\t\tRejectNonDCOCommits:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Projects.GetProjectPushRules returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestAddProjectPushRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/push_rule\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"commit_message_regex\": \"Fixes \\\\d+\\\\..*\",\n\t\t\t\"commit_message_negative_regex\": \"ssh\\\\:\\\\/\\\\/\",\n\t\t\t\"branch_name_regex\": \"(feat|fix)\\\\/*\",\n\t\t\t\"deny_delete_tag\": false,\n\t\t\t\"member_check\": false,\n\t\t\t\"prevent_secrets\": false,\n\t\t\t\"author_email_regex\": \"@company.com$\",\n\t\t\t\"file_name_regex\": \"(jar|exe)$\",\n\t\t\t\"max_file_size\": 5,\n\t\t\t\"commit_committer_check\": false,\n\t\t\t\"commit_committer_name_check\": false,\n\t\t\t\"reject_unsigned_commits\": false,\n\t\t\t\"reject_non_dco_commits\": false\n\t\t  }`)\n\t})\n\n\topt := &AddProjectPushRuleOptions{\n\t\tCommitMessageRegex:         Ptr(\"Fixes \\\\d+\\\\..*\"),\n\t\tCommitMessageNegativeRegex: Ptr(\"ssh\\\\:\\\\/\\\\/\"),\n\t\tBranchNameRegex:            Ptr(\"(feat|fix)\\\\/*\"),\n\t\tDenyDeleteTag:              Ptr(false),\n\t\tMemberCheck:                Ptr(false),\n\t\tPreventSecrets:             Ptr(false),\n\t\tAuthorEmailRegex:           Ptr(\"@company.com$\"),\n\t\tFileNameRegex:              Ptr(\"(jar|exe)$\"),\n\t\tMaxFileSize:                Ptr(5),\n\t\tCommitCommitterCheck:       Ptr(false),\n\t\tCommitCommitterNameCheck:   Ptr(false),\n\t\tRejectUnsignedCommits:      Ptr(false),\n\t\tRejectNonDCOCommits:        Ptr(false),\n\t}\n\n\trule, _, err := client.Projects.AddProjectPushRule(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.AddProjectPushRule returned error: %v\", err)\n\t}\n\n\twant := &ProjectPushRules{\n\t\tID:                         1,\n\t\tCommitMessageRegex:         \"Fixes \\\\d+\\\\..*\",\n\t\tCommitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n\t\tBranchNameRegex:            \"(feat|fix)\\\\/*\",\n\t\tDenyDeleteTag:              false,\n\t\tMemberCheck:                false,\n\t\tPreventSecrets:             false,\n\t\tAuthorEmailRegex:           \"@company.com$\",\n\t\tFileNameRegex:              \"(jar|exe)$\",\n\t\tMaxFileSize:                5,\n\t\tCommitCommitterCheck:       false,\n\t\tCommitCommitterNameCheck:   false,\n\t\tRejectUnsignedCommits:      false,\n\t\tRejectNonDCOCommits:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Projects.AddProjectPushRule returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestEditProjectPushRules(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/push_rule\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"commit_message_regex\": \"Fixes \\\\d+\\\\..*\",\n\t\t\t\"commit_message_negative_regex\": \"ssh\\\\:\\\\/\\\\/\",\n\t\t\t\"branch_name_regex\": \"(feat|fix)\\\\/*\",\n\t\t\t\"deny_delete_tag\": false,\n\t\t\t\"member_check\": false,\n\t\t\t\"prevent_secrets\": false,\n\t\t\t\"author_email_regex\": \"@company.com$\",\n\t\t\t\"file_name_regex\": \"(jar|exe)$\",\n\t\t\t\"max_file_size\": 5,\n\t\t\t\"commit_committer_check\": false,\n\t\t\t\"commit_committer_name_check\": false,\n\t\t\t\"reject_unsigned_commits\": false,\n\t\t\t\"reject_non_dco_commits\": false\n\t\t  }`)\n\t})\n\n\topt := &EditProjectPushRuleOptions{\n\t\tCommitMessageRegex:         Ptr(\"Fixes \\\\d+\\\\..*\"),\n\t\tCommitMessageNegativeRegex: Ptr(\"ssh\\\\:\\\\/\\\\/\"),\n\t\tBranchNameRegex:            Ptr(\"(feat|fix)\\\\/*\"),\n\t\tDenyDeleteTag:              Ptr(false),\n\t\tMemberCheck:                Ptr(false),\n\t\tPreventSecrets:             Ptr(false),\n\t\tAuthorEmailRegex:           Ptr(\"@company.com$\"),\n\t\tFileNameRegex:              Ptr(\"(jar|exe)$\"),\n\t\tMaxFileSize:                Ptr(5),\n\t\tCommitCommitterCheck:       Ptr(false),\n\t\tCommitCommitterNameCheck:   Ptr(false),\n\t\tRejectUnsignedCommits:      Ptr(false),\n\t\tRejectNonDCOCommits:        Ptr(false),\n\t}\n\n\trule, _, err := client.Projects.EditProjectPushRule(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.EditProjectPushRule returned error: %v\", err)\n\t}\n\n\twant := &ProjectPushRules{\n\t\tID:                         1,\n\t\tCommitMessageRegex:         \"Fixes \\\\d+\\\\..*\",\n\t\tCommitMessageNegativeRegex: \"ssh\\\\:\\\\/\\\\/\",\n\t\tBranchNameRegex:            \"(feat|fix)\\\\/*\",\n\t\tDenyDeleteTag:              false,\n\t\tMemberCheck:                false,\n\t\tPreventSecrets:             false,\n\t\tAuthorEmailRegex:           \"@company.com$\",\n\t\tFileNameRegex:              \"(jar|exe)$\",\n\t\tMaxFileSize:                5,\n\t\tCommitCommitterCheck:       false,\n\t\tCommitCommitterNameCheck:   false,\n\t\tRejectUnsignedCommits:      false,\n\t\tRejectNonDCOCommits:        false,\n\t}\n\n\tif !reflect.DeepEqual(want, rule) {\n\t\tt.Errorf(\"Projects.EditProjectPushRule returned %+v, want %+v\", rule, want)\n\t}\n}\n\nfunc TestGetProjectWebhookHeader(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Removed most of the arguments to keep test slim\n\tmux.HandleFunc(\"/api/v4/projects/1/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 1,\n\t\t\t\"custom_webhook_template\": \"{\\\"event\\\":\\\"{{object_kind}}\\\"}\",\n\t\t\t\"custom_headers\": [\n\t\t\t  {\n\t\t\t\t\"key\": \"Authorization\"\n\t\t\t  },\n\t\t\t  {\n\t\t\t\t\"key\": \"OtherKey\"\n\t\t\t  }\n\t\t\t]\n\t\t  }`)\n\t})\n\n\thook, _, err := client.Projects.GetProjectHook(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"Projects.GetProjectHook returned error: %v\", err)\n\t}\n\n\twant := &ProjectHook{\n\t\tID:                    1,\n\t\tCustomWebhookTemplate: \"{\\\"event\\\":\\\"{{object_kind}}\\\"}\",\n\t\tCustomHeaders: []*HookCustomHeader{\n\t\t\t{\n\t\t\t\tKey: \"Authorization\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tKey: \"OtherKey\",\n\t\t\t},\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, hook) {\n\t\tt.Errorf(\"Projects.GetProjectHook returned %+v, want %+v\", hook, want)\n\t}\n}\n\nfunc TestSetProjectWebhookHeader(t *testing.T) {\n\tmux, client := setup(t)\n\tvar bodyJson map[string]interface{}\n\n\t// Removed most of the arguments to keep test slim\n\tmux.HandleFunc(\"/api/v4/projects/1/hooks/1/custom_headers/Authorization\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tw.WriteHeader(http.StatusNoContent)\n\n\t\t// validate that the `value` body is sent properly\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unable to read body properly. Error: %v\", err)\n\t\t}\n\n\t\t// Unmarshal the body into JSON so we can check it\n\t\t_ = json.Unmarshal(body, &bodyJson)\n\n\t\tfmt.Fprint(w, ``)\n\t})\n\n\treq, err := client.Projects.SetProjectCustomHeader(1, 1, \"Authorization\", &SetHookCustomHeaderOptions{Value: Ptr(\"testValue\")})\n\tif err != nil {\n\t\tt.Errorf(\"Projects.SetProjectCustomHeader returned error: %v\", err)\n\t}\n\n\tassert.Equal(t, bodyJson[\"value\"], \"testValue\")\n\tassert.Equal(t, http.StatusNoContent, req.StatusCode)\n}\n\nfunc TestDeleteProjectWebhookHeader(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Removed most of the arguments to keep test slim\n\tmux.HandleFunc(\"/api/v4/projects/1/hooks/1/custom_headers/Authorization\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t\tfmt.Fprint(w, ``)\n\t})\n\n\treq, err := client.Projects.DeleteProjectCustomHeader(1, 1, \"Authorization\")\n\tif err != nil {\n\t\tt.Errorf(\"Projects.DeleteProjectCustomHeader returned error: %v\", err)\n\t}\n\n\tassert.Equal(t, http.StatusNoContent, req.StatusCode)\n}\n"
        },
        {
          "name": "protected_branches.go",
          "type": "blob",
          "size": 10.287109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen, Michael Lihs\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// ProtectedBranchesService handles communication with the protected branch\n// related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html\ntype ProtectedBranchesService struct {\n\tclient *Client\n}\n\n// ProtectedBranch represents a protected branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#list-protected-branches\ntype ProtectedBranch struct {\n\tID                        int                        `json:\"id\"`\n\tName                      string                     `json:\"name\"`\n\tPushAccessLevels          []*BranchAccessDescription `json:\"push_access_levels\"`\n\tMergeAccessLevels         []*BranchAccessDescription `json:\"merge_access_levels\"`\n\tUnprotectAccessLevels     []*BranchAccessDescription `json:\"unprotect_access_levels\"`\n\tAllowForcePush            bool                       `json:\"allow_force_push\"`\n\tCodeOwnerApprovalRequired bool                       `json:\"code_owner_approval_required\"`\n}\n\n// BranchAccessDescription represents the access description for a protected\n// branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#list-protected-branches\ntype BranchAccessDescription struct {\n\tID                     int              `json:\"id\"`\n\tAccessLevel            AccessLevelValue `json:\"access_level\"`\n\tAccessLevelDescription string           `json:\"access_level_description\"`\n\tDeployKeyID            int              `json:\"deploy_key_id\"`\n\tUserID                 int              `json:\"user_id\"`\n\tGroupID                int              `json:\"group_id\"`\n}\n\n// ListProtectedBranchesOptions represents the available ListProtectedBranches()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#list-protected-branches\ntype ListProtectedBranchesOptions struct {\n\tListOptions\n\tSearch *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n}\n\n// ListProtectedBranches gets a list of protected branches from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#list-protected-branches\nfunc (s *ProtectedBranchesService) ListProtectedBranches(pid interface{}, opt *ListProtectedBranchesOptions, options ...RequestOptionFunc) ([]*ProtectedBranch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_branches\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar p []*ProtectedBranch\n\tresp, err := s.client.Do(req, &p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// GetProtectedBranch gets a single protected branch or wildcard protected branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#get-a-single-protected-branch-or-wildcard-protected-branch\nfunc (s *ProtectedBranchesService) GetProtectedBranch(pid interface{}, branch string, options ...RequestOptionFunc) (*ProtectedBranch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_branches/%s\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(ProtectedBranch)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// ProtectRepositoryBranchesOptions represents the available\n// ProtectRepositoryBranches() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#protect-repository-branches\ntype ProtectRepositoryBranchesOptions struct {\n\tName                      *string                     `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tPushAccessLevel           *AccessLevelValue           `url:\"push_access_level,omitempty\" json:\"push_access_level,omitempty\"`\n\tMergeAccessLevel          *AccessLevelValue           `url:\"merge_access_level,omitempty\" json:\"merge_access_level,omitempty\"`\n\tUnprotectAccessLevel      *AccessLevelValue           `url:\"unprotect_access_level,omitempty\" json:\"unprotect_access_level,omitempty\"`\n\tAllowForcePush            *bool                       `url:\"allow_force_push,omitempty\" json:\"allow_force_push,omitempty\"`\n\tAllowedToPush             *[]*BranchPermissionOptions `url:\"allowed_to_push,omitempty\" json:\"allowed_to_push,omitempty\"`\n\tAllowedToMerge            *[]*BranchPermissionOptions `url:\"allowed_to_merge,omitempty\" json:\"allowed_to_merge,omitempty\"`\n\tAllowedToUnprotect        *[]*BranchPermissionOptions `url:\"allowed_to_unprotect,omitempty\" json:\"allowed_to_unprotect,omitempty\"`\n\tCodeOwnerApprovalRequired *bool                       `url:\"code_owner_approval_required,omitempty\" json:\"code_owner_approval_required,omitempty\"`\n}\n\n// BranchPermissionOptions represents a branch permission option.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#protect-repository-branches\ntype BranchPermissionOptions struct {\n\tID          *int              `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tUserID      *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID     *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tDeployKeyID *int              `url:\"deploy_key_id,omitempty\" json:\"deploy_key_id,omitempty\"`\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tDestroy     *bool             `url:\"_destroy,omitempty\" json:\"_destroy,omitempty\"`\n}\n\n// ProtectRepositoryBranches protects a single repository branch or several\n// project repository branches using a wildcard protected branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#protect-repository-branches\nfunc (s *ProtectedBranchesService) ProtectRepositoryBranches(pid interface{}, opt *ProtectRepositoryBranchesOptions, options ...RequestOptionFunc) (*ProtectedBranch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_branches\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(ProtectedBranch)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// UnprotectRepositoryBranches unprotects the given protected branch or wildcard\n// protected branch.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#unprotect-repository-branches\nfunc (s *ProtectedBranchesService) UnprotectRepositoryBranches(pid interface{}, branch string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_branches/%s\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// UpdateProtectedBranchOptions represents the available\n// UpdateProtectedBranch() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#update-a-protected-branch\ntype UpdateProtectedBranchOptions struct {\n\tName                      *string                     `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tAllowForcePush            *bool                       `url:\"allow_force_push,omitempty\" json:\"allow_force_push,omitempty\"`\n\tCodeOwnerApprovalRequired *bool                       `url:\"code_owner_approval_required,omitempty\" json:\"code_owner_approval_required,omitempty\"`\n\tAllowedToPush             *[]*BranchPermissionOptions `url:\"allowed_to_push,omitempty\" json:\"allowed_to_push,omitempty\"`\n\tAllowedToMerge            *[]*BranchPermissionOptions `url:\"allowed_to_merge,omitempty\" json:\"allowed_to_merge,omitempty\"`\n\tAllowedToUnprotect        *[]*BranchPermissionOptions `url:\"allowed_to_unprotect,omitempty\" json:\"allowed_to_unprotect,omitempty\"`\n}\n\n// UpdateProtectedBranch updates a protected branch.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#update-a-protected-branch\nfunc (s *ProtectedBranchesService) UpdateProtectedBranch(pid interface{}, branch string, opt *UpdateProtectedBranchOptions, options ...RequestOptionFunc) (*ProtectedBranch, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_branches/%s\", PathEscape(project), url.PathEscape(branch))\n\n\treq, err := s.client.NewRequest(http.MethodPatch, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(ProtectedBranch)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// RequireCodeOwnerApprovalsOptions represents the available\n// RequireCodeOwnerApprovals() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#update-a-protected-branch\ntype RequireCodeOwnerApprovalsOptions struct {\n\tCodeOwnerApprovalRequired *bool `url:\"code_owner_approval_required,omitempty\" json:\"code_owner_approval_required,omitempty\"`\n}\n\n// RequireCodeOwnerApprovals updates the code owner approval option.\n//\n// Deprecated: Use UpdateProtectedBranch() instead.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/protected_branches.html#update-a-protected-branch\nfunc (s *ProtectedBranchesService) RequireCodeOwnerApprovals(pid interface{}, branch string, opt *RequireCodeOwnerApprovalsOptions, options ...RequestOptionFunc) (*Response, error) {\n\tupdateOptions := &UpdateProtectedBranchOptions{\n\t\tCodeOwnerApprovalRequired: opt.CodeOwnerApprovalRequired,\n\t}\n\t_, req, err := s.UpdateProtectedBranch(pid, branch, updateOptions, options...)\n\treturn req, err\n}\n"
        },
        {
          "name": "protected_branches_test.go",
          "type": "blob",
          "size": 6.3759765625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListProtectedBranches(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_branches\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t{\n\t\t\"id\":1,\n\t\t\"name\":\"master\",\n\t\t\"push_access_levels\":[{\n\t\t\t\"id\":1,\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"Maintainers\",\n\t\t\t\"deploy_key_id\":null,\n\t\t\t\"user_id\":null,\n\t\t\t\"group_id\":null\n\t\t},{\n\t\t\t\"id\":2,\n\t\t\t\"access_level\":30,\n\t\t\t\"access_level_description\":\"User name\",\n\t\t\t\"deploy_key_id\":null,\n\t\t\t\"user_id\":123,\n\t\t\t\"group_id\":null\n\t\t},{\n\t\t\t\"id\":3,\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"deploy key\",\n\t\t\t\"deploy_key_id\":456,\n\t\t\t\"user_id\":null,\n\t\t\t\"group_id\":null\n\t\t}],\n\t\t\"merge_access_levels\":[{\n\t\t\t\"id\":1,\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"Maintainers\",\n\t\t\t\"user_id\":null,\n\t\t\t\"group_id\":null\n\t\t}],\n\t\t\"code_owner_approval_required\":false\n\t}\n]`)\n\t})\n\topt := &ListProtectedBranchesOptions{}\n\tprotectedBranches, _, err := client.ProtectedBranches.ListProtectedBranches(\"1\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"ProtectedBranches.ListProtectedBranches returned error: %v\", err)\n\t}\n\twant := []*ProtectedBranch{\n\t\t{\n\t\t\tID:   1,\n\t\t\tName: \"master\",\n\t\t\tPushAccessLevels: []*BranchAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tID:                     1,\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                     2,\n\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\tAccessLevelDescription: \"User name\",\n\t\t\t\t\tUserID:                 123,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                     3,\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"deploy key\",\n\t\t\t\t\tDeployKeyID:            456,\n\t\t\t\t},\n\t\t\t},\n\t\t\tMergeAccessLevels: []*BranchAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tID:                     1,\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAllowForcePush:            false,\n\t\t\tCodeOwnerApprovalRequired: false,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, protectedBranches) {\n\t\tt.Errorf(\"ProtectedBranches.ListProtectedBranches returned %+v, want %+v\", protectedBranches, want)\n\t}\n}\n\nfunc TestListProtectedBranchesWithoutCodeOwnerApproval(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_branches\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t{\n\t\t\"id\":1,\n\t\t\"name\":\"master\",\n\t\t\"push_access_levels\":[{\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"Maintainers\"\n\t\t}],\n\t\t\"merge_access_levels\":[{\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"Maintainers\"\n\t\t}]\n\t}\n]`)\n\t})\n\topt := &ListProtectedBranchesOptions{}\n\tprotectedBranches, _, err := client.ProtectedBranches.ListProtectedBranches(\"1\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"ProtectedBranches.ListProtectedBranches returned error: %v\", err)\n\t}\n\twant := []*ProtectedBranch{\n\t\t{\n\t\t\tID:   1,\n\t\t\tName: \"master\",\n\t\t\tPushAccessLevels: []*BranchAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tMergeAccessLevels: []*BranchAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tAllowForcePush:            false,\n\t\t\tCodeOwnerApprovalRequired: false,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, protectedBranches) {\n\t\tt.Errorf(\"Projects.ListProjects returned %+v, want %+v\", protectedBranches, want)\n\t}\n}\n\nfunc TestProtectRepositoryBranches(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_branches\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t{\n\t\t\"id\":1,\n\t\t\"name\":\"master\",\n\t\t\"push_access_levels\":[{\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"Maintainers\"\n\t\t}],\n\t\t\"merge_access_levels\":[{\n\t\t\t\"access_level\":40,\n\t\t\t\"access_level_description\":\"Maintainers\"\n\t\t}],\n\t\t\"allow_force_push\":true,\n\t\t\"code_owner_approval_required\":true\n\t}`)\n\t})\n\topt := &ProtectRepositoryBranchesOptions{\n\t\tName:                      Ptr(\"master\"),\n\t\tPushAccessLevel:           Ptr(MaintainerPermissions),\n\t\tMergeAccessLevel:          Ptr(MaintainerPermissions),\n\t\tAllowForcePush:            Ptr(true),\n\t\tCodeOwnerApprovalRequired: Ptr(true),\n\t}\n\tprojects, _, err := client.ProtectedBranches.ProtectRepositoryBranches(\"1\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"ProtectedBranches.ProtectRepositoryBranches returned error: %v\", err)\n\t}\n\twant := &ProtectedBranch{\n\t\tID:   1,\n\t\tName: \"master\",\n\t\tPushAccessLevels: []*BranchAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            40,\n\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t},\n\t\t},\n\t\tMergeAccessLevels: []*BranchAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            40,\n\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t},\n\t\t},\n\t\tAllowForcePush:            true,\n\t\tCodeOwnerApprovalRequired: true,\n\t}\n\tif !reflect.DeepEqual(want, projects) {\n\t\tt.Errorf(\"Projects.ListProjects returned %+v, want %+v\", projects, want)\n\t}\n}\n\nfunc TestUpdateRepositoryBranches(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_branches/master\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPatch)\n\t\ttestBody(t, r, `{\"code_owner_approval_required\":true}`)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"name\": \"master\",\n\t\t\t\"code_owner_approval_required\": true\n\t\t}`)\n\t})\n\topt := &UpdateProtectedBranchOptions{\n\t\tCodeOwnerApprovalRequired: Ptr(true),\n\t}\n\tprotectedBranch, _, err := client.ProtectedBranches.UpdateProtectedBranch(\"1\", \"master\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"ProtectedBranches.UpdateProtectedBranch returned error: %v\", err)\n\t}\n\n\twant := &ProtectedBranch{\n\t\tName:                      \"master\",\n\t\tCodeOwnerApprovalRequired: true,\n\t}\n\n\tif !reflect.DeepEqual(want, protectedBranch) {\n\t\tt.Errorf(\"ProtectedBranches.UpdateProtectedBranch returned %+v, want %+v\", protectedBranch, want)\n\t}\n}\n"
        },
        {
          "name": "protected_environments.go",
          "type": "blob",
          "size": 11.951171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ProtectedEnvironmentsService handles communication with the protected\n// environment methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html\ntype ProtectedEnvironmentsService struct {\n\tclient *Client\n}\n\n// ProtectedEnvironment represents a protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html\ntype ProtectedEnvironment struct {\n\tName                  string                          `json:\"name\"`\n\tDeployAccessLevels    []*EnvironmentAccessDescription `json:\"deploy_access_levels\"`\n\tRequiredApprovalCount int                             `json:\"required_approval_count\"`\n\tApprovalRules         []*EnvironmentApprovalRule      `json:\"approval_rules\"`\n}\n\n// EnvironmentAccessDescription represents the access decription for a protected\n// environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html\ntype EnvironmentAccessDescription struct {\n\tID                     int              `json:\"id\"`\n\tAccessLevel            AccessLevelValue `json:\"access_level\"`\n\tAccessLevelDescription string           `json:\"access_level_description\"`\n\tUserID                 int              `json:\"user_id\"`\n\tGroupID                int              `json:\"group_id\"`\n\tGroupInheritanceType   int              `json:\"group_inheritance_type\"`\n}\n\n// EnvironmentApprovalRule represents the approval rules for a protected\n// environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#protect-a-single-environment\ntype EnvironmentApprovalRule struct {\n\tID                     int              `json:\"id\"`\n\tUserID                 int              `json:\"user_id\"`\n\tGroupID                int              `json:\"group_id\"`\n\tAccessLevel            AccessLevelValue `json:\"access_level\"`\n\tAccessLevelDescription string           `json:\"access_level_description\"`\n\tRequiredApprovalCount  int              `json:\"required_approvals\"`\n\tGroupInheritanceType   int              `json:\"group_inheritance_type\"`\n}\n\n// ListProtectedEnvironmentsOptions represents the available\n// ListProtectedEnvironments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#list-protected-environments\ntype ListProtectedEnvironmentsOptions ListOptions\n\n// ListProtectedEnvironments returns a list of protected environments from a\n// project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#list-protected-environments\nfunc (s *ProtectedEnvironmentsService) ListProtectedEnvironments(pid interface{}, opt *ListProtectedEnvironmentsOptions, options ...RequestOptionFunc) ([]*ProtectedEnvironment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_environments\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pes []*ProtectedEnvironment\n\tresp, err := s.client.Do(req, &pes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pes, resp, nil\n}\n\n// GetProtectedEnvironment returns a single protected environment or wildcard\n// protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#get-a-single-protected-environment\nfunc (s *ProtectedEnvironmentsService) GetProtectedEnvironment(pid interface{}, environment string, options ...RequestOptionFunc) (*ProtectedEnvironment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_environments/%s\", PathEscape(project), PathEscape(environment))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpe := new(ProtectedEnvironment)\n\tresp, err := s.client.Do(req, pe)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pe, resp, nil\n}\n\n// ProtectRepositoryEnvironmentsOptions represents the available\n// ProtectRepositoryEnvironments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#protect-a-single-environment\ntype ProtectRepositoryEnvironmentsOptions struct {\n\tName                  *string                            `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDeployAccessLevels    *[]*EnvironmentAccessOptions       `url:\"deploy_access_levels,omitempty\" json:\"deploy_access_levels,omitempty\"`\n\tRequiredApprovalCount *int                               `url:\"required_approval_count,omitempty\" json:\"required_approval_count,omitempty\"`\n\tApprovalRules         *[]*EnvironmentApprovalRuleOptions `url:\"approval_rules,omitempty\" json:\"approval_rules,omitempty\"`\n}\n\n// EnvironmentAccessOptions represents the options for an access decription for\n// a protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#protect-a-single-environment\ntype EnvironmentAccessOptions struct {\n\tAccessLevel          *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tUserID               *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID              *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tGroupInheritanceType *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n}\n\n// EnvironmentApprovalRuleOptions represents the approval rules for a protected\n// environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#protect-a-single-environment\ntype EnvironmentApprovalRuleOptions struct {\n\tUserID                 *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID                *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tAccessLevel            *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tAccessLevelDescription *string           `url:\"access_level_description,omitempty\" json:\"access_level_description,omitempty\"`\n\tRequiredApprovalCount  *int              `url:\"required_approvals,omitempty\" json:\"required_approvals,omitempty\"`\n\tGroupInheritanceType   *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n}\n\n// ProtectRepositoryEnvironments protects a single repository environment or\n// several project repository environments using wildcard protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#protect-a-single-environment\nfunc (s *ProtectedEnvironmentsService) ProtectRepositoryEnvironments(pid interface{}, opt *ProtectRepositoryEnvironmentsOptions, options ...RequestOptionFunc) (*ProtectedEnvironment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_environments\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpe := new(ProtectedEnvironment)\n\tresp, err := s.client.Do(req, pe)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pe, resp, nil\n}\n\n// UpdateProtectedEnvironmentsOptions represents the available\n// UpdateProtectedEnvironments() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#update-a-protected-environment\ntype UpdateProtectedEnvironmentsOptions struct {\n\tName                  *string                                  `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tDeployAccessLevels    *[]*UpdateEnvironmentAccessOptions       `url:\"deploy_access_levels,omitempty\" json:\"deploy_access_levels,omitempty\"`\n\tRequiredApprovalCount *int                                     `url:\"required_approval_count,omitempty\" json:\"required_approval_count,omitempty\"`\n\tApprovalRules         *[]*UpdateEnvironmentApprovalRuleOptions `url:\"approval_rules,omitempty\" json:\"approval_rules,omitempty\"`\n}\n\n// UpdateEnvironmentAccessOptions represents the options for updates to an\n// access decription for a protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#update-a-protected-environment\ntype UpdateEnvironmentAccessOptions struct {\n\tAccessLevel          *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tID                   *int              `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tUserID               *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID              *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tGroupInheritanceType *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n\tDestroy              *bool             `url:\"_destroy,omitempty\" json:\"_destroy,omitempty\"`\n}\n\n// UpdateEnvironmentApprovalRuleOptions represents the updates to the approval\n// rules for a protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#update-a-protected-environment\ntype UpdateEnvironmentApprovalRuleOptions struct {\n\tID                     *int              `url:\"id,omitempty\" json:\"id,omitempty\"`\n\tUserID                 *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID                *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tAccessLevel            *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tAccessLevelDescription *string           `url:\"access_level_description,omitempty\" json:\"access_level_description,omitempty\"`\n\tRequiredApprovalCount  *int              `url:\"required_approvals,omitempty\" json:\"required_approvals,omitempty\"`\n\tGroupInheritanceType   *int              `url:\"group_inheritance_type,omitempty\" json:\"group_inheritance_type,omitempty\"`\n\tDestroy                *bool             `url:\"_destroy,omitempty\" json:\"_destroy,omitempty\"`\n}\n\n// UpdateProtectedEnvironments updates a single repository environment or\n// several project repository environments using wildcard protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#update-a-protected-environment\nfunc (s *ProtectedEnvironmentsService) UpdateProtectedEnvironments(pid interface{}, environment string, opt *UpdateProtectedEnvironmentsOptions, options ...RequestOptionFunc) (*ProtectedEnvironment, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_environments/%s\", PathEscape(project), PathEscape(environment))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpe := new(ProtectedEnvironment)\n\tresp, err := s.client.Do(req, pe)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pe, resp, nil\n}\n\n// UnprotectEnvironment unprotects the given protected environment or wildcard\n// protected environment.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_environments.html#unprotect-a-single-environment\nfunc (s *ProtectedEnvironmentsService) UnprotectEnvironment(pid interface{}, environment string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_environments/%s\", PathEscape(project), PathEscape(environment))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "protected_environments_test.go",
          "type": "blob",
          "size": 17.150390625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListProtectedEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\n      \"name\":\"1.0.0\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 40,\n          \"access_level_description\": \"Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ],\n      \"required_approval_count\": 1,\n      \"approval_rules\": [\n        {\n           \"id\": 38,\n           \"user_id\": 42,\n           \"group_id\": null,\n           \"access_level\": null,\n           \"access_level_description\": \"qa-group\",\n           \"required_approvals\": 1,\n           \"group_inheritance_type\": 0\n        },\n        {\n           \"id\": 39,\n           \"user_id\": null,\n           \"group_id\": 135,\n           \"access_level\": 30,\n           \"access_level_description\": \"security-group\",\n           \"required_approvals\": 2,\n           \"group_inheritance_type\": 1\n        }\n      ]\n    },{\n      \"name\":\"*-release\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ]\n    }]`)\n\t})\n\n\texpected := []*ProtectedEnvironment{\n\t\t{\n\t\t\tName: \"1.0.0\",\n\t\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t\tGroupInheritanceType:   1,\n\t\t\t\t},\n\t\t\t},\n\t\t\tRequiredApprovalCount: 1,\n\t\t\tApprovalRules: []*EnvironmentApprovalRule{\n\t\t\t\t{\n\t\t\t\t\tID:                     38,\n\t\t\t\t\tUserID:                 42,\n\t\t\t\t\tAccessLevelDescription: \"qa-group\",\n\t\t\t\t\tRequiredApprovalCount:  1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tID:                     39,\n\t\t\t\t\tGroupID:                135,\n\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\tAccessLevelDescription: \"security-group\",\n\t\t\t\t\tRequiredApprovalCount:  2,\n\t\t\t\t\tGroupInheritanceType:   1,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"*-release\",\n\t\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &ListProtectedEnvironmentsOptions{}\n\tenvironments, _, err := client.ProtectedEnvironments.ListProtectedEnvironments(1, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environments)\n}\n\nfunc TestGetProtectedEnvironment(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Test with RequiredApprovalCount\n\tenvironmentName := \"my-awesome-environment\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/1/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n      \"name\":\"my-awesome-environment\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ],\n      \"required_approval_count\": 1,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`)\n\t})\n\n\texpected := &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 1,\n\t\tApprovalRules: []*EnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err := client.ProtectedEnvironments.GetProtectedEnvironment(1, environmentName)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test without RequiredApprovalCount nor ApprovalRules\n\tenvironmentName = \"my-awesome-environment2\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/2/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n      \"name\":\"my-awesome-environment2\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ]\n    }`)\n\t})\n\n\texpected = &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err = client.ProtectedEnvironments.GetProtectedEnvironment(2, environmentName)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n}\n\nfunc TestProtectRepositoryEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Test with RequiredApprovalCount and ApprovalRules\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n      \"name\":\"my-awesome-environment\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ],\n      \"required_approval_count\": 2,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`)\n\t})\n\n\texpected := &ProtectedEnvironment{\n\t\tName: \"my-awesome-environment\",\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   1,\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t\tApprovalRules: []*EnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &ProtectRepositoryEnvironmentsOptions{\n\t\tName: Ptr(\"my-awesome-environment\"),\n\t\tDeployAccessLevels: &[]*EnvironmentAccessOptions{\n\t\t\t{AccessLevel: Ptr(AccessLevelValue(30))},\n\t\t},\n\t\tRequiredApprovalCount: Ptr(2),\n\t\tApprovalRules: &[]*EnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tGroupID:                Ptr(10),\n\t\t\t\tAccessLevel:            Ptr(AccessLevelValue(0)),\n\t\t\t\tAccessLevelDescription: Ptr(\"devops\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err := client.ProtectedEnvironments.ProtectRepositoryEnvironments(1, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test without RequiredApprovalCount nor ApprovalRules\n\tmux.HandleFunc(\"/api/v4/projects/2/protected_environments\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n      \"name\":\"my-awesome-environment2\",\n      \"deploy_access_levels\": [\n        {\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ]\n    }`)\n\t})\n\n\texpected = &ProtectedEnvironment{\n\t\tName: \"my-awesome-environment2\",\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt = &ProtectRepositoryEnvironmentsOptions{\n\t\tName: Ptr(\"my-awesome-environment2\"),\n\t\tDeployAccessLevels: &[]*EnvironmentAccessOptions{\n\t\t\t{AccessLevel: Ptr(AccessLevelValue(30))},\n\t\t},\n\t}\n\tenvironment, _, err = client.ProtectedEnvironments.ProtectRepositoryEnvironments(2, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n}\n\nfunc TestUpdateProtectedEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\t// Test with DeployAccessLevels, RequiredApprovalCount, and ApprovalRules as if adding new to existing protected environment\n\tenvironmentName := \"dev-test\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/1/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ],\n      \"required_approval_count\": 2,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected := &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   1,\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t\tApprovalRules: []*EnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &UpdateProtectedEnvironmentsOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*UpdateEnvironmentAccessOptions{\n\t\t\t{\n\t\t\t\tAccessLevel:          Ptr(AccessLevelValue(30)),\n\t\t\t\tGroupInheritanceType: Ptr(1),\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: Ptr(2),\n\t\tApprovalRules: &[]*UpdateEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tGroupID:                Ptr(10),\n\t\t\t\tAccessLevel:            Ptr(AccessLevelValue(0)),\n\t\t\t\tAccessLevelDescription: Ptr(\"devops\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err := client.ProtectedEnvironments.UpdateProtectedEnvironments(1, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test with DeployAccessLevels only, as if adding new to existing protected environment\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/2/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 1\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected = &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\tGroupInheritanceType:   1,\n\t\t\t},\n\t\t},\n\t}\n\n\topt = &UpdateProtectedEnvironmentsOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*UpdateEnvironmentAccessOptions{\n\t\t\t{AccessLevel: Ptr(AccessLevelValue(30))},\n\t\t},\n\t}\n\tenvironment, _, err = client.ProtectedEnvironments.UpdateProtectedEnvironments(2, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test update to DeployAccessLevel\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/3/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\",\n          \"group_inheritance_type\": 0\n        }\n      ],\n\t  \"required_approval_count\": 2\n    }`, environmentName)\n\t})\n\n\texpected = &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t}\n\n\topt = &UpdateProtectedEnvironmentsOptions{\n\t\tName: Ptr(environmentName),\n\t\tDeployAccessLevels: &[]*UpdateEnvironmentAccessOptions{\n\t\t\t{\n\t\t\t\tID:          Ptr(42),\n\t\t\t\tAccessLevel: Ptr(AccessLevelValue(30)),\n\t\t\t},\n\t\t},\n\t}\n\tenvironment, _, err = client.ProtectedEnvironments.UpdateProtectedEnvironments(3, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test update to ApprovalRules\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/4/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ],\n      \"required_approval_count\": 2,\n      \"approval_rules\": [\n        {\n           \"id\": 1,\n           \"user_id\": null,\n           \"group_id\": 10,\n           \"access_level\": 5,\n           \"access_level_description\": \"devops\",\n           \"required_approvals\": 0,\n           \"group_inheritance_type\": 0\n        }\n      ]\n    }`, environmentName)\n\t})\n\n\texpected = &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 2,\n\t\tApprovalRules: []*EnvironmentApprovalRule{\n\t\t\t{\n\t\t\t\tID:                     1,\n\t\t\t\tGroupID:                10,\n\t\t\t\tAccessLevel:            5,\n\t\t\t\tAccessLevelDescription: \"devops\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt = &UpdateProtectedEnvironmentsOptions{\n\t\tName: Ptr(environmentName),\n\t\tApprovalRules: &[]*UpdateEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tID:                     Ptr(1),\n\t\t\t\tGroupID:                Ptr(10),\n\t\t\t\tAccessLevel:            Ptr(AccessLevelValue(0)),\n\t\t\t\tAccessLevelDescription: Ptr(\"devops\"),\n\t\t\t},\n\t\t},\n\t}\n\n\tenvironment, _, err = client.ProtectedEnvironments.UpdateProtectedEnvironments(4, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n\n\t// Test destroy ApprovalRule\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/5/protected_environments/%s\", environmentName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n      \"name\":\"%s\",\n      \"deploy_access_levels\": [\n        {\n          \"id\": 42,\n          \"access_level\": 30,\n          \"access_level_description\": \"Developers + Maintainers\"\n        }\n      ],\n      \"required_approval_count\": 0,\n      \"approval_rules\": []\n    }`, environmentName)\n\t})\n\n\texpected = &ProtectedEnvironment{\n\t\tName: environmentName,\n\t\tDeployAccessLevels: []*EnvironmentAccessDescription{\n\t\t\t{\n\t\t\t\tID:                     42,\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: 0,\n\t\tApprovalRules:         []*EnvironmentApprovalRule{},\n\t}\n\n\topt = &UpdateProtectedEnvironmentsOptions{\n\t\tName: Ptr(environmentName),\n\t\tApprovalRules: &[]*UpdateEnvironmentApprovalRuleOptions{\n\t\t\t{\n\t\t\t\tID:      Ptr(1),\n\t\t\t\tDestroy: Ptr(true),\n\t\t\t},\n\t\t},\n\t\tRequiredApprovalCount: Ptr(0),\n\t}\n\n\tenvironment, _, err = client.ProtectedEnvironments.UpdateProtectedEnvironments(5, environmentName, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, environment)\n}\n\nfunc TestUpdateRepositoryEnvironmentsEscapesURL(t *testing.T) {\n\tmux, client := setup(t)\n\n\trawRequest := \"\"\n\n\t// Use a \"/\" in the environment name, so it needs encoding\n\t// Note: Mux requires the path to be unencoded for some reason. Using %2F will never intercept the request.\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_environments/test/environment\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\n\t\t// Store the raw request so we're sure it's encoded properly\n\t\trawRequest = r.URL.RawPath\n\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"name\": \"test/environment\"\n\t\t}`)\n\t})\n\n\t_, resp, err := client.ProtectedEnvironments.UpdateProtectedEnvironments(1, \"test/environment\", &UpdateProtectedEnvironmentsOptions{})\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n\tassert.Equal(t, rawRequest, \"/api/v4/projects/1/protected_environments/test%2Fenvironment\")\n}\n\nfunc TestUnprotectRepositoryEnvironments(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_environments/my-awesome-environment\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.ProtectedEnvironments.UnprotectEnvironment(1, \"my-awesome-environment\")\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n}\n"
        },
        {
          "name": "protected_tags.go",
          "type": "blob",
          "size": 5.671875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ProtectedTagsService handles communication with the protected tag methods\n// of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html\ntype ProtectedTagsService struct {\n\tclient *Client\n}\n\n// ProtectedTag represents a protected tag.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html\ntype ProtectedTag struct {\n\tName               string                  `json:\"name\"`\n\tCreateAccessLevels []*TagAccessDescription `json:\"create_access_levels\"`\n}\n\n// TagAccessDescription reperesents the access decription for a protected tag.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html\ntype TagAccessDescription struct {\n\tID                     int              `json:\"id\"`\n\tUserID                 int              `json:\"user_id\"`\n\tGroupID                int              `json:\"group_id\"`\n\tAccessLevel            AccessLevelValue `json:\"access_level\"`\n\tAccessLevelDescription string           `json:\"access_level_description\"`\n}\n\n// ListProtectedTagsOptions represents the available ListProtectedTags()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#list-protected-tags\ntype ListProtectedTagsOptions ListOptions\n\n// ListProtectedTags returns a list of protected tags from a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#list-protected-tags\nfunc (s *ProtectedTagsService) ListProtectedTags(pid interface{}, opt *ListProtectedTagsOptions, options ...RequestOptionFunc) ([]*ProtectedTag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_tags\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar pts []*ProtectedTag\n\tresp, err := s.client.Do(req, &pts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pts, resp, nil\n}\n\n// GetProtectedTag returns a single protected tag or wildcard protected tag.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#get-a-single-protected-tag-or-wildcard-protected-tag\nfunc (s *ProtectedTagsService) GetProtectedTag(pid interface{}, tag string, options ...RequestOptionFunc) (*ProtectedTag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_tags/%s\", PathEscape(project), PathEscape(tag))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(ProtectedTag)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// ProtectRepositoryTagsOptions represents the available ProtectRepositoryTags()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#protect-repository-tags\ntype ProtectRepositoryTagsOptions struct {\n\tName              *string                   `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tCreateAccessLevel *AccessLevelValue         `url:\"create_access_level,omitempty\" json:\"create_access_level,omitempty\"`\n\tAllowedToCreate   *[]*TagsPermissionOptions `url:\"allowed_to_create,omitempty\" json:\"allowed_to_create,omitempty\"`\n}\n\n// TagsPermissionOptions represents a protected tag permission option.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#protect-repository-tags\ntype TagsPermissionOptions struct {\n\tUserID      *int              `url:\"user_id,omitempty\" json:\"user_id,omitempty\"`\n\tGroupID     *int              `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tAccessLevel *AccessLevelValue `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n}\n\n// ProtectRepositoryTags protects a single repository tag or several project\n// repository tags using a wildcard protected tag.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#protect-repository-tags\nfunc (s *ProtectedTagsService) ProtectRepositoryTags(pid interface{}, opt *ProtectRepositoryTagsOptions, options ...RequestOptionFunc) (*ProtectedTag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_tags\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tpt := new(ProtectedTag)\n\tresp, err := s.client.Do(req, pt)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn pt, resp, nil\n}\n\n// UnprotectRepositoryTags unprotects the given protected tag or wildcard\n// protected tag.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/protected_tags.html#unprotect-repository-tags\nfunc (s *ProtectedTagsService) UnprotectRepositoryTags(pid interface{}, tag string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/protected_tags/%s\", PathEscape(project), PathEscape(tag))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "protected_tags_test.go",
          "type": "blob",
          "size": 4.1669921875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestListProtectedTags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_tags\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"name\":\"1.0.0\", \"create_access_levels\": [{\"access_level\": 40, \"access_level_description\": \"Maintainers\"}]},{\"name\":\"*-release\", \"create_access_levels\": [{\"access_level\": 30, \"access_level_description\": \"Developers + Maintainers\"}]}]`)\n\t})\n\n\texpected := []*ProtectedTag{\n\t\t{\n\t\t\tName: \"1.0.0\",\n\t\t\tCreateAccessLevels: []*TagAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            40,\n\t\t\t\t\tAccessLevelDescription: \"Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"*-release\",\n\t\t\tCreateAccessLevels: []*TagAccessDescription{\n\t\t\t\t{\n\t\t\t\t\tAccessLevel:            30,\n\t\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &ListProtectedTagsOptions{}\n\ttags, _, err := client.ProtectedTags.ListProtectedTags(1, opt)\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, tags)\n}\n\nfunc TestGetProtectedTag(t *testing.T) {\n\tmux, client := setup(t)\n\n\ttagName := \"my-awesome-tag\"\n\n\tmux.HandleFunc(fmt.Sprintf(\"/api/v4/projects/1/protected_tags/%s\", tagName), func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"name\":\"my-awesome-tag\", \"create_access_levels\": [{\"access_level\": 30, \"access_level_description\": \"Developers + Maintainers\"},{\"access_level\": 40, \"access_level_description\": \"Sample Group\", \"group_id\": 300}]}`)\n\t})\n\n\texpected := &ProtectedTag{\n\t\tName: tagName,\n\t\tCreateAccessLevels: []*TagAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAccessLevel:            40,\n\t\t\t\tGroupID:                300,\n\t\t\t\tAccessLevelDescription: \"Sample Group\",\n\t\t\t},\n\t\t},\n\t}\n\n\ttag, _, err := client.ProtectedTags.GetProtectedTag(1, tagName)\n\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, tag)\n}\n\nfunc TestProtectRepositoryTags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_tags\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"name\":\"my-awesome-tag\", \"create_access_levels\": [{\"access_level\": 30, \"access_level_description\": \"Developers + Maintainers\"},{\"access_level\": 40, \"access_level_description\": \"Sample Group\", \"group_id\": 300}]}`)\n\t})\n\n\texpected := &ProtectedTag{\n\t\tName: \"my-awesome-tag\",\n\t\tCreateAccessLevels: []*TagAccessDescription{\n\t\t\t{\n\t\t\t\tAccessLevel:            30,\n\t\t\t\tAccessLevelDescription: \"Developers + Maintainers\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAccessLevel:            40,\n\t\t\t\tGroupID:                300,\n\t\t\t\tAccessLevelDescription: \"Sample Group\",\n\t\t\t},\n\t\t},\n\t}\n\n\topt := &ProtectRepositoryTagsOptions{\n\t\tName:              Ptr(\"my-awesome-tag\"),\n\t\tCreateAccessLevel: Ptr(AccessLevelValue(30)),\n\t\tAllowedToCreate: &[]*TagsPermissionOptions{\n\t\t\t{\n\t\t\t\tGroupID: Ptr(300),\n\t\t\t},\n\t\t},\n\t}\n\ttag, _, err := client.ProtectedTags.ProtectRepositoryTags(1, opt)\n\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, expected, tag)\n}\n\nfunc TestUnprotectRepositoryTags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/protected_tags/my-awesome-tag\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.ProtectedTags.UnprotectRepositoryTags(1, \"my-awesome-tag\")\n\tassert.NoError(t, err, \"failed to get response\")\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n}\n"
        },
        {
          "name": "releaselinks.go",
          "type": "blob",
          "size": 6.3662109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ReleaseLinksService handles communication with the release link methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html\ntype ReleaseLinksService struct {\n\tclient *Client\n}\n\n// ReleaseLink represents a release link.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html\ntype ReleaseLink struct {\n\tID             int           `json:\"id\"`\n\tName           string        `json:\"name\"`\n\tURL            string        `json:\"url\"`\n\tDirectAssetURL string        `json:\"direct_asset_url\"`\n\tExternal       bool          `json:\"external\"`\n\tLinkType       LinkTypeValue `json:\"link_type\"`\n}\n\n// ListReleaseLinksOptions represents ListReleaseLinks() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#list-links-of-a-release\ntype ListReleaseLinksOptions ListOptions\n\n// ListReleaseLinks gets assets as links from a Release.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#list-links-of-a-release\nfunc (s *ReleaseLinksService) ListReleaseLinks(pid interface{}, tagName string, opt *ListReleaseLinksOptions, options ...RequestOptionFunc) ([]*ReleaseLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s/assets/links\", PathEscape(project), PathEscape(tagName))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rls []*ReleaseLink\n\tresp, err := s.client.Do(req, &rls)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rls, resp, nil\n}\n\n// GetReleaseLink returns a link from release assets.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#get-a-release-link\nfunc (s *ReleaseLinksService) GetReleaseLink(pid interface{}, tagName string, link int, options ...RequestOptionFunc) (*ReleaseLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s/assets/links/%d\",\n\t\tPathEscape(project),\n\t\tPathEscape(tagName),\n\t\tlink)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trl := new(ReleaseLink)\n\tresp, err := s.client.Do(req, rl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rl, resp, nil\n}\n\n// CreateReleaseLinkOptions represents CreateReleaseLink() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#create-a-release-link\ntype CreateReleaseLinkOptions struct {\n\tName            *string        `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tURL             *string        `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tFilePath        *string        `url:\"filepath,omitempty\" json:\"filepath,omitempty\"`\n\tDirectAssetPath *string        `url:\"direct_asset_path,omitempty\" json:\"direct_asset_path,omitempty\"`\n\tLinkType        *LinkTypeValue `url:\"link_type,omitempty\" json:\"link_type,omitempty\"`\n}\n\n// CreateReleaseLink creates a link.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#create-a-release-link\nfunc (s *ReleaseLinksService) CreateReleaseLink(pid interface{}, tagName string, opt *CreateReleaseLinkOptions, options ...RequestOptionFunc) (*ReleaseLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s/assets/links\", PathEscape(project), PathEscape(tagName))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trl := new(ReleaseLink)\n\tresp, err := s.client.Do(req, rl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rl, resp, nil\n}\n\n// UpdateReleaseLinkOptions represents UpdateReleaseLink() options.\n//\n// You have to specify at least one of Name of URL.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#update-a-release-link\ntype UpdateReleaseLinkOptions struct {\n\tName            *string        `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tURL             *string        `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tFilePath        *string        `url:\"filepath,omitempty\" json:\"filepath,omitempty\"`\n\tDirectAssetPath *string        `url:\"direct_asset_path,omitempty\" json:\"direct_asset_path,omitempty\"`\n\tLinkType        *LinkTypeValue `url:\"link_type,omitempty\" json:\"link_type,omitempty\"`\n}\n\n// UpdateReleaseLink updates an asset link.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#update-a-release-link\nfunc (s *ReleaseLinksService) UpdateReleaseLink(pid interface{}, tagName string, link int, opt *UpdateReleaseLinkOptions, options ...RequestOptionFunc) (*ReleaseLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s/assets/links/%d\",\n\t\tPathEscape(project),\n\t\tPathEscape(tagName),\n\t\tlink)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trl := new(ReleaseLink)\n\tresp, err := s.client.Do(req, rl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rl, resp, nil\n}\n\n// DeleteReleaseLink deletes a link from release.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/links.html#delete-a-release-link\nfunc (s *ReleaseLinksService) DeleteReleaseLink(pid interface{}, tagName string, link int, options ...RequestOptionFunc) (*ReleaseLink, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s/assets/links/%d\",\n\t\tPathEscape(project),\n\t\tPathEscape(tagName),\n\t\tlink,\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trl := new(ReleaseLink)\n\tresp, err := s.client.Do(req, rl)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rl, resp, nil\n}\n"
        },
        {
          "name": "releaselinks_test.go",
          "type": "blob",
          "size": 5.6279296875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestReleaseLinksService_ListReleaseLinks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1/assets/links\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, exampleReleaseLinkList)\n\t\t})\n\n\treleaseLinks, _, err := client.ReleaseLinks.ListReleaseLinks(\n\t\t1, exampleTagName, &ListReleaseLinksOptions{},\n\t)\n\n\trequire.NoError(t, err)\n\texpectedReleaseLinks := []*ReleaseLink{\n\t\t{\n\t\t\tID:       2,\n\t\t\tName:     \"awesome-v0.2.msi\",\n\t\t\tURL:      \"http://192.168.10.15:3000/msi\",\n\t\t\tExternal: true,\n\t\t},\n\t\t{\n\t\t\tID:             1,\n\t\t\tName:           \"awesome-v0.2.dmg\",\n\t\t\tURL:            \"http://192.168.10.15:3000\",\n\t\t\tDirectAssetURL: \"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/awesome-v0.2.dmg\",\n\t\t\tExternal:       false,\n\t\t\tLinkType:       OtherLinkType,\n\t\t},\n\t}\n\tassert.Equal(t, expectedReleaseLinks, releaseLinks)\n}\n\nfunc TestReleaseLinksService_CreateReleaseLink(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\toptions     *CreateReleaseLinkOptions\n\t\tresponse    string\n\t\twant        *ReleaseLink\n\t}{\n\t\t{\n\t\t\tdescription: \"Mandatory Attributes\",\n\t\t\toptions: &CreateReleaseLinkOptions{\n\t\t\t\tName: Ptr(\"awesome-v0.2.dmg\"),\n\t\t\t\tURL:  Ptr(\"http://192.168.10.15:3000\"),\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"id\":1,\n\t\t\t\t\"name\":\"awesome-v0.2.dmg\",\n\t\t\t\t\"url\":\"http://192.168.10.15:3000\",\n\t\t\t\t\"external\":true\n\t\t\t}`,\n\t\t\twant: &ReleaseLink{\n\t\t\t\tID:       1,\n\t\t\t\tName:     \"awesome-v0.2.dmg\",\n\t\t\t\tURL:      \"http://192.168.10.15:3000\",\n\t\t\t\tExternal: true,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"Optional Attributes\",\n\t\t\toptions: &CreateReleaseLinkOptions{\n\t\t\t\tName:            Ptr(\"release-notes.md\"),\n\t\t\t\tURL:             Ptr(\"http://192.168.10.15:3000\"),\n\t\t\t\tDirectAssetPath: Ptr(\"docs/release-notes.md\"),\n\t\t\t\tLinkType:        Ptr(OtherLinkType),\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"id\":1,\n\t\t\t\t\"name\":\"release-notes.md\",\n\t\t\t\t\"url\":\"http://192.168.10.15:3000\",\n\t\t\t\t\"direct_asset_url\": \"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/docs/release-notes.md\",\n\t\t\t\t\"external\": false,\n\t\t\t\t\"link_type\": \"other\"\n\t\t\t}`,\n\t\t\twant: &ReleaseLink{\n\t\t\t\tID:             1,\n\t\t\t\tName:           \"release-notes.md\",\n\t\t\t\tURL:            \"http://192.168.10.15:3000\",\n\t\t\t\tDirectAssetURL: \"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/docs/release-notes.md\",\n\t\t\t\tExternal:       false,\n\t\t\t\tLinkType:       OtherLinkType,\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tmux, client := setup(t)\n\n\t\t\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1/assets/links\",\n\t\t\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\t\t\tfmt.Fprint(w, tc.response)\n\t\t\t\t})\n\n\t\t\treleaseLink, _, err := client.ReleaseLinks.CreateReleaseLink(1, exampleTagName, tc.options)\n\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Equal(t, tc.want, releaseLink)\n\t\t})\n\t}\n}\n\nfunc TestReleaseLinksService_GetReleaseLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1/assets/links/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, exampleReleaseLink)\n\t\t})\n\n\treleaseLink, _, err := client.ReleaseLinks.GetReleaseLink(1, exampleTagName, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif releaseLink.Name != exampleReleaseName {\n\t\tt.Errorf(\"release link name, expected '%s', got '%s'\", exampleReleaseName,\n\t\t\treleaseLink.Name)\n\t}\n}\n\nfunc TestReleaseLinksService_UpdateReleaseLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1/assets/links/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, exampleReleaseLink)\n\t\t})\n\n\treleaseLink, _, err := client.ReleaseLinks.UpdateReleaseLink(\n\t\t1, exampleTagName, 1,\n\t\t&UpdateReleaseLinkOptions{\n\t\t\tName:            Ptr(exampleReleaseName),\n\t\t\tDirectAssetPath: Ptr(\"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/awesome-v0.2.dmg\"),\n\t\t\tLinkType:        Ptr(OtherLinkType),\n\t\t})\n\n\trequire.NoError(t, err)\n\texpectedRelease := &ReleaseLink{\n\t\tID:             1,\n\t\tName:           \"awesome-v0.2.dmg\",\n\t\tURL:            \"http://192.168.10.15:3000\",\n\t\tDirectAssetURL: \"http://192.168.10.15:3000/namespace/example/-/releases/v0.1/downloads/awesome-v0.2.dmg\",\n\t\tExternal:       true,\n\t\tLinkType:       OtherLinkType,\n\t}\n\tassert.Equal(t, expectedRelease, releaseLink)\n}\n\nfunc TestReleaseLinksService_DeleteReleaseLink(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1/assets/links/1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tfmt.Fprint(w, exampleReleaseLink)\n\t\t})\n\n\treleaseLink, _, err := client.ReleaseLinks.DeleteReleaseLink(1, exampleTagName, 1)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif releaseLink.Name != exampleReleaseName {\n\t\tt.Errorf(\"release link name, expected '%s', got '%s'\", exampleReleaseName,\n\t\t\treleaseLink.Name)\n\t}\n}\n"
        },
        {
          "name": "releases.go",
          "type": "blob",
          "size": 8.994140625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ReleasesService handles communication with the releases methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/releases/index.html\ntype ReleasesService struct {\n\tclient *Client\n}\n\n// Release represents a project release.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#list-releases\ntype Release struct {\n\tTagName         string     `json:\"tag_name\"`\n\tName            string     `json:\"name\"`\n\tDescription     string     `json:\"description\"`\n\tDescriptionHTML string     `json:\"description_html\"`\n\tCreatedAt       *time.Time `json:\"created_at\"`\n\tReleasedAt      *time.Time `json:\"released_at\"`\n\tAuthor          struct {\n\t\tID        int    `json:\"id\"`\n\t\tName      string `json:\"name\"`\n\t\tUsername  string `json:\"username\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"author\"`\n\tCommit          Commit `json:\"commit\"`\n\tUpcomingRelease bool   `json:\"upcoming_release\"`\n\tCommitPath      string `json:\"commit_path\"`\n\tTagPath         string `json:\"tag_path\"`\n\tAssets          struct {\n\t\tCount   int `json:\"count\"`\n\t\tSources []struct {\n\t\t\tFormat string `json:\"format\"`\n\t\t\tURL    string `json:\"url\"`\n\t\t} `json:\"sources\"`\n\t\tLinks []*ReleaseLink `json:\"links\"`\n\t} `json:\"assets\"`\n\tLinks struct {\n\t\tClosedIssueURL     string `json:\"closed_issues_url\"`\n\t\tClosedMergeRequest string `json:\"closed_merge_requests_url\"`\n\t\tEditURL            string `json:\"edit_url\"`\n\t\tMergedMergeRequest string `json:\"merged_merge_requests_url\"`\n\t\tOpenedIssues       string `json:\"opened_issues_url\"`\n\t\tOpenedMergeRequest string `json:\"opened_merge_requests_url\"`\n\t\tSelf               string `json:\"self\"`\n\t} `json:\"_links\"`\n}\n\n// ListReleasesOptions represents ListReleases() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#list-releases\ntype ListReleasesOptions struct {\n\tListOptions\n\tOrderBy                *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                   *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tIncludeHTMLDescription *bool   `url:\"include_html_description,omitempty\" json:\"include_html_description,omitempty\"`\n}\n\n// ListReleases gets a pagenated of releases accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#list-releases\nfunc (s *ReleasesService) ListReleases(pid interface{}, opt *ListReleasesOptions, options ...RequestOptionFunc) ([]*Release, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rs []*Release\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// GetRelease returns a single release, identified by a tag name.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#get-a-release-by-a-tag-name\nfunc (s *ReleasesService) GetRelease(pid interface{}, tagName string, options ...RequestOptionFunc) (*Release, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s\", PathEscape(project), PathEscape(tagName))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Release)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// GetLatestRelease returns the latest release for the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/#get-the-latest-release\nfunc (s *ReleasesService) GetLatestRelease(pid interface{}, options ...RequestOptionFunc) (*Release, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/permalink/latest\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Release)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, err\n}\n\n// CreateReleaseOptions represents CreateRelease() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#create-a-release\ntype CreateReleaseOptions struct {\n\tName        *string               `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tTagName     *string               `url:\"tag_name,omitempty\" json:\"tag_name,omitempty\"`\n\tTagMessage  *string               `url:\"tag_message,omitempty\" json:\"tag_message,omitempty\"`\n\tDescription *string               `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tRef         *string               `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tMilestones  *[]string             `url:\"milestones,omitempty\" json:\"milestones,omitempty\"`\n\tAssets      *ReleaseAssetsOptions `url:\"assets,omitempty\" json:\"assets,omitempty\"`\n\tReleasedAt  *time.Time            `url:\"released_at,omitempty\" json:\"released_at,omitempty\"`\n}\n\n// ReleaseAssetsOptions represents release assets in CreateRelease() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#create-a-release\ntype ReleaseAssetsOptions struct {\n\tLinks []*ReleaseAssetLinkOptions `url:\"links,omitempty\" json:\"links,omitempty\"`\n}\n\n// ReleaseAssetLinkOptions represents release asset link in CreateRelease()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#create-a-release\ntype ReleaseAssetLinkOptions struct {\n\tName            *string        `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tURL             *string        `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tFilePath        *string        `url:\"filepath,omitempty\" json:\"filepath,omitempty\"`\n\tDirectAssetPath *string        `url:\"direct_asset_path,omitempty\" json:\"direct_asset_path,omitempty\"`\n\tLinkType        *LinkTypeValue `url:\"link_type,omitempty\" json:\"link_type,omitempty\"`\n}\n\n// CreateRelease creates a release.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#create-a-release\nfunc (s *ReleasesService) CreateRelease(pid interface{}, opts *CreateReleaseOptions, options ...RequestOptionFunc) (*Release, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Release)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// UpdateReleaseOptions represents UpdateRelease() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#update-a-release\ntype UpdateReleaseOptions struct {\n\tName        *string    `url:\"name\" json:\"name\"`\n\tDescription *string    `url:\"description\" json:\"description\"`\n\tMilestones  *[]string  `url:\"milestones,omitempty\" json:\"milestones,omitempty\"`\n\tReleasedAt  *time.Time `url:\"released_at,omitempty\" json:\"released_at,omitempty\"`\n}\n\n// UpdateRelease updates a release.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#update-a-release\nfunc (s *ReleasesService) UpdateRelease(pid interface{}, tagName string, opts *UpdateReleaseOptions, options ...RequestOptionFunc) (*Release, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s\", PathEscape(project), PathEscape(tagName))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Release)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// DeleteRelease deletes a release.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/index.html#delete-a-release\nfunc (s *ReleasesService) DeleteRelease(pid interface{}, tagName string, options ...RequestOptionFunc) (*Release, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/releases/%s\", PathEscape(project), PathEscape(tagName))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Release)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n"
        },
        {
          "name": "releases_test.go",
          "type": "blob",
          "size": 11.7587890625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestReleasesService_ListReleases(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, exampleReleaseListResponse)\n\t\t})\n\n\topt := &ListReleasesOptions{}\n\treleases, _, err := client.Releases.ListReleases(1, opt)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif len(releases) != 2 {\n\t\tt.Error(\"expected 2 releases\")\n\t}\n}\n\nfunc TestReleasesService_GetRelease(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\trelease, _, err := client.Releases.GetRelease(1, exampleTagName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_CreateRelease(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), exampleTagName) {\n\t\t\t\tt.Errorf(\"expected request body to contain %s, got %s\",\n\t\t\t\t\texampleTagName, string(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"assets\") {\n\t\t\t\tt.Errorf(\"expected request body not to have assets, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body not to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body not to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &CreateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tTagName:     Ptr(exampleTagName),\n\t\tDescription: Ptr(\"Description\"),\n\t}\n\n\trelease, _, err := client.Releases.CreateRelease(1, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_CreateReleaseWithAsset(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), exampleTagName) {\n\t\t\t\tt.Errorf(\"expected request body to contain %s, got %s\",\n\t\t\t\t\texampleTagName, string(b))\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), \"assets\") {\n\t\t\t\tt.Errorf(\"expected request body to have assets, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body not to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body not to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &CreateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tTagName:     Ptr(exampleTagName),\n\t\tDescription: Ptr(\"Description\"),\n\t\tAssets: &ReleaseAssetsOptions{\n\t\t\tLinks: []*ReleaseAssetLinkOptions{\n\t\t\t\t{Ptr(\"sldkf\"), Ptr(\"sldkfj\"), Ptr(\"sldkfh\"), Ptr(\"direct-asset-path\"), Ptr(OtherLinkType)},\n\t\t\t},\n\t\t},\n\t}\n\n\trelease, _, err := client.Releases.CreateRelease(1, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_CreateReleaseWithAssetAndNameMetadata(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), exampleTagNameWithMetadata) {\n\t\t\t\tt.Errorf(\"expected request body to contain %s, got %s\",\n\t\t\t\t\texampleTagNameWithMetadata, string(b))\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), \"assets\") {\n\t\t\t\tt.Errorf(\"expected request body to have assets, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body not to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body not to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseWithMetadataResponse)\n\t\t})\n\n\topts := &CreateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tTagName:     Ptr(exampleTagNameWithMetadata),\n\t\tDescription: Ptr(\"Description\"),\n\t\tAssets: &ReleaseAssetsOptions{\n\t\t\tLinks: []*ReleaseAssetLinkOptions{\n\t\t\t\t{Ptr(\"sldkf\"), Ptr(\"sldkfj\"), Ptr(\"sldkfh\"), Ptr(\"direct-asset-path\"), Ptr(OtherLinkType)},\n\t\t\t},\n\t\t},\n\t}\n\n\trelease, _, err := client.Releases.CreateRelease(1, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagNameWithMetadata {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagNameWithMetadata, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_CreateReleaseWithMilestones(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), exampleTagName) {\n\t\t\t\tt.Errorf(\"expected request body to contain %s, got %s\",\n\t\t\t\t\texampleTagName, string(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"assets\") {\n\t\t\t\tt.Errorf(\"expected request body not to have assets, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body not to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &CreateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tTagName:     Ptr(exampleTagName),\n\t\tDescription: Ptr(\"Description\"),\n\t\tMilestones:  &[]string{exampleTagName, \"v0.1.0\"},\n\t}\n\n\trelease, _, err := client.Releases.CreateRelease(1, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_CreateReleaseWithReleasedAt(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), exampleTagName) {\n\t\t\t\tt.Errorf(\"expected request body to contain %s, got %s\",\n\t\t\t\t\texampleTagName, string(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"assets\") {\n\t\t\t\tt.Errorf(\"expected request body not to have assets, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body not to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &CreateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tTagName:     Ptr(exampleTagName),\n\t\tDescription: Ptr(\"Description\"),\n\t\tReleasedAt:  &time.Time{},\n\t}\n\n\trelease, _, err := client.Releases.CreateRelease(1, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_UpdateRelease(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body not to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body not to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &UpdateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tDescription: Ptr(\"Description\"),\n\t}\n\n\trelease, _, err := client.Releases.UpdateRelease(1, exampleTagName, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_UpdateReleaseWithMilestones(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body not to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &UpdateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tDescription: Ptr(\"Description\"),\n\t\tMilestones:  &[]string{exampleTagName, \"v0.1.0\"},\n\t}\n\n\trelease, _, err := client.Releases.UpdateRelease(1, exampleTagName, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_UpdateReleaseWithReleasedAt(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tb, err := io.ReadAll(r.Body)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"unable to read request body\")\n\t\t\t}\n\t\t\tif strings.Contains(string(b), \"milestones\") {\n\t\t\t\tt.Errorf(\"expected request body not to have milestones, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tif !strings.Contains(string(b), \"released_at\") {\n\t\t\t\tt.Errorf(\"expected request body to have released_at, got %s\",\n\t\t\t\t\tstring(b))\n\t\t\t}\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\topts := &UpdateReleaseOptions{\n\t\tName:        Ptr(\"name\"),\n\t\tDescription: Ptr(\"Description\"),\n\t\tReleasedAt:  &time.Time{},\n\t}\n\n\trelease, _, err := client.Releases.UpdateRelease(1, exampleTagName, opts)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n\nfunc TestReleasesService_DeleteRelease(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/releases/v0.1\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodDelete)\n\t\t\tfmt.Fprint(w, exampleReleaseResponse)\n\t\t})\n\n\trelease, _, err := client.Releases.DeleteRelease(1, exampleTagName)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tif release.TagName != exampleTagName {\n\t\tt.Errorf(\"expected tag %s, got %s\", exampleTagName, release.TagName)\n\t}\n}\n"
        },
        {
          "name": "repositories.go",
          "type": "blob",
          "size": 12.607421875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// RepositoriesService handles communication with the repositories related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repositories.html\ntype RepositoriesService struct {\n\tclient *Client\n}\n\n// TreeNode represents a GitLab repository file or directory.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repositories.html\ntype TreeNode struct {\n\tID   string `json:\"id\"`\n\tName string `json:\"name\"`\n\tType string `json:\"type\"`\n\tPath string `json:\"path\"`\n\tMode string `json:\"mode\"`\n}\n\nfunc (t TreeNode) String() string {\n\treturn Stringify(t)\n}\n\n// ListTreeOptions represents the available ListTree() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#list-repository-tree\ntype ListTreeOptions struct {\n\tListOptions\n\tPath      *string `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tRef       *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tRecursive *bool   `url:\"recursive,omitempty\" json:\"recursive,omitempty\"`\n}\n\n// ListTree gets a list of repository files and directories in a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#list-repository-tree\nfunc (s *RepositoriesService) ListTree(pid interface{}, opt *ListTreeOptions, options ...RequestOptionFunc) ([]*TreeNode, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tree\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar t []*TreeNode\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// Blob gets information about blob in repository like size and content. Note\n// that blob content is Base64 encoded.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#get-a-blob-from-repository\nfunc (s *RepositoriesService) Blob(pid interface{}, sha string, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/blobs/%s\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n\n// RawBlobContent gets the raw file contents for a blob by blob SHA.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#raw-blob-content\nfunc (s *RepositoriesService) RawBlobContent(pid interface{}, sha string, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/blobs/%s/raw\", PathEscape(project), url.PathEscape(sha))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n\n// ArchiveOptions represents the available Archive() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#get-file-archive\ntype ArchiveOptions struct {\n\tFormat *string `url:\"-\" json:\"-\"`\n\tPath   *string `url:\"path,omitempty\" json:\"path,omitempty\"`\n\tSHA    *string `url:\"sha,omitempty\" json:\"sha,omitempty\"`\n}\n\n// Archive gets an archive of the repository.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#get-file-archive\nfunc (s *RepositoriesService) Archive(pid interface{}, opt *ArchiveOptions, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/archive\", PathEscape(project))\n\n\t// Set an optional format for the archive.\n\tif opt != nil && opt.Format != nil {\n\t\tu = fmt.Sprintf(\"%s.%s\", u, *opt.Format)\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n\n// StreamArchive streams an archive of the repository to the provided\n// io.Writer.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#get-file-archive\nfunc (s *RepositoriesService) StreamArchive(pid interface{}, w io.Writer, opt *ArchiveOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/archive\", PathEscape(project))\n\n\t// Set an optional format for the archive.\n\tif opt != nil && opt.Format != nil {\n\t\tu = fmt.Sprintf(\"%s.%s\", u, *opt.Format)\n\t}\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, w)\n}\n\n// Compare represents the result of a comparison of branches, tags or commits.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#compare-branches-tags-or-commits\ntype Compare struct {\n\tCommit         *Commit   `json:\"commit\"`\n\tCommits        []*Commit `json:\"commits\"`\n\tDiffs          []*Diff   `json:\"diffs\"`\n\tCompareTimeout bool      `json:\"compare_timeout\"`\n\tCompareSameRef bool      `json:\"compare_same_ref\"`\n\tWebURL         string    `json:\"web_url\"`\n}\n\nfunc (c Compare) String() string {\n\treturn Stringify(c)\n}\n\n// CompareOptions represents the available Compare() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#compare-branches-tags-or-commits\ntype CompareOptions struct {\n\tFrom     *string `url:\"from,omitempty\" json:\"from,omitempty\"`\n\tTo       *string `url:\"to,omitempty\" json:\"to,omitempty\"`\n\tStraight *bool   `url:\"straight,omitempty\" json:\"straight,omitempty\"`\n\tUnidiff  *bool   `url:\"unidiff,omitempty\" json:\"unidiff,omitempty\"`\n}\n\n// Compare compares branches, tags or commits.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#compare-branches-tags-or-commits\nfunc (s *RepositoriesService) Compare(pid interface{}, opt *CompareOptions, options ...RequestOptionFunc) (*Compare, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/compare\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(Compare)\n\tresp, err := s.client.Do(req, c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// Contributor represents a GitLap contributor.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repositories.html#contributors\ntype Contributor struct {\n\tName      string `json:\"name\"`\n\tEmail     string `json:\"email\"`\n\tCommits   int    `json:\"commits\"`\n\tAdditions int    `json:\"additions\"`\n\tDeletions int    `json:\"deletions\"`\n}\n\nfunc (c Contributor) String() string {\n\treturn Stringify(c)\n}\n\n// ListContributorsOptions represents the available ListContributors() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repositories.html#contributors\ntype ListContributorsOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// Contributors gets the repository contributors list.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repositories.html#contributors\nfunc (s *RepositoriesService) Contributors(pid interface{}, opt *ListContributorsOptions, options ...RequestOptionFunc) ([]*Contributor, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/contributors\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar c []*Contributor\n\tresp, err := s.client.Do(req, &c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// MergeBaseOptions represents the available MergeBase() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#merge-base\ntype MergeBaseOptions struct {\n\tRef *[]string `url:\"refs[],omitempty\" json:\"refs,omitempty\"`\n}\n\n// MergeBase gets the common ancestor for 2 refs (commit SHAs, branch\n// names or tags).\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#merge-base\nfunc (s *RepositoriesService) MergeBase(pid interface{}, opt *MergeBaseOptions, options ...RequestOptionFunc) (*Commit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/merge_base\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(Commit)\n\tresp, err := s.client.Do(req, c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n\n// AddChangelogOptions represents the available AddChangelog() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#add-changelog-data-to-a-changelog-file\ntype AddChangelogOptions struct {\n\tVersion    *string  `url:\"version,omitempty\" json:\"version,omitempty\"`\n\tBranch     *string  `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tConfigFile *string  `url:\"config_file,omitempty\" json:\"config_file,omitempty\"`\n\tDate       *ISOTime `url:\"date,omitempty\" json:\"date,omitempty\"`\n\tFile       *string  `url:\"file,omitempty\" json:\"file,omitempty\"`\n\tFrom       *string  `url:\"from,omitempty\" json:\"from,omitempty\"`\n\tMessage    *string  `url:\"message,omitempty\" json:\"message,omitempty\"`\n\tTo         *string  `url:\"to,omitempty\" json:\"to,omitempty\"`\n\tTrailer    *string  `url:\"trailer,omitempty\" json:\"trailer,omitempty\"`\n}\n\n// AddChangelog generates changelog data based on commits in a repository.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#add-changelog-data-to-a-changelog-file\nfunc (s *RepositoriesService) AddChangelog(pid interface{}, opt *AddChangelogOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/changelog\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ChangelogData represents the generated changelog data.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#generate-changelog-data\ntype ChangelogData struct {\n\tNotes string `json:\"notes\"`\n}\n\nfunc (c ChangelogData) String() string {\n\treturn Stringify(c)\n}\n\n// GenerateChangelogDataOptions represents the available GenerateChangelogData()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#generate-changelog-data\ntype GenerateChangelogDataOptions struct {\n\tVersion    *string  `url:\"version,omitempty\" json:\"version,omitempty\"`\n\tConfigFile *string  `url:\"config_file,omitempty\" json:\"config_file,omitempty\"`\n\tDate       *ISOTime `url:\"date,omitempty\" json:\"date,omitempty\"`\n\tFrom       *string  `url:\"from,omitempty\" json:\"from,omitempty\"`\n\tTo         *string  `url:\"to,omitempty\" json:\"to,omitempty\"`\n\tTrailer    *string  `url:\"trailer,omitempty\" json:\"trailer,omitempty\"`\n}\n\n// GenerateChangelogData generates changelog data based on commits in a\n// repository, without committing them to a changelog file.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/repositories.html#generate-changelog-data\nfunc (s *RepositoriesService) GenerateChangelogData(pid interface{}, opt GenerateChangelogDataOptions, options ...RequestOptionFunc) (*ChangelogData, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/changelog\", project)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcd := new(ChangelogData)\n\tresp, err := s.client.Do(req, cd)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn cd, resp, nil\n}\n"
        },
        {
          "name": "repositories_test.go",
          "type": "blob",
          "size": 13.75390625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRepositoriesService_ListTree(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/tree\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": \"a1e8f8d745cc87e3a9248358d9352bb7f9a0aeba\",\n\t\t\t\t\"name\": \"html\",\n\t\t\t\t\"type\": \"tree\",\n\t\t\t\t\"path\": \"files/html\",\n\t\t\t\t\"mode\": \"040000\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*TreeNode{\n\t\t{\n\t\t\tID:   \"a1e8f8d745cc87e3a9248358d9352bb7f9a0aeba\",\n\t\t\tName: \"html\",\n\t\t\tType: \"tree\",\n\t\t\tPath: \"files/html\",\n\t\t\tMode: \"040000\",\n\t\t},\n\t}\n\n\tlto := ListTreeOptions{\n\t\tListOptions: ListOptions{\n\t\t\tPerPage:   1,\n\t\t\tPageToken: \"a1e8f8d745cc87e3a9248358d9352bb7f9a0aeba\",\n\t\t},\n\t}\n\n\ttns, resp, err := client.Repositories.ListTree(1, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, tns)\n\n\ttns, resp, err = client.Repositories.ListTree(1.01, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, tns)\n\n\ttns, resp, err = client.Repositories.ListTree(1, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, tns)\n\n\ttns, resp, err = client.Repositories.ListTree(2, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, tns)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n\n\ttns, resp, err = client.Repositories.ListTree(1, &lto)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, tns)\n}\n\nfunc TestRepositoriesService_Blob(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/blobs/2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, \"{\"+\n\t\t\t\"size: 100\"+\n\t\t\t\"content: content\"+\n\t\t\t\"}\",\n\t\t)\n\t})\n\n\twant := []byte(\"{\" +\n\t\t\"size: 100\" +\n\t\t\"content: content\" +\n\t\t\"}\")\n\n\tb, resp, err := client.Repositories.Blob(1, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Repositories.Blob(1.01, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Repositories.Blob(1, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Repositories.Blob(2, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoriesService_RawBlobContent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/blobs/2dc6aa325a317eda67812f05600bdf0fcdc70ab0/raw\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, \"{\"+\n\t\t\t\"size: 100\"+\n\t\t\t\"content: content\"+\n\t\t\t\"}\",\n\t\t)\n\t})\n\n\twant := []byte(\"{\" +\n\t\t\"size: 100\" +\n\t\t\"content: content\" +\n\t\t\"}\")\n\n\tb, resp, err := client.Repositories.RawBlobContent(1, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Repositories.RawBlobContent(1.01, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Repositories.RawBlobContent(1, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Repositories.RawBlobContent(2, \"2dc6aa325a317eda67812f05600bdf0fcdc70ab0\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoriesService_Archive(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/archive.gz\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, \"{\"+\n\t\t\t\"size: 100\"+\n\t\t\t\"content: content\"+\n\t\t\t\"}\",\n\t\t)\n\t})\n\n\topt := &ArchiveOptions{Format: Ptr(\"gz\")}\n\twant := []byte(\"{\" +\n\t\t\"size: 100\" +\n\t\t\"content: content\" +\n\t\t\"}\")\n\n\tb, resp, err := client.Repositories.Archive(1, opt, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.Repositories.Archive(1.01, opt, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Repositories.Archive(1, opt, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.Repositories.Archive(2, opt, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoriesService_StreamArchive(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/archive.gz\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t})\n\n\tvar w http.ResponseWriter\n\topt := &ArchiveOptions{Format: Ptr(\"gz\")}\n\n\tresp, err := client.Repositories.StreamArchive(1, w, opt, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.Repositories.StreamArchive(1.01, w, opt, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Repositories.StreamArchive(1, w, opt, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.Repositories.StreamArchive(2, w, opt, nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoriesService_Compare(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/12d65c8dd2b2676fa3ac47d955accc085a37a9c1/repository/compare\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"commit\": {\n\t\t\t\t\"id\": \"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\",\n\t\t\t\t\"short_id\": \"12d65c8dd2b\",\n\t\t\t\t\"title\": \"JS fix\",\n\t\t\t\t\"author_name\": \"Example User\",\n\t\t\t\t\"author_email\": \"user@example.com\"\n\t\t\t  },\n\t\t\t  \"commits\": [{\n\t\t\t\t\"id\": \"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\",\n\t\t\t\t\"short_id\": \"12d65c8dd2b\",\n\t\t\t\t\"title\": \"JS fix\",\n\t\t\t\t\"author_name\": \"Example User\",\n\t\t\t\t\"author_email\": \"user@example.com\"\n\t\t\t  }],\n\t\t\t  \"diffs\": [{\n\t\t\t\t\"old_path\": \"files/js/application.js\",\n\t\t\t\t\"new_path\": \"files/js/application.js\",\n\t\t\t\t\"a_mode\": null,\n\t\t\t\t\"b_mode\": \"100644\",\n\t\t\t\t\"diff\": \"--- a/files/js/application.js\\n+++ c/files/js/application.js\\n@@ -24,8 +24,10 @@\\n //= require g.raphael-min\\n //= require g.bar-min\\n //= require branch-graph\\n-//= require highlightjs.min\\n-//= require ace/ace\\n //= require_tree .\\n //= require d3\\n //= require underscore\\n+\\n+function fix() { \\n+  alert(\\\"Fixed\\\")\\n+}\",\n\t\t\t\t\"new_file\": false,\n\t\t\t\t\"renamed_file\": false,\n\t\t\t\t\"deleted_file\": false\n\t\t\t  }],\n\t\t\t  \"compare_timeout\": false,\n\t\t\t  \"compare_same_ref\": false,\n\t\t\t  \"web_url\": \"https://gitlab.example.com/thedude/gitlab-foss/-/compare/ae73cb07c9eeaf35924a10f713b364d32b2dd34f...0b4bc9a49b562e85de7cc9e834518ea6828729b9\"\n\t\t\t}\n\t\t`)\n\t})\n\n\topt := &CompareOptions{\n\t\tFrom: Ptr(\"master\"),\n\t\tTo:   Ptr(\"feature\"),\n\t}\n\twant := &Compare{\n\t\tCommit: &Commit{\n\t\t\tID:          \"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\",\n\t\t\tShortID:     \"12d65c8dd2b\",\n\t\t\tTitle:       \"JS fix\",\n\t\t\tAuthorName:  \"Example User\",\n\t\t\tAuthorEmail: \"user@example.com\",\n\t\t},\n\t\tCommits: []*Commit{{\n\t\t\tID:          \"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\",\n\t\t\tShortID:     \"12d65c8dd2b\",\n\t\t\tTitle:       \"JS fix\",\n\t\t\tAuthorName:  \"Example User\",\n\t\t\tAuthorEmail: \"user@example.com\",\n\t\t}},\n\t\tDiffs: []*Diff{{\n\t\t\tDiff:        \"--- a/files/js/application.js\\n+++ c/files/js/application.js\\n@@ -24,8 +24,10 @@\\n //= require g.raphael-min\\n //= require g.bar-min\\n //= require branch-graph\\n-//= require highlightjs.min\\n-//= require ace/ace\\n //= require_tree .\\n //= require d3\\n //= require underscore\\n+\\n+function fix() { \\n+  alert(\\\"Fixed\\\")\\n+}\",\n\t\t\tNewPath:     \"files/js/application.js\",\n\t\t\tOldPath:     \"files/js/application.js\",\n\t\t\tAMode:       \"\",\n\t\t\tBMode:       \"100644\",\n\t\t\tNewFile:     false,\n\t\t\tRenamedFile: false,\n\t\t\tDeletedFile: false,\n\t\t}},\n\t\tCompareTimeout: false,\n\t\tCompareSameRef: false,\n\t\tWebURL:         \"https://gitlab.example.com/thedude/gitlab-foss/-/compare/ae73cb07c9eeaf35924a10f713b364d32b2dd34f...0b4bc9a49b562e85de7cc9e834518ea6828729b9\",\n\t}\n\n\tc, resp, err := client.Repositories.Compare(\"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\", opt, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, c)\n\n\tc, resp, err = client.Repositories.Compare(1.01, opt, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Repositories.Compare(\"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\", opt, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Repositories.Compare(\"12d65c8dd2b2676fa3ac47d955accc085a37a9c2\", opt, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, c)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoriesService_Contributors(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/12d65c8dd2b2676fa3ac47d955accc085a37a9c1/repository/contributors\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[{\n\t\t\t  \"name\": \"Example User\",\n\t\t\t  \"email\": \"example@example.com\",\n\t\t\t  \"commits\": 117,\n\t\t\t  \"additions\": 0,\n\t\t\t  \"deletions\": 0\n\t\t\t}]\n\t\t`)\n\t})\n\n\twant := []*Contributor{{\n\t\tName:      \"Example User\",\n\t\tEmail:     \"example@example.com\",\n\t\tCommits:   117,\n\t\tAdditions: 0,\n\t\tDeletions: 0,\n\t}}\n\n\tcs, resp, err := client.Repositories.Contributors(\"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, cs)\n\n\tcs, resp, err = client.Repositories.Contributors(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cs)\n\n\tcs, resp, err = client.Repositories.Contributors(\"12d65c8dd2b2676fa3ac47d955accc085a37a9c1\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, cs)\n\n\tcs, resp, err = client.Repositories.Contributors(\"12d65c8dd2b2676fa3ac47d955accc085a37a9c2\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, cs)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoriesService_MergeBase(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1a0b36b3cdad1d2ee32457c102a8c0b7056fa863/repository/merge_base\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": \"1a0b36b3cdad1d2ee32457c102a8c0b7056fa863\",\n\t\t\t  \"short_id\": \"1a0b36b3\",\n\t\t\t  \"title\": \"Initial commit\",\n\t\t\t  \"parent_ids\": [],\n\t\t\t  \"message\": \"Initial commit\\n\",\n\t\t\t  \"author_name\": \"Example User\",\n\t\t\t  \"author_email\": \"user@example.com\",\n\t\t\t  \"committer_name\": \"Example User\",\n\t\t\t  \"committer_email\": \"user@example.com\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &Commit{\n\t\tID:             \"1a0b36b3cdad1d2ee32457c102a8c0b7056fa863\",\n\t\tShortID:        \"1a0b36b3\",\n\t\tTitle:          \"Initial commit\",\n\t\tAuthorName:     \"Example User\",\n\t\tAuthorEmail:    \"user@example.com\",\n\t\tCommitterName:  \"Example User\",\n\t\tCommitterEmail: \"user@example.com\",\n\t\tMessage:        \"Initial commit\\n\",\n\t\tParentIDs:      []string{},\n\t}\n\n\tc, resp, err := client.Repositories.MergeBase(\"1a0b36b3cdad1d2ee32457c102a8c0b7056fa863\", nil, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, c)\n\n\tc, resp, err = client.Repositories.MergeBase(1.01, nil, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Repositories.MergeBase(\"1a0b36b3cdad1d2ee32457c102a8c0b7056fa863\", nil, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, c)\n\n\tc, resp, err = client.Repositories.MergeBase(\"1a0b36b3cdad1d2ee32457c102a8c0b7056fa865\", nil, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, c)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestAddChangelogData(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/changelog\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tw.WriteHeader(http.StatusOK)\n\t\t})\n\n\tresp, err := client.Repositories.AddChangelog(\n\t\t1,\n\t\t&AddChangelogOptions{\n\t\t\tVersion: Ptr(\"1.0.0\"),\n\t\t})\n\trequire.NoError(t, err)\n\tassert.Equal(t, http.StatusOK, resp.StatusCode)\n}\n\nfunc TestGenerateChangelogData(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/changelog\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, exampleChangelogResponse)\n\t\t})\n\n\twant := &ChangelogData{\n\t\tNotes: \"## 1.0.0 (2021-11-17)\\n\\n### feature (2 changes)\\n\\n- [Title 2](namespace13/project13@ad608eb642124f5b3944ac0ac772fecaf570a6bf) ([merge request](namespace13/project13!2))\\n- [Title 1](namespace13/project13@3c6b80ff7034fa0d585314e1571cc780596ce3c8) ([merge request](namespace13/project13!1))\\n\",\n\t}\n\n\tnotes, _, err := client.Repositories.GenerateChangelogData(\n\t\t1,\n\t\tGenerateChangelogDataOptions{\n\t\t\tVersion: Ptr(\"1.0.0\"),\n\t\t},\n\t)\n\trequire.NoError(t, err)\n\tassert.Equal(t, want, notes)\n}\n"
        },
        {
          "name": "repository_files.go",
          "type": "blob",
          "size": 12.2177734375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// RepositoryFilesService handles communication with the repository files\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repository_files.html\ntype RepositoryFilesService struct {\n\tclient *Client\n}\n\n// File represents a GitLab repository file.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repository_files.html\ntype File struct {\n\tFileName        string `json:\"file_name\"`\n\tFilePath        string `json:\"file_path\"`\n\tSize            int    `json:\"size\"`\n\tEncoding        string `json:\"encoding\"`\n\tContent         string `json:\"content\"`\n\tExecuteFilemode bool   `json:\"execute_filemode\"`\n\tRef             string `json:\"ref\"`\n\tBlobID          string `json:\"blob_id\"`\n\tCommitID        string `json:\"commit_id\"`\n\tSHA256          string `json:\"content_sha256\"`\n\tLastCommitID    string `json:\"last_commit_id\"`\n}\n\nfunc (r File) String() string {\n\treturn Stringify(r)\n}\n\n// GetFileOptions represents the available GetFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-file-from-repository\ntype GetFileOptions struct {\n\tRef *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\n// GetFile allows you to receive information about a file in repository like\n// name, size, content. Note that file content is Base64 encoded.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-file-from-repository\nfunc (s *RepositoryFilesService) GetFile(pid interface{}, fileName string, opt *GetFileOptions, options ...RequestOptionFunc) (*File, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tf := new(File)\n\tresp, err := s.client.Do(req, f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f, resp, nil\n}\n\n// GetFileMetaDataOptions represents the available GetFileMetaData() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-file-from-repository\ntype GetFileMetaDataOptions struct {\n\tRef *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\n// GetFileMetaData allows you to receive meta information about a file in\n// repository like name, size.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-file-from-repository\nfunc (s *RepositoryFilesService) GetFileMetaData(pid interface{}, fileName string, opt *GetFileMetaDataOptions, options ...RequestOptionFunc) (*File, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodHead, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\tf := &File{\n\t\tBlobID:          resp.Header.Get(\"X-Gitlab-Blob-Id\"),\n\t\tCommitID:        resp.Header.Get(\"X-Gitlab-Commit-Id\"),\n\t\tEncoding:        resp.Header.Get(\"X-Gitlab-Encoding\"),\n\t\tFileName:        resp.Header.Get(\"X-Gitlab-File-Name\"),\n\t\tFilePath:        resp.Header.Get(\"X-Gitlab-File-Path\"),\n\t\tExecuteFilemode: resp.Header.Get(\"X-Gitlab-Execute-Filemode\") == \"true\",\n\t\tRef:             resp.Header.Get(\"X-Gitlab-Ref\"),\n\t\tSHA256:          resp.Header.Get(\"X-Gitlab-Content-Sha256\"),\n\t\tLastCommitID:    resp.Header.Get(\"X-Gitlab-Last-Commit-Id\"),\n\t}\n\n\tif sizeString := resp.Header.Get(\"X-Gitlab-Size\"); sizeString != \"\" {\n\t\tf.Size, err = strconv.Atoi(sizeString)\n\t\tif err != nil {\n\t\t\treturn nil, resp, err\n\t\t}\n\t}\n\n\treturn f, resp, nil\n}\n\n// FileBlameRange represents one item of blame information.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repository_files.html\ntype FileBlameRange struct {\n\tCommit struct {\n\t\tID             string     `json:\"id\"`\n\t\tParentIDs      []string   `json:\"parent_ids\"`\n\t\tMessage        string     `json:\"message\"`\n\t\tAuthoredDate   *time.Time `json:\"authored_date\"`\n\t\tAuthorName     string     `json:\"author_name\"`\n\t\tAuthorEmail    string     `json:\"author_email\"`\n\t\tCommittedDate  *time.Time `json:\"committed_date\"`\n\t\tCommitterName  string     `json:\"committer_name\"`\n\t\tCommitterEmail string     `json:\"committer_email\"`\n\t} `json:\"commit\"`\n\tLines []string `json:\"lines\"`\n}\n\nfunc (b FileBlameRange) String() string {\n\treturn Stringify(b)\n}\n\n// GetFileBlameOptions represents the available GetFileBlame() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-file-blame-from-repository\ntype GetFileBlameOptions struct {\n\tRef        *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tRangeStart *int    `url:\"range[start],omitempty\" json:\"range[start],omitempty\"`\n\tRangeEnd   *int    `url:\"range[end],omitempty\" json:\"range[end],omitempty\"`\n}\n\n// GetFileBlame allows you to receive blame information. Each blame range\n// contains lines and corresponding commit info.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-file-blame-from-repository\nfunc (s *RepositoryFilesService) GetFileBlame(pid interface{}, file string, opt *GetFileBlameOptions, options ...RequestOptionFunc) ([]*FileBlameRange, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s/blame\",\n\t\tPathEscape(project),\n\t\tPathEscape(file),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar br []*FileBlameRange\n\tresp, err := s.client.Do(req, &br)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn br, resp, nil\n}\n\n// GetRawFileOptions represents the available GetRawFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-raw-file-from-repository\ntype GetRawFileOptions struct {\n\tRef *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tLFS *bool   `url:\"lfs,omitempty\" json:\"lfs,omitempty\"`\n}\n\n// GetRawFile allows you to receive the raw file in repository.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#get-raw-file-from-repository\nfunc (s *RepositoryFilesService) GetRawFile(pid interface{}, fileName string, opt *GetRawFileOptions, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s/raw\",\n\t\tPathEscape(project),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar f bytes.Buffer\n\tresp, err := s.client.Do(req, &f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f.Bytes(), resp, err\n}\n\n// FileInfo represents file details of a GitLab repository file.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repository_files.html\ntype FileInfo struct {\n\tFilePath string `json:\"file_path\"`\n\tBranch   string `json:\"branch\"`\n}\n\nfunc (r FileInfo) String() string {\n\treturn Stringify(r)\n}\n\n// CreateFileOptions represents the available CreateFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository\ntype CreateFileOptions struct {\n\tBranch          *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tStartBranch     *string `url:\"start_branch,omitempty\" json:\"start_branch,omitempty\"`\n\tEncoding        *string `url:\"encoding,omitempty\" json:\"encoding,omitempty\"`\n\tAuthorEmail     *string `url:\"author_email,omitempty\" json:\"author_email,omitempty\"`\n\tAuthorName      *string `url:\"author_name,omitempty\" json:\"author_name,omitempty\"`\n\tContent         *string `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tCommitMessage   *string `url:\"commit_message,omitempty\" json:\"commit_message,omitempty\"`\n\tExecuteFilemode *bool   `url:\"execute_filemode,omitempty\" json:\"execute_filemode,omitempty\"`\n}\n\n// CreateFile creates a new file in a repository.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#create-new-file-in-repository\nfunc (s *RepositoryFilesService) CreateFile(pid interface{}, fileName string, opt *CreateFileOptions, options ...RequestOptionFunc) (*FileInfo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tf := new(FileInfo)\n\tresp, err := s.client.Do(req, f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f, resp, nil\n}\n\n// UpdateFileOptions represents the available UpdateFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository\ntype UpdateFileOptions struct {\n\tBranch          *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tStartBranch     *string `url:\"start_branch,omitempty\" json:\"start_branch,omitempty\"`\n\tEncoding        *string `url:\"encoding,omitempty\" json:\"encoding,omitempty\"`\n\tAuthorEmail     *string `url:\"author_email,omitempty\" json:\"author_email,omitempty\"`\n\tAuthorName      *string `url:\"author_name,omitempty\" json:\"author_name,omitempty\"`\n\tContent         *string `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tCommitMessage   *string `url:\"commit_message,omitempty\" json:\"commit_message,omitempty\"`\n\tLastCommitID    *string `url:\"last_commit_id,omitempty\" json:\"last_commit_id,omitempty\"`\n\tExecuteFilemode *bool   `url:\"execute_filemode,omitempty\" json:\"execute_filemode,omitempty\"`\n}\n\n// UpdateFile updates an existing file in a repository\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#update-existing-file-in-repository\nfunc (s *RepositoryFilesService) UpdateFile(pid interface{}, fileName string, opt *UpdateFileOptions, options ...RequestOptionFunc) (*FileInfo, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tf := new(FileInfo)\n\tresp, err := s.client.Do(req, f)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn f, resp, nil\n}\n\n// DeleteFileOptions represents the available DeleteFile() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#delete-existing-file-in-repository\ntype DeleteFileOptions struct {\n\tBranch        *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tStartBranch   *string `url:\"start_branch,omitempty\" json:\"start_branch,omitempty\"`\n\tAuthorEmail   *string `url:\"author_email,omitempty\" json:\"author_email,omitempty\"`\n\tAuthorName    *string `url:\"author_name,omitempty\" json:\"author_name,omitempty\"`\n\tCommitMessage *string `url:\"commit_message,omitempty\" json:\"commit_message,omitempty\"`\n\tLastCommitID  *string `url:\"last_commit_id,omitempty\" json:\"last_commit_id,omitempty\"`\n}\n\n// DeleteFile deletes an existing file in a repository\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_files.html#delete-existing-file-in-repository\nfunc (s *RepositoryFilesService) DeleteFile(pid interface{}, fileName string, opt *DeleteFileOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/files/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(fileName),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "repository_files_test.go",
          "type": "blob",
          "size": 12.5927734375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRepositoryFilesService_GetFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/app%2Fmodels%2Fkey%2Erb?ref=master\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"file_name\": \"key.rb\",\n\t\t\t  \"file_path\": \"app/models/key.rb\",\n\t\t\t  \"size\": 1476,\n\t\t\t  \"encoding\": \"base64\",\n\t\t\t  \"content\": \"IyA9PSBTY2hlbWEgSW5mb3...\",\n\t\t\t  \"content_sha256\": \"4c294617b60715c1d218e61164a3abd4808a4284cbc30e6728a01ad9aada4481\",\n\t\t\t  \"execute_filemode\": true,\n\t\t\t  \"ref\": \"master\",\n\t\t\t  \"blob_id\": \"79f7bbd25901e8334750839545a9bd021f0e4c83\",\n\t\t\t  \"commit_id\": \"d5a3ff139356ce33e37e73add446f16869741b50\",\n\t\t\t  \"last_commit_id\": \"570e7b2abdd848b95f2f578043fc23bd6f6fd24d\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &File{\n\t\tFileName:        \"key.rb\",\n\t\tFilePath:        \"app/models/key.rb\",\n\t\tSize:            1476,\n\t\tEncoding:        \"base64\",\n\t\tContent:         \"IyA9PSBTY2hlbWEgSW5mb3...\",\n\t\tExecuteFilemode: true,\n\t\tRef:             \"master\",\n\t\tBlobID:          \"79f7bbd25901e8334750839545a9bd021f0e4c83\",\n\t\tCommitID:        \"d5a3ff139356ce33e37e73add446f16869741b50\",\n\t\tSHA256:          \"4c294617b60715c1d218e61164a3abd4808a4284cbc30e6728a01ad9aada4481\",\n\t\tLastCommitID:    \"570e7b2abdd848b95f2f578043fc23bd6f6fd24d\",\n\t}\n\n\tf, resp, err := client.RepositoryFiles.GetFile(13083, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, f)\n\n\tf, resp, err = client.RepositoryFiles.GetFile(13083.01, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, f)\n\n\tf, resp, err = client.RepositoryFiles.GetFile(13083, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, f)\n\n\tf, resp, err = client.RepositoryFiles.GetFile(13084, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, f)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoryFilesService_GetFileMetaData(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/app%2Fmodels%2Fkey%2Erb?ref=master\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodHead)\n\t\tw.Header().Set(\"X-Gitlab-Blob-Id\", \"79f7bbd25901e8334750839545a9bd021f0e4c83\")\n\t\tw.Header().Set(\"X-Gitlab-Commit-Id\", \"d5a3ff139356ce33e37e73add446f16869741b50\")\n\t\tw.Header().Set(\"X-Gitlab-Content-Sha256\", \"4c294617b60715c1d218e61164a3abd4808a4284cbc30e6728a01ad9aada4481\")\n\t\tw.Header().Set(\"X-Gitlab-Encoding\", \"base64\")\n\t\tw.Header().Set(\"X-Gitlab-File-Name\", \"key.rb\")\n\t\tw.Header().Set(\"X-Gitlab-File-Path\", \"app/models/key.rb\")\n\t\tw.Header().Set(\"X-Gitlab-Execute-Filemode\", \"true\")\n\t\tw.Header().Set(\"X-Gitlab-Last-Commit-Id\", \"570e7b2abdd848b95f2f578043fc23bd6f6fd24d\")\n\t\tw.Header().Set(\"X-Gitlab-Ref\", \"master\")\n\t\tw.Header().Set(\"X-Gitlab-Size\", \"1476\")\n\t})\n\n\twant := &File{\n\t\tFileName:        \"key.rb\",\n\t\tFilePath:        \"app/models/key.rb\",\n\t\tSize:            1476,\n\t\tEncoding:        \"base64\",\n\t\tExecuteFilemode: true,\n\t\tRef:             \"master\",\n\t\tBlobID:          \"79f7bbd25901e8334750839545a9bd021f0e4c83\",\n\t\tCommitID:        \"d5a3ff139356ce33e37e73add446f16869741b50\",\n\t\tSHA256:          \"4c294617b60715c1d218e61164a3abd4808a4284cbc30e6728a01ad9aada4481\",\n\t\tLastCommitID:    \"570e7b2abdd848b95f2f578043fc23bd6f6fd24d\",\n\t}\n\n\tf, resp, err := client.RepositoryFiles.GetFileMetaData(13083, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, f)\n\n\tf, resp, err = client.RepositoryFiles.GetFileMetaData(13083.01, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, f)\n\n\tf, resp, err = client.RepositoryFiles.GetFileMetaData(13083, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, f)\n\n\tf, resp, err = client.RepositoryFiles.GetFileMetaData(13084, \"app%2Fmodels%2Fkey%2Erb?ref=master\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, f)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoryFilesService_GetFileBlame(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/path%2Fto%2Ffile.rb/blame\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"commit\": {\n\t\t\t\t  \"id\": \"d42409d56517157c48bf3bd97d3f75974dde19fb\",\n\t\t\t\t  \"message\": \"Add feature also fix bug\",\n\t\t\t\t  \"parent_ids\": [\n\t\t\t\t\t\"cc6e14f9328fa6d7b5a0d3c30dc2002a3f2a3822\"\n\t\t\t\t  ],\n\t\t\t\t  \"author_name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"author_email\": \"venkatesh.thalluri@example.com\",\n\t\t\t\t  \"committer_name\": \"Venkatesh Thalluri\",\n\t\t\t\t  \"committer_email\": \"venkatesh.thalluri@example.com\"\n\t\t\t\t},\n\t\t\t\t\"lines\": [\n\t\t\t\t  \"require 'fileutils'\",\n\t\t\t\t  \"require 'open3'\"\n\t\t\t\t]\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*FileBlameRange{\n\t\t{\n\t\t\tCommit: struct {\n\t\t\t\tID             string     `json:\"id\"`\n\t\t\t\tParentIDs      []string   `json:\"parent_ids\"`\n\t\t\t\tMessage        string     `json:\"message\"`\n\t\t\t\tAuthoredDate   *time.Time `json:\"authored_date\"`\n\t\t\t\tAuthorName     string     `json:\"author_name\"`\n\t\t\t\tAuthorEmail    string     `json:\"author_email\"`\n\t\t\t\tCommittedDate  *time.Time `json:\"committed_date\"`\n\t\t\t\tCommitterName  string     `json:\"committer_name\"`\n\t\t\t\tCommitterEmail string     `json:\"committer_email\"`\n\t\t\t}{\n\t\t\t\tID:             \"d42409d56517157c48bf3bd97d3f75974dde19fb\",\n\t\t\t\tParentIDs:      []string{\"cc6e14f9328fa6d7b5a0d3c30dc2002a3f2a3822\"},\n\t\t\t\tMessage:        \"Add feature also fix bug\",\n\t\t\t\tAuthorName:     \"Venkatesh Thalluri\",\n\t\t\t\tAuthorEmail:    \"venkatesh.thalluri@example.com\",\n\t\t\t\tCommitterName:  \"Venkatesh Thalluri\",\n\t\t\t\tCommitterEmail: \"venkatesh.thalluri@example.com\",\n\t\t\t},\n\t\t\tLines: []string{\"require 'fileutils'\", \"require 'open3'\"},\n\t\t},\n\t}\n\n\tfbr, resp, err := client.RepositoryFiles.GetFileBlame(13083, \"path%2Fto%2Ffile.rb\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fbr)\n\n\tfbr, resp, err = client.RepositoryFiles.GetFileBlame(13083.01, \"path%2Fto%2Ffile.rb\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fbr)\n\n\tfbr, resp, err = client.RepositoryFiles.GetFileBlame(13083, \"path%2Fto%2Ffile.rb\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fbr)\n\n\tfbr, resp, err = client.RepositoryFiles.GetFileBlame(13084, \"path%2Fto%2Ffile.rb\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fbr)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoryFilesService_GetRawFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/app%2Fmodels%2Fkey%2Erb/raw\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, \"HTTP/1.1 200 OK\"+\n\t\t\t\"...\"+\n\t\t\t\"X-Gitlab-Blob-Id: 79f7bbd25901e8334750839545a9bd021f0e4c83\"+\n\t\t\t\"X-Gitlab-Commit-Id: d5a3ff139356ce33e37e73add446f16869741b50\"+\n\t\t\t\"X-Gitlab-Content-Sha256: 4c294617b60715c1d218e61164a3abd4808a4284cbc30e6728a01ad9aada4481\"+\n\t\t\t\"X-Gitlab-Encoding: base64\"+\n\t\t\t\"X-Gitlab-File-Name: file.rb\"+\n\t\t\t\"X-Gitlab-File-Path: path/to/file.rb\"+\n\t\t\t\"X-Gitlab-Last-Commit-Id: 570e7b2abdd848b95f2f578043fc23bd6f6fd24d\"+\n\t\t\t\"X-Gitlab-Ref: master\"+\n\t\t\t\"X-Gitlab-Size: 1476\"+\n\t\t\t\"...\")\n\t})\n\n\twant := []byte(\"HTTP/1.1 200 OK\" +\n\t\t\"...\" +\n\t\t\"X-Gitlab-Blob-Id: 79f7bbd25901e8334750839545a9bd021f0e4c83\" +\n\t\t\"X-Gitlab-Commit-Id: d5a3ff139356ce33e37e73add446f16869741b50\" +\n\t\t\"X-Gitlab-Content-Sha256: 4c294617b60715c1d218e61164a3abd4808a4284cbc30e6728a01ad9aada4481\" +\n\t\t\"X-Gitlab-Encoding: base64\" +\n\t\t\"X-Gitlab-File-Name: file.rb\" +\n\t\t\"X-Gitlab-File-Path: path/to/file.rb\" +\n\t\t\"X-Gitlab-Last-Commit-Id: 570e7b2abdd848b95f2f578043fc23bd6f6fd24d\" +\n\t\t\"X-Gitlab-Ref: master\" +\n\t\t\"X-Gitlab-Size: 1476\" +\n\t\t\"...\",\n\t)\n\n\tb, resp, err := client.RepositoryFiles.GetRawFile(13083, \"app%2Fmodels%2Fkey%2Erb\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, b)\n\n\tb, resp, err = client.RepositoryFiles.GetRawFile(13083.01, \"app%2Fmodels%2Fkey%2Erb\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.RepositoryFiles.GetRawFile(13083, \"app%2Fmodels%2Fkey%2Erb\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, b)\n\n\tb, resp, err = client.RepositoryFiles.GetRawFile(13084, \"app%2Fmodels%2Fkey%2Erb\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, b)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoryFilesService_CreateFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/app%2Fproject%2Erb\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"file_path\": \"app/project.rb\",\n\t\t\t  \"branch\": \"master\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &FileInfo{\n\t\tFilePath: \"app/project.rb\",\n\t\tBranch:   \"master\",\n\t}\n\n\tfi, resp, err := client.RepositoryFiles.CreateFile(13083, \"app%2Fproject%2Erb\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fi)\n\n\tfi, resp, err = client.RepositoryFiles.CreateFile(13083, \"app%2Fproject%2Erb\", &CreateFileOptions{ExecuteFilemode: Ptr(true)})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fi)\n\n\tfi, resp, err = client.RepositoryFiles.CreateFile(13083.01, \"app%2Fproject%2Erb\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fi)\n\n\tfi, resp, err = client.RepositoryFiles.CreateFile(13083, \"app%2Fproject%2Erb\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fi)\n\n\tfi, resp, err = client.RepositoryFiles.CreateFile(13084, \"app%2Fproject%2Erb\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fi)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoryFilesService_UpdateFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/app%2Fproject%2Erb\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"file_path\": \"app/project.rb\",\n\t\t\t  \"branch\": \"master\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &FileInfo{\n\t\tFilePath: \"app/project.rb\",\n\t\tBranch:   \"master\",\n\t}\n\n\tfi, resp, err := client.RepositoryFiles.UpdateFile(13083, \"app%2Fproject%2Erb\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fi)\n\n\tfi, resp, err = client.RepositoryFiles.UpdateFile(13083, \"app%2Fproject%2Erb\", &UpdateFileOptions{ExecuteFilemode: Ptr(true)})\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, fi)\n\n\tfi, resp, err = client.RepositoryFiles.UpdateFile(13083.01, \"app%2Fproject%2Erb\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fi)\n\n\tfi, resp, err = client.RepositoryFiles.UpdateFile(13083, \"app%2Fproject%2Erb\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, fi)\n\n\tfi, resp, err = client.RepositoryFiles.UpdateFile(13084, \"app%2Fproject%2Erb\", nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, fi)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestRepositoryFilesService_DeleteFile(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/files/app%2Fproject%2Erb\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\tresp, err := client.RepositoryFiles.DeleteFile(13083, \"app%2Fproject%2Erb\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\n\tresp, err = client.RepositoryFiles.DeleteFile(13083.01, \"app%2Fproject%2Erb\", nil)\n\trequire.EqualError(t, err, \"invalid ID type 13083.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.RepositoryFiles.DeleteFile(13083, \"app%2Fproject%2Erb\", nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\n\tresp, err = client.RepositoryFiles.DeleteFile(13084, \"app%2Fproject%2Erb\", nil)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "repository_submodules.go",
          "type": "blob",
          "size": 3.07421875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// RepositorySubmodulesService handles communication with the repository\n// submodules related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repository_submodules.html\ntype RepositorySubmodulesService struct {\n\tclient *Client\n}\n\n// SubmoduleCommit represents a GitLab submodule commit.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/repository_submodules.html\ntype SubmoduleCommit struct {\n\tID             string           `json:\"id\"`\n\tShortID        string           `json:\"short_id\"`\n\tTitle          string           `json:\"title\"`\n\tAuthorName     string           `json:\"author_name\"`\n\tAuthorEmail    string           `json:\"author_email\"`\n\tCommitterName  string           `json:\"committer_name\"`\n\tCommitterEmail string           `json:\"committer_email\"`\n\tCreatedAt      *time.Time       `json:\"created_at\"`\n\tMessage        string           `json:\"message\"`\n\tParentIDs      []string         `json:\"parent_ids\"`\n\tCommittedDate  *time.Time       `json:\"committed_date\"`\n\tAuthoredDate   *time.Time       `json:\"authored_date\"`\n\tStatus         *BuildStateValue `json:\"status\"`\n}\n\nfunc (r SubmoduleCommit) String() string {\n\treturn Stringify(r)\n}\n\n// UpdateSubmoduleOptions represents the available UpdateSubmodule() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_submodules.html#update-existing-submodule-reference-in-repository\ntype UpdateSubmoduleOptions struct {\n\tBranch        *string `url:\"branch,omitempty\" json:\"branch,omitempty\"`\n\tCommitSHA     *string `url:\"commit_sha,omitempty\" json:\"commit_sha,omitempty\"`\n\tCommitMessage *string `url:\"commit_message,omitempty\" json:\"commit_message,omitempty\"`\n}\n\n// UpdateSubmodule updates an existing submodule reference.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/repository_submodules.html#update-existing-submodule-reference-in-repository\nfunc (s *RepositorySubmodulesService) UpdateSubmodule(pid interface{}, submodule string, opt *UpdateSubmoduleOptions, options ...RequestOptionFunc) (*SubmoduleCommit, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\n\t\t\"projects/%s/repository/submodules/%s\",\n\t\tPathEscape(project),\n\t\tPathEscape(submodule),\n\t)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsc := new(SubmoduleCommit)\n\tresp, err := s.client.Do(req, sc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn sc, resp, nil\n}\n"
        },
        {
          "name": "repository_submodules_test.go",
          "type": "blob",
          "size": 1.388671875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRepositorySubmodulesService_UpdateSubmodule(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/13083/repository/submodules/app%2Fproject\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\t\t  \"short_id\": \"6104942438c\",\n\t\t\t  \"title\": \"Update my submodule\",\n\t\t\t  \"author_name\": \"popdabubbles\",\n\t\t\t  \"author_email\": \"noty@gmail.com\",\n\t\t\t  \"committer_name\": \"Will\",\n\t\t\t  \"committer_email\": \"noty@gmail.com\",\n\t\t\t  \"message\": \"Update my submodule\",\n\t\t\t  \"parent_ids\": [\n\t\t\t    \"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"\n\t\t\t  ],\n\t\t\t  \"status\": \"running\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &SubmoduleCommit{\n\t\tID:             \"6104942438c14ec7bd21c6cd5bd995272b3faff6\",\n\t\tShortID:        \"6104942438c\",\n\t\tTitle:          \"Update my submodule\",\n\t\tAuthorName:     \"popdabubbles\",\n\t\tAuthorEmail:    \"noty@gmail.com\",\n\t\tCommitterName:  \"Will\",\n\t\tCommitterEmail: \"noty@gmail.com\",\n\t\tMessage:        \"Update my submodule\",\n\t\tParentIDs:      []string{\"ae1d9fb46aa2b07ee9836d49862ec4e2c46fbbba\"},\n\t\tStatus:         Ptr(Running),\n\t}\n\n\tsc, resp, err := client.RepositorySubmodules.UpdateSubmodule(13083, \"app%2Fproject\", nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, sc)\n}\n"
        },
        {
          "name": "request_options.go",
          "type": "blob",
          "size": 2.861328125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"context\"\n\t\"net/url\"\n\n\tretryablehttp \"github.com/hashicorp/go-retryablehttp\"\n)\n\n// RequestOptionFunc can be passed to all API requests to customize the API request.\ntype RequestOptionFunc func(*retryablehttp.Request) error\n\n// WithContext runs the request with the provided context\nfunc WithContext(ctx context.Context) RequestOptionFunc {\n\treturn func(req *retryablehttp.Request) error {\n\t\t*req = *req.WithContext(ctx)\n\t\treturn nil\n\t}\n}\n\n// WithHeader takes a header name and value and appends it to the request headers.\nfunc WithHeader(name, value string) RequestOptionFunc {\n\treturn func(req *retryablehttp.Request) error {\n\t\treq.Header.Set(name, value)\n\t\treturn nil\n\t}\n}\n\n// WithHeaders takes a map of header name/value pairs and appends them to the\n// request headers.\nfunc WithHeaders(headers map[string]string) RequestOptionFunc {\n\treturn func(req *retryablehttp.Request) error {\n\t\tfor k, v := range headers {\n\t\t\treq.Header.Set(k, v)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WithKeysetPaginationParameters takes a \"next\" link from the Link header of a\n// response to a keyset-based paginated request and modifies the values of each\n// query parameter in the request with its corresponding response parameter.\nfunc WithKeysetPaginationParameters(nextLink string) RequestOptionFunc {\n\treturn func(req *retryablehttp.Request) error {\n\t\tnextUrl, err := url.Parse(nextLink)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tq := req.URL.Query()\n\t\tfor k, values := range nextUrl.Query() {\n\t\t\tq.Del(k)\n\t\t\tfor _, v := range values {\n\t\t\t\tq.Add(k, v)\n\t\t\t}\n\t\t}\n\t\treq.URL.RawQuery = q.Encode()\n\t\treturn nil\n\t}\n}\n\n// WithSudo takes either a username or user ID and sets the SUDO request header.\nfunc WithSudo(uid interface{}) RequestOptionFunc {\n\treturn func(req *retryablehttp.Request) error {\n\t\tuser, err := parseID(uid)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treq.Header.Set(\"SUDO\", user)\n\t\treturn nil\n\t}\n}\n\n// WithToken takes a token which is then used when making this one request.\nfunc WithToken(authType AuthType, token string) RequestOptionFunc {\n\treturn func(req *retryablehttp.Request) error {\n\t\tswitch authType {\n\t\tcase JobToken:\n\t\t\treq.Header.Set(\"JOB-TOKEN\", token)\n\t\tcase OAuthToken:\n\t\t\treq.Header.Set(\"Authorization\", \"Bearer \"+token)\n\t\tcase PrivateToken:\n\t\t\treq.Header.Set(\"PRIVATE-TOKEN\", token)\n\t\t}\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "request_options_test.go",
          "type": "blob",
          "size": 5.9228515625,
          "content": "// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-retryablehttp\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestWithHeader(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/without-header\", func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Empty(t, r.Header.Get(\"X-CUSTOM-HEADER\"))\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, `{\"X-CUSTOM-HEADER\": %s`, r.Header.Get(\"X-CUSTOM-HEADER\"))\n\t})\n\tmux.HandleFunc(\"/api/v4/with-header\", func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"randomtokenstring\", r.Header.Get(\"X-CUSTOM-HEADER\"))\n\t\tw.WriteHeader(http.StatusOK)\n\t\tfmt.Fprintf(w, `{\"X-CUSTOM-HEADER\": %s`, r.Header.Get(\"X-CUSTOM-HEADER\"))\n\t})\n\n\t// ensure that X-CUSTOM-HEADER hasn't been set at all\n\treq, err := client.NewRequest(http.MethodGet, \"/without-header\", nil, nil)\n\tassert.NoError(t, err)\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\t// ensure that X-CUSTOM-HEADER is set for only one request\n\treq, err = client.NewRequest(\n\t\thttp.MethodGet,\n\t\t\"/with-header\",\n\t\tnil,\n\t\t[]RequestOptionFunc{WithHeader(\"X-CUSTOM-HEADER\", \"randomtokenstring\")},\n\t)\n\tassert.NoError(t, err)\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\treq, err = client.NewRequest(http.MethodGet, \"/without-header\", nil, nil)\n\tassert.NoError(t, err)\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\t// ensure that X-CUSTOM-HEADER is set for all client requests\n\taddr := client.BaseURL().String()\n\tclient, err = NewClient(\"\",\n\t\t// same base options as setup\n\t\tWithBaseURL(addr),\n\t\t// Disable backoff to speed up tests that expect errors.\n\t\tWithCustomBackoff(func(_, _ time.Duration, _ int, _ *http.Response) time.Duration {\n\t\t\treturn 0\n\t\t}),\n\t\t// add client headers\n\t\tWithRequestOptions(WithHeader(\"X-CUSTOM-HEADER\", \"randomtokenstring\")))\n\tassert.NoError(t, err)\n\tassert.NotNil(t, client)\n\n\treq, err = client.NewRequest(http.MethodGet, \"/with-header\", nil, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"randomtokenstring\", req.Header.Get(\"X-CUSTOM-HEADER\"))\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\treq, err = client.NewRequest(http.MethodGet, \"/with-header\", nil, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"randomtokenstring\", req.Header.Get(\"X-CUSTOM-HEADER\"))\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestWithHeaders(t *testing.T) {\n\tmux, client := setup(t)\n\tmux.HandleFunc(\"/api/v4/without-headers\", func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Empty(t, r.Header.Get(\"X-CUSTOM-HEADER-1\"))\n\t\tassert.Empty(t, r.Header.Get(\"X-CUSTOM-HEADER-2\"))\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\tmux.HandleFunc(\"/api/v4/with-headers\", func(w http.ResponseWriter, r *http.Request) {\n\t\tassert.Equal(t, \"randomtokenstring\", r.Header.Get(\"X-CUSTOM-HEADER-1\"))\n\t\tassert.Equal(t, \"randomtokenstring2\", r.Header.Get(\"X-CUSTOM-HEADER-2\"))\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\theaders := map[string]string{\n\t\t\"X-CUSTOM-HEADER-1\": \"randomtokenstring\",\n\t\t\"X-CUSTOM-HEADER-2\": \"randomtokenstring2\",\n\t}\n\n\t// ensure that X-CUSTOM-HEADER hasn't been set at all\n\treq, err := client.NewRequest(http.MethodGet, \"/without-headers\", nil, nil)\n\tassert.NoError(t, err)\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\t// ensure that X-CUSTOM-HEADER is set for only one request\n\treq, err = client.NewRequest(\n\t\thttp.MethodGet,\n\t\t\"/with-headers\",\n\t\tnil,\n\t\t[]RequestOptionFunc{WithHeaders(headers)},\n\t)\n\tassert.NoError(t, err)\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\treq, err = client.NewRequest(http.MethodGet, \"/without-headers\", nil, nil)\n\tassert.NoError(t, err)\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\t// ensure that X-CUSTOM-HEADER is set for all client requests\n\taddr := client.BaseURL().String()\n\tclient, err = NewClient(\"\",\n\t\t// same base options as setup\n\t\tWithBaseURL(addr),\n\t\t// Disable backoff to speed up tests that expect errors.\n\t\tWithCustomBackoff(func(_, _ time.Duration, _ int, _ *http.Response) time.Duration {\n\t\t\treturn 0\n\t\t}),\n\t\t// add client headers\n\t\tWithRequestOptions(WithHeaders(headers)),\n\t)\n\tassert.NoError(t, err)\n\tassert.NotNil(t, client)\n\n\treq, err = client.NewRequest(http.MethodGet, \"/with-headers\", nil, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"randomtokenstring\", req.Header.Get(\"X-CUSTOM-HEADER-1\"))\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n\n\treq, err = client.NewRequest(http.MethodGet, \"/with-headers\", nil, nil)\n\tassert.NoError(t, err)\n\tassert.Equal(t, \"randomtokenstring\", req.Header.Get(\"X-CUSTOM-HEADER-1\"))\n\n\t_, err = client.Do(req, nil)\n\tassert.NoError(t, err)\n}\n\nfunc TestWithKeysetPaginationParameters(t *testing.T) {\n\treq, err := retryablehttp.NewRequest(\"GET\", \"https://gitlab.example.com/api/v4/groups?pagination=keyset&per_page=50&order_by=name&sort=asc\", nil)\n\tassert.NoError(t, err)\n\n\tlinkNext := \"https://gitlab.example.com/api/v4/groups?pagination=keyset&per_page=50&order_by=name&sort=asc&cursor=eyJuYW1lIjoiRmxpZ2h0anMiLCJpZCI6IjI2IiwiX2tkIjoibiJ9\"\n\n\terr = WithKeysetPaginationParameters(linkNext)(req)\n\tassert.NoError(t, err)\n\n\tvalues := req.URL.Query()\n\t// Ensure all original parameters remain\n\tassert.Equal(t, \"keyset\", values.Get(\"pagination\"))\n\tassert.Equal(t, \"50\", values.Get(\"per_page\"))\n\tassert.Equal(t, \"name\", values.Get(\"order_by\"))\n\tassert.Equal(t, \"asc\", values.Get(\"sort\"))\n\n\t// Ensure cursor gets properly pulled from \"next link\" header\n\tassert.Equal(t, \"eyJuYW1lIjoiRmxpZ2h0anMiLCJpZCI6IjI2IiwiX2tkIjoibiJ9\", values.Get(\"cursor\"))\n}\n"
        },
        {
          "name": "resource_group.go",
          "type": "blob",
          "size": 4.853515625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ResourceGroupService handles communication with the resource\n// group related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html\ntype ResourceGroupService struct {\n\tclient *Client\n}\n\n// ResourceGrouop represents a GitLab Project Resource Group.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html\ntype ResourceGroup struct {\n\tID          int        `json:\"id\"`\n\tKey         string     `json:\"key\"`\n\tProcessMode string     `json:\"process_mode\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n}\n\n// Gets a string representation of a ResourceGroup\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html\nfunc (rg ResourceGroup) String() string {\n\treturn Stringify(rg)\n}\n\n// GetAllResourceGroupsForAProject allows you to get all resource\n// groups associated with a given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html#get-all-resource-groups-for-a-project\nfunc (s *ResourceGroupService) GetAllResourceGroupsForAProject(pid interface{}, options ...RequestOptionFunc) ([]*ResourceGroup, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/resource_groups\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rgs []*ResourceGroup\n\tresp, err := s.client.Do(req, &rgs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rgs, resp, nil\n}\n\n// GetASpecificResourceGroup allows you to get a specific\n// resource group for a given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html#get-a-specific-resource-group\nfunc (s *ResourceGroupService) GetASpecificResourceGroup(pid interface{}, key string, options ...RequestOptionFunc) (*ResourceGroup, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/resource_groups/%s\", PathEscape(project), key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trg := new(ResourceGroup)\n\tresp, err := s.client.Do(req, rg)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rg, resp, nil\n}\n\n// ListUpcomingJobsForASpecificResourceGroup allows you to get all\n// upcoming jobs for a specific resource group for a given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html#list-upcoming-jobs-for-a-specific-resource-group\nfunc (s *ResourceGroupService) ListUpcomingJobsForASpecificResourceGroup(pid interface{}, key string, options ...RequestOptionFunc) ([]*Job, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/resource_groups/%s/upcoming_jobs\", PathEscape(project), key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar js []*Job\n\tresp, err := s.client.Do(req, &js)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn js, resp, nil\n}\n\n// EditAnExistingResourceGroupOptions represents the available\n// EditAnExistingResourceGroup options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html#edit-an-existing-resource-group\ntype EditAnExistingResourceGroupOptions struct {\n\tProcessMode *ResourceGroupProcessMode `url:\"process_mode,omitempty\" json:\"process_mode,omitempty\"`\n}\n\n// EditAnExistingResourceGroup allows you to edit a specific\n// resource group for a given project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_groups.html#edit-an-existing-resource-group\nfunc (s *ResourceGroupService) EditAnExistingResourceGroup(pid interface{}, key string, opts *EditAnExistingResourceGroupOptions, options ...RequestOptionFunc) (*ResourceGroup, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/resource_groups/%s\", PathEscape(project), key)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trg := new(ResourceGroup)\n\tresp, err := s.client.Do(req, rg)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rg, resp, nil\n}\n"
        },
        {
          "name": "resource_group_test.go",
          "type": "blob",
          "size": 5.509765625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResourceGroups_GetAllResourceGroupsForAProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/resource_groups\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t\t{\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"key\": \"production\",\n\t\t\t\t\"process_mode\": \"unordered\",\n\t\t\t\t\"created_at\": \"2021-09-01T08:04:59.650Z\",\n\t\t\t\t\"updated_at\": \"2021-09-01T08:04:59.650Z\"\n\t\t\t  }\n\t\t]`)\n\t})\n\n\tdate, _ := time.Parse(timeLayout, \"2021-09-01T08:04:59.650Z\")\n\n\twant := []*ResourceGroup{{\n\t\tID:          3,\n\t\tKey:         \"production\",\n\t\tProcessMode: \"unordered\",\n\t\tCreatedAt:   &date,\n\t\tUpdatedAt:   &date,\n\t}}\n\n\trgs, resp, err := client.ResourceGroup.GetAllResourceGroupsForAProject(1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.ElementsMatch(t, want, rgs)\n\n\trgs, resp, err = client.ResourceGroup.GetAllResourceGroupsForAProject(1.01)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, rgs)\n\n\trgs, resp, err = client.ResourceGroup.GetAllResourceGroupsForAProject(1, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, rgs)\n\n\trgs, resp, err = client.ResourceGroup.GetAllResourceGroupsForAProject(2)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n\trequire.Nil(t, rgs)\n}\n\nfunc TestResourceGroups_GetASpecificResourceGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/resource_groups/production\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"key\": \"production\",\n\t\t\t\t\"process_mode\": \"unordered\",\n\t\t\t\t\"created_at\": \"2021-09-01T08:04:59.650Z\",\n\t\t\t\t\"updated_at\": \"2021-09-01T08:04:59.650Z\"\n\t\t\t  }\n\t\t`)\n\t})\n\n\tdate, _ := time.Parse(timeLayout, \"2021-09-01T08:04:59.650Z\")\n\n\twant := &ResourceGroup{\n\t\tID:          3,\n\t\tKey:         \"production\",\n\t\tProcessMode: \"unordered\",\n\t\tCreatedAt:   &date,\n\t\tUpdatedAt:   &date,\n\t}\n\n\trg, resp, err := client.ResourceGroup.GetASpecificResourceGroup(1, \"production\")\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, rg)\n\n\trg, resp, err = client.ResourceGroup.GetASpecificResourceGroup(1.01, \"production\")\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, rg)\n\n\trg, resp, err = client.ResourceGroup.GetASpecificResourceGroup(1, \"production\", errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, rg)\n\n\trg, resp, err = client.ResourceGroup.GetASpecificResourceGroup(2, \"production\")\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n\trequire.Nil(t, rg)\n}\n\nfunc TestResourceGroups_ListUpcomingJobsForASpecificResourceGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/resource_groups/production/upcoming_jobs\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t\t{\n\t\t\t\t\"id\": 6\n\t\t\t}\n\t\t]`)\n\t})\n\n\twant := []*Job{{\n\t\tID: 6,\n\t}}\n\n\tjobs, resp, err := client.ResourceGroup.ListUpcomingJobsForASpecificResourceGroup(1, \"production\")\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.ElementsMatch(t, want, jobs)\n\n\tjobs, resp, err = client.ResourceGroup.ListUpcomingJobsForASpecificResourceGroup(1.01, \"production\")\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, jobs)\n\n\tjobs, resp, err = client.ResourceGroup.ListUpcomingJobsForASpecificResourceGroup(1, \"production\", errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, jobs)\n\n\tjobs, resp, err = client.ResourceGroup.ListUpcomingJobsForASpecificResourceGroup(2, \"production\")\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n\trequire.Nil(t, jobs)\n}\n\nfunc TestResourceGroup_EditAnExistingResourceGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/resource_groups/production\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t\t\"id\": 3,\n\t\t\t\t\"key\": \"production\",\n\t\t\t\t\"process_mode\": \"unordered\",\n\t\t\t\t\"created_at\": \"2021-09-01T08:04:59.650Z\",\n\t\t\t\t\"updated_at\": \"2021-09-01T08:04:59.650Z\"\n\t\t\t}\n\t\t`)\n\t})\n\n\tdate, _ := time.Parse(timeLayout, \"2021-09-01T08:04:59.650Z\")\n\n\twant := &ResourceGroup{\n\t\tID:          3,\n\t\tKey:         \"production\",\n\t\tProcessMode: \"unordered\",\n\t\tCreatedAt:   &date,\n\t\tUpdatedAt:   &date,\n\t}\n\n\topts := &EditAnExistingResourceGroupOptions{ProcessMode: Ptr(OldestFirst)}\n\n\trg, resp, err := client.ResourceGroup.EditAnExistingResourceGroup(1, \"production\", opts)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, rg)\n\n\trg, resp, err = client.ResourceGroup.EditAnExistingResourceGroup(1.01, \"production\", opts)\n\trequire.EqualError(t, err, \"invalid ID type 1.01, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, rg)\n\n\trg, resp, err = client.ResourceGroup.EditAnExistingResourceGroup(1, \"production\", opts, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, rg)\n\n\trg, resp, err = client.ResourceGroup.EditAnExistingResourceGroup(2, \"production\", opts)\n\trequire.Error(t, err)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n\trequire.Nil(t, rg)\n}\n"
        },
        {
          "name": "resource_iteration_events.go",
          "type": "blob",
          "size": 3.8603515625,
          "content": "//\n// Copyright 2023, Hakki Ceylan, Yavuz Turk\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ResourceIterationEventsService handles communication with the event related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_iteration_events.html\ntype ResourceIterationEventsService struct {\n\tclient *Client\n}\n\n// IterationEvent represents a resource iteration event.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_iteration_events.html\ntype IterationEvent struct {\n\tID           int        `json:\"id\"`\n\tUser         *BasicUser `json:\"user\"`\n\tCreatedAt    *time.Time `json:\"created_at\"`\n\tResourceType string     `json:\"resource_type\"`\n\tResourceID   int        `json:\"resource_id\"`\n\tIteration    *Iteration `json:\"iteration\"`\n\tAction       string     `json:\"action\"`\n}\n\n// Iteration represents a project issue iteration.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_iteration_events.html\ntype Iteration struct {\n\tID          int        `json:\"id\"`\n\tIID         int        `json:\"iid\"`\n\tSequence    int        `json:\"sequence\"`\n\tGroupID     int        `json:\"group_id\"`\n\tTitle       string     `json:\"title\"`\n\tDescription string     `json:\"description\"`\n\tState       int        `json:\"state\"`\n\tCreatedAt   *time.Time `json:\"created_at\"`\n\tUpdatedAt   *time.Time `json:\"updated_at\"`\n\tDueDate     *ISOTime   `json:\"due_date\"`\n\tStartDate   *ISOTime   `json:\"start_date\"`\n\tWebURL      string     `json:\"web_url\"`\n}\n\n// ListIterationEventsOptions represents the options for all resource state\n// events list methods.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_iteration_events.html#list-project-issue-iteration-events\ntype ListIterationEventsOptions struct {\n\tListOptions\n}\n\n// ListIssueIterationEvents retrieves resource iteration events for the\n// specified project and issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_iteration_events.html#list-project-issue-iteration-events\nfunc (s *ResourceIterationEventsService) ListIssueIterationEvents(pid interface{}, issue int, opt *ListIterationEventsOptions, options ...RequestOptionFunc) ([]*IterationEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_iteration_events\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ies []*IterationEvent\n\tresp, err := s.client.Do(req, &ies)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ies, resp, nil\n}\n\n// GetIssueIterationEvent gets a single issue iteration event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_iteration_events.html#get-single-issue-iteration-event\nfunc (s *ResourceIterationEventsService) GetIssueIterationEvent(pid interface{}, issue int, event int, options ...RequestOptionFunc) (*IterationEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_iteration_events/%d\", PathEscape(project), issue, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tie := new(IterationEvent)\n\tresp, err := s.client.Do(req, ie)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ie, resp, nil\n}\n"
        },
        {
          "name": "resource_iteration_events_test.go",
          "type": "blob",
          "size": 5.884765625,
          "content": "// Copyright 2023, Hakki Ceylan, Yavuz Turk\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//\thttp://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestListIssueIterationEventsService_ListIssueIterationEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_iteration_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t    \"id\": 142,\n\t\t\t    \"user\": {\n\t\t\t        \"id\": 1,\n\t\t\t        \"username\": \"root\",\n\t\t\t        \"name\": \"Administrator\",\n\t\t\t        \"state\": \"active\",\n\t\t\t        \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t        \"web_url\": \"https://gitlab.example.com/root\"\n\t\t\t    },\n\t\t\t    \"created_at\": \"2023-09-22T06:51:04.801Z\",\n\t\t\t    \"resource_type\": \"Issue\",\n\t\t\t    \"resource_id\": 11,\n\t\t\t    \"iteration\": {\n\t\t\t        \"id\": 133,\n\t\t\t        \"iid\": 1,\n\t\t\t        \"sequence\": 1,\n\t\t\t        \"group_id\": 153,\n\t\t\t        \"title\": \"Iteration 1\",\n\t\t\t        \"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n\t\t\t        \"state\": 1,\n\t\t\t        \"created_at\": \"2023-07-15T00:05:06.509Z\",\n\t\t\t        \"updated_at\": \"2023-09-24T00:05:10.476Z\",\n\t\t\t        \"start_date\": \"2023-09-17\",\n\t\t\t        \"due_date\": \"2023-09-23\",\n\t\t\t        \"web_url\": \"https://gitlab.example.com/groups/project/-/iterations/1\"\n\t\t\t    },\n\t\t\t    \"action\": \"add\"\n\t\t\t}\n\t\t]`)\n\t})\n\n\topt := &ListIterationEventsOptions{ListOptions{Page: 1, PerPage: 10}}\n\n\tmes, _, err := client.ResourceIterationEvents.ListIssueIterationEvents(5, 11, opt)\n\trequire.NoError(t, err)\n\n\tstartDateISOTime, err := ParseISOTime(\"2023-09-17\")\n\trequire.NoError(t, err)\n\n\tdueDateISOTime, err := ParseISOTime(\"2023-09-23\")\n\trequire.NoError(t, err)\n\n\twant := []*IterationEvent{{\n\t\tID: 142,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   11,\n\t\tCreatedAt:    Time(time.Date(2023, time.September, 22, 0o6, 51, 0o4, 801000000, time.UTC)),\n\t\tIteration: &Iteration{\n\t\t\tID:          133,\n\t\t\tIID:         1,\n\t\t\tSequence:    1,\n\t\t\tGroupID:     153,\n\t\t\tTitle:       \"Iteration 1\",\n\t\t\tDescription: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n\t\t\tState:       1,\n\t\t\tCreatedAt:   Time(time.Date(2023, time.July, 15, 0o0, 0o5, 0o6, 509000000, time.UTC)),\n\t\t\tUpdatedAt:   Time(time.Date(2023, time.September, 24, 0o0, 0o5, 10, 476000000, time.UTC)),\n\t\t\tStartDate:   &startDateISOTime,\n\t\t\tDueDate:     &dueDateISOTime,\n\t\t\tWebURL:      \"https://gitlab.example.com/groups/project/-/iterations/1\",\n\t\t},\n\t\tAction: \"add\",\n\t}}\n\trequire.Equal(t, want, mes)\n}\n\nfunc TestListIssueIterationEventsService_GetIssueIterationEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_iteration_events/143\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t    \"id\": 143,\n\t\t\t    \"user\": {\n\t\t\t        \"id\": 1,\n\t\t\t        \"username\": \"root\",\n\t\t\t        \"name\": \"Administrator\",\n\t\t\t        \"state\": \"active\",\n\t\t\t        \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t        \"web_url\": \"https://gitlab.example.com/root\"\n\t\t\t    },\n\t\t\t    \"created_at\": \"2023-09-22T06:51:04.801Z\",\n\t\t\t    \"resource_type\": \"Issue\",\n\t\t\t    \"resource_id\": 11,\n\t\t\t    \"iteration\": {\n\t\t\t        \"id\": 133,\n\t\t\t        \"iid\": 1,\n\t\t\t        \"sequence\": 1,\n\t\t\t        \"group_id\": 153,\n\t\t\t        \"title\": \"Iteration 1\",\n\t\t\t        \"description\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n\t\t\t        \"state\": 1,\n\t\t\t        \"created_at\": \"2023-07-15T00:05:06.509Z\",\n\t\t\t        \"updated_at\": \"2023-09-24T00:05:10.476Z\",\n\t\t\t        \"start_date\": \"2023-09-17\",\n\t\t\t        \"due_date\": \"2023-09-23\",\n\t\t\t        \"web_url\": \"https://gitlab.example.com/groups/project/-/iterations/2\"\n\t\t\t    },\n\t\t\t    \"action\": \"add\"\n\t\t\t}`,\n\t\t)\n\t})\n\n\tme, _, err := client.ResourceIterationEvents.GetIssueIterationEvent(5, 11, 143)\n\trequire.NoError(t, err)\n\n\tstartDateISOTime, err := ParseISOTime(\"2023-09-17\")\n\trequire.NoError(t, err)\n\n\tdueDateISOTime, err := ParseISOTime(\"2023-09-23\")\n\trequire.NoError(t, err)\n\n\twant := &IterationEvent{\n\t\tID: 143,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"https://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   11,\n\t\tCreatedAt:    Time(time.Date(2023, time.September, 22, 0o6, 51, 0o4, 801000000, time.UTC)),\n\t\tIteration: &Iteration{\n\t\t\tID:          133,\n\t\t\tIID:         1,\n\t\t\tSequence:    1,\n\t\t\tGroupID:     153,\n\t\t\tTitle:       \"Iteration 1\",\n\t\t\tDescription: \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",\n\t\t\tState:       1,\n\t\t\tCreatedAt:   Time(time.Date(2023, time.July, 15, 0o0, 0o5, 0o6, 509000000, time.UTC)),\n\t\t\tUpdatedAt:   Time(time.Date(2023, time.September, 24, 0o0, 0o5, 10, 476000000, time.UTC)),\n\t\t\tStartDate:   &startDateISOTime,\n\t\t\tDueDate:     &dueDateISOTime,\n\t\t\tWebURL:      \"https://gitlab.example.com/groups/project/-/iterations/2\",\n\t\t},\n\t\tAction: \"add\",\n\t}\n\trequire.Equal(t, want, me)\n}\n"
        },
        {
          "name": "resource_label_events.go",
          "type": "blob",
          "size": 6.58203125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ResourceLabelEventsService handles communication with the event related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_label_events.html\ntype ResourceLabelEventsService struct {\n\tclient *Client\n}\n\n// LabelEvent represents a resource label event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#get-single-issue-label-event\ntype LabelEvent struct {\n\tID           int        `json:\"id\"`\n\tAction       string     `json:\"action\"`\n\tCreatedAt    *time.Time `json:\"created_at\"`\n\tResourceType string     `json:\"resource_type\"`\n\tResourceID   int        `json:\"resource_id\"`\n\tUser         struct {\n\t\tID        int    `json:\"id\"`\n\t\tName      string `json:\"name\"`\n\t\tUsername  string `json:\"username\"`\n\t\tState     string `json:\"state\"`\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t\tWebURL    string `json:\"web_url\"`\n\t} `json:\"user\"`\n\tLabel struct {\n\t\tID          int    `json:\"id\"`\n\t\tName        string `json:\"name\"`\n\t\tColor       string `json:\"color\"`\n\t\tTextColor   string `json:\"text_color\"`\n\t\tDescription string `json:\"description\"`\n\t} `json:\"label\"`\n}\n\n// ListLabelEventsOptions represents the options for all resource label events\n// list methods.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#list-project-issue-label-events\ntype ListLabelEventsOptions struct {\n\tListOptions\n}\n\n// ListIssueLabelEvents retrieves resource label events for the\n// specified project and issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#list-project-issue-label-events\nfunc (s *ResourceLabelEventsService) ListIssueLabelEvents(pid interface{}, issue int, opt *ListLabelEventsOptions, options ...RequestOptionFunc) ([]*LabelEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_label_events\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ls []*LabelEvent\n\tresp, err := s.client.Do(req, &ls)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ls, resp, nil\n}\n\n// GetIssueLabelEvent gets a single issue-label-event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#get-single-issue-label-event\nfunc (s *ResourceLabelEventsService) GetIssueLabelEvent(pid interface{}, issue int, event int, options ...RequestOptionFunc) (*LabelEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_label_events/%d\", PathEscape(project), issue, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(LabelEvent)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// ListGroupEpicLabelEvents retrieves resource label events for the specified\n// group and epic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#list-group-epic-label-events\nfunc (s *ResourceLabelEventsService) ListGroupEpicLabelEvents(gid interface{}, epic int, opt *ListLabelEventsOptions, options ...RequestOptionFunc) ([]*LabelEvent, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/resource_label_events\", PathEscape(group), epic)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ls []*LabelEvent\n\tresp, err := s.client.Do(req, &ls)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ls, resp, nil\n}\n\n// GetGroupEpicLabelEvent gets a single group epic label event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#get-single-epic-label-event\nfunc (s *ResourceLabelEventsService) GetGroupEpicLabelEvent(gid interface{}, epic int, event int, options ...RequestOptionFunc) (*LabelEvent, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/epics/%d/resource_label_events/%d\", PathEscape(group), epic, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(LabelEvent)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// ListMergeRequestsLabelEvents retrieves resource label events for the specified\n// project and merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#list-project-merge-request-label-events\nfunc (s *ResourceLabelEventsService) ListMergeRequestsLabelEvents(pid interface{}, request int, opt *ListLabelEventsOptions, options ...RequestOptionFunc) ([]*LabelEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/resource_label_events\", PathEscape(project), request)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ls []*LabelEvent\n\tresp, err := s.client.Do(req, &ls)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ls, resp, nil\n}\n\n// GetMergeRequestLabelEvent gets a single merge request label event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_label_events.html#get-single-merge-request-label-event\nfunc (s *ResourceLabelEventsService) GetMergeRequestLabelEvent(pid interface{}, request int, event int, options ...RequestOptionFunc) (*LabelEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/resource_label_events/%d\", PathEscape(project), request, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(LabelEvent)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n"
        },
        {
          "name": "resource_label_events_test.go",
          "type": "blob",
          "size": 14.4990234375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResourceLabelEventsService_ListIssueLabelEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_label_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 142,\n\t\t\t\t\"user\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"resource_type\": \"Issue\",\n\t\t\t\t\"resource_id\": 253,\n\t\t\t\t\"label\": {\n\t\t\t\t  \"id\": 73,\n\t\t\t\t  \"name\": \"a1\",\n\t\t\t\t  \"color\": \"#34495E\",\n\t\t\t\t  \"description\": \"\"\n\t\t\t\t},\n\t\t\t\t\"action\": \"add\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*LabelEvent{{\n\t\tID:           142,\n\t\tAction:       \"add\",\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   253,\n\t\tUser: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tLabel: struct {\n\t\t\tID          int    `json:\"id\"`\n\t\t\tName        string `json:\"name\"`\n\t\t\tColor       string `json:\"color\"`\n\t\t\tTextColor   string `json:\"text_color\"`\n\t\t\tDescription string `json:\"description\"`\n\t\t}{\n\t\t\tID:          73,\n\t\t\tName:        \"a1\",\n\t\t\tColor:       \"#34495E\",\n\t\t\tTextColor:   \"\",\n\t\t\tDescription: \"\",\n\t\t},\n\t}}\n\n\tles, resp, err := client.ResourceLabelEvents.ListIssueLabelEvents(5, 11, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListIssueLabelEvents(1.5, 11, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListIssueLabelEvents(5, 11, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListIssueLabelEvents(6, 11, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, les)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestResourceLabelEventsService_GetIssueLabelEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_label_events/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t  {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"user\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"resource_type\": \"Issue\",\n\t\t\t\t\"resource_id\": 253,\n\t\t\t\t\"label\": {\n\t\t\t\t  \"id\": 73,\n\t\t\t\t  \"name\": \"a1\",\n\t\t\t\t  \"color\": \"#34495E\",\n\t\t\t\t  \"description\": \"\"\n\t\t\t\t},\n\t\t\t\t\"action\": \"add\"\n\t\t\t  }`,\n\t\t)\n\t})\n\n\twant := &LabelEvent{\n\t\tID:           1,\n\t\tAction:       \"add\",\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   253,\n\t\tUser: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tLabel: struct {\n\t\t\tID          int    `json:\"id\"`\n\t\t\tName        string `json:\"name\"`\n\t\t\tColor       string `json:\"color\"`\n\t\t\tTextColor   string `json:\"text_color\"`\n\t\t\tDescription string `json:\"description\"`\n\t\t}{\n\t\t\tID:          73,\n\t\t\tName:        \"a1\",\n\t\t\tColor:       \"#34495E\",\n\t\t\tTextColor:   \"\",\n\t\t\tDescription: \"\",\n\t\t},\n\t}\n\n\tle, resp, err := client.ResourceLabelEvents.GetIssueLabelEvent(5, 11, 1)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetIssueLabelEvent(1.5, 11, 1)\n\trequire.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetIssueLabelEvent(5, 11, 1, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetIssueLabelEvent(6, 11, 1)\n\trequire.Error(t, err)\n\trequire.Nil(t, le)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestResourceLabelEventsService_ListGroupEpicLabelEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/11/resource_label_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 106,\n\t\t\t\t\"user\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"resource_type\": \"Epic\",\n\t\t\t\t\"resource_id\": 33,\n\t\t\t\t\"label\": {\n\t\t\t\t  \"id\": 73,\n\t\t\t\t  \"name\": \"a1\",\n\t\t\t\t  \"color\": \"#34495E\",\n\t\t\t\t  \"description\": \"\"\n\t\t\t\t},\n\t\t\t\t\"action\": \"add\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*LabelEvent{{\n\t\tID:           106,\n\t\tAction:       \"add\",\n\t\tResourceType: \"Epic\",\n\t\tResourceID:   33,\n\t\tUser: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tLabel: struct {\n\t\t\tID          int    `json:\"id\"`\n\t\t\tName        string `json:\"name\"`\n\t\t\tColor       string `json:\"color\"`\n\t\t\tTextColor   string `json:\"text_color\"`\n\t\t\tDescription string `json:\"description\"`\n\t\t}{\n\t\t\tID:          73,\n\t\t\tName:        \"a1\",\n\t\t\tColor:       \"#34495E\",\n\t\t\tTextColor:   \"\",\n\t\t\tDescription: \"\",\n\t\t},\n\t}}\n\n\tles, resp, err := client.ResourceLabelEvents.ListGroupEpicLabelEvents(1, 11, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListGroupEpicLabelEvents(1.5, 11, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListGroupEpicLabelEvents(1, 11, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListGroupEpicLabelEvents(6, 11, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, les)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestResourceLabelEventsService_GetGroupEpicLabelEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/1/epics/11/resource_label_events/107\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t{\n\t\t\t\"id\": 107,\n\t\t\t\"user\": {\n\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/root\"\n\t\t},\n\t\t\t\"resource_type\": \"Epic\",\n\t\t\t\"resource_id\": 33,\n\t\t\t\"label\": {\n\t\t\t\"id\": 73,\n\t\t\t\t\"name\": \"a1\",\n\t\t\t\t\"color\": \"#34495E\",\n\t\t\t\t\"description\": \"\"\n\t\t},\n\t\t\t\"action\": \"add\"\n\t\t}\n\t\t`)\n\t})\n\n\twant := &LabelEvent{\n\t\tID:           107,\n\t\tAction:       \"add\",\n\t\tResourceType: \"Epic\",\n\t\tResourceID:   33,\n\t\tUser: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tLabel: struct {\n\t\t\tID          int    `json:\"id\"`\n\t\t\tName        string `json:\"name\"`\n\t\t\tColor       string `json:\"color\"`\n\t\t\tTextColor   string `json:\"text_color\"`\n\t\t\tDescription string `json:\"description\"`\n\t\t}{\n\t\t\tID:          73,\n\t\t\tName:        \"a1\",\n\t\t\tColor:       \"#34495E\",\n\t\t\tTextColor:   \"\",\n\t\t\tDescription: \"\",\n\t\t},\n\t}\n\n\tle, resp, err := client.ResourceLabelEvents.GetGroupEpicLabelEvent(1, 11, 107)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetGroupEpicLabelEvent(1.5, 11, 107)\n\trequire.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetGroupEpicLabelEvent(1, 11, 107, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetGroupEpicLabelEvent(6, 11, 107)\n\trequire.Error(t, err)\n\trequire.Nil(t, le)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestResourceLabelEventsService_ListMergeRequestsLabelEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/resource_label_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t[\n\t\t\t  {\n\t\t\t\t\"id\": 119,\n\t\t\t\t\"user\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"resource_type\": \"MergeRequest\",\n\t\t\t\t\"resource_id\": 28,\n\t\t\t\t\"label\": {\n\t\t\t\t  \"id\": 74,\n\t\t\t\t  \"name\": \"p1\",\n\t\t\t\t  \"color\": \"#0033CC\",\n\t\t\t\t  \"description\": \"\"\n\t\t\t\t},\n\t\t\t\t\"action\": \"add\"\n\t\t\t  }\n\t\t\t]\n\t\t`)\n\t})\n\n\twant := []*LabelEvent{{\n\t\tID:           119,\n\t\tAction:       \"add\",\n\t\tResourceType: \"MergeRequest\",\n\t\tResourceID:   28,\n\t\tUser: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tLabel: struct {\n\t\t\tID          int    `json:\"id\"`\n\t\t\tName        string `json:\"name\"`\n\t\t\tColor       string `json:\"color\"`\n\t\t\tTextColor   string `json:\"text_color\"`\n\t\t\tDescription string `json:\"description\"`\n\t\t}{\n\t\t\tID:          74,\n\t\t\tName:        \"p1\",\n\t\t\tColor:       \"#0033CC\",\n\t\t\tTextColor:   \"\",\n\t\t\tDescription: \"\",\n\t\t},\n\t}}\n\n\tles, resp, err := client.ResourceLabelEvents.ListMergeRequestsLabelEvents(5, 11, nil)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListMergeRequestsLabelEvents(1.5, 11, nil)\n\trequire.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListMergeRequestsLabelEvents(5, 11, nil, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, les)\n\n\tles, resp, err = client.ResourceLabelEvents.ListMergeRequestsLabelEvents(6, 11, nil)\n\trequire.Error(t, err)\n\trequire.Nil(t, les)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n\nfunc TestResourceLabelEventsService_GetMergeRequestLabelEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/resource_label_events/120\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t\t\"id\": 120,\n\t\t\t\t\"user\": {\n\t\t\t\t  \"id\": 1,\n\t\t\t\t  \"name\": \"Administrator\",\n\t\t\t\t  \"username\": \"root\",\n\t\t\t\t  \"state\": \"active\",\n\t\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t\t},\n\t\t\t\t\"resource_type\": \"MergeRequest\",\n\t\t\t\t\"resource_id\": 28,\n\t\t\t\t\"label\": {\n\t\t\t\t  \"id\": 74,\n\t\t\t\t  \"name\": \"p1\",\n\t\t\t\t  \"color\": \"#0033CC\",\n\t\t\t\t  \"description\": \"\"\n\t\t\t\t},\n\t\t\t\t\"action\": \"add\"\n\t\t\t}\n\t\t`)\n\t})\n\n\twant := &LabelEvent{\n\t\tID:           120,\n\t\tAction:       \"add\",\n\t\tResourceType: \"MergeRequest\",\n\t\tResourceID:   28,\n\t\tUser: struct {\n\t\t\tID        int    `json:\"id\"`\n\t\t\tName      string `json:\"name\"`\n\t\t\tUsername  string `json:\"username\"`\n\t\t\tState     string `json:\"state\"`\n\t\t\tAvatarURL string `json:\"avatar_url\"`\n\t\t\tWebURL    string `json:\"web_url\"`\n\t\t}{\n\t\t\tID:        1,\n\t\t\tName:      \"Administrator\",\n\t\t\tUsername:  \"root\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tLabel: struct {\n\t\t\tID          int    `json:\"id\"`\n\t\t\tName        string `json:\"name\"`\n\t\t\tColor       string `json:\"color\"`\n\t\t\tTextColor   string `json:\"text_color\"`\n\t\t\tDescription string `json:\"description\"`\n\t\t}{\n\t\t\tID:          74,\n\t\t\tName:        \"p1\",\n\t\t\tColor:       \"#0033CC\",\n\t\t\tTextColor:   \"\",\n\t\t\tDescription: \"\",\n\t\t},\n\t}\n\n\tle, resp, err := client.ResourceLabelEvents.GetMergeRequestLabelEvent(5, 11, 120)\n\trequire.NoError(t, err)\n\trequire.NotNil(t, resp)\n\trequire.Equal(t, want, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetMergeRequestLabelEvent(1.5, 11, 120)\n\trequire.EqualError(t, err, \"invalid ID type 1.5, the ID must be an int or a string\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetMergeRequestLabelEvent(5, 11, 120, errorOption)\n\trequire.EqualError(t, err, \"RequestOptionFunc returns an error\")\n\trequire.Nil(t, resp)\n\trequire.Nil(t, le)\n\n\tle, resp, err = client.ResourceLabelEvents.GetMergeRequestLabelEvent(6, 11, 120)\n\trequire.Error(t, err)\n\trequire.Nil(t, le)\n\trequire.Equal(t, http.StatusNotFound, resp.StatusCode)\n}\n"
        },
        {
          "name": "resource_milestone_events.go",
          "type": "blob",
          "size": 4.853515625,
          "content": "//\n// Copyright 2022, Mai Lapyst\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ResourceMilestoneEventsService handles communication with the event related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_milestone_events.html\ntype ResourceMilestoneEventsService struct {\n\tclient *Client\n}\n\n// MilestoneEvent represents a resource milestone event.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_milestone_events.html\ntype MilestoneEvent struct {\n\tID           int        `json:\"id\"`\n\tUser         *BasicUser `json:\"user\"`\n\tCreatedAt    *time.Time `json:\"created_at\"`\n\tResourceType string     `json:\"resource_type\"`\n\tResourceID   int        `json:\"resource_id\"`\n\tMilestone    *Milestone `json:\"milestone\"`\n\tAction       string     `json:\"action\"`\n}\n\n// ListMilestoneEventsOptions represents the options for all resource state events\n// list methods.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_milestone_events.html#list-project-issue-milestone-events\ntype ListMilestoneEventsOptions struct {\n\tListOptions\n}\n\n// ListIssueMilestoneEvents retrieves resource milestone events for the specified\n// project and issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_milestone_events.html#list-project-issue-milestone-events\nfunc (s *ResourceMilestoneEventsService) ListIssueMilestoneEvents(pid interface{}, issue int, opt *ListMilestoneEventsOptions, options ...RequestOptionFunc) ([]*MilestoneEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_milestone_events\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mes []*MilestoneEvent\n\tresp, err := s.client.Do(req, &mes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mes, resp, nil\n}\n\n// GetIssueMilestoneEvent gets a single issue milestone event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_milestone_events.html#get-single-issue-milestone-event\nfunc (s *ResourceMilestoneEventsService) GetIssueMilestoneEvent(pid interface{}, issue int, event int, options ...RequestOptionFunc) (*MilestoneEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_milestone_events/%d\", PathEscape(project), issue, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tme := new(MilestoneEvent)\n\tresp, err := s.client.Do(req, me)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn me, resp, nil\n}\n\n// ListMergeMilestoneEvents retrieves resource milestone events for the specified\n// project and merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_milestone_events.html#list-project-merge-request-milestone-events\nfunc (s *ResourceMilestoneEventsService) ListMergeMilestoneEvents(pid interface{}, request int, opt *ListMilestoneEventsOptions, options ...RequestOptionFunc) ([]*MilestoneEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/resource_milestone_events\", PathEscape(project), request)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar mes []*MilestoneEvent\n\tresp, err := s.client.Do(req, &mes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn mes, resp, nil\n}\n\n// GetMergeRequestMilestoneEvent gets a single merge request milestone event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_milestone_events.html#get-single-merge-request-milestone-event\nfunc (s *ResourceMilestoneEventsService) GetMergeRequestMilestoneEvent(pid interface{}, request int, event int, options ...RequestOptionFunc) (*MilestoneEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/resource_milestone_events/%d\", PathEscape(project), request, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tme := new(MilestoneEvent)\n\tresp, err := s.client.Do(req, me)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn me, resp, nil\n}\n"
        },
        {
          "name": "resource_milestone_events_test.go",
          "type": "blob",
          "size": 6.6796875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc ListIssueMilestoneEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_milestone_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t  {\n\t\t\t\"id\": 142,\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"resource_type\": \"Issue\",\n\t\t\t\"resource_id\": 11,\n\t\t\t\"milestone\": {\n\t\t\t  \"id\": 61,\n\t\t\t  \"iid\": 9,\n\t\t\t  \"project_id\": 7,\n\t\t\t  \"title\": \"v1.2\",\n\t\t\t  \"description\": \"Ipsum Lorem\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com:3000/group/project/-/milestones/9\"\n\t\t\t},\n\t\t\t\"action\": \"add\"\n\t\t  }\n\t\t]`)\n\t})\n\n\topt := &ListMilestoneEventsOptions{ListOptions{Page: 1, PerPage: 10}}\n\n\tmes, _, err := client.ResourceMilestoneEvents.ListIssueMilestoneEvents(5, 11, opt)\n\trequire.NoError(t, err)\n\n\twant := []*MilestoneEvent{{\n\t\tID: 142,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   11,\n\t\tMilestone: &Milestone{\n\t\t\tID:          61,\n\t\t\tIID:         9,\n\t\t\tProjectID:   7,\n\t\t\tTitle:       \"v1.2\",\n\t\t\tDescription: \"Ipsum Lorem\",\n\t\t\tState:       \"active\",\n\t\t\tWebURL:      \"http://gitlab.example.com:3000/group/project/-/milestones/9\",\n\t\t},\n\t\tAction: \"add\",\n\t}}\n\trequire.Equal(t, want, mes)\n}\n\nfunc GetIssueMilestoneEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_milestone_events/143\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 143,\n\t\t\t  \"user\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t  },\n\t\t\t  \"resource_type\": \"Issue\",\n\t\t\t  \"resource_id\": 11,\n\t\t\t  \"milestone\": {\n\t\t\t    \"id\": 61,\n\t\t\t    \"iid\": 9,\n\t\t\t    \"project_id\": 7,\n\t\t\t    \"title\": \"v1.2\",\n\t\t\t    \"description\": \"Ipsum Lorem\",\n\t\t\t    \"state\": \"active\",\n\t\t\t    \"web_url\": \"http://gitlab.example.com:3000/group/project/-/milestones/9\"\n\t\t\t  },\n\t\t\t  \"action\": \"remove\"\n\t\t\t}`,\n\t\t)\n\t})\n\n\tme, _, err := client.ResourceMilestoneEvents.GetIssueMilestoneEvent(5, 11, 143)\n\trequire.NoError(t, err)\n\n\twant := &MilestoneEvent{\n\t\tID: 143,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   11,\n\t\tMilestone: &Milestone{\n\t\t\tID:          61,\n\t\t\tIID:         9,\n\t\t\tProjectID:   7,\n\t\t\tTitle:       \"v1.2\",\n\t\t\tDescription: \"Ipsum Lorem\",\n\t\t\tState:       \"active\",\n\t\t\tWebURL:      \"http://gitlab.example.com:3000/group/project/-/milestones/9\",\n\t\t},\n\t\tAction: \"remove\",\n\t}\n\trequire.Equal(t, want, me)\n}\n\nfunc ListMergeMilestoneEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/resource_milestone_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t  {\n\t\t\t\"id\": 142,\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"resource_type\": \"MergeRequest\",\n\t\t\t\"resource_id\": 11,\n\t\t\t\"milestone\": {\n\t\t\t  \"id\": 61,\n\t\t\t  \"iid\": 9,\n\t\t\t  \"project_id\": 7,\n\t\t\t  \"title\": \"v1.2\",\n\t\t\t  \"description\": \"Ipsum Lorem\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com:3000/group/project/-/milestones/9\"\n\t\t\t},\n\t\t\t\"action\": \"add\"\n\t\t  }]`,\n\t\t)\n\t})\n\n\topt := &ListMilestoneEventsOptions{ListOptions{Page: 1, PerPage: 10}}\n\n\tses, _, err := client.ResourceMilestoneEvents.ListMergeMilestoneEvents(5, 11, opt)\n\trequire.NoError(t, err)\n\n\twant := []*MilestoneEvent{{\n\t\tID: 142,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"MergeRequest\",\n\t\tResourceID:   11,\n\t\tMilestone: &Milestone{\n\t\t\tID:          61,\n\t\t\tIID:         9,\n\t\t\tProjectID:   7,\n\t\t\tTitle:       \"v1.2\",\n\t\t\tDescription: \"Ipsum Lorem\",\n\t\t\tState:       \"active\",\n\t\t\tWebURL:      \"http://gitlab.example.com:3000/group/project/-/milestones/9\",\n\t\t},\n\t\tAction: \"add\",\n\t}}\n\trequire.Equal(t, want, ses)\n}\n\nfunc GetMergeRequestMilestoneEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/resource_milestone_events/120\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t  \"id\": 120,\n\t\t  \"user\": {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Administrator\",\n\t\t\t\"username\": \"root\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\"web_url\": \"http://gitlab.example.com/root\"\n\t\t  },\n\t\t  \"resource_type\": \"MergeRequest\",\n\t\t  \"resource_id\": 11,\n          \"milestone\": {\n            \"id\": 61,\n            \"iid\": 9,\n            \"project_id\": 7,\n            \"title\": \"v1.2\",\n            \"description\": \"Ipsum Lorem\",\n            \"state\": \"active\",\n            \"web_url\": \"http://gitlab.example.com:3000/group/project/-/milestones/9\"\n          },\n          \"action\": \"remove\"\n\t\t}`)\n\t})\n\n\tme, _, err := client.ResourceMilestoneEvents.GetMergeRequestMilestoneEvent(5, 11, 120)\n\trequire.NoError(t, err)\n\n\twant := &MilestoneEvent{\n\t\tID: 120,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"MergeRequest\",\n\t\tResourceID:   11,\n\t\tMilestone: &Milestone{\n\t\t\tID:          61,\n\t\t\tIID:         9,\n\t\t\tProjectID:   7,\n\t\t\tTitle:       \"v1.2\",\n\t\t\tDescription: \"Ipsum Lorem\",\n\t\t\tState:       \"active\",\n\t\t\tWebURL:      \"http://gitlab.example.com:3000/group/project/-/milestones/9\",\n\t\t},\n\t\tAction: \"remove\",\n\t}\n\trequire.Equal(t, want, me)\n}\n"
        },
        {
          "name": "resource_state_events.go",
          "type": "blob",
          "size": 4.6455078125,
          "content": "//\n// Copyright 2021, Matthias Simon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ResourceStateEventsService handles communication with the event related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_state_events.html\ntype ResourceStateEventsService struct {\n\tclient *Client\n}\n\n// StateEvent represents a resource state event.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_state_events.html\ntype StateEvent struct {\n\tID           int            `json:\"id\"`\n\tUser         *BasicUser     `json:\"user\"`\n\tCreatedAt    *time.Time     `json:\"created_at\"`\n\tResourceType string         `json:\"resource_type\"`\n\tResourceID   int            `json:\"resource_id\"`\n\tState        EventTypeValue `json:\"state\"`\n}\n\n// ListStateEventsOptions represents the options for all resource state events\n// list methods.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_state_events.html#list-project-issue-state-events\ntype ListStateEventsOptions struct {\n\tListOptions\n}\n\n// ListIssueStateEvents retrieves resource state events for the specified\n// project and issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_state_events.html#list-project-issue-state-events\nfunc (s *ResourceStateEventsService) ListIssueStateEvents(pid interface{}, issue int, opt *ListStateEventsOptions, options ...RequestOptionFunc) ([]*StateEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_state_events\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ses []*StateEvent\n\tresp, err := s.client.Do(req, &ses)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ses, resp, nil\n}\n\n// GetIssueStateEvent gets a single issue-state-event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_state_events.html#get-single-issue-state-event\nfunc (s *ResourceStateEventsService) GetIssueStateEvent(pid interface{}, issue int, event int, options ...RequestOptionFunc) (*StateEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_state_events/%d\", PathEscape(project), issue, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tse := new(StateEvent)\n\tresp, err := s.client.Do(req, se)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn se, resp, nil\n}\n\n// ListMergeStateEvents retrieves resource state events for the specified\n// project and merge request.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_state_events.html#list-project-merge-request-state-events\nfunc (s *ResourceStateEventsService) ListMergeStateEvents(pid interface{}, request int, opt *ListStateEventsOptions, options ...RequestOptionFunc) ([]*StateEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/resource_state_events\", PathEscape(project), request)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ses []*StateEvent\n\tresp, err := s.client.Do(req, &ses)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ses, resp, nil\n}\n\n// GetMergeRequestStateEvent gets a single merge request state event.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_state_events.html#get-single-merge-request-state-event\nfunc (s *ResourceStateEventsService) GetMergeRequestStateEvent(pid interface{}, request int, event int, options ...RequestOptionFunc) (*StateEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/merge_requests/%d/resource_state_events/%d\", PathEscape(project), request, event)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tse := new(StateEvent)\n\tresp, err := s.client.Do(req, se)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn se, resp, nil\n}\n"
        },
        {
          "name": "resource_state_events_test.go",
          "type": "blob",
          "size": 4.7744140625,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResourceStateEventsService_ListIssueStateEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_state_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t  {\n\t\t\t\"id\": 142,\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"resource_type\": \"Issue\",\n\t\t\t\"resource_id\": 11,\n\t\t\t\"state\": \"opened\"\n\t\t  }\n\t\t]`)\n\t})\n\n\topt := &ListStateEventsOptions{ListOptions{Page: 1, PerPage: 10}}\n\n\tses, _, err := client.ResourceStateEvents.ListIssueStateEvents(5, 11, opt)\n\trequire.NoError(t, err)\n\n\twant := []*StateEvent{{\n\t\tID: 142,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   11,\n\t\tState:        \"opened\",\n\t}}\n\trequire.Equal(t, want, ses)\n}\n\nfunc TestResourceStateEventsService_GetIssueStateEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_state_events/143\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `\n\t\t\t{\n\t\t\t  \"id\": 143,\n\t\t\t  \"user\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t  },\n\t\t\t  \"resource_type\": \"Issue\",\n\t\t\t  \"resource_id\": 11,\n\t\t\t  \"state\": \"closed\"\n\t\t\t}`,\n\t\t)\n\t})\n\n\tse, _, err := client.ResourceStateEvents.GetIssueStateEvent(5, 11, 143)\n\trequire.NoError(t, err)\n\n\twant := &StateEvent{\n\t\tID: 143,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"Issue\",\n\t\tResourceID:   11,\n\t\tState:        \"closed\",\n\t}\n\trequire.Equal(t, want, se)\n}\n\nfunc TestResourceStateEventsService_ListMergeStateEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/resource_state_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t  {\n\t\t\t\"id\": 142,\n\t\t\t\"user\": {\n\t\t\t  \"id\": 1,\n\t\t\t  \"name\": \"Administrator\",\n\t\t\t  \"username\": \"root\",\n\t\t\t  \"state\": \"active\",\n\t\t\t  \"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t  \"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t},\n\t\t\t\"resource_type\": \"MergeRequest\",\n\t\t\t\"resource_id\": 11,\n\t\t\t\"state\": \"opened\"\n\t\t  }]`,\n\t\t)\n\t})\n\n\topt := &ListStateEventsOptions{ListOptions{Page: 1, PerPage: 10}}\n\n\tses, _, err := client.ResourceStateEvents.ListMergeStateEvents(5, 11, opt)\n\trequire.NoError(t, err)\n\n\twant := []*StateEvent{{\n\t\tID: 142,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"MergeRequest\",\n\t\tResourceID:   11,\n\t\tState:        \"opened\",\n\t}}\n\trequire.Equal(t, want, ses)\n}\n\nfunc TestResourceStateEventsService_GetMergeRequestStateEvent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/merge_requests/11/resource_state_events/120\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t  \"id\": 120,\n\t\t  \"user\": {\n\t\t\t\"id\": 1,\n\t\t\t\"name\": \"Administrator\",\n\t\t\t\"username\": \"root\",\n\t\t\t\"state\": \"active\",\n\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\"web_url\": \"http://gitlab.example.com/root\"\n\t\t  },\n\t\t  \"resource_type\": \"MergeRequest\",\n\t\t  \"resource_id\": 11,\n\t\t  \"state\": \"closed\"\n\t\t}`)\n\t})\n\n\tse, _, err := client.ResourceStateEvents.GetMergeRequestStateEvent(5, 11, 120)\n\trequire.NoError(t, err)\n\n\twant := &StateEvent{\n\t\tID: 120,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tResourceType: \"MergeRequest\",\n\t\tResourceID:   11,\n\t\tState:        \"closed\",\n\t}\n\trequire.Equal(t, want, se)\n}\n"
        },
        {
          "name": "resource_weight_events.go",
          "type": "blob",
          "size": 2.45703125,
          "content": "//\n// Copyright 2021, Matthias Simon\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// ResourceWeightEventsService handles communication with the event related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_weight_events.html\ntype ResourceWeightEventsService struct {\n\tclient *Client\n}\n\n// WeightEvent represents a resource weight event.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/resource_weight_events.html\ntype WeightEvent struct {\n\tID           int            `json:\"id\"`\n\tUser         *BasicUser     `json:\"user\"`\n\tCreatedAt    *time.Time     `json:\"created_at\"`\n\tResourceType string         `json:\"resource_type\"`\n\tResourceID   int            `json:\"resource_id\"`\n\tState        EventTypeValue `json:\"state\"`\n\tIssueID      int            `json:\"issue_id\"`\n\tWeight       int            `json:\"weight\"`\n}\n\n// ListWeightEventsOptions represents the options for all resource weight events\n// list methods.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_weight_events.html#list-project-issue-weight-events\ntype ListWeightEventsOptions struct {\n\tListOptions\n}\n\n// ListIssueWeightEvents retrieves resource weight events for the specified\n// project and issue.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/resource_weight_events.html#list-project-issue-weight-events\nfunc (s *ResourceWeightEventsService) ListIssueWeightEvents(pid interface{}, issue int, opt *ListWeightEventsOptions, options ...RequestOptionFunc) ([]*WeightEvent, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/issues/%d/resource_weight_events\", PathEscape(project), issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar wes []*WeightEvent\n\tresp, err := s.client.Do(req, &wes)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn wes, resp, nil\n}\n"
        },
        {
          "name": "resource_weight_events_test.go",
          "type": "blob",
          "size": 1.361328125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestResourceWeightEventsService_ListIssueWightEvents(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/5/issues/11/resource_weight_events\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"id\": 142,\n\t\t\t  \"user\": {\n\t\t\t\t\"id\": 1,\n\t\t\t\t\"name\": \"Administrator\",\n\t\t\t\t\"username\": \"root\",\n\t\t\t\t\"state\": \"active\",\n\t\t\t\t\"avatar_url\": \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\t\t\"web_url\": \"http://gitlab.example.com/root\"\n\t\t\t  },\n\t\t\t  \"created_at\": \"2018-08-20T13:38:20.077Z\",\n\t\t\t  \"issue_id\": 253,\n\t\t\t  \"weight\": 3\n\t\t\t}\n\t\t]`)\n\t})\n\n\topt := &ListWeightEventsOptions{ListOptions{Page: 1, PerPage: 10}}\n\n\twes, _, err := client.ResourceWeightEvents.ListIssueWeightEvents(5, 11, opt)\n\trequire.NoError(t, err)\n\n\twant := []*WeightEvent{{\n\t\tID: 142,\n\t\tUser: &BasicUser{\n\t\t\tID:        1,\n\t\t\tUsername:  \"root\",\n\t\t\tName:      \"Administrator\",\n\t\t\tState:     \"active\",\n\t\t\tAvatarURL: \"https://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t\t\tWebURL:    \"http://gitlab.example.com/root\",\n\t\t},\n\t\tCreatedAt: Ptr(time.Date(2018, time.August, 20, 13, 38, 20, 77000000, time.UTC)),\n\t\tIssueID:   253,\n\t\tWeight:    3,\n\t}}\n\trequire.Equal(t, want, wes)\n}\n"
        },
        {
          "name": "runners.go",
          "type": "blob",
          "size": 19.6123046875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// RunnersService handles communication with the runner related methods of the\n// GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/runners.html\ntype RunnersService struct {\n\tclient *Client\n}\n\n// Runner represents a GitLab CI Runner.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/runners.html\ntype Runner struct {\n\tID             int        `json:\"id\"`\n\tDescription    string     `json:\"description\"`\n\tActive         bool       `json:\"active\"`\n\tPaused         bool       `json:\"paused\"`\n\tIsShared       bool       `json:\"is_shared\"`\n\tIPAddress      string     `json:\"ip_address\"`\n\tRunnerType     string     `json:\"runner_type\"`\n\tName           string     `json:\"name\"`\n\tOnline         bool       `json:\"online\"`\n\tStatus         string     `json:\"status\"`\n\tToken          string     `json:\"token\"`\n\tTokenExpiresAt *time.Time `json:\"token_expires_at\"`\n}\n\n// RunnerDetails represents the GitLab CI runner details.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/runners.html\ntype RunnerDetails struct {\n\tPaused          bool       `json:\"paused\"`\n\tArchitecture    string     `json:\"architecture\"`\n\tDescription     string     `json:\"description\"`\n\tID              int        `json:\"id\"`\n\tIPAddress       string     `json:\"ip_address\"`\n\tIsShared        bool       `json:\"is_shared\"`\n\tRunnerType      string     `json:\"runner_type\"`\n\tContactedAt     *time.Time `json:\"contacted_at\"`\n\tMaintenanceNote string     `json:\"maintenance_note\"`\n\tName            string     `json:\"name\"`\n\tOnline          bool       `json:\"online\"`\n\tStatus          string     `json:\"status\"`\n\tPlatform        string     `json:\"platform\"`\n\tProjects        []struct {\n\t\tID                int    `json:\"id\"`\n\t\tName              string `json:\"name\"`\n\t\tNameWithNamespace string `json:\"name_with_namespace\"`\n\t\tPath              string `json:\"path\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t} `json:\"projects\"`\n\tToken          string   `json:\"token\"`\n\tRevision       string   `json:\"revision\"`\n\tTagList        []string `json:\"tag_list\"`\n\tRunUntagged    bool     `json:\"run_untagged\"`\n\tVersion        string   `json:\"version\"`\n\tLocked         bool     `json:\"locked\"`\n\tAccessLevel    string   `json:\"access_level\"`\n\tMaximumTimeout int      `json:\"maximum_timeout\"`\n\tGroups         []struct {\n\t\tID     int    `json:\"id\"`\n\t\tName   string `json:\"name\"`\n\t\tWebURL string `json:\"web_url\"`\n\t} `json:\"groups\"`\n\n\t// Deprecated: Use Paused instead. (Deprecated in GitLab 14.8)\n\tActive bool `json:\"active\"`\n}\n\n// ListRunnersOptions represents the available ListRunners() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-owned-runners\ntype ListRunnersOptions struct {\n\tListOptions\n\tType    *string   `url:\"type,omitempty\" json:\"type,omitempty\"`\n\tStatus  *string   `url:\"status,omitempty\" json:\"status,omitempty\"`\n\tPaused  *bool     `url:\"paused,omitempty\" json:\"paused,omitempty\"`\n\tTagList *[]string `url:\"tag_list,comma,omitempty\" json:\"tag_list,omitempty\"`\n\n\t// Deprecated: Use Type or Status instead.\n\tScope *string `url:\"scope,omitempty\" json:\"scope,omitempty\"`\n}\n\n// ListRunners gets a list of runners accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-owned-runners\nfunc (s *RunnersService) ListRunners(opt *ListRunnersOptions, options ...RequestOptionFunc) ([]*Runner, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"runners\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rs []*Runner\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// ListAllRunners gets a list of all runners in the GitLab instance. Access is\n// restricted to users with admin privileges.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-all-runners\nfunc (s *RunnersService) ListAllRunners(opt *ListRunnersOptions, options ...RequestOptionFunc) ([]*Runner, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"runners/all\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rs []*Runner\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// GetRunnerDetails returns details for given runner.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#get-runners-details\nfunc (s *RunnersService) GetRunnerDetails(rid interface{}, options ...RequestOptionFunc) (*RunnerDetails, *Response, error) {\n\trunner, err := parseID(rid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"runners/%s\", runner)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trs := new(RunnerDetails)\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// UpdateRunnerDetailsOptions represents the available UpdateRunnerDetails() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#update-runners-details\ntype UpdateRunnerDetailsOptions struct {\n\tDescription     *string   `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPaused          *bool     `url:\"paused,omitempty\" json:\"paused,omitempty\"`\n\tTagList         *[]string `url:\"tag_list[],omitempty\" json:\"tag_list,omitempty\"`\n\tRunUntagged     *bool     `url:\"run_untagged,omitempty\" json:\"run_untagged,omitempty\"`\n\tLocked          *bool     `url:\"locked,omitempty\" json:\"locked,omitempty\"`\n\tAccessLevel     *string   `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tMaximumTimeout  *int      `url:\"maximum_timeout,omitempty\" json:\"maximum_timeout,omitempty\"`\n\tMaintenanceNote *string   `url:\"maintenance_note,omitempty\" json:\"maintenance_note,omitempty\"`\n\n\t// Deprecated: Use Paused instead. (Deprecated in GitLab 14.8)\n\tActive *bool `url:\"active,omitempty\" json:\"active,omitempty\"`\n}\n\n// UpdateRunnerDetails updates details for a given runner.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#update-runners-details\nfunc (s *RunnersService) UpdateRunnerDetails(rid interface{}, opt *UpdateRunnerDetailsOptions, options ...RequestOptionFunc) (*RunnerDetails, *Response, error) {\n\trunner, err := parseID(rid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"runners/%s\", runner)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\trs := new(RunnerDetails)\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// RemoveRunner removes a runner.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#delete-a-runner\nfunc (s *RunnersService) RemoveRunner(rid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\trunner, err := parseID(rid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"runners/%s\", runner)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListRunnerJobsOptions represents the available ListRunnerJobs()\n// options. Status can be one of: running, success, failed, canceled.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-runners-jobs\ntype ListRunnerJobsOptions struct {\n\tListOptions\n\tStatus  *string `url:\"status,omitempty\" json:\"status,omitempty\"`\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListRunnerJobs gets a list of jobs that are being processed or were processed by specified Runner.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-runners-jobs\nfunc (s *RunnersService) ListRunnerJobs(rid interface{}, opt *ListRunnerJobsOptions, options ...RequestOptionFunc) ([]*Job, *Response, error) {\n\trunner, err := parseID(rid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"runners/%s/jobs\", runner)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rs []*Job\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// ListProjectRunnersOptions represents the available ListProjectRunners()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-projects-runners\ntype ListProjectRunnersOptions ListRunnersOptions\n\n// ListProjectRunners gets a list of runners accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-projects-runners\nfunc (s *RunnersService) ListProjectRunners(pid interface{}, opt *ListProjectRunnersOptions, options ...RequestOptionFunc) ([]*Runner, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/runners\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rs []*Runner\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// EnableProjectRunnerOptions represents the available EnableProjectRunner()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#enable-a-runner-in-project\ntype EnableProjectRunnerOptions struct {\n\tRunnerID int `json:\"runner_id\"`\n}\n\n// EnableProjectRunner enables an available specific runner in the project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#enable-a-runner-in-project\nfunc (s *RunnersService) EnableProjectRunner(pid interface{}, opt *EnableProjectRunnerOptions, options ...RequestOptionFunc) (*Runner, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/runners\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Runner)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// DisableProjectRunner disables a specific runner from project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#disable-a-runner-from-project\nfunc (s *RunnersService) DisableProjectRunner(pid interface{}, runner int, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/runners/%d\", PathEscape(project), runner)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListGroupsRunnersOptions represents the available ListGroupsRunners() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-groups-runners\ntype ListGroupsRunnersOptions struct {\n\tListOptions\n\tType    *string   `url:\"type,omitempty\" json:\"type,omitempty\"`\n\tStatus  *string   `url:\"status,omitempty\" json:\"status,omitempty\"`\n\tTagList *[]string `url:\"tag_list,comma,omitempty\" json:\"tag_list,omitempty\"`\n}\n\n// ListGroupsRunners lists all runners (specific and shared) available in the\n// group as well it’s ancestor groups. Shared runners are listed if at least one\n// shared runner is defined.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#list-groups-runners\nfunc (s *RunnersService) ListGroupsRunners(gid interface{}, opt *ListGroupsRunnersOptions, options ...RequestOptionFunc) ([]*Runner, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/runners\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar rs []*Runner\n\tresp, err := s.client.Do(req, &rs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn rs, resp, nil\n}\n\n// RegisterNewRunnerOptions represents the available RegisterNewRunner()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner\ntype RegisterNewRunnerOptions struct {\n\tToken           *string                       `url:\"token\" json:\"token\"`\n\tDescription     *string                       `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tInfo            *RegisterNewRunnerInfoOptions `url:\"info,omitempty\" json:\"info,omitempty\"`\n\tActive          *bool                         `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tPaused          *bool                         `url:\"paused,omitempty\" json:\"paused,omitempty\"`\n\tLocked          *bool                         `url:\"locked,omitempty\" json:\"locked,omitempty\"`\n\tRunUntagged     *bool                         `url:\"run_untagged,omitempty\" json:\"run_untagged,omitempty\"`\n\tTagList         *[]string                     `url:\"tag_list[],omitempty\" json:\"tag_list,omitempty\"`\n\tAccessLevel     *string                       `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tMaximumTimeout  *int                          `url:\"maximum_timeout,omitempty\" json:\"maximum_timeout,omitempty\"`\n\tMaintenanceNote *string                       `url:\"maintenance_note,omitempty\" json:\"maintenance_note,omitempty\"`\n}\n\n// RegisterNewRunnerInfoOptions represents the info hashmap parameter in\n// RegisterNewRunnerOptions.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner\ntype RegisterNewRunnerInfoOptions struct {\n\tName         *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tVersion      *string `url:\"version,omitempty\" json:\"version,omitempty\"`\n\tRevision     *string `url:\"revision,omitempty\" json:\"revision,omitempty\"`\n\tPlatform     *string `url:\"platform,omitempty\" json:\"platform,omitempty\"`\n\tArchitecture *string `url:\"architecture,omitempty\" json:\"architecture,omitempty\"`\n}\n\n// RegisterNewRunner registers a new Runner for the instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#register-a-new-runner\nfunc (s *RunnersService) RegisterNewRunner(opt *RegisterNewRunnerOptions, options ...RequestOptionFunc) (*Runner, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"runners\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(Runner)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// DeleteRegisteredRunnerOptions represents the available\n// DeleteRegisteredRunner() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#delete-a-runner-by-authentication-token\ntype DeleteRegisteredRunnerOptions struct {\n\tToken *string `url:\"token\" json:\"token\"`\n}\n\n// DeleteRegisteredRunner deletes a Runner by Token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#delete-a-runner-by-authentication-token\nfunc (s *RunnersService) DeleteRegisteredRunner(opt *DeleteRegisteredRunnerOptions, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := s.client.NewRequest(http.MethodDelete, \"runners\", opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteRegisteredRunnerByID deletes a runner by ID.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#delete-a-runner-by-id\nfunc (s *RunnersService) DeleteRegisteredRunnerByID(rid int, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := s.client.NewRequest(http.MethodDelete, fmt.Sprintf(\"runners/%d\", rid), nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// VerifyRegisteredRunnerOptions represents the available\n// VerifyRegisteredRunner() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#verify-authentication-for-a-registered-runner\ntype VerifyRegisteredRunnerOptions struct {\n\tToken *string `url:\"token\" json:\"token\"`\n}\n\n// VerifyRegisteredRunner registers a new runner for the instance.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#verify-authentication-for-a-registered-runner\nfunc (s *RunnersService) VerifyRegisteredRunner(opt *VerifyRegisteredRunnerOptions, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"runners/verify\", opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\ntype RunnerRegistrationToken struct {\n\tToken          *string    `url:\"token\" json:\"token\"`\n\tTokenExpiresAt *time.Time `url:\"token_expires_at\" json:\"token_expires_at\"`\n}\n\n// ResetInstanceRunnerRegistrationToken resets the instance runner registration\n// token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#reset-instances-runner-registration-token\nfunc (s *RunnersService) ResetInstanceRunnerRegistrationToken(options ...RequestOptionFunc) (*RunnerRegistrationToken, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"runners/reset_registration_token\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(RunnerRegistrationToken)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// ResetGroupRunnerRegistrationToken resets a group's runner registration token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#reset-groups-runner-registration-token\nfunc (s *RunnersService) ResetGroupRunnerRegistrationToken(gid interface{}, options ...RequestOptionFunc) (*RunnerRegistrationToken, *Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/runners/reset_registration_token\", PathEscape(group))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(RunnerRegistrationToken)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// ResetGroupRunnerRegistrationToken resets a projects's runner registration token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#reset-projects-runner-registration-token\nfunc (s *RunnersService) ResetProjectRunnerRegistrationToken(pid interface{}, options ...RequestOptionFunc) (*RunnerRegistrationToken, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/runners/reset_registration_token\", PathEscape(project))\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(RunnerRegistrationToken)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\ntype RunnerAuthenticationToken struct {\n\tToken          *string    `url:\"token\" json:\"token\"`\n\tTokenExpiresAt *time.Time `url:\"token_expires_at\" json:\"token_expires_at\"`\n}\n\n// ResetRunnerAuthenticationToken resets a runner's authentication token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/runners.html#reset-runners-authentication-token-by-using-the-runner-id\nfunc (s *RunnersService) ResetRunnerAuthenticationToken(rid int, options ...RequestOptionFunc) (*RunnerAuthenticationToken, *Response, error) {\n\tu := fmt.Sprintf(\"runners/%d/reset_authentication_token\", rid)\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(RunnerAuthenticationToken)\n\tresp, err := s.client.Do(req, &r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n"
        },
        {
          "name": "runners_test.go",
          "type": "blob",
          "size": 16.1640625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestDisableRunner(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/runners/2\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\t_, err := client.Runners.DisableProjectRunner(1, 2, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.DisableProjectRunner returns an error: %v\", err)\n\t}\n}\n\nfunc TestListRunnersJobs(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/1/jobs\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, exampleListRunnerJobs)\n\t})\n\n\topt := &ListRunnerJobsOptions{}\n\n\tjobs, _, err := client.Runners.ListRunnerJobs(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.ListRunnersJobs returns an error: %v\", err)\n\t}\n\n\tpipeline := struct {\n\t\tID        int    `json:\"id\"`\n\t\tProjectID int    `json:\"project_id\"`\n\t\tRef       string `json:\"ref\"`\n\t\tSha       string `json:\"sha\"`\n\t\tStatus    string `json:\"status\"`\n\t}{\n\t\tID:        8777,\n\t\tProjectID: 3252,\n\t\tRef:       \"master\",\n\t\tSha:       \"6c016b801a88f4bd31f927fc045b5c746a6f823e\",\n\t\tStatus:    \"failed\",\n\t}\n\n\twant := []*Job{\n\t\t{\n\t\t\tID:             1,\n\t\t\tStatus:         \"failed\",\n\t\t\tStage:          \"test\",\n\t\t\tName:           \"run_tests\",\n\t\t\tRef:            \"master\",\n\t\t\tCreatedAt:      Ptr(time.Date(2021, time.October, 22, 11, 59, 25, 201000000, time.UTC)),\n\t\t\tStartedAt:      Ptr(time.Date(2021, time.October, 22, 11, 59, 33, 660000000, time.UTC)),\n\t\t\tFinishedAt:     Ptr(time.Date(2021, time.October, 22, 15, 59, 25, 201000000, time.UTC)),\n\t\t\tDuration:       171.540594,\n\t\t\tQueuedDuration: 2.535766,\n\t\t\tUser: &User{\n\t\t\t\tID:          368,\n\t\t\t\tName:        \"John SMITH\",\n\t\t\t\tUsername:    \"john.smith\",\n\t\t\t\tAvatarURL:   \"https://gitlab.example.com/uploads/-/system/user/avatar/368/avatar.png\",\n\t\t\t\tState:       \"blocked\",\n\t\t\t\tWebURL:      \"https://gitlab.example.com/john.smith\",\n\t\t\t\tPublicEmail: \"john.smith@example.com\",\n\t\t\t},\n\t\t\tCommit: &Commit{\n\t\t\t\tID:             \"6c016b801a88f4bd31f927fc045b5c746a6f823e\",\n\t\t\t\tShortID:        \"6c016b80\",\n\t\t\t\tCreatedAt:      Ptr(time.Date(2018, time.March, 21, 14, 41, 0, 0, time.UTC)),\n\t\t\t\tParentIDs:      []string{\"6008b4902d40799ab11688e502d9f1f27f6d2e18\"},\n\t\t\t\tTitle:          \"Update env for specific runner\",\n\t\t\t\tMessage:        \"Update env for specific runner\\n\",\n\t\t\t\tAuthorName:     \"John SMITH\",\n\t\t\t\tAuthorEmail:    \"john.smith@example.com\",\n\t\t\t\tAuthoredDate:   Ptr(time.Date(2018, time.March, 21, 14, 41, 0, 0, time.UTC)),\n\t\t\t\tCommitterName:  \"John SMITH\",\n\t\t\t\tCommitterEmail: \"john.smith@example.com\",\n\t\t\t\tCommittedDate:  Ptr(time.Date(2018, time.March, 21, 14, 41, 0, 0, time.UTC)),\n\t\t\t\tWebURL:         \"https://gitlab.example.com/awesome/packages/common/-/commit/6c016b801a88f4bd31f927fc045b5c746a6f823e\",\n\t\t\t},\n\t\t\tPipeline: pipeline,\n\t\t\tWebURL:   \"https://gitlab.example.com/awesome/packages/common/-/jobs/14606\",\n\t\t\tProject: &Project{\n\t\t\t\tID:                3252,\n\t\t\t\tDescription:       \"Common nodejs paquet for producer\",\n\t\t\t\tName:              \"common\",\n\t\t\t\tNameWithNamespace: \"awesome\",\n\t\t\t\tPath:              \"common\",\n\t\t\t\tPathWithNamespace: \"awesome\",\n\t\t\t\tCreatedAt:         Ptr(time.Date(2018, time.February, 13, 9, 21, 48, 107000000, time.UTC)),\n\t\t\t},\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want[0], jobs[0]) {\n\t\tt.Errorf(\"Runners.ListRunnersJobs returned %+v, want %+v\", jobs[0], want[0])\n\t}\n}\n\nfunc TestRemoveRunner(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\t_, err := client.Runners.RemoveRunner(1, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.RemoveARunner returns an error: %v\", err)\n\t}\n}\n\nfunc TestUpdateRunnersDetails(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/6\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, exampleDetailResponse)\n\t})\n\n\topt := &UpdateRunnerDetailsOptions{}\n\n\tdetails, _, err := client.Runners.UpdateRunnerDetails(6, opt, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.UpdateRunnersDetails returns an error: %v\", err)\n\t}\n\n\tprojects := []struct {\n\t\tID                int    `json:\"id\"`\n\t\tName              string `json:\"name\"`\n\t\tNameWithNamespace string `json:\"name_with_namespace\"`\n\t\tPath              string `json:\"path\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t}{{\n\t\tID:                1,\n\t\tName:              \"GitLab Community Edition\",\n\t\tNameWithNamespace: \"GitLab.org / GitLab Community Edition\",\n\t\tPath:              \"gitlab-ce\",\n\t\tPathWithNamespace: \"gitlab-org/gitlab-ce\",\n\t}}\n\n\twant := &RunnerDetails{\n\t\tActive:         true,\n\t\tDescription:    \"test-1-20150125-test\",\n\t\tID:             6,\n\t\tIsShared:       false,\n\t\tRunnerType:     \"project_type\",\n\t\tContactedAt:    Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t\tOnline:         true,\n\t\tStatus:         \"online\",\n\t\tToken:          \"205086a8e3b9a2b818ffac9b89d102\",\n\t\tTagList:        []string{\"ruby\", \"mysql\"},\n\t\tRunUntagged:    true,\n\t\tAccessLevel:    \"ref_protected\",\n\t\tProjects:       projects,\n\t\tMaximumTimeout: 3600,\n\t\tLocked:         false,\n\t}\n\tif !reflect.DeepEqual(want, details) {\n\t\tt.Errorf(\"Runners.UpdateRunnersDetails returned %+v, want %+v\", details, want)\n\t}\n}\n\nfunc TestGetRunnerDetails(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/6\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, exampleDetailResponse)\n\t})\n\n\tdetails, _, err := client.Runners.GetRunnerDetails(6, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.GetRunnerDetails returns an error: %v\", err)\n\t}\n\n\tprojects := []struct {\n\t\tID                int    `json:\"id\"`\n\t\tName              string `json:\"name\"`\n\t\tNameWithNamespace string `json:\"name_with_namespace\"`\n\t\tPath              string `json:\"path\"`\n\t\tPathWithNamespace string `json:\"path_with_namespace\"`\n\t}{{\n\t\tID:                1,\n\t\tName:              \"GitLab Community Edition\",\n\t\tNameWithNamespace: \"GitLab.org / GitLab Community Edition\",\n\t\tPath:              \"gitlab-ce\",\n\t\tPathWithNamespace: \"gitlab-org/gitlab-ce\",\n\t}}\n\n\twant := &RunnerDetails{\n\t\tActive:         true,\n\t\tDescription:    \"test-1-20150125-test\",\n\t\tID:             6,\n\t\tIsShared:       false,\n\t\tRunnerType:     \"project_type\",\n\t\tContactedAt:    Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t\tOnline:         true,\n\t\tStatus:         \"online\",\n\t\tToken:          \"205086a8e3b9a2b818ffac9b89d102\",\n\t\tTagList:        []string{\"ruby\", \"mysql\"},\n\t\tRunUntagged:    true,\n\t\tAccessLevel:    \"ref_protected\",\n\t\tProjects:       projects,\n\t\tMaximumTimeout: 3600,\n\t\tLocked:         false,\n\t}\n\tif !reflect.DeepEqual(want, details) {\n\t\tt.Errorf(\"Runners.UpdateRunnersDetails returned %+v, want %+v\", details, want)\n\t}\n}\n\nfunc TestRegisterNewRunner(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, exampleRegisterNewRunner)\n\t})\n\n\topt := &RegisterNewRunnerOptions{}\n\n\trunner, resp, err := client.Runners.RegisterNewRunner(opt, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.RegisterNewRunner returns an error: %v\", err)\n\t}\n\n\twant := &Runner{\n\t\tID:             12345,\n\t\tToken:          \"6337ff461c94fd3fa32ba3b1ff4125\",\n\t\tTokenExpiresAt: Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t}\n\tif !reflect.DeepEqual(want, runner) {\n\t\tt.Errorf(\"Runners.RegisterNewRunner returned %+v, want %+v\", runner, want)\n\t}\n\n\twantCode := 201\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.DeleteRegisteredRunner returned status code %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n\n// Similar to TestRegisterNewRunner but sends info struct and some extra other\n// fields too.\nfunc TestRegisterNewRunnerInfo(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"id\": 53,\n\t\t\t\"description\": \"some description\",\n\t\t\t\"active\": true,\n\t\t\t\"ip_address\": \"1.2.3.4\",\n\t\t\t\"name\": \"some name\",\n\t\t\t\"online\": true,\n\t\t\t\"status\": \"online\",\n\t\t\t\"token\": \"1111122222333333444444\",\n\t\t\t\"token_expires_at\": \"2016-01-25T16:39:48.166Z\"\n\t\t  }`)\n\t})\n\n\topt := &RegisterNewRunnerOptions{\n\t\tToken:       Ptr(\"6337ff461c94fd3fa32ba3b1ff4125\"),\n\t\tDescription: Ptr(\"some description\"),\n\t\tInfo: &RegisterNewRunnerInfoOptions{\n\t\t\tPtr(\"some name\"),\n\t\t\tPtr(\"13.7.0\"),\n\t\t\tPtr(\"943fc252\"),\n\t\t\tPtr(\"linux\"),\n\t\t\tPtr(\"amd64\"),\n\t\t},\n\t\tActive:         Ptr(true),\n\t\tLocked:         Ptr(true),\n\t\tRunUntagged:    Ptr(false),\n\t\tMaximumTimeout: Ptr(45),\n\t}\n\trunner, resp, err := client.Runners.RegisterNewRunner(opt, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.RegisterNewRunner returns an error: %v\", err)\n\t}\n\n\twant := &Runner{\n\t\tID:             53,\n\t\tDescription:    \"some description\",\n\t\tActive:         true,\n\t\tIPAddress:      \"1.2.3.4\",\n\t\tName:           \"some name\",\n\t\tOnline:         true,\n\t\tStatus:         \"online\",\n\t\tToken:          \"1111122222333333444444\",\n\t\tTokenExpiresAt: Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t}\n\tif !reflect.DeepEqual(want, runner) {\n\t\tt.Errorf(\"Runners.RegisterNewRunner returned %+v, want %+v\", runner, want)\n\t}\n\n\twantCode := 201\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.DeleteRegisteredRunner returned status code %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n\nfunc TestDeleteRegisteredRunner(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\topt := &DeleteRegisteredRunnerOptions{}\n\n\tresp, err := client.Runners.DeleteRegisteredRunner(opt, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.DeleteRegisteredRunner returns an error: %v\", err)\n\t}\n\n\twant := 204\n\tif !reflect.DeepEqual(want, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.DeleteRegisteredRunner returned returned status code  %+v, want %+v\", resp.StatusCode, want)\n\t}\n}\n\nfunc TestDeleteRegisteredRunnerByID(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/11111\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\trid := 11111\n\n\tresp, err := client.Runners.DeleteRegisteredRunnerByID(rid, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.DeleteRegisteredRunnerByID returns an error: %v\", err)\n\t}\n\n\twant := 204\n\tif !reflect.DeepEqual(want, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.DeleteRegisteredRunnerByID returned returned status code  %+v, want %+v\", resp.StatusCode, want)\n\t}\n}\n\nfunc TestVerifyRegisteredRunner(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/verify\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\topt := &VerifyRegisteredRunnerOptions{}\n\n\tresp, err := client.Runners.VerifyRegisteredRunner(opt, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.VerifyRegisteredRunner returns an error: %v\", err)\n\t}\n\n\twant := 200\n\tif !reflect.DeepEqual(want, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.VerifyRegisteredRunner returned returned status code  %+v, want %+v\", resp.StatusCode, want)\n\t}\n}\n\nfunc TestResetInstanceRunnerRegistrationToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/reset_registration_token\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"token\": \"6337ff461c94fd3fa32ba3b1ff4125\",\n\t\t\t\"token_expires_at\": \"2016-01-25T16:39:48.166Z\"\n\t\t}`)\n\t})\n\n\ttoken, resp, err := client.Runners.ResetInstanceRunnerRegistrationToken(nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.ResetInstanceRunnerRegistrationToken returns an error: %v\", err)\n\t}\n\n\twant := &RunnerRegistrationToken{\n\t\tToken:          Ptr(\"6337ff461c94fd3fa32ba3b1ff4125\"),\n\t\tTokenExpiresAt: Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t}\n\tif !reflect.DeepEqual(want, token) {\n\t\tt.Errorf(\"Runners.ResetInstanceRunnerRegistrationToken returned %+v, want %+v\", token, want)\n\t}\n\n\twantCode := 201\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.ResetInstanceRunnerRegistrationToken returned returned status code  %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n\nfunc TestResetGroupRunnerRegistrationToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/foobar/runners/reset_registration_token\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"token\": \"6337ff461c94fd3fa32ba3b1ff4125\",\n\t\t\t\"token_expires_at\": \"2016-01-25T16:39:48.166Z\"\n\t\t}`)\n\t})\n\n\ttoken, resp, err := client.Runners.ResetGroupRunnerRegistrationToken(\"foobar\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.ResetGroupRunnerRegistrationToken returns an error: %v\", err)\n\t}\n\n\twant := &RunnerRegistrationToken{\n\t\tToken:          Ptr(\"6337ff461c94fd3fa32ba3b1ff4125\"),\n\t\tTokenExpiresAt: Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t}\n\tif !reflect.DeepEqual(want, token) {\n\t\tt.Errorf(\"Runners.ResetGroupRunnerRegistrationToken returned %+v, want %+v\", token, want)\n\t}\n\n\twantCode := 201\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.ResetGroupRunnerRegistrationToken returned returned status code  %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n\nfunc TestResetProjectRunnerRegistrationToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/9/runners/reset_registration_token\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"token\": \"6337ff461c94fd3fa32ba3b1ff4125\",\n\t\t\t\"token_expires_at\": \"2016-01-25T16:39:48.166Z\"\n\t\t}`)\n\t})\n\n\ttoken, resp, err := client.Runners.ResetProjectRunnerRegistrationToken(\"9\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.ResetProjectRunnerRegistrationToken returns an error: %v\", err)\n\t}\n\n\twant := &RunnerRegistrationToken{\n\t\tToken:          Ptr(\"6337ff461c94fd3fa32ba3b1ff4125\"),\n\t\tTokenExpiresAt: Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t}\n\tif !reflect.DeepEqual(want, token) {\n\t\tt.Errorf(\"Runners.ResetProjectRunnerRegistrationToken returned %+v, want %+v\", token, want)\n\t}\n\n\twantCode := 201\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.ResetProjectRunnerRegistrationToken returned returned status code  %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n\nfunc TestResetRunnerAuthenticationToken(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/runners/42/reset_authentication_token\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tfmt.Fprint(w, `{\n\t\t\t\"token\": \"6337ff461c94fd3fa32ba3b1ff4125\",\n\t\t\t\"token_expires_at\": \"2016-01-25T16:39:48.166Z\"\n\t\t}`)\n\t})\n\n\ttoken, resp, err := client.Runners.ResetRunnerAuthenticationToken(42, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"Runners.ResetRunnerAuthenticationToken returns an error: %v\", err)\n\t}\n\n\twant := &RunnerAuthenticationToken{\n\t\tToken:          Ptr(\"6337ff461c94fd3fa32ba3b1ff4125\"),\n\t\tTokenExpiresAt: Ptr(time.Date(2016, time.January, 25, 16, 39, 48, 166000000, time.UTC)),\n\t}\n\tif !reflect.DeepEqual(want, token) {\n\t\tt.Errorf(\"Runners.ResetRunnerAuthenticationToken returned %+v, want %+v\", token, want)\n\t}\n\n\twantCode := 201\n\tif !reflect.DeepEqual(wantCode, resp.StatusCode) {\n\t\tt.Errorf(\"Runners.ResetRunnerAuthenticationToken returned returned status code  %+v, want %+v\", resp.StatusCode, wantCode)\n\t}\n}\n"
        },
        {
          "name": "search.go",
          "type": "blob",
          "size": 13.583984375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// SearchService handles communication with the search related methods of the\n// GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html\ntype SearchService struct {\n\tclient *Client\n}\n\n// SearchOptions represents the available options for all search methods.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html\ntype SearchOptions struct {\n\tListOptions\n\tRef *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\ntype searchOptions struct {\n\tSearchOptions\n\tScope  string `url:\"scope\" json:\"scope\"`\n\tSearch string `url:\"search\" json:\"search\"`\n}\n\n// Projects searches the expression within projects\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-projects\nfunc (s *SearchService) Projects(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tvar ps []*Project\n\tresp, err := s.search(\"projects\", query, &ps, opt, options...)\n\treturn ps, resp, err\n}\n\n// ProjectsByGroup searches the expression within projects for\n// the specified group\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#group-search-api\nfunc (s *SearchService) ProjectsByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Project, *Response, error) {\n\tvar ps []*Project\n\tresp, err := s.searchByGroup(gid, \"projects\", query, &ps, opt, options...)\n\treturn ps, resp, err\n}\n\n// Issues searches the expression within issues\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-issues\nfunc (s *SearchService) Issues(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tvar is []*Issue\n\tresp, err := s.search(\"issues\", query, &is, opt, options...)\n\treturn is, resp, err\n}\n\n// IssuesByGroup searches the expression within issues for\n// the specified group\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-issues-1\nfunc (s *SearchService) IssuesByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tvar is []*Issue\n\tresp, err := s.searchByGroup(gid, \"issues\", query, &is, opt, options...)\n\treturn is, resp, err\n}\n\n// IssuesByProject searches the expression within issues for\n// the specified project\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-issues-2\nfunc (s *SearchService) IssuesByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Issue, *Response, error) {\n\tvar is []*Issue\n\tresp, err := s.searchByProject(pid, \"issues\", query, &is, opt, options...)\n\treturn is, resp, err\n}\n\n// MergeRequests searches the expression within merge requests\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-merge_requests\nfunc (s *SearchService) MergeRequests(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tvar ms []*MergeRequest\n\tresp, err := s.search(\"merge_requests\", query, &ms, opt, options...)\n\treturn ms, resp, err\n}\n\n// MergeRequestsByGroup searches the expression within merge requests for\n// the specified group\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-merge_requests-1\nfunc (s *SearchService) MergeRequestsByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tvar ms []*MergeRequest\n\tresp, err := s.searchByGroup(gid, \"merge_requests\", query, &ms, opt, options...)\n\treturn ms, resp, err\n}\n\n// MergeRequestsByProject searches the expression within merge requests for\n// the specified project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-merge_requests-2\nfunc (s *SearchService) MergeRequestsByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*MergeRequest, *Response, error) {\n\tvar ms []*MergeRequest\n\tresp, err := s.searchByProject(pid, \"merge_requests\", query, &ms, opt, options...)\n\treturn ms, resp, err\n}\n\n// Milestones searches the expression within milestones\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-milestones\nfunc (s *SearchService) Milestones(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Milestone, *Response, error) {\n\tvar ms []*Milestone\n\tresp, err := s.search(\"milestones\", query, &ms, opt, options...)\n\treturn ms, resp, err\n}\n\n// MilestonesByGroup searches the expression within milestones for\n// the specified group\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-milestones-1\nfunc (s *SearchService) MilestonesByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Milestone, *Response, error) {\n\tvar ms []*Milestone\n\tresp, err := s.searchByGroup(gid, \"milestones\", query, &ms, opt, options...)\n\treturn ms, resp, err\n}\n\n// MilestonesByProject searches the expression within milestones for\n// the specified project\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-milestones-2\nfunc (s *SearchService) MilestonesByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Milestone, *Response, error) {\n\tvar ms []*Milestone\n\tresp, err := s.searchByProject(pid, \"milestones\", query, &ms, opt, options...)\n\treturn ms, resp, err\n}\n\n// SnippetTitles searches the expression within snippet titles\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-snippet_titles\nfunc (s *SearchService) SnippetTitles(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Snippet, *Response, error) {\n\tvar ss []*Snippet\n\tresp, err := s.search(\"snippet_titles\", query, &ss, opt, options...)\n\treturn ss, resp, err\n}\n\n// SnippetBlobs searches the expression within snippet blobs\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-snippet_blobs\nfunc (s *SearchService) SnippetBlobs(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Snippet, *Response, error) {\n\tvar ss []*Snippet\n\tresp, err := s.search(\"snippet_blobs\", query, &ss, opt, options...)\n\treturn ss, resp, err\n}\n\n// NotesByProject searches the expression within notes for the specified\n// project\n//\n// GitLab API docs: // https://docs.gitlab.com/ee/api/search.html#scope-notes\nfunc (s *SearchService) NotesByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Note, *Response, error) {\n\tvar ns []*Note\n\tresp, err := s.searchByProject(pid, \"notes\", query, &ns, opt, options...)\n\treturn ns, resp, err\n}\n\n// WikiBlobs searches the expression within all wiki blobs\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-wiki_blobs\nfunc (s *SearchService) WikiBlobs(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Wiki, *Response, error) {\n\tvar ws []*Wiki\n\tresp, err := s.search(\"wiki_blobs\", query, &ws, opt, options...)\n\treturn ws, resp, err\n}\n\n// WikiBlobsByGroup searches the expression within wiki blobs for\n// specified group\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-wiki_blobs-premium-1\nfunc (s *SearchService) WikiBlobsByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Wiki, *Response, error) {\n\tvar ws []*Wiki\n\tresp, err := s.searchByGroup(gid, \"wiki_blobs\", query, &ws, opt, options...)\n\treturn ws, resp, err\n}\n\n// WikiBlobsByProject searches the expression within wiki blobs for\n// the specified project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/search.html#scope-wiki_blobs-premium-2\nfunc (s *SearchService) WikiBlobsByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Wiki, *Response, error) {\n\tvar ws []*Wiki\n\tresp, err := s.searchByProject(pid, \"wiki_blobs\", query, &ws, opt, options...)\n\treturn ws, resp, err\n}\n\n// Commits searches the expression within all commits\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-commits\nfunc (s *SearchService) Commits(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Commit, *Response, error) {\n\tvar cs []*Commit\n\tresp, err := s.search(\"commits\", query, &cs, opt, options...)\n\treturn cs, resp, err\n}\n\n// CommitsByGroup searches the expression within commits for the specified\n// group\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-commits-premium-1\nfunc (s *SearchService) CommitsByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Commit, *Response, error) {\n\tvar cs []*Commit\n\tresp, err := s.searchByGroup(gid, \"commits\", query, &cs, opt, options...)\n\treturn cs, resp, err\n}\n\n// CommitsByProject searches the expression within commits for the\n// specified project\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-commits-premium-2\nfunc (s *SearchService) CommitsByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Commit, *Response, error) {\n\tvar cs []*Commit\n\tresp, err := s.searchByProject(pid, \"commits\", query, &cs, opt, options...)\n\treturn cs, resp, err\n}\n\n// Blob represents a single blob.\ntype Blob struct {\n\tBasename  string `json:\"basename\"`\n\tData      string `json:\"data\"`\n\tPath      string `json:\"path\"`\n\tFilename  string `json:\"filename\"`\n\tID        string `json:\"id\"`\n\tRef       string `json:\"ref\"`\n\tStartline int    `json:\"startline\"`\n\tProjectID int    `json:\"project_id\"`\n}\n\n// Blobs searches the expression within all blobs\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-blobs\nfunc (s *SearchService) Blobs(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Blob, *Response, error) {\n\tvar bs []*Blob\n\tresp, err := s.search(\"blobs\", query, &bs, opt, options...)\n\treturn bs, resp, err\n}\n\n// BlobsByGroup searches the expression within blobs for the specified\n// group\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-blobs-premium-1\nfunc (s *SearchService) BlobsByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Blob, *Response, error) {\n\tvar bs []*Blob\n\tresp, err := s.searchByGroup(gid, \"blobs\", query, &bs, opt, options...)\n\treturn bs, resp, err\n}\n\n// BlobsByProject searches the expression within blobs for the specified\n// project\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-blobs-premium-2\nfunc (s *SearchService) BlobsByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*Blob, *Response, error) {\n\tvar bs []*Blob\n\tresp, err := s.searchByProject(pid, \"blobs\", query, &bs, opt, options...)\n\treturn bs, resp, err\n}\n\n// Users searches the expression within all users\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-users\nfunc (s *SearchService) Users(query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*User, *Response, error) {\n\tvar ret []*User\n\tresp, err := s.search(\"users\", query, &ret, opt, options...)\n\treturn ret, resp, err\n}\n\n// UsersByGroup searches the expression within users for the specified\n// group\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-users-1\nfunc (s *SearchService) UsersByGroup(gid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*User, *Response, error) {\n\tvar ret []*User\n\tresp, err := s.searchByGroup(gid, \"users\", query, &ret, opt, options...)\n\treturn ret, resp, err\n}\n\n// UsersByProject searches the expression within users for the\n// specified project\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/search.html#scope-users-2\nfunc (s *SearchService) UsersByProject(pid interface{}, query string, opt *SearchOptions, options ...RequestOptionFunc) ([]*User, *Response, error) {\n\tvar ret []*User\n\tresp, err := s.searchByProject(pid, \"users\", query, &ret, opt, options...)\n\treturn ret, resp, err\n}\n\nfunc (s *SearchService) search(scope, query string, result interface{}, opt *SearchOptions, options ...RequestOptionFunc) (*Response, error) {\n\topts := &searchOptions{SearchOptions: *opt, Scope: scope, Search: query}\n\n\treq, err := s.client.NewRequest(http.MethodGet, \"search\", opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, result)\n}\n\nfunc (s *SearchService) searchByGroup(gid interface{}, scope, query string, result interface{}, opt *SearchOptions, options ...RequestOptionFunc) (*Response, error) {\n\tgroup, err := parseID(gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"groups/%s/-/search\", PathEscape(group))\n\n\topts := &searchOptions{SearchOptions: *opt, Scope: scope, Search: query}\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, result)\n}\n\nfunc (s *SearchService) searchByProject(pid interface{}, scope, query string, result interface{}, opt *SearchOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/-/search\", PathEscape(project))\n\n\topts := &searchOptions{SearchOptions: *opt, Scope: scope, Search: query}\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, result)\n}\n"
        },
        {
          "name": "search_test.go",
          "type": "blob",
          "size": 2.7109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSearchService_Users(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/search_users.json\")\n\t})\n\n\topts := &SearchOptions{ListOptions: ListOptions{PerPage: 2}}\n\tusers, _, err := client.Search.Users(\"doe\", opts)\n\n\trequire.NoError(t, err)\n\n\twant := []*User{{\n\t\tID:        1,\n\t\tUsername:  \"user1\",\n\t\tName:      \"John Doe1\",\n\t\tState:     \"active\",\n\t\tAvatarURL: \"http://www.gravatar.com/avatar/c922747a93b40d1ea88262bf1aebee62?s=80&d=identicon\",\n\t\tWebURL:    \"http://localhost/user1\",\n\t}}\n\trequire.Equal(t, want, users)\n}\n\nfunc TestSearchService_UsersByGroup(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/groups/3/-/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/search_users.json\")\n\t})\n\n\topts := &SearchOptions{ListOptions: ListOptions{PerPage: 2}}\n\tusers, _, err := client.Search.UsersByGroup(\"3\", \"doe\", opts)\n\n\trequire.NoError(t, err)\n\n\twant := []*User{{\n\t\tID:        1,\n\t\tUsername:  \"user1\",\n\t\tName:      \"John Doe1\",\n\t\tState:     \"active\",\n\t\tAvatarURL: \"http://www.gravatar.com/avatar/c922747a93b40d1ea88262bf1aebee62?s=80&d=identicon\",\n\t\tWebURL:    \"http://localhost/user1\",\n\t}}\n\trequire.Equal(t, want, users)\n}\n\nfunc TestSearchService_UsersByProject(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/6/-/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/search_users.json\")\n\t})\n\n\topts := &SearchOptions{ListOptions: ListOptions{PerPage: 2}}\n\tusers, _, err := client.Search.UsersByProject(\"6\", \"doe\", opts)\n\n\trequire.NoError(t, err)\n\n\twant := []*User{{\n\t\tID:        1,\n\t\tUsername:  \"user1\",\n\t\tName:      \"John Doe1\",\n\t\tState:     \"active\",\n\t\tAvatarURL: \"http://www.gravatar.com/avatar/c922747a93b40d1ea88262bf1aebee62?s=80&d=identicon\",\n\t\tWebURL:    \"http://localhost/user1\",\n\t}}\n\trequire.Equal(t, want, users)\n}\n"
        },
        {
          "name": "services.go",
          "type": "blob",
          "size": 92.6689453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"time\"\n)\n\n// ServicesService handles communication with the services related methods of\n// the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/integrations.html\ntype ServicesService struct {\n\tclient *Client\n}\n\n// Service represents a GitLab service.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/integrations.html\ntype Service struct {\n\tID                             int        `json:\"id\"`\n\tTitle                          string     `json:\"title\"`\n\tSlug                           string     `json:\"slug\"`\n\tCreatedAt                      *time.Time `json:\"created_at\"`\n\tUpdatedAt                      *time.Time `json:\"updated_at\"`\n\tActive                         bool       `json:\"active\"`\n\tAlertEvents                    bool       `json:\"alert_events\"`\n\tCommitEvents                   bool       `json:\"commit_events\"`\n\tConfidentialIssuesEvents       bool       `json:\"confidential_issues_events\"`\n\tConfidentialNoteEvents         bool       `json:\"confidential_note_events\"`\n\tDeploymentEvents               bool       `json:\"deployment_events\"`\n\tGroupConfidentialMentionEvents bool       `json:\"group_confidential_mention_events\"`\n\tGroupMentionEvents             bool       `json:\"group_mention_events\"`\n\tIncidentEvents                 bool       `json:\"incident_events\"`\n\tIssuesEvents                   bool       `json:\"issues_events\"`\n\tJobEvents                      bool       `json:\"job_events\"`\n\tMergeRequestsEvents            bool       `json:\"merge_requests_events\"`\n\tNoteEvents                     bool       `json:\"note_events\"`\n\tPipelineEvents                 bool       `json:\"pipeline_events\"`\n\tPushEvents                     bool       `json:\"push_events\"`\n\tTagPushEvents                  bool       `json:\"tag_push_events\"`\n\tVulnerabilityEvents            bool       `json:\"vulnerability_events\"`\n\tWikiPageEvents                 bool       `json:\"wiki_page_events\"`\n\tCommentOnEventEnabled          bool       `json:\"comment_on_event_enabled\"`\n\tInherited                      bool       `json:\"inherited\"`\n}\n\n// ListServices gets a list of all active services.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/integrations.html#list-all-active-integrations\nfunc (s *ServicesService) ListServices(pid interface{}, options ...RequestOptionFunc) ([]*Service, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar svcs []*Service\n\tresp, err := s.client.Do(req, &svcs)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svcs, resp, nil\n}\n\n// CustomIssueTrackerService represents Custom Issue Tracker service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#custom-issue-tracker\ntype CustomIssueTrackerService struct {\n\tService\n\tProperties *CustomIssueTrackerServiceProperties `json:\"properties\"`\n}\n\n// CustomIssueTrackerServiceProperties represents Custom Issue Tracker specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#custom-issue-tracker\ntype CustomIssueTrackerServiceProperties struct {\n\tProjectURL  string `json:\"project_url,omitempty\"`\n\tIssuesURL   string `json:\"issues_url,omitempty\"`\n\tNewIssueURL string `json:\"new_issue_url,omitempty\"`\n}\n\n// GetCustomIssueTrackerService gets Custom Issue Tracker service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-custom-issue-tracker-settings\nfunc (s *ServicesService) GetCustomIssueTrackerService(pid interface{}, options ...RequestOptionFunc) (*CustomIssueTrackerService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/custom-issue-tracker\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(CustomIssueTrackerService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetCustomIssueTrackerServiceOptions represents the available SetCustomIssueTrackerService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-a-custom-issue-tracker\ntype SetCustomIssueTrackerServiceOptions struct {\n\tNewIssueURL *string `url:\"new_issue_url,omitempty\" json:\"new_issue_url,omitempty\"`\n\tIssuesURL   *string `url:\"issues_url,omitempty\" json:\"issues_url,omitempty\"`\n\tProjectURL  *string `url:\"project_url,omitempty\" json:\"project_url,omitempty\"`\n}\n\n// SetCustomIssueTrackerService sets Custom Issue Tracker service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-a-custom-issue-tracker\nfunc (s *ServicesService) SetCustomIssueTrackerService(pid interface{}, opt *SetCustomIssueTrackerServiceOptions, options ...RequestOptionFunc) (*CustomIssueTrackerService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/custom-issue-tracker\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(CustomIssueTrackerService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteCustomIssueTrackerService deletes Custom Issue Tracker service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-a-custom-issue-tracker\nfunc (s *ServicesService) DeleteCustomIssueTrackerService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/custom-issue-tracker\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DataDogService represents DataDog service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#datadog\ntype DataDogService struct {\n\tService\n\tProperties *DataDogServiceProperties `json:\"properties\"`\n}\n\n// DataDogServiceProperties represents DataDog specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#datadog\ntype DataDogServiceProperties struct {\n\tAPIURL             string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tDataDogEnv         string `url:\"datadog_env,omitempty\" json:\"datadog_env,omitempty\"`\n\tDataDogService     string `url:\"datadog_service,omitempty\" json:\"datadog_service,omitempty\"`\n\tDataDogSite        string `url:\"datadog_site,omitempty\" json:\"datadog_site,omitempty\"`\n\tDataDogTags        string `url:\"datadog_tags,omitempty\" json:\"datadog_tags,omitempty\"`\n\tArchiveTraceEvents bool   `url:\"archive_trace_events,omitempty\" json:\"archive_trace_events,omitempty\"`\n}\n\n// GetDataDogService gets DataDog service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-datadog-settings\nfunc (s *ServicesService) GetDataDogService(pid interface{}, options ...RequestOptionFunc) (*DataDogService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/datadog\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(DataDogService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetDataDogServiceOptions represents the available SetDataDogService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-datadog\ntype SetDataDogServiceOptions struct {\n\tAPIKey             *string `url:\"api_key,omitempty\" json:\"api_key,omitempty\"`\n\tAPIURL             *string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tDataDogEnv         *string `url:\"datadog_env,omitempty\" json:\"datadog_env,omitempty\"`\n\tDataDogService     *string `url:\"datadog_service,omitempty\" json:\"datadog_service,omitempty\"`\n\tDataDogSite        *string `url:\"datadog_site,omitempty\" json:\"datadog_site,omitempty\"`\n\tDataDogTags        *string `url:\"datadog_tags,omitempty\" json:\"datadog_tags,omitempty\"`\n\tArchiveTraceEvents *bool   `url:\"archive_trace_events,omitempty\" json:\"archive_trace_events,omitempty\"`\n}\n\n// SetDataDogService sets DataDog service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-datadog\nfunc (s *ServicesService) SetDataDogService(pid interface{}, opt *SetDataDogServiceOptions, options ...RequestOptionFunc) (*DataDogService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/datadog\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(DataDogService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteDataDogService deletes the DataDog service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-datadog\nfunc (s *ServicesService) DeleteDataDogService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/datadog\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DiscordService represents Discord service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#discord-notifications\ntype DiscordService struct {\n\tService\n\tProperties *DiscordServiceProperties `json:\"properties\"`\n}\n\n// DiscordServiceProperties represents Discord specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#discord-notifications\ntype DiscordServiceProperties struct {\n\tBranchesToBeNotified      string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tNotifyOnlyBrokenPipelines bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n}\n\n// GetDiscordService gets Discord service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-discord-notifications-settings\nfunc (s *ServicesService) GetDiscordService(pid interface{}, options ...RequestOptionFunc) (*DiscordService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/discord\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(DiscordService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetDiscordServiceOptions represents the available SetDiscordService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-discord-notifications\ntype SetDiscordServiceOptions struct {\n\tWebHook                          *string `url:\"webhook,omitempty\" json:\"webhook,omitempty\"`\n\tBranchesToBeNotified             *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tConfidentialIssuesEvents         *bool   `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tConfidentialIssuesChannel        *string `url:\"confidential_issue_channel,omitempty\" json:\"confidential_issue_channel,omitempty\"`\n\tConfidentialNoteEvents           *bool   `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tConfidentialNoteChannel          *string `url:\"confidential_note_channel,omitempty\" json:\"confidential_note_channel,omitempty\"`\n\tDeploymentEvents                 *bool   `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tDeploymentChannel                *string `url:\"deployment_channel,omitempty\" json:\"deployment_channel,omitempty\"`\n\tGroupConfidentialMentionsEvents  *bool   `url:\"group_confidential_mentions_events,omitempty\" json:\"group_confidential_mentions_events,omitempty\"`\n\tGroupConfidentialMentionsChannel *string `url:\"group_confidential_mentions_channel,omitempty\" json:\"group_confidential_mentions_channel,omitempty\"`\n\tGroupMentionsEvents              *bool   `url:\"group_mentions_events,omitempty\" json:\"group_mentions_events,omitempty\"`\n\tGroupMentionsChannel             *string `url:\"group_mentions_channel,omitempty\" json:\"group_mentions_channel,omitempty\"`\n\tIssuesEvents                     *bool   `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tIssueChannel                     *string `url:\"issue_channel,omitempty\" json:\"issue_channel,omitempty\"`\n\tMergeRequestsEvents              *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tMergeRequestChannel              *string `url:\"merge_request_channel,omitempty\" json:\"merge_request_channel,omitempty\"`\n\tNoteEvents                       *bool   `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tNoteChannel                      *string `url:\"note_channel,omitempty\" json:\"note_channel,omitempty\"`\n\tNotifyOnlyBrokenPipelines        *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tPipelineEvents                   *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tPipelineChannel                  *string `url:\"pipeline_channel,omitempty\" json:\"pipeline_channel,omitempty\"`\n\tPushEvents                       *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tPushChannel                      *string `url:\"push_channel,omitempty\" json:\"push_channel,omitempty\"`\n\tTagPushEvents                    *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tTagPushChannel                   *string `url:\"tag_push_channel,omitempty\" json:\"tag_push_channel,omitempty\"`\n\tWikiPageEvents                   *bool   `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n\tWikiPageChannel                  *string `url:\"wiki_page_channel,omitempty\" json:\"wiki_page_channel,omitempty\"`\n}\n\n// SetDiscordService sets Discord service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-discord-notifications\nfunc (s *ServicesService) SetDiscordService(pid interface{}, opt *SetDiscordServiceOptions, options ...RequestOptionFunc) (*DiscordService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/discord\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(DiscordService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteDiscordService deletes Discord service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-discord-notifications\nfunc (s *ServicesService) DeleteDiscordService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/discord\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DroneCIService represents Drone CI service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#drone\ntype DroneCIService struct {\n\tService\n\tProperties *DroneCIServiceProperties `json:\"properties\"`\n}\n\n// DroneCIServiceProperties represents Drone CI specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#drone\ntype DroneCIServiceProperties struct {\n\tDroneURL              string `json:\"drone_url\"`\n\tEnableSSLVerification bool   `json:\"enable_ssl_verification\"`\n}\n\n// GetDroneCIService gets Drone CI service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-drone-settings\nfunc (s *ServicesService) GetDroneCIService(pid interface{}, options ...RequestOptionFunc) (*DroneCIService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/drone-ci\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(DroneCIService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetDroneCIServiceOptions represents the available SetDroneCIService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-drone\ntype SetDroneCIServiceOptions struct {\n\tToken                 *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tDroneURL              *string `url:\"drone_url,omitempty\" json:\"drone_url,omitempty\"`\n\tEnableSSLVerification *bool   `url:\"enable_ssl_verification,omitempty\" json:\"enable_ssl_verification,omitempty\"`\n\tPushEvents            *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tMergeRequestsEvents   *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents         *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n}\n\n// SetDroneCIService sets Drone CI service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-drone\nfunc (s *ServicesService) SetDroneCIService(pid interface{}, opt *SetDroneCIServiceOptions, options ...RequestOptionFunc) (*DroneCIService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/drone-ci\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(DroneCIService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteDroneCIService deletes Drone CI service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-drone\nfunc (s *ServicesService) DeleteDroneCIService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/drone-ci\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// EmailsOnPushService represents Emails on Push service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#emails-on-push\ntype EmailsOnPushService struct {\n\tService\n\tProperties *EmailsOnPushServiceProperties `json:\"properties\"`\n}\n\n// EmailsOnPushServiceProperties represents Emails on Push specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#emails-on-push\ntype EmailsOnPushServiceProperties struct {\n\tRecipients             string `json:\"recipients\"`\n\tDisableDiffs           bool   `json:\"disable_diffs\"`\n\tSendFromCommitterEmail bool   `json:\"send_from_committer_email\"`\n\tPushEvents             bool   `json:\"push_events\"`\n\tTagPushEvents          bool   `json:\"tag_push_events\"`\n\tBranchesToBeNotified   string `json:\"branches_to_be_notified\"`\n}\n\n// GetEmailsOnPushService gets Emails on Push service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-emails-on-push-integration-settings\nfunc (s *ServicesService) GetEmailsOnPushService(pid interface{}, options ...RequestOptionFunc) (*EmailsOnPushService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/emails-on-push\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(EmailsOnPushService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetEmailsOnPushServiceOptions represents the available SetEmailsOnPushService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-emails-on-push\ntype SetEmailsOnPushServiceOptions struct {\n\tRecipients             *string `url:\"recipients,omitempty\" json:\"recipients,omitempty\"`\n\tDisableDiffs           *bool   `url:\"disable_diffs,omitempty\" json:\"disable_diffs,omitempty\"`\n\tSendFromCommitterEmail *bool   `url:\"send_from_committer_email,omitempty\" json:\"send_from_committer_email,omitempty\"`\n\tPushEvents             *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tTagPushEvents          *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tBranchesToBeNotified   *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n}\n\n// SetEmailsOnPushService sets Emails on Push service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-emails-on-push\nfunc (s *ServicesService) SetEmailsOnPushService(pid interface{}, opt *SetEmailsOnPushServiceOptions, options ...RequestOptionFunc) (*EmailsOnPushService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/emails-on-push\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(EmailsOnPushService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteEmailsOnPushService deletes Emails on Push service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-emails-on-push\nfunc (s *ServicesService) DeleteEmailsOnPushService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/emails-on-push\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ExternalWikiService represents External Wiki service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#external-wiki\ntype ExternalWikiService struct {\n\tService\n\tProperties *ExternalWikiServiceProperties `json:\"properties\"`\n}\n\n// ExternalWikiServiceProperties represents External Wiki specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#external-wiki\ntype ExternalWikiServiceProperties struct {\n\tExternalWikiURL string `json:\"external_wiki_url\"`\n}\n\n// GetExternalWikiService gets External Wiki service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-external-wiki-settings\nfunc (s *ServicesService) GetExternalWikiService(pid interface{}, options ...RequestOptionFunc) (*ExternalWikiService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/external-wiki\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(ExternalWikiService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetExternalWikiServiceOptions represents the available SetExternalWikiService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-an-external-wiki\ntype SetExternalWikiServiceOptions struct {\n\tExternalWikiURL *string `url:\"external_wiki_url,omitempty\" json:\"external_wiki_url,omitempty\"`\n}\n\n// SetExternalWikiService sets External Wiki service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-an-external-wiki\nfunc (s *ServicesService) SetExternalWikiService(pid interface{}, opt *SetExternalWikiServiceOptions, options ...RequestOptionFunc) (*ExternalWikiService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/external-wiki\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(ExternalWikiService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteExternalWikiService deletes External Wiki service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-an-external-wiki\nfunc (s *ServicesService) DeleteExternalWikiService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/external-wiki\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GithubService represents Github service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#github\ntype GithubService struct {\n\tService\n\tProperties *GithubServiceProperties `json:\"properties\"`\n}\n\n// GithubServiceProperties represents Github specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#github\ntype GithubServiceProperties struct {\n\tRepositoryURL string `json:\"repository_url\"`\n\tStaticContext bool   `json:\"static_context\"`\n}\n\n// GetGithubService gets Github service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-github-settings\nfunc (s *ServicesService) GetGithubService(pid interface{}, options ...RequestOptionFunc) (*GithubService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/github\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(GithubService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetGithubServiceOptions represents the available SetGithubService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-github\ntype SetGithubServiceOptions struct {\n\tToken         *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tRepositoryURL *string `url:\"repository_url,omitempty\" json:\"repository_url,omitempty\"`\n\tStaticContext *bool   `url:\"static_context,omitempty\" json:\"static_context,omitempty\"`\n}\n\n// SetGithubService sets Github service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-github\nfunc (s *ServicesService) SetGithubService(pid interface{}, opt *SetGithubServiceOptions, options ...RequestOptionFunc) (*GithubService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/github\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(GithubService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteGithubService deletes Github service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-github\nfunc (s *ServicesService) DeleteGithubService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/github\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// HarborService represents the Harbor service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#harbor\ntype HarborService struct {\n\tService\n\tProperties *HarborServiceProperties `json:\"properties\"`\n}\n\n// HarborServiceProperties represents Harbor specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#harbor\ntype HarborServiceProperties struct {\n\tURL                  string `json:\"url\"`\n\tProjectName          string `json:\"project_name\"`\n\tUsername             string `json:\"username\"`\n\tPassword             string `json:\"password\"`\n\tUseInheritedSettings bool   `json:\"use_inherited_settings\"`\n}\n\n// GetHarborService gets Harbor service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-harbor-settings\nfunc (s *ServicesService) GetHarborService(pid interface{}, options ...RequestOptionFunc) (*HarborService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/harbor\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(HarborService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetHarborServiceOptions represents the available SetHarborService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-harbor\ntype SetHarborServiceOptions struct {\n\tURL                  *string `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tProjectName          *string `url:\"project_name,omitempty\" json:\"project_name,omitempty\"`\n\tUsername             *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tPassword             *string `url:\"password,omitempty\" json:\"password,omitempty\"`\n\tUseInheritedSettings *bool   `url:\"use_inherited_settings,omitempty\" json:\"use_inherited_settings,omitempty\"`\n}\n\n// SetHarborService sets Harbor service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-harbor\nfunc (s *ServicesService) SetHarborService(pid interface{}, opt *SetHarborServiceOptions, options ...RequestOptionFunc) (*HarborService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/harbor\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(HarborService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteHarborService deletes Harbor service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-harbor\nfunc (s *ServicesService) DeleteHarborService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/harbor\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SlackApplication represents GitLab for slack application settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#gitlab-for-slack-app\ntype SlackApplication struct {\n\tService\n\tProperties *SlackApplicationProperties `json:\"properties\"`\n}\n\n// SlackApplicationProperties represents GitLab for slack application specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#gitlab-for-slack-app\ntype SlackApplicationProperties struct {\n\tChannel                    string `json:\"channel\"`\n\tNotifyOnlyBrokenPipelines  bool   `json:\"notify_only_broken_pipelines\"`\n\tBranchesToBeNotified       string `json:\"branches_to_be_notified\"`\n\tLabelsToBeNotified         string `json:\"labels_to_be_notified\"`\n\tLabelsToBeNotifiedBehavior string `json:\"labels_to_be_notified_behavior\"`\n\tPushChannel                string `json:\"push_channel\"`\n\tIssueChannel               string `json:\"issue_channel\"`\n\tConfidentialIssueChannel   string `json:\"confidential_issue_channel\"`\n\tMergeRequestChannel        string `json:\"merge_request_channel\"`\n\tNoteChannel                string `json:\"note_channel\"`\n\tConfidentialNoteChannel    string `json:\"confidential_note_channel\"`\n\tTagPushChannel             string `json:\"tag_push_channel\"`\n\tPipelineChannel            string `json:\"pipeline_channel\"`\n\tWikiPageChannel            string `json:\"wiki_page_channel\"`\n\tDeploymentChannel          string `json:\"deployment_channel\"`\n\tIncidentChannel            string `json:\"incident_channel\"`\n\tVulnerabilityChannel       string `json:\"vulnerability_channel\"`\n\tAlertChannel               string `json:\"alert_channel\"`\n\n\t// Deprecated: This parameter has been replaced with BranchesToBeNotified.\n\tNotifyOnlyDefaultBranch bool `json:\"notify_only_default_branch\"`\n}\n\n// GetSlackApplication gets the GitLab for Slack app integration settings for a\n// project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-gitlab-for-slack-app-settings\nfunc (s *ServicesService) GetSlackApplication(pid interface{}, options ...RequestOptionFunc) (*SlackApplication, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/gitlab-slack-application\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(SlackApplication)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetSlackApplicationOptions represents the available SetSlackApplication()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-gitlab-for-slack-app\ntype SetSlackApplicationOptions struct {\n\tChannel                    *string `url:\"channel,omitempty\" json:\"channel,omitempty\"`\n\tNotifyOnlyBrokenPipelines  *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tBranchesToBeNotified       *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tAlertEvents                *bool   `url:\"alert_events,omitempty\" json:\"alert_events,omitempty\"`\n\tIssuesEvents               *bool   `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tConfidentialIssuesEvents   *bool   `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tMergeRequestsEvents        *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tNoteEvents                 *bool   `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tConfidentialNoteEvents     *bool   `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tDeploymentEvents           *bool   `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tIncidentsEvents            *bool   `url:\"incidents_events,omitempty\" json:\"incidents_events,omitempty\"`\n\tPipelineEvents             *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tPushEvents                 *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tTagPushEvents              *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tVulnerabilityEvents        *bool   `url:\"vulnerability_events,omitempty\" json:\"vulnerability_events,omitempty\"`\n\tWikiPageEvents             *bool   `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n\tLabelsToBeNotified         *string `url:\"labels_to_be_notified,omitempty\" json:\"labels_to_be_notified,omitempty\"`\n\tLabelsToBeNotifiedBehavior *string `url:\"labels_to_be_notified_behavior,omitempty\" json:\"labels_to_be_notified_behavior,omitempty\"`\n\tPushChannel                *string `url:\"push_channel,omitempty\" json:\"push_channel,omitempty\"`\n\tIssueChannel               *string `url:\"issue_channel,omitempty\" json:\"issue_channel,omitempty\"`\n\tConfidentialIssueChannel   *string `url:\"confidential_issue_channel,omitempty\" json:\"confidential_issue_channel,omitempty\"`\n\tMergeRequestChannel        *string `url:\"merge_request_channel,omitempty\" json:\"merge_request_channel,omitempty\"`\n\tNoteChannel                *string `url:\"note_channel,omitempty\" json:\"note_channel,omitempty\"`\n\tConfidentialNoteChannel    *string `url:\"confidential_note_channel,omitempty\" json:\"confidential_note_channel,omitempty\"`\n\tTagPushChannel             *string `url:\"tag_push_channel,omitempty\" json:\"tag_push_channel,omitempty\"`\n\tPipelineChannel            *string `url:\"pipeline_channel,omitempty\" json:\"pipeline_channel,omitempty\"`\n\tWikiPageChannel            *string `url:\"wiki_page_channel,omitempty\" json:\"wiki_page_channel,omitempty\"`\n\tDeploymentChannel          *string `url:\"deployment_channel,omitempty\" json:\"deployment_channel,omitempty\"`\n\tIncidentChannel            *string `url:\"incident_channel,omitempty\" json:\"incident_channel,omitempty\"`\n\tVulnerabilityChannel       *string `url:\"vulnerability_channel,omitempty\" json:\"vulnerability_channel,omitempty\"`\n\tAlertChannel               *string `url:\"alert_channel,omitempty\" json:\"alert_channel,omitempty\"`\n\tUseInheritedSettings       *bool   `url:\"use_inherited_settings,omitempty\" json:\"use_inherited_settings,omitempty\"`\n\n\t// Deprecated: This parameter has been replaced with BranchesToBeNotified.\n\tNotifyOnlyDefaultBranch *bool `url:\"notify_only_default_branch,omitempty\" json:\"notify_only_default_branch,omitempty\"`\n}\n\n// SetSlackApplication update the GitLab for Slack app integration for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-gitlab-for-slack-app\nfunc (s *ServicesService) SetSlackApplication(pid interface{}, opt *SetSlackApplicationOptions, options ...RequestOptionFunc) (*SlackApplication, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/gitlab-slack-application\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(SlackApplication)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DisableSlackApplication disable the GitLab for Slack app integration for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-gitlab-for-slack-app\nfunc (s *ServicesService) DisableSlackApplication(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/gitlab-slack-application\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SetGitLabCIServiceOptions represents the available SetGitLabCIService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-gitlab-ci-service\ntype SetGitLabCIServiceOptions struct {\n\tToken      *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tProjectURL *string `url:\"project_url,omitempty\" json:\"project_url,omitempty\"`\n}\n\n// SetGitLabCIService sets GitLab CI service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-gitlab-ci-service\nfunc (s *ServicesService) SetGitLabCIService(pid interface{}, opt *SetGitLabCIServiceOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/gitlab-ci\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteGitLabCIService deletes GitLab CI service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-gitlab-ci-service\nfunc (s *ServicesService) DeleteGitLabCIService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/gitlab-ci\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SetHipChatServiceOptions represents the available SetHipChatService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-hipchat-service\ntype SetHipChatServiceOptions struct {\n\tToken *string `url:\"token,omitempty\" json:\"token,omitempty\" `\n\tRoom  *string `url:\"room,omitempty\" json:\"room,omitempty\"`\n}\n\n// SetHipChatService sets HipChat service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-hipchat-service\nfunc (s *ServicesService) SetHipChatService(pid interface{}, opt *SetHipChatServiceOptions, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/hipchat\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteHipChatService deletes HipChat service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-hipchat-service\nfunc (s *ServicesService) DeleteHipChatService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/hipchat\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// JenkinsCIService represents Jenkins CI service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#jenkins\ntype JenkinsCIService struct {\n\tService\n\tProperties *JenkinsCIServiceProperties `json:\"properties\"`\n}\n\n// JenkinsCIServiceProperties represents Jenkins CI specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#jenkins\ntype JenkinsCIServiceProperties struct {\n\tURL                   string `json:\"jenkins_url\"`\n\tEnableSSLVerification bool   `json:\"enable_ssl_verification\"`\n\tProjectName           string `json:\"project_name\"`\n\tUsername              string `json:\"username\"`\n}\n\n// GetJenkinsCIService gets Jenkins CI service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-jenkins-settings\nfunc (s *ServicesService) GetJenkinsCIService(pid interface{}, options ...RequestOptionFunc) (*JenkinsCIService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/jenkins\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(JenkinsCIService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetJenkinsCIServiceOptions represents the available SetJenkinsCIService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#jenkins\ntype SetJenkinsCIServiceOptions struct {\n\tURL                   *string `url:\"jenkins_url,omitempty\" json:\"jenkins_url,omitempty\"`\n\tEnableSSLVerification *bool   `url:\"enable_ssl_verification,omitempty\" json:\"enable_ssl_verification,omitempty\"`\n\tProjectName           *string `url:\"project_name,omitempty\" json:\"project_name,omitempty\"`\n\tUsername              *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tPassword              *string `url:\"password,omitempty\" json:\"password,omitempty\"`\n\tPushEvents            *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tMergeRequestsEvents   *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents         *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n}\n\n// SetJenkinsCIService sets Jenkins service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-jenkins\nfunc (s *ServicesService) SetJenkinsCIService(pid interface{}, opt *SetJenkinsCIServiceOptions, options ...RequestOptionFunc) (*JenkinsCIService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/jenkins\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(JenkinsCIService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteJenkinsCIService deletes Jenkins CI service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-jenkins\nfunc (s *ServicesService) DeleteJenkinsCIService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/jenkins\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// JiraService represents Jira service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#jira\ntype JiraService struct {\n\tService\n\tProperties *JiraServiceProperties `json:\"properties\"`\n}\n\n// JiraServiceProperties represents Jira specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#jira\ntype JiraServiceProperties struct {\n\tURL                          string   `json:\"url\"`\n\tAPIURL                       string   `json:\"api_url\"`\n\tUsername                     string   `json:\"username\" `\n\tPassword                     string   `json:\"password\" `\n\tActive                       bool     `json:\"active\"`\n\tJiraAuthType                 int      `json:\"jira_auth_type\"`\n\tJiraIssuePrefix              string   `json:\"jira_issue_prefix\"`\n\tJiraIssueRegex               string   `json:\"jira_issue_regex\"`\n\tJiraIssueTransitionAutomatic bool     `json:\"jira_issue_transition_automatic\"`\n\tJiraIssueTransitionID        string   `json:\"jira_issue_transition_id\"`\n\tCommitEvents                 bool     `json:\"commit_events\"`\n\tMergeRequestsEvents          bool     `json:\"merge_requests_events\"`\n\tCommentOnEventEnabled        bool     `json:\"comment_on_event_enabled\"`\n\tIssuesEnabled                bool     `json:\"issues_enabled\"`\n\tProjectKeys                  []string `json:\"project_keys\" `\n\tUseInheritedSettings         bool     `json:\"use_inherited_settings\"`\n\n\t// Deprecated: This parameter was removed in GitLab 17.0\n\tProjectKey string `json:\"project_key\" `\n}\n\n// UnmarshalJSON decodes the Jira Service Properties.\n//\n// This allows support of JiraIssueTransitionID for both type string (>11.9) and float64 (<11.9)\nfunc (p *JiraServiceProperties) UnmarshalJSON(b []byte) error {\n\ttype Alias JiraServiceProperties\n\traw := struct {\n\t\t*Alias\n\t\tJiraIssueTransitionID interface{} `json:\"jira_issue_transition_id\"`\n\t}{\n\t\tAlias: (*Alias)(p),\n\t}\n\n\tif err := json.Unmarshal(b, &raw); err != nil {\n\t\treturn err\n\t}\n\n\tswitch id := raw.JiraIssueTransitionID.(type) {\n\tcase nil:\n\t\t// No action needed.\n\tcase string:\n\t\tp.JiraIssueTransitionID = id\n\tcase float64:\n\t\tp.JiraIssueTransitionID = strconv.Itoa(int(id))\n\tdefault:\n\t\treturn fmt.Errorf(\"failed to unmarshal JiraTransitionID of type: %T\", id)\n\t}\n\n\treturn nil\n}\n\n// GetJiraService gets Jira service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-jira-service-settings\nfunc (s *ServicesService) GetJiraService(pid interface{}, options ...RequestOptionFunc) (*JiraService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/jira\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(JiraService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetJiraServiceOptions represents the available SetJiraService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-jira-service\ntype SetJiraServiceOptions struct {\n\tURL                          *string   `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tAPIURL                       *string   `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tUsername                     *string   `url:\"username,omitempty\" json:\"username,omitempty\" `\n\tPassword                     *string   `url:\"password,omitempty\" json:\"password,omitempty\" `\n\tActive                       *bool     `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tJiraAuthType                 *int      `url:\"jira_auth_type,omitempty\" json:\"jira_auth_type,omitempty\"`\n\tJiraIssuePrefix              *string   `url:\"jira_issue_prefix,omitempty\" json:\"jira_issue_prefix,omitempty\"`\n\tJiraIssueRegex               *string   `url:\"jira_issue_regex,omitempty\" json:\"jira_issue_regex,omitempty\"`\n\tJiraIssueTransitionAutomatic *bool     `url:\"jira_issue_transition_automatic,omitempty\" json:\"jira_issue_transition_automatic,omitempty\"`\n\tJiraIssueTransitionID        *string   `url:\"jira_issue_transition_id,omitempty\" json:\"jira_issue_transition_id,omitempty\"`\n\tCommitEvents                 *bool     `url:\"commit_events,omitempty\" json:\"commit_events,omitempty\"`\n\tMergeRequestsEvents          *bool     `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tCommentOnEventEnabled        *bool     `url:\"comment_on_event_enabled,omitempty\" json:\"comment_on_event_enabled,omitempty\"`\n\tIssuesEnabled                *bool     `url:\"issues_enabled,omitempty\" json:\"issues_enabled,omitempty\"`\n\tProjectKeys                  *[]string `url:\"project_keys,comma,omitempty\" json:\"project_keys,omitempty\" `\n\tUseInheritedSettings         *bool     `url:\"use_inherited_settings,omitempty\" json:\"use_inherited_settings,omitempty\"`\n\n\t// Deprecated: This parameter was removed in GitLab 17.0\n\tProjectKey *string `url:\"project_key,omitempty\" json:\"project_key,omitempty\" `\n}\n\n// SetJiraService sets Jira service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-jira-service\nfunc (s *ServicesService) SetJiraService(pid interface{}, opt *SetJiraServiceOptions, options ...RequestOptionFunc) (*JiraService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/jira\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(JiraService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteJiraService deletes Jira service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-jira-service\nfunc (s *ServicesService) DeleteJiraService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/jira\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// MattermostService represents Mattermost service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#mattermost-notifications\ntype MattermostService struct {\n\tService\n\tProperties *MattermostServiceProperties `json:\"properties\"`\n}\n\n// MattermostServiceProperties represents Mattermost specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#mattermost-notifications\ntype MattermostServiceProperties struct {\n\tWebHook                   string    `json:\"webhook\"`\n\tUsername                  string    `json:\"username\"`\n\tChannel                   string    `json:\"channel\"`\n\tNotifyOnlyBrokenPipelines BoolValue `json:\"notify_only_broken_pipelines\"`\n\tBranchesToBeNotified      string    `json:\"branches_to_be_notified\"`\n\tConfidentialIssueChannel  string    `json:\"confidential_issue_channel\"`\n\tConfidentialNoteChannel   string    `json:\"confidential_note_channel\"`\n\tIssueChannel              string    `json:\"issue_channel\"`\n\tMergeRequestChannel       string    `json:\"merge_request_channel\"`\n\tNoteChannel               string    `json:\"note_channel\"`\n\tTagPushChannel            string    `json:\"tag_push_channel\"`\n\tPipelineChannel           string    `json:\"pipeline_channel\"`\n\tPushChannel               string    `json:\"push_channel\"`\n\tVulnerabilityChannel      string    `json:\"vulnerability_channel\"`\n\tWikiPageChannel           string    `json:\"wiki_page_channel\"`\n}\n\n// GetMattermostService gets Mattermost service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-slack-service-settings\nfunc (s *ServicesService) GetMattermostService(pid interface{}, options ...RequestOptionFunc) (*MattermostService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/mattermost\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(MattermostService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetMattermostServiceOptions represents the available SetMattermostService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-mattermost-notifications-service\ntype SetMattermostServiceOptions struct {\n\tWebHook                   *string `url:\"webhook,omitempty\" json:\"webhook,omitempty\"`\n\tUsername                  *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tChannel                   *string `url:\"channel,omitempty\" json:\"channel,omitempty\"`\n\tNotifyOnlyBrokenPipelines *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tBranchesToBeNotified      *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tPushEvents                *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tIssuesEvents              *bool   `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tConfidentialIssuesEvents  *bool   `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tMergeRequestsEvents       *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents             *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tNoteEvents                *bool   `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tConfidentialNoteChannel   *string `url:\"confidential_note_channel,omitempty\" json:\"confidential_note_channel,omitempty\"`\n\tPipelineEvents            *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tWikiPageEvents            *bool   `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n\tPushChannel               *string `url:\"push_channel,omitempty\" json:\"push_channel,omitempty\"`\n\tIssueChannel              *string `url:\"issue_channel,omitempty\" json:\"issue_channel,omitempty\"`\n\tConfidentialIssueChannel  *string `url:\"confidential_issue_channel,omitempty\" json:\"confidential_issue_channel,omitempty\"`\n\tMergeRequestChannel       *string `url:\"merge_request_channel,omitempty\" json:\"merge_request_channel,omitempty\"`\n\tNoteChannel               *string `url:\"note_channel,omitempty\" json:\"note_channel,omitempty\"`\n\tConfidentialNoteEvents    *bool   `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tTagPushChannel            *string `url:\"tag_push_channel,omitempty\" json:\"tag_push_channel,omitempty\"`\n\tPipelineChannel           *string `url:\"pipeline_channel,omitempty\" json:\"pipeline_channel,omitempty\"`\n\tWikiPageChannel           *string `url:\"wiki_page_channel,omitempty\" json:\"wiki_page_channel,omitempty\"`\n}\n\n// SetMattermostService sets Mattermost service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-mattermost-notifications-service\nfunc (s *ServicesService) SetMattermostService(pid interface{}, opt *SetMattermostServiceOptions, options ...RequestOptionFunc) (*MattermostService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/mattermost\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(MattermostService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteMattermostService deletes Mattermost service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-mattermost-notifications-service\nfunc (s *ServicesService) DeleteMattermostService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/mattermost\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// MattermostSlashCommandsService represents Mattermost slash commands settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#mattermost-slash-commands\ntype MattermostSlashCommandsService struct {\n\tService\n\tProperties *MattermostSlashCommandsProperties `json:\"properties\"`\n}\n\n// MattermostSlashCommandsProperties represents Mattermost slash commands specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#mattermost-slash-commands\ntype MattermostSlashCommandsProperties struct {\n\tToken    string `json:\"token\"`\n\tUsername string `json:\"username,omitempty\"`\n}\n\n// GetMattermostSlashCommandsService gets Slack Mattermost commands service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-mattermost-slash-command-integration-settings\nfunc (s *ServicesService) GetMattermostSlashCommandsService(pid interface{}, options ...RequestOptionFunc) (*MattermostSlashCommandsService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/mattermost-slash-commands\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(MattermostSlashCommandsService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetMattermostSlashCommandsServiceOptions represents the available SetSlackSlashCommandsService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-mattermost-slash-command-integration-settings\ntype SetMattermostSlashCommandsServiceOptions struct {\n\tToken    *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tUsername *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n}\n\n// SetMattermostSlashCommandsService sets Mattermost slash commands service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-mattermost-slash-command-integration\nfunc (s *ServicesService) SetMattermostSlashCommandsService(pid interface{}, opt *SetMattermostSlashCommandsServiceOptions, options ...RequestOptionFunc) (*MattermostSlashCommandsService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/mattermost-slash-commands\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(MattermostSlashCommandsService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteMattermostSlashCommandsService deletes Mattermost slash commands service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-mattermost-slash-command-integration\nfunc (s *ServicesService) DeleteMattermostSlashCommandsService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/mattermost-slash-commands\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// MicrosoftTeamsService represents Microsoft Teams service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#microsoft-teams\ntype MicrosoftTeamsService struct {\n\tService\n\tProperties *MicrosoftTeamsServiceProperties `json:\"properties\"`\n}\n\n// MicrosoftTeamsServiceProperties represents Microsoft Teams specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#microsoft-teams\ntype MicrosoftTeamsServiceProperties struct {\n\tWebHook                   string    `json:\"webhook\"`\n\tNotifyOnlyBrokenPipelines BoolValue `json:\"notify_only_broken_pipelines\"`\n\tBranchesToBeNotified      string    `json:\"branches_to_be_notified\"`\n\tIssuesEvents              BoolValue `json:\"issues_events\"`\n\tConfidentialIssuesEvents  BoolValue `json:\"confidential_issues_events\"`\n\tMergeRequestsEvents       BoolValue `json:\"merge_requests_events\"`\n\tTagPushEvents             BoolValue `json:\"tag_push_events\"`\n\tNoteEvents                BoolValue `json:\"note_events\"`\n\tConfidentialNoteEvents    BoolValue `json:\"confidential_note_events\"`\n\tPipelineEvents            BoolValue `json:\"pipeline_events\"`\n\tWikiPageEvents            BoolValue `json:\"wiki_page_events\"`\n}\n\n// GetMicrosoftTeamsService gets MicrosoftTeams service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-microsoft-teams-service-settings\nfunc (s *ServicesService) GetMicrosoftTeamsService(pid interface{}, options ...RequestOptionFunc) (*MicrosoftTeamsService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/microsoft-teams\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(MicrosoftTeamsService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetMicrosoftTeamsServiceOptions represents the available SetMicrosoftTeamsService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#create-edit-microsoft-teams-service\ntype SetMicrosoftTeamsServiceOptions struct {\n\tWebHook                   *string `url:\"webhook,omitempty\" json:\"webhook,omitempty\"`\n\tNotifyOnlyBrokenPipelines *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tBranchesToBeNotified      *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tPushEvents                *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tIssuesEvents              *bool   `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tConfidentialIssuesEvents  *bool   `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tMergeRequestsEvents       *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents             *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tNoteEvents                *bool   `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tConfidentialNoteEvents    *bool   `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tPipelineEvents            *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tWikiPageEvents            *bool   `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n}\n\n// SetMicrosoftTeamsService sets Microsoft Teams service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#create-edit-microsoft-teams-service\nfunc (s *ServicesService) SetMicrosoftTeamsService(pid interface{}, opt *SetMicrosoftTeamsServiceOptions, options ...RequestOptionFunc) (*MicrosoftTeamsService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/microsoft-teams\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(MicrosoftTeamsService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteMicrosoftTeamsService deletes Microsoft Teams service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-microsoft-teams-service\nfunc (s *ServicesService) DeleteMicrosoftTeamsService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/microsoft-teams\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// PipelinesEmailService represents Pipelines Email service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails\ntype PipelinesEmailService struct {\n\tService\n\tProperties *PipelinesEmailProperties `json:\"properties\"`\n}\n\n// PipelinesEmailProperties represents PipelinesEmail specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails\ntype PipelinesEmailProperties struct {\n\tRecipients                string    `json:\"recipients\"`\n\tNotifyOnlyBrokenPipelines BoolValue `json:\"notify_only_broken_pipelines\"`\n\tNotifyOnlyDefaultBranch   BoolValue `json:\"notify_only_default_branch\"`\n\tBranchesToBeNotified      string    `json:\"branches_to_be_notified\"`\n}\n\n// GetPipelinesEmailService gets Pipelines Email service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-pipeline-emails-service-settings\nfunc (s *ServicesService) GetPipelinesEmailService(pid interface{}, options ...RequestOptionFunc) (*PipelinesEmailService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/pipelines-email\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(PipelinesEmailService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetPipelinesEmailServiceOptions represents the available\n// SetPipelinesEmailService() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails\ntype SetPipelinesEmailServiceOptions struct {\n\tRecipients                *string `url:\"recipients,omitempty\" json:\"recipients,omitempty\"`\n\tNotifyOnlyBrokenPipelines *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tNotifyOnlyDefaultBranch   *bool   `url:\"notify_only_default_branch,omitempty\" json:\"notify_only_default_branch,omitempty\"`\n\tAddPusher                 *bool   `url:\"add_pusher,omitempty\" json:\"add_pusher,omitempty\"`\n\tBranchesToBeNotified      *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tPipelineEvents            *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n}\n\n// SetPipelinesEmailService sets Pipelines Email service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#pipeline-emails\nfunc (s *ServicesService) SetPipelinesEmailService(pid interface{}, opt *SetPipelinesEmailServiceOptions, options ...RequestOptionFunc) (*PipelinesEmailService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/pipelines-email\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(PipelinesEmailService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeletePipelinesEmailService deletes Pipelines Email service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-pipeline-emails-service\nfunc (s *ServicesService) DeletePipelinesEmailService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/pipelines-email\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// PrometheusService represents Prometheus service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#prometheus\ntype PrometheusService struct {\n\tService\n\tProperties *PrometheusServiceProperties `json:\"properties\"`\n}\n\n// PrometheusServiceProperties represents Prometheus specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#prometheus\ntype PrometheusServiceProperties struct {\n\tAPIURL                      string `json:\"api_url\"`\n\tGoogleIAPAudienceClientID   string `json:\"google_iap_audience_client_id\"`\n\tGoogleIAPServiceAccountJSON string `json:\"google_iap_service_account_json\"`\n}\n\n// GetPrometheusService gets Prometheus service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-prometheus-service-settings\nfunc (s *ServicesService) GetPrometheusService(pid interface{}, options ...RequestOptionFunc) (*PrometheusService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/prometheus\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(PrometheusService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetPrometheusServiceOptions represents the available SetPrometheusService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-prometheus-service\ntype SetPrometheusServiceOptions struct {\n\tAPIURL                      *string `url:\"api_url,omitempty\" json:\"api_url,omitempty\"`\n\tGoogleIAPAudienceClientID   *string `url:\"google_iap_audience_client_id,omitempty\" json:\"google_iap_audience_client_id,omitempty\"`\n\tGoogleIAPServiceAccountJSON *string `url:\"google_iap_service_account_json,omitempty\" json:\"google_iap_service_account_json,omitempty\"`\n}\n\n// SetPrometheusService sets Prometheus service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-prometheus-service\nfunc (s *ServicesService) SetPrometheusService(pid interface{}, opt *SetPrometheusServiceOptions, options ...RequestOptionFunc) (*PrometheusService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/prometheus\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(PrometheusService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeletePrometheusService deletes Prometheus service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-prometheus-service\nfunc (s *ServicesService) DeletePrometheusService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/prometheus\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// RedmineService represents the Redmine service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#redmine\ntype RedmineService struct {\n\tService\n\tProperties *RedmineServiceProperties `json:\"properties\"`\n}\n\n// RedmineServiceProperties represents Redmine specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#redmine\ntype RedmineServiceProperties struct {\n\tNewIssueURL          string    `json:\"new_issue_url\"`\n\tProjectURL           string    `json:\"project_url\"`\n\tIssuesURL            string    `json:\"issues_url\"`\n\tUseInheritedSettings BoolValue `json:\"use_inherited_settings\"`\n}\n\n// GetRedmineService gets Redmine service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-redmine-settings\nfunc (s *ServicesService) GetRedmineService(pid interface{}, options ...RequestOptionFunc) (*RedmineService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/redmine\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(RedmineService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetRedmineServiceOptions represents the available SetRedmineService().\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-redmine\ntype SetRedmineServiceOptions struct {\n\tNewIssueURL          *string `url:\"new_issue_url,omitempty\" json:\"new_issue_url,omitempty\"`\n\tProjectURL           *string `url:\"project_url,omitempty\" json:\"project_url,omitempty\"`\n\tIssuesURL            *string `url:\"issues_url,omitempty\" json:\"issues_url,omitempty\"`\n\tUseInheritedSettings *bool   `url:\"use_inherited_settings,omitempty\" json:\"use_inherited_settings,omitempty\"`\n}\n\n// SetRedmineService sets Redmine service for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-redmine\nfunc (s *ServicesService) SetRedmineService(pid interface{}, opt *SetRedmineServiceOptions, options ...RequestOptionFunc) (*RedmineService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/redmine\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(RedmineService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteRedmineService deletes Redmine service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-redmine\nfunc (s *ServicesService) DeleteRedmineService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/integrations/redmine\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SlackService represents Slack service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#slack\ntype SlackService struct {\n\tService\n\tProperties *SlackServiceProperties `json:\"properties\"`\n}\n\n// SlackServiceProperties represents Slack specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#slack\ntype SlackServiceProperties struct {\n\tWebHook                   string    `json:\"webhook\"`\n\tUsername                  string    `json:\"username\"`\n\tChannel                   string    `json:\"channel\"`\n\tNotifyOnlyBrokenPipelines BoolValue `json:\"notify_only_broken_pipelines\"`\n\tNotifyOnlyDefaultBranch   BoolValue `json:\"notify_only_default_branch\"`\n\tBranchesToBeNotified      string    `json:\"branches_to_be_notified\"`\n\tAlertChannel              string    `json:\"alert_channel\"`\n\tConfidentialIssueChannel  string    `json:\"confidential_issue_channel\"`\n\tConfidentialNoteChannel   string    `json:\"confidential_note_channel\"`\n\tDeploymentChannel         string    `json:\"deployment_channel\"`\n\tIssueChannel              string    `json:\"issue_channel\"`\n\tMergeRequestChannel       string    `json:\"merge_request_channel\"`\n\tNoteChannel               string    `json:\"note_channel\"`\n\tTagPushChannel            string    `json:\"tag_push_channel\"`\n\tPipelineChannel           string    `json:\"pipeline_channel\"`\n\tPushChannel               string    `json:\"push_channel\"`\n\tVulnerabilityChannel      string    `json:\"vulnerability_channel\"`\n\tWikiPageChannel           string    `json:\"wiki_page_channel\"`\n}\n\n// GetSlackService gets Slack service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-slack-service-settings\nfunc (s *ServicesService) GetSlackService(pid interface{}, options ...RequestOptionFunc) (*SlackService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/slack\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(SlackService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetSlackServiceOptions represents the available SetSlackService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-slack-service\ntype SetSlackServiceOptions struct {\n\tWebHook                   *string `url:\"webhook,omitempty\" json:\"webhook,omitempty\"`\n\tUsername                  *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tChannel                   *string `url:\"channel,omitempty\" json:\"channel,omitempty\"`\n\tNotifyOnlyBrokenPipelines *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tNotifyOnlyDefaultBranch   *bool   `url:\"notify_only_default_branch,omitempty\" json:\"notify_only_default_branch,omitempty\"`\n\tBranchesToBeNotified      *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tAlertChannel              *string `url:\"alert_channel,omitempty\" json:\"alert_channel,omitempty\"`\n\tAlertEvents               *bool   `url:\"alert_events,omitempty\" json:\"alert_events,omitempty\"`\n\tConfidentialIssueChannel  *string `url:\"confidential_issue_channel,omitempty\" json:\"confidential_issue_channel,omitempty\"`\n\tConfidentialIssuesEvents  *bool   `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tConfidentialNoteChannel   *string `url:\"confidential_note_channel,omitempty\" json:\"confidential_note_channel,omitempty\"`\n\tConfidentialNoteEvents    *bool   `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tDeploymentChannel         *string `url:\"deployment_channel,omitempty\" json:\"deployment_channel,omitempty\"`\n\tDeploymentEvents          *bool   `url:\"deployment_events,omitempty\" json:\"deployment_events,omitempty\"`\n\tIssueChannel              *string `url:\"issue_channel,omitempty\" json:\"issue_channel,omitempty\"`\n\tIssuesEvents              *bool   `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tMergeRequestChannel       *string `url:\"merge_request_channel,omitempty\" json:\"merge_request_channel,omitempty\"`\n\tMergeRequestsEvents       *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tNoteChannel               *string `url:\"note_channel,omitempty\" json:\"note_channel,omitempty\"`\n\tNoteEvents                *bool   `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tPipelineChannel           *string `url:\"pipeline_channel,omitempty\" json:\"pipeline_channel,omitempty\"`\n\tPipelineEvents            *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tPushChannel               *string `url:\"push_channel,omitempty\" json:\"push_channel,omitempty\"`\n\tPushEvents                *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tTagPushChannel            *string `url:\"tag_push_channel,omitempty\" json:\"tag_push_channel,omitempty\"`\n\tTagPushEvents             *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tWikiPageChannel           *string `url:\"wiki_page_channel,omitempty\" json:\"wiki_page_channel,omitempty\"`\n\tWikiPageEvents            *bool   `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n}\n\n// SetSlackService sets Slack service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#edit-slack-service\nfunc (s *ServicesService) SetSlackService(pid interface{}, opt *SetSlackServiceOptions, options ...RequestOptionFunc) (*SlackService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/slack\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(SlackService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteSlackService deletes Slack service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-slack-service\nfunc (s *ServicesService) DeleteSlackService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/slack\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// SlackSlashCommandsService represents Slack slash commands settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#slack-slash-commands\ntype SlackSlashCommandsService struct {\n\tService\n\tProperties *SlackSlashCommandsProperties `json:\"properties\"`\n}\n\n// SlackSlashCommandsProperties represents Slack slash commands specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#slack-slash-commands\ntype SlackSlashCommandsProperties struct {\n\tToken string `json:\"token\"`\n}\n\n// GetSlackSlashCommandsService gets Slack slash commands service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-slack-slash-command-integration-settings\nfunc (s *ServicesService) GetSlackSlashCommandsService(pid interface{}, options ...RequestOptionFunc) (*SlackSlashCommandsService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/slack-slash-commands\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(SlackSlashCommandsService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetSlackSlashCommandsServiceOptions represents the available SetSlackSlashCommandsService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-slack-slash-command-service\ntype SetSlackSlashCommandsServiceOptions struct {\n\tToken *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n}\n\n// SetSlackSlashCommandsService sets Slack slash commands service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/13.12/ee/api/integrations.html#createedit-slack-slash-command-service\nfunc (s *ServicesService) SetSlackSlashCommandsService(pid interface{}, opt *SetSlackSlashCommandsServiceOptions, options ...RequestOptionFunc) (*SlackSlashCommandsService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/slack-slash-commands\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(SlackSlashCommandsService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteSlackSlashCommandsService deletes Slack slash commands service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/13.12/ee/api/integrations.html#delete-slack-slash-command-service\nfunc (s *ServicesService) DeleteSlackSlashCommandsService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/slack-slash-commands\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// TelegramService represents Telegram service settings.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#telegram\ntype TelegramService struct {\n\tService\n\tProperties *TelegramServiceProperties `json:\"properties\"`\n}\n\n// TelegramServiceProperties represents Telegram specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-telegram\ntype TelegramServiceProperties struct {\n\tRoom                      string `json:\"room\"`\n\tNotifyOnlyBrokenPipelines bool   `json:\"notify_only_broken_pipelines\"`\n\tBranchesToBeNotified      string `json:\"branches_to_be_notified\"`\n}\n\n// GetTelegramService gets MicrosoftTeams service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-telegram-settings\nfunc (s *ServicesService) GetTelegramService(pid interface{}, options ...RequestOptionFunc) (*TelegramService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/telegram\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(TelegramService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetTelegramServiceOptions represents the available SetTelegramService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-telegram\ntype SetTelegramServiceOptions struct {\n\tToken                     *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tRoom                      *string `url:\"room,omitempty\" json:\"room,omitempty\"`\n\tNotifyOnlyBrokenPipelines *bool   `url:\"notify_only_broken_pipelines,omitempty\" json:\"notify_only_broken_pipelines,omitempty\"`\n\tBranchesToBeNotified      *string `url:\"branches_to_be_notified,omitempty\" json:\"branches_to_be_notified,omitempty\"`\n\tPushEvents                *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tIssuesEvents              *bool   `url:\"issues_events,omitempty\" json:\"issues_events,omitempty\"`\n\tConfidentialIssuesEvents  *bool   `url:\"confidential_issues_events,omitempty\" json:\"confidential_issues_events,omitempty\"`\n\tMergeRequestsEvents       *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tTagPushEvents             *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tNoteEvents                *bool   `url:\"note_events,omitempty\" json:\"note_events,omitempty\"`\n\tConfidentialNoteEvents    *bool   `url:\"confidential_note_events,omitempty\" json:\"confidential_note_events,omitempty\"`\n\tPipelineEvents            *bool   `url:\"pipeline_events,omitempty\" json:\"pipeline_events,omitempty\"`\n\tWikiPageEvents            *bool   `url:\"wiki_page_events,omitempty\" json:\"wiki_page_events,omitempty\"`\n}\n\n// SetTelegramService sets Telegram service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#set-up-telegram\nfunc (s *ServicesService) SetTelegramService(pid interface{}, opt *SetTelegramServiceOptions, options ...RequestOptionFunc) (*TelegramService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/telegram\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(TelegramService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteTelegramService deletes Telegram service for project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#disable-telegram\nfunc (s *ServicesService) DeleteTelegramService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/telegram\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// YouTrackService represents YouTrack service settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#youtrack\ntype YouTrackService struct {\n\tService\n\tProperties *YouTrackServiceProperties `json:\"properties\"`\n}\n\n// YouTrackServiceProperties represents YouTrack specific properties.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#youtrack\ntype YouTrackServiceProperties struct {\n\tIssuesURL   string `json:\"issues_url\"`\n\tProjectURL  string `json:\"project_url\"`\n\tDescription string `json:\"description\"`\n\tPushEvents  bool   `json:\"push_events\"`\n}\n\n// GetYouTrackService gets YouTrack service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#get-youtrack-service-settings\nfunc (s *ServicesService) GetYouTrackService(pid interface{}, options ...RequestOptionFunc) (*YouTrackService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/youtrack\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tsvc := new(YouTrackService)\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// SetYouTrackServiceOptions represents the available SetYouTrackService()\n// options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-youtrack-service\ntype SetYouTrackServiceOptions struct {\n\tIssuesURL   *string `url:\"issues_url,omitempty\" json:\"issues_url,omitempty\"`\n\tProjectURL  *string `url:\"project_url,omitempty\" json:\"project_url,omitempty\"`\n\tDescription *string `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPushEvents  *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n}\n\n// SetYouTrackService sets YouTrack service for a project\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#createedit-youtrack-service\nfunc (s *ServicesService) SetYouTrackService(pid interface{}, opt *SetYouTrackServiceOptions, options ...RequestOptionFunc) (*YouTrackService, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/youtrack\", PathEscape(project))\n\n\tsvc := new(YouTrackService)\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tresp, err := s.client.Do(req, svc)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn svc, resp, nil\n}\n\n// DeleteYouTrackService deletes YouTrack service settings for a project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/integrations.html#delete-youtrack-service\nfunc (s *ServicesService) DeleteYouTrackService(pid interface{}, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/services/youtrack\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "services_test.go",
          "type": "blob",
          "size": 33.7392578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestListServices(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":1},{\"id\":2}]`)\n\t})\n\twant := []*Service{{ID: 1}, {ID: 2}}\n\n\tservices, _, err := client.Services.ListServices(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.ListServices returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, services) {\n\t\tt.Errorf(\"Services.ListServices returned %+v, want %+v\", services, want)\n\t}\n}\n\nfunc TestCustomIssueTrackerService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/custom-issue-tracker\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"title\": \"5\",\n      \"push_events\": true,\n      \"properties\": {\n        \"new_issue_url\": \"1\",\n        \"issues_url\": \"2\",\n        \"project_url\": \"3\"\n      }\n    }`)\n\t})\n\twant := &CustomIssueTrackerService{\n\t\tService: Service{\n\t\t\tID:         1,\n\t\t\tTitle:      \"5\",\n\t\t\tPushEvents: true,\n\t\t},\n\t\tProperties: &CustomIssueTrackerServiceProperties{\n\t\t\tNewIssueURL: \"1\",\n\t\t\tIssuesURL:   \"2\",\n\t\t\tProjectURL:  \"3\",\n\t\t},\n\t}\n\n\tservice, _, err := client.Services.GetCustomIssueTrackerService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetCustomIssueTrackerService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetCustomIssueTrackerService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetCustomIssueTrackerService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/custom-issue-tracker\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetCustomIssueTrackerServiceOptions{\n\t\tNewIssueURL: Ptr(\"1\"),\n\t\tIssuesURL:   Ptr(\"2\"),\n\t\tProjectURL:  Ptr(\"3\"),\n\t}\n\n\t_, _, err := client.Services.SetCustomIssueTrackerService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetCustomIssueTrackerService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteCustomIssueTrackerService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/custom-issue-tracker\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteCustomIssueTrackerService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteCustomIssueTrackerService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetDataDogService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/datadog\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"active\": true,\n      \"properties\": {\n        \"api_url\": \"\",\n        \"datadog_env\": \"production\",\n        \"datadog_service\": \"gitlab\",\n        \"datadog_site\": \"datadoghq.com\",\n        \"datadog_tags\": \"country=canada\\nprovince=ontario\",\n        \"archive_trace_events\": true\n      }\n    }`)\n\t})\n\twant := &DataDogService{\n\t\tService: Service{ID: 1, Active: true},\n\t\tProperties: &DataDogServiceProperties{\n\t\t\tAPIURL:             \"\",\n\t\t\tDataDogEnv:         \"production\",\n\t\t\tDataDogService:     \"gitlab\",\n\t\t\tDataDogSite:        \"datadoghq.com\",\n\t\t\tDataDogTags:        \"country=canada\\nprovince=ontario\",\n\t\t\tArchiveTraceEvents: true,\n\t\t},\n\t}\n\n\tservice, _, err := client.Services.GetDataDogService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetDataDogService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetDataDogService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetDataDogService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/datadog\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetDataDogServiceOptions{\n\t\tAPIKey:             String(\"secret\"),\n\t\tAPIURL:             String(\"https://some-api.com\"),\n\t\tDataDogEnv:         String(\"sandbox\"),\n\t\tDataDogService:     String(\"source-code\"),\n\t\tDataDogSite:        String(\"datadoghq.eu\"),\n\t\tDataDogTags:        String(\"country=france\"),\n\t\tArchiveTraceEvents: Bool(false),\n\t}\n\n\t_, _, err := client.Services.SetDataDogService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetDataDogService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteDataDogService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/datadog\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteDataDogService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteDataDogService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetDiscordService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/discord\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &DiscordService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetDiscordService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetDiscordService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetDiscordService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetDiscordService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/discord\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetDiscordServiceOptions{\n\t\tWebHook: Ptr(\"webhook_uri\"),\n\t}\n\n\t_, _, err := client.Services.SetDiscordService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetDiscordService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteDiscordService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/discord\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteDiscordService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteDiscordService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetDroneCIService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/drone-ci\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &DroneCIService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetDroneCIService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetDroneCIService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetDroneCIService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetDroneCIService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/drone-ci\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetDroneCIServiceOptions{Ptr(\"token\"), Ptr(\"drone-url\"), Ptr(true), nil, nil, nil}\n\n\t_, _, err := client.Services.SetDroneCIService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetDroneCIService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteDroneCIService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/drone-ci\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteDroneCIService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteDroneCIService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetEmailsOnPushService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/emails-on-push\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &EmailsOnPushService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetEmailsOnPushService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetEmailsOnPushService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetEmailsOnPushService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetEmailsOnPushService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/emails-on-push\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetEmailsOnPushServiceOptions{Ptr(\"t\"), Ptr(true), Ptr(true), Ptr(true), Ptr(true), Ptr(\"t\")}\n\n\t_, _, err := client.Services.SetEmailsOnPushService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetEmailsOnPushService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteEmailsOnPushService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/emails-on-push\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteEmailsOnPushService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteEmailsOnPushService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetHarborService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/harbor\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &HarborService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetHarborService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetHarborService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetHarborService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetHarborService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/harbor\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetHarborServiceOptions{\n\t\tURL:                  Ptr(\"url\"),\n\t\tProjectName:          Ptr(\"project\"),\n\t\tUsername:             Ptr(\"user\"),\n\t\tPassword:             Ptr(\"pass\"),\n\t\tUseInheritedSettings: Ptr(false),\n\t}\n\n\t_, _, err := client.Services.SetHarborService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetHarborService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteHarborService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/harbor\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteHarborService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteHarborService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetSlackApplication(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/gitlab-slack-application\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &SlackApplication{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetSlackApplication(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetSlackApplication returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetSlackApplication returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetSlackApplication(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/gitlab-slack-application\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetSlackApplicationOptions{Channel: Ptr(\"#channel1\"), NoteEvents: Ptr(true), AlertEvents: Ptr(true)}\n\n\t_, _, err := client.Services.SetSlackApplication(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetSlackApplication returns an error: %v\", err)\n\t}\n}\n\nfunc TestDisableSlackApplication(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/gitlab-slack-application\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DisableSlackApplication(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DisableSlackApplication returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetJiraService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/0/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {\"jira_issue_transition_id\": \"2\"}}`)\n\t})\n\n\tmux.HandleFunc(\"/api/v4/projects/2/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {\"jira_issue_transition_id\": 2}}`)\n\t})\n\n\tmux.HandleFunc(\"/api/v4/projects/3/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {\"jira_issue_transition_id\": \"2,3\"}}`)\n\t})\n\n\tmux.HandleFunc(\"/api/v4/projects/4/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {\"jira_auth_type\": 1}}`)\n\t})\n\n\twant := []*JiraService{\n\t\t{\n\t\t\tService:    Service{ID: 1},\n\t\t\tProperties: &JiraServiceProperties{},\n\t\t},\n\t\t{\n\t\t\tService: Service{ID: 1},\n\t\t\tProperties: &JiraServiceProperties{\n\t\t\t\tJiraIssueTransitionID: \"2\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tService: Service{ID: 1},\n\t\t\tProperties: &JiraServiceProperties{\n\t\t\t\tJiraIssueTransitionID: \"2\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tService: Service{ID: 1},\n\t\t\tProperties: &JiraServiceProperties{\n\t\t\t\tJiraIssueTransitionID: \"2,3\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tService: Service{ID: 1},\n\t\t\tProperties: &JiraServiceProperties{\n\t\t\t\tJiraAuthType: 1,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor testcase := 0; testcase < len(want); testcase++ {\n\t\tservice, _, err := client.Services.GetJiraService(testcase)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Services.GetJiraService returns an error: %v\", err)\n\t\t}\n\n\t\tif !reflect.DeepEqual(want[testcase], service) {\n\t\t\tt.Errorf(\"Services.GetJiraService returned %+v, want %+v\", service, want[testcase])\n\t\t}\n\t}\n}\n\nfunc TestSetJiraService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetJiraServiceOptions{\n\t\tURL:                          Ptr(\"asd\"),\n\t\tAPIURL:                       Ptr(\"asd\"),\n\t\tProjectKey:                   Ptr(\"as\"),\n\t\tUsername:                     Ptr(\"aas\"),\n\t\tPassword:                     Ptr(\"asd\"),\n\t\tActive:                       Ptr(true),\n\t\tJiraIssuePrefix:              Ptr(\"ASD\"),\n\t\tJiraIssueRegex:               Ptr(\"ASD\"),\n\t\tJiraIssueTransitionAutomatic: Ptr(true),\n\t\tJiraIssueTransitionID:        Ptr(\"2,3\"),\n\t\tCommitEvents:                 Ptr(true),\n\t\tMergeRequestsEvents:          Ptr(true),\n\t\tCommentOnEventEnabled:        Ptr(true),\n\t\tIssuesEnabled:                Ptr(true),\n\t\tUseInheritedSettings:         Ptr(true),\n\t}\n\n\t_, _, err := client.Services.SetJiraService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetJiraService returns an error: %v\", err)\n\t}\n}\n\nfunc TestSetJiraServiceProjecKeys(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetJiraServiceOptions{\n\t\tURL:                          Ptr(\"asd\"),\n\t\tAPIURL:                       Ptr(\"asd\"),\n\t\tUsername:                     Ptr(\"aas\"),\n\t\tPassword:                     Ptr(\"asd\"),\n\t\tActive:                       Ptr(true),\n\t\tJiraIssuePrefix:              Ptr(\"ASD\"),\n\t\tJiraIssueRegex:               Ptr(\"ASD\"),\n\t\tJiraIssueTransitionAutomatic: Ptr(true),\n\t\tJiraIssueTransitionID:        Ptr(\"2,3\"),\n\t\tCommitEvents:                 Ptr(true),\n\t\tMergeRequestsEvents:          Ptr(true),\n\t\tCommentOnEventEnabled:        Ptr(true),\n\t\tIssuesEnabled:                Ptr(true),\n\t\tProjectKeys:                  Ptr([]string{\"as\"}),\n\t\tUseInheritedSettings:         Ptr(true),\n\t}\n\n\t_, _, err := client.Services.SetJiraService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetJiraService returns an error: %v\", err)\n\t}\n}\n\nfunc TestSetJiraServiceAuthTypeBasicAuth(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetJiraServiceOptions{\n\t\tURL:          Ptr(\"asd\"),\n\t\tUsername:     Ptr(\"aas\"),\n\t\tPassword:     Ptr(\"asd\"),\n\t\tJiraAuthType: Ptr(0),\n\t}\n\n\t_, _, err := client.Services.SetJiraService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetJiraService returns an error: %v\", err)\n\t}\n}\n\nfunc TestSetJiraServiceAuthTypeTokenAuth(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetJiraServiceOptions{\n\t\tURL:          Ptr(\"asd\"),\n\t\tPassword:     Ptr(\"asd\"),\n\t\tJiraAuthType: Ptr(1),\n\t}\n\n\t_, _, err := client.Services.SetJiraService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetJiraService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteJiraService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/jira\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteJiraService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteJiraService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetMattermostService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/mattermost\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &MattermostService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetMattermostService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetMattermostService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetMattermostService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetMattermostService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/mattermost\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetMattermostServiceOptions{\n\t\tWebHook:  Ptr(\"webhook_uri\"),\n\t\tUsername: Ptr(\"username\"),\n\t\tChannel:  Ptr(\"#development\"),\n\t}\n\n\t_, _, err := client.Services.SetMattermostService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetMasttermostService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteMattermostService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/mattermost\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteMattermostService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteMattermostService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetMattermostSlashCommandsService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/mattermost-slash-commands\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &MattermostSlashCommandsService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetMattermostSlashCommandsService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.mattermost-slash-commands returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.mattermost-slash-commands returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetMattermostSlashCommandsService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/mattermost-slash-commands\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetMattermostSlashCommandsServiceOptions{\n\t\tToken:    Ptr(\"token\"),\n\t\tUsername: Ptr(\"username\"),\n\t}\n\n\t_, _, err := client.Services.SetMattermostSlashCommandsService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetMattermostSlashCommandsService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteMattermostSlashCommandsService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/mattermost-slash-commands\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteMattermostSlashCommandsService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteMattermostSlashCommandsService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetPipelinesEmailService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/pipelines-email\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &PipelinesEmailService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetPipelinesEmailService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetPipelinesEmailService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetPipelinesEmailService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetPipelinesEmailService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/pipelines-email\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetPipelinesEmailServiceOptions{\n\t\tRecipients:                Ptr(\"test@email.com\"),\n\t\tNotifyOnlyBrokenPipelines: Ptr(true),\n\t\tNotifyOnlyDefaultBranch:   Ptr(false),\n\t\tAddPusher:                 nil,\n\t\tBranchesToBeNotified:      nil,\n\t\tPipelineEvents:            nil,\n\t}\n\n\t_, _, err := client.Services.SetPipelinesEmailService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetPipelinesEmailService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeletePipelinesEmailService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/pipelines-email\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeletePipelinesEmailService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeletePipelinesEmailService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetPrometheusService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/prometheus\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &PrometheusService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetPrometheusService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetPrometheusService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetPrometheusService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetPrometheusService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/prometheus\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetPrometheusServiceOptions{Ptr(\"t\"), Ptr(\"u\"), Ptr(\"a\")}\n\n\t_, _, err := client.Services.SetPrometheusService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetDroneCIService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeletePrometheusService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/prometheus\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeletePrometheusService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeletePrometheusService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetRedmineService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/redmine\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &RedmineService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetRedmineService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetRedmineService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetRedmineService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetRedmineService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/redmine\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetRedmineServiceOptions{Ptr(\"t\"), Ptr(\"u\"), Ptr(\"a\"), Ptr(false)}\n\n\t_, _, err := client.Services.SetRedmineService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetRedmineService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteRedmineService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/integrations/redmine\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteRedmineService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteRedmineService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetSlackService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/slack\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &SlackService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetSlackService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetSlackService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetSlackService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetSlackService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/slack\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetSlackServiceOptions{\n\t\tWebHook:  Ptr(\"webhook_uri\"),\n\t\tUsername: Ptr(\"username\"),\n\t\tChannel:  Ptr(\"#development\"),\n\t}\n\n\t_, _, err := client.Services.SetSlackService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetSlackService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteSlackService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/slack\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteSlackService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteSlackService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetSlackSlashCommandsService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/slack-slash-commands\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &SlackSlashCommandsService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetSlackSlashCommandsService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetSlackSlashCommandsService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetSlackSlashCommandsService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetSlackSlashCommandsService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/slack-slash-commands\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetSlackSlashCommandsServiceOptions{\n\t\tToken: Ptr(\"token\"),\n\t}\n\n\t_, _, err := client.Services.SetSlackSlashCommandsService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetSlackSlashCommandsService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteSlackSlashCommandsService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/slack-slash-commands\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteSlackSlashCommandsService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteSlackSlashCommandsService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetTelegramService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/telegram\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t\t{\n\t\t\t  \"id\": 1,\n\t\t\t  \"title\": \"Telegram\",\n\t\t\t  \"slug\": \"telegram\",\n\t\t\t  \"created_at\": \"2023-12-16T20:21:03.117Z\",\n\t\t\t  \"updated_at\": \"2023-12-16T20:22:19.140Z\",\n\t\t\t  \"active\": true,\n\t\t\t  \"commit_events\": true,\n\t\t\t  \"push_events\": false,\n\t\t\t  \"issues_events\": false,\n\t\t\t  \"incident_events\": false,\n\t\t\t  \"alert_events\": true,\n\t\t\t  \"confidential_issues_events\": false,\n\t\t\t  \"merge_requests_events\": false,\n\t\t\t  \"tag_push_events\": false,\n\t\t\t  \"deployment_events\": false,\n\t\t\t  \"note_events\": false,\n\t\t\t  \"confidential_note_events\": false,\n\t\t\t  \"pipeline_events\": true,\n\t\t\t  \"wiki_page_events\": false,\n\t\t\t  \"job_events\": true,\n\t\t\t  \"comment_on_event_enabled\": true,\n\t\t\t  \"vulnerability_events\": false,\n\t\t\t  \"properties\": {\n\t\t\t\t\"room\": \"-1000000000000\",\n\t\t\t\t\"notify_only_broken_pipelines\": false,\n\t\t\t\t\"branches_to_be_notified\": \"all\"\n\t\t\t  }\n\t\t\t}\n\t\t`)\n\t})\n\twantCreatedAt, _ := time.Parse(time.RFC3339, \"2023-12-16T20:21:03.117Z\")\n\twantUpdatedAt, _ := time.Parse(time.RFC3339, \"2023-12-16T20:22:19.140Z\")\n\twant := &TelegramService{\n\t\tService: Service{\n\t\t\tID:                       1,\n\t\t\tTitle:                    \"Telegram\",\n\t\t\tSlug:                     \"telegram\",\n\t\t\tCreatedAt:                &wantCreatedAt,\n\t\t\tUpdatedAt:                &wantUpdatedAt,\n\t\t\tActive:                   true,\n\t\t\tCommitEvents:             true,\n\t\t\tPushEvents:               false,\n\t\t\tIssuesEvents:             false,\n\t\t\tAlertEvents:              true,\n\t\t\tConfidentialIssuesEvents: false,\n\t\t\tMergeRequestsEvents:      false,\n\t\t\tTagPushEvents:            false,\n\t\t\tDeploymentEvents:         false,\n\t\t\tNoteEvents:               false,\n\t\t\tConfidentialNoteEvents:   false,\n\t\t\tPipelineEvents:           true,\n\t\t\tWikiPageEvents:           false,\n\t\t\tJobEvents:                true,\n\t\t\tCommentOnEventEnabled:    true,\n\t\t\tVulnerabilityEvents:      false,\n\t\t},\n\t\tProperties: &TelegramServiceProperties{\n\t\t\tRoom:                      \"-1000000000000\",\n\t\t\tNotifyOnlyBrokenPipelines: false,\n\t\t\tBranchesToBeNotified:      \"all\",\n\t\t},\n\t}\n\n\tservice, _, err := client.Services.GetTelegramService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetTelegramService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetTelegramService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetTelegramService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/telegram\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetTelegramServiceOptions{\n\t\tToken:                     Ptr(\"token\"),\n\t\tRoom:                      Ptr(\"-1000\"),\n\t\tNotifyOnlyBrokenPipelines: Ptr(true),\n\t\tBranchesToBeNotified:      Ptr(\"all\"),\n\t\tPushEvents:                Ptr(true),\n\t\tIssuesEvents:              Ptr(true),\n\t\tConfidentialIssuesEvents:  Ptr(true),\n\t\tMergeRequestsEvents:       Ptr(true),\n\t\tTagPushEvents:             Ptr(true),\n\t\tNoteEvents:                Ptr(true),\n\t\tConfidentialNoteEvents:    Ptr(true),\n\t\tPipelineEvents:            Ptr(true),\n\t\tWikiPageEvents:            Ptr(true),\n\t}\n\n\t_, _, err := client.Services.SetTelegramService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetTelegramService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteTelegramService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/telegram\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteTelegramService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteTelegramService returns an error: %v\", err)\n\t}\n}\n\nfunc TestGetYouTrackService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/youtrack\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1}`)\n\t})\n\twant := &YouTrackService{Service: Service{ID: 1}}\n\n\tservice, _, err := client.Services.GetYouTrackService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.GetYouTrackService returns an error: %v\", err)\n\t}\n\tif !reflect.DeepEqual(want, service) {\n\t\tt.Errorf(\"Services.GetYouTrackService returned %+v, want %+v\", service, want)\n\t}\n}\n\nfunc TestSetYouTrackService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/youtrack\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"properties\": {}}`)\n\t})\n\n\topt := &SetYouTrackServiceOptions{\n\t\tIssuesURL:   Ptr(\"https://example.org/youtrack/issue/:id\"),\n\t\tProjectURL:  Ptr(\"https://example.org/youtrack/projects/1\"),\n\t\tDescription: Ptr(\"description\"),\n\t\tPushEvents:  Ptr(true),\n\t}\n\n\t_, _, err := client.Services.SetYouTrackService(1, opt)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.SetYouTrackService returns an error: %v\", err)\n\t}\n}\n\nfunc TestDeleteYouTrackService(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/services/youtrack\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Services.DeleteYouTrackService(1)\n\tif err != nil {\n\t\tt.Fatalf(\"Services.DeleteYouTrackService returns an error: %v\", err)\n\t}\n}\n"
        },
        {
          "name": "settings.go",
          "type": "blob",
          "size": 125.087890625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// SettingsService handles communication with the application SettingsService\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/settings.html\ntype SettingsService struct {\n\tclient *Client\n}\n\n// Settings represents the GitLab application settings.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/settings.html\n//\n// The available parameters have been modeled directly after the code, as the\n// documentation seems to be inaccurate.\n//\n// https://gitlab.com/gitlab-org/gitlab/-/blob/v14.9.3-ee/lib/api/settings.rb\n// https://gitlab.com/gitlab-org/gitlab/-/blob/v14.9.3-ee/lib/api/entities/application_setting.rb#L5\n// https://gitlab.com/gitlab-org/gitlab/-/blob/v14.9.3-ee/app/helpers/application_settings_helper.rb#L192\n// https://gitlab.com/gitlab-org/gitlab/-/blob/v14.9.3-ee/ee/lib/ee/api/helpers/settings_helpers.rb#L10\n// https://gitlab.com/gitlab-org/gitlab/-/blob/v14.9.3-ee/ee/app/helpers/ee/application_settings_helper.rb#L20\ntype Settings struct {\n\tID                                                    int                       `json:\"id\"`\n\tAbuseNotificationEmail                                string                    `json:\"abuse_notification_email\"`\n\tAdminMode                                             bool                      `json:\"admin_mode\"`\n\tAfterSignOutPath                                      string                    `json:\"after_sign_out_path\"`\n\tAfterSignUpText                                       string                    `json:\"after_sign_up_text\"`\n\tAkismetAPIKey                                         string                    `json:\"akismet_api_key\"`\n\tAkismetEnabled                                        bool                      `json:\"akismet_enabled\"`\n\tAllowAccountDeletion                                  bool                      `json:\"allow_account_deletion\"`\n\tAllowGroupOwnersToManageLDAP                          bool                      `json:\"allow_group_owners_to_manage_ldap\"`\n\tAllowLocalRequestsFromSystemHooks                     bool                      `json:\"allow_local_requests_from_system_hooks\"`\n\tAllowLocalRequestsFromWebHooksAndServices             bool                      `json:\"allow_local_requests_from_web_hooks_and_services\"`\n\tAllowProjectCreationForGuestAndBelow                  bool                      `json:\"allow_project_creation_for_guest_and_below\"`\n\tAllowRunnerRegistrationToken                          bool                      `json:\"allow_runner_registration_token\"`\n\tArchiveBuildsInHumanReadable                          string                    `json:\"archive_builds_in_human_readable\"`\n\tASCIIDocMaxIncludes                                   int                       `json:\"asciidoc_max_includes\"`\n\tAssetProxyAllowlist                                   []string                  `json:\"asset_proxy_allowlist\"`\n\tAssetProxyEnabled                                     bool                      `json:\"asset_proxy_enabled\"`\n\tAssetProxyURL                                         string                    `json:\"asset_proxy_url\"`\n\tAssetProxySecretKey                                   string                    `json:\"asset_proxy_secret_key\"`\n\tAuthorizedKeysEnabled                                 bool                      `json:\"authorized_keys_enabled\"`\n\tAutoBanUserOnExcessiveProjectsDownload                bool                      `json:\"auto_ban_user_on_excessive_projects_download\"`\n\tAutoDevOpsDomain                                      string                    `json:\"auto_devops_domain\"`\n\tAutoDevOpsEnabled                                     bool                      `json:\"auto_devops_enabled\"`\n\tAutomaticPurchasedStorageAllocation                   bool                      `json:\"automatic_purchased_storage_allocation\"`\n\tBulkImportConcurrentPipelineBatchLimit                int                       `json:\"bulk_import_concurrent_pipeline_batch_limit\"`\n\tBulkImportEnabled                                     bool                      `json:\"bulk_import_enabled\"`\n\tBulkImportMaxDownloadFileSize                         int                       `json:\"bulk_import_max_download_file_size\"`\n\tCanCreateGroup                                        bool                      `json:\"can_create_group\"`\n\tCheckNamespacePlan                                    bool                      `json:\"check_namespace_plan\"`\n\tCIMaxIncludes                                         int                       `json:\"ci_max_includes\"`\n\tCIMaxTotalYAMLSizeBytes                               int                       `json:\"ci_max_total_yaml_size_bytes\"`\n\tCommitEmailHostname                                   string                    `json:\"commit_email_hostname\"`\n\tConcurrentBitbucketImportJobsLimit                    int                       `json:\"concurrent_bitbucket_import_jobs_limit\"`\n\tConcurrentBitbucketServerImportJobsLimit              int                       `json:\"concurrent_bitbucket_server_import_jobs_limit\"`\n\tConcurrentGitHubImportJobsLimit                       int                       `json:\"concurrent_github_import_jobs_limit\"`\n\tContainerExpirationPoliciesEnableHistoricEntries      bool                      `json:\"container_expiration_policies_enable_historic_entries\"`\n\tContainerRegistryCleanupTagsServiceMaxListSize        int                       `json:\"container_registry_cleanup_tags_service_max_list_size\"`\n\tContainerRegistryDeleteTagsServiceTimeout             int                       `json:\"container_registry_delete_tags_service_timeout\"`\n\tContainerRegistryExpirationPoliciesCaching            bool                      `json:\"container_registry_expiration_policies_caching\"`\n\tContainerRegistryExpirationPoliciesWorkerCapacity     int                       `json:\"container_registry_expiration_policies_worker_capacity\"`\n\tContainerRegistryImportCreatedBefore                  *time.Time                `json:\"container_registry_import_created_before\"`\n\tContainerRegistryImportMaxRetries                     int                       `json:\"container_registry_import_max_retries\"`\n\tContainerRegistryImportMaxStepDuration                int                       `json:\"container_registry_import_max_step_duration\"`\n\tContainerRegistryImportMaxTagsCount                   int                       `json:\"container_registry_import_max_tags_count\"`\n\tContainerRegistryImportStartMaxRetries                int                       `json:\"container_registry_import_start_max_retries\"`\n\tContainerRegistryImportTargetPlan                     string                    `json:\"container_registry_import_target_plan\"`\n\tContainerRegistryTokenExpireDelay                     int                       `json:\"container_registry_token_expire_delay\"`\n\tCreatedAt                                             *time.Time                `json:\"created_at\"`\n\tCustomHTTPCloneURLRoot                                string                    `json:\"custom_http_clone_url_root\"`\n\tDNSRebindingProtectionEnabled                         bool                      `json:\"dns_rebinding_protection_enabled\"`\n\tDSAKeyRestriction                                     int                       `json:\"dsa_key_restriction\"`\n\tDeactivateDormantUsers                                bool                      `json:\"deactivate_dormant_users\"`\n\tDeactivateDormantUsersPeriod                          int                       `json:\"deactivate_dormant_users_period\"`\n\tDecompressArchiveFileTimeout                          int                       `json:\"decompress_archive_file_timeout\"`\n\tDefaultArtifactsExpireIn                              string                    `json:\"default_artifacts_expire_in\"`\n\tDefaultBranchName                                     string                    `json:\"default_branch_name\"`\n\tDefaultBranchProtection                               int                       `json:\"default_branch_protection\"`\n\tDefaultBranchProtectionDefaults                       *BranchProtectionDefaults `json:\"default_branch_protection_defaults,omitempty\"`\n\tDefaultCiConfigPath                                   string                    `json:\"default_ci_config_path\"`\n\tDefaultGroupVisibility                                VisibilityValue           `json:\"default_group_visibility\"`\n\tDefaultPreferredLanguage                              string                    `json:\"default_preferred_language\"`\n\tDefaultProjectCreation                                int                       `json:\"default_project_creation\"`\n\tDefaultProjectDeletionProtection                      bool                      `json:\"default_project_deletion_protection\"`\n\tDefaultProjectVisibility                              VisibilityValue           `json:\"default_project_visibility\"`\n\tDefaultProjectsLimit                                  int                       `json:\"default_projects_limit\"`\n\tDefaultSnippetVisibility                              VisibilityValue           `json:\"default_snippet_visibility\"`\n\tDefaultSyntaxHighlightingTheme                        int                       `json:\"default_syntax_highlighting_theme\"`\n\tDelayedGroupDeletion                                  bool                      `json:\"delayed_group_deletion\"`\n\tDelayedProjectDeletion                                bool                      `json:\"delayed_project_deletion\"`\n\tDeleteInactiveProjects                                bool                      `json:\"delete_inactive_projects\"`\n\tDeleteUnconfirmedUsers                                bool                      `json:\"delete_unconfirmed_users\"`\n\tDeletionAdjournedPeriod                               int                       `json:\"deletion_adjourned_period\"`\n\tDiagramsnetEnabled                                    bool                      `json:\"diagramsnet_enabled\"`\n\tDiagramsnetURL                                        string                    `json:\"diagramsnet_url\"`\n\tDiffMaxFiles                                          int                       `json:\"diff_max_files\"`\n\tDiffMaxLines                                          int                       `json:\"diff_max_lines\"`\n\tDiffMaxPatchBytes                                     int                       `json:\"diff_max_patch_bytes\"`\n\tDisableAdminOAuthScopes                               bool                      `json:\"disable_admin_oauth_scopes\"`\n\tDisableFeedToken                                      bool                      `json:\"disable_feed_token\"`\n\tDisableOverridingApproversPerMergeRequest             bool                      `json:\"disable_overriding_approvers_per_merge_request\"`\n\tDisablePersonalAccessTokens                           bool                      `json:\"disable_personal_access_tokens\"`\n\tDisabledOauthSignInSources                            []string                  `json:\"disabled_oauth_sign_in_sources\"`\n\tDomainAllowlist                                       []string                  `json:\"domain_allowlist\"`\n\tDomainDenylist                                        []string                  `json:\"domain_denylist\"`\n\tDomainDenylistEnabled                                 bool                      `json:\"domain_denylist_enabled\"`\n\tDownstreamPipelineTriggerLimitPerProjectUserSHA       int                       `json:\"downstream_pipeline_trigger_limit_per_project_user_sha\"`\n\tDuoFeaturesEnabled                                    bool                      `json:\"duo_features_enabled\"`\n\tECDSAKeyRestriction                                   int                       `json:\"ecdsa_key_restriction\"`\n\tECDSASKKeyRestriction                                 int                       `json:\"ecdsa_sk_key_restriction\"`\n\tEKSAccessKeyID                                        string                    `json:\"eks_access_key_id\"`\n\tEKSAccountID                                          string                    `json:\"eks_account_id\"`\n\tEKSIntegrationEnabled                                 bool                      `json:\"eks_integration_enabled\"`\n\tEKSSecretAccessKey                                    string                    `json:\"eks_secret_access_key\"`\n\tEd25519KeyRestriction                                 int                       `json:\"ed25519_key_restriction\"`\n\tEd25519SKKeyRestriction                               int                       `json:\"ed25519_sk_key_restriction\"`\n\tElasticsearchAWS                                      bool                      `json:\"elasticsearch_aws\"`\n\tElasticsearchAWSAccessKey                             string                    `json:\"elasticsearch_aws_access_key\"`\n\tElasticsearchAWSRegion                                string                    `json:\"elasticsearch_aws_region\"`\n\tElasticsearchAWSSecretAccessKey                       string                    `json:\"elasticsearch_aws_secret_access_key\"`\n\tElasticsearchAnalyzersKuromojiEnabled                 bool                      `json:\"elasticsearch_analyzers_kuromoji_enabled\"`\n\tElasticsearchAnalyzersKuromojiSearch                  bool                      `json:\"elasticsearch_analyzers_kuromoji_search\"`\n\tElasticsearchAnalyzersSmartCNEnabled                  bool                      `json:\"elasticsearch_analyzers_smartcn_enabled\"`\n\tElasticsearchAnalyzersSmartCNSearch                   bool                      `json:\"elasticsearch_analyzers_smartcn_search\"`\n\tElasticsearchClientRequestTimeout                     int                       `json:\"elasticsearch_client_request_timeout\"`\n\tElasticsearchIndexedFieldLengthLimit                  int                       `json:\"elasticsearch_indexed_field_length_limit\"`\n\tElasticsearchIndexedFileSizeLimitKB                   int                       `json:\"elasticsearch_indexed_file_size_limit_kb\"`\n\tElasticsearchIndexing                                 bool                      `json:\"elasticsearch_indexing\"`\n\tElasticsearchLimitIndexing                            bool                      `json:\"elasticsearch_limit_indexing\"`\n\tElasticsearchMaxBulkConcurrency                       int                       `json:\"elasticsearch_max_bulk_concurrency\"`\n\tElasticsearchMaxBulkSizeMB                            int                       `json:\"elasticsearch_max_bulk_size_mb\"`\n\tElasticsearchMaxCodeIndexingConcurrency               int                       `json:\"elasticsearch_max_code_indexing_concurrency\"`\n\tElasticsearchNamespaceIDs                             []int                     `json:\"elasticsearch_namespace_ids\"`\n\tElasticsearchPassword                                 string                    `json:\"elasticsearch_password\"`\n\tElasticsearchPauseIndexing                            bool                      `json:\"elasticsearch_pause_indexing\"`\n\tElasticsearchProjectIDs                               []int                     `json:\"elasticsearch_project_ids\"`\n\tElasticsearchReplicas                                 int                       `json:\"elasticsearch_replicas\"`\n\tElasticsearchRequeueWorkers                           bool                      `json:\"elasticsearch_requeue_workers\"`\n\tElasticsearchSearch                                   bool                      `json:\"elasticsearch_search\"`\n\tElasticsearchShards                                   int                       `json:\"elasticsearch_shards\"`\n\tElasticsearchURL                                      []string                  `json:\"elasticsearch_url\"`\n\tElasticsearchUsername                                 string                    `json:\"elasticsearch_username\"`\n\tElasticsearchWorkerNumberOfShards                     int                       `json:\"elasticsearch_worker_number_of_shards\"`\n\tEmailAdditionalText                                   string                    `json:\"email_additional_text\"`\n\tEmailAuthorInBody                                     bool                      `json:\"email_author_in_body\"`\n\tEmailConfirmationSetting                              string                    `json:\"email_confirmation_setting\"`\n\tEmailRestrictions                                     string                    `json:\"email_restrictions\"`\n\tEmailRestrictionsEnabled                              bool                      `json:\"email_restrictions_enabled\"`\n\tEnableArtifactExternalRedirectWarningPage             bool                      `json:\"enable_artifact_external_redirect_warning_page\"`\n\tEnabledGitAccessProtocol                              string                    `json:\"enabled_git_access_protocol\"`\n\tEnforceNamespaceStorageLimit                          bool                      `json:\"enforce_namespace_storage_limit\"`\n\tEnforcePATExpiration                                  bool                      `json:\"enforce_pat_expiration\"`\n\tEnforceSSHKeyExpiration                               bool                      `json:\"enforce_ssh_key_expiration\"`\n\tEnforceTerms                                          bool                      `json:\"enforce_terms\"`\n\tExternalAuthClientCert                                string                    `json:\"external_auth_client_cert\"`\n\tExternalAuthClientKey                                 string                    `json:\"external_auth_client_key\"`\n\tExternalAuthClientKeyPass                             string                    `json:\"external_auth_client_key_pass\"`\n\tExternalAuthorizationServiceDefaultLabel              string                    `json:\"external_authorization_service_default_label\"`\n\tExternalAuthorizationServiceEnabled                   bool                      `json:\"external_authorization_service_enabled\"`\n\tExternalAuthorizationServiceTimeout                   float64                   `json:\"external_authorization_service_timeout\"`\n\tExternalAuthorizationServiceURL                       string                    `json:\"external_authorization_service_url\"`\n\tExternalPipelineValidationServiceTimeout              int                       `json:\"external_pipeline_validation_service_timeout\"`\n\tExternalPipelineValidationServiceToken                string                    `json:\"external_pipeline_validation_service_token\"`\n\tExternalPipelineValidationServiceURL                  string                    `json:\"external_pipeline_validation_service_url\"`\n\tFailedLoginAttemptsUnlockPeriodInMinutes              int                       `json:\"failed_login_attempts_unlock_period_in_minutes\"`\n\tFileTemplateProjectID                                 int                       `json:\"file_template_project_id\"`\n\tFirstDayOfWeek                                        int                       `json:\"first_day_of_week\"`\n\tFlocEnabled                                           bool                      `json:\"floc_enabled\"`\n\tGeoNodeAllowedIPs                                     string                    `json:\"geo_node_allowed_ips\"`\n\tGeoStatusTimeout                                      int                       `json:\"geo_status_timeout\"`\n\tGitRateLimitUsersAlertlist                            []string                  `json:\"git_rate_limit_users_alertlist\"`\n\tGitTwoFactorSessionExpiry                             int                       `json:\"git_two_factor_session_expiry\"`\n\tGitalyTimeoutDefault                                  int                       `json:\"gitaly_timeout_default\"`\n\tGitalyTimeoutFast                                     int                       `json:\"gitaly_timeout_fast\"`\n\tGitalyTimeoutMedium                                   int                       `json:\"gitaly_timeout_medium\"`\n\tGitlabDedicatedInstance                               bool                      `json:\"gitlab_dedicated_instance\"`\n\tGitlabEnvironmentToolkitInstance                      bool                      `json:\"gitlab_environment_toolkit_instance\"`\n\tGitlabShellOperationLimit                             int                       `json:\"gitlab_shell_operation_limit\"`\n\tGitpodEnabled                                         bool                      `json:\"gitpod_enabled\"`\n\tGitpodURL                                             string                    `json:\"gitpod_url\"`\n\tGitRateLimitUsersAllowlist                            []string                  `json:\"git_rate_limit_users_allowlist\"`\n\tGloballyAllowedIPs                                    string                    `json:\"globally_allowed_ips\"`\n\tGrafanaEnabled                                        bool                      `json:\"grafana_enabled\"`\n\tGrafanaURL                                            string                    `json:\"grafana_url\"`\n\tGravatarEnabled                                       bool                      `json:\"gravatar_enabled\"`\n\tGroupDownloadExportLimit                              int                       `json:\"group_download_export_limit\"`\n\tGroupExportLimit                                      int                       `json:\"group_export_limit\"`\n\tGroupImportLimit                                      int                       `json:\"group_import_limit\"`\n\tGroupOwnersCanManageDefaultBranchProtection           bool                      `json:\"group_owners_can_manage_default_branch_protection\"`\n\tGroupRunnerTokenExpirationInterval                    int                       `json:\"group_runner_token_expiration_interval\"`\n\tHTMLEmailsEnabled                                     bool                      `json:\"html_emails_enabled\"`\n\tHashedStorageEnabled                                  bool                      `json:\"hashed_storage_enabled\"`\n\tHelpPageDocumentationBaseURL                          string                    `json:\"help_page_documentation_base_url\"`\n\tHelpPageHideCommercialContent                         bool                      `json:\"help_page_hide_commercial_content\"`\n\tHelpPageSupportURL                                    string                    `json:\"help_page_support_url\"`\n\tHelpPageText                                          string                    `json:\"help_page_text\"`\n\tHelpText                                              string                    `json:\"help_text\"`\n\tHideThirdPartyOffers                                  bool                      `json:\"hide_third_party_offers\"`\n\tHomePageURL                                           string                    `json:\"home_page_url\"`\n\tHousekeepingBitmapsEnabled                            bool                      `json:\"housekeeping_bitmaps_enabled\"`\n\tHousekeepingEnabled                                   bool                      `json:\"housekeeping_enabled\"`\n\tHousekeepingFullRepackPeriod                          int                       `json:\"housekeeping_full_repack_period\"`\n\tHousekeepingGcPeriod                                  int                       `json:\"housekeeping_gc_period\"`\n\tHousekeepingIncrementalRepackPeriod                   int                       `json:\"housekeeping_incremental_repack_period\"`\n\tHousekeepingOptimizeRepositoryPeriod                  int                       `json:\"housekeeping_optimize_repository_period\"`\n\tImportSources                                         []string                  `json:\"import_sources\"`\n\tInactiveProjectsDeleteAfterMonths                     int                       `json:\"inactive_projects_delete_after_months\"`\n\tInactiveProjectsMinSizeMB                             int                       `json:\"inactive_projects_min_size_mb\"`\n\tInactiveProjectsSendWarningEmailAfterMonths           int                       `json:\"inactive_projects_send_warning_email_after_months\"`\n\tIncludeOptionalMetricsInServicePing                   bool                      `json:\"include_optional_metrics_in_service_ping\"`\n\tInProductMarketingEmailsEnabled                       bool                      `json:\"in_product_marketing_emails_enabled\"`\n\tInvisibleCaptchaEnabled                               bool                      `json:\"invisible_captcha_enabled\"`\n\tIssuesCreateLimit                                     int                       `json:\"issues_create_limit\"`\n\tJiraConnectApplicationKey                             string                    `json:\"jira_connect_application_key\"`\n\tJiraConnectPublicKeyStorageEnabled                    bool                      `json:\"jira_connect_public_key_storage_enabled\"`\n\tJiraConnectProxyURL                                   string                    `json:\"jira_connect_proxy_url\"`\n\tKeepLatestArtifact                                    bool                      `json:\"keep_latest_artifact\"`\n\tKrokiEnabled                                          bool                      `json:\"kroki_enabled\"`\n\tKrokiFormats                                          map[string]bool           `json:\"kroki_formats\"`\n\tKrokiURL                                              string                    `json:\"kroki_url\"`\n\tLocalMarkdownVersion                                  int                       `json:\"local_markdown_version\"`\n\tLockDuoFeaturesEnabled                                bool                      `json:\"lock_duo_features_enabled\"`\n\tLockMembershipsToLDAP                                 bool                      `json:\"lock_memberships_to_ldap\"`\n\tLoginRecaptchaProtectionEnabled                       bool                      `json:\"login_recaptcha_protection_enabled\"`\n\tMailgunEventsEnabled                                  bool                      `json:\"mailgun_events_enabled\"`\n\tMailgunSigningKey                                     string                    `json:\"mailgun_signing_key\"`\n\tMaintenanceMode                                       bool                      `json:\"maintenance_mode\"`\n\tMaintenanceModeMessage                                string                    `json:\"maintenance_mode_message\"`\n\tMavenPackageRequestsForwarding                        bool                      `json:\"maven_package_requests_forwarding\"`\n\tMaxArtifactsSize                                      int                       `json:\"max_artifacts_size\"`\n\tMaxAttachmentSize                                     int                       `json:\"max_attachment_size\"`\n\tMaxDecompressedArchiveSize                            int                       `json:\"max_decompressed_archive_size\"`\n\tMaxExportSize                                         int                       `json:\"max_export_size\"`\n\tMaxImportRemoteFileSize                               int                       `json:\"max_import_remote_file_size\"`\n\tMaxImportSize                                         int                       `json:\"max_import_size\"`\n\tMaxLoginAttempts                                      int                       `json:\"max_login_attempts\"`\n\tMaxNumberOfRepositoryDownloads                        int                       `json:\"max_number_of_repository_downloads\"`\n\tMaxNumberOfRepositoryDownloadsWithinTimePeriod        int                       `json:\"max_number_of_repository_downloads_within_time_period\"`\n\tMaxPagesSize                                          int                       `json:\"max_pages_size\"`\n\tMaxPersonalAccessTokenLifetime                        int                       `json:\"max_personal_access_token_lifetime\"`\n\tMaxSSHKeyLifetime                                     int                       `json:\"max_ssh_key_lifetime\"`\n\tMaxTerraformStateSizeBytes                            int                       `json:\"max_terraform_state_size_bytes\"`\n\tMaxYAMLDepth                                          int                       `json:\"max_yaml_depth\"`\n\tMaxYAMLSizeBytes                                      int                       `json:\"max_yaml_size_bytes\"`\n\tMetricsMethodCallThreshold                            int                       `json:\"metrics_method_call_threshold\"`\n\tMinimumPasswordLength                                 int                       `json:\"minimum_password_length\"`\n\tMirrorAvailable                                       bool                      `json:\"mirror_available\"`\n\tMirrorCapacityThreshold                               int                       `json:\"mirror_capacity_threshold\"`\n\tMirrorMaxCapacity                                     int                       `json:\"mirror_max_capacity\"`\n\tMirrorMaxDelay                                        int                       `json:\"mirror_max_delay\"`\n\tNPMPackageRequestsForwarding                          bool                      `json:\"npm_package_requests_forwarding\"`\n\tNotesCreateLimit                                      int                       `json:\"notes_create_limit\"`\n\tNotifyOnUnknownSignIn                                 bool                      `json:\"notify_on_unknown_sign_in\"`\n\tNugetSkipMetadataURLValidation                        bool                      `json:\"nuget_skip_metadata_url_validation\"`\n\tOutboundLocalRequestsAllowlistRaw                     string                    `json:\"outbound_local_requests_allowlist_raw\"`\n\tOutboundLocalRequestsWhitelist                        []string                  `json:\"outbound_local_requests_whitelist\"`\n\tPackageMetadataPURLTypes                              []int                     `json:\"package_metadata_purl_types\"`\n\tPackageRegistryAllowAnyoneToPullOption                bool                      `json:\"package_registry_allow_anyone_to_pull_option\"`\n\tPackageRegistryCleanupPoliciesWorkerCapacity          int                       `json:\"package_registry_cleanup_policies_worker_capacity\"`\n\tPagesDomainVerificationEnabled                        bool                      `json:\"pages_domain_verification_enabled\"`\n\tPasswordAuthenticationEnabledForGit                   bool                      `json:\"password_authentication_enabled_for_git\"`\n\tPasswordAuthenticationEnabledForWeb                   bool                      `json:\"password_authentication_enabled_for_web\"`\n\tPasswordNumberRequired                                bool                      `json:\"password_number_required\"`\n\tPasswordSymbolRequired                                bool                      `json:\"password_symbol_required\"`\n\tPasswordUppercaseRequired                             bool                      `json:\"password_uppercase_required\"`\n\tPasswordLowercaseRequired                             bool                      `json:\"password_lowercase_required\"`\n\tPerformanceBarAllowedGroupID                          int                       `json:\"performance_bar_allowed_group_id\"`\n\tPerformanceBarAllowedGroupPath                        string                    `json:\"performance_bar_allowed_group_path\"`\n\tPerformanceBarEnabled                                 bool                      `json:\"performance_bar_enabled\"`\n\tPersonalAccessTokenPrefix                             string                    `json:\"personal_access_token_prefix\"`\n\tPipelineLimitPerProjectUserSha                        int                       `json:\"pipeline_limit_per_project_user_sha\"`\n\tPlantumlEnabled                                       bool                      `json:\"plantuml_enabled\"`\n\tPlantumlURL                                           string                    `json:\"plantuml_url\"`\n\tPollingIntervalMultiplier                             float64                   `json:\"polling_interval_multiplier,string\"`\n\tPreventMergeRequestsAuthorApproval                    bool                      `json:\"prevent_merge_request_author_approval\"`\n\tPreventMergeRequestsCommittersApproval                bool                      `json:\"prevent_merge_request_committers_approval\"`\n\tProjectDownloadExportLimit                            int                       `json:\"project_download_export_limit\"`\n\tProjectExportEnabled                                  bool                      `json:\"project_export_enabled\"`\n\tProjectExportLimit                                    int                       `json:\"project_export_limit\"`\n\tProjectImportLimit                                    int                       `json:\"project_import_limit\"`\n\tProjectJobsAPIRateLimit                               int                       `json:\"project_jobs_api_rate_limit\"`\n\tProjectRunnerTokenExpirationInterval                  int                       `json:\"project_runner_token_expiration_interval\"`\n\tProjectsAPIRateLimitUnauthenticated                   int                       `json:\"projects_api_rate_limit_unauthenticated\"`\n\tPrometheusMetricsEnabled                              bool                      `json:\"prometheus_metrics_enabled\"`\n\tProtectedCIVariables                                  bool                      `json:\"protected_ci_variables\"`\n\tPseudonymizerEnabled                                  bool                      `json:\"pseudonymizer_enabled\"`\n\tPushEventActivitiesLimit                              int                       `json:\"push_event_activities_limit\"`\n\tPushEventHooksLimit                                   int                       `json:\"push_event_hooks_limit\"`\n\tPyPIPackageRequestsForwarding                         bool                      `json:\"pypi_package_requests_forwarding\"`\n\tRSAKeyRestriction                                     int                       `json:\"rsa_key_restriction\"`\n\tRateLimitingResponseText                              string                    `json:\"rate_limiting_response_text\"`\n\tRawBlobRequestLimit                                   int                       `json:\"raw_blob_request_limit\"`\n\tRecaptchaEnabled                                      bool                      `json:\"recaptcha_enabled\"`\n\tRecaptchaPrivateKey                                   string                    `json:\"recaptcha_private_key\"`\n\tRecaptchaSiteKey                                      string                    `json:\"recaptcha_site_key\"`\n\tReceiveMaxInputSize                                   int                       `json:\"receive_max_input_size\"`\n\tReceptiveClusterAgentsEnabled                         bool                      `json:\"receptive_cluster_agents_enabled\"`\n\tRememberMeEnabled                                     bool                      `json:\"remember_me_enabled\"`\n\tRepositoryChecksEnabled                               bool                      `json:\"repository_checks_enabled\"`\n\tRepositorySizeLimit                                   int                       `json:\"repository_size_limit\"`\n\tRepositoryStorages                                    []string                  `json:\"repository_storages\"`\n\tRepositoryStoragesWeighted                            map[string]int            `json:\"repository_storages_weighted\"`\n\tRequireAdminApprovalAfterUserSignup                   bool                      `json:\"require_admin_approval_after_user_signup\"`\n\tRequireAdminTwoFactorAuthentication                   bool                      `json:\"require_admin_two_factor_authentication\"`\n\tRequirePersonalAccessTokenExpiry                      bool                      `json:\"require_personal_access_token_expiry\"`\n\tRequireTwoFactorAuthentication                        bool                      `json:\"require_two_factor_authentication\"`\n\tRestrictedVisibilityLevels                            []VisibilityValue         `json:\"restricted_visibility_levels\"`\n\tRunnerTokenExpirationInterval                         int                       `json:\"runner_token_expiration_interval\"`\n\tSearchRateLimit                                       int                       `json:\"search_rate_limit\"`\n\tSearchRateLimitUnauthenticated                        int                       `json:\"search_rate_limit_unauthenticated\"`\n\tSecretDetectionRevocationTokenTypesURL                string                    `json:\"secret_detection_revocation_token_types_url\"`\n\tSecretDetectionTokenRevocationEnabled                 bool                      `json:\"secret_detection_token_revocation_enabled\"`\n\tSecretDetectionTokenRevocationToken                   string                    `json:\"secret_detection_token_revocation_token\"`\n\tSecretDetectionTokenRevocationURL                     string                    `json:\"secret_detection_token_revocation_url\"`\n\tSecurityApprovalPoliciesLimit                         int                       `json:\"security_approval_policies_limit\"`\n\tSecurityPolicyGlobalGroupApproversEnabled             bool                      `json:\"security_policy_global_group_approvers_enabled\"`\n\tSecurityTXTContent                                    string                    `json:\"security_txt_content\"`\n\tSendUserConfirmationEmail                             bool                      `json:\"send_user_confirmation_email\"`\n\tSentryClientsideDSN                                   string                    `json:\"sentry_clientside_dsn\"`\n\tSentryDSN                                             string                    `json:\"sentry_dsn\"`\n\tSentryEnabled                                         bool                      `json:\"sentry_enabled\"`\n\tSentryEnvironment                                     string                    `json:\"sentry_environment\"`\n\tServiceAccessTokensExpirationEnforced                 bool                      `json:\"service_access_tokens_expiration_enforced\"`\n\tSessionExpireDelay                                    int                       `json:\"session_expire_delay\"`\n\tSharedRunnersEnabled                                  bool                      `json:\"shared_runners_enabled\"`\n\tSharedRunnersMinutes                                  int                       `json:\"shared_runners_minutes\"`\n\tSharedRunnersText                                     string                    `json:\"shared_runners_text\"`\n\tSidekiqJobLimiterCompressionThresholdBytes            int                       `json:\"sidekiq_job_limiter_compression_threshold_bytes\"`\n\tSidekiqJobLimiterLimitBytes                           int                       `json:\"sidekiq_job_limiter_limit_bytes\"`\n\tSidekiqJobLimiterMode                                 string                    `json:\"sidekiq_job_limiter_mode\"`\n\tSignInText                                            string                    `json:\"sign_in_text\"`\n\tSignupEnabled                                         bool                      `json:\"signup_enabled\"`\n\tSilentAdminExportsEnabled                             bool                      `json:\"silent_admin_exports_enabled\"`\n\tSilentModeEnabled                                     bool                      `json:\"silent_mode_enabled\"`\n\tSlackAppEnabled                                       bool                      `json:\"slack_app_enabled\"`\n\tSlackAppID                                            string                    `json:\"slack_app_id\"`\n\tSlackAppSecret                                        string                    `json:\"slack_app_secret\"`\n\tSlackAppSigningSecret                                 string                    `json:\"slack_app_signing_secret\"`\n\tSlackAppVerificationToken                             string                    `json:\"slack_app_verification_token\"`\n\tSnippetSizeLimit                                      int                       `json:\"snippet_size_limit\"`\n\tSnowplowAppID                                         string                    `json:\"snowplow_app_id\"`\n\tSnowplowCollectorHostname                             string                    `json:\"snowplow_collector_hostname\"`\n\tSnowplowCookieDomain                                  string                    `json:\"snowplow_cookie_domain\"`\n\tSnowplowDatabaseCollectorHostname                     string                    `json:\"snowplow_database_collector_hostname\"`\n\tSnowplowEnabled                                       bool                      `json:\"snowplow_enabled\"`\n\tSourcegraphEnabled                                    bool                      `json:\"sourcegraph_enabled\"`\n\tSourcegraphPublicOnly                                 bool                      `json:\"sourcegraph_public_only\"`\n\tSourcegraphURL                                        string                    `json:\"sourcegraph_url\"`\n\tSpamCheckAPIKey                                       string                    `json:\"spam_check_api_key\"`\n\tSpamCheckEndpointEnabled                              bool                      `json:\"spam_check_endpoint_enabled\"`\n\tSpamCheckEndpointURL                                  string                    `json:\"spam_check_endpoint_url\"`\n\tStaticObjectsExternalStorageAuthToken                 string                    `json:\"static_objects_external_storage_auth_token\"`\n\tStaticObjectsExternalStorageURL                       string                    `json:\"static_objects_external_storage_url\"`\n\tSuggestPipelineEnabled                                bool                      `json:\"suggest_pipeline_enabled\"`\n\tTerminalMaxSessionTime                                int                       `json:\"terminal_max_session_time\"`\n\tTerms                                                 string                    `json:\"terms\"`\n\tThrottleAuthenticatedAPIEnabled                       bool                      `json:\"throttle_authenticated_api_enabled\"`\n\tThrottleAuthenticatedAPIPeriodInSeconds               int                       `json:\"throttle_authenticated_api_period_in_seconds\"`\n\tThrottleAuthenticatedAPIRequestsPerPeriod             int                       `json:\"throttle_authenticated_api_requests_per_period\"`\n\tThrottleAuthenticatedDeprecatedAPIEnabled             bool                      `json:\"throttle_authenticated_deprecated_api_enabled\"`\n\tThrottleAuthenticatedDeprecatedAPIPeriodInSeconds     int                       `json:\"throttle_authenticated_deprecated_api_period_in_seconds\"`\n\tThrottleAuthenticatedDeprecatedAPIRequestsPerPeriod   int                       `json:\"throttle_authenticated_deprecated_api_requests_per_period\"`\n\tThrottleAuthenticatedFilesAPIEnabled                  bool                      `json:\"throttle_authenticated_files_api_enabled\"`\n\tThrottleAuthenticatedFilesAPIPeriodInSeconds          int                       `json:\"throttle_authenticated_files_api_period_in_seconds\"`\n\tThrottleAuthenticatedFilesAPIRequestsPerPeriod        int                       `json:\"throttle_authenticated_files_api_requests_per_period\"`\n\tThrottleAuthenticatedGitLFSEnabled                    bool                      `json:\"throttle_authenticated_git_lfs_enabled\"`\n\tThrottleAuthenticatedGitLFSPeriodInSeconds            int                       `json:\"throttle_authenticated_git_lfs_period_in_seconds\"`\n\tThrottleAuthenticatedGitLFSRequestsPerPeriod          int                       `json:\"throttle_authenticated_git_lfs_requests_per_period\"`\n\tThrottleAuthenticatedPackagesAPIEnabled               bool                      `json:\"throttle_authenticated_packages_api_enabled\"`\n\tThrottleAuthenticatedPackagesAPIPeriodInSeconds       int                       `json:\"throttle_authenticated_packages_api_period_in_seconds\"`\n\tThrottleAuthenticatedPackagesAPIRequestsPerPeriod     int                       `json:\"throttle_authenticated_packages_api_requests_per_period\"`\n\tThrottleAuthenticatedWebEnabled                       bool                      `json:\"throttle_authenticated_web_enabled\"`\n\tThrottleAuthenticatedWebPeriodInSeconds               int                       `json:\"throttle_authenticated_web_period_in_seconds\"`\n\tThrottleAuthenticatedWebRequestsPerPeriod             int                       `json:\"throttle_authenticated_web_requests_per_period\"`\n\tThrottleIncidentManagementNotificationEnabled         bool                      `json:\"throttle_incident_management_notification_enabled\"`\n\tThrottleIncidentManagementNotificationPerPeriod       int                       `json:\"throttle_incident_management_notification_per_period\"`\n\tThrottleIncidentManagementNotificationPeriodInSeconds int                       `json:\"throttle_incident_management_notification_period_in_seconds\"`\n\tThrottleProtectedPathsEnabled                         bool                      `json:\"throttle_protected_paths_enabled\"`\n\tThrottleProtectedPathsPeriodInSeconds                 int                       `json:\"throttle_protected_paths_period_in_seconds\"`\n\tThrottleProtectedPathsRequestsPerPeriod               int                       `json:\"throttle_protected_paths_requests_per_period\"`\n\tThrottleUnauthenticatedAPIEnabled                     bool                      `json:\"throttle_unauthenticated_api_enabled\"`\n\tThrottleUnauthenticatedAPIPeriodInSeconds             int                       `json:\"throttle_unauthenticated_api_period_in_seconds\"`\n\tThrottleUnauthenticatedAPIRequestsPerPeriod           int                       `json:\"throttle_unauthenticated_api_requests_per_period\"`\n\tThrottleUnauthenticatedDeprecatedAPIEnabled           bool                      `json:\"throttle_unauthenticated_deprecated_api_enabled\"`\n\tThrottleUnauthenticatedDeprecatedAPIPeriodInSeconds   int                       `json:\"throttle_unauthenticated_deprecated_api_period_in_seconds\"`\n\tThrottleUnauthenticatedDeprecatedAPIRequestsPerPeriod int                       `json:\"throttle_unauthenticated_deprecated_api_requests_per_period\"`\n\tThrottleUnauthenticatedFilesAPIEnabled                bool                      `json:\"throttle_unauthenticated_files_api_enabled\"`\n\tThrottleUnauthenticatedFilesAPIPeriodInSeconds        int                       `json:\"throttle_unauthenticated_files_api_period_in_seconds\"`\n\tThrottleUnauthenticatedFilesAPIRequestsPerPeriod      int                       `json:\"throttle_unauthenticated_files_api_requests_per_period\"`\n\tThrottleUnauthenticatedGitLFSEnabled                  bool                      `json:\"throttle_unauthenticated_git_lfs_enabled\"`\n\tThrottleUnauthenticatedGitLFSPeriodInSeconds          int                       `json:\"throttle_unauthenticated_git_lfs_period_in_seconds\"`\n\tThrottleUnauthenticatedGitLFSRequestsPerPeriod        int                       `json:\"throttle_unauthenticated_git_lfs_requests_per_period\"`\n\tThrottleUnauthenticatedPackagesAPIEnabled             bool                      `json:\"throttle_unauthenticated_packages_api_enabled\"`\n\tThrottleUnauthenticatedPackagesAPIPeriodInSeconds     int                       `json:\"throttle_unauthenticated_packages_api_period_in_seconds\"`\n\tThrottleUnauthenticatedPackagesAPIRequestsPerPeriod   int                       `json:\"throttle_unauthenticated_packages_api_requests_per_period\"`\n\tThrottleUnauthenticatedWebEnabled                     bool                      `json:\"throttle_unauthenticated_web_enabled\"`\n\tThrottleUnauthenticatedWebPeriodInSeconds             int                       `json:\"throttle_unauthenticated_web_period_in_seconds\"`\n\tThrottleUnauthenticatedWebRequestsPerPeriod           int                       `json:\"throttle_unauthenticated_web_requests_per_period\"`\n\tTimeTrackingLimitToHours                              bool                      `json:\"time_tracking_limit_to_hours\"`\n\tTwoFactorGracePeriod                                  int                       `json:\"two_factor_grace_period\"`\n\tUnconfirmedUsersDeleteAfterDays                       int                       `json:\"unconfirmed_users_delete_after_days\"`\n\tUniqueIPsLimitEnabled                                 bool                      `json:\"unique_ips_limit_enabled\"`\n\tUniqueIPsLimitPerUser                                 int                       `json:\"unique_ips_limit_per_user\"`\n\tUniqueIPsLimitTimeWindow                              int                       `json:\"unique_ips_limit_time_window\"`\n\tUpdateRunnerVersionsEnabled                           bool                      `json:\"update_runner_versions_enabled\"`\n\tUpdatedAt                                             *time.Time                `json:\"updated_at\"`\n\tUpdatingNameDisabledForUsers                          bool                      `json:\"updating_name_disabled_for_users\"`\n\tUsagePingEnabled                                      bool                      `json:\"usage_ping_enabled\"`\n\tUsagePingFeaturesEnabled                              bool                      `json:\"usage_ping_features_enabled\"`\n\tUseClickhouseForAnalytics                             bool                      `json:\"use_clickhouse_for_analytics\"`\n\tUserDeactivationEmailsEnabled                         bool                      `json:\"user_deactivation_emails_enabled\"`\n\tUserDefaultExternal                                   bool                      `json:\"user_default_external\"`\n\tUserDefaultInternalRegex                              string                    `json:\"user_default_internal_regex\"`\n\tUserDefaultsToPrivateProfile                          bool                      `json:\"user_defaults_to_private_profile\"`\n\tUserOauthApplications                                 bool                      `json:\"user_oauth_applications\"`\n\tUserShowAddSSHKeyMessage                              bool                      `json:\"user_show_add_ssh_key_message\"`\n\tUsersGetByIDLimit                                     int                       `json:\"users_get_by_id_limit\"`\n\tUsersGetByIDLimitAllowlistRaw                         string                    `json:\"users_get_by_id_limit_allowlist_raw\"`\n\tValidRunnerRegistrars                                 []string                  `json:\"valid_runner_registrars\"`\n\tVersionCheckEnabled                                   bool                      `json:\"version_check_enabled\"`\n\tWebIDEClientsidePreviewEnabled                        bool                      `json:\"web_ide_clientside_preview_enabled\"`\n\tWhatsNewVariant                                       string                    `json:\"whats_new_variant\"`\n\tWikiPageMaxContentBytes                               int                       `json:\"wiki_page_max_content_bytes\"`\n\n\t// Deprecated: Use AbuseNotificationEmail instead.\n\tAdminNotificationEmail string `json:\"admin_notification_email\"`\n\t// Deprecated: Use AllowLocalRequestsFromWebHooksAndServices instead.\n\tAllowLocalRequestsFromHooksAndServices bool `json:\"allow_local_requests_from_hooks_and_services\"`\n\t// Deprecated: Use AssetProxyAllowlist instead.\n\tAssetProxyWhitelist []string `json:\"asset_proxy_whitelist\"`\n\t// Deprecated: Use ThrottleUnauthenticatedWebEnabled or ThrottleUnauthenticatedAPIEnabled instead. (Deprecated in GitLab 14.3)\n\tThrottleUnauthenticatedEnabled bool `json:\"throttle_unauthenticated_enabled\"`\n\t// Deprecated: Use ThrottleUnauthenticatedWebPeriodInSeconds or ThrottleUnauthenticatedAPIPeriodInSeconds instead. (Deprecated in GitLab 14.3)\n\tThrottleUnauthenticatedPeriodInSeconds int `json:\"throttle_unauthenticated_period_in_seconds\"`\n\t// Deprecated: Use ThrottleUnauthenticatedWebRequestsPerPeriod or ThrottleUnauthenticatedAPIRequestsPerPeriod instead. (Deprecated in GitLab 14.3)\n\tThrottleUnauthenticatedRequestsPerPeriod int `json:\"throttle_unauthenticated_requests_per_period\"`\n\t// Deprecated: Replaced by SearchRateLimit in GitLab 14.9 (removed in 15.0).\n\tUserEmailLookupLimit int `json:\"user_email_lookup_limit\"`\n}\n\n// Settings requires a custom unmarshaller in order to properly unmarshal\n// `container_registry_import_created_before` which is either a time.Time or\n// an empty string if no value is set.\nfunc (s *Settings) UnmarshalJSON(data []byte) error {\n\ttype Alias Settings\n\n\traw := make(map[string]interface{})\n\terr := json.Unmarshal(data, &raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// If empty string, remove the value to leave it nil in the response.\n\tif v, ok := raw[\"container_registry_import_created_before\"]; ok && v == \"\" {\n\t\tdelete(raw, \"container_registry_import_created_before\")\n\n\t\tdata, err = json.Marshal(raw)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn json.Unmarshal(data, (*Alias)(s))\n}\n\nfunc (s Settings) String() string {\n\treturn Stringify(s)\n}\n\n// GetSettings gets the current application settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/settings.html#get-current-application-settings\nfunc (s *SettingsService) GetSettings(options ...RequestOptionFunc) (*Settings, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"application/settings\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tas := new(Settings)\n\tresp, err := s.client.Do(req, as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n\n// UpdateSettingsOptions represents the available UpdateSettings() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/settings.html#change-application-settings\ntype UpdateSettingsOptions struct {\n\tAbuseNotificationEmail                                *string                          `url:\"abuse_notification_email,omitempty\" json:\"abuse_notification_email,omitempty\"`\n\tAdminMode                                             *bool                            `url:\"admin_mode,omitempty\" json:\"admin_mode,omitempty\"`\n\tAdminNotificationEmail                                *string                          `url:\"admin_notification_email,omitempty\" json:\"admin_notification_email,omitempty\"`\n\tAfterSignOutPath                                      *string                          `url:\"after_sign_out_path,omitempty\" json:\"after_sign_out_path,omitempty\"`\n\tAfterSignUpText                                       *string                          `url:\"after_sign_up_text,omitempty\" json:\"after_sign_up_text,omitempty\"`\n\tAkismetAPIKey                                         *string                          `url:\"akismet_api_key,omitempty\" json:\"akismet_api_key,omitempty\"`\n\tAkismetEnabled                                        *bool                            `url:\"akismet_enabled,omitempty\" json:\"akismet_enabled,omitempty\"`\n\tAllowAccountDeletion                                  *bool                            `url:\"allow_account_deletion,omitempty\" json:\"allow_account_deletion,omitempty\"`\n\tAllowGroupOwnersToManageLDAP                          *bool                            `url:\"allow_group_owners_to_manage_ldap,omitempty\" json:\"allow_group_owners_to_manage_ldap,omitempty\"`\n\tAllowLocalRequestsFromHooksAndServices                *bool                            `url:\"allow_local_requests_from_hooks_and_services,omitempty\" json:\"allow_local_requests_from_hooks_and_services,omitempty\"`\n\tAllowLocalRequestsFromSystemHooks                     *bool                            `url:\"allow_local_requests_from_system_hooks,omitempty\" json:\"allow_local_requests_from_system_hooks,omitempty\"`\n\tAllowLocalRequestsFromWebHooksAndServices             *bool                            `url:\"allow_local_requests_from_web_hooks_and_services,omitempty\" json:\"allow_local_requests_from_web_hooks_and_services,omitempty\"`\n\tAllowProjectCreationForGuestAndBelow                  *bool                            `url:\"allow_project_creation_for_guest_and_below,omitempty\" json:\"allow_project_creation_for_guest_and_below,omitempty\"`\n\tAllowRunnerRegistrationToken                          *bool                            `url:\"allow_runner_registration_token,omitempty\" json:\"allow_runner_registration_token,omitempty\"`\n\tArchiveBuildsInHumanReadable                          *string                          `url:\"archive_builds_in_human_readable,omitempty\" json:\"archive_builds_in_human_readable,omitempty\"`\n\tASCIIDocMaxIncludes                                   *int                             `url:\"asciidoc_max_includes,omitempty\" json:\"asciidoc_max_includes,omitempty\"`\n\tAssetProxyAllowlist                                   *[]string                        `url:\"asset_proxy_allowlist,omitempty\" json:\"asset_proxy_allowlist,omitempty\"`\n\tAssetProxyEnabled                                     *bool                            `url:\"asset_proxy_enabled,omitempty\" json:\"asset_proxy_enabled,omitempty\"`\n\tAssetProxySecretKey                                   *string                          `url:\"asset_proxy_secret_key,omitempty\" json:\"asset_proxy_secret_key,omitempty\"`\n\tAssetProxyURL                                         *string                          `url:\"asset_proxy_url,omitempty\" json:\"asset_proxy_url,omitempty\"`\n\tAssetProxyWhitelist                                   *[]string                        `url:\"asset_proxy_whitelist,omitempty\" json:\"asset_proxy_whitelist,omitempty\"`\n\tAuthorizedKeysEnabled                                 *bool                            `url:\"authorized_keys_enabled,omitempty\" json:\"authorized_keys_enabled,omitempty\"`\n\tAutoBanUserOnExcessiveProjectsDownload                *bool                            `url:\"auto_ban_user_on_excessive_projects_download,omitempty\" json:\"auto_ban_user_on_excessive_projects_download,omitempty\"`\n\tAutoDevOpsDomain                                      *string                          `url:\"auto_devops_domain,omitempty\" json:\"auto_devops_domain,omitempty\"`\n\tAutoDevOpsEnabled                                     *bool                            `url:\"auto_devops_enabled,omitempty\" json:\"auto_devops_enabled,omitempty\"`\n\tAutomaticPurchasedStorageAllocation                   *bool                            `url:\"automatic_purchased_storage_allocation,omitempty\" json:\"automatic_purchased_storage_allocation,omitempty\"`\n\tBulkImportConcurrentPipelineBatchLimit                *int                             `url:\"bulk_import_concurrent_pipeline_batch_limit,omitempty\" json:\"bulk_import_concurrent_pipeline_batch_limit,omitempty\"`\n\tBulkImportEnabled                                     *bool                            `url:\"bulk_import_enabled,omitempty\" json:\"bulk_import_enabled,omitempty\"`\n\tBulkImportMaxDownloadFileSize                         *int                             `url:\"bulk_import_max_download_file_size,omitempty\" json:\"bulk_import_max_download_file_size,omitempty\"`\n\tCanCreateGroup                                        *bool                            `url:\"can_create_group,omitempty\" json:\"can_create_group,omitempty\"`\n\tCheckNamespacePlan                                    *bool                            `url:\"check_namespace_plan,omitempty\" json:\"check_namespace_plan,omitempty\"`\n\tCIMaxIncludes                                         *int                             `url:\"ci_max_includes,omitempty\" json:\"ci_max_includes,omitempty\"`\n\tCIMaxTotalYAMLSizeBytes                               *int                             `url:\"ci_max_total_yaml_size_bytes,omitempty\" json:\"ci_max_total_yaml_size_bytes,omitempty\"`\n\tCommitEmailHostname                                   *string                          `url:\"commit_email_hostname,omitempty\" json:\"commit_email_hostname,omitempty\"`\n\tConcurrentBitbucketImportJobsLimit                    *int                             `url:\"concurrent_bitbucket_import_jobs_limit,omitempty\" json:\"concurrent_bitbucket_import_jobs_limit,omitempty\"`\n\tConcurrentBitbucketServerImportJobsLimit              *int                             `url:\"concurrent_bitbucket_server_import_jobs_limit,omitempty\" json:\"concurrent_bitbucket_server_import_jobs_limit,omitempty\"`\n\tConcurrentGitHubImportJobsLimit                       *int                             `url:\"concurrent_github_import_jobs_limit,omitempty\" json:\"concurrent_github_import_jobs_limit,omitempty\"`\n\tContainerExpirationPoliciesEnableHistoricEntries      *bool                            `url:\"container_expiration_policies_enable_historic_entries,omitempty\" json:\"container_expiration_policies_enable_historic_entries,omitempty\"`\n\tContainerRegistryCleanupTagsServiceMaxListSize        *int                             `url:\"container_registry_cleanup_tags_service_max_list_size,omitempty\" json:\"container_registry_cleanup_tags_service_max_list_size,omitempty\"`\n\tContainerRegistryDeleteTagsServiceTimeout             *int                             `url:\"container_registry_delete_tags_service_timeout,omitempty\" json:\"container_registry_delete_tags_service_timeout,omitempty\"`\n\tContainerRegistryExpirationPoliciesCaching            *bool                            `url:\"container_registry_expiration_policies_caching,omitempty\" json:\"container_registry_expiration_policies_caching,omitempty\"`\n\tContainerRegistryExpirationPoliciesWorkerCapacity     *int                             `url:\"container_registry_expiration_policies_worker_capacity,omitempty\" json:\"container_registry_expiration_policies_worker_capacity,omitempty\"`\n\tContainerRegistryImportCreatedBefore                  *time.Time                       `url:\"container_registry_import_created_before,omitempty\" json:\"container_registry_import_created_before,omitempty\"`\n\tContainerRegistryImportMaxRetries                     *int                             `url:\"container_registry_import_max_retries,omitempty\" json:\"container_registry_import_max_retries,omitempty\"`\n\tContainerRegistryImportMaxStepDuration                *int                             `url:\"container_registry_import_max_step_duration,omitempty\" json:\"container_registry_import_max_step_duration,omitempty\"`\n\tContainerRegistryImportMaxTagsCount                   *int                             `url:\"container_registry_import_max_tags_count,omitempty\" json:\"container_registry_import_max_tags_count,omitempty\"`\n\tContainerRegistryImportStartMaxRetries                *int                             `url:\"container_registry_import_start_max_retries,omitempty\" json:\"container_registry_import_start_max_retries,omitempty\"`\n\tContainerRegistryImportTargetPlan                     *string                          `url:\"container_registry_import_target_plan,omitempty\" json:\"container_registry_import_target_plan,omitempty\"`\n\tContainerRegistryTokenExpireDelay                     *int                             `url:\"container_registry_token_expire_delay,omitempty\" json:\"container_registry_token_expire_delay,omitempty\"`\n\tCustomHTTPCloneURLRoot                                *string                          `url:\"custom_http_clone_url_root,omitempty\" json:\"custom_http_clone_url_root,omitempty\"`\n\tDNSRebindingProtectionEnabled                         *bool                            `url:\"dns_rebinding_protection_enabled,omitempty\" json:\"dns_rebinding_protection_enabled,omitempty\"`\n\tDSAKeyRestriction                                     *int                             `url:\"dsa_key_restriction,omitempty\" json:\"dsa_key_restriction,omitempty\"`\n\tDeactivateDormantUsers                                *bool                            `url:\"deactivate_dormant_users,omitempty\" json:\"deactivate_dormant_users,omitempty\"`\n\tDeactivateDormantUsersPeriod                          *int                             `url:\"deactivate_dormant_users_period,omitempty\" json:\"deactivate_dormant_users_period,omitempty\"`\n\tDecompressArchiveFileTimeout                          *int                             `url:\"decompress_archive_file_timeout,omitempty\" json:\"decompress_archive_file_timeout,omitempty\"`\n\tDefaultArtifactsExpireIn                              *string                          `url:\"default_artifacts_expire_in,omitempty\" json:\"default_artifacts_expire_in,omitempty\"`\n\tDefaultBranchName                                     *string                          `url:\"default_branch_name,omitempty\" json:\"default_branch_name,omitempty\"`\n\tDefaultBranchProtection                               *int                             `url:\"default_branch_protection,omitempty\" json:\"default_branch_protection,omitempty\"`\n\tDefaultBranchProtectionDefaults                       *BranchProtectionDefaultsOptions `url:\"default_branch_protection_defaults,omitempty\" json:\"default_branch_protection_defaults,omitempty\"`\n\tDefaultCiConfigPath                                   *string                          `url:\"default_ci_config_path,omitempty\" json:\"default_ci_config_path,omitempty\"`\n\tDefaultGroupVisibility                                *VisibilityValue                 `url:\"default_group_visibility,omitempty\" json:\"default_group_visibility,omitempty\"`\n\tDefaultPreferredLanguage                              *string                          `url:\"default_preferred_language,omitempty\" json:\"default_preferred_language,omitempty\"`\n\tDefaultProjectCreation                                *int                             `url:\"default_project_creation,omitempty\" json:\"default_project_creation,omitempty\"`\n\tDefaultProjectDeletionProtection                      *bool                            `url:\"default_project_deletion_protection,omitempty\" json:\"default_project_deletion_protection,omitempty\"`\n\tDefaultProjectVisibility                              *VisibilityValue                 `url:\"default_project_visibility,omitempty\" json:\"default_project_visibility,omitempty\"`\n\tDefaultProjectsLimit                                  *int                             `url:\"default_projects_limit,omitempty\" json:\"default_projects_limit,omitempty\"`\n\tDefaultSnippetVisibility                              *VisibilityValue                 `url:\"default_snippet_visibility,omitempty\" json:\"default_snippet_visibility,omitempty\"`\n\tDefaultSyntaxHighlightingTheme                        *int                             `url:\"default_syntax_highlighting_theme,omitempty\" json:\"default_syntax_highlighting_theme,omitempty\"`\n\tDelayedGroupDeletion                                  *bool                            `url:\"delayed_group_deletion,omitempty\" json:\"delayed_group_deletion,omitempty\"`\n\tDelayedProjectDeletion                                *bool                            `url:\"delayed_project_deletion,omitempty\" json:\"delayed_project_deletion,omitempty\"`\n\tDeleteInactiveProjects                                *bool                            `url:\"delete_inactive_projects,omitempty\" json:\"delete_inactive_projects,omitempty\"`\n\tDeleteUnconfirmedUsers                                *bool                            `url:\"delete_unconfirmed_users,omitempty\" json:\"delete_unconfirmed_users,omitempty\"`\n\tDeletionAdjournedPeriod                               *int                             `url:\"deletion_adjourned_period,omitempty\" json:\"deletion_adjourned_period,omitempty\"`\n\tDiagramsnetEnabled                                    *bool                            `url:\"diagramsnet_enabled,omitempty\" json:\"diagramsnet_enabled,omitempty\"`\n\tDiagramsnetURL                                        *string                          `url:\"diagramsnet_url,omitempty\" json:\"diagramsnet_url,omitempty\"`\n\tDiffMaxFiles                                          *int                             `url:\"diff_max_files,omitempty\" json:\"diff_max_files,omitempty\"`\n\tDiffMaxLines                                          *int                             `url:\"diff_max_lines,omitempty\" json:\"diff_max_lines,omitempty\"`\n\tDiffMaxPatchBytes                                     *int                             `url:\"diff_max_patch_bytes,omitempty\" json:\"diff_max_patch_bytes,omitempty\"`\n\tDisableFeedToken                                      *bool                            `url:\"disable_feed_token,omitempty\" json:\"disable_feed_token,omitempty\"`\n\tDisableAdminOAuthScopes                               *bool                            `url:\"disable_admin_oauth_scopes,omitempty\" json:\"disable_admin_oauth_scopes,omitempty\"`\n\tDisableOverridingApproversPerMergeRequest             *bool                            `url:\"disable_overriding_approvers_per_merge_request,omitempty\" json:\"disable_overriding_approvers_per_merge_request,omitempty\"`\n\tDisablePersonalAccessTokens                           *bool                            `url:\"disable_personal_access_tokens,omitempty\" json:\"disable_personal_access_tokens,omitempty\"`\n\tDisabledOauthSignInSources                            *[]string                        `url:\"disabled_oauth_sign_in_sources,omitempty\" json:\"disabled_oauth_sign_in_sources,omitempty\"`\n\tDomainAllowlist                                       *[]string                        `url:\"domain_allowlist,omitempty\" json:\"domain_allowlist,omitempty\"`\n\tDomainDenylist                                        *[]string                        `url:\"domain_denylist,omitempty\" json:\"domain_denylist,omitempty\"`\n\tDomainDenylistEnabled                                 *bool                            `url:\"domain_denylist_enabled,omitempty\" json:\"domain_denylist_enabled,omitempty\"`\n\tDownstreamPipelineTriggerLimitPerProjectUserSHA       *int                             `url:\"downstream_pipeline_trigger_limit_per_project_user_sha,omitempty\" json:\"downstream_pipeline_trigger_limit_per_project_user_sha,omitempty\"`\n\tDuoFeaturesEnabled                                    *bool                            `url:\"duo_features_enabled,omitempty\" json:\"duo_features_enabled,omitempty\"`\n\tECDSAKeyRestriction                                   *int                             `url:\"ecdsa_key_restriction,omitempty\" json:\"ecdsa_key_restriction,omitempty\"`\n\tECDSASKKeyRestriction                                 *int                             `url:\"ecdsa_sk_key_restriction,omitempty\" json:\"ecdsa_sk_key_restriction,omitempty\"`\n\tEKSAccessKeyID                                        *string                          `url:\"eks_access_key_id,omitempty\" json:\"eks_access_key_id,omitempty\"`\n\tEKSAccountID                                          *string                          `url:\"eks_account_id,omitempty\" json:\"eks_account_id,omitempty\"`\n\tEKSIntegrationEnabled                                 *bool                            `url:\"eks_integration_enabled,omitempty\" json:\"eks_integration_enabled,omitempty\"`\n\tEKSSecretAccessKey                                    *string                          `url:\"eks_secret_access_key,omitempty\" json:\"eks_secret_access_key,omitempty\"`\n\tEd25519KeyRestriction                                 *int                             `url:\"ed25519_key_restriction,omitempty\" json:\"ed25519_key_restriction,omitempty\"`\n\tEd25519SKKeyRestriction                               *int                             `url:\"ed25519_sk_key_restriction,omitempty\" json:\"ed25519_sk_key_restriction,omitempty\"`\n\tElasticsearchAWS                                      *bool                            `url:\"elasticsearch_aws,omitempty\" json:\"elasticsearch_aws,omitempty\"`\n\tElasticsearchAWSAccessKey                             *string                          `url:\"elasticsearch_aws_access_key,omitempty\" json:\"elasticsearch_aws_access_key,omitempty\"`\n\tElasticsearchAWSRegion                                *string                          `url:\"elasticsearch_aws_region,omitempty\" json:\"elasticsearch_aws_region,omitempty\"`\n\tElasticsearchAWSSecretAccessKey                       *string                          `url:\"elasticsearch_aws_secret_access_key,omitempty\" json:\"elasticsearch_aws_secret_access_key,omitempty\"`\n\tElasticsearchAnalyzersKuromojiEnabled                 *bool                            `url:\"elasticsearch_analyzers_kuromoji_enabled,omitempty\" json:\"elasticsearch_analyzers_kuromoji_enabled,omitempty\"`\n\tElasticsearchAnalyzersKuromojiSearch                  *int                             `url:\"elasticsearch_analyzers_kuromoji_search,omitempty\" json:\"elasticsearch_analyzers_kuromoji_search,omitempty\"`\n\tElasticsearchAnalyzersSmartCNEnabled                  *bool                            `url:\"elasticsearch_analyzers_smartcn_enabled,omitempty\" json:\"elasticsearch_analyzers_smartcn_enabled,omitempty\"`\n\tElasticsearchAnalyzersSmartCNSearch                   *int                             `url:\"elasticsearch_analyzers_smartcn_search,omitempty\" json:\"elasticsearch_analyzers_smartcn_search,omitempty\"`\n\tElasticsearchClientRequestTimeout                     *int                             `url:\"elasticsearch_client_request_timeout,omitempty\" json:\"elasticsearch_client_request_timeout,omitempty\"`\n\tElasticsearchIndexedFieldLengthLimit                  *int                             `url:\"elasticsearch_indexed_field_length_limit,omitempty\" json:\"elasticsearch_indexed_field_length_limit,omitempty\"`\n\tElasticsearchIndexedFileSizeLimitKB                   *int                             `url:\"elasticsearch_indexed_file_size_limit_kb,omitempty\" json:\"elasticsearch_indexed_file_size_limit_kb,omitempty\"`\n\tElasticsearchIndexing                                 *bool                            `url:\"elasticsearch_indexing,omitempty\" json:\"elasticsearch_indexing,omitempty\"`\n\tElasticsearchLimitIndexing                            *bool                            `url:\"elasticsearch_limit_indexing,omitempty\" json:\"elasticsearch_limit_indexing,omitempty\"`\n\tElasticsearchMaxBulkConcurrency                       *int                             `url:\"elasticsearch_max_bulk_concurrency,omitempty\" json:\"elasticsearch_max_bulk_concurrency,omitempty\"`\n\tElasticsearchMaxBulkSizeMB                            *int                             `url:\"elasticsearch_max_bulk_size_mb,omitempty\" json:\"elasticsearch_max_bulk_size_mb,omitempty\"`\n\tElasticsearchMaxCodeIndexingConcurrency               *int                             `url:\"elasticsearch_max_code_indexing_concurrency,omitempty\" json:\"elasticsearch_max_code_indexing_concurrency,omitempty\"`\n\tElasticsearchNamespaceIDs                             *[]int                           `url:\"elasticsearch_namespace_ids,omitempty\" json:\"elasticsearch_namespace_ids,omitempty\"`\n\tElasticsearchPassword                                 *string                          `url:\"elasticsearch_password,omitempty\" json:\"elasticsearch_password,omitempty\"`\n\tElasticsearchPauseIndexing                            *bool                            `url:\"elasticsearch_pause_indexing,omitempty\" json:\"elasticsearch_pause_indexing,omitempty\"`\n\tElasticsearchProjectIDs                               *[]int                           `url:\"elasticsearch_project_ids,omitempty\" json:\"elasticsearch_project_ids,omitempty\"`\n\tElasticsearchReplicas                                 *int                             `url:\"elasticsearch_replicas,omitempty\" json:\"elasticsearch_replicas,omitempty\"`\n\tElasticsearchRequeueWorkers                           *bool                            `url:\"elasticsearch_requeue_workers,omitempty\" json:\"elasticsearch_requeue_workers,omitempty\"`\n\tElasticsearchSearch                                   *bool                            `url:\"elasticsearch_search,omitempty\" json:\"elasticsearch_search,omitempty\"`\n\tElasticsearchShards                                   *int                             `url:\"elasticsearch_shards,omitempty\" json:\"elasticsearch_shards,omitempty\"`\n\tElasticsearchURL                                      *string                          `url:\"elasticsearch_url,omitempty\" json:\"elasticsearch_url,omitempty\"`\n\tElasticsearchUsername                                 *string                          `url:\"elasticsearch_username,omitempty\" json:\"elasticsearch_username,omitempty\"`\n\tElasticsearchWorkerNumberOfShards                     *int                             `url:\"elasticsearch_worker_number_of_shards,omitempty\" json:\"elasticsearch_worker_number_of_shards,omitempty\"`\n\tEmailAdditionalText                                   *string                          `url:\"email_additional_text,omitempty\" json:\"email_additional_text,omitempty\"`\n\tEmailAuthorInBody                                     *bool                            `url:\"email_author_in_body,omitempty\" json:\"email_author_in_body,omitempty\"`\n\tEmailConfirmationSetting                              *string                          `url:\"email_confirmation_setting,omitempty\" json:\"email_confirmation_setting,omitempty\"`\n\tEmailRestrictions                                     *string                          `url:\"email_restrictions,omitempty\" json:\"email_restrictions,omitempty\"`\n\tEmailRestrictionsEnabled                              *bool                            `url:\"email_restrictions_enabled,omitempty\" json:\"email_restrictions_enabled,omitempty\"`\n\tEnableArtifactExternalRedirectWarningPage             *bool                            `url:\"enable_artifact_external_redirect_warning_page,omitempty\" json:\"enable_artifact_external_redirect_warning_page,omitempty\"`\n\tEnabledGitAccessProtocol                              *string                          `url:\"enabled_git_access_protocol,omitempty\" json:\"enabled_git_access_protocol,omitempty\"`\n\tEnforceNamespaceStorageLimit                          *bool                            `url:\"enforce_namespace_storage_limit,omitempty\" json:\"enforce_namespace_storage_limit,omitempty\"`\n\tEnforcePATExpiration                                  *bool                            `url:\"enforce_pat_expiration,omitempty\" json:\"enforce_pat_expiration,omitempty\"`\n\tEnforceSSHKeyExpiration                               *bool                            `url:\"enforce_ssh_key_expiration,omitempty\" json:\"enforce_ssh_key_expiration,omitempty\"`\n\tEnforceTerms                                          *bool                            `url:\"enforce_terms,omitempty\" json:\"enforce_terms,omitempty\"`\n\tExternalAuthClientCert                                *string                          `url:\"external_auth_client_cert,omitempty\" json:\"external_auth_client_cert,omitempty\"`\n\tExternalAuthClientKey                                 *string                          `url:\"external_auth_client_key,omitempty\" json:\"external_auth_client_key,omitempty\"`\n\tExternalAuthClientKeyPass                             *string                          `url:\"external_auth_client_key_pass,omitempty\" json:\"external_auth_client_key_pass,omitempty\"`\n\tExternalAuthorizationServiceDefaultLabel              *string                          `url:\"external_authorization_service_default_label,omitempty\" json:\"external_authorization_service_default_label,omitempty\"`\n\tExternalAuthorizationServiceEnabled                   *bool                            `url:\"external_authorization_service_enabled,omitempty\" json:\"external_authorization_service_enabled,omitempty\"`\n\tExternalAuthorizationServiceTimeout                   *float64                         `url:\"external_authorization_service_timeout,omitempty\" json:\"external_authorization_service_timeout,omitempty\"`\n\tExternalAuthorizationServiceURL                       *string                          `url:\"external_authorization_service_url,omitempty\" json:\"external_authorization_service_url,omitempty\"`\n\tExternalPipelineValidationServiceTimeout              *int                             `url:\"external_pipeline_validation_service_timeout,omitempty\" json:\"external_pipeline_validation_service_timeout,omitempty\"`\n\tExternalPipelineValidationServiceToken                *string                          `url:\"external_pipeline_validation_service_token,omitempty\" json:\"external_pipeline_validation_service_token,omitempty\"`\n\tExternalPipelineValidationServiceURL                  *string                          `url:\"external_pipeline_validation_service_url,omitempty\" json:\"external_pipeline_validation_service_url,omitempty\"`\n\tFailedLoginAttemptsUnlockPeriodInMinutes              *int                             `url:\"failed_login_attempts_unlock_period_in_minutes,omitempty\" json:\"failed_login_attempts_unlock_period_in_minutes,omitempty\"`\n\tFileTemplateProjectID                                 *int                             `url:\"file_template_project_id,omitempty\" json:\"file_template_project_id,omitempty\"`\n\tFirstDayOfWeek                                        *int                             `url:\"first_day_of_week,omitempty\" json:\"first_day_of_week,omitempty\"`\n\tFlocEnabled                                           *bool                            `url:\"floc_enabled,omitempty\" json:\"floc_enabled,omitempty\"`\n\tGeoNodeAllowedIPs                                     *string                          `url:\"geo_node_allowed_ips,omitempty\" json:\"geo_node_allowed_ips,omitempty\"`\n\tGeoStatusTimeout                                      *int                             `url:\"geo_status_timeout,omitempty\" json:\"geo_status_timeout,omitempty\"`\n\tGitRateLimitUsersAlertlist                            *[]string                        `url:\"git_rate_limit_users_alertlist,omitempty\" json:\"git_rate_limit_users_alertlist,omitempty\"`\n\tGitTwoFactorSessionExpiry                             *int                             `url:\"git_two_factor_session_expiry,omitempty\" json:\"git_two_factor_session_expiry,omitempty\"`\n\tGitalyTimeoutDefault                                  *int                             `url:\"gitaly_timeout_default,omitempty\" json:\"gitaly_timeout_default,omitempty\"`\n\tGitalyTimeoutFast                                     *int                             `url:\"gitaly_timeout_fast,omitempty\" json:\"gitaly_timeout_fast,omitempty\"`\n\tGitalyTimeoutMedium                                   *int                             `url:\"gitaly_timeout_medium,omitempty\" json:\"gitaly_timeout_medium,omitempty\"`\n\tGitlabDedicatedInstance                               *bool                            `url:\"gitlab_dedicated_instance,omitempty\" json:\"gitlab_dedicated_instance,omitempty\"`\n\tGitlabEnvironmentToolkitInstance                      *bool                            `url:\"gitlab_environment_toolkit_instance,omitempty\" json:\"gitlab_environment_toolkit_instance,omitempty\"`\n\tGitlabShellOperationLimit                             *int                             `url:\"gitlab_shell_operation_limit,omitempty\" json:\"gitlab_shell_operation_limit,omitempty\"`\n\tGitpodEnabled                                         *bool                            `url:\"gitpod_enabled,omitempty\" json:\"gitpod_enabled,omitempty\"`\n\tGitpodURL                                             *string                          `url:\"gitpod_url,omitempty\" json:\"gitpod_url,omitempty\"`\n\tGitRateLimitUsersAllowlist                            *[]string                        `url:\"git_rate_limit_users_allowlist,omitempty\" json:\"git_rate_limit_users_allowlist,omitempty\"`\n\tGloballyAllowedIPs                                    *string                          `url:\"globally_allowed_ips,omitempty\" json:\"globally_allowed_ips,omitempty\"`\n\tGrafanaEnabled                                        *bool                            `url:\"grafana_enabled,omitempty\" json:\"grafana_enabled,omitempty\"`\n\tGrafanaURL                                            *string                          `url:\"grafana_url,omitempty\" json:\"grafana_url,omitempty\"`\n\tGravatarEnabled                                       *bool                            `url:\"gravatar_enabled,omitempty\" json:\"gravatar_enabled,omitempty\"`\n\tGroupDownloadExportLimit                              *int                             `url:\"group_download_export_limit,omitempty\" json:\"group_download_export_limit,omitempty\"`\n\tGroupExportLimit                                      *int                             `url:\"group_export_limit,omitempty\" json:\"group_export_limit,omitempty\"`\n\tGroupImportLimit                                      *int                             `url:\"group_import_limit,omitempty\" json:\"group_import_limit,omitempty\"`\n\tGroupOwnersCanManageDefaultBranchProtection           *bool                            `url:\"group_owners_can_manage_default_branch_protection,omitempty\" json:\"group_owners_can_manage_default_branch_protection,omitempty\"`\n\tGroupRunnerTokenExpirationInterval                    *int                             `url:\"group_runner_token_expiration_interval,omitempty\" json:\"group_runner_token_expiration_interval,omitempty\"`\n\tHTMLEmailsEnabled                                     *bool                            `url:\"html_emails_enabled,omitempty\" json:\"html_emails_enabled,omitempty\"`\n\tHashedStorageEnabled                                  *bool                            `url:\"hashed_storage_enabled,omitempty\" json:\"hashed_storage_enabled,omitempty\"`\n\tHelpPageDocumentationBaseURL                          *string                          `url:\"help_page_documentation_base_url,omitempty\" json:\"help_page_documentation_base_url,omitempty\"`\n\tHelpPageHideCommercialContent                         *bool                            `url:\"help_page_hide_commercial_content,omitempty\" json:\"help_page_hide_commercial_content,omitempty\"`\n\tHelpPageSupportURL                                    *string                          `url:\"help_page_support_url,omitempty\" json:\"help_page_support_url,omitempty\"`\n\tHelpPageText                                          *string                          `url:\"help_page_text,omitempty\" json:\"help_page_text,omitempty\"`\n\tHelpText                                              *string                          `url:\"help_text,omitempty\" json:\"help_text,omitempty\"`\n\tHideThirdPartyOffers                                  *bool                            `url:\"hide_third_party_offers,omitempty\" json:\"hide_third_party_offers,omitempty\"`\n\tHomePageURL                                           *string                          `url:\"home_page_url,omitempty\" json:\"home_page_url,omitempty\"`\n\tHousekeepingBitmapsEnabled                            *bool                            `url:\"housekeeping_bitmaps_enabled,omitempty\" json:\"housekeeping_bitmaps_enabled,omitempty\"`\n\tHousekeepingEnabled                                   *bool                            `url:\"housekeeping_enabled,omitempty\" json:\"housekeeping_enabled,omitempty\"`\n\tHousekeepingFullRepackPeriod                          *int                             `url:\"housekeeping_full_repack_period,omitempty\" json:\"housekeeping_full_repack_period,omitempty\"`\n\tHousekeepingGcPeriod                                  *int                             `url:\"housekeeping_gc_period,omitempty\" json:\"housekeeping_gc_period,omitempty\"`\n\tHousekeepingIncrementalRepackPeriod                   *int                             `url:\"housekeeping_incremental_repack_period,omitempty\" json:\"housekeeping_incremental_repack_period,omitempty\"`\n\tHousekeepingOptimizeRepositoryPeriod                  *int                             `url:\"housekeeping_optimize_repository_period,omitempty\" json:\"housekeeping_optimize_repository_period,omitempty\"`\n\tImportSources                                         *[]string                        `url:\"import_sources,omitempty\" json:\"import_sources,omitempty\"`\n\tInactiveProjectsDeleteAfterMonths                     *int                             `url:\"inactive_projects_delete_after_months,omitempty\" json:\"inactive_projects_delete_after_months,omitempty\"`\n\tInactiveProjectsMinSizeMB                             *int                             `url:\"inactive_projects_min_size_mb,omitempty\" json:\"inactive_projects_min_size_mb,omitempty\"`\n\tInactiveProjectsSendWarningEmailAfterMonths           *int                             `url:\"inactive_projects_send_warning_email_after_months,omitempty\" json:\"inactive_projects_send_warning_email_after_months,omitempty\"`\n\tIncludeOptionalMetricsInServicePing                   *bool                            `url:\"include_optional_metrics_in_service_ping,omitempty\" json:\"include_optional_metrics_in_service_ping,omitempty\"`\n\tInProductMarketingEmailsEnabled                       *bool                            `url:\"in_product_marketing_emails_enabled,omitempty\" json:\"in_product_marketing_emails_enabled,omitempty\"`\n\tInvisibleCaptchaEnabled                               *bool                            `url:\"invisible_captcha_enabled,omitempty\" json:\"invisible_captcha_enabled,omitempty\"`\n\tIssuesCreateLimit                                     *int                             `url:\"issues_create_limit,omitempty\" json:\"issues_create_limit,omitempty\"`\n\tJiraConnectApplicationKey                             *string                          `url:\"jira_connect_application_key,omitempty\" json:\"jira_connect_application_key,omitempty\"`\n\tJiraConnectPublicKeyStorageEnabled                    *bool                            `url:\"jira_connect_public_key_storage_enabled,omitempty\" json:\"jira_connect_public_key_storage_enabled,omitempty\"`\n\tJiraConnectProxyURL                                   *string                          `url:\"jira_connect_proxy_url,omitempty\" json:\"jira_connect_proxy_url,omitempty\"`\n\tKeepLatestArtifact                                    *bool                            `url:\"keep_latest_artifact,omitempty\" json:\"keep_latest_artifact,omitempty\"`\n\tKrokiEnabled                                          *bool                            `url:\"kroki_enabled,omitempty\" json:\"kroki_enabled,omitempty\"`\n\tKrokiFormats                                          *map[string]bool                 `url:\"kroki_formats,omitempty\" json:\"kroki_formats,omitempty\"`\n\tKrokiURL                                              *string                          `url:\"kroki_url,omitempty\" json:\"kroki_url,omitempty\"`\n\tLocalMarkdownVersion                                  *int                             `url:\"local_markdown_version,omitempty\" json:\"local_markdown_version,omitempty\"`\n\tLockDuoFeaturesEnabled                                *bool                            `url:\"lock_duo_features_enabled,omitempty\" json:\"lock_duo_features_enabled,omitempty\"`\n\tLockMembershipsToLDAP                                 *bool                            `url:\"lock_memberships_to_ldap,omitempty\" json:\"lock_memberships_to_ldap,omitempty\"`\n\tLoginRecaptchaProtectionEnabled                       *bool                            `url:\"login_recaptcha_protection_enabled,omitempty\" json:\"login_recaptcha_protection_enabled,omitempty\"`\n\tMailgunEventsEnabled                                  *bool                            `url:\"mailgun_events_enabled,omitempty\" json:\"mailgun_events_enabled,omitempty\"`\n\tMailgunSigningKey                                     *string                          `url:\"mailgun_signing_key,omitempty\" json:\"mailgun_signing_key,omitempty\"`\n\tMaintenanceMode                                       *bool                            `url:\"maintenance_mode,omitempty\" json:\"maintenance_mode,omitempty\"`\n\tMaintenanceModeMessage                                *string                          `url:\"maintenance_mode_message,omitempty\" json:\"maintenance_mode_message,omitempty\"`\n\tMavenPackageRequestsForwarding                        *bool                            `url:\"maven_package_requests_forwarding,omitempty\" json:\"maven_package_requests_forwarding,omitempty\"`\n\tMaxArtifactsSize                                      *int                             `url:\"max_artifacts_size,omitempty\" json:\"max_artifacts_size,omitempty\"`\n\tMaxAttachmentSize                                     *int                             `url:\"max_attachment_size,omitempty\" json:\"max_attachment_size,omitempty\"`\n\tMaxDecompressedArchiveSize                            *int                             `url:\"max_decompressed_archive_size,omitempty\" json:\"max_decompressed_archive_size,omitempty\"`\n\tMaxExportSize                                         *int                             `url:\"max_export_size,omitempty\" json:\"max_export_size,omitempty\"`\n\tMaxImportRemoteFileSize                               *int                             `url:\"max_import_remote_file_size,omitempty\" json:\"max_import_remote_file_size,omitempty\"`\n\tMaxImportSize                                         *int                             `url:\"max_import_size,omitempty\" json:\"max_import_size,omitempty\"`\n\tMaxLoginAttempts                                      *int                             `url:\"max_login_attempts,omitempty\" json:\"max_login_attempts,omitempty\"`\n\tMaxNumberOfRepositoryDownloads                        *int                             `url:\"max_number_of_repository_downloads,omitempty\" json:\"max_number_of_repository_downloads,omitempty\"`\n\tMaxNumberOfRepositoryDownloadsWithinTimePeriod        *int                             `url:\"max_number_of_repository_downloads_within_time_period,omitempty\" json:\"max_number_of_repository_downloads_within_time_period,omitempty\"`\n\tMaxPagesSize                                          *int                             `url:\"max_pages_size,omitempty\" json:\"max_pages_size,omitempty\"`\n\tMaxPersonalAccessTokenLifetime                        *int                             `url:\"max_personal_access_token_lifetime,omitempty\" json:\"max_personal_access_token_lifetime,omitempty\"`\n\tMaxSSHKeyLifetime                                     *int                             `url:\"max_ssh_key_lifetime,omitempty\" json:\"max_ssh_key_lifetime,omitempty\"`\n\tMaxTerraformStateSizeBytes                            *int                             `url:\"max_terraform_state_size_bytes,omitempty\" json:\"max_terraform_state_size_bytes,omitempty\"`\n\tMaxYAMLDepth                                          *int                             `url:\"max_yaml_depth,omitempty\" json:\"max_yaml_depth,omitempty\"`\n\tMaxYAMLSizeBytes                                      *int                             `url:\"max_yaml_size_bytes,omitempty\" json:\"max_yaml_size_bytes,omitempty\"`\n\tMetricsMethodCallThreshold                            *int                             `url:\"metrics_method_call_threshold,omitempty\" json:\"metrics_method_call_threshold,omitempty\"`\n\tMinimumPasswordLength                                 *int                             `url:\"minimum_password_length,omitempty\" json:\"minimum_password_length,omitempty\"`\n\tMirrorAvailable                                       *bool                            `url:\"mirror_available,omitempty\" json:\"mirror_available,omitempty\"`\n\tMirrorCapacityThreshold                               *int                             `url:\"mirror_capacity_threshold,omitempty\" json:\"mirror_capacity_threshold,omitempty\"`\n\tMirrorMaxCapacity                                     *int                             `url:\"mirror_max_capacity,omitempty\" json:\"mirror_max_capacity,omitempty\"`\n\tMirrorMaxDelay                                        *int                             `url:\"mirror_max_delay,omitempty\" json:\"mirror_max_delay,omitempty\"`\n\tNPMPackageRequestsForwarding                          *bool                            `url:\"npm_package_requests_forwarding,omitempty\" json:\"npm_package_requests_forwarding,omitempty\"`\n\tNotesCreateLimit                                      *int                             `url:\"notes_create_limit,omitempty\" json:\"notes_create_limit,omitempty\"`\n\tNotifyOnUnknownSignIn                                 *bool                            `url:\"notify_on_unknown_sign_in,omitempty\" json:\"notify_on_unknown_sign_in,omitempty\"`\n\tNugetSkipMetadataURLValidation                        *bool                            `url:\"nuget_skip_metadata_url_validation,omitempty\" json:\"nuget_skip_metadata_url_validation,omitempty\"`\n\tOutboundLocalRequestsAllowlistRaw                     *string                          `url:\"outbound_local_requests_allowlist_raw,omitempty\" json:\"outbound_local_requests_allowlist_raw,omitempty\"`\n\tOutboundLocalRequestsWhitelist                        *[]string                        `url:\"outbound_local_requests_whitelist,omitempty\" json:\"outbound_local_requests_whitelist,omitempty\"`\n\tPackageMetadataPURLTypes                              *[]int                           `url:\"package_metadata_purl_types,omitempty\" json:\"package_metadata_purl_types,omitempty\"`\n\tPackageRegistryAllowAnyoneToPullOption                *bool                            `url:\"package_registry_allow_anyone_to_pull_option,omitempty\" json:\"package_registry_allow_anyone_to_pull_option,omitempty\"`\n\tPackageRegistryCleanupPoliciesWorkerCapacity          *int                             `url:\"package_registry_cleanup_policies_worker_capacity,omitempty\" json:\"package_registry_cleanup_policies_worker_capacity,omitempty\"`\n\tPagesDomainVerificationEnabled                        *bool                            `url:\"pages_domain_verification_enabled,omitempty\" json:\"pages_domain_verification_enabled,omitempty\"`\n\tPasswordAuthenticationEnabledForGit                   *bool                            `url:\"password_authentication_enabled_for_git,omitempty\" json:\"password_authentication_enabled_for_git,omitempty\"`\n\tPasswordAuthenticationEnabledForWeb                   *bool                            `url:\"password_authentication_enabled_for_web,omitempty\" json:\"password_authentication_enabled_for_web,omitempty\"`\n\tPasswordNumberRequired                                *bool                            `url:\"password_number_required,omitempty\" json:\"password_number_required,omitempty\"`\n\tPasswordSymbolRequired                                *bool                            `url:\"password_symbol_required,omitempty\" json:\"password_symbol_required,omitempty\"`\n\tPasswordUppercaseRequired                             *bool                            `url:\"password_uppercase_required,omitempty\" json:\"password_uppercase_required,omitempty\"`\n\tPasswordLowercaseRequired                             *bool                            `url:\"password_lowercase_required,omitempty\" json:\"password_lowercase_required,omitempty\"`\n\tPerformanceBarAllowedGroupID                          *int                             `url:\"performance_bar_allowed_group_id,omitempty\" json:\"performance_bar_allowed_group_id,omitempty\"`\n\tPerformanceBarAllowedGroupPath                        *string                          `url:\"performance_bar_allowed_group_path,omitempty\" json:\"performance_bar_allowed_group_path,omitempty\"`\n\tPerformanceBarEnabled                                 *bool                            `url:\"performance_bar_enabled,omitempty\" json:\"performance_bar_enabled,omitempty\"`\n\tPersonalAccessTokenPrefix                             *string                          `url:\"personal_access_token_prefix,omitempty\" json:\"personal_access_token_prefix,omitempty\"`\n\tPlantumlEnabled                                       *bool                            `url:\"plantuml_enabled,omitempty\" json:\"plantuml_enabled,omitempty\"`\n\tPlantumlURL                                           *string                          `url:\"plantuml_url,omitempty\" json:\"plantuml_url,omitempty\"`\n\tPipelineLimitPerProjectUserSha                        *int                             `url:\"pipeline_limit_per_project_user_sha,omitempty\" json:\"pipeline_limit_per_project_user_sha,omitempty\"`\n\tPollingIntervalMultiplier                             *float64                         `url:\"polling_interval_multiplier,omitempty\" json:\"polling_interval_multiplier,omitempty\"`\n\tPreventMergeRequestsAuthorApproval                    *bool                            `url:\"prevent_merge_requests_author_approval,omitempty\" json:\"prevent_merge_requests_author_approval,omitempty\"`\n\tPreventMergeRequestsCommittersApproval                *bool                            `url:\"prevent_merge_requests_committers_approval,omitempty\" json:\"prevent_merge_requests_committers_approval,omitempty\"`\n\tProjectDownloadExportLimit                            *int                             `url:\"project_download_export_limit,omitempty\" json:\"project_download_export_limit,omitempty\"`\n\tProjectExportEnabled                                  *bool                            `url:\"project_export_enabled,omitempty\" json:\"project_export_enabled,omitempty\"`\n\tProjectExportLimit                                    *int                             `url:\"project_export_limit,omitempty\" json:\"project_export_limit,omitempty\"`\n\tProjectImportLimit                                    *int                             `url:\"project_import_limit,omitempty\" json:\"project_import_limit,omitempty\"`\n\tProjectJobsAPIRateLimit                               *int                             `url:\"project_jobs_api_rate_limit,omitempty\" json:\"project_jobs_api_rate_limit,omitempty\"`\n\tProjectRunnerTokenExpirationInterval                  *int                             `url:\"project_runner_token_expiration_interval,omitempty\" json:\"project_runner_token_expiration_interval,omitempty\"`\n\tProjectsAPIRateLimitUnauthenticated                   *int                             `url:\"projects_api_rate_limit_unauthenticated,omitempty\" json:\"projects_api_rate_limit_unauthenticated,omitempty\"`\n\tPrometheusMetricsEnabled                              *bool                            `url:\"prometheus_metrics_enabled,omitempty\" json:\"prometheus_metrics_enabled,omitempty\"`\n\tProtectedCIVariables                                  *bool                            `url:\"protected_ci_variables,omitempty\" json:\"protected_ci_variables,omitempty\"`\n\tPseudonymizerEnabled                                  *bool                            `url:\"pseudonymizer_enabled,omitempty\" json:\"pseudonymizer_enabled,omitempty\"`\n\tPushEventActivitiesLimit                              *int                             `url:\"push_event_activities_limit,omitempty\" json:\"push_event_activities_limit,omitempty\"`\n\tPushEventHooksLimit                                   *int                             `url:\"push_event_hooks_limit,omitempty\" json:\"push_event_hooks_limit,omitempty\"`\n\tPyPIPackageRequestsForwarding                         *bool                            `url:\"pypi_package_requests_forwarding,omitempty\" json:\"pypi_package_requests_forwarding,omitempty\"`\n\tRSAKeyRestriction                                     *int                             `url:\"rsa_key_restriction,omitempty\" json:\"rsa_key_restriction,omitempty\"`\n\tRateLimitingResponseText                              *string                          `url:\"rate_limiting_response_text,omitempty\" json:\"rate_limiting_response_text,omitempty\"`\n\tRawBlobRequestLimit                                   *int                             `url:\"raw_blob_request_limit,omitempty\" json:\"raw_blob_request_limit,omitempty\"`\n\tRecaptchaEnabled                                      *bool                            `url:\"recaptcha_enabled,omitempty\" json:\"recaptcha_enabled,omitempty\"`\n\tRecaptchaPrivateKey                                   *string                          `url:\"recaptcha_private_key,omitempty\" json:\"recaptcha_private_key,omitempty\"`\n\tRecaptchaSiteKey                                      *string                          `url:\"recaptcha_site_key,omitempty\" json:\"recaptcha_site_key,omitempty\"`\n\tReceiveMaxInputSize                                   *int                             `url:\"receive_max_input_size,omitempty\" json:\"receive_max_input_size,omitempty\"`\n\tReceptiveClusterAgentsEnabled                         *bool                            `url:\"receptive_cluster_agents_enabled,omitempty\" json:\"receptive_cluster_agents_enabled,omitempty\"`\n\tRememberMeEnabled                                     *bool                            `url:\"remember_me_enabled,omitempty\" json:\"remember_me_enabled,omitempty\"`\n\tRepositoryChecksEnabled                               *bool                            `url:\"repository_checks_enabled,omitempty\" json:\"repository_checks_enabled,omitempty\"`\n\tRepositorySizeLimit                                   *int                             `url:\"repository_size_limit,omitempty\" json:\"repository_size_limit,omitempty\"`\n\tRepositoryStorages                                    *[]string                        `url:\"repository_storages,omitempty\" json:\"repository_storages,omitempty\"`\n\tRepositoryStoragesWeighted                            *map[string]int                  `url:\"repository_storages_weighted,omitempty\" json:\"repository_storages_weighted,omitempty\"`\n\tRequireAdminApprovalAfterUserSignup                   *bool                            `url:\"require_admin_approval_after_user_signup,omitempty\" json:\"require_admin_approval_after_user_signup,omitempty\"`\n\tRequireAdminTwoFactorAuthentication                   *bool                            `url:\"require_admin_two_factor_authentication,omitempty\" json:\"require_admin_two_factor_authentication,omitempty\"`\n\tRequirePersonalAccessTokenExpiry                      *bool                            `url:\"require_personal_access_token_expiry,omitempty\" json:\"require_personal_access_token_expiry,omitempty\"`\n\tRequireTwoFactorAuthentication                        *bool                            `url:\"require_two_factor_authentication,omitempty\" json:\"require_two_factor_authentication,omitempty\"`\n\tRestrictedVisibilityLevels                            *[]VisibilityValue               `url:\"restricted_visibility_levels,omitempty\" json:\"restricted_visibility_levels,omitempty\"`\n\tRunnerTokenExpirationInterval                         *int                             `url:\"runner_token_expiration_interval,omitempty\" json:\"runner_token_expiration_interval,omitempty\"`\n\tSearchRateLimit                                       *int                             `url:\"search_rate_limit,omitempty\" json:\"search_rate_limit,omitempty\"`\n\tSearchRateLimitUnauthenticated                        *int                             `url:\"search_rate_limit_unauthenticated,omitempty\" json:\"search_rate_limit_unauthenticated,omitempty\"`\n\tSecretDetectionRevocationTokenTypesURL                *string                          `url:\"secret_detection_revocation_token_types_url,omitempty\" json:\"secret_detection_revocation_token_types_url,omitempty\"`\n\tSecretDetectionTokenRevocationEnabled                 *bool                            `url:\"secret_detection_token_revocation_enabled,omitempty\" json:\"secret_detection_token_revocation_enabled,omitempty\"`\n\tSecretDetectionTokenRevocationToken                   *string                          `url:\"secret_detection_token_revocation_token,omitempty\" json:\"secret_detection_token_revocation_token,omitempty\"`\n\tSecretDetectionTokenRevocationURL                     *string                          `url:\"secret_detection_token_revocation_url,omitempty\" json:\"secret_detection_token_revocation_url,omitempty\"`\n\tSecurityApprovalPoliciesLimit                         *int                             `url:\"security_approval_policies_limit,omitempty\" json:\"security_approval_policies_limit,omitempty\"`\n\tSecurityPolicyGlobalGroupApproversEnabled             *bool                            `url:\"security_policy_global_group_approvers_enabled,omitempty\" json:\"security_policy_global_group_approvers_enabled,omitempty\"`\n\tSecurityTXTContent                                    *string                          `url:\"security_txt_content,omitempty\" json:\"security_txt_content,omitempty\"`\n\tSendUserConfirmationEmail                             *bool                            `url:\"send_user_confirmation_email,omitempty\" json:\"send_user_confirmation_email,omitempty\"`\n\tSentryClientsideDSN                                   *string                          `url:\"sentry_clientside_dsn,omitempty\" json:\"sentry_clientside_dsn,omitempty\"`\n\tSentryDSN                                             *string                          `url:\"sentry_dsn,omitempty\" json:\"sentry_dsn,omitempty\"`\n\tSentryEnabled                                         *string                          `url:\"sentry_enabled,omitempty\" json:\"sentry_enabled,omitempty\"`\n\tSentryEnvironment                                     *string                          `url:\"sentry_environment,omitempty\" json:\"sentry_environment,omitempty\"`\n\tServiceAccessTokensExpirationEnforced                 *bool                            `url:\"service_access_tokens_expiration_enforced,omitempty\" json:\"service_access_tokens_expiration_enforced,omitempty\"`\n\tSessionExpireDelay                                    *int                             `url:\"session_expire_delay,omitempty\" json:\"session_expire_delay,omitempty\"`\n\tSharedRunnersEnabled                                  *bool                            `url:\"shared_runners_enabled,omitempty\" json:\"shared_runners_enabled,omitempty\"`\n\tSharedRunnersMinutes                                  *int                             `url:\"shared_runners_minutes,omitempty\" json:\"shared_runners_minutes,omitempty\"`\n\tSharedRunnersText                                     *string                          `url:\"shared_runners_text,omitempty\" json:\"shared_runners_text,omitempty\"`\n\tSidekiqJobLimiterCompressionThresholdBytes            *int                             `url:\"sidekiq_job_limiter_compression_threshold_bytes,omitempty\" json:\"sidekiq_job_limiter_compression_threshold_bytes,omitempty\"`\n\tSidekiqJobLimiterLimitBytes                           *int                             `url:\"sidekiq_job_limiter_limit_bytes,omitempty\" json:\"sidekiq_job_limiter_limit_bytes,omitempty\"`\n\tSidekiqJobLimiterMode                                 *string                          `url:\"sidekiq_job_limiter_mode,omitempty\" json:\"sidekiq_job_limiter_mode,omitempty\"`\n\tSignInText                                            *string                          `url:\"sign_in_text,omitempty\" json:\"sign_in_text,omitempty\"`\n\tSignupEnabled                                         *bool                            `url:\"signup_enabled,omitempty\" json:\"signup_enabled,omitempty\"`\n\tSilentAdminExportsEnabled                             *bool                            `url:\"silent_admin_exports_enabled,omitempty\" json:\"silent_admin_exports_enabled,omitempty\"`\n\tSilentModeEnabled                                     *bool                            `url:\"silent_mode_enabled,omitempty\" json:\"silent_mode_enabled,omitempty\"`\n\tSlackAppEnabled                                       *bool                            `url:\"slack_app_enabled,omitempty\" json:\"slack_app_enabled,omitempty\"`\n\tSlackAppID                                            *string                          `url:\"slack_app_id,omitempty\" json:\"slack_app_id,omitempty\"`\n\tSlackAppSecret                                        *string                          `url:\"slack_app_secret,omitempty\" json:\"slack_app_secret,omitempty\"`\n\tSlackAppSigningSecret                                 *string                          `url:\"slack_app_signing_secret,omitempty\" json:\"slack_app_signing_secret,omitempty\"`\n\tSlackAppVerificationToken                             *string                          `url:\"slack_app_verification_token,omitempty\" json:\"slack_app_verification_token,omitempty\"`\n\tSnippetSizeLimit                                      *int                             `url:\"snippet_size_limit,omitempty\" json:\"snippet_size_limit,omitempty\"`\n\tSnowplowAppID                                         *string                          `url:\"snowplow_app_id,omitempty\" json:\"snowplow_app_id,omitempty\"`\n\tSnowplowCollectorHostname                             *string                          `url:\"snowplow_collector_hostname,omitempty\" json:\"snowplow_collector_hostname,omitempty\"`\n\tSnowplowCookieDomain                                  *string                          `url:\"snowplow_cookie_domain,omitempty\" json:\"snowplow_cookie_domain,omitempty\"`\n\tSnowplowDatabaseCollectorHostname                     *string                          `url:\"snowplow_database_collector_hostname,omitempty\" json:\"snowplow_database_collector_hostname,omitempty\"`\n\tSnowplowEnabled                                       *bool                            `url:\"snowplow_enabled,omitempty\" json:\"snowplow_enabled,omitempty\"`\n\tSourcegraphEnabled                                    *bool                            `url:\"sourcegraph_enabled,omitempty\" json:\"sourcegraph_enabled,omitempty\"`\n\tSourcegraphPublicOnly                                 *bool                            `url:\"sourcegraph_public_only,omitempty\" json:\"sourcegraph_public_only,omitempty\"`\n\tSourcegraphURL                                        *string                          `url:\"sourcegraph_url,omitempty\" json:\"sourcegraph_url,omitempty\"`\n\tSpamCheckAPIKey                                       *string                          `url:\"spam_check_api_key,omitempty\" json:\"spam_check_api_key,omitempty\"`\n\tSpamCheckEndpointEnabled                              *bool                            `url:\"spam_check_endpoint_enabled,omitempty\" json:\"spam_check_endpoint_enabled,omitempty\"`\n\tSpamCheckEndpointURL                                  *string                          `url:\"spam_check_endpoint_url,omitempty\" json:\"spam_check_endpoint_url,omitempty\"`\n\tStaticObjectsExternalStorageAuthToken                 *string                          `url:\"static_objects_external_storage_auth_token,omitempty\" json:\"static_objects_external_storage_auth_token,omitempty\"`\n\tStaticObjectsExternalStorageURL                       *string                          `url:\"static_objects_external_storage_url,omitempty\" json:\"static_objects_external_storage_url,omitempty\"`\n\tSuggestPipelineEnabled                                *bool                            `url:\"suggest_pipeline_enabled,omitempty\" json:\"suggest_pipeline_enabled,omitempty\"`\n\tTerminalMaxSessionTime                                *int                             `url:\"terminal_max_session_time,omitempty\" json:\"terminal_max_session_time,omitempty\"`\n\tTerms                                                 *string                          `url:\"terms,omitempty\" json:\"terms,omitempty\"`\n\tThrottleAuthenticatedAPIEnabled                       *bool                            `url:\"throttle_authenticated_api_enabled,omitempty\" json:\"throttle_authenticated_api_enabled,omitempty\"`\n\tThrottleAuthenticatedAPIPeriodInSeconds               *int                             `url:\"throttle_authenticated_api_period_in_seconds,omitempty\" json:\"throttle_authenticated_api_period_in_seconds,omitempty\"`\n\tThrottleAuthenticatedAPIRequestsPerPeriod             *int                             `url:\"throttle_authenticated_api_requests_per_period,omitempty\" json:\"throttle_authenticated_api_requests_per_period,omitempty\"`\n\tThrottleAuthenticatedDeprecatedAPIEnabled             *bool                            `url:\"throttle_authenticated_deprecated_api_enabled,omitempty\" json:\"throttle_authenticated_deprecated_api_enabled,omitempty\"`\n\tThrottleAuthenticatedDeprecatedAPIPeriodInSeconds     *int                             `url:\"throttle_authenticated_deprecated_api_period_in_seconds,omitempty\" json:\"throttle_authenticated_deprecated_api_period_in_seconds,omitempty\"`\n\tThrottleAuthenticatedDeprecatedAPIRequestsPerPeriod   *int                             `url:\"throttle_authenticated_deprecated_api_requests_per_period,omitempty\" json:\"throttle_authenticated_deprecated_api_requests_per_period,omitempty\"`\n\tThrottleAuthenticatedFilesAPIEnabled                  *bool                            `url:\"throttle_authenticated_files_api_enabled,omitempty\" json:\"throttle_authenticated_files_api_enabled,omitempty\"`\n\tThrottleAuthenticatedFilesAPIPeriodInSeconds          *int                             `url:\"throttle_authenticated_files_api_period_in_seconds,omitempty\" json:\"throttle_authenticated_files_api_period_in_seconds,omitempty\"`\n\tThrottleAuthenticatedFilesAPIRequestsPerPeriod        *int                             `url:\"throttle_authenticated_files_api_requests_per_period,omitempty\" json:\"throttle_authenticated_files_api_requests_per_period,omitempty\"`\n\tThrottleAuthenticatedGitLFSEnabled                    *bool                            `url:\"throttle_authenticated_git_lfs_enabled,omitempty\" json:\"throttle_authenticated_git_lfs_enabled,omitempty\"`\n\tThrottleAuthenticatedGitLFSPeriodInSeconds            *int                             `url:\"throttle_authenticated_git_lfs_period_in_seconds,omitempty\" json:\"throttle_authenticated_git_lfs_period_in_seconds,omitempty\"`\n\tThrottleAuthenticatedGitLFSRequestsPerPeriod          *int                             `url:\"throttle_authenticated_git_lfs_requests_per_period,omitempty\" json:\"throttle_authenticated_git_lfs_requests_per_period,omitempty\"`\n\tThrottleAuthenticatedPackagesAPIEnabled               *bool                            `url:\"throttle_authenticated_packages_api_enabled,omitempty\" json:\"throttle_authenticated_packages_api_enabled,omitempty\"`\n\tThrottleAuthenticatedPackagesAPIPeriodInSeconds       *int                             `url:\"throttle_authenticated_packages_api_period_in_seconds,omitempty\" json:\"throttle_authenticated_packages_api_period_in_seconds,omitempty\"`\n\tThrottleAuthenticatedPackagesAPIRequestsPerPeriod     *int                             `url:\"throttle_authenticated_packages_api_requests_per_period,omitempty\" json:\"throttle_authenticated_packages_api_requests_per_period,omitempty\"`\n\tThrottleAuthenticatedWebEnabled                       *bool                            `url:\"throttle_authenticated_web_enabled,omitempty\" json:\"throttle_authenticated_web_enabled,omitempty\"`\n\tThrottleAuthenticatedWebPeriodInSeconds               *int                             `url:\"throttle_authenticated_web_period_in_seconds,omitempty\" json:\"throttle_authenticated_web_period_in_seconds,omitempty\"`\n\tThrottleAuthenticatedWebRequestsPerPeriod             *int                             `url:\"throttle_authenticated_web_requests_per_period,omitempty\" json:\"throttle_authenticated_web_requests_per_period,omitempty\"`\n\tThrottleIncidentManagementNotificationEnabled         *bool                            `url:\"throttle_incident_management_notification_enabled,omitempty\" json:\"throttle_incident_management_notification_enabled,omitempty\"`\n\tThrottleIncidentManagementNotificationPerPeriod       *int                             `url:\"throttle_incident_management_notification_per_period,omitempty\" json:\"throttle_incident_management_notification_per_period,omitempty\"`\n\tThrottleIncidentManagementNotificationPeriodInSeconds *int                             `url:\"throttle_incident_management_notification_period_in_seconds,omitempty\" json:\"throttle_incident_management_notification_period_in_seconds,omitempty\"`\n\tThrottleProtectedPathsEnabled                         *bool                            `url:\"throttle_protected_paths_enabled_enabled,omitempty\" json:\"throttle_protected_paths_enabled,omitempty\"`\n\tThrottleProtectedPathsPeriodInSeconds                 *int                             `url:\"throttle_protected_paths_enabled_period_in_seconds,omitempty\" json:\"throttle_protected_paths_period_in_seconds,omitempty\"`\n\tThrottleProtectedPathsRequestsPerPeriod               *int                             `url:\"throttle_protected_paths_enabled_requests_per_period,omitempty\" json:\"throttle_protected_paths_per_period,omitempty\"`\n\tThrottleUnauthenticatedAPIEnabled                     *bool                            `url:\"throttle_unauthenticated_api_enabled,omitempty\" json:\"throttle_unauthenticated_api_enabled,omitempty\"`\n\tThrottleUnauthenticatedAPIPeriodInSeconds             *int                             `url:\"throttle_unauthenticated_api_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_api_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedAPIRequestsPerPeriod           *int                             `url:\"throttle_unauthenticated_api_requests_per_period,omitempty\" json:\"throttle_unauthenticated_api_requests_per_period,omitempty\"`\n\tThrottleUnauthenticatedDeprecatedAPIEnabled           *bool                            `url:\"throttle_unauthenticated_deprecated_api_enabled,omitempty\" json:\"throttle_unauthenticated_deprecated_api_enabled,omitempty\"`\n\tThrottleUnauthenticatedDeprecatedAPIPeriodInSeconds   *int                             `url:\"throttle_unauthenticated_deprecated_api_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_deprecated_api_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedDeprecatedAPIRequestsPerPeriod *int                             `url:\"throttle_unauthenticated_deprecated_api_requests_per_period,omitempty\" json:\"throttle_unauthenticated_deprecated_api_requests_per_period,omitempty\"`\n\tThrottleUnauthenticatedEnabled                        *bool                            `url:\"throttle_unauthenticated_enabled,omitempty\" json:\"throttle_unauthenticated_enabled,omitempty\"`\n\tThrottleUnauthenticatedFilesAPIEnabled                *bool                            `url:\"throttle_unauthenticated_files_api_enabled,omitempty\" json:\"throttle_unauthenticated_files_api_enabled,omitempty\"`\n\tThrottleUnauthenticatedFilesAPIPeriodInSeconds        *int                             `url:\"throttle_unauthenticated_files_api_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_files_api_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedFilesAPIRequestsPerPeriod      *int                             `url:\"throttle_unauthenticated_files_api_requests_per_period,omitempty\" json:\"throttle_unauthenticated_files_api_requests_per_period,omitempty\"`\n\tThrottleUnauthenticatedGitLFSEnabled                  *bool                            `url:\"throttle_unauthenticated_git_lfs_enabled,omitempty\" json:\"throttle_unauthenticated_git_lfs_enabled,omitempty\"`\n\tThrottleUnauthenticatedGitLFSPeriodInSeconds          *int                             `url:\"throttle_unauthenticated_git_lfs_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_git_lfs_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedGitLFSRequestsPerPeriod        *int                             `url:\"throttle_unauthenticated_git_lfs_requests_per_period,omitempty\" json:\"throttle_unauthenticated_git_lfs_requests_per_period,omitempty\"`\n\tThrottleUnauthenticatedPackagesAPIEnabled             *bool                            `url:\"throttle_unauthenticated_packages_api_enabled,omitempty\" json:\"throttle_unauthenticated_packages_api_enabled,omitempty\"`\n\tThrottleUnauthenticatedPackagesAPIPeriodInSeconds     *int                             `url:\"throttle_unauthenticated_packages_api_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_packages_api_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedPackagesAPIRequestsPerPeriod   *int                             `url:\"throttle_unauthenticated_packages_api_requests_per_period,omitempty\" json:\"throttle_unauthenticated_packages_api_requests_per_period,omitempty\"`\n\tThrottleUnauthenticatedPeriodInSeconds                *int                             `url:\"throttle_unauthenticated_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedRequestsPerPeriod              *int                             `url:\"throttle_unauthenticated_requests_per_period,omitempty\" json:\"throttle_unauthenticated_requests_per_period,omitempty\"`\n\tThrottleUnauthenticatedWebEnabled                     *bool                            `url:\"throttle_unauthenticated_web_enabled,omitempty\" json:\"throttle_unauthenticated_web_enabled,omitempty\"`\n\tThrottleUnauthenticatedWebPeriodInSeconds             *int                             `url:\"throttle_unauthenticated_web_period_in_seconds,omitempty\" json:\"throttle_unauthenticated_web_period_in_seconds,omitempty\"`\n\tThrottleUnauthenticatedWebRequestsPerPeriod           *int                             `url:\"throttle_unauthenticated_web_requests_per_period,omitempty\" json:\"throttle_unauthenticated_web_requests_per_period,omitempty\"`\n\tTimeTrackingLimitToHours                              *bool                            `url:\"time_tracking_limit_to_hours,omitempty\" json:\"time_tracking_limit_to_hours,omitempty\"`\n\tTwoFactorGracePeriod                                  *int                             `url:\"two_factor_grace_period,omitempty\" json:\"two_factor_grace_period,omitempty\"`\n\tUnconfirmedUsersDeleteAfterDays                       *int                             `url:\"unconfirmed_users_delete_after_days,omitempty\" json:\"unconfirmed_users_delete_after_days,omitempty\"`\n\tUniqueIPsLimitEnabled                                 *bool                            `url:\"unique_ips_limit_enabled,omitempty\" json:\"unique_ips_limit_enabled,omitempty\"`\n\tUniqueIPsLimitPerUser                                 *int                             `url:\"unique_ips_limit_per_user,omitempty\" json:\"unique_ips_limit_per_user,omitempty\"`\n\tUniqueIPsLimitTimeWindow                              *int                             `url:\"unique_ips_limit_time_window,omitempty\" json:\"unique_ips_limit_time_window,omitempty\"`\n\tUpdateRunnerVersionsEnabled                           *bool                            `url:\"update_runner_versions_enabled,omitempty\" json:\"update_runner_versions_enabled,omitempty\"`\n\tUpdatingNameDisabledForUsers                          *bool                            `url:\"updating_name_disabled_for_users,omitempty\" json:\"updating_name_disabled_for_users,omitempty\"`\n\tUsagePingEnabled                                      *bool                            `url:\"usage_ping_enabled,omitempty\" json:\"usage_ping_enabled,omitempty\"`\n\tUsagePingFeaturesEnabled                              *bool                            `url:\"usage_ping_features_enabled,omitempty\" json:\"usage_ping_features_enabled,omitempty\"`\n\tUseClickhouseForAnalytics                             *bool                            `url:\"use_clickhouse_for_analytics,omitempty\" json:\"use_clickhouse_for_analytics,omitempty\"`\n\tUserDeactivationEmailsEnabled                         *bool                            `url:\"user_deactivation_emails_enabled,omitempty\" json:\"user_deactivation_emails_enabled,omitempty\"`\n\tUserDefaultExternal                                   *bool                            `url:\"user_default_external,omitempty\" json:\"user_default_external,omitempty\"`\n\tUserDefaultInternalRegex                              *string                          `url:\"user_default_internal_regex,omitempty\" json:\"user_default_internal_regex,omitempty\"`\n\tUserDefaultsToPrivateProfile                          *bool                            `url:\"user_defaults_to_private_profile,omitempty\" json:\"user_defaults_to_private_profile,omitempty\"`\n\tUserEmailLookupLimit                                  *int                             `url:\"user_email_lookup_limit,omitempty\" json:\"user_email_lookup_limit,omitempty\"`\n\tUserOauthApplications                                 *bool                            `url:\"user_oauth_applications,omitempty\" json:\"user_oauth_applications,omitempty\"`\n\tUserShowAddSSHKeyMessage                              *bool                            `url:\"user_show_add_ssh_key_message,omitempty\" json:\"user_show_add_ssh_key_message,omitempty\"`\n\tUsersGetByIDLimit                                     *int                             `url:\"users_get_by_id_limit,omitempty\" json:\"users_get_by_id_limit,omitempty\"`\n\tUsersGetByIDLimitAllowlistRaw                         *string                          `url:\"users_get_by_id_limit_allowlist_raw,omitempty\" json:\"users_get_by_id_limit_allowlist_raw,omitempty\"`\n\tValidRunnerRegistrars                                 *[]string                        `url:\"valid_runner_registrars,omitempty\" json:\"valid_runner_registrars,omitempty\"`\n\tVersionCheckEnabled                                   *bool                            `url:\"version_check_enabled,omitempty\" json:\"version_check_enabled,omitempty\"`\n\tWebIDEClientsidePreviewEnabled                        *bool                            `url:\"web_ide_clientside_preview_enabled,omitempty\" json:\"web_ide_clientside_preview_enabled,omitempty\"`\n\tWhatsNewVariant                                       *string                          `url:\"whats_new_variant,omitempty\" json:\"whats_new_variant,omitempty\"`\n\tWikiPageMaxContentBytes                               *int                             `url:\"wiki_page_max_content_bytes,omitempty\" json:\"wiki_page_max_content_bytes,omitempty\"`\n}\n\n// BranchProtectionDefaultsOptions represents default Git protected branch permissions options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#options-for-default_branch_protection_defaults\ntype BranchProtectionDefaultsOptions struct {\n\tAllowedToPush           *[]int `url:\"allowed_to_push,omitempty\" json:\"allowed_to_push,omitempty\"`\n\tAllowForcePush          *bool  `url:\"allow_force_push,omitempty\" json:\"allow_force_push,omitempty\"`\n\tAllowedToMerge          *[]int `url:\"allowed_to_merge,omitempty\" json:\"allowed_to_merge,omitempty\"`\n\tDeveloperCanInitialPush *bool  `url:\"developer_can_initial_push,omitempty\" json:\"developer_can_initial_push,omitempty\"`\n}\n\n// UpdateSettings updates the application settings.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/settings.html#change-application-settings\nfunc (s *SettingsService) UpdateSettings(opt *UpdateSettingsOptions, options ...RequestOptionFunc) (*Settings, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPut, \"application/settings\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tas := new(Settings)\n\tresp, err := s.client.Do(req, as)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn as, resp, nil\n}\n"
        },
        {
          "name": "settings_test.go",
          "type": "blob",
          "size": 2.314453125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1,    \"default_projects_limit\" : 100000}`)\n\t})\n\n\tsettings, _, err := client.Settings.GetSettings()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Settings{ID: 1, DefaultProjectsLimit: 100000}\n\tif !reflect.DeepEqual(settings, want) {\n\t\tt.Errorf(\"Settings.GetSettings returned %+v, want %+v\", settings, want)\n\t}\n}\n\nfunc TestUpdateSettings(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"default_projects_limit\" : 100}`)\n\t})\n\n\toptions := &UpdateSettingsOptions{\n\t\tDefaultProjectsLimit: Ptr(100),\n\t}\n\tsettings, _, err := client.Settings.UpdateSettings(options)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Settings{DefaultProjectsLimit: 100}\n\tif !reflect.DeepEqual(settings, want) {\n\t\tt.Errorf(\"Settings.UpdateSettings returned %+v, want %+v\", settings, want)\n\t}\n}\n\nfunc TestSettingsWithEmptyContainerRegistry(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/application/settings\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"container_registry_import_created_before\": \"\"}`)\n\t})\n\n\tsettings, _, err := client.Settings.GetSettings()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant := &Settings{ID: 1, ContainerRegistryImportCreatedBefore: nil}\n\tif !reflect.DeepEqual(settings, want) {\n\t\tt.Errorf(\"Settings.UpdateSettings returned %+v, want %+v\", settings, want)\n\t}\n}\n"
        },
        {
          "name": "sidekiq_metrics.go",
          "type": "blob",
          "size": 4.59765625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"time\"\n)\n\n// SidekiqService handles communication with the sidekiq service\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/sidekiq_metrics.html\ntype SidekiqService struct {\n\tclient *Client\n}\n\n// QueueMetrics represents the GitLab sidekiq queue metrics.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-the-current-queue-metrics\ntype QueueMetrics struct {\n\tQueues map[string]struct {\n\t\tBacklog int `json:\"backlog\"`\n\t\tLatency int `json:\"latency\"`\n\t} `json:\"queues\"`\n}\n\n// GetQueueMetrics lists information about all the registered queues,\n// their backlog and their latency.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-the-current-queue-metrics\nfunc (s *SidekiqService) GetQueueMetrics(options ...RequestOptionFunc) (*QueueMetrics, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"/sidekiq/queue_metrics\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tq := new(QueueMetrics)\n\tresp, err := s.client.Do(req, q)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn q, resp, nil\n}\n\n// ProcessMetrics represents the GitLab sidekiq process metrics.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-the-current-process-metrics\ntype ProcessMetrics struct {\n\tProcesses []struct {\n\t\tHostname    string     `json:\"hostname\"`\n\t\tPid         int        `json:\"pid\"`\n\t\tTag         string     `json:\"tag\"`\n\t\tStartedAt   *time.Time `json:\"started_at\"`\n\t\tQueues      []string   `json:\"queues\"`\n\t\tLabels      []string   `json:\"labels\"`\n\t\tConcurrency int        `json:\"concurrency\"`\n\t\tBusy        int        `json:\"busy\"`\n\t} `json:\"processes\"`\n}\n\n// GetProcessMetrics lists information about all the Sidekiq workers registered\n// to process your queues.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-the-current-process-metrics\nfunc (s *SidekiqService) GetProcessMetrics(options ...RequestOptionFunc) (*ProcessMetrics, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"/sidekiq/process_metrics\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tp := new(ProcessMetrics)\n\tresp, err := s.client.Do(req, p)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn p, resp, nil\n}\n\n// JobStats represents the GitLab sidekiq job stats.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-the-current-job-statistics\ntype JobStats struct {\n\tJobs struct {\n\t\tProcessed int `json:\"processed\"`\n\t\tFailed    int `json:\"failed\"`\n\t\tEnqueued  int `json:\"enqueued\"`\n\t} `json:\"jobs\"`\n}\n\n// GetJobStats list information about the jobs that Sidekiq has performed.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-the-current-job-statistics\nfunc (s *SidekiqService) GetJobStats(options ...RequestOptionFunc) (*JobStats, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"/sidekiq/job_stats\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tj := new(JobStats)\n\tresp, err := s.client.Do(req, j)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn j, resp, nil\n}\n\n// CompoundMetrics represents the GitLab sidekiq compounded stats.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-a-compound-response-of-all-the-previously-mentioned-metrics\ntype CompoundMetrics struct {\n\tQueueMetrics\n\tProcessMetrics\n\tJobStats\n}\n\n// GetCompoundMetrics lists all the currently available information about Sidekiq.\n// Get a compound response of all the previously mentioned metrics\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/sidekiq_metrics.html#get-a-compound-response-of-all-the-previously-mentioned-metrics\nfunc (s *SidekiqService) GetCompoundMetrics(options ...RequestOptionFunc) (*CompoundMetrics, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"/sidekiq/compound_metrics\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tc := new(CompoundMetrics)\n\tresp, err := s.client.Do(req, c)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn c, resp, nil\n}\n"
        },
        {
          "name": "sidekiq_metrics_test.go",
          "type": "blob",
          "size": 3.4404296875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSidekiqService_GetQueueMetrics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/sidekiq/queue_metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\"queues\": {\"default\": {\"backlog\": 0,\"latency\": 0}}}`)\n\t})\n\n\tqm, _, err := client.Sidekiq.GetQueueMetrics()\n\trequire.NoError(t, err)\n\n\twant := &QueueMetrics{Queues: map[string]struct {\n\t\tBacklog int `json:\"backlog\"`\n\t\tLatency int `json:\"latency\"`\n\t}{\"default\": {Backlog: 0, Latency: 0}}}\n\trequire.Equal(t, want, qm)\n}\n\nfunc TestSidekiqService_GetProcessMetrics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/sidekiq/process_metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"processes\": [{\"hostname\": \"gitlab.example.com\",\"pid\": 5649,\"tag\": \"gitlab\",\"concurrency\": 25,\"busy\": 0}]}`)\n\t})\n\n\tpm, _, err := client.Sidekiq.GetProcessMetrics()\n\trequire.NoError(t, err)\n\n\twant := &ProcessMetrics{[]struct {\n\t\tHostname    string     `json:\"hostname\"`\n\t\tPid         int        `json:\"pid\"`\n\t\tTag         string     `json:\"tag\"`\n\t\tStartedAt   *time.Time `json:\"started_at\"`\n\t\tQueues      []string   `json:\"queues\"`\n\t\tLabels      []string   `json:\"labels\"`\n\t\tConcurrency int        `json:\"concurrency\"`\n\t\tBusy        int        `json:\"busy\"`\n\t}{{Hostname: \"gitlab.example.com\", Pid: 5649, Tag: \"gitlab\", Concurrency: 25, Busy: 0}}}\n\trequire.Equal(t, want, pm)\n}\n\nfunc TestSidekiqService_GetJobStats(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/sidekiq/job_stats\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"jobs\": {\"processed\": 2,\"failed\": 0,\"enqueued\": 0}}`)\n\t})\n\n\tjs, _, err := client.Sidekiq.GetJobStats()\n\trequire.NoError(t, err)\n\n\twant := &JobStats{struct {\n\t\tProcessed int `json:\"processed\"`\n\t\tFailed    int `json:\"failed\"`\n\t\tEnqueued  int `json:\"enqueued\"`\n\t}(struct {\n\t\tProcessed int\n\t\tFailed    int\n\t\tEnqueued  int\n\t}{Processed: 2, Failed: 0, Enqueued: 0})}\n\trequire.Equal(t, want, js)\n}\n\nfunc TestSidekiqService_GetCompoundMetrics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/sidekiq/compound_metrics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_compound_metrics.json\")\n\t})\n\n\tcm, _, err := client.Sidekiq.GetCompoundMetrics()\n\trequire.NoError(t, err)\n\n\twant := &CompoundMetrics{\n\t\tQueueMetrics: QueueMetrics{Queues: map[string]struct {\n\t\t\tBacklog int `json:\"backlog\"`\n\t\t\tLatency int `json:\"latency\"`\n\t\t}{\"default\": {\n\t\t\tBacklog: 0,\n\t\t\tLatency: 0,\n\t\t}}},\n\t\tProcessMetrics: ProcessMetrics{Processes: []struct {\n\t\t\tHostname    string     `json:\"hostname\"`\n\t\t\tPid         int        `json:\"pid\"`\n\t\t\tTag         string     `json:\"tag\"`\n\t\t\tStartedAt   *time.Time `json:\"started_at\"`\n\t\t\tQueues      []string   `json:\"queues\"`\n\t\t\tLabels      []string   `json:\"labels\"`\n\t\t\tConcurrency int        `json:\"concurrency\"`\n\t\t\tBusy        int        `json:\"busy\"`\n\t\t}{{Hostname: \"gitlab.example.com\", Pid: 5649, Tag: \"gitlab\", Concurrency: 25, Busy: 0}}},\n\t\tJobStats: JobStats{Jobs: struct {\n\t\t\tProcessed int `json:\"processed\"`\n\t\t\tFailed    int `json:\"failed\"`\n\t\t\tEnqueued  int `json:\"enqueued\"`\n\t\t}(struct {\n\t\t\tProcessed int\n\t\t\tFailed    int\n\t\t\tEnqueued  int\n\t\t}{Processed: 2, Failed: 0, Enqueued: 0})},\n\t}\n\trequire.Equal(t, want, cm)\n}\n"
        },
        {
          "name": "snippet_repository_storage_move.go",
          "type": "blob",
          "size": 7.6259765625,
          "content": "//\n// Copyright 2023, Nick Westbury\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// SnippetRepositoryStorageMoveService handles communication with the\n// snippets related methods of the GitLab API.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html\ntype SnippetRepositoryStorageMoveService struct {\n\tclient *Client\n}\n\n// SnippetRepositoryStorageMove represents the status of a repository move.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html\ntype SnippetRepositoryStorageMove struct {\n\tID                     int                `json:\"id\"`\n\tCreatedAt              *time.Time         `json:\"created_at\"`\n\tState                  string             `json:\"state\"`\n\tSourceStorageName      string             `json:\"source_storage_name\"`\n\tDestinationStorageName string             `json:\"destination_storage_name\"`\n\tSnippet                *RepositorySnippet `json:\"snippet\"`\n}\n\ntype RepositorySnippet struct {\n\tID            int             `json:\"id\"`\n\tTitle         string          `json:\"title\"`\n\tDescription   string          `json:\"description\"`\n\tVisibility    VisibilityValue `json:\"visibility\"`\n\tUpdatedAt     *time.Time      `json:\"updated_at\"`\n\tCreatedAt     *time.Time      `json:\"created_at\"`\n\tProjectID     int             `json:\"project_id\"`\n\tWebURL        string          `json:\"web_url\"`\n\tRawURL        string          `json:\"raw_url\"`\n\tSSHURLToRepo  string          `json:\"ssh_url_to_repo\"`\n\tHTTPURLToRepo string          `json:\"http_url_to_repo\"`\n}\n\n// RetrieveAllSnippetStorageMovesOptions represents the available\n// RetrieveAllStorageMoves() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#retrieve-all-repository-storage-moves-for-a-snippet\ntype RetrieveAllSnippetStorageMovesOptions ListOptions\n\n// RetrieveAllStorageMoves retrieves all snippet repository storage moves\n// accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#retrieve-all-repository-storage-moves-for-a-snippet\nfunc (s SnippetRepositoryStorageMoveService) RetrieveAllStorageMoves(opts RetrieveAllSnippetStorageMovesOptions, options ...RequestOptionFunc) ([]*SnippetRepositoryStorageMove, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"snippet_repository_storage_moves\", opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ssms []*SnippetRepositoryStorageMove\n\tresp, err := s.client.Do(req, &ssms)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ssms, resp, err\n}\n\n// RetrieveAllStorageMovesForSnippet retrieves all repository storage moves for\n// a single snippet accessible by the authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#retrieve-all-repository-storage-moves-for-a-snippet\nfunc (s SnippetRepositoryStorageMoveService) RetrieveAllStorageMovesForSnippet(snippet int, opts RetrieveAllSnippetStorageMovesOptions, options ...RequestOptionFunc) ([]*SnippetRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d/repository_storage_moves\", snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ssms []*SnippetRepositoryStorageMove\n\tresp, err := s.client.Do(req, &ssms)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ssms, resp, err\n}\n\n// GetStorageMove gets a single snippet repository storage move.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#get-a-single-snippet-repository-storage-move\nfunc (s SnippetRepositoryStorageMoveService) GetStorageMove(repositoryStorage int, options ...RequestOptionFunc) (*SnippetRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"snippet_repository_storage_moves/%d\", repositoryStorage)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tssm := new(SnippetRepositoryStorageMove)\n\tresp, err := s.client.Do(req, ssm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ssm, resp, err\n}\n\n// GetStorageMoveForSnippet gets a single repository storage move for a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#get-a-single-repository-storage-move-for-a-snippet\nfunc (s SnippetRepositoryStorageMoveService) GetStorageMoveForSnippet(snippet int, repositoryStorage int, options ...RequestOptionFunc) (*SnippetRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d/repository_storage_moves/%d\", snippet, repositoryStorage)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tssm := new(SnippetRepositoryStorageMove)\n\tresp, err := s.client.Do(req, ssm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ssm, resp, err\n}\n\n// ScheduleStorageMoveForSnippetOptions represents the available\n// ScheduleStorageMoveForSnippet() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#schedule-a-repository-storage-move-for-a-snippet\ntype ScheduleStorageMoveForSnippetOptions struct {\n\tDestinationStorageName *string `url:\"destination_storage_name,omitempty\" json:\"destination_storage_name,omitempty\"`\n}\n\n// ScheduleStorageMoveForSnippet schedule a repository to be moved for a snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#schedule-a-repository-storage-move-for-a-snippet\nfunc (s SnippetRepositoryStorageMoveService) ScheduleStorageMoveForSnippet(snippet int, opts ScheduleStorageMoveForSnippetOptions, options ...RequestOptionFunc) (*SnippetRepositoryStorageMove, *Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d/repository_storage_moves\", snippet)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tssm := new(SnippetRepositoryStorageMove)\n\tresp, err := s.client.Do(req, ssm)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ssm, resp, err\n}\n\n// ScheduleAllSnippetStorageMovesOptions represents the available\n// ScheduleAllStorageMoves() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#schedule-repository-storage-moves-for-all-snippets-on-a-storage-shard\ntype ScheduleAllSnippetStorageMovesOptions struct {\n\tSourceStorageName      *string `url:\"source_storage_name,omitempty\" json:\"source_storage_name,omitempty\"`\n\tDestinationStorageName *string `url:\"destination_storage_name,omitempty\" json:\"destination_storage_name,omitempty\"`\n}\n\n// ScheduleAllStorageMoves schedules all snippet repositories to be moved.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippet_repository_storage_moves.html#schedule-repository-storage-moves-for-all-snippets-on-a-storage-shard\nfunc (s SnippetRepositoryStorageMoveService) ScheduleAllStorageMoves(opts ScheduleAllSnippetStorageMovesOptions, options ...RequestOptionFunc) (*Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"snippet_repository_storage_moves\", opts, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "snippet_repository_storage_move_test.go",
          "type": "blob",
          "size": 4.576171875,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSnippetRepositoryStorageMove_RetrieveAllSnippetStorageMoves(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippet_repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":65,\n\t\t\t\"title\":\"Test Snippet\"\n\t\t  }\n\t\t},\n\t\t{\n\t\t  \"id\":122,\n\t\t  \"state\":\"finished\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":64,\n\t\t\t\"title\":\"Test Snippet 2\"\n\t\t  }\n\t\t}]`)\n\t})\n\n\topts := RetrieveAllSnippetStorageMovesOptions{Page: 1, PerPage: 2}\n\n\tssms, _, err := client.SnippetRepositoryStorageMove.RetrieveAllStorageMoves(opts)\n\trequire.NoError(t, err)\n\n\twant := []*SnippetRepositoryStorageMove{\n\t\t{\n\t\t\tID:    123,\n\t\t\tState: \"scheduled\",\n\t\t\tSnippet: &RepositorySnippet{\n\t\t\t\tID:    65,\n\t\t\t\tTitle: \"Test Snippet\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:    122,\n\t\t\tState: \"finished\",\n\t\t\tSnippet: &RepositorySnippet{\n\t\t\t\tID:    64,\n\t\t\t\tTitle: \"Test Snippet 2\",\n\t\t\t},\n\t\t},\n\t}\n\trequire.Equal(t, want, ssms)\n}\n\nfunc TestSnippetRepositoryStorageMove_RetrieveAllStorageMovesForSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/65/repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":65,\n\t\t\t\"title\":\"Test Snippet\"\n\t\t  }\n\t\t},\n\t\t{\n\t\t  \"id\":122,\n\t\t  \"state\":\"finished\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":65,\n\t\t\t\"title\":\"Test Snippet\"\n\t\t  }\n\t\t}]`)\n\t})\n\n\topts := RetrieveAllSnippetStorageMovesOptions{Page: 1, PerPage: 2}\n\n\tssms, _, err := client.SnippetRepositoryStorageMove.RetrieveAllStorageMovesForSnippet(65, opts)\n\trequire.NoError(t, err)\n\n\twant := []*SnippetRepositoryStorageMove{\n\t\t{\n\t\t\tID:    123,\n\t\t\tState: \"scheduled\",\n\t\t\tSnippet: &RepositorySnippet{\n\t\t\t\tID:    65,\n\t\t\t\tTitle: \"Test Snippet\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tID:    122,\n\t\t\tState: \"finished\",\n\t\t\tSnippet: &RepositorySnippet{\n\t\t\t\tID:    65,\n\t\t\t\tTitle: \"Test Snippet\",\n\t\t\t},\n\t\t},\n\t}\n\trequire.Equal(t, want, ssms)\n}\n\nfunc TestSnippetRepositoryStorageMove_GetStorageMove(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippet_repository_storage_moves/123\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":65,\n\t\t\t\"title\":\"Test Snippet\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.SnippetRepositoryStorageMove.GetStorageMove(123)\n\trequire.NoError(t, err)\n\n\twant := &SnippetRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tSnippet: &RepositorySnippet{\n\t\t\tID:    65,\n\t\t\tTitle: \"Test Snippet\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestSnippetRepositoryStorageMove_GetStorageMoveForSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/65/repository_storage_moves/123\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":123,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":65,\n\t\t\t\"title\":\"Test Snippet\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.SnippetRepositoryStorageMove.GetStorageMoveForSnippet(65, 123)\n\trequire.NoError(t, err)\n\n\twant := &SnippetRepositoryStorageMove{\n\t\tID:    123,\n\t\tState: \"scheduled\",\n\t\tSnippet: &RepositorySnippet{\n\t\t\tID:    65,\n\t\t\tTitle: \"Test Snippet\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestSnippetRepositoryStorageMove_ScheduleStorageMoveForSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/65/repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t  \"id\":124,\n\t\t  \"state\":\"scheduled\",\n\t\t  \"snippet\":{\n\t\t\t\"id\":65,\n\t\t\t\"title\":\"Test Snippet\"\n\t\t  }\n\t\t}`)\n\t})\n\n\tssm, _, err := client.SnippetRepositoryStorageMove.ScheduleStorageMoveForSnippet(65, ScheduleStorageMoveForSnippetOptions{})\n\trequire.NoError(t, err)\n\n\twant := &SnippetRepositoryStorageMove{\n\t\tID:    124,\n\t\tState: \"scheduled\",\n\t\tSnippet: &RepositorySnippet{\n\t\t\tID:    65,\n\t\t\tTitle: \"Test Snippet\",\n\t\t},\n\t}\n\trequire.Equal(t, want, ssm)\n}\n\nfunc TestSnippetRepositoryStorageMove_ScheduleAllStorageMoves(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippet_repository_storage_moves\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"message\": \"202 Accepted\"}`)\n\t})\n\n\t_, err := client.SnippetRepositoryStorageMove.ScheduleAllStorageMoves(\n\t\tScheduleAllSnippetStorageMovesOptions{\n\t\t\tSourceStorageName: Ptr(\"default\"),\n\t\t},\n\t)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "snippets.go",
          "type": "blob",
          "size": 9.9931640625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// SnippetsService handles communication with the snippets\n// related methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/snippets.html\ntype SnippetsService struct {\n\tclient *Client\n}\n\n// Snippet represents a GitLab snippet.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/snippets.html\ntype Snippet struct {\n\tID          int    `json:\"id\"`\n\tTitle       string `json:\"title\"`\n\tFileName    string `json:\"file_name\"`\n\tDescription string `json:\"description\"`\n\tVisibility  string `json:\"visibility\"`\n\tAuthor      struct {\n\t\tID        int        `json:\"id\"`\n\t\tUsername  string     `json:\"username\"`\n\t\tEmail     string     `json:\"email\"`\n\t\tName      string     `json:\"name\"`\n\t\tState     string     `json:\"state\"`\n\t\tCreatedAt *time.Time `json:\"created_at\"`\n\t} `json:\"author\"`\n\tUpdatedAt *time.Time `json:\"updated_at\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tProjectID int        `json:\"project_id\"`\n\tWebURL    string     `json:\"web_url\"`\n\tRawURL    string     `json:\"raw_url\"`\n\tFiles     []struct {\n\t\tPath   string `json:\"path\"`\n\t\tRawURL string `json:\"raw_url\"`\n\t} `json:\"files\"`\n\tRepositoryStorage string `json:\"repository_storage\"`\n}\n\nfunc (s Snippet) String() string {\n\treturn Stringify(s)\n}\n\n// ListSnippetsOptions represents the available ListSnippets() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#list-all-snippets-for-a-user\ntype ListSnippetsOptions ListOptions\n\n// ListSnippets gets a list of snippets.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#list-all-snippets-for-a-user\nfunc (s *SnippetsService) ListSnippets(opt *ListSnippetsOptions, options ...RequestOptionFunc) ([]*Snippet, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"snippets\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Snippet\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// GetSnippet gets a single snippet\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#get-a-single-snippet\nfunc (s *SnippetsService) GetSnippet(snippet int, options ...RequestOptionFunc) (*Snippet, *Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d\", snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tps := new(Snippet)\n\tresp, err := s.client.Do(req, ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// SnippetContent gets a single snippet’s raw contents.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#single-snippet-contents\nfunc (s *SnippetsService) SnippetContent(snippet int, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d/raw\", snippet)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n\n// SnippetFileContent returns the raw file content as plain text.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#snippet-repository-file-content\nfunc (s *SnippetsService) SnippetFileContent(snippet int, ref, filename string, options ...RequestOptionFunc) ([]byte, *Response, error) {\n\tfilepath := PathEscape(filename)\n\tu := fmt.Sprintf(\"snippets/%d/files/%s/%s/raw\", snippet, ref, filepath)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar b bytes.Buffer\n\tresp, err := s.client.Do(req, &b)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn b.Bytes(), resp, err\n}\n\n// CreateSnippetFileOptions represents the create snippet file options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#create-new-snippet\ntype CreateSnippetFileOptions struct {\n\tFilePath *string `url:\"file_path,omitempty\" json:\"file_path,omitempty\"`\n\tContent  *string `url:\"content,omitempty\" json:\"content,omitempty\"`\n}\n\n// CreateSnippetOptions represents the available CreateSnippet() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#create-new-snippet\ntype CreateSnippetOptions struct {\n\tTitle       *string                      `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFileName    *string                      `url:\"file_name,omitempty\" json:\"file_name,omitempty\"`\n\tDescription *string                      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tContent     *string                      `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tVisibility  *VisibilityValue             `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tFiles       *[]*CreateSnippetFileOptions `url:\"files,omitempty\" json:\"files,omitempty\"`\n}\n\n// CreateSnippet creates a new snippet. The user must have permission\n// to create new snippets.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#create-new-snippet\nfunc (s *SnippetsService) CreateSnippet(opt *CreateSnippetOptions, options ...RequestOptionFunc) (*Snippet, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"snippets\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tps := new(Snippet)\n\tresp, err := s.client.Do(req, ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// UpdateSnippetFileOptions represents the update snippet file options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#update-snippet\ntype UpdateSnippetFileOptions struct {\n\tAction       *string `url:\"action,omitempty\" json:\"action,omitempty\"`\n\tFilePath     *string `url:\"file_path,omitempty\" json:\"file_path,omitempty\"`\n\tContent      *string `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tPreviousPath *string `url:\"previous_path,omitempty\" json:\"previous_path,omitempty\"`\n}\n\n// UpdateSnippetOptions represents the available UpdateSnippet() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#update-snippet\ntype UpdateSnippetOptions struct {\n\tTitle       *string                      `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFileName    *string                      `url:\"file_name,omitempty\" json:\"file_name,omitempty\"`\n\tDescription *string                      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tContent     *string                      `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tVisibility  *VisibilityValue             `url:\"visibility,omitempty\" json:\"visibility,omitempty\"`\n\tFiles       *[]*UpdateSnippetFileOptions `url:\"files,omitempty\" json:\"files,omitempty\"`\n}\n\n// UpdateSnippet updates an existing snippet. The user must have\n// permission to change an existing snippet.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#update-snippet\nfunc (s *SnippetsService) UpdateSnippet(snippet int, opt *UpdateSnippetOptions, options ...RequestOptionFunc) (*Snippet, *Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d\", snippet)\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tps := new(Snippet)\n\tresp, err := s.client.Do(req, ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// DeleteSnippet deletes an existing snippet. This is an idempotent\n// function and deleting a non-existent snippet still returns a 200 OK status\n// code.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#delete-snippet\nfunc (s *SnippetsService) DeleteSnippet(snippet int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"snippets/%d\", snippet)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ExploreSnippetsOptions represents the available ExploreSnippets() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#list-all-public-snippets\ntype ExploreSnippetsOptions ListOptions\n\n// ExploreSnippets gets the list of public snippets.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#list-all-public-snippets\nfunc (s *SnippetsService) ExploreSnippets(opt *ExploreSnippetsOptions, options ...RequestOptionFunc) ([]*Snippet, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"snippets/public\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Snippet\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n\n// ListAllSnippetsOptions represents the available ListAllSnippets() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#list-all-snippets\ntype ListAllSnippetsOptions struct {\n\tListOptions\n\tCreatedAfter      *ISOTime `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tCreatedBefore     *ISOTime `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tRepositoryStorage *string  `url:\"repository_storage,omitempty\" json:\"repository_storage,omitempty\"`\n}\n\n// ListAllSnippets gets all snippets the current user has access to.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/snippets.html#list-all-snippets\nfunc (s *SnippetsService) ListAllSnippets(opt *ListAllSnippetsOptions, options ...RequestOptionFunc) ([]*Snippet, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"snippets/all\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ps []*Snippet\n\tresp, err := s.client.Do(req, &ps)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ps, resp, nil\n}\n"
        },
        {
          "name": "snippets_test.go",
          "type": "blob",
          "size": 3.783203125,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSnippetsService_ListSnippets(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":42,\"title\":\"test\"}]`)\n\t})\n\n\topt := &ListSnippetsOptions{Page: 1, PerPage: 10}\n\n\tss, _, err := client.Snippets.ListSnippets(opt)\n\trequire.NoError(t, err)\n\n\twant := []*Snippet{{ID: 42, Title: \"test\"}}\n\trequire.Equal(t, want, ss)\n}\n\nfunc TestSnippetsService_GetSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\":\"test\"}`)\n\t})\n\n\ts, _, err := client.Snippets.GetSnippet(1)\n\trequire.NoError(t, err)\n\n\twant := &Snippet{ID: 1, Title: \"test\"}\n\trequire.Equal(t, want, s)\n}\n\nfunc TestSnippetsService_CreateSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\":\"test\"}`)\n\t})\n\n\topt := &CreateSnippetOptions{\n\t\tTitle:       Ptr(\"test\"),\n\t\tFileName:    Ptr(\"file\"),\n\t\tDescription: Ptr(\"description\"),\n\t\tContent:     Ptr(\"content\"),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\ts, _, err := client.Snippets.CreateSnippet(opt)\n\trequire.NoError(t, err)\n\n\twant := &Snippet{ID: 1, Title: \"test\"}\n\trequire.Equal(t, want, s)\n}\n\nfunc TestSnippetsService_UpdateSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\"id\":1, \"title\":\"test\"}`)\n\t})\n\n\topt := &UpdateSnippetOptions{\n\t\tTitle:       Ptr(\"test\"),\n\t\tFileName:    Ptr(\"file\"),\n\t\tDescription: Ptr(\"description\"),\n\t\tContent:     Ptr(\"content\"),\n\t\tVisibility:  Ptr(PublicVisibility),\n\t}\n\n\ts, _, err := client.Snippets.UpdateSnippet(1, opt)\n\trequire.NoError(t, err)\n\n\twant := &Snippet{ID: 1, Title: \"test\"}\n\trequire.Equal(t, want, s)\n}\n\nfunc TestSnippetsService_DeleteSnippet(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\t_, err := client.Snippets.DeleteSnippet(1)\n\trequire.NoError(t, err)\n}\n\nfunc TestSnippetsService_SnippetContent(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/1/raw\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, \"Hello World\")\n\t})\n\n\tb, _, err := client.Snippets.SnippetContent(1)\n\trequire.NoError(t, err)\n\n\twant := []byte(\"Hello World\")\n\trequire.Equal(t, want, b)\n}\n\nfunc TestSnippetsService_ExploreSnippets(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/public\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":42,\"title\":\"test\"}]`)\n\t})\n\n\topt := &ExploreSnippetsOptions{Page: 1, PerPage: 10}\n\n\tss, _, err := client.Snippets.ExploreSnippets(opt)\n\trequire.NoError(t, err)\n\n\twant := []*Snippet{{ID: 42, Title: \"test\"}}\n\trequire.Equal(t, want, ss)\n}\n\nfunc TestSnippetsService_ListAllSnippets(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/snippets/all\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[{\"id\":113,\"title\":\"Internal Snippet\"}, {\"id\":114,\"title\":\"Private Snippet\"}]`)\n\t})\n\n\topt := &ListAllSnippetsOptions{ListOptions: ListOptions{Page: 1, PerPage: 10}}\n\n\tss, _, err := client.Snippets.ListAllSnippets(opt)\n\trequire.NoError(t, err)\n\n\twant := []*Snippet{{ID: 113, Title: \"Internal Snippet\"}, {ID: 114, Title: \"Private Snippet\"}}\n\trequire.Equal(t, want, ss)\n}\n"
        },
        {
          "name": "strings.go",
          "type": "blob",
          "size": 2.0458984375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\n// Stringify attempts to create a reasonable string representation of types in\n// the Gitlab library.  It does things like resolve pointers to their values\n// and omits struct fields with nil values.\nfunc Stringify(message interface{}) string {\n\tvar buf bytes.Buffer\n\tv := reflect.ValueOf(message)\n\tstringifyValue(&buf, v)\n\treturn buf.String()\n}\n\n// stringifyValue was heavily inspired by the goprotobuf library.\nfunc stringifyValue(buf *bytes.Buffer, val reflect.Value) {\n\tif val.Kind() == reflect.Ptr && val.IsNil() {\n\t\tbuf.WriteString(\"<nil>\")\n\t\treturn\n\t}\n\n\tv := reflect.Indirect(val)\n\n\tswitch v.Kind() {\n\tcase reflect.String:\n\t\tfmt.Fprintf(buf, `\"%s\"`, v)\n\tcase reflect.Slice:\n\t\tbuf.WriteByte('[')\n\t\tfor i := 0; i < v.Len(); i++ {\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteByte(' ')\n\t\t\t}\n\n\t\t\tstringifyValue(buf, v.Index(i))\n\t\t}\n\n\t\tbuf.WriteByte(']')\n\t\treturn\n\tcase reflect.Struct:\n\t\tif v.Type().Name() != \"\" {\n\t\t\tbuf.WriteString(v.Type().String())\n\t\t}\n\n\t\tbuf.WriteByte('{')\n\n\t\tvar sep bool\n\t\tfor i := 0; i < v.NumField(); i++ {\n\t\t\tfv := v.Field(i)\n\t\t\tif fv.Kind() == reflect.Ptr && fv.IsNil() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif fv.Kind() == reflect.Slice && fv.IsNil() {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif sep {\n\t\t\t\tbuf.WriteString(\", \")\n\t\t\t} else {\n\t\t\t\tsep = true\n\t\t\t}\n\n\t\t\tbuf.WriteString(v.Type().Field(i).Name)\n\t\t\tbuf.WriteByte(':')\n\t\t\tstringifyValue(buf, fv)\n\t\t}\n\n\t\tbuf.WriteByte('}')\n\tdefault:\n\t\tif v.CanInterface() {\n\t\t\tfmt.Fprint(buf, v.Interface())\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "strings_test.go",
          "type": "blob",
          "size": 1.0703125,
          "content": "package gitlab\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\ntype Person struct {\n\tName      string\n\tAge       int\n\tNickNames []string\n\tAddress   Address\n\tCompany   *Company\n}\n\ntype Address struct {\n\tStreet   string\n\tCity     string\n\tProvince string\n\tCountry  string\n}\n\ntype Company struct {\n\tName    string\n\tAddress Address\n\tCountry string\n}\n\nfunc TestStringify_nil(t *testing.T) {\n\tvar person *Person\n\tresp := Stringify(person)\n\tassert.Equal(t, \"<nil>\", resp)\n}\n\nfunc TestStringify(t *testing.T) {\n\tperson := &Person{\"name\", 16, []string{\"n\", \"a\", \"m\", \"e\"}, Address{}, nil}\n\tresp := Stringify(person)\n\twant := \"gitlab.Person{Name:\\\"name\\\", Age:16, NickNames:[\\\"n\\\" \\\"a\\\" \\\"m\\\" \\\"e\\\"], Address:gitlab.Address{Street:\\\"\\\", City:\\\"\\\", Province:\\\"\\\", Country:\\\"\\\"}}\"\n\tassert.Equal(t, want, resp)\n}\n\nfunc TestStringify_emptySlice(t *testing.T) {\n\tperson := &Person{\"name\", 16, nil, Address{}, nil}\n\tresp := Stringify(person)\n\twant := \"gitlab.Person{Name:\\\"name\\\", Age:16, Address:gitlab.Address{Street:\\\"\\\", City:\\\"\\\", Province:\\\"\\\", Country:\\\"\\\"}}\"\n\tassert.Equal(t, want, resp)\n}\n"
        },
        {
          "name": "system_hooks.go",
          "type": "blob",
          "size": 5.26171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// SystemHooksService handles communication with the system hooks related\n// methods of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/system_hooks.html\ntype SystemHooksService struct {\n\tclient *Client\n}\n\n// Hook represents a GitLap system hook.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/system_hooks.html\ntype Hook struct {\n\tID                     int        `json:\"id\"`\n\tURL                    string     `json:\"url\"`\n\tCreatedAt              *time.Time `json:\"created_at\"`\n\tPushEvents             bool       `json:\"push_events\"`\n\tTagPushEvents          bool       `json:\"tag_push_events\"`\n\tMergeRequestsEvents    bool       `json:\"merge_requests_events\"`\n\tRepositoryUpdateEvents bool       `json:\"repository_update_events\"`\n\tEnableSSLVerification  bool       `json:\"enable_ssl_verification\"`\n}\n\nfunc (h Hook) String() string {\n\treturn Stringify(h)\n}\n\n// ListHooks gets a list of system hooks.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/system_hooks.html#list-system-hooks\nfunc (s *SystemHooksService) ListHooks(options ...RequestOptionFunc) ([]*Hook, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"hooks\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar h []*Hook\n\tresp, err := s.client.Do(req, &h)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn h, resp, nil\n}\n\n// GetHook get a single system hook.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/system_hooks.html#get-system-hook\nfunc (s *SystemHooksService) GetHook(hook int, options ...RequestOptionFunc) (*Hook, *Response, error) {\n\tu := fmt.Sprintf(\"hooks/%d\", hook)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar h *Hook\n\tresp, err := s.client.Do(req, &h)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn h, resp, nil\n}\n\n// AddHookOptions represents the available AddHook() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/system_hooks.html#add-new-system-hook\ntype AddHookOptions struct {\n\tURL                    *string `url:\"url,omitempty\" json:\"url,omitempty\"`\n\tToken                  *string `url:\"token,omitempty\" json:\"token,omitempty\"`\n\tPushEvents             *bool   `url:\"push_events,omitempty\" json:\"push_events,omitempty\"`\n\tTagPushEvents          *bool   `url:\"tag_push_events,omitempty\" json:\"tag_push_events,omitempty\"`\n\tMergeRequestsEvents    *bool   `url:\"merge_requests_events,omitempty\" json:\"merge_requests_events,omitempty\"`\n\tRepositoryUpdateEvents *bool   `url:\"repository_update_events,omitempty\" json:\"repository_update_events,omitempty\"`\n\tEnableSSLVerification  *bool   `url:\"enable_ssl_verification,omitempty\" json:\"enable_ssl_verification,omitempty\"`\n}\n\n// AddHook adds a new system hook hook.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/system_hooks.html#add-new-system-hook\nfunc (s *SystemHooksService) AddHook(opt *AddHookOptions, options ...RequestOptionFunc) (*Hook, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"hooks\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\th := new(Hook)\n\tresp, err := s.client.Do(req, h)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn h, resp, nil\n}\n\n// HookEvent represents an event trigger by a GitLab system hook.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/system_hooks.html\ntype HookEvent struct {\n\tEventName  string `json:\"event_name\"`\n\tName       string `json:\"name\"`\n\tPath       string `json:\"path\"`\n\tProjectID  int    `json:\"project_id\"`\n\tOwnerName  string `json:\"owner_name\"`\n\tOwnerEmail string `json:\"owner_email\"`\n}\n\nfunc (h HookEvent) String() string {\n\treturn Stringify(h)\n}\n\n// TestHook tests a system hook.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/system_hooks.html#test-system-hook\nfunc (s *SystemHooksService) TestHook(hook int, options ...RequestOptionFunc) (*HookEvent, *Response, error) {\n\tu := fmt.Sprintf(\"hooks/%d\", hook)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\th := new(HookEvent)\n\tresp, err := s.client.Do(req, h)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn h, resp, nil\n}\n\n// DeleteHook deletes a system hook. This is an idempotent API function and\n// returns 200 OK even if the hook is not available. If the hook is deleted it\n// is also returned as JSON.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/system_hooks.html#delete-system-hook\nfunc (s *SystemHooksService) DeleteHook(hook int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"hooks/%d\", hook)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "system_hooks_test.go",
          "type": "blob",
          "size": 3.4755859375,
          "content": "package gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSystemHooksService_ListHooks(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/hooks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t[\n\t\t\t{\n\t\t\t  \"id\":1,\n\t\t\t  \"url\":\"https://gitlab.example.com/hook\",\n\t\t\t  \"created_at\":\"2016-10-31T12:32:15.192Z\",\n\t\t\t  \"push_events\":true,\n\t\t\t  \"tag_push_events\":false,\n\t\t\t  \"merge_requests_events\": true,\n\t\t\t  \"repository_update_events\": true,\n\t\t\t  \"enable_ssl_verification\":true\n\t\t\t}\n\t\t]`)\n\t})\n\n\thooks, _, err := client.SystemHooks.ListHooks()\n\trequire.NoError(t, err)\n\n\tcreatedAt := time.Date(2016, 10, 31, 12, 32, 15, 192000000, time.UTC)\n\twant := []*Hook{{\n\t\tID:                     1,\n\t\tURL:                    \"https://gitlab.example.com/hook\",\n\t\tCreatedAt:              &createdAt,\n\t\tPushEvents:             true,\n\t\tTagPushEvents:          false,\n\t\tMergeRequestsEvents:    true,\n\t\tRepositoryUpdateEvents: true,\n\t\tEnableSSLVerification:  true,\n\t}}\n\trequire.Equal(t, want, hooks)\n}\n\nfunc TestSystemHooksService_GetHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"id\":1,\n\t\t\t\"url\":\"https://gitlab.example.com/hook\",\n\t\t\t\"created_at\":\"2016-10-31T12:32:15.192Z\",\n\t\t\t\"push_events\":true,\n\t\t\t\"tag_push_events\":false,\n\t\t\t\"merge_requests_events\": true,\n\t\t\t\"repository_update_events\": true,\n\t\t\t\"enable_ssl_verification\":true\n\t\t}`)\n\t})\n\n\thooks, _, err := client.SystemHooks.GetHook(1)\n\trequire.NoError(t, err)\n\n\tcreatedAt := time.Date(2016, 10, 31, 12, 32, 15, 192000000, time.UTC)\n\twant := &Hook{\n\t\tID:                     1,\n\t\tURL:                    \"https://gitlab.example.com/hook\",\n\t\tCreatedAt:              &createdAt,\n\t\tPushEvents:             true,\n\t\tTagPushEvents:          false,\n\t\tMergeRequestsEvents:    true,\n\t\tRepositoryUpdateEvents: true,\n\t\tEnableSSLVerification:  true,\n\t}\n\trequire.Equal(t, want, hooks)\n}\n\nfunc TestSystemHooksService_AddHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/hooks\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\"id\": 1, \"url\": \"https://gitlab.example.com/hook\"}`)\n\t})\n\n\topt := &AddHookOptions{\n\t\tURL: Ptr(\"https://gitlab.example.com/hook\"),\n\t}\n\n\thook, _, err := client.SystemHooks.AddHook(opt)\n\trequire.NoError(t, err)\n\n\twant := &Hook{ID: 1, URL: \"https://gitlab.example.com/hook\", CreatedAt: (*time.Time)(nil)}\n\trequire.Equal(t, want, hook)\n}\n\nfunc TestSystemHooksService_TestHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\"project_id\" : 1,\"owner_email\" : \"example@gitlabhq.com\",\"owner_name\" : \"Someone\",\n\t\t\t\t\"name\" : \"Ruby\",\"path\" : \"ruby\",\"event_name\" : \"project_create\"}`)\n\t})\n\n\thook, _, err := client.SystemHooks.TestHook(1)\n\trequire.NoError(t, err)\n\n\twant := &HookEvent{\n\t\tEventName:  \"project_create\",\n\t\tName:       \"Ruby\",\n\t\tPath:       \"ruby\",\n\t\tProjectID:  1,\n\t\tOwnerName:  \"Someone\",\n\t\tOwnerEmail: \"example@gitlabhq.com\",\n\t}\n\trequire.Equal(t, want, hook)\n}\n\nfunc TestSystemHooksService_DeleteHook(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/hooks/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.SystemHooks.DeleteHook(1)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "tags.go",
          "type": "blob",
          "size": 7.291015625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// TagsService handles communication with the tags related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/tags.html\ntype TagsService struct {\n\tclient *Client\n}\n\n// Tag represents a GitLab tag.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/tags.html\ntype Tag struct {\n\tCommit    *Commit      `json:\"commit\"`\n\tRelease   *ReleaseNote `json:\"release\"`\n\tName      string       `json:\"name\"`\n\tMessage   string       `json:\"message\"`\n\tProtected bool         `json:\"protected\"`\n\tTarget    string       `json:\"target\"`\n}\n\n// ReleaseNote represents a GitLab version release.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/tags.html\ntype ReleaseNote struct {\n\tTagName     string `json:\"tag_name\"`\n\tDescription string `json:\"description\"`\n}\n\nfunc (t Tag) String() string {\n\treturn Stringify(t)\n}\n\n// ListTagsOptions represents the available ListTags() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#list-project-repository-tags\ntype ListTagsOptions struct {\n\tListOptions\n\tOrderBy *string `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSearch  *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tSort    *string `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n}\n\n// ListTags gets a list of tags from a project, sorted by name in reverse\n// alphabetical order.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#list-project-repository-tags\nfunc (s *TagsService) ListTags(pid interface{}, opt *ListTagsOptions, options ...RequestOptionFunc) ([]*Tag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tags\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar t []*Tag\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// GetTag a specific repository tag determined by its name. It returns 200 together\n// with the tag information if the tag exists. It returns 404 if the tag does not exist.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#get-a-single-repository-tag\nfunc (s *TagsService) GetTag(pid interface{}, tag string, options ...RequestOptionFunc) (*Tag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tags/%s\", PathEscape(project), url.PathEscape(tag))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar t *Tag\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// CreateTagOptions represents the available CreateTag() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#create-a-new-tag\ntype CreateTagOptions struct {\n\tTagName *string `url:\"tag_name,omitempty\" json:\"tag_name,omitempty\"`\n\tRef     *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n\tMessage *string `url:\"message,omitempty\" json:\"message,omitempty\"`\n\n\t// Deprecated: Use the Releases API instead. (Deprecated in GitLab 11.7)\n\tReleaseDescription *string `url:\"release_description:omitempty\" json:\"release_description,omitempty\"`\n}\n\n// CreateTag creates a new tag in the repository that points to the supplied ref.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#create-a-new-tag\nfunc (s *TagsService) CreateTag(pid interface{}, opt *CreateTagOptions, options ...RequestOptionFunc) (*Tag, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tags\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Tag)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// DeleteTag deletes a tag of a repository with given name.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#delete-a-tag\nfunc (s *TagsService) DeleteTag(pid interface{}, tag string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tags/%s\", PathEscape(project), url.PathEscape(tag))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// CreateReleaseNoteOptions represents the available CreateReleaseNote() options.\n//\n// Deprecated: This feature was deprecated in GitLab 11.7.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#create-a-new-release\ntype CreateReleaseNoteOptions struct {\n\tDescription *string `url:\"description:omitempty\" json:\"description,omitempty\"`\n}\n\n// CreateReleaseNote Add release notes to the existing git tag.\n// If there already exists a release for the given tag, status code 409 is returned.\n//\n// Deprecated: This feature was deprecated in GitLab 11.7.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#create-a-new-release\nfunc (s *TagsService) CreateReleaseNote(pid interface{}, tag string, opt *CreateReleaseNoteOptions, options ...RequestOptionFunc) (*ReleaseNote, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tags/%s/release\", PathEscape(project), url.PathEscape(tag))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(ReleaseNote)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n// UpdateReleaseNoteOptions represents the available UpdateReleaseNote() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#update-a-release\ntype UpdateReleaseNoteOptions struct {\n\tDescription *string `url:\"description:omitempty\" json:\"description,omitempty\"`\n}\n\n// UpdateReleaseNote Updates the release notes of a given release.\n//\n// Deprecated: This feature was deprecated in GitLab 11.7.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/tags.html#update-a-release\nfunc (s *TagsService) UpdateReleaseNote(pid interface{}, tag string, opt *UpdateReleaseNoteOptions, options ...RequestOptionFunc) (*ReleaseNote, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/repository/tags/%s/release\", PathEscape(project), url.PathEscape(tag))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(ReleaseNote)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n"
        },
        {
          "name": "tags_test.go",
          "type": "blob",
          "size": 2.9697265625,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestTagsService_ListTags(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/tags\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n      {\n        \"name\": \"1.0.0\",\n        \"message\": \"test\",\n        \"target\": \"fffff\",\n        \"protected\": false\n      },{\n        \"name\": \"1.0.1\",\n        \"protected\": true\n      }\n    ]`)\n\t})\n\n\topt := &ListTagsOptions{ListOptions: ListOptions{Page: 2, PerPage: 3}}\n\n\ttags, _, err := client.Tags.ListTags(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Tags.ListTags returned error: %v\", err)\n\t}\n\n\twant := []*Tag{\n\t\t{\n\t\t\tName:      \"1.0.0\",\n\t\t\tMessage:   \"test\",\n\t\t\tTarget:    \"fffff\",\n\t\t\tProtected: false,\n\t\t},\n\t\t{\n\t\t\tName:      \"1.0.1\",\n\t\t\tProtected: true,\n\t\t},\n\t}\n\tif !reflect.DeepEqual(want, tags) {\n\t\tt.Errorf(\"Tags.ListTags returned %+v, want %+v\", tags, want)\n\t}\n}\n\nfunc TestTagsService_CreateReleaseNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/tags/1.0.0/release\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\tfmt.Fprint(w, `{\"tag_name\": \"1.0.0\", \"description\": \"Amazing release. Wow\"}`)\n\t\t})\n\n\topt := &CreateReleaseNoteOptions{Description: Ptr(\"Amazing release. Wow\")}\n\n\trelease, _, err := client.Tags.CreateReleaseNote(1, \"1.0.0\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Tags.CreateRelease returned error: %v\", err)\n\t}\n\n\twant := &ReleaseNote{TagName: \"1.0.0\", Description: \"Amazing release. Wow\"}\n\tif !reflect.DeepEqual(want, release) {\n\t\tt.Errorf(\"Tags.CreateRelease returned %+v, want %+v\", release, want)\n\t}\n}\n\nfunc TestTagsService_UpdateReleaseNote(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/repository/tags/1.0.0/release\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodPut)\n\t\t\tfmt.Fprint(w, `{\"tag_name\": \"1.0.0\", \"description\": \"Amazing release. Wow!\"}`)\n\t\t})\n\n\topt := &UpdateReleaseNoteOptions{Description: Ptr(\"Amazing release. Wow!\")}\n\n\trelease, _, err := client.Tags.UpdateReleaseNote(1, \"1.0.0\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Tags.UpdateRelease returned error: %v\", err)\n\t}\n\n\twant := &ReleaseNote{TagName: \"1.0.0\", Description: \"Amazing release. Wow!\"}\n\tif !reflect.DeepEqual(want, release) {\n\t\tt.Errorf(\"Tags.UpdateRelease returned %+v, want %+v\", release, want)\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "time_stats.go",
          "type": "blob",
          "size": 5.2919921875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// timeStatsService handles communication with the time tracking related\n// methods of the GitLab API.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\ntype timeStatsService struct {\n\tclient *Client\n}\n\n// TimeStats represents the time estimates and time spent for an issue.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\ntype TimeStats struct {\n\tHumanTimeEstimate   string `json:\"human_time_estimate\"`\n\tHumanTotalTimeSpent string `json:\"human_total_time_spent\"`\n\tTimeEstimate        int    `json:\"time_estimate\"`\n\tTotalTimeSpent      int    `json:\"total_time_spent\"`\n}\n\nfunc (t TimeStats) String() string {\n\treturn Stringify(t)\n}\n\n// SetTimeEstimateOptions represents the available SetTimeEstimate()\n// options.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\ntype SetTimeEstimateOptions struct {\n\tDuration *string `url:\"duration,omitempty\" json:\"duration,omitempty\"`\n}\n\n// setTimeEstimate sets the time estimate for a single project issue.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\nfunc (s *timeStatsService) setTimeEstimate(pid interface{}, entity string, issue int, opt *SetTimeEstimateOptions, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/time_estimate\", PathEscape(project), entity, issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(TimeStats)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// resetTimeEstimate resets the time estimate for a single project issue.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\nfunc (s *timeStatsService) resetTimeEstimate(pid interface{}, entity string, issue int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/reset_time_estimate\", PathEscape(project), entity, issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(TimeStats)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// AddSpentTimeOptions represents the available AddSpentTime() options.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\ntype AddSpentTimeOptions struct {\n\tDuration *string `url:\"duration,omitempty\" json:\"duration,omitempty\"`\n\tSummary  *string `url:\"summary,omitempty\" json:\"summary,omitempty\"`\n}\n\n// addSpentTime adds spent time for a single project issue.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\nfunc (s *timeStatsService) addSpentTime(pid interface{}, entity string, issue int, opt *AddSpentTimeOptions, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/add_spent_time\", PathEscape(project), entity, issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(TimeStats)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// resetSpentTime resets the spent time for a single project issue.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\nfunc (s *timeStatsService) resetSpentTime(pid interface{}, entity string, issue int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/reset_spent_time\", PathEscape(project), entity, issue)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(TimeStats)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// getTimeSpent gets the spent time for a single project issue.\n//\n// GitLab docs: https://docs.gitlab.com/ee/workflow/time_tracking.html\nfunc (s *timeStatsService) getTimeSpent(pid interface{}, entity string, issue int, options ...RequestOptionFunc) (*TimeStats, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/%s/%d/time_stats\", PathEscape(project), entity, issue)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(TimeStats)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n"
        },
        {
          "name": "todos.go",
          "type": "blob",
          "size": 6.2412109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// TodosService handles communication with the todos related methods of\n// the Gitlab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html\ntype TodosService struct {\n\tclient *Client\n}\n\n// Todo represents a GitLab todo.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html\ntype Todo struct {\n\tID         int            `json:\"id\"`\n\tProject    *BasicProject  `json:\"project\"`\n\tAuthor     *BasicUser     `json:\"author\"`\n\tActionName TodoAction     `json:\"action_name\"`\n\tTargetType TodoTargetType `json:\"target_type\"`\n\tTarget     *TodoTarget    `json:\"target\"`\n\tTargetURL  string         `json:\"target_url\"`\n\tBody       string         `json:\"body\"`\n\tState      string         `json:\"state\"`\n\tCreatedAt  *time.Time     `json:\"created_at\"`\n}\n\nfunc (t Todo) String() string {\n\treturn Stringify(t)\n}\n\n// TodoTarget represents a todo target of type Issue or MergeRequest\ntype TodoTarget struct {\n\tAssignees            []*BasicUser           `json:\"assignees\"`\n\tAssignee             *BasicUser             `json:\"assignee\"`\n\tAuthor               *BasicUser             `json:\"author\"`\n\tCreatedAt            *time.Time             `json:\"created_at\"`\n\tDescription          string                 `json:\"description\"`\n\tDownvotes            int                    `json:\"downvotes\"`\n\tID                   interface{}            `json:\"id\"`\n\tIID                  int                    `json:\"iid\"`\n\tLabels               []string               `json:\"labels\"`\n\tMilestone            *Milestone             `json:\"milestone\"`\n\tProjectID            int                    `json:\"project_id\"`\n\tState                string                 `json:\"state\"`\n\tSubscribed           bool                   `json:\"subscribed\"`\n\tTaskCompletionStatus *TasksCompletionStatus `json:\"task_completion_status\"`\n\tTitle                string                 `json:\"title\"`\n\tUpdatedAt            *time.Time             `json:\"updated_at\"`\n\tUpvotes              int                    `json:\"upvotes\"`\n\tUserNotesCount       int                    `json:\"user_notes_count\"`\n\tWebURL               string                 `json:\"web_url\"`\n\n\t// Only available for type Issue\n\tConfidential bool        `json:\"confidential\"`\n\tDueDate      string      `json:\"due_date\"`\n\tHasTasks     bool        `json:\"has_tasks\"`\n\tLinks        *IssueLinks `json:\"_links\"`\n\tMovedToID    int         `json:\"moved_to_id\"`\n\tTimeStats    *TimeStats  `json:\"time_stats\"`\n\tWeight       int         `json:\"weight\"`\n\n\t// Only available for type MergeRequest\n\tMergedAt                  *time.Time   `json:\"merged_at\"`\n\tApprovalsBeforeMerge      int          `json:\"approvals_before_merge\"`\n\tForceRemoveSourceBranch   bool         `json:\"force_remove_source_branch\"`\n\tMergeCommitSHA            string       `json:\"merge_commit_sha\"`\n\tMergeWhenPipelineSucceeds bool         `json:\"merge_when_pipeline_succeeds\"`\n\tMergeStatus               string       `json:\"merge_status\"`\n\tReference                 string       `json:\"reference\"`\n\tReviewers                 []*BasicUser `json:\"reviewers\"`\n\tSHA                       string       `json:\"sha\"`\n\tShouldRemoveSourceBranch  bool         `json:\"should_remove_source_branch\"`\n\tSourceBranch              string       `json:\"source_branch\"`\n\tSourceProjectID           int          `json:\"source_project_id\"`\n\tSquash                    bool         `json:\"squash\"`\n\tTargetBranch              string       `json:\"target_branch\"`\n\tTargetProjectID           int          `json:\"target_project_id\"`\n\tWorkInProgress            bool         `json:\"work_in_progress\"`\n\n\t// Only available for type DesignManagement::Design\n\tFileName string `json:\"filename\"`\n\tImageURL string `json:\"image_url\"`\n}\n\n// ListTodosOptions represents the available ListTodos() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html#get-a-list-of-to-do-items\ntype ListTodosOptions struct {\n\tListOptions\n\tAction    *TodoAction `url:\"action,omitempty\" json:\"action,omitempty\"`\n\tAuthorID  *int        `url:\"author_id,omitempty\" json:\"author_id,omitempty\"`\n\tProjectID *int        `url:\"project_id,omitempty\" json:\"project_id,omitempty\"`\n\tState     *string     `url:\"state,omitempty\" json:\"state,omitempty\"`\n\tType      *string     `url:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\n// ListTodos lists all todos created by authenticated user.\n// When no filter is applied, it returns all pending todos for the current user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/todos.html#get-a-list-of-to-do-items\nfunc (s *TodosService) ListTodos(opt *ListTodosOptions, options ...RequestOptionFunc) ([]*Todo, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"todos\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar t []*Todo\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// MarkTodoAsDone marks a single pending todo given by its ID for the current user as done.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html#mark-a-to-do-item-as-done\nfunc (s *TodosService) MarkTodoAsDone(id int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"todos/%d/mark_as_done\", id)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// MarkAllTodosAsDone marks all pending todos for the current user as done.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html#mark-all-to-do-items-as-done\nfunc (s *TodosService) MarkAllTodosAsDone(options ...RequestOptionFunc) (*Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"todos/mark_as_done\", nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "todos_test.go",
          "type": "blob",
          "size": 1.8583984375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"net/http\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestListTodos(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/todos\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/list_todos.json\")\n\t})\n\n\topts := &ListTodosOptions{ListOptions: ListOptions{PerPage: 2}}\n\ttodos, _, err := client.Todos.ListTodos(opts)\n\n\trequire.NoError(t, err)\n\n\twant := []*Todo{\n\t\t{ID: 1, State: \"pending\", Target: &TodoTarget{ID: float64(1), ApprovalsBeforeMerge: 2}},\n\t\t{ID: 2, State: \"pending\", Target: &TodoTarget{ID: \"1d76d1b2e3e886108f662765c97f4687f4134d8c\"}},\n\t}\n\trequire.Equal(t, want, todos)\n}\n\nfunc TestMarkAllTodosAsDone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/todos/mark_as_done\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\t_, err := client.Todos.MarkAllTodosAsDone()\n\trequire.NoError(t, err)\n}\n\nfunc TestMarkTodoAsDone(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/todos/1/mark_as_done\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t})\n\n\t_, err := client.Todos.MarkTodoAsDone(1)\n\trequire.NoError(t, err)\n}\n"
        },
        {
          "name": "topics.go",
          "type": "blob",
          "size": 6.021484375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\n\tretryablehttp \"github.com/hashicorp/go-retryablehttp\"\n)\n\n// TopicsService handles communication with the topics related methods\n// of the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/topics.html\ntype TopicsService struct {\n\tclient *Client\n}\n\n// Topic represents a GitLab project topic.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/topics.html\ntype Topic struct {\n\tID                 int    `json:\"id\"`\n\tName               string `json:\"name\"`\n\tTitle              string `json:\"title\"`\n\tDescription        string `json:\"description\"`\n\tTotalProjectsCount uint64 `json:\"total_projects_count\"`\n\tAvatarURL          string `json:\"avatar_url\"`\n}\n\nfunc (t Topic) String() string {\n\treturn Stringify(t)\n}\n\n// ListTopicsOptions represents the available ListTopics() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/topics.html#list-topics\ntype ListTopicsOptions struct {\n\tListOptions\n\tSearch *string `url:\"search,omitempty\" json:\"search,omitempty\"`\n}\n\n// ListTopics returns a list of project topics in the GitLab instance ordered\n// by number of associated projects.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/topics.html#list-topics\nfunc (s *TopicsService) ListTopics(opt *ListTopicsOptions, options ...RequestOptionFunc) ([]*Topic, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"topics\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar t []*Topic\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// GetTopic gets a project topic by ID.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/topics.html#get-a-topic\nfunc (s *TopicsService) GetTopic(topic int, options ...RequestOptionFunc) (*Topic, *Response, error) {\n\tu := fmt.Sprintf(\"topics/%d\", topic)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Topic)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// CreateTopicOptions represents the available CreateTopic() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/topics.html#create-a-project-topic\ntype CreateTopicOptions struct {\n\tName        *string      `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tTitle       *string      `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription *string      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tAvatar      *TopicAvatar `url:\"-\" json:\"-\"`\n}\n\n// TopicAvatar represents a GitLab topic avatar.\ntype TopicAvatar struct {\n\tFilename string\n\tImage    io.Reader\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a *TopicAvatar) MarshalJSON() ([]byte, error) {\n\tif a.Filename == \"\" && a.Image == nil {\n\t\treturn []byte(`\"\"`), nil\n\t}\n\ttype alias TopicAvatar\n\treturn json.Marshal((*alias)(a))\n}\n\n// CreateTopic creates a new project topic.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/topics.html#create-a-project-topic\nfunc (s *TopicsService) CreateTopic(opt *CreateTopicOptions, options ...RequestOptionFunc) (*Topic, *Response, error) {\n\tvar err error\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil {\n\t\treq, err = s.client.NewRequest(http.MethodPost, \"topics\", opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPost,\n\t\t\t\"topics\",\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Topic)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// UpdateTopicOptions represents the available UpdateTopic() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/topics.html#update-a-project-topic\ntype UpdateTopicOptions struct {\n\tName        *string      `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tTitle       *string      `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tDescription *string      `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tAvatar      *TopicAvatar `url:\"-\" json:\"avatar,omitempty\"`\n}\n\n// UpdateTopic updates a project topic. Only available to administrators.\n//\n// To remove a topic avatar set the TopicAvatar.Filename to an empty string\n// and set TopicAvatar.Image to nil.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/topics.html#update-a-project-topic\nfunc (s *TopicsService) UpdateTopic(topic int, opt *UpdateTopicOptions, options ...RequestOptionFunc) (*Topic, *Response, error) {\n\tu := fmt.Sprintf(\"topics/%d\", topic)\n\n\tvar err error\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil || (opt.Avatar.Filename == \"\" && opt.Avatar.Image == nil) {\n\t\treq, err = s.client.NewRequest(http.MethodPut, u, opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPut,\n\t\t\tu,\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(Topic)\n\tresp, err := s.client.Do(req, t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// DeleteTopic deletes a project topic. Only available to administrators.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/topics.html#delete-a-project-topic\nfunc (s *TopicsService) DeleteTopic(topic int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"topics/%d\", topic)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "topics_test.go",
          "type": "blob",
          "size": 5.224609375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestTopicsService_ListTopics(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/topics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `[\n      {\n        \"id\": 1,\n        \"name\": \"gitlab\",\n        \"title\": \"GitLab\",\n        \"description\": \"GitLab is a version control system\",\n        \"total_projects_count\": 1000,\n        \"avatar_url\": \"http://www.gravatar.com/avatar/a0d477b3ea21970ce6ffcbb817b0b435?s=80&d=identicon\"\n      },\n      {\n        \"id\": 3,\n        \"name\": \"git\",\n        \"title\": \"Git\",\n        \"description\": \"Git is free and open source\",\n        \"total_projects_count\": 900,\n        \"avatar_url\": \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\"\n      },\n      {\n        \"id\": 2,\n        \"name\": \"git-lfs\",\n        \"title\": \"Git LFS\",\n        \"description\": null,\n        \"total_projects_count\": 300,\n        \"avatar_url\": null\n      }\n    ]`)\n\t})\n\n\topt := &ListTopicsOptions{Search: Ptr(\"git\")}\n\ttopics, _, err := client.Topics.ListTopics(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Tags.ListTags returned error: %v\", err)\n\t}\n\n\twant := []*Topic{{\n\t\tID:                 1,\n\t\tName:               \"gitlab\",\n\t\tTitle:              \"GitLab\",\n\t\tDescription:        \"GitLab is a version control system\",\n\t\tTotalProjectsCount: 1000,\n\t\tAvatarURL:          \"http://www.gravatar.com/avatar/a0d477b3ea21970ce6ffcbb817b0b435?s=80&d=identicon\",\n\t}, {\n\t\tID:                 3,\n\t\tName:               \"git\",\n\t\tTitle:              \"Git\",\n\t\tDescription:        \"Git is free and open source\",\n\t\tTotalProjectsCount: 900,\n\t\tAvatarURL:          \"http://www.gravatar.com/avatar/e64c7d89f26bd1972efa854d13d7dd61?s=80&d=identicon\",\n\t}, {\n\t\tID:                 2,\n\t\tName:               \"git-lfs\",\n\t\tTitle:              \"Git LFS\",\n\t\tTotalProjectsCount: 300,\n\t}}\n\tif !reflect.DeepEqual(want, topics) {\n\t\tt.Errorf(\"Topics.ListTopics returned %+v, want %+v\", topics, want)\n\t}\n}\n\nfunc TestTopicsService_GetTopic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/topics/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"name\": \"gitlab\",\n      \"title\": \"GitLab\",\n      \"Description\": \"GitLab is a version control system\",\n      \"total_projects_count\": 1000,\n      \"avatar_url\": \"http://www.gravatar.com/avatar/a0d477b3ea21970ce6ffcbb817b0b435?s=80&d=identicon\"\n    }`)\n\t})\n\n\trelease, _, err := client.Topics.GetTopic(1)\n\tif err != nil {\n\t\tt.Errorf(\"Topics.GetTopic returned error: %v\", err)\n\t}\n\n\twant := &Topic{\n\t\tID:                 1,\n\t\tName:               \"gitlab\",\n\t\tTitle:              \"GitLab\",\n\t\tDescription:        \"GitLab is a version control system\",\n\t\tTotalProjectsCount: 1000,\n\t\tAvatarURL:          \"http://www.gravatar.com/avatar/a0d477b3ea21970ce6ffcbb817b0b435?s=80&d=identicon\",\n\t}\n\tif !reflect.DeepEqual(want, release) {\n\t\tt.Errorf(\"Topics.GetTopic returned %+v, want %+v\", release, want)\n\t}\n}\n\nfunc TestTopicsService_CreateTopic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/topics\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"name\": \"topic1\",\n      \"title\": \"Topic 1\",\n      \"description\": \"description\",\n      \"total_projects_count\": 0,\n      \"avatar_url\": null\n    }`)\n\t})\n\n\topt := &CreateTopicOptions{Name: Ptr(\"topic1\"), Title: Ptr(\"Topic 1\"), Description: Ptr(\"description\")}\n\trelease, _, err := client.Topics.CreateTopic(opt)\n\tif err != nil {\n\t\tt.Errorf(\"Topics.CreateTopic returned error: %v\", err)\n\t}\n\n\twant := &Topic{ID: 1, Name: \"topic1\", Title: \"Topic 1\", Description: \"description\", TotalProjectsCount: 0}\n\tif !reflect.DeepEqual(want, release) {\n\t\tt.Errorf(\"Topics.CreateTopic returned %+v, want %+v\", release, want)\n\t}\n}\n\nfunc TestTopicsService_UpdateTopic(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/topics/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprint(w, `{\n      \"id\": 1,\n      \"name\": \"topic1\",\n      \"title\": \"Topic 1\",\n      \"description\": \"description\",\n      \"total_projects_count\": 0,\n      \"avatar_url\": null\n    }`)\n\t})\n\n\topt := &UpdateTopicOptions{Name: Ptr(\"topic1\"), Title: Ptr(\"Topic 1\"), Description: Ptr(\"description\")}\n\trelease, _, err := client.Topics.UpdateTopic(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Topics.UpdateTopic returned error: %v\", err)\n\t}\n\n\twant := &Topic{ID: 1, Name: \"topic1\", Title: \"Topic 1\", Description: \"description\", TotalProjectsCount: 0}\n\tif !reflect.DeepEqual(want, release) {\n\t\tt.Errorf(\"Topics.UpdateTopic returned %+v, want %+v\", release, want)\n\t}\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 31.642578125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Ptr is a helper that returns a pointer to v.\nfunc Ptr[T any](v T) *T {\n\treturn &v\n}\n\n// AccessControlValue represents an access control value within GitLab,\n// used for managing access to certain project features.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html\ntype AccessControlValue string\n\n// List of available access control values.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html\nconst (\n\tDisabledAccessControl AccessControlValue = \"disabled\"\n\tEnabledAccessControl  AccessControlValue = \"enabled\"\n\tPrivateAccessControl  AccessControlValue = \"private\"\n\tPublicAccessControl   AccessControlValue = \"public\"\n)\n\n// AccessControl is a helper routine that allocates a new AccessControlValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc AccessControl(v AccessControlValue) *AccessControlValue {\n\treturn Ptr(v)\n}\n\n// AccessLevelValue represents a permission level within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/user/permissions.html\ntype AccessLevelValue int\n\n// List of available access levels.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/user/permissions.html\nconst (\n\tNoPermissions            AccessLevelValue = 0\n\tMinimalAccessPermissions AccessLevelValue = 5\n\tGuestPermissions         AccessLevelValue = 10\n\tReporterPermissions      AccessLevelValue = 20\n\tDeveloperPermissions     AccessLevelValue = 30\n\tMaintainerPermissions    AccessLevelValue = 40\n\tOwnerPermissions         AccessLevelValue = 50\n\tAdminPermissions         AccessLevelValue = 60\n\n\t// Deprecated: Renamed to MaintainerPermissions in GitLab 11.0.\n\tMasterPermissions AccessLevelValue = 40\n\t// Deprecated: Renamed to OwnerPermissions.\n\tOwnerPermission AccessLevelValue = 50\n)\n\n// AccessLevel is a helper routine that allocates a new AccessLevelValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc AccessLevel(v AccessLevelValue) *AccessLevelValue {\n\treturn Ptr(v)\n}\n\ntype AccessLevelDetails struct {\n\tIntegerValue AccessLevelValue `json:\"integer_value\"`\n\tStringValue  string           `json:\"string_value\"`\n}\n\n// UserIDValue represents a user ID value within GitLab.\ntype UserIDValue string\n\n// List of available user ID values.\nconst (\n\tUserIDAny  UserIDValue = \"Any\"\n\tUserIDNone UserIDValue = \"None\"\n)\n\n// ApproverIDsValue represents an approver ID value within GitLab.\ntype ApproverIDsValue struct {\n\tvalue interface{}\n}\n\n// ApproverIDs is a helper routine that creates a new ApproverIDsValue.\nfunc ApproverIDs(v interface{}) *ApproverIDsValue {\n\tswitch v.(type) {\n\tcase UserIDValue, []int:\n\t\treturn &ApproverIDsValue{value: v}\n\tdefault:\n\t\tpanic(\"Unsupported value passed as approver ID\")\n\t}\n}\n\n// EncodeValues implements the query.Encoder interface.\nfunc (a *ApproverIDsValue) EncodeValues(key string, v *url.Values) error {\n\tswitch value := a.value.(type) {\n\tcase UserIDValue:\n\t\tv.Set(key, string(value))\n\tcase []int:\n\t\tv.Del(key)\n\t\tv.Del(key + \"[]\")\n\t\tfor _, id := range value {\n\t\t\tv.Add(key+\"[]\", strconv.Itoa(id))\n\t\t}\n\t}\n\treturn nil\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a ApproverIDsValue) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(a.value)\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (a *ApproverIDsValue) UnmarshalJSON(bytes []byte) error {\n\treturn json.Unmarshal(bytes, a.value)\n}\n\n// AssigneeIDValue represents an assignee ID value within GitLab.\ntype AssigneeIDValue struct {\n\tvalue interface{}\n}\n\n// AssigneeID is a helper routine that creates a new AssigneeIDValue.\nfunc AssigneeID(v interface{}) *AssigneeIDValue {\n\tswitch v.(type) {\n\tcase UserIDValue, int:\n\t\treturn &AssigneeIDValue{value: v}\n\tdefault:\n\t\tpanic(\"Unsupported value passed as assignee ID\")\n\t}\n}\n\n// EncodeValues implements the query.Encoder interface.\nfunc (a *AssigneeIDValue) EncodeValues(key string, v *url.Values) error {\n\tswitch value := a.value.(type) {\n\tcase UserIDValue:\n\t\tv.Set(key, string(value))\n\tcase int:\n\t\tv.Set(key, strconv.Itoa(value))\n\t}\n\treturn nil\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a AssigneeIDValue) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(a.value)\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (a *AssigneeIDValue) UnmarshalJSON(bytes []byte) error {\n\treturn json.Unmarshal(bytes, a.value)\n}\n\n// ReviewerIDValue represents a reviewer ID value within GitLab.\ntype ReviewerIDValue struct {\n\tvalue interface{}\n}\n\n// ReviewerID is a helper routine that creates a new ReviewerIDValue.\nfunc ReviewerID(v interface{}) *ReviewerIDValue {\n\tswitch v.(type) {\n\tcase UserIDValue, int:\n\t\treturn &ReviewerIDValue{value: v}\n\tdefault:\n\t\tpanic(\"Unsupported value passed as reviewer ID\")\n\t}\n}\n\n// EncodeValues implements the query.Encoder interface.\nfunc (a *ReviewerIDValue) EncodeValues(key string, v *url.Values) error {\n\tswitch value := a.value.(type) {\n\tcase UserIDValue:\n\t\tv.Set(key, string(value))\n\tcase int:\n\t\tv.Set(key, strconv.Itoa(value))\n\t}\n\treturn nil\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a ReviewerIDValue) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(a.value)\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (a *ReviewerIDValue) UnmarshalJSON(bytes []byte) error {\n\treturn json.Unmarshal(bytes, a.value)\n}\n\n// AvailabilityValue represents an availability value within GitLab.\ntype AvailabilityValue string\n\n// List of available availability values.\n//\n// Undocummented, see code at:\n// https://gitlab.com/gitlab-org/gitlab-foss/-/blob/master/app/models/user_status.rb#L22\nconst (\n\tNotSet AvailabilityValue = \"not_set\"\n\tBusy   AvailabilityValue = \"busy\"\n)\n\n// Availability is a helper routine that allocates a new AvailabilityValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc Availability(v AvailabilityValue) *AvailabilityValue {\n\treturn Ptr(v)\n}\n\n// BuildStateValue represents a GitLab build state.\ntype BuildStateValue string\n\n// These constants represent all valid build states.\nconst (\n\tCreated            BuildStateValue = \"created\"\n\tWaitingForResource BuildStateValue = \"waiting_for_resource\"\n\tPreparing          BuildStateValue = \"preparing\"\n\tPending            BuildStateValue = \"pending\"\n\tRunning            BuildStateValue = \"running\"\n\tSuccess            BuildStateValue = \"success\"\n\tFailed             BuildStateValue = \"failed\"\n\tCanceled           BuildStateValue = \"canceled\"\n\tSkipped            BuildStateValue = \"skipped\"\n\tManual             BuildStateValue = \"manual\"\n\tScheduled          BuildStateValue = \"scheduled\"\n)\n\n// BuildState is a helper routine that allocates a new BuildStateValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc BuildState(v BuildStateValue) *BuildStateValue {\n\treturn Ptr(v)\n}\n\n// CommentEventAction identifies if a comment has been newly created or updated.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/project/integrations/webhook_events.html#comment-events\ntype CommentEventAction string\n\nconst (\n\tCommentEventActionCreate CommentEventAction = \"create\"\n\tCommentEventActionUpdate CommentEventAction = \"update\"\n)\n\n// ContainerRegistryStatus represents the status of a Container Registry.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/container_registry.html#list-registry-repositories\ntype ContainerRegistryStatus string\n\n// ContainerRegistryStatus represents all valid statuses of a Container Registry.\n//\n// Undocumented, see code at:\n// https://gitlab.com/gitlab-org/gitlab/-/blob/master/app/models/container_repository.rb?ref_type=heads#L35\nconst (\n\tContainerRegistryStatusDeleteScheduled ContainerRegistryStatus = \"delete_scheduled\"\n\tContainerRegistryStatusDeleteFailed    ContainerRegistryStatus = \"delete_failed\"\n\tContainerRegistryStatusDeleteOngoing   ContainerRegistryStatus = \"delete_ongoing\"\n)\n\n// DeploymentApprovalStatus represents a Gitlab deployment approval status.\ntype DeploymentApprovalStatus string\n\n// These constants represent all valid deployment approval statuses.\nconst (\n\tDeploymentApprovalStatusApproved DeploymentApprovalStatus = \"approved\"\n\tDeploymentApprovalStatusRejected DeploymentApprovalStatus = \"rejected\"\n)\n\n// DeploymentStatusValue represents a Gitlab deployment status.\ntype DeploymentStatusValue string\n\n// These constants represent all valid deployment statuses.\nconst (\n\tDeploymentStatusCreated  DeploymentStatusValue = \"created\"\n\tDeploymentStatusRunning  DeploymentStatusValue = \"running\"\n\tDeploymentStatusSuccess  DeploymentStatusValue = \"success\"\n\tDeploymentStatusFailed   DeploymentStatusValue = \"failed\"\n\tDeploymentStatusCanceled DeploymentStatusValue = \"canceled\"\n)\n\n// DeploymentStatus is a helper routine that allocates a new\n// DeploymentStatusValue to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc DeploymentStatus(v DeploymentStatusValue) *DeploymentStatusValue {\n\treturn Ptr(v)\n}\n\n// DORAMetricType represents all valid DORA metrics types.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\ntype DORAMetricType string\n\n// List of available DORA metric type names.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\nconst (\n\tDORAMetricDeploymentFrequency  DORAMetricType = \"deployment_frequency\"\n\tDORAMetricLeadTimeForChanges   DORAMetricType = \"lead_time_for_changes\"\n\tDORAMetricTimeToRestoreService DORAMetricType = \"time_to_restore_service\"\n\tDORAMetricChangeFailureRate    DORAMetricType = \"change_failure_rate\"\n)\n\n// DORAMetricInterval represents the time period over which the\n// metrics are aggregated.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\ntype DORAMetricInterval string\n\n// List of available DORA metric interval types.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/dora/metrics.html\nconst (\n\tDORAMetricIntervalDaily   DORAMetricInterval = \"daily\"\n\tDORAMetricIntervalMonthly DORAMetricInterval = \"monthly\"\n\tDORAMetricIntervalAll     DORAMetricInterval = \"all\"\n)\n\n// EventTypeValue represents actions type for contribution events.\ntype EventTypeValue string\n\n// List of available action type.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/user/profile/contributions_calendar.html#user-contribution-events\nconst (\n\tCreatedEventType   EventTypeValue = \"created\"\n\tUpdatedEventType   EventTypeValue = \"updated\"\n\tClosedEventType    EventTypeValue = \"closed\"\n\tReopenedEventType  EventTypeValue = \"reopened\"\n\tPushedEventType    EventTypeValue = \"pushed\"\n\tCommentedEventType EventTypeValue = \"commented\"\n\tMergedEventType    EventTypeValue = \"merged\"\n\tJoinedEventType    EventTypeValue = \"joined\"\n\tLeftEventType      EventTypeValue = \"left\"\n\tDestroyedEventType EventTypeValue = \"destroyed\"\n\tExpiredEventType   EventTypeValue = \"expired\"\n)\n\n// EventTargetTypeValue represents actions type value for contribution events.\ntype EventTargetTypeValue string\n\n// List of available action type.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/events.html#target-types\nconst (\n\tIssueEventTargetType        EventTargetTypeValue = \"issue\"\n\tMilestoneEventTargetType    EventTargetTypeValue = \"milestone\"\n\tMergeRequestEventTargetType EventTargetTypeValue = \"merge_request\"\n\tNoteEventTargetType         EventTargetTypeValue = \"note\"\n\tProjectEventTargetType      EventTargetTypeValue = \"project\"\n\tSnippetEventTargetType      EventTargetTypeValue = \"snippet\"\n\tUserEventTargetType         EventTargetTypeValue = \"user\"\n)\n\n// FileActionValue represents the available actions that can be performed on a file.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/commits.html#create-a-commit-with-multiple-files-and-actions\ntype FileActionValue string\n\n// The available file actions.\nconst (\n\tFileCreate FileActionValue = \"create\"\n\tFileDelete FileActionValue = \"delete\"\n\tFileMove   FileActionValue = \"move\"\n\tFileUpdate FileActionValue = \"update\"\n\tFileChmod  FileActionValue = \"chmod\"\n)\n\n// FileAction is a helper routine that allocates a new FileActionValue value\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc FileAction(v FileActionValue) *FileActionValue {\n\treturn Ptr(v)\n}\n\n// GenericPackageSelectValue represents a generic package select value.\ntype GenericPackageSelectValue string\n\n// The available generic package select values.\nconst (\n\tSelectPackageFile GenericPackageSelectValue = \"package_file\"\n)\n\n// GenericPackageSelect is a helper routine that allocates a new\n// GenericPackageSelectValue value to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc GenericPackageSelect(v GenericPackageSelectValue) *GenericPackageSelectValue {\n\treturn Ptr(v)\n}\n\n// GenericPackageStatusValue represents a generic package status.\ntype GenericPackageStatusValue string\n\n// The available generic package statuses.\nconst (\n\tPackageDefault GenericPackageStatusValue = \"default\"\n\tPackageHidden  GenericPackageStatusValue = \"hidden\"\n)\n\n// GenericPackageStatus is a helper routine that allocates a new\n// GenericPackageStatusValue value to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc GenericPackageStatus(v GenericPackageStatusValue) *GenericPackageStatusValue {\n\treturn Ptr(v)\n}\n\n// GroupHookTrigger represents the type of event to trigger for a group\n// hook test.\ntype GroupHookTrigger string\n\n// List of available group hook trigger types.\nconst (\n\tGroupHookTriggerPush                GroupHookTrigger = \"push_events\"\n\tGroupHookTriggerTagPush             GroupHookTrigger = \"tag_push_events\"\n\tGroupHookTriggerIssue               GroupHookTrigger = \"issues_events\"\n\tGroupHookTriggerConfidentialIssue   GroupHookTrigger = \"confidential_issues_events\"\n\tGroupHookTriggerNote                GroupHookTrigger = \"note_events\"\n\tGroupHookTriggerMergeRequest        GroupHookTrigger = \"merge_requests_events\"\n\tGroupHookTriggerJob                 GroupHookTrigger = \"job_events\"\n\tGroupHookTriggerPipeline            GroupHookTrigger = \"pipeline_events\"\n\tGroupHookTriggerWikiPage            GroupHookTrigger = \"wiki_page_events\"\n\tGroupHookTriggerRelease             GroupHookTrigger = \"releases_events\"\n\tGroupHookTriggerEmoji               GroupHookTrigger = \"emoji_events\"\n\tGroupHookTriggerResourceAccessToken GroupHookTrigger = \"resource_access_token_events\"\n)\n\n// ISOTime represents an ISO 8601 formatted date.\ntype ISOTime time.Time\n\n// ISO 8601 date format.\nconst iso8601 = \"2006-01-02\"\n\n// ParseISOTime parses an ISO 8601 formatted date.\nfunc ParseISOTime(s string) (ISOTime, error) {\n\tt, err := time.Parse(iso8601, s)\n\treturn ISOTime(t), err\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (t ISOTime) MarshalJSON() ([]byte, error) {\n\tif reflect.ValueOf(t).IsZero() {\n\t\treturn []byte(`null`), nil\n\t}\n\n\tif y := time.Time(t).Year(); y < 0 || y >= 10000 {\n\t\t// ISO 8901 uses 4 digits for the years.\n\t\treturn nil, errors.New(\"json: ISOTime year outside of range [0,9999]\")\n\t}\n\n\tb := make([]byte, 0, len(iso8601)+2)\n\tb = append(b, '\"')\n\tb = time.Time(t).AppendFormat(b, iso8601)\n\tb = append(b, '\"')\n\n\treturn b, nil\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (t *ISOTime) UnmarshalJSON(data []byte) error {\n\t// Ignore null, like in the main JSON package.\n\tif string(data) == \"null\" {\n\t\treturn nil\n\t}\n\n\tisotime, err := time.Parse(`\"`+iso8601+`\"`, string(data))\n\t*t = ISOTime(isotime)\n\n\treturn err\n}\n\n// EncodeValues implements the query.Encoder interface.\nfunc (t *ISOTime) EncodeValues(key string, v *url.Values) error {\n\tif t == nil || (time.Time(*t)).IsZero() {\n\t\treturn nil\n\t}\n\tv.Add(key, t.String())\n\treturn nil\n}\n\n// String implements the Stringer interface.\nfunc (t ISOTime) String() string {\n\treturn time.Time(t).Format(iso8601)\n}\n\n// Labels represents a list of labels.\ntype Labels []string\n\n// LabelOptions is a custom type with specific marshaling characteristics.\ntype LabelOptions []string\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (l *LabelOptions) MarshalJSON() ([]byte, error) {\n\tif *l == nil {\n\t\treturn []byte(`null`), nil\n\t}\n\treturn json.Marshal(strings.Join(*l, \",\"))\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (l *LabelOptions) UnmarshalJSON(data []byte) error {\n\ttype alias LabelOptions\n\tif !bytes.HasPrefix(data, []byte(\"[\")) {\n\t\tdata = []byte(fmt.Sprintf(\"[%s]\", string(data)))\n\t}\n\treturn json.Unmarshal(data, (*alias)(l))\n}\n\n// EncodeValues implements the query.EncodeValues interface.\nfunc (l *LabelOptions) EncodeValues(key string, v *url.Values) error {\n\tv.Set(key, strings.Join(*l, \",\"))\n\treturn nil\n}\n\n// LinkTypeValue represents a release link type.\ntype LinkTypeValue string\n\n// List of available release link types.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/releases/links.html#create-a-release-link\nconst (\n\tImageLinkType   LinkTypeValue = \"image\"\n\tOtherLinkType   LinkTypeValue = \"other\"\n\tPackageLinkType LinkTypeValue = \"package\"\n\tRunbookLinkType LinkTypeValue = \"runbook\"\n)\n\n// LinkType is a helper routine that allocates a new LinkType value\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc LinkType(v LinkTypeValue) *LinkTypeValue {\n\treturn Ptr(v)\n}\n\n// LicenseApprovalStatusValue describe the approval statuses of a license.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/managed_licenses.html\ntype LicenseApprovalStatusValue string\n\n// List of available license approval statuses.\nconst (\n\tLicenseApproved    LicenseApprovalStatusValue = \"approved\"\n\tLicenseBlacklisted LicenseApprovalStatusValue = \"blacklisted\"\n\tLicenseAllowed     LicenseApprovalStatusValue = \"allowed\"\n\tLicenseDenied      LicenseApprovalStatusValue = \"denied\"\n)\n\n// LicenseApprovalStatus is a helper routine that allocates a new license\n// approval status value to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc LicenseApprovalStatus(v LicenseApprovalStatusValue) *LicenseApprovalStatusValue {\n\treturn Ptr(v)\n}\n\n// MergeMethodValue represents a project merge type within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#project-merge-method\ntype MergeMethodValue string\n\n// List of available merge type\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#project-merge-method\nconst (\n\tNoFastForwardMerge MergeMethodValue = \"merge\"\n\tFastForwardMerge   MergeMethodValue = \"ff\"\n\tRebaseMerge        MergeMethodValue = \"rebase_merge\"\n)\n\n// MergeMethod is a helper routine that allocates a new MergeMethod\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc MergeMethod(v MergeMethodValue) *MergeMethodValue {\n\treturn Ptr(v)\n}\n\n// NoteTypeValue represents the type of a Note.\ntype NoteTypeValue string\n\n// List of available note types.\nconst (\n\tDiffNote       NoteTypeValue = \"DiffNote\"\n\tDiscussionNote NoteTypeValue = \"DiscussionNote\"\n\tGenericNote    NoteTypeValue = \"Note\"\n\tLegacyDiffNote NoteTypeValue = \"LegacyDiffNote\"\n)\n\n// NoteType is a helper routine that allocates a new NoteTypeValue to\n// store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc NoteType(v NoteTypeValue) *NoteTypeValue {\n\treturn Ptr(v)\n}\n\n// NotificationLevelValue represents a notification level.\ntype NotificationLevelValue int\n\n// String implements the fmt.Stringer interface.\nfunc (l NotificationLevelValue) String() string {\n\treturn notificationLevelNames[l]\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (l NotificationLevelValue) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(l.String())\n}\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (l *NotificationLevelValue) UnmarshalJSON(data []byte) error {\n\tvar raw interface{}\n\tif err := json.Unmarshal(data, &raw); err != nil {\n\t\treturn err\n\t}\n\n\tswitch raw := raw.(type) {\n\tcase float64:\n\t\t*l = NotificationLevelValue(raw)\n\tcase string:\n\t\t*l = notificationLevelTypes[raw]\n\tcase nil:\n\t\t// No action needed.\n\tdefault:\n\t\treturn fmt.Errorf(\"json: cannot unmarshal %T into Go value of type %T\", raw, *l)\n\t}\n\n\treturn nil\n}\n\n// List of valid notification levels.\nconst (\n\tDisabledNotificationLevel NotificationLevelValue = iota\n\tParticipatingNotificationLevel\n\tWatchNotificationLevel\n\tGlobalNotificationLevel\n\tMentionNotificationLevel\n\tCustomNotificationLevel\n)\n\nvar notificationLevelNames = [...]string{\n\t\"disabled\",\n\t\"participating\",\n\t\"watch\",\n\t\"global\",\n\t\"mention\",\n\t\"custom\",\n}\n\nvar notificationLevelTypes = map[string]NotificationLevelValue{\n\t\"disabled\":      DisabledNotificationLevel,\n\t\"participating\": ParticipatingNotificationLevel,\n\t\"watch\":         WatchNotificationLevel,\n\t\"global\":        GlobalNotificationLevel,\n\t\"mention\":       MentionNotificationLevel,\n\t\"custom\":        CustomNotificationLevel,\n}\n\n// NotificationLevel is a helper routine that allocates a new NotificationLevelValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc NotificationLevel(v NotificationLevelValue) *NotificationLevelValue {\n\treturn Ptr(v)\n}\n\n// ProjectCreationLevelValue represents a project creation level within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\ntype ProjectCreationLevelValue string\n\n// List of available project creation levels.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\nconst (\n\tNoOneProjectCreation      ProjectCreationLevelValue = \"noone\"\n\tMaintainerProjectCreation ProjectCreationLevelValue = \"maintainer\"\n\tDeveloperProjectCreation  ProjectCreationLevelValue = \"developer\"\n)\n\n// ProjectCreationLevel is a helper routine that allocates a new ProjectCreationLevelValue\n// to store v and returns a pointer to it.\n// Please use Ptr instead.\nfunc ProjectCreationLevel(v ProjectCreationLevelValue) *ProjectCreationLevelValue {\n\treturn Ptr(v)\n}\n\n// ProjectHookEvent represents a project hook event.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#hook-events\ntype ProjectHookEvent string\n\n// List of available project hook events.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#hook-events\nconst (\n\tProjectHookEventPush                ProjectHookEvent = \"push_events\"\n\tProjectHookEventTagPush             ProjectHookEvent = \"tag_push_events\"\n\tProjectHookEventIssues              ProjectHookEvent = \"issues_events\"\n\tProjectHookEventConfidentialIssues  ProjectHookEvent = \"confidential_issues_events\"\n\tProjectHookEventNote                ProjectHookEvent = \"note_events\"\n\tProjectHookEventMergeRequests       ProjectHookEvent = \"merge_requests_events\"\n\tProjectHookEventJob                 ProjectHookEvent = \"job_events\"\n\tProjectHookEventPipeline            ProjectHookEvent = \"pipeline_events\"\n\tProjectHookEventWiki                ProjectHookEvent = \"wiki_page_events\"\n\tProjectHookEventReleases            ProjectHookEvent = \"releases_events\"\n\tProjectHookEventEmoji               ProjectHookEvent = \"emoji_events\"\n\tProjectHookEventResourceAccessToken ProjectHookEvent = \"resource_access_token_events\"\n)\n\n// ResourceGroupProcessMode represents a process mode for a resource group\n// within a GitLab project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/ci/resource_groups/index.html#process-modes\ntype ResourceGroupProcessMode string\n\n// List of available resource group process modes.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/ci/resource_groups/index.html#process-modes\nconst (\n\tUnordered   ResourceGroupProcessMode = \"unordered\"\n\tOldestFirst ResourceGroupProcessMode = \"oldest_first\"\n\tNewestFirst ResourceGroupProcessMode = \"newest_first\"\n)\n\n// SharedRunnersSettingValue determines whether shared runners are enabled for a\n// group’s subgroups and projects.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#options-for-shared_runners_setting\ntype SharedRunnersSettingValue string\n\n// List of available shared runner setting levels.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/groups.html#options-for-shared_runners_setting\nconst (\n\tEnabledSharedRunnersSettingValue                  SharedRunnersSettingValue = \"enabled\"\n\tDisabledAndOverridableSharedRunnersSettingValue   SharedRunnersSettingValue = \"disabled_and_overridable\"\n\tDisabledAndUnoverridableSharedRunnersSettingValue SharedRunnersSettingValue = \"disabled_and_unoverridable\"\n\n\t// Deprecated: DisabledWithOverrideSharedRunnersSettingValue is deprecated\n\t// in favor of DisabledAndOverridableSharedRunnersSettingValue.\n\tDisabledWithOverrideSharedRunnersSettingValue SharedRunnersSettingValue = \"disabled_with_override\"\n)\n\n// SharedRunnersSetting is a helper routine that allocates a new SharedRunnersSettingValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc SharedRunnersSetting(v SharedRunnersSettingValue) *SharedRunnersSettingValue {\n\treturn Ptr(v)\n}\n\n// SubGroupCreationLevelValue represents a sub group creation level within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\ntype SubGroupCreationLevelValue string\n\n// List of available sub group creation levels.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\nconst (\n\tOwnerSubGroupCreationLevelValue      SubGroupCreationLevelValue = \"owner\"\n\tMaintainerSubGroupCreationLevelValue SubGroupCreationLevelValue = \"maintainer\"\n)\n\n// SubGroupCreationLevel is a helper routine that allocates a new SubGroupCreationLevelValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc SubGroupCreationLevel(v SubGroupCreationLevelValue) *SubGroupCreationLevelValue {\n\treturn Ptr(v)\n}\n\n// SquashOptionValue represents a squash optional level within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#create-project\ntype SquashOptionValue string\n\n// List of available squash options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html#create-project\nconst (\n\tSquashOptionNever      SquashOptionValue = \"never\"\n\tSquashOptionAlways     SquashOptionValue = \"always\"\n\tSquashOptionDefaultOff SquashOptionValue = \"default_off\"\n\tSquashOptionDefaultOn  SquashOptionValue = \"default_on\"\n)\n\n// SquashOption is a helper routine that allocates a new SquashOptionValue\n// to store s and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc SquashOption(s SquashOptionValue) *SquashOptionValue {\n\treturn Ptr(s)\n}\n\n// TasksCompletionStatus represents tasks of the issue/merge request.\ntype TasksCompletionStatus struct {\n\tCount          int `json:\"count\"`\n\tCompletedCount int `json:\"completed_count\"`\n}\n\n// TodoAction represents the available actions that can be performed on a todo.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html\ntype TodoAction string\n\n// The available todo actions.\nconst (\n\tTodoAssigned          TodoAction = \"assigned\"\n\tTodoMentioned         TodoAction = \"mentioned\"\n\tTodoBuildFailed       TodoAction = \"build_failed\"\n\tTodoMarked            TodoAction = \"marked\"\n\tTodoApprovalRequired  TodoAction = \"approval_required\"\n\tTodoDirectlyAddressed TodoAction = \"directly_addressed\"\n)\n\n// TodoTargetType represents the available target that can be linked to a todo.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/todos.html\ntype TodoTargetType string\n\nconst (\n\tTodoTargetAlertManagement  TodoTargetType = \"AlertManagement::Alert\"\n\tTodoTargetDesignManagement TodoTargetType = \"DesignManagement::Design\"\n\tTodoTargetIssue            TodoTargetType = \"Issue\"\n\tTodoTargetMergeRequest     TodoTargetType = \"MergeRequest\"\n)\n\n// UploadType represents the available upload types.\ntype UploadType string\n\n// The available upload types.\nconst (\n\tUploadAvatar UploadType = \"avatar\"\n\tUploadFile   UploadType = \"file\"\n)\n\n// VariableTypeValue represents a variable type within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\ntype VariableTypeValue string\n\n// List of available variable types.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\nconst (\n\tEnvVariableType  VariableTypeValue = \"env_var\"\n\tFileVariableType VariableTypeValue = \"file\"\n)\n\n// VariableType is a helper routine that allocates a new VariableTypeValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc VariableType(v VariableTypeValue) *VariableTypeValue {\n\treturn Ptr(v)\n}\n\n// VisibilityValue represents a visibility level within GitLab.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\ntype VisibilityValue string\n\n// List of available visibility levels.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/\nconst (\n\tPrivateVisibility  VisibilityValue = \"private\"\n\tInternalVisibility VisibilityValue = \"internal\"\n\tPublicVisibility   VisibilityValue = \"public\"\n)\n\n// Visibility is a helper routine that allocates a new VisibilityValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc Visibility(v VisibilityValue) *VisibilityValue {\n\treturn Ptr(v)\n}\n\n// WikiFormatValue represents the available wiki formats.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/wikis.html\ntype WikiFormatValue string\n\n// The available wiki formats.\nconst (\n\tWikiFormatMarkdown WikiFormatValue = \"markdown\"\n\tWikiFormatRDoc     WikiFormatValue = \"rdoc\"\n\tWikiFormatASCIIDoc WikiFormatValue = \"asciidoc\"\n\tWikiFormatOrg      WikiFormatValue = \"org\"\n)\n\n// WikiFormat is a helper routine that allocates a new WikiFormatValue\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc WikiFormat(v WikiFormatValue) *WikiFormatValue {\n\treturn Ptr(v)\n}\n\n// Bool is a helper routine that allocates a new bool value\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc Bool(v bool) *bool {\n\treturn Ptr(v)\n}\n\n// Int is a helper routine that allocates a new int value\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc Int(v int) *int {\n\treturn Ptr(v)\n}\n\n// String is a helper routine that allocates a new string value\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc String(v string) *string {\n\treturn Ptr(v)\n}\n\n// Time is a helper routine that allocates a new time.Time value\n// to store v and returns a pointer to it.\n//\n// Deprecated: Please use Ptr instead.\nfunc Time(v time.Time) *time.Time {\n\treturn Ptr(v)\n}\n\n// BoolValue is a boolean value with advanced json unmarshaling features.\ntype BoolValue bool\n\n// UnmarshalJSON allows 1, 0, \"true\", and \"false\" to be considered as boolean values\n// Needed for:\n// https://gitlab.com/gitlab-org/gitlab-ce/issues/50122\n// https://gitlab.com/gitlab-org/gitlab/-/issues/233941\n// https://github.com/gitlabhq/terraform-provider-gitlab/issues/348\nfunc (t *BoolValue) UnmarshalJSON(b []byte) error {\n\tswitch string(b) {\n\tcase `\"1\"`:\n\t\t*t = true\n\t\treturn nil\n\tcase `\"0\"`:\n\t\t*t = false\n\t\treturn nil\n\tcase `\"true\"`:\n\t\t*t = true\n\t\treturn nil\n\tcase `\"false\"`:\n\t\t*t = false\n\t\treturn nil\n\tdefault:\n\t\tvar v bool\n\t\terr := json.Unmarshal(b, &v)\n\t\t*t = BoolValue(v)\n\t\treturn err\n\t}\n}\n\n// CIPipelineVariablesMinimumOverrideRoleValue represents an access control\n// value used for managing access to the CI Pipeline Variable Override feature.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html\ntype CIPipelineVariablesMinimumOverrideRoleValue = string\n\n// List of available CIPipelineVariablesMinimumOverrideRoleValue values.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/projects.html\nconst (\n\tCIPipelineVariablesNoOneAllowedRole CIPipelineVariablesMinimumOverrideRoleValue = \"no_one_allowed\"\n\tCiPipelineVariablesOwnerRole        CIPipelineVariablesMinimumOverrideRoleValue = \"owner\"\n\tCiPipelineVariablesMaintainerRole   CIPipelineVariablesMinimumOverrideRoleValue = \"maintainer\"\n\tCIPipelineVariablesDeveloperRole    CIPipelineVariablesMinimumOverrideRoleValue = \"developer\"\n)\n"
        },
        {
          "name": "types_test.go",
          "type": "blob",
          "size": 1.6943359375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc TestBoolValue(t *testing.T) {\n\ttestCases := []struct {\n\t\tname     string\n\t\tdata     []byte\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tname:     \"should unmarshal true as true\",\n\t\t\tdata:     []byte(\"true\"),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"should unmarshal false as false\",\n\t\t\tdata:     []byte(\"false\"),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"should unmarshal true as true\",\n\t\t\tdata:     []byte(`\"true\"`),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"should unmarshal false as false\",\n\t\t\tdata:     []byte(`\"false\"`),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"should unmarshal \\\"1\\\" as true\",\n\t\t\tdata:     []byte(`\"1\"`),\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tname:     \"should unmarshal \\\"0\\\" as false\",\n\t\t\tdata:     []byte(`\"0\"`),\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, testCase := range testCases {\n\t\tt.Run(testCase.name, func(t *testing.T) {\n\t\t\tvar b BoolValue\n\t\t\tif err := json.Unmarshal(testCase.data, &b); err != nil {\n\t\t\t\tt.Fatalf(\"Unexpected error: %v\", err)\n\t\t\t}\n\n\t\t\tif bool(b) != testCase.expected {\n\t\t\t\tt.Fatalf(\"Expected %v but got %v\", testCase.expected, b)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "users.go",
          "type": "blob",
          "size": 52.7626953125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/hashicorp/go-retryablehttp\"\n)\n\n// List a couple of standard errors.\nvar (\n\tErrUserActivatePrevented         = errors.New(\"Cannot activate a user that is blocked by admin or by LDAP synchronization\")\n\tErrUserApprovePrevented          = errors.New(\"Cannot approve a user that is blocked by admin or by LDAP synchronization\")\n\tErrUserBlockPrevented            = errors.New(\"Cannot block a user that is already blocked by LDAP synchronization\")\n\tErrUserConflict                  = errors.New(\"User does not have a pending request\")\n\tErrUserDeactivatePrevented       = errors.New(\"Cannot deactivate a user that is blocked by admin or by LDAP synchronization\")\n\tErrUserDisableTwoFactorPrevented = errors.New(\"Cannot disable two factor authentication if not authenticated as administrator\")\n\tErrUserNotFound                  = errors.New(\"User does not exist\")\n\tErrUserRejectPrevented           = errors.New(\"Cannot reject a user if not authenticated as administrator\")\n\tErrUserTwoFactorNotEnabled       = errors.New(\"Cannot disable two factor authentication if not enabled\")\n\tErrUserUnblockPrevented          = errors.New(\"Cannot unblock a user that is blocked by LDAP synchronization\")\n)\n\n// UsersService handles communication with the user related methods of\n// the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html\ntype UsersService struct {\n\tclient *Client\n}\n\n// BasicUser included in other service responses (such as merge requests, pipelines, etc).\ntype BasicUser struct {\n\tID        int        `json:\"id\"`\n\tUsername  string     `json:\"username\"`\n\tName      string     `json:\"name\"`\n\tState     string     `json:\"state\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tAvatarURL string     `json:\"avatar_url\"`\n\tWebURL    string     `json:\"web_url\"`\n}\n\n// ServiceAccount represents a GitLab service account.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/user_service_accounts.html\ntype ServiceAccount struct {\n\tID       int    `json:\"id\"`\n\tUsername string `json:\"username\"`\n\tName     string `json:\"name\"`\n}\n\n// User represents a GitLab user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html\ntype User struct {\n\tID                             int                `json:\"id\"`\n\tUsername                       string             `json:\"username\"`\n\tEmail                          string             `json:\"email\"`\n\tName                           string             `json:\"name\"`\n\tState                          string             `json:\"state\"`\n\tWebURL                         string             `json:\"web_url\"`\n\tCreatedAt                      *time.Time         `json:\"created_at\"`\n\tBio                            string             `json:\"bio\"`\n\tBot                            bool               `json:\"bot\"`\n\tLocation                       string             `json:\"location\"`\n\tPublicEmail                    string             `json:\"public_email\"`\n\tSkype                          string             `json:\"skype\"`\n\tLinkedin                       string             `json:\"linkedin\"`\n\tTwitter                        string             `json:\"twitter\"`\n\tWebsiteURL                     string             `json:\"website_url\"`\n\tOrganization                   string             `json:\"organization\"`\n\tJobTitle                       string             `json:\"job_title\"`\n\tExternUID                      string             `json:\"extern_uid\"`\n\tProvider                       string             `json:\"provider\"`\n\tThemeID                        int                `json:\"theme_id\"`\n\tLastActivityOn                 *ISOTime           `json:\"last_activity_on\"`\n\tColorSchemeID                  int                `json:\"color_scheme_id\"`\n\tIsAdmin                        bool               `json:\"is_admin\"`\n\tIsAuditor                      bool               `json:\"is_auditor\"`\n\tAvatarURL                      string             `json:\"avatar_url\"`\n\tCanCreateGroup                 bool               `json:\"can_create_group\"`\n\tCanCreateProject               bool               `json:\"can_create_project\"`\n\tProjectsLimit                  int                `json:\"projects_limit\"`\n\tCurrentSignInAt                *time.Time         `json:\"current_sign_in_at\"`\n\tCurrentSignInIP                *net.IP            `json:\"current_sign_in_ip\"`\n\tLastSignInAt                   *time.Time         `json:\"last_sign_in_at\"`\n\tLastSignInIP                   *net.IP            `json:\"last_sign_in_ip\"`\n\tConfirmedAt                    *time.Time         `json:\"confirmed_at\"`\n\tTwoFactorEnabled               bool               `json:\"two_factor_enabled\"`\n\tNote                           string             `json:\"note\"`\n\tIdentities                     []*UserIdentity    `json:\"identities\"`\n\tExternal                       bool               `json:\"external\"`\n\tPrivateProfile                 bool               `json:\"private_profile\"`\n\tSharedRunnersMinutesLimit      int                `json:\"shared_runners_minutes_limit\"`\n\tExtraSharedRunnersMinutesLimit int                `json:\"extra_shared_runners_minutes_limit\"`\n\tUsingLicenseSeat               bool               `json:\"using_license_seat\"`\n\tCustomAttributes               []*CustomAttribute `json:\"custom_attributes\"`\n\tNamespaceID                    int                `json:\"namespace_id\"`\n\tLocked                         bool               `json:\"locked\"`\n}\n\n// UserIdentity represents a user identity.\ntype UserIdentity struct {\n\tProvider  string `json:\"provider\"`\n\tExternUID string `json:\"extern_uid\"`\n}\n\n// UserAvatar represents a GitLab user avatar.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html\ntype UserAvatar struct {\n\tFilename string\n\tImage    io.Reader\n}\n\n// MarshalJSON implements the json.Marshaler interface.\nfunc (a *UserAvatar) MarshalJSON() ([]byte, error) {\n\tif a.Filename == \"\" && a.Image == nil {\n\t\treturn []byte(`\"\"`), nil\n\t}\n\ttype alias UserAvatar\n\treturn json.Marshal((*alias)(a))\n}\n\n// ListUsersOptions represents the available ListUsers() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-users\ntype ListUsersOptions struct {\n\tListOptions\n\tActive          *bool `url:\"active,omitempty\" json:\"active,omitempty\"`\n\tBlocked         *bool `url:\"blocked,omitempty\" json:\"blocked,omitempty\"`\n\tExcludeInternal *bool `url:\"exclude_internal,omitempty\" json:\"exclude_internal,omitempty\"`\n\tExcludeExternal *bool `url:\"exclude_external,omitempty\" json:\"exclude_external,omitempty\"`\n\n\t// The options below are only available for admins.\n\tSearch               *string    `url:\"search,omitempty\" json:\"search,omitempty\"`\n\tUsername             *string    `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tExternalUID          *string    `url:\"extern_uid,omitempty\" json:\"extern_uid,omitempty\"`\n\tProvider             *string    `url:\"provider,omitempty\" json:\"provider,omitempty\"`\n\tCreatedBefore        *time.Time `url:\"created_before,omitempty\" json:\"created_before,omitempty\"`\n\tCreatedAfter         *time.Time `url:\"created_after,omitempty\" json:\"created_after,omitempty\"`\n\tOrderBy              *string    `url:\"order_by,omitempty\" json:\"order_by,omitempty\"`\n\tSort                 *string    `url:\"sort,omitempty\" json:\"sort,omitempty\"`\n\tTwoFactor            *string    `url:\"two_factor,omitempty\" json:\"two_factor,omitempty\"`\n\tAdmins               *bool      `url:\"admins,omitempty\" json:\"admins,omitempty\"`\n\tExternal             *bool      `url:\"external,omitempty\" json:\"external,omitempty\"`\n\tWithoutProjects      *bool      `url:\"without_projects,omitempty\" json:\"without_projects,omitempty\"`\n\tWithCustomAttributes *bool      `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n\tWithoutProjectBots   *bool      `url:\"without_project_bots,omitempty\" json:\"without_project_bots,omitempty\"`\n}\n\n// ListUsers gets a list of users.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-users\nfunc (s *UsersService) ListUsers(opt *ListUsersOptions, options ...RequestOptionFunc) ([]*User, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"users\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar usr []*User\n\tresp, err := s.client.Do(req, &usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n\n// GetUsersOptions represents the available GetUser() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#single-user\ntype GetUsersOptions struct {\n\tWithCustomAttributes *bool `url:\"with_custom_attributes,omitempty\" json:\"with_custom_attributes,omitempty\"`\n}\n\n// GetUser gets a single user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#single-user\nfunc (s *UsersService) GetUser(user int, opt GetUsersOptions, options ...RequestOptionFunc) (*User, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tusr := new(User)\n\tresp, err := s.client.Do(req, usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n\n// CreateUserOptions represents the available CreateUser() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#user-creation\ntype CreateUserOptions struct {\n\tAdmin               *bool       `url:\"admin,omitempty\" json:\"admin,omitempty\"`\n\tAvatar              *UserAvatar `url:\"-\" json:\"-\"`\n\tBio                 *string     `url:\"bio,omitempty\" json:\"bio,omitempty\"`\n\tCanCreateGroup      *bool       `url:\"can_create_group,omitempty\" json:\"can_create_group,omitempty\"`\n\tEmail               *string     `url:\"email,omitempty\" json:\"email,omitempty\"`\n\tExternal            *bool       `url:\"external,omitempty\" json:\"external,omitempty\"`\n\tExternUID           *string     `url:\"extern_uid,omitempty\" json:\"extern_uid,omitempty\"`\n\tForceRandomPassword *bool       `url:\"force_random_password,omitempty\" json:\"force_random_password,omitempty\"`\n\tJobTitle            *string     `url:\"job_title,omitempty\" json:\"job_title,omitempty\"`\n\tLinkedin            *string     `url:\"linkedin,omitempty\" json:\"linkedin,omitempty\"`\n\tLocation            *string     `url:\"location,omitempty\" json:\"location,omitempty\"`\n\tName                *string     `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tNote                *string     `url:\"note,omitempty\" json:\"note,omitempty\"`\n\tOrganization        *string     `url:\"organization,omitempty\" json:\"organization,omitempty\"`\n\tPassword            *string     `url:\"password,omitempty\" json:\"password,omitempty\"`\n\tPrivateProfile      *bool       `url:\"private_profile,omitempty\" json:\"private_profile,omitempty\"`\n\tProjectsLimit       *int        `url:\"projects_limit,omitempty\" json:\"projects_limit,omitempty\"`\n\tProvider            *string     `url:\"provider,omitempty\" json:\"provider,omitempty\"`\n\tResetPassword       *bool       `url:\"reset_password,omitempty\" json:\"reset_password,omitempty\"`\n\tSkipConfirmation    *bool       `url:\"skip_confirmation,omitempty\" json:\"skip_confirmation,omitempty\"`\n\tSkype               *string     `url:\"skype,omitempty\" json:\"skype,omitempty\"`\n\tThemeID             *int        `url:\"theme_id,omitempty\" json:\"theme_id,omitempty\"`\n\tTwitter             *string     `url:\"twitter,omitempty\" json:\"twitter,omitempty\"`\n\tUsername            *string     `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tWebsiteURL          *string     `url:\"website_url,omitempty\" json:\"website_url,omitempty\"`\n}\n\n// CreateUser creates a new user. Note only administrators can create new users.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#user-creation\nfunc (s *UsersService) CreateUser(opt *CreateUserOptions, options ...RequestOptionFunc) (*User, *Response, error) {\n\tvar err error\n\tvar req *retryablehttp.Request\n\n\tif opt.Avatar == nil {\n\t\treq, err = s.client.NewRequest(http.MethodPost, \"users\", opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPost,\n\t\t\t\"users\",\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tusr := new(User)\n\tresp, err := s.client.Do(req, usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n\n// ModifyUserOptions represents the available ModifyUser() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#user-modification\ntype ModifyUserOptions struct {\n\tAdmin              *bool       `url:\"admin,omitempty\" json:\"admin,omitempty\"`\n\tAvatar             *UserAvatar `url:\"-\" json:\"avatar,omitempty\"`\n\tBio                *string     `url:\"bio,omitempty\" json:\"bio,omitempty\"`\n\tCanCreateGroup     *bool       `url:\"can_create_group,omitempty\" json:\"can_create_group,omitempty\"`\n\tCommitEmail        *string     `url:\"commit_email,omitempty\" json:\"commit_email,omitempty\"`\n\tEmail              *string     `url:\"email,omitempty\" json:\"email,omitempty\"`\n\tExternal           *bool       `url:\"external,omitempty\" json:\"external,omitempty\"`\n\tExternUID          *string     `url:\"extern_uid,omitempty\" json:\"extern_uid,omitempty\"`\n\tJobTitle           *string     `url:\"job_title,omitempty\" json:\"job_title,omitempty\"`\n\tLinkedin           *string     `url:\"linkedin,omitempty\" json:\"linkedin,omitempty\"`\n\tLocation           *string     `url:\"location,omitempty\" json:\"location,omitempty\"`\n\tName               *string     `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tNote               *string     `url:\"note,omitempty\" json:\"note,omitempty\"`\n\tOrganization       *string     `url:\"organization,omitempty\" json:\"organization,omitempty\"`\n\tPassword           *string     `url:\"password,omitempty\" json:\"password,omitempty\"`\n\tPrivateProfile     *bool       `url:\"private_profile,omitempty\" json:\"private_profile,omitempty\"`\n\tProjectsLimit      *int        `url:\"projects_limit,omitempty\" json:\"projects_limit,omitempty\"`\n\tProvider           *string     `url:\"provider,omitempty\" json:\"provider,omitempty\"`\n\tPublicEmail        *string     `url:\"public_email,omitempty\" json:\"public_email,omitempty\"`\n\tSkipReconfirmation *bool       `url:\"skip_reconfirmation,omitempty\" json:\"skip_reconfirmation,omitempty\"`\n\tSkype              *string     `url:\"skype,omitempty\" json:\"skype,omitempty\"`\n\tThemeID            *int        `url:\"theme_id,omitempty\" json:\"theme_id,omitempty\"`\n\tTwitter            *string     `url:\"twitter,omitempty\" json:\"twitter,omitempty\"`\n\tUsername           *string     `url:\"username,omitempty\" json:\"username,omitempty\"`\n\tWebsiteURL         *string     `url:\"website_url,omitempty\" json:\"website_url,omitempty\"`\n}\n\n// ModifyUser modifies an existing user. Only administrators can change attributes\n// of a user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#user-modification\nfunc (s *UsersService) ModifyUser(user int, opt *ModifyUserOptions, options ...RequestOptionFunc) (*User, *Response, error) {\n\tvar err error\n\tvar req *retryablehttp.Request\n\tu := fmt.Sprintf(\"users/%d\", user)\n\n\tif opt.Avatar == nil || (opt.Avatar.Filename == \"\" && opt.Avatar.Image == nil) {\n\t\treq, err = s.client.NewRequest(http.MethodPut, u, opt, options)\n\t} else {\n\t\treq, err = s.client.UploadRequest(\n\t\t\thttp.MethodPut,\n\t\t\tu,\n\t\t\topt.Avatar.Image,\n\t\t\topt.Avatar.Filename,\n\t\t\tUploadAvatar,\n\t\t\topt,\n\t\t\toptions,\n\t\t)\n\t}\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tusr := new(User)\n\tresp, err := s.client.Do(req, usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n\n// DeleteUser deletes a user. Available only for administrators. This is an\n// idempotent function, calling this function for a non-existent user id still\n// returns a status code 200 OK. The JSON response differs if the user was\n// actually deleted or not. In the former the user is returned and in the\n// latter not.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#user-deletion\nfunc (s *UsersService) DeleteUser(user int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"users/%d\", user)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// CurrentUser gets currently authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-current-user\nfunc (s *UsersService) CurrentUser(options ...RequestOptionFunc) (*User, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"user\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tusr := new(User)\n\tresp, err := s.client.Do(req, usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n\n// UserStatus represents the current status of a user\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#user-status\ntype UserStatus struct {\n\tEmoji        string            `json:\"emoji\"`\n\tAvailability AvailabilityValue `json:\"availability\"`\n\tMessage      string            `json:\"message\"`\n\tMessageHTML  string            `json:\"message_html\"`\n}\n\n// CurrentUserStatus retrieves the user status\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#user-status\nfunc (s *UsersService) CurrentUserStatus(options ...RequestOptionFunc) (*UserStatus, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"user/status\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tstatus := new(UserStatus)\n\tresp, err := s.client.Do(req, status)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn status, resp, nil\n}\n\n// GetUserStatus retrieves a user's status\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-the-status-of-a-user\nfunc (s *UsersService) GetUserStatus(user int, options ...RequestOptionFunc) (*UserStatus, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/status\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tstatus := new(UserStatus)\n\tresp, err := s.client.Do(req, status)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn status, resp, nil\n}\n\n// UserStatusOptions represents the options required to set the status\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#set-user-status\ntype UserStatusOptions struct {\n\tEmoji        *string            `url:\"emoji,omitempty\" json:\"emoji,omitempty\"`\n\tAvailability *AvailabilityValue `url:\"availability,omitempty\" json:\"availability,omitempty\"`\n\tMessage      *string            `url:\"message,omitempty\" json:\"message,omitempty\"`\n}\n\n// SetUserStatus sets the user's status\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#set-user-status\nfunc (s *UsersService) SetUserStatus(opt *UserStatusOptions, options ...RequestOptionFunc) (*UserStatus, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPut, \"user/status\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tstatus := new(UserStatus)\n\tresp, err := s.client.Do(req, status)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn status, resp, nil\n}\n\n// UserAssociationsCount represents the user associations count.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/users.html#list-associations-count-for-user\ntype UserAssociationsCount struct {\n\tGroupsCount        int `json:\"groups_count\"`\n\tProjectsCount      int `json:\"projects_count\"`\n\tIssuesCount        int `json:\"issues_count\"`\n\tMergeRequestsCount int `json:\"merge_requests_count\"`\n}\n\n// GetUserAssociationsCount gets a list of a specified user associations.\n//\n// Gitlab API docs: https://docs.gitlab.com/ee/api/users.html#list-associations-count-for-user\nfunc (s *UsersService) GetUserAssociationsCount(user int, options ...RequestOptionFunc) (*UserAssociationsCount, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/associations_count\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tuac := new(UserAssociationsCount)\n\tresp, err := s.client.Do(req, uac)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn uac, resp, nil\n}\n\n// SSHKey represents a SSH key.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-ssh-keys\ntype SSHKey struct {\n\tID        int        `json:\"id\"`\n\tTitle     string     `json:\"title\"`\n\tKey       string     `json:\"key\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n\tExpiresAt *time.Time `json:\"expires_at\"`\n}\n\n// ListSSHKeysOptions represents the available ListSSHKeys options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-ssh-keys\ntype ListSSHKeysOptions ListOptions\n\n// ListSSHKeys gets a list of currently authenticated user's SSH keys.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-ssh-keys\nfunc (s *UsersService) ListSSHKeys(opt *ListSSHKeysOptions, options ...RequestOptionFunc) ([]*SSHKey, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"user/keys\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar k []*SSHKey\n\tresp, err := s.client.Do(req, &k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// ListSSHKeysForUserOptions represents the available ListSSHKeysForUser() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user\ntype ListSSHKeysForUserOptions ListOptions\n\n// ListSSHKeysForUser gets a list of a specified user's SSH keys.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#list-ssh-keys-for-user\nfunc (s *UsersService) ListSSHKeysForUser(uid interface{}, opt *ListSSHKeysForUserOptions, options ...RequestOptionFunc) ([]*SSHKey, *Response, error) {\n\tuser, err := parseID(uid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"users/%s/keys\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar k []*SSHKey\n\tresp, err := s.client.Do(req, &k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// GetSSHKey gets a single key.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#single-ssh-key\nfunc (s *UsersService) GetSSHKey(key int, options ...RequestOptionFunc) (*SSHKey, *Response, error) {\n\tu := fmt.Sprintf(\"user/keys/%d\", key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(SSHKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// GetSSHKeyForUser gets a single key for a given user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#single-ssh-key-for-given-user\nfunc (s *UsersService) GetSSHKeyForUser(user int, key int, options ...RequestOptionFunc) (*SSHKey, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/keys/%d\", user, key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(SSHKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// AddSSHKeyOptions represents the available AddSSHKey() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-ssh-key\ntype AddSSHKeyOptions struct {\n\tTitle     *string  `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tKey       *string  `url:\"key,omitempty\" json:\"key,omitempty\"`\n\tExpiresAt *ISOTime `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// AddSSHKey creates a new key owned by the currently authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-ssh-key\nfunc (s *UsersService) AddSSHKey(opt *AddSSHKeyOptions, options ...RequestOptionFunc) (*SSHKey, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"user/keys\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(SSHKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// AddSSHKeyForUser creates new key owned by specified user. Available only for\n// admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-ssh-key-for-user\nfunc (s *UsersService) AddSSHKeyForUser(user int, opt *AddSSHKeyOptions, options ...RequestOptionFunc) (*SSHKey, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/keys\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(SSHKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// DeleteSSHKey deletes key owned by currently authenticated user. This is an\n// idempotent function and calling it on a key that is already deleted or not\n// available results in 200 OK.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-current-user\nfunc (s *UsersService) DeleteSSHKey(key int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"user/keys/%d\", key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteSSHKeyForUser deletes key owned by a specified user. Available only\n// for admin.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#delete-ssh-key-for-given-user\nfunc (s *UsersService) DeleteSSHKeyForUser(user, key int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"users/%d/keys/%d\", user, key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// GPGKey represents a GPG key.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-all-gpg-keys\ntype GPGKey struct {\n\tID        int        `json:\"id\"`\n\tKey       string     `json:\"key\"`\n\tCreatedAt *time.Time `json:\"created_at\"`\n}\n\n// ListGPGKeys gets a list of currently authenticated user’s GPG keys.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-all-gpg-keys\nfunc (s *UsersService) ListGPGKeys(options ...RequestOptionFunc) ([]*GPGKey, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"user/gpg_keys\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ks []*GPGKey\n\tresp, err := s.client.Do(req, &ks)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ks, resp, nil\n}\n\n// GetGPGKey gets a specific GPG key of currently authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#get-a-specific-gpg-key\nfunc (s *UsersService) GetGPGKey(key int, options ...RequestOptionFunc) (*GPGKey, *Response, error) {\n\tu := fmt.Sprintf(\"user/gpg_keys/%d\", key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(GPGKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// AddGPGKeyOptions represents the available AddGPGKey() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-a-gpg-key\ntype AddGPGKeyOptions struct {\n\tKey *string `url:\"key,omitempty\" json:\"key,omitempty\"`\n}\n\n// AddGPGKey creates a new GPG key owned by the currently authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-a-gpg-key\nfunc (s *UsersService) AddGPGKey(opt *AddGPGKeyOptions, options ...RequestOptionFunc) (*GPGKey, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"user/gpg_keys\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(GPGKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// DeleteGPGKey deletes a GPG key owned by currently authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#delete-a-gpg-key\nfunc (s *UsersService) DeleteGPGKey(key int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"user/gpg_keys/%d\", key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// ListGPGKeysForUser gets a list of a specified user’s GPG keys.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#list-all-gpg-keys-for-given-user\nfunc (s *UsersService) ListGPGKeysForUser(user int, options ...RequestOptionFunc) ([]*GPGKey, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/gpg_keys\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ks []*GPGKey\n\tresp, err := s.client.Do(req, &ks)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ks, resp, nil\n}\n\n// GetGPGKeyForUser gets a specific GPG key for a given user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#get-a-specific-gpg-key-for-a-given-user\nfunc (s *UsersService) GetGPGKeyForUser(user, key int, options ...RequestOptionFunc) (*GPGKey, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/gpg_keys/%d\", user, key)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(GPGKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// AddGPGKeyForUser creates new GPG key owned by the specified user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#add-a-gpg-key-for-a-given-user\nfunc (s *UsersService) AddGPGKeyForUser(user int, opt *AddGPGKeyOptions, options ...RequestOptionFunc) (*GPGKey, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/gpg_keys\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tk := new(GPGKey)\n\tresp, err := s.client.Do(req, k)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn k, resp, nil\n}\n\n// DeleteGPGKeyForUser deletes a GPG key owned by a specified user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#delete-a-gpg-key-for-a-given-user\nfunc (s *UsersService) DeleteGPGKeyForUser(user, key int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"users/%d/gpg_keys/%d\", user, key)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// Email represents an Email.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-emails\ntype Email struct {\n\tID          int        `json:\"id\"`\n\tEmail       string     `json:\"email\"`\n\tConfirmedAt *time.Time `json:\"confirmed_at\"`\n}\n\n// ListEmails gets a list of currently authenticated user's Emails.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#list-emails\nfunc (s *UsersService) ListEmails(options ...RequestOptionFunc) ([]*Email, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"user/emails\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar e []*Email\n\tresp, err := s.client.Do(req, &e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// ListEmailsForUserOptions represents the available ListEmailsForUser() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#list-emails-for-user\ntype ListEmailsForUserOptions ListOptions\n\n// ListEmailsForUser gets a list of a specified user's Emails. Available\n// only for admin\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#list-emails-for-user\nfunc (s *UsersService) ListEmailsForUser(user int, opt *ListEmailsForUserOptions, options ...RequestOptionFunc) ([]*Email, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/emails\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar e []*Email\n\tresp, err := s.client.Do(req, &e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// GetEmail gets a single email.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#single-email\nfunc (s *UsersService) GetEmail(email int, options ...RequestOptionFunc) (*Email, *Response, error) {\n\tu := fmt.Sprintf(\"user/emails/%d\", email)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\te := new(Email)\n\tresp, err := s.client.Do(req, e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// AddEmailOptions represents the available AddEmail() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-email\ntype AddEmailOptions struct {\n\tEmail            *string `url:\"email,omitempty\" json:\"email,omitempty\"`\n\tSkipConfirmation *bool   `url:\"skip_confirmation,omitempty\" json:\"skip_confirmation,omitempty\"`\n}\n\n// AddEmail creates a new email owned by the currently authenticated user.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-email\nfunc (s *UsersService) AddEmail(opt *AddEmailOptions, options ...RequestOptionFunc) (*Email, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"user/emails\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\te := new(Email)\n\tresp, err := s.client.Do(req, e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// AddEmailForUser creates new email owned by specified user. Available only for\n// admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#add-email-for-user\nfunc (s *UsersService) AddEmailForUser(user int, opt *AddEmailOptions, options ...RequestOptionFunc) (*Email, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/emails\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\te := new(Email)\n\tresp, err := s.client.Do(req, e)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn e, resp, nil\n}\n\n// DeleteEmail deletes email owned by currently authenticated user. This is an\n// idempotent function and calling it on a key that is already deleted or not\n// available results in 200 OK.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#delete-email-for-current-user\nfunc (s *UsersService) DeleteEmail(email int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"user/emails/%d\", email)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// DeleteEmailForUser deletes email owned by a specified user. Available only\n// for admin.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#delete-email-for-given-user\nfunc (s *UsersService) DeleteEmailForUser(user, email int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"users/%d/emails/%d\", user, email)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// BlockUser blocks the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#block-user\nfunc (s *UsersService) BlockUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/block\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 403:\n\t\treturn ErrUserBlockPrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// UnblockUser unblocks the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#unblock-user\nfunc (s *UsersService) UnblockUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/unblock\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 403:\n\t\treturn ErrUserUnblockPrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// BanUser bans the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#ban-user\nfunc (s *UsersService) BanUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/ban\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// UnbanUser unbans the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#unban-user\nfunc (s *UsersService) UnbanUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/unban\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// DeactivateUser deactivate the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#deactivate-user\nfunc (s *UsersService) DeactivateUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/deactivate\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 403:\n\t\treturn ErrUserDeactivatePrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// ActivateUser activate the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#activate-user\nfunc (s *UsersService) ActivateUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/activate\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 403:\n\t\treturn ErrUserActivatePrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// ApproveUser approve the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#approve-user\nfunc (s *UsersService) ApproveUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/approve\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 201:\n\t\treturn nil\n\tcase 403:\n\t\treturn ErrUserApprovePrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// RejectUser reject the specified user. Available only for admin.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/users.html#reject-user\nfunc (s *UsersService) RejectUser(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/reject\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 200:\n\t\treturn nil\n\tcase 403:\n\t\treturn ErrUserRejectPrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tcase 409:\n\t\treturn ErrUserConflict\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// ImpersonationToken represents an impersonation token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-all-impersonation-tokens-of-a-user\ntype ImpersonationToken struct {\n\tID         int        `json:\"id\"`\n\tName       string     `json:\"name\"`\n\tActive     bool       `json:\"active\"`\n\tToken      string     `json:\"token\"`\n\tScopes     []string   `json:\"scopes\"`\n\tRevoked    bool       `json:\"revoked\"`\n\tCreatedAt  *time.Time `json:\"created_at\"`\n\tExpiresAt  *ISOTime   `json:\"expires_at\"`\n\tLastUsedAt *time.Time `json:\"last_used_at\"`\n}\n\n// GetAllImpersonationTokensOptions represents the available\n// GetAllImpersonationTokens() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-all-impersonation-tokens-of-a-user\ntype GetAllImpersonationTokensOptions struct {\n\tListOptions\n\tState *string `url:\"state,omitempty\" json:\"state,omitempty\"`\n}\n\n// GetAllImpersonationTokens retrieves all impersonation tokens of a user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-all-impersonation-tokens-of-a-user\nfunc (s *UsersService) GetAllImpersonationTokens(user int, opt *GetAllImpersonationTokensOptions, options ...RequestOptionFunc) ([]*ImpersonationToken, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/impersonation_tokens\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ts []*ImpersonationToken\n\tresp, err := s.client.Do(req, &ts)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ts, resp, nil\n}\n\n// GetImpersonationToken retrieves an impersonation token of a user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-an-impersonation-token-of-a-user\nfunc (s *UsersService) GetImpersonationToken(user, token int, options ...RequestOptionFunc) (*ImpersonationToken, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/impersonation_tokens/%d\", user, token)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(ImpersonationToken)\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// CreateImpersonationTokenOptions represents the available\n// CreateImpersonationToken() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token\ntype CreateImpersonationTokenOptions struct {\n\tName      *string    `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tScopes    *[]string  `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n\tExpiresAt *time.Time `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// CreateImpersonationToken creates an impersonation token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-an-impersonation-token\nfunc (s *UsersService) CreateImpersonationToken(user int, opt *CreateImpersonationTokenOptions, options ...RequestOptionFunc) (*ImpersonationToken, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/impersonation_tokens\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(ImpersonationToken)\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// RevokeImpersonationToken revokes an impersonation token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#revoke-an-impersonation-token\nfunc (s *UsersService) RevokeImpersonationToken(user, token int, options ...RequestOptionFunc) (*Response, error) {\n\tu := fmt.Sprintf(\"users/%d/impersonation_tokens/%d\", user, token)\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n\n// CreatePersonalAccessTokenOptions represents the available\n// CreatePersonalAccessToken() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-personal-access-token\ntype CreatePersonalAccessTokenOptions struct {\n\tName      *string   `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tExpiresAt *ISOTime  `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n\tScopes    *[]string `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n}\n\n// CreatePersonalAccessToken creates a personal access token.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-personal-access-token\nfunc (s *UsersService) CreatePersonalAccessToken(user int, opt *CreatePersonalAccessTokenOptions, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/personal_access_tokens\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// CreatePersonalAccessTokenForCurrentUserOptions represents the available\n// CreatePersonalAccessTokenForCurrentUser() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-personal-access-token-with-limited-scopes-for-the-currently-authenticated-user\ntype CreatePersonalAccessTokenForCurrentUserOptions struct {\n\tName      *string   `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tScopes    *[]string `url:\"scopes,omitempty\" json:\"scopes,omitempty\"`\n\tExpiresAt *ISOTime  `url:\"expires_at,omitempty\" json:\"expires_at,omitempty\"`\n}\n\n// CreatePersonalAccessTokenForCurrentUser creates a personal access token with limited scopes for the currently authenticated user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-personal-access-token-with-limited-scopes-for-the-currently-authenticated-user\nfunc (s *UsersService) CreatePersonalAccessTokenForCurrentUser(opt *CreatePersonalAccessTokenForCurrentUserOptions, options ...RequestOptionFunc) (*PersonalAccessToken, *Response, error) {\n\tu := \"user/personal_access_tokens\"\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tt := new(PersonalAccessToken)\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// UserActivity represents an entry in the user/activities response\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-user-activities\ntype UserActivity struct {\n\tUsername       string   `json:\"username\"`\n\tLastActivityOn *ISOTime `json:\"last_activity_on\"`\n}\n\n// GetUserActivitiesOptions represents the options for GetUserActivities\n//\n// GitLap API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-user-activities\ntype GetUserActivitiesOptions struct {\n\tListOptions\n\tFrom *ISOTime `url:\"from,omitempty\" json:\"from,omitempty\"`\n}\n\n// GetUserActivities retrieves user activities (admin only)\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#get-user-activities\nfunc (s *UsersService) GetUserActivities(opt *GetUserActivitiesOptions, options ...RequestOptionFunc) ([]*UserActivity, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"user/activities\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar t []*UserActivity\n\tresp, err := s.client.Do(req, &t)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn t, resp, nil\n}\n\n// UserMembership represents a membership of the user in a namespace or project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#user-memberships\ntype UserMembership struct {\n\tSourceID    int              `json:\"source_id\"`\n\tSourceName  string           `json:\"source_name\"`\n\tSourceType  string           `json:\"source_type\"`\n\tAccessLevel AccessLevelValue `json:\"access_level\"`\n}\n\n// GetUserMembershipOptions represents the options available to query user memberships.\n//\n// GitLab API docs:\n// ohttps://docs.gitlab.com/ee/api/users.html#user-memberships\ntype GetUserMembershipOptions struct {\n\tListOptions\n\tType *string `url:\"type,omitempty\" json:\"type,omitempty\"`\n}\n\n// GetUserMemberships retrieves a list of the user's memberships.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#user-memberships\nfunc (s *UsersService) GetUserMemberships(user int, opt *GetUserMembershipOptions, options ...RequestOptionFunc) ([]*UserMembership, *Response, error) {\n\tu := fmt.Sprintf(\"users/%d/memberships\", user)\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar m []*UserMembership\n\tresp, err := s.client.Do(req, &m)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn m, resp, nil\n}\n\n// DisableTwoFactor disables two factor authentication for the specified user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#disable-two-factor-authentication\nfunc (s *UsersService) DisableTwoFactor(user int, options ...RequestOptionFunc) error {\n\tu := fmt.Sprintf(\"users/%d/disable_two_factor\", user)\n\n\treq, err := s.client.NewRequest(http.MethodPatch, u, nil, options)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresp, err := s.client.Do(req, nil)\n\tif err != nil && resp == nil {\n\t\treturn err\n\t}\n\n\tswitch resp.StatusCode {\n\tcase 204:\n\t\treturn nil\n\tcase 400:\n\t\treturn ErrUserTwoFactorNotEnabled\n\tcase 403:\n\t\treturn ErrUserDisableTwoFactorPrevented\n\tcase 404:\n\t\treturn ErrUserNotFound\n\tdefault:\n\t\treturn fmt.Errorf(\"Received unexpected result code: %d\", resp.StatusCode)\n\t}\n}\n\n// UserRunner represents a GitLab runner linked to the current user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-runner\ntype UserRunner struct {\n\tID             int        `json:\"id\"`\n\tToken          string     `json:\"token\"`\n\tTokenExpiresAt *time.Time `json:\"token_expires_at\"`\n}\n\n// CreateUserRunnerOptions represents the available CreateUserRunner() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-runner\ntype CreateUserRunnerOptions struct {\n\tRunnerType      *string   `url:\"runner_type,omitempty\" json:\"runner_type,omitempty\"`\n\tGroupID         *int      `url:\"group_id,omitempty\" json:\"group_id,omitempty\"`\n\tProjectID       *int      `url:\"project_id,omitempty\" json:\"project_id,omitempty\"`\n\tDescription     *string   `url:\"description,omitempty\" json:\"description,omitempty\"`\n\tPaused          *bool     `url:\"paused,omitempty\" json:\"paused,omitempty\"`\n\tLocked          *bool     `url:\"locked,omitempty\" json:\"locked,omitempty\"`\n\tRunUntagged     *bool     `url:\"run_untagged,omitempty\" json:\"run_untagged,omitempty\"`\n\tTagList         *[]string `url:\"tag_list,omitempty\" json:\"tag_list,omitempty\"`\n\tAccessLevel     *string   `url:\"access_level,omitempty\" json:\"access_level,omitempty\"`\n\tMaximumTimeout  *int      `url:\"maximum_timeout,omitempty\" json:\"maximum_timeout,omitempty\"`\n\tMaintenanceNote *string   `url:\"maintenance_note,omitempty\" json:\"maintenance_note,omitempty\"`\n}\n\n// CreateUserRunner creates a runner linked to the current user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-a-runner\nfunc (s *UsersService) CreateUserRunner(opts *CreateUserRunnerOptions, options ...RequestOptionFunc) (*UserRunner, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"user/runners\", opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tr := new(UserRunner)\n\tresp, err := s.client.Do(req, r)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn r, resp, nil\n}\n\n\n// CreateServiceAccountUserOptions represents the available CreateServiceAccountUser() options.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/user_service_accounts.html#create-a-service-account-user\ntype CreateServiceAccountUserOptions struct {\n\tName     *string `url:\"name,omitempty\" json:\"name,omitempty\"`\n\tUsername *string `url:\"username,omitempty\" json:\"username,omitempty\"`\n}\n\n// CreateServiceAccountUser creates a new service account user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-service-account-user\nfunc (s *UsersService) CreateServiceAccountUser(opts *CreateServiceAccountUserOptions, options ...RequestOptionFunc) (*User, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"service_accounts\", opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tusr := new(User)\n\tresp, err := s.client.Do(req, usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n\n// ListServiceAccounts lists all service accounts.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#create-service-account-user\nfunc (s *UsersService) ListServiceAccounts(opt *ListServiceAccountsOptions, options ...RequestOptionFunc) ([]*ServiceAccount, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"service_accounts\", opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar sas []*ServiceAccount\n\tresp, err := s.client.Do(req, &sas)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn sas, resp, nil\n}\n\n// UploadAvatar uploads an avatar to the current user.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/users.html#upload-a-current-user-avatar\nfunc (s *UsersService) UploadAvatar(avatar io.Reader, filename string, options ...RequestOptionFunc) (*User, *Response, error) {\n\tu := \"user/avatar\"\n\n\treq, err := s.client.UploadRequest(\n\t\thttp.MethodPut,\n\t\tu,\n\t\tavatar,\n\t\tfilename,\n\t\tUploadAvatar,\n\t\tnil,\n\t\toptions,\n\t)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tusr := new(User)\n\tresp, err := s.client.Do(req, usr)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn usr, resp, nil\n}\n"
        },
        {
          "name": "users_test.go",
          "type": "blob",
          "size": 26.5048828125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestGetUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users/1\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_user.json\")\n\t})\n\n\tuser, _, err := client.Users.GetUser(1, GetUsersOptions{})\n\trequire.NoError(t, err)\n\n\twant := &User{\n\t\tID:           1,\n\t\tUsername:     \"john_smith\",\n\t\tName:         \"John Smith\",\n\t\tState:        \"active\",\n\t\tWebURL:       \"http://localhost:3000/john_smith\",\n\t\tCreatedAt:    Ptr(time.Date(2012, time.May, 23, 8, 0o0, 58, 0, time.UTC)),\n\t\tBio:          \"Bio of John Smith\",\n\t\tLocation:     \"USA\",\n\t\tPublicEmail:  \"john@example.com\",\n\t\tSkype:        \"john_smith\",\n\t\tLinkedin:     \"john_smith\",\n\t\tTwitter:      \"john_smith\",\n\t\tWebsiteURL:   \"john_smith.example.com\",\n\t\tOrganization: \"Smith Inc\",\n\t\tJobTitle:     \"Operations Specialist\",\n\t\tAvatarURL:    \"http://localhost:3000/uploads/user/avatar/1/cd8.jpeg\",\n\t}\n\trequire.Equal(t, want, user)\n}\n\nfunc TestGetUserAdmin(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users/1\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_user_admin.json\")\n\t})\n\n\tuser, _, err := client.Users.GetUser(1, GetUsersOptions{})\n\trequire.NoError(t, err)\n\n\tlastActivityOn := ISOTime(time.Date(2012, time.May, 23, 0, 0, 0, 0, time.UTC))\n\tcurrentSignInIP := net.ParseIP(\"8.8.8.8\")\n\tlastSignInIP := net.ParseIP(\"2001:db8::68\")\n\n\twant := &User{\n\t\tID:               1,\n\t\tUsername:         \"john_smith\",\n\t\tEmail:            \"john@example.com\",\n\t\tName:             \"John Smith\",\n\t\tState:            \"active\",\n\t\tWebURL:           \"http://localhost:3000/john_smith\",\n\t\tCreatedAt:        Ptr(time.Date(2012, time.May, 23, 8, 0, 58, 0, time.UTC)),\n\t\tBio:              \"Bio of John Smith\",\n\t\tLocation:         \"USA\",\n\t\tPublicEmail:      \"john@example.com\",\n\t\tSkype:            \"john_smith\",\n\t\tLinkedin:         \"john_smith\",\n\t\tTwitter:          \"john_smith\",\n\t\tWebsiteURL:       \"john_smith.example.com\",\n\t\tOrganization:     \"Smith Inc\",\n\t\tJobTitle:         \"Operations Specialist\",\n\t\tThemeID:          1,\n\t\tLastActivityOn:   &lastActivityOn,\n\t\tColorSchemeID:    2,\n\t\tIsAdmin:          true,\n\t\tIsAuditor:        true,\n\t\tAvatarURL:        \"http://localhost:3000/uploads/user/avatar/1/index.jpg\",\n\t\tCanCreateGroup:   true,\n\t\tCanCreateProject: true,\n\t\tProjectsLimit:    100,\n\t\tCurrentSignInAt:  Ptr(time.Date(2012, time.June, 2, 6, 36, 55, 0, time.UTC)),\n\t\tCurrentSignInIP:  &currentSignInIP,\n\t\tLastSignInAt:     Ptr(time.Date(2012, time.June, 1, 11, 41, 1, 0, time.UTC)),\n\t\tLastSignInIP:     &lastSignInIP,\n\t\tConfirmedAt:      Ptr(time.Date(2012, time.May, 23, 9, 0o5, 22, 0, time.UTC)),\n\t\tTwoFactorEnabled: true,\n\t\tNote:             \"DMCA Request: 2018-11-05 | DMCA Violation | Abuse | https://gitlab.zendesk.com/agent/tickets/123\",\n\t\tIdentities:       []*UserIdentity{{Provider: \"github\", ExternUID: \"2435223452345\"}},\n\t\tNamespaceID:      42,\n\t}\n\trequire.Equal(t, want, user)\n}\n\nfunc TestBlockUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/block\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.BlockUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.BlockUser returned error: %v\", err)\n\t}\n}\n\nfunc TestBlockUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/block\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.BlockUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.BlockUser error.\\nExpected: %+v\\nGot: %+v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestBlockUser_BlockPrevented(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/block\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t})\n\n\terr := client.Users.BlockUser(1)\n\tif !errors.Is(err, ErrUserBlockPrevented) {\n\t\tt.Errorf(\"Users.BlockUser error.\\nExpected: %+v\\nGot: %+v\", ErrUserBlockPrevented, err)\n\t}\n}\n\nfunc TestBlockUser_UnknownError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/block\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\twant := fmt.Sprintf(\"Received unexpected result code: %d\", http.StatusTeapot)\n\n\terr := client.Users.BlockUser(1)\n\tif err.Error() != want {\n\t\tt.Errorf(\"Users.BlockUser error.\\nExpected: %s\\nGot: %v\", want, err)\n\t}\n}\n\nfunc TestUnblockUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unblock\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.UnblockUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.UnblockUser returned error: %v\", err)\n\t}\n}\n\nfunc TestUnblockUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unblock\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.UnblockUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.UnblockUser error.\\nExpected: %v\\nGot: %v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestUnblockUser_UnblockPrevented(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unblock\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t})\n\n\terr := client.Users.UnblockUser(1)\n\tif !errors.Is(err, ErrUserUnblockPrevented) {\n\t\tt.Errorf(\"Users.UnblockUser error.\\nExpected: %v\\nGot: %v\", ErrUserUnblockPrevented, err)\n\t}\n}\n\nfunc TestUnblockUser_UnknownError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unblock\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\twant := fmt.Sprintf(\"Received unexpected result code: %d\", http.StatusTeapot)\n\n\terr := client.Users.UnblockUser(1)\n\tif err.Error() != want {\n\t\tt.Errorf(\"Users.UnblockUser error.\\nExpected: %s\\n\\tGot: %v\", want, err)\n\t}\n}\n\nfunc TestBanUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/block\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.BlockUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.BlockUser returned error: %v\", err)\n\t}\n}\n\nfunc TestBanUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/ban\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.BanUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.BanUser error.\\nExpected: %+v\\nGot: %+v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestBanUser_UnknownError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/ban\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\twant := fmt.Sprintf(\"Received unexpected result code: %d\", http.StatusTeapot)\n\n\terr := client.Users.BanUser(1)\n\tif err.Error() != want {\n\t\tt.Errorf(\"Users.BanUSer error.\\nExpected: %s\\nGot: %v\", want, err)\n\t}\n}\n\nfunc TestUnbanUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unban\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.UnbanUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.UnbanUser returned error: %v\", err)\n\t}\n}\n\nfunc TestUnbanUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unban\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.UnbanUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.UnbanUser error.\\nExpected: %v\\nGot: %v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestUnbanUser_UnknownError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/unban\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\twant := fmt.Sprintf(\"Received unexpected result code: %d\", http.StatusTeapot)\n\n\terr := client.Users.UnbanUser(1)\n\tif err.Error() != want {\n\t\tt.Errorf(\"Users.UnbanUser error.\\nExpected: %s\\n\\tGot: %v\", want, err)\n\t}\n}\n\nfunc TestDeactivateUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/deactivate\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.DeactivateUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.DeactivateUser returned error: %v\", err)\n\t}\n}\n\nfunc TestDeactivateUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/deactivate\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.DeactivateUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.DeactivateUser error.\\nExpected: %+v\\n\\tGot: %+v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestDeactivateUser_DeactivatePrevented(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/deactivate\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t})\n\n\terr := client.Users.DeactivateUser(1)\n\tif !errors.Is(err, ErrUserDeactivatePrevented) {\n\t\tt.Errorf(\"Users.DeactivateUser error.\\nExpected: %+v\\n\\tGot: %+v\", ErrUserDeactivatePrevented, err)\n\t}\n}\n\nfunc TestActivateUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/activate\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.ActivateUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.ActivateUser returned error: %v\", err)\n\t}\n}\n\nfunc TestActivateUser_ActivatePrevented(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/activate\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t})\n\n\terr := client.Users.ActivateUser(1)\n\tif !errors.Is(err, ErrUserActivatePrevented) {\n\t\tt.Errorf(\"Users.ActivateUser error.\\nExpected: %+v\\n\\tGot: %+v\", ErrUserActivatePrevented, err)\n\t}\n}\n\nfunc TestActivateUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/activate\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.ActivateUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.ActivateUser error.\\nExpected: %+v\\n\\tGot: %+v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestApproveUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/approve\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t})\n\n\terr := client.Users.ApproveUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.ApproveUser returned error: %v\", err)\n\t}\n}\n\nfunc TestApproveUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/approve\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.ApproveUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.ApproveUser error.\\nExpected: %v\\nGot: %v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestApproveUser_ApprovePrevented(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/approve\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t})\n\n\terr := client.Users.ApproveUser(1)\n\tif !errors.Is(err, ErrUserApprovePrevented) {\n\t\tt.Errorf(\"Users.ApproveUser error.\\nExpected: %v\\nGot: %v\", ErrUserApprovePrevented, err)\n\t}\n}\n\nfunc TestApproveUser_UnknownError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/approve\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\twant := fmt.Sprintf(\"Received unexpected result code: %d\", http.StatusTeapot)\n\n\terr := client.Users.ApproveUser(1)\n\tif err.Error() != want {\n\t\tt.Errorf(\"Users.ApproveUser error.\\nExpected: %s\\n\\tGot: %v\", want, err)\n\t}\n}\n\nfunc TestRejectUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/reject\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusOK)\n\t})\n\n\terr := client.Users.RejectUser(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.RejectUser returned error: %v\", err)\n\t}\n}\n\nfunc TestRejectUser_UserNotFound(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/reject\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\terr := client.Users.RejectUser(1)\n\tif !errors.Is(err, ErrUserNotFound) {\n\t\tt.Errorf(\"Users.RejectUser error.\\nExpected: %v\\nGot: %v\", ErrUserNotFound, err)\n\t}\n}\n\nfunc TestRejectUser_RejectPrevented(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/reject\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusForbidden)\n\t})\n\n\terr := client.Users.RejectUser(1)\n\tif !errors.Is(err, ErrUserRejectPrevented) {\n\t\tt.Errorf(\"Users.RejectUser error.\\nExpected: %v\\nGot: %v\", ErrUserRejectPrevented, err)\n\t}\n}\n\nfunc TestRejectUser_Conflict(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/reject\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusConflict)\n\t})\n\n\terr := client.Users.RejectUser(1)\n\tif !errors.Is(err, ErrUserConflict) {\n\t\tt.Errorf(\"Users.RejectUser error.\\nExpected: %v\\nGot: %v\", ErrUserConflict, err)\n\t}\n}\n\nfunc TestRejectUser_UnknownError(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/reject\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusTeapot)\n\t})\n\n\twant := fmt.Sprintf(\"Received unexpected result code: %d\", http.StatusTeapot)\n\n\terr := client.Users.RejectUser(1)\n\tif err.Error() != want {\n\t\tt.Errorf(\"Users.RejectUser error.\\nExpected: %s\\n\\tGot: %v\", want, err)\n\t}\n}\n\nfunc TestGetMemberships(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/memberships\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_user_memberships.json\")\n\t})\n\n\topt := new(GetUserMembershipOptions)\n\n\tmemberships, _, err := client.Users.GetUserMemberships(1, opt)\n\trequire.NoError(t, err)\n\n\twant := []*UserMembership{{SourceID: 1, SourceName: \"Project one\", SourceType: \"Project\", AccessLevel: 20}, {SourceID: 3, SourceName: \"Group three\", SourceType: \"Namespace\", AccessLevel: 20}}\n\tassert.Equal(t, want, memberships)\n}\n\nfunc TestGetUserAssociationsCount(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users/1/associations_count\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_user_associations_count.json\")\n\t})\n\n\tuserAssociationsCount, _, err := client.Users.GetUserAssociationsCount(1)\n\trequire.NoError(t, err)\n\n\twant := &UserAssociationsCount{\n\t\tGroupsCount:        1,\n\t\tProjectsCount:      2,\n\t\tIssuesCount:        3,\n\t\tMergeRequestsCount: 4,\n\t}\n\trequire.Equal(t, want, userAssociationsCount)\n}\n\nfunc TestGetSingleSSHKeyForUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/users/1/keys/1\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprint(w, `\n\t\t{\n\t\t\t\"id\": 1,\n\t\t\t\"title\": \"Public key\",\n\t\t\t\"key\": \"ssh-rsa AAAA...\",\n\t\t\t\"created_at\": \"2014-08-01T14:47:39.080Z\"\n\t\t}`)\n\t})\n\n\tsshKey, _, err := client.Users.GetSSHKeyForUser(1, 1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.GetSSHKeyForUser returned an error: %v\", err)\n\t}\n\n\twantCreatedAt := time.Date(2014, 8, 1, 14, 47, 39, 80000000, time.UTC)\n\n\twant := &SSHKey{\n\t\tID:        1,\n\t\tTitle:     \"Public key\",\n\t\tKey:       \"ssh-rsa AAAA...\",\n\t\tCreatedAt: &wantCreatedAt,\n\t}\n\n\tif !reflect.DeepEqual(want, sshKey) {\n\t\tt.Errorf(\"Users.GetSSHKeyForUser returned %+v, want %+v\", sshKey, want)\n\t}\n}\n\nfunc TestDisableUser2FA(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%susers/1/disable_two_factor\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPatch)\n\t\tw.WriteHeader(http.StatusNoContent)\n\t})\n\n\terr := client.Users.DisableTwoFactor(1)\n\tif err != nil {\n\t\tt.Errorf(\"Users.DisableTwoFactor returned error: %v\", err)\n\t}\n}\n\nfunc TestCreateUserRunner(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := fmt.Sprintf(\"/%suser/runners\", apiVersionPath)\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tw.Write([]byte(`\n    {\n      \"id\": 1234,\n      \"token\": \"glrt-1234567890ABCD\",\n      \"token_expires_at\":null\n    }`))\n\t})\n\n\tcreateRunnerOpts := &CreateUserRunnerOptions{\n\t\tProjectID:  Ptr(1),\n\t\tRunnerType: Ptr(\"project_type\"),\n\t}\n\n\tresponse, _, err := client.Users.CreateUserRunner(createRunnerOpts)\n\tif err != nil {\n\t\tt.Errorf(\"Users.CreateUserRunner returned an error: %v\", err)\n\t}\n\n\trequire.Equal(t, 1234, response.ID)\n\trequire.Equal(t, \"glrt-1234567890ABCD\", response.Token)\n\trequire.Equal(t, (*time.Time)(nil), response.TokenExpiresAt)\n}\n\nfunc TestCreatePersonalAccessTokenForCurrentUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/user/personal_access_tokens\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/post_user_personal_access_tokens.json\")\n\t})\n\n\tscopes := []string{\"k8s_proxy\"}\n\texpiresAt := ISOTime(time.Date(2020, time.October, 15, 0, 0, 0, 0, time.UTC))\n\tuser, _, err := client.Users.CreatePersonalAccessTokenForCurrentUser(&CreatePersonalAccessTokenForCurrentUserOptions{\n\t\tName:      String(\"mytoken\"),\n\t\tScopes:    &scopes,\n\t\tExpiresAt: &expiresAt,\n\t})\n\trequire.NoError(t, err)\n\n\tcreatedAt := time.Date(2020, time.October, 14, 11, 58, 53, 526000000, time.UTC)\n\twant := &PersonalAccessToken{\n\t\tID:        3,\n\t\tName:      \"mytoken\",\n\t\tRevoked:   false,\n\t\tCreatedAt: &createdAt,\n\t\tScopes:    scopes,\n\t\tUserID:    42,\n\t\tActive:    true,\n\t\tExpiresAt: &expiresAt,\n\t\tToken:     \"glpat-aaaaaaaa-bbbbbbbbb\",\n\t}\n\trequire.Equal(t, want, user)\n}\n\nfunc TestCreateServiceAccountUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/service_accounts\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"application/json\") {\n\t\t\tt.Fatalf(\"Users.CreateServiceAccountUser request content-type %+v want application/json;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Users.CreateServiceAccountUser request content-length is -1\")\n\t\t}\n\t\tmustWriteHTTPResponse(t, w, \"testdata/create_service_account_user.json\")\n\t})\n\n\tuser, _, err := client.Users.CreateServiceAccountUser(&CreateServiceAccountUserOptions{\n\t\tName:     Ptr(\"Test Service Account\"),\n\t\tUsername: Ptr(\"serviceaccount\"),\n\t})\n\trequire.NoError(t, err)\n\n\twant := &User{\n\t\tID:        999,\n\t\tUsername:  \"serviceaccount\",\n\t\tName:      \"Test Service Account\",\n\t\tState:     \"active\",\n\t\tLocked:    false,\n\t\tAvatarURL: \"http://localhost:3000/uploads/user/avatar/999/cd8.jpeg\",\n\t\tWebURL:    \"http://localhost:3000/serviceaccount\",\n\t}\n\trequire.Equal(t, want, user)\n}\n\nfunc TestCreateUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"application/json\") {\n\t\t\tt.Fatalf(\"Users.CreateUser request content-type %+v want application/json;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Users.CreateUser request content-length is -1\")\n\t\t}\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tw.Write([]byte(`\n    {\n      \"email\": \"user999@example.com\",\n      \"id\": 999,\n      \"name\":\"Firstname Lastname\",\n      \"username\":\"user\"\n    }`))\n\t})\n\n\tuser, _, err := client.Users.CreateUser(&CreateUserOptions{\n\t\tEmail:    Ptr(\"user999@example.com\"),\n\t\tName:     Ptr(\"Firstname Lastname\"),\n\t\tUsername: Ptr(\"user\"),\n\t})\n\trequire.NoError(t, err)\n\n\twant := &User{\n\t\tEmail:    \"user999@example.com\",\n\t\tID:       999,\n\t\tName:     \"Firstname Lastname\",\n\t\tUsername: \"user\",\n\t}\n\trequire.Equal(t, want, user)\n}\n\nfunc TestCreateUserAvatar(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data\") {\n\t\t\tt.Fatalf(\"Users.CreateUser request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Users.CreateUser request content-length is -1\")\n\t\t}\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tw.Write([]byte(`\n    {\n      \"avatar_url\":\"http://localhost:3000/uploads/-/system/user/avatar/999/avatar.png\",\n      \"email\": \"user999@example.com\",\n      \"id\": 999,\n      \"name\":\"Firstname Lastname\",\n      \"username\":\"user\"\n    }`))\n\t})\n\tavatar := new(bytes.Buffer)\n\tuserAvatar := &UserAvatar{\n\t\tImage:    avatar,\n\t\tFilename: \"avatar.png\",\n\t}\n\tuser, _, err := client.Users.CreateUser(&CreateUserOptions{\n\t\tAvatar:   userAvatar,\n\t\tEmail:    Ptr(\"user999@example.com\"),\n\t\tName:     Ptr(\"Firstname Lastname\"),\n\t\tUsername: Ptr(\"user\"),\n\t})\n\trequire.NoError(t, err)\n\n\twant := &User{\n\t\tAvatarURL: \"http://localhost:3000/uploads/-/system/user/avatar/999/avatar.png\",\n\t\tEmail:     \"user999@example.com\",\n\t\tID:        999,\n\t\tName:      \"Firstname Lastname\",\n\t\tUsername:  \"user\",\n\t}\n\trequire.Equal(t, want, user)\n}\n\nfunc TestModifyUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users/1\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"application/json\") {\n\t\t\tt.Fatalf(\"Users.ModifyUser request content-type %+v want application/json;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Users.ModifyUser request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{}`)\n\t})\n\t_, _, err := client.Users.ModifyUser(1, &ModifyUserOptions{})\n\trequire.NoError(t, err)\n}\n\nfunc TestModifyUserAvatar(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/users/1\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data;\") {\n\t\t\tt.Fatalf(\"Users.ModifyUser request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Users.ModifyUser request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{}`)\n\t})\n\tavatar := new(bytes.Buffer)\n\tuserAvatar := &UserAvatar{\n\t\tImage:    avatar,\n\t\tFilename: \"avatar.png\",\n\t}\n\t_, _, err := client.Users.ModifyUser(1, &ModifyUserOptions{Avatar: userAvatar})\n\trequire.NoError(t, err)\n}\n\nfunc TestUploadAvatarUser(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/user/avatar\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tif !strings.Contains(r.Header.Get(\"Content-Type\"), \"multipart/form-data;\") {\n\t\t\tt.Fatalf(\"Users.UploadAvatar request content-type %+v want multipart/form-data;\", r.Header.Get(\"Content-Type\"))\n\t\t}\n\t\tif r.ContentLength == -1 {\n\t\t\tt.Fatalf(\"Users.UploadAvatar request content-length is -1\")\n\t\t}\n\t\tfmt.Fprint(w, `{}`)\n\t})\n\n\tavatar := new(bytes.Buffer)\n\t_, _, err := client.Users.UploadAvatar(avatar, \"avatar.png\")\n\tif err != nil {\n\t\tt.Fatalf(\"Users.UploadAvatar returns an error: %v\", err)\n\t}\n}\n\nfunc TestListServiceAccounts(t *testing.T) {\n\tmux, client := setup(t)\n\n\tpath := \"/api/v4/service_accounts\"\n\n\tmux.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tmustWriteHTTPResponse(t, w, \"testdata/get_serviceaccounts.json\")\n\t})\n\n\tserviceaccounts, _, err := client.Users.ListServiceAccounts(&ListServiceAccountsOptions{})\n\trequire.NoError(t, err)\n\twant := []*ServiceAccount{\n\t\t{\n\t\t\tID:       114,\n\t\t\tUsername: \"service_account_33\",\n\t\t\tName:     \"Service account user\",\n\t\t},\n\t\t{\n\t\t\tID:       137,\n\t\t\tUsername: \"service_account_34\",\n\t\t\tName:     \"john doe\",\n\t\t},\n\t}\n\trequire.Equal(t, want, serviceaccounts)\n}\n"
        },
        {
          "name": "validate.go",
          "type": "blob",
          "size": 4.9736328125,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\n// ValidateService handles communication with the validation related methods of\n// the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/lint.html\ntype ValidateService struct {\n\tclient *Client\n}\n\n// LintResult represents the linting results.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/lint.html\ntype LintResult struct {\n\tStatus     string   `json:\"status\"`\n\tErrors     []string `json:\"errors\"`\n\tWarnings   []string `json:\"warnings\"`\n\tMergedYaml string   `json:\"merged_yaml\"`\n}\n\n// ProjectLintResult represents the linting results by project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-a-projects-ci-configuration\ntype ProjectLintResult struct {\n\tValid      bool     `json:\"valid\"`\n\tErrors     []string `json:\"errors\"`\n\tWarnings   []string `json:\"warnings\"`\n\tMergedYaml string   `json:\"merged_yaml\"`\n}\n\n// LintOptions represents the available Lint() options.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-the-ci-yaml-configuration\ntype LintOptions struct {\n\tContent           string `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tIncludeMergedYAML bool   `url:\"include_merged_yaml,omitempty\" json:\"include_merged_yaml,omitempty\"`\n\tIncludeJobs       bool   `url:\"include_jobs,omitempty\" json:\"include_jobs,omitempty\"`\n}\n\n// Lint validates .gitlab-ci.yml content.\n// Deprecated: This endpoint was removed in GitLab 16.0.\n//\n// Gitlab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-the-ci-yaml-configuration-deprecated\nfunc (s *ValidateService) Lint(opts *LintOptions, options ...RequestOptionFunc) (*LintResult, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodPost, \"ci/lint\", &opts, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(LintResult)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// ProjectNamespaceLintOptions represents the available ProjectNamespaceLint() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-a-ci-yaml-configuration-with-a-namespace\ntype ProjectNamespaceLintOptions struct {\n\tContent     *string `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tDryRun      *bool   `url:\"dry_run,omitempty\" json:\"dry_run,omitempty\"`\n\tIncludeJobs *bool   `url:\"include_jobs,omitempty\" json:\"include_jobs,omitempty\"`\n\tRef         *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\n// ProjectNamespaceLint validates .gitlab-ci.yml content by project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-a-ci-yaml-configuration-with-a-namespace\nfunc (s *ValidateService) ProjectNamespaceLint(pid interface{}, opt *ProjectNamespaceLintOptions, options ...RequestOptionFunc) (*ProjectLintResult, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/ci/lint\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, &opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(ProjectLintResult)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n\n// ProjectLintOptions represents the available ProjectLint() options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-a-projects-ci-configuration\ntype ProjectLintOptions struct {\n\tContentRef  *string `url:\"content_ref,omitempty\" json:\"content_ref,omitempty\"`\n\tDryRunRef   *string `url:\"dry_run_ref,omitempty\" json:\"dry_run_ref,omitempty\"`\n\tDryRun      *bool   `url:\"dry_run,omitempty\" json:\"dry_run,omitempty\"`\n\tIncludeJobs *bool   `url:\"include_jobs,omitempty\" json:\"include_jobs,omitempty\"`\n\tRef         *string `url:\"ref,omitempty\" json:\"ref,omitempty\"`\n}\n\n// ProjectLint validates .gitlab-ci.yml content by project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/lint.html#validate-a-projects-ci-configuration\nfunc (s *ValidateService) ProjectLint(pid interface{}, opt *ProjectLintOptions, options ...RequestOptionFunc) (*ProjectLintResult, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/ci/lint\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, &opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tl := new(ProjectLintResult)\n\tresp, err := s.client.Do(req, l)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn l, resp, nil\n}\n"
        },
        {
          "name": "validate_test.go",
          "type": "blob",
          "size": 6.912109375,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestValidate(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\topts        *LintOptions\n\t\tresponse    string\n\t\twant        *LintResult\n\t}{\n\t\t{\n\t\t\tdescription: \"valid\",\n\t\t\topts: &LintOptions{\n\t\t\t\tContent: `\n\t\t\t\tbuild1:\n\t\t\t\t\tstage: build\n\t\t\t\t\tscript:\n\t\t\t\t\t\t- echo \"Do your build here\"`,\n\t\t\t\tIncludeMergedYAML: true,\n\t\t\t\tIncludeJobs:       false,\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"status\": \"valid\",\n\t\t\t\t\"errors\": [],\n\t\t\t\t\"merged_yaml\":\"---\\nbuild1:\\n    stage: build\\n    script:\\n    - echo\\\"Do your build here\\\"\"\n\t\t\t}`,\n\t\t\twant: &LintResult{\n\t\t\t\tStatus:     \"valid\",\n\t\t\t\tMergedYaml: \"---\\nbuild1:\\n    stage: build\\n    script:\\n    - echo\\\"Do your build here\\\"\",\n\t\t\t\tErrors:     []string{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"invalid\",\n\t\t\topts: &LintOptions{\n\t\t\t\tContent: `\n\t\t\t\t\tbuild1:\n\t\t\t\t\t\t- echo \"Do your build here\"`,\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"status\": \"invalid\",\n\t\t\t\t\"errors\": [\"error message when content is invalid\"]\n\t\t\t}`,\n\t\t\twant: &LintResult{\n\t\t\t\tStatus: \"invalid\",\n\t\t\t\tErrors: []string{\"error message when content is invalid\"},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tmux, client := setup(t)\n\n\t\t\tmux.HandleFunc(\"/api/v4/ci/lint\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\t\tfmt.Fprint(w, tc.response)\n\t\t\t})\n\n\t\t\tgot, _, err := client.Validate.Lint(tc.opts)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Validate returned error: %v\", err)\n\t\t\t}\n\n\t\t\twant := tc.want\n\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"Validate returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateProject(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\tresponse    string\n\t\twant        *ProjectLintResult\n\t}{\n\t\t{\n\t\t\tdescription: \"valid\",\n\t\t\tresponse: `{\n\t\t\t\t\"valid\": true,\n\t\t\t\t\"errors\": [],\n\t\t\t\t\"warnings\": [],\n\t\t\t\t\"merged_yaml\": \t\"---\\n:build:\\n  :script:\\n  - echo build\"\n\t\t\t}`,\n\t\t\twant: &ProjectLintResult{\n\t\t\t\tValid:      true,\n\t\t\t\tWarnings:   []string{},\n\t\t\t\tErrors:     []string{},\n\t\t\t\tMergedYaml: \"---\\n:build:\\n  :script:\\n  - echo build\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"invalid\",\n\t\t\tresponse: `{\n\t\t\t\t\"valid\": false,\n\t\t\t\t\"errors\": [\"jobs:build config contains unknown keys: bad_key\"],\n\t\t\t\t\"warnings\": [],\n\t\t\t\t\"merged_yaml\": \t\"---\\n:build:\\n  :script:\\n  - echo build\\n  :bad_key: value\"\n\t\t\t}`,\n\t\t\twant: &ProjectLintResult{\n\t\t\t\tValid:      false,\n\t\t\t\tWarnings:   []string{},\n\t\t\t\tErrors:     []string{\"jobs:build config contains unknown keys: bad_key\"},\n\t\t\t\tMergedYaml: \"---\\n:build:\\n  :script:\\n  - echo build\\n  :bad_key: value\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tmux, client := setup(t)\n\n\t\t\tmux.HandleFunc(\"/api/v4/projects/1/ci/lint\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\t\tfmt.Fprint(w, tc.response)\n\t\t\t})\n\n\t\t\topt := &ProjectLintOptions{}\n\t\t\tgot, _, err := client.Validate.ProjectLint(1, opt)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Validate returned error: %v\", err)\n\t\t\t}\n\n\t\t\twant := tc.want\n\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"Validate returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateProjectNamespace(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\trequest     *ProjectNamespaceLintOptions\n\t\tresponse    string\n\t\twant        *ProjectLintResult\n\t}{\n\t\t{\n\t\t\tdescription: \"valid\",\n\t\t\trequest: &ProjectNamespaceLintOptions{\n\t\t\t\tContent:     Ptr(\"{'build': {'script': 'echo build'}}\"),\n\t\t\t\tDryRun:      Ptr(false),\n\t\t\t\tIncludeJobs: Ptr(true),\n\t\t\t\tRef:         Ptr(\"foo\"),\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"valid\": true,\n\t\t\t\t\"errors\": [],\n\t\t\t\t\"warnings\": [],\n\t\t\t\t\"merged_yaml\": \t\"---\\n:build:\\n  :script:\\n  - echo build\"\n\t\t\t}`,\n\t\t\twant: &ProjectLintResult{\n\t\t\t\tValid:      true,\n\t\t\t\tWarnings:   []string{},\n\t\t\t\tErrors:     []string{},\n\t\t\t\tMergedYaml: \"---\\n:build:\\n  :script:\\n  - echo build\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tdescription: \"invalid\",\n\t\t\trequest: &ProjectNamespaceLintOptions{\n\t\t\t\tContent: Ptr(\"{'build': {'script': 'echo build', 'bad_key': 'value'}}\"),\n\t\t\t\tDryRun:  Ptr(false),\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"valid\": false,\n\t\t\t\t\"errors\": [\"jobs:build config contains unknown keys: bad_key\"],\n\t\t\t\t\"warnings\": [],\n\t\t\t\t\"merged_yaml\": \t\"---\\n:build:\\n  :script:\\n  - echo build\\n  :bad_key: value\"\n\t\t\t}`,\n\t\t\twant: &ProjectLintResult{\n\t\t\t\tValid:      false,\n\t\t\t\tWarnings:   []string{},\n\t\t\t\tErrors:     []string{\"jobs:build config contains unknown keys: bad_key\"},\n\t\t\t\tMergedYaml: \"---\\n:build:\\n  :script:\\n  - echo build\\n  :bad_key: value\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tmux, client := setup(t)\n\n\t\t\tmux.HandleFunc(\"/api/v4/projects/1/ci/lint\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\ttestMethod(t, r, http.MethodPost)\n\t\t\t\tfmt.Fprint(w, tc.response)\n\t\t\t})\n\n\t\t\tgot, _, err := client.Validate.ProjectNamespaceLint(1, tc.request)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Validate returned error: %v\", err)\n\t\t\t}\n\n\t\t\twant := tc.want\n\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"Validate returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateProjectLint(t *testing.T) {\n\ttestCases := []struct {\n\t\tdescription string\n\t\trequest     *ProjectLintOptions\n\t\tresponse    string\n\t\twant        *ProjectLintResult\n\t}{\n\t\t{\n\t\t\tdescription: \"valid\",\n\t\t\trequest: &ProjectLintOptions{\n\t\t\t\tDryRun:      Ptr(false),\n\t\t\t\tIncludeJobs: Ptr(true),\n\t\t\t\tContentRef:  Ptr(\"foo\"),\n\t\t\t},\n\t\t\tresponse: `{\n\t\t\t\t\"valid\": true,\n\t\t\t\t\"errors\": [],\n\t\t\t\t\"warnings\": [],\n\t\t\t\t\"merged_yaml\": \t\"---\\n:build:\\n  :script:\\n  - echo build\"\n\t\t\t}`,\n\t\t\twant: &ProjectLintResult{\n\t\t\t\tValid:      true,\n\t\t\t\tWarnings:   []string{},\n\t\t\t\tErrors:     []string{},\n\t\t\t\tMergedYaml: \"---\\n:build:\\n  :script:\\n  - echo build\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.description, func(t *testing.T) {\n\t\t\tmux, client := setup(t)\n\n\t\t\tmux.HandleFunc(\"/api/v4/projects/1/ci/lint\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\t\tfmt.Fprint(w, tc.response)\n\t\t\t})\n\n\t\t\tgot, _, err := client.Validate.ProjectLint(1, tc.request)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Validate returned error: %v\", err)\n\t\t\t}\n\n\t\t\twant := tc.want\n\t\t\tif !reflect.DeepEqual(got, want) {\n\t\t\t\tt.Errorf(\"Validate returned \\ngot:\\n%v\\nwant:\\n%v\", Stringify(got), Stringify(want))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.61328125,
          "content": "//\n// Copyright 2021, Andrea Funto'\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport \"net/http\"\n\n// VersionService handles communication with the GitLab server instance to\n// retrieve its version information via the GitLab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/version.html\ntype VersionService struct {\n\tclient *Client\n}\n\n// Version represents a GitLab instance version.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/version.html\ntype Version struct {\n\tVersion  string `json:\"version\"`\n\tRevision string `json:\"revision\"`\n}\n\nfunc (s Version) String() string {\n\treturn Stringify(s)\n}\n\n// GetVersion gets a GitLab server instance version; it is only available to\n// authenticated users.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/version.html\nfunc (s *VersionService) GetVersion(options ...RequestOptionFunc) (*Version, *Response, error) {\n\treq, err := s.client.NewRequest(http.MethodGet, \"version\", nil, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tv := new(Version)\n\tresp, err := s.client.Do(req, v)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn v, resp, nil\n}\n"
        },
        {
          "name": "version_test.go",
          "type": "blob",
          "size": 1.201171875,
          "content": "//\n// Copyright 2021, Sander van Harmelen\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestGetVersion(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/version\",\n\t\tfunc(w http.ResponseWriter, r *http.Request) {\n\t\t\ttestMethod(t, r, http.MethodGet)\n\t\t\tfmt.Fprint(w, `{\"version\":\"11.3.4-ee\", \"revision\":\"14d3a1d\"}`)\n\t\t})\n\n\tversion, _, err := client.Version.GetVersion()\n\tif err != nil {\n\t\tt.Errorf(\"Version.GetVersion returned error: %v\", err)\n\t}\n\n\twant := &Version{Version: \"11.3.4-ee\", Revision: \"14d3a1d\"}\n\tif !reflect.DeepEqual(want, version) {\n\t\tt.Errorf(\"Version.GetVersion returned %+v, want %+v\", version, want)\n\t}\n}\n"
        },
        {
          "name": "wikis.go",
          "type": "blob",
          "size": 5.9208984375,
          "content": "//\n// Copyright 2021, Stany MARCEL\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/url\"\n)\n\n// WikisService handles communication with the wikis related methods of\n// the Gitlab API.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/wikis.html\ntype WikisService struct {\n\tclient *Client\n}\n\n// Wiki represents a GitLab wiki.\n//\n// GitLab API docs: https://docs.gitlab.com/ee/api/wikis.html\ntype Wiki struct {\n\tContent  string          `json:\"content\"`\n\tEncoding string          `json:\"encoding\"`\n\tFormat   WikiFormatValue `json:\"format\"`\n\tSlug     string          `json:\"slug\"`\n\tTitle    string          `json:\"title\"`\n}\n\nfunc (w Wiki) String() string {\n\treturn Stringify(w)\n}\n\n// ListWikisOptions represents the available ListWikis options.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#list-wiki-pages\ntype ListWikisOptions struct {\n\tWithContent *bool `url:\"with_content,omitempty\" json:\"with_content,omitempty\"`\n}\n\n// ListWikis lists all pages of the wiki of the given project id.\n// When with_content is set, it also returns the content of the pages.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#list-wiki-pages\nfunc (s *WikisService) ListWikis(pid interface{}, opt *ListWikisOptions, options ...RequestOptionFunc) ([]*Wiki, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/wikis\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar ws []*Wiki\n\tresp, err := s.client.Do(req, &ws)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn ws, resp, nil\n}\n\n// GetWikiPageOptions represents options to GetWikiPage\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#get-a-wiki-page\ntype GetWikiPageOptions struct {\n\tRenderHTML *bool   `url:\"render_html,omitempty\" json:\"render_html,omitempty\"`\n\tVersion    *string `url:\"version,omitempty\" json:\"version,omitempty\"`\n}\n\n// GetWikiPage gets a wiki page for a given project.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#get-a-wiki-page\nfunc (s *WikisService) GetWikiPage(pid interface{}, slug string, opt *GetWikiPageOptions, options ...RequestOptionFunc) (*Wiki, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/wikis/%s\", PathEscape(project), url.PathEscape(slug))\n\n\treq, err := s.client.NewRequest(http.MethodGet, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tw := new(Wiki)\n\tresp, err := s.client.Do(req, w)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn w, resp, nil\n}\n\n// CreateWikiPageOptions represents options to CreateWikiPage.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#create-a-new-wiki-page\ntype CreateWikiPageOptions struct {\n\tContent *string          `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tTitle   *string          `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFormat  *WikiFormatValue `url:\"format,omitempty\" json:\"format,omitempty\"`\n}\n\n// CreateWikiPage creates a new wiki page for the given repository with\n// the given title, slug, and content.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#create-a-new-wiki-page\nfunc (s *WikisService) CreateWikiPage(pid interface{}, opt *CreateWikiPageOptions, options ...RequestOptionFunc) (*Wiki, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/wikis\", PathEscape(project))\n\n\treq, err := s.client.NewRequest(http.MethodPost, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tw := new(Wiki)\n\tresp, err := s.client.Do(req, w)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn w, resp, nil\n}\n\n// EditWikiPageOptions represents options to EditWikiPage.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#edit-an-existing-wiki-page\ntype EditWikiPageOptions struct {\n\tContent *string          `url:\"content,omitempty\" json:\"content,omitempty\"`\n\tTitle   *string          `url:\"title,omitempty\" json:\"title,omitempty\"`\n\tFormat  *WikiFormatValue `url:\"format,omitempty\" json:\"format,omitempty\"`\n}\n\n// EditWikiPage Updates an existing wiki page. At least one parameter is\n// required to update the wiki page.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#edit-an-existing-wiki-page\nfunc (s *WikisService) EditWikiPage(pid interface{}, slug string, opt *EditWikiPageOptions, options ...RequestOptionFunc) (*Wiki, *Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/wikis/%s\", PathEscape(project), url.PathEscape(slug))\n\n\treq, err := s.client.NewRequest(http.MethodPut, u, opt, options)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tw := new(Wiki)\n\tresp, err := s.client.Do(req, w)\n\tif err != nil {\n\t\treturn nil, resp, err\n\t}\n\n\treturn w, resp, nil\n}\n\n// DeleteWikiPage deletes a wiki page with a given slug.\n//\n// GitLab API docs:\n// https://docs.gitlab.com/ee/api/wikis.html#delete-a-wiki-page\nfunc (s *WikisService) DeleteWikiPage(pid interface{}, slug string, options ...RequestOptionFunc) (*Response, error) {\n\tproject, err := parseID(pid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tu := fmt.Sprintf(\"projects/%s/wikis/%s\", PathEscape(project), url.PathEscape(slug))\n\n\treq, err := s.client.NewRequest(http.MethodDelete, u, nil, options)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.client.Do(req, nil)\n}\n"
        },
        {
          "name": "wikis_test.go",
          "type": "blob",
          "size": 4.623046875,
          "content": "//\n// Copyright 2021, Stany MARCEL\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage gitlab\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestListWikis(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/wikis\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `[\n\t\t\t{\n\t\t\t  \"content\": \"Here is an instruction how to deploy this project.\",\n\t\t\t  \"format\": \"markdown\",\n\t\t\t  \"slug\": \"deploy\",\n\t\t\t  \"title\": \"deploy\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"content\": \"Our development process is described here.\",\n\t\t\t  \"format\": \"markdown\",\n\t\t\t  \"slug\": \"development\",\n\t\t\t  \"title\": \"development\"\n\t\t\t},\n\t\t\t{\n\t\t\t  \"content\": \"*  [Deploy](deploy)\\n*  [Development](development)\",\n\t\t\t  \"format\": \"markdown\",\n\t\t\t  \"slug\": \"home\",\n\t\t\t  \"title\": \"home\"\n\t\t\t}\n\t\t  ]`)\n\t})\n\n\twikis, _, err := client.Wikis.ListWikis(1, &ListWikisOptions{WithContent: Ptr(true)})\n\tif err != nil {\n\t\tt.Errorf(\"Wikis.ListWikis returned error: %v\", err)\n\t}\n\n\twant := []*Wiki{\n\t\t{\n\t\t\tContent: \"Here is an instruction how to deploy this project.\",\n\t\t\tFormat:  \"markdown\",\n\t\t\tSlug:    \"deploy\",\n\t\t\tTitle:   \"deploy\",\n\t\t},\n\t\t{\n\t\t\tContent: \"Our development process is described here.\",\n\t\t\tFormat:  \"markdown\",\n\t\t\tSlug:    \"development\",\n\t\t\tTitle:   \"development\",\n\t\t},\n\t\t{\n\t\t\tContent: \"*  [Deploy](deploy)\\n*  [Development](development)\",\n\t\t\tFormat:  \"markdown\",\n\t\t\tSlug:    \"home\",\n\t\t\tTitle:   \"home\",\n\t\t},\n\t}\n\n\tif !reflect.DeepEqual(want, wikis) {\n\t\tt.Errorf(\"Labels.CreateLabel returned %+v, want %+v\", wikis, want)\n\t}\n}\n\nfunc TestGetWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/wikis/home\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodGet)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"content\": \"home page\",\n\t\t\t\"format\": \"markdown\",\n\t\t\t\"slug\": \"home\",\n\t\t\t\"title\": \"home\",\n\t\t\t\"encoding\": \"UTF-8\"\n\t\t  }`)\n\t})\n\n\twiki, _, err := client.Wikis.GetWikiPage(1, \"home\", &GetWikiPageOptions{})\n\tif err != nil {\n\t\tt.Errorf(\"Wiki.GetWikiPage returned error: %v\", err)\n\t}\n\n\twant := &Wiki{\n\t\tContent:  \"home page\",\n\t\tEncoding: \"UTF-8\",\n\t\tFormat:   \"markdown\",\n\t\tSlug:     \"home\",\n\t\tTitle:    \"home\",\n\t}\n\n\tif !reflect.DeepEqual(want, wiki) {\n\t\tt.Errorf(\"Labels.CreateLabel returned %+v, want %+v\", wiki, want)\n\t}\n}\n\nfunc TestCreateWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/wikis\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPost)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"content\": \"Hello world\",\n\t\t\t\"format\": \"markdown\",\n\t\t\t\"slug\": \"Hello\",\n\t\t\t\"title\": \"Hello\"\n\t\t  }`)\n\t})\n\n\topt := &CreateWikiPageOptions{\n\t\tContent: Ptr(\"Hello world\"),\n\t\tTitle:   Ptr(\"Hello\"),\n\t\tFormat:  Ptr(WikiFormatMarkdown),\n\t}\n\twiki, _, err := client.Wikis.CreateWikiPage(1, opt)\n\tif err != nil {\n\t\tt.Errorf(\"Wiki.CreateWikiPage returned error: %v\", err)\n\t}\n\n\twant := &Wiki{\n\t\tContent: \"Hello world\",\n\t\tFormat:  \"markdown\",\n\t\tSlug:    \"Hello\",\n\t\tTitle:   \"Hello\",\n\t}\n\n\tif !reflect.DeepEqual(want, wiki) {\n\t\tt.Errorf(\"Wiki.CreateWikiPage returned %+v, want %+v\", wiki, want)\n\t}\n}\n\nfunc TestEditWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/wikis/foo\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodPut)\n\t\tfmt.Fprintf(w, `{\n\t\t\t\"content\": \"documentation\",\n\t\t\t\"format\": \"markdown\",\n\t\t\t\"slug\": \"Docs\",\n\t\t\t\"title\": \"Docs\"\n\t\t  }`)\n\t})\n\n\topt := &EditWikiPageOptions{\n\t\tContent: Ptr(\"documentation\"),\n\t\tFormat:  Ptr(WikiFormatMarkdown),\n\t\tTitle:   Ptr(\"Docs\"),\n\t}\n\twiki, _, err := client.Wikis.EditWikiPage(1, \"foo\", opt)\n\tif err != nil {\n\t\tt.Errorf(\"Wiki.EditWikiPage returned error: %v\", err)\n\t}\n\n\twant := &Wiki{\n\t\tContent: \"documentation\",\n\t\tFormat:  \"markdown\",\n\t\tSlug:    \"Docs\",\n\t\tTitle:   \"Docs\",\n\t}\n\n\tif !reflect.DeepEqual(want, wiki) {\n\t\tt.Errorf(\"Wiki.EditWikiPage returned %+v, want %+v\", wiki, want)\n\t}\n}\n\nfunc TestDeleteWikiPage(t *testing.T) {\n\tmux, client := setup(t)\n\n\tmux.HandleFunc(\"/api/v4/projects/1/wikis/foo\", func(w http.ResponseWriter, r *http.Request) {\n\t\ttestMethod(t, r, http.MethodDelete)\n\t})\n\n\t_, err := client.Wikis.DeleteWikiPage(1, \"foo\")\n\tif err != nil {\n\t\tt.Errorf(\"Wiki.DeleteWikiPage returned error: %v\", err)\n\t}\n}\n"
        }
      ]
    }
  ]
}