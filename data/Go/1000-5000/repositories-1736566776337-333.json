{
  "metadata": {
    "timestamp": 1736566776337,
    "page": 333,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "d5/tengo",
      "stars": 3571,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.01171875,
          "content": "dist/\n\n.idea"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.28125,
          "content": "env:\n  - GO111MODULE=on\nbefore:\n  hooks:\n    - go mod tidy\nbuilds:\n  - env:\n      - CGO_ENABLED=0\n    main: ./cmd/tengo/main.go\n    goos:\n      - darwin\n      - linux\n      - windows\narchives:\n  -\n    files:\n      - none*\nchecksum:\n  name_template: 'checksums.txt'\nchangelog:\n  sort: asc\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.04296875,
          "content": "MIT License\n\nCopyright (c) 2019 Daniel Kang\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.1865234375,
          "content": "generate:\n\tgo generate ./...\n\nlint:\n\tgolint -set_exit_status ./...\n\ntest: generate lint\n\tgo test -race -cover ./...\n\tgo run ./cmd/tengo -resolve ./testdata/cli/test.tengo\n\nfmt:\n\tgo fmt ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.9130859375,
          "content": "# The Tengo Language\n\n[![GoDoc](https://godoc.org/github.com/d5/tengo/v2?status.svg)](https://godoc.org/github.com/d5/tengo/v2)\n![test](https://github.com/d5/tengo/workflows/test/badge.svg)\n[![Go Report Card](https://goreportcard.com/badge/github.com/d5/tengo)](https://goreportcard.com/report/github.com/d5/tengo)\n\n**Tengo is a small, dynamic, fast, secure script language for Go.** \n\nTengo is **[fast](#benchmark)** and secure because it's compiled/executed as\nbytecode on stack-based VM that's written in native Go.\n\n```golang\n/* The Tengo Language */\nfmt := import(\"fmt\")\n\neach := func(seq, fn) {\n    for x in seq { fn(x) }\n}\n\nsum := func(init, seq) {\n    each(seq, func(x) { init += x })\n    return init\n}\n\nfmt.println(sum(0, [1, 2, 3]))   // \"6\"\nfmt.println(sum(\"\", [1, 2, 3]))  // \"123\"\n```\n\n> Test this Tengo code in the\n> [Tengo Playground](https://tengolang.com/?s=0c8d5d0d88f2795a7093d7f35ae12c3afa17bea3)\n\n## Features\n\n- Simple and highly readable\n  [Syntax](https://github.com/d5/tengo/blob/master/docs/tutorial.md)\n  - Dynamic typing with type coercion\n  - Higher-order functions and closures\n  - Immutable values\n- [Securely Embeddable](https://github.com/d5/tengo/blob/master/docs/interoperability.md)\n  and [Extensible](https://github.com/d5/tengo/blob/master/docs/objects.md)\n- Compiler/runtime written in native Go _(no external deps or cgo)_\n- Executable as a\n  [standalone](https://github.com/d5/tengo/blob/master/docs/tengo-cli.md)\n  language / REPL\n- Use cases: rules engine, [state machine](https://github.com/d5/go-fsm),\n  data pipeline, [transpiler](https://github.com/d5/tengo2lua)\n\n## Benchmark\n\n| | fib(35) | fibt(35) |  Language (Type)  |\n| :--- |    ---: |     ---: |  :---: |\n| [**Tengo**](https://github.com/d5/tengo) | `2,315ms` | `3ms` | Tengo (VM) |\n| [go-lua](https://github.com/Shopify/go-lua) | `4,028ms` | `3ms` | Lua (VM) |\n| [GopherLua](https://github.com/yuin/gopher-lua) | `4,409ms` | `3ms` | Lua (VM) |\n| [goja](https://github.com/dop251/goja) | `5,194ms` | `4ms` | JavaScript (VM) |\n| [starlark-go](https://github.com/google/starlark-go) | `6,954ms` | `3ms` | Starlark (Interpreter) |\n| [gpython](https://github.com/go-python/gpython) | `11,324ms` | `4ms` | Python (Interpreter) |\n| [Yaegi](https://github.com/containous/yaegi) | `11,715ms` | `10ms` | Yaegi (Interpreter) |\n| [otto](https://github.com/robertkrimen/otto) | `48,539ms` | `6ms` | JavaScript (Interpreter) |\n| [Anko](https://github.com/mattn/anko) | `52,821ms` | `6ms` | Anko (Interpreter) |\n| - | - | - | - |\n| Go | `47ms` | `2ms` | Go (Native) |\n| Lua | `756ms` | `2ms` | Lua (Native) |\n| Python | `1,907ms` | `14ms` | Python2 (Native) |\n\n_* [fib(35)](https://github.com/d5/tengobench/blob/master/code/fib.tengo):\nFibonacci(35)_  \n_* [fibt(35)](https://github.com/d5/tengobench/blob/master/code/fibtc.tengo):\n[tail-call](https://en.wikipedia.org/wiki/Tail_call) version of Fibonacci(35)_  \n_* **Go** does not read the source code from file, while all other cases do_  \n_* See [here](https://github.com/d5/tengobench) for commands/codes used_\n\n## Quick Start\n\n```\ngo get github.com/d5/tengo/v2\n```\n\nA simple Go example code that compiles/runs Tengo script code with some input/output values:\n\n```golang\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/d5/tengo/v2\"\n)\n\nfunc main() {\n\t// create a new Script instance\n\tscript := tengo.NewScript([]byte(\n`each := func(seq, fn) {\n    for x in seq { fn(x) }\n}\n\nsum := 0\nmul := 1\neach([a, b, c, d], func(x) {\n    sum += x\n    mul *= x\n})`))\n\n\t// set values\n\t_ = script.Add(\"a\", 1)\n\t_ = script.Add(\"b\", 9)\n\t_ = script.Add(\"c\", 8)\n\t_ = script.Add(\"d\", 4)\n\n\t// run the script\n\tcompiled, err := script.RunContext(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// retrieve values\n\tsum := compiled.Get(\"sum\")\n\tmul := compiled.Get(\"mul\")\n\tfmt.Println(sum, mul) // \"22 288\"\n}\n```\n\nOr, if you need to evaluate a simple expression, you can use [Eval](https://pkg.go.dev/github.com/d5/tengo/v2#Eval) function instead:\n\n\n```golang\nres, err := tengo.Eval(ctx,\n\t`input ? \"success\" : \"fail\"`,\n\tmap[string]interface{}{\"input\": 1})\nif err != nil {\n\tpanic(err)\n}\nfmt.Println(res) // \"success\"\n```\n\n## References\n\n- [Language Syntax](https://github.com/d5/tengo/blob/master/docs/tutorial.md)\n- [Object Types](https://github.com/d5/tengo/blob/master/docs/objects.md)\n- [Runtime Types](https://github.com/d5/tengo/blob/master/docs/runtime-types.md)\n  and [Operators](https://github.com/d5/tengo/blob/master/docs/operators.md)\n- [Builtin Functions](https://github.com/d5/tengo/blob/master/docs/builtins.md)\n- [Interoperability](https://github.com/d5/tengo/blob/master/docs/interoperability.md)\n- [Tengo CLI](https://github.com/d5/tengo/blob/master/docs/tengo-cli.md)\n- [Standard Library](https://github.com/d5/tengo/blob/master/docs/stdlib.md)\n- Syntax Highlighters: [VSCode](https://github.com/lissein/vscode-tengo), [Atom](https://github.com/d5/tengo-atom), [Vim](https://github.com/geseq/tengo-vim)\n- **Why the name Tengo?** It's from [1Q84](https://en.wikipedia.org/wiki/1Q84).\n\n\n"
        },
        {
          "name": "builtins.go",
          "type": "blob",
          "size": 12.94921875,
          "content": "package tengo\n\nvar builtinFuncs = []*BuiltinFunction{\n\t{\n\t\tName:  \"len\",\n\t\tValue: builtinLen,\n\t},\n\t{\n\t\tName:  \"copy\",\n\t\tValue: builtinCopy,\n\t},\n\t{\n\t\tName:  \"append\",\n\t\tValue: builtinAppend,\n\t},\n\t{\n\t\tName:  \"delete\",\n\t\tValue: builtinDelete,\n\t},\n\t{\n\t\tName:  \"splice\",\n\t\tValue: builtinSplice,\n\t},\n\t{\n\t\tName:  \"string\",\n\t\tValue: builtinString,\n\t},\n\t{\n\t\tName:  \"int\",\n\t\tValue: builtinInt,\n\t},\n\t{\n\t\tName:  \"bool\",\n\t\tValue: builtinBool,\n\t},\n\t{\n\t\tName:  \"float\",\n\t\tValue: builtinFloat,\n\t},\n\t{\n\t\tName:  \"char\",\n\t\tValue: builtinChar,\n\t},\n\t{\n\t\tName:  \"bytes\",\n\t\tValue: builtinBytes,\n\t},\n\t{\n\t\tName:  \"time\",\n\t\tValue: builtinTime,\n\t},\n\t{\n\t\tName:  \"is_int\",\n\t\tValue: builtinIsInt,\n\t},\n\t{\n\t\tName:  \"is_float\",\n\t\tValue: builtinIsFloat,\n\t},\n\t{\n\t\tName:  \"is_string\",\n\t\tValue: builtinIsString,\n\t},\n\t{\n\t\tName:  \"is_bool\",\n\t\tValue: builtinIsBool,\n\t},\n\t{\n\t\tName:  \"is_char\",\n\t\tValue: builtinIsChar,\n\t},\n\t{\n\t\tName:  \"is_bytes\",\n\t\tValue: builtinIsBytes,\n\t},\n\t{\n\t\tName:  \"is_array\",\n\t\tValue: builtinIsArray,\n\t},\n\t{\n\t\tName:  \"is_immutable_array\",\n\t\tValue: builtinIsImmutableArray,\n\t},\n\t{\n\t\tName:  \"is_map\",\n\t\tValue: builtinIsMap,\n\t},\n\t{\n\t\tName:  \"is_immutable_map\",\n\t\tValue: builtinIsImmutableMap,\n\t},\n\t{\n\t\tName:  \"is_iterable\",\n\t\tValue: builtinIsIterable,\n\t},\n\t{\n\t\tName:  \"is_time\",\n\t\tValue: builtinIsTime,\n\t},\n\t{\n\t\tName:  \"is_error\",\n\t\tValue: builtinIsError,\n\t},\n\t{\n\t\tName:  \"is_undefined\",\n\t\tValue: builtinIsUndefined,\n\t},\n\t{\n\t\tName:  \"is_function\",\n\t\tValue: builtinIsFunction,\n\t},\n\t{\n\t\tName:  \"is_callable\",\n\t\tValue: builtinIsCallable,\n\t},\n\t{\n\t\tName:  \"type_name\",\n\t\tValue: builtinTypeName,\n\t},\n\t{\n\t\tName:  \"format\",\n\t\tValue: builtinFormat,\n\t},\n\t{\n\t\tName:  \"range\",\n\t\tValue: builtinRange,\n\t},\n}\n\n// GetAllBuiltinFunctions returns all builtin function objects.\nfunc GetAllBuiltinFunctions() []*BuiltinFunction {\n\treturn append([]*BuiltinFunction{}, builtinFuncs...)\n}\n\nfunc builtinTypeName(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\treturn &String{Value: args[0].TypeName()}, nil\n}\n\nfunc builtinIsString(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*String); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsInt(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Int); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsFloat(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Float); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsBool(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Bool); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsChar(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Char); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsBytes(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Bytes); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsArray(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Array); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsImmutableArray(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*ImmutableArray); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsMap(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Map); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsImmutableMap(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*ImmutableMap); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsTime(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Time); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsError(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Error); ok {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsUndefined(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif args[0] == UndefinedValue {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsFunction(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tswitch args[0].(type) {\n\tcase *CompiledFunction:\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsCallable(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif args[0].CanCall() {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\nfunc builtinIsIterable(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif args[0].CanIterate() {\n\t\treturn TrueValue, nil\n\t}\n\treturn FalseValue, nil\n}\n\n// len(obj object) => int\nfunc builtinLen(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tswitch arg := args[0].(type) {\n\tcase *Array:\n\t\treturn &Int{Value: int64(len(arg.Value))}, nil\n\tcase *ImmutableArray:\n\t\treturn &Int{Value: int64(len(arg.Value))}, nil\n\tcase *String:\n\t\treturn &Int{Value: int64(len(arg.Value))}, nil\n\tcase *Bytes:\n\t\treturn &Int{Value: int64(len(arg.Value))}, nil\n\tcase *Map:\n\t\treturn &Int{Value: int64(len(arg.Value))}, nil\n\tcase *ImmutableMap:\n\t\treturn &Int{Value: int64(len(arg.Value))}, nil\n\tdefault:\n\t\treturn nil, ErrInvalidArgumentType{\n\t\t\tName:     \"first\",\n\t\t\tExpected: \"array/string/bytes/map\",\n\t\t\tFound:    arg.TypeName(),\n\t\t}\n\t}\n}\n\n//range(start, stop[, step])\nfunc builtinRange(args ...Object) (Object, error) {\n\tnumArgs := len(args)\n\tif numArgs < 2 || numArgs > 3 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tvar start, stop, step *Int\n\n\tfor i, arg := range args {\n\t\tv, ok := args[i].(*Int)\n\t\tif !ok {\n\t\t\tvar name string\n\t\t\tswitch i {\n\t\t\tcase 0:\n\t\t\t\tname = \"start\"\n\t\t\tcase 1:\n\t\t\t\tname = \"stop\"\n\t\t\tcase 2:\n\t\t\t\tname = \"step\"\n\t\t\t}\n\n\t\t\treturn nil, ErrInvalidArgumentType{\n\t\t\t\tName:     name,\n\t\t\t\tExpected: \"int\",\n\t\t\t\tFound:    arg.TypeName(),\n\t\t\t}\n\t\t}\n\t\tif i == 2 && v.Value <= 0 {\n\t\t\treturn nil, ErrInvalidRangeStep\n\t\t}\n\t\tswitch i {\n\t\tcase 0:\n\t\t\tstart = v\n\t\tcase 1:\n\t\t\tstop = v\n\t\tcase 2:\n\t\t\tstep = v\n\t\t}\n\t}\n\n\tif step == nil {\n\t\tstep = &Int{Value: int64(1)}\n\t}\n\n\treturn buildRange(start.Value, stop.Value, step.Value), nil\n}\n\nfunc buildRange(start, stop, step int64) *Array {\n\tarray := &Array{}\n\tif start <= stop {\n\t\tfor i := start; i < stop; i += step {\n\t\t\tarray.Value = append(array.Value, &Int{\n\t\t\t\tValue: i,\n\t\t\t})\n\t\t}\n\t} else {\n\t\tfor i := start; i > stop; i -= step {\n\t\t\tarray.Value = append(array.Value, &Int{\n\t\t\t\tValue: i,\n\t\t\t})\n\t\t}\n\t}\n\treturn array\n}\n\nfunc builtinFormat(args ...Object) (Object, error) {\n\tnumArgs := len(args)\n\tif numArgs == 0 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tformat, ok := args[0].(*String)\n\tif !ok {\n\t\treturn nil, ErrInvalidArgumentType{\n\t\t\tName:     \"format\",\n\t\t\tExpected: \"string\",\n\t\t\tFound:    args[0].TypeName(),\n\t\t}\n\t}\n\tif numArgs == 1 {\n\t\t// okay to return 'format' directly as String is immutable\n\t\treturn format, nil\n\t}\n\ts, err := Format(format.Value, args[1:]...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &String{Value: s}, nil\n}\n\nfunc builtinCopy(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\treturn args[0].Copy(), nil\n}\n\nfunc builtinString(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif !(argsLen == 1 || argsLen == 2) {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*String); ok {\n\t\treturn args[0], nil\n\t}\n\tv, ok := ToString(args[0])\n\tif ok {\n\t\tif len(v) > MaxStringLen {\n\t\t\treturn nil, ErrStringLimit\n\t\t}\n\t\treturn &String{Value: v}, nil\n\t}\n\tif argsLen == 2 {\n\t\treturn args[1], nil\n\t}\n\treturn UndefinedValue, nil\n}\n\nfunc builtinInt(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif !(argsLen == 1 || argsLen == 2) {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Int); ok {\n\t\treturn args[0], nil\n\t}\n\tv, ok := ToInt64(args[0])\n\tif ok {\n\t\treturn &Int{Value: v}, nil\n\t}\n\tif argsLen == 2 {\n\t\treturn args[1], nil\n\t}\n\treturn UndefinedValue, nil\n}\n\nfunc builtinFloat(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif !(argsLen == 1 || argsLen == 2) {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Float); ok {\n\t\treturn args[0], nil\n\t}\n\tv, ok := ToFloat64(args[0])\n\tif ok {\n\t\treturn &Float{Value: v}, nil\n\t}\n\tif argsLen == 2 {\n\t\treturn args[1], nil\n\t}\n\treturn UndefinedValue, nil\n}\n\nfunc builtinBool(args ...Object) (Object, error) {\n\tif len(args) != 1 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Bool); ok {\n\t\treturn args[0], nil\n\t}\n\tv, ok := ToBool(args[0])\n\tif ok {\n\t\tif v {\n\t\t\treturn TrueValue, nil\n\t\t}\n\t\treturn FalseValue, nil\n\t}\n\treturn UndefinedValue, nil\n}\n\nfunc builtinChar(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif !(argsLen == 1 || argsLen == 2) {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Char); ok {\n\t\treturn args[0], nil\n\t}\n\tv, ok := ToRune(args[0])\n\tif ok {\n\t\treturn &Char{Value: v}, nil\n\t}\n\tif argsLen == 2 {\n\t\treturn args[1], nil\n\t}\n\treturn UndefinedValue, nil\n}\n\nfunc builtinBytes(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif !(argsLen == 1 || argsLen == 2) {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\n\t// bytes(N) => create a new bytes with given size N\n\tif n, ok := args[0].(*Int); ok {\n\t\tif n.Value > int64(MaxBytesLen) {\n\t\t\treturn nil, ErrBytesLimit\n\t\t}\n\t\treturn &Bytes{Value: make([]byte, int(n.Value))}, nil\n\t}\n\tv, ok := ToByteSlice(args[0])\n\tif ok {\n\t\tif len(v) > MaxBytesLen {\n\t\t\treturn nil, ErrBytesLimit\n\t\t}\n\t\treturn &Bytes{Value: v}, nil\n\t}\n\tif argsLen == 2 {\n\t\treturn args[1], nil\n\t}\n\treturn UndefinedValue, nil\n}\n\nfunc builtinTime(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif !(argsLen == 1 || argsLen == 2) {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tif _, ok := args[0].(*Time); ok {\n\t\treturn args[0], nil\n\t}\n\tv, ok := ToTime(args[0])\n\tif ok {\n\t\treturn &Time{Value: v}, nil\n\t}\n\tif argsLen == 2 {\n\t\treturn args[1], nil\n\t}\n\treturn UndefinedValue, nil\n}\n\n// append(arr, items...)\nfunc builtinAppend(args ...Object) (Object, error) {\n\tif len(args) < 2 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tswitch arg := args[0].(type) {\n\tcase *Array:\n\t\treturn &Array{Value: append(arg.Value, args[1:]...)}, nil\n\tcase *ImmutableArray:\n\t\treturn &Array{Value: append(arg.Value, args[1:]...)}, nil\n\tdefault:\n\t\treturn nil, ErrInvalidArgumentType{\n\t\t\tName:     \"first\",\n\t\t\tExpected: \"array\",\n\t\t\tFound:    arg.TypeName(),\n\t\t}\n\t}\n}\n\n// builtinDelete deletes Map keys\n// usage: delete(map, \"key\")\n// key must be a string\nfunc builtinDelete(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif argsLen != 2 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\tswitch arg := args[0].(type) {\n\tcase *Map:\n\t\tif key, ok := args[1].(*String); ok {\n\t\t\tdelete(arg.Value, key.Value)\n\t\t\treturn UndefinedValue, nil\n\t\t}\n\t\treturn nil, ErrInvalidArgumentType{\n\t\t\tName:     \"second\",\n\t\t\tExpected: \"string\",\n\t\t\tFound:    args[1].TypeName(),\n\t\t}\n\tdefault:\n\t\treturn nil, ErrInvalidArgumentType{\n\t\t\tName:     \"first\",\n\t\t\tExpected: \"map\",\n\t\t\tFound:    arg.TypeName(),\n\t\t}\n\t}\n}\n\n// builtinSplice deletes and changes given Array, returns deleted items.\n// usage:\n// deleted_items := splice(array[,start[,delete_count[,item1[,item2[,...]]]])\nfunc builtinSplice(args ...Object) (Object, error) {\n\targsLen := len(args)\n\tif argsLen == 0 {\n\t\treturn nil, ErrWrongNumArguments\n\t}\n\n\tarray, ok := args[0].(*Array)\n\tif !ok {\n\t\treturn nil, ErrInvalidArgumentType{\n\t\t\tName:     \"first\",\n\t\t\tExpected: \"array\",\n\t\t\tFound:    args[0].TypeName(),\n\t\t}\n\t}\n\tarrayLen := len(array.Value)\n\n\tvar startIdx int\n\tif argsLen > 1 {\n\t\targ1, ok := args[1].(*Int)\n\t\tif !ok {\n\t\t\treturn nil, ErrInvalidArgumentType{\n\t\t\t\tName:     \"second\",\n\t\t\t\tExpected: \"int\",\n\t\t\t\tFound:    args[1].TypeName(),\n\t\t\t}\n\t\t}\n\t\tstartIdx = int(arg1.Value)\n\t\tif startIdx < 0 || startIdx > arrayLen {\n\t\t\treturn nil, ErrIndexOutOfBounds\n\t\t}\n\t}\n\n\tdelCount := len(array.Value)\n\tif argsLen > 2 {\n\t\targ2, ok := args[2].(*Int)\n\t\tif !ok {\n\t\t\treturn nil, ErrInvalidArgumentType{\n\t\t\t\tName:     \"third\",\n\t\t\t\tExpected: \"int\",\n\t\t\t\tFound:    args[2].TypeName(),\n\t\t\t}\n\t\t}\n\t\tdelCount = int(arg2.Value)\n\t\tif delCount < 0 {\n\t\t\treturn nil, ErrIndexOutOfBounds\n\t\t}\n\t}\n\t// if count of to be deleted items is bigger than expected, truncate it\n\tif startIdx+delCount > arrayLen {\n\t\tdelCount = arrayLen - startIdx\n\t}\n\t// delete items\n\tendIdx := startIdx + delCount\n\tdeleted := append([]Object{}, array.Value[startIdx:endIdx]...)\n\n\thead := array.Value[:startIdx]\n\tvar items []Object\n\tif argsLen > 3 {\n\t\titems = make([]Object, 0, argsLen-3)\n\t\tfor i := 3; i < argsLen; i++ {\n\t\t\titems = append(items, args[i])\n\t\t}\n\t}\n\titems = append(items, array.Value[endIdx:]...)\n\tarray.Value = append(head, items...)\n\n\t// return deleted items\n\treturn &Array{Value: deleted}, nil\n}\n"
        },
        {
          "name": "builtins_test.go",
          "type": "blob",
          "size": 13.8447265625,
          "content": "package tengo_test\n\nimport (\n\t\"errors\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n)\n\nfunc Test_builtinDelete(t *testing.T) {\n\tvar builtinDelete func(args ...tengo.Object) (tengo.Object, error)\n\tfor _, f := range tengo.GetAllBuiltinFunctions() {\n\t\tif f.Name == \"delete\" {\n\t\t\tbuiltinDelete = f.Value\n\t\t\tbreak\n\t\t}\n\t}\n\tif builtinDelete == nil {\n\t\tt.Fatal(\"builtin delete not found\")\n\t}\n\ttype args struct {\n\t\targs []tengo.Object\n\t}\n\ttests := []struct {\n\t\tname      string\n\t\targs      args\n\t\twant      tengo.Object\n\t\twantErr   bool\n\t\twantedErr error\n\t\ttarget    interface{}\n\t}{\n\t\t{name: \"invalid-arg\", args: args{[]tengo.Object{&tengo.String{},\n\t\t\t&tengo.String{}}}, wantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName:     \"first\",\n\t\t\t\tExpected: \"map\",\n\t\t\t\tFound:    \"string\"},\n\t\t},\n\t\t{name: \"no-args\",\n\t\t\twantErr: true, wantedErr: tengo.ErrWrongNumArguments},\n\t\t{name: \"empty-args\", args: args{[]tengo.Object{}}, wantErr: true,\n\t\t\twantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"3-args\", args: args{[]tengo.Object{\n\t\t\t(*tengo.Map)(nil), (*tengo.String)(nil), (*tengo.String)(nil)}},\n\t\t\twantErr: true, wantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"nil-map-empty-key\",\n\t\t\targs: args{[]tengo.Object{&tengo.Map{}, &tengo.String{}}},\n\t\t\twant: tengo.UndefinedValue,\n\t\t},\n\t\t{name: \"nil-map-nonstr-key\",\n\t\t\targs: args{[]tengo.Object{\n\t\t\t\t&tengo.Map{}, &tengo.Int{}}}, wantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"second\", Expected: \"string\", Found: \"int\"},\n\t\t},\n\t\t{name: \"nil-map-no-key\",\n\t\t\targs: args{[]tengo.Object{&tengo.Map{}}}, wantErr: true,\n\t\t\twantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"map-missing-key\",\n\t\t\targs: args{\n\t\t\t\t[]tengo.Object{\n\t\t\t\t\t&tengo.Map{Value: map[string]tengo.Object{\n\t\t\t\t\t\t\"key\": &tengo.String{Value: \"value\"},\n\t\t\t\t\t}},\n\t\t\t\t\t&tengo.String{Value: \"key1\"}}},\n\t\t\twant: tengo.UndefinedValue,\n\t\t\ttarget: &tengo.Map{\n\t\t\t\tValue: map[string]tengo.Object{\n\t\t\t\t\t\"key\": &tengo.String{\n\t\t\t\t\t\tValue: \"value\"}}},\n\t\t},\n\t\t{name: \"map-emptied\",\n\t\t\targs: args{\n\t\t\t\t[]tengo.Object{\n\t\t\t\t\t&tengo.Map{Value: map[string]tengo.Object{\n\t\t\t\t\t\t\"key\": &tengo.String{Value: \"value\"},\n\t\t\t\t\t}},\n\t\t\t\t\t&tengo.String{Value: \"key\"}}},\n\t\t\twant:   tengo.UndefinedValue,\n\t\t\ttarget: &tengo.Map{Value: map[string]tengo.Object{}},\n\t\t},\n\t\t{name: \"map-multi-keys\",\n\t\t\targs: args{\n\t\t\t\t[]tengo.Object{\n\t\t\t\t\t&tengo.Map{Value: map[string]tengo.Object{\n\t\t\t\t\t\t\"key1\": &tengo.String{Value: \"value1\"},\n\t\t\t\t\t\t\"key2\": &tengo.Int{Value: 10},\n\t\t\t\t\t}},\n\t\t\t\t\t&tengo.String{Value: \"key1\"}}},\n\t\t\twant: tengo.UndefinedValue,\n\t\t\ttarget: &tengo.Map{Value: map[string]tengo.Object{\n\t\t\t\t\"key2\": &tengo.Int{Value: 10}}},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := builtinDelete(tt.args.args...)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"builtinDelete() error = %v, wantErr %v\",\n\t\t\t\t\terr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr && !errors.Is(err, tt.wantedErr) {\n\t\t\t\tif err.Error() != tt.wantedErr.Error() {\n\t\t\t\t\tt.Errorf(\"builtinDelete() error = %v, wantedErr %v\",\n\t\t\t\t\t\terr, tt.wantedErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"builtinDelete() = %v, want %v\", got, tt.want)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !tt.wantErr && tt.target != nil {\n\t\t\t\tswitch v := tt.args.args[0].(type) {\n\t\t\t\tcase *tengo.Map, *tengo.Array:\n\t\t\t\t\tif !reflect.DeepEqual(tt.target, tt.args.args[0]) {\n\t\t\t\t\t\tt.Errorf(\"builtinDelete() objects are not equal \"+\n\t\t\t\t\t\t\t\"got: %+v, want: %+v\", tt.args.args[0], tt.target)\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tt.Errorf(\"builtinDelete() unsuporrted arg[0] type %s\",\n\t\t\t\t\t\tv.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_builtinSplice(t *testing.T) {\n\tvar builtinSplice func(args ...tengo.Object) (tengo.Object, error)\n\tfor _, f := range tengo.GetAllBuiltinFunctions() {\n\t\tif f.Name == \"splice\" {\n\t\t\tbuiltinSplice = f.Value\n\t\t\tbreak\n\t\t}\n\t}\n\tif builtinSplice == nil {\n\t\tt.Fatal(\"builtin splice not found\")\n\t}\n\ttests := []struct {\n\t\tname      string\n\t\targs      []tengo.Object\n\t\tdeleted   tengo.Object\n\t\tArray     *tengo.Array\n\t\twantErr   bool\n\t\twantedErr error\n\t}{\n\t\t{name: \"no args\", args: []tengo.Object{}, wantErr: true,\n\t\t\twantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"invalid args\", args: []tengo.Object{&tengo.Map{}},\n\t\t\twantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"first\", Expected: \"array\", Found: \"map\"},\n\t\t},\n\t\t{name: \"invalid args\",\n\t\t\targs:    []tengo.Object{&tengo.Array{}, &tengo.String{}},\n\t\t\twantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"second\", Expected: \"int\", Found: \"string\"},\n\t\t},\n\t\t{name: \"negative index\",\n\t\t\targs:      []tengo.Object{&tengo.Array{}, &tengo.Int{Value: -1}},\n\t\t\twantErr:   true,\n\t\t\twantedErr: tengo.ErrIndexOutOfBounds},\n\t\t{name: \"non int count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{}, &tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"\"}},\n\t\t\twantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"third\", Expected: \"int\", Found: \"string\"},\n\t\t},\n\t\t{name: \"negative count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: -1}},\n\t\t\twantErr:   true,\n\t\t\twantedErr: tengo.ErrIndexOutOfBounds,\n\t\t},\n\t\t{name: \"insert with zero count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"b\"}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.String{Value: \"b\"},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t},\n\t\t{name: \"insert\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t},\n\t\t{name: \"insert with zero count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t},\n\t\t{name: \"insert with delete\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"}},\n\t\t\tdeleted: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{&tengo.Int{Value: 1}}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t},\n\t\t{name: \"insert with delete multi\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2},\n\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t&tengo.String{Value: \"d\"}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\tArray: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.String{Value: \"c\"},\n\t\t\t\t\t&tengo.String{Value: \"d\"}}},\n\t\t},\n\t\t{name: \"delete all with positive count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 3}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{}},\n\t\t},\n\t\t{name: \"delete all with big count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 5}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{}},\n\t\t},\n\t\t{name: \"nothing2\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t},\n\t\t{name: \"pop without count\",\n\t\t\targs: []tengo.Object{\n\t\t\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t\t\t&tengo.Int{Value: 0},\n\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t&tengo.Int{Value: 2}}},\n\t\t\t\t&tengo.Int{Value: 2}},\n\t\t\tdeleted: &tengo.Array{Value: []tengo.Object{&tengo.Int{Value: 2}}},\n\t\t\tArray: &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 0}, &tengo.Int{Value: 1}}},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := builtinSplice(tt.args...)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"builtinSplice() error = %v, wantErr %v\",\n\t\t\t\t\terr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !reflect.DeepEqual(got, tt.deleted) {\n\t\t\t\tt.Errorf(\"builtinSplice() = %v, want %v\", got, tt.deleted)\n\t\t\t}\n\t\t\tif tt.wantErr && tt.wantedErr.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"builtinSplice() error = %v, wantedErr %v\",\n\t\t\t\t\terr, tt.wantedErr)\n\t\t\t}\n\t\t\tif tt.Array != nil && !reflect.DeepEqual(tt.Array, tt.args[0]) {\n\t\t\t\tt.Errorf(\"builtinSplice() arrays are not equal expected\"+\n\t\t\t\t\t\" %s, got %s\", tt.Array, tt.args[0].(*tengo.Array))\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_builtinRange(t *testing.T) {\n\tvar builtinRange func(args ...tengo.Object) (tengo.Object, error)\n\tfor _, f := range tengo.GetAllBuiltinFunctions() {\n\t\tif f.Name == \"range\" {\n\t\t\tbuiltinRange = f.Value\n\t\t\tbreak\n\t\t}\n\t}\n\tif builtinRange == nil {\n\t\tt.Fatal(\"builtin range not found\")\n\t}\n\ttests := []struct {\n\t\tname      string\n\t\targs      []tengo.Object\n\t\tresult    *tengo.Array\n\t\twantErr   bool\n\t\twantedErr error\n\t}{\n\t\t{name: \"no args\", args: []tengo.Object{}, wantErr: true,\n\t\t\twantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"single args\", args: []tengo.Object{&tengo.Map{}},\n\t\t\twantErr:   true,\n\t\t\twantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"4 args\", args: []tengo.Object{&tengo.Map{}, &tengo.String{}, &tengo.String{}, &tengo.String{}},\n\t\t\twantErr:   true,\n\t\t\twantedErr: tengo.ErrWrongNumArguments,\n\t\t},\n\t\t{name: \"invalid start\",\n\t\t\targs:    []tengo.Object{&tengo.String{}, &tengo.String{}},\n\t\t\twantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"start\", Expected: \"int\", Found: \"string\"},\n\t\t},\n\t\t{name: \"invalid stop\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.String{}},\n\t\t\twantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"stop\", Expected: \"int\", Found: \"string\"},\n\t\t},\n\t\t{name: \"invalid step\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.Int{}, &tengo.String{}},\n\t\t\twantErr: true,\n\t\t\twantedErr: tengo.ErrInvalidArgumentType{\n\t\t\t\tName: \"step\", Expected: \"int\", Found: \"string\"},\n\t\t},\n\t\t{name: \"zero step\",\n\t\t\targs:      []tengo.Object{&tengo.Int{}, &tengo.Int{}, &tengo.Int{}}, //must greate than 0\n\t\t\twantErr:   true,\n\t\t\twantedErr: tengo.ErrInvalidRangeStep,\n\t\t},\n\t\t{name: \"negative step\",\n\t\t\targs:      []tengo.Object{&tengo.Int{}, &tengo.Int{}, intObject(-2)}, //must greate than 0\n\t\t\twantErr:   true,\n\t\t\twantedErr: tengo.ErrInvalidRangeStep,\n\t\t},\n\t\t{name: \"same bound\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.Int{}},\n\t\t\twantErr: false,\n\t\t\tresult: &tengo.Array{\n\t\t\t\tValue: nil,\n\t\t\t},\n\t\t},\n\t\t{name: \"positive range\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.Int{Value: 5}},\n\t\t\twantErr: false,\n\t\t\tresult: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\tintObject(0),\n\t\t\t\t\tintObject(1),\n\t\t\t\t\tintObject(2),\n\t\t\t\t\tintObject(3),\n\t\t\t\t\tintObject(4),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{name: \"negative range\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.Int{Value: -5}},\n\t\t\twantErr: false,\n\t\t\tresult: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\tintObject(0),\n\t\t\t\t\tintObject(-1),\n\t\t\t\t\tintObject(-2),\n\t\t\t\t\tintObject(-3),\n\t\t\t\t\tintObject(-4),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t{name: \"positive with step\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.Int{Value: 5}, &tengo.Int{Value: 2}},\n\t\t\twantErr: false,\n\t\t\tresult: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\tintObject(0),\n\t\t\t\t\tintObject(2),\n\t\t\t\t\tintObject(4),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t{name: \"negative with step\",\n\t\t\targs:    []tengo.Object{&tengo.Int{}, &tengo.Int{Value: -10}, &tengo.Int{Value: 2}},\n\t\t\twantErr: false,\n\t\t\tresult: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\tintObject(0),\n\t\t\t\t\tintObject(-2),\n\t\t\t\t\tintObject(-4),\n\t\t\t\t\tintObject(-6),\n\t\t\t\t\tintObject(-8),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t{name: \"large range\",\n\t\t\targs:    []tengo.Object{intObject(-10), intObject(10), &tengo.Int{Value: 3}},\n\t\t\twantErr: false,\n\t\t\tresult: &tengo.Array{\n\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\tintObject(-10),\n\t\t\t\t\tintObject(-7),\n\t\t\t\t\tintObject(-4),\n\t\t\t\t\tintObject(-1),\n\t\t\t\t\tintObject(2),\n\t\t\t\t\tintObject(5),\n\t\t\t\t\tintObject(8),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := builtinRange(tt.args...)\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"builtinRange() error = %v, wantErr %v\",\n\t\t\t\t\terr, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif tt.wantErr && tt.wantedErr.Error() != err.Error() {\n\t\t\t\tt.Errorf(\"builtinRange() error = %v, wantedErr %v\",\n\t\t\t\t\terr, tt.wantedErr)\n\t\t\t}\n\t\t\tif tt.result != nil && !reflect.DeepEqual(tt.result, got) {\n\t\t\t\tt.Errorf(\"builtinRange() arrays are not equal expected\"+\n\t\t\t\t\t\" %s, got %s\", tt.result, got.(*tengo.Array))\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "bytecode.go",
          "type": "blob",
          "size": 7.0830078125,
          "content": "package tengo\n\nimport (\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\n\t\"github.com/d5/tengo/v2/parser\"\n)\n\n// Bytecode is a compiled instructions and constants.\ntype Bytecode struct {\n\tFileSet      *parser.SourceFileSet\n\tMainFunction *CompiledFunction\n\tConstants    []Object\n}\n\n// Encode writes Bytecode data to the writer.\nfunc (b *Bytecode) Encode(w io.Writer) error {\n\tenc := gob.NewEncoder(w)\n\tif err := enc.Encode(b.FileSet); err != nil {\n\t\treturn err\n\t}\n\tif err := enc.Encode(b.MainFunction); err != nil {\n\t\treturn err\n\t}\n\treturn enc.Encode(b.Constants)\n}\n\n// CountObjects returns the number of objects found in Constants.\nfunc (b *Bytecode) CountObjects() int {\n\tn := 0\n\tfor _, c := range b.Constants {\n\t\tn += CountObjects(c)\n\t}\n\treturn n\n}\n\n// FormatInstructions returns human readable string representations of\n// compiled instructions.\nfunc (b *Bytecode) FormatInstructions() []string {\n\treturn FormatInstructions(b.MainFunction.Instructions, 0)\n}\n\n// FormatConstants returns human readable string representations of\n// compiled constants.\nfunc (b *Bytecode) FormatConstants() (output []string) {\n\tfor cidx, cn := range b.Constants {\n\t\tswitch cn := cn.(type) {\n\t\tcase *CompiledFunction:\n\t\t\toutput = append(output, fmt.Sprintf(\n\t\t\t\t\"[% 3d] (Compiled Function|%p)\", cidx, &cn))\n\t\t\tfor _, l := range FormatInstructions(cn.Instructions, 0) {\n\t\t\t\toutput = append(output, fmt.Sprintf(\"     %s\", l))\n\t\t\t}\n\t\tdefault:\n\t\t\toutput = append(output, fmt.Sprintf(\"[% 3d] %s (%s|%p)\",\n\t\t\t\tcidx, cn, reflect.TypeOf(cn).Elem().Name(), &cn))\n\t\t}\n\t}\n\treturn\n}\n\n// Decode reads Bytecode data from the reader.\nfunc (b *Bytecode) Decode(r io.Reader, modules *ModuleMap) error {\n\tif modules == nil {\n\t\tmodules = NewModuleMap()\n\t}\n\n\tdec := gob.NewDecoder(r)\n\tif err := dec.Decode(&b.FileSet); err != nil {\n\t\treturn err\n\t}\n\t// TODO: files in b.FileSet.File does not have their 'set' field properly\n\t//  set to b.FileSet as it's private field and not serialized by gob\n\t//  encoder/decoder.\n\tif err := dec.Decode(&b.MainFunction); err != nil {\n\t\treturn err\n\t}\n\tif err := dec.Decode(&b.Constants); err != nil {\n\t\treturn err\n\t}\n\tfor i, v := range b.Constants {\n\t\tfv, err := fixDecodedObject(v, modules)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tb.Constants[i] = fv\n\t}\n\treturn nil\n}\n\n// RemoveDuplicates finds and remove the duplicate values in Constants.\n// Note this function mutates Bytecode.\nfunc (b *Bytecode) RemoveDuplicates() {\n\tvar deduped []Object\n\n\tindexMap := make(map[int]int) // mapping from old constant index to new index\n\tfns := make(map[*CompiledFunction]int)\n\tints := make(map[int64]int)\n\tstrings := make(map[string]int)\n\tfloats := make(map[float64]int)\n\tchars := make(map[rune]int)\n\timmutableMaps := make(map[string]int) // for modules\n\n\tfor curIdx, c := range b.Constants {\n\t\tswitch c := c.(type) {\n\t\tcase *CompiledFunction:\n\t\t\tif newIdx, ok := fns[c]; ok {\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t} else {\n\t\t\t\tnewIdx = len(deduped)\n\t\t\t\tfns[c] = newIdx\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t\tdeduped = append(deduped, c)\n\t\t\t}\n\t\tcase *ImmutableMap:\n\t\t\tmodName := inferModuleName(c)\n\t\t\tnewIdx, ok := immutableMaps[modName]\n\t\t\tif modName != \"\" && ok {\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t} else {\n\t\t\t\tnewIdx = len(deduped)\n\t\t\t\timmutableMaps[modName] = newIdx\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t\tdeduped = append(deduped, c)\n\t\t\t}\n\t\tcase *Int:\n\t\t\tif newIdx, ok := ints[c.Value]; ok {\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t} else {\n\t\t\t\tnewIdx = len(deduped)\n\t\t\t\tints[c.Value] = newIdx\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t\tdeduped = append(deduped, c)\n\t\t\t}\n\t\tcase *String:\n\t\t\tif newIdx, ok := strings[c.Value]; ok {\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t} else {\n\t\t\t\tnewIdx = len(deduped)\n\t\t\t\tstrings[c.Value] = newIdx\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t\tdeduped = append(deduped, c)\n\t\t\t}\n\t\tcase *Float:\n\t\t\tif newIdx, ok := floats[c.Value]; ok {\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t} else {\n\t\t\t\tnewIdx = len(deduped)\n\t\t\t\tfloats[c.Value] = newIdx\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t\tdeduped = append(deduped, c)\n\t\t\t}\n\t\tcase *Char:\n\t\t\tif newIdx, ok := chars[c.Value]; ok {\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t} else {\n\t\t\t\tnewIdx = len(deduped)\n\t\t\t\tchars[c.Value] = newIdx\n\t\t\t\tindexMap[curIdx] = newIdx\n\t\t\t\tdeduped = append(deduped, c)\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(fmt.Errorf(\"unsupported top-level constant type: %s\",\n\t\t\t\tc.TypeName()))\n\t\t}\n\t}\n\n\t// replace with de-duplicated constants\n\tb.Constants = deduped\n\n\t// update CONST instructions with new indexes\n\t// main function\n\tupdateConstIndexes(b.MainFunction.Instructions, indexMap)\n\t// other compiled functions in constants\n\tfor _, c := range b.Constants {\n\t\tswitch c := c.(type) {\n\t\tcase *CompiledFunction:\n\t\t\tupdateConstIndexes(c.Instructions, indexMap)\n\t\t}\n\t}\n}\n\nfunc fixDecodedObject(\n\to Object,\n\tmodules *ModuleMap,\n) (Object, error) {\n\tswitch o := o.(type) {\n\tcase *Bool:\n\t\tif o.IsFalsy() {\n\t\t\treturn FalseValue, nil\n\t\t}\n\t\treturn TrueValue, nil\n\tcase *Undefined:\n\t\treturn UndefinedValue, nil\n\tcase *Array:\n\t\tfor i, v := range o.Value {\n\t\t\tfv, err := fixDecodedObject(v, modules)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\to.Value[i] = fv\n\t\t}\n\tcase *ImmutableArray:\n\t\tfor i, v := range o.Value {\n\t\t\tfv, err := fixDecodedObject(v, modules)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\to.Value[i] = fv\n\t\t}\n\tcase *Map:\n\t\tfor k, v := range o.Value {\n\t\t\tfv, err := fixDecodedObject(v, modules)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\to.Value[k] = fv\n\t\t}\n\tcase *ImmutableMap:\n\t\tmodName := inferModuleName(o)\n\t\tif mod := modules.GetBuiltinModule(modName); mod != nil {\n\t\t\treturn mod.AsImmutableMap(modName), nil\n\t\t}\n\n\t\tfor k, v := range o.Value {\n\t\t\t// encoding of user function not supported\n\t\t\tif _, isUserFunction := v.(*UserFunction); isUserFunction {\n\t\t\t\treturn nil, fmt.Errorf(\"user function not decodable\")\n\t\t\t}\n\n\t\t\tfv, err := fixDecodedObject(v, modules)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\to.Value[k] = fv\n\t\t}\n\t}\n\treturn o, nil\n}\n\nfunc updateConstIndexes(insts []byte, indexMap map[int]int) {\n\ti := 0\n\tfor i < len(insts) {\n\t\top := insts[i]\n\t\tnumOperands := parser.OpcodeOperands[op]\n\t\t_, read := parser.ReadOperands(numOperands, insts[i+1:])\n\n\t\tswitch op {\n\t\tcase parser.OpConstant:\n\t\t\tcurIdx := int(insts[i+2]) | int(insts[i+1])<<8\n\t\t\tnewIdx, ok := indexMap[curIdx]\n\t\t\tif !ok {\n\t\t\t\tpanic(fmt.Errorf(\"constant index not found: %d\", curIdx))\n\t\t\t}\n\t\t\tcopy(insts[i:], MakeInstruction(op, newIdx))\n\t\tcase parser.OpClosure:\n\t\t\tcurIdx := int(insts[i+2]) | int(insts[i+1])<<8\n\t\t\tnumFree := int(insts[i+3])\n\t\t\tnewIdx, ok := indexMap[curIdx]\n\t\t\tif !ok {\n\t\t\t\tpanic(fmt.Errorf(\"constant index not found: %d\", curIdx))\n\t\t\t}\n\t\t\tcopy(insts[i:], MakeInstruction(op, newIdx, numFree))\n\t\t}\n\n\t\ti += 1 + read\n\t}\n}\n\nfunc inferModuleName(mod *ImmutableMap) string {\n\tif modName, ok := mod.Value[\"__module_name__\"].(*String); ok {\n\t\treturn modName.Value\n\t}\n\treturn \"\"\n}\n\nfunc init() {\n\tgob.Register(&parser.SourceFileSet{})\n\tgob.Register(&parser.SourceFile{})\n\tgob.Register(&Array{})\n\tgob.Register(&Bool{})\n\tgob.Register(&Bytes{})\n\tgob.Register(&Char{})\n\tgob.Register(&CompiledFunction{})\n\tgob.Register(&Error{})\n\tgob.Register(&Float{})\n\tgob.Register(&ImmutableArray{})\n\tgob.Register(&ImmutableMap{})\n\tgob.Register(&Int{})\n\tgob.Register(&Map{})\n\tgob.Register(&String{})\n\tgob.Register(&Time{})\n\tgob.Register(&Undefined{})\n\tgob.Register(&UserFunction{})\n}\n"
        },
        {
          "name": "bytecode_test.go",
          "type": "blob",
          "size": 9.21875,
          "content": "package tengo_test\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/require\"\n)\n\ntype srcfile struct {\n\tname string\n\tsize int\n}\n\nfunc TestBytecode(t *testing.T) {\n\ttestBytecodeSerialization(t, bytecode(concatInsts(), objectsArray()))\n\n\ttestBytecodeSerialization(t, bytecode(\n\t\tconcatInsts(), objectsArray(\n\t\t\t&tengo.Char{Value: 'y'},\n\t\t\t&tengo.Float{Value: 93.11},\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0)),\n\t\t\t&tengo.Float{Value: 39.2},\n\t\t\t&tengo.Int{Value: 192},\n\t\t\t&tengo.String{Value: \"bar\"})))\n\n\ttestBytecodeSerialization(t, bytecodeFileSet(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 6),\n\t\t\ttengo.MakeInstruction(parser.OpPop)),\n\t\tobjectsArray(\n\t\t\t&tengo.Int{Value: 55},\n\t\t\t&tengo.Int{Value: 66},\n\t\t\t&tengo.Int{Value: 77},\n\t\t\t&tengo.Int{Value: 88},\n\t\t\t&tengo.ImmutableMap{\n\t\t\t\tValue: map[string]tengo.Object{\n\t\t\t\t\t\"array\": &tengo.ImmutableArray{\n\t\t\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t\t\t&tengo.Int{Value: 2},\n\t\t\t\t\t\t\t&tengo.Int{Value: 3},\n\t\t\t\t\t\t\ttengo.TrueValue,\n\t\t\t\t\t\t\ttengo.FalseValue,\n\t\t\t\t\t\t\ttengo.UndefinedValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"true\":  tengo.TrueValue,\n\t\t\t\t\t\"false\": tengo.FalseValue,\n\t\t\t\t\t\"bytes\": &tengo.Bytes{Value: make([]byte, 16)},\n\t\t\t\t\t\"char\":  &tengo.Char{Value: 'Y'},\n\t\t\t\t\t\"error\": &tengo.Error{Value: &tengo.String{\n\t\t\t\t\t\tValue: \"some error\",\n\t\t\t\t\t}},\n\t\t\t\t\t\"float\": &tengo.Float{Value: -19.84},\n\t\t\t\t\t\"immutable_array\": &tengo.ImmutableArray{\n\t\t\t\t\t\tValue: []tengo.Object{\n\t\t\t\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t\t\t\t&tengo.Int{Value: 2},\n\t\t\t\t\t\t\t&tengo.Int{Value: 3},\n\t\t\t\t\t\t\ttengo.TrueValue,\n\t\t\t\t\t\t\ttengo.FalseValue,\n\t\t\t\t\t\t\ttengo.UndefinedValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"immutable_map\": &tengo.ImmutableMap{\n\t\t\t\t\t\tValue: map[string]tengo.Object{\n\t\t\t\t\t\t\t\"a\": &tengo.Int{Value: 1},\n\t\t\t\t\t\t\t\"b\": &tengo.Int{Value: 2},\n\t\t\t\t\t\t\t\"c\": &tengo.Int{Value: 3},\n\t\t\t\t\t\t\t\"d\": tengo.TrueValue,\n\t\t\t\t\t\t\t\"e\": tengo.FalseValue,\n\t\t\t\t\t\t\t\"f\": tengo.UndefinedValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"int\": &tengo.Int{Value: 91},\n\t\t\t\t\t\"map\": &tengo.Map{\n\t\t\t\t\t\tValue: map[string]tengo.Object{\n\t\t\t\t\t\t\t\"a\": &tengo.Int{Value: 1},\n\t\t\t\t\t\t\t\"b\": &tengo.Int{Value: 2},\n\t\t\t\t\t\t\t\"c\": &tengo.Int{Value: 3},\n\t\t\t\t\t\t\t\"d\": tengo.TrueValue,\n\t\t\t\t\t\t\t\"e\": tengo.FalseValue,\n\t\t\t\t\t\t\t\"f\": tengo.UndefinedValue,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t\"string\":    &tengo.String{Value: \"foo bar\"},\n\t\t\t\t\t\"time\":      &tengo.Time{Value: time.Now()},\n\t\t\t\t\t\"undefined\": tengo.UndefinedValue,\n\t\t\t\t},\n\t\t\t},\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 4, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 5, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1))),\n\t\tfileSet(srcfile{name: \"file1\", size: 100},\n\t\t\tsrcfile{name: \"file2\", size: 200})))\n}\n\nfunc TestBytecode_RemoveDuplicates(t *testing.T) {\n\ttestBytecodeRemoveDuplicates(t,\n\t\tbytecode(\n\t\t\tconcatInsts(), objectsArray(\n\t\t\t\t&tengo.Char{Value: 'y'},\n\t\t\t\t&tengo.Float{Value: 93.11},\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0)),\n\t\t\t\t&tengo.Float{Value: 39.2},\n\t\t\t\t&tengo.Int{Value: 192},\n\t\t\t\t&tengo.String{Value: \"bar\"})),\n\t\tbytecode(\n\t\t\tconcatInsts(), objectsArray(\n\t\t\t\t&tengo.Char{Value: 'y'},\n\t\t\t\t&tengo.Float{Value: 93.11},\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0)),\n\t\t\t\t&tengo.Float{Value: 39.2},\n\t\t\t\t&tengo.Int{Value: 192},\n\t\t\t\t&tengo.String{Value: \"bar\"})))\n\n\ttestBytecodeRemoveDuplicates(t,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 5),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 6),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 7),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 8),\n\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 4, 1)),\n\t\t\tobjectsArray(\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Float{Value: 2.0},\n\t\t\t\t&tengo.Char{Value: '3'},\n\t\t\t\t&tengo.String{Value: \"four\"},\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 7),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0)),\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Float{Value: 2.0},\n\t\t\t\t&tengo.Char{Value: '3'},\n\t\t\t\t&tengo.String{Value: \"four\"})),\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 4, 1)),\n\t\t\tobjectsArray(\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Float{Value: 2.0},\n\t\t\t\t&tengo.Char{Value: '3'},\n\t\t\t\t&tengo.String{Value: \"four\"},\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0)))))\n\n\ttestBytecodeRemoveDuplicates(t,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4)),\n\t\t\tobjectsArray(\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2},\n\t\t\t\t&tengo.Int{Value: 3},\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 3})),\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2)),\n\t\t\tobjectsArray(\n\t\t\t\t&tengo.Int{Value: 1},\n\t\t\t\t&tengo.Int{Value: 2},\n\t\t\t\t&tengo.Int{Value: 3})))\n}\n\nfunc TestBytecode_CountObjects(t *testing.T) {\n\tb := bytecode(\n\t\tconcatInsts(),\n\t\tobjectsArray(\n\t\t\t&tengo.Int{Value: 55},\n\t\t\t&tengo.Int{Value: 66},\n\t\t\t&tengo.Int{Value: 77},\n\t\t\t&tengo.Int{Value: 88},\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\tcompiledFunction(1, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1))))\n\trequire.Equal(t, 7, b.CountObjects())\n}\n\nfunc fileSet(files ...srcfile) *parser.SourceFileSet {\n\tfileSet := parser.NewFileSet()\n\tfor _, f := range files {\n\t\tfileSet.AddFile(f.name, -1, f.size)\n\t}\n\treturn fileSet\n}\n\nfunc bytecodeFileSet(\n\tinstructions []byte,\n\tconstants []tengo.Object,\n\tfileSet *parser.SourceFileSet,\n) *tengo.Bytecode {\n\treturn &tengo.Bytecode{\n\t\tFileSet:      fileSet,\n\t\tMainFunction: &tengo.CompiledFunction{Instructions: instructions},\n\t\tConstants:    constants,\n\t}\n}\n\nfunc testBytecodeRemoveDuplicates(\n\tt *testing.T,\n\tinput, expected *tengo.Bytecode,\n) {\n\tinput.RemoveDuplicates()\n\n\trequire.Equal(t, expected.FileSet, input.FileSet)\n\trequire.Equal(t, expected.MainFunction, input.MainFunction)\n\trequire.Equal(t, expected.Constants, input.Constants)\n}\n\nfunc testBytecodeSerialization(t *testing.T, b *tengo.Bytecode) {\n\tvar buf bytes.Buffer\n\terr := b.Encode(&buf)\n\trequire.NoError(t, err)\n\n\tr := &tengo.Bytecode{}\n\terr = r.Decode(bytes.NewReader(buf.Bytes()), nil)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, b.FileSet, r.FileSet)\n\trequire.Equal(t, b.MainFunction, r.MainFunction)\n\trequire.Equal(t, b.Constants, r.Constants)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "compiler.go",
          "type": "blob",
          "size": 33.41796875,
          "content": "package tengo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/token\"\n)\n\n// compilationScope represents a compiled instructions and the last two\n// instructions that were emitted.\ntype compilationScope struct {\n\tInstructions []byte\n\tSymbolInit   map[string]bool\n\tSourceMap    map[int]parser.Pos\n}\n\n// loop represents a loop construct that the compiler uses to track the current\n// loop.\ntype loop struct {\n\tContinues []int\n\tBreaks    []int\n}\n\n// CompilerError represents a compiler error.\ntype CompilerError struct {\n\tFileSet *parser.SourceFileSet\n\tNode    parser.Node\n\tErr     error\n}\n\nfunc (e *CompilerError) Error() string {\n\tfilePos := e.FileSet.Position(e.Node.Pos())\n\treturn fmt.Sprintf(\"Compile Error: %s\\n\\tat %s\", e.Err.Error(), filePos)\n}\n\n// Compiler compiles the AST into a bytecode.\ntype Compiler struct {\n\tfile            *parser.SourceFile\n\tparent          *Compiler\n\tmodulePath      string\n\timportDir       string\n\timportFileExt   []string\n\tconstants       []Object\n\tsymbolTable     *SymbolTable\n\tscopes          []compilationScope\n\tscopeIndex      int\n\tmodules         ModuleGetter\n\tcompiledModules map[string]*CompiledFunction\n\tallowFileImport bool\n\tloops           []*loop\n\tloopIndex       int\n\ttrace           io.Writer\n\tindent          int\n}\n\n// NewCompiler creates a Compiler.\nfunc NewCompiler(\n\tfile *parser.SourceFile,\n\tsymbolTable *SymbolTable,\n\tconstants []Object,\n\tmodules ModuleGetter,\n\ttrace io.Writer,\n) *Compiler {\n\tmainScope := compilationScope{\n\t\tSymbolInit: make(map[string]bool),\n\t\tSourceMap:  make(map[int]parser.Pos),\n\t}\n\n\t// symbol table\n\tif symbolTable == nil {\n\t\tsymbolTable = NewSymbolTable()\n\t}\n\n\t// add builtin functions to the symbol table\n\tfor idx, fn := range builtinFuncs {\n\t\tsymbolTable.DefineBuiltin(idx, fn.Name)\n\t}\n\n\t// builtin modules\n\tif modules == nil {\n\t\tmodules = NewModuleMap()\n\t}\n\n\treturn &Compiler{\n\t\tfile:            file,\n\t\tsymbolTable:     symbolTable,\n\t\tconstants:       constants,\n\t\tscopes:          []compilationScope{mainScope},\n\t\tscopeIndex:      0,\n\t\tloopIndex:       -1,\n\t\ttrace:           trace,\n\t\tmodules:         modules,\n\t\tcompiledModules: make(map[string]*CompiledFunction),\n\t\timportFileExt:   []string{SourceFileExtDefault},\n\t}\n}\n\n// Compile compiles the AST node.\nfunc (c *Compiler) Compile(node parser.Node) error {\n\tif c.trace != nil {\n\t\tif node != nil {\n\t\t\tdefer untracec(tracec(c, fmt.Sprintf(\"%s (%s)\",\n\t\t\t\tnode.String(), reflect.TypeOf(node).Elem().Name())))\n\t\t} else {\n\t\t\tdefer untracec(tracec(c, \"<nil>\"))\n\t\t}\n\t}\n\n\tswitch node := node.(type) {\n\tcase *parser.File:\n\t\tfor _, stmt := range node.Stmts {\n\t\t\tif err := c.Compile(stmt); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *parser.ExprStmt:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.emit(node, parser.OpPop)\n\tcase *parser.IncDecStmt:\n\t\top := token.AddAssign\n\t\tif node.Token == token.Dec {\n\t\t\top = token.SubAssign\n\t\t}\n\t\treturn c.compileAssign(node, []parser.Expr{node.Expr},\n\t\t\t[]parser.Expr{&parser.IntLit{Value: 1}}, op)\n\tcase *parser.ParenExpr:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase *parser.BinaryExpr:\n\t\tif node.Token == token.LAnd || node.Token == token.LOr {\n\t\t\treturn c.compileLogical(node)\n\t\t}\n\n\t\tif err := c.Compile(node.LHS); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := c.Compile(node.RHS); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch node.Token {\n\t\tcase token.Add:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Add))\n\t\tcase token.Sub:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Sub))\n\t\tcase token.Mul:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Mul))\n\t\tcase token.Quo:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Quo))\n\t\tcase token.Rem:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Rem))\n\t\tcase token.Greater:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Greater))\n\t\tcase token.GreaterEq:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.GreaterEq))\n\t\tcase token.Less:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Less))\n\t\tcase token.LessEq:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.LessEq))\n\t\tcase token.Equal:\n\t\t\tc.emit(node, parser.OpEqual)\n\t\tcase token.NotEqual:\n\t\t\tc.emit(node, parser.OpNotEqual)\n\t\tcase token.And:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.And))\n\t\tcase token.Or:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Or))\n\t\tcase token.Xor:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Xor))\n\t\tcase token.AndNot:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.AndNot))\n\t\tcase token.Shl:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Shl))\n\t\tcase token.Shr:\n\t\t\tc.emit(node, parser.OpBinaryOp, int(token.Shr))\n\t\tdefault:\n\t\t\treturn c.errorf(node, \"invalid binary operator: %s\",\n\t\t\t\tnode.Token.String())\n\t\t}\n\tcase *parser.IntLit:\n\t\tc.emit(node, parser.OpConstant,\n\t\t\tc.addConstant(&Int{Value: node.Value}))\n\tcase *parser.FloatLit:\n\t\tc.emit(node, parser.OpConstant,\n\t\t\tc.addConstant(&Float{Value: node.Value}))\n\tcase *parser.BoolLit:\n\t\tif node.Value {\n\t\t\tc.emit(node, parser.OpTrue)\n\t\t} else {\n\t\t\tc.emit(node, parser.OpFalse)\n\t\t}\n\tcase *parser.StringLit:\n\t\tif len(node.Value) > MaxStringLen {\n\t\t\treturn c.error(node, ErrStringLimit)\n\t\t}\n\t\tc.emit(node, parser.OpConstant,\n\t\t\tc.addConstant(&String{Value: node.Value}))\n\tcase *parser.CharLit:\n\t\tc.emit(node, parser.OpConstant,\n\t\t\tc.addConstant(&Char{Value: node.Value}))\n\tcase *parser.UndefinedLit:\n\t\tc.emit(node, parser.OpNull)\n\tcase *parser.UnaryExpr:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tswitch node.Token {\n\t\tcase token.Not:\n\t\t\tc.emit(node, parser.OpLNot)\n\t\tcase token.Sub:\n\t\t\tc.emit(node, parser.OpMinus)\n\t\tcase token.Xor:\n\t\t\tc.emit(node, parser.OpBComplement)\n\t\tcase token.Add:\n\t\t\t// do nothing?\n\t\tdefault:\n\t\t\treturn c.errorf(node,\n\t\t\t\t\"invalid unary operator: %s\", node.Token.String())\n\t\t}\n\tcase *parser.IfStmt:\n\t\t// open new symbol table for the statement\n\t\tc.symbolTable = c.symbolTable.Fork(true)\n\t\tdefer func() {\n\t\t\tc.symbolTable = c.symbolTable.Parent(false)\n\t\t}()\n\n\t\tif node.Init != nil {\n\t\t\tif err := c.Compile(node.Init); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tif err := c.Compile(node.Cond); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// first jump placeholder\n\t\tjumpPos1 := c.emit(node, parser.OpJumpFalsy, 0)\n\t\tif err := c.Compile(node.Body); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif node.Else != nil {\n\t\t\t// second jump placeholder\n\t\t\tjumpPos2 := c.emit(node, parser.OpJump, 0)\n\n\t\t\t// update first jump offset\n\t\t\tcurPos := len(c.currentInstructions())\n\t\t\tc.changeOperand(jumpPos1, curPos)\n\t\t\tif err := c.Compile(node.Else); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// update second jump offset\n\t\t\tcurPos = len(c.currentInstructions())\n\t\t\tc.changeOperand(jumpPos2, curPos)\n\t\t} else {\n\t\t\t// update first jump offset\n\t\t\tcurPos := len(c.currentInstructions())\n\t\t\tc.changeOperand(jumpPos1, curPos)\n\t\t}\n\tcase *parser.ForStmt:\n\t\treturn c.compileForStmt(node)\n\tcase *parser.ForInStmt:\n\t\treturn c.compileForInStmt(node)\n\tcase *parser.BranchStmt:\n\t\tif node.Token == token.Break {\n\t\t\tcurLoop := c.currentLoop()\n\t\t\tif curLoop == nil {\n\t\t\t\treturn c.errorf(node, \"break not allowed outside loop\")\n\t\t\t}\n\t\t\tpos := c.emit(node, parser.OpJump, 0)\n\t\t\tcurLoop.Breaks = append(curLoop.Breaks, pos)\n\t\t} else if node.Token == token.Continue {\n\t\t\tcurLoop := c.currentLoop()\n\t\t\tif curLoop == nil {\n\t\t\t\treturn c.errorf(node, \"continue not allowed outside loop\")\n\t\t\t}\n\t\t\tpos := c.emit(node, parser.OpJump, 0)\n\t\t\tcurLoop.Continues = append(curLoop.Continues, pos)\n\t\t} else {\n\t\t\tpanic(fmt.Errorf(\"invalid branch statement: %s\",\n\t\t\t\tnode.Token.String()))\n\t\t}\n\tcase *parser.BlockStmt:\n\t\tif len(node.Stmts) == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\tc.symbolTable = c.symbolTable.Fork(true)\n\t\tdefer func() {\n\t\t\tc.symbolTable = c.symbolTable.Parent(false)\n\t\t}()\n\n\t\tfor _, stmt := range node.Stmts {\n\t\t\tif err := c.Compile(stmt); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\tcase *parser.AssignStmt:\n\t\terr := c.compileAssign(node, node.LHS, node.RHS, node.Token)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\tcase *parser.Ident:\n\t\tsymbol, _, ok := c.symbolTable.Resolve(node.Name, false)\n\t\tif !ok {\n\t\t\treturn c.errorf(node, \"unresolved reference '%s'\", node.Name)\n\t\t}\n\n\t\tswitch symbol.Scope {\n\t\tcase ScopeGlobal:\n\t\t\tc.emit(node, parser.OpGetGlobal, symbol.Index)\n\t\tcase ScopeLocal:\n\t\t\tc.emit(node, parser.OpGetLocal, symbol.Index)\n\t\tcase ScopeBuiltin:\n\t\t\tc.emit(node, parser.OpGetBuiltin, symbol.Index)\n\t\tcase ScopeFree:\n\t\t\tc.emit(node, parser.OpGetFree, symbol.Index)\n\t\t}\n\tcase *parser.ArrayLit:\n\t\tfor _, elem := range node.Elements {\n\t\t\tif err := c.Compile(elem); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tc.emit(node, parser.OpArray, len(node.Elements))\n\tcase *parser.MapLit:\n\t\tfor _, elt := range node.Elements {\n\t\t\t// key\n\t\t\tif len(elt.Key) > MaxStringLen {\n\t\t\t\treturn c.error(node, ErrStringLimit)\n\t\t\t}\n\t\t\tc.emit(node, parser.OpConstant,\n\t\t\t\tc.addConstant(&String{Value: elt.Key}))\n\n\t\t\t// value\n\t\t\tif err := c.Compile(elt.Value); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tc.emit(node, parser.OpMap, len(node.Elements)*2)\n\n\tcase *parser.SelectorExpr: // selector on RHS side\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := c.Compile(node.Sel); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.emit(node, parser.OpIndex)\n\tcase *parser.IndexExpr:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := c.Compile(node.Index); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.emit(node, parser.OpIndex)\n\tcase *parser.SliceExpr:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif node.Low != nil {\n\t\t\tif err := c.Compile(node.Low); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tc.emit(node, parser.OpNull)\n\t\t}\n\t\tif node.High != nil {\n\t\t\tif err := c.Compile(node.High); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tc.emit(node, parser.OpNull)\n\t\t}\n\t\tc.emit(node, parser.OpSliceIndex)\n\tcase *parser.FuncLit:\n\t\tc.enterScope()\n\n\t\tfor _, p := range node.Type.Params.List {\n\t\t\ts := c.symbolTable.Define(p.Name)\n\n\t\t\t// function arguments is not assigned directly.\n\t\t\ts.LocalAssigned = true\n\t\t}\n\n\t\tif err := c.Compile(node.Body); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// code optimization\n\t\tc.optimizeFunc(node)\n\n\t\tfreeSymbols := c.symbolTable.FreeSymbols()\n\t\tnumLocals := c.symbolTable.MaxSymbols()\n\t\tinstructions, sourceMap := c.leaveScope()\n\n\t\tfor _, s := range freeSymbols {\n\t\t\tswitch s.Scope {\n\t\t\tcase ScopeLocal:\n\t\t\t\tif !s.LocalAssigned {\n\t\t\t\t\t// Here, the closure is capturing a local variable that's\n\t\t\t\t\t// not yet assigned its value. One example is a local\n\t\t\t\t\t// recursive function:\n\t\t\t\t\t//\n\t\t\t\t\t//   func() {\n\t\t\t\t\t//     foo := func(x) {\n\t\t\t\t\t//       // ..\n\t\t\t\t\t//       return foo(x-1)\n\t\t\t\t\t//     }\n\t\t\t\t\t//   }\n\t\t\t\t\t//\n\t\t\t\t\t// which translate into\n\t\t\t\t\t//\n\t\t\t\t\t//   0000 GETL    0\n\t\t\t\t\t//   0002 CLOSURE ?     1\n\t\t\t\t\t//   0006 DEFL    0\n\t\t\t\t\t//\n\t\t\t\t\t// . So the local variable (0) is being captured before\n\t\t\t\t\t// it's assigned the value.\n\t\t\t\t\t//\n\t\t\t\t\t// Solution is to transform the code into something like\n\t\t\t\t\t// this:\n\t\t\t\t\t//\n\t\t\t\t\t//   func() {\n\t\t\t\t\t//     foo := undefined\n\t\t\t\t\t//     foo = func(x) {\n\t\t\t\t\t//       // ..\n\t\t\t\t\t//       return foo(x-1)\n\t\t\t\t\t//     }\n\t\t\t\t\t//   }\n\t\t\t\t\t//\n\t\t\t\t\t// that is equivalent to\n\t\t\t\t\t//\n\t\t\t\t\t//   0000 NULL\n\t\t\t\t\t//   0001 DEFL    0\n\t\t\t\t\t//   0003 GETL    0\n\t\t\t\t\t//   0005 CLOSURE ?     1\n\t\t\t\t\t//   0009 SETL    0\n\t\t\t\t\t//\n\t\t\t\t\tc.emit(node, parser.OpNull)\n\t\t\t\t\tc.emit(node, parser.OpDefineLocal, s.Index)\n\t\t\t\t\ts.LocalAssigned = true\n\t\t\t\t}\n\t\t\t\tc.emit(node, parser.OpGetLocalPtr, s.Index)\n\t\t\tcase ScopeFree:\n\t\t\t\tc.emit(node, parser.OpGetFreePtr, s.Index)\n\t\t\t}\n\t\t}\n\n\t\tcompiledFunction := &CompiledFunction{\n\t\t\tInstructions:  instructions,\n\t\t\tNumLocals:     numLocals,\n\t\t\tNumParameters: len(node.Type.Params.List),\n\t\t\tVarArgs:       node.Type.Params.VarArgs,\n\t\t\tSourceMap:     sourceMap,\n\t\t}\n\t\tif len(freeSymbols) > 0 {\n\t\t\tc.emit(node, parser.OpClosure,\n\t\t\t\tc.addConstant(compiledFunction), len(freeSymbols))\n\t\t} else {\n\t\t\tc.emit(node, parser.OpConstant, c.addConstant(compiledFunction))\n\t\t}\n\tcase *parser.ReturnStmt:\n\t\tif c.symbolTable.Parent(true) == nil {\n\t\t\t// outside the function\n\t\t\treturn c.errorf(node, \"return not allowed outside function\")\n\t\t}\n\n\t\tif node.Result == nil {\n\t\t\tc.emit(node, parser.OpReturn, 0)\n\t\t} else {\n\t\t\tif err := c.Compile(node.Result); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.emit(node, parser.OpReturn, 1)\n\t\t}\n\tcase *parser.CallExpr:\n\t\tif err := c.Compile(node.Func); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor _, arg := range node.Args {\n\t\t\tif err := c.Compile(arg); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tellipsis := 0\n\t\tif node.Ellipsis.IsValid() {\n\t\t\tellipsis = 1\n\t\t}\n\t\tc.emit(node, parser.OpCall, len(node.Args), ellipsis)\n\tcase *parser.ImportExpr:\n\t\tif node.ModuleName == \"\" {\n\t\t\treturn c.errorf(node, \"empty module name\")\n\t\t}\n\n\t\tif mod := c.modules.Get(node.ModuleName); mod != nil {\n\t\t\tv, err := mod.Import(node.ModuleName)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tswitch v := v.(type) {\n\t\t\tcase []byte: // module written in Tengo\n\t\t\t\tcompiled, err := c.compileModule(node,\n\t\t\t\t\tnode.ModuleName, v, false)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tc.emit(node, parser.OpConstant, c.addConstant(compiled))\n\t\t\t\tc.emit(node, parser.OpCall, 0, 0)\n\t\t\tcase Object: // builtin module\n\t\t\t\tc.emit(node, parser.OpConstant, c.addConstant(v))\n\t\t\tdefault:\n\t\t\t\tpanic(fmt.Errorf(\"invalid import value type: %T\", v))\n\t\t\t}\n\t\t} else if c.allowFileImport {\n\t\t\tmoduleName := node.ModuleName\n\n\t\t\tmodulePath, err := c.getPathModule(moduleName)\n\t\t\tif err != nil {\n\t\t\t\treturn c.errorf(node, \"module file path error: %s\",\n\t\t\t\t\terr.Error())\n\t\t\t}\n\n\t\t\tmoduleSrc, err := ioutil.ReadFile(modulePath)\n\t\t\tif err != nil {\n\t\t\t\treturn c.errorf(node, \"module file read error: %s\",\n\t\t\t\t\terr.Error())\n\t\t\t}\n\n\t\t\tcompiled, err := c.compileModule(node, modulePath, moduleSrc, true)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tc.emit(node, parser.OpConstant, c.addConstant(compiled))\n\t\t\tc.emit(node, parser.OpCall, 0, 0)\n\t\t} else {\n\t\t\treturn c.errorf(node, \"module '%s' not found\", node.ModuleName)\n\t\t}\n\tcase *parser.ExportStmt:\n\t\t// export statement must be in top-level scope\n\t\tif c.scopeIndex != 0 {\n\t\t\treturn c.errorf(node, \"export not allowed inside function\")\n\t\t}\n\n\t\t// export statement is simply ignore when compiling non-module code\n\t\tif c.parent == nil {\n\t\t\tbreak\n\t\t}\n\t\tif err := c.Compile(node.Result); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.emit(node, parser.OpImmutable)\n\t\tc.emit(node, parser.OpReturn, 1)\n\tcase *parser.ErrorExpr:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.emit(node, parser.OpError)\n\tcase *parser.ImmutableExpr:\n\t\tif err := c.Compile(node.Expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tc.emit(node, parser.OpImmutable)\n\tcase *parser.CondExpr:\n\t\tif err := c.Compile(node.Cond); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// first jump placeholder\n\t\tjumpPos1 := c.emit(node, parser.OpJumpFalsy, 0)\n\t\tif err := c.Compile(node.True); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// second jump placeholder\n\t\tjumpPos2 := c.emit(node, parser.OpJump, 0)\n\n\t\t// update first jump offset\n\t\tcurPos := len(c.currentInstructions())\n\t\tc.changeOperand(jumpPos1, curPos)\n\t\tif err := c.Compile(node.False); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// update second jump offset\n\t\tcurPos = len(c.currentInstructions())\n\t\tc.changeOperand(jumpPos2, curPos)\n\t}\n\treturn nil\n}\n\n// Bytecode returns a compiled bytecode.\nfunc (c *Compiler) Bytecode() *Bytecode {\n\treturn &Bytecode{\n\t\tFileSet: c.file.Set(),\n\t\tMainFunction: &CompiledFunction{\n\t\t\tInstructions: append(c.currentInstructions(), parser.OpSuspend),\n\t\t\tSourceMap:    c.currentSourceMap(),\n\t\t},\n\t\tConstants: c.constants,\n\t}\n}\n\n// EnableFileImport enables or disables module loading from local files.\n// Local file modules are disabled by default.\nfunc (c *Compiler) EnableFileImport(enable bool) {\n\tc.allowFileImport = enable\n}\n\n// SetImportDir sets the initial import directory path for file imports.\nfunc (c *Compiler) SetImportDir(dir string) {\n\tc.importDir = dir\n}\n\n// SetImportFileExt sets the extension name of the source file for loading\n// local module files.\n//\n// Use this method if you want other source file extension than \".tengo\".\n//\n//     // this will search for *.tengo, *.foo, *.bar\n//     err := c.SetImportFileExt(\".tengo\", \".foo\", \".bar\")\n//\n// This function requires at least one argument, since it will replace the\n// current list of extension name.\nfunc (c *Compiler) SetImportFileExt(exts ...string) error {\n\tif len(exts) == 0 {\n\t\treturn fmt.Errorf(\"missing arg: at least one argument is required\")\n\t}\n\n\tfor _, ext := range exts {\n\t\tif ext != filepath.Ext(ext) || ext == \"\" {\n\t\t\treturn fmt.Errorf(\"invalid file extension: %s\", ext)\n\t\t}\n\t}\n\n\tc.importFileExt = exts // Replace the hole current extension list\n\n\treturn nil\n}\n\n// GetImportFileExt returns the current list of extension name.\n// Thease are the complementary suffix of the source file to search and load\n// local module files.\nfunc (c *Compiler) GetImportFileExt() []string {\n\treturn c.importFileExt\n}\n\nfunc (c *Compiler) compileAssign(\n\tnode parser.Node,\n\tlhs, rhs []parser.Expr,\n\top token.Token,\n) error {\n\tnumLHS, numRHS := len(lhs), len(rhs)\n\tif numLHS > 1 || numRHS > 1 {\n\t\treturn c.errorf(node, \"tuple assignment not allowed\")\n\t}\n\n\t// resolve and compile left-hand side\n\tident, selectors := resolveAssignLHS(lhs[0])\n\tnumSel := len(selectors)\n\n\tif op == token.Define && numSel > 0 {\n\t\t// using selector on new variable does not make sense\n\t\treturn c.errorf(node, \"operator ':=' not allowed with selector\")\n\t}\n\n\t_, isFunc := rhs[0].(*parser.FuncLit)\n\tsymbol, depth, exists := c.symbolTable.Resolve(ident, false)\n\tif op == token.Define {\n\t\tif depth == 0 && exists {\n\t\t\treturn c.errorf(node, \"'%s' redeclared in this block\", ident)\n\t\t}\n\t\tif isFunc {\n\t\t\tsymbol = c.symbolTable.Define(ident)\n\t\t}\n\t} else {\n\t\tif !exists {\n\t\t\treturn c.errorf(node, \"unresolved reference '%s'\", ident)\n\t\t}\n\t}\n\n\t// +=, -=, *=, /=\n\tif op != token.Assign && op != token.Define {\n\t\tif err := c.Compile(lhs[0]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// compile RHSs\n\tfor _, expr := range rhs {\n\t\tif err := c.Compile(expr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif op == token.Define && !isFunc {\n\t\tsymbol = c.symbolTable.Define(ident)\n\t}\n\n\tswitch op {\n\tcase token.AddAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Add))\n\tcase token.SubAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Sub))\n\tcase token.MulAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Mul))\n\tcase token.QuoAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Quo))\n\tcase token.RemAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Rem))\n\tcase token.AndAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.And))\n\tcase token.OrAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Or))\n\tcase token.AndNotAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.AndNot))\n\tcase token.XorAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Xor))\n\tcase token.ShlAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Shl))\n\tcase token.ShrAssign:\n\t\tc.emit(node, parser.OpBinaryOp, int(token.Shr))\n\t}\n\n\t// compile selector expressions (right to left)\n\tfor i := numSel - 1; i >= 0; i-- {\n\t\tif err := c.Compile(selectors[i]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tswitch symbol.Scope {\n\tcase ScopeGlobal:\n\t\tif numSel > 0 {\n\t\t\tc.emit(node, parser.OpSetSelGlobal, symbol.Index, numSel)\n\t\t} else {\n\t\t\tc.emit(node, parser.OpSetGlobal, symbol.Index)\n\t\t}\n\tcase ScopeLocal:\n\t\tif numSel > 0 {\n\t\t\tc.emit(node, parser.OpSetSelLocal, symbol.Index, numSel)\n\t\t} else {\n\t\t\tif op == token.Define && !symbol.LocalAssigned {\n\t\t\t\tc.emit(node, parser.OpDefineLocal, symbol.Index)\n\t\t\t} else {\n\t\t\t\tc.emit(node, parser.OpSetLocal, symbol.Index)\n\t\t\t}\n\t\t}\n\n\t\t// mark the symbol as local-assigned\n\t\tsymbol.LocalAssigned = true\n\tcase ScopeFree:\n\t\tif numSel > 0 {\n\t\t\tc.emit(node, parser.OpSetSelFree, symbol.Index, numSel)\n\t\t} else {\n\t\t\tc.emit(node, parser.OpSetFree, symbol.Index)\n\t\t}\n\tdefault:\n\t\tpanic(fmt.Errorf(\"invalid assignment variable scope: %s\",\n\t\t\tsymbol.Scope))\n\t}\n\treturn nil\n}\n\nfunc (c *Compiler) compileLogical(node *parser.BinaryExpr) error {\n\t// left side term\n\tif err := c.Compile(node.LHS); err != nil {\n\t\treturn err\n\t}\n\n\t// jump position\n\tvar jumpPos int\n\tif node.Token == token.LAnd {\n\t\tjumpPos = c.emit(node, parser.OpAndJump, 0)\n\t} else {\n\t\tjumpPos = c.emit(node, parser.OpOrJump, 0)\n\t}\n\n\t// right side term\n\tif err := c.Compile(node.RHS); err != nil {\n\t\treturn err\n\t}\n\n\tc.changeOperand(jumpPos, len(c.currentInstructions()))\n\treturn nil\n}\n\nfunc (c *Compiler) compileForStmt(stmt *parser.ForStmt) error {\n\tc.symbolTable = c.symbolTable.Fork(true)\n\tdefer func() {\n\t\tc.symbolTable = c.symbolTable.Parent(false)\n\t}()\n\n\t// init statement\n\tif stmt.Init != nil {\n\t\tif err := c.Compile(stmt.Init); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// pre-condition position\n\tpreCondPos := len(c.currentInstructions())\n\n\t// condition expression\n\tpostCondPos := -1\n\tif stmt.Cond != nil {\n\t\tif err := c.Compile(stmt.Cond); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// condition jump position\n\t\tpostCondPos = c.emit(stmt, parser.OpJumpFalsy, 0)\n\t}\n\n\t// enter loop\n\tloop := c.enterLoop()\n\n\t// body statement\n\tif err := c.Compile(stmt.Body); err != nil {\n\t\tc.leaveLoop()\n\t\treturn err\n\t}\n\n\tc.leaveLoop()\n\n\t// post-body position\n\tpostBodyPos := len(c.currentInstructions())\n\n\t// post statement\n\tif stmt.Post != nil {\n\t\tif err := c.Compile(stmt.Post); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// back to condition\n\tc.emit(stmt, parser.OpJump, preCondPos)\n\n\t// post-statement position\n\tpostStmtPos := len(c.currentInstructions())\n\tif postCondPos >= 0 {\n\t\tc.changeOperand(postCondPos, postStmtPos)\n\t}\n\n\t// update all break/continue jump positions\n\tfor _, pos := range loop.Breaks {\n\t\tc.changeOperand(pos, postStmtPos)\n\t}\n\tfor _, pos := range loop.Continues {\n\t\tc.changeOperand(pos, postBodyPos)\n\t}\n\treturn nil\n}\n\nfunc (c *Compiler) compileForInStmt(stmt *parser.ForInStmt) error {\n\tc.symbolTable = c.symbolTable.Fork(true)\n\tdefer func() {\n\t\tc.symbolTable = c.symbolTable.Parent(false)\n\t}()\n\n\t// for-in statement is compiled like following:\n\t//\n\t//   for :it := iterator(iterable); :it.next();  {\n\t//     k, v := :it.get()  // DEFINE operator\n\t//\n\t//     ... body ...\n\t//   }\n\t//\n\t// \":it\" is a local variable but it will not conflict with other user variables\n\t// because character \":\" is not allowed in the variable names.\n\n\t// init\n\t//   :it = iterator(iterable)\n\titSymbol := c.symbolTable.Define(\":it\")\n\tif err := c.Compile(stmt.Iterable); err != nil {\n\t\treturn err\n\t}\n\tc.emit(stmt, parser.OpIteratorInit)\n\tif itSymbol.Scope == ScopeGlobal {\n\t\tc.emit(stmt, parser.OpSetGlobal, itSymbol.Index)\n\t} else {\n\t\tc.emit(stmt, parser.OpDefineLocal, itSymbol.Index)\n\t}\n\n\t// pre-condition position\n\tpreCondPos := len(c.currentInstructions())\n\n\t// condition\n\t//  :it.HasMore()\n\tif itSymbol.Scope == ScopeGlobal {\n\t\tc.emit(stmt, parser.OpGetGlobal, itSymbol.Index)\n\t} else {\n\t\tc.emit(stmt, parser.OpGetLocal, itSymbol.Index)\n\t}\n\tc.emit(stmt, parser.OpIteratorNext)\n\n\t// condition jump position\n\tpostCondPos := c.emit(stmt, parser.OpJumpFalsy, 0)\n\n\t// enter loop\n\tloop := c.enterLoop()\n\n\t// assign key variable\n\tif stmt.Key.Name != \"_\" {\n\t\tkeySymbol := c.symbolTable.Define(stmt.Key.Name)\n\t\tif itSymbol.Scope == ScopeGlobal {\n\t\t\tc.emit(stmt, parser.OpGetGlobal, itSymbol.Index)\n\t\t} else {\n\t\t\tc.emit(stmt, parser.OpGetLocal, itSymbol.Index)\n\t\t}\n\t\tc.emit(stmt, parser.OpIteratorKey)\n\t\tif keySymbol.Scope == ScopeGlobal {\n\t\t\tc.emit(stmt, parser.OpSetGlobal, keySymbol.Index)\n\t\t} else {\n\t\t\tkeySymbol.LocalAssigned = true\n\t\t\tc.emit(stmt, parser.OpDefineLocal, keySymbol.Index)\n\t\t}\n\t}\n\n\t// assign value variable\n\tif stmt.Value.Name != \"_\" {\n\t\tvalueSymbol := c.symbolTable.Define(stmt.Value.Name)\n\t\tif itSymbol.Scope == ScopeGlobal {\n\t\t\tc.emit(stmt, parser.OpGetGlobal, itSymbol.Index)\n\t\t} else {\n\t\t\tc.emit(stmt, parser.OpGetLocal, itSymbol.Index)\n\t\t}\n\t\tc.emit(stmt, parser.OpIteratorValue)\n\t\tif valueSymbol.Scope == ScopeGlobal {\n\t\t\tc.emit(stmt, parser.OpSetGlobal, valueSymbol.Index)\n\t\t} else {\n\t\t\tvalueSymbol.LocalAssigned = true\n\t\t\tc.emit(stmt, parser.OpDefineLocal, valueSymbol.Index)\n\t\t}\n\t}\n\n\t// body statement\n\tif err := c.Compile(stmt.Body); err != nil {\n\t\tc.leaveLoop()\n\t\treturn err\n\t}\n\n\tc.leaveLoop()\n\n\t// post-body position\n\tpostBodyPos := len(c.currentInstructions())\n\n\t// back to condition\n\tc.emit(stmt, parser.OpJump, preCondPos)\n\n\t// post-statement position\n\tpostStmtPos := len(c.currentInstructions())\n\tc.changeOperand(postCondPos, postStmtPos)\n\n\t// update all break/continue jump positions\n\tfor _, pos := range loop.Breaks {\n\t\tc.changeOperand(pos, postStmtPos)\n\t}\n\tfor _, pos := range loop.Continues {\n\t\tc.changeOperand(pos, postBodyPos)\n\t}\n\treturn nil\n}\n\nfunc (c *Compiler) checkCyclicImports(\n\tnode parser.Node,\n\tmodulePath string,\n) error {\n\tif c.modulePath == modulePath {\n\t\treturn c.errorf(node, \"cyclic module import: %s\", modulePath)\n\t} else if c.parent != nil {\n\t\treturn c.parent.checkCyclicImports(node, modulePath)\n\t}\n\treturn nil\n}\n\nfunc (c *Compiler) compileModule(\n\tnode parser.Node,\n\tmodulePath string,\n\tsrc []byte,\n\tisFile bool,\n) (*CompiledFunction, error) {\n\tif err := c.checkCyclicImports(node, modulePath); err != nil {\n\t\treturn nil, err\n\t}\n\n\tcompiledModule, exists := c.loadCompiledModule(modulePath)\n\tif exists {\n\t\treturn compiledModule, nil\n\t}\n\n\tmodFile := c.file.Set().AddFile(modulePath, -1, len(src))\n\tp := parser.NewParser(modFile, src, nil)\n\tfile, err := p.ParseFile()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// inherit builtin functions\n\tsymbolTable := NewSymbolTable()\n\tfor _, sym := range c.symbolTable.BuiltinSymbols() {\n\t\tsymbolTable.DefineBuiltin(sym.Index, sym.Name)\n\t}\n\n\t// no global scope for the module\n\tsymbolTable = symbolTable.Fork(false)\n\n\t// compile module\n\tmoduleCompiler := c.fork(modFile, modulePath, symbolTable, isFile)\n\tif err := moduleCompiler.Compile(file); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// code optimization\n\tmoduleCompiler.optimizeFunc(node)\n\tcompiledFunc := moduleCompiler.Bytecode().MainFunction\n\tcompiledFunc.NumLocals = symbolTable.MaxSymbols()\n\tc.storeCompiledModule(modulePath, compiledFunc)\n\treturn compiledFunc, nil\n}\n\nfunc (c *Compiler) loadCompiledModule(\n\tmodulePath string,\n) (mod *CompiledFunction, ok bool) {\n\tif c.parent != nil {\n\t\treturn c.parent.loadCompiledModule(modulePath)\n\t}\n\tmod, ok = c.compiledModules[modulePath]\n\treturn\n}\n\nfunc (c *Compiler) storeCompiledModule(\n\tmodulePath string,\n\tmodule *CompiledFunction,\n) {\n\tif c.parent != nil {\n\t\tc.parent.storeCompiledModule(modulePath, module)\n\t}\n\tc.compiledModules[modulePath] = module\n}\n\nfunc (c *Compiler) enterLoop() *loop {\n\tloop := &loop{}\n\tc.loops = append(c.loops, loop)\n\tc.loopIndex++\n\tif c.trace != nil {\n\t\tc.printTrace(\"LOOPE\", c.loopIndex)\n\t}\n\treturn loop\n}\n\nfunc (c *Compiler) leaveLoop() {\n\tif c.trace != nil {\n\t\tc.printTrace(\"LOOPL\", c.loopIndex)\n\t}\n\tc.loops = c.loops[:len(c.loops)-1]\n\tc.loopIndex--\n}\n\nfunc (c *Compiler) currentLoop() *loop {\n\tif c.loopIndex >= 0 {\n\t\treturn c.loops[c.loopIndex]\n\t}\n\treturn nil\n}\n\nfunc (c *Compiler) currentInstructions() []byte {\n\treturn c.scopes[c.scopeIndex].Instructions\n}\n\nfunc (c *Compiler) currentSourceMap() map[int]parser.Pos {\n\treturn c.scopes[c.scopeIndex].SourceMap\n}\n\nfunc (c *Compiler) enterScope() {\n\tscope := compilationScope{\n\t\tSymbolInit: make(map[string]bool),\n\t\tSourceMap:  make(map[int]parser.Pos),\n\t}\n\tc.scopes = append(c.scopes, scope)\n\tc.scopeIndex++\n\tc.symbolTable = c.symbolTable.Fork(false)\n\tif c.trace != nil {\n\t\tc.printTrace(\"SCOPE\", c.scopeIndex)\n\t}\n}\n\nfunc (c *Compiler) leaveScope() (\n\tinstructions []byte,\n\tsourceMap map[int]parser.Pos,\n) {\n\tinstructions = c.currentInstructions()\n\tsourceMap = c.currentSourceMap()\n\tc.scopes = c.scopes[:len(c.scopes)-1]\n\tc.scopeIndex--\n\tc.symbolTable = c.symbolTable.Parent(true)\n\tif c.trace != nil {\n\t\tc.printTrace(\"SCOPL\", c.scopeIndex)\n\t}\n\treturn\n}\n\nfunc (c *Compiler) fork(\n\tfile *parser.SourceFile,\n\tmodulePath string,\n\tsymbolTable *SymbolTable,\n\tisFile bool,\n) *Compiler {\n\tchild := NewCompiler(file, symbolTable, nil, c.modules, c.trace)\n\tchild.modulePath = modulePath // module file path\n\tchild.parent = c              // parent to set to current compiler\n\tchild.allowFileImport = c.allowFileImport\n\tchild.importDir = c.importDir\n\tchild.importFileExt = c.importFileExt\n\tif isFile && c.importDir != \"\" {\n\t\tchild.importDir = filepath.Dir(modulePath)\n\t}\n\treturn child\n}\n\nfunc (c *Compiler) error(node parser.Node, err error) error {\n\treturn &CompilerError{\n\t\tFileSet: c.file.Set(),\n\t\tNode:    node,\n\t\tErr:     err,\n\t}\n}\n\nfunc (c *Compiler) errorf(\n\tnode parser.Node,\n\tformat string,\n\targs ...interface{},\n) error {\n\treturn &CompilerError{\n\t\tFileSet: c.file.Set(),\n\t\tNode:    node,\n\t\tErr:     fmt.Errorf(format, args...),\n\t}\n}\n\nfunc (c *Compiler) addConstant(o Object) int {\n\tif c.parent != nil {\n\t\t// module compilers will use their parent's constants array\n\t\treturn c.parent.addConstant(o)\n\t}\n\tc.constants = append(c.constants, o)\n\tif c.trace != nil {\n\t\tc.printTrace(fmt.Sprintf(\"CONST %04d %s\", len(c.constants)-1, o))\n\t}\n\treturn len(c.constants) - 1\n}\n\nfunc (c *Compiler) addInstruction(b []byte) int {\n\tposNewIns := len(c.currentInstructions())\n\tc.scopes[c.scopeIndex].Instructions = append(\n\t\tc.currentInstructions(), b...)\n\treturn posNewIns\n}\n\nfunc (c *Compiler) replaceInstruction(pos int, inst []byte) {\n\tcopy(c.currentInstructions()[pos:], inst)\n\tif c.trace != nil {\n\t\tc.printTrace(fmt.Sprintf(\"REPLC %s\",\n\t\t\tFormatInstructions(\n\t\t\t\tc.scopes[c.scopeIndex].Instructions[pos:], pos)[0]))\n\t}\n}\n\nfunc (c *Compiler) changeOperand(opPos int, operand ...int) {\n\top := c.currentInstructions()[opPos]\n\tinst := MakeInstruction(op, operand...)\n\tc.replaceInstruction(opPos, inst)\n}\n\n// optimizeFunc performs some code-level optimization for the current function\n// instructions. It also removes unreachable (dead code) instructions and adds\n// \"returns\" instruction if needed.\nfunc (c *Compiler) optimizeFunc(node parser.Node) {\n\t// any instructions between RETURN and the function end\n\t// or instructions between RETURN and jump target position\n\t// are considered as unreachable.\n\n\t// pass 1. identify all jump destinations\n\tdsts := make(map[int]bool)\n\titerateInstructions(c.scopes[c.scopeIndex].Instructions,\n\t\tfunc(pos int, opcode parser.Opcode, operands []int) bool {\n\t\t\tswitch opcode {\n\t\t\tcase parser.OpJump, parser.OpJumpFalsy,\n\t\t\t\tparser.OpAndJump, parser.OpOrJump:\n\t\t\t\tdsts[operands[0]] = true\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t// pass 2. eliminate dead code\n\tvar newInsts []byte\n\tposMap := make(map[int]int) // old position to new position\n\tvar dstIdx int\n\tvar deadCode bool\n\titerateInstructions(c.scopes[c.scopeIndex].Instructions,\n\t\tfunc(pos int, opcode parser.Opcode, operands []int) bool {\n\t\t\tswitch {\n\t\t\tcase dsts[pos]:\n\t\t\t\tdstIdx++\n\t\t\t\tdeadCode = false\n\t\t\tcase opcode == parser.OpReturn:\n\t\t\t\tif deadCode {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tdeadCode = true\n\t\t\tcase deadCode:\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tposMap[pos] = len(newInsts)\n\t\t\tnewInsts = append(newInsts,\n\t\t\t\tMakeInstruction(opcode, operands...)...)\n\t\t\treturn true\n\t\t})\n\n\t// pass 3. update jump positions\n\tvar lastOp parser.Opcode\n\tvar appendReturn bool\n\tendPos := len(c.scopes[c.scopeIndex].Instructions)\n\tnewEndPost := len(newInsts)\n\n\titerateInstructions(newInsts,\n\t\tfunc(pos int, opcode parser.Opcode, operands []int) bool {\n\t\t\tswitch opcode {\n\t\t\tcase parser.OpJump, parser.OpJumpFalsy, parser.OpAndJump,\n\t\t\t\tparser.OpOrJump:\n\t\t\t\tnewDst, ok := posMap[operands[0]]\n\t\t\t\tif ok {\n\t\t\t\t\tcopy(newInsts[pos:],\n\t\t\t\t\t\tMakeInstruction(opcode, newDst))\n\t\t\t\t} else if endPos == operands[0] {\n\t\t\t\t\t// there's a jump instruction that jumps to the end of\n\t\t\t\t\t// function compiler should append \"return\".\n\t\t\t\t\tcopy(newInsts[pos:],\n\t\t\t\t\t\tMakeInstruction(opcode, newEndPost))\n\t\t\t\t\tappendReturn = true\n\t\t\t\t} else {\n\t\t\t\t\tpanic(fmt.Errorf(\"invalid jump position: %d\", newDst))\n\t\t\t\t}\n\t\t\t}\n\t\t\tlastOp = opcode\n\t\t\treturn true\n\t\t})\n\tif lastOp != parser.OpReturn {\n\t\tappendReturn = true\n\t}\n\n\t// pass 4. update source map\n\tnewSourceMap := make(map[int]parser.Pos)\n\tfor pos, srcPos := range c.scopes[c.scopeIndex].SourceMap {\n\t\tnewPos, ok := posMap[pos]\n\t\tif ok {\n\t\t\tnewSourceMap[newPos] = srcPos\n\t\t}\n\t}\n\tc.scopes[c.scopeIndex].Instructions = newInsts\n\tc.scopes[c.scopeIndex].SourceMap = newSourceMap\n\n\t// append \"return\"\n\tif appendReturn {\n\t\tc.emit(node, parser.OpReturn, 0)\n\t}\n}\n\nfunc (c *Compiler) emit(\n\tnode parser.Node,\n\topcode parser.Opcode,\n\toperands ...int,\n) int {\n\tfilePos := parser.NoPos\n\tif node != nil {\n\t\tfilePos = node.Pos()\n\t}\n\n\tinst := MakeInstruction(opcode, operands...)\n\tpos := c.addInstruction(inst)\n\tc.scopes[c.scopeIndex].SourceMap[pos] = filePos\n\tif c.trace != nil {\n\t\tc.printTrace(fmt.Sprintf(\"EMIT  %s\",\n\t\t\tFormatInstructions(\n\t\t\t\tc.scopes[c.scopeIndex].Instructions[pos:], pos)[0]))\n\t}\n\treturn pos\n}\n\nfunc (c *Compiler) printTrace(a ...interface{}) {\n\tconst (\n\t\tdots = \". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . \"\n\t\tn    = len(dots)\n\t)\n\n\ti := 2 * c.indent\n\tfor i > n {\n\t\t_, _ = fmt.Fprint(c.trace, dots)\n\t\ti -= n\n\t}\n\t_, _ = fmt.Fprint(c.trace, dots[0:i])\n\t_, _ = fmt.Fprintln(c.trace, a...)\n}\n\nfunc (c *Compiler) getPathModule(moduleName string) (pathFile string, err error) {\n\tfor _, ext := range c.importFileExt {\n\t\tnameFile := moduleName\n\n\t\tif !strings.HasSuffix(nameFile, ext) {\n\t\t\tnameFile += ext\n\t\t}\n\n\t\tpathFile, err = filepath.Abs(filepath.Join(c.importDir, nameFile))\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Check if file exists\n\t\tif _, err := os.Stat(pathFile); !errors.Is(err, os.ErrNotExist) {\n\t\t\treturn pathFile, nil\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"module '%s' not found at: %s\", moduleName, pathFile)\n}\n\nfunc resolveAssignLHS(\n\texpr parser.Expr,\n) (name string, selectors []parser.Expr) {\n\tswitch term := expr.(type) {\n\tcase *parser.SelectorExpr:\n\t\tname, selectors = resolveAssignLHS(term.Expr)\n\t\tselectors = append(selectors, term.Sel)\n\t\treturn\n\tcase *parser.IndexExpr:\n\t\tname, selectors = resolveAssignLHS(term.Expr)\n\t\tselectors = append(selectors, term.Index)\n\tcase *parser.Ident:\n\t\tname = term.Name\n\t}\n\treturn\n}\n\nfunc iterateInstructions(\n\tb []byte,\n\tfn func(pos int, opcode parser.Opcode, operands []int) bool,\n) {\n\tfor i := 0; i < len(b); i++ {\n\t\tnumOperands := parser.OpcodeOperands[b[i]]\n\t\toperands, read := parser.ReadOperands(numOperands, b[i+1:])\n\t\tif !fn(i, b[i], operands) {\n\t\t\tbreak\n\t\t}\n\t\ti += read\n\t}\n}\n\nfunc tracec(c *Compiler, msg string) *Compiler {\n\tc.printTrace(msg, \"{\")\n\tc.indent++\n\treturn c\n}\n\nfunc untracec(c *Compiler) {\n\tc.indent--\n\tc.printTrace(\"}\")\n}\n"
        },
        {
          "name": "compiler_test.go",
          "type": "blob",
          "size": 44.6962890625,
          "content": "package tengo_test\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/require\"\n\t\"github.com/d5/tengo/v2/stdlib\"\n)\n\nfunc TestCompiler_Compile(t *testing.T) {\n\texpectCompile(t, `1 + 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1; 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 - 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 12),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 * 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 13),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `2 / 1`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 14),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(1))))\n\n\texpectCompile(t, `true`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `false`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpFalse),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `1 > 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 39),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 < 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 38),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 >= 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 44),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 <= 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 43),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 == 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `1 != 2`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpNotEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `true == false`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpFalse),\n\t\t\t\ttengo.MakeInstruction(parser.OpEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `true != false`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpFalse),\n\t\t\t\ttengo.MakeInstruction(parser.OpNotEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `-1`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpMinus),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1))))\n\n\texpectCompile(t, `!true`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpLNot),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `if true { 10 }; 3333`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),          // 0000\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 10), // 0001\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),   // 0004\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0007\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),   // 0008\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)), // 0011\n\t\t\tobjectsArray(\n\t\t\t\tintObject(10),\n\t\t\t\tintObject(3333))))\n\n\texpectCompile(t, `if (true) { 10 } else { 20 }; 3333;`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),          // 0000\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 15), // 0001\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),   // 0004\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0007\n\t\t\t\ttengo.MakeInstruction(parser.OpJump, 19),      // 0008\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),   // 0011\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0014\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),   // 0015\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)), // 0018\n\t\t\tobjectsArray(\n\t\t\t\tintObject(10),\n\t\t\t\tintObject(20),\n\t\t\t\tintObject(3333))))\n\n\texpectCompile(t, `\"kami\"`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tstringObject(\"kami\"))))\n\n\texpectCompile(t, `\"ka\" + \"mi\"`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tstringObject(\"ka\"),\n\t\t\t\tstringObject(\"mi\"))))\n\n\texpectCompile(t, `a := 1; b := 2; a += b`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `a := 1; b := 2; a /= b`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 14),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `[]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `[1, 2, 3]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3))))\n\n\texpectCompile(t, `[1 + 2, 3 - 4, 5 * 6]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 12),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 5),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 13),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3),\n\t\t\t\tintObject(4),\n\t\t\t\tintObject(5),\n\t\t\t\tintObject(6))))\n\n\texpectCompile(t, `{}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpMap, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `{a: 2, b: 4, c: 6}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 5),\n\t\t\t\ttengo.MakeInstruction(parser.OpMap, 6),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tstringObject(\"a\"),\n\t\t\t\tintObject(2),\n\t\t\t\tstringObject(\"b\"),\n\t\t\t\tintObject(4),\n\t\t\t\tstringObject(\"c\"),\n\t\t\t\tintObject(6))))\n\n\texpectCompile(t, `{a: 2 + 3, b: 5 * 6}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 5),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 13),\n\t\t\t\ttengo.MakeInstruction(parser.OpMap, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tstringObject(\"a\"),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3),\n\t\t\t\tstringObject(\"b\"),\n\t\t\t\tintObject(5),\n\t\t\t\tintObject(6))))\n\n\texpectCompile(t, `[1, 2, 3][1 + 1]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpIndex),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3))))\n\n\texpectCompile(t, `{a: 2}[2 - 1]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpMap, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 12),\n\t\t\t\ttengo.MakeInstruction(parser.OpIndex),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tstringObject(\"a\"),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(1))))\n\n\texpectCompile(t, `[1, 2, 3][:]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpNull),\n\t\t\t\ttengo.MakeInstruction(parser.OpNull),\n\t\t\t\ttengo.MakeInstruction(parser.OpSliceIndex),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3))))\n\n\texpectCompile(t, `[1, 2, 3][0 : 2]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSliceIndex),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3),\n\t\t\t\tintObject(0))))\n\n\texpectCompile(t, `[1, 2, 3][:2]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpNull),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSliceIndex),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3))))\n\n\texpectCompile(t, `[1, 2, 3][0:]`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpNull),\n\t\t\t\ttengo.MakeInstruction(parser.OpSliceIndex),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3),\n\t\t\t\tintObject(0))))\n\n\texpectCompile(t, `f1 := func(a) { return a }; f1([1, 2]...);`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 1, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2))))\n\n\texpectCompile(t, `func() { return 5 + 10 }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(5),\n\t\t\t\tintObject(10),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `func() { 5 + 10 }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(5),\n\t\t\t\tintObject(10),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `func() { 1; 2 }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `func() { 1; return 2 }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `func() { if(true) { return 1 } else { return 2 } }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpTrue),          // 0000\n\t\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 11), // 0001\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),   // 0004\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1),     // 0007\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),   // 0009\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))  // 0012\n\n\texpectCompile(t, `func() { 1; if(true) { 2 } else { 3 }; 4 }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(1),\n\t\t\t\tintObject(2),\n\t\t\t\tintObject(3),\n\t\t\t\tintObject(4),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),   // 0000\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0003\n\t\t\t\t\ttengo.MakeInstruction(parser.OpTrue),          // 0004\n\t\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 19), // 0005\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),   // 0008\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0011\n\t\t\t\t\ttengo.MakeInstruction(parser.OpJump, 23),      // 0012\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),   // 0015\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0018\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),   // 0019\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),           // 0022\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))  // 0023\n\n\texpectCompile(t, `func() { }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `func() { 24 }()`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 0, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(24),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `func() { return 24 }()`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 0, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(24),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `noArg := func() { 24 }; noArg();`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 0, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(24),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `noArg := func() { return 24 }; noArg();`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 0, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(24),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `n := 55; func() { n };`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(55),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `func() { n := 55; return n }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(55),\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `func() { a := 55; b := 77; return a + b }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(55),\n\t\t\t\tintObject(77),\n\t\t\t\tcompiledFunction(2, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `f1 := func(a) { return a }; f1(24);`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 1, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tintObject(24))))\n\n\texpectCompile(t, `varTest := func(...a) { return a }; varTest(1,2,3);`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 3, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tintObject(1), intObject(2), intObject(3))))\n\n\texpectCompile(t, `f1 := func(a, b, c) { a; b; return c; }; f1(24, 25, 26);`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 3, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(3, 3,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 2),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tintObject(24),\n\t\t\t\tintObject(25),\n\t\t\t\tintObject(26))))\n\n\texpectCompile(t, `func() { n := 55; n = 23; return n }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(55),\n\t\t\t\tintObject(23),\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\texpectCompile(t, `len([]);`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpGetBuiltin, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpArray, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpCall, 1, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `func() { return len([]) }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetBuiltin, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpArray, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpCall, 1, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `func(a) { func(b) { return a + b } }`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocalPtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 0, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n\n\texpectCompile(t, `\nfunc(a) {\n\treturn func(b) {\n\t\treturn func(c) {\n\t\t\treturn a + b + c\n\t\t}\n\t}\n}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFreePtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocalPtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 0, 2),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tcompiledFunction(1, 1,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocalPtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 1, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `\ng := 55;\n\nfunc() {\n\ta := 66;\n\n\treturn func() {\n\t\tb := 77;\n\n\t\treturn func() {\n\t\t\tc := 88;\n\n\t\t\treturn g + a + b + c;\n\t\t}\n\t}\n}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 6),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(55),\n\t\t\t\tintObject(66),\n\t\t\t\tintObject(77),\n\t\t\t\tintObject(88),\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFree, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetFreePtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocalPtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 4, 2),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)),\n\t\t\t\tcompiledFunction(1, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocalPtr, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpClosure, 5, 1),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `for i:=0; i<10; i++ {}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 38),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 35),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpJump, 6),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(0),\n\t\t\t\tintObject(10),\n\t\t\t\tintObject(1))))\n\n\texpectCompile(t, `m := {}; for k, v in m {}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpMap, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpIteratorInit),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpIteratorNext),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 41),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpIteratorKey),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpIteratorValue),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpJump, 13),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray()))\n\n\texpectCompile(t, `a := 0; a == 0 && a != 1 || a < 1`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpAndJump, 25),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpNotEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpOrJump, 38),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 38),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(0),\n\t\t\t\tintObject(1))))\n\n\t// unknown module name\n\texpectCompileError(t, `import(\"user1\")`, \"module 'user1' not found\")\n\n\t// too many errors\n\texpectCompileError(t, `\nr[\"x\"] = {\n    @a:1,\n    @b:1,\n    @c:1,\n    @d:1,\n    @e:1,\n    @f:1,\n    @g:1,\n    @h:1,\n    @i:1,\n    @j:1,\n    @k:1\n}\n`, \"Parse Error: illegal character U+0040 '@'\\n\\tat test:3:5 (and 10 more errors)\")\n\n\texpectCompileError(t, `import(\"\")`, \"empty module name\")\n\n\t// https://github.com/d5/tengo/issues/314\n\texpectCompileError(t, `\n(func() {\n\tfn := fn()\n})()\n`, \"unresolved reference 'fn\")\n}\n\nfunc TestCompilerErrorReport(t *testing.T) {\n\texpectCompileError(t, `import(\"user1\")`,\n\t\t\"Compile Error: module 'user1' not found\\n\\tat test:1:1\")\n\n\texpectCompileError(t, `a = 1`,\n\t\t\"Compile Error: unresolved reference 'a'\\n\\tat test:1:1\")\n\texpectCompileError(t, `a := a`,\n\t\t\"Compile Error: unresolved reference 'a'\\n\\tat test:1:6\")\n\texpectCompileError(t, `a, b := 1, 2`,\n\t\t\"Compile Error: tuple assignment not allowed\\n\\tat test:1:1\")\n\texpectCompileError(t, `a.b := 1`,\n\t\t\"not allowed with selector\")\n\texpectCompileError(t, `a:=1; a:=3`,\n\t\t\"Compile Error: 'a' redeclared in this block\\n\\tat test:1:7\")\n\n\texpectCompileError(t, `return 5`,\n\t\t\"Compile Error: return not allowed outside function\\n\\tat test:1:1\")\n\texpectCompileError(t, `func() { break }`,\n\t\t\"Compile Error: break not allowed outside loop\\n\\tat test:1:10\")\n\texpectCompileError(t, `func() { continue }`,\n\t\t\"Compile Error: continue not allowed outside loop\\n\\tat test:1:10\")\n\texpectCompileError(t, `func() { export 5 }`,\n\t\t\"Compile Error: export not allowed inside function\\n\\tat test:1:10\")\n}\n\nfunc TestCompilerDeadCode(t *testing.T) {\n\texpectCompile(t, `\nfunc() {\n\ta := 4\n\treturn a\n\n\tb := 5 // dead code from here\n\tc := a\n\treturn b\n}`,\n\t\tbytecode(\n\t\t\tconcatInsts(\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\t\tobjectsArray(\n\t\t\t\tintObject(4),\n\t\t\t\tintObject(5),\n\t\t\t\tcompiledFunction(0, 0,\n\t\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `\nfunc() {\n\tif true {\n\t\treturn 5\n\t\ta := 4  // dead code from here\n\t\tb := a\n\t\treturn b\n\t} else {\n\t\treturn 4\n\t\tc := 5  // dead code from here\n\t\td := c\n\t\treturn d\n\t}\n}`, bytecode(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\tobjectsArray(\n\t\t\tintObject(5),\n\t\t\tintObject(4),\n\t\t\tcompiledFunction(0, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `\nfunc() {\n\ta := 1\n\tfor {\n\t\tif a == 5 {\n\t\t\treturn 10\n\t\t}\n\t\t5 + 5\n\t\treturn 20\n\t\tb := a\n\t\treturn b\n\t}\n}`, bytecode(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 4),\n\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\tobjectsArray(\n\t\t\tintObject(1),\n\t\t\tintObject(5),\n\t\t\tintObject(10),\n\t\t\tintObject(20),\n\t\t\tcompiledFunction(0, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpEqual),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 21),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `\nfunc() {\n\tif true {\n\t\treturn 5\n\t\ta := 4  // dead code from here\n\t\tb := a\n\t\treturn b\n\t} else {\n\t\treturn 4\n\t\tc := 5  // dead code from here\n\t\td := c\n\t\treturn d\n\t}\n}`, bytecode(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\tobjectsArray(\n\t\t\tintObject(5),\n\t\t\tintObject(4),\n\t\t\tcompiledFunction(0, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 11),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n\n\texpectCompile(t, `\nfunc() {\n\tif true {\n\t\treturn\n\t}\n\n    return\n\n    return 123\n}`, bytecode(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\tobjectsArray(\n\t\t\tintObject(123),\n\t\t\tcompiledFunction(0, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpTrue),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 8),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 1)))))\n}\n\nfunc TestCompilerScopes(t *testing.T) {\n\texpectCompile(t, `\nif a := 1; a {\n    a = 2\n\tb := a\n} else {\n    a = 3\n\tb := a\n}`, bytecode(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 31),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 1),\n\t\t\ttengo.MakeInstruction(parser.OpJump, 43),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpGetGlobal, 0),\n\t\t\ttengo.MakeInstruction(parser.OpSetGlobal, 2),\n\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\tobjectsArray(\n\t\t\tintObject(1),\n\t\t\tintObject(2),\n\t\t\tintObject(3))))\n\n\texpectCompile(t, `\nfunc() {\n\tif a := 1; a {\n    \ta = 2\n\t\tb := a\n\t} else {\n    \ta = 3\n\t\tb := a\n\t}\n}`, bytecode(\n\t\tconcatInsts(\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 3),\n\t\t\ttengo.MakeInstruction(parser.OpPop),\n\t\t\ttengo.MakeInstruction(parser.OpSuspend)),\n\t\tobjectsArray(\n\t\t\tintObject(1),\n\t\t\tintObject(2),\n\t\t\tintObject(3),\n\t\t\tcompiledFunction(0, 0,\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpJumpFalsy, 26),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpJump, 35),\n\t\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\t\ttengo.MakeInstruction(parser.OpSetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 0),\n\t\t\t\ttengo.MakeInstruction(parser.OpDefineLocal, 1),\n\t\t\t\ttengo.MakeInstruction(parser.OpReturn, 0)))))\n}\n\nfunc TestCompiler_custom_extension(t *testing.T) {\n\tpathFileSource := \"./testdata/issue286/test.mshk\"\n\n\tmodules := stdlib.GetModuleMap(stdlib.AllModuleNames()...)\n\n\tsrc, err := ioutil.ReadFile(pathFileSource)\n\trequire.NoError(t, err)\n\n\t// Escape shegang\n\tif len(src) > 1 && string(src[:2]) == \"#!\" {\n\t\tcopy(src, \"//\")\n\t}\n\n\tfileSet := parser.NewFileSet()\n\tsrcFile := fileSet.AddFile(filepath.Base(pathFileSource), -1, len(src))\n\n\tp := parser.NewParser(srcFile, src, nil)\n\tfile, err := p.ParseFile()\n\trequire.NoError(t, err)\n\n\tc := tengo.NewCompiler(srcFile, nil, nil, modules, nil)\n\tc.EnableFileImport(true)\n\tc.SetImportDir(filepath.Dir(pathFileSource))\n\n\t// Search for \"*.tengo\" and \".mshk\"(custom extension)\n\tc.SetImportFileExt(\".tengo\", \".mshk\")\n\n\terr = c.Compile(file)\n\trequire.NoError(t, err)\n}\n\nfunc TestCompilerNewCompiler_default_file_extension(t *testing.T) {\n\tmodules := stdlib.GetModuleMap(stdlib.AllModuleNames()...)\n\tinput := \"{}\"\n\tfileSet := parser.NewFileSet()\n\tfile := fileSet.AddFile(\"test\", -1, len(input))\n\n\tc := tengo.NewCompiler(file, nil, nil, modules, nil)\n\tc.EnableFileImport(true)\n\n\trequire.Equal(t, []string{\".tengo\"}, c.GetImportFileExt(),\n\t\t\"newly created compiler object must contain the default extension\")\n}\n\nfunc TestCompilerSetImportExt_extension_name_validation(t *testing.T) {\n\tc := new(tengo.Compiler) // Instantiate a new compiler object with no initialization\n\n\t// Test of empty arg\n\terr := c.SetImportFileExt()\n\n\trequire.Error(t, err, \"empty arg should return an error\")\n\n\t// Test of various arg types\n\tfor _, test := range []struct {\n\t\textensions []string\n\t\texpect     []string\n\t\trequireErr bool\n\t\tmsgFail    string\n\t}{\n\t\t{[]string{\".tengo\"}, []string{\".tengo\"}, false,\n\t\t\t\"well-formed extension should not return an error\"},\n\t\t{[]string{\"\"}, []string{\".tengo\"}, true,\n\t\t\t\"empty extension name should return an error\"},\n\t\t{[]string{\"foo\"}, []string{\".tengo\"}, true,\n\t\t\t\"name without dot prefix should return an error\"},\n\t\t{[]string{\"foo.bar\"}, []string{\".tengo\"}, true,\n\t\t\t\"malformed extension should return an error\"},\n\t\t{[]string{\"foo.\"}, []string{\".tengo\"}, true,\n\t\t\t\"malformed extension should return an error\"},\n\t\t{[]string{\".mshk\"}, []string{\".mshk\"}, false,\n\t\t\t\"name with dot prefix should be added\"},\n\t\t{[]string{\".foo\", \".bar\"}, []string{\".foo\", \".bar\"}, false,\n\t\t\t\"it should replace instead of appending\"},\n\t} {\n\t\terr := c.SetImportFileExt(test.extensions...)\n\t\tif test.requireErr {\n\t\t\trequire.Error(t, err, test.msgFail)\n\t\t}\n\n\t\texpect := test.expect\n\t\tactual := c.GetImportFileExt()\n\t\trequire.Equal(t, expect, actual, test.msgFail)\n\t}\n}\n\nfunc concatInsts(instructions ...[]byte) []byte {\n\tvar concat []byte\n\tfor _, i := range instructions {\n\t\tconcat = append(concat, i...)\n\t}\n\treturn concat\n}\n\nfunc bytecode(\n\tinstructions []byte,\n\tconstants []tengo.Object,\n) *tengo.Bytecode {\n\treturn &tengo.Bytecode{\n\t\tFileSet:      parser.NewFileSet(),\n\t\tMainFunction: &tengo.CompiledFunction{Instructions: instructions},\n\t\tConstants:    constants,\n\t}\n}\n\nfunc expectCompile(\n\tt *testing.T,\n\tinput string,\n\texpected *tengo.Bytecode,\n) {\n\tactual, trace, err := traceCompile(input, nil)\n\n\tvar ok bool\n\tdefer func() {\n\t\tif !ok {\n\t\t\tfor _, tr := range trace {\n\t\t\t\tt.Log(tr)\n\t\t\t}\n\t\t}\n\t}()\n\n\trequire.NoError(t, err)\n\tequalBytecode(t, expected, actual)\n\tok = true\n}\n\nfunc expectCompileError(t *testing.T, input, expected string) {\n\t_, trace, err := traceCompile(input, nil)\n\n\tvar ok bool\n\tdefer func() {\n\t\tif !ok {\n\t\t\tfor _, tr := range trace {\n\t\t\t\tt.Log(tr)\n\t\t\t}\n\t\t}\n\t}()\n\n\trequire.Error(t, err)\n\trequire.True(t, strings.Contains(err.Error(), expected),\n\t\t\"expected error string: %s, got: %s\", expected, err.Error())\n\tok = true\n}\n\nfunc equalBytecode(t *testing.T, expected, actual *tengo.Bytecode) {\n\trequire.Equal(t, expected.MainFunction, actual.MainFunction)\n\tequalConstants(t, expected.Constants, actual.Constants)\n}\n\nfunc equalConstants(t *testing.T, expected, actual []tengo.Object) {\n\trequire.Equal(t, len(expected), len(actual))\n\tfor i := 0; i < len(expected); i++ {\n\t\trequire.Equal(t, expected[i], actual[i])\n\t}\n}\n\ntype compileTracer struct {\n\tOut []string\n}\n\nfunc (o *compileTracer) Write(p []byte) (n int, err error) {\n\to.Out = append(o.Out, string(p))\n\treturn len(p), nil\n}\n\nfunc traceCompile(\n\tinput string,\n\tsymbols map[string]tengo.Object,\n) (res *tengo.Bytecode, trace []string, err error) {\n\tfileSet := parser.NewFileSet()\n\tfile := fileSet.AddFile(\"test\", -1, len(input))\n\n\tp := parser.NewParser(file, []byte(input), nil)\n\n\tsymTable := tengo.NewSymbolTable()\n\tfor name := range symbols {\n\t\tsymTable.Define(name)\n\t}\n\tfor idx, fn := range tengo.GetAllBuiltinFunctions() {\n\t\tsymTable.DefineBuiltin(idx, fn.Name)\n\t}\n\n\ttr := &compileTracer{}\n\tc := tengo.NewCompiler(file, symTable, nil, nil, tr)\n\tparsed, err := p.ParseFile()\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = c.Compile(parsed)\n\tres = c.Bytecode()\n\tres.RemoveDuplicates()\n\t{\n\t\ttrace = append(trace, fmt.Sprintf(\"Compiler Trace:\\n%s\",\n\t\t\tstrings.Join(tr.Out, \"\")))\n\t\ttrace = append(trace, fmt.Sprintf(\"Compiled Constants:\\n%s\",\n\t\t\tstrings.Join(res.FormatConstants(), \"\\n\")))\n\t\ttrace = append(trace, fmt.Sprintf(\"Compiled Instructions:\\n%s\\n\",\n\t\t\tstrings.Join(res.FormatInstructions(), \"\\n\")))\n\t}\n\tif err != nil {\n\t\treturn\n\t}\n\treturn\n}\n\nfunc objectsArray(o ...tengo.Object) []tengo.Object {\n\treturn o\n}\n\nfunc intObject(v int64) *tengo.Int {\n\treturn &tengo.Int{Value: v}\n}\n\nfunc stringObject(v string) *tengo.String {\n\treturn &tengo.String{Value: v}\n}\n\nfunc compiledFunction(\n\tnumLocals, numParams int,\n\tinsts ...[]byte,\n) *tengo.CompiledFunction {\n\treturn &tengo.CompiledFunction{\n\t\tInstructions:  concatInsts(insts...),\n\t\tNumLocals:     numLocals,\n\t\tNumParameters: numParams,\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.080078125,
          "content": "// tengo is a small, dynamic, fast, secure script language for Go.\n\npackage tengo\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.23828125,
          "content": "package tengo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\nvar (\n\t// ErrStackOverflow is a stack overflow error.\n\tErrStackOverflow = errors.New(\"stack overflow\")\n\n\t// ErrObjectAllocLimit is an objects allocation limit error.\n\tErrObjectAllocLimit = errors.New(\"object allocation limit exceeded\")\n\n\t// ErrIndexOutOfBounds is an error where a given index is out of the\n\t// bounds.\n\tErrIndexOutOfBounds = errors.New(\"index out of bounds\")\n\n\t// ErrInvalidIndexType represents an invalid index type.\n\tErrInvalidIndexType = errors.New(\"invalid index type\")\n\n\t// ErrInvalidIndexValueType represents an invalid index value type.\n\tErrInvalidIndexValueType = errors.New(\"invalid index value type\")\n\n\t// ErrInvalidIndexOnError represents an invalid index on error.\n\tErrInvalidIndexOnError = errors.New(\"invalid index on error\")\n\n\t// ErrInvalidOperator represents an error for invalid operator usage.\n\tErrInvalidOperator = errors.New(\"invalid operator\")\n\n\t// ErrWrongNumArguments represents a wrong number of arguments error.\n\tErrWrongNumArguments = errors.New(\"wrong number of arguments\")\n\n\t// ErrBytesLimit represents an error where the size of bytes value exceeds\n\t// the limit.\n\tErrBytesLimit = errors.New(\"exceeding bytes size limit\")\n\n\t// ErrStringLimit represents an error where the size of string value\n\t// exceeds the limit.\n\tErrStringLimit = errors.New(\"exceeding string size limit\")\n\n\t// ErrNotIndexable is an error where an Object is not indexable.\n\tErrNotIndexable = errors.New(\"not indexable\")\n\n\t// ErrNotIndexAssignable is an error where an Object is not index\n\t// assignable.\n\tErrNotIndexAssignable = errors.New(\"not index-assignable\")\n\n\t// ErrNotImplemented is an error where an Object has not implemented a\n\t// required method.\n\tErrNotImplemented = errors.New(\"not implemented\")\n\n\t// ErrInvalidRangeStep is an error where the step parameter is less than or equal to 0 when using builtin range function.\n\tErrInvalidRangeStep = errors.New(\"range step must be greater than 0\")\n)\n\n// ErrInvalidArgumentType represents an invalid argument value type error.\ntype ErrInvalidArgumentType struct {\n\tName     string\n\tExpected string\n\tFound    string\n}\n\nfunc (e ErrInvalidArgumentType) Error() string {\n\treturn fmt.Sprintf(\"invalid type for argument '%s': expected %s, found %s\",\n\t\te.Name, e.Expected, e.Found)\n}\n"
        },
        {
          "name": "eval.go",
          "type": "blob",
          "size": 0.8447265625,
          "content": "package tengo\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Eval compiles and executes given expr with params, and returns an\n// evaluated value. expr must be an expression. Otherwise it will fail to\n// compile. Expression must not use or define variable \"__res__\" as it's\n// reserved for the internal usage.\nfunc Eval(\n\tctx context.Context,\n\texpr string,\n\tparams map[string]interface{},\n) (interface{}, error) {\n\texpr = strings.TrimSpace(expr)\n\tif expr == \"\" {\n\t\treturn nil, fmt.Errorf(\"empty expression\")\n\t}\n\n\tscript := NewScript([]byte(fmt.Sprintf(\"__res__ := (%s)\", expr)))\n\tfor pk, pv := range params {\n\t\terr := script.Add(pk, pv)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"script add: %w\", err)\n\t\t}\n\t}\n\tcompiled, err := script.RunContext(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"script run: %w\", err)\n\t}\n\treturn compiled.Get(\"__res__\").Value(), nil\n}\n"
        },
        {
          "name": "eval_test.go",
          "type": "blob",
          "size": 0.88671875,
          "content": "package tengo_test\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/require\"\n)\n\nfunc TestEval(t *testing.T) {\n\teval := func(\n\t\texpr string,\n\t\tparams map[string]interface{},\n\t\texpected interface{},\n\t) {\n\t\tctx := context.Background()\n\t\tactual, err := tengo.Eval(ctx, expr, params)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, expected, actual)\n\t}\n\n\teval(`undefined`, nil, nil)\n\teval(`1`, nil, int64(1))\n\teval(`19 + 23`, nil, int64(42))\n\teval(`\"foo bar\"`, nil, \"foo bar\")\n\teval(`[1, 2, 3][1]`, nil, int64(2))\n\n\teval(\n\t\t`5 + p`,\n\t\tmap[string]interface{}{\n\t\t\t\"p\": 7,\n\t\t},\n\t\tint64(12),\n\t)\n\teval(\n\t\t`\"seven is \" + p`,\n\t\tmap[string]interface{}{\n\t\t\t\"p\": 7,\n\t\t},\n\t\t\"seven is 7\",\n\t)\n\teval(\n\t\t`\"\" + a + b`,\n\t\tmap[string]interface{}{\n\t\t\t\"a\": 7,\n\t\t\t\"b\": \" is seven\",\n\t\t},\n\t\t\"7 is seven\",\n\t)\n\n\teval(\n\t\t`a ? \"success\" : \"fail\"`,\n\t\tmap[string]interface{}{\n\t\t\t\"a\": 1,\n\t\t},\n\t\t\"success\",\n\t)\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.658203125,
          "content": "package tengo_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/d5/tengo/v2\"\n)\n\nfunc Example() {\n\t// Tengo script code\n\tsrc := `\neach := func(seq, fn) {\n    for x in seq { fn(x) }\n}\n\nsum := 0\nmul := 1\neach([a, b, c, d], func(x) {\n\tsum += x\n\tmul *= x\n})`\n\n\t// create a new Script instance\n\tscript := tengo.NewScript([]byte(src))\n\n\t// set values\n\t_ = script.Add(\"a\", 1)\n\t_ = script.Add(\"b\", 9)\n\t_ = script.Add(\"c\", 8)\n\t_ = script.Add(\"d\", 4)\n\n\t// run the script\n\tcompiled, err := script.RunContext(context.Background())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// retrieve values\n\tsum := compiled.Get(\"sum\")\n\tmul := compiled.Get(\"mul\")\n\tfmt.Println(sum, mul)\n\n\t// Output:\n\t// 22 288\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "formatter.go",
          "type": "blob",
          "size": 27.91796875,
          "content": "package tengo\n\nimport (\n\t\"strconv\"\n\t\"sync\"\n\t\"unicode/utf8\"\n)\n\n// Strings for use with fmtbuf.WriteString. This is less overhead than using\n// fmtbuf.Write with byte arrays.\nconst (\n\tcommaSpaceString  = \", \"\n\tnilParenString    = \"(nil)\"\n\tpercentBangString = \"%!\"\n\tmissingString     = \"(MISSING)\"\n\tbadIndexString    = \"(BADINDEX)\"\n\textraString       = \"%!(EXTRA \"\n\tbadWidthString    = \"%!(BADWIDTH)\"\n\tbadPrecString     = \"%!(BADPREC)\"\n\tnoVerbString      = \"%!(NOVERB)\"\n)\n\nconst (\n\tldigits = \"0123456789abcdefx\"\n\tudigits = \"0123456789ABCDEFX\"\n)\n\nconst (\n\tsigned   = true\n\tunsigned = false\n)\n\n// flags placed in a separate struct for easy clearing.\ntype fmtFlags struct {\n\twidPresent  bool\n\tprecPresent bool\n\tminus       bool\n\tplus        bool\n\tsharp       bool\n\tspace       bool\n\tzero        bool\n\n\t// For the formats %+v %#v, we set the plusV/sharpV flags\n\t// and clear the plus/sharp flags since %+v and %#v are in effect\n\t// different, flagless formats set at the top level.\n\tplusV  bool\n\tsharpV bool\n\n\t// error-related flags.\n\tinDetail    bool\n\tneedNewline bool\n\tneedColon   bool\n}\n\n// A formatter is the raw formatter used by Printf etc.\n// It prints into a fmtbuf that must be set up separately.\ntype formatter struct {\n\tbuf *fmtbuf\n\n\tfmtFlags\n\n\twid  int // width\n\tprec int // precision\n\n\t// intbuf is large enough to store %b of an int64 with a sign and\n\t// avoids padding at the end of the struct on 32 bit architectures.\n\tintbuf [68]byte\n}\n\nfunc (f *formatter) clearFlags() {\n\tf.fmtFlags = fmtFlags{}\n}\n\nfunc (f *formatter) init(buf *fmtbuf) {\n\tf.buf = buf\n\tf.clearFlags()\n}\n\n// writePadding generates n bytes of padding.\nfunc (f *formatter) writePadding(n int) {\n\tif n <= 0 { // No padding bytes needed.\n\t\treturn\n\t}\n\tbuf := *f.buf\n\toldLen := len(buf)\n\tnewLen := oldLen + n\n\n\tif newLen > MaxStringLen {\n\t\tpanic(ErrStringLimit)\n\t}\n\n\t// Make enough room for padding.\n\tif newLen > cap(buf) {\n\t\tbuf = make(fmtbuf, cap(buf)*2+n)\n\t\tcopy(buf, *f.buf)\n\t}\n\t// Decide which byte the padding should be filled with.\n\tpadByte := byte(' ')\n\tif f.zero {\n\t\tpadByte = byte('0')\n\t}\n\t// Fill padding with padByte.\n\tpadding := buf[oldLen:newLen]\n\tfor i := range padding {\n\t\tpadding[i] = padByte\n\t}\n\t*f.buf = buf[:newLen]\n}\n\n// pad appends b to f.buf, padded on left (!f.minus) or right (f.minus).\nfunc (f *formatter) pad(b []byte) {\n\tif !f.widPresent || f.wid == 0 {\n\t\tf.buf.Write(b)\n\t\treturn\n\t}\n\twidth := f.wid - utf8.RuneCount(b)\n\tif !f.minus {\n\t\t// left padding\n\t\tf.writePadding(width)\n\t\tf.buf.Write(b)\n\t} else {\n\t\t// right padding\n\t\tf.buf.Write(b)\n\t\tf.writePadding(width)\n\t}\n}\n\n// padString appends s to f.buf, padded on left (!f.minus) or right (f.minus).\nfunc (f *formatter) padString(s string) {\n\tif !f.widPresent || f.wid == 0 {\n\t\tf.buf.WriteString(s)\n\t\treturn\n\t}\n\twidth := f.wid - utf8.RuneCountInString(s)\n\tif !f.minus {\n\t\t// left padding\n\t\tf.writePadding(width)\n\t\tf.buf.WriteString(s)\n\t} else {\n\t\t// right padding\n\t\tf.buf.WriteString(s)\n\t\tf.writePadding(width)\n\t}\n}\n\n// fmtBoolean formats a boolean.\nfunc (f *formatter) fmtBoolean(v bool) {\n\tif v {\n\t\tf.padString(\"true\")\n\t} else {\n\t\tf.padString(\"false\")\n\t}\n}\n\n// fmtUnicode formats a uint64 as \"U+0078\" or with f.sharp set as \"U+0078 'x'\".\nfunc (f *formatter) fmtUnicode(u uint64) {\n\tbuf := f.intbuf[0:]\n\n\t// With default precision set the maximum needed buf length is 18\n\t// for formatting -1 with %#U (\"U+FFFFFFFFFFFFFFFF\") which fits\n\t// into the already allocated intbuf with a capacity of 68 bytes.\n\tprec := 4\n\tif f.precPresent && f.prec > 4 {\n\t\tprec = f.prec\n\t\t// Compute space needed for \"U+\" , number, \" '\", character, \"'\".\n\t\twidth := 2 + prec + 2 + utf8.UTFMax + 1\n\t\tif width > len(buf) {\n\t\t\tbuf = make([]byte, width)\n\t\t}\n\t}\n\n\t// Format into buf, ending at buf[i]. Formatting numbers is easier\n\t// right-to-left.\n\ti := len(buf)\n\n\t// For %#U we want to add a space and a quoted character at the end of\n\t// the fmtbuf.\n\tif f.sharp && u <= utf8.MaxRune && strconv.IsPrint(rune(u)) {\n\t\ti--\n\t\tbuf[i] = '\\''\n\t\ti -= utf8.RuneLen(rune(u))\n\t\tutf8.EncodeRune(buf[i:], rune(u))\n\t\ti--\n\t\tbuf[i] = '\\''\n\t\ti--\n\t\tbuf[i] = ' '\n\t}\n\t// Format the Unicode code point u as a hexadecimal number.\n\tfor u >= 16 {\n\t\ti--\n\t\tbuf[i] = udigits[u&0xF]\n\t\tprec--\n\t\tu >>= 4\n\t}\n\ti--\n\tbuf[i] = udigits[u]\n\tprec--\n\t// Add zeros in front of the number until requested precision is reached.\n\tfor prec > 0 {\n\t\ti--\n\t\tbuf[i] = '0'\n\t\tprec--\n\t}\n\t// Add a leading \"U+\".\n\ti--\n\tbuf[i] = '+'\n\ti--\n\tbuf[i] = 'U'\n\n\toldZero := f.zero\n\tf.zero = false\n\tf.pad(buf[i:])\n\tf.zero = oldZero\n}\n\n// fmtInteger formats signed and unsigned integers.\nfunc (f *formatter) fmtInteger(\n\tu uint64,\n\tbase int,\n\tisSigned bool,\n\tverb rune,\n\tdigits string,\n) {\n\tnegative := isSigned && int64(u) < 0\n\tif negative {\n\t\tu = -u\n\t}\n\n\tbuf := f.intbuf[0:]\n\t// The already allocated f.intbuf with a capacity of 68 bytes\n\t// is large enough for integer formatting when no precision or width is set.\n\tif f.widPresent || f.precPresent {\n\t\t// Account 3 extra bytes for possible addition of a sign and \"0x\".\n\t\twidth := 3 + f.wid + f.prec // wid and prec are always positive.\n\t\tif width > len(buf) {\n\t\t\t// We're going to need a bigger boat.\n\t\t\tbuf = make([]byte, width)\n\t\t}\n\t}\n\n\t// Two ways to ask for extra leading zero digits: %.3d or %03d.\n\t// If both are specified the f.zero flag is ignored and\n\t// padding with spaces is used instead.\n\tprec := 0\n\tif f.precPresent {\n\t\tprec = f.prec\n\t\t// Precision of 0 and value of 0 means \"print nothing\" but padding.\n\t\tif prec == 0 && u == 0 {\n\t\t\toldZero := f.zero\n\t\t\tf.zero = false\n\t\t\tf.writePadding(f.wid)\n\t\t\tf.zero = oldZero\n\t\t\treturn\n\t\t}\n\t} else if f.zero && f.widPresent {\n\t\tprec = f.wid\n\t\tif negative || f.plus || f.space {\n\t\t\tprec-- // leave room for sign\n\t\t}\n\t}\n\n\t// Because printing is easier right-to-left: format u into buf, ending at\n\t// buf[i]. We could make things marginally faster by splitting the 32-bit\n\t// case out into a separate block but it's not worth the duplication, so\n\t// u has 64 bits.\n\ti := len(buf)\n\t// Use constants for the division and modulo for more efficient code.\n\t// Switch cases ordered by popularity.\n\tswitch base {\n\tcase 10:\n\t\tfor u >= 10 {\n\t\t\ti--\n\t\t\tnext := u / 10\n\t\t\tbuf[i] = byte('0' + u - next*10)\n\t\t\tu = next\n\t\t}\n\tcase 16:\n\t\tfor u >= 16 {\n\t\t\ti--\n\t\t\tbuf[i] = digits[u&0xF]\n\t\t\tu >>= 4\n\t\t}\n\tcase 8:\n\t\tfor u >= 8 {\n\t\t\ti--\n\t\t\tbuf[i] = byte('0' + u&7)\n\t\t\tu >>= 3\n\t\t}\n\tcase 2:\n\t\tfor u >= 2 {\n\t\t\ti--\n\t\t\tbuf[i] = byte('0' + u&1)\n\t\t\tu >>= 1\n\t\t}\n\tdefault:\n\t\tpanic(\"fmt: unknown base; can't happen\")\n\t}\n\ti--\n\tbuf[i] = digits[u]\n\tfor i > 0 && prec > len(buf)-i {\n\t\ti--\n\t\tbuf[i] = '0'\n\t}\n\n\t// Various prefixes: 0x, -, etc.\n\tif f.sharp {\n\t\tswitch base {\n\t\tcase 2:\n\t\t\t// Add a leading 0b.\n\t\t\ti--\n\t\t\tbuf[i] = 'b'\n\t\t\ti--\n\t\t\tbuf[i] = '0'\n\t\tcase 8:\n\t\t\tif buf[i] != '0' {\n\t\t\t\ti--\n\t\t\t\tbuf[i] = '0'\n\t\t\t}\n\t\tcase 16:\n\t\t\t// Add a leading 0x or 0X.\n\t\t\ti--\n\t\t\tbuf[i] = digits[16]\n\t\t\ti--\n\t\t\tbuf[i] = '0'\n\t\t}\n\t}\n\tif verb == 'O' {\n\t\ti--\n\t\tbuf[i] = 'o'\n\t\ti--\n\t\tbuf[i] = '0'\n\t}\n\n\tif negative {\n\t\ti--\n\t\tbuf[i] = '-'\n\t} else if f.plus {\n\t\ti--\n\t\tbuf[i] = '+'\n\t} else if f.space {\n\t\ti--\n\t\tbuf[i] = ' '\n\t}\n\n\t// Left padding with zeros has already been handled like precision earlier\n\t// or the f.zero flag is ignored due to an explicitly set precision.\n\toldZero := f.zero\n\tf.zero = false\n\tf.pad(buf[i:])\n\tf.zero = oldZero\n}\n\n// truncate truncates the string s to the specified precision, if present.\nfunc (f *formatter) truncateString(s string) string {\n\tif f.precPresent {\n\t\tn := f.prec\n\t\tfor i := range s {\n\t\t\tn--\n\t\t\tif n < 0 {\n\t\t\t\treturn s[:i]\n\t\t\t}\n\t\t}\n\t}\n\treturn s\n}\n\n// truncate truncates the byte slice b as a string of the specified precision,\n// if present.\nfunc (f *formatter) truncate(b []byte) []byte {\n\tif f.precPresent {\n\t\tn := f.prec\n\t\tfor i := 0; i < len(b); {\n\t\t\tn--\n\t\t\tif n < 0 {\n\t\t\t\treturn b[:i]\n\t\t\t}\n\t\t\twid := 1\n\t\t\tif b[i] >= utf8.RuneSelf {\n\t\t\t\t_, wid = utf8.DecodeRune(b[i:])\n\t\t\t}\n\t\t\ti += wid\n\t\t}\n\t}\n\treturn b\n}\n\n// fmtS formats a string.\nfunc (f *formatter) fmtS(s string) {\n\ts = f.truncateString(s)\n\tf.padString(s)\n}\n\n// fmtBs formats the byte slice b as if it was formatted as string with fmtS.\nfunc (f *formatter) fmtBs(b []byte) {\n\tb = f.truncate(b)\n\tf.pad(b)\n}\n\n// fmtSbx formats a string or byte slice as a hexadecimal encoding of its bytes.\nfunc (f *formatter) fmtSbx(s string, b []byte, digits string) {\n\tlength := len(b)\n\tif b == nil {\n\t\t// No byte slice present. Assume string s should be encoded.\n\t\tlength = len(s)\n\t}\n\t// Set length to not process more bytes than the precision demands.\n\tif f.precPresent && f.prec < length {\n\t\tlength = f.prec\n\t}\n\t// Compute width of the encoding taking into account the f.sharp and\n\t// f.space flag.\n\twidth := 2 * length\n\tif width > 0 {\n\t\tif f.space {\n\t\t\t// Each element encoded by two hexadecimals will get a leading\n\t\t\t// 0x or 0X.\n\t\t\tif f.sharp {\n\t\t\t\twidth *= 2\n\t\t\t}\n\t\t\t// Elements will be separated by a space.\n\t\t\twidth += length - 1\n\t\t} else if f.sharp {\n\t\t\t// Only a leading 0x or 0X will be added for the whole string.\n\t\t\twidth += 2\n\t\t}\n\t} else { // The byte slice or string that should be encoded is empty.\n\t\tif f.widPresent {\n\t\t\tf.writePadding(f.wid)\n\t\t}\n\t\treturn\n\t}\n\t// Handle padding to the left.\n\tif f.widPresent && f.wid > width && !f.minus {\n\t\tf.writePadding(f.wid - width)\n\t}\n\t// Write the encoding directly into the output fmtbuf.\n\tbuf := *f.buf\n\tif f.sharp {\n\t\t// Add leading 0x or 0X.\n\t\tbuf = append(buf, '0', digits[16])\n\t}\n\tvar c byte\n\tfor i := 0; i < length; i++ {\n\t\tif f.space && i > 0 {\n\t\t\t// Separate elements with a space.\n\t\t\tbuf = append(buf, ' ')\n\t\t\tif f.sharp {\n\t\t\t\t// Add leading 0x or 0X for each element.\n\t\t\t\tbuf = append(buf, '0', digits[16])\n\t\t\t}\n\t\t}\n\t\tif b != nil {\n\t\t\tc = b[i] // Take a byte from the input byte slice.\n\t\t} else {\n\t\t\tc = s[i] // Take a byte from the input string.\n\t\t}\n\t\t// Encode each byte as two hexadecimal digits.\n\t\tbuf = append(buf, digits[c>>4], digits[c&0xF])\n\t}\n\t*f.buf = buf\n\t// Handle padding to the right.\n\tif f.widPresent && f.wid > width && f.minus {\n\t\tf.writePadding(f.wid - width)\n\t}\n}\n\n// fmtSx formats a string as a hexadecimal encoding of its bytes.\nfunc (f *formatter) fmtSx(s, digits string) {\n\tf.fmtSbx(s, nil, digits)\n}\n\n// fmtBx formats a byte slice as a hexadecimal encoding of its bytes.\nfunc (f *formatter) fmtBx(b []byte, digits string) {\n\tf.fmtSbx(\"\", b, digits)\n}\n\n// fmtQ formats a string as a double-quoted, escaped Go string constant.\n// If f.sharp is set a raw (backquoted) string may be returned instead\n// if the string does not contain any control characters other than tab.\nfunc (f *formatter) fmtQ(s string) {\n\ts = f.truncateString(s)\n\tif f.sharp && strconv.CanBackquote(s) {\n\t\tf.padString(\"`\" + s + \"`\")\n\t\treturn\n\t}\n\tbuf := f.intbuf[:0]\n\tif f.plus {\n\t\tf.pad(strconv.AppendQuoteToASCII(buf, s))\n\t} else {\n\t\tf.pad(strconv.AppendQuote(buf, s))\n\t}\n}\n\n// fmtC formats an integer as a Unicode character.\n// If the character is not valid Unicode, it will print '\\ufffd'.\nfunc (f *formatter) fmtC(c uint64) {\n\tr := rune(c)\n\tif c > utf8.MaxRune {\n\t\tr = utf8.RuneError\n\t}\n\tbuf := f.intbuf[:0]\n\tw := utf8.EncodeRune(buf[:utf8.UTFMax], r)\n\tf.pad(buf[:w])\n}\n\n// fmtQc formats an integer as a single-quoted, escaped Go character constant.\n// If the character is not valid Unicode, it will print '\\ufffd'.\nfunc (f *formatter) fmtQc(c uint64) {\n\tr := rune(c)\n\tif c > utf8.MaxRune {\n\t\tr = utf8.RuneError\n\t}\n\tbuf := f.intbuf[:0]\n\tif f.plus {\n\t\tf.pad(strconv.AppendQuoteRuneToASCII(buf, r))\n\t} else {\n\t\tf.pad(strconv.AppendQuoteRune(buf, r))\n\t}\n}\n\n// fmtFloat formats a float64. It assumes that verb is a valid format specifier\n// for strconv.AppendFloat and therefore fits into a byte.\nfunc (f *formatter) fmtFloat(v float64, size int, verb rune, prec int) {\n\t// Explicit precision in format specifier overrules default precision.\n\tif f.precPresent {\n\t\tprec = f.prec\n\t}\n\t// Format number, reserving space for leading + sign if needed.\n\tnum := strconv.AppendFloat(f.intbuf[:1], v, byte(verb), prec, size)\n\tif num[1] == '-' || num[1] == '+' {\n\t\tnum = num[1:]\n\t} else {\n\t\tnum[0] = '+'\n\t}\n\t// f.space means to add a leading space instead of a \"+\" sign unless\n\t// the sign is explicitly asked for by f.plus.\n\tif f.space && num[0] == '+' && !f.plus {\n\t\tnum[0] = ' '\n\t}\n\t// Special handling for infinities and NaN,\n\t// which don't look like a number so shouldn't be padded with zeros.\n\tif num[1] == 'I' || num[1] == 'N' {\n\t\toldZero := f.zero\n\t\tf.zero = false\n\t\t// Remove sign before NaN if not asked for.\n\t\tif num[1] == 'N' && !f.space && !f.plus {\n\t\t\tnum = num[1:]\n\t\t}\n\t\tf.pad(num)\n\t\tf.zero = oldZero\n\t\treturn\n\t}\n\t// The sharp flag forces printing a decimal point for non-binary formats\n\t// and retains trailing zeros, which we may need to restore.\n\tif f.sharp && verb != 'b' {\n\t\tdigits := 0\n\t\tswitch verb {\n\t\tcase 'v', 'g', 'G', 'x':\n\t\t\tdigits = prec\n\t\t\t// If no precision is set explicitly use a precision of 6.\n\t\t\tif digits == -1 {\n\t\t\t\tdigits = 6\n\t\t\t}\n\t\t}\n\n\t\t// Buffer pre-allocated with enough room for\n\t\t// exponent notations of the form \"e+123\" or \"p-1023\".\n\t\tvar tailBuf [6]byte\n\t\ttail := tailBuf[:0]\n\n\t\thasDecimalPoint := false\n\t\t// Starting from i = 1 to skip sign at num[0].\n\t\tfor i := 1; i < len(num); i++ {\n\t\t\tswitch num[i] {\n\t\t\tcase '.':\n\t\t\t\thasDecimalPoint = true\n\t\t\tcase 'p', 'P':\n\t\t\t\ttail = append(tail, num[i:]...)\n\t\t\t\tnum = num[:i]\n\t\t\tcase 'e', 'E':\n\t\t\t\tif verb != 'x' && verb != 'X' {\n\t\t\t\t\ttail = append(tail, num[i:]...)\n\t\t\t\t\tnum = num[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tfallthrough\n\t\t\tdefault:\n\t\t\t\tdigits--\n\t\t\t}\n\t\t}\n\t\tif !hasDecimalPoint {\n\t\t\tnum = append(num, '.')\n\t\t}\n\t\tfor digits > 0 {\n\t\t\tnum = append(num, '0')\n\t\t\tdigits--\n\t\t}\n\t\tnum = append(num, tail...)\n\t}\n\t// We want a sign if asked for and if the sign is not positive.\n\tif f.plus || num[0] != '+' {\n\t\t// If we're zero padding to the left we want the sign before the\n\t\t// leading zeros. Achieve this by writing the sign out and then padding\n\t\t// the unsigned number.\n\t\tif f.zero && f.widPresent && f.wid > len(num) {\n\t\t\tf.buf.WriteSingleByte(num[0])\n\t\t\tf.writePadding(f.wid - len(num))\n\t\t\tf.buf.Write(num[1:])\n\t\t\treturn\n\t\t}\n\t\tf.pad(num)\n\t\treturn\n\t}\n\t// No sign to show and the number is positive; just print the unsigned\n\t// number.\n\tf.pad(num[1:])\n}\n\n// Use simple []byte instead of bytes.Buffer to avoid large dependency.\ntype fmtbuf []byte\n\nfunc (b *fmtbuf) Write(p []byte) {\n\tif len(*b)+len(p) > MaxStringLen {\n\t\tpanic(ErrStringLimit)\n\t}\n\n\t*b = append(*b, p...)\n}\n\nfunc (b *fmtbuf) WriteString(s string) {\n\tif len(*b)+len(s) > MaxStringLen {\n\t\tpanic(ErrStringLimit)\n\t}\n\n\t*b = append(*b, s...)\n}\n\nfunc (b *fmtbuf) WriteSingleByte(c byte) {\n\tif len(*b) >= MaxStringLen {\n\t\tpanic(ErrStringLimit)\n\t}\n\n\t*b = append(*b, c)\n}\n\nfunc (b *fmtbuf) WriteRune(r rune) {\n\tif len(*b)+utf8.RuneLen(r) > MaxStringLen {\n\t\tpanic(ErrStringLimit)\n\t}\n\n\tif r < utf8.RuneSelf {\n\t\t*b = append(*b, byte(r))\n\t\treturn\n\t}\n\n\tb2 := *b\n\tn := len(b2)\n\tfor n+utf8.UTFMax > cap(b2) {\n\t\tb2 = append(b2, 0)\n\t}\n\tw := utf8.EncodeRune(b2[n:n+utf8.UTFMax], r)\n\t*b = b2[:n+w]\n}\n\n// pp is used to store a printer's state and is reused with sync.Pool to avoid\n// allocations.\ntype pp struct {\n\tbuf fmtbuf\n\n\t// arg holds the current item.\n\targ Object\n\n\t// fmt is used to format basic items such as integers or strings.\n\tfmt formatter\n\n\t// reordered records whether the format string used argument reordering.\n\treordered bool\n\n\t// goodArgNum records whether the most recent reordering directive was\n\t// valid.\n\tgoodArgNum bool\n\n\t// erroring is set when printing an error string to guard against calling\n\t// handleMethods.\n\terroring bool\n}\n\nvar ppFree = sync.Pool{\n\tNew: func() interface{} { return new(pp) },\n}\n\n// newPrinter allocates a new pp struct or grabs a cached one.\nfunc newPrinter() *pp {\n\tp := ppFree.Get().(*pp)\n\tp.erroring = false\n\tp.fmt.init(&p.buf)\n\treturn p\n}\n\n// free saves used pp structs in ppFree; avoids an allocation per invocation.\nfunc (p *pp) free() {\n\t// Proper usage of a sync.Pool requires each entry to have approximately\n\t// the same memory cost. To obtain this property when the stored type\n\t// contains a variably-sized fmtbuf, we add a hard limit on the maximum\n\t// fmtbuf to place back in the pool.\n\t//\n\t// See https://golang.org/issue/23199\n\tif cap(p.buf) > 64<<10 {\n\t\treturn\n\t}\n\n\tp.buf = p.buf[:0]\n\tp.arg = nil\n\tppFree.Put(p)\n}\n\nfunc (p *pp) Width() (wid int, ok bool) {\n\treturn p.fmt.wid, p.fmt.widPresent\n}\n\nfunc (p *pp) Precision() (prec int, ok bool) {\n\treturn p.fmt.prec, p.fmt.precPresent\n}\n\nfunc (p *pp) Flag(b int) bool {\n\tswitch b {\n\tcase '-':\n\t\treturn p.fmt.minus\n\tcase '+':\n\t\treturn p.fmt.plus || p.fmt.plusV\n\tcase '#':\n\t\treturn p.fmt.sharp || p.fmt.sharpV\n\tcase ' ':\n\t\treturn p.fmt.space\n\tcase '0':\n\t\treturn p.fmt.zero\n\t}\n\treturn false\n}\n\n// Implement Write so we can call Fprintf on a pp (through State), for\n// recursive use in custom verbs.\nfunc (p *pp) Write(b []byte) (ret int, err error) {\n\tp.buf.Write(b)\n\treturn len(b), nil\n}\n\n// Implement WriteString so that we can call io.WriteString\n// on a pp (through state), for efficiency.\nfunc (p *pp) WriteString(s string) (ret int, err error) {\n\tp.buf.WriteString(s)\n\treturn len(s), nil\n}\n\nfunc (p *pp) WriteRune(r rune) (ret int, err error) {\n\tp.buf.WriteRune(r)\n\treturn utf8.RuneLen(r), nil\n}\n\nfunc (p *pp) WriteSingleByte(c byte) (ret int, err error) {\n\tp.buf.WriteSingleByte(c)\n\treturn 1, nil\n}\n\n// tooLarge reports whether the magnitude of the integer is\n// too large to be used as a formatting width or precision.\nfunc tooLarge(x int) bool {\n\tconst max int = 1e6\n\treturn x > max || x < -max\n}\n\n// parsenum converts ASCII to integer.  num is 0 (and isnum is false) if no\n// number present.\nfunc parsenum(s string, start, end int) (num int, isnum bool, newi int) {\n\tif start >= end {\n\t\treturn 0, false, end\n\t}\n\tfor newi = start; newi < end && '0' <= s[newi] && s[newi] <= '9'; newi++ {\n\t\tif tooLarge(num) {\n\t\t\treturn 0, false, end // Overflow; crazy long number most likely.\n\t\t}\n\t\tnum = num*10 + int(s[newi]-'0')\n\t\tisnum = true\n\t}\n\treturn\n}\n\nfunc (p *pp) badVerb(verb rune) {\n\tp.erroring = true\n\t_, _ = p.WriteString(percentBangString)\n\t_, _ = p.WriteRune(verb)\n\t_, _ = p.WriteSingleByte('(')\n\tswitch {\n\tcase p.arg != nil:\n\t\t_, _ = p.WriteString(p.arg.String())\n\t\t_, _ = p.WriteSingleByte('=')\n\t\tp.printArg(p.arg, 'v')\n\tdefault:\n\t\t_, _ = p.WriteString(UndefinedValue.String())\n\t}\n\t_, _ = p.WriteSingleByte(')')\n\tp.erroring = false\n}\n\nfunc (p *pp) fmtBool(v bool, verb rune) {\n\tswitch verb {\n\tcase 't', 'v':\n\t\tp.fmt.fmtBoolean(v)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\n// fmt0x64 formats a uint64 in hexadecimal and prefixes it with 0x or\n// not, as requested, by temporarily setting the sharp flag.\nfunc (p *pp) fmt0x64(v uint64, leading0x bool) {\n\tsharp := p.fmt.sharp\n\tp.fmt.sharp = leading0x\n\tp.fmt.fmtInteger(v, 16, unsigned, 'v', ldigits)\n\tp.fmt.sharp = sharp\n}\n\n// fmtInteger formats a signed or unsigned integer.\nfunc (p *pp) fmtInteger(v uint64, isSigned bool, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif p.fmt.sharpV && !isSigned {\n\t\t\tp.fmt0x64(v, true)\n\t\t} else {\n\t\t\tp.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)\n\t\t}\n\tcase 'd':\n\t\tp.fmt.fmtInteger(v, 10, isSigned, verb, ldigits)\n\tcase 'b':\n\t\tp.fmt.fmtInteger(v, 2, isSigned, verb, ldigits)\n\tcase 'o', 'O':\n\t\tp.fmt.fmtInteger(v, 8, isSigned, verb, ldigits)\n\tcase 'x':\n\t\tp.fmt.fmtInteger(v, 16, isSigned, verb, ldigits)\n\tcase 'X':\n\t\tp.fmt.fmtInteger(v, 16, isSigned, verb, udigits)\n\tcase 'c':\n\t\tp.fmt.fmtC(v)\n\tcase 'q':\n\t\tif v <= utf8.MaxRune {\n\t\t\tp.fmt.fmtQc(v)\n\t\t} else {\n\t\t\tp.badVerb(verb)\n\t\t}\n\tcase 'U':\n\t\tp.fmt.fmtUnicode(v)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\n// fmtFloat formats a float. The default precision for each verb\n// is specified as last argument in the call to fmt_float.\nfunc (p *pp) fmtFloat(v float64, size int, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tp.fmt.fmtFloat(v, size, 'g', -1)\n\tcase 'b', 'g', 'G', 'x', 'X':\n\t\tp.fmt.fmtFloat(v, size, verb, -1)\n\tcase 'f', 'e', 'E':\n\t\tp.fmt.fmtFloat(v, size, verb, 6)\n\tcase 'F':\n\t\tp.fmt.fmtFloat(v, size, 'f', 6)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\nfunc (p *pp) fmtString(v string, verb rune) {\n\tswitch verb {\n\tcase 'v':\n\t\tif p.fmt.sharpV {\n\t\t\tp.fmt.fmtQ(v)\n\t\t} else {\n\t\t\tp.fmt.fmtS(v)\n\t\t}\n\tcase 's':\n\t\tp.fmt.fmtS(v)\n\tcase 'x':\n\t\tp.fmt.fmtSx(v, ldigits)\n\tcase 'X':\n\t\tp.fmt.fmtSx(v, udigits)\n\tcase 'q':\n\t\tp.fmt.fmtQ(v)\n\tdefault:\n\t\tp.badVerb(verb)\n\t}\n}\n\nfunc (p *pp) fmtBytes(v []byte, verb rune, typeString string) {\n\tswitch verb {\n\tcase 'v', 'd':\n\t\tif p.fmt.sharpV {\n\t\t\t_, _ = p.WriteString(typeString)\n\t\t\tif v == nil {\n\t\t\t\t_, _ = p.WriteString(nilParenString)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, _ = p.WriteSingleByte('{')\n\t\t\tfor i, c := range v {\n\t\t\t\tif i > 0 {\n\t\t\t\t\t_, _ = p.WriteString(commaSpaceString)\n\t\t\t\t}\n\t\t\t\tp.fmt0x64(uint64(c), true)\n\t\t\t}\n\t\t\t_, _ = p.WriteSingleByte('}')\n\t\t} else {\n\t\t\t_, _ = p.WriteSingleByte('[')\n\t\t\tfor i, c := range v {\n\t\t\t\tif i > 0 {\n\t\t\t\t\t_, _ = p.WriteSingleByte(' ')\n\t\t\t\t}\n\t\t\t\tp.fmt.fmtInteger(uint64(c), 10, unsigned, verb, ldigits)\n\t\t\t}\n\t\t\t_, _ = p.WriteSingleByte(']')\n\t\t}\n\tcase 's':\n\t\tp.fmt.fmtBs(v)\n\tcase 'x':\n\t\tp.fmt.fmtBx(v, ldigits)\n\tcase 'X':\n\t\tp.fmt.fmtBx(v, udigits)\n\tcase 'q':\n\t\tp.fmt.fmtQ(string(v))\n\t}\n}\n\nfunc (p *pp) printArg(arg Object, verb rune) {\n\tp.arg = arg\n\n\tif arg == nil {\n\t\targ = UndefinedValue\n\t}\n\n\t// Special processing considerations.\n\t// %T (the value's type) and %p (its address) are special; we always do\n\t// them first.\n\tswitch verb {\n\tcase 'T':\n\t\tp.fmt.fmtS(arg.TypeName())\n\t\treturn\n\tcase 'v':\n\t\tp.fmt.fmtS(arg.String())\n\t\treturn\n\t}\n\n\t// Some types can be done without reflection.\n\tswitch f := arg.(type) {\n\tcase *Bool:\n\t\tp.fmtBool(!f.IsFalsy(), verb)\n\tcase *Float:\n\t\tp.fmtFloat(f.Value, 64, verb)\n\tcase *Int:\n\t\tp.fmtInteger(uint64(f.Value), signed, verb)\n\tcase *String:\n\t\tp.fmtString(f.Value, verb)\n\tcase *Bytes:\n\t\tp.fmtBytes(f.Value, verb, \"[]byte\")\n\tdefault:\n\t\tp.fmtString(f.String(), verb)\n\t}\n}\n\n// intFromArg gets the argNumth element of a. On return, isInt reports whether\n// the argument has integer type.\nfunc intFromArg(a []Object, argNum int) (num int, isInt bool, newArgNum int) {\n\tnewArgNum = argNum\n\tif argNum < len(a) {\n\t\tvar num64 int64\n\t\tnum64, isInt = ToInt64(a[argNum])\n\t\tnum = int(num64)\n\t\tnewArgNum = argNum + 1\n\t\tif tooLarge(num) {\n\t\t\tnum = 0\n\t\t\tisInt = false\n\t\t}\n\t}\n\treturn\n}\n\n// parseArgNumber returns the value of the bracketed number, minus 1\n// (explicit argument numbers are one-indexed but we want zero-indexed).\n// The opening bracket is known to be present at format[0].\n// The returned values are the index, the number of bytes to consume\n// up to the closing paren, if present, and whether the number parsed\n// ok. The bytes to consume will be 1 if no closing paren is present.\nfunc parseArgNumber(format string) (index int, wid int, ok bool) {\n\t// There must be at least 3 bytes: [n].\n\tif len(format) < 3 {\n\t\treturn 0, 1, false\n\t}\n\n\t// Find closing bracket.\n\tfor i := 1; i < len(format); i++ {\n\t\tif format[i] == ']' {\n\t\t\twidth, ok, newi := parsenum(format, 1, i)\n\t\t\tif !ok || newi != i {\n\t\t\t\treturn 0, i + 1, false\n\t\t\t}\n\t\t\t// arg numbers are one-indexed andskip paren.\n\t\t\treturn width - 1, i + 1, true\n\t\t}\n\t}\n\treturn 0, 1, false\n}\n\n// argNumber returns the next argument to evaluate, which is either the value\n// of the passed-in argNum or the value of the bracketed integer that begins\n// format[i:]. It also returns the new value of i, that is, the index of the\n// next byte of the format to process.\nfunc (p *pp) argNumber(\n\targNum int,\n\tformat string,\n\ti int,\n\tnumArgs int,\n) (newArgNum, newi int, found bool) {\n\tif len(format) <= i || format[i] != '[' {\n\t\treturn argNum, i, false\n\t}\n\tp.reordered = true\n\tindex, wid, ok := parseArgNumber(format[i:])\n\tif ok && 0 <= index && index < numArgs {\n\t\treturn index, i + wid, true\n\t}\n\tp.goodArgNum = false\n\treturn argNum, i + wid, ok\n}\n\nfunc (p *pp) badArgNum(verb rune) {\n\t_, _ = p.WriteString(percentBangString)\n\t_, _ = p.WriteRune(verb)\n\t_, _ = p.WriteString(badIndexString)\n}\n\nfunc (p *pp) missingArg(verb rune) {\n\t_, _ = p.WriteString(percentBangString)\n\t_, _ = p.WriteRune(verb)\n\t_, _ = p.WriteString(missingString)\n}\n\nfunc (p *pp) doFormat(format string, a []Object) (err error) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tif e, ok := r.(error); ok && e == ErrStringLimit {\n\t\t\t\terr = e\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpanic(r)\n\t\t}\n\t}()\n\n\tend := len(format)\n\targNum := 0         // we process one argument per non-trivial format\n\tafterIndex := false // previous item in format was an index like [3].\n\tp.reordered = false\nformatLoop:\n\tfor i := 0; i < end; {\n\t\tp.goodArgNum = true\n\t\tlasti := i\n\t\tfor i < end && format[i] != '%' {\n\t\t\ti++\n\t\t}\n\t\tif i > lasti {\n\t\t\t_, _ = p.WriteString(format[lasti:i])\n\t\t}\n\t\tif i >= end {\n\t\t\t// done processing format string\n\t\t\tbreak\n\t\t}\n\n\t\t// Process one verb\n\t\ti++\n\n\t\t// Do we have flags?\n\t\tp.fmt.clearFlags()\n\tsimpleFormat:\n\t\tfor ; i < end; i++ {\n\t\t\tc := format[i]\n\t\t\tswitch c {\n\t\t\tcase '#':\n\t\t\t\tp.fmt.sharp = true\n\t\t\tcase '0':\n\t\t\t\t// Only allow zero padding to the left.\n\t\t\t\tp.fmt.zero = !p.fmt.minus\n\t\t\tcase '+':\n\t\t\t\tp.fmt.plus = true\n\t\t\tcase '-':\n\t\t\t\tp.fmt.minus = true\n\t\t\t\tp.fmt.zero = false // Do not pad with zeros to the right.\n\t\t\tcase ' ':\n\t\t\t\tp.fmt.space = true\n\t\t\tdefault:\n\t\t\t\t// Fast path for common case of ascii lower case simple verbs\n\t\t\t\t// without precision or width or argument indices.\n\t\t\t\tif 'a' <= c && c <= 'z' && argNum < len(a) {\n\t\t\t\t\tif c == 'v' {\n\t\t\t\t\t\t// Go syntax\n\t\t\t\t\t\tp.fmt.sharpV = p.fmt.sharp\n\t\t\t\t\t\tp.fmt.sharp = false\n\t\t\t\t\t\t// Struct-field syntax\n\t\t\t\t\t\tp.fmt.plusV = p.fmt.plus\n\t\t\t\t\t\tp.fmt.plus = false\n\t\t\t\t\t}\n\t\t\t\t\tp.printArg(a[argNum], rune(c))\n\t\t\t\t\targNum++\n\t\t\t\t\ti++\n\t\t\t\t\tcontinue formatLoop\n\t\t\t\t}\n\t\t\t\t// Format is more complex than simple flags and a verb or is\n\t\t\t\t// malformed.\n\t\t\t\tbreak simpleFormat\n\t\t\t}\n\t\t}\n\n\t\t// Do we have an explicit argument index?\n\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\n\t\t// Do we have width?\n\t\tif i < end && format[i] == '*' {\n\t\t\ti++\n\t\t\tp.fmt.wid, p.fmt.widPresent, argNum = intFromArg(a, argNum)\n\n\t\t\tif !p.fmt.widPresent {\n\t\t\t\t_, _ = p.WriteString(badWidthString)\n\t\t\t}\n\n\t\t\t// We have a negative width, so take its value and ensure\n\t\t\t// that the minus flag is set\n\t\t\tif p.fmt.wid < 0 {\n\t\t\t\tp.fmt.wid = -p.fmt.wid\n\t\t\t\tp.fmt.minus = true\n\t\t\t\tp.fmt.zero = false // Do not pad with zeros to the right.\n\t\t\t}\n\t\t\tafterIndex = false\n\t\t} else {\n\t\t\tp.fmt.wid, p.fmt.widPresent, i = parsenum(format, i, end)\n\t\t\tif afterIndex && p.fmt.widPresent { // \"%[3]2d\"\n\t\t\t\tp.goodArgNum = false\n\t\t\t}\n\t\t}\n\n\t\t// Do we have precision?\n\t\tif i+1 < end && format[i] == '.' {\n\t\t\ti++\n\t\t\tif afterIndex { // \"%[3].2d\"\n\t\t\t\tp.goodArgNum = false\n\t\t\t}\n\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\t\t\tif i < end && format[i] == '*' {\n\t\t\t\ti++\n\t\t\t\tp.fmt.prec, p.fmt.precPresent, argNum = intFromArg(a, argNum)\n\t\t\t\t// Negative precision arguments don't make sense\n\t\t\t\tif p.fmt.prec < 0 {\n\t\t\t\t\tp.fmt.prec = 0\n\t\t\t\t\tp.fmt.precPresent = false\n\t\t\t\t}\n\t\t\t\tif !p.fmt.precPresent {\n\t\t\t\t\t_, _ = p.WriteString(badPrecString)\n\t\t\t\t}\n\t\t\t\tafterIndex = false\n\t\t\t} else {\n\t\t\t\tp.fmt.prec, p.fmt.precPresent, i = parsenum(format, i, end)\n\t\t\t\tif !p.fmt.precPresent {\n\t\t\t\t\tp.fmt.prec = 0\n\t\t\t\t\tp.fmt.precPresent = true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !afterIndex {\n\t\t\targNum, i, afterIndex = p.argNumber(argNum, format, i, len(a))\n\t\t}\n\n\t\tif i >= end {\n\t\t\t_, _ = p.WriteString(noVerbString)\n\t\t\tbreak\n\t\t}\n\n\t\tverb, size := rune(format[i]), 1\n\t\tif verb >= utf8.RuneSelf {\n\t\t\tverb, size = utf8.DecodeRuneInString(format[i:])\n\t\t}\n\t\ti += size\n\n\t\tswitch {\n\t\tcase verb == '%':\n\t\t\t// Percent does not absorb operands and ignores f.wid and f.prec.\n\t\t\t_, _ = p.WriteSingleByte('%')\n\t\tcase !p.goodArgNum:\n\t\t\tp.badArgNum(verb)\n\t\tcase argNum >= len(a):\n\t\t\t// No argument left over to print for the current verb.\n\t\t\tp.missingArg(verb)\n\t\tcase verb == 'v':\n\t\t\t// Go syntax\n\t\t\tp.fmt.sharpV = p.fmt.sharp\n\t\t\tp.fmt.sharp = false\n\t\t\t// Struct-field syntax\n\t\t\tp.fmt.plusV = p.fmt.plus\n\t\t\tp.fmt.plus = false\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\tp.printArg(a[argNum], verb)\n\t\t\targNum++\n\t\t}\n\t}\n\n\t// Check for extra arguments unless the call accessed the arguments\n\t// out of order, in which case it's too expensive to detect if they've all\n\t// been used and arguably OK if they're not.\n\tif !p.reordered && argNum < len(a) {\n\t\tp.fmt.clearFlags()\n\t\t_, _ = p.WriteString(extraString)\n\t\tfor i, arg := range a[argNum:] {\n\t\t\tif i > 0 {\n\t\t\t\t_, _ = p.WriteString(commaSpaceString)\n\t\t\t}\n\t\t\tif arg == nil {\n\t\t\t\t_, _ = p.WriteString(UndefinedValue.String())\n\t\t\t} else {\n\t\t\t\t_, _ = p.WriteString(arg.TypeName())\n\t\t\t\t_, _ = p.WriteSingleByte('=')\n\t\t\t\tp.printArg(arg, 'v')\n\t\t\t}\n\t\t}\n\t\t_, _ = p.WriteSingleByte(')')\n\t}\n\n\treturn nil\n}\n\n// Format is like fmt.Sprintf but using Objects.\nfunc Format(format string, a ...Object) (string, error) {\n\tp := newPrinter()\n\terr := p.doFormat(format, a)\n\ts := string(p.buf)\n\tp.free()\n\n\treturn s, err\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0380859375,
          "content": "module github.com/d5/tengo/v2\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "instructions.go",
          "type": "blob",
          "size": 1.525390625,
          "content": "package tengo\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/d5/tengo/v2/parser\"\n)\n\n// MakeInstruction returns a bytecode for an opcode and the operands.\nfunc MakeInstruction(opcode parser.Opcode, operands ...int) []byte {\n\tnumOperands := parser.OpcodeOperands[opcode]\n\n\ttotalLen := 1\n\tfor _, w := range numOperands {\n\t\ttotalLen += w\n\t}\n\n\tinstruction := make([]byte, totalLen)\n\tinstruction[0] = opcode\n\n\toffset := 1\n\tfor i, o := range operands {\n\t\twidth := numOperands[i]\n\t\tswitch width {\n\t\tcase 1:\n\t\t\tinstruction[offset] = byte(o)\n\t\tcase 2:\n\t\t\tn := uint16(o)\n\t\t\tinstruction[offset] = byte(n >> 8)\n\t\t\tinstruction[offset+1] = byte(n)\n\t\tcase 4:\n\t\t\tn := uint32(o)\n\t\t\tinstruction[offset] = byte(n >> 24)\n\t\t\tinstruction[offset+1] = byte(n >> 16)\n\t\t\tinstruction[offset+2] = byte(n >> 8)\n\t\t\tinstruction[offset+3] = byte(n)\n\t\t}\n\t\toffset += width\n\t}\n\treturn instruction\n}\n\n// FormatInstructions returns string representation of bytecode instructions.\nfunc FormatInstructions(b []byte, posOffset int) []string {\n\tvar out []string\n\n\ti := 0\n\tfor i < len(b) {\n\t\tnumOperands := parser.OpcodeOperands[b[i]]\n\t\toperands, read := parser.ReadOperands(numOperands, b[i+1:])\n\n\t\tswitch len(numOperands) {\n\t\tcase 0:\n\t\t\tout = append(out, fmt.Sprintf(\"%04d %-7s\",\n\t\t\t\tposOffset+i, parser.OpcodeNames[b[i]]))\n\t\tcase 1:\n\t\t\tout = append(out, fmt.Sprintf(\"%04d %-7s %-5d\",\n\t\t\t\tposOffset+i, parser.OpcodeNames[b[i]], operands[0]))\n\t\tcase 2:\n\t\t\tout = append(out, fmt.Sprintf(\"%04d %-7s %-5d %-5d\",\n\t\t\t\tposOffset+i, parser.OpcodeNames[b[i]],\n\t\t\t\toperands[0], operands[1]))\n\t\t}\n\t\ti += 1 + read\n\t}\n\treturn out\n}\n"
        },
        {
          "name": "iterator.go",
          "type": "blob",
          "size": 4.5146484375,
          "content": "package tengo\n\n// Iterator represents an iterator for underlying data type.\ntype Iterator interface {\n\tObject\n\n\t// Next returns true if there are more elements to iterate.\n\tNext() bool\n\n\t// Key returns the key or index value of the current element.\n\tKey() Object\n\n\t// Value returns the value of the current element.\n\tValue() Object\n}\n\n// ArrayIterator is an iterator for an array.\ntype ArrayIterator struct {\n\tObjectImpl\n\tv []Object\n\ti int\n\tl int\n}\n\n// TypeName returns the name of the type.\nfunc (i *ArrayIterator) TypeName() string {\n\treturn \"array-iterator\"\n}\n\nfunc (i *ArrayIterator) String() string {\n\treturn \"<array-iterator>\"\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (i *ArrayIterator) IsFalsy() bool {\n\treturn true\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (i *ArrayIterator) Equals(Object) bool {\n\treturn false\n}\n\n// Copy returns a copy of the type.\nfunc (i *ArrayIterator) Copy() Object {\n\treturn &ArrayIterator{v: i.v, i: i.i, l: i.l}\n}\n\n// Next returns true if there are more elements to iterate.\nfunc (i *ArrayIterator) Next() bool {\n\ti.i++\n\treturn i.i <= i.l\n}\n\n// Key returns the key or index value of the current element.\nfunc (i *ArrayIterator) Key() Object {\n\treturn &Int{Value: int64(i.i - 1)}\n}\n\n// Value returns the value of the current element.\nfunc (i *ArrayIterator) Value() Object {\n\treturn i.v[i.i-1]\n}\n\n// BytesIterator represents an iterator for a string.\ntype BytesIterator struct {\n\tObjectImpl\n\tv []byte\n\ti int\n\tl int\n}\n\n// TypeName returns the name of the type.\nfunc (i *BytesIterator) TypeName() string {\n\treturn \"bytes-iterator\"\n}\n\nfunc (i *BytesIterator) String() string {\n\treturn \"<bytes-iterator>\"\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (i *BytesIterator) Equals(Object) bool {\n\treturn false\n}\n\n// Copy returns a copy of the type.\nfunc (i *BytesIterator) Copy() Object {\n\treturn &BytesIterator{v: i.v, i: i.i, l: i.l}\n}\n\n// Next returns true if there are more elements to iterate.\nfunc (i *BytesIterator) Next() bool {\n\ti.i++\n\treturn i.i <= i.l\n}\n\n// Key returns the key or index value of the current element.\nfunc (i *BytesIterator) Key() Object {\n\treturn &Int{Value: int64(i.i - 1)}\n}\n\n// Value returns the value of the current element.\nfunc (i *BytesIterator) Value() Object {\n\treturn &Int{Value: int64(i.v[i.i-1])}\n}\n\n// MapIterator represents an iterator for the map.\ntype MapIterator struct {\n\tObjectImpl\n\tv map[string]Object\n\tk []string\n\ti int\n\tl int\n}\n\n// TypeName returns the name of the type.\nfunc (i *MapIterator) TypeName() string {\n\treturn \"map-iterator\"\n}\n\nfunc (i *MapIterator) String() string {\n\treturn \"<map-iterator>\"\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (i *MapIterator) IsFalsy() bool {\n\treturn true\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (i *MapIterator) Equals(Object) bool {\n\treturn false\n}\n\n// Copy returns a copy of the type.\nfunc (i *MapIterator) Copy() Object {\n\treturn &MapIterator{v: i.v, k: i.k, i: i.i, l: i.l}\n}\n\n// Next returns true if there are more elements to iterate.\nfunc (i *MapIterator) Next() bool {\n\ti.i++\n\treturn i.i <= i.l\n}\n\n// Key returns the key or index value of the current element.\nfunc (i *MapIterator) Key() Object {\n\tk := i.k[i.i-1]\n\treturn &String{Value: k}\n}\n\n// Value returns the value of the current element.\nfunc (i *MapIterator) Value() Object {\n\tk := i.k[i.i-1]\n\treturn i.v[k]\n}\n\n// StringIterator represents an iterator for a string.\ntype StringIterator struct {\n\tObjectImpl\n\tv []rune\n\ti int\n\tl int\n}\n\n// TypeName returns the name of the type.\nfunc (i *StringIterator) TypeName() string {\n\treturn \"string-iterator\"\n}\n\nfunc (i *StringIterator) String() string {\n\treturn \"<string-iterator>\"\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (i *StringIterator) IsFalsy() bool {\n\treturn true\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (i *StringIterator) Equals(Object) bool {\n\treturn false\n}\n\n// Copy returns a copy of the type.\nfunc (i *StringIterator) Copy() Object {\n\treturn &StringIterator{v: i.v, i: i.i, l: i.l}\n}\n\n// Next returns true if there are more elements to iterate.\nfunc (i *StringIterator) Next() bool {\n\ti.i++\n\treturn i.i <= i.l\n}\n\n// Key returns the key or index value of the current element.\nfunc (i *StringIterator) Key() Object {\n\treturn &Int{Value: int64(i.i - 1)}\n}\n\n// Value returns the value of the current element.\nfunc (i *StringIterator) Value() Object {\n\treturn &Char{Value: i.v[i.i-1]}\n}\n"
        },
        {
          "name": "modules.go",
          "type": "blob",
          "size": 2.4580078125,
          "content": "package tengo\n\n// Importable interface represents importable module instance.\ntype Importable interface {\n\t// Import should return either an Object or module source code ([]byte).\n\tImport(moduleName string) (interface{}, error)\n}\n\n// ModuleGetter enables implementing dynamic module loading.\ntype ModuleGetter interface {\n\tGet(name string) Importable\n}\n\n// ModuleMap represents a set of named modules. Use NewModuleMap to create a\n// new module map.\ntype ModuleMap struct {\n\tm map[string]Importable\n}\n\n// NewModuleMap creates a new module map.\nfunc NewModuleMap() *ModuleMap {\n\treturn &ModuleMap{\n\t\tm: make(map[string]Importable),\n\t}\n}\n\n// Add adds an import module.\nfunc (m *ModuleMap) Add(name string, module Importable) {\n\tm.m[name] = module\n}\n\n// AddBuiltinModule adds a builtin module.\nfunc (m *ModuleMap) AddBuiltinModule(name string, attrs map[string]Object) {\n\tm.m[name] = &BuiltinModule{Attrs: attrs}\n}\n\n// AddSourceModule adds a source module.\nfunc (m *ModuleMap) AddSourceModule(name string, src []byte) {\n\tm.m[name] = &SourceModule{Src: src}\n}\n\n// Remove removes a named module.\nfunc (m *ModuleMap) Remove(name string) {\n\tdelete(m.m, name)\n}\n\n// Get returns an import module identified by name. It returns if the name is\n// not found.\nfunc (m *ModuleMap) Get(name string) Importable {\n\treturn m.m[name]\n}\n\n// GetBuiltinModule returns a builtin module identified by name. It returns\n// if the name is not found or the module is not a builtin module.\nfunc (m *ModuleMap) GetBuiltinModule(name string) *BuiltinModule {\n\tmod, _ := m.m[name].(*BuiltinModule)\n\treturn mod\n}\n\n// GetSourceModule returns a source module identified by name. It returns if\n// the name is not found or the module is not a source module.\nfunc (m *ModuleMap) GetSourceModule(name string) *SourceModule {\n\tmod, _ := m.m[name].(*SourceModule)\n\treturn mod\n}\n\n// Copy creates a copy of the module map.\nfunc (m *ModuleMap) Copy() *ModuleMap {\n\tc := &ModuleMap{\n\t\tm: make(map[string]Importable),\n\t}\n\tfor name, mod := range m.m {\n\t\tc.m[name] = mod\n\t}\n\treturn c\n}\n\n// Len returns the number of named modules.\nfunc (m *ModuleMap) Len() int {\n\treturn len(m.m)\n}\n\n// AddMap adds named modules from another module map.\nfunc (m *ModuleMap) AddMap(o *ModuleMap) {\n\tfor name, mod := range o.m {\n\t\tm.m[name] = mod\n\t}\n}\n\n// SourceModule is an importable module that's written in Tengo.\ntype SourceModule struct {\n\tSrc []byte\n}\n\n// Import returns a module source code.\nfunc (m *SourceModule) Import(_ string) (interface{}, error) {\n\treturn m.Src, nil\n}\n"
        },
        {
          "name": "objects.go",
          "type": "blob",
          "size": 35.26171875,
          "content": "package tengo\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/token\"\n)\n\nvar (\n\t// TrueValue represents a true value.\n\tTrueValue Object = &Bool{value: true}\n\n\t// FalseValue represents a false value.\n\tFalseValue Object = &Bool{value: false}\n\n\t// UndefinedValue represents an undefined value.\n\tUndefinedValue Object = &Undefined{}\n)\n\n// Object represents an object in the VM.\ntype Object interface {\n\t// TypeName should return the name of the type.\n\tTypeName() string\n\n\t// String should return a string representation of the type's value.\n\tString() string\n\n\t// BinaryOp should return another object that is the result of a given\n\t// binary operator and a right-hand side object. If BinaryOp returns an\n\t// error, the VM will treat it as a run-time error.\n\tBinaryOp(op token.Token, rhs Object) (Object, error)\n\n\t// IsFalsy should return true if the value of the type should be considered\n\t// as falsy.\n\tIsFalsy() bool\n\n\t// Equals should return true if the value of the type should be considered\n\t// as equal to the value of another object.\n\tEquals(another Object) bool\n\n\t// Copy should return a copy of the type (and its value). Copy function\n\t// will be used for copy() builtin function which is expected to deep-copy\n\t// the values generally.\n\tCopy() Object\n\n\t// IndexGet should take an index Object and return a result Object or an\n\t// error for indexable objects. Indexable is an object that can take an\n\t// index and return an object. If error is returned, the runtime will treat\n\t// it as a run-time error and ignore returned value. If Object is not\n\t// indexable, ErrNotIndexable should be returned as error. If nil is\n\t// returned as value, it will be converted to UndefinedToken value by the\n\t// runtime.\n\tIndexGet(index Object) (value Object, err error)\n\n\t// IndexSet should take an index Object and a value Object for index\n\t// assignable objects. Index assignable is an object that can take an index\n\t// and a value on the left-hand side of the assignment statement. If Object\n\t// is not index assignable, ErrNotIndexAssignable should be returned as\n\t// error. If an error is returned, it will be treated as a run-time error.\n\tIndexSet(index, value Object) error\n\n\t// Iterate should return an Iterator for the type.\n\tIterate() Iterator\n\n\t// CanIterate should return whether the Object can be Iterated.\n\tCanIterate() bool\n\n\t// Call should take an arbitrary number of arguments and returns a return\n\t// value and/or an error, which the VM will consider as a run-time error.\n\tCall(args ...Object) (ret Object, err error)\n\n\t// CanCall should return whether the Object can be Called.\n\tCanCall() bool\n}\n\n// ObjectImpl represents a default Object Implementation. To defined a new\n// value type, one can embed ObjectImpl in their type declarations to avoid\n// implementing all non-significant methods. TypeName() and String() methods\n// still need to be implemented.\ntype ObjectImpl struct {\n}\n\n// TypeName returns the name of the type.\nfunc (o *ObjectImpl) TypeName() string {\n\tpanic(ErrNotImplemented)\n}\n\nfunc (o *ObjectImpl) String() string {\n\tpanic(ErrNotImplemented)\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *ObjectImpl) BinaryOp(_ token.Token, _ Object) (Object, error) {\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *ObjectImpl) Copy() Object {\n\treturn nil\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *ObjectImpl) IsFalsy() bool {\n\treturn false\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *ObjectImpl) Equals(x Object) bool {\n\treturn o == x\n}\n\n// IndexGet returns an element at a given index.\nfunc (o *ObjectImpl) IndexGet(_ Object) (res Object, err error) {\n\treturn nil, ErrNotIndexable\n}\n\n// IndexSet sets an element at a given index.\nfunc (o *ObjectImpl) IndexSet(_, _ Object) (err error) {\n\treturn ErrNotIndexAssignable\n}\n\n// Iterate returns an iterator.\nfunc (o *ObjectImpl) Iterate() Iterator {\n\treturn nil\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *ObjectImpl) CanIterate() bool {\n\treturn false\n}\n\n// Call takes an arbitrary number of arguments and returns a return value\n// and/or an error.\nfunc (o *ObjectImpl) Call(_ ...Object) (ret Object, err error) {\n\treturn nil, nil\n}\n\n// CanCall returns whether the Object can be Called.\nfunc (o *ObjectImpl) CanCall() bool {\n\treturn false\n}\n\n// Array represents an array of objects.\ntype Array struct {\n\tObjectImpl\n\tValue []Object\n}\n\n// TypeName returns the name of the type.\nfunc (o *Array) TypeName() string {\n\treturn \"array\"\n}\n\nfunc (o *Array) String() string {\n\tvar elements []string\n\tfor _, e := range o.Value {\n\t\telements = append(elements, e.String())\n\t}\n\treturn fmt.Sprintf(\"[%s]\", strings.Join(elements, \", \"))\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *Array) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tif rhs, ok := rhs.(*Array); ok {\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tif len(rhs.Value) == 0 {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Array{Value: append(o.Value, rhs.Value...)}, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *Array) Copy() Object {\n\tvar c []Object\n\tfor _, elem := range o.Value {\n\t\tc = append(c, elem.Copy())\n\t}\n\treturn &Array{Value: c}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Array) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Array) Equals(x Object) bool {\n\tvar xVal []Object\n\tswitch x := x.(type) {\n\tcase *Array:\n\t\txVal = x.Value\n\tcase *ImmutableArray:\n\t\txVal = x.Value\n\tdefault:\n\t\treturn false\n\t}\n\tif len(o.Value) != len(xVal) {\n\t\treturn false\n\t}\n\tfor i, e := range o.Value {\n\t\tif !e.Equals(xVal[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// IndexGet returns an element at a given index.\nfunc (o *Array) IndexGet(index Object) (res Object, err error) {\n\tintIdx, ok := index.(*Int)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tidxVal := int(intIdx.Value)\n\tif idxVal < 0 || idxVal >= len(o.Value) {\n\t\tres = UndefinedValue\n\t\treturn\n\t}\n\tres = o.Value[idxVal]\n\treturn\n}\n\n// IndexSet sets an element at a given index.\nfunc (o *Array) IndexSet(index, value Object) (err error) {\n\tintIdx, ok := ToInt(index)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tif intIdx < 0 || intIdx >= len(o.Value) {\n\t\terr = ErrIndexOutOfBounds\n\t\treturn\n\t}\n\to.Value[intIdx] = value\n\treturn nil\n}\n\n// Iterate creates an array iterator.\nfunc (o *Array) Iterate() Iterator {\n\treturn &ArrayIterator{\n\t\tv: o.Value,\n\t\tl: len(o.Value),\n\t}\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *Array) CanIterate() bool {\n\treturn true\n}\n\n// Bool represents a boolean value.\ntype Bool struct {\n\tObjectImpl\n\n\t// this is intentionally non-public to force using objects.TrueValue and\n\t// FalseValue always\n\tvalue bool\n}\n\nfunc (o *Bool) String() string {\n\tif o.value {\n\t\treturn \"true\"\n\t}\n\n\treturn \"false\"\n}\n\n// TypeName returns the name of the type.\nfunc (o *Bool) TypeName() string {\n\treturn \"bool\"\n}\n\n// Copy returns a copy of the type.\nfunc (o *Bool) Copy() Object {\n\treturn o\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Bool) IsFalsy() bool {\n\treturn !o.value\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Bool) Equals(x Object) bool {\n\treturn o == x\n}\n\n// GobDecode decodes bool value from input bytes.\nfunc (o *Bool) GobDecode(b []byte) (err error) {\n\to.value = b[0] == 1\n\treturn\n}\n\n// GobEncode encodes bool values into bytes.\nfunc (o *Bool) GobEncode() (b []byte, err error) {\n\tif o.value {\n\t\tb = []byte{1}\n\t} else {\n\t\tb = []byte{0}\n\t}\n\treturn\n}\n\n// BuiltinFunction represents a builtin function.\ntype BuiltinFunction struct {\n\tObjectImpl\n\tName  string\n\tValue CallableFunc\n}\n\n// TypeName returns the name of the type.\nfunc (o *BuiltinFunction) TypeName() string {\n\treturn \"builtin-function:\" + o.Name\n}\n\nfunc (o *BuiltinFunction) String() string {\n\treturn \"<builtin-function>\"\n}\n\n// Copy returns a copy of the type.\nfunc (o *BuiltinFunction) Copy() Object {\n\treturn &BuiltinFunction{Value: o.Value}\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *BuiltinFunction) Equals(_ Object) bool {\n\treturn false\n}\n\n// Call executes a builtin function.\nfunc (o *BuiltinFunction) Call(args ...Object) (Object, error) {\n\treturn o.Value(args...)\n}\n\n// CanCall returns whether the Object can be Called.\nfunc (o *BuiltinFunction) CanCall() bool {\n\treturn true\n}\n\n// BuiltinModule is an importable module that's written in Go.\ntype BuiltinModule struct {\n\tAttrs map[string]Object\n}\n\n// Import returns an immutable map for the module.\nfunc (m *BuiltinModule) Import(moduleName string) (interface{}, error) {\n\treturn m.AsImmutableMap(moduleName), nil\n}\n\n// AsImmutableMap converts builtin module into an immutable map.\nfunc (m *BuiltinModule) AsImmutableMap(moduleName string) *ImmutableMap {\n\tattrs := make(map[string]Object, len(m.Attrs))\n\tfor k, v := range m.Attrs {\n\t\tattrs[k] = v.Copy()\n\t}\n\tattrs[\"__module_name__\"] = &String{Value: moduleName}\n\treturn &ImmutableMap{Value: attrs}\n}\n\n// Bytes represents a byte array.\ntype Bytes struct {\n\tObjectImpl\n\tValue []byte\n}\n\nfunc (o *Bytes) String() string {\n\treturn string(o.Value)\n}\n\n// TypeName returns the name of the type.\nfunc (o *Bytes) TypeName() string {\n\treturn \"bytes\"\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *Bytes) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tswitch op {\n\tcase token.Add:\n\t\tswitch rhs := rhs.(type) {\n\t\tcase *Bytes:\n\t\t\tif len(o.Value)+len(rhs.Value) > MaxBytesLen {\n\t\t\t\treturn nil, ErrBytesLimit\n\t\t\t}\n\t\t\treturn &Bytes{Value: append(o.Value, rhs.Value...)}, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *Bytes) Copy() Object {\n\treturn &Bytes{Value: append([]byte{}, o.Value...)}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Bytes) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Bytes) Equals(x Object) bool {\n\tt, ok := x.(*Bytes)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn bytes.Equal(o.Value, t.Value)\n}\n\n// IndexGet returns an element (as Int) at a given index.\nfunc (o *Bytes) IndexGet(index Object) (res Object, err error) {\n\tintIdx, ok := index.(*Int)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tidxVal := int(intIdx.Value)\n\tif idxVal < 0 || idxVal >= len(o.Value) {\n\t\tres = UndefinedValue\n\t\treturn\n\t}\n\tres = &Int{Value: int64(o.Value[idxVal])}\n\treturn\n}\n\n// Iterate creates a bytes iterator.\nfunc (o *Bytes) Iterate() Iterator {\n\treturn &BytesIterator{\n\t\tv: o.Value,\n\t\tl: len(o.Value),\n\t}\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *Bytes) CanIterate() bool {\n\treturn true\n}\n\n// Char represents a character value.\ntype Char struct {\n\tObjectImpl\n\tValue rune\n}\n\nfunc (o *Char) String() string {\n\treturn string(o.Value)\n}\n\n// TypeName returns the name of the type.\nfunc (o *Char) TypeName() string {\n\treturn \"char\"\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *Char) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tswitch rhs := rhs.(type) {\n\tcase *Char:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tr := o.Value + rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Char{Value: r}, nil\n\t\tcase token.Sub:\n\t\t\tr := o.Value - rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Char{Value: r}, nil\n\t\tcase token.Less:\n\t\t\tif o.Value < rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif o.Value > rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif o.Value <= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif o.Value >= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase *Int:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tr := o.Value + rune(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Char{Value: r}, nil\n\t\tcase token.Sub:\n\t\t\tr := o.Value - rune(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Char{Value: r}, nil\n\t\tcase token.Less:\n\t\t\tif int64(o.Value) < rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif int64(o.Value) > rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif int64(o.Value) <= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif int64(o.Value) >= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *Char) Copy() Object {\n\treturn &Char{Value: o.Value}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Char) IsFalsy() bool {\n\treturn o.Value == 0\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Char) Equals(x Object) bool {\n\tt, ok := x.(*Char)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn o.Value == t.Value\n}\n\n// CompiledFunction represents a compiled function.\ntype CompiledFunction struct {\n\tObjectImpl\n\tInstructions  []byte\n\tNumLocals     int // number of local variables (including function parameters)\n\tNumParameters int\n\tVarArgs       bool\n\tSourceMap     map[int]parser.Pos\n\tFree          []*ObjectPtr\n}\n\n// TypeName returns the name of the type.\nfunc (o *CompiledFunction) TypeName() string {\n\treturn \"compiled-function\"\n}\n\nfunc (o *CompiledFunction) String() string {\n\treturn \"<compiled-function>\"\n}\n\n// Copy returns a copy of the type.\nfunc (o *CompiledFunction) Copy() Object {\n\treturn &CompiledFunction{\n\t\tInstructions:  append([]byte{}, o.Instructions...),\n\t\tNumLocals:     o.NumLocals,\n\t\tNumParameters: o.NumParameters,\n\t\tVarArgs:       o.VarArgs,\n\t\tFree:          append([]*ObjectPtr{}, o.Free...), // DO NOT Copy() of elements; these are variable pointers\n\t}\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *CompiledFunction) Equals(_ Object) bool {\n\treturn false\n}\n\n// SourcePos returns the source position of the instruction at ip.\nfunc (o *CompiledFunction) SourcePos(ip int) parser.Pos {\n\tfor ip >= 0 {\n\t\tif p, ok := o.SourceMap[ip]; ok {\n\t\t\treturn p\n\t\t}\n\t\tip--\n\t}\n\treturn parser.NoPos\n}\n\n// CanCall returns whether the Object can be Called.\nfunc (o *CompiledFunction) CanCall() bool {\n\treturn true\n}\n\n// Error represents an error value.\ntype Error struct {\n\tObjectImpl\n\tValue Object\n}\n\n// TypeName returns the name of the type.\nfunc (o *Error) TypeName() string {\n\treturn \"error\"\n}\n\nfunc (o *Error) String() string {\n\tif o.Value != nil {\n\t\treturn fmt.Sprintf(\"error: %s\", o.Value.String())\n\t}\n\treturn \"error\"\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Error) IsFalsy() bool {\n\treturn true // error is always false.\n}\n\n// Copy returns a copy of the type.\nfunc (o *Error) Copy() Object {\n\treturn &Error{Value: o.Value.Copy()}\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Error) Equals(x Object) bool {\n\treturn o == x // pointer equality\n}\n\n// IndexGet returns an element at a given index.\nfunc (o *Error) IndexGet(index Object) (res Object, err error) {\n\tif strIdx, _ := ToString(index); strIdx != \"value\" {\n\t\terr = ErrInvalidIndexOnError\n\t\treturn\n\t}\n\tres = o.Value\n\treturn\n}\n\n// Float represents a floating point number value.\ntype Float struct {\n\tObjectImpl\n\tValue float64\n}\n\nfunc (o *Float) String() string {\n\treturn strconv.FormatFloat(o.Value, 'f', -1, 64)\n}\n\n// TypeName returns the name of the type.\nfunc (o *Float) TypeName() string {\n\treturn \"float\"\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *Float) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tswitch rhs := rhs.(type) {\n\tcase *Float:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tr := o.Value + rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Sub:\n\t\t\tr := o.Value - rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Mul:\n\t\t\tr := o.Value * rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Quo:\n\t\t\tr := o.Value / rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Less:\n\t\t\tif o.Value < rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif o.Value > rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif o.Value <= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif o.Value >= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase *Int:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tr := o.Value + float64(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Sub:\n\t\t\tr := o.Value - float64(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Mul:\n\t\t\tr := o.Value * float64(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Quo:\n\t\t\tr := o.Value / float64(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Float{Value: r}, nil\n\t\tcase token.Less:\n\t\t\tif o.Value < float64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif o.Value > float64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif o.Value <= float64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif o.Value >= float64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *Float) Copy() Object {\n\treturn &Float{Value: o.Value}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Float) IsFalsy() bool {\n\treturn math.IsNaN(o.Value)\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Float) Equals(x Object) bool {\n\tt, ok := x.(*Float)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn o.Value == t.Value\n}\n\n// ImmutableArray represents an immutable array of objects.\ntype ImmutableArray struct {\n\tObjectImpl\n\tValue []Object\n}\n\n// TypeName returns the name of the type.\nfunc (o *ImmutableArray) TypeName() string {\n\treturn \"immutable-array\"\n}\n\nfunc (o *ImmutableArray) String() string {\n\tvar elements []string\n\tfor _, e := range o.Value {\n\t\telements = append(elements, e.String())\n\t}\n\treturn fmt.Sprintf(\"[%s]\", strings.Join(elements, \", \"))\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *ImmutableArray) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tif rhs, ok := rhs.(*ImmutableArray); ok {\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\treturn &Array{Value: append(o.Value, rhs.Value...)}, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *ImmutableArray) Copy() Object {\n\tvar c []Object\n\tfor _, elem := range o.Value {\n\t\tc = append(c, elem.Copy())\n\t}\n\treturn &Array{Value: c}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *ImmutableArray) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *ImmutableArray) Equals(x Object) bool {\n\tvar xVal []Object\n\tswitch x := x.(type) {\n\tcase *Array:\n\t\txVal = x.Value\n\tcase *ImmutableArray:\n\t\txVal = x.Value\n\tdefault:\n\t\treturn false\n\t}\n\tif len(o.Value) != len(xVal) {\n\t\treturn false\n\t}\n\tfor i, e := range o.Value {\n\t\tif !e.Equals(xVal[i]) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// IndexGet returns an element at a given index.\nfunc (o *ImmutableArray) IndexGet(index Object) (res Object, err error) {\n\tintIdx, ok := index.(*Int)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tidxVal := int(intIdx.Value)\n\tif idxVal < 0 || idxVal >= len(o.Value) {\n\t\tres = UndefinedValue\n\t\treturn\n\t}\n\tres = o.Value[idxVal]\n\treturn\n}\n\n// Iterate creates an array iterator.\nfunc (o *ImmutableArray) Iterate() Iterator {\n\treturn &ArrayIterator{\n\t\tv: o.Value,\n\t\tl: len(o.Value),\n\t}\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *ImmutableArray) CanIterate() bool {\n\treturn true\n}\n\n// ImmutableMap represents an immutable map object.\ntype ImmutableMap struct {\n\tObjectImpl\n\tValue map[string]Object\n}\n\n// TypeName returns the name of the type.\nfunc (o *ImmutableMap) TypeName() string {\n\treturn \"immutable-map\"\n}\n\nfunc (o *ImmutableMap) String() string {\n\tvar pairs []string\n\tfor k, v := range o.Value {\n\t\tpairs = append(pairs, fmt.Sprintf(\"%s: %s\", k, v.String()))\n\t}\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(pairs, \", \"))\n}\n\n// Copy returns a copy of the type.\nfunc (o *ImmutableMap) Copy() Object {\n\tc := make(map[string]Object)\n\tfor k, v := range o.Value {\n\t\tc[k] = v.Copy()\n\t}\n\treturn &Map{Value: c}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *ImmutableMap) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\n// IndexGet returns the value for the given key.\nfunc (o *ImmutableMap) IndexGet(index Object) (res Object, err error) {\n\tstrIdx, ok := ToString(index)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tres, ok = o.Value[strIdx]\n\tif !ok {\n\t\tres = UndefinedValue\n\t}\n\treturn\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *ImmutableMap) Equals(x Object) bool {\n\tvar xVal map[string]Object\n\tswitch x := x.(type) {\n\tcase *Map:\n\t\txVal = x.Value\n\tcase *ImmutableMap:\n\t\txVal = x.Value\n\tdefault:\n\t\treturn false\n\t}\n\tif len(o.Value) != len(xVal) {\n\t\treturn false\n\t}\n\tfor k, v := range o.Value {\n\t\ttv := xVal[k]\n\t\tif !v.Equals(tv) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Iterate creates an immutable map iterator.\nfunc (o *ImmutableMap) Iterate() Iterator {\n\tvar keys []string\n\tfor k := range o.Value {\n\t\tkeys = append(keys, k)\n\t}\n\treturn &MapIterator{\n\t\tv: o.Value,\n\t\tk: keys,\n\t\tl: len(keys),\n\t}\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *ImmutableMap) CanIterate() bool {\n\treturn true\n}\n\n// Int represents an integer value.\ntype Int struct {\n\tObjectImpl\n\tValue int64\n}\n\nfunc (o *Int) String() string {\n\treturn strconv.FormatInt(o.Value, 10)\n}\n\n// TypeName returns the name of the type.\nfunc (o *Int) TypeName() string {\n\treturn \"int\"\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *Int) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tswitch rhs := rhs.(type) {\n\tcase *Int:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tr := o.Value + rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Sub:\n\t\t\tr := o.Value - rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Mul:\n\t\t\tr := o.Value * rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Quo:\n\t\t\tr := o.Value / rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Rem:\n\t\t\tr := o.Value % rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.And:\n\t\t\tr := o.Value & rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Or:\n\t\t\tr := o.Value | rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Xor:\n\t\t\tr := o.Value ^ rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.AndNot:\n\t\t\tr := o.Value &^ rhs.Value\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Shl:\n\t\t\tr := o.Value << uint64(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Shr:\n\t\t\tr := o.Value >> uint64(rhs.Value)\n\t\t\tif r == o.Value {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Int{Value: r}, nil\n\t\tcase token.Less:\n\t\t\tif o.Value < rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif o.Value > rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif o.Value <= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif o.Value >= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase *Float:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\treturn &Float{Value: float64(o.Value) + rhs.Value}, nil\n\t\tcase token.Sub:\n\t\t\treturn &Float{Value: float64(o.Value) - rhs.Value}, nil\n\t\tcase token.Mul:\n\t\t\treturn &Float{Value: float64(o.Value) * rhs.Value}, nil\n\t\tcase token.Quo:\n\t\t\treturn &Float{Value: float64(o.Value) / rhs.Value}, nil\n\t\tcase token.Less:\n\t\t\tif float64(o.Value) < rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif float64(o.Value) > rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif float64(o.Value) <= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif float64(o.Value) >= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase *Char:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\treturn &Char{Value: rune(o.Value) + rhs.Value}, nil\n\t\tcase token.Sub:\n\t\t\treturn &Char{Value: rune(o.Value) - rhs.Value}, nil\n\t\tcase token.Less:\n\t\t\tif o.Value < int64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif o.Value > int64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif o.Value <= int64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif o.Value >= int64(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *Int) Copy() Object {\n\treturn &Int{Value: o.Value}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Int) IsFalsy() bool {\n\treturn o.Value == 0\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Int) Equals(x Object) bool {\n\tt, ok := x.(*Int)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn o.Value == t.Value\n}\n\n// Map represents a map of objects.\ntype Map struct {\n\tObjectImpl\n\tValue map[string]Object\n}\n\n// TypeName returns the name of the type.\nfunc (o *Map) TypeName() string {\n\treturn \"map\"\n}\n\nfunc (o *Map) String() string {\n\tvar pairs []string\n\tfor k, v := range o.Value {\n\t\tpairs = append(pairs, fmt.Sprintf(\"%s: %s\", k, v.String()))\n\t}\n\treturn fmt.Sprintf(\"{%s}\", strings.Join(pairs, \", \"))\n}\n\n// Copy returns a copy of the type.\nfunc (o *Map) Copy() Object {\n\tc := make(map[string]Object)\n\tfor k, v := range o.Value {\n\t\tc[k] = v.Copy()\n\t}\n\treturn &Map{Value: c}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Map) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Map) Equals(x Object) bool {\n\tvar xVal map[string]Object\n\tswitch x := x.(type) {\n\tcase *Map:\n\t\txVal = x.Value\n\tcase *ImmutableMap:\n\t\txVal = x.Value\n\tdefault:\n\t\treturn false\n\t}\n\tif len(o.Value) != len(xVal) {\n\t\treturn false\n\t}\n\tfor k, v := range o.Value {\n\t\ttv := xVal[k]\n\t\tif !v.Equals(tv) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// IndexGet returns the value for the given key.\nfunc (o *Map) IndexGet(index Object) (res Object, err error) {\n\tstrIdx, ok := ToString(index)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tres, ok = o.Value[strIdx]\n\tif !ok {\n\t\tres = UndefinedValue\n\t}\n\treturn\n}\n\n// IndexSet sets the value for the given key.\nfunc (o *Map) IndexSet(index, value Object) (err error) {\n\tstrIdx, ok := ToString(index)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\to.Value[strIdx] = value\n\treturn nil\n}\n\n// Iterate creates a map iterator.\nfunc (o *Map) Iterate() Iterator {\n\tvar keys []string\n\tfor k := range o.Value {\n\t\tkeys = append(keys, k)\n\t}\n\treturn &MapIterator{\n\t\tv: o.Value,\n\t\tk: keys,\n\t\tl: len(keys),\n\t}\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *Map) CanIterate() bool {\n\treturn true\n}\n\n// ObjectPtr represents a free variable.\ntype ObjectPtr struct {\n\tObjectImpl\n\tValue *Object\n}\n\nfunc (o *ObjectPtr) String() string {\n\treturn \"free-var\"\n}\n\n// TypeName returns the name of the type.\nfunc (o *ObjectPtr) TypeName() string {\n\treturn \"<free-var>\"\n}\n\n// Copy returns a copy of the type.\nfunc (o *ObjectPtr) Copy() Object {\n\treturn o\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *ObjectPtr) IsFalsy() bool {\n\treturn o.Value == nil\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *ObjectPtr) Equals(x Object) bool {\n\treturn o == x\n}\n\n// String represents a string value.\ntype String struct {\n\tObjectImpl\n\tValue   string\n\truneStr []rune\n}\n\n// TypeName returns the name of the type.\nfunc (o *String) TypeName() string {\n\treturn \"string\"\n}\n\nfunc (o *String) String() string {\n\treturn strconv.Quote(o.Value)\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *String) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tswitch op {\n\tcase token.Add:\n\t\tswitch rhs := rhs.(type) {\n\t\tcase *String:\n\t\t\tif len(o.Value)+len(rhs.Value) > MaxStringLen {\n\t\t\t\treturn nil, ErrStringLimit\n\t\t\t}\n\t\t\treturn &String{Value: o.Value + rhs.Value}, nil\n\t\tdefault:\n\t\t\trhsStr := rhs.String()\n\t\t\tif len(o.Value)+len(rhsStr) > MaxStringLen {\n\t\t\t\treturn nil, ErrStringLimit\n\t\t\t}\n\t\t\treturn &String{Value: o.Value + rhsStr}, nil\n\t\t}\n\tcase token.Less:\n\t\tswitch rhs := rhs.(type) {\n\t\tcase *String:\n\t\t\tif o.Value < rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase token.LessEq:\n\t\tswitch rhs := rhs.(type) {\n\t\tcase *String:\n\t\t\tif o.Value <= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase token.Greater:\n\t\tswitch rhs := rhs.(type) {\n\t\tcase *String:\n\t\t\tif o.Value > rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\tcase token.GreaterEq:\n\t\tswitch rhs := rhs.(type) {\n\t\tcase *String:\n\t\t\tif o.Value >= rhs.Value {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *String) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\n// Copy returns a copy of the type.\nfunc (o *String) Copy() Object {\n\treturn &String{Value: o.Value}\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *String) Equals(x Object) bool {\n\tt, ok := x.(*String)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn o.Value == t.Value\n}\n\n// IndexGet returns a character at a given index.\nfunc (o *String) IndexGet(index Object) (res Object, err error) {\n\tintIdx, ok := index.(*Int)\n\tif !ok {\n\t\terr = ErrInvalidIndexType\n\t\treturn\n\t}\n\tidxVal := int(intIdx.Value)\n\tif o.runeStr == nil {\n\t\to.runeStr = []rune(o.Value)\n\t}\n\tif idxVal < 0 || idxVal >= len(o.runeStr) {\n\t\tres = UndefinedValue\n\t\treturn\n\t}\n\tres = &Char{Value: o.runeStr[idxVal]}\n\treturn\n}\n\n// Iterate creates a string iterator.\nfunc (o *String) Iterate() Iterator {\n\tif o.runeStr == nil {\n\t\to.runeStr = []rune(o.Value)\n\t}\n\treturn &StringIterator{\n\t\tv: o.runeStr,\n\t\tl: len(o.runeStr),\n\t}\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *String) CanIterate() bool {\n\treturn true\n}\n\n// Time represents a time value.\ntype Time struct {\n\tObjectImpl\n\tValue time.Time\n}\n\nfunc (o *Time) String() string {\n\treturn o.Value.String()\n}\n\n// TypeName returns the name of the type.\nfunc (o *Time) TypeName() string {\n\treturn \"time\"\n}\n\n// BinaryOp returns another object that is the result of a given binary\n// operator and a right-hand side object.\nfunc (o *Time) BinaryOp(op token.Token, rhs Object) (Object, error) {\n\tswitch rhs := rhs.(type) {\n\tcase *Int:\n\t\tswitch op {\n\t\tcase token.Add: // time + int => time\n\t\t\tif rhs.Value == 0 {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Time{Value: o.Value.Add(time.Duration(rhs.Value))}, nil\n\t\tcase token.Sub: // time - int => time\n\t\t\tif rhs.Value == 0 {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &Time{Value: o.Value.Add(time.Duration(-rhs.Value))}, nil\n\t\t}\n\tcase *Time:\n\t\tswitch op {\n\t\tcase token.Sub: // time - time => int (duration)\n\t\t\treturn &Int{Value: int64(o.Value.Sub(rhs.Value))}, nil\n\t\tcase token.Less: // time < time => bool\n\t\t\tif o.Value.Before(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.Greater:\n\t\t\tif o.Value.After(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.LessEq:\n\t\t\tif o.Value.Equal(rhs.Value) || o.Value.Before(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\tcase token.GreaterEq:\n\t\t\tif o.Value.Equal(rhs.Value) || o.Value.After(rhs.Value) {\n\t\t\t\treturn TrueValue, nil\n\t\t\t}\n\t\t\treturn FalseValue, nil\n\t\t}\n\t}\n\treturn nil, ErrInvalidOperator\n}\n\n// Copy returns a copy of the type.\nfunc (o *Time) Copy() Object {\n\treturn &Time{Value: o.Value}\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Time) IsFalsy() bool {\n\treturn o.Value.IsZero()\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Time) Equals(x Object) bool {\n\tt, ok := x.(*Time)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn o.Value.Equal(t.Value)\n}\n\n// Undefined represents an undefined value.\ntype Undefined struct {\n\tObjectImpl\n}\n\n// TypeName returns the name of the type.\nfunc (o *Undefined) TypeName() string {\n\treturn \"undefined\"\n}\n\nfunc (o *Undefined) String() string {\n\treturn \"<undefined>\"\n}\n\n// Copy returns a copy of the type.\nfunc (o *Undefined) Copy() Object {\n\treturn o\n}\n\n// IsFalsy returns true if the value of the type is falsy.\nfunc (o *Undefined) IsFalsy() bool {\n\treturn true\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *Undefined) Equals(x Object) bool {\n\treturn o == x\n}\n\n// IndexGet returns an element at a given index.\nfunc (o *Undefined) IndexGet(_ Object) (Object, error) {\n\treturn UndefinedValue, nil\n}\n\n// Iterate creates a map iterator.\nfunc (o *Undefined) Iterate() Iterator {\n\treturn o\n}\n\n// CanIterate returns whether the Object can be Iterated.\nfunc (o *Undefined) CanIterate() bool {\n\treturn true\n}\n\n// Next returns true if there are more elements to iterate.\nfunc (o *Undefined) Next() bool {\n\treturn false\n}\n\n// Key returns the key or index value of the current element.\nfunc (o *Undefined) Key() Object {\n\treturn o\n}\n\n// Value returns the value of the current element.\nfunc (o *Undefined) Value() Object {\n\treturn o\n}\n\n// UserFunction represents a user function.\ntype UserFunction struct {\n\tObjectImpl\n\tName  string\n\tValue CallableFunc\n}\n\n// TypeName returns the name of the type.\nfunc (o *UserFunction) TypeName() string {\n\treturn \"user-function:\" + o.Name\n}\n\nfunc (o *UserFunction) String() string {\n\treturn \"<user-function>\"\n}\n\n// Copy returns a copy of the type.\nfunc (o *UserFunction) Copy() Object {\n\treturn &UserFunction{Value: o.Value, Name: o.Name}\n}\n\n// Equals returns true if the value of the type is equal to the value of\n// another object.\nfunc (o *UserFunction) Equals(_ Object) bool {\n\treturn false\n}\n\n// Call invokes a user function.\nfunc (o *UserFunction) Call(args ...Object) (Object, error) {\n\treturn o.Value(args...)\n}\n\n// CanCall returns whether the Object can be Called.\nfunc (o *UserFunction) CanCall() bool {\n\treturn true\n}\n"
        },
        {
          "name": "objects_test.go",
          "type": "blob",
          "size": 21.3837890625,
          "content": "package tengo_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/require\"\n\t\"github.com/d5/tengo/v2/token\"\n)\n\nfunc TestObject_TypeName(t *testing.T) {\n\tvar o tengo.Object = &tengo.Int{}\n\trequire.Equal(t, \"int\", o.TypeName())\n\to = &tengo.Float{}\n\trequire.Equal(t, \"float\", o.TypeName())\n\to = &tengo.Char{}\n\trequire.Equal(t, \"char\", o.TypeName())\n\to = &tengo.String{}\n\trequire.Equal(t, \"string\", o.TypeName())\n\to = &tengo.Bool{}\n\trequire.Equal(t, \"bool\", o.TypeName())\n\to = &tengo.Array{}\n\trequire.Equal(t, \"array\", o.TypeName())\n\to = &tengo.Map{}\n\trequire.Equal(t, \"map\", o.TypeName())\n\to = &tengo.ArrayIterator{}\n\trequire.Equal(t, \"array-iterator\", o.TypeName())\n\to = &tengo.StringIterator{}\n\trequire.Equal(t, \"string-iterator\", o.TypeName())\n\to = &tengo.MapIterator{}\n\trequire.Equal(t, \"map-iterator\", o.TypeName())\n\to = &tengo.BuiltinFunction{Name: \"fn\"}\n\trequire.Equal(t, \"builtin-function:fn\", o.TypeName())\n\to = &tengo.UserFunction{Name: \"fn\"}\n\trequire.Equal(t, \"user-function:fn\", o.TypeName())\n\to = &tengo.CompiledFunction{}\n\trequire.Equal(t, \"compiled-function\", o.TypeName())\n\to = &tengo.Undefined{}\n\trequire.Equal(t, \"undefined\", o.TypeName())\n\to = &tengo.Error{}\n\trequire.Equal(t, \"error\", o.TypeName())\n\to = &tengo.Bytes{}\n\trequire.Equal(t, \"bytes\", o.TypeName())\n}\n\nfunc TestObject_IsFalsy(t *testing.T) {\n\tvar o tengo.Object = &tengo.Int{Value: 0}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.Int{Value: 1}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Float{Value: 0}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Float{Value: 1}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Char{Value: ' '}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Char{Value: 'T'}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.String{Value: \"\"}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.String{Value: \" \"}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Array{Value: nil}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.Array{Value: []tengo.Object{nil}} // nil is not valid but still count as 1 element\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Map{Value: nil}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.Map{Value: map[string]tengo.Object{\"a\": nil}} // nil is not valid but still count as 1 element\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.StringIterator{}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.ArrayIterator{}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.MapIterator{}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.BuiltinFunction{}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.CompiledFunction{}\n\trequire.False(t, o.IsFalsy())\n\to = &tengo.Undefined{}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.Error{}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.Bytes{}\n\trequire.True(t, o.IsFalsy())\n\to = &tengo.Bytes{Value: []byte{1, 2}}\n\trequire.False(t, o.IsFalsy())\n}\n\nfunc TestObject_String(t *testing.T) {\n\tvar o tengo.Object = &tengo.Int{Value: 0}\n\trequire.Equal(t, \"0\", o.String())\n\to = &tengo.Int{Value: 1}\n\trequire.Equal(t, \"1\", o.String())\n\to = &tengo.Float{Value: 0}\n\trequire.Equal(t, \"0\", o.String())\n\to = &tengo.Float{Value: 1}\n\trequire.Equal(t, \"1\", o.String())\n\to = &tengo.Char{Value: ' '}\n\trequire.Equal(t, \" \", o.String())\n\to = &tengo.Char{Value: 'T'}\n\trequire.Equal(t, \"T\", o.String())\n\to = &tengo.String{Value: \"\"}\n\trequire.Equal(t, `\"\"`, o.String())\n\to = &tengo.String{Value: \" \"}\n\trequire.Equal(t, `\" \"`, o.String())\n\to = &tengo.Array{Value: nil}\n\trequire.Equal(t, \"[]\", o.String())\n\to = &tengo.Map{Value: nil}\n\trequire.Equal(t, \"{}\", o.String())\n\to = &tengo.Error{Value: nil}\n\trequire.Equal(t, \"error\", o.String())\n\to = &tengo.Error{Value: &tengo.String{Value: \"error 1\"}}\n\trequire.Equal(t, `error: \"error 1\"`, o.String())\n\to = &tengo.StringIterator{}\n\trequire.Equal(t, \"<string-iterator>\", o.String())\n\to = &tengo.ArrayIterator{}\n\trequire.Equal(t, \"<array-iterator>\", o.String())\n\to = &tengo.MapIterator{}\n\trequire.Equal(t, \"<map-iterator>\", o.String())\n\to = &tengo.Undefined{}\n\trequire.Equal(t, \"<undefined>\", o.String())\n\to = &tengo.Bytes{}\n\trequire.Equal(t, \"\", o.String())\n\to = &tengo.Bytes{Value: []byte(\"foo\")}\n\trequire.Equal(t, \"foo\", o.String())\n}\n\nfunc TestObject_BinaryOp(t *testing.T) {\n\tvar o tengo.Object = &tengo.Char{}\n\t_, err := o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.Bool{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.Map{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.ArrayIterator{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.StringIterator{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.MapIterator{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.BuiltinFunction{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.CompiledFunction{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.Undefined{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n\to = &tengo.Error{}\n\t_, err = o.BinaryOp(token.Add, tengo.UndefinedValue)\n\trequire.Error(t, err)\n}\n\nfunc TestArray_BinaryOp(t *testing.T) {\n\ttestBinaryOp(t, &tengo.Array{Value: nil}, token.Add,\n\t\t&tengo.Array{Value: nil}, &tengo.Array{Value: nil})\n\ttestBinaryOp(t, &tengo.Array{Value: nil}, token.Add,\n\t\t&tengo.Array{Value: []tengo.Object{}}, &tengo.Array{Value: nil})\n\ttestBinaryOp(t, &tengo.Array{Value: []tengo.Object{}}, token.Add,\n\t\t&tengo.Array{Value: nil}, &tengo.Array{Value: []tengo.Object{}})\n\ttestBinaryOp(t, &tengo.Array{Value: []tengo.Object{}}, token.Add,\n\t\t&tengo.Array{Value: []tengo.Object{}},\n\t\t&tengo.Array{Value: []tengo.Object{}})\n\ttestBinaryOp(t, &tengo.Array{Value: nil}, token.Add,\n\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 1},\n\t\t}}, &tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 1},\n\t\t}})\n\ttestBinaryOp(t, &tengo.Array{Value: nil}, token.Add,\n\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 1},\n\t\t\t&tengo.Int{Value: 2},\n\t\t\t&tengo.Int{Value: 3},\n\t\t}}, &tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 1},\n\t\t\t&tengo.Int{Value: 2},\n\t\t\t&tengo.Int{Value: 3},\n\t\t}})\n\ttestBinaryOp(t, &tengo.Array{Value: []tengo.Object{\n\t\t&tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: 2},\n\t\t&tengo.Int{Value: 3},\n\t}}, token.Add, &tengo.Array{Value: nil},\n\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 1},\n\t\t\t&tengo.Int{Value: 2},\n\t\t\t&tengo.Int{Value: 3},\n\t\t}})\n\ttestBinaryOp(t, &tengo.Array{Value: []tengo.Object{\n\t\t&tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: 2},\n\t\t&tengo.Int{Value: 3},\n\t}}, token.Add, &tengo.Array{Value: []tengo.Object{\n\t\t&tengo.Int{Value: 4},\n\t\t&tengo.Int{Value: 5},\n\t\t&tengo.Int{Value: 6},\n\t}}, &tengo.Array{Value: []tengo.Object{\n\t\t&tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: 2},\n\t\t&tengo.Int{Value: 3},\n\t\t&tengo.Int{Value: 4},\n\t\t&tengo.Int{Value: 5},\n\t\t&tengo.Int{Value: 6},\n\t}})\n}\n\nfunc TestError_Equals(t *testing.T) {\n\terr1 := &tengo.Error{Value: &tengo.String{Value: \"some error\"}}\n\terr2 := err1\n\trequire.True(t, err1.Equals(err2))\n\trequire.True(t, err2.Equals(err1))\n\n\terr2 = &tengo.Error{Value: &tengo.String{Value: \"some error\"}}\n\trequire.False(t, err1.Equals(err2))\n\trequire.False(t, err2.Equals(err1))\n}\n\nfunc TestFloat_BinaryOp(t *testing.T) {\n\t// float + float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Add,\n\t\t\t\t&tengo.Float{Value: r}, &tengo.Float{Value: l + r})\n\t\t}\n\t}\n\n\t// float - float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Sub,\n\t\t\t\t&tengo.Float{Value: r}, &tengo.Float{Value: l - r})\n\t\t}\n\t}\n\n\t// float * float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Mul,\n\t\t\t\t&tengo.Float{Value: r}, &tengo.Float{Value: l * r})\n\t\t}\n\t}\n\n\t// float / float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\tif r != 0 {\n\t\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Quo,\n\t\t\t\t\t&tengo.Float{Value: r}, &tengo.Float{Value: l / r})\n\t\t\t}\n\t\t}\n\t}\n\n\t// float < float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Less,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(l < r))\n\t\t}\n\t}\n\n\t// float > float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Greater,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(l > r))\n\t\t}\n\t}\n\n\t// float <= float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.LessEq,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(l <= r))\n\t\t}\n\t}\n\n\t// float >= float\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.4 {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.GreaterEq,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(l >= r))\n\t\t}\n\t}\n\n\t// float + int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Add,\n\t\t\t\t&tengo.Int{Value: r}, &tengo.Float{Value: l + float64(r)})\n\t\t}\n\t}\n\n\t// float - int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Sub,\n\t\t\t\t&tengo.Int{Value: r}, &tengo.Float{Value: l - float64(r)})\n\t\t}\n\t}\n\n\t// float * int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Mul,\n\t\t\t\t&tengo.Int{Value: r}, &tengo.Float{Value: l * float64(r)})\n\t\t}\n\t}\n\n\t// float / int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\tif r != 0 {\n\t\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Quo,\n\t\t\t\t\t&tengo.Int{Value: r},\n\t\t\t\t\t&tengo.Float{Value: l / float64(r)})\n\t\t\t}\n\t\t}\n\t}\n\n\t// float < int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Less,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l < float64(r)))\n\t\t}\n\t}\n\n\t// float > int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.Greater,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l > float64(r)))\n\t\t}\n\t}\n\n\t// float <= int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.LessEq,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l <= float64(r)))\n\t\t}\n\t}\n\n\t// float >= int\n\tfor l := float64(-2); l <= 2.1; l += 0.4 {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Float{Value: l}, token.GreaterEq,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l >= float64(r)))\n\t\t}\n\t}\n}\n\nfunc TestInt_BinaryOp(t *testing.T) {\n\t// int + int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Add,\n\t\t\t\t&tengo.Int{Value: r}, &tengo.Int{Value: l + r})\n\t\t}\n\t}\n\n\t// int - int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Sub,\n\t\t\t\t&tengo.Int{Value: r}, &tengo.Int{Value: l - r})\n\t\t}\n\t}\n\n\t// int * int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Mul,\n\t\t\t\t&tengo.Int{Value: r}, &tengo.Int{Value: l * r})\n\t\t}\n\t}\n\n\t// int / int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\tif r != 0 {\n\t\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Quo,\n\t\t\t\t\t&tengo.Int{Value: r}, &tengo.Int{Value: l / r})\n\t\t\t}\n\t\t}\n\t}\n\n\t// int % int\n\tfor l := int64(-4); l <= 4; l++ {\n\t\tfor r := -int64(-4); r <= 4; r++ {\n\t\t\tif r == 0 {\n\t\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Rem,\n\t\t\t\t\t&tengo.Int{Value: r}, &tengo.Int{Value: l % r})\n\t\t\t}\n\t\t}\n\t}\n\n\t// int & int\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.And, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.And, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(1) & int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.And, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(0) & int64(1)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.And, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(1)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.And, &tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0) & int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.And, &tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1) & int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: int64(0xffffffff)}, token.And,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1984}, token.And,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1984) & int64(0xffffffff)})\n\ttestBinaryOp(t, &tengo.Int{Value: -1984}, token.And,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(-1984) & int64(0xffffffff)})\n\n\t// int | int\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.Or, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.Or, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(1) | int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.Or, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(0) | int64(1)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.Or, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(1)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.Or, &tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0) | int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.Or, &tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1) | int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: int64(0xffffffff)}, token.Or,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1984}, token.Or,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1984) | int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: -1984}, token.Or,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(-1984) | int64(0xffffffff)})\n\n\t// int ^ int\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.Xor, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.Xor, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(1) ^ int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.Xor, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(0) ^ int64(1)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.Xor, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.Xor, &tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0) ^ int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.Xor, &tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1) ^ int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: int64(0xffffffff)}, token.Xor,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1984}, token.Xor,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1984) ^ int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: -1984}, token.Xor,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(-1984) ^ int64(0xffffffff)})\n\n\t// int &^ int\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.AndNot, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.AndNot, &tengo.Int{Value: 0},\n\t\t&tengo.Int{Value: int64(1) &^ int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.AndNot,\n\t\t&tengo.Int{Value: 1}, &tengo.Int{Value: int64(0) &^ int64(1)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.AndNot, &tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 0}, token.AndNot,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0) &^ int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1}, token.AndNot,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1) &^ int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: int64(0xffffffff)}, token.AndNot,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(0)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: 1984}, token.AndNot,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(1984) &^ int64(0xffffffff)})\n\ttestBinaryOp(t,\n\t\t&tengo.Int{Value: -1984}, token.AndNot,\n\t\t&tengo.Int{Value: int64(0xffffffff)},\n\t\t&tengo.Int{Value: int64(-1984) &^ int64(0xffffffff)})\n\n\t// int << int\n\tfor s := int64(0); s < 64; s++ {\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: 0}, token.Shl, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(0) << uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: 1}, token.Shl, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(1) << uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: 2}, token.Shl, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(2) << uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: -1}, token.Shl, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(-1) << uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: -2}, token.Shl, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(-2) << uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: int64(0xffffffff)}, token.Shl,\n\t\t\t&tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(0xffffffff) << uint(s)})\n\t}\n\n\t// int >> int\n\tfor s := int64(0); s < 64; s++ {\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: 0}, token.Shr, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(0) >> uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: 1}, token.Shr, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(1) >> uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: 2}, token.Shr, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(2) >> uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: -1}, token.Shr, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(-1) >> uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: -2}, token.Shr, &tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(-2) >> uint(s)})\n\t\ttestBinaryOp(t,\n\t\t\t&tengo.Int{Value: int64(0xffffffff)}, token.Shr,\n\t\t\t&tengo.Int{Value: s},\n\t\t\t&tengo.Int{Value: int64(0xffffffff) >> uint(s)})\n\t}\n\n\t// int < int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Less,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l < r))\n\t\t}\n\t}\n\n\t// int > int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Greater,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l > r))\n\t\t}\n\t}\n\n\t// int <= int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.LessEq,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l <= r))\n\t\t}\n\t}\n\n\t// int >= int\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := int64(-2); r <= 2; r++ {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.GreaterEq,\n\t\t\t\t&tengo.Int{Value: r}, boolValue(l >= r))\n\t\t}\n\t}\n\n\t// int + float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Add,\n\t\t\t\t&tengo.Float{Value: r},\n\t\t\t\t&tengo.Float{Value: float64(l) + r})\n\t\t}\n\t}\n\n\t// int - float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Sub,\n\t\t\t\t&tengo.Float{Value: r},\n\t\t\t\t&tengo.Float{Value: float64(l) - r})\n\t\t}\n\t}\n\n\t// int * float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Mul,\n\t\t\t\t&tengo.Float{Value: r},\n\t\t\t\t&tengo.Float{Value: float64(l) * r})\n\t\t}\n\t}\n\n\t// int / float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\tif r != 0 {\n\t\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Quo,\n\t\t\t\t\t&tengo.Float{Value: r},\n\t\t\t\t\t&tengo.Float{Value: float64(l) / r})\n\t\t\t}\n\t\t}\n\t}\n\n\t// int < float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Less,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(float64(l) < r))\n\t\t}\n\t}\n\n\t// int > float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.Greater,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(float64(l) > r))\n\t\t}\n\t}\n\n\t// int <= float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.LessEq,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(float64(l) <= r))\n\t\t}\n\t}\n\n\t// int >= float\n\tfor l := int64(-2); l <= 2; l++ {\n\t\tfor r := float64(-2); r <= 2.1; r += 0.5 {\n\t\t\ttestBinaryOp(t, &tengo.Int{Value: l}, token.GreaterEq,\n\t\t\t\t&tengo.Float{Value: r}, boolValue(float64(l) >= r))\n\t\t}\n\t}\n}\n\nfunc TestMap_Index(t *testing.T) {\n\tm := &tengo.Map{Value: make(map[string]tengo.Object)}\n\tk := &tengo.Int{Value: 1}\n\tv := &tengo.String{Value: \"abcdef\"}\n\terr := m.IndexSet(k, v)\n\n\trequire.NoError(t, err)\n\n\tres, err := m.IndexGet(k)\n\trequire.NoError(t, err)\n\trequire.Equal(t, v, res)\n}\n\nfunc TestString_BinaryOp(t *testing.T) {\n\tlstr := \"abcde\"\n\trstr := \"01234\"\n\tfor l := 0; l < len(lstr); l++ {\n\t\tfor r := 0; r < len(rstr); r++ {\n\t\t\tls := lstr[l:]\n\t\t\trs := rstr[r:]\n\t\t\ttestBinaryOp(t, &tengo.String{Value: ls}, token.Add,\n\t\t\t\t&tengo.String{Value: rs},\n\t\t\t\t&tengo.String{Value: ls + rs})\n\n\t\t\trc := []rune(rstr)[r]\n\t\t\ttestBinaryOp(t, &tengo.String{Value: ls}, token.Add,\n\t\t\t\t&tengo.Char{Value: rc},\n\t\t\t\t&tengo.String{Value: ls + string(rc)})\n\t\t}\n\t}\n}\n\nfunc testBinaryOp(\n\tt *testing.T,\n\tlhs tengo.Object,\n\top token.Token,\n\trhs tengo.Object,\n\texpected tengo.Object,\n) {\n\tt.Helper()\n\tactual, err := lhs.BinaryOp(op, rhs)\n\trequire.NoError(t, err)\n\trequire.Equal(t, expected, actual)\n}\n\nfunc boolValue(b bool) tengo.Object {\n\tif b {\n\t\treturn tengo.TrueValue\n\t}\n\treturn tengo.FalseValue\n}\n"
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "require",
          "type": "tree",
          "content": null
        },
        {
          "name": "script.go",
          "type": "blob",
          "size": 7.4658203125,
          "content": "package tengo\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"github.com/d5/tengo/v2/parser\"\n)\n\n// Script can simplify compilation and execution of embedded scripts.\ntype Script struct {\n\tvariables        map[string]*Variable\n\tmodules          ModuleGetter\n\tinput            []byte\n\tmaxAllocs        int64\n\tmaxConstObjects  int\n\tenableFileImport bool\n\timportDir        string\n}\n\n// NewScript creates a Script instance with an input script.\nfunc NewScript(input []byte) *Script {\n\treturn &Script{\n\t\tvariables:       make(map[string]*Variable),\n\t\tinput:           input,\n\t\tmaxAllocs:       -1,\n\t\tmaxConstObjects: -1,\n\t}\n}\n\n// Add adds a new variable or updates an existing variable to the script.\nfunc (s *Script) Add(name string, value interface{}) error {\n\tobj, err := FromInterface(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.variables[name] = &Variable{\n\t\tname:  name,\n\t\tvalue: obj,\n\t}\n\treturn nil\n}\n\n// Remove removes (undefines) an existing variable for the script. It returns\n// false if the variable name is not defined.\nfunc (s *Script) Remove(name string) bool {\n\tif _, ok := s.variables[name]; !ok {\n\t\treturn false\n\t}\n\tdelete(s.variables, name)\n\treturn true\n}\n\n// SetImports sets import modules.\nfunc (s *Script) SetImports(modules ModuleGetter) {\n\ts.modules = modules\n}\n\n// SetImportDir sets the initial import directory for script files.\nfunc (s *Script) SetImportDir(dir string) error {\n\tdir, err := filepath.Abs(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.importDir = dir\n\treturn nil\n}\n\n// SetMaxAllocs sets the maximum number of objects allocations during the run\n// time. Compiled script will return ErrObjectAllocLimit error if it\n// exceeds this limit.\nfunc (s *Script) SetMaxAllocs(n int64) {\n\ts.maxAllocs = n\n}\n\n// SetMaxConstObjects sets the maximum number of objects in the compiled\n// constants.\nfunc (s *Script) SetMaxConstObjects(n int) {\n\ts.maxConstObjects = n\n}\n\n// EnableFileImport enables or disables module loading from local files. Local\n// file modules are disabled by default.\nfunc (s *Script) EnableFileImport(enable bool) {\n\ts.enableFileImport = enable\n}\n\n// Compile compiles the script with all the defined variables, and, returns\n// Compiled object.\nfunc (s *Script) Compile() (*Compiled, error) {\n\tsymbolTable, globals, err := s.prepCompile()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfileSet := parser.NewFileSet()\n\tsrcFile := fileSet.AddFile(\"(main)\", -1, len(s.input))\n\tp := parser.NewParser(srcFile, s.input, nil)\n\tfile, err := p.ParseFile()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc := NewCompiler(srcFile, symbolTable, nil, s.modules, nil)\n\tc.EnableFileImport(s.enableFileImport)\n\tc.SetImportDir(s.importDir)\n\tif err := c.Compile(file); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// reduce globals size\n\tglobals = globals[:symbolTable.MaxSymbols()+1]\n\n\t// global symbol names to indexes\n\tglobalIndexes := make(map[string]int, len(globals))\n\tfor _, name := range symbolTable.Names() {\n\t\tsymbol, _, _ := symbolTable.Resolve(name, false)\n\t\tif symbol.Scope == ScopeGlobal {\n\t\t\tglobalIndexes[name] = symbol.Index\n\t\t}\n\t}\n\n\t// remove duplicates from constants\n\tbytecode := c.Bytecode()\n\tbytecode.RemoveDuplicates()\n\n\t// check the constant objects limit\n\tif s.maxConstObjects >= 0 {\n\t\tcnt := bytecode.CountObjects()\n\t\tif cnt > s.maxConstObjects {\n\t\t\treturn nil, fmt.Errorf(\"exceeding constant objects limit: %d\", cnt)\n\t\t}\n\t}\n\treturn &Compiled{\n\t\tglobalIndexes: globalIndexes,\n\t\tbytecode:      bytecode,\n\t\tglobals:       globals,\n\t\tmaxAllocs:     s.maxAllocs,\n\t}, nil\n}\n\n// Run compiles and runs the scripts. Use returned compiled object to access\n// global variables.\nfunc (s *Script) Run() (compiled *Compiled, err error) {\n\tcompiled, err = s.Compile()\n\tif err != nil {\n\t\treturn\n\t}\n\terr = compiled.Run()\n\treturn\n}\n\n// RunContext is like Run but includes a context.\nfunc (s *Script) RunContext(\n\tctx context.Context,\n) (compiled *Compiled, err error) {\n\tcompiled, err = s.Compile()\n\tif err != nil {\n\t\treturn\n\t}\n\terr = compiled.RunContext(ctx)\n\treturn\n}\n\nfunc (s *Script) prepCompile() (\n\tsymbolTable *SymbolTable,\n\tglobals []Object,\n\terr error,\n) {\n\tvar names []string\n\tfor name := range s.variables {\n\t\tnames = append(names, name)\n\t}\n\n\tsymbolTable = NewSymbolTable()\n\tfor idx, fn := range builtinFuncs {\n\t\tsymbolTable.DefineBuiltin(idx, fn.Name)\n\t}\n\n\tglobals = make([]Object, GlobalsSize)\n\n\tfor idx, name := range names {\n\t\tsymbol := symbolTable.Define(name)\n\t\tif symbol.Index != idx {\n\t\t\tpanic(fmt.Errorf(\"wrong symbol index: %d != %d\",\n\t\t\t\tidx, symbol.Index))\n\t\t}\n\t\tglobals[symbol.Index] = s.variables[name].value\n\t}\n\treturn\n}\n\n// Compiled is a compiled instance of the user script. Use Script.Compile() to\n// create Compiled object.\ntype Compiled struct {\n\tglobalIndexes map[string]int // global symbol name to index\n\tbytecode      *Bytecode\n\tglobals       []Object\n\tmaxAllocs     int64\n\tlock          sync.RWMutex\n}\n\n// Run executes the compiled script in the virtual machine.\nfunc (c *Compiled) Run() error {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tv := NewVM(c.bytecode, c.globals, c.maxAllocs)\n\treturn v.Run()\n}\n\n// RunContext is like Run but includes a context.\nfunc (c *Compiled) RunContext(ctx context.Context) (err error) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tv := NewVM(c.bytecode, c.globals, c.maxAllocs)\n\tch := make(chan error, 1)\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tswitch e := r.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\tch <- fmt.Errorf(e)\n\t\t\t\tcase error:\n\t\t\t\t\tch <- e\n\t\t\t\tdefault:\n\t\t\t\t\tch <- fmt.Errorf(\"unknown panic: %v\", e)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tch <- v.Run()\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\tv.Abort()\n\t\t<-ch\n\t\terr = ctx.Err()\n\tcase err = <-ch:\n\t}\n\treturn\n}\n\n// Clone creates a new copy of Compiled. Cloned copies are safe for concurrent\n// use by multiple goroutines.\nfunc (c *Compiled) Clone() *Compiled {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\n\tclone := &Compiled{\n\t\tglobalIndexes: c.globalIndexes,\n\t\tbytecode:      c.bytecode,\n\t\tglobals:       make([]Object, len(c.globals)),\n\t\tmaxAllocs:     c.maxAllocs,\n\t}\n\t// copy global objects\n\tfor idx, g := range c.globals {\n\t\tif g != nil {\n\t\t\tclone.globals[idx] = g.Copy()\n\t\t}\n\t}\n\treturn clone\n}\n\n// IsDefined returns true if the variable name is defined (has value) before or\n// after the execution.\nfunc (c *Compiled) IsDefined(name string) bool {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\n\tidx, ok := c.globalIndexes[name]\n\tif !ok {\n\t\treturn false\n\t}\n\tv := c.globals[idx]\n\tif v == nil {\n\t\treturn false\n\t}\n\treturn v != UndefinedValue\n}\n\n// Get returns a variable identified by the name.\nfunc (c *Compiled) Get(name string) *Variable {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\n\tvalue := UndefinedValue\n\tif idx, ok := c.globalIndexes[name]; ok {\n\t\tvalue = c.globals[idx]\n\t\tif value == nil {\n\t\t\tvalue = UndefinedValue\n\t\t}\n\t}\n\treturn &Variable{\n\t\tname:  name,\n\t\tvalue: value,\n\t}\n}\n\n// GetAll returns all the variables that are defined by the compiled script.\nfunc (c *Compiled) GetAll() []*Variable {\n\tc.lock.RLock()\n\tdefer c.lock.RUnlock()\n\n\tvar vars []*Variable\n\tfor name, idx := range c.globalIndexes {\n\t\tvalue := c.globals[idx]\n\t\tif value == nil {\n\t\t\tvalue = UndefinedValue\n\t\t}\n\t\tvars = append(vars, &Variable{\n\t\t\tname:  name,\n\t\t\tvalue: value,\n\t\t})\n\t}\n\treturn vars\n}\n\n// Set replaces the value of a global variable identified by the name. An error\n// will be returned if the name was not defined during compilation.\nfunc (c *Compiled) Set(name string, value interface{}) error {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tobj, err := FromInterface(value)\n\tif err != nil {\n\t\treturn err\n\t}\n\tidx, ok := c.globalIndexes[name]\n\tif !ok {\n\t\treturn fmt.Errorf(\"'%s' is not defined\", name)\n\t}\n\tc.globals[idx] = obj\n\treturn nil\n}\n"
        },
        {
          "name": "script_test.go",
          "type": "blob",
          "size": 14.8056640625,
          "content": "package tengo_test\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/require\"\n\t\"github.com/d5/tengo/v2/stdlib\"\n\t\"github.com/d5/tengo/v2/token\"\n)\n\nfunc TestScript_Add(t *testing.T) {\n\ts := tengo.NewScript([]byte(`a := b; c := test(b); d := test(5)`))\n\trequire.NoError(t, s.Add(\"b\", 5))     // b = 5\n\trequire.NoError(t, s.Add(\"b\", \"foo\")) // b = \"foo\"  (re-define before compilation)\n\trequire.NoError(t, s.Add(\"test\",\n\t\tfunc(args ...tengo.Object) (ret tengo.Object, err error) {\n\t\t\tif len(args) > 0 {\n\t\t\t\tswitch arg := args[0].(type) {\n\t\t\t\tcase *tengo.Int:\n\t\t\t\t\treturn &tengo.Int{Value: arg.Value + 1}, nil\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn &tengo.Int{Value: 0}, nil\n\t\t}))\n\tc, err := s.Compile()\n\trequire.NoError(t, err)\n\trequire.NoError(t, c.Run())\n\trequire.Equal(t, \"foo\", c.Get(\"a\").Value())\n\trequire.Equal(t, \"foo\", c.Get(\"b\").Value())\n\trequire.Equal(t, int64(0), c.Get(\"c\").Value())\n\trequire.Equal(t, int64(6), c.Get(\"d\").Value())\n}\n\nfunc TestScript_Remove(t *testing.T) {\n\ts := tengo.NewScript([]byte(`a := b`))\n\terr := s.Add(\"b\", 5)\n\trequire.NoError(t, err)\n\trequire.True(t, s.Remove(\"b\")) // b is removed\n\t_, err = s.Compile()           // should not compile because b is undefined\n\trequire.Error(t, err)\n}\n\nfunc TestScript_Run(t *testing.T) {\n\ts := tengo.NewScript([]byte(`a := b`))\n\terr := s.Add(\"b\", 5)\n\trequire.NoError(t, err)\n\tc, err := s.Run()\n\trequire.NoError(t, err)\n\trequire.NotNil(t, c)\n\tcompiledGet(t, c, \"a\", int64(5))\n}\n\nfunc TestScript_BuiltinModules(t *testing.T) {\n\ts := tengo.NewScript([]byte(`math := import(\"math\"); a := math.abs(-19.84)`))\n\ts.SetImports(stdlib.GetModuleMap(\"math\"))\n\tc, err := s.Run()\n\trequire.NoError(t, err)\n\trequire.NotNil(t, c)\n\tcompiledGet(t, c, \"a\", 19.84)\n\n\tc, err = s.Run()\n\trequire.NoError(t, err)\n\trequire.NotNil(t, c)\n\tcompiledGet(t, c, \"a\", 19.84)\n\n\ts.SetImports(stdlib.GetModuleMap(\"os\"))\n\t_, err = s.Run()\n\trequire.Error(t, err)\n\n\ts.SetImports(nil)\n\t_, err = s.Run()\n\trequire.Error(t, err)\n}\n\nfunc TestScript_SourceModules(t *testing.T) {\n\ts := tengo.NewScript([]byte(`\nenum := import(\"enum\")\na := enum.all([1,2,3], func(_, v) { \n\treturn v > 0 \n})\n`))\n\ts.SetImports(stdlib.GetModuleMap(\"enum\"))\n\tc, err := s.Run()\n\trequire.NoError(t, err)\n\trequire.NotNil(t, c)\n\tcompiledGet(t, c, \"a\", true)\n\n\ts.SetImports(nil)\n\t_, err = s.Run()\n\trequire.Error(t, err)\n}\n\nfunc TestScript_SetMaxConstObjects(t *testing.T) {\n\t// one constant '5'\n\ts := tengo.NewScript([]byte(`a := 5`))\n\ts.SetMaxConstObjects(1) // limit = 1\n\t_, err := s.Compile()\n\trequire.NoError(t, err)\n\ts.SetMaxConstObjects(0) // limit = 0\n\t_, err = s.Compile()\n\trequire.Error(t, err)\n\trequire.Equal(t, \"exceeding constant objects limit: 1\", err.Error())\n\n\t// two constants '5' and '1'\n\ts = tengo.NewScript([]byte(`a := 5 + 1`))\n\ts.SetMaxConstObjects(2) // limit = 2\n\t_, err = s.Compile()\n\trequire.NoError(t, err)\n\ts.SetMaxConstObjects(1) // limit = 1\n\t_, err = s.Compile()\n\trequire.Error(t, err)\n\trequire.Equal(t, \"exceeding constant objects limit: 2\", err.Error())\n\n\t// duplicates will be removed\n\ts = tengo.NewScript([]byte(`a := 5 + 5`))\n\ts.SetMaxConstObjects(1) // limit = 1\n\t_, err = s.Compile()\n\trequire.NoError(t, err)\n\ts.SetMaxConstObjects(0) // limit = 0\n\t_, err = s.Compile()\n\trequire.Error(t, err)\n\trequire.Equal(t, \"exceeding constant objects limit: 1\", err.Error())\n\n\t// no limit set\n\ts = tengo.NewScript([]byte(`a := 1 + 2 + 3 + 4 + 5`))\n\t_, err = s.Compile()\n\trequire.NoError(t, err)\n}\n\nfunc TestScriptConcurrency(t *testing.T) {\n\tsolve := func(a, b, c int) (d, e int) {\n\t\ta += 2\n\t\tb += c\n\t\ta += b * 2\n\t\td = a + b + c\n\t\te = 0\n\t\tfor i := 1; i <= d; i++ {\n\t\t\te += i\n\t\t}\n\t\te *= 2\n\t\treturn\n\t}\n\n\tcode := []byte(`\nmod1 := import(\"mod1\")\n\na += 2\nb += c\na += b * 2\n\narr := [a, b, c]\narrstr := string(arr)\nmap := {a: a, b: b, c: c}\n\nd := a + b + c\ns := 0\n\nfor i:=1; i<=d; i++ {\n\ts += i\n}\n\ne := mod1.double(s)\n`)\n\tmod1 := map[string]tengo.Object{\n\t\t\"double\": &tengo.UserFunction{\n\t\t\tValue: func(args ...tengo.Object) (\n\t\t\t\tret tengo.Object,\n\t\t\t\terr error,\n\t\t\t) {\n\t\t\t\targ0, _ := tengo.ToInt64(args[0])\n\t\t\t\tret = &tengo.Int{Value: arg0 * 2}\n\t\t\t\treturn\n\t\t\t},\n\t\t},\n\t}\n\n\tscr := tengo.NewScript(code)\n\t_ = scr.Add(\"a\", 0)\n\t_ = scr.Add(\"b\", 0)\n\t_ = scr.Add(\"c\", 0)\n\tmods := tengo.NewModuleMap()\n\tmods.AddBuiltinModule(\"mod1\", mod1)\n\tscr.SetImports(mods)\n\tcompiled, err := scr.Compile()\n\trequire.NoError(t, err)\n\n\texecuteFn := func(compiled *tengo.Compiled, a, b, c int) (d, e int) {\n\t\t_ = compiled.Set(\"a\", a)\n\t\t_ = compiled.Set(\"b\", b)\n\t\t_ = compiled.Set(\"c\", c)\n\t\terr := compiled.Run()\n\t\trequire.NoError(t, err)\n\t\td = compiled.Get(\"d\").Int()\n\t\te = compiled.Get(\"e\").Int()\n\t\treturn\n\t}\n\n\tconcurrency := 500\n\tvar wg sync.WaitGroup\n\twg.Add(concurrency)\n\tfor i := 0; i < concurrency; i++ {\n\t\tgo func(compiled *tengo.Compiled) {\n\t\t\ttime.Sleep(time.Duration(rand.Int63n(50)) * time.Millisecond)\n\t\t\tdefer wg.Done()\n\n\t\t\ta := rand.Intn(10)\n\t\t\tb := rand.Intn(10)\n\t\t\tc := rand.Intn(10)\n\n\t\t\td, e := executeFn(compiled, a, b, c)\n\t\t\texpectedD, expectedE := solve(a, b, c)\n\n\t\t\trequire.Equal(t, expectedD, d, \"input: %d, %d, %d\", a, b, c)\n\t\t\trequire.Equal(t, expectedE, e, \"input: %d, %d, %d\", a, b, c)\n\t\t}(compiled.Clone())\n\t}\n\twg.Wait()\n}\n\ntype Counter struct {\n\ttengo.ObjectImpl\n\tvalue int64\n}\n\nfunc (o *Counter) TypeName() string {\n\treturn \"counter\"\n}\n\nfunc (o *Counter) String() string {\n\treturn fmt.Sprintf(\"Counter(%d)\", o.value)\n}\n\nfunc (o *Counter) BinaryOp(\n\top token.Token,\n\trhs tengo.Object,\n) (tengo.Object, error) {\n\tswitch rhs := rhs.(type) {\n\tcase *Counter:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\treturn &Counter{value: o.value + rhs.value}, nil\n\t\tcase token.Sub:\n\t\t\treturn &Counter{value: o.value - rhs.value}, nil\n\t\t}\n\tcase *tengo.Int:\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\treturn &Counter{value: o.value + rhs.Value}, nil\n\t\tcase token.Sub:\n\t\t\treturn &Counter{value: o.value - rhs.Value}, nil\n\t\t}\n\t}\n\n\treturn nil, errors.New(\"invalid operator\")\n}\n\nfunc (o *Counter) IsFalsy() bool {\n\treturn o.value == 0\n}\n\nfunc (o *Counter) Equals(t tengo.Object) bool {\n\tif tc, ok := t.(*Counter); ok {\n\t\treturn o.value == tc.value\n\t}\n\n\treturn false\n}\n\nfunc (o *Counter) Copy() tengo.Object {\n\treturn &Counter{value: o.value}\n}\n\nfunc (o *Counter) Call(_ ...tengo.Object) (tengo.Object, error) {\n\treturn &tengo.Int{Value: o.value}, nil\n}\n\nfunc (o *Counter) CanCall() bool {\n\treturn true\n}\n\nfunc TestScript_CustomObjects(t *testing.T) {\n\tc := compile(t, `a := c1(); s := string(c1); c2 := c1; c2++`, M{\n\t\t\"c1\": &Counter{value: 5},\n\t})\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"a\", int64(5))\n\tcompiledGet(t, c, \"s\", \"Counter(5)\")\n\tcompiledGetCounter(t, c, \"c2\", &Counter{value: 6})\n\n\tc = compile(t, `\narr := [1, 2, 3, 4]\nfor x in arr {\n\tc1 += x\n}\nout := c1()\n`, M{\n\t\t\"c1\": &Counter{value: 5},\n\t})\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"out\", int64(15))\n}\n\nfunc compiledGetCounter(\n\tt *testing.T,\n\tc *tengo.Compiled,\n\tname string,\n\texpected *Counter,\n) {\n\tv := c.Get(name)\n\trequire.NotNil(t, v)\n\n\tactual := v.Value().(*Counter)\n\trequire.NotNil(t, actual)\n\trequire.Equal(t, expected.value, actual.value)\n}\n\nfunc TestScriptSourceModule(t *testing.T) {\n\t// script1 imports \"mod1\"\n\tscr := tengo.NewScript([]byte(`out := import(\"mod\")`))\n\tmods := tengo.NewModuleMap()\n\tmods.AddSourceModule(\"mod\", []byte(`export 5`))\n\tscr.SetImports(mods)\n\tc, err := scr.Run()\n\trequire.NoError(t, err)\n\trequire.Equal(t, int64(5), c.Get(\"out\").Value())\n\n\t// executing module function\n\tscr = tengo.NewScript([]byte(`fn := import(\"mod\"); out := fn()`))\n\tmods = tengo.NewModuleMap()\n\tmods.AddSourceModule(\"mod\",\n\t\t[]byte(`a := 3; export func() { return a + 5 }`))\n\tscr.SetImports(mods)\n\tc, err = scr.Run()\n\trequire.NoError(t, err)\n\trequire.Equal(t, int64(8), c.Get(\"out\").Value())\n\n\tscr = tengo.NewScript([]byte(`out := import(\"mod\")`))\n\tmods = tengo.NewModuleMap()\n\tmods.AddSourceModule(\"mod\",\n\t\t[]byte(`text := import(\"text\"); export text.title(\"foo\")`))\n\tmods.AddBuiltinModule(\"text\",\n\t\tmap[string]tengo.Object{\n\t\t\t\"title\": &tengo.UserFunction{\n\t\t\t\tName: \"title\",\n\t\t\t\tValue: func(args ...tengo.Object) (tengo.Object, error) {\n\t\t\t\t\ts, _ := tengo.ToString(args[0])\n\t\t\t\t\treturn &tengo.String{Value: strings.Title(s)}, nil\n\t\t\t\t}},\n\t\t})\n\tscr.SetImports(mods)\n\tc, err = scr.Run()\n\trequire.NoError(t, err)\n\trequire.Equal(t, \"Foo\", c.Get(\"out\").Value())\n\tscr.SetImports(nil)\n\t_, err = scr.Run()\n\trequire.Error(t, err)\n}\n\nfunc BenchmarkArrayIndex(b *testing.B) {\n\tbench(b.N, `a := [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        for i := 0; i < 1000; i++ {\n            a[0]; a[1]; a[2]; a[3]; a[4]; a[5]; a[6]; a[7]; a[7];\n        }\n    `)\n}\n\nfunc BenchmarkArrayIndexCompare(b *testing.B) {\n\tbench(b.N, `a := [1, 2, 3, 4, 5, 6, 7, 8, 9];\n        for i := 0; i < 1000; i++ {\n            1; 2; 3; 4; 5; 6; 7; 8; 9;\n        }\n    `)\n}\n\nfunc bench(n int, input string) {\n\ts := tengo.NewScript([]byte(input))\n\tc, err := s.Compile()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tif err := c.Run(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\ntype M map[string]interface{}\n\nfunc TestCompiled_Get(t *testing.T) {\n\t// simple script\n\tc := compile(t, `a := 5`, nil)\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"a\", int64(5))\n\n\t// user-defined variables\n\tcompileError(t, `a := b`, nil)          // compile error because \"b\" is not defined\n\tc = compile(t, `a := b`, M{\"b\": \"foo\"}) // now compile with b = \"foo\" defined\n\tcompiledGet(t, c, \"a\", nil)             // a = undefined; because it's before Compiled.Run()\n\tcompiledRun(t, c)                       // Compiled.Run()\n\tcompiledGet(t, c, \"a\", \"foo\")           // a = \"foo\"\n}\n\nfunc TestCompiled_GetAll(t *testing.T) {\n\tc := compile(t, `a := 5`, nil)\n\tcompiledRun(t, c)\n\tcompiledGetAll(t, c, M{\"a\": int64(5)})\n\n\tc = compile(t, `a := b`, M{\"b\": \"foo\"})\n\tcompiledRun(t, c)\n\tcompiledGetAll(t, c, M{\"a\": \"foo\", \"b\": \"foo\"})\n\n\tc = compile(t, `a := b; b = 5`, M{\"b\": \"foo\"})\n\tcompiledRun(t, c)\n\tcompiledGetAll(t, c, M{\"a\": \"foo\", \"b\": int64(5)})\n}\n\nfunc TestCompiled_IsDefined(t *testing.T) {\n\tc := compile(t, `a := 5`, nil)\n\tcompiledIsDefined(t, c, \"a\", false) // a is not defined before Run()\n\tcompiledRun(t, c)\n\tcompiledIsDefined(t, c, \"a\", true)\n\tcompiledIsDefined(t, c, \"b\", false)\n}\n\nfunc TestCompiled_Set(t *testing.T) {\n\tc := compile(t, `a := b`, M{\"b\": \"foo\"})\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"a\", \"foo\")\n\n\t// replace value of 'b'\n\terr := c.Set(\"b\", \"bar\")\n\trequire.NoError(t, err)\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"a\", \"bar\")\n\n\t// try to replace undefined variable\n\terr = c.Set(\"c\", 1984)\n\trequire.Error(t, err) // 'c' is not defined\n\n\t// case #2\n\tc = compile(t, `\na := func() { \n\treturn func() {\n\t\treturn b + 5\n\t}() \n}()`, M{\"b\": 5})\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"a\", int64(10))\n\terr = c.Set(\"b\", 10)\n\trequire.NoError(t, err)\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"a\", int64(15))\n}\n\nfunc TestCompiled_RunContext(t *testing.T) {\n\t// machine completes normally\n\tc := compile(t, `a := 5`, nil)\n\terr := c.RunContext(context.Background())\n\trequire.NoError(t, err)\n\tcompiledGet(t, c, \"a\", int64(5))\n\n\t// timeout\n\tc = compile(t, `for true {}`, nil)\n\tctx, cancel := context.WithTimeout(context.Background(),\n\t\t1*time.Millisecond)\n\tdefer cancel()\n\terr = c.RunContext(ctx)\n\trequire.Equal(t, context.DeadlineExceeded, err)\n}\n\nfunc TestCompiled_CustomObject(t *testing.T) {\n\tc := compile(t, `r := (t<130)`, M{\"t\": &customNumber{value: 123}})\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"r\", true)\n\n\tc = compile(t, `r := (t>13)`, M{\"t\": &customNumber{value: 123}})\n\tcompiledRun(t, c)\n\tcompiledGet(t, c, \"r\", true)\n}\n\n// customNumber is a user defined object that can compare to tengo.Int\n// very shitty implementation, just to test that token.Less and token.Greater in BinaryOp works\ntype customNumber struct {\n\ttengo.ObjectImpl\n\tvalue int64\n}\n\nfunc (n *customNumber) TypeName() string {\n\treturn \"Number\"\n}\n\nfunc (n *customNumber) String() string {\n\treturn strconv.FormatInt(n.value, 10)\n}\n\nfunc (n *customNumber) BinaryOp(op token.Token, rhs tengo.Object) (tengo.Object, error) {\n\ttengoInt, ok := rhs.(*tengo.Int)\n\tif !ok {\n\t\treturn nil, tengo.ErrInvalidOperator\n\t}\n\treturn n.binaryOpInt(op, tengoInt)\n}\n\nfunc (n *customNumber) binaryOpInt(op token.Token, rhs *tengo.Int) (tengo.Object, error) {\n\ti := n.value\n\n\tswitch op {\n\tcase token.Less:\n\t\tif i < rhs.Value {\n\t\t\treturn tengo.TrueValue, nil\n\t\t}\n\t\treturn tengo.FalseValue, nil\n\tcase token.Greater:\n\t\tif i > rhs.Value {\n\t\t\treturn tengo.TrueValue, nil\n\t\t}\n\t\treturn tengo.FalseValue, nil\n\tcase token.LessEq:\n\t\tif i <= rhs.Value {\n\t\t\treturn tengo.TrueValue, nil\n\t\t}\n\t\treturn tengo.FalseValue, nil\n\tcase token.GreaterEq:\n\t\tif i >= rhs.Value {\n\t\t\treturn tengo.TrueValue, nil\n\t\t}\n\t\treturn tengo.FalseValue, nil\n\t}\n\treturn nil, tengo.ErrInvalidOperator\n}\n\nfunc TestScript_ImportError(t *testing.T) {\n\tm := `\n\texp := import(\"expression\")\n\tr := exp(ctx)\n`\n\n\tsrc := `\nexport func(ctx) {\n\tclosure := func() {\n\t\tif ctx.actiontimes < 0 { // an error is thrown here because actiontimes is undefined\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\treturn closure()\n}`\n\n\ts := tengo.NewScript([]byte(m))\n\tmods := tengo.NewModuleMap()\n\tmods.AddSourceModule(\"expression\", []byte(src))\n\ts.SetImports(mods)\n\n\terr := s.Add(\"ctx\", map[string]interface{}{\n\t\t\"ctx\": 12,\n\t})\n\trequire.NoError(t, err)\n\n\t_, err = s.Run()\n\trequire.True(t, strings.Contains(err.Error(), \"expression:4:6\"))\n}\n\nfunc compile(t *testing.T, input string, vars M) *tengo.Compiled {\n\ts := tengo.NewScript([]byte(input))\n\tfor vn, vv := range vars {\n\t\terr := s.Add(vn, vv)\n\t\trequire.NoError(t, err)\n\t}\n\n\tc, err := s.Compile()\n\trequire.NoError(t, err)\n\trequire.NotNil(t, c)\n\treturn c\n}\n\nfunc compileError(t *testing.T, input string, vars M) {\n\ts := tengo.NewScript([]byte(input))\n\tfor vn, vv := range vars {\n\t\terr := s.Add(vn, vv)\n\t\trequire.NoError(t, err)\n\t}\n\t_, err := s.Compile()\n\trequire.Error(t, err)\n}\n\nfunc compiledRun(t *testing.T, c *tengo.Compiled) {\n\terr := c.Run()\n\trequire.NoError(t, err)\n}\n\nfunc compiledGet(\n\tt *testing.T,\n\tc *tengo.Compiled,\n\tname string,\n\texpected interface{},\n) {\n\tv := c.Get(name)\n\trequire.NotNil(t, v)\n\trequire.Equal(t, expected, v.Value())\n}\n\nfunc compiledGetAll(\n\tt *testing.T,\n\tc *tengo.Compiled,\n\texpected M,\n) {\n\tvars := c.GetAll()\n\trequire.Equal(t, len(expected), len(vars))\n\n\tfor k, v := range expected {\n\t\tvar found bool\n\t\tfor _, e := range vars {\n\t\t\tif e.Name() == k {\n\t\t\t\trequire.Equal(t, v, e.Value())\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\trequire.True(t, found, \"variable '%s' not found\", k)\n\t}\n}\n\nfunc compiledIsDefined(\n\tt *testing.T,\n\tc *tengo.Compiled,\n\tname string,\n\texpected bool,\n) {\n\trequire.Equal(t, expected, c.IsDefined(name))\n}\nfunc TestCompiled_Clone(t *testing.T) {\n\tscript := tengo.NewScript([]byte(`\ncount += 1\ndata[\"b\"] = 2\n`))\n\n\terr := script.Add(\"data\", map[string]interface{}{\"a\": 1})\n\trequire.NoError(t, err)\n\n\terr = script.Add(\"count\", 1000)\n\trequire.NoError(t, err)\n\n\tcompiled, err := script.Compile()\n\trequire.NoError(t, err)\n\n\tclone := compiled.Clone()\n\terr = clone.RunContext(context.Background())\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 1000, compiled.Get(\"count\").Int())\n\trequire.Equal(t, 1, len(compiled.Get(\"data\").Map()))\n\n\trequire.Equal(t, 1001, clone.Get(\"count\").Int())\n\trequire.Equal(t, 2, len(clone.Get(\"data\").Map()))\n}\n"
        },
        {
          "name": "stdlib",
          "type": "tree",
          "content": null
        },
        {
          "name": "symbol_table.go",
          "type": "blob",
          "size": 4.2021484375,
          "content": "package tengo\n\n// SymbolScope represents a symbol scope.\ntype SymbolScope string\n\n// List of symbol scopes\nconst (\n\tScopeGlobal  SymbolScope = \"GLOBAL\"\n\tScopeLocal   SymbolScope = \"LOCAL\"\n\tScopeBuiltin SymbolScope = \"BUILTIN\"\n\tScopeFree    SymbolScope = \"FREE\"\n)\n\n// Symbol represents a symbol in the symbol table.\ntype Symbol struct {\n\tName          string\n\tScope         SymbolScope\n\tIndex         int\n\tLocalAssigned bool // if the local symbol is assigned at least once\n}\n\n// SymbolTable represents a symbol table.\ntype SymbolTable struct {\n\tparent         *SymbolTable\n\tblock          bool\n\tstore          map[string]*Symbol\n\tnumDefinition  int\n\tmaxDefinition  int\n\tfreeSymbols    []*Symbol\n\tbuiltinSymbols []*Symbol\n}\n\n// NewSymbolTable creates a SymbolTable.\nfunc NewSymbolTable() *SymbolTable {\n\treturn &SymbolTable{\n\t\tstore: make(map[string]*Symbol),\n\t}\n}\n\n// Define adds a new symbol in the current scope.\nfunc (t *SymbolTable) Define(name string) *Symbol {\n\tsymbol := &Symbol{Name: name, Index: t.nextIndex()}\n\tt.numDefinition++\n\n\tif t.Parent(true) == nil {\n\t\tsymbol.Scope = ScopeGlobal\n\n\t\t// if symbol is defined in a block of global scope, symbol index must\n\t\t// be tracked at the root-level table instead.\n\t\tif p := t.parent; p != nil {\n\t\t\tfor p.parent != nil {\n\t\t\t\tp = p.parent\n\t\t\t}\n\t\t\tt.numDefinition--\n\t\t\tp.numDefinition++\n\t\t}\n\n\t} else {\n\t\tsymbol.Scope = ScopeLocal\n\t}\n\tt.store[name] = symbol\n\tt.updateMaxDefs(symbol.Index + 1)\n\treturn symbol\n}\n\n// DefineBuiltin adds a symbol for builtin function.\nfunc (t *SymbolTable) DefineBuiltin(index int, name string) *Symbol {\n\tif t.parent != nil {\n\t\treturn t.parent.DefineBuiltin(index, name)\n\t}\n\n\tsymbol := &Symbol{\n\t\tName:  name,\n\t\tIndex: index,\n\t\tScope: ScopeBuiltin,\n\t}\n\tt.store[name] = symbol\n\tt.builtinSymbols = append(t.builtinSymbols, symbol)\n\treturn symbol\n}\n\n// Resolve resolves a symbol with a given name.\nfunc (t *SymbolTable) Resolve(\n\tname string,\n\trecur bool,\n) (*Symbol, int, bool) {\n\tsymbol, ok := t.store[name]\n\tif ok {\n\t\t// symbol can be used if\n\t\tif symbol.Scope != ScopeLocal || // it's not of local scope, OR,\n\t\t\tsymbol.LocalAssigned || // it's assigned at least once, OR,\n\t\t\trecur { // it's defined in higher level\n\t\t\treturn symbol, 0, true\n\t\t}\n\t}\n\n\tif t.parent == nil {\n\t\treturn nil, 0, false\n\t}\n\n\tsymbol, depth, ok := t.parent.Resolve(name, true)\n\tif !ok {\n\t\treturn nil, 0, false\n\t}\n\tdepth++\n\n\t// if symbol is defined in parent table and if it's not global/builtin\n\t// then it's free variable.\n\tif !t.block && depth > 0 &&\n\t\tsymbol.Scope != ScopeGlobal &&\n\t\tsymbol.Scope != ScopeBuiltin {\n\t\treturn t.defineFree(symbol), depth, true\n\t}\n\treturn symbol, depth, true\n}\n\n// Fork creates a new symbol table for a new scope.\nfunc (t *SymbolTable) Fork(block bool) *SymbolTable {\n\treturn &SymbolTable{\n\t\tstore:  make(map[string]*Symbol),\n\t\tparent: t,\n\t\tblock:  block,\n\t}\n}\n\n// Parent returns the outer scope of the current symbol table.\nfunc (t *SymbolTable) Parent(skipBlock bool) *SymbolTable {\n\tif skipBlock && t.block {\n\t\treturn t.parent.Parent(skipBlock)\n\t}\n\treturn t.parent\n}\n\n// MaxSymbols returns the total number of symbols defined in the scope.\nfunc (t *SymbolTable) MaxSymbols() int {\n\treturn t.maxDefinition\n}\n\n// FreeSymbols returns free symbols for the scope.\nfunc (t *SymbolTable) FreeSymbols() []*Symbol {\n\treturn t.freeSymbols\n}\n\n// BuiltinSymbols returns builtin symbols for the scope.\nfunc (t *SymbolTable) BuiltinSymbols() []*Symbol {\n\tif t.parent != nil {\n\t\treturn t.parent.BuiltinSymbols()\n\t}\n\treturn t.builtinSymbols\n}\n\n// Names returns the name of all the symbols.\nfunc (t *SymbolTable) Names() []string {\n\tvar names []string\n\tfor name := range t.store {\n\t\tnames = append(names, name)\n\t}\n\treturn names\n}\n\nfunc (t *SymbolTable) nextIndex() int {\n\tif t.block {\n\t\treturn t.parent.nextIndex() + t.numDefinition\n\t}\n\treturn t.numDefinition\n}\n\nfunc (t *SymbolTable) updateMaxDefs(numDefs int) {\n\tif numDefs > t.maxDefinition {\n\t\tt.maxDefinition = numDefs\n\t}\n\tif t.block {\n\t\tt.parent.updateMaxDefs(numDefs)\n\t}\n}\n\nfunc (t *SymbolTable) defineFree(original *Symbol) *Symbol {\n\t// TODO: should we check duplicates?\n\tt.freeSymbols = append(t.freeSymbols, original)\n\tsymbol := &Symbol{\n\t\tName:  original.Name,\n\t\tIndex: len(t.freeSymbols) - 1,\n\t\tScope: ScopeFree,\n\t}\n\tt.store[original.Name] = symbol\n\treturn symbol\n}\n"
        },
        {
          "name": "symbol_table_test.go",
          "type": "blob",
          "size": 3.33984375,
          "content": "package tengo_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/require\"\n)\n\nfunc TestSymbolTable(t *testing.T) {\n\t/*\n\t\tGLOBAL\n\t\t[0] a\n\t\t[1] b\n\n\t\t\tLOCAL 1\n\t\t\t[0] d\n\n\t\t\t\tLOCAL 2\n\t\t\t\t[0] e\n\t\t\t\t[1] f\n\n\t\t\t\tLOCAL 2 BLOCK 1\n\t\t\t\t[2] g\n\t\t\t\t[3] h\n\n\t\t\t\tLOCAL 2 BLOCK 2\n\t\t\t\t[2] i\n\t\t\t\t[3] j\n\t\t\t\t[4] k\n\n\t\t\tLOCAL 1 BLOCK 1\n\t\t\t[1] l\n\t\t\t[2] m\n\t\t\t[3] n\n\t\t\t[4] o\n\t\t\t[5] p\n\n\t\t\t\tLOCAL 3\n\t\t\t\t[0] q\n\t\t\t\t[1] r\n\t*/\n\n\tglobal := symbolTable()\n\trequire.Equal(t, globalSymbol(\"a\", 0), global.Define(\"a\"))\n\trequire.Equal(t, globalSymbol(\"b\", 1), global.Define(\"b\"))\n\n\tlocal1 := global.Fork(false)\n\trequire.Equal(t, localSymbol(\"d\", 0), local1.Define(\"d\"))\n\n\tlocal1Block1 := local1.Fork(true)\n\trequire.Equal(t, localSymbol(\"l\", 1), local1Block1.Define(\"l\"))\n\trequire.Equal(t, localSymbol(\"m\", 2), local1Block1.Define(\"m\"))\n\trequire.Equal(t, localSymbol(\"n\", 3), local1Block1.Define(\"n\"))\n\trequire.Equal(t, localSymbol(\"o\", 4), local1Block1.Define(\"o\"))\n\trequire.Equal(t, localSymbol(\"p\", 5), local1Block1.Define(\"p\"))\n\n\tlocal2 := local1.Fork(false)\n\trequire.Equal(t, localSymbol(\"e\", 0), local2.Define(\"e\"))\n\trequire.Equal(t, localSymbol(\"f\", 1), local2.Define(\"f\"))\n\n\tlocal2Block1 := local2.Fork(true)\n\trequire.Equal(t, localSymbol(\"g\", 2), local2Block1.Define(\"g\"))\n\trequire.Equal(t, localSymbol(\"h\", 3), local2Block1.Define(\"h\"))\n\n\tlocal2Block2 := local2.Fork(true)\n\trequire.Equal(t, localSymbol(\"i\", 2), local2Block2.Define(\"i\"))\n\trequire.Equal(t, localSymbol(\"j\", 3), local2Block2.Define(\"j\"))\n\trequire.Equal(t, localSymbol(\"k\", 4), local2Block2.Define(\"k\"))\n\n\tlocal3 := local1Block1.Fork(false)\n\trequire.Equal(t, localSymbol(\"q\", 0), local3.Define(\"q\"))\n\trequire.Equal(t, localSymbol(\"r\", 1), local3.Define(\"r\"))\n\n\trequire.Equal(t, 2, global.MaxSymbols())\n\trequire.Equal(t, 6, local1.MaxSymbols())\n\trequire.Equal(t, 6, local1Block1.MaxSymbols())\n\trequire.Equal(t, 5, local2.MaxSymbols())\n\trequire.Equal(t, 4, local2Block1.MaxSymbols())\n\trequire.Equal(t, 5, local2Block2.MaxSymbols())\n\trequire.Equal(t, 2, local3.MaxSymbols())\n\n\tresolveExpect(t, global, \"a\", globalSymbol(\"a\", 0), 0)\n\tresolveExpect(t, local1, \"d\", localSymbol(\"d\", 0), 0)\n\tresolveExpect(t, local1, \"a\", globalSymbol(\"a\", 0), 1)\n\tresolveExpect(t, local3, \"a\", globalSymbol(\"a\", 0), 3)\n\tresolveExpect(t, local3, \"d\", freeSymbol(\"d\", 0), 2)\n\tresolveExpect(t, local3, \"r\", localSymbol(\"r\", 1), 0)\n\tresolveExpect(t, local2Block2, \"k\", localSymbol(\"k\", 4), 0)\n\tresolveExpect(t, local2Block2, \"e\", localSymbol(\"e\", 0), 1)\n\tresolveExpect(t, local2Block2, \"b\", globalSymbol(\"b\", 1), 3)\n}\n\nfunc symbol(\n\tname string,\n\tscope tengo.SymbolScope,\n\tindex int,\n) *tengo.Symbol {\n\treturn &tengo.Symbol{\n\t\tName:  name,\n\t\tScope: scope,\n\t\tIndex: index,\n\t}\n}\n\nfunc globalSymbol(name string, index int) *tengo.Symbol {\n\treturn symbol(name, tengo.ScopeGlobal, index)\n}\n\nfunc localSymbol(name string, index int) *tengo.Symbol {\n\treturn symbol(name, tengo.ScopeLocal, index)\n}\n\nfunc freeSymbol(name string, index int) *tengo.Symbol {\n\treturn symbol(name, tengo.ScopeFree, index)\n}\n\nfunc symbolTable() *tengo.SymbolTable {\n\treturn tengo.NewSymbolTable()\n}\n\nfunc resolveExpect(\n\tt *testing.T,\n\tsymbolTable *tengo.SymbolTable,\n\tname string,\n\texpectedSymbol *tengo.Symbol,\n\texpectedDepth int,\n) {\n\tactualSymbol, actualDepth, ok := symbolTable.Resolve(name, true)\n\trequire.True(t, ok)\n\trequire.Equal(t, expectedSymbol, actualSymbol)\n\trequire.Equal(t, expectedDepth, actualDepth)\n}\n"
        },
        {
          "name": "tengo.go",
          "type": "blob",
          "size": 6.1884765625,
          "content": "package tengo\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar (\n\t// MaxStringLen is the maximum byte-length for string value. Note this\n\t// limit applies to all compiler/VM instances in the process.\n\tMaxStringLen = 2147483647\n\n\t// MaxBytesLen is the maximum length for bytes value. Note this limit\n\t// applies to all compiler/VM instances in the process.\n\tMaxBytesLen = 2147483647\n)\n\nconst (\n\t// GlobalsSize is the maximum number of global variables for a VM.\n\tGlobalsSize = 1024\n\n\t// StackSize is the maximum stack size for a VM.\n\tStackSize = 2048\n\n\t// MaxFrames is the maximum number of function frames for a VM.\n\tMaxFrames = 1024\n\n\t// SourceFileExtDefault is the default extension for source files.\n\tSourceFileExtDefault = \".tengo\"\n)\n\n// CallableFunc is a function signature for the callable functions.\ntype CallableFunc = func(args ...Object) (ret Object, err error)\n\n// CountObjects returns the number of objects that a given object o contains.\n// For scalar value types, it will always be 1. For compound value types,\n// this will include its elements and all of their elements recursively.\nfunc CountObjects(o Object) (c int) {\n\tc = 1\n\tswitch o := o.(type) {\n\tcase *Array:\n\t\tfor _, v := range o.Value {\n\t\t\tc += CountObjects(v)\n\t\t}\n\tcase *ImmutableArray:\n\t\tfor _, v := range o.Value {\n\t\t\tc += CountObjects(v)\n\t\t}\n\tcase *Map:\n\t\tfor _, v := range o.Value {\n\t\t\tc += CountObjects(v)\n\t\t}\n\tcase *ImmutableMap:\n\t\tfor _, v := range o.Value {\n\t\t\tc += CountObjects(v)\n\t\t}\n\tcase *Error:\n\t\tc += CountObjects(o.Value)\n\t}\n\treturn\n}\n\n// ToString will try to convert object o to string value.\nfunc ToString(o Object) (v string, ok bool) {\n\tif o == UndefinedValue {\n\t\treturn\n\t}\n\tok = true\n\tif str, isStr := o.(*String); isStr {\n\t\tv = str.Value\n\t} else {\n\t\tv = o.String()\n\t}\n\treturn\n}\n\n// ToInt will try to convert object o to int value.\nfunc ToInt(o Object) (v int, ok bool) {\n\tswitch o := o.(type) {\n\tcase *Int:\n\t\tv = int(o.Value)\n\t\tok = true\n\tcase *Float:\n\t\tv = int(o.Value)\n\t\tok = true\n\tcase *Char:\n\t\tv = int(o.Value)\n\t\tok = true\n\tcase *Bool:\n\t\tif o == TrueValue {\n\t\t\tv = 1\n\t\t}\n\t\tok = true\n\tcase *String:\n\t\tc, err := strconv.ParseInt(o.Value, 10, 64)\n\t\tif err == nil {\n\t\t\tv = int(c)\n\t\t\tok = true\n\t\t}\n\t}\n\treturn\n}\n\n// ToInt64 will try to convert object o to int64 value.\nfunc ToInt64(o Object) (v int64, ok bool) {\n\tswitch o := o.(type) {\n\tcase *Int:\n\t\tv = o.Value\n\t\tok = true\n\tcase *Float:\n\t\tv = int64(o.Value)\n\t\tok = true\n\tcase *Char:\n\t\tv = int64(o.Value)\n\t\tok = true\n\tcase *Bool:\n\t\tif o == TrueValue {\n\t\t\tv = 1\n\t\t}\n\t\tok = true\n\tcase *String:\n\t\tc, err := strconv.ParseInt(o.Value, 10, 64)\n\t\tif err == nil {\n\t\t\tv = c\n\t\t\tok = true\n\t\t}\n\t}\n\treturn\n}\n\n// ToFloat64 will try to convert object o to float64 value.\nfunc ToFloat64(o Object) (v float64, ok bool) {\n\tswitch o := o.(type) {\n\tcase *Int:\n\t\tv = float64(o.Value)\n\t\tok = true\n\tcase *Float:\n\t\tv = o.Value\n\t\tok = true\n\tcase *String:\n\t\tc, err := strconv.ParseFloat(o.Value, 64)\n\t\tif err == nil {\n\t\t\tv = c\n\t\t\tok = true\n\t\t}\n\t}\n\treturn\n}\n\n// ToBool will try to convert object o to bool value.\nfunc ToBool(o Object) (v bool, ok bool) {\n\tok = true\n\tv = !o.IsFalsy()\n\treturn\n}\n\n// ToRune will try to convert object o to rune value.\nfunc ToRune(o Object) (v rune, ok bool) {\n\tswitch o := o.(type) {\n\tcase *Int:\n\t\tv = rune(o.Value)\n\t\tok = true\n\tcase *Char:\n\t\tv = o.Value\n\t\tok = true\n\t}\n\treturn\n}\n\n// ToByteSlice will try to convert object o to []byte value.\nfunc ToByteSlice(o Object) (v []byte, ok bool) {\n\tswitch o := o.(type) {\n\tcase *Bytes:\n\t\tv = o.Value\n\t\tok = true\n\tcase *String:\n\t\tv = []byte(o.Value)\n\t\tok = true\n\t}\n\treturn\n}\n\n// ToTime will try to convert object o to time.Time value.\nfunc ToTime(o Object) (v time.Time, ok bool) {\n\tswitch o := o.(type) {\n\tcase *Time:\n\t\tv = o.Value\n\t\tok = true\n\tcase *Int:\n\t\tv = time.Unix(o.Value, 0)\n\t\tok = true\n\t}\n\treturn\n}\n\n// ToInterface attempts to convert an object o to an interface{} value\nfunc ToInterface(o Object) (res interface{}) {\n\tswitch o := o.(type) {\n\tcase *Int:\n\t\tres = o.Value\n\tcase *String:\n\t\tres = o.Value\n\tcase *Float:\n\t\tres = o.Value\n\tcase *Bool:\n\t\tres = o == TrueValue\n\tcase *Char:\n\t\tres = o.Value\n\tcase *Bytes:\n\t\tres = o.Value\n\tcase *Array:\n\t\tres = make([]interface{}, len(o.Value))\n\t\tfor i, val := range o.Value {\n\t\t\tres.([]interface{})[i] = ToInterface(val)\n\t\t}\n\tcase *ImmutableArray:\n\t\tres = make([]interface{}, len(o.Value))\n\t\tfor i, val := range o.Value {\n\t\t\tres.([]interface{})[i] = ToInterface(val)\n\t\t}\n\tcase *Map:\n\t\tres = make(map[string]interface{})\n\t\tfor key, v := range o.Value {\n\t\t\tres.(map[string]interface{})[key] = ToInterface(v)\n\t\t}\n\tcase *ImmutableMap:\n\t\tres = make(map[string]interface{})\n\t\tfor key, v := range o.Value {\n\t\t\tres.(map[string]interface{})[key] = ToInterface(v)\n\t\t}\n\tcase *Time:\n\t\tres = o.Value\n\tcase *Error:\n\t\tres = errors.New(o.String())\n\tcase *Undefined:\n\t\tres = nil\n\tcase Object:\n\t\treturn o\n\t}\n\treturn\n}\n\n// FromInterface will attempt to convert an interface{} v to a Tengo Object\nfunc FromInterface(v interface{}) (Object, error) {\n\tswitch v := v.(type) {\n\tcase nil:\n\t\treturn UndefinedValue, nil\n\tcase string:\n\t\tif len(v) > MaxStringLen {\n\t\t\treturn nil, ErrStringLimit\n\t\t}\n\t\treturn &String{Value: v}, nil\n\tcase int64:\n\t\treturn &Int{Value: v}, nil\n\tcase int:\n\t\treturn &Int{Value: int64(v)}, nil\n\tcase bool:\n\t\tif v {\n\t\t\treturn TrueValue, nil\n\t\t}\n\t\treturn FalseValue, nil\n\tcase rune:\n\t\treturn &Char{Value: v}, nil\n\tcase byte:\n\t\treturn &Char{Value: rune(v)}, nil\n\tcase float64:\n\t\treturn &Float{Value: v}, nil\n\tcase []byte:\n\t\tif len(v) > MaxBytesLen {\n\t\t\treturn nil, ErrBytesLimit\n\t\t}\n\t\treturn &Bytes{Value: v}, nil\n\tcase error:\n\t\treturn &Error{Value: &String{Value: v.Error()}}, nil\n\tcase map[string]Object:\n\t\treturn &Map{Value: v}, nil\n\tcase map[string]interface{}:\n\t\tkv := make(map[string]Object)\n\t\tfor vk, vv := range v {\n\t\t\tvo, err := FromInterface(vv)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tkv[vk] = vo\n\t\t}\n\t\treturn &Map{Value: kv}, nil\n\tcase []Object:\n\t\treturn &Array{Value: v}, nil\n\tcase []interface{}:\n\t\tarr := make([]Object, len(v))\n\t\tfor i, e := range v {\n\t\t\tvo, err := FromInterface(e)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tarr[i] = vo\n\t\t}\n\t\treturn &Array{Value: arr}, nil\n\tcase time.Time:\n\t\treturn &Time{Value: v}, nil\n\tcase Object:\n\t\treturn v, nil\n\tcase CallableFunc:\n\t\treturn &UserFunction{Value: v}, nil\n\t}\n\treturn nil, fmt.Errorf(\"cannot convert to object: %T\", v)\n}\n"
        },
        {
          "name": "tengo_test.go",
          "type": "blob",
          "size": 3.7294921875,
          "content": "package tengo_test\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/require\"\n)\n\nfunc TestInstructions_String(t *testing.T) {\n\tassertInstructionString(t,\n\t\t[][]byte{\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 1),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 65535),\n\t\t},\n\t\t`0000 CONST   1    \n0003 CONST   2    \n0006 CONST   65535`)\n\n\tassertInstructionString(t,\n\t\t[][]byte{\n\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 65535),\n\t\t},\n\t\t`0000 BINARYOP 11   \n0002 CONST   2    \n0005 CONST   65535`)\n\n\tassertInstructionString(t,\n\t\t[][]byte{\n\t\t\ttengo.MakeInstruction(parser.OpBinaryOp, 11),\n\t\t\ttengo.MakeInstruction(parser.OpGetLocal, 1),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 2),\n\t\t\ttengo.MakeInstruction(parser.OpConstant, 65535),\n\t\t},\n\t\t`0000 BINARYOP 11   \n0002 GETL    1    \n0004 CONST   2    \n0007 CONST   65535`)\n}\n\nfunc TestMakeInstruction(t *testing.T) {\n\tmakeInstruction(t, []byte{parser.OpConstant, 0, 0},\n\t\tparser.OpConstant, 0)\n\tmakeInstruction(t, []byte{parser.OpConstant, 0, 1},\n\t\tparser.OpConstant, 1)\n\tmakeInstruction(t, []byte{parser.OpConstant, 255, 254},\n\t\tparser.OpConstant, 65534)\n\tmakeInstruction(t, []byte{parser.OpPop}, parser.OpPop)\n\tmakeInstruction(t, []byte{parser.OpTrue}, parser.OpTrue)\n\tmakeInstruction(t, []byte{parser.OpFalse}, parser.OpFalse)\n}\n\nfunc TestNumObjects(t *testing.T) {\n\ttestCountObjects(t, &tengo.Array{}, 1)\n\ttestCountObjects(t, &tengo.Array{Value: []tengo.Object{\n\t\t&tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: 2},\n\t\t&tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 3},\n\t\t\t&tengo.Int{Value: 4},\n\t\t\t&tengo.Int{Value: 5},\n\t\t}},\n\t}}, 7)\n\ttestCountObjects(t, tengo.TrueValue, 1)\n\ttestCountObjects(t, tengo.FalseValue, 1)\n\ttestCountObjects(t, &tengo.BuiltinFunction{}, 1)\n\ttestCountObjects(t, &tengo.Bytes{Value: []byte(\"foobar\")}, 1)\n\ttestCountObjects(t, &tengo.Char{Value: ''}, 1)\n\ttestCountObjects(t, &tengo.CompiledFunction{}, 1)\n\ttestCountObjects(t, &tengo.Error{Value: &tengo.Int{Value: 5}}, 2)\n\ttestCountObjects(t, &tengo.Float{Value: 19.84}, 1)\n\ttestCountObjects(t, &tengo.ImmutableArray{Value: []tengo.Object{\n\t\t&tengo.Int{Value: 1},\n\t\t&tengo.Int{Value: 2},\n\t\t&tengo.ImmutableArray{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 3},\n\t\t\t&tengo.Int{Value: 4},\n\t\t\t&tengo.Int{Value: 5},\n\t\t}},\n\t}}, 7)\n\ttestCountObjects(t, &tengo.ImmutableMap{\n\t\tValue: map[string]tengo.Object{\n\t\t\t\"k1\": &tengo.Int{Value: 1},\n\t\t\t\"k2\": &tengo.Int{Value: 2},\n\t\t\t\"k3\": &tengo.Array{Value: []tengo.Object{\n\t\t\t\t&tengo.Int{Value: 3},\n\t\t\t\t&tengo.Int{Value: 4},\n\t\t\t\t&tengo.Int{Value: 5},\n\t\t\t}},\n\t\t}}, 7)\n\ttestCountObjects(t, &tengo.Int{Value: 1984}, 1)\n\ttestCountObjects(t, &tengo.Map{Value: map[string]tengo.Object{\n\t\t\"k1\": &tengo.Int{Value: 1},\n\t\t\"k2\": &tengo.Int{Value: 2},\n\t\t\"k3\": &tengo.Array{Value: []tengo.Object{\n\t\t\t&tengo.Int{Value: 3},\n\t\t\t&tengo.Int{Value: 4},\n\t\t\t&tengo.Int{Value: 5},\n\t\t}},\n\t}}, 7)\n\ttestCountObjects(t, &tengo.String{Value: \"foo bar\"}, 1)\n\ttestCountObjects(t, &tengo.Time{Value: time.Now()}, 1)\n\ttestCountObjects(t, tengo.UndefinedValue, 1)\n}\n\nfunc testCountObjects(t *testing.T, o tengo.Object, expected int) {\n\trequire.Equal(t, expected, tengo.CountObjects(o))\n}\n\nfunc assertInstructionString(\n\tt *testing.T,\n\tinstructions [][]byte,\n\texpected string,\n) {\n\tconcatted := make([]byte, 0)\n\tfor _, e := range instructions {\n\t\tconcatted = append(concatted, e...)\n\t}\n\trequire.Equal(t, expected, strings.Join(\n\t\ttengo.FormatInstructions(concatted, 0), \"\\n\"))\n}\n\nfunc makeInstruction(\n\tt *testing.T,\n\texpected []byte,\n\topcode parser.Opcode,\n\toperands ...int,\n) {\n\tinst := tengo.MakeInstruction(opcode, operands...)\n\trequire.Equal(t, expected, inst)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "token",
          "type": "tree",
          "content": null
        },
        {
          "name": "variable.go",
          "type": "blob",
          "size": 3.2119140625,
          "content": "package tengo\n\nimport (\n\t\"errors\"\n)\n\n// Variable is a user-defined variable for the script.\ntype Variable struct {\n\tname  string\n\tvalue Object\n}\n\n// NewVariable creates a Variable.\nfunc NewVariable(name string, value interface{}) (*Variable, error) {\n\tobj, err := FromInterface(value)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Variable{\n\t\tname:  name,\n\t\tvalue: obj,\n\t}, nil\n}\n\n// Name returns the name of the variable.\nfunc (v *Variable) Name() string {\n\treturn v.name\n}\n\n// Value returns an empty interface of the variable value.\nfunc (v *Variable) Value() interface{} {\n\treturn ToInterface(v.value)\n}\n\n// ValueType returns the name of the value type.\nfunc (v *Variable) ValueType() string {\n\treturn v.value.TypeName()\n}\n\n// Int returns int value of the variable value.\n// It returns 0 if the value is not convertible to int.\nfunc (v *Variable) Int() int {\n\tc, _ := ToInt(v.value)\n\treturn c\n}\n\n// Int64 returns int64 value of the variable value. It returns 0 if the value\n// is not convertible to int64.\nfunc (v *Variable) Int64() int64 {\n\tc, _ := ToInt64(v.value)\n\treturn c\n}\n\n// Float returns float64 value of the variable value. It returns 0.0 if the\n// value is not convertible to float64.\nfunc (v *Variable) Float() float64 {\n\tc, _ := ToFloat64(v.value)\n\treturn c\n}\n\n// Char returns rune value of the variable value. It returns 0 if the value is\n// not convertible to rune.\nfunc (v *Variable) Char() rune {\n\tc, _ := ToRune(v.value)\n\treturn c\n}\n\n// Bool returns bool value of the variable value. It returns 0 if the value is\n// not convertible to bool.\nfunc (v *Variable) Bool() bool {\n\tc, _ := ToBool(v.value)\n\treturn c\n}\n\n// Array returns []interface value of the variable value. It returns 0 if the\n// value is not convertible to []interface.\nfunc (v *Variable) Array() []interface{} {\n\tswitch val := v.value.(type) {\n\tcase *Array:\n\t\tvar arr []interface{}\n\t\tfor _, e := range val.Value {\n\t\t\tarr = append(arr, ToInterface(e))\n\t\t}\n\t\treturn arr\n\t}\n\treturn nil\n}\n\n// Map returns map[string]interface{} value of the variable value. It returns\n// 0 if the value is not convertible to map[string]interface{}.\nfunc (v *Variable) Map() map[string]interface{} {\n\tswitch val := v.value.(type) {\n\tcase *Map:\n\t\tkv := make(map[string]interface{})\n\t\tfor mk, mv := range val.Value {\n\t\t\tkv[mk] = ToInterface(mv)\n\t\t}\n\t\treturn kv\n\t}\n\treturn nil\n}\n\n// String returns string value of the variable value. It returns 0 if the value\n// is not convertible to string.\nfunc (v *Variable) String() string {\n\tc, _ := ToString(v.value)\n\treturn c\n}\n\n// Bytes returns a byte slice of the variable value. It returns nil if the\n// value is not convertible to byte slice.\nfunc (v *Variable) Bytes() []byte {\n\tc, _ := ToByteSlice(v.value)\n\treturn c\n}\n\n// Error returns an error if the underlying value is error object. If not,\n// this returns nil.\nfunc (v *Variable) Error() error {\n\terr, ok := v.value.(*Error)\n\tif ok {\n\t\treturn errors.New(err.String())\n\t}\n\treturn nil\n}\n\n// Object returns an underlying Object of the variable value. Note that\n// returned Object is a copy of an actual Object used in the script.\nfunc (v *Variable) Object() Object {\n\treturn v.value\n}\n\n// IsUndefined returns true if the underlying value is undefined.\nfunc (v *Variable) IsUndefined() bool {\n\treturn v.value == UndefinedValue\n}\n"
        },
        {
          "name": "variable_test.go",
          "type": "blob",
          "size": 1.9296875,
          "content": "package tengo_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/require\"\n)\n\ntype VariableTest struct {\n\tName        string\n\tValue       interface{}\n\tValueType   string\n\tIntValue    int\n\tInt64Value  int64\n\tFloatValue  float64\n\tCharValue   rune\n\tBoolValue   bool\n\tStringValue string\n\tObject      tengo.Object\n\tIsUndefined bool\n}\n\nfunc TestVariable(t *testing.T) {\n\tvars := []VariableTest{\n\t\t{\n\t\t\tName:        \"a\",\n\t\t\tValue:       int64(1),\n\t\t\tValueType:   \"int\",\n\t\t\tIntValue:    1,\n\t\t\tInt64Value:  1,\n\t\t\tFloatValue:  1.0,\n\t\t\tCharValue:   rune(1),\n\t\t\tBoolValue:   true,\n\t\t\tStringValue: \"1\",\n\t\t\tObject:      &tengo.Int{Value: 1},\n\t\t},\n\t\t{\n\t\t\tName:        \"b\",\n\t\t\tValue:       \"52.11\",\n\t\t\tValueType:   \"string\",\n\t\t\tFloatValue:  52.11,\n\t\t\tStringValue: \"52.11\",\n\t\t\tBoolValue:   true,\n\t\t\tObject:      &tengo.String{Value: \"52.11\"},\n\t\t},\n\t\t{\n\t\t\tName:        \"c\",\n\t\t\tValue:       true,\n\t\t\tValueType:   \"bool\",\n\t\t\tIntValue:    1,\n\t\t\tInt64Value:  1,\n\t\t\tFloatValue:  0,\n\t\t\tBoolValue:   true,\n\t\t\tStringValue: \"true\",\n\t\t\tObject:      tengo.TrueValue,\n\t\t},\n\t\t{\n\t\t\tName:        \"d\",\n\t\t\tValue:       nil,\n\t\t\tValueType:   \"undefined\",\n\t\t\tObject:      tengo.UndefinedValue,\n\t\t\tIsUndefined: true,\n\t\t},\n\t}\n\n\tfor _, tc := range vars {\n\t\tv, err := tengo.NewVariable(tc.Name, tc.Value)\n\t\trequire.NoError(t, err)\n\t\trequire.Equal(t, tc.Value, v.Value(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.ValueType, v.ValueType(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.IntValue, v.Int(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.Int64Value, v.Int64(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.FloatValue, v.Float(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.CharValue, v.Char(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.BoolValue, v.Bool(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.StringValue, v.String(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.Object, v.Object(), \"Name: %s\", tc.Name)\n\t\trequire.Equal(t, tc.IsUndefined, v.IsUndefined(), \"Name: %s\", tc.Name)\n\t}\n}\n"
        },
        {
          "name": "vm.go",
          "type": "blob",
          "size": 21.2109375,
          "content": "package tengo\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/token\"\n)\n\n// frame represents a function call frame.\ntype frame struct {\n\tfn          *CompiledFunction\n\tfreeVars    []*ObjectPtr\n\tip          int\n\tbasePointer int\n}\n\n// VM is a virtual machine that executes the bytecode compiled by Compiler.\ntype VM struct {\n\tconstants   []Object\n\tstack       [StackSize]Object\n\tsp          int\n\tglobals     []Object\n\tfileSet     *parser.SourceFileSet\n\tframes      [MaxFrames]frame\n\tframesIndex int\n\tcurFrame    *frame\n\tcurInsts    []byte\n\tip          int\n\taborting    int64\n\tmaxAllocs   int64\n\tallocs      int64\n\terr         error\n}\n\n// NewVM creates a VM.\nfunc NewVM(\n\tbytecode *Bytecode,\n\tglobals []Object,\n\tmaxAllocs int64,\n) *VM {\n\tif globals == nil {\n\t\tglobals = make([]Object, GlobalsSize)\n\t}\n\tv := &VM{\n\t\tconstants:   bytecode.Constants,\n\t\tsp:          0,\n\t\tglobals:     globals,\n\t\tfileSet:     bytecode.FileSet,\n\t\tframesIndex: 1,\n\t\tip:          -1,\n\t\tmaxAllocs:   maxAllocs,\n\t}\n\tv.frames[0].fn = bytecode.MainFunction\n\tv.frames[0].ip = -1\n\tv.curFrame = &v.frames[0]\n\tv.curInsts = v.curFrame.fn.Instructions\n\treturn v\n}\n\n// Abort aborts the execution.\nfunc (v *VM) Abort() {\n\tatomic.StoreInt64(&v.aborting, 1)\n}\n\n// Run starts the execution.\nfunc (v *VM) Run() (err error) {\n\t// reset VM states\n\tv.sp = 0\n\tv.curFrame = &(v.frames[0])\n\tv.curInsts = v.curFrame.fn.Instructions\n\tv.framesIndex = 1\n\tv.ip = -1\n\tv.allocs = v.maxAllocs + 1\n\n\tv.run()\n\tatomic.StoreInt64(&v.aborting, 0)\n\terr = v.err\n\tif err != nil {\n\t\tfilePos := v.fileSet.Position(\n\t\t\tv.curFrame.fn.SourcePos(v.ip - 1))\n\t\terr = fmt.Errorf(\"Runtime Error: %w\\n\\tat %s\",\n\t\t\terr, filePos)\n\t\tfor v.framesIndex > 1 {\n\t\t\tv.framesIndex--\n\t\t\tv.curFrame = &v.frames[v.framesIndex-1]\n\t\t\tfilePos = v.fileSet.Position(\n\t\t\t\tv.curFrame.fn.SourcePos(v.curFrame.ip - 1))\n\t\t\terr = fmt.Errorf(\"%w\\n\\tat %s\", err, filePos)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (v *VM) run() {\n\tfor atomic.LoadInt64(&v.aborting) == 0 {\n\t\tv.ip++\n\n\t\tswitch v.curInsts[v.ip] {\n\t\tcase parser.OpConstant:\n\t\t\tv.ip += 2\n\t\t\tcidx := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8\n\n\t\t\tv.stack[v.sp] = v.constants[cidx]\n\t\t\tv.sp++\n\t\tcase parser.OpNull:\n\t\t\tv.stack[v.sp] = UndefinedValue\n\t\t\tv.sp++\n\t\tcase parser.OpBinaryOp:\n\t\t\tv.ip++\n\t\t\tright := v.stack[v.sp-1]\n\t\t\tleft := v.stack[v.sp-2]\n\t\t\ttok := token.Token(v.curInsts[v.ip])\n\t\t\tres, e := left.BinaryOp(tok, right)\n\t\t\tif e != nil {\n\t\t\t\tv.sp -= 2\n\t\t\t\tif e == ErrInvalidOperator {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid operation: %s %s %s\",\n\t\t\t\t\t\tleft.TypeName(), tok.String(), right.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.err = e\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv.allocs--\n\t\t\tif v.allocs == 0 {\n\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv.stack[v.sp-2] = res\n\t\t\tv.sp--\n\t\tcase parser.OpEqual:\n\t\t\tright := v.stack[v.sp-1]\n\t\t\tleft := v.stack[v.sp-2]\n\t\t\tv.sp -= 2\n\t\t\tif left.Equals(right) {\n\t\t\t\tv.stack[v.sp] = TrueValue\n\t\t\t} else {\n\t\t\t\tv.stack[v.sp] = FalseValue\n\t\t\t}\n\t\t\tv.sp++\n\t\tcase parser.OpNotEqual:\n\t\t\tright := v.stack[v.sp-1]\n\t\t\tleft := v.stack[v.sp-2]\n\t\t\tv.sp -= 2\n\t\t\tif left.Equals(right) {\n\t\t\t\tv.stack[v.sp] = FalseValue\n\t\t\t} else {\n\t\t\t\tv.stack[v.sp] = TrueValue\n\t\t\t}\n\t\t\tv.sp++\n\t\tcase parser.OpPop:\n\t\t\tv.sp--\n\t\tcase parser.OpTrue:\n\t\t\tv.stack[v.sp] = TrueValue\n\t\t\tv.sp++\n\t\tcase parser.OpFalse:\n\t\t\tv.stack[v.sp] = FalseValue\n\t\t\tv.sp++\n\t\tcase parser.OpLNot:\n\t\t\toperand := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\tif operand.IsFalsy() {\n\t\t\t\tv.stack[v.sp] = TrueValue\n\t\t\t} else {\n\t\t\t\tv.stack[v.sp] = FalseValue\n\t\t\t}\n\t\t\tv.sp++\n\t\tcase parser.OpBComplement:\n\t\t\toperand := v.stack[v.sp-1]\n\t\t\tv.sp--\n\n\t\t\tswitch x := operand.(type) {\n\t\t\tcase *Int:\n\t\t\t\tvar res Object = &Int{Value: ^x.Value}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = res\n\t\t\t\tv.sp++\n\t\t\tdefault:\n\t\t\t\tv.err = fmt.Errorf(\"invalid operation: ^%s\",\n\t\t\t\t\toperand.TypeName())\n\t\t\t\treturn\n\t\t\t}\n\t\tcase parser.OpMinus:\n\t\t\toperand := v.stack[v.sp-1]\n\t\t\tv.sp--\n\n\t\t\tswitch x := operand.(type) {\n\t\t\tcase *Int:\n\t\t\t\tvar res Object = &Int{Value: -x.Value}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = res\n\t\t\t\tv.sp++\n\t\t\tcase *Float:\n\t\t\t\tvar res Object = &Float{Value: -x.Value}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = res\n\t\t\t\tv.sp++\n\t\t\tdefault:\n\t\t\t\tv.err = fmt.Errorf(\"invalid operation: -%s\",\n\t\t\t\t\toperand.TypeName())\n\t\t\t\treturn\n\t\t\t}\n\t\tcase parser.OpJumpFalsy:\n\t\t\tv.ip += 4\n\t\t\tv.sp--\n\t\t\tif v.stack[v.sp].IsFalsy() {\n\t\t\t\tpos := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8 | int(v.curInsts[v.ip-2])<<16 | int(v.curInsts[v.ip-3])<<24\n\t\t\t\tv.ip = pos - 1\n\t\t\t}\n\t\tcase parser.OpAndJump:\n\t\t\tv.ip += 4\n\t\t\tif v.stack[v.sp-1].IsFalsy() {\n\t\t\t\tpos := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8 | int(v.curInsts[v.ip-2])<<16 | int(v.curInsts[v.ip-3])<<24\n\t\t\t\tv.ip = pos - 1\n\t\t\t} else {\n\t\t\t\tv.sp--\n\t\t\t}\n\t\tcase parser.OpOrJump:\n\t\t\tv.ip += 4\n\t\t\tif v.stack[v.sp-1].IsFalsy() {\n\t\t\t\tv.sp--\n\t\t\t} else {\n\t\t\t\tpos := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8 | int(v.curInsts[v.ip-2])<<16 | int(v.curInsts[v.ip-3])<<24\n\t\t\t\tv.ip = pos - 1\n\t\t\t}\n\t\tcase parser.OpJump:\n\t\t\tpos := int(v.curInsts[v.ip+4]) | int(v.curInsts[v.ip+3])<<8 | int(v.curInsts[v.ip+2])<<16 | int(v.curInsts[v.ip+1])<<24\n\t\t\tv.ip = pos - 1\n\t\tcase parser.OpSetGlobal:\n\t\t\tv.ip += 2\n\t\t\tv.sp--\n\t\t\tglobalIndex := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8\n\t\t\tv.globals[globalIndex] = v.stack[v.sp]\n\t\tcase parser.OpSetSelGlobal:\n\t\t\tv.ip += 3\n\t\t\tglobalIndex := int(v.curInsts[v.ip-1]) | int(v.curInsts[v.ip-2])<<8\n\t\t\tnumSelectors := int(v.curInsts[v.ip])\n\n\t\t\t// selectors and RHS value\n\t\t\tselectors := make([]Object, numSelectors)\n\t\t\tfor i := 0; i < numSelectors; i++ {\n\t\t\t\tselectors[i] = v.stack[v.sp-numSelectors+i]\n\t\t\t}\n\t\t\tval := v.stack[v.sp-numSelectors-1]\n\t\t\tv.sp -= numSelectors + 1\n\t\t\te := indexAssign(v.globals[globalIndex], val, selectors)\n\t\t\tif e != nil {\n\t\t\t\tv.err = e\n\t\t\t\treturn\n\t\t\t}\n\t\tcase parser.OpGetGlobal:\n\t\t\tv.ip += 2\n\t\t\tglobalIndex := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8\n\t\t\tval := v.globals[globalIndex]\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpArray:\n\t\t\tv.ip += 2\n\t\t\tnumElements := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8\n\n\t\t\tvar elements []Object\n\t\t\tfor i := v.sp - numElements; i < v.sp; i++ {\n\t\t\t\telements = append(elements, v.stack[i])\n\t\t\t}\n\t\t\tv.sp -= numElements\n\n\t\t\tvar arr Object = &Array{Value: elements}\n\t\t\tv.allocs--\n\t\t\tif v.allocs == 0 {\n\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tv.stack[v.sp] = arr\n\t\t\tv.sp++\n\t\tcase parser.OpMap:\n\t\t\tv.ip += 2\n\t\t\tnumElements := int(v.curInsts[v.ip]) | int(v.curInsts[v.ip-1])<<8\n\t\t\tkv := make(map[string]Object, numElements)\n\t\t\tfor i := v.sp - numElements; i < v.sp; i += 2 {\n\t\t\t\tkey := v.stack[i]\n\t\t\t\tvalue := v.stack[i+1]\n\t\t\t\tkv[key.(*String).Value] = value\n\t\t\t}\n\t\t\tv.sp -= numElements\n\n\t\t\tvar m Object = &Map{Value: kv}\n\t\t\tv.allocs--\n\t\t\tif v.allocs == 0 {\n\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.stack[v.sp] = m\n\t\t\tv.sp++\n\t\tcase parser.OpError:\n\t\t\tvalue := v.stack[v.sp-1]\n\t\t\tvar e Object = &Error{\n\t\t\t\tValue: value,\n\t\t\t}\n\t\t\tv.allocs--\n\t\t\tif v.allocs == 0 {\n\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.stack[v.sp-1] = e\n\t\tcase parser.OpImmutable:\n\t\t\tvalue := v.stack[v.sp-1]\n\t\t\tswitch value := value.(type) {\n\t\t\tcase *Array:\n\t\t\t\tvar immutableArray Object = &ImmutableArray{\n\t\t\t\t\tValue: value.Value,\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp-1] = immutableArray\n\t\t\tcase *Map:\n\t\t\t\tvar immutableMap Object = &ImmutableMap{\n\t\t\t\t\tValue: value.Value,\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp-1] = immutableMap\n\t\t\t}\n\t\tcase parser.OpIndex:\n\t\t\tindex := v.stack[v.sp-1]\n\t\t\tleft := v.stack[v.sp-2]\n\t\t\tv.sp -= 2\n\n\t\t\tval, err := left.IndexGet(index)\n\t\t\tif err != nil {\n\t\t\t\tif err == ErrNotIndexable {\n\t\t\t\t\tv.err = fmt.Errorf(\"not indexable: %s\", index.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err == ErrInvalidIndexType {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid index type: %s\",\n\t\t\t\t\t\tindex.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.err = err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif val == nil {\n\t\t\t\tval = UndefinedValue\n\t\t\t}\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpSliceIndex:\n\t\t\thigh := v.stack[v.sp-1]\n\t\t\tlow := v.stack[v.sp-2]\n\t\t\tleft := v.stack[v.sp-3]\n\t\t\tv.sp -= 3\n\n\t\t\tvar lowIdx int64\n\t\t\tif low != UndefinedValue {\n\t\t\t\tif lowInt, ok := low.(*Int); ok {\n\t\t\t\t\tlowIdx = lowInt.Value\n\t\t\t\t} else {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index type: %s\",\n\t\t\t\t\t\tlow.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch left := left.(type) {\n\t\t\tcase *Array:\n\t\t\t\tnumElements := int64(len(left.Value))\n\t\t\t\tvar highIdx int64\n\t\t\t\tif high == UndefinedValue {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t} else if highInt, ok := high.(*Int); ok {\n\t\t\t\t\thighIdx = highInt.Value\n\t\t\t\t} else {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index type: %s\",\n\t\t\t\t\t\thigh.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx > highIdx {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index: %d > %d\",\n\t\t\t\t\t\tlowIdx, highIdx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx < 0 {\n\t\t\t\t\tlowIdx = 0\n\t\t\t\t} else if lowIdx > numElements {\n\t\t\t\t\tlowIdx = numElements\n\t\t\t\t}\n\t\t\t\tif highIdx < 0 {\n\t\t\t\t\thighIdx = 0\n\t\t\t\t} else if highIdx > numElements {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t}\n\t\t\t\tvar val Object = &Array{\n\t\t\t\t\tValue: left.Value[lowIdx:highIdx],\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = val\n\t\t\t\tv.sp++\n\t\t\tcase *ImmutableArray:\n\t\t\t\tnumElements := int64(len(left.Value))\n\t\t\t\tvar highIdx int64\n\t\t\t\tif high == UndefinedValue {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t} else if highInt, ok := high.(*Int); ok {\n\t\t\t\t\thighIdx = highInt.Value\n\t\t\t\t} else {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index type: %s\",\n\t\t\t\t\t\thigh.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx > highIdx {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index: %d > %d\",\n\t\t\t\t\t\tlowIdx, highIdx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx < 0 {\n\t\t\t\t\tlowIdx = 0\n\t\t\t\t} else if lowIdx > numElements {\n\t\t\t\t\tlowIdx = numElements\n\t\t\t\t}\n\t\t\t\tif highIdx < 0 {\n\t\t\t\t\thighIdx = 0\n\t\t\t\t} else if highIdx > numElements {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t}\n\t\t\t\tvar val Object = &Array{\n\t\t\t\t\tValue: left.Value[lowIdx:highIdx],\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = val\n\t\t\t\tv.sp++\n\t\t\tcase *String:\n\t\t\t\tnumElements := int64(len(left.Value))\n\t\t\t\tvar highIdx int64\n\t\t\t\tif high == UndefinedValue {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t} else if highInt, ok := high.(*Int); ok {\n\t\t\t\t\thighIdx = highInt.Value\n\t\t\t\t} else {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index type: %s\",\n\t\t\t\t\t\thigh.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx > highIdx {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index: %d > %d\",\n\t\t\t\t\t\tlowIdx, highIdx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx < 0 {\n\t\t\t\t\tlowIdx = 0\n\t\t\t\t} else if lowIdx > numElements {\n\t\t\t\t\tlowIdx = numElements\n\t\t\t\t}\n\t\t\t\tif highIdx < 0 {\n\t\t\t\t\thighIdx = 0\n\t\t\t\t} else if highIdx > numElements {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t}\n\t\t\t\tvar val Object = &String{\n\t\t\t\t\tValue: left.Value[lowIdx:highIdx],\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = val\n\t\t\t\tv.sp++\n\t\t\tcase *Bytes:\n\t\t\t\tnumElements := int64(len(left.Value))\n\t\t\t\tvar highIdx int64\n\t\t\t\tif high == UndefinedValue {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t} else if highInt, ok := high.(*Int); ok {\n\t\t\t\t\thighIdx = highInt.Value\n\t\t\t\t} else {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index type: %s\",\n\t\t\t\t\t\thigh.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx > highIdx {\n\t\t\t\t\tv.err = fmt.Errorf(\"invalid slice index: %d > %d\",\n\t\t\t\t\t\tlowIdx, highIdx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif lowIdx < 0 {\n\t\t\t\t\tlowIdx = 0\n\t\t\t\t} else if lowIdx > numElements {\n\t\t\t\t\tlowIdx = numElements\n\t\t\t\t}\n\t\t\t\tif highIdx < 0 {\n\t\t\t\t\thighIdx = 0\n\t\t\t\t} else if highIdx > numElements {\n\t\t\t\t\thighIdx = numElements\n\t\t\t\t}\n\t\t\t\tvar val Object = &Bytes{\n\t\t\t\t\tValue: left.Value[lowIdx:highIdx],\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = val\n\t\t\t\tv.sp++\n\t\t\tdefault:\n\t\t\t\tv.err = fmt.Errorf(\"not indexable: %s\", left.TypeName())\n\t\t\t\treturn\n\t\t\t}\n\t\tcase parser.OpCall:\n\t\t\tnumArgs := int(v.curInsts[v.ip+1])\n\t\t\tspread := int(v.curInsts[v.ip+2])\n\t\t\tv.ip += 2\n\n\t\t\tvalue := v.stack[v.sp-1-numArgs]\n\t\t\tif !value.CanCall() {\n\t\t\t\tv.err = fmt.Errorf(\"not callable: %s\", value.TypeName())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif spread == 1 {\n\t\t\t\tv.sp--\n\t\t\t\tswitch arr := v.stack[v.sp].(type) {\n\t\t\t\tcase *Array:\n\t\t\t\t\tfor _, item := range arr.Value {\n\t\t\t\t\t\tv.stack[v.sp] = item\n\t\t\t\t\t\tv.sp++\n\t\t\t\t\t}\n\t\t\t\t\tnumArgs += len(arr.Value) - 1\n\t\t\t\tcase *ImmutableArray:\n\t\t\t\t\tfor _, item := range arr.Value {\n\t\t\t\t\t\tv.stack[v.sp] = item\n\t\t\t\t\t\tv.sp++\n\t\t\t\t\t}\n\t\t\t\t\tnumArgs += len(arr.Value) - 1\n\t\t\t\tdefault:\n\t\t\t\t\tv.err = fmt.Errorf(\"not an array: %s\", arr.TypeName())\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif callee, ok := value.(*CompiledFunction); ok {\n\t\t\t\tif callee.VarArgs {\n\t\t\t\t\t// if the closure is variadic,\n\t\t\t\t\t// roll up all variadic parameters into an array\n\t\t\t\t\trealArgs := callee.NumParameters - 1\n\t\t\t\t\tvarArgs := numArgs - realArgs\n\t\t\t\t\tif varArgs >= 0 {\n\t\t\t\t\t\tnumArgs = realArgs + 1\n\t\t\t\t\t\targs := make([]Object, varArgs)\n\t\t\t\t\t\tspStart := v.sp - varArgs\n\t\t\t\t\t\tfor i := spStart; i < v.sp; i++ {\n\t\t\t\t\t\t\targs[i-spStart] = v.stack[i]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv.stack[spStart] = &Array{Value: args}\n\t\t\t\t\t\tv.sp = spStart + 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif numArgs != callee.NumParameters {\n\t\t\t\t\tif callee.VarArgs {\n\t\t\t\t\t\tv.err = fmt.Errorf(\n\t\t\t\t\t\t\t\"wrong number of arguments: want>=%d, got=%d\",\n\t\t\t\t\t\t\tcallee.NumParameters-1, numArgs)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tv.err = fmt.Errorf(\n\t\t\t\t\t\t\t\"wrong number of arguments: want=%d, got=%d\",\n\t\t\t\t\t\t\tcallee.NumParameters, numArgs)\n\t\t\t\t\t}\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// test if it's tail-call\n\t\t\t\tif callee == v.curFrame.fn { // recursion\n\t\t\t\t\tnextOp := v.curInsts[v.ip+1]\n\t\t\t\t\tif nextOp == parser.OpReturn ||\n\t\t\t\t\t\t(nextOp == parser.OpPop &&\n\t\t\t\t\t\t\tparser.OpReturn == v.curInsts[v.ip+2]) {\n\t\t\t\t\t\tfor p := 0; p < numArgs; p++ {\n\t\t\t\t\t\t\tv.stack[v.curFrame.basePointer+p] =\n\t\t\t\t\t\t\t\tv.stack[v.sp-numArgs+p]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tv.sp -= numArgs + 1\n\t\t\t\t\t\tv.ip = -1 // reset IP to beginning of the frame\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif v.framesIndex >= MaxFrames {\n\t\t\t\t\tv.err = ErrStackOverflow\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// update call frame\n\t\t\t\tv.curFrame.ip = v.ip // store current ip before call\n\t\t\t\tv.curFrame = &(v.frames[v.framesIndex])\n\t\t\t\tv.curFrame.fn = callee\n\t\t\t\tv.curFrame.freeVars = callee.Free\n\t\t\t\tv.curFrame.basePointer = v.sp - numArgs\n\t\t\t\tv.curInsts = callee.Instructions\n\t\t\t\tv.ip = -1\n\t\t\t\tv.framesIndex++\n\t\t\t\tv.sp = v.sp - numArgs + callee.NumLocals\n\t\t\t} else {\n\t\t\t\tvar args []Object\n\t\t\t\targs = append(args, v.stack[v.sp-numArgs:v.sp]...)\n\t\t\t\tret, e := value.Call(args...)\n\t\t\t\tv.sp -= numArgs + 1\n\n\t\t\t\t// runtime error\n\t\t\t\tif e != nil {\n\t\t\t\t\tif e == ErrWrongNumArguments {\n\t\t\t\t\t\tv.err = fmt.Errorf(\n\t\t\t\t\t\t\t\"wrong number of arguments in call to '%s'\",\n\t\t\t\t\t\t\tvalue.TypeName())\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif e, ok := e.(ErrInvalidArgumentType); ok {\n\t\t\t\t\t\tv.err = fmt.Errorf(\n\t\t\t\t\t\t\t\"invalid type for argument '%s' in call to '%s': \"+\n\t\t\t\t\t\t\t\t\"expected %s, found %s\",\n\t\t\t\t\t\t\te.Name, value.TypeName(), e.Expected, e.Found)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tv.err = e\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// nil return -> undefined\n\t\t\t\tif ret == nil {\n\t\t\t\t\tret = UndefinedValue\n\t\t\t\t}\n\t\t\t\tv.allocs--\n\t\t\t\tif v.allocs == 0 {\n\t\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv.stack[v.sp] = ret\n\t\t\t\tv.sp++\n\t\t\t}\n\t\tcase parser.OpReturn:\n\t\t\tv.ip++\n\t\t\tvar retVal Object\n\t\t\tif int(v.curInsts[v.ip]) == 1 {\n\t\t\t\tretVal = v.stack[v.sp-1]\n\t\t\t} else {\n\t\t\t\tretVal = UndefinedValue\n\t\t\t}\n\t\t\t//v.sp--\n\t\t\tv.framesIndex--\n\t\t\tv.curFrame = &v.frames[v.framesIndex-1]\n\t\t\tv.curInsts = v.curFrame.fn.Instructions\n\t\t\tv.ip = v.curFrame.ip\n\t\t\t//v.sp = lastFrame.basePointer - 1\n\t\t\tv.sp = v.frames[v.framesIndex].basePointer\n\t\t\t// skip stack overflow check because (newSP) <= (oldSP)\n\t\t\tv.stack[v.sp-1] = retVal\n\t\t\t//v.sp++\n\t\tcase parser.OpDefineLocal:\n\t\t\tv.ip++\n\t\t\tlocalIndex := int(v.curInsts[v.ip])\n\t\t\tsp := v.curFrame.basePointer + localIndex\n\n\t\t\t// local variables can be mutated by other actions\n\t\t\t// so always store the copy of popped value\n\t\t\tval := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\tv.stack[sp] = val\n\t\tcase parser.OpSetLocal:\n\t\t\tlocalIndex := int(v.curInsts[v.ip+1])\n\t\t\tv.ip++\n\t\t\tsp := v.curFrame.basePointer + localIndex\n\n\t\t\t// update pointee of v.stack[sp] instead of replacing the pointer\n\t\t\t// itself. this is needed because there can be free variables\n\t\t\t// referencing the same local variables.\n\t\t\tval := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\tif obj, ok := v.stack[sp].(*ObjectPtr); ok {\n\t\t\t\t*obj.Value = val\n\t\t\t\tval = obj\n\t\t\t}\n\t\t\tv.stack[sp] = val // also use a copy of popped value\n\t\tcase parser.OpSetSelLocal:\n\t\t\tlocalIndex := int(v.curInsts[v.ip+1])\n\t\t\tnumSelectors := int(v.curInsts[v.ip+2])\n\t\t\tv.ip += 2\n\n\t\t\t// selectors and RHS value\n\t\t\tselectors := make([]Object, numSelectors)\n\t\t\tfor i := 0; i < numSelectors; i++ {\n\t\t\t\tselectors[i] = v.stack[v.sp-numSelectors+i]\n\t\t\t}\n\t\t\tval := v.stack[v.sp-numSelectors-1]\n\t\t\tv.sp -= numSelectors + 1\n\t\t\tdst := v.stack[v.curFrame.basePointer+localIndex]\n\t\t\tif obj, ok := dst.(*ObjectPtr); ok {\n\t\t\t\tdst = *obj.Value\n\t\t\t}\n\t\t\tif e := indexAssign(dst, val, selectors); e != nil {\n\t\t\t\tv.err = e\n\t\t\t\treturn\n\t\t\t}\n\t\tcase parser.OpGetLocal:\n\t\t\tv.ip++\n\t\t\tlocalIndex := int(v.curInsts[v.ip])\n\t\t\tval := v.stack[v.curFrame.basePointer+localIndex]\n\t\t\tif obj, ok := val.(*ObjectPtr); ok {\n\t\t\t\tval = *obj.Value\n\t\t\t}\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpGetBuiltin:\n\t\t\tv.ip++\n\t\t\tbuiltinIndex := int(v.curInsts[v.ip])\n\t\t\tv.stack[v.sp] = builtinFuncs[builtinIndex]\n\t\t\tv.sp++\n\t\tcase parser.OpClosure:\n\t\t\tv.ip += 3\n\t\t\tconstIndex := int(v.curInsts[v.ip-1]) | int(v.curInsts[v.ip-2])<<8\n\t\t\tnumFree := int(v.curInsts[v.ip])\n\t\t\tfn, ok := v.constants[constIndex].(*CompiledFunction)\n\t\t\tif !ok {\n\t\t\t\tv.err = fmt.Errorf(\"not function: %s\", fn.TypeName())\n\t\t\t\treturn\n\t\t\t}\n\t\t\tfree := make([]*ObjectPtr, numFree)\n\t\t\tfor i := 0; i < numFree; i++ {\n\t\t\t\tswitch freeVar := (v.stack[v.sp-numFree+i]).(type) {\n\t\t\t\tcase *ObjectPtr:\n\t\t\t\t\tfree[i] = freeVar\n\t\t\t\tdefault:\n\t\t\t\t\tfree[i] = &ObjectPtr{\n\t\t\t\t\t\tValue: &v.stack[v.sp-numFree+i],\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.sp -= numFree\n\t\t\tcl := &CompiledFunction{\n\t\t\t\tInstructions:  fn.Instructions,\n\t\t\t\tNumLocals:     fn.NumLocals,\n\t\t\t\tNumParameters: fn.NumParameters,\n\t\t\t\tVarArgs:       fn.VarArgs,\n\t\t\t\tSourceMap:     fn.SourceMap,\n\t\t\t\tFree:          free,\n\t\t\t}\n\t\t\tv.allocs--\n\t\t\tif v.allocs == 0 {\n\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.stack[v.sp] = cl\n\t\t\tv.sp++\n\t\tcase parser.OpGetFreePtr:\n\t\t\tv.ip++\n\t\t\tfreeIndex := int(v.curInsts[v.ip])\n\t\t\tval := v.curFrame.freeVars[freeIndex]\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpGetFree:\n\t\t\tv.ip++\n\t\t\tfreeIndex := int(v.curInsts[v.ip])\n\t\t\tval := *v.curFrame.freeVars[freeIndex].Value\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpSetFree:\n\t\t\tv.ip++\n\t\t\tfreeIndex := int(v.curInsts[v.ip])\n\t\t\t*v.curFrame.freeVars[freeIndex].Value = v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\tcase parser.OpGetLocalPtr:\n\t\t\tv.ip++\n\t\t\tlocalIndex := int(v.curInsts[v.ip])\n\t\t\tsp := v.curFrame.basePointer + localIndex\n\t\t\tval := v.stack[sp]\n\t\t\tvar freeVar *ObjectPtr\n\t\t\tif obj, ok := val.(*ObjectPtr); ok {\n\t\t\t\tfreeVar = obj\n\t\t\t} else {\n\t\t\t\tfreeVar = &ObjectPtr{Value: &val}\n\t\t\t\tv.stack[sp] = freeVar\n\t\t\t}\n\t\t\tv.stack[v.sp] = freeVar\n\t\t\tv.sp++\n\t\tcase parser.OpSetSelFree:\n\t\t\tv.ip += 2\n\t\t\tfreeIndex := int(v.curInsts[v.ip-1])\n\t\t\tnumSelectors := int(v.curInsts[v.ip])\n\n\t\t\t// selectors and RHS value\n\t\t\tselectors := make([]Object, numSelectors)\n\t\t\tfor i := 0; i < numSelectors; i++ {\n\t\t\t\tselectors[i] = v.stack[v.sp-numSelectors+i]\n\t\t\t}\n\t\t\tval := v.stack[v.sp-numSelectors-1]\n\t\t\tv.sp -= numSelectors + 1\n\t\t\te := indexAssign(*v.curFrame.freeVars[freeIndex].Value,\n\t\t\t\tval, selectors)\n\t\t\tif e != nil {\n\t\t\t\tv.err = e\n\t\t\t\treturn\n\t\t\t}\n\t\tcase parser.OpIteratorInit:\n\t\t\tvar iterator Object\n\t\t\tdst := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\tif !dst.CanIterate() {\n\t\t\t\tv.err = fmt.Errorf(\"not iterable: %s\", dst.TypeName())\n\t\t\t\treturn\n\t\t\t}\n\t\t\titerator = dst.Iterate()\n\t\t\tv.allocs--\n\t\t\tif v.allocs == 0 {\n\t\t\t\tv.err = ErrObjectAllocLimit\n\t\t\t\treturn\n\t\t\t}\n\t\t\tv.stack[v.sp] = iterator\n\t\t\tv.sp++\n\t\tcase parser.OpIteratorNext:\n\t\t\titerator := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\thasMore := iterator.(Iterator).Next()\n\t\t\tif hasMore {\n\t\t\t\tv.stack[v.sp] = TrueValue\n\t\t\t} else {\n\t\t\t\tv.stack[v.sp] = FalseValue\n\t\t\t}\n\t\t\tv.sp++\n\t\tcase parser.OpIteratorKey:\n\t\t\titerator := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\tval := iterator.(Iterator).Key()\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpIteratorValue:\n\t\t\titerator := v.stack[v.sp-1]\n\t\t\tv.sp--\n\t\t\tval := iterator.(Iterator).Value()\n\t\t\tv.stack[v.sp] = val\n\t\t\tv.sp++\n\t\tcase parser.OpSuspend:\n\t\t\treturn\n\t\tdefault:\n\t\t\tv.err = fmt.Errorf(\"unknown opcode: %d\", v.curInsts[v.ip])\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// IsStackEmpty tests if the stack is empty or not.\nfunc (v *VM) IsStackEmpty() bool {\n\treturn v.sp == 0\n}\n\nfunc indexAssign(dst, src Object, selectors []Object) error {\n\tnumSel := len(selectors)\n\tfor sidx := numSel - 1; sidx > 0; sidx-- {\n\t\tnext, err := dst.IndexGet(selectors[sidx])\n\t\tif err != nil {\n\t\t\tif err == ErrNotIndexable {\n\t\t\t\treturn fmt.Errorf(\"not indexable: %s\", dst.TypeName())\n\t\t\t}\n\t\t\tif err == ErrInvalidIndexType {\n\t\t\t\treturn fmt.Errorf(\"invalid index type: %s\",\n\t\t\t\t\tselectors[sidx].TypeName())\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tdst = next\n\t}\n\n\tif err := dst.IndexSet(selectors[0], src); err != nil {\n\t\tif err == ErrNotIndexAssignable {\n\t\t\treturn fmt.Errorf(\"not index-assignable: %s\", dst.TypeName())\n\t\t}\n\t\tif err == ErrInvalidIndexValueType {\n\t\t\treturn fmt.Errorf(\"invaid index value type: %s\", src.TypeName())\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "vm_test.go",
          "type": "blob",
          "size": 108.4716796875,
          "content": "package tengo_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"reflect\"\n\t_runtime \"runtime\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/d5/tengo/v2\"\n\t\"github.com/d5/tengo/v2/parser\"\n\t\"github.com/d5/tengo/v2/require\"\n\t\"github.com/d5/tengo/v2/stdlib\"\n\t\"github.com/d5/tengo/v2/token\"\n)\n\nconst testOut = \"out\"\n\ntype IARR []interface{}\ntype IMAP map[string]interface{}\ntype MAP = map[string]interface{}\ntype ARR = []interface{}\n\ntype testopts struct {\n\tmodules     *tengo.ModuleMap\n\tsymbols     map[string]tengo.Object\n\tmaxAllocs   int64\n\tskip2ndPass bool\n}\n\nfunc Opts() *testopts {\n\treturn &testopts{\n\t\tmodules:     tengo.NewModuleMap(),\n\t\tsymbols:     make(map[string]tengo.Object),\n\t\tmaxAllocs:   -1,\n\t\tskip2ndPass: false,\n\t}\n}\n\nfunc (o *testopts) copy() *testopts {\n\tc := &testopts{\n\t\tmodules:     o.modules.Copy(),\n\t\tsymbols:     make(map[string]tengo.Object),\n\t\tmaxAllocs:   o.maxAllocs,\n\t\tskip2ndPass: o.skip2ndPass,\n\t}\n\tfor k, v := range o.symbols {\n\t\tc.symbols[k] = v\n\t}\n\treturn c\n}\n\nfunc (o *testopts) Stdlib() *testopts {\n\to.modules.AddMap(stdlib.GetModuleMap(stdlib.AllModuleNames()...))\n\treturn o\n}\n\nfunc (o *testopts) Module(name string, mod interface{}) *testopts {\n\tc := o.copy()\n\tswitch mod := mod.(type) {\n\tcase tengo.Importable:\n\t\tc.modules.Add(name, mod)\n\tcase string:\n\t\tc.modules.AddSourceModule(name, []byte(mod))\n\tcase []byte:\n\t\tc.modules.AddSourceModule(name, mod)\n\tdefault:\n\t\tpanic(fmt.Errorf(\"invalid module type: %T\", mod))\n\t}\n\treturn c\n}\n\nfunc (o *testopts) Symbol(name string, value tengo.Object) *testopts {\n\tc := o.copy()\n\tc.symbols[name] = value\n\treturn c\n}\n\nfunc (o *testopts) MaxAllocs(limit int64) *testopts {\n\tc := o.copy()\n\tc.maxAllocs = limit\n\treturn c\n}\n\nfunc (o *testopts) Skip2ndPass() *testopts {\n\tc := o.copy()\n\tc.skip2ndPass = true\n\treturn c\n}\n\ntype customError struct {\n\terr error\n\tstr string\n}\n\nfunc (c *customError) Error() string {\n\treturn c.str\n}\n\nfunc (c *customError) Unwrap() error {\n\treturn c.err\n}\n\nfunc TestArray(t *testing.T) {\n\texpectRun(t, `out = [1, 2 * 2, 3 + 3]`, nil, ARR{1, 4, 6})\n\n\t// array copy-by-reference\n\texpectRun(t, `a1 := [1, 2, 3]; a2 := a1; a1[0] = 5; out = a2`,\n\t\tnil, ARR{5, 2, 3})\n\texpectRun(t, `func () { a1 := [1, 2, 3]; a2 := a1; a1[0] = 5; out = a2 }()`,\n\t\tnil, ARR{5, 2, 3})\n\n\t// array index set\n\texpectError(t, `a1 := [1, 2, 3]; a1[3] = 5`,\n\t\tnil, \"index out of bounds\")\n\n\t// index operator\n\tarr := ARR{1, 2, 3, 4, 5, 6}\n\tarrStr := `[1, 2, 3, 4, 5, 6]`\n\tarrLen := 6\n\tfor idx := 0; idx < arrLen; idx++ {\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d]\", arrStr, idx),\n\t\t\tnil, arr[idx])\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[0 + %d]\", arrStr, idx),\n\t\t\tnil, arr[idx])\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[1 + %d - 1]\", arrStr, idx),\n\t\t\tnil, arr[idx])\n\t\texpectRun(t, fmt.Sprintf(\"idx := %d; out = %s[idx]\", idx, arrStr),\n\t\t\tnil, arr[idx])\n\t}\n\n\texpectRun(t, fmt.Sprintf(\"%s[%d]\", arrStr, -1),\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, fmt.Sprintf(\"%s[%d]\", arrStr, arrLen),\n\t\tnil, tengo.UndefinedValue)\n\n\t// slice operator\n\tfor low := 0; low < arrLen; low++ {\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d:%d]\", arrStr, low, low),\n\t\t\tnil, ARR{})\n\t\tfor high := low; high <= arrLen; high++ {\n\t\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d:%d]\", arrStr, low, high),\n\t\t\t\tnil, arr[low:high])\n\t\t\texpectRun(t, fmt.Sprintf(\"out = %s[0 + %d : 0 + %d]\",\n\t\t\t\tarrStr, low, high), nil, arr[low:high])\n\t\t\texpectRun(t, fmt.Sprintf(\"out = %s[1 + %d - 1 : 1 + %d - 1]\",\n\t\t\t\tarrStr, low, high), nil, arr[low:high])\n\t\t\texpectRun(t, fmt.Sprintf(\"out = %s[:%d]\", arrStr, high),\n\t\t\t\tnil, arr[:high])\n\t\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d:]\", arrStr, low),\n\t\t\t\tnil, arr[low:])\n\t\t}\n\t}\n\n\texpectRun(t, fmt.Sprintf(\"out = %s[:]\", arrStr),\n\t\tnil, arr)\n\texpectRun(t, fmt.Sprintf(\"out = %s[%d:]\", arrStr, -1),\n\t\tnil, arr)\n\texpectRun(t, fmt.Sprintf(\"out = %s[:%d]\", arrStr, arrLen+1),\n\t\tnil, arr)\n\texpectRun(t, fmt.Sprintf(\"out = %s[%d:%d]\", arrStr, 2, 2),\n\t\tnil, ARR{})\n\n\texpectError(t, fmt.Sprintf(\"%s[:%d]\", arrStr, -1),\n\t\tnil, \"invalid slice index\")\n\texpectError(t, fmt.Sprintf(\"%s[%d:]\", arrStr, arrLen+1),\n\t\tnil, \"invalid slice index\")\n\texpectError(t, fmt.Sprintf(\"%s[%d:%d]\", arrStr, 0, -1),\n\t\tnil, \"invalid slice index\")\n\texpectError(t, fmt.Sprintf(\"%s[%d:%d]\", arrStr, 2, 1),\n\t\tnil, \"invalid slice index\")\n}\n\nfunc TestAssignment(t *testing.T) {\n\texpectRun(t, `a := 1; a = 2; out = a`, nil, 2)\n\texpectRun(t, `a := 1; a = 2; out = a`, nil, 2)\n\texpectRun(t, `a := 1; a = a + 4; out = a`, nil, 5)\n\texpectRun(t, `a := 1; f1 := func() { a = 2; return a }; out = f1()`,\n\t\tnil, 2)\n\texpectRun(t, `a := 1; f1 := func() { a := 3; a = 2; return a }; out = f1()`,\n\t\tnil, 2)\n\n\texpectRun(t, `a := 1; out = a`, nil, 1)\n\texpectRun(t, `a := 1; a = 2; out = a`, nil, 2)\n\texpectRun(t, `a := 1; func() { a = 2 }(); out = a`, nil, 2)\n\texpectRun(t, `a := 1; func() { a := 2 }(); out = a`, nil, 1) // \"a := 2\" defines a new local variable 'a'\n\texpectRun(t, `a := 1; func() { b := 2; out = b }()`, nil, 2)\n\texpectRun(t, `\nout = func() { \n\ta := 2\n\tfunc() {\n\t\ta = 3 // captured from outer scope\n\t}()\n\treturn a\n}()\n`, nil, 3)\n\n\texpectRun(t, `\nfunc() {\n\ta := 5\n\tout = func() {  \t\n\t\ta := 4\t\t\t\t\t\t\n\t\treturn a\n\t}()\n}()`, nil, 4)\n\n\texpectError(t, `a := 1; a := 2`, nil, \"redeclared\")              // redeclared in the same scope\n\texpectError(t, `func() { a := 1; a := 2 }()`, nil, \"redeclared\") // redeclared in the same scope\n\n\texpectRun(t, `a := 1; a += 2; out = a`, nil, 3)\n\texpectRun(t, `a := 1; a += 4 - 2;; out = a`, nil, 3)\n\texpectRun(t, `a := 3; a -= 1;; out = a`, nil, 2)\n\texpectRun(t, `a := 3; a -= 5 - 4;; out = a`, nil, 2)\n\texpectRun(t, `a := 2; a *= 4;; out = a`, nil, 8)\n\texpectRun(t, `a := 2; a *= 1 + 3;; out = a`, nil, 8)\n\texpectRun(t, `a := 10; a /= 2;; out = a`, nil, 5)\n\texpectRun(t, `a := 10; a /= 5 - 3;; out = a`, nil, 5)\n\n\t// compound assignment operator does not define new variable\n\texpectError(t, `a += 4`, nil, \"unresolved reference\")\n\texpectError(t, `a -= 4`, nil, \"unresolved reference\")\n\texpectError(t, `a *= 4`, nil, \"unresolved reference\")\n\texpectError(t, `a /= 4`, nil, \"unresolved reference\")\n\n\texpectRun(t, `\nf1 := func() { \n\tf2 := func() { \n\t\ta := 1\n\t\ta += 2    // it's a statement, not an expression\n\t\treturn a\n\t}; \n\t\n\treturn f2(); \n}; \n\nout = f1();`, nil, 3)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 1; a += 4 - 2; return a }; return f2(); }; out = f1()`,\n\t\tnil, 3)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 3; a -= 1; return a }; return f2(); }; out = f1()`,\n\t\tnil, 2)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 3; a -= 5 - 4; return a }; return f2(); }; out = f1()`,\n\t\tnil, 2)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 2; a *= 4; return a }; return f2(); }; out = f1()`,\n\t\tnil, 8)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 2; a *= 1 + 3; return a }; return f2(); }; out = f1()`,\n\t\tnil, 8)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 10; a /= 2; return a }; return f2(); }; out = f1()`,\n\t\tnil, 5)\n\texpectRun(t, `f1 := func() { f2 := func() { a := 10; a /= 5 - 3; return a }; return f2(); }; out = f1()`,\n\t\tnil, 5)\n\n\texpectRun(t, `a := 1; f1 := func() { f2 := func() { a += 2; return a }; return f2(); }; out = f1()`,\n\t\tnil, 3)\n\n\texpectRun(t, `\n\tf1 := func(a) {\n\t\treturn func(b) {\n\t\t\tc := a\n\t\t\tc += b * 2\n\t\t\treturn c\n\t\t}\n\t}\n\t\n\tout = f1(3)(4)\n\t`, nil, 11)\n\n\texpectRun(t, `\n\tout = func() {\n\t\ta := 1\n\t\tfunc() {\n\t\t\ta = 2\n\t\t\tfunc() {\n\t\t\t\ta = 3\n\t\t\t\tfunc() {\n\t\t\t\t\ta := 4 // declared new\n\t\t\t\t}()\n\t\t\t}()\n\t\t}()\n\t\treturn a\n\t}()\n\t`, nil, 3)\n\n\t// write on free variables\n\texpectRun(t, `\n\tf1 := func() {\n\t\ta := 5\n\t\n\t\treturn func() {\n\t\t\ta += 3\n\t\t\treturn a\n\t\t}()\n\t}\n\tout = f1()\n\t`, nil, 8)\n\n\texpectRun(t, `\n    out = func() {\n        f1 := func() {\n            a := 5\n            add1 := func() { a += 1 }\n            add2 := func() { a += 2 }\n            a += 3\n            return func() { a += 4; add1(); add2(); a += 5; return a }\n        }\n        return f1()\n    }()()\n    `, nil, 20)\n\n\texpectRun(t, `\n\t\tit := func(seq, fn) {\n\t\t\tfn(seq[0])\n\t\t\tfn(seq[1])\n\t\t\tfn(seq[2])\n\t\t}\n\t\n\t\tfoo := func(a) {\n\t\t\tb := 0\n\t\t\tit([1, 2, 3], func(x) {\n\t\t\t\tb = x + a\n\t\t\t})\n\t\t\treturn b\n\t\t}\n\t\n\t\tout = foo(2)\n\t\t`, nil, 5)\n\n\texpectRun(t, `\n\t\tit := func(seq, fn) {\n\t\t\tfn(seq[0])\n\t\t\tfn(seq[1])\n\t\t\tfn(seq[2])\n\t\t}\n\t\n\t\tfoo := func(a) {\n\t\t\tb := 0\n\t\t\tit([1, 2, 3], func(x) {\n\t\t\t\tb += x + a\n\t\t\t})\n\t\t\treturn b\n\t\t}\n\t\n\t\tout = foo(2)\n\t\t`, nil, 12)\n\n\texpectRun(t, `\nout = func() {\n\ta := 1\n\tfunc() {\n\t\ta = 2\n\t}()\n\treturn a\n}()\n`, nil, 2)\n\n\texpectRun(t, `\nf := func() {\n\ta := 1\n\treturn {\n\t\tb: func() { a += 3 },\n\t\tc: func() { a += 2 },\n\t\td: func() { return a }\n\t}\n}\nm := f()\nm.b()\nm.c()\nout = m.d()\n`, nil, 6)\n\n\texpectRun(t, `\neach := func(s, x) { for i:=0; i<len(s); i++ { x(s[i]) } }\n\nout = func() {\n\ta := 100\n\teach([1, 2, 3], func(x) {\n\t\ta += x\n\t})\n\ta += 10\n\treturn func(b) {\n\t\treturn a + b\n\t}\n}()(20)\n`, nil, 136)\n\n\t// assigning different type value\n\texpectRun(t, `a := 1; a = \"foo\"; out = a`, nil, \"foo\")              // global\n\texpectRun(t, `func() { a := 1; a = \"foo\"; out = a }()`, nil, \"foo\") // local\n\texpectRun(t, `\nout = func() { \n\ta := 5\n\treturn func() { \n\t\ta = \"foo\"\n\t\treturn a\n\t}()\n}()`, nil, \"foo\") // free\n\n\t// variables declared in if/for blocks\n\texpectRun(t, `for a:=0; a<5; a++ {}; a := \"foo\"; out = a`,\n\t\tnil, \"foo\")\n\texpectRun(t, `func() { for a:=0; a<5; a++ {}; a := \"foo\"; out = a }()`,\n\t\tnil, \"foo\")\n\n\t// selectors\n\texpectRun(t, `a:=[1,2,3]; a[1] = 5; out = a[1]`, nil, 5)\n\texpectRun(t, `a:=[1,2,3]; a[1] += 5; out = a[1]`, nil, 7)\n\texpectRun(t, `a:={b:1,c:2}; a.b = 5; out = a.b`, nil, 5)\n\texpectRun(t, `a:={b:1,c:2}; a.b += 5; out = a.b`, nil, 6)\n\texpectRun(t, `a:={b:1,c:2}; a.b += a.c; out = a.b`, nil, 3)\n\texpectRun(t, `a:={b:1,c:2}; a.b += a.c; out = a.c`, nil, 2)\n\texpectRun(t, `\na := {\n\tb: [1, 2, 3],\n\tc: {\n\t\td: 8,\n\t\te: \"foo\",\n\t\tf: [9, 8]\n\t}\n}\na.c.f[1] += 2\nout = a[\"c\"][\"f\"][1]\n`, nil, 10)\n\n\texpectRun(t, `\na := {\n\tb: [1, 2, 3],\n\tc: {\n\t\td: 8,\n\t\te: \"foo\",\n\t\tf: [9, 8]\n\t}\n}\na.c.h = \"bar\"\nout = a.c.h\n`, nil, \"bar\")\n\n\texpectError(t, `\na := {\n\tb: [1, 2, 3],\n\tc: {\n\t\td: 8,\n\t\te: \"foo\",\n\t\tf: [9, 8]\n\t}\n}\na.x.e = \"bar\"`, nil, \"not index-assignable\")\n}\n\nfunc TestBitwise(t *testing.T) {\n\texpectRun(t, `out = 1 & 1`, nil, 1)\n\texpectRun(t, `out = 1 & 0`, nil, 0)\n\texpectRun(t, `out = 0 & 1`, nil, 0)\n\texpectRun(t, `out = 0 & 0`, nil, 0)\n\texpectRun(t, `out = 1 | 1`, nil, 1)\n\texpectRun(t, `out = 1 | 0`, nil, 1)\n\texpectRun(t, `out = 0 | 1`, nil, 1)\n\texpectRun(t, `out = 0 | 0`, nil, 0)\n\texpectRun(t, `out = 1 ^ 1`, nil, 0)\n\texpectRun(t, `out = 1 ^ 0`, nil, 1)\n\texpectRun(t, `out = 0 ^ 1`, nil, 1)\n\texpectRun(t, `out = 0 ^ 0`, nil, 0)\n\texpectRun(t, `out = 1 &^ 1`, nil, 0)\n\texpectRun(t, `out = 1 &^ 0`, nil, 1)\n\texpectRun(t, `out = 0 &^ 1`, nil, 0)\n\texpectRun(t, `out = 0 &^ 0`, nil, 0)\n\texpectRun(t, `out = 1 << 2`, nil, 4)\n\texpectRun(t, `out = 16 >> 2`, nil, 4)\n\n\texpectRun(t, `out = 1; out &= 1`, nil, 1)\n\texpectRun(t, `out = 1; out |= 0`, nil, 1)\n\texpectRun(t, `out = 1; out ^= 0`, nil, 1)\n\texpectRun(t, `out = 1; out &^= 0`, nil, 1)\n\texpectRun(t, `out = 1; out <<= 2`, nil, 4)\n\texpectRun(t, `out = 16; out >>= 2`, nil, 4)\n\n\texpectRun(t, `out = ^0`, nil, ^0)\n\texpectRun(t, `out = ^1`, nil, ^1)\n\texpectRun(t, `out = ^55`, nil, ^55)\n\texpectRun(t, `out = ^-55`, nil, ^-55)\n}\n\nfunc TestBoolean(t *testing.T) {\n\texpectRun(t, `out = true`, nil, true)\n\texpectRun(t, `out = false`, nil, false)\n\n\texpectRun(t, `out = 1 < 2`, nil, true)\n\texpectRun(t, `out = 1 > 2`, nil, false)\n\texpectRun(t, `out = 1 < 1`, nil, false)\n\texpectRun(t, `out = 1 > 2`, nil, false)\n\texpectRun(t, `out = 1 == 1`, nil, true)\n\texpectRun(t, `out = 1 != 1`, nil, false)\n\texpectRun(t, `out = 1 == 2`, nil, false)\n\texpectRun(t, `out = 1 != 2`, nil, true)\n\texpectRun(t, `out = 1 <= 2`, nil, true)\n\texpectRun(t, `out = 1 >= 2`, nil, false)\n\texpectRun(t, `out = 1 <= 1`, nil, true)\n\texpectRun(t, `out = 1 >= 2`, nil, false)\n\n\texpectRun(t, `out = true == true`, nil, true)\n\texpectRun(t, `out = false == false`, nil, true)\n\texpectRun(t, `out = true == false`, nil, false)\n\texpectRun(t, `out = true != false`, nil, true)\n\texpectRun(t, `out = false != true`, nil, true)\n\texpectRun(t, `out = (1 < 2) == true`, nil, true)\n\texpectRun(t, `out = (1 < 2) == false`, nil, false)\n\texpectRun(t, `out = (1 > 2) == true`, nil, false)\n\texpectRun(t, `out = (1 > 2) == false`, nil, true)\n\n\texpectError(t, `5 + true`, nil, \"invalid operation\")\n\texpectError(t, `5 + true; 5`, nil, \"invalid operation\")\n\texpectError(t, `-true`, nil, \"invalid operation\")\n\texpectError(t, `true + false`, nil, \"invalid operation\")\n\texpectError(t, `5; true + false; 5`, nil, \"invalid operation\")\n\texpectError(t, `if (10 > 1) { true + false; }`, nil, \"invalid operation\")\n\texpectError(t, `\nfunc() {\n\tif (10 > 1) {\n\t\tif (10 > 1) {\n\t\t\treturn true + false;\n\t\t}\n\n\t\treturn 1;\n\t}\n}()\n`, nil, \"invalid operation\")\n\texpectError(t, `if (true + false) { 10 }`, nil, \"invalid operation\")\n\texpectError(t, `10 + (true + false)`, nil, \"invalid operation\")\n\texpectError(t, `(true + false) + 20`, nil, \"invalid operation\")\n\texpectError(t, `!(true + false)`, nil, \"invalid operation\")\n}\n\nfunc TestUndefined(t *testing.T) {\n\texpectRun(t, `out = undefined`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = undefined.a`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = undefined[1]`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = undefined.a.b`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = undefined[1][2]`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = undefined ? 1 : 2`, nil, 2)\n\texpectRun(t, `out = undefined == undefined`, nil, true)\n\texpectRun(t, `out = undefined == 1`, nil, false)\n\texpectRun(t, `out = 1 == undefined`, nil, false)\n\texpectRun(t, `out = undefined == float([])`, nil, true)\n\texpectRun(t, `out = float([]) == undefined`, nil, true)\n}\n\nfunc TestBuiltinFunction(t *testing.T) {\n\texpectRun(t, `out = len(\"\")`, nil, 0)\n\texpectRun(t, `out = len(\"four\")`, nil, 4)\n\texpectRun(t, `out = len(\"hello world\")`, nil, 11)\n\texpectRun(t, `out = len([])`, nil, 0)\n\texpectRun(t, `out = len([1, 2, 3])`, nil, 3)\n\texpectRun(t, `out = len({})`, nil, 0)\n\texpectRun(t, `out = len({a:1, b:2})`, nil, 2)\n\texpectRun(t, `out = len(immutable([]))`, nil, 0)\n\texpectRun(t, `out = len(immutable([1, 2, 3]))`, nil, 3)\n\texpectRun(t, `out = len(immutable({}))`, nil, 0)\n\texpectRun(t, `out = len(immutable({a:1, b:2}))`, nil, 2)\n\texpectError(t, `len(1)`, nil, \"invalid type for argument\")\n\texpectError(t, `len(\"one\", \"two\")`, nil, \"wrong number of arguments\")\n\n\texpectRun(t, `out = copy(1)`, nil, 1)\n\texpectError(t, `copy(1, 2)`, nil, \"wrong number of arguments\")\n\n\texpectRun(t, `out = append([1, 2, 3], 4)`, nil, ARR{1, 2, 3, 4})\n\texpectRun(t, `out = append([1, 2, 3], 4, 5, 6)`, nil, ARR{1, 2, 3, 4, 5, 6})\n\texpectRun(t, `out = append([1, 2, 3], \"foo\", false)`,\n\t\tnil, ARR{1, 2, 3, \"foo\", false})\n\n\texpectRun(t, `out = int(1)`, nil, 1)\n\texpectRun(t, `out = int(1.8)`, nil, 1)\n\texpectRun(t, `out = int(\"-522\")`, nil, -522)\n\texpectRun(t, `out = int(true)`, nil, 1)\n\texpectRun(t, `out = int(false)`, nil, 0)\n\texpectRun(t, `out = int('8')`, nil, 56)\n\texpectRun(t, `out = int([1])`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = int({a: 1})`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = int(undefined)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = int(\"-522\", 1)`, nil, -522)\n\texpectRun(t, `out = int(undefined, 1)`, nil, 1)\n\texpectRun(t, `out = int(undefined, 1.8)`, nil, 1.8)\n\texpectRun(t, `out = int(undefined, string(1))`, nil, \"1\")\n\texpectRun(t, `out = int(undefined, undefined)`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `out = string(1)`, nil, \"1\")\n\texpectRun(t, `out = string(1.8)`, nil, \"1.8\")\n\texpectRun(t, `out = string(\"-522\")`, nil, \"-522\")\n\texpectRun(t, `out = string(true)`, nil, \"true\")\n\texpectRun(t, `out = string(false)`, nil, \"false\")\n\texpectRun(t, `out = string('8')`, nil, \"8\")\n\texpectRun(t, `out = string([1,8.1,true,3])`, nil, \"[1, 8.1, true, 3]\")\n\texpectRun(t, `out = string({b: \"foo\"})`, nil, `{b: \"foo\"}`)\n\texpectRun(t, `out = string(undefined)`, nil, tengo.UndefinedValue) // not \"undefined\"\n\texpectRun(t, `out = string(1, \"-522\")`, nil, \"1\")\n\texpectRun(t, `out = string(undefined, \"-522\")`, nil, \"-522\") // not \"undefined\"\n\n\texpectRun(t, `out = float(1)`, nil, 1.0)\n\texpectRun(t, `out = float(1.8)`, nil, 1.8)\n\texpectRun(t, `out = float(\"-52.2\")`, nil, -52.2)\n\texpectRun(t, `out = float(true)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = float(false)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = float('8')`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = float([1,8.1,true,3])`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = float({a: 1, b: \"foo\"})`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = float(undefined)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = float(\"-52.2\", 1.8)`, nil, -52.2)\n\texpectRun(t, `out = float(undefined, 1)`, nil, 1)\n\texpectRun(t, `out = float(undefined, 1.8)`, nil, 1.8)\n\texpectRun(t, `out = float(undefined, \"-52.2\")`, nil, \"-52.2\")\n\texpectRun(t, `out = float(undefined, char(56))`, nil, '8')\n\texpectRun(t, `out = float(undefined, undefined)`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `out = char(56)`, nil, '8')\n\texpectRun(t, `out = char(1.8)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char(\"-52.2\")`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char(true)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char(false)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char('8')`, nil, '8')\n\texpectRun(t, `out = char([1,8.1,true,3])`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char({a: 1, b: \"foo\"})`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char(undefined)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = char(56, 'a')`, nil, '8')\n\texpectRun(t, `out = char(undefined, '8')`, nil, '8')\n\texpectRun(t, `out = char(undefined, 56)`, nil, 56)\n\texpectRun(t, `out = char(undefined, \"-52.2\")`, nil, \"-52.2\")\n\texpectRun(t, `out = char(undefined, undefined)`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `out = bool(1)`, nil, true)          // non-zero integer: true\n\texpectRun(t, `out = bool(0)`, nil, false)         // zero: true\n\texpectRun(t, `out = bool(1.8)`, nil, true)        // all floats (except for NaN): true\n\texpectRun(t, `out = bool(0.0)`, nil, true)        // all floats (except for NaN): true\n\texpectRun(t, `out = bool(\"false\")`, nil, true)    // non-empty string: true\n\texpectRun(t, `out = bool(\"\")`, nil, false)        // empty string: false\n\texpectRun(t, `out = bool(true)`, nil, true)       // true: true\n\texpectRun(t, `out = bool(false)`, nil, false)     // false: false\n\texpectRun(t, `out = bool('8')`, nil, true)        // non-zero chars: true\n\texpectRun(t, `out = bool(char(0))`, nil, false)   // zero char: false\n\texpectRun(t, `out = bool([1])`, nil, true)        // non-empty arrays: true\n\texpectRun(t, `out = bool([])`, nil, false)        // empty array: false\n\texpectRun(t, `out = bool({a: 1})`, nil, true)     // non-empty maps: true\n\texpectRun(t, `out = bool({})`, nil, false)        // empty maps: false\n\texpectRun(t, `out = bool(undefined)`, nil, false) // undefined: false\n\n\texpectRun(t, `out = bytes(1)`, nil, []byte{0})\n\texpectRun(t, `out = bytes(1.8)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes(\"-522\")`, nil, []byte{'-', '5', '2', '2'})\n\texpectRun(t, `out = bytes(true)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes(false)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes('8')`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes([1])`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes({a: 1})`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes(undefined)`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = bytes(\"-522\", ['8'])`, nil, []byte{'-', '5', '2', '2'})\n\texpectRun(t, `out = bytes(undefined, \"-522\")`, nil, \"-522\")\n\texpectRun(t, `out = bytes(undefined, 1)`, nil, 1)\n\texpectRun(t, `out = bytes(undefined, 1.8)`, nil, 1.8)\n\texpectRun(t, `out = bytes(undefined, int(\"-522\"))`, nil, -522)\n\texpectRun(t, `out = bytes(undefined, undefined)`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `out = is_error(error(1))`, nil, true)\n\texpectRun(t, `out = is_error(1)`, nil, false)\n\n\texpectRun(t, `out = is_undefined(undefined)`, nil, true)\n\texpectRun(t, `out = is_undefined(error(1))`, nil, false)\n\n\t// type_name\n\texpectRun(t, `out = type_name(1)`, nil, \"int\")\n\texpectRun(t, `out = type_name(1.1)`, nil, \"float\")\n\texpectRun(t, `out = type_name(\"a\")`, nil, \"string\")\n\texpectRun(t, `out = type_name([1,2,3])`, nil, \"array\")\n\texpectRun(t, `out = type_name({k:1})`, nil, \"map\")\n\texpectRun(t, `out = type_name('a')`, nil, \"char\")\n\texpectRun(t, `out = type_name(true)`, nil, \"bool\")\n\texpectRun(t, `out = type_name(false)`, nil, \"bool\")\n\texpectRun(t, `out = type_name(bytes( 1))`, nil, \"bytes\")\n\texpectRun(t, `out = type_name(undefined)`, nil, \"undefined\")\n\texpectRun(t, `out = type_name(error(\"err\"))`, nil, \"error\")\n\texpectRun(t, `out = type_name(func() {})`, nil, \"compiled-function\")\n\texpectRun(t, `a := func(x) { return func() { return x } }; out = type_name(a(5))`,\n\t\tnil, \"compiled-function\") // closure\n\n\t// is_function\n\texpectRun(t, `out = is_function(1)`, nil, false)\n\texpectRun(t, `out = is_function(func() {})`, nil, true)\n\texpectRun(t, `out = is_function(func(x) { return x })`, nil, true)\n\texpectRun(t, `out = is_function(len)`, nil, false) // builtin function\n\texpectRun(t, `a := func(x) { return func() { return x } }; out = is_function(a)`,\n\t\tnil, true) // function\n\texpectRun(t, `a := func(x) { return func() { return x } }; out = is_function(a(5))`,\n\t\tnil, true) // closure\n\texpectRun(t, `out = is_function(x)`,\n\t\tOpts().Symbol(\"x\", &StringArray{\n\t\t\tValue: []string{\"foo\", \"bar\"},\n\t\t}).Skip2ndPass(),\n\t\tfalse) // user object\n\n\t// is_callable\n\texpectRun(t, `out = is_callable(1)`, nil, false)\n\texpectRun(t, `out = is_callable(func() {})`, nil, true)\n\texpectRun(t, `out = is_callable(func(x) { return x })`, nil, true)\n\texpectRun(t, `out = is_callable(len)`, nil, true) // builtin function\n\texpectRun(t, `a := func(x) { return func() { return x } }; out = is_callable(a)`,\n\t\tnil, true) // function\n\texpectRun(t, `a := func(x) { return func() { return x } }; out = is_callable(a(5))`,\n\t\tnil, true) // closure\n\texpectRun(t, `out = is_callable(x)`,\n\t\tOpts().Symbol(\"x\", &StringArray{\n\t\t\tValue: []string{\"foo\", \"bar\"},\n\t\t}).Skip2ndPass(), true) // user object\n\n\texpectRun(t, `out = format(\"\")`, nil, \"\")\n\texpectRun(t, `out = format(\"foo\")`, nil, \"foo\")\n\texpectRun(t, `out = format(\"foo %d %v %s\", 1, 2, \"bar\")`,\n\t\tnil, \"foo 1 2 bar\")\n\texpectRun(t, `out = format(\"foo %v\", [1, \"bar\", true])`,\n\t\tnil, `foo [1, \"bar\", true]`)\n\texpectRun(t, `out = format(\"foo %v %d\", [1, \"bar\", true], 19)`,\n\t\tnil, `foo [1, \"bar\", true] 19`)\n\texpectRun(t, `out = format(\"foo %v\", {\"a\": {\"b\": {\"c\": [1, 2, 3]}}})`,\n\t\tnil, `foo {a: {b: {c: [1, 2, 3]}}}`)\n\texpectRun(t, `out = format(\"%v\", [1, [2, [3, 4]]])`,\n\t\tnil, `[1, [2, [3, 4]]]`)\n\n\ttengo.MaxStringLen = 9\n\texpectError(t, `format(\"%s\", \"1234567890\")`,\n\t\tnil, \"exceeding string size limit\")\n\ttengo.MaxStringLen = 2147483647\n\n\t// delete\n\texpectError(t, `delete()`, nil, tengo.ErrWrongNumArguments.Error())\n\texpectError(t, `delete(1)`, nil, tengo.ErrWrongNumArguments.Error())\n\texpectError(t, `delete(1, 2, 3)`, nil, tengo.ErrWrongNumArguments.Error())\n\texpectError(t, `delete({}, \"\", 3)`, nil, tengo.ErrWrongNumArguments.Error())\n\texpectError(t, `delete(1, 1)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `delete(1.0, 1)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `delete(\"str\", 1)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `delete(bytes(\"str\"), 1)`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete(error(\"err\"), 1)`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete(true, 1)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `delete(char('c'), 1)`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete(undefined, 1)`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete(time(1257894000), 1)`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete(immutable({}), \"key\")`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete(immutable([]), \"\")`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `delete([], \"\")`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `delete({}, 1)`, nil, `invalid type for argument 'second'`)\n\texpectError(t, `delete({}, 1.0)`, nil, `invalid type for argument 'second'`)\n\texpectError(t, `delete({}, undefined)`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `delete({}, [])`, nil, `invalid type for argument 'second'`)\n\texpectError(t, `delete({}, {})`, nil, `invalid type for argument 'second'`)\n\texpectError(t, `delete({}, error(\"err\"))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `delete({}, bytes(\"str\"))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `delete({}, char(35))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `delete({}, time(1257894000))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `delete({}, immutable({}))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `delete({}, immutable([]))`, nil,\n\t\t`invalid type for argument 'second'`)\n\n\texpectRun(t, `out = delete({}, \"\")`, nil, tengo.UndefinedValue)\n\texpectRun(t, `out = {key1: 1}; delete(out, \"key1\")`, nil, MAP{})\n\texpectRun(t, `out = {key1: 1, key2: \"2\"}; delete(out, \"key1\")`, nil,\n\t\tMAP{\"key2\": \"2\"})\n\texpectRun(t, `out = [1, \"2\", {a: \"b\", c: 10}]; delete(out[2], \"c\")`, nil,\n\t\tARR{1, \"2\", MAP{\"a\": \"b\"}})\n\n\t// splice\n\texpectError(t, `splice()`, nil, tengo.ErrWrongNumArguments.Error())\n\texpectError(t, `splice(1)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `splice(1.0)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `splice(\"str\")`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `splice(bytes(\"str\"))`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice(error(\"err\"))`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice(true)`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `splice(char('c'))`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice(undefined)`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice(time(1257894000))`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice(immutable({}))`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice(immutable([]))`, nil,\n\t\t`invalid type for argument 'first'`)\n\texpectError(t, `splice({})`, nil, `invalid type for argument 'first'`)\n\texpectError(t, `splice([], 1.0)`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], \"str\")`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], bytes(\"str\"))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], error(\"error\"))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], false)`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], char('d'))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], undefined)`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], time(0))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], [])`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], {})`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], immutable([]))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], immutable({}))`, nil,\n\t\t`invalid type for argument 'second'`)\n\texpectError(t, `splice([], 0, 1.0)`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, \"string\")`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, bytes(\"string\"))`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, error(\"string\"))`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, true)`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, char('f'))`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, undefined)`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, time(0))`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, [])`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, {})`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, immutable([]))`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 0, immutable({}))`, nil,\n\t\t`invalid type for argument 'third'`)\n\texpectError(t, `splice([], 1)`, nil, tengo.ErrIndexOutOfBounds.Error())\n\texpectError(t, `splice([1, 2, 3], 0, -1)`, nil,\n\t\ttengo.ErrIndexOutOfBounds.Error())\n\texpectError(t, `splice([1, 2, 3], 99, 0, \"a\", \"b\")`, nil,\n\t\ttengo.ErrIndexOutOfBounds.Error())\n\texpectRun(t, `out = []; splice(out)`, nil, ARR{})\n\texpectRun(t, `out = [\"a\"]; splice(out, 1)`, nil, ARR{\"a\"})\n\texpectRun(t, `out = [\"a\"]; out = splice(out, 1)`, nil, ARR{})\n\texpectRun(t, `out = [1, 2, 3]; splice(out, 0, 1)`, nil, ARR{2, 3})\n\texpectRun(t, `out = [1, 2, 3]; out = splice(out, 0, 1)`, nil, ARR{1})\n\texpectRun(t, `out = [1, 2, 3]; splice(out, 0, 0, \"a\", \"b\")`, nil,\n\t\tARR{\"a\", \"b\", 1, 2, 3})\n\texpectRun(t, `out = [1, 2, 3]; out = splice(out, 0, 0, \"a\", \"b\")`, nil,\n\t\tARR{})\n\texpectRun(t, `out = [1, 2, 3]; splice(out, 1, 0, \"a\", \"b\")`, nil,\n\t\tARR{1, \"a\", \"b\", 2, 3})\n\texpectRun(t, `out = [1, 2, 3]; out = splice(out, 1, 0, \"a\", \"b\")`, nil,\n\t\tARR{})\n\texpectRun(t, `out = [1, 2, 3]; splice(out, 1, 0, \"a\", \"b\")`, nil,\n\t\tARR{1, \"a\", \"b\", 2, 3})\n\texpectRun(t, `out = [1, 2, 3]; splice(out, 2, 0, \"a\", \"b\")`, nil,\n\t\tARR{1, 2, \"a\", \"b\", 3})\n\texpectRun(t, `out = [1, 2, 3]; splice(out, 3, 0, \"a\", \"b\")`, nil,\n\t\tARR{1, 2, 3, \"a\", \"b\"})\n\texpectRun(t, `array := [1, 2, 3]; deleted := splice(array, 1, 1, \"a\", \"b\");\n\t\t\t\tout = [deleted, array]`, nil, ARR{ARR{2}, ARR{1, \"a\", \"b\", 3}})\n\texpectRun(t, `array := [1, 2, 3]; deleted := splice(array, 1); \n\t\tout = [deleted, array]`, nil, ARR{ARR{2, 3}, ARR{1}})\n\texpectRun(t, `out = []; splice(out, 0, 0, \"a\", \"b\")`, nil, ARR{\"a\", \"b\"})\n\texpectRun(t, `out = []; splice(out, 0, 1, \"a\", \"b\")`, nil, ARR{\"a\", \"b\"})\n\texpectRun(t, `out = []; out = splice(out, 0, 0, \"a\", \"b\")`, nil, ARR{})\n\texpectRun(t, `out = splice(splice([1, 2, 3], 0, 3), 1, 3)`, nil, ARR{2, 3})\n\t// splice doc examples\n\texpectRun(t, `v := [1, 2, 3]; deleted := splice(v, 0);\n\t\tout = [deleted, v]`, nil, ARR{ARR{1, 2, 3}, ARR{}})\n\texpectRun(t, `v := [1, 2, 3]; deleted := splice(v, 1);\n\t\tout = [deleted, v]`, nil, ARR{ARR{2, 3}, ARR{1}})\n\texpectRun(t, `v := [1, 2, 3]; deleted := splice(v, 0, 1);\n\t\tout = [deleted, v]`, nil, ARR{ARR{1}, ARR{2, 3}})\n\texpectRun(t, `v := [\"a\", \"b\", \"c\"]; deleted := splice(v, 1, 2);\n\t\tout = [deleted, v]`, nil, ARR{ARR{\"b\", \"c\"}, ARR{\"a\"}})\n\texpectRun(t, `v := [\"a\", \"b\", \"c\"]; deleted := splice(v, 2, 1, \"d\");\n\t\tout = [deleted, v]`, nil, ARR{ARR{\"c\"}, ARR{\"a\", \"b\", \"d\"}})\n\texpectRun(t, `v := [\"a\", \"b\", \"c\"]; deleted := splice(v, 0, 0, \"d\", \"e\");\n\t\tout = [deleted, v]`, nil, ARR{ARR{}, ARR{\"d\", \"e\", \"a\", \"b\", \"c\"}})\n\texpectRun(t, `v := [\"a\", \"b\", \"c\"]; deleted := splice(v, 1, 1, \"d\", \"e\");\n\t\tout = [deleted, v]`, nil, ARR{ARR{\"b\"}, ARR{\"a\", \"d\", \"e\", \"c\"}})\n}\n\nfunc TestBytesN(t *testing.T) {\n\tcurMaxBytesLen := tengo.MaxBytesLen\n\tdefer func() { tengo.MaxBytesLen = curMaxBytesLen }()\n\ttengo.MaxBytesLen = 10\n\n\texpectRun(t, `out = bytes(0)`, nil, make([]byte, 0))\n\texpectRun(t, `out = bytes(10)`, nil, make([]byte, 10))\n\texpectError(t, `bytes(11)`, nil, \"bytes size limit\")\n\n\ttengo.MaxBytesLen = 1000\n\texpectRun(t, `out = bytes(1000)`, nil, make([]byte, 1000))\n\texpectError(t, `bytes(1001)`, nil, \"bytes size limit\")\n}\n\nfunc TestBytes(t *testing.T) {\n\texpectRun(t, `out = bytes(\"Hello World!\")`, nil, []byte(\"Hello World!\"))\n\texpectRun(t, `out = bytes(\"Hello\") + bytes(\" \") + bytes(\"World!\")`,\n\t\tnil, []byte(\"Hello World!\"))\n\n\t// bytes[] -> int\n\texpectRun(t, `out = bytes(\"abcde\")[0]`, nil, 97)\n\texpectRun(t, `out = bytes(\"abcde\")[1]`, nil, 98)\n\texpectRun(t, `out = bytes(\"abcde\")[4]`, nil, 101)\n\texpectRun(t, `out = bytes(\"abcde\")[10]`, nil, tengo.UndefinedValue)\n}\n\nfunc TestCall(t *testing.T) {\n\texpectRun(t, `a := { b: func(x) { return x + 2 } }; out = a.b(5)`,\n\t\tnil, 7)\n\texpectRun(t, `a := { b: { c: func(x) { return x + 2 } } }; out = a.b.c(5)`,\n\t\tnil, 7)\n\texpectRun(t, `a := { b: { c: func(x) { return x + 2 } } }; out = a[\"b\"].c(5)`,\n\t\tnil, 7)\n\texpectError(t, `a := 1\nb := func(a, c) {\n   c(a)\n}\n\nc := func(a) {\n   a()\n}\nb(a, c)\n`, nil, \"Runtime Error: not callable: int\\n\\tat test:7:4\\n\\tat test:3:4\\n\\tat test:9:1\")\n}\n\nfunc TestChar(t *testing.T) {\n\texpectRun(t, `out = 'a'`, nil, 'a')\n\texpectRun(t, `out = ''`, nil, rune(20061))\n\texpectRun(t, `out = ''`, nil, rune(198))\n\n\texpectRun(t, `out = '0' + '9'`, nil, rune(105))\n\texpectRun(t, `out = '0' + 9`, nil, '9')\n\texpectRun(t, `out = '9' - 4`, nil, '5')\n\texpectRun(t, `out = '0' == '0'`, nil, true)\n\texpectRun(t, `out = '0' != '0'`, nil, false)\n\texpectRun(t, `out = '2' < '4'`, nil, true)\n\texpectRun(t, `out = '2' > '4'`, nil, false)\n\texpectRun(t, `out = '2' <= '4'`, nil, true)\n\texpectRun(t, `out = '2' >= '4'`, nil, false)\n\texpectRun(t, `out = '4' < '4'`, nil, false)\n\texpectRun(t, `out = '4' > '4'`, nil, false)\n\texpectRun(t, `out = '4' <= '4'`, nil, true)\n\texpectRun(t, `out = '4' >= '4'`, nil, true)\n}\n\nfunc TestCondExpr(t *testing.T) {\n\texpectRun(t, `out = true ? 5 : 10`, nil, 5)\n\texpectRun(t, `out = false ? 5 : 10`, nil, 10)\n\texpectRun(t, `out = (1 == 1) ? 2 + 3 : 12 - 2`, nil, 5)\n\texpectRun(t, `out = (1 != 1) ? 2 + 3 : 12 - 2`, nil, 10)\n\texpectRun(t, `out = (1 == 1) ? true ? 10 - 8 : 1 + 3 : 12 - 2`, nil, 2)\n\texpectRun(t, `out = (1 == 1) ? false ? 10 - 8 : 1 + 3 : 12 - 2`, nil, 4)\n\n\texpectRun(t, `\nout = 0\nf1 := func() { out += 10 }\nf2 := func() { out = -out }\ntrue ? f1() : f2()\n`, nil, 10)\n\texpectRun(t, `\nout = 5\nf1 := func() { out += 10 }\nf2 := func() { out = -out }\nfalse ? f1() : f2()\n`, nil, -5)\n\texpectRun(t, `\nf1 := func(a) { return a + 2 }\nf2 := func(a) { return a - 2 }\nf3 := func(a) { return a + 10 }\nf4 := func(a) { return -a }\n\nf := func(c) {\n\treturn c == 0 ? f1(c) : f2(c) ? f3(c) : f4(c)\n}\n\nout = [f(0), f(1), f(2)]\n`, nil, ARR{2, 11, -2})\n\n\texpectRun(t, `f := func(a) { return -a }; out = f(true ? 5 : 3)`, nil, -5)\n\texpectRun(t, `out = [false?5:10, true?1:2]`, nil, ARR{10, 1})\n\n\texpectRun(t, `\nout = 1 > 2 ?\n\t1 + 2 + 3 :\n\t10 - 5`, nil, 5)\n}\n\nfunc TestEquality(t *testing.T) {\n\ttestEquality(t, `1`, `1`, true)\n\ttestEquality(t, `1`, `2`, false)\n\n\ttestEquality(t, `1.0`, `1.0`, true)\n\ttestEquality(t, `1.0`, `1.1`, false)\n\n\ttestEquality(t, `true`, `true`, true)\n\ttestEquality(t, `true`, `false`, false)\n\n\ttestEquality(t, `\"foo\"`, `\"foo\"`, true)\n\ttestEquality(t, `\"foo\"`, `\"bar\"`, false)\n\n\ttestEquality(t, `'f'`, `'f'`, true)\n\ttestEquality(t, `'f'`, `'b'`, false)\n\n\ttestEquality(t, `[]`, `[]`, true)\n\ttestEquality(t, `[1]`, `[1]`, true)\n\ttestEquality(t, `[1]`, `[1, 2]`, false)\n\ttestEquality(t, `[\"foo\", \"bar\"]`, `[\"foo\", \"bar\"]`, true)\n\ttestEquality(t, `[\"foo\", \"bar\"]`, `[\"bar\", \"foo\"]`, false)\n\n\ttestEquality(t, `{}`, `{}`, true)\n\ttestEquality(t, `{a: 1, b: 2}`, `{b: 2, a: 1}`, true)\n\ttestEquality(t, `{a: 1, b: 2}`, `{b: 2}`, false)\n\ttestEquality(t, `{a: 1, b: {}}`, `{b: {}, a: 1}`, true)\n\n\ttestEquality(t, `1`, `\"foo\"`, false)\n\ttestEquality(t, `1`, `true`, false)\n\ttestEquality(t, `[1]`, `[\"1\"]`, false)\n\ttestEquality(t, `[1, [2]]`, `[1, [\"2\"]]`, false)\n\ttestEquality(t, `{a: 1}`, `{a: \"1\"}`, false)\n\ttestEquality(t, `{a: 1, b: {c: 2}}`, `{a: 1, b: {c: \"2\"}}`, false)\n}\n\nfunc testEquality(t *testing.T, lhs, rhs string, expected bool) {\n\t// 1. equality is commutative\n\t// 2. equality and inequality must be always opposite\n\texpectRun(t, fmt.Sprintf(\"out = %s == %s\", lhs, rhs), nil, expected)\n\texpectRun(t, fmt.Sprintf(\"out = %s == %s\", rhs, lhs), nil, expected)\n\texpectRun(t, fmt.Sprintf(\"out = %s != %s\", lhs, rhs), nil, !expected)\n\texpectRun(t, fmt.Sprintf(\"out = %s != %s\", rhs, lhs), nil, !expected)\n}\n\nfunc TestVMErrorInfo(t *testing.T) {\n\texpectError(t, `a := 5\na + \"boo\"`,\n\t\tnil, \"Runtime Error: invalid operation: int + string\\n\\tat test:2:1\")\n\n\texpectError(t, `a := 5\nb := a(5)`,\n\t\tnil, \"Runtime Error: not callable: int\\n\\tat test:2:6\")\n\n\texpectError(t, `a := 5\nb := {}\nb.x.y = 10`,\n\t\tnil, \"Runtime Error: not index-assignable: undefined\\n\\tat test:3:1\")\n\n\texpectError(t, `\na := func() {\n\tb := 5\n\tb += \"foo\"\n}\na()`,\n\t\tnil, \"Runtime Error: invalid operation: int + string\\n\\tat test:4:2\")\n\n\texpectError(t, `a := 5\na + import(\"mod1\")`, Opts().Module(\n\t\t\"mod1\", `export \"foo\"`,\n\t), \": invalid operation: int + string\\n\\tat test:2:1\")\n\n\texpectError(t, `a := import(\"mod1\")()`,\n\t\tOpts().Module(\n\t\t\t\"mod1\", `\nexport func() {\n\tb := 5\n\treturn b + \"foo\"\n}`), \"Runtime Error: invalid operation: int + string\\n\\tat mod1:4:9\")\n\n\texpectError(t, `a := import(\"mod1\")()`,\n\t\tOpts().Module(\n\t\t\t\"mod1\", `export import(\"mod2\")()`).\n\t\t\tModule(\n\t\t\t\t\"mod2\", `\nexport func() {\n\tb := 5\n\treturn b + \"foo\"\n}`), \"Runtime Error: invalid operation: int + string\\n\\tat mod2:4:9\")\n\n\texpectError(t, `a := [1, 2, 3]; b := a[:\"invalid\"];`, nil,\n\t\t\"Runtime Error: invalid slice index type: string\")\n\texpectError(t, `a := immutable([4, 5, 6]); b := a[:false];`, nil,\n\t\t\"Runtime Error: invalid slice index type: bool\")\n\texpectError(t, `a := \"hello\"; b := a[:1.23];`, nil,\n\t\t\"Runtime Error: invalid slice index type: float\")\n\texpectError(t, `a := bytes(\"world\"); b := a[:time(1)];`, nil,\n\t\t\"Runtime Error: invalid slice index type: time\")\n}\n\nfunc TestVMErrorUnwrap(t *testing.T) {\n\tuserErr := errors.New(\"user runtime error\")\n\tuserFunc := func(err error) *tengo.UserFunction {\n\t\treturn &tengo.UserFunction{Name: \"user_func\", Value: func(args ...tengo.Object) (tengo.Object, error) {\n\t\t\treturn nil, err\n\t\t}}\n\t}\n\tuserModule := func(err error) *tengo.BuiltinModule {\n\t\treturn &tengo.BuiltinModule{\n\t\t\tAttrs: map[string]tengo.Object{\n\t\t\t\t\"afunction\": &tengo.UserFunction{\n\t\t\t\t\tName: \"afunction\",\n\t\t\t\t\tValue: func(a ...tengo.Object) (tengo.Object, error) {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t}\n\n\texpectError(t, `user_func()`,\n\t\tOpts().Symbol(\"user_func\", userFunc(userErr)),\n\t\t\"Runtime Error: \"+userErr.Error(),\n\t)\n\texpectErrorIs(t, `user_func()`,\n\t\tOpts().Symbol(\"user_func\", userFunc(userErr)),\n\t\tuserErr,\n\t)\n\n\twrapUserErr := &customError{err: userErr, str: \"custom error\"}\n\n\texpectErrorIs(t, `user_func()`,\n\t\tOpts().Symbol(\"user_func\", userFunc(wrapUserErr)),\n\t\twrapUserErr,\n\t)\n\texpectErrorIs(t, `user_func()`,\n\t\tOpts().Symbol(\"user_func\", userFunc(wrapUserErr)),\n\t\tuserErr,\n\t)\n\tvar asErr1 *customError\n\texpectErrorAs(t, `user_func()`,\n\t\tOpts().Symbol(\"user_func\", userFunc(wrapUserErr)),\n\t\t&asErr1,\n\t)\n\trequire.True(t, asErr1.Error() == wrapUserErr.Error(),\n\t\t\"expected error as:%v, got:%v\", wrapUserErr, asErr1)\n\n\texpectError(t, `import(\"mod1\").afunction()`,\n\t\tOpts().Module(\"mod1\", userModule(userErr)),\n\t\t\"Runtime Error: \"+userErr.Error(),\n\t)\n\texpectErrorIs(t, `import(\"mod1\").afunction()`,\n\t\tOpts().Module(\"mod1\", userModule(userErr)),\n\t\tuserErr,\n\t)\n\texpectError(t, `import(\"mod1\").afunction()`,\n\t\tOpts().Module(\"mod1\", userModule(wrapUserErr)),\n\t\t\"Runtime Error: \"+wrapUserErr.Error(),\n\t)\n\texpectErrorIs(t, `import(\"mod1\").afunction()`,\n\t\tOpts().Module(\"mod1\", userModule(wrapUserErr)),\n\t\twrapUserErr,\n\t)\n\texpectErrorIs(t, `import(\"mod1\").afunction()`,\n\t\tOpts().Module(\"mod1\", userModule(wrapUserErr)),\n\t\tuserErr,\n\t)\n\tvar asErr2 *customError\n\texpectErrorAs(t, `import(\"mod1\").afunction()`,\n\t\tOpts().Module(\"mod1\", userModule(wrapUserErr)),\n\t\t&asErr2,\n\t)\n\trequire.True(t, asErr2.Error() == wrapUserErr.Error(),\n\t\t\"expected error as:%v, got:%v\", wrapUserErr, asErr2)\n}\n\nfunc TestError(t *testing.T) {\n\texpectRun(t, `out = error(1)`, nil, errorObject(1))\n\texpectRun(t, `out = error(1).value`, nil, 1)\n\texpectRun(t, `out = error(\"some error\")`, nil, errorObject(\"some error\"))\n\texpectRun(t, `out = error(\"some\" + \" error\")`, nil, errorObject(\"some error\"))\n\texpectRun(t, `out = func() { return error(5) }()`, nil, errorObject(5))\n\texpectRun(t, `out = error(error(\"foo\"))`, nil, errorObject(errorObject(\"foo\")))\n\texpectRun(t, `out = error(\"some error\")`, nil, errorObject(\"some error\"))\n\texpectRun(t, `out = error(\"some error\").value`, nil, \"some error\")\n\texpectRun(t, `out = error(\"some error\")[\"value\"]`, nil, \"some error\")\n\n\texpectError(t, `error(\"error\").err`, nil, \"invalid index on error\")\n\texpectError(t, `error(\"error\").value_`, nil, \"invalid index on error\")\n\texpectError(t, `error([1,2,3])[1]`, nil, \"invalid index on error\")\n}\n\nfunc TestFloat(t *testing.T) {\n\texpectRun(t, `out = 0.0`, nil, 0.0)\n\texpectRun(t, `out = -10.3`, nil, -10.3)\n\texpectRun(t, `out = 3.2 + 2.0 * -4.0`, nil, -4.8)\n\texpectRun(t, `out = 4 + 2.3`, nil, 6.3)\n\texpectRun(t, `out = 2.3 + 4`, nil, 6.3)\n\texpectRun(t, `out = +5.0`, nil, 5.0)\n\texpectRun(t, `out = -5.0 + +5.0`, nil, 0.0)\n}\n\nfunc TestForIn(t *testing.T) {\n\t// array\n\texpectRun(t, `out = 0; for x in [1, 2, 3] { out += x }`,\n\t\tnil, 6) // value\n\texpectRun(t, `out = 0; for i, x in [1, 2, 3] { out += i + x }`,\n\t\tnil, 9) // index, value\n\texpectRun(t, `out = 0; func() { for i, x in [1, 2, 3] { out += i + x } }()`,\n\t\tnil, 9) // index, value\n\texpectRun(t, `out = 0; for i, _ in [1, 2, 3] { out += i }`,\n\t\tnil, 3) // index, _\n\texpectRun(t, `out = 0; func() { for i, _ in [1, 2, 3] { out += i  } }()`,\n\t\tnil, 3) // index, _\n\n\t// map\n\texpectRun(t, `out = 0; for v in {a:2,b:3,c:4} { out += v }`,\n\t\tnil, 9) // value\n\texpectRun(t, `out = \"\"; for k, v in {a:2,b:3,c:4} { out = k; if v==3 { break } }`,\n\t\tnil, \"b\") // key, value\n\texpectRun(t, `out = \"\"; for k, _ in {a:2} { out += k }`,\n\t\tnil, \"a\") // key, _\n\texpectRun(t, `out = 0; for _, v in {a:2,b:3,c:4} { out += v }`,\n\t\tnil, 9) // _, value\n\texpectRun(t, `out = \"\"; func() { for k, v in {a:2,b:3,c:4} { out = k; if v==3 { break } } }()`,\n\t\tnil, \"b\") // key, value\n\n\t// string\n\texpectRun(t, `out = \"\"; for c in \"abcde\" { out += c }`,\n\t\tnil, \"abcde\")\n\texpectRun(t, `out = \"\"; for i, c in \"abcde\" { if i == 2 { continue }; out += c }`,\n\t\tnil, \"abde\")\n}\n\nfunc TestFor(t *testing.T) {\n\texpectRun(t, `\n\tout = 0\n\tfor {\n\t\tout++\n\t\tif out == 5 {\n\t\t\tbreak\n\t\t}\n\t}`, nil, 5)\n\n\texpectRun(t, `\n\tout = 0\n\tfor {\n\t\tout++\n\t\tif out == 5 {\n\t\t\tbreak\n\t\t}\n\t}`, nil, 5)\n\n\texpectRun(t, `\n\tout = 0\n\ta := 0\n\tfor {\n\t\ta++\n\t\tif a == 3 { continue }\n\t\tif a == 5 { break }\n\t\tout += a\n\t}`, nil, 7) // 1 + 2 + 4\n\n\texpectRun(t, `\n\tout = 0\n\ta := 0\n\tfor {\n\t\ta++\n\t\tif a == 3 { continue }\n\t\tout += a\n\t\tif a == 5 { break }\n\t}`, nil, 12) // 1 + 2 + 4 + 5\n\n\texpectRun(t, `\n\tout = 0\n\tfor true {\n\t\tout++\n\t\tif out == 5 {\n\t\t\tbreak\n\t\t}\n\t}`, nil, 5)\n\n\texpectRun(t, `\n\ta := 0\n\tfor true {\n\t\ta++\n\t\tif a == 5 {\n\t\t\tbreak\n\t\t}\n\t}\n\tout = a`, nil, 5)\n\n\texpectRun(t, `\n\tout = 0\n\ta := 0\n\tfor true {\n\t\ta++\n\t\tif a == 3 { continue }\n\t\tif a == 5 { break }\n\t\tout += a\n\t}`, nil, 7) // 1 + 2 + 4\n\n\texpectRun(t, `\n\tout = 0\n\ta := 0\n\tfor true {\n\t\ta++\n\t\tif a == 3 { continue }\n\t\tout += a\n\t\tif a == 5 { break }\n\t}`, nil, 12) // 1 + 2 + 4 + 5\n\n\texpectRun(t, `\n\tout = 0\n\tfunc() {\n\t\tfor true {\n\t\t\tout++\n\t\t\tif out == 5 {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = 0\n\tfor a:=1; a<=10; a++ {\n\t\tout += a\n\t}`, nil, 55)\n\n\texpectRun(t, `\n\tout = 0\n\tfor a:=1; a<=3; a++ {\n\t\tfor b:=3; b<=6; b++ {\n\t\t\tout += b\n\t\t}\n\t}`, nil, 54)\n\n\texpectRun(t, `\n\tout = 0\n\tfunc() {\n\t\tfor {\n\t\t\tout++\n\t\t\tif out == 5 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = 0\n\tfunc() {\n\t\tfor true {\n\t\t\tout++\n\t\t\tif out == 5 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = func() {\n\t\ta := 0\n\t\tfor {\n\t\t\ta++\n\t\t\tif a == 5 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn a\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = func() {\n\t\ta := 0\n\t\tfor true {\n\t\t\ta++\n\t\t\tif a== 5 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\treturn a\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = func() {\n\t\ta := 0\n\t\tfunc() {\n\t\t\tfor {\n\t\t\t\ta++\n\t\t\t\tif a == 5 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\treturn a\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = func() {\n\t\ta := 0\n\t\tfunc() {\n\t\t\tfor true {\n\t\t\t\ta++\n\t\t\t\tif a == 5 {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\treturn a\n\t}()`, nil, 5)\n\n\texpectRun(t, `\n\tout = func() {\n\t\tsum := 0\n\t\tfor a:=1; a<=10; a++ {\n\t\t\tsum += a\n\t\t}\n\t\treturn sum\n\t}()`, nil, 55)\n\n\texpectRun(t, `\n\tout = func() {\n\t\tsum := 0\n\t\tfor a:=1; a<=4; a++ {\n\t\t\tfor b:=3; b<=5; b++ {\n\t\t\t\tsum += b\n\t\t\t}\n\t\t}\n\t\treturn sum\n\t}()`, nil, 48) // (3+4+5) * 4\n\n\texpectRun(t, `\n\ta := 1\n\tfor ; a<=10; a++ {\n\t\tif a == 5 {\n\t\t\tbreak\n\t\t}\n\t}\n\tout = a`, nil, 5)\n\n\texpectRun(t, `\n\tout = 0\n\tfor a:=1; a<=10; a++ {\n\t\tif a == 3 {\n\t\t\tcontinue\n\t\t}\n\t\tout += a\n\t\tif a == 5 {\n\t\t\tbreak\n\t\t}\n\t}`, nil, 12) // 1 + 2 + 4 + 5\n\n\texpectRun(t, `\n\tout = 0\n\tfor a:=1; a<=10; {\n\t\tif a == 3 {\n\t\t\ta++\n\t\t\tcontinue\n\t\t}\n\t\tout += a\n\t\tif a == 5 {\n\t\t\tbreak\n\t\t}\n\t\ta++\n\t}`, nil, 12) // 1 + 2 + 4 + 5\n}\n\nfunc TestFunction(t *testing.T) {\n\t// function with no \"return\" statement returns \"invalid\" value.\n\texpectRun(t, `f1 := func() {}; out = f1();`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `f1 := func() {}; f2 := func() { return f1(); }; f1(); out = f2();`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `f := func(x) { x; }; out = f(5);`,\n\t\tnil, tengo.UndefinedValue)\n\n\texpectRun(t, `f := func(...x) { return x; }; out = f(1,2,3);`,\n\t\tnil, ARR{1, 2, 3})\n\n\texpectRun(t, `f := func(a, b, ...x) { return [a, b, x]; }; out = f(8,9,1,2,3);`,\n\t\tnil, ARR{8, 9, ARR{1, 2, 3}})\n\n\texpectRun(t, `f := func(v) { x := 2; return func(a, ...b){ return [a, b, v+x]}; }; out = f(5)(\"a\", \"b\");`,\n\t\tnil, ARR{\"a\", ARR{\"b\"}, 7})\n\n\texpectRun(t, `f := func(...x) { return x; }; out = f();`,\n\t\tnil, &tengo.Array{Value: []tengo.Object{}})\n\n\texpectRun(t, `f := func(a, b, ...x) { return [a, b, x]; }; out = f(8, 9);`,\n\t\tnil, ARR{8, 9, ARR{}})\n\n\texpectRun(t, `f := func(v) { x := 2; return func(a, ...b){ return [a, b, v+x]}; }; out = f(5)(\"a\");`,\n\t\tnil, ARR{\"a\", ARR{}, 7})\n\n\texpectError(t, `f := func(a, b, ...x) { return [a, b, x]; }; f();`, nil,\n\t\t\"Runtime Error: wrong number of arguments: want>=2, got=0\\n\\tat test:1:46\")\n\n\texpectError(t, `f := func(a, b, ...x) { return [a, b, x]; }; f(1);`, nil,\n\t\t\"Runtime Error: wrong number of arguments: want>=2, got=1\\n\\tat test:1:46\")\n\n\texpectRun(t, `f := func(x) { return x; }; out = f(5);`, nil, 5)\n\texpectRun(t, `f := func(x) { return x * 2; }; out = f(5);`, nil, 10)\n\texpectRun(t, `f := func(x, y) { return x + y; }; out = f(5, 5);`, nil, 10)\n\texpectRun(t, `f := func(x, y) { return x + y; }; out = f(5 + 5, f(5, 5));`,\n\t\tnil, 20)\n\texpectRun(t, `out = func(x) { return x; }(5)`, nil, 5)\n\texpectRun(t, `x := 10; f := func(x) { return x; }; f(5); out = x;`, nil, 10)\n\n\texpectRun(t, `\n\tf2 := func(a) {\n\t\tf1 := func(a) {\n\t\t\treturn a * 2;\n\t\t};\n\t\n\t\treturn f1(a) * 3;\n\t};\n\t\n\tout = f2(10);\n\t`, nil, 60)\n\n\texpectRun(t, `\n\t\tf1 := func(f) {\n\t\t\ta := [undefined]\n\t\t\ta[0] = func() { return f(a) }\n\t\t\treturn a[0]()\n\t\t}\n\n\t\tout = f1(func(a) { return 2 })\n\t`, nil, 2)\n\n\t// closures\n\texpectRun(t, `\n\t\tnewAdder := func(x) {\n\t\t\treturn func(y) { return x + y };\n\t\t};\n\t\n\t\tadd2 := newAdder(2);\n\t\tout = add2(5);\n\t\t`, nil, 7)\n\texpectRun(t, `\n\t\tm := {a: 1}\n\t\tfor k,v in m {\n\t\t\tfunc(){\n\t\t\t\tout = k\n\t\t\t}()\n\t\t}\n\t\t`, nil, \"a\")\n\n\texpectRun(t, `\n\t\tm := {a: 1}\n\t\tfor k,v in m {\n\t\t\tfunc(){\n\t\t\t\tout = v\n\t\t\t}()\n\t\t}\n\t\t`, nil, 1)\n\t// function as a argument\n\texpectRun(t, `\n\tadd := func(a, b) { return a + b };\n\tsub := func(a, b) { return a - b };\n\tapplyFunc := func(a, b, f) { return f(a, b) };\n\t\n\tout = applyFunc(applyFunc(2, 2, add), 3, sub);\n\t`, nil, 1)\n\n\texpectRun(t, `f1 := func() { return 5 + 10; }; out = f1();`,\n\t\tnil, 15)\n\texpectRun(t, `f1 := func() { return 1 }; f2 := func() { return 2 }; out = f1() + f2()`,\n\t\tnil, 3)\n\texpectRun(t, `f1 := func() { return 1 }; f2 := func() { return f1() + 2 }; f3 := func() { return f2() + 3 }; out = f3()`,\n\t\tnil, 6)\n\texpectRun(t, `f1 := func() { return 99; 100 }; out = f1();`,\n\t\tnil, 99)\n\texpectRun(t, `f1 := func() { return 99; return 100 }; out = f1();`,\n\t\tnil, 99)\n\texpectRun(t, `f1 := func() { return 33; }; f2 := func() { return f1 }; out = f2()();`,\n\t\tnil, 33)\n\texpectRun(t, `one := func() { one = 1; return one }; out = one()`,\n\t\tnil, 1)\n\texpectRun(t, `three := func() { one := 1; two := 2; return one + two }; out = three()`,\n\t\tnil, 3)\n\texpectRun(t, `three := func() { one := 1; two := 2; return one + two }; seven := func() { three := 3; four := 4; return three + four }; out = three() + seven()`,\n\t\tnil, 10)\n\texpectRun(t, `\n\tfoo1 := func() {\n\t\tfoo := 50\n\t\treturn foo\n\t}\n\tfoo2 := func() {\n\t\tfoo := 100\n\t\treturn foo\n\t}\n\tout = foo1() + foo2()`, nil, 150)\n\texpectRun(t, `\n\tg := 50;\n\tminusOne := func() {\n\t\tn := 1;\n\t\treturn g - n;\n\t};\n\tminusTwo := func() {\n\t\tn := 2;\n\t\treturn g - n;\n\t};\n\tout = minusOne() + minusTwo()\n\t`, nil, 97)\n\texpectRun(t, `\n\tf1 := func() {\n\t\tf2 := func() { return 1; }\n\t\treturn f2\n\t};\n\tout = f1()()\n\t`, nil, 1)\n\n\texpectRun(t, `\n\tf1 := func(a) { return a; };\n\tout = f1(4)`, nil, 4)\n\texpectRun(t, `\n\tf1 := func(a, b) { return a + b; };\n\tout = f1(1, 2)`, nil, 3)\n\n\texpectRun(t, `\n\tsum := func(a, b) {\n\t\tc := a + b;\n\t\treturn c;\n\t};\n\tout = sum(1, 2);`, nil, 3)\n\n\texpectRun(t, `\n\tsum := func(a, b) {\n\t\tc := a + b;\n\t\treturn c;\n\t};\n\tout = sum(1, 2) + sum(3, 4);`, nil, 10)\n\n\texpectRun(t, `\n\tsum := func(a, b) {\n\t\tc := a + b\n\t\treturn c\n\t};\n\touter := func() {\n\t\treturn sum(1, 2) + sum(3, 4)\n\t};\n\tout = outer();`, nil, 10)\n\n\texpectRun(t, `\n\tg := 10;\n\t\n\tsum := func(a, b) {\n\t\tc := a + b;\n\t\treturn c + g;\n\t}\n\t\n\touter := func() {\n\t\treturn sum(1, 2) + sum(3, 4) + g;\n\t}\n\t\n\tout = outer() + g\n\t`, nil, 50)\n\n\texpectError(t, `func() { return 1; }(1)`,\n\t\tnil, \"wrong number of arguments\")\n\texpectError(t, `func(a) { return a; }()`,\n\t\tnil, \"wrong number of arguments\")\n\texpectError(t, `func(a, b) { return a + b; }(1)`,\n\t\tnil, \"wrong number of arguments\")\n\n\texpectRun(t, `\n\t\tf1 := func(a) {\n\t\t\treturn func() { return a; };\n\t\t};\n\t\tf2 := f1(99);\n\t\tout = f2()\n\t\t`, nil, 99)\n\n\texpectRun(t, `\n\t\tf1 := func(a, b) {\n\t\t\treturn func(c) { return a + b + c };\n\t\t};\n\t\n\t\tf2 := f1(1, 2);\n\t\tout = f2(8);\n\t\t`, nil, 11)\n\texpectRun(t, `\n\t\tf1 := func(a, b) {\n\t\t\tc := a + b;\n\t\t\treturn func(d) { return c + d };\n\t\t};\n\t\tf2 := f1(1, 2);\n\t\tout = f2(8);\n\t\t`, nil, 11)\n\texpectRun(t, `\n\t\tf1 := func(a, b) {\n\t\t\tc := a + b;\n\t\t\treturn func(d) {\n\t\t\t\te := d + c;\n\t\t\t\treturn func(f) { return e + f };\n\t\t\t}\n\t\t};\n\t\tf2 := f1(1, 2);\n\t\tf3 := f2(3);\n\t\tout = f3(8);\n\t\t`, nil, 14)\n\texpectRun(t, `\n\t\ta := 1;\n\t\tf1 := func(b) {\n\t\t\treturn func(c) {\n\t\t\t\treturn func(d) { return a + b + c + d }\n\t\t\t};\n\t\t};\n\t\tf2 := f1(2);\n\t\tf3 := f2(3);\n\t\tout = f3(8);\n\t\t`, nil, 14)\n\texpectRun(t, `\n\t\tf1 := func(a, b) {\n\t\t\tone := func() { return a; };\n\t\t\ttwo := func() { return b; };\n\t\t\treturn func() { return one() + two(); }\n\t\t};\n\t\tf2 := f1(9, 90);\n\t\tout = f2();\n\t\t`, nil, 99)\n\n\t// global function recursion\n\texpectRun(t, `\n\t\tfib := func(x) {\n\t\t\tif x == 0 {\n\t\t\t\treturn 0\n\t\t\t} else if x == 1 {\n\t\t\t\treturn 1\n\t\t\t} else {\n\t\t\t\treturn fib(x-1) + fib(x-2)\n\t\t\t}\n\t\t}\n\t\tout = fib(15)`, nil, 610)\n\n\t// local function recursion\n\texpectRun(t, `\nout = func() {\n\tsum := func(x) {\n\t\treturn x == 0 ? 0 : x + sum(x-1)\n\t}\n\treturn sum(5)\n}()`, nil, 15)\n\n\texpectError(t, `return 5`, nil, \"return not allowed outside function\")\n\n\t// closure and block scopes\n\texpectRun(t, `\nfunc() {\n\ta := 10\n\tfunc() {\n\t\tb := 5\n\t\tif true {\n\t\t\tout = a + 5\n\t\t}\n\t}()\n}()`, nil, 15)\n\texpectRun(t, `\nfunc() {\n\ta := 10\n\tb := func() { return 5 }\n\tfunc() {\n\t\tif b() {\n\t\t\tout = a + b()\n\t\t}\n\t}()\n}()`, nil, 15)\n\texpectRun(t, `\nfunc() {\n\ta := 10\n\tfunc() {\n\t\tb := func() { return 5 }\n\t\tfunc() {\n\t\t\tif true {\n\t\t\t\tout = a + b()\n\t\t\t}\n\t\t}()\n\t}()\n}()`, nil, 15)\n\n\t// function skipping return\n\texpectRun(t, `out = func() {}()`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `out = func(v) { if v { return true } }(1)`,\n\t\tnil, true)\n\texpectRun(t, `out = func(v) { if v { return true } }(0)`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `out = func(v) { if v { } else { return true } }(1)`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `out = func(v) { if v { return } }(1)`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `out = func(v) { if v { return } }(0)`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `out = func(v) { if v { } else { return } }(1)`,\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, `out = func(v) { for ;;v++ { if v == 3 { return true } } }(1)`,\n\t\tnil, true)\n\texpectRun(t, `out = func(v) { for ;;v++ { if v == 3 { break } } }(1)`,\n\t\tnil, tengo.UndefinedValue)\n\n\t// 'f' in RHS at line 4 must reference global variable 'f'\n\t// See https://github.com/d5/tengo/issues/314\n\texpectRun(t, `\nf := func() { return 2 }\nout = (func() {\n\tf := f()\n\treturn f\n})()\n\t`, nil, 2)\n}\n\nfunc TestBlocksInGlobalScope(t *testing.T) {\n\texpectRun(t, `\nf := undefined\nif true {\n\ta := 1\n\tf = func() {\n\t\ta = 2\n\t}\n}\nb := 3\nf()\nout = b`,\n\t\tnil, 3)\n\n\texpectRun(t, `\nfunc() {\n\tf := undefined\n\tif true {\n\t\ta := 10\n\t\tf = func() {\n\t\t\ta = 20\n\t\t}\n\t}\n\tb := 5\n\tf()\n\tout = b\n}()\n\t`,\n\t\tnil, 5)\n\n\texpectRun(t, `\nf := undefined\nif true {\n\ta := 1\n\tb := 2\n\tf = func() {\n\t\ta = 3\n\t\tb = 4\n\t}\n}\nc := 5\nd := 6\nf()\nout = c + d`,\n\t\tnil, 11)\n\n\texpectRun(t, `\nfn := undefined\nif true {\n\ta := 1\n\tb := 2\n\tif true {\n\t\tc := 3\n\t\td := 4\n\t\tfn = func() {\n\t\t\ta = 5\n\t\t\tb = 6\n\t\t\tc = 7\n\t\t\td = 8\n\t\t}\n\t}\n}\ne := 9\nf := 10\nfn()\nout = e + f`,\n\t\tnil, 19)\n\n\texpectRun(t, `\nout = 0\nfunc() {\n\tfor x in [1, 2, 3] {\n\t\tout += x\n\t}\n}()`,\n\t\tnil, 6)\n\n\texpectRun(t, `\nout = 0\nfor x in [1, 2, 3] {\n\tout += x\n}`,\n\t\tnil, 6)\n}\n\nfunc TestIf(t *testing.T) {\n\n\texpectRun(t, `if (true) { out = 10 }`, nil, 10)\n\texpectRun(t, `if (false) { out = 10 }`, nil, tengo.UndefinedValue)\n\texpectRun(t, `if (false) { out = 10 } else { out = 20 }`, nil, 20)\n\texpectRun(t, `if (1) { out = 10 }`, nil, 10)\n\texpectRun(t, `if (0) { out = 10 } else { out = 20 }`, nil, 20)\n\texpectRun(t, `if (1 < 2) { out = 10 }`, nil, 10)\n\texpectRun(t, `if (1 > 2) { out = 10 }`, nil, tengo.UndefinedValue)\n\texpectRun(t, `if (1 < 2) { out = 10 } else { out = 20 }`, nil, 10)\n\texpectRun(t, `if (1 > 2) { out = 10 } else { out = 20 }`, nil, 20)\n\n\texpectRun(t, `if (1 < 2) { out = 10 } else if (1 > 2) { out = 20 } else { out = 30 }`,\n\t\tnil, 10)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 < 2) { out = 20 } else { out = 30 }`,\n\t\tnil, 20)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 == 2) { out = 20 } else { out = 30 }`,\n\t\tnil, 30)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 == 2) { out = 20 } else if (1 < 2) { out = 30 } else { out = 40 }`,\n\t\tnil, 30)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 < 2) { out = 20; out = 21; out = 22 } else { out = 30 }`,\n\t\tnil, 22)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 == 2) { out = 20 } else { out = 30; out = 31; out = 32}`,\n\t\tnil, 32)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 < 2) { if (1 == 2) { out = 21 } else { out = 22 } } else { out = 30 }`,\n\t\tnil, 22)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 < 2) { if (1 == 2) { out = 21 } else if (2 == 3) { out = 22 } else { out = 23 } } else { out = 30 }`,\n\t\tnil, 23)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 == 2) { if (1 == 2) { out = 21 } else if (2 == 3) { out = 22 } else { out = 23 } } else { out = 30 }`,\n\t\tnil, 30)\n\texpectRun(t, `if (1 > 2) { out = 10 } else if (1 == 2) { out = 20 } else { if (1 == 2) { out = 31 } else if (2 == 3) { out = 32 } else { out = 33 } }`,\n\t\tnil, 33)\n\n\texpectRun(t, `if a:=0; a<1 { out = 10 }`, nil, 10)\n\texpectRun(t, `a:=0; if a++; a==1 { out = 10 }`, nil, 10)\n\texpectRun(t, `\nfunc() {\n\ta := 1\n\tif a++; a > 1 {\n\t\tout = a\n\t}\n}()\n`, nil, 2)\n\texpectRun(t, `\nfunc() {\n\ta := 1\n\tif a++; a == 1 {\n\t\tout = 10\n\t} else {\n\t\tout = 20\n\t}\n}()\n`, nil, 20)\n\texpectRun(t, `\nfunc() {\n\ta := 1\n\n\tfunc() {\n\t\tif a++; a > 1 {\n\t\t\ta++\n\t\t}\n\t}()\n\n\tout = a\n}()\n`, nil, 3)\n\n\t// expression statement in init (should not leave objects on stack)\n\texpectRun(t, `a := 1; if a; a { out = a }`, nil, 1)\n\texpectRun(t, `a := 1; if a + 4; a { out = a }`, nil, 1)\n\n\t// dead code elimination\n\texpectRun(t, `\nout = func() {\n\tif false { return 1 }\n\n\ta := undefined\n\n\ta = 2\n\tif !a {\n\t\tb := func() {\n\t\t\treturn is_callable(a) ? a(8) : a\n\t\t}()\n\t\tif is_error(b) { \n\t\t\treturn b \n\t\t} else if !is_undefined(b) { \n\t\t\treturn immutable(b)\n\t\t}\n\t}\n\t\n\ta = 3\n\tif a {\n\t\tb := func() {\n\t\t\treturn is_callable(a) ? a(9) : a\n\t\t}()\n\t\tif is_error(b) { \n\t\t\treturn b \n\t\t} else if !is_undefined(b) { \n\t\t\treturn immutable(b)\n\t\t}\n\t}\n\n\treturn a\n}()\n`, nil, 3)\n}\n\nfunc TestImmutable(t *testing.T) {\n\t// primitive types are already immutable values\n\t// immutable expression has no effects.\n\texpectRun(t, `a := immutable(1); out = a`, nil, 1)\n\texpectRun(t, `a := 5; b := immutable(a); out = b`, nil, 5)\n\texpectRun(t, `a := immutable(1); a = 5; out = a`, nil, 5)\n\n\t// array\n\texpectError(t, `a := immutable([1, 2, 3]); a[1] = 5`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `a := immutable([\"foo\", [1,2,3]]); a[1] = \"bar\"`,\n\t\tnil, \"not index-assignable\")\n\texpectRun(t, `a := immutable([\"foo\", [1,2,3]]); a[1][1] = \"bar\"; out = a`,\n\t\tnil, IARR{\"foo\", ARR{1, \"bar\", 3}})\n\texpectError(t, `a := immutable([\"foo\", immutable([1,2,3])]); a[1][1] = \"bar\"`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `a := [\"foo\", immutable([1,2,3])]; a[1][1] = \"bar\"`,\n\t\tnil, \"not index-assignable\")\n\texpectRun(t, `a := immutable([1,2,3]); b := copy(a); b[1] = 5; out = b`,\n\t\tnil, ARR{1, 5, 3})\n\texpectRun(t, `a := immutable([1,2,3]); b := copy(a); b[1] = 5; out = a`,\n\t\tnil, IARR{1, 2, 3})\n\texpectRun(t, `out = immutable([1,2,3]) == [1,2,3]`,\n\t\tnil, true)\n\texpectRun(t, `out = immutable([1,2,3]) == immutable([1,2,3])`,\n\t\tnil, true)\n\texpectRun(t, `out = [1,2,3] == immutable([1,2,3])`,\n\t\tnil, true)\n\texpectRun(t, `out = immutable([1,2,3]) == [1,2]`,\n\t\tnil, false)\n\texpectRun(t, `out = immutable([1,2,3]) == immutable([1,2])`,\n\t\tnil, false)\n\texpectRun(t, `out = [1,2,3] == immutable([1,2])`,\n\t\tnil, false)\n\texpectRun(t, `out = immutable([1, 2, 3, 4])[1]`,\n\t\tnil, 2)\n\texpectRun(t, `out = immutable([1, 2, 3, 4])[1:3]`,\n\t\tnil, ARR{2, 3})\n\texpectRun(t, `a := immutable([1,2,3]); a = 5; out = a`,\n\t\tnil, 5)\n\texpectRun(t, `a := immutable([1, 2, 3]); out = a[5]`,\n\t\tnil, tengo.UndefinedValue)\n\n\t// map\n\texpectError(t, `a := immutable({b: 1, c: 2}); a.b = 5`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `a := immutable({b: 1, c: 2}); a[\"b\"] = \"bar\"`,\n\t\tnil, \"not index-assignable\")\n\texpectRun(t, `a := immutable({b: 1, c: [1,2,3]}); a.c[1] = \"bar\"; out = a`,\n\t\tnil, IMAP{\"b\": 1, \"c\": ARR{1, \"bar\", 3}})\n\texpectError(t, `a := immutable({b: 1, c: immutable([1,2,3])}); a.c[1] = \"bar\"`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `a := {b: 1, c: immutable([1,2,3])}; a.c[1] = \"bar\"`,\n\t\tnil, \"not index-assignable\")\n\texpectRun(t, `out = immutable({a:1,b:2}) == {a:1,b:2}`,\n\t\tnil, true)\n\texpectRun(t, `out = immutable({a:1,b:2}) == immutable({a:1,b:2})`,\n\t\tnil, true)\n\texpectRun(t, `out = {a:1,b:2} == immutable({a:1,b:2})`,\n\t\tnil, true)\n\texpectRun(t, `out = immutable({a:1,b:2}) == {a:1,b:3}`,\n\t\tnil, false)\n\texpectRun(t, `out = immutable({a:1,b:2}) == immutable({a:1,b:3})`,\n\t\tnil, false)\n\texpectRun(t, `out = {a:1,b:2} == immutable({a:1,b:3})`,\n\t\tnil, false)\n\texpectRun(t, `out = immutable({a:1,b:2}).b`,\n\t\tnil, 2)\n\texpectRun(t, `out = immutable({a:1,b:2})[\"b\"]`,\n\t\tnil, 2)\n\texpectRun(t, `a := immutable({a:1,b:2}); a = 5; out = 5`,\n\t\tnil, 5)\n\texpectRun(t, `a := immutable({a:1,b:2}); out = a.c`,\n\t\tnil, tengo.UndefinedValue)\n\n\texpectRun(t, `a := immutable({b: 5, c: \"foo\"}); out = a.b`,\n\t\tnil, 5)\n\texpectError(t, `a := immutable({b: 5, c: \"foo\"}); a.b = 10`,\n\t\tnil, \"not index-assignable\")\n}\n\nfunc TestIncDec(t *testing.T) {\n\texpectRun(t, `out = 0; out++`, nil, 1)\n\texpectRun(t, `out = 0; out--`, nil, -1)\n\texpectRun(t, `a := 0; a++; out = a`, nil, 1)\n\texpectRun(t, `a := 0; a++; a--; out = a`, nil, 0)\n\n\t// this seems strange but it works because 'a += b' is\n\t// translated into 'a = a + b' and string type takes other types for + operator.\n\texpectRun(t, `a := \"foo\"; a++; out = a`, nil, \"foo1\")\n\texpectError(t, `a := \"foo\"; a--`, nil, \"invalid operation\")\n\n\texpectError(t, `a++`, nil, \"unresolved reference\") // not declared\n\texpectError(t, `a--`, nil, \"unresolved reference\") // not declared\n\texpectError(t, `4++`, nil, \"unresolved reference\")\n}\n\ntype StringDict struct {\n\ttengo.ObjectImpl\n\tValue map[string]string\n}\n\nfunc (o *StringDict) String() string { return \"\" }\n\nfunc (o *StringDict) TypeName() string {\n\treturn \"string-dict\"\n}\n\nfunc (o *StringDict) IndexGet(index tengo.Object) (tengo.Object, error) {\n\tstrIdx, ok := index.(*tengo.String)\n\tif !ok {\n\t\treturn nil, tengo.ErrInvalidIndexType\n\t}\n\n\tfor k, v := range o.Value {\n\t\tif strings.EqualFold(strIdx.Value, k) {\n\t\t\treturn &tengo.String{Value: v}, nil\n\t\t}\n\t}\n\n\treturn tengo.UndefinedValue, nil\n}\n\nfunc (o *StringDict) IndexSet(index, value tengo.Object) error {\n\tstrIdx, ok := index.(*tengo.String)\n\tif !ok {\n\t\treturn tengo.ErrInvalidIndexType\n\t}\n\n\tstrVal, ok := tengo.ToString(value)\n\tif !ok {\n\t\treturn tengo.ErrInvalidIndexValueType\n\t}\n\n\to.Value[strings.ToLower(strIdx.Value)] = strVal\n\n\treturn nil\n}\n\ntype StringCircle struct {\n\ttengo.ObjectImpl\n\tValue []string\n}\n\nfunc (o *StringCircle) TypeName() string {\n\treturn \"string-circle\"\n}\n\nfunc (o *StringCircle) String() string {\n\treturn \"\"\n}\n\nfunc (o *StringCircle) IndexGet(index tengo.Object) (tengo.Object, error) {\n\tintIdx, ok := index.(*tengo.Int)\n\tif !ok {\n\t\treturn nil, tengo.ErrInvalidIndexType\n\t}\n\n\tr := int(intIdx.Value) % len(o.Value)\n\tif r < 0 {\n\t\tr = len(o.Value) + r\n\t}\n\n\treturn &tengo.String{Value: o.Value[r]}, nil\n}\n\nfunc (o *StringCircle) IndexSet(index, value tengo.Object) error {\n\tintIdx, ok := index.(*tengo.Int)\n\tif !ok {\n\t\treturn tengo.ErrInvalidIndexType\n\t}\n\n\tr := int(intIdx.Value) % len(o.Value)\n\tif r < 0 {\n\t\tr = len(o.Value) + r\n\t}\n\n\tstrVal, ok := tengo.ToString(value)\n\tif !ok {\n\t\treturn tengo.ErrInvalidIndexValueType\n\t}\n\n\to.Value[r] = strVal\n\n\treturn nil\n}\n\ntype StringArray struct {\n\ttengo.ObjectImpl\n\tValue []string\n}\n\nfunc (o *StringArray) String() string {\n\treturn strings.Join(o.Value, \", \")\n}\n\nfunc (o *StringArray) BinaryOp(\n\top token.Token,\n\trhs tengo.Object,\n) (tengo.Object, error) {\n\tif rhs, ok := rhs.(*StringArray); ok {\n\t\tswitch op {\n\t\tcase token.Add:\n\t\t\tif len(rhs.Value) == 0 {\n\t\t\t\treturn o, nil\n\t\t\t}\n\t\t\treturn &StringArray{Value: append(o.Value, rhs.Value...)}, nil\n\t\t}\n\t}\n\n\treturn nil, tengo.ErrInvalidOperator\n}\n\nfunc (o *StringArray) IsFalsy() bool {\n\treturn len(o.Value) == 0\n}\n\nfunc (o *StringArray) Equals(x tengo.Object) bool {\n\tif x, ok := x.(*StringArray); ok {\n\t\tif len(o.Value) != len(x.Value) {\n\t\t\treturn false\n\t\t}\n\n\t\tfor i, v := range o.Value {\n\t\t\tif v != x.Value[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\treturn false\n}\n\nfunc (o *StringArray) Copy() tengo.Object {\n\treturn &StringArray{\n\t\tValue: append([]string{}, o.Value...),\n\t}\n}\n\nfunc (o *StringArray) TypeName() string {\n\treturn \"string-array\"\n}\n\nfunc (o *StringArray) IndexGet(index tengo.Object) (tengo.Object, error) {\n\tintIdx, ok := index.(*tengo.Int)\n\tif ok {\n\t\tif intIdx.Value >= 0 && intIdx.Value < int64(len(o.Value)) {\n\t\t\treturn &tengo.String{Value: o.Value[intIdx.Value]}, nil\n\t\t}\n\n\t\treturn nil, tengo.ErrIndexOutOfBounds\n\t}\n\n\tstrIdx, ok := index.(*tengo.String)\n\tif ok {\n\t\tfor vidx, str := range o.Value {\n\t\t\tif strIdx.Value == str {\n\t\t\t\treturn &tengo.Int{Value: int64(vidx)}, nil\n\t\t\t}\n\t\t}\n\n\t\treturn tengo.UndefinedValue, nil\n\t}\n\n\treturn nil, tengo.ErrInvalidIndexType\n}\n\nfunc (o *StringArray) IndexSet(index, value tengo.Object) error {\n\tstrVal, ok := tengo.ToString(value)\n\tif !ok {\n\t\treturn tengo.ErrInvalidIndexValueType\n\t}\n\n\tintIdx, ok := index.(*tengo.Int)\n\tif ok {\n\t\tif intIdx.Value >= 0 && intIdx.Value < int64(len(o.Value)) {\n\t\t\to.Value[intIdx.Value] = strVal\n\t\t\treturn nil\n\t\t}\n\n\t\treturn tengo.ErrIndexOutOfBounds\n\t}\n\n\treturn tengo.ErrInvalidIndexType\n}\n\nfunc (o *StringArray) Call(\n\targs ...tengo.Object,\n) (ret tengo.Object, err error) {\n\tif len(args) != 1 {\n\t\treturn nil, tengo.ErrWrongNumArguments\n\t}\n\n\ts1, ok := tengo.ToString(args[0])\n\tif !ok {\n\t\treturn nil, tengo.ErrInvalidArgumentType{\n\t\t\tName:     \"first\",\n\t\t\tExpected: \"string(compatible)\",\n\t\t\tFound:    args[0].TypeName(),\n\t\t}\n\t}\n\n\tfor i, v := range o.Value {\n\t\tif v == s1 {\n\t\t\treturn &tengo.Int{Value: int64(i)}, nil\n\t\t}\n\t}\n\n\treturn tengo.UndefinedValue, nil\n}\n\nfunc (o *StringArray) CanCall() bool {\n\treturn true\n}\n\nfunc TestIndexable(t *testing.T) {\n\tdict := func() *StringDict {\n\t\treturn &StringDict{Value: map[string]string{\"a\": \"foo\", \"b\": \"bar\"}}\n\t}\n\texpectRun(t, `out = dict[\"a\"]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"foo\")\n\texpectRun(t, `out = dict[\"B\"]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"bar\")\n\texpectRun(t, `out = dict[\"x\"]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), tengo.UndefinedValue)\n\texpectError(t, `dict[0]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"invalid index type\")\n\n\tstrCir := func() *StringCircle {\n\t\treturn &StringCircle{Value: []string{\"one\", \"two\", \"three\"}}\n\t}\n\texpectRun(t, `out = cir[0]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"one\")\n\texpectRun(t, `out = cir[1]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"two\")\n\texpectRun(t, `out = cir[-1]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"three\")\n\texpectRun(t, `out = cir[-2]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"two\")\n\texpectRun(t, `out = cir[3]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"one\")\n\texpectError(t, `cir[\"a\"]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"invalid index type\")\n\n\tstrArr := func() *StringArray {\n\t\treturn &StringArray{Value: []string{\"one\", \"two\", \"three\"}}\n\t}\n\texpectRun(t, `out = arr[\"one\"]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), 0)\n\texpectRun(t, `out = arr[\"three\"]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), 2)\n\texpectRun(t, `out = arr[\"four\"]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), tengo.UndefinedValue)\n\texpectRun(t, `out = arr[0]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"one\")\n\texpectRun(t, `out = arr[1]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"two\")\n\texpectError(t, `arr[-1]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"index out of bounds\")\n}\n\nfunc TestIndexAssignable(t *testing.T) {\n\tdict := func() *StringDict {\n\t\treturn &StringDict{Value: map[string]string{\"a\": \"foo\", \"b\": \"bar\"}}\n\t}\n\texpectRun(t, `dict[\"a\"] = \"1984\"; out = dict[\"a\"]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"1984\")\n\texpectRun(t, `dict[\"c\"] = \"1984\"; out = dict[\"c\"]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"1984\")\n\texpectRun(t, `dict[\"c\"] = 1984; out = dict[\"C\"]`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"1984\")\n\texpectError(t, `dict[0] = \"1984\"`,\n\t\tOpts().Symbol(\"dict\", dict()).Skip2ndPass(), \"invalid index type\")\n\n\tstrCir := func() *StringCircle {\n\t\treturn &StringCircle{Value: []string{\"one\", \"two\", \"three\"}}\n\t}\n\texpectRun(t, `cir[0] = \"ONE\"; out = cir[0]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"ONE\")\n\texpectRun(t, `cir[1] = \"TWO\"; out = cir[1]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"TWO\")\n\texpectRun(t, `cir[-1] = \"THREE\"; out = cir[2]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"THREE\")\n\texpectRun(t, `cir[0] = \"ONE\"; out = cir[3]`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"ONE\")\n\texpectError(t, `cir[\"a\"] = \"ONE\"`,\n\t\tOpts().Symbol(\"cir\", strCir()).Skip2ndPass(), \"invalid index type\")\n\n\tstrArr := func() *StringArray {\n\t\treturn &StringArray{Value: []string{\"one\", \"two\", \"three\"}}\n\t}\n\texpectRun(t, `arr[0] = \"ONE\"; out = arr[0]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"ONE\")\n\texpectRun(t, `arr[1] = \"TWO\"; out = arr[1]`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"TWO\")\n\texpectError(t, `arr[\"one\"] = \"ONE\"`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"invalid index type\")\n}\n\nfunc TestInteger(t *testing.T) {\n\texpectRun(t, `out = 5`, nil, 5)\n\texpectRun(t, `out = 10`, nil, 10)\n\texpectRun(t, `out = -5`, nil, -5)\n\texpectRun(t, `out = -10`, nil, -10)\n\texpectRun(t, `out = 5 + 5 + 5 + 5 - 10`, nil, 10)\n\texpectRun(t, `out = 2 * 2 * 2 * 2 * 2`, nil, 32)\n\texpectRun(t, `out = -50 + 100 + -50`, nil, 0)\n\texpectRun(t, `out = 5 * 2 + 10`, nil, 20)\n\texpectRun(t, `out = 5 + 2 * 10`, nil, 25)\n\texpectRun(t, `out = 20 + 2 * -10`, nil, 0)\n\texpectRun(t, `out = 50 / 2 * 2 + 10`, nil, 60)\n\texpectRun(t, `out = 2 * (5 + 10)`, nil, 30)\n\texpectRun(t, `out = 3 * 3 * 3 + 10`, nil, 37)\n\texpectRun(t, `out = 3 * (3 * 3) + 10`, nil, 37)\n\texpectRun(t, `out = (5 + 10 * 2 + 15 /3) * 2 + -10`, nil, 50)\n\texpectRun(t, `out = 5 % 3`, nil, 2)\n\texpectRun(t, `out = 5 % 3 + 4`, nil, 6)\n\texpectRun(t, `out = +5`, nil, 5)\n\texpectRun(t, `out = +5 + -5`, nil, 0)\n\n\texpectRun(t, `out = 9 + '0'`, nil, '9')\n\texpectRun(t, `out = '9' - 5`, nil, '4')\n}\n\ntype StringArrayIterator struct {\n\ttengo.ObjectImpl\n\tstrArr *StringArray\n\tidx    int\n}\n\nfunc (i *StringArrayIterator) TypeName() string {\n\treturn \"string-array-iterator\"\n}\n\nfunc (i *StringArrayIterator) String() string {\n\treturn \"\"\n}\n\nfunc (i *StringArrayIterator) Next() bool {\n\ti.idx++\n\treturn i.idx <= len(i.strArr.Value)\n}\n\nfunc (i *StringArrayIterator) Key() tengo.Object {\n\treturn &tengo.Int{Value: int64(i.idx - 1)}\n}\n\nfunc (i *StringArrayIterator) Value() tengo.Object {\n\treturn &tengo.String{Value: i.strArr.Value[i.idx-1]}\n}\n\nfunc (o *StringArray) Iterate() tengo.Iterator {\n\treturn &StringArrayIterator{\n\t\tstrArr: o,\n\t}\n}\n\nfunc (o *StringArray) CanIterate() bool {\n\treturn true\n}\n\nfunc TestIterable(t *testing.T) {\n\tstrArr := func() *StringArray {\n\t\treturn &StringArray{Value: []string{\"one\", \"two\", \"three\"}}\n\t}\n\texpectRun(t, `for i, s in arr { out += i }`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), 3)\n\texpectRun(t, `for i, s in arr { out += s }`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"onetwothree\")\n\texpectRun(t, `for i, s in arr { out += s + i }`,\n\t\tOpts().Symbol(\"arr\", strArr()).Skip2ndPass(), \"one0two1three2\")\n}\n\nfunc TestLogical(t *testing.T) {\n\texpectRun(t, `out = true && true`, nil, true)\n\texpectRun(t, `out = true && false`, nil, false)\n\texpectRun(t, `out = false && true`, nil, false)\n\texpectRun(t, `out = false && false`, nil, false)\n\texpectRun(t, `out = !true && true`, nil, false)\n\texpectRun(t, `out = !true && false`, nil, false)\n\texpectRun(t, `out = !false && true`, nil, true)\n\texpectRun(t, `out = !false && false`, nil, false)\n\n\texpectRun(t, `out = true || true`, nil, true)\n\texpectRun(t, `out = true || false`, nil, true)\n\texpectRun(t, `out = false || true`, nil, true)\n\texpectRun(t, `out = false || false`, nil, false)\n\texpectRun(t, `out = !true || true`, nil, true)\n\texpectRun(t, `out = !true || false`, nil, false)\n\texpectRun(t, `out = !false || true`, nil, true)\n\texpectRun(t, `out = !false || false`, nil, true)\n\n\texpectRun(t, `out = 1 && 2`, nil, 2)\n\texpectRun(t, `out = 1 || 2`, nil, 1)\n\texpectRun(t, `out = 1 && 0`, nil, 0)\n\texpectRun(t, `out = 1 || 0`, nil, 1)\n\texpectRun(t, `out = 1 && (0 || 2)`, nil, 2)\n\texpectRun(t, `out = 0 || (0 || 2)`, nil, 2)\n\texpectRun(t, `out = 0 || (0 && 2)`, nil, 0)\n\texpectRun(t, `out = 0 || (2 && 0)`, nil, 0)\n\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; t() && f()`,\n\t\tnil, 7)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; f() && t()`,\n\t\tnil, 7)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; f() || t()`,\n\t\tnil, 3)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; t() || f()`,\n\t\tnil, 3)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; !t() && f()`,\n\t\tnil, 3)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; !f() && t()`,\n\t\tnil, 3)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; !f() || t()`,\n\t\tnil, 7)\n\texpectRun(t, `t:=func() {out = 3; return true}; f:=func() {out = 7; return false}; !t() || f()`,\n\t\tnil, 7)\n}\n\nfunc TestMap(t *testing.T) {\n\texpectRun(t, `\nout = {\n\tone: 10 - 9,\n\ttwo: 1 + 1,\n\tthree: 6 / 2\n}`, nil, MAP{\n\t\t\"one\":   1,\n\t\t\"two\":   2,\n\t\t\"three\": 3,\n\t})\n\n\texpectRun(t, `\nout = {\n\t\"one\": 10 - 9,\n\t\"two\": 1 + 1,\n\t\"three\": 6 / 2\n}`, nil, MAP{\n\t\t\"one\":   1,\n\t\t\"two\":   2,\n\t\t\"three\": 3,\n\t})\n\n\texpectRun(t, `out = {foo: 5}[\"foo\"]`, nil, 5)\n\texpectRun(t, `out = {foo: 5}[\"bar\"]`, nil, tengo.UndefinedValue)\n\texpectRun(t, `key := \"foo\"; out = {foo: 5}[key]`, nil, 5)\n\texpectRun(t, `out = {}[\"foo\"]`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `\nm := {\n\tfoo: func(x) {\n\t\treturn x * 2\n\t}\n}\nout = m[\"foo\"](2) + m[\"foo\"](3)\n`, nil, 10)\n\n\t// map assignment is copy-by-reference\n\texpectRun(t, `m1 := {k1: 1, k2: \"foo\"}; m2 := m1; m1.k1 = 5; out = m2.k1`,\n\t\tnil, 5)\n\texpectRun(t, `m1 := {k1: 1, k2: \"foo\"}; m2 := m1; m2.k1 = 3; out = m1.k1`,\n\t\tnil, 3)\n\texpectRun(t, `func() { m1 := {k1: 1, k2: \"foo\"}; m2 := m1; m1.k1 = 5; out = m2.k1 }()`,\n\t\tnil, 5)\n\texpectRun(t, `func() { m1 := {k1: 1, k2: \"foo\"}; m2 := m1; m2.k1 = 3; out = m1.k1 }()`,\n\t\tnil, 3)\n}\n\nfunc TestBuiltin(t *testing.T) {\n\tm := Opts().Module(\"math\",\n\t\t&tengo.BuiltinModule{\n\t\t\tAttrs: map[string]tengo.Object{\n\t\t\t\t\"abs\": &tengo.UserFunction{\n\t\t\t\t\tName: \"abs\",\n\t\t\t\t\tValue: func(a ...tengo.Object) (tengo.Object, error) {\n\t\t\t\t\t\tv, _ := tengo.ToFloat64(a[0])\n\t\t\t\t\t\treturn &tengo.Float{Value: math.Abs(v)}, nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t// builtin\n\texpectRun(t, `math := import(\"math\"); out = math.abs(1)`, m, 1.0)\n\texpectRun(t, `math := import(\"math\"); out = math.abs(-1)`, m, 1.0)\n\texpectRun(t, `math := import(\"math\"); out = math.abs(1.0)`, m, 1.0)\n\texpectRun(t, `math := import(\"math\"); out = math.abs(-1.0)`, m, 1.0)\n}\n\nfunc TestUserModules(t *testing.T) {\n\t// export none\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `fn := func() { return 5.0 }; a := 2`),\n\t\ttengo.UndefinedValue)\n\n\t// export values\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `export 5`), 5)\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `export \"foo\"`), \"foo\")\n\n\t// export compound types\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `export [1, 2, 3]`), IARR{1, 2, 3})\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `export {a: 1, b: 2}`), IMAP{\"a\": 1, \"b\": 2})\n\n\t// export value is immutable\n\texpectError(t, `m1 := import(\"mod1\"); m1.a = 5`,\n\t\tOpts().Module(\"mod1\", `export {a: 1, b: 2}`), \"not index-assignable\")\n\texpectError(t, `m1 := import(\"mod1\"); m1[1] = 5`,\n\t\tOpts().Module(\"mod1\", `export [1, 2, 3]`), \"not index-assignable\")\n\n\t// code after export statement will not be executed\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `a := 10; export a; a = 20`), 10)\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `a := 10; export a; a = 20; export a`), 10)\n\n\t// export function\n\texpectRun(t, `out = import(\"mod1\")()`,\n\t\tOpts().Module(\"mod1\", `export func() { return 5.0 }`), 5.0)\n\t// export function that reads module-global variable\n\texpectRun(t, `out = import(\"mod1\")()`,\n\t\tOpts().Module(\"mod1\", `a := 1.5; export func() { return a + 5.0 }`), 6.5)\n\t// export function that read local variable\n\texpectRun(t, `out = import(\"mod1\")()`,\n\t\tOpts().Module(\"mod1\", `export func() { a := 1.5; return a + 5.0 }`), 6.5)\n\t// export function that read free variables\n\texpectRun(t, `out = import(\"mod1\")()`,\n\t\tOpts().Module(\"mod1\", `export func() { a := 1.5; return func() { return a + 5.0 }() }`), 6.5)\n\n\t// recursive function in module\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\n\t\t\t\"mod1\", `\na := func(x) {\n\treturn x == 0 ? 0 : x + a(x-1)\n}\n\nexport a(5)\n`), 15)\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\n\t\t\t\"mod1\", `\nexport func() {\n\ta := func(x) {\n\t\treturn x == 0 ? 0 : x + a(x-1)\n\t}\n\n\treturn a(5)\n}()\n`), 15)\n\n\t// (main) -> mod1 -> mod2\n\texpectRun(t, `out = import(\"mod1\")()`,\n\t\tOpts().Module(\"mod1\", `export import(\"mod2\")`).\n\t\t\tModule(\"mod2\", `export func() { return 5.0 }`),\n\t\t5.0)\n\t// (main) -> mod1 -> mod2\n\t//        -> mod2\n\texpectRun(t, `import(\"mod1\"); out = import(\"mod2\")()`,\n\t\tOpts().Module(\"mod1\", `export import(\"mod2\")`).\n\t\t\tModule(\"mod2\", `export func() { return 5.0 }`),\n\t\t5.0)\n\t// (main) -> mod1 -> mod2 -> mod3\n\t//        -> mod2 -> mod3\n\texpectRun(t, `import(\"mod1\"); out = import(\"mod2\")()`,\n\t\tOpts().Module(\"mod1\", `export import(\"mod2\")`).\n\t\t\tModule(\"mod2\", `export import(\"mod3\")`).\n\t\t\tModule(\"mod3\", `export func() { return 5.0 }`),\n\t\t5.0)\n\n\t// cyclic imports\n\t// (main) -> mod1 -> mod2 -> mod1\n\texpectError(t, `import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `import(\"mod2\")`).\n\t\t\tModule(\"mod2\", `import(\"mod1\")`),\n\t\t\"Compile Error: cyclic module import: mod1\\n\\tat mod2:1:1\")\n\t// (main) -> mod1 -> mod2 -> mod3 -> mod1\n\texpectError(t, `import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `import(\"mod2\")`).\n\t\t\tModule(\"mod2\", `import(\"mod3\")`).\n\t\t\tModule(\"mod3\", `import(\"mod1\")`),\n\t\t\"Compile Error: cyclic module import: mod1\\n\\tat mod3:1:1\")\n\t// (main) -> mod1 -> mod2 -> mod3 -> mod2\n\texpectError(t, `import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `import(\"mod2\")`).\n\t\t\tModule(\"mod2\", `import(\"mod3\")`).\n\t\t\tModule(\"mod3\", `import(\"mod2\")`),\n\t\t\"Compile Error: cyclic module import: mod2\\n\\tat mod3:1:1\")\n\n\t// unknown modules\n\texpectError(t, `import(\"mod0\")`,\n\t\tOpts().Module(\"mod1\", `a := 5`), \"module 'mod0' not found\")\n\texpectError(t, `import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `import(\"mod2\")`), \"module 'mod2' not found\")\n\n\t// module is immutable but its variables is not necessarily immutable.\n\texpectRun(t, `m1 := import(\"mod1\"); m1.a.b = 5; out = m1.a.b`,\n\t\tOpts().Module(\"mod1\", `export {a: {b: 3}}`),\n\t\t5)\n\n\t// make sure module has same builtin functions\n\texpectRun(t, `out = import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `export func() { return type_name(0) }()`),\n\t\t\"int\")\n\n\t// 'export' statement is ignored outside module\n\texpectRun(t, `a := 5; export func() { a = 10 }(); out = a`,\n\t\tOpts().Skip2ndPass(), 5)\n\n\t// 'export' must be in the top-level\n\texpectError(t, `import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `func() { export 5 }()`),\n\t\t\"Compile Error: export not allowed inside function\\n\\tat mod1:1:10\")\n\texpectError(t, `import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `func() { func() { export 5 }() }()`),\n\t\t\"Compile Error: export not allowed inside function\\n\\tat mod1:1:19\")\n\n\t// module cannot access outer scope\n\texpectError(t, `a := 5; import(\"mod1\")`,\n\t\tOpts().Module(\"mod1\", `export a`),\n\t\t\"Compile Error: unresolved reference 'a'\\n\\tat mod1:1:8\")\n\n\t// runtime error within modules\n\texpectError(t, `\na := 1;\nb := import(\"mod1\");\nb(a)`,\n\t\tOpts().Module(\"mod1\", `\nexport func(a) {\n   a()\n}\n`), \"Runtime Error: not callable: int\\n\\tat mod1:3:4\\n\\tat test:4:1\")\n\n\t// module skipping export\n\texpectRun(t, `out = import(\"mod0\")`,\n\t\tOpts().Module(\"mod0\", ``), tengo.UndefinedValue)\n\texpectRun(t, `out = import(\"mod0\")`,\n\t\tOpts().Module(\"mod0\", `if 1 { export true }`), true)\n\texpectRun(t, `out = import(\"mod0\")`,\n\t\tOpts().Module(\"mod0\", `if 0 { export true }`),\n\t\ttengo.UndefinedValue)\n\texpectRun(t, `out = import(\"mod0\")`,\n\t\tOpts().Module(\"mod0\", `if 1 { } else { export true }`),\n\t\ttengo.UndefinedValue)\n\texpectRun(t, `out = import(\"mod0\")`,\n\t\tOpts().Module(\"mod0\", `for v:=0;;v++ { if v == 3 { export true } }`),\n\t\ttrue)\n\texpectRun(t, `out = import(\"mod0\")`,\n\t\tOpts().Module(\"mod0\", `for v:=0;;v++ { if v == 3 { break } }`),\n\t\ttengo.UndefinedValue)\n\n\t// duplicate compiled functions\n\t// NOTE: module \"mod\" has a function with some local variable, and it's\n\t//  imported twice by the main script. That causes the same CompiledFunction\n\t//  put in constants twice and the Bytecode optimization (removing duplicate\n\t//  constants) should still work correctly.\n\texpectRun(t, `\nm1 := import(\"mod\")\nm2 := import(\"mod\")\nout = m1.x\n\t`,\n\t\tOpts().Module(\"mod\", `\nf1 := func(a, b) {\n\tc := a + b + 1\n\treturn a + b + 1\n}\nexport { x: 1 }\n`),\n\t\t1)\n}\n\nfunc TestModuleBlockScopes(t *testing.T) {\n\tm := Opts().Module(\"rand\",\n\t\t&tengo.BuiltinModule{\n\t\t\tAttrs: map[string]tengo.Object{\n\t\t\t\t\"intn\": &tengo.UserFunction{\n\t\t\t\t\tName: \"abs\",\n\t\t\t\t\tValue: func(a ...tengo.Object) (tengo.Object, error) {\n\t\t\t\t\t\tv, _ := tengo.ToInt64(a[0])\n\t\t\t\t\t\treturn &tengo.Int{Value: rand.Int63n(v)}, nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t// block scopes in module\n\texpectRun(t, `out = import(\"mod1\")()`, m.Module(\n\t\t\"mod1\", `\n\trand := import(\"rand\")\n\tfoo := func() { return 1 }\n\texport func() {\n\t\trand.intn(3)\n\t\treturn foo()\n\t}`), 1)\n\n\texpectRun(t, `out = import(\"mod1\")()`, m.Module(\n\t\t\"mod1\", `\nrand := import(\"rand\")\nfoo := func() { return 1 }\nexport func() {\n\trand.intn(3)\n\tif foo() {}\n\treturn 10\n}\n`), 10)\n\n\texpectRun(t, `out = import(\"mod1\")()`, m.Module(\n\t\t\"mod1\", `\n\trand := import(\"rand\")\n\tfoo := func() { return 1 }\n\texport func() {\n\t\trand.intn(3)\n\t\tif true { foo() }\n\t\treturn 10\n\t}\n\t`), 10)\n}\n\nfunc TestBangOperator(t *testing.T) {\n\texpectRun(t, `out = !true`, nil, false)\n\texpectRun(t, `out = !false`, nil, true)\n\texpectRun(t, `out = !0`, nil, true)\n\texpectRun(t, `out = !5`, nil, false)\n\texpectRun(t, `out = !!true`, nil, true)\n\texpectRun(t, `out = !!false`, nil, false)\n\texpectRun(t, `out = !!5`, nil, true)\n}\n\nfunc TestObjectsLimit(t *testing.T) {\n\ttestAllocsLimit(t, `5`, 0)\n\ttestAllocsLimit(t, `5 + 5`, 1)\n\ttestAllocsLimit(t, `a := [1, 2, 3]`, 1)\n\ttestAllocsLimit(t, `a := 1; b := 2; c := 3; d := [a, b, c]`, 1)\n\ttestAllocsLimit(t, `a := {foo: 1, bar: 2}`, 1)\n\ttestAllocsLimit(t, `a := 1; b := 2; c := {foo: a, bar: b}`, 1)\n\ttestAllocsLimit(t, `\nf := func() {\n\treturn 5 + 5\n}\na := f() + 5\n`, 2)\n\ttestAllocsLimit(t, `\nf := func() {\n\treturn 5 + 5\n}\na := f()\n`, 1)\n\ttestAllocsLimit(t, `\na := []\nf := func() {\n\ta = append(a, 5)\n}\nf()\nf()\nf()\n`, 4)\n}\n\nfunc testAllocsLimit(t *testing.T, src string, limit int64) {\n\texpectRun(t, src,\n\t\tOpts().Skip2ndPass(), tengo.UndefinedValue) // no limit\n\texpectRun(t, src,\n\t\tOpts().MaxAllocs(limit).Skip2ndPass(), tengo.UndefinedValue)\n\texpectRun(t, src,\n\t\tOpts().MaxAllocs(limit+1).Skip2ndPass(), tengo.UndefinedValue)\n\tif limit > 1 {\n\t\texpectError(t, src,\n\t\t\tOpts().MaxAllocs(limit-1).Skip2ndPass(),\n\t\t\t\"allocation limit exceeded\")\n\t}\n\tif limit > 2 {\n\t\texpectError(t, src,\n\t\t\tOpts().MaxAllocs(limit-2).Skip2ndPass(),\n\t\t\t\"allocation limit exceeded\")\n\t}\n}\n\nfunc TestReturn(t *testing.T) {\n\texpectRun(t, `out = func() { return 10; }()`, nil, 10)\n\texpectRun(t, `out = func() { return 10; return 9; }()`, nil, 10)\n\texpectRun(t, `out = func() { return 2 * 5; return 9 }()`, nil, 10)\n\texpectRun(t, `out = func() { 9; return 2 * 5; return 9 }()`, nil, 10)\n\texpectRun(t, `\n\tout = func() { \n\t\tif (10 > 1) {\n\t\t\tif (10 > 1) {\n\t\t\t\treturn 10;\n\t  \t\t}\n\n\t  \t\treturn 1;\n\t\t}\n\t}()`, nil, 10)\n\n\texpectRun(t, `f1 := func() { return 2 * 5; }; out = f1()`, nil, 10)\n}\n\nfunc TestVMScopes(t *testing.T) {\n\t// shadowed global variable\n\texpectRun(t, `\nc := 5\nif a := 3; a {\n\tc := 6\n} else {\n\tc := 7\n}\nout = c\n`, nil, 5)\n\n\t// shadowed local variable\n\texpectRun(t, `\nfunc() {\n\tc := 5\n\tif a := 3; a {\n\t\tc := 6\n\t} else {\n\t\tc := 7\n\t}\n\tout = c\n}()\n`, nil, 5)\n\n\t// 'b' is declared in 2 separate blocks\n\texpectRun(t, `\nc := 5\nif a := 3; a {\n\tb := 8\n\tc = b\n} else {\n\tb := 9\n\tc = b\n}\nout = c\n`, nil, 8)\n\n\t// shadowing inside for statement\n\texpectRun(t, `\na := 4\nb := 5\nfor i:=0;i<3;i++ {\n\tb := 6\n\tfor j:=0;j<2;j++ {\n\t\tb := 7\n\t\ta = i*j\n\t}\n}\nout = a`, nil, 2)\n\n\t// shadowing variable declared in init statement\n\texpectRun(t, `\nif a := 5; a {\n\ta := 6\n\tout = a\n}`, nil, 6)\n\texpectRun(t, `\na := 4\nif a := 5; a {\n\ta := 6\n\tout = a\n}`, nil, 6)\n\texpectRun(t, `\na := 4\nif a := 0; a {\n\ta := 6\n\tout = a\n} else {\n\ta := 7\n\tout = a\n}`, nil, 7)\n\texpectRun(t, `\na := 4\nif a := 0; a {\n\tout = a\n} else {\n\tout = a\n}`, nil, 0)\n\n\t// shadowing function level\n\texpectRun(t, `\na := 5\nfunc() {\n\ta := 6\n\ta = 7\n}()\nout = a\n`, nil, 5)\n\texpectRun(t, `\na := 5\nfunc() {\n\tif a := 7; true {\n\t\ta = 8\n\t}\n}()\nout = a\n`, nil, 5)\n}\n\nfunc TestSelector(t *testing.T) {\n\texpectRun(t, `a := {k1: 5, k2: \"foo\"}; out = a.k1`,\n\t\tnil, 5)\n\texpectRun(t, `a := {k1: 5, k2: \"foo\"}; out = a.k2`,\n\t\tnil, \"foo\")\n\texpectRun(t, `a := {k1: 5, k2: \"foo\"}; out = a.k3`,\n\t\tnil, tengo.UndefinedValue)\n\n\texpectRun(t, `\na := {\n\tb: {\n\t\tc: 4,\n\t\ta: false\n\t},\n\tc: \"foo bar\"\n}\nout = a.b.c`, nil, 4)\n\n\texpectRun(t, `\na := {\n\tb: {\n\t\tc: 4,\n\t\ta: false\n\t},\n\tc: \"foo bar\"\n}\nb := a.x.c`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `\na := {\n\tb: {\n\t\tc: 4,\n\t\ta: false\n\t},\n\tc: \"foo bar\"\n}\nb := a.x.y`, nil, tengo.UndefinedValue)\n\n\texpectRun(t, `a := {b: 1, c: \"foo\"}; a.b = 2; out = a.b`,\n\t\tnil, 2)\n\texpectRun(t, `a := {b: 1, c: \"foo\"}; a.c = 2; out = a.c`,\n\t\tnil, 2) // type not checked on sub-field\n\texpectRun(t, `a := {b: {c: 1}}; a.b.c = 2; out = a.b.c`,\n\t\tnil, 2)\n\texpectRun(t, `a := {b: 1}; a.c = 2; out = a`,\n\t\tnil, MAP{\"b\": 1, \"c\": 2})\n\texpectRun(t, `a := {b: {c: 1}}; a.b.d = 2; out = a`,\n\t\tnil, MAP{\"b\": MAP{\"c\": 1, \"d\": 2}})\n\n\texpectRun(t, `func() { a := {b: 1, c: \"foo\"}; a.b = 2; out = a.b }()`,\n\t\tnil, 2)\n\texpectRun(t, `func() { a := {b: 1, c: \"foo\"}; a.c = 2; out = a.c }()`,\n\t\tnil, 2) // type not checked on sub-field\n\texpectRun(t, `func() { a := {b: {c: 1}}; a.b.c = 2; out = a.b.c }()`,\n\t\tnil, 2)\n\texpectRun(t, `func() { a := {b: 1}; a.c = 2; out = a }()`,\n\t\tnil, MAP{\"b\": 1, \"c\": 2})\n\texpectRun(t, `func() { a := {b: {c: 1}}; a.b.d = 2; out = a }()`,\n\t\tnil, MAP{\"b\": MAP{\"c\": 1, \"d\": 2}})\n\n\texpectRun(t, `func() { a := {b: 1, c: \"foo\"}; func() { a.b = 2 }(); out = a.b }()`,\n\t\tnil, 2)\n\texpectRun(t, `func() { a := {b: 1, c: \"foo\"}; func() { a.c = 2 }(); out = a.c }()`,\n\t\tnil, 2) // type not checked on sub-field\n\texpectRun(t, `func() { a := {b: {c: 1}}; func() { a.b.c = 2 }(); out = a.b.c }()`,\n\t\tnil, 2)\n\texpectRun(t, `func() { a := {b: 1}; func() { a.c = 2 }(); out = a }()`,\n\t\tnil, MAP{\"b\": 1, \"c\": 2})\n\texpectRun(t, `func() { a := {b: {c: 1}}; func() { a.b.d = 2 }(); out = a }()`,\n\t\tnil, MAP{\"b\": MAP{\"c\": 1, \"d\": 2}})\n\n\texpectRun(t, `\na := {\n\tb: [1, 2, 3],\n\tc: {\n\t\td: 8,\n\t\te: \"foo\",\n\t\tf: [9, 8]\n\t}\n}\nout = [a.b[2], a.c.d, a.c.e, a.c.f[1]]\n`, nil, ARR{3, 8, \"foo\", 8})\n\n\texpectRun(t, `\nfunc() {\n\ta := [1, 2, 3]\n\tb := 9\n\ta[1] = b\n\tb = 7     // make sure a[1] has a COPY of value of 'b'\n\tout = a[1]\n}()\n`, nil, 9)\n\n\texpectError(t, `a := {b: {c: 1}}; a.d.c = 2`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `a := [1, 2, 3]; a.b = 2`,\n\t\tnil, \"invalid index type\")\n\texpectError(t, `a := \"foo\"; a.b = 2`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `func() { a := {b: {c: 1}}; a.d.c = 2 }()`,\n\t\tnil, \"not index-assignable\")\n\texpectError(t, `func() { a := [1, 2, 3]; a.b = 2 }()`,\n\t\tnil, \"invalid index type\")\n\texpectError(t, `func() { a := \"foo\"; a.b = 2 }()`,\n\t\tnil, \"not index-assignable\")\n}\n\nfunc TestSourceModules(t *testing.T) {\n\ttestEnumModule(t, `out = enum.key(0, 20)`, 0)\n\ttestEnumModule(t, `out = enum.key(10, 20)`, 10)\n\ttestEnumModule(t, `out = enum.value(0, 0)`, 0)\n\ttestEnumModule(t, `out = enum.value(10, 20)`, 20)\n\n\ttestEnumModule(t, `out = enum.all([], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.all([1], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.all([true, 1], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.all([true, 0], enum.value)`, false)\n\ttestEnumModule(t, `out = enum.all([true, 0, 1], enum.value)`, false)\n\ttestEnumModule(t, `out = enum.all(immutable([true, 0, 1]), enum.value)`,\n\t\tfalse) // immutable-array\n\ttestEnumModule(t, `out = enum.all({}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.all({a:1}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.all({a:true, b:1}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.all(immutable({a:true, b:1}), enum.value)`,\n\t\ttrue) // immutable-map\n\ttestEnumModule(t, `out = enum.all({a:true, b:0}, enum.value)`, false)\n\ttestEnumModule(t, `out = enum.all({a:true, b:0, c:1}, enum.value)`, false)\n\ttestEnumModule(t, `out = enum.all(0, enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.all(\"123\", enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\n\ttestEnumModule(t, `out = enum.any([], enum.value)`, false)\n\ttestEnumModule(t, `out = enum.any([1], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any([true, 1], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any([true, 0], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any([true, 0, 1], enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any(immutable([true, 0, 1]), enum.value)`,\n\t\ttrue) // immutable-array\n\ttestEnumModule(t, `out = enum.any([false], enum.value)`, false)\n\ttestEnumModule(t, `out = enum.any([false, 0], enum.value)`, false)\n\ttestEnumModule(t, `out = enum.any({}, enum.value)`, false)\n\ttestEnumModule(t, `out = enum.any({a:1}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any({a:true, b:1}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any({a:true, b:0}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any({a:true, b:0, c:1}, enum.value)`, true)\n\ttestEnumModule(t, `out = enum.any(immutable({a:true, b:0, c:1}), enum.value)`,\n\t\ttrue) // immutable-map\n\ttestEnumModule(t, `out = enum.any({a:false}, enum.value)`, false)\n\ttestEnumModule(t, `out = enum.any({a:false, b:0}, enum.value)`, false)\n\ttestEnumModule(t, `out = enum.any(0, enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.any(\"123\", enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\n\ttestEnumModule(t, `out = enum.chunk([], 1)`, ARR{})\n\ttestEnumModule(t, `out = enum.chunk([1], 1)`, ARR{ARR{1}})\n\ttestEnumModule(t, `out = enum.chunk([1,2,3], 1)`,\n\t\tARR{ARR{1}, ARR{2}, ARR{3}})\n\ttestEnumModule(t, `out = enum.chunk([1,2,3], 2)`,\n\t\tARR{ARR{1, 2}, ARR{3}})\n\ttestEnumModule(t, `out = enum.chunk([1,2,3], 3)`,\n\t\tARR{ARR{1, 2, 3}})\n\ttestEnumModule(t, `out = enum.chunk([1,2,3], 4)`,\n\t\tARR{ARR{1, 2, 3}})\n\ttestEnumModule(t, `out = enum.chunk([1,2,3,4], 3)`,\n\t\tARR{ARR{1, 2, 3}, ARR{4}})\n\ttestEnumModule(t, `out = enum.chunk([], 0)`,\n\t\ttengo.UndefinedValue) // size=0: undefined\n\ttestEnumModule(t, `out = enum.chunk([1], 0)`,\n\t\ttengo.UndefinedValue) // size=0: undefined\n\ttestEnumModule(t, `out = enum.chunk([1,2,3], 0)`,\n\t\ttengo.UndefinedValue) // size=0: undefined\n\ttestEnumModule(t, `out = enum.chunk({a:1,b:2,c:3}, 1)`,\n\t\ttengo.UndefinedValue) // map: undefined\n\ttestEnumModule(t, `out = enum.chunk(0, 1)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.chunk(\"123\", 1)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\n\ttestEnumModule(t, `out = enum.at([], 0)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([], 1)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([], -1)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([\"one\"], 0)`,\n\t\t\"one\")\n\ttestEnumModule(t, `out = enum.at([\"one\"], 1)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([\"one\"], -1)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([\"one\",\"two\",\"three\"], 0)`,\n\t\t\"one\")\n\ttestEnumModule(t, `out = enum.at([\"one\",\"two\",\"three\"], 1)`,\n\t\t\"two\")\n\ttestEnumModule(t, `out = enum.at([\"one\",\"two\",\"three\"], 2)`,\n\t\t\"three\")\n\ttestEnumModule(t, `out = enum.at([\"one\",\"two\",\"three\"], -1)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([\"one\",\"two\",\"three\"], 3)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at([\"one\",\"two\",\"three\"], \"1\")`,\n\t\ttengo.UndefinedValue) // non-int index: undefined\n\ttestEnumModule(t, `out = enum.at({}, \"a\")`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at({a:\"one\"}, \"a\")`,\n\t\t\"one\")\n\ttestEnumModule(t, `out = enum.at({a:\"one\"}, \"b\")`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at({a:\"one\",b:\"two\",c:\"three\"}, \"a\")`,\n\t\t\"one\")\n\ttestEnumModule(t, `out = enum.at({a:\"one\",b:\"two\",c:\"three\"}, \"b\")`,\n\t\t\"two\")\n\ttestEnumModule(t, `out = enum.at({a:\"one\",b:\"two\",c:\"three\"}, \"c\")`,\n\t\t\"three\")\n\ttestEnumModule(t, `out = enum.at({a:\"one\",b:\"two\",c:\"three\"}, \"d\")`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.at({a:\"one\",b:\"two\",c:\"three\"}, 'a')`,\n\t\ttengo.UndefinedValue) // non-string index: undefined\n\ttestEnumModule(t, `out = enum.at(0, 1)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.at(\"abc\", 1)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\n\ttestEnumModule(t, `out=0; enum.each([],func(k,v){out+=v})`, 0)\n\ttestEnumModule(t, `out=0; enum.each([1,2,3],func(k,v){out+=v})`, 6)\n\ttestEnumModule(t, `out=0; enum.each([1,2,3],func(k,v){out+=k})`, 3)\n\ttestEnumModule(t, `out=0; enum.each({a:1,b:2,c:3},func(k,v){out+=v})`, 6)\n\ttestEnumModule(t, `out=\"\"; enum.each({a:1,b:2,c:3},func(k,v){out+=k}); out=len(out)`,\n\t\t3)\n\ttestEnumModule(t, `out=0; enum.each(5,func(k,v){out+=v})`, 0)     // non-enumerable: no iteration\n\ttestEnumModule(t, `out=0; enum.each(\"123\",func(k,v){out+=v})`, 0) // non-enumerable: no iteration\n\n\ttestEnumModule(t, `out = enum.filter([], enum.value)`,\n\t\tARR{})\n\ttestEnumModule(t, `out = enum.filter([false,1,2], enum.value)`,\n\t\tARR{1, 2})\n\ttestEnumModule(t, `out = enum.filter([false,1,0,2], enum.value)`,\n\t\tARR{1, 2})\n\ttestEnumModule(t, `out = enum.filter({}, enum.value)`,\n\t\ttengo.UndefinedValue) // non-array: undefined\n\ttestEnumModule(t, `out = enum.filter(0, enum.value)`,\n\t\ttengo.UndefinedValue) // non-array: undefined\n\ttestEnumModule(t, `out = enum.filter(\"123\", enum.value)`,\n\t\ttengo.UndefinedValue) // non-array: undefined\n\n\ttestEnumModule(t, `out = enum.find([], enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find([0], enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find([1], enum.value)`, 1)\n\ttestEnumModule(t, `out = enum.find([false,0,undefined,1], enum.value)`, 1)\n\ttestEnumModule(t, `out = enum.find([1,2,3], enum.value)`, 1)\n\ttestEnumModule(t, `out = enum.find({}, enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find({a:0}, enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find({a:1}, enum.value)`, 1)\n\ttestEnumModule(t, `out = enum.find({a:false,b:0,c:undefined,d:1}, enum.value)`,\n\t\t1)\n\t//testEnumModule(t, `out = enum.find({a:1,b:2,c:3}, enum.value)`, 1)\n\ttestEnumModule(t, `out = enum.find(0, enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.find(\"123\", enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\n\ttestEnumModule(t, `out = enum.find_key([], enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find_key([0], enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find_key([1], enum.value)`, 0)\n\ttestEnumModule(t, `out = enum.find_key([false,0,undefined,1], enum.value)`,\n\t\t3)\n\ttestEnumModule(t, `out = enum.find_key([1,2,3], enum.value)`, 0)\n\ttestEnumModule(t, `out = enum.find_key({}, enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find_key({a:0}, enum.value)`,\n\t\ttengo.UndefinedValue)\n\ttestEnumModule(t, `out = enum.find_key({a:1}, enum.value)`,\n\t\t\"a\")\n\ttestEnumModule(t, `out = enum.find_key({a:false,b:0,c:undefined,d:1}, enum.value)`,\n\t\t\"d\")\n\t//testEnumModule(t, `out = enum.find_key({a:1,b:2,c:3}, enum.value)`, \"a\")\n\ttestEnumModule(t, `out = enum.find_key(0, enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.find_key(\"123\", enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\n\ttestEnumModule(t, `out = enum.map([], enum.value)`,\n\t\tARR{})\n\ttestEnumModule(t, `out = enum.map([1,2,3], enum.value)`,\n\t\tARR{1, 2, 3})\n\ttestEnumModule(t, `out = enum.map([1,2,3], enum.key)`,\n\t\tARR{0, 1, 2})\n\ttestEnumModule(t, `out = enum.map([1,2,3], func(k,v) { return v*2 })`,\n\t\tARR{2, 4, 6})\n\ttestEnumModule(t, `out = enum.map({}, enum.value)`,\n\t\tARR{})\n\ttestEnumModule(t, `out = enum.map({a:1}, func(k,v) { return v*2 })`,\n\t\tARR{2})\n\ttestEnumModule(t, `out = enum.map(0, enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n\ttestEnumModule(t, `out = enum.map(\"123\", enum.value)`,\n\t\ttengo.UndefinedValue) // non-enumerable: undefined\n}\n\nfunc testEnumModule(t *testing.T, input string, expected interface{}) {\n\texpectRun(t, `enum := import(\"enum\"); `+input,\n\t\tOpts().Module(\"enum\", stdlib.SourceModules[\"enum\"]),\n\t\texpected)\n}\n\nfunc TestSrcModEnum(t *testing.T) {\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.all([1, 2, 3], func(_, v) { return v >= 1 }) \n`, Opts().Stdlib(), true)\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.all([1, 2, 3], func(_, v) { return v >= 2 }) \n`, Opts().Stdlib(), false)\n\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.any([1, 2, 3], func(_, v) { return v >= 1 }) \n`, Opts().Stdlib(), true)\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.any([1, 2, 3], func(_, v) { return v >= 2 }) \n`, Opts().Stdlib(), true)\n\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.chunk([1, 2, 3], 1) \n`, Opts().Stdlib(), ARR{ARR{1}, ARR{2}, ARR{3}})\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.chunk([1, 2, 3], 2) \n`, Opts().Stdlib(), ARR{ARR{1, 2}, ARR{3}})\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.chunk([1, 2, 3], 3) \n`, Opts().Stdlib(), ARR{ARR{1, 2, 3}})\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.chunk([1, 2, 3], 4) \n`, Opts().Stdlib(), ARR{ARR{1, 2, 3}})\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.chunk([1, 2, 3, 4, 5, 6], 2) \n`, Opts().Stdlib(), ARR{ARR{1, 2}, ARR{3, 4}, ARR{5, 6}})\n\n\texpectRun(t, `\nx := import(\"enum\")\nout = x.at([1, 2, 3], 0) \n`, Opts().Stdlib(), 1)\n}\n\nfunc TestVMStackOverflow(t *testing.T) {\n\texpectError(t, `f := func() { return f() + 1 }; f()`,\n\t\tnil, \"stack overflow\")\n}\n\nfunc TestString(t *testing.T) {\n\texpectRun(t, `out = \"Hello World!\"`, nil, \"Hello World!\")\n\texpectRun(t, `out = \"Hello\" + \" \" + \"World!\"`, nil, \"Hello World!\")\n\n\texpectRun(t, `out = \"Hello\" == \"Hello\"`, nil, true)\n\texpectRun(t, `out = \"Hello\" == \"World\"`, nil, false)\n\texpectRun(t, `out = \"Hello\" != \"Hello\"`, nil, false)\n\texpectRun(t, `out = \"Hello\" != \"World\"`, nil, true)\n\n\texpectRun(t, `out = \"Hello\" > \"World\"`, nil, false)\n\texpectRun(t, `out = \"World\" < \"Hello\"`, nil, false)\n\texpectRun(t, `out = \"Hello\" < \"World\"`, nil, true)\n\texpectRun(t, `out = \"World\" > \"Hello\"`, nil, true)\n\texpectRun(t, `out = \"Hello\" >= \"World\"`, nil, false)\n\texpectRun(t, `out = \"Hello\" <= \"World\"`, nil, true)\n\texpectRun(t, `out = \"Hello\" >= \"Hello\"`, nil, true)\n\texpectRun(t, `out = \"World\" <= \"World\"`, nil, true)\n\n\t// index operator\n\tstr := \"abcdef\"\n\tstrStr := `\"abcdef\"`\n\tstrLen := 6\n\tfor idx := 0; idx < strLen; idx++ {\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d]\", strStr, idx),\n\t\t\tnil, str[idx])\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[0 + %d]\", strStr, idx),\n\t\t\tnil, str[idx])\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[1 + %d - 1]\", strStr, idx),\n\t\t\tnil, str[idx])\n\t\texpectRun(t, fmt.Sprintf(\"idx := %d; out = %s[idx]\", idx, strStr),\n\t\t\tnil, str[idx])\n\t}\n\n\texpectRun(t, fmt.Sprintf(\"%s[%d]\", strStr, -1),\n\t\tnil, tengo.UndefinedValue)\n\texpectRun(t, fmt.Sprintf(\"%s[%d]\", strStr, strLen),\n\t\tnil, tengo.UndefinedValue)\n\n\t// slice operator\n\tfor low := 0; low <= strLen; low++ {\n\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d:%d]\", strStr, low, low),\n\t\t\tnil, \"\")\n\t\tfor high := low; high <= strLen; high++ {\n\t\t\texpectRun(t, fmt.Sprintf(\"out = %s[%d:%d]\", strStr, low, high),\n\t\t\t\tnil, str[low:high])\n\t\t\texpectRun(t,\n\t\t\t\tfmt.Sprintf(\"out = %s[0 + %d : 0 + %d]\", strStr, low, high),\n\t\t\t\tnil, str[low:high])\n\t\t\texpectRun(t,\n\t\t\t\tfmt.Sprintf(\"out = %s[1 + %d - 1 : 1 + %d - 1]\",\n\t\t\t\t\tstrStr, low, high),\n\t\t\t\tnil, str[low:high])\n\t\t\texpectRun(t,\n\t\t\t\tfmt.Sprintf(\"out = %s[:%d]\", strStr, high),\n\t\t\t\tnil, str[:high])\n\t\t\texpectRun(t,\n\t\t\t\tfmt.Sprintf(\"out = %s[%d:]\", strStr, low),\n\t\t\t\tnil, str[low:])\n\t\t}\n\t}\n\n\texpectRun(t, fmt.Sprintf(\"out = %s[:]\", strStr),\n\t\tnil, str[:])\n\texpectRun(t, fmt.Sprintf(\"out = %s[:]\", strStr),\n\t\tnil, str)\n\texpectRun(t, fmt.Sprintf(\"out = %s[%d:]\", strStr, -1),\n\t\tnil, str)\n\texpectRun(t, fmt.Sprintf(\"out = %s[:%d]\", strStr, strLen+1),\n\t\tnil, str)\n\texpectRun(t, fmt.Sprintf(\"out = %s[%d:%d]\", strStr, 2, 2),\n\t\tnil, \"\")\n\n\texpectError(t, fmt.Sprintf(\"%s[:%d]\", strStr, -1),\n\t\tnil, \"invalid slice index\")\n\texpectError(t, fmt.Sprintf(\"%s[%d:]\", strStr, strLen+1),\n\t\tnil, \"invalid slice index\")\n\texpectError(t, fmt.Sprintf(\"%s[%d:%d]\", strStr, 0, -1),\n\t\tnil, \"invalid slice index\")\n\texpectError(t, fmt.Sprintf(\"%s[%d:%d]\", strStr, 2, 1),\n\t\tnil, \"invalid slice index\")\n\n\t// string concatenation with other types\n\texpectRun(t, `out = \"foo\" + 1`, nil, \"foo1\")\n\t// Float.String() returns the smallest number of digits\n\t// necessary such that ParseFloat will return f exactly.\n\texpectRun(t, `out = \"foo\" + 1.0`, nil, \"foo1\") // <- note '1' instead of '1.0'\n\texpectRun(t, `out = \"foo\" + 1.5`, nil, \"foo1.5\")\n\texpectRun(t, `out = \"foo\" + true`, nil, \"footrue\")\n\texpectRun(t, `out = \"foo\" + 'X'`, nil, \"fooX\")\n\texpectRun(t, `out = \"foo\" + error(5)`, nil, \"fooerror: 5\")\n\texpectRun(t, `out = \"foo\" + undefined`, nil, \"foo<undefined>\")\n\texpectRun(t, `out = \"foo\" + [1,2,3]`, nil, \"foo[1, 2, 3]\")\n\t// also works with \"+=\" operator\n\texpectRun(t, `out = \"foo\"; out += 1.5`, nil, \"foo1.5\")\n\t// string concats works only when string is LHS\n\texpectError(t, `1 + \"foo\"`, nil, \"invalid operation\")\n\n\texpectError(t, `\"foo\" - \"bar\"`, nil, \"invalid operation\")\n}\n\nfunc TestTailCall(t *testing.T) {\n\texpectRun(t, `\n\tfac := func(n, a) {\n\t\tif n == 1 {\n\t\t\treturn a\n\t\t}\n\t\treturn fac(n-1, n*a)\n\t}\n\tout = fac(5, 1)`, nil, 120)\n\n\texpectRun(t, `\n\tfac := func(n, a) {\n\t\tif n == 1 {\n\t\t\treturn a\n\t\t}\n\t\tx := {foo: fac} // indirection for test\n\t\treturn x.foo(n-1, n*a)\n\t}\n\tout = fac(5, 1)`, nil, 120)\n\n\texpectRun(t, `\n\tfib := func(x, s) {\n\t\tif x == 0 {\n\t\t\treturn 0 + s\n\t\t} else if x == 1 {\n\t\t\treturn 1 + s\n\t\t}\n\t\treturn fib(x-1, fib(x-2, s))\n\t}\n\tout = fib(15, 0)`, nil, 610)\n\n\texpectRun(t, `\n\tfib := func(n, a, b) {\n\t\tif n == 0 {\n\t\t\treturn a\n\t\t} else if n == 1 {\n\t\t\treturn b\n\t\t}\n\t\treturn fib(n-1, b, a + b)\n\t}\n\tout = fib(15, 0, 1)`, nil, 610)\n\n\t// global variable and no return value\n\texpectRun(t, `\n\t\t\tout = 0\n\t\t\tfoo := func(a) {\n\t\t\t   if a == 0 {\n\t\t\t       return\n\t\t\t   }\n\t\t\t   out += a\n\t\t\t   foo(a-1)\n\t\t\t}\n\t\t\tfoo(10)`, nil, 55)\n\n\texpectRun(t, `\n\tf1 := func() {\n\t\tf2 := 0    // TODO: this might be fixed in the future\n\t\tf2 = func(n, s) {\n\t\t\tif n == 0 { return s }\n\t\t\treturn f2(n-1, n + s)\n\t\t}\n\t\treturn f2(5, 0)\n\t}\n\tout = f1()`, nil, 15)\n\n\t// tail-call replacing loop\n\t// without tail-call optimization, this code will cause stack overflow\n\texpectRun(t, `\niter := func(n, max) {\n\tif n == max {\n\t\treturn n\n\t}\n\n\treturn iter(n+1, max)\n}\nout = iter(0, 9999)\n`, nil, 9999)\n\texpectRun(t, `\nc := 0\niter := func(n, max) {\n\tif n == max {\n\t\treturn\n\t}\n\n\tc++\n\titer(n+1, max)\n}\niter(0, 9999)\nout = c \n`, nil, 9999)\n}\n\n// tail call with free vars\nfunc TestTailCallFreeVars(t *testing.T) {\n\texpectRun(t, `\nfunc() {\n\ta := 10\n\tf2 := 0\n\tf2 = func(n, s) {\n\t\tif n == 0 {\n\t\t\treturn s + a\n\t\t}\n\t\treturn f2(n-1, n+s)\n\t}\n\tout = f2(5, 0)\n}()`, nil, 25)\n}\n\nfunc TestSpread(t *testing.T) {\n\texpectRun(t, `\n\tf := func(...a) {\n\t\treturn append(a, 3)\n\t}\n\tout = f([1, 2]...)\n\t`, nil, ARR{1, 2, 3})\n\n\texpectRun(t, `\n\tf := func(a, ...b) {\n\t\treturn append([a], append(b, 3)...)\n\t}\n\tout = f([1, 2]...)\n\t`, nil, ARR{1, 2, 3})\n\n\texpectRun(t, `\n\tf := func(a, ...b) {\n\t\treturn append(append([a], b), 3)\n\t}\n\tout = f(1, [2]...)\n\t`, nil, ARR{1, ARR{2}, 3})\n\n\texpectRun(t, `\n\tf1 := func(...a){\n\t\treturn append([3], a...)\n\t}\n\tf2 := func(a, ...b) {\n\t\treturn f1(append([a], b...)...)\n\t}\n\tout = f2([1, 2]...)\n\t`, nil, ARR{3, 1, 2})\n\n\texpectRun(t, `\n\tf := func(a, ...b) {\n\t\treturn func(...a) {\n\t\t\treturn append([3], append(a, 4)...)\n\t\t}(a, b...)\n\t}\n\tout = f([1, 2]...)\n\t`, nil, ARR{3, 1, 2, 4})\n\n\texpectRun(t, `\n\tf := func(a, ...b) {\n\t\tc := append(b, 4)\n\t\treturn func(){\n\t\t\treturn append(append([a], b...), c...)\n\t\t}()\n\t}\n\tout = f(1, immutable([2, 3])...)\n\t`, nil, ARR{1, 2, 3, 2, 3, 4})\n\n\texpectError(t, `func(a) {}([1, 2]...)`, nil,\n\t\t\"Runtime Error: wrong number of arguments: want=1, got=2\")\n\texpectError(t, `func(a, b, c) {}([1, 2]...)`, nil,\n\t\t\"Runtime Error: wrong number of arguments: want=3, got=2\")\n}\n\nfunc TestSliceIndex(t *testing.T) {\n\texpectError(t, `undefined[:1]`, nil, \"Runtime Error: not indexable\")\n\texpectError(t, `123[-1:2]`, nil, \"Runtime Error: not indexable\")\n\texpectError(t, `{}[:]`, nil, \"Runtime Error: not indexable\")\n\texpectError(t, `a := 123[-1:2] ; a += 1`, nil, \"Runtime Error: not indexable\")\n}\n\nfunc expectRun(\n\tt *testing.T,\n\tinput string,\n\topts *testopts,\n\texpected interface{},\n) {\n\tif opts == nil {\n\t\topts = Opts()\n\t}\n\n\tsymbols := opts.symbols\n\tmodules := opts.modules\n\tmaxAllocs := opts.maxAllocs\n\n\texpectedObj := toObject(expected)\n\n\tif symbols == nil {\n\t\tsymbols = make(map[string]tengo.Object)\n\t}\n\tsymbols[testOut] = objectZeroCopy(expectedObj)\n\n\t// first pass: run the code normally\n\t{\n\t\t// parse\n\t\tfile := parse(t, input)\n\t\tif file == nil {\n\t\t\treturn\n\t\t}\n\n\t\t// compiler/VM\n\t\tres, trace, err := traceCompileRun(file, symbols, modules, maxAllocs)\n\t\trequire.NoError(t, err, \"\\n\"+strings.Join(trace, \"\\n\"))\n\t\trequire.Equal(t, expectedObj, res[testOut],\n\t\t\t\"\\n\"+strings.Join(trace, \"\\n\"))\n\t}\n\n\t// second pass: run the code as import module\n\tif !opts.skip2ndPass {\n\t\tfile := parse(t, `out = import(\"__code__\")`)\n\t\tif file == nil {\n\t\t\treturn\n\t\t}\n\n\t\texpectedObj := toObject(expected)\n\t\tswitch eo := expectedObj.(type) {\n\t\tcase *tengo.Array:\n\t\t\texpectedObj = &tengo.ImmutableArray{Value: eo.Value}\n\t\tcase *tengo.Map:\n\t\t\texpectedObj = &tengo.ImmutableMap{Value: eo.Value}\n\t\t}\n\n\t\tmodules.AddSourceModule(\"__code__\",\n\t\t\t[]byte(fmt.Sprintf(\"out := undefined; %s; export out\", input)))\n\n\t\tres, trace, err := traceCompileRun(file, symbols, modules, maxAllocs)\n\t\trequire.NoError(t, err, \"\\n\"+strings.Join(trace, \"\\n\"))\n\t\trequire.Equal(t, expectedObj, res[testOut],\n\t\t\t\"\\n\"+strings.Join(trace, \"\\n\"))\n\t}\n}\n\nfunc expectError(\n\tt *testing.T,\n\tinput string,\n\topts *testopts,\n\texpected string,\n) {\n\tif opts == nil {\n\t\topts = Opts()\n\t}\n\n\tsymbols := opts.symbols\n\tmodules := opts.modules\n\tmaxAllocs := opts.maxAllocs\n\n\texpected = strings.TrimSpace(expected)\n\tif expected == \"\" {\n\t\tpanic(\"expected must not be empty\")\n\t}\n\n\t// parse\n\tprogram := parse(t, input)\n\tif program == nil {\n\t\treturn\n\t}\n\n\t// compiler/VM\n\t_, trace, err := traceCompileRun(program, symbols, modules, maxAllocs)\n\trequire.Error(t, err, \"\\n\"+strings.Join(trace, \"\\n\"))\n\trequire.True(t, strings.Contains(err.Error(), expected),\n\t\t\"expected error string: %s, got: %s\\n%s\",\n\t\texpected, err.Error(), strings.Join(trace, \"\\n\"))\n}\n\nfunc expectErrorIs(\n\tt *testing.T,\n\tinput string,\n\topts *testopts,\n\texpected error,\n) {\n\tif opts == nil {\n\t\topts = Opts()\n\t}\n\tsymbols := opts.symbols\n\tmodules := opts.modules\n\tmaxAllocs := opts.maxAllocs\n\n\t// parse\n\tprogram := parse(t, input)\n\tif program == nil {\n\t\treturn\n\t}\n\n\t// compiler/VM\n\t_, trace, err := traceCompileRun(program, symbols, modules, maxAllocs)\n\trequire.Error(t, err, \"\\n\"+strings.Join(trace, \"\\n\"))\n\trequire.True(t, errors.Is(err, expected),\n\t\t\"expected error is: %s, got: %s\\n%s\",\n\t\texpected.Error(), err.Error(), strings.Join(trace, \"\\n\"))\n}\n\nfunc expectErrorAs(\n\tt *testing.T,\n\tinput string,\n\topts *testopts,\n\texpected interface{},\n) {\n\tif opts == nil {\n\t\topts = Opts()\n\t}\n\tsymbols := opts.symbols\n\tmodules := opts.modules\n\tmaxAllocs := opts.maxAllocs\n\n\t// parse\n\tprogram := parse(t, input)\n\tif program == nil {\n\t\treturn\n\t}\n\n\t// compiler/VM\n\t_, trace, err := traceCompileRun(program, symbols, modules, maxAllocs)\n\trequire.Error(t, err, \"\\n\"+strings.Join(trace, \"\\n\"))\n\trequire.True(t, errors.As(err, expected),\n\t\t\"expected error as: %v, got: %v\\n%s\",\n\t\texpected, err, strings.Join(trace, \"\\n\"))\n}\n\ntype vmTracer struct {\n\tOut []string\n}\n\nfunc (o *vmTracer) Write(p []byte) (n int, err error) {\n\to.Out = append(o.Out, string(p))\n\treturn len(p), nil\n}\n\nfunc traceCompileRun(\n\tfile *parser.File,\n\tsymbols map[string]tengo.Object,\n\tmodules *tengo.ModuleMap,\n\tmaxAllocs int64,\n) (res map[string]tengo.Object, trace []string, err error) {\n\tvar v *tengo.VM\n\n\tdefer func() {\n\t\tif e := recover(); e != nil {\n\t\t\terr = fmt.Errorf(\"panic: %v\", e)\n\n\t\t\t// stack trace\n\t\t\tvar stackTrace []string\n\t\t\tfor i := 2; ; i += 1 {\n\t\t\t\t_, file, line, ok := _runtime.Caller(i)\n\t\t\t\tif !ok {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tstackTrace = append(stackTrace,\n\t\t\t\t\tfmt.Sprintf(\"  %s:%d\", file, line))\n\t\t\t}\n\n\t\t\ttrace = append(trace,\n\t\t\t\tfmt.Sprintf(\"[Error Trace]\\n\\n  %s\\n\",\n\t\t\t\t\tstrings.Join(stackTrace, \"\\n  \")))\n\t\t}\n\t}()\n\n\tglobals := make([]tengo.Object, tengo.GlobalsSize)\n\n\tsymTable := tengo.NewSymbolTable()\n\tfor name, value := range symbols {\n\t\tsym := symTable.Define(name)\n\n\t\t// should not store pointer to 'value' variable\n\t\t// which is re-used in each iteration.\n\t\tvalueCopy := value\n\t\tglobals[sym.Index] = valueCopy\n\t}\n\tfor idx, fn := range tengo.GetAllBuiltinFunctions() {\n\t\tsymTable.DefineBuiltin(idx, fn.Name)\n\t}\n\n\ttr := &vmTracer{}\n\tc := tengo.NewCompiler(file.InputFile, symTable, nil, modules, tr)\n\terr = c.Compile(file)\n\ttrace = append(trace,\n\t\tfmt.Sprintf(\"\\n[Compiler Trace]\\n\\n%s\",\n\t\t\tstrings.Join(tr.Out, \"\")))\n\tif err != nil {\n\t\treturn\n\t}\n\n\tbytecode := c.Bytecode()\n\tbytecode.RemoveDuplicates()\n\ttrace = append(trace, fmt.Sprintf(\"\\n[Compiled Constants]\\n\\n%s\",\n\t\tstrings.Join(bytecode.FormatConstants(), \"\\n\")))\n\ttrace = append(trace, fmt.Sprintf(\"\\n[Compiled Instructions]\\n\\n%s\\n\",\n\t\tstrings.Join(bytecode.FormatInstructions(), \"\\n\")))\n\n\tv = tengo.NewVM(bytecode, globals, maxAllocs)\n\n\terr = v.Run()\n\t{\n\t\tres = make(map[string]tengo.Object)\n\t\tfor name := range symbols {\n\t\t\tsym, depth, ok := symTable.Resolve(name, false)\n\t\t\tif !ok || depth != 0 {\n\t\t\t\terr = fmt.Errorf(\"symbol not found: %s\", name)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tres[name] = globals[sym.Index]\n\t\t}\n\t\ttrace = append(trace, fmt.Sprintf(\"\\n[Globals]\\n\\n%s\",\n\t\t\tstrings.Join(formatGlobals(globals), \"\\n\")))\n\t}\n\tif err == nil && !v.IsStackEmpty() {\n\t\terr = errors.New(\"non empty stack after execution\")\n\t}\n\n\treturn\n}\n\nfunc formatGlobals(globals []tengo.Object) (formatted []string) {\n\tfor idx, global := range globals {\n\t\tif global == nil {\n\t\t\treturn\n\t\t}\n\t\tformatted = append(formatted, fmt.Sprintf(\"[% 3d] %s (%s|%p)\",\n\t\t\tidx, global.String(), reflect.TypeOf(global).Elem().Name(), global))\n\t}\n\treturn\n}\n\nfunc parse(t *testing.T, input string) *parser.File {\n\ttestFileSet := parser.NewFileSet()\n\ttestFile := testFileSet.AddFile(\"test\", -1, len(input))\n\n\tp := parser.NewParser(testFile, []byte(input), nil)\n\tfile, err := p.ParseFile()\n\trequire.NoError(t, err)\n\treturn file\n}\n\nfunc errorObject(v interface{}) *tengo.Error {\n\treturn &tengo.Error{Value: toObject(v)}\n}\n\nfunc toObject(v interface{}) tengo.Object {\n\tswitch v := v.(type) {\n\tcase tengo.Object:\n\t\treturn v\n\tcase string:\n\t\treturn &tengo.String{Value: v}\n\tcase int64:\n\t\treturn &tengo.Int{Value: v}\n\tcase int: // for convenience\n\t\treturn &tengo.Int{Value: int64(v)}\n\tcase bool:\n\t\tif v {\n\t\t\treturn tengo.TrueValue\n\t\t}\n\t\treturn tengo.FalseValue\n\tcase rune:\n\t\treturn &tengo.Char{Value: v}\n\tcase byte: // for convenience\n\t\treturn &tengo.Char{Value: rune(v)}\n\tcase float64:\n\t\treturn &tengo.Float{Value: v}\n\tcase []byte:\n\t\treturn &tengo.Bytes{Value: v}\n\tcase MAP:\n\t\tobjs := make(map[string]tengo.Object)\n\t\tfor k, v := range v {\n\t\t\tobjs[k] = toObject(v)\n\t\t}\n\n\t\treturn &tengo.Map{Value: objs}\n\tcase ARR:\n\t\tvar objs []tengo.Object\n\t\tfor _, e := range v {\n\t\t\tobjs = append(objs, toObject(e))\n\t\t}\n\n\t\treturn &tengo.Array{Value: objs}\n\tcase IMAP:\n\t\tobjs := make(map[string]tengo.Object)\n\t\tfor k, v := range v {\n\t\t\tobjs[k] = toObject(v)\n\t\t}\n\n\t\treturn &tengo.ImmutableMap{Value: objs}\n\tcase IARR:\n\t\tvar objs []tengo.Object\n\t\tfor _, e := range v {\n\t\t\tobjs = append(objs, toObject(e))\n\t\t}\n\n\t\treturn &tengo.ImmutableArray{Value: objs}\n\t}\n\n\tpanic(fmt.Errorf(\"unknown type: %T\", v))\n}\n\nfunc objectZeroCopy(o tengo.Object) tengo.Object {\n\tswitch o.(type) {\n\tcase *tengo.Int:\n\t\treturn &tengo.Int{}\n\tcase *tengo.Float:\n\t\treturn &tengo.Float{}\n\tcase *tengo.Bool:\n\t\treturn &tengo.Bool{}\n\tcase *tengo.Char:\n\t\treturn &tengo.Char{}\n\tcase *tengo.String:\n\t\treturn &tengo.String{}\n\tcase *tengo.Array:\n\t\treturn &tengo.Array{}\n\tcase *tengo.Map:\n\t\treturn &tengo.Map{}\n\tcase *tengo.Undefined:\n\t\treturn tengo.UndefinedValue\n\tcase *tengo.Error:\n\t\treturn &tengo.Error{}\n\tcase *tengo.Bytes:\n\t\treturn &tengo.Bytes{}\n\tcase *tengo.ImmutableArray:\n\t\treturn &tengo.ImmutableArray{}\n\tcase *tengo.ImmutableMap:\n\t\treturn &tengo.ImmutableMap{}\n\tcase nil:\n\t\tpanic(\"nil\")\n\tdefault:\n\t\tpanic(fmt.Errorf(\"unknown object type: %s\", o.TypeName()))\n\t}\n}\n"
        }
      ]
    }
  ]
}