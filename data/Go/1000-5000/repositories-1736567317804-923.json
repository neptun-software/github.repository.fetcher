{
  "metadata": {
    "timestamp": 1736567317804,
    "page": 923,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "sourcegraph/thyme",
      "stars": 2243,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0078125,
          "content": "*~\n.bin\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.044921875,
          "content": "# How to Contribute\n\nThis Sourcegraph project is [MIT licensed](LICENSE) and accepts\ncontributions via GitHub pull requests. This document outlines some of\nthe conventions on development workflow, commit message formatting,\ncontact points and other resources to make it easier to get your\ncontribution accepted.\n\n# Certificate of Origin\n\nBy contributing to this project you agree to the Developer Certificate of Origin\n(DCO). This document was created by the Linux Kernel community and is a simple\nstatement that you, as a contributor, have the legal right to make the\ncontribution. See the [DCO](DCO) file for details.\n\n## Getting Started\n\n- Fork the repository on GitHub\n- Read the [README](README.md) for build and test instructions\n- Play with the project, submit bugs, submit patches!\n\n## Contribution Flow\n\nThis is a rough outline of what a contributor's workflow looks like:\n\n- Create a topic branch from where you want to base your work (usually master).\n- Make commits of logical units.\n- Make sure your commit messages are in the proper format (see below).\n- Push your changes to a topic branch in your fork of the repository.\n- Make sure the tests pass, and add any new tests as appropriate.\n- Submit a pull request to the original repository.\n\nThanks for your contributions!\n\n### Format of the Commit Message\n\nWe follow a rough convention for commit messages that is designed to answer two\nquestions: what changed and why. The subject line should feature the what and\nthe body of the commit should describe the why.\n\n```\nscripts: add the test-cluster command\n\nthis uses tmux to setup a test cluster that you can easily kill and\nstart for debugging.\n\nFixes #38\n```\n\nThe format can be described more formally as follows:\n\n```\n<subsystem>: <what changed>\n<BLANK LINE>\n<why this change was made>\n<BLANK LINE>\n<footer>\n```\n\nThe first line is the subject and should be no longer than 70 characters, the\nsecond line is always blank, and other lines should be wrapped at 80 characters.\nThis allows the message to be easier to read on Sourcegraph and GitHub as well\nas in various git tools.\n"
        },
        {
          "name": "DCO",
          "type": "blob",
          "size": 1.3876953125,
          "content": "Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2016 Sourcegraph\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.333984375,
          "content": "# <img alt=\"logo\" src=\"/assets/images/thyme.png\" height=\"40\"> Thyme\n\nSpice up your day-to-day productivity with some free Thyme, courtesy\nof the team at [Sourcegraph](https://sourcegraph.com) (the\n[best way to read and explore code](https://sourcegraph.com/github.com/sourcegraph/thyme/-/def/GoPackage/github.com/sourcegraph/thyme/-/Snapshot)).\nAutomatically track which applications you use and for how long.\n\n- Simple CLI to track and analyze your application usage\n- Detailed charts that let you profile how you spend your time\n- Stores data locally, giving you full control and privacy\n- [Open-source](https://sourcegraph.com/github.com/sourcegraph/thyme/-/def/GoPackage/github.com/sourcegraph/thyme/cmd/thyme/-/main.go/TrackCmd/Execute), [well-documented](https://godoc.org/github.com/sourcegraph/thyme), and easily extensible\n\nThyme is a work in progress, so please report bugs! Want to see how it works? [Dive into the source here.](https://sourcegraph.com/github.com/sourcegraph/thyme/-/def/GoPackage/github.com/sourcegraph/thyme/cmd/thyme/-/main.go/TrackCmd/Execute)\n\nWant to share what you've learned about your Thyme? Join the discussion on [Twitter](https://twitter.com/intent/tweet?url=https%3A%2F%2Fgithub.com%2Fsourcegraph%2Fthyme&original_referer=https%3A%2F%2Fgithub.com).\n\n## Features\n\n### Simple CLI\n\n1. Record which applications you use every 30 seconds:\n   ```\n   $ while true; do thyme track -o thyme.json; sleep 30s; done;\n   ```\n\n2. Create charts showing application usage over time. In a new window:\n   ```\n   $ thyme show -i thyme.json -w stats > thyme.html\n   ```\n\n3. Open `thyme.html` in your browser of choice to see the charts\n   below.\n\n### Application usage timeline\n\n![Application usage timeline](/assets/images/app_coarse.png)\n\n### Detailed application window timeline\n\n![Application usage timeline](/assets/images/app_fine.png)\n\n### Aggregate time usage by app\n\n![Application usage timeline](/assets/images/agg.png)\n\n\n## Dependencies\n\nThyme's dependencies vary by system. See `thyme dep` (mentioned in the installation instructions below).\n\n## Install\n\n1. [Install Go](https://golang.org/dl/) (if you have Homebrew on macOS, you can also run `brew install go`) and run\n   ```\n   $ go get -u github.com/sourcegraph/thyme/cmd/thyme\n   ```\n   Alternatively, if you don't want to install Go, just download the `thyme` binary [here](https://github.com/sourcegraph/thyme/releases).\n\n1. Follow the instructions printed by `thyme dep`.\n   ```\n   $ thyme dep\n   ```\n\n1. Verify `thyme` works with\n   ```\n   $ thyme track\n   ```\n   This should display JSON describing which applications are currently active, visible, and present on your system.\n\nThyme currently supports Linux, macOS, and Windows.\n\n## Usage for Other Shells\n##### Windows Powershell\n   ```\n   > for(1){thyme track -o thyme.json; Start-Sleep -s 5}\n   > thyme show -i thyme.json -w stats | Out-File -e utf8 thyme.html\n   ```\n##### Windows DOS Command Line\n   ```\n   > for /L %n in (0) do @(thyme track -o thyme.json && timeout /t 5 /nobreak)\n   > thyme show -i thyme.json -w stats > thyme.html\n   ```\n\n## Use cases\n\nThyme was designed for developers who want to investigate their\napplication usage to make decisions that boost their day-to-day\nproductivity.\n\nIt can also be for other purposes such as:\n\n- Tracking billable hours and constructing timesheets\n- Studying application usage behavior in a given population\n\n## How is Thyme different from other time trackers?\n\nThere are many time tracking products and services on the market.\nThyme differs from available offerings in the following ways:\n\n- Thyme does not intend to be a fully featured time management product\n  or service. Thyme adopts the Unix philosophy of a command-line tool\n  that does one thing well and plays nicely with other command-line\n  tools.\n\n- Thyme does not require you to manually signal when you start or stop\n  an activity. It automatically records which applications you use.\n\n- Thyme is open source and free of charge.\n\n- Thyme does not send data over the network. It stores the data it\n  collects on local disk. It's up to you whether you want to share it\n  or not.\n\n## Attribution\n\nThe [Thyme logo](https://thenounproject.com/term/thyme/356887/)\n<img alt=\"logo\" src=\"/assets/images/thyme.png\" height=\"40\"> by\n[Anthony Bossard](https://thenounproject.com/le101edaltonien/) is\nlicensed under\n[Creative Commons 3.0](https://creativecommons.org/licenses/by/3.0/us/).\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "darwin.go",
          "type": "blob",
          "size": 6.986328125,
          "content": "package thyme\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"hash/fnv\"\n\t\"log\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc init() {\n\tRegisterTracker(\"darwin\", NewDarwinTracker)\n}\n\n// DarwinTracker tracks application usage using the \"System Events\" API in AppleScript. Due to the liminations of this\n// API, the DarwinTracker will not be able to detect individual windows of applications that are not scriptable (in the\n// AppleScript sense). For these applications, a single window is emitted with the name set to the application process\n// name and the ID set to the process ID.\ntype DarwinTracker struct{}\n\nvar _ Tracker = (*DarwinTracker)(nil)\n\nfunc NewDarwinTracker() Tracker {\n\treturn &DarwinTracker{}\n}\n\n// allWindowsScript fetches the windows of all scriptable applications.  It\n// iterates through each application process known to System Events and attempts\n// to script the application with the same name as the application process. If\n// such an application exists and is scriptable, it prints the name of every\n// window in the application. Otherwise, it just prints the name of every\n// visible window in the application. If no visible windows exist, it will just\n// print the application name.  (System Events processes only have windows in\n// the current desktop/workspace.)\nconst (\n\tallWindowsScript = `\ntell application \"System Events\"\n  set listOfProcesses to (every application process where background only is false)\nend tell\n\nrepeat with proc in listOfProcesses\n  set procName to (name of proc)\n  set procID to (id of proc)\n  log \"PROCESS \" & procID & \":\" & procName\n  -- Attempt to list windows if the process is scriptable\n  try\n    tell application procName\n      repeat with i from 1 to (count windows)\n        log \"WINDOW \" & (id of window i) & \":\" & (name of window i) as string\n      end repeat\n    end tell\n  end try\nend repeat\n`\n\tactiveWindowsScript = `\ntell application \"System Events\"\n     set proc to (first application process whose frontmost is true)\nend tell\n\nset procName to (name of proc)\ntry\n  tell application procName\n     log \"WINDOW \" & (id of window 1) & \":\" & (name of window 1)\n  end tell\non error e\n  log \"WINDOW \" & (id of proc) & \":\" & (name of first window of proc)\nend try\n`\n\t// visibleWindowsScript generates a mapping from process to windows in the\n\t// current desktop (note: this is slightly different than the behavior of\n\t// the previous two scripts, where an empty windows list for a process\n\t// should NOT imply that there is one window named after the process.\n\t// Furthermore, the window IDs are not valid in this script (only the window\n\t// name is valid).\n\tvisibleWindowsScript = `\ntell application \"System Events\"\n\tset listOfProcesses to (every process whose visible is true)\nend tell\nrepeat with proc in listOfProcesses\n\tset procName to (name of proc)\n\tset procID to (id of proc)\n\tlog \"PROCESS \" & procID & \":\" & procName\n\tset app_windows to (every window of proc)\n\trepeat with each_window in app_windows\n\t\tlog \"WINDOW -1:\" & (name of each_window) as string\n\tend repeat\nend repeat\n`\n)\n\nfunc (t *DarwinTracker) Deps() string {\n\treturn `\nYou will need to enable privileges for \"Terminal\" in System Preferences > Security & Privacy > Privacy > Accessibility.\nSee https://support.apple.com/en-us/HT202802 for details.\n\nNote: this command prints out this message regardless of whether this has been done or not.\n`\n}\n\nfunc (t *DarwinTracker) Snap() (*Snapshot, error) {\n\tvar allWindows []*Window\n\tvar allProcWins map[process][]*Window\n\t{\n\t\tprocWins, err := runAS(allWindowsScript)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor proc, wins := range procWins {\n\t\t\tif len(wins) == 0 {\n\t\t\t\tallWindows = append(allWindows, &Window{ID: proc.id, Name: proc.name})\n\t\t\t} else {\n\t\t\t\tallWindows = append(allWindows, wins...)\n\t\t\t}\n\t\t}\n\t\tallProcWins = procWins\n\t}\n\n\tvar active int64\n\t{\n\t\tprocWins, err := runAS(activeWindowsScript)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(procWins) > 1 {\n\t\t\treturn nil, fmt.Errorf(\"found more than one active process: %+v\", procWins)\n\t\t}\n\t\tfor proc, wins := range procWins {\n\t\t\tif len(wins) == 0 {\n\t\t\t\tactive = proc.id\n\t\t\t} else if len(wins) == 1 {\n\t\t\t\tactive = wins[0].ID\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"found more than one active window: %+v\", wins)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar visible []int64\n\t{\n\t\tprocWins, err := runAS(visibleWindowsScript)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfor proc, wins := range procWins {\n\t\t\tallWins := allProcWins[proc]\n\t\t\tfor _, visWin := range wins {\n\t\t\t\tif len(allWins) == 0 {\n\t\t\t\t\tvisible = append(visible, proc.id)\n\t\t\t\t} else {\n\t\t\t\t\tfound := false\n\t\t\t\t\tfor _, win := range allWins {\n\t\t\t\t\t\tif win.Name == visWin.Name {\n\t\t\t\t\t\t\tvisible = append(visible, win.ID)\n\t\t\t\t\t\t\tfound = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !found {\n\t\t\t\t\t\tlog.Printf(\"warning: window ID not found for visible window %q\", visWin.Name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &Snapshot{\n\t\tTime:    time.Now(),\n\t\tWindows: allWindows,\n\t\tActive:  active,\n\t\tVisible: visible,\n\t}, nil\n}\n\n// process is the {name, id} of a process\ntype process struct {\n\tname string\n\tid   int64\n}\n\n// runAS runs script as AppleScript and parses the output into a map of\n// processes to windows.\nfunc runAS(script string) (map[process][]*Window, error) {\n\tcmd := exec.Command(\"osascript\")\n\tcmd.Stdin = bytes.NewBuffer([]byte(script))\n\tb, err := cmd.CombinedOutput()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"AppleScript error: %s, output was:\\n%s\", err, string(b))\n\t}\n\treturn parseASOutput(string(b))\n}\n\n// parseASOutput parses the output of the AppleScript snippets used to extract window information.\nfunc parseASOutput(out string) (map[process][]*Window, error) {\n\tproc := process{}\n\tprocWins := make(map[process][]*Window)\n\tfor _, line := range strings.Split(out, \"\\n\") {\n\t\tif strings.HasPrefix(line, \"PROCESS \") {\n\t\t\tc := strings.Index(line, \":\")\n\t\t\tprocID, err := strconv.ParseInt(line[len(\"PROCESS \"):c], 10, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tproc = process{line[c+1:], procID}\n\t\t\tprocWins[proc] = nil\n\t\t} else if strings.HasPrefix(line, \"WINDOW \") {\n\t\t\twin, winID := parseWindowLine(line, proc.id)\n\t\t\tprocWins[proc] = append(procWins[proc],\n\t\t\t\t&Window{ID: winID, Name: fmt.Sprintf(\"%s - %s\", win, proc.name)},\n\t\t\t)\n\t\t}\n\t}\n\treturn procWins, nil\n}\n\n// parseWindowLine parses window ID from a line of the AppleScript\n// output. If the ID is missing (\"missing value\"), parseWindowLine\n// will return the hash of the window title and process ID. Note: if 2\n// windows controlled by the same process both have IDs missing and\n// have the same title, they will hash to the same ID. This is\n// unfortunate but seems to be the best behavior.\nfunc parseWindowLine(line string, procId int64) (string, int64) {\n\tc := strings.Index(line, \":\")\n\twin := line[c+1:]\n\twinID, err := strconv.ParseInt(line[len(\"WINDOW \"):c], 10, 0)\n\tif err != nil {\n\t\t// sometimes \"missing value\" appears here, so generate a value\n\t\t// taking the process ID and the window index to generate a hash\n\t\twinID = hash(fmt.Sprintf(\"%s%v\", win, procId))\n\t}\n\treturn win, winID\n}\n\n// hash converts a string to an integer hash\nfunc hash(s string) int64 {\n\th := fnv.New32a()\n\th.Write([]byte(s))\n\treturn int64(h.Sum32())\n}\n"
        },
        {
          "name": "data.go",
          "type": "blob",
          "size": 6.626953125,
          "content": "package thyme\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\t\"time\"\n)\n\n// trackers is the list of Tracker constructors that are available on this system. Tracker implementations should call\n// the RegisterTracker function to make themselves available.\nvar trackers = make(map[string]func() Tracker)\n\n// RegisterTracker makes a Tracker constructor available to clients of this package.\nfunc RegisterTracker(name string, t func() Tracker) {\n\tif _, exists := trackers[name]; exists {\n\t\tlog.Fatalf(\"a tracker already exists with the name %s\", name)\n\t}\n\ttrackers[name] = t\n}\n\n// NewTracker returns a new Tracker instance whose type is `name`.\nfunc NewTracker(name string) Tracker {\n\tif _, exists := trackers[name]; !exists {\n\t\tlog.Fatalf(\"no Tracker constructor has been registered with name %s\", name)\n\t}\n\treturn trackers[name]()\n}\n\n// Tracker tracks application usage. An implementation that satisfies\n// this interface is required for each OS windowing system Thyme\n// supports.\ntype Tracker interface {\n\t// Snap returns a Snapshot reflecting the currently in-use windows\n\t// at the current time.\n\tSnap() (*Snapshot, error)\n\n\t// Deps returns a string listing the dependencies that still need\n\t// to be installed with instructions for how to install them.\n\tDeps() string\n}\n\n// Stream represents all the sampling data gathered by Thyme.\ntype Stream struct {\n\t// Snapshots is a list of window snapshots ordered by time.\n\tSnapshots []*Snapshot\n}\n\n// Print returns a pretty-printed representation of the snapshot.\nfunc (s Stream) Print() string {\n\tvar b bytes.Buffer\n\tfor _, snap := range s.Snapshots {\n\t\tfmt.Fprintf(&b, \"%s\", snap.Print())\n\t}\n\treturn string(b.Bytes())\n}\n\n// Snapshot represents the current state of all in-use application\n// windows at a moment in time.\ntype Snapshot struct {\n\tTime    time.Time\n\tWindows []*Window\n\tActive  int64\n\tVisible []int64\n}\n\n// Print returns a pretty-printed representation of the snapshot.\nfunc (s Snapshot) Print() string {\n\tvar b bytes.Buffer\n\n\tvar active *Window\n\tvisible := make([]*Window, 0, len(s.Windows))\n\tother := make([]*Window, 0, len(s.Windows))\ns_Windows:\n\tfor _, w := range s.Windows {\n\t\tif w.ID == s.Active {\n\t\t\tactive = w\n\t\t\tcontinue s_Windows\n\t\t}\n\t\tfor _, v := range s.Visible {\n\t\t\tif w.ID == v {\n\t\t\t\tvisible = append(visible, w)\n\t\t\t\tcontinue s_Windows\n\t\t\t}\n\t\t}\n\t\tother = append(other, w)\n\t}\n\n\tfmt.Fprintf(&b, \"%s\\n\", s.Time.Format(\"Mon Jan 2 15:04:05 -0700 MST 2006\"))\n\tif active != nil {\n\t\tfmt.Fprintf(&b, \"\\tActive: %s\\n\", active.Info().Print())\n\t}\n\tif len(visible) > 0 {\n\t\tfmt.Fprintf(&b, \"\\tVisible: \")\n\t\tfor _, v := range visible {\n\t\t\tfmt.Fprintf(&b, \"%s, \", v.Info().Print())\n\t\t}\n\t\tfmt.Fprintf(&b, \"\\n\")\n\t}\n\tif len(other) > 0 {\n\t\tfmt.Fprintf(&b, \"\\tOther: \")\n\t\tfor _, w := range other {\n\t\t\tfmt.Fprintf(&b, \"%s, \", w.Info().Print())\n\t\t}\n\t\tfmt.Fprintf(&b, \"\\n\")\n\t}\n\treturn string(b.Bytes())\n}\n\n// Window represents an application window.\ntype Window struct {\n\t// ID is the numerical identifier of the window.\n\tID int64\n\n\t// Desktop is the numerical identifier of the desktop the\n\t// window belongs to.  Equal to -1 if the window is sticky.\n\tDesktop int64\n\n\t// Name is the display name of the window (typically what the\n\t// windowing system shows in the top bar of the window).\n\tName string\n}\n\n// systemNames is a set of excluded window names that are known to\n// be used by system windows that aren't visible to the user.\nvar systemNames = map[string]struct{}{\n\t\"XdndCollectionWindowImp\": {},\n\t\"unity-launcher\":          {},\n\t\"unity-panel\":             {},\n\t\"unity-dash\":              {},\n\t\"Hud\":                     {},\n\t\"Desktop\":                 {},\n}\n\n// IsSystem returns true if the window is a system window (like\n// \"unity-panel\" and thus shouldn't be considered an application\n// visible to the end-users)\nfunc (w *Window) IsSystem() bool {\n\tif _, is := systemNames[w.Name]; is {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// IsSticky returns true if the window is a sticky window (i.e.\n// present on all desktops)\nfunc (w *Window) IsSticky() bool {\n\treturn w.Desktop == -1\n}\n\n// IsOnDesktop returns true if the window is present on the specified\n// desktop\nfunc (w *Window) IsOnDesktop(desktop int64) bool {\n\treturn w.IsSticky() || w.Desktop == desktop\n}\n\nconst (\n\tdefaultWindowTitleSeparator       = \" - \"\n\tmicrosoftEdgeWindowTitleSeparator = \"\\u200e- \"\n)\n\n// Info returns more structured metadata about a window. The metadata\n// is extracted using heuristics.\n//\n// Assumptions:\n//     1) Most windows use \" - \" to separate their window names from their content\n//     2) Most windows use the \" - \" with the application name at the end.\n//     3) The few programs that reverse this convention only reverse it.\nfunc (w *Window) Info() *Winfo {\n\t// Special Cases\n\tfields := strings.Split(w.Name, defaultWindowTitleSeparator)\n\tif len(fields) > 1 {\n\t\tlast := strings.TrimSpace(fields[len(fields)-1])\n\t\tif last == \"Google Chrome\" {\n\t\t\treturn &Winfo{\n\t\t\t\tApp:    \"Google Chrome\",\n\t\t\t\tSubApp: strings.TrimSpace(fields[len(fields)-2]),\n\t\t\t\tTitle:  strings.Join(fields[0:len(fields)-2], defaultWindowTitleSeparator),\n\t\t\t}\n\t\t}\n\t}\n\n\tif strings.Contains(w.Name, microsoftEdgeWindowTitleSeparator) {\n\t\t// App Name Last\n\t\tbeforeSep := strings.LastIndex(w.Name, microsoftEdgeWindowTitleSeparator)\n\t\tafterSep := beforeSep + len(microsoftEdgeWindowTitleSeparator)\n\t\treturn &Winfo{\n\t\t\tApp:   strings.TrimSpace(w.Name[afterSep:]),\n\t\t\tTitle: strings.TrimSpace(w.Name[:beforeSep]),\n\t\t}\n\t}\n\n\t// Normal Cases\n\tif beforeSep := strings.Index(w.Name, defaultWindowTitleSeparator); beforeSep > -1 {\n\t\t// App Name First\n\t\tif w.Name[:beforeSep] == \"Slack\" {\n\t\t\tafterSep := beforeSep + len(defaultWindowTitleSeparator)\n\t\t\treturn &Winfo{\n\t\t\t\tApp:   strings.TrimSpace(w.Name[:beforeSep]),\n\t\t\t\tTitle: strings.TrimSpace(w.Name[afterSep:]),\n\t\t\t}\n\t\t}\n\n\t\t// App Name Last\n\t\tbeforeSep := strings.LastIndex(w.Name, defaultWindowTitleSeparator)\n\t\tafterSep := beforeSep + len(defaultWindowTitleSeparator)\n\t\treturn &Winfo{\n\t\t\tApp:   strings.TrimSpace(w.Name[afterSep:]),\n\t\t\tTitle: strings.TrimSpace(w.Name[:beforeSep]),\n\t\t}\n\t}\n\n\t// No Application name separator\n\treturn &Winfo{\n\t\tTitle: w.Name,\n\t}\n}\n\n// Winfo is structured metadata info about a window.\ntype Winfo struct {\n\t// App is the application that controls the window.\n\tApp string\n\n\t// SubApp is the sub-application that controls the window. An\n\t// example is a web app (e.g., Sourcegraph) that runs\n\t// inside a Chrome tab. In this case, the App field would be\n\t// \"Google Chrome\" and the SubApp field would be \"Sourcegraph\".\n\tSubApp string\n\n\t// Title is the title of the window after the App and SubApp name\n\t// have been stripped.\n\tTitle string\n}\n\n// Print returns a pretty-printed representation of the snapshot.\nfunc (w Winfo) Print() string {\n\treturn fmt.Sprintf(\"[%s|%s|%s]\", w.App, w.SubApp, w.Title)\n}\n"
        },
        {
          "name": "linux.go",
          "type": "blob",
          "size": 4.9189453125,
          "content": "package thyme\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc init() {\n\tRegisterTracker(\"linux\", NewLinuxTracker)\n}\n\n// LinuxTracker tracks application usage on Linux via a few standard command-line utilities.\ntype LinuxTracker struct{}\n\nvar _ Tracker = (*LinuxTracker)(nil)\n\nfunc NewLinuxTracker() Tracker {\n\treturn &LinuxTracker{}\n}\n\nfunc (t *LinuxTracker) Deps() string {\n\treturn `\nInstall the following command-line utilities via your package manager of choice:\n* xdpyinfo\n* xwininfo\n* xdotool\n* wmctrl\n\nFor example:\n* Debian: apt-get install x11-utils xdotool wmctrl\n\nNote: this command prints out this message regardless of whether the dependencies are already installed.\n`\n}\n\nfunc (t *LinuxTracker) Snap() (*Snapshot, error) {\n\tvar viewWidth, viewHeight int\n\t{\n\t\tout, err := exec.Command(\"bash\", \"-c\", \"xdpyinfo | grep dimensions\").Output()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"xdpyinfo failed with error: %s. Try running `xdpyinfo | grep dimensions` to diagnose.\", err)\n\t\t}\n\t\tmatches := dimRx.FindStringSubmatch(string(out))\n\t\tif len(matches) != 3 {\n\t\t\treturn nil, fmt.Errorf(\"could not parse viewport dimensions from output line %q\", string(out))\n\t\t}\n\t\tw, err := strconv.Atoi(matches[1])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\th, err := strconv.Atoi(matches[2])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tviewWidth, viewHeight = w, h\n\t}\n\n\tvar windows []*Window\n\t{\n\t\tout, err := exec.Command(\"wmctrl\", \"-l\").Output()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"wmctrl failed with error: %s. Try running `wmctrl -l` to diagnose.\", err)\n\t\t}\n\t\tlines := strings.Split(string(out), \"\\n\")\n\t\tfor _, line := range lines {\n\t\t\tfields := strings.Fields(line)\n\t\t\tif len(fields) < 4 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tid_, desktop_, name := fields[0], fields[1], strings.Join(fields[3:], \" \")\n\t\t\tid, err := strconv.ParseInt(id_, 0, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdesktop, err := strconv.ParseInt(desktop_, 0, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tw := Window{ID: id, Desktop: desktop, Name: name}\n\t\t\tif !w.IsSystem() {\n\t\t\t\twindows = append(windows, &w)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar currentDesktop int64\n\t{\n\t\tout, err := exec.Command(\"wmctrl\", \"-d\").Output()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tlines := strings.Split(string(out), \"\\n\")\n\t\tfor _, line := range lines {\n\t\t\tfields := strings.Fields(line)\n\t\t\tif len(fields) < 2 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tid_, mode := fields[0], fields[1]\n\t\t\tid, err := strconv.ParseInt(id_, 0, 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif \"*\" == mode {\n\t\t\t\tcurrentDesktop = id\n\t\t\t}\n\t\t}\n\t}\n\n\tvar visible []int64\n\t{\n\t\tfor _, window := range windows {\n\t\t\tout_, err := exec.Command(\"xwininfo\", \"-id\", fmt.Sprintf(\"%d\", window.ID), \"-stats\").Output()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"xwininfo failed with error: %s\", err)\n\t\t\t}\n\t\t\tout := string(out_)\n\t\t\tx, err := parseWinDim(xRx, out, \"X\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ty, err := parseWinDim(yRx, out, \"Y\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tw, err := parseWinDim(wRx, out, \"W\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\th, err := parseWinDim(hRx, out, \"H\")\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif window.IsOnDesktop(currentDesktop) && isVisible(x, y, w, h, viewHeight, viewWidth) {\n\t\t\t\tvisible = append(visible, window.ID)\n\t\t\t}\n\t\t}\n\t}\n\n\tvar active int64\n\t{\n\t\tout, err := exec.Command(\"xdotool\", \"getactivewindow\").Output()\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"xdotool failed with error: %s. Try running `xdotool getactivewindow` to diagnose.\", err)\n\t\t}\n\t\tid, err := strconv.ParseInt(strings.TrimSpace(string(out)), 10, 64)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tactive = id\n\t}\n\n\treturn &Snapshot{Windows: windows, Active: active, Visible: visible, Time: time.Now()}, nil\n}\n\n// isVisible checks if the window is visible in the current viewport.\n// x and y are assumed to be relative to the current viewport (i.e.,\n// (0, 0) is the coordinate of the top-left corner of the current\n// viewport.\nfunc isVisible(x, y, w, h, viewHeight, viewWidth int) bool {\n\treturn (0 <= x && x < viewWidth && 0 <= y && y < viewHeight) ||\n\t\t(0 <= x+w && x+w < viewWidth && 0 <= y && y < viewHeight) ||\n\t\t(0 <= x && x < viewWidth && 0 <= y+h && y+h < viewHeight) ||\n\t\t(0 <= x+w && x+w < viewWidth && 0 <= y+h && y+h < viewHeight)\n}\n\nvar (\n\tdimRx = regexp.MustCompile(`dimensions:\\s+([0-9]+)x([0-9]+)\\s+pixels`)\n\txRx   = regexp.MustCompile(`Absolute upper\\-left X:\\s+(\\-?[0-9]+)`)\n\tyRx   = regexp.MustCompile(`Absolute upper\\-left Y:\\s+(\\-?[0-9]+)`)\n\twRx   = regexp.MustCompile(`Width:\\s+([0-9]+)`)\n\thRx   = regexp.MustCompile(`Height:\\s+([0-9]+)`)\n)\n\n// parseWinDim parses window dimension info from the output of `xwininfo`\nfunc parseWinDim(rx *regexp.Regexp, out string, varname string) (int, error) {\n\tif matches := rx.FindStringSubmatch(out); len(matches) == 2 {\n\t\tn, err := strconv.Atoi(matches[1])\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn n, nil\n\t} else {\n\t\treturn 0, fmt.Errorf(\"could not parse window %s from output %s\", varname, out)\n\t}\n\n}\n"
        },
        {
          "name": "list.go",
          "type": "blob",
          "size": 0.0908203125,
          "content": "package thyme\n\nimport \"fmt\"\n\nfunc List(stream *Stream) {\n\tfmt.Printf(\"%s\", stream.Print())\n}\n"
        },
        {
          "name": "release.sh",
          "type": "blob",
          "size": 0.1689453125,
          "content": "#!/bin/bash\n\nfor os in darwin windows linux; do\n    for arch in 386; do\n        env GOOS=\"$os\" GOARCH=\"$arch\" go build -o \"./.bin/thyme-$os-$arch\" ./cmd/thyme\n    done\ndone\n"
        },
        {
          "name": "show.go",
          "type": "blob",
          "size": 11.0087890625,
          "content": "package thyme\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"sort\"\n\t\"strconv\"\n\t\"text/template\"\n\t\"time\"\n)\n\nconst maxNumberOfBars = 30\n\n// Stats renders an HTML page with charts using stream as its data\n// source. Currently, it renders the following charts:\n// 1. A timeline of applications active, visible, and open\n// 2. A timeline of windows active, visible, and open\n// 3. A barchart of applications most often active, visible, and open\nfunc Stats(stream *Stream) error {\n\ttlFine := NewTimeline(stream, func(w *Window) string { return w.Name })\n\ttlCoarse := NewTimeline(stream, appID)\n\tagg := NewAggTime(stream, appID)\n\n\tif err := statsTmpl.Execute(os.Stdout, &statsPage{\n\t\tFine:   tlFine,\n\t\tCoarse: tlCoarse,\n\t\tAgg:    agg,\n\t}); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// AggTime is the list of bar charts that convey aggregate application time usage.\ntype AggTime struct {\n\tCharts []*BarChart\n}\n\n// NewAggTime returns a new AggTime created from a Stream.\nfunc NewAggTime(stream *Stream, labelFunc func(*Window) string) *AggTime {\n\tn := strconv.Itoa(maxNumberOfBars)\n\tactive := NewBarChart(\"Active\", \"App\", \"Samples\", \"Top \"+n+\" active applications by time (multiplied by window count)\")\n\tvisible := NewBarChart(\"Visible\", \"App\", \"Samples\", \"Top \"+n+\" visible applications by time (multiplied by window count)\")\n\tall := NewBarChart(\"All\", \"App\", \"Samples\", \"Top \"+n+\" open applications by time (multiplied by window count)\")\n\tfor _, snap := range stream.Snapshots {\n\t\twindows := make(map[int64]*Window)\n\t\tfor _, win := range snap.Windows {\n\t\t\twindows[win.ID] = win\n\t\t}\n\n\t\tif win := windows[snap.Active]; win != nil {\n\t\t\tactive.Plus(labelFunc(windows[snap.Active]), 1)\n\t\t}\n\t\tfor _, v := range snap.Visible {\n\t\t\tvisible.Plus(labelFunc(windows[v]), 1)\n\t\t}\n\t\tfor _, win := range snap.Windows {\n\t\t\tall.Plus(labelFunc(win), 1)\n\t\t}\n\t}\n\treturn &AggTime{Charts: []*BarChart{active, visible, all}}\n}\n\n// BarChart is a representation of a bar chart.\ntype BarChart struct {\n\tID     string\n\tYLabel string\n\tXLabel string\n\tTitle  string\n\tSeries map[string]int\n}\n\n// Bar represents a single bar in a bar chart.\ntype Bar struct {\n\tLabel string\n\tCount int\n}\n\n// NewBarChart returns a new BarChart with the specified ID, x- and\n// y-axis label, and title.\nfunc NewBarChart(id, x, y, title string) *BarChart {\n\treturn &BarChart{ID: id, XLabel: x, YLabel: y, Title: title, Series: make(map[string]int)}\n}\n\n// Plus adds n to the count associated with the label.\nfunc (c *BarChart) Plus(label string, n int) {\n\tc.Series[label] += n\n}\n\n// OrderedBars returns a list of the top $maxNumberOfBars bars in the bar chart ordered by\n// decreasing count.\nfunc (c *BarChart) OrderedBars() []Bar {\n\tvar bars []Bar\n\tfor l, c := range c.Series {\n\t\tbars = append(bars, Bar{Label: l, Count: c})\n\t}\n\ts := sortBars{bars}\n\tsort.Sort(s)\n\tnumberOfBars := maxNumberOfBars\n\tif numberOfBars > len(s.bars) {\n\t\tnumberOfBars = len(s.bars)\n\t}\n\treturn s.bars[:numberOfBars]\n}\n\ntype sortBars struct {\n\tbars []Bar\n}\n\nfunc (s sortBars) Len() int           { return len(s.bars) }\nfunc (s sortBars) Less(a, b int) bool { return s.bars[a].Count > s.bars[b].Count }\nfunc (s sortBars) Swap(a, b int)      { s.bars[a], s.bars[b] = s.bars[b], s.bars[a] }\n\n// Timeline represents a timeline of application usage.\n// Start is the start time of the timeline.\n// End is the end time of the timeline.\n// Rows is a map where the keys are tags and the values are lists of\n// time ranges. Each row is a distinct sub-timeline.\ntype Timeline struct {\n\tStart time.Time\n\tEnd   time.Time\n\tRows  map[string][]*Range\n}\n\n// Range represents a labeled range of time.\ntype Range struct {\n\tLabel string\n\tStart time.Time\n\tEnd   time.Time\n}\n\n// NewTimeline returns a new Timeline created from the specified\n// Stream. labelFunc is used to determine the ID string to be used for\n// a given Window. If you're tracking events by app, this ID should\n// reflect the identity of the window's application. If you're\n// tracking events by window name, the ID should be the window name.\nfunc NewTimeline(stream *Stream, labelFunc func(*Window) string) *Timeline {\n\tif len(stream.Snapshots) == 0 {\n\t\treturn nil\n\t}\n\tvar active, visible, other []*Range\n\tvar lastActive *Range\n\tvar lastVisible, lastOther = make(map[string]*Range), make(map[string]*Range)\n\tfor _, snap := range stream.Snapshots {\n\t\twindows := make(map[int64]*Window)\n\t\tfor _, win := range snap.Windows {\n\t\t\twindows[win.ID] = win\n\t\t}\n\n\t\t{\n\t\t\tif win := windows[snap.Active]; win != nil {\n\t\t\t\twinLabel := labelFunc(win)\n\t\t\t\tif lastActive != nil && lastActive.Label == winLabel {\n\t\t\t\t\tlastActive.End = snap.Time\n\t\t\t\t} else {\n\t\t\t\t\tif lastActive != nil {\n\t\t\t\t\t\tlastActive.End = snap.Time\n\t\t\t\t\t}\n\t\t\t\t\tnewRange := &Range{Label: winLabel, Start: snap.Time, End: snap.Time}\n\t\t\t\t\tactive = append(active, newRange)\n\t\t\t\t\tlastActive = newRange\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlastActive = nil\n\t\t\t}\n\t\t}\n\n\t\tfor _, prevRange := range lastVisible {\n\t\t\tprevRange.End = snap.Time\n\t\t}\n\t\tnextVisible := make(map[string]*Range)\n\t\tfor _, v := range snap.Visible {\n\t\t\tvar winLabel string\n\t\t\tif win := windows[v]; win != nil {\n\t\t\t\twinLabel = labelFunc(win)\n\t\t\t}\n\t\t\tif existRng, exists := lastVisible[winLabel]; !exists {\n\t\t\t\tnewRange := &Range{Label: winLabel, Start: snap.Time, End: snap.Time}\n\t\t\t\tnextVisible[winLabel] = newRange\n\t\t\t\tvisible = append(visible, newRange)\n\t\t\t} else {\n\t\t\t\tnextVisible[winLabel] = existRng\n\t\t\t}\n\t\t}\n\t\tlastVisible = nextVisible\n\n\t\tfor _, prevRange := range lastOther {\n\t\t\tprevRange.End = snap.Time\n\t\t}\n\t\tnextOther := make(map[string]*Range)\n\t\tfor _, win := range snap.Windows {\n\t\t\twinLabel := labelFunc(win)\n\t\t\tif existRng, exists := lastOther[winLabel]; !exists {\n\t\t\t\tnewRange := &Range{Label: winLabel, Start: snap.Time, End: snap.Time}\n\t\t\t\tnextOther[winLabel] = newRange\n\t\t\t\tother = append(other, newRange)\n\t\t\t} else {\n\t\t\t\tnextOther[winLabel] = existRng\n\t\t\t}\n\t\t}\n\t\tlastOther = nextOther\n\t}\n\treturn &Timeline{\n\t\tStart: stream.Snapshots[0].Time,\n\t\tEnd:   stream.Snapshots[len(stream.Snapshots)-1].Time,\n\t\tRows:  map[string][]*Range{\"Active\": active, \"Visible\": visible, \"All\": other},\n\t}\n}\n\n// timeToJS is a template helper function that converts a time.Time to\n// code that creates a JavaScript Date object.\nfunc timeToJS(t time.Time) string {\n\treturn fmt.Sprintf(`new Date(%d, %d, %d, %d, %d, %d)`, t.Year(), t.Month(), t.Day(), t.Hour(), t.Minute(), t.Second())\n}\n\n// statsPage is the data rendered in statsTmpl.\ntype statsPage struct {\n\tFine   *Timeline\n\tCoarse *Timeline\n\tAgg    *AggTime\n}\n\n// statsTmpl is the HTML template for the page rendered by the `Stats`\n// function.\nvar statsTmpl = template.Must(template.New(\"\").Funcs(map[string]interface{}{\n\t\"timeToJS\": timeToJS,\n}).Parse(`<html>\n  <head>\n\t<meta charset=\"utf-8\">\n\t<style>\n\t\t.description {\n\t\t\tfont-family: Roboto;\n\t\t\tfont-size: 16px;\n\t\t\tpadding: 16px 0;\n\t\t\tcolor: rgb(117, 117, 117);\n\t\t}\n\t</style>\n\n    <script type=\"text/javascript\" src=\"https://www.gstatic.com/charts/loader.js\"></script>\n    <script type=\"text/javascript\">\n      google.charts.load('current', {'packages':['corechart', 'bar', 'timeline']});\n\t</script>\n\n\t{{with .Coarse}}\n    <script type=\"text/javascript\">\n      google.charts.setOnLoadCallback(drawChartCoarse);\n      function drawChartCoarse() {\n        var container = document.getElementById('timeline_coarse');\n        var chart = new google.visualization.Timeline(container);\n        var dataTable = new google.visualization.DataTable();\n\n        dataTable.addColumn({ type: 'string', id: 'Status' });\n\t\tdataTable.addColumn({ type: 'string', id: 'Name' });\n        dataTable.addColumn({ type: 'date', id: 'Start' });\n        dataTable.addColumn({ type: 'date', id: 'End' });\n        dataTable.addRows([\n\t\t{{range .Rows.Active}}\n\t\t\t[\n\t\t\t\t\"Active\",\n\t\t\t\t{{printf \"%q\" .Label}},\n\t\t\t\t{{timeToJS .Start}},\n\t\t\t\t{{timeToJS .End}},\n\t\t\t],\n\t\t{{end}}\n\t\t{{range .Rows.Visible}}\n\t\t\t[\n\t\t\t\t\"Visible\",\n\t\t\t\t{{printf \"%q\" .Label}},\n\t\t\t\t{{timeToJS .Start}},\n\t\t\t\t{{timeToJS .End}},\n\t\t\t],\n\t\t{{end}}\n\t\t{{range .Rows.All}}\n\t\t\t[\n\t\t\t\t\"All\",\n\t\t\t\t{{printf \"%q\" .Label}},\n\t\t\t\t{{timeToJS .Start}},\n\t\t\t\t{{timeToJS .End}},\n\t\t\t],\n\t\t{{end}}\n\t\t]);\n\n\t\tvar options = {\n\t\t\ttimeline: { showRowLabels: true },\n\t\t};\n        chart.draw(dataTable, options);\n      }\n    </script>\n\t{{end}}\n\n\t{{range $chart := .Agg.Charts}}\n\t<script type=\"text/javascript\">\n\tgoogle.charts.setOnLoadCallback(drawBarChart{{$chart.ID}});\n\tfunction drawBarChart{{$chart.ID}}() {\n      var data = google.visualization.arrayToDataTable([\n        ['Application', 'Number of samples'],\n\t\t{{range $chart.OrderedBars}}\n\t\t[{{printf \"%q\" .Label}}, {{.Count}}],\n\t\t{{end}}\n      ]);\n\n      var options = {\n        chart: {\n          title: '{{$chart.Title}}'\n        },\n\t\tlegend: { position: \"none\" },\n        hAxis: {\n          title: '{{$chart.YLabel}}',\n          minValue: 0,\n        },\n        vAxis: {\n          title: '{{$chart.XLabel}}'\n        },\n        bars: 'horizontal',\n        height: 600\n      };\n      var material = new google.charts.Bar(document.getElementById('bar_chart_{{$chart.ID}}'));\n      material.draw(data, options);\n    }\n\t</script>\n\t{{end}}\n\n\t{{with .Fine}}\n    <script type=\"text/javascript\">\n      google.charts.setOnLoadCallback(drawChartFine);\n      function drawChartFine() {\n        var container = document.getElementById('timeline_fine');\n        var chart = new google.visualization.Timeline(container);\n        var dataTable = new google.visualization.DataTable();\n\n        dataTable.addColumn({ type: 'string', id: 'Status' });\n\t\tdataTable.addColumn({ type: 'string', id: 'Name' });\n        dataTable.addColumn({ type: 'date', id: 'Start' });\n        dataTable.addColumn({ type: 'date', id: 'End' });\n        dataTable.addRows([\n\t\t{{range .Rows.Active}}\n\t\t\t[\n\t\t\t\t\"Active\",\n\t\t\t\t{{printf \"%q\" .Label}},\n\t\t\t\t{{timeToJS .Start}},\n\t\t\t\t{{timeToJS .End}},\n\t\t\t],\n\t\t{{end}}\n\t\t{{range .Rows.Visible}}\n\t\t\t[\n\t\t\t\t\"Visible\",\n\t\t\t\t{{printf \"%q\" .Label}},\n\t\t\t\t{{timeToJS .Start}},\n\t\t\t\t{{timeToJS .End}},\n\t\t\t],\n\t\t{{end}}\n\t\t{{range .Rows.All}}\n\t\t\t[\n\t\t\t\t\"All\",\n\t\t\t\t{{printf \"%q\" .Label}},\n\t\t\t\t{{timeToJS .Start}},\n\t\t\t\t{{timeToJS .End}},\n\t\t\t],\n\t\t{{end}}\n\t\t]);\n\n\t\tvar options = {\n\t\t\ttimeline: { showRowLabels: true },\n\t\t};\n        chart.draw(dataTable, options);\n      }\n    </script>\n\t{{end}}\n\n\n  </head>\n  <body>\n\n\t<div class=\"description\">\n\t\tThis is a coarse-grained timeline of all the applications you use over the course of the day. Every bar represents an application.\n\t</div>\n    <div id=\"timeline_coarse\" style=\"min-height: 500px;\"></div>\n\t<hr>\n\n\t<div class=\"description\">\n\t\tThis is a fine-grained timeline of all the applications you use over the course of the day. Every bar represents a distinct window.\n\t</div>\n    <div id=\"timeline_fine\" style=\"min-height: 500px;\"></div>\n\t<hr>\n\n\t{{range $chart := .Agg.Charts}}\n\t<div id=\"bar_chart_{{$chart.ID}}\"></div>\n\t<hr>\n\t{{end}}\n\n  </body>\n</html>`))\n\n// appID returns a string that identifies the application of the\n// window, w. It does so in best effort fashion. If the application\n// can't be determined, it returns the the name of the window.\nfunc appID(w *Window) string {\n\tif w == nil {\n\t\treturn \"(nil)\"\n\t}\n\tif w.Info().App != \"\" {\n\t\treturn w.Info().App\n\t}\n\tif w.Info().SubApp != \"\" {\n\t\treturn fmt.Sprintf(\"%s :: %s\", w.Info().App, w.Info().SubApp)\n\t}\n\tif w.Info().Title != \"\" {\n\t\treturn w.Info().Title\n\t}\n\treturn w.Name\n}\n"
        },
        {
          "name": "windows.go",
          "type": "blob",
          "size": 3.4462890625,
          "content": "// +build windows\n\npackage thyme\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n\t\"time\"\n\t\"unsafe\"\n)\n\nfunc init() {\n\tRegisterTracker(\"windows\", NewWindowsTracker)\n}\n\n// WindowsTracker tracks application usage using the \"EnumWindows\" win32 API. Windows is very liberal\n// in what it calls a Window, so one Window (or application) may return multiple times with the same\n// process ID, but different window titles. Which title is used is a matter of chance.\ntype WindowsTracker struct{}\n\nvar _ Tracker = (*WindowsTracker)(nil)\n\nfunc NewWindowsTracker() Tracker {\n\treturn &WindowsTracker{}\n}\n\nvar windowsIgnoreList []string = []string{\n\t\"Default IME\",\n\t\"MSCTFIME UI\",\n}\n\nvar (\n\tuser                         = syscall.NewLazyDLL(\"user32.dll\")\n\tprocGetForegroundWindow      = user.NewProc(\"GetForegroundWindow\")\n\tprocGetWindowText            = user.NewProc(\"GetWindowTextW\")\n\tprocGetWindowTextLengthW     = user.NewProc(\"GetWindowTextLengthW\")\n\tprocEnumWindows              = user.NewProc(\"EnumWindows\")\n\tprocIsWindow                 = user.NewProc(\"IsWindow\")\n\tprocIsWindowVisible          = user.NewProc(\"IsWindowVisible\")\n\tprocGetWindowThreadProcessId = user.NewProc(\"GetWindowThreadProcessId\")\n)\n\nfunc (t *WindowsTracker) Deps() string {\n\treturn \"Nothing, Ready to Go!\"\n}\n\n// getWindowTitle returns a title of a window of the provided system window handle\nfunc getWindowTitle(window uintptr) string {\n\ttextLength, _, _ := procGetWindowTextLengthW.Call(uintptr(window))\n\ttextLength += 1\n\ttitleBuffer := make([]uint16, textLength)\n\tprocGetWindowText.Call(uintptr(window), uintptr(unsafe.Pointer(&titleBuffer[0])), textLength)\n\treturn syscall.UTF16ToString(titleBuffer)\n}\n\n// getWindowID returns the process (thread) id that created the window. Multiple windows can share\n// the same process id.\nfunc getWindowID(window uintptr) int64 {\n\tid, _, _ := procGetWindowThreadProcessId.Call(window, 0)\n\treturn int64(id)\n}\n\n// windowsIgnore will return true for titles of windows that are likely internal to windows itself\n// and not the applications we care to monitor.\nfunc windowsIgnore(title string) bool {\n\tif title == \"\" {\n\t\treturn true\n\t}\n\tfor _, ignore := range windowsIgnoreList {\n\t\tif ignore == title {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (t *WindowsTracker) Snap() (snap *Snapshot, err error) {\n\tvar allWindows []*Window\n\tvar visible []int64\n\tvar active int64\n\n\tvar cbId uintptr = 888\n\n\tactiveWindow, _, _ := procGetForegroundWindow.Call()\n\tactiveTitle := getWindowTitle(activeWindow)\n\n\tcb := syscall.NewCallback(func(hwnd syscall.Handle, lparam uintptr) uintptr {\n\t\tif lparam != cbId {\n\t\t\terr = fmt.Errorf(\"lparam does not match what callback expected; received (%d), expected (%d)\", lparam, cbId)\n\t\t\treturn 0\n\t\t}\n\t\tb, _, _ := procIsWindow.Call(uintptr(hwnd))\n\t\tif b != 0 {\n\t\t\tcurrentTitle := getWindowTitle(uintptr(hwnd))\n\t\t\tcurrentId := getWindowID(uintptr(hwnd))\n\t\t\t// Skip windows that are in a process where we already have a visible window\n\t\t\tfor _, visibleId := range visible {\n\t\t\t\tif currentId == visibleId {\n\t\t\t\t\treturn 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !windowsIgnore(currentTitle) {\n\t\t\t\tif activeTitle == currentTitle {\n\t\t\t\t\tactive = currentId\n\t\t\t\t}\n\t\t\t\tv, _, _ := procIsWindowVisible.Call(uintptr(hwnd))\n\t\t\t\tif v != 0 {\n\t\t\t\t\tvisible = append(visible, currentId)\n\t\t\t\t}\n\t\t\t\tallWindows = append(allWindows, &Window{ID: currentId, Name: currentTitle})\n\t\t\t}\n\t\t}\n\t\treturn 1 // continue enumeration\n\t})\n\n\tprocEnumWindows.Call(cb, cbId)\n\n\treturn &Snapshot{\n\t\tTime:    time.Now(),\n\t\tWindows: allWindows,\n\t\tActive:  active,\n\t\tVisible: visible,\n\t}, err\n}\n"
        }
      ]
    }
  ]
}