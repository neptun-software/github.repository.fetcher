{
  "metadata": {
    "timestamp": 1736566908641,
    "page": 478,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alicebob/miniredis",
      "stars": 3171,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0947265625,
          "content": "/integration/redis_src/\n/integration/dump.rdb\n*.swp\n/integration/nodes.conf\n.idea/\nminiredis.iml\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 6.5625,
          "content": "## Changelog\n\n\n### v2.34.0\n\n- fix ZINTERSTORE where target is one of the source sets\n- added support for ZRank and ZRevRank with score (thanks Jeff Howell)\n- fix MEMORY subcommand casing (thanks @joshaber)\n- use streamCmp in Xtrim (thanks @daniel-cohere)\n\n\n### v2.33.0\n\n- minimum Go version is now 1.17\n- fix integer overflow (thanks @wszaranski)\n- test against the last BSD redis (7.2.4)\n- ignore 'redis.set_repl()' call (thanks @TingluoHuang)\n- various build fixes (thanks @wszaranski)\n- add StartAddrTLS function (thanks @agriffaut)\n- support for the NOMKSTREAM option for XADD (thanks @Jahaja)\n- return empty array for SRANDMEMBER on nonexistent key (thanks @WKBae)\n\n\n### v2.32.1\n\n- support for SINTERCARD (thanks @s-barr-fetch)\n- support for EXPIRETIME and PEXPIRETIME (thanks @wszaranski)\n- fix GEO* units to be case insensitive\n\n\n### v2.31.1\n\n- support COUNT in SCAN and ZSCAN (thanks @BarakSilverfort)\n- support for OBJECT IDLETIME (thanks @nerd2)\n- support for HRANDFIELD (thanks @sejin-P)\n\n\n### v2.31.0\n\n- support for MEMORY USAGE (thanks @davidroman0O)\n- test against Redis 7.2.0\n- support for CLIENT SETNAME/GETNAME (thanks @mr-karan)\n- fix very small numbers (thanks @zsh1995)\n- use the same float-to-string logic real Redis uses\n\n\n### v2.30.5\n\n- support SMISMEMBER (thanks @sandyharvie)\n\n\n### v2.30.4\n\n- fix ZADD LT/LG (thanks @sejin-P)\n- fix COPY (thanks @jerargus)\n- quicker SPOP\n\n\n### v2.30.3\n\n- fix lua error_reply (thanks @pkierski)\n- fix use of blocking functions in lua\n- support for ZMSCORE (thanks @lsgndln)\n- lua cache (thanks @tonyhb)\n\n\n### v2.30.2\n\n- support MINID in XADD  (thanks @nathan-cormier)\n- support BLMOVE (thanks @sevein)\n- fix COMMAND (thanks @pje)\n- fix 'XREAD ... $' on a non-existing stream\n\n\n### v2.30.1\n\n- support SET NX GET special case\n\n\n### v2.30.0\n\n- implement redis 7.0.x (from 6.X). Main changes:\n   - test against 7.0.7\n   - update error messages\n   - support nx|xx|gt|lt options in [P]EXPIRE[AT]\n   - update how deleted items are processed in pending queues in streams\n\n\n### v2.23.1\n\n- resolve $ to latest ID in XREAD (thanks @josh-hook)\n- handle disconnect in blocking functions (thanks @jgirtakovskis)\n- fix type conversion bug in redisToLua (thanks Sandy Harvie)\n- BRPOP{LPUSH} timeout can be float since 6.0\n\n\n### v2.23.0\n\n- basic INFO support (thanks @kirill-a-belov)\n- support COUNT in SSCAN (thanks @Abdi-dd)\n- test and support Go 1.19\n- support LPOS (thanks @ianstarz)\n- support XPENDING, XGROUP {CREATECONSUMER,DESTROY,DELCONSUMER}, XINFO {CONSUMERS,GROUPS}, XCLAIM (thanks @sandyharvie)\n\n\n### v2.22.0\n\n- set miniredis.DumpMaxLineLen to get more Dump() info (thanks @afjoseph)\n- fix invalid resposne of COMMAND (thanks @zsh1995)\n- fix possibility to generate duplicate IDs in XADD (thanks @readams)\n- adds support for XAUTOCLAIM min-idle parameter (thanks @readams)\n\n\n### v2.21.0\n\n- support for GETEX (thanks @dntj)\n- support for GT and LT in ZADD (thanks @lsgndln)\n- support for XAUTOCLAIM (thanks @randall-fulton)\n\n\n### v2.20.0\n\n- back to support Go >= 1.14 (thanks @ajatprabha and @marcind)\n\n\n### v2.19.0\n\n- support for TYPE in SCAN (thanks @0xDiddi)\n- update BITPOS (thanks @dirkm)\n- fix a lua redis.call() return value (thanks @mpetronic)\n- update ZRANGE (thanks @valdemarpereira)\n\n\n### v2.18.0\n\n- support for ZUNION (thanks @propan)\n- support for COPY (thanks @matiasinsaurralde and @rockitbaby)\n- support for LMOVE (thanks @btwear)\n\n\n### v2.17.0\n\n- added miniredis.RunT(t)\n\n\n### v2.16.1\n\n- fix ZINTERSTORE with sets (thanks @lingjl2010 and @okhowang)\n- fix exclusive ranges in XRANGE (thanks @joseotoro)\n\n\n### v2.16.0\n\n- simplify some code (thanks @zonque)\n- support for EXAT/PXAT in SET\n- support for XTRIM (thanks @joseotoro)\n- support for ZRANDMEMBER\n- support for redis.log() in lua (thanks @dirkm)\n\n\n### v2.15.2\n\n- Fix race condition in blocking code (thanks @zonque and @robx)\n- XREAD accepts '$' as ID (thanks @bradengroom)\n\n\n### v2.15.1\n\n- EVAL should cache the script (thanks @guoshimin)\n\n\n### v2.15.0\n\n- target redis 6.2 and added new args to various commands\n- support for all hyperlog commands (thanks @ilbaktin)\n- support for GETDEL (thanks @wszaranski)\n\n\n### v2.14.5\n\n- added XPENDING\n- support for BLOCK option in XREAD and XREADGROUP\n\n\n### v2.14.4\n\n- fix BITPOS error (thanks @xiaoyuzdy)\n- small fixes for XREAD, XACK, and XDEL. Mostly error cases.\n- fix empty EXEC return type (thanks @ashanbrown)\n- fix XDEL (thanks @svakili and @yvesf)\n- fix FLUSHALL for streams (thanks @svakili)\n\n\n### v2.14.3\n\n- fix problem where Lua code didn't set the selected DB\n- update to redis 6.0.10 (thanks @lazappa)\n\n\n### v2.14.2\n\n- update LUA dependency\n- deal with (p)unsubscribe when there are no channels\n\n\n### v2.14.1\n\n- mod tidy\n\n\n### v2.14.0\n\n- support for HELLO and the RESP3 protocol\n- KEEPTTL in SET (thanks @johnpena)\n\n\n### v2.13.3\n\n- support Go 1.14 and 1.15\n- update the `Check...()` methods\n- support for XREAD (thanks @pieterlexis)\n\n\n### v2.13.2\n\n- Use SAN instead of CN in self signed cert for testing (thanks @johejo)\n- Travis CI now tests against the most recent two versions of Go (thanks @johejo)\n- changed unit and integration tests to compare raw payloads, not parsed payloads\n- remove \"redigo\" dependency\n\n\n### v2.13.1\n\n- added HSTRLEN\n- minimal support for ACL users in AUTH\n\n\n### v2.13.0\n\n- added RunTLS(...)\n- added SetError(...)\n\n\n### v2.12.0\n\n- redis 6\n- Lua json update (thanks @gsmith85)\n- CLUSTER commands (thanks @kratisto)\n- fix TOUCH\n- fix a shutdown race condition\n\n\n### v2.11.4\n\n- ZUNIONSTORE now supports standard set types (thanks @wshirey)\n\n\n### v2.11.3\n\n- support for TOUCH (thanks @cleroux)\n- support for cluster and stream commands (thanks @kak-tus)\n\n\n### v2.11.2\n\n- make sure Lua code is executed concurrently\n- add command GEORADIUSBYMEMBER (thanks @kyeett)\n\n\n### v2.11.1\n\n- globals protection for Lua code (thanks @vk-outreach)\n- HSET update (thanks @carlgreen)\n- fix BLPOP block on shutdown (thanks @Asalle)\n\n\n### v2.11.0\n\n- added XRANGE/XREVRANGE, XADD, and XLEN (thanks @skateinmars)\n- added GEODIST\n- improved precision for geohashes, closer to what real redis does\n- use 128bit floats internally for INCRBYFLOAT and related (thanks @timnd)\n\n\n### v2.10.1\n\n- added m.Server()\n\n\n### v2.10.0\n\n- added UNLINK\n- fix DEL zero-argument case\n- cleanup some direct access commands\n- added GEOADD, GEOPOS, GEORADIUS, and GEORADIUS_RO\n\n\n### v2.9.1\n\n- fix issue with ZRANGEBYLEX\n- fix issue with BRPOPLPUSH and direct access\n\n\n### v2.9.0\n\n- proper versioned import of github.com/gomodule/redigo (thanks @yfei1)\n- fix messages generated by PSUBSCRIBE\n- optional internal seed (thanks @zikaeroh)\n\n\n### v2.8.0\n\nProper `v2` in go.mod.\n\n\n### older\n\nSee https://github.com/alicebob/miniredis/releases for the full changelog\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0478515625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Harmen\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.9189453125,
          "content": ".PHONY: test\ntest: ### Run unit tests\n\tgo test ./...\n\n.PHONY: testrace\ntestrace: ### Run unit tests with race detector\n\tgo test -race ./...\n\n.PHONY: int\nint: ### Run integration tests (doesn't download redis server)\n\t${MAKE} -C integration int\n\n.PHONY: ci\nci: ### Run full tests suite (including download and compilation of proper redis server)\n\t${MAKE} test\n\t${MAKE} -C integration redis_src/redis-server int\n\t${MAKE} testrace\n\n.PHONY: clean\nclean: ### Clean integration test files and remove compiled redis from integration/redis_src\n\t${MAKE} -C integration clean\n\n.PHONY: help\nhelp:\nifeq ($(UNAME), Linux)\n\t@grep -P '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | \\\n\t\tawk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-20s\\033[0m %s\\n\", $$1, $$2}'\nelse\n\t@# this is not tested, but prepared in advance for you, Mac drivers\n\t@awk -F ':.*###' '$$0 ~ FS {printf \"%15s%s\\n\", $$1 \":\", $$2}' \\\n\t\t$(MAKEFILE_LIST) | grep -v '@awk' | sort\nendif\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.5654296875,
          "content": "# Miniredis\n\nPure Go Redis test server, used in Go unittests.\n\n\n##\n\nSometimes you want to test code which uses Redis, without making it a full-blown\nintegration test.\nMiniredis implements (parts of) the Redis server, to be used in unittests. It\nenables a simple, cheap, in-memory, Redis replacement, with a real TCP interface. Think of it as the Redis version of `net/http/httptest`.\n\nIt saves you from using mock code, and since the redis server lives in the\ntest process you can query for values directly, without going through the server\nstack.\n\nThere are no dependencies on external binaries, so you can easily integrate it in automated build processes.\n\nBe sure to import v2:\n```\nimport \"github.com/alicebob/miniredis/v2\"\n```\n\n## Commands\n\nImplemented commands:\n\n - Connection (complete)\n   - AUTH -- see RequireAuth()\n   - ECHO\n   - HELLO -- see RequireUserAuth()\n   - PING\n   - SELECT\n   - SWAPDB\n   - QUIT\n - Key\n   - COPY\n   - DEL\n   - EXISTS\n   - EXPIRE\n   - EXPIREAT\n   - EXPIRETIME\n   - KEYS\n   - MOVE\n   - PERSIST\n   - PEXPIRE\n   - PEXPIREAT\n   - PEXPIRETIME\n   - PTTL\n   - RANDOMKEY -- see m.Seed(...)\n   - RENAME\n   - RENAMENX\n   - SCAN\n   - TOUCH\n   - TTL\n   - TYPE\n   - UNLINK\n - Transactions (complete)\n   - DISCARD\n   - EXEC\n   - MULTI\n   - UNWATCH\n   - WATCH\n - Server\n   - DBSIZE\n   - FLUSHALL\n   - FLUSHDB\n   - TIME -- returns time.Now() or value set by SetTime()\n   - COMMAND -- partly\n   - INFO -- partly, returns only \"clients\" section with one field \"connected_clients\"\n - String keys (complete)\n   - APPEND\n   - BITCOUNT\n   - BITOP\n   - BITPOS\n   - DECR\n   - DECRBY\n   - GET\n   - GETBIT\n   - GETRANGE\n   - GETSET\n   - GETDEL\n   - GETEX\n   - INCR\n   - INCRBY\n   - INCRBYFLOAT\n   - MGET\n   - MSET\n   - MSETNX\n   - PSETEX\n   - SET\n   - SETBIT\n   - SETEX\n   - SETNX\n   - SETRANGE\n   - STRLEN\n - Hash keys (complete)\n   - HDEL\n   - HEXISTS\n   - HGET\n   - HGETALL\n   - HINCRBY\n   - HINCRBYFLOAT\n   - HKEYS\n   - HLEN\n   - HMGET\n   - HMSET\n   - HRANDFIELD\n   - HSET\n   - HSETNX\n   - HSTRLEN\n   - HVALS\n   - HSCAN\n - List keys (complete)\n   - BLPOP\n   - BRPOP\n   - BRPOPLPUSH\n   - LINDEX\n   - LINSERT\n   - LLEN\n   - LPOP\n   - LPUSH\n   - LPUSHX\n   - LRANGE\n   - LREM\n   - LSET\n   - LTRIM\n   - RPOP\n   - RPOPLPUSH\n   - RPUSH\n   - RPUSHX\n   - LMOVE\n   - BLMOVE\n - Pub/Sub (complete)\n   - PSUBSCRIBE\n   - PUBLISH\n   - PUBSUB\n   - PUNSUBSCRIBE\n   - SUBSCRIBE\n   - UNSUBSCRIBE\n - Set keys (complete)\n   - SADD\n   - SCARD\n   - SDIFF\n   - SDIFFSTORE\n   - SINTER\n   - SINTERSTORE\n   - SINTERCARD\n   - SISMEMBER\n   - SMEMBERS\n   - SMISMEMBER\n   - SMOVE\n   - SPOP -- see m.Seed(...)\n   - SRANDMEMBER -- see m.Seed(...)\n   - SREM\n   - SSCAN\n   - SUNION\n   - SUNIONSTORE\n - Sorted Set keys (complete)\n   - ZADD\n   - ZCARD\n   - ZCOUNT\n   - ZINCRBY\n   - ZINTER\n   - ZINTERSTORE\n   - ZLEXCOUNT\n   - ZPOPMIN\n   - ZPOPMAX\n   - ZRANDMEMBER\n   - ZRANGE\n   - ZRANGEBYLEX\n   - ZRANGEBYSCORE\n   - ZRANK\n   - ZREM\n   - ZREMRANGEBYLEX\n   - ZREMRANGEBYRANK\n   - ZREMRANGEBYSCORE\n   - ZREVRANGE\n   - ZREVRANGEBYLEX\n   - ZREVRANGEBYSCORE\n   - ZREVRANK\n   - ZSCORE\n   - ZUNION\n   - ZUNIONSTORE\n   - ZSCAN\n - Stream keys\n   - XACK\n   - XADD\n   - XAUTOCLAIM\n   - XCLAIM\n   - XDEL\n   - XGROUP CREATE\n   - XGROUP CREATECONSUMER\n   - XGROUP DESTROY\n   - XGROUP DELCONSUMER\n   - XINFO STREAM -- partly\n   - XINFO GROUPS\n   - XINFO CONSUMERS -- partly\n   - XLEN\n   - XRANGE\n   - XREAD\n   - XREADGROUP\n   - XREVRANGE\n   - XPENDING\n   - XTRIM\n - Scripting\n   - EVAL\n   - EVALSHA\n   - SCRIPT LOAD\n   - SCRIPT EXISTS\n   - SCRIPT FLUSH\n - GEO\n   - GEOADD\n   - GEODIST\n   - ~~GEOHASH~~\n   - GEOPOS\n   - GEORADIUS\n   - GEORADIUS_RO\n   - GEORADIUSBYMEMBER\n   - GEORADIUSBYMEMBER_RO\n - Cluster\n   - CLUSTER SLOTS\n   - CLUSTER KEYSLOT\n   - CLUSTER NODES\n - HyperLogLog (complete)\n   - PFADD\n   - PFCOUNT\n   - PFMERGE\n\n\n## TTLs, key expiration, and time\n\nSince miniredis is intended to be used in unittests TTLs don't decrease\nautomatically. You can use `TTL()` to get the TTL (as a time.Duration) of a\nkey. It will return 0 when no TTL is set.\n\n`m.FastForward(d)` can be used to decrement all TTLs. All TTLs which become <=\n0 will be removed.\n\nEXPIREAT and PEXPIREAT values will be\nconverted to a duration. For that you can either set m.SetTime(t) to use that\ntime as the base for the (P)EXPIREAT conversion, or don't call SetTime(), in\nwhich case time.Now() will be used.\n\nSetTime() also sets the value returned by TIME, which defaults to time.Now().\nIt is not updated by FastForward, only by SetTime.\n\n## Randomness and Seed()\n\nMiniredis will use `math/rand`'s global RNG for randomness unless a seed is\nprovided by calling `m.Seed(...)`. If a seed is provided, then miniredis will\nuse its own RNG based on that seed.\n\nCommands which use randomness are: RANDOMKEY, SPOP, and SRANDMEMBER.\n\n## Example\n\n``` Go\n\nimport (\n    ...\n    \"github.com/alicebob/miniredis/v2\"\n    ...\n)\n\nfunc TestSomething(t *testing.T) {\n\ts := miniredis.RunT(t)\n\n\t// Optionally set some keys your code expects:\n\ts.Set(\"foo\", \"bar\")\n\ts.HSet(\"some\", \"other\", \"key\")\n\n\t// Run your code and see if it behaves.\n\t// An example using the redigo library from \"github.com/gomodule/redigo/redis\":\n\tc, err := redis.Dial(\"tcp\", s.Addr())\n\t_, err = c.Do(\"SET\", \"foo\", \"bar\")\n\n\t// Optionally check values in redis...\n\tif got, err := s.Get(\"foo\"); err != nil || got != \"bar\" {\n\t\tt.Error(\"'foo' has the wrong value\")\n\t}\n\t// ... or use a helper for that:\n\ts.CheckGet(t, \"foo\", \"bar\")\n\n\t// TTL and expiration:\n\ts.Set(\"foo\", \"bar\")\n\ts.SetTTL(\"foo\", 10*time.Second)\n\ts.FastForward(11 * time.Second)\n\tif s.Exists(\"foo\") {\n\t\tt.Fatal(\"'foo' should not have existed anymore\")\n\t}\n}\n```\n\n## Not supported\n\nCommands which will probably not be implemented:\n\n - CLUSTER (all)\n    - ~~CLUSTER *~~\n    - ~~READONLY~~\n    - ~~READWRITE~~\n - Key\n    - ~~DUMP~~\n    - ~~MIGRATE~~\n    - ~~OBJECT~~\n    - ~~RESTORE~~\n    - ~~WAIT~~\n - Scripting\n    - ~~SCRIPT DEBUG~~\n    - ~~SCRIPT KILL~~\n - Server\n    - ~~BGSAVE~~\n    - ~~BGWRITEAOF~~\n    - ~~CLIENT *~~\n    - ~~CONFIG *~~\n    - ~~DEBUG *~~\n    - ~~LASTSAVE~~\n    - ~~MONITOR~~\n    - ~~ROLE~~\n    - ~~SAVE~~\n    - ~~SHUTDOWN~~\n    - ~~SLAVEOF~~\n    - ~~SLOWLOG~~\n    - ~~SYNC~~\n\n\n## &c.\n\nIntegration tests are run against Redis 7.2.4. The [./integration](./integration/) subdir\ncompares miniredis against a real redis instance.\n\nThe Redis 6 RESP3 protocol is supported. If there are problems, please open\nan issue.\n\nIf you want to test Redis Sentinel have a look at [minisentinel](https://github.com/Bose/minisentinel).\n\nA changelog is kept at [CHANGELOG.md](https://github.com/alicebob/miniredis/blob/master/CHANGELOG.md).\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/alicebob/miniredis/v2.svg)](https://pkg.go.dev/github.com/alicebob/miniredis/v2)\n"
        },
        {
          "name": "check.go",
          "type": "blob",
          "size": 1.5576171875,
          "content": "package miniredis\n\nimport (\n\t\"reflect\"\n\t\"sort\"\n)\n\n// T is implemented by Testing.T\ntype T interface {\n\tHelper()\n\tErrorf(string, ...interface{})\n}\n\n// CheckGet does not call Errorf() iff there is a string key with the\n// expected value. Normal use case is `m.CheckGet(t, \"username\", \"theking\")`.\nfunc (m *Miniredis) CheckGet(t T, key, expected string) {\n\tt.Helper()\n\n\tfound, err := m.Get(key)\n\tif err != nil {\n\t\tt.Errorf(\"GET error, key %#v: %v\", key, err)\n\t\treturn\n\t}\n\tif found != expected {\n\t\tt.Errorf(\"GET error, key %#v: Expected %#v, got %#v\", key, expected, found)\n\t\treturn\n\t}\n}\n\n// CheckList does not call Errorf() iff there is a list key with the\n// expected values.\n// Normal use case is `m.CheckGet(t, \"favorite_colors\", \"red\", \"green\", \"infrared\")`.\nfunc (m *Miniredis) CheckList(t T, key string, expected ...string) {\n\tt.Helper()\n\n\tfound, err := m.List(key)\n\tif err != nil {\n\t\tt.Errorf(\"List error, key %#v: %v\", key, err)\n\t\treturn\n\t}\n\tif !reflect.DeepEqual(expected, found) {\n\t\tt.Errorf(\"List error, key %#v: Expected %#v, got %#v\", key, expected, found)\n\t\treturn\n\t}\n}\n\n// CheckSet does not call Errorf() iff there is a set key with the\n// expected values.\n// Normal use case is `m.CheckSet(t, \"visited\", \"Rome\", \"Stockholm\", \"Dublin\")`.\nfunc (m *Miniredis) CheckSet(t T, key string, expected ...string) {\n\tt.Helper()\n\n\tfound, err := m.Members(key)\n\tif err != nil {\n\t\tt.Errorf(\"Set error, key %#v: %v\", key, err)\n\t\treturn\n\t}\n\tsort.Strings(expected)\n\tif !reflect.DeepEqual(expected, found) {\n\t\tt.Errorf(\"Set error, key %#v: Expected %#v, got %#v\", key, expected, found)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "cmd_client.go",
          "type": "blob",
          "size": 1.427734375,
          "content": "package miniredis\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsClient handles client operations.\nfunc commandsClient(m *Miniredis) {\n\tm.srv.Register(\"CLIENT\", m.cmdClient)\n}\n\n// CLIENT\nfunc (m *Miniredis) cmdClient(c *server.Peer, cmd string, args []string) {\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR wrong number of arguments for 'client' command\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tswitch cmd := strings.ToUpper(args[0]); cmd {\n\t\tcase \"SETNAME\":\n\t\t\tm.cmdClientSetName(c, args[1:])\n\t\tcase \"GETNAME\":\n\t\t\tm.cmdClientGetName(c, args[1:])\n\t\tdefault:\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(fmt.Sprintf(\"ERR unknown subcommand '%s'. Try CLIENT HELP.\", cmd))\n\t\t}\n\t})\n}\n\n// CLIENT SETNAME\nfunc (m *Miniredis) cmdClientSetName(c *server.Peer, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR wrong number of arguments for 'client setname' command\")\n\t\treturn\n\t}\n\n\tname := args[0]\n\tif strings.ContainsAny(name, \" \\n\") {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR Client names cannot contain spaces, newlines or special characters.\")\n\t\treturn\n\n\t}\n\tc.ClientName = name\n\tc.WriteOK()\n}\n\n// CLIENT GETNAME\nfunc (m *Miniredis) cmdClientGetName(c *server.Peer, args []string) {\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR wrong number of arguments for 'client getname' command\")\n\t\treturn\n\t}\n\n\tif c.ClientName == \"\" {\n\t\tc.WriteNull()\n\t} else {\n\t\tc.WriteBulk(c.ClientName)\n\t}\n}\n"
        },
        {
          "name": "cmd_client_test.go",
          "type": "blob",
          "size": 0.615234375,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test CLIENT *.\nfunc TestClient(t *testing.T) {\n\tt.Run(\"setname and getname\", func(t *testing.T) {\n\t\t_, c := runWithClient(t)\n\n\t\t// Set the client name\n\t\tmustDo(t, c,\n\t\t\t\"CLIENT\", \"SETNAME\", \"miniredis-tests\",\n\t\t\tproto.Inline(\"OK\"),\n\t\t)\n\n\t\t// Get the client name\n\t\tmustDo(t, c,\n\t\t\t\"CLIENT\", \"GETNAME\",\n\t\t\tproto.String(\"miniredis-tests\"),\n\t\t)\n\t})\n\n\tt.Run(\"getname without setname\", func(t *testing.T) {\n\t\t_, c := runWithClient(t)\n\n\t\t// Get the client name without setting it first\n\t\tmustDo(t, c,\n\t\t\t\"CLIENT\", \"GETNAME\",\n\t\t\tproto.Nil,\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_cluster.go",
          "type": "blob",
          "size": 1.5673828125,
          "content": "// Commands from https://redis.io/commands#cluster\n\npackage miniredis\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsCluster handles some cluster operations.\nfunc commandsCluster(m *Miniredis) {\n\tm.srv.Register(\"CLUSTER\", m.cmdCluster)\n}\n\nfunc (m *Miniredis) cmdCluster(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tswitch strings.ToUpper(args[0]) {\n\tcase \"SLOTS\":\n\t\tm.cmdClusterSlots(c, cmd, args)\n\tcase \"KEYSLOT\":\n\t\tm.cmdClusterKeySlot(c, cmd, args)\n\tcase \"NODES\":\n\t\tm.cmdClusterNodes(c, cmd, args)\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(\"ERR 'CLUSTER %s' not supported\", strings.Join(args, \" \")))\n\t\treturn\n\t}\n}\n\n// CLUSTER SLOTS\nfunc (m *Miniredis) cmdClusterSlots(c *server.Peer, cmd string, args []string) {\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tc.WriteLen(1)\n\t\tc.WriteLen(3)\n\t\tc.WriteInt(0)\n\t\tc.WriteInt(16383)\n\t\tc.WriteLen(3)\n\t\tc.WriteBulk(m.srv.Addr().IP.String())\n\t\tc.WriteInt(m.srv.Addr().Port)\n\t\tc.WriteBulk(\"09dbe9720cda62f7865eabc5fd8857c5d2678366\")\n\t})\n}\n\n// CLUSTER KEYSLOT\nfunc (m *Miniredis) cmdClusterKeySlot(c *server.Peer, cmd string, args []string) {\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tc.WriteInt(163)\n\t})\n}\n\n// CLUSTER NODES\nfunc (m *Miniredis) cmdClusterNodes(c *server.Peer, cmd string, args []string) {\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tc.WriteBulk(\"e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 127.0.0.1:7000@7000 myself,master - 0 0 1 connected 0-16383\")\n\t})\n}\n"
        },
        {
          "name": "cmd_cluster_test.go",
          "type": "blob",
          "size": 0.84765625,
          "content": "package miniredis\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test CLUSTER *.\nfunc TestCluster(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"slots\", func(t *testing.T) {\n\t\tport, err := strconv.Atoi(s.Port())\n\t\tok(t, err)\n\t\tmustDo(t, c,\n\t\t\t\"CLUSTER\", \"SLOTS\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.Int(0),\n\t\t\t\t\tproto.Int(16383),\n\t\t\t\t\tproto.Array(\n\t\t\t\t\t\tproto.String(s.Host()),\n\t\t\t\t\t\tproto.Int(port),\n\t\t\t\t\t\tproto.String(\"09dbe9720cda62f7865eabc5fd8857c5d2678366\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"nodes\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"CLUSTER\", \"NODES\",\n\t\t\tproto.String(\"e7d1eecce10fd6bb5eb35b9f99a514335d9ba9ca 127.0.0.1:7000@7000 myself,master - 0 0 1 connected 0-16383\"),\n\t\t)\n\t})\n\n\tt.Run(\"keyslot\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"CLUSTER\", \"keyslot\", \"{test_key}\",\n\t\t\tproto.Int(163),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_command.go",
          "type": "blob",
          "size": 15.4697265625,
          "content": "// Command 'COMMAND' from https://redis.io/commands#server\n\npackage miniredis\n\nimport \"github.com/alicebob/miniredis/v2/server\"\n\nfunc (m *Miniredis) cmdCommand(c *server.Peer, cmd string, args []string) {\n\t// Got from redis 5.0.7 with\n\t// echo 'COMMAND' | nc redis_addr redis_port\n\n\tres := \"*200\\r\\n*6\\r\\n$12\\r\\nhincrbyfloat\\r\\n:4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$10\\r\\nxreadgroup\\r\\n:-7\\r\\n*3\\r\\n+write\\r\\n+noscript\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$10\\r\\nsdiffstore\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nlastsave\\r\\n:1\\r\\n*2\\r\\n+random\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nsetnx\\r\\n:3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nbzpopmax\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+noscript\\r\\n+fast\\r\\n:1\\r\\n:-2\\r\\n:1\\r\\n*6\\r\\n$12\\r\\npunsubscribe\\r\\n:-1\\r\\n*4\\r\\n+pubsub\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nxack\\r\\n:-4\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$10\\r\\npfselftest\\r\\n:1\\r\\n*1\\r\\n+admin\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nsubstr\\r\\n:4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nsmembers\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$11\\r\\nunsubscribe\\r\\n:-1\\r\\n*4\\r\\n+pubsub\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$11\\r\\nzinterstore\\r\\n:-4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+movablekeys\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nstrlen\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\npfmerge\\r\\n:-2\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nrandomkey\\r\\n:1\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nlolwut\\r\\n:-1\\r\\n*1\\r\\n+readonly\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nrpop\\r\\n:2\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nhkeys\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nclient\\r\\n:-2\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nmodule\\r\\n:-2\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\nslowlog\\r\\n:-2\\r\\n*2\\r\\n+admin\\r\\n+random\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\ngeohash\\r\\n:-2\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nlrange\\r\\n:4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nping\\r\\n:-1\\r\\n*2\\r\\n+stale\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$8\\r\\nbitcount\\r\\n:-2\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\npubsub\\r\\n:-2\\r\\n*4\\r\\n+pubsub\\r\\n+random\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nrole\\r\\n:1\\r\\n*3\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nhget\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nobject\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:2\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nzrevrange\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nhincrby\\r\\n:4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nzlexcount\\r\\n:4\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nscard\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nappend\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nhstrlen\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nconfig\\r\\n:-2\\r\\n*4\\r\\n+admin\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nhset\\r\\n:-4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$16\\r\\nzrevrangebyscore\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nincr\\r\\n:2\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nsetbit\\r\\n:4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nrpoplpush\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nxclaim\\r\\n:-6\\r\\n*3\\r\\n+write\\r\\n+random\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$11\\r\\nsinterstore\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\npublish\\r\\n:3\\r\\n*4\\r\\n+pubsub\\r\\n+loading\\r\\n+stale\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nhscan\\r\\n:-3\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nmulti\\r\\n:1\\r\\n*2\\r\\n+noscript\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$3\\r\\nset\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nlpushx\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$16\\r\\nzremrangebyscore\\r\\n:4\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\npexpireat\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nhdel\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$12\\r\\nbgrewriteaof\\r\\n:1\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\nmigrate\\r\\n:-6\\r\\n*3\\r\\n+write\\r\\n+random\\r\\n+movablekeys\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$9\\r\\nreplicaof\\r\\n:3\\r\\n*3\\r\\n+admin\\r\\n+noscript\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\ntouch\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nxsetid\\r\\n:3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nbitop\\r\\n:-4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:2\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nswapdb\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nsdiff\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nlindex\\r\\n:3\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nwait\\r\\n:3\\r\\n*1\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nlrem\\r\\n:4\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nhsetnx\\r\\n:4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\ngetrange\\r\\n:4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nhlen\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\npost\\r\\n:-1\\r\\n*2\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$9\\r\\nsismember\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nunwatch\\r\\n:1\\r\\n*2\\r\\n+noscript\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nlpush\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nscan\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nsmove\\r\\n:4\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$7\\r\\ncluster\\r\\n:-2\\r\\n*1\\r\\n+admin\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nbgsave\\r\\n:-1\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\ndump\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nlatency\\r\\n:-2\\r\\n*4\\r\\n+admin\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$8\\r\\nbzpopmin\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+noscript\\r\\n+fast\\r\\n:1\\r\\n:-2\\r\\n:1\\r\\n*6\\r\\n$6\\r\\ngetbit\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nhgetall\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nrename\\r\\n:3\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nsubscribe\\r\\n:-2\\r\\n*4\\r\\n+pubsub\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nxdel\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$15\\r\\nzremrangebyrank\\r\\n:4\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\ntype\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nscript\\r\\n:-2\\r\\n*1\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nhmset\\r\\n:-4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nsunion\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nmget\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$10\\r\\nbrpoplpush\\r\\n:4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+noscript\\r\\n:1\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$6\\r\\ngeoadd\\r\\n:-5\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\ndecrby\\r\\n:3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\necho\\r\\n:2\\r\\n*1\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\ndbsize\\r\\n:1\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nzcard\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nselect\\r\\n:2\\r\\n*2\\r\\n+loading\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nsadd\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nhost:\\r\\n:-1\\r\\n*2\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nsscan\\r\\n:-3\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$12\\r\\ngeoradius_ro\\r\\n:-6\\r\\n*2\\r\\n+readonly\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nmonitor\\r\\n:1\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$14\\r\\nzremrangebylex\\r\\n:4\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$11\\r\\nsunionstore\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nzscan\\r\\n:-3\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nreadwrite\\r\\n:1\\r\\n*1\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nxgroup\\r\\n:-2\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:2\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nsetex\\r\\n:4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nsave\\r\\n:1\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nhvals\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nwatch\\r\\n:-2\\r\\n*2\\r\\n+noscript\\r\\n+fast\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nhexists\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\ninfo\\r\\n:-1\\r\\n*3\\r\\n+random\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\npsync\\r\\n:3\\r\\n*3\\r\\n+readonly\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$11\\r\\nzrangebylex\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nzadd\\r\\n:-4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nxlen\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nauth\\r\\n:2\\r\\n*4\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nsrem\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\ngeoradius\\r\\n:-6\\r\\n*2\\r\\n+write\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nexec\\r\\n:1\\r\\n*2\\r\\n+noscript\\r\\n+skip_monitor\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\npfcount\\r\\n:-2\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nzpopmin\\r\\n:-2\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nmove\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nxtrim\\r\\n:-2\\r\\n*3\\r\\n+write\\r\\n+random\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nasking\\r\\n:1\\r\\n*1\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\npttl\\r\\n:2\\r\\n*3\\r\\n+readonly\\r\\n+random\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$11\\r\\nsrandmember\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nflushall\\r\\n:-1\\r\\n*1\\r\\n+write\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nsort\\r\\n:-2\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$3\\r\\ndel\\r\\n:-2\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$14\\r\\nrestore-asking\\r\\n:-4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+asking\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$10\\r\\npsubscribe\\r\\n:-2\\r\\n*4\\r\\n+pubsub\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\ndecr\\r\\n:2\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nincrby\\r\\n:3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$14\\r\\nzrevrangebylex\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nbitfield\\r\\n:-2\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nexists\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nreplconf\\r\\n:-1\\r\\n*4\\r\\n+admin\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\nzincrby\\r\\n:4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nblpop\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+noscript\\r\\n:1\\r\\n:-2\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nlpop\\r\\n:2\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$3\\r\\nttl\\r\\n:2\\r\\n*3\\r\\n+readonly\\r\\n+random\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nxread\\r\\n:-4\\r\\n*3\\r\\n+readonly\\r\\n+noscript\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nrpush\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nzrevrank\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$11\\r\\nincrbyfloat\\r\\n:3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nbrpop\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+noscript\\r\\n:1\\r\\n:-2\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nxadd\\r\\n:-5\\r\\n*4\\r\\n+write\\r\\n+denyoom\\r\\n+random\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nsetrange\\r\\n:4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$17\\r\\ngeoradiusbymember\\r\\n:-5\\r\\n*2\\r\\n+write\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nunlink\\r\\n:-2\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nexpireat\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\ndebug\\r\\n:-2\\r\\n*2\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$20\\r\\ngeoradiusbymember_ro\\r\\n:-5\\r\\n*2\\r\\n+readonly\\r\\n+movablekeys\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nlset\\r\\n:4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nzscore\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nllen\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\ntime\\r\\n:1\\r\\n*2\\r\\n+random\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$8\\r\\nshutdown\\r\\n:-1\\r\\n*4\\r\\n+admin\\r\\n+noscript\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\nevalsha\\r\\n:-3\\r\\n*2\\r\\n+noscript\\r\\n+movablekeys\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nzcount\\r\\n:4\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nmemory\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nxinfo\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:2\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$8\\r\\nxpending\\r\\n:-3\\r\\n*2\\r\\n+readonly\\r\\n+random\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\neval\\r\\n:-3\\r\\n*2\\r\\n+noscript\\r\\n+movablekeys\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nxrange\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nrestore\\r\\n:-4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nzpopmax\\r\\n:-2\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nmset\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:-1\\r\\n:2\\r\\n*6\\r\\n$4\\r\\nspop\\r\\n:-2\\r\\n*3\\r\\n+write\\r\\n+random\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nltrim\\r\\n:4\\r\\n*1\\r\\n+write\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\nzrank\\r\\n:3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$9\\r\\nxrevrange\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$3\\r\\nget\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nflushdb\\r\\n:-1\\r\\n*1\\r\\n+write\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$5\\r\\nhmget\\r\\n:-3\\r\\n*2\\r\\n+readonly\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nmsetnx\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:-1\\r\\n:2\\r\\n*6\\r\\n$7\\r\\npersist\\r\\n:2\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$11\\r\\nzunionstore\\r\\n:-4\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+movablekeys\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\ncommand\\r\\n:0\\r\\n*3\\r\\n+random\\r\\n+loading\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$8\\r\\nrenamenx\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:2\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nzrange\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\npexpire\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nkeys\\r\\n:2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$4\\r\\nzrem\\r\\n:-3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$5\\r\\npfadd\\r\\n:-2\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\npsetex\\r\\n:4\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$13\\r\\nzrangebyscore\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$4\\r\\nsync\\r\\n:1\\r\\n*3\\r\\n+readonly\\r\\n+admin\\r\\n+noscript\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\npfdebug\\r\\n:-3\\r\\n*1\\r\\n+write\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\ndiscard\\r\\n:1\\r\\n*2\\r\\n+noscript\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$8\\r\\nreadonly\\r\\n:1\\r\\n*1\\r\\n+fast\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$7\\r\\ngeodist\\r\\n:-4\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\ngeopos\\r\\n:-2\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nbitpos\\r\\n:-3\\r\\n*1\\r\\n+readonly\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nsinter\\r\\n:-2\\r\\n*2\\r\\n+readonly\\r\\n+sort_for_script\\r\\n:1\\r\\n:-1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\ngetset\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nslaveof\\r\\n:3\\r\\n*3\\r\\n+admin\\r\\n+noscript\\r\\n+stale\\r\\n:0\\r\\n:0\\r\\n:0\\r\\n*6\\r\\n$6\\r\\nrpushx\\r\\n:-3\\r\\n*3\\r\\n+write\\r\\n+denyoom\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$7\\r\\nlinsert\\r\\n:5\\r\\n*2\\r\\n+write\\r\\n+denyoom\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n*6\\r\\n$6\\r\\nexpire\\r\\n:3\\r\\n*2\\r\\n+write\\r\\n+fast\\r\\n:1\\r\\n:1\\r\\n:1\\r\\n\"\n\n\tc.WriteRaw(res)\n}\n"
        },
        {
          "name": "cmd_connection.go",
          "type": "blob",
          "size": 5.4697265625,
          "content": "// Commands from https://redis.io/commands#connection\n\npackage miniredis\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nfunc commandsConnection(m *Miniredis) {\n\tm.srv.Register(\"AUTH\", m.cmdAuth)\n\tm.srv.Register(\"ECHO\", m.cmdEcho)\n\tm.srv.Register(\"HELLO\", m.cmdHello)\n\tm.srv.Register(\"PING\", m.cmdPing)\n\tm.srv.Register(\"QUIT\", m.cmdQuit)\n\tm.srv.Register(\"SELECT\", m.cmdSelect)\n\tm.srv.Register(\"SWAPDB\", m.cmdSwapdb)\n}\n\n// PING\nfunc (m *Miniredis) cmdPing(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\n\tif len(args) > 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\tpayload := \"\"\n\tif len(args) > 0 {\n\t\tpayload = args[0]\n\t}\n\n\t// PING is allowed in subscribed state\n\tif sub := getCtx(c).subscriber; sub != nil {\n\t\tc.Block(func(c *server.Writer) {\n\t\t\tc.WriteLen(2)\n\t\t\tc.WriteBulk(\"pong\")\n\t\t\tc.WriteBulk(payload)\n\t\t})\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif payload == \"\" {\n\t\t\tc.WriteInline(\"PONG\")\n\t\t\treturn\n\t\t}\n\t\tc.WriteBulk(payload)\n\t})\n}\n\n// AUTH\nfunc (m *Miniredis) cmdAuth(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\tif len(args) > 2 {\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\tvar opts = struct {\n\t\tusername string\n\t\tpassword string\n\t}{\n\t\tusername: \"default\",\n\t\tpassword: args[0],\n\t}\n\tif len(args) == 2 {\n\t\topts.username, opts.password = args[0], args[1]\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif len(m.passwords) == 0 && opts.username == \"default\" {\n\t\t\tc.WriteError(\"ERR AUTH <password> called without any password configured for the default user. Are you sure your configuration is correct?\")\n\t\t\treturn\n\t\t}\n\t\tsetPW, ok := m.passwords[opts.username]\n\t\tif !ok {\n\t\t\tc.WriteError(\"WRONGPASS invalid username-password pair\")\n\t\t\treturn\n\t\t}\n\t\tif setPW != opts.password {\n\t\t\tc.WriteError(\"WRONGPASS invalid username-password pair\")\n\t\t\treturn\n\t\t}\n\n\t\tctx.authenticated = true\n\t\tc.WriteOK()\n\t})\n}\n\n// HELLO\nfunc (m *Miniredis) cmdHello(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tversion  int\n\t\tusername string\n\t\tpassword string\n\t}\n\n\tif ok := optIntErr(c, args[0], &opts.version, \"ERR Protocol version is not an integer or out of range\"); !ok {\n\t\treturn\n\t}\n\targs = args[1:]\n\n\tswitch opts.version {\n\tcase 2, 3:\n\tdefault:\n\t\tc.WriteError(\"NOPROTO unsupported protocol version\")\n\t\treturn\n\t}\n\n\tvar checkAuth bool\n\tfor len(args) > 0 {\n\t\tswitch strings.ToUpper(args[0]) {\n\t\tcase \"AUTH\":\n\t\t\tif len(args) < 3 {\n\t\t\t\tc.WriteError(fmt.Sprintf(\"ERR Syntax error in HELLO option '%s'\", args[0]))\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.username, opts.password, args = args[1], args[2], args[3:]\n\t\t\tcheckAuth = true\n\t\tcase \"SETNAME\":\n\t\t\tif len(args) < 2 {\n\t\t\t\tc.WriteError(fmt.Sprintf(\"ERR Syntax error in HELLO option '%s'\", args[0]))\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, args = args[1], args[2:]\n\t\tdefault:\n\t\t\tc.WriteError(fmt.Sprintf(\"ERR Syntax error in HELLO option '%s'\", args[0]))\n\t\t\treturn\n\t\t}\n\t}\n\n\tif len(m.passwords) == 0 && opts.username == \"default\" {\n\t\t// redis ignores legacy \"AUTH\" if it's not enabled.\n\t\tcheckAuth = false\n\t}\n\tif checkAuth {\n\t\tsetPW, ok := m.passwords[opts.username]\n\t\tif !ok {\n\t\t\tc.WriteError(\"WRONGPASS invalid username-password pair\")\n\t\t\treturn\n\t\t}\n\t\tif setPW != opts.password {\n\t\t\tc.WriteError(\"WRONGPASS invalid username-password pair\")\n\t\t\treturn\n\t\t}\n\t\tgetCtx(c).authenticated = true\n\t}\n\n\tc.Resp3 = opts.version == 3\n\n\tc.WriteMapLen(7)\n\tc.WriteBulk(\"server\")\n\tc.WriteBulk(\"miniredis\")\n\tc.WriteBulk(\"version\")\n\tc.WriteBulk(\"6.0.5\")\n\tc.WriteBulk(\"proto\")\n\tc.WriteInt(opts.version)\n\tc.WriteBulk(\"id\")\n\tc.WriteInt(42)\n\tc.WriteBulk(\"mode\")\n\tc.WriteBulk(\"standalone\")\n\tc.WriteBulk(\"role\")\n\tc.WriteBulk(\"master\")\n\tc.WriteBulk(\"modules\")\n\tc.WriteLen(0)\n}\n\n// ECHO\nfunc (m *Miniredis) cmdEcho(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tmsg := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tc.WriteBulk(msg)\n\t})\n}\n\n// SELECT\nfunc (m *Miniredis) cmdSelect(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.isValidCMD(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tid int\n\t}\n\tif ok := optInt(c, args[0], &opts.id); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif opts.id < 0 {\n\t\t\tc.WriteError(msgDBIndexOutOfRange)\n\t\t\tsetDirty(c)\n\t\t\treturn\n\t\t}\n\n\t\tctx.selectedDB = opts.id\n\t\tc.WriteOK()\n\t})\n}\n\n// SWAPDB\nfunc (m *Miniredis) cmdSwapdb(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tid1 int\n\t\tid2 int\n\t}\n\n\tif ok := optIntErr(c, args[0], &opts.id1, \"ERR invalid first DB index\"); !ok {\n\t\treturn\n\t}\n\tif ok := optIntErr(c, args[1], &opts.id2, \"ERR invalid second DB index\"); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif opts.id1 < 0 || opts.id2 < 0 {\n\t\t\tc.WriteError(msgDBIndexOutOfRange)\n\t\t\tsetDirty(c)\n\t\t\treturn\n\t\t}\n\n\t\tm.swapDB(opts.id1, opts.id2)\n\n\t\tc.WriteOK()\n\t})\n}\n\n// QUIT\nfunc (m *Miniredis) cmdQuit(c *server.Peer, cmd string, args []string) {\n\t// QUIT isn't transactionfied and accepts any arguments.\n\tc.WriteOK()\n\tc.Close()\n}\n"
        },
        {
          "name": "cmd_connection_test.go",
          "type": "blob",
          "size": 5.4716796875,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestAuth(t *testing.T) {\n\tt.Run(\"default user\", func(t *testing.T) {\n\t\ts, c := runWithClient(t)\n\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"foo\", \"bar\", \"baz\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\ts.RequireAuth(\"nocomment\")\n\t\tmustDo(t, c,\n\t\t\t\"PING\", \"foo\", \"bar\",\n\t\t\tproto.Error(\"NOAUTH Authentication required.\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"wrongpasswd\",\n\t\t\tproto.Error(\"WRONGPASS invalid username-password pair\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"nocomment\",\n\t\t\tproto.Inline(\"OK\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PING\",\n\t\t\tproto.Inline(\"PONG\"),\n\t\t)\n\t})\n\n\tt.Run(\"another user\", func(t *testing.T) {\n\t\ts, c := runWithClient(t)\n\n\t\ts.RequireUserAuth(\"hello\", \"world\")\n\t\tmustDo(t, c,\n\t\t\t\"PING\", \"foo\", \"bar\",\n\t\t\tproto.Error(\"NOAUTH Authentication required.\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"hello\", \"wrongpasswd\",\n\t\t\tproto.Error(\"WRONGPASS invalid username-password pair\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"goodbye\", \"world\",\n\t\t\tproto.Error(\"WRONGPASS invalid username-password pair\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"hello\", \"world\",\n\t\t\tproto.Inline(\"OK\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PING\",\n\t\t\tproto.Inline(\"PONG\"),\n\t\t)\n\t})\n\n\tt.Run(\"error cases\", func(t *testing.T) {\n\t\t_, c := runWithClient(t)\n\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'auth' command\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"AUTH\", \"foo\", \"bar\", \"baz\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n}\n\nfunc TestPing(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tt.Run(\"no args\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"PING\",\n\t\t\tproto.Inline(\"PONG\"),\n\t\t)\n\t})\n\n\tt.Run(\"args\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"PING\", \"hi\",\n\t\t\tproto.String(\"hi\"),\n\t\t)\n\t})\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"PING\", \"foo\", \"bar\",\n\t\t\tproto.Error(errWrongNumber(\"ping\")),\n\t\t)\n\t})\n}\n\nfunc TestEcho(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"ECHO\", \"hello\\nworld\",\n\t\tproto.String(\"hello\\nworld\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"ECHO\",\n\t\tproto.Error(errWrongNumber(\"echo\")),\n\t)\n}\n\nfunc TestSelect(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\tmustOK(t, c, \"SELECT\", \"5\")\n\tmustOK(t, c, \"SET\", \"foo\", \"baz\")\n\n\tt.Run(\"direct access\", func(t *testing.T) {\n\t\tgot, err := s.Get(\"foo\")\n\t\tok(t, err)\n\t\tequals(t, \"bar\", got)\n\n\t\ts.Select(5)\n\t\tgot, err = s.Get(\"foo\")\n\t\tok(t, err)\n\t\tequals(t, \"baz\", got)\n\t})\n\n\t// Another connection should have its own idea of the selected db:\n\tc2, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c2.Close()\n\tmustDo(t, c2,\n\t\t\"GET\", \"foo\",\n\t\tproto.String(\"bar\"),\n\t)\n}\n\nfunc TestSwapdb(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\tmustOK(t, c, \"SELECT\", \"5\")\n\tmustOK(t, c, \"SET\", \"foo\", \"baz\")\n\tmustOK(t, c, \"SWAPDB\", \"0\", \"5\")\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\tgot, err := s.Get(\"foo\")\n\t\tok(t, err)\n\t\tequals(t, \"baz\", got)\n\t\ts.Select(5)\n\t\tgot, err = s.Get(\"foo\")\n\t\tok(t, err)\n\t\tequals(t, \"bar\", got)\n\t})\n\n\tt.Run(\"another connection\", func(t *testing.T) {\n\t\tc2, err := proto.Dial(s.Addr())\n\t\tok(t, err)\n\t\tdefer c2.Close()\n\t\tmustDo(t, c2,\n\t\t\t\"GET\", \"foo\",\n\t\t\tproto.String(\"baz\"),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\",\n\t\t\tproto.Error(errWrongNumber(\"SWAPDB\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\", \"1\", \"2\", \"3\",\n\t\t\tproto.Error(errWrongNumber(\"SWAPDB\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\", \"foo\", \"2\",\n\t\t\tproto.Error(\"ERR invalid first DB index\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\", \"1\", \"bar\",\n\t\t\tproto.Error(\"ERR invalid second DB index\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\", \"foo\", \"bar\",\n\t\t\tproto.Error(\"ERR invalid first DB index\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\", \"-1\", \"2\",\n\t\t\tproto.Error(\"ERR DB index is out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SWAPDB\", \"1\", \"-2\",\n\t\t\tproto.Error(\"ERR DB index is out of range\"),\n\t\t)\n\t})\n}\n\nfunc TestQuit(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustOK(t, c, \"QUIT\")\n\n\tres, err := c.Do(\"PING\")\n\tassert(t, err != nil, \"QUIT closed the client\")\n\tequals(t, \"\", res)\n}\n\nfunc TestSetError(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"PING\",\n\t\tproto.Inline(\"PONG\"),\n\t)\n\n\ts.SetError(\"LOADING Redis is loading the dataset in memory\")\n\tmustDo(t, c,\n\t\t\"ECHO\",\n\t\tproto.Error(\"LOADING Redis is loading the dataset in memory\"),\n\t)\n\n\ts.SetError(\"\")\n\tmustDo(t, c,\n\t\t\"PING\",\n\t\tproto.Inline(\"PONG\"),\n\t)\n}\n\nfunc TestHello(t *testing.T) {\n\tt.Run(\"default user\", func(t *testing.T) {\n\t\ts, c := runWithClient(t)\n\n\t\tpayl := proto.Map(\n\t\t\tproto.String(\"server\"), proto.String(\"miniredis\"),\n\t\t\tproto.String(\"version\"), proto.String(\"6.0.5\"),\n\t\t\tproto.String(\"proto\"), proto.Int(3),\n\t\t\tproto.String(\"id\"), proto.Int(42),\n\t\t\tproto.String(\"mode\"), proto.String(\"standalone\"),\n\t\t\tproto.String(\"role\"), proto.String(\"master\"),\n\t\t\tproto.String(\"modules\"), proto.Array(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"HELLO\", \"3\", \"AUTH\", \"default\", \"secret\",\n\t\t\tpayl,\n\t\t)\n\n\t\ts.RequireAuth(\"secret\")\n\t\tmustDo(t, c,\n\t\t\t\"HELLO\", \"3\", \"AUTH\", \"default\", \"secret\",\n\t\t\tpayl,\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HELLO\", \"3\", \"AUTH\", \"default\", \"secret\", \"SETNAME\", \"santa\",\n\t\t\tpayl,\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HELLO\", \"3\", \"SETNAME\", \"santa\",\n\t\t\tpayl,\n\t\t)\n\n\t\tt.Run(\"errors\", func(t *testing.T) {\n\t\t\tmustDo(t, c,\n\t\t\t\t\"HELLO\",\n\t\t\t\tproto.Error(errWrongNumber(\"HELLO\")),\n\t\t\t)\n\t\t\tmustDo(t, c,\n\t\t\t\t\"HELLO\", \"foo\",\n\t\t\t\tproto.Error(\"ERR Protocol version is not an integer or out of range\"),\n\t\t\t)\n\t\t\tmustDo(t, c,\n\t\t\t\t\"HELLO\", \"3\", \"AUTH\", \"foo\",\n\t\t\t\tproto.Error(\"ERR Syntax error in HELLO option 'AUTH'\"),\n\t\t\t)\n\t\t\tmustDo(t, c,\n\t\t\t\t\"HELLO\", \"3\", \"AUTH\", \"foo\", \"bar\", \"SETNAME\",\n\t\t\t\tproto.Error(\"ERR Syntax error in HELLO option 'SETNAME'\"),\n\t\t\t)\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "cmd_generic.go",
          "type": "blob",
          "size": 15.5126953125,
          "content": "// Commands from https://redis.io/commands#generic\n\npackage miniredis\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nconst (\n\t// expiretimeReplyNoExpiration is return value for EXPIRETIME and PEXPIRETIME if the key exists but has no associated expiration time\n\texpiretimeReplyNoExpiration = -1\n\t// expiretimeReplyMissingKey is return value for EXPIRETIME and PEXPIRETIME if the key does not exist\n\texpiretimeReplyMissingKey = -2\n)\n\nfunc inSeconds(t time.Time) int {\n\treturn int(t.Unix())\n}\n\nfunc inMilliSeconds(t time.Time) int {\n\treturn int(t.UnixMilli())\n}\n\n// commandsGeneric handles EXPIRE, TTL, PERSIST, &c.\nfunc commandsGeneric(m *Miniredis) {\n\tm.srv.Register(\"COPY\", m.cmdCopy)\n\tm.srv.Register(\"DEL\", m.cmdDel)\n\t// DUMP\n\tm.srv.Register(\"EXISTS\", m.cmdExists)\n\tm.srv.Register(\"EXPIRE\", makeCmdExpire(m, false, time.Second))\n\tm.srv.Register(\"EXPIREAT\", makeCmdExpire(m, true, time.Second))\n\tm.srv.Register(\"EXPIRETIME\", m.makeCmdExpireTime(inSeconds))\n\tm.srv.Register(\"PEXPIRETIME\", m.makeCmdExpireTime(inMilliSeconds))\n\tm.srv.Register(\"KEYS\", m.cmdKeys)\n\t// MIGRATE\n\tm.srv.Register(\"MOVE\", m.cmdMove)\n\t// OBJECT\n\tm.srv.Register(\"PERSIST\", m.cmdPersist)\n\tm.srv.Register(\"PEXPIRE\", makeCmdExpire(m, false, time.Millisecond))\n\tm.srv.Register(\"PEXPIREAT\", makeCmdExpire(m, true, time.Millisecond))\n\tm.srv.Register(\"PTTL\", m.cmdPTTL)\n\tm.srv.Register(\"RANDOMKEY\", m.cmdRandomkey)\n\tm.srv.Register(\"RENAME\", m.cmdRename)\n\tm.srv.Register(\"RENAMENX\", m.cmdRenamenx)\n\t// RESTORE\n\tm.srv.Register(\"TOUCH\", m.cmdTouch)\n\tm.srv.Register(\"TTL\", m.cmdTTL)\n\tm.srv.Register(\"TYPE\", m.cmdType)\n\tm.srv.Register(\"SCAN\", m.cmdScan)\n\t// SORT\n\tm.srv.Register(\"UNLINK\", m.cmdDel)\n}\n\ntype expireOpts struct {\n\tkey   string\n\tvalue int\n\tnx    bool\n\txx    bool\n\tgt    bool\n\tlt    bool\n}\n\nfunc expireParse(cmd string, args []string) (*expireOpts, error) {\n\tvar opts expireOpts\n\n\topts.key = args[0]\n\tif err := optIntSimple(args[1], &opts.value); err != nil {\n\t\treturn nil, err\n\t}\n\targs = args[2:]\n\tfor len(args) > 0 {\n\t\tswitch strings.ToLower(args[0]) {\n\t\tcase \"nx\":\n\t\t\topts.nx = true\n\t\tcase \"xx\":\n\t\t\topts.xx = true\n\t\tcase \"gt\":\n\t\t\topts.gt = true\n\t\tcase \"lt\":\n\t\t\topts.lt = true\n\t\tdefault:\n\t\t\treturn nil, fmt.Errorf(\"ERR Unsupported option %s\", args[0])\n\t\t}\n\t\targs = args[1:]\n\t}\n\tif opts.gt && opts.lt {\n\t\treturn nil, errors.New(\"ERR GT and LT options at the same time are not compatible\")\n\t}\n\tif opts.nx && (opts.xx || opts.gt || opts.lt) {\n\t\treturn nil, errors.New(\"ERR NX and XX, GT or LT options at the same time are not compatible\")\n\t}\n\treturn &opts, nil\n}\n\n// generic expire command for EXPIRE, PEXPIRE, EXPIREAT, PEXPIREAT\n// d is the time unit. If unix is set it'll be seen as a unixtimestamp and\n// converted to a duration.\nfunc makeCmdExpire(m *Miniredis, unix bool, d time.Duration) func(*server.Peer, string, []string) {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) < 2 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\n\t\topts, err := expireParse(cmd, args)\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\t// Key must be present.\n\t\t\tif _, ok := db.keys[opts.key]; !ok {\n\t\t\t\tc.WriteInt(0)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\toldTTL, ok := db.ttl[opts.key]\n\n\t\t\tvar newTTL time.Duration\n\t\t\tif unix {\n\t\t\t\tnewTTL = m.at(opts.value, d)\n\t\t\t} else {\n\t\t\t\tnewTTL = time.Duration(opts.value) * d\n\t\t\t}\n\n\t\t\t// > NX -- Set expiry only when the key has no expiry\n\t\t\tif opts.nx && ok {\n\t\t\t\tc.WriteInt(0)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// > XX -- Set expiry only when the key has an existing expiry\n\t\t\tif opts.xx && !ok {\n\t\t\t\tc.WriteInt(0)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// > GT -- Set expiry only when the new expiry is greater than current one\n\t\t\t// (no exp == infinity)\n\t\t\tif opts.gt && (!ok || newTTL <= oldTTL) {\n\t\t\t\tc.WriteInt(0)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// > LT -- Set expiry only when the new expiry is less than current one\n\t\t\tif opts.lt && ok && newTTL > oldTTL {\n\t\t\t\tc.WriteInt(0)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdb.ttl[opts.key] = newTTL\n\t\t\tdb.incr(opts.key)\n\t\t\tdb.checkTTL(opts.key)\n\t\t\tc.WriteInt(1)\n\t\t})\n\t}\n}\n\n// makeCmdExpireTime creates server command function that returns the absolute Unix timestamp (since January 1, 1970)\n// at which the given key will expire, in unit selected by time result strategy (e.g. seconds, milliseconds).\n// For more information see redis documentation for [expiretime] and [pexpiretime].\n//\n// [expiretime]: https://redis.io/commands/expiretime/\n// [pexpiretime]: https://redis.io/commands/pexpiretime/\nfunc (m *Miniredis) makeCmdExpireTime(timeResultStrategy func(time.Time) int) server.Cmd {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) != 1 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\n\t\tkey := args[0]\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\tif _, ok := db.keys[key]; !ok {\n\t\t\t\tc.WriteInt(expiretimeReplyMissingKey)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tttl, ok := db.ttl[key]\n\t\t\tif !ok {\n\t\t\t\tc.WriteInt(expiretimeReplyNoExpiration)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tc.WriteInt(timeResultStrategy(m.effectiveNow().Add(ttl)))\n\t\t})\n\t}\n}\n\n// TOUCH\nfunc (m *Miniredis) cmdTouch(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tcount := 0\n\t\tfor _, key := range args {\n\t\t\tif db.exists(key) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(count)\n\t})\n}\n\n// TTL\nfunc (m *Miniredis) cmdTTL(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif _, ok := db.keys[key]; !ok {\n\t\t\t// No such key\n\t\t\tc.WriteInt(-2)\n\t\t\treturn\n\t\t}\n\n\t\tv, ok := db.ttl[key]\n\t\tif !ok {\n\t\t\t// no expire value\n\t\t\tc.WriteInt(-1)\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(int(v.Seconds()))\n\t})\n}\n\n// PTTL\nfunc (m *Miniredis) cmdPTTL(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif _, ok := db.keys[key]; !ok {\n\t\t\t// no such key\n\t\t\tc.WriteInt(-2)\n\t\t\treturn\n\t\t}\n\n\t\tv, ok := db.ttl[key]\n\t\tif !ok {\n\t\t\t// no expire value\n\t\t\tc.WriteInt(-1)\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(int(v.Nanoseconds() / 1000000))\n\t})\n}\n\n// PERSIST\nfunc (m *Miniredis) cmdPersist(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif _, ok := db.keys[key]; !ok {\n\t\t\t// no such key\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := db.ttl[key]; !ok {\n\t\t\t// no expire value\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tdelete(db.ttl, key)\n\t\tdb.incr(key)\n\t\tc.WriteInt(1)\n\t})\n}\n\n// DEL and UNLINK\nfunc (m *Miniredis) cmdDel(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tcount := 0\n\t\tfor _, key := range args {\n\t\t\tif db.exists(key) {\n\t\t\t\tcount++\n\t\t\t}\n\t\t\tdb.del(key, true) // delete expire\n\t\t}\n\t\tc.WriteInt(count)\n\t})\n}\n\n// TYPE\nfunc (m *Miniredis) cmdType(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"usage error\")\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\tc.WriteInline(\"none\")\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInline(t)\n\t})\n}\n\n// EXISTS\nfunc (m *Miniredis) cmdExists(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tfound := 0\n\t\tfor _, k := range args {\n\t\t\tif db.exists(k) {\n\t\t\t\tfound++\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(found)\n\t})\n}\n\n// MOVE\nfunc (m *Miniredis) cmdMove(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey      string\n\t\ttargetDB int\n\t}\n\n\topts.key = args[0]\n\topts.targetDB, _ = strconv.Atoi(args[1])\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif ctx.selectedDB == opts.targetDB {\n\t\t\tc.WriteError(\"ERR source and destination objects are the same\")\n\t\t\treturn\n\t\t}\n\t\tdb := m.db(ctx.selectedDB)\n\t\ttargetDB := m.db(opts.targetDB)\n\n\t\tif !db.move(opts.key, targetDB) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(1)\n\t})\n}\n\n// KEYS\nfunc (m *Miniredis) cmdKeys(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tkeys, _ := matchKeys(db.allKeys(), key)\n\t\tc.WriteLen(len(keys))\n\t\tfor _, s := range keys {\n\t\t\tc.WriteBulk(s)\n\t\t}\n\t})\n}\n\n// RANDOMKEY\nfunc (m *Miniredis) cmdRandomkey(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif len(db.keys) == 0 {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tnr := m.randIntn(len(db.keys))\n\t\tfor k := range db.keys {\n\t\t\tif nr == 0 {\n\t\t\t\tc.WriteBulk(k)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tnr--\n\t\t}\n\t})\n}\n\n// RENAME\nfunc (m *Miniredis) cmdRename(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tfrom string\n\t\tto   string\n\t}{\n\t\tfrom: args[0],\n\t\tto:   args[1],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.from) {\n\t\t\tc.WriteError(msgKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tdb.rename(opts.from, opts.to)\n\t\tc.WriteOK()\n\t})\n}\n\n// RENAMENX\nfunc (m *Miniredis) cmdRenamenx(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tfrom string\n\t\tto   string\n\t}{\n\t\tfrom: args[0],\n\t\tto:   args[1],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.from) {\n\t\t\tc.WriteError(msgKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tif db.exists(opts.to) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tdb.rename(opts.from, opts.to)\n\t\tc.WriteInt(1)\n\t})\n}\n\ntype scanOpts struct {\n\tcursor    int\n\tcount     int\n\twithMatch bool\n\tmatch     string\n\twithType  bool\n\t_type     string\n}\n\nfunc scanParse(cmd string, args []string) (*scanOpts, error) {\n\tvar opts scanOpts\n\tif err := optIntSimple(args[0], &opts.cursor); err != nil {\n\t\treturn nil, errors.New(msgInvalidCursor)\n\t}\n\targs = args[1:]\n\n\t// MATCH, COUNT and TYPE options\n\tfor len(args) > 0 {\n\t\tif strings.ToLower(args[0]) == \"count\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn nil, errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\tcount, err := strconv.Atoi(args[1])\n\t\t\tif err != nil || count < 0 {\n\t\t\t\treturn nil, errors.New(msgInvalidInt)\n\t\t\t}\n\t\t\tif count == 0 {\n\t\t\t\treturn nil, errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\topts.count = count\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tif strings.ToLower(args[0]) == \"match\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn nil, errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\topts.withMatch = true\n\t\t\topts.match, args = args[1], args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tif strings.ToLower(args[0]) == \"type\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn nil, errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\topts.withType = true\n\t\t\topts._type, args = strings.ToLower(args[1]), args[2:]\n\t\t\tcontinue\n\t\t}\n\t\treturn nil, errors.New(msgSyntaxError)\n\t}\n\treturn &opts, nil\n}\n\n// SCAN\nfunc (m *Miniredis) cmdScan(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts, err := scanParse(cmd, args)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\t// We return _all_ (matched) keys every time.\n\t\tvar keys []string\n\n\t\tif opts.withType {\n\t\t\tkeys = make([]string, 0)\n\t\t\tfor k, t := range db.keys {\n\t\t\t\t// type must be given exactly; no pattern matching is performed\n\t\t\t\tif t == opts._type {\n\t\t\t\t\tkeys = append(keys, k)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tkeys = db.allKeys()\n\t\t}\n\n\t\tsort.Strings(keys) // To make things deterministic.\n\n\t\tif opts.withMatch {\n\t\t\tkeys, _ = matchKeys(keys, opts.match)\n\t\t}\n\n\t\tlow := opts.cursor\n\t\thigh := low + opts.count\n\t\t// validate high is correct\n\t\tif high > len(keys) || high == 0 {\n\t\t\thigh = len(keys)\n\t\t}\n\t\tif opts.cursor > high {\n\t\t\t// invalid cursor\n\t\t\tc.WriteLen(2)\n\t\t\tc.WriteBulk(\"0\") // no next cursor\n\t\t\tc.WriteLen(0)    // no elements\n\t\t\treturn\n\t\t}\n\t\tcursorValue := low + opts.count\n\t\tif cursorValue >= len(keys) {\n\t\t\tcursorValue = 0 // no next cursor\n\t\t}\n\t\tkeys = keys[low:high]\n\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(fmt.Sprintf(\"%d\", cursorValue))\n\t\tc.WriteLen(len(keys))\n\t\tfor _, k := range keys {\n\t\t\tc.WriteBulk(k)\n\t\t}\n\t})\n}\n\ntype copyOpts struct {\n\tfrom          string\n\tto            string\n\tdestinationDB int\n\treplace       bool\n}\n\nfunc copyParse(cmd string, args []string) (*copyOpts, error) {\n\topts := copyOpts{\n\t\tdestinationDB: -1,\n\t}\n\n\topts.from, opts.to, args = args[0], args[1], args[2:]\n\tfor len(args) > 0 {\n\t\tswitch strings.ToLower(args[0]) {\n\t\tcase \"db\":\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn nil, errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\tif err := optIntSimple(args[1], &opts.destinationDB); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif opts.destinationDB < 0 {\n\t\t\t\treturn nil, errors.New(msgDBIndexOutOfRange)\n\t\t\t}\n\t\t\targs = args[2:]\n\t\tcase \"replace\":\n\t\t\topts.replace = true\n\t\t\targs = args[1:]\n\t\tdefault:\n\t\t\treturn nil, errors.New(msgSyntaxError)\n\t\t}\n\t}\n\treturn &opts, nil\n}\n\n// COPY\nfunc (m *Miniredis) cmdCopy(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts, err := copyParse(cmd, args)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tfromDB, toDB := ctx.selectedDB, opts.destinationDB\n\t\tif toDB == -1 {\n\t\t\ttoDB = fromDB\n\t\t}\n\n\t\tif fromDB == toDB && opts.from == opts.to {\n\t\t\tc.WriteError(\"ERR source and destination objects are the same\")\n\t\t\treturn\n\t\t}\n\n\t\tif !m.db(fromDB).exists(opts.from) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif !opts.replace {\n\t\t\tif m.db(toDB).exists(opts.to) {\n\t\t\t\tc.WriteInt(0)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tm.copy(m.db(fromDB), opts.from, m.db(toDB), opts.to)\n\t\tc.WriteInt(1)\n\t})\n}\n"
        },
        {
          "name": "cmd_generic_test.go",
          "type": "blob",
          "size": 17.62890625,
          "content": "package miniredis\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test EXPIRE. Keys with an expiration are called volatile in Redis parlance.\nfunc TestTTL(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"parse\", func(t *testing.T) {\n\t\tt.Run(\"basic\", func(t *testing.T) {\n\t\t\tv, err := expireParse(\"SCAN\", []string{\"foo\", \"200\"})\n\t\t\tok(t, err)\n\t\t\tequals(t, expireOpts{key: \"foo\", value: 200}, *v)\n\t\t})\n\t})\n\n\t// Not volatile yet\n\t{\n\t\tequals(t, time.Duration(0), s.TTL(\"foo\"))\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(-2),\n\t\t)\n\t}\n\n\t// Set something\n\t{\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\t\t// key exists, but no Expire set yet\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmust1(t, c, \"EXPIRE\", \"foo\", \"1200\") // EXPIRE returns 1 on success\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(1200),\n\t\t)\n\t}\n\n\t// A SET resets the expire.\n\t{\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t}\n\n\t// Set a non-existing key\n\t{\n\t\tmust0(t, c, \"EXPIRE\", \"nokey\", \"1200\") // EXPIRE returns 0 on failure\n\t}\n\n\t// Remove an expire\n\t{\n\n\t\t// No key yet\n\t\tmust0(t, c, \"PERSIST\", \"exkey\")\n\n\t\tmustOK(t, c, \"SET\", \"exkey\", \"bar\")\n\n\t\t// No timeout yet\n\t\tmust0(t, c, \"PERSIST\", \"exkey\")\n\n\t\tmust1(t, c, \"EXPIRE\", \"exkey\", \"1200\")\n\n\t\t// All fine now\n\t\tmust1(t, c, \"PERSIST\", \"exkey\")\n\n\t\t// No TTL left\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"exkey\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t}\n\n\t// Hash key works fine, too\n\t{\n\t\tmust1(t, c, \"HSET\", \"wim\", \"zus\", \"jet\")\n\t\tmust1(t, c, \"EXPIRE\", \"wim\", \"1234\")\n\t\tmustDo(t, c,\n\t\t\t\"EXPIRE\", \"wim\", \"1234\",\n\t\t\tproto.Int(1),\n\t\t)\n\t}\n\n\t{\n\t\tmustOK(t, c, \"SET\", \"wim\", \"zus\")\n\t\tmust1(t, c, \"EXPIRE\", \"wim\", \"-1200\")\n\t\tequals(t, false, s.Exists(\"wim\"))\n\t}\n}\n\nfunc TestExpireat(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Not volatile yet\n\t{\n\t\tequals(t, time.Duration(0), s.TTL(\"foo\"))\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(-2),\n\t\t)\n\t}\n\n\t// Set something\n\t{\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\t\t// Key exists, but no ttl set.\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(-1),\n\t\t)\n\n\t\tnow := 1234567890\n\t\ts.SetTime(time.Unix(int64(now), 0))\n\t\tmust1(t, c, \"EXPIREAT\", \"foo\", strconv.Itoa(now+100)) // EXPIREAT returns 1 on success.\n\n\t\tequals(t, 100*time.Second, s.TTL(\"foo\"))\n\t\tequals(t, 100*time.Second, s.TTL(\"foo\"))\n\t\tmustDo(t, c, \"TTL\", \"foo\", proto.Int(100))\n\t}\n}\n\nfunc TestTouch(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Set something\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ts.SetTime(time.Unix(1234567890, 0))\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\", \"EX\", \"100\")\n\t\tmustOK(t, c, \"SET\", \"baz\", \"qux\", \"EX\", \"100\")\n\n\t\t// Touch one key\n\t\tmust1(t, c, \"TOUCH\", \"baz\")\n\n\t\t// Touch multiple keys, \"nay\" doesn't exist\n\t\tmustDo(t, c,\n\t\t\t\"TOUCH\", \"foo\", \"baz\", \"nay\",\n\t\t\tproto.Int(2),\n\t\t)\n\t})\n\n\tt.Run(\"failure cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"TOUCH\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'touch' command\"),\n\t\t)\n\t})\n\n\tt.Run(\"TTL unchanged\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\", \"EX\", \"100\")\n\n\t\ts.FastForward(time.Second * 99)\n\t\tequals(t, time.Second, s.TTL(\"foo\"))\n\n\t\tmust1(t, c, \"TOUCH\", \"baz\")\n\t\tequals(t, time.Second, s.TTL(\"foo\"))\n\t})\n}\n\nfunc TestPexpireat(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Not volatile yet\n\t{\n\t\tequals(t, time.Duration(0), s.TTL(\"foo\"))\n\t\tmustDo(t, c,\n\t\t\t\"TTL\", \"foo\",\n\t\t\tproto.Int(-2),\n\t\t)\n\t}\n\n\t// Set something\n\t{\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\t\t// Key exists, but no ttl set.\n\t\tmustDo(t, c,\n\t\t\t\"PTTL\", \"foo\",\n\t\t\tproto.Int(-1),\n\t\t)\n\n\t\tnow := 1234567890\n\t\ts.SetTime(time.Unix(int64(now), 0))\n\t\tmust1(t, c, \"PEXPIREAT\", \"foo\", strconv.Itoa(now*1000+100)) // PEXPIREAT returns 1 on success.\n\n\t\tequals(t, 100*time.Millisecond, s.TTL(\"foo\"))\n\t\tmustDo(t, c,\n\t\t\t\"PTTL\", \"foo\",\n\t\t\tproto.Int(100),\n\t\t)\n\t}\n}\n\nfunc TestPexpire(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"key exists\", func(t *testing.T) {\n\t\tok(t, s.Set(\"foo\", \"bar\"))\n\t\tmust1(t, c, \"PEXPIRE\", \"foo\", \"12\")\n\n\t\tmustDo(t, c,\n\t\t\t\"PTTL\", \"foo\",\n\t\t\tproto.Int(12),\n\t\t)\n\t\tequals(t, 12*time.Millisecond, s.TTL(\"foo\"))\n\t})\n\n\tt.Run(\"no such key\", func(t *testing.T) {\n\t\tmust0(t, c, \"PEXPIRE\", \"nosuch\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"PTTL\", \"nosuch\",\n\t\t\tproto.Int(-2),\n\t\t)\n\t})\n\n\tt.Run(\"no expire\", func(t *testing.T) {\n\t\ts.Set(\"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"PTTL\", \"aap\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t})\n}\n\nfunc TestDel(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"simple\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"bar\")\n\t\ts.HSet(\"aap\", \"noot\", \"mies\")\n\t\ts.Set(\"one\", \"two\")\n\t\ts.SetTTL(\"one\", time.Second*1234)\n\t\ts.Set(\"three\", \"four\")\n\t\tmustDo(t, c,\n\t\t\t\"DEL\", \"one\", \"aap\", \"nosuch\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\tequals(t, time.Duration(0), s.TTL(\"one\"))\n\t})\n\n\tt.Run(\"failure cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"DEL\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'del' command\"),\n\t\t)\n\t})\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"bar\")\n\t\ts.Del(\"foo\")\n\t\tgot, err := s.Get(\"foo\")\n\t\tequals(t, ErrKeyNotFound, err)\n\t\tequals(t, \"\", got)\n\t})\n}\n\nfunc TestUnlink(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"simple\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"bar\")\n\t\ts.HSet(\"aap\", \"noot\", \"mies\")\n\t\ts.Set(\"one\", \"two\")\n\t\ts.SetTTL(\"one\", time.Second*1234)\n\t\ts.Set(\"three\", \"four\")\n\t\tmustDo(t, c,\n\t\t\t\"UNLINK\", \"one\", \"aap\", \"nosuch\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\tequals(t, time.Duration(0), s.TTL(\"one\"))\n\t})\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"bar\")\n\t\ts.Unlink(\"foo\")\n\t\tgot, err := s.Get(\"foo\")\n\t\tequals(t, ErrKeyNotFound, err)\n\t\tequals(t, \"\", got)\n\t})\n}\n\nfunc TestType(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Set(\"foo\", \"bar!\")\n\tt.Run(\"string\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"TYPE\", \"foo\",\n\t\t\tproto.Inline(\"string\"),\n\t\t)\n\t})\n\n\ts.HSet(\"aap\", \"noot\", \"mies\")\n\tt.Run(\"hash\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"TYPE\", \"aap\",\n\t\t\tproto.Inline(\"hash\"),\n\t\t)\n\t})\n\n\tt.Run(\"no such key\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"TYPE\", \"nosuch\",\n\t\t\tproto.Inline(\"none\"),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"TYPE\",\n\t\t\tproto.Error(\"usage error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"TYPE\", \"spurious\", \"arguments\",\n\t\t\tproto.Error(\"usage error\"),\n\t\t)\n\t})\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\tequals(t, \"hash\", s.Type(\"aap\"))\n\t\tequals(t, \"\", s.Type(\"nokey\"))\n\t})\n}\n\nfunc TestExpireTime(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"nosuch\", func(t *testing.T) {\n\t\tmustDo(t, c, \"EXPIRETIME\", \"nosuch\", proto.Int(-2))\n\t})\n\n\tt.Run(\"noexpire\", func(t *testing.T) {\n\t\ts.Set(\"noexpire\", \"\")\n\t\tmustDo(t, c, \"EXPIRETIME\", \"noexpire\", proto.Int(-1))\n\t})\n\n\tt.Run(\"\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"\")\n\t\tmust1(t, c, \"EXPIREAT\", \"foo\", \"10413792000\") // Mon Jan 01 2300 00:00:00 GMT+0000\n\t\tmustDo(t, c, \"EXPIRETIME\", \"foo\",\n\t\t\tproto.Int(10413792000),\n\t\t)\n\t})\n}\n\nfunc TestPExpireTime(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"nosuch\", func(t *testing.T) {\n\t\tmustDo(t, c, \"PEXPIRETIME\", \"nosuch\", proto.Int(-2))\n\t})\n\n\tt.Run(\"noexpire\", func(t *testing.T) {\n\t\ts.Set(\"noexpire\", \"\")\n\t\tmustDo(t, c, \"PEXPIRETIME\", \"noexpire\", proto.Int(-1))\n\t})\n\n\tt.Run(\"\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"\")\n\t\tmust1(t, c, \"PEXPIREAT\", \"foo\", \"10413792000123\") // Mon Jan 01 2300 00:00:00.123 GMT+0000\n\t\tmustDo(t, c, \"PEXPIRETIME\", \"foo\",\n\t\t\tproto.Int(10413792000123),\n\t\t)\n\t})\n}\n\nfunc TestExists(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"string\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"bar!\")\n\t\tmust1(t, c, \"EXISTS\", \"foo\")\n\t})\n\n\tt.Run(\"hash\", func(t *testing.T) {\n\t\ts.HSet(\"aap\", \"noot\", \"mies\")\n\t\tmust1(t, c, \"EXISTS\", \"aap\")\n\t})\n\n\tt.Run(\"multiple keys\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"EXISTS\", \"foo\", \"aap\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"EXISTS\", \"foo\", \"noot\", \"aap\",\n\t\t\tproto.Int(2),\n\t\t)\n\t})\n\n\tt.Run(\"nosuch keys\", func(t *testing.T) {\n\t\tmust0(t, c, \"EXISTS\", \"nosuch\")\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"EXISTS\",\n\t\t\tproto.Error(errWrongNumber(\"exists\")),\n\t\t)\n\t})\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\tequals(t, true, s.Exists(\"aap\"))\n\t\tequals(t, false, s.Exists(\"nokey\"))\n\t})\n}\n\nfunc TestMove(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// No problem.\n\t{\n\t\ts.Set(\"foo\", \"bar!\")\n\t\tmust1(t, c, \"MOVE\", \"foo\", \"1\")\n\t}\n\n\t// Src key doesn't exists.\n\t{\n\t\tmust0(t, c, \"MOVE\", \"nosuch\", \"1\")\n\t}\n\n\t// Target key already exists.\n\t{\n\t\ts.DB(0).Set(\"two\", \"orig\")\n\t\ts.DB(1).Set(\"two\", \"taken\")\n\t\tmust0(t, c, \"MOVE\", \"two\", \"1\")\n\t\ts.CheckGet(t, \"two\", \"orig\")\n\t}\n\n\t// TTL is also moved\n\t{\n\t\ts.DB(0).Set(\"one\", \"two\")\n\t\ts.DB(0).SetTTL(\"one\", time.Second*4242)\n\t\tmust1(t, c, \"MOVE\", \"one\", \"1\")\n\t\tequals(t, s.DB(1).TTL(\"one\"), time.Second*4242)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"MOVE\",\n\t\t\tproto.Error(errWrongNumber(\"move\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"MOVE\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"move\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"MOVE\", \"foo\", \"noint\",\n\t\t\tproto.Error(\"ERR source and destination objects are the same\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"MOVE\", \"foo\", \"2\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"move\")),\n\t\t)\n\t})\n}\n\nfunc TestKeys(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Set(\"foo\", \"bar!\")\n\ts.Set(\"foobar\", \"bar!\")\n\ts.Set(\"barfoo\", \"bar!\")\n\ts.Set(\"fooooo\", \"bar!\")\n\n\tmustDo(t, c,\n\t\t\"KEYS\", \"foo\",\n\t\tproto.Strings(\"foo\"),\n\t)\n\n\t// simple '*'\n\tmustDo(t, c,\n\t\t\"KEYS\", \"foo*\",\n\t\tproto.Strings(\"foo\", \"foobar\", \"fooooo\"),\n\t)\n\n\t// simple '?'\n\tmustDo(t, c,\n\t\t\"KEYS\", \"fo?\",\n\t\tproto.Strings(\"foo\"),\n\t)\n\n\t// Don't die on never-matching pattern.\n\tmustDo(t, c,\n\t\t\"KEYS\", `f\\`,\n\t\tproto.Strings(),\n\t)\n\n\tt.Run(\"error\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"KEYS\",\n\t\t\tproto.Error(errWrongNumber(\"keys\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"KEYS\", \"foo\", \"noint\",\n\t\t\tproto.Error(errWrongNumber(\"keys\")),\n\t\t)\n\t})\n}\n\nfunc TestRandom(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Empty db.\n\tmustNil(t, c, \"RANDOMKEY\")\n\n\ts.Set(\"one\", \"bar!\")\n\ts.Set(\"two\", \"bar!\")\n\ts.Set(\"three\", \"bar!\")\n\n\t// No idea which key will be returned.\n\t{\n\t\tv, err := c.Do(\"RANDOMKEY\")\n\t\tok(t, err)\n\t\tassert(t, v == proto.String(\"one\") || v == proto.String(\"two\") || v == proto.String(\"three\"), \"RANDOMKEY looks sane\")\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"RANDOMKEY\", \"spurious\",\n\t\t\tproto.Error(errWrongNumber(\"randomkey\")),\n\t\t)\n\t})\n}\n\nfunc TestRename(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Non-existing key\n\tmustDo(t, c,\n\t\t\"RENAME\", \"nosuch\", \"to\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\n\t// Same key\n\tmustDo(t, c,\n\t\t\"RENAME\", \"from\", \"from\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\n\tt.Run(\"string key\", func(t *testing.T) {\n\t\ts.Set(\"from\", \"value\")\n\t\tmustOK(t, c, \"RENAME\", \"from\", \"to\")\n\t\tequals(t, false, s.Exists(\"from\"))\n\t\tequals(t, true, s.Exists(\"to\"))\n\t\ts.CheckGet(t, \"to\", \"value\")\n\t\t_, ok := s.dbs[0].ttl[\"to\"]\n\t\tequals(t, ok, false)\n\t})\n\n\tt.Run(\"hash key\", func(t *testing.T) {\n\t\ts.HSet(\"from\", \"key\", \"value\")\n\t\tmustOK(t, c, \"RENAME\", \"from\", \"to\")\n\t\tequals(t, false, s.Exists(\"from\"))\n\t\tequals(t, true, s.Exists(\"to\"))\n\t\tequals(t, \"value\", s.HGet(\"to\", \"key\"))\n\t\t_, ok := s.dbs[0].ttl[\"to\"]\n\t\tequals(t, ok, false)\n\t})\n\n\tt.Run(\"ttl\", func(t *testing.T) {\n\t\ts.Set(\"TTLfrom\", \"value\")\n\t\ts.Set(\"TTLto\", \"value\")\n\t\ts.SetTTL(\"TTLto\", time.Second*99999)\n\t\tequals(t, time.Second*99999, s.TTL(\"TTLto\"))\n\t\tmustOK(t, c, \"RENAME\", \"TTLfrom\", \"TTLto\")\n\t\t_, ok := s.dbs[0].ttl[\"TTLto\"]\n\t\tequals(t, ok, false)\n\t})\n\n\tt.Run(\"overwrite\", func(t *testing.T) {\n\t\ts.Set(\"from\", \"string value\")\n\t\ts.HSet(\"to\", \"key\", \"value\")\n\t\ts.SetTTL(\"from\", time.Second*999999)\n\n\t\tmustOK(t, c, \"RENAME\", \"from\", \"to\")\n\t\tequals(t, false, s.Exists(\"from\"))\n\t\tequals(t, true, s.Exists(\"to\"))\n\t\ts.CheckGet(t, \"to\", \"string value\")\n\t\tequals(t, time.Duration(0), s.TTL(\"from\"))\n\t\tequals(t, time.Second*999999, s.TTL(\"to\"))\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"RENAME\",\n\t\t\tproto.Error(errWrongNumber(\"rename\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RENAME\", \"too few\",\n\t\t\tproto.Error(errWrongNumber(\"rename\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RENAME\", \"some\", \"spurious\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"rename\")),\n\t\t)\n\t})\n}\n\nfunc TestScan(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"parse\", func(t *testing.T) {\n\t\tt.Run(\"basic\", func(t *testing.T) {\n\t\t\tv, err := scanParse(\"SCAN\", []string{\"0\", \"COUNT\", \"200\"})\n\t\t\tok(t, err)\n\t\t\tequals(t, scanOpts{count: 200}, *v)\n\t\t})\n\t})\n\n\t// We cheat with scan. It always returns everything.\n\n\ts.Set(\"key\", \"value\")\n\n\tt.Run(\"no problem\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"key\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"invalid cursor\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"42\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0\"),\n\t\t\t\tproto.Array(),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"count\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"COUNT\", \"200\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"key\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\ts.Set(\"v1\", \"value\")\n\t\ts.Set(\"v2\", \"value\")\n\t\ts.Set(\"v3\", \"value\")\n\t\ts.Set(\"v4\", \"value\")\n\t\ts.Set(\"v5\", \"value\")\n\t\ts.Set(\"v6\", \"value\")\n\t\ts.Set(\"v7\", \"value\")\n\t\ts.Set(\"v8\", \"value\")\n\t\ts.Set(\"v9\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"COUNT\", \"3\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"3\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"key\"),\n\t\t\t\t\tproto.String(\"v1\"),\n\t\t\t\t\tproto.String(\"v2\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"3\", \"COUNT\", \"3\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"6\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"v3\"),\n\t\t\t\t\tproto.String(\"v4\"),\n\t\t\t\t\tproto.String(\"v5\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"match\", func(t *testing.T) {\n\t\ts.Set(\"aap\", \"noot\")\n\t\ts.Set(\"mies\", \"wim\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"MATCH\", \"mi*\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"mies\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"type\", func(t *testing.T) {\n\t\ts.SAdd(\"typetest\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"TYPE\", \"set\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"typetest\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\t// types aren't checked, they just return an empty array\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"TYPE\", \"not-a-type\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0\"),\n\t\t\t\tproto.Array(),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\",\n\t\t\tproto.Error(errWrongNumber(\"scan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"noint\",\n\t\t\tproto.Error(\"ERR invalid cursor\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"1\", \"MATCH\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"1\", \"COUNT\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"1\", \"COUNT\", \"noint\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"COUNT\", \"0\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"0\", \"COUNT\", \"-1\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"1\", \"TYPE\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCAN\", \"1\", \"not-an-option\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n}\n\nfunc TestRenamenx(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Non-existing key\n\tmustDo(t, c,\n\t\t\"RENAMENX\", \"nosuch\", \"to\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\n\tt.Run(\"same key\", func(t *testing.T) {\n\t\ts.Set(\"akey\", \"value\")\n\t\tmust0(t, c,\n\t\t\t\"RENAMENX\", \"akey\", \"akey\",\n\t\t)\n\t})\n\n\t// Move a string key\n\tt.Run(\"string key\", func(t *testing.T) {\n\t\ts.Set(\"from\", \"value\")\n\t\tmust1(t, c, \"RENAMENX\", \"from\", \"to\")\n\t\tequals(t, false, s.Exists(\"from\"))\n\t\tequals(t, true, s.Exists(\"to\"))\n\t\ts.CheckGet(t, \"to\", \"value\")\n\t})\n\n\tt.Run(\"existing key\", func(t *testing.T) {\n\t\ts.Set(\"from\", \"string value\")\n\t\ts.Set(\"to\", \"value\")\n\n\t\tmust0(t, c, \"RENAMENX\", \"from\", \"to\")\n\t\tequals(t, true, s.Exists(\"from\"))\n\t\tequals(t, true, s.Exists(\"to\"))\n\t\ts.CheckGet(t, \"from\", \"string value\")\n\t\ts.CheckGet(t, \"to\", \"value\")\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"RENAME\",\n\t\t\tproto.Error(errWrongNumber(\"rename\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RENAME\", \"too few\",\n\t\t\tproto.Error(errWrongNumber(\"rename\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RENAME\", \"some\", \"spurious\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"rename\")),\n\t\t)\n\t})\n}\n\nfunc TestCopy(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"parse\", func(t *testing.T) {\n\t\tt.Run(\"basic\", func(t *testing.T) {\n\t\t\tv, err := copyParse(\"copy\", []string{\"key1\", \"key2\"})\n\t\t\tok(t, err)\n\t\t\tequals(t, copyOpts{from: \"key1\", to: \"key2\", destinationDB: -1}, *v)\n\t\t})\n\t})\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ts.Set(\"key1\", \"value\")\n\t\t// should return 1 after a successful copy operation:\n\t\tmust1(t, c, \"COPY\", \"key1\", \"key2\")\n\t\ts.CheckGet(t, \"key2\", \"value\")\n\t\tequals(t, \"string\", s.Type(\"key2\"))\n\t})\n\n\t// should return 0 when trying to copy a nonexistent key:\n\tt.Run(\"nonexistent key\", func(t *testing.T) {\n\t\tmust0(t, c, \"COPY\", \"nosuch\", \"to\")\n\t})\n\n\t// should return 0 when trying to overwrite an existing key:\n\tt.Run(\"existing key\", func(t *testing.T) {\n\t\ts.Set(\"existingkey\", \"value\")\n\t\ts.Set(\"newkey\", \"newvalue\")\n\t\tmust0(t, c, \"COPY\", \"newkey\", \"existingkey\")\n\t\t// existing key value should remain unchanged:\n\t\ts.CheckGet(t, \"existingkey\", \"value\")\n\t})\n\n\tt.Run(\"list\", func(t *testing.T) {\n\t\tmust1(t, c, \"LPUSH\", \"l1\", \"original\")\n\t\tmust1(t, c, \"COPY\", \"l1\", \"l2\")\n\t\tmustOK(t, c, \"LSET\", \"l1\", \"0\", \"modified\")\n\t\ts.CheckList(t, \"l1\", \"modified\")\n\t\ts.CheckList(t, \"l2\", \"original\")\n\t})\n\n\tt.Run(\"destination db\", func(t *testing.T) {\n\t\ts.Set(\"akey1\", \"value\")\n\t\tmust1(t, c, \"COPY\", \"akey1\", \"akey2\", \"DB\", \"2\")\n\t\ts.Select(2)\n\t\ts.CheckGet(t, \"akey2\", \"value\")\n\t\tequals(t, \"string\", s.Type(\"akey2\"))\n\t})\n\ts.Select(0)\n\n\tt.Run(\"replace\", func(t *testing.T) {\n\t\ts.Set(\"rkey1\", \"value\")\n\t\ts.Set(\"rkey2\", \"another\")\n\t\tmust1(t, c, \"COPY\", \"rkey1\", \"rkey2\", \"REPLACE\")\n\t\ts.CheckGet(t, \"rkey2\", \"value\")\n\t\tequals(t, \"string\", s.Type(\"rkey2\"))\n\t})\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\ts.Set(\"d1\", \"value\")\n\t\tok(t, s.Copy(0, \"d1\", 0, \"d2\"))\n\t\tequals(t, \"string\", s.Type(\"d2\"))\n\t\ts.CheckGet(t, \"d2\", \"value\")\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c, \"COPY\",\n\t\t\tproto.Error(errWrongNumber(\"copy\")),\n\t\t)\n\t\tmustDo(t, c, \"COPY\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"copy\")),\n\t\t)\n\t\tmustDo(t, c, \"COPY\", \"foo\", \"bar\", \"baz\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_geo.go",
          "type": "blob",
          "size": 12.5615234375,
          "content": "// Commands from https://redis.io/commands#geo\n\npackage miniredis\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsGeo handles GEOADD, GEORADIUS etc.\nfunc commandsGeo(m *Miniredis) {\n\tm.srv.Register(\"GEOADD\", m.cmdGeoadd)\n\tm.srv.Register(\"GEODIST\", m.cmdGeodist)\n\tm.srv.Register(\"GEOPOS\", m.cmdGeopos)\n\tm.srv.Register(\"GEORADIUS\", m.cmdGeoradius)\n\tm.srv.Register(\"GEORADIUS_RO\", m.cmdGeoradius)\n\tm.srv.Register(\"GEORADIUSBYMEMBER\", m.cmdGeoradiusbymember)\n\tm.srv.Register(\"GEORADIUSBYMEMBER_RO\", m.cmdGeoradiusbymember)\n}\n\n// GEOADD\nfunc (m *Miniredis) cmdGeoadd(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 || len(args[1:])%3 != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\tkey, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(key) && db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\ttoSet := map[string]float64{}\n\t\tfor len(args) > 2 {\n\t\t\trawLong, rawLat, name := args[0], args[1], args[2]\n\t\t\targs = args[3:]\n\t\t\tlongitude, err := strconv.ParseFloat(rawLong, 64)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(\"ERR value is not a valid float\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tlatitude, err := strconv.ParseFloat(rawLat, 64)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(\"ERR value is not a valid float\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif latitude < -85.05112878 ||\n\t\t\t\tlatitude > 85.05112878 ||\n\t\t\t\tlongitude < -180 ||\n\t\t\t\tlongitude > 180 {\n\t\t\t\tc.WriteError(fmt.Sprintf(\"ERR invalid longitude,latitude pair %.6f,%.6f\", longitude, latitude))\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttoSet[name] = float64(toGeohash(longitude, latitude))\n\t\t}\n\n\t\tset := 0\n\t\tfor name, score := range toSet {\n\t\t\tif db.ssetAdd(key, score, name) {\n\t\t\t\tset++\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(set)\n\t})\n}\n\n// GEODIST\nfunc (m *Miniredis) cmdGeodist(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, from, to, args := args[0], args[1], args[2], args[3:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tif !db.exists(key) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tunit := \"m\"\n\t\tif len(args) > 0 {\n\t\t\tunit, args = args[0], args[1:]\n\t\t}\n\t\tif len(args) > 0 {\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\n\t\ttoMeter := parseUnit(unit)\n\t\tif toMeter == 0 {\n\t\t\tc.WriteError(msgUnsupportedUnit)\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.sortedsetKeys[key]\n\t\tfromD, okFrom := members.get(from)\n\t\ttoD, okTo := members.get(to)\n\t\tif !okFrom || !okTo {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tfromLo, fromLat := fromGeohash(uint64(fromD))\n\t\ttoLo, toLat := fromGeohash(uint64(toD))\n\n\t\tdist := distance(fromLat, fromLo, toLat, toLo) / toMeter\n\t\tc.WriteBulk(fmt.Sprintf(\"%.4f\", dist))\n\t})\n}\n\n// GEOPOS\nfunc (m *Miniredis) cmdGeopos(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\tkey, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(key) && db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(args))\n\t\tfor _, l := range args {\n\t\t\tif !db.ssetExists(key, l) {\n\t\t\t\tc.WriteLen(-1)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tscore := db.ssetScore(key, l)\n\t\t\tc.WriteLen(2)\n\t\t\tlong, lat := fromGeohash(uint64(score))\n\t\t\tc.WriteBulk(fmt.Sprintf(\"%f\", long))\n\t\t\tc.WriteBulk(fmt.Sprintf(\"%f\", lat))\n\t\t}\n\t})\n}\n\ntype geoDistance struct {\n\tName      string\n\tScore     float64\n\tDistance  float64\n\tLongitude float64\n\tLatitude  float64\n}\n\n// GEORADIUS and GEORADIUS_RO\nfunc (m *Miniredis) cmdGeoradius(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 5 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\tlongitude, err := strconv.ParseFloat(args[1], 64)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tlatitude, err := strconv.ParseFloat(args[2], 64)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tradius, err := strconv.ParseFloat(args[3], 64)\n\tif err != nil || radius < 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\ttoMeter := parseUnit(args[4])\n\tif toMeter == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\targs = args[5:]\n\n\tvar opts struct {\n\t\twithDist      bool\n\t\twithCoord     bool\n\t\tdirection     direction // unsorted\n\t\tcount         int\n\t\twithStore     bool\n\t\tstoreKey      string\n\t\twithStoredist bool\n\t\tstoredistKey  string\n\t}\n\tfor len(args) > 0 {\n\t\targ := args[0]\n\t\targs = args[1:]\n\t\tswitch strings.ToUpper(arg) {\n\t\tcase \"WITHCOORD\":\n\t\t\topts.withCoord = true\n\t\tcase \"WITHDIST\":\n\t\t\topts.withDist = true\n\t\tcase \"ASC\":\n\t\t\topts.direction = asc\n\t\tcase \"DESC\":\n\t\t\topts.direction = desc\n\t\tcase \"COUNT\":\n\t\t\tif len(args) == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tn, err := strconv.Atoi(args[0])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n <= 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR COUNT must be > 0\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\targs = args[1:]\n\t\t\topts.count = n\n\t\tcase \"STORE\":\n\t\t\tif len(args) == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withStore = true\n\t\t\topts.storeKey = args[0]\n\t\t\targs = args[1:]\n\t\tcase \"STOREDIST\":\n\t\t\tif len(args) == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withStoredist = true\n\t\t\topts.storedistKey = args[0]\n\t\t\targs = args[1:]\n\t\tdefault:\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif strings.ToUpper(cmd) == \"GEORADIUS_RO\" && (opts.withStore || opts.withStoredist) {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR syntax error\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif (opts.withStore || opts.withStoredist) && (opts.withDist || opts.withCoord) {\n\t\t\tc.WriteError(\"ERR STORE option in GEORADIUS is not compatible with WITHDIST, WITHHASH and WITHCOORDS options\")\n\t\t\treturn\n\t\t}\n\n\t\tdb := m.db(ctx.selectedDB)\n\t\tmembers := db.ssetElements(key)\n\n\t\tmatches := withinRadius(members, longitude, latitude, radius*toMeter)\n\n\t\t// deal with ASC/DESC\n\t\tif opts.direction != unsorted {\n\t\t\tsort.Slice(matches, func(i, j int) bool {\n\t\t\t\tif opts.direction == desc {\n\t\t\t\t\treturn matches[i].Distance > matches[j].Distance\n\t\t\t\t}\n\t\t\t\treturn matches[i].Distance < matches[j].Distance\n\t\t\t})\n\t\t}\n\n\t\t// deal with COUNT\n\t\tif opts.count > 0 && len(matches) > opts.count {\n\t\t\tmatches = matches[:opts.count]\n\t\t}\n\n\t\t// deal with \"STORE x\"\n\t\tif opts.withStore {\n\t\t\tdb.del(opts.storeKey, true)\n\t\t\tfor _, member := range matches {\n\t\t\t\tdb.ssetAdd(opts.storeKey, member.Score, member.Name)\n\t\t\t}\n\t\t\tc.WriteInt(len(matches))\n\t\t\treturn\n\t\t}\n\n\t\t// deal with \"STOREDIST x\"\n\t\tif opts.withStoredist {\n\t\t\tdb.del(opts.storedistKey, true)\n\t\t\tfor _, member := range matches {\n\t\t\t\tdb.ssetAdd(opts.storedistKey, member.Distance/toMeter, member.Name)\n\t\t\t}\n\t\t\tc.WriteInt(len(matches))\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(matches))\n\t\tfor _, member := range matches {\n\t\t\tif !opts.withDist && !opts.withCoord {\n\t\t\t\tc.WriteBulk(member.Name)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlen := 1\n\t\t\tif opts.withDist {\n\t\t\t\tlen++\n\t\t\t}\n\t\t\tif opts.withCoord {\n\t\t\t\tlen++\n\t\t\t}\n\t\t\tc.WriteLen(len)\n\t\t\tc.WriteBulk(member.Name)\n\t\t\tif opts.withDist {\n\t\t\t\tc.WriteBulk(fmt.Sprintf(\"%.4f\", member.Distance/toMeter))\n\t\t\t}\n\t\t\tif opts.withCoord {\n\t\t\t\tc.WriteLen(2)\n\t\t\t\tc.WriteBulk(fmt.Sprintf(\"%f\", member.Longitude))\n\t\t\t\tc.WriteBulk(fmt.Sprintf(\"%f\", member.Latitude))\n\t\t\t}\n\t\t}\n\t})\n}\n\n// GEORADIUSBYMEMBER and GEORADIUSBYMEMBER_RO\nfunc (m *Miniredis) cmdGeoradiusbymember(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 4 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey     string\n\t\tmember  string\n\t\tradius  float64\n\t\ttoMeter float64\n\n\t\twithDist      bool\n\t\twithCoord     bool\n\t\tdirection     direction // unsorted\n\t\tcount         int\n\t\twithStore     bool\n\t\tstoreKey      string\n\t\twithStoredist bool\n\t\tstoredistKey  string\n\t}{\n\t\tkey:    args[0],\n\t\tmember: args[1],\n\t}\n\n\tr, err := strconv.ParseFloat(args[2], 64)\n\tif err != nil || r < 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\topts.radius = r\n\n\topts.toMeter = parseUnit(args[3])\n\tif opts.toMeter == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\targs = args[4:]\n\n\tfor len(args) > 0 {\n\t\targ := args[0]\n\t\targs = args[1:]\n\t\tswitch strings.ToUpper(arg) {\n\t\tcase \"WITHCOORD\":\n\t\t\topts.withCoord = true\n\t\tcase \"WITHDIST\":\n\t\t\topts.withDist = true\n\t\tcase \"ASC\":\n\t\t\topts.direction = asc\n\t\tcase \"DESC\":\n\t\t\topts.direction = desc\n\t\tcase \"COUNT\":\n\t\t\tif len(args) == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tn, err := strconv.Atoi(args[0])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n <= 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR COUNT must be > 0\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\targs = args[1:]\n\t\t\topts.count = n\n\t\tcase \"STORE\":\n\t\t\tif len(args) == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withStore = true\n\t\t\topts.storeKey = args[0]\n\t\t\targs = args[1:]\n\t\tcase \"STOREDIST\":\n\t\t\tif len(args) == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withStoredist = true\n\t\t\topts.storedistKey = args[0]\n\t\t\targs = args[1:]\n\t\tdefault:\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(\"ERR syntax error\")\n\t\t\treturn\n\t\t}\n\t}\n\n\tif strings.ToUpper(cmd) == \"GEORADIUSBYMEMBER_RO\" && (opts.withStore || opts.withStoredist) {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR syntax error\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tif (opts.withStore || opts.withStoredist) && (opts.withDist || opts.withCoord) {\n\t\t\tc.WriteError(\"ERR STORE option in GEORADIUS is not compatible with WITHDIST, WITHHASH and WITHCOORDS options\")\n\t\t\treturn\n\t\t}\n\n\t\tdb := m.db(ctx.selectedDB)\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\t// get position of member\n\t\tif !db.ssetExists(opts.key, opts.member) {\n\t\t\tc.WriteError(\"ERR could not decode requested zset member\")\n\t\t\treturn\n\t\t}\n\t\tscore := db.ssetScore(opts.key, opts.member)\n\t\tlongitude, latitude := fromGeohash(uint64(score))\n\n\t\tmembers := db.ssetElements(opts.key)\n\t\tmatches := withinRadius(members, longitude, latitude, opts.radius*opts.toMeter)\n\n\t\t// deal with ASC/DESC\n\t\tif opts.direction != unsorted {\n\t\t\tsort.Slice(matches, func(i, j int) bool {\n\t\t\t\tif opts.direction == desc {\n\t\t\t\t\treturn matches[i].Distance > matches[j].Distance\n\t\t\t\t}\n\t\t\t\treturn matches[i].Distance < matches[j].Distance\n\t\t\t})\n\t\t}\n\n\t\t// deal with COUNT\n\t\tif opts.count > 0 && len(matches) > opts.count {\n\t\t\tmatches = matches[:opts.count]\n\t\t}\n\n\t\t// deal with \"STORE x\"\n\t\tif opts.withStore {\n\t\t\tdb.del(opts.storeKey, true)\n\t\t\tfor _, member := range matches {\n\t\t\t\tdb.ssetAdd(opts.storeKey, member.Score, member.Name)\n\t\t\t}\n\t\t\tc.WriteInt(len(matches))\n\t\t\treturn\n\t\t}\n\n\t\t// deal with \"STOREDIST x\"\n\t\tif opts.withStoredist {\n\t\t\tdb.del(opts.storedistKey, true)\n\t\t\tfor _, member := range matches {\n\t\t\t\tdb.ssetAdd(opts.storedistKey, member.Distance/opts.toMeter, member.Name)\n\t\t\t}\n\t\t\tc.WriteInt(len(matches))\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(matches))\n\t\tfor _, member := range matches {\n\t\t\tif !opts.withDist && !opts.withCoord {\n\t\t\t\tc.WriteBulk(member.Name)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tlen := 1\n\t\t\tif opts.withDist {\n\t\t\t\tlen++\n\t\t\t}\n\t\t\tif opts.withCoord {\n\t\t\t\tlen++\n\t\t\t}\n\t\t\tc.WriteLen(len)\n\t\t\tc.WriteBulk(member.Name)\n\t\t\tif opts.withDist {\n\t\t\t\tc.WriteBulk(fmt.Sprintf(\"%.4f\", member.Distance/opts.toMeter))\n\t\t\t}\n\t\t\tif opts.withCoord {\n\t\t\t\tc.WriteLen(2)\n\t\t\t\tc.WriteBulk(fmt.Sprintf(\"%f\", member.Longitude))\n\t\t\t\tc.WriteBulk(fmt.Sprintf(\"%f\", member.Latitude))\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc withinRadius(members []ssElem, longitude, latitude, radius float64) []geoDistance {\n\tmatches := []geoDistance{}\n\tfor _, el := range members {\n\t\telLo, elLat := fromGeohash(uint64(el.score))\n\t\tdistanceInMeter := distance(latitude, longitude, elLat, elLo)\n\n\t\tif distanceInMeter <= radius {\n\t\t\tmatches = append(matches, geoDistance{\n\t\t\t\tName:      el.member,\n\t\t\t\tScore:     el.score,\n\t\t\t\tDistance:  distanceInMeter,\n\t\t\t\tLongitude: elLo,\n\t\t\t\tLatitude:  elLat,\n\t\t\t})\n\t\t}\n\t}\n\treturn matches\n}\n\nfunc parseUnit(u string) float64 {\n\tswitch strings.ToLower(u) {\n\tcase \"m\":\n\t\treturn 1\n\tcase \"km\":\n\t\treturn 1000\n\tcase \"mi\":\n\t\treturn 1609.34\n\tcase \"ft\":\n\t\treturn 0.3048\n\tdefault:\n\t\treturn 0\n\t}\n}\n"
        },
        {
          "name": "cmd_geo_test.go",
          "type": "blob",
          "size": 10.490234375,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestGeoadd(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tt.Run(\"ok\", func(t *testing.T) {\n\t\tmust1(t, c, \"GEOADD\", \"Sicily\", \"13.361389\", \"38.115556\", \"Palermo\")\n\t\tmust1(t, c, \"GEOADD\", \"Sicily\", \"15.087269\", \"37.502669\", \"Catania\")\n\t})\n\n\tt.Run(\"failure cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEOADD\", \"broken\", \"-190.0\", \"10.0\", \"hi\",\n\t\t\tproto.Error(\"ERR invalid longitude,latitude pair -190.000000,10.000000\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEOADD\", \"broken\", \"190.0\", \"10.0\", \"hi\",\n\t\t\tproto.Error(\"ERR invalid longitude,latitude pair 190.000000,10.000000\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEOADD\", \"broken\", \"10.0\", \"-86.0\", \"hi\",\n\t\t\tproto.Error(\"ERR invalid longitude,latitude pair 10.000000,-86.000000\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEOADD\", \"broken\", \"10.0\", \"86.0\", \"hi\",\n\t\t\tproto.Error(\"ERR invalid longitude,latitude pair 10.000000,86.000000\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEOADD\", \"broken\", \"notafloat\", \"10.0\", \"hi\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEOADD\", \"broken\", \"10.0\", \"notafloat\", \"hi\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t})\n}\n\nfunc TestGeopos(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"13.361389\", \"38.115556\", \"Palermo\")\n\n\tt.Run(\"ok\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEOPOS\", \"Sicily\", \"Palermo\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"13.361389\", \"38.115556\"),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"no location\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEOPOS\", \"Sicily\", \"Corleone\",\n\t\t\tproto.Array(proto.NilList),\n\t\t)\n\t})\n\n\tt.Run(\"failure cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEOPOS\",\n\t\t\tproto.Error(errWrongNumber(\"geopos\")),\n\t\t)\n\t\ts.Set(\"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"GEOPOS\", \"foo\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test GEOADD / GEORADIUS / GEORADIUS_RO\nfunc TestGeo(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"13.361389\", \"38.115556\", \"Palermo\")\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"15.087269\", \"37.502669\", \"Catania\")\n\n\tt.Run(\"WITHDIST WITHCOORD\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"WITHDIST\", \"WITHCOORD\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"Palermo\"),\n\t\t\t\t\tproto.String(\"190.4424\"),\n\t\t\t\t\tproto.Strings(\"13.361389\", \"38.115556\"),\n\t\t\t\t),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"Catania\"),\n\t\t\t\t\tproto.String(\"56.4413\"),\n\t\t\t\t\tproto.Strings(\"15.087267\", \"37.502668\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"WITHCOORD\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"WITHCOORD\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"Palermo\"),\n\t\t\t\t\tproto.Strings(\"13.361389\", \"38.115556\"),\n\t\t\t\t),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"Catania\"),\n\t\t\t\t\tproto.Strings(\"15.087267\", \"37.502668\"),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"WITHDIST\", func(t *testing.T) {\n\t\t// in KM\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"WITHDIST\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"Palermo\", \"190.4424\"),\n\t\t\t\tproto.Strings(\"Catania\", \"56.4413\"),\n\t\t\t),\n\t\t)\n\n\t\t// in meter\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200000\", \"m\", \"WITHDIST\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"Palermo\", \"190442.4351\"),\n\t\t\t\tproto.Strings(\"Catania\", \"56441.2660\"),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"ASC DESC\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"ASC\",\n\t\t\tproto.Strings(\"Catania\", \"Palermo\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"DESC\",\n\t\t\tproto.Strings(\"Palermo\", \"Catania\"),\n\t\t)\n\t})\n\n\tt.Run(\"COUNT\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"ASC\", \"COUNT\", \"1\",\n\t\t\tproto.Strings(\"Catania\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"ASC\", \"COUNT\", \"99\",\n\t\t\tproto.Strings(\"Catania\", \"Palermo\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"COUNT\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"COUNT\", \"notanumber\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"COUNT\", \"-12\",\n\t\t\tproto.Error(\"ERR COUNT must be > 0\"),\n\t\t)\n\t})\n\n\tt.Run(\"no args\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"km\",\n\t\t\tproto.Strings(\"Palermo\", \"Catania\"),\n\t\t)\n\n\t\t// Too small radius\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"1\", \"km\",\n\t\t\tproto.Array(),\n\t\t)\n\n\t\t// Wrong coords\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"80\", \"80\", \"200\", \"km\",\n\t\t\tproto.Array(),\n\t\t)\n\n\t\t// Wrong map key\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Capri\", \"15\", \"37\", \"200\", \"km\",\n\t\t\tproto.Array(),\n\t\t)\n\n\t\t// Unsupported/unknown distance unit\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"15\", \"37\", \"200\", \"mm\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'georadius' command\"),\n\t\t)\n\n\t\t// Wrong parameter type\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS\", \"Sicily\", \"abc\", \"def\", \"ghi\", \"m\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'georadius' command\"),\n\t\t)\n\t})\n\n\tt.Run(\"GEORADIUS_RO\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS_RO\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"ASC\",\n\t\t\tproto.Strings(\"Catania\", \"Palermo\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS_RO\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"STORE\", \"foo\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUS_RO\", \"Sicily\", \"15\", \"37\", \"200\", \"km\", \"STOREDIST\", \"foo\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n}\n\nfunc TestGeodist(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"13.361389\", \"38.115556\", \"Palermo\")\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"15.087269\", \"37.502669\", \"Catania\")\n\n\tt.Run(\"no unit\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEODIST\", \"Sicily\", \"Palermo\", \"Catania\",\n\t\t\tproto.String(\"166274.1514\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEODIST\", \"Sicily\", \"Palermo\", \"Catania\", \"km\",\n\t\t\tproto.String(\"166.2742\"),\n\t\t)\n\t})\n\n\tt.Run(\"no such key\", func(t *testing.T) {\n\t\tmustNil(t, c, \"GEODIST\", \"nosuch\", \"nosuch\", \"nosuch\")\n\t\tmustNil(t, c, \"GEODIST\", \"Sicily\", \"Palermo\", \"nosuch\")\n\t\tmustNil(t, c, \"GEODIST\", \"Sicily\", \"nosuch\", \"Catania\")\n\t})\n\n\tt.Run(\"failure cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEODIST\",\n\t\t\tproto.Error(errWrongNumber(\"geodist\")),\n\t\t)\n\t\tmustDo(t, c, \"GEODIST\", \"Sicily\",\n\t\t\tproto.Error(errWrongNumber(\"geodist\")),\n\t\t)\n\t\tmustDo(t, c, \"GEODIST\", \"Sicily\", \"Palermo\",\n\t\t\tproto.Error(errWrongNumber(\"geodist\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEODIST\", \"Sicily\", \"Palermo\", \"Catania\", \"miles\",\n\t\t\tproto.Error(\"ERR unsupported unit provided. please use M, KM, FT, MI\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GEODIST\", \"Sicily\", \"Palermo\", \"Catania\", \"m\", \"too many\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"GEODIST\", \"foo\", \"Palermo\", \"Catania\",\n\t\t\tproto.Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"),\n\t\t)\n\t})\n}\n\n// Test GEOADD / GEORADIUSBYMEMBER / GEORADIUSBYMEMBER_RO\nfunc TestGeobymember(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"13.361389\", \"38.115556\", \"Palermo\")\n\tmust1(t, c, \"GEOADD\", \"Sicily\", \"15.087269\", \"37.502669\", \"Catania\")\n\n\tt.Run(\"WITHDIST WITHCOORD\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"WITHDIST\", \"WITHCOORD\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"Palermo\"), proto.String(\"0.0000\"), proto.Strings(\"13.361389\", \"38.115556\")),\n\t\t\t\tproto.Array(proto.String(\"Catania\"), proto.String(\"166.2742\"), proto.Strings(\"15.087267\", \"37.502668\")),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"WITHCOORD\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"WITHCOORD\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"Palermo\"), proto.Strings(\"13.361389\", \"38.115556\")),\n\t\t\t\tproto.Array(proto.String(\"Catania\"), proto.Strings(\"15.087267\", \"37.502668\")),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"WITHDIST\", func(t *testing.T) {\n\t\t// in km\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"WITHDIST\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"Palermo\", \"0.0000\"),\n\t\t\t\tproto.Strings(\"Catania\", \"166.2742\"),\n\t\t\t),\n\t\t)\n\n\t\t// in meter\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200000\", \"m\", \"WITHDIST\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"Palermo\", \"0.0000\"),\n\t\t\t\tproto.Strings(\"Catania\", \"166274.1514\"), // in meter\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"ASC DESC\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"ASC\",\n\t\t\tproto.Strings(\"Palermo\", \"Catania\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Catania\", \"200\", \"km\", \"ASC\",\n\t\t\tproto.Strings(\"Catania\", \"Palermo\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"DESC\",\n\t\t\tproto.Strings(\"Catania\", \"Palermo\"),\n\t\t)\n\t})\n\n\tt.Run(\"COUNT\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"ASC\", \"COUNT\", \"1\",\n\t\t\tproto.Strings(\"Palermo\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"ASC\", \"COUNT\", \"99\",\n\t\t\tproto.Strings(\"Palermo\", \"Catania\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"COUNT\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"COUNT\", \"notanumber\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"COUNT\", \"-12\",\n\t\t\tproto.Error(\"ERR COUNT must be > 0\"),\n\t\t)\n\t})\n\n\tt.Run(\"no args\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"km\",\n\t\t\tproto.Strings(\"Palermo\", \"Catania\"),\n\t\t)\n\n\t\t// Wrong map key\n\t\tmustNil(t, c, \"GEORADIUSBYMEMBER\", \"Capri\", \"Palermo\", \"200\", \"km\")\n\n\t\t// Missing member\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"nosuch\", \"200\", \"km\",\n\t\t\tproto.Error(\"ERR could not decode requested zset member\"),\n\t\t)\n\n\t\t// Unsupported/unknown distance unit\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"Palermo\", \"200\", \"mm\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'georadiusbymember' command\"),\n\t\t)\n\n\t\t// Wrong parameter type\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER\", \"Sicily\", \"abc\", \"def\", \"ghi\", \"m\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'georadiusbymember' command\"),\n\t\t)\n\t})\n\n\tt.Run(\"GEORADIUSBYMEMBER_RO\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER_RO\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"ASC\",\n\t\t\tproto.Strings(\"Palermo\", \"Catania\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER_RO\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"STORE\", \"foo\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"GEORADIUSBYMEMBER_RO\", \"Sicily\", \"Palermo\", \"200\", \"km\", \"STOREDIST\", \"foo\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_hash.go",
          "type": "blob",
          "size": 13.509765625,
          "content": "// Commands from https://redis.io/commands#hash\n\npackage miniredis\n\nimport (\n\t\"math/big\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsHash handles all hash value operations.\nfunc commandsHash(m *Miniredis) {\n\tm.srv.Register(\"HDEL\", m.cmdHdel)\n\tm.srv.Register(\"HEXISTS\", m.cmdHexists)\n\tm.srv.Register(\"HGET\", m.cmdHget)\n\tm.srv.Register(\"HGETALL\", m.cmdHgetall)\n\tm.srv.Register(\"HINCRBY\", m.cmdHincrby)\n\tm.srv.Register(\"HINCRBYFLOAT\", m.cmdHincrbyfloat)\n\tm.srv.Register(\"HKEYS\", m.cmdHkeys)\n\tm.srv.Register(\"HLEN\", m.cmdHlen)\n\tm.srv.Register(\"HMGET\", m.cmdHmget)\n\tm.srv.Register(\"HMSET\", m.cmdHmset)\n\tm.srv.Register(\"HSET\", m.cmdHset)\n\tm.srv.Register(\"HSETNX\", m.cmdHsetnx)\n\tm.srv.Register(\"HSTRLEN\", m.cmdHstrlen)\n\tm.srv.Register(\"HVALS\", m.cmdHvals)\n\tm.srv.Register(\"HSCAN\", m.cmdHscan)\n\tm.srv.Register(\"HRANDFIELD\", m.cmdHrandfield)\n}\n\n// HSET\nfunc (m *Miniredis) cmdHset(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, pairs := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif len(pairs)%2 == 1 {\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\n\t\tif t, ok := db.keys[key]; ok && t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tnew := db.hashSet(key, pairs...)\n\t\tc.WriteInt(new)\n\t})\n}\n\n// HSETNX\nfunc (m *Miniredis) cmdHsetnx(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey   string\n\t\tfield string\n\t\tvalue string\n\t}{\n\t\tkey:   args[0],\n\t\tfield: args[1],\n\t\tvalue: args[2],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := db.hashKeys[opts.key]; !ok {\n\t\t\tdb.hashKeys[opts.key] = map[string]string{}\n\t\t\tdb.keys[opts.key] = \"hash\"\n\t\t}\n\t\t_, ok := db.hashKeys[opts.key][opts.field]\n\t\tif ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tdb.hashKeys[opts.key][opts.field] = opts.value\n\t\tdb.incr(opts.key)\n\t\tc.WriteInt(1)\n\t})\n}\n\n// HMSET\nfunc (m *Miniredis) cmdHmset(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, args := args[0], args[1:]\n\tif len(args)%2 != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[key]; ok && t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tfor len(args) > 0 {\n\t\t\tfield, value := args[0], args[1]\n\t\t\targs = args[2:]\n\t\t\tdb.hashSet(key, field, value)\n\t\t}\n\t\tc.WriteOK()\n\t})\n}\n\n// HGET\nfunc (m *Miniredis) cmdHget(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, field := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tvalue, ok := db.hashKeys[key][field]\n\t\tif !ok {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tc.WriteBulk(value)\n\t})\n}\n\n// HDEL\nfunc (m *Miniredis) cmdHdel(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey    string\n\t\tfields []string\n\t}{\n\t\tkey:    args[0],\n\t\tfields: args[1:],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[opts.key]\n\t\tif !ok {\n\t\t\t// No key is zero deleted\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tdeleted := 0\n\t\tfor _, f := range opts.fields {\n\t\t\t_, ok := db.hashKeys[opts.key][f]\n\t\t\tif !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdelete(db.hashKeys[opts.key], f)\n\t\t\tdeleted++\n\t\t}\n\t\tc.WriteInt(deleted)\n\n\t\t// Nothing left. Remove the whole key.\n\t\tif len(db.hashKeys[opts.key]) == 0 {\n\t\t\tdb.del(opts.key, true)\n\t\t}\n\t})\n}\n\n// HEXISTS\nfunc (m *Miniredis) cmdHexists(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey   string\n\t\tfield string\n\t}{\n\t\tkey:   args[0],\n\t\tfield: args[1],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[opts.key]\n\t\tif !ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := db.hashKeys[opts.key][opts.field]; !ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(1)\n\t})\n}\n\n// HGETALL\nfunc (m *Miniredis) cmdHgetall(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\tc.WriteMapLen(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteMapLen(len(db.hashKeys[key]))\n\t\tfor _, k := range db.hashFields(key) {\n\t\t\tc.WriteBulk(k)\n\t\t\tc.WriteBulk(db.hashGet(key, k))\n\t\t}\n\t})\n}\n\n// HKEYS\nfunc (m *Miniredis) cmdHkeys(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteLen(0)\n\t\t\treturn\n\t\t}\n\t\tif db.t(key) != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tfields := db.hashFields(key)\n\t\tc.WriteLen(len(fields))\n\t\tfor _, f := range fields {\n\t\t\tc.WriteBulk(f)\n\t\t}\n\t})\n}\n\n// HSTRLEN\nfunc (m *Miniredis) cmdHstrlen(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\thash, key := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[hash]\n\t\tif !ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tkeys := db.hashKeys[hash]\n\t\tc.WriteInt(len(keys[key]))\n\t})\n}\n\n// HVALS\nfunc (m *Miniredis) cmdHvals(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\tc.WriteLen(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tvals := db.hashValues(key)\n\t\tc.WriteLen(len(vals))\n\t\tfor _, v := range vals {\n\t\t\tc.WriteBulk(v)\n\t\t}\n\t})\n}\n\n// HLEN\nfunc (m *Miniredis) cmdHlen(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(len(db.hashKeys[key]))\n\t})\n}\n\n// HMGET\nfunc (m *Miniredis) cmdHmget(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[key]; ok && t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tf, ok := db.hashKeys[key]\n\t\tif !ok {\n\t\t\tf = map[string]string{}\n\t\t}\n\n\t\tc.WriteLen(len(args) - 1)\n\t\tfor _, k := range args[1:] {\n\t\t\tv, ok := f[k]\n\t\t\tif !ok {\n\t\t\t\tc.WriteNull()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.WriteBulk(v)\n\t\t}\n\t})\n}\n\n// HINCRBY\nfunc (m *Miniredis) cmdHincrby(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey   string\n\t\tfield string\n\t\tdelta int\n\t}{\n\t\tkey:   args[0],\n\t\tfield: args[1],\n\t}\n\tif ok := optInt(c, args[2], &opts.delta); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv, err := db.hashIncr(opts.key, opts.field, opts.delta)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(v)\n\t})\n}\n\n// HINCRBYFLOAT\nfunc (m *Miniredis) cmdHincrbyfloat(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey   string\n\t\tfield string\n\t\tdelta *big.Float\n\t}{\n\t\tkey:   args[0],\n\t\tfield: args[1],\n\t}\n\tdelta, _, err := big.ParseFloat(args[2], 10, 128, 0)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidFloat)\n\t\treturn\n\t}\n\topts.delta = delta\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"hash\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv, err := db.hashIncrfloat(opts.key, opts.field, opts.delta)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.WriteBulk(formatBig(v))\n\t})\n}\n\n// HSCAN\nfunc (m *Miniredis) cmdHscan(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey       string\n\t\tcursor    int\n\t\twithMatch bool\n\t\tmatch     string\n\t}{\n\t\tkey: args[0],\n\t}\n\tif ok := optIntErr(c, args[1], &opts.cursor, msgInvalidCursor); !ok {\n\t\treturn\n\t}\n\targs = args[2:]\n\n\t// MATCH and COUNT options\n\tfor len(args) > 0 {\n\t\tif strings.ToLower(args[0]) == \"count\" {\n\t\t\t// we do nothing with count\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err := strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tif strings.ToLower(args[0]) == \"match\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withMatch = true\n\t\t\topts.match, args = args[1], args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\t// return _all_ (matched) keys every time\n\n\t\tif opts.cursor != 0 {\n\t\t\t// Invalid cursor.\n\t\t\tc.WriteLen(2)\n\t\t\tc.WriteBulk(\"0\") // no next cursor\n\t\t\tc.WriteLen(0)    // no elements\n\t\t\treturn\n\t\t}\n\t\tif db.exists(opts.key) && db.t(opts.key) != \"hash\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.hashFields(opts.key)\n\t\tif opts.withMatch {\n\t\t\tmembers, _ = matchKeys(members, opts.match)\n\t\t}\n\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(\"0\") // no next cursor\n\t\t// HSCAN gives key, values.\n\t\tc.WriteLen(len(members) * 2)\n\t\tfor _, k := range members {\n\t\t\tc.WriteBulk(k)\n\t\t\tc.WriteBulk(db.hashGet(opts.key, k))\n\t\t}\n\t})\n}\n\n// HRANDFIELD\nfunc (m *Miniredis) cmdHrandfield(c *server.Peer, cmd string, args []string) {\n\tif len(args) > 3 || len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey        string\n\t\tcount      int\n\t\tcountSet   bool\n\t\twithValues bool\n\t}{\n\t\tkey: args[0],\n\t}\n\n\tif len(args) > 1 {\n\t\tif ok := optIntErr(c, args[1], &opts.count, msgInvalidInt); !ok {\n\t\t\treturn\n\t\t}\n\t\topts.countSet = true\n\t}\n\n\tif len(args) == 3 {\n\t\tif strings.ToLower(args[2]) == \"withvalues\" {\n\t\t\topts.withValues = true\n\t\t} else {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t}\n\n\twithTx(m, c, func(peer *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tmembers := db.hashFields(opts.key)\n\t\tm.shuffle(members)\n\n\t\tif !opts.countSet {\n\t\t\t// > When called with just the key argument, return a random field from the\n\t\t\t// hash value stored at key.\n\t\t\tif len(members) == 0 {\n\t\t\t\tpeer.WriteNull()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tpeer.WriteBulk(members[0])\n\t\t\treturn\n\t\t}\n\n\t\tif len(members) > abs(opts.count) {\n\t\t\tmembers = members[:abs(opts.count)]\n\t\t}\n\t\tswitch {\n\t\tcase opts.count >= 0:\n\t\t\t// if count is positive there can't be duplicates, and the length is restricted\n\t\tcase opts.count < 0:\n\t\t\t// if count is negative there can be duplicates, but length will match\n\t\t\tif len(members) > 0 {\n\t\t\t\tfor len(members) < -opts.count {\n\t\t\t\t\tmembers = append(members, members[m.randIntn(len(members))])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif opts.withValues {\n\t\t\tpeer.WriteMapLen(len(members))\n\t\t\tfor _, m := range members {\n\t\t\t\tpeer.WriteBulk(m)\n\t\t\t\tpeer.WriteBulk(db.hashGet(opts.key, m))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tpeer.WriteLen(len(members))\n\t\tfor _, m := range members {\n\t\t\tpeer.WriteBulk(m)\n\t\t}\n\t})\n}\n\nfunc abs(n int) int {\n\tif n < 0 {\n\t\treturn -n\n\t}\n\treturn n\n}\n"
        },
        {
          "name": "cmd_hash_test.go",
          "type": "blob",
          "size": 14.154296875,
          "content": "package miniredis\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestHash(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmust1(t, c, \"HSET\", \"aap\", \"noot\", \"mies\")\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"aap\", \"noot\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\tequals(t, \"mies\", s.HGet(\"aap\", \"noot\"))\n\n\t\t// Existing field.\n\t\tmust0(t, c, \"HSET\", \"aap\", \"noot\", \"mies\")\n\n\t\t// Multiple fields.\n\t\tmustDo(t, c,\n\t\t\t\"HSET\", \"aaa\", \"bbb\", \"cc\", \"ddd\", \"ee\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"aaa\", \"bbb\",\n\t\t\tproto.String(\"cc\"),\n\t\t)\n\t\tequals(t, \"cc\", s.HGet(\"aaa\", \"bbb\"))\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"aaa\", \"ddd\",\n\t\t\tproto.String(\"ee\"),\n\t\t)\n\t\tequals(t, \"ee\", s.HGet(\"aaa\", \"ddd\"))\n\t})\n\n\tt.Run(\"wrong key type\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"HSET\", \"foo\", \"noot\", \"mies\",\n\t\t\tproto.Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"),\n\t\t)\n\t})\n\n\tt.Run(\"unmatched pairs\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"HSET\", \"a\", \"b\", \"c\", \"d\",\n\t\t\tproto.Error(errWrongNumber(\"hset\")),\n\t\t)\n\t})\n\n\tt.Run(\"no such key\", func(t *testing.T) {\n\t\tmustNil(t, c, \"HGET\", \"aap\", \"nosuch\")\n\t})\n\n\tt.Run(\"no such hash\", func(t *testing.T) {\n\t\tmustNil(t, c, \"HGET\", \"nosuch\", \"nosuch\")\n\t\tequals(t, \"\", s.HGet(\"nosuch\", \"nosuch\"))\n\t})\n\n\tt.Run(\"wrong type\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"aap\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'hget' command\"),\n\t\t)\n\t})\n\n\tt.Run(\"direct HSet()\", func(t *testing.T) {\n\t\ts.HSet(\"wim\", \"zus\", \"jet\")\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"wim\", \"zus\",\n\t\t\tproto.String(\"jet\"),\n\t\t)\n\n\t\ts.HSet(\"xxx\", \"yyy\", \"a\", \"zzz\", \"b\")\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"xxx\", \"yyy\",\n\t\t\tproto.String(\"a\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HGET\", \"xxx\", \"zzz\",\n\t\t\tproto.String(\"b\"),\n\t\t)\n\t})\n}\n\nfunc TestHashSetNX(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// New Hash\n\tmust1(t, c, \"HSETNX\", \"wim\", \"zus\", \"jet\")\n\n\tmust0(t, c, \"HSETNX\", \"wim\", \"zus\", \"jet\")\n\n\t// Just a new key\n\tmust1(t, c, \"HSETNX\", \"wim\", \"aap\", \"noot\")\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c,\n\t\t\"HSETNX\", \"foo\", \"nosuch\", \"nosuch\",\n\t\tproto.Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"),\n\t)\n}\n\nfunc TestHashMSet(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// New Hash\n\t{\n\t\tmustOK(t, c, \"HMSET\", \"hash\", \"wim\", \"zus\", \"jet\", \"vuur\")\n\n\t\tequals(t, \"zus\", s.HGet(\"hash\", \"wim\"))\n\t\tequals(t, \"vuur\", s.HGet(\"hash\", \"jet\"))\n\t}\n\n\t// Doesn't touch ttl.\n\t{\n\t\ts.SetTTL(\"hash\", time.Second*999)\n\t\tmustOK(t, c, \"HMSET\", \"hash\", \"gijs\", \"lam\")\n\t\tequals(t, time.Second*999, s.TTL(\"hash\"))\n\t}\n\n\t{\n\t\t// Wrong key type\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c, \"HMSET\", \"str\", \"key\", \"value\", proto.Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"))\n\n\t\t// Usage error\n\t\tmustDo(t, c, \"HMSET\", \"str\", proto.Error(errWrongNumber(\"hmset\")))\n\t\tmustDo(t, c, \"HMSET\", \"str\", \"odd\", proto.Error(errWrongNumber(\"hmset\")))\n\t\tmustDo(t, c, \"HMSET\", \"str\", \"key\", \"value\", \"odd\", proto.Error(errWrongNumber(\"hmset\")))\n\t}\n}\n\nfunc TestHashDel(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\tmustDo(t, c, \"HDEL\", \"wim\", \"zus\", \"gijs\", proto.Int(2))\n\n\tmust0(t, c, \"HDEL\", \"wim\", \"nosuch\")\n\n\t// Deleting all makes the key disappear\n\tmustDo(t, c, \"HDEL\", \"wim\", \"teun\", \"kees\", proto.Int(2))\n\tassert(t, !s.Exists(\"wim\"), \"no more wim key\")\n\n\t// Key doesn't exists.\n\tmust0(t, c, \"HDEL\", \"nosuch\", \"nosuch\")\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c, \"HDEL\", \"foo\", \"nosuch\", proto.Error(msgWrongType))\n\n\t// Direct HDel()\n\ts.HSet(\"aap\", \"noot\", \"mies\")\n\ts.HDel(\"aap\", \"noot\")\n\tequals(t, \"\", s.HGet(\"aap\", \"noot\"))\n}\n\nfunc TestHashExists(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\tmust1(t, c, \"HEXISTS\", \"wim\", \"zus\")\n\tmust0(t, c, \"HEXISTS\", \"wim\", \"nosuch\")\n\tmust0(t, c, \"HEXISTS\", \"nosuch\", \"nosuch\")\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c,\n\t\t\"HEXISTS\", \"foo\", \"nosuch\",\n\t\tproto.Error(msgWrongType),\n\t)\n}\n\nfunc TestHashGetall(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\tmustDo(t, c,\n\t\t\"HGETALL\", \"wim\",\n\t\tproto.Strings(\n\t\t\t\"gijs\", \"lam\",\n\t\t\t\"kees\", \"bok\",\n\t\t\t\"teun\", \"vuur\",\n\t\t\t\"zus\", \"jet\",\n\t\t),\n\t)\n\n\tmustDo(t, c, \"HGETALL\", \"nosuch\",\n\t\tproto.Strings(),\n\t)\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c, \"HGETALL\", \"foo\",\n\t\tproto.Error(msgWrongType),\n\t)\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"HGETALL\", \"wim\",\n\t\t\tproto.StringMap(\n\t\t\t\t\"gijs\", \"lam\",\n\t\t\t\t\"kees\", \"bok\",\n\t\t\t\t\"teun\", \"vuur\",\n\t\t\t\t\"zus\", \"jet\",\n\t\t\t),\n\t\t)\n\t\tmustDo(t, c, \"HGETALL\", \"nosuch\",\n\t\t\tproto.StringMap(),\n\t\t)\n\t})\n}\n\nfunc TestHashKeys(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\tmustDo(t, c,\n\t\t\"HKEYS\", \"wim\",\n\t\tproto.Strings(\n\t\t\t\"gijs\",\n\t\t\t\"kees\",\n\t\t\t\"teun\",\n\t\t\t\"zus\",\n\t\t),\n\t)\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\tdirect, err := s.HKeys(\"wim\")\n\t\tok(t, err)\n\t\tequals(t, []string{\n\t\t\t\"gijs\",\n\t\t\t\"kees\",\n\t\t\t\"teun\",\n\t\t\t\"zus\",\n\t\t}, direct)\n\t\t_, err = s.HKeys(\"nosuch\")\n\t\tequals(t, err, ErrKeyNotFound)\n\t})\n\n\tmustDo(t, c, \"HKEYS\", \"nosuch\", proto.Strings())\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c, \"HKEYS\", \"foo\", proto.Error(msgWrongType))\n}\n\nfunc TestHashValues(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\tmustDo(t, c, \"HVALS\", \"wim\",\n\t\tproto.Strings(\n\t\t\t\"bok\",\n\t\t\t\"jet\",\n\t\t\t\"lam\",\n\t\t\t\"vuur\",\n\t\t),\n\t)\n\n\tmustDo(t, c, \"HVALS\", \"nosuch\", proto.Strings())\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c, \"HVALS\", \"foo\", proto.Error(msgWrongType))\n}\n\nfunc TestHashLen(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\tmustDo(t, c, \"HLEN\", \"wim\", proto.Int(4))\n\n\tmust0(t, c, \"HLEN\", \"nosuch\")\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c, \"HLEN\", \"foo\", proto.Error(msgWrongType))\n}\n\nfunc TestHashMget(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\tmustDo(t, c,\n\t\t\"HMGET\", \"wim\", \"zus\", \"nosuch\", \"kees\",\n\t\tproto.Array(\n\t\t\tproto.String(\"jet\"),\n\t\t\tproto.Nil,\n\t\t\tproto.String(\"bok\"),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"HMGET\", \"nosuch\", \"zus\", \"kees\",\n\t\tproto.Array(\n\t\t\tproto.Nil,\n\t\t\tproto.Nil,\n\t\t),\n\t)\n\n\t// Wrong key type\n\ts.Set(\"foo\", \"bar\")\n\tmustDo(t, c,\n\t\t\"HMGET\", \"foo\", \"bar\",\n\t\tproto.Error(msgWrongType),\n\t)\n}\n\nfunc TestHashIncrby(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// New key\n\tmust1(t, c, \"HINCRBY\", \"hash\", \"field\", \"1\")\n\n\t// Existing key\n\tmustDo(t, c,\n\t\t\"HINCRBY\", \"hash\", \"field\", \"100\",\n\t\tproto.Int(101),\n\t)\n\n\t// Minus works.\n\tmustDo(t, c,\n\t\t\"HINCRBY\", \"hash\", \"field\", \"-12\",\n\t\tproto.Int(101-12),\n\t)\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\ts.HIncr(\"hash\", \"field\", -3)\n\t\tequals(t, \"86\", s.HGet(\"hash\", \"field\"))\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\t// Wrong key type\n\t\ts.Set(\"str\", \"cake\")\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBY\", \"str\", \"case\", \"4\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBY\", \"str\", \"case\", \"foo\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBY\", \"str\",\n\t\t\tproto.Error(errWrongNumber(\"hincrby\")),\n\t\t)\n\t})\n}\n\nfunc TestHashIncrbyfloat(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.HSet(\"hash\", \"field\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"hash\", \"field\", \"400.12\",\n\t\t\tproto.String(\"412.12\"),\n\t\t)\n\t\tequals(t, \"412.12\", s.HGet(\"hash\", \"field\"))\n\t}\n\n\t// Existing key, not a number\n\t{\n\t\ts.HSet(\"hash\", \"field\", \"noint\")\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"hash\", \"field\", \"400\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"hash\", \"newfield\", \"40.33\",\n\t\t\tproto.String(\"40.33\"),\n\t\t)\n\t\tequals(t, \"40.33\", s.HGet(\"hash\", \"newfield\"))\n\t}\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\ts.HSet(\"hash\", \"field\", \"500.1\")\n\t\tf, err := s.HIncrfloat(\"hash\", \"field\", 12)\n\t\tok(t, err)\n\t\tequals(t, 512.1, f)\n\t\tequals(t, \"512.1\", s.HGet(\"hash\", \"field\"))\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Set(\"wrong\", \"type\")\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"wrong\", \"type\", \"400\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\",\n\t\t\tproto.Error(errWrongNumber(\"hincrbyfloat\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"wrong\",\n\t\t\tproto.Error(errWrongNumber(\"hincrbyfloat\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"wrong\", \"value\",\n\t\t\tproto.Error(errWrongNumber(\"hincrbyfloat\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"wrong\", \"value\", \"noint\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HINCRBYFLOAT\", \"foo\", \"bar\", \"12\", \"tomanye\",\n\t\t\tproto.Error(errWrongNumber(\"hincrbyfloat\")),\n\t\t)\n\t})\n}\n\nfunc TestHscan(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// We cheat with hscan. It always returns everything.\n\n\ts.HSet(\"h\", \"field1\", \"value1\")\n\ts.HSet(\"h\", \"field2\", \"value2\")\n\n\t// No problem\n\tmustDo(t, c,\n\t\t\"HSCAN\", \"h\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"field1\"),\n\t\t\t\tproto.String(\"value1\"),\n\t\t\t\tproto.String(\"field2\"),\n\t\t\t\tproto.String(\"value2\"),\n\t\t\t),\n\t\t),\n\t)\n\n\t// Invalid cursor\n\tmustDo(t, c,\n\t\t\"HSCAN\", \"h\", \"42\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\n\t// COUNT (ignored)\n\tmustDo(t, c,\n\t\t\"HSCAN\", \"h\", \"0\", \"COUNT\", \"200\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"field1\"),\n\t\t\t\tproto.String(\"value1\"),\n\t\t\t\tproto.String(\"field2\"),\n\t\t\t\tproto.String(\"value2\"),\n\t\t\t),\n\t\t),\n\t)\n\n\t// MATCH\n\ts.HSet(\"h\", \"aap\", \"a\")\n\ts.HSet(\"h\", \"noot\", \"b\")\n\ts.HSet(\"h\", \"mies\", \"m\")\n\tmustDo(t, c,\n\t\t\"HSCAN\", \"h\", \"0\", \"MATCH\", \"mi*\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"mies\"),\n\t\t\t\tproto.String(\"m\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"HSCAN\",\n\t\t\tproto.Error(errWrongNumber(\"hscan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HSCAN\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"hscan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HSCAN\", \"set\", \"noint\",\n\t\t\tproto.Error(\"ERR invalid cursor\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HSCAN\", \"set\", \"1\", \"MATCH\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HSCAN\", \"set\", \"1\", \"COUNT\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"HSCAN\", \"set\", \"1\", \"COUNT\", \"noint\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t})\n}\n\nfunc TestHstrlen(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ts.HSet(\"myhash\", \"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"HSTRLEN\", \"myhash\", \"foo\",\n\t\t\tproto.Int(3),\n\t\t)\n\t})\n\n\tt.Run(\"no such key\", func(t *testing.T) {\n\t\ts.HSet(\"myhash\", \"foo\", \"bar\")\n\t\tmust0(t, c,\n\t\t\t\"HSTRLEN\", \"myhash\", \"nosuch\",\n\t\t)\n\t})\n\n\tt.Run(\"no such hash\", func(t *testing.T) {\n\t\ts.HSet(\"myhash\", \"foo\", \"bar\")\n\t\tmust0(t, c,\n\t\t\t\"HSTRLEN\", \"yourhash\", \"foo\",\n\t\t)\n\t})\n\n\tt.Run(\"utf8\", func(t *testing.T) {\n\t\ts.HSet(\"myhash\", \"snow\", \"\")\n\t\tmustDo(t, c,\n\t\t\t\"HSTRLEN\", \"myhash\", \"snow\",\n\t\t\tproto.Int(9),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"HSTRLEN\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'hstrlen' command\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"HSTRLEN\", \"bar\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'hstrlen' command\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"HSTRLEN\", \"bar\", \"baz\", \"bak\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'hstrlen' command\"),\n\t\t)\n\n\t\ts.Set(\"notahash\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"HSTRLEN\", \"notahash\", \"bar\",\n\t\t\tproto.Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"),\n\t\t)\n\t})\n}\n\nfunc TestHashRandField(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.HSet(\"wim\", \"zus\", \"jet\")\n\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\ts.HSet(\"wim\", \"gijs\", \"lam\")\n\ts.HSet(\"wim\", \"kees\", \"bok\")\n\n\t{\n\t\tv, err := c.Do(\"HRANDFIELD\", \"wim\", \"1\")\n\t\tok(t, err)\n\t\tassert(t, v == proto.Strings(\"zus\") || v == proto.Strings(\"teun\") || v == proto.Strings(\"gijs\") || v == proto.Strings(\"kees\"), \"HRANDFIELD looks sane\")\n\t}\n\n\t{\n\t\tv, err := c.Do(\"HRANDFIELD\", \"wim\", \"1\", \"WITHVALUES\")\n\t\tok(t, err)\n\t\tst, err := proto.Parse(v)\n\t\tok(t, err)\n\t\tli := st.([]interface{})\n\t\tkeys := make([]string, len(li))\n\t\tfor i, v := range li {\n\t\t\tkeys[i] = v.(string)\n\t\t}\n\n\t\tassert(t, len(keys) == 2, \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[0] == \"zus\" || keys[0] == \"teun\" || keys[0] == \"gijs\" || keys[0] == \"kees\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[1] == \"jet\" || keys[1] == \"vuur\" || keys[1] == \"lam\" || keys[1] == \"bok\", \"HRANDFIELD looks sane\")\n\t}\n\n\t{\n\t\tv, err := c.Do(\"HRANDFIELD\", \"wim\", \"4\")\n\t\tok(t, err)\n\t\tst, err := proto.Parse(v)\n\t\tok(t, err)\n\t\tli := st.([]interface{})\n\t\tkeys := make([]string, len(li))\n\t\tfor i, v := range li {\n\t\t\tkeys[i] = v.(string)\n\t\t}\n\t\tsort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })\n\t\tassert(t, len(keys) == 4, \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[0] == \"gijs\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[1] == \"kees\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[2] == \"teun\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[3] == \"zus\", \"HRANDFIELD looks sane\")\n\t}\n\n\t{\n\t\tv, err := c.Do(\"HRANDFIELD\", \"wim\", \"5\")\n\t\tok(t, err)\n\t\tst, err := proto.Parse(v)\n\t\tok(t, err)\n\t\tli := st.([]interface{})\n\t\tkeys := make([]string, len(li))\n\t\tfor i, v := range li {\n\t\t\tkeys[i] = v.(string)\n\t\t}\n\t\tsort.Slice(keys, func(i, j int) bool { return keys[i] < keys[j] })\n\t\tassert(t, len(keys) == 4, \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[0] == \"gijs\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[1] == \"kees\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[2] == \"teun\", \"HRANDFIELD looks sane\")\n\t\tassert(t, keys[3] == \"zus\", \"HRANDFIELD looks sane\")\n\t}\n\n\t{\n\t\tv, err := c.Do(\"HRANDFIELD\", \"wim\", \"-5\")\n\t\tok(t, err)\n\t\tst, err := proto.Parse(v)\n\t\tok(t, err)\n\t\tli := st.([]interface{})\n\t\tkeys := make([]string, len(li))\n\t\tfor i, v := range li {\n\t\t\tkeys[i] = v.(string)\n\t\t}\n\n\t\tkeyMap := make(map[string]bool)\n\t\tfor _, key := range keys {\n\t\t\tkeyMap[key] = true\n\t\t}\n\t\tassert(t, len(keys) == 5, \"HRANDFIELD looks sane\")\n\t\tassert(t, len(keyMap) <= 4, \"HRANDFIELD looks sane\")\n\t}\n\n\t// Wrong key type\n\tmustDo(t, c,\n\t\t\"HRANDFIELD\", \"wim\", \"zus\",\n\t\tproto.Error(msgInvalidInt),\n\t)\n}\n"
        },
        {
          "name": "cmd_hll.go",
          "type": "blob",
          "size": 1.673828125,
          "content": "package miniredis\n\nimport \"github.com/alicebob/miniredis/v2/server\"\n\n// commandsHll handles all hll related operations.\nfunc commandsHll(m *Miniredis) {\n\tm.srv.Register(\"PFADD\", m.cmdPfadd)\n\tm.srv.Register(\"PFCOUNT\", m.cmdPfcount)\n\tm.srv.Register(\"PFMERGE\", m.cmdPfmerge)\n}\n\n// PFADD\nfunc (m *Miniredis) cmdPfadd(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, items := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(key) && db.t(key) != \"hll\" {\n\t\t\tc.WriteError(ErrNotValidHllValue.Error())\n\t\t\treturn\n\t\t}\n\n\t\taltered := db.hllAdd(key, items...)\n\t\tc.WriteInt(altered)\n\t})\n}\n\n// PFCOUNT\nfunc (m *Miniredis) cmdPfcount(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkeys := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tcount, err := db.hllCount(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(count)\n\t})\n}\n\n// PFMERGE\nfunc (m *Miniredis) cmdPfmerge(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkeys := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif err := db.hllMerge(keys); err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.WriteOK()\n\t})\n}\n"
        },
        {
          "name": "cmd_hll_test.go",
          "type": "blob",
          "size": 3.962890625,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test PFADD\nfunc TestPfadd(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"PFADD\", \"h\", \"aap\", \"noot\", \"mies\",\n\t\tproto.Int(1),\n\t)\n\n\tmustDo(t, c,\n\t\t\"PFADD\", \"h\", \"aap\", // already exists in hll => returns 0\n\t\tproto.Int(0),\n\t)\n\n\tmustDo(t, c,\n\t\t\"TYPE\", \"h\",\n\t\tproto.Inline(\"hll\"),\n\t)\n\n\tt.Run(\"direct usage\", func(t *testing.T) {\n\t\tadded, err := s.SetAdd(\"s1\", \"aap\")\n\t\tok(t, err)\n\t\tequals(t, 1, added)\n\n\t\tmembers, err := s.Members(\"s1\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\"}, members)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"PFADD\", \"str\", \"hi\",\n\t\t\tproto.Error(msgNotValidHllValue),\n\t\t)\n\t\t// Wrong argument counts\n\t\tmustDo(t, c,\n\t\t\t\"PFADD\",\n\t\t\tproto.Error(errWrongNumber(\"pfadd\")),\n\t\t)\n\t})\n}\n\n// Test PFCOUNT\nfunc TestPfcount(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Add 100 unique random values\n\tfor i := 0; i < 100; i++ {\n\t\tmustDo(t, c,\n\t\t\t\"PFADD\", \"h1\", randomStr(10),\n\t\t\tproto.Int(1), // hll changes each time\n\t\t)\n\t}\n\n\t// Add 1 more unique value\n\tspecificValue := randomStr(10)\n\tmustDo(t, c,\n\t\t\"PFADD\", \"h1\", specificValue,\n\t\tproto.Int(1), // hll changes because of new element\n\t)\n\tfor i := 0; i < 50; i++ {\n\t\tmustDo(t, c,\n\t\t\t\"PFADD\", \"h1\", specificValue,\n\t\t\tproto.Int(0), // hll doesn't change because this element has already been added before\n\t\t)\n\t}\n\n\tmustDo(t, c,\n\t\t\"PFCOUNT\", \"h1\",\n\t\tproto.Int(101),\n\t)\n\n\t// Create a new hll\n\tmustDo(t, c,\n\t\t\"PFADD\", \"h2\", randomStr(10), randomStr(10), randomStr(10),\n\t\tproto.Int(1),\n\t)\n\n\tmustDo(t, c,\n\t\t\"PFCOUNT\", \"h2\",\n\t\tproto.Int(3),\n\t)\n\n\t// Several hlls are involved - a sum of all the counts is returned\n\tmustDo(t, c,\n\t\t\"PFCOUNT\",\n\t\t\"h1\", // has 101 unique values\n\t\t\"h2\", // has 3 unique values\n\t\t\"h3\", // empty key\n\t\tproto.Int(104),\n\t)\n\n\t// A nonexisting key\n\tmustDo(t, c,\n\t\t\"PFCOUNT\", \"h9\",\n\t\tproto.Int(0),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"PFCOUNT\",\n\t\t\tproto.Error(errWrongNumber(\"pfcount\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PFCOUNT\", \"str\",\n\t\t\tproto.Error(msgNotValidHllValue),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PFCOUNT\", \"h1\", \"str\",\n\t\t\tproto.Error(msgNotValidHllValue),\n\t\t)\n\t})\n}\n\n// Test PFMERGE\nfunc TestPfmerge(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Add 100 unique random values to h1 and 50 of these 100 to h2\n\tfor i := 0; i < 100; i++ {\n\t\tvalue := randomStr(10)\n\t\tmustDo(t, c,\n\t\t\t\"PFADD\", \"h1\", value,\n\t\t\tproto.Int(1), // hll changes each time\n\t\t)\n\t\tif i%2 == 0 {\n\t\t\tmustDo(t, c,\n\t\t\t\t\"PFADD\", \"h2\", value,\n\t\t\t\tproto.Int(1), // hll changes each time\n\t\t\t)\n\t\t}\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\tmustDo(t, c,\n\t\t\t\"PFADD\", \"h3\", randomStr(10),\n\t\t\tproto.Int(1), // hll changes each time\n\t\t)\n\t}\n\n\t// Merge non-intersecting hlls\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"PFMERGE\",\n\t\t\t\"res1\",\n\t\t\t\"h1\", // count 100\n\t\t\t\"h3\", // count 100\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PFCOUNT\", \"res1\",\n\t\t\tproto.Int(200),\n\t\t)\n\t}\n\n\t// Merge intersecting hlls\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"PFMERGE\",\n\t\t\t\"res2\",\n\t\t\t\"h1\", // count 100\n\t\t\t\"h2\", // count 50 (all 50 are presented in h1)\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PFCOUNT\", \"res2\",\n\t\t\tproto.Int(100),\n\t\t)\n\t}\n\n\t// Merge all hlls\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"PFMERGE\",\n\t\t\t\"res3\",\n\t\t\t\"h1\", // count 100\n\t\t\t\"h2\", // count 50 (all 50 are presented in h1)\n\t\t\t\"h3\", // count 100\n\t\t\t\"h4\", // empty key\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PFCOUNT\", \"res3\",\n\t\t\tproto.Int(200),\n\t\t)\n\t}\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\tcommonElem := randomStr(10)\n\t\ts.PfAdd(\"h5\", commonElem, randomStr(10), randomStr(10), randomStr(10), randomStr(10))\n\t\ts.PfAdd(\"h6\", commonElem, randomStr(10), randomStr(10))\n\n\t\tsum, err := s.PfCount(\"h5\", \"h6\", \"h7\") // h7 is empty\n\t\tok(t, err)\n\t\tequals(t, sum, 8)\n\n\t\ts.PfMerge(\"h8\", \"h5\", \"h6\")\n\t\tsum, err = s.PfCount(\"h8\")\n\t\tok(t, err)\n\t\tequals(t, sum, 7) // common elem is counted once\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"PFMERGE\",\n\t\t\tproto.Error(errWrongNumber(\"pfmerge\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PFMERGE\", \"h10\", \"str\",\n\t\t\tproto.Error(msgNotValidHllValue),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_info.go",
          "type": "blob",
          "size": 0.771484375,
          "content": "package miniredis\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// Command 'INFO' from https://redis.io/commands/info/\nfunc (m *Miniredis) cmdInfo(c *server.Peer, cmd string, args []string) {\n\tif !m.isValidCMD(c, cmd) {\n\t\treturn\n\t}\n\n\tif len(args) > 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tconst (\n\t\t\tclientsSectionName    = \"clients\"\n\t\t\tclientsSectionContent = \"# Clients\\nconnected_clients:%d\\r\\n\"\n\t\t)\n\n\t\tvar result string\n\n\t\tfor _, key := range args {\n\t\t\tif key != clientsSectionName {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(fmt.Sprintf(\"section (%s) is not supported\", key))\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tresult = fmt.Sprintf(clientsSectionContent, m.Server().ClientsLen())\n\n\t\tc.WriteBulk(result)\n\t})\n}\n"
        },
        {
          "name": "cmd_info_test.go",
          "type": "blob",
          "size": 0.9921875,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestMiniredis_cmdInfo(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"Invalid section name\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"INFO\", \"invalid_or_unsupported_section_name\",\n\t\t\tproto.Error(\"section (invalid_or_unsupported_section_name) is not supported\"),\n\t\t)\n\t})\n\n\tt.Run(\"No section name in args\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"INFO\",\n\t\t\tproto.String(\"# Clients\\nconnected_clients:1\\r\\n\"),\n\t\t)\n\t})\n\n\tt.Run(\"Success\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"INFO\", \"clients\",\n\t\t\tproto.String(\"# Clients\\nconnected_clients:1\\r\\n\"),\n\t\t)\n\n\t\tc2, err := proto.Dial(s.Addr())\n\t\tok(t, err)\n\t\tmustDo(t, c2,\n\t\t\t\"INFO\", \"clients\",\n\t\t\tproto.String(\"# Clients\\nconnected_clients:2\\r\\n\"),\n\t\t)\n\t\tc2.Close()\n\n\t\ttime.Sleep(10 * time.Millisecond)\n\n\t\tc3, err := proto.Dial(s.Addr())\n\t\tok(t, err)\n\t\tdefer c3.Close()\n\t\tmustDo(t, c3,\n\t\t\t\"INFO\", \"clients\",\n\t\t\tproto.String(\"# Clients\\nconnected_clients:2\\r\\n\"),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_list.go",
          "type": "blob",
          "size": 19.2666015625,
          "content": "// Commands from https://redis.io/commands#list\n\npackage miniredis\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\ntype leftright int\n\nconst (\n\tleft leftright = iota\n\tright\n)\n\n// commandsList handles list commands (mostly L*)\nfunc commandsList(m *Miniredis) {\n\tm.srv.Register(\"BLPOP\", m.cmdBlpop)\n\tm.srv.Register(\"BRPOP\", m.cmdBrpop)\n\tm.srv.Register(\"BRPOPLPUSH\", m.cmdBrpoplpush)\n\tm.srv.Register(\"LINDEX\", m.cmdLindex)\n\tm.srv.Register(\"LPOS\", m.cmdLpos)\n\tm.srv.Register(\"LINSERT\", m.cmdLinsert)\n\tm.srv.Register(\"LLEN\", m.cmdLlen)\n\tm.srv.Register(\"LPOP\", m.cmdLpop)\n\tm.srv.Register(\"LPUSH\", m.cmdLpush)\n\tm.srv.Register(\"LPUSHX\", m.cmdLpushx)\n\tm.srv.Register(\"LRANGE\", m.cmdLrange)\n\tm.srv.Register(\"LREM\", m.cmdLrem)\n\tm.srv.Register(\"LSET\", m.cmdLset)\n\tm.srv.Register(\"LTRIM\", m.cmdLtrim)\n\tm.srv.Register(\"RPOP\", m.cmdRpop)\n\tm.srv.Register(\"RPOPLPUSH\", m.cmdRpoplpush)\n\tm.srv.Register(\"RPUSH\", m.cmdRpush)\n\tm.srv.Register(\"RPUSHX\", m.cmdRpushx)\n\tm.srv.Register(\"LMOVE\", m.cmdLmove)\n\tm.srv.Register(\"BLMOVE\", m.cmdBlmove)\n}\n\n// BLPOP\nfunc (m *Miniredis) cmdBlpop(c *server.Peer, cmd string, args []string) {\n\tm.cmdBXpop(c, cmd, args, left)\n}\n\n// BRPOP\nfunc (m *Miniredis) cmdBrpop(c *server.Peer, cmd string, args []string) {\n\tm.cmdBXpop(c, cmd, args, right)\n}\n\nfunc (m *Miniredis) cmdBXpop(c *server.Peer, cmd string, args []string, lr leftright) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkeys    []string\n\t\ttimeout time.Duration\n\t}\n\n\tif ok := optDuration(c, args[len(args)-1], &opts.timeout); !ok {\n\t\treturn\n\t}\n\topts.keys = args[:len(args)-1]\n\n\tblocking(\n\t\tm,\n\t\tc,\n\t\topts.timeout,\n\t\tfunc(c *server.Peer, ctx *connCtx) bool {\n\t\t\tdb := m.db(ctx.selectedDB)\n\t\t\tfor _, key := range opts.keys {\n\t\t\t\tif !db.exists(key) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif db.t(key) != \"list\" {\n\t\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\t\treturn true\n\t\t\t\t}\n\n\t\t\t\tif len(db.listKeys[key]) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tc.WriteLen(2)\n\t\t\t\tc.WriteBulk(key)\n\t\t\t\tvar v string\n\t\t\t\tswitch lr {\n\t\t\t\tcase left:\n\t\t\t\t\tv = db.listLpop(key)\n\t\t\t\tcase right:\n\t\t\t\t\tv = db.listPop(key)\n\t\t\t\t}\n\t\t\t\tc.WriteBulk(v)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t\tfunc(c *server.Peer) {\n\t\t\t// timeout\n\t\t\tc.WriteLen(-1)\n\t\t},\n\t)\n}\n\n// LINDEX\nfunc (m *Miniredis) cmdLindex(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, offsets := args[0], args[1]\n\n\toffset, err := strconv.Atoi(offsets)\n\tif err != nil || offsets == \"-0\" {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\t// No such key\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif t != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tl := db.listKeys[key]\n\t\tif offset < 0 {\n\t\t\toffset = len(l) + offset\n\t\t}\n\t\tif offset < 0 || offset > len(l)-1 {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tc.WriteBulk(l[offset])\n\t})\n}\n\n// LPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]\nfunc (m *Miniredis) cmdLpos(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tif len(args) == 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\t// Extract options from arguments if present.\n\t//\n\t// Redis allows duplicate options and uses the last specified.\n\t// `LPOS key term RANK 1 RANK 2` is effectively the same as\n\t// `LPOS key term RANK 2`\n\tif len(args)%2 == 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\trank, count := 1, 1 // Default values\n\tvar maxlen int      // Default value is the list length (see below)\n\tvar countSpecified, maxlenSpecified bool\n\tif len(args) > 2 {\n\t\tfor i := 2; i < len(args); i++ {\n\t\t\tif i%2 == 0 {\n\t\t\t\tval := args[i+1]\n\t\t\t\tvar err error\n\t\t\t\tswitch strings.ToLower(args[i]) {\n\t\t\t\tcase \"rank\":\n\t\t\t\t\tif rank, err = strconv.Atoi(val); err != nil {\n\t\t\t\t\t\tsetDirty(c)\n\t\t\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif rank == 0 {\n\t\t\t\t\t\tsetDirty(c)\n\t\t\t\t\t\tc.WriteError(msgRankIsZero)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\tcase \"count\":\n\t\t\t\t\tcountSpecified = true\n\t\t\t\t\tif count, err = strconv.Atoi(val); err != nil || count < 0 {\n\t\t\t\t\t\tsetDirty(c)\n\t\t\t\t\t\tc.WriteError(msgCountIsNegative)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\tcase \"maxlen\":\n\t\t\t\t\tmaxlenSpecified = true\n\t\t\t\t\tif maxlen, err = strconv.Atoi(val); err != nil || maxlen < 0 {\n\t\t\t\t\t\tsetDirty(c)\n\t\t\t\t\t\tc.WriteError(msgMaxLengthIsNegative)\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tsetDirty(c)\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tkey, element := args[0], args[1]\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\t// No such key\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif t != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tl := db.listKeys[key]\n\n\t\t// RANK cannot be zero (see above).\n\t\t// If RANK is positive search forward (left to right).\n\t\t// If RANK is negative search backward (right to left).\n\t\t// Iterator returns true to continue iterating.\n\t\titerate := func(iterator func(i int, e string) bool) {\n\t\t\tcomparisons := len(l)\n\t\t\t// Only use max length if specified, not zero, and less than total length.\n\t\t\t// When max length is specified, but is zero, this means \"unlimited\".\n\t\t\tif maxlenSpecified && maxlen != 0 && maxlen < len(l) {\n\t\t\t\tcomparisons = maxlen\n\t\t\t}\n\t\t\tif rank > 0 {\n\t\t\t\tfor i := 0; i < comparisons; i++ {\n\t\t\t\t\tif resume := iterator(i, l[i]); !resume {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if rank < 0 {\n\t\t\t\tstart := len(l) - 1\n\t\t\t\tend := len(l) - comparisons\n\t\t\t\tfor i := start; i >= end; i-- {\n\t\t\t\t\tif resume := iterator(i, l[i]); !resume {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar currentRank, currentCount int\n\t\tvals := make([]int, 0, count)\n\t\titerate(func(i int, e string) bool {\n\t\t\tif e == element {\n\t\t\t\tcurrentRank++\n\t\t\t\t// Only collect values only after surpassing the absolute value of rank.\n\t\t\t\tif rank > 0 && currentRank < rank {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif rank < 0 && currentRank < -rank {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tvals = append(vals, i)\n\t\t\t\tcurrentCount++\n\t\t\t\tif currentCount == count {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\tif !countSpecified && len(vals) == 0 {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif !countSpecified && len(vals) == 1 {\n\t\t\tc.WriteInt(vals[0])\n\t\t\treturn\n\t\t}\n\t\tc.WriteLen(len(vals))\n\t\tfor _, val := range vals {\n\t\t\tc.WriteInt(val)\n\t\t}\n\t})\n}\n\n// LINSERT\nfunc (m *Miniredis) cmdLinsert(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 4 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\twhere := 0\n\tswitch strings.ToLower(args[1]) {\n\tcase \"before\":\n\t\twhere = -1\n\tcase \"after\":\n\t\twhere = +1\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tpivot := args[2]\n\tvalue := args[3]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\t// No such key\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tl := db.listKeys[key]\n\t\tfor i, el := range l {\n\t\t\tif el != pivot {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif where < 0 {\n\t\t\t\tl = append(l[:i], append(listKey{value}, l[i:]...)...)\n\t\t\t} else {\n\t\t\t\tif i == len(l)-1 {\n\t\t\t\t\tl = append(l, value)\n\t\t\t\t} else {\n\t\t\t\t\tl = append(l[:i+1], append(listKey{value}, l[i+1:]...)...)\n\t\t\t\t}\n\t\t\t}\n\t\t\tdb.listKeys[key] = l\n\t\t\tdb.incr(key)\n\t\t\tc.WriteInt(len(l))\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(-1)\n\t})\n}\n\n// LLEN\nfunc (m *Miniredis) cmdLlen(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[key]\n\t\tif !ok {\n\t\t\t// No such key. That's zero length.\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif t != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(len(db.listKeys[key]))\n\t})\n}\n\n// LPOP\nfunc (m *Miniredis) cmdLpop(c *server.Peer, cmd string, args []string) {\n\tm.cmdXpop(c, cmd, args, left)\n}\n\n// RPOP\nfunc (m *Miniredis) cmdRpop(c *server.Peer, cmd string, args []string) {\n\tm.cmdXpop(c, cmd, args, right)\n}\n\nfunc (m *Miniredis) cmdXpop(c *server.Peer, cmd string, args []string, lr leftright) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey       string\n\t\twithCount bool\n\t\tcount     int\n\t}\n\n\topts.key, args = args[0], args[1:]\n\tif len(args) > 0 {\n\t\tif ok := optInt(c, args[0], &opts.count); !ok {\n\t\t\treturn\n\t\t}\n\t\tif opts.count < 0 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgOutOfRange)\n\t\t\treturn\n\t\t}\n\t\topts.withCount = true\n\t\targs = args[1:]\n\t}\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\t// non-existing key is fine\n\t\t\tif opts.withCount && !c.Resp3 {\n\t\t\t\t// zero-length list in this specific case. Looks like a redis bug to me.\n\t\t\t\tc.WriteLen(-1)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif db.t(opts.key) != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tif opts.withCount {\n\t\t\tvar popped []string\n\t\t\tfor opts.count > 0 && len(db.listKeys[opts.key]) > 0 {\n\t\t\t\tswitch lr {\n\t\t\t\tcase left:\n\t\t\t\t\tpopped = append(popped, db.listLpop(opts.key))\n\t\t\t\tcase right:\n\t\t\t\t\tpopped = append(popped, db.listPop(opts.key))\n\t\t\t\t}\n\t\t\t\topts.count -= 1\n\t\t\t}\n\t\t\tc.WriteStrings(popped)\n\t\t\treturn\n\t\t}\n\n\t\tvar elem string\n\t\tswitch lr {\n\t\tcase left:\n\t\t\telem = db.listLpop(opts.key)\n\t\tcase right:\n\t\t\telem = db.listPop(opts.key)\n\t\t}\n\t\tc.WriteBulk(elem)\n\t})\n}\n\n// LPUSH\nfunc (m *Miniredis) cmdLpush(c *server.Peer, cmd string, args []string) {\n\tm.cmdXpush(c, cmd, args, left)\n}\n\n// RPUSH\nfunc (m *Miniredis) cmdRpush(c *server.Peer, cmd string, args []string) {\n\tm.cmdXpush(c, cmd, args, right)\n}\n\nfunc (m *Miniredis) cmdXpush(c *server.Peer, cmd string, args []string, lr leftright) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(key) && db.t(key) != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tvar newLen int\n\t\tfor _, value := range args {\n\t\t\tswitch lr {\n\t\t\tcase left:\n\t\t\t\tnewLen = db.listLpush(key, value)\n\t\t\tcase right:\n\t\t\t\tnewLen = db.listPush(key, value)\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(newLen)\n\t})\n}\n\n// LPUSHX\nfunc (m *Miniredis) cmdLpushx(c *server.Peer, cmd string, args []string) {\n\tm.cmdXpushx(c, cmd, args, left)\n}\n\n// RPUSHX\nfunc (m *Miniredis) cmdRpushx(c *server.Peer, cmd string, args []string) {\n\tm.cmdXpushx(c, cmd, args, right)\n}\n\nfunc (m *Miniredis) cmdXpushx(c *server.Peer, cmd string, args []string, lr leftright) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif db.t(key) != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tvar newLen int\n\t\tfor _, value := range args {\n\t\t\tswitch lr {\n\t\t\tcase left:\n\t\t\t\tnewLen = db.listLpush(key, value)\n\t\t\tcase right:\n\t\t\t\tnewLen = db.listPush(key, value)\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(newLen)\n\t})\n}\n\n// LRANGE\nfunc (m *Miniredis) cmdLrange(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey   string\n\t\tstart int\n\t\tend   int\n\t}{\n\t\tkey: args[0],\n\t}\n\tif ok := optInt(c, args[1], &opts.start); !ok {\n\t\treturn\n\t}\n\tif ok := optInt(c, args[2], &opts.end); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tl := db.listKeys[opts.key]\n\t\tif len(l) == 0 {\n\t\t\tc.WriteLen(0)\n\t\t\treturn\n\t\t}\n\n\t\trs, re := redisRange(len(l), opts.start, opts.end, false)\n\t\tc.WriteLen(re - rs)\n\t\tfor _, el := range l[rs:re] {\n\t\t\tc.WriteBulk(el)\n\t\t}\n\t})\n}\n\n// LREM\nfunc (m *Miniredis) cmdLrem(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tcount int\n\t\tvalue string\n\t}\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.count); !ok {\n\t\treturn\n\t}\n\topts.value = args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif db.t(opts.key) != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tl := db.listKeys[opts.key]\n\t\tif opts.count < 0 {\n\t\t\treverseSlice(l)\n\t\t}\n\t\tdeleted := 0\n\t\tnewL := []string{}\n\t\ttoDelete := len(l)\n\t\tif opts.count < 0 {\n\t\t\ttoDelete = -opts.count\n\t\t}\n\t\tif opts.count > 0 {\n\t\t\ttoDelete = opts.count\n\t\t}\n\t\tfor _, el := range l {\n\t\t\tif el == opts.value {\n\t\t\t\tif toDelete > 0 {\n\t\t\t\t\tdeleted++\n\t\t\t\t\ttoDelete--\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewL = append(newL, el)\n\t\t}\n\t\tif opts.count < 0 {\n\t\t\treverseSlice(newL)\n\t\t}\n\t\tif len(newL) == 0 {\n\t\t\tdb.del(opts.key, true)\n\t\t} else {\n\t\t\tdb.listKeys[opts.key] = newL\n\t\t\tdb.incr(opts.key)\n\t\t}\n\n\t\tc.WriteInt(deleted)\n\t})\n}\n\n// LSET\nfunc (m *Miniredis) cmdLset(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tindex int\n\t\tvalue string\n\t}\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.index); !ok {\n\t\treturn\n\t}\n\topts.value = args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteError(msgKeyNotFound)\n\t\t\treturn\n\t\t}\n\t\tif db.t(opts.key) != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tl := db.listKeys[opts.key]\n\t\tindex := opts.index\n\t\tif index < 0 {\n\t\t\tindex = len(l) + index\n\t\t}\n\t\tif index < 0 || index > len(l)-1 {\n\t\t\tc.WriteError(msgOutOfRange)\n\t\t\treturn\n\t\t}\n\t\tl[index] = opts.value\n\t\tdb.incr(opts.key)\n\n\t\tc.WriteOK()\n\t})\n}\n\n// LTRIM\nfunc (m *Miniredis) cmdLtrim(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tstart int\n\t\tend   int\n\t}\n\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.start); !ok {\n\t\treturn\n\t}\n\tif ok := optInt(c, args[2], &opts.end); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.keys[opts.key]\n\t\tif !ok {\n\t\t\tc.WriteOK()\n\t\t\treturn\n\t\t}\n\t\tif t != \"list\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tl := db.listKeys[opts.key]\n\t\trs, re := redisRange(len(l), opts.start, opts.end, false)\n\t\tl = l[rs:re]\n\t\tif len(l) == 0 {\n\t\t\tdb.del(opts.key, true)\n\t\t} else {\n\t\t\tdb.listKeys[opts.key] = l\n\t\t\tdb.incr(opts.key)\n\t\t}\n\t\tc.WriteOK()\n\t})\n}\n\n// RPOPLPUSH\nfunc (m *Miniredis) cmdRpoplpush(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tsrc, dst := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(src) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif db.t(src) != \"list\" || (db.exists(dst) && db.t(dst) != \"list\") {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\telem := db.listPop(src)\n\t\tdb.listLpush(dst, elem)\n\t\tc.WriteBulk(elem)\n\t})\n}\n\n// BRPOPLPUSH\nfunc (m *Miniredis) cmdBrpoplpush(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tsrc     string\n\t\tdst     string\n\t\ttimeout time.Duration\n\t}\n\topts.src = args[0]\n\topts.dst = args[1]\n\tif ok := optDuration(c, args[2], &opts.timeout); !ok {\n\t\treturn\n\t}\n\n\tblocking(\n\t\tm,\n\t\tc,\n\t\topts.timeout,\n\t\tfunc(c *server.Peer, ctx *connCtx) bool {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\tif !db.exists(opts.src) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif db.t(opts.src) != \"list\" || (db.exists(opts.dst) && db.t(opts.dst) != \"list\") {\n\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif len(db.listKeys[opts.src]) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\telem := db.listPop(opts.src)\n\t\t\tdb.listLpush(opts.dst, elem)\n\t\t\tc.WriteBulk(elem)\n\t\t\treturn true\n\t\t},\n\t\tfunc(c *server.Peer) {\n\t\t\t// timeout\n\t\t\tc.WriteLen(-1)\n\t\t},\n\t)\n}\n\n// LMOVE\nfunc (m *Miniredis) cmdLmove(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 4 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tsrc    string\n\t\tdst    string\n\t\tsrcDir string\n\t\tdstDir string\n\t}{\n\t\tsrc:    args[0],\n\t\tdst:    args[1],\n\t\tsrcDir: strings.ToLower(args[2]),\n\t\tdstDir: strings.ToLower(args[3]),\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.src) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif db.t(opts.src) != \"list\" || (db.exists(opts.dst) && db.t(opts.dst) != \"list\") {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tvar elem string\n\t\tswitch opts.srcDir {\n\t\tcase \"left\":\n\t\t\telem = db.listLpop(opts.src)\n\t\tcase \"right\":\n\t\t\telem = db.listPop(opts.src)\n\t\tdefault:\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\n\t\tswitch opts.dstDir {\n\t\tcase \"left\":\n\t\t\tdb.listLpush(opts.dst, elem)\n\t\tcase \"right\":\n\t\t\tdb.listPush(opts.dst, elem)\n\t\tdefault:\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t\tc.WriteBulk(elem)\n\t})\n}\n\n// BLMOVE\nfunc (m *Miniredis) cmdBlmove(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 5 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tsrc     string\n\t\tdst     string\n\t\tsrcDir  string\n\t\tdstDir  string\n\t\ttimeout time.Duration\n\t}{\n\t\tsrc:    args[0],\n\t\tdst:    args[1],\n\t\tsrcDir: strings.ToLower(args[2]),\n\t\tdstDir: strings.ToLower(args[3]),\n\t}\n\tif ok := optDuration(c, args[len(args)-1], &opts.timeout); !ok {\n\t\treturn\n\t}\n\n\tblocking(\n\t\tm,\n\t\tc,\n\t\topts.timeout,\n\t\tfunc(c *server.Peer, ctx *connCtx) bool {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\tif !db.exists(opts.src) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif db.t(opts.src) != \"list\" || (db.exists(opts.dst) && db.t(opts.dst) != \"list\") {\n\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tvar elem string\n\t\t\tswitch opts.srcDir {\n\t\t\tcase \"left\":\n\t\t\t\telem = db.listLpop(opts.src)\n\t\t\tcase \"right\":\n\t\t\t\telem = db.listPop(opts.src)\n\t\t\tdefault:\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tswitch opts.dstDir {\n\t\t\tcase \"left\":\n\t\t\t\tdb.listLpush(opts.dst, elem)\n\t\t\tcase \"right\":\n\t\t\t\tdb.listPush(opts.dst, elem)\n\t\t\tdefault:\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tc.WriteBulk(elem)\n\t\t\treturn true\n\t\t},\n\t\tfunc(c *server.Peer) {\n\t\t\t// timeout\n\t\t\tc.WriteLen(-1)\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "cmd_list_test.go",
          "type": "blob",
          "size": 33.95703125,
          "content": "package miniredis\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// execute command in a go routine. Used to test blocking commands.\nfunc goStrings(t *testing.T, s *Miniredis, args ...string) <-chan string {\n\tc, err := proto.Dial(s.Addr())\n\tok(t, err)\n\n\tgot := make(chan string, 1)\n\tgo func() {\n\t\tdefer c.Close()\n\t\tdefer close(got)\n\t\tres, err := c.Do(args...)\n\t\tif err != nil {\n\t\t\tt.Error(err.Error())\n\t\t\treturn\n\t\t}\n\t\tgot <- res\n\t}()\n\treturn got\n}\n\nfunc TestLpush(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\", \"l\", \"aap\", \"noot\", \"mies\",\n\t\t\tproto.Int(3), // new length.\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"0\", \"0\",\n\t\t\tproto.Strings(\"mies\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"aap\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\", \"l\", \"aap2\", \"noot2\", \"mies2\",\n\t\t\tproto.Int(6),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"0\", \"0\",\n\t\t\tproto.Strings(\"mies2\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"aap\"),\n\t\t)\n\t})\n\n\tt.Run(\"direct\", func(t *testing.T) {\n\t\tl, err := s.Lpush(\"l2\", \"a\")\n\t\tok(t, err)\n\t\tequals(t, 1, l)\n\t\tl, err = s.Lpush(\"l2\", \"b\")\n\t\tok(t, err)\n\t\tequals(t, 2, l)\n\t\tlist, err := s.List(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"b\", \"a\"}, list)\n\n\t\tel, err := s.Lpop(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, \"b\", el)\n\t\tel, err = s.Lpop(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, \"a\", el)\n\t\t// Key is removed on pop-empty.\n\t\tequals(t, false, s.Exists(\"l2\"))\n\t})\n\n\tt.Run(\"direct, wakeup\", func(t *testing.T) {\n\t\tgo func() {\n\t\t\ttime.Sleep(30 * time.Millisecond)\n\t\t\tl, err := s.Lpush(\"q1\", \"a\")\n\t\t\tok(t, err)\n\t\t\tequals(t, 1, l)\n\t\t}()\n\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"q1\", \"q2\", \"1\",\n\t\t\tproto.String(\"a\"),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'lpush' command\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\", \"l\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'lpush' command\"),\n\t\t)\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\", \"str\", \"noot\", \"mies\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestLpushx(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmust0(t, c,\n\t\t\t\"LPUSHX\", \"l\", \"aap\",\n\t\t)\n\t\tequals(t, false, s.Exists(\"l\"))\n\n\t\t// Create the list with a normal LPUSH\n\t\tmust1(t, c,\n\t\t\t\"LPUSH\", \"l\", \"noot\",\n\t\t)\n\t\tequals(t, true, s.Exists(\"l\"))\n\n\t\tmustDo(t, c,\n\t\t\t\"LPUSHX\", \"l\", \"mies\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\tequals(t, true, s.Exists(\"l\"))\n\t}\n\n\t// Push more.\n\t{\n\t\tmust1(t, c,\n\t\t\t\"LPUSH\", \"l2\", \"aap1\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPUSHX\", \"l2\", \"aap2\", \"noot2\", \"mies2\",\n\t\t\tproto.Int(4),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l2\", \"0\", \"0\",\n\t\t\tproto.Strings(\"mies2\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l2\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"aap1\"),\n\t\t)\n\t}\n\n\t// Errors\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LPUSHX\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'lpushx' command\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPUSHX\", \"l\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'lpushx' command\"),\n\t\t)\n\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"LPUSHX\", \"str\", \"mies\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n}\n\nfunc TestLpop(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tt.Run(\"single\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\", \"l\", \"aap\", \"noot\", \"mies\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l\",\n\t\t\tproto.String(\"noot\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l\",\n\t\t\tproto.String(\"aap\"),\n\t\t)\n\n\t\t// Last element has been popped. Key is gone.\n\t\tmust0(t, c, \"EXISTS\", \"l\")\n\n\t\t// Can pop non-existing keys just fine.\n\t\tmustNil(t, c, \"LPOP\", \"l\")\n\t})\n\n\tt.Run(\"with count\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"LPUSH\", \"l2\", \"aap\", \"noot\", \"mies\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l2\", \"2\",\n\t\t\tproto.Strings(\"mies\", \"noot\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l2\", \"2\",\n\t\t\tproto.Strings(\"aap\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l2\", \"99\",\n\t\t\tproto.NilList,\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"l2\", \"0\",\n\t\t\tproto.NilList,\n\t\t)\n\n\t\t// Last element has been popped. Key is gone.\n\t\tmust0(t, c, \"EXISTS\", \"l2\")\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPOP\", \"str\", \"-1\",\n\t\t\tproto.Error(msgOutOfRange),\n\t\t)\n\t})\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c, \"LPOP\", \"nosuch\", proto.NilResp3)\n\t\tmustDo(t, c, \"LPOP\", \"nosuch\", \"2\", proto.NilResp3)\n\t})\n}\n\nfunc TestRPushPop(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"RPUSH\", \"l\", \"aap\", \"noot\", \"mies\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"0\", \"0\",\n\t\t\tproto.Strings(\"aap\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"mies\"),\n\t\t)\n\t}\n\n\t// Push more.\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"RPUSH\", \"l\", \"aap2\", \"noot2\", \"mies2\",\n\t\t\tproto.Int(6),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"0\", \"0\",\n\t\t\tproto.Strings(\"aap\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"mies2\"),\n\t\t)\n\t}\n\n\t// Direct usage\n\t{\n\t\tl, err := s.Push(\"l2\", \"a\")\n\t\tok(t, err)\n\t\tequals(t, 1, l)\n\t\tl, err = s.Push(\"l2\", \"b\")\n\t\tok(t, err)\n\t\tequals(t, 2, l)\n\t\tlist, err := s.List(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"a\", \"b\"}, list)\n\n\t\tel, err := s.Pop(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, \"b\", el)\n\t\tel, err = s.Pop(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, \"a\", el)\n\t\t// Key is removed on pop-empty.\n\t\tequals(t, false, s.Exists(\"l2\"))\n\t}\n\n\t// Wrong type of key\n\t{\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"RPUSH\", \"str\", \"noot\", \"mies\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n}\n\nfunc TestRpop(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\")\n\n\t// Simple pops.\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"RPOP\", \"l\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"RPOP\", \"l\",\n\t\t\tproto.String(\"noot\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"RPOP\", \"l\",\n\t\t\tproto.String(\"aap\"),\n\t\t)\n\n\t\t// Last element has been popped. Key is gone.\n\t\tmust0(t, c, \"EXISTS\", \"l\")\n\n\t\t// Can pop non-existing keys just fine.\n\t\tmustNil(t, c, \"RPOP\", \"l\")\n\t}\n}\n\nfunc TestLindex(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\", \"vuur\")\n\n\tmustDo(t, c,\n\t\t\"LINDEX\", \"l\", \"0\",\n\t\tproto.String(\"aap\"),\n\t)\n\tmustDo(t, c,\n\t\t\"LINDEX\", \"l\", \"1\",\n\t\tproto.String(\"noot\"),\n\t)\n\tmustDo(t, c,\n\t\t\"LINDEX\", \"l\", \"3\",\n\t\tproto.String(\"vuur\"),\n\t)\n\n\tmustNil(t, c, \"LINDEX\", \"l\", \"3000\") // Too many\n\n\tmustDo(t, c,\n\t\t\"LINDEX\", \"l\", \"-1\",\n\t\tproto.String(\"vuur\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"LINDEX\", \"l\", \"-2\",\n\t\tproto.String(\"mies\"),\n\t)\n\n\tmustNil(t, c, \"LINDEX\", \"l\", \"-400\") // Too big\n\n\t// Non existing key\n\tmustNil(t, c, \"LINDEX\", \"nonexisting\", \"400\")\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\t// Wrong type of key\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"LINDEX\", \"str\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\t// Not an integer\n\t\tmustDo(t, c,\n\t\t\t\"LINDEX\", \"l\", \"noint\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\t// Too many arguments\n\t\tmustDo(t, c,\n\t\t\t\"LINDEX\", \"str\", \"l\", \"foo\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'lindex' command\"),\n\t\t)\n\t})\n}\n\nfunc TestLpos(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"aap\", \"mies\", \"aap\", \"vuur\", \"aap\", \"aap\")\n\n\t// Simple LPOS.\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\",\n\t\tproto.Int(0),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"noot\",\n\t\tproto.Int(1),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"mies\",\n\t\tproto.Int(3),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"vuur\",\n\t\tproto.Int(5),\n\t)\n\tmustNil(t, c, \"LPOS\", \"l\", \"wim\")\n\n\t// LPOS with RANK option.\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"1\",\n\t\tproto.Int(0),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"4\",\n\t\tproto.Int(6),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"5\",\n\t\tproto.Int(7),\n\t)\n\tmustNil(t, c, \"LPOS\", \"l\", \"aap\", \"RANK\", \"6\")\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-1\",\n\t\tproto.Int(7),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-3\",\n\t\tproto.Int(4),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-5\",\n\t\tproto.Int(0),\n\t)\n\tmustNil(t, c, \"LPOS\", \"l\", \"aap\", \"RANK\", \"-6\")\n\n\t// LPOS with COUNT\n\t// When COUNT is specified always return a list.\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"wim\", \"COUNT\", \"1\",\n\t\tproto.Ints())\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"1\",\n\t\tproto.Ints(0),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"3\",\n\t\tproto.Ints(0, 2, 4),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"5\",\n\t\tproto.Ints(0, 2, 4, 6, 7),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"100\",\n\t\tproto.Ints(0, 2, 4, 6, 7),\n\t)\n\tmustDo(t, c,\n\t\t// COUNT 0 means \"unlimited\".\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"0\",\n\t\tproto.Ints(0, 2, 4, 6, 7),\n\t)\n\n\t// LPOS with RANK and COUNT\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"3\", \"COUNT\", \"2\",\n\t\tproto.Ints(4, 6),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"3\", \"COUNT\", \"3\",\n\t\tproto.Ints(4, 6, 7),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"5\", \"COUNT\", \"100\",\n\t\tproto.Ints(7),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-3\", \"COUNT\", \"2\",\n\t\tproto.Ints(4, 2),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-3\", \"COUNT\", \"3\",\n\t\tproto.Ints(4, 2, 0),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-5\", \"COUNT\", \"100\",\n\t\tproto.Ints(0),\n\t)\n\n\t// LPOS with RANK and MAXLEN\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustNil(t, c, \"LPOS\", \"l\", \"aap\", \"RANK\", \"4\", \"MAXLEN\", \"6\")\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"4\", \"MAXLEN\", \"7\",\n\t\tproto.Int(6),\n\t)\n\tmustNil(t, c, \"LPOS\", \"l\", \"aap\", \"RANK\", \"-4\", \"MAXLEN\", \"5\")\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-4\", \"MAXLEN\", \"6\",\n\t\tproto.Int(2),\n\t)\n\n\t// LPOS with COUNT and MAXLEN\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"0\", \"MAXLEN\", \"1\",\n\t\tproto.Ints(0),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"0\", \"MAXLEN\", \"4\",\n\t\tproto.Ints(0, 2),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"0\", \"MAXLEN\", \"7\",\n\t\tproto.Ints(0, 2, 4, 6),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"0\", \"MAXLEN\", \"8\",\n\t\tproto.Ints(0, 2, 4, 6, 7),\n\t)\n\tmustDo(t, c,\n\t\t// MAXLEN 0 means \"unlimited\".\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"0\", \"MAXLEN\", \"0\",\n\t\tproto.Ints(0, 2, 4, 6, 7),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"2\", \"MAXLEN\", \"0\",\n\t\tproto.Ints(0, 2),\n\t)\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"1\", \"MAXLEN\", \"0\",\n\t\tproto.Ints(0),\n\t)\n\n\t// LPOS with RANK, COUNT, and MAXLEN\n\t// [aap, noot, aap, mies, aap, vuur, aap, aap]\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"4\", \"COUNT\", \"2\", \"MAXLEN\", \"0\",\n\t\tproto.Ints(6, 7))\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"4\", \"COUNT\", \"2\", \"MAXLEN\", \"7\",\n\t\tproto.Ints(6))\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"4\", \"COUNT\", \"2\", \"MAXLEN\", \"6\",\n\t\tproto.Ints())\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-3\", \"COUNT\", \"2\", \"MAXLEN\", \"0\",\n\t\tproto.Ints(4, 2))\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-3\", \"COUNT\", \"2\", \"MAXLEN\", \"4\",\n\t\tproto.Ints(4))\n\tmustDo(t, c,\n\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"-3\", \"COUNT\", \"2\", \"MAXLEN\", \"3\",\n\t\tproto.Ints())\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\t// Wrong type of key.\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"str\", \"value\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\t// Wrong number of arguments.\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'lpos' command\"),\n\t\t)\n\n\t\t// Wrong number of options.\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"1\", \"COUNT\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"1\", \"COUNT\", \"1\", \"MAXLEN\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"1\", \"COUNT\", \"1\", \"MAXLEN\", \"1\", \"RANK\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\t// Invalid options.\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANKS\", \"1\",\n\t\t\tproto.Error(\"ERR syntax error\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"1\", \"COUNTING\", \"1\",\n\t\t\tproto.Error(\"ERR syntax error\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"1\", \"MAXLENGTH\", \"1\",\n\t\t\tproto.Error(\"ERR syntax error\"))\n\n\t\t// Invalid option values.\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"not_an_int\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"0\",\n\t\t\tproto.Error(\"ERR RANK can't be zero: use 1 to start from the first match, 2 from the second ... or use negative to start from the end of the list\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"-1\",\n\t\t\tproto.Error(\"ERR COUNT can't be negative\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"not_an_int\",\n\t\t\t// Redis (incorrectly?) reports this as a negative number.\n\t\t\tproto.Error(\"ERR COUNT can't be negative\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"MAXLEN\", \"-1\",\n\t\t\tproto.Error(\"ERR MAXLEN can't be negative\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"MAXLEN\", \"not_an_int\",\n\t\t\t// Redis (incorrectly?) reports this as a negative number.\n\t\t\tproto.Error(\"ERR MAXLEN can't be negative\"))\n\n\t\t// First invalid option encountered reports the error.\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"MAXLEN\", \"-1\", \"RANK\", \"not_an_int\", \"COUNT\", \"-1\",\n\t\t\tproto.Error(\"ERR MAXLEN can't be negative\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"RANK\", \"not_an_int\", \"COUNT\", \"-1\", \"MAXLEN\", \"-1\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"))\n\t\tmustDo(t, c,\n\t\t\t\"LPOS\", \"l\", \"aap\", \"COUNT\", \"-1\", \"MAXLEN\", \"-1\", \"RANK\", \"not_an_int\",\n\t\t\tproto.Error(\"ERR COUNT can't be negative\"))\n\t})\n}\n\nfunc TestLlen(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\", \"vuur\")\n\n\tmustDo(t, c,\n\t\t\"LLEN\", \"l\",\n\t\tproto.Int(4),\n\t)\n\n\t// Non existing key\n\tmust0(t, c,\n\t\t\"LLEN\", \"nonexisting\",\n\t)\n\n\t// Wrong type of key\n\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\tmustDo(t, c,\n\t\t\"LLEN\", \"str\",\n\t\tproto.Error(msgWrongType),\n\t)\n\n\t// Too many arguments\n\tmustDo(t, c,\n\t\t\"LLEN\", \"too\", \"many\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'llen' command\"),\n\t)\n}\n\nfunc TestLtrim(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\", \"vuur\")\n\n\t{\n\t\tmustOK(t, c, \"LTRIM\", \"l\", \"0\", \"2\")\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"noot\", \"mies\"}, l)\n\t}\n\n\t// Delete key on empty list\n\t{\n\t\tmustOK(t, c, \"LTRIM\", \"l\", \"0\", \"-99\")\n\t\tequals(t, false, s.Exists(\"l\"))\n\t}\n\n\t// Not existing key\n\tmustOK(t, c, \"LTRIM\", \"nonexisting\", \"0\", \"1\")\n\n\t// Wrong type of key\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\", \"str\", \"0\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\", \"l\", \"1\", \"2\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"ltrim\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\", \"l\", \"1\", \"noint\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\", \"l\", \"noint\", \"1\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\", \"l\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"ltrim\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"ltrim\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LTRIM\",\n\t\t\tproto.Error(errWrongNumber(\"ltrim\")),\n\t\t)\n\t})\n}\n\nfunc TestLrem(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Reverse\n\t{\n\t\ts.Push(\"l\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"noot\")\n\t\tmust1(t, c,\n\t\t\t\"LREM\", \"l\", \"-1\", \"noot\",\n\t\t)\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"noot\", \"mies\", \"vuur\", \"noot\"}, l)\n\t}\n\t// Normal\n\t{\n\t\ts.Push(\"l2\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l2\", \"2\", \"noot\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\tl, err := s.List(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"mies\", \"vuur\", \"noot\"}, l)\n\t}\n\n\t// All\n\t{\n\t\ts.Push(\"l3\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l3\", \"0\", \"noot\",\n\t\t\tproto.Int(3),\n\t\t)\n\t\tl, err := s.List(\"l3\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"mies\", \"vuur\"}, l)\n\t}\n\n\t// All\n\t{\n\t\ts.Push(\"l4\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l4\", \"200\", \"noot\",\n\t\t\tproto.Int(3),\n\t\t)\n\t\tl, err := s.List(\"l4\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"mies\", \"vuur\"}, l)\n\t}\n\n\t// Delete key on empty list\n\t{\n\t\ts.Push(\"l5\", \"noot\", \"noot\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l5\", \"99\", \"noot\",\n\t\t\tproto.Int(3),\n\t\t)\n\t\tequals(t, false, s.Exists(\"l5\"))\n\t}\n\n\t// Non existing key\n\tmust0(t, c,\n\t\t\"LREM\", \"nonexisting\", \"0\", \"aap\",\n\t)\n\n\t// Error cases\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LREM\",\n\t\t\tproto.Error(errWrongNumber(\"lrem\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"lrem\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"lrem\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l\", \"noint\", \"aap\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"l\", \"1\", \"aap\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"lrem\")),\n\t\t)\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"LREM\", \"str\", \"0\", \"aap\",\n\t\t\tproto.Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\"),\n\t\t)\n\t}\n}\n\nfunc TestLset(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"noot\")\n\t// Simple LSET\n\t{\n\t\tmustOK(t, c, \"LSET\", \"l\", \"1\", \"noot!\")\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"noot!\", \"mies\", \"vuur\", \"noot\", \"noot\"}, l)\n\t}\n\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"LSET\", \"l\", \"-1\", \"noot?\",\n\t\t)\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"noot!\", \"mies\", \"vuur\", \"noot\", \"noot?\"}, l)\n\t}\n\n\t// Out of range\n\tmustDo(t, c,\n\t\t\"LSET\", \"l\", \"10000\", \"aap\",\n\t\tproto.Error(\"ERR index out of range\"),\n\t)\n\tmustDo(t, c,\n\t\t\"LSET\", \"l\", \"-10000\", \"aap\",\n\t\tproto.Error(\"ERR index out of range\"),\n\t)\n\n\t// Non existing key\n\tmustDo(t, c,\n\t\t\"LSET\", \"nonexisting\", \"0\", \"aap\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"LSET\",\n\t\t\tproto.Error(errWrongNumber(\"lset\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LSET\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"lset\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LSET\", \"l\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"lset\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LSET\", \"l\", \"noint\", \"aap\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LSET\", \"l\", \"1\", \"aap\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"lset\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"LSET\", \"str\", \"0\", \"aap\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestLinsert(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"end\")\n\t// Before\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"BEFORE\", \"noot\", \"!\",\n\t\t\tproto.Int(7),\n\t\t)\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"!\", \"noot\", \"mies\", \"vuur\", \"noot\", \"end\"}, l)\n\t}\n\n\t// After\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"AFTER\", \"noot\", \"?\",\n\t\t\tproto.Int(8),\n\t\t)\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"!\", \"noot\", \"?\", \"mies\", \"vuur\", \"noot\", \"end\"}, l)\n\t}\n\n\t// Edge case before\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"BEFORE\", \"aap\", \"[\",\n\t\t\tproto.Int(9),\n\t\t)\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"[\", \"aap\", \"!\", \"noot\", \"?\", \"mies\", \"vuur\", \"noot\", \"end\"}, l)\n\t}\n\n\t// Edge case after\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"AFTER\", \"end\", \"]\",\n\t\t\tproto.Int(10),\n\t\t)\n\t\tl, err := s.List(\"l\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"[\", \"aap\", \"!\", \"noot\", \"?\", \"mies\", \"vuur\", \"noot\", \"end\", \"]\"}, l)\n\t}\n\n\t// Non existing pivot\n\tmustDo(t, c,\n\t\t\"LINSERT\", \"l\", \"before\", \"nosuch\", \"noot\",\n\t\tproto.Int(-1),\n\t)\n\n\t// Non existing key\n\tmust0(t, c,\n\t\t\"LINSERT\", \"nonexisting\", \"before\", \"aap\", \"noot\",\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\",\n\t\t\tproto.Error(errWrongNumber(\"linsert\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"linsert\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"before\",\n\t\t\tproto.Error(errWrongNumber(\"linsert\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"before\", \"value\",\n\t\t\tproto.Error(errWrongNumber(\"linsert\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"wrong\", \"value\", \"value\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"l\", \"wrong\", \"value\", \"value\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"linsert\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"LINSERT\", \"str\", \"before\", \"value\", \"value\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestRpoplpush(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"l\", \"aap\", \"noot\", \"mies\")\n\ts.Push(\"l2\", \"vuur\", \"noot\", \"end\")\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"l\", \"l2\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\ts.CheckList(t, \"l\", \"aap\", \"noot\")\n\t\ts.CheckList(t, \"l2\", \"mies\", \"vuur\", \"noot\", \"end\")\n\t}\n\t// Again!\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"l\", \"l2\",\n\t\t\tproto.String(\"noot\"),\n\t\t)\n\t\ts.CheckList(t, \"l\", \"aap\")\n\t\ts.CheckList(t, \"l2\", \"noot\", \"mies\", \"vuur\", \"noot\", \"end\")\n\t}\n\t// Again!\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"l\", \"l2\",\n\t\t\tproto.String(\"aap\"),\n\t\t)\n\t\tassert(t, !s.Exists(\"l\"), \"l exists\")\n\t\ts.CheckList(t, \"l2\", \"aap\", \"noot\", \"mies\", \"vuur\", \"noot\", \"end\")\n\t}\n\n\t// Non existing lists\n\t{\n\t\ts.Push(\"ll\", \"aap\", \"noot\", \"mies\")\n\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"ll\", \"nosuch\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\tassert(t, s.Exists(\"nosuch\"), \"nosuch exists\")\n\t\ts.CheckList(t, \"ll\", \"aap\", \"noot\")\n\t\ts.CheckList(t, \"nosuch\", \"mies\")\n\n\t\tmustNil(t, c,\n\t\t\t\"RPOPLPUSH\", \"nosuch2\", \"ll\",\n\t\t)\n\t}\n\n\t// Cycle\n\t{\n\t\ts.Push(\"cycle\", \"aap\", \"noot\", \"mies\")\n\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"cycle\", \"cycle\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\ts.CheckList(t, \"cycle\", \"mies\", \"aap\", \"noot\")\n\t}\n\n\t// Error cases\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Push(\"src\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\",\n\t\t\tproto.Error(errWrongNumber(\"rpoplpush\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"rpoplpush\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"too\", \"many\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"rpoplpush\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"str\", \"src\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RPOPLPUSH\", \"src\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestRpushx(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Simple cases\n\t{\n\t\t// No key key\n\t\tmust0(t, c,\n\t\t\t\"RPUSHX\", \"l\", \"value\",\n\t\t)\n\t\tassert(t, !s.Exists(\"l\"), \"l doesn't exist\")\n\n\t\ts.Push(\"l\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"RPUSHX\", \"l\", \"mies\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\ts.CheckList(t, \"l\", \"aap\", \"noot\", \"mies\")\n\t}\n\n\t// Push more.\n\t{\n\t\tmust1(t, c,\n\t\t\t\"LPUSH\", \"l2\", \"aap1\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RPUSHX\", \"l2\", \"aap2\", \"noot2\", \"mies2\",\n\t\t\tproto.Int(4),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l2\", \"0\", \"0\",\n\t\t\tproto.Strings(\"aap1\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LRANGE\", \"l2\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"mies2\"),\n\t\t)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Push(\"src\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"RPUSHX\",\n\t\t\tproto.Error(errWrongNumber(\"rpushx\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"RPUSHX\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"rpushx\")),\n\t\t)\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"RPUSHX\", \"str\", \"value\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestBrpop(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Simple cases\n\t{\n\t\ts.Push(\"ll\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\", \"ll\", \"1\",\n\t\t\tproto.Strings(\"ll\", \"mies\"),\n\t\t)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\",\n\t\t\tproto.Error(errWrongNumber(\"brpop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"brpop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\", \"key\", \"-1\",\n\t\t\tproto.Error(\"ERR timeout is negative\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\", \"key\", \"inf\",\n\t\t\tproto.Error(\"ERR timeout is out of range\"),\n\t\t)\n\t})\n}\n\nfunc TestBrpopSimple(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tgot := goStrings(t, s, \"BRPOP\", \"mylist\", \"0\")\n\ttime.Sleep(30 * time.Millisecond)\n\n\tmustDo(t, c,\n\t\t\"RPUSH\", \"mylist\", \"e1\", \"e2\", \"e3\",\n\t\tproto.Int(3),\n\t)\n\n\tselect {\n\tcase have := <-got:\n\t\tequals(t, proto.Strings(\"mylist\", \"e3\"), have)\n\tcase <-time.After(500 * time.Millisecond):\n\t\tt.Error(\"BRPOP took too long\")\n\t}\n}\n\nfunc TestBrpopMulti(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tgot := goStrings(t, s, \"BRPOP\", \"l1\", \"l2\", \"l3\", \"0\")\n\tmust1(t, c, \"RPUSH\", \"l0\", \"e01\")\n\tmust1(t, c, \"RPUSH\", \"l2\", \"e21\")\n\tmust1(t, c, \"RPUSH\", \"l3\", \"e31\")\n\n\tselect {\n\tcase have := <-got:\n\t\tequals(t, proto.Strings(\"l2\", \"e21\"), have)\n\tcase <-time.After(500 * time.Millisecond):\n\t\tt.Error(\"BRPOP took too long\")\n\t}\n\n\tgot = goStrings(t, s, \"BRPOP\", \"l1\", \"l2\", \"l3\", \"0\")\n\tselect {\n\tcase have := <-got:\n\t\tequals(t, proto.Strings(\"l3\", \"e31\"), have)\n\tcase <-time.After(500 * time.Millisecond):\n\t\tt.Error(\"BRPOP took too long\")\n\t}\n}\n\nfunc TestBrpopTimeout(t *testing.T) {\n\ts := RunT(t)\n\n\tgot := goStrings(t, s, \"BRPOP\", \"l1\", \"0.1\")\n\tselect {\n\tcase have := <-got:\n\t\tequals(t, proto.NilList, have)\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Error(\"BRPOP took too long\")\n\t}\n}\n\nfunc TestBrpopTx(t *testing.T) {\n\t// BRPOP in a transaction behaves as if the timeout triggers right away\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\", \"l1\", \"3\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"foo\", \"bar\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"EXEC\",\n\t\t\tproto.Array(\n\t\t\t\tproto.NilList,\n\t\t\t\tproto.Inline(\"OK\"),\n\t\t\t),\n\t\t)\n\t}\n\n\t// Now set something\n\ts.Push(\"l1\", \"e1\")\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOP\", \"l1\", \"3\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"foo\", \"bar\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"EXEC\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"l1\", \"e1\"),\n\t\t\t\tproto.Inline(\"OK\"),\n\t\t\t),\n\t\t)\n\t}\n}\n\nfunc TestBlpop(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ts.Push(\"ll\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"BLPOP\", \"ll\", \"1\",\n\t\t\tproto.Strings(\"ll\", \"aap\"),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"BLPOP\",\n\t\t\tproto.Error(errWrongNumber(\"blpop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLPOP\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"blpop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLPOP\", \"key\", \"-1\",\n\t\t\tproto.Error(\"ERR timeout is negative\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLPOP\", \"key\", \"inf\",\n\t\t\tproto.Error(\"ERR timeout is out of range\"),\n\t\t)\n\t})\n}\n\nfunc TestBlpopResourceCleanup(t *testing.T) {\n\ts := RunT(t)\n\tc, err := proto.Dial(s.Addr())\n\tok(t, err)\n\n\t// Let's say a client issued BLPOP and then the client was closed\n\tgo func() {\n\t\t_, err := c.Do(\"BLPOP\", \"key\", \"0\")\n\t\tassert(t, strings.Contains(err.Error(), \"use of closed network connection\"), \"got a network error\")\n\t}()\n\n\ttime.Sleep(50 * time.Millisecond)\n\n\tc.Close()\n\ts.Close() // expect BLPOP to stop blocking\n}\n\nfunc TestBrpoplpush(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Simple cases\n\t{\n\t\ts.Push(\"l1\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"l1\", \"l2\", \"1\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\n\t\tlv, err := s.List(\"l2\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"mies\"}, lv)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\",\n\t\t\tproto.Error(errWrongNumber(\"brpoplpush\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"brpoplpush\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"key\", \"bar\",\n\t\t\tproto.Error(errWrongNumber(\"brpoplpush\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"key\", \"foo\", \"-1\",\n\t\t\tproto.Error(\"ERR timeout is negative\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"key\", \"foo\", \"inf\",\n\t\t\tproto.Error(\"ERR timeout is out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BRPOPLPUSH\", \"key\", \"foo\", \"1\", \"baz\",\n\t\t\tproto.Error(errWrongNumber(\"brpoplpush\")),\n\t\t)\n\t})\n}\n\nfunc TestBrpoplpushSimple(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tgot := goStrings(t, s, \"BRPOPLPUSH\", \"from\", \"to\", \"1\")\n\ttime.Sleep(30 * time.Millisecond)\n\n\tmustDo(t, c,\n\t\t\"RPUSH\", \"from\", \"e1\", \"e2\", \"e3\",\n\t\tproto.Int(3),\n\t)\n\n\tselect {\n\tcase have := <-got:\n\t\tequals(t, proto.String(\"e3\"), have)\n\tcase <-time.After(500 * time.Millisecond):\n\t\tt.Fatal(\"BRPOP took too long\")\n\t}\n\n\tlv, err := s.List(\"from\")\n\tok(t, err)\n\tequals(t, []string{\"e1\", \"e2\"}, lv)\n\tlv, err = s.List(\"to\")\n\tok(t, err)\n\tequals(t, []string{\"e3\"}, lv)\n}\n\nfunc TestBrpoplpushTimeout(t *testing.T) {\n\ts := RunT(t)\n\n\tgot := goStrings(t, s, \"BRPOPLPUSH\", \"l1\", \"l2\", \"0.1\")\n\tselect {\n\tcase have := <-got:\n\t\tequals(t, proto.NilList, have)\n\tcase <-time.After(200 * time.Millisecond):\n\t\tt.Error(\"BRPOPLPUSH took too long\")\n\t}\n}\n\nfunc TestLmove(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Push(\"src\", \"LR\", \"LL\", \"RR\", \"RL\")\n\ts.Push(\"dst\", \"m1\", \"m2\", \"m3\")\n\t// RIGHT LEFT\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"RIGHT\", \"LEFT\",\n\t\t\tproto.String(\"RL\"),\n\t\t)\n\t\ts.CheckList(t, \"src\", \"LR\", \"LL\", \"RR\")\n\t\ts.CheckList(t, \"dst\", \"RL\", \"m1\", \"m2\", \"m3\")\n\t}\n\t// LEFT RIGHT\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"LEFT\", \"RIGHT\",\n\t\t\tproto.String(\"LR\"),\n\t\t)\n\t\ts.CheckList(t, \"src\", \"LL\", \"RR\")\n\t\ts.CheckList(t, \"dst\", \"RL\", \"m1\", \"m2\", \"m3\", \"LR\")\n\t}\n\t// RIGHT RIGHT\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"RIGHT\", \"RIGHT\",\n\t\t\tproto.String(\"RR\"),\n\t\t)\n\t\ts.CheckList(t, \"src\", \"LL\")\n\t\ts.CheckList(t, \"dst\", \"RL\", \"m1\", \"m2\", \"m3\", \"LR\", \"RR\")\n\t}\n\t// LEFT LEFT\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"LEFT\", \"LEFT\",\n\t\t\tproto.String(\"LL\"),\n\t\t)\n\t\tassert(t, !s.Exists(\"src\"), \"src exists\")\n\t\ts.CheckList(t, \"dst\", \"LL\", \"RL\", \"m1\", \"m2\", \"m3\", \"LR\", \"RR\")\n\t}\n\n\t// Non existing lists\n\t{\n\t\ts.Push(\"ll\", \"aap\", \"noot\", \"mies\")\n\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"ll\", \"nosuch\", \"RIGHT\", \"LEFT\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\tassert(t, s.Exists(\"nosuch\"), \"nosuch exists\")\n\t\ts.CheckList(t, \"ll\", \"aap\", \"noot\")\n\t\ts.CheckList(t, \"nosuch\", \"mies\")\n\n\t\tmustNil(t, c,\n\t\t\t\"LMOVE\", \"nosuch2\", \"ll\", \"RIGHT\", \"LEFT\",\n\t\t)\n\t}\n\n\t// Cycle\n\t{\n\t\ts.Push(\"cycle\", \"aap\", \"noot\", \"mies\")\n\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"cycle\", \"cycle\", \"RIGHT\", \"LEFT\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\ts.CheckList(t, \"cycle\", \"mies\", \"aap\", \"noot\")\n\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"cycle\", \"cycle\", \"LEFT\", \"RIGHT\",\n\t\t\tproto.String(\"mies\"),\n\t\t)\n\t\ts.CheckList(t, \"cycle\", \"aap\", \"noot\", \"mies\")\n\t}\n\n\t// Error cases\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.Push(\"src\", \"aap\", \"noot\", \"mies\")\n\t\ts.Push(\"dst\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\",\n\t\t\tproto.Error(errWrongNumber(\"lmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"lmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"l\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"lmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"l\", \"l\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"lmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"too\", \"many\", \"many\", \"many\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"lmove\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"str\", \"src\", \"left\", \"right\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"str\", \"left\", \"right\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"no\", \"good\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"invalid\", \"right\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"LMOVE\", \"src\", \"dst\", \"left\", \"invalid\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n}\n\nfunc TestBlmove(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"Behaves just like LMOVE\", func(t *testing.T) {\n\t\ts.Push(\"src\", \"LR\", \"LL\", \"RR\", \"RL\")\n\t\ts.Push(\"dst\", \"m1\", \"m2\", \"m3\")\n\n\t\t// RIGHT LEFT\n\t\t{\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"src\", \"dst\", \"RIGHT\", \"LEFT\", \"0\",\n\t\t\t\tproto.String(\"RL\"),\n\t\t\t)\n\t\t\ts.CheckList(t, \"src\", \"LR\", \"LL\", \"RR\")\n\t\t\ts.CheckList(t, \"dst\", \"RL\", \"m1\", \"m2\", \"m3\")\n\t\t}\n\t\t// LEFT RIGHT\n\t\t{\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"src\", \"dst\", \"LEFT\", \"RIGHT\", \"0\",\n\t\t\t\tproto.String(\"LR\"),\n\t\t\t)\n\t\t\ts.CheckList(t, \"src\", \"LL\", \"RR\")\n\t\t\ts.CheckList(t, \"dst\", \"RL\", \"m1\", \"m2\", \"m3\", \"LR\")\n\t\t}\n\t\t// RIGHT RIGHT\n\t\t{\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"src\", \"dst\", \"RIGHT\", \"RIGHT\", \"0\",\n\t\t\t\tproto.String(\"RR\"),\n\t\t\t)\n\t\t\ts.CheckList(t, \"src\", \"LL\")\n\t\t\ts.CheckList(t, \"dst\", \"RL\", \"m1\", \"m2\", \"m3\", \"LR\", \"RR\")\n\t\t}\n\t\t// LEFT LEFT\n\t\t{\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"src\", \"dst\", \"LEFT\", \"LEFT\", \"0\",\n\t\t\t\tproto.String(\"LL\"),\n\t\t\t)\n\t\t\tassert(t, !s.Exists(\"src\"), \"src exists\")\n\t\t\ts.CheckList(t, \"dst\", \"LL\", \"RL\", \"m1\", \"m2\", \"m3\", \"LR\", \"RR\")\n\t\t}\n\n\t\t// Non existing lists\n\t\t{\n\t\t\ts.Push(\"ll\", \"aap\", \"noot\", \"mies\")\n\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"ll\", \"nosuch\", \"RIGHT\", \"LEFT\", \"0\",\n\t\t\t\tproto.String(\"mies\"),\n\t\t\t)\n\t\t\tassert(t, s.Exists(\"nosuch\"), \"nosuch exists\")\n\t\t\ts.CheckList(t, \"ll\", \"aap\", \"noot\")\n\t\t\ts.CheckList(t, \"nosuch\", \"mies\")\n\n\t\t\tmustNilList(t, c,\n\t\t\t\t\"BLMOVE\", \"nosuch2\", \"ll\", \"RIGHT\", \"LEFT\", \"0.001\",\n\t\t\t)\n\t\t}\n\n\t\t// Cycle\n\t\t{\n\t\t\ts.Push(\"cycle\", \"aap\", \"noot\", \"mies\")\n\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"cycle\", \"cycle\", \"RIGHT\", \"LEFT\", \"0\",\n\t\t\t\tproto.String(\"mies\"),\n\t\t\t)\n\t\t\ts.CheckList(t, \"cycle\", \"mies\", \"aap\", \"noot\")\n\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BLMOVE\", \"cycle\", \"cycle\", \"LEFT\", \"RIGHT\", \"0\",\n\t\t\t\tproto.String(\"mies\"),\n\t\t\t)\n\t\t\ts.CheckList(t, \"cycle\", \"aap\", \"noot\", \"mies\")\n\t\t}\n\t})\n\n\tt.Run(\"Errors\", func(t *testing.T) {\n\t\ts.Push(\"src\", \"aap\", \"noot\", \"mies\")\n\t\ts.Push(\"dst\", \"aap\", \"noot\", \"mies\")\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\",\n\t\t\tproto.Error(errWrongNumber(\"blmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"blmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"l\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"blmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"l\", \"l\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"blmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"l\", \"l\", \"l\", \"l\",\n\t\t\tproto.Error(errWrongNumber(\"blmove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"too\", \"many\", \"many\", \"many\", \"many\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"blmove\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"string!\")\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"str\", \"src\", \"left\", \"right\", \"0\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"src\", \"str\", \"left\", \"right\", \"0\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"src\", \"dst\", \"no\", \"good\", \"0\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"src\", \"dst\", \"invalid\", \"right\", \"0\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BLMOVE\", \"src\", \"dst\", \"left\", \"invalid\", \"0\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n\n\tt.Run(\"Blocking: simple case\", func(t *testing.T) {\n\t\tc.Do(\"DEL\", \"src\", \"dst\")\n\n\t\ts.Push(\"src\", \"s1\", \"s2\")\n\t\ts.Push(\"dst\", \"d1\")\n\t\tgot := goStrings(t, s, \"BLMOVE\", \"src\", \"dst\", \"RIGHT\", \"LEFT\", \"0.1\")\n\t\tselect {\n\t\tcase have := <-got:\n\t\t\tequals(t, proto.String(\"s2\"), have)\n\t\t\ts.CheckList(t, \"src\", \"s1\")\n\t\t\ts.CheckList(t, \"dst\", \"s2\", \"d1\")\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Error(\"BLMOVE took too long\")\n\t\t}\n\t})\n\n\tt.Run(\"Blocking: timeout\", func(t *testing.T) {\n\t\tc.Do(\"DEL\", \"src\", \"dst\")\n\n\t\tgot := goStrings(t, s, \"BLMOVE\", \"src\", \"dst\", \"RIGHT\", \"LEFT\", \"0.1\")\n\t\tselect {\n\t\tcase have := <-got:\n\t\t\tequals(t, proto.NilList, have)\n\t\tcase <-time.After(200 * time.Millisecond):\n\t\t\tt.Error(\"BLMOVE took too long\")\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "cmd_object.go",
          "type": "blob",
          "size": 1.037109375,
          "content": "package miniredis\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsObject handles all object operations.\nfunc commandsObject(m *Miniredis) {\n\tm.srv.Register(\"OBJECT\", m.cmdObject)\n}\n\n// OBJECT\nfunc (m *Miniredis) cmdObject(c *server.Peer, cmd string, args []string) {\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tswitch sub := strings.ToLower(args[0]); sub {\n\tcase \"idletime\":\n\t\tm.cmdObjectIdletime(c, args[1:])\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(msgFObjectUsage, sub))\n\t}\n}\n\n// OBJECT IDLETIME\nfunc (m *Miniredis) cmdObjectIdletime(c *server.Peer, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"object|idletime\"))\n\t\treturn\n\t}\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tt, ok := db.lru[key]\n\t\tif !ok {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(int(db.master.effectiveNow().Sub(t).Seconds()))\n\t})\n}\n"
        },
        {
          "name": "cmd_object_test.go",
          "type": "blob",
          "size": 0.603515625,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test OBJECT IDLETIME.\nfunc TestObjectIdletime(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tstart := time.Now()\n\t\ts.SetTime(start)\n\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"foo\", \"bar\",\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"OBJECT\", \"IDLETIME\", \"foo\",\n\t\t\tproto.Int(0),\n\t\t)\n\n\t\ts.SetTime(start.Add(time.Minute))\n\t\tmustDo(t, c,\n\t\t\t\"OBJECT\", \"IDLETIME\", \"foo\",\n\t\t\tproto.Int(60),\n\t\t)\n\n\t\ts.Get(\"foo\")\n\t\tmustDo(t, c,\n\t\t\t\"object\", \"idletime\", \"foo\",\n\t\t\tproto.Int(0),\n\t\t)\n\n\t\ts.Del(\"foo\")\n\t\tmustDo(t, c,\n\t\t\t\"OBJECT\", \"IDLETIME\", \"foo\",\n\t\t\tproto.Nil,\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "cmd_pubsub.go",
          "type": "blob",
          "size": 4.99609375,
          "content": "// Commands from https://redis.io/commands#pubsub\n\npackage miniredis\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsPubsub handles all PUB/SUB operations.\nfunc commandsPubsub(m *Miniredis) {\n\tm.srv.Register(\"SUBSCRIBE\", m.cmdSubscribe)\n\tm.srv.Register(\"UNSUBSCRIBE\", m.cmdUnsubscribe)\n\tm.srv.Register(\"PSUBSCRIBE\", m.cmdPsubscribe)\n\tm.srv.Register(\"PUNSUBSCRIBE\", m.cmdPunsubscribe)\n\tm.srv.Register(\"PUBLISH\", m.cmdPublish)\n\tm.srv.Register(\"PUBSUB\", m.cmdPubSub)\n}\n\n// SUBSCRIBE\nfunc (m *Miniredis) cmdSubscribe(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tsub := m.subscribedState(c)\n\t\tfor _, channel := range args {\n\t\t\tn := sub.Subscribe(channel)\n\t\t\tc.Block(func(w *server.Writer) {\n\t\t\t\tw.WritePushLen(3)\n\t\t\t\tw.WriteBulk(\"subscribe\")\n\t\t\t\tw.WriteBulk(channel)\n\t\t\t\tw.WriteInt(n)\n\t\t\t})\n\t\t}\n\t})\n}\n\n// UNSUBSCRIBE\nfunc (m *Miniredis) cmdUnsubscribe(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\tchannels := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tsub := m.subscribedState(c)\n\n\t\tif len(channels) == 0 {\n\t\t\tchannels = sub.Channels()\n\t\t}\n\n\t\t// there is no de-duplication\n\t\tfor _, channel := range channels {\n\t\t\tn := sub.Unsubscribe(channel)\n\t\t\tc.Block(func(w *server.Writer) {\n\t\t\t\tw.WritePushLen(3)\n\t\t\t\tw.WriteBulk(\"unsubscribe\")\n\t\t\t\tw.WriteBulk(channel)\n\t\t\t\tw.WriteInt(n)\n\t\t\t})\n\t\t}\n\t\tif len(channels) == 0 {\n\t\t\t// special case: there is always a reply\n\t\t\tc.Block(func(w *server.Writer) {\n\t\t\t\tw.WritePushLen(3)\n\t\t\t\tw.WriteBulk(\"unsubscribe\")\n\t\t\t\tw.WriteNull()\n\t\t\t\tw.WriteInt(0)\n\t\t\t})\n\t\t}\n\n\t\tif sub.Count() == 0 {\n\t\t\tendSubscriber(m, c)\n\t\t}\n\t})\n}\n\n// PSUBSCRIBE\nfunc (m *Miniredis) cmdPsubscribe(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tsub := m.subscribedState(c)\n\t\tfor _, pat := range args {\n\t\t\tn := sub.Psubscribe(pat)\n\t\t\tc.Block(func(w *server.Writer) {\n\t\t\t\tw.WritePushLen(3)\n\t\t\t\tw.WriteBulk(\"psubscribe\")\n\t\t\t\tw.WriteBulk(pat)\n\t\t\t\tw.WriteInt(n)\n\t\t\t})\n\t\t}\n\t})\n}\n\n// PUNSUBSCRIBE\nfunc (m *Miniredis) cmdPunsubscribe(c *server.Peer, cmd string, args []string) {\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\tpatterns := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tsub := m.subscribedState(c)\n\n\t\tif len(patterns) == 0 {\n\t\t\tpatterns = sub.Patterns()\n\t\t}\n\n\t\t// there is no de-duplication\n\t\tfor _, pat := range patterns {\n\t\t\tn := sub.Punsubscribe(pat)\n\t\t\tc.Block(func(w *server.Writer) {\n\t\t\t\tw.WritePushLen(3)\n\t\t\t\tw.WriteBulk(\"punsubscribe\")\n\t\t\t\tw.WriteBulk(pat)\n\t\t\t\tw.WriteInt(n)\n\t\t\t})\n\t\t}\n\t\tif len(patterns) == 0 {\n\t\t\t// special case: there is always a reply\n\t\t\tc.Block(func(w *server.Writer) {\n\t\t\t\tw.WritePushLen(3)\n\t\t\t\tw.WriteBulk(\"punsubscribe\")\n\t\t\t\tw.WriteNull()\n\t\t\t\tw.WriteInt(0)\n\t\t\t})\n\t\t}\n\n\t\tif sub.Count() == 0 {\n\t\t\tendSubscriber(m, c)\n\t\t}\n\t})\n}\n\n// PUBLISH\nfunc (m *Miniredis) cmdPublish(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tchannel, mesg := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tc.WriteInt(m.publish(channel, mesg))\n\t})\n}\n\n// PUBSUB\nfunc (m *Miniredis) cmdPubSub(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tsubcommand := strings.ToUpper(args[0])\n\tsubargs := args[1:]\n\tvar argsOk bool\n\n\tswitch subcommand {\n\tcase \"CHANNELS\":\n\t\targsOk = len(subargs) < 2\n\tcase \"NUMSUB\":\n\t\targsOk = true\n\tcase \"NUMPAT\":\n\t\targsOk = len(subargs) == 0\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(msgFPubsubUsageSimple, subcommand))\n\t\treturn\n\t}\n\n\tif !argsOk {\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(msgFPubsubUsage, subcommand))\n\t\treturn\n\t}\n\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tswitch subcommand {\n\t\tcase \"CHANNELS\":\n\t\t\tpat := \"\"\n\t\t\tif len(subargs) == 1 {\n\t\t\t\tpat = subargs[0]\n\t\t\t}\n\n\t\t\tallsubs := m.allSubscribers()\n\t\t\tchannels := activeChannels(allsubs, pat)\n\n\t\t\tc.WriteLen(len(channels))\n\t\t\tfor _, channel := range channels {\n\t\t\t\tc.WriteBulk(channel)\n\t\t\t}\n\n\t\tcase \"NUMSUB\":\n\t\t\tsubs := m.allSubscribers()\n\t\t\tc.WriteLen(len(subargs) * 2)\n\t\t\tfor _, channel := range subargs {\n\t\t\t\tc.WriteBulk(channel)\n\t\t\t\tc.WriteInt(countSubs(subs, channel))\n\t\t\t}\n\n\t\tcase \"NUMPAT\":\n\t\t\tc.WriteInt(countPsubs(m.allSubscribers()))\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "cmd_pubsub_test.go",
          "type": "blob",
          "size": 11.0009765625,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestSubscribe(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"event1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"event2\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event2\"),\n\t\t\tproto.Int(2),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"event3\", \"event4\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event3\"),\n\t\t\tproto.Int(3),\n\t\t),\n\t)\n\tmustRead(t, c,\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event4\"),\n\t\t\tproto.Int(4),\n\t\t),\n\t)\n\n\t{\n\t\t// publish something!\n\t\tmustDo(t, c,\n\t\t\t\"SUBSCRIBE\", \"colors\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"subscribe\"),\n\t\t\t\tproto.String(\"colors\"),\n\t\t\t\tproto.Int(5),\n\t\t\t),\n\t\t)\n\t\tn := s.Publish(\"colors\", \"green\")\n\t\tequals(t, 1, n)\n\n\t\tmustRead(t, c,\n\t\t\tproto.Strings(\"message\", \"colors\", \"green\"),\n\t\t)\n\t}\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SUBSCRIBE\", \"q1\", \"q2\",\n\t\t\tproto.Push(\n\t\t\t\tproto.String(\"subscribe\"),\n\t\t\t\tproto.String(\"q1\"),\n\t\t\t\tproto.Int(6),\n\t\t\t),\n\t\t)\n\t\tmustRead(t, c,\n\t\t\tproto.Push(\n\t\t\t\tproto.String(\"subscribe\"),\n\t\t\t\tproto.String(\"q2\"),\n\t\t\t\tproto.Int(7),\n\t\t\t),\n\t\t)\n\t})\n}\n\nfunc TestUnsubscribe(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"event1\", \"event2\", \"event3\", \"event4\", \"event5\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\tmustRead(t, c, proto.Array(proto.String(\"subscribe\"), proto.String(\"event2\"), proto.Int(2)))\n\tmustRead(t, c, proto.Array(proto.String(\"subscribe\"), proto.String(\"event3\"), proto.Int(3)))\n\tmustRead(t, c, proto.Array(proto.String(\"subscribe\"), proto.String(\"event4\"), proto.Int(4)))\n\tmustRead(t, c, proto.Array(proto.String(\"subscribe\"), proto.String(\"event5\"), proto.Int(5)))\n\n\tmustDo(t, c,\n\t\t\"UNSUBSCRIBE\", \"event1\", \"event2\",\n\t\tproto.Array(\n\t\t\tproto.String(\"unsubscribe\"),\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(4),\n\t\t),\n\t)\n\tmustRead(t, c, proto.Array(proto.String(\"unsubscribe\"), proto.String(\"event2\"), proto.Int(3)))\n\n\tmustDo(t, c,\n\t\t\"UNSUBSCRIBE\", \"event3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"unsubscribe\"),\n\t\t\tproto.String(\"event3\"),\n\t\t\tproto.Int(2),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"UNSUBSCRIBE\", \"event999\",\n\t\tproto.Array(\n\t\t\tproto.String(\"unsubscribe\"),\n\t\t\tproto.String(\"event999\"),\n\t\t\tproto.Int(2),\n\t\t),\n\t)\n\n\t{\n\t\t// unsub the rest\n\t\tmustDo(t, c,\n\t\t\t\"UNSUBSCRIBE\", \"event4\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"unsubscribe\"),\n\t\t\t\tproto.String(\"event4\"),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"UNSUBSCRIBE\", \"event5\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"unsubscribe\"),\n\t\t\t\tproto.String(\"event5\"),\n\t\t\t\tproto.Int(0),\n\t\t\t),\n\t\t)\n\t}\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"UNSUBSCRIBE\", \"q1\",\n\t\t\tproto.Push(\n\t\t\t\tproto.String(\"unsubscribe\"),\n\t\t\t\tproto.String(\"q1\"),\n\t\t\t\tproto.Int(0),\n\t\t\t),\n\t\t)\n\t})\n}\n\nfunc TestUnsubscribeEmpty(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"UNSUBSCRIBE\",\n\t\tproto.Array(\n\t\t\tproto.String(\"unsubscribe\"),\n\t\t\tproto.Nil,\n\t\t\tproto.Int(0),\n\t\t),\n\t)\n}\n\nfunc TestPsubscribe(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"PSUBSCRIBE\", \"event1\",\n\t\tproto.Array(proto.String(\"psubscribe\"), proto.String(\"event1\"), proto.Int(1)),\n\t)\n\n\tmustDo(t, c,\n\t\t\"PSUBSCRIBE\", \"event2?\",\n\t\tproto.Array(proto.String(\"psubscribe\"), proto.String(\"event2?\"), proto.Int(2)),\n\t)\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"PSUBSCRIBE\", \"event3*\", \"event4[abc]\",\n\t\t\tproto.Array(proto.String(\"psubscribe\"), proto.String(\"event3*\"), proto.Int(3)),\n\t\t)\n\t\tmustRead(t, c,\n\t\t\tproto.Array(proto.String(\"psubscribe\"), proto.String(\"event4[abc]\"), proto.Int(4)),\n\t\t)\n\t}\n\n\tmustDo(t, c,\n\t\t\"PSUBSCRIBE\", \"event5[]\",\n\t\tproto.Array(proto.String(\"psubscribe\"), proto.String(\"event5[]\"), proto.Int(5)),\n\t)\n\n\t{\n\t\t// publish some things!\n\t\tn := s.Publish(\"event4b\", \"hello 4b!\")\n\t\tequals(t, 1, n)\n\n\t\tn = s.Publish(\"event4d\", \"hello 4d?\")\n\t\tequals(t, 0, n)\n\n\t\tmustRead(t, c,\n\t\t\tproto.Strings(\"pmessage\", \"event4[abc]\", \"event4b\", \"hello 4b!\"),\n\t\t)\n\t}\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"PSUBSCRIBE\", \"q1\",\n\t\t\tproto.Push(\n\t\t\t\tproto.String(\"psubscribe\"),\n\t\t\t\tproto.String(\"q1\"),\n\t\t\t\tproto.Int(6),\n\t\t\t),\n\t\t)\n\t})\n}\n\nfunc TestPunsubscribe(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"PSUBSCRIBE\", \"event1\", \"event2?\", \"event3*\", \"event4[abc]\", \"event5[]\",\n\t\tproto.Array(\n\t\t\tproto.String(\"psubscribe\"),\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\tmustRead(t, c, proto.Array(proto.String(\"psubscribe\"), proto.String(\"event2?\"), proto.Int(2)))\n\tmustRead(t, c, proto.Array(proto.String(\"psubscribe\"), proto.String(\"event3*\"), proto.Int(3)))\n\tmustRead(t, c, proto.Array(proto.String(\"psubscribe\"), proto.String(\"event4[abc]\"), proto.Int(4)))\n\tmustRead(t, c, proto.Array(proto.String(\"psubscribe\"), proto.String(\"event5[]\"), proto.Int(5)))\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"PUNSUBSCRIBE\", \"event1\", \"event2?\",\n\t\t\tproto.Array(proto.String(\"punsubscribe\"), proto.String(\"event1\"), proto.Int(4)),\n\t\t)\n\t\tmustRead(t, c,\n\t\t\tproto.Array(proto.String(\"punsubscribe\"), proto.String(\"event2?\"), proto.Int(3)),\n\t\t)\n\t}\n\n\t// punsub the rest\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"PUNSUBSCRIBE\",\n\t\t\tproto.Array(proto.String(\"punsubscribe\"), proto.String(\"event3*\"), proto.Int(2)),\n\t\t)\n\t\tmustRead(t, c,\n\t\t\tproto.Array(proto.String(\"punsubscribe\"), proto.String(\"event4[abc]\"), proto.Int(1)),\n\t\t)\n\t\tmustRead(t, c,\n\t\t\tproto.Array(proto.String(\"punsubscribe\"), proto.String(\"event5[]\"), proto.Int(0)),\n\t\t)\n\t}\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"PUNSUBSCRIBE\", \"q1\",\n\t\t\tproto.Push(\n\t\t\t\tproto.String(\"punsubscribe\"),\n\t\t\t\tproto.String(\"q1\"),\n\t\t\t\tproto.Int(0),\n\t\t\t),\n\t\t)\n\t})\n}\n\nfunc TestPunsubscribeEmpty(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"PUNSUBSCRIBE\",\n\t\tproto.Array(\n\t\t\tproto.String(\"punsubscribe\"),\n\t\t\tproto.Nil,\n\t\t\tproto.Int(0),\n\t\t),\n\t)\n}\n\nfunc TestPublishMode(t *testing.T) {\n\t// only pubsub related commands should be accepted while there are\n\t// subscriptions.\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"birds\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"birds\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SET\", \"foo\", \"bar\",\n\t\tproto.Error(\"ERR Can't execute 'set': only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT are allowed in this context\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"UNSUBSCRIBE\", \"birds\",\n\t\tproto.Array(\n\t\t\tproto.String(\"unsubscribe\"),\n\t\t\tproto.String(\"birds\"),\n\t\t\tproto.Int(0),\n\t\t),\n\t)\n\n\t// no subs left. All should be fine now.\n\tmustOK(t, c,\n\t\t\"SET\", \"foo\", \"bar\",\n\t)\n}\n\nfunc TestPublish(t *testing.T) {\n\ts := RunT(t)\n\tc1, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c1.Close()\n\tc2, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c2.Close()\n\n\tmustDo(t, c2,\n\t\t\"SUBSCRIBE\", \"event1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\n\t{\n\t\tmust1(t, c1,\n\t\t\t\"PUBLISH\", \"event1\", \"message2\",\n\t\t)\n\t\tmustRead(t, c2,\n\t\t\tproto.Strings(\"message\", \"event1\", \"message2\"),\n\t\t)\n\t}\n\n\t// direct access\n\t{\n\t\tequals(t, 1, s.Publish(\"event1\", \"message3\"))\n\n\t\tmustRead(t, c2,\n\t\t\tproto.Strings(\"message\", \"event1\", \"message3\"),\n\t\t)\n\t}\n\n\t// Wrong usage\n\tmustDo(t, c2,\n\t\t\"PUBLISH\", \"foo\", \"bar\",\n\t\tproto.Error(\"ERR Can't execute 'publish': only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT are allowed in this context\"),\n\t)\n}\n\nfunc TestPublishMix(t *testing.T) {\n\t// SUBSCRIBE and PSUBSCRIBE\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"c1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"c1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"PSUBSCRIBE\", \"c1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"psubscribe\"),\n\t\t\tproto.String(\"c1\"),\n\t\t\tproto.Int(2),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\", \"c2\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"c2\"),\n\t\t\tproto.Int(3),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"PUNSUBSCRIBE\", \"c1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"punsubscribe\"),\n\t\t\tproto.String(\"c1\"),\n\t\t\tproto.Int(2),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"UNSUBSCRIBE\", \"c1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"unsubscribe\"),\n\t\t\tproto.String(\"c1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n}\n\nfunc TestPubsubChannels(t *testing.T) {\n\ts := RunT(t)\n\tc1, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c1.Close()\n\tc2, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c2.Close()\n\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"CHANNELS\",\n\t\tproto.Strings(),\n\t)\n\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"CHANNELS\", \"event1[abc]\",\n\t\tproto.Strings(),\n\t)\n\n\tmustDo(t, c2,\n\t\t\"SUBSCRIBE\", \"event1\", \"event1b\", \"event1c\",\n\t\tproto.Array(\n\t\t\tproto.String(\"subscribe\"),\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\tmustRead(t, c2, proto.Array(proto.String(\"subscribe\"), proto.String(\"event1b\"), proto.Int(2)))\n\tmustRead(t, c2, proto.Array(proto.String(\"subscribe\"), proto.String(\"event1c\"), proto.Int(3)))\n\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"CHANNELS\",\n\t\tproto.Strings(\"event1\", \"event1b\", \"event1c\"),\n\t)\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"CHANNELS\", \"event1b\",\n\t\tproto.Strings(\"event1b\"),\n\t)\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"CHANNELS\", \"event1[abc]\",\n\t\tproto.Strings(\"event1b\", \"event1c\"),\n\t)\n\n\t// workaround to make sure c2 stays alive; likely a go1.12-ism\n\tmustDo(t, c1, \"PING\", proto.Inline(\"PONG\"))\n\tmustDo(t, c2, \"PING\", \"foo\", proto.Strings(\"pong\", \"foo\"))\n}\n\nfunc TestPubsubNumsub(t *testing.T) {\n\ts := RunT(t)\n\tc1, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c1.Close()\n\tc2, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c2.Close()\n\n\tmustDo(t, c2,\n\t\t\"SUBSCRIBE\", \"event1\", \"event2\", \"event3\",\n\t\tproto.Array(proto.String(\"subscribe\"), proto.String(\"event1\"), proto.Int(1)),\n\t)\n\tmustRead(t, c2, proto.Array(proto.String(\"subscribe\"), proto.String(\"event2\"), proto.Int(2)))\n\tmustRead(t, c2, proto.Array(proto.String(\"subscribe\"), proto.String(\"event3\"), proto.Int(3)))\n\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"NUMSUB\",\n\t\tproto.Strings(),\n\t)\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"NUMSUB\", \"event1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"event1\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\tmustDo(t, c1,\n\t\t\"PUBSUB\", \"NUMSUB\", \"event12\", \"event3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"event12\"),\n\t\t\tproto.Int(0),\n\t\t\tproto.String(\"event3\"),\n\t\t\tproto.Int(1),\n\t\t),\n\t)\n\n}\n\nfunc TestPubsubNumpat(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmust0(t, c,\n\t\t\"PUBSUB\", \"NUMPAT\",\n\t)\n\n\tequals(t, 0, s.PubSubNumPat())\n}\n\nfunc TestPubSubBadArgs(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"SUBSCRIBE\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'subscribe' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PSUBSCRIBE\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'psubscribe' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PUBLISH\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'publish' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PUBLISH\", \"event1\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'publish' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PUBLISH\", \"event1\", \"message2\", \"message3\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'publish' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PUBSUB\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'pubsub' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PUBSUB\", \"FOOBAR\",\n\t\tproto.Error(\"ERR unknown subcommand 'FOOBAR'. Try PUBSUB HELP.\"),\n\t)\n\tmustDo(t, c,\n\t\t\"PUBSUB\", \"CHANNELS\", \"FOOBAR1\", \"FOOBAR2\",\n\t\tproto.Error(\"ERR unknown subcommand or wrong number of arguments for 'CHANNELS'. Try PUBSUB HELP.\"),\n\t)\n}\n"
        },
        {
          "name": "cmd_scripting.go",
          "type": "blob",
          "size": 7.1455078125,
          "content": "package miniredis\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\n\tluajson \"github.com/alicebob/gopher-json\"\n\tlua \"github.com/yuin/gopher-lua\"\n\t\"github.com/yuin/gopher-lua/parse\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nfunc commandsScripting(m *Miniredis) {\n\tm.srv.Register(\"EVAL\", m.cmdEval)\n\tm.srv.Register(\"EVALSHA\", m.cmdEvalsha)\n\tm.srv.Register(\"SCRIPT\", m.cmdScript)\n}\n\nvar (\n\tparsedScripts = sync.Map{}\n)\n\n// Execute lua. Needs to run m.Lock()ed, from within withTx().\n// Returns true if the lua was OK (and hence should be cached).\nfunc (m *Miniredis) runLuaScript(c *server.Peer, sha, script string, args []string) bool {\n\tl := lua.NewState(lua.Options{SkipOpenLibs: true})\n\tdefer l.Close()\n\n\t// Taken from the go-lua manual\n\tfor _, pair := range []struct {\n\t\tn string\n\t\tf lua.LGFunction\n\t}{\n\t\t{lua.LoadLibName, lua.OpenPackage},\n\t\t{lua.BaseLibName, lua.OpenBase},\n\t\t{lua.CoroutineLibName, lua.OpenCoroutine},\n\t\t{lua.TabLibName, lua.OpenTable},\n\t\t{lua.StringLibName, lua.OpenString},\n\t\t{lua.MathLibName, lua.OpenMath},\n\t\t{lua.DebugLibName, lua.OpenDebug},\n\t} {\n\t\tif err := l.CallByParam(lua.P{\n\t\t\tFn:      l.NewFunction(pair.f),\n\t\t\tNRet:    0,\n\t\t\tProtect: true,\n\t\t}, lua.LString(pair.n)); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tluajson.Preload(l)\n\trequireGlobal(l, \"cjson\", \"json\")\n\n\t// set global variable KEYS\n\tkeysTable := l.NewTable()\n\tkeysS, args := args[0], args[1:]\n\tkeysLen, err := strconv.Atoi(keysS)\n\tif err != nil {\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn false\n\t}\n\tif keysLen < 0 {\n\t\tc.WriteError(msgNegativeKeysNumber)\n\t\treturn false\n\t}\n\tif keysLen > len(args) {\n\t\tc.WriteError(msgInvalidKeysNumber)\n\t\treturn false\n\t}\n\tkeys, args := args[:keysLen], args[keysLen:]\n\tfor i, k := range keys {\n\t\tl.RawSet(keysTable, lua.LNumber(i+1), lua.LString(k))\n\t}\n\tl.SetGlobal(\"KEYS\", keysTable)\n\n\targvTable := l.NewTable()\n\tfor i, a := range args {\n\t\tl.RawSet(argvTable, lua.LNumber(i+1), lua.LString(a))\n\t}\n\tl.SetGlobal(\"ARGV\", argvTable)\n\n\tredisFuncs, redisConstants := mkLua(m.srv, c, sha)\n\t// Register command handlers\n\tl.Push(l.NewFunction(func(l *lua.LState) int {\n\t\tmod := l.RegisterModule(\"redis\", redisFuncs).(*lua.LTable)\n\t\tfor k, v := range redisConstants {\n\t\t\tmod.RawSetString(k, v)\n\t\t}\n\t\tl.Push(mod)\n\t\treturn 1\n\t}))\n\n\t_ = doScript(l, protectGlobals)\n\n\tl.Push(lua.LString(\"redis\"))\n\tl.Call(1, 0)\n\n\tif err := doScript(l, script); err != nil {\n\t\tc.WriteError(err.Error())\n\t\treturn false\n\t}\n\n\tluaToRedis(l, c, l.Get(1))\n\treturn true\n}\n\n// doScript pre-compiiles the given script into a Lua prototype,\n// then executes the pre-compiled function against the given lua state.\n//\n// This is thread-safe.\nfunc doScript(l *lua.LState, script string) error {\n\tproto, err := compile(script)\n\tif err != nil {\n\t\treturn fmt.Errorf(errLuaParseError(err))\n\t}\n\n\tlfunc := l.NewFunctionFromProto(proto)\n\tl.Push(lfunc)\n\tif err := l.PCall(0, lua.MultRet, nil); err != nil {\n\t\t// ensure we wrap with the correct format.\n\t\treturn fmt.Errorf(errLuaParseError(err))\n\t}\n\n\treturn nil\n}\n\nfunc compile(script string) (*lua.FunctionProto, error) {\n\tif val, ok := parsedScripts.Load(script); ok {\n\t\treturn val.(*lua.FunctionProto), nil\n\t}\n\tchunk, err := parse.Parse(strings.NewReader(script), \"<string>\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tproto, err := lua.Compile(chunk, \"\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparsedScripts.Store(script, proto)\n\treturn proto, nil\n}\n\nfunc (m *Miniredis) cmdEval(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\tscript, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tsha := sha1Hex(script)\n\t\tok := m.runLuaScript(c, sha, script, args)\n\t\tif ok {\n\t\t\tm.scripts[sha] = script\n\t\t}\n\t})\n}\n\nfunc (m *Miniredis) cmdEvalsha(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\tsha, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tscript, ok := m.scripts[sha]\n\t\tif !ok {\n\t\t\tc.WriteError(msgNoScriptFound)\n\t\t\treturn\n\t\t}\n\n\t\tm.runLuaScript(c, sha, script, args)\n\t})\n}\n\nfunc (m *Miniredis) cmdScript(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tsubcmd string\n\t\tscript string\n\t}\n\n\topts.subcmd, args = args[0], args[1:]\n\n\tswitch strings.ToLower(opts.subcmd) {\n\tcase \"load\":\n\t\tif len(args) != 1 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(fmt.Sprintf(msgFScriptUsage, \"LOAD\"))\n\t\t\treturn\n\t\t}\n\t\topts.script = args[0]\n\tcase \"exists\":\n\t\tif len(args) == 0 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(\"script|exists\"))\n\t\t\treturn\n\t\t}\n\tcase \"flush\":\n\t\tif len(args) == 1 {\n\t\t\tswitch strings.ToUpper(args[0]) {\n\t\t\tcase \"SYNC\", \"ASYNC\":\n\t\t\t\targs = args[1:]\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t\tif len(args) != 0 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgScriptFlush)\n\t\t\treturn\n\t\t}\n\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(msgFScriptUsageSimple, strings.ToUpper(opts.subcmd)))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tswitch strings.ToLower(opts.subcmd) {\n\t\tcase \"load\":\n\t\t\tif _, err := parse.Parse(strings.NewReader(opts.script), \"user_script\"); err != nil {\n\t\t\t\tc.WriteError(errLuaParseError(err))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsha := sha1Hex(opts.script)\n\t\t\tm.scripts[sha] = opts.script\n\t\t\tc.WriteBulk(sha)\n\n\t\tcase \"exists\":\n\t\t\tc.WriteLen(len(args))\n\t\t\tfor _, arg := range args {\n\t\t\t\tif _, ok := m.scripts[arg]; ok {\n\t\t\t\t\tc.WriteInt(1)\n\t\t\t\t} else {\n\t\t\t\t\tc.WriteInt(0)\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase \"flush\":\n\t\t\tm.scripts = map[string]string{}\n\t\t\tc.WriteOK()\n\n\t\t}\n\t})\n}\n\nfunc sha1Hex(s string) string {\n\th := sha1.New()\n\tio.WriteString(h, s)\n\treturn hex.EncodeToString(h.Sum(nil))\n}\n\n// requireGlobal imports module modName into the global namespace with the\n// identifier id.  panics if an error results from the function execution\nfunc requireGlobal(l *lua.LState, id, modName string) {\n\tif err := l.CallByParam(lua.P{\n\t\tFn:      l.GetGlobal(\"require\"),\n\t\tNRet:    1,\n\t\tProtect: true,\n\t}, lua.LString(modName)); err != nil {\n\t\tpanic(err)\n\t}\n\tmod := l.Get(-1)\n\tl.Pop(1)\n\n\tl.SetGlobal(id, mod)\n}\n\n// the following script protects globals\n// it is based on:  http://metalua.luaforge.net/src/lib/strict.lua.html\nvar protectGlobals = `\nlocal dbg=debug\nlocal mt = {}\nsetmetatable(_G, mt)\nmt.__newindex = function (t, n, v)\n  if dbg.getinfo(2) then\n    local w = dbg.getinfo(2, \"S\").what\n    if w ~= \"C\" then\n      error(\"Script attempted to create global variable '\"..tostring(n)..\"'\", 2)\n    end\n  end\n  rawset(t, n, v)\nend\nmt.__index = function (t, n)\n  if dbg.getinfo(2) and dbg.getinfo(2, \"S\").what ~= \"C\" then\n    error(\"Script attempted to access nonexistent global variable '\"..tostring(n)..\"'\", 2)\n  end\n  return rawget(t, n)\nend\ndebug = nil\n\n`\n"
        },
        {
          "name": "cmd_scripting_test.go",
          "type": "blob",
          "size": 11.54296875,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestEval(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 42\", \"0\",\n\t\tproto.Int(42),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {KEYS[1], ARGV[1]}\", \"1\", \"key1\", \"key2\",\n\t\tproto.Strings(\"key1\", \"key2\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {ARGV[1]}\", \"0\", \"key1\",\n\t\tproto.Strings(\"key1\"),\n\t)\n\n\t// Invalid args\n\tmustDo(t, c,\n\t\t\"EVAL\", \"42\", \"0\",\n\t\tproto.Error(\"ERR Error compiling script (new function): <string> line:1(column:2) near '42':   syntax error \"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 42\",\n\t\tproto.Error(errWrongNumber(\"eval\")),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 42\", \"1\",\n\t\tproto.Error(msgInvalidKeysNumber),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 42\", \"-1\",\n\t\tproto.Error(msgNegativeKeysNumber),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 42\", \"letter\",\n\t\tproto.Error(msgInvalidInt),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"[\", \"0\",\n\t\tproto.Error(\"ERR Error compiling script (new function): <string> line:1(column:1) near '[':   syntax error \"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"os.exit(42)\",\n\t\tproto.Error(errWrongNumber(\"eval\")),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", `return string.gsub(\"foo\", \"o\", \"a\")`,\n\t\tproto.Error(errWrongNumber(\"eval\")),\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", \"return someGlobal\", \"0\",\n\t\t\"Script attempted to access nonexistent global variable 'someGlobal'\",\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", \"someGlobal = 5\", \"0\",\n\t\t\"Script attempted to create global variable 'someGlobal'\",\n\t)\n\n\tt.Run(\"bigger float value\", func(t *testing.T) {\n\t\tmust0(t, c,\n\t\t\t\"EVAL\", \"return redis.call('expire','foo', 999999)\", \"0\",\n\t\t)\n\t\tmust0(t, c,\n\t\t\t\"EVAL\", \"return redis.call('expire','foo',1000000)\", \"0\",\n\t\t)\n\t})\n}\n\nfunc TestEvalCall(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", \"redis.call()\", \"0\",\n\t\t\"Error compiling script\",\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", \"redis.call({})\", \"0\",\n\t\t\"Error compiling script\",\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", \"redis.call(1)\", \"0\",\n\t\t\"Error compiling script\",\n\t)\n}\n\nfunc TestScript(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tvar (\n\t\tscript1sha = \"a42059b356c875f0717db19a51f6aaca9ae659ea\"\n\t\tscript2sha = \"1fa00e76656cc152ad327c13fe365858fd7be306\" // \"return 42\"\n\t)\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"LOAD\", \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n\t\tproto.String(script1sha),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"LOAD\", \"return 42\",\n\t\tproto.String(script2sha),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"EXISTS\", script1sha, script2sha, \"invalid sha\",\n\t\tproto.Array(proto.Int(1), proto.Int(1), proto.Int(0)),\n\t)\n\n\tmustOK(t, c, \"SCRIPT\", \"FLUSH\")\n\tmustOK(t, c, \"SCRIPT\", \"FLUSH\", \"async\")\n\tmustOK(t, c, \"SCRIPT\", \"FLUSH\", \"sync\")\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"EXISTS\", script1sha,\n\t\tproto.Array(proto.Int(0)),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"EXISTS\",\n\t\tproto.Error(errWrongNumber(\"script|exists\")),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\",\n\t\tproto.Error(errWrongNumber(\"script\")),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"LOAD\",\n\t\tproto.Error(\"ERR unknown subcommand or wrong number of arguments for 'LOAD'. Try SCRIPT HELP.\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"LOAD\", \"return 42\", \"FOO\",\n\t\tproto.Error(\"ERR unknown subcommand or wrong number of arguments for 'LOAD'. Try SCRIPT HELP.\"),\n\t)\n\n\tmustContain(t, c,\n\t\t\"SCRIPT\", \"LOAD\", \"[\",\n\t\t\"Error compiling script\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"FLUSH\", \"1\",\n\t\tproto.Error(\"ERR SCRIPT FLUSH only support SYNC|ASYNC option\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"FOO\",\n\t\tproto.Error(\"ERR unknown subcommand 'FOO'. Try SCRIPT HELP.\"),\n\t)\n}\n\nfunc TestCJSON(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", `return cjson.decode('{\"id\":\"foo\"}')['id']`, \"0\",\n\t\tproto.String(\"foo\"),\n\t)\n\tmustDo(t, c,\n\t\t\"EVAL\", `return cjson.encode({foo=42})`, \"0\",\n\t\tproto.String(`{\"foo\":42}`),\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", `redis.encode()`, \"0\",\n\t\t\"Error compiling script\",\n\t)\n\tmustContain(t, c,\n\t\t\"EVAL\", `redis.encode(\"1\", \"2\")`, \"0\",\n\t\t\"Error compiling script\",\n\t)\n\tmustContain(t, c,\n\t\t\"EVAL\", `redis.decode()`, \"0\",\n\t\t\"Error compiling script\",\n\t)\n\tmustContain(t, c,\n\t\t\"EVAL\", `redis.decode(\"{\")`, \"0\",\n\t\t\"Error compiling script\",\n\t)\n\tmustContain(t, c,\n\t\t\"EVAL\", `redis.decode(\"1\", \"2\")`, \"0\",\n\t\t\"Error compiling script\",\n\t)\n}\n\nfunc TestLog(t *testing.T) {\n\t_, c := runWithClient(t)\n\tmustNil(t, c,\n\t\t\"EVAL\", \"redis.log(redis.LOG_NOTICE, 'hello')\", \"0\")\n}\n\nfunc TestSha1Hex(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\ttest1 := func(val string, want string) {\n\t\tt.Helper()\n\t\tmustDo(t, c,\n\t\t\t\"EVAL\", \"return redis.sha1hex(ARGV[1])\", \"0\", val,\n\t\t\tproto.String(want),\n\t\t)\n\t}\n\ttest1(\"foo\", \"0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33\")\n\ttest1(\"bar\", \"62cdb7020ff920e5aa642c3d4066950dd1f01f4d\")\n\ttest1(\"0\", \"b6589fc6ab0dc82cf12099d1c2d40ab994e8410c\")\n\n\ttest2 := func(eval, want string) {\n\t\tt.Helper()\n\t\tmustDo(t, c,\n\t\t\t\"EVAL\", eval, \"0\",\n\t\t\tproto.String(want),\n\t\t)\n\t}\n\ttest2(\"return redis.sha1hex({})\", \"da39a3ee5e6b4b0d3255bfef95601890afd80709\")\n\ttest2(\"return redis.sha1hex(nil)\", \"da39a3ee5e6b4b0d3255bfef95601890afd80709\")\n\ttest2(\"return redis.sha1hex(42)\", \"92cfceb39d57d914ed8b14d0e37643de0797ae56\")\n\n\tmustContain(t, c,\n\t\t\"EVAL\", \"redis.sha1hex()\", \"0\",\n\t\t\"wrong number of arguments\",\n\t)\n}\n\nfunc TestEvalsha(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tscript1sha := \"bfbf458525d6a0b19200bfd6db3af481156b367b\"\n\tmustDo(t, c,\n\t\t\"SCRIPT\", \"LOAD\", \"return {KEYS[1],ARGV[1]}\",\n\t\tproto.String(script1sha),\n\t)\n\tmustDo(t, c,\n\t\t\"EVALSHA\", script1sha, \"1\", \"key1\", \"key2\",\n\t\tproto.Strings(\"key1\", \"key2\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\",\n\t\tproto.Error(errWrongNumber(\"evalsha\")),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\", \"foo\",\n\t\tproto.Error(errWrongNumber(\"evalsha\")),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\", \"foo\", \"0\",\n\t\tproto.Error(msgNoScriptFound),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\", script1sha, script1sha,\n\t\tproto.Error(msgInvalidInt),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\", script1sha, \"-1\",\n\t\tproto.Error(msgNegativeKeysNumber),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\", script1sha, \"1\",\n\t\tproto.Error(msgInvalidKeysNumber),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVALSHA\", \"foo\", \"1\", \"bar\",\n\t\tproto.Error(msgNoScriptFound),\n\t)\n}\n\nfunc TestCmdEvalReply(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t// return nil\n\tmustNil(t, c,\n\t\t\"EVAL\", \"\", \"0\",\n\t)\n\t// return boolean true\n\tmust1(t, c,\n\t\t\"EVAL\", \"return true\", \"0\",\n\t)\n\t// return boolean false\n\tmustNil(t, c,\n\t\t\"EVAL\", \"return false\", \"0\",\n\t)\n\t// return single number\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 10\", \"0\",\n\t\tproto.Int(10),\n\t)\n\t// return single float\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 12.345\", \"0\",\n\t\tproto.Int(12),\n\t)\n\t// return multiple numbers\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 10, 20\", \"0\",\n\t\tproto.Int(10),\n\t)\n\t// return single string\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 'test'\", \"0\",\n\t\tproto.String(\"test\"),\n\t)\n\t// return multiple strings\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return 'test1', 'test2'\", \"0\",\n\t\tproto.String(\"test1\"),\n\t)\n\t// return single table multiple integer\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {10, 20}\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.Int(10),\n\t\t\tproto.Int(20),\n\t\t),\n\t)\n\t// return single table multiple string\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {'test1', 'test2'}\", \"0\",\n\t\tproto.Strings(\"test1\", \"test2\"),\n\t)\n\t// return nested table\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {10, 20, {30, 40}}\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.Int(10),\n\t\t\tproto.Int(20),\n\t\t\tproto.Ints(30, 40),\n\t\t),\n\t)\n\t// return combination table\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {10, 20, {30, 'test', true, 40}, false}\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.Int(10),\n\t\t\tproto.Int(20),\n\t\t\tproto.Array(\n\t\t\t\tproto.Int(30),\n\t\t\t\tproto.String(\"test\"),\n\t\t\t\tproto.Int(1),\n\t\t\t\tproto.Int(40),\n\t\t\t),\n\t\t\tproto.Nil,\n\t\t),\n\t)\n\t// KEYS and ARGV\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}\",\n\t\t\"2\", \"key1\", \"key2\", \"first\", \"second\",\n\t\tproto.Strings(\n\t\t\t\"key1\",\n\t\t\t\"key2\",\n\t\t\t\"first\",\n\t\t\t\"second\",\n\t\t),\n\t)\n\n\tmustOK(t, c,\n\t\t\"EVAL\", `return redis.call(\"XGROUP\", \"CREATE\", KEYS[1], ARGV[1], \"$\", \"MKSTREAM\")`,\n\t\t\"1\", \"stream\", \"group\",\n\t)\n\tmustDo(t, c,\n\t\t\"EVAL\", `return redis.call(\"XPENDING\", KEYS[1], ARGV[1], \"-\", \"+\", 1, ARGV[2])`,\n\t\t\"1\", \"stream\", \"group\", \"consumer\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", `return {err=\"broken\"}`, \"0\",\n\t\tproto.Error(\"broken\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", `return redis.error_reply(\"broken\")`, \"0\",\n\t\tproto.Error(\"ERR broken\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", `return {ok=\"good\"}`, \"0\",\n\t\tproto.Inline(\"good\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", `return redis.status_reply(\"good\")`, \"0\",\n\t\tproto.Inline(\"good\"),\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", `return redis.error_reply()`, \"0\",\n\t\t\"wrong number or type of arguments\",\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", `return redis.error_reply(1)`, \"0\",\n\t\t\"wrong number or type of arguments\",\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", `return redis.status_reply()`, \"0\",\n\t\t\"wrong number or type of arguments\",\n\t)\n\n\tmustContain(t, c,\n\t\t\"EVAL\", `return redis.status_reply(1)`, \"0\",\n\t\t\"wrong number or type of arguments\",\n\t)\n}\n\nfunc TestCmdEvalResponse(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustOK(t, c,\n\t\t\"EVAL\", \"return redis.call('set','foo','bar')\", \"0\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return redis.call('get','foo')\", \"0\",\n\t\tproto.String(\"bar\"),\n\t)\n\tmustNil(t, c,\n\t\t\"EVAL\", \"return redis.call('get','nosuch')\", \"0\",\n\t)\n\n\tmustOK(t, c,\n\t\t\"EVAL\", \"return redis.call('HMSET', 'mkey', 'foo','bar','foo1','bar1')\", \"0\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return redis.call('HGETALL','mkey')\", \"0\",\n\t\tproto.Strings(\"foo\", \"bar\", \"foo1\", \"bar1\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return redis.call('HMGET','mkey', 'foo1')\", \"0\",\n\t\tproto.Strings(\"bar1\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return redis.call('HMGET','mkey', 'foo')\", \"0\",\n\t\tproto.Strings(\"bar\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EVAL\", \"return redis.call('HMGET','mkey', 'bad', 'key')\", \"0\",\n\t\tproto.Array(proto.Nil, proto.Nil),\n\t)\n}\n\nfunc TestCmdEvalAuth(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\teval := \"return redis.call('set','foo','bar')\"\n\n\ts.RequireAuth(\"123password\")\n\n\tmustDo(t, c,\n\t\t\"EVAL\", eval, \"0\",\n\t\tproto.Error(\"NOAUTH Authentication required.\"),\n\t)\n\n\tmustOK(t, c,\n\t\t\"AUTH\", \"123password\",\n\t)\n\n\tmustOK(t, c,\n\t\t\"EVAL\", eval, \"0\",\n\t)\n}\n\nfunc TestLuaReplicate(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tt.Run(\"replicate_commands\", func(t *testing.T) {\n\t\tmustNil(t, c,\n\t\t\t\"EVAL\", \"redis.replicate_commands()\", \"0\",\n\t\t)\n\t})\n\n\tt.Run(\"set_repl\", func(t *testing.T) {\n\t\tmustNil(t, c,\n\t\t\t\"EVAL\", \"redis.set_repl(redis.REPL_NONE)\", \"0\",\n\t\t)\n\t})\n}\n\nfunc TestLuaTX(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tt.Run(\"eval\", func(t *testing.T) {\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"EVAL\", \"return {ARGV[1]}\", \"0\", \"key1\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"EXEC\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Strings(\"key1\"), // EVAL\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"evalsha\", func(t *testing.T) {\n\t\tscript1sha := \"bfbf458525d6a0b19200bfd6db3af481156b367b\"\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCRIPT\", \"LOAD\", \"return {KEYS[1],ARGV[1]}\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"EVALSHA\", script1sha, \"1\", \"key1\", \"key2\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"EXEC\",\n\t\t\tproto.Array(\n\t\t\t\tproto.String(script1sha),      // SCRIPT\n\t\t\t\tproto.Strings(\"key1\", \"key2\"), // EVALSHA\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"compile\", func(t *testing.T) {\n\t\t// compiling is done inside the transaction\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"foo\", \"12\",\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCRIPT\", \"LOAD\", \"foobar\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GET\", \"foo\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"EXEC\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Error(\"ERR Error compiling script (new function): user_script at EOF:   parse error \"),\n\t\t\t\tproto.String(\"12\"),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"misc\", func(t *testing.T) {\n\t\t// misc SCRIPT subcommands\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCRIPT\", \"EXISTS\", \"123\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SCRIPT\", \"FLUSH\",\n\t\t\tproto.Inline(\"QUEUED\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"EXEC\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Ints(0),\n\t\t\t\tproto.Inline(\"OK\"),\n\t\t\t),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_server.go",
          "type": "blob",
          "size": 3.3916015625,
          "content": "// Commands from https://redis.io/commands#server\n\npackage miniredis\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n\t\"github.com/alicebob/miniredis/v2/size\"\n)\n\nfunc commandsServer(m *Miniredis) {\n\tm.srv.Register(\"COMMAND\", m.cmdCommand)\n\tm.srv.Register(\"DBSIZE\", m.cmdDbsize)\n\tm.srv.Register(\"FLUSHALL\", m.cmdFlushall)\n\tm.srv.Register(\"FLUSHDB\", m.cmdFlushdb)\n\tm.srv.Register(\"INFO\", m.cmdInfo)\n\tm.srv.Register(\"TIME\", m.cmdTime)\n\tm.srv.Register(\"MEMORY\", m.cmdMemory)\n}\n\n// MEMORY\nfunc (m *Miniredis) cmdMemory(c *server.Peer, cmd string, args []string) {\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tcmd, args := strings.ToLower(args[0]), args[1:]\n\t\tswitch cmd {\n\t\tcase \"usage\":\n\t\t\tif len(args) < 1 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(errWrongNumber(\"memory|usage\"))\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif len(args) > 1 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar (\n\t\t\t\tvalue interface{}\n\t\t\t\tok    bool\n\t\t\t)\n\t\t\tswitch db.keys[args[0]] {\n\t\t\tcase \"string\":\n\t\t\t\tvalue, ok = db.stringKeys[args[0]]\n\t\t\tcase \"set\":\n\t\t\t\tvalue, ok = db.setKeys[args[0]]\n\t\t\tcase \"hash\":\n\t\t\t\tvalue, ok = db.hashKeys[args[0]]\n\t\t\tcase \"list\":\n\t\t\t\tvalue, ok = db.listKeys[args[0]]\n\t\t\tcase \"hll\":\n\t\t\t\tvalue, ok = db.hllKeys[args[0]]\n\t\t\tcase \"zset\":\n\t\t\t\tvalue, ok = db.sortedsetKeys[args[0]]\n\t\t\tcase \"stream\":\n\t\t\t\tvalue, ok = db.streamKeys[args[0]]\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tc.WriteNull()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.WriteInt(size.Of(value))\n\t\tdefault:\n\t\t\tc.WriteError(fmt.Sprintf(msgMemorySubcommand, strings.ToUpper(cmd)))\n\t\t}\n\t})\n}\n\n// DBSIZE\nfunc (m *Miniredis) cmdDbsize(c *server.Peer, cmd string, args []string) {\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tc.WriteInt(len(db.keys))\n\t})\n}\n\n// FLUSHALL\nfunc (m *Miniredis) cmdFlushall(c *server.Peer, cmd string, args []string) {\n\tif len(args) > 0 && strings.ToLower(args[0]) == \"async\" {\n\t\targs = args[1:]\n\t}\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tm.flushAll()\n\t\tc.WriteOK()\n\t})\n}\n\n// FLUSHDB\nfunc (m *Miniredis) cmdFlushdb(c *server.Peer, cmd string, args []string) {\n\tif len(args) > 0 && strings.ToLower(args[0]) == \"async\" {\n\t\targs = args[1:]\n\t}\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tm.db(ctx.selectedDB).flush()\n\t\tc.WriteOK()\n\t})\n}\n\n// TIME\nfunc (m *Miniredis) cmdTime(c *server.Peer, cmd string, args []string) {\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tnow := m.effectiveNow()\n\t\tnanos := now.UnixNano()\n\t\tseconds := nanos / 1_000_000_000\n\t\tmicroseconds := (nanos / 1_000) % 1_000_000\n\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(strconv.FormatInt(seconds, 10))\n\t\tc.WriteBulk(strconv.FormatInt(microseconds, 10))\n\t})\n}\n"
        },
        {
          "name": "cmd_server_test.go",
          "type": "blob",
          "size": 2.2392578125,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test DBSIZE, FLUSHDB, and FLUSHALL.\nfunc TestCmdServer(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Set something\n\t{\n\t\ts.Set(\"aap\", \"niet\")\n\t\ts.Set(\"roos\", \"vuur\")\n\t\ts.DB(1).Set(\"noot\", \"mies\")\n\t}\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"DBSIZE\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"FLUSHDB\",\n\t\t)\n\t\tmust0(t, c,\n\t\t\t\"DBSIZE\",\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"SELECT\", \"1\",\n\t\t)\n\n\t\tmust1(t, c,\n\t\t\t\"DBSIZE\",\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"FLUSHALL\",\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"DBSIZE\",\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"SELECT\", \"4\",\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"DBSIZE\",\n\t\t)\n\t}\n\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"FLUSHDB\", \"ASYNC\",\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"FLUSHALL\", \"ASYNC\",\n\t\t)\n\t}\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"DBSIZE\", \"FOO\",\n\t\t\tproto.Error(errWrongNumber(\"dbsize\")),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"FLUSHDB\", \"FOO\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"FLUSHDB\", \"ASYNC\", \"FOO\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"FLUSHALL\", \"FOO\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"FLUSHALL\", \"ASYNC\", \"FOO\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"FLUSHALL\", \"ASYNC\", \"ASYNC\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t}\n}\n\n// Test TIME\nfunc TestCmdServerTime(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t_, err := c.Do(\"TIME\")\n\tok(t, err)\n\n\ts.SetTime(time.Unix(100, 123456789))\n\tmustDo(t, c,\n\t\t\"TIME\",\n\t\tproto.Strings(\"100\", \"123456\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"TIME\", \"FOO\",\n\t\tproto.Error(errWrongNumber(\"time\")),\n\t)\n}\n\n// Test Memory Usage\nfunc TestCmdServerMemoryUsage(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tc.Do(\"SET\", \"foo\", \"bar\")\n\tmustDo(t, c,\n\t\t\"PFADD\", \"h\", \"aap\", \"noot\", \"mies\",\n\t\tproto.Int(1),\n\t)\n\n\t// Intended only for having metrics not to be 1:1 Redis\n\tmustDo(t, c,\n\t\t\"MEMORY\", \"USAGE\", \"foo\",\n\t\tproto.Int(19), // normally, with Redis it should be 56 but we don't have the same overhead as Redis\n\t)\n\t// Intended only for having metrics not to be 1:1 Redis\n\tmustDo(t, c,\n\t\t\"MEMORY\", \"USAGE\", \"h\",\n\t\tproto.Int(124), // normally, with Redis it should be 56 but we don't have the same overhead as Redis\n\t)\n}\n\nfunc TestCmdServerMemoryUsageLowerCase(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tc.Do(\"SET\", \"foo\", \"bar\")\n\tmustDo(t, c,\n\t\t\"memory\", \"usage\", \"foo\",\n\t\tproto.Int(19),\n\t)\n}\n"
        },
        {
          "name": "cmd_set.go",
          "type": "blob",
          "size": 14.5693359375,
          "content": "// Commands from https://redis.io/commands#set\n\npackage miniredis\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsSet handles all set value operations.\nfunc commandsSet(m *Miniredis) {\n\tm.srv.Register(\"SADD\", m.cmdSadd)\n\tm.srv.Register(\"SCARD\", m.cmdScard)\n\tm.srv.Register(\"SDIFF\", m.cmdSdiff)\n\tm.srv.Register(\"SDIFFSTORE\", m.cmdSdiffstore)\n\tm.srv.Register(\"SINTERCARD\", m.cmdSintercard)\n\tm.srv.Register(\"SINTER\", m.cmdSinter)\n\tm.srv.Register(\"SINTERSTORE\", m.cmdSinterstore)\n\tm.srv.Register(\"SISMEMBER\", m.cmdSismember)\n\tm.srv.Register(\"SMEMBERS\", m.cmdSmembers)\n\tm.srv.Register(\"SMISMEMBER\", m.cmdSmismember)\n\tm.srv.Register(\"SMOVE\", m.cmdSmove)\n\tm.srv.Register(\"SPOP\", m.cmdSpop)\n\tm.srv.Register(\"SRANDMEMBER\", m.cmdSrandmember)\n\tm.srv.Register(\"SREM\", m.cmdSrem)\n\tm.srv.Register(\"SUNION\", m.cmdSunion)\n\tm.srv.Register(\"SUNIONSTORE\", m.cmdSunionstore)\n\tm.srv.Register(\"SSCAN\", m.cmdSscan)\n}\n\n// SADD\nfunc (m *Miniredis) cmdSadd(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, elems := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(key) && db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tadded := db.setAdd(key, elems...)\n\t\tc.WriteInt(added)\n\t})\n}\n\n// SCARD\nfunc (m *Miniredis) cmdScard(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.setMembers(key)\n\t\tc.WriteInt(len(members))\n\t})\n}\n\n// SDIFF\nfunc (m *Miniredis) cmdSdiff(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkeys := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tset, err := db.setDiff(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteSetLen(len(set))\n\t\tfor k := range set {\n\t\t\tc.WriteBulk(k)\n\t\t}\n\t})\n}\n\n// SDIFFSTORE\nfunc (m *Miniredis) cmdSdiffstore(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tdest, keys := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tset, err := db.setDiff(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tdb.del(dest, true)\n\t\tdb.setSet(dest, set)\n\t\tc.WriteInt(len(set))\n\t})\n}\n\n// SINTER\nfunc (m *Miniredis) cmdSinter(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkeys := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tset, err := db.setInter(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(set))\n\t\tfor k := range set {\n\t\t\tc.WriteBulk(k)\n\t\t}\n\t})\n}\n\n// SINTERSTORE\nfunc (m *Miniredis) cmdSinterstore(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tdest, keys := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tset, err := db.setInter(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tdb.del(dest, true)\n\t\tdb.setSet(dest, set)\n\t\tc.WriteInt(len(set))\n\t})\n}\n\n// SINTERCARD\nfunc (m *Miniredis) cmdSintercard(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkeys  []string\n\t\tlimit int\n\t}{}\n\n\tnumKeys, err := strconv.Atoi(args[0])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR numkeys should be greater than 0\")\n\t\treturn\n\t}\n\tif numKeys < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR numkeys should be greater than 0\")\n\t\treturn\n\t}\n\n\targs = args[1:]\n\tif len(args) < numKeys {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR Number of keys can't be greater than number of args\")\n\t\treturn\n\t}\n\topts.keys = args[:numKeys]\n\n\targs = args[numKeys:]\n\tif len(args) == 2 && strings.ToLower(args[0]) == \"limit\" {\n\t\tl, err := strconv.Atoi(args[1])\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\tif l < 0 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgLimitIsNegative)\n\t\t\treturn\n\t\t}\n\t\topts.limit = l\n\t} else if len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tcount, err := db.setIntercard(opts.keys, opts.limit)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(count)\n\t})\n}\n\n// SISMEMBER\nfunc (m *Miniredis) cmdSismember(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, value := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif db.setIsMember(key, value) {\n\t\t\tc.WriteInt(1)\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(0)\n\t})\n}\n\n// SMEMBERS\nfunc (m *Miniredis) cmdSmembers(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteSetLen(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.setMembers(key)\n\n\t\tc.WriteSetLen(len(members))\n\t\tfor _, elem := range members {\n\t\t\tc.WriteBulk(elem)\n\t\t}\n\t})\n}\n\n// SMISMEMBER\nfunc (m *Miniredis) cmdSmismember(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, values := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteLen(len(values))\n\t\t\tfor range values {\n\t\t\t\tc.WriteInt(0)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(values))\n\t\tfor _, value := range values {\n\t\t\tif db.setIsMember(key, value) {\n\t\t\t\tc.WriteInt(1)\n\t\t\t} else {\n\t\t\t\tc.WriteInt(0)\n\t\t\t}\n\t\t}\n\t\treturn\n\t})\n}\n\n// SMOVE\nfunc (m *Miniredis) cmdSmove(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tsrc, dst, member := args[0], args[1], args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(src) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(src) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif db.exists(dst) && db.t(dst) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif !db.setIsMember(src, member) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tdb.setRem(src, member)\n\t\tdb.setAdd(dst, member)\n\t\tc.WriteInt(1)\n\t})\n}\n\n// SPOP\nfunc (m *Miniredis) cmdSpop(c *server.Peer, cmd string, args []string) {\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\topts := struct {\n\t\tkey       string\n\t\twithCount bool\n\t\tcount     int\n\t}{\n\t\tcount: 1,\n\t}\n\topts.key, args = args[0], args[1:]\n\n\tif len(args) > 0 {\n\t\tv, err := strconv.Atoi(args[0])\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\tif v < 0 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgOutOfRange)\n\t\t\treturn\n\t\t}\n\t\topts.count = v\n\t\topts.withCount = true\n\t\targs = args[1:]\n\t}\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tif !opts.withCount {\n\t\t\t\tc.WriteNull()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.WriteLen(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tvar deleted []string\n\t\tmembers := db.setMembers(opts.key)\n\t\tfor i := 0; i < opts.count; i++ {\n\t\t\tif len(members) == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti := m.randIntn(len(members))\n\t\t\tmember := members[i]\n\t\t\tmembers = delElem(members, i)\n\t\t\tdb.setRem(opts.key, member)\n\t\t\tdeleted = append(deleted, member)\n\t\t}\n\t\t// without `count` return a single value\n\t\tif !opts.withCount {\n\t\t\tif len(deleted) == 0 {\n\t\t\t\tc.WriteNull()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.WriteBulk(deleted[0])\n\t\t\treturn\n\t\t}\n\t\t// with `count` return a list\n\t\tc.WriteLen(len(deleted))\n\t\tfor _, v := range deleted {\n\t\t\tc.WriteBulk(v)\n\t\t}\n\t})\n}\n\n// SRANDMEMBER\nfunc (m *Miniredis) cmdSrandmember(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif len(args) > 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\tcount := 0\n\twithCount := false\n\tif len(args) == 2 {\n\t\tvar err error\n\t\tcount, err = strconv.Atoi(args[1])\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\twithCount = true\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tif withCount {\n\t\t\t\tc.WriteLen(0)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.setMembers(key)\n\t\tif count < 0 {\n\t\t\t// Non-unique elements is allowed with negative count.\n\t\t\tc.WriteLen(-count)\n\t\t\tfor count != 0 {\n\t\t\t\tmember := members[m.randIntn(len(members))]\n\t\t\t\tc.WriteBulk(member)\n\t\t\t\tcount++\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\t// Must be unique elements.\n\t\tm.shuffle(members)\n\t\tif count > len(members) {\n\t\t\tcount = len(members)\n\t\t}\n\t\tif !withCount {\n\t\t\tc.WriteBulk(members[0])\n\t\t\treturn\n\t\t}\n\t\tc.WriteLen(count)\n\t\tfor i := range make([]struct{}, count) {\n\t\t\tc.WriteBulk(members[i])\n\t\t}\n\t})\n}\n\n// SREM\nfunc (m *Miniredis) cmdSrem(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, fields := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(db.setRem(key, fields...))\n\t})\n}\n\n// SUNION\nfunc (m *Miniredis) cmdSunion(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkeys := args\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tset, err := db.setUnion(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(set))\n\t\tfor k := range set {\n\t\t\tc.WriteBulk(k)\n\t\t}\n\t})\n}\n\n// SUNIONSTORE\nfunc (m *Miniredis) cmdSunionstore(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tdest, keys := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tset, err := db.setUnion(keys)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tdb.del(dest, true)\n\t\tdb.setSet(dest, set)\n\t\tc.WriteInt(len(set))\n\t})\n}\n\n// SSCAN\nfunc (m *Miniredis) cmdSscan(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey       string\n\t\tvalue     int\n\t\tcursor    int\n\t\tcount     int\n\t\twithMatch bool\n\t\tmatch     string\n\t}\n\n\topts.key = args[0]\n\tif ok := optIntErr(c, args[1], &opts.cursor, msgInvalidCursor); !ok {\n\t\treturn\n\t}\n\targs = args[2:]\n\n\t// MATCH and COUNT options\n\tfor len(args) > 0 {\n\t\tif strings.ToLower(args[0]) == \"count\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcount, err := strconv.Atoi(args[1])\n\t\t\tif err != nil || count < 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif count == 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.count = count\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tif strings.ToLower(args[0]) == \"match\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withMatch = true\n\t\t\topts.match = args[1]\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\t// return _all_ (matched) keys every time\n\t\tif db.exists(opts.key) && db.t(opts.key) != \"set\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\t\tmembers := db.setMembers(opts.key)\n\t\tif opts.withMatch {\n\t\t\tmembers, _ = matchKeys(members, opts.match)\n\t\t}\n\t\tlow := opts.cursor\n\t\thigh := low + opts.count\n\t\t// validate high is correct\n\t\tif high > len(members) || high == 0 {\n\t\t\thigh = len(members)\n\t\t}\n\t\tif opts.cursor > high {\n\t\t\t// invalid cursor\n\t\t\tc.WriteLen(2)\n\t\t\tc.WriteBulk(\"0\") // no next cursor\n\t\t\tc.WriteLen(0)    // no elements\n\t\t\treturn\n\t\t}\n\t\tcursorValue := low + opts.count\n\t\tif cursorValue > len(members) {\n\t\t\tcursorValue = 0 // no next cursor\n\t\t}\n\t\tmembers = members[low:high]\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(fmt.Sprintf(\"%d\", cursorValue))\n\t\tc.WriteLen(len(members))\n\t\tfor _, k := range members {\n\t\t\tc.WriteBulk(k)\n\t\t}\n\n\t})\n}\n\nfunc delElem(ls []string, i int) []string {\n\t// this swap+truncate is faster but changes behaviour:\n\t// ls[i] = ls[len(ls)-1]\n\t// ls = ls[:len(ls)-1]\n\t// so we do the dumb thing:\n\tls = append(ls[:i], ls[i+1:]...)\n\treturn ls\n}\n"
        },
        {
          "name": "cmd_set_test.go",
          "type": "blob",
          "size": 17.7783203125,
          "content": "package miniredis\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test SADD / SMEMBERS.\nfunc TestSadd(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SADD\", \"s\", \"aap\", \"noot\", \"mies\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmembers, err := s.Members(\"s\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"mies\", \"noot\"}, members)\n\n\t\tmustDo(t, c,\n\t\t\t\"SMEMBERS\", \"s\",\n\t\t\tproto.Strings(\"aap\", \"mies\", \"noot\"),\n\t\t)\n\t}\n\n\tmustDo(t, c,\n\t\t\"TYPE\", \"s\",\n\t\tproto.Inline(\"set\"),\n\t)\n\n\t// SMEMBERS on an nonexisting key\n\tmustDo(t, c,\n\t\t\"SMEMBERS\", \"nosuch\",\n\t\tproto.Strings(),\n\t)\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SADD\", \"s\", \"new\", \"noot\", \"mies\",\n\t\t\tproto.Int(1), // Only one new field.\n\t\t)\n\n\t\tmembers, err := s.Members(\"s\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\", \"mies\", \"new\", \"noot\"}, members)\n\t}\n\n\tt.Run(\"direct usage\", func(t *testing.T) {\n\t\tadded, err := s.SetAdd(\"s1\", \"aap\")\n\t\tok(t, err)\n\t\tequals(t, 1, added)\n\n\t\tmembers, err := s.Members(\"s1\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"aap\"}, members)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"SADD\", \"str\", \"hi\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMEMBERS\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\t// Wrong argument counts\n\t\tmustDo(t, c,\n\t\t\t\"SADD\",\n\t\t\tproto.Error(errWrongNumber(\"sadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SADD\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"sadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMEMBERS\",\n\t\t\tproto.Error(errWrongNumber(\"smembers\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMEMBERS\", \"set\", \"spurious\",\n\t\t\tproto.Error(errWrongNumber(\"smembers\")),\n\t\t)\n\t})\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c, \"SMEMBERS\", \"resp\", proto.Set())\n\t\tmustDo(t, c, \"SADD\", \"resp\", \"aap\", proto.Int(1))\n\t\tmustDo(t, c, \"SMEMBERS\", \"resp\", proto.StringSet(\"aap\"))\n\t})\n}\n\n// Test SISMEMBER\nfunc TestSismember(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s\", \"aap\", \"noot\", \"mies\")\n\n\t{\n\t\tmust1(t, c, \"SISMEMBER\", \"s\", \"aap\")\n\n\t\tmust0(t, c, \"SISMEMBER\", \"s\", \"nosuch\")\n\t}\n\n\t// a nonexisting key\n\tmust0(t, c, \"SISMEMBER\", \"nosuch\", \"nosuch\")\n\n\tt.Run(\"direct usage\", func(t *testing.T) {\n\t\tisMember, err := s.IsMember(\"s\", \"noot\")\n\t\tok(t, err)\n\t\tequals(t, true, isMember)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"SISMEMBER\", \"str\", \"foo\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SISMEMBER\",\n\t\t\tproto.Error(errWrongNumber(\"sismember\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SISMEMBER\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"sismember\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SISMEMBER\", \"set\", \"spurious\", \"args\",\n\t\t\tproto.Error(errWrongNumber(\"sismember\")),\n\t\t)\n\t})\n}\n\n// Test SMISMEMBER\nfunc TestSmismember(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s\", \"aap\", \"noot\", \"mies\")\n\n\tmustDo(t, c, \"SMISMEMBER\", \"s\", \"aap\", \"nosuch\", \"mies\", proto.Ints(1, 0, 1))\n\tmustDo(t, c, \"SMISMEMBER\", \"q\", \"aap\", \"nosuch\", \"mies\", proto.Ints(0, 0, 0))\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"SMISMEMBER\", \"str\", \"foo\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMISMEMBER\",\n\t\t\tproto.Error(errWrongNumber(\"smismember\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMISMEMBER\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"smismember\")),\n\t\t)\n\t})\n}\n\n// Test SREM\nfunc TestSrem(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s\", \"aap\", \"noot\", \"mies\", \"vuur\")\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SREM\", \"s\", \"aap\", \"noot\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmembers, err := s.Members(\"s\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"mies\", \"vuur\"}, members)\n\t}\n\n\t// a nonexisting key\n\tmust0(t, c,\n\t\t\"SREM\", \"s\", \"nosuch\",\n\t\tproto.Int(9),\n\t)\n\n\t// a nonexisting key\n\tmust0(t, c,\n\t\t\"SREM\", \"nosuch\", \"nosuch\",\n\t)\n\n\tt.Run(\"direct usage\", func(t *testing.T) {\n\t\tb, err := s.SRem(\"s\", \"mies\")\n\t\tok(t, err)\n\t\tequals(t, 1, b)\n\n\t\tmembers, err := s.Members(\"s\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"vuur\"}, members)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"SREM\", \"str\", \"value\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SREM\",\n\t\t\tproto.Error(errWrongNumber(\"srem\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SREM\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"srem\")),\n\t\t)\n\t})\n}\n\n// Test SMOVE\nfunc TestSmove(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s\", \"aap\", \"noot\")\n\n\t{\n\t\tmust1(t, c,\n\t\t\t\"SMOVE\", \"s\", \"s2\", \"aap\",\n\t\t)\n\n\t\tm, err := s.IsMember(\"s\", \"aap\")\n\t\tok(t, err)\n\t\tequals(t, false, m)\n\t\tm, err = s.IsMember(\"s2\", \"aap\")\n\t\tok(t, err)\n\t\tequals(t, true, m)\n\t}\n\n\t// Move away the last member\n\t{\n\t\tmust1(t, c,\n\t\t\t\"SMOVE\", \"s\", \"s2\", \"noot\",\n\t\t)\n\n\t\tequals(t, false, s.Exists(\"s\"))\n\n\t\tm, err := s.IsMember(\"s2\", \"noot\")\n\t\tok(t, err)\n\t\tequals(t, true, m)\n\t}\n\n\t// a nonexisting member\n\tmust0(t, c, \"SMOVE\", \"s\", \"s2\", \"nosuch\")\n\n\t// a nonexisting key\n\tmust0(t, c, \"SMOVE\", \"nosuch\", \"nosuch2\", \"nosuch\")\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\", \"str\", \"dst\", \"value\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\", \"s2\", \"str\", \"value\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\",\n\t\t\tproto.Error(errWrongNumber(\"smove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"smove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\", \"set\", \"set2\",\n\t\t\tproto.Error(errWrongNumber(\"smove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\", \"set\", \"set2\", \"spurious\", \"args\",\n\t\t\tproto.Error(errWrongNumber(\"smove\")),\n\t\t)\n\t})\n}\n\n// Test SPOP\nfunc TestSpop(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basics\", func(t *testing.T) {\n\t\ts.SetAdd(\"s\", \"aap\", \"noot\")\n\n\t\tres, err := c.Do(\"SPOP\", \"s\")\n\t\tok(t, err)\n\t\tassert(t, res == proto.String(\"aap\") || res == proto.String(\"noot\"), \"spop got something\")\n\n\t\tres, err = c.Do(\"SPOP\", \"s\")\n\t\tok(t, err)\n\t\tassert(t, res == proto.String(\"aap\") || res == proto.String(\"noot\"), \"spop got something\")\n\n\t\tassert(t, !s.Exists(\"s\"), \"all spopped away\")\n\t})\n\n\tt.Run(\"nonexisting key\", func(t *testing.T) {\n\t\tmustNil(t, c, \"SPOP\", \"nosuch\")\n\t})\n\n\tt.Run(\"various errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\",\n\t\t\tproto.Error(errWrongNumber(\"smove\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SMOVE\", \"chk\", \"set2\",\n\t\t\tproto.Error(errWrongNumber(\"smove\")),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"SPOP\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n\n\tt.Run(\"count argument\", func(t *testing.T) {\n\t\ts.Seed(42)\n\t\ts.SetAdd(\"s\", \"aap\", \"noot\", \"mies\", \"vuur\")\n\t\tmustDo(t, c,\n\t\t\t\"SPOP\", \"s\", \"2\",\n\t\t\tproto.Strings(\"mies\", \"vuur\"),\n\t\t)\n\t\tmembers, err := s.Members(\"s\")\n\t\tok(t, err)\n\t\tassert(t, len(members) == 2, \"SPOP s 2\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SPOP\", \"str\", \"-12\",\n\t\t\tproto.Error(msgOutOfRange),\n\t\t)\n\t})\n}\n\n// Test SRANDMEMBER\nfunc TestSrandmember(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s\", \"aap\", \"noot\", \"mies\")\n\n\ts.Seed(42)\n\t// No count\n\t{\n\t\tres, err := c.Do(\"SRANDMEMBER\", \"s\")\n\t\tok(t, err)\n\t\tassert(t, res == proto.String(\"aap\") ||\n\t\t\tres == proto.String(\"noot\") ||\n\t\t\tres == proto.String(\"mies\"),\n\t\t\t\"srandmember got something\",\n\t\t)\n\t}\n\n\t// Positive count\n\tmustDo(t, c,\n\t\t\"SRANDMEMBER\", \"s\", \"2\",\n\t\tproto.Strings(\"noot\", \"mies\"),\n\t)\n\n\t// Negative count\n\tmustDo(t, c,\n\t\t\"SRANDMEMBER\", \"s\", \"-2\",\n\t\tproto.Strings(\"aap\", \"mies\"),\n\t)\n\n\t// a nonexisting key\n\tmustNil(t, c,\n\t\t\"SRANDMEMBER\", \"nosuch\",\n\t)\n\n\t// a nonexisting key with count\n\tmustDo(t, c,\n\t\t\"SRANDMEMBER\", \"nosuch\", \"1\",\n\t\tproto.Strings(),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SRANDMEMBER\",\n\t\t\tproto.Error(errWrongNumber(\"srandmember\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SRANDMEMBER\", \"chk\", \"noint\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SRANDMEMBER\", \"chk\", \"1\", \"toomanu\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"SRANDMEMBER\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\ts.SetAdd(\"q\", \"aap\")\n\t\tmustDo(t, c,\n\t\t\t\"SRANDMEMBER\", \"q\",\n\t\t\tproto.String(\"aap\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SRANDMEMBER\", \"q\", \"1\",\n\t\t\tproto.Strings(\"aap\"),\n\t\t)\n\t})\n}\n\n// Test SDIFF\nfunc TestSdiff(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s1\", \"aap\", \"noot\", \"mies\")\n\ts.SetAdd(\"s2\", \"noot\", \"mies\", \"vuur\")\n\ts.SetAdd(\"s3\", \"aap\", \"mies\", \"wim\")\n\n\t// Simple case\n\tmustDo(t, c,\n\t\t\"SDIFF\", \"s1\", \"s2\",\n\t\tproto.Strings(\"aap\"),\n\t)\n\n\t// No other set\n\t{\n\t\tres, err := c.DoStrings(\"SDIFF\", \"s1\")\n\t\tok(t, err)\n\t\tsort.Strings(res)\n\t\tequals(t, []string{\"aap\", \"mies\", \"noot\"}, res)\n\t}\n\n\t// 3 sets\n\tmustDo(t, c,\n\t\t\"SDIFF\", \"s1\", \"s2\", \"s3\",\n\t\tproto.Strings(),\n\t)\n\n\t// A nonexisting key\n\tmustDo(t, c,\n\t\t\"SDIFF\", \"s9\",\n\t\tproto.Strings(),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SDIFF\",\n\t\t\tproto.Error(errWrongNumber(\"sdiff\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SDIFF\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SDIFF\", \"chk\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test SDIFFSTORE\nfunc TestSdiffstore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s1\", \"aap\", \"noot\", \"mies\")\n\ts.SetAdd(\"s2\", \"noot\", \"mies\", \"vuur\")\n\ts.SetAdd(\"s3\", \"aap\", \"mies\", \"wim\")\n\n\t// Simple case\n\t{\n\t\tmust1(t, c,\n\t\t\t\"SDIFFSTORE\", \"res\", \"s1\", \"s3\",\n\t\t)\n\t\ts.CheckSet(t, \"res\", \"noot\")\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SDIFFSTORE\",\n\t\t\tproto.Error(errWrongNumber(\"sdiffstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SDIFFSTORE\", \"t\",\n\t\t\tproto.Error(errWrongNumber(\"sdiffstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SDIFFSTORE\", \"t\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test SINTER\nfunc TestSinter(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s1\", \"aap\", \"noot\", \"mies\")\n\ts.SetAdd(\"s2\", \"noot\", \"mies\", \"vuur\")\n\ts.SetAdd(\"s3\", \"aap\", \"mies\", \"wim\")\n\n\t// Simple case\n\t{\n\t\tres, err := c.DoStrings(\"SINTER\", \"s1\", \"s2\")\n\t\tok(t, err)\n\t\tsort.Strings(res)\n\t\tequals(t, []string{\"mies\", \"noot\"}, res)\n\t}\n\n\t// No other set\n\t{\n\t\tres, err := c.DoStrings(\"SINTER\", \"s1\")\n\t\tok(t, err)\n\t\tsort.Strings(res)\n\t\tequals(t, []string{\"aap\", \"mies\", \"noot\"}, res)\n\t}\n\n\t// 3 sets\n\tmustDo(t, c,\n\t\t\"SINTER\", \"s1\", \"s2\", \"s3\",\n\t\tproto.Strings(\"mies\"),\n\t)\n\n\t// A nonexisting key\n\tmustDo(t, c,\n\t\t\"SINTER\", \"s9\",\n\t\tproto.Strings(),\n\t)\n\n\t// With one of the keys being an empty set, the resulting set is also empty\n\tmustDo(t, c,\n\t\t\"SINTER\", \"s1\", \"s9\",\n\t\tproto.Strings(),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SINTER\",\n\t\t\tproto.Error(errWrongNumber(\"sinter\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SINTER\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SINTER\", \"chk\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test SINTERSTORE\nfunc TestSinterstore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s1\", \"aap\", \"noot\", \"mies\")\n\ts.SetAdd(\"s2\", \"noot\", \"mies\", \"vuur\")\n\ts.SetAdd(\"s3\", \"aap\", \"mies\", \"wim\")\n\n\t// Simple case\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SINTERSTORE\", \"res\", \"s1\", \"s3\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\ts.CheckSet(t, \"res\", \"aap\", \"mies\")\n\t}\n\n\t// With one of the keys being an empty set, the resulting set is also empty\n\t{\n\t\tmust0(t, c,\n\t\t\t\"SINTERSTORE\", \"res\", \"s1\", \"s9\",\n\t\t)\n\t\ts.CheckSet(t, \"res\", []string{}...)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SINTERSTORE\",\n\t\t\tproto.Error(errWrongNumber(\"sinterstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SINTERSTORE\", \"t\",\n\t\t\tproto.Error(errWrongNumber(\"sinterstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SINTERSTORE\", \"t\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test SINTERCARD\nfunc TestSintercard(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t_, _ = s.SetAdd(\"s1\", \"a\", \"b\", \"c\")\n\t_, _ = s.SetAdd(\"s2\", \"b\", \"c\", \"d\")\n\t_, _ = s.SetAdd(\"s3\", \"c\", \"d\", \"e\")\n\n\tt.Run(\"no limit set\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SINTERCARD\", \"2\", \"s1\", \"s2\",\n\t\t\tproto.Int(2),\n\t\t)\n\t})\n\n\tt.Run(\"limit greater than result\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SINTERCARD\", \"2\", \"s1\", \"s2\", \"LIMIT\", \"15\",\n\t\t\tproto.Int(2),\n\t\t)\n\t})\n\n\tt.Run(\"limit of 0\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SINTERCARD\", \"2\", \"s1\", \"s2\", \"LIMIT\", \"0\",\n\t\t\tproto.Int(2),\n\t\t)\n\t})\n\n\tt.Run(\"limit of 1\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SINTERCARD\", \"2\", \"s1\", \"s2\", \"LIMIT\", \"1\",\n\t\t\tproto.Int(1),\n\t\t)\n\t})\n\n\tt.Run(\"multi intersection\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SINTERCARD\", \"3\", \"s1\", \"s2\", \"s3\",\n\t\t\tproto.Int(1),\n\t\t)\n\t})\n\n\tt.Run(\"nonexisting key\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"2\", \"s1\", \"NOT_A_KEY\",\n\t\t\tproto.Int(0),\n\t\t)\n\t})\n\n\tt.Run(\"bad numKeys\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"two\", \"key1\", \"key2\",\n\t\t\tproto.Error(\"ERR numkeys should be greater than 0\"),\n\t\t)\n\t})\n\n\tt.Run(\"too many keys limit\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"2\", \"key1\", \"key2\", \"key3\", \"LIMIT\", \"3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n\n\tt.Run(\"too many keys no limit\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"2\", \"key1\", \"key2\", \"key3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n\n\tt.Run(\"too few keys limit\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"4\", \"key1\", \"key2\", \"key3\", \"LIMIT\", \"3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n\n\tt.Run(\"too few keys no limit\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"4\", \"key1\", \"key2\", \"key3\",\n\t\t\tproto.Error(\"ERR Number of keys can't be greater than number of args\"),\n\t\t)\n\t})\n\n\tt.Run(\"bad limit\", func(t *testing.T) {\n\t\tmustDo(\n\t\t\tt, c,\n\t\t\t\"SINTERCARD\", \"2\", \"key1\", \"key2\", \"LIMIT\", \"five\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t})\n\n\tt.Run(\"wrong type\", func(t *testing.T) {\n\t\t_ = s.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SINTERCARD\", \"1\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test SUNION\nfunc TestSunion(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s1\", \"aap\", \"noot\", \"mies\")\n\ts.SetAdd(\"s2\", \"noot\", \"mies\", \"vuur\")\n\ts.SetAdd(\"s3\", \"aap\", \"mies\", \"wim\")\n\n\t// Simple case\n\t{\n\t\tres, err := c.DoStrings(\"SUNION\", \"s1\", \"s2\")\n\t\tok(t, err)\n\t\tsort.Strings(res)\n\t\tequals(t, []string{\"aap\", \"mies\", \"noot\", \"vuur\"}, res)\n\t}\n\n\t// No other set\n\t{\n\t\tres, err := c.DoStrings(\"SUNION\", \"s1\")\n\t\tok(t, err)\n\t\tsort.Strings(res)\n\t\tequals(t, []string{\"aap\", \"mies\", \"noot\"}, res)\n\t}\n\n\t// 3 sets\n\t{\n\t\tres, err := c.DoStrings(\"SUNION\", \"s1\", \"s2\", \"s3\")\n\t\tok(t, err)\n\t\tsort.Strings(res)\n\t\tequals(t, []string{\"aap\", \"mies\", \"noot\", \"vuur\", \"wim\"}, res)\n\t}\n\n\t// A nonexisting key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SUNION\", \"s9\",\n\t\t\tproto.Strings(),\n\t\t)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SUNION\",\n\t\t\tproto.Error(errWrongNumber(\"sunion\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SUNION\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SUNION\", \"chk\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test SUNIONSTORE\nfunc TestSunionstore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.SetAdd(\"s1\", \"aap\", \"noot\", \"mies\")\n\ts.SetAdd(\"s2\", \"noot\", \"mies\", \"vuur\")\n\ts.SetAdd(\"s3\", \"aap\", \"mies\", \"wim\")\n\n\t// Simple case\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SUNIONSTORE\", \"res\", \"s1\", \"s3\",\n\t\t\tproto.Int(4),\n\t\t)\n\t\ts.CheckSet(t, \"res\", \"aap\", \"mies\", \"noot\", \"wim\")\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\ts.SetAdd(\"chk\", \"aap\", \"noot\")\n\t\ts.Set(\"str\", \"value\")\n\n\t\tmustDo(t, c,\n\t\t\t\"SUNIONSTORE\",\n\t\t\tproto.Error(errWrongNumber(\"sunionstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SUNIONSTORE\", \"t\",\n\t\t\tproto.Error(errWrongNumber(\"sunionstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SUNIONSTORE\", \"t\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestSscan(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// We cheat with sscan. It always returns everything.\n\n\ts.SetAdd(\"set\", \"value1\", \"value2\")\n\t// No problem\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"set\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"value1\"),\n\t\t\t\tproto.String(\"value2\"),\n\t\t\t),\n\t\t),\n\t)\n\n\t// Invalid cursor\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"set\", \"42\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Strings(),\n\t\t),\n\t)\n\n\t// COUNT (ignored)\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"set\", \"0\", \"COUNT\", \"200\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"value1\"),\n\t\t\t\tproto.String(\"value2\"),\n\t\t\t),\n\t\t),\n\t)\n\n\t// MATCH\n\ts.SetAdd(\"set\", \"aap\", \"noot\", \"mies\")\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"set\", \"0\", \"MATCH\", \"mi*\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"mies\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\",\n\t\t\tproto.Error(errWrongNumber(\"sscan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"sscan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\", \"noint\",\n\t\t\tproto.Error(msgInvalidCursor),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\", \"0\", \"MATCH\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\", \"0\", \"COUNT\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\", \"0\", \"COUNT\", \"0\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\", \"0\", \"COUNT\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"set\", \"0\", \"COUNT\", \"-3\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"SSCAN\", \"str\", \"0\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n\n\ts.SetAdd(\"largeset\", \"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\")\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"largeset\", \"0\", \"COUNT\", \"3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"3\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"v1\"),\n\t\t\t\tproto.String(\"v2\"),\n\t\t\t\tproto.String(\"v3\"),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"largeset\", \"3\", \"COUNT\", \"3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"6\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"v4\"),\n\t\t\t\tproto.String(\"v5\"),\n\t\t\t\tproto.String(\"v6\"),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"SSCAN\", \"largeset\", \"6\", \"COUNT\", \"3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"v7\"),\n\t\t\t\tproto.String(\"v8\"),\n\t\t\t),\n\t\t),\n\t)\n}\n\nfunc TestDelElem(t *testing.T) {\n\tequals(t, []string{\"b\", \"c\", \"d\"}, delElem([]string{\"a\", \"b\", \"c\", \"d\"}, 0))\n\tequals(t, []string{\"a\", \"c\", \"d\"}, delElem([]string{\"a\", \"b\", \"c\", \"d\"}, 1))\n\tequals(t, []string{\"a\", \"b\", \"d\"}, delElem([]string{\"a\", \"b\", \"c\", \"d\"}, 2))\n\tequals(t, []string{\"a\", \"b\", \"c\"}, delElem([]string{\"a\", \"b\", \"c\", \"d\"}, 3))\n}\n"
        },
        {
          "name": "cmd_sorted_set.go",
          "type": "blob",
          "size": 37.970703125,
          "content": "// Commands from https://redis.io/commands#sorted_set\n\npackage miniredis\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsSortedSet handles all sorted set operations.\nfunc commandsSortedSet(m *Miniredis) {\n\tm.srv.Register(\"ZADD\", m.cmdZadd)\n\tm.srv.Register(\"ZCARD\", m.cmdZcard)\n\tm.srv.Register(\"ZCOUNT\", m.cmdZcount)\n\tm.srv.Register(\"ZINCRBY\", m.cmdZincrby)\n\tm.srv.Register(\"ZINTER\", m.makeCmdZinter(false))\n\tm.srv.Register(\"ZINTERSTORE\", m.makeCmdZinter(true))\n\tm.srv.Register(\"ZLEXCOUNT\", m.cmdZlexcount)\n\tm.srv.Register(\"ZRANGE\", m.cmdZrange)\n\tm.srv.Register(\"ZRANGEBYLEX\", m.makeCmdZrangebylex(false))\n\tm.srv.Register(\"ZRANGEBYSCORE\", m.makeCmdZrangebyscore(false))\n\tm.srv.Register(\"ZRANK\", m.makeCmdZrank(false))\n\tm.srv.Register(\"ZREM\", m.cmdZrem)\n\tm.srv.Register(\"ZREMRANGEBYLEX\", m.cmdZremrangebylex)\n\tm.srv.Register(\"ZREMRANGEBYRANK\", m.cmdZremrangebyrank)\n\tm.srv.Register(\"ZREMRANGEBYSCORE\", m.cmdZremrangebyscore)\n\tm.srv.Register(\"ZREVRANGE\", m.cmdZrevrange)\n\tm.srv.Register(\"ZREVRANGEBYLEX\", m.makeCmdZrangebylex(true))\n\tm.srv.Register(\"ZREVRANGEBYSCORE\", m.makeCmdZrangebyscore(true))\n\tm.srv.Register(\"ZREVRANK\", m.makeCmdZrank(true))\n\tm.srv.Register(\"ZSCORE\", m.cmdZscore)\n\tm.srv.Register(\"ZMSCORE\", m.cmdZMscore)\n\tm.srv.Register(\"ZUNION\", m.cmdZunion)\n\tm.srv.Register(\"ZUNIONSTORE\", m.cmdZunionstore)\n\tm.srv.Register(\"ZSCAN\", m.cmdZscan)\n\tm.srv.Register(\"ZPOPMAX\", m.cmdZpopmax(true))\n\tm.srv.Register(\"ZPOPMIN\", m.cmdZpopmax(false))\n\tm.srv.Register(\"ZRANDMEMBER\", m.cmdZrandmember)\n}\n\n// ZADD\nfunc (m *Miniredis) cmdZadd(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey  string\n\t\tnx   bool\n\t\txx   bool\n\t\tgt   bool\n\t\tlt   bool\n\t\tch   bool\n\t\tincr bool\n\t}\n\telems := map[string]float64{}\n\n\topts.key = args[0]\n\targs = args[1:]\nouter:\n\tfor len(args) > 0 {\n\t\tswitch strings.ToUpper(args[0]) {\n\t\tcase \"NX\":\n\t\t\topts.nx = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"XX\":\n\t\t\topts.xx = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"GT\":\n\t\t\topts.gt = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"LT\":\n\t\t\topts.lt = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"CH\":\n\t\t\topts.ch = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"INCR\":\n\t\t\topts.incr = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tbreak outer\n\t\t}\n\t}\n\n\tif len(args) == 0 || len(args)%2 != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tfor len(args) > 0 {\n\t\tscore, err := strconv.ParseFloat(args[0], 64)\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidFloat)\n\t\t\treturn\n\t\t}\n\t\telems[args[1]] = score\n\t\targs = args[2:]\n\t}\n\n\tif opts.xx && opts.nx {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgXXandNX)\n\t\treturn\n\t}\n\n\tif opts.gt && opts.lt ||\n\t\topts.gt && opts.nx ||\n\t\topts.lt && opts.nx {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgGTLTandNX)\n\t\treturn\n\t}\n\n\tif opts.incr && len(elems) > 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSingleElementPair)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(opts.key) && db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif opts.incr {\n\t\t\tfor member, delta := range elems {\n\t\t\t\tif opts.nx && db.ssetExists(opts.key, member) {\n\t\t\t\t\tc.WriteNull()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif opts.xx && !db.ssetExists(opts.key, member) {\n\t\t\t\t\tc.WriteNull()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tnewScore := db.ssetIncrby(opts.key, member, delta)\n\t\t\t\tc.WriteFloat(newScore)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tres := 0\n\t\tfor member, score := range elems {\n\t\t\texists := db.ssetExists(opts.key, member)\n\t\t\tif opts.nx && exists {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif opts.xx && !exists {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\told := db.ssetScore(opts.key, member)\n\t\t\tif opts.gt && exists && score <= old {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif opts.lt && exists && score >= old {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif db.ssetAdd(opts.key, score, member) {\n\t\t\t\tres++\n\t\t\t} else {\n\t\t\t\tif opts.ch && old != score {\n\t\t\t\t\t// if 'CH' is specified, only count changed keys\n\t\t\t\t\tres++\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(res)\n\t})\n}\n\n// ZCARD\nfunc (m *Miniredis) cmdZcard(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(db.ssetCard(key))\n\t})\n}\n\n// ZCOUNT\nfunc (m *Miniredis) cmdZcount(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar (\n\t\topts struct {\n\t\t\tkey     string\n\t\t\tmin     float64\n\t\t\tminIncl bool\n\t\t\tmax     float64\n\t\t\tmaxIncl bool\n\t\t}\n\t\terr error\n\t)\n\n\topts.key = args[0]\n\topts.min, opts.minIncl, err = parseFloatRange(args[1])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidMinMax)\n\t\treturn\n\t}\n\topts.max, opts.maxIncl, err = parseFloatRange(args[2])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidMinMax)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.ssetElements(opts.key)\n\t\tmembers = withSSRange(members, opts.min, opts.minIncl, opts.max, opts.maxIncl)\n\t\tc.WriteInt(len(members))\n\t})\n}\n\n// ZINCRBY\nfunc (m *Miniredis) cmdZincrby(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey    string\n\t\tdelta  float64\n\t\tmember string\n\t}\n\n\topts.key = args[0]\n\td, err := strconv.ParseFloat(args[1], 64)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidFloat)\n\t\treturn\n\t}\n\topts.delta = d\n\topts.member = args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif db.exists(opts.key) && db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tnewScore := db.ssetIncrby(opts.key, opts.member, opts.delta)\n\t\tc.WriteFloat(newScore)\n\t})\n}\n\n// ZINTERSTORE and ZINTER\nfunc (m *Miniredis) makeCmdZinter(store bool) func(c *server.Peer, cmd string, args []string) {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tminArgs := 2\n\t\tif store {\n\t\t\tminArgs++\n\t\t}\n\t\tif len(args) < minArgs {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\n\t\tvar opts = struct {\n\t\t\tStore       bool   // if true this is ZINTERSTORE\n\t\t\tDestination string // only relevant if $store is true\n\t\t\tKeys        []string\n\t\t\tAggregate   string\n\t\t\tWithWeights bool\n\t\t\tWeights     []float64\n\t\t\tWithScores  bool // only for ZINTER\n\t\t}{\n\t\t\tStore:     store,\n\t\t\tAggregate: \"sum\",\n\t\t}\n\n\t\tif store {\n\t\t\topts.Destination = args[0]\n\t\t\targs = args[1:]\n\t\t}\n\t\tnumKeys, err := strconv.Atoi(args[0])\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\targs = args[1:]\n\t\tif len(args) < numKeys {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t\tif numKeys <= 0 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(\"ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\")\n\t\t\treturn\n\t\t}\n\t\topts.Keys = args[:numKeys]\n\t\targs = args[numKeys:]\n\n\t\tfor len(args) > 0 {\n\t\t\tswitch strings.ToLower(args[0]) {\n\t\t\tcase \"weights\":\n\t\t\t\tif len(args) < numKeys+1 {\n\t\t\t\t\tsetDirty(c)\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < numKeys; i++ {\n\t\t\t\t\tf, err := strconv.ParseFloat(args[i+1], 64)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tsetDirty(c)\n\t\t\t\t\t\tc.WriteError(\"ERR weight value is not a float\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\topts.Weights = append(opts.Weights, f)\n\t\t\t\t}\n\t\t\t\topts.WithWeights = true\n\t\t\t\targs = args[numKeys+1:]\n\t\t\tcase \"aggregate\":\n\t\t\t\tif len(args) < 2 {\n\t\t\t\t\tsetDirty(c)\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\taggregate := strings.ToLower(args[1])\n\t\t\t\tswitch aggregate {\n\t\t\t\tcase \"sum\", \"min\", \"max\":\n\t\t\t\t\topts.Aggregate = aggregate\n\t\t\t\tdefault:\n\t\t\t\t\tsetDirty(c)\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\targs = args[2:]\n\t\t\tcase \"withscores\":\n\t\t\t\tif store {\n\t\t\t\t\tsetDirty(c)\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\topts.WithScores = true\n\t\t\t\targs = args[1:]\n\t\t\tdefault:\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\t// We collect everything and remove all keys which turned out not to be\n\t\t\t// present in every set.\n\t\t\tsset := map[string]float64{}\n\t\t\tcounts := map[string]int{}\n\t\t\tfor i, key := range opts.Keys {\n\t\t\t\tif !db.exists(key) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tvar set map[string]float64\n\t\t\t\tswitch db.t(key) {\n\t\t\t\tcase \"set\":\n\t\t\t\t\tset = map[string]float64{}\n\t\t\t\t\tfor elem := range db.setKeys[key] {\n\t\t\t\t\t\tset[elem] = 1.0\n\t\t\t\t\t}\n\t\t\t\tcase \"zset\":\n\t\t\t\t\tset = db.sortedSet(key)\n\t\t\t\tdefault:\n\t\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tfor member, score := range set {\n\t\t\t\t\tif opts.WithWeights {\n\t\t\t\t\t\tscore *= opts.Weights[i]\n\t\t\t\t\t}\n\t\t\t\t\tcounts[member]++\n\t\t\t\t\told, ok := sset[member]\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tsset[member] = score\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tswitch opts.Aggregate {\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tpanic(\"Invalid aggregate\")\n\t\t\t\t\tcase \"sum\":\n\t\t\t\t\t\tsset[member] += score\n\t\t\t\t\tcase \"min\":\n\t\t\t\t\t\tif score < old {\n\t\t\t\t\t\t\tsset[member] = score\n\t\t\t\t\t\t}\n\t\t\t\t\tcase \"max\":\n\t\t\t\t\t\tif score > old {\n\t\t\t\t\t\t\tsset[member] = score\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor key, count := range counts {\n\t\t\t\tif count != numKeys {\n\t\t\t\t\tdelete(sset, key)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif opts.Store {\n\t\t\t\t// ZINTERSTORE mode\n\t\t\t\tdb.del(opts.Destination, true)\n\t\t\t\tdb.ssetSet(opts.Destination, sset)\n\t\t\t\tc.WriteInt(len(sset))\n\t\t\t\treturn\n\t\t\t}\n\t\t\t// ZINTER mode\n\t\t\tsize := len(sset)\n\t\t\tif opts.WithScores {\n\t\t\t\tsize *= 2\n\t\t\t}\n\t\t\tc.WriteLen(size)\n\t\t\tfor _, l := range sortedKeys(sset) {\n\t\t\t\tc.WriteBulk(l)\n\t\t\t\tif opts.WithScores {\n\t\t\t\t\tc.WriteFloat(sset[l])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// ZLEXCOUNT\nfunc (m *Miniredis) cmdZlexcount(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts = struct {\n\t\tKey string\n\t\tMin string\n\t\tMax string\n\t}{\n\t\tKey: args[0],\n\t\tMin: args[1],\n\t\tMax: args[2],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tmin, minIncl, minErr := parseLexrange(opts.Min)\n\t\tmax, maxIncl, maxErr := parseLexrange(opts.Max)\n\t\tif minErr != nil || maxErr != nil {\n\t\t\tc.WriteError(msgInvalidRangeItem)\n\t\t\treturn\n\t\t}\n\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.Key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.Key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.ssetMembers(opts.Key)\n\t\t// Just key sort. If scores are not the same we don't care.\n\t\tsort.Strings(members)\n\t\tmembers = withLexRange(members, min, minIncl, max, maxIncl)\n\n\t\tc.WriteInt(len(members))\n\t})\n}\n\n// ZRANGE\nfunc (m *Miniredis) cmdZrange(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tKey        string\n\t\tMin        string\n\t\tMax        string\n\t\tWithScores bool\n\t\tByScore    bool\n\t\tByLex      bool\n\t\tReverse    bool\n\t\tWithLimit  bool\n\t\tOffset     string\n\t\tCount      string\n\t}\n\n\topts.Key, opts.Min, opts.Max = args[0], args[1], args[2]\n\targs = args[3:]\n\n\tfor len(args) > 0 {\n\t\tswitch strings.ToLower(args[0]) {\n\t\tcase \"byscore\":\n\t\t\topts.ByScore = true\n\t\t\targs = args[1:]\n\t\tcase \"bylex\":\n\t\t\topts.ByLex = true\n\t\t\targs = args[1:]\n\t\tcase \"rev\":\n\t\t\topts.Reverse = true\n\t\t\targs = args[1:]\n\t\tcase \"limit\":\n\t\t\topts.WithLimit = true\n\t\t\targs = args[1:]\n\t\t\tif len(args) < 2 {\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.Offset = args[0]\n\t\t\topts.Count = args[1]\n\t\t\targs = args[2:]\n\t\tcase \"withscores\":\n\t\t\topts.WithScores = true\n\t\t\targs = args[1:]\n\t\tdefault:\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tswitch {\n\t\tcase opts.ByScore && opts.ByLex:\n\t\t\tc.WriteError(msgSyntaxError)\n\t\tcase opts.ByScore:\n\t\t\trunRangeByScore(m, c, ctx, optsRangeByScore{\n\t\t\t\tKey:        opts.Key,\n\t\t\t\tMin:        opts.Min,\n\t\t\t\tMax:        opts.Max,\n\t\t\t\tReverse:    opts.Reverse,\n\t\t\t\tWithLimit:  opts.WithLimit,\n\t\t\t\tOffset:     opts.Offset,\n\t\t\t\tCount:      opts.Count,\n\t\t\t\tWithScores: opts.WithScores,\n\t\t\t})\n\t\tcase opts.ByLex:\n\t\t\trunRangeByLex(m, c, ctx, optsRangeByLex{\n\t\t\t\tKey:        opts.Key,\n\t\t\t\tMin:        opts.Min,\n\t\t\t\tMax:        opts.Max,\n\t\t\t\tReverse:    opts.Reverse,\n\t\t\t\tWithLimit:  opts.WithLimit,\n\t\t\t\tOffset:     opts.Offset,\n\t\t\t\tCount:      opts.Count,\n\t\t\t\tWithScores: opts.WithScores,\n\t\t\t})\n\t\tdefault:\n\t\t\tif opts.WithLimit {\n\t\t\t\tc.WriteError(msgLimitCombination)\n\t\t\t\treturn\n\t\t\t}\n\t\t\trunRange(m, c, ctx, optsRange{\n\t\t\t\tKey:        opts.Key,\n\t\t\t\tMin:        opts.Min,\n\t\t\t\tMax:        opts.Max,\n\t\t\t\tReverse:    opts.Reverse,\n\t\t\t\tWithScores: opts.WithScores,\n\t\t\t})\n\t\t}\n\t})\n}\n\n// ZREVRANGE\nfunc (m *Miniredis) cmdZrevrange(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts = optsRange{\n\t\tReverse: true,\n\t\tKey:     args[0],\n\t\tMin:     args[1],\n\t\tMax:     args[2],\n\t}\n\targs = args[3:]\n\n\tfor len(args) > 0 {\n\t\tswitch strings.ToLower(args[0]) {\n\t\tcase \"withscores\":\n\t\t\topts.WithScores = true\n\t\t\targs = args[1:]\n\t\tdefault:\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t}\n\n\twithTx(m, c, func(c *server.Peer, cctx *connCtx) {\n\t\trunRange(m, c, cctx, opts)\n\t})\n}\n\n// ZRANGEBYLEX and ZREVRANGEBYLEX\nfunc (m *Miniredis) makeCmdZrangebylex(reverse bool) server.Cmd {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) < 3 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\t\topts := optsRangeByLex{\n\t\t\tReverse: reverse,\n\t\t\tKey:     args[0],\n\t\t\tMin:     args[1],\n\t\t\tMax:     args[2],\n\t\t}\n\t\targs = args[3:]\n\n\t\tfor len(args) > 0 {\n\t\t\tswitch strings.ToLower(args[0]) {\n\t\t\tcase \"limit\":\n\t\t\t\topts.WithLimit = true\n\t\t\t\targs = args[1:]\n\t\t\t\tif len(args) < 2 {\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\topts.Offset = args[0]\n\t\t\t\topts.Count = args[1]\n\t\t\t\targs = args[2:]\n\t\t\t\tcontinue\n\t\t\tdefault:\n\t\t\t\t// Syntax error\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\twithTx(m, c, func(c *server.Peer, cctx *connCtx) {\n\t\t\trunRangeByLex(m, c, cctx, opts)\n\t\t})\n\t}\n}\n\n// ZRANGEBYSCORE and ZREVRANGEBYSCORE\nfunc (m *Miniredis) makeCmdZrangebyscore(reverse bool) server.Cmd {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) < 3 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\n\t\tvar opts = optsRangeByScore{\n\t\t\tReverse: reverse,\n\t\t\tKey:     args[0],\n\t\t\tMin:     args[1],\n\t\t\tMax:     args[2],\n\t\t}\n\t\targs = args[3:]\n\n\t\tfor len(args) > 0 {\n\t\t\tif strings.ToLower(args[0]) == \"limit\" {\n\t\t\t\topts.WithLimit = true\n\t\t\t\targs = args[1:]\n\t\t\t\tif len(args) < 2 {\n\t\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\topts.Offset = args[0]\n\t\t\t\topts.Count = args[1]\n\t\t\t\targs = args[2:]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.ToLower(args[0]) == \"withscores\" {\n\t\t\t\topts.WithScores = true\n\t\t\t\targs = args[1:]\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\n\t\twithTx(m, c, func(c *server.Peer, cctx *connCtx) {\n\t\t\trunRangeByScore(m, c, cctx, opts)\n\t\t})\n\t}\n}\n\n// ZRANK and ZREVRANK\nfunc (m *Miniredis) makeCmdZrank(reverse bool) server.Cmd {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) < 2 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\n\t\tkey, member := args[0], args[1]\n\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\twithScore := false\n\t\t\tif len(args) > 0 && strings.ToUpper(args[len(args)-1]) == \"WITHSCORE\" {\n\t\t\t\twithScore = true\n\t\t\t\targs = args[:len(args)-1]\n\t\t\t}\n\n\t\t\tif len(args) > 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif !db.exists(key) {\n\t\t\t\tif withScore {\n\t\t\t\t\tc.WriteLen(-1)\n\t\t\t\t} else {\n\t\t\t\t\tc.WriteNull()\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif db.t(key) != \"zset\" {\n\t\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdirection := asc\n\t\t\tif reverse {\n\t\t\t\tdirection = desc\n\t\t\t}\n\t\t\trank, ok := db.ssetRank(key, member, direction)\n\t\t\tif !ok {\n\t\t\t\tif withScore {\n\t\t\t\t\tc.WriteLen(-1)\n\t\t\t\t} else {\n\t\t\t\t\tc.WriteNull()\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif withScore {\n\t\t\t\tc.WriteLen(2)\n\t\t\t\tc.WriteInt(rank)\n\t\t\t\tc.WriteFloat(db.ssetScore(key, member))\n\t\t\t} else {\n\t\t\t\tc.WriteInt(rank)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// ZREM\nfunc (m *Miniredis) cmdZrem(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, members := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tdeleted := 0\n\t\tfor _, member := range members {\n\t\t\tif db.ssetRem(key, member) {\n\t\t\t\tdeleted++\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(deleted)\n\t})\n}\n\n// ZREMRANGEBYLEX\nfunc (m *Miniredis) cmdZremrangebylex(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts = struct {\n\t\tKey string\n\t\tMin string\n\t\tMax string\n\t}{\n\t\tKey: args[0],\n\t\tMin: args[1],\n\t\tMax: args[2],\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tmin, minIncl, minErr := parseLexrange(opts.Min)\n\t\tmax, maxIncl, maxErr := parseLexrange(opts.Max)\n\t\tif minErr != nil || maxErr != nil {\n\t\t\tc.WriteError(msgInvalidRangeItem)\n\t\t\treturn\n\t\t}\n\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.Key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.Key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.ssetMembers(opts.Key)\n\t\t// Just key sort. If scores are not the same we don't care.\n\t\tsort.Strings(members)\n\t\tmembers = withLexRange(members, min, minIncl, max, maxIncl)\n\n\t\tfor _, el := range members {\n\t\t\tdb.ssetRem(opts.Key, el)\n\t\t}\n\t\tc.WriteInt(len(members))\n\t})\n}\n\n// ZREMRANGEBYRANK\nfunc (m *Miniredis) cmdZremrangebyrank(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tstart int\n\t\tend   int\n\t}\n\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.start); !ok {\n\t\treturn\n\t}\n\tif ok := optInt(c, args[2], &opts.end); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.ssetMembers(opts.key)\n\t\trs, re := redisRange(len(members), opts.start, opts.end, false)\n\t\tfor _, el := range members[rs:re] {\n\t\t\tdb.ssetRem(opts.key, el)\n\t\t}\n\t\tc.WriteInt(re - rs)\n\t})\n}\n\n// ZREMRANGEBYSCORE\nfunc (m *Miniredis) cmdZremrangebyscore(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar (\n\t\topts struct {\n\t\t\tkey     string\n\t\t\tmin     float64\n\t\t\tminIncl bool\n\t\t\tmax     float64\n\t\t\tmaxIncl bool\n\t\t}\n\t\terr error\n\t)\n\topts.key = args[0]\n\topts.min, opts.minIncl, err = parseFloatRange(args[1])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidMinMax)\n\t\treturn\n\t}\n\topts.max, opts.maxIncl, err = parseFloatRange(args[2])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidMinMax)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.ssetElements(opts.key)\n\t\tmembers = withSSRange(members, opts.min, opts.minIncl, opts.max, opts.maxIncl)\n\n\t\tfor _, el := range members {\n\t\t\tdb.ssetRem(opts.key, el.member)\n\t\t}\n\t\tc.WriteInt(len(members))\n\t})\n}\n\n// ZSCORE\nfunc (m *Miniredis) cmdZscore(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, member := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif !db.ssetExists(key, member) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteFloat(db.ssetScore(key, member))\n\t})\n}\n\n// ZMSCORE\nfunc (m *Miniredis) cmdZMscore(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, members := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteLen(len(members))\n\t\t\tfor range members {\n\t\t\t\tc.WriteNull()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(members))\n\t\tfor _, member := range members {\n\t\t\tif !db.ssetExists(key, member) {\n\t\t\t\tc.WriteNull()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.WriteFloat(db.ssetScore(key, member))\n\t\t}\n\t})\n}\n\n// parseFloatRange handles ZRANGEBYSCORE floats. They are inclusive unless the\n// string starts with '('\nfunc parseFloatRange(s string) (float64, bool, error) {\n\tif len(s) == 0 {\n\t\treturn 0, false, nil\n\t}\n\tinclusive := true\n\tif s[0] == '(' {\n\t\ts = s[1:]\n\t\tinclusive = false\n\t}\n\tswitch strings.ToLower(s) {\n\tcase \"+inf\":\n\t\treturn math.Inf(+1), true, nil\n\tcase \"-inf\":\n\t\treturn math.Inf(-1), true, nil\n\tdefault:\n\t\tf, err := strconv.ParseFloat(s, 64)\n\t\treturn f, inclusive, err\n\t}\n}\n\n// withSSRange limits a list of sorted set elements by the ZRANGEBYSCORE range\n// logic.\nfunc withSSRange(members ssElems, min float64, minIncl bool, max float64, maxIncl bool) ssElems {\n\tgt := func(a, b float64) bool { return a > b }\n\tgteq := func(a, b float64) bool { return a >= b }\n\n\tmincmp := gt\n\tif minIncl {\n\t\tmincmp = gteq\n\t}\n\tfor i, m := range members {\n\t\tif mincmp(m.score, min) {\n\t\t\tmembers = members[i:]\n\t\t\tgoto checkmax\n\t\t}\n\t}\n\t// all elements were smaller\n\treturn nil\n\ncheckmax:\n\tmaxcmp := gteq\n\tif maxIncl {\n\t\tmaxcmp = gt\n\t}\n\tfor i, m := range members {\n\t\tif maxcmp(m.score, max) {\n\t\t\tmembers = members[:i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn members\n}\n\n// withLexRange limits a list of sorted set elements.\nfunc withLexRange(members []string, min string, minIncl bool, max string, maxIncl bool) []string {\n\tif max == \"-\" || min == \"+\" {\n\t\treturn nil\n\t}\n\tif min != \"-\" {\n\t\tfound := false\n\t\tif minIncl {\n\t\t\tfor i, m := range members {\n\t\t\t\tif m >= min {\n\t\t\t\t\tmembers = members[i:]\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Excluding min\n\t\t\tfor i, m := range members {\n\t\t\t\tif m > min {\n\t\t\t\t\tmembers = members[i:]\n\t\t\t\t\tfound = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn nil\n\t\t}\n\t}\n\tif max != \"+\" {\n\t\tif maxIncl {\n\t\t\tfor i, m := range members {\n\t\t\t\tif m > max {\n\t\t\t\t\tmembers = members[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Excluding max\n\t\t\tfor i, m := range members {\n\t\t\t\tif m >= max {\n\t\t\t\t\tmembers = members[:i]\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn members\n}\n\n// ZUNION\nfunc (m *Miniredis) cmdZunion(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tnumKeys, err := strconv.Atoi(args[0])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn\n\t}\n\targs = args[1:]\n\tif len(args) < numKeys {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tif numKeys <= 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR at least 1 input key is needed for ZUNION\")\n\t\treturn\n\t}\n\tkeys := args[:numKeys]\n\targs = args[numKeys:]\n\n\twithScores := false\n\tif len(args) > 0 && strings.ToUpper(args[len(args)-1]) == \"WITHSCORES\" {\n\t\twithScores = true\n\t\targs = args[:len(args)-1]\n\t}\n\n\topts := zunionOptions{\n\t\tKeys:        keys,\n\t\tWithWeights: false,\n\t\tWeights:     []float64{},\n\t\tAggregate:   \"sum\",\n\t}\n\n\tif err := opts.parseArgs(args, numKeys); err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tsset, err := executeZUnion(db, opts)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif withScores {\n\t\t\tc.WriteLen(len(sset) * 2)\n\t\t} else {\n\t\t\tc.WriteLen(len(sset))\n\t\t}\n\t\tfor _, el := range sset.byScore(asc) {\n\t\t\tc.WriteBulk(el.member)\n\t\t\tif withScores {\n\t\t\t\tc.WriteFloat(el.score)\n\t\t\t}\n\t\t}\n\t})\n}\n\n// ZUNIONSTORE\nfunc (m *Miniredis) cmdZunionstore(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tdestination := args[0]\n\tnumKeys, err := strconv.Atoi(args[1])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn\n\t}\n\targs = args[2:]\n\tif len(args) < numKeys {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\tif numKeys <= 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\")\n\t\treturn\n\t}\n\tkeys := args[:numKeys]\n\targs = args[numKeys:]\n\n\topts := zunionOptions{\n\t\tKeys:        keys,\n\t\tWithWeights: false,\n\t\tWeights:     []float64{},\n\t\tAggregate:   \"sum\",\n\t}\n\n\tif err := opts.parseArgs(args, numKeys); err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tdeleteDest := true\n\t\tfor _, key := range keys {\n\t\t\tif destination == key {\n\t\t\t\tdeleteDest = false\n\t\t\t}\n\t\t}\n\t\tif deleteDest {\n\t\t\tdb.del(destination, true)\n\t\t}\n\n\t\tsset, err := executeZUnion(db, opts)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tdb.ssetSet(destination, sset)\n\t\tc.WriteInt(sset.card())\n\t})\n}\n\ntype zunionOptions struct {\n\tKeys        []string\n\tWithWeights bool\n\tWeights     []float64\n\tAggregate   string\n}\n\nfunc (opts *zunionOptions) parseArgs(args []string, numKeys int) error {\n\tfor len(args) > 0 {\n\t\tswitch strings.ToLower(args[0]) {\n\t\tcase \"weights\":\n\t\t\tif len(args) < numKeys+1 {\n\t\t\t\treturn errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\tfor i := 0; i < numKeys; i++ {\n\t\t\t\tf, err := strconv.ParseFloat(args[i+1], 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn errors.New(\"ERR weight value is not a float\")\n\t\t\t\t}\n\t\t\t\topts.Weights = append(opts.Weights, f)\n\t\t\t}\n\t\t\topts.WithWeights = true\n\t\t\targs = args[numKeys+1:]\n\t\tcase \"aggregate\":\n\t\t\tif len(args) < 2 {\n\t\t\t\treturn errors.New(msgSyntaxError)\n\t\t\t}\n\t\t\topts.Aggregate = strings.ToLower(args[1])\n\t\t\tswitch opts.Aggregate {\n\t\t\tdefault:\n\t\t\t\treturn errors.New(msgSyntaxError)\n\t\t\tcase \"sum\", \"min\", \"max\":\n\t\t\t}\n\t\t\targs = args[2:]\n\t\tdefault:\n\t\t\treturn errors.New(msgSyntaxError)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc executeZUnion(db *RedisDB, opts zunionOptions) (sortedSet, error) {\n\tsset := sortedSet{}\n\tfor i, key := range opts.Keys {\n\t\tif !db.exists(key) {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar set map[string]float64\n\t\tswitch db.t(key) {\n\t\tcase \"set\":\n\t\t\tset = map[string]float64{}\n\t\t\tfor elem := range db.setKeys[key] {\n\t\t\t\tset[elem] = 1.0\n\t\t\t}\n\t\tcase \"zset\":\n\t\t\tset = db.sortedSet(key)\n\t\tdefault:\n\t\t\treturn nil, errors.New(msgWrongType)\n\t\t}\n\n\t\tfor member, score := range set {\n\t\t\tif opts.WithWeights {\n\t\t\t\tscore *= opts.Weights[i]\n\t\t\t}\n\t\t\told, ok := sset[member]\n\t\t\tif !ok {\n\t\t\t\tsset[member] = score\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch opts.Aggregate {\n\t\t\tdefault:\n\t\t\t\tpanic(\"Invalid aggregate\")\n\t\t\tcase \"sum\":\n\t\t\t\tsset[member] += score\n\t\t\tcase \"min\":\n\t\t\t\tif score < old {\n\t\t\t\t\tsset[member] = score\n\t\t\t\t}\n\t\t\tcase \"max\":\n\t\t\t\tif score > old {\n\t\t\t\t\tsset[member] = score\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sset, nil\n}\n\n// ZSCAN\nfunc (m *Miniredis) cmdZscan(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey       string\n\t\tcursor    int\n\t\tcount     int\n\t\twithMatch bool\n\t\tmatch     string\n\t}\n\n\topts.key = args[0]\n\tif ok := optIntErr(c, args[1], &opts.cursor, msgInvalidCursor); !ok {\n\t\treturn\n\t}\n\targs = args[2:]\n\t// MATCH and COUNT options\n\tfor len(args) > 0 {\n\t\tif strings.ToLower(args[0]) == \"count\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcount, err := strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif count <= 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.count = count\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tif strings.ToLower(args[0]) == \"match\" {\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.withMatch = true\n\t\t\topts.match = args[1]\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\t}\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tif db.exists(opts.key) && db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tmembers := db.ssetMembers(opts.key)\n\t\tif opts.withMatch {\n\t\t\tmembers, _ = matchKeys(members, opts.match)\n\t\t}\n\n\t\tlow := opts.cursor\n\t\thigh := low + opts.count\n\t\t// validate high is correct\n\t\tif high > len(members) || high == 0 {\n\t\t\thigh = len(members)\n\t\t}\n\t\tif opts.cursor > high {\n\t\t\t// invalid cursor\n\t\t\tc.WriteLen(2)\n\t\t\tc.WriteBulk(\"0\") // no next cursor\n\t\t\tc.WriteLen(0)    // no elements\n\t\t\treturn\n\t\t}\n\t\tcursorValue := low + opts.count\n\t\tif cursorValue >= len(members) {\n\t\t\tcursorValue = 0 // no next cursor\n\t\t}\n\t\tmembers = members[low:high]\n\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(fmt.Sprintf(\"%d\", cursorValue))\n\t\t// HSCAN gives key, values.\n\t\tc.WriteLen(len(members) * 2)\n\t\tfor _, k := range members {\n\t\t\tc.WriteBulk(k)\n\t\t\tc.WriteFloat(db.ssetScore(opts.key, k))\n\t\t}\n\t})\n}\n\n// ZPOPMAX and ZPOPMIN\nfunc (m *Miniredis) cmdZpopmax(reverse bool) server.Cmd {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) < 1 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\n\t\tkey := args[0]\n\t\tcount := 1\n\t\tvar err error\n\t\tif len(args) > 1 {\n\t\t\tcount, err = strconv.Atoi(args[1])\n\t\t\tif err != nil || count < 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidRange)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\twithScores := true\n\t\tif len(args) > 2 {\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\tif !db.exists(key) {\n\t\t\t\tc.WriteLen(0)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif db.t(key) != \"zset\" {\n\t\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tmembers := db.ssetMembers(key)\n\t\t\tif reverse {\n\t\t\t\treverseSlice(members)\n\t\t\t}\n\t\t\trs, re := redisRange(len(members), 0, count-1, false)\n\t\t\tif withScores {\n\t\t\t\tc.WriteLen((re - rs) * 2)\n\t\t\t} else {\n\t\t\t\tc.WriteLen(re - rs)\n\t\t\t}\n\t\t\tfor _, el := range members[rs:re] {\n\t\t\t\tc.WriteBulk(el)\n\t\t\t\tif withScores {\n\t\t\t\t\tc.WriteFloat(db.ssetScore(key, el))\n\t\t\t\t}\n\t\t\t\tdb.ssetRem(key, el)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// ZRANDMEMBER\nfunc (m *Miniredis) cmdZrandmember(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey        string\n\t\twithCount  bool\n\t\tcount      int\n\t\twithScores bool\n\t}\n\n\topts.key = args[0]\n\targs = args[1:]\n\n\tif len(args) > 0 {\n\t\t// can be negative\n\t\tif ok := optInt(c, args[0], &opts.count); !ok {\n\t\t\treturn\n\t\t}\n\t\topts.withCount = true\n\t\targs = args[1:]\n\t}\n\n\tif len(args) > 0 && strings.ToUpper(args[0]) == \"WITHSCORES\" {\n\t\topts.withScores = true\n\t\targs = args[1:]\n\t}\n\n\tif len(args) > 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tif opts.withCount {\n\t\t\t\tc.WriteLen(0)\n\t\t\t} else {\n\t\t\t\tc.WriteNull()\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(opts.key) != \"zset\" {\n\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\treturn\n\t\t}\n\n\t\tif !opts.withCount {\n\t\t\tmember := db.ssetRandomMember(opts.key)\n\t\t\tif member == \"\" {\n\t\t\t\tc.WriteNull()\n\t\t\t\treturn\n\t\t\t}\n\t\t\tc.WriteBulk(member)\n\t\t\treturn\n\t\t}\n\n\t\tvar members []string\n\t\tswitch {\n\t\tcase opts.count == 0:\n\t\t\tc.WriteStrings(nil)\n\t\t\treturn\n\t\tcase opts.count > 0:\n\t\t\tallMembers := db.ssetMembers(opts.key)\n\t\t\tdb.master.shuffle(allMembers)\n\t\t\tif len(allMembers) > opts.count {\n\t\t\t\tallMembers = allMembers[:opts.count]\n\t\t\t}\n\t\t\tmembers = allMembers\n\t\tcase opts.count < 0:\n\t\t\tfor i := 0; i < -opts.count; i++ {\n\t\t\t\tmembers = append(members, db.ssetRandomMember(opts.key))\n\t\t\t}\n\t\t}\n\t\tif opts.withScores {\n\t\t\tc.WriteLen(len(members) * 2)\n\t\t\tfor _, m := range members {\n\t\t\t\tc.WriteBulk(m)\n\t\t\t\tc.WriteFloat(db.ssetScore(opts.key, m))\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tc.WriteStrings(members)\n\t})\n}\n\ntype optsRange struct {\n\tKey        string\n\tMin        string\n\tMax        string\n\tReverse    bool\n\tWithScores bool\n}\n\nfunc runRange(m *Miniredis, c *server.Peer, cctx *connCtx, opts optsRange) {\n\tmin, minErr := strconv.Atoi(opts.Min)\n\tmax, maxErr := strconv.Atoi(opts.Max)\n\tif minErr != nil || maxErr != nil {\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn\n\t}\n\n\tdb := m.db(cctx.selectedDB)\n\n\tif !db.exists(opts.Key) {\n\t\tc.WriteLen(0)\n\t\treturn\n\t}\n\n\tif db.t(opts.Key) != \"zset\" {\n\t\tc.WriteError(ErrWrongType.Error())\n\t\treturn\n\t}\n\n\tmembers := db.ssetMembers(opts.Key)\n\tif opts.Reverse {\n\t\treverseSlice(members)\n\t}\n\trs, re := redisRange(len(members), min, max, false)\n\tif opts.WithScores {\n\t\tc.WriteLen((re - rs) * 2)\n\t} else {\n\t\tc.WriteLen(re - rs)\n\t}\n\tfor _, el := range members[rs:re] {\n\t\tc.WriteBulk(el)\n\t\tif opts.WithScores {\n\t\t\tc.WriteFloat(db.ssetScore(opts.Key, el))\n\t\t}\n\t}\n}\n\ntype optsRangeByScore struct {\n\tKey        string\n\tMin        string\n\tMax        string\n\tReverse    bool\n\tWithLimit  bool\n\tOffset     string\n\tCount      string\n\tWithScores bool\n}\n\nfunc runRangeByScore(m *Miniredis, c *server.Peer, cctx *connCtx, opts optsRangeByScore) {\n\tvar limitOffset, limitCount int\n\tvar err error\n\tif opts.WithLimit {\n\t\tlimitOffset, err = strconv.Atoi(opts.Offset)\n\t\tif err != nil {\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\tlimitCount, err = strconv.Atoi(opts.Count)\n\t\tif err != nil {\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t}\n\tmin, minIncl, minErr := parseFloatRange(opts.Min)\n\tmax, maxIncl, maxErr := parseFloatRange(opts.Max)\n\tif minErr != nil || maxErr != nil {\n\t\tc.WriteError(msgInvalidMinMax)\n\t\treturn\n\t}\n\n\tdb := m.db(cctx.selectedDB)\n\n\tif !db.exists(opts.Key) {\n\t\tc.WriteLen(0)\n\t\treturn\n\t}\n\n\tif db.t(opts.Key) != \"zset\" {\n\t\tc.WriteError(ErrWrongType.Error())\n\t\treturn\n\t}\n\n\tmembers := db.ssetElements(opts.Key)\n\tif opts.Reverse {\n\t\tmin, max = max, min\n\t\tminIncl, maxIncl = maxIncl, minIncl\n\t}\n\tmembers = withSSRange(members, min, minIncl, max, maxIncl)\n\tif opts.Reverse {\n\t\treverseElems(members)\n\t}\n\n\t// Apply LIMIT ranges. That's <start> <elements>. Unlike RANGE.\n\tif opts.WithLimit {\n\t\tif limitOffset < 0 {\n\t\t\tmembers = ssElems{}\n\t\t} else {\n\t\t\tif limitOffset < len(members) {\n\t\t\t\tmembers = members[limitOffset:]\n\t\t\t} else {\n\t\t\t\t// out of range\n\t\t\t\tmembers = ssElems{}\n\t\t\t}\n\t\t\tif limitCount >= 0 {\n\t\t\t\tif len(members) > limitCount {\n\t\t\t\t\tmembers = members[:limitCount]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif opts.WithScores {\n\t\tc.WriteLen(len(members) * 2)\n\t} else {\n\t\tc.WriteLen(len(members))\n\t}\n\tfor _, el := range members {\n\t\tc.WriteBulk(el.member)\n\t\tif opts.WithScores {\n\t\t\tc.WriteFloat(el.score)\n\t\t}\n\t}\n}\n\ntype optsRangeByLex struct {\n\tKey        string\n\tMin        string\n\tMax        string\n\tReverse    bool\n\tWithLimit  bool\n\tOffset     string\n\tCount      string\n\tWithScores bool\n}\n\nfunc runRangeByLex(m *Miniredis, c *server.Peer, cctx *connCtx, opts optsRangeByLex) {\n\tvar limitOffset, limitCount int\n\tvar err error\n\tif opts.WithLimit {\n\t\tlimitOffset, err = strconv.Atoi(opts.Offset)\n\t\tif err != nil {\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\tlimitCount, err = strconv.Atoi(opts.Count)\n\t\tif err != nil {\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t}\n\tmin, minIncl, minErr := parseLexrange(opts.Min)\n\tmax, maxIncl, maxErr := parseLexrange(opts.Max)\n\tif minErr != nil || maxErr != nil {\n\t\tc.WriteError(msgInvalidRangeItem)\n\t\treturn\n\t}\n\n\tdb := m.db(cctx.selectedDB)\n\n\tif !db.exists(opts.Key) {\n\t\tc.WriteLen(0)\n\t\treturn\n\t}\n\n\tif db.t(opts.Key) != \"zset\" {\n\t\tc.WriteError(ErrWrongType.Error())\n\t\treturn\n\t}\n\n\tmembers := db.ssetMembers(opts.Key)\n\t// Just key sort. If scores are not the same we don't care.\n\tsort.Strings(members)\n\tif opts.Reverse {\n\t\tmin, max = max, min\n\t\tminIncl, maxIncl = maxIncl, minIncl\n\t}\n\tmembers = withLexRange(members, min, minIncl, max, maxIncl)\n\tif opts.Reverse {\n\t\treverseSlice(members)\n\t}\n\n\t// Apply LIMIT ranges. That's <start> <elements>. Unlike RANGE.\n\tif opts.WithLimit {\n\t\tif limitOffset < 0 {\n\t\t\tmembers = nil\n\t\t} else {\n\t\t\tif limitOffset < len(members) {\n\t\t\t\tmembers = members[limitOffset:]\n\t\t\t} else {\n\t\t\t\t// out of range\n\t\t\t\tmembers = nil\n\t\t\t}\n\t\t\tif limitCount >= 0 {\n\t\t\t\tif len(members) > limitCount {\n\t\t\t\t\tmembers = members[:limitCount]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tc.WriteLen(len(members))\n\tfor _, el := range members {\n\t\tc.WriteBulk(el)\n\t}\n}\n\n// optLexrange handles ZRANGE{,BYLEX} ranges. They start with '[', '(', or are\n// '+' or '-'.\n// Sets destValue and destInclusive. destValue can be '+' or '-'.\nfunc parseLexrange(s string) (string, bool, error) {\n\tif len(s) == 0 {\n\t\treturn \"\", false, errors.New(msgInvalidRangeItem)\n\t}\n\n\tif s == \"+\" || s == \"-\" {\n\t\treturn s, false, nil\n\t}\n\n\tswitch s[0] {\n\tcase '(':\n\t\treturn s[1:], false, nil\n\tcase '[':\n\t\treturn s[1:], true, nil\n\tdefault:\n\t\treturn \"\", false, errors.New(msgInvalidRangeItem)\n\t}\n}\n\nfunc sortedKeys(m map[string]float64) []string {\n\tvar keys []string\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\treturn keys\n}\n"
        },
        {
          "name": "cmd_sorted_set_test.go",
          "type": "blob",
          "size": 43.2255859375,
          "content": "package miniredis\n\nimport (\n\t\"math\"\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test ZADD / ZCARD / ZRANK / ZREVRANK.\nfunc TestSortedSet(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"z\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCARD\", \"z\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZRANK\", \"z\", \"one\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANK\", \"z\", \"three\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANK\", \"z\", \"three\", \"withscore\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Int(2),\n\t\t\t\tproto.String(\"3\"),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANK\", \"z\", \"one\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANK\", \"z\", \"one\", \"withscore\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Int(2),\n\t\t\t\tproto.String(\"1\"),\n\t\t\t),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZREVRANK\", \"z\", \"three\",\n\t\t)\n\t}\n\n\t// TYPE of our zset\n\tmustDo(t, c,\n\t\t\"TYPE\", \"z\",\n\t\tproto.Inline(\"zset\"),\n\t)\n\n\t// Replace a key\n\t{\n\t\tmust0(t, c,\n\t\t\t\"ZADD\", \"z\", \"2.1\", \"two\",\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCARD\", \"z\",\n\t\t\tproto.Int(3),\n\t\t)\n\t}\n\n\t// To infinity!\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"zinf\", \"inf\", \"plus inf\", \"-inf\", \"minus inf\", \"10\", \"ten\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCARD\", \"zinf\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tsmap, err := s.SortedSet(\"zinf\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\n\t\t\t\"plus inf\":  math.Inf(+1),\n\t\t\t\"minus inf\": math.Inf(-1),\n\t\t\t\"ten\":       10.0,\n\t\t}, smap)\n\t}\n\n\t// Invalid score\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"z\", \"noint\", \"two\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t}\n\n\t// ZRANK on non-existing key/member\n\t{\n\t\tmustNil(t, c,\n\t\t\t\"ZRANK\", \"z\", \"nosuch\",\n\t\t)\n\n\t\tmustNil(t, c,\n\t\t\t\"ZRANK\", \"nosuch\", \"nosuch\",\n\t\t)\n\t}\n\n\t// Direct usage\n\t{\n\t\tadded, err := s.ZAdd(\"s1\", 12.4, \"aap\")\n\t\tok(t, err)\n\t\tequals(t, true, added)\n\t\tadded, err = s.ZAdd(\"s1\", 3.4, \"noot\")\n\t\tok(t, err)\n\t\tequals(t, true, added)\n\t\tadded, err = s.ZAdd(\"s1\", 3.5, \"noot\")\n\t\tok(t, err)\n\t\tequals(t, false, added)\n\n\t\tmembers, err := s.ZMembers(\"s1\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"noot\", \"aap\"}, members)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\t// Wrong type of key\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZRANK\", \"str\", \"foo\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANK\",\n\t\t\tproto.Error(errWrongNumber(\"zrank\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANK\", \"set\", \"spurious\", \"args\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANK\",\n\t\t\tproto.Error(errWrongNumber(\"zrevrank\")),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCARD\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZCARD\",\n\t\t\tproto.Error(errWrongNumber(\"zcard\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZCARD\", \"set\", \"spurious\",\n\t\t\tproto.Error(errWrongNumber(\"zcard\")),\n\t\t)\n\t})\n}\n\n// Test ZADD\nfunc TestSortedSetAdd(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"z\", \"1\", \"one\", \"2\", \"two\", \"3\", \"three\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZADD\", \"z\", \"1\", \"one\", \"2.1\", \"two\", \"3\", \"three\",\n\t\t)\n\n\t\tmust1(t, c,\n\t\t\t\"ZADD\", \"z\", \"CH\", \"1\", \"one\", \"2.2\", \"two\", \"3\", \"three\",\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZADD\", \"z\", \"NX\", \"1\", \"one\", \"2.2\", \"two\", \"3\", \"three\",\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZADD\", \"z\", \"GT\", \"1\", \"one\",\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZADD\", \"z\", \"GT\", \"2\", \"one\",\n\t\t)\n\n\t\tmust1(t, c,\n\t\t\t\"ZADD\", \"z\", \"NX\", \"1\", \"one\", \"4\", \"four\",\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZADD\", \"z\", \"XX\", \"1.1\", \"one\", \"4\", \"four\",\n\t\t)\n\n\t\tmust1(t, c,\n\t\t\t\"ZADD\", \"z\", \"XX\", \"CH\", \"1.2\", \"one\", \"4\", \"four\",\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"z\", \"INCR\", \"1.2\", \"one\",\n\t\t\tproto.String(\"2.4\"),\n\t\t)\n\n\t\tmustNil(t, c,\n\t\t\t\"ZADD\", \"z\", \"INCR\", \"NX\", \"1.2\", \"one\",\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"z\", \"INCR\", \"XX\", \"1.2\", \"one\",\n\t\t\tproto.String(\"3.5999999999999996\"),\n\t\t)\n\n\t\tmustNil(t, c,\n\t\t\t\"ZADD\", \"q\", \"INCR\", \"XX\", \"1.2\", \"one\",\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"q\", \"INCR\", \"NX\", \"1.2\", \"one\",\n\t\t\tproto.String(\"1.2\"),\n\t\t)\n\n\t\tmustNil(t, c,\n\t\t\t\"ZADD\", \"q\", \"INCR\", \"NX\", \"1.2\", \"one\",\n\t\t)\n\n\t\t// CH is ignored with INCR\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"z\", \"INCR\", \"CH\", \"1.2\", \"one\",\n\t\t\tproto.String(\"4.8\"),\n\t\t)\n\t}\n\n\tt.Run(\"LT and GT options\", func(t *testing.T) {\n\t\tmust1(t, c, \"ZADD\", \"zlt\", \"LT\", \"1\", \"one\")\n\t\tmust0(t, c, \"ZADD\", \"zlt\", \"LT\", \"2\", \"one\")\n\t\tmust1(t, c, \"ZADD\", \"zgt\", \"GT\", \"-1\", \"one\")\n\t\tmust0(t, c, \"ZADD\", \"zgt\", \"GT\", \"-2\", \"one\")\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\t// Wrong type of key\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\n\t\t_, err := s.ZAdd(\"str\", 1.0, \"hi\")\n\t\tmustFail(t, err, msgWrongType)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"str\", \"1.0\", \"hi\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\",\n\t\t\tproto.Error(errWrongNumber(\"zadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"1.0\",\n\t\t\tproto.Error(errWrongNumber(\"zadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"1.0\", \"foo\", \"1.0\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"MX\", \"1.0\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"1.0\", \"key\", \"MX\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"MX\", \"XX\", \"1.0\", \"foo\",\n\t\t\tproto.Error(\"ERR value is not a valid float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"INCR\", \"1.0\", \"foo\", \"2.3\", \"bar\",\n\t\t\tproto.Error(\"ERR INCR option supports a single increment-element pair\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"set\", \"GT\", \"LT\", \"1.0\", \"foo\",\n\t\t\tproto.Error(msgGTLTandNX),\n\t\t)\n\t})\n\n\tuseRESP3(t, c)\n\tt.Run(\"RESP3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZADD\", \"foo\", \"INCR\", \"1.2\", \"bar\",\n\t\t\tproto.Float(1.2),\n\t\t)\n\t})\n}\n\nfunc TestSortedSetRange(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"-1\",\n\t\t\tproto.Strings(\"one\", \"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"1\",\n\t\t\tproto.Strings(\"one\", \"two\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"-1\", \"-1\",\n\t\t\tproto.Strings(\"inf\"),\n\t\t)\n\t\t// weird cases.\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"-100\", \"-100\",\n\t\t\tproto.Strings(),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"100\", \"400\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\t// Nonexistent key\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"nosuch\", \"1\", \"4\",\n\t\t\tproto.Strings(),\n\t\t)\n\t})\n\n\tt.Run(\"withscores\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"1\", \"2\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"two\", \"2\", \"zwei\", \"2\"),\n\t\t)\n\t\t// INF in WITHSCORES\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"4\", \"-1\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"three\", \"3\", \"inf\", \"inf\"),\n\t\t)\n\t})\n\n\tt.Run(\"reverse\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"-1\", \"REV\",\n\t\t\tproto.Strings(\"inf\", \"three\", \"drei\", \"zwei\", \"two\", \"one\"),\n\t\t)\n\t})\n\n\tt.Run(\"limit\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"+inf\", \"BYSCORE\", \"LIMIT\", \"1\", \"2\",\n\t\t\tproto.Strings(\"two\", \"zwei\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"+inf\", \"BYSCORE\", \"LIMIT\", \"1\", \"-1\",\n\t\t\tproto.Strings(\"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"+inf\", \"BYSCORE\", \"LIMIT\", \"1\", \"9999\",\n\t\t\tproto.Strings(\"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\",\n\t\t\tproto.Error(errWrongNumber(\"zrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"set\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"zrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"set\", \"noint\", \"1\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"set\", \"1\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"set\", \"1\", \"2\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"set\", \"1\", \"2\", \"LIMIT\", \"1\", \"2\",\n\t\t\tproto.Error(msgLimitCombination),\n\t\t)\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"str\", \"1\", \"2\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZREVRANGE\nfunc TestSortedSetRevRange(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"z\", \"0\", \"-1\",\n\t\tproto.Strings(\"inf\", \"three\", \"drei\", \"zwei\", \"two\", \"one\"),\n\t)\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"z\", \"0\", \"1\",\n\t\tproto.Strings(\"inf\", \"three\"),\n\t)\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"z\", \"-1\", \"-1\",\n\t\tproto.Strings(\"one\"),\n\t)\n\n\t// weird cases.\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"z\", \"-100\", \"-100\",\n\t\tproto.Strings(),\n\t)\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"z\", \"100\", \"400\",\n\t\tproto.Strings(),\n\t)\n\n\t// Nonexistent key\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"nosuch\", \"1\", \"4\",\n\t\tproto.Strings(),\n\t)\n\n\t// With scores\n\tmustDo(t, c,\n\t\t\"ZREVRANGE\", \"z\", \"1\", \"2\", \"WITHSCORES\",\n\t\tproto.Strings(\"three\", \"3\", \"drei\", \"3\"),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\",\n\t\t\tproto.Error(errWrongNumber(\"zrevrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zrevrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\", \"set\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"zrevrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\", \"set\", \"noint\", \"1\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\", \"set\", \"1\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\", \"set\", \"1\", \"2\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGE\", \"str\", \"1\", \"2\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZRANGEBYSCORE,  ZREVRANGEBYSCORE, and ZCOUNT\nfunc TestSortedSetRangeByScore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", -273.15, \"zero kelvin\")\n\ts.ZAdd(\"z\", -4, \"minusfour\")\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\t// Normal cases\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"-inf\", \"inf\",\n\t\t\tproto.Strings(\"zero kelvin\", \"minusfour\", \"one\", \"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\", \"z\", \"inf\", \"-inf\",\n\t\t\tproto.Strings(\"inf\", \"three\", \"drei\", \"zwei\", \"two\", \"one\", \"minusfour\", \"zero kelvin\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCOUNT\", \"z\", \"-inf\", \"inf\",\n\t\t\tproto.Int(8),\n\t\t)\n\t}\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"2\", \"3\",\n\t\t\tproto.Strings(\"two\", \"zwei\", \"drei\", \"three\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"4\", \"4\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\", \"z\", \"3\", \"2\",\n\t\t\tproto.Strings(\"three\", \"drei\", \"zwei\", \"two\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\", \"z\", \"4\", \"4\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCOUNT\", \"z\", \"2\", \"3\",\n\t\t\tproto.Int(4),\n\t\t)\n\t}\n\t// Exclusive min\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"(2\", \"3\",\n\t\t\tproto.Strings(\"drei\", \"three\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCOUNT\", \"z\", \"(2\", \"3\",\n\t\t\tproto.Int(2),\n\t\t)\n\t}\n\t// Exclusive max\n\tmustDo(t, c,\n\t\t\"ZRANGEBYSCORE\", \"z\", \"2\", \"(3\",\n\t\tproto.Strings(\"two\", \"zwei\"),\n\t)\n\n\t// Exclusive both\n\tmustDo(t, c,\n\t\t\"ZRANGEBYSCORE\", \"z\", \"(2\", \"(3\",\n\t\tproto.Strings(),\n\t)\n\n\t// Wrong ranges\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"+inf\", \"-inf\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\", \"z\", \"-inf\", \"+inf\",\n\t\t\tproto.Strings(),\n\t\t)\n\t}\n\n\t// No such key\n\tmustDo(t, c,\n\t\t\"ZRANGEBYSCORE\", \"nosuch\", \"-inf\", \"inf\",\n\t\tproto.Strings(),\n\t)\n\n\t// With scores\n\tmustDo(t, c,\n\t\t\"ZRANGEBYSCORE\", \"z\", \"(1\", \"2\", \"WITHSCORES\",\n\t\tproto.Strings(\"two\", \"2\", \"zwei\", \"2\"),\n\t)\n\n\t// With LIMIT\n\t// (note, this is SQL like logic, not the redis RANGE logic)\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"-inf\", \"inf\", \"LIMIT\", \"1\", \"2\",\n\t\t\tproto.Strings(\"minusfour\", \"one\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\", \"z\", \"inf\", \"-inf\", \"LIMIT\", \"1\", \"2\",\n\t\t\tproto.Strings(\"three\", \"drei\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"1\", \"inf\", \"LIMIT\", \"1\", \"2000\",\n\t\t\tproto.Strings(\"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\", \"z\", \"inf\", \"1\", \"LIMIT\", \"1\", \"2000\",\n\t\t\tproto.Strings(\"three\", \"drei\", \"zwei\", \"two\", \"one\"),\n\t\t)\n\n\t\t// Negative start limit. No go.\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"-inf\", \"inf\", \"LIMIT\", \"-1\", \"2\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\t// Negative end limit. Is fine but ignored.\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"-inf\", \"inf\", \"LIMIT\", \"1\", \"-2\",\n\t\t\tproto.Strings(\"minusfour\", \"one\", \"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\t}\n\t// Everything\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"-inf\", \"inf\", \"WITHSCORES\", \"LIMIT\", \"1\", \"2\",\n\t\t\tproto.Strings(\"minusfour\", \"-4\", \"one\", \"1\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"z\", \"-inf\", \"inf\", \"LIMIT\", \"1\", \"2\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"minusfour\", \"-4\", \"one\", \"1\"),\n\t\t)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\",\n\t\t\tproto.Error(errWrongNumber(\"zrangebyscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zrangebyscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"zrangebyscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"nofloat\", \"1\",\n\t\t\tproto.Error(\"ERR min or max is not a float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"1\", \"nofloat\",\n\t\t\tproto.Error(\"ERR min or max is not a float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"1\", \"2\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"[1\", \"2\",\n\t\t\tproto.Error(\"ERR min or max is not a float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"1\", \"[2\",\n\t\t\tproto.Error(\"ERR min or max is not a float\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"[1\", \"2\", \"LIMIT\", \"noint\", \"1\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"set\", \"[1\", \"2\", \"LIMIT\", \"1\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYSCORE\", \"str\", \"1\", \"2\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYSCORE\",\n\t\t\tproto.Error(errWrongNumber(\"zrevrangebyscore\")),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZCOUNT\",\n\t\t\tproto.Error(errWrongNumber(\"zcount\")),\n\t\t)\n\t})\n}\n\nfunc TestIssue10(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"key\", 3.3, \"element\")\n\n\tmustDo(t, c,\n\t\t\"ZRANGEBYSCORE\", \"key\", \"3.3\", \"3.3\",\n\t\tproto.Strings(\"element\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"ZRANGEBYSCORE\", \"key\", \"4.3\", \"4.3\",\n\t\tproto.Strings(),\n\t)\n}\n\n// Test ZREM\nfunc TestSortedSetRem(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\n\t// Simple delete\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZREM\", \"z\", \"two\", \"zwei\", \"nosuch\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\tassert(t, s.Exists(\"z\"), \"key is there\")\n\t}\n\t// Delete the last member\n\t{\n\t\tmust1(t, c,\n\t\t\t\"ZREM\", \"z\", \"one\",\n\t\t)\n\t\tassert(t, !s.Exists(\"z\"), \"key is gone\")\n\t}\n\t// Nonexistent key\n\tmust0(t, c,\n\t\t\"ZREM\", \"nosuch\", \"member\",\n\t)\n\n\t// Direct\n\t{\n\t\ts.ZAdd(\"z2\", 1, \"one\")\n\t\ts.ZAdd(\"z2\", 2, \"two\")\n\t\ts.ZAdd(\"z2\", 2, \"zwei\")\n\t\tgone, err := s.ZRem(\"z2\", \"two\")\n\t\tok(t, err)\n\t\tassert(t, gone, \"member gone\")\n\t\tmembers, err := s.ZMembers(\"z2\")\n\t\tok(t, err)\n\t\tequals(t, []string{\"one\", \"zwei\"}, members)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZREM\",\n\t\t\tproto.Error(errWrongNumber(\"zrem\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREM\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zrem\")),\n\t\t)\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZREM\", \"str\", \"aap\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZREMRANGEBYLEX\nfunc TestSortedSetRemRangeByLex(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 12, \"zero kelvin\")\n\ts.ZAdd(\"z\", 12, \"minusfour\")\n\ts.ZAdd(\"z\", 12, \"one\")\n\ts.ZAdd(\"z\", 12, \"oneone\")\n\ts.ZAdd(\"z\", 12, \"two\")\n\ts.ZAdd(\"z\", 12, \"zwei\")\n\ts.ZAdd(\"z\", 12, \"three\")\n\ts.ZAdd(\"z\", 12, \"drei\")\n\ts.ZAdd(\"z\", 12, \"inf\")\n\n\t// Inclusive range\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"z\", \"[o\", \"[three\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmembers, err := s.ZMembers(\"z\")\n\t\tok(t, err)\n\t\tequals(t,\n\t\t\t[]string{\"drei\", \"inf\", \"minusfour\", \"two\", \"zero kelvin\", \"zwei\"},\n\t\t\tmembers,\n\t\t)\n\t}\n\n\t// Wrong ranges\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYLEX\", \"z\", \"+\", \"(z\",\n\t)\n\n\t// No such key\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYLEX\", \"nosuch\", \"-\", \"+\",\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebylex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebylex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"set\", \"1\", \"[a\",\n\t\t\tproto.Error(\"ERR min or max not valid string range item\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"set\", \"[a\", \"1\",\n\t\t\tproto.Error(\"ERR min or max not valid string range item\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"set\", \"[a\", \"!a\",\n\t\t\tproto.Error(\"ERR min or max not valid string range item\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"set\", \"-\", \"+\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebylex\")),\n\t\t)\n\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYLEX\", \"str\", \"-\", \"+\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZREMRANGEBYRANK\nfunc TestSortedSetRemRangeByRank(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"z\", \"-2\", \"-1\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"-1\",\n\t\t\tproto.Strings(\"one\", \"two\", \"zwei\", \"drei\"),\n\t\t)\n\t}\n\n\t// weird cases.\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYRANK\", \"z\", \"-100\", \"-100\",\n\t)\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYRANK\", \"z\", \"100\", \"400\",\n\t)\n\n\t// Nonexistent key\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYRANK\", \"nosuch\", \"1\", \"4\",\n\t)\n\n\t// Delete all. Key should be gone.\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"z\", \"0\", \"-1\",\n\t\t\tproto.Int(4),\n\t\t)\n\t\tequals(t, false, s.Exists(\"z\"))\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyrank\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyrank\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"set\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyrank\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"set\", \"noint\", \"1\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"set\", \"1\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"set\", \"1\", \"2\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyrank\")),\n\t\t)\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYRANK\", \"str\", \"1\", \"2\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZREMRANGEBYSCORE\nfunc TestSortedSetRangeRemByScore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", -273.15, \"zero kelvin\")\n\ts.ZAdd(\"z\", -4, \"minusfour\")\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\t// Normal cases\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"z\", \"-inf\", \"1\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"-1\",\n\t\t\tproto.Strings(\"two\", \"zwei\", \"drei\", \"three\", \"inf\"),\n\t\t)\n\t}\n\t// Exclusive min\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"z\", \"(2\", \"(4\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGE\", \"z\", \"0\", \"-1\",\n\t\t\tproto.Strings(\"two\", \"zwei\", \"inf\"),\n\t\t)\n\t}\n\n\t// Wrong ranges\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYSCORE\", \"z\", \"+inf\", \"-inf\",\n\t)\n\n\t// No such key\n\tmust0(t, c,\n\t\t\"ZREMRANGEBYSCORE\", \"nosuch\", \"-inf\", \"inf\",\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"set\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"set\", \"nofloat\", \"1\",\n\t\t\tproto.Error(msgInvalidMinMax),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"set\", \"1\", \"nofloat\",\n\t\t\tproto.Error(msgInvalidMinMax),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"set\", \"1\", \"2\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"zremrangebyscore\")),\n\t\t)\n\t\t// Wrong type of key\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZREMRANGEBYSCORE\", \"str\", \"1\", \"2\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZSCORE\nfunc TestSortedSetScore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\n\t// Simple case\n\tmustDo(t, c,\n\t\t\"ZSCORE\", \"z\", \"two\",\n\t\tproto.String(\"2\"),\n\t)\n\n\t// no such member\n\tmustNil(t, c,\n\t\t\"ZSCORE\", \"z\", \"nosuch\",\n\t)\n\n\t// no such key\n\tmustNil(t, c,\n\t\t\"ZSCORE\", \"nosuch\", \"nosuch\",\n\t)\n\n\t// Direct\n\t{\n\t\ts.ZAdd(\"z2\", 1, \"one\")\n\t\ts.ZAdd(\"z2\", 2, \"two\")\n\t\ts.ZAdd(\"z2\", 0.000000000000000000000000000000000000000000000000000000000000000025339988685347402, \"small\")\n\t\tscore, err := s.ZScore(\"z2\", \"two\")\n\t\tok(t, err)\n\t\tequals(t, 2.0, score)\n\n\t\tscore, err = s.ZScore(\"z2\", \"small\")\n\t\tok(t, err)\n\t\tequals(t, 0.000000000000000000000000000000000000000000000000000000000000000025339988685347402, score)\n\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZSCORE\",\n\t\t\tproto.Error(errWrongNumber(\"zscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCORE\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"zscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCORE\", \"too\", \"many\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"zscore\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZSCORE\", \"str\", \"aap\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZMSCORE\nfunc TestSortedSetMultiScore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\n\t// One member only\n\tmustDo(t, c,\n\t\t\"ZMSCORE\", \"z\", \"two\",\n\t\tproto.Strings(\"2\"),\n\t)\n\n\t// Two members\n\tmustDo(t, c,\n\t\t\"ZMSCORE\", \"z\", \"one\", \"two\",\n\t\tproto.Strings(\"1\", \"2\"),\n\t)\n\n\t// Three members\n\tmustDo(t, c,\n\t\t\"ZMSCORE\", \"z\", \"one\", \"two\", \"zwei\",\n\t\tproto.Strings(\"1\", \"2\", \"2\"),\n\t)\n\n\t// No such member\n\tmustDo(t, c, \"ZMSCORE\", \"z\", \"nosuch\",\n\t\tproto.Array(proto.Nil),\n\t)\n\n\t// One member exists, one doesn't\n\tmustDo(t, c, \"ZMSCORE\", \"z\", \"nosuch\", \"two\",\n\t\tproto.Array(proto.Nil, proto.String(\"2\")),\n\t)\n\n\t// No such key\n\tmustNil(t, c,\n\t\t\"ZSCORE\", \"nosuch\", \"nosuch\",\n\t)\n\n\t// Direct\n\t{\n\t\ts.ZAdd(\"z2\", 1, \"one\")\n\t\ts.ZAdd(\"z2\", 2, \"two\")\n\t\tscores, err := s.ZMScore(\"z2\", \"one\", \"two\")\n\t\tok(t, err)\n\t\tequals(t, []float64{1.0, 2.0}, scores)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZMSCORE\",\n\t\t\tproto.Error(errWrongNumber(\"zmscore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZMSCORE\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"zmscore\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZMSCORE\", \"str\", \"aap\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZRANGEBYLEX, ZREVRANGEBYLEX, ZLEXCOUNT\nfunc TestSortedSetRangeByLex(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 12, \"zero kelvin\")\n\ts.ZAdd(\"z\", 12, \"minusfour\")\n\ts.ZAdd(\"z\", 12, \"one\")\n\ts.ZAdd(\"z\", 12, \"oneone\")\n\ts.ZAdd(\"z\", 12, \"two\")\n\ts.ZAdd(\"z\", 12, \"zwei\")\n\ts.ZAdd(\"z\", 12, \"three\")\n\ts.ZAdd(\"z\", 12, \"drei\")\n\ts.ZAdd(\"z\", 12, \"inf\")\n\n\t// Normal cases\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"-\", \"+\",\n\t\t\tproto.Strings(\n\t\t\t\t\"drei\",\n\t\t\t\t\"inf\",\n\t\t\t\t\"minusfour\",\n\t\t\t\t\"one\",\n\t\t\t\t\"oneone\",\n\t\t\t\t\"three\",\n\t\t\t\t\"two\",\n\t\t\t\t\"zero kelvin\",\n\t\t\t\t\"zwei\",\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"[zz\", \"+\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYLEX\", \"z\", \"+\", \"-\",\n\t\t\tproto.Strings(\n\t\t\t\t\"zwei\",\n\t\t\t\t\"zero kelvin\",\n\t\t\t\t\"two\",\n\t\t\t\t\"three\",\n\t\t\t\t\"oneone\",\n\t\t\t\t\"one\",\n\t\t\t\t\"minusfour\",\n\t\t\t\t\"inf\",\n\t\t\t\t\"drei\",\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"z\", \"-\", \"+\",\n\t\t\tproto.Int(9),\n\t\t)\n\t}\n\n\t// Inclusive range\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"[o\", \"[three\",\n\t\t\tproto.Strings(\"one\", \"oneone\", \"three\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYLEX\", \"z\", \"[three\", \"[o\",\n\t\t\tproto.Strings(\"three\", \"oneone\", \"one\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"z\", \"[o\", \"[three\",\n\t\t\tproto.Int(3),\n\t\t)\n\t}\n\n\t// Exclusive range\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"(o\", \"(z\",\n\t\t\tproto.Strings(\"one\", \"oneone\", \"three\", \"two\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYLEX\", \"z\", \"(z\", \"(o\",\n\t\t\tproto.Strings(\"two\", \"three\", \"oneone\", \"one\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"z\", \"(o\", \"(z\",\n\t\t\tproto.Int(4),\n\t\t)\n\t}\n\n\t// Wrong ranges\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"+\", \"(z\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYLEX\", \"z\", \"(z\", \"+\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"(a\", \"-\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZREVRANGEBYLEX\", \"z\", \"-\", \"(a\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"(z\", \"(a\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZLEXCOUNT\", \"z\", \"(z\", \"(z\",\n\t\t)\n\t}\n\n\t// No such key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"nosuch\", \"-\", \"+\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"ZLEXCOUNT\", \"nosuch\", \"-\", \"+\",\n\t\t)\n\t}\n\n\t// With LIMIT\n\t// (note, this is SQL like logic, not the redis RANGE logic)\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"-\", \"+\", \"LIMIT\", \"1\", \"2\",\n\t\t\tproto.Strings(\"inf\", \"minusfour\"),\n\t\t)\n\n\t\t// Negative start limit. No go.\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"-\", \"+\", \"LIMIT\", \"-1\", \"2\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\t// Negative end limit. Is fine but ignored.\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"z\", \"-\", \"+\", \"LIMIT\", \"1\", \"-2\",\n\t\t\tproto.Strings(\"inf\", \"minusfour\", \"one\", \"oneone\", \"three\", \"two\", \"zero kelvin\", \"zwei\"),\n\t\t)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\",\n\t\t\tproto.Error(errWrongNumber(\"zrangebylex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zrangebylex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\", \"1\", \"[a\",\n\t\t\tproto.Error(msgInvalidRangeItem),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\", \"[a\", \"1\",\n\t\t\tproto.Error(msgInvalidRangeItem),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\", \"[a\", \"!a\",\n\t\t\tproto.Error(msgInvalidRangeItem),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\", \"-\", \"+\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\", \"[1\", \"(1\", \"LIMIT\", \"noint\", \"1\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"set\", \"[1\", \"(1\", \"LIMIT\", \"1\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZRANGEBYLEX\", \"str\", \"-\", \"+\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\",\n\t\t\tproto.Error(errWrongNumber(\"zlexcount\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"k\",\n\t\t\tproto.Error(errWrongNumber(\"zlexcount\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"k\", \"[a\", \"a\",\n\t\t\tproto.Error(msgInvalidRangeItem),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"k\", \"a\", \"(a\",\n\t\t\tproto.Error(msgInvalidRangeItem),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZLEXCOUNT\", \"k\", \"(a\", \"(a\", \"toomany\",\n\t\t\tproto.Error(errWrongNumber(\"zlexcount\")),\n\t\t)\n\t})\n}\n\n// Test ZINCRBY\nfunc TestSortedSetIncrby(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Normal cases\n\t{\n\t\t// New key\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"z\", \"1\", \"member\",\n\t\t\tproto.String(\"1\"),\n\t\t)\n\n\t\t// Existing key\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"z\", \"2.5\", \"member\",\n\t\t\tproto.String(\"3.5\"),\n\t\t)\n\n\t\t// New member\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"z\", \"1\", \"othermember\",\n\t\t\tproto.String(\"1\"),\n\t\t)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\",\n\t\t\tproto.Error(errWrongNumber(\"zincrby\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zincrby\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"set\", \"nofloat\", \"a\",\n\t\t\tproto.Error(msgInvalidFloat),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"set\", \"1.0\", \"too\", \"many\",\n\t\t\tproto.Error(errWrongNumber(\"zincrby\")),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZINCRBY\", \"str\", \"1.0\", \"member\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestZscan(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// We cheat with zscan. It always returns everything.\n\n\ts.ZAdd(\"h\", 1.0, \"field1\")\n\ts.ZAdd(\"h\", 2.0, \"field2\")\n\n\t// No problem\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"h\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"field1\"),\n\t\t\t\tproto.String(\"1\"),\n\t\t\t\tproto.String(\"field2\"),\n\t\t\t\tproto.String(\"2\"),\n\t\t\t),\n\t\t),\n\t)\n\n\t// Invalid cursor\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"h\", \"42\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\n\t// COUNT (ignored)\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"h\", \"0\", \"COUNT\", \"200\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"field1\"),\n\t\t\t\tproto.String(\"1\"),\n\t\t\t\tproto.String(\"field2\"),\n\t\t\t\tproto.String(\"2\"),\n\t\t\t),\n\t\t),\n\t)\n\n\t// MATCH\n\ts.ZAdd(\"h\", 3.0, \"aap\")\n\ts.ZAdd(\"h\", 4.0, \"noot\")\n\ts.ZAdd(\"h\", 5.0, \"mies\")\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"h\", \"0\", \"MATCH\", \"mi*\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"mies\"),\n\t\t\t\tproto.String(\"5\"),\n\t\t\t),\n\t\t),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\",\n\t\t\tproto.Error(errWrongNumber(\"zscan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zscan\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\", \"noint\",\n\t\t\tproto.Error(\"ERR invalid cursor\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\", \"0\", \"MATCH\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\", \"0\", \"COUNT\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\", \"0\", \"COUNT\", \"0\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\", \"0\", \"COUNT\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"set\", \"0\", \"COUNT\", \"-3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZSCAN\", \"str\", \"0\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n\n\ts.ZAdd(\"largeset\", 1.0, \"v1\")\n\ts.ZAdd(\"largeset\", 2.0, \"v2\")\n\ts.ZAdd(\"largeset\", 3.0, \"v3\")\n\ts.ZAdd(\"largeset\", 4.0, \"v4\")\n\ts.ZAdd(\"largeset\", 5.0, \"v5\")\n\ts.ZAdd(\"largeset\", 6.0, \"v6\")\n\ts.ZAdd(\"largeset\", 7.0, \"v7\")\n\ts.ZAdd(\"largeset\", 8.0, \"v8\")\n\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"largeset\", \"0\", \"COUNT\", \"3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"3\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"v1\"),\n\t\t\t\tproto.String(\"1\"),\n\t\t\t\tproto.String(\"v2\"),\n\t\t\t\tproto.String(\"2\"),\n\t\t\t\tproto.String(\"v3\"),\n\t\t\t\tproto.String(\"3\"),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"largeset\", \"3\", \"COUNT\", \"3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"6\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"v4\"),\n\t\t\t\tproto.String(\"4\"),\n\t\t\t\tproto.String(\"v5\"),\n\t\t\t\tproto.String(\"5\"),\n\t\t\t\tproto.String(\"v6\"),\n\t\t\t\tproto.String(\"6\"),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"ZSCAN\", \"largeset\", \"6\", \"COUNT\", \"3\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"v7\"),\n\t\t\t\tproto.String(\"7\"),\n\t\t\t\tproto.String(\"v8\"),\n\t\t\t\tproto.String(\"8\"),\n\t\t\t),\n\t\t),\n\t)\n}\n\nfunc TestZunionstore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"h1\", 1.0, \"field1\")\n\ts.ZAdd(\"h1\", 2.0, \"field2\")\n\ts.ZAdd(\"h2\", 1.0, \"field1\")\n\ts.ZAdd(\"h2\", 2.0, \"field2\")\n\n\tt.Run(\"simple case\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"new\", \"2\", \"h1\", \"h2\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"new\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 2, \"field2\": 4}, ss)\n\t})\n\n\tt.Run(\"merge destination with itself\", func(t *testing.T) {\n\t\ts.ZAdd(\"h3\", 1.0, \"field1\")\n\t\ts.ZAdd(\"h3\", 3.0, \"field3\")\n\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"h3\", \"2\", \"h1\", \"h3\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"h3\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 2, \"field2\": 2, \"field3\": 3}, ss)\n\t})\n\n\tt.Run(\"WEIGHTS\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"weighted\", \"2\", \"h1\", \"h2\", \"WeIgHtS\", \"4.5\", \"12\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"weighted\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 16.5, \"field2\": 33}, ss)\n\t})\n\n\tt.Run(\"AGGREGATE\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"aggr\", \"2\", \"h1\", \"h2\", \"AgGrEgAtE\", \"min\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"aggr\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 1.0, \"field2\": 2.0}, ss)\n\t})\n\n\tt.Run(\"normal set\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SADD\", \"set\", \"aap\", \"noot\", \"mies\",\n\t\t\tproto.Int(3),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"aggr\", \"1\", \"set\",\n\t\t\tproto.Int(3),\n\t\t)\n\t})\n\n\tt.Run(\"wrong usage\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\",\n\t\t\tproto.Error(errWrongNumber(\"zunionstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zunionstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"noint\",\n\t\t\tproto.Error(errWrongNumber(\"zunionstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"0\", \"key\",\n\t\t\tproto.Error(\"ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"-1\", \"key\",\n\t\t\tproto.Error(\"ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"1\", \"too\", \"many\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"key\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"WEIGHTS\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"WEIGHTS\", \"1\", \"2\", \"3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"WEIGHTS\", \"1\", \"nof\",\n\t\t\tproto.Error(\"ERR weight value is not a float\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"AGGREGATE\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"AGGREGATE\", \"foo\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"AGGREGATE\", \"sum\", \"foo\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZUNIONSTORE\", \"set\", \"1\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestZunion(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"h1\", 1.0, \"field1\")\n\ts.ZAdd(\"h1\", 2.0, \"field2\")\n\ts.ZAdd(\"h2\", 1.0, \"field1\")\n\ts.ZAdd(\"h2\", 2.0, \"field2\")\n\n\tt.Run(\"simple case\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"h1\", \"h2\", proto.Strings(\"field1\", \"field2\"),\n\t\t)\n\t})\n\n\tt.Run(\"WITHSCORES\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"h1\", \"h2\", \"WITHSCORES\", proto.Strings(\"field1\", \"2\", \"field2\", \"4\"),\n\t\t)\n\t})\n\n\tt.Run(\"WEIGHTS\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"h1\", \"h2\", \"WeiGHtS\", \"4.5\", \"12\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"field1\", \"16.5\", \"field2\", \"33\"),\n\t\t)\n\t})\n\n\tt.Run(\"AGGREGATE\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"h1\", \"h2\", \"AgGrEgAtE\", \"min\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"field1\", \"1\", \"field2\", \"2\"),\n\t\t)\n\t})\n\n\tt.Run(\"wrong usage\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\",\n\t\t\tproto.Error(errWrongNumber(\"zunion\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\",\n\t\t\tproto.Error(errWrongNumber(\"zunion\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"noint\",\n\t\t\tproto.Error(errWrongNumber(\"zunion\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"0\", \"key\",\n\t\t\tproto.Error(\"ERR at least 1 input key is needed for ZUNION\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"-1\", \"key\",\n\t\t\tproto.Error(\"ERR at least 1 input key is needed for ZUNION\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"1\", \"too\", \"many\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"key\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"k1\", \"k2\", \"WEIGHTS\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"k1\", \"k2\", \"WEIGHTS\", \"1\", \"2\", \"3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"k1\", \"k2\", \"WEIGHTS\", \"1\", \"nof\",\n\t\t\tproto.Error(\"ERR weight value is not a float\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"k1\", \"k2\", \"AGGREGATE\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"k1\", \"k2\", \"AGGREGATE\", \"foo\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZUNION\", \"2\", \"k1\", \"k2\", \"AGGREGATE\", \"sum\", \"foo\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n}\n\nfunc TestZinter(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"h1\", 1.0, \"field1\")\n\ts.ZAdd(\"h1\", 2.0, \"field2\")\n\ts.ZAdd(\"h1\", 3.0, \"field3\")\n\ts.ZAdd(\"h2\", 1.0, \"field1\")\n\ts.ZAdd(\"h2\", 2.0, \"field2\")\n\ts.ZAdd(\"h2\", 4.0, \"field4\")\n\ts.SAdd(\"s2\", \"field1\")\n\n\t// Simple case\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZINTER\", \"2\", \"h1\", \"h2\",\n\t\t\tproto.Strings(\"field1\", \"field2\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTER\", \"2\", \"h1\", \"h2\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"field1\", \"2\", \"field2\", \"4\"),\n\t\t)\n\t}\n\t// it's the same code as ZINTERSTORE, so see TestZinterstore()\n}\n\nfunc TestZinterstore(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"h1\", 1.0, \"field1\")\n\ts.ZAdd(\"h1\", 2.0, \"field2\")\n\ts.ZAdd(\"h1\", 3.0, \"field3\")\n\ts.ZAdd(\"h2\", 1.0, \"field1\")\n\ts.ZAdd(\"h2\", 2.0, \"field2\")\n\ts.ZAdd(\"h2\", 4.0, \"field4\")\n\ts.SAdd(\"s2\", \"field1\")\n\n\t// Simple case\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"new\", \"2\", \"h1\", \"h2\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"new\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 2, \"field2\": 4}, ss)\n\t}\n\n\t// WEIGHTS\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"weighted\", \"2\", \"h1\", \"h2\", \"WeIgHtS\", \"4.5\", \"12\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"weighted\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 16.5, \"field2\": 33}, ss)\n\t}\n\n\t// AGGREGATE\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"aggr\", \"2\", \"h1\", \"h2\", \"AgGrEgAtE\", \"min\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"aggr\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 1.0, \"field2\": 2.0}, ss)\n\t}\n\n\t// compatible set\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"cnew\", \"2\", \"h1\", \"s2\",\n\t\t\tproto.Int(1),\n\t\t)\n\n\t\tss, err := s.SortedSet(\"cnew\")\n\t\tok(t, err)\n\t\tequals(t, map[string]float64{\"field1\": 2}, ss)\n\t}\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\",\n\t\t\tproto.Error(errWrongNumber(\"zinterstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\",\n\t\t\tproto.Error(errWrongNumber(\"zinterstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"noint\",\n\t\t\tproto.Error(errWrongNumber(\"zinterstore\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"0\", \"key\",\n\t\t\tproto.Error(\"ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"-1\", \"key\",\n\t\t\tproto.Error(\"ERR at least 1 input key is needed for ZUNIONSTORE/ZINTERSTORE\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"1\", \"too\", \"many\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"key\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"WEIGHTS\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"WEIGHTS\", \"1\", \"2\", \"3\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"WEIGHTS\", \"1\", \"nof\",\n\t\t\tproto.Error(\"ERR weight value is not a float\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"AGGREGATE\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"AGGREGATE\", \"foo\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"k1\", \"k2\", \"AGGREGATE\", \"sum\", \"foo\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"1\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZINTERSTORE\", \"set\", \"2\", \"set\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestSSRange(t *testing.T) {\n\tss := newSortedSet()\n\tss.set(1.0, \"key1\")\n\tss.set(5.0, \"key5\")\n\telems := ss.byScore(asc)\n\ttype cas struct {\n\t\tmin, max       float64\n\t\tminInc, maxInc bool\n\t\twant           []string\n\t}\n\tfor _, c := range []cas{\n\t\t{\n\t\t\tmin:    2.0,\n\t\t\tminInc: true,\n\t\t\tmax:    3.0,\n\t\t\tmaxInc: true,\n\t\t\twant:   []string(nil),\n\t\t},\n\t\t{\n\t\t\tmin:    -2.0,\n\t\t\tminInc: true,\n\t\t\tmax:    -3.0,\n\t\t\tmaxInc: true,\n\t\t\twant:   []string(nil),\n\t\t},\n\t\t{\n\t\t\tmin:    12.0,\n\t\t\tminInc: true,\n\t\t\tmax:    13.0,\n\t\t\tmaxInc: true,\n\t\t\twant:   []string(nil),\n\t\t},\n\t\t{\n\t\t\tmin:    1.0,\n\t\t\tminInc: false,\n\t\t\tmax:    3.0,\n\t\t\tmaxInc: true,\n\t\t\twant:   []string(nil),\n\t\t},\n\t\t{\n\t\t\tmin:    2.0,\n\t\t\tminInc: true,\n\t\t\tmax:    5.0,\n\t\t\tmaxInc: false,\n\t\t\twant:   []string(nil),\n\t\t},\n\t\t{\n\t\t\tmin:  0.0,\n\t\t\tmax:  2.0,\n\t\t\twant: []string{\"key1\"},\n\t\t},\n\t\t{\n\t\t\tmin:  2.0,\n\t\t\tmax:  7.0,\n\t\t\twant: []string{\"key5\"},\n\t\t},\n\t\t{\n\t\t\tmin:  0.0,\n\t\t\tmax:  7.0,\n\t\t\twant: []string{\"key1\", \"key5\"},\n\t\t},\n\t\t{\n\t\t\tmin:    1.0,\n\t\t\tminInc: false,\n\t\t\tmax:    5.0,\n\t\t\tmaxInc: false,\n\t\t\twant:   []string(nil),\n\t\t},\n\t} {\n\t\tvar have []string\n\t\tfor _, v := range withSSRange(elems, c.min, c.minInc, c.max, c.maxInc) {\n\t\t\thave = append(have, v.member)\n\t\t}\n\t\tequals(t, have, c.want)\n\t}\n}\n\n// Test ZPOPMIN\nfunc TestSortedSetPopMin(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\tmustDo(t, c,\n\t\t\"ZPOPMIN\", \"z\", \"2\",\n\t\tproto.Strings(\"one\", \"1\", \"two\", \"2\"),\n\t)\n\n\t// Get one - without count\n\tmustDo(t, c,\n\t\t\"ZPOPMIN\", \"z\",\n\t\tproto.Strings(\"zwei\", \"2\"),\n\t)\n\n\t// Nonexistent key\n\tmustDo(t, c,\n\t\t\"ZPOPMIN\", \"nosuch\", \"1\",\n\t\tproto.Strings(),\n\t)\n\n\t// Get more than exist\n\tmustDo(t, c,\n\t\t\"ZPOPMIN\", \"z\", \"100\",\n\t\tproto.Strings(\"drei\", \"3\", \"three\", \"3\", \"inf\", \"inf\"),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMIN\",\n\t\t\tproto.Error(errWrongNumber(\"zpopmin\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMIN\", \"z\", \"-100\",\n\t\t\tproto.Error(msgInvalidRange),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMIN\", \"set\", \"noint\",\n\t\t\tproto.Error(msgInvalidRange),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMIN\", \"set\", \"1\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMIN\", \"str\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZPOPMAX\nfunc TestSortedSetPopMax(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\ts.ZAdd(\"z\", math.Inf(+1), \"inf\")\n\n\tmustDo(t, c,\n\t\t\"ZPOPMAX\", \"z\", \"2\",\n\t\tproto.Strings(\"inf\", \"inf\", \"three\", \"3\"),\n\t)\n\n\t// Get one - without count\n\tmustDo(t, c,\n\t\t\"ZPOPMAX\", \"z\",\n\t\tproto.Strings(\"drei\", \"3\"),\n\t)\n\n\t// Nonexistent key\n\tmustDo(t, c,\n\t\t\"ZPOPMAX\", \"nosuch\", \"1\",\n\t\tproto.Strings(),\n\t)\n\n\t// Get more than exist\n\tmustDo(t, c,\n\t\t\"ZPOPMAX\", \"z\", \"100\",\n\t\tproto.Strings(\"zwei\", \"2\", \"two\", \"2\", \"one\", \"1\"),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMAX\",\n\t\t\tproto.Error(errWrongNumber(\"zpopmax\")),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMAX\", \"z\", \"-100\",\n\t\t\tproto.Error(msgInvalidRange),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMAX\", \"set\", \"noint\",\n\t\t\tproto.Error(msgInvalidRange),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMAX\", \"set\", \"1\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZPOPMAX\", \"str\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test ZRANDMEMBER\nfunc TestSortedSetRandmember(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.ZAdd(\"z\", 1, \"one\")\n\ts.ZAdd(\"z\", 2, \"two\")\n\ts.ZAdd(\"z\", 2, \"zwei\")\n\ts.ZAdd(\"z\", 3, \"three\")\n\ts.ZAdd(\"z\", 3, \"drei\")\n\n\tt.Run(\"no count\", func(t *testing.T) {\n\t\ts.Seed(12)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\",\n\t\t\tproto.String(\"three\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"nosuch\",\n\t\t\tproto.Nil,\n\t\t)\n\t})\n\n\tt.Run(\"positive count\", func(t *testing.T) {\n\t\ts.Seed(81)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"2\",\n\t\t\tproto.Strings(\"one\", \"two\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"2\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"drei\", \"3\", \"zwei\", \"2\"),\n\t\t)\n\n\t\ts.Seed(81)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"7\",\n\t\t\tproto.Strings(\"one\", \"two\", \"zwei\", \"three\", \"drei\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"0\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"nosuch\", \"40\",\n\t\t\tproto.Array(),\n\t\t)\n\t})\n\n\tt.Run(\"negative count\", func(t *testing.T) {\n\t\ts.Seed(-12)\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"-2\",\n\t\t\tproto.Strings(\"one\", \"one\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"-2\", \"WITHSCORES\",\n\t\t\tproto.Strings(\"zwei\", \"2\", \"two\", \"2\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"-7\",\n\t\t\tproto.Strings(\"two\", \"two\", \"one\", \"drei\", \"drei\", \"two\", \"two\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"-0\",\n\t\t\tproto.Strings(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"nosuch\", \"-33\",\n\t\t\tproto.Array(),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"nosuch\", \"-33\", \"WITHSCORES\",\n\t\t\tproto.Array(),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\",\n\t\t\tproto.Error(errWrongNumber(\"zrandmember\")),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"z\", \"WITHSCORES\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\ts.Set(\"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"ZRANDMEMBER\", \"str\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n"
        },
        {
          "name": "cmd_stream.go",
          "type": "blob",
          "size": 36.1103515625,
          "content": "// Commands from https://redis.io/commands#stream\n\npackage miniredis\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsStream handles all stream operations.\nfunc commandsStream(m *Miniredis) {\n\tm.srv.Register(\"XADD\", m.cmdXadd)\n\tm.srv.Register(\"XLEN\", m.cmdXlen)\n\tm.srv.Register(\"XREAD\", m.cmdXread)\n\tm.srv.Register(\"XRANGE\", m.makeCmdXrange(false))\n\tm.srv.Register(\"XREVRANGE\", m.makeCmdXrange(true))\n\tm.srv.Register(\"XGROUP\", m.cmdXgroup)\n\tm.srv.Register(\"XINFO\", m.cmdXinfo)\n\tm.srv.Register(\"XREADGROUP\", m.cmdXreadgroup)\n\tm.srv.Register(\"XACK\", m.cmdXack)\n\tm.srv.Register(\"XDEL\", m.cmdXdel)\n\tm.srv.Register(\"XPENDING\", m.cmdXpending)\n\tm.srv.Register(\"XTRIM\", m.cmdXtrim)\n\tm.srv.Register(\"XAUTOCLAIM\", m.cmdXautoclaim)\n\tm.srv.Register(\"XCLAIM\", m.cmdXclaim)\n}\n\n// XADD\nfunc (m *Miniredis) cmdXadd(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 4 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, args := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tmaxlen := -1\n\t\tminID := \"\"\n\t\tmakeStream := true\n\t\tif strings.ToLower(args[0]) == \"nomkstream\" {\n\t\t\targs = args[1:]\n\t\t\tmakeStream = false\n\t\t}\n\t\tif strings.ToLower(args[0]) == \"maxlen\" {\n\t\t\targs = args[1:]\n\t\t\t// we don't treat \"~\" special\n\t\t\tif args[0] == \"~\" {\n\t\t\t\targs = args[1:]\n\t\t\t}\n\t\t\tn, err := strconv.Atoi(args[0])\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n < 0 {\n\t\t\t\tc.WriteError(\"ERR The MAXLEN argument must be >= 0.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tmaxlen = n\n\t\t\targs = args[1:]\n\t\t} else if strings.ToLower(args[0]) == \"minid\" {\n\t\t\targs = args[1:]\n\t\t\t// we don't treat \"~\" special\n\t\t\tif args[0] == \"~\" {\n\t\t\t\targs = args[1:]\n\t\t\t}\n\t\t\tminID = args[0]\n\t\t\targs = args[1:]\n\t\t}\n\t\tif len(args) < 1 {\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tentryID, args := args[0], args[1:]\n\n\t\t// args must be composed of field/value pairs.\n\t\tif len(args) == 0 || len(args)%2 != 0 {\n\t\t\tc.WriteError(\"ERR wrong number of arguments for XADD\") // non-default message\n\t\t\treturn\n\t\t}\n\n\t\tvar values []string\n\t\tfor len(args) > 0 {\n\t\t\tvalues = append(values, args[0], args[1])\n\t\t\targs = args[2:]\n\t\t}\n\n\t\tdb := m.db(ctx.selectedDB)\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tif !makeStream {\n\t\t\t\tc.WriteNull()\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts, _ = db.newStream(key)\n\t\t}\n\n\t\tnewID, err := s.add(entryID, values, m.effectiveNow())\n\t\tif err != nil {\n\t\t\tswitch err {\n\t\t\tcase errInvalidEntryID:\n\t\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\tdefault:\n\t\t\t\tc.WriteError(err.Error())\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tif maxlen >= 0 {\n\t\t\ts.trim(maxlen)\n\t\t}\n\t\tif minID != \"\" {\n\t\t\ts.trimBefore(minID)\n\t\t}\n\t\tdb.incr(key)\n\n\t\tc.WriteBulk(newID)\n\t})\n}\n\n// XLEN\nfunc (m *Miniredis) cmdXlen(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t}\n\t\tif s == nil {\n\t\t\t// No such key. That's zero length.\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(len(s.entries))\n\t})\n}\n\n// XRANGE and XREVRANGE\nfunc (m *Miniredis) makeCmdXrange(reverse bool) server.Cmd {\n\treturn func(c *server.Peer, cmd string, args []string) {\n\t\tif len(args) < 3 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(errWrongNumber(cmd))\n\t\t\treturn\n\t\t}\n\t\tif len(args) == 4 || len(args) > 5 {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t\tif !m.handleAuth(c) {\n\t\t\treturn\n\t\t}\n\t\tif m.checkPubsub(c, cmd) {\n\t\t\treturn\n\t\t}\n\n\t\topts := struct {\n\t\t\tkey            string\n\t\t\tstartKey       string\n\t\t\tstartExclusive bool\n\t\t\tendKey         string\n\t\t\tendExclusive   bool\n\t\t}{\n\t\t\tkey:      args[0],\n\t\t\tstartKey: args[1],\n\t\t\tendKey:   args[2],\n\t\t}\n\t\tif strings.HasPrefix(opts.startKey, \"(\") {\n\t\t\topts.startExclusive = true\n\t\t\topts.startKey = opts.startKey[1:]\n\t\t\tif opts.startKey == \"-\" || opts.startKey == \"+\" {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif strings.HasPrefix(opts.endKey, \"(\") {\n\t\t\topts.endExclusive = true\n\t\t\topts.endKey = opts.endKey[1:]\n\t\t\tif opts.endKey == \"-\" || opts.endKey == \"+\" {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tcountArg := \"0\"\n\t\tif len(args) == 5 {\n\t\t\tif strings.ToLower(args[3]) != \"count\" {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcountArg = args[4]\n\t\t}\n\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tstart, err := formatStreamRangeBound(opts.startKey, true, reverse)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tend, err := formatStreamRangeBound(opts.endKey, false, reverse)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tcount, err := strconv.Atoi(countArg)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tdb := m.db(ctx.selectedDB)\n\n\t\t\tif !db.exists(opts.key) {\n\t\t\t\tc.WriteLen(0)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif db.t(opts.key) != \"stream\" {\n\t\t\t\tc.WriteError(ErrWrongType.Error())\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar entries = db.streamKeys[opts.key].entries\n\t\t\tif reverse {\n\t\t\t\tentries = reversedStreamEntries(entries)\n\t\t\t}\n\t\t\tif count == 0 {\n\t\t\t\tcount = len(entries)\n\t\t\t}\n\n\t\t\tvar returnedEntries []StreamEntry\n\t\t\tfor _, entry := range entries {\n\t\t\t\tif len(returnedEntries) == count {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif !reverse {\n\t\t\t\t\t// Break if entry ID > end\n\t\t\t\t\tif streamCmp(entry.ID, end) == 1 {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if entry ID < start\n\t\t\t\t\tif streamCmp(entry.ID, start) == -1 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Break if entry iD < end\n\t\t\t\t\tif streamCmp(entry.ID, end) == -1 {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\t// Continue if entry ID > start.\n\t\t\t\t\tif streamCmp(entry.ID, start) == 1 {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Continue if start exclusive and entry ID == start\n\t\t\t\tif opts.startExclusive && streamCmp(entry.ID, start) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\t// Continue if end exclusive and entry ID == end\n\t\t\t\tif opts.endExclusive && streamCmp(entry.ID, end) == 0 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\treturnedEntries = append(returnedEntries, entry)\n\t\t\t}\n\n\t\t\tc.WriteLen(len(returnedEntries))\n\t\t\tfor _, entry := range returnedEntries {\n\t\t\t\tc.WriteLen(2)\n\t\t\t\tc.WriteBulk(entry.ID)\n\t\t\t\tc.WriteLen(len(entry.Values))\n\t\t\t\tfor _, v := range entry.Values {\n\t\t\t\t\tc.WriteBulk(v)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\n// XGROUP\nfunc (m *Miniredis) cmdXgroup(c *server.Peer, cmd string, args []string) {\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tsubCmd, args := strings.ToLower(args[0]), args[1:]\n\tswitch subCmd {\n\tcase \"create\":\n\t\tm.cmdXgroupCreate(c, cmd, args)\n\tcase \"destroy\":\n\t\tm.cmdXgroupDestroy(c, cmd, args)\n\tcase \"createconsumer\":\n\t\tm.cmdXgroupCreateconsumer(c, cmd, args)\n\tcase \"delconsumer\":\n\t\tm.cmdXgroupDelconsumer(c, cmd, args)\n\tcase \"help\",\n\t\t\"setid\":\n\t\terr := fmt.Sprintf(\"ERR 'XGROUP %s' not supported\", subCmd)\n\t\tsetDirty(c)\n\t\tc.WriteError(err)\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(\n\t\t\t\"ERR unknown subcommand '%s'. Try XGROUP HELP.\",\n\t\t\tsubCmd,\n\t\t))\n\t}\n}\n\n// XGROUP CREATE\nfunc (m *Miniredis) cmdXgroupCreate(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 && len(args) != 4 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"CREATE\"))\n\t\treturn\n\t}\n\tstream, group, id := args[0], args[1], args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(stream)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil && len(args) == 4 && strings.ToUpper(args[3]) == \"MKSTREAM\" {\n\t\t\tif s, err = db.newStream(stream); err != nil {\n\t\t\t\tc.WriteError(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgXgroupKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tif err := s.createGroup(group, id); err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteOK()\n\t})\n}\n\n// XGROUP DESTROY\nfunc (m *Miniredis) cmdXgroupDestroy(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"DESTROY\"))\n\t\treturn\n\t}\n\tstream, groupName := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(stream)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgXgroupKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok := s.groups[groupName]; !ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tdelete(s.groups, groupName)\n\t\tc.WriteInt(1)\n\t})\n}\n\n// XGROUP CREATECONSUMER\nfunc (m *Miniredis) cmdXgroupCreateconsumer(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"CREATECONSUMER\"))\n\t\treturn\n\t}\n\tkey, groupName, consumerName := args[0], args[1], args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgXgroupKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tg, ok := s.groups[groupName]\n\t\tif !ok {\n\t\t\terr := fmt.Sprintf(\"NOGROUP No such consumer group '%s' for key name '%s'\", groupName, key)\n\t\t\tc.WriteError(err)\n\t\t\treturn\n\t\t}\n\n\t\tif _, ok = g.consumers[consumerName]; ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tg.consumers[consumerName] = &consumer{}\n\t\tc.WriteInt(1)\n\t})\n}\n\n// XGROUP DELCONSUMER\nfunc (m *Miniredis) cmdXgroupDelconsumer(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"DELCONSUMER\"))\n\t\treturn\n\t}\n\tkey, groupName, consumerName := args[0], args[1], args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgXgroupKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tg, ok := s.groups[groupName]\n\t\tif !ok {\n\t\t\terr := fmt.Sprintf(\"NOGROUP No such consumer group '%s' for key name '%s'\", groupName, key)\n\t\t\tc.WriteError(err)\n\t\t\treturn\n\t\t}\n\n\t\tconsumer, ok := g.consumers[consumerName]\n\t\tif !ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tdefer delete(g.consumers, consumerName)\n\n\t\tif consumer.numPendingEntries > 0 {\n\t\t\tnewPending := make([]pendingEntry, 0)\n\t\t\tfor _, entry := range g.pending {\n\t\t\t\tif entry.consumer != consumerName {\n\t\t\t\t\tnewPending = append(newPending, entry)\n\t\t\t\t}\n\t\t\t}\n\t\t\tg.pending = newPending\n\t\t}\n\t\tc.WriteInt(consumer.numPendingEntries)\n\t})\n}\n\n// XINFO\nfunc (m *Miniredis) cmdXinfo(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tsubCmd, args := strings.ToUpper(args[0]), args[1:]\n\tswitch subCmd {\n\tcase \"STREAM\":\n\t\tm.cmdXinfoStream(c, args)\n\tcase \"CONSUMERS\":\n\t\tm.cmdXinfoConsumers(c, args)\n\tcase \"GROUPS\":\n\t\tm.cmdXinfoGroups(c, args)\n\tcase \"HELP\":\n\t\terr := fmt.Sprintf(\"'XINFO %s' not supported\", strings.Join(args, \" \"))\n\t\tsetDirty(c)\n\t\tc.WriteError(err)\n\tdefault:\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(\n\t\t\t\"ERR unknown subcommand or wrong number of arguments for '%s'. Try XINFO HELP.\",\n\t\t\tsubCmd,\n\t\t))\n\t}\n}\n\n// XINFO STREAM\n// Produces only part of full command output\nfunc (m *Miniredis) cmdXinfoStream(c *server.Peer, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"STREAM\"))\n\t\treturn\n\t}\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteMapLen(1)\n\t\tc.WriteBulk(\"length\")\n\t\tc.WriteInt(len(s.entries))\n\t})\n}\n\n// XINFO GROUPS\nfunc (m *Miniredis) cmdXinfoGroups(c *server.Peer, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"GROUPS\"))\n\t\treturn\n\t}\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteLen(len(s.groups))\n\t\tfor name, g := range s.groups {\n\t\t\tc.WriteMapLen(6)\n\n\t\t\tc.WriteBulk(\"name\")\n\t\t\tc.WriteBulk(name)\n\t\t\tc.WriteBulk(\"consumers\")\n\t\t\tc.WriteInt(len(g.consumers))\n\t\t\tc.WriteBulk(\"pending\")\n\t\t\tc.WriteInt(len(g.activePending()))\n\t\t\tc.WriteBulk(\"last-delivered-id\")\n\t\t\tc.WriteBulk(g.lastID)\n\t\t\tc.WriteBulk(\"entries-read\")\n\t\t\tc.WriteNull()\n\t\t\tc.WriteBulk(\"lag\")\n\t\t\tc.WriteInt(len(g.stream.entries))\n\t\t}\n\t})\n}\n\n// XINFO CONSUMERS\n// Please note that this is only a partial implementation, for it does not\n// return each consumer's \"idle\" value, which indicates \"the number of\n// milliseconds that have passed since the consumer last interacted with the\n// server.\"\nfunc (m *Miniredis) cmdXinfoConsumers(c *server.Peer, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(\"CONSUMERS\"))\n\t\treturn\n\t}\n\tkey, groupName := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\ts, err := db.stream(key)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteError(msgKeyNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tg, ok := s.groups[groupName]\n\t\tif !ok {\n\t\t\terr := fmt.Sprintf(\"NOGROUP No such consumer group '%s' for key name '%s'\", groupName, key)\n\t\t\tc.WriteError(err)\n\t\t\treturn\n\t\t}\n\n\t\tvar consumerNames []string\n\t\tfor name := range g.consumers {\n\t\t\tconsumerNames = append(consumerNames, name)\n\t\t}\n\t\tsort.Strings(consumerNames)\n\n\t\tc.WriteLen(len(consumerNames))\n\t\tfor _, name := range consumerNames {\n\t\t\tcons := g.consumers[name]\n\n\t\t\tc.WriteMapLen(4)\n\t\t\tc.WriteBulk(\"name\")\n\t\t\tc.WriteBulk(name)\n\t\t\tc.WriteBulk(\"pending\")\n\t\t\tc.WriteInt(cons.numPendingEntries)\n\t\t\t// TODO: these times aren't set for all commands\n\t\t\tc.WriteBulk(\"idle\")\n\t\t\tc.WriteInt(m.sinceMilli(cons.lastSeen))\n\t\t\tc.WriteBulk(\"inactive\")\n\t\t\tc.WriteInt(m.sinceMilli(cons.lastSuccess))\n\t\t}\n\t})\n}\n\nfunc (m *Miniredis) sinceMilli(t time.Time) int {\n\tif t.IsZero() {\n\t\treturn -1\n\t}\n\treturn int(m.effectiveNow().Sub(t).Milliseconds())\n}\n\n// XREADGROUP\nfunc (m *Miniredis) cmdXreadgroup(c *server.Peer, cmd string, args []string) {\n\t// XREADGROUP GROUP group consumer STREAMS key ID\n\tif len(args) < 6 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tgroup        string\n\t\tconsumer     string\n\t\tcount        int\n\t\tnoack        bool\n\t\tstreams      []string\n\t\tids          []string\n\t\tblock        bool\n\t\tblockTimeout time.Duration\n\t}\n\n\tif strings.ToUpper(args[0]) != \"GROUP\" {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\n\topts.group, opts.consumer, args = args[1], args[2], args[3:]\n\n\tvar err error\nparsing:\n\tfor len(args) > 0 {\n\t\tswitch strings.ToUpper(args[0]) {\n\t\tcase \"COUNT\":\n\t\t\tif len(args) < 2 {\n\t\t\t\terr = errors.New(errWrongNumber(cmd))\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\topts.count, err = strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\targs = args[2:]\n\t\tcase \"BLOCK\":\n\t\t\terr = parseBlock(cmd, args, &opts.block, &opts.blockTimeout)\n\t\t\tif err != nil {\n\t\t\t\tbreak parsing\n\t\t\t}\n\t\t\targs = args[2:]\n\t\tcase \"NOACK\":\n\t\t\targs = args[1:]\n\t\t\topts.noack = true\n\t\tcase \"STREAMS\":\n\t\t\targs = args[1:]\n\n\t\t\tif len(args)%2 != 0 {\n\t\t\t\terr = errors.New(msgXreadUnbalanced)\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\topts.streams, opts.ids = args[0:len(args)/2], args[len(args)/2:]\n\t\t\tbreak parsing\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"ERR incorrect argument %s\", args[0])\n\t\t\tbreak parsing\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\n\tif len(opts.streams) == 0 || len(opts.ids) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\n\tfor _, id := range opts.ids {\n\t\tif id != `>` {\n\t\t\topts.block = false\n\t\t}\n\t}\n\n\tif !opts.block {\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\t\t\tres, err := xreadgroup(\n\t\t\t\tdb,\n\t\t\t\topts.group,\n\t\t\t\topts.consumer,\n\t\t\t\topts.noack,\n\t\t\t\topts.streams,\n\t\t\t\topts.ids,\n\t\t\t\topts.count,\n\t\t\t\tm.effectiveNow(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(err.Error())\n\t\t\t\treturn\n\t\t\t}\n\t\t\twriteXread(c, opts.streams, res)\n\t\t})\n\t\treturn\n\t}\n\n\tblocking(\n\t\tm,\n\t\tc,\n\t\topts.blockTimeout,\n\t\tfunc(c *server.Peer, ctx *connCtx) bool {\n\t\t\tif ctx.nested {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR XREADGROUP command is not allowed with BLOCK option from scripts\")\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tdb := m.db(ctx.selectedDB)\n\t\t\tres, err := xreadgroup(\n\t\t\t\tdb,\n\t\t\t\topts.group,\n\t\t\t\topts.consumer,\n\t\t\t\topts.noack,\n\t\t\t\topts.streams,\n\t\t\t\topts.ids,\n\t\t\t\topts.count,\n\t\t\t\tm.effectiveNow(),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\tc.WriteError(err.Error())\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif len(res) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\twriteXread(c, opts.streams, res)\n\t\t\treturn true\n\t\t},\n\t\tfunc(c *server.Peer) { // timeout\n\t\t\tc.WriteLen(-1)\n\t\t},\n\t)\n}\n\nfunc xreadgroup(\n\tdb *RedisDB,\n\tgroup,\n\tconsumer string,\n\tnoack bool,\n\tstreams []string,\n\tids []string,\n\tcount int,\n\tnow time.Time,\n) (map[string][]StreamEntry, error) {\n\tres := map[string][]StreamEntry{}\n\tfor i, key := range streams {\n\t\tid := ids[i]\n\n\t\tg, err := db.streamGroup(key, group)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif g == nil {\n\t\t\treturn nil, errXreadgroup(key, group)\n\t\t}\n\n\t\tif _, err := parseStreamID(id); id != `>` && err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tentries := g.readGroup(now, consumer, id, count, noack)\n\t\tif id == `>` && len(entries) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tres[key] = entries\n\t}\n\treturn res, nil\n}\n\n// XACK\nfunc (m *Miniredis) cmdXack(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, group, ids := args[0], args[1], args[2:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tg, err := db.streamGroup(key, group)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif g == nil {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tcnt, err := g.ack(ids)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tc.WriteInt(cnt)\n\t})\n}\n\n// XDEL\nfunc (m *Miniredis) cmdXdel(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tstream, ids := args[0], args[1:]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\ts, err := db.stream(stream)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tn, err := s.delete(ids)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tdb.incr(stream)\n\t\tc.WriteInt(n)\n\t})\n}\n\n// XREAD\nfunc (m *Miniredis) cmdXread(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar (\n\t\topts struct {\n\t\t\tcount        int\n\t\t\tstreams      []string\n\t\t\tids          []string\n\t\t\tblock        bool\n\t\t\tblockTimeout time.Duration\n\t\t}\n\t\terr error\n\t)\n\nparsing:\n\tfor len(args) > 0 {\n\t\tswitch strings.ToUpper(args[0]) {\n\t\tcase \"COUNT\":\n\t\t\tif len(args) < 2 {\n\t\t\t\terr = errors.New(errWrongNumber(cmd))\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\topts.count, err = strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tbreak parsing\n\t\t\t}\n\t\t\targs = args[2:]\n\t\tcase \"BLOCK\":\n\t\t\terr = parseBlock(cmd, args, &opts.block, &opts.blockTimeout)\n\t\t\tif err != nil {\n\t\t\t\tbreak parsing\n\t\t\t}\n\t\t\targs = args[2:]\n\t\tcase \"STREAMS\":\n\t\t\targs = args[1:]\n\n\t\t\tif len(args)%2 != 0 {\n\t\t\t\terr = errors.New(msgXreadUnbalanced)\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\topts.streams, opts.ids = args[0:len(args)/2], args[len(args)/2:]\n\t\t\tfor i, id := range opts.ids {\n\t\t\t\tif _, err := parseStreamID(id); id != `$` && err != nil {\n\t\t\t\t\tsetDirty(c)\n\t\t\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\t\t\treturn\n\t\t\t\t} else if id == \"$\" {\n\t\t\t\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\t\t\t\tdb := m.db(getCtx(c).selectedDB)\n\t\t\t\t\t\tstream, ok := db.streamKeys[opts.streams[i]]\n\t\t\t\t\t\tif ok {\n\t\t\t\t\t\t\topts.ids[i] = stream.lastID()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\topts.ids[i] = \"0-0\"\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\targs = nil\n\t\t\tbreak parsing\n\t\tdefault:\n\t\t\terr = fmt.Errorf(\"ERR incorrect argument %s\", args[0])\n\t\t\tbreak parsing\n\t\t}\n\t}\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\n\tif !opts.block {\n\t\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t\tdb := m.db(ctx.selectedDB)\n\t\t\tres := xread(db, opts.streams, opts.ids, opts.count)\n\t\t\twriteXread(c, opts.streams, res)\n\t\t})\n\t\treturn\n\t}\n\tblocking(\n\t\tm,\n\t\tc,\n\t\topts.blockTimeout,\n\t\tfunc(c *server.Peer, ctx *connCtx) bool {\n\t\t\tif ctx.nested {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR XREAD command is not allowed with BLOCK option from scripts\")\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tdb := m.db(ctx.selectedDB)\n\t\t\tres := xread(db, opts.streams, opts.ids, opts.count)\n\t\t\tif len(res) == 0 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\twriteXread(c, opts.streams, res)\n\t\t\treturn true\n\t\t},\n\t\tfunc(c *server.Peer) { // timeout\n\t\t\tc.WriteLen(-1)\n\t\t},\n\t)\n}\n\nfunc xread(db *RedisDB, streams []string, ids []string, count int) map[string][]StreamEntry {\n\tres := map[string][]StreamEntry{}\n\tfor i := range streams {\n\t\tstream := streams[i]\n\t\tid := ids[i]\n\n\t\tvar s, ok = db.streamKeys[stream]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tentries := s.entries\n\t\tif len(entries) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tentryCount := count\n\t\tif entryCount == 0 {\n\t\t\tentryCount = len(entries)\n\t\t}\n\n\t\tvar returnedEntries []StreamEntry\n\t\tfor _, entry := range entries {\n\t\t\tif len(returnedEntries) == entryCount {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif id == \"$\" {\n\t\t\t\tid = s.lastID()\n\t\t\t}\n\t\t\tif streamCmp(entry.ID, id) <= 0 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturnedEntries = append(returnedEntries, entry)\n\t\t}\n\t\tif len(returnedEntries) > 0 {\n\t\t\tres[stream] = returnedEntries\n\t\t}\n\t}\n\treturn res\n}\n\nfunc writeXread(c *server.Peer, streams []string, res map[string][]StreamEntry) {\n\tif len(res) == 0 {\n\t\tc.WriteLen(-1)\n\t\treturn\n\t}\n\tc.WriteLen(len(res))\n\tfor _, stream := range streams {\n\t\tentries, ok := res[stream]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(stream)\n\t\tc.WriteLen(len(entries))\n\t\tfor _, entry := range entries {\n\t\t\tc.WriteLen(2)\n\t\t\tc.WriteBulk(entry.ID)\n\t\t\tc.WriteLen(len(entry.Values))\n\t\t\tfor _, v := range entry.Values {\n\t\t\t\tc.WriteBulk(v)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// XPENDING\nfunc (m *Miniredis) cmdXpending(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey        string\n\t\tgroup      string\n\t\tsummary    bool\n\t\tidle       time.Duration\n\t\tstart, end string\n\t\tcount      int\n\t\tconsumer   *string\n\t}\n\n\topts.key, opts.group, args = args[0], args[1], args[2:]\n\topts.summary = true\n\tif len(args) >= 3 {\n\t\topts.summary = false\n\n\t\tif strings.ToUpper(args[0]) == \"IDLE\" {\n\t\t\tidleMs, err := strconv.ParseInt(args[1], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.idle = time.Duration(idleMs) * time.Millisecond\n\n\t\t\targs = args[2:]\n\t\t\tif len(args) < 3 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tvar err error\n\t\topts.start, err = formatStreamRangeBound(args[0], true, false)\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\treturn\n\t\t}\n\t\topts.end, err = formatStreamRangeBound(args[1], false, false)\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidStreamID)\n\t\t\treturn\n\t\t}\n\t\topts.count, err = strconv.Atoi(args[2]) // negative is allowed\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\t\targs = args[3:]\n\n\t\tif len(args) == 1 {\n\t\t\topts.consumer, args = &args[0], args[1:]\n\t\t}\n\t}\n\tif len(args) != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgSyntaxError)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tg, err := db.streamGroup(opts.key, opts.group)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif g == nil {\n\t\t\tc.WriteError(errReadgroup(opts.key, opts.group).Error())\n\t\t\treturn\n\t\t}\n\n\t\tif opts.summary {\n\t\t\twriteXpendingSummary(c, *g)\n\t\t\treturn\n\t\t}\n\t\twriteXpending(m.effectiveNow(), c, *g, opts.idle, opts.start, opts.end, opts.count, opts.consumer)\n\t})\n}\n\nfunc writeXpendingSummary(c *server.Peer, g streamGroup) {\n\tpend := g.activePending()\n\tif len(pend) == 0 {\n\t\tc.WriteLen(4)\n\t\tc.WriteInt(0)\n\t\tc.WriteNull()\n\t\tc.WriteNull()\n\t\tc.WriteLen(-1)\n\t\treturn\n\t}\n\n\t// format:\n\t//  - number of pending\n\t//  - smallest ID\n\t//  - highest ID\n\t//  - all consumers with > 0 pending items\n\tc.WriteLen(4)\n\tc.WriteInt(len(pend))\n\tc.WriteBulk(pend[0].id)\n\tc.WriteBulk(pend[len(pend)-1].id)\n\tcons := map[string]int{}\n\tfor id := range g.consumers {\n\t\tcnt := g.pendingCount(id)\n\t\tif cnt > 0 {\n\t\t\tcons[id] = cnt\n\t\t}\n\t}\n\tc.WriteLen(len(cons))\n\tvar ids []string\n\tfor id := range cons {\n\t\tids = append(ids, id)\n\t}\n\tsort.Strings(ids) // be predicatable\n\tfor _, id := range ids {\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(id)\n\t\tc.WriteBulk(strconv.Itoa(cons[id]))\n\t}\n}\n\nfunc writeXpending(\n\tnow time.Time,\n\tc *server.Peer,\n\tg streamGroup,\n\tidle time.Duration,\n\tstart,\n\tend string,\n\tcount int,\n\tconsumer *string,\n) {\n\tif len(g.pending) == 0 || count < 0 {\n\t\tc.WriteLen(-1)\n\t\treturn\n\t}\n\n\t// format, list of:\n\t//  - message ID\n\t//  - consumer\n\t//  - milliseconds since delivery\n\t//  - delivery count\n\ttype entry struct {\n\t\tid       string\n\t\tconsumer string\n\t\tmillis   int\n\t\tcount    int\n\t}\n\tvar res []entry\n\tfor _, p := range g.pending {\n\t\tif len(res) >= count {\n\t\t\tbreak\n\t\t}\n\t\tif consumer != nil && p.consumer != *consumer {\n\t\t\tcontinue\n\t\t}\n\t\tif streamCmp(p.id, start) < 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif streamCmp(p.id, end) > 0 {\n\t\t\tcontinue\n\t\t}\n\t\ttimeSinceLastDelivery := now.Sub(p.lastDelivery)\n\t\tif timeSinceLastDelivery >= idle {\n\t\t\tres = append(res, entry{\n\t\t\t\tid:       p.id,\n\t\t\t\tconsumer: p.consumer,\n\t\t\t\tmillis:   int(timeSinceLastDelivery.Milliseconds()),\n\t\t\t\tcount:    p.deliveryCount,\n\t\t\t})\n\t\t}\n\t}\n\tif len(res) == 0 {\n\t\tc.WriteLen(-1)\n\t\treturn\n\t}\n\tc.WriteLen(len(res))\n\tfor _, e := range res {\n\t\tc.WriteLen(4)\n\t\tc.WriteBulk(e.id)\n\t\tc.WriteBulk(e.consumer)\n\t\tc.WriteInt(e.millis)\n\t\tc.WriteInt(e.count)\n\t}\n}\n\n// XTRIM\nfunc (m *Miniredis) cmdXtrim(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tstream     string\n\t\tstrategy   string\n\t\tmaxLen     int    // for MAXLEN\n\t\tthreshold  string // for MINID\n\t\twithLimit  bool   // \"LIMIT\"\n\t\twithExact  bool   // \"=\"\n\t\twithNearly bool   // \"~\"\n\t}\n\n\topts.stream, opts.strategy, args = args[0], strings.ToUpper(args[1]), args[2:]\n\n\tif opts.strategy != \"MAXLEN\" && opts.strategy != \"MINID\" {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgXtrimInvalidStrategy)\n\t\treturn\n\t}\n\n\t// Ignore nearly exact trimming parameters.\n\tswitch args[0] {\n\tcase \"=\":\n\t\topts.withExact = true\n\t\targs = args[1:]\n\tcase \"~\":\n\t\topts.withNearly = true\n\t\targs = args[1:]\n\t}\n\n\tswitch opts.strategy {\n\tcase \"MAXLEN\":\n\t\tmaxLen, err := strconv.Atoi(args[0])\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgXtrimInvalidMaxLen)\n\t\t\treturn\n\t\t}\n\t\topts.maxLen = maxLen\n\tcase \"MINID\":\n\t\topts.threshold = args[0]\n\t}\n\targs = args[1:]\n\n\tif len(args) == 2 && strings.ToUpper(args[0]) == \"LIMIT\" {\n\t\t// Ignore LIMIT.\n\t\topts.withLimit = true\n\t\tif _, err := strconv.Atoi(args[1]); err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgInvalidInt)\n\t\t\treturn\n\t\t}\n\n\t\targs = args[2:]\n\t}\n\n\tif len(args) != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(\"ERR incorrect argument %s\", args[0]))\n\t\treturn\n\t}\n\n\tif opts.withLimit && !opts.withNearly {\n\t\tsetDirty(c)\n\t\tc.WriteError(fmt.Sprintf(msgXtrimInvalidLimit))\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\ts, err := db.stream(opts.stream)\n\t\tif err != nil {\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif s == nil {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tswitch opts.strategy {\n\t\tcase \"MAXLEN\":\n\t\t\tentriesBefore := len(s.entries)\n\t\t\ts.trim(opts.maxLen)\n\t\t\tc.WriteInt(entriesBefore - len(s.entries))\n\t\tcase \"MINID\":\n\t\t\tn := s.trimBefore(opts.threshold)\n\t\t\tc.WriteInt(n)\n\t\t}\n\t})\n}\n\n// XAUTOCLAIM\nfunc (m *Miniredis) cmdXautoclaim(c *server.Peer, cmd string, args []string) {\n\t// XAUTOCLAIM key group consumer min-idle-time start\n\tif len(args) < 5 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey         string\n\t\tgroup       string\n\t\tconsumer    string\n\t\tminIdleTime time.Duration\n\t\tstart       string\n\t\tjustId      bool\n\t\tcount       int\n\t}\n\n\topts.key, opts.group, opts.consumer = args[0], args[1], args[2]\n\tn, err := strconv.Atoi(args[3])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR Invalid min-idle-time argument for XAUTOCLAIM\")\n\t\treturn\n\t}\n\topts.minIdleTime = time.Millisecond * time.Duration(n)\n\n\tstart_, err := formatStreamRangeBound(args[4], true, false)\n\tif err != nil {\n\t\tc.WriteError(msgInvalidStreamID)\n\t\treturn\n\t}\n\topts.start = start_\n\n\targs = args[5:]\n\n\topts.count = 100\nparsing:\n\tfor len(args) > 0 {\n\t\tswitch strings.ToUpper(args[0]) {\n\t\tcase \"COUNT\":\n\t\t\tif len(args) < 2 {\n\t\t\t\terr = errors.New(errWrongNumber(cmd))\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\topts.count, err = strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tbreak parsing\n\t\t\t}\n\n\t\t\targs = args[2:]\n\t\tcase \"JUSTID\":\n\t\t\targs = args[1:]\n\t\t\topts.justId = true\n\t\tdefault:\n\t\t\terr = errors.New(msgSyntaxError)\n\t\t\tbreak parsing\n\t\t}\n\t}\n\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(err.Error())\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\t\tg, err := db.streamGroup(opts.key, opts.group)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif g == nil {\n\t\t\tc.WriteError(errReadgroup(opts.key, opts.group).Error())\n\t\t\treturn\n\t\t}\n\n\t\tnextCallId, entries := xautoclaim(m.effectiveNow(), *g, opts.minIdleTime, opts.start, opts.count, opts.consumer)\n\t\twriteXautoclaim(c, nextCallId, entries, opts.justId)\n\t})\n}\n\nfunc xautoclaim(\n\tnow time.Time,\n\tg streamGroup,\n\tminIdleTime time.Duration,\n\tstart string,\n\tcount int,\n\tconsumerID string,\n) (string, []StreamEntry) {\n\tnextCallId := \"0-0\"\n\tif len(g.pending) == 0 || count < 0 {\n\t\treturn nextCallId, nil\n\t}\n\n\tmsgs := g.pendingAfter(start)\n\tvar res []StreamEntry\n\tfor i, p := range msgs {\n\t\tif minIdleTime > 0 && now.Before(p.lastDelivery.Add(minIdleTime)) {\n\t\t\tcontinue\n\t\t}\n\n\t\tprevConsumerID := p.consumer\n\t\tif _, ok := g.consumers[consumerID]; !ok {\n\t\t\tg.consumers[consumerID] = &consumer{}\n\t\t}\n\t\tp.consumer = consumerID\n\n\t\t_, entry := g.stream.get(p.id)\n\t\t// not found. Weird?\n\t\tif entry == nil {\n\t\t\t// TODO: support third element of return from XAUTOCLAIM, which\n\t\t\t// should delete entries not found in the PEL during XAUTOCLAIM.\n\t\t\t// (Introduced in Redis 7.0)\n\t\t\tcontinue\n\t\t}\n\n\t\tp.deliveryCount += 1\n\t\tp.lastDelivery = now\n\n\t\tg.consumers[prevConsumerID].numPendingEntries--\n\t\tg.consumers[consumerID].numPendingEntries++\n\n\t\tmsgs[i] = p\n\t\tres = append(res, *entry)\n\n\t\tif len(res) >= count {\n\t\t\tif len(msgs) > i+1 {\n\t\t\t\tnextCallId = msgs[i+1].id\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nextCallId, res\n}\n\nfunc writeXautoclaim(c *server.Peer, nextCallId string, res []StreamEntry, justId bool) {\n\tc.WriteLen(3)\n\tc.WriteBulk(nextCallId)\n\tc.WriteLen(len(res))\n\tfor _, entry := range res {\n\t\tif justId {\n\t\t\tc.WriteBulk(entry.ID)\n\t\t\tcontinue\n\t\t}\n\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(entry.ID)\n\t\tc.WriteLen(len(entry.Values))\n\t\tfor _, v := range entry.Values {\n\t\t\tc.WriteBulk(v)\n\t\t}\n\t}\n\t// TODO: see \"Redis 7\" note\n\tc.WriteLen(0)\n}\n\n// XCLAIM\nfunc (m *Miniredis) cmdXclaim(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 5 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey             string\n\t\tgroupName       string\n\t\tconsumerName    string\n\t\tminIdleTime     time.Duration\n\t\tnewLastDelivery time.Time\n\t\tids             []string\n\t\tretryCount      *int\n\t\tforce           bool\n\t\tjustId          bool\n\t}\n\n\topts.key, opts.groupName, opts.consumerName = args[0], args[1], args[2]\n\n\tminIdleTimeMillis, err := strconv.Atoi(args[3])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR Invalid min-idle-time argument for XCLAIM\")\n\t\treturn\n\t}\n\topts.minIdleTime = time.Millisecond * time.Duration(minIdleTimeMillis)\n\n\topts.newLastDelivery = m.effectiveNow()\n\topts.ids = append(opts.ids, args[4])\n\n\targs = args[5:]\n\tfor len(args) > 0 {\n\t\targ := strings.ToUpper(args[0])\n\t\tif arg == \"IDLE\" ||\n\t\t\targ == \"TIME\" ||\n\t\t\targ == \"RETRYCOUNT\" ||\n\t\t\targ == \"FORCE\" ||\n\t\t\targ == \"JUSTID\" {\n\t\t\tbreak\n\t\t}\n\t\topts.ids = append(opts.ids, arg)\n\t\targs = args[1:]\n\t}\n\n\tfor len(args) > 0 {\n\t\targ := strings.ToUpper(args[0])\n\t\tswitch arg {\n\t\tcase \"IDLE\":\n\t\t\tidleMs, err := strconv.ParseInt(args[1], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR Invalid IDLE option argument for XCLAIM\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif idleMs < 0 {\n\t\t\t\tidleMs = 0\n\t\t\t}\n\t\t\topts.newLastDelivery = m.effectiveNow().Add(time.Millisecond * time.Duration(-idleMs))\n\t\t\targs = args[2:]\n\t\tcase \"TIME\":\n\t\t\ttimeMs, err := strconv.ParseInt(args[1], 10, 64)\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR Invalid TIME option argument for XCLAIM\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.newLastDelivery = time.UnixMilli(timeMs)\n\t\t\targs = args[2:]\n\t\tcase \"RETRYCOUNT\":\n\t\t\tretryCount, err := strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(\"ERR Invalid RETRYCOUNT option argument for XCLAIM\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.retryCount = &retryCount\n\t\t\targs = args[2:]\n\t\tcase \"FORCE\":\n\t\t\topts.force = true\n\t\t\targs = args[1:]\n\t\tcase \"JUSTID\":\n\t\t\topts.justId = true\n\t\t\targs = args[1:]\n\t\tdefault:\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(fmt.Sprintf(\"ERR Unrecognized XCLAIM option '%s'\", args[0]))\n\t\t\treturn\n\t\t}\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tg, err := db.streamGroup(opts.key, opts.groupName)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\tif g == nil {\n\t\t\tc.WriteError(errReadgroup(opts.key, opts.groupName).Error())\n\t\t\treturn\n\t\t}\n\n\t\tclaimedEntryIDs := m.xclaim(g, opts.consumerName, opts.minIdleTime, opts.newLastDelivery, opts.ids, opts.retryCount, opts.force)\n\t\twriteXclaim(c, g.stream, claimedEntryIDs, opts.justId)\n\t})\n}\n\nfunc (m *Miniredis) xclaim(\n\tgroup *streamGroup,\n\tconsumerName string,\n\tminIdleTime time.Duration,\n\tnewLastDelivery time.Time,\n\tids []string,\n\tretryCount *int,\n\tforce bool,\n) (claimedEntryIDs []string) {\n\tfor _, id := range ids {\n\t\tpelPos, pelEntry := group.searchPending(id)\n\t\tif pelEntry == nil {\n\t\t\tgroup.setLastSeen(consumerName, m.effectiveNow())\n\t\t\tif !force {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif pelPos < len(group.pending) {\n\t\t\t\tgroup.pending = append(group.pending[:pelPos+1], group.pending[pelPos:]...)\n\t\t\t} else {\n\t\t\t\tgroup.pending = append(group.pending, pendingEntry{})\n\t\t\t}\n\t\t\tpelEntry = &group.pending[pelPos]\n\n\t\t\t*pelEntry = pendingEntry{\n\t\t\t\tid:            id,\n\t\t\t\tconsumer:      consumerName,\n\t\t\t\tdeliveryCount: 1,\n\t\t\t}\n\t\t\tgroup.setLastSuccess(consumerName, m.effectiveNow())\n\t\t} else {\n\t\t\tgroup.consumers[pelEntry.consumer].numPendingEntries--\n\t\t\tpelEntry.consumer = consumerName\n\t\t}\n\n\t\tif retryCount != nil {\n\t\t\tpelEntry.deliveryCount = *retryCount\n\t\t} else {\n\t\t\tpelEntry.deliveryCount++\n\t\t}\n\t\tpelEntry.lastDelivery = newLastDelivery\n\n\t\t// redis7: don't report entries which are deleted by now\n\t\tif _, e := group.stream.get(id); e == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tclaimedEntryIDs = append(claimedEntryIDs, id)\n\t}\n\tif len(claimedEntryIDs) == 0 {\n\t\tgroup.setLastSeen(consumerName, m.effectiveNow())\n\t\treturn\n\t}\n\n\tif _, ok := group.consumers[consumerName]; !ok {\n\t\tgroup.consumers[consumerName] = &consumer{}\n\t}\n\tconsumer := group.consumers[consumerName]\n\tconsumer.numPendingEntries += len(claimedEntryIDs)\n\n\tgroup.setLastSuccess(consumerName, m.effectiveNow())\n\treturn\n}\n\nfunc writeXclaim(c *server.Peer, stream *streamKey, claimedEntryIDs []string, justId bool) {\n\tc.WriteLen(len(claimedEntryIDs))\n\tfor _, id := range claimedEntryIDs {\n\t\tif justId {\n\t\t\tc.WriteBulk(id)\n\t\t\tcontinue\n\t\t}\n\n\t\t_, entry := stream.get(id)\n\t\tif entry == nil {\n\t\t\tc.WriteNull()\n\t\t\tcontinue\n\t\t}\n\n\t\tc.WriteLen(2)\n\t\tc.WriteBulk(entry.ID)\n\t\tc.WriteStrings(entry.Values)\n\t}\n}\n\nfunc parseBlock(cmd string, args []string, block *bool, timeout *time.Duration) error {\n\tif len(args) < 2 {\n\t\treturn errors.New(errWrongNumber(cmd))\n\t}\n\t(*block) = true\n\tms, err := strconv.Atoi(args[1])\n\tif err != nil {\n\t\treturn errors.New(msgInvalidInt)\n\t}\n\tif ms < 0 {\n\t\treturn errors.New(\"ERR timeout is negative\")\n\t}\n\t(*timeout) = time.Millisecond * time.Duration(ms)\n\treturn nil\n}\n"
        },
        {
          "name": "cmd_stream_test.go",
          "type": "blob",
          "size": 41.44921875,
          "content": "package miniredis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test XADD / XLEN / XRANGE\nfunc TestStream(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"s\", \"1234567-89\", \"one\", \"1\", \"two\", \"2\",\n\t\tproto.String(\"1234567-89\"),\n\t)\n\n\tmust1(t, c,\n\t\t\"XLEN\", \"s\",\n\t)\n\n\tt.Run(\"TYPE\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"TYPE\", \"s\",\n\t\t\tproto.Inline(\"stream\"),\n\t\t)\n\t})\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"STREAM\", \"s\",\n\t\tproto.Array(proto.String(\"length\"), proto.Int(1)),\n\t)\n\n\tnow := time.Date(2001, 1, 1, 4, 4, 5, 4000000, time.UTC)\n\ts.SetTime(now)\n\n\tt.Run(\"direct usage\", func(t *testing.T) {\n\t\t_, err := s.XAdd(\"s1\", \"0-0\", []string{\"name\", \"foo\"})\n\t\tmustFail(t, err, msgStreamIDZero)\n\n\t\tid, err := s.XAdd(\"s1\", \"12345-67\", []string{\"name\", \"bar\"})\n\t\tok(t, err)\n\t\tequals(t, \"12345-67\", id)\n\n\t\t_, err = s.XAdd(\"s1\", \"12345-0\", []string{\"name\", \"foo\"})\n\t\tmustFail(t, err, msgStreamIDTooSmall)\n\n\t\tid, err = s.XAdd(\"s1\", \"*\", []string{\"name\", \"baz\"})\n\t\tok(t, err)\n\t\tequals(t, \"978321845004-0\", id)\n\n\t\tstream, err := s.Stream(\"s1\")\n\t\tok(t, err)\n\t\tequals(t, 2, len(stream))\n\t\tequals(t, StreamEntry{\n\t\t\tID:     \"12345-67\",\n\t\t\tValues: []string{\"name\", \"bar\"},\n\t\t}, stream[0])\n\t\tequals(t, StreamEntry{\n\t\t\tID:     \"978321845004-0\",\n\t\t\tValues: []string{\"name\", \"baz\"},\n\t\t}, stream[1])\n\t})\n\n\tuseRESP3(t, c)\n\tt.Run(\"resp3\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XINFO\", \"STREAM\", \"s\",\n\t\t\tproto.Map(proto.String(\"length\"), proto.Int(1)),\n\t\t)\n\t})\n}\n\n// Test XADD\nfunc TestStreamAdd(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"XADD\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"123456\", \"one\", \"11\", \"two\", \"22\",\n\t\t\tproto.String(\"123456-0\"),\n\t\t)\n\n\t\tres, err := c.Do(\"XADD\", \"s\", \"*\", \"one\", \"1\", \"two\", \"2\")\n\t\tok(t, err)\n\t\texp := `\\d+-0`\n\t\tmatched, err := regexp.MatchString(exp, res)\n\t\tok(t, err)\n\t\tassert(t, matched, \"expected: %#v got: %#v\", exp, res)\n\n\t\tk := fmt.Sprintf(\"%d-0\", uint64(math.MaxUint64-100))\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", k, \"one\", \"11\", \"two\", \"22\",\n\t\t\tproto.String(k),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"*\", \"one\", \"111\", \"two\", \"222\",\n\t\t\tproto.String(fmt.Sprintf(\"%d-1\", uint64(math.MaxUint64-100))),\n\t\t)\n\t})\n\n\tt.Run(\"XADD SetTime\", func(t *testing.T) {\n\t\tnow := time.Date(2001, 1, 1, 4, 4, 5, 4000000, time.UTC)\n\t\ts.SetTime(now)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"now\", \"*\", \"one\", \"1\",\n\t\t\tproto.String(\"978321845004-0\"),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"now\", \"*\", \"two\", \"2\",\n\t\t\tproto.String(\"978321845004-1\"),\n\t\t)\n\t})\n\n\tt.Run(\"XADD MAXLEN\", func(t *testing.T) {\n\t\tnow := time.Date(2001, 1, 1, 4, 4, 5, 4000000, time.UTC)\n\t\ts.SetTime(now)\n\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t_, err := c.Do(\"XADD\", \"nowy\", \"MAXLEN\", \"10\", \"*\", \"one\", \"1\")\n\t\t\tok(t, err)\n\t\t\tnowy, _ := s.Stream(\"nowy\")\n\t\t\tassert(t, len(nowy) <= 10, \"deleted entries\")\n\t\t}\n\t\tnowy, _ := s.Stream(\"nowy\")\n\t\tequals(t, 10, len(nowy))\n\n\t\tfor i := 0; i < 100; i++ {\n\t\t\t_, err := c.Do(\"XADD\", \"nowz\", \"MAXLEN\", \"~\", \"10\", \"*\", \"one\", \"1\")\n\t\t\tok(t, err)\n\t\t\tnowz, _ := s.Stream(\"nowz\")\n\t\t\tassert(t, len(nowz) <= 10, \"deleted entries\")\n\t\t}\n\t\tnowz, _ := s.Stream(\"nowz\")\n\t\tequals(t, 10, len(nowz))\n\t})\n\n\tt.Run(\"XADD MINID\", func(t *testing.T) {\n\t\tnow := time.Date(2023, 1, 1, 4, 4, 5, 4000000, time.UTC)\n\t\ts.SetTime(now)\n\n\t\tminID := strconv.FormatInt(now.Add(-time.Second).UnixNano()/time.Millisecond.Nanoseconds(), 10)\n\t\t_, err := c.Do(\"XADD\", \"mid\", \"MINID\", minID, \"*\", \"one\", \"1\")\n\t\tok(t, err)\n\t\t_, err = c.Do(\"XADD\", \"mid\", \"MINID\", minID, \"*\", \"two\", \"2\")\n\t\tok(t, err)\n\t\tnow = now.Add(time.Second)\n\t\ts.SetTime(now)\n\t\t_, err = c.Do(\"XADD\", \"mid\", \"MINID\", minID, \"*\", \"three\", \"3\")\n\t\tok(t, err)\n\t\tnow = now.Add(time.Second)\n\t\ts.SetTime(now)\n\t\t// advance the minID, older entries will be dropped\n\t\tminID = strconv.FormatInt(now.Add(-time.Second).UnixNano()/time.Millisecond.Nanoseconds(), 10)\n\t\t_, err = c.Do(\"XADD\", \"mid\", \"MINID\", minID, \"*\", \"four\", \"4\")\n\t\tok(t, err)\n\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"mid\", \"-\", \"+\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"1672545846004-0\"), proto.Strings(\"three\", \"3\")),\n\t\t\t\tproto.Array(proto.String(\"1672545847004-0\"), proto.Strings(\"four\", \"4\")),\n\t\t\t),\n\t\t)\n\t\t// advance now & minID and test with ~\n\t\tnow = now.Add(time.Second)\n\t\ts.SetTime(now)\n\t\tminID = strconv.FormatInt(now.Add(-time.Second).UnixNano()/time.Millisecond.Nanoseconds(), 10)\n\t\t_, err = c.Do(\"XADD\", \"mid\", \"MINID\", \"~\", minID, \"*\", \"five\", \"5\")\n\t\tok(t, err)\n\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"mid\", \"-\", \"+\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"1672545847004-0\"), proto.Strings(\"four\", \"4\")),\n\t\t\t\tproto.Array(proto.String(\"1672545848004-0\"), proto.Strings(\"five\", \"5\")),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"XADD NOMKSTREAM\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"reallynosuchkey\", \"NOMKSTREAM\", \"*\", \"one\", \"1\",\n\t\t\tproto.Nil,\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"reallynosuchkey\", \"NOMKSTREAM\", \"MINID\", \"1672545848004-0\", \"*\", \"one\", \"1\",\n\t\t\tproto.Nil,\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"reallynosuchkey\", \"NOMKSTREAM\", \"MAXLEN\", \"~\", \"10\", \"*\", \"one\", \"1\",\n\t\t\tproto.Nil,\n\t\t)\n\t})\n\n\tt.Run(\"error cases\", func(t *testing.T) {\n\t\t// Wrong type of key\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"str\", \"value\",\n\t\t)\n\t\t_, err := s.XAdd(\"str\", \"*\", []string{\"hi\", \"1\"})\n\t\tmustFail(t, err, msgWrongType)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"str\", \"*\", \"hi\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XADD\",\n\t\t\tproto.Error(errWrongNumber(\"xadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\",\n\t\t\tproto.Error(errWrongNumber(\"xadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"*\",\n\t\t\tproto.Error(errWrongNumber(\"xadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"*\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"xadd\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"MAXLEN\", \"!!!\", \"1000\", \"*\", \"key\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"MAXLEN\", \"~\", \"thousand\", \"*\", \"key\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"a-b\", \"one\", \"111\", \"two\", \"222\",\n\t\t\tproto.Error(\"ERR Invalid stream ID specified as stream command argument\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"0-0\", \"one\", \"111\", \"two\", \"222\",\n\t\t\tproto.Error(\"ERR The ID specified in XADD must be greater than 0-0\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", \"1234567-89\", \"one\", \"111\", \"two\", \"222\",\n\t\t\tproto.Error(\"ERR The ID specified in XADD is equal or smaller than the target stream top item\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XADD\", \"s\", fmt.Sprintf(\"%d-0\", uint64(math.MaxUint64-100)),\n\t\t\tproto.Error(errWrongNumber(\"xadd\")),\n\t\t)\n\t})\n}\n\n// Test XLEN\nfunc TestStreamLen(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t_, err := c.Do(\"XADD\", \"s\", \"*\", \"one\", \"1\", \"two\", \"2\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"s\", \"*\", \"one\", \"11\", \"two\", \"22\")\n\tok(t, err)\n\n\tt.Run(\"XLEN\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XLEN\", \"s\",\n\t\t\tproto.Int(2),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"XLEN\", \"s3\",\n\t\t)\n\t})\n\n\tt.Run(\"error cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XLEN\",\n\t\t\tproto.Error(errWrongNumber(\"xlen\")),\n\t\t)\n\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"str\", \"value\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XLEN\", \"str\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\n// Test XRANGE / XREVRANGE\nfunc TestStreamRange(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t_, err := c.Do(\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\", \"greek-god\", \"Hermes\", \"idx\", \"1\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"1-0\", \"name\", \"Venus\", \"greek-god\", \"Aphrodite\", \"idx\", \"2\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"2-1\", \"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"3-0\", \"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"4-1\", \"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")\n\tok(t, err)\n\n\tt.Run(\"XRANGE\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"planets\", \"1\", \"+\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"1-0\"), proto.Strings(\"name\", \"Venus\", \"greek-god\", \"Aphrodite\", \"idx\", \"2\")),\n\t\t\t\tproto.Array(proto.String(\"2-1\"), proto.Strings(\"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")),\n\t\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")),\n\t\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XREVRANGE\", \"planets\", \"3\", \"1\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")),\n\t\t\t\tproto.Array(proto.String(\"2-1\"), proto.Strings(\"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")),\n\t\t\t\tproto.Array(proto.String(\"1-0\"), proto.Strings(\"name\", \"Venus\", \"greek-god\", \"Aphrodite\", \"idx\", \"2\")),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"XRANGE exclusive ranges\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"planets\", \"(1\", \"+\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"2-1\"), proto.Strings(\"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")),\n\t\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")),\n\t\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XREVRANGE\", \"planets\", \"3\", \"(1\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")),\n\t\t\t\tproto.Array(proto.String(\"2-1\"), proto.Strings(\"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")),\n\t\t\t),\n\t\t)\n\t})\n\n\tt.Run(\"error cases\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"str\", \"-\", \"+\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\",\n\t\t\tproto.Error(errWrongNumber(\"xrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"xrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"xrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"2\", \"3\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"2\", \"3\", \"COUNT\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"2\", \"3\", \"COUNT\", \"1\", \"toomany\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"-\", \"noint\",\n\t\t\tproto.Error(msgInvalidStreamID),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"(-\", \"+\",\n\t\t\tproto.Error(msgInvalidStreamID),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XRANGE\", \"foo\", \"-\", \"(+\",\n\t\t\tproto.Error(msgInvalidStreamID),\n\t\t)\n\t})\n}\n\n// Test XREAD\nfunc TestStreamRead(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t_, err := c.Do(\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\", \"greek-god\", \"Hermes\", \"idx\", \"1\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"1-0\", \"name\", \"Venus\", \"greek-god\", \"Aphrodite\", \"idx\", \"2\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"2-1\", \"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"3-0\", \"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"4-1\", \"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")\n\tok(t, err)\n\n\t_, err = c.Do(\"XADD\", \"planets2\", \"0-1\", \"name\", \"Mercury\", \"greek-god\", \"Hermes\", \"idx\", \"1\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets2\", \"1-0\", \"name\", \"Venus\", \"greek-god\", \"Aphrodite\", \"idx\", \"2\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets2\", \"2-1\", \"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets2\", \"3-0\", \"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets2\", \"4-1\", \"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")\n\tok(t, err)\n\n\tt.Run(\"XREAD\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"planets\", \"1\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"planets\"),\n\t\t\t\t\tproto.Array(\n\t\t\t\t\t\tproto.Array(proto.String(\"2-1\"), proto.Strings(\"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")),\n\t\t\t\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")),\n\t\t\t\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"planets\", \"planets2\", \"1\", \"3\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"planets\"),\n\t\t\t\t\tproto.Array(\n\t\t\t\t\t\tproto.Array(proto.String(\"2-1\"), proto.Strings(\"name\", \"Earth\", \"greek-god\", \"\", \"idx\", \"3\")),\n\t\t\t\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"greek-god\", \"Ares\", \"name\", \"Mars\", \"idx\", \"4\")),\n\t\t\t\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\tproto.Array(proto.String(\"planets2\"),\n\t\t\t\t\tproto.Array(\n\t\t\t\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\", \"greek-god\", \"Dias\", \"idx\", \"5\")),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tt.Run(\"blocking async\", func(t *testing.T) {\n\t\t\t// XREAD blocking test using latest ID\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\txaddClient, err := proto.Dial(s.Addr())\n\t\t\t\tok(t, err)\n\t\t\t\tdefer xaddClient.Close()\n\t\t\t\tfor {\n\t\t\t\t\tselect {\n\t\t\t\t\tcase <-time.After(10 * time.Millisecond):\n\t\t\t\t\tcase <-ctx.Done():\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\t_, err = xaddClient.Do(\"XADD\", \"planets\", \"5-1\", \"name\", \"block\", \"idx\", \"6\")\n\t\t\t\t\tok(t, err)\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\tmustDo(t, c,\n\t\t\t\t\"XREAD\", \"BLOCK\", \"0\", \"STREAMS\", \"planets\", \"$\",\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.Array(proto.String(\"planets\"),\n\t\t\t\t\t\tproto.Array(\n\t\t\t\t\t\t\tproto.Array(proto.String(\"5-1\"), proto.Strings(\"name\", \"block\", \"idx\", \"6\")),\n\t\t\t\t\t\t),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t)\n\t\t\tcancel()\n\t\t\twg.Wait()\n\t\t})\n\t})\n\n\tt.Run(\"error cases\", func(t *testing.T) {\n\t\tmustOK(t, c, \"SET\", \"str\", \"value\")\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\",\n\t\t\tproto.Error(errWrongNumber(\"xread\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"xread\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"foo\", \"bar\", \"1\",\n\t\t\tproto.Error(msgXreadUnbalanced),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"COUNT\",\n\t\t\tproto.Error(errWrongNumber(\"xread\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"COUNT\", \"notint\",\n\t\t\tproto.Error(errWrongNumber(\"xread\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"COUNT\", \"10\", // no STREAMS\n\t\t\tproto.Error(errWrongNumber(\"xread\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"foo\", \"noint\",\n\t\t\tproto.Error(msgInvalidStreamID),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"str\", \"noint\",\n\t\t\tproto.Error(msgInvalidStreamID),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XREAD\", \"STREAMS\", \"foo\", \"2\", \"noint\",\n\t\t\tproto.Error(msgXreadUnbalanced),\n\t\t)\n\t})\n}\n\n// Test XINFO\nfunc TestStreamInfo(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"STREAM\", \"planets\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\", \"greek-god\", \"Hermes\", \"idx\", \"1\",\n\t\tproto.String(\"0-1\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"STREAM\", \"planets\",\n\t\tproto.Array(proto.String(\"length\"), proto.Int(1)),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\", \"foo\", \"bar\",\n\t\tproto.Error(\"ERR wrong number of arguments for 'groups' command\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"foo\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"foo\", \"bar\",\n\t\tproto.Error(\"ERR no such key\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Error(\"NOGROUP No such consumer group 'processing' for key name 'planets'\"),\n\t)\n}\n\n// Test XGROUP\nfunc TestStreamGroup(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"s\", \"processing\", \"$\",\n\t\tproto.Error(msgXgroupKeyNotFound),\n\t)\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DESTROY\", \"s\", \"processing\",\n\t\tproto.Error(msgXgroupKeyNotFound),\n\t)\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DELCONSUMER\", \"s\", \"processing\", \"foo\",\n\t\tproto.Error(msgXgroupKeyNotFound),\n\t)\n\n\tmustOK(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"s\", \"processing\", \"$\", \"MKSTREAM\",\n\t)\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DESTROY\", \"s\", \"foo\",\n\t\tproto.Int(0),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"s\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(0),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-0\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(0),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"s\", \"processing\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"CREATECONSUMER\", \"s\", \"processing\", \"alice\",\n\t\tproto.Int(1),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"s\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(1),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-0\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(0),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"s\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DELCONSUMER\", \"s\", \"processing\", \"foo\",\n\t\tproto.Int(0),\n\t)\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DELCONSUMER\", \"s\", \"processing\", \"alice\",\n\t\tproto.Int(0),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"s\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(0),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-0\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(0),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"s\", \"processing\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DESTROY\", \"s\", \"processing\",\n\t\tproto.Int(1),\n\t)\n\tmust0(t, c,\n\t\t\"XLEN\", \"s\",\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"s\",\n\t\tproto.Array(),\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XGROUP\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'xgroup' command\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XGROUP\", \"HELP\",\n\t\t\tproto.Error(\"ERR 'XGROUP help' not supported\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XGROUP\", \"foo\",\n\t\t\tproto.Error(\"ERR unknown subcommand 'foo'. Try XGROUP HELP.\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XGROUP\", \"SETID\",\n\t\t\tproto.Error(\"ERR 'XGROUP setid' not supported\"),\n\t\t)\n\t})\n}\n\n// Test XREADGROUP\nfunc TestStreamReadGroup(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Error(\"NOGROUP No such key 'planets' or consumer group 'processing' in XREADGROUP with GROUP option\"),\n\t)\n\n\tmustOK(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"planets\", \"processing\", \"$\", \"MKSTREAM\",\n\t)\n\n\tmustNilList(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(0),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-0\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(0),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\",\n\t\tproto.String(\"0-1\"),\n\t)\n\n\tmust1(t, c,\n\t\t\"XLEN\", \"planets\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"planets\"), proto.Array(proto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")))),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(1),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-1\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustNilList(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t)\n\n\t// Read from PEL\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \"0-0\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"planets\"), proto.Array(proto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")))),\n\t\t),\n\t)\n}\n\n// Test XDEL\nfunc TestStreamDelete(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustOK(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"planets\", \"processing\", \"$\", \"MKSTREAM\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\",\n\t\tproto.String(\"0-1\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"planets\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.Array(\n\t\t\t\t\t\tproto.String(\"0-1\"),\n\t\t\t\t\t\tproto.Strings(\"name\", \"Mercury\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-2\", \"name\", \"Mercury\",\n\t\tproto.String(\"0-2\"),\n\t)\n\n\tmust1(t, c,\n\t\t\"XDEL\", \"planets\", \"0-1\",\n\t)\n\n\tmust1(t, c,\n\t\t\"XDEL\", \"planets\", \"0-2\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \"0-0\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"planets\"),\n\t\t\t\tproto.Array(),\n\t\t\t),\n\t\t),\n\t)\n}\n\n// Test XACK\nfunc TestStreamAck(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tmustOK(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"planets\", \"processing\", \"$\", \"MKSTREAM\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\",\n\t\tproto.String(\"0-1\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"planets\"), proto.Array(proto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")))),\n\t\t),\n\t)\n\n\tmust1(t, c,\n\t\t\"XACK\", \"planets\", \"processing\", \"0-1\",\n\t)\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \"0-0\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"planets\"),\n\t\t\t\tproto.Array(),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(1),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-1\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DELCONSUMER\", \"planets\", \"processing\", \"alice\",\n\t\tproto.Int(0),\n\t)\n}\n\n// Test XPENDING\nfunc TestStreamXpending(t *testing.T) {\n\ts, c := runWithClient(t)\n\tnow := time.Now()\n\ts.SetTime(now)\n\n\tmustOK(t, c, \"XGROUP\", \"CREATE\", \"planets\", \"processing\", \"$\", \"MKSTREAM\")\n\tmustDo(t, c, \"XADD\", \"planets\", \"99-1\", \"name\", \"Mercury\",\n\t\tproto.String(\"99-1\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"planets\"),\n\t\t\t\tproto.Array(proto.Array(proto.String(\"99-1\"), proto.Strings(\"name\", \"Mercury\"))),\n\t\t\t),\n\t\t),\n\t)\n\n\tt.Run(\"summary mode\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Int(1),\n\t\t\t\tproto.String(\"99-1\"),\n\t\t\t\tproto.String(\"99-1\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.Array(proto.String(\"alice\"), proto.String(\"1\")),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"nosuch\", \"processing\",\n\t\t\tproto.Error(\"NOGROUP No such key 'nosuch' or consumer group 'processing'\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"nosuch\",\n\t\t\tproto.Error(\"NOGROUP No such key 'planets' or consumer group 'nosuch'\"),\n\t\t)\n\t})\n\n\tt.Run(\"full mode\", func(t *testing.T) {\n\t\ts.SetTime(now.Add(3 * time.Second))\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"99-1\"),\n\t\t\t\t\tproto.String(\"alice\"),\n\t\t\t\t\tproto.Int(3000),\n\t\t\t\t\tproto.Int(1),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"-99\",\n\t\t\tproto.NilList,\n\t\t)\n\n\t\t// Increase delivery count\n\t\ts.SetTime(now.Add(5 * time.Second))\n\t\tmustDo(t, c,\n\t\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \"99-0\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"planets\"), proto.Array(proto.Array(proto.String(\"99-1\"), proto.Strings(\"name\", \"Mercury\")))),\n\t\t\t),\n\t\t)\n\t\ts.SetTime(now.Add(9 * time.Second))\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"99-1\"),\n\t\t\t\t\tproto.String(\"alice\"),\n\t\t\t\t\tproto.Int(4000),\n\t\t\t\t\tproto.Int(2),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"IDLE\", \"5000\", \"-\", \"+\", \"999\",\n\t\t\tproto.NilList,\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\", \"bob\",\n\t\t\tproto.NilList,\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"IDLE\", \"4000\", \"-\", \"+\", \"999\", \"alice\",\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.String(\"99-1\"),\n\t\t\t\t\tproto.String(\"alice\"),\n\t\t\t\t\tproto.Int(4000),\n\t\t\t\t\tproto.Int(2),\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"XGROUP\", \"DELCONSUMER\", \"planets\", \"processing\", \"alice\",\n\t\t\tproto.Int(1),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\t\tproto.NilList,\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'xpending' command\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for 'xpending' command\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"toomany\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"IDLE\", \"1000\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"cons\", \"nine\",\n\t\t\tproto.Error(\"ERR value is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"99\", \"cons\", \"foo\",\n\t\t\tproto.Error(\"ERR syntax error\"),\n\t\t)\n\t})\n}\n\n// Test XTRIM\nfunc TestStreamTrim(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\tt.Run(\"error cases\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"XTRIM\", \"planets\", \"UNKNOWN_STRATEGY\", \"4\",\n\t\t\tproto.Error(msgXtrimInvalidStrategy))\n\t\tmustDo(t, c,\n\t\t\t\"XTRIM\", \"planets\",\n\t\t\tproto.Error(errWrongNumber(\"xtrim\")))\n\t\tmustDo(t, c,\n\t\t\t\"XTRIM\", \"planets\", \"MAXLEN\", \"notANumber\",\n\t\t\tproto.Error(msgXtrimInvalidMaxLen))\n\t})\n\n\t_, err := c.Do(\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"1-0\", \"name\", \"Venus\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"2-1\", \"name\", \"Earth\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"3-0\", \"name\", \"Mars\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"4-1\", \"name\", \"Jupiter\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"5-1\", \"name\", \"Saturn\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"5-2\", \"name\", \"Uranus\")\n\tok(t, err)\n\t_, err = c.Do(\"XADD\", \"planets\", \"5-11\", \"name\", \"Pluto\")\n\tok(t, err)\n\n\tmustDo(t, c,\n\t\t\"XTRIM\", \"planets\", \"MAXLEN\", \"=\", \"5\", proto.Int(3))\n\n\tmustDo(t, c,\n\t\t\"XRANGE\", \"planets\", \"-\", \"+\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"3-0\"), proto.Strings(\"name\", \"Mars\")),\n\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\")),\n\t\t\tproto.Array(proto.String(\"5-1\"), proto.Strings(\"name\", \"Saturn\")),\n\t\t\tproto.Array(proto.String(\"5-2\"), proto.Strings(\"name\", \"Uranus\")),\n\t\t\tproto.Array(proto.String(\"5-11\"), proto.Strings(\"name\", \"Pluto\")),\n\t\t))\n\n\tmustDo(t, c,\n\t\t\"XTRIM\", \"planets\", \"MINID\", \"~\", \"4\", \"LIMIT\", \"50\", proto.Int(1))\n\n\tmustDo(t, c,\n\t\t\"XRANGE\", \"planets\", \"-\", \"+\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"4-1\"), proto.Strings(\"name\", \"Jupiter\")),\n\t\t\tproto.Array(proto.String(\"5-1\"), proto.Strings(\"name\", \"Saturn\")),\n\t\t\tproto.Array(proto.String(\"5-2\"), proto.Strings(\"name\", \"Uranus\")),\n\t\t\tproto.Array(proto.String(\"5-11\"), proto.Strings(\"name\", \"Pluto\")),\n\t\t))\n\n\tmustDo(t, c,\n\t\t\"XTRIM\", \"planets\", \"MINID\", \"5\", proto.Int(1))\n\n\tmustDo(t, c,\n\t\t\"XRANGE\", \"planets\", \"-\", \"+\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"5-1\"), proto.Strings(\"name\", \"Saturn\")),\n\t\t\tproto.Array(proto.String(\"5-2\"), proto.Strings(\"name\", \"Uranus\")),\n\t\t\tproto.Array(proto.String(\"5-11\"), proto.Strings(\"name\", \"Pluto\")),\n\t\t))\n\n\tmustDo(t, c,\n\t\t\"XTRIM\", \"planets\", \"MINID\", \"5-11\", proto.Int(2))\n\n\tmustDo(t, c,\n\t\t\"XRANGE\", \"planets\", \"-\", \"+\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"5-11\"), proto.Strings(\"name\", \"Pluto\")),\n\t\t))\n}\n\nfunc TestStreamAutoClaim(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tnow := time.Now()\n\ts.SetTime(now)\n\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0\",\n\t\tproto.Error(\"NOGROUP No such key 'planets' or consumer group 'processing'\"),\n\t)\n\n\tmustOK(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"planets\", \"processing\", \"$\", \"MKSTREAM\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\",\n\t\tproto.String(\"0-1\"),\n\t)\n\n\tmust1(t, c,\n\t\t\"XLEN\", \"planets\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"planets\"), proto.Array(proto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")))),\n\t\t),\n\t)\n\n\t// Read message already claimed\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(proto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\"))),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\t// Add an additional item to pending\n\ts.SetTime(now.Add(5000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-2\", \"name\", \"Venus\",\n\t\tproto.String(\"0-2\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"planets\"), proto.Array(proto.Array(proto.String(\"0-2\"), proto.Strings(\"name\", \"Venus\")))),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(2),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\t// Autoclaim with a min idle time that should not catch any items\n\ts.SetTime(now.Add(10000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"15000\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\n\t// Set time further in the future where autoclaim with min idle time should\n\t// return only one result\n\ts.SetTime(now.Add(15000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"15000\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")),\n\t\t\t),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\n\t// Further in the future we should return Venus but not Mercury since it is\n\t// claimed more recently\n\ts.SetTime(now.Add(25000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"15000\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"0-2\"), proto.Strings(\"name\", \"Venus\")),\n\t\t\t),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\n\t// Even further in the future we should return both\n\ts.SetTime(now.Add(40000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"15000\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")),\n\t\t\t\tproto.Array(proto.String(\"0-2\"), proto.Strings(\"name\", \"Venus\")),\n\t\t\t),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(2),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\ts.SetTime(now.Add(60000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"bob\", \"15000\", \"0\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-0\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")),\n\t\t\t\tproto.Array(proto.String(\"0-2\"), proto.Strings(\"name\", \"Venus\")),\n\t\t\t),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"bob\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(2),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\ts.SetTime(now.Add(80000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XAUTOCLAIM\", \"planets\", \"processing\", \"alice\", \"15000\", \"0\", \"COUNT\", \"1\",\n\t\tproto.Array(\n\t\t\tproto.String(\"0-2\"),\n\t\t\tproto.Array(\n\t\t\t\tproto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")),\n\t\t\t),\n\t\t\tproto.Array(),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"bob\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"idle\"), proto.Int(-1),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DELCONSUMER\", \"planets\", \"processing\", \"alice\",\n\t\tproto.Int(1),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-2\"),\n\t\t\t\tproto.String(\"bob\"),\n\t\t\t\tproto.Int(20000),\n\t\t\t\tproto.Int(4),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XGROUP\", \"DELCONSUMER\", \"planets\", \"processing\", \"bob\",\n\t\tproto.Int(1),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(0),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-2\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(2),\n\t\t\t),\n\t\t),\n\t)\n}\n\nfunc TestStreamClaim(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tnow := time.Now()\n\ts.SetTime(now)\n\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0-0\",\n\t\tproto.Error(\"NOGROUP No such key 'planets' or consumer group 'processing'\"),\n\t)\n\n\tmustOK(t, c,\n\t\t\"XGROUP\", \"CREATE\", \"planets\", \"processing\", \"$\", \"MKSTREAM\",\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0-0\",\n\t\tproto.Array(),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"idle\"), proto.Int(0),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-1\", \"name\", \"Mercury\",\n\t\tproto.String(\"0-1\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-2\", \"name\", \"Venus\",\n\t\tproto.String(\"0-2\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0-1\",\n\t\tproto.Array(),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.NilList,\n\t)\n\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0-1\", \"0-2\", \"FORCE\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"0-1\"), proto.Strings(\"name\", \"Mercury\")),\n\t\t\tproto.Array(proto.String(\"0-2\"), proto.Strings(\"name\", \"Venus\")),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(1),\n\t\t\t\tproto.String(\"pending\"), proto.Int(2),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-0\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(2),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(2),\n\t\t\t\tproto.String(\"idle\"), proto.Int(0),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(0),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-1\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(2),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-2\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(2),\n\t\t\t),\n\t\t),\n\t)\n\n\ts.SetTime(now.Add(20000 * time.Millisecond))\n\tmustDo(t, c,\n\t\t\"XDEL\", \"planets\", \"0-1\",\n\t\tproto.Int(1),\n\t)\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"bob\", \"0\", \"0-1\",\n\t\tproto.Array(),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"GROUPS\", \"planets\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"processing\"),\n\t\t\t\tproto.String(\"consumers\"), proto.Int(2),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"last-delivered-id\"), proto.String(\"0-0\"),\n\t\t\t\tproto.String(\"entries-read\"), proto.Nil,\n\t\t\t\tproto.String(\"lag\"), proto.Int(1),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(1),\n\t\t\t\tproto.String(\"idle\"), proto.Int(20000),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(20000),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"bob\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0),\n\t\t\t\tproto.String(\"idle\"), proto.Int(0),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(-1),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-1\"),\n\t\t\t\tproto.String(\"bob\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(3),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-2\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(20000),\n\t\t\t\tproto.Int(2),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-3\", \"name\", \"Earth\",\n\t\tproto.String(\"0-3\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XADD\", \"planets\", \"0-4\", \"name\", \"Mars\",\n\t\tproto.String(\"0-4\"),\n\t)\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"bob\", \"0\", \"0-4\", \"FORCE\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"0-4\"), proto.Strings(\"name\", \"Mars\")),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"bob\", \"0\", \"0-4\",\n\t\tproto.Array(\n\t\t\tproto.Array(proto.String(\"0-4\"), proto.Strings(\"name\", \"Mars\")),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-1\"),\n\t\t\t\tproto.String(\"bob\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(3),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-2\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(20000),\n\t\t\t\tproto.Int(2),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-4\"),\n\t\t\t\tproto.String(\"bob\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(3),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XREADGROUP\", \"GROUP\", \"processing\", \"alice\", \"STREAMS\", \"planets\", \">\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"planets\"),\n\t\t\t\tproto.Array(\n\t\t\t\t\tproto.Array(proto.String(\"0-2\"), proto.Strings(\"name\", \"Venus\")),\n\t\t\t\t\tproto.Array(proto.String(\"0-3\"), proto.Strings(\"name\", \"Earth\")),\n\t\t\t\t\tproto.Array(proto.String(\"0-4\"), proto.Strings(\"name\", \"Mars\")),\n\t\t\t\t),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-1\"),\n\t\t\t\tproto.String(\"bob\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(3),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-2\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-3\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-4\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t),\n\t)\n\tmustDo(t, c,\n\t\t\"XINFO\", \"CONSUMERS\", \"planets\", \"processing\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"alice\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(3),\n\t\t\t\tproto.String(\"idle\"), proto.Int(20000),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(20000),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"name\"), proto.String(\"bob\"),\n\t\t\t\tproto.String(\"pending\"), proto.Int(0), // deleted\n\t\t\t\tproto.String(\"idle\"), proto.Int(0),\n\t\t\t\tproto.String(\"inactive\"), proto.Int(0),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0-3\", \"RETRYCOUNT\", \"10\", \"IDLE\", \"5000\", \"JUSTID\",\n\t\tproto.Array(proto.String(\"0-3\")),\n\t)\n\tnewTime := s.effectiveNow().Add(time.Millisecond * time.Duration(-10000))\n\tnewTimeString := strconv.FormatInt(newTime.UnixNano()/time.Millisecond.Nanoseconds(), 10)\n\tmustDo(t, c,\n\t\t\"XCLAIM\", \"planets\", \"processing\", \"alice\", \"0\", \"0-1\", \"RETRYCOUNT\", \"1\", \"TIME\", newTimeString, \"JUSTID\",\n\t\tproto.Array(),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.Array(\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-1\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(10000),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-2\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-3\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(5000),\n\t\t\t\tproto.Int(10),\n\t\t\t),\n\t\t\tproto.Array(\n\t\t\t\tproto.String(\"0-4\"),\n\t\t\t\tproto.String(\"alice\"),\n\t\t\t\tproto.Int(0),\n\t\t\t\tproto.Int(1),\n\t\t\t),\n\t\t),\n\t)\n\n\tmustDo(t, c,\n\t\t\"XACK\", \"planets\", \"processing\", \"0-1\", \"0-2\", \"0-3\", \"0-4\",\n\t\tproto.Int(3),\n\t)\n\tmustDo(t, c,\n\t\t\"XPENDING\", \"planets\", \"processing\", \"-\", \"+\", \"999\",\n\t\tproto.NilList,\n\t)\n}\n"
        },
        {
          "name": "cmd_string.go",
          "type": "blob",
          "size": 25.123046875,
          "content": "// Commands from https://redis.io/commands#string\n\npackage miniredis\n\nimport (\n\t\"math/big\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsString handles all string value operations.\nfunc commandsString(m *Miniredis) {\n\tm.srv.Register(\"APPEND\", m.cmdAppend)\n\tm.srv.Register(\"BITCOUNT\", m.cmdBitcount)\n\tm.srv.Register(\"BITOP\", m.cmdBitop)\n\tm.srv.Register(\"BITPOS\", m.cmdBitpos)\n\tm.srv.Register(\"DECRBY\", m.cmdDecrby)\n\tm.srv.Register(\"DECR\", m.cmdDecr)\n\tm.srv.Register(\"GETBIT\", m.cmdGetbit)\n\tm.srv.Register(\"GET\", m.cmdGet)\n\tm.srv.Register(\"GETEX\", m.cmdGetex)\n\tm.srv.Register(\"GETRANGE\", m.cmdGetrange)\n\tm.srv.Register(\"GETSET\", m.cmdGetset)\n\tm.srv.Register(\"GETDEL\", m.cmdGetdel)\n\tm.srv.Register(\"INCRBYFLOAT\", m.cmdIncrbyfloat)\n\tm.srv.Register(\"INCRBY\", m.cmdIncrby)\n\tm.srv.Register(\"INCR\", m.cmdIncr)\n\tm.srv.Register(\"MGET\", m.cmdMget)\n\tm.srv.Register(\"MSET\", m.cmdMset)\n\tm.srv.Register(\"MSETNX\", m.cmdMsetnx)\n\tm.srv.Register(\"PSETEX\", m.cmdPsetex)\n\tm.srv.Register(\"SETBIT\", m.cmdSetbit)\n\tm.srv.Register(\"SETEX\", m.cmdSetex)\n\tm.srv.Register(\"SET\", m.cmdSet)\n\tm.srv.Register(\"SETNX\", m.cmdSetnx)\n\tm.srv.Register(\"SETRANGE\", m.cmdSetrange)\n\tm.srv.Register(\"STRLEN\", m.cmdStrlen)\n}\n\n// SET\nfunc (m *Miniredis) cmdSet(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey     string\n\t\tvalue   string\n\t\tnx      bool // set iff not exists\n\t\txx      bool // set iff exists\n\t\tkeepttl bool // set keepttl\n\t\tttlSet  bool\n\t\tttl     time.Duration\n\t\tget     bool\n\t}\n\n\topts.key, opts.value, args = args[0], args[1], args[2:]\n\tfor len(args) > 0 {\n\t\ttimeUnit := time.Second\n\t\tswitch arg := strings.ToUpper(args[0]); arg {\n\t\tcase \"NX\":\n\t\t\topts.nx = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"XX\":\n\t\t\topts.xx = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"KEEPTTL\":\n\t\t\topts.keepttl = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tcase \"PX\", \"PXAT\":\n\t\t\ttimeUnit = time.Millisecond\n\t\t\tfallthrough\n\t\tcase \"EX\", \"EXAT\":\n\t\t\tif len(args) < 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif opts.ttlSet {\n\t\t\t\t// multiple ex/exat/px/pxat options set\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\texpire, err := strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif expire <= 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidSETime)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif arg == \"PXAT\" || arg == \"EXAT\" {\n\t\t\t\topts.ttl = m.at(expire, timeUnit)\n\t\t\t} else {\n\t\t\t\topts.ttl = time.Duration(expire) * timeUnit\n\t\t\t}\n\t\t\topts.ttlSet = true\n\n\t\t\targs = args[2:]\n\t\t\tcontinue\n\t\tcase \"GET\":\n\t\t\topts.get = true\n\t\t\targs = args[1:]\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\treadonly := false\n\t\tif opts.nx {\n\t\t\tif db.exists(opts.key) {\n\t\t\t\tif opts.get {\n\t\t\t\t\t// special case for SET NX GET\n\t\t\t\t\treadonly = true\n\t\t\t\t} else {\n\t\t\t\t\tc.WriteNull()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif opts.xx {\n\t\t\tif !db.exists(opts.key) {\n\t\t\t\tif opts.get {\n\t\t\t\t\t// special case for SET XX GET\n\t\t\t\t\treadonly = true\n\t\t\t\t} else {\n\t\t\t\t\tc.WriteNull()\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif opts.keepttl {\n\t\t\tif val, ok := db.ttl[opts.key]; ok {\n\t\t\t\topts.ttl = val\n\t\t\t}\n\t\t}\n\t\tif opts.get {\n\t\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\told, existed := db.stringKeys[opts.key]\n\t\tif !readonly {\n\t\t\tdb.del(opts.key, true) // be sure to remove existing values of other type keys.\n\t\t\t// a vanilla SET clears the expire\n\t\t\tif opts.ttl >= 0 { // EXAT/PXAT can expire right away\n\t\t\t\tdb.stringSet(opts.key, opts.value)\n\t\t\t}\n\t\t\tif opts.ttl != 0 {\n\t\t\t\tdb.ttl[opts.key] = opts.ttl\n\t\t\t}\n\t\t}\n\t\tif opts.get {\n\t\t\tif !existed {\n\t\t\t\tc.WriteNull()\n\t\t\t} else {\n\t\t\t\tc.WriteBulk(old)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tc.WriteOK()\n\t})\n}\n\n// SETEX\nfunc (m *Miniredis) cmdSetex(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\tttl, err := strconv.Atoi(args[1])\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidInt)\n\t\treturn\n\t}\n\tif ttl <= 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidSETEXTime)\n\t\treturn\n\t}\n\tvalue := args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tdb.del(key, true) // Clear any existing keys.\n\t\tdb.stringSet(key, value)\n\t\tdb.ttl[key] = time.Duration(ttl) * time.Second\n\t\tc.WriteOK()\n\t})\n}\n\n// PSETEX\nfunc (m *Miniredis) cmdPsetex(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tttl   int\n\t\tvalue string\n\t}\n\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.ttl); !ok {\n\t\treturn\n\t}\n\tif opts.ttl <= 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidPSETEXTime)\n\t\treturn\n\t}\n\topts.value = args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tdb.del(opts.key, true) // Clear any existing keys.\n\t\tdb.stringSet(opts.key, opts.value)\n\t\tdb.ttl[opts.key] = time.Duration(opts.ttl) * time.Millisecond\n\t\tc.WriteOK()\n\t})\n}\n\n// SETNX\nfunc (m *Miniredis) cmdSetnx(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, value := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif _, ok := db.keys[key]; ok {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\n\t\tdb.stringSet(key, value)\n\t\tc.WriteInt(1)\n\t})\n}\n\n// MSET\nfunc (m *Miniredis) cmdMset(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tif len(args)%2 != 0 {\n\t\tsetDirty(c)\n\t\t// non-default error message\n\t\tc.WriteError(\"ERR wrong number of arguments for MSET\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tfor len(args) > 0 {\n\t\t\tkey, value := args[0], args[1]\n\t\t\targs = args[2:]\n\n\t\t\tdb.del(key, true) // clear TTL\n\t\t\tdb.stringSet(key, value)\n\t\t}\n\t\tc.WriteOK()\n\t})\n}\n\n// MSETNX\nfunc (m *Miniredis) cmdMsetnx(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tif len(args)%2 != 0 {\n\t\tsetDirty(c)\n\t\t// non-default error message (yes, with 'MSET').\n\t\tc.WriteError(\"ERR wrong number of arguments for MSET\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tkeys := map[string]string{}\n\t\texisting := false\n\t\tfor len(args) > 0 {\n\t\t\tkey := args[0]\n\t\t\tvalue := args[1]\n\t\t\targs = args[2:]\n\t\t\tkeys[key] = value\n\t\t\tif _, ok := db.keys[key]; ok {\n\t\t\t\texisting = true\n\t\t\t}\n\t\t}\n\n\t\tres := 0\n\t\tif !existing {\n\t\t\tres = 1\n\t\t\tfor k, v := range keys {\n\t\t\t\t// Nothing to delete. That's the whole point.\n\t\t\t\tdb.stringSet(k, v)\n\t\t\t}\n\t\t}\n\t\tc.WriteInt(res)\n\t})\n}\n\n// GET\nfunc (m *Miniredis) cmdGet(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tif db.t(key) != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteBulk(db.stringGet(key))\n\t})\n}\n\n// GETEX\nfunc (m *Miniredis) cmdGetex(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey     string\n\t\tttl     time.Duration\n\t\tpersist bool // remove existing TTL on the key.\n\t}\n\n\topts.key, args = args[0], args[1:]\n\tif len(args) > 0 {\n\t\ttimeUnit := time.Second\n\t\tswitch arg := strings.ToUpper(args[0]); arg {\n\t\tcase \"PERSIST\":\n\t\t\tif len(args) > 1 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\topts.persist = true\n\t\tcase \"PX\", \"PXAT\":\n\t\t\ttimeUnit = time.Millisecond\n\t\t\tfallthrough\n\t\tcase \"EX\", \"EXAT\":\n\t\t\tif len(args) != 2 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgSyntaxError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\texpire, err := strconv.Atoi(args[1])\n\t\t\tif err != nil {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidInt)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif expire <= 0 {\n\t\t\t\tsetDirty(c)\n\t\t\t\tc.WriteError(msgInvalidSETime)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tif arg == \"PXAT\" || arg == \"EXAT\" {\n\t\t\t\topts.ttl = m.at(expire, timeUnit)\n\t\t\t} else {\n\t\t\t\topts.ttl = time.Duration(expire) * timeUnit\n\t\t\t}\n\t\tdefault:\n\t\t\tsetDirty(c)\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tswitch {\n\t\tcase opts.persist:\n\t\t\tdelete(db.ttl, opts.key)\n\t\tcase opts.ttl != 0:\n\t\t\tdb.ttl[opts.key] = opts.ttl\n\t\t}\n\n\t\tif db.t(opts.key) != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteBulk(db.stringGet(opts.key))\n\t})\n}\n\n// GETSET\nfunc (m *Miniredis) cmdGetset(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, value := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\told, ok := db.stringKeys[key]\n\t\tdb.stringSet(key, value)\n\t\t// a GETSET clears the ttl\n\t\tdelete(db.ttl, key)\n\n\t\tif !ok {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\t\tc.WriteBulk(old)\n\t})\n}\n\n// GETDEL\nfunc (m *Miniredis) cmdGetdel(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tkey := args[0]\n\n\t\tif !db.exists(key) {\n\t\t\tc.WriteNull()\n\t\t\treturn\n\t\t}\n\n\t\tif db.t(key) != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv := db.stringGet(key)\n\t\tdb.del(key, true)\n\t\tc.WriteBulk(v)\n\t})\n}\n\n// MGET\nfunc (m *Miniredis) cmdMget(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tc.WriteLen(len(args))\n\t\tfor _, k := range args {\n\t\t\tif t, ok := db.keys[k]; !ok || t != \"string\" {\n\t\t\t\tc.WriteNull()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tv, ok := db.stringKeys[k]\n\t\t\tif !ok {\n\t\t\t\t// Should not happen, we just checked keys[]\n\t\t\t\tc.WriteNull()\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc.WriteBulk(v)\n\t\t}\n\t})\n}\n\n// INCR\nfunc (m *Miniredis) cmdIncr(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tkey := args[0]\n\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tv, err := db.stringIncr(key, +1)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Don't touch TTL\n\t\tc.WriteInt(v)\n\t})\n}\n\n// INCRBY\nfunc (m *Miniredis) cmdIncrby(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tdelta int\n\t}\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.delta); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv, err := db.stringIncr(opts.key, opts.delta)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Don't touch TTL\n\t\tc.WriteInt(v)\n\t})\n}\n\n// INCRBYFLOAT\nfunc (m *Miniredis) cmdIncrbyfloat(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\tdelta, _, err := big.ParseFloat(args[1], 10, 128, 0)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidFloat)\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv, err := db.stringIncrfloat(key, delta)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Don't touch TTL\n\t\tc.WriteBulk(formatBig(v))\n\t})\n}\n\n// DECR\nfunc (m *Miniredis) cmdDecr(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tkey := args[0]\n\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tv, err := db.stringIncr(key, -1)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Don't touch TTL\n\t\tc.WriteInt(v)\n\t})\n}\n\n// DECRBY\nfunc (m *Miniredis) cmdDecrby(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tdelta int\n\t}\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.delta); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv, err := db.stringIncr(opts.key, -opts.delta)\n\t\tif err != nil {\n\t\t\tc.WriteError(err.Error())\n\t\t\treturn\n\t\t}\n\t\t// Don't touch TTL\n\t\tc.WriteInt(v)\n\t})\n}\n\n// STRLEN\nfunc (m *Miniredis) cmdStrlen(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey := args[0]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tc.WriteInt(len(db.stringKeys[key]))\n\t})\n}\n\n// APPEND\nfunc (m *Miniredis) cmdAppend(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tkey, value := args[0], args[1]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tnewValue := db.stringKeys[key] + value\n\t\tdb.stringSet(key, newValue)\n\n\t\tc.WriteInt(len(newValue))\n\t})\n}\n\n// GETRANGE\nfunc (m *Miniredis) cmdGetrange(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tstart int\n\t\tend   int\n\t}\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.start); !ok {\n\t\treturn\n\t}\n\tif ok := optInt(c, args[2], &opts.end); !ok {\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv := db.stringKeys[opts.key]\n\t\tc.WriteBulk(withRange(v, opts.start, opts.end))\n\t})\n}\n\n// SETRANGE\nfunc (m *Miniredis) cmdSetrange(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey   string\n\t\tpos   int\n\t\tsubst string\n\t}\n\topts.key = args[0]\n\tif ok := optInt(c, args[1], &opts.pos); !ok {\n\t\treturn\n\t}\n\tif opts.pos < 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR offset is out of range\")\n\t\treturn\n\t}\n\topts.subst = args[2]\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\tv := []byte(db.stringKeys[opts.key])\n\t\tend := opts.pos + len(opts.subst)\n\t\tif len(v) < end {\n\t\t\tnewV := make([]byte, end)\n\t\t\tcopy(newV, v)\n\t\t\tv = newV\n\t\t}\n\t\tcopy(v[opts.pos:end], opts.subst)\n\t\tdb.stringSet(opts.key, string(v))\n\t\tc.WriteInt(len(v))\n\t})\n}\n\n// BITCOUNT\nfunc (m *Miniredis) cmdBitcount(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tuseRange bool\n\t\tstart    int\n\t\tend      int\n\t\tkey      string\n\t}\n\topts.key, args = args[0], args[1:]\n\tif len(args) >= 2 {\n\t\topts.useRange = true\n\t\tif ok := optInt(c, args[0], &opts.start); !ok {\n\t\t\treturn\n\t\t}\n\t\tif ok := optInt(c, args[1], &opts.end); !ok {\n\t\t\treturn\n\t\t}\n\t\targs = args[2:]\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif !db.exists(opts.key) {\n\t\t\tc.WriteInt(0)\n\t\t\treturn\n\t\t}\n\t\tif db.t(opts.key) != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\n\t\t// Real redis only checks after it knows the key is there and a string.\n\t\tif len(args) != 0 {\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t\treturn\n\t\t}\n\n\t\tv := db.stringKeys[opts.key]\n\t\tif opts.useRange {\n\t\t\tv = withRange(v, opts.start, opts.end)\n\t\t}\n\n\t\tc.WriteInt(countBits([]byte(v)))\n\t})\n}\n\n// BITOP\nfunc (m *Miniredis) cmdBitop(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\top     string\n\t\ttarget string\n\t\tinput  []string\n\t}\n\topts.op = strings.ToUpper(args[0])\n\topts.target = args[1]\n\topts.input = args[2:]\n\n\t// 'op' is tested when the transaction is executed.\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tswitch opts.op {\n\t\tcase \"AND\", \"OR\", \"XOR\":\n\t\t\tfirst := opts.input[0]\n\t\t\tif t, ok := db.keys[first]; ok && t != \"string\" {\n\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tres := []byte(db.stringKeys[first])\n\t\t\tfor _, vk := range opts.input[1:] {\n\t\t\t\tif t, ok := db.keys[vk]; ok && t != \"string\" {\n\t\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tv := db.stringKeys[vk]\n\t\t\t\tcb := map[string]func(byte, byte) byte{\n\t\t\t\t\t\"AND\": func(a, b byte) byte { return a & b },\n\t\t\t\t\t\"OR\":  func(a, b byte) byte { return a | b },\n\t\t\t\t\t\"XOR\": func(a, b byte) byte { return a ^ b },\n\t\t\t\t}[opts.op]\n\t\t\t\tres = sliceBinOp(cb, res, []byte(v))\n\t\t\t}\n\t\t\tdb.del(opts.target, false) // Keep TTL\n\t\t\tif len(res) == 0 {\n\t\t\t\tdb.del(opts.target, true)\n\t\t\t} else {\n\t\t\t\tdb.stringSet(opts.target, string(res))\n\t\t\t}\n\t\t\tc.WriteInt(len(res))\n\t\tcase \"NOT\":\n\t\t\t// NOT only takes a single argument.\n\t\t\tif len(opts.input) != 1 {\n\t\t\t\tc.WriteError(\"ERR BITOP NOT must be called with a single source key.\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tkey := opts.input[0]\n\t\t\tif t, ok := db.keys[key]; ok && t != \"string\" {\n\t\t\t\tc.WriteError(msgWrongType)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvalue := []byte(db.stringKeys[key])\n\t\t\tfor i := range value {\n\t\t\t\tvalue[i] = ^value[i]\n\t\t\t}\n\t\t\tdb.del(opts.target, false) // Keep TTL\n\t\t\tif len(value) == 0 {\n\t\t\t\tdb.del(opts.target, true)\n\t\t\t} else {\n\t\t\t\tdb.stringSet(opts.target, string(value))\n\t\t\t}\n\t\t\tc.WriteInt(len(value))\n\t\tdefault:\n\t\t\tc.WriteError(msgSyntaxError)\n\t\t}\n\t})\n}\n\n// BITPOS\nfunc (m *Miniredis) cmdBitpos(c *server.Peer, cmd string, args []string) {\n\tif len(args) < 2 || len(args) > 4 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tKey     string\n\t\tBit     int\n\t\tStart   int\n\t\tEnd     int\n\t\tWithEnd bool\n\t}\n\n\topts.Key = args[0]\n\tif ok := optInt(c, args[1], &opts.Bit); !ok {\n\t\treturn\n\t}\n\tif len(args) > 2 {\n\t\tif ok := optInt(c, args[2], &opts.Start); !ok {\n\t\t\treturn\n\t\t}\n\t}\n\tif len(args) > 3 {\n\t\tif ok := optInt(c, args[3], &opts.End); !ok {\n\t\t\treturn\n\t\t}\n\t\topts.WithEnd = true\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.Key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t} else if !ok {\n\t\t\t// non-existing key behaves differently\n\t\t\tif opts.Bit == 0 {\n\t\t\t\tc.WriteInt(0)\n\t\t\t} else {\n\t\t\t\tc.WriteInt(-1)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\t\tvalue := db.stringKeys[opts.Key]\n\t\tstart := opts.Start\n\t\tend := opts.End\n\t\tif start < 0 {\n\t\t\tstart += len(value)\n\t\t\tif start < 0 {\n\t\t\t\tstart = 0\n\t\t\t}\n\t\t}\n\t\tif start > len(value) {\n\t\t\tstart = len(value)\n\t\t}\n\n\t\tif opts.WithEnd {\n\t\t\tif end < 0 {\n\t\t\t\tend += len(value)\n\t\t\t}\n\t\t\tif end < 0 {\n\t\t\t\tend = 0\n\t\t\t}\n\t\t\tend++ // +1 for redis end semantics\n\t\t\tif end > len(value) {\n\t\t\t\tend = len(value)\n\t\t\t}\n\t\t} else {\n\t\t\tend = len(value)\n\t\t}\n\n\t\tif start != 0 || opts.WithEnd {\n\t\t\tif end < start {\n\t\t\t\tvalue = \"\"\n\t\t\t} else {\n\t\t\t\tvalue = value[start:end]\n\t\t\t}\n\t\t}\n\t\tpos := bitPos([]byte(value), opts.Bit == 1)\n\t\tif pos >= 0 {\n\t\t\tpos += start * 8\n\t\t}\n\t\t// Special case when looking for 0, but not when start and end are\n\t\t// given.\n\t\tif opts.Bit == 0 && pos == -1 && !opts.WithEnd && len(value) > 0 {\n\t\t\tpos = start*8 + len(value)*8\n\t\t}\n\t\tc.WriteInt(pos)\n\t})\n}\n\n// GETBIT\nfunc (m *Miniredis) cmdGetbit(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 2 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey string\n\t\tbit int\n\t}\n\topts.key = args[0]\n\tif ok := optIntErr(c, args[1], &opts.bit, \"ERR bit offset is not an integer or out of range\"); !ok {\n\t\treturn\n\t}\n\tif opts.bit < 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR bit offset is not an integer or out of range\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tvalue := db.stringKeys[opts.key]\n\n\t\tourByteNr := opts.bit / 8\n\t\tvar ourByte byte\n\t\tif ourByteNr > len(value)-1 {\n\t\t\tourByte = '\\x00'\n\t\t} else {\n\t\t\tourByte = value[ourByteNr]\n\t\t}\n\t\tres := 0\n\t\tif toBits(ourByte)[opts.bit%8] {\n\t\t\tres = 1\n\t\t}\n\t\tc.WriteInt(res)\n\t})\n}\n\n// SETBIT\nfunc (m *Miniredis) cmdSetbit(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 3 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tvar opts struct {\n\t\tkey    string\n\t\tbit    int\n\t\tnewBit int\n\t}\n\topts.key = args[0]\n\tif ok := optIntErr(c, args[1], &opts.bit, \"ERR bit offset is not an integer or out of range\"); !ok {\n\t\treturn\n\t}\n\tif opts.bit < 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR bit offset is not an integer or out of range\")\n\t\treturn\n\t}\n\tif ok := optIntErr(c, args[2], &opts.newBit, \"ERR bit is not an integer or out of range\"); !ok {\n\t\treturn\n\t}\n\tif opts.newBit != 0 && opts.newBit != 1 {\n\t\tsetDirty(c)\n\t\tc.WriteError(\"ERR bit is not an integer or out of range\")\n\t\treturn\n\t}\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\tdb := m.db(ctx.selectedDB)\n\n\t\tif t, ok := db.keys[opts.key]; ok && t != \"string\" {\n\t\t\tc.WriteError(msgWrongType)\n\t\t\treturn\n\t\t}\n\t\tvalue := []byte(db.stringKeys[opts.key])\n\n\t\tourByteNr := opts.bit / 8\n\t\tourBitNr := opts.bit % 8\n\t\tif ourByteNr > len(value)-1 {\n\t\t\t// Too short. Expand.\n\t\t\tnewValue := make([]byte, ourByteNr+1)\n\t\t\tcopy(newValue, value)\n\t\t\tvalue = newValue\n\t\t}\n\t\told := 0\n\t\tif toBits(value[ourByteNr])[ourBitNr] {\n\t\t\told = 1\n\t\t}\n\t\tif opts.newBit == 0 {\n\t\t\tvalue[ourByteNr] &^= 1 << uint8(7-ourBitNr)\n\t\t} else {\n\t\t\tvalue[ourByteNr] |= 1 << uint8(7-ourBitNr)\n\t\t}\n\t\tdb.stringSet(opts.key, string(value))\n\n\t\tc.WriteInt(old)\n\t})\n}\n\n// Redis range. both start and end can be negative.\nfunc withRange(v string, start, end int) string {\n\ts, e := redisRange(len(v), start, end, true /* string getrange symantics */)\n\treturn v[s:e]\n}\n\nfunc countBits(v []byte) int {\n\tcount := 0\n\tfor _, b := range []byte(v) {\n\t\tfor b > 0 {\n\t\t\tcount += int((b % uint8(2)))\n\t\t\tb = b >> 1\n\t\t}\n\t}\n\treturn count\n}\n\n// sliceBinOp applies an operator to all slice elements, with Redis string\n// padding logic.\nfunc sliceBinOp(f func(a, b byte) byte, a, b []byte) []byte {\n\tmaxl := len(a)\n\tif len(b) > maxl {\n\t\tmaxl = len(b)\n\t}\n\tlA := make([]byte, maxl)\n\tcopy(lA, a)\n\tlB := make([]byte, maxl)\n\tcopy(lB, b)\n\tres := make([]byte, maxl)\n\tfor i := range res {\n\t\tres[i] = f(lA[i], lB[i])\n\t}\n\treturn res\n}\n\n// Return the number of the first bit set/unset.\nfunc bitPos(s []byte, bit bool) int {\n\tfor i, b := range s {\n\t\tfor j, set := range toBits(b) {\n\t\t\tif set == bit {\n\t\t\t\treturn i*8 + j\n\t\t\t}\n\t\t}\n\t}\n\treturn -1\n}\n\n// toBits changes a byte in 8 bools.\nfunc toBits(s byte) [8]bool {\n\tr := [8]bool{}\n\tfor i := range r {\n\t\tif s&(uint8(1)<<uint8(7-i)) != 0 {\n\t\t\tr[i] = true\n\t\t}\n\t}\n\treturn r\n}\n"
        },
        {
          "name": "cmd_string_test.go",
          "type": "blob",
          "size": 29.3408203125,
          "content": "package miniredis\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// Test simple GET/SET keys\nfunc TestString(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// SET command\n\tmustOK(t, c,\n\t\t\"SET\", \"foo\", \"bar\",\n\t)\n\n\t// GET command\n\tmustDo(t, c,\n\t\t\"GET\", \"foo\",\n\t\tproto.String(\"bar\"),\n\t)\n\n\t// Query server directly.\n\t{\n\t\tgot, err := s.Get(\"foo\")\n\t\tok(t, err)\n\t\tequals(t, \"bar\", got)\n\t}\n\n\t// Use Set directly\n\t{\n\t\tok(t, s.Set(\"aap\", \"noot\"))\n\t\ts.CheckGet(t, \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"GET\", \"aap\",\n\t\t\tproto.String(\"noot\"),\n\t\t)\n\t\ts.CheckGet(t, \"aap\", \"noot\")\n\t\t// Re-set.\n\t\tok(t, s.Set(\"aap\", \"noot2\"))\n\t}\n\n\t// non-existing key\n\tmustNil(t, c,\n\t\t\"GET\", \"reallynosuchkey\",\n\t)\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmust1(t, c,\n\t\t\t\"HSET\", \"wim\", \"zus\", \"jet\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GET\", \"wim\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n}\n\nfunc TestSet(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\t// Simple case\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"aap\", \"noot\",\n\t\t)\n\n\t\t// Overwrite other types.\n\t\ts.HSet(\"wim\", \"teun\", \"vuur\")\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"wim\", \"gijs\",\n\t\t)\n\t\ts.CheckGet(t, \"wim\", \"gijs\")\n\t})\n\n\tt.Run(\"NX\", func(t *testing.T) {\n\t\t// new key\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"mies\", \"toon\", \"NX\",\n\t\t)\n\t\t// now existing key\n\t\tmustNil(t, c,\n\t\t\t\"SET\", \"mies\", \"toon\", \"NX\",\n\t\t)\n\t\t// lowercase NX is no problem\n\t\tmustNil(t, c,\n\t\t\t\"SET\", \"mies\", \"toon\", \"nx\",\n\t\t)\n\t})\n\n\t// XX argument - only set if exists\n\tt.Run(\"XX\", func(t *testing.T) {\n\t\t// new key, no go\n\t\tmustNil(t, c,\n\t\t\t\"SET\", \"one\", \"two\", \"XX\",\n\t\t)\n\n\t\ts.Set(\"one\", \"three\")\n\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"one\", \"two\", \"XX\",\n\t\t)\n\t\ts.CheckGet(t, \"one\", \"two\")\n\n\t\t// XX with another key type\n\t\ts.HSet(\"eleven\", \"twelve\", \"thirteen\")\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"eleven\", \"fourteen\", \"XX\",\n\t\t)\n\t\ts.CheckGet(t, \"eleven\", \"fourteen\")\n\t})\n\n\tt.Run(\"EX PX\", func(t *testing.T) {\n\t\t// EX or PX argument. TTL values.\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"one\", \"two\", \"EX\", \"1299\",\n\t\t)\n\t\ts.CheckGet(t, \"one\", \"two\")\n\t\tequals(t, time.Second*1299, s.TTL(\"one\"))\n\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"three\", \"four\", \"PX\", \"8888\",\n\t\t)\n\t\ts.CheckGet(t, \"three\", \"four\")\n\t\tequals(t, time.Millisecond*8888, s.TTL(\"three\"))\n\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"one\", \"two\", \"EX\", \"notimestamp\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"one\", \"two\", \"EX\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"aap\", \"noot\", \"EX\", \"0\",\n\t\t\tproto.Error(\"ERR invalid expire time in set\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"aap\", \"noot\", \"EX\", \"-100\",\n\t\t\tproto.Error(\"ERR invalid expire time in set\"),\n\t\t)\n\t})\n\n\tt.Run(\"KEEPTTL\", func(t *testing.T) {\n\t\ts.Set(\"foo\", \"bar\")\n\t\ts.SetTTL(\"foo\", time.Second*1337)\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"foo\", \"baz\", \"KEEPTTL\",\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"baz\")\n\t\tequals(t, time.Second*1337, s.TTL(\"foo\"))\n\t})\n\n\tt.Run(\"GET\", func(t *testing.T) {\n\t\tmustNil(t, c,\n\t\t\t\"SET\", \"dino\", \"bar\", \"GET\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"dino\", \"bal\", \"GET\",\n\t\t\tproto.String(\"bar\"),\n\t\t)\n\t})\n\n\tt.Run(\"EXAT\", func(t *testing.T) {\n\t\ts.SetTime(time.Unix(1234567890, 0))\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"exat\", \"bar\", \"EXAT\", \"2345678901\",\n\t\t)\n\t\tequals(t, time.Second*1111111011, s.TTL(\"exat\"))\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"exat\", \"bal\", \"EXAT\", \"-1\",\n\t\t\tproto.Error(msgInvalidSETime),\n\t\t)\n\t})\n\n\tt.Run(\"PXAT\", func(t *testing.T) {\n\t\ts.SetTime(time.Unix(1234567890, 0))\n\t\tmustOK(t, c,\n\t\t\t\"SET\", \"pxat\", \"bar\", \"PXAT\", \"3345678901000\",\n\t\t)\n\t\tequals(t, time.Second*2111111011, s.TTL(\"pxat\"))\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"pxat\", \"bal\", \"PXAT\", \"-1\",\n\t\t\tproto.Error(msgInvalidSETime),\n\t\t)\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"SET\", \"one\", \"two\", \"FOO\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n}\n\nfunc TestMget(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Set(\"zus\", \"jet\")\n\ts.Set(\"teun\", \"vuur\")\n\ts.Set(\"gijs\", \"lam\")\n\ts.Set(\"kees\", \"bok\")\n\n\tmustDo(t, c,\n\t\t\"MGET\", \"zus\", \"nosuch\", \"kees\",\n\t\tproto.Array(proto.String(\"jet\"), proto.Nil, proto.String(\"bok\")),\n\t)\n\n\t// Wrong key type returns nil\n\t{\n\t\ts.HSet(\"aap\", \"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"MGET\", \"aap\",\n\t\t\tproto.Array(proto.Nil),\n\t\t)\n\t}\n}\n\nfunc TestMset(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"MSET\", \"zus\", \"jet\", \"teun\", \"vuur\", \"gijs\", \"lam\",\n\t\t)\n\t\ts.CheckGet(t, \"zus\", \"jet\")\n\t\ts.CheckGet(t, \"teun\", \"vuur\")\n\t\ts.CheckGet(t, \"gijs\", \"lam\")\n\t}\n\n\t// Other types are overwritten\n\t{\n\t\ts.HSet(\"aap\", \"foo\", \"bar\")\n\t\tmustOK(t, c,\n\t\t\t\"MSET\", \"aap\", \"jet\",\n\t\t)\n\t\ts.CheckGet(t, \"aap\", \"jet\")\n\t}\n\n\t// Odd argument list is not OK\n\tmustDo(t, c,\n\t\t\"MSET\", \"zus\", \"jet\", \"teun\",\n\t\tproto.Error(\"ERR wrong number of arguments for MSET\"),\n\t)\n\n\t// TTL is cleared\n\t{\n\t\ts.Set(\"foo\", \"bar\")\n\t\ts.HSet(\"aap\", \"foo\", \"bar\") // even for weird keys.\n\t\ts.SetTTL(\"aap\", time.Second*999)\n\t\ts.SetTTL(\"foo\", time.Second*999)\n\t\tmustOK(t, c,\n\t\t\t\"MSET\", \"aap\", \"noot\", \"foo\", \"baz\",\n\t\t)\n\t\tequals(t, time.Duration(0), s.TTL(\"aap\"))\n\t\tequals(t, time.Duration(0), s.TTL(\"foo\"))\n\t}\n}\n\nfunc TestSetex(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Usual case\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"SETEX\", \"aap\", \"1234\", \"noot\",\n\t\t)\n\t\ts.CheckGet(t, \"aap\", \"noot\")\n\t\tequals(t, time.Second*1234, s.TTL(\"aap\"))\n\t}\n\n\t// Same thing\n\tmustOK(t, c,\n\t\t\"SETEX\", \"aap\", \"1234\", \"noot\",\n\t)\n\n\t// Error cases\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SETEX\", \"aap\", \"nottl\", \"noot\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETEX\", \"aap\",\n\t\t\tproto.Error(errWrongNumber(\"setex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETEX\", \"aap\", \"12\",\n\t\t\tproto.Error(errWrongNumber(\"setex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETEX\", \"aap\", \"12\", \"noot\", \"toomuch\",\n\t\t\tproto.Error(errWrongNumber(\"setex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETEX\", \"aap\", \"0\", \"noot\",\n\t\t\tproto.Error(\"ERR invalid expire time in setex\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETEX\", \"aap\", \"-10\", \"noot\",\n\t\t\tproto.Error(\"ERR invalid expire time in setex\"),\n\t\t)\n\t}\n}\n\nfunc TestPsetex(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Usual case\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"PSETEX\", \"aap\", \"1234\", \"noot\",\n\t\t)\n\t\ts.CheckGet(t, \"aap\", \"noot\")\n\t\tequals(t, time.Millisecond*1234, s.TTL(\"aap\"))\n\t}\n\n\t// Same thing\n\tmustOK(t, c,\n\t\t\"PSETEX\", \"aap\", \"1234\", \"noot\",\n\t)\n\n\t// Error cases\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"PSETEX\", \"aap\", \"nottl\", \"noot\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PSETEX\", \"aap\",\n\t\t\tproto.Error(errWrongNumber(\"psetex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PSETEX\", \"aap\", \"12\",\n\t\t\tproto.Error(errWrongNumber(\"psetex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PSETEX\", \"aap\", \"12\", \"noot\", \"toomuch\",\n\t\t\tproto.Error(errWrongNumber(\"psetex\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PSETEX\", \"aap\", \"0\", \"noot\",\n\t\t\tproto.Error(\"ERR invalid expire time in psetex\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"PSETEX\", \"aap\", \"-10\", \"noot\",\n\t\t\tproto.Error(\"ERR invalid expire time in psetex\"),\n\t\t)\n\t}\n}\n\nfunc TestSetnx(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"bar\")\n\t\tmust0(t, c,\n\t\t\t\"SETNX\", \"foo\", \"not bar\",\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"bar\")\n\t}\n\n\t// New key\n\t{\n\t\tmust1(t, c,\n\t\t\t\"SETNX\", \"notfoo\", \"also not bar\",\n\t\t)\n\t\ts.CheckGet(t, \"notfoo\", \"also not bar\")\n\t}\n\n\t// Existing key of a different type\n\t{\n\t\ts.HSet(\"foo\", \"bar\", \"baz\")\n\t\tmust0(t, c,\n\t\t\t\"SETNX\", \"foo\", \"not bar\",\n\t\t)\n\t\tequals(t, \"hash\", s.Type(\"foo\"))\n\t\t_, err := s.Get(\"foo\")\n\t\tequals(t, ErrWrongType, err)\n\t\tequals(t, \"baz\", s.HGet(\"foo\", \"bar\"))\n\t}\n}\n\nfunc TestIncr(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"INCR\", \"foo\",\n\t\t\tproto.Int(13),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"13\")\n\t}\n\n\t// Existing key, not an integer\n\t{\n\t\ts.Set(\"foo\", \"noint\")\n\t\tmustDo(t, c,\n\t\t\t\"INCR\", \"foo\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmust1(t, c,\n\t\t\t\"INCR\", \"bar\",\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"1\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"INCR\", \"wrong\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Direct usage\n\t{\n\t\ti, err := s.Incr(\"count\", 1)\n\t\tok(t, err)\n\t\tequals(t, 1, i)\n\t\ti, err = s.Incr(\"count\", 1)\n\t\tok(t, err)\n\t\tequals(t, 2, i)\n\t\t_, err = s.Incr(\"wrong\", 1)\n\t\tassert(t, err != nil, \"do s.Incr error\")\n\t}\n\n\t// Overflow\n\t{\n\t\ts.Set(\"overflow\", \"9223372036854775807\")\n\t\tmustDo(t, c,\n\t\t\t\"INCR\", \"overflow\",\n\t\t\tproto.Error(msgIntOverflow),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"INCR\",\n\t\t\tproto.Error(errWrongNumber(\"incr\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"INCR\", \"new\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"incr\")),\n\t\t)\n\t}\n}\n\nfunc TestIncrBy(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"foo\", \"400\",\n\t\t\tproto.Int(412),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"412\")\n\t}\n\n\t// Existing key, not an integer\n\t{\n\t\ts.Set(\"foo\", \"noint\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"foo\", \"400\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"bar\", \"4000\",\n\t\t\tproto.Int(4000),\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"4000\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"wrong\", \"400\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Amount not an integer\n\tmustDo(t, c,\n\t\t\"INCRBY\", \"key\", \"noint\",\n\t\tproto.Error(msgInvalidInt),\n\t)\n\n\t// Overflow\n\t{\n\t\ts.Set(\"overflow\", \"10\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"overflow\", \"9223372036854775807\",\n\t\t\tproto.Error(msgIntOverflow),\n\t\t)\n\t\ts.Set(\"overflow\", \"-10\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"overflow\", \"-9223372036854775807\",\n\t\t\tproto.Error(msgIntOverflow),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\",\n\t\t\tproto.Error(errWrongNumber(\"incrby\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"INCRBY\", \"another\", \"new\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"incrby\")),\n\t\t)\n\t}\n}\n\nfunc TestIncrbyfloat(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBYFLOAT\", \"foo\", \"400.12\",\n\t\t\tproto.String(\"412.12\"),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"412.12\")\n\t}\n\n\t// Existing key, not a number\n\t{\n\t\ts.Set(\"foo\", \"noint\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBYFLOAT\", \"foo\", \"400\",\n\t\t\tproto.Error(msgInvalidFloat),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"INCRBYFLOAT\", \"bar\", \"40.33\",\n\t\t\tproto.String(\"40.33\"),\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"40.33\")\n\t}\n\n\t// Direct usage\n\t{\n\t\ts.Set(\"foo\", \"500.1\")\n\t\tf, err := s.Incrfloat(\"foo\", 12)\n\t\tok(t, err)\n\t\tequals(t, 512.1, f)\n\t\ts.CheckGet(t, \"foo\", \"512.1\")\n\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\t_, err = s.Incrfloat(\"wrong\", 12)\n\t\tassert(t, err != nil, \"do s.Incrfloat() error\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"INCRBYFLOAT\", \"wrong\", \"400\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Amount not a number\n\tmustDo(t, c,\n\t\t\"INCRBYFLOAT\", \"key\", \"noint\",\n\t\tproto.Error(msgInvalidFloat),\n\t)\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"INCRBYFLOAT\",\n\t\t\tproto.Error(errWrongNumber(\"incrbyfloat\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"INCRBYFLOAT\", \"another\", \"new\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"incrbyfloat\")),\n\t\t)\n\t}\n}\n\nfunc TestDecrBy(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"foo\", \"400\",\n\t\t\tproto.Int(-388),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"-388\")\n\t}\n\n\t// Existing key, not an integer\n\t{\n\t\ts.Set(\"foo\", \"noint\")\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"foo\", \"400\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"bar\", \"4000\",\n\t\t\tproto.Int(-4000),\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"-4000\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"wrong\", \"400\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Amount not an integer\n\tmustDo(t, c,\n\t\t\"DECRBY\", \"key\", \"noint\",\n\t\tproto.Error(msgInvalidInt),\n\t)\n\n\t// Overflow\n\t{\n\t\ts.Set(\"overflow\", \"10\")\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"overflow\", \"-9223372036854775807\",\n\t\t\tproto.Error(msgIntOverflow),\n\t\t)\n\t\ts.Set(\"overflow\", \"-10\")\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"overflow\", \"9223372036854775807\",\n\t\t\tproto.Error(msgIntOverflow),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\",\n\t\t\tproto.Error(errWrongNumber(\"decrby\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"DECRBY\", \"another\", \"new\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"decrby\")),\n\t\t)\n\t}\n}\n\nfunc TestDecr(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"12\")\n\t\tmustDo(t, c,\n\t\t\t\"DECR\", \"foo\",\n\t\t\tproto.Int(11),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"11\")\n\t}\n\n\t// Existing key, not an integer\n\t{\n\t\ts.Set(\"foo\", \"noint\")\n\t\tmustDo(t, c,\n\t\t\t\"DECR\", \"foo\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"DECR\", \"bar\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"-1\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"DECR\", \"wrong\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"DECR\",\n\t\t\tproto.Error(errWrongNumber(\"decr\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"DECR\", \"new\", \"key\",\n\t\t\tproto.Error(errWrongNumber(\"decr\")),\n\t\t)\n\t}\n\n\t// Overflow\n\t{\n\t\ts.Set(\"overflow\", \"-9223372036854775808\")\n\t\tmustDo(t, c,\n\t\t\t\"DECR\", \"overflow\",\n\t\t\tproto.Error(msgIntOverflow),\n\t\t)\n\t}\n\n\t// Direct one works\n\t{\n\t\ts.Set(\"aap\", \"400\")\n\t\ts.Incr(\"aap\", +42)\n\t\ts.CheckGet(t, \"aap\", \"442\")\n\t}\n}\n\nfunc TestGetex(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\t// Missing key\n\t\tmustNil(t, c, \"GETEX\", \"basic\")\n\n\t\t// Existing key\n\t\ts.Set(\"basic\", \"bar\")\n\t\tmustDo(t, c, \"GETEX\", \"basic\", proto.String(\"bar\"))\n\t\tequals(t, time.Duration(0), s.TTL(\"basic\"))\n\t})\n\n\tt.Run(\"EX\", func(t *testing.T) {\n\t\t// Missing key\n\t\tmustNil(t, c, \"GETEX\", \"withex\", \"EX\", \"123\")\n\n\t\t// Existing key\n\t\ts.Set(\"withex\", \"bar\")\n\t\tmustDo(t, c, \"GETEX\", \"withex\", \"EX\", \"123\", proto.String(\"bar\"))\n\t\tequals(t, 123*time.Second, s.TTL(\"withex\"))\n\t})\n\n\tt.Run(\"PX\", func(t *testing.T) {\n\t\t// Missing key\n\t\tmustNil(t, c, \"GETEX\", \"withpx\", \"PX\", \"123\")\n\n\t\t// Existing key\n\t\ts.Set(\"withpx\", \"bar\")\n\t\tmustDo(t, c, \"GETEX\", \"withpx\", \"PX\", \"123\", proto.String(\"bar\"))\n\t\tequals(t, 123*time.Millisecond, s.TTL(\"withpx\"))\n\t})\n\n\tt.Run(\"EXAT\", func(t *testing.T) {\n\t\ts.SetTime(time.Unix(100, 0))\n\n\t\t// Missing key\n\t\tmustNil(t, c, \"GETEX\", \"withexat\", \"EXAT\", \"123\")\n\n\t\t// Existing key\n\t\ts.Set(\"withexat\", \"bar\")\n\t\tmustDo(t, c, \"GETEX\", \"withexat\", \"EXAT\", \"123\", proto.String(\"bar\"))\n\t\tequals(t, 23*time.Second, s.TTL(\"withexat\"))\n\t})\n\n\tt.Run(\"PXAT\", func(t *testing.T) {\n\t\ts.SetTime(time.Unix(0, 100_000_000))\n\n\t\t// Missing key\n\t\tmustNil(t, c, \"GETEX\", \"withpxat\", \"PXAT\", \"123\")\n\n\t\t// Existing key\n\t\ts.Set(\"withpxat\", \"bar\")\n\t\tmustDo(t, c, \"GETEX\", \"withpxat\", \"PXAT\", \"123\", proto.String(\"bar\"))\n\t\tequals(t, 23*time.Millisecond, s.TTL(\"withpxat\"))\n\t})\n\n\tt.Run(\"PERSIST\", func(t *testing.T) {\n\t\t// Missing key\n\t\tmustNil(t, c, \"GETEX\", \"foo\", \"PERSIST\")\n\n\t\t// Existing key with TTL\n\t\tmustOK(t, c, \"SETEX\", \"foo\", \"123\", \"bar\")\n\t\tmustDo(t, c, \"GETEX\", \"foo\", \"PERSIST\", proto.String(\"bar\"))\n\t\tequals(t, time.Duration(0), s.TTL(\"foo\"))\n\t})\n\n\tt.Run(\"errors\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"GETEX\", \"one\", \"two\",\n\t\t\tproto.Error(msgSyntaxError),\n\t\t)\n\t})\n}\n\nfunc TestGetSet(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"GETSET\", \"foo\", \"baz\",\n\t\t\tproto.String(\"bar\"),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"baz\")\n\t}\n\n\t// New key\n\t{\n\t\tmustNil(t, c,\n\t\t\t\"GETSET\", \"bar\", \"bak\",\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"bak\")\n\t}\n\n\t// TTL needs to be cleared\n\t{\n\t\ts.Set(\"one\", \"two\")\n\t\ts.SetTTL(\"one\", time.Second*1234)\n\t\tmustDo(t, c,\n\t\t\t\"GETSET\", \"one\", \"three\",\n\t\t\tproto.String(\"two\"),\n\t\t)\n\t\ts.CheckGet(t, \"bar\", \"bak\")\n\t\tequals(t, time.Duration(0), s.TTL(\"one\"))\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"GETSET\", \"wrong\", \"key\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"GETSET\",\n\t\t\tproto.Error(errWrongNumber(\"getset\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETSET\", \"spurious\", \"arguments\", \"here\",\n\t\t\tproto.Error(errWrongNumber(\"getset\")),\n\t\t)\n\t}\n}\n\nfunc TestGetdel(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Missing key\n\t{\n\t\tmustNil(t, c, \"GETDEL\", \"foo\")\n\t}\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"GETDEL\", \"foo\",\n\t\t\tproto.String(\"bar\"),\n\t\t)\n\t\tmust0(t, c, \"EXISTS\", \"foo\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"foo\", \"bar\")\n\t\tmustDo(t, c,\n\t\t\t\"GETDEL\", \"wrong\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"GETDEL\",\n\t\t\tproto.Error(errWrongNumber(\"getdel\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETDEL\", \"foo\", \"bar\",\n\t\t\tproto.Error(errWrongNumber(\"getdel\")),\n\t\t)\n\t}\n}\n\nfunc TestStrlen(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"bar!\")\n\t\tmustDo(t, c,\n\t\t\t\"STRLEN\", \"foo\",\n\t\t\tproto.Int(4),\n\t\t)\n\t}\n\n\t// New key\n\t{\n\t\tmust0(t, c,\n\t\t\t\"STRLEN\", \"nosuch\",\n\t\t)\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"STRLEN\", \"wrong\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"STRLEN\",\n\t\t\tproto.Error(errWrongNumber(\"strlen\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"STRLEN\", \"spurious\", \"arguments\",\n\t\t\tproto.Error(errWrongNumber(\"strlen\")),\n\t\t)\n\t}\n}\n\nfunc TestAppend(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Existing key\n\t{\n\t\ts.Set(\"foo\", \"bar!\")\n\t\tmustDo(t, c,\n\t\t\t\"APPEND\", \"foo\", \"morebar\",\n\t\t\tproto.Int(11),\n\t\t)\n\t}\n\n\t// New key\n\tmustDo(t, c,\n\t\t\"APPEND\", \"bar\", \"was empty\",\n\t\tproto.Int(9),\n\t)\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"APPEND\", \"wrong\", \"type\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"APPEND\",\n\t\t\tproto.Error(errWrongNumber(\"append\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"APPEND\", \"missing\",\n\t\t\tproto.Error(errWrongNumber(\"append\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"APPEND\", \"spurious\", \"arguments\", \"!\",\n\t\t\tproto.Error(errWrongNumber(\"append\")),\n\t\t)\n\t}\n}\n\nfunc TestGetrange(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\ts.Set(\"foo\", \"abcdefg\")\n\t\ttest := func(s, e int, res string) {\n\t\t\tt.Helper()\n\t\t\tmustDo(t, c,\n\t\t\t\t\"GETRANGE\", \"foo\", strconv.Itoa(s), strconv.Itoa(e),\n\t\t\t\tproto.String(res),\n\t\t\t)\n\t\t}\n\t\ttest(0, 0, \"a\")\n\t\ttest(0, 3, \"abcd\")\n\t\ttest(0, 7, \"abcdefg\")\n\t\ttest(0, 100, \"abcdefg\")\n\t\ttest(1, 2, \"bc\")\n\t\ttest(1, 100, \"bcdefg\")\n\t\ttest(-4, -2, \"def\")\n\t\ttest(0, -1, \"abcdefg\")\n\t\ttest(0, -2, \"abcdef\")\n\t\ttest(0, -100, \"a\") // Redis is funny\n\t\ttest(-2, 2, \"\")\n\t}\n\n\t// New key\n\tmustDo(t, c,\n\t\t\"GETRANGE\", \"bar\", \"0\", \"4\",\n\t\tproto.String(\"\"),\n\t)\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"GETRANGE\", \"wrong\", \"0\", \"0\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"GETRANGE\",\n\t\t\tproto.Error(errWrongNumber(\"getrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETRANGE\", \"missing\",\n\t\t\tproto.Error(errWrongNumber(\"getrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETRANGE\", \"many\", \"spurious\", \"arguments\", \"!\",\n\t\t\tproto.Error(errWrongNumber(\"getrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETRANGE\", \"many\", \"noint\", \"12\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETRANGE\", \"many\", \"12\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t}\n}\n\nfunc TestSetrange(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t// Simple case\n\t{\n\t\ts.Set(\"foo\", \"abcdefg\")\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"foo\", \"1\", \"bar\",\n\t\t\tproto.Int(7),\n\t\t)\n\t\ts.CheckGet(t, \"foo\", \"abarefg\")\n\t}\n\t// Non existing key\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"nosuch\", \"3\", \"bar\",\n\t\t\tproto.Int(6),\n\t\t)\n\t\ts.CheckGet(t, \"nosuch\", \"\\x00\\x00\\x00bar\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"wrong\", \"0\", \"aap\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\",\n\t\t\tproto.Error(errWrongNumber(\"setrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"missing\",\n\t\t\tproto.Error(errWrongNumber(\"setrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"missing\", \"1\",\n\t\t\tproto.Error(errWrongNumber(\"setrange\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"key\", \"noint\", \"\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"key\", \"-1\", \"\",\n\t\t\tproto.Error(\"ERR offset is out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETRANGE\", \"many\", \"12\", \"keys\", \"here\",\n\t\t\tproto.Error(errWrongNumber(\"setrange\")),\n\t\t)\n\t}\n}\n\nfunc TestBitcount(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\ts.Set(\"countme\", \"a\") // 'a' is 0x1100001\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\", \"countme\",\n\t\t\tproto.Int(3),\n\t\t)\n\n\t\ts.Set(\"countme\", \"aaaaa\") // 'a' is 0x1100001\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\", \"countme\",\n\t\t\tproto.Int(3*5),\n\t\t)\n\t}\n\t// Non-existing\n\tmust0(t, c,\n\t\t\"BITCOUNT\", \"nosuch\",\n\t)\n\n\t{\n\t\t// a: 0x1100001 - 3\n\t\t// b: 0x1100010 - 3\n\t\t// c: 0x1100011 - 4\n\t\t// d: 0x1100100 - 3\n\t\ts.Set(\"foo\", \"abcd\")\n\t\ttest := func(s, e, res int) {\n\t\t\tt.Helper()\n\t\t\tmustDo(t, c,\n\t\t\t\t\"BITCOUNT\", \"foo\", strconv.Itoa(s), strconv.Itoa(e),\n\t\t\t\tproto.Int(res),\n\t\t\t)\n\t\t}\n\t\ttest(0, 0, 3)  // \"a\"\n\t\ttest(0, 3, 13) // \"abcd\"\n\t\ttest(2, -2, 4) // \"c\"\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\", \"wrong\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\",\n\t\t\tproto.Error(errWrongNumber(\"bitcount\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\", \"many\", \"spurious\", \"arguments\", \"!\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\", \"many\", \"noint\", \"12\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITCOUNT\", \"many\", \"12\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t}\n}\n\nfunc TestBitop(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tand := func(a, b byte) byte { return a & b }\n\t\tequals(t, []byte(\"`\"), sliceBinOp(and, []byte(\"a\"), []byte(\"b\")))\n\t\tequals(t, []byte(\"`\\000\\000\"), sliceBinOp(and, []byte(\"aaa\"), []byte(\"b\")))\n\t\tequals(t, []byte(\"`\\000\\000\"), sliceBinOp(and, []byte(\"a\"), []byte(\"bbb\")))\n\t\tequals(t, []byte(\"``\\000\"), sliceBinOp(and, []byte(\"aa\"), []byte(\"bbb\")))\n\t}\n\n\t// Single char AND\n\t{\n\t\ts.Set(\"a\", \"a\") // 'a' is 0x1100001\n\t\ts.Set(\"b\", \"b\") // 'b' is 0x1100010\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"AND\", \"bitand\", \"a\", \"b\",\n\t\t\tproto.Int(1), // Length of the longest key\n\t\t)\n\t\ts.CheckGet(t, \"bitand\", \"`\")\n\t}\n\t// Multi char AND\n\t{\n\t\ts.Set(\"a\", \"aa\")   // 'a' is 0x1100001\n\t\ts.Set(\"b\", \"bbbb\") // 'b' is 0x1100010\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"AND\", \"bitand\", \"a\", \"b\",\n\t\t\tproto.Int(4), // Length of the longest key\n\t\t)\n\t\ts.CheckGet(t, \"bitand\", \"``\\000\\000\")\n\t}\n\n\t// Multi char OR\n\t{\n\t\ts.Set(\"a\", \"aa\")   // 'a' is 0x1100001\n\t\ts.Set(\"b\", \"bbbb\") // 'b' is 0x1100010\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"OR\", \"bitor\", \"a\", \"b\",\n\t\t\tproto.Int(4),\n\t\t)\n\t\ts.CheckGet(t, \"bitor\", \"ccbb\")\n\t}\n\n\t// Multi char XOR\n\t{\n\t\ts.Set(\"a\", \"aa\")   // 'a' is 0x1100001\n\t\ts.Set(\"b\", \"bbbb\") // 'b' is 0x1100010\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"XOR\", \"bitxor\", \"a\", \"b\",\n\t\t\tproto.Int(4),\n\t\t)\n\t\ts.CheckGet(t, \"bitxor\", \"\\x03\\x03bb\")\n\t}\n\n\t// Guess who's NOT like the other ops?\n\t{\n\t\ts.Set(\"a\", \"aa\") // 'a' is 0x1100001\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"NOT\", \"not\", \"a\",\n\t\t\tproto.Int(2),\n\t\t)\n\t\ts.CheckGet(t, \"not\", \"\\x9e\\x9e\")\n\t}\n\n\t// Single argument. Works, just an roundabout copy.\n\t{\n\t\ts.Set(\"a\", \"a\") // 'a' is 0x1100001\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"AND\", \"copy\", \"a\",\n\t\t\tproto.Int(1),\n\t\t)\n\t\ts.CheckGet(t, \"copy\", \"a\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"AND\", \"wrong\",\n\t\t\tproto.Error(errWrongNumber(\"bitop\")),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\",\n\t\t\tproto.Error(errWrongNumber(\"bitop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"AND\",\n\t\t\tproto.Error(errWrongNumber(\"bitop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"WHAT\",\n\t\t\tproto.Error(errWrongNumber(\"bitop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"NOT\",\n\t\t\tproto.Error(errWrongNumber(\"bitop\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITOP\", \"NOT\", \"foo\", \"bar\", \"baz\",\n\t\t\tproto.Error(\"ERR BITOP NOT must be called with a single source key.\"),\n\t\t)\n\t}\n}\n\nfunc TestBitpos(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tt.Run(\"basic\", func(t *testing.T) {\n\t\ts.Set(\"findme\", \"\\xff\\xf0\\x00\")\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"0\",\n\t\t\tproto.Int(12),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"0\", \"1\",\n\t\t\tproto.Int(12),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"0\", \"1\", \"1\",\n\t\t\tproto.Int(12),\n\t\t)\n\n\t\tmust0(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"1\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"1\", \"1\",\n\t\t\tproto.Int(8),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"1\", \"1\", \"2\",\n\t\t\tproto.Int(8),\n\t\t)\n\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"findme\", \"1\", \"10000\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t})\n\n\tt.Run(\"substrings\", func(t *testing.T) {\n\t\ts.Set(\"bin\", string([]rune{rune(0b0000_0000), rune(0b0010_0000), rune(0b0001_0000)}))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\",\n\t\t\tproto.Int(10))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"1\",\n\t\t\tproto.Int(10))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"1\", \"2\",\n\t\t\tproto.Int(10))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"2\", \"2\",\n\t\t\tproto.Int(19))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"0\", \"0\",\n\t\t\tproto.Int(-1))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"0\", \"-1\",\n\t\t\tproto.Int(10))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"0\", \"-2\",\n\t\t\tproto.Int(10))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"0\", \"-3\",\n\t\t\tproto.Int(-1))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"0\", \"0\", \"-999\",\n\t\t\tproto.Int(0))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"-1\",\n\t\t\tproto.Int(19))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"-1\", \"-1\",\n\t\t\tproto.Int(19))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"-1\", \"2\",\n\t\t\tproto.Int(19))\n\t\tmustDo(t, c, \"BITPOS\", \"bin\", \"1\", \"-2\",\n\t\t\tproto.Int(10))\n\t})\n\n\tt.Run(\"only zeros\", func(t *testing.T) {\n\t\ts.Set(\"zero\", \"\\x00\\x00\")\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"zero\", \"1\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmust0(t, c,\n\t\t\t\"BITPOS\", \"zero\", \"0\",\n\t\t)\n\n\t\t// -end is ok\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"zero\", \"0\", \"0\", \"-100\",\n\t\t\tproto.Int(0),\n\t\t)\n\t})\n\n\tt.Run(\"only ones\", func(t *testing.T) {\n\t\ts.Set(\"one\", \"\\xff\\xff\")\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"one\", \"1\",\n\t\t\tproto.Int(0),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"one\", \"1\", \"1\",\n\t\t\tproto.Int(8),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"one\", \"1\", \"2\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"one\", \"0\",\n\t\t\tproto.Int(16), // Special case\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"one\", \"0\", \"1\",\n\t\t\tproto.Int(16), // Special case\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"one\", \"0\", \"0\", \"1\",\n\t\t\tproto.Int(-1), // Counter the special case\n\t\t)\n\t})\n\n\tt.Run(\"non-existing\", func(t *testing.T) {\n\t\tmustDo(t, c, \"BITPOS\", \"nosuch\", \"1\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c, \"BITPOS\", \"nosuch\", \"1\", \"0\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c, \"BITPOS\", \"nosuch\", \"0\",\n\t\t\tproto.Int(0),\n\t\t)\n\t\tmustDo(t, c, \"BITPOS\", \"nosuch\", \"0\", \"0\",\n\t\t\tproto.Int(0),\n\t\t)\n\t})\n\n\tt.Run(\"empty string\", func(t *testing.T) {\n\t\ts.Set(\"empty\", \"\")\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"empty\", \"1\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"empty\", \"0\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"empty\", \"0\", \"0\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"empty\", \"0\", \"0\", \"0\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"empty\", \"0\", \"0\", \"-1\",\n\t\t\tproto.Int(-1),\n\t\t)\n\t})\n\n\tt.Run(\"wrong type\", func(t *testing.T) {\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"wrong\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t})\n\n\tt.Run(\"wrong usage\", func(t *testing.T) {\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\",\n\t\t\tproto.Error(errWrongNumber(\"bitpos\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"many\", \"noint\",\n\t\t\tproto.Error(msgInvalidInt),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"BITPOS\", \"many\",\n\t\t\tproto.Error(errWrongNumber(\"bitpos\")),\n\t\t)\n\t})\n}\n\nfunc TestGetbit(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\ts.Set(\"findme\", \"\\x08\")\n\t\tmust0(t, c,\n\t\t\t\"GETBIT\", \"findme\", \"0\",\n\t\t)\n\t\tmust1(t, c,\n\t\t\t\"GETBIT\", \"findme\", \"4\",\n\t\t)\n\t\tmust0(t, c,\n\t\t\t\"GETBIT\", \"findme\", \"5\",\n\t\t)\n\t}\n\n\t// Non-existing\n\t{\n\t\tmust0(t, c,\n\t\t\t\"GETBIT\", \"nosuch\", \"1\",\n\t\t)\n\t\tmust0(t, c,\n\t\t\t\"GETBIT\", \"nosuch\", \"1000\",\n\t\t)\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"GETBIT\", \"wrong\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"GETBIT\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"getbit\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETBIT\", \"spurious\", \"arguments\", \"!\",\n\t\t\tproto.Error(errWrongNumber(\"getbit\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"GETBIT\", \"many\", \"noint\",\n\t\t\tproto.Error(\"ERR bit offset is not an integer or out of range\"),\n\t\t)\n\t}\n}\n\nfunc TestSetbit(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\ts.Set(\"findme\", \"\\x08\")\n\t\tmust1(t, c,\n\t\t\t\"SETBIT\", \"findme\", \"4\", \"0\",\n\t\t)\n\t\ts.CheckGet(t, \"findme\", \"\\x00\")\n\n\t\tmust0(t, c,\n\t\t\t\"SETBIT\", \"findme\", \"4\", \"1\",\n\t\t)\n\t\ts.CheckGet(t, \"findme\", \"\\x08\")\n\t}\n\n\t// Non-existing\n\t{\n\t\tmust0(t, c,\n\t\t\t\"SETBIT\", \"nosuch\", \"0\", \"1\",\n\t\t)\n\t\ts.CheckGet(t, \"nosuch\", \"\\x80\")\n\t}\n\n\t// Too short\n\t{\n\t\ts.Set(\"short\", \"\\x00\\x00\")\n\t\tmust0(t, c,\n\t\t\t\"SETBIT\", \"short\", \"24\", \"0\",\n\t\t)\n\t\ts.CheckGet(t, \"short\", \"\\x00\\x00\\x00\\x00\")\n\t\tmust0(t, c,\n\t\t\t\"SETBIT\", \"short\", \"32\", \"1\",\n\t\t)\n\t\ts.CheckGet(t, \"short\", \"\\x00\\x00\\x00\\x00\\x80\")\n\t}\n\n\t// Wrong type of existing key\n\t{\n\t\ts.HSet(\"wrong\", \"aap\", \"noot\")\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"wrong\", \"0\", \"1\",\n\t\t\tproto.Error(msgWrongType),\n\t\t)\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"setbit\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"spurious\", \"arguments\", \"!\",\n\t\t\tproto.Error(\"ERR bit offset is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"many\", \"noint\", \"1\",\n\t\t\tproto.Error(\"ERR bit offset is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"many\", \"1\", \"noint\",\n\t\t\tproto.Error(\"ERR bit is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"many\", \"-3\", \"0\",\n\t\t\tproto.Error(\"ERR bit offset is not an integer or out of range\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"SETBIT\", \"many\", \"3\", \"2\",\n\t\t\tproto.Error(\"ERR bit is not an integer or out of range\"),\n\t\t)\n\t}\n}\n\nfunc TestMsetnx(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\t{\n\t\tmust1(t, c,\n\t\t\t\"MSETNX\", \"aap\", \"noot\", \"mies\", \"vuur\",\n\t\t)\n\t\ts.CheckGet(t, \"aap\", \"noot\")\n\t\ts.CheckGet(t, \"mies\", \"vuur\")\n\t}\n\n\t// A key exists.\n\t{\n\t\tmust0(t, c,\n\t\t\t\"MSETNX\", \"noaap\", \"noot\", \"mies\", \"vuur!\",\n\t\t)\n\t\tequals(t, false, s.Exists(\"noaap\"))\n\t\ts.CheckGet(t, \"aap\", \"noot\")\n\t\ts.CheckGet(t, \"mies\", \"vuur\")\n\t}\n\n\t// Other type of existing key\n\t{\n\t\ts.HSet(\"one\", \"two\", \"three\")\n\t\tmust0(t, c,\n\t\t\t\"MSETNX\", \"one\", \"two\", \"three\", \"four!\",\n\t\t)\n\t\tequals(t, false, s.Exists(\"three\"))\n\t}\n\n\t// Wrong usage\n\t{\n\t\tmustDo(t, c,\n\t\t\t\"MSETNX\", \"foo\",\n\t\t\tproto.Error(errWrongNumber(\"msetnx\")),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"MSETNX\", \"odd\", \"arguments\", \"!\",\n\t\t\tproto.Error(\"ERR wrong number of arguments for MSET\"),\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"MSETNX\",\n\t\t\tproto.Error(errWrongNumber(\"msetnx\")),\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "cmd_transactions.go",
          "type": "blob",
          "size": 3.08203125,
          "content": "// Commands from https://redis.io/commands#transactions\n\npackage miniredis\n\nimport (\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// commandsTransaction handles MULTI &c.\nfunc commandsTransaction(m *Miniredis) {\n\tm.srv.Register(\"DISCARD\", m.cmdDiscard)\n\tm.srv.Register(\"EXEC\", m.cmdExec)\n\tm.srv.Register(\"MULTI\", m.cmdMulti)\n\tm.srv.Register(\"UNWATCH\", m.cmdUnwatch)\n\tm.srv.Register(\"WATCH\", m.cmdWatch)\n}\n\n// MULTI\nfunc (m *Miniredis) cmdMulti(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 0 {\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\tif inTx(ctx) {\n\t\tc.WriteError(\"ERR MULTI calls can not be nested\")\n\t\treturn\n\t}\n\n\tstartTx(ctx)\n\n\tc.WriteOK()\n}\n\n// EXEC\nfunc (m *Miniredis) cmdExec(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\tif !inTx(ctx) {\n\t\tc.WriteError(\"ERR EXEC without MULTI\")\n\t\treturn\n\t}\n\n\tif ctx.dirtyTransaction {\n\t\tc.WriteError(\"EXECABORT Transaction discarded because of previous errors.\")\n\t\t// a failed EXEC finishes the tx\n\t\tstopTx(ctx)\n\t\treturn\n\t}\n\n\tm.Lock()\n\tdefer m.Unlock()\n\n\t// Check WATCHed keys.\n\tfor t, version := range ctx.watch {\n\t\tif m.db(t.db).keyVersion[t.key] > version {\n\t\t\t// Abort! Abort!\n\t\t\tstopTx(ctx)\n\t\t\tc.WriteLen(-1)\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.WriteLen(len(ctx.transaction))\n\tfor _, cb := range ctx.transaction {\n\t\tcb(c, ctx)\n\t}\n\t// wake up anyone who waits on anything.\n\tm.signal.Broadcast()\n\n\tstopTx(ctx)\n}\n\n// DISCARD\nfunc (m *Miniredis) cmdDiscard(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tctx := getCtx(c)\n\tif !inTx(ctx) {\n\t\tc.WriteError(\"ERR DISCARD without MULTI\")\n\t\treturn\n\t}\n\n\tstopTx(ctx)\n\tc.WriteOK()\n}\n\n// WATCH\nfunc (m *Miniredis) cmdWatch(c *server.Peer, cmd string, args []string) {\n\tif len(args) == 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\tctx := getCtx(c)\n\tif ctx.nested {\n\t\tc.WriteError(msgNotFromScripts(ctx.nestedSHA))\n\t\treturn\n\t}\n\tif inTx(ctx) {\n\t\tc.WriteError(\"ERR WATCH in MULTI\")\n\t\treturn\n\t}\n\n\tm.Lock()\n\tdefer m.Unlock()\n\tdb := m.db(ctx.selectedDB)\n\n\tfor _, key := range args {\n\t\twatch(db, ctx, key)\n\t}\n\tc.WriteOK()\n}\n\n// UNWATCH\nfunc (m *Miniredis) cmdUnwatch(c *server.Peer, cmd string, args []string) {\n\tif len(args) != 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(errWrongNumber(cmd))\n\t\treturn\n\t}\n\tif !m.handleAuth(c) {\n\t\treturn\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn\n\t}\n\n\t// Doesn't matter if UNWATCH is in a TX or not. Looks like a Redis bug to me.\n\tunwatch(getCtx(c))\n\n\twithTx(m, c, func(c *server.Peer, ctx *connCtx) {\n\t\t// Do nothing if it's called in a transaction.\n\t\tc.WriteOK()\n\t})\n}\n"
        },
        {
          "name": "cmd_transactions_test.go",
          "type": "blob",
          "size": 3.2998046875,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\nfunc TestMulti(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t// Do accept MULTI, but use it as a no-op\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n}\n\nfunc TestExec(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t// Exec without MULTI.\n\tmustDo(t, c,\n\t\t\"EXEC\",\n\t\tproto.Error(\"ERR EXEC without MULTI\"),\n\t)\n}\n\nfunc TestDiscard(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t// DISCARD without MULTI.\n\tmustDo(t, c,\n\t\t\"DISCARD\",\n\t\tproto.Error(\"ERR DISCARD without MULTI\"),\n\t)\n}\n\nfunc TestWatch(t *testing.T) {\n\t_, c := runWithClient(t)\n\n\t// Simple WATCH\n\tmustOK(t, c,\n\t\t\"WATCH\", \"foo\",\n\t)\n\n\t// Can't do WATCH in a MULTI\n\t{\n\t\tmustOK(t, c,\n\t\t\t\"MULTI\",\n\t\t)\n\t\tmustDo(t, c,\n\t\t\t\"WATCH\", \"foo\",\n\t\t\tproto.Error(\"ERR WATCH in MULTI\"),\n\t\t)\n\t}\n}\n\n// Test simple multi/exec block.\nfunc TestSimpleTransaction(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"SET\", \"aap\", \"1\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\t// Not set yet.\n\tequals(t, false, s.Exists(\"aap\"))\n\n\tmustDo(t, c,\n\t\t\"EXEC\",\n\t\tproto.Array(proto.Inline(\"OK\")),\n\t)\n\n\t// SET should be back to normal mode\n\tmustOK(t, c,\n\t\t\"SET\", \"aap\", \"1\",\n\t)\n}\n\nfunc TestDiscardTransaction(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\ts.Set(\"aap\", \"noot\")\n\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"SET\", \"aap\", \"mies\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\t// Not committed\n\ts.CheckGet(t, \"aap\", \"noot\")\n\n\tmustOK(t, c,\n\t\t\"DISCARD\",\n\t)\n\n\t// TX didn't get executed\n\ts.CheckGet(t, \"aap\", \"noot\")\n}\n\nfunc TestTxQueueErr(t *testing.T) {\n\ts, c := runWithClient(t)\n\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"SET\", \"aap\", \"mies\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\t// That's an error!\n\tmustDo(t, c,\n\t\t\"SET\", \"aap\",\n\t\tproto.Error(errWrongNumber(\"set\")),\n\t)\n\n\t// Thisone is ok again\n\tmustDo(t, c,\n\t\t\"SET\", \"noot\", \"vuur\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EXEC\",\n\t\tproto.Error(\"EXECABORT Transaction discarded because of previous errors.\"),\n\t)\n\n\t// Didn't get EXECed\n\tequals(t, false, s.Exists(\"aap\"))\n}\n\nfunc TestTxWatch(t *testing.T) {\n\t// Watch with no error.\n\ts, c := runWithClient(t)\n\n\ts.Set(\"one\", \"two\")\n\tmustOK(t, c,\n\t\t\"WATCH\", \"one\",\n\t)\n\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"GET\", \"one\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EXEC\",\n\t\tproto.Strings(\"two\"),\n\t)\n}\n\nfunc TestTxWatchErr(t *testing.T) {\n\t// Watch with en error.\n\ts, c := runWithClient(t)\n\tc2, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c2.Close()\n\n\ts.Set(\"one\", \"two\")\n\tmustOK(t, c,\n\t\t\"WATCH\", \"one\",\n\t\tproto.String(\"\"),\n\t)\n\n\t// Here comes client 2\n\tmustOK(t, c2, \"SET\", \"one\", \"three\")\n\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"GET\", \"one\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\tmustNilList(t, c,\n\t\t\"EXEC\",\n\t)\n\n\t// It did get updated, and we're not in a transaction anymore.\n\tmustDo(t, c,\n\t\t\"GET\", \"one\",\n\t\tproto.String(\"three\"),\n\t)\n}\n\nfunc TestUnwatch(t *testing.T) {\n\ts, c := runWithClient(t)\n\tc2, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c2.Close()\n\n\ts.Set(\"one\", \"two\")\n\tmustOK(t, c,\n\t\t\"WATCH\", \"one\",\n\t)\n\n\tmustOK(t, c,\n\t\t\"UNWATCH\",\n\t)\n\n\t// Here comes client 2\n\tmustOK(t, c2,\n\t\t\"SET\", \"one\", \"three\",\n\t)\n\n\tmustOK(t, c,\n\t\t\"MULTI\",\n\t)\n\n\tmustDo(t, c,\n\t\t\"SET\", \"one\", \"four\",\n\t\tproto.Inline(\"QUEUED\"),\n\t)\n\n\tmustDo(t, c,\n\t\t\"EXEC\",\n\t\tproto.Array(proto.Inline(\"OK\")),\n\t)\n\n\t// It did get updated by our TX\n\tmustDo(t, c,\n\t\t\"GET\", \"one\",\n\t\tproto.String(\"four\"),\n\t)\n}\n"
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 16.095703125,
          "content": "package miniredis\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"sort\"\n\t\"strconv\"\n\t\"time\"\n)\n\nvar (\n\terrInvalidEntryID = errors.New(\"stream ID is invalid\")\n)\n\n// exists also updates the lru\nfunc (db *RedisDB) exists(k string) bool {\n\t_, ok := db.keys[k]\n\tif ok {\n\t\tdb.lru[k] = db.master.effectiveNow()\n\t}\n\treturn ok\n}\n\n// t gives the type of a key, or \"\"\nfunc (db *RedisDB) t(k string) string {\n\treturn db.keys[k]\n}\n\n// incr increases the version and the lru timestamp\nfunc (db *RedisDB) incr(k string) {\n\tdb.lru[k] = db.master.effectiveNow()\n\tdb.keyVersion[k]++\n}\n\n// allKeys returns all keys. Sorted.\nfunc (db *RedisDB) allKeys() []string {\n\tres := make([]string, 0, len(db.keys))\n\tfor k := range db.keys {\n\t\tres = append(res, k)\n\t}\n\tsort.Strings(res) // To make things deterministic.\n\treturn res\n}\n\n// flush removes all keys and values.\nfunc (db *RedisDB) flush() {\n\tdb.keys = map[string]string{}\n\tdb.lru = map[string]time.Time{}\n\tdb.stringKeys = map[string]string{}\n\tdb.hashKeys = map[string]hashKey{}\n\tdb.listKeys = map[string]listKey{}\n\tdb.setKeys = map[string]setKey{}\n\tdb.hllKeys = map[string]*hll{}\n\tdb.sortedsetKeys = map[string]sortedSet{}\n\tdb.ttl = map[string]time.Duration{}\n\tdb.streamKeys = map[string]*streamKey{}\n}\n\n// move something to another db. Will return ok. Or not.\nfunc (db *RedisDB) move(key string, to *RedisDB) bool {\n\tif _, ok := to.keys[key]; ok {\n\t\treturn false\n\t}\n\n\tt, ok := db.keys[key]\n\tif !ok {\n\t\treturn false\n\t}\n\tto.keys[key] = db.keys[key]\n\tswitch t {\n\tcase \"string\":\n\t\tto.stringKeys[key] = db.stringKeys[key]\n\tcase \"hash\":\n\t\tto.hashKeys[key] = db.hashKeys[key]\n\tcase \"list\":\n\t\tto.listKeys[key] = db.listKeys[key]\n\tcase \"set\":\n\t\tto.setKeys[key] = db.setKeys[key]\n\tcase \"zset\":\n\t\tto.sortedsetKeys[key] = db.sortedsetKeys[key]\n\tcase \"stream\":\n\t\tto.streamKeys[key] = db.streamKeys[key]\n\tcase \"hll\":\n\t\tto.hllKeys[key] = db.hllKeys[key]\n\tdefault:\n\t\tpanic(\"unhandled key type\")\n\t}\n\tif v, ok := db.ttl[key]; ok {\n\t\tto.ttl[key] = v\n\t}\n\tto.incr(key)\n\tdb.del(key, true)\n\treturn true\n}\n\nfunc (db *RedisDB) rename(from, to string) {\n\tdb.del(to, true)\n\tswitch db.t(from) {\n\tcase \"string\":\n\t\tdb.stringKeys[to] = db.stringKeys[from]\n\tcase \"hash\":\n\t\tdb.hashKeys[to] = db.hashKeys[from]\n\tcase \"list\":\n\t\tdb.listKeys[to] = db.listKeys[from]\n\tcase \"set\":\n\t\tdb.setKeys[to] = db.setKeys[from]\n\tcase \"zset\":\n\t\tdb.sortedsetKeys[to] = db.sortedsetKeys[from]\n\tcase \"stream\":\n\t\tdb.streamKeys[to] = db.streamKeys[from]\n\tcase \"hll\":\n\t\tdb.hllKeys[to] = db.hllKeys[from]\n\tdefault:\n\t\tpanic(\"missing case\")\n\t}\n\tdb.keys[to] = db.keys[from]\n\tif v, ok := db.ttl[from]; ok {\n\t\tdb.ttl[to] = v\n\t}\n\tdb.incr(to)\n\n\tdb.del(from, true)\n}\n\nfunc (db *RedisDB) del(k string, delTTL bool) {\n\tif !db.exists(k) {\n\t\treturn\n\t}\n\tt := db.t(k)\n\tdelete(db.keys, k)\n\tdelete(db.lru, k)\n\tdb.keyVersion[k]++\n\tif delTTL {\n\t\tdelete(db.ttl, k)\n\t}\n\tswitch t {\n\tcase \"string\":\n\t\tdelete(db.stringKeys, k)\n\tcase \"hash\":\n\t\tdelete(db.hashKeys, k)\n\tcase \"list\":\n\t\tdelete(db.listKeys, k)\n\tcase \"set\":\n\t\tdelete(db.setKeys, k)\n\tcase \"zset\":\n\t\tdelete(db.sortedsetKeys, k)\n\tcase \"stream\":\n\t\tdelete(db.streamKeys, k)\n\tcase \"hll\":\n\t\tdelete(db.hllKeys, k)\n\tdefault:\n\t\tpanic(\"Unknown key type: \" + t)\n\t}\n}\n\n// stringGet returns the string key or \"\" on error/nonexists.\nfunc (db *RedisDB) stringGet(k string) string {\n\tif t, ok := db.keys[k]; !ok || t != \"string\" {\n\t\treturn \"\"\n\t}\n\treturn db.stringKeys[k]\n}\n\n// stringSet force set()s a key. Does not touch expire.\nfunc (db *RedisDB) stringSet(k, v string) {\n\tdb.del(k, false)\n\tdb.keys[k] = \"string\"\n\tdb.stringKeys[k] = v\n\tdb.incr(k)\n}\n\n// change int key value\nfunc (db *RedisDB) stringIncr(k string, delta int) (int, error) {\n\tv := 0\n\tif sv, ok := db.stringKeys[k]; ok {\n\t\tvar err error\n\t\tv, err = strconv.Atoi(sv)\n\t\tif err != nil {\n\t\t\treturn 0, ErrIntValueError\n\t\t}\n\t}\n\n\tif delta > 0 {\n\t\tif math.MaxInt-delta < v {\n\t\t\treturn 0, ErrIntValueOverflowError\n\t\t}\n\t} else {\n\t\tif math.MinInt-delta > v {\n\t\t\treturn 0, ErrIntValueOverflowError\n\t\t}\n\t}\n\n\tv += delta\n\tdb.stringSet(k, strconv.Itoa(v))\n\treturn v, nil\n}\n\n// change float key value\nfunc (db *RedisDB) stringIncrfloat(k string, delta *big.Float) (*big.Float, error) {\n\tv := big.NewFloat(0.0)\n\tv.SetPrec(128)\n\tif sv, ok := db.stringKeys[k]; ok {\n\t\tvar err error\n\t\tv, _, err = big.ParseFloat(sv, 10, 128, 0)\n\t\tif err != nil {\n\t\t\treturn nil, ErrFloatValueError\n\t\t}\n\t}\n\tv.Add(v, delta)\n\tdb.stringSet(k, formatBig(v))\n\treturn v, nil\n}\n\n// listLpush is 'left push', aka unshift. Returns the new length.\nfunc (db *RedisDB) listLpush(k, v string) int {\n\tl, ok := db.listKeys[k]\n\tif !ok {\n\t\tdb.keys[k] = \"list\"\n\t}\n\tl = append([]string{v}, l...)\n\tdb.listKeys[k] = l\n\tdb.incr(k)\n\treturn len(l)\n}\n\n// 'left pop', aka shift.\nfunc (db *RedisDB) listLpop(k string) string {\n\tl := db.listKeys[k]\n\tel := l[0]\n\tl = l[1:]\n\tif len(l) == 0 {\n\t\tdb.del(k, true)\n\t} else {\n\t\tdb.listKeys[k] = l\n\t}\n\tdb.incr(k)\n\treturn el\n}\n\nfunc (db *RedisDB) listPush(k string, v ...string) int {\n\tl, ok := db.listKeys[k]\n\tif !ok {\n\t\tdb.keys[k] = \"list\"\n\t}\n\tl = append(l, v...)\n\tdb.listKeys[k] = l\n\tdb.incr(k)\n\treturn len(l)\n}\n\nfunc (db *RedisDB) listPop(k string) string {\n\tl := db.listKeys[k]\n\tel := l[len(l)-1]\n\tl = l[:len(l)-1]\n\tif len(l) == 0 {\n\t\tdb.del(k, true)\n\t} else {\n\t\tdb.listKeys[k] = l\n\t\tdb.incr(k)\n\t}\n\treturn el\n}\n\n// setset replaces a whole set.\nfunc (db *RedisDB) setSet(k string, set setKey) {\n\tdb.keys[k] = \"set\"\n\tdb.setKeys[k] = set\n\tdb.incr(k)\n}\n\n// setadd adds members to a set. Returns nr of new keys.\nfunc (db *RedisDB) setAdd(k string, elems ...string) int {\n\ts, ok := db.setKeys[k]\n\tif !ok {\n\t\ts = setKey{}\n\t\tdb.keys[k] = \"set\"\n\t}\n\tadded := 0\n\tfor _, e := range elems {\n\t\tif _, ok := s[e]; !ok {\n\t\t\tadded++\n\t\t}\n\t\ts[e] = struct{}{}\n\t}\n\tdb.setKeys[k] = s\n\tdb.incr(k)\n\treturn added\n}\n\n// setrem removes members from a set. Returns nr of deleted keys.\nfunc (db *RedisDB) setRem(k string, fields ...string) int {\n\ts, ok := db.setKeys[k]\n\tif !ok {\n\t\treturn 0\n\t}\n\tremoved := 0\n\tfor _, f := range fields {\n\t\tif _, ok := s[f]; ok {\n\t\t\tremoved++\n\t\t\tdelete(s, f)\n\t\t}\n\t}\n\tif len(s) == 0 {\n\t\tdb.del(k, true)\n\t} else {\n\t\tdb.setKeys[k] = s\n\t}\n\tdb.incr(k)\n\treturn removed\n}\n\n// All members of a set.\nfunc (db *RedisDB) setMembers(k string) []string {\n\tset := db.setKeys[k]\n\tmembers := make([]string, 0, len(set))\n\tfor k := range set {\n\t\tmembers = append(members, k)\n\t}\n\tsort.Strings(members)\n\treturn members\n}\n\n// Is a SET value present?\nfunc (db *RedisDB) setIsMember(k, v string) bool {\n\tset, ok := db.setKeys[k]\n\tif !ok {\n\t\treturn false\n\t}\n\t_, ok = set[v]\n\treturn ok\n}\n\n// hashFields returns all (sorted) keys ('fields') for a hash key.\nfunc (db *RedisDB) hashFields(k string) []string {\n\tv := db.hashKeys[k]\n\tvar r []string\n\tfor k := range v {\n\t\tr = append(r, k)\n\t}\n\tsort.Strings(r)\n\treturn r\n}\n\n// hashValues returns all (sorted) values a hash key.\nfunc (db *RedisDB) hashValues(k string) []string {\n\th := db.hashKeys[k]\n\tvar r []string\n\tfor _, v := range h {\n\t\tr = append(r, v)\n\t}\n\tsort.Strings(r)\n\treturn r\n}\n\n// hashGet a value\nfunc (db *RedisDB) hashGet(key, field string) string {\n\treturn db.hashKeys[key][field]\n}\n\n// hashSet returns the number of new keys\nfunc (db *RedisDB) hashSet(k string, fv ...string) int {\n\tif t, ok := db.keys[k]; ok && t != \"hash\" {\n\t\tdb.del(k, true)\n\t}\n\tdb.keys[k] = \"hash\"\n\tif _, ok := db.hashKeys[k]; !ok {\n\t\tdb.hashKeys[k] = map[string]string{}\n\t}\n\tnew := 0\n\tfor idx := 0; idx < len(fv)-1; idx = idx + 2 {\n\t\tf, v := fv[idx], fv[idx+1]\n\t\t_, ok := db.hashKeys[k][f]\n\t\tdb.hashKeys[k][f] = v\n\t\tdb.incr(k)\n\t\tif !ok {\n\t\t\tnew++\n\t\t}\n\t}\n\treturn new\n}\n\n// hashIncr changes int key value\nfunc (db *RedisDB) hashIncr(key, field string, delta int) (int, error) {\n\tv := 0\n\tif h, ok := db.hashKeys[key]; ok {\n\t\tif f, ok := h[field]; ok {\n\t\t\tvar err error\n\t\t\tv, err = strconv.Atoi(f)\n\t\t\tif err != nil {\n\t\t\t\treturn 0, ErrIntValueError\n\t\t\t}\n\t\t}\n\t}\n\tv += delta\n\tdb.hashSet(key, field, strconv.Itoa(v))\n\treturn v, nil\n}\n\n// hashIncrfloat changes float key value\nfunc (db *RedisDB) hashIncrfloat(key, field string, delta *big.Float) (*big.Float, error) {\n\tv := big.NewFloat(0.0)\n\tv.SetPrec(128)\n\tif h, ok := db.hashKeys[key]; ok {\n\t\tif f, ok := h[field]; ok {\n\t\t\tvar err error\n\t\t\tv, _, err = big.ParseFloat(f, 10, 128, 0)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, ErrFloatValueError\n\t\t\t}\n\t\t}\n\t}\n\tv.Add(v, delta)\n\tdb.hashSet(key, field, formatBig(v))\n\treturn v, nil\n}\n\n// sortedSet set returns a sortedSet as map\nfunc (db *RedisDB) sortedSet(key string) map[string]float64 {\n\tss := db.sortedsetKeys[key]\n\treturn map[string]float64(ss)\n}\n\n// ssetSet sets a complete sorted set.\nfunc (db *RedisDB) ssetSet(key string, sset sortedSet) {\n\tdb.keys[key] = \"zset\"\n\tdb.incr(key)\n\tdb.sortedsetKeys[key] = sset\n}\n\n// ssetAdd adds member to a sorted set. Returns whether this was a new member.\nfunc (db *RedisDB) ssetAdd(key string, score float64, member string) bool {\n\tss, ok := db.sortedsetKeys[key]\n\tif !ok {\n\t\tss = newSortedSet()\n\t\tdb.keys[key] = \"zset\"\n\t}\n\t_, ok = ss[member]\n\tss[member] = score\n\tdb.sortedsetKeys[key] = ss\n\tdb.incr(key)\n\treturn !ok\n}\n\n// All members from a sorted set, ordered by score.\nfunc (db *RedisDB) ssetMembers(key string) []string {\n\tss, ok := db.sortedsetKeys[key]\n\tif !ok {\n\t\treturn nil\n\t}\n\telems := ss.byScore(asc)\n\tmembers := make([]string, 0, len(elems))\n\tfor _, e := range elems {\n\t\tmembers = append(members, e.member)\n\t}\n\treturn members\n}\n\n// All members+scores from a sorted set, ordered by score.\nfunc (db *RedisDB) ssetElements(key string) ssElems {\n\tss, ok := db.sortedsetKeys[key]\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn ss.byScore(asc)\n}\n\nfunc (db *RedisDB) ssetRandomMember(key string) string {\n\telems := db.ssetElements(key)\n\tif len(elems) == 0 {\n\t\treturn \"\"\n\t}\n\treturn elems[db.master.randIntn(len(elems))].member\n}\n\n// ssetCard is the sorted set cardinality.\nfunc (db *RedisDB) ssetCard(key string) int {\n\tss := db.sortedsetKeys[key]\n\treturn ss.card()\n}\n\n// ssetRank is the sorted set rank.\nfunc (db *RedisDB) ssetRank(key, member string, d direction) (int, bool) {\n\tss := db.sortedsetKeys[key]\n\treturn ss.rankByScore(member, d)\n}\n\n// ssetScore is sorted set score.\nfunc (db *RedisDB) ssetScore(key, member string) float64 {\n\tss := db.sortedsetKeys[key]\n\treturn ss[member]\n}\n\n// ssetMScore returns multiple scores of a list of members in a sorted set.\nfunc (db *RedisDB) ssetMScore(key string, members []string) []float64 {\n\tscores := make([]float64, 0, len(members))\n\tss := db.sortedsetKeys[key]\n\tfor _, member := range members {\n\t\tscores = append(scores, ss[member])\n\t}\n\treturn scores\n}\n\n// ssetRem is sorted set key delete.\nfunc (db *RedisDB) ssetRem(key, member string) bool {\n\tss := db.sortedsetKeys[key]\n\t_, ok := ss[member]\n\tdelete(ss, member)\n\tif len(ss) == 0 {\n\t\t// Delete key on removal of last member\n\t\tdb.del(key, true)\n\t}\n\treturn ok\n}\n\n// ssetExists tells if a member exists in a sorted set.\nfunc (db *RedisDB) ssetExists(key, member string) bool {\n\tss := db.sortedsetKeys[key]\n\t_, ok := ss[member]\n\treturn ok\n}\n\n// ssetIncrby changes float sorted set score.\nfunc (db *RedisDB) ssetIncrby(k, m string, delta float64) float64 {\n\tss, ok := db.sortedsetKeys[k]\n\tif !ok {\n\t\tss = newSortedSet()\n\t\tdb.keys[k] = \"zset\"\n\t\tdb.sortedsetKeys[k] = ss\n\t}\n\n\tv, _ := ss.get(m)\n\tv += delta\n\tss.set(v, m)\n\tdb.incr(k)\n\treturn v\n}\n\n// setDiff implements the logic behind SDIFF*\nfunc (db *RedisDB) setDiff(keys []string) (setKey, error) {\n\tkey := keys[0]\n\tkeys = keys[1:]\n\tif db.exists(key) && db.t(key) != \"set\" {\n\t\treturn nil, ErrWrongType\n\t}\n\ts := setKey{}\n\tfor k := range db.setKeys[key] {\n\t\ts[k] = struct{}{}\n\t}\n\tfor _, sk := range keys {\n\t\tif !db.exists(sk) {\n\t\t\tcontinue\n\t\t}\n\t\tif db.t(sk) != \"set\" {\n\t\t\treturn nil, ErrWrongType\n\t\t}\n\t\tfor e := range db.setKeys[sk] {\n\t\t\tdelete(s, e)\n\t\t}\n\t}\n\treturn s, nil\n}\n\n// setInter implements the logic behind SINTER*\n// len keys needs to be > 0\nfunc (db *RedisDB) setInter(keys []string) (setKey, error) {\n\t// all keys must either not exist, or be of type \"set\".\n\tfor _, key := range keys {\n\t\tif db.exists(key) && db.t(key) != \"set\" {\n\t\t\treturn nil, ErrWrongType\n\t\t}\n\t}\n\n\tkey := keys[0]\n\tkeys = keys[1:]\n\tif !db.exists(key) {\n\t\treturn nil, nil\n\t}\n\tif db.t(key) != \"set\" {\n\t\treturn nil, ErrWrongType\n\t}\n\ts := setKey{}\n\tfor k := range db.setKeys[key] {\n\t\ts[k] = struct{}{}\n\t}\n\tfor _, sk := range keys {\n\t\tif !db.exists(sk) {\n\t\t\treturn setKey{}, nil\n\t\t}\n\t\tif db.t(sk) != \"set\" {\n\t\t\treturn nil, ErrWrongType\n\t\t}\n\t\tother := db.setKeys[sk]\n\t\tfor e := range s {\n\t\t\tif _, ok := other[e]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdelete(s, e)\n\t\t}\n\t}\n\treturn s, nil\n}\n\n// setIntercard implements the logic behind SINTER*\n// len keys needs to be > 0\nfunc (db *RedisDB) setIntercard(keys []string, limit int) (int, error) {\n\t// all keys must either not exist, or be of type \"set\".\n\tallExist := true\n\tfor _, key := range keys {\n\t\texists := db.exists(key)\n\t\tallExist = allExist && exists\n\t\tif exists && db.t(key) != \"set\" {\n\t\t\treturn 0, ErrWrongType\n\t\t}\n\t}\n\n\tif !allExist {\n\t\treturn 0, nil\n\t}\n\n\tsmallestKey := keys[0]\n\tsmallestIdx := 0\n\tfor i, key := range keys {\n\t\tif len(db.setKeys[key]) < len(db.setKeys[smallestKey]) {\n\t\t\tsmallestKey = key\n\t\t\tsmallestIdx = i\n\t\t}\n\t}\n\tkeys[smallestIdx] = keys[len(keys)-1]\n\tkeys = keys[:len(keys)-1]\n\n\tcount := 0\n\tfor item := range db.setKeys[smallestKey] {\n\t\tinIntersection := true\n\t\tfor _, key := range keys {\n\t\t\tif _, ok := db.setKeys[key][item]; !ok {\n\t\t\t\tinIntersection = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif inIntersection {\n\t\t\tcount++\n\t\t\tif count == limit {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn count, nil\n}\n\n// setUnion implements the logic behind SUNION*\nfunc (db *RedisDB) setUnion(keys []string) (setKey, error) {\n\tkey := keys[0]\n\tkeys = keys[1:]\n\tif db.exists(key) && db.t(key) != \"set\" {\n\t\treturn nil, ErrWrongType\n\t}\n\ts := setKey{}\n\tfor k := range db.setKeys[key] {\n\t\ts[k] = struct{}{}\n\t}\n\tfor _, sk := range keys {\n\t\tif !db.exists(sk) {\n\t\t\tcontinue\n\t\t}\n\t\tif db.t(sk) != \"set\" {\n\t\t\treturn nil, ErrWrongType\n\t\t}\n\t\tfor e := range db.setKeys[sk] {\n\t\t\ts[e] = struct{}{}\n\t\t}\n\t}\n\treturn s, nil\n}\n\nfunc (db *RedisDB) newStream(key string) (*streamKey, error) {\n\tif s, err := db.stream(key); err != nil {\n\t\treturn nil, err\n\t} else if s != nil {\n\t\treturn nil, fmt.Errorf(\"ErrAlreadyExists\")\n\t}\n\n\tdb.keys[key] = \"stream\"\n\ts := newStreamKey()\n\tdb.streamKeys[key] = s\n\tdb.incr(key)\n\treturn s, nil\n}\n\n// return existing stream, or nil.\nfunc (db *RedisDB) stream(key string) (*streamKey, error) {\n\tif db.exists(key) && db.t(key) != \"stream\" {\n\t\treturn nil, ErrWrongType\n\t}\n\n\treturn db.streamKeys[key], nil\n}\n\n// return existing stream group, or nil.\nfunc (db *RedisDB) streamGroup(key, group string) (*streamGroup, error) {\n\ts, err := db.stream(key)\n\tif err != nil || s == nil {\n\t\treturn nil, err\n\t}\n\treturn s.groups[group], nil\n}\n\n// fastForward proceeds the current timestamp with duration, works as a time machine\nfunc (db *RedisDB) fastForward(duration time.Duration) {\n\tfor _, key := range db.allKeys() {\n\t\tif value, ok := db.ttl[key]; ok {\n\t\t\tdb.ttl[key] = value - duration\n\t\t\tdb.checkTTL(key)\n\t\t}\n\t}\n}\n\nfunc (db *RedisDB) checkTTL(key string) {\n\tif v, ok := db.ttl[key]; ok && v <= 0 {\n\t\tdb.del(key, true)\n\t}\n}\n\n// hllAdd adds members to a hll. Returns 1 if at least 1 if internal HyperLogLog was altered, otherwise 0\nfunc (db *RedisDB) hllAdd(k string, elems ...string) int {\n\ts, ok := db.hllKeys[k]\n\tif !ok {\n\t\ts = newHll()\n\t\tdb.keys[k] = \"hll\"\n\t}\n\thllAltered := 0\n\tfor _, e := range elems {\n\t\tif s.Add([]byte(e)) {\n\t\t\thllAltered = 1\n\t\t}\n\t}\n\tdb.hllKeys[k] = s\n\tdb.incr(k)\n\treturn hllAltered\n}\n\n// hllCount estimates the amount of members added to hll by hllAdd. If called with several arguments, hllCount returns a sum of estimations\nfunc (db *RedisDB) hllCount(keys []string) (int, error) {\n\tcountOverall := 0\n\tfor _, key := range keys {\n\t\tif db.exists(key) && db.t(key) != \"hll\" {\n\t\t\treturn 0, ErrNotValidHllValue\n\t\t}\n\t\tif !db.exists(key) {\n\t\t\tcontinue\n\t\t}\n\t\tcountOverall += db.hllKeys[key].Count()\n\t}\n\n\treturn countOverall, nil\n}\n\n// hllMerge merges all the hlls provided as keys to the first key. Creates a new hll in the first key if it contains nothing\nfunc (db *RedisDB) hllMerge(keys []string) error {\n\tfor _, key := range keys {\n\t\tif db.exists(key) && db.t(key) != \"hll\" {\n\t\t\treturn ErrNotValidHllValue\n\t\t}\n\t}\n\n\tdestKey := keys[0]\n\trestKeys := keys[1:]\n\n\tvar destHll *hll\n\tif db.exists(destKey) {\n\t\tdestHll = db.hllKeys[destKey]\n\t} else {\n\t\tdestHll = newHll()\n\t}\n\n\tfor _, key := range restKeys {\n\t\tif !db.exists(key) {\n\t\t\tcontinue\n\t\t}\n\t\tdestHll.Merge(db.hllKeys[key])\n\t}\n\n\tdb.hllKeys[destKey] = destHll\n\tdb.keys[destKey] = \"hll\"\n\tdb.incr(destKey)\n\n\treturn nil\n}\n"
        },
        {
          "name": "direct.go",
          "type": "blob",
          "size": 20.7919921875,
          "content": "package miniredis\n\n// Commands to modify and query our databases directly.\n\nimport (\n\t\"errors\"\n\t\"math/big\"\n\t\"time\"\n)\n\nvar (\n\t// ErrKeyNotFound is returned when a key doesn't exist.\n\tErrKeyNotFound = errors.New(msgKeyNotFound)\n\n\t// ErrWrongType when a key is not the right type.\n\tErrWrongType = errors.New(msgWrongType)\n\n\t// ErrNotValidHllValue when a key is not a valid HyperLogLog string value.\n\tErrNotValidHllValue = errors.New(msgNotValidHllValue)\n\n\t// ErrIntValueError can returned by INCRBY\n\tErrIntValueError = errors.New(msgInvalidInt)\n\n\t// ErrIntValueOverflowError can be returned by INCR, DECR, INCRBY, DECRBY\n\tErrIntValueOverflowError = errors.New(msgIntOverflow)\n\n\t// ErrFloatValueError can returned by INCRBYFLOAT\n\tErrFloatValueError = errors.New(msgInvalidFloat)\n)\n\n// Select sets the DB id for all direct commands.\nfunc (m *Miniredis) Select(i int) {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.selectedDB = i\n}\n\n// Keys returns all keys from the selected database, sorted.\nfunc (m *Miniredis) Keys() []string {\n\treturn m.DB(m.selectedDB).Keys()\n}\n\n// Keys returns all keys, sorted.\nfunc (db *RedisDB) Keys() []string {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\treturn db.allKeys()\n}\n\n// FlushAll removes all keys from all databases.\nfunc (m *Miniredis) FlushAll() {\n\tm.Lock()\n\tdefer m.Unlock()\n\tdefer m.signal.Broadcast()\n\n\tm.flushAll()\n}\n\nfunc (m *Miniredis) flushAll() {\n\tfor _, db := range m.dbs {\n\t\tdb.flush()\n\t}\n}\n\n// FlushDB removes all keys from the selected database.\nfunc (m *Miniredis) FlushDB() {\n\tm.DB(m.selectedDB).FlushDB()\n}\n\n// FlushDB removes all keys.\nfunc (db *RedisDB) FlushDB() {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tdb.flush()\n}\n\n// Get returns string keys added with SET.\nfunc (m *Miniredis) Get(k string) (string, error) {\n\treturn m.DB(m.selectedDB).Get(k)\n}\n\n// Get returns a string key.\nfunc (db *RedisDB) Get(k string) (string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn \"\", ErrKeyNotFound\n\t}\n\tif db.t(k) != \"string\" {\n\t\treturn \"\", ErrWrongType\n\t}\n\treturn db.stringGet(k), nil\n}\n\n// Set sets a string key. Removes expire.\nfunc (m *Miniredis) Set(k, v string) error {\n\treturn m.DB(m.selectedDB).Set(k, v)\n}\n\n// Set sets a string key. Removes expire.\n// Unlike redis the key can't be an existing non-string key.\nfunc (db *RedisDB) Set(k, v string) error {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"string\" {\n\t\treturn ErrWrongType\n\t}\n\tdb.del(k, true) // Remove expire\n\tdb.stringSet(k, v)\n\treturn nil\n}\n\n// Incr changes a int string value by delta.\nfunc (m *Miniredis) Incr(k string, delta int) (int, error) {\n\treturn m.DB(m.selectedDB).Incr(k, delta)\n}\n\n// Incr changes a int string value by delta.\nfunc (db *RedisDB) Incr(k string, delta int) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"string\" {\n\t\treturn 0, ErrWrongType\n\t}\n\n\treturn db.stringIncr(k, delta)\n}\n\n// IncrByFloat increments the float value of a key by the given delta.\n// is an alias for Miniredis.Incrfloat\nfunc (m *Miniredis) IncrByFloat(k string, delta float64) (float64, error) {\n\treturn m.Incrfloat(k, delta)\n}\n\n// Incrfloat changes a float string value by delta.\nfunc (m *Miniredis) Incrfloat(k string, delta float64) (float64, error) {\n\treturn m.DB(m.selectedDB).Incrfloat(k, delta)\n}\n\n// Incrfloat changes a float string value by delta.\nfunc (db *RedisDB) Incrfloat(k string, delta float64) (float64, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"string\" {\n\t\treturn 0, ErrWrongType\n\t}\n\n\tv, err := db.stringIncrfloat(k, big.NewFloat(delta))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvf, _ := v.Float64()\n\treturn vf, nil\n}\n\n// List returns the list k, or an error if it's not there or something else.\n// This is the same as the Redis command `LRANGE 0 -1`, but you can do your own\n// range-ing.\nfunc (m *Miniredis) List(k string) ([]string, error) {\n\treturn m.DB(m.selectedDB).List(k)\n}\n\n// List returns the list k, or an error if it's not there or something else.\n// This is the same as the Redis command `LRANGE 0 -1`, but you can do your own\n// range-ing.\nfunc (db *RedisDB) List(k string) ([]string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"list\" {\n\t\treturn nil, ErrWrongType\n\t}\n\treturn db.listKeys[k], nil\n}\n\n// Lpush prepends one value to a list. Returns the new length.\nfunc (m *Miniredis) Lpush(k, v string) (int, error) {\n\treturn m.DB(m.selectedDB).Lpush(k, v)\n}\n\n// Lpush prepends one value to a list. Returns the new length.\nfunc (db *RedisDB) Lpush(k, v string) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"list\" {\n\t\treturn 0, ErrWrongType\n\t}\n\treturn db.listLpush(k, v), nil\n}\n\n// Lpop removes and returns the last element in a list.\nfunc (m *Miniredis) Lpop(k string) (string, error) {\n\treturn m.DB(m.selectedDB).Lpop(k)\n}\n\n// Lpop removes and returns the last element in a list.\nfunc (db *RedisDB) Lpop(k string) (string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif !db.exists(k) {\n\t\treturn \"\", ErrKeyNotFound\n\t}\n\tif db.t(k) != \"list\" {\n\t\treturn \"\", ErrWrongType\n\t}\n\treturn db.listLpop(k), nil\n}\n\n// RPush appends one or multiple values to a list. Returns the new length.\n// An alias for Push\nfunc (m *Miniredis) RPush(k string, v ...string) (int, error) {\n\treturn m.Push(k, v...)\n}\n\n// Push add element at the end. Returns the new length.\nfunc (m *Miniredis) Push(k string, v ...string) (int, error) {\n\treturn m.DB(m.selectedDB).Push(k, v...)\n}\n\n// Push add element at the end. Is called RPUSH in redis. Returns the new length.\nfunc (db *RedisDB) Push(k string, v ...string) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"list\" {\n\t\treturn 0, ErrWrongType\n\t}\n\treturn db.listPush(k, v...), nil\n}\n\n// RPop is an alias for Pop\nfunc (m *Miniredis) RPop(k string) (string, error) {\n\treturn m.Pop(k)\n}\n\n// Pop removes and returns the last element. Is called RPOP in Redis.\nfunc (m *Miniredis) Pop(k string) (string, error) {\n\treturn m.DB(m.selectedDB).Pop(k)\n}\n\n// Pop removes and returns the last element. Is called RPOP in Redis.\nfunc (db *RedisDB) Pop(k string) (string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif !db.exists(k) {\n\t\treturn \"\", ErrKeyNotFound\n\t}\n\tif db.t(k) != \"list\" {\n\t\treturn \"\", ErrWrongType\n\t}\n\n\treturn db.listPop(k), nil\n}\n\n// SAdd adds keys to a set. Returns the number of new keys.\n// Alias for SetAdd\nfunc (m *Miniredis) SAdd(k string, elems ...string) (int, error) {\n\treturn m.SetAdd(k, elems...)\n}\n\n// SetAdd adds keys to a set. Returns the number of new keys.\nfunc (m *Miniredis) SetAdd(k string, elems ...string) (int, error) {\n\treturn m.DB(m.selectedDB).SetAdd(k, elems...)\n}\n\n// SetAdd adds keys to a set. Returns the number of new keys.\nfunc (db *RedisDB) SetAdd(k string, elems ...string) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"set\" {\n\t\treturn 0, ErrWrongType\n\t}\n\treturn db.setAdd(k, elems...), nil\n}\n\n// SMembers returns all keys in a set, sorted.\n// Alias for Members.\nfunc (m *Miniredis) SMembers(k string) ([]string, error) {\n\treturn m.Members(k)\n}\n\n// Members returns all keys in a set, sorted.\nfunc (m *Miniredis) Members(k string) ([]string, error) {\n\treturn m.DB(m.selectedDB).Members(k)\n}\n\n// Members gives all set keys. Sorted.\nfunc (db *RedisDB) Members(k string) ([]string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"set\" {\n\t\treturn nil, ErrWrongType\n\t}\n\treturn db.setMembers(k), nil\n}\n\n// SIsMember tells if value is in the set.\n// Alias for IsMember\nfunc (m *Miniredis) SIsMember(k, v string) (bool, error) {\n\treturn m.IsMember(k, v)\n}\n\n// IsMember tells if value is in the set.\nfunc (m *Miniredis) IsMember(k, v string) (bool, error) {\n\treturn m.DB(m.selectedDB).IsMember(k, v)\n}\n\n// IsMember tells if value is in the set.\nfunc (db *RedisDB) IsMember(k, v string) (bool, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn false, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"set\" {\n\t\treturn false, ErrWrongType\n\t}\n\treturn db.setIsMember(k, v), nil\n}\n\n// HKeys returns all (sorted) keys ('fields') for a hash key.\nfunc (m *Miniredis) HKeys(k string) ([]string, error) {\n\treturn m.DB(m.selectedDB).HKeys(k)\n}\n\n// HKeys returns all (sorted) keys ('fields') for a hash key.\nfunc (db *RedisDB) HKeys(key string) ([]string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(key) {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\tif db.t(key) != \"hash\" {\n\t\treturn nil, ErrWrongType\n\t}\n\treturn db.hashFields(key), nil\n}\n\n// Del deletes a key and any expiration value. Returns whether there was a key.\nfunc (m *Miniredis) Del(k string) bool {\n\treturn m.DB(m.selectedDB).Del(k)\n}\n\n// Del deletes a key and any expiration value. Returns whether there was a key.\nfunc (db *RedisDB) Del(k string) bool {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif !db.exists(k) {\n\t\treturn false\n\t}\n\tdb.del(k, true)\n\treturn true\n}\n\n// Unlink deletes a key and any expiration value. Returns where there was a key.\n// It's exactly the same as Del() and is not async. It is here for the consistency.\nfunc (m *Miniredis) Unlink(k string) bool {\n\treturn m.Del(k)\n}\n\n// Unlink deletes a key and any expiration value. Returns where there was a key.\n// It's exactly the same as Del() and is not async. It is here for the consistency.\nfunc (db *RedisDB) Unlink(k string) bool {\n\treturn db.Del(k)\n}\n\n// TTL is the left over time to live. As set via EXPIRE, PEXPIRE, EXPIREAT,\n// PEXPIREAT.\n// Note: this direct function returns 0 if there is no TTL set, unlike redis,\n// which returns -1.\nfunc (m *Miniredis) TTL(k string) time.Duration {\n\treturn m.DB(m.selectedDB).TTL(k)\n}\n\n// TTL is the left over time to live. As set via EXPIRE, PEXPIRE, EXPIREAT,\n// PEXPIREAT.\n// 0 if not set.\nfunc (db *RedisDB) TTL(k string) time.Duration {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\treturn db.ttl[k]\n}\n\n// SetTTL sets the TTL of a key.\nfunc (m *Miniredis) SetTTL(k string, ttl time.Duration) {\n\tm.DB(m.selectedDB).SetTTL(k, ttl)\n}\n\n// SetTTL sets the time to live of a key.\nfunc (db *RedisDB) SetTTL(k string, ttl time.Duration) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tdb.ttl[k] = ttl\n\tdb.incr(k)\n}\n\n// Type gives the type of a key, or \"\"\nfunc (m *Miniredis) Type(k string) string {\n\treturn m.DB(m.selectedDB).Type(k)\n}\n\n// Type gives the type of a key, or \"\"\nfunc (db *RedisDB) Type(k string) string {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\treturn db.t(k)\n}\n\n// Exists tells whether a key exists.\nfunc (m *Miniredis) Exists(k string) bool {\n\treturn m.DB(m.selectedDB).Exists(k)\n}\n\n// Exists tells whether a key exists.\nfunc (db *RedisDB) Exists(k string) bool {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\treturn db.exists(k)\n}\n\n// HGet returns hash keys added with HSET.\n// This will return an empty string if the key is not set. Redis would return\n// a nil.\n// Returns empty string when the key is of a different type.\nfunc (m *Miniredis) HGet(k, f string) string {\n\treturn m.DB(m.selectedDB).HGet(k, f)\n}\n\n// HGet returns hash keys added with HSET.\n// Returns empty string when the key is of a different type.\nfunc (db *RedisDB) HGet(k, f string) string {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\th, ok := db.hashKeys[k]\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn h[f]\n}\n\n// HSet sets hash keys.\n// If there is another key by the same name it will be gone.\nfunc (m *Miniredis) HSet(k string, fv ...string) {\n\tm.DB(m.selectedDB).HSet(k, fv...)\n}\n\n// HSet sets hash keys.\n// If there is another key by the same name it will be gone.\nfunc (db *RedisDB) HSet(k string, fv ...string) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tdb.hashSet(k, fv...)\n}\n\n// HDel deletes a hash key.\nfunc (m *Miniredis) HDel(k, f string) {\n\tm.DB(m.selectedDB).HDel(k, f)\n}\n\n// HDel deletes a hash key.\nfunc (db *RedisDB) HDel(k, f string) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tdb.hdel(k, f)\n}\n\nfunc (db *RedisDB) hdel(k, f string) {\n\tif _, ok := db.hashKeys[k]; !ok {\n\t\treturn\n\t}\n\tdelete(db.hashKeys[k], f)\n\tdb.incr(k)\n}\n\n// HIncrBy increases the integer value of a hash field by delta (int).\nfunc (m *Miniredis) HIncrBy(k, f string, delta int) (int, error) {\n\treturn m.HIncr(k, f, delta)\n}\n\n// HIncr increases a key/field by delta (int).\nfunc (m *Miniredis) HIncr(k, f string, delta int) (int, error) {\n\treturn m.DB(m.selectedDB).HIncr(k, f, delta)\n}\n\n// HIncr increases a key/field by delta (int).\nfunc (db *RedisDB) HIncr(k, f string, delta int) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\treturn db.hashIncr(k, f, delta)\n}\n\n// HIncrByFloat increases a key/field by delta (float).\nfunc (m *Miniredis) HIncrByFloat(k, f string, delta float64) (float64, error) {\n\treturn m.HIncrfloat(k, f, delta)\n}\n\n// HIncrfloat increases a key/field by delta (float).\nfunc (m *Miniredis) HIncrfloat(k, f string, delta float64) (float64, error) {\n\treturn m.DB(m.selectedDB).HIncrfloat(k, f, delta)\n}\n\n// HIncrfloat increases a key/field by delta (float).\nfunc (db *RedisDB) HIncrfloat(k, f string, delta float64) (float64, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tv, err := db.hashIncrfloat(k, f, big.NewFloat(delta))\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tvf, _ := v.Float64()\n\treturn vf, nil\n}\n\n// SRem removes fields from a set. Returns number of deleted fields.\nfunc (m *Miniredis) SRem(k string, fields ...string) (int, error) {\n\treturn m.DB(m.selectedDB).SRem(k, fields...)\n}\n\n// SRem removes fields from a set. Returns number of deleted fields.\nfunc (db *RedisDB) SRem(k string, fields ...string) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif !db.exists(k) {\n\t\treturn 0, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"set\" {\n\t\treturn 0, ErrWrongType\n\t}\n\treturn db.setRem(k, fields...), nil\n}\n\n// ZAdd adds a score,member to a sorted set.\nfunc (m *Miniredis) ZAdd(k string, score float64, member string) (bool, error) {\n\treturn m.DB(m.selectedDB).ZAdd(k, score, member)\n}\n\n// ZAdd adds a score,member to a sorted set.\nfunc (db *RedisDB) ZAdd(k string, score float64, member string) (bool, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif db.exists(k) && db.t(k) != \"zset\" {\n\t\treturn false, ErrWrongType\n\t}\n\treturn db.ssetAdd(k, score, member), nil\n}\n\n// ZMembers returns all members of a sorted set by score\nfunc (m *Miniredis) ZMembers(k string) ([]string, error) {\n\treturn m.DB(m.selectedDB).ZMembers(k)\n}\n\n// ZMembers returns all members of a sorted set by score\nfunc (db *RedisDB) ZMembers(k string) ([]string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"zset\" {\n\t\treturn nil, ErrWrongType\n\t}\n\treturn db.ssetMembers(k), nil\n}\n\n// SortedSet returns a raw string->float64 map.\nfunc (m *Miniredis) SortedSet(k string) (map[string]float64, error) {\n\treturn m.DB(m.selectedDB).SortedSet(k)\n}\n\n// SortedSet returns a raw string->float64 map.\nfunc (db *RedisDB) SortedSet(k string) (map[string]float64, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"zset\" {\n\t\treturn nil, ErrWrongType\n\t}\n\treturn db.sortedSet(k), nil\n}\n\n// ZRem deletes a member. Returns whether the was a key.\nfunc (m *Miniredis) ZRem(k, member string) (bool, error) {\n\treturn m.DB(m.selectedDB).ZRem(k, member)\n}\n\n// ZRem deletes a member. Returns whether the was a key.\nfunc (db *RedisDB) ZRem(k, member string) (bool, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\tif !db.exists(k) {\n\t\treturn false, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"zset\" {\n\t\treturn false, ErrWrongType\n\t}\n\treturn db.ssetRem(k, member), nil\n}\n\n// ZScore gives the score of a sorted set member.\nfunc (m *Miniredis) ZScore(k, member string) (float64, error) {\n\treturn m.DB(m.selectedDB).ZScore(k, member)\n}\n\n// ZScore gives the score of a sorted set member.\nfunc (db *RedisDB) ZScore(k, member string) (float64, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn 0, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"zset\" {\n\t\treturn 0, ErrWrongType\n\t}\n\treturn db.ssetScore(k, member), nil\n}\n\n// ZScore gives scores of a list of members in a sorted set.\nfunc (m *Miniredis) ZMScore(k string, members ...string) ([]float64, error) {\n\treturn m.DB(m.selectedDB).ZMScore(k, members)\n}\n\nfunc (db *RedisDB) ZMScore(k string, members []string) ([]float64, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif !db.exists(k) {\n\t\treturn nil, ErrKeyNotFound\n\t}\n\tif db.t(k) != \"zset\" {\n\t\treturn nil, ErrWrongType\n\t}\n\treturn db.ssetMScore(k, members), nil\n}\n\n// XAdd adds an entry to a stream. `id` can be left empty or be '*'.\n// If a value is given normal XADD rules apply. Values should be an even\n// length.\nfunc (m *Miniredis) XAdd(k string, id string, values []string) (string, error) {\n\treturn m.DB(m.selectedDB).XAdd(k, id, values)\n}\n\n// XAdd adds an entry to a stream. `id` can be left empty or be '*'.\n// If a value is given normal XADD rules apply. Values should be an even\n// length.\nfunc (db *RedisDB) XAdd(k string, id string, values []string) (string, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\tdefer db.master.signal.Broadcast()\n\n\ts, err := db.stream(k)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif s == nil {\n\t\ts, _ = db.newStream(k)\n\t}\n\n\treturn s.add(id, values, db.master.effectiveNow())\n}\n\n// Stream returns a slice of stream entries. Oldest first.\nfunc (m *Miniredis) Stream(k string) ([]StreamEntry, error) {\n\treturn m.DB(m.selectedDB).Stream(k)\n}\n\n// Stream returns a slice of stream entries. Oldest first.\nfunc (db *RedisDB) Stream(key string) ([]StreamEntry, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\ts, err := db.stream(key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif s == nil {\n\t\treturn nil, nil\n\t}\n\treturn s.entries, nil\n}\n\n// Publish a message to subscribers. Returns the number of receivers.\nfunc (m *Miniredis) Publish(channel, message string) int {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\treturn m.publish(channel, message)\n}\n\n// PubSubChannels is \"PUBSUB CHANNELS <pattern>\". An empty pattern is fine\n// (meaning all channels).\n// Returned channels will be ordered alphabetically.\nfunc (m *Miniredis) PubSubChannels(pattern string) []string {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\treturn activeChannels(m.allSubscribers(), pattern)\n}\n\n// PubSubNumSub is \"PUBSUB NUMSUB [channels]\". It returns all channels with their\n// subscriber count.\nfunc (m *Miniredis) PubSubNumSub(channels ...string) map[string]int {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tsubs := m.allSubscribers()\n\tres := map[string]int{}\n\tfor _, channel := range channels {\n\t\tres[channel] = countSubs(subs, channel)\n\t}\n\treturn res\n}\n\n// PubSubNumPat is \"PUBSUB NUMPAT\"\nfunc (m *Miniredis) PubSubNumPat() int {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\treturn countPsubs(m.allSubscribers())\n}\n\n// PfAdd adds keys to a hll. Returns the flag which equals to 1 if the inner hll value has been changed.\nfunc (m *Miniredis) PfAdd(k string, elems ...string) (int, error) {\n\treturn m.DB(m.selectedDB).HllAdd(k, elems...)\n}\n\n// HllAdd adds keys to a hll. Returns the flag which equals to true if the inner hll value has been changed.\nfunc (db *RedisDB) HllAdd(k string, elems ...string) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\tif db.exists(k) && db.t(k) != \"hll\" {\n\t\treturn 0, ErrWrongType\n\t}\n\treturn db.hllAdd(k, elems...), nil\n}\n\n// PfCount returns an estimation of the amount of elements previously added to a hll.\nfunc (m *Miniredis) PfCount(keys ...string) (int, error) {\n\treturn m.DB(m.selectedDB).HllCount(keys...)\n}\n\n// HllCount returns an estimation of the amount of elements previously added to a hll.\nfunc (db *RedisDB) HllCount(keys ...string) (int, error) {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\treturn db.hllCount(keys)\n}\n\n// PfMerge merges all the input hlls into a hll under destKey key.\nfunc (m *Miniredis) PfMerge(destKey string, sourceKeys ...string) error {\n\treturn m.DB(m.selectedDB).HllMerge(destKey, sourceKeys...)\n}\n\n// HllMerge merges all the input hlls into a hll under destKey key.\nfunc (db *RedisDB) HllMerge(destKey string, sourceKeys ...string) error {\n\tdb.master.Lock()\n\tdefer db.master.Unlock()\n\n\treturn db.hllMerge(append([]string{destKey}, sourceKeys...))\n}\n\n// Copy a value.\n// Needs the IDs of both the source and dest DBs (which can differ).\n// Returns ErrKeyNotFound if src does not exist.\n// Overwrites dest if it already exists (unlike the redis command, which needs a flag to allow that).\nfunc (m *Miniredis) Copy(srcDB int, src string, destDB int, dest string) error {\n\treturn m.copy(m.DB(srcDB), src, m.DB(destDB), dest)\n}\n"
        },
        {
          "name": "fpconv",
          "type": "tree",
          "content": null
        },
        {
          "name": "geo.go",
          "type": "blob",
          "size": 1.384765625,
          "content": "package miniredis\n\nimport (\n\t\"math\"\n\n\t\"github.com/alicebob/miniredis/v2/geohash\"\n)\n\nfunc toGeohash(long, lat float64) uint64 {\n\treturn geohash.EncodeIntWithPrecision(lat, long, 52)\n}\n\nfunc fromGeohash(score uint64) (float64, float64) {\n\tlat, long := geohash.DecodeIntWithPrecision(score, 52)\n\treturn long, lat\n}\n\n// haversin() function\nfunc hsin(theta float64) float64 {\n\treturn math.Pow(math.Sin(theta/2), 2)\n}\n\n// distance function returns the distance (in meters) between two points of\n// a given longitude and latitude relatively accurately (using a spherical\n// approximation of the Earth) through the Haversin Distance Formula for\n// great arc distance on a sphere with accuracy for small distances\n// point coordinates are supplied in degrees and converted into rad. in the func\n// distance returned is meters\n// http://en.wikipedia.org/wiki/Haversine_formula\n// Source: https://gist.github.com/cdipaolo/d3f8db3848278b49db68\nfunc distance(lat1, lon1, lat2, lon2 float64) float64 {\n\t// convert to radians\n\t// must cast radius as float to multiply later\n\tvar la1, lo1, la2, lo2 float64\n\tla1 = lat1 * math.Pi / 180\n\tlo1 = lon1 * math.Pi / 180\n\tla2 = lat2 * math.Pi / 180\n\tlo2 = lon2 * math.Pi / 180\n\n\tearth := 6372797.560856 // Earth radius in METERS, according to src/geohash_helper.c\n\n\t// calculate\n\th := hsin(la2-la1) + math.Cos(la1)*math.Cos(la2)*hsin(lo2-lo1)\n\n\treturn 2 * earth * math.Asin(math.Sqrt(h))\n}\n"
        },
        {
          "name": "geo_test.go",
          "type": "blob",
          "size": 0.36328125,
          "content": "package miniredis\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestGeolib(t *testing.T) {\n\tlong := 13.36138933897018433\n\tlat := 38.11555639549629859\n\tv := toGeohash(long, lat)\n\tequals(t, v, uint64(3479099956230698))\n\n\tlongBack, latBack := fromGeohash(uint64(float64(v)))\n\tassert(t, math.Abs(long-longBack) < 0.000001, \"long\")\n\tassert(t, math.Abs(lat-latBack) < 0.000001, \"lat\")\n}\n"
        },
        {
          "name": "geohash",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1611328125,
          "content": "module github.com/alicebob/miniredis/v2\n\nrequire (\n\tgithub.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302\n\tgithub.com/yuin/gopher-lua v1.1.1\n)\n\ngo 1.17\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.0439453125,
          "content": "github.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a h1:HbKu58rmZpUGpz5+4FfNmIU+FmZg2P3Xaj2v2bfNWmk=\ngithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\ngithub.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302 h1:uvdUDbHQHO85qeSydJtItA4T55Pw6BtAejd0APRJOCE=\ngithub.com/alicebob/gopher-json v0.0.0-20230218143504-906a9b012302/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/yuin/gopher-lua v1.1.1 h1:kYKnWBjvbNP4XLT3+bPEwAXJx262OhaHDWDVOPjL46M=\ngithub.com/yuin/gopher-lua v1.1.1/go.mod h1:GBR0iDaNXjAgGg9zfCvksxSRnQx76gclCIb7kdAd1Pw=\ngolang.org/x/sys v0.0.0-20190204203706-41f3e6584952/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\n"
        },
        {
          "name": "hll.go",
          "type": "blob",
          "size": 0.8310546875,
          "content": "package miniredis\n\nimport (\n\t\"github.com/alicebob/miniredis/v2/hyperloglog\"\n)\n\ntype hll struct {\n\tinner *hyperloglog.Sketch\n}\n\nfunc newHll() *hll {\n\treturn &hll{\n\t\tinner: hyperloglog.New14(),\n\t}\n}\n\n// Add returns true if cardinality has been changed, or false otherwise.\nfunc (h *hll) Add(item []byte) bool {\n\treturn h.inner.Insert(item)\n}\n\n// Count returns the estimation of a set cardinality.\nfunc (h *hll) Count() int {\n\treturn int(h.inner.Estimate())\n}\n\n// Merge merges the other hll into original one (not making a copy but doing this in place).\nfunc (h *hll) Merge(other *hll) {\n\t_ = h.inner.Merge(other.inner)\n}\n\n// Bytes returns raw-bytes representation of hll data structure.\nfunc (h *hll) Bytes() []byte {\n\tdataBytes, _ := h.inner.MarshalBinary()\n\treturn dataBytes\n}\n\nfunc (h *hll) copy() *hll {\n\treturn &hll{\n\t\tinner: h.inner.Clone(),\n\t}\n}\n"
        },
        {
          "name": "hyperloglog",
          "type": "tree",
          "content": null
        },
        {
          "name": "integration",
          "type": "tree",
          "content": null
        },
        {
          "name": "keys.go",
          "type": "blob",
          "size": 1.7373046875,
          "content": "package miniredis\n\n// Translate the 'KEYS' or 'PSUBSCRIBE' argument ('foo*', 'f??', &c.) into a regexp.\n\nimport (\n\t\"bytes\"\n\t\"regexp\"\n)\n\n// patternRE compiles a glob to a regexp. Returns nil if the given\n// pattern will never match anything.\n// The general strategy is to sandwich all non-meta characters between \\Q...\\E.\nfunc patternRE(k string) *regexp.Regexp {\n\tre := bytes.Buffer{}\n\tre.WriteString(`(?s)^\\Q`)\n\tfor i := 0; i < len(k); i++ {\n\t\tp := k[i]\n\t\tswitch p {\n\t\tcase '*':\n\t\t\tre.WriteString(`\\E.*\\Q`)\n\t\tcase '?':\n\t\t\tre.WriteString(`\\E.\\Q`)\n\t\tcase '[':\n\t\t\tcharClass := bytes.Buffer{}\n\t\t\ti++\n\t\t\tfor ; i < len(k); i++ {\n\t\t\t\tif k[i] == ']' {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tif k[i] == '\\\\' {\n\t\t\t\t\tif i == len(k)-1 {\n\t\t\t\t\t\t// Ends with a '\\'. U-huh.\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t}\n\t\t\t\t\tcharClass.WriteByte(k[i])\n\t\t\t\t\ti++\n\t\t\t\t\tcharClass.WriteByte(k[i])\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tcharClass.WriteByte(k[i])\n\t\t\t}\n\t\t\tif charClass.Len() == 0 {\n\t\t\t\t// '[]' is valid in Redis, but matches nothing.\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tre.WriteString(`\\E[`)\n\t\t\tre.Write(charClass.Bytes())\n\t\t\tre.WriteString(`]\\Q`)\n\n\t\tcase '\\\\':\n\t\t\tif i == len(k)-1 {\n\t\t\t\t// Ends with a '\\'. U-huh.\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\t// Forget the \\, keep the next char.\n\t\t\ti++\n\t\t\tre.WriteByte(k[i])\n\t\t\tcontinue\n\t\tdefault:\n\t\t\tre.WriteByte(p)\n\t\t}\n\t}\n\tre.WriteString(`\\E$`)\n\treturn regexp.MustCompile(re.String())\n}\n\n// matchKeys filters only matching keys.\n// The returned boolean is whether the match pattern was valid\nfunc matchKeys(keys []string, match string) ([]string, bool) {\n\tre := patternRE(match)\n\tif re == nil {\n\t\t// Special case: the given pattern won't match anything or is invalid.\n\t\treturn nil, false\n\t}\n\tvar res []string\n\tfor _, k := range keys {\n\t\tif !re.MatchString(k) {\n\t\t\tcontinue\n\t\t}\n\t\tres = append(res, k)\n\t}\n\treturn res, true\n}\n"
        },
        {
          "name": "keys_test.go",
          "type": "blob",
          "size": 2.9091796875,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n)\n\nfunc TestKeysSel(t *testing.T) {\n\t// Helper to test the selection behind KEYS\n\t// pattern -> cases -> should match?\n\ttest := func(pat string, chk map[string]bool) {\n\t\tt.Helper()\n\t\tpatRe := patternRE(pat)\n\t\tif patRe == nil {\n\t\t\tt.Errorf(\"'%v' won't match anything. Didn't expect that.\", pat)\n\t\t\treturn\n\t\t}\n\t\tfor key, expected := range chk {\n\t\t\tmatch := patRe.MatchString(key)\n\t\t\tif have, want := match, expected; have != want {\n\t\t\t\tt.Errorf(\"'%v' -> '%v'. have %v, want %v\", pat, key, have, want)\n\t\t\t}\n\t\t}\n\t}\n\ttest(\"aap\", map[string]bool{\n\t\t\"aap\":         true,\n\t\t\"aapnoot\":     false,\n\t\t\"nootaap\":     false,\n\t\t\"nootaapnoot\": false,\n\t\t\"AAP\":         false,\n\t})\n\ttest(\"aap*\", map[string]bool{\n\t\t\"aap\":         true,\n\t\t\"aapnoot\":     true,\n\t\t\"nootaap\":     false,\n\t\t\"nootaapnoot\": false,\n\t\t\"AAP\":         false,\n\t})\n\t// No problem with regexp meta chars?\n\ttest(\"(?:a)ap*\", map[string]bool{\n\t\t\"(?:a)ap!\": true,\n\t\t\"aap\":      false,\n\t})\n\ttest(\"*aap*\", map[string]bool{\n\t\t\"aap\":         true,\n\t\t\"aapnoot\":     true,\n\t\t\"nootaap\":     true,\n\t\t\"nootaapnoot\": true,\n\t\t\"AAP\":         false,\n\t\t\"a_a_p\":       false,\n\t})\n\ttest(`\\*aap*`, map[string]bool{\n\t\t\"*aap\":     true,\n\t\t\"aap\":      false,\n\t\t\"*aapnoot\": true,\n\t\t\"aapnoot\":  false,\n\t})\n\ttest(`aa?`, map[string]bool{\n\t\t\"aap\":  true,\n\t\t\"aal\":  true,\n\t\t\"aaf\":  true,\n\t\t\"aa?\":  true,\n\t\t\"aap!\": false,\n\t})\n\ttest(`aa\\?`, map[string]bool{\n\t\t\"aap\":  false,\n\t\t\"aa?\":  true,\n\t\t\"aa?!\": false,\n\t})\n\ttest(\"aa[pl]\", map[string]bool{\n\t\t\"aap\":  true,\n\t\t\"aal\":  true,\n\t\t\"aaf\":  false,\n\t\t\"aa?\":  false,\n\t\t\"aap!\": false,\n\t})\n\ttest(\"[ab]a[pl]\", map[string]bool{\n\t\t\"aap\":  true,\n\t\t\"aal\":  true,\n\t\t\"bap\":  true,\n\t\t\"bal\":  true,\n\t\t\"aaf\":  false,\n\t\t\"cap\":  false,\n\t\t\"aa?\":  false,\n\t\t\"aap!\": false,\n\t})\n\ttest(`\\[ab\\]`, map[string]bool{\n\t\t\"[ab]\": true,\n\t\t\"a\":    false,\n\t})\n\ttest(`[\\[ab]`, map[string]bool{\n\t\t\"[\": true,\n\t\t\"a\": true,\n\t\t\"b\": true,\n\t\t\"c\": false,\n\t\t\"]\": false,\n\t})\n\ttest(`[\\[\\]]`, map[string]bool{\n\t\t\"[\": true,\n\t\t\"]\": true,\n\t\t\"c\": false,\n\t})\n\ttest(`\\\\ap`, map[string]bool{\n\t\t`\\ap`:  true,\n\t\t`\\\\ap`: false,\n\t})\n\t// Escape a normal char\n\ttest(`\\foo`, map[string]bool{\n\t\t`foo`:  true,\n\t\t`\\foo`: false,\n\t})\n\n\t// Patterns which won't match anything.\n\ttest2 := func(pat string) {\n\t\tt.Helper()\n\t\tif patternRE(pat) != nil {\n\t\t\tt.Errorf(\"'%v' will match something. Didn't expect that.\", pat)\n\t\t}\n\t}\n\ttest2(`ap[\\`) // trailing \\ in char class\n\ttest2(`ap[`)  // open char class\n\ttest2(`[]ap`) // empty char class\n\ttest2(`ap\\`)  // trailing \\\n}\n\nfunc TestMatchKeys(t *testing.T) {\n\tt.Run(\"simple\", func(t *testing.T) {\n\t\tm, ok := matchKeys([]string{\"a\", \"b\", \"c\"}, \"*\")\n\t\tequals(t, true, ok)\n\t\tequals(t, []string{\"a\", \"b\", \"c\"}, m)\n\t})\n\n\tt.Run(\"newlines\", func(t *testing.T) {\n\t\tm, ok := matchKeys([]string{\"a\", \"b\\nb\", \"c\"}, \"*\")\n\t\tequals(t, true, ok)\n\t\tequals(t, []string{\"a\", \"b\\nb\", \"c\"}, m)\n\t})\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\t_, ok := matchKeys([]string{\"a\", \"b\", \"c\"}, \"[\")\n\t\tequals(t, false, ok)\n\t})\n}\n"
        },
        {
          "name": "lua.go",
          "type": "blob",
          "size": 5.931640625,
          "content": "package miniredis\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\n\tlua \"github.com/yuin/gopher-lua\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nvar luaRedisConstants = map[string]lua.LValue{\n\t\"LOG_DEBUG\":   lua.LNumber(0),\n\t\"LOG_VERBOSE\": lua.LNumber(1),\n\t\"LOG_NOTICE\":  lua.LNumber(2),\n\t\"LOG_WARNING\": lua.LNumber(3),\n}\n\nfunc mkLua(srv *server.Server, c *server.Peer, sha string) (map[string]lua.LGFunction, map[string]lua.LValue) {\n\tmkCall := func(failFast bool) func(l *lua.LState) int {\n\t\t// one server.Ctx for a single Lua run\n\t\tpCtx := &connCtx{}\n\t\tif getCtx(c).authenticated {\n\t\t\tpCtx.authenticated = true\n\t\t}\n\t\tpCtx.nested = true\n\t\tpCtx.nestedSHA = sha\n\t\tpCtx.selectedDB = getCtx(c).selectedDB\n\n\t\treturn func(l *lua.LState) int {\n\t\t\ttop := l.GetTop()\n\t\t\tif top == 0 {\n\t\t\t\tl.Error(lua.LString(fmt.Sprintf(\"Please specify at least one argument for this redis lib call script: %s, &c.\", sha)), 1)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tvar args []string\n\t\t\tfor i := 1; i <= top; i++ {\n\t\t\t\tswitch a := l.Get(i).(type) {\n\t\t\t\tcase lua.LNumber:\n\t\t\t\t\targs = append(args, a.String())\n\t\t\t\tcase lua.LString:\n\t\t\t\t\targs = append(args, string(a))\n\t\t\t\tdefault:\n\t\t\t\t\tl.Error(lua.LString(fmt.Sprintf(\"Lua redis lib command arguments must be strings or integers script: %s, &c.\", sha)), 1)\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(args) == 0 {\n\t\t\t\tl.Error(lua.LString(msgNotFromScripts(sha)), 1)\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tbuf := &bytes.Buffer{}\n\t\t\twr := bufio.NewWriter(buf)\n\t\t\tpeer := server.NewPeer(wr)\n\t\t\tpeer.Ctx = pCtx\n\t\t\tsrv.Dispatch(peer, args)\n\t\t\twr.Flush()\n\n\t\t\tres, err := server.ParseReply(bufio.NewReader(buf))\n\t\t\tif err != nil {\n\t\t\t\tif failFast {\n\t\t\t\t\t// call() mode\n\t\t\t\t\tif strings.Contains(err.Error(), \"ERR unknown command\") {\n\t\t\t\t\t\tl.Error(lua.LString(fmt.Sprintf(\"Unknown Redis command called from script script: %s, &c.\", sha)), 1)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tl.Error(lua.LString(err.Error()), 1)\n\t\t\t\t\t}\n\t\t\t\t\treturn 0\n\t\t\t\t}\n\t\t\t\t// pcall() mode\n\t\t\t\tl.Push(lua.LNil)\n\t\t\t\treturn 1\n\t\t\t}\n\n\t\t\tif res == nil {\n\t\t\t\tl.Push(lua.LFalse)\n\t\t\t} else {\n\t\t\t\tswitch r := res.(type) {\n\t\t\t\tcase int64:\n\t\t\t\t\tl.Push(lua.LNumber(r))\n\t\t\t\tcase int:\n\t\t\t\t\tl.Push(lua.LNumber(r))\n\t\t\t\tcase []uint8:\n\t\t\t\t\tl.Push(lua.LString(string(r)))\n\t\t\t\tcase []interface{}:\n\t\t\t\t\tl.Push(redisToLua(l, r))\n\t\t\t\tcase server.Simple:\n\t\t\t\t\tl.Push(luaStatusReply(string(r)))\n\t\t\t\tcase string:\n\t\t\t\t\tl.Push(lua.LString(r))\n\t\t\t\tcase error:\n\t\t\t\t\tl.Error(lua.LString(r.Error()), 1)\n\t\t\t\t\treturn 0\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(fmt.Sprintf(\"type not handled (%T)\", r))\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 1\n\t\t}\n\t}\n\n\treturn map[string]lua.LGFunction{\n\t\t\"call\":  mkCall(true),\n\t\t\"pcall\": mkCall(false),\n\t\t\"error_reply\": func(l *lua.LState) int {\n\t\t\tv := l.Get(1)\n\t\t\tmsg, ok := v.(lua.LString)\n\t\t\tif !ok {\n\t\t\t\tl.Error(lua.LString(\"wrong number or type of arguments\"), 1)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tres := &lua.LTable{}\n\t\t\tparts := strings.SplitN(msg.String(), \" \", 2)\n\t\t\t// '-' at the beginging will be added as a part of error response\n\t\t\tif parts[0] != \"\" && parts[0][0] == '-' {\n\t\t\t\tparts[0] = parts[0][1:]\n\t\t\t}\n\t\t\tvar final_msg string\n\t\t\tif len(parts) == 2 {\n\t\t\t\tfinal_msg = fmt.Sprintf(\"%s %s\", parts[0], parts[1])\n\t\t\t} else {\n\t\t\t\tfinal_msg = fmt.Sprintf(\"ERR %s\", parts[0])\n\t\t\t}\n\t\t\tres.RawSetString(\"err\", lua.LString(final_msg))\n\t\t\tl.Push(res)\n\t\t\treturn 1\n\t\t},\n\t\t\"log\": func(l *lua.LState) int {\n\t\t\tlevel := l.CheckInt(1)\n\t\t\tmsg := l.CheckString(2)\n\t\t\t_, _ = level, msg\n\t\t\t// do nothing by default. To see logs uncomment:\n\t\t\t//   fmt.Printf(\"%v: %v\", level, msg)\n\t\t\treturn 0\n\t\t},\n\t\t\"status_reply\": func(l *lua.LState) int {\n\t\t\tv := l.Get(1)\n\t\t\tmsg, ok := v.(lua.LString)\n\t\t\tif !ok {\n\t\t\t\tl.Error(lua.LString(\"wrong number or type of arguments\"), 1)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tres := luaStatusReply(string(msg))\n\t\t\tl.Push(res)\n\t\t\treturn 1\n\t\t},\n\t\t\"sha1hex\": func(l *lua.LState) int {\n\t\t\ttop := l.GetTop()\n\t\t\tif top != 1 {\n\t\t\t\tl.Error(lua.LString(\"wrong number of arguments\"), 1)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tmsg := lua.LVAsString(l.Get(1))\n\t\t\tl.Push(lua.LString(sha1Hex(msg)))\n\t\t\treturn 1\n\t\t},\n\t\t\"replicate_commands\": func(l *lua.LState) int {\n\t\t\t// ignored\n\t\t\treturn 1\n\t\t},\n\t\t\"set_repl\": func(l *lua.LState) int {\n\t\t\ttop := l.GetTop()\n\t\t\tif top != 1 {\n\t\t\t\tl.Error(lua.LString(\"wrong number of arguments\"), 1)\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\t// ignored\n\t\t\treturn 1\n\t\t},\n\t}, luaRedisConstants\n}\n\nfunc luaToRedis(l *lua.LState, c *server.Peer, value lua.LValue) {\n\tif value == nil {\n\t\tc.WriteNull()\n\t\treturn\n\t}\n\n\tswitch t := value.(type) {\n\tcase *lua.LNilType:\n\t\tc.WriteNull()\n\tcase lua.LBool:\n\t\tif lua.LVAsBool(value) {\n\t\t\tc.WriteInt(1)\n\t\t} else {\n\t\t\tc.WriteNull()\n\t\t}\n\tcase lua.LNumber:\n\t\tc.WriteInt(int(lua.LVAsNumber(value)))\n\tcase lua.LString:\n\t\ts := lua.LVAsString(value)\n\t\tc.WriteBulk(s)\n\tcase *lua.LTable:\n\t\t// special case for tables with an 'err' or 'ok' field\n\t\t// note: according to the docs this only counts when 'err' or 'ok' is\n\t\t// the only field.\n\t\tif s := t.RawGetString(\"err\"); s.Type() != lua.LTNil {\n\t\t\tc.WriteError(s.String())\n\t\t\treturn\n\t\t}\n\t\tif s := t.RawGetString(\"ok\"); s.Type() != lua.LTNil {\n\t\t\tc.WriteInline(s.String())\n\t\t\treturn\n\t\t}\n\n\t\tresult := []lua.LValue{}\n\t\tfor j := 1; true; j++ {\n\t\t\tval := l.GetTable(value, lua.LNumber(j))\n\t\t\tif val == nil {\n\t\t\t\tresult = append(result, val)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif val.Type() == lua.LTNil {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tresult = append(result, val)\n\t\t}\n\n\t\tc.WriteLen(len(result))\n\t\tfor _, r := range result {\n\t\t\tluaToRedis(l, c, r)\n\t\t}\n\tdefault:\n\t\tpanic(\"....\")\n\t}\n}\n\nfunc redisToLua(l *lua.LState, res []interface{}) *lua.LTable {\n\trettb := l.NewTable()\n\tfor _, e := range res {\n\t\tvar v lua.LValue\n\t\tif e == nil {\n\t\t\tv = lua.LFalse\n\t\t} else {\n\t\t\tswitch et := e.(type) {\n\t\t\tcase int:\n\t\t\t\tv = lua.LNumber(et)\n\t\t\tcase int64:\n\t\t\t\tv = lua.LNumber(et)\n\t\t\tcase []uint8:\n\t\t\t\tv = lua.LString(string(et))\n\t\t\tcase []interface{}:\n\t\t\t\tv = redisToLua(l, et)\n\t\t\tcase string:\n\t\t\t\tv = lua.LString(et)\n\t\t\tdefault:\n\t\t\t\t// TODO: oops?\n\t\t\t\tv = lua.LString(e.(string))\n\t\t\t}\n\t\t}\n\t\tl.RawSet(rettb, lua.LNumber(rettb.Len()+1), v)\n\t}\n\treturn rettb\n}\n\nfunc luaStatusReply(msg string) *lua.LTable {\n\ttab := &lua.LTable{}\n\ttab.RawSetString(\"ok\", lua.LString(msg))\n\treturn tab\n}\n"
        },
        {
          "name": "metro",
          "type": "tree",
          "content": null
        },
        {
          "name": "miniredis.go",
          "type": "blob",
          "size": 17.72265625,
          "content": "// Package miniredis is a pure Go Redis test server, for use in Go unittests.\n// There are no dependencies on system binaries, and every server you start\n// will be empty.\n//\n// import \"github.com/alicebob/miniredis/v2\"\n//\n// Start a server with `s := miniredis.RunT(t)`, it'll be shutdown via a t.Cleanup().\n// Or do everything manual: `s, err := miniredis.Run(); defer s.Close()`\n//\n// Point your Redis client to `s.Addr()` or `s.Host(), s.Port()`.\n//\n// Set keys directly via s.Set(...) and similar commands, or use a Redis client.\n//\n// For direct use you can select a Redis database with either `s.Select(12);\n// s.Get(\"foo\")` or `s.DB(12).Get(\"foo\")`.\npackage miniredis\n\nimport (\n\t\"context\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nvar DumpMaxLineLen = 60\n\ntype hashKey map[string]string\ntype listKey []string\ntype setKey map[string]struct{}\n\n// RedisDB holds a single (numbered) Redis database.\ntype RedisDB struct {\n\tmaster        *Miniredis               // pointer to the lock in Miniredis\n\tid            int                      // db id\n\tkeys          map[string]string        // Master map of keys with their type\n\tstringKeys    map[string]string        // GET/SET &c. keys\n\thashKeys      map[string]hashKey       // MGET/MSET &c. keys\n\tlistKeys      map[string]listKey       // LPUSH &c. keys\n\tsetKeys       map[string]setKey        // SADD &c. keys\n\thllKeys       map[string]*hll          // PFADD &c. keys\n\tsortedsetKeys map[string]sortedSet     // ZADD &c. keys\n\tstreamKeys    map[string]*streamKey    // XADD &c. keys\n\tttl           map[string]time.Duration // effective TTL values\n\tlru           map[string]time.Time     // last recently used ( read or written to )\n\tkeyVersion    map[string]uint          // used to watch values\n}\n\n// Miniredis is a Redis server implementation.\ntype Miniredis struct {\n\tsync.Mutex\n\tsrv         *server.Server\n\tport        int\n\tpasswords   map[string]string // username password\n\tdbs         map[int]*RedisDB\n\tselectedDB  int               // DB id used in the direct Get(), Set() &c.\n\tscripts     map[string]string // sha1 -> lua src\n\tsignal      *sync.Cond\n\tnow         time.Time // time.Now() if not set.\n\tsubscribers map[*Subscriber]struct{}\n\trand        *rand.Rand\n\tCtx         context.Context\n\tCtxCancel   context.CancelFunc\n}\n\ntype txCmd func(*server.Peer, *connCtx)\n\n// database id + key combo\ntype dbKey struct {\n\tdb  int\n\tkey string\n}\n\n// connCtx has all state for a single connection.\n// (this struct was named before context.Context existed)\ntype connCtx struct {\n\tselectedDB       int            // selected DB\n\tauthenticated    bool           // auth enabled and a valid AUTH seen\n\ttransaction      []txCmd        // transaction callbacks. Or nil.\n\tdirtyTransaction bool           // any error during QUEUEing\n\twatch            map[dbKey]uint // WATCHed keys\n\tsubscriber       *Subscriber    // client is in PUBSUB mode if not nil\n\tnested           bool           // this is called via Lua\n\tnestedSHA        string         // set to the SHA of the nesting function\n}\n\n// NewMiniRedis makes a new, non-started, Miniredis object.\nfunc NewMiniRedis() *Miniredis {\n\tm := Miniredis{\n\t\tdbs:         map[int]*RedisDB{},\n\t\tscripts:     map[string]string{},\n\t\tsubscribers: map[*Subscriber]struct{}{},\n\t}\n\tm.Ctx, m.CtxCancel = context.WithCancel(context.Background())\n\tm.signal = sync.NewCond(&m)\n\treturn &m\n}\n\nfunc newRedisDB(id int, m *Miniredis) RedisDB {\n\treturn RedisDB{\n\t\tid:            id,\n\t\tmaster:        m,\n\t\tkeys:          map[string]string{},\n\t\tlru:           map[string]time.Time{},\n\t\tstringKeys:    map[string]string{},\n\t\thashKeys:      map[string]hashKey{},\n\t\tlistKeys:      map[string]listKey{},\n\t\tsetKeys:       map[string]setKey{},\n\t\thllKeys:       map[string]*hll{},\n\t\tsortedsetKeys: map[string]sortedSet{},\n\t\tstreamKeys:    map[string]*streamKey{},\n\t\tttl:           map[string]time.Duration{},\n\t\tkeyVersion:    map[string]uint{},\n\t}\n}\n\n// Run creates and Start()s a Miniredis.\nfunc Run() (*Miniredis, error) {\n\tm := NewMiniRedis()\n\treturn m, m.Start()\n}\n\n// Run creates and Start()s a Miniredis, TLS version.\nfunc RunTLS(cfg *tls.Config) (*Miniredis, error) {\n\tm := NewMiniRedis()\n\treturn m, m.StartTLS(cfg)\n}\n\n// Tester is a minimal version of a testing.T\ntype Tester interface {\n\tFatalf(string, ...interface{})\n\tCleanup(func())\n\tLogf(format string, args ...interface{})\n}\n\n// RunT start a new miniredis, pass it a testing.T. It also registers the cleanup after your test is done.\nfunc RunT(t Tester) *Miniredis {\n\tm := NewMiniRedis()\n\tif err := m.Start(); err != nil {\n\t\tt.Fatalf(\"could not start miniredis: %s\", err)\n\t\t// not reached\n\t}\n\tt.Cleanup(m.Close)\n\treturn m\n}\n\nfunc runWithClient(t Tester) (*Miniredis, *proto.Client) {\n\tm := RunT(t)\n\n\tc, err := proto.Dial(m.Addr())\n\tif err != nil {\n\t\tt.Fatalf(\"could not connect to miniredis: %s\", err)\n\t}\n\tt.Cleanup(func() {\n\t\tif err = c.Close(); err != nil {\n\t\t\tt.Logf(\"error closing connection to miniredis: %s\", err)\n\t\t}\n\t})\n\n\treturn m, c\n}\n\n// Start starts a server. It listens on a random port on localhost. See also\n// Addr().\nfunc (m *Miniredis) Start() error {\n\ts, err := server.NewServer(fmt.Sprintf(\"127.0.0.1:%d\", m.port))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn m.start(s)\n}\n\n// Start starts a server, TLS version.\nfunc (m *Miniredis) StartTLS(cfg *tls.Config) error {\n\ts, err := server.NewServerTLS(fmt.Sprintf(\"127.0.0.1:%d\", m.port), cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn m.start(s)\n}\n\n// StartAddr runs miniredis with a given addr. Examples: \"127.0.0.1:6379\",\n// \":6379\", or \"127.0.0.1:0\"\nfunc (m *Miniredis) StartAddr(addr string) error {\n\ts, err := server.NewServer(addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn m.start(s)\n}\n\n// StartAddrTLS runs miniredis with a given addr, TLS version.\nfunc (m *Miniredis) StartAddrTLS(addr string, cfg *tls.Config) error {\n\ts, err := server.NewServerTLS(addr, cfg)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn m.start(s)\n}\n\nfunc (m *Miniredis) start(s *server.Server) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.srv = s\n\tm.port = s.Addr().Port\n\n\tcommandsConnection(m)\n\tcommandsGeneric(m)\n\tcommandsServer(m)\n\tcommandsString(m)\n\tcommandsHash(m)\n\tcommandsList(m)\n\tcommandsPubsub(m)\n\tcommandsSet(m)\n\tcommandsSortedSet(m)\n\tcommandsStream(m)\n\tcommandsTransaction(m)\n\tcommandsScripting(m)\n\tcommandsGeo(m)\n\tcommandsCluster(m)\n\tcommandsHll(m)\n\tcommandsClient(m)\n\tcommandsObject(m)\n\n\treturn nil\n}\n\n// Restart restarts a Close()d server on the same port. Values will be\n// preserved.\nfunc (m *Miniredis) Restart() error {\n\treturn m.Start()\n}\n\n// Close shuts down a Miniredis.\nfunc (m *Miniredis) Close() {\n\tm.Lock()\n\n\tif m.srv == nil {\n\t\tm.Unlock()\n\t\treturn\n\t}\n\tsrv := m.srv\n\tm.srv = nil\n\tm.CtxCancel()\n\tm.Unlock()\n\n\t// the OnDisconnect callbacks can lock m, so run Close() outside the lock.\n\tsrv.Close()\n\n}\n\n// RequireAuth makes every connection need to AUTH first. This is the old 'AUTH [password] command.\n// Remove it by setting an empty string.\nfunc (m *Miniredis) RequireAuth(pw string) {\n\tm.RequireUserAuth(\"default\", pw)\n}\n\n// Add a username/password, for use with 'AUTH [username] [password]'.\n// There are currently no access controls for commands implemented.\n// Disable access for the user with an empty password.\nfunc (m *Miniredis) RequireUserAuth(username, pw string) {\n\tm.Lock()\n\tdefer m.Unlock()\n\tif m.passwords == nil {\n\t\tm.passwords = map[string]string{}\n\t}\n\tif pw == \"\" {\n\t\tdelete(m.passwords, username)\n\t\treturn\n\t}\n\tm.passwords[username] = pw\n}\n\n// DB returns a DB by ID.\nfunc (m *Miniredis) DB(i int) *RedisDB {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn m.db(i)\n}\n\n// get DB. No locks!\nfunc (m *Miniredis) db(i int) *RedisDB {\n\tif db, ok := m.dbs[i]; ok {\n\t\treturn db\n\t}\n\tdb := newRedisDB(i, m) // main miniredis has our mutex.\n\tm.dbs[i] = &db\n\treturn &db\n}\n\n// SwapDB swaps DBs by IDs.\nfunc (m *Miniredis) SwapDB(i, j int) bool {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn m.swapDB(i, j)\n}\n\n// swap DB. No locks!\nfunc (m *Miniredis) swapDB(i, j int) bool {\n\tdb1 := m.db(i)\n\tdb2 := m.db(j)\n\n\tdb1.id = j\n\tdb2.id = i\n\n\tm.dbs[i] = db2\n\tm.dbs[j] = db1\n\n\treturn true\n}\n\n// Addr returns '127.0.0.1:12345'. Can be given to a Dial(). See also Host()\n// and Port(), which return the same things.\nfunc (m *Miniredis) Addr() string {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn m.srv.Addr().String()\n}\n\n// Host returns the host part of Addr().\nfunc (m *Miniredis) Host() string {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn m.srv.Addr().IP.String()\n}\n\n// Port returns the (random) port part of Addr().\nfunc (m *Miniredis) Port() string {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn strconv.Itoa(m.srv.Addr().Port)\n}\n\n// CommandCount returns the number of processed commands.\nfunc (m *Miniredis) CommandCount() int {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn int(m.srv.TotalCommands())\n}\n\n// CurrentConnectionCount returns the number of currently connected clients.\nfunc (m *Miniredis) CurrentConnectionCount() int {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn m.srv.ClientsLen()\n}\n\n// TotalConnectionCount returns the number of client connections since server start.\nfunc (m *Miniredis) TotalConnectionCount() int {\n\tm.Lock()\n\tdefer m.Unlock()\n\treturn int(m.srv.TotalConnections())\n}\n\n// FastForward decreases all TTLs by the given duration. All TTLs <= 0 will be\n// expired.\nfunc (m *Miniredis) FastForward(duration time.Duration) {\n\tm.Lock()\n\tdefer m.Unlock()\n\tfor _, db := range m.dbs {\n\t\tdb.fastForward(duration)\n\t}\n}\n\n// Server returns the underlying server to allow custom commands to be implemented\nfunc (m *Miniredis) Server() *server.Server {\n\treturn m.srv\n}\n\n// Dump returns a text version of the selected DB, usable for debugging.\n//\n// Dump limits the maximum length of each key:value to \"DumpMaxLineLen\" characters.\n// To increase that, call something like:\n//\n//\tminiredis.DumpMaxLineLen = 1024\n//\tmr, _ = miniredis.Run()\n//\tmr.Dump()\nfunc (m *Miniredis) Dump() string {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tvar (\n\t\tmaxLen = DumpMaxLineLen\n\t\tindent = \"   \"\n\t\tdb     = m.db(m.selectedDB)\n\t\tr      = \"\"\n\t\tv      = func(s string) string {\n\t\t\tsuffix := \"\"\n\t\t\tif len(s) > maxLen {\n\t\t\t\tsuffix = fmt.Sprintf(\"...(%d)\", len(s))\n\t\t\t\ts = s[:maxLen-len(suffix)]\n\t\t\t}\n\t\t\treturn fmt.Sprintf(\"%q%s\", s, suffix)\n\t\t}\n\t)\n\n\tfor _, k := range db.allKeys() {\n\t\tr += fmt.Sprintf(\"- %s\\n\", k)\n\t\tt := db.t(k)\n\t\tswitch t {\n\t\tcase \"string\":\n\t\t\tr += fmt.Sprintf(\"%s%s\\n\", indent, v(db.stringKeys[k]))\n\t\tcase \"hash\":\n\t\t\tfor _, hk := range db.hashFields(k) {\n\t\t\t\tr += fmt.Sprintf(\"%s%s: %s\\n\", indent, hk, v(db.hashGet(k, hk)))\n\t\t\t}\n\t\tcase \"list\":\n\t\t\tfor _, lk := range db.listKeys[k] {\n\t\t\t\tr += fmt.Sprintf(\"%s%s\\n\", indent, v(lk))\n\t\t\t}\n\t\tcase \"set\":\n\t\t\tfor _, mk := range db.setMembers(k) {\n\t\t\t\tr += fmt.Sprintf(\"%s%s\\n\", indent, v(mk))\n\t\t\t}\n\t\tcase \"zset\":\n\t\t\tfor _, el := range db.ssetElements(k) {\n\t\t\t\tr += fmt.Sprintf(\"%s%f: %s\\n\", indent, el.score, v(el.member))\n\t\t\t}\n\t\tcase \"stream\":\n\t\t\tfor _, entry := range db.streamKeys[k].entries {\n\t\t\t\tr += fmt.Sprintf(\"%s%s\\n\", indent, entry.ID)\n\t\t\t\tev := entry.Values\n\t\t\t\tfor i := 0; i < len(ev)/2; i++ {\n\t\t\t\t\tr += fmt.Sprintf(\"%s%s%s: %s\\n\", indent, indent, v(ev[2*i]), v(ev[2*i+1]))\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"hll\":\n\t\t\tfor _, entry := range db.hllKeys {\n\t\t\t\tr += fmt.Sprintf(\"%s%s\\n\", indent, v(string(entry.Bytes())))\n\t\t\t}\n\t\tdefault:\n\t\t\tr += fmt.Sprintf(\"%s(a %s, fixme!)\\n\", indent, t)\n\t\t}\n\t}\n\treturn r\n}\n\n// SetTime sets the time against which EXPIREAT values are compared, and the\n// time used in stream entry IDs.  Will use time.Now() if this is not set.\nfunc (m *Miniredis) SetTime(t time.Time) {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.now = t\n}\n\n// make every command return this message. For example:\n//\n//\tLOADING Redis is loading the dataset in memory\n//\tMASTERDOWN Link with MASTER is down and replica-serve-stale-data is set to 'no'.\n//\n// Clear it with an empty string. Don't add newlines.\nfunc (m *Miniredis) SetError(msg string) {\n\tcb := server.Hook(nil)\n\tif msg != \"\" {\n\t\tcb = func(c *server.Peer, cmd string, args ...string) bool {\n\t\t\tc.WriteError(msg)\n\t\t\treturn true\n\t\t}\n\t}\n\tm.srv.SetPreHook(cb)\n}\n\n// isValidCMD returns true if command is valid and can be executed.\nfunc (m *Miniredis) isValidCMD(c *server.Peer, cmd string) bool {\n\tif !m.handleAuth(c) {\n\t\treturn false\n\t}\n\tif m.checkPubsub(c, cmd) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n\n// handleAuth returns false if connection has no access. It sends the reply.\nfunc (m *Miniredis) handleAuth(c *server.Peer) bool {\n\tif getCtx(c).nested {\n\t\treturn true\n\t}\n\n\tm.Lock()\n\tdefer m.Unlock()\n\tif len(m.passwords) == 0 {\n\t\treturn true\n\t}\n\tif !getCtx(c).authenticated {\n\t\tc.WriteError(\"NOAUTH Authentication required.\")\n\t\treturn false\n\t}\n\treturn true\n}\n\n// handlePubsub sends an error to the user if the connection is in PUBSUB mode.\n// It'll return true if it did.\nfunc (m *Miniredis) checkPubsub(c *server.Peer, cmd string) bool {\n\tif getCtx(c).nested {\n\t\treturn false\n\t}\n\n\tm.Lock()\n\tdefer m.Unlock()\n\n\tctx := getCtx(c)\n\tif ctx.subscriber == nil {\n\t\treturn false\n\t}\n\n\tprefix := \"ERR \"\n\tif strings.ToLower(cmd) == \"exec\" {\n\t\tprefix = \"EXECABORT Transaction discarded because of: \"\n\t}\n\tc.WriteError(fmt.Sprintf(\n\t\t\"%sCan't execute '%s': only (P)SUBSCRIBE / (P)UNSUBSCRIBE / PING / QUIT are allowed in this context\",\n\t\tprefix,\n\t\tstrings.ToLower(cmd),\n\t))\n\treturn true\n}\n\nfunc getCtx(c *server.Peer) *connCtx {\n\tif c.Ctx == nil {\n\t\tc.Ctx = &connCtx{}\n\t}\n\treturn c.Ctx.(*connCtx)\n}\n\nfunc startTx(ctx *connCtx) {\n\tctx.transaction = []txCmd{}\n\tctx.dirtyTransaction = false\n}\n\nfunc stopTx(ctx *connCtx) {\n\tctx.transaction = nil\n\tunwatch(ctx)\n}\n\nfunc inTx(ctx *connCtx) bool {\n\treturn ctx.transaction != nil\n}\n\nfunc addTxCmd(ctx *connCtx, cb txCmd) {\n\tctx.transaction = append(ctx.transaction, cb)\n}\n\nfunc watch(db *RedisDB, ctx *connCtx, key string) {\n\tif ctx.watch == nil {\n\t\tctx.watch = map[dbKey]uint{}\n\t}\n\tctx.watch[dbKey{db: db.id, key: key}] = db.keyVersion[key] // Can be 0.\n}\n\nfunc unwatch(ctx *connCtx) {\n\tctx.watch = nil\n}\n\n// setDirty can be called even when not in an tx. Is an no-op then.\nfunc setDirty(c *server.Peer) {\n\tif c.Ctx == nil {\n\t\t// No transaction. Not relevant.\n\t\treturn\n\t}\n\tgetCtx(c).dirtyTransaction = true\n}\n\nfunc (m *Miniredis) addSubscriber(s *Subscriber) {\n\tm.subscribers[s] = struct{}{}\n}\n\n// closes and remove the subscriber.\nfunc (m *Miniredis) removeSubscriber(s *Subscriber) {\n\t_, ok := m.subscribers[s]\n\tdelete(m.subscribers, s)\n\tif ok {\n\t\ts.Close()\n\t}\n}\n\nfunc (m *Miniredis) publish(c, msg string) int {\n\tn := 0\n\tfor s := range m.subscribers {\n\t\tn += s.Publish(c, msg)\n\t}\n\treturn n\n}\n\n// enter 'subscribed state', or return the existing one.\nfunc (m *Miniredis) subscribedState(c *server.Peer) *Subscriber {\n\tctx := getCtx(c)\n\tsub := ctx.subscriber\n\tif sub != nil {\n\t\treturn sub\n\t}\n\n\tsub = newSubscriber()\n\tm.addSubscriber(sub)\n\n\tc.OnDisconnect(func() {\n\t\tm.Lock()\n\t\tm.removeSubscriber(sub)\n\t\tm.Unlock()\n\t})\n\n\tctx.subscriber = sub\n\n\tgo monitorPublish(c, sub.publish)\n\tgo monitorPpublish(c, sub.ppublish)\n\n\treturn sub\n}\n\n// whenever the p?sub count drops to 0 subscribed state should be stopped, and\n// all redis commands are allowed again.\nfunc endSubscriber(m *Miniredis, c *server.Peer) {\n\tctx := getCtx(c)\n\tif sub := ctx.subscriber; sub != nil {\n\t\tm.removeSubscriber(sub) // will Close() the sub\n\t}\n\tctx.subscriber = nil\n}\n\n// Start a new pubsub subscriber. It can (un) subscribe to channels and\n// patterns, and has a channel to get published messages. Close it with\n// Close().\n// Does not close itself when there are no subscriptions left.\nfunc (m *Miniredis) NewSubscriber() *Subscriber {\n\tsub := newSubscriber()\n\n\tm.Lock()\n\tm.addSubscriber(sub)\n\tm.Unlock()\n\n\treturn sub\n}\n\nfunc (m *Miniredis) allSubscribers() []*Subscriber {\n\tvar subs []*Subscriber\n\tfor s := range m.subscribers {\n\t\tsubs = append(subs, s)\n\t}\n\treturn subs\n}\n\nfunc (m *Miniredis) Seed(seed int) {\n\tm.Lock()\n\tdefer m.Unlock()\n\n\t// m.rand is not safe for concurrent use.\n\tm.rand = rand.New(rand.NewSource(int64(seed)))\n}\n\nfunc (m *Miniredis) randIntn(n int) int {\n\tif m.rand == nil {\n\t\treturn rand.Intn(n)\n\t}\n\treturn m.rand.Intn(n)\n}\n\n// shuffle shuffles a list of strings. Kinda.\nfunc (m *Miniredis) shuffle(l []string) {\n\tfor range l {\n\t\ti := m.randIntn(len(l))\n\t\tj := m.randIntn(len(l))\n\t\tl[i], l[j] = l[j], l[i]\n\t}\n}\n\nfunc (m *Miniredis) effectiveNow() time.Time {\n\tif !m.now.IsZero() {\n\t\treturn m.now\n\t}\n\treturn time.Now().UTC()\n}\n\n// convert a unixtimestamp to a duration, to use an absolute time as TTL.\n// d can be either time.Second or time.Millisecond.\nfunc (m *Miniredis) at(i int, d time.Duration) time.Duration {\n\tvar ts time.Time\n\tswitch d {\n\tcase time.Millisecond:\n\t\tts = time.Unix(int64(i/1000), 1000000*int64(i%1000))\n\tcase time.Second:\n\t\tts = time.Unix(int64(i), 0)\n\tdefault:\n\t\tpanic(\"invalid time unit (d). Fixme!\")\n\t}\n\tnow := m.effectiveNow()\n\treturn ts.Sub(now)\n}\n\n// copy does not mind if dst already exists.\nfunc (m *Miniredis) copy(\n\tsrcDB *RedisDB, src string,\n\tdestDB *RedisDB, dst string,\n) error {\n\tif !srcDB.exists(src) {\n\t\treturn ErrKeyNotFound\n\t}\n\n\tswitch srcDB.t(src) {\n\tcase \"string\":\n\t\tdestDB.stringKeys[dst] = srcDB.stringKeys[src]\n\tcase \"hash\":\n\t\tdestDB.hashKeys[dst] = copyHashKey(srcDB.hashKeys[src])\n\tcase \"list\":\n\t\tdestDB.listKeys[dst] = copyListKey(srcDB.listKeys[src])\n\tcase \"set\":\n\t\tdestDB.setKeys[dst] = copySetKey(srcDB.setKeys[src])\n\tcase \"zset\":\n\t\tdestDB.sortedsetKeys[dst] = copySortedSet(srcDB.sortedsetKeys[src])\n\tcase \"stream\":\n\t\tdestDB.streamKeys[dst] = srcDB.streamKeys[src].copy()\n\tcase \"hll\":\n\t\tdestDB.hllKeys[dst] = srcDB.hllKeys[src].copy()\n\tdefault:\n\t\tpanic(\"missing case\")\n\t}\n\tdestDB.keys[dst] = srcDB.keys[src]\n\tdestDB.incr(dst)\n\tif v, ok := srcDB.ttl[src]; ok {\n\t\tdestDB.ttl[dst] = v\n\t}\n\treturn nil\n}\n\nfunc copyHashKey(orig hashKey) hashKey {\n\tcpy := hashKey{}\n\tfor k, v := range orig {\n\t\tcpy[k] = v\n\t}\n\treturn cpy\n}\n\nfunc copyListKey(orig listKey) listKey {\n\tcpy := make(listKey, len(orig))\n\tcopy(cpy, orig)\n\treturn cpy\n}\n\nfunc copySetKey(orig setKey) setKey {\n\tcpy := setKey{}\n\tfor k, v := range orig {\n\t\tcpy[k] = v\n\t}\n\treturn cpy\n}\n\nfunc copySortedSet(orig sortedSet) sortedSet {\n\tcpy := sortedSet{}\n\tfor k, v := range orig {\n\t\tcpy[k] = v\n\t}\n\treturn cpy\n}\n"
        },
        {
          "name": "miniredis_test.go",
          "type": "blob",
          "size": 6.296875,
          "content": "package miniredis\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// Test starting/stopping a server\nfunc TestServer(t *testing.T) {\n\ts, c := runWithClient(t)\n\tmustDo(t, c, \"PING\", proto.Inline(\"PONG\"))\n\n\t// A single client\n\tequals(t, 1, s.CurrentConnectionCount())\n\tequals(t, 1, s.TotalConnectionCount())\n\tequals(t, 1, s.CommandCount())\n\tmustDo(t, c, \"PING\", proto.Inline(\"PONG\"))\n\tequals(t, 2, s.CommandCount())\n}\n\nfunc TestMultipleServers(t *testing.T) {\n\ts1 := RunT(t)\n\ts2 := RunT(t)\n\tif s1.Addr() == s2.Addr() {\n\t\tt.Fatal(\"Non-unique addresses\", s1.Addr(), s2.Addr())\n\t}\n\n\ts2.Close()\n\ts1.Close()\n\t// Closing multiple times is fine\n\tgo s1.Close()\n\tgo s1.Close()\n\ts1.Close()\n}\n\nfunc TestRestart(t *testing.T) {\n\ts := RunT(t)\n\taddr := s.Addr()\n\n\ts.Set(\"color\", \"red\")\n\n\ts.Close()\n\terr := s.Restart()\n\tok(t, err)\n\tif have, want := s.Addr(), addr; have != want {\n\t\tt.Fatalf(\"have: %s, want: %s\", have, want)\n\t}\n\n\tc, err := proto.Dial(s.Addr())\n\tok(t, err)\n\tdefer c.Close()\n\tmustDo(t, c, \"PING\", proto.Inline(\"PONG\"))\n\n\tmustDo(t, c,\n\t\t\"GET\", \"color\",\n\t\tproto.String(\"red\"),\n\t)\n}\n\n// Test a custom addr\nfunc TestAddr(t *testing.T) {\n\tm := NewMiniRedis()\n\terr := m.StartAddr(\"127.0.0.1:7887\")\n\tok(t, err)\n\tdefer m.Close()\n\n\tc, err := proto.Dial(\"127.0.0.1:7887\")\n\tok(t, err)\n\tdefer c.Close()\n\tmustDo(t, c, \"PING\", proto.Inline(\"PONG\"))\n}\n\nfunc TestDump(t *testing.T) {\n\ts := RunT(t)\n\ts.Set(\"aap\", \"noot\")\n\ts.Set(\"vuur\", \"mies\")\n\ts.HSet(\"ahash\", \"aap\", \"noot\")\n\ts.HSet(\"ahash\", \"vuur\", \"mies\")\n\tif have, want := s.Dump(), `- aap\n   \"noot\"\n- ahash\n   aap: \"noot\"\n   vuur: \"mies\"\n- vuur\n   \"mies\"\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n\n\t// Tricky whitespace\n\ts.Select(1)\n\ts.Set(\"whitespace\", \"foo\\nbar\\tbaz!\")\n\tif have, want := s.Dump(), `- whitespace\n   \"foo\\nbar\\tbaz!\"\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n\n\t// Long key\n\ts.Select(2)\n\ts.Set(\"long\", \"This is a rather long key, with some fox jumping over a fence or something.\")\n\ts.Set(\"countonme\", \"0123456789012345678901234567890123456789012345678901234567890123456789\")\n\ts.HSet(\"hlong\", \"long\", \"This is another rather long key, with some fox jumping over a fence or something.\")\n\tif have, want := s.Dump(), `- countonme\n   \"01234567890123456789012345678901234567890123456789012\"...(70)\n- hlong\n   long: \"This is another rather long key, with some fox jumpin\"...(81)\n- long\n   \"This is a rather long key, with some fox jumping over\"...(75)\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestDumpList(t *testing.T) {\n\ts := RunT(t)\n\ts.Push(\"elements\", \"earth\")\n\ts.Push(\"elements\", \"wind\")\n\ts.Push(\"elements\", \"fire\")\n\tif have, want := s.Dump(), `- elements\n   \"earth\"\n   \"wind\"\n   \"fire\"\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestDumpSet(t *testing.T) {\n\ts := RunT(t)\n\ts.SetAdd(\"elements\", \"earth\")\n\ts.SetAdd(\"elements\", \"wind\")\n\ts.SetAdd(\"elements\", \"fire\")\n\tif have, want := s.Dump(), `- elements\n   \"earth\"\n   \"fire\"\n   \"wind\"\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestDumpSortedSet(t *testing.T) {\n\ts := RunT(t)\n\ts.ZAdd(\"elements\", 2.0, \"wind\")\n\ts.ZAdd(\"elements\", 3.0, \"earth\")\n\ts.ZAdd(\"elements\", 1.0, \"fire\")\n\tif have, want := s.Dump(), `- elements\n   1.000000: \"fire\"\n   2.000000: \"wind\"\n   3.000000: \"earth\"\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestDumpStream(t *testing.T) {\n\ts := RunT(t)\n\ts.XAdd(\"elements\", \"0-1\", []string{\"name\", \"earth\"})\n\ts.XAdd(\"elements\", \"123456789-0\", []string{\"name\", \"wind\"})\n\ts.XAdd(\"elements\", \"123456789-1\", []string{\"name\", \"fire\"})\n\tif have, want := s.Dump(), `- elements\n   0-1\n      \"name\": \"earth\"\n   123456789-0\n      \"name\": \"wind\"\n   123456789-1\n      \"name\": \"fire\"\n`; have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n\n\ts.XAdd(\"elements\", \"*\", []string{\"name\", \"Leeloo\"})\n\tfullHave := s.Dump()\n\thave := strings.Split(fullHave, \"\\n\")[8]\n\twant := `      \"name\": \"Leeloo\"`\n\tif have != want {\n\t\tt.Errorf(\"have: %q, want: %q\", have, want)\n\t}\n}\n\nfunc TestKeysAndFlush(t *testing.T) {\n\ts := RunT(t)\n\ts.Set(\"aap\", \"noot\")\n\ts.Set(\"vuur\", \"mies\")\n\ts.Set(\"muur\", \"oom\")\n\ts.HSet(\"hash\", \"key\", \"value\")\n\tequals(t, []string{\"aap\", \"hash\", \"muur\", \"vuur\"}, s.Keys())\n\n\ts.Select(1)\n\ts.Set(\"1aap\", \"1noot\")\n\tequals(t, []string{\"1aap\"}, s.Keys())\n\n\ts.Select(0)\n\ts.FlushDB()\n\tequals(t, []string{}, s.Keys())\n\ts.Select(1)\n\tequals(t, []string{\"1aap\"}, s.Keys())\n\n\ts.Select(0)\n\ts.FlushAll()\n\tequals(t, []string{}, s.Keys())\n\ts.Select(1)\n\tequals(t, []string{}, s.Keys())\n}\n\nfunc TestExpireWithFastForward(t *testing.T) {\n\ts := RunT(t)\n\n\ts.Set(\"aap\", \"noot\")\n\ts.Set(\"noot\", \"aap\")\n\ts.SetTTL(\"aap\", 10*time.Second)\n\n\ts.FastForward(5 * time.Second)\n\tequals(t, 2, len(s.Keys()))\n\n\ts.FastForward(5 * time.Second)\n\tequals(t, 1, len(s.Keys()))\n}\n\n/*\nwe don't have the redis client anymore\nfunc TestPool(t *testing.T) {\n\ts, err := Run()\n\tok(t, err)\n\tdefer s.Close()\n\n\tpool := &redis.Pool{\n\t\tMaxIdle:     1,\n\t\tIdleTimeout: 5 * time.Second,\n\t\tDial: func() (redis.Conn, error) {\n\t\t\treturn redis.Dial(\"tcp\", s.Addr())\n\t\t},\n\t}\n\tc := pool.Get()\n\tc.Close()\n}\n*/\n\nfunc TestMiniredis_isValidCMD(t *testing.T) {\n\ttestCases := []struct {\n\t\tname         string\n\t\tisAuthorized bool\n\t\tisInPUBSUB   bool\n\t\twantResult   bool\n\t}{\n\t\t{\n\t\t\tname:         \"Client is not authorized, no PUBSUB mode\",\n\t\t\tisAuthorized: false,\n\t\t\tisInPUBSUB:   false,\n\t\t\twantResult:   false,\n\t\t},\n\t\t{\n\t\t\tname:         \"Client is not authorized, PUBSUB mode\",\n\t\t\tisAuthorized: false,\n\t\t\tisInPUBSUB:   true,\n\t\t\twantResult:   false,\n\t\t},\n\t\t{\n\t\t\tname:         \"Client is authorized, PUBSUB mode\",\n\t\t\tisAuthorized: true,\n\t\t\tisInPUBSUB:   true,\n\t\t\twantResult:   false,\n\t\t},\n\t\t{\n\t\t\tname:         \"Client is authorized, no PUBSUB mode\",\n\t\t\tisAuthorized: true,\n\t\t\tisInPUBSUB:   false,\n\t\t\twantResult:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tm := &Miniredis{\n\t\t\t\tpasswords: map[string]string{\n\t\t\t\t\t\"example_username\": \"example_password\",\n\t\t\t\t},\n\t\t\t}\n\t\t\tc := server.NewPeer(bufio.NewWriter(&bytes.Buffer{}))\n\t\t\tc.Ctx = &connCtx{\n\t\t\t\tauthenticated: tc.isAuthorized,\n\t\t\t}\n\t\t\tif tc.isInPUBSUB {\n\t\t\t\tc.Ctx = &connCtx{\n\t\t\t\t\tauthenticated: tc.isAuthorized,\n\t\t\t\t\tsubscriber:    newSubscriber(),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tassert(t, tc.wantResult == m.isValidCMD(c, \"example_cmd\"), \"fail\")\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "opts.go",
          "type": "blob",
          "size": 1.1962890625,
          "content": "package miniredis\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// optInt parses an int option in a command.\n// Writes \"invalid integer\" error to c if it's not a valid integer. Returns\n// whether or not things were okay.\nfunc optInt(c *server.Peer, src string, dest *int) bool {\n\treturn optIntErr(c, src, dest, msgInvalidInt)\n}\n\nfunc optIntErr(c *server.Peer, src string, dest *int, errMsg string) bool {\n\tn, err := strconv.Atoi(src)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(errMsg)\n\t\treturn false\n\t}\n\t*dest = n\n\treturn true\n}\n\n// optIntSimple sets dest or returns an error\nfunc optIntSimple(src string, dest *int) error {\n\tn, err := strconv.Atoi(src)\n\tif err != nil {\n\t\treturn errors.New(msgInvalidInt)\n\t}\n\t*dest = n\n\treturn nil\n}\n\nfunc optDuration(c *server.Peer, src string, dest *time.Duration) bool {\n\tn, err := strconv.ParseFloat(src, 64)\n\tif err != nil {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgInvalidTimeout)\n\t\treturn false\n\t}\n\tif n < 0 {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgTimeoutNegative)\n\t\treturn false\n\t}\n\tif math.IsInf(n, 0) {\n\t\tsetDirty(c)\n\t\tc.WriteError(msgTimeoutIsOutOfRange)\n\t\treturn false\n\t}\n\n\t*dest = time.Duration(n*1_000_000) * time.Microsecond\n\treturn true\n}\n"
        },
        {
          "name": "proto",
          "type": "tree",
          "content": null
        },
        {
          "name": "pubsub.go",
          "type": "blob",
          "size": 4.91796875,
          "content": "package miniredis\n\nimport (\n\t\"regexp\"\n\t\"sort\"\n\t\"sync\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\n// PubsubMessage is what gets broadcasted over pubsub channels.\ntype PubsubMessage struct {\n\tChannel string\n\tMessage string\n}\n\ntype PubsubPmessage struct {\n\tPattern string\n\tChannel string\n\tMessage string\n}\n\n// Subscriber has the (p)subscriptions.\ntype Subscriber struct {\n\tpublish  chan PubsubMessage\n\tppublish chan PubsubPmessage\n\tchannels map[string]struct{}\n\tpatterns map[string]*regexp.Regexp\n\tmu       sync.Mutex\n}\n\n// Make a new subscriber. The channel is not buffered, so you will need to keep\n// reading using Messages(). Use Close() when done, or unsubscribe.\nfunc newSubscriber() *Subscriber {\n\treturn &Subscriber{\n\t\tpublish:  make(chan PubsubMessage),\n\t\tppublish: make(chan PubsubPmessage),\n\t\tchannels: map[string]struct{}{},\n\t\tpatterns: map[string]*regexp.Regexp{},\n\t}\n}\n\n// Close the listening channel\nfunc (s *Subscriber) Close() {\n\tclose(s.publish)\n\tclose(s.ppublish)\n}\n\n// Count the total number of channels and patterns\nfunc (s *Subscriber) Count() int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\treturn s.count()\n}\n\nfunc (s *Subscriber) count() int {\n\treturn len(s.channels) + len(s.patterns)\n}\n\n// Subscribe to a channel. Returns the total number of (p)subscriptions after\n// subscribing.\nfunc (s *Subscriber) Subscribe(c string) int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\ts.channels[c] = struct{}{}\n\treturn s.count()\n}\n\n// Unsubscribe a channel. Returns the total number of (p)subscriptions after\n// unsubscribing.\nfunc (s *Subscriber) Unsubscribe(c string) int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tdelete(s.channels, c)\n\treturn s.count()\n}\n\n// Subscribe to a pattern. Returns the total number of (p)subscriptions after\n// subscribing.\nfunc (s *Subscriber) Psubscribe(pat string) int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\ts.patterns[pat] = patternRE(pat)\n\treturn s.count()\n}\n\n// Unsubscribe a pattern. Returns the total number of (p)subscriptions after\n// unsubscribing.\nfunc (s *Subscriber) Punsubscribe(pat string) int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tdelete(s.patterns, pat)\n\treturn s.count()\n}\n\n// List all subscribed channels, in alphabetical order\nfunc (s *Subscriber) Channels() []string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tvar cs []string\n\tfor c := range s.channels {\n\t\tcs = append(cs, c)\n\t}\n\tsort.Strings(cs)\n\treturn cs\n}\n\n// List all subscribed patterns, in alphabetical order\nfunc (s *Subscriber) Patterns() []string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tvar ps []string\n\tfor p := range s.patterns {\n\t\tps = append(ps, p)\n\t}\n\tsort.Strings(ps)\n\treturn ps\n}\n\n// Publish a message. Will return return how often we sent the message (can be\n// a match for a subscription and for a psubscription.\nfunc (s *Subscriber) Publish(c, msg string) int {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tfound := 0\n\nsubs:\n\tfor sub := range s.channels {\n\t\tif sub == c {\n\t\t\ts.publish <- PubsubMessage{c, msg}\n\t\t\tfound++\n\t\t\tbreak subs\n\t\t}\n\t}\n\npats:\n\tfor orig, pat := range s.patterns {\n\t\tif pat != nil && pat.MatchString(c) {\n\t\t\ts.ppublish <- PubsubPmessage{orig, c, msg}\n\t\t\tfound++\n\t\t\tbreak pats\n\t\t}\n\t}\n\n\treturn found\n}\n\n// The channel to read messages for this subscriber. Only for messages matching\n// a SUBSCRIBE.\nfunc (s *Subscriber) Messages() <-chan PubsubMessage {\n\treturn s.publish\n}\n\n// The channel to read messages for this subscriber. Only for messages matching\n// a PSUBSCRIBE.\nfunc (s *Subscriber) Pmessages() <-chan PubsubPmessage {\n\treturn s.ppublish\n}\n\n// List all pubsub channels. If `pat` isn't empty channels names must match the\n// pattern. Channels are returned alphabetically.\nfunc activeChannels(subs []*Subscriber, pat string) []string {\n\tchannels := map[string]struct{}{}\n\tfor _, s := range subs {\n\t\tfor c := range s.channels {\n\t\t\tchannels[c] = struct{}{}\n\t\t}\n\t}\n\n\tvar cpat *regexp.Regexp\n\tif pat != \"\" {\n\t\tcpat = patternRE(pat)\n\t}\n\n\tvar cs []string\n\tfor k := range channels {\n\t\tif cpat != nil && !cpat.MatchString(k) {\n\t\t\tcontinue\n\t\t}\n\t\tcs = append(cs, k)\n\t}\n\tsort.Strings(cs)\n\treturn cs\n}\n\n// Count all subscribed (not psubscribed) clients for the given channel\n// pattern. Channels are returned alphabetically.\nfunc countSubs(subs []*Subscriber, channel string) int {\n\tn := 0\n\tfor _, p := range subs {\n\t\tfor c := range p.channels {\n\t\t\tif c == channel {\n\t\t\t\tn++\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn n\n}\n\n// Count the total of all client psubscriptions.\nfunc countPsubs(subs []*Subscriber) int {\n\tn := 0\n\tfor _, p := range subs {\n\t\tn += len(p.patterns)\n\t}\n\treturn n\n}\n\nfunc monitorPublish(conn *server.Peer, msgs <-chan PubsubMessage) {\n\tfor msg := range msgs {\n\t\tconn.Block(func(c *server.Writer) {\n\t\t\tc.WritePushLen(3)\n\t\t\tc.WriteBulk(\"message\")\n\t\t\tc.WriteBulk(msg.Channel)\n\t\t\tc.WriteBulk(msg.Message)\n\t\t\tc.Flush()\n\t\t})\n\t}\n}\n\nfunc monitorPpublish(conn *server.Peer, msgs <-chan PubsubPmessage) {\n\tfor msg := range msgs {\n\t\tconn.Block(func(c *server.Writer) {\n\t\t\tc.WritePushLen(4)\n\t\t\tc.WriteBulk(\"pmessage\")\n\t\t\tc.WriteBulk(msg.Pattern)\n\t\t\tc.WriteBulk(msg.Channel)\n\t\t\tc.WriteBulk(msg.Message)\n\t\t\tc.Flush()\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "redis.go",
          "type": "blob",
          "size": 7.533203125,
          "content": "package miniredis\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nconst (\n\tmsgWrongType            = \"WRONGTYPE Operation against a key holding the wrong kind of value\"\n\tmsgNotValidHllValue     = \"WRONGTYPE Key is not a valid HyperLogLog string value.\"\n\tmsgInvalidInt           = \"ERR value is not an integer or out of range\"\n\tmsgIntOverflow          = \"ERR increment or decrement would overflow\"\n\tmsgInvalidFloat         = \"ERR value is not a valid float\"\n\tmsgInvalidMinMax        = \"ERR min or max is not a float\"\n\tmsgInvalidRangeItem     = \"ERR min or max not valid string range item\"\n\tmsgInvalidTimeout       = \"ERR timeout is not a float or out of range\"\n\tmsgInvalidRange         = \"ERR value is out of range, must be positive\"\n\tmsgSyntaxError          = \"ERR syntax error\"\n\tmsgKeyNotFound          = \"ERR no such key\"\n\tmsgOutOfRange           = \"ERR index out of range\"\n\tmsgInvalidCursor        = \"ERR invalid cursor\"\n\tmsgXXandNX              = \"ERR XX and NX options at the same time are not compatible\"\n\tmsgTimeoutNegative      = \"ERR timeout is negative\"\n\tmsgTimeoutIsOutOfRange  = \"ERR timeout is out of range\"\n\tmsgInvalidSETime        = \"ERR invalid expire time in set\"\n\tmsgInvalidSETEXTime     = \"ERR invalid expire time in setex\"\n\tmsgInvalidPSETEXTime    = \"ERR invalid expire time in psetex\"\n\tmsgInvalidKeysNumber    = \"ERR Number of keys can't be greater than number of args\"\n\tmsgNegativeKeysNumber   = \"ERR Number of keys can't be negative\"\n\tmsgFScriptUsage         = \"ERR unknown subcommand or wrong number of arguments for '%s'. Try SCRIPT HELP.\"\n\tmsgFScriptUsageSimple   = \"ERR unknown subcommand '%s'. Try SCRIPT HELP.\"\n\tmsgFPubsubUsage         = \"ERR unknown subcommand or wrong number of arguments for '%s'. Try PUBSUB HELP.\"\n\tmsgFPubsubUsageSimple   = \"ERR unknown subcommand '%s'. Try PUBSUB HELP.\"\n\tmsgFObjectUsage         = \"ERR unknown subcommand '%s'. Try OBJECT HELP.\"\n\tmsgScriptFlush          = \"ERR SCRIPT FLUSH only support SYNC|ASYNC option\"\n\tmsgSingleElementPair    = \"ERR INCR option supports a single increment-element pair\"\n\tmsgGTLTandNX            = \"ERR GT, LT, and/or NX options at the same time are not compatible\"\n\tmsgInvalidStreamID      = \"ERR Invalid stream ID specified as stream command argument\"\n\tmsgStreamIDTooSmall     = \"ERR The ID specified in XADD is equal or smaller than the target stream top item\"\n\tmsgStreamIDZero         = \"ERR The ID specified in XADD must be greater than 0-0\"\n\tmsgNoScriptFound        = \"NOSCRIPT No matching script. Please use EVAL.\"\n\tmsgUnsupportedUnit      = \"ERR unsupported unit provided. please use M, KM, FT, MI\"\n\tmsgXreadUnbalanced      = \"ERR Unbalanced 'xread' list of streams: for each stream key an ID or '$' must be specified.\"\n\tmsgXgroupKeyNotFound    = \"ERR The XGROUP subcommand requires the key to exist. Note that for CREATE you may want to use the MKSTREAM option to create an empty stream automatically.\"\n\tmsgXtrimInvalidStrategy = \"ERR unsupported XTRIM strategy. Please use MAXLEN, MINID\"\n\tmsgXtrimInvalidMaxLen   = \"ERR value is not an integer or out of range\"\n\tmsgXtrimInvalidLimit    = \"ERR syntax error, LIMIT cannot be used without the special ~ option\"\n\tmsgDBIndexOutOfRange    = \"ERR DB index is out of range\"\n\tmsgLimitCombination     = \"ERR syntax error, LIMIT is only supported in combination with either BYSCORE or BYLEX\"\n\tmsgRankIsZero           = \"ERR RANK can't be zero: use 1 to start from the first match, 2 from the second ... or use negative to start from the end of the list\"\n\tmsgCountIsNegative      = \"ERR COUNT can't be negative\"\n\tmsgMaxLengthIsNegative  = \"ERR MAXLEN can't be negative\"\n\tmsgLimitIsNegative      = \"ERR LIMIT can't be negative\"\n\tmsgMemorySubcommand     = \"ERR unknown subcommand '%s'. Try MEMORY HELP.\"\n)\n\nfunc errWrongNumber(cmd string) string {\n\treturn fmt.Sprintf(\"ERR wrong number of arguments for '%s' command\", strings.ToLower(cmd))\n}\n\nfunc errLuaParseError(err error) string {\n\treturn fmt.Sprintf(\"ERR Error compiling script (new function): %s\", err.Error())\n}\n\nfunc errReadgroup(key, group string) error {\n\treturn fmt.Errorf(\"NOGROUP No such key '%s' or consumer group '%s'\", key, group)\n}\n\nfunc errXreadgroup(key, group string) error {\n\treturn fmt.Errorf(\"NOGROUP No such key '%s' or consumer group '%s' in XREADGROUP with GROUP option\", key, group)\n}\n\nfunc msgNotFromScripts(sha string) string {\n\treturn fmt.Sprintf(\"This Redis command is not allowed from script script: %s, &c\", sha)\n}\n\n// withTx wraps the non-argument-checking part of command handling code in\n// transaction logic.\nfunc withTx(\n\tm *Miniredis,\n\tc *server.Peer,\n\tcb txCmd,\n) {\n\tctx := getCtx(c)\n\n\tif ctx.nested {\n\t\t// this is a call via Lua's .call(). It's already locked.\n\t\tcb(c, ctx)\n\t\tm.signal.Broadcast()\n\t\treturn\n\t}\n\n\tif inTx(ctx) {\n\t\taddTxCmd(ctx, cb)\n\t\tc.WriteInline(\"QUEUED\")\n\t\treturn\n\t}\n\tm.Lock()\n\tcb(c, ctx)\n\t// done, wake up anyone who waits on anything.\n\tm.signal.Broadcast()\n\tm.Unlock()\n}\n\n// blockCmd is executed returns whether it is done\ntype blockCmd func(*server.Peer, *connCtx) bool\n\n// blocking keeps trying a command until the callback returns true. Calls\n// onTimeout after the timeout (or when we call this in a transaction).\nfunc blocking(\n\tm *Miniredis,\n\tc *server.Peer,\n\ttimeout time.Duration,\n\tcb blockCmd,\n\tonTimeout func(*server.Peer),\n) {\n\tvar (\n\t\tctx = getCtx(c)\n\t)\n\tif inTx(ctx) {\n\t\taddTxCmd(ctx, func(c *server.Peer, ctx *connCtx) {\n\t\t\tif !cb(c, ctx) {\n\t\t\t\tonTimeout(c)\n\t\t\t}\n\t\t})\n\t\tc.WriteInline(\"QUEUED\")\n\t\treturn\n\t}\n\n\tlocalCtx, cancel := context.WithCancel(m.Ctx)\n\tdefer cancel()\n\ttimedOut := false\n\tif timeout != 0 {\n\t\tgo setCondTimer(localCtx, m.signal, &timedOut, timeout)\n\t}\n\tgo func() {\n\t\t<-localCtx.Done()\n\t\tm.signal.Broadcast() // main loop might miss this signal\n\t}()\n\n\tif !ctx.nested {\n\t\t// this is a call via Lua's .call(). It's already locked.\n\t\tm.Lock()\n\t\tdefer m.Unlock()\n\t}\n\tfor {\n\t\tif c.Closed() {\n\t\t\treturn\n\t\t}\n\n\t\tif m.Ctx.Err() != nil {\n\t\t\treturn\n\t\t}\n\n\t\tdone := cb(c, ctx)\n\t\tif done {\n\t\t\treturn\n\t\t}\n\n\t\tif timedOut {\n\t\t\tonTimeout(c)\n\t\t\treturn\n\t\t}\n\n\t\tm.signal.Wait()\n\t}\n}\n\nfunc setCondTimer(ctx context.Context, sig *sync.Cond, timedOut *bool, timeout time.Duration) {\n\tdl := time.NewTimer(timeout)\n\tdefer dl.Stop()\n\tselect {\n\tcase <-dl.C:\n\t\tsig.L.Lock() // for timedOut\n\t\t*timedOut = true\n\t\tsig.Broadcast() // main loop might miss this signal\n\t\tsig.L.Unlock()\n\tcase <-ctx.Done():\n\t}\n}\n\n// formatBig formats a float the way redis does\nfunc formatBig(v *big.Float) string {\n\t// Format with %f and strip trailing 0s.\n\tif v.IsInf() {\n\t\treturn \"inf\"\n\t}\n\t// if math.IsInf(v, -1) {\n\t// return \"-inf\"\n\t// }\n\treturn stripZeros(fmt.Sprintf(\"%.17f\", v))\n}\n\nfunc stripZeros(sv string) string {\n\tfor strings.Contains(sv, \".\") {\n\t\tif sv[len(sv)-1] != '0' {\n\t\t\tbreak\n\t\t}\n\t\t// Remove trailing 0s.\n\t\tsv = sv[:len(sv)-1]\n\t\t// Ends with a '.'.\n\t\tif sv[len(sv)-1] == '.' {\n\t\t\tsv = sv[:len(sv)-1]\n\t\t\tbreak\n\t\t}\n\t}\n\treturn sv\n}\n\n// redisRange gives Go offsets for something l long with start/end in\n// Redis semantics. Both start and end can be negative.\n// Used for string range and list range things.\n// The results can be used as: v[start:end]\n// Note that GETRANGE (on a string key) never returns an empty string when end\n// is a large negative number.\nfunc redisRange(l, start, end int, stringSymantics bool) (int, int) {\n\tif start < 0 {\n\t\tstart = l + start\n\t\tif start < 0 {\n\t\t\tstart = 0\n\t\t}\n\t}\n\tif start > l {\n\t\tstart = l\n\t}\n\n\tif end < 0 {\n\t\tend = l + end\n\t\tif end < 0 {\n\t\t\tend = -1\n\t\t\tif stringSymantics {\n\t\t\t\tend = 0\n\t\t\t}\n\t\t}\n\t}\n\tif end < math.MaxInt32 {\n\t\tend++ // end argument is inclusive in Redis.\n\t}\n\tif end > l {\n\t\tend = l\n\t}\n\n\tif end < start {\n\t\treturn 0, 0\n\t}\n\treturn start, end\n}\n"
        },
        {
          "name": "redis_test.go",
          "type": "blob",
          "size": 0.578125,
          "content": "package miniredis\n\nimport (\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/alicebob/miniredis/v2/server\"\n)\n\nfunc TestRedis(t *testing.T) {\n\ts := RunT(t)\n\n\tpeer := &server.Peer{}\n\tvar wg sync.WaitGroup\n\twg.Add(1)\n\n\tgo func() {\n\t\tdefer wg.Done()\n\t\tblocking(s, peer, time.Second, func(p *server.Peer, cc *connCtx) bool {\n\t\t\terr := s.Ctx.Err()\n\t\t\tif err != nil {\n\t\t\t\tt.Error(\"blocking call should not retry command when context has error\")\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t}, func(p *server.Peer) {\n\t\t\t// expect to time out\n\t\t})\n\t}()\n\n\ttime.Sleep(time.Millisecond * 250)\n\n\ts.Close()\n\twg.Wait()\n}\n"
        },
        {
          "name": "server",
          "type": "tree",
          "content": null
        },
        {
          "name": "size",
          "type": "tree",
          "content": null
        },
        {
          "name": "sorted_set.go",
          "type": "blob",
          "size": 1.85546875,
          "content": "package miniredis\n\n// The most KISS way to implement a sorted set. Luckily we don't care about\n// performance that much.\n\nimport (\n\t\"sort\"\n)\n\ntype direction int\n\nconst (\n\tunsorted direction = iota\n\tasc\n\tdesc\n)\n\ntype sortedSet map[string]float64\n\ntype ssElem struct {\n\tscore  float64\n\tmember string\n}\ntype ssElems []ssElem\n\ntype byScore ssElems\n\nfunc (sse byScore) Len() int      { return len(sse) }\nfunc (sse byScore) Swap(i, j int) { sse[i], sse[j] = sse[j], sse[i] }\nfunc (sse byScore) Less(i, j int) bool {\n\tif sse[i].score != sse[j].score {\n\t\treturn sse[i].score < sse[j].score\n\t}\n\treturn sse[i].member < sse[j].member\n}\n\nfunc newSortedSet() sortedSet {\n\treturn sortedSet{}\n}\n\nfunc (ss *sortedSet) card() int {\n\treturn len(*ss)\n}\n\nfunc (ss *sortedSet) set(score float64, member string) {\n\t(*ss)[member] = score\n}\n\nfunc (ss *sortedSet) get(member string) (float64, bool) {\n\tv, ok := (*ss)[member]\n\treturn v, ok\n}\n\n// elems gives the list of ssElem, ready to sort.\nfunc (ss *sortedSet) elems() ssElems {\n\telems := make(ssElems, 0, len(*ss))\n\tfor e, s := range *ss {\n\t\telems = append(elems, ssElem{s, e})\n\t}\n\treturn elems\n}\n\nfunc (ss *sortedSet) byScore(d direction) ssElems {\n\telems := ss.elems()\n\tsort.Sort(byScore(elems))\n\tif d == desc {\n\t\treverseElems(elems)\n\t}\n\treturn ssElems(elems)\n}\n\n// rankByScore gives the (0-based) index of member, or returns false.\nfunc (ss *sortedSet) rankByScore(member string, d direction) (int, bool) {\n\tif _, ok := (*ss)[member]; !ok {\n\t\treturn 0, false\n\t}\n\tfor i, e := range ss.byScore(d) {\n\t\tif e.member == member {\n\t\t\treturn i, true\n\t\t}\n\t}\n\t// Can't happen\n\treturn 0, false\n}\n\nfunc reverseSlice(o []string) {\n\tfor i := range make([]struct{}, len(o)/2) {\n\t\tother := len(o) - 1 - i\n\t\to[i], o[other] = o[other], o[i]\n\t}\n}\n\nfunc reverseElems(o ssElems) {\n\tfor i := range make([]struct{}, len(o)/2) {\n\t\tother := len(o) - 1 - i\n\t\to[i], o[other] = o[other], o[i]\n\t}\n}\n"
        },
        {
          "name": "sorted_set_test.go",
          "type": "blob",
          "size": 1.513671875,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n)\n\nfunc TestSortedSetImpl(t *testing.T) {\n\ts := newSortedSet()\n\tequals(t, 0, s.card())\n\ts.set(3.1415, \"pi\")\n\ts.set(2*3.1415, \"2pi\")\n\ts.set(3*3.1415, \"3pi\")\n\tequals(t, 3, s.card())\n\t// replace works?\n\ts.set(3.141592, \"pi\")\n\tequals(t, 3, s.card())\n\n\t// Get a key\n\t{\n\t\tpi, ok := s.get(\"pi\")\n\t\tassert(t, ok, \"got pi\")\n\t\tequals(t, 3.141592, pi)\n\t}\n\n\t// Set ordered by score\n\t{\n\t\telems := s.byScore(asc)\n\t\tequals(t, 3, len(elems))\n\t\tequals(t, ssElems{\n\t\t\t{3.141592, \"pi\"},\n\t\t\t{2 * 3.1415, \"2pi\"},\n\t\t\t{3 * 3.1415, \"3pi\"},\n\t\t}, elems)\n\t}\n\n\t// Rank of a key\n\t{\n\t\trank, found := s.rankByScore(\"pi\", asc)\n\t\tassert(t, found, \"Found pi\")\n\t\tequals(t, 0, rank)\n\n\t\trank, found = s.rankByScore(\"3pi\", desc)\n\t\tassert(t, found, \"Found 3pi\")\n\t\tequals(t, 0, rank)\n\n\t\trank, found = s.rankByScore(\"3pi\", asc)\n\t\tassert(t, found, \"Found 3pi\")\n\t\tequals(t, 2, rank)\n\n\t\t_, found = s.rankByScore(\"nosuch\", asc)\n\t\tassert(t, !found, \"Did not find nosuch\")\n\t}\n}\n\nfunc TestSortOrder(t *testing.T) {\n\t// Keys with the same key should be sorted lexicographically\n\ts := newSortedSet()\n\tequals(t, 0, s.card())\n\ts.set(1, \"one\")\n\ts.set(1, \"1\")\n\ts.set(1, \"eins\")\n\ts.set(2, \"two\")\n\ts.set(2, \"2\")\n\ts.set(2, \"zwei\")\n\ts.set(3, \"three\")\n\ts.set(3, \"3\")\n\ts.set(3, \"drei\")\n\tequals(t, 9, s.card())\n\n\t// Set ordered by score, member\n\t{\n\t\telems := s.byScore(asc)\n\t\tequals(t, 9, len(elems))\n\t\tequals(t, ssElems{\n\t\t\t{1, \"1\"},\n\t\t\t{1, \"eins\"},\n\t\t\t{1, \"one\"},\n\t\t\t{2, \"2\"},\n\t\t\t{2, \"two\"},\n\t\t\t{2, \"zwei\"},\n\t\t\t{3, \"3\"},\n\t\t\t{3, \"drei\"},\n\t\t\t{3, \"three\"},\n\t\t}, elems)\n\t}\n}\n"
        },
        {
          "name": "stream.go",
          "type": "blob",
          "size": 10.2998046875,
          "content": "// Basic stream implementation.\n\npackage miniredis\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\n// a Stream is a list of entries, lowest ID (oldest) first, and all \"groups\".\ntype streamKey struct {\n\tentries         []StreamEntry\n\tgroups          map[string]*streamGroup\n\tlastAllocatedID string\n\tmu              sync.Mutex\n}\n\n// a StreamEntry is an entry in a stream. The ID is always of the form\n// \"123-123\".\n// Values is an ordered list of key-value pairs.\ntype StreamEntry struct {\n\tID     string\n\tValues []string\n}\n\ntype streamGroup struct {\n\tstream    *streamKey\n\tlastID    string\n\tpending   []pendingEntry\n\tconsumers map[string]*consumer\n}\n\ntype consumer struct {\n\tnumPendingEntries int\n\t// these timestamps aren't tracked perfectly\n\tlastSeen    time.Time // \"idle\" XINFO key\n\tlastSuccess time.Time // \"inactive\" XINFO key\n}\n\ntype pendingEntry struct {\n\tid            string\n\tconsumer      string\n\tdeliveryCount int\n\tlastDelivery  time.Time\n}\n\nfunc newStreamKey() *streamKey {\n\treturn &streamKey{\n\t\tgroups: map[string]*streamGroup{},\n\t}\n}\n\n// generateID doesn't lock the mutex\nfunc (s *streamKey) generateID(now time.Time) string {\n\tts := uint64(now.UnixNano()) / 1_000_000\n\n\tnext := fmt.Sprintf(\"%d-%d\", ts, 0)\n\tif s.lastAllocatedID != \"\" && streamCmp(s.lastAllocatedID, next) >= 0 {\n\t\tlast, _ := parseStreamID(s.lastAllocatedID)\n\t\tnext = fmt.Sprintf(\"%d-%d\", last[0], last[1]+1)\n\t}\n\n\tlastID := s.lastIDUnlocked()\n\tif streamCmp(lastID, next) >= 0 {\n\t\tlast, _ := parseStreamID(lastID)\n\t\tnext = fmt.Sprintf(\"%d-%d\", last[0], last[1]+1)\n\t}\n\n\ts.lastAllocatedID = next\n\treturn next\n}\n\n// lastID locks the mutex\nfunc (s *streamKey) lastID() string {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\treturn s.lastIDUnlocked()\n}\n\n// lastID doesn't lock the mutex\nfunc (s *streamKey) lastIDUnlocked() string {\n\tif len(s.entries) == 0 {\n\t\treturn \"0-0\"\n\t}\n\n\treturn s.entries[len(s.entries)-1].ID\n}\n\nfunc (s *streamKey) copy() *streamKey {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tcpy := &streamKey{\n\t\tentries: s.entries,\n\t}\n\tgroups := map[string]*streamGroup{}\n\tfor k, v := range s.groups {\n\t\tgr := v.copy()\n\t\tgr.stream = cpy\n\t\tgroups[k] = gr\n\t}\n\tcpy.groups = groups\n\treturn cpy\n}\n\nfunc parseStreamID(id string) ([2]uint64, error) {\n\tvar (\n\t\tres [2]uint64\n\t\terr error\n\t)\n\tparts := strings.SplitN(id, \"-\", 2)\n\tres[0], err = strconv.ParseUint(parts[0], 10, 64)\n\tif err != nil {\n\t\treturn res, errors.New(msgInvalidStreamID)\n\t}\n\tif len(parts) == 2 {\n\t\tres[1], err = strconv.ParseUint(parts[1], 10, 64)\n\t\tif err != nil {\n\t\t\treturn res, errors.New(msgInvalidStreamID)\n\t\t}\n\t}\n\treturn res, nil\n}\n\n// compares two stream IDs (of the full format: \"123-123\"). Returns: -1, 0, 1\n// The given IDs should be valid stream IDs.\nfunc streamCmp(a, b string) int {\n\tap, _ := parseStreamID(a)\n\tbp, _ := parseStreamID(b)\n\n\tswitch {\n\tcase ap[0] < bp[0]:\n\t\treturn -1\n\tcase ap[0] > bp[0]:\n\t\treturn 1\n\tcase ap[1] < bp[1]:\n\t\treturn -1\n\tcase ap[1] > bp[1]:\n\t\treturn 1\n\tdefault:\n\t\treturn 0\n\t}\n}\n\n// formatStreamID makes a full id (\"42-42\") out of a partial one (\"42\")\nfunc formatStreamID(id string) (string, error) {\n\tvar ts [2]uint64\n\tparts := strings.SplitN(id, \"-\", 2)\n\n\tif len(parts) > 0 {\n\t\tp, err := strconv.ParseUint(parts[0], 10, 64)\n\t\tif err != nil {\n\t\t\treturn \"\", errInvalidEntryID\n\t\t}\n\t\tts[0] = p\n\t}\n\tif len(parts) > 1 {\n\t\tp, err := strconv.ParseUint(parts[1], 10, 64)\n\t\tif err != nil {\n\t\t\treturn \"\", errInvalidEntryID\n\t\t}\n\t\tts[1] = p\n\t}\n\treturn fmt.Sprintf(\"%d-%d\", ts[0], ts[1]), nil\n}\n\nfunc formatStreamRangeBound(id string, start bool, reverse bool) (string, error) {\n\tif id == \"-\" {\n\t\treturn \"0-0\", nil\n\t}\n\n\tif id == \"+\" {\n\t\treturn fmt.Sprintf(\"%d-%d\", uint64(math.MaxUint64), uint64(math.MaxUint64)), nil\n\t}\n\n\tif id == \"0\" {\n\t\treturn \"0-0\", nil\n\t}\n\n\tparts := strings.Split(id, \"-\")\n\tif len(parts) == 2 {\n\t\treturn formatStreamID(id)\n\t}\n\n\t// Incomplete IDs case\n\tts, err := strconv.ParseUint(parts[0], 10, 64)\n\tif err != nil {\n\t\treturn \"\", errInvalidEntryID\n\t}\n\n\tif (!start && !reverse) || (start && reverse) {\n\t\treturn fmt.Sprintf(\"%d-%d\", ts, uint64(math.MaxUint64)), nil\n\t}\n\n\treturn fmt.Sprintf(\"%d-%d\", ts, 0), nil\n}\n\nfunc reversedStreamEntries(o []StreamEntry) []StreamEntry {\n\tnewStream := make([]StreamEntry, len(o))\n\tfor i, e := range o {\n\t\tnewStream[len(o)-i-1] = e\n\t}\n\treturn newStream\n}\n\nfunc (s *streamKey) createGroup(group, id string) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif _, ok := s.groups[group]; ok {\n\t\treturn errors.New(\"BUSYGROUP Consumer Group name already exists\")\n\t}\n\n\tif id == \"$\" {\n\t\tid = s.lastIDUnlocked()\n\t}\n\ts.groups[group] = &streamGroup{\n\t\tstream:    s,\n\t\tlastID:    id,\n\t\tconsumers: map[string]*consumer{},\n\t}\n\treturn nil\n}\n\n// streamAdd adds an entry to a stream. Returns the new entry ID.\n// If id is empty or \"*\" the ID will be generated automatically.\n// `values` should have an even length.\nfunc (s *streamKey) add(entryID string, values []string, now time.Time) (string, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif entryID == \"\" || entryID == \"*\" {\n\t\tentryID = s.generateID(now)\n\t}\n\n\tentryID, err := formatStreamID(entryID)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif entryID == \"0-0\" {\n\t\treturn \"\", errors.New(msgStreamIDZero)\n\t}\n\tif streamCmp(s.lastIDUnlocked(), entryID) != -1 {\n\t\treturn \"\", errors.New(msgStreamIDTooSmall)\n\t}\n\n\ts.entries = append(s.entries, StreamEntry{\n\t\tID:     entryID,\n\t\tValues: values,\n\t})\n\treturn entryID, nil\n}\n\nfunc (s *streamKey) trim(n int) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif len(s.entries) > n {\n\t\ts.entries = s.entries[len(s.entries)-n:]\n\t}\n}\n\n// trimBefore deletes entries with an id less than the provided id\n// and returns the number of entries deleted\nfunc (s *streamKey) trimBefore(id string) int {\n\ts.mu.Lock()\n\tvar delete []string\n\tfor _, entry := range s.entries {\n\t\tif streamCmp(entry.ID, id) < 0 {\n\t\t\tdelete = append(delete, entry.ID)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\ts.mu.Unlock()\n\ts.delete(delete)\n\treturn len(delete)\n}\n\n// all entries after \"id\"\nfunc (s *streamKey) after(id string) []StreamEntry {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tpos := sort.Search(len(s.entries), func(i int) bool {\n\t\treturn streamCmp(id, s.entries[i].ID) < 0\n\t})\n\treturn s.entries[pos:]\n}\n\n// get a stream entry by ID\n// Also returns the position in the entries slice, if found.\nfunc (s *streamKey) get(id string) (int, *StreamEntry) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tpos := sort.Search(len(s.entries), func(i int) bool {\n\t\treturn streamCmp(id, s.entries[i].ID) <= 0\n\t})\n\tif len(s.entries) <= pos || s.entries[pos].ID != id {\n\t\treturn 0, nil\n\t}\n\treturn pos, &s.entries[pos]\n}\n\nfunc (g *streamGroup) readGroup(\n\tnow time.Time,\n\tconsumerID,\n\tid string,\n\tcount int,\n\tnoack bool,\n) []StreamEntry {\n\tif id == \">\" {\n\t\t// undelivered messages\n\t\tmsgs := g.stream.after(g.lastID)\n\t\tif len(msgs) == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\tif count > 0 && len(msgs) > count {\n\t\t\tmsgs = msgs[:count]\n\t\t}\n\n\t\tif !noack {\n\t\t\tshouldAppend := len(g.pending) == 0\n\t\t\tfor _, msg := range msgs {\n\t\t\t\tif !shouldAppend {\n\t\t\t\t\tshouldAppend = streamCmp(msg.ID, g.pending[len(g.pending)-1].id) == 1\n\t\t\t\t}\n\n\t\t\t\tvar entry *pendingEntry\n\t\t\t\tif shouldAppend {\n\t\t\t\t\tg.pending = append(g.pending, pendingEntry{})\n\t\t\t\t\tentry = &g.pending[len(g.pending)-1]\n\t\t\t\t} else {\n\t\t\t\t\tvar pos int\n\t\t\t\t\tpos, entry = g.searchPending(msg.ID)\n\t\t\t\t\tif entry == nil {\n\t\t\t\t\t\tg.pending = append(g.pending[:pos+1], g.pending[pos:]...)\n\t\t\t\t\t\tentry = &g.pending[pos]\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg.consumers[entry.consumer].numPendingEntries--\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t*entry = pendingEntry{\n\t\t\t\t\tid:            msg.ID,\n\t\t\t\t\tconsumer:      consumerID,\n\t\t\t\t\tdeliveryCount: 1,\n\t\t\t\t\tlastDelivery:  now,\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif _, ok := g.consumers[consumerID]; !ok {\n\t\t\tg.consumers[consumerID] = &consumer{}\n\t\t}\n\t\tg.consumers[consumerID].numPendingEntries += len(msgs)\n\t\tg.lastID = msgs[len(msgs)-1].ID\n\t\treturn msgs\n\t}\n\n\t// re-deliver messages from the pending list.\n\t// con := gr.consumers[consumerID]\n\tmsgs := g.pendingAfter(id)\n\tvar res []StreamEntry\n\tfor i, p := range msgs {\n\t\tif p.consumer != consumerID {\n\t\t\tcontinue\n\t\t}\n\t\t_, entry := g.stream.get(p.id)\n\t\t// not found. Weird?\n\t\tif entry == nil {\n\t\t\tcontinue\n\t\t}\n\t\tp.deliveryCount += 1\n\t\tp.lastDelivery = now\n\t\tmsgs[i] = p\n\t\tres = append(res, *entry)\n\t}\n\treturn res\n}\n\nfunc (g *streamGroup) searchPending(id string) (int, *pendingEntry) {\n\tpos := sort.Search(len(g.pending), func(i int) bool {\n\t\treturn streamCmp(id, g.pending[i].id) <= 0\n\t})\n\tif pos >= len(g.pending) || g.pending[pos].id != id {\n\t\treturn pos, nil\n\t}\n\treturn pos, &g.pending[pos]\n}\n\nfunc (g *streamGroup) ack(ids []string) (int, error) {\n\tcount := 0\n\tfor _, id := range ids {\n\t\tif _, err := parseStreamID(id); err != nil {\n\t\t\treturn 0, errors.New(msgInvalidStreamID)\n\t\t}\n\n\t\tpos, entry := g.searchPending(id)\n\t\tif entry == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tconsumer := g.consumers[entry.consumer]\n\t\tconsumer.numPendingEntries--\n\n\t\tg.pending = append(g.pending[:pos], g.pending[pos+1:]...)\n\t\t// don't count deleted entries\n\t\tif _, e := g.stream.get(id); e == nil {\n\t\t\tcontinue\n\t\t}\n\t\tcount++\n\t}\n\treturn count, nil\n}\n\nfunc (s *streamKey) delete(ids []string) (int, error) {\n\tcount := 0\n\tfor _, id := range ids {\n\t\tif _, err := parseStreamID(id); err != nil {\n\t\t\treturn 0, errors.New(msgInvalidStreamID)\n\t\t}\n\n\t\ti, entry := s.get(id)\n\t\tif entry == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\ts.entries = append(s.entries[:i], s.entries[i+1:]...)\n\t\tcount++\n\t}\n\treturn count, nil\n}\n\nfunc (g *streamGroup) pendingAfter(id string) []pendingEntry {\n\tpos := sort.Search(len(g.pending), func(i int) bool {\n\t\treturn streamCmp(id, g.pending[i].id) < 0\n\t})\n\treturn g.pending[pos:]\n}\n\nfunc (g *streamGroup) pendingCount(consumer string) int {\n\tn := 0\n\tfor _, p := range g.activePending() {\n\t\tif p.consumer == consumer {\n\t\t\tn++\n\t\t}\n\t}\n\treturn n\n}\n\n// pending entries without the entries deleted from the group\nfunc (g *streamGroup) activePending() []pendingEntry {\n\tvar pe []pendingEntry\n\tfor _, p := range g.pending {\n\t\t// drop deleted ones\n\t\tif _, e := g.stream.get(p.id); e == nil {\n\t\t\tcontinue\n\t\t}\n\t\tp := p\n\t\tpe = append(pe, p)\n\t}\n\treturn pe\n}\n\nfunc (g *streamGroup) copy() *streamGroup {\n\tcns := map[string]*consumer{}\n\tfor k, v := range g.consumers {\n\t\tc := *v\n\t\tcns[k] = &c\n\t}\n\treturn &streamGroup{\n\t\t// don't copy stream\n\t\tlastID:    g.lastID,\n\t\tpending:   g.pending,\n\t\tconsumers: cns,\n\t}\n}\n\nfunc (g *streamGroup) setLastSeen(c string, t time.Time) {\n\tcons, ok := g.consumers[c]\n\tif !ok {\n\t\tcons = &consumer{}\n\t}\n\tcons.lastSeen = t\n\tg.consumers[c] = cons\n}\n\nfunc (g *streamGroup) setLastSuccess(c string, t time.Time) {\n\tg.setLastSeen(c, t)\n\tg.consumers[c].lastSuccess = t\n}\n"
        },
        {
          "name": "stream_test.go",
          "type": "blob",
          "size": 4.0849609375,
          "content": "package miniredis\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestStreamID(t *testing.T) {\n\ttest := func(a, b string, want int) {\n\t\tif have := streamCmp(a, b); have != want {\n\t\t\tt.Errorf(\"cmp(%q, %q) have %d, want %d\", a, b, have, want)\n\t\t}\n\t}\n\ttest(\"1-1\", \"2-1\", -1)\n\ttest(\"1-1\", \"1-1\", 0)\n\ttest(\"1-1\", \"0-1\", 1)\n\ttest(\"1-1\", \"1-2\", -1)\n\ttest(\"1-1\", \"1-1\", 0)\n\ttest(\"1-1\", \"1-0\", 1)\n}\n\nfunc TestFormatStreamID(t *testing.T) {\n\tif have, _ := formatStreamID(\"1-1\"); have != \"1-1\" {\n\t\tt.Errorf(\"have %q, want %q\", have, \"1-1\")\n\t}\n\tif have, _ := formatStreamID(\"1\"); have != \"1-0\" {\n\t\tt.Errorf(\"have %q, want %q\", have, \"1-0\")\n\t}\n\tif have, _ := formatStreamID(\"1-002\"); have != \"1-2\" {\n\t\tt.Errorf(\"have %q, want %q\", have, \"1-2\")\n\t}\n\tif _, err := formatStreamID(\"1-foo\"); err != errInvalidEntryID {\n\t\tt.Errorf(\"have %s, want %s\", err, errInvalidEntryID)\n\t}\n\tif _, err := formatStreamID(\"foo\"); err != errInvalidEntryID {\n\t\tt.Errorf(\"have %s, want %s\", err, errInvalidEntryID)\n\t}\n}\n\nfunc TestStreamKey(t *testing.T) {\n\tnow := time.Now()\n\n\tt.Run(\"add\", func(t *testing.T) {\n\t\ts := newStreamKey()\n\t\tid, err := s.add(\"123-123\", []string{\"k\", \"v\"}, now)\n\t\tok(t, err)\n\t\tequalStr(t, \"123-123\", id)\n\t\tequals(t, 1, len(s.entries))\n\t})\n\n\tt.Run(\"after\", func(t *testing.T) {\n\t\ts := newStreamKey()\n\t\ts.add(\"123-123\", []string{\"k\", \"v\"}, now)\n\t\ts.add(\"123-128\", []string{\"k\", \"v\"}, now)\n\t\ts.add(\"123-129\", []string{\"k\", \"v\"}, now)\n\n\t\tequals(t, 3, len(s.after(\"0\")))\n\t\tequals(t, 3, len(s.after(\"123-122\")))\n\t\tequals(t, 2, len(s.after(\"123-123\")))\n\t\tequals(t, 2, len(s.after(\"123-124\")))\n\t\tequals(t, 1, len(s.after(\"123-128\")))\n\t\tequals(t, 0, len(s.after(\"123-129\")))\n\t\tequals(t, 0, len(s.after(\"999-999\")))\n\t})\n\n\tt.Run(\"get\", func(t *testing.T) {\n\t\ts := newStreamKey()\n\t\ts.add(\"123-123\", []string{\"k\", \"v\"}, now)\n\t\ts.add(\"123-128\", []string{\"k\", \"w\"}, now)\n\t\ts.add(\"123-129\", []string{\"k\", \"y\"}, now)\n\n\t\ti, entry := s.get(\"0\")\n\t\tequals(t, 0, i)\n\t\tequals(t, (*StreamEntry)(nil), entry)\n\n\t\ti, entry = s.get(\"123-123\")\n\t\tequals(t, 0, i)\n\t\tequalStr(t, \"123-123\", entry.ID)\n\n\t\ti, entry = s.get(\"123-124\")\n\t\tequals(t, 0, i)\n\t\tequals(t, (*StreamEntry)(nil), entry)\n\n\t\ti, entry = s.get(\"123-129\")\n\t\tequals(t, 2, i)\n\t\tequalStr(t, \"123-129\", entry.ID)\n\n\t\ti, entry = s.get(\"999-999\")\n\t\tequals(t, 0, i)\n\t\tequals(t, (*StreamEntry)(nil), entry)\n\t})\n\n\tt.Run(\"delete\", func(t *testing.T) {\n\t\ts := newStreamKey()\n\t\ts.add(\"123-123\", []string{\"k\", \"v\"}, now)\n\t\ts.add(\"123-124\", []string{\"k\", \"v\"}, now)\n\t\ts.add(\"123-125\", []string{\"k\", \"v\"}, now)\n\t\tequals(t, 3, len(s.entries))\n\t\tn, err := s.delete([]string{\"123-124\"})\n\t\tok(t, err)\n\t\tequals(t, 1, n)\n\t\tequals(t, 2, len(s.entries))\n\n\t\tn, err = s.delete([]string{\"9-9\"})\n\t\tok(t, err)\n\t\tequals(t, 0, n)\n\n\t\tn, err = s.delete([]string{\"999-999\"})\n\t\tok(t, err)\n\t\tequals(t, 0, n)\n\n\t\tequals(t, 2, len(s.entries))\n\t})\n}\n\nfunc TestStreamKeyGroup(t *testing.T) {\n\tnow := time.Now()\n\ts := newStreamKey()\n\t_, err := s.add(\"123-123\", []string{\"k\", \"v\"}, now)\n\tok(t, err)\n\n\tok(t, s.createGroup(\"mygroup\", \"$\"))\n\tg := s.groups[\"mygroup\"]\n\n\t{\n\t\ts.add(\"999-1\", []string{\"k\", \"v\"}, now)\n\t\tls := g.readGroup(now, \"consumer1\", \">\", 999, false)\n\t\tequals(t, 1, len(ls))\n\t}\n\n\t{\n\t\ts.add(\"999-2\", []string{\"k\", \"v\"}, now)\n\t\ts.add(\"999-3\", []string{\"k\", \"v\"}, now)\n\t\tls := g.readGroup(now, \"consumer1\", \">\", 1, false)\n\t\tequals(t, 1, len(ls))\n\t\tequalStr(t, \"999-2\", ls[0].ID)\n\t}\n\n\t// re-read unacked messages\n\t{\n\t\tls := g.readGroup(now, \"consumer1\", \"0-0\", 999, false)\n\t\tequals(t, 2, len(ls))\n\t\tequalStr(t, \"999-1\", ls[0].ID)\n\t\tequalStr(t, \"999-2\", ls[1].ID)\n\t}\n\n\t// ack\n\t{\n\t\tn, err := g.ack([]string{\"999-2\"})\n\t\tok(t, err)\n\t\tequals(t, 1, n)\n\t\tls := g.readGroup(now, \"consumer1\", \"0-0\", 999, false)\n\t\tequals(t, 1, len(ls))\n\t\tequalStr(t, \"999-1\", ls[0].ID)\n\t}\n\n\tt.Run(\"invalid acks\", func(t *testing.T) {\n\t\tn, err := g.ack([]string{\"99999-0\"})\n\t\tok(t, err)\n\t\tequals(t, 0, n)\n\t})\n\n\tt.Run(\"delete last ID\", func(t *testing.T) {\n\t\ts := newStreamKey()\n\t\ts.add(\"123-123\", []string{\"k\", \"v\"}, now)\n\t\tok(t, s.createGroup(\"mygroup\", \"$\"))\n\t\tg := s.groups[\"mygroup\"]\n\t\t_, err := s.delete([]string{\"123-123\"}) // !\n\t\tok(t, err)\n\n\t\tls := g.readGroup(now, \"consumer1\", \">\", 999, false)\n\t\tequals(t, 0, len(ls))\n\t})\n}\n"
        },
        {
          "name": "test_test.go",
          "type": "blob",
          "size": 3.009765625,
          "content": "package miniredis\n\nimport (\n\t\"math/rand\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/alicebob/miniredis/v2/proto\"\n)\n\n// assert fails the test if the condition is false.\nfunc assert(tb testing.TB, condition bool, msg string, v ...interface{}) {\n\ttb.Helper()\n\tif !condition {\n\t\ttb.Errorf(msg, v...)\n\t}\n}\n\n// ok fails the test if an err is not nil.\nfunc ok(tb testing.TB, err error) {\n\ttb.Helper()\n\tif err != nil {\n\t\ttb.Errorf(\"unexpected error: %s\", err.Error())\n\t}\n}\n\n// equals fails the test if exp is not equal to act.\nfunc equals(tb testing.TB, exp, act interface{}) {\n\ttb.Helper()\n\tif !reflect.DeepEqual(exp, act) {\n\t\ttb.Errorf(\"expected: %#v got: %#v\", exp, act)\n\t}\n}\n\nfunc equalStr(tb testing.TB, want, have string) {\n\ttb.Helper()\n\tif have != want {\n\t\ttb.Errorf(\"want: %q have: %q\", want, have)\n\t}\n}\n\n// mustFail compares the error strings\nfunc mustFail(tb testing.TB, err error, want string) {\n\ttb.Helper()\n\tif err == nil {\n\t\ttb.Errorf(\"expected an error, but got a nil\")\n\t\treturn\n\t}\n\n\tif have := err.Error(); have != want {\n\t\ttb.Errorf(\"have %q, want %q\", have, want)\n\t}\n}\n\n// execute a Do(args[,-1]...), which needs to be the same as the last arg.\nfunc mustDo(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\targs, want := args[:len(args)-1], args[len(args)-1]\n\n\tres, err := c.Do(args...)\n\tok(tb, err)\n\tequals(tb, want, res)\n}\n\n// mustOK is a mustDo() which expects an \"OK\" response\nfunc mustOK(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\tmustDo(tb, c, append(args, proto.Inline(\"OK\"))...)\n}\n\n// mustNil is a mustDo() which expects a nil response\nfunc mustNil(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\tmustDo(tb, c, append(args, proto.Nil)...)\n}\n\n// mustNilList is a mustDo() which expects a list nil (-1) response\nfunc mustNilList(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\tmustDo(tb, c, append(args, proto.NilList)...)\n}\n\n// must0 is a mustDo() which expects a `0` response\nfunc must0(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\tmustDo(tb, c, append(args, proto.Int(0))...)\n}\n\n// must1 is a mustDo() which expects a `1` response\nfunc must1(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\tmustDo(tb, c, append(args, proto.Int(1))...)\n}\n\n// execute a Read()\nfunc mustRead(tb testing.TB, c *proto.Client, want string) {\n\ttb.Helper()\n\tres, err := c.Read()\n\tok(tb, err)\n\tequals(tb, want, res)\n}\n\n// execute a Do(args[,-1]...), which result needs to Contain() the same as the last arg.\nfunc mustContain(tb testing.TB, c *proto.Client, args ...string) {\n\ttb.Helper()\n\targs, want := args[:len(args)-1], args[len(args)-1]\n\n\tres, err := c.Do(args...)\n\tok(tb, err)\n\tif !strings.Contains(res, want) {\n\t\ttb.Errorf(\"expected %q in %q\", want, res)\n\t}\n}\n\nfunc useRESP3(t *testing.T, c *proto.Client) {\n\tmustContain(t, c, \"HELLO\", \"3\", \"miniredis\")\n}\n\nconst letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nfunc randomStr(length int) string {\n\tb := make([]byte, length)\n\tfor i := range b {\n\t\tb[i] = letters[rand.Intn(len(letters))]\n\t}\n\treturn string(b)\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}