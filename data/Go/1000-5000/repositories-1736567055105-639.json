{
  "metadata": {
    "timestamp": 1736567055105,
    "page": 639,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gonum/plot",
      "stars": 2770,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".ci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".codecov.yml",
          "type": "blob",
          "size": 0.037109375,
          "content": "fixes:\n  - \"src/gonum.org/v1/plot/::\"\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.15625,
          "content": "**/*.svg\n**/*.png\n!**/testdata/*_golden.png\n!**/testdata/*_input.png\n!**/testdata/*_golden.svg\n**/*.eps\n**/*.pdf\n**/*.jpg\n**/*.jpeg\n**/*.tex\n**/*.tif\n**/*.tiff\n"
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.181640625,
          "content": "Ethan Burns <burns.ethan@gmail.com>\nSteve McCoy <mccoyst@gmail.com>\nDan Kortschak <dan.kortschak@adelaide.edu.au>\nJames Bell <james@stellentus.com>\nSebastien Binet <seb.binet@gmail.com>\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.1083984375,
          "content": "See the [gonum project-wide CONTRIBUTING.md file.](https://github.com/gonum/gonum/blob/master/CONTRIBUTING.md)\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.494140625,
          "content": "Copyright ©2013 The Gonum Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the Gonum project nor the names of its authors and\n      contributors may be used to endorse or promote products derived from this\n      software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.4443359375,
          "content": "# Gonum Plot\n\n[![Build status](https://github.com/gonum/plot/workflows/CI/badge.svg)](https://github.com/gonum/plot/actions)\n[![Build status](https://ci.appveyor.com/api/projects/status/6vtroet40gj5jhoe/branch/master?svg=true)](https://ci.appveyor.com/project/Gonum/plot/branch/master)\n[![codecov.io](https://codecov.io/gh/gonum/plot/branch/master/graph/badge.svg)](https://codecov.io/gh/gonum/plot)\n[![coveralls.io](https://coveralls.io/repos/gonum/plot/badge.svg?branch=master&service=github)](https://coveralls.io/github/gonum/plot?branch=master)\n[![GoDoc](https://godoc.org/gonum.org/v1/plot?status.svg)](https://godoc.org/gonum.org/v1/plot)\n[![go.dev reference](https://pkg.go.dev/badge/gonum.org/v1/plot)](https://pkg.go.dev/gonum.org/v1/plot)\n\n`gonum/plot` is the new, official fork of code.google.com/p/plotinum.\nIt provides an API for building and drawing plots in Go.\n*Note* that this new API is still in flux and may change.\nSee the wiki for some [example plots](http://github.com/gonum/plot/wiki/Example-plots).\n\nFor additional Plotters, see the [Community Plotters](https://github.com/gonum/plot/wiki/Community-Plotters) Wiki page.\n\nThere is a discussion list on Google Groups: gonum-dev@googlegroups.com.\n\n`gonum/plot` is split into a few packages:\n\n* The `plot` package provides simple interface for laying out a plot and provides primitives for drawing to it.\n* The `plotter` package provides a standard set of `Plotter`s which use the primitives provided by the `plot` package for drawing lines, scatter plots, box plots, error bars, etc. to a plot. You do not need to use the `plotter` package to make use of `gonum/plot`, however: see the wiki for a tutorial on making your own custom plotters.\n* The `plotutil` package contains a few routines that allow some common plot types to be made very easily. This package is quite new so it is not as well tested as the others and it is bound to change.\n* The `vg` package provides a generic vector graphics API that sits on top of other vector graphics back-ends such as a custom EPS back-end, draw2d, SVGo, X-Window, gopdf, and [Gio](https://gioui.org).\n\n## Documentation\n\nDocumentation is available at:\n\n  https://godoc.org/gonum.org/v1/plot\n\n## Installation\n\nYou can get `gonum/plot` using go get:\n\n`go get gonum.org/v1/plot/...`\n\nIf you write a cool plotter that you think others may be interested in using, please post to the list so that we can link to it in the `gonum/plot` wiki or possibly integrate it into the `plotter` package.\n"
        },
        {
          "name": "align.go",
          "type": "blob",
          "size": 3.50390625,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n)\n\n// Align returns a two-dimensional row-major array of Canvases which will\n// produce tiled plots with DataCanvases that are evenly sized and spaced.\n// The arguments to the function are a two-dimensional row-major array\n// of plots, a tile configuration, and the canvas to which the tiled\n// plots are to be drawn.\nfunc Align(plots [][]*Plot, t draw.Tiles, dc draw.Canvas) [][]draw.Canvas {\n\to := make([][]draw.Canvas, len(plots))\n\n\tif len(plots) != t.Rows {\n\t\tpanic(fmt.Errorf(\"plot: plots rows (%d) != tiles rows (%d)\", len(plots), t.Rows))\n\t}\n\n\t// Create the initial tiles.\n\tfor j := 0; j < t.Rows; j++ {\n\t\tif len(plots[j]) != t.Cols {\n\t\t\tpanic(fmt.Errorf(\"plot: plots row %d columns (%d) != tiles columns (%d)\", j, len(plots[j]), t.Rows))\n\t\t}\n\n\t\to[j] = make([]draw.Canvas, len(plots[j]))\n\t\tfor i := 0; i < t.Cols; i++ {\n\t\t\to[j][i] = t.At(dc, i, j)\n\t\t}\n\t}\n\n\ttype posNeg struct {\n\t\tp, n float64\n\t}\n\txSpacing := make([]posNeg, t.Cols)\n\tySpacing := make([]posNeg, t.Rows)\n\n\t// Calculate the maximum spacing between data canvases\n\t// for each row and column.\n\tfor j, row := range plots {\n\t\tfor i, p := range row {\n\t\t\tif p == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tc := o[j][i]\n\t\t\tdataC := p.DataCanvas(o[j][i])\n\t\t\txSpacing[i].n = math.Max(float64(dataC.Min.X-c.Min.X), xSpacing[i].n)\n\t\t\txSpacing[i].p = math.Max(float64(c.Max.X-dataC.Max.X), xSpacing[i].p)\n\t\t\tySpacing[j].n = math.Max(float64(dataC.Min.Y-c.Min.Y), ySpacing[j].n)\n\t\t\tySpacing[j].p = math.Max(float64(c.Max.Y-dataC.Max.Y), ySpacing[j].p)\n\t\t}\n\t}\n\n\t// Calculate the total row and column spacing.\n\tvar xTotalSpace float64\n\tfor _, s := range xSpacing {\n\t\txTotalSpace += s.n + s.p\n\t}\n\txTotalSpace += float64(t.PadX)*float64(len(xSpacing)-1) + float64(t.PadLeft+t.PadRight)\n\tvar yTotalSpace float64\n\tfor _, s := range ySpacing {\n\t\tyTotalSpace += s.n + s.p\n\t}\n\tyTotalSpace += float64(t.PadY)*float64(len(ySpacing)-1) + float64(t.PadTop+t.PadBottom)\n\n\tavgWidth := vg.Length((float64(dc.Max.X-dc.Min.X) - xTotalSpace) / float64(t.Cols))\n\tavgHeight := vg.Length((float64(dc.Max.Y-dc.Min.Y) - yTotalSpace) / float64(t.Rows))\n\n\tmoveVertical := make([]vg.Length, t.Cols)\n\tfor j := t.Rows - 1; j >= 0; j-- {\n\t\trow := plots[j]\n\t\tvar moveHorizontal vg.Length\n\t\tfor i, p := range row {\n\t\t\tc := o[j][i]\n\n\t\t\tif p != nil {\n\t\t\t\tdataC := p.DataCanvas(c)\n\t\t\t\t// Adjust the horizontal and vertical spacing between\n\t\t\t\t// canvases to match the maximum for each column and row,\n\t\t\t\t// respectively.\n\t\t\t\tc = draw.Crop(c,\n\t\t\t\t\tvg.Length(xSpacing[i].n)-(dataC.Min.X-c.Min.X),\n\t\t\t\t\tc.Max.X-dataC.Max.X-vg.Length(xSpacing[i].p),\n\t\t\t\t\tvg.Length(ySpacing[j].n)-(dataC.Min.Y-c.Min.Y),\n\t\t\t\t\tc.Max.Y-dataC.Max.Y-vg.Length(ySpacing[j].p),\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tvar width, height vg.Length\n\t\t\tif p == nil {\n\t\t\t\twidth = c.Max.X - c.Min.X - vg.Length(xSpacing[i].p+xSpacing[i].n)\n\t\t\t\theight = c.Max.Y - c.Min.Y - vg.Length(ySpacing[j].p+ySpacing[j].n)\n\t\t\t} else {\n\t\t\t\tdataC := p.DataCanvas(c)\n\t\t\t\twidth = dataC.Max.X - dataC.Min.X\n\t\t\t\theight = dataC.Max.Y - dataC.Min.Y\n\t\t\t}\n\n\t\t\t// Adjust the canvas so that the height and width of the\n\t\t\t// DataCanvas is the same for all plots.\n\t\t\to[j][i] = draw.Crop(c,\n\t\t\t\tmoveHorizontal,\n\t\t\t\tmoveHorizontal+avgWidth-width,\n\t\t\t\tmoveVertical[i],\n\t\t\t\tmoveVertical[i]+avgHeight-height,\n\t\t\t)\n\t\t\tmoveHorizontal += avgWidth - width\n\t\t\tmoveVertical[i] += avgHeight - height\n\t\t}\n\t}\n\treturn o\n}\n"
        },
        {
          "name": "align_example_test.go",
          "type": "blob",
          "size": 2.2890625,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot_test\n\nimport (\n\t\"log\"\n\t\"math\"\n\t\"os\"\n\n\t\"gonum.org/v1/plot\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n\t\"gonum.org/v1/plot/vg/vgimg\"\n)\n\nfunc ExampleAlign() {\n\tconst rows, cols = 4, 3\n\tplots := make([][]*plot.Plot, rows)\n\tfor j := 0; j < rows; j++ {\n\t\tplots[j] = make([]*plot.Plot, cols)\n\t\tfor i := 0; i < cols; i++ {\n\t\t\tif i == 0 && j == 2 {\n\t\t\t\t// This shows what happens when there are nil plots.\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tp := plot.New()\n\n\t\t\tif j == 0 && i == 2 {\n\t\t\t\t// This shows what happens when the axis padding\n\t\t\t\t// is different among plots.\n\t\t\t\tp.X.Padding, p.Y.Padding = 0, 0\n\t\t\t}\n\n\t\t\tif j == 1 && i == 1 {\n\t\t\t\t// To test the Align function, we make the axis labels\n\t\t\t\t// on one of the plots stick out.\n\t\t\t\tp.Y.Max = 1e9\n\t\t\t\tp.X.Max = 1e9\n\t\t\t\tp.X.Tick.Label.Rotation = math.Pi / 2\n\t\t\t\tp.X.Tick.Label.XAlign = draw.XRight\n\t\t\t\tp.X.Tick.Label.YAlign = draw.YCenter\n\t\t\t\tp.X.Tick.Label.Font.Size = 8\n\t\t\t\tp.Y.Tick.Label.Font.Size = 8\n\t\t\t} else {\n\t\t\t\tp.Y.Max = 1e9\n\t\t\t\tp.X.Max = 1e9\n\t\t\t\tp.X.Tick.Label.Font.Size = 1\n\t\t\t\tp.Y.Tick.Label.Font.Size = 1\n\t\t\t}\n\n\t\t\tplots[j][i] = p\n\t\t}\n\t}\n\n\timg := vgimg.New(vg.Points(150), vg.Points(175))\n\tdc := draw.New(img)\n\n\tt := draw.Tiles{\n\t\tRows:      rows,\n\t\tCols:      cols,\n\t\tPadX:      vg.Millimeter,\n\t\tPadY:      vg.Millimeter,\n\t\tPadTop:    vg.Points(2),\n\t\tPadBottom: vg.Points(2),\n\t\tPadLeft:   vg.Points(2),\n\t\tPadRight:  vg.Points(2),\n\t}\n\n\tcanvases := plot.Align(plots, t, dc)\n\tfor j := 0; j < rows; j++ {\n\t\tfor i := 0; i < cols; i++ {\n\t\t\tif plots[j][i] != nil {\n\t\t\t\tplots[j][i].Draw(canvases[j][i])\n\t\t\t}\n\t\t}\n\t}\n\n\tw, err := os.Create(\"testdata/align.png\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer w.Close()\n\tpng := vgimg.PngCanvas{Canvas: img}\n\tif _, err := png.WriteTo(w); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc ExampleAxis_labelsPosition() {\n\tp := plot.New()\n\tp.Title.Text = \"Title\"\n\tp.X.Label.Text = \"X [mm]\"\n\tp.Y.Label.Text = \"Y [A.U.]\"\n\tp.X.Label.Position = draw.PosRight\n\tp.Y.Label.Position = draw.PosTop\n\tp.X.Min = -10\n\tp.X.Max = +10\n\tp.Y.Min = -10\n\tp.Y.Max = +10\n\n\terr := p.Save(10*vg.Centimeter, 10*vg.Centimeter, \"testdata/axis_labels.png\")\n\tif err != nil {\n\t\tlog.Fatalf(\"could not save plot: %+v\", err)\n\t}\n}\n"
        },
        {
          "name": "align_test.go",
          "type": "blob",
          "size": 0.4140625,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot_test\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/plot/cmpimg\"\n)\n\nfunc TestAlign(t *testing.T) {\n\tcmpimg.CheckPlot(ExampleAlign, t, \"align.png\")\n}\n\nfunc TestAxisLabels(t *testing.T) {\n\tcmpimg.CheckPlot(ExampleAxis_labelsPosition, t, \"axis_labels.png\")\n}\n"
        },
        {
          "name": "appveyor.yml",
          "type": "blob",
          "size": 0.283203125,
          "content": "build: off\n\nimage: Visual Studio 2019\n\nstack: go 1.20\n\nclone_folder: c:\\gopath\\src\\gonum.org\\v1\\plot\n\ncache:\n  - '%LocalAppData%\\go-build'\n\nbranches:\n  only:\n    - master\n\nenvironment:\n  GO111MODULE: 'on'\n\nbuild_script:\n  - go version\n  - go get -v -t ./...\n\ntest_script:\n  - go test ./...\n"
        },
        {
          "name": "axis.go",
          "type": "blob",
          "size": 17.9013671875,
          "content": "// Copyright ©2015 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot\n\nimport (\n\t\"image/color\"\n\t\"math\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"gonum.org/v1/plot/font\"\n\t\"gonum.org/v1/plot/text\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n)\n\n// Ticker creates Ticks in a specified range\ntype Ticker interface {\n\t// Ticks returns Ticks in a specified range\n\tTicks(min, max float64) []Tick\n}\n\n// Normalizer rescales values from the data coordinate system to the\n// normalized coordinate system.\ntype Normalizer interface {\n\t// Normalize transforms a value x in the data coordinate system to\n\t// the normalized coordinate system.\n\tNormalize(min, max, x float64) float64\n}\n\n// An Axis represents either a horizontal or vertical\n// axis of a plot.\ntype Axis struct {\n\t// Min and Max are the minimum and maximum data\n\t// values represented by the axis.\n\tMin, Max float64\n\n\tLabel struct {\n\t\t// Text is the axis label string.\n\t\tText string\n\n\t\t// Padding is the distance between the label and the axis.\n\t\tPadding vg.Length\n\n\t\t// TextStyle is the style of the axis label text.\n\t\t// For the vertical axis, one quarter turn\n\t\t// counterclockwise will be added to the label\n\t\t// text before drawing.\n\t\tTextStyle text.Style\n\n\t\t// Position is where the axis label string should be drawn.\n\t\t// The default value is draw.PosCenter, displaying the label\n\t\t// at the center of the axis.\n\t\t// Valid values are [-1,+1], with +1 being the far right/top\n\t\t// of the axis, and -1 the far left/bottom of the axis.\n\t\tPosition float64\n\t}\n\n\t// LineStyle is the style of the axis line.\n\tdraw.LineStyle\n\n\t// Padding between the axis line and the data.  Having\n\t// non-zero padding ensures that the data is never drawn\n\t// on the axis, thus making it easier to see.\n\tPadding vg.Length\n\n\tTick struct {\n\t\t// Label is the TextStyle on the tick labels.\n\t\tLabel text.Style\n\n\t\t// LineStyle is the LineStyle of the tick lines.\n\t\tdraw.LineStyle\n\n\t\t// Length is the length of a major tick mark.\n\t\t// Minor tick marks are half of the length of major\n\t\t// tick marks.\n\t\tLength vg.Length\n\n\t\t// Marker returns the tick marks.  Any tick marks\n\t\t// returned by the Marker function that are not in\n\t\t// range of the axis are not drawn.\n\t\tMarker Ticker\n\t}\n\n\t// Scale transforms a value given in the data coordinate system\n\t// to the normalized coordinate system of the axis—its distance\n\t// along the axis as a fraction of the axis range.\n\tScale Normalizer\n\n\t// AutoRescale enables an axis to automatically adapt its minimum\n\t// and maximum boundaries, according to its underlying Ticker.\n\tAutoRescale bool\n}\n\n// makeAxis returns a default Axis.\n//\n// The default range is (∞, ­∞), and thus any finite\n// value is less than Min and greater than Max.\nfunc makeAxis(o orientation) Axis {\n\n\ta := Axis{\n\t\tMin: math.Inf(+1),\n\t\tMax: math.Inf(-1),\n\t\tLineStyle: draw.LineStyle{\n\t\t\tColor: color.Black,\n\t\t\tWidth: vg.Points(0.5),\n\t\t},\n\t\tPadding: vg.Points(5),\n\t\tScale:   LinearScale{},\n\t}\n\ta.Label.TextStyle = text.Style{\n\t\tColor:   color.Black,\n\t\tFont:    font.From(DefaultFont, 12),\n\t\tXAlign:  draw.XCenter,\n\t\tYAlign:  draw.YBottom,\n\t\tHandler: DefaultTextHandler,\n\t}\n\ta.Label.Position = draw.PosCenter\n\n\tvar (\n\t\txalign draw.XAlignment\n\t\tyalign draw.YAlignment\n\t)\n\tswitch o {\n\tcase vertical:\n\t\txalign = draw.XRight\n\t\tyalign = draw.YCenter\n\tcase horizontal:\n\t\txalign = draw.XCenter\n\t\tyalign = draw.YTop\n\t}\n\n\ta.Tick.Label = text.Style{\n\t\tColor:   color.Black,\n\t\tFont:    font.From(DefaultFont, 10),\n\t\tXAlign:  xalign,\n\t\tYAlign:  yalign,\n\t\tHandler: DefaultTextHandler,\n\t}\n\ta.Tick.LineStyle = draw.LineStyle{\n\t\tColor: color.Black,\n\t\tWidth: vg.Points(0.5),\n\t}\n\ta.Tick.Length = vg.Points(8)\n\ta.Tick.Marker = DefaultTicks{}\n\n\treturn a\n}\n\n// sanitizeRange ensures that the range of the\n// axis makes sense.\nfunc (a *Axis) sanitizeRange() {\n\tif math.IsInf(a.Min, 0) {\n\t\ta.Min = 0\n\t}\n\tif math.IsInf(a.Max, 0) {\n\t\ta.Max = 0\n\t}\n\tif a.Min > a.Max {\n\t\ta.Min, a.Max = a.Max, a.Min\n\t}\n\tif a.Min == a.Max {\n\t\ta.Min--\n\t\ta.Max++\n\t}\n\n\tif a.AutoRescale {\n\t\tmarks := a.Tick.Marker.Ticks(a.Min, a.Max)\n\t\tfor _, t := range marks {\n\t\t\ta.Min = math.Min(a.Min, t.Value)\n\t\t\ta.Max = math.Max(a.Max, t.Value)\n\t\t}\n\t}\n}\n\n// LinearScale an be used as the value of an Axis.Scale function to\n// set the axis to a standard linear scale.\ntype LinearScale struct{}\n\nvar _ Normalizer = LinearScale{}\n\n// Normalize returns the fractional distance of x between min and max.\nfunc (LinearScale) Normalize(min, max, x float64) float64 {\n\treturn (x - min) / (max - min)\n}\n\n// LogScale can be used as the value of an Axis.Scale function to\n// set the axis to a log scale.\ntype LogScale struct{}\n\nvar _ Normalizer = LogScale{}\n\n// Normalize returns the fractional logarithmic distance of\n// x between min and max.\nfunc (LogScale) Normalize(min, max, x float64) float64 {\n\tif min <= 0 || max <= 0 || x <= 0 {\n\t\tpanic(\"Values must be greater than 0 for a log scale.\")\n\t}\n\tlogMin := math.Log(min)\n\treturn (math.Log(x) - logMin) / (math.Log(max) - logMin)\n}\n\n// InvertedScale can be used as the value of an Axis.Scale function to\n// invert the axis using any Normalizer.\ntype InvertedScale struct{ Normalizer }\n\nvar _ Normalizer = InvertedScale{}\n\n// Normalize returns a normalized [0, 1] value for the position of x.\nfunc (is InvertedScale) Normalize(min, max, x float64) float64 {\n\treturn is.Normalizer.Normalize(max, min, x)\n}\n\n// Norm returns the value of x, given in the data coordinate\n// system, normalized to its distance as a fraction of the\n// range of this axis.  For example, if x is a.Min then the return\n// value is 0, and if x is a.Max then the return value is 1.\nfunc (a Axis) Norm(x float64) float64 {\n\treturn a.Scale.Normalize(a.Min, a.Max, x)\n}\n\n// drawTicks returns true if the tick marks should be drawn.\nfunc (a Axis) drawTicks() bool {\n\treturn a.Tick.Width > 0 && a.Tick.Length > 0\n}\n\n// A horizontalAxis draws horizontally across the bottom\n// of a plot.\ntype horizontalAxis struct {\n\tAxis\n}\n\n// size returns the height of the axis.\nfunc (a horizontalAxis) size() (h vg.Length) {\n\tif a.Label.Text != \"\" { // We assume that the label isn't rotated.\n\t\th += a.Label.TextStyle.Height(a.Label.Text)\n\t\th += a.Label.Padding\n\t}\n\n\tmarks := a.Tick.Marker.Ticks(a.Min, a.Max)\n\tif len(marks) > 0 {\n\t\tif a.drawTicks() {\n\t\t\th += a.Tick.Length\n\t\t}\n\t\th += tickLabelHeight(a.Tick.Label, marks)\n\t}\n\th += a.Width / 2\n\th += a.Padding\n\n\treturn h\n}\n\n// draw draws the axis along the lower edge of a draw.Canvas.\nfunc (a horizontalAxis) draw(c draw.Canvas) {\n\tvar (\n\t\tx vg.Length\n\t\ty = c.Min.Y\n\t)\n\tswitch a.Label.Position {\n\tcase draw.PosCenter:\n\t\tx = c.Center().X\n\tcase draw.PosRight:\n\t\tx = c.Max.X\n\t\tx -= a.Label.TextStyle.Width(a.Label.Text) / 2\n\t}\n\tif a.Label.Text != \"\" {\n\t\tdescent := a.Label.TextStyle.FontExtents().Descent\n\t\tc.FillText(a.Label.TextStyle, vg.Point{X: x, Y: y + descent}, a.Label.Text)\n\t\ty += a.Label.TextStyle.Height(a.Label.Text)\n\t\ty += a.Label.Padding\n\t}\n\n\tmarks := a.Tick.Marker.Ticks(a.Min, a.Max)\n\tticklabelheight := tickLabelHeight(a.Tick.Label, marks)\n\tdescent := a.Tick.Label.FontExtents().Descent\n\tfor _, t := range marks {\n\t\tx := c.X(a.Norm(t.Value))\n\t\tif !c.ContainsX(x) || t.IsMinor() {\n\t\t\tcontinue\n\t\t}\n\t\tc.FillText(a.Tick.Label, vg.Point{X: x, Y: y + ticklabelheight + descent}, t.Label)\n\t}\n\n\tif len(marks) > 0 {\n\t\ty += ticklabelheight\n\t} else {\n\t\ty += a.Width / 2\n\t}\n\n\tif len(marks) > 0 && a.drawTicks() {\n\t\tlen := a.Tick.Length\n\t\tfor _, t := range marks {\n\t\t\tx := c.X(a.Norm(t.Value))\n\t\t\tif !c.ContainsX(x) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tstart := t.lengthOffset(len)\n\t\t\tc.StrokeLine2(a.Tick.LineStyle, x, y+start, x, y+len)\n\t\t}\n\t\ty += len\n\t}\n\n\tc.StrokeLine2(a.LineStyle, c.Min.X, y, c.Max.X, y)\n}\n\n// GlyphBoxes returns the GlyphBoxes for the tick labels.\nfunc (a horizontalAxis) GlyphBoxes(p *Plot) []GlyphBox {\n\tvar (\n\t\tboxes []GlyphBox\n\t\tyoff  font.Length\n\t)\n\n\tif a.Label.Text != \"\" {\n\t\tx := a.Norm(p.X.Max)\n\t\tswitch a.Label.Position {\n\t\tcase draw.PosCenter:\n\t\t\tx = a.Norm(0.5 * (p.X.Max + p.X.Min))\n\t\tcase draw.PosRight:\n\t\t\tx -= a.Norm(0.5 * a.Label.TextStyle.Width(a.Label.Text).Points()) // FIXME(sbinet): want data coordinates\n\t\t}\n\t\tdescent := a.Label.TextStyle.FontExtents().Descent\n\t\tboxes = append(boxes, GlyphBox{\n\t\t\tX:         x,\n\t\t\tRectangle: a.Label.TextStyle.Rectangle(a.Label.Text).Add(vg.Point{Y: yoff + descent}),\n\t\t})\n\t\tyoff += a.Label.TextStyle.Height(a.Label.Text)\n\t\tyoff += a.Label.Padding\n\t}\n\n\tvar (\n\t\tmarks   = a.Tick.Marker.Ticks(a.Min, a.Max)\n\t\theight  = tickLabelHeight(a.Tick.Label, marks)\n\t\tdescent = a.Tick.Label.FontExtents().Descent\n\t)\n\tfor _, t := range marks {\n\t\tif t.IsMinor() {\n\t\t\tcontinue\n\t\t}\n\t\tbox := GlyphBox{\n\t\t\tX:         a.Norm(t.Value),\n\t\t\tRectangle: a.Tick.Label.Rectangle(t.Label).Add(vg.Point{Y: yoff + height + descent}),\n\t\t}\n\t\tboxes = append(boxes, box)\n\t}\n\treturn boxes\n}\n\n// A verticalAxis is drawn vertically up the left side of a plot.\ntype verticalAxis struct {\n\tAxis\n}\n\n// size returns the width of the axis.\nfunc (a verticalAxis) size() (w vg.Length) {\n\tif a.Label.Text != \"\" { // We assume that the label isn't rotated.\n\t\tw += a.Label.TextStyle.FontExtents().Descent\n\t\tw += a.Label.TextStyle.Height(a.Label.Text)\n\t\tw += a.Label.Padding\n\t}\n\n\tmarks := a.Tick.Marker.Ticks(a.Min, a.Max)\n\tif len(marks) > 0 {\n\t\tif lwidth := tickLabelWidth(a.Tick.Label, marks); lwidth > 0 {\n\t\t\tw += lwidth\n\t\t\tw += a.Label.TextStyle.Width(\" \")\n\t\t}\n\t\tif a.drawTicks() {\n\t\t\tw += a.Tick.Length\n\t\t}\n\t}\n\tw += a.Width / 2\n\tw += a.Padding\n\n\treturn w\n}\n\n// draw draws the axis along the left side of a draw.Canvas.\nfunc (a verticalAxis) draw(c draw.Canvas) {\n\tvar (\n\t\tx = c.Min.X\n\t\ty vg.Length\n\t)\n\tif a.Label.Text != \"\" {\n\t\tsty := a.Label.TextStyle\n\t\tsty.Rotation += math.Pi / 2\n\t\tx += a.Label.TextStyle.Height(a.Label.Text)\n\t\tswitch a.Label.Position {\n\t\tcase draw.PosCenter:\n\t\t\ty = c.Center().Y\n\t\tcase draw.PosTop:\n\t\t\ty = c.Max.Y\n\t\t\ty -= a.Label.TextStyle.Width(a.Label.Text) / 2\n\t\t}\n\t\tdescent := a.Label.TextStyle.FontExtents().Descent\n\t\tc.FillText(sty, vg.Point{X: x - descent, Y: y}, a.Label.Text)\n\t\tx += descent\n\t\tx += a.Label.Padding\n\t}\n\tmarks := a.Tick.Marker.Ticks(a.Min, a.Max)\n\tif w := tickLabelWidth(a.Tick.Label, marks); len(marks) > 0 && w > 0 {\n\t\tx += w\n\t}\n\n\tmajor := false\n\tdescent := a.Tick.Label.FontExtents().Descent\n\tfor _, t := range marks {\n\t\ty := c.Y(a.Norm(t.Value))\n\t\tif !c.ContainsY(y) || t.IsMinor() {\n\t\t\tcontinue\n\t\t}\n\t\tc.FillText(a.Tick.Label, vg.Point{X: x, Y: y + descent}, t.Label)\n\t\tmajor = true\n\t}\n\tif major {\n\t\tx += a.Tick.Label.Width(\" \")\n\t}\n\tif a.drawTicks() && len(marks) > 0 {\n\t\tlen := a.Tick.Length\n\t\tfor _, t := range marks {\n\t\t\ty := c.Y(a.Norm(t.Value))\n\t\t\tif !c.ContainsY(y) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tstart := t.lengthOffset(len)\n\t\t\tc.StrokeLine2(a.Tick.LineStyle, x+start, y, x+len, y)\n\t\t}\n\t\tx += len\n\t}\n\n\tc.StrokeLine2(a.LineStyle, x, c.Min.Y, x, c.Max.Y)\n}\n\n// GlyphBoxes returns the GlyphBoxes for the tick labels\nfunc (a verticalAxis) GlyphBoxes(p *Plot) []GlyphBox {\n\tvar (\n\t\tboxes []GlyphBox\n\t\txoff  font.Length\n\t)\n\n\tif a.Label.Text != \"\" {\n\t\tyoff := a.Norm(p.Y.Max)\n\t\tswitch a.Label.Position {\n\t\tcase draw.PosCenter:\n\t\t\tyoff = a.Norm(0.5 * (p.Y.Max + p.Y.Min))\n\t\tcase draw.PosTop:\n\t\t\tyoff -= a.Norm(0.5 * a.Label.TextStyle.Width(a.Label.Text).Points()) // FIXME(sbinet): want data coordinates\n\t\t}\n\n\t\tsty := a.Label.TextStyle\n\t\tsty.Rotation += math.Pi / 2\n\n\t\txoff += a.Label.TextStyle.Height(a.Label.Text)\n\t\tdescent := a.Label.TextStyle.FontExtents().Descent\n\t\tboxes = append(boxes, GlyphBox{\n\t\t\tY:         yoff,\n\t\t\tRectangle: sty.Rectangle(a.Label.Text).Add(vg.Point{X: xoff - descent}),\n\t\t})\n\t\txoff += descent\n\t\txoff += a.Label.Padding\n\t}\n\n\tmarks := a.Tick.Marker.Ticks(a.Min, a.Max)\n\tif w := tickLabelWidth(a.Tick.Label, marks); len(marks) != 0 && w > 0 {\n\t\txoff += w\n\t}\n\n\tvar (\n\t\text  = a.Tick.Label.FontExtents()\n\t\tdesc = ext.Height - ext.Ascent // descent + linegap\n\t)\n\tfor _, t := range marks {\n\t\tif t.IsMinor() {\n\t\t\tcontinue\n\t\t}\n\t\tbox := GlyphBox{\n\t\t\tY:         a.Norm(t.Value),\n\t\t\tRectangle: a.Tick.Label.Rectangle(t.Label).Add(vg.Point{X: xoff, Y: desc}),\n\t\t}\n\t\tboxes = append(boxes, box)\n\t}\n\treturn boxes\n}\n\n// DefaultTicks is suitable for the Tick.Marker field of an Axis,\n// it returns a reasonable default set of tick marks.\ntype DefaultTicks struct{}\n\nvar _ Ticker = DefaultTicks{}\n\n// Ticks returns Ticks in the specified range.\nfunc (DefaultTicks) Ticks(min, max float64) []Tick {\n\tif max <= min {\n\t\tpanic(\"illegal range\")\n\t}\n\n\tconst suggestedTicks = 3\n\n\tlabels, step, q, mag := talbotLinHanrahan(min, max, suggestedTicks, withinData, nil, nil, nil)\n\tmajorDelta := step * math.Pow10(mag)\n\tif q == 0 {\n\t\t// Simple fall back was chosen, so\n\t\t// majorDelta is the label distance.\n\t\tmajorDelta = labels[1] - labels[0]\n\t}\n\n\t// Choose a reasonable, but ad\n\t// hoc formatting for labels.\n\tfc := byte('f')\n\tvar off int\n\tif mag < -1 || 6 < mag {\n\t\toff = 1\n\t\tfc = 'g'\n\t}\n\tif math.Trunc(q) != q {\n\t\toff += 2\n\t}\n\tprec := minInt(6, maxInt(off, -mag))\n\tticks := make([]Tick, len(labels))\n\tfor i, v := range labels {\n\t\tticks[i] = Tick{Value: v, Label: strconv.FormatFloat(v, fc, prec, 64)}\n\t}\n\n\tvar minorDelta float64\n\t// See talbotLinHanrahan for the values used here.\n\tswitch step {\n\tcase 1, 2.5:\n\t\tminorDelta = majorDelta / 5\n\tcase 2, 3, 4, 5:\n\t\tminorDelta = majorDelta / step\n\tdefault:\n\t\tif majorDelta/2 < dlamchP {\n\t\t\treturn ticks\n\t\t}\n\t\tminorDelta = majorDelta / 2\n\t}\n\n\t// Find the first minor tick not greater\n\t// than the lowest data value.\n\tvar i float64\n\tfor labels[0]+(i-1)*minorDelta > min {\n\t\ti--\n\t}\n\t// Add ticks at minorDelta intervals when\n\t// they are not within minorDelta/2 of a\n\t// labelled tick.\n\tfor {\n\t\tval := labels[0] + i*minorDelta\n\t\tif val > max {\n\t\t\tbreak\n\t\t}\n\t\tfound := false\n\t\tfor _, t := range ticks {\n\t\t\tif math.Abs(t.Value-val) < minorDelta/2 {\n\t\t\t\tfound = true\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tticks = append(ticks, Tick{Value: val})\n\t\t}\n\t\ti++\n\t}\n\n\treturn ticks\n}\n\nfunc minInt(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc maxInt(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\n// LogTicks is suitable for the Tick.Marker field of an Axis,\n// it returns tick marks suitable for a log-scale axis.\ntype LogTicks struct {\n\t// Prec specifies the precision of tick rendering\n\t// according to the documentation for strconv.FormatFloat.\n\tPrec int\n}\n\nvar _ Ticker = LogTicks{}\n\n// Ticks returns Ticks in a specified range\nfunc (t LogTicks) Ticks(min, max float64) []Tick {\n\tif min <= 0 || max <= 0 {\n\t\tpanic(\"Values must be greater than 0 for a log scale.\")\n\t}\n\n\tval := math.Pow10(int(math.Log10(min)))\n\tmax = math.Pow10(int(math.Ceil(math.Log10(max))))\n\tvar ticks []Tick\n\tfor val < max {\n\t\tfor i := 1; i < 10; i++ {\n\t\t\tif i == 1 {\n\t\t\t\tticks = append(ticks, Tick{Value: val, Label: formatFloatTick(val, t.Prec)})\n\t\t\t}\n\t\t\tticks = append(ticks, Tick{Value: val * float64(i)})\n\t\t}\n\t\tval *= 10\n\t}\n\tticks = append(ticks, Tick{Value: val, Label: formatFloatTick(val, t.Prec)})\n\n\treturn ticks\n}\n\n// ConstantTicks is suitable for the Tick.Marker field of an Axis.\n// This function returns the given set of ticks.\ntype ConstantTicks []Tick\n\nvar _ Ticker = ConstantTicks{}\n\n// Ticks returns Ticks in a specified range\nfunc (ts ConstantTicks) Ticks(float64, float64) []Tick {\n\treturn ts\n}\n\n// UnixTimeIn returns a time conversion function for the given location.\nfunc UnixTimeIn(loc *time.Location) func(t float64) time.Time {\n\treturn func(t float64) time.Time {\n\t\treturn time.Unix(int64(t), 0).In(loc)\n\t}\n}\n\n// UTCUnixTime is the default time conversion for TimeTicks.\nvar UTCUnixTime = UnixTimeIn(time.UTC)\n\n// TimeTicks is suitable for axes representing time values.\ntype TimeTicks struct {\n\t// Ticker is used to generate a set of ticks.\n\t// If nil, DefaultTicks will be used.\n\tTicker Ticker\n\n\t// Format is the textual representation of the time value.\n\t// If empty, time.RFC3339 will be used\n\tFormat string\n\n\t// Time takes a float64 value and converts it into a time.Time.\n\t// If nil, UTCUnixTime is used.\n\tTime func(t float64) time.Time\n}\n\nvar _ Ticker = TimeTicks{}\n\n// Ticks implements plot.Ticker.\nfunc (t TimeTicks) Ticks(min, max float64) []Tick {\n\tif t.Ticker == nil {\n\t\tt.Ticker = DefaultTicks{}\n\t}\n\tif t.Format == \"\" {\n\t\tt.Format = time.RFC3339\n\t}\n\tif t.Time == nil {\n\t\tt.Time = UTCUnixTime\n\t}\n\n\tticks := t.Ticker.Ticks(min, max)\n\tfor i := range ticks {\n\t\ttick := &ticks[i]\n\t\tif tick.Label == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\ttick.Label = t.Time(tick.Value).Format(t.Format)\n\t}\n\treturn ticks\n}\n\n// A Tick is a single tick mark on an axis.\ntype Tick struct {\n\t// Value is the data value marked by this Tick.\n\tValue float64\n\n\t// Label is the text to display at the tick mark.\n\t// If Label is an empty string then this is a minor\n\t// tick mark.\n\tLabel string\n}\n\n// IsMinor returns true if this is a minor tick mark.\nfunc (t Tick) IsMinor() bool {\n\treturn t.Label == \"\"\n}\n\n// lengthOffset returns an offset that should be added to the\n// tick mark's line to accout for its length.  I.e., the start of\n// the line for a minor tick mark must be shifted by half of\n// the length.\nfunc (t Tick) lengthOffset(len vg.Length) vg.Length {\n\tif t.IsMinor() {\n\t\treturn len / 2\n\t}\n\treturn 0\n}\n\n// tickLabelHeight returns height of the tick mark labels.\nfunc tickLabelHeight(sty text.Style, ticks []Tick) vg.Length {\n\tmaxHeight := vg.Length(0)\n\tfor _, t := range ticks {\n\t\tif t.IsMinor() {\n\t\t\tcontinue\n\t\t}\n\t\tr := sty.Rectangle(t.Label)\n\t\th := r.Max.Y - r.Min.Y\n\t\tif h > maxHeight {\n\t\t\tmaxHeight = h\n\t\t}\n\t}\n\treturn maxHeight\n}\n\n// tickLabelWidth returns the width of the widest tick mark label.\nfunc tickLabelWidth(sty text.Style, ticks []Tick) vg.Length {\n\tmaxWidth := vg.Length(0)\n\tfor _, t := range ticks {\n\t\tif t.IsMinor() {\n\t\t\tcontinue\n\t\t}\n\t\tr := sty.Rectangle(t.Label)\n\t\tw := r.Max.X - r.Min.X\n\t\tif w > maxWidth {\n\t\t\tmaxWidth = w\n\t\t}\n\t}\n\treturn maxWidth\n}\n\n// formatFloatTick returns a g-formated string representation of v\n// to the specified precision.\nfunc formatFloatTick(v float64, prec int) string {\n\treturn strconv.FormatFloat(v, 'g', prec, 64)\n}\n\n// TickerFunc is suitable for the Tick.Marker field of an Axis.\n// It is an adapter which allows to quickly setup a Ticker using a function with an appropriate signature.\ntype TickerFunc func(min, max float64) []Tick\n\nvar _ Ticker = TickerFunc(nil)\n\n// Ticks implements plot.Ticker.\nfunc (f TickerFunc) Ticks(min, max float64) []Tick {\n\treturn f(min, max)\n}\n"
        },
        {
          "name": "axis_test.go",
          "type": "blob",
          "size": 4.4775390625,
          "content": "// Copyright ©2015 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"gonum.org/v1/plot/cmpimg\"\n\t\"gonum.org/v1/plot/vg\"\n)\n\nvar axisSmallTickTests = []struct {\n\tmin, max   float64\n\twantValues []float64\n\twantLabels []string\n}{\n\t{\n\t\tmin:        -1.9846500878911073,\n\t\tmax:        0.4370974820125605,\n\t\twantValues: []float64{-1.75, -0.75, 0.25},\n\t\twantLabels: []string{\"-1.75\", \"-0.75\", \"0.25\"},\n\t},\n\t{\n\t\tmin:        -1.985e15,\n\t\tmax:        0.4371e15,\n\t\twantValues: []float64{-1.75e15, -7.5e14, 2.5e14},\n\t\twantLabels: []string{\"-1.75e+15\", \"-7.5e+14\", \"2.5e+14\"},\n\t},\n\t{\n\t\tmin:        -1.985e-15,\n\t\tmax:        0.4371e-15,\n\t\twantValues: []float64{-1.985e-15, -7.739500000000001e-16, 4.3709999999999994e-16},\n\t\twantLabels: []string{\"-1.985e-15\", \"-7.7395e-16\", \"4.371e-16\"},\n\t},\n\t{\n\t\tmin:        math.MaxFloat64 / 4,\n\t\tmax:        math.MaxFloat64 / 3,\n\t\twantValues: []float64{4.4942328371557893e+307, 5.243271643348421e+307, 5.992310449541053e+307},\n\t\twantLabels: []string{\"4e+307\", \"5e+307\", \"6e+307\"},\n\t},\n\t{\n\t\tmin:        0.00010,\n\t\tmax:        0.00015,\n\t\twantValues: []float64{0.0001, 0.00012, 0.00014000000000000001},\n\t\twantLabels: []string{\"0.0001\", \"0.00012\", \"0.00014\"},\n\t},\n\t{\n\t\tmin:        555.6545,\n\t\tmax:        21800.9875,\n\t\twantValues: []float64{4000, 12000, 20000},\n\t\twantLabels: []string{\"4000\", \"12000\", \"20000\"},\n\t},\n\t{\n\t\tmin:        555.6545,\n\t\tmax:        27800.9875,\n\t\twantValues: []float64{5000, 15000, 25000},\n\t\twantLabels: []string{\"5000\", \"15000\", \"25000\"},\n\t},\n\t{\n\t\tmin:        55.6545,\n\t\tmax:        1555.9875,\n\t\twantValues: []float64{300, 900, 1500},\n\t\twantLabels: []string{\"300\", \"900\", \"1500\"},\n\t},\n\t{\n\t\tmin:        3.096916 - 0.125,\n\t\tmax:        3.096916 + 0.125,\n\t\twantValues: []float64{3, 3.1, 3.2},\n\t\twantLabels: []string{\"3.0\", \"3.1\", \"3.2\"},\n\t},\n}\n\nfunc TestAxisSmallTick(t *testing.T) {\n\td := DefaultTicks{}\n\tfor i, test := range axisSmallTickTests {\n\t\tticks := d.Ticks(test.min, test.max)\n\t\tgotLabels := labelsOf(ticks)\n\t\tgotValues := valuesOf(ticks)\n\t\tif !reflect.DeepEqual(gotValues, test.wantValues) {\n\t\t\tt.Errorf(\"tick values mismatch %d:\\ngot: %v\\nwant:%v\", i, gotValues, test.wantValues)\n\t\t}\n\t\tif !reflect.DeepEqual(gotLabels, test.wantLabels) {\n\t\t\tt.Errorf(\"tick labels mismatch %d:\\ngot: %q\\nwant:%q\", i, gotLabels, test.wantLabels)\n\t\t}\n\t}\n}\n\nfunc valuesOf(ticks []Tick) []float64 {\n\tvar values []float64\n\tfor _, t := range ticks {\n\t\tif t.Label != \"\" {\n\t\t\tvalues = append(values, t.Value)\n\t\t}\n\t}\n\treturn values\n}\n\nfunc labelsOf(ticks []Tick) []string {\n\tvar labels []string\n\tfor _, t := range ticks {\n\t\tif t.Label != \"\" {\n\t\t\tlabels = append(labels, t.Label)\n\t\t}\n\t}\n\treturn labels\n}\n\nfunc TestTickerFunc_Ticks(t *testing.T) {\n\ttype args struct {\n\t\tmin float64\n\t\tmax float64\n\t}\n\ttests := []struct {\n\t\tname string\n\t\targs args\n\t\twant []Tick\n\t\tf    TickerFunc\n\t}{\n\t\t{\n\t\t\tname: \"return exactly the same ticks as the function passed to TickerFunc\",\n\t\t\targs: args{0, 3},\n\t\t\twant: []Tick{{1, \"a\"}, {2, \"b\"}},\n\t\t\tf: func(min, max float64) []Tick {\n\t\t\t\treturn []Tick{{1, \"a\"}, {2, \"b\"}}\n\t\t\t},\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := tt.f.Ticks(tt.args.min, tt.args.max); !reflect.DeepEqual(got, tt.want) {\n\t\t\t\tt.Errorf(\"TickerFunc.Ticks() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestInvertedScale_Normalize(t *testing.T) {\n\tinverter := InvertedScale{Normalizer: LinearScale{}}\n\tif got := inverter.Normalize(0, 1, 1); got != 0.0 {\n\t\tt.Errorf(\"Expected a normalization inversion %f->%f not %f\", 1.0, 0.0, got)\n\t}\n\tif got := inverter.Normalize(0, 1, .5); got != 0.5 {\n\t\tt.Errorf(\"Expected a normalization inversion %f->%f not %f\", 0.5, 0.5, got)\n\t}\n\tif got := inverter.Normalize(0, 1, 0); got != 1.0 {\n\t\tt.Errorf(\"Expected a normalization inversion %f->%f not %f\", 0.0, 1.0, got)\n\t}\n}\n\nfunc TestAxisPadding(t *testing.T) {\n\tfor _, padding := range []int{0, 5, 10} {\n\t\tt.Run(fmt.Sprintf(\"padding-%d\", padding), func(t *testing.T) {\n\t\t\tcmpimg.CheckPlot(func() {\n\t\t\t\tp := New()\n\t\t\t\tp.Title.Text = fmt.Sprintf(\"padding=%d\", padding)\n\t\t\t\tp.X.Label.Text = \"X-Axis\"\n\t\t\t\tp.X.Label.Padding = vg.Points(float64(padding))\n\t\t\t\tp.Y.Label.Text = \"Y-Axis\"\n\t\t\t\tp.Y.Label.Padding = vg.Points(float64(padding))\n\n\t\t\t\tconst size = 5 * vg.Centimeter\n\t\t\t\terr := p.Save(size, size, fmt.Sprintf(\"testdata/axis_padding_%02d.png\", padding))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"error: %+v\", err)\n\t\t\t\t}\n\t\t\t}, t, fmt.Sprintf(\"axis_padding_%02d.png\", padding))\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "cmpimg",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.7236328125,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package plot provides an API for setting up plots, and primitives for\n// drawing on plots.\n//\n// Plot is the basic type for creating a plot, setting the title, axis\n// labels, legend, tick marks, etc.  Types implementing the Plotter\n// interface can draw to the data area of a plot using the primitives\n// made available by this package.  Some standard implementations\n// of the Plotter interface can be found in the\n// gonum.org/v1/plot/plotter package\n// which is documented here:\n// https://godoc.org/gonum.org/v1/plot/plotter\npackage plot // import \"gonum.org/v1/plot\"\n"
        },
        {
          "name": "font",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.029296875,
          "content": "module gonum.org/v1/plot\n\ngo 1.22.0\n\nrequire (\n\tgioui.org v0.2.0\n\tgioui.org/x v0.2.0\n\tgit.sr.ht/~sbinet/gg v0.6.0\n\tgithub.com/ajstarks/svgo v0.0.0-20211024235047-1546f124cd8b\n\tgithub.com/andybalholm/stroke v0.0.0-20221221101821-bd29b49d73f0\n\tgithub.com/go-fonts/latin-modern v0.3.3\n\tgithub.com/go-fonts/liberation v0.3.3\n\tgithub.com/go-latex/latex v0.0.0-20240709081214-31cef3c7570e\n\tgithub.com/go-pdf/fpdf v0.9.0\n\tgolang.org/x/exp v0.0.0-20241009180824-f66d83c29e7c\n\tgolang.org/x/image v0.21.0\n\tgonum.org/v1/gonum v0.15.1\n\trsc.io/pdf v0.1.1\n)\n\nrequire (\n\tgioui.org/cpu v0.0.0-20220412190645-f1e9e8c3b1f7 // indirect\n\tgioui.org/shader v1.0.6 // indirect\n\tgithub.com/campoy/embedmd v1.0.0 // indirect\n\tgithub.com/go-text/typesetting v0.0.0-20230803102845-24e03d8b5372 // indirect\n\tgithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgolang.org/x/exp/shiny v0.0.0-20241009180824-f66d83c29e7c // indirect\n\tgolang.org/x/sys v0.26.0 // indirect\n\tgolang.org/x/text v0.19.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 7.4609375,
          "content": "eliasnaur.com/font v0.0.0-20230308162249-dd43949cb42d h1:ARo7NCVvN2NdhLlJE9xAbKweuI9L6UgfTbYb0YwPacY=\neliasnaur.com/font v0.0.0-20230308162249-dd43949cb42d/go.mod h1:OYVuxibdk9OSLX8vAqydtRPP87PyTFcT9uH3MlEGBQA=\ngioui.org v0.2.0 h1:RbzDn1h/pCVf/q44ImQSa/J3MIFpY3OWphzT/Tyei+w=\ngioui.org v0.2.0/go.mod h1:1H72sKEk/fNFV+l0JNeM2Dt3co3Y4uaQcD+I+/GQ0e4=\ngioui.org/cpu v0.0.0-20210808092351-bfe733dd3334/go.mod h1:A8M0Cn5o+vY5LTMlnRoK3O5kG+rH0kWfJjeKd9QpBmQ=\ngioui.org/cpu v0.0.0-20220412190645-f1e9e8c3b1f7 h1:tNJdnP5CgM39PRc+KWmBRRYX/zJ+rd5XaYxY5d5veqA=\ngioui.org/cpu v0.0.0-20220412190645-f1e9e8c3b1f7/go.mod h1:A8M0Cn5o+vY5LTMlnRoK3O5kG+rH0kWfJjeKd9QpBmQ=\ngioui.org/shader v1.0.6 h1:cvZmU+eODFR2545X+/8XucgZdTtEjR3QWW6W65b0q5Y=\ngioui.org/shader v1.0.6/go.mod h1:mWdiME581d/kV7/iEhLmUgUK5iZ09XR5XpduXzbePVM=\ngioui.org/x v0.2.0 h1:/MbdjKH19F16auv19UiQxli2n6BYPw7eyh9XBOTgmEw=\ngioui.org/x v0.2.0/go.mod h1:rCGN2nZ8ZHqrtseJoQxCMZpt2xrZUrdZ2WuMRLBJmYs=\ngit.sr.ht/~sbinet/cmpimg v0.1.0 h1:E0zPRk2muWuCqSKSVZIWsgtU9pjsw3eKHi8VmQeScxo=\ngit.sr.ht/~sbinet/cmpimg v0.1.0/go.mod h1:FU12psLbF4TfNXkKH2ZZQ29crIqoiqTZmeQ7dkp/pxE=\ngit.sr.ht/~sbinet/gg v0.6.0 h1:RIzgkizAk+9r7uPzf/VfbJHBMKUr0F5hRFxTUGMnt38=\ngit.sr.ht/~sbinet/gg v0.6.0/go.mod h1:uucygbfC9wVPQIfrmwM2et0imr8L7KQWywX0xpFMm94=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/ajstarks/deck v0.0.0-20200831202436-30c9fc6549a9/go.mod h1:JynElWSGnm/4RlzPXRlREEwqTHAN3T56Bv2ITsFT3gY=\ngithub.com/ajstarks/deck/generate v0.0.0-20210309230005-c3f852c02e19/go.mod h1:T13YZdzov6OU0A1+RfKZiZN9ca6VeKdBdyDV+BY97Tk=\ngithub.com/ajstarks/svgo v0.0.0-20211024235047-1546f124cd8b h1:slYM766cy2nI3BwyRiyQj/Ud48djTMtMebDqepE95rw=\ngithub.com/ajstarks/svgo v0.0.0-20211024235047-1546f124cd8b/go.mod h1:1KcenG0jGWcpt8ov532z81sp/kMMUG485J2InIOyADM=\ngithub.com/andybalholm/stroke v0.0.0-20221221101821-bd29b49d73f0 h1:uF5Q/hWnDU1XZeT6CsrRSxHLroUSEYYO3kgES+yd+So=\ngithub.com/andybalholm/stroke v0.0.0-20221221101821-bd29b49d73f0/go.mod h1:ccdDYaY5+gO+cbnQdFxEXqfy0RkoV25H3jLXUDNM3wg=\ngithub.com/campoy/embedmd v1.0.0 h1:V4kI2qTJJLf4J29RzI/MAt2c3Bl4dQSYPuflzwFH2hY=\ngithub.com/campoy/embedmd v1.0.0/go.mod h1:oxyr9RCiSXg0M3VJ3ks0UGfp98BpSSGr0kpiX3MzVl8=\ngithub.com/go-fonts/dejavu v0.3.4 h1:Qqyx9IOs5CQFxyWTdvddeWzrX0VNwUAvbmAzL0fpjbc=\ngithub.com/go-fonts/dejavu v0.3.4/go.mod h1:D1z0DglIz+lmpeNYMYlxW4r22IhcdOYnt+R3PShU/Kg=\ngithub.com/go-fonts/latin-modern v0.3.3 h1:g2xNgI8yzdNzIVm+qvbMryB6yGPe0pSMss8QT3QwlJ0=\ngithub.com/go-fonts/latin-modern v0.3.3/go.mod h1:tHaiWDGze4EPB0Go4cLT5M3QzRY3peya09Z/8KSCrpY=\ngithub.com/go-fonts/liberation v0.3.3 h1:tM/T2vEOhjia6v5krQu8SDDegfH1SfXVRUNNKpq0Usk=\ngithub.com/go-fonts/liberation v0.3.3/go.mod h1:eUAzNRuJnpSnd1sm2EyloQfSOT79pdw7X7++Ri+3MCU=\ngithub.com/go-latex/latex v0.0.0-20240709081214-31cef3c7570e h1:xcdj0LWnMSIU1j8+jIeJyfvk6SjgJedFQssSqFthJ2E=\ngithub.com/go-latex/latex v0.0.0-20240709081214-31cef3c7570e/go.mod h1:J4SAGzkcl+28QWi7yz72tyC/4aGnppOvya+AEv4TaAQ=\ngithub.com/go-pdf/fpdf v0.9.0 h1:PPvSaUuo1iMi9KkaAn90NuKi+P4gwMedWPHhj8YlJQw=\ngithub.com/go-pdf/fpdf v0.9.0/go.mod h1:oO8N111TkmKb9D7VvWGLvLJlaZUQVPM+6V42pp3iV4Y=\ngithub.com/go-text/typesetting v0.0.0-20230803102845-24e03d8b5372 h1:FQivqchis6bE2/9uF70M2gmmLpe82esEm2QadL0TEJo=\ngithub.com/go-text/typesetting v0.0.0-20230803102845-24e03d8b5372/go.mod h1:evDBbvNR/KaVFZ2ZlDSOWWXIUKq0wCOEtzLxRM8SG3k=\ngithub.com/go-text/typesetting-utils v0.0.0-20230616150549-2a7df14b6a22 h1:LBQTFxP2MfsyEDqSKmUBZaDuDHN1vpqDyOZjcqS7MYI=\ngithub.com/go-text/typesetting-utils v0.0.0-20230616150549-2a7df14b6a22/go.mod h1:DDxDdQEnB70R8owOx3LVpEFvpMK9eeH1o2r0yZhFI9o=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0 h1:DACJavvAHhabrF08vX0COfcOBJRhZ8lUbR+ZWIs0Y5g=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/exp v0.0.0-20241009180824-f66d83c29e7c h1:7dEasQXItcW1xKJ2+gg5VOiBnqWrJc+rq0DPKyvvdbY=\ngolang.org/x/exp v0.0.0-20241009180824-f66d83c29e7c/go.mod h1:NQtJDoLvd6faHhE7m4T/1IY708gDefGGjR/iUW8yQQ8=\ngolang.org/x/exp/shiny v0.0.0-20241009180824-f66d83c29e7c h1:jTMrjjZRcSH/BDxWhXCP6OWsfVgmnwI7J+F4/nyVXaU=\ngolang.org/x/exp/shiny v0.0.0-20241009180824-f66d83c29e7c/go.mod h1:3F+MieQB7dRYLTmnncoFbb1crS5lfQoTfDgQy6K4N0o=\ngolang.org/x/image v0.21.0 h1:c5qV36ajHpdj4Qi0GnE0jUc/yuo33OLFaa0d+crTD5s=\ngolang.org/x/image v0.21.0/go.mod h1:vUbsLavqK/W303ZroQQVKQ+Af3Yl6Uz1Ppu5J/cLz78=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.26.0 h1:KHjCJyddX0LoSTb3J+vWpupP9p0oznkqVk/IfjymZbo=\ngolang.org/x/sys v0.26.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.19.0 h1:kTxAhCbGbxhK0IwgSKiMO5awPoDQ0RpfiVYBfK860YM=\ngolang.org/x/text v0.19.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngonum.org/v1/gonum v0.15.1 h1:FNy7N6OUZVUaWG9pTiD+jlhdQ3lMP+/LcTpJ6+a8sQ0=\ngonum.org/v1/gonum v0.15.1/go.mod h1:eZTZuRFrzu5pcyjN5wJhcIhnUdNijYxX1T2IcrOGY0o=\nhonnef.co/go/tools v0.1.3/go.mod h1:NgwopIslSNH47DimFoV78dnkksY2EFtX0ajyb3K/las=\nrsc.io/pdf v0.1.1 h1:k1MczvYDUvJBe93bYd7wrZLLUEcLZAuF824/I4e5Xr4=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\n"
        },
        {
          "name": "gob",
          "type": "tree",
          "content": null
        },
        {
          "name": "labelling.go",
          "type": "blob",
          "size": 7.55078125,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This is an implementation of the Talbot, Lin and Hanrahan algorithm\n// described in doi:10.1109/TVCG.2010.130 with reference to the R\n// implementation in the labeling package, ©2014 Justin Talbot (Licensed\n// MIT+file LICENSE|Unlimited).\n\npackage plot\n\nimport (\n\t\"math\"\n)\n\nconst (\n\t// dlamchE is the machine epsilon. For IEEE this is 2^{-53}.\n\tdlamchE = 1.0 / (1 << 53)\n\n\t// dlamchB is the radix of the machine (the base of the number system).\n\tdlamchB = 2\n\n\t// dlamchP is base * eps.\n\tdlamchP = dlamchB * dlamchE\n)\n\nconst (\n\t// free indicates no restriction on label containment.\n\tfree = iota\n\t// containData specifies that all the data range lies\n\t// within the interval [label_min, label_max].\n\tcontainData\n\t// withinData specifies that all labels lie within the\n\t// interval [dMin, dMax].\n\twithinData\n)\n\n// talbotLinHanrahan returns an optimal set of approximately want label values\n// for the data range [dMin, dMax], and the step and magnitude of the step between values.\n// containment is specifies are guarantees for label and data range containment, valid\n// values are free, containData and withinData.\n// The optional parameters Q, nice numbers, and w, weights, allow tuning of the\n// algorithm but by default (when nil) are set to the parameters described in the\n// paper.\n// The legibility function allows tuning of the legibility assessment for labels.\n// By default, when nil, legbility will set the legibility score for each candidate\n// labelling scheme to 1.\n// See the paper for an explanation of the function of Q, w and legibility.\nfunc talbotLinHanrahan(dMin, dMax float64, want int, containment int, Q []float64, w *weights, legibility func(lMin, lMax, lStep float64) float64) (values []float64, step, q float64, magnitude int) {\n\tconst eps = dlamchP * 100\n\n\tif dMin > dMax {\n\t\tpanic(\"labelling: invalid data range: min greater than max\")\n\t}\n\n\tif Q == nil {\n\t\tQ = []float64{1, 5, 2, 2.5, 4, 3}\n\t}\n\tif w == nil {\n\t\tw = &weights{\n\t\t\tsimplicity: 0.25,\n\t\t\tcoverage:   0.2,\n\t\t\tdensity:    0.5,\n\t\t\tlegibility: 0.05,\n\t\t}\n\t}\n\tif legibility == nil {\n\t\tlegibility = unitLegibility\n\t}\n\n\tif r := dMax - dMin; r < eps {\n\t\tl := make([]float64, want)\n\t\tstep := r / float64(want-1)\n\t\tfor i := range l {\n\t\t\tl[i] = dMin + float64(i)*step\n\t\t}\n\t\tmagnitude = minAbsMag(dMin, dMax)\n\t\treturn l, step, 0, magnitude\n\t}\n\n\ttype selection struct {\n\t\t// n is the number of labels selected.\n\t\tn int\n\t\t// lMin and lMax are the selected min\n\t\t// and max label values. lq is the q\n\t\t// chosen.\n\t\tlMin, lMax, lStep, lq float64\n\t\t// score is the score for the selection.\n\t\tscore float64\n\t\t// magnitude is the magnitude of the\n\t\t// label step distance.\n\t\tmagnitude int\n\t}\n\tbest := selection{score: -2}\n\nouter:\n\tfor skip := 1; ; skip++ {\n\t\tfor _, q := range Q {\n\t\t\tsm := maxSimplicity(q, Q, skip)\n\t\t\tif w.score(sm, 1, 1, 1) < best.score {\n\t\t\t\tbreak outer\n\t\t\t}\n\n\t\t\tfor have := 2; ; have++ {\n\t\t\t\tdm := maxDensity(have, want)\n\t\t\t\tif w.score(sm, 1, dm, 1) < best.score {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tdelta := (dMax - dMin) / float64(have+1) / float64(skip) / q\n\n\t\t\t\tconst maxExp = 309\n\t\t\t\tfor mag := int(math.Ceil(math.Log10(delta))); mag < maxExp; mag++ {\n\t\t\t\t\tstep := float64(skip) * q * math.Pow10(mag)\n\n\t\t\t\t\tcm := maxCoverage(dMin, dMax, step*float64(have-1))\n\t\t\t\t\tif w.score(sm, cm, dm, 1) < best.score {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tfracStep := step / float64(skip)\n\t\t\t\t\tkStep := step * float64(have-1)\n\n\t\t\t\t\tminStart := (math.Floor(dMax/step) - float64(have-1)) * float64(skip)\n\t\t\t\t\tmaxStart := math.Ceil(dMax/step) * float64(skip)\n\t\t\t\t\tfor start := minStart; start <= maxStart && start != start-1; start++ {\n\t\t\t\t\t\tlMin := start * fracStep\n\t\t\t\t\t\tlMax := lMin + kStep\n\n\t\t\t\t\t\tswitch containment {\n\t\t\t\t\t\tcase containData:\n\t\t\t\t\t\t\tif dMin < lMin || lMax < dMax {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase withinData:\n\t\t\t\t\t\t\tif lMin < dMin || dMax < lMax {\n\t\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcase free:\n\t\t\t\t\t\t\t// Free choice.\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tscore := w.score(\n\t\t\t\t\t\t\tsimplicity(q, Q, skip, lMin, lMax, step),\n\t\t\t\t\t\t\tcoverage(dMin, dMax, lMin, lMax),\n\t\t\t\t\t\t\tdensity(have, want, dMin, dMax, lMin, lMax),\n\t\t\t\t\t\t\tlegibility(lMin, lMax, step),\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif score > best.score {\n\t\t\t\t\t\t\tbest = selection{\n\t\t\t\t\t\t\t\tn:         have,\n\t\t\t\t\t\t\t\tlMin:      lMin,\n\t\t\t\t\t\t\t\tlMax:      lMax,\n\t\t\t\t\t\t\t\tlStep:     float64(skip) * q,\n\t\t\t\t\t\t\t\tlq:        q,\n\t\t\t\t\t\t\t\tscore:     score,\n\t\t\t\t\t\t\t\tmagnitude: mag,\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif best.score == -2 {\n\t\tl := make([]float64, want)\n\t\tstep := (dMax - dMin) / float64(want-1)\n\t\tfor i := range l {\n\t\t\tl[i] = dMin + float64(i)*step\n\t\t}\n\t\tmagnitude = minAbsMag(dMin, dMax)\n\t\treturn l, step, 0, magnitude\n\t}\n\n\tl := make([]float64, best.n)\n\tstep = best.lStep * math.Pow10(best.magnitude)\n\tfor i := range l {\n\t\tl[i] = best.lMin + float64(i)*step\n\t}\n\treturn l, best.lStep, best.lq, best.magnitude\n}\n\n// minAbsMag returns the minumum magnitude of the absolute values of a and b.\nfunc minAbsMag(a, b float64) int {\n\treturn int(math.Min(math.Floor(math.Log10(math.Abs(a))), (math.Floor(math.Log10(math.Abs(b))))))\n}\n\n// simplicity returns the simplicity score for how will the curent q, lMin, lMax,\n// lStep and skip match the given nice numbers, Q.\nfunc simplicity(q float64, Q []float64, skip int, lMin, lMax, lStep float64) float64 {\n\tconst eps = dlamchP * 100\n\n\tfor i, v := range Q {\n\t\tif v == q {\n\t\t\tm := math.Mod(lMin, lStep)\n\t\t\tv = 0\n\t\t\tif (m < eps || lStep-m < eps) && lMin <= 0 && 0 <= lMax {\n\t\t\t\tv = 1\n\t\t\t}\n\t\t\treturn 1 - float64(i)/(float64(len(Q))-1) - float64(skip) + v\n\t\t}\n\t}\n\tpanic(\"labelling: invalid q for Q\")\n}\n\n// maxSimplicity returns the maximum simplicity for q, Q and skip.\nfunc maxSimplicity(q float64, Q []float64, skip int) float64 {\n\tfor i, v := range Q {\n\t\tif v == q {\n\t\t\treturn 1 - float64(i)/(float64(len(Q))-1) - float64(skip) + 1\n\t\t}\n\t}\n\tpanic(\"labelling: invalid q for Q\")\n}\n\n// coverage returns the coverage score for based on the average\n// squared distance between the extreme labels, lMin and lMax, and\n// the extreme data points, dMin and dMax.\nfunc coverage(dMin, dMax, lMin, lMax float64) float64 {\n\tr := 0.1 * (dMax - dMin)\n\tmax := dMax - lMax\n\tmin := dMin - lMin\n\treturn 1 - 0.5*(max*max+min*min)/(r*r)\n}\n\n// maxCoverage returns the maximum coverage achievable for the data\n// range.\nfunc maxCoverage(dMin, dMax, span float64) float64 {\n\tr := dMax - dMin\n\tif span <= r {\n\t\treturn 1\n\t}\n\th := 0.5 * (span - r)\n\tr *= 0.1\n\treturn 1 - (h*h)/(r*r)\n}\n\n// density returns the density score which measures the goodness of\n// the labelling density compared to the user defined target\n// based on the want parameter given to talbotLinHanrahan.\nfunc density(have, want int, dMin, dMax, lMin, lMax float64) float64 {\n\trho := float64(have-1) / (lMax - lMin)\n\trhot := float64(want-1) / (math.Max(lMax, dMax) - math.Min(dMin, lMin))\n\tif d := rho / rhot; d >= 1 {\n\t\treturn 2 - d\n\t}\n\treturn 2 - rhot/rho\n}\n\n// maxDensity returns the maximum density score achievable for have and want.\nfunc maxDensity(have, want int) float64 {\n\tif have < want {\n\t\treturn 1\n\t}\n\treturn 2 - float64(have-1)/float64(want-1)\n}\n\n// unitLegibility returns a default legibility score ignoring label\n// spacing.\nfunc unitLegibility(_, _, _ float64) float64 {\n\treturn 1\n}\n\n// weights is a helper type to calcuate the labelling scheme's total score.\ntype weights struct {\n\tsimplicity, coverage, density, legibility float64\n}\n\n// score returns the score for a labelling scheme with simplicity, s,\n// coverage, c, density, d and legibility l.\nfunc (w *weights) score(s, c, d, l float64) float64 {\n\treturn w.simplicity*s + w.coverage*c + w.density*d + w.legibility*l\n}\n"
        },
        {
          "name": "labelling_test.go",
          "type": "blob",
          "size": 6.28125,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nvar talbotLinHanrahanTests = []struct {\n\tdMin, dMax  float64\n\twant        int\n\tcontainment int\n\n\twantValues    []float64\n\twantStep      float64\n\twantMagnitude int\n}{\n\t// Expected values confirmed against R reference implementation.\n\t{\n\t\tdMin:        -1.9846500878911073,\n\t\tdMax:        0.4370974820125605,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{-2, -1, 0},\n\t\twantStep:      1,\n\t\twantMagnitude: 0,\n\t},\n\t{\n\t\tdMin:        -1.9846500878911073,\n\t\tdMax:        0.4370974820125605,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{-2, -1, 0, 1},\n\t\twantStep:      1,\n\t\twantMagnitude: 0,\n\t},\n\t{\n\t\tdMin:        -1.985e-15,\n\t\tdMax:        0.4371e-15,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{-1.985e-15, -7.739500000000001e-16, 4.3709999999999994e-16},\n\t\twantStep:      1.21105e-15,\n\t\twantMagnitude: -16,\n\t},\n\t{\n\t\tdMin:        -1.985e-15,\n\t\tdMax:        0.4371e-15,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{-1.985e-15, -7.739500000000001e-16, 4.3709999999999994e-16},\n\t\twantStep:      1.21105e-15,\n\t\twantMagnitude: -16,\n\t},\n\t{\n\t\tdMin:        -1.985e15,\n\t\tdMax:        0.4371e15,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{-2e+15, -1e+15, 0},\n\t\twantStep:      1,\n\t\twantMagnitude: 15,\n\t},\n\t{\n\t\tdMin:        -1.985e15,\n\t\tdMax:        0.4371e15,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{-2e+15, -1e+15, 0, 1e+15},\n\t\twantStep:      1,\n\t\twantMagnitude: 15,\n\t},\n\t{\n\t\tdMin:        dlamchP * 20,\n\t\tdMax:        dlamchP * 50,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{4.440892098500626e-15, 7.771561172376096e-15, 1.1102230246251565e-14},\n\t\twantStep:      3.3306690738754696e-15,\n\t\twantMagnitude: -15,\n\t},\n\t{\n\t\tdMin:        dlamchP * 20,\n\t\tdMax:        dlamchP * 50,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{4.440892098500626e-15, 7.771561172376096e-15, 1.1102230246251565e-14},\n\t\twantStep:      3.3306690738754696e-15,\n\t\twantMagnitude: -15,\n\t},\n\t{\n\t\tdMin:        math.MaxFloat64 / 4,\n\t\tdMax:        math.MaxFloat64 / 3,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{4.4942328371557893e+307, 5.243271643348421e+307, 5.992310449541053e+307},\n\t\twantStep:      7.490388061926317e+306,\n\t\twantMagnitude: 307,\n\t},\n\t{\n\t\tdMin:        math.MaxFloat64 / 4,\n\t\tdMax:        math.MaxFloat64 / 3,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{4.4942328371557893e+307, 5.243271643348421e+307, 5.992310449541053e+307},\n\t\twantStep:      7.490388061926317e+306,\n\t\twantMagnitude: 307,\n\t},\n\t{\n\t\tdMin:        0.00010,\n\t\tdMax:        0.00015,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{0.0001, 0.000125, 0.00015000000000000001},\n\t\twantStep:      2.5,\n\t\twantMagnitude: -5,\n\t},\n\t{\n\t\tdMin:        0.00010,\n\t\tdMax:        0.00015,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{0.0001, 0.000125, 0.00015000000000000001},\n\t\twantStep:      2.5,\n\t\twantMagnitude: -5,\n\t},\n\t{\n\t\tdMin:        555.6545,\n\t\tdMax:        21800.9875,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{0, 10000, 20000},\n\t\twantStep:      1,\n\t\twantMagnitude: 4,\n\t},\n\t{\n\t\tdMin:        555.6545,\n\t\tdMax:        21800.9875,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{0, 12000, 24000},\n\t\twantStep:      12,\n\t\twantMagnitude: 3,\n\t},\n\t{\n\t\tdMin:        555.6545,\n\t\tdMax:        27800.9875,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{0, 10000, 20000, 30000},\n\t\twantStep:      1,\n\t\twantMagnitude: 4,\n\t},\n\t{\n\t\tdMin:        555.6545,\n\t\tdMax:        27800.9875,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{0, 10000, 20000, 30000},\n\t\twantStep:      1,\n\t\twantMagnitude: 4,\n\t},\n\t{\n\t\tdMin:        55.6545,\n\t\tdMax:        1555.9875,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{0, 500, 1000, 1500},\n\t\twantStep:      5,\n\t\twantMagnitude: 2,\n\t},\n\t{\n\t\tdMin:        55.6545,\n\t\tdMax:        1555.9875,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{0, 800, 1600},\n\t\twantStep:      8,\n\t\twantMagnitude: 2,\n\t},\n\t{\n\t\tdMin:        3.096916 - 0.125,\n\t\tdMax:        3.096916 + 0.125,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{3, 3.1, 3.2},\n\t\twantStep:      1,\n\t\twantMagnitude: -1,\n\t},\n\t{\n\t\tdMin:        3.096916 - 0.125,\n\t\tdMax:        3.096916 + 0.125,\n\t\twant:        3,\n\t\tcontainment: containData,\n\n\t\twantValues:    []float64{2.9499999999999997, 3.0999999999999996, 3.2499999999999996},\n\t\twantStep:      15,\n\t\twantMagnitude: -2,\n\t},\n\t// The following fails in the reference implementation with a\n\t// warning of \"probable complete loss of accuracy in modulus\".\n\t{\n\t\tdMin:        99.99999999999996,\n\t\tdMax:        100,\n\t\twant:        3,\n\t\tcontainment: free,\n\n\t\twantValues:    []float64{99.99999999999996, 99.99999999999997, 100},\n\t\twantStep:      2,\n\t\twantMagnitude: -14,\n\t},\n}\n\nfunc TestTalbotLinHanrahan(t *testing.T) {\n\tfor _, test := range talbotLinHanrahanTests {\n\t\tvalues, step, _, magnitude := talbotLinHanrahan(test.dMin, test.dMax, test.want, test.containment, nil, nil, nil)\n\t\tif !reflect.DeepEqual(values, test.wantValues) {\n\t\t\tt.Errorf(\"unexpected values for dMin=%g, dMax=%g, want=%d, containment=%d:\\ngot: %v\\nwant:%v\",\n\t\t\t\ttest.dMin, test.dMax, test.want, test.containment, values, test.wantValues)\n\t\t}\n\t\tif step != test.wantStep {\n\t\t\tt.Errorf(\"unexpected step for dMin=%g, dMax=%g, want=%d, containment=%d: got:%v want:%v\",\n\t\t\t\ttest.dMin, test.dMax, test.want, test.containment, step, test.wantStep)\n\t\t}\n\t\tif magnitude != test.wantMagnitude {\n\t\t\tt.Errorf(\"unexpected magnitude for dMin=%g, dMax=%g, want=%d, containment=%d: got:%d want:%d\",\n\t\t\t\ttest.dMin, test.dMax, test.want, test.containment, magnitude, test.wantMagnitude)\n\t\t}\n\t\tif test.containment == containData {\n\t\t\tf := math.Pow10(-magnitude)\n\t\t\tif test.containment == containData && (test.dMin*f < values[0]*f || values[len(values)-1]*f < test.dMax*f) {\n\t\t\t\tt.Errorf(\"unexpected values for containment dMin=%g, dMax=%g, want=%d not containment:\\ngot: %v\\nwant:%v\",\n\t\t\t\t\ttest.dMin, test.dMax, test.want, values, test.wantValues)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "legend.go",
          "type": "blob",
          "size": 4.9404296875,
          "content": "// Copyright ©2015 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot\n\nimport (\n\t\"math\"\n\n\t\"gonum.org/v1/plot/font\"\n\t\"gonum.org/v1/plot/text\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n)\n\n// A Legend gives a description of the meaning of different\n// data elements of the plot.  Each legend entry has a name\n// and a thumbnail, where the thumbnail shows a small\n// sample of the display style of the corresponding data.\ntype Legend struct {\n\t// TextStyle is the style given to the legend\n\t// entry texts.\n\tTextStyle text.Style\n\n\t// Padding is the amount of padding to add\n\t// between each entry in the legend.  If Padding\n\t// is zero then entries are spaced based on the\n\t// font size.\n\tPadding vg.Length\n\n\t// Top and Left specify the location of the legend.\n\t// If Top is true the legend is located along the top\n\t// edge of the plot, otherwise it is located along\n\t// the bottom edge.  If Left is true then the legend\n\t// is located along the left edge of the plot, and the\n\t// text is positioned after the icons, otherwise it is\n\t// located along the right edge and the text is\n\t// positioned before the icons.\n\tTop, Left bool\n\n\t// XOffs and YOffs are added to the legend's\n\t// final position.\n\tXOffs, YOffs vg.Length\n\n\t// YPosition specifies the vertical position of a legend entry.\n\t// Valid values are [-1,+1], with +1 being the top of the\n\t// entry vertical space, and -1 the bottom.\n\tYPosition float64\n\n\t// ThumbnailWidth is the width of legend thumbnails.\n\tThumbnailWidth vg.Length\n\n\t// entries are all of the legendEntries described\n\t// by this legend.\n\tentries []legendEntry\n}\n\n// A legendEntry represents a single line of a legend, it\n// has a name and an icon.\ntype legendEntry struct {\n\t// text is the text associated with this entry.\n\ttext string\n\n\t// thumbs is a slice of all of the thumbnails styles\n\tthumbs []Thumbnailer\n}\n\n// Thumbnailer wraps the Thumbnail method, which\n// draws the small image in a legend representing the\n// style of data.\ntype Thumbnailer interface {\n\t// Thumbnail draws an thumbnail representing\n\t// a legend entry.  The thumbnail will usually show\n\t// a smaller representation of the style used\n\t// to plot the corresponding data.\n\tThumbnail(c *draw.Canvas)\n}\n\n// NewLegend returns a legend with the default parameter settings.\nfunc NewLegend() Legend {\n\treturn newLegend(DefaultTextHandler)\n}\n\nfunc newLegend(hdlr text.Handler) Legend {\n\treturn Legend{\n\t\tYPosition:      draw.PosBottom,\n\t\tThumbnailWidth: vg.Points(20),\n\t\tTextStyle: text.Style{\n\t\t\tFont:    font.From(DefaultFont, 12),\n\t\t\tHandler: hdlr,\n\t\t},\n\t}\n}\n\n// Draw draws the legend to the given draw.Canvas.\nfunc (l *Legend) Draw(c draw.Canvas) {\n\ticonx := c.Min.X\n\tsty := l.TextStyle\n\tem := sty.Rectangle(\" \")\n\ttextx := iconx + l.ThumbnailWidth + em.Max.X\n\tif !l.Left {\n\t\ticonx = c.Max.X - l.ThumbnailWidth\n\t\ttextx = iconx - em.Max.X\n\t\tsty.XAlign--\n\t}\n\ttextx += l.XOffs\n\ticonx += l.XOffs\n\n\tdescent := sty.FontExtents().Descent\n\tenth := l.entryHeight()\n\ty := c.Max.Y - enth - descent\n\tif !l.Top {\n\t\ty = c.Min.Y + (enth+l.Padding)*(vg.Length(len(l.entries))-1)\n\t}\n\ty += l.YOffs\n\n\ticon := &draw.Canvas{\n\t\tCanvas: c.Canvas,\n\t\tRectangle: vg.Rectangle{\n\t\t\tMin: vg.Point{X: iconx, Y: y},\n\t\t\tMax: vg.Point{X: iconx + l.ThumbnailWidth, Y: y + enth},\n\t\t},\n\t}\n\n\tif l.YPosition < draw.PosBottom || draw.PosTop < l.YPosition {\n\t\tpanic(\"plot: invalid vertical offset for the legend's entries\")\n\t}\n\tyoff := vg.Length(l.YPosition-draw.PosBottom) / 2\n\tyoff += descent\n\n\tfor _, e := range l.entries {\n\t\tfor _, t := range e.thumbs {\n\t\t\tt.Thumbnail(icon)\n\t\t}\n\t\tyoffs := (enth - descent - sty.Rectangle(e.text).Max.Y) / 2\n\t\tyoffs += yoff\n\t\tc.FillText(sty, vg.Point{X: textx, Y: icon.Min.Y + yoffs}, e.text)\n\t\ticon.Min.Y -= enth + l.Padding\n\t\ticon.Max.Y -= enth + l.Padding\n\t}\n}\n\n// Rectangle returns the extent of the Legend.\nfunc (l *Legend) Rectangle(c draw.Canvas) vg.Rectangle {\n\tvar width, height vg.Length\n\tsty := l.TextStyle\n\tentryHeight := l.entryHeight()\n\tfor i, e := range l.entries {\n\t\twidth = vg.Length(math.Max(float64(width), float64(l.ThumbnailWidth+sty.Rectangle(\" \"+e.text).Max.X)))\n\t\theight += entryHeight\n\t\tif i != 0 {\n\t\t\theight += l.Padding\n\t\t}\n\t}\n\tvar r vg.Rectangle\n\tif l.Left {\n\t\tr.Max.X = c.Max.X\n\t\tr.Min.X = c.Max.X - width\n\t} else {\n\t\tr.Max.X = c.Min.X + width\n\t\tr.Min.X = c.Min.X\n\t}\n\tif l.Top {\n\t\tr.Max.Y = c.Max.Y\n\t\tr.Min.Y = c.Max.Y - height\n\t} else {\n\t\tr.Max.Y = c.Min.Y + height\n\t\tr.Min.Y = c.Min.Y\n\t}\n\treturn r\n}\n\n// entryHeight returns the height of the tallest legend\n// entry text.\nfunc (l *Legend) entryHeight() (height vg.Length) {\n\tfor _, e := range l.entries {\n\t\tif h := l.TextStyle.Rectangle(e.text).Max.Y; h > height {\n\t\t\theight = h\n\t\t}\n\t}\n\treturn\n}\n\n// Add adds an entry to the legend with the given name.\n// The entry's thumbnail is drawn as the composite of all of the\n// thumbnails.\nfunc (l *Legend) Add(name string, thumbs ...Thumbnailer) {\n\tl.entries = append(l.entries, legendEntry{text: name, thumbs: thumbs})\n}\n"
        },
        {
          "name": "legend_example_test.go",
          "type": "blob",
          "size": 2.19921875,
          "content": "// Copyright ©2018 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot_test\n\nimport (\n\t\"image/color\"\n\t\"os\"\n\n\t\"gonum.org/v1/plot\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n\t\"gonum.org/v1/plot/vg/vgimg\"\n)\n\ntype exampleThumbnailer struct {\n\tcolor.Color\n}\n\n// Thumbnail fulfills the plot.Thumbnailer interface.\nfunc (et exampleThumbnailer) Thumbnail(c *draw.Canvas) {\n\tpts := []vg.Point{\n\t\t{X: c.Min.X, Y: c.Min.Y},\n\t\t{X: c.Min.X, Y: c.Max.Y},\n\t\t{X: c.Max.X, Y: c.Max.Y},\n\t\t{X: c.Max.X, Y: c.Min.Y},\n\t}\n\tpoly := c.ClipPolygonY(pts)\n\tc.FillPolygon(et.Color, poly)\n\n\tpts = append(pts, vg.Point{X: c.Min.X, Y: c.Min.Y})\n\toutline := c.ClipLinesY(pts)\n\tc.StrokeLines(draw.LineStyle{\n\t\tColor: color.Black,\n\t\tWidth: vg.Points(1),\n\t}, outline...)\n}\n\n// This example creates a some standalone legends with borders around them.\nfunc ExampleLegend_standalone() {\n\tc := vgimg.New(vg.Points(120), vg.Points(100))\n\tdc := draw.New(c)\n\n\t// These example thumbnailers could be replaced with any of Plotters\n\t// in the plotter subpackage.\n\tred := exampleThumbnailer{Color: color.NRGBA{R: 255, A: 255}}\n\tgreen := exampleThumbnailer{Color: color.NRGBA{G: 255, A: 255}}\n\tblue := exampleThumbnailer{Color: color.NRGBA{B: 255, A: 255}}\n\n\tl := plot.NewLegend()\n\tl.Add(\"red\", red)\n\tl.Add(\"green\", green)\n\tl.Add(\"blue\", blue)\n\tl.Padding = vg.Millimeter\n\tl.YPosition = draw.PosCenter\n\n\t// purpleRectangle draws a purple rectangle around the given Legend.\n\tpurpleRectangle := func(l plot.Legend) {\n\t\tr := l.Rectangle(dc)\n\t\tdc.StrokeLines(draw.LineStyle{\n\t\t\tColor: color.NRGBA{R: 255, B: 255, A: 255},\n\t\t\tWidth: vg.Points(1),\n\t\t}, []vg.Point{\n\t\t\t{X: r.Min.X, Y: r.Min.Y}, {X: r.Min.X, Y: r.Max.Y}, {X: r.Max.X, Y: r.Max.Y},\n\t\t\t{X: r.Max.X, Y: r.Min.Y}, {X: r.Min.X, Y: r.Min.Y},\n\t\t})\n\t}\n\n\tl.Draw(dc)\n\tpurpleRectangle(l)\n\n\tl.Left = true\n\tl.Draw(dc)\n\tpurpleRectangle(l)\n\n\tl.Top = true\n\tl.Draw(dc)\n\tpurpleRectangle(l)\n\n\tl.Left = false\n\tl.Draw(dc)\n\tpurpleRectangle(l)\n\n\tw, err := os.Create(\"testdata/legend_standalone.png\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer w.Close()\n\n\tpng := vgimg.PngCanvas{Canvas: c}\n\tif _, err := png.WriteTo(w); err != nil {\n\t\tpanic(err)\n\t}\n}\n"
        },
        {
          "name": "legend_test.go",
          "type": "blob",
          "size": 0.3447265625,
          "content": "// Copyright ©2018 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot_test\n\nimport (\n\t\"testing\"\n\n\t\"gonum.org/v1/plot/cmpimg\"\n)\n\nfunc TestLegend_standalone(t *testing.T) {\n\tcmpimg.CheckPlot(ExampleLegend_standalone, t, \"legend_standalone.png\")\n}\n"
        },
        {
          "name": "palette",
          "type": "tree",
          "content": null
        },
        {
          "name": "plot.go",
          "type": "blob",
          "size": 13.3525390625,
          "content": "// Copyright ©2015 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot\n\nimport (\n\t\"image/color\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"gonum.org/v1/plot/font\"\n\t\"gonum.org/v1/plot/font/liberation\"\n\t\"gonum.org/v1/plot/text\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n)\n\nvar (\n\t// DefaultFont is the name of the default font for plot text.\n\tDefaultFont = font.Font{\n\t\tTypeface: \"Liberation\",\n\t\tVariant:  \"Serif\",\n\t}\n\n\t// DefaultTextHandler is the default text handler used for text processing.\n\tDefaultTextHandler text.Handler\n)\n\n// Plot is the basic type representing a plot.\ntype Plot struct {\n\tTitle struct {\n\t\t// Text is the text of the plot title.  If\n\t\t// Text is the empty string then the plot\n\t\t// will not have a title.\n\t\tText string\n\n\t\t// Padding is the amount of padding\n\t\t// between the bottom of the title and\n\t\t// the top of the plot.\n\t\tPadding vg.Length\n\n\t\t// TextStyle specifies how the plot title text should be displayed.\n\t\tTextStyle text.Style\n\t}\n\n\t// BackgroundColor is the background color of the plot.\n\t// The default is White.\n\tBackgroundColor color.Color\n\n\t// X and Y are the horizontal and vertical axes\n\t// of the plot respectively.\n\tX, Y Axis\n\n\t// Legend is the plot's legend.\n\tLegend Legend\n\n\t// TextHandler parses and formats text according to a given\n\t// dialect (Markdown, LaTeX, plain, ...)\n\t// The default is a plain text handler.\n\tTextHandler text.Handler\n\n\t// plotters are drawn by calling their Plot method\n\t// after the axes are drawn.\n\tplotters []Plotter\n}\n\n// Plotter is an interface that wraps the Plot method.\n// Some standard implementations of Plotter can be\n// found in the gonum.org/v1/plot/plotter\n// package, documented here:\n// https://godoc.org/gonum.org/v1/plot/plotter\ntype Plotter interface {\n\t// Plot draws the data to a draw.Canvas.\n\tPlot(draw.Canvas, *Plot)\n}\n\n// DataRanger wraps the DataRange method.\ntype DataRanger interface {\n\t// DataRange returns the range of X and Y values.\n\tDataRange() (xmin, xmax, ymin, ymax float64)\n}\n\n// orientation describes whether an axis is horizontal or vertical.\ntype orientation byte\n\nconst (\n\thorizontal orientation = iota\n\tvertical\n)\n\n// New returns a new plot with some reasonable default settings.\nfunc New() *Plot {\n\thdlr := DefaultTextHandler\n\tp := &Plot{\n\t\tBackgroundColor: color.White,\n\t\tX:               makeAxis(horizontal),\n\t\tY:               makeAxis(vertical),\n\t\tLegend:          newLegend(hdlr),\n\t\tTextHandler:     hdlr,\n\t}\n\tp.Title.TextStyle = text.Style{\n\t\tColor:   color.Black,\n\t\tFont:    font.From(DefaultFont, 12),\n\t\tXAlign:  draw.XCenter,\n\t\tYAlign:  draw.YTop,\n\t\tHandler: hdlr,\n\t}\n\treturn p\n}\n\n// Add adds a Plotters to the plot.\n//\n// If the plotters implements DataRanger then the\n// minimum and maximum values of the X and Y\n// axes are changed if necessary to fit the range of\n// the data.\n//\n// When drawing the plot, Plotters are drawn in the\n// order in which they were added to the plot.\nfunc (p *Plot) Add(ps ...Plotter) {\n\tfor _, d := range ps {\n\t\tif x, ok := d.(DataRanger); ok {\n\t\t\txmin, xmax, ymin, ymax := x.DataRange()\n\t\t\tp.X.Min = math.Min(p.X.Min, xmin)\n\t\t\tp.X.Max = math.Max(p.X.Max, xmax)\n\t\t\tp.Y.Min = math.Min(p.Y.Min, ymin)\n\t\t\tp.Y.Max = math.Max(p.Y.Max, ymax)\n\t\t}\n\t}\n\n\tp.plotters = append(p.plotters, ps...)\n}\n\n// Draw draws a plot to a draw.Canvas.\n//\n// Plotters are drawn in the order in which they were\n// added to the plot.  Plotters that  implement the\n// GlyphBoxer interface will have their GlyphBoxes\n// taken into account when padding the plot so that\n// none of their glyphs are clipped.\nfunc (p *Plot) Draw(c draw.Canvas) {\n\tif p.BackgroundColor != nil {\n\t\tc.SetColor(p.BackgroundColor)\n\t\tc.Fill(c.Rectangle.Path())\n\t}\n\n\tif p.Title.Text != \"\" {\n\t\tdescent := p.Title.TextStyle.FontExtents().Descent\n\t\tc.FillText(p.Title.TextStyle, vg.Point{X: c.Center().X, Y: c.Max.Y + descent}, p.Title.Text)\n\n\t\trect := p.Title.TextStyle.Rectangle(p.Title.Text)\n\t\tc.Max.Y -= rect.Size().Y\n\t\tc.Max.Y -= p.Title.Padding\n\t}\n\n\tp.X.sanitizeRange()\n\tx := horizontalAxis{p.X}\n\tp.Y.sanitizeRange()\n\ty := verticalAxis{p.Y}\n\n\tywidth := y.size()\n\n\txheight := x.size()\n\tx.draw(padX(p, draw.Crop(c, ywidth, 0, 0, 0)))\n\ty.draw(padY(p, draw.Crop(c, 0, 0, xheight, 0)))\n\n\tdataC := padY(p, padX(p, draw.Crop(c, ywidth, 0, xheight, 0)))\n\tfor _, data := range p.plotters {\n\t\tdata.Plot(dataC, p)\n\t}\n\n\tp.Legend.Draw(draw.Crop(c, ywidth, 0, xheight, 0))\n}\n\n// DataCanvas returns a new draw.Canvas that\n// is the subset of the given draw area into which\n// the plot data will be drawn.\nfunc (p *Plot) DataCanvas(da draw.Canvas) draw.Canvas {\n\tif p.Title.Text != \"\" {\n\t\trect := p.Title.TextStyle.Rectangle(p.Title.Text)\n\t\tda.Max.Y -= rect.Size().Y\n\t\tda.Max.Y -= p.Title.Padding\n\t}\n\tp.X.sanitizeRange()\n\tx := horizontalAxis{p.X}\n\tp.Y.sanitizeRange()\n\ty := verticalAxis{p.Y}\n\treturn padY(p, padX(p, draw.Crop(da, y.size(), 0, x.size(), 0)))\n}\n\n// DrawGlyphBoxes draws red outlines around the plot's\n// GlyphBoxes.  This is intended for debugging.\nfunc (p *Plot) DrawGlyphBoxes(c draw.Canvas) {\n\tdac := p.DataCanvas(c)\n\tsty := draw.LineStyle{\n\t\tColor: color.RGBA{R: 255, A: 255},\n\t\tWidth: vg.Points(0.5),\n\t}\n\n\tdrawBox := func(c draw.Canvas, b GlyphBox) {\n\t\tx := c.X(b.X) + b.Rectangle.Min.X\n\t\ty := c.Y(b.Y) + b.Rectangle.Min.Y\n\t\tc.StrokeLines(sty, []vg.Point{\n\t\t\t{X: x, Y: y},\n\t\t\t{X: x + b.Rectangle.Size().X, Y: y},\n\t\t\t{X: x + b.Rectangle.Size().X, Y: y + b.Rectangle.Size().Y},\n\t\t\t{X: x, Y: y + b.Rectangle.Size().Y},\n\t\t\t{X: x, Y: y},\n\t\t})\n\t}\n\n\tvar title vg.Length\n\tif p.Title.Text != \"\" {\n\t\trect := p.Title.TextStyle.Rectangle(p.Title.Text)\n\t\ttitle += rect.Size().Y\n\t\ttitle += p.Title.Padding\n\t\tbox := GlyphBox{\n\t\t\tRectangle: rect.Add(vg.Point{\n\t\t\t\tX: c.Center().X,\n\t\t\t\tY: c.Max.Y,\n\t\t\t}),\n\t\t}\n\t\tdrawBox(c, box)\n\t}\n\n\tfor _, b := range p.GlyphBoxes(p) {\n\t\tdrawBox(dac, b)\n\t}\n\n\tp.X.sanitizeRange()\n\tp.Y.sanitizeRange()\n\n\tx := horizontalAxis{p.X}\n\ty := verticalAxis{p.Y}\n\n\tywidth := y.size()\n\txheight := x.size()\n\n\tcx := padX(p, draw.Crop(c, ywidth, 0, 0, 0))\n\tfor _, b := range x.GlyphBoxes(p) {\n\t\tdrawBox(cx, b)\n\t}\n\n\tcy := padY(p, draw.Crop(c, 0, 0, xheight, 0))\n\tcy.Max.Y -= title\n\tfor _, b := range y.GlyphBoxes(p) {\n\t\tdrawBox(cy, b)\n\t}\n}\n\n// padX returns a draw.Canvas that is padded horizontally\n// so that glyphs will no be clipped.\nfunc padX(p *Plot, c draw.Canvas) draw.Canvas {\n\tglyphs := p.GlyphBoxes(p)\n\tl := leftMost(&c, glyphs)\n\txAxis := horizontalAxis{p.X}\n\tglyphs = append(glyphs, xAxis.GlyphBoxes(p)...)\n\tr := rightMost(&c, glyphs)\n\n\tminx := c.Min.X - l.Min.X\n\tmaxx := c.Max.X - (r.Min.X + r.Size().X)\n\tlx := vg.Length(l.X)\n\trx := vg.Length(r.X)\n\tn := (lx*maxx - rx*minx) / (lx - rx)\n\tm := ((lx-1)*maxx - rx*minx + minx) / (lx - rx)\n\treturn draw.Canvas{\n\t\tCanvas: vg.Canvas(c),\n\t\tRectangle: vg.Rectangle{\n\t\t\tMin: vg.Point{X: n, Y: c.Min.Y},\n\t\t\tMax: vg.Point{X: m, Y: c.Max.Y},\n\t\t},\n\t}\n}\n\n// rightMost returns the right-most GlyphBox.\nfunc rightMost(c *draw.Canvas, boxes []GlyphBox) GlyphBox {\n\tmaxx := c.Max.X\n\tr := GlyphBox{X: 1}\n\tfor _, b := range boxes {\n\t\tif b.Size().X <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif x := c.X(b.X) + b.Min.X + b.Size().X; x > maxx && b.X <= 1 {\n\t\t\tmaxx = x\n\t\t\tr = b\n\t\t}\n\t}\n\treturn r\n}\n\n// leftMost returns the left-most GlyphBox.\nfunc leftMost(c *draw.Canvas, boxes []GlyphBox) GlyphBox {\n\tminx := c.Min.X\n\tl := GlyphBox{}\n\tfor _, b := range boxes {\n\t\tif b.Size().X <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif x := c.X(b.X) + b.Min.X; x < minx && b.X >= 0 {\n\t\t\tminx = x\n\t\t\tl = b\n\t\t}\n\t}\n\treturn l\n}\n\n// padY returns a draw.Canvas that is padded vertically\n// so that glyphs will no be clipped.\nfunc padY(p *Plot, c draw.Canvas) draw.Canvas {\n\tglyphs := p.GlyphBoxes(p)\n\tb := bottomMost(&c, glyphs)\n\tyAxis := verticalAxis{p.Y}\n\tglyphs = append(glyphs, yAxis.GlyphBoxes(p)...)\n\tt := topMost(&c, glyphs)\n\n\tminy := c.Min.Y - b.Min.Y\n\tmaxy := c.Max.Y - (t.Min.Y + t.Size().Y)\n\tby := vg.Length(b.Y)\n\tty := vg.Length(t.Y)\n\tn := (by*maxy - ty*miny) / (by - ty)\n\tm := ((by-1)*maxy - ty*miny + miny) / (by - ty)\n\treturn draw.Canvas{\n\t\tCanvas: vg.Canvas(c),\n\t\tRectangle: vg.Rectangle{\n\t\t\tMin: vg.Point{Y: n, X: c.Min.X},\n\t\t\tMax: vg.Point{Y: m, X: c.Max.X},\n\t\t},\n\t}\n}\n\n// topMost returns the top-most GlyphBox.\nfunc topMost(c *draw.Canvas, boxes []GlyphBox) GlyphBox {\n\tmaxy := c.Max.Y\n\tt := GlyphBox{Y: 1}\n\tfor _, b := range boxes {\n\t\tif b.Size().Y <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif y := c.Y(b.Y) + b.Min.Y + b.Size().Y; y > maxy && b.Y <= 1 {\n\t\t\tmaxy = y\n\t\t\tt = b\n\t\t}\n\t}\n\treturn t\n}\n\n// bottomMost returns the bottom-most GlyphBox.\nfunc bottomMost(c *draw.Canvas, boxes []GlyphBox) GlyphBox {\n\tminy := c.Min.Y\n\tl := GlyphBox{}\n\tfor _, b := range boxes {\n\t\tif b.Size().Y <= 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif y := c.Y(b.Y) + b.Min.Y; y < miny && b.Y >= 0 {\n\t\t\tminy = y\n\t\t\tl = b\n\t\t}\n\t}\n\treturn l\n}\n\n// Transforms returns functions to transfrom\n// from the x and y data coordinate system to\n// the draw coordinate system of the given\n// draw area.\nfunc (p *Plot) Transforms(c *draw.Canvas) (x, y func(float64) vg.Length) {\n\tx = func(x float64) vg.Length { return c.X(p.X.Norm(x)) }\n\ty = func(y float64) vg.Length { return c.Y(p.Y.Norm(y)) }\n\treturn\n}\n\n// GlyphBoxer wraps the GlyphBoxes method.\n// It should be implemented by things that meet\n// the Plotter interface that draw glyphs so that\n// their glyphs are not clipped if drawn near the\n// edge of the draw.Canvas.\n//\n// When computing padding, the plot ignores\n// GlyphBoxes as follows:\n// If the Size.X > 0 and the X value is not in range\n// of the X axis then the box is ignored.\n// If Size.Y > 0 and the Y value is not in range of\n// the Y axis then the box is ignored.\n//\n// Also, GlyphBoxes with Size.X <= 0 are ignored\n// when computing horizontal padding and\n// GlyphBoxes with Size.Y <= 0 are ignored when\n// computing vertical padding.  This is useful\n// for things like box plots and bar charts where\n// the boxes and bars are considered to be glyphs\n// in the X direction (and thus need padding), but\n// may be clipped in the Y direction (and do not\n// need padding).\ntype GlyphBoxer interface {\n\tGlyphBoxes(*Plot) []GlyphBox\n}\n\n// A GlyphBox describes the location of a glyph\n// and the offset/size of its bounding box.\n//\n// If the Rectangle.Size().X is non-positive (<= 0) then\n// the GlyphBox is ignored when computing the\n// horizontal padding, and likewise with\n// Rectangle.Size().Y and the vertical padding.\ntype GlyphBox struct {\n\t// The glyph location in normalized coordinates.\n\tX, Y float64\n\n\t// Rectangle is the offset of the glyph's minimum drawing\n\t// point relative to the glyph location and its size.\n\tvg.Rectangle\n}\n\n// GlyphBoxes returns the GlyphBoxes for all plot\n// data that meet the GlyphBoxer interface.\nfunc (p *Plot) GlyphBoxes(*Plot) (boxes []GlyphBox) {\n\tfor _, d := range p.plotters {\n\t\tgb, ok := d.(GlyphBoxer)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tfor _, b := range gb.GlyphBoxes(p) {\n\t\t\tif b.Size().X > 0 && (b.X < 0 || b.X > 1) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif b.Size().Y > 0 && (b.Y < 0 || b.Y > 1) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tboxes = append(boxes, b)\n\t\t}\n\t}\n\treturn\n}\n\n// NominalX configures the plot to have a nominal X\n// axis—an X axis with names instead of numbers.  The\n// X location corresponding to each name are the integers,\n// e.g., the x value 0 is centered above the first name and\n// 1 is above the second name, etc.  Labels for x values\n// that do not end up in range of the X axis will not have\n// tick marks.\nfunc (p *Plot) NominalX(names ...string) {\n\tp.X.Tick.Width = 0\n\tp.X.Tick.Length = 0\n\tp.X.Width = 0\n\tp.Y.Padding = p.X.Tick.Label.Width(names[0]) / 2\n\tticks := make([]Tick, len(names))\n\tfor i, name := range names {\n\t\tticks[i] = Tick{float64(i), name}\n\t}\n\tp.X.Tick.Marker = ConstantTicks(ticks)\n}\n\n// HideX configures the X axis so that it will not be drawn.\nfunc (p *Plot) HideX() {\n\tp.X.Tick.Length = 0\n\tp.X.Width = 0\n\tp.X.Tick.Marker = ConstantTicks([]Tick{})\n}\n\n// HideY configures the Y axis so that it will not be drawn.\nfunc (p *Plot) HideY() {\n\tp.Y.Tick.Length = 0\n\tp.Y.Width = 0\n\tp.Y.Tick.Marker = ConstantTicks([]Tick{})\n}\n\n// HideAxes hides the X and Y axes.\nfunc (p *Plot) HideAxes() {\n\tp.HideX()\n\tp.HideY()\n}\n\n// NominalY is like NominalX, but for the Y axis.\nfunc (p *Plot) NominalY(names ...string) {\n\tp.Y.Tick.Width = 0\n\tp.Y.Tick.Length = 0\n\tp.Y.Width = 0\n\tp.X.Padding = p.Y.Tick.Label.Height(names[0]) / 2\n\tticks := make([]Tick, len(names))\n\tfor i, name := range names {\n\t\tticks[i] = Tick{float64(i), name}\n\t}\n\tp.Y.Tick.Marker = ConstantTicks(ticks)\n}\n\n// WriterTo returns an io.WriterTo that will write the plot as\n// the specified image format.\n//\n// Supported formats are:\n//\n//   - .eps\n//   - .jpg|.jpeg\n//   - .pdf\n//   - .png\n//   - .svg\n//   - .tex\n//   - .tif|.tiff\nfunc (p *Plot) WriterTo(w, h vg.Length, format string) (io.WriterTo, error) {\n\tc, err := draw.NewFormattedCanvas(w, h, format)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp.Draw(draw.New(c))\n\treturn c, nil\n}\n\n// Save saves the plot to an image file.  The file format is determined\n// by the extension.\n//\n// Supported extensions are:\n//\n//   - .eps\n//   - .jpg|.jpeg\n//   - .pdf\n//   - .png\n//   - .svg\n//   - .tex\n//   - .tif|.tiff\nfunc (p *Plot) Save(w, h vg.Length, file string) (err error) {\n\tf, err := os.Create(file)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\te := f.Close()\n\t\tif err == nil {\n\t\t\terr = e\n\t\t}\n\t}()\n\n\tformat := strings.ToLower(filepath.Ext(file))\n\tif len(format) != 0 {\n\t\tformat = format[1:]\n\t}\n\tc, err := p.WriterTo(w, h, format)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = c.WriteTo(f)\n\treturn err\n}\n\nfunc init() {\n\tfont.DefaultCache.Add(liberation.Collection())\n\tDefaultTextHandler = text.Plain{\n\t\tFonts: font.DefaultCache,\n\t}\n}\n"
        },
        {
          "name": "plot_test.go",
          "type": "blob",
          "size": 4.111328125,
          "content": "// Copyright ©2015 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage plot_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"image/color\"\n\t\"math\"\n\t\"os\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t\"gonum.org/v1/plot\"\n\t\"gonum.org/v1/plot/cmpimg\"\n\t\"gonum.org/v1/plot/font\"\n\t\"gonum.org/v1/plot/plotter\"\n\t\"gonum.org/v1/plot/text\"\n\t\"gonum.org/v1/plot/vg\"\n\t\"gonum.org/v1/plot/vg/draw\"\n\t\"gonum.org/v1/plot/vg/recorder\"\n\t\"gonum.org/v1/plot/vg/vgimg\"\n)\n\nfunc TestLegendAlignment(t *testing.T) {\n\tl := plot.Legend{\n\t\tThumbnailWidth: vg.Points(20),\n\t\tTextStyle: text.Style{\n\t\t\tFont:    font.From(plot.DefaultFont, 10),\n\t\t\tHandler: plot.DefaultTextHandler,\n\t\t},\n\t}\n\tfor i, n := range []string{\"A\", \"B\", \"C\", \"D\"} {\n\t\tb, err := plotter.NewBarChart(plotter.Values{0}, 1)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"failed to create bar chart %q: %v\", n, err)\n\t\t}\n\t\tb.Color = color.Gray{byte(i+1)*64 - 1}\n\t\tl.Add(n, b)\n\t}\n\n\tc := vgimg.PngCanvas{Canvas: vgimg.New(5*vg.Centimeter, 5*vg.Centimeter)}\n\tl.Draw(draw.New(c))\n\tvar buf bytes.Buffer\n\tif _, err := c.WriteTo(&buf); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif *cmpimg.GenerateTestData {\n\t\t// Recreate Golden images and exit.\n\t\terr := os.WriteFile(\"testdata/legendAlignment_golden.png\", buf.Bytes(), 0o644)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn\n\t}\n\n\terr := os.WriteFile(\"testdata/legendAlignment.png\", buf.Bytes(), 0o644)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\twant, err := os.ReadFile(\"testdata/legendAlignment_golden.png\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tok, err := cmpimg.Equal(\"png\", buf.Bytes(), want)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !ok {\n\t\tt.Fatalf(\"images differ\")\n\t}\n\n}\n\nfunc TestIssue514(t *testing.T) {\n\tfor _, ulp := range []int{\n\t\t0,\n\t\t+1, +2, +3, +4, +5, +6, +7, +8, +9, +10, +11, +12, +13, +14, +15, +16, +17, +18, +19, +20, +21, +22,\n\t\t-1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18, -19, -20, -21, -22,\n\t} {\n\t\tt.Run(fmt.Sprintf(\"ulps%+02d\", ulp), func(t *testing.T) {\n\t\t\tdone := make(chan int)\n\t\t\tgo func() {\n\t\t\t\tdefer close(done)\n\n\t\t\t\tp := plot.New()\n\n\t\t\t\tvar (\n\t\t\t\t\ty1 = 100.0\n\t\t\t\t\ty2 = y1\n\t\t\t\t)\n\n\t\t\t\tswitch {\n\t\t\t\tcase ulp < 0:\n\t\t\t\t\ty2 = math.Float64frombits(math.Float64bits(y1) - uint64(-ulp))\n\t\t\t\tcase ulp > 0:\n\t\t\t\t\ty2 = math.Float64frombits(math.Float64bits(y1) + uint64(ulp))\n\t\t\t\t}\n\n\t\t\t\tpts, err := plotter.NewScatter(plotter.XYs{\n\t\t\t\t\t{X: 1, Y: y1},\n\t\t\t\t\t{X: 1, Y: y2},\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Errorf(\"could not create scatter: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tp.Add(pts)\n\n\t\t\t\tc := draw.NewCanvas(&recorder.Canvas{}, 100, 100)\n\t\t\t\tp.Draw(c)\n\t\t\t}()\n\n\t\t\ttimeout := time.NewTimer(100 * time.Millisecond)\n\t\t\tdefer timeout.Stop()\n\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\tcase <-timeout.C:\n\t\t\t\tt.Fatalf(\"could not create plot with small axis range within allotted time\")\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestDrawGlyphBoxes(t *testing.T) {\n\tcmpimg.CheckPlot(func() {\n\t\tp := plot.New()\n\n\t\tp.Title.Text = \"My very very very\\nlong Title\"\n\t\tp.X.Min = 0\n\t\tp.X.Max = 10\n\t\tp.Y.Min = 0\n\t\tp.Y.Max = 10\n\n\t\tp.X.Label.Text = \"X-axis\"\n\t\tp.Y.Label.Text = \"Y-axis\"\n\n\t\tf1 := plotter.NewFunction(func(x float64) float64 { return 5 })\n\t\tf1.LineStyle.Color = color.RGBA{R: 255, A: 255}\n\n\t\tf2 := plotter.NewFunction(func(x float64) float64 { return 6 })\n\t\tf2.LineStyle.Color = color.RGBA{B: 255, A: 255}\n\n\t\tlabels, err := plotter.NewLabels(plotter.XYLabels{\n\t\t\tXYs: []plotter.XY{\n\t\t\t\t{X: 2.5, Y: 2.5},\n\t\t\t\t{X: 7.5, Y: 2.5},\n\t\t\t\t{X: 7.5, Y: 7.5},\n\t\t\t\t{X: 2.5, Y: 7.5},\n\t\t\t},\n\t\t\tLabels: []string{\"Agg\", \"Bgg\", \"Cgg\", \"Dgg\"},\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not creates labels plotter: %+v\", err)\n\t\t}\n\n\t\tp.Add(f1, f2, labels)\n\t\tp.Add(plotter.NewGrid())\n\n\t\tp.Legend.Add(\"fg1\", f1)\n\t\tp.Legend.Add(\"fg2\", f2)\n\t\tp.Legend.Top = true\n\n\t\tc := vgimg.PngCanvas{\n\t\t\tCanvas: vgimg.New(20*vg.Centimeter, 15*vg.Centimeter),\n\t\t}\n\n\t\td := draw.New(c)\n\t\tp.Draw(d)\n\t\tp.DrawGlyphBoxes(d)\n\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err = c.WriteTo(buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"error: %+v\", err)\n\t\t}\n\n\t\terr = os.WriteFile(\"testdata/glyphbox_\"+runtime.GOARCH+\".png\", buf.Bytes(), 0644)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"could not save plot: %+v\", err)\n\t\t}\n\t}, t, \"glyphbox_\"+runtime.GOARCH+\".png\")\n}\n"
        },
        {
          "name": "plotter",
          "type": "tree",
          "content": null
        },
        {
          "name": "plotutil",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "text",
          "type": "tree",
          "content": null
        },
        {
          "name": "tools",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 1.4013671875,
          "content": "// Copyright ©2019 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build go1.12\n// +build go1.12\n\npackage plot\n\nimport (\n\t\"fmt\"\n\t\"runtime/debug\"\n)\n\nconst root = \"gonum.org/v1/plot\"\n\n// Version returns the version of Gonum/plot and its checksum. The returned\n// values are only valid in binaries built with module support.\n//\n// If a replace directive exists in the Gonum/plot go.mod, the replace will\n// be reported in the version in the following format:\n//\n//\t\"version=>[replace-path] [replace-version]\"\n//\n// and the replace sum will be returned in place of the original sum.\n//\n// The exact version format returned by Version may change in future.\nfunc Version() (version, sum string) {\n\tb, ok := debug.ReadBuildInfo()\n\tif !ok {\n\t\treturn \"\", \"\"\n\t}\n\tfor _, m := range b.Deps {\n\t\tif m.Path == root {\n\t\t\tif m.Replace != nil {\n\t\t\t\tswitch {\n\t\t\t\tcase m.Replace.Version != \"\" && m.Replace.Path != \"\":\n\t\t\t\t\treturn fmt.Sprintf(\"%s=>%s %s\", m.Version, m.Replace.Path, m.Replace.Version), m.Replace.Sum\n\t\t\t\tcase m.Replace.Version != \"\":\n\t\t\t\t\treturn fmt.Sprintf(\"%s=>%s\", m.Version, m.Replace.Version), m.Replace.Sum\n\t\t\t\tcase m.Replace.Path != \"\":\n\t\t\t\t\treturn fmt.Sprintf(\"%s=>%s\", m.Version, m.Replace.Path), m.Replace.Sum\n\t\t\t\tdefault:\n\t\t\t\t\treturn m.Version + \"*\", m.Sum + \"*\"\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn m.Version, m.Sum\n\t\t}\n\t}\n\treturn \"\", \"\"\n}\n"
        },
        {
          "name": "vg",
          "type": "tree",
          "content": null
        },
        {
          "name": "vgall.go",
          "type": "blob",
          "size": 0.41015625,
          "content": "// Copyright ©2017 The Gonum Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !minimal\n// +build !minimal\n\npackage plot // import \"gonum.org/v1/plot\"\n\nimport (\n\t_ \"gonum.org/v1/plot/vg/vgeps\"\n\t_ \"gonum.org/v1/plot/vg/vgimg\"\n\t_ \"gonum.org/v1/plot/vg/vgpdf\"\n\t_ \"gonum.org/v1/plot/vg/vgsvg\"\n\t_ \"gonum.org/v1/plot/vg/vgtex\"\n)\n"
        }
      ]
    }
  ]
}