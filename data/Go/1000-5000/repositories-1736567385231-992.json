{
  "metadata": {
    "timestamp": 1736567385231,
    "page": 992,
    "hasNextPage": false,
    "endCursor": "Y3Vyc29yOjEwMDA=",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "levigross/grequests",
      "stars": 2143,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2734375,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n*.prof\n\n.idea/\n*.iml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0791015625,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"{}\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright 2015 – Levi Gross\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.3662109375,
          "content": "# GRequests\nA Go \"clone\" of the great and famous Requests library\n\n[![Join the chat at https://gitter.im/levigross/grequests](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/levigross/grequests?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n\nLicense\n======\n\nGRequests is licensed under the Apache License, Version 2.0. See [LICENSE](LICENSE) for the full license text\n\nFeatures\n========\n\n- Responses can be serialized into JSON and XML\n- Easy file uploads\n- Easy file downloads\n- Support for the following HTTP verbs `GET, HEAD, POST, PUT, DELETE, PATCH, OPTIONS`\n\nInstall\n=======\n`go get -u github.com/levigross/grequests`\n\nUsage\n======\n`import \"github.com/levigross/grequests\"`\n\nBasic Examples\n=========\nBasic GET request:\n\n```go\nresp, err := grequests.Get(\"http://httpbin.org/get\", nil)\n// You can modify the request by passing an optional RequestOptions struct\n\nif err != nil {\n\tlog.Fatalln(\"Unable to make request: \", err)\n}\n\nfmt.Println(resp.String())\n// {\n//   \"args\": {},\n//   \"headers\": {\n//     \"Accept\": \"*/*\",\n//     \"Host\": \"httpbin.org\",\n```\n\nIf an error occurs all of the other properties and methods of a `Response` will be `nil`\n\nQuirks\n=======\n## Request Quirks\n\nWhen passing parameters to be added to a URL, if the URL has existing parameters that *_contradict_* with what has been passed within `Params` – `Params` will be the \"source of authority\" and overwrite the contradicting URL parameter.\n\nLets see how it works...\n\n```go\nro := &RequestOptions{\n\tParams: map[string]string{\"Hello\": \"Goodbye\"},\n}\nGet(\"http://httpbin.org/get?Hello=World\", ro)\n// The URL is now http://httpbin.org/get?Hello=Goodbye\n```\n\n## Response Quirks\n\nOrder matters! This is because `grequests.Response` is implemented as an `io.ReadCloser` which proxies the *http.Response.Body* `io.ReadCloser` interface. It also includes an internal buffer for use in `Response.String()` and `Response.Bytes()`.\n\nHere are a list of methods that consume the *http.Response.Body* `io.ReadCloser` interface.\n\n- Response.JSON\n- Response.XML\n- Response.DownloadToFile\n- Response.Close\n- Response.Read\n\nThe following methods make use of an internal byte buffer\n\n- Response.String\n- Response.Bytes\n\nIn the code below, once the file is downloaded – the `Response` struct no longer has access to the request bytes\n\n```go\nresponse := Get(\"http://some-wonderful-file.txt\", nil)\n\nif err := response.DownloadToFile(\"randomFile\"); err != nil {\n\tlog.Println(\"Unable to download file: \", err)\n}\n\n// At this point the .String and .Bytes method will return empty responses\n\nresponse.Bytes() == nil // true\nresponse.String() == \"\" // true\n\n```\n\nBut if we were to call `response.Bytes()` or `response.String()` first, every operation will succeed until the internal buffer is cleared:\n\n```go\nresponse := Get(\"http://some-wonderful-file.txt\", nil)\n\n// This call to .Bytes caches the request bytes in an internal byte buffer – which can be used again and again until it is cleared\nresponse.Bytes() == `file-bytes`\nresponse.String() == \"file-string\"\n\n// This will work because it will use the internal byte buffer\nif err := resp.DownloadToFile(\"randomFile\"); err != nil {\n\tlog.Println(\"Unable to download file: \", err)\n}\n\n// Now if we clear the internal buffer....\nresponse.ClearInternalBuffer()\n\n// At this point the .String and .Bytes method will return empty responses\n\nresponse.Bytes() == nil // true\nresponse.String() == \"\" // true\n```\n"
        },
        {
          "name": "base.go",
          "type": "blob",
          "size": 2.5341796875,
          "content": "// Package grequests implements a friendly API over Go's existing net/http library\npackage grequests\n\n// Get takes 2 parameters and returns a Response Struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Get(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"GET\", url, ro)\n}\n\n// Put takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Put(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"PUT\", url, ro)\n}\n\n// Patch takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Patch(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"PATCH\", url, ro)\n}\n\n// Delete takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Delete(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"DELETE\", url, ro)\n}\n\n// Post takes 2 parameters and returns a Response channel. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Post(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"POST\", url, ro)\n}\n\n// Head takes 2 parameters and returns a Response channel. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Head(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"HEAD\", url, ro)\n}\n\n// Options takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Options(url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(\"OPTIONS\", url, ro)\n}\n\n// Req takes 3 parameters and returns a Response Struct. These three options are:\n//\t1. A verb\n// \t2. A URL\n// \t3. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\nfunc Req(verb string, url string, ro *RequestOptions) (*Response, error) {\n\treturn DoRegularRequest(verb, url, ro)\n}\n"
        },
        {
          "name": "base_delete_test.go",
          "type": "blob",
          "size": 2.1796875,
          "content": "package grequests\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestBasicDeleteRequest(t *testing.T) {\n\tresp, err := Delete(\"http://httpbin.org/delete\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n}\n\nfunc TestDeleteSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Delete(\"http://httpbin.org/delete\", nil)\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tif len(session.HTTPClient.Jar.Cookies(cookieURL)) != 3 {\n\t\tt.Error(\"Invalid number of cookies provided: \", resp.RawResponse.Cookies())\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n}\n\nfunc TestDeleteInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Delete(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n"
        },
        {
          "name": "base_get_test.go",
          "type": "blob",
          "size": 32.740234375,
          "content": "package grequests\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype BasicGetResponse struct {\n\tArgs    struct{} `json:\"args\"`\n\tHeaders struct {\n\t\tAccept         string `json:\"Accept\"`\n\t\tAcceptEncoding string `json:\"Accept-Encoding\"`\n\t\tAcceptLanguage string `json:\"Accept-Language\"`\n\t\tDnt            string `json:\"Dst\"`\n\t\tHost           string `json:\"Host\"`\n\t\tUserAgent      string `json:\"User-Agent\"`\n\t\tHello          string `json:\"Hello\"`\n\t} `json:\"headers\"`\n\tOrigin string `json:\"origin\"`\n\tURL    string `json:\"url\"`\n}\n\ntype BasicGetResponseNewHeader struct {\n\tArgs    struct{} `json:\"args\"`\n\tHeaders struct {\n\t\tAccept           string `json:\"Accept\"`\n\t\tAcceptEncoding   string `json:\"Accept-Encoding\"`\n\t\tAcceptLanguage   string `json:\"Accept-Language\"`\n\t\tDnt              string `json:\"Dst\"`\n\t\tHost             string `json:\"Host\"`\n\t\tUserAgent        string `json:\"User-Agent\"`\n\t\tXWonderfulHeader string `json:\"X-Wonderful-Header\"`\n\t} `json:\"headers\"`\n\tOrigin string `json:\"origin\"`\n\tURL    string `json:\"url\"`\n}\n\ntype BasicGetResponseBasicAuth struct {\n\tArgs    struct{} `json:\"args\"`\n\tHeaders struct {\n\t\tAccept         string `json:\"Accept\"`\n\t\tAcceptEncoding string `json:\"Accept-Encoding\"`\n\t\tAcceptLanguage string `json:\"Accept-Language\"`\n\t\tDnt            string `json:\"Dst\"`\n\t\tHost           string `json:\"Host\"`\n\t\tUserAgent      string `json:\"User-Agent\"`\n\t\tAuthorization  string `json:\"Authorization\"`\n\t} `json:\"headers\"`\n\tOrigin string `json:\"origin\"`\n\tURL    string `json:\"url\"`\n}\n\ntype BasicGetResponseArgs struct {\n\tArgs struct {\n\t\tGoodbye string `json:\"Goodbye\"`\n\t\tHello   string `json:\"Hello\"`\n\t} `json:\"args\"`\n\tHeaders struct {\n\t\tAccept         string `json:\"Accept\"`\n\t\tAcceptEncoding string `json:\"Accept-Encoding\"`\n\t\tAcceptLanguage string `json:\"Accept-Language\"`\n\t\tDnt            string `json:\"Dst\"`\n\t\tHost           string `json:\"Host\"`\n\t\tUserAgent      string `json:\"User-Agent\"`\n\t\tAuthorization  string `json:\"Authorization\"`\n\t} `json:\"headers\"`\n\tOrigin string `json:\"origin\"`\n\tURL    string `json:\"url\"`\n}\n\ntype GetXMLSample struct {\n\tXMLName xml.Name `xml:\"slideshow\"`\n\tTitle   string   `xml:\"title,attr\"`\n\tDate    string   `xml:\"date,attr\"`\n\tAuthor  string   `xml:\"author,attr\"`\n\tSlide   []struct {\n\t\tType  string `xml:\"type,attr\"`\n\t\tTitle string `xml:\"title\"`\n\t} `xml:\"slide\"`\n}\n\ntype TestJSONCookies struct {\n\tCookies struct {\n\t\tAnotherCookie string `json:\"AnotherCookie\"`\n\t\tTestCookie    string `json:\"TestCookie\"`\n\t} `json:\"cookies\"`\n}\n\ntype MassiveJSONBlob struct {\n\tType     string `json:\"type\"`\n\tFeatures []struct {\n\t\tType       string `json:\"type\"`\n\t\tProperties struct {\n\t\t\tMAPBLKLOT string      `json:\"MAPBLKLOT\"`\n\t\t\tBLKLOT    string      `json:\"BLKLOT\"`\n\t\t\tBLOCKNUM  string      `json:\"BLOCK_NUM\"`\n\t\t\tLOTNUM    string      `json:\"LOT_NUM\"`\n\t\t\tFROMST    string      `json:\"FROM_ST\"`\n\t\t\tTOST      string      `json:\"TO_ST\"`\n\t\t\tSTREET    string      `json:\"STREET\"`\n\t\t\tSTTYPE    interface{} `json:\"ST_TYPE\"`\n\t\t\tODDEVEN   string      `json:\"ODD_EVEN\"`\n\t\t} `json:\"properties\"`\n\t\tGeometry struct {\n\t\t\tType        string `json:\"type\"`\n\t\t\tCoordinates []struct {\n\t\t\t\tNum0  []float64 `json:\"0,omitempty\"`\n\t\t\t\tNum1  []float64 `json:\"1,omitempty\"`\n\t\t\t\tNum2  []float64 `json:\"2,omitempty\"`\n\t\t\t\tNum3  []float64 `json:\"3,omitempty\"`\n\t\t\t\tNum4  []float64 `json:\"4,omitempty\"`\n\t\t\t\tNum5  []float64 `json:\"5,omitempty\"`\n\t\t\t\tNum6  []float64 `json:\"6,omitempty\"`\n\t\t\t\tNum7  []float64 `json:\"7,omitempty\"`\n\t\t\t\tNum8  []float64 `json:\"8,omitempty\"`\n\t\t\t\tNum9  []float64 `json:\"9,omitempty\"`\n\t\t\t\tNum10 []float64 `json:\"10,omitempty\"`\n\t\t\t} `json:\"-\"`\n\t\t} `json:\"geometry\"`\n\t} `json:\"features\"`\n}\n\ntype GithubSelfJSON struct {\n\tID       int    `json:\"id\"`\n\tName     string `json:\"name\"`\n\tFullName string `json:\"full_name\"`\n\tOwner    struct {\n\t\tLogin             string `json:\"login\"`\n\t\tID                int    `json:\"id\"`\n\t\tAvatarURL         string `json:\"avatar_url\"`\n\t\tGravatarID        string `json:\"gravatar_id\"`\n\t\tURL               string `json:\"url\"`\n\t\tHTMLURL           string `json:\"html_url\"`\n\t\tFollowersURL      string `json:\"followers_url\"`\n\t\tFollowingURL      string `json:\"following_url\"`\n\t\tGistsURL          string `json:\"gists_url\"`\n\t\tStarredURL        string `json:\"starred_url\"`\n\t\tSubscriptionsURL  string `json:\"subscriptions_url\"`\n\t\tOrganizationsURL  string `json:\"organizations_url\"`\n\t\tReposURL          string `json:\"repos_url\"`\n\t\tEventsURL         string `json:\"events_url\"`\n\t\tReceivedEventsURL string `json:\"received_events_url\"`\n\t\tType              string `json:\"type\"`\n\t\tSiteAdmin         bool   `json:\"site_admin\"`\n\t} `json:\"owner\"`\n\tPrivate          bool        `json:\"private\"`\n\tHTMLURL          string      `json:\"html_url\"`\n\tDescription      string      `json:\"description\"`\n\tFork             bool        `json:\"fork\"`\n\tURL              string      `json:\"url\"`\n\tForksURL         string      `json:\"forks_url\"`\n\tKeysURL          string      `json:\"keys_url\"`\n\tCollaboratorsURL string      `json:\"collaborators_url\"`\n\tTeamsURL         string      `json:\"teams_url\"`\n\tHooksURL         string      `json:\"hooks_url\"`\n\tIssueEventsURL   string      `json:\"issue_events_url\"`\n\tEventsURL        string      `json:\"events_url\"`\n\tAssigneesURL     string      `json:\"assignees_url\"`\n\tBranchesURL      string      `json:\"branches_url\"`\n\tTagsURL          string      `json:\"tags_url\"`\n\tBlobsURL         string      `json:\"blobs_url\"`\n\tGitTagsURL       string      `json:\"git_tags_url\"`\n\tGitRefsURL       string      `json:\"git_refs_url\"`\n\tTreesURL         string      `json:\"trees_url\"`\n\tStatusesURL      string      `json:\"statuses_url\"`\n\tLanguagesURL     string      `json:\"languages_url\"`\n\tStargazersURL    string      `json:\"stargazers_url\"`\n\tContributorsURL  string      `json:\"contributors_url\"`\n\tSubscribersURL   string      `json:\"subscribers_url\"`\n\tSubscriptionURL  string      `json:\"subscription_url\"`\n\tCommitsURL       string      `json:\"commits_url\"`\n\tGitCommitsURL    string      `json:\"git_commits_url\"`\n\tCommentsURL      string      `json:\"comments_url\"`\n\tIssueCommentURL  string      `json:\"issue_comment_url\"`\n\tContentsURL      string      `json:\"contents_url\"`\n\tCompareURL       string      `json:\"compare_url\"`\n\tMergesURL        string      `json:\"merges_url\"`\n\tArchiveURL       string      `json:\"archive_url\"`\n\tDownloadsURL     string      `json:\"downloads_url\"`\n\tIssuesURL        string      `json:\"issues_url\"`\n\tPullsURL         string      `json:\"pulls_url\"`\n\tMilestonesURL    string      `json:\"milestones_url\"`\n\tNotificationsURL string      `json:\"notifications_url\"`\n\tLabelsURL        string      `json:\"labels_url\"`\n\tReleasesURL      string      `json:\"releases_url\"`\n\tDeploymentsURL   string      `json:\"deployments_url\"`\n\tCreatedAt        time.Time   `json:\"created_at\"`\n\tUpdatedAt        time.Time   `json:\"updated_at\"`\n\tPushedAt         time.Time   `json:\"pushed_at\"`\n\tGitURL           string      `json:\"git_url\"`\n\tSSHURL           string      `json:\"ssh_url\"`\n\tCloneURL         string      `json:\"clone_url\"`\n\tSvnURL           string      `json:\"svn_url\"`\n\tHomepage         string      `json:\"homepage\"`\n\tSize             int         `json:\"size\"`\n\tStargazersCount  int         `json:\"stargazers_count\"`\n\tWatchersCount    int         `json:\"watchers_count\"`\n\tLanguage         string      `json:\"language\"`\n\tHasIssues        bool        `json:\"has_issues\"`\n\tHasDownloads     bool        `json:\"has_downloads\"`\n\tHasWiki          bool        `json:\"has_wiki\"`\n\tHasPages         bool        `json:\"has_pages\"`\n\tForksCount       int         `json:\"forks_count\"`\n\tMirrorURL        interface{} `json:\"mirror_url\"`\n\tOpenIssuesCount  int         `json:\"open_issues_count\"`\n\tForks            int         `json:\"forks\"`\n\tOpenIssues       int         `json:\"open_issues\"`\n\tWatchers         int         `json:\"watchers\"`\n\tDefaultBranch    string      `json:\"default_branch\"`\n\tNetworkCount     int         `json:\"network_count\"`\n\tSubscribersCount int         `json:\"subscribers_count\"`\n}\n\nfunc TestGetNoOptions(t *testing.T) {\n\tresp, _ := Get(\"http://httpbin.org/get\", nil)\n\tverifyOkResponse(resp, t)\n}\n\nfunc TestGetRequestHook(t *testing.T) {\n\taddHelloWorld := func(req *http.Request) error {\n\t\treq.Header.Add(\"Hello\", \"World\")\n\t\treturn nil\n\t}\n\tresp, _ := Get(\"http://httpbin.org/get\",\n\t\t&RequestOptions{BeforeRequest: addHelloWorld})\n\tj := verifyOkResponse(resp, t)\n\tif j.Headers.Hello != \"World\" {\n\t\tt.Error(\"Hook Function failed\")\n\t}\n}\n\nfunc TestGetNoOptionsCustomClient(t *testing.T) {\n\tresp, _ := Get(\"http://httpbin.org/get\",\n\t\t&RequestOptions{HTTPClient: http.DefaultClient})\n\tverifyOkResponse(resp, t)\n}\n\nfunc TestGetCustomTLSHandshakeTimeout(t *testing.T) {\n\tro := &RequestOptions{TLSHandshakeTimeout: 10 * time.Millisecond}\n\tif _, err := Get(\"https://httpbin.org\", ro); err == nil {\n\t\tt.Error(\"unexpected: successful TLS Handshake\")\n\t}\n}\n\nfunc TestGetCustomDialTimeout(t *testing.T) {\n\tro := &RequestOptions{DialTimeout: time.Nanosecond}\n\tif _, err := Get(\"http://httpbin.org\", ro); err == nil {\n\t\tt.Error(\"unexpected: successful connection\")\n\t}\n}\n\nfunc TestGetProxy(t *testing.T) {\n\tch := make(chan string, 1)\n\n\tts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tch <- \"real server\"\n\t}))\n\n\tdefer ts.Close()\n\n\tproxy := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tch <- \"proxy for \" + r.URL.String()\n\t}))\n\n\tdefer proxy.Close()\n\n\tpu, err := url.Parse(proxy.URL)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tresp, err := Head(ts.URL, &RequestOptions{Proxies: map[string]*url.URL{pu.Scheme: pu}})\n\n\tdefer http.DefaultTransport.(*http.Transport).CloseIdleConnections()\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Response is not OK for some reason: \", resp.StatusCode)\n\t}\n\n\tgot := <-ch\n\twant := \"proxy for \" + ts.URL + \"/\"\n\tif got != want {\n\t\tt.Errorf(\"want %q, got %q\", want, got)\n\t}\n}\n\nfunc TestGetSyncInvalidProxyScheme(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", &RequestOptions{Proxies: map[string]*url.URL{\"gopher\": nil}})\n\tif err != nil {\n\t\tt.Error(\"Request failed: \", err)\n\t}\n\n\tverifyOkResponse(resp, t)\n}\n\nfunc TestGetSyncNoOptions(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\tif err != nil {\n\t\tt.Error(\"Request failed: \", err)\n\t}\n\n\tverifyOkResponse(resp, t)\n}\n\nfunc TestGetNoOptionsGzip(t *testing.T) {\n\tresp, _ := Get(\"https://httpbin.org/gzip\", nil)\n\tverifyOkResponse(resp, t)\n}\n\nfunc TestGetWithCookies(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/cookies\",\n\t\t&RequestOptions{\n\t\t\tCookies: []*http.Cookie{\n\t\t\t\t{\n\t\t\t\t\tName:     \"TestCookie\",\n\t\t\t\t\tValue:    \"Random Value\",\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tSecure:   false,\n\t\t\t\t}, {\n\t\t\t\t\tName:     \"AnotherCookie\",\n\t\t\t\t\tValue:    \"Some Value\",\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tSecure:   false,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &TestJSONCookies{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Cannot serialize cookie JSON: \", err)\n\t}\n\n\tif myJSONStruct.Cookies.TestCookie != \"Random Value\" {\n\t\tt.Errorf(\"Cookie value not set properly: %#v\", myJSONStruct)\n\t}\n\n\tif myJSONStruct.Cookies.AnotherCookie != \"Some Value\" {\n\t\tt.Errorf(\"Cookie value not set properly: %#v\", myJSONStruct)\n\t}\n\n}\n\nfunc TestGetWithCookiesCustomCookieJar(t *testing.T) {\n\tcookieJar, _ := cookiejar.New(nil)\n\tresp, err := Get(\"http://httpbin.org/cookies\",\n\t\t&RequestOptions{\n\t\t\tCookieJar: cookieJar,\n\t\t\tCookies: []*http.Cookie{\n\t\t\t\t{\n\t\t\t\t\tName:     \"TestCookie\",\n\t\t\t\t\tValue:    \"Random Value\",\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tSecure:   false,\n\t\t\t\t}, {\n\t\t\t\t\tName:     \"AnotherCookie\",\n\t\t\t\t\tValue:    \"Some Value\",\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tSecure:   false,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &TestJSONCookies{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Cannot serialize cookie JSON: \", err)\n\t}\n\n\tif myJSONStruct.Cookies.TestCookie != \"Random Value\" {\n\t\tt.Errorf(\"Cookie value not set properly: %#v\", myJSONStruct)\n\t}\n\n\tif myJSONStruct.Cookies.AnotherCookie != \"Some Value\" {\n\t\tt.Errorf(\"Cookie value not set properly: %#v\", myJSONStruct)\n\t}\n\n}\n\nfunc TestGetSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tif len(session.HTTPClient.Jar.Cookies(cookieURL)) != 3 {\n\t\tt.Error(\"Invalid number of cookies provided: \", session.HTTPClient.Jar.Cookies(cookieURL))\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n\tsession.CloseIdleConnections()\n\n}\n\n//func TestGetNoOptionsDeflate(t *testing.T) {\n//\tverifyOkResponse(<-GetAsync(\"http://httpbin.org/deflate\", nil), t)\n//}\n\nfunc xmlASCIIDecoder(charset string, input io.Reader) (io.Reader, error) {\n\treturn input, nil\n}\n\nfunc TestGetInvalidURL(t *testing.T) {\n\tresp, err := Get(\"%../dir/\", &RequestOptions{Params: map[string]string{\"1\": \"2\"}})\n\n\tif err == nil {\n\t\tt.Error(\"Some how the request was valid to make request\", err)\n\t}\n\n\tresp.ClearInternalBuffer() // This will panic without our nil checks\n}\n\nfunc TestGetInvalidURLNoParams(t *testing.T) {\n\t_, err := Get(\"%../dir/\", nil)\n\n\tif err == nil {\n\t\tt.Error(\"Some how the request was valid to make request\", err)\n\t}\n}\n\nfunc TestGetInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Get(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n\nfunc TestGetXMLSerialize(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/xml\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tuserXML := &GetXMLSample{}\n\n\tif err := resp.XML(userXML, xmlASCIIDecoder); err != nil {\n\t\tt.Error(\"Unable to consume the response as XML: \", err)\n\t}\n\n\tif userXML.Title != \"Sample Slide Show\" {\n\t\tt.Errorf(\"Invalid XML serialization %#v\", userXML)\n\t}\n\n\tif err := resp.XML(int(123), nil); err == nil {\n\t\tt.Error(\"Still able to consume XML from used response\")\n\t}\n\n}\n\nfunc TestGetCustomUserAgent(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\"}\n\tresp, _ := Get(\"http://httpbin.org/get\", ro)\n\tjsonResp := verifyOkResponse(resp, t)\n\tif jsonResp.Headers.UserAgent != \"LeviBot 0.1\" {\n\t\tt.Error(\"User agent header not properly set\")\n\t}\n}\n\nfunc TestGetBasicAuth(t *testing.T) {\n\tro := &RequestOptions{Auth: []string{\"Levi\", \"Bot\"}}\n\tresp, err := Get(\"http://httpbin.org/get\", ro)\n\t// Not the usual JSON so copy and paste from below\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicGetResponseBasicAuth{}\n\n\terr = resp.JSON(myJSONStruct)\n\tif err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.Headers.Authorization != \"Basic TGV2aTpCb3Q=\" {\n\t\tt.Error(\"Unable to set HTTP basic auth\", myJSONStruct.Headers)\n\t}\n\n}\n\nfunc TestGetCustomHeader(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\",\n\t\tHeaders: map[string]string{\"X-Wonderful-Header\": \"1\"}}\n\tresp, err := Get(\"http://httpbin.org/get\", ro)\n\t// Not the usual JSON so copy and paste from below\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicGetResponseNewHeader{}\n\n\terr = resp.JSON(myJSONStruct)\n\tif err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.Headers.XWonderfulHeader != \"1\" {\n\t\tt.Error(\"Unable to set custom HTTP header\", myJSONStruct.Headers)\n\t}\n}\n\nfunc TestGetInvalidSSLCertNoVerify(t *testing.T) {\n\tro := &RequestOptions{InsecureSkipVerify: true}\n\tfor _, badSSL := range []string{\n\t\t\"https://self-signed.badssl.com/\",\n\t\t\"https://expired.badssl.com/\",\n\t\t\"https://wrong.host.badssl.com/\",\n\t} {\n\t\tresp, err := Get(badSSL, ro)\n\t\tif err != nil {\n\t\t\tt.Error(\"Unable to make request\", err)\n\t\t}\n\t\tif resp.Ok != true {\n\t\t\tt.Error(\"Request did not return OK\")\n\t\t}\n\t}\n\n}\n\nfunc TestGetInvalidSSLCertNoVerifyNoOptions(t *testing.T) {\n\tfor _, badSSL := range []string{\n\t\t\"https://self-signed.badssl.com/\",\n\t\t\"https://expired.badssl.com/\",\n\t\t\"https://wrong.host.badssl.com/\",\n\t} {\n\t\tresp, err := Get(badSSL, nil)\n\t\tif err == nil {\n\t\t\tt.Error(\"Unable to make request\", err)\n\t\t}\n\n\t\tif resp.Ok == true {\n\t\t\tt.Error(\"Request did not return OK\")\n\t\t}\n\t}\n}\n\nfunc TestGetInvalidSSLCertNoCompression(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\", DisableCompression: true}\n\tresp, err := Get(\"https://self-signed.badssl.com/\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"SSL verification worked when it shouldn't of\", err)\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetInvalidSSLCertWithCompression(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\", DisableCompression: false}\n\tresp, err := Get(\"https://self-signed.badssl.com/\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"SSL verification worked when it shouldn't of\", err)\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestErrorResponseNOOP(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\", DisableCompression: false}\n\tresp, err := Get(\"https://self-signed.badssl.com/\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"SSL verification worked when it shouldn't of\", err)\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n\tmyJSONStruct := &BasicGetResponseArgs{}\n\n\tif err := resp.JSON(myJSONStruct); err == nil {\n\t\tt.Error(\"Somehow Able to convert to JSON\", err)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"Somehow byte buffer is working now (bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"Somehow byte buffer is working now (bytes)\", resp.String())\n\t}\n\n\tresp.ClearInternalBuffer()\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"Somehow byte buffer is working now (bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"Somehow byte buffer is working now (bytes)\", resp.String())\n\t}\n\n\tuserXML := &GetXMLSample{}\n\n\tif err := resp.XML(userXML, xmlASCIIDecoder); err == nil {\n\t\tt.Errorf(\"Somehow to consume the response as XML: %#v\", userXML)\n\t}\n\n\tfileName := \"randomFile\"\n\n\tif err := resp.DownloadToFile(fileName); err == nil {\n\t\tt.Error(\"Somehow able to download to file: \", err)\n\t}\n\n\tvar buf [1]byte\n\n\tif written, err := resp.Read(buf[:]); written != -1 && err == nil {\n\t\tt.Error(\"Somehow we were able to read from our error response\")\n\t}\n\n}\n\nfunc TestGetInvalidSSLCertNoCompressionNoVerify(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\", InsecureSkipVerify: true, DisableCompression: true}\n\tresp, err := Get(\"https://self-signed.badssl.com/\", ro)\n\n\tif err != nil {\n\t\tt.Error(\"SSL verification worked when it shouldn't of\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetInvalidSSLCertWithCompressionNoVerify(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\", InsecureSkipVerify: true, DisableCompression: false}\n\tresp, err := Get(\"https://self-signed.badssl.com/\", ro)\n\n\tif err != nil {\n\t\tt.Error(\"SSL verification worked when it shouldn't of\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetInvalidSSLCert(t *testing.T) {\n\tro := &RequestOptions{UserAgent: \"LeviBot 0.1\"}\n\tresp, err := Get(\"https://self-signed.badssl.com/\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"SSL verification worked when it shouldn't of\", err)\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetBasicArgs(t *testing.T) {\n\tro := &RequestOptions{\n\t\tParams: map[string]string{\"Hello\": \"World\"},\n\t}\n\tresp, _ := Get(\"http://httpbin.org/get?Goodbye=World\", ro)\n\n\tverifyOkArgsResponse(resp, t)\n\n}\n\nfunc TestGetBasicArgsQueryStruct(t *testing.T) {\n\tro := &RequestOptions{\n\t\tQueryStruct: struct {\n\t\t\tHello string `url:\"Hello\"`\n\t\t}{\n\t\t\t\"World\",\n\t\t},\n\t}\n\tresp, _ := Get(\"http://httpbin.org/get?Goodbye=World\", ro)\n\n\tverifyOkArgsResponse(resp, t)\n\n}\n\nfunc TestGetBasicArgsQueryStructErr(t *testing.T) {\n\tro := &RequestOptions{\n\t\tQueryStruct: 5,\n\t}\n\tresp, err := Get(\"http://httpbin.org/get?Goodbye=World\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"URL Parsing should have failed\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetBasicArgsQueryStructUrlQueryErr(t *testing.T) {\n\tro := &RequestOptions{\n\t\tQueryStruct: 5,\n\t}\n\tresp, err := Get(\"http://httpbin.org/get?Goodbye=World%zz\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"URL Parsing should have failed\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetBasicArgsQueryStructUrlErr(t *testing.T) {\n\tro := &RequestOptions{\n\t\tQueryStruct: 5,\n\t}\n\tresp, err := Get(\"%\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"URL Parsing should have failed\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetBasicArgsErr(t *testing.T) {\n\tro := &RequestOptions{\n\t\tParams: map[string]string{\"Hello\": \"World\"},\n\t}\n\tresp, err := Get(\"http://httpbin.org/get?Goodbye=%zzz\", ro)\n\n\tif err == nil {\n\t\tt.Error(\"URL Parsing should have failed\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did return OK\")\n\t}\n\n}\n\nfunc TestGetBasicArgsParams(t *testing.T) {\n\tro := &RequestOptions{\n\t\tParams: map[string]string{\"Hello\": \"World\", \"Goodbye\": \"World\"},\n\t}\n\tresp, _ := Get(\"http://httpbin.org/get\", ro)\n\n\tverifyOkArgsResponse(resp, t)\n}\n\nfunc TestGetBasicArgsParamsOverwrite(t *testing.T) {\n\tro := &RequestOptions{\n\t\tParams: map[string]string{\"Hello\": \"World\", \"Goodbye\": \"World\"},\n\t}\n\n\tresp, _ := Get(\"http://httpbin.org/get?Hello=Nothing\", ro)\n\n\tverifyOkArgsResponse(resp, t)\n}\n\nfunc TestGetFileDownload(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\n\tfileName := \"randomFile\"\n\n\tif err := resp.DownloadToFile(fileName); err != nil {\n\t\tt.Error(\"Unable to download to file: \", err)\n\t}\n\n\tif err := resp.DownloadToFile(\".\"); err == nil {\n\t\tt.Error(\"Able to create file '.'\")\n\t}\n\n\tfd, err := os.Open(fileName)\n\tdefer fd.Close()\n\tdefer os.Remove(fileName)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file to verify content \", err)\n\t}\n\n\tjsonDecoder := json.NewDecoder(fd)\n\n\tmyJSONStruct := &BasicGetResponse{}\n\n\tif err := jsonDecoder.Decode(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to cocerce file to JSON \", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/get\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n}\n\nfunc TestJsonConsumedResponse(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tif resp.Bytes() == nil {\n\t\tt.Error(\"Unable to coerce value to bytes\", resp.Bytes())\n\t}\n\n\tresp.ClearInternalBuffer()\n\n\tif err := resp.JSON(struct{}{}); err == nil {\n\t\tt.Error(\"Struct should not be able to hold JSON: \")\n\t}\n}\n\nfunc TestDownloadConsumedResponse(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tif resp.Bytes() == nil {\n\t\tt.Error(\"Unable to coerce value to bytes\")\n\t}\n\n\tresp.ClearInternalBuffer()\n\n\tif err := resp.DownloadToFile(\"randomFile\"); err == nil {\n\t\tt.Error(\"Still able to download file: \", err)\n\t}\n\n\tdefer os.Remove(\"randomFile\")\n}\n\nfunc TestGetBytes(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tif resp.Bytes() == nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream\")\n\t}\n\n\tif bytes.Compare(resp.Bytes(), resp.Bytes()) != 0 {\n\t\tt.Error(\"Body bytes have not been cached\", resp.Bytes())\n\t}\n}\n\nfunc TestGetBytesNoBuffer(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tif resp.Bytes() == nil {\n\t\tt.Error(\"Cannot coerce HTTP response to bytes\")\n\t}\n\n\tif bytes.Compare(resp.Bytes(), resp.Bytes()) != 0 {\n\t\tt.Error(\"Body bytes have not been cached\", resp.Bytes())\n\t}\n\n\tif err := resp.DownloadToFile(\"randomFile\"); err != nil {\n\t\tt.Error(\"Unable to download file: \", err)\n\t}\n\n\tdefer os.Remove(\"randomFile\")\n\n\tresp.ClearInternalBuffer()\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"Internal Buffer not cleaned up\")\n\t}\n}\n\nfunc TestGetString(t *testing.T) {\n\tresp, err := Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tif resp.String() == \"\" {\n\t\tt.Error(\"Response Stream not returned as string\", resp.String())\n\t}\n\n\tif resp.String() != resp.String() {\n\t\tt.Error(\"Body string have not been cached\", resp.String())\n\t}\n\n\tif err := resp.DownloadToFile(\"randomFile\"); err != nil {\n\t\tt.Error(\"Unable to download file: \", err)\n\t}\n\n\tdefer os.Remove(\"randomFile\")\n\n\tresp.ClearInternalBuffer()\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"Internal Buffer not cleaned up\")\n\t}\n\n}\n\nfunc TestGetRedirectHeaderCopy(t *testing.T) {\n\tsrv := httptest.NewServer(http.DefaultServeMux)\n\thttp.HandleFunc(\"/foo\", func(w http.ResponseWriter, req *http.Request) {\n\t\tif req.Header.Get(\"X-Custom\") == \"\" {\n\t\t\thttp.Error(w, \"no custom header found\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t})\n\tresp, err := Get(srv.URL+\"/foo\", &RequestOptions{Headers: map[string]string{\"X-Custom\": \"1\"}})\n\n\tif err != nil {\n\t\tt.Error(\"Redirect request failed\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tsrv.Close()\n\n}\n\nfunc TestGetRedirectSecretHeaderNoCopy(t *testing.T) {\n\tsrv := httptest.NewServer(http.DefaultServeMux)\n\thttp.HandleFunc(\"/sec\", func(w http.ResponseWriter, req *http.Request) {\n\t\tif req.Header.Get(\"X-Custom\") == \"\" {\n\t\t\thttp.Error(w, \"no custom header found\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t})\n\tresp, err := Get(srv.URL+\"/sec\", &RequestOptions{\n\t\tHeaders: map[string]string{\"X-Custom\": \"1\"}, SensitiveHTTPHeaders: map[string]struct{}{\"X-Custom\": {}},\n\t})\n\n\tif err != nil {\n\t\tt.Error(\"Redirect request failed\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tsrv.Close()\n\n}\n\nfunc TestMassiveJSONFile(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"Skipping massive JSON file download because short was called\")\n\t}\n\tresp, err := Get(\"https://raw.githubusercontent.com/levigross/sf-city-lots-json/master/citylots.json\", nil)\n\tif err != nil {\n\t\tt.Error(\"Request to massive JSON blob failed\", err)\n\t}\n\n\tmyjson := &MassiveJSONBlob{}\n\n\tif err := resp.JSON(myjson); err != nil {\n\t\tt.Error(\"Unable to serialize massive JSON blob\", err)\n\t}\n\n\tif myjson.Type != \"FeatureCollection\" {\n\t\tt.Error(\"JSON did not properly serialize\")\n\t}\n}\n\nfunc TestGitHubSelfJSON(t *testing.T) {\n\tresp, err := Get(\"https://api.github.com/repos/levigross/grequests\", nil)\n\tif err != nil {\n\t\tt.Error(\"Request to reddit JSON blob failed\", err)\n\t}\n\n\tmyjson := &GithubSelfJSON{}\n\n\tif err := resp.JSON(myjson); err != nil {\n\t\tt.Error(\"Unable to serialize reddit JSON blob\", err)\n\t}\n}\n\nfunc TestUnlimitedRedirects(t *testing.T) {\n\tsrv := httptest.NewServer(http.DefaultServeMux)\n\thttp.HandleFunc(\"/bar\", func(w http.ResponseWriter, req *http.Request) {\n\t\thttp.Redirect(w, req, \"/bar\", http.StatusMovedPermanently)\n\t})\n\n\tresp, err := Get(srv.URL+\"/bar\", &RequestOptions{Headers: map[string]string{\"X-Custom\": \"1\"}})\n\n\tif err == nil {\n\t\tt.Error(\"Redirect limitation failed\", err)\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Request did not returned\")\n\t}\n\n\tsrv.Close()\n}\n\nfunc TestAuthStripOnRedirect(t *testing.T) {\n\tt.SkipNow()\n\tsrv := httptest.NewServer(http.DefaultServeMux)\n\thttp.HandleFunc(\"/test/\", func(w http.ResponseWriter, req *http.Request) {\n\t\tif req.Header.Get(\"Authorization\") != \"\" {\n\t\t\thttp.Error(w, \"Found Auth: \"+req.Header.Get(\"Authorization\"), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif req.Header.Get(\"WWW-Authenticate\") != \"\" {\n\t\t\thttp.Error(w, \"Found Auth: \"+req.Header.Get(\"WWW-Authenticate\"), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tif req.Header.Get(\"Proxy-Authorization\") != \"\" {\n\t\t\thttp.Error(w, \"Found Auth: \"+req.Header.Get(\"Proxy-Authorization\"), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tio.WriteString(w, \"OK\")\n\t})\n\n\tresp, err := Get(srv.URL+\"/test\", &RequestOptions{\n\t\tAuth:    []string{\"one \", \"two\"},\n\t\tHeaders: map[string]string{\"WWW-Authenticate\": \"foo\", \"Proxy-Authorization\": \"bar\"},\n\t})\n\n\tif err != nil {\n\t\tt.Error(\"Request had creds inside\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request had creds inside\", resp.StatusCode, resp.String())\n\t}\n\n\tsrv.Close()\n}\n\nfunc TestNoRedirect(t *testing.T) {\n\tsrv := httptest.NewServer(http.DefaultServeMux)\n\thttp.HandleFunc(\"/3tester/\", func(w http.ResponseWriter, req *http.Request) {\n\t\thttp.Redirect(w, req, \"/\", http.StatusMovedPermanently)\n\t})\n\n\tclient := &http.Client{\n\t\tCheckRedirect: func(req *http.Request, via []*http.Request) error {\n\t\t\treturn errors.New(\"cancel redirection\")\n\t\t},\n\t}\n\n\t_, err := Get(srv.URL+\"/3tester/\", &RequestOptions{\n\t\tHTTPClient: client,\n\t})\n\n\tif err == nil {\n\t\tt.Error(\"Request passed when it was supposed to fail on redirect\", err)\n\t}\n\n\tsrv.Close()\n\n}\n\nfunc verifyOkArgsResponse(resp *Response, t *testing.T) *BasicGetResponseArgs {\n\tif resp.Error != nil {\n\t\tt.Error(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicGetResponseArgs{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.Args.Goodbye != \"World\" && myJSONStruct.Args.Hello != \"World\" {\n\t\tt.Error(\"Args not properly set\", myJSONStruct.Args)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/get?Goodbye=World&Hello=World\" {\n\t\tt.Error(\"Url is not properly constructed\", myJSONStruct.URL)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\treturn myJSONStruct\n}\n\nfunc TestGetCustomRequestTimeout(t *testing.T) {\n\tro := &RequestOptions{RequestTimeout: 2 * time.Nanosecond}\n\tif _, err := Get(\"http://httpbin.org\", ro); err == nil {\n\t\tt.Error(\"unexpected: successful connection\")\n\t}\n}\n\nfunc TestGetCustomRequestTimeoutContext(t *testing.T) {\n\tderContext := context.Background()\n\tctx, cancel := context.WithTimeout(derContext, time.Microsecond)\n\tro := &RequestOptions{Context: ctx}\n\tcancel()\n\tif _, err := Get(\"http://httpbin.org\", ro); err == nil {\n\t\tt.Error(\"unexpected: successful connection\")\n\t}\n}\n\n// verifyResponse will verify the following conditions\n// 1. The request didn't return an error\n// 2. The response returned an OK (a status code within the 200 range)\n// 3. The output can be coerced to JSON (this may change later)\n// It should only be run when testing GET request to http://httpbin.org/get expecting JSON\nfunc verifyOkResponse(resp *Response, t *testing.T) *BasicGetResponse {\n\tif resp.Error != nil {\n\t\tt.Error(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicGetResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Errorf(\"JSON decoding did not fully consume the response stream (Bytes) %#v\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\treturn myJSONStruct\n}\n"
        },
        {
          "name": "base_head_test.go",
          "type": "blob",
          "size": 2.7958984375,
          "content": "package grequests\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestBasicHeadRequest(t *testing.T) {\n\tresp, err := Head(\"http://httpbin.org/get\", nil)\n\tif err != nil {\n\t\tt.Error(\"Unable to make HEAD request: \", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"HEAD request did not return success: \", resp.StatusCode)\n\t}\n\n\tif resp.Header.Get(\"Content-Type\") != \"application/json\" {\n\t\tt.Error(\"Content Type Header is unexpected: \", resp.Header.Get(\"Content-Type\"))\n\t}\n}\n\nfunc TestBasicHeadRequestNoContent(t *testing.T) {\n\tresp, err := Head(\"http://httpbin.org/bytes/0\", nil)\n\tif err != nil {\n\t\tt.Error(\"Unable to make HEAD request: \", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"HEAD request did not return success: \", resp.StatusCode)\n\t}\n\n\tif resp.Header.Get(\"Content-Type\") != \"application/octet-stream\" {\n\t\tt.Error(\"Content Type Header is unexpected: \", resp.Header.Get(\"Content-Type\"))\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"Somehow byte buffer is working now (bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"Somehow byte buffer is working now (bytes)\", resp.String())\n\t}\n}\n\nfunc TestHeadSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Head(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Head(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Head(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tif len(session.HTTPClient.Jar.Cookies(cookieURL)) != 3 {\n\t\tt.Error(\"Invalid number of cookies provided: \", session.HTTPClient.Jar.Cookies(cookieURL))\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n}\n\nfunc TestHeadInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Head(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n"
        },
        {
          "name": "base_options_test.go",
          "type": "blob",
          "size": 2.0947265625,
          "content": "package grequests\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestBasicOPTIONSRequest(t *testing.T) {\n\tresp, err := Options(\"http://httpbin.org/get\", nil)\n\tif err != nil {\n\t\tt.Error(\"Unable to make OPTIONS request: \", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Options request did not return success: \", resp.StatusCode)\n\t}\n\n\tif resp.Header.Get(\"Access-Control-Allow-Methods\") != \"GET, POST, PUT, DELETE, PATCH, OPTIONS\" {\n\t\tt.Error(\"Access-Control-Allow-Methods Type Header is unexpected: \", resp.Header)\n\t}\n}\n\nfunc TestOptionsSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Options(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Options(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Options(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n}\n\nfunc TestOptionsInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Options(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n"
        },
        {
          "name": "base_patch_test.go",
          "type": "blob",
          "size": 2.2548828125,
          "content": "package grequests\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestBasicPatchRequest(t *testing.T) {\n\tresp, err := Patch(\"http://httpbin.org/patch\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n}\n\nfunc TestPatchSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Patch(\"http://httpbin.org/patch\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK: \", resp.String())\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tif len(session.HTTPClient.Jar.Cookies(cookieURL)) != 3 {\n\t\tt.Error(\"Invalid number of cookies provided: \", session.HTTPClient.Jar.Cookies(cookieURL))\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n}\n\nfunc TestPatchInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Patch(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n"
        },
        {
          "name": "base_post_test.go",
          "type": "blob",
          "size": 22.9833984375,
          "content": "package grequests\n\nimport (\n\t\"bytes\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"net/url\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n)\n\ntype BasicPostResponse struct {\n\tArgs  struct{} `json:\"args\"`\n\tData  string   `json:\"data\"`\n\tFiles struct{} `json:\"files\"`\n\tForm  struct {\n\t\tOne string `json:\"one\"`\n\t} `json:\"form\"`\n\tHeaders struct {\n\t\tAccept        string `json:\"Accept\"`\n\t\tContentLength string `json:\"Content-Length\"`\n\t\tContentType   string `json:\"Content-Type\"`\n\t\tHost          string `json:\"Host\"`\n\t\tUserAgent     string `json:\"User-Agent\"`\n\t} `json:\"headers\"`\n\tJSON   interface{} `json:\"json\"`\n\tOrigin string      `json:\"origin\"`\n\tURL    string      `json:\"url\"`\n}\n\ntype BasicPostJSONResponse struct {\n\tArgs    struct{} `json:\"args\"`\n\tData    string   `json:\"data\"`\n\tFiles   struct{} `json:\"files\"`\n\tForm    struct{} `json:\"form\"`\n\tHeaders struct {\n\t\tAcceptEncoding string `json:\"Accept-Encoding\"`\n\t\tContentLength  string `json:\"Content-Length\"`\n\t\tContentType    string `json:\"Content-Type\"`\n\t\tHost           string `json:\"Host\"`\n\t\tUserAgent      string `json:\"User-Agent\"`\n\t\tXRequestedWith string `json:\"X-Requested-With\"`\n\t} `json:\"headers\"`\n\tJSON struct {\n\t\tOne string `json:\"One\"`\n\t} `json:\"json\"`\n\tOrigin string `json:\"origin\"`\n\tURL    string `json:\"url\"`\n}\n\ntype BasicMultiFileUploadResponse struct {\n\tArgs  struct{} `json:\"args\"`\n\tData  string   `json:\"data\"`\n\tFiles struct {\n\t\tFile1 string `json:\"file1\"`\n\t\tFile2 string `json:\"file2\"`\n\t} `json:\"files\"`\n\tForm struct {\n\t\tOne string `json:\"One\"`\n\t} `json:\"form\"`\n\tHeaders struct {\n\t\tAcceptEncoding string `json:\"Accept-Encoding\"`\n\t\tContentLength  string `json:\"Content-Length\"`\n\t\tContentType    string `json:\"Content-Type\"`\n\t\tHost           string `json:\"Host\"`\n\t\tUserAgent      string `json:\"User-Agent\"`\n\t} `json:\"headers\"`\n\tJSON   interface{} `json:\"json\"`\n\tOrigin string      `json:\"origin\"`\n\tURL    string      `json:\"url\"`\n}\n\ntype BasicPostFileUpload struct {\n\tArgs  struct{} `json:\"args\"`\n\tData  string   `json:\"data\"`\n\tFiles struct {\n\t\tFile string `json:\"file\"`\n\t} `json:\"files\"`\n\tForm struct {\n\t\tOne string `json:\"one\"`\n\t} `json:\"form\"`\n\tHeaders struct {\n\t\tAcceptEncoding string `json:\"Accept-Encoding\"`\n\t\tContentLength  string `json:\"Content-Length\"`\n\t\tContentType    string `json:\"Content-Type\"`\n\t\tHost           string `json:\"Host\"`\n\t\tUserAgent      string `json:\"User-Agent\"`\n\t} `json:\"headers\"`\n\tJSON   interface{} `json:\"json\"`\n\tOrigin string      `json:\"origin\"`\n\tURL    string      `json:\"url\"`\n}\n\ntype XMLPostMessage struct {\n\tName   string\n\tAge    int\n\tHeight int\n}\n\ntype dataAndErrorBuffer struct {\n\terr error\n\tbytes.Buffer\n}\n\nfunc (dataAndErrorBuffer) Close() error { return nil }\n\nfunc (r dataAndErrorBuffer) Read(p []byte) (n int, err error) {\n\treturn 0, r.err\n}\n\nfunc TestBasicPostRequest(t *testing.T) {\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{Data: map[string]string{\"One\": \"Two\"}})\n\tverifyOkPostResponse(resp, t)\n\n}\n\nfunc TestBasicRegularPostRequest(t *testing.T) {\n\tresp, err := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{Data: map[string]string{\"One\": \"Two\"}})\n\n\tif err != nil {\n\t\tt.Error(\"Cannot post: \", err)\n\t}\n\n\tverifyOkPostResponse(resp, t)\n\n}\n\nfunc TestBasicPostRequestInvalidURL(t *testing.T) {\n\tresp, _ := Post(\"%../dir/\",\n\t\t&RequestOptions{Data: map[string]string{\"One\": \"Two\"},\n\t\t\tParams: map[string]string{\"1\": \"2\"}})\n\n\tif resp.Error == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n}\n\nfunc TestBasicPostRequestInvalidURLNoParams(t *testing.T) {\n\tresp, _ := Post(\"%../dir/\", &RequestOptions{Data: map[string]string{\"One\": \"Two\"}})\n\n\tif resp.Error == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n}\n\nfunc TestSessionPostRequestInvalidURLNoParams(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Post(\"%../dir/\", &RequestOptions{Data: map[string]string{\"One\": \"Two\"}}); err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n}\n\nfunc TestXMLPostRequestInvalidURL(t *testing.T) {\n\tresp, _ := Post(\"%../dir/\",\n\t\t&RequestOptions{XML: XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}})\n\n\tif resp.Error == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n}\n\nfunc TestXMLSessionPostRequestInvalidURL(t *testing.T) {\n\tsession := NewSession(nil)\n\n\t_, err := session.Post(\"%../dir/\",\n\t\t&RequestOptions{XML: XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n}\n\nfunc TestBasicPostJsonRequestInvalidURL(t *testing.T) {\n\t_, err := Post(\"%../dir/\",\n\t\t&RequestOptions{JSON: map[string]string{\"One\": \"Two\"}, IsAjax: true})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n}\n\nfunc TestSessionPostJsonRequestInvalidURL(t *testing.T) {\n\tsession := NewSession(nil)\n\n\t_, err := session.Post(\"%../dir/\",\n\t\t&RequestOptions{JSON: map[string]string{\"One\": \"Two\"}, IsAjax: true})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n}\n\nfunc TestBasicPostJsonRequestInvalidJSON(t *testing.T) {\n\tresp, err := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{JSON: math.NaN(), IsAjax: true})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Somehow the request is OK\")\n\t}\n}\n\nfunc TestSessionPostJsonRequestInvalidJSON(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{JSON: math.NaN(), IsAjax: true})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Somehow the request is OK\")\n\t}\n}\n\nfunc TestBasicPostJsonRequestInvalidXML(t *testing.T) {\n\tresp, err := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{XML: map[string]string{\"One\": \"two\"}, IsAjax: true})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Somehow the request is OK\")\n\t}\n}\n\nfunc TestSessionPostJsonRequestInvalidXML(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{XML: map[string]string{\"One\": \"two\"}, IsAjax: true})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow the request went through\")\n\t}\n\n\tif resp.Ok == true {\n\t\tt.Error(\"Somehow the request is OK\")\n\t}\n}\n\nfunc TestBasicPostRequestUploadInvalidURL(t *testing.T) {\n\n\tfd, err := FileUploadFromDisk(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\tdefer fd[0].FileContents.Close()\n\n\tresp, _ := Post(\"%../dir/\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif resp.Error == nil {\n\t\tt.Fatal(\"Somehow able to make the request\")\n\t}\n}\n\nfunc TestSessionPostRequestUploadInvalidURL(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tfd, err := FileUploadFromDisk(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\tdefer fd[0].FileContents.Close()\n\n\t_, err = session.Post(\"%../dir/\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"Somehow able to make the request\")\n\t}\n}\n\nfunc TestBasicPostRequestUploadInvalidFileUpload(t *testing.T) {\n\n\tresp, _ := Post(\"%../dir/\",\n\t\t&RequestOptions{\n\t\t\tFiles: []FileUpload{{FileName: `\\x00%'\"üfdsufhid\\Ä\\\"D\\\\\\\"JS%25//'\"H•\\\\\\\\'\"¶•ªç∂\\uf8\\x8AKÔÓÔ`, FileContents: nil}},\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif resp.Error == nil {\n\t\tt.Fatal(\"Somehow able to make the request\")\n\t}\n}\n\nfunc TestSessionPostRequestUploadInvalidFileUpload(t *testing.T) {\n\tsession := NewSession(nil)\n\t_, err := session.Post(\"%../dir/\",\n\t\t&RequestOptions{\n\t\t\tFiles: []FileUpload{{FileName: \"üfdsufhidÄDJSHAKÔÓÔ\", FileContents: nil}},\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"Somehow able to make the request\")\n\t}\n}\n\nfunc TestXMLPostRequest(t *testing.T) {\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{XML: XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tmyXMLStruct := &XMLPostMessage{}\n\n\txml.Unmarshal([]byte(myJSONStruct.Data), myXMLStruct)\n\n\tif myXMLStruct.Age != 1 {\n\t\tt.Errorf(\"Unable to serialize XML response from within JSON %#v \", myXMLStruct)\n\t}\n\n}\n\nfunc TestXMLPostRequestReaderBody(t *testing.T) {\n\tmsg := XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}\n\tderBytes, err := xml.Marshal(msg)\n\tif err != nil {\n\t\tt.Fatal(\"Unable to marshal XML\", err)\n\t}\n\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{RequestBody: bytes.NewReader(derBytes)})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tmyXMLStruct := &XMLPostMessage{}\n\n\txml.Unmarshal([]byte(myJSONStruct.Data), myXMLStruct)\n\n\tif myXMLStruct.Age != 1 {\n\t\tt.Errorf(\"Unable to serialize XML response from within JSON %#v \", myXMLStruct)\n\t}\n\n}\n\nfunc TestXMLMarshaledStringPostRequest(t *testing.T) {\n\txmlStruct := XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}\n\tencoded, _ := xml.Marshal(xmlStruct)\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{XML: string(encoded)})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to response to JSON\", err)\n\t}\n\n\tif myJSONStruct.Data != string(encoded) {\n\t\tt.Error(\"Response is not valid\", myJSONStruct.Data, string(encoded))\n\t}\n}\n\nfunc TestXMLMarshaledBytesPostRequest(t *testing.T) {\n\txmlStruct := XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}\n\tencoded, _ := xml.Marshal(xmlStruct)\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{XML: encoded})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to response to JSON\", err)\n\t}\n\n\tif myJSONStruct.Data != string(encoded) {\n\t\tt.Error(\"Response is not valid\", myJSONStruct.Data, string(encoded))\n\t}\n}\n\nfunc TestXMLNilPostRequest(t *testing.T) {\n\tresp, _ := Post(\"http://httpbin.org/post\", &RequestOptions{XML: nil})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to response to JSON\", err)\n\t}\n\n\tif myJSONStruct.Data != \"\" {\n\t\tt.Error(\"Response is not valid\", myJSONStruct.Data)\n\t}\n}\n\nfunc TestBasicPostRequestUploadErrorReader(t *testing.T) {\n\tvar rd dataAndErrorBuffer\n\trd.err = fmt.Errorf(\"Random Error\")\n\t_, err := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{\n\t\t\tFiles: []FileUpload{{FileName: \"Random.test\", FileContents: rd}},\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err == nil {\n\t\tt.Error(\"Somehow our test didn't fail...\")\n\t}\n}\n\nfunc TestBasicPostRequestUploadErrorEOFReader(t *testing.T) {\n\tvar rd dataAndErrorBuffer\n\trd.err = io.EOF\n\t_, err := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{\n\t\t\tFiles: []FileUpload{{FileName: \"Random.test\", FileContents: rd}},\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err != nil {\n\t\tt.Error(\"Somehow our test didn't fail... \", err)\n\t}\n}\n\nfunc TestBasicPostRequestUpload(t *testing.T) {\n\n\tfd, err := FileUploadFromDisk(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostFileUpload{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.Files.File != \"saucy sauce\" {\n\t\tt.Error(\"File upload contents have been modified: \", myJSONStruct.Files.File)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\tif myJSONStruct.Form.One != \"Two\" {\n\t\tt.Error(\"Unable to parse form properly\", myJSONStruct.Form)\n\t}\n}\n\nfunc TestBasicPostRequestUploadWithMime(t *testing.T) {\n\n\tfd, err := os.Open(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{\n\t\t\tFiles: []FileUpload{{FileContents: fd, FileMime: \"text/plain\"}},\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostFileUpload{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.Files.File != \"saucy sauce\" {\n\t\tt.Error(\"File upload contents have been modified: \", myJSONStruct.Files.File)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\tif myJSONStruct.Form.One != \"Two\" {\n\t\tt.Error(\"Unable to parse form properly\", myJSONStruct.Form)\n\t}\n\n\t// TODO: Ensure file field contains correct content-type, field, and\n\t// filename information as soon as\n\t// https://github.com/kennethreitz/httpbin/pull/388 gets merged\n\t// (Or figure out a way to test this case the PR is rejected)\n}\n\nfunc TestBasicPostRequestUploadMultipleFiles(t *testing.T) {\n\n\tfd, err := FileUploadFromGlob(\"testdata/*\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to glob file: \", err)\n\t}\n\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicMultiFileUploadResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.Files.File2 != \"saucy sauce\" {\n\t\tt.Error(\"File upload contents have been modified: \", myJSONStruct.Files.File2)\n\t}\n\tif myJSONStruct.Files.File1 != \"I am just here to test the glob\" {\n\t\tt.Error(\"File upload contents have been modified: \", myJSONStruct.Files.File1)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\tif myJSONStruct.Form.One != \"Two\" {\n\t\tt.Error(\"Unable to parse form properly\", myJSONStruct.Form)\n\t}\n\n}\n\nfunc TestBasicPostJsonBytesRequest(t *testing.T) {\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{JSON: []byte(`{\"One\":\"Two\"}`), IsAjax: true})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.JSON.One != \"Two\" {\n\t\tt.Error(\"Invalid post response: \", myJSONStruct.JSON.One)\n\t}\n\n\tif strings.TrimSpace(myJSONStruct.Data) != `{\"One\":\"Two\"}` {\n\t\tt.Error(\"JSON not properly returned: \", myJSONStruct.Data)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\tif myJSONStruct.Headers.XRequestedWith != \"XMLHttpRequest\" {\n\t\tt.Error(\"Invalid requested header: \", myJSONStruct.Headers.XRequestedWith)\n\t}\n\n}\n\nfunc TestBasicPostJsonStringRequest(t *testing.T) {\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{JSON: `{\"One\":\"Two\"}`, IsAjax: true})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.JSON.One != \"Two\" {\n\t\tt.Error(\"Invalid post response: \", myJSONStruct.JSON.One)\n\t}\n\n\tif strings.TrimSpace(myJSONStruct.Data) != `{\"One\":\"Two\"}` {\n\t\tt.Error(\"JSON not properly returned: \", myJSONStruct.Data)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\tif myJSONStruct.Headers.XRequestedWith != \"XMLHttpRequest\" {\n\t\tt.Error(\"Invalid requested header: \", myJSONStruct.Headers.XRequestedWith)\n\t}\n\n}\n\nfunc TestBasicPostJsonRequest(t *testing.T) {\n\tresp, _ := Post(\"http://httpbin.org/post\",\n\t\t&RequestOptions{JSON: map[string]string{\"One\": \"Two\"}, IsAjax: true})\n\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostJSONResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.JSON.One != \"Two\" {\n\t\tt.Error(\"Invalid post response: \", myJSONStruct.JSON.One)\n\t}\n\n\tif strings.TrimSpace(myJSONStruct.Data) != `{\"One\":\"Two\"}` {\n\t\tt.Error(\"JSON not properly returned: \", myJSONStruct.Data)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\tif myJSONStruct.Headers.XRequestedWith != \"XMLHttpRequest\" {\n\t\tt.Error(\"Invalid requested header: \", myJSONStruct.Headers.XRequestedWith)\n\t}\n\n}\n\nfunc TestPostSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Post(\"http://httpbin.org/post\", &RequestOptions{Data: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tif len(session.HTTPClient.Jar.Cookies(cookieURL)) != 3 {\n\t\tt.Error(\"Invalid number of cookies provided: \", session.HTTPClient.Jar.Cookies(cookieURL))\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n}\n\n// verifyResponse will verify the following conditions\n// 1. The request didn't return an error\n// 2. The response returned an OK (a status code within the 200 range)\n// 3. The output can be coerced to JSON (this may change later)\n// It should only be run when testing GET request to http://httpbin.org/post expecting JSON\nfunc verifyOkPostResponse(resp *Response, t *testing.T) *BasicPostResponse {\n\tif resp.Error != nil {\n\t\tt.Fatal(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tmyJSONStruct := &BasicPostResponse{}\n\n\tif err := resp.JSON(myJSONStruct); err != nil {\n\t\tt.Error(\"Unable to coerce to JSON\", err)\n\t}\n\n\tif myJSONStruct.URL != \"http://httpbin.org/post\" {\n\t\tt.Error(\"For some reason the URL isn't the same\", myJSONStruct.URL)\n\t}\n\n\tif myJSONStruct.Headers.Host != \"httpbin.org\" {\n\t\tt.Error(\"The host header is invalid\")\n\t}\n\n\tif myJSONStruct.Form.One != \"Two\" {\n\t\tt.Errorf(\"Invalid post response: %#v\", myJSONStruct.Form)\n\t}\n\n\tif resp.Bytes() != nil {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (Bytes)\", resp.Bytes())\n\t}\n\n\tif resp.String() != \"\" {\n\t\tt.Error(\"JSON decoding did not fully consume the response stream (String)\", resp.String())\n\t}\n\n\tif resp.StatusCode != 200 {\n\t\tt.Error(\"Response returned a non-200 code\")\n\t}\n\n\treturn myJSONStruct\n}\n\nfunc TestPostInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Post(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n"
        },
        {
          "name": "base_put_test.go",
          "type": "blob",
          "size": 3.3642578125,
          "content": "package grequests\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestBasicPutRequest(t *testing.T) {\n\tresp, err := Put(\"http://httpbin.org/put\", nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n}\n\nfunc TestBasicPutUploadRequest(t *testing.T) {\n\tfd, err := FileUploadFromDisk(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\tresp, _ := Put(\"http://httpbin.org/put\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif resp.Error != nil {\n\t\tt.Error(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n}\n\nfunc TestBasicPutUploadRequestInvalidURL(t *testing.T) {\n\tfd, err := FileUploadFromDisk(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\t_, err = Put(\"%../dir/\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"Somehow able to make the request\")\n\t}\n}\n\nfunc TestSessionPutUploadRequestInvalidURL(t *testing.T) {\n\tfd, err := FileUploadFromDisk(\"testdata/mypassword\")\n\n\tif err != nil {\n\t\tt.Error(\"Unable to open file: \", err)\n\t}\n\n\tsession := NewSession(nil)\n\n\t_, err = session.Put(\"%../dir/\",\n\t\t&RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err == nil {\n\t\tt.Fatal(\"Somehow able to make the request\")\n\t}\n}\n\nfunc TestPutSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tresp, err := session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"two\": \"three\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Get(\"http://httpbin.org/cookies/set\", &RequestOptions{Params: map[string]string{\"three\": \"four\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tresp, err = session.Put(\"http://httpbin.org/put\", &RequestOptions{Data: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tt.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Error(\"Request did not return OK\")\n\t}\n\n\tcookieURL, err := url.Parse(\"http://httpbin.org\")\n\tif err != nil {\n\t\tt.Error(\"We (for some reason) cannot parse the cookie URL\")\n\t}\n\n\tif len(session.HTTPClient.Jar.Cookies(cookieURL)) != 3 {\n\t\tt.Error(\"Invalid number of cookies provided: \", session.HTTPClient.Jar.Cookies(cookieURL))\n\t}\n\n\tfor _, cookie := range session.HTTPClient.Jar.Cookies(cookieURL) {\n\t\tswitch cookie.Name {\n\t\tcase \"one\":\n\t\t\tif cookie.Value != \"two\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"two\":\n\t\t\tif cookie.Value != \"three\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tcase \"three\":\n\t\t\tif cookie.Value != \"four\" {\n\t\t\t\tt.Error(\"Cookie value is not valid\", cookie)\n\t\t\t}\n\t\tdefault:\n\t\t\tt.Error(\"We should not have any other cookies: \", cookie)\n\t\t}\n\t}\n\n}\n\nfunc TestPutInvalidURLSession(t *testing.T) {\n\tsession := NewSession(nil)\n\n\tif _, err := session.Put(\"%../dir/\", nil); err == nil {\n\t\tt.Error(\"Some how the request was valid to make request \", err)\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 6.93359375,
          "content": "package grequests_test\n\nimport (\n\t\"encoding/xml\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\n\t\"github.com/levigross/grequests\"\n)\n\nfunc Example_basicGet() {\n\t// This is a very basic GET request\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tlog.Println(resp.String())\n}\n\nfunc Example_basicGetCustomHTTPClient() {\n\t// This is a very basic GET request\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", &grequests.RequestOptions{HTTPClient: http.DefaultClient})\n\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tlog.Println(resp.String())\n}\n\nfunc Example_proxy() {\n\tproxyURL, err := url.Parse(\"http://127.0.0.1:8080\") // Proxy URL\n\tif err != nil {\n\t\tlog.Panicln(err)\n\t}\n\n\tresp, err := grequests.Get(\"http://www.levigross.com/\",\n\t\t&grequests.RequestOptions{Proxies: map[string]*url.URL{proxyURL.Scheme: proxyURL}})\n\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tlog.Println(resp)\n}\n\nfunc Example_cookies() {\n\tresp, err := grequests.Get(\"http://httpbin.org/cookies\",\n\t\t&grequests.RequestOptions{\n\t\t\tCookies: []*http.Cookie{\n\t\t\t\t{\n\t\t\t\t\tName:     \"TestCookie\",\n\t\t\t\t\tValue:    \"Random Value\",\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tSecure:   false,\n\t\t\t\t}, {\n\t\t\t\t\tName:     \"AnotherCookie\",\n\t\t\t\t\tValue:    \"Some Value\",\n\t\t\t\t\tHttpOnly: true,\n\t\t\t\t\tSecure:   false,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tlog.Println(resp.String())\n}\n\nfunc Example_session() {\n\tsession := grequests.NewSession(nil)\n\n\tresp, err := session.Get(\"http://httpbin.org/cookies/set\", &grequests.RequestOptions{Params: map[string]string{\"one\": \"two\"}})\n\n\tif err != nil {\n\t\tlog.Fatal(\"Cannot set cookie: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tlog.Println(resp.String())\n\n}\n\nfunc Example_parse_XML() {\n\ttype GetXMLSample struct {\n\t\tXMLName xml.Name `xml:\"slideshow\"`\n\t\tTitle   string   `xml:\"title,attr\"`\n\t\tDate    string   `xml:\"date,attr\"`\n\t\tAuthor  string   `xml:\"author,attr\"`\n\t\tSlide   []struct {\n\t\t\tType  string `xml:\"type,attr\"`\n\t\t\tTitle string `xml:\"title\"`\n\t\t} `xml:\"slide\"`\n\t}\n\n\tresp, err := grequests.Get(\"http://httpbin.org/xml\", nil)\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tuserXML := &GetXMLSample{}\n\n\t// func xmlASCIIDecoder(charset string, input io.Reader) (io.Reader, error) {\n\t// \treturn input, nil\n\t// }\n\n\t// If the server returns XML encoded in another charset (not UTF-8) – you\n\t// must provide an encoder function that looks like the one I wrote above.\n\n\t// If you an consuming UTF-8 just pass `nil` into the second arg\n\tif err := resp.XML(userXML, xmlASCIIDecoder); err != nil {\n\t\tlog.Println(\"Unable to consume the response as XML: \", err)\n\t}\n\n\tif userXML.Title != \"Sample Slide Show\" {\n\t\tlog.Printf(\"Invalid XML serialization %#v\", userXML)\n\t}\n}\n\nfunc Example_customUserAgent() {\n\tro := &grequests.RequestOptions{UserAgent: \"LeviBot 0.1\"}\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", ro)\n\n\tif err != nil {\n\t\tlog.Fatal(\"Oops something went wrong: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tlog.Println(resp.String())\n}\n\nfunc Example_basicAuth() {\n\tro := &grequests.RequestOptions{Auth: []string{\"Levi\", \"Bot\"}}\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", ro)\n\t// Not the usual JSON so copy and paste from below\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_customHTTPHeader() {\n\tro := &grequests.RequestOptions{UserAgent: \"LeviBot 0.1\",\n\t\tHeaders: map[string]string{\"X-Wonderful-Header\": \"1\"}}\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", ro)\n\t// Not the usual JSON so copy and paste from below\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_acceptInvalidTLSCert() {\n\tro := &grequests.RequestOptions{InsecureSkipVerify: true}\n\tresp, err := grequests.Get(\"https://www.pcwebshop.co.uk/\", ro)\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_urlQueryParams() {\n\tro := &grequests.RequestOptions{\n\t\tParams: map[string]string{\"Hello\": \"World\", \"Goodbye\": \"World\"},\n\t}\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", ro)\n\t// url will now be http://httpbin.org/get?hello=world&goodbye=world\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_downloadFile() {\n\tresp, err := grequests.Get(\"http://httpbin.org/get\", nil)\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n\tif err := resp.DownloadToFile(\"randomFile\"); err != nil {\n\t\tlog.Println(\"Unable to download to file: \", err)\n\t}\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to download file\", err)\n\t}\n\n}\n\nfunc Example_postForm() {\n\tresp, err := grequests.Post(\"http://httpbin.org/post\",\n\t\t&grequests.RequestOptions{Data: map[string]string{\"One\": \"Two\"}})\n\n\t// This is the basic form POST. The request body will be `one=two`\n\n\tif err != nil {\n\t\tlog.Println(\"Cannot post: \", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_postXML() {\n\n\ttype XMLPostMessage struct {\n\t\tName   string\n\t\tAge    int\n\t\tHeight int\n\t}\n\n\tresp, err := grequests.Post(\"http://httpbin.org/post\",\n\t\t&grequests.RequestOptions{XML: XMLPostMessage{Name: \"Human\", Age: 1, Height: 1}})\n\t// The request body will contain the XML generated by the `XMLPostMessage` struct\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_postFileUpload() {\n\n\tfd, err := grequests.FileUploadFromDisk(\"test_files/mypassword\")\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to open file: \", err)\n\t}\n\n\t// This will upload the file as a multipart mime request\n\tresp, err := grequests.Post(\"http://httpbin.org/post\",\n\t\t&grequests.RequestOptions{\n\t\t\tFiles: fd,\n\t\t\tData:  map[string]string{\"One\": \"Two\"},\n\t\t})\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n}\n\nfunc Example_postJSONAJAX() {\n\tresp, err := grequests.Post(\"http://httpbin.org/post\",\n\t\t&grequests.RequestOptions{\n\t\t\tJSON:   map[string]string{\"One\": \"Two\"},\n\t\t\tIsAjax: true, // this adds the X-Requested-With: XMLHttpRequest header\n\t\t})\n\n\tif err != nil {\n\t\tlog.Println(\"Unable to make request\", resp.Error)\n\t}\n\n\tif resp.Ok != true {\n\t\tlog.Println(\"Request did not return OK\")\n\t}\n\n}\n\nfunc xmlASCIIDecoder(charset string, input io.Reader) (io.Reader, error) {\n\treturn input, nil\n}\n"
        },
        {
          "name": "file_upload.go",
          "type": "blob",
          "size": 1.7939453125,
          "content": "package grequests\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FileUpload is a struct that is used to specify the file that a User\n// wishes to upload.\ntype FileUpload struct {\n\t// Filename is the name of the file that you wish to upload. We use this to guess the mimetype as well as pass it onto the server\n\tFileName string\n\n\t// FileContents is happy as long as you pass it a io.ReadCloser (which most file use anyways)\n\tFileContents io.ReadCloser\n\n\t// FieldName is form field name\n\tFieldName string\n\n\t// FileMime represents which mimetime should be sent along with the file.\n\t// When empty, defaults to application/octet-stream\n\tFileMime string\n}\n\n// FileUploadFromDisk allows you to create a FileUpload struct slice by just specifying a location on the disk\nfunc FileUploadFromDisk(fileName string) ([]FileUpload, error) {\n\tfd, err := os.Open(fileName)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn []FileUpload{{FileContents: fd, FileName: fileName}}, nil\n\n}\n\n// FileUploadFromGlob allows you to create a FileUpload struct slice by just specifying a glob location on the disk\n// this function will gloss over all errors in the files and only upload the files that don't return errors from the glob\nfunc FileUploadFromGlob(fileSystemGlob string) ([]FileUpload, error) {\n\tfiles, err := filepath.Glob(fileSystemGlob)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(files) == 0 {\n\t\treturn nil, errors.New(\"grequests: No files have been returned in the glob\")\n\t}\n\n\tfilesToUpload := make([]FileUpload, 0, len(files))\n\n\tfor _, f := range files {\n\t\tif s, err := os.Stat(f); err != nil || s.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\t// ignoring error because I can stat the file\n\t\tfd, _ := os.Open(f)\n\n\t\tfilesToUpload = append(filesToUpload, FileUpload{FileContents: fd, FileName: filepath.Base(fd.Name())})\n\n\t}\n\n\treturn filesToUpload, nil\n\n}\n"
        },
        {
          "name": "file_upload_test.go",
          "type": "blob",
          "size": 1.0361328125,
          "content": "package grequests\n\nimport \"testing\"\n\nfunc TestErrorOpenFile(t *testing.T) {\n\tfd, err := FileUploadFromDisk(\"I am Not A File\")\n\tif err == nil {\n\t\tt.Error(\"We are not getting an error back from our non existent file: \")\n\t}\n\n\tif fd != nil {\n\t\tt.Error(\"We actually got back a pointer: \", fd)\n\t}\n}\n\nfunc TestGLOBFiles(t *testing.T) {\n\tfd, err := FileUploadFromGlob(\"testdata/*\")\n\n\tif err != nil {\n\t\tt.Error(\"Got an invalid GLOB: \", err)\n\t}\n\n\tif len(fd) != 2 {\n\t\tt.Error(\"Some how we have more than two files in our glob\", len(fd), fd)\n\t}\n}\n\nfunc TestInvalidGlob(t *testing.T) {\n\tif _, err := FileUploadFromGlob(\"[-]\"); err == nil {\n\t\tt.Error(\"Somehow the glob worked\")\n\t}\n}\n\nfunc TestNoGlobFiles(t *testing.T) {\n\tif _, err := FileUploadFromGlob(\"notapath\"); err == nil {\n\t\tt.Error(\"Somehow got a valid GLOB\")\n\t}\n}\n\nfunc TestGlobWithDir(t *testing.T) {\n\tfd, err := FileUploadFromGlob(\"*test*\")\n\n\tif err != nil {\n\t\tt.Error(\"Glob failed\", err)\n\t}\n\n\tfor _, f := range fd {\n\t\tif f.FileName == \"test_files\" {\n\t\t\tt.Error(f, \"is a dir (which cannot be uploaded)\")\n\t\t}\n\t}\n\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.1240234375,
          "content": "module github.com/levigross/grequests\n\ngo 1.21\n\nrequire (\n\tgithub.com/google/go-querystring v1.1.0\n\tgolang.org/x/net v0.19.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.599609375,
          "content": "github.com/google/go-cmp v0.5.2 h1:X2ev0eStA3AbceY54o37/0PQ/UWqKEiiO2dKL5OPaFM=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngolang.org/x/net v0.19.0 h1:zTwKpTd2XuCqf8huc7Fo2iSy+4RHPd10s4KzeTnVr1c=\ngolang.org/x/net v0.19.0/go.mod h1:CfAk/cbD4CthTvqiEl8NpboMuiuOYsAr/7NOjZJtv1U=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "request.go",
          "type": "blob",
          "size": 16.015625,
          "content": "package grequests\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/cookiejar\"\n\t\"net/textproto\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/google/go-querystring/query\"\n\n\t\"context\"\n\n\t\"golang.org/x/net/publicsuffix\"\n)\n\n// RequestOptions is the location that of where the data\ntype RequestOptions struct {\n\n\t// Data is a map of key values that will eventually convert into the\n\t// the body of a POST request.\n\tData map[string]string\n\n\t// Params is a map of query strings that may be used within a GET request\n\tParams map[string]string\n\n\t// QueryStruct is a struct that encapsulates a set of URL query params\n\t// this paramter is mutually exclusive with `Params map[string]string` (they cannot be combined)\n\t// for more information please see https://godoc.org/github.com/google/go-querystring/query\n\tQueryStruct interface{}\n\n\t// Files is where you can include files to upload. The use of this data\n\t// structure is limited to POST requests\n\tFiles []FileUpload\n\n\t// JSON can be used when you wish to send JSON within the request body\n\tJSON interface{}\n\n\t// XML can be used if you wish to send XML within the request body\n\tXML interface{}\n\n\t// Headers if you want to add custom HTTP headers to the request,\n\t// this is your friend\n\tHeaders map[string]string\n\n\t// InsecureSkipVerify is a flag that specifies if we should validate the\n\t// server's TLS certificate. It should be noted that Go's TLS verify mechanism\n\t// doesn't validate if a certificate has been revoked\n\tInsecureSkipVerify bool\n\n\t// DisableCompression will disable gzip compression on requests\n\tDisableCompression bool\n\n\t// UserAgent allows you to set an arbitrary custom user agent\n\tUserAgent string\n\n\t// Host allows you to set an arbitrary custom host\n\tHost string\n\n\t// Auth allows you to specify a user name and password that you wish to\n\t// use when requesting the URL. It will use basic HTTP authentication\n\t// formatting the username and password in base64 the format is:\n\t// []string{username, password}\n\tAuth []string\n\n\t// IsAjax is a flag that can be set to make the request appear\n\t// to be generated by browser Javascript\n\tIsAjax bool\n\n\t// Cookies is an array of `http.Cookie` that allows you to attach\n\t// cookies to your request\n\tCookies []*http.Cookie\n\n\t// UseCookieJar will create a custom HTTP client that will\n\t// process and store HTTP cookies when they are sent down\n\tUseCookieJar bool\n\n\t// Proxies is a map in the following format\n\t// *protocol* => proxy address e.g http => http://127.0.0.1:8080\n\tProxies map[string]*url.URL\n\n\t// TLSHandshakeTimeout specifies the maximum amount of time waiting to\n\t// wait for a TLS handshake. Zero means no timeout.\n\tTLSHandshakeTimeout time.Duration\n\n\t// DialTimeout is the maximum amount of time a dial will wait for\n\t// a connect to complete.\n\tDialTimeout time.Duration\n\n\t// KeepAlive specifies the keep-alive period for an active\n\t// network connection. If zero, keep-alive are not enabled.\n\tDialKeepAlive time.Duration\n\n\t// RequestTimeout is the maximum amount of time a whole request(include dial / request / redirect)\n\t// will wait.\n\tRequestTimeout time.Duration\n\n\t// HTTPClient can be provided if you wish to supply a custom HTTP client\n\t// this is useful if you want to use an OAUTH client with your request.\n\tHTTPClient *http.Client\n\n\t// SensitiveHTTPHeaders is a map of sensitive HTTP headers that a user\n\t// doesn't want passed on a redirect.\n\tSensitiveHTTPHeaders map[string]struct{}\n\n\t// RedirectLimit is the acceptable amount of redirects that we should expect\n\t// before returning an error be default this is set to 30. You can change this\n\t// globally by modifying the `RedirectLimit` variable.\n\tRedirectLimit int\n\n\t// RequestBody allows you to put anything matching an `io.Reader` into the request\n\t// this option will take precedence over any other request option specified\n\tRequestBody io.Reader\n\n\t// CookieJar allows you to specify a special cookiejar to use with your request.\n\t// this option will take precedence over the `UseCookieJar` option above.\n\tCookieJar http.CookieJar\n\n\t// Context can be used to maintain state between requests https://golang.org/pkg/context/#Context\n\tContext context.Context\n\n\t// BeforeRequest is a hook that can be used to modify the request object\n\t// before the request has been fired. This is useful for adding authentication\n\t// and other functionality not provided in this library\n\tBeforeRequest func(req *http.Request) error\n\n\t// LocalAddr allows you to send the request on any local interface\n\tLocalAddr *net.TCPAddr\n}\n\n// DoRegularRequest adds generic test functionality\nfunc DoRegularRequest(requestVerb, url string, ro *RequestOptions) (*Response, error) {\n\treturn buildResponse(buildRequest(requestVerb, url, ro, nil))\n}\n\nfunc doSessionRequest(requestVerb, url string, ro *RequestOptions, httpClient *http.Client) (*Response, error) {\n\treturn buildResponse(buildRequest(requestVerb, url, ro, httpClient))\n}\n\nvar quoteEscaper = strings.NewReplacer(\"\\\\\", \"\\\\\\\\\", `\"`, \"\\\\\\\"\")\n\nfunc escapeQuotes(s string) string {\n\treturn quoteEscaper.Replace(s)\n}\n\n// buildRequest is where most of the magic happens for request processing\nfunc buildRequest(httpMethod, url string, ro *RequestOptions, httpClient *http.Client) (*http.Response, error) {\n\tif ro == nil {\n\t\tro = &RequestOptions{}\n\t}\n\n\tif ro.CookieJar != nil {\n\t\tro.UseCookieJar = true\n\t}\n\n\t// Create our own HTTP client\n\n\tif httpClient == nil {\n\t\thttpClient = BuildHTTPClient(*ro)\n\t}\n\n\tvar err error // we don't want to shadow url so we won't use :=\n\tswitch {\n\tcase len(ro.Params) != 0:\n\t\tif url, err = buildURLParams(url, ro.Params); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase ro.QueryStruct != nil:\n\t\tif url, err = buildURLStruct(url, ro.QueryStruct); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Build the request\n\treq, err := buildHTTPRequest(httpMethod, url, ro)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Do we need to add any HTTP headers or Basic Auth?\n\taddHTTPHeaders(ro, req)\n\taddCookies(ro, req)\n\n\taddRedirectFunctionality(httpClient, ro)\n\n\tif ro.Context != nil {\n\t\treq = req.WithContext(ro.Context)\n\t}\n\n\tif ro.BeforeRequest != nil {\n\t\tif err := ro.BeforeRequest(req); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn httpClient.Do(req)\n}\n\nfunc buildHTTPRequest(httpMethod, userURL string, ro *RequestOptions) (*http.Request, error) {\n\tif ro.RequestBody != nil {\n\t\treturn http.NewRequest(httpMethod, userURL, ro.RequestBody)\n\t}\n\n\tif ro.JSON != nil {\n\t\treturn createBasicJSONRequest(httpMethod, userURL, ro)\n\t}\n\n\tif ro.XML != nil {\n\t\treturn createBasicXMLRequest(httpMethod, userURL, ro)\n\t}\n\n\tif ro.Files != nil {\n\t\treturn createFileUploadRequest(httpMethod, userURL, ro)\n\t}\n\n\tif ro.Data != nil {\n\t\treturn createBasicRequest(httpMethod, userURL, ro)\n\t}\n\n\treturn http.NewRequest(httpMethod, userURL, nil)\n}\n\nfunc createFileUploadRequest(httpMethod, userURL string, ro *RequestOptions) (*http.Request, error) {\n\tif httpMethod == \"POST\" {\n\t\treturn createMultiPartPostRequest(httpMethod, userURL, ro)\n\t}\n\n\t// This may be a PUT or PATCH request so we will just put the raw\n\t// io.ReadCloser in the request body\n\t// and guess the MIME type from the file name\n\n\t// At the moment, we will only support 1 file upload as a time\n\t// when uploading using PUT or PATCH\n\n\treq, err := http.NewRequest(httpMethod, userURL, ro.Files[0].FileContents)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", mime.TypeByExtension(ro.Files[0].FileName))\n\n\treturn req, nil\n\n}\n\nfunc createBasicXMLRequest(httpMethod, userURL string, ro *RequestOptions) (*http.Request, error) {\n\tvar reader io.Reader\n\n\tswitch ro.XML.(type) {\n\tcase string:\n\t\treader = strings.NewReader(ro.XML.(string))\n\tcase []byte:\n\t\treader = bytes.NewReader(ro.XML.([]byte))\n\tdefault:\n\t\tbyteSlice, err := xml.Marshal(ro.XML)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treader = bytes.NewReader(byteSlice)\n\t}\n\n\treq, err := http.NewRequest(httpMethod, userURL, reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/xml\")\n\n\treturn req, nil\n\n}\nfunc createMultiPartPostRequest(httpMethod, userURL string, ro *RequestOptions) (*http.Request, error) {\n\trequestBody := &bytes.Buffer{}\n\n\tmultipartWriter := multipart.NewWriter(requestBody)\n\n\tfor i, f := range ro.Files {\n\n\t\tif f.FileContents == nil {\n\t\t\treturn nil, errors.New(\"grequests: Pointer FileContents cannot be nil\")\n\t\t}\n\n\t\tfieldName := f.FieldName\n\n\t\tif fieldName == \"\" {\n\t\t\tif len(ro.Files) > 1 {\n\t\t\t\tfieldName = strings.Join([]string{\"file\", strconv.Itoa(i + 1)}, \"\")\n\t\t\t} else {\n\t\t\t\tfieldName = \"file\"\n\t\t\t}\n\t\t}\n\n\t\tvar writer io.Writer\n\t\tvar err error\n\n\t\tif f.FileMime != \"\" {\n\t\t\tif f.FileName == \"\" {\n\t\t\t\tf.FileName = \"filename\"\n\t\t\t}\n\t\t\th := make(textproto.MIMEHeader)\n\t\t\th.Set(\"Content-Disposition\", fmt.Sprintf(`form-data; name=\"%s\"; filename=\"%s\"`, escapeQuotes(fieldName), escapeQuotes(f.FileName)))\n\t\t\th.Set(\"Content-Type\", f.FileMime)\n\t\t\twriter, err = multipartWriter.CreatePart(h)\n\t\t} else {\n\t\t\twriter, err = multipartWriter.CreateFormFile(fieldName, f.FileName)\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif _, err = io.Copy(writer, f.FileContents); err != nil && err != io.EOF {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif err := f.FileContents.Close(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t}\n\n\t// Populate the other parts of the form (if there are any)\n\tfor key, value := range ro.Data {\n\t\tmultipartWriter.WriteField(key, value)\n\t}\n\n\tif err := multipartWriter.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treq, err := http.NewRequest(httpMethod, userURL, requestBody)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Add(\"Content-Type\", multipartWriter.FormDataContentType())\n\n\treturn req, err\n}\n\nfunc createBasicJSONRequest(httpMethod, userURL string, ro *RequestOptions) (*http.Request, error) {\n\n\tvar reader io.Reader\n\tswitch ro.JSON.(type) {\n\tcase string:\n\t\treader = strings.NewReader(ro.JSON.(string))\n\tcase []byte:\n\t\treader = bytes.NewReader(ro.JSON.([]byte))\n\tdefault:\n\t\tbyteSlice, err := json.Marshal(ro.JSON)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treader = bytes.NewReader(byteSlice)\n\t}\n\n\treq, err := http.NewRequest(httpMethod, userURL, reader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treq.Header.Set(\"Content-Type\", \"application/json\")\n\n\treturn req, nil\n\n}\nfunc createBasicRequest(httpMethod, userURL string, ro *RequestOptions) (*http.Request, error) {\n\n\treq, err := http.NewRequest(httpMethod, userURL, strings.NewReader(encodePostValues(ro.Data)))\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// The content type must be set to a regular form\n\treq.Header.Set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\n\treturn req, nil\n}\n\nfunc encodePostValues(postValues map[string]string) string {\n\turlValues := &url.Values{}\n\n\tfor key, value := range postValues {\n\t\turlValues.Set(key, value)\n\t}\n\n\treturn urlValues.Encode() // This will sort all of the string values\n}\n\n// proxySettings will default to the default proxy settings if none are provided\n// if settings are provided – they will override the environment variables\nfunc (ro RequestOptions) proxySettings(req *http.Request) (*url.URL, error) {\n\t// No proxies – lets use the default\n\tif len(ro.Proxies) == 0 {\n\t\treturn http.ProxyFromEnvironment(req)\n\t}\n\n\t// There was a proxy specified – do we support the protocol?\n\tif _, ok := ro.Proxies[req.URL.Scheme]; ok {\n\t\treturn ro.Proxies[req.URL.Scheme], nil\n\t}\n\n\t// Proxies were specified but not for any protocol that we use\n\treturn http.ProxyFromEnvironment(req)\n\n}\n\n// dontUseDefaultClient will tell the \"client creator\" if a custom client is needed\n// it checks the following items (and will create a custom client of these are)\n// true\n// 1. Do we want to accept invalid SSL certificates?\n// 2. Do we want to disable compression?\n// 3. Do we want a custom proxy?\n// 4. Do we want to change the default timeout for TLS Handshake?\n// 5. Do we want to change the default request timeout?\n// 6. Do we want to change the default connection timeout?\n// 7. Do you want to use the http.Client's cookieJar?\n// 8. Do you want to change the request timeout?\n// 9. Do you want to set a custom LocalAddr to send the request from\nfunc (ro RequestOptions) dontUseDefaultClient() bool {\n\tswitch {\n\tcase ro.InsecureSkipVerify == true:\n\tcase ro.DisableCompression == true:\n\tcase len(ro.Proxies) != 0:\n\tcase ro.TLSHandshakeTimeout != 0:\n\tcase ro.DialTimeout != 0:\n\tcase ro.DialKeepAlive != 0:\n\tcase len(ro.Cookies) != 0:\n\tcase ro.UseCookieJar != false:\n\tcase ro.RequestTimeout != 0:\n\tcase ro.LocalAddr != nil:\n\tdefault:\n\t\treturn false\n\t}\n\treturn true\n}\n\n// BuildHTTPClient is a function that will return a custom HTTP client based on the request options provided\n// the check is in UseDefaultClient\nfunc BuildHTTPClient(ro RequestOptions) *http.Client {\n\n\tif ro.HTTPClient != nil {\n\t\treturn ro.HTTPClient\n\t}\n\n\t// Does the user want to change the defaults?\n\tif !ro.dontUseDefaultClient() {\n\t\treturn http.DefaultClient\n\t}\n\n\t// Using the user config for tls timeout or default\n\tif ro.TLSHandshakeTimeout == 0 {\n\t\tro.TLSHandshakeTimeout = tlsHandshakeTimeout\n\t}\n\n\t// Using the user config for dial timeout or default\n\tif ro.DialTimeout == 0 {\n\t\tro.DialTimeout = dialTimeout\n\t}\n\n\t// Using the user config for dial keep alive or default\n\tif ro.DialKeepAlive == 0 {\n\t\tro.DialKeepAlive = dialKeepAlive\n\t}\n\n\tif ro.RequestTimeout == 0 {\n\t\tro.RequestTimeout = requestTimeout\n\t}\n\n\tvar cookieJar http.CookieJar\n\n\tif ro.UseCookieJar {\n\t\tif ro.CookieJar != nil {\n\t\t\tcookieJar = ro.CookieJar\n\t\t} else {\n\t\t\t// The function does not return an error ever... so we are just ignoring it\n\t\t\tcookieJar, _ = cookiejar.New(&cookiejar.Options{PublicSuffixList: publicsuffix.List})\n\t\t}\n\t}\n\n\treturn &http.Client{\n\t\tJar:       cookieJar,\n\t\tTransport: createHTTPTransport(ro),\n\t\tTimeout:   ro.RequestTimeout,\n\t}\n}\n\nfunc createHTTPTransport(ro RequestOptions) *http.Transport {\n\tourHTTPTransport := &http.Transport{\n\t\t// These are borrowed from the default transporter\n\t\tProxy: ro.proxySettings,\n\t\tDial: (&net.Dialer{\n\t\t\tTimeout:   ro.DialTimeout,\n\t\t\tKeepAlive: ro.DialKeepAlive,\n\t\t\tLocalAddr: ro.LocalAddr,\n\t\t}).Dial,\n\t\tTLSHandshakeTimeout: ro.TLSHandshakeTimeout,\n\n\t\t// Here comes the user settings\n\t\tTLSClientConfig:    &tls.Config{InsecureSkipVerify: ro.InsecureSkipVerify},\n\t\tDisableCompression: ro.DisableCompression,\n\t}\n\tEnsureTransporterFinalized(ourHTTPTransport)\n\treturn ourHTTPTransport\n}\n\n// buildURLParams returns a URL with all of the params\n// Note: This function will override current URL params if they contradict what is provided in the map\n// That is what the \"magic\" is on the last line\nfunc buildURLParams(userURL string, params map[string]string) (string, error) {\n\tparsedURL, err := url.Parse(userURL)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tparsedQuery, err := url.ParseQuery(parsedURL.RawQuery)\n\n\tif err != nil {\n\t\treturn \"\", nil\n\t}\n\n\tfor key, value := range params {\n\t\tparsedQuery.Set(key, value)\n\t}\n\n\treturn addQueryParams(parsedURL, parsedQuery), nil\n}\n\n// addHTTPHeaders adds any additional HTTP headers that need to be added are added here including:\n// 1. Custom User agent\n// 2. Authorization Headers\n// 3. Any other header requested\nfunc addHTTPHeaders(ro *RequestOptions, req *http.Request) {\n\tfor key, value := range ro.Headers {\n\t\treq.Header.Set(key, value)\n\t}\n\n\tif ro.UserAgent != \"\" {\n\t\treq.Header.Set(\"User-Agent\", ro.UserAgent)\n\t} else {\n\t\treq.Header.Set(\"User-Agent\", localUserAgent)\n\t}\n\n\tif ro.Host != \"\" {\n\t\treq.Host = ro.Host\n\t}\n\n\tif ro.Auth != nil {\n\t\treq.SetBasicAuth(ro.Auth[0], ro.Auth[1])\n\t}\n\n\tif ro.IsAjax == true {\n\t\treq.Header.Set(\"X-Requested-With\", \"XMLHttpRequest\")\n\t}\n}\n\nfunc addCookies(ro *RequestOptions, req *http.Request) {\n\tfor _, c := range ro.Cookies {\n\t\treq.AddCookie(c)\n\t}\n}\n\nfunc addQueryParams(parsedURL *url.URL, parsedQuery url.Values) string {\n\treturn strings.Join([]string{strings.Replace(parsedURL.String(), \"?\"+parsedURL.RawQuery, \"\", -1), parsedQuery.Encode()}, \"?\")\n}\n\nfunc buildURLStruct(userURL string, URLStruct interface{}) (string, error) {\n\tparsedURL, err := url.Parse(userURL)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tparsedQuery, err := url.ParseQuery(parsedURL.RawQuery)\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tqueryStruct, err := query.Values(URLStruct)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor key, value := range queryStruct {\n\t\tfor _, v := range value {\n\t\t\tparsedQuery.Add(key, v)\n\t\t}\n\t}\n\n\treturn addQueryParams(parsedURL, parsedQuery), nil\n}\n"
        },
        {
          "name": "request_test.go",
          "type": "blob",
          "size": 0.9921875,
          "content": "package grequests\n\nimport \"testing\"\n\nfunc TestAddQueryStringParams(t *testing.T) {\n\tuserURL, err := buildURLParams(\"https://www.google.com/\", map[string]string{\"1\": \"2\", \"3\": \"4\"})\n\n\tif err != nil {\n\t\tt.Error(\"URL Parse Error: \", err)\n\t}\n\n\tif userURL != \"https://www.google.com/?1=2&3=4\" {\n\t\tt.Error(\"URL params not properly built\", userURL)\n\t}\n}\n\nfunc TestSortAddQueryStringParams(t *testing.T) {\n\tuserURL, err := buildURLParams(\"https://www.google.com/\", map[string]string{\"3\": \"4\", \"1\": \"2\"})\n\n\tif err != nil {\n\t\tt.Error(\"URL Parse Error: \", err)\n\t}\n\n\tif userURL != \"https://www.google.com/?1=2&3=4\" {\n\t\tt.Error(\"URL params not properly built and sorted\", userURL)\n\t}\n}\n\nfunc TestAddQueryStringParamsExistingParam(t *testing.T) {\n\tuserURL, err := buildURLParams(\"https://www.google.com/?5=6\", map[string]string{\"3\": \"4\", \"1\": \"2\"})\n\n\tif err != nil {\n\t\tt.Error(\"URL Parse Error: \", err)\n\t}\n\n\tif userURL != \"https://www.google.com/?1=2&3=4&5=6\" {\n\t\tt.Error(\"URL params not properly built and sorted\", userURL)\n\t}\n}\n"
        },
        {
          "name": "response.go",
          "type": "blob",
          "size": 4.8134765625,
          "content": "package grequests\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\n// Response is what is returned to a user when they fire off a request\ntype Response struct {\n\n\t// Ok is a boolean flag that validates that the server returned a 2xx code\n\tOk bool\n\n\t// This is the Go error flag – if something went wrong within the request, this flag will be set.\n\tError error\n\n\t// We want to abstract (at least at the moment) the Go http.Response object away. So we are going to make use of it\n\t// internal but not give the user access\n\tRawResponse *http.Response\n\n\t// StatusCode is the HTTP Status Code returned by the HTTP Response. Taken from resp.StatusCode\n\tStatusCode int\n\n\t// Header is a net/http/Header structure\n\tHeader http.Header\n\n\tinternalByteBuffer *bytes.Buffer\n}\n\nfunc buildResponse(resp *http.Response, err error) (*Response, error) {\n\t// If the connection didn't succeed we just return a blank response\n\tif err != nil {\n\t\treturn &Response{Error: err}, err\n\t}\n\n\tgoodResp := &Response{\n\t\t// If your code is within the 2xx range – the response is considered `Ok`\n\t\tOk:                 resp.StatusCode >= 200 && resp.StatusCode < 300,\n\t\tError:              nil,\n\t\tRawResponse:        resp,\n\t\tStatusCode:         resp.StatusCode,\n\t\tHeader:             resp.Header,\n\t\tinternalByteBuffer: bytes.NewBuffer([]byte{}),\n\t}\n\t// EnsureResponseFinalized(goodResp) This will come back in 1.0\n\treturn goodResp, nil\n}\n\n// Read is part of our ability to support io.ReadCloser if someone wants to make use of the raw body\nfunc (r *Response) Read(p []byte) (n int, err error) {\n\n\tif r.Error != nil {\n\t\treturn -1, r.Error\n\t}\n\n\treturn r.RawResponse.Body.Read(p)\n}\n\n// Close is part of our ability to support io.ReadCloser if someone wants to make use of the raw body\nfunc (r *Response) Close() error {\n\n\tif r.Error != nil {\n\t\treturn r.Error\n\t}\n\n\tio.Copy(ioutil.Discard, r)\n\n\treturn r.RawResponse.Body.Close()\n}\n\n// DownloadToFile allows you to download the contents of the response to a file\nfunc (r *Response) DownloadToFile(fileName string) error {\n\n\tif r.Error != nil {\n\t\treturn r.Error\n\t}\n\n\tfd, err := os.Create(fileName)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer r.Close() // This is a noop if we use the internal ByteBuffer\n\tdefer fd.Close()\n\n\tif _, err := io.Copy(fd, r.getInternalReader()); err != nil && err != io.EOF {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// getInternalReader because we implement io.ReadCloser and optionally hold a large buffer of the response (created by\n// the user's request)\nfunc (r *Response) getInternalReader() io.Reader {\n\n\tif r.internalByteBuffer.Len() != 0 {\n\t\treturn r.internalByteBuffer\n\t}\n\treturn r\n}\n\n// XML is a method that will populate a struct that is provided `userStruct` with the XML returned within the\n// response body\nfunc (r *Response) XML(userStruct interface{}, charsetReader XMLCharDecoder) error {\n\n\tif r.Error != nil {\n\t\treturn r.Error\n\t}\n\n\txmlDecoder := xml.NewDecoder(r.getInternalReader())\n\n\tif charsetReader != nil {\n\t\txmlDecoder.CharsetReader = charsetReader\n\t}\n\n\tdefer r.Close()\n\n\treturn xmlDecoder.Decode(&userStruct)\n}\n\n// JSON is a method that will populate a struct that is provided `userStruct` with the JSON returned within the\n// response body\nfunc (r *Response) JSON(userStruct interface{}) error {\n\n\tif r.Error != nil {\n\t\treturn r.Error\n\t}\n\n\tjsonDecoder := json.NewDecoder(r.getInternalReader())\n\tdefer r.Close()\n\n\treturn jsonDecoder.Decode(&userStruct)\n}\n\n// createResponseBytesBuffer is a utility method that will populate the internal byte reader – this is largely used for .String()\n// and .Bytes()\nfunc (r *Response) populateResponseByteBuffer() {\n\n\t// Have I done this already?\n\tif r.internalByteBuffer.Len() != 0 {\n\t\treturn\n\t}\n\n\tdefer r.Close()\n\n\t// Is there any content?\n\tif r.RawResponse.ContentLength == 0 {\n\t\treturn\n\t}\n\n\t// Did the server tell us how big the response is going to be?\n\tif r.RawResponse.ContentLength > 0 {\n\t\tr.internalByteBuffer.Grow(int(r.RawResponse.ContentLength))\n\t}\n\n\tif _, err := io.Copy(r.internalByteBuffer, r); err != nil && err != io.EOF {\n\t\tr.Error = err\n\t\tr.RawResponse.Body.Close()\n\t}\n\n}\n\n// Bytes returns the response as a byte array\nfunc (r *Response) Bytes() []byte {\n\n\tif r.Error != nil {\n\t\treturn nil\n\t}\n\n\tr.populateResponseByteBuffer()\n\n\t// Are we still empty?\n\tif r.internalByteBuffer.Len() == 0 {\n\t\treturn nil\n\t}\n\treturn r.internalByteBuffer.Bytes()\n\n}\n\n// String returns the response as a string\nfunc (r *Response) String() string {\n\tif r.Error != nil {\n\t\treturn \"\"\n\t}\n\n\tr.populateResponseByteBuffer()\n\n\treturn r.internalByteBuffer.String()\n}\n\n// ClearInternalBuffer is a function that will clear the internal buffer that we use to hold the .String() and .Bytes()\n// data. Once you have used these functions – you may want to free up the memory.\nfunc (r *Response) ClearInternalBuffer() {\n\n\tif r == nil || r.internalByteBuffer == nil {\n\t\treturn\n\t}\n\n\tr.internalByteBuffer.Reset()\n}\n"
        },
        {
          "name": "response_test.go",
          "type": "blob",
          "size": 0.5537109375,
          "content": "package grequests\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc TestResponseOk(t *testing.T) {\n\tstatus := []int{200, 201, 202, 203, 204, 205, 206, 207, 208, 226}\n\tfor _, status := range status {\n\t\tverifyResponseOkForStatus(status, t)\n\t}\n}\n\nfunc verifyResponseOkForStatus(status int, t *testing.T) {\n\turl := \"http://httpbin.org/status/\" + strconv.Itoa(status)\n\tresp, err := Get(url, nil)\n\n\tif err != nil {\n\t\tt.Error(\"Unable to make request\", err)\n\t}\n\n\tif resp.Ok != true {\n\t\tt.Errorf(\"Request did not return OK. Received status code %d rather a 2xx.\", resp.StatusCode)\n\t}\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 4.734375,
          "content": "package grequests\n\nimport \"net/http\"\n\n// Session allows a user to make use of persistent cookies in between\n// HTTP requests\ntype Session struct {\n\t// RequestOptions is global options\n\tRequestOptions *RequestOptions\n\n\t// HTTPClient is the client that we will use to request the resources\n\tHTTPClient *http.Client\n}\n\n// NewSession returns a session struct which enables can be used to maintain establish a persistent state with the\n// server\n// This function will set UseCookieJar to true as that is the purpose of using the session\nfunc NewSession(ro *RequestOptions) *Session {\n\tif ro == nil {\n\t\tro = &RequestOptions{}\n\t}\n\n\tro.UseCookieJar = true\n\n\treturn &Session{RequestOptions: ro, HTTPClient: BuildHTTPClient(*ro)}\n}\n\n// Combine session options and request options\n// 1. UserAgent\n// 2. Host\n// 3. Auth\n// 4. Headers\nfunc (s *Session) combineRequestOptions(ro *RequestOptions) *RequestOptions {\n\tif ro == nil {\n\t\tro = &RequestOptions{}\n\t}\n\n\tif ro.UserAgent == \"\" && s.RequestOptions.UserAgent != \"\" {\n\t\tro.UserAgent = s.RequestOptions.UserAgent\n\t}\n\n\tif ro.Host == \"\" && s.RequestOptions.Host != \"\" {\n\t\tro.Host = s.RequestOptions.Host\n\t}\n\n\tif ro.Auth == nil && s.RequestOptions.Auth != nil {\n\t\tro.Auth = s.RequestOptions.Auth\n\t}\n\n\tif len(s.RequestOptions.Headers) > 0 || len(ro.Headers) > 0 {\n\t\theaders := make(map[string]string)\n\t\tfor k, v := range s.RequestOptions.Headers {\n\t\t\theaders[k] = v\n\t\t}\n\t\tfor k, v := range ro.Headers {\n\t\t\theaders[k] = v\n\t\t}\n\t\tro.Headers = headers\n\t}\n\treturn ro\n}\n\n// Get takes 2 parameters and returns a Response Struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Get(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"GET\", url, ro, s.HTTPClient)\n}\n\n// Put takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Put(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"PUT\", url, ro, s.HTTPClient)\n}\n\n// Patch takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Patch(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"PATCH\", url, ro, s.HTTPClient)\n}\n\n// Delete takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Delete(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"DELETE\", url, ro, s.HTTPClient)\n}\n\n// Post takes 2 parameters and returns a Response channel. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Post(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"POST\", url, ro, s.HTTPClient)\n}\n\n// Head takes 2 parameters and returns a Response channel. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Head(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"HEAD\", url, ro, s.HTTPClient)\n}\n\n// Options takes 2 parameters and returns a Response struct. These two options are:\n// \t1. A URL\n// \t2. A RequestOptions struct\n// If you do not intend to use the `RequestOptions` you can just pass nil\n// A new session is created by calling NewSession with a request options struct\nfunc (s *Session) Options(url string, ro *RequestOptions) (*Response, error) {\n\tro = s.combineRequestOptions(ro)\n\treturn doSessionRequest(\"OPTIONS\", url, ro, s.HTTPClient)\n}\n\n// CloseIdleConnections closes the idle connections that a session client may make use of\nfunc (s *Session) CloseIdleConnections() {\n\ts.HTTPClient.Transport.(*http.Transport).CloseIdleConnections()\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 3.0078125,
          "content": "package grequests\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"net/http\"\n\t\"runtime\"\n\t\"time\"\n)\n\nconst (\n\tlocalUserAgent = \"GRequests/0.10\"\n\n\t// Default value for net.Dialer Timeout\n\tdialTimeout = 30 * time.Second\n\n\t// Default value for net.Dialer KeepAlive\n\tdialKeepAlive = 30 * time.Second\n\n\t// Default value for http.Transport TLSHandshakeTimeout\n\ttlsHandshakeTimeout = 10 * time.Second\n\n\t// Default value for Request Timeout\n\trequestTimeout = 90 * time.Second\n)\n\nvar (\n\t// ErrRedirectLimitExceeded is the error returned when the request responded\n\t// with too many redirects\n\tErrRedirectLimitExceeded = errors.New(\"grequests: Request exceeded redirect count\")\n\n\t// RedirectLimit is a tunable variable that specifies how many times we can\n\t// redirect in response to a redirect. This is the global variable, if you\n\t// wish to set this on a request by request basis, set it within the\n\t// `RequestOptions` structure\n\tRedirectLimit = 30\n\n\t// SensitiveHTTPHeaders is a map of sensitive HTTP headers that a user\n\t// doesn't want passed on a redirect. This is the global variable, if you\n\t// wish to set this on a request by request basis, set it within the\n\t// `RequestOptions` structure\n\tSensitiveHTTPHeaders = map[string]struct{}{\n\t\t\"Www-Authenticate\":    {},\n\t\t\"Authorization\":       {},\n\t\t\"Proxy-Authorization\": {},\n\t}\n)\n\n// XMLCharDecoder is a helper type that takes a stream of bytes (not encoded in\n// UTF-8) and returns a reader that encodes the bytes into UTF-8. This is done\n// because Go's XML library only supports XML encoded in UTF-8\ntype XMLCharDecoder func(charset string, input io.Reader) (io.Reader, error)\n\nfunc addRedirectFunctionality(client *http.Client, ro *RequestOptions) {\n\tif client.CheckRedirect != nil {\n\t\treturn\n\t}\n\tclient.CheckRedirect = func(req *http.Request, via []*http.Request) error {\n\n\t\tif ro.RedirectLimit < 0 {\n\t\t\treturn http.ErrUseLastResponse\n\t\t}\n\n\t\tif ro.RedirectLimit == 0 {\n\t\t\tro.RedirectLimit = RedirectLimit\n\t\t}\n\n\t\tif len(via) >= ro.RedirectLimit {\n\t\t\treturn ErrRedirectLimitExceeded\n\t\t}\n\n\t\tif ro.SensitiveHTTPHeaders == nil {\n\t\t\tro.SensitiveHTTPHeaders = SensitiveHTTPHeaders\n\t\t}\n\n\t\tfor k, vv := range via[0].Header {\n\t\t\t// Is this a sensitive header?\n\t\t\tif _, found := ro.SensitiveHTTPHeaders[k]; found {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, v := range vv {\n\t\t\t\treq.Header.Add(k, v)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t}\n}\n\n// EnsureTransporterFinalized will ensure that when the HTTP client is GCed\n// the runtime will close the idle connections (so that they won't leak)\n// this function was adopted from Hashicorp's go-cleanhttp package\nfunc EnsureTransporterFinalized(httpTransport *http.Transport) {\n\truntime.SetFinalizer(&httpTransport, func(transportInt **http.Transport) {\n\t\t(*transportInt).CloseIdleConnections()\n\t})\n}\n\n// EnsureResponseFinalized will ensure that when the Response is GCed\n// the request body is closed so we aren't leaking fds\n// func EnsureResponseFinalized(httpResp *Response) {\n// \truntime.SetFinalizer(&httpResp, func(httpResponseInt **Response) {\n// \t\t(*httpResponseInt).RawResponse.Body.Close()\n// \t})\n// }\n// This will come back in 1.0\n"
        },
        {
          "name": "utils_test.go",
          "type": "blob",
          "size": 0.017578125,
          "content": "package grequests\n"
        }
      ]
    }
  ]
}