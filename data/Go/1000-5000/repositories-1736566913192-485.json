{
  "metadata": {
    "timestamp": 1736566913192,
    "page": 485,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "justinas/alice",
      "stars": 3150,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.8515625,
          "content": "language: go\n\nmatrix:\n  include:\n    - go: 1.2.x\n      arch: amd64\n    - go: 1.3.x\n      arch: amd64\n    - go: 1.4.x\n      arch: amd64\n    - go: 1.5.x\n      arch: amd64\n    - go: 1.5.x\n      arch: ppc64le\n    - go: 1.6.x \n      arch: amd64\n    - go: 1.6.x\n      arch: ppc64le\n    - go: 1.7.x\n      arch: amd64\n    - go: 1.7.x\n      arch: ppc64le\n    - go: 1.8.x\n      arch: amd64\n    - go: 1.8.x\n      arch: ppc64le\n    - go: 1.9.x\n      arch: amd64\n    - go: 1.9.x\n      arch: ppc64le\n    - go: 1.10.x\n      arch: amd64\n    - go: 1.10.x\n      arch: ppc64le\n    - go: 1.11.x\n      arch: amd64\n    - go: 1.11.x\n      arch: ppc64le\n    - go: 1.12.x\n      arch: amd64\n    - go: 1.12.x\n      arch: ppc64le\n    - go: 1.13.x\n      arch: amd64\n    - go: 1.13.x\n      arch: ppc64le\n    - go: tip\n      arch: amd64\n    - go: tip\n      arch: ppc64le\n  allow_failures:\n    - go: tip\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Justinas Stankevicius\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.5712890625,
          "content": "# Alice \n\n[![GoDoc](https://godoc.org/github.com/golang/gddo?status.svg)](http://godoc.org/github.com/justinas/alice)\n[![Build Status](https://travis-ci.org/justinas/alice.svg?branch=master)](https://travis-ci.org/justinas/alice)\n[![Coverage](http://gocover.io/_badge/github.com/justinas/alice)](http://gocover.io/github.com/justinas/alice)\n\nAlice provides a convenient way to chain \nyour HTTP middleware functions and the app handler.\n\nIn short, it transforms\n\n```go\nMiddleware1(Middleware2(Middleware3(App)))\n```\n\nto\n\n```go\nalice.New(Middleware1, Middleware2, Middleware3).Then(App)\n```\n\n### Why?\n\nNone of the other middleware chaining solutions\nbehaves exactly like Alice.\nAlice is as minimal as it gets:\nin essence, it's just a for loop that does the wrapping for you.\n\nCheck out [this blog post](http://justinas.org/alice-painless-middleware-chaining-for-go/)\nfor explanation how Alice is different from other chaining solutions.\n\n### Usage\n\nYour middleware constructors should have the form of\n\n```go\nfunc (http.Handler) http.Handler\n```\n\nSome middleware provide this out of the box.\nFor ones that don't, it's trivial to write one yourself.\n\n```go\nfunc myStripPrefix(h http.Handler) http.Handler {\n    return http.StripPrefix(\"/old\", h)\n}\n```\n\nThis complete example shows the full power of Alice.\n\n```go\npackage main\n\nimport (\n    \"net/http\"\n    \"time\"\n\n    \"github.com/throttled/throttled\"\n    \"github.com/justinas/alice\"\n    \"github.com/justinas/nosurf\"\n)\n\nfunc timeoutHandler(h http.Handler) http.Handler {\n    return http.TimeoutHandler(h, 1*time.Second, \"timed out\")\n}\n\nfunc myApp(w http.ResponseWriter, r *http.Request) {\n    w.Write([]byte(\"Hello world!\"))\n}\n\nfunc main() {\n    th := throttled.Interval(throttled.PerSec(10), 1, &throttled.VaryBy{Path: true}, 50)\n    myHandler := http.HandlerFunc(myApp)\n\n    chain := alice.New(th.Throttle, timeoutHandler, nosurf.NewPure).Then(myHandler)\n    http.ListenAndServe(\":8000\", chain)\n}\n```\n\nHere, the request will pass [throttled](https://github.com/PuerkitoBio/throttled) first,\nthen an http.TimeoutHandler we've set up,\nthen [nosurf](https://github.com/justinas/nosurf)\nand will finally reach our handler.\n\nNote that Alice makes **no guarantees** for\nhow one or another piece of  middleware will behave.\nOnce it passes the execution to the outer layer of middleware,\nit has no saying in whether middleware will execute the inner handlers.\nThis is intentional behavior.\n\nAlice works with Go 1.0 and higher.\n\n### Contributing\n\n0. Find an issue that bugs you / open a new one.\n1. Discuss.\n2. Branch off, commit, test.\n3. Make a pull request / attach the commits to the issue.\n"
        },
        {
          "name": "chain.go",
          "type": "blob",
          "size": 3.802734375,
          "content": "// Package alice provides a convenient way to chain http handlers.\npackage alice\n\nimport \"net/http\"\n\n// A constructor for a piece of middleware.\n// Some middleware use this constructor out of the box,\n// so in most cases you can just pass somepackage.New\ntype Constructor func(http.Handler) http.Handler\n\n// Chain acts as a list of http.Handler constructors.\n// Chain is effectively immutable:\n// once created, it will always hold\n// the same set of constructors in the same order.\ntype Chain struct {\n\tconstructors []Constructor\n}\n\n// New creates a new chain,\n// memorizing the given list of middleware constructors.\n// New serves no other function,\n// constructors are only called upon a call to Then().\nfunc New(constructors ...Constructor) Chain {\n\treturn Chain{append(([]Constructor)(nil), constructors...)}\n}\n\n// Then chains the middleware and returns the final http.Handler.\n//\n//\tNew(m1, m2, m3).Then(h)\n//\n// is equivalent to:\n//\n//\tm1(m2(m3(h)))\n//\n// When the request comes in, it will be passed to m1, then m2, then m3\n// and finally, the given handler\n// (assuming every middleware calls the following one).\n//\n// A chain can be safely reused by calling Then() several times.\n//\n//\tstdStack := alice.New(ratelimitHandler, csrfHandler)\n//\tindexPipe = stdStack.Then(indexHandler)\n//\tauthPipe = stdStack.Then(authHandler)\n//\n// Note that constructors are called on every call to Then()\n// and thus several instances of the same middleware will be created\n// when a chain is reused in this way.\n// For proper middleware, this should cause no problems.\n//\n// Then() treats nil as http.DefaultServeMux.\nfunc (c Chain) Then(h http.Handler) http.Handler {\n\tif h == nil {\n\t\th = http.DefaultServeMux\n\t}\n\n\tfor i := range c.constructors {\n\t\th = c.constructors[len(c.constructors)-1-i](h)\n\t}\n\n\treturn h\n}\n\n// ThenFunc works identically to Then, but takes\n// a HandlerFunc instead of a Handler.\n//\n// The following two statements are equivalent:\n//\n//\tc.Then(http.HandlerFunc(fn))\n//\tc.ThenFunc(fn)\n//\n// ThenFunc provides all the guarantees of Then.\nfunc (c Chain) ThenFunc(fn http.HandlerFunc) http.Handler {\n\t// This nil check cannot be removed due to the \"nil is not nil\" common mistake in Go.\n\t// Required due to: https://stackoverflow.com/questions/33426977/how-to-golang-check-a-variable-is-nil\n\tif fn == nil {\n\t\treturn c.Then(nil)\n\t}\n\treturn c.Then(fn)\n}\n\n// Append extends a chain, adding the specified constructors\n// as the last ones in the request flow.\n//\n// Append returns a new chain, leaving the original one untouched.\n//\n//\tstdChain := alice.New(m1, m2)\n//\textChain := stdChain.Append(m3, m4)\n//\t// requests in stdChain go m1 -> m2\n//\t// requests in extChain go m1 -> m2 -> m3 -> m4\nfunc (c Chain) Append(constructors ...Constructor) Chain {\n\tnewCons := make([]Constructor, 0, len(c.constructors)+len(constructors))\n\tnewCons = append(newCons, c.constructors...)\n\tnewCons = append(newCons, constructors...)\n\n\treturn Chain{newCons}\n}\n\n// Extend extends a chain by adding the specified chain\n// as the last one in the request flow.\n//\n// Extend returns a new chain, leaving the original one untouched.\n//\n//\tstdChain := alice.New(m1, m2)\n//\text1Chain := alice.New(m3, m4)\n//\text2Chain := stdChain.Extend(ext1Chain)\n//\t// requests in stdChain go  m1 -> m2\n//\t// requests in ext1Chain go m3 -> m4\n//\t// requests in ext2Chain go m1 -> m2 -> m3 -> m4\n//\n// Another example:\n//\n//\taHtmlAfterNosurf := alice.New(m2)\n//\taHtml := alice.New(m1, func(h http.Handler) http.Handler {\n//\t\tcsrf := nosurf.New(h)\n//\t\tcsrf.SetFailureHandler(aHtmlAfterNosurf.ThenFunc(csrfFail))\n//\t\treturn csrf\n//\t}).Extend(aHtmlAfterNosurf)\n//\t// requests to aHtml hitting nosurfs success handler go m1 -> nosurf -> m2 -> target-handler\n//\t// requests to aHtml hitting nosurfs failure handler go m1 -> nosurf -> m2 -> csrfFail\nfunc (c Chain) Extend(chain Chain) Chain {\n\treturn c.Append(chain.constructors...)\n}\n"
        },
        {
          "name": "chain_test.go",
          "type": "blob",
          "size": 4.361328125,
          "content": "// Package alice implements a middleware chaining solution.\npackage alice\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n// A constructor for middleware\n// that writes its own \"tag\" into the RW and does nothing else.\n// Useful in checking if a chain is behaving in the right order.\nfunc tagMiddleware(tag string) Constructor {\n\treturn func(h http.Handler) http.Handler {\n\t\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t_, _ = w.Write([]byte(tag))\n\t\t\th.ServeHTTP(w, r)\n\t\t})\n\t}\n}\n\n// Not recommended (https://golang.org/pkg/reflect/#Value.Pointer),\n// but the best we can do.\nfunc funcsEqual(f1, f2 interface{}) bool {\n\tval1 := reflect.ValueOf(f1)\n\tval2 := reflect.ValueOf(f2)\n\treturn val1.Pointer() == val2.Pointer()\n}\n\nvar testApp = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t_, _ = w.Write([]byte(\"app\\n\"))\n})\n\nfunc TestNew(t *testing.T) {\n\tc1 := func(h http.Handler) http.Handler {\n\t\treturn nil\n\t}\n\n\tc2 := func(h http.Handler) http.Handler {\n\t\treturn http.StripPrefix(\"potato\", nil)\n\t}\n\n\tslice := []Constructor{c1, c2}\n\n\tchain := New(slice...)\n\tfor k := range slice {\n\t\tif !funcsEqual(chain.constructors[k], slice[k]) {\n\t\t\tt.Error(\"New does not add constructors correctly\")\n\t\t}\n\t}\n}\n\nfunc TestThenWorksWithNoMiddleware(t *testing.T) {\n\tif !funcsEqual(New().Then(testApp), testApp) {\n\t\tt.Error(\"Then does not work with no middleware\")\n\t}\n}\n\nfunc TestThenTreatsNilAsDefaultServeMux(t *testing.T) {\n\tif New().Then(nil) != http.DefaultServeMux {\n\t\tt.Error(\"Then does not treat nil as DefaultServeMux\")\n\t}\n}\n\nfunc TestThenFuncTreatsNilAsDefaultServeMux(t *testing.T) {\n\tif New().ThenFunc(nil) != http.DefaultServeMux {\n\t\tt.Error(\"ThenFunc does not treat nil as DefaultServeMux\")\n\t}\n}\n\nfunc TestThenFuncConstructsHandlerFunc(t *testing.T) {\n\tfn := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(200)\n\t})\n\tchained := New().ThenFunc(fn)\n\trec := httptest.NewRecorder()\n\n\tchained.ServeHTTP(rec, (*http.Request)(nil))\n\n\tif reflect.TypeOf(chained) != reflect.TypeOf((http.HandlerFunc)(nil)) {\n\t\tt.Error(\"ThenFunc does not construct HandlerFunc\")\n\t}\n}\n\nfunc TestThenOrdersHandlersCorrectly(t *testing.T) {\n\tt1 := tagMiddleware(\"t1\\n\")\n\tt2 := tagMiddleware(\"t2\\n\")\n\tt3 := tagMiddleware(\"t3\\n\")\n\n\tchained := New(t1, t2, t3).Then(testApp)\n\n\tw := httptest.NewRecorder()\n\tr, err := http.NewRequest(\"GET\", \"/\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tchained.ServeHTTP(w, r)\n\n\tif w.Body.String() != \"t1\\nt2\\nt3\\napp\\n\" {\n\t\tt.Error(\"Then does not order handlers correctly\")\n\t}\n}\n\nfunc TestAppendAddsHandlersCorrectly(t *testing.T) {\n\tchain := New(tagMiddleware(\"t1\\n\"), tagMiddleware(\"t2\\n\"))\n\tnewChain := chain.Append(tagMiddleware(\"t3\\n\"), tagMiddleware(\"t4\\n\"))\n\n\tif len(chain.constructors) != 2 {\n\t\tt.Error(\"chain should have 2 constructors\")\n\t}\n\tif len(newChain.constructors) != 4 {\n\t\tt.Error(\"newChain should have 4 constructors\")\n\t}\n\n\tchained := newChain.Then(testApp)\n\n\tw := httptest.NewRecorder()\n\tr, err := http.NewRequest(\"GET\", \"/\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tchained.ServeHTTP(w, r)\n\n\tif w.Body.String() != \"t1\\nt2\\nt3\\nt4\\napp\\n\" {\n\t\tt.Error(\"Append does not add handlers correctly\")\n\t}\n}\n\nfunc TestAppendRespectsImmutability(t *testing.T) {\n\tchain := New(tagMiddleware(\"\"))\n\tnewChain := chain.Append(tagMiddleware(\"\"))\n\n\tif &chain.constructors[0] == &newChain.constructors[0] {\n\t\tt.Error(\"Apppend does not respect immutability\")\n\t}\n}\n\nfunc TestExtendAddsHandlersCorrectly(t *testing.T) {\n\tchain1 := New(tagMiddleware(\"t1\\n\"), tagMiddleware(\"t2\\n\"))\n\tchain2 := New(tagMiddleware(\"t3\\n\"), tagMiddleware(\"t4\\n\"))\n\tnewChain := chain1.Extend(chain2)\n\n\tif len(chain1.constructors) != 2 {\n\t\tt.Error(\"chain1 should contain 2 constructors\")\n\t}\n\tif len(chain2.constructors) != 2 {\n\t\tt.Error(\"chain2 should contain 2 constructors\")\n\t}\n\tif len(newChain.constructors) != 4 {\n\t\tt.Error(\"newChain should contain 4 constructors\")\n\t}\n\n\tchained := newChain.Then(testApp)\n\n\tw := httptest.NewRecorder()\n\tr, err := http.NewRequest(\"GET\", \"/\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tchained.ServeHTTP(w, r)\n\n\tif w.Body.String() != \"t1\\nt2\\nt3\\nt4\\napp\\n\" {\n\t\tt.Error(\"Extend does not add handlers in correctly\")\n\t}\n}\n\nfunc TestExtendRespectsImmutability(t *testing.T) {\n\tchain := New(tagMiddleware(\"\"))\n\tnewChain := chain.Extend(New(tagMiddleware(\"\")))\n\n\tif &chain.constructors[0] == &newChain.constructors[0] {\n\t\tt.Error(\"Extend does not respect immutability\")\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.041015625,
          "content": "module github.com/justinas/alice\n\ngo 1.12\n"
        }
      ]
    }
  ]
}