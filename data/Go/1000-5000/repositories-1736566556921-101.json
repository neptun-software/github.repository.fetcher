{
  "metadata": {
    "timestamp": 1736566556921,
    "page": 101,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjExMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "mailru/easyjson",
      "stars": 4563,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.04296875,
          "content": ".root\n*_easyjson.go\n*.iml\n.idea\n*.swp\nbin/*\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0322265625,
          "content": "Copyright (c) 2016 Mail.Ru Group\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.7470703125,
          "content": "all: test\n\nclean:\n\trm -rf bin\n\trm -rf tests/*_easyjson.go\n\trm -rf benchmark/*_easyjson.go\n\nbuild:\n\tgo build -o ./bin/easyjson ./easyjson\n\ngenerate: build\n\tbin/easyjson -stubs \\\n\t\t./tests/snake.go \\\n\t\t./tests/data.go \\\n\t\t./tests/omitempty.go \\\n\t\t./tests/nothing.go \\\n\t\t./tests/named_type.go \\\n\t\t./tests/custom_map_key_type.go \\\n\t\t./tests/embedded_type.go \\\n\t\t./tests/reference_to_pointer.go \\\n\t\t./tests/html.go \\\n\t\t./tests/unknown_fields.go \\\n\t\t./tests/type_declaration.go \\\n\t\t./tests/type_declaration_skip.go \\\n\t\t./tests/members_escaped.go \\\n\t\t./tests/members_unescaped.go \\\n\t\t./tests/intern.go \\\n\t\t./tests/nocopy.go \\\n\t\t./tests/escaping.go\n\tbin/easyjson -all \\\n\t\t./tests/data.go \\\n \t\t./tests/nothing.go \\\n \t\t./tests/errors.go \\\n \t\t./tests/html.go \\\n \t\t./tests/type_declaration_skip.go\n\tbin/easyjson \\\n\t\t./tests/nested_easy.go \\\n\t\t./tests/named_type.go \\\n\t\t./tests/custom_map_key_type.go \\\n\t\t./tests/embedded_type.go \\\n\t\t./tests/reference_to_pointer.go \\\n\t\t./tests/key_marshaler_map.go \\\n\t\t./tests/unknown_fields.go \\\n\t\t./tests/type_declaration.go \\\n\t\t./tests/members_escaped.go \\\n\t\t./tests/intern.go \\\n\t\t./tests/nocopy.go \\\n\t\t./tests/escaping.go \\\n\t\t./tests/nested_marshaler.go\n\tbin/easyjson -snake_case ./tests/snake.go\n\tbin/easyjson -omit_empty ./tests/omitempty.go\n\tbin/easyjson -build_tags=use_easyjson -disable_members_unescape ./benchmark/data.go\n\tbin/easyjson -disallow_unknown_fields ./tests/disallow_unknown.go\n\tbin/easyjson -disable_members_unescape ./tests/members_unescaped.go\n\ntest: generate\n\tgo test \\\n\t\t./tests \\\n\t\t./jlexer \\\n\t\t./gen \\\n\t\t./buffer\n\tcd benchmark && go test -benchmem -tags use_easyjson -bench .\n\tgolint -set_exit_status ./tests/*_easyjson.go\n\nbench-other: generate\n\tcd benchmark && make\n\nbench-python:\n\tbenchmark/ujson.sh\n\n\n.PHONY: clean generate test build\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.01953125,
          "content": "# easyjson [![Build Status](https://github.com/mailru/easyjson/actions/workflows/easyjson.yml/badge.svg)](https://github.com/mailru/easyjson/actions/workflows/easyjson.yml) [![Go Report Card](https://goreportcard.com/badge/github.com/mailru/easyjson)](https://goreportcard.com/report/github.com/mailru/easyjson)\n\nPackage easyjson provides a fast and easy way to marshal/unmarshal Go structs\nto/from JSON without the use of reflection. In performance tests, easyjson\noutperforms the standard `encoding/json` package by a factor of 4-5x, and other\nJSON encoding packages by a factor of 2-3x.\n\neasyjson aims to keep generated Go code simple enough so that it can be easily\noptimized or fixed. Another goal is to provide users with the ability to\ncustomize the generated code by providing options not available with the\nstandard `encoding/json` package, such as generating \"snake_case\" names or\nenabling `omitempty` behavior by default.\n\n## Usage\n### Install: \n```sh\n# for Go < 1.17\ngo get -u github.com/mailru/easyjson/...\n```\n#### or\n```sh\n# for Go >= 1.17\ngo get github.com/mailru/easyjson && go install github.com/mailru/easyjson/...@latest\n```\n### Run:\n```sh\neasyjson -all <file>.go\n```\n\nThe above will generate `<file>_easyjson.go` containing the appropriate marshaler and\nunmarshaler funcs for all structs contained in `<file>.go`.\n\nPlease note that easyjson requires a full Go build environment and the `GOPATH`\nenvironment variable to be set. This is because easyjson code generation\ninvokes `go run` on a temporary file (an approach to code generation borrowed\nfrom [ffjson](https://github.com/pquerna/ffjson)).\n\n### Serialize\n```go\nsomeStruct := &SomeStruct{Field1: \"val1\", Field2: \"val2\"}\nrawBytes, err := easyjson.Marshal(someStruct)\n```\n\n### Deserialize\n```go\nsomeStruct := &SomeStruct{}\nerr := easyjson.Unmarshal(rawBytes, someStruct)\n```\n\nPlease see the [GoDoc](https://godoc.org/github.com/mailru/easyjson)\nfor more information and features.\n## Options\n```txt\nUsage of easyjson:\n  -all\n    \tgenerate marshaler/unmarshalers for all structs in a file\n  -build_tags string\n        build tags to add to generated file\n  -gen_build_flags string\n        build flags when running the generator while bootstrapping\n  -byte\n        use simple bytes instead of Base64Bytes for slice of bytes\n  -leave_temps\n    \tdo not delete temporary files\n  -no_std_marshalers\n    \tdon't generate MarshalJSON/UnmarshalJSON funcs\n  -noformat\n    \tdo not run 'gofmt -w' on output file\n  -omit_empty\n    \tomit empty fields by default\n  -output_filename string\n    \tspecify the filename of the output\n  -pkg\n    \tprocess the whole package instead of just the given file\n  -snake_case\n    \tuse snake_case names instead of CamelCase by default\n  -lower_camel_case\n        use lowerCamelCase instead of CamelCase by default\n  -stubs\n    \tonly generate stubs for marshaler/unmarshaler funcs\n  -disallow_unknown_fields\n        return error if some unknown field in json appeared\n  -disable_members_unescape\n        disable unescaping of \\uXXXX string sequences in member names\n```\n\nUsing `-all` will generate marshalers/unmarshalers for all Go structs in the\nfile excluding those structs whose preceding comment starts with `easyjson:skip`.\nFor example: \n\n```go\n//easyjson:skip\ntype A struct {}\n```\n\nIf `-all` is not provided, then only those structs whose preceding\ncomment starts with `easyjson:json` will have marshalers/unmarshalers\ngenerated. For example:\n\n```go\n//easyjson:json\ntype A struct {}\n```\n\nAdditional option notes:\n\n* `-snake_case` tells easyjson to generate snake\\_case field names by default\n  (unless overridden by a field tag). The CamelCase to snake\\_case conversion\n  algorithm should work in most cases (ie, HTTPVersion will be converted to\n  \"http_version\").\n\n* `-build_tags` will add the specified build tags to generated Go sources.\n\n* `-gen_build_flags` will execute the easyjson bootstapping code to launch the \n  actual generator command with provided flags. Multiple arguments should be\n  separated by space e.g. `-gen_build_flags=\"-mod=mod -x\"`.\n\n## Structure json tag options\n\nBesides standard json tag options like 'omitempty' the following are supported:\n\n* 'nocopy' - disables allocation and copying of string values, making them\n  refer to original json buffer memory. This works great for short lived\n  objects which are not hold in memory after decoding and immediate usage.\n  Note if string requires unescaping it will be processed as normally.\n* 'intern' - string \"interning\" (deduplication) to save memory when the very\n  same string dictionary values are often met all over the structure.\n  See below for more details.\n\n## Generated Marshaler/Unmarshaler Funcs\n\nFor Go struct types, easyjson generates the funcs `MarshalEasyJSON` /\n`UnmarshalEasyJSON` for marshaling/unmarshaling JSON. In turn, these satisfy\nthe `easyjson.Marshaler` and `easyjson.Unmarshaler` interfaces and when used in\nconjunction with `easyjson.Marshal` / `easyjson.Unmarshal` avoid unnecessary\nreflection / type assertions during marshaling/unmarshaling to/from JSON for Go\nstructs.\n\neasyjson also generates `MarshalJSON` and `UnmarshalJSON` funcs for Go struct\ntypes compatible with the standard `json.Marshaler` and `json.Unmarshaler`\ninterfaces. Please be aware that using the standard `json.Marshal` /\n`json.Unmarshal` for marshaling/unmarshaling will incur a significant\nperformance penalty when compared to using `easyjson.Marshal` /\n`easyjson.Unmarshal`.\n\nAdditionally, easyjson exposes utility funcs that use the `MarshalEasyJSON` and\n`UnmarshalEasyJSON` for marshaling/unmarshaling to and from standard readers\nand writers. For example, easyjson provides `easyjson.MarshalToHTTPResponseWriter`\nwhich marshals to the standard `http.ResponseWriter`. Please see the [GoDoc\nlisting](https://godoc.org/github.com/mailru/easyjson) for the full listing of\nutility funcs that are available.\n\n## Controlling easyjson Marshaling and Unmarshaling Behavior\n\nGo types can provide their own `MarshalEasyJSON` and `UnmarshalEasyJSON` funcs\nthat satisfy the `easyjson.Marshaler` / `easyjson.Unmarshaler` interfaces.\nThese will be used by `easyjson.Marshal` and `easyjson.Unmarshal` when defined\nfor a Go type.\n\nGo types can also satisfy the `easyjson.Optional` interface, which allows the\ntype to define its own `omitempty` logic.\n\n## Type Wrappers\n\neasyjson provides additional type wrappers defined in the `easyjson/opt`\npackage. These wrap the standard Go primitives and in turn satisfy the\neasyjson interfaces.\n\nThe `easyjson/opt` type wrappers are useful when needing to distinguish between\na missing value and/or when needing to specifying a default value. Type\nwrappers allow easyjson to avoid additional pointers and heap allocations and\ncan significantly increase performance when used properly.\n\n## Memory Pooling\n\neasyjson uses a buffer pool that allocates data in increasing chunks from 128\nto 32768 bytes. Chunks of 512 bytes and larger will be reused with the help of\n`sync.Pool`. The maximum size of a chunk is bounded to reduce redundant memory\nallocation and to allow larger reusable buffers.\n\neasyjson's custom allocation buffer pool is defined in the `easyjson/buffer`\npackage, and the default behavior pool behavior can be modified (if necessary)\nthrough a call to `buffer.Init()` prior to any marshaling or unmarshaling.\nPlease see the [GoDoc listing](https://godoc.org/github.com/mailru/easyjson/buffer)\nfor more information.\n\n## String interning\n\nDuring unmarshaling, `string` field values can be optionally\n[interned](https://en.wikipedia.org/wiki/String_interning) to reduce memory\nallocations and usage by deduplicating strings in memory, at the expense of slightly\nincreased CPU usage.\n\nThis will work effectively only for `string` fields being decoded that have frequently\nthe same value (e.g. if you have a string field that can only assume a small number\nof possible values).\n\nTo enable string interning, add the `intern` keyword tag to your `json` tag on `string`\nfields, e.g.:\n\n```go\ntype Foo struct {\n  UUID  string `json:\"uuid\"`         // will not be interned during unmarshaling\n  State string `json:\"state,intern\"` // will be interned during unmarshaling\n}\n```\n\n## Issues, Notes, and Limitations\n\n* easyjson is still early in its development. As such, there are likely to be\n  bugs and missing features when compared to `encoding/json`. In the case of a\n  missing feature or bug, please create a GitHub issue. Pull requests are\n  welcome!\n\n* Unlike `encoding/json`, object keys are case-sensitive. Case-insensitive\n  matching is not currently provided due to the significant performance hit\n  when doing case-insensitive key matching. In the future, case-insensitive\n  object key matching may be provided via an option to the generator.\n\n* easyjson makes use of `unsafe`, which simplifies the code and\n  provides significant performance benefits by allowing no-copy\n  conversion from `[]byte` to `string`. That said, `unsafe` is used\n  only when unmarshaling and parsing JSON, and any `unsafe` operations\n  / memory allocations done will be safely deallocated by\n  easyjson. Set the build tag `easyjson_nounsafe` to compile it\n  without `unsafe`.\n\n* easyjson is compatible with Google App Engine. The `appengine` build\n  tag (set by App Engine's environment) will automatically disable the\n  use of `unsafe`, which is not allowed in App Engine's Standard\n  Environment. Note that the use with App Engine is still experimental.\n\n* Floats are formatted using the default precision from Go's `strconv` package.\n  As such, easyjson will not correctly handle high precision floats when\n  marshaling/unmarshaling JSON. Note, however, that there are very few/limited\n  uses where this behavior is not sufficient for general use. That said, a\n  different package may be needed if precise marshaling/unmarshaling of high\n  precision floats to/from JSON is required.\n\n* While unmarshaling, the JSON parser does the minimal amount of work needed to\n  skip over unmatching parens, and as such full validation is not done for the\n  entire JSON value being unmarshaled/parsed.\n\n* Currently there is no true streaming support for encoding/decoding as\n  typically for many uses/protocols the final, marshaled length of the JSON\n  needs to be known prior to sending the data. Currently this is not possible\n  with easyjson's architecture.\n  \n* easyjson parser and codegen based on reflection, so it won't work on `package main` \n  files, because they cant be imported by parser.\n\n## Benchmarks\n\nMost benchmarks were done using the example\n[13kB example JSON](https://dev.twitter.com/rest/reference/get/search/tweets)\n(9k after eliminating whitespace). This example is similar to real-world data,\nis well-structured, and contains a healthy variety of different types, making\nit ideal for JSON serialization benchmarks.\n\nNote:\n\n* For small request benchmarks, an 80 byte portion of the above example was\n  used.\n\n* For large request marshaling benchmarks, a struct containing 50 regular\n  samples was used, making a ~500kB output JSON.\n\n* Benchmarks are showing the results of easyjson's default behaviour,\n  which makes use of `unsafe`.\n\nBenchmarks are available in the repository and can be run by invoking `make`.\n\n### easyjson vs. encoding/json\n\neasyjson is roughly 5-6 times faster than the standard `encoding/json` for\nunmarshaling, and 3-4 times faster for non-concurrent marshaling. Concurrent\nmarshaling is 6-7x faster if marshaling to a writer.\n\n### easyjson vs. ffjson\n\neasyjson uses the same approach for JSON marshaling as\n[ffjson](https://github.com/pquerna/ffjson), but takes a significantly\ndifferent approach to lexing and parsing JSON during unmarshaling. This means\neasyjson is roughly 2-3x faster for unmarshaling and 1.5-2x faster for\nnon-concurrent unmarshaling.\n\nAs of this writing, `ffjson` seems to have issues when used concurrently:\nspecifically, large request pooling hurts `ffjson`'s performance and causes\nscalability issues. These issues with `ffjson` can likely be fixed, but as of\nwriting remain outstanding/known issues with `ffjson`.\n\neasyjson and `ffjson` have similar performance for small requests, however\neasyjson outperforms `ffjson` by roughly 2-5x times for large requests when\nused with a writer.\n\n### easyjson vs. go/codec\n\n[go/codec](https://github.com/ugorji/go) provides\ncompile-time helpers for JSON generation. In this case, helpers do not work\nlike marshalers as they are encoding-independent.\n\neasyjson is generally 2x faster than `go/codec` for non-concurrent benchmarks\nand about 3x faster for concurrent encoding (without marshaling to a writer).\n\nIn an attempt to measure marshaling performance of `go/codec` (as opposed to\nallocations/memcpy/writer interface invocations), a benchmark was done with\nresetting length of a byte slice rather than resetting the whole slice to nil.\nHowever, the optimization in this exact form may not be applicable in practice,\nsince the memory is not freed between marshaling operations.\n\n### easyjson vs 'ujson' python module\n\n[ujson](https://github.com/esnme/ultrajson) is using C code for parsing, so it\nis interesting to see how plain golang compares to that. It is important to note\nthat the resulting object for python is slower to access, since the library\nparses JSON object into dictionaries.\n\neasyjson is slightly faster for unmarshaling and 2-3x faster than `ujson` for\nmarshaling.\n\n### Benchmark Results\n\n`ffjson` results are from February 4th, 2016, using the latest `ffjson` and go1.6.\n`go/codec` results are from March 4th, 2016, using the latest `go/codec` and go1.6.\n\n#### Unmarshaling\n\n| lib      | json size | MB/s | allocs/op | B/op  |\n|:---------|:----------|-----:|----------:|------:|\n| standard | regular   | 22   | 218       | 10229 |\n| standard | small     | 9.7  | 14        | 720   |\n|          |           |      |           |       |\n| easyjson | regular   | 125  | 128       | 9794  |\n| easyjson | small     | 67   | 3         | 128   |\n|          |           |      |           |       |\n| ffjson   | regular   | 66   | 141       | 9985  |\n| ffjson   | small     | 17.6 | 10        | 488   |\n|          |           |      |           |       |\n| codec    | regular   | 55   | 434       | 19299 |\n| codec    | small     | 29   | 7         | 336   |\n|          |           |      |           |       |\n| ujson    | regular   | 103  | N/A       | N/A   |\n\n#### Marshaling, one goroutine.\n\n| lib       | json size | MB/s | allocs/op | B/op  |\n|:----------|:----------|-----:|----------:|------:|\n| standard  | regular   | 75   | 9         | 23256 |\n| standard  | small     | 32   | 3         | 328   |\n| standard  | large     | 80   | 17        | 1.2M  |\n|           |           |      |           |       |\n| easyjson  | regular   | 213  | 9         | 10260 |\n| easyjson* | regular   | 263  | 8         | 742   |\n| easyjson  | small     | 125  | 1         | 128   |\n| easyjson  | large     | 212  | 33        | 490k  |\n| easyjson* | large     | 262  | 25        | 2879  |\n|           |           |      |           |       |\n| ffjson    | regular   | 122  | 153       | 21340 |\n| ffjson**  | regular   | 146  | 152       | 4897  |\n| ffjson    | small     | 36   | 5         | 384   |\n| ffjson**  | small     | 64   | 4         | 128   |\n| ffjson    | large     | 134  | 7317      | 818k  |\n| ffjson**  | large     | 125  | 7320      | 827k  |\n|           |           |      |           |       |\n| codec     | regular   | 80   | 17        | 33601 |\n| codec***  | regular   | 108  | 9         | 1153  |\n| codec     | small     | 42   | 3         | 304   |\n| codec***  | small     | 56   | 1         | 48    |\n| codec     | large     | 73   | 483       | 2.5M  |\n| codec***  | large     | 103  | 451       | 66007 |\n|           |           |      |           |       |\n| ujson     | regular   | 92   | N/A       | N/A   |\n\n\\* marshaling to a writer,\n\\*\\* using `ffjson.Pool()`,\n\\*\\*\\* reusing output slice instead of resetting it to nil\n\n#### Marshaling, concurrent.\n\n| lib       | json size | MB/s | allocs/op | B/op  |\n|:----------|:----------|-----:|----------:|------:|\n| standard  | regular   | 252  | 9         | 23257 |\n| standard  | small     | 124  | 3         | 328   |\n| standard  | large     | 289  | 17        | 1.2M  |\n|           |           |      |           |       |\n| easyjson  | regular   | 792  | 9         | 10597 |\n| easyjson* | regular   | 1748 | 8         | 779   |\n| easyjson  | small     | 333  | 1         | 128   |\n| easyjson  | large     | 718  | 36        | 548k  |\n| easyjson* | large     | 2134 | 25        | 4957  |\n|           |           |      |           |       |\n| ffjson    | regular   | 301  | 153       | 21629 |\n| ffjson**  | regular   | 707  | 152       | 5148  |\n| ffjson    | small     | 62   | 5         | 384   |\n| ffjson**  | small     | 282  | 4         | 128   |\n| ffjson    | large     | 438  | 7330      | 1.0M  |\n| ffjson**  | large     | 131  | 7319      | 820k  |\n|           |           |      |           |       |\n| codec     | regular   | 183  | 17        | 33603 |\n| codec***  | regular   | 671  | 9         | 1157  |\n| codec     | small     | 147  | 3         | 304   |\n| codec***  | small     | 299  | 1         | 48    |\n| codec     | large     | 190  | 483       | 2.5M  |\n| codec***  | large     | 752  | 451       | 77574 |\n\n\\* marshaling to a writer,\n\\*\\* using `ffjson.Pool()`,\n\\*\\*\\* reusing output slice instead of resetting it to nil\n"
        },
        {
          "name": "benchmark",
          "type": "tree",
          "content": null
        },
        {
          "name": "bootstrap",
          "type": "tree",
          "content": null
        },
        {
          "name": "buffer",
          "type": "tree",
          "content": null
        },
        {
          "name": "easyjson",
          "type": "tree",
          "content": null
        },
        {
          "name": "gen",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0849609375,
          "content": "module github.com/mailru/easyjson\n\ngo 1.20\n\nrequire github.com/josharian/intern v1.0.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.1689453125,
          "content": "github.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 3.087890625,
          "content": "// Package easyjson contains marshaler/unmarshaler interfaces and helper functions.\npackage easyjson\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"unsafe\"\n\n\t\"github.com/mailru/easyjson/jlexer\"\n\t\"github.com/mailru/easyjson/jwriter\"\n)\n\n// Marshaler is an easyjson-compatible marshaler interface.\ntype Marshaler interface {\n\tMarshalEasyJSON(w *jwriter.Writer)\n}\n\n// Unmarshaler is an easyjson-compatible unmarshaler interface.\ntype Unmarshaler interface {\n\tUnmarshalEasyJSON(w *jlexer.Lexer)\n}\n\n// MarshalerUnmarshaler is an easyjson-compatible marshaler/unmarshaler interface.\ntype MarshalerUnmarshaler interface {\n\tMarshaler\n\tUnmarshaler\n}\n\n// Optional defines an undefined-test method for a type to integrate with 'omitempty' logic.\ntype Optional interface {\n\tIsDefined() bool\n}\n\n// UnknownsUnmarshaler provides a method to unmarshal unknown struct fileds and save them as you want\ntype UnknownsUnmarshaler interface {\n\tUnmarshalUnknown(in *jlexer.Lexer, key string)\n}\n\n// UnknownsMarshaler provides a method to write additional struct fields\ntype UnknownsMarshaler interface {\n\tMarshalUnknowns(w *jwriter.Writer, first bool)\n}\n\nfunc isNilInterface(i interface{}) bool {\n\treturn (*[2]uintptr)(unsafe.Pointer(&i))[1] == 0\n}\n\n// Marshal returns data as a single byte slice. Method is suboptimal as the data is likely to be copied\n// from a chain of smaller chunks.\nfunc Marshal(v Marshaler) ([]byte, error) {\n\tif isNilInterface(v) {\n\t\treturn nullBytes, nil\n\t}\n\n\tw := jwriter.Writer{}\n\tv.MarshalEasyJSON(&w)\n\treturn w.BuildBytes()\n}\n\n// MarshalToWriter marshals the data to an io.Writer.\nfunc MarshalToWriter(v Marshaler, w io.Writer) (written int, err error) {\n\tif isNilInterface(v) {\n\t\treturn w.Write(nullBytes)\n\t}\n\n\tjw := jwriter.Writer{}\n\tv.MarshalEasyJSON(&jw)\n\treturn jw.DumpTo(w)\n}\n\n// MarshalToHTTPResponseWriter sets Content-Length and Content-Type headers for the\n// http.ResponseWriter, and send the data to the writer. started will be equal to\n// false if an error occurred before any http.ResponseWriter methods were actually\n// invoked (in this case a 500 reply is possible).\nfunc MarshalToHTTPResponseWriter(v Marshaler, w http.ResponseWriter) (started bool, written int, err error) {\n\tif isNilInterface(v) {\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Header().Set(\"Content-Length\", strconv.Itoa(len(nullBytes)))\n\t\twritten, err = w.Write(nullBytes)\n\t\treturn true, written, err\n\t}\n\n\tjw := jwriter.Writer{}\n\tv.MarshalEasyJSON(&jw)\n\tif jw.Error != nil {\n\t\treturn false, 0, jw.Error\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tw.Header().Set(\"Content-Length\", strconv.Itoa(jw.Size()))\n\n\tstarted = true\n\twritten, err = jw.DumpTo(w)\n\treturn\n}\n\n// Unmarshal decodes the JSON in data into the object.\nfunc Unmarshal(data []byte, v Unmarshaler) error {\n\tl := jlexer.Lexer{Data: data}\n\tv.UnmarshalEasyJSON(&l)\n\treturn l.Error()\n}\n\n// UnmarshalFromReader reads all the data in the reader and decodes as JSON into the object.\nfunc UnmarshalFromReader(r io.Reader, v Unmarshaler) error {\n\tdata, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn err\n\t}\n\tl := jlexer.Lexer{Data: data}\n\tv.UnmarshalEasyJSON(&l)\n\treturn l.Error()\n}\n"
        },
        {
          "name": "helpers_test.go",
          "type": "blob",
          "size": 0.181640625,
          "content": "package easyjson\n\nimport \"testing\"\n\nfunc BenchmarkNilCheck(b *testing.B) {\n\tvar a *int\n\tfor i := 0; i < b.N; i++ {\n\t\tif !isNilInterface(a) {\n\t\t\tb.Fatal(\"expected it to be nil\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "jlexer",
          "type": "tree",
          "content": null
        },
        {
          "name": "jwriter",
          "type": "tree",
          "content": null
        },
        {
          "name": "opt",
          "type": "tree",
          "content": null
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "raw.go",
          "type": "blob",
          "size": 1.13671875,
          "content": "package easyjson\n\nimport (\n\t\"github.com/mailru/easyjson/jlexer\"\n\t\"github.com/mailru/easyjson/jwriter\"\n)\n\n// RawMessage is a raw piece of JSON (number, string, bool, object, array or\n// null) that is extracted without parsing and output as is during marshaling.\ntype RawMessage []byte\n\n// MarshalEasyJSON does JSON marshaling using easyjson interface.\nfunc (v *RawMessage) MarshalEasyJSON(w *jwriter.Writer) {\n\tif len(*v) == 0 {\n\t\tw.RawString(\"null\")\n\t} else {\n\t\tw.Raw(*v, nil)\n\t}\n}\n\n// UnmarshalEasyJSON does JSON unmarshaling using easyjson interface.\nfunc (v *RawMessage) UnmarshalEasyJSON(l *jlexer.Lexer) {\n\t*v = RawMessage(l.Raw())\n}\n\n// UnmarshalJSON implements encoding/json.Unmarshaler interface.\nfunc (v *RawMessage) UnmarshalJSON(data []byte) error {\n\t*v = make([]byte, len(data))\n\tcopy(*v, data)\n\treturn nil\n}\n\nvar nullBytes = []byte(\"null\")\n\n// MarshalJSON implements encoding/json.Marshaler interface.\nfunc (v RawMessage) MarshalJSON() ([]byte, error) {\n\tif len(v) == 0 {\n\t\treturn nullBytes, nil\n\t}\n\treturn v, nil\n}\n\n// IsDefined is required for integration with omitempty easyjson logic.\nfunc (v *RawMessage) IsDefined() bool {\n\treturn len(*v) > 0\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "unknown_fields.go",
          "type": "blob",
          "size": 0.7802734375,
          "content": "package easyjson\n\nimport (\n\tjlexer \"github.com/mailru/easyjson/jlexer\"\n\t\"github.com/mailru/easyjson/jwriter\"\n)\n\n// UnknownFieldsProxy implemets UnknownsUnmarshaler and UnknownsMarshaler\n// use it as embedded field in your structure to parse and then serialize unknown struct fields\ntype UnknownFieldsProxy struct {\n\tunknownFields map[string][]byte\n}\n\nfunc (s *UnknownFieldsProxy) UnmarshalUnknown(in *jlexer.Lexer, key string) {\n\tif s.unknownFields == nil {\n\t\ts.unknownFields = make(map[string][]byte, 1)\n\t}\n\ts.unknownFields[key] = in.Raw()\n}\n\nfunc (s UnknownFieldsProxy) MarshalUnknowns(out *jwriter.Writer, first bool) {\n\tfor key, val := range s.unknownFields {\n\t\tif first {\n\t\t\tfirst = false\n\t\t} else {\n\t\t\tout.RawByte(',')\n\t\t}\n\t\tout.String(string(key))\n\t\tout.RawByte(':')\n\t\tout.Raw(val, nil)\n\t}\n}\n"
        }
      ]
    }
  ]
}