{
  "metadata": {
    "timestamp": 1736567098257,
    "page": 690,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jordan-wright/email",
      "stars": 2682,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.259765625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n# IDEs\n.idea\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0439453125,
          "content": "language: go\nsudo: false\ngo:\n  - 1.x\n  - tip\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013 Jordan Wright\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.8798828125,
          "content": "email\n=====\n\n[![Build Status](https://travis-ci.org/jordan-wright/email.png?branch=master)](https://travis-ci.org/jordan-wright/email) [![GoDoc](https://godoc.org/github.com/jordan-wright/email?status.svg)](https://godoc.org/github.com/jordan-wright/email)\n\nRobust and flexible email library for Go\n\n### Email for humans\nThe ```email``` package is designed to be simple to use, but flexible enough so as not to be restrictive. The goal is to provide an *email interface for humans*.\n\nThe ```email``` package currently supports the following:\n*  From, To, Bcc, and Cc fields\n*  Email addresses in both \"test@example.com\" and \"First Last &lt;test@example.com&gt;\" format\n*  Text and HTML Message Body\n*  Attachments\n*  Read Receipts\n*  Custom headers\n*  More to come!\n\n### Installation\n```go get github.com/jordan-wright/email```\n\n*Note: Version > 1 of this library requires Go v1.5 or above.*\n\n*If you need compatibility with previous Go versions, you can use the previous package at gopkg.in/jordan-wright/email.v1*\n\n### Examples\n#### Sending email using Gmail\n```go\ne := email.NewEmail()\ne.From = \"Jordan Wright <test@gmail.com>\"\ne.To = []string{\"test@example.com\"}\ne.Bcc = []string{\"test_bcc@example.com\"}\ne.Cc = []string{\"test_cc@example.com\"}\ne.Subject = \"Awesome Subject\"\ne.Text = []byte(\"Text Body is, of course, supported!\")\ne.HTML = []byte(\"<h1>Fancy HTML is supported, too!</h1>\")\ne.Send(\"smtp.gmail.com:587\", smtp.PlainAuth(\"\", \"test@gmail.com\", \"password123\", \"smtp.gmail.com\"))\n```\n\n#### Another Method for Creating an Email\nYou can also create an email directly by creating a struct as follows:\n```go\ne := &email.Email {\n\tTo: []string{\"test@example.com\"},\n\tFrom: \"Jordan Wright <test@gmail.com>\",\n\tSubject: \"Awesome Subject\",\n\tText: []byte(\"Text Body is, of course, supported!\"),\n\tHTML: []byte(\"<h1>Fancy HTML is supported, too!</h1>\"),\n\tHeaders: textproto.MIMEHeader{},\n}\n```\n\n#### Creating an Email From an io.Reader\nYou can also create an email from any type that implements the ```io.Reader``` interface by using ```email.NewEmailFromReader```.\n\n#### Attaching a File\n```go\ne := NewEmail()\ne.AttachFile(\"test.txt\")\n```\n\n#### A Pool of Reusable Connections\n```go\n(var ch <-chan *email.Email)\np := email.NewPool(\n\t\"smtp.gmail.com:587\",\n\t4,\n\tsmtp.PlainAuth(\"\", \"test@gmail.com\", \"password123\", \"smtp.gmail.com\"),\n)\nfor i := 0; i < 4; i++ {\n\tgo func() {\n\t\tfor e := range ch {\n\t\t\tp.Send(e, 10 * time.Second)\n\t\t}\n\t}()\n}\n```\n\n### Documentation\n[http://godoc.org/github.com/jordan-wright/email](http://godoc.org/github.com/jordan-wright/email)\n\n### Other Sources\nSections inspired by the handy [gophermail](https://github.com/jpoehls/gophermail) project.\n\n### Contributors\nI'd like to thank all the [contributors and maintainers](https://github.com/jordan-wright/email/graphs/contributors) of this package.\n\nA special thanks goes out to Jed Denlea [jeddenlea](https://github.com/jeddenlea) for his numerous contributions and optimizations.\n"
        },
        {
          "name": "email.go",
          "type": "blob",
          "size": 22.0087890625,
          "content": "// Package email is designed to provide an \"email interface for humans.\"\n// Designed to be robust and flexible, the email package aims to make sending email easy without getting in the way.\npackage email\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"math/big\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"mime/quotedprintable\"\n\t\"net/mail\"\n\t\"net/smtp\"\n\t\"net/textproto\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode\"\n)\n\nconst (\n\tMaxLineLength      = 76                             // MaxLineLength is the maximum line length per RFC 2045\n\tdefaultContentType = \"text/plain; charset=us-ascii\" // defaultContentType is the default Content-Type according to RFC 2045, section 5.2\n)\n\n// ErrMissingBoundary is returned when there is no boundary given for a multipart entity\nvar ErrMissingBoundary = errors.New(\"No boundary found for multipart entity\")\n\n// ErrMissingContentType is returned when there is no \"Content-Type\" header for a MIME entity\nvar ErrMissingContentType = errors.New(\"No Content-Type found for MIME entity\")\n\n// Email is the type used for email messages\ntype Email struct {\n\tReplyTo     []string\n\tFrom        string\n\tTo          []string\n\tBcc         []string\n\tCc          []string\n\tSubject     string\n\tText        []byte // Plaintext message (optional)\n\tHTML        []byte // Html message (optional)\n\tSender      string // override From as SMTP envelope sender (optional)\n\tHeaders     textproto.MIMEHeader\n\tAttachments []*Attachment\n\tReadReceipt []string\n}\n\n// part is a copyable representation of a multipart.Part\ntype part struct {\n\theader textproto.MIMEHeader\n\tbody   []byte\n}\n\n// NewEmail creates an Email, and returns the pointer to it.\nfunc NewEmail() *Email {\n\treturn &Email{Headers: textproto.MIMEHeader{}}\n}\n\n// trimReader is a custom io.Reader that will trim any leading\n// whitespace, as this can cause email imports to fail.\ntype trimReader struct {\n\trd      io.Reader\n\ttrimmed bool\n}\n\n// Read trims off any unicode whitespace from the originating reader\nfunc (tr *trimReader) Read(buf []byte) (int, error) {\n\tn, err := tr.rd.Read(buf)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\tif !tr.trimmed {\n\t\tt := bytes.TrimLeftFunc(buf[:n], unicode.IsSpace)\n\t\ttr.trimmed = true\n\t\tn = copy(buf, t)\n\t}\n\treturn n, err\n}\n\nfunc handleAddressList(v []string) []string {\n\tres := []string{}\n\tfor _, a := range v {\n\t\tw := strings.Split(a, \",\")\n\t\tfor _, addr := range w {\n\t\t\tdecodedAddr, err := (&mime.WordDecoder{}).DecodeHeader(strings.TrimSpace(addr))\n\t\t\tif err == nil {\n\t\t\t\tres = append(res, decodedAddr)\n\t\t\t} else {\n\t\t\t\tres = append(res, addr)\n\t\t\t}\n\t\t}\n\t}\n\treturn res\n}\n\n// NewEmailFromReader reads a stream of bytes from an io.Reader, r,\n// and returns an email struct containing the parsed data.\n// This function expects the data in RFC 5322 format.\nfunc NewEmailFromReader(r io.Reader) (*Email, error) {\n\te := NewEmail()\n\ts := &trimReader{rd: r}\n\ttp := textproto.NewReader(bufio.NewReader(s))\n\t// Parse the main headers\n\thdrs, err := tp.ReadMIMEHeader()\n\tif err != nil {\n\t\treturn e, err\n\t}\n\t// Set the subject, to, cc, bcc, and from\n\tfor h, v := range hdrs {\n\t\tswitch h {\n\t\tcase \"Subject\":\n\t\t\te.Subject = v[0]\n\t\t\tsubj, err := (&mime.WordDecoder{}).DecodeHeader(e.Subject)\n\t\t\tif err == nil && len(subj) > 0 {\n\t\t\t\te.Subject = subj\n\t\t\t}\n\t\t\tdelete(hdrs, h)\n\t\tcase \"To\":\n\t\t\te.To = handleAddressList(v)\n\t\t\tdelete(hdrs, h)\n\t\tcase \"Cc\":\n\t\t\te.Cc = handleAddressList(v)\n\t\t\tdelete(hdrs, h)\n\t\tcase \"Bcc\":\n\t\t\te.Bcc = handleAddressList(v)\n\t\t\tdelete(hdrs, h)\n\t\tcase \"Reply-To\":\n\t\t\te.ReplyTo = handleAddressList(v)\n\t\t\tdelete(hdrs, h)\n\t\tcase \"From\":\n\t\t\te.From = v[0]\n\t\t\tfr, err := (&mime.WordDecoder{}).DecodeHeader(e.From)\n\t\t\tif err == nil && len(fr) > 0 {\n\t\t\t\te.From = fr\n\t\t\t}\n\t\t\tdelete(hdrs, h)\n\t\t}\n\t}\n\te.Headers = hdrs\n\tbody := tp.R\n\t// Recursively parse the MIME parts\n\tps, err := parseMIMEParts(e.Headers, body)\n\tif err != nil {\n\t\treturn e, err\n\t}\n\tfor _, p := range ps {\n\t\tif ct := p.header.Get(\"Content-Type\"); ct == \"\" {\n\t\t\treturn e, ErrMissingContentType\n\t\t}\n\t\tct, _, err := mime.ParseMediaType(p.header.Get(\"Content-Type\"))\n\t\tif err != nil {\n\t\t\treturn e, err\n\t\t}\n\t\t// Check if part is an attachment based on the existence of the Content-Disposition header with a value of \"attachment\".\n\t\tif cd := p.header.Get(\"Content-Disposition\"); cd != \"\" {\n\t\t\tcd, params, err := mime.ParseMediaType(p.header.Get(\"Content-Disposition\"))\n\t\t\tif err != nil {\n\t\t\t\treturn e, err\n\t\t\t}\n\t\t\tfilename, filenameDefined := params[\"filename\"]\n\t\t\tif cd == \"attachment\" || (cd == \"inline\" && filenameDefined) {\n\t\t\t\t_, err = e.Attach(bytes.NewReader(p.body), filename, ct)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn e, err\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tswitch {\n\t\tcase ct == \"text/plain\":\n\t\t\te.Text = p.body\n\t\tcase ct == \"text/html\":\n\t\t\te.HTML = p.body\n\t\t}\n\t}\n\treturn e, nil\n}\n\n// parseMIMEParts will recursively walk a MIME entity and return a []mime.Part containing\n// each (flattened) mime.Part found.\n// It is important to note that there are no limits to the number of recursions, so be\n// careful when parsing unknown MIME structures!\nfunc parseMIMEParts(hs textproto.MIMEHeader, b io.Reader) ([]*part, error) {\n\tvar ps []*part\n\t// If no content type is given, set it to the default\n\tif _, ok := hs[\"Content-Type\"]; !ok {\n\t\ths.Set(\"Content-Type\", defaultContentType)\n\t}\n\tct, params, err := mime.ParseMediaType(hs.Get(\"Content-Type\"))\n\tif err != nil {\n\t\treturn ps, err\n\t}\n\t// If it's a multipart email, recursively parse the parts\n\tif strings.HasPrefix(ct, \"multipart/\") {\n\t\tif _, ok := params[\"boundary\"]; !ok {\n\t\t\treturn ps, ErrMissingBoundary\n\t\t}\n\t\tmr := multipart.NewReader(b, params[\"boundary\"])\n\t\tfor {\n\t\t\tvar buf bytes.Buffer\n\t\t\tp, err := mr.NextPart()\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn ps, err\n\t\t\t}\n\t\t\tif _, ok := p.Header[\"Content-Type\"]; !ok {\n\t\t\t\tp.Header.Set(\"Content-Type\", defaultContentType)\n\t\t\t}\n\t\t\tsubct, _, err := mime.ParseMediaType(p.Header.Get(\"Content-Type\"))\n\t\t\tif err != nil {\n\t\t\t\treturn ps, err\n\t\t\t}\n\t\t\tif strings.HasPrefix(subct, \"multipart/\") {\n\t\t\t\tsps, err := parseMIMEParts(p.Header, p)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn ps, err\n\t\t\t\t}\n\t\t\t\tps = append(ps, sps...)\n\t\t\t} else {\n\t\t\t\tvar reader io.Reader\n\t\t\t\treader = p\n\t\t\t\tconst cte = \"Content-Transfer-Encoding\"\n\t\t\t\tif p.Header.Get(cte) == \"base64\" {\n\t\t\t\t\treader = base64.NewDecoder(base64.StdEncoding, reader)\n\t\t\t\t}\n\t\t\t\t// Otherwise, just append the part to the list\n\t\t\t\t// Copy the part data into the buffer\n\t\t\t\tif _, err := io.Copy(&buf, reader); err != nil {\n\t\t\t\t\treturn ps, err\n\t\t\t\t}\n\t\t\t\tps = append(ps, &part{body: buf.Bytes(), header: p.Header})\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// If it is not a multipart email, parse the body content as a single \"part\"\n\t\tswitch hs.Get(\"Content-Transfer-Encoding\") {\n\t\tcase \"quoted-printable\":\n\t\t\tb = quotedprintable.NewReader(b)\n\t\tcase \"base64\":\n\t\t\tb = base64.NewDecoder(base64.StdEncoding, b)\n\t\t}\n\t\tvar buf bytes.Buffer\n\t\tif _, err := io.Copy(&buf, b); err != nil {\n\t\t\treturn ps, err\n\t\t}\n\t\tps = append(ps, &part{body: buf.Bytes(), header: hs})\n\t}\n\treturn ps, nil\n}\n\n// Attach is used to attach content from an io.Reader to the email.\n// Required parameters include an io.Reader, the desired filename for the attachment, and the Content-Type\n// The function will return the created Attachment for reference, as well as nil for the error, if successful.\nfunc (e *Email) Attach(r io.Reader, filename string, c string) (a *Attachment, err error) {\n\tvar buffer bytes.Buffer\n\tif _, err = io.Copy(&buffer, r); err != nil {\n\t\treturn\n\t}\n\tat := &Attachment{\n\t\tFilename:    filename,\n\t\tContentType: c,\n\t\tHeader:      textproto.MIMEHeader{},\n\t\tContent:     buffer.Bytes(),\n\t}\n\te.Attachments = append(e.Attachments, at)\n\treturn at, nil\n}\n\n// AttachFile is used to attach content to the email.\n// It attempts to open the file referenced by filename and, if successful, creates an Attachment.\n// This Attachment is then appended to the slice of Email.Attachments.\n// The function will then return the Attachment for reference, as well as nil for the error, if successful.\nfunc (e *Email) AttachFile(filename string) (a *Attachment, err error) {\n\tf, err := os.Open(filename)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tct := mime.TypeByExtension(filepath.Ext(filename))\n\tbasename := filepath.Base(filename)\n\treturn e.Attach(f, basename, ct)\n}\n\n// msgHeaders merges the Email's various fields and custom headers together in a\n// standards compliant way to create a MIMEHeader to be used in the resulting\n// message. It does not alter e.Headers.\n//\n// \"e\"'s fields To, Cc, From, Subject will be used unless they are present in\n// e.Headers. Unless set in e.Headers, \"Date\" will filled with the current time.\nfunc (e *Email) msgHeaders() (textproto.MIMEHeader, error) {\n\tres := make(textproto.MIMEHeader, len(e.Headers)+6)\n\tif e.Headers != nil {\n\t\tfor _, h := range []string{\"Reply-To\", \"To\", \"Cc\", \"From\", \"Subject\", \"Date\", \"Message-Id\", \"MIME-Version\"} {\n\t\t\tif v, ok := e.Headers[h]; ok {\n\t\t\t\tres[h] = v\n\t\t\t}\n\t\t}\n\t}\n\t// Set headers if there are values.\n\tif _, ok := res[\"Reply-To\"]; !ok && len(e.ReplyTo) > 0 {\n\t\tres.Set(\"Reply-To\", strings.Join(e.ReplyTo, \", \"))\n\t}\n\tif _, ok := res[\"To\"]; !ok && len(e.To) > 0 {\n\t\tres.Set(\"To\", strings.Join(e.To, \", \"))\n\t}\n\tif _, ok := res[\"Cc\"]; !ok && len(e.Cc) > 0 {\n\t\tres.Set(\"Cc\", strings.Join(e.Cc, \", \"))\n\t}\n\tif _, ok := res[\"Subject\"]; !ok && e.Subject != \"\" {\n\t\tres.Set(\"Subject\", e.Subject)\n\t}\n\tif _, ok := res[\"Message-Id\"]; !ok {\n\t\tid, err := generateMessageID()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tres.Set(\"Message-Id\", id)\n\t}\n\t// Date and From are required headers.\n\tif _, ok := res[\"From\"]; !ok {\n\t\tres.Set(\"From\", e.From)\n\t}\n\tif _, ok := res[\"Date\"]; !ok {\n\t\tres.Set(\"Date\", time.Now().Format(time.RFC1123Z))\n\t}\n\tif _, ok := res[\"MIME-Version\"]; !ok {\n\t\tres.Set(\"MIME-Version\", \"1.0\")\n\t}\n\tfor field, vals := range e.Headers {\n\t\tif _, ok := res[field]; !ok {\n\t\t\tres[field] = vals\n\t\t}\n\t}\n\treturn res, nil\n}\n\nfunc writeMessage(buff io.Writer, msg []byte, multipart bool, mediaType string, w *multipart.Writer) error {\n\tif multipart {\n\t\theader := textproto.MIMEHeader{\n\t\t\t\"Content-Type\":              {mediaType + \"; charset=UTF-8\"},\n\t\t\t\"Content-Transfer-Encoding\": {\"quoted-printable\"},\n\t\t}\n\t\tif _, err := w.CreatePart(header); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tqp := quotedprintable.NewWriter(buff)\n\t// Write the text\n\tif _, err := qp.Write(msg); err != nil {\n\t\treturn err\n\t}\n\treturn qp.Close()\n}\n\nfunc (e *Email) categorizeAttachments() (htmlRelated, others []*Attachment) {\n\tfor _, a := range e.Attachments {\n\t\tif a.HTMLRelated {\n\t\t\thtmlRelated = append(htmlRelated, a)\n\t\t} else {\n\t\t\tothers = append(others, a)\n\t\t}\n\t}\n\treturn\n}\n\n// Bytes converts the Email object to a []byte representation, including all needed MIMEHeaders, boundaries, etc.\nfunc (e *Email) Bytes() ([]byte, error) {\n\t// TODO: better guess buffer size\n\tbuff := bytes.NewBuffer(make([]byte, 0, 4096))\n\n\theaders, err := e.msgHeaders()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thtmlAttachments, otherAttachments := e.categorizeAttachments()\n\tif len(e.HTML) == 0 && len(htmlAttachments) > 0 {\n\t\treturn nil, errors.New(\"there are HTML attachments, but no HTML body\")\n\t}\n\n\tvar (\n\t\tisMixed       = len(otherAttachments) > 0\n\t\tisAlternative = len(e.Text) > 0 && len(e.HTML) > 0\n\t\tisRelated     = len(e.HTML) > 0 && len(htmlAttachments) > 0\n\t)\n\n\tvar w *multipart.Writer\n\tif isMixed || isAlternative || isRelated {\n\t\tw = multipart.NewWriter(buff)\n\t}\n\tswitch {\n\tcase isMixed:\n\t\theaders.Set(\"Content-Type\", \"multipart/mixed;\\r\\n boundary=\"+w.Boundary())\n\tcase isAlternative:\n\t\theaders.Set(\"Content-Type\", \"multipart/alternative;\\r\\n boundary=\"+w.Boundary())\n\tcase isRelated:\n\t\theaders.Set(\"Content-Type\", \"multipart/related;\\r\\n boundary=\"+w.Boundary())\n\tcase len(e.HTML) > 0:\n\t\theaders.Set(\"Content-Type\", \"text/html; charset=UTF-8\")\n\t\theaders.Set(\"Content-Transfer-Encoding\", \"quoted-printable\")\n\tdefault:\n\t\theaders.Set(\"Content-Type\", \"text/plain; charset=UTF-8\")\n\t\theaders.Set(\"Content-Transfer-Encoding\", \"quoted-printable\")\n\t}\n\theaderToBytes(buff, headers)\n\t_, err = io.WriteString(buff, \"\\r\\n\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check to see if there is a Text or HTML field\n\tif len(e.Text) > 0 || len(e.HTML) > 0 {\n\t\tvar subWriter *multipart.Writer\n\n\t\tif isMixed && isAlternative {\n\t\t\t// Create the multipart alternative part\n\t\t\tsubWriter = multipart.NewWriter(buff)\n\t\t\theader := textproto.MIMEHeader{\n\t\t\t\t\"Content-Type\": {\"multipart/alternative;\\r\\n boundary=\" + subWriter.Boundary()},\n\t\t\t}\n\t\t\tif _, err := w.CreatePart(header); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else {\n\t\t\tsubWriter = w\n\t\t}\n\t\t// Create the body sections\n\t\tif len(e.Text) > 0 {\n\t\t\t// Write the text\n\t\t\tif err := writeMessage(buff, e.Text, isMixed || isAlternative, \"text/plain\", subWriter); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t\tif len(e.HTML) > 0 {\n\t\t\tmessageWriter := subWriter\n\t\t\tvar relatedWriter *multipart.Writer\n\t\t\tif (isMixed || isAlternative) && len(htmlAttachments) > 0 {\n\t\t\t\trelatedWriter = multipart.NewWriter(buff)\n\t\t\t\theader := textproto.MIMEHeader{\n\t\t\t\t\t\"Content-Type\": {\"multipart/related;\\r\\n boundary=\" + relatedWriter.Boundary()},\n\t\t\t\t}\n\t\t\t\tif _, err := subWriter.CreatePart(header); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tmessageWriter = relatedWriter\n\t\t\t} else if isRelated && len(htmlAttachments) > 0 {\n\t\t\t\trelatedWriter = w\n\t\t\t\tmessageWriter = w\n\t\t\t}\n\t\t\t// Write the HTML\n\t\t\tif err := writeMessage(buff, e.HTML, isMixed || isAlternative || isRelated, \"text/html\", messageWriter); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif len(htmlAttachments) > 0 {\n\t\t\t\tfor _, a := range htmlAttachments {\n\t\t\t\t\ta.setDefaultHeaders()\n\t\t\t\t\tap, err := relatedWriter.CreatePart(a.Header)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\t// Write the base64Wrapped content to the part\n\t\t\t\t\tbase64Wrap(ap, a.Content)\n\t\t\t\t}\n\n\t\t\t\tif isMixed || isAlternative {\n\t\t\t\t\trelatedWriter.Close()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif isMixed && isAlternative {\n\t\t\tif err := subWriter.Close(); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\t// Create attachment part, if necessary\n\tfor _, a := range otherAttachments {\n\t\ta.setDefaultHeaders()\n\t\tap, err := w.CreatePart(a.Header)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Write the base64Wrapped content to the part\n\t\tbase64Wrap(ap, a.Content)\n\t}\n\tif isMixed || isAlternative || isRelated {\n\t\tif err := w.Close(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn buff.Bytes(), nil\n}\n\n// Send an email using the given host and SMTP auth (optional), returns any error thrown by smtp.SendMail\n// This function merges the To, Cc, and Bcc fields and calls the smtp.SendMail function using the Email.Bytes() output as the message\nfunc (e *Email) Send(addr string, a smtp.Auth) error {\n\t// Merge the To, Cc, and Bcc fields\n\tto := make([]string, 0, len(e.To)+len(e.Cc)+len(e.Bcc))\n\tto = append(append(append(to, e.To...), e.Cc...), e.Bcc...)\n\tfor i := 0; i < len(to); i++ {\n\t\taddr, err := mail.ParseAddress(to[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tto[i] = addr.Address\n\t}\n\t// Check to make sure there is at least one recipient and one \"From\" address\n\tif e.From == \"\" || len(to) == 0 {\n\t\treturn errors.New(\"Must specify at least one From address and one To address\")\n\t}\n\tsender, err := e.parseSender()\n\tif err != nil {\n\t\treturn err\n\t}\n\traw, err := e.Bytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn smtp.SendMail(addr, a, sender, to, raw)\n}\n\n// Select and parse an SMTP envelope sender address.  Choose Email.Sender if set, or fallback to Email.From.\nfunc (e *Email) parseSender() (string, error) {\n\tif e.Sender != \"\" {\n\t\tsender, err := mail.ParseAddress(e.Sender)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn sender.Address, nil\n\t} else {\n\t\tfrom, err := mail.ParseAddress(e.From)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn from.Address, nil\n\t}\n}\n\n// SendWithTLS sends an email over tls with an optional TLS config.\n//\n// The TLS Config is helpful if you need to connect to a host that is used an untrusted\n// certificate.\nfunc (e *Email) SendWithTLS(addr string, a smtp.Auth, t *tls.Config) error {\n\t// Merge the To, Cc, and Bcc fields\n\tto := make([]string, 0, len(e.To)+len(e.Cc)+len(e.Bcc))\n\tto = append(append(append(to, e.To...), e.Cc...), e.Bcc...)\n\tfor i := 0; i < len(to); i++ {\n\t\taddr, err := mail.ParseAddress(to[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tto[i] = addr.Address\n\t}\n\t// Check to make sure there is at least one recipient and one \"From\" address\n\tif e.From == \"\" || len(to) == 0 {\n\t\treturn errors.New(\"Must specify at least one From address and one To address\")\n\t}\n\tsender, err := e.parseSender()\n\tif err != nil {\n\t\treturn err\n\t}\n\traw, err := e.Bytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconn, err := tls.Dial(\"tcp\", addr, t)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc, err := smtp.NewClient(conn, t.ServerName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\tif err = c.Hello(\"localhost\"); err != nil {\n\t\treturn err\n\t}\n\n\tif a != nil {\n\t\tif ok, _ := c.Extension(\"AUTH\"); ok {\n\t\t\tif err = c.Auth(a); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err = c.Mail(sender); err != nil {\n\t\treturn err\n\t}\n\tfor _, addr := range to {\n\t\tif err = c.Rcpt(addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tw, err := c.Data()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = w.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.Quit()\n}\n\n// SendWithStartTLS sends an email over TLS using STARTTLS with an optional TLS config.\n//\n// The TLS Config is helpful if you need to connect to a host that is used an untrusted\n// certificate.\nfunc (e *Email) SendWithStartTLS(addr string, a smtp.Auth, t *tls.Config) error {\n\t// Merge the To, Cc, and Bcc fields\n\tto := make([]string, 0, len(e.To)+len(e.Cc)+len(e.Bcc))\n\tto = append(append(append(to, e.To...), e.Cc...), e.Bcc...)\n\tfor i := 0; i < len(to); i++ {\n\t\taddr, err := mail.ParseAddress(to[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tto[i] = addr.Address\n\t}\n\t// Check to make sure there is at least one recipient and one \"From\" address\n\tif e.From == \"\" || len(to) == 0 {\n\t\treturn errors.New(\"Must specify at least one From address and one To address\")\n\t}\n\tsender, err := e.parseSender()\n\tif err != nil {\n\t\treturn err\n\t}\n\traw, err := e.Bytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Taken from the standard library\n\t// https://github.com/golang/go/blob/master/src/net/smtp/smtp.go#L328\n\tc, err := smtp.Dial(addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer c.Close()\n\tif err = c.Hello(\"localhost\"); err != nil {\n\t\treturn err\n\t}\n\t// Use TLS if available\n\tif ok, _ := c.Extension(\"STARTTLS\"); ok {\n\t\tif err = c.StartTLS(t); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif a != nil {\n\t\tif ok, _ := c.Extension(\"AUTH\"); ok {\n\t\t\tif err = c.Auth(a); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\tif err = c.Mail(sender); err != nil {\n\t\treturn err\n\t}\n\tfor _, addr := range to {\n\t\tif err = c.Rcpt(addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\tw, err := c.Data()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = w.Write(raw)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = w.Close()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn c.Quit()\n}\n\n// Attachment is a struct representing an email attachment.\n// Based on the mime/multipart.FileHeader struct, Attachment contains the name, MIMEHeader, and content of the attachment in question\ntype Attachment struct {\n\tFilename    string\n\tContentType string\n\tHeader      textproto.MIMEHeader\n\tContent     []byte\n\tHTMLRelated bool\n}\n\nfunc (at *Attachment) setDefaultHeaders() {\n\tcontentType := \"application/octet-stream\"\n\tif len(at.ContentType) > 0 {\n\t\tcontentType = at.ContentType\n\t}\n\tat.Header.Set(\"Content-Type\", contentType)\n\n\tif len(at.Header.Get(\"Content-Disposition\")) == 0 {\n\t\tdisposition := \"attachment\"\n\t\tif at.HTMLRelated {\n\t\t\tdisposition = \"inline\"\n\t\t}\n\t\tat.Header.Set(\"Content-Disposition\", fmt.Sprintf(\"%s;\\r\\n filename=\\\"%s\\\"\", disposition, at.Filename))\n\t}\n\tif len(at.Header.Get(\"Content-ID\")) == 0 {\n\t\tat.Header.Set(\"Content-ID\", fmt.Sprintf(\"<%s>\", at.Filename))\n\t}\n\tif len(at.Header.Get(\"Content-Transfer-Encoding\")) == 0 {\n\t\tat.Header.Set(\"Content-Transfer-Encoding\", \"base64\")\n\t}\n}\n\n// base64Wrap encodes the attachment content, and wraps it according to RFC 2045 standards (every 76 chars)\n// The output is then written to the specified io.Writer\nfunc base64Wrap(w io.Writer, b []byte) {\n\t// 57 raw bytes per 76-byte base64 line.\n\tconst maxRaw = 57\n\t// Buffer for each line, including trailing CRLF.\n\tbuffer := make([]byte, MaxLineLength+len(\"\\r\\n\"))\n\tcopy(buffer[MaxLineLength:], \"\\r\\n\")\n\t// Process raw chunks until there's no longer enough to fill a line.\n\tfor len(b) >= maxRaw {\n\t\tbase64.StdEncoding.Encode(buffer, b[:maxRaw])\n\t\tw.Write(buffer)\n\t\tb = b[maxRaw:]\n\t}\n\t// Handle the last chunk of bytes.\n\tif len(b) > 0 {\n\t\tout := buffer[:base64.StdEncoding.EncodedLen(len(b))]\n\t\tbase64.StdEncoding.Encode(out, b)\n\t\tout = append(out, \"\\r\\n\"...)\n\t\tw.Write(out)\n\t}\n}\n\n// headerToBytes renders \"header\" to \"buff\". If there are multiple values for a\n// field, multiple \"Field: value\\r\\n\" lines will be emitted.\nfunc headerToBytes(buff io.Writer, header textproto.MIMEHeader) {\n\tfor field, vals := range header {\n\t\tfor _, subval := range vals {\n\t\t\t// bytes.Buffer.Write() never returns an error.\n\t\t\tio.WriteString(buff, field)\n\t\t\tio.WriteString(buff, \": \")\n\t\t\t// Write the encoded header if needed\n\t\t\tswitch {\n\t\t\tcase field == \"Content-Type\" || field == \"Content-Disposition\":\n\t\t\t\tbuff.Write([]byte(subval))\n\t\t\tcase field == \"From\" || field == \"To\" || field == \"Cc\" || field == \"Bcc\":\n\t\t\t\tparticipants := strings.Split(subval, \",\")\n\t\t\t\tfor i, v := range participants {\n\t\t\t\t\taddr, err := mail.ParseAddress(v)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tparticipants[i] = addr.String()\n\t\t\t\t}\n\t\t\t\tbuff.Write([]byte(strings.Join(participants, \", \")))\n\t\t\tdefault:\n\t\t\t\tbuff.Write([]byte(mime.QEncoding.Encode(\"UTF-8\", subval)))\n\t\t\t}\n\t\t\tio.WriteString(buff, \"\\r\\n\")\n\t\t}\n\t}\n}\n\nvar maxBigInt = big.NewInt(math.MaxInt64)\n\n// generateMessageID generates and returns a string suitable for an RFC 2822\n// compliant Message-ID, e.g.:\n// <1444789264909237300.3464.1819418242800517193@DESKTOP01>\n//\n// The following parameters are used to generate a Message-ID:\n// - The nanoseconds since Epoch\n// - The calling PID\n// - A cryptographically random int64\n// - The sending hostname\nfunc generateMessageID() (string, error) {\n\tt := time.Now().UnixNano()\n\tpid := os.Getpid()\n\trint, err := rand.Int(rand.Reader, maxBigInt)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\th, err := os.Hostname()\n\t// If we can't get the hostname, we'll use localhost\n\tif err != nil {\n\t\th = \"localhost.localdomain\"\n\t}\n\tmsgid := fmt.Sprintf(\"<%d.%d.%d@%s>\", t, pid, rint, h)\n\treturn msgid, nil\n}\n"
        },
        {
          "name": "email_test.go",
          "type": "blob",
          "size": 28.86328125,
          "content": "package email\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"bufio\"\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"mime/quotedprintable\"\n\t\"net/mail\"\n\t\"net/smtp\"\n\t\"net/textproto\"\n)\n\nfunc prepareEmail() *Email {\n\te := NewEmail()\n\te.From = \"Jordan Wright <test@example.com>\"\n\te.To = []string{\"test@example.com\"}\n\te.Bcc = []string{\"test_bcc@example.com\"}\n\te.Cc = []string{\"test_cc@example.com\"}\n\te.Subject = \"Awesome Subject\"\n\treturn e\n}\n\nfunc basicTests(t *testing.T, e *Email) *mail.Message {\n\traw, err := e.Bytes()\n\tif err != nil {\n\t\tt.Fatal(\"Failed to render message: \", e)\n\t}\n\n\tmsg, err := mail.ReadMessage(bytes.NewBuffer(raw))\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse rendered message: \", err)\n\t}\n\n\texpectedHeaders := map[string]string{\n\t\t\"To\":      \"<test@example.com>\",\n\t\t\"From\":    \"\\\"Jordan Wright\\\" <test@example.com>\",\n\t\t\"Cc\":      \"<test_cc@example.com>\",\n\t\t\"Subject\": \"Awesome Subject\",\n\t}\n\n\tfor header, expected := range expectedHeaders {\n\t\tif val := msg.Header.Get(header); val != expected {\n\t\t\tt.Errorf(\"Wrong value for message header %s: %v != %v\", header, expected, val)\n\t\t}\n\t}\n\treturn msg\n}\n\nfunc TestEmailText(t *testing.T) {\n\te := prepareEmail()\n\te.Text = []byte(\"Text Body is, of course, supported!\\n\")\n\n\tmsg := basicTests(t, e)\n\n\t// Were the right headers set?\n\tct := msg.Header.Get(\"Content-type\")\n\tmt, _, err := mime.ParseMediaType(ct)\n\tif err != nil {\n\t\tt.Fatal(\"Content-type header is invalid: \", ct)\n\t} else if mt != \"text/plain\" {\n\t\tt.Fatalf(\"Content-type expected \\\"text/plain\\\", not %v\", mt)\n\t}\n}\n\nfunc TestEmailWithHTMLAttachments(t *testing.T) {\n\te := prepareEmail()\n\n\t// Set plain text to exercise \"mime/alternative\"\n\te.Text = []byte(\"Text Body is, of course, supported!\\n\")\n\n\te.HTML = []byte(\"<html><body>This is a text.</body></html>\")\n\n\t// Set HTML attachment to exercise \"mime/related\".\n\tattachment, err := e.Attach(bytes.NewBufferString(\"Rad attachment\"), \"rad.txt\", \"image/png; charset=utf-8\")\n\tif err != nil {\n\t\tt.Fatal(\"Could not add an attachment to the message: \", err)\n\t}\n\tattachment.HTMLRelated = true\n\n\tb, err := e.Bytes()\n\tif err != nil {\n\t\tt.Fatal(\"Could not serialize e-mail:\", err)\n\t}\n\n\t// Print the bytes for ocular validation and make sure no errors.\n\t//fmt.Println(string(b))\n\n\t// TODO: Verify the attachments.\n\ts := &trimReader{rd: bytes.NewBuffer(b)}\n\ttp := textproto.NewReader(bufio.NewReader(s))\n\t// Parse the main headers\n\thdrs, err := tp.ReadMIMEHeader()\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse the headers:\", err)\n\t}\n\t// Recursively parse the MIME parts\n\tps, err := parseMIMEParts(hdrs, tp.R)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse the MIME parts recursively:\", err)\n\t}\n\n\tplainTextFound := false\n\thtmlFound := false\n\timageFound := false\n\tif expected, actual := 3, len(ps); actual != expected {\n\t\tt.Error(\"Unexpected number of parts. Expected:\", expected, \"Was:\", actual)\n\t}\n\tfor _, part := range ps {\n\t\t// part has \"header\" and \"body []byte\"\n\t\tcd := part.header.Get(\"Content-Disposition\")\n\t\tct := part.header.Get(\"Content-Type\")\n\t\tif strings.Contains(ct, \"image/png\") && strings.HasPrefix(cd, \"inline\") {\n\t\t\timageFound = true\n\t\t}\n\t\tif strings.Contains(ct, \"text/html\") {\n\t\t\thtmlFound = true\n\t\t}\n\t\tif strings.Contains(ct, \"text/plain\") {\n\t\t\tplainTextFound = true\n\t\t}\n\t}\n\n\tif !plainTextFound {\n\t\tt.Error(\"Did not find plain text part.\")\n\t}\n\tif !htmlFound {\n\t\tt.Error(\"Did not find HTML part.\")\n\t}\n\tif !imageFound {\n\t\tt.Error(\"Did not find image part.\")\n\t}\n}\n\nfunc TestEmailWithHTMLAttachmentsHTMLOnly(t *testing.T) {\n\te := prepareEmail()\n\n\te.HTML = []byte(\"<html><body>This is a text.</body></html>\")\n\n\t// Set HTML attachment to exercise \"mime/related\".\n\tattachment, err := e.Attach(bytes.NewBufferString(\"Rad attachment\"), \"rad.txt\", \"image/png; charset=utf-8\")\n\tif err != nil {\n\t\tt.Fatal(\"Could not add an attachment to the message: \", err)\n\t}\n\tattachment.HTMLRelated = true\n\n\tb, err := e.Bytes()\n\tif err != nil {\n\t\tt.Fatal(\"Could not serialize e-mail:\", err)\n\t}\n\n\t// Print the bytes for ocular validation and make sure no errors.\n\t//fmt.Println(string(b))\n\n\t// TODO: Verify the attachments.\n\ts := &trimReader{rd: bytes.NewBuffer(b)}\n\ttp := textproto.NewReader(bufio.NewReader(s))\n\t// Parse the main headers\n\thdrs, err := tp.ReadMIMEHeader()\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse the headers:\", err)\n\t}\n\n\tif !strings.HasPrefix(hdrs.Get(\"Content-Type\"), \"multipart/related\") {\n\t\tt.Error(\"Envelope Content-Type is not multipart/related: \", hdrs[\"Content-Type\"])\n\t}\n\n\t// Recursively parse the MIME parts\n\tps, err := parseMIMEParts(hdrs, tp.R)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse the MIME parts recursively:\", err)\n\t}\n\n\thtmlFound := false\n\timageFound := false\n\tif expected, actual := 2, len(ps); actual != expected {\n\t\tt.Error(\"Unexpected number of parts. Expected:\", expected, \"Was:\", actual)\n\t}\n\tfor _, part := range ps {\n\t\t// part has \"header\" and \"body []byte\"\n\t\tct := part.header.Get(\"Content-Type\")\n\t\tif strings.Contains(ct, \"image/png\") {\n\t\t\timageFound = true\n\t\t}\n\t\tif strings.Contains(ct, \"text/html\") {\n\t\t\thtmlFound = true\n\t\t}\n\t}\n\n\tif !htmlFound {\n\t\tt.Error(\"Did not find HTML part.\")\n\t}\n\tif !imageFound {\n\t\tt.Error(\"Did not find image part.\")\n\t}\n}\n\nfunc TestEmailHTML(t *testing.T) {\n\te := prepareEmail()\n\te.HTML = []byte(\"<h1>Fancy Html is supported, too!</h1>\\n\")\n\n\tmsg := basicTests(t, e)\n\n\t// Were the right headers set?\n\tct := msg.Header.Get(\"Content-type\")\n\tmt, _, err := mime.ParseMediaType(ct)\n\tif err != nil {\n\t\tt.Fatalf(\"Content-type header is invalid: %#v\", ct)\n\t} else if mt != \"text/html\" {\n\t\tt.Fatalf(\"Content-type expected \\\"text/html\\\", not %v\", mt)\n\t}\n}\n\nfunc TestEmailTextAttachment(t *testing.T) {\n\te := prepareEmail()\n\te.Text = []byte(\"Text Body is, of course, supported!\\n\")\n\t_, err := e.Attach(bytes.NewBufferString(\"Rad attachment\"), \"rad.txt\", \"text/plain; charset=utf-8\")\n\tif err != nil {\n\t\tt.Fatal(\"Could not add an attachment to the message: \", err)\n\t}\n\n\tmsg := basicTests(t, e)\n\n\t// Were the right headers set?\n\tct := msg.Header.Get(\"Content-type\")\n\tmt, params, err := mime.ParseMediaType(ct)\n\tif err != nil {\n\t\tt.Fatal(\"Content-type header is invalid: \", ct)\n\t} else if mt != \"multipart/mixed\" {\n\t\tt.Fatalf(\"Content-type expected \\\"multipart/mixed\\\", not %v\", mt)\n\t}\n\tb := params[\"boundary\"]\n\tif b == \"\" {\n\t\tt.Fatalf(\"Invalid or missing boundary parameter: %#v\", b)\n\t}\n\tif len(params) != 1 {\n\t\tt.Fatal(\"Unexpected content-type parameters\")\n\t}\n\n\t// Is the generated message parsable?\n\tmixed := multipart.NewReader(msg.Body, params[\"boundary\"])\n\n\ttext, err := mixed.NextPart()\n\tif err != nil {\n\t\tt.Fatalf(\"Could not find text component of email: %s\", err)\n\t}\n\n\t// Does the text portion match what we expect?\n\tmt, _, err = mime.ParseMediaType(text.Header.Get(\"Content-type\"))\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse message's Content-Type\")\n\t} else if mt != \"text/plain\" {\n\t\tt.Fatal(\"Message missing text/plain\")\n\t}\n\tplainText, err := ioutil.ReadAll(text)\n\tif err != nil {\n\t\tt.Fatal(\"Could not read plain text component of message: \", err)\n\t}\n\tif !bytes.Equal(plainText, []byte(\"Text Body is, of course, supported!\\r\\n\")) {\n\t\tt.Fatalf(\"Plain text is broken: %#q\", plainText)\n\t}\n\n\t// Check attachments.\n\t_, err = mixed.NextPart()\n\tif err != nil {\n\t\tt.Fatalf(\"Could not find attachment component of email: %s\", err)\n\t}\n\n\tif _, err = mixed.NextPart(); err != io.EOF {\n\t\tt.Error(\"Expected only text and one attachment!\")\n\t}\n}\n\nfunc TestEmailTextHtmlAttachment(t *testing.T) {\n\te := prepareEmail()\n\te.Text = []byte(\"Text Body is, of course, supported!\\n\")\n\te.HTML = []byte(\"<h1>Fancy Html is supported, too!</h1>\\n\")\n\t_, err := e.Attach(bytes.NewBufferString(\"Rad attachment\"), \"rad.txt\", \"text/plain; charset=utf-8\")\n\tif err != nil {\n\t\tt.Fatal(\"Could not add an attachment to the message: \", err)\n\t}\n\n\tmsg := basicTests(t, e)\n\n\t// Were the right headers set?\n\tct := msg.Header.Get(\"Content-type\")\n\tmt, params, err := mime.ParseMediaType(ct)\n\tif err != nil {\n\t\tt.Fatal(\"Content-type header is invalid: \", ct)\n\t} else if mt != \"multipart/mixed\" {\n\t\tt.Fatalf(\"Content-type expected \\\"multipart/mixed\\\", not %v\", mt)\n\t}\n\tb := params[\"boundary\"]\n\tif b == \"\" {\n\t\tt.Fatal(\"Unexpected empty boundary parameter\")\n\t}\n\tif len(params) != 1 {\n\t\tt.Fatal(\"Unexpected content-type parameters\")\n\t}\n\n\t// Is the generated message parsable?\n\tmixed := multipart.NewReader(msg.Body, params[\"boundary\"])\n\n\ttext, err := mixed.NextPart()\n\tif err != nil {\n\t\tt.Fatalf(\"Could not find text component of email: %s\", err)\n\t}\n\n\t// Does the text portion match what we expect?\n\tmt, params, err = mime.ParseMediaType(text.Header.Get(\"Content-type\"))\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse message's Content-Type\")\n\t} else if mt != \"multipart/alternative\" {\n\t\tt.Fatal(\"Message missing multipart/alternative\")\n\t}\n\tmpReader := multipart.NewReader(text, params[\"boundary\"])\n\tpart, err := mpReader.NextPart()\n\tif err != nil {\n\t\tt.Fatal(\"Could not read plain text component of message: \", err)\n\t}\n\tplainText, err := ioutil.ReadAll(part)\n\tif err != nil {\n\t\tt.Fatal(\"Could not read plain text component of message: \", err)\n\t}\n\tif !bytes.Equal(plainText, []byte(\"Text Body is, of course, supported!\\r\\n\")) {\n\t\tt.Fatalf(\"Plain text is broken: %#q\", plainText)\n\t}\n\n\t// Check attachments.\n\t_, err = mixed.NextPart()\n\tif err != nil {\n\t\tt.Fatalf(\"Could not find attachment component of email: %s\", err)\n\t}\n\n\tif _, err = mixed.NextPart(); err != io.EOF {\n\t\tt.Error(\"Expected only text and one attachment!\")\n\t}\n}\n\nfunc TestEmailAttachment(t *testing.T) {\n\te := prepareEmail()\n\t_, err := e.Attach(bytes.NewBufferString(\"Rad attachment\"), \"rad.txt\", \"text/plain; charset=utf-8\")\n\tif err != nil {\n\t\tt.Fatal(\"Could not add an attachment to the message: \", err)\n\t}\n\tmsg := basicTests(t, e)\n\n\t// Were the right headers set?\n\tct := msg.Header.Get(\"Content-type\")\n\tmt, params, err := mime.ParseMediaType(ct)\n\tif err != nil {\n\t\tt.Fatal(\"Content-type header is invalid: \", ct)\n\t} else if mt != \"multipart/mixed\" {\n\t\tt.Fatalf(\"Content-type expected \\\"multipart/mixed\\\", not %v\", mt)\n\t}\n\tb := params[\"boundary\"]\n\tif b == \"\" {\n\t\tt.Fatal(\"Unexpected empty boundary parameter\")\n\t}\n\tif len(params) != 1 {\n\t\tt.Fatal(\"Unexpected content-type parameters\")\n\t}\n\n\t// Is the generated message parsable?\n\tmixed := multipart.NewReader(msg.Body, params[\"boundary\"])\n\n\t// Check attachments.\n\ta, err := mixed.NextPart()\n\tif err != nil {\n\t\tt.Fatalf(\"Could not find attachment component of email: %s\", err)\n\t}\n\n\tif !strings.HasPrefix(a.Header.Get(\"Content-Disposition\"), \"attachment\") {\n\t\tt.Fatalf(\"Content disposition is not attachment: %s\", a.Header.Get(\"Content-Disposition\"))\n\t}\n\n\tif _, err = mixed.NextPart(); err != io.EOF {\n\t\tt.Error(\"Expected only one attachment!\")\n\t}\n}\n\nfunc TestHeaderEncoding(t *testing.T) {\n\tcases := []struct {\n\t\tfield string\n\t\thave  string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\tfield: \"From\",\n\t\t\thave:  \"Needs Enc√≥ding <encoding@example.com>, Only ASCII <foo@example.com>\",\n\t\t\twant:  \"=?utf-8?q?Needs_Enc=C3=B3ding?= <encoding@example.com>, \\\"Only ASCII\\\" <foo@example.com>\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tfield: \"To\",\n\t\t\thave:  \"Keith Moore <moore@cs.utk.edu>, Keld J√∏rn Simonsen <keld@dkuug.dk>\",\n\t\t\twant:  \"\\\"Keith Moore\\\" <moore@cs.utk.edu>, =?utf-8?q?Keld_J=C3=B8rn_Simonsen?= <keld@dkuug.dk>\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tfield: \"Cc\",\n\t\t\thave:  \"Needs Enc√≥ding <encoding@example.com>, \\\"Test :)\\\" <test@localhost>\",\n\t\t\twant:  \"=?utf-8?q?Needs_Enc=C3=B3ding?= <encoding@example.com>, \\\"Test :)\\\" <test@localhost>\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tfield: \"Subject\",\n\t\t\thave:  \"Subject with a üêü\",\n\t\t\twant:  \"=?UTF-8?q?Subject_with_a_=F0=9F=90=9F?=\\r\\n\",\n\t\t},\n\t\t{\n\t\t\tfield: \"Subject\",\n\t\t\thave:  \"Subject with only ASCII\",\n\t\t\twant:  \"Subject with only ASCII\\r\\n\",\n\t\t},\n\t}\n\tbuff := &bytes.Buffer{}\n\tfor _, c := range cases {\n\t\theader := make(textproto.MIMEHeader)\n\t\theader.Add(c.field, c.have)\n\t\tbuff.Reset()\n\t\theaderToBytes(buff, header)\n\t\twant := fmt.Sprintf(\"%s: %s\", c.field, c.want)\n\t\tgot := buff.String()\n\t\tif got != want {\n\t\t\tt.Errorf(\"invalid utf-8 header encoding. \\nwant:%#v\\ngot: %#v\", want, got)\n\t\t}\n\t}\n}\n\nfunc TestEmailFromReader(t *testing.T) {\n\tex := &Email{\n\t\tSubject: \"Test Subject\",\n\t\tTo:      []string{\"Jordan Wright <jmwright798@gmail.com>\", \"also@example.com\"},\n\t\tFrom:    \"Jordan Wright <jmwright798@gmail.com>\",\n\t\tReplyTo: []string{\"Jordan Wright <jmwright798@gmail.com>\"},\n\t\tCc:      []string{\"one@example.com\", \"Two <two@example.com>\"},\n\t\tBcc:     []string{\"three@example.com\", \"Four <four@example.com>\"},\n\t\tText:    []byte(\"This is a test email with HTML Formatting. It also has very long lines so\\nthat the content must be wrapped if using quoted-printable decoding.\\n\"),\n\t\tHTML:    []byte(\"<div dir=\\\"ltr\\\">This is a test email with <b>HTML Formatting.</b>\\u00a0It also has very long lines so that the content must be wrapped if using quoted-printable decoding.</div>\\n\"),\n\t}\n\traw := []byte(`\n\tMIME-Version: 1.0\nSubject: Test Subject\nFrom: Jordan Wright <jmwright798@gmail.com>\nReply-To: Jordan Wright <jmwright798@gmail.com>\nTo: Jordan Wright <jmwright798@gmail.com>, also@example.com\nCc: one@example.com, Two <two@example.com>\nBcc: three@example.com, Four <four@example.com>\nContent-Type: multipart/alternative; boundary=001a114fb3fc42fd6b051f834280\n\n--001a114fb3fc42fd6b051f834280\nContent-Type: text/plain; charset=UTF-8\n\nThis is a test email with HTML Formatting. It also has very long lines so\nthat the content must be wrapped if using quoted-printable decoding.\n\n--001a114fb3fc42fd6b051f834280\nContent-Type: text/html; charset=UTF-8\nContent-Transfer-Encoding: quoted-printable\n\n<div dir=3D\"ltr\">This is a test email with <b>HTML Formatting.</b>=C2=A0It =\nalso has very long lines so that the content must be wrapped if using quote=\nd-printable decoding.</div>\n\n--001a114fb3fc42fd6b051f834280--`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating email %s\", err.Error())\n\t}\n\tif e.Subject != ex.Subject {\n\t\tt.Fatalf(\"Incorrect subject. %#q != %#q\", e.Subject, ex.Subject)\n\t}\n\tif !bytes.Equal(e.Text, ex.Text) {\n\t\tt.Fatalf(\"Incorrect text: %#q != %#q\", e.Text, ex.Text)\n\t}\n\tif !bytes.Equal(e.HTML, ex.HTML) {\n\t\tt.Fatalf(\"Incorrect HTML: %#q != %#q\", e.HTML, ex.HTML)\n\t}\n\tif e.From != ex.From {\n\t\tt.Fatalf(\"Incorrect \\\"From\\\": %#q != %#q\", e.From, ex.From)\n\t}\n\tif len(e.To) != len(ex.To) {\n\t\tt.Fatalf(\"Incorrect number of \\\"To\\\" addresses: %v != %v\", len(e.To), len(ex.To))\n\t}\n\tif e.To[0] != ex.To[0] {\n\t\tt.Fatalf(\"Incorrect \\\"To[0]\\\": %#q != %#q\", e.To[0], ex.To[0])\n\t}\n\tif e.To[1] != ex.To[1] {\n\t\tt.Fatalf(\"Incorrect \\\"To[1]\\\": %#q != %#q\", e.To[1], ex.To[1])\n\t}\n\tif len(e.Cc) != len(ex.Cc) {\n\t\tt.Fatalf(\"Incorrect number of \\\"Cc\\\" addresses: %v != %v\", len(e.Cc), len(ex.Cc))\n\t}\n\tif e.Cc[0] != ex.Cc[0] {\n\t\tt.Fatalf(\"Incorrect \\\"Cc[0]\\\": %#q != %#q\", e.Cc[0], ex.Cc[0])\n\t}\n\tif e.Cc[1] != ex.Cc[1] {\n\t\tt.Fatalf(\"Incorrect \\\"Cc[1]\\\": %#q != %#q\", e.Cc[1], ex.Cc[1])\n\t}\n\tif len(e.Bcc) != len(ex.Bcc) {\n\t\tt.Fatalf(\"Incorrect number of \\\"Bcc\\\" addresses: %v != %v\", len(e.Bcc), len(ex.Bcc))\n\t}\n\tif e.Bcc[0] != ex.Bcc[0] {\n\t\tt.Fatalf(\"Incorrect \\\"Bcc[0]\\\": %#q != %#q\", e.Cc[0], ex.Cc[0])\n\t}\n\tif e.Bcc[1] != ex.Bcc[1] {\n\t\tt.Fatalf(\"Incorrect \\\"Bcc[1]\\\": %#q != %#q\", e.Bcc[1], ex.Bcc[1])\n\t}\n\tif len(e.ReplyTo) != len(ex.ReplyTo) {\n\t\tt.Fatalf(\"Incorrect number of \\\"Reply-To\\\" addresses: %v != %v\", len(e.ReplyTo), len(ex.ReplyTo))\n\t}\n\tif e.ReplyTo[0] != ex.ReplyTo[0] {\n\t\tt.Fatalf(\"Incorrect \\\"ReplyTo\\\": %#q != %#q\", e.ReplyTo[0], ex.ReplyTo[0])\n\t}\n}\n\nfunc TestNonAsciiEmailFromReader(t *testing.T) {\n\tex := &Email{\n\t\tSubject: \"Test Subject\",\n\t\tTo:      []string{\"Ana√Øs <anais@example.org>\"},\n\t\tCc:      []string{\"Patrik F√§ltstr√∂m <paf@example.com>\"},\n\t\tFrom:    \"Mrs Val√É¬©rie Dupont <valerie.dupont@example.com>\",\n\t\tText:    []byte(\"This is a test message!\"),\n\t}\n\traw := []byte(`\n\tMIME-Version: 1.0\nSubject: =?UTF-8?Q?Test Subject?=\nFrom: Mrs =?ISO-8859-1?Q?Val=C3=A9rie=20Dupont?= <valerie.dupont@example.com>\nTo: =?utf-8?q?Ana=C3=AFs?= <anais@example.org>\nCc: =?ISO-8859-1?Q?Patrik_F=E4ltstr=F6m?= <paf@example.com>\nContent-type: text/plain; charset=ISO-8859-1\n\nThis is a test message!`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating email %s\", err.Error())\n\t}\n\tif e.Subject != ex.Subject {\n\t\tt.Fatalf(\"Incorrect subject. %#q != %#q\", e.Subject, ex.Subject)\n\t}\n\tif e.From != ex.From {\n\t\tt.Fatalf(\"Incorrect \\\"From\\\": %#q != %#q\", e.From, ex.From)\n\t}\n\tif e.To[0] != ex.To[0] {\n\t\tt.Fatalf(\"Incorrect \\\"To\\\": %#q != %#q\", e.To, ex.To)\n\t}\n\tif e.Cc[0] != ex.Cc[0] {\n\t\tt.Fatalf(\"Incorrect \\\"Cc\\\": %#q != %#q\", e.Cc, ex.Cc)\n\t}\n}\n\nfunc TestNonMultipartEmailFromReader(t *testing.T) {\n\tex := &Email{\n\t\tText:    []byte(\"This is a test message!\"),\n\t\tSubject: \"Example Subject (no MIME Type)\",\n\t\tHeaders: textproto.MIMEHeader{},\n\t}\n\tex.Headers.Add(\"Content-Type\", \"text/plain; charset=us-ascii\")\n\tex.Headers.Add(\"Message-ID\", \"<foobar@example.com>\")\n\traw := []byte(`From: \"Foo Bar\" <foobar@example.com>\nContent-Type: text/plain\nTo: foobar@example.com\nSubject: Example Subject (no MIME Type)\nMessage-ID: <foobar@example.com>\n\nThis is a test message!`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating email %s\", err.Error())\n\t}\n\tif ex.Subject != e.Subject {\n\t\tt.Errorf(\"Incorrect subject. %#q != %#q\\n\", ex.Subject, e.Subject)\n\t}\n\tif !bytes.Equal(ex.Text, e.Text) {\n\t\tt.Errorf(\"Incorrect body. %#q != %#q\\n\", ex.Text, e.Text)\n\t}\n\tif ex.Headers.Get(\"Message-ID\") != e.Headers.Get(\"Message-ID\") {\n\t\tt.Errorf(\"Incorrect message ID. %#q != %#q\\n\", ex.Headers.Get(\"Message-ID\"), e.Headers.Get(\"Message-ID\"))\n\t}\n}\n\nfunc TestBase64EmailFromReader(t *testing.T) {\n\tex := &Email{\n\t\tSubject: \"Test Subject\",\n\t\tTo:      []string{\"Jordan Wright <jmwright798@gmail.com>\"},\n\t\tFrom:    \"Jordan Wright <jmwright798@gmail.com>\",\n\t\tText:    []byte(\"This is a test email with HTML Formatting. It also has very long lines so that the content must be wrapped if using quoted-printable decoding.\"),\n\t\tHTML:    []byte(\"<div dir=\\\"ltr\\\">This is a test email with <b>HTML Formatting.</b>\\u00a0It also has very long lines so that the content must be wrapped if using quoted-printable decoding.</div>\\n\"),\n\t}\n\traw := []byte(`\n\t\tMIME-Version: 1.0\nSubject: Test Subject\nFrom: Jordan Wright <jmwright798@gmail.com>\nTo: Jordan Wright <jmwright798@gmail.com>\nContent-Type: multipart/alternative; boundary=001a114fb3fc42fd6b051f834280\n\n--001a114fb3fc42fd6b051f834280\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: base64\n\nVGhpcyBpcyBhIHRlc3QgZW1haWwgd2l0aCBIVE1MIEZvcm1hdHRpbmcuIEl0IGFsc28gaGFzIHZl\ncnkgbG9uZyBsaW5lcyBzbyB0aGF0IHRoZSBjb250ZW50IG11c3QgYmUgd3JhcHBlZCBpZiB1c2lu\nZyBxdW90ZWQtcHJpbnRhYmxlIGRlY29kaW5nLg==\n\n--001a114fb3fc42fd6b051f834280\nContent-Type: text/html; charset=UTF-8\nContent-Transfer-Encoding: quoted-printable\n\n<div dir=3D\"ltr\">This is a test email with <b>HTML Formatting.</b>=C2=A0It =\nalso has very long lines so that the content must be wrapped if using quote=\nd-printable decoding.</div>\n\n--001a114fb3fc42fd6b051f834280--`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating email %s\", err.Error())\n\t}\n\tif e.Subject != ex.Subject {\n\t\tt.Fatalf(\"Incorrect subject. %#q != %#q\", e.Subject, ex.Subject)\n\t}\n\tif !bytes.Equal(e.Text, ex.Text) {\n\t\tt.Fatalf(\"Incorrect text: %#q != %#q\", e.Text, ex.Text)\n\t}\n\tif !bytes.Equal(e.HTML, ex.HTML) {\n\t\tt.Fatalf(\"Incorrect HTML: %#q != %#q\", e.HTML, ex.HTML)\n\t}\n\tif e.From != ex.From {\n\t\tt.Fatalf(\"Incorrect \\\"From\\\": %#q != %#q\", e.From, ex.From)\n\t}\n}\n\nfunc TestAttachmentEmailFromReader(t *testing.T) {\n\tex := &Email{\n\t\tSubject: \"Test Subject\",\n\t\tTo:      []string{\"Jordan Wright <jmwright798@gmail.com>\"},\n\t\tFrom:    \"Jordan Wright <jmwright798@gmail.com>\",\n\t\tText:    []byte(\"Simple text body\"),\n\t\tHTML:    []byte(\"<div dir=\\\"ltr\\\">Simple HTML body</div>\\n\"),\n\t}\n\ta, err := ex.Attach(bytes.NewReader([]byte(\"Let's just pretend this is raw JPEG data.\")), \"cat.jpeg\", \"image/jpeg\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error attaching image %s\", err.Error())\n\t}\n\tb, err := ex.Attach(bytes.NewReader([]byte(\"Let's just pretend this is raw JPEG data.\")), \"cat-inline.jpeg\", \"image/jpeg\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error attaching inline image %s\", err.Error())\n\t}\n\traw := []byte(`\nFrom: Jordan Wright <jmwright798@gmail.com>\nDate: Thu, 17 Oct 2019 08:55:37 +0100\nMime-Version: 1.0\nContent-Type: multipart/mixed;\n boundary=35d10c2224bd787fe700c2c6f4769ddc936eb8a0b58e9c8717e406c5abb7\nTo: Jordan Wright <jmwright798@gmail.com>\nSubject: Test Subject\n\n--35d10c2224bd787fe700c2c6f4769ddc936eb8a0b58e9c8717e406c5abb7\nContent-Type: multipart/alternative;\n boundary=b10ca5b1072908cceb667e8968d3af04503b7ab07d61c9f579c15b416d7c\n\n--b10ca5b1072908cceb667e8968d3af04503b7ab07d61c9f579c15b416d7c\nContent-Transfer-Encoding: quoted-printable\nContent-Type: text/plain; charset=UTF-8\n\nSimple text body\n--b10ca5b1072908cceb667e8968d3af04503b7ab07d61c9f579c15b416d7c\nContent-Transfer-Encoding: quoted-printable\nContent-Type: text/html; charset=UTF-8\n\n<div dir=3D\"ltr\">Simple HTML body</div>\n\n--b10ca5b1072908cceb667e8968d3af04503b7ab07d61c9f579c15b416d7c--\n\n--35d10c2224bd787fe700c2c6f4769ddc936eb8a0b58e9c8717e406c5abb7\nContent-Disposition: attachment;\n filename=\"cat.jpeg\"\nContent-Id: <cat.jpeg>\nContent-Transfer-Encoding: base64\nContent-Type: image/jpeg\n\nTGV0J3MganVzdCBwcmV0ZW5kIHRoaXMgaXMgcmF3IEpQRUcgZGF0YS4=\n\n--35d10c2224bd787fe700c2c6f4769ddc936eb8a0b58e9c8717e406c5abb7\nContent-Disposition: inline;\n filename=\"cat-inline.jpeg\"\nContent-Id: <cat-inline.jpeg>\nContent-Transfer-Encoding: base64\nContent-Type: image/jpeg\n\nTGV0J3MganVzdCBwcmV0ZW5kIHRoaXMgaXMgcmF3IEpQRUcgZGF0YS4=\n\n--35d10c2224bd787fe700c2c6f4769ddc936eb8a0b58e9c8717e406c5abb7--`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error creating email %s\", err.Error())\n\t}\n\tif e.Subject != ex.Subject {\n\t\tt.Fatalf(\"Incorrect subject. %#q != %#q\", e.Subject, ex.Subject)\n\t}\n\tif !bytes.Equal(e.Text, ex.Text) {\n\t\tt.Fatalf(\"Incorrect text: %#q != %#q\", e.Text, ex.Text)\n\t}\n\tif !bytes.Equal(e.HTML, ex.HTML) {\n\t\tt.Fatalf(\"Incorrect HTML: %#q != %#q\", e.HTML, ex.HTML)\n\t}\n\tif e.From != ex.From {\n\t\tt.Fatalf(\"Incorrect \\\"From\\\": %#q != %#q\", e.From, ex.From)\n\t}\n\tif len(e.Attachments) != 2 {\n\t\tt.Fatalf(\"Incorrect number of attachments %d != %d\", len(e.Attachments), 1)\n\t}\n\tif e.Attachments[0].Filename != a.Filename {\n\t\tt.Fatalf(\"Incorrect attachment filename %s != %s\", e.Attachments[0].Filename, a.Filename)\n\t}\n\tif !bytes.Equal(e.Attachments[0].Content, a.Content) {\n\t\tt.Fatalf(\"Incorrect attachment content %#q != %#q\", e.Attachments[0].Content, a.Content)\n\t}\n\tif e.Attachments[1].Filename != b.Filename {\n\t\tt.Fatalf(\"Incorrect attachment filename %s != %s\", e.Attachments[1].Filename, b.Filename)\n\t}\n\tif !bytes.Equal(e.Attachments[1].Content, b.Content) {\n\t\tt.Fatalf(\"Incorrect attachment content %#q != %#q\", e.Attachments[1].Content, b.Content)\n\t}\n}\n\nfunc ExampleGmail() {\n\te := NewEmail()\n\te.From = \"Jordan Wright <test@gmail.com>\"\n\te.To = []string{\"test@example.com\"}\n\te.Bcc = []string{\"test_bcc@example.com\"}\n\te.Cc = []string{\"test_cc@example.com\"}\n\te.Subject = \"Awesome Subject\"\n\te.Text = []byte(\"Text Body is, of course, supported!\\n\")\n\te.HTML = []byte(\"<h1>Fancy Html is supported, too!</h1>\\n\")\n\te.Send(\"smtp.gmail.com:587\", smtp.PlainAuth(\"\", e.From, \"password123\", \"smtp.gmail.com\"))\n}\n\nfunc ExampleAttach() {\n\te := NewEmail()\n\te.AttachFile(\"test.txt\")\n}\n\nfunc Test_base64Wrap(t *testing.T) {\n\tfile := \"I'm a file long enough to force the function to wrap a\\n\" +\n\t\t\"couple of lines, but I stop short of the end of one line and\\n\" +\n\t\t\"have some padding dangling at the end.\"\n\tencoded := \"SSdtIGEgZmlsZSBsb25nIGVub3VnaCB0byBmb3JjZSB0aGUgZnVuY3Rpb24gdG8gd3JhcCBhCmNv\\r\\n\" +\n\t\t\"dXBsZSBvZiBsaW5lcywgYnV0IEkgc3RvcCBzaG9ydCBvZiB0aGUgZW5kIG9mIG9uZSBsaW5lIGFu\\r\\n\" +\n\t\t\"ZApoYXZlIHNvbWUgcGFkZGluZyBkYW5nbGluZyBhdCB0aGUgZW5kLg==\\r\\n\"\n\n\tvar buf bytes.Buffer\n\tbase64Wrap(&buf, []byte(file))\n\tif !bytes.Equal(buf.Bytes(), []byte(encoded)) {\n\t\tt.Fatalf(\"Encoded file does not match expected: %#q != %#q\", string(buf.Bytes()), encoded)\n\t}\n}\n\n// *Since the mime library in use by ```email``` is now in the stdlib, this test is deprecated\nfunc Test_quotedPrintEncode(t *testing.T) {\n\tvar buf bytes.Buffer\n\ttext := []byte(\"Dear reader!\\n\\n\" +\n\t\t\"This is a test email to try and capture some of the corner cases that exist within\\n\" +\n\t\t\"the quoted-printable encoding.\\n\" +\n\t\t\"There are some wacky parts like =, and this input assumes UNIX line breaks so\\r\\n\" +\n\t\t\"it can come out a little weird.  Also, we need to support unicode so here's a fish: üêü\\n\")\n\texpected := []byte(\"Dear reader!\\r\\n\\r\\n\" +\n\t\t\"This is a test email to try and capture some of the corner cases that exist=\\r\\n\" +\n\t\t\" within\\r\\n\" +\n\t\t\"the quoted-printable encoding.\\r\\n\" +\n\t\t\"There are some wacky parts like =3D, and this input assumes UNIX line break=\\r\\n\" +\n\t\t\"s so\\r\\n\" +\n\t\t\"it can come out a little weird.  Also, we need to support unicode so here's=\\r\\n\" +\n\t\t\" a fish: =F0=9F=90=9F\\r\\n\")\n\tqp := quotedprintable.NewWriter(&buf)\n\tif _, err := qp.Write(text); err != nil {\n\t\tt.Fatal(\"quotePrintEncode: \", err)\n\t}\n\tif err := qp.Close(); err != nil {\n\t\tt.Fatal(\"Error closing writer\", err)\n\t}\n\tif b := buf.Bytes(); !bytes.Equal(b, expected) {\n\t\tt.Errorf(\"quotedPrintEncode generated incorrect results: %#q != %#q\", b, expected)\n\t}\n}\n\nfunc TestMultipartNoContentType(t *testing.T) {\n\traw := []byte(`From: Mikhail Gusarov <dottedmag@dottedmag.net>\nTo: notmuch@notmuchmail.org\nReferences: <20091117190054.GU3165@dottiness.seas.harvard.edu>\nDate: Wed, 18 Nov 2009 01:02:38 +0600\nMessage-ID: <87iqd9rn3l.fsf@vertex.dottedmag>\nMIME-Version: 1.0\nSubject: Re: [notmuch] Working with Maildir storage?\nContent-Type: multipart/mixed; boundary=\"===============1958295626==\"\n\n--===============1958295626==\nContent-Type: multipart/signed; boundary=\"=-=-=\";\n    micalg=pgp-sha1; protocol=\"application/pgp-signature\"\n\n--=-=-=\nContent-Transfer-Encoding: quoted-printable\n\nTwas brillig at 14:00:54 17.11.2009 UTC-05 when lars@seas.harvard.edu did g=\nyre and gimble:\n\n--=-=-=\nContent-Type: application/pgp-signature\n\n-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1.4.9 (GNU/Linux)\n\niQIcBAEBAgAGBQJLAvNOAAoJEJ0g9lA+M4iIjLYQAKp0PXEgl3JMOEBisH52AsIK\n=/ksP\n-----END PGP SIGNATURE-----\n--=-=-=--\n\n--===============1958295626==\nContent-Type: text/plain; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: inline\n\nTesting!\n--===============1958295626==--\n`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error when parsing email %s\", err.Error())\n\t}\n\tif !bytes.Equal(e.Text, []byte(\"Testing!\")) {\n\t\tt.Fatalf(\"Error incorrect text: %#q != %#q\\n\", e.Text, \"Testing!\")\n\t}\n}\n\nfunc TestNoMultipartHTMLContentTypeBase64Encoding(t *testing.T) {\n\traw := []byte(`MIME-Version: 1.0\nFrom: no-reply@example.com\nTo: tester@example.org\nDate: 7 Jan 2021 03:07:44 -0800\nSubject: Hello\nContent-Type: text/html; charset=utf-8\nContent-Transfer-Encoding: base64\nMessage-Id: <20210107110744.547DD70532@example.com>\n\nPGh0bWw+PGhlYWQ+PHRpdGxlPnRlc3Q8L3RpdGxlPjwvaGVhZD48Ym9keT5IZWxsbyB3\nb3JsZCE8L2JvZHk+PC9odG1sPg==\n`)\n\te, err := NewEmailFromReader(bytes.NewReader(raw))\n\tif err != nil {\n\t\tt.Fatalf(\"Error when parsing email %s\", err.Error())\n\t}\n\tif !bytes.Equal(e.HTML, []byte(\"<html><head><title>test</title></head><body>Hello world!</body></html>\")) {\n\t\tt.Fatalf(\"Error incorrect text: %#q != %#q\\n\", e.Text, \"<html>...</html>\")\n\t}\n}\n\n// *Since the mime library in use by ```email``` is now in the stdlib, this test is deprecated\nfunc Test_quotedPrintDecode(t *testing.T) {\n\ttext := []byte(\"Dear reader!\\r\\n\\r\\n\" +\n\t\t\"This is a test email to try and capture some of the corner cases that exist=\\r\\n\" +\n\t\t\" within\\r\\n\" +\n\t\t\"the quoted-printable encoding.\\r\\n\" +\n\t\t\"There are some wacky parts like =3D, and this input assumes UNIX line break=\\r\\n\" +\n\t\t\"s so\\r\\n\" +\n\t\t\"it can come out a little weird.  Also, we need to support unicode so here's=\\r\\n\" +\n\t\t\" a fish: =F0=9F=90=9F\\r\\n\")\n\texpected := []byte(\"Dear reader!\\r\\n\\r\\n\" +\n\t\t\"This is a test email to try and capture some of the corner cases that exist within\\r\\n\" +\n\t\t\"the quoted-printable encoding.\\r\\n\" +\n\t\t\"There are some wacky parts like =, and this input assumes UNIX line breaks so\\r\\n\" +\n\t\t\"it can come out a little weird.  Also, we need to support unicode so here's a fish: üêü\\r\\n\")\n\tqp := quotedprintable.NewReader(bytes.NewReader(text))\n\tgot, err := ioutil.ReadAll(qp)\n\tif err != nil {\n\t\tt.Fatal(\"quotePrintDecode: \", err)\n\t}\n\n\tif !bytes.Equal(got, expected) {\n\t\tt.Errorf(\"quotedPrintDecode generated incorrect results: %#q != %#q\", got, expected)\n\t}\n}\n\nfunc Benchmark_base64Wrap(b *testing.B) {\n\t// Reasonable base case; 128K random bytes\n\tfile := make([]byte, 128*1024)\n\tif _, err := rand.Read(file); err != nil {\n\t\tpanic(err)\n\t}\n\tfor i := 0; i <= b.N; i++ {\n\t\tbase64Wrap(ioutil.Discard, file)\n\t}\n}\n\nfunc TestParseSender(t *testing.T) {\n\tvar cases = []struct {\n\t\te      Email\n\t\twant   string\n\t\thaserr bool\n\t}{\n\t\t{\n\t\t\tEmail{From: \"from@test.com\"},\n\t\t\t\"from@test.com\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tEmail{Sender: \"sender@test.com\", From: \"from@test.com\"},\n\t\t\t\"sender@test.com\",\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\tEmail{Sender: \"bad_address_sender\"},\n\t\t\t\"\",\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\tEmail{Sender: \"good@sender.com\", From: \"bad_address_from\"},\n\t\t\t\"good@sender.com\",\n\t\t\tfalse,\n\t\t},\n\t}\n\n\tfor i, testcase := range cases {\n\t\tgot, err := testcase.e.parseSender()\n\t\tif got != testcase.want || (err != nil) != testcase.haserr {\n\t\t\tt.Errorf(`%d: got %s != want %s or error \"%t\" != \"%t\"`, i+1, got, testcase.want, err != nil, testcase.haserr)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pool.go",
          "type": "blob",
          "size": 6.5908203125,
          "content": "package email\n\nimport (\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n\t\"net/mail\"\n\t\"net/smtp\"\n\t\"net/textproto\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype Pool struct {\n\taddr          string\n\tauth          smtp.Auth\n\tmax           int\n\tcreated       int\n\tclients       chan *client\n\trebuild       chan struct{}\n\tmut           *sync.Mutex\n\tlastBuildErr  *timestampedErr\n\tclosing       chan struct{}\n\ttlsConfig     *tls.Config\n\thelloHostname string\n}\n\ntype client struct {\n\t*smtp.Client\n\tfailCount int\n}\n\ntype timestampedErr struct {\n\terr error\n\tts  time.Time\n}\n\nconst maxFails = 4\n\nvar (\n\tErrClosed  = errors.New(\"pool closed\")\n\tErrTimeout = errors.New(\"timed out\")\n)\n\nfunc NewPool(address string, count int, auth smtp.Auth, opt_tlsConfig ...*tls.Config) (pool *Pool, err error) {\n\tpool = &Pool{\n\t\taddr:    address,\n\t\tauth:    auth,\n\t\tmax:     count,\n\t\tclients: make(chan *client, count),\n\t\trebuild: make(chan struct{}),\n\t\tclosing: make(chan struct{}),\n\t\tmut:     &sync.Mutex{},\n\t}\n\tif len(opt_tlsConfig) == 1 {\n\t\tpool.tlsConfig = opt_tlsConfig[0]\n\t} else if host, _, e := net.SplitHostPort(address); e != nil {\n\t\treturn nil, e\n\t} else {\n\t\tpool.tlsConfig = &tls.Config{ServerName: host}\n\t}\n\treturn\n}\n\n// go1.1 didn't have this method\nfunc (c *client) Close() error {\n\treturn c.Text.Close()\n}\n\n// SetHelloHostname optionally sets the hostname that the Go smtp.Client will\n// use when doing a HELLO with the upstream SMTP server. By default, Go uses\n// \"localhost\" which may not be accepted by certain SMTP servers that demand\n// an FQDN.\nfunc (p *Pool) SetHelloHostname(h string) {\n\tp.helloHostname = h\n}\n\nfunc (p *Pool) get(timeout time.Duration) *client {\n\tselect {\n\tcase c := <-p.clients:\n\t\treturn c\n\tdefault:\n\t}\n\n\tif p.created < p.max {\n\t\tp.makeOne()\n\t}\n\n\tvar deadline <-chan time.Time\n\tif timeout >= 0 {\n\t\tdeadline = time.After(timeout)\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase c := <-p.clients:\n\t\t\treturn c\n\t\tcase <-p.rebuild:\n\t\t\tp.makeOne()\n\t\tcase <-deadline:\n\t\t\treturn nil\n\t\tcase <-p.closing:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc shouldReuse(err error) bool {\n\t// certainly not perfect, but might be close:\n\t//  - EOF: clearly, the connection went down\n\t//  - textproto.Errors were valid SMTP over a valid connection,\n\t//    but resulted from an SMTP error response\n\t//  - textproto.ProtocolErrors result from connections going down,\n\t//    invalid SMTP, that sort of thing\n\t//  - syscall.Errno is probably down connection/bad pipe, but\n\t//    passed straight through by textproto instead of becoming a\n\t//    ProtocolError\n\t//  - if we don't recognize the error, don't reuse the connection\n\t// A false positive will probably fail on the Reset(), and even if\n\t// not will eventually hit maxFails.\n\t// A false negative will knock over (and trigger replacement of) a\n\t// conn that might have still worked.\n\tif err == io.EOF {\n\t\treturn false\n\t}\n\tswitch err.(type) {\n\tcase *textproto.Error:\n\t\treturn true\n\tcase *textproto.ProtocolError, textproto.ProtocolError:\n\t\treturn false\n\tcase syscall.Errno:\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc (p *Pool) replace(c *client) {\n\tp.clients <- c\n}\n\nfunc (p *Pool) inc() bool {\n\tif p.created >= p.max {\n\t\treturn false\n\t}\n\n\tp.mut.Lock()\n\tdefer p.mut.Unlock()\n\n\tif p.created >= p.max {\n\t\treturn false\n\t}\n\tp.created++\n\treturn true\n}\n\nfunc (p *Pool) dec() {\n\tp.mut.Lock()\n\tp.created--\n\tp.mut.Unlock()\n\n\tselect {\n\tcase p.rebuild <- struct{}{}:\n\tdefault:\n\t}\n}\n\nfunc (p *Pool) makeOne() {\n\tgo func() {\n\t\tif p.inc() {\n\t\t\tif c, err := p.build(); err == nil {\n\t\t\t\tp.clients <- c\n\t\t\t} else {\n\t\t\t\tp.lastBuildErr = &timestampedErr{err, time.Now()}\n\t\t\t\tp.dec()\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc startTLS(c *client, t *tls.Config) (bool, error) {\n\tif ok, _ := c.Extension(\"STARTTLS\"); !ok {\n\t\treturn false, nil\n\t}\n\n\tif err := c.StartTLS(t); err != nil {\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}\n\nfunc addAuth(c *client, auth smtp.Auth) (bool, error) {\n\tif ok, _ := c.Extension(\"AUTH\"); !ok {\n\t\treturn false, nil\n\t}\n\n\tif err := c.Auth(auth); err != nil {\n\t\treturn false, err\n\t}\n\n\treturn true, nil\n}\n\nfunc (p *Pool) build() (*client, error) {\n\tcl, err := smtp.Dial(p.addr)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Is there a custom hostname for doing a HELLO with the SMTP server?\n\tif p.helloHostname != \"\" {\n\t\tcl.Hello(p.helloHostname)\n\t}\n\n\tc := &client{cl, 0}\n\n\tif _, err := startTLS(c, p.tlsConfig); err != nil {\n\t\tc.Close()\n\t\treturn nil, err\n\t}\n\n\tif p.auth != nil {\n\t\tif _, err := addAuth(c, p.auth); err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn c, nil\n}\n\nfunc (p *Pool) maybeReplace(err error, c *client) {\n\tif err == nil {\n\t\tc.failCount = 0\n\t\tp.replace(c)\n\t\treturn\n\t}\n\n\tc.failCount++\n\tif c.failCount >= maxFails {\n\t\tgoto shutdown\n\t}\n\n\tif !shouldReuse(err) {\n\t\tgoto shutdown\n\t}\n\n\tif err := c.Reset(); err != nil {\n\t\tgoto shutdown\n\t}\n\n\tp.replace(c)\n\treturn\n\nshutdown:\n\tp.dec()\n\tc.Close()\n}\n\nfunc (p *Pool) failedToGet(startTime time.Time) error {\n\tselect {\n\tcase <-p.closing:\n\t\treturn ErrClosed\n\tdefault:\n\t}\n\n\tif p.lastBuildErr != nil && startTime.Before(p.lastBuildErr.ts) {\n\t\treturn p.lastBuildErr.err\n\t}\n\n\treturn ErrTimeout\n}\n\n// Send sends an email via a connection pulled from the Pool. The timeout may\n// be <0 to indicate no timeout. Otherwise reaching the timeout will produce\n// and error building a connection that occurred while we were waiting, or\n// otherwise ErrTimeout.\nfunc (p *Pool) Send(e *Email, timeout time.Duration) (err error) {\n\tstart := time.Now()\n\tc := p.get(timeout)\n\tif c == nil {\n\t\treturn p.failedToGet(start)\n\t}\n\n\tdefer func() {\n\t\tp.maybeReplace(err, c)\n\t}()\n\n\trecipients, err := addressLists(e.To, e.Cc, e.Bcc)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tmsg, err := e.Bytes()\n\tif err != nil {\n\t\treturn\n\t}\n\n\tfrom, err := emailOnly(e.From)\n\tif err != nil {\n\t\treturn\n\t}\n\tif err = c.Mail(from); err != nil {\n\t\treturn\n\t}\n\n\tfor _, recip := range recipients {\n\t\tif err = c.Rcpt(recip); err != nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\tw, err := c.Data()\n\tif err != nil {\n\t\treturn\n\t}\n\tif _, err = w.Write(msg); err != nil {\n\t\treturn\n\t}\n\n\terr = w.Close()\n\n\treturn\n}\n\nfunc emailOnly(full string) (string, error) {\n\taddr, err := mail.ParseAddress(full)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn addr.Address, nil\n}\n\nfunc addressLists(lists ...[]string) ([]string, error) {\n\tlength := 0\n\tfor _, lst := range lists {\n\t\tlength += len(lst)\n\t}\n\tcombined := make([]string, 0, length)\n\n\tfor _, lst := range lists {\n\t\tfor _, full := range lst {\n\t\t\taddr, err := emailOnly(full)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tcombined = append(combined, addr)\n\t\t}\n\t}\n\n\treturn combined, nil\n}\n\n// Close immediately changes the pool's state so no new connections will be\n// created, then gets and closes the existing ones as they become available.\nfunc (p *Pool) Close() {\n\tclose(p.closing)\n\n\tfor p.created > 0 {\n\t\tc := <-p.clients\n\t\tc.Quit()\n\t\tp.dec()\n\t}\n}\n"
        }
      ]
    }
  ]
}