{
  "metadata": {
    "timestamp": 1736566637781,
    "page": 194,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "AlecAivazis/survey",
      "stars": 4102,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 2.9208984375,
          "content": "# Contributing to Survey\n\nüéâüéâ First off, thanks for the interest in contributing to `survey`! üéâüéâ\n\nThe following is a set of guidelines to follow when contributing to this package. These are not hard rules, please use common sense and feel free to propose changes to this document in a pull request.\n\n## Code of Conduct\n\nThis project and its contibutors are expected to uphold the [Go Community Code of Conduct](https://golang.org/conduct). By participating, you are expected to follow these guidelines.\n\n## Getting help\n\n* [Open an issue](https://github.com/AlecAivazis/survey/issues/new/choose)\n* Reach out to `@AlecAivazis` or `@mislav` in the Gophers slack (please use only when urgent)\n\n## Submitting a contribution\n\nWhen submitting a contribution,\n\n- Try to make a series of smaller changes instead of one large change\n- Provide a description of each change that you are proposing\n- Reference the issue addressed by your pull request (if there is one)\n- Document all new exported Go APIs\n- Update the project's README when applicable\n- Include unit tests if possible\n- Contributions with visual ramifications or interaction changes should be accompanied with an integration test‚Äîsee below for details.\n\n## Writing and running tests\n\nWhen submitting features, please add as many units tests as necessary to test both positive and negative cases.\n\nIntegration tests for survey uses [go-expect](https://github.com/Netflix/go-expect) to expect a match on stdout and respond on stdin. Since `os.Stdout` in a `go test` process is not a TTY, you need a way to interpret terminal / ANSI escape sequences for things like `CursorLocation`. The stdin/stdout handled by `go-expect` is also multiplexed to a [virtual terminal](https://github.com/hinshun/vt10x).\n\nFor example, you can extend the tests for Input by specifying the following test case:\n\n```go\n{\n  \"Test Input prompt interaction\",       // Name of the test.\n  &Input{                                // An implementation of the survey.Prompt interface.\n    Message: \"What is your name?\",\n  },\n  func(c *expect.Console) {              // An expect procedure. You can expect strings / regexps and\n    c.ExpectString(\"What is your name?\") // write back strings / bytes to its psuedoterminal for survey.\n    c.SendLine(\"Johnny Appleseed\")\n    c.ExpectEOF()                        // Nothing is read from the tty without an expect, and once an\n                                         // expectation is met, no further bytes are read. End your\n                                         // procedure with `c.ExpectEOF()` to read until survey finishes.\n  },\n  \"Johnny Appleseed\",                    // The expected result.\n}\n```\n\nIf you want to write your own `go-expect` test from scratch, you'll need to instantiate a virtual terminal,\nmultiplex it into an `*expect.Console`, and hook up its tty with survey's optional stdio. Please see `go-expect`\n[documentation](https://godoc.org/github.com/Netflix/go-expect) for more detail.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0439453125,
          "content": "MIT License\n\nCopyright (c) 2018 Alec Aivazis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 17.1396484375,
          "content": "# Survey\n\n[![GoDoc](http://img.shields.io/badge/godoc-reference-5272B4.svg)](https://pkg.go.dev/github.com/AlecAivazis/survey/v2)\n\nA library for building interactive and accessible prompts on terminals supporting ANSI escape sequences.\n\n‚ö†Ô∏è This project is no longer maintained. For an alternative, please check out: https://github.com/charmbracelet/bubbletea ‚ö†Ô∏è\n\nHey everyone! I finally came to terms with the fact that I can no longer dedicate enough time to keep this library alive. \nThis project outgrew my wildest expectations and was such a great experience. If someone else wants to take over maintainence,\nplease reach out\n\n\n<img width=\"550\" src=\"https://thumbs.gfycat.com/VillainousGraciousKouprey-size_restricted.gif\"/>\n\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"github.com/AlecAivazis/survey/v2\"\n)\n\n// the questions to ask\nvar qs = []*survey.Question{\n    {\n        Name:     \"name\",\n        Prompt:   &survey.Input{Message: \"What is your name?\"},\n        Validate: survey.Required,\n        Transform: survey.Title,\n    },\n    {\n        Name: \"color\",\n        Prompt: &survey.Select{\n            Message: \"Choose a color:\",\n            Options: []string{\"red\", \"blue\", \"green\"},\n            Default: \"red\",\n        },\n    },\n    {\n        Name: \"age\",\n        Prompt:   &survey.Input{Message: \"How old are you?\"},\n    },\n}\n\nfunc main() {\n    // the answers will be written to this struct\n    answers := struct {\n        Name          string                  // survey will match the question and field names\n        FavoriteColor string `survey:\"color\"` // or you can tag fields to match a specific name\n        Age           int                     // if the types don't match, survey will convert it\n    }{}\n\n    // perform the questions\n    err := survey.Ask(qs, &answers)\n    if err != nil {\n        fmt.Println(err.Error())\n        return\n    }\n\n    fmt.Printf(\"%s chose %s.\", answers.Name, answers.FavoriteColor)\n}\n```\n\n## Examples\n\nExamples can be found in the `examples/` directory. Run them\nto see basic behavior:\n\n```bash\ngo run examples/simple.go\ngo run examples/validation.go\n```\n\n## Running the Prompts\n\nThere are two primary ways to execute prompts and start collecting information from your users: `Ask` and\n`AskOne`. The primary difference is whether you are interested in collecting a single piece of information\nor if you have a list of questions to ask whose answers should be collected in a single struct.\nFor most basic usecases, `Ask` should be enough. However, for surveys with complicated branching logic,\nwe recommend that you break out your questions into multiple calls to both of these functions to fit your needs.\n\n### Configuring the Prompts\n\nMost prompts take fine-grained configuration through fields on the structs you instantiate. It is also\npossible to change survey's default behaviors by passing `AskOpts` to either `Ask` or `AskOne`. Examples\nin this document will do both interchangeably:\n\n```golang\nprompt := &Select{\n    Message: \"Choose a color:\",\n    Options: []string{\"red\", \"blue\", \"green\"},\n    // can pass a validator directly\n    Validate: survey.Required,\n}\n\n// or define a default for the single call to `AskOne`\n// the answer will get written to the color variable\nsurvey.AskOne(prompt, &color, survey.WithValidator(survey.Required))\n\n// or define a default for every entry in a list of questions\n// the answer will get copied into the matching field of the struct as shown above\nsurvey.Ask(questions, &answers, survey.WithValidator(survey.Required))\n```\n\n## Prompts\n\n### Input\n\n<img src=\"https://thumbs.gfycat.com/LankyBlindAmericanpainthorse-size_restricted.gif\" width=\"400px\"/>\n\n```golang\nname := \"\"\nprompt := &survey.Input{\n    Message: \"ping\",\n}\nsurvey.AskOne(prompt, &name)\n```\n\n#### Suggestion Options\n\n<img src=\"https://i.imgur.com/Q7POpA1.gif\" width=\"800px\"/>\n\n```golang\nfile := \"\"\nprompt := &survey.Input{\n    Message: \"inform a file to save:\",\n    Suggest: func (toComplete string) []string {\n        files, _ := filepath.Glob(toComplete + \"*\")\n        return files\n    },\n}\n}\nsurvey.AskOne(prompt, &file)\n```\n\n### Multiline\n\n<img src=\"https://thumbs.gfycat.com/ImperfectShimmeringBeagle-size_restricted.gif\" width=\"400px\"/>\n\n```golang\ntext := \"\"\nprompt := &survey.Multiline{\n    Message: \"ping\",\n}\nsurvey.AskOne(prompt, &text)\n```\n\n### Password\n\n<img src=\"https://thumbs.gfycat.com/CompassionateSevereHypacrosaurus-size_restricted.gif\" width=\"400px\" />\n\n```golang\npassword := \"\"\nprompt := &survey.Password{\n    Message: \"Please type your password\",\n}\nsurvey.AskOne(prompt, &password)\n```\n\n### Confirm\n\n<img src=\"https://thumbs.gfycat.com/UnkemptCarefulGermanpinscher-size_restricted.gif\" width=\"400px\"/>\n\n```golang\nname := false\nprompt := &survey.Confirm{\n    Message: \"Do you like pie?\",\n}\nsurvey.AskOne(prompt, &name)\n```\n\n### Select\n\n<img src=\"https://thumbs.gfycat.com/GrimFilthyAmazonparrot-size_restricted.gif\" width=\"450px\"/>\n\n```golang\ncolor := \"\"\nprompt := &survey.Select{\n    Message: \"Choose a color:\",\n    Options: []string{\"red\", \"blue\", \"green\"},\n}\nsurvey.AskOne(prompt, &color)\n```\n\nFields and values that come from a `Select` prompt can be one of two different things. If you pass an `int`\nthe field will have the value of the selected index. If you instead pass a string, the string value selected\nwill be written to the field.\n\nThe user can also press `esc` to toggle the ability cycle through the options with the j and k keys to do down and up respectively.\n\nBy default, the select prompt is limited to showing 7 options at a time\nand will paginate lists of options longer than that. This can be changed a number of ways:\n\n```golang\n// as a field on a single select\nprompt := &survey.MultiSelect{..., PageSize: 10}\n\n// or as an option to Ask or AskOne\nsurvey.AskOne(prompt, &days, survey.WithPageSize(10))\n```\n\n#### Select options description\n\nThe optional description text can be used to add extra information to each option listed in the select prompt:\n\n```golang\ncolor := \"\"\nprompt := &survey.Select{\n    Message: \"Choose a color:\",\n    Options: []string{\"red\", \"blue\", \"green\"},\n    Description: func(value string, index int) string {\n        if value == \"red\" {\n            return \"My favorite color\"\n        }\n        return \"\"\n    },\n}\nsurvey.AskOne(prompt, &color)\n\n// Assuming that the user chose \"red - My favorite color\":\nfmt.Println(color) //=> \"red\"\n```\n\n### MultiSelect\n\n![Example](img/multi-select-all-none.gif)\n\n```golang\ndays := []string{}\nprompt := &survey.MultiSelect{\n    Message: \"What days do you prefer:\",\n    Options: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n}\nsurvey.AskOne(prompt, &days)\n```\n\nFields and values that come from a `MultiSelect` prompt can be one of two different things. If you pass an `int`\nthe field will have a slice of the selected indices. If you instead pass a string, a slice of the string values\nselected will be written to the field.\n\nThe user can also press `esc` to toggle the ability cycle through the options with the j and k keys to do down and up respectively.\n\nBy default, the MultiSelect prompt is limited to showing 7 options at a time\nand will paginate lists of options longer than that. This can be changed a number of ways:\n\n```golang\n// as a field on a single select\nprompt := &survey.MultiSelect{..., PageSize: 10}\n\n// or as an option to Ask or AskOne\nsurvey.AskOne(prompt, &days, survey.WithPageSize(10))\n```\n\n### Editor\n\nLaunches the user's preferred editor (defined by the \\$VISUAL or \\$EDITOR environment variables) on a\ntemporary file. Once the user exits their editor, the contents of the temporary file are read in as\nthe result. If neither of those are present, notepad (on Windows) or vim (Linux or Mac) is used.\n\nYou can also specify a [pattern](https://golang.org/pkg/io/ioutil/#TempFile) for the name of the temporary file. This\ncan be useful for ensuring syntax highlighting matches your usecase.\n\n```golang\nprompt := &survey.Editor{\n    Message: \"Shell code snippet\",\n    FileName: \"*.sh\",\n}\n\nsurvey.AskOne(prompt, &content)\n```\n\n## Filtering Options\n\nBy default, the user can filter for options in Select and MultiSelects by typing while the prompt\nis active. This will filter out all options that don't contain the typed string anywhere in their name, ignoring case.\n\nA custom filter function can also be provided to change this behavior:\n\n```golang\nfunc myFilter(filterValue string, optValue string, optIndex int) bool {\n    // only include the option if it includes the filter and has length greater than 5\n    return strings.Contains(optValue, filterValue) && len(optValue) >= 5\n}\n\n// configure it for a specific prompt\n&Select{\n    Message: \"Choose a color:\",\n    Options: []string{\"red\", \"blue\", \"green\"},\n    Filter: myFilter,\n}\n\n// or define a default for all of the questions\nsurvey.AskOne(prompt, &color, survey.WithFilter(myFilter))\n```\n\n## Keeping the filter active\n\nBy default the filter will disappear if the user selects one of the filtered elements. Once the user selects one element the filter setting is gone.\n\nHowever the user can prevent this from happening and keep the filter active for multiple selections in a e.g. MultiSelect:\n\n```golang\n// configure it for a specific prompt\n&Select{\n    Message:    \"Choose a color:\",\n    Options:    []string{\"light-green\", \"green\", \"dark-green\", \"red\"},\n    KeepFilter: true,\n}\n\n// or define a default for all of the questions\nsurvey.AskOne(prompt, &color, survey.WithKeepFilter(true))\n```\n\n## Validation\n\nValidating individual responses for a particular question can be done by defining a\n`Validate` field on the `survey.Question` to be validated. This function takes an\n`interface{}` type and returns an error to show to the user, prompting them for another\nresponse. Like usual, validators can be provided directly to the prompt or with `survey.WithValidator`:\n\n```golang\nq := &survey.Question{\n    Prompt: &survey.Input{Message: \"Hello world validation\"},\n    Validate: func (val interface{}) error {\n        // since we are validating an Input, the assertion will always succeed\n        if str, ok := val.(string) ; !ok || len(str) > 10 {\n            return errors.New(\"This response cannot be longer than 10 characters.\")\n        }\n\treturn nil\n    },\n}\n\ncolor := \"\"\nprompt := &survey.Input{ Message: \"Whats your name?\" }\n\n// you can pass multiple validators here and survey will make sure each one passes\nsurvey.AskOne(prompt, &color, survey.WithValidator(survey.Required))\n```\n\n### Built-in Validators\n\n`survey` comes prepackaged with a few validators to fit common situations. Currently these\nvalidators include:\n\n| name         | valid types    | description                                                      | notes                                                                                 |\n| ------------ | -------------- | ---------------------------------------------------------------- | ------------------------------------------------------------------------------------- |\n| Required     | any            | Rejects zero values of the response type                         | Boolean values pass straight through since the zero value (false) is a valid response |\n| MinLength(n) | string         | Enforces that a response is at least the given length            |                                                                                       |\n| MaxLength(n) | string         | Enforces that a response is no longer than the given length      |                                                                                       |\n| MaxItems(n)  | []OptionAnswer | Enforces that a response has no more selections of the indicated |                                                                                       |\n| MinItems(n)  | []OptionAnswer | Enforces that a response has no less selections of the indicated |                                                                                       |\n\n## Help Text\n\nAll of the prompts have a `Help` field which can be defined to provide more information to your users:\n\n<img src=\"https://thumbs.gfycat.com/CloudyRemorsefulFossa-size_restricted.gif\" width=\"400px\" style=\"margin-top: 8px\"/>\n\n```golang\n&survey.Input{\n    Message: \"What is your phone number:\",\n    Help:    \"Phone number should include the area code\",\n}\n```\n\n## Removing the \"Select All\" and \"Select None\" options\n\nBy default, users can select all of the multi-select options using the right arrow key. To prevent users from being able to do this (and remove the `<right> to all` message from the prompt), use the option `WithRemoveSelectAll`:\n\n```golang\nimport (\n    \"github.com/AlecAivazis/survey/v2\"\n)\n\nnumber := \"\"\nprompt := &survey.Input{\n    Message: \"This question has the select all option removed\",\n}\n\nsurvey.AskOne(prompt, &number, survey.WithRemoveSelectAll())\n```\n\nAlso by default, users can use the left arrow key to unselect all of the options. To prevent users from being able to do this (and remove the `<left> to none` message from the prompt), use the option `WithRemoveSelectNone`:\n\n```golang\nimport (\n    \"github.com/AlecAivazis/survey/v2\"\n)\n\nnumber := \"\"\nprompt := &survey.Input{\n    Message: \"This question has the select all option removed\",\n}\n\nsurvey.AskOne(prompt, &number, survey.WithRemoveSelectNone())\n```\n\n\n### Changing the input rune\n\nIn some situations, `?` is a perfectly valid response. To handle this, you can change the rune that survey\nlooks for with `WithHelpInput`:\n\n```golang\nimport (\n    \"github.com/AlecAivazis/survey/v2\"\n)\n\nnumber := \"\"\nprompt := &survey.Input{\n    Message: \"If you have this need, please give me a reasonable message.\",\n    Help:    \"I couldn't come up with one.\",\n}\n\nsurvey.AskOne(prompt, &number, survey.WithHelpInput('^'))\n```\n\n## Changing the Icons\n\nChanging the icons and their color/format can be done by passing the `WithIcons` option. The format\nfollows the patterns outlined [here](https://github.com/mgutz/ansi#style-format). For example:\n\n```golang\nimport (\n    \"github.com/AlecAivazis/survey/v2\"\n)\n\nnumber := \"\"\nprompt := &survey.Input{\n    Message: \"If you have this need, please give me a reasonable message.\",\n    Help:    \"I couldn't come up with one.\",\n}\n\nsurvey.AskOne(prompt, &number, survey.WithIcons(func(icons *survey.IconSet) {\n    // you can set any icons\n    icons.Question.Text = \"‚Åá\"\n    // for more information on formatting the icons, see here: https://github.com/mgutz/ansi#style-format\n    icons.Question.Format = \"yellow+hb\"\n}))\n```\n\nThe icons and their default text and format are summarized below:\n\n| name           | text | format     | description                                                   |\n| -------------- | ---- | ---------- | ------------------------------------------------------------- |\n| Error          | X    | red        | Before an error                                               |\n| Help           | i    | cyan       | Before help text                                              |\n| Question       | ?    | green+hb   | Before the message of a prompt                                |\n| SelectFocus    | >    | green      | Marks the current focus in `Select` and `MultiSelect` prompts |\n| UnmarkedOption | [ ]  | default+hb | Marks an unselected option in a `MultiSelect` prompt          |\n| MarkedOption   | [x]  | cyan+b     | Marks a chosen selection in a `MultiSelect` prompt            |\n\n## Custom Types\n\nsurvey will assign prompt answers to your custom types if they implement this interface:\n\n```golang\ntype Settable interface {\n    WriteAnswer(field string, value interface{}) error\n}\n```\n\nHere is an example how to use them:\n\n```golang\ntype MyValue struct {\n    value string\n}\nfunc (my *MyValue) WriteAnswer(name string, value interface{}) error {\n     my.value = value.(string)\n}\n\nmyval := MyValue{}\nsurvey.AskOne(\n    &survey.Input{\n        Message: \"Enter something:\",\n    },\n    &myval\n)\n```\n\n## Testing\n\nYou can test your program's interactive prompts using [go-expect](https://github.com/Netflix/go-expect). The library\ncan be used to expect a match on stdout and respond on stdin. Since `os.Stdout` in a `go test` process is not a TTY,\nif you are manipulating the cursor or using `survey`, you will need a way to interpret terminal / ANSI escape sequences\nfor things like `CursorLocation`. `vt10x.NewVT10XConsole` will create a `go-expect` console that also multiplexes\nstdio to an in-memory [virtual terminal](https://github.com/hinshun/vt10x).\n\nFor some examples, you can see any of the tests in this repo.\n\n## FAQ\n\n### What kinds of IO are supported by `survey`?\n\nsurvey aims to support most terminal emulators; it expects support for ANSI escape sequences.\nThis means that reading from piped stdin or writing to piped stdout is **not supported**,\nand likely to break your application in these situations. See [#337](https://github.com/AlecAivazis/survey/pull/337#issue-581351617)\n\n### Why isn't Ctrl-C working?\n\nOrdinarily, when you type Ctrl-C, the terminal recognizes this as the QUIT button and delivers a SIGINT signal to the process, which terminates it.\nHowever, Survey temporarily configures the terminal to deliver control codes as ordinary input bytes.\nWhen Survey reads a ^C byte (ASCII \\x03, \"end of text\"), it interrupts the current survey and returns a\n`github.com/AlecAivazis/survey/v2/terminal.InterruptErr` from `Ask` or `AskOne`.\nIf you want to stop the process, handle the returned error in your code:\n\n```go\nerr := survey.AskOne(prompt, &myVar)\nif err != nil {\n\tif err == terminal.InterruptErr {\n\t\tlog.Fatal(\"interrupted\")\n\t}\n\t...\n}\n```\n"
        },
        {
          "name": "confirm.go",
          "type": "blob",
          "size": 3.6171875,
          "content": "package survey\n\nimport (\n\t\"fmt\"\n\t\"regexp\"\n)\n\n// Confirm is a regular text input that accept yes/no answers. Response type is a bool.\ntype Confirm struct {\n\tRenderer\n\tMessage string\n\tDefault bool\n\tHelp    string\n}\n\n// data available to the templates when processing\ntype ConfirmTemplateData struct {\n\tConfirm\n\tAnswer   string\n\tShowHelp bool\n\tConfig   *PromptConfig\n}\n\n// Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format\nvar ConfirmQuestionTemplate = `\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }} {{color \"reset\"}}\n{{- if .Answer}}\n  {{- color \"cyan\"}}{{.Answer}}{{color \"reset\"}}{{\"\\n\"}}\n{{- else }}\n  {{- if and .Help (not .ShowHelp)}}{{color \"cyan\"}}[{{ .Config.HelpInput }} for help]{{color \"reset\"}} {{end}}\n  {{- color \"white\"}}{{if .Default}}(Y/n) {{else}}(y/N) {{end}}{{color \"reset\"}}\n{{- end}}`\n\n// the regex for answers\nvar (\n\tyesRx = regexp.MustCompile(\"^(?i:y(?:es)?)$\")\n\tnoRx  = regexp.MustCompile(\"^(?i:n(?:o)?)$\")\n)\n\nfunc yesNo(t bool) string {\n\tif t {\n\t\treturn \"Yes\"\n\t}\n\treturn \"No\"\n}\n\nfunc (c *Confirm) getBool(showHelp bool, config *PromptConfig) (bool, error) {\n\tcursor := c.NewCursor()\n\trr := c.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\n\t// start waiting for input\n\tfor {\n\t\tline, err := rr.ReadLine(0)\n\t\tif err != nil {\n\t\t\treturn false, err\n\t\t}\n\t\t// move back up a line to compensate for the \\n echoed from terminal\n\t\tcursor.PreviousLine(1)\n\t\tval := string(line)\n\n\t\t// get the answer that matches the\n\t\tvar answer bool\n\t\tswitch {\n\t\tcase yesRx.Match([]byte(val)):\n\t\t\tanswer = true\n\t\tcase noRx.Match([]byte(val)):\n\t\t\tanswer = false\n\t\tcase val == \"\":\n\t\t\tanswer = c.Default\n\t\tcase val == config.HelpInput && c.Help != \"\":\n\t\t\terr := c.Render(\n\t\t\t\tConfirmQuestionTemplate,\n\t\t\t\tConfirmTemplateData{\n\t\t\t\t\tConfirm:  *c,\n\t\t\t\t\tShowHelp: true,\n\t\t\t\t\tConfig:   config,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\t// use the default value and bubble up\n\t\t\t\treturn c.Default, err\n\t\t\t}\n\t\t\tshowHelp = true\n\t\t\tcontinue\n\t\tdefault:\n\t\t\t// we didnt get a valid answer, so print error and prompt again\n\t\t\t//lint:ignore ST1005 it should be fine for this error message to have punctuation\n\t\t\tif err := c.Error(config, fmt.Errorf(\"%q is not a valid answer, please try again.\", val)); err != nil {\n\t\t\t\treturn c.Default, err\n\t\t\t}\n\t\t\terr := c.Render(\n\t\t\t\tConfirmQuestionTemplate,\n\t\t\t\tConfirmTemplateData{\n\t\t\t\t\tConfirm:  *c,\n\t\t\t\t\tShowHelp: showHelp,\n\t\t\t\t\tConfig:   config,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\t// use the default value and bubble up\n\t\t\t\treturn c.Default, err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\treturn answer, nil\n\t}\n}\n\n/*\nPrompt prompts the user with a simple text field and expects a reply followed\nby a carriage return.\n\n\tlikesPie := false\n\tprompt := &survey.Confirm{ Message: \"What is your name?\" }\n\tsurvey.AskOne(prompt, &likesPie)\n*/\nfunc (c *Confirm) Prompt(config *PromptConfig) (interface{}, error) {\n\t// render the question template\n\terr := c.Render(\n\t\tConfirmQuestionTemplate,\n\t\tConfirmTemplateData{\n\t\t\tConfirm: *c,\n\t\t\tConfig:  config,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// get input and return\n\treturn c.getBool(false, config)\n}\n\n// Cleanup overwrite the line with the finalized formatted version\nfunc (c *Confirm) Cleanup(config *PromptConfig, val interface{}) error {\n\t// if the value was previously true\n\tans := yesNo(val.(bool))\n\n\t// render the template\n\treturn c.Render(\n\t\tConfirmQuestionTemplate,\n\t\tConfirmTemplateData{\n\t\t\tConfirm: *c,\n\t\t\tAnswer:  ans,\n\t\t\tConfig:  config,\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "confirm_test.go",
          "type": "blob",
          "size": 3.70703125,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestConfirmRender(t *testing.T) {\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   Confirm\n\t\tdata     ConfirmTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"Test Confirm question output with default true\",\n\t\t\tConfirm{Message: \"Is pizza your favorite food?\", Default: true},\n\t\t\tConfirmTemplateData{},\n\t\t\tfmt.Sprintf(\"%s Is pizza your favorite food? (Y/n) \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm question output with default false\",\n\t\t\tConfirm{Message: \"Is pizza your favorite food?\", Default: false},\n\t\t\tConfirmTemplateData{},\n\t\t\tfmt.Sprintf(\"%s Is pizza your favorite food? (y/N) \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm answer output\",\n\t\t\tConfirm{Message: \"Is pizza your favorite food?\"},\n\t\t\tConfirmTemplateData{Answer: \"Yes\"},\n\t\t\tfmt.Sprintf(\"%s Is pizza your favorite food? Yes\\n\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm with help but help message is hidden\",\n\t\t\tConfirm{Message: \"Is pizza your favorite food?\", Help: \"This is helpful\"},\n\t\t\tConfirmTemplateData{},\n\t\t\tfmt.Sprintf(\"%s Is pizza your favorite food? [%s for help] (y/N) \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm help output with help message shown\",\n\t\t\tConfirm{Message: \"Is pizza your favorite food?\", Help: \"This is helpful\"},\n\t\t\tConfirmTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s Is pizza your favorite food? (y/N) \", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.title, func(t *testing.T) {\n\t\t\tr, w, err := os.Pipe()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.prompt.WithStdio(terminal.Stdio{Out: w})\n\t\t\ttest.data.Confirm = test.prompt\n\n\t\t\t// set the runtime config\n\t\t\ttest.data.Config = defaultPromptConfig()\n\n\t\t\terr = test.prompt.Render(\n\t\t\t\tConfirmQuestionTemplate,\n\t\t\t\ttest.data,\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, w.Close())\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = io.Copy(&buf, r)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Contains(t, buf.String(), test.expected)\n\t\t})\n\t}\n}\n\nfunc TestConfirmPrompt(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"Test Confirm prompt interaction\",\n\t\t\t&Confirm{\n\t\t\t\tMessage: \"Is pizza your favorite food?\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Is pizza your favorite food? (y/N)\")\n\t\t\t\tc.SendLine(\"n\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm prompt interaction with default\",\n\t\t\t&Confirm{\n\t\t\t\tMessage: \"Is pizza your favorite food?\",\n\t\t\t\tDefault: true,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Is pizza your favorite food? (Y/n)\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm prompt interaction overriding default\",\n\t\t\t&Confirm{\n\t\t\t\tMessage: \"Is pizza your favorite food?\",\n\t\t\t\tDefault: true,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Is pizza your favorite food? (Y/n)\")\n\t\t\t\tc.SendLine(\"n\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tfalse,\n\t\t},\n\t\t{\n\t\t\t\"Test Confirm prompt interaction and prompt for help\",\n\t\t\t&Confirm{\n\t\t\t\tMessage: \"Is pizza your favorite food?\",\n\t\t\t\tHelp:    \"It probably is\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\n\t\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\t\"Is pizza your favorite food? [%s for help] (y/N)\",\n\t\t\t\t\t\tstring(defaultPromptConfig().HelpInput),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\tc.SendLine(\"?\")\n\t\t\t\tc.ExpectString(\"It probably is\")\n\t\t\t\tc.SendLine(\"Y\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\ttrue,\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "core",
          "type": "tree",
          "content": null
        },
        {
          "name": "editor.go",
          "type": "blob",
          "size": 5.240234375,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"runtime\"\n\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\tshellquote \"github.com/kballard/go-shellquote\"\n)\n\n/*\nEditor launches an instance of the users preferred editor on a temporary file.\nThe editor to use is determined by reading the $VISUAL or $EDITOR environment\nvariables. If neither of those are present, notepad (on Windows) or vim\n(others) is used.\nThe launch of the editor is triggered by the enter key. Since the response may\nbe long, it will not be echoed as Input does, instead, it print <Received>.\nResponse type is a string.\n\n\tmessage := \"\"\n\tprompt := &survey.Editor{ Message: \"What is your commit message?\" }\n\tsurvey.AskOne(prompt, &message)\n*/\ntype Editor struct {\n\tRenderer\n\tMessage       string\n\tDefault       string\n\tHelp          string\n\tEditor        string\n\tHideDefault   bool\n\tAppendDefault bool\n\tFileName      string\n}\n\n// data available to the templates when processing\ntype EditorTemplateData struct {\n\tEditor\n\tAnswer     string\n\tShowAnswer bool\n\tShowHelp   bool\n\tConfig     *PromptConfig\n}\n\n// Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format\nvar EditorQuestionTemplate = `\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }} {{color \"reset\"}}\n{{- if .ShowAnswer}}\n  {{- color \"cyan\"}}{{.Answer}}{{color \"reset\"}}{{\"\\n\"}}\n{{- else }}\n  {{- if and .Help (not .ShowHelp)}}{{color \"cyan\"}}[{{ .Config.HelpInput }} for help]{{color \"reset\"}} {{end}}\n  {{- if and .Default (not .HideDefault)}}{{color \"white\"}}({{.Default}}) {{color \"reset\"}}{{end}}\n  {{- color \"cyan\"}}[Enter to launch editor] {{color \"reset\"}}\n{{- end}}`\n\nvar (\n\tbom    = []byte{0xef, 0xbb, 0xbf}\n\teditor = \"vim\"\n)\n\nfunc init() {\n\tif runtime.GOOS == \"windows\" {\n\t\teditor = \"notepad\"\n\t}\n\tif v := os.Getenv(\"VISUAL\"); v != \"\" {\n\t\teditor = v\n\t} else if e := os.Getenv(\"EDITOR\"); e != \"\" {\n\t\teditor = e\n\t}\n}\n\nfunc (e *Editor) PromptAgain(config *PromptConfig, invalid interface{}, err error) (interface{}, error) {\n\tinitialValue := invalid.(string)\n\treturn e.prompt(initialValue, config)\n}\n\nfunc (e *Editor) Prompt(config *PromptConfig) (interface{}, error) {\n\tinitialValue := \"\"\n\tif e.Default != \"\" && e.AppendDefault {\n\t\tinitialValue = e.Default\n\t}\n\treturn e.prompt(initialValue, config)\n}\n\nfunc (e *Editor) prompt(initialValue string, config *PromptConfig) (interface{}, error) {\n\t// render the template\n\terr := e.Render(\n\t\tEditorQuestionTemplate,\n\t\tEditorTemplateData{\n\t\t\tEditor: *e,\n\t\t\tConfig: config,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// start reading runes from the standard in\n\trr := e.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\n\tcursor := e.NewCursor()\n\tcursor.Hide()\n\tdefer cursor.Show()\n\n\tfor {\n\t\tr, _, err := rr.ReadRune()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif r == '\\r' || r == '\\n' {\n\t\t\tbreak\n\t\t}\n\t\tif r == terminal.KeyInterrupt {\n\t\t\treturn \"\", terminal.InterruptErr\n\t\t}\n\t\tif r == terminal.KeyEndTransmission {\n\t\t\tbreak\n\t\t}\n\t\tif string(r) == config.HelpInput && e.Help != \"\" {\n\t\t\terr = e.Render(\n\t\t\t\tEditorQuestionTemplate,\n\t\t\t\tEditorTemplateData{\n\t\t\t\t\tEditor:   *e,\n\t\t\t\t\tShowHelp: true,\n\t\t\t\t\tConfig:   config,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t}\n\t\tcontinue\n\t}\n\n\t// prepare the temp file\n\tpattern := e.FileName\n\tif pattern == \"\" {\n\t\tpattern = \"survey*.txt\"\n\t}\n\tf, err := ioutil.TempFile(\"\", pattern)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tdefer func() {\n\t\t_ = os.Remove(f.Name())\n\t}()\n\n\t// write utf8 BOM header\n\t// The reason why we do this is because notepad.exe on Windows determines the\n\t// encoding of an \"empty\" text file by the locale, for example, GBK in China,\n\t// while golang string only handles utf8 well. However, a text file with utf8\n\t// BOM header is not considered \"empty\" on Windows, and the encoding will then\n\t// be determined utf8 by notepad.exe, instead of GBK or other encodings.\n\tif _, err := f.Write(bom); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// write initial value\n\tif _, err := f.WriteString(initialValue); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// close the fd to prevent the editor unable to save file\n\tif err := f.Close(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// check is input editor exist\n\tif e.Editor != \"\" {\n\t\teditor = e.Editor\n\t}\n\n\tstdio := e.Stdio()\n\n\targs, err := shellquote.Split(editor)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\targs = append(args, f.Name())\n\n\t// open the editor\n\tcmd := exec.Command(args[0], args[1:]...)\n\tcmd.Stdin = stdio.In\n\tcmd.Stdout = stdio.Out\n\tcmd.Stderr = stdio.Err\n\tcursor.Show()\n\tif err := cmd.Run(); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// raw is a BOM-unstripped UTF8 byte slice\n\traw, err := ioutil.ReadFile(f.Name())\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// strip BOM header\n\ttext := string(bytes.TrimPrefix(raw, bom))\n\n\t// check length, return default value on empty\n\tif len(text) == 0 && !e.AppendDefault {\n\t\treturn e.Default, nil\n\t}\n\n\treturn text, nil\n}\n\nfunc (e *Editor) Cleanup(config *PromptConfig, val interface{}) error {\n\treturn e.Render(\n\t\tEditorQuestionTemplate,\n\t\tEditorTemplateData{\n\t\t\tEditor:     *e,\n\t\t\tAnswer:     \"<Received>\",\n\t\t\tShowAnswer: true,\n\t\t\tConfig:     config,\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "editor_test.go",
          "type": "blob",
          "size": 6.744140625,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"os/exec\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestEditorRender(t *testing.T) {\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   Editor\n\t\tdata     EditorTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"Test Editor question output without default\",\n\t\t\tEditor{Message: \"What is your favorite month:\"},\n\t\t\tEditorTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [Enter to launch editor] \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor question output with default\",\n\t\t\tEditor{Message: \"What is your favorite month:\", Default: \"April\"},\n\t\t\tEditorTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: (April) [Enter to launch editor] \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor question output with HideDefault\",\n\t\t\tEditor{Message: \"What is your favorite month:\", Default: \"April\", HideDefault: true},\n\t\t\tEditorTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [Enter to launch editor] \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor answer output\",\n\t\t\tEditor{Message: \"What is your favorite month:\"},\n\t\t\tEditorTemplateData{Answer: \"October\", ShowAnswer: true},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: October\\n\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor question output without default but with help hidden\",\n\t\t\tEditor{Message: \"What is your favorite month:\", Help: \"This is helpful\"},\n\t\t\tEditorTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for help] [Enter to launch editor] \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor question output with default and with help hidden\",\n\t\t\tEditor{Message: \"What is your favorite month:\", Default: \"April\", Help: \"This is helpful\"},\n\t\t\tEditorTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for help] (April) [Enter to launch editor] \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor question output without default but with help shown\",\n\t\t\tEditor{Message: \"What is your favorite month:\", Help: \"This is helpful\"},\n\t\t\tEditorTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s What is your favorite month: [Enter to launch editor] \", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Editor question output with default and with help shown\",\n\t\t\tEditor{Message: \"What is your favorite month:\", Default: \"April\", Help: \"This is helpful\"},\n\t\t\tEditorTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s What is your favorite month: (April) [Enter to launch editor] \", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.title, func(t *testing.T) {\n\t\t\tr, w, err := os.Pipe()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.prompt.WithStdio(terminal.Stdio{Out: w})\n\t\t\ttest.data.Editor = test.prompt\n\n\t\t\t// set the icon set\n\t\t\ttest.data.Config = defaultPromptConfig()\n\n\t\t\terr = test.prompt.Render(\n\t\t\t\tEditorQuestionTemplate,\n\t\t\t\ttest.data,\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, w.Close())\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = io.Copy(&buf, r)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Contains(t, buf.String(), test.expected)\n\t\t})\n\t}\n}\n\nfunc TestEditorPrompt(t *testing.T) {\n\tif _, err := exec.LookPath(\"vi\"); err != nil {\n\t\tt.Skip(\"warning: vi not found in PATH\")\n\t}\n\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"Test Editor prompt interaction\",\n\t\t\t&Editor{\n\t\t\t\tEditor:  \"vi\",\n\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Edit git commit message [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.Send(\"ccAdd editor prompt tests\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Add editor prompt tests\\n\",\n\t\t},\n\t\t{\n\t\t\t\"Test Editor prompt interaction with default\",\n\t\t\t&Editor{\n\t\t\t\tEditor:  \"vi\",\n\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t\tDefault: \"No comment\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Edit git commit message (No comment) [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.SendLine(\":q!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"No comment\",\n\t\t},\n\t\t{\n\t\t\t\"Test Editor prompt interaction overriding default\",\n\t\t\t&Editor{\n\t\t\t\tEditor:  \"vi\",\n\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t\tDefault: \"No comment\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Edit git commit message (No comment) [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.Send(\"ccAdd editor prompt tests\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Add editor prompt tests\\n\",\n\t\t},\n\t\t{\n\t\t\t\"Test Editor prompt interaction hiding default\",\n\t\t\t&Editor{\n\t\t\t\tEditor:      \"vi\",\n\t\t\t\tMessage:     \"Edit git commit message\",\n\t\t\t\tDefault:     \"No comment\",\n\t\t\t\tHideDefault: true,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Edit git commit message [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.SendLine(\":q!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"No comment\",\n\t\t},\n\t\t{\n\t\t\t\"Test Editor prompt interaction and prompt for help\",\n\t\t\t&Editor{\n\t\t\t\tEditor:  \"vi\",\n\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t\tHelp:    \"Describe your git commit\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\n\t\t\t\t\tfmt.Sprintf(\n\t\t\t\t\t\t\"Edit git commit message [%s for help] [Enter to launch editor]\",\n\t\t\t\t\t\tstring(defaultPromptConfig().HelpInput),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\tc.SendLine(\"?\")\n\t\t\t\tc.ExpectString(\"Describe your git commit\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.Send(\"ccAdd editor prompt tests\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Add editor prompt tests\\n\",\n\t\t},\n\t\t{\n\t\t\t\"Test Editor prompt interaction with default and append default\",\n\t\t\t&Editor{\n\t\t\t\tEditor:        \"vi\",\n\t\t\t\tMessage:       \"Edit git commit message\",\n\t\t\t\tDefault:       \"No comment\",\n\t\t\t\tAppendDefault: true,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Edit git commit message (No comment) [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectString(\"No comment\")\n\t\t\t\tc.SendLine(\"dd\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"Test Editor prompt interaction with editor args\",\n\t\t\t&Editor{\n\t\t\t\tEditor:  \"vi --\",\n\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Edit git commit message [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.Send(\"ccAdd editor prompt tests\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Add editor prompt tests\\n\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "filter.go",
          "type": "blob",
          "size": 0.0146484375,
          "content": "package survey\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.5810546875,
          "content": "module github.com/AlecAivazis/survey/v2\n\nrequire (\n\tgithub.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2\n\tgithub.com/creack/pty v1.1.17\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec\n\tgithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51\n\tgithub.com/mattn/go-colorable v0.1.2 // indirect\n\tgithub.com/mattn/go-isatty v0.0.8\n\tgithub.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b\n\tgithub.com/stretchr/testify v1.6.1\n\tgolang.org/x/term v0.0.0-20210927222741-03fcf44c2211\n\tgolang.org/x/text v0.4.0\n)\n\ngo 1.13\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.2314453125,
          "content": "github.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2 h1:+vx7roKuyA63nhn5WAunQHLTznkw5W8b1Xc0dNjp83s=\ngithub.com/Netflix/go-expect v0.0.0-20220104043353-73e0943537d2/go.mod h1:HBCaDeC1lPdgDeDbhX8XFpy1jqjK0IBG8W5K+xYqA0w=\ngithub.com/creack/pty v1.1.17 h1:QeVUsEDNrLBW4tMgZHvxy18sKtr6VI492kBhUfhDJNI=\ngithub.com/creack/pty v1.1.17/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec h1:qv2VnGeEQHchGaZ/u7lxST/RaJw+cv273q79D81Xbog=\ngithub.com/hinshun/vt10x v0.0.0-20220119200601-820417d04eec/go.mod h1:Q48J4R4DvxnHolD5P8pOtXigYlRuPLGl6moFx3ulM68=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\ngithub.com/mattn/go-colorable v0.1.2 h1:/bC9yWikZXAL9uJdulbSfyVNIR3n3trXl+v8+1sx8mU=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-isatty v0.0.8 h1:HLtExJ+uU2HOZ+wI0Tt5DtUDrx8yhUqDcp7fYERX4CE=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b h1:j7+1HpAFS1zy5+Q4qx1fWh90gTKwiN4QCGoY9TWyyO4=\ngithub.com/mgutz/ansi v0.0.0-20170206155736-9520e82c474b/go.mod h1:01TrycV0kFyexm33Z7vhZRXopbI8J3TDReVlkTgMUxE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f h1:v4INt8xihDGvnrfjMDVXGxw9wrfxYyCjk0KbXjhR55s=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211 h1:JGgROgKl9N8DuW20oFS5gxc+lE67/N3FcwmBPMe7ArY=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.4.0 h1:BrVqGRd7+k1DiOgtnFvAkoQEWQvBc25ouMJM6429SFg=\ngolang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "img",
          "type": "tree",
          "content": null
        },
        {
          "name": "input.go",
          "type": "blob",
          "size": 5.4501953125,
          "content": "package survey\n\nimport (\n\t\"errors\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\n/*\nInput is a regular text input that prints each character the user types on the screen\nand accepts the input with the enter key. Response type is a string.\n\n\tname := \"\"\n\tprompt := &survey.Input{ Message: \"What is your name?\" }\n\tsurvey.AskOne(prompt, &name)\n*/\ntype Input struct {\n\tRenderer\n\tMessage       string\n\tDefault       string\n\tHelp          string\n\tSuggest       func(toComplete string) []string\n\tanswer        string\n\ttypedAnswer   string\n\toptions       []core.OptionAnswer\n\tselectedIndex int\n\tshowingHelp   bool\n}\n\n// data available to the templates when processing\ntype InputTemplateData struct {\n\tInput\n\tShowAnswer    bool\n\tShowHelp      bool\n\tAnswer        string\n\tPageEntries   []core.OptionAnswer\n\tSelectedIndex int\n\tConfig        *PromptConfig\n}\n\n// Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format\nvar InputQuestionTemplate = `\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }} {{color \"reset\"}}\n{{- if .ShowAnswer}}\n  {{- color \"cyan\"}}{{.Answer}}{{color \"reset\"}}{{\"\\n\"}}\n{{- else if .PageEntries -}}\n  {{- .Answer}} [Use arrows to move, enter to select, type to continue]\n  {{- \"\\n\"}}\n  {{- range $ix, $choice := .PageEntries}}\n    {{- if eq $ix $.SelectedIndex }}{{color $.Config.Icons.SelectFocus.Format }}{{ $.Config.Icons.SelectFocus.Text }} {{else}}{{color \"default\"}}  {{end}}\n    {{- $choice.Value}}\n    {{- color \"reset\"}}{{\"\\n\"}}\n  {{- end}}\n{{- else }}\n  {{- if or (and .Help (not .ShowHelp)) .Suggest }}{{color \"cyan\"}}[\n    {{- if and .Help (not .ShowHelp)}}{{ print .Config.HelpInput }} for help {{- if and .Suggest}}, {{end}}{{end -}}\n    {{- if and .Suggest }}{{color \"cyan\"}}{{ print .Config.SuggestInput }} for suggestions{{end -}}\n  ]{{color \"reset\"}} {{end}}\n  {{- if .Default}}{{color \"white\"}}({{.Default}}) {{color \"reset\"}}{{end}}\n{{- end}}`\n\nfunc (i *Input) onRune(config *PromptConfig) terminal.OnRuneFn {\n\treturn terminal.OnRuneFn(func(key rune, line []rune) ([]rune, bool, error) {\n\t\tif i.options != nil && (key == terminal.KeyEnter || key == '\\n') {\n\t\t\treturn []rune(i.answer), true, nil\n\t\t} else if i.options != nil && key == terminal.KeyEscape {\n\t\t\ti.answer = i.typedAnswer\n\t\t\ti.options = nil\n\t\t} else if key == terminal.KeyArrowUp && len(i.options) > 0 {\n\t\t\tif i.selectedIndex == 0 {\n\t\t\t\ti.selectedIndex = len(i.options) - 1\n\t\t\t} else {\n\t\t\t\ti.selectedIndex--\n\t\t\t}\n\t\t\ti.answer = i.options[i.selectedIndex].Value\n\t\t} else if (key == terminal.KeyArrowDown || key == terminal.KeyTab) && len(i.options) > 0 {\n\t\t\tif i.selectedIndex == len(i.options)-1 {\n\t\t\t\ti.selectedIndex = 0\n\t\t\t} else {\n\t\t\t\ti.selectedIndex++\n\t\t\t}\n\t\t\ti.answer = i.options[i.selectedIndex].Value\n\t\t} else if key == terminal.KeyTab && i.Suggest != nil {\n\t\t\ti.answer = string(line)\n\t\t\ti.typedAnswer = i.answer\n\t\t\toptions := i.Suggest(i.answer)\n\t\t\ti.selectedIndex = 0\n\t\t\tif len(options) == 0 {\n\t\t\t\treturn line, false, nil\n\t\t\t}\n\n\t\t\ti.answer = options[0]\n\t\t\tif len(options) == 1 {\n\t\t\t\ti.typedAnswer = i.answer\n\t\t\t\ti.options = nil\n\t\t\t} else {\n\t\t\t\ti.options = core.OptionAnswerList(options)\n\t\t\t}\n\t\t} else {\n\t\t\tif i.options == nil {\n\t\t\t\treturn line, false, nil\n\t\t\t}\n\n\t\t\tif key >= terminal.KeySpace {\n\t\t\t\ti.answer += string(key)\n\t\t\t}\n\t\t\ti.typedAnswer = i.answer\n\n\t\t\ti.options = nil\n\t\t}\n\n\t\tpageSize := config.PageSize\n\t\topts, idx := paginate(pageSize, i.options, i.selectedIndex)\n\t\terr := i.Render(\n\t\t\tInputQuestionTemplate,\n\t\t\tInputTemplateData{\n\t\t\t\tInput:         *i,\n\t\t\t\tAnswer:        i.answer,\n\t\t\t\tShowHelp:      i.showingHelp,\n\t\t\t\tSelectedIndex: idx,\n\t\t\t\tPageEntries:   opts,\n\t\t\t\tConfig:        config,\n\t\t\t},\n\t\t)\n\n\t\tif err == nil {\n\t\t\terr = errReadLineAgain\n\t\t}\n\n\t\treturn []rune(i.typedAnswer), true, err\n\t})\n}\n\nvar errReadLineAgain = errors.New(\"read line again\")\n\nfunc (i *Input) Prompt(config *PromptConfig) (interface{}, error) {\n\t// render the template\n\terr := i.Render(\n\t\tInputQuestionTemplate,\n\t\tInputTemplateData{\n\t\t\tInput:    *i,\n\t\t\tConfig:   config,\n\t\t\tShowHelp: i.showingHelp,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// start reading runes from the standard in\n\trr := i.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\tcursor := i.NewCursor()\n\tif !config.ShowCursor {\n\t\tcursor.Hide()       // hide the cursor\n\t\tdefer cursor.Show() // show the cursor when we're done\n\t}\n\n\tvar line []rune\n\n\tfor {\n\t\tif i.options != nil {\n\t\t\tline = []rune{}\n\t\t}\n\n\t\tline, err = rr.ReadLineWithDefault(0, line, i.onRune(config))\n\t\tif err == errReadLineAgain {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tbreak\n\t}\n\n\ti.answer = string(line)\n\t// readline print an empty line, go up before we render the follow up\n\tcursor.Up(1)\n\n\t// if we ran into the help string\n\tif i.answer == config.HelpInput && i.Help != \"\" {\n\t\t// show the help and prompt again\n\t\ti.showingHelp = true\n\t\treturn i.Prompt(config)\n\t}\n\n\t// if the line is empty\n\tif len(i.answer) == 0 {\n\t\t// use the default value\n\t\treturn i.Default, err\n\t}\n\n\tlineStr := i.answer\n\n\ti.AppendRenderedText(lineStr)\n\n\t// we're done\n\treturn lineStr, err\n}\n\nfunc (i *Input) Cleanup(config *PromptConfig, val interface{}) error {\n\treturn i.Render(\n\t\tInputQuestionTemplate,\n\t\tInputTemplateData{\n\t\t\tInput:      *i,\n\t\t\tShowAnswer: true,\n\t\t\tConfig:     config,\n\t\t\tAnswer:     val.(string),\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "input_test.go",
          "type": "blob",
          "size": 12.6201171875,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestInputRender(t *testing.T) {\n\n\tsuggestFn := func(string) (s []string) { return s }\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   Input\n\t\tdata     InputTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"Test Input question output without default\",\n\t\t\tInput{Message: \"What is your favorite month:\"},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with default\",\n\t\t\tInput{Message: \"What is your favorite month:\", Default: \"April\"},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: (April) \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Input answer output\",\n\t\t\tInput{Message: \"What is your favorite month:\"},\n\t\t\tInputTemplateData{ShowAnswer: true, Answer: \"October\"},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: October\\n\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output without default but with help hidden\",\n\t\t\tInput{Message: \"What is your favorite month:\", Help: \"This is helpful\"},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for help] \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with default and with help hidden\",\n\t\t\tInput{Message: \"What is your favorite month:\", Default: \"April\", Help: \"This is helpful\"},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for help] (April) \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output without default but with help shown\",\n\t\t\tInput{Message: \"What is your favorite month:\", Help: \"This is helpful\"},\n\t\t\tInputTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s What is your favorite month: \", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with default and with help shown\",\n\t\t\tInput{Message: \"What is your favorite month:\", Default: \"April\", Help: \"This is helpful\"},\n\t\t\tInputTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s What is your favorite month: (April) \", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with completion\",\n\t\t\tInput{Message: \"What is your favorite month:\", Suggest: suggestFn},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for suggestions] \", defaultIcons().Question.Text, string(defaultPromptConfig().SuggestInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with suggestions and help hidden\",\n\t\t\tInput{Message: \"What is your favorite month:\", Suggest: suggestFn, Help: \"This is helpful\"},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for help, %s for suggestions] \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput), string(defaultPromptConfig().SuggestInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with suggestions and default and help hidden\",\n\t\t\tInput{Message: \"What is your favorite month:\", Suggest: suggestFn, Help: \"This is helpful\", Default: \"April\"},\n\t\t\tInputTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [%s for help, %s for suggestions] (April) \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput), string(defaultPromptConfig().SuggestInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Input question output with suggestions shown\",\n\t\t\tInput{Message: \"What is your favorite month:\", Suggest: suggestFn},\n\t\t\tInputTemplateData{\n\t\t\t\tAnswer:        \"February\",\n\t\t\t\tPageEntries:   core.OptionAnswerList([]string{\"January\", \"February\", \"March\", \"etc...\"}),\n\t\t\t\tSelectedIndex: 1,\n\t\t\t},\n\t\t\tfmt.Sprintf(\n\t\t\t\t\"%s What is your favorite month: February [Use arrows to move, enter to select, type to continue]\\n\"+\n\t\t\t\t\t\"  January\\n%s February\\n  March\\n  etc...\\n\",\n\t\t\t\tdefaultIcons().Question.Text, defaultPromptConfig().Icons.SelectFocus.Text,\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.title, func(t *testing.T) {\n\t\t\tr, w, err := os.Pipe()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.prompt.WithStdio(terminal.Stdio{Out: w})\n\t\t\ttest.data.Input = test.prompt\n\n\t\t\t// set the runtime config\n\t\t\ttest.data.Config = defaultPromptConfig()\n\n\t\t\terr = test.prompt.Render(\n\t\t\t\tInputQuestionTemplate,\n\t\t\t\ttest.data,\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, w.Close())\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = io.Copy(&buf, r)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Contains(t, buf.String(), test.expected)\n\t\t})\n\t}\n}\n\nfunc TestInputPrompt(t *testing.T) {\n\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"Test Input prompt interaction\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"Larry Bird\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Larry Bird\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction with default\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\tDefault: \"Johnny Appleseed\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Johnny Appleseed\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction overriding default\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\tDefault: \"Johnny Appleseed\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"Larry Bird\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Larry Bird\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction and prompt for help\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\tHelp:    \"It might be Satoshi Nakamoto\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"?\")\n\t\t\t\tc.ExpectString(\"It might be Satoshi Nakamoto\")\n\t\t\t\tc.SendLine(\"Satoshi Nakamoto\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Satoshi Nakamoto\",\n\t\t},\n\t\t{\n\t\t\t// https://en.wikipedia.org/wiki/ANSI_escape_code\n\t\t\t// Device Status Report - Reports the cursor position (CPR) to the\n\t\t\t// application as (as though typed at the keyboard) ESC[n;mR, where n is the\n\t\t\t// row and m is the column.\n\t\t\t\"SKIP: Test Input prompt with R matching DSR\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"R\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"R\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when delete\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.Send(\"Johnny \")\n\t\t\t\tc.Send(string(terminal.KeyDelete))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Johnny\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when delete rune\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.Send(\"Â∞èÊòé\")\n\t\t\t\tc.Send(string(terminal.KeyBackspace))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Â∞è\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when ask for suggestion with empty value\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your favorite month?\",\n\t\t\t\tSuggest: func(string) []string {\n\t\t\t\t\treturn []string{\"January\", \"February\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your favorite month?\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.ExpectString(\"January\")\n\t\t\t\tc.ExpectString(\"February\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"January\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when ask for suggestion with some value\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your favorite month?\",\n\t\t\t\tSuggest: func(string) []string {\n\t\t\t\t\treturn []string{\"February\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your favorite month?\")\n\t\t\t\tc.Send(\"feb\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"February\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when ask for suggestion with some value, choosing the second one\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your favorite month?\",\n\t\t\t\tSuggest: func(string) []string {\n\t\t\t\t\treturn []string{\"January\", \"February\", \"March\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your favorite month?\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"March\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when ask for suggestion with some value, choosing the second one\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"What is your favorite month?\",\n\t\t\t\tSuggest: func(string) []string {\n\t\t\t\t\treturn []string{\"January\", \"February\", \"March\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your favorite month?\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowUp))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"February\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when ask for suggestion, complementing it and get new suggestions\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"Where to save it?\",\n\t\t\t\tSuggest: func(complete string) []string {\n\t\t\t\t\tif complete == \"\" {\n\t\t\t\t\t\treturn []string{\"folder1/\", \"folder2/\", \"folder3/\"}\n\t\t\t\t\t}\n\t\t\t\t\treturn []string{\"folder3/file1.txt\", \"folder3/file2.txt\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Where to save it?\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.ExpectString(\"folder1/\")\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\"f\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.ExpectString(\"folder3/file2.txt\")\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"folder3/file2.txt\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction when asked suggestions, but abort suggestions\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"Wanna a suggestion?\",\n\t\t\t\tSuggest: func(string) []string {\n\t\t\t\t\treturn []string{\"suggest1\", \"suggest2\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Wanna a suggestion?\")\n\t\t\t\tc.Send(\"typed answer\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.ExpectString(\"suggest1\")\n\t\t\t\tc.Send(string(terminal.KeyEscape))\n\t\t\t\tc.ExpectString(\"typed answer\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"typed answer\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt interaction with suggestions, when tabbed with list being shown, should select next suggestion\",\n\t\t\t&Input{\n\t\t\t\tMessage: \"Choose the special one:\",\n\t\t\t\tSuggest: func(string) []string {\n\t\t\t\t\treturn []string{\"suggest1\", \"suggest2\", \"special answer\"}\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose the special one:\")\n\t\t\t\tc.Send(\"s\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.ExpectString(\"suggest1\")\n\t\t\t\tc.ExpectString(\"suggest2\")\n\t\t\t\tc.ExpectString(\"special answer\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"special answer\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt must allow moving cursor using right and left arrows\",\n\t\t\t&Input{Message: \"Filename to save:\"},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Filename to save:\")\n\t\t\t\tc.Send(\"essay.txt\")\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(\"_final\")\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.Send(string(terminal.KeyBackspace))\n\t\t\t\tc.Send(string(terminal.KeyBackspace))\n\t\t\t\tc.Send(string(terminal.KeyBackspace))\n\t\t\t\tc.Send(\"md\")\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.SendLine(\"2\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"essay_final2.md\",\n\t\t},\n\t\t{\n\t\t\t\"Test Input prompt must allow moving cursor using right and left arrows, even after suggestions\",\n\t\t\t&Input{Message: \"Filename to save:\", Suggest: func(string) []string { return []string{\".txt\", \".csv\", \".go\"} }},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Filename to save:\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.ExpectString(\".txt\")\n\t\t\t\tc.ExpectString(\".csv\")\n\t\t\t\tc.ExpectString(\".go\")\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.Send(\"newtable\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"newtable.csv\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttestName := strings.TrimPrefix(test.name, \"SKIP: \")\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tif testName != test.name {\n\t\t\t\tt.Skipf(\"warning: flakey test %q\", testName)\n\t\t\t}\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "multiline.go",
          "type": "blob",
          "size": 2.455078125,
          "content": "package survey\n\nimport (\n\t\"strings\"\n\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\ntype Multiline struct {\n\tRenderer\n\tMessage string\n\tDefault string\n\tHelp    string\n}\n\n// data available to the templates when processing\ntype MultilineTemplateData struct {\n\tMultiline\n\tAnswer     string\n\tShowAnswer bool\n\tShowHelp   bool\n\tConfig     *PromptConfig\n}\n\n// Templates with Color formatting. See Documentation: https://github.com/mgutz/ansi#style-format\nvar MultilineQuestionTemplate = `\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }} {{color \"reset\"}}\n{{- if .ShowAnswer}}\n  {{- \"\\n\"}}{{color \"cyan\"}}{{.Answer}}{{color \"reset\"}}\n  {{- if .Answer }}{{ \"\\n\" }}{{ end }}\n{{- else }}\n  {{- if .Default}}{{color \"white\"}}({{.Default}}) {{color \"reset\"}}{{end}}\n  {{- color \"cyan\"}}[Enter 2 empty lines to finish]{{color \"reset\"}}\n{{- end}}`\n\nfunc (i *Multiline) Prompt(config *PromptConfig) (interface{}, error) {\n\t// render the template\n\terr := i.Render(\n\t\tMultilineQuestionTemplate,\n\t\tMultilineTemplateData{\n\t\t\tMultiline: *i,\n\t\t\tConfig:    config,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// start reading runes from the standard in\n\trr := i.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\n\tcursor := i.NewCursor()\n\n\tmultiline := make([]string, 0)\n\n\temptyOnce := false\n\t// get the next line\n\tfor {\n\t\tvar line []rune\n\t\tline, err = rr.ReadLine(0)\n\t\tif err != nil {\n\t\t\treturn string(line), err\n\t\t}\n\n\t\tif string(line) == \"\" {\n\t\t\tif emptyOnce {\n\t\t\t\tnumLines := len(multiline) + 2\n\t\t\t\tcursor.PreviousLine(numLines)\n\t\t\t\tfor j := 0; j < numLines; j++ {\n\t\t\t\t\tterminal.EraseLine(i.Stdio().Out, terminal.ERASE_LINE_ALL)\n\t\t\t\t\tcursor.NextLine(1)\n\t\t\t\t}\n\t\t\t\tcursor.PreviousLine(numLines)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\temptyOnce = true\n\t\t} else {\n\t\t\temptyOnce = false\n\t\t}\n\t\tmultiline = append(multiline, string(line))\n\t}\n\n\tval := strings.Join(multiline, \"\\n\")\n\tval = strings.TrimSpace(val)\n\n\t// if the line is empty\n\tif len(val) == 0 {\n\t\t// use the default value\n\t\treturn i.Default, err\n\t}\n\n\ti.AppendRenderedText(val)\n\treturn val, err\n}\n\nfunc (i *Multiline) Cleanup(config *PromptConfig, val interface{}) error {\n\treturn i.Render(\n\t\tMultilineQuestionTemplate,\n\t\tMultilineTemplateData{\n\t\t\tMultiline:  *i,\n\t\t\tAnswer:     val.(string),\n\t\t\tShowAnswer: true,\n\t\t\tConfig:     config,\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "multiline_test.go",
          "type": "blob",
          "size": 4.51171875,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestMultilineRender(t *testing.T) {\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   Multiline\n\t\tdata     MultilineTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"Test Multiline question output without default\",\n\t\t\tMultiline{Message: \"What is your favorite month:\"},\n\t\t\tMultilineTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [Enter 2 empty lines to finish]\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline question output with default\",\n\t\t\tMultiline{Message: \"What is your favorite month:\", Default: \"April\"},\n\t\t\tMultilineTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: (April) [Enter 2 empty lines to finish]\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline answer output\",\n\t\t\tMultiline{Message: \"What is your favorite month:\"},\n\t\t\tMultilineTemplateData{Answer: \"October\", ShowAnswer: true},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: \\nOctober\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline question output without default but with help hidden\",\n\t\t\tMultiline{Message: \"What is your favorite month:\", Help: \"This is helpful\"},\n\t\t\tMultilineTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: [Enter 2 empty lines to finish]\", string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline question output with default and with help hidden\",\n\t\t\tMultiline{Message: \"What is your favorite month:\", Default: \"April\", Help: \"This is helpful\"},\n\t\t\tMultilineTemplateData{},\n\t\t\tfmt.Sprintf(\"%s What is your favorite month: (April) [Enter 2 empty lines to finish]\", string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline question output without default but with help shown\",\n\t\t\tMultiline{Message: \"What is your favorite month:\", Help: \"This is helpful\"},\n\t\t\tMultilineTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s What is your favorite month: [Enter 2 empty lines to finish]\", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline question output with default and with help shown\",\n\t\t\tMultiline{Message: \"What is your favorite month:\", Default: \"April\", Help: \"This is helpful\"},\n\t\t\tMultilineTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s What is your favorite month: (April) [Enter 2 empty lines to finish]\", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.title, func(t *testing.T) {\n\t\t\tr, w, err := os.Pipe()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.prompt.WithStdio(terminal.Stdio{Out: w})\n\t\t\ttest.data.Multiline = test.prompt\n\t\t\t// set the icon set\n\t\t\ttest.data.Config = defaultPromptConfig()\n\n\t\t\terr = test.prompt.Render(\n\t\t\t\tMultilineQuestionTemplate,\n\t\t\t\ttest.data,\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, w.Close())\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = io.Copy(&buf, r)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Contains(t, buf.String(), test.expected, test.title)\n\t\t})\n\t}\n}\n\nfunc TestMultilinePrompt(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"Test Multiline prompt interaction\",\n\t\t\t&Multiline{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"Larry Bird\\nI guess...\\nnot sure\\n\\n\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Larry Bird\\nI guess...\\nnot sure\",\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline prompt interaction with default\",\n\t\t\t&Multiline{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\tDefault: \"Johnny Appleseed\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"\\n\\n\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Johnny Appleseed\",\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline prompt interaction overriding default\",\n\t\t\t&Multiline{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\tDefault: \"Johnny Appleseed\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"Larry Bird\\n\\n\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"Larry Bird\",\n\t\t},\n\t\t{\n\t\t\t\"Test Multiline does not implement help interaction\",\n\t\t\t&Multiline{\n\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\tHelp:    \"It might be Satoshi Nakamoto\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"?\")\n\t\t\t\tc.SendLine(\"Satoshi Nakamoto\\n\\n\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"?\\nSatoshi Nakamoto\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "multiselect.go",
          "type": "blob",
          "size": 10.1298828125,
          "content": "package survey\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\n/*\nMultiSelect is a prompt that presents a list of various options to the user\nfor them to select using the arrow keys and enter. Response type is a slice of strings.\n\n\tdays := []string{}\n\tprompt := &survey.MultiSelect{\n\t\tMessage: \"What days do you prefer:\",\n\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t}\n\tsurvey.AskOne(prompt, &days)\n*/\ntype MultiSelect struct {\n\tRenderer\n\tMessage       string\n\tOptions       []string\n\tDefault       interface{}\n\tHelp          string\n\tPageSize      int\n\tVimMode       bool\n\tFilterMessage string\n\tFilter        func(filter string, value string, index int) bool\n\tDescription   func(value string, index int) string\n\tfilter        string\n\tselectedIndex int\n\tchecked       map[int]bool\n\tshowingHelp   bool\n}\n\n// data available to the templates when processing\ntype MultiSelectTemplateData struct {\n\tMultiSelect\n\tAnswer        string\n\tShowAnswer    bool\n\tChecked       map[int]bool\n\tSelectedIndex int\n\tShowHelp      bool\n\tDescription   func(value string, index int) string\n\tPageEntries   []core.OptionAnswer\n\tConfig        *PromptConfig\n\n\t// These fields are used when rendering an individual option\n\tCurrentOpt   core.OptionAnswer\n\tCurrentIndex int\n}\n\n// IterateOption sets CurrentOpt and CurrentIndex appropriately so a multiselect option can be rendered individually\nfunc (m MultiSelectTemplateData) IterateOption(ix int, opt core.OptionAnswer) interface{} {\n\tcopy := m\n\tcopy.CurrentIndex = ix\n\tcopy.CurrentOpt = opt\n\treturn copy\n}\n\nfunc (m MultiSelectTemplateData) GetDescription(opt core.OptionAnswer) string {\n\tif m.Description == nil {\n\t\treturn \"\"\n\t}\n\treturn m.Description(opt.Value, opt.Index)\n}\n\nvar MultiSelectQuestionTemplate = `\n{{- define \"option\"}}\n    {{- if eq .SelectedIndex .CurrentIndex }}{{color .Config.Icons.SelectFocus.Format }}{{ .Config.Icons.SelectFocus.Text }}{{color \"reset\"}}{{else}} {{end}}\n    {{- if index .Checked .CurrentOpt.Index }}{{color .Config.Icons.MarkedOption.Format }} {{ .Config.Icons.MarkedOption.Text }} {{else}}{{color .Config.Icons.UnmarkedOption.Format }} {{ .Config.Icons.UnmarkedOption.Text }} {{end}}\n    {{- color \"reset\"}}\n    {{- \" \"}}{{- .CurrentOpt.Value}}{{ if ne ($.GetDescription .CurrentOpt) \"\" }} - {{color \"cyan\"}}{{ $.GetDescription .CurrentOpt }}{{color \"reset\"}}{{end}}\n{{end}}\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }}{{ .FilterMessage }}{{color \"reset\"}}\n{{- if .ShowAnswer}}{{color \"cyan\"}} {{.Answer}}{{color \"reset\"}}{{\"\\n\"}}\n{{- else }}\n\t{{- \"  \"}}{{- color \"cyan\"}}[Use arrows to move, space to select,{{- if not .Config.RemoveSelectAll }} <right> to all,{{end}}{{- if not .Config.RemoveSelectNone }} <left> to none,{{end}} type to filter{{- if and .Help (not .ShowHelp)}}, {{ .Config.HelpInput }} for more help{{end}}]{{color \"reset\"}}\n  {{- \"\\n\"}}\n  {{- range $ix, $option := .PageEntries}}\n    {{- template \"option\" $.IterateOption $ix $option}}\n  {{- end}}\n{{- end}}`\n\n// OnChange is called on every keypress.\nfunc (m *MultiSelect) OnChange(key rune, config *PromptConfig) {\n\toptions := m.filterOptions(config)\n\toldFilter := m.filter\n\n\tif key == terminal.KeyArrowUp || (m.VimMode && key == 'k') {\n\t\t// if we are at the top of the list\n\t\tif m.selectedIndex == 0 {\n\t\t\t// go to the bottom\n\t\t\tm.selectedIndex = len(options) - 1\n\t\t} else {\n\t\t\t// decrement the selected index\n\t\t\tm.selectedIndex--\n\t\t}\n\t} else if key == terminal.KeyTab || key == terminal.KeyArrowDown || (m.VimMode && key == 'j') {\n\t\t// if we are at the bottom of the list\n\t\tif m.selectedIndex == len(options)-1 {\n\t\t\t// start at the top\n\t\t\tm.selectedIndex = 0\n\t\t} else {\n\t\t\t// increment the selected index\n\t\t\tm.selectedIndex++\n\t\t}\n\t\t// if the user pressed down and there is room to move\n\t} else if key == terminal.KeySpace {\n\t\t// the option they have selected\n\t\tif m.selectedIndex < len(options) {\n\t\t\tselectedOpt := options[m.selectedIndex]\n\n\t\t\t// if we haven't seen this index before\n\t\t\tif old, ok := m.checked[selectedOpt.Index]; !ok {\n\t\t\t\t// set the value to true\n\t\t\t\tm.checked[selectedOpt.Index] = true\n\t\t\t} else {\n\t\t\t\t// otherwise just invert the current value\n\t\t\t\tm.checked[selectedOpt.Index] = !old\n\t\t\t}\n\t\t\tif !config.KeepFilter {\n\t\t\t\tm.filter = \"\"\n\t\t\t}\n\t\t}\n\t\t// only show the help message if we have one to show\n\t} else if string(key) == config.HelpInput && m.Help != \"\" {\n\t\tm.showingHelp = true\n\t} else if key == terminal.KeyEscape {\n\t\tm.VimMode = !m.VimMode\n\t} else if key == terminal.KeyDeleteWord || key == terminal.KeyDeleteLine {\n\t\tm.filter = \"\"\n\t} else if key == terminal.KeyDelete || key == terminal.KeyBackspace {\n\t\tif m.filter != \"\" {\n\t\t\truneFilter := []rune(m.filter)\n\t\t\tm.filter = string(runeFilter[0 : len(runeFilter)-1])\n\t\t}\n\t} else if key >= terminal.KeySpace {\n\t\tm.filter += string(key)\n\t\tm.VimMode = false\n\t} else if !config.RemoveSelectAll && key == terminal.KeyArrowRight {\n\t\tfor _, v := range options {\n\t\t\tm.checked[v.Index] = true\n\t\t}\n\t\tif !config.KeepFilter {\n\t\t\tm.filter = \"\"\n\t\t}\n\t} else if !config.RemoveSelectNone && key == terminal.KeyArrowLeft {\n\t\tfor _, v := range options {\n\t\t\tm.checked[v.Index] = false\n\t\t}\n\t\tif !config.KeepFilter {\n\t\t\tm.filter = \"\"\n\t\t}\n\t}\n\n\tm.FilterMessage = \"\"\n\tif m.filter != \"\" {\n\t\tm.FilterMessage = \" \" + m.filter\n\t}\n\tif oldFilter != m.filter {\n\t\t// filter changed\n\t\toptions = m.filterOptions(config)\n\t\tif len(options) > 0 && len(options) <= m.selectedIndex {\n\t\t\tm.selectedIndex = len(options) - 1\n\t\t}\n\t}\n\t// paginate the options\n\t// figure out the page size\n\tpageSize := m.PageSize\n\t// if we dont have a specific one\n\tif pageSize == 0 {\n\t\t// grab the global value\n\t\tpageSize = config.PageSize\n\t}\n\n\t// TODO if we have started filtering and were looking at the end of a list\n\t// and we have modified the filter then we should move the page back!\n\topts, idx := paginate(pageSize, options, m.selectedIndex)\n\n\ttmplData := MultiSelectTemplateData{\n\t\tMultiSelect:   *m,\n\t\tSelectedIndex: idx,\n\t\tChecked:       m.checked,\n\t\tShowHelp:      m.showingHelp,\n\t\tDescription:   m.Description,\n\t\tPageEntries:   opts,\n\t\tConfig:        config,\n\t}\n\n\t// render the options\n\t_ = m.RenderWithCursorOffset(MultiSelectQuestionTemplate, tmplData, opts, idx)\n}\n\nfunc (m *MultiSelect) filterOptions(config *PromptConfig) []core.OptionAnswer {\n\t// the filtered list\n\tanswers := []core.OptionAnswer{}\n\n\t// if there is no filter applied\n\tif m.filter == \"\" {\n\t\t// return all of the options\n\t\treturn core.OptionAnswerList(m.Options)\n\t}\n\n\t// the filter to apply\n\tfilter := m.Filter\n\tif filter == nil {\n\t\tfilter = config.Filter\n\t}\n\n\t// apply the filter to each option\n\tfor i, opt := range m.Options {\n\t\t// i the filter says to include the option\n\t\tif filter(m.filter, opt, i) {\n\t\t\tanswers = append(answers, core.OptionAnswer{\n\t\t\t\tIndex: i,\n\t\t\t\tValue: opt,\n\t\t\t})\n\t\t}\n\t}\n\n\t// we're done here\n\treturn answers\n}\n\nfunc (m *MultiSelect) Prompt(config *PromptConfig) (interface{}, error) {\n\t// compute the default state\n\tm.checked = make(map[int]bool)\n\t// if there is a default\n\tif m.Default != nil {\n\t\t// if the default is string values\n\t\tif defaultValues, ok := m.Default.([]string); ok {\n\t\t\tfor _, dflt := range defaultValues {\n\t\t\t\tfor i, opt := range m.Options {\n\t\t\t\t\t// if the option corresponds to the default\n\t\t\t\t\tif opt == dflt {\n\t\t\t\t\t\t// we found our initial value\n\t\t\t\t\t\tm.checked[i] = true\n\t\t\t\t\t\t// stop looking\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if the default value is index values\n\t\t} else if defaultIndices, ok := m.Default.([]int); ok {\n\t\t\t// go over every index we need to enable by default\n\t\t\tfor _, idx := range defaultIndices {\n\t\t\t\t// and enable it\n\t\t\t\tm.checked[idx] = true\n\t\t\t}\n\t\t}\n\t}\n\n\t// if there are no options to render\n\tif len(m.Options) == 0 {\n\t\t// we failed\n\t\treturn \"\", errors.New(\"please provide options to select from\")\n\t}\n\n\t// figure out the page size\n\tpageSize := m.PageSize\n\t// if we dont have a specific one\n\tif pageSize == 0 {\n\t\t// grab the global value\n\t\tpageSize = config.PageSize\n\t}\n\t// paginate the options\n\t// build up a list of option answers\n\topts, idx := paginate(pageSize, core.OptionAnswerList(m.Options), m.selectedIndex)\n\n\tcursor := m.NewCursor()\n\tcursor.Save()          // for proper cursor placement during selection\n\tcursor.Hide()          // hide the cursor\n\tdefer cursor.Show()    // show the cursor when we're done\n\tdefer cursor.Restore() // clear any accessibility offsetting on exit\n\n\ttmplData := MultiSelectTemplateData{\n\t\tMultiSelect:   *m,\n\t\tSelectedIndex: idx,\n\t\tDescription:   m.Description,\n\t\tChecked:       m.checked,\n\t\tPageEntries:   opts,\n\t\tConfig:        config,\n\t}\n\n\t// ask the question\n\terr := m.RenderWithCursorOffset(MultiSelectQuestionTemplate, tmplData, opts, idx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\trr := m.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\n\t// start waiting for input\n\tfor {\n\t\tr, _, err := rr.ReadRune()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif r == '\\r' || r == '\\n' {\n\t\t\tbreak\n\t\t}\n\t\tif r == terminal.KeyInterrupt {\n\t\t\treturn \"\", terminal.InterruptErr\n\t\t}\n\t\tif r == terminal.KeyEndTransmission {\n\t\t\tbreak\n\t\t}\n\t\tm.OnChange(r, config)\n\t}\n\tm.filter = \"\"\n\tm.FilterMessage = \"\"\n\n\tanswers := []core.OptionAnswer{}\n\tfor i, option := range m.Options {\n\t\tif val, ok := m.checked[i]; ok && val {\n\t\t\tanswers = append(answers, core.OptionAnswer{Value: option, Index: i})\n\t\t}\n\t}\n\n\treturn answers, nil\n}\n\n// Cleanup removes the options section, and renders the ask like a normal question.\nfunc (m *MultiSelect) Cleanup(config *PromptConfig, val interface{}) error {\n\t// the answer to show\n\tanswer := \"\"\n\tfor _, ans := range val.([]core.OptionAnswer) {\n\t\tanswer = fmt.Sprintf(\"%s, %s\", answer, ans.Value)\n\t}\n\n\t// if we answered anything\n\tif len(answer) > 2 {\n\t\t// remove the precending commas\n\t\tanswer = answer[2:]\n\t}\n\n\t// execute the output summary template with the answer\n\treturn m.Render(\n\t\tMultiSelectQuestionTemplate,\n\t\tMultiSelectTemplateData{\n\t\t\tMultiSelect:   *m,\n\t\t\tSelectedIndex: m.selectedIndex,\n\t\t\tChecked:       m.checked,\n\t\t\tAnswer:        answer,\n\t\t\tShowAnswer:    true,\n\t\t\tDescription:   m.Description,\n\t\t\tConfig:        config,\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "multiselect_test.go",
          "type": "blob",
          "size": 23.0546875,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestMultiSelectRender(t *testing.T) {\n\n\tprompt := MultiSelect{\n\t\tMessage: \"Pick your words:\",\n\t\tOptions: []string{\"foo\", \"bar\", \"baz\", \"buz\"},\n\t\tDefault: []string{\"bar\", \"buz\"},\n\t}\n\n\tdescriptions := []string{\"oof\", \"rab\", \"zab\", \"zub\"}\n\n\thelpfulPrompt := prompt\n\thelpfulPrompt.Help = \"This is helpful\"\n\n\tpagePrompt := MultiSelect{\n\t\tMessage:  \"Pick your words:\",\n\t\tOptions:  []string{\"foo\", \"bar\", \"baz\", \"buz\"},\n\t\tPageSize: 2,\n\t}\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   MultiSelect\n\t\tdata     MultiSelectTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"question output\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"answer output\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tAnswer:     \"foo, buz\",\n\t\t\t\tShowAnswer: true,\n\t\t\t},\n\t\t\tfmt.Sprintf(\"%s Pick your words: foo, buz\\n\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"help hidden\",\n\t\t\thelpfulPrompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter, %s for more help]\", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"question outputhelp shown\",\n\t\t\thelpfulPrompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t\tShowHelp:      true,\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s This is helpful\", defaultIcons().Help.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"marked on paginating\",\n\t\t\tpagePrompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 0,\n\t\t\t\tPageEntries:   core.OptionAnswerList(pagePrompt.Options)[1:3], /* show unmarked items(bar, baz)*/\n\t\t\t\tChecked:       map[int]bool{0: true},                          /* foo marked */\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  bar\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  baz\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"description all\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t\tDescription: func(value string, index int) string {\n\t\t\t\t\treturn descriptions[index]\n\t\t\t\t},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo - oof\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar - rab\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz - zab\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz - zub\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"description even\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t\tDescription: func(value string, index int) string {\n\n\t\t\t\t\tif index%2 == 0 {\n\t\t\t\t\t\treturn descriptions[index]\n\t\t\t\t\t}\n\n\t\t\t\t\treturn \"\"\n\t\t\t\t},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo - oof\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz - zab\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"description never\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t\tDescription: func(value string, index int) string {\n\t\t\t\t\treturn \"\"\n\t\t\t\t},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"description repeat value\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t\tDescription: func(value string, index int) string {\n\t\t\t\t\treturn value\n\t\t\t\t},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo - foo\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar - bar\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz - baz\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz - buz\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"description print index\",\n\t\t\tprompt,\n\t\t\tMultiSelectTemplateData{\n\t\t\t\tSelectedIndex: 2,\n\t\t\t\tPageEntries:   core.OptionAnswerList(prompt.Options),\n\t\t\t\tChecked:       map[int]bool{1: true, 3: true},\n\t\t\t\tDescription: func(value string, index int) string {\n\t\t\t\t\treturn fmt.Sprint(index)\n\t\t\t\t},\n\t\t\t},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your words:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  foo - 0\", defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  bar - 1\", defaultIcons().MarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s %s  baz - 2\", defaultIcons().SelectFocus.Text, defaultIcons().UnmarkedOption.Text),\n\t\t\t\t\tfmt.Sprintf(\"  %s  buz - 3\\n\", defaultIcons().MarkedOption.Text),\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.title, func(t *testing.T) {\n\t\t\tr, w, err := os.Pipe()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.prompt.WithStdio(terminal.Stdio{Out: w})\n\t\t\ttest.data.MultiSelect = test.prompt\n\n\t\t\t// set the icon set\n\t\t\ttest.data.Config = defaultPromptConfig()\n\n\t\t\terr = test.prompt.Render(\n\t\t\t\tMultiSelectQuestionTemplate,\n\t\t\t\ttest.data,\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, w.Close())\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = io.Copy(&buf, r)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Contains(t, buf.String(), test.expected)\n\t\t})\n\t}\n}\n\nfunc TestMultiSelectPrompt(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"basic interaction\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select Monday.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Monday\", Index: 1}},\n\t\t},\n\t\t{\n\t\t\t\"cycle to next when tab send\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select Monday.\n\t\t\t\tc.Send(string(terminal.KeyTab))\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Monday\", Index: 1},\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"default value as []string\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tDefault: []string{\"Tuesday\", \"Thursday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t\t{Value: \"Thursday\", Index: 4},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"default value as []int\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tDefault: []int{2, 4},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t\t{Value: \"Thursday\", Index: 4},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"overriding default\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tDefault: []string{\"Tuesday\", \"Thursday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Deselect Tuesday.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Thursday\", Index: 4}},\n\t\t},\n\t\t{\n\t\t\t\"prompt for help\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tHelp:    \"Saturday is best\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter, ? for more help]\")\n\t\t\t\tc.Send(\"?\")\n\t\t\t\tc.ExpectString(\"Saturday is best\")\n\t\t\t\t// Select Saturday\n\t\t\t\tc.Send(string(terminal.KeyArrowUp))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Saturday\", Index: 6}},\n\t\t},\n\t\t{\n\t\t\t\"page size\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage:  \"What days do you prefer:\",\n\t\t\t\tOptions:  []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tPageSize: 1,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select Monday.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Monday\", Index: 1}},\n\t\t},\n\t\t{\n\t\t\t\"vim mode\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tVimMode: true,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select Tuesday.\n\t\t\t\tc.Send(\"jj \")\n\t\t\t\t// Select Thursday.\n\t\t\t\tc.Send(\"jj \")\n\t\t\t\t// Select Saturday.\n\t\t\t\tc.Send(\"jj \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t\t{Value: \"Thursday\", Index: 4},\n\t\t\t\t{Value: \"Saturday\", Index: 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"filter interaction\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Filter down to Tuesday.\n\t\t\t\tc.Send(\"Tues\")\n\t\t\t\t// Select Tuesday.\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Tuesday\", Index: 2}},\n\t\t},\n\t\t{\n\t\t\t\"filter is case-insensitive\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Filter down to Tuesday.\n\t\t\t\tc.Send(\"tues\")\n\t\t\t\t// Select Tuesday.\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Tuesday\", Index: 2}},\n\t\t},\n\t\t{\n\t\t\t\"custom filter\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\tFilter: func(filterValue string, optValue string, index int) bool {\n\t\t\t\t\treturn strings.Contains(optValue, filterValue) && len(optValue) >= 7\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:\")\n\t\t\t\t// Filter down to days which names are longer than 7 runes\n\t\t\t\tc.Send(\"day\")\n\t\t\t\t// Select Wednesday.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{{Value: \"Wednesday\", Index: 3}},\n\t\t},\n\t\t{\n\t\t\t\"clears input on select\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Filter down to Tuesday.\n\t\t\t\tc.Send(\"Tues\")\n\t\t\t\t// Select Tuesday.\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Filter down to Tuesday.\n\t\t\t\tc.Send(\"Tues\")\n\t\t\t\t// Deselect Tuesday.\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{},\n\t\t},\n\t\t{\n\t\t\t\"select all\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select all\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Sunday\", Index: 0},\n\t\t\t\t{Value: \"Monday\", Index: 1},\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t\t{Value: \"Wednesday\", Index: 3},\n\t\t\t\t{Value: \"Thursday\", Index: 4},\n\t\t\t\t{Value: \"Friday\", Index: 5},\n\t\t\t\t{Value: \"Saturday\", Index: 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"select none\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select first\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Select second\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Deselect all\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{},\n\t\t},\n\t\t{\n\t\t\t\"select all with filter\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Send filter\n\t\t\t\tc.Send(\"tu\")\n\t\t\t\t// Select all\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t\t{Value: \"Saturday\", Index: 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"select all with filter and select others without filter\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Select first\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Select second\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Send filter\n\t\t\t\tc.Send(\"tu\")\n\t\t\t\t// Select all\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Sunday\", Index: 0},\n\t\t\t\t{Value: \"Monday\", Index: 1},\n\t\t\t\t{Value: \"Tuesday\", Index: 2},\n\t\t\t\t{Value: \"Saturday\", Index: 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"select all with filter and deselect one without filter\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Send filter\n\t\t\t\tc.Send(\"tu\")\n\t\t\t\t// Select all\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\t\t\t\t// Deselect second\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Saturday\", Index: 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"delete filter word\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Filter down to 'Sunday'\n\t\t\t\tc.Send(\"su\")\n\t\t\t\t// Delete 'u'\n\t\t\t\tc.Send(string(terminal.KeyDelete))\n\t\t\t\t// Filter down to 'Saturday'\n\t\t\t\tc.Send(\"at\")\n\t\t\t\t// Select 'Saturday'\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Saturday\", Index: 6},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"delete filter word in rune\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"‰ªäÂ§©‰∏≠ÂçàÂêÉ‰ªÄ‰πàÔºü\",\n\t\t\t\tOptions: []string{\"ÈùíÊ§íÁâõËÇâ‰∏ù\", \"Â∞èÁÇíËÇâ\", \"Â∞èÁÖéÈ∏°\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"‰ªäÂ§©‰∏≠ÂçàÂêÉ‰ªÄ‰πàÔºü  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Filter down to Â∞èÁÇíËÇâ.\n\t\t\t\tc.Send(\"Â∞èÁÇí\")\n\t\t\t\t// Filter down to Â∞èÁÇíËÇâ and Â∞èÁÖéÈ∏°.\n\t\t\t\tc.Send(string(terminal.KeyBackspace))\n\t\t\t\t// Filter down to Â∞èÁÖéÈ∏°.\n\t\t\t\tc.Send(\"ÁÖé\")\n\t\t\t\t// Select Â∞èÁÖéÈ∏°.\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"Â∞èÁÖéÈ∏°\", Index: 2},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n\nfunc TestMultiSelectPromptKeepFilter(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"multi select with filter keep\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What color do you prefer:\",\n\t\t\t\tOptions: []string{\"green\", \"red\", \"light-green\", \"blue\", \"black\", \"yellow\", \"purple\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What color do you prefer:  [Use arrows to move, space to select, <right> to all, <left> to none, type to filter]\")\n\t\t\t\t// Filter down to green\n\t\t\t\tc.Send(\"green\")\n\t\t\t\t// Select green.\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Select light-green.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\" \")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{\n\t\t\t\t{Value: \"green\", Index: 0},\n\t\t\t\t{Value: \"light-green\", Index: 2},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTestKeepFilter(t, test)\n\t\t})\n\t}\n}\n\nfunc TestMultiSelectPromptRemoveSelectAll(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"multi select with remove select all option\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What color do you prefer:\",\n\t\t\t\tOptions: []string{\"green\", \"red\", \"light-green\", \"blue\", \"black\", \"yellow\", \"purple\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What color do you prefer:  [Use arrows to move, space to select, <left> to none, type to filter]\")\n\t\t\t\t// Select the first option \"green\"\n\t\t\t\tc.Send(\" \")\n\n\t\t\t\t// attempt to select all (this shouldn't do anything)\n\t\t\t\tc.Send(string(terminal.KeyArrowRight))\n\n\t\t\t\t// end the session\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{ // we should only have one option selected, not all of them\n\t\t\t\t{Value: \"green\", Index: 0},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTestRemoveSelectAll(t, test)\n\t\t})\n\t}\n}\n\nfunc TestMultiSelectPromptRemoveSelectNone(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"multi select with remove select none option\",\n\t\t\t&MultiSelect{\n\t\t\t\tMessage: \"What color do you prefer:\",\n\t\t\t\tOptions: []string{\"green\", \"red\", \"light-green\", \"blue\", \"black\", \"yellow\", \"purple\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What color do you prefer:  [Use arrows to move, space to select, <right> to all, type to filter]\")\n\t\t\t\t// Select the first option \"green\"\n\t\t\t\tc.Send(\" \")\n\n\t\t\t\t// attempt to unselect all (this shouldn't do anything)\n\t\t\t\tc.Send(string(terminal.KeyArrowLeft))\n\n\t\t\t\t// end the session\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t[]core.OptionAnswer{ // we should only have one option selected, not all of them\n\t\t\t\t{Value: \"green\", Index: 0},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTestRemoveSelectNone(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "password.go",
          "type": "blob",
          "size": 2.4873046875,
          "content": "package survey\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\n/*\nPassword is like a normal Input but the text shows up as *'s and there is no default. Response\ntype is a string.\n\n\tpassword := \"\"\n\tprompt := &survey.Password{ Message: \"Please type your password\" }\n\tsurvey.AskOne(prompt, &password)\n*/\ntype Password struct {\n\tRenderer\n\tMessage string\n\tHelp    string\n}\n\ntype PasswordTemplateData struct {\n\tPassword\n\tShowHelp bool\n\tConfig   *PromptConfig\n}\n\n// PasswordQuestionTemplate is a template with color formatting. See Documentation: https://github.com/mgutz/ansi#style-format\nvar PasswordQuestionTemplate = `\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }} {{color \"reset\"}}\n{{- if and .Help (not .ShowHelp)}}{{color \"cyan\"}}[{{ .Config.HelpInput }} for help]{{color \"reset\"}} {{end}}`\n\nfunc (p *Password) Prompt(config *PromptConfig) (interface{}, error) {\n\t// render the question template\n\tuserOut, _, err := core.RunTemplate(\n\t\tPasswordQuestionTemplate,\n\t\tPasswordTemplateData{\n\t\t\tPassword: *p,\n\t\t\tConfig:   config,\n\t\t},\n\t)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif _, err := fmt.Fprint(terminal.NewAnsiStdout(p.Stdio().Out), userOut); err != nil {\n\t\treturn \"\", err\n\t}\n\n\trr := p.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\n\t// no help msg?  Just return any response\n\tif p.Help == \"\" {\n\t\tline, err := rr.ReadLine(config.HideCharacter)\n\t\treturn string(line), err\n\t}\n\n\tcursor := p.NewCursor()\n\n\tvar line []rune\n\t// process answers looking for help prompt answer\n\tfor {\n\t\tline, err = rr.ReadLine(config.HideCharacter)\n\t\tif err != nil {\n\t\t\treturn string(line), err\n\t\t}\n\n\t\tif string(line) == config.HelpInput {\n\t\t\t// terminal will echo the \\n so we need to jump back up one row\n\t\t\tcursor.PreviousLine(1)\n\n\t\t\terr = p.Render(\n\t\t\t\tPasswordQuestionTemplate,\n\t\t\t\tPasswordTemplateData{\n\t\t\t\t\tPassword: *p,\n\t\t\t\t\tShowHelp: true,\n\t\t\t\t\tConfig:   config,\n\t\t\t\t},\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn \"\", err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tbreak\n\t}\n\n\tlineStr := string(line)\n\tp.AppendRenderedText(strings.Repeat(string(config.HideCharacter), len(lineStr)))\n\treturn lineStr, err\n}\n\n// Cleanup hides the string with a fixed number of characters.\nfunc (prompt *Password) Cleanup(config *PromptConfig, val interface{}) error {\n\treturn nil\n}\n"
        },
        {
          "name": "password_test.go",
          "type": "blob",
          "size": 2.212890625,
          "content": "package survey\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestPasswordRender(t *testing.T) {\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   Password\n\t\tdata     PasswordTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"Test Password question output\",\n\t\t\tPassword{Message: \"Tell me your secret:\"},\n\t\t\tPasswordTemplateData{},\n\t\t\tfmt.Sprintf(\"%s Tell me your secret: \", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Password question output with help hidden\",\n\t\t\tPassword{Message: \"Tell me your secret:\", Help: \"This is helpful\"},\n\t\t\tPasswordTemplateData{},\n\t\t\tfmt.Sprintf(\"%s Tell me your secret: [%s for help] \", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t},\n\t\t{\n\t\t\t\"Test Password question output with help shown\",\n\t\t\tPassword{Message: \"Tell me your secret:\", Help: \"This is helpful\"},\n\t\t\tPasswordTemplateData{ShowHelp: true},\n\t\t\tfmt.Sprintf(\"%s This is helpful\\n%s Tell me your secret: \", defaultIcons().Help.Text, defaultIcons().Question.Text),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttest.data.Password = test.prompt\n\n\t\t// set the icon set\n\t\ttest.data.Config = defaultPromptConfig()\n\n\t\tactual, _, err := core.RunTemplate(\n\t\t\tPasswordQuestionTemplate,\n\t\t\t&test.data,\n\t\t)\n\t\tassert.Nil(t, err, test.title)\n\t\tassert.Equal(t, test.expected, actual, test.title)\n\t}\n}\n\nfunc TestPasswordPrompt(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"Test Password prompt interaction\",\n\t\t\t&Password{\n\t\t\t\tMessage: \"Please type your password\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Please type your password\")\n\t\t\t\tc.Send(\"secret\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"secret\",\n\t\t},\n\t\t{\n\t\t\t\"Test Password prompt interaction with help\",\n\t\t\t&Password{\n\t\t\t\tMessage: \"Please type your password\",\n\t\t\t\tHelp:    \"It's a secret\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Please type your password\")\n\t\t\t\tc.SendLine(\"?\")\n\t\t\t\tc.ExpectString(\"It's a secret\")\n\t\t\t\tc.Send(\"secret\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\t\"secret\",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "renderer.go",
          "type": "blob",
          "size": 4.9052734375,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\t\"golang.org/x/term\"\n)\n\ntype Renderer struct {\n\tstdio          terminal.Stdio\n\trenderedErrors bytes.Buffer\n\trenderedText   bytes.Buffer\n}\n\ntype ErrorTemplateData struct {\n\tError error\n\tIcon  Icon\n}\n\nvar ErrorTemplate = `{{color .Icon.Format }}{{ .Icon.Text }} Sorry, your reply was invalid: {{ .Error.Error }}{{color \"reset\"}}\n`\n\nfunc (r *Renderer) WithStdio(stdio terminal.Stdio) {\n\tr.stdio = stdio\n}\n\nfunc (r *Renderer) Stdio() terminal.Stdio {\n\treturn r.stdio\n}\n\nfunc (r *Renderer) NewRuneReader() *terminal.RuneReader {\n\treturn terminal.NewRuneReader(r.stdio)\n}\n\nfunc (r *Renderer) NewCursor() *terminal.Cursor {\n\treturn &terminal.Cursor{\n\t\tIn:  r.stdio.In,\n\t\tOut: r.stdio.Out,\n\t}\n}\n\nfunc (r *Renderer) Error(config *PromptConfig, invalid error) error {\n\t// cleanup the currently rendered errors\n\tr.resetPrompt(r.countLines(r.renderedErrors))\n\tr.renderedErrors.Reset()\n\n\t// cleanup the rest of the prompt\n\tr.resetPrompt(r.countLines(r.renderedText))\n\tr.renderedText.Reset()\n\n\tuserOut, layoutOut, err := core.RunTemplate(ErrorTemplate, &ErrorTemplateData{\n\t\tError: invalid,\n\t\tIcon:  config.Icons.Error,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// send the message to the user\n\tif _, err := fmt.Fprint(terminal.NewAnsiStdout(r.stdio.Out), userOut); err != nil {\n\t\treturn err\n\t}\n\n\t// add the printed text to the rendered error buffer so we can cleanup later\n\tr.appendRenderedError(layoutOut)\n\n\treturn nil\n}\n\nfunc (r *Renderer) OffsetCursor(offset int) {\n\tcursor := r.NewCursor()\n\tfor offset > 0 {\n\t\tcursor.PreviousLine(1)\n\t\toffset--\n\t}\n}\n\nfunc (r *Renderer) Render(tmpl string, data interface{}) error {\n\t// cleanup the currently rendered text\n\tlineCount := r.countLines(r.renderedText)\n\tr.resetPrompt(lineCount)\n\tr.renderedText.Reset()\n\n\t// render the template summarizing the current state\n\tuserOut, layoutOut, err := core.RunTemplate(tmpl, data)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// print the summary\n\tif _, err := fmt.Fprint(terminal.NewAnsiStdout(r.stdio.Out), userOut); err != nil {\n\t\treturn err\n\t}\n\n\t// add the printed text to the rendered text buffer so we can cleanup later\n\tr.AppendRenderedText(layoutOut)\n\n\t// nothing went wrong\n\treturn nil\n}\n\nfunc (r *Renderer) RenderWithCursorOffset(tmpl string, data IterableOpts, opts []core.OptionAnswer, idx int) error {\n\tcursor := r.NewCursor()\n\tcursor.Restore() // clear any accessibility offsetting\n\n\tif err := r.Render(tmpl, data); err != nil {\n\t\treturn err\n\t}\n\tcursor.Save()\n\n\toffset := computeCursorOffset(MultiSelectQuestionTemplate, data, opts, idx, r.termWidthSafe())\n\tr.OffsetCursor(offset)\n\n\treturn nil\n}\n\n// appendRenderedError appends text to the renderer's error buffer\n// which is used to track what has been printed. It is not exported\n// as errors should only be displayed via Error(config, error).\nfunc (r *Renderer) appendRenderedError(text string) {\n\tr.renderedErrors.WriteString(text)\n}\n\n// AppendRenderedText appends text to the renderer's text buffer\n// which is used to track of what has been printed. The buffer is used\n// to calculate how many lines to erase before updating the prompt.\nfunc (r *Renderer) AppendRenderedText(text string) {\n\tr.renderedText.WriteString(text)\n}\n\nfunc (r *Renderer) resetPrompt(lines int) {\n\t// clean out current line in case tmpl didnt end in newline\n\tcursor := r.NewCursor()\n\tcursor.HorizontalAbsolute(0)\n\tterminal.EraseLine(r.stdio.Out, terminal.ERASE_LINE_ALL)\n\t// clean up what we left behind last time\n\tfor i := 0; i < lines; i++ {\n\t\tcursor.PreviousLine(1)\n\t\tterminal.EraseLine(r.stdio.Out, terminal.ERASE_LINE_ALL)\n\t}\n}\n\nfunc (r *Renderer) termWidth() (int, error) {\n\tfd := int(r.stdio.Out.Fd())\n\ttermWidth, _, err := term.GetSize(fd)\n\treturn termWidth, err\n}\n\nfunc (r *Renderer) termWidthSafe() int {\n\tw, err := r.termWidth()\n\tif err != nil || w == 0 {\n\t\t// if we got an error due to terminal.GetSize not being supported\n\t\t// on current platform then just assume a very wide terminal\n\t\tw = 10000\n\t}\n\treturn w\n}\n\n// countLines will return the count of `\\n` with the addition of any\n// lines that have wrapped due to narrow terminal width\nfunc (r *Renderer) countLines(buf bytes.Buffer) int {\n\tw := r.termWidthSafe()\n\n\tbufBytes := buf.Bytes()\n\n\tcount := 0\n\tcurr := 0\n\tfor curr < len(bufBytes) {\n\t\tvar delim int\n\t\t// read until the next newline or the end of the string\n\t\trelDelim := bytes.IndexRune(bufBytes[curr:], '\\n')\n\t\tif relDelim != -1 {\n\t\t\tcount += 1 // new line found, add it to the count\n\t\t\tdelim = curr + relDelim\n\t\t} else {\n\t\t\tdelim = len(bufBytes) // no new line found, read rest of text\n\t\t}\n\n\t\tstr := string(bufBytes[curr:delim])\n\t\tif lineWidth := terminal.StringWidth(str); lineWidth > w {\n\t\t\t// account for word wrapping\n\t\t\tcount += lineWidth / w\n\t\t\tif (lineWidth % w) == 0 {\n\t\t\t\t// content whose width is exactly a multiplier of available width should not\n\t\t\t\t// count as having wrapped on the last line\n\t\t\t\tcount -= 1\n\t\t\t}\n\t\t}\n\t\tcurr = delim + 1\n\t}\n\n\treturn count\n}\n"
        },
        {
          "name": "renderer_posix_test.go",
          "type": "blob",
          "size": 1.677734375,
          "content": "//go:build !windows\n// +build !windows\n\npackage survey\n\nimport (\n\t\"bytes\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\tpseudotty \"github.com/creack/pty\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestRenderer_countLines(t *testing.T) {\n\tt.Parallel()\n\n\ttermWidth := 72\n\tpty, tty, err := pseudotty.Open()\n\trequire.Nil(t, err)\n\tdefer pty.Close()\n\tdefer tty.Close()\n\n\terr = pseudotty.Setsize(tty, &pseudotty.Winsize{\n\t\tRows: 30,\n\t\tCols: uint16(termWidth),\n\t})\n\trequire.Nil(t, err)\n\n\tr := Renderer{\n\t\tstdio: terminal.Stdio{\n\t\t\tIn:  tty,\n\t\t\tOut: tty,\n\t\t\tErr: tty,\n\t\t},\n\t}\n\n\ttests := []struct {\n\t\tname  string\n\t\tbuf   *bytes.Buffer\n\t\twants int\n\t}{\n\t\t{\n\t\t\tname:  \"empty\",\n\t\t\tbuf:   new(bytes.Buffer),\n\t\t\twants: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"no newline\",\n\t\t\tbuf:   bytes.NewBufferString(\"hello\"),\n\t\t\twants: 0,\n\t\t},\n\t\t{\n\t\t\tname:  \"short line\",\n\t\t\tbuf:   bytes.NewBufferString(\"hello\\n\"),\n\t\t\twants: 1,\n\t\t},\n\t\t{\n\t\t\tname:  \"three short lines\",\n\t\t\tbuf:   bytes.NewBufferString(\"hello\\nbeautiful\\nworld\\n\"),\n\t\t\twants: 3,\n\t\t},\n\t\t{\n\t\t\tname:  \"full line\",\n\t\t\tbuf:   bytes.NewBufferString(strings.Repeat(\"A\", termWidth) + \"\\n\"),\n\t\t\twants: 1,\n\t\t},\n\t\t{\n\t\t\tname:  \"overflow\",\n\t\t\tbuf:   bytes.NewBufferString(strings.Repeat(\"A\", termWidth+1) + \"\\n\"),\n\t\t\twants: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"overflow fills 2nd line\",\n\t\t\tbuf:   bytes.NewBufferString(strings.Repeat(\"A\", termWidth*2) + \"\\n\"),\n\t\t\twants: 2,\n\t\t},\n\t\t{\n\t\t\tname:  \"overflow spills to 3rd line\",\n\t\t\tbuf:   bytes.NewBufferString(strings.Repeat(\"A\", termWidth*2+1) + \"\\n\"),\n\t\t\twants: 3,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tn := r.countLines(*tt.buf)\n\t\t\tassert.Equal(t, tt.wants, n)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "renderer_test.go",
          "type": "blob",
          "size": 0.63671875,
          "content": "package survey\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n)\n\nfunc TestValidationError(t *testing.T) {\n\n\terr := fmt.Errorf(\"Football is not a valid month\")\n\n\tactual, _, err := core.RunTemplate(\n\t\tErrorTemplate,\n\t\t&ErrorTemplateData{\n\t\t\tError: err,\n\t\t\tIcon:  defaultIcons().Error,\n\t\t},\n\t)\n\tif err != nil {\n\t\tt.Errorf(\"Failed to run template to format error: %s\", err)\n\t}\n\n\texpected := fmt.Sprintf(\"%s Sorry, your reply was invalid: Football is not a valid month\\n\", defaultIcons().Error.Text)\n\n\tif actual != expected {\n\t\tt.Errorf(\"Formatted error was not formatted correctly. Found:\\n%s\\nExpected:\\n%s\", actual, expected)\n\t}\n}\n"
        },
        {
          "name": "select.go",
          "type": "blob",
          "size": 8.921875,
          "content": "package survey\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\n/*\nSelect is a prompt that presents a list of various options to the user\nfor them to select using the arrow keys and enter. Response type is a string.\n\n\tcolor := \"\"\n\tprompt := &survey.Select{\n\t\tMessage: \"Choose a color:\",\n\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t}\n\tsurvey.AskOne(prompt, &color)\n*/\ntype Select struct {\n\tRenderer\n\tMessage       string\n\tOptions       []string\n\tDefault       interface{}\n\tHelp          string\n\tPageSize      int\n\tVimMode       bool\n\tFilterMessage string\n\tFilter        func(filter string, value string, index int) bool\n\tDescription   func(value string, index int) string\n\tfilter        string\n\tselectedIndex int\n\tshowingHelp   bool\n}\n\n// SelectTemplateData is the data available to the templates when processing\ntype SelectTemplateData struct {\n\tSelect\n\tPageEntries   []core.OptionAnswer\n\tSelectedIndex int\n\tAnswer        string\n\tShowAnswer    bool\n\tShowHelp      bool\n\tDescription   func(value string, index int) string\n\tConfig        *PromptConfig\n\n\t// These fields are used when rendering an individual option\n\tCurrentOpt   core.OptionAnswer\n\tCurrentIndex int\n}\n\n// IterateOption sets CurrentOpt and CurrentIndex appropriately so a select option can be rendered individually\nfunc (s SelectTemplateData) IterateOption(ix int, opt core.OptionAnswer) interface{} {\n\tcopy := s\n\tcopy.CurrentIndex = ix\n\tcopy.CurrentOpt = opt\n\treturn copy\n}\n\nfunc (s SelectTemplateData) GetDescription(opt core.OptionAnswer) string {\n\tif s.Description == nil {\n\t\treturn \"\"\n\t}\n\treturn s.Description(opt.Value, opt.Index)\n}\n\nvar SelectQuestionTemplate = `\n{{- define \"option\"}}\n    {{- if eq .SelectedIndex .CurrentIndex }}{{color .Config.Icons.SelectFocus.Format }}{{ .Config.Icons.SelectFocus.Text }} {{else}}{{color \"default\"}}  {{end}}\n    {{- .CurrentOpt.Value}}{{ if ne ($.GetDescription .CurrentOpt) \"\" }} - {{color \"cyan\"}}{{ $.GetDescription .CurrentOpt }}{{end}}\n    {{- color \"reset\"}}\n{{end}}\n{{- if .ShowHelp }}{{- color .Config.Icons.Help.Format }}{{ .Config.Icons.Help.Text }} {{ .Help }}{{color \"reset\"}}{{\"\\n\"}}{{end}}\n{{- color .Config.Icons.Question.Format }}{{ .Config.Icons.Question.Text }} {{color \"reset\"}}\n{{- color \"default+hb\"}}{{ .Message }}{{ .FilterMessage }}{{color \"reset\"}}\n{{- if .ShowAnswer}}{{color \"cyan\"}} {{.Answer}}{{color \"reset\"}}{{\"\\n\"}}\n{{- else}}\n  {{- \"  \"}}{{- color \"cyan\"}}[Use arrows to move, type to filter{{- if and .Help (not .ShowHelp)}}, {{ .Config.HelpInput }} for more help{{end}}]{{color \"reset\"}}\n  {{- \"\\n\"}}\n  {{- range $ix, $option := .PageEntries}}\n    {{- template \"option\" $.IterateOption $ix $option}}\n  {{- end}}\n{{- end}}`\n\n// OnChange is called on every keypress.\nfunc (s *Select) OnChange(key rune, config *PromptConfig) bool {\n\toptions := s.filterOptions(config)\n\toldFilter := s.filter\n\n\t// if the user pressed the enter key and the index is a valid option\n\tif key == terminal.KeyEnter || key == '\\n' {\n\t\t// if the selected index is a valid option\n\t\tif len(options) > 0 && s.selectedIndex < len(options) {\n\n\t\t\t// we're done (stop prompting the user)\n\t\t\treturn true\n\t\t}\n\n\t\t// we're not done (keep prompting)\n\t\treturn false\n\n\t\t// if the user pressed the up arrow or 'k' to emulate vim\n\t} else if (key == terminal.KeyArrowUp || (s.VimMode && key == 'k')) && len(options) > 0 {\n\t\t// if we are at the top of the list\n\t\tif s.selectedIndex == 0 {\n\t\t\t// start from the button\n\t\t\ts.selectedIndex = len(options) - 1\n\t\t} else {\n\t\t\t// otherwise we are not at the top of the list so decrement the selected index\n\t\t\ts.selectedIndex--\n\t\t}\n\n\t\t// if the user pressed down or 'j' to emulate vim\n\t} else if (key == terminal.KeyTab || key == terminal.KeyArrowDown || (s.VimMode && key == 'j')) && len(options) > 0 {\n\t\t// if we are at the bottom of the list\n\t\tif s.selectedIndex == len(options)-1 {\n\t\t\t// start from the top\n\t\t\ts.selectedIndex = 0\n\t\t} else {\n\t\t\t// increment the selected index\n\t\t\ts.selectedIndex++\n\t\t}\n\t\t// only show the help message if we have one\n\t} else if string(key) == config.HelpInput && s.Help != \"\" {\n\t\ts.showingHelp = true\n\t\t// if the user wants to toggle vim mode on/off\n\t} else if key == terminal.KeyEscape {\n\t\ts.VimMode = !s.VimMode\n\t\t// if the user hits any of the keys that clear the filter\n\t} else if key == terminal.KeyDeleteWord || key == terminal.KeyDeleteLine {\n\t\ts.filter = \"\"\n\t\t// if the user is deleting a character in the filter\n\t} else if key == terminal.KeyDelete || key == terminal.KeyBackspace {\n\t\t// if there is content in the filter to delete\n\t\tif s.filter != \"\" {\n\t\t\truneFilter := []rune(s.filter)\n\t\t\t// subtract a line from the current filter\n\t\t\ts.filter = string(runeFilter[0 : len(runeFilter)-1])\n\t\t\t// we removed the last value in the filter\n\t\t}\n\t} else if key >= terminal.KeySpace {\n\t\ts.filter += string(key)\n\t\t// make sure vim mode is disabled\n\t\ts.VimMode = false\n\t}\n\n\ts.FilterMessage = \"\"\n\tif s.filter != \"\" {\n\t\ts.FilterMessage = \" \" + s.filter\n\t}\n\tif oldFilter != s.filter {\n\t\t// filter changed\n\t\toptions = s.filterOptions(config)\n\t\tif len(options) > 0 && len(options) <= s.selectedIndex {\n\t\t\ts.selectedIndex = len(options) - 1\n\t\t}\n\t}\n\n\t// figure out the options and index to render\n\t// figure out the page size\n\tpageSize := s.PageSize\n\t// if we dont have a specific one\n\tif pageSize == 0 {\n\t\t// grab the global value\n\t\tpageSize = config.PageSize\n\t}\n\n\t// TODO if we have started filtering and were looking at the end of a list\n\t// and we have modified the filter then we should move the page back!\n\topts, idx := paginate(pageSize, options, s.selectedIndex)\n\n\ttmplData := SelectTemplateData{\n\t\tSelect:        *s,\n\t\tSelectedIndex: idx,\n\t\tShowHelp:      s.showingHelp,\n\t\tDescription:   s.Description,\n\t\tPageEntries:   opts,\n\t\tConfig:        config,\n\t}\n\n\t// render the options\n\t_ = s.RenderWithCursorOffset(SelectQuestionTemplate, tmplData, opts, idx)\n\n\t// keep prompting\n\treturn false\n}\n\nfunc (s *Select) filterOptions(config *PromptConfig) []core.OptionAnswer {\n\t// the filtered list\n\tanswers := []core.OptionAnswer{}\n\n\t// if there is no filter applied\n\tif s.filter == \"\" {\n\t\treturn core.OptionAnswerList(s.Options)\n\t}\n\n\t// the filter to apply\n\tfilter := s.Filter\n\tif filter == nil {\n\t\tfilter = config.Filter\n\t}\n\n\tfor i, opt := range s.Options {\n\t\t// i the filter says to include the option\n\t\tif filter(s.filter, opt, i) {\n\t\t\tanswers = append(answers, core.OptionAnswer{\n\t\t\t\tIndex: i,\n\t\t\t\tValue: opt,\n\t\t\t})\n\t\t}\n\t}\n\n\t// return the list of answers\n\treturn answers\n}\n\nfunc (s *Select) Prompt(config *PromptConfig) (interface{}, error) {\n\t// if there are no options to render\n\tif len(s.Options) == 0 {\n\t\t// we failed\n\t\treturn \"\", errors.New(\"please provide options to select from\")\n\t}\n\n\ts.selectedIndex = 0\n\tif s.Default != nil {\n\t\tswitch defaultValue := s.Default.(type) {\n\t\tcase string:\n\t\t\tvar found bool\n\t\t\tfor i, opt := range s.Options {\n\t\t\t\tif opt == defaultValue {\n\t\t\t\t\ts.selectedIndex = i\n\t\t\t\t\tfound = true\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !found {\n\t\t\t\treturn \"\", fmt.Errorf(\"default value %q not found in options\", defaultValue)\n\t\t\t}\n\t\tcase int:\n\t\t\tif defaultValue >= len(s.Options) {\n\t\t\t\treturn \"\", fmt.Errorf(\"default index %d exceeds the number of options\", defaultValue)\n\t\t\t}\n\t\t\ts.selectedIndex = defaultValue\n\t\tdefault:\n\t\t\treturn \"\", errors.New(\"default value of select must be an int or string\")\n\t\t}\n\t}\n\n\t// figure out the page size\n\tpageSize := s.PageSize\n\t// if we dont have a specific one\n\tif pageSize == 0 {\n\t\t// grab the global value\n\t\tpageSize = config.PageSize\n\t}\n\n\t// figure out the options and index to render\n\topts, idx := paginate(pageSize, core.OptionAnswerList(s.Options), s.selectedIndex)\n\n\tcursor := s.NewCursor()\n\tcursor.Save()          // for proper cursor placement during selection\n\tcursor.Hide()          // hide the cursor\n\tdefer cursor.Show()    // show the cursor when we're done\n\tdefer cursor.Restore() // clear any accessibility offsetting on exit\n\n\ttmplData := SelectTemplateData{\n\t\tSelect:        *s,\n\t\tSelectedIndex: idx,\n\t\tDescription:   s.Description,\n\t\tShowHelp:      s.showingHelp,\n\t\tPageEntries:   opts,\n\t\tConfig:        config,\n\t}\n\n\t// ask the question\n\terr := s.RenderWithCursorOffset(SelectQuestionTemplate, tmplData, opts, idx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\trr := s.NewRuneReader()\n\t_ = rr.SetTermMode()\n\tdefer func() {\n\t\t_ = rr.RestoreTermMode()\n\t}()\n\n\t// start waiting for input\n\tfor {\n\t\tr, _, err := rr.ReadRune()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif r == terminal.KeyInterrupt {\n\t\t\treturn \"\", terminal.InterruptErr\n\t\t}\n\t\tif r == terminal.KeyEndTransmission {\n\t\t\tbreak\n\t\t}\n\t\tif s.OnChange(r, config) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\toptions := s.filterOptions(config)\n\ts.filter = \"\"\n\ts.FilterMessage = \"\"\n\n\tif s.selectedIndex < len(options) {\n\t\treturn options[s.selectedIndex], err\n\t}\n\n\treturn options[0], err\n}\n\nfunc (s *Select) Cleanup(config *PromptConfig, val interface{}) error {\n\tcursor := s.NewCursor()\n\tcursor.Restore()\n\treturn s.Render(\n\t\tSelectQuestionTemplate,\n\t\tSelectTemplateData{\n\t\t\tSelect:      *s,\n\t\t\tAnswer:      val.(core.OptionAnswer).Value,\n\t\t\tShowAnswer:  true,\n\t\t\tDescription: s.Description,\n\t\t\tConfig:      config,\n\t\t},\n\t)\n}\n"
        },
        {
          "name": "select_test.go",
          "type": "blob",
          "size": 8.984375,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\nfunc TestSelectRender(t *testing.T) {\n\n\tprompt := Select{\n\t\tMessage: \"Pick your word:\",\n\t\tOptions: []string{\"foo\", \"bar\", \"baz\", \"buz\"},\n\t\tDefault: \"baz\",\n\t}\n\n\thelpfulPrompt := prompt\n\thelpfulPrompt.Help = \"This is helpful\"\n\n\ttests := []struct {\n\t\ttitle    string\n\t\tprompt   Select\n\t\tdata     SelectTemplateData\n\t\texpected string\n\t}{\n\t\t{\n\t\t\t\"Test Select question output\",\n\t\t\tprompt,\n\t\t\tSelectTemplateData{SelectedIndex: 2, PageEntries: core.OptionAnswerList(prompt.Options)},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your word:  [Use arrows to move, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\t\"  foo\",\n\t\t\t\t\t\"  bar\",\n\t\t\t\t\tfmt.Sprintf(\"%s baz\", defaultIcons().SelectFocus.Text),\n\t\t\t\t\t\"  buz\\n\",\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"Test Select answer output\",\n\t\t\tprompt,\n\t\t\tSelectTemplateData{Answer: \"buz\", ShowAnswer: true, PageEntries: core.OptionAnswerList(prompt.Options)},\n\t\t\tfmt.Sprintf(\"%s Pick your word: buz\\n\", defaultIcons().Question.Text),\n\t\t},\n\t\t{\n\t\t\t\"Test Select question output with help hidden\",\n\t\t\thelpfulPrompt,\n\t\t\tSelectTemplateData{SelectedIndex: 2, PageEntries: core.OptionAnswerList(prompt.Options)},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your word:  [Use arrows to move, type to filter, %s for more help]\", defaultIcons().Question.Text, string(defaultPromptConfig().HelpInput)),\n\t\t\t\t\t\"  foo\",\n\t\t\t\t\t\"  bar\",\n\t\t\t\t\tfmt.Sprintf(\"%s baz\", defaultIcons().SelectFocus.Text),\n\t\t\t\t\t\"  buz\\n\",\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t\t{\n\t\t\t\"Test Select question output with help shown\",\n\t\t\thelpfulPrompt,\n\t\t\tSelectTemplateData{SelectedIndex: 2, ShowHelp: true, PageEntries: core.OptionAnswerList(prompt.Options)},\n\t\t\tstrings.Join(\n\t\t\t\t[]string{\n\t\t\t\t\tfmt.Sprintf(\"%s This is helpful\", defaultIcons().Help.Text),\n\t\t\t\t\tfmt.Sprintf(\"%s Pick your word:  [Use arrows to move, type to filter]\", defaultIcons().Question.Text),\n\t\t\t\t\t\"  foo\",\n\t\t\t\t\t\"  bar\",\n\t\t\t\t\tfmt.Sprintf(\"%s baz\", defaultIcons().SelectFocus.Text),\n\t\t\t\t\t\"  buz\\n\",\n\t\t\t\t},\n\t\t\t\t\"\\n\",\n\t\t\t),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tt.Run(test.title, func(t *testing.T) {\n\t\t\tr, w, err := os.Pipe()\n\t\t\tassert.NoError(t, err)\n\n\t\t\ttest.prompt.WithStdio(terminal.Stdio{Out: w})\n\t\t\ttest.data.Select = test.prompt\n\n\t\t\t// set the icon set\n\t\t\ttest.data.Config = defaultPromptConfig()\n\n\t\t\terr = test.prompt.Render(\n\t\t\t\tSelectQuestionTemplate,\n\t\t\t\ttest.data,\n\t\t\t)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.NoError(t, w.Close())\n\t\t\tvar buf bytes.Buffer\n\t\t\t_, err = io.Copy(&buf, r)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Contains(t, buf.String(), test.expected)\n\t\t})\n\t}\n}\n\nfunc TestSelectPrompt(t *testing.T) {\n\ttests := []PromptTest{\n\t\t{\n\t\t\t\"basic interaction: blue\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select blue.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowDown))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 1, Value: \"blue\"},\n\t\t},\n\t\t{\n\t\t\t\"basic interaction: green\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select blue.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\t// Select green.\n\t\t\t\tc.SendLine(string(terminal.KeyTab))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"default value\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tDefault: \"green\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select green.\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"default index\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tDefault: 2,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select green.\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"overriding default\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tDefault: \"blue\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select red.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowUp))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 0, Value: \"red\"},\n\t\t},\n\t\t{\n\t\t\t\"SKIP: prompt for help\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tHelp:    \"My favourite color is red\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\tc.SendLine(\"?\")\n\t\t\t\tc.ExpectString(\"My favourite color is red\")\n\t\t\t\t// Select red.\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 0, Value: \"red\"},\n\t\t},\n\t\t{\n\t\t\t\"PageSize\",\n\t\t\t&Select{\n\t\t\t\tMessage:  \"Choose a color:\",\n\t\t\t\tOptions:  []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tPageSize: 1,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select green.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowUp))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"vim mode\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tVimMode: true,\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Select blue.\n\t\t\t\tc.SendLine(\"j\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 1, Value: \"blue\"},\n\t\t},\n\t\t{\n\t\t\t\"filter\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Filter down to red and green.\n\t\t\t\tc.Send(\"re\")\n\t\t\t\t// Select green.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowDown))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"filter is case-insensitive\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Filter down to red and green.\n\t\t\t\tc.Send(\"RE\")\n\t\t\t\t// Select green.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowDown))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"Can select the first result in a filtered list if there is a default\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tDefault: \"blue\",\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Make sure only red is showing\n\t\t\t\tc.SendLine(\"red\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 0, Value: \"red\"},\n\t\t},\n\t\t{\n\t\t\t\"custom filter\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t\tFilter: func(filter string, optValue string, optIndex int) (filtered bool) {\n\t\t\t\t\treturn len(optValue) >= 5\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Filter down to only green since custom filter only keeps options that are longer than 5 runes\n\t\t\t\tc.SendLine(\"re\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"green\"},\n\t\t},\n\t\t{\n\t\t\t\"answers filtered out\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// filter away everything\n\t\t\t\tc.SendLine(\"z\")\n\t\t\t\t// send enter (should get ignored since there are no answers)\n\t\t\t\tc.SendLine(string(terminal.KeyEnter))\n\n\t\t\t\t// remove the filter we just applied\n\t\t\t\tc.SendLine(string(terminal.KeyBackspace))\n\n\t\t\t\t// press enter\n\t\t\t\tc.SendLine(string(terminal.KeyEnter))\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 0, Value: \"red\"},\n\t\t},\n\t\t{\n\t\t\t\"delete filter word\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\tOptions: []string{\"red\", \"blue\", \"black\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"Choose a color:\")\n\t\t\t\t// Filter down to blue.\n\t\t\t\tc.Send(\"blu\")\n\t\t\t\t// Filter down to blue and black.\n\t\t\t\tc.Send(string(terminal.KeyDelete))\n\t\t\t\t// Select black.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowDown))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"black\"},\n\t\t},\n\t\t{\n\t\t\t\"delete filter word in rune\",\n\t\t\t&Select{\n\t\t\t\tMessage: \"‰ªäÂ§©‰∏≠ÂçàÂêÉ‰ªÄ‰πàÔºü\",\n\t\t\t\tOptions: []string{\"ÈùíÊ§íÁâõËÇâ‰∏ù\", \"Â∞èÁÇíËÇâ\", \"Â∞èÁÖéÈ∏°\"},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"‰ªäÂ§©‰∏≠ÂçàÂêÉ‰ªÄ‰πàÔºü\")\n\t\t\t\t// Filter down to Â∞èÁÇíËÇâ.\n\t\t\t\tc.Send(\"Â∞èÁÇí\")\n\t\t\t\t// Filter down to Â∞èÁÇíËÇâ and Â∞èÁÖéÈ∏°.\n\t\t\t\tc.Send(string(terminal.KeyBackspace))\n\t\t\t\t// Select Â∞èÁÖéÈ∏°.\n\t\t\t\tc.SendLine(string(terminal.KeyArrowDown))\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tcore.OptionAnswer{Index: 2, Value: \"Â∞èÁÖéÈ∏°\"},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\ttestName := strings.TrimPrefix(test.name, \"SKIP: \")\n\t\tt.Run(testName, func(t *testing.T) {\n\t\t\tif testName != test.name {\n\t\t\t\tt.Skipf(\"warning: flakey test %q\", testName)\n\t\t\t}\n\t\t\tRunPromptTest(t, test)\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "survey.go",
          "type": "blob",
          "size": 11.6904296875,
          "content": "package survey\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\n// DefaultAskOptions is the default options on ask, using the OS stdio.\nfunc defaultAskOptions() *AskOptions {\n\treturn &AskOptions{\n\t\tStdio: terminal.Stdio{\n\t\t\tIn:  os.Stdin,\n\t\t\tOut: os.Stdout,\n\t\t\tErr: os.Stderr,\n\t\t},\n\t\tPromptConfig: PromptConfig{\n\t\t\tPageSize:     7,\n\t\t\tHelpInput:    \"?\",\n\t\t\tSuggestInput: \"tab\",\n\t\t\tIcons: IconSet{\n\t\t\t\tError: Icon{\n\t\t\t\t\tText:   \"X\",\n\t\t\t\t\tFormat: \"red\",\n\t\t\t\t},\n\t\t\t\tHelp: Icon{\n\t\t\t\t\tText:   \"?\",\n\t\t\t\t\tFormat: \"cyan\",\n\t\t\t\t},\n\t\t\t\tQuestion: Icon{\n\t\t\t\t\tText:   \"?\",\n\t\t\t\t\tFormat: \"green+hb\",\n\t\t\t\t},\n\t\t\t\tMarkedOption: Icon{\n\t\t\t\t\tText:   \"[x]\",\n\t\t\t\t\tFormat: \"green\",\n\t\t\t\t},\n\t\t\t\tUnmarkedOption: Icon{\n\t\t\t\t\tText:   \"[ ]\",\n\t\t\t\t\tFormat: \"default+hb\",\n\t\t\t\t},\n\t\t\t\tSelectFocus: Icon{\n\t\t\t\t\tText:   \">\",\n\t\t\t\t\tFormat: \"cyan+b\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tFilter: func(filter string, value string, index int) (include bool) {\n\t\t\t\tfilter = strings.ToLower(filter)\n\n\t\t\t\t// include this option if it matches\n\t\t\t\treturn strings.Contains(strings.ToLower(value), filter)\n\t\t\t},\n\t\t\tKeepFilter:       false,\n\t\t\tShowCursor:       false,\n\t\t\tRemoveSelectAll:  false,\n\t\t\tRemoveSelectNone: false,\n\t\t\tHideCharacter:    '*',\n\t\t},\n\t}\n}\nfunc defaultPromptConfig() *PromptConfig {\n\treturn &defaultAskOptions().PromptConfig\n}\n\nfunc defaultIcons() *IconSet {\n\treturn &defaultPromptConfig().Icons\n}\n\n// OptionAnswer is an ergonomic alias for core.OptionAnswer\ntype OptionAnswer = core.OptionAnswer\n\n// Icon holds the text and format to show for a particular icon\ntype Icon struct {\n\tText   string\n\tFormat string\n}\n\n// IconSet holds the icons to use for various prompts\ntype IconSet struct {\n\tHelpInput      Icon\n\tError          Icon\n\tHelp           Icon\n\tQuestion       Icon\n\tMarkedOption   Icon\n\tUnmarkedOption Icon\n\tSelectFocus    Icon\n}\n\n// Validator is a function passed to a Question after a user has provided a response.\n// If the function returns an error, then the user will be prompted again for another\n// response.\ntype Validator func(ans interface{}) error\n\n// Transformer is a function passed to a Question after a user has provided a response.\n// The function can be used to implement a custom logic that will result to return\n// a different representation of the given answer.\n//\n// Look `TransformString`, `ToLower` `Title` and `ComposeTransformers` for more.\ntype Transformer func(ans interface{}) (newAns interface{})\n\n// Question is the core data structure for a survey questionnaire.\ntype Question struct {\n\tName      string\n\tPrompt    Prompt\n\tValidate  Validator\n\tTransform Transformer\n}\n\n// PromptConfig holds the global configuration for a prompt\ntype PromptConfig struct {\n\tPageSize         int\n\tIcons            IconSet\n\tHelpInput        string\n\tSuggestInput     string\n\tFilter           func(filter string, option string, index int) bool\n\tKeepFilter       bool\n\tShowCursor       bool\n\tRemoveSelectAll  bool\n\tRemoveSelectNone bool\n\tHideCharacter    rune\n}\n\n// Prompt is the primary interface for the objects that can take user input\n// and return a response.\ntype Prompt interface {\n\tPrompt(config *PromptConfig) (interface{}, error)\n\tCleanup(*PromptConfig, interface{}) error\n\tError(*PromptConfig, error) error\n}\n\n// PromptAgainer Interface for Prompts that support prompting again after invalid input\ntype PromptAgainer interface {\n\tPromptAgain(config *PromptConfig, invalid interface{}, err error) (interface{}, error)\n}\n\n// AskOpt allows setting optional ask options.\ntype AskOpt func(options *AskOptions) error\n\n// AskOptions provides additional options on ask.\ntype AskOptions struct {\n\tStdio        terminal.Stdio\n\tValidators   []Validator\n\tPromptConfig PromptConfig\n}\n\n// WithStdio specifies the standard input, output and error files survey\n// interacts with. By default, these are os.Stdin, os.Stdout, and os.Stderr.\nfunc WithStdio(in terminal.FileReader, out terminal.FileWriter, err io.Writer) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\toptions.Stdio.In = in\n\t\toptions.Stdio.Out = out\n\t\toptions.Stdio.Err = err\n\t\treturn nil\n\t}\n}\n\n// WithFilter specifies the default filter to use when asking questions.\nfunc WithFilter(filter func(filter string, value string, index int) (include bool)) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// save the filter internally\n\t\toptions.PromptConfig.Filter = filter\n\n\t\treturn nil\n\t}\n}\n\n// WithKeepFilter sets the if the filter is kept after selections\nfunc WithKeepFilter(KeepFilter bool) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// set the page size\n\t\toptions.PromptConfig.KeepFilter = KeepFilter\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\n// WithRemoveSelectAll remove the select all option in Multiselect\nfunc WithRemoveSelectAll() AskOpt {\n\treturn func(options *AskOptions) error {\n\t\toptions.PromptConfig.RemoveSelectAll = true\n\t\treturn nil\n\t}\n}\n\n// WithRemoveSelectNone remove the select none/unselect all in Multiselect\nfunc WithRemoveSelectNone() AskOpt {\n\treturn func(options *AskOptions) error {\n\t\toptions.PromptConfig.RemoveSelectNone = true\n\t\treturn nil\n\t}\n}\n\n// WithValidator specifies a validator to use while prompting the user\nfunc WithValidator(v Validator) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// add the provided validator to the list\n\t\toptions.Validators = append(options.Validators, v)\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\ntype wantsStdio interface {\n\tWithStdio(terminal.Stdio)\n}\n\n// WithPageSize sets the default page size used by prompts\nfunc WithPageSize(pageSize int) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// set the page size\n\t\toptions.PromptConfig.PageSize = pageSize\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\n// WithHelpInput changes the character that prompts look for to give the user helpful information.\nfunc WithHelpInput(r rune) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// set the input character\n\t\toptions.PromptConfig.HelpInput = string(r)\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\n// WithIcons sets the icons that will be used when prompting the user\nfunc WithIcons(setIcons func(*IconSet)) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// update the default icons with whatever the user says\n\t\tsetIcons(&options.PromptConfig.Icons)\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\n// WithShowCursor sets the show cursor behavior when prompting the user\nfunc WithShowCursor(ShowCursor bool) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// set the page size\n\t\toptions.PromptConfig.ShowCursor = ShowCursor\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\n// WithHideCharacter sets the default character shown instead of the password for password inputs\nfunc WithHideCharacter(char rune) AskOpt {\n\treturn func(options *AskOptions) error {\n\t\t// set the hide character\n\t\toptions.PromptConfig.HideCharacter = char\n\n\t\t// nothing went wrong\n\t\treturn nil\n\t}\n}\n\n/*\nAskOne performs the prompt for a single prompt and asks for validation if required.\nResponse types should be something that can be casted from the response type designated\nin the documentation. For example:\n\n\tname := \"\"\n\tprompt := &survey.Input{\n\t\tMessage: \"name\",\n\t}\n\n\tsurvey.AskOne(prompt, &name)\n*/\nfunc AskOne(p Prompt, response interface{}, opts ...AskOpt) error {\n\terr := Ask([]*Question{{Prompt: p}}, response, opts...)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n/*\nAsk performs the prompt loop, asking for validation when appropriate. The response\ntype can be one of two options. If a struct is passed, the answer will be written to\nthe field whose name matches the Name field on the corresponding question. Field types\nshould be something that can be casted from the response type designated in the\ndocumentation. Note, a survey tag can also be used to identify a Otherwise, a\nmap[string]interface{} can be passed, responses will be written to the key with the\nmatching name. For example:\n\n\tqs := []*survey.Question{\n\t\t{\n\t\t\tName:     \"name\",\n\t\t\tPrompt:   &survey.Input{Message: \"What is your name?\"},\n\t\t\tValidate: survey.Required,\n\t\t\tTransform: survey.Title,\n\t\t},\n\t}\n\n\tanswers := struct{ Name string }{}\n\n\n\terr := survey.Ask(qs, &answers)\n*/\nfunc Ask(qs []*Question, response interface{}, opts ...AskOpt) error {\n\t// build up the configuration options\n\toptions := defaultAskOptions()\n\tfor _, opt := range opts {\n\t\tif opt == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif err := opt(options); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// if we weren't passed a place to record the answers\n\tif response == nil {\n\t\t// we can't go any further\n\t\treturn errors.New(\"cannot call Ask() with a nil reference to record the answers\")\n\t}\n\n\tvalidate := func(q *Question, val interface{}) error {\n\t\tif q.Validate != nil {\n\t\t\tif err := q.Validate(val); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tfor _, v := range options.Validators {\n\t\t\tif err := v(val); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\n\t// go over every question\n\tfor _, q := range qs {\n\t\t// If Prompt implements controllable stdio, pass in specified stdio.\n\t\tif p, ok := q.Prompt.(wantsStdio); ok {\n\t\t\tp.WithStdio(options.Stdio)\n\t\t}\n\n\t\tvar ans interface{}\n\t\tvar validationErr error\n\t\t// prompt and validation loop\n\t\tfor {\n\t\t\tif validationErr != nil {\n\t\t\t\tif err := q.Prompt.Error(&options.PromptConfig, validationErr); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar err error\n\t\t\tif promptAgainer, ok := q.Prompt.(PromptAgainer); ok && validationErr != nil {\n\t\t\t\tans, err = promptAgainer.PromptAgain(&options.PromptConfig, ans, validationErr)\n\t\t\t} else {\n\t\t\t\tans, err = q.Prompt.Prompt(&options.PromptConfig)\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tvalidationErr = validate(q, ans)\n\t\t\tif validationErr == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif q.Transform != nil {\n\t\t\t// check if we have a transformer available, if so\n\t\t\t// then try to acquire the new representation of the\n\t\t\t// answer, if the resulting answer is not nil.\n\t\t\tif newAns := q.Transform(ans); newAns != nil {\n\t\t\t\tans = newAns\n\t\t\t}\n\t\t}\n\n\t\t// tell the prompt to cleanup with the validated value\n\t\tif err := q.Prompt.Cleanup(&options.PromptConfig, ans); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// add it to the map\n\t\tif err := core.WriteAnswer(response, q.Name, ans); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// return the response\n\treturn nil\n}\n\n// paginate returns a single page of choices given the page size, the total list of\n// possible choices, and the current selected index in the total list.\nfunc paginate(pageSize int, choices []core.OptionAnswer, sel int) ([]core.OptionAnswer, int) {\n\tvar start, end, cursor int\n\n\tif len(choices) < pageSize {\n\t\t// if we dont have enough options to fill a page\n\t\tstart = 0\n\t\tend = len(choices)\n\t\tcursor = sel\n\n\t} else if sel < pageSize/2 {\n\t\t// if we are in the first half page\n\t\tstart = 0\n\t\tend = pageSize\n\t\tcursor = sel\n\n\t} else if len(choices)-sel-1 < pageSize/2 {\n\t\t// if we are in the last half page\n\t\tstart = len(choices) - pageSize\n\t\tend = len(choices)\n\t\tcursor = sel - start\n\n\t} else {\n\t\t// somewhere in the middle\n\t\tabove := pageSize / 2\n\t\tbelow := pageSize - above\n\n\t\tcursor = pageSize / 2\n\t\tstart = sel - above\n\t\tend = sel + below\n\t}\n\n\t// return the subset we care about and the index\n\treturn choices[start:end], cursor\n}\n\ntype IterableOpts interface {\n\tIterateOption(int, core.OptionAnswer) interface{}\n}\n\nfunc computeCursorOffset(tmpl string, data IterableOpts, opts []core.OptionAnswer, idx, tWidth int) int {\n\ttmpls, err := core.GetTemplatePair(tmpl)\n\tif err != nil {\n\t\treturn 0\n\t}\n\n\tt := tmpls[0]\n\n\trenderOpt := func(ix int, opt core.OptionAnswer) string {\n\t\tvar buf bytes.Buffer\n\t\t_ = t.ExecuteTemplate(&buf, \"option\", data.IterateOption(ix, opt))\n\t\treturn buf.String()\n\t}\n\n\toffset := len(opts) - idx\n\n\tfor i, o := range opts {\n\t\tif i < idx {\n\t\t\tcontinue\n\t\t}\n\t\trenderedOpt := renderOpt(i, o)\n\t\tvalWidth := utf8.RuneCount([]byte(renderedOpt))\n\t\tif valWidth > tWidth {\n\t\t\tsplitCount := valWidth / tWidth\n\t\t\tif valWidth%tWidth == 0 {\n\t\t\t\tsplitCount -= 1\n\t\t\t}\n\t\t\toffset += splitCount\n\t\t}\n\t}\n\n\treturn offset\n}\n"
        },
        {
          "name": "survey_posix_test.go",
          "type": "blob",
          "size": 1.005859375,
          "content": "//go:build !windows\n// +build !windows\n\npackage survey\n\nimport (\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\texpect \"github.com/Netflix/go-expect\"\n\tpseudotty \"github.com/creack/pty\"\n\t\"github.com/hinshun/vt10x\"\n)\n\nfunc RunTest(t *testing.T, procedure func(expectConsole), test func(terminal.Stdio) error) {\n\tt.Helper()\n\tt.Parallel()\n\n\tpty, tty, err := pseudotty.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"failed to open pseudotty: %v\", err)\n\t}\n\n\tterm := vt10x.New(vt10x.WithWriter(tty))\n\tc, err := expect.NewConsole(expect.WithStdin(pty), expect.WithStdout(term), expect.WithCloser(pty, tty))\n\tif err != nil {\n\t\tt.Fatalf(\"failed to create console: %v\", err)\n\t}\n\tdefer c.Close()\n\n\tdonec := make(chan struct{})\n\tgo func() {\n\t\tdefer close(donec)\n\t\tprocedure(&consoleWithErrorHandling{console: c, t: t})\n\t}()\n\n\tstdio := terminal.Stdio{In: c.Tty(), Out: c.Tty(), Err: c.Tty()}\n\tif err := test(stdio); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tif err := c.Tty().Close(); err != nil {\n\t\tt.Errorf(\"error closing Tty: %v\", err)\n\t}\n\t<-donec\n}\n"
        },
        {
          "name": "survey_test.go",
          "type": "blob",
          "size": 15.7314453125,
          "content": "package survey\n\nimport (\n\t\"errors\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n\texpect \"github.com/Netflix/go-expect\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc init() {\n\t// disable color output for all prompts to simplify testing\n\tcore.DisableColor = true\n}\n\ntype expectConsole interface {\n\tExpectString(string)\n\tExpectEOF()\n\tSendLine(string)\n\tSend(string)\n}\n\ntype consoleWithErrorHandling struct {\n\tconsole *expect.Console\n\tt       *testing.T\n}\n\nfunc (c *consoleWithErrorHandling) ExpectString(s string) {\n\tif _, err := c.console.ExpectString(s); err != nil {\n\t\tc.t.Helper()\n\t\tc.t.Fatalf(\"ExpectString(%q) = %v\", s, err)\n\t}\n}\n\nfunc (c *consoleWithErrorHandling) SendLine(s string) {\n\tif _, err := c.console.SendLine(s); err != nil {\n\t\tc.t.Helper()\n\t\tc.t.Fatalf(\"SendLine(%q) = %v\", s, err)\n\t}\n}\n\nfunc (c *consoleWithErrorHandling) Send(s string) {\n\tif _, err := c.console.Send(s); err != nil {\n\t\tc.t.Helper()\n\t\tc.t.Fatalf(\"Send(%q) = %v\", s, err)\n\t}\n}\n\nfunc (c *consoleWithErrorHandling) ExpectEOF() {\n\tif _, err := c.console.ExpectEOF(); err != nil {\n\t\tc.t.Helper()\n\t\tc.t.Fatalf(\"ExpectEOF() = %v\", err)\n\t}\n}\n\ntype PromptTest struct {\n\tname      string\n\tprompt    Prompt\n\tprocedure func(expectConsole)\n\texpected  interface{}\n}\n\nfunc RunPromptTest(t *testing.T, test PromptTest) {\n\tt.Helper()\n\tvar answer interface{}\n\tRunTest(t, test.procedure, func(stdio terminal.Stdio) error {\n\t\tvar err error\n\t\tif p, ok := test.prompt.(wantsStdio); ok {\n\t\t\tp.WithStdio(stdio)\n\t\t}\n\n\t\tanswer, err = test.prompt.Prompt(defaultPromptConfig())\n\t\treturn err\n\t})\n\trequire.Equal(t, test.expected, answer)\n}\n\nfunc RunPromptTestKeepFilter(t *testing.T, test PromptTest) {\n\tt.Helper()\n\tvar answer interface{}\n\tRunTest(t, test.procedure, func(stdio terminal.Stdio) error {\n\t\tvar err error\n\t\tif p, ok := test.prompt.(wantsStdio); ok {\n\t\t\tp.WithStdio(stdio)\n\t\t}\n\t\tconfig := defaultPromptConfig()\n\t\tconfig.KeepFilter = true\n\t\tanswer, err = test.prompt.Prompt(config)\n\t\treturn err\n\t})\n\trequire.Equal(t, test.expected, answer)\n}\n\nfunc RunPromptTestRemoveSelectAll(t *testing.T, test PromptTest) {\n\tt.Helper()\n\tvar answer interface{}\n\tRunTest(t, test.procedure, func(stdio terminal.Stdio) error {\n\t\tvar err error\n\t\tif p, ok := test.prompt.(wantsStdio); ok {\n\t\t\tp.WithStdio(stdio)\n\t\t}\n\t\tconfig := defaultPromptConfig()\n\t\tconfig.RemoveSelectAll = true\n\t\tanswer, err = test.prompt.Prompt(config)\n\t\treturn err\n\t})\n\trequire.Equal(t, test.expected, answer)\n}\n\nfunc RunPromptTestRemoveSelectNone(t *testing.T, test PromptTest) {\n\tt.Helper()\n\tvar answer interface{}\n\tRunTest(t, test.procedure, func(stdio terminal.Stdio) error {\n\t\tvar err error\n\t\tif p, ok := test.prompt.(wantsStdio); ok {\n\t\t\tp.WithStdio(stdio)\n\t\t}\n\t\tconfig := defaultPromptConfig()\n\t\tconfig.RemoveSelectNone = true\n\t\tanswer, err = test.prompt.Prompt(config)\n\t\treturn err\n\t})\n\trequire.Equal(t, test.expected, answer)\n}\n\nfunc TestPagination_tooFew(t *testing.T) {\n\t// a small list of options\n\tchoices := core.OptionAnswerList([]string{\"choice1\", \"choice2\", \"choice3\"})\n\n\t// a page bigger than the total number\n\tpageSize := 4\n\t// the current selection\n\tsel := 3\n\n\t// compute the page info\n\tpage, idx := paginate(pageSize, choices, sel)\n\n\t// make sure we see the full list of options\n\tassert.Equal(t, choices, page)\n\t// with the second index highlighted (no change)\n\tassert.Equal(t, 3, idx)\n}\n\nfunc TestPagination_firstHalf(t *testing.T) {\n\t// the choices for the test\n\tchoices := core.OptionAnswerList([]string{\"choice1\", \"choice2\", \"choice3\", \"choice4\", \"choice5\", \"choice6\"})\n\n\t// section the choices into groups of 4 so the choice is somewhere in the middle\n\t// to verify there is no displacement of the page\n\tpageSize := 4\n\t// test the second item\n\tsel := 2\n\n\t// compute the page info\n\tpage, idx := paginate(pageSize, choices, sel)\n\n\t// we should see the first three options\n\tassert.Equal(t, choices[0:4], page)\n\t// with the second index highlighted\n\tassert.Equal(t, 2, idx)\n}\n\nfunc TestPagination_middle(t *testing.T) {\n\t// the choices for the test\n\tchoices := core.OptionAnswerList([]string{\"choice0\", \"choice1\", \"choice2\", \"choice3\", \"choice4\", \"choice5\"})\n\n\t// section the choices into groups of 3\n\tpageSize := 2\n\t// test the second item so that we can verify we are in the middle of the list\n\tsel := 3\n\n\t// compute the page info\n\tpage, idx := paginate(pageSize, choices, sel)\n\n\t// we should see the first three options\n\tassert.Equal(t, choices[2:4], page)\n\t// with the second index highlighted\n\tassert.Equal(t, 1, idx)\n}\n\nfunc TestPagination_lastHalf(t *testing.T) {\n\t// the choices for the test\n\tchoices := core.OptionAnswerList([]string{\"choice0\", \"choice1\", \"choice2\", \"choice3\", \"choice4\", \"choice5\"})\n\n\t// section the choices into groups of 3\n\tpageSize := 3\n\t// test the last item to verify we're not in the middle\n\tsel := 5\n\n\t// compute the page info\n\tpage, idx := paginate(pageSize, choices, sel)\n\n\t// we should see the first three options\n\tassert.Equal(t, choices[3:6], page)\n\t// we should be at the bottom of the list\n\tassert.Equal(t, 2, idx)\n}\n\nfunc TestAsk(t *testing.T) {\n\tif _, err := exec.LookPath(\"vi\"); err != nil {\n\t\tt.Skip(\"vi not found in PATH\")\n\t}\n\n\ttests := []struct {\n\t\tname      string\n\t\tquestions []*Question\n\t\tprocedure func(expectConsole)\n\t\texpected  map[string]interface{}\n\t}{\n\t\t{\n\t\t\t\"Test Ask for all prompts\",\n\t\t\t[]*Question{\n\t\t\t\t{\n\t\t\t\t\tName: \"pizza\",\n\t\t\t\t\tPrompt: &Confirm{\n\t\t\t\t\t\tMessage: \"Is pizza your favorite food?\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName: \"commit-message\",\n\t\t\t\t\tPrompt: &Editor{\n\t\t\t\t\t\tEditor:  \"vi\",\n\t\t\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t/* TODO gets stuck\n\t\t\t\t{\n\t\t\t\t\tName: \"commit-message-validated\",\n\t\t\t\t\tPrompt: &Editor{\n\t\t\t\t\t\tEditor:  \"vi\",\n\t\t\t\t\t\tMessage: \"Edit git commit message\",\n\t\t\t\t\t},\n\t\t\t\t\tValidate: func(v interface{}) error {\n\t\t\t\t\t\ts := v.(string)\n\t\t\t\t\t\tif strings.Contains(s, \"invalid\") {\n\t\t\t\t\t\t\treturn fmt.Errorf(\"invalid error message\")\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn nil\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t*/\n\t\t\t\t{\n\t\t\t\t\tName: \"name\",\n\t\t\t\t\tPrompt: &Input{\n\t\t\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t/* TODO gets stuck\n\t\t\t\t{\n\t\t\t\t\tName: \"day\",\n\t\t\t\t\tPrompt: &MultiSelect{\n\t\t\t\t\t\tMessage: \"What days do you prefer:\",\n\t\t\t\t\t\tOptions: []string{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t*/\n\t\t\t\t{\n\t\t\t\t\tName: \"password\",\n\t\t\t\t\tPrompt: &Password{\n\t\t\t\t\t\tMessage: \"Please type your password\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tName: \"color\",\n\t\t\t\t\tPrompt: &Select{\n\t\t\t\t\t\tMessage: \"Choose a color:\",\n\t\t\t\t\t\tOptions: []string{\"red\", \"blue\", \"green\", \"yellow\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\t// Confirm\n\t\t\t\tc.ExpectString(\"Is pizza your favorite food? (y/N)\")\n\t\t\t\tc.SendLine(\"Y\")\n\n\t\t\t\t// Editor\n\t\t\t\tc.ExpectString(\"Edit git commit message [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.Send(\"ccAdd editor prompt tests\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\n\t\t\t\t/* TODO gets stuck\n\t\t\t\t// Editor validated\n\t\t\t\tc.ExpectString(\"Edit git commit message [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.Send(\"i invalid input first try\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.ExpectString(\"invalid error message\")\n\t\t\t\tc.ExpectString(\"Edit git commit message [Enter to launch editor]\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.ExpectString(\"first try\")\n\t\t\t\tc.Send(\"ccAdd editor prompt tests, but validated\\x1b\")\n\t\t\t\tc.SendLine(\":wq!\")\n\t\t\t\t*/\n\n\t\t\t\t// Input\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"Johnny Appleseed\")\n\n\t\t\t\t/* TODO gets stuck\n\t\t\t\t// MultiSelect\n\t\t\t\tc.ExpectString(\"What days do you prefer:  [Use arrows to move, space to select, type to filter]\")\n\t\t\t\t// Select Monday.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(\" \")\n\t\t\t\t// Select Wednesday.\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.Send(string(terminal.KeyArrowDown))\n\t\t\t\tc.SendLine(\" \")\n\t\t\t\t*/\n\n\t\t\t\t// Password\n\t\t\t\tc.ExpectString(\"Please type your password\")\n\t\t\t\tc.Send(\"secret\")\n\t\t\t\tc.SendLine(\"\")\n\n\t\t\t\t// Select\n\t\t\t\tc.ExpectString(\"Choose a color:  [Use arrows to move, type to filter]\")\n\t\t\t\tc.SendLine(\"yellow\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"pizza\":          true,\n\t\t\t\t\"commit-message\": \"Add editor prompt tests\\n\",\n\t\t\t\t/* TODO\n\t\t\t\t\"commit-message-validated\": \"Add editor prompt tests, but validated\\n\",\n\t\t\t\t*/\n\t\t\t\t\"name\": \"Johnny Appleseed\",\n\t\t\t\t/* TODO\n\t\t\t\t\"day\":                      []string{\"Monday\", \"Wednesday\"},\n\t\t\t\t*/\n\t\t\t\t\"password\": \"secret\",\n\t\t\t\t\"color\":    core.OptionAnswer{Index: 3, Value: \"yellow\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Test Ask with validate survey.Required\",\n\t\t\t[]*Question{\n\t\t\t\t{\n\t\t\t\t\tName: \"name\",\n\t\t\t\t\tPrompt: &Input{\n\t\t\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\t\t},\n\t\t\t\t\tValidate: Required,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"\")\n\t\t\t\tc.ExpectString(\"Sorry, your reply was invalid: Value is required\")\n\t\t\t\ttime.Sleep(time.Millisecond)\n\t\t\t\tc.SendLine(\"Johnny Appleseed\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": \"Johnny Appleseed\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t\"Test Ask with transformer survey.ToLower\",\n\t\t\t[]*Question{\n\t\t\t\t{\n\t\t\t\t\tName: \"name\",\n\t\t\t\t\tPrompt: &Input{\n\t\t\t\t\t\tMessage: \"What is your name?\",\n\t\t\t\t\t},\n\t\t\t\t\tTransform: ToLower,\n\t\t\t\t},\n\t\t\t},\n\t\t\tfunc(c expectConsole) {\n\t\t\t\tc.ExpectString(\"What is your name?\")\n\t\t\t\tc.SendLine(\"Johnny Appleseed\")\n\t\t\t\tc.ExpectString(\"What is your name? johnny appleseed\")\n\t\t\t\tc.ExpectEOF()\n\t\t\t},\n\t\t\tmap[string]interface{}{\n\t\t\t\t\"name\": \"johnny appleseed\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\t// Capture range variable.\n\t\ttest := test\n\t\tt.Run(test.name, func(t *testing.T) {\n\t\t\tanswers := make(map[string]interface{})\n\t\t\tRunTest(t, test.procedure, func(stdio terminal.Stdio) error {\n\t\t\t\treturn Ask(test.questions, &answers, WithStdio(stdio.In, stdio.Out, stdio.Err))\n\t\t\t})\n\t\t\trequire.Equal(t, test.expected, answers)\n\t\t})\n\t}\n}\n\nfunc TestAsk_returnsErrorIfTargetIsNil(t *testing.T) {\n\t// pass an empty place to leave the answers\n\terr := Ask([]*Question{}, nil)\n\n\t// if we didn't get an error\n\tif err == nil {\n\t\t// the test failed\n\t\tt.Error(\"Did not encounter error when asking with no where to record.\")\n\t}\n}\n\nfunc Test_computeCursorOffset_MultiSelect(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tix        int\n\t\topts      []core.OptionAnswer\n\t\ttermWidth int\n\t\twant      int\n\t}{\n\t\t{\n\t\t\tname: \"no opts\",\n\t\t\tix:   0,\n\t\t\topts: []core.OptionAnswer{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"one opt\",\n\t\t\tix:   0,\n\t\t\topts: core.OptionAnswerList([]string{\"one\"}),\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple opt\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\"}),\n\t\t\tix:   0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"first choice\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\", \"three\", \"four\", \"five\"}),\n\t\t\tix:   0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"mid choice\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\", \"three\", \"four\", \"five\"}),\n\t\t\tix:   2,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"last choice\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\", \"three\", \"four\", \"five\"}),\n\t\t\tix:   4,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"wide choices, uneven\",\n\t\t\topts: core.OptionAnswerList([]string{\n\t\t\t\t\"wide one wide one wide one\",\n\t\t\t\t\"two\", \"three\",\n\t\t\t\t\"wide four wide four wide four\",\n\t\t\t\t\"five\", \"six\"}),\n\t\t\ttermWidth: 20,\n\t\t\tix:        0,\n\t\t\twant:      8,\n\t\t},\n\t\t{\n\t\t\tname: \"wide choices, even\",\n\t\t\topts: core.OptionAnswerList([]string{\n\t\t\t\t\"wide one wide one wide one\",\n\t\t\t\t\"two\", \"three\",\n\t\t\t\t\"012345678901\",\n\t\t\t\t\"five\", \"six\"}),\n\t\t\ttermWidth: 20,\n\t\t\tix:        0,\n\t\t\twant:      7,\n\t\t},\n\t\t{\n\t\t\tname: \"wide choices, wide before idx\",\n\t\t\topts: core.OptionAnswerList([]string{\n\t\t\t\t\"wide one wide one wide one\",\n\t\t\t\t\"wide two wide two wide two\",\n\t\t\t\t\"three\", \"four\", \"five\", \"six\"}),\n\t\t\ttermWidth: 20,\n\t\t\tix:        2,\n\t\t\twant:      4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tif tt.termWidth == 0 {\n\t\t\ttt.termWidth = 100\n\t\t}\n\t\ttmpl := MultiSelectQuestionTemplate\n\t\tdata := MultiSelectTemplateData{\n\t\t\tSelectedIndex: tt.ix,\n\t\t\tConfig:        defaultPromptConfig(),\n\t\t}\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := computeCursorOffset(tmpl, data, tt.opts, tt.ix, tt.termWidth); got != tt.want {\n\t\t\t\tt.Errorf(\"computeCursorOffset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc Test_computeCursorOffset_Select(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tix        int\n\t\topts      []core.OptionAnswer\n\t\ttermWidth int\n\t\twant      int\n\t}{\n\t\t{\n\t\t\tname: \"no opts\",\n\t\t\tix:   0,\n\t\t\topts: []core.OptionAnswer{},\n\t\t\twant: 0,\n\t\t},\n\t\t{\n\t\t\tname: \"one opt\",\n\t\t\tix:   0,\n\t\t\topts: core.OptionAnswerList([]string{\"one\"}),\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"multiple opt\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\"}),\n\t\t\tix:   0,\n\t\t\twant: 2,\n\t\t},\n\t\t{\n\t\t\tname: \"first choice\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\", \"three\", \"four\", \"five\"}),\n\t\t\tix:   0,\n\t\t\twant: 5,\n\t\t},\n\t\t{\n\t\t\tname: \"mid choice\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\", \"three\", \"four\", \"five\"}),\n\t\t\tix:   2,\n\t\t\twant: 3,\n\t\t},\n\t\t{\n\t\t\tname: \"last choice\",\n\t\t\topts: core.OptionAnswerList([]string{\"one\", \"two\", \"three\", \"four\", \"five\"}),\n\t\t\tix:   4,\n\t\t\twant: 1,\n\t\t},\n\t\t{\n\t\t\tname: \"wide choices, uneven\",\n\t\t\topts: core.OptionAnswerList([]string{\n\t\t\t\t\"wide one wide one wide one\",\n\t\t\t\t\"two\", \"three\",\n\t\t\t\t\"wide four wide four wide four\",\n\t\t\t\t\"five\", \"six\"}),\n\t\t\ttermWidth: 20,\n\t\t\tix:        0,\n\t\t\twant:      8,\n\t\t},\n\t\t{\n\t\t\tname: \"wide choices, even\",\n\t\t\topts: core.OptionAnswerList([]string{\n\t\t\t\t\"wide one wide one wide one\",\n\t\t\t\t\"two\", \"three\",\n\t\t\t\t\"01234567890123456\",\n\t\t\t\t\"five\", \"six\"}),\n\t\t\ttermWidth: 20,\n\t\t\tix:        0,\n\t\t\twant:      7,\n\t\t},\n\t\t{\n\t\t\tname: \"wide choices, wide before idx\",\n\t\t\topts: core.OptionAnswerList([]string{\n\t\t\t\t\"wide one wide one wide one\",\n\t\t\t\t\"wide two wide two wide two\",\n\t\t\t\t\"three\", \"four\", \"five\", \"six\"}),\n\t\t\ttermWidth: 20,\n\t\t\tix:        2,\n\t\t\twant:      4,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tif tt.termWidth == 0 {\n\t\t\ttt.termWidth = 100\n\t\t}\n\t\ttmpl := SelectQuestionTemplate\n\t\tdata := SelectTemplateData{\n\t\t\tSelectedIndex: tt.ix,\n\t\t\tConfig:        defaultPromptConfig(),\n\t\t}\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tif got := computeCursorOffset(tmpl, data, tt.opts, tt.ix, tt.termWidth); got != tt.want {\n\t\t\t\tt.Errorf(\"computeCursorOffset() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAsk_Validation(t *testing.T) {\n\tp := &mockPrompt{\n\t\tanswers: []string{\"\", \"company\", \"COM\", \"com\"},\n\t}\n\n\tvar res struct {\n\t\tTLDN string\n\t}\n\terr := Ask([]*Question{\n\t\t{\n\t\t\tName:   \"TLDN\",\n\t\t\tPrompt: p,\n\t\t\tValidate: func(v interface{}) error {\n\t\t\t\ts := v.(string)\n\t\t\t\tif strings.ToLower(s) != s {\n\t\t\t\t\treturn errors.New(\"value contains uppercase characters\")\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t},\n\t\t},\n\t}, &res, WithValidator(MinLength(1)), WithValidator(MaxLength(5)))\n\tif err != nil {\n\t\tt.Fatalf(\"Ask() = %v\", err)\n\t}\n\n\tif res.TLDN != \"com\" {\n\t\tt.Errorf(\"answer: %q, want %q\", res.TLDN, \"com\")\n\t}\n\tif p.cleanups != 1 {\n\t\tt.Errorf(\"cleanups: %d, want %d\", p.cleanups, 1)\n\t}\n\tif err1 := p.printedErrors[0].Error(); err1 != \"value is too short. Min length is 1\" {\n\t\tt.Errorf(\"printed error 1: %q, want %q\", err1, \"value is too short. Min length is 1\")\n\t}\n\tif err2 := p.printedErrors[1].Error(); err2 != \"value is too long. Max length is 5\" {\n\t\tt.Errorf(\"printed error 2: %q, want %q\", err2, \"value is too long. Max length is 5\")\n\t}\n\tif err3 := p.printedErrors[2].Error(); err3 != \"value contains uppercase characters\" {\n\t\tt.Errorf(\"printed error 2: %q, want %q\", err3, \"value contains uppercase characters\")\n\t}\n}\n\ntype mockPrompt struct {\n\tindex         int\n\tanswers       []string\n\tcleanups      int\n\tprintedErrors []error\n}\n\nfunc (p *mockPrompt) Prompt(*PromptConfig) (interface{}, error) {\n\tif p.index >= len(p.answers) {\n\t\treturn nil, errors.New(\"no more answers\")\n\t}\n\tval := p.answers[p.index]\n\tp.index++\n\treturn val, nil\n}\n\nfunc (p *mockPrompt) Cleanup(*PromptConfig, interface{}) error {\n\tp.cleanups++\n\treturn nil\n}\n\nfunc (p *mockPrompt) Error(_ *PromptConfig, err error) error {\n\tp.printedErrors = append(p.printedErrors, err)\n\treturn nil\n}\n"
        },
        {
          "name": "survey_windows_test.go",
          "type": "blob",
          "size": 0.2353515625,
          "content": "package survey\n\nimport (\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/terminal\"\n)\n\nfunc RunTest(t *testing.T, procedure func(expectConsole), test func(terminal.Stdio) error) {\n\tt.Skip(\"warning: Windows does not support psuedoterminals\")\n}\n"
        },
        {
          "name": "terminal",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "transform.go",
          "type": "blob",
          "size": 2.5546875,
          "content": "package survey\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\n\t\"golang.org/x/text/cases\"\n\t\"golang.org/x/text/language\"\n)\n\n// TransformString returns a `Transformer` based on the \"f\"\n// function which accepts a string representation of the answer\n// and returns a new one, transformed, answer.\n// Take for example the functions inside the std `strings` package,\n// they can be converted to a compatible `Transformer` by using this function,\n// i.e: `TransformString(strings.Title)`, `TransformString(strings.ToUpper)`.\n//\n// Note that `TransformString` is just a helper, `Transformer` can be used\n// to transform any type of answer.\nfunc TransformString(f func(s string) string) Transformer {\n\treturn func(ans interface{}) interface{} {\n\t\t// if the answer value passed in is the zero value of the appropriate type\n\t\tif isZero(reflect.ValueOf(ans)) {\n\t\t\t// skip this `Transformer` by returning a zero value of string.\n\t\t\t// The original answer will be not affected,\n\t\t\t// see survey.go#L125.\n\t\t\t// A zero value of string should be returned to be handled by\n\t\t\t// next Transformer in a composed Tranformer,\n\t\t\t// see tranform.go#L75\n\t\t\treturn \"\"\n\t\t}\n\n\t\t// \"ans\" is never nil here, so we don't have to check that\n\t\t// see survey.go#L338 for more.\n\t\t// Make sure that the the answer's value was a typeof string.\n\t\ts, ok := ans.(string)\n\t\tif !ok {\n\t\t\treturn \"\"\n\t\t}\n\n\t\treturn f(s)\n\t}\n}\n\n// ToLower is a `Transformer`.\n// It receives an answer value\n// and returns a copy of the \"ans\"\n// with all Unicode letters mapped to their lower case.\n//\n// Note that if \"ans\" is not a string then it will\n// return a nil value, meaning that the above answer\n// will not be affected by this call at all.\nfunc ToLower(ans interface{}) interface{} {\n\ttransformer := TransformString(strings.ToLower)\n\treturn transformer(ans)\n}\n\n// Title is a `Transformer`.\n// It receives an answer value\n// and returns a copy of the \"ans\"\n// with all Unicode letters that begin words\n// mapped to their title case.\n//\n// Note that if \"ans\" is not a string then it will\n// return a nil value, meaning that the above answer\n// will not be affected by this call at all.\nfunc Title(ans interface{}) interface{} {\n\ttransformer := TransformString(cases.Title(language.English).String)\n\treturn transformer(ans)\n}\n\n// ComposeTransformers is a variadic function used to create one transformer from many.\nfunc ComposeTransformers(transformers ...Transformer) Transformer {\n\t// return a transformer that calls each one sequentially\n\treturn func(ans interface{}) interface{} {\n\t\t// execute each transformer\n\t\tfor _, t := range transformers {\n\t\t\tans = t(ans)\n\t\t}\n\t\treturn ans\n\t}\n}\n"
        },
        {
          "name": "transform_test.go",
          "type": "blob",
          "size": 1.4951171875,
          "content": "package survey\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc testStringTransformer(t *testing.T, f func(string) string) {\n\ttransformer := TransformString(f)\n\n\ttests := []string{\n\t\t\"hello my name is\",\n\t\t\"where are you from\",\n\t\t\"does that matter?\",\n\t}\n\n\tfor _, tt := range tests {\n\t\tif expected, got := f(tt), transformer(tt); expected != got {\n\t\t\tt.Errorf(\"TransformString transformer failed to transform the answer, expected '%s' but got '%s'.\", expected, got)\n\t\t}\n\t}\n}\n\nfunc TestTransformString(t *testing.T) {\n\ttestStringTransformer(t, strings.ToTitle) // all letters titled\n\ttestStringTransformer(t, strings.ToLower) // all letters lowercase\n}\n\nfunc TestComposeTransformers(t *testing.T) {\n\t// create a transformer which makes no sense,\n\t// remember: transformer can be used for any type\n\t// we just test the built'n functions that\n\t// happens to be for strings only.\n\ttransformer := ComposeTransformers(\n\t\tTitle,\n\t\tToLower,\n\t)\n\n\tans := \"my name is\"\n\tif expected, got := strings.ToLower(ans), transformer(ans); expected != got {\n\t\t// the result should be lowercase.\n\t\tt.Errorf(\"TestComposeTransformers transformer failed to transform the answer to title->lowercase, expected '%s' but got '%s'.\", expected, got)\n\t}\n\n\tvar emptyAns string\n\tif expected, got := \"\", transformer(emptyAns); expected != got {\n\t\t// TransformString transformers should be skipped and return zero value string\n\t\tt.Errorf(\"TestComposeTransformers transformer failed to skip transforming on optional empty input, expected '%s' but got '%s'.\", expected, got)\n\t}\n}\n"
        },
        {
          "name": "validate.go",
          "type": "blob",
          "size": 3.9453125,
          "content": "package survey\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n)\n\n// Required does not allow an empty value\nfunc Required(val interface{}) error {\n\t// the reflect value of the result\n\tvalue := reflect.ValueOf(val)\n\n\t// if the value passed in is the zero value of the appropriate type\n\tif isZero(value) && value.Kind() != reflect.Bool {\n\t\t//lint:ignore ST1005 this error message should render as capitalized\n\t\treturn errors.New(\"Value is required\")\n\t}\n\treturn nil\n}\n\n// MaxLength requires that the string is no longer than the specified value\nfunc MaxLength(length int) Validator {\n\t// return a validator that checks the length of the string\n\treturn func(val interface{}) error {\n\t\tif str, ok := val.(string); ok {\n\t\t\t// if the string is longer than the given value\n\t\t\tif len([]rune(str)) > length {\n\t\t\t\t// yell loudly\n\t\t\t\treturn fmt.Errorf(\"value is too long. Max length is %v\", length)\n\t\t\t}\n\t\t} else {\n\t\t\t// otherwise we cannot convert the value into a string and cannot enforce length\n\t\t\treturn fmt.Errorf(\"cannot enforce length on response of type %v\", reflect.TypeOf(val).Name())\n\t\t}\n\n\t\t// the input is fine\n\t\treturn nil\n\t}\n}\n\n// MinLength requires that the string is longer or equal in length to the specified value\nfunc MinLength(length int) Validator {\n\t// return a validator that checks the length of the string\n\treturn func(val interface{}) error {\n\t\tif str, ok := val.(string); ok {\n\t\t\t// if the string is shorter than the given value\n\t\t\tif len([]rune(str)) < length {\n\t\t\t\t// yell loudly\n\t\t\t\treturn fmt.Errorf(\"value is too short. Min length is %v\", length)\n\t\t\t}\n\t\t} else {\n\t\t\t// otherwise we cannot convert the value into a string and cannot enforce length\n\t\t\treturn fmt.Errorf(\"cannot enforce length on response of type %v\", reflect.TypeOf(val).Name())\n\t\t}\n\n\t\t// the input is fine\n\t\treturn nil\n\t}\n}\n\n// MaxItems requires that the list is no longer than the specified value\nfunc MaxItems(numberItems int) Validator {\n\t// return a validator that checks the length of the list\n\treturn func(val interface{}) error {\n\t\tif list, ok := val.([]core.OptionAnswer); ok {\n\t\t\t// if the list is longer than the given value\n\t\t\tif len(list) > numberItems {\n\t\t\t\t// yell loudly\n\t\t\t\treturn fmt.Errorf(\"value is too long. Max items is %v\", numberItems)\n\t\t\t}\n\t\t} else {\n\t\t\t// otherwise we cannot convert the value into a list of answer and cannot enforce length\n\t\t\treturn fmt.Errorf(\"cannot impose the length on something other than a list of answers\")\n\t\t}\n\t\t// the input is fine\n\t\treturn nil\n\t}\n}\n\n// MinItems requires that the list is longer or equal in length to the specified value\nfunc MinItems(numberItems int) Validator {\n\t// return a validator that checks the length of the list\n\treturn func(val interface{}) error {\n\t\tif list, ok := val.([]core.OptionAnswer); ok {\n\t\t\t// if the list is shorter than the given value\n\t\t\tif len(list) < numberItems {\n\t\t\t\t// yell loudly\n\t\t\t\treturn fmt.Errorf(\"value is too short. Min items is %v\", numberItems)\n\t\t\t}\n\t\t} else {\n\t\t\t// otherwise we cannot convert the value into a list of answer and cannot enforce length\n\t\t\treturn fmt.Errorf(\"cannot impose the length on something other than a list of answers\")\n\t\t}\n\t\t// the input is fine\n\t\treturn nil\n\t}\n}\n\n// ComposeValidators is a variadic function used to create one validator from many.\nfunc ComposeValidators(validators ...Validator) Validator {\n\t// return a validator that calls each one sequentially\n\treturn func(val interface{}) error {\n\t\t// execute each validator\n\t\tfor _, validator := range validators {\n\t\t\t// if the answer's value is not valid\n\t\t\tif err := validator(val); err != nil {\n\t\t\t\t// return the error\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\t// we passed all validators, the answer is valid\n\t\treturn nil\n\t}\n}\n\n// isZero returns true if the passed value is the zero object\nfunc isZero(v reflect.Value) bool {\n\tswitch v.Kind() {\n\tcase reflect.Slice, reflect.Map:\n\t\treturn v.Len() == 0\n\t}\n\n\t// compare the types directly with more general coverage\n\treturn reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface())\n}\n"
        },
        {
          "name": "validate_test.go",
          "type": "blob",
          "size": 5.169921875,
          "content": "package survey\n\nimport (\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"github.com/AlecAivazis/survey/v2/core\"\n)\n\nfunc TestRequired_canSucceedOnPrimitiveTypes(t *testing.T) {\n\t// a string to test\n\tstr := \"hello\"\n\t// if the string is not valid\n\tif valid := Required(str); valid != nil {\n\t\t//\n\t\tt.Error(\"Non null returned an error when one wasn't expected.\")\n\t}\n}\n\nfunc TestRequired_canFailOnPrimitiveTypes(t *testing.T) {\n\t// a string to test\n\tstr := \"\"\n\t// if the string is valid\n\tif notValid := Required(str); notValid == nil {\n\t\t//\n\t\tt.Error(\"Non null did not return an error when one was expected.\")\n\t}\n}\n\nfunc TestRequired_canSucceedOnMap(t *testing.T) {\n\t// an non-empty map to test\n\tval := map[string]int{\"hello\": 1}\n\t// if the string is not valid\n\tif valid := Required(val); valid != nil {\n\t\t//\n\t\tt.Error(\"Non null returned an error when one wasn't expected.\")\n\t}\n}\n\nfunc TestRequired_passesOnFalse(t *testing.T) {\n\t// a false value to pass to the validator\n\tval := false\n\n\t// if the boolean is invalid\n\tif notValid := Required(val); notValid != nil {\n\t\t//\n\t\tt.Error(\"False failed a required check.\")\n\t}\n}\n\nfunc TestRequired_canFailOnMap(t *testing.T) {\n\t// an non-empty map to test\n\tval := map[string]int{}\n\t// if the string is valid\n\tif notValid := Required(val); notValid == nil {\n\t\t//\n\t\tt.Error(\"Non null did not return an error when one was expected.\")\n\t}\n}\n\nfunc TestRequired_canSucceedOnLists(t *testing.T) {\n\t// a string to test\n\tstr := []string{\"hello\"}\n\t// if the string is not valid\n\tif valid := Required(str); valid != nil {\n\t\t//\n\t\tt.Error(\"Non null returned an error when one wasn't expected.\")\n\t}\n}\n\nfunc TestRequired_canFailOnLists(t *testing.T) {\n\t// a string to test\n\tstr := []string{}\n\t// if the string is not valid\n\tif notValid := Required(str); notValid == nil {\n\t\t//\n\t\tt.Error(\"Non null did not return an error when one was expected.\")\n\t}\n}\n\nconst letterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nfunc randString(n int) string {\n\tb := make([]byte, n)\n\tfor i := range b {\n\t\tb[i] = letterBytes[rand.Int63()%int64(len(letterBytes))]\n\t}\n\treturn string(b)\n}\n\nfunc TestMaxItems(t *testing.T) {\n\t// the list to test\n\ttestList := []core.OptionAnswer{\n\t\t{Value: \"a\", Index: 0},\n\t\t{Value: \"b\", Index: 1},\n\t\t{Value: \"c\", Index: 2},\n\t\t{Value: \"d\", Index: 3},\n\t\t{Value: \"e\", Index: 4},\n\t\t{Value: \"f\", Index: 5},\n\t}\n\n\t// validate the list\n\tif err := MaxItems(4)(testList); err == nil {\n\t\tt.Error(\"No error returned with input greater than 6 items.\")\n\t}\n}\n\nfunc TestMinItems(t *testing.T) {\n\t// the list to test\n\ttestList := []core.OptionAnswer{\n\t\t{Value: \"a\", Index: 0},\n\t\t{Value: \"b\", Index: 1},\n\t\t{Value: \"c\", Index: 2},\n\t\t{Value: \"d\", Index: 3},\n\t\t{Value: \"e\", Index: 4},\n\t\t{Value: \"f\", Index: 5},\n\t}\n\n\t// validate the list\n\tif err := MinItems(10)(testList); err == nil {\n\t\tt.Error(\"No error returned with input less than 10 items.\")\n\t}\n}\n\nfunc TestMaxLength(t *testing.T) {\n\t// the string to test\n\ttestStr := randString(150)\n\t// validate the string\n\tif err := MaxLength(140)(testStr); err == nil {\n\t\tt.Error(\"No error returned with input greater than 150 characters.\")\n\t}\n\n\t// emoji test\n\temojiStr := \"IüòçGolang\"\n\t// validate visible length with Maxlength\n\tif err := MaxLength(10)(emojiStr); err != nil {\n\t\tt.Errorf(\"Error returned with emoji containing 8 characters long input.\")\n\t}\n}\n\nfunc TestMinLength(t *testing.T) {\n\t// validate the string\n\tif err := MinLength(12)(randString(10)); err == nil {\n\t\tt.Error(\"No error returned with input less than 12 characters.\")\n\t}\n\n\t// emoji test\n\temojiStr := \"IüòçGolang\"\n\t// validate visibly 8 characters long string with MinLength\n\tif err := MinLength(10)(emojiStr); err == nil {\n\t\tt.Error(\"No error returned with emoji containing input less than 10 characters.\")\n\t}\n}\n\nfunc TestMinLength_onInt(t *testing.T) {\n\t// validate the string\n\tif err := MinLength(12)(1); err == nil {\n\t\tt.Error(\"No error returned when enforcing length on int.\")\n\t}\n}\n\nfunc TestMaxLength_onInt(t *testing.T) {\n\t// validate the string\n\tif err := MaxLength(12)(1); err == nil {\n\t\tt.Error(\"No error returned when enforcing length on int.\")\n\t}\n}\n\nfunc TestComposeValidators_passes(t *testing.T) {\n\t// create a validator that requires a string of no more than 10 characters\n\tvalid := ComposeValidators(\n\t\tRequired,\n\t\tMaxLength(10),\n\t)\n\n\tstr := randString(12)\n\t// if a valid string fails\n\tif err := valid(str); err == nil {\n\t\t// the test failed\n\t\tt.Error(\"Composed validator did not pass. Wanted string less than 10 chars, passed in\", str)\n\t}\n\n}\n\nfunc TestComposeValidators_failsOnFirstError(t *testing.T) {\n\t// create a validator that requires a string of no more than 10 characters\n\tvalid := ComposeValidators(\n\t\tRequired,\n\t\tMaxLength(10),\n\t)\n\n\t// if an empty string passes\n\tif err := valid(\"\"); err == nil {\n\t\t// the test failed\n\t\tt.Error(\"Composed validator did not fail on first test like expected.\")\n\t}\n}\n\nfunc TestComposeValidators_failsOnSubsequentValidators(t *testing.T) {\n\t// create a validator that requires a string of no more than 10 characters\n\tvalid := ComposeValidators(\n\t\tRequired,\n\t\tMaxLength(10),\n\t)\n\n\tstr := randString(12)\n\t// if a string longer than 10 passes\n\tif err := valid(str); err == nil {\n\t\t// the test failed\n\t\tt.Error(\"Composed validator did not fail on second first test like expected. Should fail max length > 10 :\", str)\n\t}\n}\n"
        }
      ]
    }
  ]
}