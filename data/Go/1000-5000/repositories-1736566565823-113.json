{
  "metadata": {
    "timestamp": 1736566565823,
    "page": 113,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jinzhu/now",
      "stars": 4471,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "Guardfile",
          "type": "blob",
          "size": 0.0400390625,
          "content": "guard 'gotest' do\n  watch(%r{\\.go$})\nend\n"
        },
        {
          "name": "License",
          "type": "blob",
          "size": 1.0712890625,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-NOW  Jinzhu <wosmvp@gmail.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.3671875,
          "content": "## Now\n\nNow is a time toolkit for golang\n\n[![go report card](https://goreportcard.com/badge/github.com/jinzhu/now \"go report card\")](https://goreportcard.com/report/github.com/jinzhu/now)\n[![test status](https://github.com/jinzhu/now/workflows/tests/badge.svg?branch=master \"test status\")](https://github.com/jinzhu/now/actions)\n[![MIT license](https://img.shields.io/badge/license-MIT-brightgreen.svg)](https://opensource.org/licenses/MIT)\n\n## Install\n\n```\ngo get -u github.com/jinzhu/now\n```\n\n## Usage\n\nCalculating time based on current time\n\n```go\nimport \"github.com/jinzhu/now\"\n\ntime.Now() // 2013-11-18 17:51:49.123456789 Mon\n\nnow.BeginningOfMinute()        // 2013-11-18 17:51:00 Mon\nnow.BeginningOfHour()          // 2013-11-18 17:00:00 Mon\nnow.BeginningOfDay()           // 2013-11-18 00:00:00 Mon\nnow.BeginningOfWeek()          // 2013-11-17 00:00:00 Sun\nnow.BeginningOfMonth()         // 2013-11-01 00:00:00 Fri\nnow.BeginningOfQuarter()       // 2013-10-01 00:00:00 Tue\nnow.BeginningOfYear()          // 2013-01-01 00:00:00 Tue\n\nnow.EndOfMinute()              // 2013-11-18 17:51:59.999999999 Mon\nnow.EndOfHour()                // 2013-11-18 17:59:59.999999999 Mon\nnow.EndOfDay()                 // 2013-11-18 23:59:59.999999999 Mon\nnow.EndOfWeek()                // 2013-11-23 23:59:59.999999999 Sat\nnow.EndOfMonth()               // 2013-11-30 23:59:59.999999999 Sat\nnow.EndOfQuarter()             // 2013-12-31 23:59:59.999999999 Tue\nnow.EndOfYear()                // 2013-12-31 23:59:59.999999999 Tue\n\nnow.WeekStartDay = time.Monday // Set Monday as first day, default is Sunday\nnow.EndOfWeek()                // 2013-11-24 23:59:59.999999999 Sun\n```\n\nCalculating time based on another time\n\n```go\nt := time.Date(2013, 02, 18, 17, 51, 49, 123456789, time.Now().Location())\nnow.With(t).EndOfMonth()   // 2013-02-28 23:59:59.999999999 Thu\n```\n\nCalculating time based on configuration\n\n```go\nlocation, err := time.LoadLocation(\"Asia/Shanghai\")\n\nmyConfig := &now.Config{\n\tWeekStartDay: time.Monday,\n\tTimeLocation: location,\n\tTimeFormats: []string{\"2006-01-02 15:04:05\"},\n}\n\nt := time.Date(2013, 11, 18, 17, 51, 49, 123456789, time.Now().Location()) // // 2013-11-18 17:51:49.123456789 Mon\nmyConfig.With(t).BeginningOfWeek()         // 2013-11-18 00:00:00 Mon\n\nmyConfig.Parse(\"2002-10-12 22:14:01\")     // 2002-10-12 22:14:01\nmyConfig.Parse(\"2002-10-12 22:14\")        // returns error 'can't parse string as time: 2002-10-12 22:14'\n```\n\n### Monday/Sunday\n\nDon't be bothered with the `WeekStartDay` setting, you can use `Monday`, `Sunday`\n\n```go\nnow.Monday()              // 2013-11-18 00:00:00 Mon\nnow.Monday(\"17:44\")       // 2013-11-18 17:44:00 Mon\nnow.Sunday()              // 2013-11-24 00:00:00 Sun (Next Sunday)\nnow.Sunday(\"18:19:24\")    // 2013-11-24 18:19:24 Sun (Next Sunday)\nnow.EndOfSunday()         // 2013-11-24 23:59:59.999999999 Sun (End of next Sunday)\n\nt := time.Date(2013, 11, 24, 17, 51, 49, 123456789, time.Now().Location()) // 2013-11-24 17:51:49.123456789 Sun\nnow.With(t).Monday()              // 2013-11-18 00:00:00 Mon (Last Monday if today is Sunday)\nnow.With(t).Monday(\"17:44\")       // 2013-11-18 17:44:00 Mon (Last Monday if today is Sunday)\nnow.With(t).Sunday()              // 2013-11-24 00:00:00 Sun (Beginning Of Today if today is Sunday)\nnow.With(t).Sunday(\"18:19:24\")    // 2013-11-24 18:19:24 Sun (Beginning Of Today if today is Sunday)\nnow.With(t).EndOfSunday()         // 2013-11-24 23:59:59.999999999 Sun (End of Today if today is Sunday)\n```\n\n### Parse String to Time\n\n```go\ntime.Now() // 2013-11-18 17:51:49.123456789 Mon\n\n// Parse(string) (time.Time, error)\nt, err := now.Parse(\"2017\")                // 2017-01-01 00:00:00, nil\nt, err := now.Parse(\"2017-10\")             // 2017-10-01 00:00:00, nil\nt, err := now.Parse(\"2017-10-13\")          // 2017-10-13 00:00:00, nil\nt, err := now.Parse(\"1999-12-12 12\")       // 1999-12-12 12:00:00, nil\nt, err := now.Parse(\"1999-12-12 12:20\")    // 1999-12-12 12:20:00, nil\nt, err := now.Parse(\"1999-12-12 12:20:21\") // 1999-12-12 12:20:21, nil\nt, err := now.Parse(\"10-13\")               // 2013-10-13 00:00:00, nil\nt, err := now.Parse(\"12:20\")               // 2013-11-18 12:20:00, nil\nt, err := now.Parse(\"12:20:13\")            // 2013-11-18 12:20:13, nil\nt, err := now.Parse(\"14\")                  // 2013-11-18 14:00:00, nil\nt, err := now.Parse(\"99:99\")               // 2013-11-18 12:20:00, Can't parse string as time: 99:99\n\n// MustParse must parse string to time or it will panic\nnow.MustParse(\"2013-01-13\")             // 2013-01-13 00:00:00\nnow.MustParse(\"02-17\")                  // 2013-02-17 00:00:00\nnow.MustParse(\"2-17\")                   // 2013-02-17 00:00:00\nnow.MustParse(\"8\")                      // 2013-11-18 08:00:00\nnow.MustParse(\"2002-10-12 22:14\")       // 2002-10-12 22:14:00\nnow.MustParse(\"99:99\")                  // panic: Can't parse string as time: 99:99\n```\n\nExtend `now` to support more formats is quite easy, just update `now.TimeFormats` with other time layouts, e.g:\n\n```go\nnow.TimeFormats = append(now.TimeFormats, \"02 Jan 2006 15:04\")\n```\n\nPlease send me pull requests if you want a format to be supported officially\n\n## Contributing\n\nYou can help to make the project better, check out [http://gorm.io/contribute.html](http://gorm.io/contribute.html) for things you can do.\n\n# Author\n\n**jinzhu**\n\n* <http://github.com/jinzhu>\n* <wosmvp@gmail.com>\n* <http://twitter.com/zhangjinzhu>\n\n## License\n\nReleased under the [MIT License](http://www.opensource.org/licenses/MIT).\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.037109375,
          "content": "module github.com/jinzhu/now\n\ngo 1.12\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 5.0556640625,
          "content": "// Package now is a time toolkit for golang.\n//\n// More details README here: https://github.com/jinzhu/now\n//\n//  import \"github.com/jinzhu/now\"\n//\n//  now.BeginningOfMinute() // 2013-11-18 17:51:00 Mon\n//  now.BeginningOfDay()    // 2013-11-18 00:00:00 Mon\n//  now.EndOfDay()          // 2013-11-18 23:59:59.999999999 Mon\npackage now\n\nimport \"time\"\n\n// WeekStartDay set week start day, default is sunday\nvar WeekStartDay = time.Sunday\n\n// TimeFormats default time formats will be parsed as\nvar TimeFormats = []string{\n\t\"2006\", \"2006-1\", \"2006-1-2\", \"2006-1-2 15\", \"2006-1-2 15:4\", \"2006-1-2 15:4:5\", \"1-2\",\n\t\"15:4:5\", \"15:4\", \"15\",\n\t\"15:4:5 Jan 2, 2006 MST\", \"2006-01-02 15:04:05.999999999 -0700 MST\", \"2006-01-02T15:04:05Z0700\", \"2006-01-02T15:04:05Z07\",\n\t\"2006.1.2\", \"2006.1.2 15:04:05\", \"2006.01.02\", \"2006.01.02 15:04:05\", \"2006.01.02 15:04:05.999999999\",\n\t\"1/2/2006\", \"1/2/2006 15:4:5\", \"2006/01/02\", \"20060102\", \"2006/01/02 15:04:05\",\n\ttime.ANSIC, time.UnixDate, time.RubyDate, time.RFC822, time.RFC822Z, time.RFC850,\n\ttime.RFC1123, time.RFC1123Z, time.RFC3339, time.RFC3339Nano,\n\ttime.Kitchen, time.Stamp, time.StampMilli, time.StampMicro, time.StampNano,\n}\n\n// Config configuration for now package\ntype Config struct {\n\tWeekStartDay time.Weekday\n\tTimeLocation *time.Location\n\tTimeFormats  []string\n}\n\n// DefaultConfig default config\nvar DefaultConfig *Config\n\n// New initialize Now based on configuration\nfunc (config *Config) With(t time.Time) *Now {\n\treturn &Now{Time: t, Config: config}\n}\n\n// Parse parse string to time based on configuration\nfunc (config *Config) Parse(strs ...string) (time.Time, error) {\n\tif config.TimeLocation == nil {\n\t\treturn config.With(time.Now()).Parse(strs...)\n\t} else {\n\t\treturn config.With(time.Now().In(config.TimeLocation)).Parse(strs...)\n\t}\n}\n\n// MustParse must parse string to time or will panic\nfunc (config *Config) MustParse(strs ...string) time.Time {\n\tif config.TimeLocation == nil {\n\t\treturn config.With(time.Now()).MustParse(strs...)\n\t} else {\n\t\treturn config.With(time.Now().In(config.TimeLocation)).MustParse(strs...)\n\t}\n}\n\n// Now now struct\ntype Now struct {\n\ttime.Time\n\t*Config\n}\n\n// With initialize Now with time\nfunc With(t time.Time) *Now {\n\tconfig := DefaultConfig\n\tif config == nil {\n\t\tconfig = &Config{\n\t\t\tWeekStartDay: WeekStartDay,\n\t\t\tTimeFormats:  TimeFormats,\n\t\t}\n\t}\n\n\treturn &Now{Time: t, Config: config}\n}\n\n// New initialize Now with time\nfunc New(t time.Time) *Now {\n\treturn With(t)\n}\n\n// BeginningOfMinute beginning of minute\nfunc BeginningOfMinute() time.Time {\n\treturn With(time.Now()).BeginningOfMinute()\n}\n\n// BeginningOfHour beginning of hour\nfunc BeginningOfHour() time.Time {\n\treturn With(time.Now()).BeginningOfHour()\n}\n\n// BeginningOfDay beginning of day\nfunc BeginningOfDay() time.Time {\n\treturn With(time.Now()).BeginningOfDay()\n}\n\n// BeginningOfWeek beginning of week\nfunc BeginningOfWeek() time.Time {\n\treturn With(time.Now()).BeginningOfWeek()\n}\n\n// BeginningOfMonth beginning of month\nfunc BeginningOfMonth() time.Time {\n\treturn With(time.Now()).BeginningOfMonth()\n}\n\n// BeginningOfQuarter beginning of quarter\nfunc BeginningOfQuarter() time.Time {\n\treturn With(time.Now()).BeginningOfQuarter()\n}\n\n// BeginningOfYear beginning of year\nfunc BeginningOfYear() time.Time {\n\treturn With(time.Now()).BeginningOfYear()\n}\n\n// EndOfMinute end of minute\nfunc EndOfMinute() time.Time {\n\treturn With(time.Now()).EndOfMinute()\n}\n\n// EndOfHour end of hour\nfunc EndOfHour() time.Time {\n\treturn With(time.Now()).EndOfHour()\n}\n\n// EndOfDay end of day\nfunc EndOfDay() time.Time {\n\treturn With(time.Now()).EndOfDay()\n}\n\n// EndOfWeek end of week\nfunc EndOfWeek() time.Time {\n\treturn With(time.Now()).EndOfWeek()\n}\n\n// EndOfMonth end of month\nfunc EndOfMonth() time.Time {\n\treturn With(time.Now()).EndOfMonth()\n}\n\n// EndOfQuarter end of quarter\nfunc EndOfQuarter() time.Time {\n\treturn With(time.Now()).EndOfQuarter()\n}\n\n// EndOfYear end of year\nfunc EndOfYear() time.Time {\n\treturn With(time.Now()).EndOfYear()\n}\n\n// Monday monday\n\nfunc Monday(strs ...string) time.Time {\n\treturn With(time.Now()).Monday(strs...)\n}\n\n// Sunday sunday\nfunc Sunday(strs ...string) time.Time {\n\treturn With(time.Now()).Sunday(strs...)\n}\n\n// EndOfSunday end of sunday\nfunc EndOfSunday() time.Time {\n\treturn With(time.Now()).EndOfSunday()\n}\n\n// Quarter returns the yearly quarter\nfunc Quarter() uint {\n\treturn With(time.Now()).Quarter()\n}\n\n// Parse parse string to time\nfunc Parse(strs ...string) (time.Time, error) {\n\treturn With(time.Now()).Parse(strs...)\n}\n\n// ParseInLocation parse string to time in location\nfunc ParseInLocation(loc *time.Location, strs ...string) (time.Time, error) {\n\treturn With(time.Now().In(loc)).Parse(strs...)\n}\n\n// MustParse must parse string to time or will panic\nfunc MustParse(strs ...string) time.Time {\n\treturn With(time.Now()).MustParse(strs...)\n}\n\n// MustParseInLocation must parse string to time in location or will panic\nfunc MustParseInLocation(loc *time.Location, strs ...string) time.Time {\n\treturn With(time.Now().In(loc)).MustParse(strs...)\n}\n\n// Between check now between the begin, end time or not\nfunc Between(time1, time2 string) bool {\n\treturn With(time.Now()).Between(time1, time2)\n}\n"
        },
        {
          "name": "now.go",
          "type": "blob",
          "size": 6.29296875,
          "content": "package now\n\nimport (\n\t\"errors\"\n\t\"regexp\"\n\t\"time\"\n)\n\n// BeginningOfMinute beginning of minute\nfunc (now *Now) BeginningOfMinute() time.Time {\n\treturn now.Truncate(time.Minute)\n}\n\n// BeginningOfHour beginning of hour\nfunc (now *Now) BeginningOfHour() time.Time {\n\ty, m, d := now.Date()\n\treturn time.Date(y, m, d, now.Time.Hour(), 0, 0, 0, now.Time.Location())\n}\n\n// BeginningOfDay beginning of day\nfunc (now *Now) BeginningOfDay() time.Time {\n\ty, m, d := now.Date()\n\treturn time.Date(y, m, d, 0, 0, 0, 0, now.Time.Location())\n}\n\n// BeginningOfWeek beginning of week\nfunc (now *Now) BeginningOfWeek() time.Time {\n\tt := now.BeginningOfDay()\n\tweekday := int(t.Weekday())\n\n\tif now.WeekStartDay != time.Sunday {\n\t\tweekStartDayInt := int(now.WeekStartDay)\n\n\t\tif weekday < weekStartDayInt {\n\t\t\tweekday = weekday + 7 - weekStartDayInt\n\t\t} else {\n\t\t\tweekday = weekday - weekStartDayInt\n\t\t}\n\t}\n\treturn t.AddDate(0, 0, -weekday)\n}\n\n// BeginningOfMonth beginning of month\nfunc (now *Now) BeginningOfMonth() time.Time {\n\ty, m, _ := now.Date()\n\treturn time.Date(y, m, 1, 0, 0, 0, 0, now.Location())\n}\n\n// BeginningOfQuarter beginning of quarter\nfunc (now *Now) BeginningOfQuarter() time.Time {\n\tmonth := now.BeginningOfMonth()\n\toffset := (int(month.Month()) - 1) % 3\n\treturn month.AddDate(0, -offset, 0)\n}\n\n// BeginningOfHalf beginning of half year\nfunc (now *Now) BeginningOfHalf() time.Time {\n\tmonth := now.BeginningOfMonth()\n\toffset := (int(month.Month()) - 1) % 6\n\treturn month.AddDate(0, -offset, 0)\n}\n\n// BeginningOfYear BeginningOfYear beginning of year\nfunc (now *Now) BeginningOfYear() time.Time {\n\ty, _, _ := now.Date()\n\treturn time.Date(y, time.January, 1, 0, 0, 0, 0, now.Location())\n}\n\n// EndOfMinute end of minute\nfunc (now *Now) EndOfMinute() time.Time {\n\treturn now.BeginningOfMinute().Add(time.Minute - time.Nanosecond)\n}\n\n// EndOfHour end of hour\nfunc (now *Now) EndOfHour() time.Time {\n\treturn now.BeginningOfHour().Add(time.Hour - time.Nanosecond)\n}\n\n// EndOfDay end of day\nfunc (now *Now) EndOfDay() time.Time {\n\ty, m, d := now.Date()\n\treturn time.Date(y, m, d, 23, 59, 59, int(time.Second-time.Nanosecond), now.Location())\n}\n\n// EndOfWeek end of week\nfunc (now *Now) EndOfWeek() time.Time {\n\treturn now.BeginningOfWeek().AddDate(0, 0, 7).Add(-time.Nanosecond)\n}\n\n// EndOfMonth end of month\nfunc (now *Now) EndOfMonth() time.Time {\n\treturn now.BeginningOfMonth().AddDate(0, 1, 0).Add(-time.Nanosecond)\n}\n\n// EndOfQuarter end of quarter\nfunc (now *Now) EndOfQuarter() time.Time {\n\treturn now.BeginningOfQuarter().AddDate(0, 3, 0).Add(-time.Nanosecond)\n}\n\n// EndOfHalf end of half year\nfunc (now *Now) EndOfHalf() time.Time {\n\treturn now.BeginningOfHalf().AddDate(0, 6, 0).Add(-time.Nanosecond)\n}\n\n// EndOfYear end of year\nfunc (now *Now) EndOfYear() time.Time {\n\treturn now.BeginningOfYear().AddDate(1, 0, 0).Add(-time.Nanosecond)\n}\n\n// Monday monday\n/*\nfunc (now *Now) Monday() time.Time {\n\tt := now.BeginningOfDay()\n\tweekday := int(t.Weekday())\n\tif weekday == 0 {\n\t\tweekday = 7\n\t}\n\treturn t.AddDate(0, 0, -weekday+1)\n}\n*/\n\nfunc (now *Now) Monday(strs ...string) time.Time {\n\tvar parseTime time.Time\n\tvar err error\n\tif len(strs) > 0 {\n\t\tparseTime, err = now.Parse(strs...)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\tparseTime = now.BeginningOfDay()\n\t}\n\tweekday := int(parseTime.Weekday())\n\tif weekday == 0 {\n\t\tweekday = 7\n\t}\n\treturn parseTime.AddDate(0, 0, -weekday+1)\n}\n\nfunc (now *Now) Sunday(strs ...string) time.Time {\n\tvar parseTime time.Time\n\tvar err error\n\tif len(strs) > 0 {\n\t\tparseTime, err = now.Parse(strs...)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t} else {\n\t\tparseTime = now.BeginningOfDay()\n\t}\n\tweekday := int(parseTime.Weekday())\n\tif weekday == 0 {\n\t\tweekday = 7\n\t}\n\treturn parseTime.AddDate(0, 0, (7 - weekday))\n}\n\n// EndOfSunday end of sunday\nfunc (now *Now) EndOfSunday() time.Time {\n\treturn New(now.Sunday()).EndOfDay()\n}\n\n// Quarter returns the yearly quarter\nfunc (now *Now) Quarter() uint {\n\treturn (uint(now.Month())-1)/3 + 1\n}\n\nfunc (now *Now) parseWithFormat(str string, location *time.Location) (t time.Time, err error) {\n\tfor _, format := range now.TimeFormats {\n\t\tt, err = time.ParseInLocation(format, str, location)\n\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\terr = errors.New(\"Can't parse string as time: \" + str)\n\treturn\n}\n\nvar hasTimeRegexp = regexp.MustCompile(`(\\s+|^\\s*|T)\\d{1,2}((:\\d{1,2})*|((:\\d{1,2}){2}\\.(\\d{3}|\\d{6}|\\d{9})))(\\s*$|[Z+-])`) // match 15:04:05, 15:04:05.000, 15:04:05.000000 15, 2017-01-01 15:04, 2021-07-20T00:59:10Z, 2021-07-20T00:59:10+08:00, 2021-07-20T00:00:10-07:00 etc\nvar onlyTimeRegexp = regexp.MustCompile(`^\\s*\\d{1,2}((:\\d{1,2})*|((:\\d{1,2}){2}\\.(\\d{3}|\\d{6}|\\d{9})))\\s*$`)            // match 15:04:05, 15, 15:04:05.000, 15:04:05.000000, etc\n\n// Parse parse string to time\nfunc (now *Now) Parse(strs ...string) (t time.Time, err error) {\n\tvar (\n\t\tsetCurrentTime  bool\n\t\tparseTime       []int\n\t\tcurrentLocation = now.Location()\n\t\tonlyTimeInStr   = true\n\t\tcurrentTime     = formatTimeToList(now.Time)\n\t)\n\n\tfor _, str := range strs {\n\t\thasTimeInStr := hasTimeRegexp.MatchString(str) // match 15:04:05, 15\n\t\tonlyTimeInStr = hasTimeInStr && onlyTimeInStr && onlyTimeRegexp.MatchString(str)\n\t\tif t, err = now.parseWithFormat(str, currentLocation); err == nil {\n\t\t\tlocation := t.Location()\n\t\t\tparseTime = formatTimeToList(t)\n\n\t\t\tfor i, v := range parseTime {\n\t\t\t\t// Don't reset hour, minute, second if current time str including time\n\t\t\t\tif hasTimeInStr && i <= 3 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// If value is zero, replace it with current time\n\t\t\t\tif v == 0 {\n\t\t\t\t\tif setCurrentTime {\n\t\t\t\t\t\tparseTime[i] = currentTime[i]\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tsetCurrentTime = true\n\t\t\t\t}\n\n\t\t\t\t// if current time only includes time, should change day, month to current time\n\t\t\t\tif onlyTimeInStr {\n\t\t\t\t\tif i == 4 || i == 5 {\n\t\t\t\t\t\tparseTime[i] = currentTime[i]\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt = time.Date(parseTime[6], time.Month(parseTime[5]), parseTime[4], parseTime[3], parseTime[2], parseTime[1], parseTime[0], location)\n\t\t\tcurrentTime = formatTimeToList(t)\n\t\t}\n\t}\n\treturn\n}\n\n// MustParse must parse string to time or it will panic\nfunc (now *Now) MustParse(strs ...string) (t time.Time) {\n\tt, err := now.Parse(strs...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn t\n}\n\n// Between check time between the begin, end time or not\nfunc (now *Now) Between(begin, end string) bool {\n\tbeginTime := now.MustParse(begin)\n\tendTime := now.MustParse(end)\n\treturn now.After(beginTime) && now.Before(endTime)\n}\n"
        },
        {
          "name": "now_test.go",
          "type": "blob",
          "size": 17.984375,
          "content": "package now\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nvar (\n\tformat          = \"2006-01-02 15:04:05.999999999\"\n\tlocationCaracas *time.Location\n\tlocationBerlin  *time.Location\n\ttimeCaracas     time.Time\n)\n\nfunc init() {\n\tvar err error\n\tif locationCaracas, err = time.LoadLocation(\"America/Caracas\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif locationBerlin, err = time.LoadLocation(\"Europe/Berlin\"); err != nil {\n\t\tpanic(err)\n\t}\n\n\ttimeCaracas = time.Date(2016, 1, 1, 12, 10, 0, 0, locationCaracas)\n}\n\nfunc assertT(t *testing.T) func(time.Time, string, string) {\n\treturn func(actual time.Time, expected string, msg string) {\n\t\tactualStr := actual.Format(format)\n\t\tif actualStr != expected {\n\t\t\tt.Errorf(\"Failed %s: actual: %v, expected: %v\", msg, actualStr, expected)\n\t\t}\n\t}\n}\n\nfunc TestBeginningOf(t *testing.T) {\n\tassert := assertT(t)\n\n\tn := time.Date(2013, 11, 18, 17, 51, 49, 123456789, time.UTC)\n\n\tassert(With(n).BeginningOfMinute(), \"2013-11-18 17:51:00\", \"BeginningOfMinute\")\n\n\tWeekStartDay = time.Monday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-18 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n\n\tWeekStartDay = time.Tuesday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-12 00:00:00\", \"BeginningOfWeek, FirstDayTuesday\")\n\n\tWeekStartDay = time.Wednesday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-13 00:00:00\", \"BeginningOfWeek, FirstDayWednesday\")\n\n\tWeekStartDay = time.Thursday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-14 00:00:00\", \"BeginningOfWeek, FirstDayThursday\")\n\n\tWeekStartDay = time.Friday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-15 00:00:00\", \"BeginningOfWeek, FirstDayFriday\")\n\n\tWeekStartDay = time.Saturday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-16 00:00:00\", \"BeginningOfWeek, FirstDaySaturday\")\n\n\tWeekStartDay = time.Sunday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-17 00:00:00\", \"BeginningOfWeek, FirstDaySunday\")\n\n\tassert(With(n).BeginningOfHour(), \"2013-11-18 17:00:00\", \"BeginningOfHour\")\n\n\t// Truncate with hour bug\n\tassert(With(timeCaracas).BeginningOfHour(), \"2016-01-01 12:00:00\", \"BeginningOfHour Caracas\")\n\n\tassert(With(n).BeginningOfDay(), \"2013-11-18 00:00:00\", \"BeginningOfDay\")\n\n\tlocation, err := time.LoadLocation(\"Japan\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error loading location: %v\", err)\n\t}\n\tbeginningOfDay := time.Date(2015, 05, 01, 0, 0, 0, 0, location)\n\tassert(With(beginningOfDay).BeginningOfDay(), \"2015-05-01 00:00:00\", \"BeginningOfDay\")\n\n\t// DST\n\tdstBeginningOfDay := time.Date(2017, 10, 29, 10, 0, 0, 0, locationBerlin)\n\tassert(With(dstBeginningOfDay).BeginningOfDay(), \"2017-10-29 00:00:00\", \"BeginningOfDay DST\")\n\n\tassert(With(n).BeginningOfWeek(), \"2013-11-17 00:00:00\", \"BeginningOfWeek\")\n\n\tdstBegginingOfWeek := time.Date(2017, 10, 30, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstBegginingOfWeek).BeginningOfWeek(), \"2017-10-29 00:00:00\", \"BeginningOfWeek\")\n\n\tdstBegginingOfWeek = time.Date(2017, 10, 29, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstBegginingOfWeek).BeginningOfWeek(), \"2017-10-29 00:00:00\", \"BeginningOfWeek\")\n\n\tWeekStartDay = time.Monday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-18 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n\tdstBegginingOfWeek = time.Date(2017, 10, 24, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstBegginingOfWeek).BeginningOfWeek(), \"2017-10-23 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n\n\tdstBegginingOfWeek = time.Date(2017, 10, 29, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstBegginingOfWeek).BeginningOfWeek(), \"2017-10-23 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n\n\tWeekStartDay = time.Sunday\n\n\tassert(With(n).BeginningOfMonth(), \"2013-11-01 00:00:00\", \"BeginningOfMonth\")\n\n\t// DST\n\tdstBeginningOfMonth := time.Date(2017, 10, 31, 0, 0, 0, 0, locationBerlin)\n\tassert(With(dstBeginningOfMonth).BeginningOfMonth(), \"2017-10-01 00:00:00\", \"BeginningOfMonth DST\")\n\n\tassert(With(n).BeginningOfQuarter(), \"2013-10-01 00:00:00\", \"BeginningOfQuarter\")\n\n\t// DST\n\tassert(With(dstBeginningOfMonth).BeginningOfQuarter(), \"2017-10-01 00:00:00\", \"BeginningOfQuarter DST\")\n\tdstBeginningOfQuarter := time.Date(2017, 11, 24, 0, 0, 0, 0, locationBerlin)\n\tassert(With(dstBeginningOfQuarter).BeginningOfQuarter(), \"2017-10-01 00:00:00\", \"BeginningOfQuarter DST\")\n\n\tassert(With(dstBeginningOfQuarter).BeginningOfHalf(), \"2017-07-01 00:00:00\", \"BeginningOfHalf DST\")\n\n\tassert(With(n.AddDate(0, -1, 0)).BeginningOfQuarter(), \"2013-10-01 00:00:00\", \"BeginningOfQuarter\")\n\n\tassert(With(n.AddDate(0, 1, 0)).BeginningOfQuarter(), \"2013-10-01 00:00:00\", \"BeginningOfQuarter\")\n\n\tassert(With(n.AddDate(0, 1, 0)).BeginningOfHalf(), \"2013-07-01 00:00:00\", \"BeginningOfHalf\")\n\n\t// DST\n\tassert(With(dstBeginningOfQuarter).BeginningOfYear(), \"2017-01-01 00:00:00\", \"BeginningOfYear DST\")\n\n\tassert(With(timeCaracas).BeginningOfYear(), \"2016-01-01 00:00:00\", \"BeginningOfYear Caracas\")\n}\n\nfunc TestEndOf(t *testing.T) {\n\tassert := assertT(t)\n\n\tn := time.Date(2013, 11, 18, 17, 51, 49, 123456789, time.UTC)\n\n\tassert(With(n).EndOfMinute(), \"2013-11-18 17:51:59.999999999\", \"EndOfMinute\")\n\n\tassert(With(n).EndOfHour(), \"2013-11-18 17:59:59.999999999\", \"EndOfHour\")\n\n\tassert(With(timeCaracas).EndOfHour(), \"2016-01-01 12:59:59.999999999\", \"EndOfHour Caracas\")\n\n\tassert(With(n).EndOfDay(), \"2013-11-18 23:59:59.999999999\", \"EndOfDay\")\n\n\tdstEndOfDay := time.Date(2017, 10, 29, 1, 0, 0, 0, locationBerlin)\n\tassert(With(dstEndOfDay).EndOfDay(), \"2017-10-29 23:59:59.999999999\", \"EndOfDay DST\")\n\n\tWeekStartDay = time.Tuesday\n\tassert(With(n).EndOfWeek(), \"2013-11-18 23:59:59.999999999\", \"EndOfWeek, FirstDayTuesday\")\n\n\tWeekStartDay = time.Wednesday\n\tassert(With(n).EndOfWeek(), \"2013-11-19 23:59:59.999999999\", \"EndOfWeek, FirstDayWednesday\")\n\n\tWeekStartDay = time.Thursday\n\tassert(With(n).EndOfWeek(), \"2013-11-20 23:59:59.999999999\", \"EndOfWeek, FirstDayThursday\")\n\n\tWeekStartDay = time.Friday\n\tassert(With(n).EndOfWeek(), \"2013-11-21 23:59:59.999999999\", \"EndOfWeek, FirstDayFriday\")\n\n\tWeekStartDay = time.Saturday\n\tassert(With(n).EndOfWeek(), \"2013-11-22 23:59:59.999999999\", \"EndOfWeek, FirstDaySaturday\")\n\n\tWeekStartDay = time.Sunday\n\tassert(With(n).EndOfWeek(), \"2013-11-23 23:59:59.999999999\", \"EndOfWeek, FirstDaySunday\")\n\n\tWeekStartDay = time.Monday\n\tassert(With(n).EndOfWeek(), \"2013-11-24 23:59:59.999999999\", \"EndOfWeek, FirstDayMonday\")\n\n\tdstEndOfWeek := time.Date(2017, 10, 24, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstEndOfWeek).EndOfWeek(), \"2017-10-29 23:59:59.999999999\", \"EndOfWeek, FirstDayMonday\")\n\n\tdstEndOfWeek = time.Date(2017, 10, 29, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstEndOfWeek).EndOfWeek(), \"2017-10-29 23:59:59.999999999\", \"EndOfWeek, FirstDayMonday\")\n\n\tWeekStartDay = time.Sunday\n\tassert(With(n).EndOfWeek(), \"2013-11-23 23:59:59.999999999\", \"EndOfWeek\")\n\n\tdstEndOfWeek = time.Date(2017, 10, 29, 0, 0, 0, 0, locationBerlin)\n\tassert(With(dstEndOfWeek).EndOfWeek(), \"2017-11-04 23:59:59.999999999\", \"EndOfWeek\")\n\n\tdstEndOfWeek = time.Date(2017, 10, 29, 12, 0, 0, 0, locationBerlin)\n\tassert(With(dstEndOfWeek).EndOfWeek(), \"2017-11-04 23:59:59.999999999\", \"EndOfWeek\")\n\n\tassert(With(n).EndOfMonth(), \"2013-11-30 23:59:59.999999999\", \"EndOfMonth\")\n\n\tassert(With(n).EndOfQuarter(), \"2013-12-31 23:59:59.999999999\", \"EndOfQuarter\")\n\n\tassert(With(n).EndOfHalf(), \"2013-12-31 23:59:59.999999999\", \"EndOfHalf\")\n\n\tassert(With(n.AddDate(0, -1, 0)).EndOfQuarter(), \"2013-12-31 23:59:59.999999999\", \"EndOfQuarter\")\n\n\tassert(With(n.AddDate(0, 1, 0)).EndOfQuarter(), \"2013-12-31 23:59:59.999999999\", \"EndOfQuarter\")\n\n\tassert(With(n.AddDate(0, 1, 0)).EndOfHalf(), \"2013-12-31 23:59:59.999999999\", \"EndOfHalf\")\n\n\tassert(With(n).EndOfYear(), \"2013-12-31 23:59:59.999999999\", \"EndOfYear\")\n\n\tn1 := time.Date(2013, 02, 18, 17, 51, 49, 123456789, time.UTC)\n\tassert(With(n1).EndOfMonth(), \"2013-02-28 23:59:59.999999999\", \"EndOfMonth for 2013/02\")\n\n\tn2 := time.Date(1900, 02, 18, 17, 51, 49, 123456789, time.UTC)\n\tassert(With(n2).EndOfMonth(), \"1900-02-28 23:59:59.999999999\", \"EndOfMonth\")\n}\n\nfunc TestMondayAndSunday(t *testing.T) {\n\tassert := assertT(t)\n\n\tn := time.Date(2013, 11, 19, 17, 51, 49, 123456789, time.UTC)\n\tn2 := time.Date(2013, 11, 24, 17, 51, 49, 123456789, time.UTC)\n\tnDst := time.Date(2017, 10, 29, 10, 0, 0, 0, locationBerlin)\n\n\tassert(With(n).Monday(), \"2013-11-18 00:00:00\", \"Monday\")\n\n\tassert(With(n2).Monday(), \"2013-11-18 00:00:00\", \"Monday\")\n\n\tassert(With(timeCaracas).Monday(), \"2015-12-28 00:00:00\", \"Monday Caracas\")\n\n\tassert(With(nDst).Monday(), \"2017-10-23 00:00:00\", \"Monday DST\")\n\n\tassert(With(n).Monday(\"17:51:49\"), \"2013-11-18 17:51:49\", \"Monday\")\n\n\tassert(With(n).Monday(\"17:51\"), \"2013-11-18 17:51:00\", \"Monday\")\n\n\tassert(With(n).Sunday(), \"2013-11-24 00:00:00\", \"Sunday\")\n\n\tassert(With(n).Sunday(\"18:19:20\"), \"2013-11-24 18:19:20\", \"Sunday\")\n\n\tassert(With(n).Sunday(\"18:19\"), \"2013-11-24 18:19:00\", \"Sunday\")\n\n\tassert(With(n2).Sunday(), \"2013-11-24 00:00:00\", \"Sunday\")\n\n\tassert(With(timeCaracas).Sunday(), \"2016-01-03 00:00:00\", \"Sunday Caracas\")\n\n\tassert(With(nDst).Sunday(), \"2017-10-29 00:00:00\", \"Sunday DST\")\n\n\tassert(With(n).EndOfSunday(), \"2013-11-24 23:59:59.999999999\", \"EndOfSunday\")\n\n\tassert(With(timeCaracas).EndOfSunday(), \"2016-01-03 23:59:59.999999999\", \"EndOfSunday Caracas\")\n\n\tassert(With(nDst).EndOfSunday(), \"2017-10-29 23:59:59.999999999\", \"EndOfSunday DST\")\n\n\tassert(With(n).BeginningOfWeek(), \"2013-11-17 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n\n\tWeekStartDay = time.Monday\n\tassert(With(n).BeginningOfWeek(), \"2013-11-18 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n}\n\nfunc TestParse(t *testing.T) {\n\tassert := assertT(t)\n\n\tn := time.Date(2013, 11, 18, 17, 51, 49, 123456789, time.UTC)\n\n\tassert(With(n).MustParse(\"2002\"), \"2002-01-01 00:00:00\", \"Parse 2002\")\n\n\tassert(With(n).MustParse(\"2002-10\"), \"2002-10-01 00:00:00\", \"Parse 2002-10\")\n\n\tassert(With(n).MustParse(\"2002-10-12\"), \"2002-10-12 00:00:00\", \"Parse 2002-10-12\")\n\n\tassert(With(n).MustParse(\"2002-10-12 22\"), \"2002-10-12 22:00:00\", \"Parse 2002-10-12 22\")\n\n\tassert(With(n).MustParse(\"2002-10-12 22:14\"), \"2002-10-12 22:14:00\", \"Parse 2002-10-12 22:14\")\n\n\tassert(With(n).MustParse(\"2002-10-12 2:4\"), \"2002-10-12 02:04:00\", \"Parse 2002-10-12 2:4\")\n\n\tassert(With(n).MustParse(\"2002-10-12 02:04\"), \"2002-10-12 02:04:00\", \"Parse 2002-10-12 02:04\")\n\n\tassert(With(n).MustParse(\"2002-10-12 22:14:56\"), \"2002-10-12 22:14:56\", \"Parse 2002-10-12 22:14:56\")\n\n\tassert(With(n).MustParse(\"2002-10-12 00:14:56\"), \"2002-10-12 00:14:56\", \"Parse 2002-10-12 00:14:56\")\n\n\tassert(With(n).MustParse(\"2013-12-19 23:28:09.999999999 +0800 CST\"), \"2013-12-19 23:28:09.999999999\", \"Parse two strings 2013-12-19 23:28:09.999999999 +0800 CST\")\n\n\tassert(With(n).MustParse(\"10-12\"), \"2013-10-12 00:00:00\", \"Parse 10-12\")\n\n\tassert(With(n).MustParse(\"18\"), \"2013-11-18 18:00:00\", \"Parse 18 as hour\")\n\n\tassert(With(n).MustParse(\"18:20\"), \"2013-11-18 18:20:00\", \"Parse 18:20\")\n\n\tassert(With(n).MustParse(\"00:01\"), \"2013-11-18 00:01:00\", \"Parse 00:01\")\n\n\tassert(With(n).MustParse(\"00:00:00\"), \"2013-11-18 00:00:00\", \"Parse 00:00:00\")\n\n\tassert(With(n).MustParse(\"18:20:39\"), \"2013-11-18 18:20:39\", \"Parse 18:20:39\")\n\n\tassert(With(n).MustParse(\"18:20:39\", \"2011-01-01\"), \"2011-01-01 18:20:39\", \"Parse two strings 18:20:39, 2011-01-01\")\n\n\tassert(With(n).MustParse(\"2011-1-1\", \"18:20:39\"), \"2011-01-01 18:20:39\", \"Parse two strings 2011-01-01, 18:20:39\")\n\n\tassert(With(n).MustParse(\"2011-01-01\", \"18\"), \"2011-01-01 18:00:00\", \"Parse two strings 2011-01-01, 18\")\n\n\tassert(With(n).MustParse(\"2002-10-12T00:14:56Z\"), \"2002-10-12 00:14:56\", \"Parse 2002-10-12T00:14:56Z\")\n\tassert(With(n).MustParse(\"2002-10-12T00:00:56Z\"), \"2002-10-12 00:00:56\", \"Parse 2002-10-12T00:00:56Z\")\n\tassert(With(n).MustParse(\"2002-10-12T00:00:00.999Z\"), \"2002-10-12 00:00:00.999\", \"Parse 2002-10-12T00:00:00.999Z\")\n\tassert(With(n).MustParse(\"2002-10-12T00:14:56.999999Z\"), \"2002-10-12 00:14:56.999999\", \"Parse 2002-10-12T00:14:56.999999Z\")\n\tassert(With(n).MustParse(\"2002-10-12T00:00:56.999999999Z\"), \"2002-10-12 00:00:56.999999999\", \"Parse 2002-10-12T00:00:56.999999999Z\")\n\n\tassert(With(n).MustParse(\"2002-10-12T00:14:56+08:00\"), \"2002-10-12 00:14:56\", \"Parse 2002-10-12T00:14:56+08:00\")\n\t_, off := With(n).MustParse(\"2002-10-12T00:14:56+08:00\").Zone()\n\tif (off != 28800) {\n\t\tt.Errorf(\"Parse 2002-10-12T00:14:56+08:00 shouldn't lose time zone offset\")\n\t}\n\tassert(With(n).MustParse(\"2002-10-12T00:00:56-07:00\"), \"2002-10-12 00:00:56\", \"Parse 2002-10-12T00:00:56-07:00\")\n\t_, off2 := With(n).MustParse(\"2002-10-12T00:00:56-07:00\").Zone()\n\tif (off2 != -25200){\n\t\tt.Errorf(\"Parse 2002-10-12T00:00:56-07:00 shouldn't lose time zone offset\")\n\t}\n\tassert(With(n).MustParse(\"2002-10-12T00:01:12.333+0200\"), \"2002-10-12 00:01:12.333\", \"Parse 2002-10-12T00:01:12.333+0200\")\n\t_, off3 := With(n).MustParse(\"2002-10-12T00:01:12.333+0200\").Zone()\n\tif (off3 != 7200){\n\t\tt.Errorf(\"Parse 2002-10-12T00:01:12.333+0200 shouldn't lose time zone offset\")\n\t}\n\tassert(With(n).MustParse(\"2002-10-12T00:00:56.999999999+08:00\"), \"2002-10-12 00:00:56.999999999\", \"Parse 2002-10-12T00:00:56.999999999+08:00\")\n\t_, off4 := With(n).MustParse(\"2002-10-12T00:14:56.999999999+08:00\").Zone()\n\tif (off4 != 28800) {\n\t\tt.Errorf(\"Parse 2002-10-12T00:14:56.999999999+08:00 shouldn't lose time zone offset\")\n\t}\n\tassert(With(n).MustParse(\"2002-10-12T00:00:56.666666-07:00\"), \"2002-10-12 00:00:56.666666\", \"Parse 2002-10-12T00:00:56.666666-07:00\")\n\t_, off5 := With(n).MustParse(\"2002-10-12T00:00:56.666666-07:00\").Zone()\n\tif (off5 != -25200){\n\t\tt.Errorf(\"Parse 2002-10-12T00:00:56.666666-07:00 shouldn't lose time zone offset\")\n\t}\n\tassert(With(n).MustParse(\"2002-10-12T00:01:12.999999999-06\"), \"2002-10-12 00:01:12.999999999\", \"Parse 2002-10-12T00:01:12.999999999-06\")\n\t_, off6 := With(n).MustParse(\"2002-10-12T00:01:12.999999999-06\").Zone()\n\tif (off6 != -21600){\n\t\tt.Errorf(\"Parse 2002-10-12T00:01:12.999999999-06 shouldn't lose time zone offset\")\n\t}\n\n\tTimeFormats = append(TimeFormats, \"02 Jan 15:04\")\n\tassert(With(n).MustParse(\"04 Feb 12:09\"), \"2013-02-04 12:09:00\", \"Parse 04 Feb 12:09 with specified format\")\n\n\tassert(With(n).MustParse(\"23:28:9 Dec 19, 2013 PST\"), \"2013-12-19 23:28:09\", \"Parse 23:28:9 Dec 19, 2013 PST\")\n\n\tif With(n).MustParse(\"23:28:9 Dec 19, 2013 PST\").Location().String() != \"PST\" {\n\t\tt.Errorf(\"Parse 23:28:9 Dec 19, 2013 PST shouldn't lose time zone\")\n\t}\n\n\tn2 := With(n).MustParse(\"23:28:9 Dec 19, 2013 PST\")\n\tif With(n2).MustParse(\"10:20\").Location().String() != \"PST\" {\n\t\tt.Errorf(\"Parse 10:20 shouldn't change time zone\")\n\t}\n\n\tTimeFormats = append(TimeFormats, \"2006-01-02T15:04:05.0\")\n\tif MustParseInLocation(time.UTC, \"2018-02-13T15:17:06.0\").String() != \"2018-02-13 15:17:06 +0000 UTC\" {\n\t\tt.Errorf(\"ParseInLocation 2018-02-13T15:17:06.0\")\n\t}\n\n\tTimeFormats = append(TimeFormats, \"2006-01-02 15:04:05.000\")\n\tassert(With(n).MustParse(\"2018-04-20 21:22:23.473\"), \"2018-04-20 21:22:23.473\", \"Parse 2018/04/20 21:22:23.473\")\n\n\tTimeFormats = append(TimeFormats, \"15:04:05.000\")\n\tassert(With(n).MustParse(\"13:00:01.365\"), \"2013-11-18 13:00:01.365\", \"Parse 13:00:01.365\")\n\n\tTimeFormats = append(TimeFormats, \"2006-01-02 15:04:05.000000\")\n\tassert(With(n).MustParse(\"2010-01-01 07:24:23.131384\"), \"2010-01-01 07:24:23.131384\", \"Parse 2010-01-01 07:24:23.131384\")\n\tassert(With(n).MustParse(\"00:00:00.182736\"), \"2013-11-18 00:00:00.182736\", \"Parse 00:00:00.182736\")\n\n\tn3 := MustParse(\"2017-12-11T10:25:49Z\")\n\tif n3.Location() != time.UTC {\n\t\tt.Errorf(\"time location should be UTC, but got %v\", n3.Location())\n\t}\n}\n\nfunc TestBetween(t *testing.T) {\n\ttm := time.Date(2015, 06, 30, 17, 51, 49, 123456789, time.Now().Location())\n\tif !With(tm).Between(\"23:28:9 Dec 19, 2013 PST\", \"23:28:9 Dec 19, 2015 PST\") {\n\t\tt.Errorf(\"Between\")\n\t}\n\n\tif !With(tm).Between(\"2015-05-12 12:20\", \"2015-06-30 17:51:50\") {\n\t\tt.Errorf(\"Between\")\n\t}\n}\n\nfunc TestConfig(t *testing.T) {\n\tassert := assertT(t)\n\n\tlocation, err := time.LoadLocation(\"Asia/Shanghai\")\n\tif err != nil {\n\t\tt.Errorf(\"load location for Asia/Shanghai should returns no error, but got %v\", err)\n\t}\n\n\tmyConfig := Config{\n\t\tWeekStartDay: time.Monday,\n\t\tTimeLocation: location,\n\t\tTimeFormats:  []string{\"2006-01-02 15:04:05\"},\n\t}\n\n\tn := time.Date(2013, 11, 18, 17, 51, 49, 123456789, time.Now().Location()) // // 2013-11-18 17:51:49.123456789 Mon\n\tassert(myConfig.With(n).BeginningOfWeek(), \"2013-11-18 00:00:00\", \"BeginningOfWeek, FirstDayMonday\")\n\n\tif result, _ := myConfig.Parse(\"2018-02-13 15:17:06\"); result.String() != \"2018-02-13 15:17:06 +0800 CST\" {\n\t\tt.Errorf(\"ParseInLocation 2018-02-13T15:17:06.0, got %v\", result)\n\t}\n\n\tif result := myConfig.MustParse(\"2018-02-13 15:17:06\"); result.String() != \"2018-02-13 15:17:06 +0800 CST\" {\n\t\tt.Errorf(\"ParseInLocation 2018-02-13T15:17:06.0, got %v\", result)\n\t}\n}\n\nfunc TestQuarter(t *testing.T) {\n\ttype test struct {\n\t\tgivenDate       time.Time\n\t\texpectedQuarter uint\n\t}\n\n\ttests := []test{\n\t\t{time.Date(2021, 6, 18, 0, 0, 0, 0, time.UTC), 2},\n\t\t{time.Date(2021, 7, 18, 0, 0, 0, 0, time.UTC), 3},\n\t}\n\n\tfor _, tc := range tests {\n\t\tgot := With(tc.givenDate).Quarter()\n\t\tif got != tc.expectedQuarter {\n\t\t\tt.Fatalf(\"Quarter %d expected, got %d\", tc.expectedQuarter, got)\n\t\t}\n\t}\n}\n\nfunc Example() {\n\ttime.Now() // 2013-11-18 17:51:49.123456789 Mon\n\n\tBeginningOfMinute() // 2013-11-18 17:51:00 Mon\n\tBeginningOfHour()   // 2013-11-18 17:00:00 Mon\n\tBeginningOfDay()    // 2013-11-18 00:00:00 Mon\n\tBeginningOfWeek()   // 2013-11-17 00:00:00 Sun\n\n\tWeekStartDay = time.Monday // Set Monday as first day\n\tBeginningOfWeek()          // 2013-11-18 00:00:00 Mon\n\tBeginningOfMonth()         // 2013-11-01 00:00:00 Fri\n\tBeginningOfQuarter()       // 2013-10-01 00:00:00 Tue\n\tBeginningOfYear()          // 2013-01-01 00:00:00 Tue\n\n\tEndOfMinute() // 2013-11-18 17:51:59.999999999 Mon\n\tEndOfHour()   // 2013-11-18 17:59:59.999999999 Mon\n\tEndOfDay()    // 2013-11-18 23:59:59.999999999 Mon\n\tEndOfWeek()   // 2013-11-23 23:59:59.999999999 Sat\n\n\tWeekStartDay = time.Monday // Set Monday as first day\n\tEndOfWeek()                // 2013-11-24 23:59:59.999999999 Sun\n\tEndOfMonth()               // 2013-11-30 23:59:59.999999999 Sat\n\tEndOfQuarter()             // 2013-12-31 23:59:59.999999999 Tue\n\tEndOfYear()                // 2013-12-31 23:59:59.999999999 Tue\n\n\t// Use another time\n\tt := time.Date(2013, 02, 18, 17, 51, 49, 123456789, time.UTC)\n\tWith(t).EndOfMonth() // 2013-02-28 23:59:59.999999999 Thu\n\n\tMonday()        // 2013-11-18 00:00:00 Mon\n\tMonday(\"17:44\") // 2013-11-18 17:44:00 Mon\n\tSunday()        // 2013-11-24 00:00:00 Sun\n\tSunday(\"17:44\") // 2013-11-24 17:44:00 Sun\n\tEndOfSunday()   // 2013-11-24 23:59:59.999999999 Sun\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 0.1962890625,
          "content": "package now\n\nimport \"time\"\n\nfunc formatTimeToList(t time.Time) []int {\n\thour, min, sec := t.Clock()\n\tyear, month, day := t.Date()\n\treturn []int{t.Nanosecond(), sec, min, hour, day, int(month), year}\n}\n"
        }
      ]
    }
  ]
}