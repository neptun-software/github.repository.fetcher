{
  "metadata": {
    "timestamp": 1736566483399,
    "page": 29,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "charmbracelet/huh",
      "stars": 4879,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.08203125,
          "content": "*.gif filter=lfs diff=lfs merge=lfs -text\n*.png filter=lfs diff=lfs merge=lfs -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.4892578125,
          "content": "# If you prefer the allow list template instead of the deny list, see community template:\n# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore\n#\n# Binaries for programs and plugins\n*.exe\n*.exe~\n*.dll\n*.so\n*.dylib\n\n# Test binary, built with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Dependency directories (remove the comment below to include it)\n# vendor/\n\n# Go workspace file\ngo.work\n\n# Debugging\ndebug.log\n"
        },
        {
          "name": ".golangci-soft.yml",
          "type": "blob",
          "size": 0.556640625,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - exhaustive\n    - goconst\n    - godot\n    - mnd\n    - gomoddirectives\n    - goprintffuncname\n    - misspell\n    - nakedret\n    - nestif\n    - noctx\n    - nolintlint\n    - prealloc\n    - wrapcheck\n\n  # disable default linters, they are already enabled in .golangci.yml\n  disable:\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - typecheck\n    - unused\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3603515625,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - goimports\n    - gosec\n    - nilerr\n    - predeclared\n    - revive\n    - rowserrcheck\n    - sqlclosecheck\n    - tparallel\n    - unconvert\n    - unparam\n    - whitespace\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.0830078125,
          "content": "Contributions are welcome!\n\nPlease submit a PR or open an issue to discuss features.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) 2023 Charm\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.2099609375,
          "content": ".PHONY: spinner\n\n$(V).SILENT:\ntest:\n\tgo test ./...\n\nspinner:\n\tcd spinner/examples/loading && go run .\n\nburger:\n\tcd examples/burger && go run .\n\ntheme:\n\tcd examples/theme && go run .\n\ngh:\n\tcd examples/gh && go run .\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 14.8720703125,
          "content": "# Huh?\n\n<p>\n  <img alt=\"Hey there! I’m Glenn!\" title=\"Hey there! I’m Glenn!\" src=\"https://stuff.charm.sh/huh/glenn.png\" width=\"400\" />\n  <br><br>\n  <a href=\"https://github.com/charmbracelet/huh/releases\"><img src=\"https://img.shields.io/github/release/charmbracelet/huh.svg\" alt=\"Latest Release\"></a>\n  <a href=\"https://pkg.go.dev/github.com/charmbracelet/huh?tab=doc\"><img src=\"https://godoc.org/github.com/golang/gddo?status.svg\" alt=\"Go Docs\"></a>\n  <a href=\"https://github.com/charmbracelet/huh/actions\"><img src=\"https://github.com/charmbracelet/huh/actions/workflows/build.yml/badge.svg?branch=main\" alt=\"Build Status\"></a>\n</p>\n\nA simple, powerful library for building interactive forms and prompts in the terminal.\n\n<img alt=\"Running a burger form\" width=\"600\" src=\"https://vhs.charm.sh/vhs-3J4i6HE3yBmz6SUO3HqILr.gif\">\n\n`huh?` is easy to use in a standalone fashion, can be\n[integrated into a Bubble Tea application](#what-about-bubble-tea), and contains\na first-class [accessible mode](#accessibility) for screen readers.\n\nThe above example is running from a single Go program ([source](./examples/burger/main.go)).\n\n## Tutorial\n\nLet’s build a form for ordering burgers. To start, we’ll import the library and\ndefine a few variables where’ll we store answers.\n\n```go\npackage main\n\nimport \"github.com/charmbracelet/huh\"\n\nvar (\n    burger       string\n    toppings     []string\n    sauceLevel   int\n    name         string\n    instructions string\n    discount     bool\n)\n```\n\n`huh?` separates forms into groups (you can think of groups as pages). Groups\nare made of fields (e.g. `Select`, `Input`, `Text`). We will set up three\ngroups for the customer to fill out.\n\n```go\nform := huh.NewForm(\n    huh.NewGroup(\n        // Ask the user for a base burger and toppings.\n        huh.NewSelect[string]().\n            Title(\"Choose your burger\").\n            Options(\n                huh.NewOption(\"Charmburger Classic\", \"classic\"),\n                huh.NewOption(\"Chickwich\", \"chickwich\"),\n                huh.NewOption(\"Fishburger\", \"fishburger\"),\n                huh.NewOption(\"Charmpossible™ Burger\", \"charmpossible\"),\n            ).\n            Value(&burger), // store the chosen option in the \"burger\" variable\n\n        // Let the user select multiple toppings.\n        huh.NewMultiSelect[string]().\n            Title(\"Toppings\").\n            Options(\n                huh.NewOption(\"Lettuce\", \"lettuce\").Selected(true),\n                huh.NewOption(\"Tomatoes\", \"tomatoes\").Selected(true),\n                huh.NewOption(\"Jalapeños\", \"jalapeños\"),\n                huh.NewOption(\"Cheese\", \"cheese\"),\n                huh.NewOption(\"Vegan Cheese\", \"vegan cheese\"),\n                huh.NewOption(\"Nutella\", \"nutella\"),\n            ).\n            Limit(4). // there’s a 4 topping limit!\n            Value(&toppings),\n\n        // Option values in selects and multi selects can be any type you\n        // want. We’ve been recording strings above, but here we’ll store\n        // answers as integers. Note the generic \"[int]\" directive below.\n        huh.NewSelect[int]().\n            Title(\"How much Charm Sauce do you want?\").\n            Options(\n                huh.NewOption(\"None\", 0),\n                huh.NewOption(\"A little\", 1),\n                huh.NewOption(\"A lot\", 2),\n            ).\n            Value(&sauceLevel),\n    ),\n\n    // Gather some final details about the order.\n    huh.NewGroup(\n        huh.NewInput().\n            Title(\"What’s your name?\").\n            Value(&name).\n            // Validating fields is easy. The form will mark erroneous fields\n            // and display error messages accordingly.\n            Validate(func(str string) error {\n                if str == \"Frank\" {\n                    return errors.New(\"Sorry, we don’t serve customers named Frank.\")\n                }\n                return nil\n            }),\n\n        huh.NewText().\n            Title(\"Special Instructions\").\n            CharLimit(400).\n            Value(&instructions),\n\n        huh.NewConfirm().\n            Title(\"Would you like 15% off?\").\n            Value(&discount),\n    ),\n)\n```\n\nFinally, run the form:\n\n```go\nerr := form.Run()\nif err != nil {\n    log.Fatal(err)\n}\n\nif !discount {\n    fmt.Println(\"What? You didn’t take the discount?!\")\n}\n```\n\nAnd that’s it! For more info see [the full source][burgersource] for this\nexample as well as [the docs][docs].\n\nIf you need more dynamic forms that change based on input from previous fields,\ncheck out the [dynamic forms](#dynamic-forms) example.\n\n[burgersource]: ./examples/burger/main.go\n[docs]: https://pkg.go.dev/github.com/charmbracelet/huh?tab=doc\n\n## Field Reference\n\n- [`Input`](#input): single line text input\n- [`Text`](#text): multi-line text input\n- [`Select`](#select): select an option from a list\n- [`MultiSelect`](#multiple-select): select multiple options from a list\n- [`Confirm`](#confirm): confirm an action (yes or no)\n\n> [!TIP]\n> Just want to prompt the user with a single field? Each field has a `Run`\n> method that can be used as a shorthand for gathering quick and easy input.\n\n```go\nvar name string\n\nhuh.NewInput().\n    Title(\"What’s your name?\").\n    Value(&name).\n    Run() // this is blocking...\n\nfmt.Printf(\"Hey, %s!\\n\", name)\n```\n\n### Input\n\nPrompt the user for a single line of text.\n\n<img alt=\"Input field\" width=\"600\" src=\"https://vhs.charm.sh/vhs-1ULe9JbTHfwFmm3hweRVtD.gif\">\n\n```go\nhuh.NewInput().\n    Title(\"What’s for lunch?\").\n    Prompt(\"?\").\n    Validate(isFood).\n    Value(&lunch)\n```\n\n### Text\n\nPrompt the user for multiple lines of text.\n\n<img alt=\"Text field\" width=\"600\" src=\"https://vhs.charm.sh/vhs-2rrIuVSEf38bT0cwc8hfEG.gif\">\n\n```go\nhuh.NewText().\n    Title(\"Tell me a story.\").\n    Validate(checkForPlagiarism).\n    Value(&story)\n```\n\n### Select\n\nPrompt the user to select a single option from a list.\n\n<img alt=\"Select field\" width=\"600\" src=\"https://vhs.charm.sh/vhs-7wFqZlxMWgbWmOIpBqXJTi.gif\">\n\n```go\nhuh.NewSelect[string]().\n    Title(\"Pick a country.\").\n    Options(\n        huh.NewOption(\"United States\", \"US\"),\n        huh.NewOption(\"Germany\", \"DE\"),\n        huh.NewOption(\"Brazil\", \"BR\"),\n        huh.NewOption(\"Canada\", \"CA\"),\n    ).\n    Value(&country)\n```\n\n### Multiple Select\n\nPrompt the user to select multiple (zero or more) options from a list.\n\n<img alt=\"Multiselect field\" width=\"600\" src=\"https://vhs.charm.sh/vhs-3TLImcoexOehRNLELysMpK.gif\">\n\n```go\nhuh.NewMultiSelect[string]().\n    Options(\n        huh.NewOption(\"Lettuce\", \"Lettuce\").Selected(true),\n        huh.NewOption(\"Tomatoes\", \"Tomatoes\").Selected(true),\n        huh.NewOption(\"Charm Sauce\", \"Charm Sauce\"),\n        huh.NewOption(\"Jalapeños\", \"Jalapeños\"),\n        huh.NewOption(\"Cheese\", \"Cheese\"),\n        huh.NewOption(\"Vegan Cheese\", \"Vegan Cheese\"),\n        huh.NewOption(\"Nutella\", \"Nutella\"),\n    ).\n    Title(\"Toppings\").\n    Limit(4).\n    Value(&toppings)\n```\n\n### Confirm\n\nPrompt the user to confirm (Yes or No).\n\n<img alt=\"Confirm field\" width=\"600\" src=\"https://vhs.charm.sh/vhs-2HeX5MdOxLsrWwsa0TNMIL.gif\">\n\n```go\nhuh.NewConfirm().\n    Title(\"Are you sure?\").\n    Affirmative(\"Yes!\").\n    Negative(\"No.\").\n    Value(&confirm)\n```\n\n## Accessibility\n\n`huh?` has a special rendering option designed specifically for screen readers.\nYou can enable it with `form.WithAccessible(true)`.\n\n> [!TIP]\n> We recommend setting this through an environment variable or configuration\n> option to allow the user to control accessibility.\n\n```go\naccessibleMode := os.Getenv(\"ACCESSIBLE\") != \"\"\nform.WithAccessible(accessibleMode)\n```\n\nAccessible forms will drop TUIs in favor of standard prompts, providing better\ndictation and feedback of the information on screen for the visually impaired.\n\n<img alt=\"Accessible cuisine form\" width=\"600\" src=\"https://vhs.charm.sh/vhs-19xEBn4LgzPZDtgzXRRJYS.gif\">\n\n## Themes\n\n`huh?` contains a powerful theme abstraction. Supply your own custom theme or\nchoose from one of the five predefined themes:\n\n- `Charm`\n- `Dracula`\n- `Catppuccin`\n- `Base 16`\n- `Default`\n\n<br />\n<p>\n    <img alt=\"Charm-themed form\" width=\"400\" src=\"https://stuff.charm.sh/huh/themes/charm-theme.png\">\n    <img alt=\"Dracula-themed form\" width=\"400\" src=\"https://stuff.charm.sh/huh/themes/dracula-theme.png\">\n    <img alt=\"Catppuccin-themed form\" width=\"400\" src=\"https://stuff.charm.sh/huh/themes/catppuccin-theme.png\">\n    <img alt=\"Base 16-themed form\" width=\"400\" src=\"https://stuff.charm.sh/huh/themes/basesixteen-theme.png\">\n    <img alt=\"Default-themed form\" width=\"400\" src=\"https://stuff.charm.sh/huh/themes/default-theme.png\">\n</p>\n\nThemes can take advantage of the full range of\n[Lip Gloss][lipgloss] style options. For a high level theme reference see\n[the docs](https://pkg.go.dev/github.com/charmbracelet/huh#Theme).\n\n[lipgloss]: https://github.com/charmbracelet/lipgloss\n\n## Dynamic Forms\n\n`huh?` forms can be as dynamic as your heart desires. Simply replace properties\nwith their equivalent `Func` to recompute the properties value every time a\ndifferent part of your form changes.\n\nHere’s how you would build a simple country + state / province picker.\n\nFirst, define some variables that we’ll use to store the user selection.\n\n```go\nvar country string\nvar state string\n```\n\nDefine your country select as you normally would:\n\n```go\nhuh.NewSelect[string]().\n    Options(huh.NewOptions(\"United States\", \"Canada\", \"Mexico\")...).\n    Value(&country).\n    Title(\"Country\").\n```\n\nDefine your state select with `TitleFunc` and `OptionsFunc` instead of `Title`\nand `Options`. This will allow you to change the title and options based on the\nselection of the previous field, i.e. `country`.\n\nTo do this, we provide a `func() string` and a `binding any` to `TitleFunc`. The\nfunction defines what to show for the title and the binding specifies what value\nneeds to change for the function to recompute. So if `country` changes (e.g. the\nuser changes the selection) we will recompute the function.\n\nFor `OptionsFunc`, we provide a `func() []Option[string]` and a `binding any`.\nWe’ll fetch the country’s states, provinces, or territories from an API. `huh`\nwill automatically handle caching for you.\n\n> [!IMPORTANT]\n> We have to pass `&country` as the binding to recompute the function only when\n> `country` changes, otherwise we will hit the API too often.\n\n```go\nhuh.NewSelect[string]().\n    Value(&state).\n    Height(8).\n    TitleFunc(func() string {\n        switch country {\n        case \"United States\":\n            return \"State\"\n        case \"Canada\":\n            return \"Province\"\n        default:\n            return \"Territory\"\n        }\n    }, &country).\n    OptionsFunc(func() []huh.Option[string] {\n        opts := fetchStatesForCountry(country)\n        return huh.NewOptions(opts...)\n    }, &country),\n```\n\nLastly, run the `form` with these inputs.\n\n```go\nerr := form.Run()\nif err != nil {\n    log.Fatal(err)\n}\n```\n\n<img width=\"600\" src=\"https://vhs.charm.sh/vhs-6FRmBjNi2aiRb4INPXwIjo.gif\" alt=\"Country / State form with dynamic inputs running.\">\n\n## Bonus: Spinner\n\n`huh?` ships with a standalone spinner package. It’s useful for indicating\nbackground activity after a form is submitted.\n\n<img alt=\"Spinner while making a burger\" width=\"600\" src=\"https://vhs.charm.sh/vhs-6HvYomAFP6H8mngOYWXvwJ.gif\">\n\nCreate a new spinner, set a title, set the action (or provide a `Context`), and run the spinner:\n\n<table>\n\n<tr>\n<td> <strong>Action Style</strong> </td><td> <strong>Context Style</strong> </td></tr>\n<tr>\n<td>\n\n```go\nerr := spinner.New().\n    Title(\"Making your burger...\").\n    Action(makeBurger).\n    Run()\n\nfmt.Println(\"Order up!\")\n```\n\n</td>\n<td>\n\n```go\ngo makeBurger()\n\nerr := spinner.New().\n    Type(spinner.Line).\n    Title(\"Making your burger...\").\n    Context(ctx).\n    Run()\n\nfmt.Println(\"Order up!\")\n```\n\n</td>\n</tr>\n</table>\n\nFor more on Spinners see the [spinner examples](./spinner/examples) and\n[the spinner docs](https://pkg.go.dev/github.com/charmbracelet/huh/spinner).\n\n## What about Bubble Tea?\n\n<img alt=\"Bubbletea + Huh?\" width=\"174\" src=\"https://stuff.charm.sh/huh/bubbletea-huh.png\">\n\nIn addition to its standalone mode, `huh?` has first-class support for\n[Bubble Tea][tea] and can be easily integrated into Bubble Tea applications.\nIt’s incredibly useful in portions of your Bubble Tea application that need\nform-like input.\n\n<img alt=\"Bubble Tea embedded form example\" width=\"800\" src=\"https://vhs.charm.sh/vhs-3wGaB7EUKWmojeaHpARMUv.gif\">\n\nA `huh.Form` is merely a `tea.Model`, so you can use it just as\nyou would any other [Bubble](https://github.com/charmbracelet/bubbles).\n\n```go\ntype Model struct {\n    form *huh.Form // huh.Form is just a tea.Model\n}\n\nfunc NewModel() Model {\n    return Model{\n        form: huh.NewForm(\n            huh.NewGroup(\n                huh.NewSelect[string]().\n                    Key(\"class\").\n                    Options(huh.NewOptions(\"Warrior\", \"Mage\", \"Rogue\")...).\n                    Title(\"Choose your class\"),\n\n            huh.NewSelect[int]().\n                Key(\"level\").\n                Options(huh.NewOptions(1, 20, 9999)...).\n                Title(\"Choose your level\"),\n            ),\n        )\n    }\n}\n\nfunc (m Model) Init() tea.Cmd {\n    return m.form.Init()\n}\n\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n    // ...\n\n    form, cmd := m.form.Update(msg)\n    if f, ok := form.(*huh.Form); ok {\n        m.form = f\n    }\n\n    return m, cmd\n}\n\nfunc (m Model) View() string {\n    if m.form.State == huh.StateCompleted {\n        class := m.form.GetString(\"class\")\n        level := m.form.GetString(\"level\")\n        return fmt.Sprintf(\"You selected: %s, Lvl. %d\", class, level)\n    }\n    return m.form.View()\n}\n\n```\n\nFor more info in using `huh?` in Bubble Tea applications see [the full Bubble\nTea example][example].\n\n[tea]: https://github.com/charmbracelet/bubbletea\n[bubbles]: https://github.com/charmbracelet/bubbles\n[example]: https://github.com/charmbracelet/huh/blob/main/examples/bubbletea/main.go\n\n## `Huh?` in the Wild\nFor some `Huh?` programs in production, see:\n\n* [glyphs](https://github.com/maaslalani/glyphs): a unicode symbol picker\n* [meteor](https://github.com/stefanlogue/meteor): a highly customisable conventional commit message tool\n* [freeze](https://github.com/charmbracelet/freeze): a tool for generating images of code and terminal output\n* [gum](https://github.com/charmbracelet/gum): a tool for glamorous shell scripts\n* [savvy](https://github.com/getsavvyinc/savvy-cli): the easiest way to create, share, and run runbooks in the terminal\n\n\n## Feedback\n\nWe’d love to hear your thoughts on this project. Feel free to drop us a note!\n\n- [Twitter](https://twitter.com/charmcli)\n- [The Fediverse](https://mastodon.social/@charmcli)\n- [Discord](https://charm.sh/chat)\n\n## Acknowledgments\n\n`huh?` is inspired by the wonderful [Survey][survey] library by Alec Aivazis.\n\n[survey]: https://github.com/AlecAivazis/survey\n\n## License\n\n[MIT](https://github.com/charmbracelet/bubbletea/raw/master/LICENSE)\n\n---\n\nPart of [Charm](https://charm.sh).\n\n<a href=\"https://charm.sh/\"><img alt=\"The Charm logo\" src=\"https://stuff.charm.sh/charm-badge.jpg\" width=\"400\"></a>\n\nCharm热爱开源 • Charm loves open source • نحنُ نحب المصادر المفتوحة\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.1416015625,
          "content": "# Security Policy\n\n## Reporting a Vulnerability\n\nPlease email [vt100@charm.sh](mailto:vt100@charm.sh) for any possible security vulnerabilities.\n"
        },
        {
          "name": "accessibility",
          "type": "tree",
          "content": null
        },
        {
          "name": "accessor.go",
          "type": "blob",
          "size": 0.8642578125,
          "content": "package huh\n\n// Accessor give read/write access to field values.\ntype Accessor[T any] interface {\n\tGet() T\n\tSet(value T)\n}\n\n// EmbeddedAccessor is a basic accessor, acting as the default one for fields.\ntype EmbeddedAccessor[T any] struct {\n\tvalue T\n}\n\n// Get gets the value.\nfunc (a *EmbeddedAccessor[T]) Get() T {\n\treturn a.value\n}\n\n// Set sets the value.\nfunc (a *EmbeddedAccessor[T]) Set(value T) {\n\ta.value = value\n}\n\n// PointerAccessor allows field value to be exposed as a pointed variable.\ntype PointerAccessor[T any] struct {\n\tvalue *T\n}\n\n// NewPointerAccessor returns a new pointer accessor.\nfunc NewPointerAccessor[T any](value *T) *PointerAccessor[T] {\n\treturn &PointerAccessor[T]{\n\t\tvalue: value,\n\t}\n}\n\n// Get gets the value.\nfunc (a *PointerAccessor[T]) Get() T {\n\treturn *a.value\n}\n\n// Set sets the value.\nfunc (a *PointerAccessor[T]) Set(value T) {\n\t*a.value = value\n}\n"
        },
        {
          "name": "clamp.go",
          "type": "blob",
          "size": 0.1220703125,
          "content": "package huh\n\nfunc clamp(n, low, high int) int {\n\tif low > high {\n\t\tlow, high = high, low\n\t}\n\treturn min(high, max(low, n))\n}\n"
        },
        {
          "name": "eval.go",
          "type": "blob",
          "size": 1.4248046875,
          "content": "package huh\n\nimport (\n\t\"time\"\n\n\t\"github.com/mitchellh/hashstructure/v2\"\n)\n\n// Eval is an evaluatable value, it stores a cached value and a function to\n// recompute it. It's bindings are what we check to see if we need to recompute\n// the value.\n//\n// By default it is also cached.\ntype Eval[T any] struct {\n\tval T\n\tfn  func() T\n\n\tbindings     any\n\tbindingsHash uint64\n\tcache        map[uint64]T\n\n\tloading      bool\n\tloadingStart time.Time\n}\n\nconst spinnerShowThreshold = 25 * time.Millisecond\n\nfunc hash(val any) uint64 {\n\thash, _ := hashstructure.Hash(val, hashstructure.FormatV2, nil)\n\treturn hash\n}\n\nfunc (e *Eval[T]) shouldUpdate() (bool, uint64) {\n\tif e.fn == nil {\n\t\treturn false, 0\n\t}\n\tnewHash := hash(e.bindings)\n\treturn e.bindingsHash != newHash, newHash\n}\n\nfunc (e *Eval[T]) loadFromCache() bool {\n\tval, ok := e.cache[e.bindingsHash]\n\tif ok {\n\t\te.loading = false\n\t\te.val = val\n\t}\n\treturn ok\n}\n\nfunc (e *Eval[T]) update(val T) {\n\te.val = val\n\te.cache[e.bindingsHash] = val\n\te.loading = false\n}\n\ntype updateTitleMsg struct {\n\tid    int\n\thash  uint64\n\ttitle string\n}\n\ntype updateDescriptionMsg struct {\n\tid          int\n\thash        uint64\n\tdescription string\n}\n\ntype updatePlaceholderMsg struct {\n\tid          int\n\thash        uint64\n\tplaceholder string\n}\n\ntype updateSuggestionsMsg struct {\n\tid          int\n\thash        uint64\n\tsuggestions []string\n}\n\ntype updateOptionsMsg[T comparable] struct {\n\tid      int\n\thash    uint64\n\toptions []Option[T]\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "field_confirm.go",
          "type": "blob",
          "size": 8.7578125,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/accessibility\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// Confirm is a form confirm field.\ntype Confirm struct {\n\taccessor Accessor[bool]\n\tkey      string\n\tid       int\n\n\t// customization\n\ttitle       Eval[string]\n\tdescription Eval[string]\n\taffirmative string\n\tnegative    string\n\n\t// error handling\n\tvalidate func(bool) error\n\terr      error\n\n\t// state\n\tfocused bool\n\n\t// options\n\twidth           int\n\theight          int\n\tinline          bool\n\taccessible      bool\n\ttheme           *Theme\n\tkeymap          ConfirmKeyMap\n\tbuttonAlignment lipgloss.Position\n}\n\n// NewConfirm returns a new confirm field.\nfunc NewConfirm() *Confirm {\n\treturn &Confirm{\n\t\taccessor:        &EmbeddedAccessor[bool]{},\n\t\tid:              nextID(),\n\t\ttitle:           Eval[string]{cache: make(map[uint64]string)},\n\t\tdescription:     Eval[string]{cache: make(map[uint64]string)},\n\t\taffirmative:     \"Yes\",\n\t\tnegative:        \"No\",\n\t\tvalidate:        func(bool) error { return nil },\n\t\tbuttonAlignment: lipgloss.Center,\n\t}\n}\n\n// Validate sets the validation function of the confirm field.\nfunc (c *Confirm) Validate(validate func(bool) error) *Confirm {\n\tc.validate = validate\n\treturn c\n}\n\n// Error returns the error of the confirm field.\nfunc (c *Confirm) Error() error {\n\treturn c.err\n}\n\n// Skip returns whether the confirm should be skipped or should be blocking.\nfunc (*Confirm) Skip() bool {\n\treturn false\n}\n\n// Zoom returns whether the input should be zoomed.\nfunc (*Confirm) Zoom() bool {\n\treturn false\n}\n\n// Affirmative sets the affirmative value of the confirm field.\nfunc (c *Confirm) Affirmative(affirmative string) *Confirm {\n\tc.affirmative = affirmative\n\treturn c\n}\n\n// Negative sets the negative value of the confirm field.\nfunc (c *Confirm) Negative(negative string) *Confirm {\n\tc.negative = negative\n\treturn c\n}\n\n// Value sets the value of the confirm field.\nfunc (c *Confirm) Value(value *bool) *Confirm {\n\treturn c.Accessor(NewPointerAccessor(value))\n}\n\n// Accessor sets the accessor of the confirm field.\nfunc (c *Confirm) Accessor(accessor Accessor[bool]) *Confirm {\n\tc.accessor = accessor\n\treturn c\n}\n\n// Key sets the key of the confirm field.\nfunc (c *Confirm) Key(key string) *Confirm {\n\tc.key = key\n\treturn c\n}\n\n// Title sets the title of the confirm field.\nfunc (c *Confirm) Title(title string) *Confirm {\n\tc.title.val = title\n\tc.title.fn = nil\n\treturn c\n}\n\n// TitleFunc sets the title func of the confirm field.\nfunc (c *Confirm) TitleFunc(f func() string, bindings any) *Confirm {\n\tc.title.fn = f\n\tc.title.bindings = bindings\n\treturn c\n}\n\n// Description sets the description of the confirm field.\nfunc (c *Confirm) Description(description string) *Confirm {\n\tc.description.val = description\n\tc.description.fn = nil\n\treturn c\n}\n\n// DescriptionFunc sets the description function of the confirm field.\nfunc (c *Confirm) DescriptionFunc(f func() string, bindings any) *Confirm {\n\tc.description.fn = f\n\tc.description.bindings = bindings\n\treturn c\n}\n\n// Inline sets whether the field should be inline.\nfunc (c *Confirm) Inline(inline bool) *Confirm {\n\tc.inline = inline\n\treturn c\n}\n\n// Focus focuses the confirm field.\nfunc (c *Confirm) Focus() tea.Cmd {\n\tc.focused = true\n\treturn nil\n}\n\n// Blur blurs the confirm field.\nfunc (c *Confirm) Blur() tea.Cmd {\n\tc.focused = false\n\tc.err = c.validate(c.accessor.Get())\n\treturn nil\n}\n\n// KeyBinds returns the help message for the confirm field.\nfunc (c *Confirm) KeyBinds() []key.Binding {\n\treturn []key.Binding{c.keymap.Toggle, c.keymap.Prev, c.keymap.Submit, c.keymap.Next, c.keymap.Accept, c.keymap.Reject}\n}\n\n// Init initializes the confirm field.\nfunc (c *Confirm) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update updates the confirm field.\nfunc (c *Confirm) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase updateFieldMsg:\n\t\tif ok, hash := c.title.shouldUpdate(); ok {\n\t\t\tc.title.bindingsHash = hash\n\t\t\tif !c.title.loadFromCache() {\n\t\t\t\tc.title.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateTitleMsg{id: c.id, title: c.title.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := c.description.shouldUpdate(); ok {\n\t\t\tc.description.bindingsHash = hash\n\t\t\tif !c.description.loadFromCache() {\n\t\t\t\tc.description.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateDescriptionMsg{id: c.id, description: c.description.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\tcase updateTitleMsg:\n\t\tif msg.id == c.id && msg.hash == c.title.bindingsHash {\n\t\t\tc.title.val = msg.title\n\t\t\tc.title.loading = false\n\t\t}\n\tcase updateDescriptionMsg:\n\t\tif msg.id == c.id && msg.hash == c.description.bindingsHash {\n\t\t\tc.description.val = msg.description\n\t\t\tc.description.loading = false\n\t\t}\n\tcase tea.KeyMsg:\n\t\tc.err = nil\n\t\tswitch {\n\t\tcase key.Matches(msg, c.keymap.Toggle):\n\t\t\tif c.negative == \"\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tc.accessor.Set(!c.accessor.Get())\n\t\tcase key.Matches(msg, c.keymap.Prev):\n\t\t\tcmds = append(cmds, PrevField)\n\t\tcase key.Matches(msg, c.keymap.Next, c.keymap.Submit):\n\t\t\tcmds = append(cmds, NextField)\n\t\tcase key.Matches(msg, c.keymap.Accept):\n\t\t\tc.accessor.Set(true)\n\t\t\tcmds = append(cmds, NextField)\n\t\tcase key.Matches(msg, c.keymap.Reject):\n\t\t\tc.accessor.Set(false)\n\t\t\tcmds = append(cmds, NextField)\n\t\t}\n\t}\n\n\treturn c, tea.Batch(cmds...)\n}\n\nfunc (c *Confirm) activeStyles() *FieldStyles {\n\ttheme := c.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif c.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\n// View renders the confirm field.\nfunc (c *Confirm) View() string {\n\tstyles := c.activeStyles()\n\n\tvar sb strings.Builder\n\tsb.WriteString(styles.Title.Render(c.title.val))\n\tif c.err != nil {\n\t\tsb.WriteString(styles.ErrorIndicator.String())\n\t}\n\n\tdescription := styles.Description.Render(c.description.val)\n\n\tif !c.inline && (c.description.val != \"\" || c.description.fn != nil) {\n\t\tsb.WriteString(\"\\n\")\n\t}\n\tsb.WriteString(description)\n\n\tif !c.inline {\n\t\tsb.WriteString(\"\\n\")\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\tvar negative string\n\tvar affirmative string\n\tif c.negative != \"\" {\n\t\tif c.accessor.Get() {\n\t\t\taffirmative = styles.FocusedButton.Render(c.affirmative)\n\t\t\tnegative = styles.BlurredButton.Render(c.negative)\n\t\t} else {\n\t\t\taffirmative = styles.BlurredButton.Render(c.affirmative)\n\t\t\tnegative = styles.FocusedButton.Render(c.negative)\n\t\t}\n\t\tc.keymap.Reject.SetHelp(\"n\", c.negative)\n\t} else {\n\t\taffirmative = styles.FocusedButton.Render(c.affirmative)\n\t\tc.keymap.Reject.SetEnabled(false)\n\t}\n\n\tc.keymap.Accept.SetHelp(\"y\", c.affirmative)\n\n\tbuttonsRow := lipgloss.JoinHorizontal(c.buttonAlignment, affirmative, negative)\n\n\tpromptWidth := lipgloss.Width(sb.String())\n\tbuttonsWidth := lipgloss.Width(buttonsRow)\n\n\trenderWidth := promptWidth\n\tif buttonsWidth > renderWidth {\n\t\trenderWidth = buttonsWidth\n\t}\n\n\tstyle := lipgloss.NewStyle().Width(renderWidth).Align(c.buttonAlignment)\n\n\tsb.WriteString(style.Render(buttonsRow))\n\treturn styles.Base.Render(sb.String())\n}\n\n// Run runs the confirm field in accessible mode.\nfunc (c *Confirm) Run() error {\n\tif c.accessible {\n\t\treturn c.runAccessible()\n\t}\n\treturn Run(c)\n}\n\n// runAccessible runs the confirm field in accessible mode.\nfunc (c *Confirm) runAccessible() error {\n\tstyles := c.activeStyles()\n\tfmt.Println(styles.Title.Render(c.title.val))\n\tfmt.Println()\n\tc.accessor.Set(accessibility.PromptBool())\n\tfmt.Println(styles.SelectedOption.Render(\"Chose: \"+c.String()) + \"\\n\")\n\treturn nil\n}\n\nfunc (c *Confirm) String() string {\n\tif c.accessor.Get() {\n\t\treturn c.affirmative\n\t}\n\treturn c.negative\n}\n\n// WithTheme sets the theme of the confirm field.\nfunc (c *Confirm) WithTheme(theme *Theme) Field {\n\tif c.theme != nil {\n\t\treturn c\n\t}\n\tc.theme = theme\n\treturn c\n}\n\n// WithKeyMap sets the keymap of the confirm field.\nfunc (c *Confirm) WithKeyMap(k *KeyMap) Field {\n\tc.keymap = k.Confirm\n\treturn c\n}\n\n// WithAccessible sets the accessible mode of the confirm field.\nfunc (c *Confirm) WithAccessible(accessible bool) Field {\n\tc.accessible = accessible\n\treturn c\n}\n\n// WithWidth sets the width of the confirm field.\nfunc (c *Confirm) WithWidth(width int) Field {\n\tc.width = width\n\treturn c\n}\n\n// WithHeight sets the height of the confirm field.\nfunc (c *Confirm) WithHeight(height int) Field {\n\tc.height = height\n\treturn c\n}\n\n// WithPosition sets the position of the confirm field.\nfunc (c *Confirm) WithPosition(p FieldPosition) Field {\n\tc.keymap.Prev.SetEnabled(!p.IsFirst())\n\tc.keymap.Next.SetEnabled(!p.IsLast())\n\tc.keymap.Submit.SetEnabled(p.IsLast())\n\treturn c\n}\n\n// WithButtonAlignment sets the button position of the confirm field.\nfunc (c *Confirm) WithButtonAlignment(p lipgloss.Position) *Confirm {\n\tc.buttonAlignment = p\n\treturn c\n}\n\n// GetKey returns the key of the field.\nfunc (c *Confirm) GetKey() string {\n\treturn c.key\n}\n\n// GetValue returns the value of the field.\nfunc (c *Confirm) GetValue() any {\n\treturn c.accessor.Get()\n}\n"
        },
        {
          "name": "field_filepicker.go",
          "type": "blob",
          "size": 10.01953125,
          "content": "package huh\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\txstrings \"github.com/charmbracelet/x/exp/strings\"\n\n\t\"github.com/charmbracelet/bubbles/filepicker\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/accessibility\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// FilePicker is a form file file field.\ntype FilePicker struct {\n\taccessor Accessor[string]\n\tkey      string\n\tpicker   filepicker.Model\n\n\t// state\n\tfocused bool\n\tpicking bool\n\n\t// customization\n\ttitle       string\n\tdescription string\n\n\t// error handling\n\tvalidate func(string) error\n\terr      error\n\n\t// options\n\twidth      int\n\theight     int\n\taccessible bool\n\ttheme      *Theme\n\tkeymap     FilePickerKeyMap\n}\n\n// NewFilePicker returns a new file field.\nfunc NewFilePicker() *FilePicker {\n\tfp := filepicker.New()\n\tfp.ShowSize = false\n\n\tif cmd := fp.Init(); cmd != nil {\n\t\tfp, _ = fp.Update(cmd())\n\t}\n\n\treturn &FilePicker{\n\t\taccessor: &EmbeddedAccessor[string]{},\n\t\tvalidate: func(string) error { return nil },\n\t\tpicker:   fp,\n\t}\n}\n\n// CurrentDirectory sets the directory of the file field.\nfunc (f *FilePicker) CurrentDirectory(directory string) *FilePicker {\n\tf.picker.CurrentDirectory = directory\n\tif cmd := f.picker.Init(); cmd != nil {\n\t\tf.picker, _ = f.picker.Update(cmd())\n\t}\n\treturn f\n}\n\n// Cursor sets the cursor of the file field.\nfunc (f *FilePicker) Cursor(cursor string) *FilePicker {\n\tf.picker.Cursor = cursor\n\treturn f\n}\n\n// Picking sets whether the file picker should be in the picking files state.\nfunc (f *FilePicker) Picking(v bool) *FilePicker {\n\tf.setPicking(v)\n\treturn f\n}\n\n// ShowHidden sets whether to show hidden files.\nfunc (f *FilePicker) ShowHidden(v bool) *FilePicker {\n\tf.picker.ShowHidden = v\n\treturn f\n}\n\n// ShowSize sets whether to show file sizes.\nfunc (f *FilePicker) ShowSize(v bool) *FilePicker {\n\tf.picker.ShowSize = v\n\treturn f\n}\n\n// ShowPermissions sets whether to show file permissions.\nfunc (f *FilePicker) ShowPermissions(v bool) *FilePicker {\n\tf.picker.ShowPermissions = v\n\treturn f\n}\n\n// FileAllowed sets whether to allow files to be selected.\nfunc (f *FilePicker) FileAllowed(v bool) *FilePicker {\n\tf.picker.FileAllowed = v\n\treturn f\n}\n\n// DirAllowed sets whether to allow files to be selected.\nfunc (f *FilePicker) DirAllowed(v bool) *FilePicker {\n\tf.picker.DirAllowed = v\n\treturn f\n}\n\n// Value sets the value of the file field.\nfunc (f *FilePicker) Value(value *string) *FilePicker {\n\treturn f.Accessor(NewPointerAccessor(value))\n}\n\n// Accessor sets the accessor of the file field.\nfunc (f *FilePicker) Accessor(accessor Accessor[string]) *FilePicker {\n\tf.accessor = accessor\n\treturn f\n}\n\n// Key sets the key of the file field which can be used to retrieve the value\n// after submission.\nfunc (f *FilePicker) Key(key string) *FilePicker {\n\tf.key = key\n\treturn f\n}\n\n// Title sets the title of the file field.\nfunc (f *FilePicker) Title(title string) *FilePicker {\n\tf.title = title\n\treturn f\n}\n\n// Description sets the description of the file field.\nfunc (f *FilePicker) Description(description string) *FilePicker {\n\tf.description = description\n\treturn f\n}\n\n// AllowedTypes sets the allowed types of the file field. These will be the only\n// valid file types accepted, other files will show as disabled.\nfunc (f *FilePicker) AllowedTypes(types []string) *FilePicker {\n\tf.picker.AllowedTypes = types\n\treturn f\n}\n\n// Height sets the height of the file field. If the number of options\n// exceeds the height, the file field will become scrollable.\nfunc (f *FilePicker) Height(height int) *FilePicker {\n\tadjust := 0\n\tif f.title != \"\" {\n\t\tadjust++\n\t}\n\tif f.description != \"\" {\n\t\tadjust++\n\t}\n\tf.picker.Height = height - adjust\n\treturn f\n}\n\n// Validate sets the validation function of the file field.\nfunc (f *FilePicker) Validate(validate func(string) error) *FilePicker {\n\tf.validate = validate\n\treturn f\n}\n\n// Error returns the error of the file field.\nfunc (f *FilePicker) Error() error {\n\treturn f.err\n}\n\n// Skip returns whether the file should be skipped or should be blocking.\nfunc (*FilePicker) Skip() bool {\n\treturn false\n}\n\n// Zoom returns whether the input should be zoomed.\nfunc (f *FilePicker) Zoom() bool {\n\treturn f.picking\n}\n\n// Focus focuses the file field.\nfunc (f *FilePicker) Focus() tea.Cmd {\n\tf.focused = true\n\treturn f.picker.Init()\n}\n\n// Blur blurs the file field.\nfunc (f *FilePicker) Blur() tea.Cmd {\n\tf.focused = false\n\tf.setPicking(false)\n\tf.err = f.validate(f.accessor.Get())\n\treturn nil\n}\n\n// KeyBinds returns the help keybindings for the file field.\nfunc (f *FilePicker) KeyBinds() []key.Binding {\n\treturn []key.Binding{f.keymap.Up, f.keymap.Down, f.keymap.Close, f.keymap.Open, f.keymap.Prev, f.keymap.Next, f.keymap.Submit}\n}\n\n// Init initializes the file field.\nfunc (f *FilePicker) Init() tea.Cmd {\n\treturn f.picker.Init()\n}\n\n// Update updates the file field.\nfunc (f *FilePicker) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tf.err = nil\n\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\tswitch {\n\t\tcase key.Matches(msg, f.keymap.Open):\n\t\t\tif f.picking {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tf.setPicking(true)\n\t\t\treturn f, f.picker.Init()\n\t\tcase key.Matches(msg, f.keymap.Close):\n\t\t\tf.setPicking(false)\n\t\t\treturn f, NextField\n\t\tcase key.Matches(msg, f.keymap.Next):\n\t\t\tf.setPicking(false)\n\t\t\treturn f, NextField\n\t\tcase key.Matches(msg, f.keymap.Prev):\n\t\t\tf.setPicking(false)\n\t\t\treturn f, PrevField\n\t\t}\n\t}\n\n\tvar cmd tea.Cmd\n\tf.picker, cmd = f.picker.Update(msg)\n\tdidSelect, file := f.picker.DidSelectFile(msg)\n\tif didSelect {\n\t\tf.accessor.Set(file)\n\t\tf.setPicking(false)\n\t\treturn f, NextField\n\t}\n\tdidSelect, _ = f.picker.DidSelectDisabledFile(msg)\n\tif didSelect {\n\t\tf.err = errors.New(xstrings.EnglishJoin(f.picker.AllowedTypes, true) + \" files only\")\n\t\treturn f, nil\n\t}\n\n\treturn f, cmd\n}\n\nfunc (f *FilePicker) activeStyles() *FieldStyles {\n\ttheme := f.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif f.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\n// View renders the file field.\nfunc (f *FilePicker) View() string {\n\tstyles := f.activeStyles()\n\n\tvar sb strings.Builder\n\tif f.title != \"\" {\n\t\tsb.WriteString(styles.Title.Render(f.title) + \"\\n\")\n\t}\n\tif f.description != \"\" {\n\t\tsb.WriteString(styles.Description.Render(f.description) + \"\\n\")\n\t}\n\tif f.picking {\n\t\tsb.WriteString(strings.TrimSuffix(f.picker.View(), \"\\n\"))\n\t} else {\n\t\tif f.accessor.Get() != \"\" {\n\t\t\tsb.WriteString(styles.SelectedOption.Render(f.accessor.Get()))\n\t\t} else {\n\t\t\tsb.WriteString(styles.TextInput.Placeholder.Render(\"No file selected.\"))\n\t\t}\n\t}\n\treturn styles.Base.Render(sb.String())\n}\n\nfunc (f *FilePicker) setPicking(v bool) {\n\tf.picking = v\n\n\tf.keymap.Close.SetEnabled(v)\n\tf.keymap.Up.SetEnabled(v)\n\tf.keymap.Down.SetEnabled(v)\n\tf.keymap.Select.SetEnabled(v)\n\tf.keymap.Back.SetEnabled(v)\n\n\tf.picker.KeyMap.Up.SetEnabled(v)\n\tf.picker.KeyMap.Down.SetEnabled(v)\n\tf.picker.KeyMap.Select.SetEnabled(v)\n\tf.picker.KeyMap.Open.SetEnabled(v)\n\tf.picker.KeyMap.Back.SetEnabled(v)\n}\n\n// Run runs the file field.\nfunc (f *FilePicker) Run() error {\n\tif f.accessible {\n\t\treturn f.runAccessible()\n\t}\n\treturn Run(f)\n}\n\n// runAccessible runs an accessible file field.\nfunc (f *FilePicker) runAccessible() error {\n\tstyles := f.activeStyles()\n\tfmt.Println(styles.Title.Render(f.title))\n\tfmt.Println()\n\n\tvalidateFile := func(s string) error {\n\t\t// is the string a file?\n\t\tif _, err := os.Open(s); err != nil {\n\t\t\treturn errors.New(\"not a file\")\n\t\t}\n\n\t\t// is it one of the allowed types?\n\t\tvalid := false\n\t\tfor _, ext := range f.picker.AllowedTypes {\n\t\t\tif strings.HasSuffix(s, ext) {\n\t\t\t\tvalid = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !valid {\n\t\t\treturn errors.New(\"cannot select: \" + s)\n\t\t}\n\n\t\t// does it pass user validation?\n\t\treturn f.validate(s)\n\t}\n\n\tf.accessor.Set(accessibility.PromptString(\"File: \", validateFile))\n\tfmt.Println(styles.SelectedOption.Render(f.accessor.Get() + \"\\n\"))\n\treturn nil\n}\n\n// copied from bubbles' filepicker\nconst (\n\tfileSizeWidth = 7\n\tpaddingLeft   = 2\n)\n\n// WithTheme sets the theme of the file field.\nfunc (f *FilePicker) WithTheme(theme *Theme) Field {\n\tif f.theme != nil || theme == nil {\n\t\treturn f\n\t}\n\tf.theme = theme\n\n\t// XXX: add specific themes\n\tf.picker.Styles = filepicker.Styles{\n\t\tDisabledCursor:   lipgloss.Style{},\n\t\tCursor:           theme.Focused.TextInput.Prompt,\n\t\tSymlink:          lipgloss.NewStyle(),\n\t\tDirectory:        theme.Focused.Directory,\n\t\tFile:             theme.Focused.File,\n\t\tDisabledFile:     theme.Focused.TextInput.Placeholder,\n\t\tPermission:       theme.Focused.TextInput.Placeholder,\n\t\tSelected:         theme.Focused.SelectedOption,\n\t\tDisabledSelected: theme.Focused.TextInput.Placeholder,\n\t\tFileSize:         theme.Focused.TextInput.Placeholder.Width(fileSizeWidth).Align(lipgloss.Right),\n\t\tEmptyDirectory:   theme.Focused.TextInput.Placeholder.PaddingLeft(paddingLeft).SetString(\"No files found.\"),\n\t}\n\n\treturn f\n}\n\n// WithKeyMap sets the keymap on a file field.\nfunc (f *FilePicker) WithKeyMap(k *KeyMap) Field {\n\tf.keymap = k.FilePicker\n\tf.picker.KeyMap = filepicker.KeyMap{\n\t\tGoToTop:  k.FilePicker.GoToTop,\n\t\tGoToLast: k.FilePicker.GoToLast,\n\t\tDown:     k.FilePicker.Down,\n\t\tUp:       k.FilePicker.Up,\n\t\tPageUp:   k.FilePicker.PageUp,\n\t\tPageDown: k.FilePicker.PageDown,\n\t\tBack:     k.FilePicker.Back,\n\t\tOpen:     k.FilePicker.Open,\n\t\tSelect:   k.FilePicker.Select,\n\t}\n\tf.setPicking(f.picking)\n\treturn f\n}\n\n// WithAccessible sets the accessible mode of the file field.\nfunc (f *FilePicker) WithAccessible(accessible bool) Field {\n\tf.accessible = accessible\n\treturn f\n}\n\n// WithWidth sets the width of the file field.\nfunc (f *FilePicker) WithWidth(width int) Field {\n\tf.width = width\n\treturn f\n}\n\n// WithHeight sets the height of the file field.\nfunc (f *FilePicker) WithHeight(height int) Field {\n\tf.height = height\n\tf.Height(height)\n\tf.picker, _ = f.picker.Update(nil)\n\treturn f\n}\n\n// WithPosition sets the position of the file field.\nfunc (f *FilePicker) WithPosition(p FieldPosition) Field {\n\tf.keymap.Prev.SetEnabled(!p.IsFirst())\n\tf.keymap.Next.SetEnabled(!p.IsLast())\n\tf.keymap.Submit.SetEnabled(p.IsLast())\n\treturn f\n}\n\n// GetKey returns the key of the field.\nfunc (f *FilePicker) GetKey() string {\n\treturn f.key\n}\n\n// GetValue returns the value of the field.\nfunc (f *FilePicker) GetValue() any {\n\treturn f.accessor.Get()\n}\n"
        },
        {
          "name": "field_input.go",
          "type": "blob",
          "size": 13.529296875,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/textinput\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/accessibility\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// Input is a input field.\n//\n// The input field is a field that allows the user to enter text. Use it to user\n// input. It can be used for collecting text, passwords, or other short input.\n//\n// The input field supports Suggestions, Placeholder, and Validation.\ntype Input struct {\n\taccessor Accessor[string]\n\tkey      string\n\tid       int\n\n\ttitle       Eval[string]\n\tdescription Eval[string]\n\tplaceholder Eval[string]\n\tsuggestions Eval[[]string]\n\n\ttextinput textinput.Model\n\n\tinline   bool\n\tvalidate func(string) error\n\terr      error\n\tfocused  bool\n\n\taccessible bool\n\twidth      int\n\theight     int // not really used anywhere\n\n\ttheme  *Theme\n\tkeymap InputKeyMap\n}\n\n// NewInput creates a new input field.\n//\n// The input field is a field that allows the user to enter text. Use it to user\n// input. It can be used for collecting text, passwords, or other short input.\n//\n// The input field supports Suggestions, Placeholder, and Validation.\nfunc NewInput() *Input {\n\tinput := textinput.New()\n\n\ti := &Input{\n\t\taccessor:    &EmbeddedAccessor[string]{},\n\t\ttextinput:   input,\n\t\tvalidate:    func(string) error { return nil },\n\t\tid:          nextID(),\n\t\ttitle:       Eval[string]{cache: make(map[uint64]string)},\n\t\tdescription: Eval[string]{cache: make(map[uint64]string)},\n\t\tplaceholder: Eval[string]{cache: make(map[uint64]string)},\n\t\tsuggestions: Eval[[]string]{cache: make(map[uint64][]string)},\n\t}\n\n\treturn i\n}\n\n// Value sets the value of the input field.\nfunc (i *Input) Value(value *string) *Input {\n\treturn i.Accessor(NewPointerAccessor(value))\n}\n\n// Accessor sets the accessor of the input field.\nfunc (i *Input) Accessor(accessor Accessor[string]) *Input {\n\ti.accessor = accessor\n\ti.textinput.SetValue(i.accessor.Get())\n\treturn i\n}\n\n// Key sets the key of the input field.\nfunc (i *Input) Key(key string) *Input {\n\ti.key = key\n\treturn i\n}\n\n// Title sets the title of the input field.\n//\n// The Title is static for dynamic Title use `TitleFunc`.\nfunc (i *Input) Title(title string) *Input {\n\ti.title.val = title\n\ti.title.fn = nil\n\treturn i\n}\n\n// Description sets the description of the input field.\n//\n// The Description is static for dynamic Description use `DescriptionFunc`.\nfunc (i *Input) Description(description string) *Input {\n\ti.description.val = description\n\ti.description.fn = nil\n\treturn i\n}\n\n// TitleFunc sets the title func of the input field.\n//\n// The TitleFunc will be re-evaluated when the binding of the TitleFunc changes.\n// This is useful when you want to display dynamic content and update the title\n// when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (i *Input) TitleFunc(f func() string, bindings any) *Input {\n\ti.title.fn = f\n\ti.title.bindings = bindings\n\treturn i\n}\n\n// DescriptionFunc sets the description func of the input field.\n//\n// The DescriptionFunc will be re-evaluated when the binding of the\n// DescriptionFunc changes. This is useful when you want to display dynamic\n// content and update the description when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (i *Input) DescriptionFunc(f func() string, bindings any) *Input {\n\ti.description.fn = f\n\ti.description.bindings = bindings\n\treturn i\n}\n\n// Prompt sets the prompt of the input field.\nfunc (i *Input) Prompt(prompt string) *Input {\n\ti.textinput.Prompt = prompt\n\treturn i\n}\n\n// CharLimit sets the character limit of the input field.\nfunc (i *Input) CharLimit(charlimit int) *Input {\n\ti.textinput.CharLimit = charlimit\n\treturn i\n}\n\n// Suggestions sets the suggestions to display for autocomplete in the input\n// field.\n//\n// The suggestions are static for dynamic suggestions use `SuggestionsFunc`.\nfunc (i *Input) Suggestions(suggestions []string) *Input {\n\ti.suggestions.fn = nil\n\n\ti.textinput.ShowSuggestions = len(suggestions) > 0\n\ti.textinput.KeyMap.AcceptSuggestion.SetEnabled(len(suggestions) > 0)\n\ti.textinput.SetSuggestions(suggestions)\n\treturn i\n}\n\n// SuggestionsFunc sets the suggestions func to display for autocomplete in the\n// input field.\n//\n// The SuggestionsFunc will be re-evaluated when the binding of the\n// SuggestionsFunc changes. This is useful when you want to display dynamic\n// suggestions when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (i *Input) SuggestionsFunc(f func() []string, bindings any) *Input {\n\ti.suggestions.fn = f\n\ti.suggestions.bindings = bindings\n\ti.suggestions.loading = true\n\n\ti.textinput.KeyMap.AcceptSuggestion.SetEnabled(f != nil)\n\ti.textinput.ShowSuggestions = f != nil\n\treturn i\n}\n\n// EchoMode sets the input behavior of the text Input field.\ntype EchoMode textinput.EchoMode\n\nconst (\n\t// EchoNormal displays text as is.\n\t// This is the default behavior.\n\tEchoModeNormal EchoMode = EchoMode(textinput.EchoNormal)\n\n\t// EchoPassword displays the EchoCharacter mask instead of actual characters.\n\t// This is commonly used for password fields.\n\tEchoModePassword EchoMode = EchoMode(textinput.EchoPassword)\n\n\t// EchoNone displays nothing as characters are entered.\n\t// This is commonly seen for password fields on the command line.\n\tEchoModeNone EchoMode = EchoMode(textinput.EchoNone)\n)\n\n// EchoMode sets the echo mode of the input.\nfunc (i *Input) EchoMode(mode EchoMode) *Input {\n\ti.textinput.EchoMode = textinput.EchoMode(mode)\n\treturn i\n}\n\n// Password sets whether or not to hide the input while the user is typing.\n//\n// Deprecated: use EchoMode(EchoPassword) instead.\nfunc (i *Input) Password(password bool) *Input {\n\tif password {\n\t\ti.textinput.EchoMode = textinput.EchoPassword\n\t} else {\n\t\ti.textinput.EchoMode = textinput.EchoNormal\n\t}\n\treturn i\n}\n\n// Placeholder sets the placeholder of the text input.\nfunc (i *Input) Placeholder(str string) *Input {\n\ti.textinput.Placeholder = str\n\treturn i\n}\n\n// PlaceholderFunc sets the placeholder func of the text input.\nfunc (i *Input) PlaceholderFunc(f func() string, bindings any) *Input {\n\ti.placeholder.fn = f\n\ti.placeholder.bindings = bindings\n\treturn i\n}\n\n// Inline sets whether the title and input should be on the same line.\nfunc (i *Input) Inline(inline bool) *Input {\n\ti.inline = inline\n\treturn i\n}\n\n// Validate sets the validation function of the input field.\nfunc (i *Input) Validate(validate func(string) error) *Input {\n\ti.validate = validate\n\treturn i\n}\n\n// Error returns the error of the input field.\nfunc (i *Input) Error() error { return i.err }\n\n// Skip returns whether the input should be skipped or should be blocking.\nfunc (*Input) Skip() bool { return false }\n\n// Zoom returns whether the input should be zoomed.\nfunc (*Input) Zoom() bool { return false }\n\n// Focus focuses the input field.\nfunc (i *Input) Focus() tea.Cmd {\n\ti.focused = true\n\treturn i.textinput.Focus()\n}\n\n// Blur blurs the input field.\nfunc (i *Input) Blur() tea.Cmd {\n\ti.focused = false\n\ti.accessor.Set(i.textinput.Value())\n\ti.textinput.Blur()\n\ti.err = i.validate(i.accessor.Get())\n\treturn nil\n}\n\n// KeyBinds returns the help message for the input field.\nfunc (i *Input) KeyBinds() []key.Binding {\n\tif i.textinput.ShowSuggestions {\n\t\treturn []key.Binding{i.keymap.AcceptSuggestion, i.keymap.Prev, i.keymap.Submit, i.keymap.Next}\n\t}\n\treturn []key.Binding{i.keymap.Prev, i.keymap.Submit, i.keymap.Next}\n}\n\n// Init initializes the input field.\nfunc (i *Input) Init() tea.Cmd {\n\ti.textinput.Blur()\n\treturn nil\n}\n\n// Update updates the input field.\nfunc (i *Input) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\tvar cmd tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase updateFieldMsg:\n\t\tvar cmds []tea.Cmd\n\t\tif ok, hash := i.title.shouldUpdate(); ok {\n\t\t\ti.title.bindingsHash = hash\n\t\t\tif !i.title.loadFromCache() {\n\t\t\t\ti.title.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateTitleMsg{id: i.id, title: i.title.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := i.description.shouldUpdate(); ok {\n\t\t\ti.description.bindingsHash = hash\n\t\t\tif !i.description.loadFromCache() {\n\t\t\t\ti.description.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateDescriptionMsg{id: i.id, description: i.description.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := i.placeholder.shouldUpdate(); ok {\n\t\t\ti.placeholder.bindingsHash = hash\n\t\t\tif i.placeholder.loadFromCache() {\n\t\t\t\ti.textinput.Placeholder = i.placeholder.val\n\t\t\t} else {\n\t\t\t\ti.placeholder.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updatePlaceholderMsg{id: i.id, placeholder: i.placeholder.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := i.suggestions.shouldUpdate(); ok {\n\t\t\ti.suggestions.bindingsHash = hash\n\t\t\tif i.suggestions.loadFromCache() {\n\t\t\t\ti.textinput.ShowSuggestions = len(i.suggestions.val) > 0\n\t\t\t\ti.textinput.SetSuggestions(i.suggestions.val)\n\t\t\t} else {\n\t\t\t\ti.suggestions.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateSuggestionsMsg{id: i.id, suggestions: i.suggestions.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn i, tea.Batch(cmds...)\n\tcase updateTitleMsg:\n\t\tif i.id == msg.id && i.title.bindingsHash == msg.hash {\n\t\t\ti.title.update(msg.title)\n\t\t}\n\tcase updateDescriptionMsg:\n\t\tif i.id == msg.id && i.description.bindingsHash == msg.hash {\n\t\t\ti.description.update(msg.description)\n\t\t}\n\tcase updatePlaceholderMsg:\n\t\tif i.id == msg.id && i.placeholder.bindingsHash == msg.hash {\n\t\t\ti.placeholder.update(msg.placeholder)\n\t\t\ti.textinput.Placeholder = msg.placeholder\n\t\t}\n\tcase updateSuggestionsMsg:\n\t\tif i.id == msg.id && i.suggestions.bindingsHash == msg.hash {\n\t\t\ti.suggestions.update(msg.suggestions)\n\t\t\ti.textinput.ShowSuggestions = len(msg.suggestions) > 0\n\t\t\ti.textinput.SetSuggestions(msg.suggestions)\n\t\t}\n\tcase tea.KeyMsg:\n\t\ti.err = nil\n\n\t\tswitch {\n\t\tcase key.Matches(msg, i.keymap.Prev):\n\t\t\tcmds = append(cmds, PrevField)\n\t\tcase key.Matches(msg, i.keymap.Next, i.keymap.Submit):\n\t\t\tvalue := i.textinput.Value()\n\t\t\ti.err = i.validate(value)\n\t\t\tif i.err != nil {\n\t\t\t\treturn i, nil\n\t\t\t}\n\t\t\tcmds = append(cmds, NextField)\n\t\t}\n\t}\n\n\ti.textinput, cmd = i.textinput.Update(msg)\n\tcmds = append(cmds, cmd)\n\ti.accessor.Set(i.textinput.Value())\n\n\treturn i, tea.Batch(cmds...)\n}\n\nfunc (i *Input) activeStyles() *FieldStyles {\n\ttheme := i.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif i.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\n// View renders the input field.\nfunc (i *Input) View() string {\n\tstyles := i.activeStyles()\n\n\t// NB: since the method is on a pointer receiver these are being mutated.\n\t// Because this runs on every render this shouldn't matter in practice,\n\t// however.\n\ti.textinput.PlaceholderStyle = styles.TextInput.Placeholder\n\ti.textinput.PromptStyle = styles.TextInput.Prompt\n\ti.textinput.Cursor.Style = styles.TextInput.Cursor\n\ti.textinput.Cursor.TextStyle = styles.TextInput.CursorText\n\ti.textinput.TextStyle = styles.TextInput.Text\n\n\t// Adjust text input size to its char limit if it fit in its width\n\tif i.textinput.CharLimit > 0 {\n\t\ti.textinput.Width = min(i.textinput.CharLimit, i.textinput.Width)\n\t}\n\n\tvar sb strings.Builder\n\tif i.title.val != \"\" || i.title.fn != nil {\n\t\tsb.WriteString(styles.Title.Render(i.title.val))\n\t\tif !i.inline {\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\tif i.description.val != \"\" || i.description.fn != nil {\n\t\tsb.WriteString(styles.Description.Render(i.description.val))\n\t\tif !i.inline {\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\tsb.WriteString(i.textinput.View())\n\n\treturn styles.Base.Render(sb.String())\n}\n\n// Run runs the input field in accessible mode.\nfunc (i *Input) Run() error {\n\tif i.accessible {\n\t\treturn i.runAccessible()\n\t}\n\treturn i.run()\n}\n\n// run runs the input field.\nfunc (i *Input) run() error {\n\treturn Run(i)\n}\n\n// runAccessible runs the input field in accessible mode.\nfunc (i *Input) runAccessible() error {\n\tstyles := i.activeStyles()\n\tfmt.Println(styles.Title.Render(i.title.val))\n\tfmt.Println()\n\ti.accessor.Set(accessibility.PromptString(\"Input: \", i.validate))\n\tfmt.Println(styles.SelectedOption.Render(\"Input: \" + i.accessor.Get() + \"\\n\"))\n\treturn nil\n}\n\n// WithKeyMap sets the keymap on an input field.\nfunc (i *Input) WithKeyMap(k *KeyMap) Field {\n\ti.keymap = k.Input\n\ti.textinput.KeyMap.AcceptSuggestion = i.keymap.AcceptSuggestion\n\treturn i\n}\n\n// WithAccessible sets the accessible mode of the input field.\nfunc (i *Input) WithAccessible(accessible bool) Field {\n\ti.accessible = accessible\n\treturn i\n}\n\n// WithTheme sets the theme of the input field.\nfunc (i *Input) WithTheme(theme *Theme) Field {\n\tif i.theme != nil {\n\t\treturn i\n\t}\n\ti.theme = theme\n\treturn i\n}\n\n// WithWidth sets the width of the input field.\nfunc (i *Input) WithWidth(width int) Field {\n\tstyles := i.activeStyles()\n\ti.width = width\n\tframeSize := styles.Base.GetHorizontalFrameSize()\n\tpromptWidth := lipgloss.Width(i.textinput.PromptStyle.Render(i.textinput.Prompt))\n\ttitleWidth := lipgloss.Width(styles.Title.Render(i.title.val))\n\tdescriptionWidth := lipgloss.Width(styles.Description.Render(i.description.val))\n\ti.textinput.Width = width - frameSize - promptWidth - 1\n\tif i.inline {\n\t\ti.textinput.Width -= titleWidth\n\t\ti.textinput.Width -= descriptionWidth\n\t}\n\treturn i\n}\n\n// WithHeight sets the height of the input field.\nfunc (i *Input) WithHeight(height int) Field {\n\ti.height = height\n\treturn i\n}\n\n// WithPosition sets the position of the input field.\nfunc (i *Input) WithPosition(p FieldPosition) Field {\n\ti.keymap.Prev.SetEnabled(!p.IsFirst())\n\ti.keymap.Next.SetEnabled(!p.IsLast())\n\ti.keymap.Submit.SetEnabled(p.IsLast())\n\treturn i\n}\n\n// GetKey returns the key of the field.\nfunc (i *Input) GetKey() string { return i.key }\n\n// GetValue returns the value of the field.\nfunc (i *Input) GetValue() any {\n\treturn i.accessor.Get()\n}\n"
        },
        {
          "name": "field_multiselect.go",
          "type": "blob",
          "size": 19.4091796875,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/spinner\"\n\t\"github.com/charmbracelet/bubbles/textinput\"\n\t\"github.com/charmbracelet/bubbles/viewport\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/accessibility\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// MultiSelect is a form multi-select field.\ntype MultiSelect[T comparable] struct {\n\taccessor Accessor[[]T]\n\tkey      string\n\tid       int\n\n\t// customization\n\ttitle           Eval[string]\n\tdescription     Eval[string]\n\toptions         Eval[[]Option[T]]\n\tfilterable      bool\n\tfilteredOptions []Option[T]\n\tlimit           int\n\theight          int\n\n\t// error handling\n\tvalidate func([]T) error\n\terr      error\n\n\t// state\n\tcursor    int\n\tfocused   bool\n\tfiltering bool\n\tfilter    textinput.Model\n\tviewport  viewport.Model\n\tspinner   spinner.Model\n\n\t// options\n\twidth      int\n\taccessible bool\n\ttheme      *Theme\n\tkeymap     MultiSelectKeyMap\n}\n\n// NewMultiSelect returns a new multi-select field.\nfunc NewMultiSelect[T comparable]() *MultiSelect[T] {\n\tfilter := textinput.New()\n\tfilter.Prompt = \"/\"\n\n\ts := spinner.New(spinner.WithSpinner(spinner.Line))\n\n\treturn &MultiSelect[T]{\n\t\taccessor:    &EmbeddedAccessor[[]T]{},\n\t\tvalidate:    func([]T) error { return nil },\n\t\tfiltering:   false,\n\t\tfilter:      filter,\n\t\tid:          nextID(),\n\t\toptions:     Eval[[]Option[T]]{cache: make(map[uint64][]Option[T])},\n\t\ttitle:       Eval[string]{cache: make(map[uint64]string)},\n\t\tdescription: Eval[string]{cache: make(map[uint64]string)},\n\t\tspinner:     s,\n\t\tfilterable:  true,\n\t}\n}\n\n// Value sets the value of the multi-select field.\nfunc (m *MultiSelect[T]) Value(value *[]T) *MultiSelect[T] {\n\treturn m.Accessor(NewPointerAccessor(value))\n}\n\n// Accessor sets the accessor of the input field.\nfunc (m *MultiSelect[T]) Accessor(accessor Accessor[[]T]) *MultiSelect[T] {\n\tm.accessor = accessor\n\tfor i, o := range m.options.val {\n\t\tfor _, v := range m.accessor.Get() {\n\t\t\tif o.Value == v {\n\t\t\t\tm.options.val[i].selected = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn m\n}\n\n// Key sets the key of the select field which can be used to retrieve the value\n// after submission.\nfunc (m *MultiSelect[T]) Key(key string) *MultiSelect[T] {\n\tm.key = key\n\treturn m\n}\n\n// Title sets the title of the multi-select field.\nfunc (m *MultiSelect[T]) Title(title string) *MultiSelect[T] {\n\tm.title.val = title\n\tm.title.fn = nil\n\treturn m\n}\n\n// TitleFunc sets the title func of the multi-select field.\nfunc (m *MultiSelect[T]) TitleFunc(f func() string, bindings any) *MultiSelect[T] {\n\tm.title.fn = f\n\tm.title.bindings = bindings\n\treturn m\n}\n\n// Description sets the description of the multi-select field.\nfunc (m *MultiSelect[T]) Description(description string) *MultiSelect[T] {\n\tm.description.val = description\n\treturn m\n}\n\n// DescriptionFunc sets the description func of the multi-select field.\nfunc (m *MultiSelect[T]) DescriptionFunc(f func() string, bindings any) *MultiSelect[T] {\n\tm.description.fn = f\n\tm.description.bindings = bindings\n\treturn m\n}\n\n// Options sets the options of the multi-select field.\nfunc (m *MultiSelect[T]) Options(options ...Option[T]) *MultiSelect[T] {\n\tif len(options) <= 0 {\n\t\treturn m\n\t}\n\n\tfor i, o := range options {\n\t\tfor _, v := range m.accessor.Get() {\n\t\t\tif o.Value == v {\n\t\t\t\toptions[i].selected = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\tm.options.val = options\n\tm.filteredOptions = options\n\tm.updateViewportHeight()\n\treturn m\n}\n\n// OptionsFunc sets the options func of the multi-select field.\nfunc (m *MultiSelect[T]) OptionsFunc(f func() []Option[T], bindings any) *MultiSelect[T] {\n\tm.options.fn = f\n\tm.options.bindings = bindings\n\tm.filteredOptions = make([]Option[T], 0)\n\t// If there is no height set, we should attach a static height since these\n\t// options are possibly dynamic.\n\tif m.height <= 0 {\n\t\tm.height = defaultHeight\n\t\tm.updateViewportHeight()\n\t}\n\treturn m\n}\n\n// Filterable sets the multi-select field as filterable.\nfunc (m *MultiSelect[T]) Filterable(filterable bool) *MultiSelect[T] {\n\tm.filterable = filterable\n\treturn m\n}\n\n// Filtering sets the filtering state of the multi-select field.\nfunc (m *MultiSelect[T]) Filtering(filtering bool) *MultiSelect[T] {\n\tm.filtering = filtering\n\tm.filter.Focus()\n\treturn m\n}\n\n// Limit sets the limit of the multi-select field.\nfunc (m *MultiSelect[T]) Limit(limit int) *MultiSelect[T] {\n\tm.limit = limit\n\tm.setSelectAllHelp()\n\treturn m\n}\n\n// Height sets the height of the multi-select field.\nfunc (m *MultiSelect[T]) Height(height int) *MultiSelect[T] {\n\t// What we really want to do is set the height of the viewport, but we\n\t// need a theme applied before we can calcualate its height.\n\tm.height = height\n\tm.updateViewportHeight()\n\treturn m\n}\n\n// Validate sets the validation function of the multi-select field.\nfunc (m *MultiSelect[T]) Validate(validate func([]T) error) *MultiSelect[T] {\n\tm.validate = validate\n\treturn m\n}\n\n// Error returns the error of the multi-select field.\nfunc (m *MultiSelect[T]) Error() error {\n\treturn m.err\n}\n\n// Skip returns whether the multiselect should be skipped or should be blocking.\nfunc (*MultiSelect[T]) Skip() bool {\n\treturn false\n}\n\n// Zoom returns whether the multiselect should be zoomed.\nfunc (*MultiSelect[T]) Zoom() bool {\n\treturn false\n}\n\n// Focus focuses the multi-select field.\nfunc (m *MultiSelect[T]) Focus() tea.Cmd {\n\tm.updateValue()\n\tm.focused = true\n\treturn nil\n}\n\n// Blur blurs the multi-select field.\nfunc (m *MultiSelect[T]) Blur() tea.Cmd {\n\tm.updateValue()\n\tm.focused = false\n\treturn nil\n}\n\n// KeyBinds returns the help message for the multi-select field.\nfunc (m *MultiSelect[T]) KeyBinds() []key.Binding {\n\tbinds := []key.Binding{\n\t\tm.keymap.Toggle,\n\t\tm.keymap.Up,\n\t\tm.keymap.Down,\n\t}\n\tif m.filterable {\n\t\tbinds = append(\n\t\t\tbinds,\n\t\t\tm.keymap.Filter,\n\t\t\tm.keymap.SetFilter,\n\t\t\tm.keymap.ClearFilter,\n\t\t)\n\t}\n\tbinds = append(\n\t\tbinds,\n\t\tm.keymap.Prev,\n\t\tm.keymap.Submit,\n\t\tm.keymap.Next,\n\t\tm.keymap.SelectAll,\n\t\tm.keymap.SelectNone,\n\t)\n\treturn binds\n}\n\n// Init initializes the multi-select field.\nfunc (m *MultiSelect[T]) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update updates the multi-select field.\nfunc (m *MultiSelect[T]) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\t// Enforce height on the viewport during update as we need themes to\n\t// be applied before we can calculate the height.\n\tm.updateViewportHeight()\n\n\tvar cmd tea.Cmd\n\tif m.filtering {\n\t\tm.filter, cmd = m.filter.Update(msg)\n\t\tm.setSelectAllHelp()\n\t\tcmds = append(cmds, cmd)\n\t}\n\n\tswitch msg := msg.(type) {\n\tcase updateFieldMsg:\n\t\tvar fieldCmds []tea.Cmd\n\t\tif ok, hash := m.title.shouldUpdate(); ok {\n\t\t\tm.title.bindingsHash = hash\n\t\t\tif !m.title.loadFromCache() {\n\t\t\t\tm.title.loading = true\n\t\t\t\tfieldCmds = append(fieldCmds, func() tea.Msg {\n\t\t\t\t\treturn updateTitleMsg{id: m.id, title: m.title.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := m.description.shouldUpdate(); ok {\n\t\t\tm.description.bindingsHash = hash\n\t\t\tif !m.description.loadFromCache() {\n\t\t\t\tm.description.loading = true\n\t\t\t\tfieldCmds = append(fieldCmds, func() tea.Msg {\n\t\t\t\t\treturn updateDescriptionMsg{id: m.id, description: m.description.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := m.options.shouldUpdate(); ok {\n\t\t\tm.options.bindingsHash = hash\n\t\t\tif m.options.loadFromCache() {\n\t\t\t\tm.filteredOptions = m.options.val\n\t\t\t\tm.updateValue()\n\t\t\t\tm.cursor = clamp(m.cursor, 0, len(m.filteredOptions)-1)\n\t\t\t} else {\n\t\t\t\tm.options.loading = true\n\t\t\t\tm.options.loadingStart = time.Now()\n\t\t\t\tfieldCmds = append(fieldCmds, func() tea.Msg {\n\t\t\t\t\treturn updateOptionsMsg[T]{id: m.id, options: m.options.fn(), hash: hash}\n\t\t\t\t}, m.spinner.Tick)\n\t\t\t}\n\t\t}\n\n\t\treturn m, tea.Batch(fieldCmds...)\n\n\tcase spinner.TickMsg:\n\t\tif !m.options.loading {\n\t\t\tbreak\n\t\t}\n\t\tm.spinner, cmd = m.spinner.Update(msg)\n\t\treturn m, cmd\n\n\tcase updateTitleMsg:\n\t\tif msg.id == m.id && msg.hash == m.title.bindingsHash {\n\t\t\tm.title.update(msg.title)\n\t\t}\n\tcase updateDescriptionMsg:\n\t\tif msg.id == m.id && msg.hash == m.description.bindingsHash {\n\t\t\tm.description.update(msg.description)\n\t\t}\n\tcase updateOptionsMsg[T]:\n\t\tif msg.id == m.id && msg.hash == m.options.bindingsHash {\n\t\t\tm.options.update(msg.options)\n\t\t\t// since we're updating the options, we need to reset the cursor.\n\t\t\tm.filteredOptions = m.options.val\n\t\t\tm.updateValue()\n\t\t\tm.cursor = clamp(m.cursor, 0, len(m.filteredOptions)-1)\n\t\t}\n\tcase tea.KeyMsg:\n\t\tm.err = nil\n\t\tswitch {\n\t\tcase key.Matches(msg, m.keymap.Filter):\n\t\t\tm.setFilter(true)\n\t\t\treturn m, m.filter.Focus()\n\t\tcase key.Matches(msg, m.keymap.SetFilter):\n\t\t\tif len(m.filteredOptions) <= 0 {\n\t\t\t\tm.filter.SetValue(\"\")\n\t\t\t\tm.filteredOptions = m.options.val\n\t\t\t}\n\t\t\tm.setFilter(false)\n\t\tcase key.Matches(msg, m.keymap.ClearFilter):\n\t\t\tm.filter.SetValue(\"\")\n\t\t\tm.filteredOptions = m.options.val\n\t\t\tm.setFilter(false)\n\t\tcase key.Matches(msg, m.keymap.Up):\n\t\t\t// FIXME: should use keys in keymap\n\t\t\tif m.filtering && msg.String() == \"k\" {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tm.cursor = max(m.cursor-1, 0)\n\t\t\tif m.cursor < m.viewport.YOffset {\n\t\t\t\tm.viewport.SetYOffset(m.cursor)\n\t\t\t}\n\t\tcase key.Matches(msg, m.keymap.Down):\n\t\t\t// FIXME: should use keys in keymap\n\t\t\tif m.filtering && msg.String() == \"j\" {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tm.cursor = min(m.cursor+1, len(m.filteredOptions)-1)\n\t\t\tif m.cursor >= m.viewport.YOffset+m.viewport.Height {\n\t\t\t\tm.viewport.LineDown(1)\n\t\t\t}\n\t\tcase key.Matches(msg, m.keymap.GotoTop):\n\t\t\tif m.filtering {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tm.cursor = 0\n\t\t\tm.viewport.GotoTop()\n\t\tcase key.Matches(msg, m.keymap.GotoBottom):\n\t\t\tif m.filtering {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tm.cursor = len(m.filteredOptions) - 1\n\t\t\tm.viewport.GotoBottom()\n\t\tcase key.Matches(msg, m.keymap.HalfPageUp):\n\t\t\tm.cursor = max(m.cursor-m.viewport.Height/2, 0)\n\t\t\tm.viewport.HalfViewUp()\n\t\tcase key.Matches(msg, m.keymap.HalfPageDown):\n\t\t\tm.cursor = min(m.cursor+m.viewport.Height/2, len(m.filteredOptions)-1)\n\t\t\tm.viewport.HalfViewDown()\n\t\tcase key.Matches(msg, m.keymap.Toggle) && !m.filtering:\n\t\t\tfor i, option := range m.options.val {\n\t\t\t\tif option.Key == m.filteredOptions[m.cursor].Key {\n\t\t\t\t\tif !m.options.val[m.cursor].selected && m.limit > 0 && m.numSelected() >= m.limit {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tselected := m.options.val[i].selected\n\t\t\t\t\tm.options.val[i].selected = !selected\n\t\t\t\t\tm.filteredOptions[m.cursor].selected = !selected\n\t\t\t\t}\n\t\t\t}\n\t\t\tm.setSelectAllHelp()\n\t\t\tm.updateValue()\n\t\tcase key.Matches(msg, m.keymap.SelectAll, m.keymap.SelectNone) && m.limit <= 0:\n\t\t\tselected := false\n\n\t\t\tfor _, option := range m.filteredOptions {\n\t\t\t\tif !option.selected {\n\t\t\t\t\tselected = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor i, option := range m.options.val {\n\t\t\t\tfor j := range m.filteredOptions {\n\t\t\t\t\tif option.Key == m.filteredOptions[j].Key {\n\t\t\t\t\t\tm.options.val[i].selected = selected\n\t\t\t\t\t\tm.filteredOptions[j].selected = selected\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tm.setSelectAllHelp()\n\t\t\tm.updateValue()\n\t\tcase key.Matches(msg, m.keymap.Prev):\n\t\t\tm.updateValue()\n\t\t\tm.err = m.validate(m.accessor.Get())\n\t\t\tif m.err != nil {\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t\treturn m, PrevField\n\t\tcase key.Matches(msg, m.keymap.Next, m.keymap.Submit):\n\t\t\tm.updateValue()\n\t\t\tm.err = m.validate(m.accessor.Get())\n\t\t\tif m.err != nil {\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t\treturn m, NextField\n\t\t}\n\n\t\tif m.filtering {\n\t\t\tm.filteredOptions = m.options.val\n\t\t\tif m.filter.Value() != \"\" {\n\t\t\t\tm.filteredOptions = nil\n\t\t\t\tfor _, option := range m.options.val {\n\t\t\t\t\tif m.filterFunc(option.Key) {\n\t\t\t\t\t\tm.filteredOptions = append(m.filteredOptions, option)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(m.filteredOptions) > 0 {\n\t\t\t\tm.cursor = min(m.cursor, len(m.filteredOptions)-1)\n\t\t\t\tm.viewport.SetYOffset(clamp(m.cursor, 0, len(m.filteredOptions)-m.viewport.Height))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn m, tea.Batch(cmds...)\n}\n\n// updateViewportHeight updates the viewport size according to the Height setting\n// on this multi-select field.\nfunc (m *MultiSelect[T]) updateViewportHeight() {\n\t// If no height is set size the viewport to the number of options.\n\tif m.height <= 0 {\n\t\tm.viewport.Height = len(m.options.val)\n\t\treturn\n\t}\n\n\tconst minHeight = 1\n\tm.viewport.Height = max(minHeight, m.height-\n\t\tlipgloss.Height(m.titleView())-\n\t\tlipgloss.Height(m.descriptionView()))\n}\n\n// numSelected returns the total number of selected options.\nfunc (m *MultiSelect[T]) numSelected() int {\n\tvar count int\n\tfor _, o := range m.options.val {\n\t\tif o.selected {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\n// numFilteredOptionsSelected returns the number of selected options with the\n// current filter applied.\nfunc (m *MultiSelect[T]) numFilteredSelected() int {\n\tvar count int\n\tfor _, o := range m.filteredOptions {\n\t\tif o.selected {\n\t\t\tcount++\n\t\t}\n\t}\n\treturn count\n}\n\nfunc (m *MultiSelect[T]) updateValue() {\n\tvalue := make([]T, 0)\n\tfor _, option := range m.options.val {\n\t\tif option.selected {\n\t\t\tvalue = append(value, option.Value)\n\t\t}\n\t}\n\tm.accessor.Set(value)\n\tm.err = m.validate(m.accessor.Get())\n}\n\nfunc (m *MultiSelect[T]) activeStyles() *FieldStyles {\n\ttheme := m.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif m.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\nfunc (m *MultiSelect[T]) titleView() string {\n\tif m.title.val == \"\" {\n\t\treturn \"\"\n\t}\n\tvar (\n\t\tstyles = m.activeStyles()\n\t\tsb     = strings.Builder{}\n\t)\n\tif m.filtering {\n\t\tsb.WriteString(m.filter.View())\n\t} else if m.filter.Value() != \"\" {\n\t\tsb.WriteString(styles.Title.Render(m.title.val) + styles.Description.Render(\"/\"+m.filter.Value()))\n\t} else {\n\t\tsb.WriteString(styles.Title.Render(m.title.val))\n\t}\n\tif m.err != nil {\n\t\tsb.WriteString(styles.ErrorIndicator.String())\n\t}\n\treturn sb.String()\n}\n\nfunc (m *MultiSelect[T]) descriptionView() string {\n\treturn m.activeStyles().Description.Render(m.description.val)\n}\n\nfunc (m *MultiSelect[T]) optionsView() string {\n\tvar (\n\t\tstyles = m.activeStyles()\n\t\tc      = styles.MultiSelectSelector.String()\n\t\tsb     strings.Builder\n\t)\n\n\tif m.options.loading && time.Since(m.options.loadingStart) > spinnerShowThreshold {\n\t\tm.spinner.Style = m.activeStyles().MultiSelectSelector.UnsetString()\n\t\tsb.WriteString(m.spinner.View() + \" Loading...\")\n\t\treturn sb.String()\n\t}\n\n\tfor i, option := range m.filteredOptions {\n\t\tif m.cursor == i {\n\t\t\tsb.WriteString(c)\n\t\t} else {\n\t\t\tsb.WriteString(strings.Repeat(\" \", lipgloss.Width(c)))\n\t\t}\n\n\t\tif m.filteredOptions[i].selected {\n\t\t\tsb.WriteString(styles.SelectedPrefix.String())\n\t\t\tsb.WriteString(styles.SelectedOption.Render(option.Key))\n\t\t} else {\n\t\t\tsb.WriteString(styles.UnselectedPrefix.String())\n\t\t\tsb.WriteString(styles.UnselectedOption.Render(option.Key))\n\t\t}\n\t\tif i < len(m.options.val)-1 {\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\tfor i := len(m.filteredOptions); i < len(m.options.val)-1; i++ {\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\treturn sb.String()\n}\n\n// View renders the multi-select field.\nfunc (m *MultiSelect[T]) View() string {\n\tstyles := m.activeStyles()\n\n\tm.viewport.SetContent(m.optionsView())\n\n\tvar sb strings.Builder\n\tif m.title.val != \"\" || m.title.fn != nil {\n\t\tsb.WriteString(m.titleView())\n\t\tsb.WriteString(\"\\n\")\n\t}\n\tif m.description.val != \"\" || m.description.fn != nil {\n\t\tsb.WriteString(m.descriptionView() + \"\\n\")\n\t}\n\tsb.WriteString(m.viewport.View())\n\treturn styles.Base.Render(sb.String())\n}\n\nfunc (m *MultiSelect[T]) printOptions() {\n\tstyles := m.activeStyles()\n\tvar sb strings.Builder\n\tsb.WriteString(styles.Title.Render(m.title.val))\n\tsb.WriteString(\"\\n\")\n\n\tfor i, option := range m.options.val {\n\t\tif option.selected {\n\t\t\tsb.WriteString(styles.SelectedOption.Render(fmt.Sprintf(\"%d. %s %s\", i+1, \"✓\", option.Key)))\n\t\t} else {\n\t\t\tsb.WriteString(fmt.Sprintf(\"%d. %s %s\", i+1, \" \", option.Key))\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\tfmt.Println(sb.String())\n}\n\n// setFilter sets the filter of the select field.\nfunc (m *MultiSelect[T]) setFilter(filter bool) {\n\tm.filtering = filter\n\tm.keymap.SetFilter.SetEnabled(filter)\n\tm.keymap.Filter.SetEnabled(!filter)\n\tm.keymap.Next.SetEnabled(!filter)\n\tm.keymap.Submit.SetEnabled(!filter)\n\tm.keymap.Prev.SetEnabled(!filter)\n\tm.keymap.ClearFilter.SetEnabled(!filter && m.filter.Value() != \"\")\n}\n\n// filterFunc returns true if the option matches the filter.\nfunc (m *MultiSelect[T]) filterFunc(option string) bool {\n\t// XXX: remove diacritics or allow customization of filter function.\n\treturn strings.Contains(strings.ToLower(option), strings.ToLower(m.filter.Value()))\n}\n\n// setSelectAllHelp enables the appropriate select all or select none keybinding.\nfunc (m *MultiSelect[T]) setSelectAllHelp() {\n\tif m.limit <= 0 {\n\t\tnoneSelected := m.numFilteredSelected() <= 0\n\t\tallSelected := m.numFilteredSelected() > 0 && m.numFilteredSelected() < len(m.filteredOptions)\n\t\tselectAll := noneSelected || allSelected\n\t\tm.keymap.SelectAll.SetEnabled(selectAll)\n\t\tm.keymap.SelectNone.SetEnabled(!selectAll)\n\t}\n}\n\n// Run runs the multi-select field.\nfunc (m *MultiSelect[T]) Run() error {\n\tif m.accessible {\n\t\treturn m.runAccessible()\n\t}\n\treturn Run(m)\n}\n\n// runAccessible() runs the multi-select field in accessible mode.\nfunc (m *MultiSelect[T]) runAccessible() error {\n\tm.printOptions()\n\tstyles := m.activeStyles()\n\n\tvar choice int\n\tfor {\n\t\tfmt.Printf(\"Select up to %d options. 0 to continue.\\n\", m.limit)\n\n\t\tchoice = accessibility.PromptInt(\"Select: \", 0, len(m.options.val))\n\t\tif choice == 0 {\n\t\t\tm.updateValue()\n\t\t\terr := m.validate(m.accessor.Get())\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tif !m.options.val[choice-1].selected && m.limit > 0 && m.numSelected() >= m.limit {\n\t\t\tfmt.Printf(\"You can't select more than %d options.\\n\", m.limit)\n\t\t\tcontinue\n\t\t}\n\t\tm.options.val[choice-1].selected = !m.options.val[choice-1].selected\n\t\tif m.options.val[choice-1].selected {\n\t\t\tfmt.Printf(\"Selected: %s\\n\\n\", m.options.val[choice-1].Key)\n\t\t} else {\n\t\t\tfmt.Printf(\"Deselected: %s\\n\\n\", m.options.val[choice-1].Key)\n\t\t}\n\n\t\tm.printOptions()\n\t}\n\n\tvar values []string\n\n\tvalue := m.accessor.Get()\n\tfor _, option := range m.options.val {\n\t\tif option.selected {\n\t\t\tvalue = append(value, option.Value)\n\t\t\tvalues = append(values, option.Key)\n\t\t}\n\t}\n\tm.accessor.Set(value)\n\n\tfmt.Println(styles.SelectedOption.Render(\"Selected:\", strings.Join(values, \", \")+\"\\n\"))\n\treturn nil\n}\n\n// WithTheme sets the theme of the multi-select field.\nfunc (m *MultiSelect[T]) WithTheme(theme *Theme) Field {\n\tif m.theme != nil {\n\t\treturn m\n\t}\n\tm.theme = theme\n\tm.filter.Cursor.Style = theme.Focused.TextInput.Cursor\n\tm.filter.Cursor.TextStyle = theme.Focused.TextInput.CursorText\n\tm.filter.PromptStyle = theme.Focused.TextInput.Prompt\n\tm.filter.TextStyle = theme.Focused.TextInput.Text\n\tm.filter.PlaceholderStyle = theme.Focused.TextInput.Placeholder\n\tm.updateViewportHeight()\n\treturn m\n}\n\n// WithKeyMap sets the keymap of the multi-select field.\nfunc (m *MultiSelect[T]) WithKeyMap(k *KeyMap) Field {\n\tm.keymap = k.MultiSelect\n\tif !m.filterable {\n\t\tm.keymap.Filter.SetEnabled(false)\n\t\tm.keymap.ClearFilter.SetEnabled(false)\n\t\tm.keymap.SetFilter.SetEnabled(false)\n\t}\n\treturn m\n}\n\n// WithAccessible sets the accessible mode of the multi-select field.\nfunc (m *MultiSelect[T]) WithAccessible(accessible bool) Field {\n\tm.accessible = accessible\n\treturn m\n}\n\n// WithWidth sets the width of the multi-select field.\nfunc (m *MultiSelect[T]) WithWidth(width int) Field {\n\tm.width = width\n\treturn m\n}\n\n// WithHeight sets the total height of the multi-select field. Including padding\n// and help menu heights.\nfunc (m *MultiSelect[T]) WithHeight(height int) Field {\n\tm.Height(height)\n\treturn m\n}\n\n// WithPosition sets the position of the multi-select field.\nfunc (m *MultiSelect[T]) WithPosition(p FieldPosition) Field {\n\tif m.filtering {\n\t\treturn m\n\t}\n\tm.keymap.Prev.SetEnabled(!p.IsFirst())\n\tm.keymap.Next.SetEnabled(!p.IsLast())\n\tm.keymap.Submit.SetEnabled(p.IsLast())\n\treturn m\n}\n\n// GetKey returns the multi-select's key.\nfunc (m *MultiSelect[T]) GetKey() string {\n\treturn m.key\n}\n\n// GetValue returns the multi-select's value.\nfunc (m *MultiSelect[T]) GetValue() any {\n\treturn m.accessor.Get()\n}\n"
        },
        {
          "name": "field_note.go",
          "type": "blob",
          "size": 8.5439453125,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n)\n\n// Note is a note field.\n//\n// A note is responsible for displaying information to the user. Use it to\n// provide context around a different field. Generally, the notes are not\n// interacted with unless the note has a next button `Next(true)`.\ntype Note struct {\n\tid int\n\n\ttitle       Eval[string]\n\tdescription Eval[string]\n\tnextLabel   string\n\n\tfocused        bool\n\tshowNextButton bool\n\tskip           bool\n\n\taccessible bool\n\theight     int\n\twidth      int\n\n\ttheme  *Theme\n\tkeymap NoteKeyMap\n}\n\n// NewNote creates a new note field.\n//\n// A note is responsible for displaying information to the user. Use it to\n// provide context around a different field. Generally, the notes are not\n// interacted with unless the note has a next button `Next(true)`.\nfunc NewNote() *Note {\n\treturn &Note{\n\t\tid:             nextID(),\n\t\tshowNextButton: false,\n\t\tskip:           true,\n\t\tnextLabel:      \"Next\",\n\t\ttitle:          Eval[string]{cache: make(map[uint64]string)},\n\t\tdescription:    Eval[string]{cache: make(map[uint64]string)},\n\t}\n}\n\n// Title sets the note field's title.\n//\n// This title will be static, for dynamic titles use `TitleFunc`.\nfunc (n *Note) Title(title string) *Note {\n\tn.title.val = title\n\tn.title.fn = nil\n\treturn n\n}\n\n// TitleFunc sets the title func of the note field.\n//\n// The TitleFunc will be re-evaluated when the binding of the TitleFunc changes.\n// This is useful when you want to display dynamic content and update the title\n// of a note when another part of your form changes.\n//\n// See README.md#Dynamic for more usage information.\nfunc (n *Note) TitleFunc(f func() string, bindings any) *Note {\n\tn.title.fn = f\n\tn.title.bindings = bindings\n\treturn n\n}\n\n// Description sets the note field's description.\n//\n// This description will be static, for dynamic descriptions use `DescriptionFunc`.\nfunc (n *Note) Description(description string) *Note {\n\tn.description.val = description\n\tn.description.fn = nil\n\treturn n\n}\n\n// DescriptionFunc sets the description func of the note field.\n//\n// The DescriptionFunc will be re-evaluated when the binding of the\n// DescriptionFunc changes. This is useful when you want to display dynamic\n// content and update the description of a note when another part of your form\n// changes.\n//\n// For example, you can make a dynamic markdown preview with the following Form & Group.\n//\n//\thuh.NewText().Title(\"Markdown\").Value(&md),\n//\thuh.NewNote().Height(20).Title(\"Preview\").\n//\t  DescriptionFunc(func() string {\n//\t      return md\n//\t  }, &md),\n//\n// Notice the `binding` of the Note is the same as the `Value` of the Text field.\n// This binds the two values together, so that when the `Value` of the Text\n// field changes so does the Note description.\nfunc (n *Note) DescriptionFunc(f func() string, bindings any) *Note {\n\tn.description.fn = f\n\tn.description.bindings = bindings\n\treturn n\n}\n\n// Height sets the note field's height.\nfunc (n *Note) Height(height int) *Note {\n\tn.height = height\n\treturn n\n}\n\n// Next sets whether or not to show the next button.\n//\n//\tTitle\n//\tDescription\n//\n//\t[ Next ]\nfunc (n *Note) Next(show bool) *Note {\n\tn.showNextButton = show\n\treturn n\n}\n\n// NextLabel sets the next button label.\nfunc (n *Note) NextLabel(label string) *Note {\n\tn.nextLabel = label\n\treturn n\n}\n\n// Focus focuses the note field.\nfunc (n *Note) Focus() tea.Cmd {\n\tn.focused = true\n\treturn nil\n}\n\n// Blur blurs the note field.\nfunc (n *Note) Blur() tea.Cmd {\n\tn.focused = false\n\treturn nil\n}\n\n// Error returns the error of the note field.\nfunc (n *Note) Error() error { return nil }\n\n// Skip returns whether the note should be skipped or should be blocking.\nfunc (n *Note) Skip() bool { return n.skip }\n\n// Zoom returns whether the note should be zoomed.\nfunc (n *Note) Zoom() bool { return false }\n\n// KeyBinds returns the help message for the note field.\nfunc (n *Note) KeyBinds() []key.Binding {\n\treturn []key.Binding{\n\t\tn.keymap.Prev,\n\t\tn.keymap.Submit,\n\t\tn.keymap.Next,\n\t}\n}\n\n// Init initializes the note field.\nfunc (n *Note) Init() tea.Cmd { return nil }\n\n// Update updates the note field.\nfunc (n *Note) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase updateFieldMsg:\n\t\tvar cmds []tea.Cmd\n\t\tif ok, hash := n.title.shouldUpdate(); ok {\n\t\t\tn.title.bindingsHash = hash\n\t\t\tif !n.title.loadFromCache() {\n\t\t\t\tn.title.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateTitleMsg{id: n.id, title: n.title.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := n.description.shouldUpdate(); ok {\n\t\t\tn.description.bindingsHash = hash\n\t\t\tif !n.description.loadFromCache() {\n\t\t\t\tn.description.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateDescriptionMsg{id: n.id, description: n.description.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn n, tea.Batch(cmds...)\n\tcase updateTitleMsg:\n\t\tif msg.id == n.id && msg.hash == n.title.bindingsHash {\n\t\t\tn.title.update(msg.title)\n\t\t}\n\tcase updateDescriptionMsg:\n\t\tif msg.id == n.id && msg.hash == n.description.bindingsHash {\n\t\t\tn.description.update(msg.description)\n\t\t}\n\tcase tea.KeyMsg:\n\t\tswitch {\n\t\tcase key.Matches(msg, n.keymap.Prev):\n\t\t\treturn n, PrevField\n\t\tcase key.Matches(msg, n.keymap.Next, n.keymap.Submit):\n\t\t\treturn n, NextField\n\t\t}\n\t\treturn n, NextField\n\t}\n\treturn n, nil\n}\n\nfunc (n *Note) activeStyles() *FieldStyles {\n\ttheme := n.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif n.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\n// View renders the note field.\nfunc (n *Note) View() string {\n\tstyles := n.activeStyles()\n\tsb := strings.Builder{}\n\n\tif n.title.val != \"\" || n.title.fn != nil {\n\t\tsb.WriteString(styles.NoteTitle.Render(n.title.val))\n\t}\n\tif n.description.val != \"\" || n.description.fn != nil {\n\t\tsb.WriteString(\"\\n\")\n\t\tsb.WriteString(render(n.description.val))\n\t}\n\tif n.showNextButton {\n\t\tsb.WriteString(styles.Next.Render(n.nextLabel))\n\t}\n\treturn styles.Card.Height(n.height).Render(sb.String())\n}\n\n// Run runs the note field.\nfunc (n *Note) Run() error {\n\tif n.accessible {\n\t\treturn n.runAccessible()\n\t}\n\treturn Run(n)\n}\n\n// runAccessible runs an accessible note field.\nfunc (n *Note) runAccessible() error {\n\tif n.title.val != \"\" {\n\t\tfmt.Println(n.title.val)\n\t\tfmt.Println()\n\t}\n\n\tfmt.Println(n.description.val)\n\tfmt.Println()\n\treturn nil\n}\n\n// WithTheme sets the theme on a note field.\nfunc (n *Note) WithTheme(theme *Theme) Field {\n\tif n.theme != nil {\n\t\treturn n\n\t}\n\tn.theme = theme\n\treturn n\n}\n\n// WithKeyMap sets the keymap on a note field.\nfunc (n *Note) WithKeyMap(k *KeyMap) Field {\n\tn.keymap = k.Note\n\treturn n\n}\n\n// WithAccessible sets the accessible mode of the note field.\nfunc (n *Note) WithAccessible(accessible bool) Field {\n\tn.accessible = accessible\n\treturn n\n}\n\n// WithWidth sets the width of the note field.\nfunc (n *Note) WithWidth(width int) Field {\n\tn.width = width\n\treturn n\n}\n\n// WithHeight sets the height of the note field.\nfunc (n *Note) WithHeight(height int) Field {\n\tn.Height(height)\n\treturn n\n}\n\n// WithPosition sets the position information of the note field.\nfunc (n *Note) WithPosition(p FieldPosition) Field {\n\t// if the note is the only field on the screen,\n\t// we shouldn't skip the entire group.\n\tif p.Field == p.FirstField && p.Field == p.LastField {\n\t\tn.skip = false\n\t}\n\tn.keymap.Prev.SetEnabled(!p.IsFirst())\n\tn.keymap.Next.SetEnabled(!p.IsLast())\n\tn.keymap.Submit.SetEnabled(p.IsLast())\n\treturn n\n}\n\n// GetValue satisfies the Field interface, notes do not have values.\nfunc (n *Note) GetValue() any { return nil }\n\n// GetKey satisfies the Field interface, notes do not have keys.\nfunc (n *Note) GetKey() string { return \"\" }\n\nfunc render(input string) string {\n\tvar result strings.Builder\n\tvar italic, bold, codeblock bool\n\tvar escape bool\n\n\tfor _, char := range input {\n\t\tif escape || codeblock {\n\t\t\tresult.WriteRune(char)\n\t\t\tescape = false\n\t\t\tcontinue\n\t\t}\n\t\tswitch char {\n\t\tcase '\\\\':\n\t\t\tescape = true\n\t\tcase '_':\n\t\t\tif !italic {\n\t\t\t\tresult.WriteString(\"\\033[3m\")\n\t\t\t\titalic = true\n\t\t\t} else {\n\t\t\t\tresult.WriteString(\"\\033[23m\")\n\t\t\t\titalic = false\n\t\t\t}\n\t\tcase '*':\n\t\t\tif !bold {\n\t\t\t\tresult.WriteString(\"\\033[1m\")\n\t\t\t\tbold = true\n\t\t\t} else {\n\t\t\t\tresult.WriteString(\"\\033[22m\")\n\t\t\t\tbold = false\n\t\t\t}\n\t\tcase '`':\n\t\t\tif !codeblock {\n\t\t\t\tresult.WriteString(\"\\033[0;37;40m\")\n\t\t\t\tresult.WriteString(\" \")\n\t\t\t\tcodeblock = true\n\t\t\t} else {\n\t\t\t\tresult.WriteString(\" \")\n\t\t\t\tresult.WriteString(\"\\033[0m\")\n\t\t\t\tcodeblock = false\n\n\t\t\t\tif bold {\n\t\t\t\t\tresult.WriteString(\"\\033[1m\")\n\t\t\t\t}\n\t\t\t\tif italic {\n\t\t\t\t\tresult.WriteString(\"\\033[3m\")\n\t\t\t\t}\n\t\t\t}\n\t\tdefault:\n\t\t\tresult.WriteRune(char)\n\t\t}\n\t}\n\n\t// Reset any open formatting\n\tresult.WriteString(\"\\033[0m\")\n\n\treturn result.String()\n}\n"
        },
        {
          "name": "field_select.go",
          "type": "blob",
          "size": 19.275390625,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/spinner\"\n\t\"github.com/charmbracelet/bubbles/textinput\"\n\t\"github.com/charmbracelet/bubbles/viewport\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/accessibility\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\nconst (\n\tminHeight     = 1\n\tdefaultHeight = 10\n)\n\n// Select is a select field.\n//\n// A select field is a field that allows the user to select from a list of\n// options. The options can be provided statically or dynamically using Options\n// or OptionsFunc. The options can be filtered using \"/\" and navigation is done\n// using j/k, up/down, or ctrl+n/ctrl+p keys.\ntype Select[T comparable] struct {\n\tid       int\n\taccessor Accessor[T]\n\tkey      string\n\n\tviewport viewport.Model\n\n\ttitle           Eval[string]\n\tdescription     Eval[string]\n\toptions         Eval[[]Option[T]]\n\tfilteredOptions []Option[T]\n\n\tvalidate func(T) error\n\terr      error\n\n\tselected  int\n\tfocused   bool\n\tfiltering bool\n\tfilter    textinput.Model\n\tspinner   spinner.Model\n\n\tinline     bool\n\twidth      int\n\theight     int\n\taccessible bool\n\ttheme      *Theme\n\tkeymap     SelectKeyMap\n}\n\n// NewSelect creates a new select field.\n//\n// A select field is a field that allows the user to select from a list of\n// options. The options can be provided statically or dynamically using Options\n// or OptionsFunc. The options can be filtered using \"/\" and navigation is done\n// using j/k, up/down, or ctrl+n/ctrl+p keys.\nfunc NewSelect[T comparable]() *Select[T] {\n\tfilter := textinput.New()\n\tfilter.Prompt = \"/\"\n\n\ts := spinner.New(spinner.WithSpinner(spinner.Line))\n\n\treturn &Select[T]{\n\t\taccessor:    &EmbeddedAccessor[T]{},\n\t\tvalidate:    func(T) error { return nil },\n\t\tfiltering:   false,\n\t\tfilter:      filter,\n\t\toptions:     Eval[[]Option[T]]{cache: make(map[uint64][]Option[T])},\n\t\ttitle:       Eval[string]{cache: make(map[uint64]string)},\n\t\tdescription: Eval[string]{cache: make(map[uint64]string)},\n\t\tspinner:     s,\n\t}\n}\n\n// Value sets the value of the select field.\nfunc (s *Select[T]) Value(value *T) *Select[T] {\n\treturn s.Accessor(NewPointerAccessor(value))\n}\n\n// Accessor sets the accessor of the select field.\nfunc (s *Select[T]) Accessor(accessor Accessor[T]) *Select[T] {\n\ts.accessor = accessor\n\ts.selectValue(s.accessor.Get())\n\ts.updateValue()\n\treturn s\n}\n\nfunc (s *Select[T]) selectValue(value T) {\n\tfor i, o := range s.options.val {\n\t\tif o.Value == value {\n\t\t\ts.selected = i\n\t\t\tbreak\n\t\t}\n\t}\n}\n\n// Key sets the key of the select field which can be used to retrieve the value\n// after submission.\nfunc (s *Select[T]) Key(key string) *Select[T] {\n\ts.key = key\n\treturn s\n}\n\n// Title sets the title of the select field.\n//\n// This title will be static, for dynamic titles use `TitleFunc`.\nfunc (s *Select[T]) Title(title string) *Select[T] {\n\ts.title.val = title\n\ts.title.fn = nil\n\treturn s\n}\n\n// TitleFunc sets the title func of the select field.\n//\n// This TitleFunc will be re-evaluated when the binding of the TitleFunc\n// changes. This when you want to display dynamic content and update the title\n// when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (s *Select[T]) TitleFunc(f func() string, bindings any) *Select[T] {\n\ts.title.fn = f\n\ts.title.bindings = bindings\n\treturn s\n}\n\n// Filtering sets the filtering state of the select field.\nfunc (s *Select[T]) Filtering(filtering bool) *Select[T] {\n\ts.filtering = filtering\n\ts.filter.Focus()\n\treturn s\n}\n\n// Description sets the description of the select field.\n//\n// This description will be static, for dynamic descriptions use `DescriptionFunc`.\nfunc (s *Select[T]) Description(description string) *Select[T] {\n\ts.description.val = description\n\treturn s\n}\n\n// DescriptionFunc sets the description func of the select field.\n//\n// This DescriptionFunc will be re-evaluated when the binding of the\n// DescriptionFunc changes. This is useful when you want to display dynamic\n// content and update the description when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (s *Select[T]) DescriptionFunc(f func() string, bindings any) *Select[T] {\n\ts.description.fn = f\n\ts.description.bindings = bindings\n\treturn s\n}\n\n// Options sets the options of the select field.\n//\n// This is what your user will select from.\n//\n// Title\n// Description\n//\n//\t-> Option 1\n//\t   Option 2\n//\t   Option 3\n//\n// These options will be static, for dynamic options use `OptionsFunc`.\nfunc (s *Select[T]) Options(options ...Option[T]) *Select[T] {\n\tif len(options) <= 0 {\n\t\treturn s\n\t}\n\ts.options.val = options\n\ts.filteredOptions = options\n\n\t// Set the cursor to the existing value or the last selected option.\n\tfor i, option := range options {\n\t\tif option.Value == s.accessor.Get() {\n\t\t\ts.selected = i\n\t\t\tbreak\n\t\t} else if option.selected {\n\t\t\ts.selected = i\n\t\t}\n\t}\n\n\ts.updateViewportHeight()\n\ts.updateValue()\n\n\treturn s\n}\n\n// OptionsFunc sets the options func of the select field.\n//\n// This OptionsFunc will be re-evaluated when the binding of the OptionsFunc\n// changes. This is useful when you want to display dynamic content and update\n// the options when another part of your form changes.\n//\n// For example, changing the state / provinces, based on the selected country.\n//\n//\t   huh.NewSelect[string]().\n//\t\t    Options(huh.NewOptions(\"United States\", \"Canada\", \"Mexico\")...).\n//\t\t    Value(&country).\n//\t\t    Title(\"Country\").\n//\t\t    Height(5),\n//\n//\t\thuh.NewSelect[string]().\n//\t\t  Title(\"State / Province\"). // This can also be made dynamic with `TitleFunc`.\n//\t\t  OptionsFunc(func() []huh.Option[string] {\n//\t\t    s := states[country]\n//\t\t    time.Sleep(1000 * time.Millisecond)\n//\t\t    return huh.NewOptions(s...)\n//\t\t}, &country),\n//\n// See examples/dynamic/dynamic-country/main.go for the full example.\nfunc (s *Select[T]) OptionsFunc(f func() []Option[T], bindings any) *Select[T] {\n\ts.options.fn = f\n\ts.options.bindings = bindings\n\t// If there is no height set, we should attach a static height since these\n\t// options are possibly dynamic.\n\tif s.height <= 0 {\n\t\ts.height = defaultHeight\n\t\ts.updateViewportHeight()\n\t}\n\treturn s\n}\n\n// Inline sets whether the select input should be inline.\nfunc (s *Select[T]) Inline(v bool) *Select[T] {\n\ts.inline = v\n\tif v {\n\t\ts.Height(1)\n\t}\n\ts.keymap.Left.SetEnabled(v)\n\ts.keymap.Right.SetEnabled(v)\n\ts.keymap.Up.SetEnabled(!v)\n\ts.keymap.Down.SetEnabled(!v)\n\treturn s\n}\n\n// Height sets the height of the select field. If the number of options exceeds\n// the height, the select field will become scrollable.\nfunc (s *Select[T]) Height(height int) *Select[T] {\n\ts.height = height\n\ts.updateViewportHeight()\n\treturn s\n}\n\n// Validate sets the validation function of the select field.\nfunc (s *Select[T]) Validate(validate func(T) error) *Select[T] {\n\ts.validate = validate\n\treturn s\n}\n\n// Error returns the error of the select field.\nfunc (s *Select[T]) Error() error { return s.err }\n\n// Skip returns whether the select should be skipped or should be blocking.\nfunc (*Select[T]) Skip() bool { return false }\n\n// Zoom returns whether the input should be zoomed.\nfunc (*Select[T]) Zoom() bool { return false }\n\n// Focus focuses the select field.\nfunc (s *Select[T]) Focus() tea.Cmd {\n\ts.focused = true\n\treturn nil\n}\n\n// Blur blurs the select field.\nfunc (s *Select[T]) Blur() tea.Cmd {\n\tvalue := s.accessor.Get()\n\tif s.inline {\n\t\ts.clearFilter()\n\t\ts.selectValue(value)\n\t}\n\ts.focused = false\n\ts.err = s.validate(value)\n\treturn nil\n}\n\n// KeyBinds returns the help keybindings for the select field.\nfunc (s *Select[T]) KeyBinds() []key.Binding {\n\treturn []key.Binding{\n\t\ts.keymap.Up,\n\t\ts.keymap.Down,\n\t\ts.keymap.Left,\n\t\ts.keymap.Right,\n\t\ts.keymap.Filter,\n\t\ts.keymap.SetFilter,\n\t\ts.keymap.ClearFilter,\n\t\ts.keymap.Prev,\n\t\ts.keymap.Next,\n\t\ts.keymap.Submit,\n\t}\n}\n\n// Init initializes the select field.\nfunc (s *Select[T]) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update updates the select field.\nfunc (s *Select[T]) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\ts.updateViewportHeight()\n\n\tvar cmd tea.Cmd\n\tif s.filtering {\n\t\ts.filter, cmd = s.filter.Update(msg)\n\n\t\t// Keep the selected item in view.\n\t\tif s.selected < s.viewport.YOffset || s.selected >= s.viewport.YOffset+s.viewport.Height {\n\t\t\ts.viewport.SetYOffset(s.selected)\n\t\t}\n\t}\n\n\tswitch msg := msg.(type) {\n\tcase updateFieldMsg:\n\t\tvar cmds []tea.Cmd\n\t\tif ok, hash := s.title.shouldUpdate(); ok {\n\t\t\ts.title.bindingsHash = hash\n\t\t\tif !s.title.loadFromCache() {\n\t\t\t\ts.title.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateTitleMsg{id: s.id, title: s.title.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := s.description.shouldUpdate(); ok {\n\t\t\ts.description.bindingsHash = hash\n\t\t\tif !s.description.loadFromCache() {\n\t\t\t\ts.description.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateDescriptionMsg{id: s.id, description: s.description.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := s.options.shouldUpdate(); ok {\n\t\t\ts.clearFilter()\n\t\t\ts.options.bindingsHash = hash\n\t\t\tif s.options.loadFromCache() {\n\t\t\t\ts.filteredOptions = s.options.val\n\t\t\t\ts.selected = clamp(s.selected, 0, len(s.options.val)-1)\n\t\t\t} else {\n\t\t\t\ts.options.loading = true\n\t\t\t\ts.options.loadingStart = time.Now()\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateOptionsMsg[T]{id: s.id, hash: hash, options: s.options.fn()}\n\t\t\t\t}, s.spinner.Tick)\n\t\t\t}\n\t\t}\n\t\treturn s, tea.Batch(cmds...)\n\n\tcase spinner.TickMsg:\n\t\tif !s.options.loading {\n\t\t\tbreak\n\t\t}\n\t\ts.spinner, cmd = s.spinner.Update(msg)\n\t\treturn s, cmd\n\n\tcase updateTitleMsg:\n\t\tif msg.id == s.id && msg.hash == s.title.bindingsHash {\n\t\t\ts.title.update(msg.title)\n\t\t}\n\tcase updateDescriptionMsg:\n\t\tif msg.id == s.id && msg.hash == s.description.bindingsHash {\n\t\t\ts.description.update(msg.description)\n\t\t}\n\tcase updateOptionsMsg[T]:\n\t\tif msg.id == s.id && msg.hash == s.options.bindingsHash {\n\t\t\ts.options.update(msg.options)\n\n\t\t\t// since we're updating the options, we need to update the selected cursor\n\t\t\t// position and filteredOptions.\n\t\t\ts.selected = clamp(s.selected, 0, len(msg.options)-1)\n\t\t\ts.filteredOptions = msg.options\n\t\t\ts.updateValue()\n\t\t}\n\tcase tea.KeyMsg:\n\t\ts.err = nil\n\t\tswitch {\n\t\tcase key.Matches(msg, s.keymap.Filter):\n\t\t\ts.setFiltering(true)\n\t\t\treturn s, s.filter.Focus()\n\t\tcase key.Matches(msg, s.keymap.SetFilter):\n\t\t\tif len(s.filteredOptions) <= 0 {\n\t\t\t\ts.filter.SetValue(\"\")\n\t\t\t\ts.filteredOptions = s.options.val\n\t\t\t}\n\t\t\ts.setFiltering(false)\n\t\tcase key.Matches(msg, s.keymap.ClearFilter):\n\t\t\ts.clearFilter()\n\t\tcase key.Matches(msg, s.keymap.Up, s.keymap.Left):\n\t\t\t// When filtering we should ignore j/k keybindings\n\t\t\t//\n\t\t\t// XXX: Currently, the below check doesn't account for keymap\n\t\t\t// changes. When making this fix it's worth considering ignoring\n\t\t\t// whether to ignore all up/down keybindings as ignoring a-zA-Z0-9\n\t\t\t// may not be enough when international keyboards are considered.\n\t\t\tif s.filtering && (msg.String() == \"k\" || msg.String() == \"h\") {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.selected = s.selected - 1\n\t\t\tif s.selected < 0 {\n\t\t\t\ts.selected = len(s.filteredOptions) - 1\n\t\t\t\ts.viewport.GotoBottom()\n\t\t\t}\n\t\t\tif s.selected < s.viewport.YOffset {\n\t\t\t\ts.viewport.SetYOffset(s.selected)\n\t\t\t}\n\t\t\ts.updateValue()\n\t\tcase key.Matches(msg, s.keymap.GotoTop):\n\t\t\tif s.filtering {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.selected = 0\n\t\t\ts.viewport.GotoTop()\n\t\t\ts.updateValue()\n\t\tcase key.Matches(msg, s.keymap.GotoBottom):\n\t\t\tif s.filtering {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.selected = len(s.filteredOptions) - 1\n\t\t\ts.viewport.GotoBottom()\n\t\tcase key.Matches(msg, s.keymap.HalfPageUp):\n\t\t\ts.selected = max(s.selected-s.viewport.Height/2, 0)\n\t\t\ts.viewport.HalfViewUp()\n\t\t\ts.updateValue()\n\t\tcase key.Matches(msg, s.keymap.HalfPageDown):\n\t\t\ts.selected = min(s.selected+s.viewport.Height/2, len(s.filteredOptions)-1)\n\t\t\ts.viewport.HalfViewDown()\n\t\t\ts.updateValue()\n\t\tcase key.Matches(msg, s.keymap.Down, s.keymap.Right):\n\t\t\t// When filtering we should ignore j/k keybindings\n\t\t\t//\n\t\t\t// XXX: See note in the previous case match.\n\t\t\tif s.filtering && (msg.String() == \"j\" || msg.String() == \"l\") {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.selected = s.selected + 1\n\t\t\tif s.selected > len(s.filteredOptions)-1 {\n\t\t\t\ts.selected = 0\n\t\t\t\ts.viewport.GotoTop()\n\t\t\t}\n\t\t\tif s.selected >= s.viewport.YOffset+s.viewport.Height {\n\t\t\t\ts.viewport.LineDown(1)\n\t\t\t}\n\t\t\ts.updateValue()\n\t\tcase key.Matches(msg, s.keymap.Prev):\n\t\t\tif s.selected >= len(s.filteredOptions) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.updateValue()\n\t\t\ts.err = s.validate(s.accessor.Get())\n\t\t\tif s.err != nil {\n\t\t\t\treturn s, nil\n\t\t\t}\n\t\t\ts.updateValue()\n\t\t\treturn s, PrevField\n\t\tcase key.Matches(msg, s.keymap.Next, s.keymap.Submit):\n\t\t\tif s.selected >= len(s.filteredOptions) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ts.setFiltering(false)\n\t\t\ts.updateValue()\n\t\t\ts.err = s.validate(s.accessor.Get())\n\t\t\tif s.err != nil {\n\t\t\t\treturn s, nil\n\t\t\t}\n\t\t\ts.updateValue()\n\t\t\treturn s, NextField\n\t\t}\n\n\t\tif s.filtering {\n\t\t\ts.filteredOptions = s.options.val\n\t\t\tif s.filter.Value() != \"\" {\n\t\t\t\ts.filteredOptions = nil\n\t\t\t\tfor _, option := range s.options.val {\n\t\t\t\t\tif s.filterFunc(option.Key) {\n\t\t\t\t\t\ts.filteredOptions = append(s.filteredOptions, option)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(s.filteredOptions) > 0 {\n\t\t\t\ts.selected = min(s.selected, len(s.filteredOptions)-1)\n\t\t\t\ts.viewport.SetYOffset(clamp(s.selected, 0, len(s.filteredOptions)-s.viewport.Height))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn s, cmd\n}\n\nfunc (s *Select[T]) updateValue() {\n\tif s.selected < len(s.filteredOptions) && s.selected >= 0 {\n\t\ts.accessor.Set(s.filteredOptions[s.selected].Value)\n\t}\n}\n\n// updateViewportHeight updates the viewport size according to the Height setting\n// on this select field.\nfunc (s *Select[T]) updateViewportHeight() {\n\t// If no height is set size the viewport to the number of options.\n\tif s.height <= 0 {\n\t\ts.viewport.Height = len(s.options.val)\n\t\treturn\n\t}\n\n\ts.viewport.Height = max(minHeight, s.height-\n\t\tlipgloss.Height(s.titleView())-\n\t\tlipgloss.Height(s.descriptionView()))\n}\n\nfunc (s *Select[T]) activeStyles() *FieldStyles {\n\ttheme := s.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif s.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\nfunc (s *Select[T]) titleView() string {\n\tvar (\n\t\tstyles = s.activeStyles()\n\t\tsb     = strings.Builder{}\n\t)\n\tif s.filtering {\n\t\tsb.WriteString(s.filter.View())\n\t} else if s.filter.Value() != \"\" && !s.inline {\n\t\tsb.WriteString(styles.Title.Render(s.title.val) + styles.Description.Render(\"/\"+s.filter.Value()))\n\t} else {\n\t\tsb.WriteString(styles.Title.Render(s.title.val))\n\t}\n\tif s.err != nil {\n\t\tsb.WriteString(styles.ErrorIndicator.String())\n\t}\n\treturn sb.String()\n}\n\nfunc (s *Select[T]) descriptionView() string {\n\treturn s.activeStyles().Description.Render(s.description.val)\n}\n\nfunc (s *Select[T]) optionsView() string {\n\tvar (\n\t\tstyles = s.activeStyles()\n\t\tc      = styles.SelectSelector.String()\n\t\tsb     strings.Builder\n\t)\n\n\tif s.options.loading && time.Since(s.options.loadingStart) > spinnerShowThreshold {\n\t\ts.spinner.Style = s.activeStyles().MultiSelectSelector.UnsetString()\n\t\tsb.WriteString(s.spinner.View() + \" Loading...\")\n\t\treturn sb.String()\n\t}\n\n\tif s.inline {\n\t\tsb.WriteString(styles.PrevIndicator.Faint(s.selected <= 0).String())\n\t\tif len(s.filteredOptions) > 0 {\n\t\t\tsb.WriteString(styles.SelectedOption.Render(s.filteredOptions[s.selected].Key))\n\t\t} else {\n\t\t\tsb.WriteString(styles.TextInput.Placeholder.Render(\"No matches\"))\n\t\t}\n\t\tsb.WriteString(styles.NextIndicator.Faint(s.selected == len(s.filteredOptions)-1).String())\n\t\treturn sb.String()\n\t}\n\n\tfor i, option := range s.filteredOptions {\n\t\tif s.selected == i {\n\t\t\tsb.WriteString(c + styles.SelectedOption.Render(option.Key))\n\t\t} else {\n\t\t\tsb.WriteString(strings.Repeat(\" \", lipgloss.Width(c)) + styles.UnselectedOption.Render(option.Key))\n\t\t}\n\t\tif i < len(s.options.val)-1 {\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\tfor i := len(s.filteredOptions); i < len(s.options.val)-1; i++ {\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\treturn sb.String()\n}\n\n// View renders the select field.\nfunc (s *Select[T]) View() string {\n\tstyles := s.activeStyles()\n\ts.viewport.SetContent(s.optionsView())\n\n\tvar sb strings.Builder\n\tif s.title.val != \"\" || s.title.fn != nil {\n\t\tsb.WriteString(s.titleView())\n\t\tif !s.inline {\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\tif s.description.val != \"\" || s.description.fn != nil {\n\t\tsb.WriteString(s.descriptionView())\n\t\tif !s.inline {\n\t\t\tsb.WriteString(\"\\n\")\n\t\t}\n\t}\n\tsb.WriteString(s.viewport.View())\n\treturn styles.Base.Render(sb.String())\n}\n\n// clearFilter clears the value of the filter.\nfunc (s *Select[T]) clearFilter() {\n\ts.filter.SetValue(\"\")\n\ts.filteredOptions = s.options.val\n\ts.setFiltering(false)\n}\n\n// setFiltering sets the filter of the select field.\nfunc (s *Select[T]) setFiltering(filtering bool) {\n\tif s.inline && filtering {\n\t\ts.filter.Width = lipgloss.Width(s.titleView()) - 1 - 1\n\t}\n\ts.filtering = filtering\n\ts.keymap.SetFilter.SetEnabled(filtering)\n\ts.keymap.Filter.SetEnabled(!filtering)\n\ts.keymap.ClearFilter.SetEnabled(!filtering && s.filter.Value() != \"\")\n}\n\n// filterFunc returns true if the option matches the filter.\nfunc (s *Select[T]) filterFunc(option string) bool {\n\t// XXX: remove diacritics or allow customization of filter function.\n\treturn strings.Contains(strings.ToLower(option), strings.ToLower(s.filter.Value()))\n}\n\n// Run runs the select field.\nfunc (s *Select[T]) Run() error {\n\tif s.accessible {\n\t\treturn s.runAccessible()\n\t}\n\treturn Run(s)\n}\n\n// runAccessible runs an accessible select field.\nfunc (s *Select[T]) runAccessible() error {\n\tvar sb strings.Builder\n\tstyles := s.activeStyles()\n\tsb.WriteString(styles.Title.Render(s.title.val) + \"\\n\")\n\n\tfor i, option := range s.options.val {\n\t\tsb.WriteString(fmt.Sprintf(\"%d. %s\", i+1, option.Key))\n\t\tsb.WriteString(\"\\n\")\n\t}\n\n\tfmt.Println(sb.String())\n\n\tfor {\n\t\tchoice := accessibility.PromptInt(\"Choose: \", 1, len(s.options.val))\n\t\toption := s.options.val[choice-1]\n\t\tif err := s.validate(option.Value); err != nil {\n\t\t\tfmt.Println(err.Error())\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(styles.SelectedOption.Render(\"Chose: \" + option.Key + \"\\n\"))\n\t\ts.accessor.Set(option.Value)\n\t\tbreak\n\t}\n\n\treturn nil\n}\n\n// WithTheme sets the theme of the select field.\nfunc (s *Select[T]) WithTheme(theme *Theme) Field {\n\tif s.theme != nil {\n\t\treturn s\n\t}\n\ts.theme = theme\n\ts.filter.Cursor.Style = theme.Focused.TextInput.Cursor\n\ts.filter.Cursor.TextStyle = theme.Focused.TextInput.CursorText\n\ts.filter.PromptStyle = theme.Focused.TextInput.Prompt\n\ts.filter.TextStyle = theme.Focused.TextInput.Text\n\ts.filter.PlaceholderStyle = theme.Focused.TextInput.Placeholder\n\ts.updateViewportHeight()\n\treturn s\n}\n\n// WithKeyMap sets the keymap on a select field.\nfunc (s *Select[T]) WithKeyMap(k *KeyMap) Field {\n\ts.keymap = k.Select\n\ts.keymap.Left.SetEnabled(s.inline)\n\ts.keymap.Right.SetEnabled(s.inline)\n\ts.keymap.Up.SetEnabled(!s.inline)\n\ts.keymap.Down.SetEnabled(!s.inline)\n\treturn s\n}\n\n// WithAccessible sets the accessible mode of the select field.\nfunc (s *Select[T]) WithAccessible(accessible bool) Field {\n\ts.accessible = accessible\n\treturn s\n}\n\n// WithWidth sets the width of the select field.\nfunc (s *Select[T]) WithWidth(width int) Field {\n\ts.width = width\n\treturn s\n}\n\n// WithHeight sets the height of the select field.\nfunc (s *Select[T]) WithHeight(height int) Field {\n\treturn s.Height(height)\n}\n\n// WithPosition sets the position of the select field.\nfunc (s *Select[T]) WithPosition(p FieldPosition) Field {\n\tif s.filtering {\n\t\treturn s\n\t}\n\ts.keymap.Prev.SetEnabled(!p.IsFirst())\n\ts.keymap.Next.SetEnabled(!p.IsLast())\n\ts.keymap.Submit.SetEnabled(p.IsLast())\n\treturn s\n}\n\n// GetKey returns the key of the field.\nfunc (s *Select[T]) GetKey() string { return s.key }\n\n// GetValue returns the value of the field.\nfunc (s *Select[T]) GetValue() any {\n\treturn s.accessor.Get()\n}\n"
        },
        {
          "name": "field_text.go",
          "type": "blob",
          "size": 12.658203125,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strings\"\n\n\t\"github.com/charmbracelet/bubbles/key\"\n\t\"github.com/charmbracelet/bubbles/textarea\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/accessibility\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// Text is a text field.\n//\n// A text box is responsible for getting multi-line input from the user. Use\n// it to gather longer-form user input. The Text field can be filled with an\n// EDITOR.\ntype Text struct {\n\taccessor Accessor[string]\n\tkey      string\n\tid       int\n\n\ttitle       Eval[string]\n\tdescription Eval[string]\n\tplaceholder Eval[string]\n\n\teditorCmd       string\n\teditorArgs      []string\n\teditorExtension string\n\n\ttextarea textarea.Model\n\n\tfocused  bool\n\tvalidate func(string) error\n\terr      error\n\n\taccessible bool\n\twidth      int\n\n\ttheme  *Theme\n\tkeymap TextKeyMap\n}\n\n// NewText creates a new text field.\n//\n// A text box is responsible for getting multi-line input from the user. Use\n// it to gather longer-form user input. The Text field can be filled with an\n// EDITOR.\nfunc NewText() *Text {\n\ttext := textarea.New()\n\ttext.ShowLineNumbers = false\n\ttext.Prompt = \"\"\n\ttext.FocusedStyle.CursorLine = lipgloss.NewStyle()\n\n\teditorCmd, editorArgs := getEditor()\n\n\tt := &Text{\n\t\taccessor:        &EmbeddedAccessor[string]{},\n\t\tid:              nextID(),\n\t\ttextarea:        text,\n\t\tvalidate:        func(string) error { return nil },\n\t\teditorCmd:       editorCmd,\n\t\teditorArgs:      editorArgs,\n\t\teditorExtension: \"md\",\n\t\ttitle:           Eval[string]{cache: make(map[uint64]string)},\n\t\tdescription:     Eval[string]{cache: make(map[uint64]string)},\n\t\tplaceholder:     Eval[string]{cache: make(map[uint64]string)},\n\t}\n\n\treturn t\n}\n\n// Value sets the value of the text field.\nfunc (t *Text) Value(value *string) *Text {\n\treturn t.Accessor(NewPointerAccessor(value))\n}\n\n// Accessor sets the accessor of the text field.\nfunc (t *Text) Accessor(accessor Accessor[string]) *Text {\n\tt.accessor = accessor\n\tt.textarea.SetValue(t.accessor.Get())\n\treturn t\n}\n\n// Key sets the key of the text field.\nfunc (t *Text) Key(key string) *Text {\n\tt.key = key\n\treturn t\n}\n\n// Title sets the text field's title.\n//\n// This title will be static, for dynamic titles use `TitleFunc`.\nfunc (t *Text) Title(title string) *Text {\n\tt.title.val = title\n\tt.title.fn = nil\n\treturn t\n}\n\n// TitleFunc sets the text field's title func.\n//\n// The TitleFunc will be re-evaluated when the binding of the TitleFunc changes.\n// This is useful when you want to display dynamic content and update the title\n// when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (t *Text) TitleFunc(f func() string, bindings any) *Text {\n\tt.title.fn = f\n\tt.title.bindings = bindings\n\treturn t\n}\n\n// Description sets the description of the text field.\n//\n// This description will be static, for dynamic description use `DescriptionFunc`.\nfunc (t *Text) Description(description string) *Text {\n\tt.description.val = description\n\tt.description.fn = nil\n\treturn t\n}\n\n// DescriptionFunc sets the description func of the text field.\n//\n// The DescriptionFunc will be re-evaluated when the binding of the\n// DescriptionFunc changes. This is useful when you want to display dynamic\n// content and update the description when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (t *Text) DescriptionFunc(f func() string, bindings any) *Text {\n\tt.description.fn = f\n\tt.description.bindings = bindings\n\treturn t\n}\n\n// Lines sets the number of lines to show of the text field.\nfunc (t *Text) Lines(lines int) *Text {\n\tt.textarea.SetHeight(lines)\n\treturn t\n}\n\n// CharLimit sets the character limit of the text field.\nfunc (t *Text) CharLimit(charlimit int) *Text {\n\tt.textarea.CharLimit = charlimit\n\treturn t\n}\n\n// ShowLineNumbers sets whether or not to show line numbers.\nfunc (t *Text) ShowLineNumbers(show bool) *Text {\n\tt.textarea.ShowLineNumbers = show\n\treturn t\n}\n\n// Placeholder sets the placeholder of the text field.\n//\n// This placeholder will be static, for dynamic placeholders use `PlaceholderFunc`.\nfunc (t *Text) Placeholder(str string) *Text {\n\tt.textarea.Placeholder = str\n\treturn t\n}\n\n// PlaceholderFunc sets the placeholder func of the text field.\n//\n// The PlaceholderFunc will be re-evaluated when the binding of the\n// PlaceholderFunc changes. This is useful when you want to display dynamic\n// content and update the placeholder when another part of your form changes.\n//\n// See README#Dynamic for more usage information.\nfunc (t *Text) PlaceholderFunc(f func() string, bindings any) *Text {\n\tt.placeholder.fn = f\n\tt.placeholder.bindings = bindings\n\treturn t\n}\n\n// Validate sets the validation function of the text field.\nfunc (t *Text) Validate(validate func(string) error) *Text {\n\tt.validate = validate\n\treturn t\n}\n\nconst defaultEditor = \"nano\"\n\n// getEditor returns the editor command and arguments.\nfunc getEditor() (string, []string) {\n\teditor := strings.Fields(os.Getenv(\"EDITOR\"))\n\tif len(editor) > 0 {\n\t\treturn editor[0], editor[1:]\n\t}\n\treturn defaultEditor, nil\n}\n\n// Editor specifies which editor to use.\n//\n// The first argument provided is used as the editor command (vim, nvim, nano, etc...)\n// The following (optional) arguments provided are passed as arguments to the editor command.\nfunc (t *Text) Editor(editor ...string) *Text {\n\tif len(editor) > 0 {\n\t\tt.editorCmd = editor[0]\n\t}\n\tif len(editor) > 1 {\n\t\tt.editorArgs = editor[1:]\n\t}\n\treturn t\n}\n\n// EditorExtension specifies arguments to pass into the editor.\nfunc (t *Text) EditorExtension(extension string) *Text {\n\tt.editorExtension = extension\n\treturn t\n}\n\n// Error returns the error of the text field.\nfunc (t *Text) Error() error { return t.err }\n\n// Skip returns whether the textarea should be skipped or should be blocking.\nfunc (*Text) Skip() bool { return false }\n\n// Zoom returns whether the note should be zoomed.\nfunc (*Text) Zoom() bool { return false }\n\n// Focus focuses the text field.\nfunc (t *Text) Focus() tea.Cmd {\n\tt.focused = true\n\treturn t.textarea.Focus()\n}\n\n// Blur blurs the text field.\nfunc (t *Text) Blur() tea.Cmd {\n\tt.focused = false\n\tt.accessor.Set(t.textarea.Value())\n\tt.textarea.Blur()\n\tt.err = t.validate(t.accessor.Get())\n\treturn nil\n}\n\n// KeyBinds returns the help message for the text field.\nfunc (t *Text) KeyBinds() []key.Binding {\n\treturn []key.Binding{t.keymap.NewLine, t.keymap.Editor, t.keymap.Prev, t.keymap.Submit, t.keymap.Next}\n}\n\ntype updateValueMsg []byte\n\n// Init initializes the text field.\nfunc (t *Text) Init() tea.Cmd {\n\tt.textarea.Blur()\n\treturn nil\n}\n\n// Update updates the text field.\nfunc (t *Text) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\tvar cmd tea.Cmd\n\n\tswitch msg := msg.(type) {\n\tcase updateValueMsg:\n\t\tt.textarea.SetValue(string(msg))\n\t\tt.textarea, cmd = t.textarea.Update(msg)\n\t\tcmds = append(cmds, cmd)\n\t\tt.accessor.Set(t.textarea.Value())\n\tcase updateFieldMsg:\n\t\tvar cmds []tea.Cmd\n\t\tif ok, hash := t.placeholder.shouldUpdate(); ok {\n\t\t\tt.placeholder.bindingsHash = hash\n\t\t\tif t.placeholder.loadFromCache() {\n\t\t\t\tt.textarea.Placeholder = t.placeholder.val\n\t\t\t} else {\n\t\t\t\tt.placeholder.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updatePlaceholderMsg{id: t.id, placeholder: t.placeholder.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := t.title.shouldUpdate(); ok {\n\t\t\tt.title.bindingsHash = hash\n\t\t\tif !t.title.loadFromCache() {\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateTitleMsg{id: t.id, title: t.title.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tif ok, hash := t.description.shouldUpdate(); ok {\n\t\t\tt.description.bindingsHash = hash\n\t\t\tif !t.description.loadFromCache() {\n\t\t\t\tt.description.loading = true\n\t\t\t\tcmds = append(cmds, func() tea.Msg {\n\t\t\t\t\treturn updateDescriptionMsg{id: t.id, description: t.description.fn(), hash: hash}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\treturn t, tea.Batch(cmds...)\n\tcase updatePlaceholderMsg:\n\t\tif t.id == msg.id && t.placeholder.bindingsHash == msg.hash {\n\t\t\tt.placeholder.update(msg.placeholder)\n\t\t\tt.textarea.Placeholder = msg.placeholder\n\t\t}\n\tcase updateTitleMsg:\n\t\tif t.id == msg.id && t.title.bindingsHash == msg.hash {\n\t\t\tt.title.update(msg.title)\n\t\t}\n\tcase updateDescriptionMsg:\n\t\tif t.id == msg.id && t.description.bindingsHash == msg.hash {\n\t\t\tt.description.update(msg.description)\n\t\t}\n\tcase tea.KeyMsg:\n\t\tt.err = nil\n\n\t\tswitch {\n\t\tcase key.Matches(msg, t.keymap.Editor):\n\t\t\text := strings.TrimPrefix(t.editorExtension, \".\")\n\t\t\ttmpFile, _ := os.CreateTemp(os.TempDir(), \"*.\"+ext)\n\t\t\tcmd := exec.Command(t.editorCmd, append(t.editorArgs, tmpFile.Name())...) //nolint:gosec\n\t\t\t_ = os.WriteFile(tmpFile.Name(), []byte(t.textarea.Value()), 0o644)       //nolint:mnd,gosec\n\t\t\tcmds = append(cmds, tea.ExecProcess(cmd, func(error) tea.Msg {\n\t\t\t\tcontent, _ := os.ReadFile(tmpFile.Name())\n\t\t\t\t_ = os.Remove(tmpFile.Name())\n\t\t\t\treturn updateValueMsg(content)\n\t\t\t}))\n\t\tcase key.Matches(msg, t.keymap.Next, t.keymap.Submit):\n\t\t\tvalue := t.textarea.Value()\n\t\t\tt.err = t.validate(value)\n\t\t\tif t.err != nil {\n\t\t\t\treturn t, nil\n\t\t\t}\n\t\t\tcmds = append(cmds, NextField)\n\t\tcase key.Matches(msg, t.keymap.Prev):\n\t\t\tvalue := t.textarea.Value()\n\t\t\tt.err = t.validate(value)\n\t\t\tif t.err != nil {\n\t\t\t\treturn t, nil\n\t\t\t}\n\t\t\tcmds = append(cmds, PrevField)\n\t\t}\n\t}\n\n\tt.textarea, cmd = t.textarea.Update(msg)\n\tcmds = append(cmds, cmd)\n\tt.accessor.Set(t.textarea.Value())\n\n\treturn t, tea.Batch(cmds...)\n}\n\nfunc (t *Text) activeStyles() *FieldStyles {\n\ttheme := t.theme\n\tif theme == nil {\n\t\ttheme = ThemeCharm()\n\t}\n\tif t.focused {\n\t\treturn &theme.Focused\n\t}\n\treturn &theme.Blurred\n}\n\nfunc (t *Text) activeTextAreaStyles() *textarea.Style {\n\tif t.theme == nil {\n\t\treturn &t.textarea.BlurredStyle\n\t}\n\tif t.focused {\n\t\treturn &t.textarea.FocusedStyle\n\t}\n\treturn &t.textarea.BlurredStyle\n}\n\n// View renders the text field.\nfunc (t *Text) View() string {\n\tstyles := t.activeStyles()\n\ttextareaStyles := t.activeTextAreaStyles()\n\n\t// NB: since the method is on a pointer receiver these are being mutated.\n\t// Because this runs on every render this shouldn't matter in practice,\n\t// however.\n\ttextareaStyles.Placeholder = styles.TextInput.Placeholder\n\ttextareaStyles.Text = styles.TextInput.Text\n\ttextareaStyles.Prompt = styles.TextInput.Prompt\n\ttextareaStyles.CursorLine = styles.TextInput.Text\n\tt.textarea.Cursor.Style = styles.TextInput.Cursor\n\tt.textarea.Cursor.TextStyle = styles.TextInput.CursorText\n\n\tvar sb strings.Builder\n\tif t.title.val != \"\" || t.title.fn != nil {\n\t\tsb.WriteString(styles.Title.Render(t.title.val))\n\t\tif t.err != nil {\n\t\t\tsb.WriteString(styles.ErrorIndicator.String())\n\t\t}\n\t\tsb.WriteString(\"\\n\")\n\t}\n\tif t.description.val != \"\" || t.description.fn != nil {\n\t\tsb.WriteString(styles.Description.Render(t.description.val))\n\t\tsb.WriteString(\"\\n\")\n\t}\n\tsb.WriteString(t.textarea.View())\n\n\treturn styles.Base.Render(sb.String())\n}\n\n// Run runs the text field.\nfunc (t *Text) Run() error {\n\tif t.accessible {\n\t\treturn t.runAccessible()\n\t}\n\treturn Run(t)\n}\n\n// runAccessible runs an accessible text field.\nfunc (t *Text) runAccessible() error {\n\tstyles := t.activeStyles()\n\tfmt.Println(styles.Title.Render(t.title.val))\n\tfmt.Println()\n\tt.accessor.Set(accessibility.PromptString(\"Input: \", func(input string) error {\n\t\tif err := t.validate(input); err != nil {\n\t\t\t// Handle the error from t.validate, return it\n\t\t\treturn err\n\t\t}\n\n\t\tif len(input) > t.textarea.CharLimit {\n\t\t\treturn fmt.Errorf(\"Input cannot exceed %d characters\", t.textarea.CharLimit)\n\t\t}\n\t\treturn nil\n\t}))\n\tfmt.Println()\n\treturn nil\n}\n\n// WithTheme sets the theme on a text field.\nfunc (t *Text) WithTheme(theme *Theme) Field {\n\tif t.theme != nil {\n\t\treturn t\n\t}\n\tt.theme = theme\n\treturn t\n}\n\n// WithKeyMap sets the keymap on a text field.\nfunc (t *Text) WithKeyMap(k *KeyMap) Field {\n\tt.keymap = k.Text\n\tt.textarea.KeyMap.InsertNewline.SetKeys(t.keymap.NewLine.Keys()...)\n\treturn t\n}\n\n// WithAccessible sets the accessible mode of the text field.\nfunc (t *Text) WithAccessible(accessible bool) Field {\n\tt.accessible = accessible\n\treturn t\n}\n\n// WithWidth sets the width of the text field.\nfunc (t *Text) WithWidth(width int) Field {\n\tt.width = width\n\tt.textarea.SetWidth(width - t.activeStyles().Base.GetHorizontalFrameSize())\n\treturn t\n}\n\n// WithHeight sets the height of the text field.\nfunc (t *Text) WithHeight(height int) Field {\n\tadjust := 0\n\tif t.title.val != \"\" {\n\t\tadjust++\n\t}\n\tif t.description.val != \"\" {\n\t\tadjust++\n\t}\n\tt.textarea.SetHeight(height - t.activeStyles().Base.GetVerticalFrameSize() - adjust)\n\treturn t\n}\n\n// WithPosition sets the position information of the text field.\nfunc (t *Text) WithPosition(p FieldPosition) Field {\n\tt.keymap.Prev.SetEnabled(!p.IsFirst())\n\tt.keymap.Next.SetEnabled(!p.IsLast())\n\tt.keymap.Submit.SetEnabled(p.IsLast())\n\treturn t\n}\n\n// GetKey returns the key of the field.\nfunc (t *Text) GetKey() string { return t.key }\n\n// GetValue returns the value of the field.\nfunc (t *Text) GetValue() any {\n\treturn t.accessor.Get()\n}\n"
        },
        {
          "name": "form.go",
          "type": "blob",
          "size": 15.232421875,
          "content": "package huh\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/bubbles/help\"\n\t\"github.com/charmbracelet/bubbles/key\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/internal/selector\"\n)\n\nconst defaultWidth = 80\n\n// Internal ID management. Used during animating to ensure that frame messages\n// are received only by spinner components that sent them.\nvar (\n\tlastID int\n\tidMtx  sync.Mutex\n)\n\n// Return the next ID we should use on the Model.\nfunc nextID() int {\n\tidMtx.Lock()\n\tdefer idMtx.Unlock()\n\tlastID++\n\treturn lastID\n}\n\n// FormState represents the current state of the form.\ntype FormState int\n\nconst (\n\t// StateNormal is when the user is completing the form.\n\tStateNormal FormState = iota\n\n\t// StateCompleted is when the user has completed the form.\n\tStateCompleted\n\n\t// StateAborted is when the user has aborted the form.\n\tStateAborted\n)\n\n// ErrUserAborted is the error returned when a user exits the form before submitting.\nvar ErrUserAborted = errors.New(\"user aborted\")\n\n// ErrTimeout is the error returned when the timeout is reached.\nvar ErrTimeout = errors.New(\"timeout\")\n\n// ErrTimeoutUnsupported is the error returned when timeout is used while in accessible mode.\nvar ErrTimeoutUnsupported = errors.New(\"timeout is not supported in accessible mode\")\n\n// Form is a collection of groups that are displayed one at a time on a \"page\".\n//\n// The form can navigate between groups and is complete once all the groups are\n// complete.\ntype Form struct {\n\t// collection of groups\n\tselector *selector.Selector[*Group]\n\n\tresults map[string]any\n\n\t// callbacks\n\tSubmitCmd tea.Cmd\n\tCancelCmd tea.Cmd\n\n\tState FormState\n\n\t// whether or not to use bubble tea rendering for accessibility\n\t// purposes, if true, the form will render with basic prompting primitives\n\t// to be more accessible to screen readers.\n\taccessible bool\n\n\tquitting bool\n\taborted  bool\n\n\t// options\n\twidth      int\n\theight     int\n\tkeymap     *KeyMap\n\ttimeout    time.Duration\n\tteaOptions []tea.ProgramOption\n\n\tlayout Layout\n}\n\n// NewForm returns a form with the given groups and default themes and\n// keybindings.\n//\n// Use With* methods to customize the form with options, such as setting\n// different themes and keybindings.\nfunc NewForm(groups ...*Group) *Form {\n\tselector := selector.NewSelector(groups)\n\n\tf := &Form{\n\t\tselector: selector,\n\t\tkeymap:   NewDefaultKeyMap(),\n\t\tresults:  make(map[string]any),\n\t\tlayout:   LayoutDefault,\n\t\tteaOptions: []tea.ProgramOption{\n\t\t\ttea.WithOutput(os.Stderr),\n\t\t},\n\t}\n\n\t// NB: If dynamic forms come into play this will need to be applied when\n\t// groups and fields are added.\n\tf.WithKeyMap(f.keymap)\n\tf.WithWidth(f.width)\n\tf.WithHeight(f.height)\n\tf.UpdateFieldPositions()\n\n\tif os.Getenv(\"TERM\") == \"dumb\" {\n\t\tf.WithWidth(defaultWidth)\n\t\tf.WithAccessible(true)\n\t}\n\n\treturn f\n}\n\n// Field is a primitive of a form.\n//\n// A field represents a single input control on a form such as a text input,\n// confirm button, select option, etc...\n//\n// Each field implements the Bubble Tea Model interface.\ntype Field interface {\n\t// Bubble Tea Model\n\tInit() tea.Cmd\n\tUpdate(tea.Msg) (tea.Model, tea.Cmd)\n\tView() string\n\n\t// Bubble Tea Events\n\tBlur() tea.Cmd\n\tFocus() tea.Cmd\n\n\t// Errors and Validation\n\tError() error\n\n\t// Run runs the field individually.\n\tRun() error\n\n\t// Skip returns whether this input should be skipped or not.\n\tSkip() bool\n\n\t// Zoom returns whether this input should be zoomed or not.\n\t// Zoom allows the field to take focus of the group / form height.\n\tZoom() bool\n\n\t// KeyBinds returns help keybindings.\n\tKeyBinds() []key.Binding\n\n\t// WithTheme sets the theme on a field.\n\tWithTheme(*Theme) Field\n\n\t// WithAccessible sets whether the field should run in accessible mode.\n\tWithAccessible(bool) Field\n\n\t// WithKeyMap sets the keymap on a field.\n\tWithKeyMap(*KeyMap) Field\n\n\t// WithWidth sets the width of a field.\n\tWithWidth(int) Field\n\n\t// WithHeight sets the height of a field.\n\tWithHeight(int) Field\n\n\t// WithPosition tells the field the index of the group and position it is in.\n\tWithPosition(FieldPosition) Field\n\n\t// GetKey returns the field's key.\n\tGetKey() string\n\n\t// GetValue returns the field's value.\n\tGetValue() any\n}\n\n// FieldPosition is positional information about the given field and form.\ntype FieldPosition struct {\n\tGroup      int\n\tField      int\n\tFirstField int\n\tLastField  int\n\tGroupCount int\n\tFirstGroup int\n\tLastGroup  int\n}\n\n// IsFirst returns whether a field is the form's first field.\nfunc (p FieldPosition) IsFirst() bool {\n\treturn p.Field == p.FirstField && p.Group == p.FirstGroup\n}\n\n// IsLast returns whether a field is the form's last field.\nfunc (p FieldPosition) IsLast() bool {\n\treturn p.Field == p.LastField && p.Group == p.LastGroup\n}\n\n// nextGroupMsg is a message to move to the next group.\ntype nextGroupMsg struct{}\n\n// prevGroupMsg is a message to move to the previous group.\ntype prevGroupMsg struct{}\n\n// nextGroup is the command to move to the next group.\nfunc nextGroup() tea.Msg {\n\treturn nextGroupMsg{}\n}\n\n// prevGroup is the command to move to the previous group.\nfunc prevGroup() tea.Msg {\n\treturn prevGroupMsg{}\n}\n\n// WithAccessible sets the form to run in accessible mode to avoid redrawing the\n// views which makes it easier for screen readers to read and describe the form.\n//\n// This avoids using the Bubble Tea renderer and instead simply uses basic\n// terminal prompting to gather input which degrades the user experience but\n// provides accessibility.\nfunc (f *Form) WithAccessible(accessible bool) *Form {\n\tf.accessible = accessible\n\treturn f\n}\n\n// WithShowHelp sets whether or not the form should show help.\n//\n// This allows the form groups and field to show what keybindings are available\n// to the user.\nfunc (f *Form) WithShowHelp(v bool) *Form {\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tgroup.WithShowHelp(v)\n\t\treturn true\n\t})\n\treturn f\n}\n\n// WithShowErrors sets whether or not the form should show errors.\n//\n// This allows the form groups and fields to show errors when the Validate\n// function returns an error.\nfunc (f *Form) WithShowErrors(v bool) *Form {\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tgroup.WithShowErrors(v)\n\t\treturn true\n\t})\n\treturn f\n}\n\n// WithTheme sets the theme on a form.\n//\n// This allows all groups and fields to be themed consistently, however themes\n// can be applied to each group and field individually for more granular\n// control.\nfunc (f *Form) WithTheme(theme *Theme) *Form {\n\tif theme == nil {\n\t\treturn f\n\t}\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tgroup.WithTheme(theme)\n\t\treturn true\n\t})\n\treturn f\n}\n\n// WithKeyMap sets the keymap on a form.\n//\n// This allows customization of the form key bindings.\nfunc (f *Form) WithKeyMap(keymap *KeyMap) *Form {\n\tif keymap == nil {\n\t\treturn f\n\t}\n\tf.keymap = keymap\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tgroup.WithKeyMap(keymap)\n\t\treturn true\n\t})\n\tf.UpdateFieldPositions()\n\treturn f\n}\n\n// WithWidth sets the width of a form.\n//\n// This allows all groups and fields to be sized consistently, however width\n// can be applied to each group and field individually for more granular\n// control.\nfunc (f *Form) WithWidth(width int) *Form {\n\tif width <= 0 {\n\t\treturn f\n\t}\n\tf.width = width\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\twidth := f.layout.GroupWidth(f, group, width)\n\t\tgroup.WithWidth(width)\n\t\treturn true\n\t})\n\treturn f\n}\n\n// WithHeight sets the height of a form.\nfunc (f *Form) WithHeight(height int) *Form {\n\tif height <= 0 {\n\t\treturn f\n\t}\n\tf.height = height\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tgroup.WithHeight(height)\n\t\treturn true\n\t})\n\treturn f\n}\n\n// WithOutput sets the io.Writer to output the form.\nfunc (f *Form) WithOutput(w io.Writer) *Form {\n\tf.teaOptions = append(f.teaOptions, tea.WithOutput(w))\n\treturn f\n}\n\n// WithInput sets the io.Reader to the input form.\nfunc (f *Form) WithInput(r io.Reader) *Form {\n\tf.teaOptions = append(f.teaOptions, tea.WithInput(r))\n\treturn f\n}\n\n// WithTimeout sets the duration for the form to be killed.\nfunc (f *Form) WithTimeout(t time.Duration) *Form {\n\tf.timeout = t\n\treturn f\n}\n\n// WithProgramOptions sets the tea options of the form.\nfunc (f *Form) WithProgramOptions(opts ...tea.ProgramOption) *Form {\n\tf.teaOptions = opts\n\treturn f\n}\n\n// WithLayout sets the layout on a form.\n//\n// This allows customization of the form group layout.\nfunc (f *Form) WithLayout(layout Layout) *Form {\n\tf.layout = layout\n\treturn f\n}\n\n// UpdateFieldPositions sets the position on all the fields.\nfunc (f *Form) UpdateFieldPositions() *Form {\n\tfirstGroup := 0\n\tlastGroup := f.selector.Total() - 1\n\n\t// determine the first non-hidden group.\n\tf.selector.Range(func(_ int, g *Group) bool {\n\t\tif !f.isGroupHidden(g) {\n\t\t\treturn false\n\t\t}\n\t\tfirstGroup++\n\t\treturn true\n\t})\n\n\t// determine the last non-hidden group.\n\tf.selector.ReverseRange(func(_ int, g *Group) bool {\n\t\tif !f.isGroupHidden(g) {\n\t\t\treturn false\n\t\t}\n\t\tlastGroup--\n\t\treturn true\n\t})\n\n\tf.selector.Range(func(g int, group *Group) bool {\n\t\t// determine the first non-skippable field.\n\t\tvar firstField int\n\t\tgroup.selector.Range(func(_ int, field Field) bool {\n\t\t\tif !field.Skip() || group.selector.Total() == 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tfirstField++\n\t\t\treturn true\n\t\t})\n\n\t\t// determine the last non-skippable field.\n\t\tvar lastField int\n\t\tgroup.selector.ReverseRange(func(i int, field Field) bool {\n\t\t\tlastField = i\n\t\t\tif !field.Skip() || group.selector.Total() == 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\n\t\tgroup.selector.Range(func(i int, field Field) bool {\n\t\t\tfield.WithPosition(FieldPosition{\n\t\t\t\tGroup:      g,\n\t\t\t\tField:      i,\n\t\t\t\tFirstField: firstField,\n\t\t\t\tLastField:  lastField,\n\t\t\t\tFirstGroup: firstGroup,\n\t\t\t\tLastGroup:  lastGroup,\n\t\t\t})\n\t\t\treturn true\n\t\t})\n\n\t\treturn true\n\t})\n\treturn f\n}\n\n// Errors returns the current groups' errors.\nfunc (f *Form) Errors() []error {\n\treturn f.selector.Selected().Errors()\n}\n\n// Help returns the current groups' help.\nfunc (f *Form) Help() help.Model {\n\treturn f.selector.Selected().help\n}\n\n// KeyBinds returns the current fields' keybinds.\nfunc (f *Form) KeyBinds() []key.Binding {\n\tgroup := f.selector.Selected()\n\treturn group.selector.Selected().KeyBinds()\n}\n\n// Get returns a result from the form.\nfunc (f *Form) Get(key string) any {\n\treturn f.results[key]\n}\n\n// GetString returns a result as a string from the form.\nfunc (f *Form) GetString(key string) string {\n\tv, ok := f.results[key].(string)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn v\n}\n\n// GetInt returns a result as a int from the form.\nfunc (f *Form) GetInt(key string) int {\n\tv, ok := f.results[key].(int)\n\tif !ok {\n\t\treturn 0\n\t}\n\treturn v\n}\n\n// GetBool returns a result as a string from the form.\nfunc (f *Form) GetBool(key string) bool {\n\tv, ok := f.results[key].(bool)\n\tif !ok {\n\t\treturn false\n\t}\n\treturn v\n}\n\n// NextGroup moves the form to the next group.\nfunc (f *Form) NextGroup() tea.Cmd {\n\t_, cmd := f.Update(nextGroup())\n\treturn cmd\n}\n\n// PrevGroup moves the form to the next group.\nfunc (f *Form) PrevGroup() tea.Cmd {\n\t_, cmd := f.Update(prevGroup())\n\treturn cmd\n}\n\n// NextField moves the form to the next field.\nfunc (f *Form) NextField() tea.Cmd {\n\t_, cmd := f.Update(NextField())\n\treturn cmd\n}\n\n// NextField moves the form to the next field.\nfunc (f *Form) PrevField() tea.Cmd {\n\t_, cmd := f.Update(PrevField())\n\treturn cmd\n}\n\n// Init initializes the form.\nfunc (f *Form) Init() tea.Cmd {\n\tcmds := make([]tea.Cmd, f.selector.Total())\n\tf.selector.Range(func(i int, group *Group) bool {\n\t\tif i == 0 {\n\t\t\tgroup.active = true\n\t\t}\n\t\tcmds[i] = group.Init()\n\t\treturn true\n\t})\n\n\tif f.isGroupHidden(f.selector.Selected()) {\n\t\tcmds = append(cmds, nextGroup)\n\t}\n\n\treturn tea.Batch(cmds...)\n}\n\n// Update updates the form.\nfunc (f *Form) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\t// If the form is aborted or completed there's no need to update it.\n\tif f.State != StateNormal {\n\t\treturn f, nil\n\t}\n\n\tgroup := f.selector.Selected()\n\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\tif f.width > 0 {\n\t\t\tbreak\n\t\t}\n\t\tf.selector.Range(func(_ int, group *Group) bool {\n\t\t\twidth := f.layout.GroupWidth(f, group, msg.Width)\n\t\t\tgroup.WithWidth(width)\n\t\t\treturn true\n\t\t})\n\t\tif f.height > 0 {\n\t\t\tbreak\n\t\t}\n\t\tf.selector.Range(func(_ int, group *Group) bool {\n\t\t\tif group.fullHeight() > msg.Height {\n\t\t\t\tgroup.WithHeight(msg.Height)\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\tcase tea.KeyMsg:\n\t\tswitch {\n\t\tcase key.Matches(msg, f.keymap.Quit):\n\t\t\tf.aborted = true\n\t\t\tf.quitting = true\n\t\t\tf.State = StateAborted\n\t\t\treturn f, f.CancelCmd\n\t\t}\n\n\tcase nextFieldMsg:\n\t\t// Form is progressing to the next field, let's save the value of the current field.\n\t\tfield := group.selector.Selected()\n\t\tf.results[field.GetKey()] = field.GetValue()\n\n\tcase nextGroupMsg:\n\t\tif len(group.Errors()) > 0 {\n\t\t\treturn f, nil\n\t\t}\n\n\t\tsubmit := func() (tea.Model, tea.Cmd) {\n\t\t\tf.quitting = true\n\t\t\tf.State = StateCompleted\n\t\t\treturn f, f.SubmitCmd\n\t\t}\n\n\t\tif f.selector.OnLast() {\n\t\t\treturn submit()\n\t\t}\n\n\t\tfor i := f.selector.Index() + 1; i < f.selector.Total(); i++ {\n\t\t\tif !f.isGroupHidden(f.selector.Get(i)) {\n\t\t\t\tf.selector.SetIndex(i)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// all subsequent groups are hidden, so we must act as\n\t\t\t// if we were in the last one.\n\t\t\tif i == f.selector.Total()-1 {\n\t\t\t\treturn submit()\n\t\t\t}\n\t\t}\n\t\tf.selector.Selected().active = true\n\t\treturn f, f.selector.Selected().Init()\n\n\tcase prevGroupMsg:\n\t\tif len(group.Errors()) > 0 {\n\t\t\treturn f, nil\n\t\t}\n\n\t\tfor i := f.selector.Index() - 1; i >= 0; i-- {\n\t\t\tif !f.isGroupHidden(f.selector.Get(i)) {\n\t\t\t\tf.selector.SetIndex(i)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tf.selector.Selected().active = true\n\t\treturn f, f.selector.Selected().Init()\n\t}\n\n\tm, cmd := group.Update(msg)\n\tf.selector.Set(f.selector.Index(), m.(*Group))\n\n\t// A user input a key, this could hide or show other groups,\n\t// let's update all of their positions.\n\tswitch msg.(type) {\n\tcase tea.KeyMsg:\n\t\tf.UpdateFieldPositions()\n\t}\n\n\treturn f, cmd\n}\n\nfunc (f *Form) isGroupHidden(group *Group) bool {\n\thide := group.hide\n\tif hide == nil {\n\t\treturn false\n\t}\n\treturn hide()\n}\n\n// View renders the form.\nfunc (f *Form) View() string {\n\tif f.quitting {\n\t\treturn \"\"\n\t}\n\n\treturn f.layout.View(f)\n}\n\n// Run runs the form.\nfunc (f *Form) Run() error {\n\treturn f.RunWithContext(context.Background())\n}\n\n// RunWithContext runs the form with the given context.\nfunc (f *Form) RunWithContext(ctx context.Context) error {\n\tf.SubmitCmd = tea.Quit\n\tf.CancelCmd = tea.Interrupt\n\n\tif f.selector.Total() == 0 {\n\t\treturn nil\n\t}\n\n\tif f.accessible {\n\t\treturn f.runAccessible()\n\t}\n\n\treturn f.run(ctx)\n}\n\n// run runs the form in normal mode.\nfunc (f *Form) run(ctx context.Context) error {\n\tif f.timeout > 0 {\n\t\tctx, cancel := context.WithTimeout(ctx, f.timeout)\n\t\tdefer cancel()\n\t\tf.teaOptions = append(f.teaOptions, tea.WithContext(ctx), tea.WithReportFocus())\n\t} else {\n\t\tf.teaOptions = append(f.teaOptions, tea.WithContext(ctx), tea.WithReportFocus())\n\t}\n\n\tm, err := tea.NewProgram(f, f.teaOptions...).Run()\n\tif m.(*Form).aborted || errors.Is(err, tea.ErrInterrupted) {\n\t\treturn ErrUserAborted\n\t}\n\tif errors.Is(err, tea.ErrProgramKilled) {\n\t\treturn ErrTimeout\n\t}\n\tif err != nil {\n\t\treturn fmt.Errorf(\"huh: %w\", err)\n\t}\n\treturn nil\n}\n\n// runAccessible runs the form in accessible mode.\nfunc (f *Form) runAccessible() error {\n\t// Timeouts are not supported in this mode.\n\tif f.timeout > 0 {\n\t\treturn ErrTimeoutUnsupported\n\t}\n\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tgroup.selector.Range(func(_ int, field Field) bool {\n\t\t\tfield.Init()\n\t\t\tfield.Focus()\n\t\t\t_ = field.WithAccessible(true).Run()\n\t\t\treturn true\n\t\t})\n\t\treturn true\n\t})\n\n\treturn nil\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 1.2421875,
          "content": "module github.com/charmbracelet/huh\n\ngo 1.21\n\nrequire (\n\tgithub.com/catppuccin/go v0.2.0\n\tgithub.com/charmbracelet/bubbles v0.20.0\n\tgithub.com/charmbracelet/bubbletea v1.2.5-0.20241205214244-9306010a31ee\n\tgithub.com/charmbracelet/lipgloss v1.0.0\n\tgithub.com/charmbracelet/x/ansi v0.4.5\n\tgithub.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0\n\tgithub.com/mitchellh/hashstructure/v2 v2.0.2\n)\n\nrequire (\n\tgithub.com/atotto/clipboard v0.1.4 // indirect\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/charmbracelet/x/term v0.2.1 // indirect\n\tgithub.com/dustin/go-humanize v1.0.1 // indirect\n\tgithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-localereader v0.0.1 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.16 // indirect\n\tgithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/muesli/termenv v0.15.3-0.20240618155329-98d742f6907a // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgolang.org/x/sync v0.10.0 // indirect\n\tgolang.org/x/sys v0.28.0 // indirect\n\tgolang.org/x/text v0.18.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.6787109375,
          "content": "github.com/MakeNowJust/heredoc v1.0.0 h1:cXCdzVdstXyiTqTvfqk9SDHpKNjxuom+DOlyEeQ4pzQ=\ngithub.com/MakeNowJust/heredoc v1.0.0/go.mod h1:mG5amYoWBHf8vpLOuehzbGGw0EHxpZZ6lCpQ4fNJ8LE=\ngithub.com/atotto/clipboard v0.1.4 h1:EH0zSVneZPSuFR11BlR9YppQTVDbh5+16AmcJi4g1z4=\ngithub.com/atotto/clipboard v0.1.4/go.mod h1:ZY9tmq7sm5xIbd9bOK4onWV4S6X0u6GY7Vn0Yu86PYI=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/catppuccin/go v0.2.0 h1:ktBeIrIP42b/8FGiScP9sgrWOss3lw0Z5SktRoithGA=\ngithub.com/catppuccin/go v0.2.0/go.mod h1:8IHJuMGaUUjQM82qBrGNBv7LFq6JI3NnQCF6MOlZjpc=\ngithub.com/charmbracelet/bubbles v0.20.0 h1:jSZu6qD8cRQ6k9OMfR1WlM+ruM8fkPWkHvQWD9LIutE=\ngithub.com/charmbracelet/bubbles v0.20.0/go.mod h1:39slydyswPy+uVOHZ5x/GjwVAFkCsV8IIVy+4MhzwwU=\ngithub.com/charmbracelet/bubbletea v1.2.5-0.20241205214244-9306010a31ee h1:xNijbIIsd6zADvvqrQj3kfKmLqJshZpCspKAfspXkFU=\ngithub.com/charmbracelet/bubbletea v1.2.5-0.20241205214244-9306010a31ee/go.mod h1:Hbk5+oE4a7cDyjfdPi4sHZ42aGTMYcmHnVDhsRswn7A=\ngithub.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=\ngithub.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=\ngithub.com/charmbracelet/x/ansi v0.4.5 h1:LqK4vwBNaXw2AyGIICa5/29Sbdq58GbGdFngSexTdRM=\ngithub.com/charmbracelet/x/ansi v0.4.5/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=\ngithub.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0 h1:qko3AQ4gK1MTS/de7F5hPGx6/k1u0w4TeYmBFwzYVP4=\ngithub.com/charmbracelet/x/exp/strings v0.0.0-20240722160745-212f7b056ed0/go.mod h1:pBhA0ybfXv6hDjQUZ7hk1lVxBiUbupdw5R31yPUViVQ=\ngithub.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=\ngithub.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=\ngithub.com/dustin/go-humanize v1.0.1 h1:GzkhY7T5VNhEkwH0PVJgjz+fX1rhBrR7pRT3mDkpeCY=\ngithub.com/dustin/go-humanize v1.0.1/go.mod h1:Mu1zIs6XwVuF/gI1OepvI0qD18qycQx+mFykh5fBlto=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=\ngithub.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mitchellh/hashstructure/v2 v2.0.2 h1:vGKWl0YJqUNxE8d+h8f6NJLcCJrgbhC4NcD46KavDd4=\ngithub.com/mitchellh/hashstructure/v2 v2.0.2/go.mod h1:MG3aRVU/N29oo/V/IhBX8GR/zz4kQkprJgF2EVszyDE=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/muesli/termenv v0.15.3-0.20240618155329-98d742f6907a h1:2MaM6YC3mGu54x+RKAA6JiFFHlHDY1UbkxqppT7wYOg=\ngithub.com/muesli/termenv v0.15.3-0.20240618155329-98d742f6907a/go.mod h1:hxSnBBYLK21Vtq/PHd0S2FYCxBXzBua8ov5s1RobyRQ=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=\ngolang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=\n"
        },
        {
          "name": "group.go",
          "type": "blob",
          "size": 8.212890625,
          "content": "package huh\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/bubbles/help\"\n\t\"github.com/charmbracelet/bubbles/viewport\"\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/huh/internal/selector\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// Group is a collection of fields that are displayed together with a page of\n// the form. While a group is displayed the form completer can switch between\n// fields in the group.\n//\n// If any of the fields in a group have errors, the form will not be able to\n// progress to the next group.\ntype Group struct {\n\t// collection of fields\n\tselector *selector.Selector[Field]\n\n\t// information\n\ttitle       string\n\tdescription string\n\n\t// navigation\n\tviewport viewport.Model\n\n\t// help\n\tshowHelp bool\n\thelp     help.Model\n\n\t// errors\n\tshowErrors bool\n\n\t// group options\n\twidth  int\n\theight int\n\tkeymap *KeyMap\n\thide   func() bool\n\tactive bool\n}\n\n// NewGroup returns a new group with the given fields.\nfunc NewGroup(fields ...Field) *Group {\n\tselector := selector.NewSelector(fields)\n\tgroup := &Group{\n\t\tselector:   selector,\n\t\thelp:       help.New(),\n\t\tshowHelp:   true,\n\t\tshowErrors: true,\n\t\tactive:     false,\n\t}\n\n\theight := group.fullHeight()\n\tv := viewport.New(80, height) //nolint:mnd\n\tgroup.viewport = v\n\tgroup.height = height\n\n\treturn group\n}\n\n// Title sets the group's title.\nfunc (g *Group) Title(title string) *Group {\n\tg.title = title\n\treturn g\n}\n\n// Description sets the group's description.\nfunc (g *Group) Description(description string) *Group {\n\tg.description = description\n\treturn g\n}\n\n// WithShowHelp sets whether or not the group's help should be shown.\nfunc (g *Group) WithShowHelp(show bool) *Group {\n\tg.showHelp = show\n\treturn g\n}\n\n// WithShowErrors sets whether or not the group's errors should be shown.\nfunc (g *Group) WithShowErrors(show bool) *Group {\n\tg.showErrors = show\n\treturn g\n}\n\n// WithTheme sets the theme on a group.\nfunc (g *Group) WithTheme(t *Theme) *Group {\n\tg.help.Styles = t.Help\n\tg.selector.Range(func(_ int, field Field) bool {\n\t\tfield.WithTheme(t)\n\t\treturn true\n\t})\n\tif g.height <= 0 {\n\t\tg.WithHeight(g.fullHeight())\n\t}\n\treturn g\n}\n\n// WithKeyMap sets the keymap on a group.\nfunc (g *Group) WithKeyMap(k *KeyMap) *Group {\n\tg.keymap = k\n\tg.selector.Range(func(_ int, field Field) bool {\n\t\tfield.WithKeyMap(k)\n\t\treturn true\n\t})\n\treturn g\n}\n\n// WithWidth sets the width on a group.\nfunc (g *Group) WithWidth(width int) *Group {\n\tg.width = width\n\tg.viewport.Width = width\n\tg.selector.Range(func(_ int, field Field) bool {\n\t\tfield.WithWidth(width)\n\t\treturn true\n\t})\n\treturn g\n}\n\n// WithHeight sets the height on a group.\nfunc (g *Group) WithHeight(height int) *Group {\n\tg.height = height\n\tg.viewport.Height = height\n\tg.selector.Range(func(_ int, field Field) bool {\n\t\t// A field height must not exceed the form height.\n\t\tif height-1 <= lipgloss.Height(field.View()) {\n\t\t\tfield.WithHeight(height)\n\t\t}\n\t\treturn true\n\t})\n\treturn g\n}\n\n// WithHide sets whether this group should be skipped.\nfunc (g *Group) WithHide(hide bool) *Group {\n\tg.WithHideFunc(func() bool { return hide })\n\treturn g\n}\n\n// WithHideFunc sets the function that checks if this group should be skipped.\nfunc (g *Group) WithHideFunc(hideFunc func() bool) *Group {\n\tg.hide = hideFunc\n\treturn g\n}\n\n// Errors returns the groups' fields' errors.\nfunc (g *Group) Errors() []error {\n\tvar errs []error\n\tg.selector.Range(func(_ int, field Field) bool {\n\t\tif err := field.Error(); err != nil {\n\t\t\terrs = append(errs, err)\n\t\t}\n\t\treturn true\n\t})\n\treturn errs\n}\n\n// updateFieldMsg is a message to update the fields of a group that is currently\n// displayed.\n//\n// This is used to update all TitleFunc, DescriptionFunc, and ...Func update\n// methods to make all fields dynamically update based on user input.\ntype updateFieldMsg struct{}\n\n// nextFieldMsg is a message to move to the next field,\n//\n// each field controls when to send this message such that it is able to use\n// different key bindings or events to trigger group progression.\ntype nextFieldMsg struct{}\n\n// prevFieldMsg is a message to move to the previous field.\n//\n// each field controls when to send this message such that it is able to use\n// different key bindings or events to trigger group progression.\ntype prevFieldMsg struct{}\n\n// NextField is the command to move to the next field.\nfunc NextField() tea.Msg {\n\treturn nextFieldMsg{}\n}\n\n// PrevField is the command to move to the previous field.\nfunc PrevField() tea.Msg {\n\treturn prevFieldMsg{}\n}\n\n// Init initializes the group.\nfunc (g *Group) Init() tea.Cmd {\n\tvar cmds []tea.Cmd\n\n\tif g.selector.Selected().Skip() {\n\t\tif g.selector.OnLast() {\n\t\t\tcmds = append(cmds, g.prevField()...)\n\t\t} else if g.selector.OnFirst() {\n\t\t\tcmds = append(cmds, g.nextField()...)\n\t\t}\n\t\treturn tea.Batch(cmds...)\n\t}\n\n\tif g.active {\n\t\tcmd := g.selector.Selected().Focus()\n\t\tcmds = append(cmds, cmd)\n\t}\n\tg.buildView()\n\treturn tea.Batch(cmds...)\n}\n\n// nextField moves to the next field.\nfunc (g *Group) nextField() []tea.Cmd {\n\tblurCmd := g.selector.Selected().Blur()\n\tif g.selector.OnLast() {\n\t\treturn []tea.Cmd{blurCmd, nextGroup}\n\t}\n\tg.selector.Next()\n\tfor g.selector.Selected().Skip() {\n\t\tif g.selector.OnLast() {\n\t\t\treturn []tea.Cmd{blurCmd, nextGroup}\n\t\t}\n\t\tg.selector.Next()\n\t}\n\tfocusCmd := g.selector.Selected().Focus()\n\treturn []tea.Cmd{blurCmd, focusCmd}\n}\n\n// prevField moves to the previous field.\nfunc (g *Group) prevField() []tea.Cmd {\n\tblurCmd := g.selector.Selected().Blur()\n\tif g.selector.OnFirst() {\n\t\treturn []tea.Cmd{blurCmd, prevGroup}\n\t}\n\tg.selector.Prev()\n\tfor g.selector.Selected().Skip() {\n\t\tif g.selector.OnFirst() {\n\t\t\treturn []tea.Cmd{blurCmd, prevGroup}\n\t\t}\n\t\tg.selector.Prev()\n\t}\n\tfocusCmd := g.selector.Selected().Focus()\n\treturn []tea.Cmd{blurCmd, focusCmd}\n}\n\n// Update updates the group.\nfunc (g *Group) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tvar cmds []tea.Cmd\n\n\t// Update all the fields in the group.\n\tg.selector.Range(func(i int, field Field) bool {\n\t\tswitch msg := msg.(type) {\n\t\tcase tea.KeyMsg:\n\t\t\tbreak\n\t\tdefault:\n\t\t\tm, cmd := field.Update(msg)\n\t\t\tg.selector.Set(i, m.(Field))\n\t\t\tcmds = append(cmds, cmd)\n\t\t}\n\t\tif g.selector.Index() == i {\n\t\t\tm, cmd := field.Update(msg)\n\t\t\tg.selector.Set(i, m.(Field))\n\t\t\tcmds = append(cmds, cmd)\n\t\t}\n\t\tm, cmd := field.Update(updateFieldMsg{})\n\t\tg.selector.Set(i, m.(Field))\n\t\tcmds = append(cmds, cmd)\n\t\treturn true\n\t})\n\n\tswitch msg := msg.(type) {\n\tcase tea.WindowSizeMsg:\n\t\tg.WithHeight(max(g.height, min(g.fullHeight(), msg.Height-1)))\n\tcase nextFieldMsg:\n\t\tcmds = append(cmds, g.nextField()...)\n\tcase prevFieldMsg:\n\t\tcmds = append(cmds, g.prevField()...)\n\t}\n\n\tg.buildView()\n\n\treturn g, tea.Batch(cmds...)\n}\n\n// height returns the full height of the group.\nfunc (g *Group) fullHeight() int {\n\theight := g.selector.Total()\n\tg.selector.Range(func(_ int, field Field) bool {\n\t\theight += lipgloss.Height(field.View())\n\t\treturn true\n\t})\n\treturn height\n}\n\nfunc (g *Group) getContent() (int, string) {\n\tvar fields strings.Builder\n\toffset := 0\n\tgap := \"\\n\\n\"\n\n\t// if the focused field is requesting it be zoomed, only show that field.\n\tif g.selector.Selected().Zoom() {\n\t\tg.selector.Selected().WithHeight(g.height - 1)\n\t\tfields.WriteString(g.selector.Selected().View())\n\t} else {\n\t\tg.selector.Range(func(i int, field Field) bool {\n\t\t\tfields.WriteString(field.View())\n\t\t\tif i == g.selector.Index() {\n\t\t\t\toffset = lipgloss.Height(fields.String()) - lipgloss.Height(field.View())\n\t\t\t}\n\t\t\tif i < g.selector.Total()-1 {\n\t\t\t\tfields.WriteString(gap)\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t}\n\n\treturn offset, fields.String() + \"\\n\"\n}\n\nfunc (g *Group) buildView() {\n\toffset, content := g.getContent()\n\n\tg.viewport.SetContent(content)\n\tg.viewport.SetYOffset(offset)\n}\n\n// View renders the group.\nfunc (g *Group) View() string {\n\tvar view strings.Builder\n\tview.WriteString(g.viewport.View())\n\tview.WriteString(g.Footer())\n\treturn view.String()\n}\n\n// Content renders the group's content only (no footer).\nfunc (g *Group) Content() string {\n\t_, content := g.getContent()\n\treturn content\n}\n\n// Footer renders the group's footer only (no content).\nfunc (g *Group) Footer() string {\n\tvar view strings.Builder\n\tview.WriteRune('\\n')\n\terrors := g.Errors()\n\tif g.showHelp && len(errors) <= 0 {\n\t\tview.WriteString(g.help.ShortHelpView(g.selector.Selected().KeyBinds()))\n\t}\n\tif g.showErrors {\n\t\tfor _, err := range errors {\n\t\t\tview.WriteString(ThemeCharm().Focused.ErrorMessage.Render(err.Error()))\n\t\t}\n\t}\n\treturn view.String()\n}\n"
        },
        {
          "name": "huh_test.go",
          "type": "blob",
          "size": 22.1240234375,
          "content": "package huh\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/charmbracelet/x/ansi\"\n)\n\nvar pretty = lipgloss.NewStyle().\n\tWidth(60).\n\tBorder(lipgloss.NormalBorder()).\n\tMarginTop(1).\n\tPadding(1, 3, 1, 2)\n\nfunc TestForm(t *testing.T) {\n\ttype Taco struct {\n\t\tShell    string\n\t\tBase     string\n\t\tToppings []string\n\t}\n\n\ttype Order struct {\n\t\tTaco         Taco\n\t\tName         string\n\t\tInstructions string\n\t\tDiscount     bool\n\t}\n\n\tvar taco Taco\n\torder := Order{Taco: taco}\n\n\tf := NewForm(\n\t\tNewGroup(\n\t\t\tNewSelect[string]().\n\t\t\t\tOptions(NewOptions(\"Soft\", \"Hard\")...).\n\t\t\t\tTitle(\"Shell?\").\n\t\t\t\tDescription(\"Our tortillas are made fresh in-house every day.\").\n\t\t\t\tValidate(func(t string) error {\n\t\t\t\t\tif t == \"Hard\" {\n\t\t\t\t\t\treturn fmt.Errorf(\"we're out of hard shells, sorry\")\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}).\n\t\t\t\tValue(&order.Taco.Shell),\n\n\t\t\tNewSelect[string]().\n\t\t\t\tOptions(NewOptions(\"Chicken\", \"Beef\", \"Fish\", \"Beans\")...).\n\t\t\t\tValue(&order.Taco.Base).\n\t\t\t\tTitle(\"Base\"),\n\t\t),\n\n\t\t// Prompt for toppings and special instructions.\n\t\t// The customer can ask for up to 4 toppings.\n\t\tNewGroup(\n\t\t\tNewMultiSelect[string]().\n\t\t\t\tTitle(\"Toppings\").\n\t\t\t\tDescription(\"Choose up to 4.\").\n\t\t\t\tOptions(\n\t\t\t\t\tNewOption(\"Lettuce\", \"lettuce\").Selected(true),\n\t\t\t\t\tNewOption(\"Tomatoes\", \"tomatoes\").Selected(true),\n\t\t\t\t\tNewOption(\"Corn\", \"corn\"),\n\t\t\t\t\tNewOption(\"Salsa\", \"salsa\"),\n\t\t\t\t\tNewOption(\"Sour Cream\", \"sour cream\"),\n\t\t\t\t\tNewOption(\"Cheese\", \"cheese\"),\n\t\t\t\t).\n\t\t\t\tValidate(func(t []string) error {\n\t\t\t\t\tif len(t) <= 0 {\n\t\t\t\t\t\treturn fmt.Errorf(\"at least one topping is required\")\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t}).\n\t\t\t\tValue(&order.Taco.Toppings).\n\t\t\t\tFilterable(true).\n\t\t\t\tLimit(4),\n\t\t),\n\n\t\t// Gather final details for the order.\n\t\tNewGroup(\n\t\t\tNewInput().\n\t\t\t\tValue(&order.Name).\n\t\t\t\tTitle(\"What's your name?\").\n\t\t\t\tPlaceholder(\"Margaret Thatcher\").\n\t\t\t\tDescription(\"For when your order is ready.\"),\n\n\t\t\tNewText().\n\t\t\t\tValue(&order.Instructions).\n\t\t\t\tPlaceholder(\"Just put it in the mailbox please\").\n\t\t\t\tTitle(\"Special Instructions\").\n\t\t\t\tDescription(\"Anything we should know?\").\n\t\t\t\tCharLimit(400),\n\n\t\t\tNewConfirm().\n\t\t\t\tTitle(\"Would you like 15% off?\").\n\t\t\t\tValue(&order.Discount).\n\t\t\t\tAffirmative(\"Yes!\").\n\t\t\t\tNegative(\"No.\"),\n\t\t),\n\t)\n\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\t//\n\t//  ┃ Shell?\n\t//  ┃ Our tortillas are made fresh in-house every day.\n\t//  ┃ > Soft\n\t//  ┃   Hard\n\t//\n\t//    Base\n\t//    > Chicken\n\t//      Beef\n\t//      Fish\n\t//      Beans\n\t//\n\t//   ↑ up • ↓ down • / filter • enter select\n\t//\n\n\tif !strings.Contains(view, \"┃ Shell?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to contain Shell? title\")\n\t}\n\n\tif !strings.Contains(view, \"Our tortillas are made fresh in-house every day.\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to contain tortilla description\")\n\t}\n\n\tif !strings.Contains(view, \"Base\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to contain Base title\")\n\t}\n\n\t// Attempt to select hard shell and retrieve error.\n\tm, _ := f.Update(keys('j'))\n\tm, _ = m.Update(tea.KeyMsg{Type: tea.KeyTab})\n\tview = ansi.Strip(m.View())\n\n\tif !strings.Contains(view, \"* we're out of hard shells, sorry\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to show out of hard shells error\")\n\t}\n\n\tm, _ = m.Update(keys('k'))\n\n\tm, cmd := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = batchUpdate(m, cmd)\n\n\tview = ansi.Strip(m.View())\n\n\tif !strings.Contains(view, \"┃ > Chicken\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Fatal(\"Expected form to continue to base group\")\n\t}\n\n\t// batchMsg + nextGroup\n\tm, cmd = m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = batchUpdate(m, cmd)\n\tview = ansi.Strip(m.View())\n\n\t//\n\t// ┃ Toppings\n\t// ┃ Choose up to 4.\n\t// ┃ > ✓ Lettuce\n\t// ┃   ✓ Tomatoes\n\t// ┃   • Corn\n\t// ┃   • Salsa\n\t// ┃   • Sour Cream\n\t// ┃   • Cheese\n\t//\n\t//  x toggle • ↑ up • ↓ down • enter confirm • shift+tab back\n\t//\n\tif !strings.Contains(view, \"Toppings\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Fatal(\"Expected form to show toppings group\")\n\t}\n\n\tif !strings.Contains(view, \"Choose up to 4.\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to show toppings description\")\n\t}\n\n\tif !strings.Contains(view, \"> ✓ Lettuce \") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to preselect lettuce\")\n\t}\n\n\tif !strings.Contains(view, \"  ✓ Tomatoes\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to preselect tomatoes\")\n\t}\n\n\tm, _ = m.Update(keys('j'))\n\tm, _ = m.Update(keys('j'))\n\tview = ansi.Strip(m.View())\n\n\tif !strings.Contains(view, \"> • Corn\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to change selection to corn\")\n\t}\n\n\tm, _ = m.Update(keys('x'))\n\tview = ansi.Strip(m.View())\n\n\tif !strings.Contains(view, \"> ✓ Corn\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to change selection to corn\")\n\t}\n\n\tm = batchUpdate(m.Update(tea.KeyMsg{Type: tea.KeyEnter}))\n\tview = ansi.Strip(m.View())\n\n\tif !strings.Contains(view, \"What's your name?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to prompt for name\")\n\t}\n\n\tif !strings.Contains(view, \"Special Instructions\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to prompt for special instructions\")\n\t}\n\n\tif !strings.Contains(view, \"Would you like 15% off?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to prompt for discount\")\n\t}\n\n\t//\n\t// ┃ What's your name?\n\t// ┃ For when your order is ready.\n\t// ┃ > Margaret Thatcher\n\t//\n\t//    Special Instructions\n\t//    Anything we should know?\n\t//    Just put it in the mailbox please\n\t//\n\t//    Would you like 15% off?\n\t//\n\t//      Yes!     No.\n\t//\n\t//   enter next • shift+tab back\n\t//\n\tm.Update(keys('G', 'l', 'e', 'n'))\n\tview = ansi.Strip(m.View())\n\tif !strings.Contains(view, \"Glen\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected form to accept user input\")\n\t}\n\n\tif order.Taco.Shell != \"Soft\" {\n\t\tt.Error(\"Expected order shell to be Soft\")\n\t}\n\n\tif order.Taco.Base != \"Chicken\" {\n\t\tt.Error(\"Expected order shell to be Chicken\")\n\t}\n\n\tif len(order.Taco.Toppings) != 3 {\n\t\tt.Error(\"Expected order to have 3 toppings\")\n\t}\n\n\tif order.Name != \"Glen\" {\n\t\tt.Error(\"Expected order name to be Glen\")\n\t}\n\n\t// TODO: Finish and submit form.\n}\n\nfunc TestInput(t *testing.T) {\n\tfield := NewInput()\n\tf := NewForm(NewGroup(field))\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \">\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain prompt.\")\n\t}\n\n\t// Type Huh in the form.\n\tm, _ := f.Update(keys('H', 'u', 'h'))\n\tf = m.(*Form)\n\tview = ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Huh\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Huh.\")\n\t}\n\n\tif !strings.Contains(view, \"enter submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\tif field.GetValue() != \"Huh\" {\n\t\tt.Error(\"Expected field value to be Huh\")\n\t}\n}\n\nfunc TestInlineInput(t *testing.T) {\n\tfield := NewInput().\n\t\tTitle(\"Input \").\n\t\tPrompt(\": \").\n\t\tDescription(\"Description\").\n\t\tInline(true)\n\n\tf := NewForm(NewGroup(field)).WithWidth(40)\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"┃ Input Description:\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain inline input.\")\n\t}\n\n\t// Type Huh in the form.\n\tm, _ := f.Update(keys('H', 'u', 'h'))\n\tf = m.(*Form)\n\tview = ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Huh\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Huh.\")\n\t}\n\n\tif !strings.Contains(view, \"enter submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\tif !strings.Contains(view, \"┃ Input Description: Huh\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\tif field.GetValue() != \"Huh\" {\n\t\tt.Error(\"Expected field value to be Huh\")\n\t}\n}\n\nfunc TestText(t *testing.T) {\n\tfield := NewText()\n\tf := NewForm(NewGroup(field))\n\tf.Update(f.Init())\n\n\t// Type Huh in the form.\n\tm, _ := f.Update(keys('H', 'u', 'h'))\n\tf = m.(*Form)\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Huh\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Huh.\")\n\t}\n\n\tif !strings.Contains(view, \"alt+enter / ctrl+j new line • ctrl+e open editor • enter submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\tif field.GetValue() != \"Huh\" {\n\t\tt.Error(\"Expected field value to be Huh\")\n\t}\n}\n\nfunc TestConfirm(t *testing.T) {\n\tfield := NewConfirm().Title(\"Are you sure?\")\n\tf := NewForm(NewGroup(field))\n\tf.Update(f.Init())\n\n\t// Type Huh in the form.\n\tm, _ := f.Update(keys('H'))\n\tf = m.(*Form)\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Yes\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Yes.\")\n\t}\n\n\tif !strings.Contains(view, \"No\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain No.\")\n\t}\n\n\tif !strings.Contains(view, \"Are you sure?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Are you sure?.\")\n\t}\n\n\tif !strings.Contains(view, \"←/→ toggle • enter submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\tif field.GetValue() != false {\n\t\tt.Error(\"Expected field value to be false\")\n\t}\n\n\t// Toggle left\n\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyLeft})\n\n\tif field.GetValue() != true {\n\t\tt.Error(\"Expected field value to be true\")\n\t}\n\n\t// Toggle right\n\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyRight})\n\n\tif field.GetValue() != false {\n\t\tt.Error(\"Expected field value to be false\")\n\t}\n}\n\nfunc TestSelect(t *testing.T) {\n\tfield := NewSelect[string]().Options(NewOptions(\"Foo\", \"Bar\", \"Baz\")...).Title(\"Which one?\")\n\tf := NewForm(NewGroup(field))\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Foo\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Foo.\")\n\t}\n\n\tif !strings.Contains(view, \"Which one?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Which one?.\")\n\t}\n\n\tif !strings.Contains(view, \"> Foo\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Foo.\")\n\t}\n\n\t// Move selection cursor down\n\tm, _ := f.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tf = m.(*Form)\n\n\tview = ansi.Strip(f.View())\n\n\tif strings.Contains(view, \"> Foo\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Bar.\")\n\t}\n\n\tif !strings.Contains(view, \"> Bar\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Bar.\")\n\t}\n\n\tif !strings.Contains(view, \"↑ up • ↓ down • / filter • enter submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\t// Submit\n\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tf = m.(*Form)\n\n\tif field.GetValue() != \"Bar\" {\n\t\tt.Error(\"Expected field value to be Bar\")\n\t}\n}\n\nfunc TestMultiSelect(t *testing.T) {\n\tfield := NewMultiSelect[string]().Options(NewOptions(\"Foo\", \"Bar\", \"Baz\")...).Title(\"Which one?\")\n\tf := NewForm(NewGroup(field))\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Foo\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Foo.\")\n\t}\n\n\tif !strings.Contains(view, \"Which one?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain Which one?.\")\n\t}\n\n\tif !strings.Contains(view, \"> • Foo\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Foo.\")\n\t}\n\n\t// Move selection cursor down\n\tm, _ := f.Update(keys('j'))\n\tview = ansi.Strip(m.View())\n\n\tif strings.Contains(view, \"> • Foo\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Bar.\")\n\t}\n\n\tif !strings.Contains(view, \"> • Bar\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Bar.\")\n\t}\n\n\t// Toggle\n\tm, _ = f.Update(keys('x'))\n\tview = ansi.Strip(m.View())\n\n\tif !strings.Contains(view, \"> ✓ Bar\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected cursor to be on Bar.\")\n\t}\n\n\tif !strings.Contains(view, \"x toggle • ↑ up • ↓ down • / filter • enter submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n\n\t// Submit\n\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tf = m.(*Form)\n\n\tvalue := field.GetValue()\n\tif value, ok := value.([]string); !ok {\n\t\tt.Error(\"Expected field value to a slice of string\")\n\t} else {\n\t\tif len(value) != 1 {\n\t\t\tt.Error(\"Expected field value length to be 1\")\n\t\t} else {\n\t\t\tif value[0] != \"Bar\" {\n\t\t\t\tt.Error(\"Expected first field value length to be Bar\")\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestMultiSelectFiltering(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tfiltering bool\n\t}{\n\t\t{\"Filtering off\", false},\n\t\t{\"Filtering on\", true},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tfield := NewMultiSelect[string]().Options(NewOptions(\"Foo\", \"Bar\", \"Baz\")...).Title(\"Which one?\").Filterable(tc.filtering)\n\t\t\tf := NewForm(NewGroup(field))\n\t\t\tf.Update(f.Init())\n\t\t\t// Filter for values starting with a 'B' only.\n\t\t\tf.Update(keys('/'))\n\t\t\tf.Update(keys('B'))\n\n\t\t\tview := ansi.Strip(f.View())\n\t\t\t// When we're filtering, the list should change.\n\t\t\tif tc.filtering && strings.Contains(view, \"Foo\") {\n\t\t\t\tt.Log(pretty.Render(view))\n\t\t\t\tt.Error(\"Foo should not in filtered list.\")\n\t\t\t}\n\t\t\t// When we're not filtering, the list shouldn't change.\n\t\t\tif !tc.filtering && !strings.Contains(view, \"Foo\") {\n\t\t\t\tt.Log(pretty.Render(view))\n\t\t\t\tt.Error(\"Expected list to contain Foo.\")\n\t\t\t}\n\t\t})\n\t}\n\tt.Run(\"Remove filter option from help menu.\", func(t *testing.T) {\n\t\tfield := NewMultiSelect[string]().Options(NewOptions(\"Foo\", \"Bar\", \"Baz\")...).Title(\"Which one?\").Filterable(false)\n\t\tf := NewForm(NewGroup(field))\n\t\tf.Update(f.Init())\n\t\tview := ansi.Strip(f.View())\n\t\tif strings.Contains(view, \"filter\") {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Expected list to hide filtering in help menu.\")\n\t\t}\n\t})\n}\n\nfunc TestSelectPageNavigation(t *testing.T) {\n\topts := NewOptions(\n\t\t\"Qux\",\n\t\t\"Quux\",\n\t\t\"Foo\",\n\t\t\"Bar\",\n\t\t\"Baz\",\n\t\t\"Corge\",\n\t\t\"Grault\",\n\t\t\"Garply\",\n\t\t\"Waldo\",\n\t\t\"Fred\",\n\t\t\"Plugh\",\n\t\t\"Xyzzy\",\n\t\t\"Thud\",\n\t\t\"Norf\",\n\t\t\"Blip\",\n\t\t\"Flob\",\n\t\t\"Zorp\",\n\t\t\"Smurf\",\n\t\t\"Bloop\",\n\t\t\"Ping\",\n\t)\n\n\treFirst := regexp.MustCompile(`>( •)? Qux`)\n\treLast := regexp.MustCompile(`>( •)? Ping`)\n\treHalfDown := regexp.MustCompile(`>( •)? Baz`)\n\n\tfor _, field := range []Field{\n\t\tNewMultiSelect[string]().Options(opts...).Title(\"Choose\"),\n\t\tNewSelect[string]().Options(opts...).Title(\"Choose\"),\n\t} {\n\t\tf := NewForm(NewGroup(field)).WithHeight(10)\n\t\tf.Update(f.Init())\n\n\t\tview := ansi.Strip(f.View())\n\t\tif !reFirst.MatchString(view) {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Wrong item selected\")\n\t\t}\n\n\t\tm, _ := f.Update(keys('G'))\n\t\tview = ansi.Strip(m.View())\n\t\tif !reLast.MatchString(view) {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Wrong item selected\")\n\t\t}\n\n\t\tm, _ = f.Update(keys('g'))\n\t\tview = ansi.Strip(m.View())\n\t\tif !reFirst.MatchString(view) {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Wrong item selected\")\n\t\t}\n\n\t\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tview = ansi.Strip(m.View())\n\t\tif !reHalfDown.MatchString(view) {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Wrong item selected\")\n\t\t}\n\n\t\t// sends multiple to verify it stays within boundaries\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlU})\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlU})\n\t\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyCtrlU})\n\t\tview = ansi.Strip(m.View())\n\t\tif !reFirst.MatchString(view) {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Wrong item selected\")\n\t\t}\n\n\t\t// verify it stays within boundaries\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tm, _ = f.Update(tea.KeyMsg{Type: tea.KeyCtrlD})\n\t\tview = ansi.Strip(m.View())\n\t\tif !reLast.MatchString(view) {\n\t\t\tt.Log(pretty.Render(view))\n\t\t\tt.Error(\"Wrong item selected\")\n\t\t}\n\t}\n}\n\nfunc TestFile(t *testing.T) {\n\tfield := NewFilePicker().Title(\"Which file?\")\n\tcmd := field.Init()\n\tfield.Update(cmd())\n\n\tview := ansi.Strip(field.View())\n\n\tif !strings.Contains(view, \"No file selected\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected file picker to show no file selected.\")\n\t}\n\n\tif !strings.Contains(view, \"Which file?\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected file picker to show title.\")\n\t}\n}\n\nfunc TestHideGroup(t *testing.T) {\n\tf := NewForm(\n\t\tNewGroup(NewNote().Description(\"Foo\")).\n\t\t\tWithHide(true),\n\t\tNewGroup(NewNote().Description(\"Bar\")),\n\t\tNewGroup(NewNote().Description(\"Baz\")),\n\t\tNewGroup(NewNote().Description(\"Qux\")).\n\t\t\tWithHideFunc(func() bool { return false }).\n\t\t\tWithHide(true),\n\t)\n\n\tf = batchUpdate(f, f.Init()).(*Form)\n\n\tif v := f.View(); !strings.Contains(v, \"Bar\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Bar to not be hidden\")\n\t}\n\n\t// should have no effect as previous group is hidden\n\tf.Update(prevGroup())\n\n\tif v := f.View(); !strings.Contains(v, \"Bar\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Bar to not be hidden\")\n\t}\n\n\tf.Update(nextGroup())\n\n\tif v := f.View(); !strings.Contains(v, \"Baz\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Baz to not be hidden\")\n\t}\n\n\tf.Update(nextGroup())\n\n\tif v := f.View(); strings.Contains(v, \"Qux\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Qux to be hidden\")\n\t}\n\n\tif v := f.State; v != StateCompleted {\n\t\tt.Error(\"should have been completed\")\n\t}\n}\n\nfunc TestHideGroupLastAndFirstGroupsNotHidden(t *testing.T) {\n\tf := NewForm(\n\t\tNewGroup(NewNote().Description(\"Bar\")),\n\t\tNewGroup(NewNote().Description(\"Foo\")).\n\t\t\tWithHide(true),\n\t\tNewGroup(NewNote().Description(\"Baz\")),\n\t)\n\n\tf = batchUpdate(f, f.Init()).(*Form)\n\n\tif v := ansi.Strip(f.View()); !strings.Contains(v, \"Bar\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Bar to not be hidden\")\n\t}\n\n\t// should have no effect as there isn't any\n\tf.Update(prevGroup())\n\n\tif v := f.View(); !strings.Contains(v, \"Bar\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Bar to not be hidden\")\n\t}\n\n\tf.Update(nextGroup())\n\n\tif v := ansi.Strip(f.View()); !strings.Contains(v, \"Baz\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Baz to not be hidden\")\n\t}\n\n\t// should submit the form\n\tf.Update(nextGroup())\n\tif v := f.State; v != StateCompleted {\n\t\tt.Error(\"should have been completed\")\n\t}\n}\n\nfunc TestPrevGroup(t *testing.T) {\n\tf := NewForm(\n\t\tNewGroup(NewNote().Description(\"Bar\")),\n\t\tNewGroup(NewNote().Description(\"Foo\")),\n\t\tNewGroup(NewNote().Description(\"Baz\")),\n\t)\n\n\tf = batchUpdate(f, f.Init()).(*Form)\n\tf.Update(nextGroup())\n\tf.Update(nextGroup())\n\tf.Update(prevGroup())\n\tf.Update(prevGroup())\n\n\tif v := ansi.Strip(f.View()); !strings.Contains(v, \"Bar\") {\n\t\tt.Log(pretty.Render(v))\n\t\tt.Error(\"expected Bar to not be hidden\")\n\t}\n}\n\nfunc TestNote(t *testing.T) {\n\tfield := NewNote().Title(\"Taco\").Description(\"How may we take your order?\").Next(true)\n\tf := NewForm(NewGroup(field))\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Taco\") {\n\t\tt.Log(view)\n\t\tt.Error(\"Expected field to contain Taco title.\")\n\t}\n\n\tif !strings.Contains(view, \"order?\") {\n\t\tt.Log(view)\n\t\tt.Error(\"Expected field to contain Taco description.\")\n\t}\n\n\tif !strings.Contains(view, \"Next\") {\n\t\tt.Log(view)\n\t\tt.Error(\"Expected field to contain next button\")\n\t}\n\n\tif !strings.Contains(view, \"enter submit\") {\n\t\tt.Log(view)\n\t\tt.Error(\"Expected field to contain help.\")\n\t}\n}\n\nfunc TestDynamicHelp(t *testing.T) {\n\tf := NewForm(\n\t\tNewGroup(\n\t\t\tNewInput().Title(\"Dynamic Help\"),\n\t\t\tNewInput().Title(\"Dynamic Help\"),\n\t\t\tNewInput().Title(\"Dynamic Help\"),\n\t\t),\n\t)\n\tf.Update(f.Init())\n\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"Dynamic Help\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Fatal(\"Expected help to contain title.\")\n\t}\n\n\tif strings.Contains(view, \"shift+tab\") || strings.Contains(view, \"submit\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected help not to contain shift+tab or submit.\")\n\t}\n}\n\nfunc TestSkip(t *testing.T) {\n\tf := NewForm(\n\t\tNewGroup(\n\t\t\tNewInput().Title(\"First\"),\n\t\t\tNewNote().Title(\"Skipped\"),\n\t\t\tNewNote().Title(\"Skipped\"),\n\t\t\tNewInput().Title(\"Second\"),\n\t\t),\n\t).WithWidth(25)\n\n\tf = batchUpdate(f, f.Init()).(*Form)\n\tview := ansi.Strip(f.View())\n\n\tif !strings.Contains(view, \"┃ First\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected first field to be focused\")\n\t}\n\n\t// next field should skip both of the notes and proceed to the last input.\n\tf.Update(NextField())\n\tview = ansi.Strip(f.View())\n\n\tif strings.Contains(view, \"┃ First\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected first field to be blurred\")\n\t}\n\n\tif !strings.Contains(view, \"┃ Second\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected second field to be focused\")\n\t}\n\n\t// previous field should skip both of the notes and focus the first input.\n\tf.Update(PrevField())\n\tview = ansi.Strip(f.View())\n\n\tif strings.Contains(view, \"┃ Second\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected second field to be blurred\")\n\t}\n\n\tif !strings.Contains(view, \"┃ First\") {\n\t\tt.Log(pretty.Render(view))\n\t\tt.Error(\"Expected first field to be focused\")\n\t}\n}\n\nfunc TestTimeout(t *testing.T) {\n\t// This test requires a real program, so make sure it doesn't interfere with our test runner.\n\tf := formProgram()\n\n\t// Test that the form times out after 1ms and returns a timeout error.\n\terr := f.WithTimeout(1 * time.Millisecond).Run()\n\tif err == nil || !errors.Is(err, ErrTimeout) {\n\t\tt.Errorf(\"expected timeout error, got %v\", err)\n\t}\n}\n\nfunc TestAbort(t *testing.T) {\n\t// This test requires a real program, so make sure it doesn't interfere with our test runner.\n\tf := formProgram()\n\n\t// Test that the form aborts without throwing a timeout error when explicitly told to abort.\n\tctx, cancel := context.WithCancel(context.Background())\n\t// Since the context is cancelled, the program should exit immediately.\n\tcancel()\n\t// Tell the form to abort.\n\tf.Update(tea.KeyMsg{Type: tea.KeyCtrlC})\n\t// Run the program.\n\terr := f.RunWithContext(ctx)\n\tif err == nil || !errors.Is(err, ErrUserAborted) {\n\t\tt.Errorf(\"expected user aborted error, got %v\", err)\n\t}\n}\n\n// formProgram returns a new Form with a nil input and output, so it can be used as a test program.\nfunc formProgram() *Form {\n\treturn NewForm(NewGroup(NewInput().Title(\"Foo\"))).\n\t\tWithInput(nil).WithOutput(io.Discard).\n\t\tWithAccessible(false)\n}\n\nfunc batchUpdate(m tea.Model, cmd tea.Cmd) tea.Model {\n\tif cmd == nil {\n\t\treturn m\n\t}\n\tmsg := cmd()\n\tm, cmd = m.Update(msg)\n\tif cmd == nil {\n\t\treturn m\n\t}\n\tmsg = cmd()\n\tm, cmd = m.Update(msg)\n\treturn m\n}\n\nfunc keys(runes ...rune) tea.KeyMsg {\n\treturn tea.KeyMsg{\n\t\tType:  tea.KeyRunes,\n\t\tRunes: runes,\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "keymap.go",
          "type": "blob",
          "size": 8.3837890625,
          "content": "package huh\n\nimport \"github.com/charmbracelet/bubbles/key\"\n\n// KeyMap is the keybindings to navigate the form.\ntype KeyMap struct {\n\tQuit key.Binding\n\n\tConfirm     ConfirmKeyMap\n\tFilePicker  FilePickerKeyMap\n\tInput       InputKeyMap\n\tMultiSelect MultiSelectKeyMap\n\tNote        NoteKeyMap\n\tSelect      SelectKeyMap\n\tText        TextKeyMap\n}\n\n// InputKeyMap is the keybindings for input fields.\ntype InputKeyMap struct {\n\tAcceptSuggestion key.Binding\n\tNext             key.Binding\n\tPrev             key.Binding\n\tSubmit           key.Binding\n}\n\n// TextKeyMap is the keybindings for text fields.\ntype TextKeyMap struct {\n\tNext    key.Binding\n\tPrev    key.Binding\n\tNewLine key.Binding\n\tEditor  key.Binding\n\tSubmit  key.Binding\n}\n\n// SelectKeyMap is the keybindings for select fields.\ntype SelectKeyMap struct {\n\tNext         key.Binding\n\tPrev         key.Binding\n\tUp           key.Binding\n\tDown         key.Binding\n\tHalfPageUp   key.Binding\n\tHalfPageDown key.Binding\n\tGotoTop      key.Binding\n\tGotoBottom   key.Binding\n\tLeft         key.Binding\n\tRight        key.Binding\n\tFilter       key.Binding\n\tSetFilter    key.Binding\n\tClearFilter  key.Binding\n\tSubmit       key.Binding\n}\n\n// MultiSelectKeyMap is the keybindings for multi-select fields.\ntype MultiSelectKeyMap struct {\n\tNext         key.Binding\n\tPrev         key.Binding\n\tUp           key.Binding\n\tDown         key.Binding\n\tHalfPageUp   key.Binding\n\tHalfPageDown key.Binding\n\tGotoTop      key.Binding\n\tGotoBottom   key.Binding\n\tToggle       key.Binding\n\tFilter       key.Binding\n\tSetFilter    key.Binding\n\tClearFilter  key.Binding\n\tSubmit       key.Binding\n\tSelectAll    key.Binding\n\tSelectNone   key.Binding\n}\n\n// FilePickerKey is the keybindings for filepicker fields.\ntype FilePickerKeyMap struct {\n\tOpen     key.Binding\n\tClose    key.Binding\n\tGoToTop  key.Binding\n\tGoToLast key.Binding\n\tPageUp   key.Binding\n\tPageDown key.Binding\n\tBack     key.Binding\n\tSelect   key.Binding\n\tUp       key.Binding\n\tDown     key.Binding\n\tPrev     key.Binding\n\tNext     key.Binding\n\tSubmit   key.Binding\n}\n\n// NoteKeyMap is the keybindings for note fields.\ntype NoteKeyMap struct {\n\tNext   key.Binding\n\tPrev   key.Binding\n\tSubmit key.Binding\n}\n\n// ConfirmKeyMap is the keybindings for confirm fields.\ntype ConfirmKeyMap struct {\n\tNext   key.Binding\n\tPrev   key.Binding\n\tToggle key.Binding\n\tSubmit key.Binding\n\tAccept key.Binding\n\tReject key.Binding\n}\n\n// NewDefaultKeyMap returns a new default keymap.\nfunc NewDefaultKeyMap() *KeyMap {\n\treturn &KeyMap{\n\t\tQuit: key.NewBinding(key.WithKeys(\"ctrl+c\")),\n\t\tInput: InputKeyMap{\n\t\t\tAcceptSuggestion: key.NewBinding(key.WithKeys(\"ctrl+e\"), key.WithHelp(\"ctrl+e\", \"complete\")),\n\t\t\tPrev:             key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:             key.NewBinding(key.WithKeys(\"enter\", \"tab\"), key.WithHelp(\"enter\", \"next\")),\n\t\t\tSubmit:           key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t},\n\t\tFilePicker: FilePickerKeyMap{\n\t\t\tGoToTop:  key.NewBinding(key.WithKeys(\"g\"), key.WithHelp(\"g\", \"first\"), key.WithDisabled()),\n\t\t\tGoToLast: key.NewBinding(key.WithKeys(\"G\"), key.WithHelp(\"G\", \"last\"), key.WithDisabled()),\n\t\t\tPageUp:   key.NewBinding(key.WithKeys(\"K\", \"pgup\"), key.WithHelp(\"pgup\", \"page up\"), key.WithDisabled()),\n\t\t\tPageDown: key.NewBinding(key.WithKeys(\"J\", \"pgdown\"), key.WithHelp(\"pgdown\", \"page down\"), key.WithDisabled()),\n\t\t\tBack:     key.NewBinding(key.WithKeys(\"h\", \"backspace\", \"left\", \"esc\"), key.WithHelp(\"h\", \"back\"), key.WithDisabled()),\n\t\t\tSelect:   key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"select\"), key.WithDisabled()),\n\t\t\tUp:       key.NewBinding(key.WithKeys(\"up\", \"k\", \"ctrl+k\", \"ctrl+p\"), key.WithHelp(\"↑\", \"up\"), key.WithDisabled()),\n\t\t\tDown:     key.NewBinding(key.WithKeys(\"down\", \"j\", \"ctrl+j\", \"ctrl+n\"), key.WithHelp(\"↓\", \"down\"), key.WithDisabled()),\n\n\t\t\tOpen:   key.NewBinding(key.WithKeys(\"l\", \"right\", \"enter\"), key.WithHelp(\"enter\", \"open\")),\n\t\t\tClose:  key.NewBinding(key.WithKeys(\"esc\"), key.WithHelp(\"esc\", \"close\"), key.WithDisabled()),\n\t\t\tPrev:   key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:   key.NewBinding(key.WithKeys(\"tab\"), key.WithHelp(\"tab\", \"next\")),\n\t\t\tSubmit: key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t},\n\t\tText: TextKeyMap{\n\t\t\tPrev:    key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:    key.NewBinding(key.WithKeys(\"tab\", \"enter\"), key.WithHelp(\"enter\", \"next\")),\n\t\t\tSubmit:  key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t\tNewLine: key.NewBinding(key.WithKeys(\"alt+enter\", \"ctrl+j\"), key.WithHelp(\"alt+enter / ctrl+j\", \"new line\")),\n\t\t\tEditor:  key.NewBinding(key.WithKeys(\"ctrl+e\"), key.WithHelp(\"ctrl+e\", \"open editor\")),\n\t\t},\n\t\tSelect: SelectKeyMap{\n\t\t\tPrev:         key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:         key.NewBinding(key.WithKeys(\"enter\", \"tab\"), key.WithHelp(\"enter\", \"select\")),\n\t\t\tSubmit:       key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t\tUp:           key.NewBinding(key.WithKeys(\"up\", \"k\", \"ctrl+k\", \"ctrl+p\"), key.WithHelp(\"↑\", \"up\")),\n\t\t\tDown:         key.NewBinding(key.WithKeys(\"down\", \"j\", \"ctrl+j\", \"ctrl+n\"), key.WithHelp(\"↓\", \"down\")),\n\t\t\tLeft:         key.NewBinding(key.WithKeys(\"h\", \"left\"), key.WithHelp(\"←\", \"left\"), key.WithDisabled()),\n\t\t\tRight:        key.NewBinding(key.WithKeys(\"l\", \"right\"), key.WithHelp(\"→\", \"right\"), key.WithDisabled()),\n\t\t\tFilter:       key.NewBinding(key.WithKeys(\"/\"), key.WithHelp(\"/\", \"filter\")),\n\t\t\tSetFilter:    key.NewBinding(key.WithKeys(\"esc\"), key.WithHelp(\"esc\", \"set filter\"), key.WithDisabled()),\n\t\t\tClearFilter:  key.NewBinding(key.WithKeys(\"esc\"), key.WithHelp(\"esc\", \"clear filter\"), key.WithDisabled()),\n\t\t\tHalfPageUp:   key.NewBinding(key.WithKeys(\"ctrl+u\"), key.WithHelp(\"ctrl+u\", \"½ page up\")),\n\t\t\tHalfPageDown: key.NewBinding(key.WithKeys(\"ctrl+d\"), key.WithHelp(\"ctrl+d\", \"½ page down\")),\n\t\t\tGotoTop:      key.NewBinding(key.WithKeys(\"home\", \"g\"), key.WithHelp(\"g/home\", \"go to start\")),\n\t\t\tGotoBottom:   key.NewBinding(key.WithKeys(\"end\", \"G\"), key.WithHelp(\"G/end\", \"go to end\")),\n\t\t},\n\t\tMultiSelect: MultiSelectKeyMap{\n\t\t\tPrev:         key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:         key.NewBinding(key.WithKeys(\"enter\", \"tab\"), key.WithHelp(\"enter\", \"confirm\")),\n\t\t\tSubmit:       key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t\tToggle:       key.NewBinding(key.WithKeys(\" \", \"x\"), key.WithHelp(\"x\", \"toggle\")),\n\t\t\tUp:           key.NewBinding(key.WithKeys(\"up\", \"k\", \"ctrl+p\"), key.WithHelp(\"↑\", \"up\")),\n\t\t\tDown:         key.NewBinding(key.WithKeys(\"down\", \"j\", \"ctrl+n\"), key.WithHelp(\"↓\", \"down\")),\n\t\t\tFilter:       key.NewBinding(key.WithKeys(\"/\"), key.WithHelp(\"/\", \"filter\")),\n\t\t\tSetFilter:    key.NewBinding(key.WithKeys(\"enter\", \"esc\"), key.WithHelp(\"esc\", \"set filter\"), key.WithDisabled()),\n\t\t\tClearFilter:  key.NewBinding(key.WithKeys(\"esc\"), key.WithHelp(\"esc\", \"clear filter\"), key.WithDisabled()),\n\t\t\tHalfPageUp:   key.NewBinding(key.WithKeys(\"ctrl+u\"), key.WithHelp(\"ctrl+u\", \"½ page up\")),\n\t\t\tHalfPageDown: key.NewBinding(key.WithKeys(\"ctrl+d\"), key.WithHelp(\"ctrl+d\", \"½ page down\")),\n\t\t\tGotoTop:      key.NewBinding(key.WithKeys(\"home\", \"g\"), key.WithHelp(\"g/home\", \"go to start\")),\n\t\t\tGotoBottom:   key.NewBinding(key.WithKeys(\"end\", \"G\"), key.WithHelp(\"G/end\", \"go to end\")),\n\t\t\tSelectAll:    key.NewBinding(key.WithKeys(\"ctrl+a\"), key.WithHelp(\"ctrl+a\", \"select all\")),\n\t\t\tSelectNone:   key.NewBinding(key.WithKeys(\"ctrl+a\"), key.WithHelp(\"ctrl+a\", \"select none\"), key.WithDisabled()),\n\t\t},\n\t\tNote: NoteKeyMap{\n\t\t\tPrev:   key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:   key.NewBinding(key.WithKeys(\"enter\", \"tab\"), key.WithHelp(\"enter\", \"next\")),\n\t\t\tSubmit: key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t},\n\t\tConfirm: ConfirmKeyMap{\n\t\t\tPrev:   key.NewBinding(key.WithKeys(\"shift+tab\"), key.WithHelp(\"shift+tab\", \"back\")),\n\t\t\tNext:   key.NewBinding(key.WithKeys(\"enter\", \"tab\"), key.WithHelp(\"enter\", \"next\")),\n\t\t\tSubmit: key.NewBinding(key.WithKeys(\"enter\"), key.WithHelp(\"enter\", \"submit\")),\n\t\t\tToggle: key.NewBinding(key.WithKeys(\"h\", \"l\", \"right\", \"left\"), key.WithHelp(\"←/→\", \"toggle\")),\n\t\t\tAccept: key.NewBinding(key.WithKeys(\"y\", \"Y\"), key.WithHelp(\"y\", \"Yes\")),\n\t\t\tReject: key.NewBinding(key.WithKeys(\"n\", \"N\"), key.WithHelp(\"n\", \"No\")),\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "layout.go",
          "type": "blob",
          "size": 3.54296875,
          "content": "package huh\n\nimport (\n\t\"strings\"\n\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// A Layout is responsible for laying out groups in a form.\ntype Layout interface {\n\tView(f *Form) string\n\tGroupWidth(f *Form, g *Group, w int) int\n}\n\n// Default layout shows a single group at a time.\nvar LayoutDefault Layout = &layoutDefault{}\n\n// Stack layout stacks all groups on top of each other.\nvar LayoutStack Layout = &layoutStack{}\n\n// Column layout distributes groups in even columns.\nfunc LayoutColumns(columns int) Layout {\n\treturn &layoutColumns{columns: columns}\n}\n\n// Grid layout distributes groups in a grid.\nfunc LayoutGrid(rows int, columns int) Layout {\n\treturn &layoutGrid{rows: rows, columns: columns}\n}\n\ntype layoutDefault struct{}\n\nfunc (l *layoutDefault) View(f *Form) string {\n\treturn f.selector.Selected().View()\n}\n\nfunc (l *layoutDefault) GroupWidth(_ *Form, _ *Group, w int) int {\n\treturn w\n}\n\ntype layoutColumns struct {\n\tcolumns int\n}\n\nfunc (l *layoutColumns) visibleGroups(f *Form) []*Group {\n\tsegmentIndex := f.selector.Index() / l.columns\n\tstart := segmentIndex * l.columns\n\tend := start + l.columns\n\n\ttotal := f.selector.Total()\n\tif end > total {\n\t\tend = total\n\t}\n\n\tvar groups []*Group\n\tf.selector.Range(func(i int, group *Group) bool {\n\t\tif i >= start && i < end {\n\t\t\tgroups = append(groups, group)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\n\treturn groups\n}\n\nfunc (l *layoutColumns) View(f *Form) string {\n\tgroups := l.visibleGroups(f)\n\tif len(groups) == 0 {\n\t\treturn \"\"\n\t}\n\n\tcolumns := make([]string, 0, len(groups))\n\tfor _, group := range groups {\n\t\tcolumns = append(columns, group.Content())\n\t}\n\tfooter := f.selector.Selected().Footer()\n\n\treturn lipgloss.JoinVertical(lipgloss.Left,\n\t\tlipgloss.JoinHorizontal(lipgloss.Top, columns...),\n\t\tfooter,\n\t)\n}\n\nfunc (l *layoutColumns) GroupWidth(_ *Form, _ *Group, w int) int {\n\treturn w / l.columns\n}\n\ntype layoutStack struct{}\n\nfunc (l *layoutStack) View(f *Form) string {\n\tvar columns []string\n\tf.selector.Range(func(_ int, group *Group) bool {\n\t\tcolumns = append(columns, group.Content())\n\t\treturn true\n\t})\n\tfooter := f.selector.Selected().Footer()\n\n\tvar view strings.Builder\n\tview.WriteString(strings.Join(columns, \"\\n\"))\n\tview.WriteString(footer)\n\treturn view.String()\n}\n\nfunc (l *layoutStack) GroupWidth(_ *Form, _ *Group, w int) int {\n\treturn w\n}\n\ntype layoutGrid struct {\n\trows, columns int\n}\n\nfunc (l *layoutGrid) visibleGroups(f *Form) [][]*Group {\n\ttotal := l.rows * l.columns\n\tsegmentIndex := f.selector.Index() / total\n\tstart := segmentIndex * total\n\tend := start + total\n\n\tif glen := f.selector.Total(); end > glen {\n\t\tend = glen\n\t}\n\n\tvar visible []*Group\n\tf.selector.Range(func(i int, group *Group) bool {\n\t\tif i >= start && i < end {\n\t\t\tvisible = append(visible, group)\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t})\n\tgrid := make([][]*Group, l.rows)\n\tfor i := 0; i < l.rows; i++ {\n\t\tstartRow := i * l.columns\n\t\tendRow := startRow + l.columns\n\t\tif startRow >= len(visible) {\n\t\t\tbreak\n\t\t}\n\t\tif endRow > len(visible) {\n\t\t\tendRow = len(visible)\n\t\t}\n\t\tgrid[i] = visible[startRow:endRow]\n\t}\n\treturn grid\n}\n\nfunc (l *layoutGrid) View(f *Form) string {\n\tgrid := l.visibleGroups(f)\n\tif len(grid) == 0 {\n\t\treturn \"\"\n\t}\n\n\trows := make([]string, 0, len(grid))\n\tfor _, row := range grid {\n\t\tvar columns []string\n\t\tfor _, group := range row {\n\t\t\tcolumns = append(columns, group.Content())\n\t\t}\n\t\trows = append(rows, lipgloss.JoinHorizontal(lipgloss.Top, columns...))\n\t}\n\tfooter := f.selector.Selected().Footer()\n\n\treturn lipgloss.JoinVertical(lipgloss.Left, strings.Join(rows, \"\\n\"), footer)\n}\n\nfunc (l *layoutGrid) GroupWidth(_ *Form, _ *Group, w int) int {\n\treturn w / l.columns\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 0.7998046875,
          "content": "package huh\n\nimport \"fmt\"\n\n// Option is an option for select fields.\ntype Option[T comparable] struct {\n\tKey      string\n\tValue    T\n\tselected bool\n}\n\n// NewOptions returns new options from a list of values.\nfunc NewOptions[T comparable](values ...T) []Option[T] {\n\toptions := make([]Option[T], len(values))\n\tfor i, o := range values {\n\t\toptions[i] = Option[T]{\n\t\t\tKey:   fmt.Sprint(o),\n\t\t\tValue: o,\n\t\t}\n\t}\n\treturn options\n}\n\n// NewOption returns a new select option.\nfunc NewOption[T comparable](key string, value T) Option[T] {\n\treturn Option[T]{Key: key, Value: value}\n}\n\n// Selected sets whether the option is currently selected.\nfunc (o Option[T]) Selected(selected bool) Option[T] {\n\to.selected = selected\n\treturn o\n}\n\n// String returns the key of the option.\nfunc (o Option[T]) String() string {\n\treturn o.Key\n}\n"
        },
        {
          "name": "run.go",
          "type": "blob",
          "size": 0.1982421875,
          "content": "package huh\n\n// Run runs a single field by wrapping it within a group and a form.\nfunc Run(field Field) error {\n\tgroup := NewGroup(field)\n\tform := NewForm(group).WithShowHelp(false)\n\treturn form.Run()\n}\n"
        },
        {
          "name": "spinner",
          "type": "tree",
          "content": null
        },
        {
          "name": "theme.go",
          "type": "blob",
          "size": 13.3515625,
          "content": "package huh\n\nimport (\n\tcatppuccin \"github.com/catppuccin/go\"\n\t\"github.com/charmbracelet/bubbles/help\"\n\t\"github.com/charmbracelet/lipgloss\"\n)\n\n// Theme is a collection of styles for components of the form.\n// Themes can be applied to a form using the WithTheme option.\ntype Theme struct {\n\tForm           lipgloss.Style\n\tGroup          lipgloss.Style\n\tFieldSeparator lipgloss.Style\n\tBlurred        FieldStyles\n\tFocused        FieldStyles\n\tHelp           help.Styles\n}\n\n// FieldStyles are the styles for input fields.\ntype FieldStyles struct {\n\tBase           lipgloss.Style\n\tTitle          lipgloss.Style\n\tDescription    lipgloss.Style\n\tErrorIndicator lipgloss.Style\n\tErrorMessage   lipgloss.Style\n\n\t// Select styles.\n\tSelectSelector lipgloss.Style // Selection indicator\n\tOption         lipgloss.Style // Select options\n\tNextIndicator  lipgloss.Style\n\tPrevIndicator  lipgloss.Style\n\n\t// FilePicker styles.\n\tDirectory lipgloss.Style\n\tFile      lipgloss.Style\n\n\t// Multi-select styles.\n\tMultiSelectSelector lipgloss.Style\n\tSelectedOption      lipgloss.Style\n\tSelectedPrefix      lipgloss.Style\n\tUnselectedOption    lipgloss.Style\n\tUnselectedPrefix    lipgloss.Style\n\n\t// Textinput and teatarea styles.\n\tTextInput TextInputStyles\n\n\t// Confirm styles.\n\tFocusedButton lipgloss.Style\n\tBlurredButton lipgloss.Style\n\n\t// Card styles.\n\tCard      lipgloss.Style\n\tNoteTitle lipgloss.Style\n\tNext      lipgloss.Style\n}\n\n// TextInputStyles are the styles for text inputs.\ntype TextInputStyles struct {\n\tCursor      lipgloss.Style\n\tCursorText  lipgloss.Style\n\tPlaceholder lipgloss.Style\n\tPrompt      lipgloss.Style\n\tText        lipgloss.Style\n}\n\nconst (\n\tbuttonPaddingHorizontal = 2\n\tbuttonPaddingVertical   = 0\n)\n\n// ThemeBase returns a new base theme with general styles to be inherited by\n// other themes.\nfunc ThemeBase() *Theme {\n\tvar t Theme\n\n\tt.FieldSeparator = lipgloss.NewStyle().SetString(\"\\n\\n\")\n\n\tbutton := lipgloss.NewStyle().\n\t\tPadding(buttonPaddingVertical, buttonPaddingHorizontal).\n\t\tMarginRight(1)\n\n\t// Focused styles.\n\tt.Focused.Base = lipgloss.NewStyle().PaddingLeft(1).BorderStyle(lipgloss.ThickBorder()).BorderLeft(true)\n\tt.Focused.Card = lipgloss.NewStyle().PaddingLeft(1)\n\tt.Focused.ErrorIndicator = lipgloss.NewStyle().SetString(\" *\")\n\tt.Focused.ErrorMessage = lipgloss.NewStyle().SetString(\" *\")\n\tt.Focused.SelectSelector = lipgloss.NewStyle().SetString(\"> \")\n\tt.Focused.NextIndicator = lipgloss.NewStyle().MarginLeft(1).SetString(\"→\")\n\tt.Focused.PrevIndicator = lipgloss.NewStyle().MarginRight(1).SetString(\"←\")\n\tt.Focused.MultiSelectSelector = lipgloss.NewStyle().SetString(\"> \")\n\tt.Focused.SelectedPrefix = lipgloss.NewStyle().SetString(\"[•] \")\n\tt.Focused.UnselectedPrefix = lipgloss.NewStyle().SetString(\"[ ] \")\n\tt.Focused.FocusedButton = button.Foreground(lipgloss.Color(\"0\")).Background(lipgloss.Color(\"7\"))\n\tt.Focused.BlurredButton = button.Foreground(lipgloss.Color(\"7\")).Background(lipgloss.Color(\"0\"))\n\tt.Focused.TextInput.Placeholder = lipgloss.NewStyle().Foreground(lipgloss.Color(\"8\"))\n\n\tt.Help = help.New().Styles\n\n\t// Blurred styles.\n\tt.Blurred = t.Focused\n\tt.Blurred.Base = t.Blurred.Base.BorderStyle(lipgloss.HiddenBorder())\n\tt.Blurred.MultiSelectSelector = lipgloss.NewStyle().SetString(\"  \")\n\tt.Blurred.NextIndicator = lipgloss.NewStyle()\n\tt.Blurred.PrevIndicator = lipgloss.NewStyle()\n\n\treturn &t\n}\n\n// ThemeCharm returns a new theme based on the Charm color scheme.\nfunc ThemeCharm() *Theme {\n\tt := ThemeBase()\n\n\tvar (\n\t\tnormalFg = lipgloss.AdaptiveColor{Light: \"235\", Dark: \"252\"}\n\t\tindigo   = lipgloss.AdaptiveColor{Light: \"#5A56E0\", Dark: \"#7571F9\"}\n\t\tcream    = lipgloss.AdaptiveColor{Light: \"#FFFDF5\", Dark: \"#FFFDF5\"}\n\t\tfuchsia  = lipgloss.Color(\"#F780E2\")\n\t\tgreen    = lipgloss.AdaptiveColor{Light: \"#02BA84\", Dark: \"#02BF87\"}\n\t\tred      = lipgloss.AdaptiveColor{Light: \"#FF4672\", Dark: \"#ED567A\"}\n\t)\n\n\tt.Focused.Base = t.Focused.Base.BorderForeground(lipgloss.Color(\"238\"))\n\tt.Focused.Title = t.Focused.Title.Foreground(indigo).Bold(true)\n\tt.Focused.NoteTitle = t.Focused.NoteTitle.Foreground(indigo).Bold(true).MarginBottom(1)\n\tt.Focused.Directory = t.Focused.Directory.Foreground(indigo)\n\tt.Focused.Description = t.Focused.Description.Foreground(lipgloss.AdaptiveColor{Light: \"\", Dark: \"243\"})\n\tt.Focused.ErrorIndicator = t.Focused.ErrorIndicator.Foreground(red)\n\tt.Focused.ErrorMessage = t.Focused.ErrorMessage.Foreground(red)\n\tt.Focused.SelectSelector = t.Focused.SelectSelector.Foreground(fuchsia)\n\tt.Focused.NextIndicator = t.Focused.NextIndicator.Foreground(fuchsia)\n\tt.Focused.PrevIndicator = t.Focused.PrevIndicator.Foreground(fuchsia)\n\tt.Focused.Option = t.Focused.Option.Foreground(normalFg)\n\tt.Focused.MultiSelectSelector = t.Focused.MultiSelectSelector.Foreground(fuchsia)\n\tt.Focused.SelectedOption = t.Focused.SelectedOption.Foreground(green)\n\tt.Focused.SelectedPrefix = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: \"#02CF92\", Dark: \"#02A877\"}).SetString(\"✓ \")\n\tt.Focused.UnselectedPrefix = lipgloss.NewStyle().Foreground(lipgloss.AdaptiveColor{Light: \"\", Dark: \"243\"}).SetString(\"• \")\n\tt.Focused.UnselectedOption = t.Focused.UnselectedOption.Foreground(normalFg)\n\tt.Focused.FocusedButton = t.Focused.FocusedButton.Foreground(cream).Background(fuchsia)\n\tt.Focused.Next = t.Focused.FocusedButton\n\tt.Focused.BlurredButton = t.Focused.BlurredButton.Foreground(normalFg).Background(lipgloss.AdaptiveColor{Light: \"252\", Dark: \"237\"})\n\n\tt.Focused.TextInput.Cursor = t.Focused.TextInput.Cursor.Foreground(green)\n\tt.Focused.TextInput.Placeholder = t.Focused.TextInput.Placeholder.Foreground(lipgloss.AdaptiveColor{Light: \"248\", Dark: \"238\"})\n\tt.Focused.TextInput.Prompt = t.Focused.TextInput.Prompt.Foreground(fuchsia)\n\n\tt.Blurred = t.Focused\n\tt.Blurred.Base = t.Focused.Base.BorderStyle(lipgloss.HiddenBorder())\n\tt.Blurred.NextIndicator = lipgloss.NewStyle()\n\tt.Blurred.PrevIndicator = lipgloss.NewStyle()\n\n\treturn t\n}\n\n// ThemeDracula returns a new theme based on the Dracula color scheme.\nfunc ThemeDracula() *Theme {\n\tt := ThemeBase()\n\n\tvar (\n\t\tbackground = lipgloss.AdaptiveColor{Dark: \"#282a36\"}\n\t\tselection  = lipgloss.AdaptiveColor{Dark: \"#44475a\"}\n\t\tforeground = lipgloss.AdaptiveColor{Dark: \"#f8f8f2\"}\n\t\tcomment    = lipgloss.AdaptiveColor{Dark: \"#6272a4\"}\n\t\tgreen      = lipgloss.AdaptiveColor{Dark: \"#50fa7b\"}\n\t\tpurple     = lipgloss.AdaptiveColor{Dark: \"#bd93f9\"}\n\t\tred        = lipgloss.AdaptiveColor{Dark: \"#ff5555\"}\n\t\tyellow     = lipgloss.AdaptiveColor{Dark: \"#f1fa8c\"}\n\t)\n\n\tt.Focused.Base = t.Focused.Base.BorderForeground(selection)\n\tt.Focused.Title = t.Focused.Title.Foreground(purple)\n\tt.Focused.NoteTitle = t.Focused.NoteTitle.Foreground(purple)\n\tt.Focused.Description = t.Focused.Description.Foreground(comment)\n\tt.Focused.ErrorIndicator = t.Focused.ErrorIndicator.Foreground(red)\n\tt.Focused.Directory = t.Focused.Directory.Foreground(purple)\n\tt.Focused.File = t.Focused.File.Foreground(foreground)\n\tt.Focused.ErrorMessage = t.Focused.ErrorMessage.Foreground(red)\n\tt.Focused.SelectSelector = t.Focused.SelectSelector.Foreground(yellow)\n\tt.Focused.NextIndicator = t.Focused.NextIndicator.Foreground(yellow)\n\tt.Focused.PrevIndicator = t.Focused.PrevIndicator.Foreground(yellow)\n\tt.Focused.Option = t.Focused.Option.Foreground(foreground)\n\tt.Focused.MultiSelectSelector = t.Focused.MultiSelectSelector.Foreground(yellow)\n\tt.Focused.SelectedOption = t.Focused.SelectedOption.Foreground(green)\n\tt.Focused.SelectedPrefix = t.Focused.SelectedPrefix.Foreground(green)\n\tt.Focused.UnselectedOption = t.Focused.UnselectedOption.Foreground(foreground)\n\tt.Focused.UnselectedPrefix = t.Focused.UnselectedPrefix.Foreground(comment)\n\tt.Focused.FocusedButton = t.Focused.FocusedButton.Foreground(yellow).Background(purple).Bold(true)\n\tt.Focused.BlurredButton = t.Focused.BlurredButton.Foreground(foreground).Background(background)\n\n\tt.Focused.TextInput.Cursor = t.Focused.TextInput.Cursor.Foreground(yellow)\n\tt.Focused.TextInput.Placeholder = t.Focused.TextInput.Placeholder.Foreground(comment)\n\tt.Focused.TextInput.Prompt = t.Focused.TextInput.Prompt.Foreground(yellow)\n\n\tt.Blurred = t.Focused\n\tt.Blurred.Base = t.Blurred.Base.BorderStyle(lipgloss.HiddenBorder())\n\tt.Blurred.NextIndicator = lipgloss.NewStyle()\n\tt.Blurred.PrevIndicator = lipgloss.NewStyle()\n\n\treturn t\n}\n\n// ThemeBase16 returns a new theme based on the base16 color scheme.\nfunc ThemeBase16() *Theme {\n\tt := ThemeBase()\n\n\tt.Focused.Base = t.Focused.Base.BorderForeground(lipgloss.Color(\"8\"))\n\tt.Focused.Title = t.Focused.Title.Foreground(lipgloss.Color(\"6\"))\n\tt.Focused.NoteTitle = t.Focused.NoteTitle.Foreground(lipgloss.Color(\"6\"))\n\tt.Focused.Directory = t.Focused.Directory.Foreground(lipgloss.Color(\"6\"))\n\tt.Focused.Description = t.Focused.Description.Foreground(lipgloss.Color(\"8\"))\n\tt.Focused.ErrorIndicator = t.Focused.ErrorIndicator.Foreground(lipgloss.Color(\"9\"))\n\tt.Focused.ErrorMessage = t.Focused.ErrorMessage.Foreground(lipgloss.Color(\"9\"))\n\tt.Focused.SelectSelector = t.Focused.SelectSelector.Foreground(lipgloss.Color(\"3\"))\n\tt.Focused.NextIndicator = t.Focused.NextIndicator.Foreground(lipgloss.Color(\"3\"))\n\tt.Focused.PrevIndicator = t.Focused.PrevIndicator.Foreground(lipgloss.Color(\"3\"))\n\tt.Focused.Option = t.Focused.Option.Foreground(lipgloss.Color(\"7\"))\n\tt.Focused.MultiSelectSelector = t.Focused.MultiSelectSelector.Foreground(lipgloss.Color(\"3\"))\n\tt.Focused.SelectedOption = t.Focused.SelectedOption.Foreground(lipgloss.Color(\"2\"))\n\tt.Focused.SelectedPrefix = t.Focused.SelectedPrefix.Foreground(lipgloss.Color(\"2\"))\n\tt.Focused.UnselectedOption = t.Focused.UnselectedOption.Foreground(lipgloss.Color(\"7\"))\n\tt.Focused.FocusedButton = t.Focused.FocusedButton.Foreground(lipgloss.Color(\"7\")).Background(lipgloss.Color(\"5\"))\n\tt.Focused.BlurredButton = t.Focused.BlurredButton.Foreground(lipgloss.Color(\"7\")).Background(lipgloss.Color(\"0\"))\n\n\tt.Focused.TextInput.Cursor.Foreground(lipgloss.Color(\"5\"))\n\tt.Focused.TextInput.Placeholder.Foreground(lipgloss.Color(\"8\"))\n\tt.Focused.TextInput.Prompt.Foreground(lipgloss.Color(\"3\"))\n\n\tt.Blurred = t.Focused\n\tt.Blurred.Base = t.Blurred.Base.BorderStyle(lipgloss.HiddenBorder())\n\tt.Blurred.NoteTitle = t.Blurred.NoteTitle.Foreground(lipgloss.Color(\"8\"))\n\tt.Blurred.Title = t.Blurred.NoteTitle.Foreground(lipgloss.Color(\"8\"))\n\n\tt.Blurred.TextInput.Prompt = t.Blurred.TextInput.Prompt.Foreground(lipgloss.Color(\"8\"))\n\tt.Blurred.TextInput.Text = t.Blurred.TextInput.Text.Foreground(lipgloss.Color(\"7\"))\n\n\tt.Blurred.NextIndicator = lipgloss.NewStyle()\n\tt.Blurred.PrevIndicator = lipgloss.NewStyle()\n\n\treturn t\n}\n\n// ThemeCatppuccin returns a new theme based on the Catppuccin color scheme.\nfunc ThemeCatppuccin() *Theme {\n\tt := ThemeBase()\n\n\tlight := catppuccin.Latte\n\tdark := catppuccin.Mocha\n\tvar (\n\t\tbase     = lipgloss.AdaptiveColor{Light: light.Base().Hex, Dark: dark.Base().Hex}\n\t\ttext     = lipgloss.AdaptiveColor{Light: light.Text().Hex, Dark: dark.Text().Hex}\n\t\tsubtext1 = lipgloss.AdaptiveColor{Light: light.Subtext1().Hex, Dark: dark.Subtext1().Hex}\n\t\tsubtext0 = lipgloss.AdaptiveColor{Light: light.Subtext0().Hex, Dark: dark.Subtext0().Hex}\n\t\toverlay1 = lipgloss.AdaptiveColor{Light: light.Overlay1().Hex, Dark: dark.Overlay1().Hex}\n\t\toverlay0 = lipgloss.AdaptiveColor{Light: light.Overlay0().Hex, Dark: dark.Overlay0().Hex}\n\t\tgreen    = lipgloss.AdaptiveColor{Light: light.Green().Hex, Dark: dark.Green().Hex}\n\t\tred      = lipgloss.AdaptiveColor{Light: light.Red().Hex, Dark: dark.Red().Hex}\n\t\tpink     = lipgloss.AdaptiveColor{Light: light.Pink().Hex, Dark: dark.Pink().Hex}\n\t\tmauve    = lipgloss.AdaptiveColor{Light: light.Mauve().Hex, Dark: dark.Mauve().Hex}\n\t\tcursor   = lipgloss.AdaptiveColor{Light: light.Rosewater().Hex, Dark: dark.Rosewater().Hex}\n\t)\n\n\tt.Focused.Base = t.Focused.Base.BorderForeground(subtext1)\n\tt.Focused.Title = t.Focused.Title.Foreground(mauve)\n\tt.Focused.NoteTitle = t.Focused.NoteTitle.Foreground(mauve)\n\tt.Focused.Directory = t.Focused.Directory.Foreground(mauve)\n\tt.Focused.Description = t.Focused.Description.Foreground(subtext0)\n\tt.Focused.ErrorIndicator = t.Focused.ErrorIndicator.Foreground(red)\n\tt.Focused.ErrorMessage = t.Focused.ErrorMessage.Foreground(red)\n\tt.Focused.SelectSelector = t.Focused.SelectSelector.Foreground(pink)\n\tt.Focused.NextIndicator = t.Focused.NextIndicator.Foreground(pink)\n\tt.Focused.PrevIndicator = t.Focused.PrevIndicator.Foreground(pink)\n\tt.Focused.Option = t.Focused.Option.Foreground(text)\n\tt.Focused.MultiSelectSelector = t.Focused.MultiSelectSelector.Foreground(pink)\n\tt.Focused.SelectedOption = t.Focused.SelectedOption.Foreground(green)\n\tt.Focused.SelectedPrefix = t.Focused.SelectedPrefix.Foreground(green)\n\tt.Focused.UnselectedPrefix = t.Focused.UnselectedPrefix.Foreground(text)\n\tt.Focused.UnselectedOption = t.Focused.UnselectedOption.Foreground(text)\n\tt.Focused.FocusedButton = t.Focused.FocusedButton.Foreground(base).Background(pink)\n\tt.Focused.BlurredButton = t.Focused.BlurredButton.Foreground(text).Background(base)\n\n\tt.Focused.TextInput.Cursor = t.Focused.TextInput.Cursor.Foreground(cursor)\n\tt.Focused.TextInput.Placeholder = t.Focused.TextInput.Placeholder.Foreground(overlay0)\n\tt.Focused.TextInput.Prompt = t.Focused.TextInput.Prompt.Foreground(pink)\n\n\tt.Blurred = t.Focused\n\tt.Blurred.Base = t.Blurred.Base.BorderStyle(lipgloss.HiddenBorder())\n\n\tt.Help.Ellipsis = t.Help.Ellipsis.Foreground(subtext0)\n\tt.Help.ShortKey = t.Help.ShortKey.Foreground(subtext0)\n\tt.Help.ShortDesc = t.Help.ShortDesc.Foreground(overlay1)\n\tt.Help.ShortSeparator = t.Help.ShortSeparator.Foreground(subtext0)\n\tt.Help.FullKey = t.Help.FullKey.Foreground(subtext0)\n\tt.Help.FullDesc = t.Help.FullDesc.Foreground(overlay1)\n\tt.Help.FullSeparator = t.Help.FullSeparator.Foreground(subtext0)\n\n\treturn t\n}\n"
        },
        {
          "name": "validate.go",
          "type": "blob",
          "size": 1.509765625,
          "content": "package huh\n\nimport (\n\t\"fmt\"\n\t\"unicode/utf8\"\n)\n\n// ValidateNotEmpty checks if the input is not empty.\nfunc ValidateNotEmpty() func(s string) error {\n\treturn func(s string) error {\n\t\tif err := ValidateMinLength(1)(s); err != nil {\n\t\t\treturn fmt.Errorf(\"input cannot be empty\")\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// ValidateMinLength checks if the length of the input is at least min.\nfunc ValidateMinLength(v int) func(s string) error {\n\treturn func(s string) error {\n\t\tif utf8.RuneCountInString(s) < v {\n\t\t\treturn fmt.Errorf(\"input must be at least %d characters long\", v)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// ValidateMaxLength checks if the length of the input is at most max.\nfunc ValidateMaxLength(v int) func(s string) error {\n\treturn func(s string) error {\n\t\tif utf8.RuneCountInString(s) > v {\n\t\t\treturn fmt.Errorf(\"input must be at most %d characters long\", v)\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// ValidateLength checks if the length of the input is within the specified range.\nfunc ValidateLength(minl, maxl int) func(s string) error {\n\treturn func(s string) error {\n\t\tif err := ValidateMinLength(minl)(s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn ValidateMaxLength(maxl)(s)\n\t}\n}\n\n// ValidateOneOf checks if a string is one of the specified options.\nfunc ValidateOneOf(options ...string) func(string) error {\n\tvalidOptions := make(map[string]struct{})\n\tfor _, option := range options {\n\t\tvalidOptions[option] = struct{}{}\n\t}\n\n\treturn func(value string) error {\n\t\tif _, ok := validOptions[value]; !ok {\n\t\t\treturn fmt.Errorf(\"invalid option: %s\", value)\n\t\t}\n\t\treturn nil\n\t}\n}\n"
        }
      ]
    }
  ]
}