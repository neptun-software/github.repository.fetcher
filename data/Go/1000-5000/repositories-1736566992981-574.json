{
  "metadata": {
    "timestamp": 1736566992981,
    "page": 574,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "knadh/koanf",
      "stars": 2932,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.017578125,
          "content": ".env\n\n# IDE\n.idea\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.07421875,
          "content": "The MIT License\n\nCopyright (c) 2019, Kailash Nadh. https://github.com/knadh\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 29.7568359375,
          "content": "<a href=\"https://zerodha.tech\"><img src=\"https://zerodha.tech/static/images/github-badge.svg\" align=\"right\" /></a>\n\n![koanf](https://user-images.githubusercontent.com/547147/72681838-6981dd00-3aed-11ea-8f5d-310816c70c08.png)\n\n**koanf** is a library for reading configuration from different sources in different formats in Go applications. It is a cleaner, lighter [alternative to spf13/viper](#alternative-to-viper) with better abstractions and extensibility and far fewer dependencies.\n\nkoanf v2 has modules (Providers) for reading configuration from a variety of sources such as files, command line flags, environment variables, Vault, and S3 and for parsing (Parsers) formats such as JSON, YAML, TOML, Hashicorp HCL. It is easy to plug in custom parsers and providers.\n\nAll external dependencies in providers and parsers are detached from the core and can be installed separately as necessary.\n\n[![Run Tests](https://github.com/knadh/koanf/actions/workflows/test.yml/badge.svg)](https://github.com/knadh/koanf/actions/workflows/test.yml) [![GoDoc](https://pkg.go.dev/badge/github.com/knadh/koanf?utm_source=godoc)](https://pkg.go.dev/github.com/knadh/koanf/v2) \n\n### Installation\n\n```shell\n# Install the core.\ngo get -u github.com/knadh/koanf/v2\n\n# Install the necessary Provider(s).\n# Available: file, env, posflag, basicflag, confmap, rawbytes,\n#            structs, fs, s3, appconfig/v2, consul/v2, etcd/v2, vault/v2, parameterstore/v2\n# eg: go get -u github.com/knadh/koanf/providers/s3\n# eg: go get -u github.com/knadh/koanf/providers/consul/v2\n\ngo get -u github.com/knadh/koanf/providers/file\n\n\n# Install the necessary Parser(s).\n# Available: toml, toml/v2, json, yaml, dotenv, hcl, hjson, nestedtext\n# go get -u github.com/knadh/koanf/parsers/$parser\n\ngo get -u github.com/knadh/koanf/parsers/toml\n```\n\n[See the list](#api) of all bundled Providers and Parsers.\n\n### Contents\n\n- [Concepts](#concepts)\n- [Reading config from files](#reading-config-from-files)\n- [Watching file for changes](#watching-file-for-changes)\n- [Reading from command line](#reading-from-command-line)\n- [Reading environment variables](#reading-environment-variables)\n- [Reading raw bytes](#reading-raw-bytes)\n- [Reading from maps and structs](#reading-from-nested-maps)\n- [Unmarshalling and marshalling](#unmarshalling-and-marshalling)\n- [Order of merge and key case sensitivity](#order-of-merge-and-key-case-sensitivity)\n- [Custom Providers and Parsers](#custom-providers-and-parsers)\n- [Custom merge strategies](#custom-merge-strategies)\n- [List of installable Providers and Parsers](#api)\n\n### Concepts\n\n- `koanf.Provider` is a generic interface that provides configuration, for example, from files, environment variables, HTTP sources, or anywhere. The configuration can either be raw bytes that a parser can parse, or it can be a nested `map[string]interface{}` that can be directly loaded.\n- `koanf.Parser` is a generic interface that takes raw bytes, parses, and returns a nested `map[string]interface{}`. For example, JSON and YAML parsers.\n- Once loaded into koanf, configuration are values queried by a delimited key path syntax. eg: `app.server.port`. Any delimiter can be chosen.\n- Configuration from multiple sources can be loaded and merged into a koanf instance, for example, load from a file first and override certain values with flags from the command line.\n\nWith these two interface implementations, koanf can obtain configuration in any format from any source, parse it, and make it available to an application.\n\n### Reading config from files\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/parsers/yaml\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\n// Global koanf instance. Use \".\" as the key path delimiter. This can be \"/\" or any character.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\t// Load JSON config.\n\tif err := k.Load(file.Provider(\"mock/mock.json\"), json.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\t// Load YAML config and merge into the previously loaded config (because we can).\n\tk.Load(file.Provider(\"mock/mock.yml\"), yaml.Parser())\n\n\tfmt.Println(\"parent's name is = \", k.String(\"parent1.name\"))\n\tfmt.Println(\"parent's ID is = \", k.Int(\"parent1.id\"))\n}\n\n```\n\n### Watching file for changes\nSome providers expose a `Watch()` method that makes the provider watch for changes\nin configuration and trigger a callback to reload the configuration.\nThis is not goroutine safe if there are concurrent `*Get()` calls happening on the\nkoanf object while it is doing a `Load()`. Such scenarios will need mutex locking.\n\n`file, appconfig, vault, consul` providers have a `Watch()` method.\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/parsers/yaml\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\n// Global koanf instance. Use \".\" as the key path delimiter. This can be \"/\" or any character.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\t// Load JSON config.\n\tf := file.Provider(\"mock/mock.json\")\n\tif err := k.Load(f, json.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\t// Load YAML config and merge into the previously loaded config (because we can).\n\tk.Load(file.Provider(\"mock/mock.yml\"), yaml.Parser())\n\n\tfmt.Println(\"parent's name is = \", k.String(\"parent1.name\"))\n\tfmt.Println(\"parent's ID is = \", k.Int(\"parent1.id\"))\n\n\t// Watch the file and get a callback on change. The callback can do whatever,\n\t// like re-load the configuration.\n\t// File provider always returns a nil `event`.\n\tf.Watch(func(event interface{}, err error) {\n\t\tif err != nil {\n\t\t\tlog.Printf(\"watch error: %v\", err)\n\t\t\treturn\n\t\t}\n\n\t\t// Throw away the old config and load a fresh copy.\n\t\tlog.Println(\"config changed. Reloading ...\")\n\t\tk = koanf.New(\".\")\n\t\tk.Load(f, json.Parser())\n\t\tk.Print()\n\t})\n\n\t// To stop a file watcher, call:\n\t// f.Unwatch()\n\n\t// Block forever (and manually make a change to mock/mock.json) to\n\t// reload the config.\n\tlog.Println(\"waiting forever. Try making a change to mock/mock.json to live reload\")\n\t<-make(chan bool)\n}\n```\n\n\n### Reading from command line\n\nThe following example shows the use of `posflag.Provider`, a wrapper over the [spf13/pflag](https://github.com/spf13/pflag) library, an advanced commandline lib. For Go's built in `flag` package, use `basicflag.Provider`.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/toml\"\n\n\t// TOML version 2 is available at:\n\t// \"github.com/knadh/koanf/parsers/toml/v2\"\n\n\t\"github.com/knadh/koanf/providers/file\"\n\t\"github.com/knadh/koanf/providers/posflag\"\n\tflag \"github.com/spf13/pflag\"\n)\n\n// Global koanf instance. Use \".\" as the key path delimiter. This can be \"/\" or any character.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\t// Use the POSIX compliant pflag lib instead of Go's flag lib.\n\tf := flag.NewFlagSet(\"config\", flag.ContinueOnError)\n\tf.Usage = func() {\n\t\tfmt.Println(f.FlagUsages())\n\t\tos.Exit(0)\n\t}\n\t// Path to one or more config files to load into koanf along with some config params.\n\tf.StringSlice(\"conf\", []string{\"mock/mock.toml\"}, \"path to one or more .toml config files\")\n\tf.String(\"time\", \"2020-01-01\", \"a time string\")\n\tf.String(\"type\", \"xxx\", \"type of the app\")\n\tf.Parse(os.Args[1:])\n\n\t// Load the config files provided in the commandline.\n\tcFiles, _ := f.GetStringSlice(\"conf\")\n\tfor _, c := range cFiles {\n\t\tif err := k.Load(file.Provider(c), toml.Parser()); err != nil {\n\t\t\tlog.Fatalf(\"error loading file: %v\", err)\n\t\t}\n\t}\n\n\t// \"time\" and \"type\" may have been loaded from the config file, but\n\t// they can still be overridden with the values from the command line.\n\t// The bundled posflag.Provider takes a flagset from the spf13/pflag lib.\n\t// Passing the Koanf instance to posflag helps it deal with default command\n\t// line flag values that are not present in conf maps from previously loaded\n\t// providers.\n\tif err := k.Load(posflag.Provider(f, \".\", k), nil); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\tfmt.Println(\"time is = \", k.String(\"time\"))\n}\n```\n\n### Reading environment variables\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/providers/env\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\n// Global koanf instance. Use . as the key path delimiter. This can be / or anything.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\t// Load JSON config.\n\tif err := k.Load(file.Provider(\"mock/mock.json\"), json.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\t// Load environment variables and merge into the loaded config.\n\t// \"MYVAR\" is the prefix to filter the env vars by.\n\t// \".\" is the delimiter used to represent the key hierarchy in env vars.\n\t// The (optional, or can be nil) function can be used to transform\n\t// the env var names, for instance, to lowercase them.\n\t//\n\t// For example, env vars: MYVAR_TYPE and MYVAR_PARENT1_CHILD1_NAME\n\t// will be merged into the \"type\" and the nested \"parent1.child1.name\"\n\t// keys in the config file here as we lowercase the key, \n\t// replace `_` with `.` and strip the MYVAR_ prefix so that \n\t// only \"parent1.child1.name\" remains.\n\tk.Load(env.Provider(\"MYVAR_\", \".\", func(s string) string {\n\t\treturn strings.Replace(strings.ToLower(\n\t\t\tstrings.TrimPrefix(s, \"MYVAR_\")), \"_\", \".\", -1)\n\t}), nil)\n\n\tfmt.Println(\"name is = \", k.String(\"parent1.child1.name\"))\n}\n```\n\nYou can also use the `env.ProviderWithValue` with a callback that supports mutating both the key and value\nto return types other than a string. For example, here, env values separated by spaces are\nreturned as string slices or arrays. eg: `MYVAR_slice=a b c` becomes `slice: [a, b, c]`.\n\n```go\n\tk.Load(env.ProviderWithValue(\"MYVAR_\", \".\", func(s string, v string) (string, interface{}) {\n\t\t// Strip out the MYVAR_ prefix and lowercase and get the key while also replacing\n\t\t// the _ character with . in the key (koanf delimiter).\n\t\tkey := strings.Replace(strings.ToLower(strings.TrimPrefix(s, \"MYVAR_\")), \"_\", \".\", -1)\n\n\t\t// If there is a space in the value, split the value into a slice by the space.\n\t\tif strings.Contains(v, \" \") {\n\t\t\treturn key, strings.Split(v, \" \")\n\t\t}\n\n\t\t// Otherwise, return the plain string.\n\t\treturn key, v\n\t}), nil)\n```\n\n### Reading from an S3 bucket\n\n```go\n// Load JSON config from s3.\nif err := k.Load(s3.Provider(s3.Config{\n\tAccessKey: os.Getenv(\"AWS_S3_ACCESS_KEY\"),\n\tSecretKey: os.Getenv(\"AWS_S3_SECRET_KEY\"),\n\tRegion:    os.Getenv(\"AWS_S3_REGION\"),\n\tBucket:    os.Getenv(\"AWS_S3_BUCKET\"),\n\tObjectKey: \"dir/config.json\",\n}), json.Parser()); err != nil {\n\tlog.Fatalf(\"error loading config: %v\", err)\n}\n```\n\n### Reading raw bytes\n\nThe bundled `rawbytes` Provider can be used to read arbitrary bytes from a source, like a database or an HTTP call.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/providers/rawbytes\"\n)\n\n// Global koanf instance. Use . as the key path delimiter. This can be / or anything.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\tb := []byte(`{\"type\": \"rawbytes\", \"parent1\": {\"child1\": {\"type\": \"rawbytes\"}}}`)\n\tk.Load(rawbytes.Provider(b), json.Parser())\n\tfmt.Println(\"type is = \", k.String(\"parent1.child1.type\"))\n}\n```\n\n### Unmarshalling and marshalling\n`Parser`s can be used to unmarshal and scan the values in a Koanf instance into a struct based on the field tags, and to marshal a Koanf instance back into serialized bytes, for example to JSON or YAML files\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\n// Global koanf instance. Use . as the key path delimiter. This can be / or anything.\nvar (\n\tk      = koanf.New(\".\")\n\tparser = json.Parser()\n)\n\nfunc main() {\n\t// Load JSON config.\n\tif err := k.Load(file.Provider(\"mock/mock.json\"), parser); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\t// Structure to unmarshal nested conf to.\n\ttype childStruct struct {\n\t\tName       string            `koanf:\"name\"`\n\t\tType       string            `koanf:\"type\"`\n\t\tEmpty      map[string]string `koanf:\"empty\"`\n\t\tGrandChild struct {\n\t\t\tIds []int `koanf:\"ids\"`\n\t\t\tOn  bool  `koanf:\"on\"`\n\t\t} `koanf:\"grandchild1\"`\n\t}\n\n\tvar out childStruct\n\n\t// Quick unmarshal.\n\tk.Unmarshal(\"parent1.child1\", &out)\n\tfmt.Println(out)\n\n\t// Unmarshal with advanced config.\n\tout = childStruct{}\n\tk.UnmarshalWithConf(\"parent1.child1\", &out, koanf.UnmarshalConf{Tag: \"koanf\"})\n\tfmt.Println(out)\n\n\t// Marshal the instance back to JSON.\n\t// The parser instance can be anything, eg: json.Parser(), yaml.Parser() etc.\n\tb, _ := k.Marshal(parser)\n\tfmt.Println(string(b))\n}\n```\n\n### Unmarshalling with flat paths\n\nSometimes it is necessary to unmarshal an assortment of keys from various nested structures into a flat target structure. This is possible with the `UnmarshalConf.FlatPaths` flag.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\n// Global koanf instance. Use . as the key path delimiter. This can be / or anything.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\t// Load JSON config.\n\tif err := k.Load(file.Provider(\"mock/mock.json\"), json.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\ttype rootFlat struct {\n\t\tType                        string            `koanf:\"type\"`\n\t\tEmpty                       map[string]string `koanf:\"empty\"`\n\t\tParent1Name                 string            `koanf:\"parent1.name\"`\n\t\tParent1ID                   int               `koanf:\"parent1.id\"`\n\t\tParent1Child1Name           string            `koanf:\"parent1.child1.name\"`\n\t\tParent1Child1Type           string            `koanf:\"parent1.child1.type\"`\n\t\tParent1Child1Empty          map[string]string `koanf:\"parent1.child1.empty\"`\n\t\tParent1Child1Grandchild1IDs []int             `koanf:\"parent1.child1.grandchild1.ids\"`\n\t\tParent1Child1Grandchild1On  bool              `koanf:\"parent1.child1.grandchild1.on\"`\n\t}\n\n\t// Unmarshal the whole root with FlatPaths: True.\n\tvar o1 rootFlat\n\tk.UnmarshalWithConf(\"\", &o1, koanf.UnmarshalConf{Tag: \"koanf\", FlatPaths: true})\n\tfmt.Println(o1)\n\n\t// Unmarshal a child structure of \"parent1\".\n\ttype subFlat struct {\n\t\tName                 string            `koanf:\"name\"`\n\t\tID                   int               `koanf:\"id\"`\n\t\tChild1Name           string            `koanf:\"child1.name\"`\n\t\tChild1Type           string            `koanf:\"child1.type\"`\n\t\tChild1Empty          map[string]string `koanf:\"child1.empty\"`\n\t\tChild1Grandchild1IDs []int             `koanf:\"child1.grandchild1.ids\"`\n\t\tChild1Grandchild1On  bool              `koanf:\"child1.grandchild1.on\"`\n\t}\n\n\tvar o2 subFlat\n\tk.UnmarshalWithConf(\"parent1\", &o2, koanf.UnmarshalConf{Tag: \"koanf\", FlatPaths: true})\n\tfmt.Println(o2)\n}\n```\n\n#### Reading from nested maps\n\nThe bundled `confmap` provider takes a `map[string]interface{}` that can be loaded into a koanf instance. \n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/providers/confmap\"\n\t\"github.com/knadh/koanf/providers/file\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/parsers/yaml\"\n)\n\n// Global koanf instance. Use \".\" as the key path delimiter. This can be \"/\" or any character.\nvar k = koanf.New(\".\")\n\nfunc main() {\n\t// Load default values using the confmap provider.\n\t// We provide a flat map with the \".\" delimiter.\n\t// A nested map can be loaded by setting the delimiter to an empty string \"\".\n\tk.Load(confmap.Provider(map[string]interface{}{\n\t\t\"parent1.name\": \"Default Name\",\n\t\t\"parent3.name\": \"New name here\",\n\t}, \".\"), nil)\n\n\t// Load JSON config on top of the default values.\n\tif err := k.Load(file.Provider(\"mock/mock.json\"), json.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\t// Load YAML config and merge into the previously loaded config (because we can).\n\tk.Load(file.Provider(\"mock/mock.yml\"), yaml.Parser())\n\n\tfmt.Println(\"parent's name is = \", k.String(\"parent1.name\"))\n\tfmt.Println(\"parent's ID is = \", k.Int(\"parent1.id\"))\n}\n```\n\n#### Reading from struct \n\nThe bundled `structs` provider can be used to read data from a struct to load into a koanf instance.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/providers/structs\"\n)\n\n// Global koanf instance. Use \".\" as the key path delimiter. This can be \"/\" or any character.\nvar k = koanf.New(\".\")\n\ntype parentStruct struct {\n\tName   string      `koanf:\"name\"`\n\tID     int         `koanf:\"id\"`\n\tChild1 childStruct `koanf:\"child1\"`\n}\ntype childStruct struct {\n\tName        string            `koanf:\"name\"`\n\tType        string            `koanf:\"type\"`\n\tEmpty       map[string]string `koanf:\"empty\"`\n\tGrandchild1 grandchildStruct  `koanf:\"grandchild1\"`\n}\ntype grandchildStruct struct {\n\tIds []int `koanf:\"ids\"`\n\tOn  bool  `koanf:\"on\"`\n}\ntype sampleStruct struct {\n\tType    string            `koanf:\"type\"`\n\tEmpty   map[string]string `koanf:\"empty\"`\n\tParent1 parentStruct      `koanf:\"parent1\"`\n}\n\nfunc main() {\n\t// Load default values using the structs provider.\n\t// We provide a struct along with the struct tag `koanf` to the\n\t// provider.\n\tk.Load(structs.Provider(sampleStruct{\n\t\tType:  \"json\",\n\t\tEmpty: make(map[string]string),\n\t\tParent1: parentStruct{\n\t\t\tName: \"parent1\",\n\t\t\tID:   1234,\n\t\t\tChild1: childStruct{\n\t\t\t\tName:  \"child1\",\n\t\t\t\tType:  \"json\",\n\t\t\t\tEmpty: make(map[string]string),\n\t\t\t\tGrandchild1: grandchildStruct{\n\t\t\t\t\tIds: []int{1, 2, 3},\n\t\t\t\t\tOn:  true,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}, \"koanf\"), nil)\n\n\tfmt.Printf(\"name is = `%s`\\n\", k.String(\"parent1.child1.name\"))\n}\n```\n### Merge behavior\n#### Default behavior\nThe default behavior when you create Koanf this way is: `koanf.New(delim)` that the latest loaded configuration will\nmerge with the previous one.\n\nFor example:\n`first.yml`\n```yaml\nkey: [1,2,3]\n```\n`second.yml`\n```yaml\nkey: 'string'\n```\nWhen `second.yml` is loaded it will override the type of the `first.yml`.\n\nIf this behavior is not desired, you can merge 'strictly'. In the same scenario, `Load` will return an error.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/maps\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/parsers/yaml\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\nvar conf = koanf.Conf{\n\tDelim:       \".\",\n\tStrictMerge: true,\n}\nvar k = koanf.NewWithConf(conf)\n\nfunc main() {\n\tyamlPath := \"mock/mock.yml\"\n\tif err := k.Load(file.Provider(yamlPath), yaml.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\tjsonPath := \"mock/mock.json\"\n\tif err := k.Load(file.Provider(jsonPath), json.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n}\n```\n**Note:** When merging different extensions, each parser can treat his types differently,\n meaning even though you the load same types there is a probability that it will fail with `StrictMerge: true`.\n\nFor example: merging JSON and YAML will most likely fail because JSON treats integers as float64 and YAML treats them as integers.\n\n### Order of merge and key case sensitivity\n\n- Config keys are case-sensitive in koanf. For example, `app.server.port` and `APP.SERVER.port` are not the same.\n- koanf does not impose any ordering on loading config from various providers. Every successive `Load()` or `Merge()` merges new config into the existing config. That is, it is possible to load environment variables first, then files on top of it, and then command line variables on top of it, or any such order.\n\n### Custom Providers and Parsers\n\nA Provider returns a nested `map[string]interface{}` config that can be loaded directly into koanf with `koanf.Load()` or it can return raw bytes that can be parsed with a Parser (again, loaded using `koanf.Load()`. Writing Providers and Parsers are easy. See the bundled implementations in the [providers](https://github.com/knadh/koanf/tree/master/providers) and [parsers](https://github.com/knadh/koanf/tree/master/parsers) directories.\n\n### Custom merge strategies\n\nBy default, when merging two config sources using `Load()`, koanf recursively merges keys of nested maps (`map[string]interface{}`),\nwhile static values are overwritten (slices, strings, etc). This behaviour can be changed by providing a custom merge function with the `WithMergeFunc` option.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/knadh/koanf/v2\"\n\t\"github.com/knadh/koanf/maps\"\n\t\"github.com/knadh/koanf/parsers/json\"\n\t\"github.com/knadh/koanf/parsers/yaml\"\n\t\"github.com/knadh/koanf/providers/file\"\n)\n\nvar conf = koanf.Conf{\n\tDelim:       \".\",\n\tStrictMerge: true,\n}\nvar k = koanf.NewWithConf(conf)\n\nfunc main() {\n\tyamlPath := \"mock/mock.yml\"\n\tif err := k.Load(file.Provider(yamlPath), yaml.Parser()); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n\n\tjsonPath := \"mock/mock.json\"\n\tif err := k.Load(file.Provider(jsonPath), json.Parser(), koanf.WithMergeFunc(func(src, dest map[string]interface{}) error {\n     // Your custom logic, copying values from src into dst\n     return nil\n    })); err != nil {\n\t\tlog.Fatalf(\"error loading config: %v\", err)\n\t}\n}\n```\n\n## API\n\nSee the full API documentation of all available methods at https://pkg.go.dev/github.com/knadh/koanf/v2#section-documentation\n\n### Bundled Providers\n\nInstall with `go get -u github.com/knadh/koanf/providers/$provider`\n\n| Package             | Provider                                                      | Description                                                                                                                                                                           |\n| ------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| file      | `file.Provider(filepath string)`                              | Reads a file and returns the raw bytes to be parsed.                                                                                                                                  |\n| fs      | `fs.Provider(f fs.FS, filepath string)`                              | (**Experimental**) Reads a file from fs.FS and returns the raw bytes to be parsed. The provider requires `go v1.16` or higher.                                            |\n| basicflag | `basicflag.Provider(f *flag.FlagSet, delim string)`           | Takes a stdlib `flag.FlagSet`                                                                                                                                                        |\n| posflag   | `posflag.Provider(f *pflag.FlagSet, delim string)`            | Takes an `spf13/pflag.FlagSet` (advanced POSIX compatible flags with multiple types) and provides a nested config map based on delim.                                                 |\n| env       | `env.Provider(prefix, delim string, f func(s string) string)` | Takes an optional prefix to filter env variables by, an optional function that takes and returns a string to transform env variables, and returns a nested config map based on delim. |\n| confmap   | `confmap.Provider(mp map[string]interface{}, delim string)`   | Takes a premade `map[string]interface{}` conf map. If delim is provided, the keys are assumed to be flattened, thus unflattened using delim.                                          |\n| structs   | `structs.Provider(s interface{}, tag string)`                 | Takes a struct and struct tag.                                                                                                                                                        |\n| s3        | `s3.Provider(s3.S3Config{})`                                  | Takes a s3 config struct.                                                                                                                                                             |\n| rawbytes  | `rawbytes.Provider(b []byte)`                                 | Takes a raw `[]byte` slice to be parsed with a koanf.Parser                                                                                                                           |\n| vault/v2     | `vault.Provider(vault.Config{})`                              | Hashicorp Vault provider                                                                                                                           |\n| appconfig/v2     | `vault.AppConfig(appconfig.Config{})`                              | AWS AppConfig provider                                                                                                                           |\n| etcd/v2     | `etcd.Provider(etcd.Config{})`                              | CNCF etcd provider                                                                                                                           |\n| consul/v2     | `consul.Provider(consul.Config{})`                              | Hashicorp Consul provider                                                                                                                           |\n| parameterstore/v2 | `parameterstore.Provider(parameterstore.Config{})` | AWS Systems Manager Parameter Store provider |\n| cliflagv2  |  `cliflagv2.Provider(ctx *cli.Context, delimiter string)` |  Reads commands and flags from urfave/cli/v2 context including global flags and nested command flags and provides a nested config map based on delim. |\n\n\n### Bundled Parsers\n\nInstall with `go get -u github.com/knadh/koanf/parsers/$parser`\n\n| Package      | Parser                           | Description                                                                                                                                               |\n| ------------ | -------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| json       | `json.Parser()`                  | Parses JSON bytes into a nested map                                                                                                                       |\n| yaml       | `yaml.Parser()`                  | Parses YAML bytes into a nested map                                                                                                                       |\n| toml       | `toml.Parser()`                  | Parses TOML bytes into a nested map                                                                                                                       |\n| toml/v2    | `toml.Parser()`                  | Parses TOML bytes into a nested map (using go-toml v2)                                                                                                    |\n| dotenv     | `dotenv.Parser()`              | Parses DotEnv bytes into a flat map                                                                                                                       |\n| hcl        | `hcl.Parser(flattenSlices bool)` | Parses Hashicorp HCL bytes into a nested map. `flattenSlices` is recommended to be set to true. [Read more](https://github.com/hashicorp/hcl/issues/162). |\n| nestedtext | `nestedtext.Parser()`              | Parses NestedText bytes into a flat map                                                                                                                 |\n| hjson\t\t | `hjson.Parser()`\t\t\t\t\t| Parses HJSON bytes into a nested map\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n\n\n### Third-party Providers\n| Package             | Provider                                                      | Description                                                                                                                                                                           |\n| ------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| github.com/defensestation/koanf/providers/secretsmanager     | `vault.SecretsManager(secretsmanager.Config{}, f func(s string) string)`                              | AWS Secrets Manager provider, takes map or string as a value from store                                                \t\t\t\t\t\t  |\n| github.com/defensestation/koanf/providers/parameterstore     | `vault.ParameterStore(parameterstore.Config{}, f func(s string) string)`                              | AWS ParameterStore provider, an optional function that takes and returns a string to transform env variables                                                 \t\t\t\t\t\t  |\n\n\n### Alternative to viper\n\nkoanf is a [lightweight](https://github.com/knadh/koanf/blob/master/go.mod) alternative to the popular [spf13/viper](https://github.com/spf13/viper). It was written as a result of multiple stumbling blocks encountered with some of viper's fundamental flaws.\n\n- viper breaks JSON, YAML, TOML, HCL language specs by [forcibly lowercasing keys](https://github.com/spf13/viper/pull/635).\n- Significantly bloats [build sizes](https://github.com/knadh/koanf/wiki/Comparison-with-spf13-viper).\n- Tightly couples config parsing with file extensions.\n- Has poor semantics and abstractions. Commandline, env, file etc. and various parses are hardcoded in the core. There are no primitives that can be extended.\n- Pulls a large number of [third party dependencies](https://github.com/spf13/viper/issues/707) into the core package. For instance, even if you do not use YAML or flags, the dependencies are still pulled as a result of the coupling.\n- Imposes arbitrary ordering conventions (eg: flag -> env -> config etc.)\n- `Get()` returns references to slices and maps. Mutations made outside change the underlying values inside the conf map.\n- Does non-idiomatic things such as [throwing away O(1) on flat maps](https://github.com/spf13/viper/blob/3b4aca75714a37276c4b1883630bd98c02498b73/viper.go#L1524).\n- Viper treats keys that contain an empty map (eg: `my_key: {}`) as if they were not set (ie: `IsSet(\"my_key\") == false`).\n- There are a large number of [open issues](https://github.com/spf13/viper/issues).\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "getters.go",
          "type": "blob",
          "size": 15.291015625,
          "content": "package koanf\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// Int64 returns the int64 value of a given key path or 0 if the path\n// does not exist or if the value is not a valid int64.\nfunc (ko *Koanf) Int64(path string) int64 {\n\tif v := ko.Get(path); v != nil {\n\t\ti, _ := toInt64(v)\n\t\treturn i\n\t}\n\treturn 0\n}\n\n// MustInt64 returns the int64 value of a given key path or panics\n// if the value is not set or set to default value of 0.\nfunc (ko *Koanf) MustInt64(path string) int64 {\n\tval := ko.Int64(path)\n\tif val == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Int64s returns the []int64 slice value of a given key path or an\n// empty []int64 slice if the path does not exist or if the value\n// is not a valid int slice.\nfunc (ko *Koanf) Int64s(path string) []int64 {\n\to := ko.Get(path)\n\tif o == nil {\n\t\treturn []int64{}\n\t}\n\n\tvar out []int64\n\tswitch v := o.(type) {\n\tcase []int64:\n\t\treturn v\n\tcase []int:\n\t\tout = make([]int64, 0, len(v))\n\t\tfor _, vi := range v {\n\t\t\ti, err := toInt64(vi)\n\n\t\t\t// On error, return as it's not a valid\n\t\t\t// int slice.\n\t\t\tif err != nil {\n\t\t\t\treturn []int64{}\n\t\t\t}\n\t\t\tout = append(out, i)\n\t\t}\n\t\treturn out\n\tcase []interface{}:\n\t\tout = make([]int64, 0, len(v))\n\t\tfor _, vi := range v {\n\t\t\ti, err := toInt64(vi)\n\n\t\t\t// On error, return as it's not a valid\n\t\t\t// int slice.\n\t\t\tif err != nil {\n\t\t\t\treturn []int64{}\n\t\t\t}\n\t\t\tout = append(out, i)\n\t\t}\n\t\treturn out\n\t}\n\n\treturn []int64{}\n}\n\n// MustInt64s returns the []int64 slice value of a given key path or panics\n// if the value is not set or its default value.\nfunc (ko *Koanf) MustInt64s(path string) []int64 {\n\tval := ko.Int64s(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Int64Map returns the map[string]int64 value of a given key path\n// or an empty map[string]int64 if the path does not exist or if the\n// value is not a valid int64 map.\nfunc (ko *Koanf) Int64Map(path string) map[string]int64 {\n\tvar (\n\t\tout = map[string]int64{}\n\t\to   = ko.Get(path)\n\t)\n\tif o == nil {\n\t\treturn out\n\t}\n\n\tmp, ok := o.(map[string]interface{})\n\tif !ok {\n\t\treturn out\n\t}\n\n\tout = make(map[string]int64, len(mp))\n\tfor k, v := range mp {\n\t\tswitch i := v.(type) {\n\t\tcase int64:\n\t\t\tout[k] = i\n\t\tdefault:\n\t\t\t// Attempt a conversion.\n\t\t\tiv, err := toInt64(i)\n\t\t\tif err != nil {\n\t\t\t\treturn map[string]int64{}\n\t\t\t}\n\t\t\tout[k] = iv\n\t\t}\n\t}\n\treturn out\n}\n\n// MustInt64Map returns the map[string]int64 value of a given key path\n// or panics if it isn't set or set to default value.\nfunc (ko *Koanf) MustInt64Map(path string) map[string]int64 {\n\tval := ko.Int64Map(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Int returns the int value of a given key path or 0 if the path\n// does not exist or if the value is not a valid int.\nfunc (ko *Koanf) Int(path string) int {\n\treturn int(ko.Int64(path))\n}\n\n// MustInt returns the int value of a given key path or panics\n// if it isn't set or set to default value of 0.\nfunc (ko *Koanf) MustInt(path string) int {\n\tval := ko.Int(path)\n\tif val == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Ints returns the []int slice value of a given key path or an\n// empty []int slice if the path does not exist or if the value\n// is not a valid int slice.\nfunc (ko *Koanf) Ints(path string) []int {\n\to := ko.Get(path)\n\tif o == nil {\n\t\treturn []int{}\n\t}\n\n\tvar out []int\n\tswitch v := o.(type) {\n\tcase []int:\n\t\treturn v\n\tcase []int64:\n\t\tout = make([]int, 0, len(v))\n\t\tfor _, vi := range v {\n\t\t\tout = append(out, int(vi))\n\t\t}\n\t\treturn out\n\tcase []interface{}:\n\t\tout = make([]int, 0, len(v))\n\t\tfor _, vi := range v {\n\t\t\ti, err := toInt64(vi)\n\n\t\t\t// On error, return as it's not a valid\n\t\t\t// int slice.\n\t\t\tif err != nil {\n\t\t\t\treturn []int{}\n\t\t\t}\n\t\t\tout = append(out, int(i))\n\t\t}\n\t\treturn out\n\t}\n\n\treturn []int{}\n}\n\n// MustInts returns the []int slice value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustInts(path string) []int {\n\tval := ko.Ints(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// IntMap returns the map[string]int value of a given key path\n// or an empty map[string]int if the path does not exist or if the\n// value is not a valid int map.\nfunc (ko *Koanf) IntMap(path string) map[string]int {\n\tvar (\n\t\tmp  = ko.Int64Map(path)\n\t\tout = make(map[string]int, len(mp))\n\t)\n\tfor k, v := range mp {\n\t\tout[k] = int(v)\n\t}\n\treturn out\n}\n\n// MustIntMap returns the map[string]int value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustIntMap(path string) map[string]int {\n\tval := ko.IntMap(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Float64 returns the float64 value of a given key path or 0 if the path\n// does not exist or if the value is not a valid float64.\nfunc (ko *Koanf) Float64(path string) float64 {\n\tif v := ko.Get(path); v != nil {\n\t\tf, _ := toFloat64(v)\n\t\treturn f\n\t}\n\treturn 0\n}\n\n// MustFloat64 returns the float64 value of a given key path or panics\n// if it isn't set or set to default value 0.\nfunc (ko *Koanf) MustFloat64(path string) float64 {\n\tval := ko.Float64(path)\n\tif val == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Float64s returns the []float64 slice value of a given key path or an\n// empty []float64 slice if the path does not exist or if the value\n// is not a valid float64 slice.\nfunc (ko *Koanf) Float64s(path string) []float64 {\n\to := ko.Get(path)\n\tif o == nil {\n\t\treturn []float64{}\n\t}\n\n\tvar out []float64\n\tswitch v := o.(type) {\n\tcase []float64:\n\t\treturn v\n\tcase []interface{}:\n\t\tout = make([]float64, 0, len(v))\n\t\tfor _, vi := range v {\n\t\t\ti, err := toFloat64(vi)\n\n\t\t\t// On error, return as it's not a valid\n\t\t\t// int slice.\n\t\t\tif err != nil {\n\t\t\t\treturn []float64{}\n\t\t\t}\n\t\t\tout = append(out, i)\n\t\t}\n\t\treturn out\n\t}\n\n\treturn []float64{}\n}\n\n// MustFloat64s returns the []Float64 slice value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustFloat64s(path string) []float64 {\n\tval := ko.Float64s(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Float64Map returns the map[string]float64 value of a given key path\n// or an empty map[string]float64 if the path does not exist or if the\n// value is not a valid float64 map.\nfunc (ko *Koanf) Float64Map(path string) map[string]float64 {\n\tvar (\n\t\tout = map[string]float64{}\n\t\to   = ko.Get(path)\n\t)\n\tif o == nil {\n\t\treturn out\n\t}\n\n\tmp, ok := o.(map[string]interface{})\n\tif !ok {\n\t\treturn out\n\t}\n\n\tout = make(map[string]float64, len(mp))\n\tfor k, v := range mp {\n\t\tswitch i := v.(type) {\n\t\tcase float64:\n\t\t\tout[k] = i\n\t\tdefault:\n\t\t\t// Attempt a conversion.\n\t\t\tiv, err := toFloat64(i)\n\t\t\tif err != nil {\n\t\t\t\treturn map[string]float64{}\n\t\t\t}\n\t\t\tout[k] = iv\n\t\t}\n\t}\n\treturn out\n}\n\n// MustFloat64Map returns the map[string]float64 value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustFloat64Map(path string) map[string]float64 {\n\tval := ko.Float64Map(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Duration returns the time.Duration value of a given key path assuming\n// that the key contains a valid numeric value.\nfunc (ko *Koanf) Duration(path string) time.Duration {\n\t// Look for a parsable string representation first.\n\tif v := ko.Int64(path); v != 0 {\n\t\treturn time.Duration(v)\n\t}\n\n\tv, _ := time.ParseDuration(ko.String(path))\n\treturn v\n}\n\n// MustDuration returns the time.Duration value of a given key path or panics\n// if it isn't set or set to default value 0.\nfunc (ko *Koanf) MustDuration(path string) time.Duration {\n\tval := ko.Duration(path)\n\tif val == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Time attempts to parse the value of a given key path and return time.Time\n// representation. If the value is numeric, it is treated as a UNIX timestamp\n// and if it's string, a parse is attempted with the given layout.\nfunc (ko *Koanf) Time(path, layout string) time.Time {\n\t// Unix timestamp?\n\tv := ko.Int64(path)\n\tif v != 0 {\n\t\treturn time.Unix(v, 0)\n\t}\n\n\t// String representation.\n\ts := ko.String(path)\n\tif s != \"\" {\n\t\tt, _ := time.Parse(layout, s)\n\t\treturn t\n\t}\n\n\treturn time.Time{}\n}\n\n// MustTime attempts to parse the value of a given key path and return time.Time\n// representation. If the value is numeric, it is treated as a UNIX timestamp\n// and if it's string, a parse is attempted with the given layout. It panics if\n// the parsed time is zero.\nfunc (ko *Koanf) MustTime(path, layout string) time.Time {\n\tval := ko.Time(path, layout)\n\tif val.IsZero() {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// String returns the string value of a given key path or \"\" if the path\n// does not exist or if the value is not a valid string.\nfunc (ko *Koanf) String(path string) string {\n\tif v := ko.Get(path); v != nil {\n\t\tif i, ok := v.(string); ok {\n\t\t\treturn i\n\t\t}\n\t\treturn fmt.Sprintf(\"%v\", v)\n\t}\n\treturn \"\"\n}\n\n// MustString returns the string value of a given key path\n// or panics if it isn't set or set to default value \"\".\nfunc (ko *Koanf) MustString(path string) string {\n\tval := ko.String(path)\n\tif val == \"\" {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Strings returns the []string slice value of a given key path or an\n// empty []string slice if the path does not exist or if the value\n// is not a valid string slice.\nfunc (ko *Koanf) Strings(path string) []string {\n\to := ko.Get(path)\n\tif o == nil {\n\t\treturn []string{}\n\t}\n\n\tvar out []string\n\tswitch v := o.(type) {\n\tcase []interface{}:\n\t\tout = make([]string, 0, len(v))\n\t\tfor _, u := range v {\n\t\t\tif s, ok := u.(string); ok {\n\t\t\t\tout = append(out, s)\n\t\t\t} else {\n\t\t\t\tout = append(out, fmt.Sprintf(\"%v\", u))\n\t\t\t}\n\t\t}\n\t\treturn out\n\tcase []string:\n\t\tout := make([]string, len(v))\n\t\tcopy(out, v)\n\t\treturn out\n\t}\n\n\treturn []string{}\n}\n\n// MustStrings returns the []string slice value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustStrings(path string) []string {\n\tval := ko.Strings(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// StringMap returns the map[string]string value of a given key path\n// or an empty map[string]string if the path does not exist or if the\n// value is not a valid string map.\nfunc (ko *Koanf) StringMap(path string) map[string]string {\n\tvar (\n\t\tout = map[string]string{}\n\t\to   = ko.Get(path)\n\t)\n\tif o == nil {\n\t\treturn out\n\t}\n\n\tswitch mp := o.(type) {\n\tcase map[string]string:\n\t\tout = make(map[string]string, len(mp))\n\t\tfor k, v := range mp {\n\t\t\tout[k] = v\n\t\t}\n\tcase map[string]interface{}:\n\t\tout = make(map[string]string, len(mp))\n\t\tfor k, v := range mp {\n\t\t\tswitch s := v.(type) {\n\t\t\tcase string:\n\t\t\t\tout[k] = s\n\t\t\tdefault:\n\t\t\t\t// There's a non string type. Return.\n\t\t\t\treturn map[string]string{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out\n}\n\n// MustStringMap returns the map[string]string value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustStringMap(path string) map[string]string {\n\tval := ko.StringMap(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// StringsMap returns the map[string][]string value of a given key path\n// or an empty map[string][]string if the path does not exist or if the\n// value is not a valid strings map.\nfunc (ko *Koanf) StringsMap(path string) map[string][]string {\n\tvar (\n\t\tout = map[string][]string{}\n\t\to   = ko.Get(path)\n\t)\n\tif o == nil {\n\t\treturn out\n\t}\n\n\tswitch mp := o.(type) {\n\tcase map[string][]string:\n\t\tout = make(map[string][]string, len(mp))\n\t\tfor k, v := range mp {\n\t\t\tout[k] = append(out[k], v...)\n\t\t}\n\tcase map[string][]interface{}:\n\t\tout = make(map[string][]string, len(mp))\n\t\tfor k, v := range mp {\n\t\t\tfor _, v := range v {\n\t\t\t\tswitch sv := v.(type) {\n\t\t\t\tcase string:\n\t\t\t\t\tout[k] = append(out[k], sv)\n\t\t\t\tdefault:\n\t\t\t\t\treturn map[string][]string{}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tcase map[string]interface{}:\n\t\tout = make(map[string][]string, len(mp))\n\t\tfor k, v := range mp {\n\t\t\tswitch s := v.(type) {\n\t\t\tcase []string:\n\t\t\t\tout[k] = append(out[k], s...)\n\t\t\tcase []interface{}:\n\t\t\t\tfor _, v := range s {\n\t\t\t\t\tswitch sv := v.(type) {\n\t\t\t\t\tcase string:\n\t\t\t\t\t\tout[k] = append(out[k], sv)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn map[string][]string{}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\t// There's a non []interface type. Return.\n\t\t\t\treturn map[string][]string{}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn out\n}\n\n// MustStringsMap returns the map[string][]string value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustStringsMap(path string) map[string][]string {\n\tval := ko.StringsMap(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Bytes returns the []byte value of a given key path or an empty\n// []byte slice if the path does not exist or if the value is not a valid string.\nfunc (ko *Koanf) Bytes(path string) []byte {\n\treturn []byte(ko.String(path))\n}\n\n// MustBytes returns the []byte value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustBytes(path string) []byte {\n\tval := ko.Bytes(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// Bool returns the bool value of a given key path or false if the path\n// does not exist or if the value is not a valid bool representation.\n// Accepted string representations of bool are the ones supported by strconv.ParseBool.\nfunc (ko *Koanf) Bool(path string) bool {\n\tif v := ko.Get(path); v != nil {\n\t\tb, _ := toBool(v)\n\t\treturn b\n\t}\n\treturn false\n}\n\n// Bools returns the []bool slice value of a given key path or an\n// empty []bool slice if the path does not exist or if the value\n// is not a valid bool slice.\nfunc (ko *Koanf) Bools(path string) []bool {\n\to := ko.Get(path)\n\tif o == nil {\n\t\treturn []bool{}\n\t}\n\n\tvar out []bool\n\tswitch v := o.(type) {\n\tcase []interface{}:\n\t\tout = make([]bool, 0, len(v))\n\t\tfor _, u := range v {\n\t\t\tb, err := toBool(u)\n\t\t\tif err != nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tout = append(out, b)\n\t\t}\n\t\treturn out\n\tcase []bool:\n\t\treturn out\n\t}\n\treturn nil\n}\n\n// MustBools returns the []bool value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustBools(path string) []bool {\n\tval := ko.Bools(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n\n// BoolMap returns the map[string]bool value of a given key path\n// or an empty map[string]bool if the path does not exist or if the\n// value is not a valid bool map.\nfunc (ko *Koanf) BoolMap(path string) map[string]bool {\n\tvar (\n\t\tout = map[string]bool{}\n\t\to   = ko.Get(path)\n\t)\n\tif o == nil {\n\t\treturn out\n\t}\n\n\tmp, ok := o.(map[string]interface{})\n\tif !ok {\n\t\treturn out\n\t}\n\tout = make(map[string]bool, len(mp))\n\tfor k, v := range mp {\n\t\tswitch i := v.(type) {\n\t\tcase bool:\n\t\t\tout[k] = i\n\t\tdefault:\n\t\t\t// Attempt a conversion.\n\t\t\tb, err := toBool(i)\n\t\t\tif err != nil {\n\t\t\t\treturn map[string]bool{}\n\t\t\t}\n\t\t\tout[k] = b\n\t\t}\n\t}\n\n\treturn out\n}\n\n// MustBoolMap returns the map[string]bool value of a given key path or panics\n// if the value is not set or set to default value.\nfunc (ko *Koanf) MustBoolMap(path string) map[string]bool {\n\tval := ko.BoolMap(path)\n\tif len(val) == 0 {\n\t\tpanic(fmt.Sprintf(\"invalid value: %s=%v\", path, val))\n\t}\n\treturn val\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.306640625,
          "content": "module github.com/knadh/koanf/v2\n\ngo 1.18\n\nrequire (\n\tgithub.com/go-viper/mapstructure/v2 v2.2.1\n\tgithub.com/knadh/koanf/maps v0.1.1\n\tgithub.com/mitchellh/copystructure v1.2.0\n)\n\nrequire github.com/mitchellh/reflectwalk v1.0.2 // indirect\n\nretract v2.0.2 // Tagged as minor version, but contains breaking changes.\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.71484375,
          "content": "github.com/go-viper/mapstructure/v2 v2.2.1 h1:ZAaOCxANMuZx5RCeg0mBdEZk7DZasvvZIxtHqx8aGss=\ngithub.com/go-viper/mapstructure/v2 v2.2.1/go.mod h1:oJDH3BJKyqBA2TXFhDsKDGDTlndYOZ6rGS0BRZIxGhM=\ngithub.com/knadh/koanf/maps v0.1.1 h1:G5TjmUh2D7G2YWf5SQQqSiHRJEjaicvU0KpypqB3NIs=\ngithub.com/knadh/koanf/maps v0.1.1/go.mod h1:npD/QZY3V6ghQDdcQzl1W4ICNVTkohC8E73eI2xW4yI=\ngithub.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=\ngithub.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=\ngithub.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=\ngithub.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\n"
        },
        {
          "name": "go.work",
          "type": "blob",
          "size": 0.49609375,
          "content": "go 1.18\n\nuse (\n\t.\n\t./examples\n\t./maps\n\t./parsers/dotenv\n\t./parsers/hcl\n\t./parsers/hjson\n\t./parsers/json\n\t./parsers/kdl\n\t./parsers/nestedtext\n\t./parsers/toml\n\t./parsers/yaml\n\t./providers/appconfig\n\t./providers/basicflag\n\t./providers/confmap\n\t./providers/consul\n\t./providers/env\n\t./providers/etcd\n\t./providers/file\n\t./providers/fs\n\t./providers/nats\n\t./providers/parameterstore\n\t./providers/posflag\n\t./providers/rawbytes\n\t./providers/s3\n\t./providers/structs\n\t./providers/vault\n\t./providers/cliflagv2\n\t./tests\n)\n"
        },
        {
          "name": "go.work.sum",
          "type": "blob",
          "size": 14.0341796875,
          "content": "cloud.google.com/go v0.110.0/go.mod h1:SJnCLqQ0FCFGSZMUNUf84MV3Aia54kn7pi8st7tMzaY=\ncloud.google.com/go/accessapproval v1.6.0/go.mod h1:R0EiYnwV5fsRFiKZkPHr6mwyk2wxUJ30nL4j2pcFY2E=\ncloud.google.com/go/accesscontextmanager v1.7.0/go.mod h1:CEGLewx8dwa33aDAZQujl7Dx+uYhS0eay198wB/VumQ=\ncloud.google.com/go/aiplatform v1.37.0/go.mod h1:IU2Cv29Lv9oCn/9LkFiiuKfwrRTq+QQMbW+hPCxJGZw=\ncloud.google.com/go/analytics v0.19.0/go.mod h1:k8liqf5/HCnOUkbawNtrWWc+UAzyDlW89doe8TtoDsE=\ncloud.google.com/go/apigateway v1.5.0/go.mod h1:GpnZR3Q4rR7LVu5951qfXPJCHquZt02jf7xQx7kpqN8=\ncloud.google.com/go/apigeeconnect v1.5.0/go.mod h1:KFaCqvBRU6idyhSNyn3vlHXc8VMDJdRmwDF6JyFRqZ8=\ncloud.google.com/go/apigeeregistry v0.6.0/go.mod h1:BFNzW7yQVLZ3yj0TKcwzb8n25CFBri51GVGOEUcgQsc=\ncloud.google.com/go/apikeys v0.6.0/go.mod h1:kbpXu5upyiAlGkKrJgQl8A0rKNNJ7dQ377pdroRSSi8=\ncloud.google.com/go/appengine v1.7.1/go.mod h1:IHLToyb/3fKutRysUlFO0BPt5j7RiQ45nrzEJmKTo6E=\ncloud.google.com/go/area120 v0.7.1/go.mod h1:j84i4E1RboTWjKtZVWXPqvK5VHQFJRF2c1Nm69pWm9k=\ncloud.google.com/go/artifactregistry v1.13.0/go.mod h1:uy/LNfoOIivepGhooAUpL1i30Hgee3Cu0l4VTWHUC08=\ncloud.google.com/go/asset v1.13.0/go.mod h1:WQAMyYek/b7NBpYq/K4KJWcRqzoalEsxz/t/dTk4THw=\ncloud.google.com/go/assuredworkloads v1.10.0/go.mod h1:kwdUQuXcedVdsIaKgKTp9t0UJkE5+PAVNhdQm4ZVq2E=\ncloud.google.com/go/automl v1.12.0/go.mod h1:tWDcHDp86aMIuHmyvjuKeeHEGq76lD7ZqfGLN6B0NuU=\ncloud.google.com/go/baremetalsolution v0.5.0/go.mod h1:dXGxEkmR9BMwxhzBhV0AioD0ULBmuLZI8CdwalUxuss=\ncloud.google.com/go/batch v0.7.0/go.mod h1:vLZN95s6teRUqRQ4s3RLDsH8PvboqBK+rn1oevL159g=\ncloud.google.com/go/beyondcorp v0.5.0/go.mod h1:uFqj9X+dSfrheVp7ssLTaRHd2EHqSL4QZmH4e8WXGGU=\ncloud.google.com/go/bigquery v1.50.0/go.mod h1:YrleYEh2pSEbgTBZYMJ5SuSr0ML3ypjRB1zgf7pvQLU=\ncloud.google.com/go/billing v1.13.0/go.mod h1:7kB2W9Xf98hP9Sr12KfECgfGclsH3CQR0R08tnRlRbc=\ncloud.google.com/go/binaryauthorization v1.5.0/go.mod h1:OSe4OU1nN/VswXKRBmciKpo9LulY41gch5c68htf3/Q=\ncloud.google.com/go/certificatemanager v1.6.0/go.mod h1:3Hh64rCKjRAX8dXgRAyOcY5vQ/fE1sh8o+Mdd6KPgY8=\ncloud.google.com/go/channel v1.12.0/go.mod h1:VkxCGKASi4Cq7TbXxlaBezonAYpp1GCnKMY6tnMQnLU=\ncloud.google.com/go/cloudbuild v1.9.0/go.mod h1:qK1d7s4QlO0VwfYn5YuClDGg2hfmLZEb4wQGAbIgL1s=\ncloud.google.com/go/clouddms v1.5.0/go.mod h1:QSxQnhikCLUw13iAbffF2CZxAER3xDGNHjsTAkQJcQA=\ncloud.google.com/go/cloudtasks v1.10.0/go.mod h1:NDSoTLkZ3+vExFEWu2UJV1arUyzVDAiZtdWcsUyNwBs=\ncloud.google.com/go/compute v1.19.1/go.mod h1:6ylj3a05WF8leseCdIf77NK0g1ey+nj5IKd5/kvShxE=\ncloud.google.com/go/compute/metadata v0.2.3/go.mod h1:VAV5nSsACxMJvgaAuX6Pk2AawlZn8kiOGuCv6gTkwuA=\ncloud.google.com/go/contactcenterinsights v1.6.0/go.mod h1:IIDlT6CLcDoyv79kDv8iWxMSTZhLxSCofVV5W6YFM/w=\ncloud.google.com/go/container v1.15.0/go.mod h1:ft+9S0WGjAyjDggg5S06DXj+fHJICWg8L7isCQe9pQA=\ncloud.google.com/go/containeranalysis v0.9.0/go.mod h1:orbOANbwk5Ejoom+s+DUCTTJ7IBdBQJDcSylAx/on9s=\ncloud.google.com/go/datacatalog v1.13.0/go.mod h1:E4Rj9a5ZtAxcQJlEBTLgMTphfP11/lNaAshpoBgemX8=\ncloud.google.com/go/dataflow v0.8.0/go.mod h1:Rcf5YgTKPtQyYz8bLYhFoIV/vP39eL7fWNcSOyFfLJE=\ncloud.google.com/go/dataform v0.7.0/go.mod h1:7NulqnVozfHvWUBpMDfKMUESr+85aJsC/2O0o3jWPDE=\ncloud.google.com/go/datafusion v1.6.0/go.mod h1:WBsMF8F1RhSXvVM8rCV3AeyWVxcC2xY6vith3iw3S+8=\ncloud.google.com/go/datalabeling v0.7.0/go.mod h1:WPQb1y08RJbmpM3ww0CSUAGweL0SxByuW2E+FU+wXcM=\ncloud.google.com/go/dataplex v1.6.0/go.mod h1:bMsomC/aEJOSpHXdFKFGQ1b0TDPIeL28nJObeO1ppRs=\ncloud.google.com/go/dataproc v1.12.0/go.mod h1:zrF3aX0uV3ikkMz6z4uBbIKyhRITnxvr4i3IjKsKrw4=\ncloud.google.com/go/dataqna v0.7.0/go.mod h1:Lx9OcIIeqCrw1a6KdO3/5KMP1wAmTc0slZWwP12Qq3c=\ncloud.google.com/go/datastore v1.11.0/go.mod h1:TvGxBIHCS50u8jzG+AW/ppf87v1of8nwzFNgEZU1D3c=\ncloud.google.com/go/datastream v1.7.0/go.mod h1:uxVRMm2elUSPuh65IbZpzJNMbuzkcvu5CjMqVIUHrww=\ncloud.google.com/go/deploy v1.8.0/go.mod h1:z3myEJnA/2wnB4sgjqdMfgxCA0EqC3RBTNcVPs93mtQ=\ncloud.google.com/go/dialogflow v1.32.0/go.mod h1:jG9TRJl8CKrDhMEcvfcfFkkpp8ZhgPz3sBGmAUYJ2qE=\ncloud.google.com/go/dlp v1.9.0/go.mod h1:qdgmqgTyReTz5/YNSSuueR8pl7hO0o9bQ39ZhtgkWp4=\ncloud.google.com/go/documentai v1.18.0/go.mod h1:F6CK6iUH8J81FehpskRmhLq/3VlwQvb7TvwOceQ2tbs=\ncloud.google.com/go/domains v0.8.0/go.mod h1:M9i3MMDzGFXsydri9/vW+EWz9sWb4I6WyHqdlAk0idE=\ncloud.google.com/go/edgecontainer v1.0.0/go.mod h1:cttArqZpBB2q58W/upSG++ooo6EsblxDIolxa3jSjbY=\ncloud.google.com/go/errorreporting v0.3.0/go.mod h1:xsP2yaAp+OAW4OIm60An2bbLpqIhKXdWR/tawvl7QzU=\ncloud.google.com/go/essentialcontacts v1.5.0/go.mod h1:ay29Z4zODTuwliK7SnX8E86aUF2CTzdNtvv42niCX0M=\ncloud.google.com/go/eventarc v1.11.0/go.mod h1:PyUjsUKPWoRBCHeOxZd/lbOOjahV41icXyUY5kSTvVY=\ncloud.google.com/go/filestore v1.6.0/go.mod h1:di5unNuss/qfZTw2U9nhFqo8/ZDSc466dre85Kydllg=\ncloud.google.com/go/firestore v1.9.0/go.mod h1:HMkjKHNTtRyZNiMzu7YAsLr9K3X2udY2AMwDaMEQiiE=\ncloud.google.com/go/functions v1.13.0/go.mod h1:EU4O007sQm6Ef/PwRsI8N2umygGqPBS/IZQKBQBcJ3c=\ncloud.google.com/go/gaming v1.9.0/go.mod h1:Fc7kEmCObylSWLO334NcO+O9QMDyz+TKC4v1D7X+Bc0=\ncloud.google.com/go/gkebackup v0.4.0/go.mod h1:byAyBGUwYGEEww7xsbnUTBHIYcOPy/PgUWUtOeRm9Vg=\ncloud.google.com/go/gkeconnect v0.7.0/go.mod h1:SNfmVqPkaEi3bF/B3CNZOAYPYdg7sU+obZ+QTky2Myw=\ncloud.google.com/go/gkehub v0.12.0/go.mod h1:djiIwwzTTBrF5NaXCGv3mf7klpEMcST17VBTVVDcuaw=\ncloud.google.com/go/gkemulticloud v0.5.0/go.mod h1:W0JDkiyi3Tqh0TJr//y19wyb1yf8llHVto2Htf2Ja3Y=\ncloud.google.com/go/gsuiteaddons v1.5.0/go.mod h1:TFCClYLd64Eaa12sFVmUyG62tk4mdIsI7pAnSXRkcFo=\ncloud.google.com/go/iam v0.13.0/go.mod h1:ljOg+rcNfzZ5d6f1nAUJ8ZIxOaZUVoS14bKCtaLZ/D0=\ncloud.google.com/go/iap v1.7.1/go.mod h1:WapEwPc7ZxGt2jFGB/C/bm+hP0Y6NXzOYGjpPnmMS74=\ncloud.google.com/go/ids v1.3.0/go.mod h1:JBdTYwANikFKaDP6LtW5JAi4gubs57SVNQjemdt6xV4=\ncloud.google.com/go/iot v1.6.0/go.mod h1:IqdAsmE2cTYYNO1Fvjfzo9po179rAtJeVGUvkLN3rLE=\ncloud.google.com/go/kms v1.10.1/go.mod h1:rIWk/TryCkR59GMC3YtHtXeLzd634lBbKenvyySAyYI=\ncloud.google.com/go/language v1.9.0/go.mod h1:Ns15WooPM5Ad/5no/0n81yUetis74g3zrbeJBE+ptUY=\ncloud.google.com/go/lifesciences v0.8.0/go.mod h1:lFxiEOMqII6XggGbOnKiyZ7IBwoIqA84ClvoezaA/bo=\ncloud.google.com/go/logging v1.7.0/go.mod h1:3xjP2CjkM3ZkO73aj4ASA5wRPGGCRrPIAeNqVNkzY8M=\ncloud.google.com/go/longrunning v0.4.1/go.mod h1:4iWDqhBZ70CvZ6BfETbvam3T8FMvLK+eFj0E6AaRQTo=\ncloud.google.com/go/managedidentities v1.5.0/go.mod h1:+dWcZ0JlUmpuxpIDfyP5pP5y0bLdRwOS4Lp7gMni/LA=\ncloud.google.com/go/maps v0.7.0/go.mod h1:3GnvVl3cqeSvgMcpRlQidXsPYuDGQ8naBis7MVzpXsY=\ncloud.google.com/go/mediatranslation v0.7.0/go.mod h1:LCnB/gZr90ONOIQLgSXagp8XUW1ODs2UmUMvcgMfI2I=\ncloud.google.com/go/memcache v1.9.0/go.mod h1:8oEyzXCu+zo9RzlEaEjHl4KkgjlNDaXbCQeQWlzNFJM=\ncloud.google.com/go/metastore v1.10.0/go.mod h1:fPEnH3g4JJAk+gMRnrAnoqyv2lpUCqJPWOodSaf45Eo=\ncloud.google.com/go/monitoring v1.13.0/go.mod h1:k2yMBAB1H9JT/QETjNkgdCGD9bPF712XiLTVr+cBrpw=\ncloud.google.com/go/networkconnectivity v1.11.0/go.mod h1:iWmDD4QF16VCDLXUqvyspJjIEtBR/4zq5hwnY2X3scM=\ncloud.google.com/go/networkmanagement v1.6.0/go.mod h1:5pKPqyXjB/sgtvB5xqOemumoQNB7y95Q7S+4rjSOPYY=\ncloud.google.com/go/networksecurity v0.8.0/go.mod h1:B78DkqsxFG5zRSVuwYFRZ9Xz8IcQ5iECsNrPn74hKHU=\ncloud.google.com/go/notebooks v1.8.0/go.mod h1:Lq6dYKOYOWUCTvw5t2q1gp1lAp0zxAxRycayS0iJcqQ=\ncloud.google.com/go/optimization v1.3.1/go.mod h1:IvUSefKiwd1a5p0RgHDbWCIbDFgKuEdB+fPPuP0IDLI=\ncloud.google.com/go/orchestration v1.6.0/go.mod h1:M62Bevp7pkxStDfFfTuCOaXgaaqRAga1yKyoMtEoWPQ=\ncloud.google.com/go/orgpolicy v1.10.0/go.mod h1:w1fo8b7rRqlXlIJbVhOMPrwVljyuW5mqssvBtU18ONc=\ncloud.google.com/go/osconfig v1.11.0/go.mod h1:aDICxrur2ogRd9zY5ytBLV89KEgT2MKB2L/n6x1ooPw=\ncloud.google.com/go/oslogin v1.9.0/go.mod h1:HNavntnH8nzrn8JCTT5fj18FuJLFJc4NaZJtBnQtKFs=\ncloud.google.com/go/phishingprotection v0.7.0/go.mod h1:8qJI4QKHoda/sb/7/YmMQ2omRLSLYSu9bU0EKCNI+Lk=\ncloud.google.com/go/policytroubleshooter v1.6.0/go.mod h1:zYqaPTsmfvpjm5ULxAyD/lINQxJ0DDsnWOP/GZ7xzBc=\ncloud.google.com/go/privatecatalog v0.8.0/go.mod h1:nQ6pfaegeDAq/Q5lrfCQzQLhubPiZhSaNhIgfJlnIXs=\ncloud.google.com/go/pubsub v1.30.0/go.mod h1:qWi1OPS0B+b5L+Sg6Gmc9zD1Y+HaM0MdUr7LsupY1P4=\ncloud.google.com/go/pubsublite v1.7.0/go.mod h1:8hVMwRXfDfvGm3fahVbtDbiLePT3gpoiJYJY+vxWxVM=\ncloud.google.com/go/recaptchaenterprise/v2 v2.7.0/go.mod h1:19wVj/fs5RtYtynAPJdDTb69oW0vNHYDBTbB4NvMD9c=\ncloud.google.com/go/recommendationengine v0.7.0/go.mod h1:1reUcE3GIu6MeBz/h5xZJqNLuuVjNg1lmWMPyjatzac=\ncloud.google.com/go/recommender v1.9.0/go.mod h1:PnSsnZY7q+VL1uax2JWkt/UegHssxjUVVCrX52CuEmQ=\ncloud.google.com/go/redis v1.11.0/go.mod h1:/X6eicana+BWcUda5PpwZC48o37SiFVTFSs0fWAJ7uQ=\ncloud.google.com/go/resourcemanager v1.7.0/go.mod h1:HlD3m6+bwhzj9XCouqmeiGuni95NTrExfhoSrkC/3EI=\ncloud.google.com/go/resourcesettings v1.5.0/go.mod h1:+xJF7QSG6undsQDfsCJyqWXyBwUoJLhetkRMDRnIoXA=\ncloud.google.com/go/retail v1.12.0/go.mod h1:UMkelN/0Z8XvKymXFbD4EhFJlYKRx1FGhQkVPU5kF14=\ncloud.google.com/go/run v0.9.0/go.mod h1:Wwu+/vvg8Y+JUApMwEDfVfhetv30hCG4ZwDR/IXl2Qg=\ncloud.google.com/go/scheduler v1.9.0/go.mod h1:yexg5t+KSmqu+njTIh3b7oYPheFtBWGcbVUYF1GGMIc=\ncloud.google.com/go/secretmanager v1.10.0/go.mod h1:MfnrdvKMPNra9aZtQFvBcvRU54hbPD8/HayQdlUgJpU=\ncloud.google.com/go/security v1.13.0/go.mod h1:Q1Nvxl1PAgmeW0y3HTt54JYIvUdtcpYKVfIB8AOMZ+0=\ncloud.google.com/go/securitycenter v1.19.0/go.mod h1:LVLmSg8ZkkyaNy4u7HCIshAngSQ8EcIRREP3xBnyfag=\ncloud.google.com/go/servicecontrol v1.11.1/go.mod h1:aSnNNlwEFBY+PWGQ2DoM0JJ/QUXqV5/ZD9DOLB7SnUk=\ncloud.google.com/go/servicedirectory v1.9.0/go.mod h1:29je5JjiygNYlmsGz8k6o+OZ8vd4f//bQLtvzkPPT/s=\ncloud.google.com/go/servicemanagement v1.8.0/go.mod h1:MSS2TDlIEQD/fzsSGfCdJItQveu9NXnUniTrq/L8LK4=\ncloud.google.com/go/serviceusage v1.6.0/go.mod h1:R5wwQcbOWsyuOfbP9tGdAnCAc6B9DRwPG1xtWMDeuPA=\ncloud.google.com/go/shell v1.6.0/go.mod h1:oHO8QACS90luWgxP3N9iZVuEiSF84zNyLytb+qE2f9A=\ncloud.google.com/go/spanner v1.45.0/go.mod h1:FIws5LowYz8YAE1J8fOS7DJup8ff7xJeetWEo5REA2M=\ncloud.google.com/go/speech v1.15.0/go.mod h1:y6oH7GhqCaZANH7+Oe0BhgIogsNInLlz542tg3VqeYI=\ncloud.google.com/go/storagetransfer v1.8.0/go.mod h1:JpegsHHU1eXg7lMHkvf+KE5XDJ7EQu0GwNJbbVGanEw=\ncloud.google.com/go/talent v1.5.0/go.mod h1:G+ODMj9bsasAEJkQSzO2uHQWXHHXUomArjWQQYkqK6c=\ncloud.google.com/go/texttospeech v1.6.0/go.mod h1:YmwmFT8pj1aBblQOI3TfKmwibnsfvhIBzPXcW4EBovc=\ncloud.google.com/go/tpu v1.5.0/go.mod h1:8zVo1rYDFuW2l4yZVY0R0fb/v44xLh3llq7RuV61fPM=\ncloud.google.com/go/trace v1.9.0/go.mod h1:lOQqpE5IaWY0Ixg7/r2SjixMuc6lfTFeO4QGM4dQWOk=\ncloud.google.com/go/translate v1.7.0/go.mod h1:lMGRudH1pu7I3n3PETiOB2507gf3HnfLV8qlkHZEyos=\ncloud.google.com/go/video v1.15.0/go.mod h1:SkgaXwT+lIIAKqWAJfktHT/RbgjSuY6DobxEp0C5yTQ=\ncloud.google.com/go/videointelligence v1.10.0/go.mod h1:LHZngX1liVtUhZvi2uNS0VQuOzNi2TkY1OakiuoUOjU=\ncloud.google.com/go/vision/v2 v2.7.0/go.mod h1:H89VysHy21avemp6xcf9b9JvZHVehWbET0uT/bcuY/0=\ncloud.google.com/go/vmmigration v1.6.0/go.mod h1:bopQ/g4z+8qXzichC7GW1w2MjbErL54rk3/C843CjfY=\ncloud.google.com/go/vmwareengine v0.3.0/go.mod h1:wvoyMvNWdIzxMYSpH/R7y2h5h3WFkx6d+1TIsP39WGY=\ncloud.google.com/go/vpcaccess v1.6.0/go.mod h1:wX2ILaNhe7TlVa4vC5xce1bCnqE3AeH27RV31lnmZes=\ncloud.google.com/go/webrisk v1.8.0/go.mod h1:oJPDuamzHXgUc+b8SiHRcVInZQuybnvEW72PqTc7sSg=\ncloud.google.com/go/websecurityscanner v1.5.0/go.mod h1:Y6xdCPy81yi0SQnDY1xdNTNpfY1oAgXUlcfN3B3eSng=\ncloud.google.com/go/workflows v1.10.0/go.mod h1:fZ8LmRmZQWacon9UCX1r/g/DfAXx5VcPALq2CxzdePw=\ngithub.com/benbjohnson/clock v1.1.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=\ngithub.com/census-instrumentation/opencensus-proto v0.4.1/go.mod h1:4T9NM4+4Vw91VeyqjLS6ao50K5bOcLKN6Q42XnYaRYw=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cncf/udpa/go v0.0.0-20220112060539-c52dc94e7fbe/go.mod h1:6pvJx4me5XPnfI9Z40ddWsdw2W/uZgQLFXToKeRcDiI=\ngithub.com/cncf/xds/go v0.0.0-20230607035331-e9ce68804cb4/go.mod h1:eXthEFrGJvWHgFFCl3hGmgk+/aYT6PnTQLykKQRLhEs=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/envoyproxy/go-control-plane v0.11.1-0.20230524094728-9239064ad72f/go.mod h1:sfYdkwUW4BA3PbKjySwjJy+O4Pu0h62rlqCMHNk+K+Q=\ngithub.com/envoyproxy/protoc-gen-validate v0.10.1/go.mod h1:DRjgyB0I43LtJapqN6NiRwroiAU2PaFuvk/vjgh61ss=\ngithub.com/go-test/deep v1.0.2/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\ngithub.com/golang/glog v1.1.0/go.mod h1:pfYeQZ3JWZoXTV5sFc986z3HTpwQs9At6P4ImfuP3NQ=\ngithub.com/google/uuid v1.3.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=\ngithub.com/hashicorp/consul/sdk v0.13.1/go.mod h1:SW/mM4LbKfqmMvcFu8v+eiQQ7oitXEFeiBe9StxERb0=\ngithub.com/hashicorp/go-uuid v1.0.2/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/go-version v1.2.1/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=\ngithub.com/prometheus/client_golang v1.11.1/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=\ngithub.com/prometheus/common v0.26.0/go.mod h1:M7rCNAaPfAosfx8veZJCuw84e35h3Cfd9VFqTh1DIvc=\ngithub.com/prometheus/procfs v0.6.0/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=\ngo.uber.org/automaxprocs v1.5.3/go.mod h1:eRbA25aqJrxAbsLO0xy5jVwPt7FQnRgjW+efnwa1WM0=\ngo.uber.org/goleak v1.1.11/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/oauth2 v0.7.0/go.mod h1:hPLQkd9LyjfXTiRohC/41GhcFqxisoUQ99sCUOHO9x4=\ngolang.org/x/sys v0.4.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.14.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.15.0/go.mod h1:BDl952bC7+uMoWR75FIrCDx79TPU9oHkTZ9yRbYOrX0=\ngolang.org/x/term v0.18.0/go.mod h1:ILwASektA3OnRv7amZ1xhE/KTR+u50pbXfZ03+6Nx58=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\nsigs.k8s.io/yaml v1.2.0/go.mod h1:yfXDCHCao9+ENCvLSE62v9VSji2MKu5jeNfTrofGhJc=\n"
        },
        {
          "name": "interfaces.go",
          "type": "blob",
          "size": 0.7236328125,
          "content": "package koanf\n\n// Provider represents a configuration provider. Providers can\n// read configuration from a source (file, HTTP etc.)\ntype Provider interface {\n\t// ReadBytes returns the entire configuration as raw []bytes to be parsed.\n\t// with a Parser.\n\tReadBytes() ([]byte, error)\n\n\t// Read returns the parsed configuration as a nested map[string]interface{}.\n\t// It is important to note that the string keys should not be flat delimited\n\t// keys like `parent.child.key`, but nested like `{parent: {child: {key: 1}}}`.\n\tRead() (map[string]interface{}, error)\n}\n\n// Parser represents a configuration format parser.\ntype Parser interface {\n\tUnmarshal([]byte) (map[string]interface{}, error)\n\tMarshal(map[string]interface{}) ([]byte, error)\n}\n"
        },
        {
          "name": "koanf.go",
          "type": "blob",
          "size": 15.4072265625,
          "content": "package koanf\n\nimport (\n\t\"bytes\"\n\t\"encoding\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\n\t\"github.com/knadh/koanf/maps\"\n\t\"github.com/mitchellh/copystructure\"\n\t\"github.com/go-viper/mapstructure/v2\"\n)\n\n// Koanf is the configuration apparatus.\ntype Koanf struct {\n\tconfMap     map[string]interface{}\n\tconfMapFlat map[string]interface{}\n\tkeyMap      KeyMap\n\tconf        Conf\n}\n\n// Conf is the Koanf configuration.\ntype Conf struct {\n\t// Delim is the delimiter to use\n\t// when specifying config key paths, for instance a . for `parent.child.key`\n\t// or a / for `parent/child/key`.\n\tDelim string\n\n\t// StrictMerge makes the merging behavior strict.\n\t// Meaning when loading two files that have the same key,\n\t// the first loaded file will define the desired type, and if the second file loads\n\t// a different type will cause an error.\n\tStrictMerge bool\n}\n\n// KeyMap represents a map of flattened delimited keys and the non-delimited\n// parts as their slices. For nested keys, the map holds all levels of path combinations.\n// For example, the nested structure `parent -> child -> key` will produce the map:\n// parent.child.key => [parent, child, key]\n// parent.child => [parent, child]\n// parent => [parent]\ntype KeyMap map[string][]string\n\n// UnmarshalConf represents configuration options used by\n// Unmarshal() to unmarshal conf maps into arbitrary structs.\ntype UnmarshalConf struct {\n\t// Tag is the struct field tag to unmarshal.\n\t// `koanf` is used if left empty.\n\tTag string\n\n\t// If this is set to true, instead of unmarshalling nested structures\n\t// based on the key path, keys are taken literally to unmarshal into\n\t// a flat struct. For example:\n\t// ```\n\t// type MyStuff struct {\n\t// \tChild1Name string `koanf:\"parent1.child1.name\"`\n\t// \tChild2Name string `koanf:\"parent2.child2.name\"`\n\t// \tType       string `koanf:\"json\"`\n\t// }\n\t// ```\n\tFlatPaths     bool\n\tDecoderConfig *mapstructure.DecoderConfig\n}\n\n// New returns a new instance of Koanf. delim is the delimiter to use\n// when specifying config key paths, for instance a . for `parent.child.key`\n// or a / for `parent/child/key`.\nfunc New(delim string) *Koanf {\n\treturn NewWithConf(Conf{\n\t\tDelim:       delim,\n\t\tStrictMerge: false,\n\t})\n}\n\n// NewWithConf returns a new instance of Koanf based on the Conf.\nfunc NewWithConf(conf Conf) *Koanf {\n\treturn &Koanf{\n\t\tconfMap:     make(map[string]interface{}),\n\t\tconfMapFlat: make(map[string]interface{}),\n\t\tkeyMap:      make(KeyMap),\n\t\tconf:        conf,\n\t}\n}\n\n// Load takes a Provider that either provides a parsed config map[string]interface{}\n// in which case pa (Parser) can be nil, or raw bytes to be parsed, where a Parser\n// can be provided to parse. Additionally, options can be passed which modify the\n// load behavior, such as passing a custom merge function.\nfunc (ko *Koanf) Load(p Provider, pa Parser, opts ...Option) error {\n\tvar (\n\t\tmp  map[string]interface{}\n\t\terr error\n\t)\n\n\tif p == nil {\n\t\treturn fmt.Errorf(\"load received a nil provider\")\n\t}\n\n\t// No Parser is given. Call the Provider's Read() method to get\n\t// the config map.\n\tif pa == nil {\n\t\tmp, err = p.Read()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// There's a Parser. Get raw bytes from the Provider to parse.\n\t\tb, err := p.ReadBytes()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmp, err = pa.Unmarshal(b)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn ko.merge(mp, newOptions(opts))\n}\n\n// Keys returns the slice of all flattened keys in the loaded configuration\n// sorted alphabetically.\nfunc (ko *Koanf) Keys() []string {\n\tout := make([]string, 0, len(ko.confMapFlat))\n\tfor k := range ko.confMapFlat {\n\t\tout = append(out, k)\n\t}\n\tsort.Strings(out)\n\treturn out\n}\n\n// KeyMap returns a map of flattened keys and the individual parts of the\n// key as slices. eg: \"parent.child.key\" => [\"parent\", \"child\", \"key\"].\nfunc (ko *Koanf) KeyMap() KeyMap {\n\tout := make(KeyMap, len(ko.keyMap))\n\tfor key, parts := range ko.keyMap {\n\t\tout[key] = make([]string, len(parts))\n\t\tcopy(out[key], parts)\n\t}\n\treturn out\n}\n\n// All returns a map of all flattened key paths and their values.\n// Note that it uses maps.Copy to create a copy that uses\n// json.Marshal which changes the numeric types to float64.\nfunc (ko *Koanf) All() map[string]interface{} {\n\treturn maps.Copy(ko.confMapFlat)\n}\n\n// Raw returns a copy of the full raw conf map.\n// Note that it uses maps.Copy to create a copy that uses\n// json.Marshal which changes the numeric types to float64.\nfunc (ko *Koanf) Raw() map[string]interface{} {\n\treturn maps.Copy(ko.confMap)\n}\n\n// Sprint returns a key -> value string representation\n// of the config map with keys sorted alphabetically.\nfunc (ko *Koanf) Sprint() string {\n\tb := bytes.Buffer{}\n\tfor _, k := range ko.Keys() {\n\t\tb.WriteString(fmt.Sprintf(\"%s -> %v\\n\", k, ko.confMapFlat[k]))\n\t}\n\treturn b.String()\n}\n\n// Print prints a key -> value string representation\n// of the config map with keys sorted alphabetically.\nfunc (ko *Koanf) Print() {\n\tfmt.Print(ko.Sprint())\n}\n\n// Cut cuts the config map at a given key path into a sub map and\n// returns a new Koanf instance with the cut config map loaded.\n// For instance, if the loaded config has a path that looks like\n// parent.child.sub.a.b, `Cut(\"parent.child\")` returns a new Koanf\n// instance with the config map `sub.a.b` where everything above\n// `parent.child` are cut out.\nfunc (ko *Koanf) Cut(path string) *Koanf {\n\tout := make(map[string]interface{})\n\n\t// Cut only makes sense if the requested key path is a map.\n\tif v, ok := ko.Get(path).(map[string]interface{}); ok {\n\t\tout = v\n\t}\n\n\tn := New(ko.conf.Delim)\n\t_ = n.merge(out, new(options))\n\treturn n\n}\n\n// Copy returns a copy of the Koanf instance.\nfunc (ko *Koanf) Copy() *Koanf {\n\treturn ko.Cut(\"\")\n}\n\n// Merge merges the config map of a given Koanf instance into\n// the current instance.\nfunc (ko *Koanf) Merge(in *Koanf) error {\n\treturn ko.merge(in.Raw(), new(options))\n}\n\n// MergeAt merges the config map of a given Koanf instance into\n// the current instance as a sub map, at the given key path.\n// If all or part of the key path is missing, it will be created.\n// If the key path is `\"\"`, this is equivalent to Merge.\nfunc (ko *Koanf) MergeAt(in *Koanf, path string) error {\n\t// No path. Merge the two config maps.\n\tif path == \"\" {\n\t\treturn ko.Merge(in)\n\t}\n\n\t// Unflatten the config map with the given key path.\n\tn := maps.Unflatten(map[string]interface{}{\n\t\tpath: in.Raw(),\n\t}, ko.conf.Delim)\n\n\treturn ko.merge(n, new(options))\n}\n\n// Set sets the value at a specific key.\nfunc (ko *Koanf) Set(key string, val interface{}) error {\n\t// Unflatten the config map with the given key path.\n\tn := maps.Unflatten(map[string]interface{}{\n\t\tkey: val,\n\t}, ko.conf.Delim)\n\n\treturn ko.merge(n, new(options))\n}\n\n// Marshal takes a Parser implementation and marshals the config map into bytes,\n// for example, to TOML or JSON bytes.\nfunc (ko *Koanf) Marshal(p Parser) ([]byte, error) {\n\treturn p.Marshal(ko.Raw())\n}\n\n// Unmarshal unmarshals a given key path into the given struct using\n// the mapstructure lib. If no path is specified, the whole map is unmarshalled.\n// `koanf` is the struct field tag used to match field names. To customize,\n// use UnmarshalWithConf(). It uses the mitchellh/mapstructure package.\nfunc (ko *Koanf) Unmarshal(path string, o interface{}) error {\n\treturn ko.UnmarshalWithConf(path, o, UnmarshalConf{})\n}\n\n// UnmarshalWithConf is like Unmarshal but takes configuration params in UnmarshalConf.\n// See mitchellh/mapstructure's DecoderConfig for advanced customization\n// of the unmarshal behaviour.\nfunc (ko *Koanf) UnmarshalWithConf(path string, o interface{}, c UnmarshalConf) error {\n\tif c.DecoderConfig == nil {\n\t\tc.DecoderConfig = &mapstructure.DecoderConfig{\n\t\t\tDecodeHook: mapstructure.ComposeDecodeHookFunc(\n\t\t\t\tmapstructure.StringToTimeDurationHookFunc(),\n\t\t\t\ttextUnmarshalerHookFunc()),\n\t\t\tMetadata:         nil,\n\t\t\tResult:           o,\n\t\t\tWeaklyTypedInput: true,\n\t\t}\n\t}\n\n\tif c.Tag == \"\" {\n\t\tc.DecoderConfig.TagName = \"koanf\"\n\t} else {\n\t\tc.DecoderConfig.TagName = c.Tag\n\t}\n\n\td, err := mapstructure.NewDecoder(c.DecoderConfig)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal using flat key paths.\n\tmp := ko.Get(path)\n\tif c.FlatPaths {\n\t\tif f, ok := mp.(map[string]interface{}); ok {\n\t\t\tfmp, _ := maps.Flatten(f, nil, ko.conf.Delim)\n\t\t\tmp = fmp\n\t\t}\n\t}\n\n\treturn d.Decode(mp)\n}\n\n// Delete removes all nested values from a given path.\n// Clears all keys/values if no path is specified.\n// Every empty, key on the path, is recursively deleted.\nfunc (ko *Koanf) Delete(path string) {\n\t// No path. Erase the entire map.\n\tif path == \"\" {\n\t\tko.confMap = make(map[string]interface{})\n\t\tko.confMapFlat = make(map[string]interface{})\n\t\tko.keyMap = make(KeyMap)\n\t\treturn\n\t}\n\n\t// Does the path exist?\n\tp, ok := ko.keyMap[path]\n\tif !ok {\n\t\treturn\n\t}\n\tmaps.Delete(ko.confMap, p)\n\n\t// Update the flattened version as well.\n\tko.confMapFlat, ko.keyMap = maps.Flatten(ko.confMap, nil, ko.conf.Delim)\n\tko.keyMap = populateKeyParts(ko.keyMap, ko.conf.Delim)\n}\n\n// Get returns the raw, uncast interface{} value of a given key path\n// in the config map. If the key path does not exist, nil is returned.\nfunc (ko *Koanf) Get(path string) interface{} {\n\t// No path. Return the whole conf map.\n\tif path == \"\" {\n\t\treturn ko.Raw()\n\t}\n\n\t// Does the path exist?\n\tp, ok := ko.keyMap[path]\n\tif !ok {\n\t\treturn nil\n\t}\n\tres := maps.Search(ko.confMap, p)\n\n\t// Non-reference types are okay to return directly.\n\t// Other types are \"copied\" with maps.Copy or json.Marshal\n\t// that change the numeric types to float64.\n\n\tswitch v := res.(type) {\n\tcase int, int8, int16, int32, int64, float32, float64, string, bool:\n\t\treturn v\n\tcase map[string]interface{}:\n\t\treturn maps.Copy(v)\n\t}\n\n\tout, _ := copystructure.Copy(&res)\n\tif ptrOut, ok := out.(*interface{}); ok {\n\t\treturn *ptrOut\n\t}\n\treturn out\n}\n\n// Slices returns a list of Koanf instances constructed out of a\n// []map[string]interface{} interface at the given path.\nfunc (ko *Koanf) Slices(path string) []*Koanf {\n\tout := []*Koanf{}\n\tif path == \"\" {\n\t\treturn out\n\t}\n\n\t// Does the path exist?\n\tsl, ok := ko.Get(path).([]interface{})\n\tif !ok {\n\t\treturn out\n\t}\n\n\tfor _, s := range sl {\n\t\tmp, ok := s.(map[string]interface{})\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tk := New(ko.conf.Delim)\n\t\t_ = k.merge(mp, new(options))\n\t\tout = append(out, k)\n\t}\n\n\treturn out\n}\n\n// Exists returns true if the given key path exists in the conf map.\nfunc (ko *Koanf) Exists(path string) bool {\n\t_, ok := ko.keyMap[path]\n\treturn ok\n}\n\n// MapKeys returns a sorted string list of keys in a map addressed by the\n// given path. If the path is not a map, an empty string slice is\n// returned.\nfunc (ko *Koanf) MapKeys(path string) []string {\n\tvar (\n\t\tout = []string{}\n\t\to   = ko.Get(path)\n\t)\n\tif o == nil {\n\t\treturn out\n\t}\n\n\tmp, ok := o.(map[string]interface{})\n\tif !ok {\n\t\treturn out\n\t}\n\tout = make([]string, 0, len(mp))\n\tfor k := range mp {\n\t\tout = append(out, k)\n\t}\n\tsort.Strings(out)\n\treturn out\n}\n\n// Delim returns delimiter in used by this instance of Koanf.\nfunc (ko *Koanf) Delim() string {\n\treturn ko.conf.Delim\n}\n\nfunc (ko *Koanf) merge(c map[string]interface{}, opts *options) error {\n\tmaps.IntfaceKeysToStrings(c)\n\tif opts.merge != nil {\n\t\tif err := opts.merge(c, ko.confMap); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else if ko.conf.StrictMerge {\n\t\tif err := maps.MergeStrict(c, ko.confMap); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tmaps.Merge(c, ko.confMap)\n\t}\n\n\t// Maintain a flattened version as well.\n\tko.confMapFlat, ko.keyMap = maps.Flatten(ko.confMap, nil, ko.conf.Delim)\n\tko.keyMap = populateKeyParts(ko.keyMap, ko.conf.Delim)\n\n\treturn nil\n}\n\n// toInt64 takes an interface value and if it is an integer type,\n// converts and returns int64. If it's any other type,\n// forces it to a string and attempts to do a strconv.Atoi\n// to get an integer out.\nfunc toInt64(v interface{}) (int64, error) {\n\tswitch i := v.(type) {\n\tcase int:\n\t\treturn int64(i), nil\n\tcase int8:\n\t\treturn int64(i), nil\n\tcase int16:\n\t\treturn int64(i), nil\n\tcase int32:\n\t\treturn int64(i), nil\n\tcase int64:\n\t\treturn i, nil\n\t}\n\n\t// Force it to a string and try to convert.\n\tf, err := strconv.ParseFloat(fmt.Sprintf(\"%v\", v), 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn int64(f), nil\n}\n\n// toInt64 takes a `v interface{}` value and if it is a float type,\n// converts and returns a `float64`. If it's any other type, forces it to a\n// string and attempts to get a float out using `strconv.ParseFloat`.\nfunc toFloat64(v interface{}) (float64, error) {\n\tswitch i := v.(type) {\n\tcase float32:\n\t\treturn float64(i), nil\n\tcase float64:\n\t\treturn i, nil\n\t}\n\n\t// Force it to a string and try to convert.\n\tf, err := strconv.ParseFloat(fmt.Sprintf(\"%v\", v), 64)\n\tif err != nil {\n\t\treturn f, err\n\t}\n\n\treturn f, nil\n}\n\n// toBool takes an interface value and if it is a bool type,\n// returns it. If it's any other type, forces it to a string and attempts\n// to parse it as a bool using strconv.ParseBool.\nfunc toBool(v interface{}) (bool, error) {\n\tif b, ok := v.(bool); ok {\n\t\treturn b, nil\n\t}\n\n\t// Force it to a string and try to convert.\n\tb, err := strconv.ParseBool(fmt.Sprintf(\"%v\", v))\n\tif err != nil {\n\t\treturn b, err\n\t}\n\treturn b, nil\n}\n\n// populateKeyParts iterates a key map and generates all possible\n// traversal paths. For instance, `parent.child.key` generates\n// `parent`, and `parent.child`.\nfunc populateKeyParts(m KeyMap, delim string) KeyMap {\n\tout := make(KeyMap, len(m)) // The size of the result is at very least same to KeyMap\n\tfor _, parts := range m {\n\t\t// parts is a slice of [parent, child, key]\n\t\tvar nk string\n\n\t\tfor i := range parts {\n\t\t\tif i == 0 {\n\t\t\t\t// On first iteration only use first part\n\t\t\t\tnk = parts[i]\n\t\t\t} else {\n\t\t\t\t// If nk already contains a part (e.g. `parent`) append delim + `child`\n\t\t\t\tnk += delim + parts[i]\n\t\t\t}\n\t\t\tif _, ok := out[nk]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tout[nk] = make([]string, i+1)\n\t\t\tcopy(out[nk], parts[0:i+1])\n\t\t}\n\t}\n\treturn out\n}\n\n// textUnmarshalerHookFunc is a fixed version of mapstructure.TextUnmarshallerHookFunc.\n// This hook allows to additionally unmarshal text into custom string types that implement the encoding.Text(Un)Marshaler interface(s).\nfunc textUnmarshalerHookFunc() mapstructure.DecodeHookFuncType {\n\treturn func(\n\t\tf reflect.Type,\n\t\tt reflect.Type,\n\t\tdata interface{},\n\t) (interface{}, error) {\n\t\tif f.Kind() != reflect.String {\n\t\t\treturn data, nil\n\t\t}\n\t\tresult := reflect.New(t).Interface()\n\t\tunmarshaller, ok := result.(encoding.TextUnmarshaler)\n\t\tif !ok {\n\t\t\treturn data, nil\n\t\t}\n\n\t\t// default text representation is the actual value of the `from` string\n\t\tvar (\n\t\t\tdataVal = reflect.ValueOf(data)\n\t\t\ttext    = []byte(dataVal.String())\n\t\t)\n\t\tif f.Kind() == t.Kind() {\n\t\t\t// source and target are of underlying type string\n\t\t\tvar (\n\t\t\t\terr    error\n\t\t\t\tptrVal = reflect.New(dataVal.Type())\n\t\t\t)\n\t\t\tif !ptrVal.Elem().CanSet() {\n\t\t\t\t// cannot set, skip, this should not happen\n\t\t\t\tif err := unmarshaller.UnmarshalText(text); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn result, nil\n\t\t\t}\n\t\t\tptrVal.Elem().Set(dataVal)\n\n\t\t\t// We need to assert that both, the value type and the pointer type\n\t\t\t// do (not) implement the TextMarshaller interface before proceeding and simply\n\t\t\t// using the string value of the string type.\n\t\t\t// it might be the case that the internal string representation differs from\n\t\t\t// the (un)marshalled string.\n\n\t\t\tfor _, v := range []reflect.Value{dataVal, ptrVal} {\n\t\t\t\tif marshaller, ok := v.Interface().(encoding.TextMarshaler); ok {\n\t\t\t\t\ttext, err = marshaller.MarshalText()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// text is either the source string's value or the source string type's marshaled value\n\t\t// which may differ from its internal string value.\n\t\tif err := unmarshaller.UnmarshalText(text); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn result, nil\n\t}\n}\n"
        },
        {
          "name": "maps",
          "type": "tree",
          "content": null
        },
        {
          "name": "mock",
          "type": "tree",
          "content": null
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 0.8134765625,
          "content": "package koanf\n\n// options contains options to modify the behavior of Koanf.Load.\ntype options struct {\n\tmerge func(a, b map[string]interface{}) error\n}\n\n// newOptions creates a new options instance.\nfunc newOptions(opts []Option) *options {\n\to := new(options)\n\to.apply(opts)\n\treturn o\n}\n\n// Option is a generic type used to modify the behavior of Koanf.Load.\ntype Option func(*options)\n\n// apply the given options.\nfunc (o *options) apply(opts []Option) {\n\tfor _, opt := range opts {\n\t\topt(o)\n\t}\n}\n\n// WithMergeFunc is an option to modify the merge behavior of Koanf.Load.\n// If unset, the default merge function is used.\n//\n// The merge function is expected to merge map src into dest (left to right).\nfunc WithMergeFunc(merge func(src, dest map[string]interface{}) error) Option {\n\treturn func(o *options) {\n\t\to.merge = merge\n\t}\n}\n"
        },
        {
          "name": "parsers",
          "type": "tree",
          "content": null
        },
        {
          "name": "providers",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}