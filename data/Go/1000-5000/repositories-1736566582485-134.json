{
  "metadata": {
    "timestamp": 1736566582485,
    "page": 134,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "dustin/go-humanize",
      "stars": 4408,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.470703125,
          "content": "sudo: false\nlanguage: go\ngo_import_path: github.com/dustin/go-humanize\ngo:\n  - 1.13.x\n  - 1.14.x\n  - 1.15.x\n  - 1.16.x\n  - stable\n  - master\nmatrix:\n  allow_failures:\n    - go: master\n  fast_finish: true\ninstall:\n  - # Do nothing. This is needed to prevent default install action \"go get -t -v ./...\" from happening here (we want it to happen inside script step).\nscript:\n  - diff -u <(echo -n) <(gofmt -d -s .)\n  - go vet .\n  - go install -v -race ./...\n  - go test -v -race ./...\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.109375,
          "content": "Copyright (c) 2005-2008  Dustin Sallings <dustin@spy.net>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n<http://www.opensource.org/licenses/mit-license.php>\n"
        },
        {
          "name": "README.markdown",
          "type": "blob",
          "size": 3.005859375,
          "content": "# Humane Units [![Build Status](https://travis-ci.org/dustin/go-humanize.svg?branch=master)](https://travis-ci.org/dustin/go-humanize) [![GoDoc](https://godoc.org/github.com/dustin/go-humanize?status.svg)](https://godoc.org/github.com/dustin/go-humanize)\n\nJust a few functions for helping humanize times and sizes.\n\n`go get` it as `github.com/dustin/go-humanize`, import it as\n`\"github.com/dustin/go-humanize\"`, use it as `humanize`.\n\nSee [godoc](https://pkg.go.dev/github.com/dustin/go-humanize) for\ncomplete documentation.\n\n## Sizes\n\nThis lets you take numbers like `82854982` and convert them to useful\nstrings like, `83 MB` or `79 MiB` (whichever you prefer).\n\nExample:\n\n```go\nfmt.Printf(\"That file is %s.\", humanize.Bytes(82854982)) // That file is 83 MB.\n```\n\n## Times\n\nThis lets you take a `time.Time` and spit it out in relative terms.\nFor example, `12 seconds ago` or `3 days from now`.\n\nExample:\n\n```go\nfmt.Printf(\"This was touched %s.\", humanize.Time(someTimeInstance)) // This was touched 7 hours ago.\n```\n\nThanks to Kyle Lemons for the time implementation from an IRC\nconversation one day. It's pretty neat.\n\n## Ordinals\n\nFrom a [mailing list discussion][odisc] where a user wanted to be able\nto label ordinals.\n\n    0 -> 0th\n    1 -> 1st\n    2 -> 2nd\n    3 -> 3rd\n    4 -> 4th\n    [...]\n\nExample:\n\n```go\nfmt.Printf(\"You're my %s best friend.\", humanize.Ordinal(193)) // You are my 193rd best friend.\n```\n\n## Commas\n\nWant to shove commas into numbers? Be my guest.\n\n    0 -> 0\n    100 -> 100\n    1000 -> 1,000\n    1000000000 -> 1,000,000,000\n    -100000 -> -100,000\n\nExample:\n\n```go\nfmt.Printf(\"You owe $%s.\\n\", humanize.Comma(6582491)) // You owe $6,582,491.\n```\n\n## Ftoa\n\nNicer float64 formatter that removes trailing zeros.\n\n```go\nfmt.Printf(\"%f\", 2.24)                // 2.240000\nfmt.Printf(\"%s\", humanize.Ftoa(2.24)) // 2.24\nfmt.Printf(\"%f\", 2.0)                 // 2.000000\nfmt.Printf(\"%s\", humanize.Ftoa(2.0))  // 2\n```\n\n## SI notation\n\nFormat numbers with [SI notation][sinotation].\n\nExample:\n\n```go\nhumanize.SI(0.00000000223, \"M\") // 2.23 nM\n```\n\n## English-specific functions\n\nThe following functions are in the `humanize/english` subpackage.\n\n### Plurals\n\nSimple English pluralization\n\n```go\nenglish.PluralWord(1, \"object\", \"\") // object\nenglish.PluralWord(42, \"object\", \"\") // objects\nenglish.PluralWord(2, \"bus\", \"\") // buses\nenglish.PluralWord(99, \"locus\", \"loci\") // loci\n\nenglish.Plural(1, \"object\", \"\") // 1 object\nenglish.Plural(42, \"object\", \"\") // 42 objects\nenglish.Plural(2, \"bus\", \"\") // 2 buses\nenglish.Plural(99, \"locus\", \"loci\") // 99 loci\n```\n\n### Word series\n\nFormat comma-separated words lists with conjuctions:\n\n```go\nenglish.WordSeries([]string{\"foo\"}, \"and\") // foo\nenglish.WordSeries([]string{\"foo\", \"bar\"}, \"and\") // foo and bar\nenglish.WordSeries([]string{\"foo\", \"bar\", \"baz\"}, \"and\") // foo, bar and baz\n\nenglish.OxfordWordSeries([]string{\"foo\", \"bar\", \"baz\"}, \"and\") // foo, bar, and baz\n```\n\n[odisc]: https://groups.google.com/d/topic/golang-nuts/l8NhI74jl-4/discussion\n[sinotation]: http://en.wikipedia.org/wiki/Metric_prefix\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.3828125,
          "content": "# Security Policy\n\nTo report a security issue, please disclose it at [security advisory](https://github.com/dustin/go-humanize/security/advisories/new).\n\nWe will respond within 7 working days of your submission. If the issue is confirmed as a vulnerability, we will open a Security Advisory and acknowledge your contributions as part of it. This project follows a 90 day disclosure timeline.\n"
        },
        {
          "name": "big.go",
          "type": "blob",
          "size": 0.59765625,
          "content": "package humanize\n\nimport (\n\t\"math/big\"\n)\n\n// order of magnitude (to a max order)\nfunc oomm(n, b *big.Int, maxmag int) (float64, int) {\n\tmag := 0\n\tm := &big.Int{}\n\tfor n.Cmp(b) >= 0 {\n\t\tn.DivMod(n, b, m)\n\t\tmag++\n\t\tif mag == maxmag && maxmag >= 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn float64(n.Int64()) + (float64(m.Int64()) / float64(b.Int64())), mag\n}\n\n// total order of magnitude\n// (same as above, but with no upper limit)\nfunc oom(n, b *big.Int) (float64, int) {\n\tmag := 0\n\tm := &big.Int{}\n\tfor n.Cmp(b) >= 0 {\n\t\tn.DivMod(n, b, m)\n\t\tmag++\n\t}\n\treturn float64(n.Int64()) + (float64(m.Int64()) / float64(b.Int64())), mag\n}\n"
        },
        {
          "name": "bigbytes.go",
          "type": "blob",
          "size": 4.736328125,
          "content": "package humanize\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nvar (\n\tbigIECExp = big.NewInt(1024)\n\n\t// BigByte is one byte in bit.Ints\n\tBigByte = big.NewInt(1)\n\t// BigKiByte is 1,024 bytes in bit.Ints\n\tBigKiByte = (&big.Int{}).Mul(BigByte, bigIECExp)\n\t// BigMiByte is 1,024 k bytes in bit.Ints\n\tBigMiByte = (&big.Int{}).Mul(BigKiByte, bigIECExp)\n\t// BigGiByte is 1,024 m bytes in bit.Ints\n\tBigGiByte = (&big.Int{}).Mul(BigMiByte, bigIECExp)\n\t// BigTiByte is 1,024 g bytes in bit.Ints\n\tBigTiByte = (&big.Int{}).Mul(BigGiByte, bigIECExp)\n\t// BigPiByte is 1,024 t bytes in bit.Ints\n\tBigPiByte = (&big.Int{}).Mul(BigTiByte, bigIECExp)\n\t// BigEiByte is 1,024 p bytes in bit.Ints\n\tBigEiByte = (&big.Int{}).Mul(BigPiByte, bigIECExp)\n\t// BigZiByte is 1,024 e bytes in bit.Ints\n\tBigZiByte = (&big.Int{}).Mul(BigEiByte, bigIECExp)\n\t// BigYiByte is 1,024 z bytes in bit.Ints\n\tBigYiByte = (&big.Int{}).Mul(BigZiByte, bigIECExp)\n\t// BigRiByte is 1,024 y bytes in bit.Ints\n\tBigRiByte = (&big.Int{}).Mul(BigYiByte, bigIECExp)\n\t// BigQiByte is 1,024 r bytes in bit.Ints\n\tBigQiByte = (&big.Int{}).Mul(BigRiByte, bigIECExp)\n)\n\nvar (\n\tbigSIExp = big.NewInt(1000)\n\n\t// BigSIByte is one SI byte in big.Ints\n\tBigSIByte = big.NewInt(1)\n\t// BigKByte is 1,000 SI bytes in big.Ints\n\tBigKByte = (&big.Int{}).Mul(BigSIByte, bigSIExp)\n\t// BigMByte is 1,000 SI k bytes in big.Ints\n\tBigMByte = (&big.Int{}).Mul(BigKByte, bigSIExp)\n\t// BigGByte is 1,000 SI m bytes in big.Ints\n\tBigGByte = (&big.Int{}).Mul(BigMByte, bigSIExp)\n\t// BigTByte is 1,000 SI g bytes in big.Ints\n\tBigTByte = (&big.Int{}).Mul(BigGByte, bigSIExp)\n\t// BigPByte is 1,000 SI t bytes in big.Ints\n\tBigPByte = (&big.Int{}).Mul(BigTByte, bigSIExp)\n\t// BigEByte is 1,000 SI p bytes in big.Ints\n\tBigEByte = (&big.Int{}).Mul(BigPByte, bigSIExp)\n\t// BigZByte is 1,000 SI e bytes in big.Ints\n\tBigZByte = (&big.Int{}).Mul(BigEByte, bigSIExp)\n\t// BigYByte is 1,000 SI z bytes in big.Ints\n\tBigYByte = (&big.Int{}).Mul(BigZByte, bigSIExp)\n\t// BigRByte is 1,000 SI y bytes in big.Ints\n\tBigRByte = (&big.Int{}).Mul(BigYByte, bigSIExp)\n\t// BigQByte is 1,000 SI r bytes in big.Ints\n\tBigQByte = (&big.Int{}).Mul(BigRByte, bigSIExp)\n)\n\nvar bigBytesSizeTable = map[string]*big.Int{\n\t\"b\":   BigByte,\n\t\"kib\": BigKiByte,\n\t\"kb\":  BigKByte,\n\t\"mib\": BigMiByte,\n\t\"mb\":  BigMByte,\n\t\"gib\": BigGiByte,\n\t\"gb\":  BigGByte,\n\t\"tib\": BigTiByte,\n\t\"tb\":  BigTByte,\n\t\"pib\": BigPiByte,\n\t\"pb\":  BigPByte,\n\t\"eib\": BigEiByte,\n\t\"eb\":  BigEByte,\n\t\"zib\": BigZiByte,\n\t\"zb\":  BigZByte,\n\t\"yib\": BigYiByte,\n\t\"yb\":  BigYByte,\n\t\"rib\": BigRiByte,\n\t\"rb\":  BigRByte,\n\t\"qib\": BigQiByte,\n\t\"qb\":  BigQByte,\n\t// Without suffix\n\t\"\":   BigByte,\n\t\"ki\": BigKiByte,\n\t\"k\":  BigKByte,\n\t\"mi\": BigMiByte,\n\t\"m\":  BigMByte,\n\t\"gi\": BigGiByte,\n\t\"g\":  BigGByte,\n\t\"ti\": BigTiByte,\n\t\"t\":  BigTByte,\n\t\"pi\": BigPiByte,\n\t\"p\":  BigPByte,\n\t\"ei\": BigEiByte,\n\t\"e\":  BigEByte,\n\t\"z\":  BigZByte,\n\t\"zi\": BigZiByte,\n\t\"y\":  BigYByte,\n\t\"yi\": BigYiByte,\n\t\"r\":  BigRByte,\n\t\"ri\": BigRiByte,\n\t\"q\":  BigQByte,\n\t\"qi\": BigQiByte,\n}\n\nvar ten = big.NewInt(10)\n\nfunc humanateBigBytes(s, base *big.Int, sizes []string) string {\n\tif s.Cmp(ten) < 0 {\n\t\treturn fmt.Sprintf(\"%d B\", s)\n\t}\n\tc := (&big.Int{}).Set(s)\n\tval, mag := oomm(c, base, len(sizes)-1)\n\tsuffix := sizes[mag]\n\tf := \"%.0f %s\"\n\tif val < 10 {\n\t\tf = \"%.1f %s\"\n\t}\n\n\treturn fmt.Sprintf(f, val, suffix)\n\n}\n\n// BigBytes produces a human readable representation of an SI size.\n//\n// See also: ParseBigBytes.\n//\n// BigBytes(82854982) -> 83 MB\nfunc BigBytes(s *big.Int) string {\n\tsizes := []string{\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\", \"RB\", \"QB\"}\n\treturn humanateBigBytes(s, bigSIExp, sizes)\n}\n\n// BigIBytes produces a human readable representation of an IEC size.\n//\n// See also: ParseBigBytes.\n//\n// BigIBytes(82854982) -> 79 MiB\nfunc BigIBytes(s *big.Int) string {\n\tsizes := []string{\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\", \"RiB\", \"QiB\"}\n\treturn humanateBigBytes(s, bigIECExp, sizes)\n}\n\n// ParseBigBytes parses a string representation of bytes into the number\n// of bytes it represents.\n//\n// See also: BigBytes, BigIBytes.\n//\n// ParseBigBytes(\"42 MB\") -> 42000000, nil\n// ParseBigBytes(\"42 mib\") -> 44040192, nil\nfunc ParseBigBytes(s string) (*big.Int, error) {\n\tlastDigit := 0\n\thasComma := false\n\tfor _, r := range s {\n\t\tif !(unicode.IsDigit(r) || r == '.' || r == ',') {\n\t\t\tbreak\n\t\t}\n\t\tif r == ',' {\n\t\t\thasComma = true\n\t\t}\n\t\tlastDigit++\n\t}\n\n\tnum := s[:lastDigit]\n\tif hasComma {\n\t\tnum = strings.Replace(num, \",\", \"\", -1)\n\t}\n\n\tval := &big.Rat{}\n\t_, err := fmt.Sscanf(num, \"%f\", val)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\textra := strings.ToLower(strings.TrimSpace(s[lastDigit:]))\n\tif m, ok := bigBytesSizeTable[extra]; ok {\n\t\tmv := (&big.Rat{}).SetInt(m)\n\t\tval.Mul(val, mv)\n\t\trv := &big.Int{}\n\t\trv.Div(val.Num(), val.Denom())\n\t\treturn rv, nil\n\t}\n\n\treturn nil, fmt.Errorf(\"unhandled size name: %v\", extra)\n}\n"
        },
        {
          "name": "bigbytes_test.go",
          "type": "blob",
          "size": 5.32421875,
          "content": "package humanize\n\nimport (\n\t\"math/big\"\n\t\"testing\"\n)\n\nfunc TestBigByteParsing(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\texp uint64\n\t}{\n\t\t{\"42\", 42},\n\t\t{\"42MB\", 42000000},\n\t\t{\"42MiB\", 44040192},\n\t\t{\"42mb\", 42000000},\n\t\t{\"42mib\", 44040192},\n\t\t{\"42MIB\", 44040192},\n\t\t{\"42 MB\", 42000000},\n\t\t{\"42 MiB\", 44040192},\n\t\t{\"42 mb\", 42000000},\n\t\t{\"42 mib\", 44040192},\n\t\t{\"42 MIB\", 44040192},\n\t\t{\"42.5MB\", 42500000},\n\t\t{\"42.5MiB\", 44564480},\n\t\t{\"42.5 MB\", 42500000},\n\t\t{\"42.5 MiB\", 44564480},\n\t\t// No need to say B\n\t\t{\"42M\", 42000000},\n\t\t{\"42Mi\", 44040192},\n\t\t{\"42m\", 42000000},\n\t\t{\"42mi\", 44040192},\n\t\t{\"42MI\", 44040192},\n\t\t{\"42 M\", 42000000},\n\t\t{\"42 Mi\", 44040192},\n\t\t{\"42 m\", 42000000},\n\t\t{\"42 mi\", 44040192},\n\t\t{\"42 MI\", 44040192},\n\t\t{\"42.5M\", 42500000},\n\t\t{\"42.5Mi\", 44564480},\n\t\t{\"42.5 M\", 42500000},\n\t\t{\"42.5 Mi\", 44564480},\n\t\t{\"1,005.03 MB\", 1005030000},\n\t\t// Large testing, breaks when too much larger than\n\t\t// this.\n\t\t{\"12.5 EB\", uint64(12.5 * float64(EByte))},\n\t\t{\"12.5 E\", uint64(12.5 * float64(EByte))},\n\t\t{\"12.5 EiB\", uint64(12.5 * float64(EiByte))},\n\t}\n\n\tfor _, p := range tests {\n\t\tgot, err := ParseBigBytes(p.in)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Couldn't parse %v: %v\", p.in, err)\n\t\t} else {\n\t\t\tif got.Uint64() != p.exp {\n\t\t\t\tt.Errorf(\"Expected %v for %v, got %v\",\n\t\t\t\t\tp.exp, p.in, got)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestBigByteErrors(t *testing.T) {\n\tgot, err := ParseBigBytes(\"84 JB\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got %v\", got)\n\t}\n\t_, err = ParseBigBytes(\"\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error parsing nothing\")\n\t}\n}\n\nfunc bbyte(in uint64) string {\n\treturn BigBytes((&big.Int{}).SetUint64(in))\n}\n\nfunc bibyte(in uint64) string {\n\treturn BigIBytes((&big.Int{}).SetUint64(in))\n}\n\nfunc TestBigBytes(t *testing.T) {\n\ttestList{\n\t\t{\"bytes(0)\", bbyte(0), \"0 B\"},\n\t\t{\"bytes(1)\", bbyte(1), \"1 B\"},\n\t\t{\"bytes(803)\", bbyte(803), \"803 B\"},\n\t\t{\"bytes(999)\", bbyte(999), \"999 B\"},\n\n\t\t{\"bytes(1024)\", bbyte(1024), \"1.0 kB\"},\n\t\t{\"bytes(1MB - 1)\", bbyte(MByte - Byte), \"1000 kB\"},\n\n\t\t{\"bytes(1MB)\", bbyte(1024 * 1024), \"1.0 MB\"},\n\t\t{\"bytes(1GB - 1K)\", bbyte(GByte - KByte), \"1000 MB\"},\n\n\t\t{\"bytes(1GB)\", bbyte(GByte), \"1.0 GB\"},\n\t\t{\"bytes(1TB - 1M)\", bbyte(TByte - MByte), \"1000 GB\"},\n\n\t\t{\"bytes(1TB)\", bbyte(TByte), \"1.0 TB\"},\n\t\t{\"bytes(1PB - 1T)\", bbyte(PByte - TByte), \"999 TB\"},\n\n\t\t{\"bytes(1PB)\", bbyte(PByte), \"1.0 PB\"},\n\t\t{\"bytes(1PB - 1T)\", bbyte(EByte - PByte), \"999 PB\"},\n\n\t\t{\"bytes(1EB)\", bbyte(EByte), \"1.0 EB\"},\n\t\t// Overflows.\n\t\t// {\"bytes(1EB - 1P)\", Bytes((KByte*EByte)-PByte), \"1023EB\"},\n\n\t\t{\"bytes(0)\", bibyte(0), \"0 B\"},\n\t\t{\"bytes(1)\", bibyte(1), \"1 B\"},\n\t\t{\"bytes(803)\", bibyte(803), \"803 B\"},\n\t\t{\"bytes(1023)\", bibyte(1023), \"1023 B\"},\n\n\t\t{\"bytes(1024)\", bibyte(1024), \"1.0 KiB\"},\n\t\t{\"bytes(1MB - 1)\", bibyte(MiByte - IByte), \"1024 KiB\"},\n\n\t\t{\"bytes(1MB)\", bibyte(1024 * 1024), \"1.0 MiB\"},\n\t\t{\"bytes(1GB - 1K)\", bibyte(GiByte - KiByte), \"1024 MiB\"},\n\n\t\t{\"bytes(1GB)\", bibyte(GiByte), \"1.0 GiB\"},\n\t\t{\"bytes(1TB - 1M)\", bibyte(TiByte - MiByte), \"1024 GiB\"},\n\n\t\t{\"bytes(1TB)\", bibyte(TiByte), \"1.0 TiB\"},\n\t\t{\"bytes(1PB - 1T)\", bibyte(PiByte - TiByte), \"1023 TiB\"},\n\n\t\t{\"bytes(1PB)\", bibyte(PiByte), \"1.0 PiB\"},\n\t\t{\"bytes(1PB - 1T)\", bibyte(EiByte - PiByte), \"1023 PiB\"},\n\n\t\t{\"bytes(1EiB)\", bibyte(EiByte), \"1.0 EiB\"},\n\t\t// Overflows.\n\t\t// {\"bytes(1EB - 1P)\", bibyte((KIByte*EIByte)-PiByte), \"1023EB\"},\n\n\t\t{\"bytes(5.5GiB)\", bibyte(5.5 * GiByte), \"5.5 GiB\"},\n\n\t\t{\"bytes(5.5GB)\", bbyte(5.5 * GByte), \"5.5 GB\"},\n\t}.validate(t)\n}\n\nfunc TestVeryBigBytes(t *testing.T) {\n\tb, _ := (&big.Int{}).SetString(\"15347691069326346944512\", 10)\n\ts := BigBytes(b)\n\tif s != \"15 ZB\" {\n\t\tt.Errorf(\"Expected 15 ZB, got %v\", s)\n\t}\n\ts = BigIBytes(b)\n\tif s != \"13 ZiB\" {\n\t\tt.Errorf(\"Expected 13 ZiB, got %v\", s)\n\t}\n\n\tb, _ = (&big.Int{}).SetString(\"15716035654990179271180288\", 10)\n\ts = BigBytes(b)\n\tif s != \"16 YB\" {\n\t\tt.Errorf(\"Expected 16 YB, got %v\", s)\n\t}\n\ts = BigIBytes(b)\n\tif s != \"13 YiB\" {\n\t\tt.Errorf(\"Expected 13 YiB, got %v\", s)\n\t}\n}\n\nfunc TestVeryVeryBigBytes(t *testing.T) {\n\tb, _ := (&big.Int{}).SetString(\"16093220510709943573688614912\", 10)\n\ts := BigBytes(b)\n\tif s != \"16 RB\" {\n\t\tt.Errorf(\"Expected 16 RB, got %v\", s)\n\t}\n\ts = BigIBytes(b)\n\tif s != \"13 RiB\" {\n\t\tt.Errorf(\"Expected 13 RiB, got %v\", s)\n\t}\n}\n\nfunc TestParseVeryBig(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\tout string\n\t}{\n\t\t{\"16 ZB\", \"16000000000000000000000\"},\n\t\t{\"16 ZiB\", \"18889465931478580854784\"},\n\t\t{\"16.5 ZB\", \"16500000000000000000000\"},\n\t\t{\"16.5 ZiB\", \"19479761741837286506496\"},\n\t\t{\"16 Z\", \"16000000000000000000000\"},\n\t\t{\"16 Zi\", \"18889465931478580854784\"},\n\t\t{\"16.5 Z\", \"16500000000000000000000\"},\n\t\t{\"16.5 Zi\", \"19479761741837286506496\"},\n\n\t\t{\"16 YB\", \"16000000000000000000000000\"},\n\t\t{\"16 YiB\", \"19342813113834066795298816\"},\n\t\t{\"16.5 YB\", \"16500000000000000000000000\"},\n\t\t{\"16.5 YiB\", \"19947276023641381382651904\"},\n\t\t{\"16 Y\", \"16000000000000000000000000\"},\n\t\t{\"16 Yi\", \"19342813113834066795298816\"},\n\t\t{\"16.5 Y\", \"16500000000000000000000000\"},\n\t\t{\"16.5 Yi\", \"19947276023641381382651904\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tx, err := ParseBigBytes(test.in)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error parsing %q: %v\", test.in, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif x.String() != test.out {\n\t\t\tt.Errorf(\"Expected %q for %q, got %v\", test.out, test.in, x)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseBigBytes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tParseBigBytes(\"16.5 Z\")\n\t}\n}\n\nfunc BenchmarkBigBytes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tbibyte(16.5 * GByte)\n\t}\n}\n"
        },
        {
          "name": "bytes.go",
          "type": "blob",
          "size": 2.548828125,
          "content": "package humanize\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unicode\"\n)\n\n// IEC Sizes.\n// kibis of bits\nconst (\n\tByte = 1 << (iota * 10)\n\tKiByte\n\tMiByte\n\tGiByte\n\tTiByte\n\tPiByte\n\tEiByte\n)\n\n// SI Sizes.\nconst (\n\tIByte = 1\n\tKByte = IByte * 1000\n\tMByte = KByte * 1000\n\tGByte = MByte * 1000\n\tTByte = GByte * 1000\n\tPByte = TByte * 1000\n\tEByte = PByte * 1000\n)\n\nvar bytesSizeTable = map[string]uint64{\n\t\"b\":   Byte,\n\t\"kib\": KiByte,\n\t\"kb\":  KByte,\n\t\"mib\": MiByte,\n\t\"mb\":  MByte,\n\t\"gib\": GiByte,\n\t\"gb\":  GByte,\n\t\"tib\": TiByte,\n\t\"tb\":  TByte,\n\t\"pib\": PiByte,\n\t\"pb\":  PByte,\n\t\"eib\": EiByte,\n\t\"eb\":  EByte,\n\t// Without suffix\n\t\"\":   Byte,\n\t\"ki\": KiByte,\n\t\"k\":  KByte,\n\t\"mi\": MiByte,\n\t\"m\":  MByte,\n\t\"gi\": GiByte,\n\t\"g\":  GByte,\n\t\"ti\": TiByte,\n\t\"t\":  TByte,\n\t\"pi\": PiByte,\n\t\"p\":  PByte,\n\t\"ei\": EiByte,\n\t\"e\":  EByte,\n}\n\nfunc logn(n, b float64) float64 {\n\treturn math.Log(n) / math.Log(b)\n}\n\nfunc humanateBytes(s uint64, base float64, sizes []string) string {\n\tif s < 10 {\n\t\treturn fmt.Sprintf(\"%d B\", s)\n\t}\n\te := math.Floor(logn(float64(s), base))\n\tsuffix := sizes[int(e)]\n\tval := math.Floor(float64(s)/math.Pow(base, e)*10+0.5) / 10\n\tf := \"%.0f %s\"\n\tif val < 10 {\n\t\tf = \"%.1f %s\"\n\t}\n\n\treturn fmt.Sprintf(f, val, suffix)\n}\n\n// Bytes produces a human readable representation of an SI size.\n//\n// See also: ParseBytes.\n//\n// Bytes(82854982) -> 83 MB\nfunc Bytes(s uint64) string {\n\tsizes := []string{\"B\", \"kB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\"}\n\treturn humanateBytes(s, 1000, sizes)\n}\n\n// IBytes produces a human readable representation of an IEC size.\n//\n// See also: ParseBytes.\n//\n// IBytes(82854982) -> 79 MiB\nfunc IBytes(s uint64) string {\n\tsizes := []string{\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\"}\n\treturn humanateBytes(s, 1024, sizes)\n}\n\n// ParseBytes parses a string representation of bytes into the number\n// of bytes it represents.\n//\n// See Also: Bytes, IBytes.\n//\n// ParseBytes(\"42 MB\") -> 42000000, nil\n// ParseBytes(\"42 mib\") -> 44040192, nil\nfunc ParseBytes(s string) (uint64, error) {\n\tlastDigit := 0\n\thasComma := false\n\tfor _, r := range s {\n\t\tif !(unicode.IsDigit(r) || r == '.' || r == ',') {\n\t\t\tbreak\n\t\t}\n\t\tif r == ',' {\n\t\t\thasComma = true\n\t\t}\n\t\tlastDigit++\n\t}\n\n\tnum := s[:lastDigit]\n\tif hasComma {\n\t\tnum = strings.Replace(num, \",\", \"\", -1)\n\t}\n\n\tf, err := strconv.ParseFloat(num, 64)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\textra := strings.ToLower(strings.TrimSpace(s[lastDigit:]))\n\tif m, ok := bytesSizeTable[extra]; ok {\n\t\tf *= float64(m)\n\t\tif f >= math.MaxUint64 {\n\t\t\treturn 0, fmt.Errorf(\"too large: %v\", s)\n\t\t}\n\t\treturn uint64(f), nil\n\t}\n\n\treturn 0, fmt.Errorf(\"unhandled size name: %v\", extra)\n}\n"
        },
        {
          "name": "bytes_test.go",
          "type": "blob",
          "size": 3.5439453125,
          "content": "package humanize\n\nimport (\n\t\"testing\"\n)\n\nfunc TestByteParsing(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\texp uint64\n\t}{\n\t\t{\"42\", 42},\n\t\t{\"42MB\", 42000000},\n\t\t{\"42MiB\", 44040192},\n\t\t{\"42mb\", 42000000},\n\t\t{\"42mib\", 44040192},\n\t\t{\"42MIB\", 44040192},\n\t\t{\"42 MB\", 42000000},\n\t\t{\"42 MiB\", 44040192},\n\t\t{\"42 mb\", 42000000},\n\t\t{\"42 mib\", 44040192},\n\t\t{\"42 MIB\", 44040192},\n\t\t{\"42.5MB\", 42500000},\n\t\t{\"42.5MiB\", 44564480},\n\t\t{\"42.5 MB\", 42500000},\n\t\t{\"42.5 MiB\", 44564480},\n\t\t// No need to say B\n\t\t{\"42M\", 42000000},\n\t\t{\"42Mi\", 44040192},\n\t\t{\"42m\", 42000000},\n\t\t{\"42mi\", 44040192},\n\t\t{\"42MI\", 44040192},\n\t\t{\"42 M\", 42000000},\n\t\t{\"42 Mi\", 44040192},\n\t\t{\"42 m\", 42000000},\n\t\t{\"42 mi\", 44040192},\n\t\t{\"42 MI\", 44040192},\n\t\t{\"42.5M\", 42500000},\n\t\t{\"42.5Mi\", 44564480},\n\t\t{\"42.5 M\", 42500000},\n\t\t{\"42.5 Mi\", 44564480},\n\t\t// Bug #42\n\t\t{\"1,005.03 MB\", 1005030000},\n\t\t// Large testing, breaks when too much larger than\n\t\t// this.\n\t\t{\"12.5 EB\", uint64(12.5 * float64(EByte))},\n\t\t{\"12.5 E\", uint64(12.5 * float64(EByte))},\n\t\t{\"12.5 EiB\", uint64(12.5 * float64(EiByte))},\n\t}\n\n\tfor _, p := range tests {\n\t\tgot, err := ParseBytes(p.in)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Couldn't parse %v: %v\", p.in, err)\n\t\t}\n\t\tif got != p.exp {\n\t\t\tt.Errorf(\"Expected %v for %v, got %v\",\n\t\t\t\tp.exp, p.in, got)\n\t\t}\n\t}\n}\n\nfunc TestByteErrors(t *testing.T) {\n\tgot, err := ParseBytes(\"84 JB\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got %v\", got)\n\t}\n\t_, err = ParseBytes(\"\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error parsing nothing\")\n\t}\n\tgot, err = ParseBytes(\"16 EiB\")\n\tif err == nil {\n\t\tt.Errorf(\"Expected error, got %v\", got)\n\t}\n}\n\nfunc TestBytes(t *testing.T) {\n\ttestList{\n\t\t{\"bytes(0)\", Bytes(0), \"0 B\"},\n\t\t{\"bytes(1)\", Bytes(1), \"1 B\"},\n\t\t{\"bytes(803)\", Bytes(803), \"803 B\"},\n\t\t{\"bytes(999)\", Bytes(999), \"999 B\"},\n\n\t\t{\"bytes(1024)\", Bytes(1024), \"1.0 kB\"},\n\t\t{\"bytes(9999)\", Bytes(9999), \"10 kB\"},\n\t\t{\"bytes(1MB - 1)\", Bytes(MByte - Byte), \"1000 kB\"},\n\n\t\t{\"bytes(1MB)\", Bytes(1024 * 1024), \"1.0 MB\"},\n\t\t{\"bytes(1GB - 1K)\", Bytes(GByte - KByte), \"1000 MB\"},\n\n\t\t{\"bytes(1GB)\", Bytes(GByte), \"1.0 GB\"},\n\t\t{\"bytes(1TB - 1M)\", Bytes(TByte - MByte), \"1000 GB\"},\n\t\t{\"bytes(10MB)\", Bytes(9999 * 1000), \"10 MB\"},\n\n\t\t{\"bytes(1TB)\", Bytes(TByte), \"1.0 TB\"},\n\t\t{\"bytes(1PB - 1T)\", Bytes(PByte - TByte), \"999 TB\"},\n\n\t\t{\"bytes(1PB)\", Bytes(PByte), \"1.0 PB\"},\n\t\t{\"bytes(1PB - 1T)\", Bytes(EByte - PByte), \"999 PB\"},\n\n\t\t{\"bytes(1EB)\", Bytes(EByte), \"1.0 EB\"},\n\t\t// Overflows.\n\t\t// {\"bytes(1EB - 1P)\", Bytes((KByte*EByte)-PByte), \"1023EB\"},\n\n\t\t{\"bytes(0)\", IBytes(0), \"0 B\"},\n\t\t{\"bytes(1)\", IBytes(1), \"1 B\"},\n\t\t{\"bytes(803)\", IBytes(803), \"803 B\"},\n\t\t{\"bytes(1023)\", IBytes(1023), \"1023 B\"},\n\n\t\t{\"bytes(1024)\", IBytes(1024), \"1.0 KiB\"},\n\t\t{\"bytes(1MB - 1)\", IBytes(MiByte - IByte), \"1024 KiB\"},\n\n\t\t{\"bytes(1MB)\", IBytes(1024 * 1024), \"1.0 MiB\"},\n\t\t{\"bytes(1GB - 1K)\", IBytes(GiByte - KiByte), \"1024 MiB\"},\n\n\t\t{\"bytes(1GB)\", IBytes(GiByte), \"1.0 GiB\"},\n\t\t{\"bytes(1TB - 1M)\", IBytes(TiByte - MiByte), \"1024 GiB\"},\n\n\t\t{\"bytes(1TB)\", IBytes(TiByte), \"1.0 TiB\"},\n\t\t{\"bytes(1PB - 1T)\", IBytes(PiByte - TiByte), \"1023 TiB\"},\n\n\t\t{\"bytes(1PB)\", IBytes(PiByte), \"1.0 PiB\"},\n\t\t{\"bytes(1PB - 1T)\", IBytes(EiByte - PiByte), \"1023 PiB\"},\n\n\t\t{\"bytes(1EiB)\", IBytes(EiByte), \"1.0 EiB\"},\n\t\t// Overflows.\n\t\t// {\"bytes(1EB - 1P)\", IBytes((KIByte*EIByte)-PiByte), \"1023EB\"},\n\n\t\t{\"bytes(5.5GiB)\", IBytes(5.5 * GiByte), \"5.5 GiB\"},\n\n\t\t{\"bytes(5.5GB)\", Bytes(5.5 * GByte), \"5.5 GB\"},\n\t}.validate(t)\n}\n\nfunc BenchmarkParseBytes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tParseBytes(\"16.5 GB\")\n\t}\n}\n\nfunc BenchmarkBytes(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBytes(16.5 * GByte)\n\t}\n}\n"
        },
        {
          "name": "comma.go",
          "type": "blob",
          "size": 2.41796875,
          "content": "package humanize\n\nimport (\n\t\"bytes\"\n\t\"math\"\n\t\"math/big\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Comma produces a string form of the given number in base 10 with\n// commas after every three orders of magnitude.\n//\n// e.g. Comma(834142) -> 834,142\nfunc Comma(v int64) string {\n\tsign := \"\"\n\n\t// Min int64 can't be negated to a usable value, so it has to be special cased.\n\tif v == math.MinInt64 {\n\t\treturn \"-9,223,372,036,854,775,808\"\n\t}\n\n\tif v < 0 {\n\t\tsign = \"-\"\n\t\tv = 0 - v\n\t}\n\n\tparts := []string{\"\", \"\", \"\", \"\", \"\", \"\", \"\"}\n\tj := len(parts) - 1\n\n\tfor v > 999 {\n\t\tparts[j] = strconv.FormatInt(v%1000, 10)\n\t\tswitch len(parts[j]) {\n\t\tcase 2:\n\t\t\tparts[j] = \"0\" + parts[j]\n\t\tcase 1:\n\t\t\tparts[j] = \"00\" + parts[j]\n\t\t}\n\t\tv = v / 1000\n\t\tj--\n\t}\n\tparts[j] = strconv.Itoa(int(v))\n\treturn sign + strings.Join(parts[j:], \",\")\n}\n\n// Commaf produces a string form of the given number in base 10 with\n// commas after every three orders of magnitude.\n//\n// e.g. Commaf(834142.32) -> 834,142.32\nfunc Commaf(v float64) string {\n\tbuf := &bytes.Buffer{}\n\tif v < 0 {\n\t\tbuf.Write([]byte{'-'})\n\t\tv = 0 - v\n\t}\n\n\tcomma := []byte{','}\n\n\tparts := strings.Split(strconv.FormatFloat(v, 'f', -1, 64), \".\")\n\tpos := 0\n\tif len(parts[0])%3 != 0 {\n\t\tpos += len(parts[0]) % 3\n\t\tbuf.WriteString(parts[0][:pos])\n\t\tbuf.Write(comma)\n\t}\n\tfor ; pos < len(parts[0]); pos += 3 {\n\t\tbuf.WriteString(parts[0][pos : pos+3])\n\t\tbuf.Write(comma)\n\t}\n\tbuf.Truncate(buf.Len() - 1)\n\n\tif len(parts) > 1 {\n\t\tbuf.Write([]byte{'.'})\n\t\tbuf.WriteString(parts[1])\n\t}\n\treturn buf.String()\n}\n\n// CommafWithDigits works like the Commaf but limits the resulting\n// string to the given number of decimal places.\n//\n// e.g. CommafWithDigits(834142.32, 1) -> 834,142.3\nfunc CommafWithDigits(f float64, decimals int) string {\n\treturn stripTrailingDigits(Commaf(f), decimals)\n}\n\n// BigComma produces a string form of the given big.Int in base 10\n// with commas after every three orders of magnitude.\nfunc BigComma(b *big.Int) string {\n\tsign := \"\"\n\tif b.Sign() < 0 {\n\t\tsign = \"-\"\n\t\tb.Abs(b)\n\t}\n\n\tathousand := big.NewInt(1000)\n\tc := (&big.Int{}).Set(b)\n\t_, m := oom(c, athousand)\n\tparts := make([]string, m+1)\n\tj := len(parts) - 1\n\n\tmod := &big.Int{}\n\tfor b.Cmp(athousand) >= 0 {\n\t\tb.DivMod(b, athousand, mod)\n\t\tparts[j] = strconv.FormatInt(mod.Int64(), 10)\n\t\tswitch len(parts[j]) {\n\t\tcase 2:\n\t\t\tparts[j] = \"0\" + parts[j]\n\t\tcase 1:\n\t\t\tparts[j] = \"00\" + parts[j]\n\t\t}\n\t\tj--\n\t}\n\tparts[j] = strconv.Itoa(int(b.Int64()))\n\treturn sign + strings.Join(parts[j:], \",\")\n}\n"
        },
        {
          "name": "comma_test.go",
          "type": "blob",
          "size": 5.333984375,
          "content": "package humanize\n\nimport (\n\t\"math\"\n\t\"math/big\"\n\t\"testing\"\n)\n\nfunc TestCommas(t *testing.T) {\n\ttestList{\n\t\t{\"0\", Comma(0), \"0\"},\n\t\t{\"10\", Comma(10), \"10\"},\n\t\t{\"100\", Comma(100), \"100\"},\n\t\t{\"1,000\", Comma(1000), \"1,000\"},\n\t\t{\"10,000\", Comma(10000), \"10,000\"},\n\t\t{\"100,000\", Comma(100000), \"100,000\"},\n\t\t{\"10,000,000\", Comma(10000000), \"10,000,000\"},\n\t\t{\"10,100,000\", Comma(10100000), \"10,100,000\"},\n\t\t{\"10,010,000\", Comma(10010000), \"10,010,000\"},\n\t\t{\"10,001,000\", Comma(10001000), \"10,001,000\"},\n\t\t{\"123,456,789\", Comma(123456789), \"123,456,789\"},\n\t\t{\"maxint\", Comma(9.223372e+18), \"9,223,372,000,000,000,000\"},\n\t\t{\"math.maxint\", Comma(math.MaxInt64), \"9,223,372,036,854,775,807\"},\n\t\t{\"math.minint\", Comma(math.MinInt64), \"-9,223,372,036,854,775,808\"},\n\t\t{\"minint\", Comma(-9.223372e+18), \"-9,223,372,000,000,000,000\"},\n\t\t{\"-123,456,789\", Comma(-123456789), \"-123,456,789\"},\n\t\t{\"-10,100,000\", Comma(-10100000), \"-10,100,000\"},\n\t\t{\"-10,010,000\", Comma(-10010000), \"-10,010,000\"},\n\t\t{\"-10,001,000\", Comma(-10001000), \"-10,001,000\"},\n\t\t{\"-10,000,000\", Comma(-10000000), \"-10,000,000\"},\n\t\t{\"-100,000\", Comma(-100000), \"-100,000\"},\n\t\t{\"-10,000\", Comma(-10000), \"-10,000\"},\n\t\t{\"-1,000\", Comma(-1000), \"-1,000\"},\n\t\t{\"-100\", Comma(-100), \"-100\"},\n\t\t{\"-10\", Comma(-10), \"-10\"},\n\t}.validate(t)\n}\n\nfunc TestCommafWithDigits(t *testing.T) {\n\ttestList{\n\t\t{\"1.23, 0\", CommafWithDigits(1.23, 0), \"1\"},\n\t\t{\"1.23, 1\", CommafWithDigits(1.23, 1), \"1.2\"},\n\t\t{\"1.23, 2\", CommafWithDigits(1.23, 2), \"1.23\"},\n\t\t{\"1.23, 3\", CommafWithDigits(1.23, 3), \"1.23\"},\n\t}.validate(t)\n}\n\nfunc TestCommafs(t *testing.T) {\n\ttestList{\n\t\t{\"0\", Commaf(0), \"0\"},\n\t\t{\"10.11\", Commaf(10.11), \"10.11\"},\n\t\t{\"100\", Commaf(100), \"100\"},\n\t\t{\"1,000\", Commaf(1000), \"1,000\"},\n\t\t{\"10,000\", Commaf(10000), \"10,000\"},\n\t\t{\"100,000\", Commaf(100000), \"100,000\"},\n\t\t{\"834,142.32\", Commaf(834142.32), \"834,142.32\"},\n\t\t{\"10,000,000\", Commaf(10000000), \"10,000,000\"},\n\t\t{\"10,100,000\", Commaf(10100000), \"10,100,000\"},\n\t\t{\"10,010,000\", Commaf(10010000), \"10,010,000\"},\n\t\t{\"10,001,000\", Commaf(10001000), \"10,001,000\"},\n\t\t{\"123,456,789\", Commaf(123456789), \"123,456,789\"},\n\t\t{\"maxf64\", Commaf(math.MaxFloat64), \"179,769,313,486,231,570,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000\"},\n\t\t{\"minf64\", Commaf(math.SmallestNonzeroFloat64), \"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005\"},\n\t\t{\"-123,456,789\", Commaf(-123456789), \"-123,456,789\"},\n\t\t{\"-10,100,000\", Commaf(-10100000), \"-10,100,000\"},\n\t\t{\"-10,010,000\", Commaf(-10010000), \"-10,010,000\"},\n\t\t{\"-10,001,000\", Commaf(-10001000), \"-10,001,000\"},\n\t\t{\"-10,000,000\", Commaf(-10000000), \"-10,000,000\"},\n\t\t{\"-100,000\", Commaf(-100000), \"-100,000\"},\n\t\t{\"-10,000\", Commaf(-10000), \"-10,000\"},\n\t\t{\"-1,000\", Commaf(-1000), \"-1,000\"},\n\t\t{\"-100.11\", Commaf(-100.11), \"-100.11\"},\n\t\t{\"-10\", Commaf(-10), \"-10\"},\n\t}.validate(t)\n}\n\nfunc BenchmarkCommas(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tComma(1234567890)\n\t}\n}\n\nfunc BenchmarkCommaf(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCommaf(1234567890.83584)\n\t}\n}\n\nfunc BenchmarkBigCommas(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tBigComma(big.NewInt(1234567890))\n\t}\n}\n\nfunc bigComma(i int64) string {\n\treturn BigComma(big.NewInt(i))\n}\n\nfunc TestBigCommas(t *testing.T) {\n\ttestList{\n\t\t{\"0\", bigComma(0), \"0\"},\n\t\t{\"10\", bigComma(10), \"10\"},\n\t\t{\"100\", bigComma(100), \"100\"},\n\t\t{\"1,000\", bigComma(1000), \"1,000\"},\n\t\t{\"10,000\", bigComma(10000), \"10,000\"},\n\t\t{\"100,000\", bigComma(100000), \"100,000\"},\n\t\t{\"10,000,000\", bigComma(10000000), \"10,000,000\"},\n\t\t{\"10,100,000\", bigComma(10100000), \"10,100,000\"},\n\t\t{\"10,010,000\", bigComma(10010000), \"10,010,000\"},\n\t\t{\"10,001,000\", bigComma(10001000), \"10,001,000\"},\n\t\t{\"123,456,789\", bigComma(123456789), \"123,456,789\"},\n\t\t{\"maxint\", bigComma(9.223372e+18), \"9,223,372,000,000,000,000\"},\n\t\t{\"minint\", bigComma(-9.223372e+18), \"-9,223,372,000,000,000,000\"},\n\t\t{\"-123,456,789\", bigComma(-123456789), \"-123,456,789\"},\n\t\t{\"-10,100,000\", bigComma(-10100000), \"-10,100,000\"},\n\t\t{\"-10,010,000\", bigComma(-10010000), \"-10,010,000\"},\n\t\t{\"-10,001,000\", bigComma(-10001000), \"-10,001,000\"},\n\t\t{\"-10,000,000\", bigComma(-10000000), \"-10,000,000\"},\n\t\t{\"-100,000\", bigComma(-100000), \"-100,000\"},\n\t\t{\"-10,000\", bigComma(-10000), \"-10,000\"},\n\t\t{\"-1,000\", bigComma(-1000), \"-1,000\"},\n\t\t{\"-100\", bigComma(-100), \"-100\"},\n\t\t{\"-10\", bigComma(-10), \"-10\"},\n\t}.validate(t)\n}\n\nfunc TestVeryBigCommas(t *testing.T) {\n\ttests := []struct{ in, exp string }{\n\t\t{\n\t\t\t\"84889279597249724975972597249849757294578485\",\n\t\t\t\"84,889,279,597,249,724,975,972,597,249,849,757,294,578,485\",\n\t\t},\n\t\t{\n\t\t\t\"-84889279597249724975972597249849757294578485\",\n\t\t\t\"-84,889,279,597,249,724,975,972,597,249,849,757,294,578,485\",\n\t\t},\n\t}\n\tfor _, test := range tests {\n\t\tn, _ := (&big.Int{}).SetString(test.in, 10)\n\t\tgot := BigComma(n)\n\t\tif test.exp != got {\n\t\t\tt.Errorf(\"Expected %q, got %q\", test.exp, got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "commaf.go",
          "type": "blob",
          "size": 0.744140625,
          "content": "//go:build go1.6\n// +build go1.6\n\npackage humanize\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n\t\"strings\"\n)\n\n// BigCommaf produces a string form of the given big.Float in base 10\n// with commas after every three orders of magnitude.\nfunc BigCommaf(v *big.Float) string {\n\tbuf := &bytes.Buffer{}\n\tif v.Sign() < 0 {\n\t\tbuf.Write([]byte{'-'})\n\t\tv.Abs(v)\n\t}\n\n\tcomma := []byte{','}\n\n\tparts := strings.Split(v.Text('f', -1), \".\")\n\tpos := 0\n\tif len(parts[0])%3 != 0 {\n\t\tpos += len(parts[0]) % 3\n\t\tbuf.WriteString(parts[0][:pos])\n\t\tbuf.Write(comma)\n\t}\n\tfor ; pos < len(parts[0]); pos += 3 {\n\t\tbuf.WriteString(parts[0][pos : pos+3])\n\t\tbuf.Write(comma)\n\t}\n\tbuf.Truncate(buf.Len() - 1)\n\n\tif len(parts) > 1 {\n\t\tbuf.Write([]byte{'.'})\n\t\tbuf.WriteString(parts[1])\n\t}\n\treturn buf.String()\n}\n"
        },
        {
          "name": "commaf_test.go",
          "type": "blob",
          "size": 2.44140625,
          "content": "//go:build go1.6\n// +build go1.6\n\npackage humanize\n\nimport (\n\t\"math\"\n\t\"math/big\"\n\t\"testing\"\n)\n\nfunc BenchmarkBigCommaf(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tCommaf(1234567890.83584)\n\t}\n}\n\nfunc TestBigCommafs(t *testing.T) {\n\ttestList{\n\t\t{\"0\", BigCommaf(big.NewFloat(0)), \"0\"},\n\t\t{\"10.11\", BigCommaf(big.NewFloat(10.11)), \"10.11\"},\n\t\t{\"100\", BigCommaf(big.NewFloat(100)), \"100\"},\n\t\t{\"1,000\", BigCommaf(big.NewFloat(1000)), \"1,000\"},\n\t\t{\"10,000\", BigCommaf(big.NewFloat(10000)), \"10,000\"},\n\t\t{\"100,000\", BigCommaf(big.NewFloat(100000)), \"100,000\"},\n\t\t{\"834,142.32\", BigCommaf(big.NewFloat(834142.32)), \"834,142.32\"},\n\t\t{\"10,000,000\", BigCommaf(big.NewFloat(10000000)), \"10,000,000\"},\n\t\t{\"10,100,000\", BigCommaf(big.NewFloat(10100000)), \"10,100,000\"},\n\t\t{\"10,010,000\", BigCommaf(big.NewFloat(10010000)), \"10,010,000\"},\n\t\t{\"10,001,000\", BigCommaf(big.NewFloat(10001000)), \"10,001,000\"},\n\t\t{\"123,456,789\", BigCommaf(big.NewFloat(123456789)), \"123,456,789\"},\n\t\t{\"maxf64\", BigCommaf(big.NewFloat(math.MaxFloat64)), \"179,769,313,486,231,570,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000\"},\n\t\t{\"minf64\", BigCommaf(big.NewFloat(math.SmallestNonzeroFloat64)), \"0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004940656458412465\"},\n\t\t{\"-123,456,789\", BigCommaf(big.NewFloat(-123456789)), \"-123,456,789\"},\n\t\t{\"-10,100,000\", BigCommaf(big.NewFloat(-10100000)), \"-10,100,000\"},\n\t\t{\"-10,010,000\", BigCommaf(big.NewFloat(-10010000)), \"-10,010,000\"},\n\t\t{\"-10,001,000\", BigCommaf(big.NewFloat(-10001000)), \"-10,001,000\"},\n\t\t{\"-10,000,000\", BigCommaf(big.NewFloat(-10000000)), \"-10,000,000\"},\n\t\t{\"-100,000\", BigCommaf(big.NewFloat(-100000)), \"-100,000\"},\n\t\t{\"-10,000\", BigCommaf(big.NewFloat(-10000)), \"-10,000\"},\n\t\t{\"-1,000\", BigCommaf(big.NewFloat(-1000)), \"-1,000\"},\n\t\t{\"-100.11\", BigCommaf(big.NewFloat(-100.11)), \"-100.11\"},\n\t\t{\"-10\", BigCommaf(big.NewFloat(-10)), \"-10\"},\n\t}.validate(t)\n}\n"
        },
        {
          "name": "common_test.go",
          "type": "blob",
          "size": 0.2783203125,
          "content": "package humanize\n\nimport (\n\t\"testing\"\n)\n\ntype testList []struct {\n\tname, got, exp string\n}\n\nfunc (tl testList) validate(t *testing.T) {\n\tfor _, test := range tl {\n\t\tif test.got != test.exp {\n\t\t\tt.Errorf(\"On %v, expected '%v', but got '%v'\",\n\t\t\t\ttest.name, test.exp, test.got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "english",
          "type": "tree",
          "content": null
        },
        {
          "name": "ftoa.go",
          "type": "blob",
          "size": 0.962890625,
          "content": "package humanize\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc stripTrailingZeros(s string) string {\n\tif !strings.ContainsRune(s, '.') {\n\t\treturn s\n\t}\n\toffset := len(s) - 1\n\tfor offset > 0 {\n\t\tif s[offset] == '.' {\n\t\t\toffset--\n\t\t\tbreak\n\t\t}\n\t\tif s[offset] != '0' {\n\t\t\tbreak\n\t\t}\n\t\toffset--\n\t}\n\treturn s[:offset+1]\n}\n\nfunc stripTrailingDigits(s string, digits int) string {\n\tif i := strings.Index(s, \".\"); i >= 0 {\n\t\tif digits <= 0 {\n\t\t\treturn s[:i]\n\t\t}\n\t\ti++\n\t\tif i+digits >= len(s) {\n\t\t\treturn s\n\t\t}\n\t\treturn s[:i+digits]\n\t}\n\treturn s\n}\n\n// Ftoa converts a float to a string with no trailing zeros.\nfunc Ftoa(num float64) string {\n\treturn stripTrailingZeros(strconv.FormatFloat(num, 'f', 6, 64))\n}\n\n// FtoaWithDigits converts a float to a string but limits the resulting string\n// to the given number of decimal places, and no trailing zeros.\nfunc FtoaWithDigits(num float64, digits int) string {\n\treturn stripTrailingZeros(stripTrailingDigits(strconv.FormatFloat(num, 'f', 6, 64), digits))\n}\n"
        },
        {
          "name": "ftoa_test.go",
          "type": "blob",
          "size": 2.751953125,
          "content": "package humanize\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"testing/quick\"\n)\n\nfunc TestFtoa(t *testing.T) {\n\ttestList{\n\t\t{\"200\", Ftoa(200), \"200\"},\n\t\t{\"20\", Ftoa(20.0), \"20\"},\n\t\t{\"2\", Ftoa(2), \"2\"},\n\t\t{\"2.2\", Ftoa(2.2), \"2.2\"},\n\t\t{\"2.02\", Ftoa(2.02), \"2.02\"},\n\t\t{\"200.02\", Ftoa(200.02), \"200.02\"},\n\t}.validate(t)\n}\n\nfunc TestFtoaWithDigits(t *testing.T) {\n\ttestList{\n\t\t{\"1.23, 0\", FtoaWithDigits(1.23, 0), \"1\"},\n\t\t{\"20, 0\", FtoaWithDigits(20.0, 0), \"20\"},\n\t\t{\"1.23, 1\", FtoaWithDigits(1.23, 1), \"1.2\"},\n\t\t{\"1.23, 2\", FtoaWithDigits(1.23, 2), \"1.23\"},\n\t\t{\"1.23, 3\", FtoaWithDigits(1.23, 3), \"1.23\"},\n\t}.validate(t)\n}\n\nfunc TestStripTrailingDigits(t *testing.T) {\n\terr := quick.Check(func(s string, digits int) bool {\n\t\tstripped := stripTrailingDigits(s, digits)\n\n\t\t// A stripped string will always be a prefix of its original string\n\t\tif !strings.HasPrefix(s, stripped) {\n\t\t\treturn false\n\t\t}\n\n\t\tif strings.ContainsRune(s, '.') {\n\t\t\t// If there is a dot, the part on the left of the dot will never change\n\t\t\ta := strings.Split(s, \".\")\n\t\t\tb := strings.Split(stripped, \".\")\n\t\t\tif a[0] != b[0] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\t// If there's no dot in the input, the output will always be the same as the input.\n\t\t\tif stripped != s {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}, &quick.Config{\n\t\tMaxCount: 10000,\n\t\tValues: func(v []reflect.Value, r *rand.Rand) {\n\t\t\trdigs := func(n int) string {\n\t\t\t\tdigs := []rune{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}\n\t\t\t\tvar rv []rune\n\t\t\t\tfor i := 0; i < n; i++ {\n\t\t\t\t\trv = append(rv, digs[r.Intn(len(digs))])\n\t\t\t\t}\n\t\t\t\treturn string(rv)\n\t\t\t}\n\n\t\t\tls := r.Intn(20)\n\t\t\trs := r.Intn(20)\n\t\t\tjc := \".\"\n\t\t\tif rs == 0 {\n\t\t\t\tjc = \"\"\n\t\t\t}\n\t\t\ts := rdigs(ls) + jc + rdigs(rs)\n\t\t\tdigits := r.Intn(len(s) + 1)\n\n\t\t\tv[0] = reflect.ValueOf(s)\n\t\t\tv[1] = reflect.ValueOf(digits)\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc BenchmarkFtoaRegexTrailing(b *testing.B) {\n\ttrailingZerosRegex := regexp.MustCompile(`\\.?0+$`)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttrailingZerosRegex.ReplaceAllString(\"2.00000\", \"\")\n\t\ttrailingZerosRegex.ReplaceAllString(\"2.0000\", \"\")\n\t\ttrailingZerosRegex.ReplaceAllString(\"2.000\", \"\")\n\t\ttrailingZerosRegex.ReplaceAllString(\"2.00\", \"\")\n\t\ttrailingZerosRegex.ReplaceAllString(\"2.0\", \"\")\n\t\ttrailingZerosRegex.ReplaceAllString(\"2\", \"\")\n\t}\n}\n\nfunc BenchmarkFtoaFunc(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tstripTrailingZeros(\"2.00000\")\n\t\tstripTrailingZeros(\"2.0000\")\n\t\tstripTrailingZeros(\"2.000\")\n\t\tstripTrailingZeros(\"2.00\")\n\t\tstripTrailingZeros(\"2.0\")\n\t\tstripTrailingZeros(\"2\")\n\t}\n}\n\nfunc BenchmarkFmtF(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = fmt.Sprintf(\"%f\", 2.03584)\n\t}\n}\n\nfunc BenchmarkStrconvF(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tstrconv.FormatFloat(2.03584, 'f', 6, 64)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.044921875,
          "content": "module github.com/dustin/go-humanize\n\ngo 1.16\n"
        },
        {
          "name": "humanize.go",
          "type": "blob",
          "size": 0.26953125,
          "content": "/*\nPackage humanize converts boring ugly numbers to human-friendly strings and back.\n\nDurations can be turned into strings such as \"3 days ago\", numbers\nrepresenting sizes like 82854982 into useful strings like, \"83 MB\" or\n\"79 MiB\" (whichever you prefer).\n*/\npackage humanize\n"
        },
        {
          "name": "number.go",
          "type": "blob",
          "size": 4.2216796875,
          "content": "package humanize\n\n/*\nSlightly adapted from the source to fit go-humanize.\n\nAuthor: https://github.com/gorhill\nSource: https://gist.github.com/gorhill/5285193\n\n*/\n\nimport (\n\t\"math\"\n\t\"strconv\"\n)\n\nvar (\n\trenderFloatPrecisionMultipliers = [...]float64{\n\t\t1,\n\t\t10,\n\t\t100,\n\t\t1000,\n\t\t10000,\n\t\t100000,\n\t\t1000000,\n\t\t10000000,\n\t\t100000000,\n\t\t1000000000,\n\t}\n\n\trenderFloatPrecisionRounders = [...]float64{\n\t\t0.5,\n\t\t0.05,\n\t\t0.005,\n\t\t0.0005,\n\t\t0.00005,\n\t\t0.000005,\n\t\t0.0000005,\n\t\t0.00000005,\n\t\t0.000000005,\n\t\t0.0000000005,\n\t}\n)\n\n// FormatFloat produces a formatted number as string based on the following user-specified criteria:\n//\n// * thousands separator\n// * decimal separator\n// * decimal precision\n//\n// Usage: s := FormatFloat(format, n)\n// The format parameter tells how to render the number n.\n//\n// See examples: http://play.golang.org/p/LXc1Ddm1lJ\n//\n// Examples of format strings, given n = 12345.6789:\n// \"#,###.##\" => \"12,345.67\"\n// \"#,###.\" => \"12,345\"\n// \"#,###\" => \"12345,678\"\n// \"#\\u202F###,##\" => \"12â€¯345,68\"\n// \"#.###,###### => 12.345,678900\n// \"\" (aka default format) => 12,345.67\n//\n// The highest precision allowed is 9 digits after the decimal symbol.\n// There is also a version for integer number, FormatInteger(),\n// which is convenient for calls within template.\nfunc FormatFloat(format string, n float64) string {\n\t// Special cases:\n\t//   NaN = \"NaN\"\n\t//   +Inf = \"+Infinity\"\n\t//   -Inf = \"-Infinity\"\n\tif math.IsNaN(n) {\n\t\treturn \"NaN\"\n\t}\n\tif n > math.MaxFloat64 {\n\t\treturn \"Infinity\"\n\t}\n\tif n < (0.0 - math.MaxFloat64) {\n\t\treturn \"-Infinity\"\n\t}\n\n\t// default format\n\tprecision := 2\n\tdecimalStr := \".\"\n\tthousandStr := \",\"\n\tpositiveStr := \"\"\n\tnegativeStr := \"-\"\n\n\tif len(format) > 0 {\n\t\tformat := []rune(format)\n\n\t\t// If there is an explicit format directive,\n\t\t// then default values are these:\n\t\tprecision = 9\n\t\tthousandStr = \"\"\n\n\t\t// collect indices of meaningful formatting directives\n\t\tformatIndx := []int{}\n\t\tfor i, char := range format {\n\t\t\tif char != '#' && char != '0' {\n\t\t\t\tformatIndx = append(formatIndx, i)\n\t\t\t}\n\t\t}\n\n\t\tif len(formatIndx) > 0 {\n\t\t\t// Directive at index 0:\n\t\t\t//   Must be a '+'\n\t\t\t//   Raise an error if not the case\n\t\t\t// index: 0123456789\n\t\t\t//        +0.000,000\n\t\t\t//        +000,000.0\n\t\t\t//        +0000.00\n\t\t\t//        +0000\n\t\t\tif formatIndx[0] == 0 {\n\t\t\t\tif format[formatIndx[0]] != '+' {\n\t\t\t\t\tpanic(\"FormatFloat(): invalid positive sign directive\")\n\t\t\t\t}\n\t\t\t\tpositiveStr = \"+\"\n\t\t\t\tformatIndx = formatIndx[1:]\n\t\t\t}\n\n\t\t\t// Two directives:\n\t\t\t//   First is thousands separator\n\t\t\t//   Raise an error if not followed by 3-digit\n\t\t\t// 0123456789\n\t\t\t// 0.000,000\n\t\t\t// 000,000.00\n\t\t\tif len(formatIndx) == 2 {\n\t\t\t\tif (formatIndx[1] - formatIndx[0]) != 4 {\n\t\t\t\t\tpanic(\"FormatFloat(): thousands separator directive must be followed by 3 digit-specifiers\")\n\t\t\t\t}\n\t\t\t\tthousandStr = string(format[formatIndx[0]])\n\t\t\t\tformatIndx = formatIndx[1:]\n\t\t\t}\n\n\t\t\t// One directive:\n\t\t\t//   Directive is decimal separator\n\t\t\t//   The number of digit-specifier following the separator indicates wanted precision\n\t\t\t// 0123456789\n\t\t\t// 0.00\n\t\t\t// 000,0000\n\t\t\tif len(formatIndx) == 1 {\n\t\t\t\tdecimalStr = string(format[formatIndx[0]])\n\t\t\t\tprecision = len(format) - formatIndx[0] - 1\n\t\t\t}\n\t\t}\n\t}\n\n\t// generate sign part\n\tvar signStr string\n\tif n >= 0.000000001 {\n\t\tsignStr = positiveStr\n\t} else if n <= -0.000000001 {\n\t\tsignStr = negativeStr\n\t\tn = -n\n\t} else {\n\t\tsignStr = \"\"\n\t\tn = 0.0\n\t}\n\n\t// split number into integer and fractional parts\n\tintf, fracf := math.Modf(n + renderFloatPrecisionRounders[precision])\n\n\t// generate integer part string\n\tintStr := strconv.FormatInt(int64(intf), 10)\n\n\t// add thousand separator if required\n\tif len(thousandStr) > 0 {\n\t\tfor i := len(intStr); i > 3; {\n\t\t\ti -= 3\n\t\t\tintStr = intStr[:i] + thousandStr + intStr[i:]\n\t\t}\n\t}\n\n\t// no fractional part, we can leave now\n\tif precision == 0 {\n\t\treturn signStr + intStr\n\t}\n\n\t// generate fractional part\n\tfracStr := strconv.Itoa(int(fracf * renderFloatPrecisionMultipliers[precision]))\n\t// may need padding\n\tif len(fracStr) < precision {\n\t\tfracStr = \"000000000000000\"[:precision-len(fracStr)] + fracStr\n\t}\n\n\treturn signStr + intStr + decimalStr + fracStr\n}\n\n// FormatInteger produces a formatted number as string.\n// See FormatFloat.\nfunc FormatInteger(format string, n int) string {\n\treturn FormatFloat(format, float64(n))\n}\n"
        },
        {
          "name": "number_test.go",
          "type": "blob",
          "size": 2.2080078125,
          "content": "package humanize\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\ntype TestStruct struct {\n\tname      string\n\tformat    string\n\tnum       float64\n\tformatted string\n}\n\nfunc TestFormatFloat(t *testing.T) {\n\ttests := []TestStruct{\n\t\t{\"default\", \"\", 12345.6789, \"12,345.68\"},\n\t\t{\"#\", \"#\", 12345.6789, \"12345.678900000\"},\n\t\t{\"#.\", \"#.\", 12345.6789, \"12346\"},\n\t\t{\"#,#\", \"#,#\", 12345.6789, \"12345,7\"},\n\t\t{\"#,##\", \"#,##\", 12345.6789, \"12345,68\"},\n\t\t{\"#,###\", \"#,###\", 12345.6789, \"12345,679\"},\n\t\t{\"#,###.\", \"#,###.\", 12345.6789, \"12,346\"},\n\t\t{\"#,###.##\", \"#,###.##\", 12345.6789, \"12,345.68\"},\n\t\t{\"#,###.###\", \"#,###.###\", 12345.6789, \"12,345.679\"},\n\t\t{\"#,###.####\", \"#,###.####\", 12345.6789, \"12,345.6789\"},\n\t\t{\"#.###,######\", \"#.###,######\", 12345.6789, \"12.345,678900\"},\n\t\t{\"bug46\", \"#,###.##\", 52746220055.92342, \"52,746,220,055.92\"},\n\t\t{\"#\\u202f###,##\", \"#\\u202f###,##\", 12345.6789, \"12â€¯345,68\"},\n\n\t\t// special cases\n\t\t{\"NaN\", \"#\", math.NaN(), \"NaN\"},\n\t\t{\"+Inf\", \"#\", math.Inf(1), \"Infinity\"},\n\t\t{\"-Inf\", \"#\", math.Inf(-1), \"-Infinity\"},\n\t\t{\"signStr <= -0.000000001\", \"\", -0.000000002, \"-0.00\"},\n\t\t{\"signStr = 0\", \"\", 0, \"0.00\"},\n\t\t{\"Format directive must start with +\", \"+000\", 12345.6789, \"+12345.678900000\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := FormatFloat(test.format, test.num)\n\t\tif got != test.formatted {\n\t\t\tt.Errorf(\"On %v (%v, %v), got %v, wanted %v\",\n\t\t\t\ttest.name, test.format, test.num, got, test.formatted)\n\t\t}\n\t}\n\t// Test a single integer\n\tgot := FormatInteger(\"#\", 12345)\n\tif got != \"12345.000000000\" {\n\t\tt.Errorf(\"On %v (%v, %v), got %v, wanted %v\",\n\t\t\t\"integerTest\", \"#\", 12345, got, \"12345.000000000\")\n\t}\n\t// Test the things that could panic\n\tpanictests := []TestStruct{\n\t\t{\"FormatFloat(): invalid positive sign directive\", \"-\", 12345.6789, \"12,345.68\"},\n\t\t{\"FormatFloat(): thousands separator directive must be followed by 3 digit-specifiers\", \"0.01\", 12345.6789, \"12,345.68\"},\n\t}\n\tfor _, test := range panictests {\n\t\tdidPanic := false\n\t\tvar message interface{}\n\t\tfunc() {\n\n\t\t\tdefer func() {\n\t\t\t\tif message = recover(); message != nil {\n\t\t\t\t\tdidPanic = true\n\t\t\t\t}\n\t\t\t}()\n\n\t\t\t// call the target function\n\t\t\t_ = FormatFloat(test.format, test.num)\n\n\t\t}()\n\t\tif didPanic != true {\n\t\t\tt.Errorf(\"On %v, should have panic and did not.\",\n\t\t\t\ttest.name)\n\t\t}\n\t}\n\n}\n"
        },
        {
          "name": "ordinals.go",
          "type": "blob",
          "size": 0.3623046875,
          "content": "package humanize\n\nimport \"strconv\"\n\n// Ordinal gives you the input number in a rank/ordinal format.\n//\n// Ordinal(3) -> 3rd\nfunc Ordinal(x int) string {\n\tsuffix := \"th\"\n\tswitch x % 10 {\n\tcase 1:\n\t\tif x%100 != 11 {\n\t\t\tsuffix = \"st\"\n\t\t}\n\tcase 2:\n\t\tif x%100 != 12 {\n\t\t\tsuffix = \"nd\"\n\t\t}\n\tcase 3:\n\t\tif x%100 != 13 {\n\t\t\tsuffix = \"rd\"\n\t\t}\n\t}\n\treturn strconv.Itoa(x) + suffix\n}\n"
        },
        {
          "name": "ordinals_test.go",
          "type": "blob",
          "size": 0.6484375,
          "content": "package humanize\n\nimport (\n\t\"testing\"\n)\n\nfunc TestOrdinals(t *testing.T) {\n\ttestList{\n\t\t{\"0\", Ordinal(0), \"0th\"},\n\t\t{\"1\", Ordinal(1), \"1st\"},\n\t\t{\"2\", Ordinal(2), \"2nd\"},\n\t\t{\"3\", Ordinal(3), \"3rd\"},\n\t\t{\"4\", Ordinal(4), \"4th\"},\n\t\t{\"10\", Ordinal(10), \"10th\"},\n\t\t{\"11\", Ordinal(11), \"11th\"},\n\t\t{\"12\", Ordinal(12), \"12th\"},\n\t\t{\"13\", Ordinal(13), \"13th\"},\n\t\t{\"21\", Ordinal(21), \"21st\"},\n\t\t{\"32\", Ordinal(32), \"32nd\"},\n\t\t{\"43\", Ordinal(43), \"43rd\"},\n\t\t{\"101\", Ordinal(101), \"101st\"},\n\t\t{\"102\", Ordinal(102), \"102nd\"},\n\t\t{\"103\", Ordinal(103), \"103rd\"},\n\t\t{\"211\", Ordinal(211), \"211th\"},\n\t\t{\"212\", Ordinal(212), \"212th\"},\n\t\t{\"213\", Ordinal(213), \"213th\"},\n\t}.validate(t)\n}\n"
        },
        {
          "name": "si.go",
          "type": "blob",
          "size": 2.8408203125,
          "content": "package humanize\n\nimport (\n\t\"errors\"\n\t\"math\"\n\t\"regexp\"\n\t\"strconv\"\n)\n\nvar siPrefixTable = map[float64]string{\n\t-30: \"q\", // quecto\n\t-27: \"r\", // ronto\n\t-24: \"y\", // yocto\n\t-21: \"z\", // zepto\n\t-18: \"a\", // atto\n\t-15: \"f\", // femto\n\t-12: \"p\", // pico\n\t-9:  \"n\", // nano\n\t-6:  \"Âµ\", // micro\n\t-3:  \"m\", // milli\n\t0:   \"\",\n\t3:   \"k\", // kilo\n\t6:   \"M\", // mega\n\t9:   \"G\", // giga\n\t12:  \"T\", // tera\n\t15:  \"P\", // peta\n\t18:  \"E\", // exa\n\t21:  \"Z\", // zetta\n\t24:  \"Y\", // yotta\n\t27:  \"R\", // ronna\n\t30:  \"Q\", // quetta\n}\n\nvar revSIPrefixTable = revfmap(siPrefixTable)\n\n// revfmap reverses the map and precomputes the power multiplier\nfunc revfmap(in map[float64]string) map[string]float64 {\n\trv := map[string]float64{}\n\tfor k, v := range in {\n\t\trv[v] = math.Pow(10, k)\n\t}\n\treturn rv\n}\n\nvar riParseRegex *regexp.Regexp\n\nfunc init() {\n\tri := `^([\\-0-9.]+)\\s?([`\n\tfor _, v := range siPrefixTable {\n\t\tri += v\n\t}\n\tri += `]?)(.*)`\n\n\triParseRegex = regexp.MustCompile(ri)\n}\n\n// ComputeSI finds the most appropriate SI prefix for the given number\n// and returns the prefix along with the value adjusted to be within\n// that prefix.\n//\n// See also: SI, ParseSI.\n//\n// e.g. ComputeSI(2.2345e-12) -> (2.2345, \"p\")\nfunc ComputeSI(input float64) (float64, string) {\n\tif input == 0 {\n\t\treturn 0, \"\"\n\t}\n\tmag := math.Abs(input)\n\texponent := math.Floor(logn(mag, 10))\n\texponent = math.Floor(exponent/3) * 3\n\n\tvalue := mag / math.Pow(10, exponent)\n\n\t// Handle special case where value is exactly 1000.0\n\t// Should return 1 M instead of 1000 k\n\tif value == 1000.0 {\n\t\texponent += 3\n\t\tvalue = mag / math.Pow(10, exponent)\n\t}\n\n\tvalue = math.Copysign(value, input)\n\n\tprefix := siPrefixTable[exponent]\n\treturn value, prefix\n}\n\n// SI returns a string with default formatting.\n//\n// SI uses Ftoa to format float value, removing trailing zeros.\n//\n// See also: ComputeSI, ParseSI.\n//\n// e.g. SI(1000000, \"B\") -> 1 MB\n// e.g. SI(2.2345e-12, \"F\") -> 2.2345 pF\nfunc SI(input float64, unit string) string {\n\tvalue, prefix := ComputeSI(input)\n\treturn Ftoa(value) + \" \" + prefix + unit\n}\n\n// SIWithDigits works like SI but limits the resulting string to the\n// given number of decimal places.\n//\n// e.g. SIWithDigits(1000000, 0, \"B\") -> 1 MB\n// e.g. SIWithDigits(2.2345e-12, 2, \"F\") -> 2.23 pF\nfunc SIWithDigits(input float64, decimals int, unit string) string {\n\tvalue, prefix := ComputeSI(input)\n\treturn FtoaWithDigits(value, decimals) + \" \" + prefix + unit\n}\n\nvar errInvalid = errors.New(\"invalid input\")\n\n// ParseSI parses an SI string back into the number and unit.\n//\n// See also: SI, ComputeSI.\n//\n// e.g. ParseSI(\"2.2345 pF\") -> (2.2345e-12, \"F\", nil)\nfunc ParseSI(input string) (float64, string, error) {\n\tfound := riParseRegex.FindStringSubmatch(input)\n\tif len(found) != 4 {\n\t\treturn 0, \"\", errInvalid\n\t}\n\tmag := revSIPrefixTable[found[2]]\n\tunit := found[3]\n\n\tbase, err := strconv.ParseFloat(found[1], 64)\n\treturn base * mag, unit, err\n}\n"
        },
        {
          "name": "si_test.go",
          "type": "blob",
          "size": 3.326171875,
          "content": "package humanize\n\nimport (\n\t\"math\"\n\t\"testing\"\n)\n\nfunc TestSI(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tnum       float64\n\t\tformatted string\n\t}{\n\t\t{\"e-30\", 1e-30, \"1 qF\"},\n\t\t{\"e-27\", 1e-27, \"1 rF\"},\n\t\t{\"e-24\", 1e-24, \"1 yF\"},\n\t\t{\"e-21\", 1e-21, \"1 zF\"},\n\t\t{\"e-18\", 1e-18, \"1 aF\"},\n\t\t{\"e-15\", 1e-15, \"1 fF\"},\n\t\t{\"e-12\", 1e-12, \"1 pF\"},\n\t\t{\"e-12\", 2.2345e-12, \"2.2345 pF\"},\n\t\t{\"e-12\", 2.23e-12, \"2.23 pF\"},\n\t\t{\"e-11\", 2.23e-11, \"22.3 pF\"},\n\t\t{\"e-10\", 2.2e-10, \"220 pF\"},\n\t\t{\"e-9\", 2.2e-9, \"2.2 nF\"},\n\t\t{\"e-8\", 2.2e-8, \"22 nF\"},\n\t\t{\"e-7\", 2.2e-7, \"220 nF\"},\n\t\t{\"e-6\", 2.2e-6, \"2.2 ÂµF\"},\n\t\t{\"e-6\", 1e-6, \"1 ÂµF\"},\n\t\t{\"e-5\", 2.2e-5, \"22 ÂµF\"},\n\t\t{\"e-4\", 2.2e-4, \"220 ÂµF\"},\n\t\t{\"e-3\", 2.2e-3, \"2.2 mF\"},\n\t\t{\"e-2\", 2.2e-2, \"22 mF\"},\n\t\t{\"e-1\", 2.2e-1, \"220 mF\"},\n\t\t{\"e+0\", 2.2e-0, \"2.2 F\"},\n\t\t{\"e+0\", 2.2, \"2.2 F\"},\n\t\t{\"e+1\", 2.2e+1, \"22 F\"},\n\t\t{\"0\", 0, \"0 F\"},\n\t\t{\"e+1\", 22, \"22 F\"},\n\t\t{\"e+2\", 2.2e+2, \"220 F\"},\n\t\t{\"e+2\", 220, \"220 F\"},\n\t\t{\"e+3\", 2.2e+3, \"2.2 kF\"},\n\t\t{\"e+3\", 2200, \"2.2 kF\"},\n\t\t{\"e+4\", 2.2e+4, \"22 kF\"},\n\t\t{\"e+4\", 22000, \"22 kF\"},\n\t\t{\"e+5\", 2.2e+5, \"220 kF\"},\n\t\t{\"e+6\", 2.2e+6, \"2.2 MF\"},\n\t\t{\"e+6\", 1e+6, \"1 MF\"},\n\t\t{\"e+7\", 2.2e+7, \"22 MF\"},\n\t\t{\"e+8\", 2.2e+8, \"220 MF\"},\n\t\t{\"e+9\", 2.2e+9, \"2.2 GF\"},\n\t\t{\"e+10\", 2.2e+10, \"22 GF\"},\n\t\t{\"e+11\", 2.2e+11, \"220 GF\"},\n\t\t{\"e+12\", 2.2e+12, \"2.2 TF\"},\n\t\t{\"e+15\", 2.2e+15, \"2.2 PF\"},\n\t\t{\"e+18\", 2.2e+18, \"2.2 EF\"},\n\t\t{\"e+21\", 2.2e+21, \"2.2 ZF\"},\n\t\t{\"e+24\", 2.2e+24, \"2.2 YF\"},\n\t\t{\"e+27\", 2.2e+27, \"2.2 RF\"},\n\t\t{\"e+30\", 2.2e+30, \"2.2 QF\"},\n\n\t\t// special case\n\t\t{\"1F\", 1000 * 1000, \"1 MF\"},\n\t\t{\"1F\", 1e6, \"1 MF\"},\n\n\t\t// negative number\n\t\t{\"-100 F\", -100, \"-100 F\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := SI(test.num, \"F\")\n\t\tif got != test.formatted {\n\t\t\tt.Errorf(\"On %v (%v), got %v, wanted %v\",\n\t\t\t\ttest.name, test.num, got, test.formatted)\n\t\t}\n\n\t\tgotf, gotu, err := ParseSI(test.formatted)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error parsing %v (%v): %v\", test.name, test.formatted, err)\n\t\t\tcontinue\n\t\t}\n\n\t\tif math.Abs(1-(gotf/test.num)) > 0.01 {\n\t\t\tt.Errorf(\"On %v (%v), got %v, wanted %v (Â±%v)\",\n\t\t\t\ttest.name, test.formatted, gotf, test.num,\n\t\t\t\tmath.Abs(1-(gotf/test.num)))\n\t\t}\n\t\tif gotu != \"F\" {\n\t\t\tt.Errorf(\"On %v (%v), expected unit F, got %v\",\n\t\t\t\ttest.name, test.formatted, gotu)\n\t\t}\n\t}\n\n\t// Parse error\n\tgotf, gotu, err := ParseSI(\"x1.21JW\") // 1.21 jigga whats\n\tif err == nil {\n\t\tt.Errorf(\"Expected error on x1.21JW, got %v %v\", gotf, gotu)\n\t}\n}\n\nfunc TestSIWithDigits(t *testing.T) {\n\ttests := []struct {\n\t\tname      string\n\t\tnum       float64\n\t\tdigits    int\n\t\tformatted string\n\t}{\n\t\t{\"e-12\", 2.234e-12, 0, \"2 pF\"},\n\t\t{\"e-12\", 2.234e-12, 1, \"2.2 pF\"},\n\t\t{\"e-12\", 2.234e-12, 2, \"2.23 pF\"},\n\t\t{\"e-12\", 2.234e-12, 3, \"2.234 pF\"},\n\t\t{\"e-12\", 2.234e-12, 4, \"2.234 pF\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot := SIWithDigits(test.num, test.digits, \"F\")\n\t\tif got != test.formatted {\n\t\t\tt.Errorf(\"On %v (%v), got %v, wanted %v\",\n\t\t\t\ttest.name, test.num, got, test.formatted)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParseSI(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\tParseSI(\"2.2346ZB\")\n\t}\n}\n\n// There was a report that zeroes were being truncated incorrectly\nfunc TestBug106(t *testing.T) {\n\ttests := []struct{\n\t\tin float64\n\t\twant string\n\t}{\n\t\t{20.0, \"20 U\"},\n\t\t{200.0, \"200 U\"},\n\t}\n\n\tfor _, test := range tests {\n\t\tif got :=SIWithDigits(test.in, 0, \"U\") ;  got != test.want {\n\t\t\tt.Errorf(\"on %f got %v, want %v\", test.in, got, test.want);\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "times.go",
          "type": "blob",
          "size": 3.1630859375,
          "content": "package humanize\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"sort\"\n\t\"time\"\n)\n\n// Seconds-based time units\nconst (\n\tDay      = 24 * time.Hour\n\tWeek     = 7 * Day\n\tMonth    = 30 * Day\n\tYear     = 12 * Month\n\tLongTime = 37 * Year\n)\n\n// Time formats a time into a relative string.\n//\n// Time(someT) -> \"3 weeks ago\"\nfunc Time(then time.Time) string {\n\treturn RelTime(then, time.Now(), \"ago\", \"from now\")\n}\n\n// A RelTimeMagnitude struct contains a relative time point at which\n// the relative format of time will switch to a new format string.  A\n// slice of these in ascending order by their \"D\" field is passed to\n// CustomRelTime to format durations.\n//\n// The Format field is a string that may contain a \"%s\" which will be\n// replaced with the appropriate signed label (e.g. \"ago\" or \"from\n// now\") and a \"%d\" that will be replaced by the quantity.\n//\n// The DivBy field is the amount of time the time difference must be\n// divided by in order to display correctly.\n//\n// e.g. if D is 2*time.Minute and you want to display \"%d minutes %s\"\n// DivBy should be time.Minute so whatever the duration is will be\n// expressed in minutes.\ntype RelTimeMagnitude struct {\n\tD      time.Duration\n\tFormat string\n\tDivBy  time.Duration\n}\n\nvar defaultMagnitudes = []RelTimeMagnitude{\n\t{time.Second, \"now\", time.Second},\n\t{2 * time.Second, \"1 second %s\", 1},\n\t{time.Minute, \"%d seconds %s\", time.Second},\n\t{2 * time.Minute, \"1 minute %s\", 1},\n\t{time.Hour, \"%d minutes %s\", time.Minute},\n\t{2 * time.Hour, \"1 hour %s\", 1},\n\t{Day, \"%d hours %s\", time.Hour},\n\t{2 * Day, \"1 day %s\", 1},\n\t{Week, \"%d days %s\", Day},\n\t{2 * Week, \"1 week %s\", 1},\n\t{Month, \"%d weeks %s\", Week},\n\t{2 * Month, \"1 month %s\", 1},\n\t{Year, \"%d months %s\", Month},\n\t{18 * Month, \"1 year %s\", 1},\n\t{2 * Year, \"2 years %s\", 1},\n\t{LongTime, \"%d years %s\", Year},\n\t{math.MaxInt64, \"a long while %s\", 1},\n}\n\n// RelTime formats a time into a relative string.\n//\n// It takes two times and two labels.  In addition to the generic time\n// delta string (e.g. 5 minutes), the labels are used applied so that\n// the label corresponding to the smaller time is applied.\n//\n// RelTime(timeInPast, timeInFuture, \"earlier\", \"later\") -> \"3 weeks earlier\"\nfunc RelTime(a, b time.Time, albl, blbl string) string {\n\treturn CustomRelTime(a, b, albl, blbl, defaultMagnitudes)\n}\n\n// CustomRelTime formats a time into a relative string.\n//\n// It takes two times two labels and a table of relative time formats.\n// In addition to the generic time delta string (e.g. 5 minutes), the\n// labels are used applied so that the label corresponding to the\n// smaller time is applied.\nfunc CustomRelTime(a, b time.Time, albl, blbl string, magnitudes []RelTimeMagnitude) string {\n\tlbl := albl\n\tdiff := b.Sub(a)\n\n\tif a.After(b) {\n\t\tlbl = blbl\n\t\tdiff = a.Sub(b)\n\t}\n\n\tn := sort.Search(len(magnitudes), func(i int) bool {\n\t\treturn magnitudes[i].D > diff\n\t})\n\n\tif n >= len(magnitudes) {\n\t\tn = len(magnitudes) - 1\n\t}\n\tmag := magnitudes[n]\n\targs := []interface{}{}\n\tescaped := false\n\tfor _, ch := range mag.Format {\n\t\tif escaped {\n\t\t\tswitch ch {\n\t\t\tcase 's':\n\t\t\t\targs = append(args, lbl)\n\t\t\tcase 'd':\n\t\t\t\targs = append(args, diff/mag.DivBy)\n\t\t\t}\n\t\t\tescaped = false\n\t\t} else {\n\t\t\tescaped = ch == '%'\n\t\t}\n\t}\n\treturn fmt.Sprintf(mag.Format, args...)\n}\n"
        },
        {
          "name": "times_test.go",
          "type": "blob",
          "size": 6.1474609375,
          "content": "package humanize\n\nimport (\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestPast(t *testing.T) {\n\tnow := time.Now()\n\ttestList{\n\t\t{\"now\", Time(now), \"now\"},\n\t\t{\"1 second ago\", Time(now.Add(-1 * time.Second)), \"1 second ago\"},\n\t\t{\"12 seconds ago\", Time(now.Add(-12 * time.Second)), \"12 seconds ago\"},\n\t\t{\"30 seconds ago\", Time(now.Add(-30 * time.Second)), \"30 seconds ago\"},\n\t\t{\"45 seconds ago\", Time(now.Add(-45 * time.Second)), \"45 seconds ago\"},\n\t\t{\"1 minute ago\", Time(now.Add(-63 * time.Second)), \"1 minute ago\"},\n\t\t{\"15 minutes ago\", Time(now.Add(-15 * time.Minute)), \"15 minutes ago\"},\n\t\t{\"1 hour ago\", Time(now.Add(-63 * time.Minute)), \"1 hour ago\"},\n\t\t{\"2 hours ago\", Time(now.Add(-2 * time.Hour)), \"2 hours ago\"},\n\t\t{\"21 hours ago\", Time(now.Add(-21 * time.Hour)), \"21 hours ago\"},\n\t\t{\"1 day ago\", Time(now.Add(-26 * time.Hour)), \"1 day ago\"},\n\t\t{\"2 days ago\", Time(now.Add(-49 * time.Hour)), \"2 days ago\"},\n\t\t{\"3 days ago\", Time(now.Add(-3 * Day)), \"3 days ago\"},\n\t\t{\"1 week ago (1)\", Time(now.Add(-7 * Day)), \"1 week ago\"},\n\t\t{\"1 week ago (2)\", Time(now.Add(-12 * Day)), \"1 week ago\"},\n\t\t{\"2 weeks ago\", Time(now.Add(-15 * Day)), \"2 weeks ago\"},\n\t\t{\"1 month ago\", Time(now.Add(-39 * Day)), \"1 month ago\"},\n\t\t{\"3 months ago\", Time(now.Add(-99 * Day)), \"3 months ago\"},\n\t\t{\"1 year ago (1)\", Time(now.Add(-365 * Day)), \"1 year ago\"},\n\t\t{\"1 year ago (1)\", Time(now.Add(-400 * Day)), \"1 year ago\"},\n\t\t{\"2 years ago (1)\", Time(now.Add(-548 * Day)), \"2 years ago\"},\n\t\t{\"2 years ago (2)\", Time(now.Add(-725 * Day)), \"2 years ago\"},\n\t\t{\"2 years ago (3)\", Time(now.Add(-800 * Day)), \"2 years ago\"},\n\t\t{\"3 years ago\", Time(now.Add(-3 * Year)), \"3 years ago\"},\n\t\t{\"long ago\", Time(now.Add(-LongTime)), \"a long while ago\"},\n\t}.validate(t)\n}\n\nfunc TestReltimeOffbyone(t *testing.T) {\n\ttestList{\n\t\t{\"1w-1\", RelTime(time.Unix(0, 0), time.Unix(7*24*60*60, -1), \"ago\", \"\"), \"6 days ago\"},\n\t\t{\"1wÂ±0\", RelTime(time.Unix(0, 0), time.Unix(7*24*60*60, 0), \"ago\", \"\"), \"1 week ago\"},\n\t\t{\"1w+1\", RelTime(time.Unix(0, 0), time.Unix(7*24*60*60, 1), \"ago\", \"\"), \"1 week ago\"},\n\t\t{\"2w-1\", RelTime(time.Unix(0, 0), time.Unix(14*24*60*60, -1), \"ago\", \"\"), \"1 week ago\"},\n\t\t{\"2wÂ±0\", RelTime(time.Unix(0, 0), time.Unix(14*24*60*60, 0), \"ago\", \"\"), \"2 weeks ago\"},\n\t\t{\"2w+1\", RelTime(time.Unix(0, 0), time.Unix(14*24*60*60, 1), \"ago\", \"\"), \"2 weeks ago\"},\n\t}.validate(t)\n}\n\nfunc TestFuture(t *testing.T) {\n\t// Add a little time so that these things properly line up in\n\t// the future.\n\tnow := time.Now().Add(time.Millisecond * 250)\n\ttestList{\n\t\t{\"now\", Time(now), \"now\"},\n\t\t{\"1 second from now\", Time(now.Add(+1 * time.Second)), \"1 second from now\"},\n\t\t{\"12 seconds from now\", Time(now.Add(+12 * time.Second)), \"12 seconds from now\"},\n\t\t{\"30 seconds from now\", Time(now.Add(+30 * time.Second)), \"30 seconds from now\"},\n\t\t{\"45 seconds from now\", Time(now.Add(+45 * time.Second)), \"45 seconds from now\"},\n\t\t{\"15 minutes from now\", Time(now.Add(+15 * time.Minute)), \"15 minutes from now\"},\n\t\t{\"2 hours from now\", Time(now.Add(+2 * time.Hour)), \"2 hours from now\"},\n\t\t{\"21 hours from now\", Time(now.Add(+21 * time.Hour)), \"21 hours from now\"},\n\t\t{\"1 day from now\", Time(now.Add(+26 * time.Hour)), \"1 day from now\"},\n\t\t{\"2 days from now\", Time(now.Add(+49 * time.Hour)), \"2 days from now\"},\n\t\t{\"3 days from now\", Time(now.Add(+3 * Day)), \"3 days from now\"},\n\t\t{\"1 week from now (1)\", Time(now.Add(+7 * Day)), \"1 week from now\"},\n\t\t{\"1 week from now (2)\", Time(now.Add(+12 * Day)), \"1 week from now\"},\n\t\t{\"2 weeks from now\", Time(now.Add(+15 * Day)), \"2 weeks from now\"},\n\t\t{\"1 month from now\", Time(now.Add(+30 * Day)), \"1 month from now\"},\n\t\t{\"1 year from now\", Time(now.Add(+365 * Day)), \"1 year from now\"},\n\t\t{\"2 years from now\", Time(now.Add(+2 * Year)), \"2 years from now\"},\n\t\t{\"a while from now\", Time(now.Add(+LongTime)), \"a long while from now\"},\n\t}.validate(t)\n}\n\nfunc TestRange(t *testing.T) {\n\tstart := time.Time{}\n\tend := time.Unix(math.MaxInt64, math.MaxInt64)\n\tx := RelTime(start, end, \"ago\", \"from now\")\n\tif x != \"a long while from now\" {\n\t\tt.Errorf(\"Expected a long while from now, got %q\", x)\n\t}\n}\n\nfunc TestCustomRelTime(t *testing.T) {\n\tnow := time.Now().Add(time.Millisecond * 250)\n\tmagnitudes := []RelTimeMagnitude{\n\t\t{time.Second, \"now\", time.Second},\n\t\t{2 * time.Second, \"1 second %s\", 1},\n\t\t{time.Minute, \"%d seconds %s\", time.Second},\n\t\t{Day - time.Second, \"%d minutes %s\", time.Minute},\n\t\t{Day, \"%d hours %s\", time.Hour},\n\t\t{2 * Day, \"1 day %s\", 1},\n\t\t{Week, \"%d days %s\", Day},\n\t\t{2 * Week, \"1 week %s\", 1},\n\t\t{6 * Month, \"%d weeks %s\", Week},\n\t\t{Year, \"%d months %s\", Month},\n\t}\n\tcustomRelTime := func(then time.Time) string {\n\t\treturn CustomRelTime(then, time.Now(), \"ago\", \"from now\", magnitudes)\n\t}\n\ttestList{\n\t\t{\"now\", customRelTime(now), \"now\"},\n\t\t{\"1 second from now\", customRelTime(now.Add(+1 * time.Second)), \"1 second from now\"},\n\t\t{\"12 seconds from now\", customRelTime(now.Add(+12 * time.Second)), \"12 seconds from now\"},\n\t\t{\"30 seconds from now\", customRelTime(now.Add(+30 * time.Second)), \"30 seconds from now\"},\n\t\t{\"45 seconds from now\", customRelTime(now.Add(+45 * time.Second)), \"45 seconds from now\"},\n\t\t{\"15 minutes from now\", customRelTime(now.Add(+15 * time.Minute)), \"15 minutes from now\"},\n\t\t{\"2 hours from now\", customRelTime(now.Add(+2 * time.Hour)), \"120 minutes from now\"},\n\t\t{\"21 hours from now\", customRelTime(now.Add(+21 * time.Hour)), \"1260 minutes from now\"},\n\t\t{\"1 day from now\", customRelTime(now.Add(+26 * time.Hour)), \"1 day from now\"},\n\t\t{\"2 days from now\", customRelTime(now.Add(+49 * time.Hour)), \"2 days from now\"},\n\t\t{\"3 days from now\", customRelTime(now.Add(+3 * Day)), \"3 days from now\"},\n\t\t{\"1 week from now (1)\", customRelTime(now.Add(+7 * Day)), \"1 week from now\"},\n\t\t{\"1 week from now (2)\", customRelTime(now.Add(+12 * Day)), \"1 week from now\"},\n\t\t{\"2 weeks from now\", customRelTime(now.Add(+15 * Day)), \"2 weeks from now\"},\n\t\t{\"1 month from now\", customRelTime(now.Add(+30 * Day)), \"4 weeks from now\"},\n\t\t{\"6 months from now\", customRelTime(now.Add(+6*Month - time.Second)), \"25 weeks from now\"},\n\t\t{\"1 year from now\", customRelTime(now.Add(+365 * Day)), \"12 months from now\"},\n\t\t{\"2 years from now\", customRelTime(now.Add(+2 * Year)), \"24 months from now\"},\n\t\t{\"a while from now\", customRelTime(now.Add(+LongTime)), \"444 months from now\"},\n\t}.validate(t)\n}\n"
        }
      ]
    }
  ]
}