{
  "metadata": {
    "timestamp": 1736566935205,
    "page": 512,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "bwmarrin/snowflake",
      "stars": 3082,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.236328125,
          "content": "language: go\ngo:\n    - 1.11.x\n    - 1.12.x\ninstall:\n    - go get -v .\n    - go get -v golang.org/x/lint/golint\nscript:\n    - diff <(gofmt -d .) <(echo -n)\n    - go vet -x ./...\n    - golint -set_exit_status ./...\n    - go test -v -race ./...\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2578125,
          "content": "Copyright (c) 2016, Bruce\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.5458984375,
          "content": "snowflake\n====\n[![GoDoc](https://godoc.org/github.com/bwmarrin/snowflake?status.svg)](https://godoc.org/github.com/bwmarrin/snowflake) [![Go report](http://goreportcard.com/badge/bwmarrin/snowflake)](http://goreportcard.com/report/bwmarrin/snowflake) [![Coverage](http://gocover.io/_badge/github.com/bwmarrin/snowflake)](https://gocover.io/github.com/bwmarrin/snowflake) [![Build Status](https://travis-ci.org/bwmarrin/snowflake.svg?branch=master)](https://travis-ci.org/bwmarrin/snowflake) [![Discord Gophers](https://img.shields.io/badge/Discord%20Gophers-%23info-blue.svg)](https://discord.gg/0f1SbxBZjYq9jLBk)\n\nsnowflake is a [Go](https://golang.org/) package that provides\n* A very simple Twitter snowflake generator.\n* Methods to parse existing snowflake IDs.\n* Methods to convert a snowflake ID into several other data types and back.\n* JSON Marshal/Unmarshal functions to easily use snowflake IDs within a JSON API.\n* Monotonic Clock calculations protect from clock drift.\n\n**For help with this package or general Go discussion, please join the [Discord \nGophers](https://discord.gg/0f1SbxBZjYq9jLBk) chat server.**\n\n## Status\nThis package should be considered stable and completed.  Any additions in the \nfuture will strongly avoid API changes to existing functions. \n  \n### ID Format\nBy default, the ID format follows the original Twitter snowflake format.\n* The ID as a whole is a 63 bit integer stored in an int64\n* 41 bits are used to store a timestamp with millisecond precision, using a custom epoch.\n* 10 bits are used to store a node id - a range from 0 through 1023.\n* 12 bits are used to store a sequence number - a range from 0 through 4095.\n\n### Custom Format\nYou can alter the number of bits used for the node id and step number (sequence)\nby setting the snowflake.NodeBits and snowflake.StepBits values.  Remember that\nThere is a maximum of 22 bits available that can be shared between these two \nvalues. You do not have to use all 22 bits.\n\n### Custom Epoch\nBy default this package uses the Twitter Epoch of 1288834974657 or Nov 04 2010 01:42:54.\nYou can set your own epoch value by setting snowflake.Epoch to a time in milliseconds\nto use as the epoch.\n\n### Custom Notes\nWhen setting custom epoch or bit values you need to set them prior to calling\nany functions on the snowflake package, including NewNode().  Otherwise the\ncustom values you set will not be applied correctly.\n\n### How it Works.\nEach time you generate an ID, it works, like this.\n* A timestamp with millisecond precision is stored using 41 bits of the ID.\n* Then the NodeID is added in subsequent bits.\n* Then the Sequence Number is added, starting at 0 and incrementing for each ID generated in the same millisecond. If you generate enough IDs in the same millisecond that the sequence would roll over or overfill then the generate function will pause until the next millisecond.\n\nThe default Twitter format shown below.\n```\n+--------------------------------------------------------------------------+\n| 1 Bit Unused | 41 Bit Timestamp |  10 Bit NodeID  |   12 Bit Sequence ID |\n+--------------------------------------------------------------------------+\n```\n\nUsing the default settings, this allows for 4096 unique IDs to be generated every millisecond, per Node ID.\n## Getting Started\n\n### Installing\n\nThis assumes you already have a working Go environment, if not please see\n[this page](https://golang.org/doc/install) first.\n\n```sh\ngo get github.com/bwmarrin/snowflake\n```\n\n\n### Usage\n\nImport the package into your project then construct a new snowflake Node using a\nunique node number. The default settings permit a node number range from 0 to 1023.\nIf you have set a custom NodeBits value, you will need to calculate what your \nnode number range will be. With the node object call the Generate() method to \ngenerate and return a unique snowflake ID. \n\nKeep in mind that each node you create must have a unique node number, even \nacross multiple servers.  If you do not keep node numbers unique the generator \ncannot guarantee unique IDs across all nodes.\n\n\n**Example Program:**\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/bwmarrin/snowflake\"\n)\n\nfunc main() {\n\n\t// Create a new Node with a Node number of 1\n\tnode, err := snowflake.NewNode(1)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\n\t// Generate a snowflake ID.\n\tid := node.Generate()\n\n\t// Print out the ID in a few different ways.\n\tfmt.Printf(\"Int64  ID: %d\\n\", id)\n\tfmt.Printf(\"String ID: %s\\n\", id)\n\tfmt.Printf(\"Base2  ID: %s\\n\", id.Base2())\n\tfmt.Printf(\"Base64 ID: %s\\n\", id.Base64())\n\n\t// Print out the ID's timestamp\n\tfmt.Printf(\"ID Time  : %d\\n\", id.Time())\n\n\t// Print out the ID's node number\n\tfmt.Printf(\"ID Node  : %d\\n\", id.Node())\n\n\t// Print out the ID's sequence number\n\tfmt.Printf(\"ID Step  : %d\\n\", id.Step())\n\n  // Generate and print, all in one.\n  fmt.Printf(\"ID       : %d\\n\", node.Generate().Int64())\n}\n```\n\n### Performance\n\nWith default settings, this snowflake generator should be sufficiently fast \nenough on most systems to generate 4096 unique ID's per millisecond. This is \nthe maximum that the snowflake ID format supports. That is, around 243-244 \nnanoseconds per operation. \n\nSince the snowflake generator is single threaded the primary limitation will be\nthe maximum speed of a single processor on your system.\n\nTo benchmark the generator on your system run the following command inside the\nsnowflake package directory.\n\n```sh\ngo test -run=^$ -bench=.\n```\n\nIf your curious, check out this commit that shows benchmarks that compare a few \ndifferent ways of implementing a snowflake generator in Go.\n*  https://github.com/bwmarrin/snowflake/tree/9befef8908df13f4102ed21f42b083dd862b5036\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.044921875,
          "content": "module github.com/bwmarrin/snowflake\n\ngo 1.16\n"
        },
        {
          "name": "snowflake.go",
          "type": "blob",
          "size": 8.88671875,
          "content": "// Package snowflake provides a very simple Twitter snowflake generator and parser.\npackage snowflake\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar (\n\t// Epoch is set to the twitter snowflake epoch of Nov 04 2010 01:42:54 UTC in milliseconds\n\t// You may customize this to set a different epoch for your application.\n\tEpoch int64 = 1288834974657\n\n\t// NodeBits holds the number of bits to use for Node\n\t// Remember, you have a total 22 bits to share between Node/Step\n\tNodeBits uint8 = 10\n\n\t// StepBits holds the number of bits to use for Step\n\t// Remember, you have a total 22 bits to share between Node/Step\n\tStepBits uint8 = 12\n\n\t// DEPRECATED: the below four variables will be removed in a future release.\n\tmu        sync.Mutex\n\tnodeMax   int64 = -1 ^ (-1 << NodeBits)\n\tnodeMask        = nodeMax << StepBits\n\tstepMask  int64 = -1 ^ (-1 << StepBits)\n\ttimeShift       = NodeBits + StepBits\n\tnodeShift       = StepBits\n)\n\nconst encodeBase32Map = \"ybndrfg8ejkmcpqxot1uwisza345h769\"\n\nvar decodeBase32Map [256]byte\n\nconst encodeBase58Map = \"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ\"\n\nvar decodeBase58Map [256]byte\n\n// A JSONSyntaxError is returned from UnmarshalJSON if an invalid ID is provided.\ntype JSONSyntaxError struct{ original []byte }\n\nfunc (j JSONSyntaxError) Error() string {\n\treturn fmt.Sprintf(\"invalid snowflake ID %q\", string(j.original))\n}\n\n// ErrInvalidBase58 is returned by ParseBase58 when given an invalid []byte\nvar ErrInvalidBase58 = errors.New(\"invalid base58\")\n\n// ErrInvalidBase32 is returned by ParseBase32 when given an invalid []byte\nvar ErrInvalidBase32 = errors.New(\"invalid base32\")\n\n// Create maps for decoding Base58/Base32.\n// This speeds up the process tremendously.\nfunc init() {\n\n\tfor i := 0; i < len(decodeBase58Map); i++ {\n\t\tdecodeBase58Map[i] = 0xFF\n\t}\n\n\tfor i := 0; i < len(encodeBase58Map); i++ {\n\t\tdecodeBase58Map[encodeBase58Map[i]] = byte(i)\n\t}\n\n\tfor i := 0; i < len(decodeBase32Map); i++ {\n\t\tdecodeBase32Map[i] = 0xFF\n\t}\n\n\tfor i := 0; i < len(encodeBase32Map); i++ {\n\t\tdecodeBase32Map[encodeBase32Map[i]] = byte(i)\n\t}\n}\n\n// A Node struct holds the basic information needed for a snowflake generator\n// node\ntype Node struct {\n\tmu    sync.Mutex\n\tepoch time.Time\n\ttime  int64\n\tnode  int64\n\tstep  int64\n\n\tnodeMax   int64\n\tnodeMask  int64\n\tstepMask  int64\n\ttimeShift uint8\n\tnodeShift uint8\n}\n\n// An ID is a custom type used for a snowflake ID.  This is used so we can\n// attach methods onto the ID.\ntype ID int64\n\n// NewNode returns a new snowflake node that can be used to generate snowflake\n// IDs\nfunc NewNode(node int64) (*Node, error) {\n\n\tif NodeBits+StepBits > 22 {\n\t\treturn nil, errors.New(\"Remember, you have a total 22 bits to share between Node/Step\")\n\t}\n\t// re-calc in case custom NodeBits or StepBits were set\n\t// DEPRECATED: the below block will be removed in a future release.\n\tmu.Lock()\n\tnodeMax = -1 ^ (-1 << NodeBits)\n\tnodeMask = nodeMax << StepBits\n\tstepMask = -1 ^ (-1 << StepBits)\n\ttimeShift = NodeBits + StepBits\n\tnodeShift = StepBits\n\tmu.Unlock()\n\n\tn := Node{}\n\tn.node = node\n\tn.nodeMax = -1 ^ (-1 << NodeBits)\n\tn.nodeMask = n.nodeMax << StepBits\n\tn.stepMask = -1 ^ (-1 << StepBits)\n\tn.timeShift = NodeBits + StepBits\n\tn.nodeShift = StepBits\n\n\tif n.node < 0 || n.node > n.nodeMax {\n\t\treturn nil, errors.New(\"Node number must be between 0 and \" + strconv.FormatInt(n.nodeMax, 10))\n\t}\n\n\tvar curTime = time.Now()\n\t// add time.Duration to curTime to make sure we use the monotonic clock if available\n\tn.epoch = curTime.Add(time.Unix(Epoch/1000, (Epoch%1000)*1000000).Sub(curTime))\n\n\treturn &n, nil\n}\n\n// Generate creates and returns a unique snowflake ID\n// To help guarantee uniqueness\n// - Make sure your system is keeping accurate system time\n// - Make sure you never have multiple nodes running with the same node ID\nfunc (n *Node) Generate() ID {\n\n\tn.mu.Lock()\n\tdefer n.mu.Unlock()\n\n\tnow := time.Since(n.epoch).Milliseconds()\n\n\tif now == n.time {\n\t\tn.step = (n.step + 1) & n.stepMask\n\n\t\tif n.step == 0 {\n\t\t\tfor now <= n.time {\n\t\t\t\tnow = time.Since(n.epoch).Milliseconds()\n\t\t\t}\n\t\t}\n\t} else {\n\t\tn.step = 0\n\t}\n\n\tn.time = now\n\n\tr := ID((now)<<n.timeShift |\n\t\t(n.node << n.nodeShift) |\n\t\t(n.step),\n\t)\n\n\treturn r\n}\n\n// Int64 returns an int64 of the snowflake ID\nfunc (f ID) Int64() int64 {\n\treturn int64(f)\n}\n\n// ParseInt64 converts an int64 into a snowflake ID\nfunc ParseInt64(id int64) ID {\n\treturn ID(id)\n}\n\n// String returns a string of the snowflake ID\nfunc (f ID) String() string {\n\treturn strconv.FormatInt(int64(f), 10)\n}\n\n// ParseString converts a string into a snowflake ID\nfunc ParseString(id string) (ID, error) {\n\ti, err := strconv.ParseInt(id, 10, 64)\n\treturn ID(i), err\n\n}\n\n// Base2 returns a string base2 of the snowflake ID\nfunc (f ID) Base2() string {\n\treturn strconv.FormatInt(int64(f), 2)\n}\n\n// ParseBase2 converts a Base2 string into a snowflake ID\nfunc ParseBase2(id string) (ID, error) {\n\ti, err := strconv.ParseInt(id, 2, 64)\n\treturn ID(i), err\n}\n\n// Base32 uses the z-base-32 character set but encodes and decodes similar\n// to base58, allowing it to create an even smaller result string.\n// NOTE: There are many different base32 implementations so becareful when\n// doing any interoperation.\nfunc (f ID) Base32() string {\n\n\tif f < 32 {\n\t\treturn string(encodeBase32Map[f])\n\t}\n\n\tb := make([]byte, 0, 12)\n\tfor f >= 32 {\n\t\tb = append(b, encodeBase32Map[f%32])\n\t\tf /= 32\n\t}\n\tb = append(b, encodeBase32Map[f])\n\n\tfor x, y := 0, len(b)-1; x < y; x, y = x+1, y-1 {\n\t\tb[x], b[y] = b[y], b[x]\n\t}\n\n\treturn string(b)\n}\n\n// ParseBase32 parses a base32 []byte into a snowflake ID\n// NOTE: There are many different base32 implementations so becareful when\n// doing any interoperation.\nfunc ParseBase32(b []byte) (ID, error) {\n\n\tvar id int64\n\n\tfor i := range b {\n\t\tif decodeBase32Map[b[i]] == 0xFF {\n\t\t\treturn -1, ErrInvalidBase32\n\t\t}\n\t\tid = id*32 + int64(decodeBase32Map[b[i]])\n\t}\n\n\treturn ID(id), nil\n}\n\n// Base36 returns a base36 string of the snowflake ID\nfunc (f ID) Base36() string {\n\treturn strconv.FormatInt(int64(f), 36)\n}\n\n// ParseBase36 converts a Base36 string into a snowflake ID\nfunc ParseBase36(id string) (ID, error) {\n\ti, err := strconv.ParseInt(id, 36, 64)\n\treturn ID(i), err\n}\n\n// Base58 returns a base58 string of the snowflake ID\nfunc (f ID) Base58() string {\n\n\tif f < 58 {\n\t\treturn string(encodeBase58Map[f])\n\t}\n\n\tb := make([]byte, 0, 11)\n\tfor f >= 58 {\n\t\tb = append(b, encodeBase58Map[f%58])\n\t\tf /= 58\n\t}\n\tb = append(b, encodeBase58Map[f])\n\n\tfor x, y := 0, len(b)-1; x < y; x, y = x+1, y-1 {\n\t\tb[x], b[y] = b[y], b[x]\n\t}\n\n\treturn string(b)\n}\n\n// ParseBase58 parses a base58 []byte into a snowflake ID\nfunc ParseBase58(b []byte) (ID, error) {\n\n\tvar id int64\n\n\tfor i := range b {\n\t\tif decodeBase58Map[b[i]] == 0xFF {\n\t\t\treturn -1, ErrInvalidBase58\n\t\t}\n\t\tid = id*58 + int64(decodeBase58Map[b[i]])\n\t}\n\n\treturn ID(id), nil\n}\n\n// Base64 returns a base64 string of the snowflake ID\nfunc (f ID) Base64() string {\n\treturn base64.StdEncoding.EncodeToString(f.Bytes())\n}\n\n// ParseBase64 converts a base64 string into a snowflake ID\nfunc ParseBase64(id string) (ID, error) {\n\tb, err := base64.StdEncoding.DecodeString(id)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn ParseBytes(b)\n\n}\n\n// Bytes returns a byte slice of the snowflake ID\nfunc (f ID) Bytes() []byte {\n\treturn []byte(f.String())\n}\n\n// ParseBytes converts a byte slice into a snowflake ID\nfunc ParseBytes(id []byte) (ID, error) {\n\ti, err := strconv.ParseInt(string(id), 10, 64)\n\treturn ID(i), err\n}\n\n// IntBytes returns an array of bytes of the snowflake ID, encoded as a\n// big endian integer.\nfunc (f ID) IntBytes() [8]byte {\n\tvar b [8]byte\n\tbinary.BigEndian.PutUint64(b[:], uint64(f))\n\treturn b\n}\n\n// ParseIntBytes converts an array of bytes encoded as big endian integer as\n// a snowflake ID\nfunc ParseIntBytes(id [8]byte) ID {\n\treturn ID(int64(binary.BigEndian.Uint64(id[:])))\n}\n\n// Time returns an int64 unix timestamp in milliseconds of the snowflake ID time\n// DEPRECATED: the below function will be removed in a future release.\nfunc (f ID) Time() int64 {\n\treturn (int64(f) >> timeShift) + Epoch\n}\n\n// Node returns an int64 of the snowflake ID node number\n// DEPRECATED: the below function will be removed in a future release.\nfunc (f ID) Node() int64 {\n\treturn int64(f) & nodeMask >> nodeShift\n}\n\n// Step returns an int64 of the snowflake step (or sequence) number\n// DEPRECATED: the below function will be removed in a future release.\nfunc (f ID) Step() int64 {\n\treturn int64(f) & stepMask\n}\n\n// MarshalJSON returns a json byte array string of the snowflake ID.\nfunc (f ID) MarshalJSON() ([]byte, error) {\n\tbuff := make([]byte, 0, 22)\n\tbuff = append(buff, '\"')\n\tbuff = strconv.AppendInt(buff, int64(f), 10)\n\tbuff = append(buff, '\"')\n\treturn buff, nil\n}\n\n// UnmarshalJSON converts a json byte array of a snowflake ID into an ID type.\nfunc (f *ID) UnmarshalJSON(b []byte) error {\n\tif len(b) < 3 || b[0] != '\"' || b[len(b)-1] != '\"' {\n\t\treturn JSONSyntaxError{b}\n\t}\n\n\ti, err := strconv.ParseInt(string(b[1:len(b)-1]), 10, 64)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t*f = ID(i)\n\treturn nil\n}\n"
        },
        {
          "name": "snowflake_test.go",
          "type": "blob",
          "size": 10.7470703125,
          "content": "package snowflake\n\nimport (\n\t\"bytes\"\n\t\"reflect\"\n\t\"testing\"\n)\n\n//******************************************************************************\n// General Test funcs\n\nfunc TestNewNode(t *testing.T) {\n\n\t_, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\t_, err = NewNode(5000)\n\tif err == nil {\n\t\tt.Fatalf(\"no error creating NewNode, %s\", err)\n\t}\n\n}\n\n// lazy check if Generate will create duplicate IDs\n// would be good to later enhance this with more smarts\nfunc TestGenerateDuplicateID(t *testing.T) {\n\n\tnode, _ := NewNode(1)\n\n\tvar x, y ID\n\tfor i := 0; i < 1000000; i++ {\n\t\ty = node.Generate()\n\t\tif x == y {\n\t\t\tt.Errorf(\"x(%d) & y(%d) are the same\", x, y)\n\t\t}\n\t\tx = y\n\t}\n}\n\n// I feel like there's probably a better way\nfunc TestRace(t *testing.T) {\n\n\tnode, _ := NewNode(1)\n\n\tgo func() {\n\t\tfor i := 0; i < 1000000000; i++ {\n\n\t\t\tNewNode(1)\n\t\t}\n\t}()\n\n\tfor i := 0; i < 4000; i++ {\n\n\t\tnode.Generate()\n\t}\n\n}\n\n//******************************************************************************\n// Converters/Parsers Test funcs\n// We should have funcs here to test conversion both ways for everything\n\nfunc TestPrintAll(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\tid := node.Generate()\n\n\tt.Logf(\"Int64    : %#v\", id.Int64())\n\tt.Logf(\"String   : %#v\", id.String())\n\tt.Logf(\"Base2    : %#v\", id.Base2())\n\tt.Logf(\"Base32   : %#v\", id.Base32())\n\tt.Logf(\"Base36   : %#v\", id.Base36())\n\tt.Logf(\"Base58   : %#v\", id.Base58())\n\tt.Logf(\"Base64   : %#v\", id.Base64())\n\tt.Logf(\"Bytes    : %#v\", id.Bytes())\n\tt.Logf(\"IntBytes : %#v\", id.IntBytes())\n\n}\n\nfunc TestInt64(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\ti := oID.Int64()\n\n\tpID := ParseInt64(i)\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tmi := int64(1116766490855473152)\n\tpID = ParseInt64(mi)\n\tif pID.Int64() != mi {\n\t\tt.Fatalf(\"pID %v != mi %v\", pID.Int64(), mi)\n\t}\n\n}\n\nfunc TestString(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\tsi := oID.String()\n\n\tpID, err := ParseString(si)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tms := `1116766490855473152`\n\t_, err = ParseString(ms)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\n\tms = `1112316766490855473152`\n\t_, err = ParseString(ms)\n\tif err == nil {\n\t\tt.Fatalf(\"no error parsing %s\", ms)\n\t}\n}\n\nfunc TestBase2(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\ti := oID.Base2()\n\n\tpID, err := ParseBase2(i)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tms := `111101111111101110110101100101001000000000000000000000000000`\n\t_, err = ParseBase2(ms)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\n\tms = `1112316766490855473152`\n\t_, err = ParseBase2(ms)\n\tif err == nil {\n\t\tt.Fatalf(\"no error parsing %s\", ms)\n\t}\n}\n\nfunc TestBase32(t *testing.T) {\n\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\n\t\tsf := node.Generate()\n\t\tb32i := sf.Base32()\n\t\tpsf, err := ParseBase32([]byte(b32i))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif sf != psf {\n\t\t\tt.Fatal(\"Parsed does not match String.\")\n\t\t}\n\t}\n}\n\nfunc TestBase36(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\ti := oID.Base36()\n\n\tpID, err := ParseBase36(i)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tms := `8hgmw4blvlkw`\n\t_, err = ParseBase36(ms)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\n\tms = `68h5gmw443blv2lk1w`\n\t_, err = ParseBase36(ms)\n\tif err == nil {\n\t\tt.Fatalf(\"no error parsing, %s\", err)\n\t}\n}\n\nfunc TestBase58(t *testing.T) {\n\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\n\t\tsf := node.Generate()\n\t\tb58 := sf.Base58()\n\t\tpsf, err := ParseBase58([]byte(b58))\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif sf != psf {\n\t\t\tt.Fatal(\"Parsed does not match String.\")\n\t\t}\n\t}\n}\n\nfunc TestBase64(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\ti := oID.Base64()\n\n\tpID, err := ParseBase64(i)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tms := `MTExNjgxOTQ5NDY2MDk5NzEyMA==`\n\t_, err = ParseBase64(ms)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\n\tms = `MTExNjgxOTQ5NDY2MDk5NzEyMA`\n\t_, err = ParseBase64(ms)\n\tif err == nil {\n\t\tt.Fatalf(\"no error parsing, %s\", err)\n\t}\n}\n\nfunc TestBytes(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\ti := oID.Bytes()\n\n\tpID, err := ParseBytes(i)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %s\", err)\n\t}\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tms := []byte{0x31, 0x31, 0x31, 0x36, 0x38, 0x32, 0x31, 0x36, 0x37, 0x39, 0x35, 0x37, 0x30, 0x34, 0x31, 0x39, 0x37, 0x31, 0x32}\n\t_, err = ParseBytes(ms)\n\tif err != nil {\n\t\tt.Fatalf(\"error parsing, %#v\", err)\n\t}\n\n\tms = []byte{0xFF, 0xFF, 0xFF, 0x31, 0x31, 0x31, 0x36, 0x38, 0x32, 0x31, 0x36, 0x37, 0x39, 0x35, 0x37, 0x30, 0x34, 0x31, 0x39, 0x37, 0x31, 0x32}\n\t_, err = ParseBytes(ms)\n\tif err == nil {\n\t\tt.Fatalf(\"no error parsing, %#v\", err)\n\t}\n}\n\nfunc TestIntBytes(t *testing.T) {\n\tnode, err := NewNode(0)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating NewNode, %s\", err)\n\t}\n\n\toID := node.Generate()\n\ti := oID.IntBytes()\n\n\tpID := ParseIntBytes(i)\n\tif pID != oID {\n\t\tt.Fatalf(\"pID %v != oID %v\", pID, oID)\n\t}\n\n\tms := [8]uint8{0xf, 0x7f, 0xc0, 0xfc, 0x2f, 0x80, 0x0, 0x0}\n\tmi := int64(1116823421972381696)\n\tpID = ParseIntBytes(ms)\n\tif pID.Int64() != mi {\n\t\tt.Fatalf(\"pID %v != mi %v\", pID.Int64(), mi)\n\t}\n\n}\n\n//******************************************************************************\n// Marshall Test Methods\n\nfunc TestMarshalJSON(t *testing.T) {\n\tid := ID(13587)\n\texpected := \"\\\"13587\\\"\"\n\n\tbytes, err := id.MarshalJSON()\n\tif err != nil {\n\t\tt.Fatalf(\"Unexpected error during MarshalJSON\")\n\t}\n\n\tif string(bytes) != expected {\n\t\tt.Fatalf(\"Got %s, expected %s\", string(bytes), expected)\n\t}\n}\n\nfunc TestMarshalsIntBytes(t *testing.T) {\n\tid := ID(13587).IntBytes()\n\texpected := []byte{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x35, 0x13}\n\tif !bytes.Equal(id[:], expected) {\n\t\tt.Fatalf(\"Expected ID to be encoded as %v, got %v\", expected, id)\n\t}\n}\n\nfunc TestUnmarshalJSON(t *testing.T) {\n\ttt := []struct {\n\t\tjson        string\n\t\texpectedID  ID\n\t\texpectedErr error\n\t}{\n\t\t{`\"13587\"`, 13587, nil},\n\t\t{`1`, 0, JSONSyntaxError{[]byte(`1`)}},\n\t\t{`\"invalid`, 0, JSONSyntaxError{[]byte(`\"invalid`)}},\n\t}\n\n\tfor _, tc := range tt {\n\t\tvar id ID\n\t\terr := id.UnmarshalJSON([]byte(tc.json))\n\t\tif !reflect.DeepEqual(err, tc.expectedErr) {\n\t\t\tt.Fatalf(\"Expected to get error '%s' decoding JSON, but got '%s'\", tc.expectedErr, err)\n\t\t}\n\n\t\tif id != tc.expectedID {\n\t\t\tt.Fatalf(\"Expected to get ID '%s' decoding JSON, but got '%s'\", tc.expectedID, id)\n\t\t}\n\t}\n}\n\n// ****************************************************************************\n// Benchmark Methods\n\nfunc BenchmarkParseBase32(b *testing.B) {\n\n\tnode, _ := NewNode(1)\n\tsf := node.Generate()\n\tb32i := sf.Base32()\n\n\tb.ReportAllocs()\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tParseBase32([]byte(b32i))\n\t}\n}\nfunc BenchmarkBase32(b *testing.B) {\n\n\tnode, _ := NewNode(1)\n\tsf := node.Generate()\n\n\tb.ReportAllocs()\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tsf.Base32()\n\t}\n}\nfunc BenchmarkParseBase58(b *testing.B) {\n\n\tnode, _ := NewNode(1)\n\tsf := node.Generate()\n\tb58 := sf.Base58()\n\n\tb.ReportAllocs()\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tParseBase58([]byte(b58))\n\t}\n}\nfunc BenchmarkBase58(b *testing.B) {\n\n\tnode, _ := NewNode(1)\n\tsf := node.Generate()\n\n\tb.ReportAllocs()\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tsf.Base58()\n\t}\n}\nfunc BenchmarkGenerate(b *testing.B) {\n\n\tnode, _ := NewNode(1)\n\n\tb.ReportAllocs()\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = node.Generate()\n\t}\n}\n\nfunc BenchmarkGenerateMaxSequence(b *testing.B) {\n\n\tNodeBits = 1\n\tStepBits = 21\n\tnode, _ := NewNode(1)\n\n\tb.ReportAllocs()\n\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = node.Generate()\n\t}\n}\n\nfunc BenchmarkUnmarshal(b *testing.B) {\n\t// Generate the ID to unmarshal\n\tnode, _ := NewNode(1)\n\tid := node.Generate()\n\tbytes, _ := id.MarshalJSON()\n\n\tvar id2 ID\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_ = id2.UnmarshalJSON(bytes)\n\t}\n}\n\nfunc BenchmarkMarshal(b *testing.B) {\n\t// Generate the ID to marshal\n\tnode, _ := NewNode(1)\n\tid := node.Generate()\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\t_, _ = id.MarshalJSON()\n\t}\n}\n\nfunc TestParseBase32(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\targ     string\n\t\twant    ID\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"ok\",\n\t\t\targ:     \"b8wjm1zroyyyy\",\n\t\t\twant:    1427970479175499776,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"capital case is invalid encoding\",\n\t\t\targ:     \"B8WJM1ZROYYYY\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"l is not allowed\",\n\t\t\targ:     \"b8wjm1zroyyyl\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"v is not allowed\",\n\t\t\targ:     \"b8wjm1zroyyyv\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"2 is not allowed\",\n\t\t\targ:     \"b8wjm1zroyyy2\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := ParseBase32([]byte(tt.arg))\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"ParseBase32() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"ParseBase32() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseBase58(t *testing.T) {\n\ttests := []struct {\n\t\tname    string\n\t\targ     string\n\t\twant    ID\n\t\twantErr bool\n\t}{\n\t\t{\n\t\t\tname:    \"ok\",\n\t\t\targ:     \"4jgmnx8Js8A\",\n\t\t\twant:    1428076403798048768,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:    \"0 not allowed\",\n\t\t\targ:     \"0jgmnx8Js8A\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"I not allowed\",\n\t\t\targ:     \"Ijgmnx8Js8A\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"O not allowed\",\n\t\t\targ:     \"Ojgmnx8Js8A\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t\t{\n\t\t\tname:    \"l not allowed\",\n\t\t\targ:     \"ljgmnx8Js8A\",\n\t\t\twant:    -1,\n\t\t\twantErr: true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgot, err := ParseBase58([]byte(tt.arg))\n\t\t\tif (err != nil) != tt.wantErr {\n\t\t\t\tt.Errorf(\"ParseBase58() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"ParseBase58() got = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}