{
  "metadata": {
    "timestamp": 1736566801832,
    "page": 364,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "alecthomas/gometalinter",
      "stars": 3507,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0380859375,
          "content": "gometalinter\n_linters/bin\n_linters/pkg\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 4.048828125,
          "content": "---\nproject_name: gometalinter\n\nrelease:\n  github:\n    owner: alecthomas\n    name: gometalinter\n\nbrew:\n  name: gometalinter\n  github:\n    owner: alecthomas\n    name: homebrew-tap\n\n  commit_author:\n    name: goreleaserbot\n    email: goreleaser@carlosbecker.com\n\n  folder: Formula\n  homepage: \"https://github.com/alecthomas/gometalinter\"\n  description: \"Concurrently run Go lint tools and normalise their output.\"\n\nbuilds:\n  - binary: gometalinter\n    goos: &goos\n      - darwin\n      - windows\n      - linux\n      - freebsd\n      - openbsd\n      - netbsd\n    goarch: &goarch\n      - amd64\n      - i386\n      - arm64\n      - ppc64le\n    env:\n      - CGO_ENABLED=0\n    main: ./\n    ldflags: -s -w -X main.version={{.Version}} -X main.commit={{.Commit}} -X main.date={{.Date}}\n\n  - binary: gocyclo\n    goos: *goos\n    goarch: *goarch\n    env: &env\n      - CGO_ENABLED=0\n      - GOPATH=$PWD/_linters\n    main: ./_linters/src/github.com/alecthomas/gocyclo\n\n  - binary: nakedret\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/alexkohler/nakedret\n\n  - binary: misspell\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/client9/misspell/cmd/misspell\n\n  - binary: gosec\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/securego/gosec/cmd/gosec\n\n  - binary: golint\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/golang/lint/golint\n\n  - binary: ineffassign\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/gordonklaus/ineffassign\n\n  - binary: goconst\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/jgautheron/goconst/cmd/goconst\n\n  - binary: errcheck\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/kisielk/errcheck\n\n  - binary: maligned\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/mdempsky/maligned\n\n  - binary: unconvert\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/mdempsky/unconvert\n\n  - binary: dupl\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/mibk/dupl\n\n  - binary: structcheck\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/opennota/check/cmd/structcheck\n\n  - binary: varcheck\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/opennota/check/cmd/varcheck\n\n  - binary: safesql\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/stripe/safesql\n\n  - binary: deadcode\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/tsenart/deadcode\n\n  - binary: lll\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/github.com/walle/lll/cmd/lll\n\n  - binary: goimports\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/golang.org/x/tools/cmd/goimports\n\n  - binary: gotype\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/golang.org/x/tools/cmd/gotype\n\n  - binary: staticcheck\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/honnef.co/go/tools/cmd/staticcheck\n\n  - binary: interfacer\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/mvdan.cc/interfacer\n\n  - binary: unparam\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/mvdan.cc/unparam\n\n  - binary: gochecknoinits\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/4d63.com/gochecknoinits\n\n  - binary: gochecknoglobals\n    goos: *goos\n    goarch: *goarch\n    env: *env\n    main: ./_linters/src/4d63.com/gochecknoglobals\n\narchive:\n  format: tar.gz\n  wrap_in_directory: true\n  format_overrides:\n    - goos: windows\n      format: zip\n  name_template: '{{ .Binary }}-{{ .Version }}-{{ .Os }}-{{ .Arch }}{{ if .Arm }}v{{ .Arm }}{{ end }}'\n  files:\n    - COPYING\n    - README.md\n\nsnapshot:\n  name_template: SNAPSHOT-{{ .Commit }}\n\nchecksum:\n  name_template: '{{ .ProjectName }}-{{ .Version }}-checksums.txt'\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.6748046875,
          "content": "sudo: false\nlanguage: go\ninstall:\n- go get -t -v . ./regressiontests\n- gometalinter --install\ngo:\n- 1.9.x\n- 1.10.x\n- 1.11.x\nscript: go test -v . ./regressiontests\nbefore_deploy:\n  - curl -sL https://git.io/goreleaser | bash\ndeploy:\n  provider: releases\n  api_key:\n    secure: AFHdOq5gTUFodz06wFMwSxM/mjF9BtwiUxHq5eODTymARPp+DBkTLFcZgf77VE8wFEGuM9/5eedsuCna3FmQwY3ClGoINaAa8ouZHyYkqMhEZyhnTu9848zqJQxy46VKpwcXw1se/qyN6tNNIgJizrAbwfSgbdktCFxWZU2xB00\n  file_glob: true\n  file:\n    - dist/gometalinter-*.zip\n    - dist/gometalinter-*.tar.bz2\n    - dist/gometalinter-*.sha256\n  skip_cleanup: true\n  on:\n    tags: true\n    repo: alecthomas/gometalinter\n    condition: $TRAVIS_GO_VERSION =~ ^1\\.11\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 1.7314453125,
          "content": "### Please only report errors with gometalinter itself\n\ngometalinter relies on underlying linters to detect issues in source code.\nIf your issue seems to be related to an underlying linter, please report an\nissue against that linter rather than gometalinter. For a full list of linters\nand their repositories please see the [README](README.md).\n\n### Do you want to upgrade a vendored linter?\n\nPlease send a PR. We use [GVT](https://github.com/FiloSottile/gvt). It should be as simple as:\n\n```\ngo get github.com/FiloSottile/gvt\ncd _linters\ngvt update <linter>\ngit add <paths>\n```\n\n### Before you report an issue\n\nSometimes gometalinter will not report issues that you think it should. There\nare three things to try in that case:\n\n#### 1. Update to the latest build of gometalinter and all linters\n\n    go get -u github.com/alecthomas/gometalinter\n    gometalinter --install\n\nIf you're lucky, this will fix the problem.\n\n#### 2. Analyse the debug output\n\nIf that doesn't help, the problem may be elsewhere (in no particular order):\n\n1. Upstream linter has changed its output or semantics.\n2. gometalinter is not invoking the tool correctly.\n3. gometalinter regular expression matches are not correct for a linter.\n4. Linter is exceeding the deadline.\n\nTo find out what's going on run in debug mode:\n\n    gometalinter --debug\n\nThis will show all output from the linters and should indicate why it is\nfailing.\n\n#### 3. Run linters manually\n\nThe output of `gometalinter --debug` should show the exact commands gometalinter\nis running. Run these commands from the command line to determine if the linter\nor gometaliner is at fault.\n\n#### 4. Report an issue.\n\nFailing all else, if the problem looks like a bug please file an issue and\ninclude the output of `gometalinter --debug`\n"
        },
        {
          "name": "COPYING",
          "type": "blob",
          "size": 1.0302734375,
          "content": "Copyright (C) 2012 Alec Thomas\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.80859375,
          "content": "# Go Meta Linter\n\n----\n\ngometalinter is **DEPRECATED** and the project will be archived on 2019-04-07. See [#590](https://github.com/alecthomas/gometalinter/issues/590) for discussion.\n\nSwitch to [golangci-lint](https://github.com/golangci/golangci-lint).\n\n----\n\n\n[![Build Status](https://travis-ci.org/alecthomas/gometalinter.svg)](https://travis-ci.org/alecthomas/gometalinter) [![Gitter chat](https://badges.gitter.im/alecthomas.svg)](https://gitter.im/alecthomas/Lobby)\n\n<!-- MarkdownTOC -->\n\n- [Installing](#installing)\n    - [Binary Releases](#binary-releases)\n    - [Homebrew](#homebrew)\n- [Editor integration](#editor-integration)\n- [Supported linters](#supported-linters)\n- [Configuration file](#configuration-file)\n    - [`Format` key](#format-key)\n    - [Format Methods](#format-methods)\n  - [Adding Custom linters](#adding-custom-linters)\n- [Comment directives](#comment-directives)\n- [Quickstart](#quickstart)\n- [FAQ](#faq)\n  - [Exit status](#exit-status)\n  - [What's the best way to use `gometalinter` in CI?](#whats-the-best-way-to-use-gometalinter-in-ci)\n  - [How do I make `gometalinter` work with Go 1.5 vendoring?](#how-do-i-make-gometalinter-work-with-go-15-vendoring)\n  - [Why does `gometalinter --install` install a fork of gocyclo?](#why-does-gometalinter---install-install-a-fork-of-gocyclo)\n  - [Many unexpected errors are being reported](#many-unexpected-errors-are-being-reported)\n  - [Gometalinter is not working](#gometalinter-is-not-working)\n    - [1. Update to the latest build of gometalinter and all linters](#1-update-to-the-latest-build-of-gometalinter-and-all-linters)\n    - [2. Analyse the debug output](#2-analyse-the-debug-output)\n    - [3. Report an issue.](#3-report-an-issue)\n  - [How do I filter issues between two git refs?](#how-do-i-filter-issues-between-two-git-refs)\n- [Checkstyle XML format](#checkstyle-xml-format)\n\n<!-- /MarkdownTOC -->\n\n\nThe number of tools for statically checking Go source for errors and warnings\nis impressive.\n\nThis is a tool that concurrently runs a whole bunch of those linters and\nnormalises their output to a standard format:\n\n    <file>:<line>:[<column>]: <message> (<linter>)\n\neg.\n\n    stutter.go:9::warning: unused global variable unusedGlobal (varcheck)\n    stutter.go:12:6:warning: exported type MyStruct should have comment or be unexported (golint)\n\nIt is intended for use with editor/IDE integration.\n\n## Installing\n\n### Binary Releases\n\nTo install the latest stable release:\n\n    curl -L https://git.io/vp6lP | sh\n\nAlternatively you can install a specific version from the [releases](https://github.com/alecthomas/gometalinter/releases) list.\n\n### Homebrew\n\n```sh\nbrew tap alecthomas/homebrew-tap\nbrew install gometalinter\n```\n\n## Editor integration\n\n- [SublimeLinter plugin](https://github.com/alecthomas/SublimeLinter-contrib-gometalinter).\n- [Atom go-plus package](https://atom.io/packages/go-plus).\n- [Emacs Flycheck checker](https://github.com/favadi/flycheck-gometalinter).\n- [Go for Visual Studio Code](https://marketplace.visualstudio.com/items?itemName=lukehoban.Go).\n- [GoLand File Watcher](https://blog.jetbrains.com/go/2017/10/18/gogland-eap-16-file-watcher-tons-of-new-inspections-smarter-navigate-to-test-and-more/).\n- Vim/Neovim\n    - [Neomake](https://github.com/neomake/neomake).\n    - [Syntastic](https://github.com/scrooloose/syntastic/wiki/Go:---gometalinter) `let g:syntastic_go_checkers = ['gometalinter']`.\n    - [ale](https://github.com/w0rp/ale) `let g:ale_linters = {'go': ['gometalinter']}`\n    - [vim-go](https://github.com/fatih/vim-go) with the `:GoMetaLinter` command.\n\n## Supported linters\n\n- [go vet](https://golang.org/cmd/vet/) - Reports potential errors that otherwise compile.\n- [go tool vet --shadow](https://golang.org/cmd/vet/#hdr-Shadowed_variables) - Reports variables that may have been unintentionally shadowed.\n- [gotype](https://golang.org/x/tools/cmd/gotype) - Syntactic and semantic analysis similar to the Go compiler.\n- [gotype -x](https://golang.org/x/tools/cmd/gotype) - Syntactic and semantic analysis in external test packages (similar to the Go compiler).\n- [deadcode](https://github.com/tsenart/deadcode) - Finds unused code.\n- [gocyclo](https://github.com/alecthomas/gocyclo) - Computes the cyclomatic complexity of functions.\n- [golint](https://github.com/golang/lint) - Google's (mostly stylistic) linter.\n- [varcheck](https://github.com/opennota/check) - Find unused global variables and constants.\n- [structcheck](https://github.com/opennota/check) - Find unused struct fields.\n- [maligned](https://github.com/mdempsky/maligned) -  Detect structs that would take less memory if their fields were sorted.\n- [errcheck](https://github.com/kisielk/errcheck) - Check that error return values are used.\n- [staticcheck](https://github.com/dominikh/go-tools/tree/master/cmd/staticcheck) - Statically detect bugs, both obvious and subtle ones.\n- [dupl](https://github.com/mibk/dupl) - Reports potentially duplicated code.\n- [ineffassign](https://github.com/gordonklaus/ineffassign) - Detect when assignments to *existing* variables are not used.\n- [interfacer](https://github.com/mvdan/interfacer) - Suggest narrower interfaces that can be used.\n- [unconvert](https://github.com/mdempsky/unconvert) - Detect redundant type conversions.\n- [goconst](https://github.com/jgautheron/goconst) - Finds repeated strings that could be replaced by a constant.\n- [gosec](https://github.com/securego/gosec) - Inspects source code for security problems by scanning the Go AST.\n\nDisabled by default (enable with `--enable=<linter>`):\n\n- [testify](https://github.com/stretchr/testify) - Show location of failed testify assertions.\n- [test](http://golang.org/pkg/testing/) - Show location of test failures from the stdlib testing module.\n- [gofmt -s](https://golang.org/cmd/gofmt/) - Checks if the code is properly formatted and could not be further simplified.\n- [goimports](https://godoc.org/golang.org/x/tools/cmd/goimports) - Checks missing or unreferenced package imports.\n- [gochecknoinits](https://4d63.com/gochecknoinits) - Report init functions, to reduce side effects in code.\n- [gochecknoglobals](https://4d63.com/gochecknoglobals) - Report global vars, to reduce side effects in code.\n- [lll](https://github.com/walle/lll) - Report long lines (see `--line-length=N`).\n- [misspell](https://github.com/client9/misspell) - Finds commonly misspelled English words.\n- [nakedret](https://github.com/alexkohler/nakedret) - Finds naked returns.\n- [unparam](https://github.com/mvdan/unparam) - Find unused function parameters.\n- [safesql](https://github.com/stripe/safesql) - Finds potential SQL injection vulnerabilities.\n\nAdditional linters can be added through the command line with `--linter=NAME:COMMAND:PATTERN` (see [below](#details)).\n\n## Configuration file\n\ngometalinter now supports a JSON configuration file called `.gometalinter.json` that can\nbe placed at the root of your project. The configuration file will be automatically loaded\nfrom the working directory or any parent directory and can be overridden by passing\n`--config=<file>` or ignored with `--no-config`. The format of this file is determined by\nthe `Config` struct in [config.go](https://github.com/alecthomas/gometalinter/blob/master/config.go).\n\nThe configuration file mostly corresponds to command-line flags, with the following exceptions:\n\n- Linters defined in the configuration file will overlay existing definitions, not replace them.\n- \"Enable\" defines the exact set of linters that will be enabled (default\n  linters are disabled). `--help` displays the list of default linters with the exact names\n  you must use.\n\nHere is an example configuration file:\n\n```json\n{\n  \"Enable\": [\"deadcode\", \"unconvert\"]\n}\n```\n\nIf a `.gometalinter.json` file is loaded, individual options can still be overridden by\npassing command-line flags. All flags are parsed in order, meaning configuration passed\nwith the `--config` flag will override any command-line flags passed before and be\noverridden by flags passed after.\n\n\n#### `Format` key\n\nThe default `Format` key places the different fields of an `Issue` into a template. this\ncorresponds to the `--format` option command-line flag.\n\nDefault `Format`:\n```\nFormat: \"{{.Path}}:{{.Line}}:{{if .Col}}{{.Col}}{{end}}:{{.Severity}}: {{.Message}} ({{.Linter}})\"\n```\n\n#### Format Methods\n\n* `{{.Path.Relative}}` - equivalent to `{{.Path}}` which outputs a relative path to the file\n* `{{.Path.Abs}}` - outputs an absolute path to the file\n\n### Adding Custom linters\n\nLinters can be added and customized from the config file using the `Linters` field.\nLinters supports the following fields:\n\n* `Command` - the path to the linter binary and any default arguments\n* `Pattern` - a regular expression used to parse the linter output\n* `IsFast` - if the linter should be run when the `--fast` flag is used\n* `PartitionStrategy` - how paths args should be passed to the linter command:\n  * `directories` - call the linter once with a list of all the directories\n  * `files` - call the linter once with a list of all the files\n  * `packages` - call the linter once with a list of all the package paths\n  * `files-by-package` - call the linter once per package with a list of the\n    files in the package.\n  * `single-directory` - call the linter once per directory\n\nThe config for default linters can be overridden by using the name of the\nlinter.\n\nAdditional linters can be configured via the command line using the format\n`NAME:COMMAND:PATTERN`.\n\nExample:\n\n```\n$ gometalinter --linter='vet:go tool vet -printfuncs=Infof,Debugf,Warningf,Errorf:PATH:LINE:MESSAGE' .\n```\n\n## Comment directives\n\ngometalinter supports suppression of linter messages via comment directives. The\nform of the directive is:\n\n```\n// nolint[: <linter>[, <linter>, ...]]\n```\n\nSuppression works in the following way:\n\n1. Line-level suppression\n\n    A comment directive suppresses any linter messages on that line.\n\n    eg. In this example any messages for `a := 10` will be suppressed and errcheck\n    messages for `defer r.Close()` will also be suppressed.\n\n    ```go\n    a := 10 // nolint\n    a = 2\n    defer r.Close() // nolint: errcheck\n    ```\n\n2. Statement-level suppression\n\n    A comment directive at the same indentation level as a statement it\n    immediately precedes will also suppress any linter messages in that entire\n    statement.\n\n    eg. In this example all messages for `SomeFunc()` will be suppressed.\n\n    ```go\n    // nolint\n    func SomeFunc() {\n    }\n    ```\n\nImplementation details: gometalinter now performs parsing of Go source code,\nto extract linter directives and associate them with line ranges. To avoid\nunnecessary processing, parsing is on-demand: the first time a linter emits a\nmessage for a file, that file is parsed for directives.\n\n## Quickstart\n\nInstall gometalinter (see above).\n\nRun it:\n\n```\n$ cd example\n$ gometalinter ./...\nstutter.go:13::warning: unused struct field MyStruct.Unused (structcheck)\nstutter.go:9::warning: unused global variable unusedGlobal (varcheck)\nstutter.go:12:6:warning: exported type MyStruct should have comment or be unexported (golint)\nstutter.go:16:6:warning: exported type PublicUndocumented should have comment or be unexported (golint)\nstutter.go:8:1:warning: unusedGlobal is unused (deadcode)\nstutter.go:12:1:warning: MyStruct is unused (deadcode)\nstutter.go:16:1:warning: PublicUndocumented is unused (deadcode)\nstutter.go:20:1:warning: duplicateDefer is unused (deadcode)\nstutter.go:21:15:warning: error return value not checked (defer a.Close()) (errcheck)\nstutter.go:22:15:warning: error return value not checked (defer a.Close()) (errcheck)\nstutter.go:27:6:warning: error return value not checked (doit()           // test for errcheck) (errcheck)\nstutter.go:29::error: unreachable code (vet)\nstutter.go:26::error: missing argument for Printf(\"%d\"): format reads arg 1, have only 0 args (vet)\n```\n\nGometalinter also supports the commonly seen `<path>/...` recursive path\nformat. Note that this can be *very* slow, and you may need to increase the linter `--deadline` to allow linters to complete.\n\n## FAQ\n\n### Exit status\n\ngometalinter sets two bits of the exit status to indicate different issues:\n\n| Bit | Meaning\n|-----|----------\n| 0   | A linter generated an issue.\n| 1   | An underlying error occurred; eg. a linter failed to execute. In this situation a warning will also be displayed.\n\neg. linter only = 1, underlying only = 2, linter + underlying = 3\n\n### What's the best way to use `gometalinter` in CI?\n\nThere are two main problems running in a CI:\n\n1. <s>Linters break, causing `gometalinter --install --update` to error</s> (this is no longer an issue as all linters are vendored).\n2. `gometalinter` adds a new linter.\n\nI have solved 1 by vendoring the linters.\n\nFor 2, the best option is to disable all linters, then explicitly enable the\nones you want:\n\n    gometalinter --disable-all --enable=errcheck --enable=vet --enable=vetshadow ...\n\n### How do I make `gometalinter` work with Go 1.5 vendoring?\n\n`gometalinter` has a `--vendor` flag that just sets `GO15VENDOREXPERIMENT=1`, however the\nunderlying tools must support it. Ensure that all of the linters are up to date and built with Go 1.5\n(`gometalinter --install --force`) then run `gometalinter --vendor .`. That should be it.\n\n### Why does `gometalinter --install` install a fork of gocyclo?\n\nI forked `gocyclo` because the upstream behaviour is to recursively check all\nsubdirectories even when just a single directory is specified. This made it\nunusably slow when vendoring. The recursive behaviour can be achieved with\ngometalinter by explicitly specifying `<path>/...`. There is a\n[pull request](https://github.com/fzipp/gocyclo/pull/1) open.\n\n### Many unexpected errors are being reported\n\nIf you see a whole bunch of errors being reported that you wouldn't expect,\nsuch as compile errors, this typically means that something is wrong with your\nGo environment. Try `go install` and fix any issues with your go installation,\nthen try gometalinter again.\n\n### Gometalinter is not working\n\nThat's more of a statement than a question, but okay.\n\nSometimes gometalinter will not report issues that you think it should. There\nare three things to try in that case:\n\n#### 1. Update to the latest build of gometalinter and all linters\n\n    curl -L https://git.io/vp6lP | sh\n\nIf you're lucky, this will fix the problem.\n\n#### 2. Analyse the debug output\n\nIf that doesn't help, the problem may be elsewhere (in no particular order):\n\n1. Upstream linter has changed its output or semantics.\n2. gometalinter is not invoking the tool correctly.\n3. gometalinter regular expression matches are not correct for a linter.\n4. Linter is exceeding the deadline.\n\nTo find out what's going on run in debug mode:\n\n    gometalinter --debug\n\nThis will show all output from the linters and should indicate why it is\nfailing.\n\n#### 3. Report an issue.\n\nFailing all else, if the problem looks like a bug please file an issue and\ninclude the output of `gometalinter --debug`.\n\n### How do I filter issues between two git refs?\n\n[revgrep](https://github.com/bradleyfalzon/revgrep) can be used to filter the output of `gometalinter`\nto show issues on lines that have changed between two git refs, such as unstaged changes, changes in\n`HEAD` vs `master` and between `master` and `origin/master`. See the project's documentation and `-help`\nusage for more information.\n\n```\ngo get -u github.com/bradleyfalzon/revgrep/...\ngometalinter |& revgrep               # If unstaged changes or untracked files, those issues are shown.\ngometalinter |& revgrep               # Else show issues in the last commit.\ngometalinter |& revgrep master        # Show issues between master and HEAD (or any other reference).\ngometalinter |& revgrep origin/master # Show issues that haven't been pushed.\n```\n\n## Checkstyle XML format\n\n`gometalinter` supports [checkstyle](http://checkstyle.sourceforge.net/)\ncompatible XML output format. It is triggered with `--checkstyle` flag:\n\n\tgometalinter --checkstyle\n\nCheckstyle format can be used to integrate gometalinter with Jenkins CI with the\nhelp of [Checkstyle Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Checkstyle+Plugin).\n"
        },
        {
          "name": "_linters",
          "type": "tree",
          "content": null
        },
        {
          "name": "aggregate.go",
          "type": "blob",
          "size": 1.083984375,
          "content": "package main\n\nimport (\n\t\"sort\"\n\t\"strings\"\n)\n\ntype issueKey struct {\n\tpath      string\n\tline, col int\n\tmessage   string\n}\n\ntype multiIssue struct {\n\t*Issue\n\tlinterNames []string\n}\n\n// AggregateIssueChan reads issues from a channel, aggregates issues which have\n// the same file, line, vol, and message, and returns aggregated issues on\n// a new channel.\nfunc AggregateIssueChan(issues chan *Issue) chan *Issue {\n\tout := make(chan *Issue, 1000000)\n\tissueMap := make(map[issueKey]*multiIssue)\n\tgo func() {\n\t\tfor issue := range issues {\n\t\t\tkey := issueKey{\n\t\t\t\tpath:    issue.Path.String(),\n\t\t\t\tline:    issue.Line,\n\t\t\t\tcol:     issue.Col,\n\t\t\t\tmessage: issue.Message,\n\t\t\t}\n\t\t\tif existing, ok := issueMap[key]; ok {\n\t\t\t\texisting.linterNames = append(existing.linterNames, issue.Linter)\n\t\t\t} else {\n\t\t\t\tissueMap[key] = &multiIssue{\n\t\t\t\t\tIssue:       issue,\n\t\t\t\t\tlinterNames: []string{issue.Linter},\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor _, multi := range issueMap {\n\t\t\tissue := multi.Issue\n\t\t\tsort.Strings(multi.linterNames)\n\t\t\tissue.Linter = strings.Join(multi.linterNames, \", \")\n\t\t\tout <- issue\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n"
        },
        {
          "name": "checkstyle.go",
          "type": "blob",
          "size": 1.42578125,
          "content": "package main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\n\tkingpin \"gopkg.in/alecthomas/kingpin.v3-unstable\"\n)\n\ntype checkstyleOutput struct {\n\tXMLName xml.Name          `xml:\"checkstyle\"`\n\tVersion string            `xml:\"version,attr\"`\n\tFiles   []*checkstyleFile `xml:\"file\"`\n}\n\ntype checkstyleFile struct {\n\tName   string             `xml:\"name,attr\"`\n\tErrors []*checkstyleError `xml:\"error\"`\n}\n\ntype checkstyleError struct {\n\tColumn   int    `xml:\"column,attr\"`\n\tLine     int    `xml:\"line,attr\"`\n\tMessage  string `xml:\"message,attr\"`\n\tSeverity string `xml:\"severity,attr\"`\n\tSource   string `xml:\"source,attr\"`\n}\n\nfunc outputToCheckstyle(issues chan *Issue) int {\n\tvar lastFile *checkstyleFile\n\tout := checkstyleOutput{\n\t\tVersion: \"5.0\",\n\t}\n\tstatus := 0\n\tfor issue := range issues {\n\t\tpath := issue.Path.Relative()\n\t\tif lastFile != nil && lastFile.Name != path {\n\t\t\tout.Files = append(out.Files, lastFile)\n\t\t\tlastFile = nil\n\t\t}\n\t\tif lastFile == nil {\n\t\t\tlastFile = &checkstyleFile{Name: path}\n\t\t}\n\n\t\tif config.Errors && issue.Severity != Error {\n\t\t\tcontinue\n\t\t}\n\n\t\tlastFile.Errors = append(lastFile.Errors, &checkstyleError{\n\t\t\tColumn:   issue.Col,\n\t\t\tLine:     issue.Line,\n\t\t\tMessage:  issue.Message,\n\t\t\tSeverity: string(issue.Severity),\n\t\t\tSource:   issue.Linter,\n\t\t})\n\t\tstatus = 1\n\t}\n\tif lastFile != nil {\n\t\tout.Files = append(out.Files, lastFile)\n\t}\n\td, err := xml.Marshal(&out)\n\tkingpin.FatalIfError(err, \"\")\n\tfmt.Printf(\"%s%s\\n\", xml.Header, d)\n\treturn status\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 4.828125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"text/template\"\n\t\"time\"\n)\n\n// Config for gometalinter. This can be loaded from a JSON file with --config.\ntype Config struct { // nolint: maligned\n\t// A map from linter name -> <LinterConfig|string>.\n\t//\n\t// For backwards compatibility, the value stored in the JSON blob can also\n\t// be a string of the form \"<command>:<pattern>\".\n\tLinters map[string]StringOrLinterConfig\n\n\t// The set of linters that should be enabled.\n\tEnable  []string\n\tDisable []string\n\n\t// A map of linter name to message that is displayed. This is useful when linters display text\n\t// that is useful only in isolation, such as errcheck which just reports the construct.\n\tMessageOverride map[string]string\n\tSeverity        map[string]string\n\tVendoredLinters bool\n\tFormat          string\n\tFast            bool\n\tInstall         bool\n\tUpdate          bool\n\tForce           bool\n\tDownloadOnly    bool\n\tDebug           bool\n\tConcurrency     int\n\tExclude         []string\n\tInclude         []string\n\tSkip            []string\n\tVendor          bool\n\tCyclo           int\n\tLineLength      int\n\tMisspellLocale  string\n\tMinConfidence   float64\n\tMinOccurrences  int\n\tMinConstLength  int\n\tDuplThreshold   int\n\tSort            []string\n\tTest            bool\n\tDeadline        jsonDuration\n\tErrors          bool\n\tJSON            bool\n\tCheckstyle      bool\n\tEnableGC        bool\n\tAggregate       bool\n\tEnableAll       bool\n\n\t// Warn if a nolint directive was never matched to a linter issue\n\tWarnUnmatchedDirective bool\n\n\tformatTemplate *template.Template\n}\n\ntype StringOrLinterConfig LinterConfig\n\nfunc (c *StringOrLinterConfig) UnmarshalJSON(raw []byte) error {\n\tvar linterConfig LinterConfig\n\t// first try to un-marshall directly into struct\n\torigErr := json.Unmarshal(raw, &linterConfig)\n\tif origErr == nil {\n\t\t*c = StringOrLinterConfig(linterConfig)\n\t\treturn nil\n\t}\n\n\t// i.e. bytes didn't represent the struct, treat them as a string\n\tvar linterSpec string\n\tif err := json.Unmarshal(raw, &linterSpec); err != nil {\n\t\treturn origErr\n\t}\n\tlinter, err := parseLinterConfigSpec(\"\", linterSpec)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*c = StringOrLinterConfig(linter)\n\treturn nil\n}\n\ntype jsonDuration time.Duration\n\nfunc (td *jsonDuration) UnmarshalJSON(raw []byte) error {\n\tvar durationAsString string\n\tif err := json.Unmarshal(raw, &durationAsString); err != nil {\n\t\treturn err\n\t}\n\tduration, err := time.ParseDuration(durationAsString)\n\t*td = jsonDuration(duration)\n\treturn err\n}\n\n// Duration returns the value as a time.Duration\nfunc (td *jsonDuration) Duration() time.Duration {\n\treturn time.Duration(*td)\n}\n\nvar sortKeys = []string{\"none\", \"path\", \"line\", \"column\", \"severity\", \"message\", \"linter\"}\n\n// Configuration defaults.\nvar config = &Config{\n\tFormat: DefaultIssueFormat,\n\n\tLinters: map[string]StringOrLinterConfig{},\n\tSeverity: map[string]string{\n\t\t\"gotype\":  \"error\",\n\t\t\"gotypex\": \"error\",\n\t\t\"test\":    \"error\",\n\t\t\"testify\": \"error\",\n\t\t\"vet\":     \"error\",\n\t},\n\tMessageOverride: map[string]string{\n\t\t\"errcheck\":    \"error return value not checked ({message})\",\n\t\t\"gocyclo\":     \"cyclomatic complexity {cyclo} of function {function}() is high (> {mincyclo})\",\n\t\t\"gofmt\":       \"file is not gofmted with -s\",\n\t\t\"goimports\":   \"file is not goimported\",\n\t\t\"safesql\":     \"potentially unsafe SQL statement\",\n\t\t\"structcheck\": \"unused struct field {message}\",\n\t\t\"unparam\":     \"parameter {message}\",\n\t\t\"varcheck\":    \"unused variable or constant {message}\",\n\t},\n\tEnable:          defaultEnabled(),\n\tVendoredLinters: true,\n\tConcurrency:     runtime.NumCPU(),\n\tCyclo:           10,\n\tLineLength:      80,\n\tMisspellLocale:  \"\",\n\tMinConfidence:   0.8,\n\tMinOccurrences:  3,\n\tMinConstLength:  3,\n\tDuplThreshold:   50,\n\tSort:            []string{\"none\"},\n\tDeadline:        jsonDuration(time.Second * 30),\n}\n\nfunc loadConfigFile(filename string) error {\n\tr, err := os.Open(filename)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer r.Close() // nolint: errcheck\n\terr = json.NewDecoder(r).Decode(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, disable := range config.Disable {\n\t\tfor i, enable := range config.Enable {\n\t\t\tif enable == disable {\n\t\t\t\tconfig.Enable = append(config.Enable[:i], config.Enable[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn err\n}\n\nfunc findDefaultConfigFile() (fullPath string, found bool, err error) {\n\tprevPath := \"\"\n\tdirPath, err := os.Getwd()\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\n\tfor dirPath != prevPath {\n\t\tfullPath, found, err = findConfigFileInDir(dirPath)\n\t\tif err != nil || found {\n\t\t\treturn fullPath, found, err\n\t\t}\n\t\tprevPath, dirPath = dirPath, filepath.Dir(dirPath)\n\t}\n\n\treturn \"\", false, nil\n}\n\nfunc findConfigFileInDir(dirPath string) (fullPath string, found bool, err error) {\n\tfullPath = filepath.Join(dirPath, defaultConfigPath)\n\tif _, err := os.Stat(fullPath); err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn \"\", false, nil\n\t\t}\n\t\treturn \"\", false, err\n\t}\n\n\treturn fullPath, true, nil\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 2.0439453125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestLinterConfigUnmarshalJSON(t *testing.T) {\n\tsource := `{\n\t\t\"Command\": \"/bin/custom\",\n\t\t\"PartitionStrategy\": \"directories\"\n\t}`\n\tvar config StringOrLinterConfig\n\terr := json.Unmarshal([]byte(source), &config)\n\trequire.NoError(t, err)\n\tassert.Equal(t, \"/bin/custom\", config.Command)\n\tassert.Equal(t, functionName(partitionPathsAsDirectories), functionName(config.PartitionStrategy))\n}\n\nfunc TestFindDefaultConfigFile(t *testing.T) {\n\ttmpdir, cleanup := setupTempDir(t)\n\tdefer cleanup()\n\n\tmkDir(t, tmpdir, \"contains\")\n\tmkDir(t, tmpdir, \"contains\", \"foo\")\n\tmkDir(t, tmpdir, \"contains\", \"foo\", \"bar\")\n\tmkDir(t, tmpdir, \"contains\", \"double\")\n\tmkDir(t, tmpdir, \"lacks\")\n\n\tmkFile(t, filepath.Join(tmpdir, \"contains\"), defaultConfigPath, \"{}\")\n\tmkFile(t, filepath.Join(tmpdir, \"contains\", \"double\"), defaultConfigPath, \"{}\")\n\n\tvar testcases = []struct {\n\t\tdir      string\n\t\texpected string\n\t\tfound    bool\n\t}{\n\t\t{\n\t\t\tdir:      tmpdir,\n\t\t\texpected: \"\",\n\t\t\tfound:    false,\n\t\t},\n\t\t{\n\t\t\tdir:      filepath.Join(tmpdir, \"contains\"),\n\t\t\texpected: filepath.Join(tmpdir, \"contains\", defaultConfigPath),\n\t\t\tfound:    true,\n\t\t},\n\t\t{\n\t\t\tdir:      filepath.Join(tmpdir, \"contains\", \"foo\"),\n\t\t\texpected: filepath.Join(tmpdir, \"contains\", defaultConfigPath),\n\t\t\tfound:    true,\n\t\t},\n\t\t{\n\t\t\tdir:      filepath.Join(tmpdir, \"contains\", \"foo\", \"bar\"),\n\t\t\texpected: filepath.Join(tmpdir, \"contains\", defaultConfigPath),\n\t\t\tfound:    true,\n\t\t},\n\t\t{\n\t\t\tdir:      filepath.Join(tmpdir, \"contains\", \"double\"),\n\t\t\texpected: filepath.Join(tmpdir, \"contains\", \"double\", defaultConfigPath),\n\t\t\tfound:    true,\n\t\t},\n\t\t{\n\t\t\tdir:      filepath.Join(tmpdir, \"lacks\"),\n\t\t\texpected: \"\",\n\t\t\tfound:    false,\n\t\t},\n\t}\n\n\tfor _, testcase := range testcases {\n\t\trequire.NoError(t, os.Chdir(testcase.dir))\n\t\tconfigFile, found, err := findDefaultConfigFile()\n\t\tassert.Equal(t, testcase.expected, configFile)\n\t\tassert.Equal(t, testcase.found, found)\n\t\tassert.NoError(t, err)\n\t}\n}\n"
        },
        {
          "name": "directives.go",
          "type": "blob",
          "size": 5.24609375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"go/ast\"\n\t\"go/parser\"\n\t\"go/token\"\n\t\"os\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype ignoredRange struct {\n\tcol        int\n\tstart, end int\n\tlinters    []string\n\tmatched    bool\n}\n\nfunc (i *ignoredRange) matches(issue *Issue) bool {\n\tif issue.Line < i.start || issue.Line > i.end {\n\t\treturn false\n\t}\n\tif len(i.linters) == 0 {\n\t\treturn true\n\t}\n\tfor _, l := range i.linters {\n\t\tif l == issue.Linter {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (i *ignoredRange) near(col, start int) bool {\n\treturn col == i.col && i.end == start-1\n}\n\nfunc (i *ignoredRange) String() string {\n\tlinters := strings.Join(i.linters, \",\")\n\tif len(i.linters) == 0 {\n\t\tlinters = \"all\"\n\t}\n\treturn fmt.Sprintf(\"%s:%d-%d\", linters, i.start, i.end)\n}\n\ntype ignoredRanges []*ignoredRange\n\nfunc (ir ignoredRanges) Len() int           { return len(ir) }\nfunc (ir ignoredRanges) Swap(i, j int)      { ir[i], ir[j] = ir[j], ir[i] }\nfunc (ir ignoredRanges) Less(i, j int) bool { return ir[i].end < ir[j].end }\n\ntype directiveParser struct {\n\tlock  sync.Mutex\n\tfiles map[string]ignoredRanges\n\tfset  *token.FileSet\n}\n\nfunc newDirectiveParser() *directiveParser {\n\treturn &directiveParser{\n\t\tfiles: map[string]ignoredRanges{},\n\t\tfset:  token.NewFileSet(),\n\t}\n}\n\n// IsIgnored returns true if the given linter issue is ignored by a linter directive.\nfunc (d *directiveParser) IsIgnored(issue *Issue) bool {\n\td.lock.Lock()\n\tpath := issue.Path.Relative()\n\tranges, ok := d.files[path]\n\tif !ok {\n\t\tranges = d.parseFile(path)\n\t\tsort.Sort(ranges)\n\t\td.files[path] = ranges\n\t}\n\td.lock.Unlock()\n\tfor _, r := range ranges {\n\t\tif r.matches(issue) {\n\t\t\tdebug(\"nolint: matched %s to issue %s\", r, issue)\n\t\t\tr.matched = true\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Unmatched returns all the ranges which were never used to ignore an issue\nfunc (d *directiveParser) Unmatched() map[string]ignoredRanges {\n\tunmatched := map[string]ignoredRanges{}\n\tfor path, ranges := range d.files {\n\t\tfor _, ignore := range ranges {\n\t\t\tif !ignore.matched {\n\t\t\t\tunmatched[path] = append(unmatched[path], ignore)\n\t\t\t}\n\t\t}\n\t}\n\treturn unmatched\n}\n\n// LoadFiles from a list of directories\nfunc (d *directiveParser) LoadFiles(paths []string) error {\n\td.lock.Lock()\n\tdefer d.lock.Unlock()\n\tfilenames, err := pathsToFileGlobs(paths)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, filename := range filenames {\n\t\tranges := d.parseFile(filename)\n\t\tsort.Sort(ranges)\n\t\td.files[filename] = ranges\n\t}\n\treturn nil\n}\n\n// Takes a set of ignoredRanges, determines if they immediately precede a statement\n// construct, and expands the range to include that construct. Why? So you can\n// precede a function or struct with //nolint\ntype rangeExpander struct {\n\tfset   *token.FileSet\n\tranges ignoredRanges\n}\n\nfunc (a *rangeExpander) Visit(node ast.Node) ast.Visitor {\n\tif node == nil {\n\t\treturn a\n\t}\n\tstartPos := a.fset.Position(node.Pos())\n\tstart := startPos.Line\n\tend := a.fset.Position(node.End()).Line\n\tfound := sort.Search(len(a.ranges), func(i int) bool {\n\t\treturn a.ranges[i].end+1 >= start\n\t})\n\tif found < len(a.ranges) && a.ranges[found].near(startPos.Column, start) {\n\t\tr := a.ranges[found]\n\t\tif r.start > start {\n\t\t\tr.start = start\n\t\t}\n\t\tif r.end < end {\n\t\t\tr.end = end\n\t\t}\n\t}\n\treturn a\n}\n\nfunc (d *directiveParser) parseFile(path string) ignoredRanges {\n\tstart := time.Now()\n\tdebug(\"nolint: parsing %s for directives\", path)\n\tfile, err := parser.ParseFile(d.fset, path, nil, parser.ParseComments)\n\tif err != nil {\n\t\tdebug(\"nolint: failed to parse %q: %s\", path, err)\n\t\treturn nil\n\t}\n\tranges := extractCommentGroupRange(d.fset, file.Comments...)\n\tvisitor := &rangeExpander{fset: d.fset, ranges: ranges}\n\tast.Walk(visitor, file)\n\tdebug(\"nolint: parsing %s took %s\", path, time.Since(start))\n\treturn visitor.ranges\n}\n\nfunc extractCommentGroupRange(fset *token.FileSet, comments ...*ast.CommentGroup) (ranges ignoredRanges) {\n\tfor _, g := range comments {\n\t\tfor _, c := range g.List {\n\t\t\ttext := strings.TrimLeft(c.Text, \"/ \")\n\t\t\tvar linters []string\n\t\t\tif strings.HasPrefix(text, \"nolint\") {\n\t\t\t\tif strings.HasPrefix(text, \"nolint:\") {\n\t\t\t\t\tfor _, linter := range strings.Split(text[7:], \",\") {\n\t\t\t\t\t\tlinters = append(linters, strings.TrimSpace(linter))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpos := fset.Position(g.Pos())\n\t\t\t\trng := &ignoredRange{\n\t\t\t\t\tcol:     pos.Column,\n\t\t\t\t\tstart:   pos.Line,\n\t\t\t\t\tend:     fset.Position(g.End()).Line,\n\t\t\t\t\tlinters: linters,\n\t\t\t\t}\n\t\t\t\tranges = append(ranges, rng)\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\n\nfunc filterIssuesViaDirectives(directives *directiveParser, issues chan *Issue) chan *Issue {\n\tout := make(chan *Issue, 1000000)\n\tgo func() {\n\t\tfor issue := range issues {\n\t\t\tif !directives.IsIgnored(issue) {\n\t\t\t\tout <- issue\n\t\t\t}\n\t\t}\n\n\t\tif config.WarnUnmatchedDirective {\n\t\t\tfor _, issue := range warnOnUnusedDirective(directives) {\n\t\t\t\tout <- issue\n\t\t\t}\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n\nfunc warnOnUnusedDirective(directives *directiveParser) []*Issue {\n\tout := []*Issue{}\n\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\twarning(\"failed to get working directory %s\", err)\n\t}\n\n\tfor path, ranges := range directives.Unmatched() {\n\t\tfor _, ignore := range ranges {\n\t\t\tissue, _ := NewIssue(\"nolint\", config.formatTemplate)\n\t\t\tissue.Path = newIssuePath(cwd, path)\n\t\t\tissue.Line = ignore.start\n\t\t\tissue.Col = ignore.col\n\t\t\tissue.Message = \"nolint directive did not match any issue\"\n\t\t\tout = append(out, issue)\n\t\t}\n\t}\n\treturn out\n}\n"
        },
        {
          "name": "directives_test.go",
          "type": "blob",
          "size": 0.82421875,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestIgnoreRangeMatch(t *testing.T) {\n\tvar testcases = []struct {\n\t\tdoc      string\n\t\tissue    Issue\n\t\tlinters  []string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tdoc:   \"unmatched line\",\n\t\t\tissue: Issue{Line: 100},\n\t\t},\n\t\t{\n\t\t\tdoc:      \"matched line, all linters\",\n\t\t\tissue:    Issue{Line: 5},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tdoc:     \"matched line, unmatched linter\",\n\t\t\tissue:   Issue{Line: 5},\n\t\t\tlinters: []string{\"vet\"},\n\t\t},\n\t\t{\n\t\t\tdoc:      \"matched line and linters\",\n\t\t\tissue:    Issue{Line: 20, Linter: \"vet\"},\n\t\t\tlinters:  []string{\"vet\"},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, testcase := range testcases {\n\t\tir := ignoredRange{col: 20, start: 5, end: 20, linters: testcase.linters}\n\t\tassert.Equal(t, testcase.expected, ir.matches(&testcase.issue), testcase.doc)\n\t}\n}\n"
        },
        {
          "name": "execute.go",
          "type": "blob",
          "size": 6.73046875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/google/shlex\"\n\tkingpin \"gopkg.in/alecthomas/kingpin.v3-unstable\"\n)\n\ntype Vars map[string]string\n\nfunc (v Vars) Copy() Vars {\n\tout := Vars{}\n\tfor k, v := range v {\n\t\tout[k] = v\n\t}\n\treturn out\n}\n\nfunc (v Vars) Replace(s string) string {\n\tfor k, v := range v {\n\t\tprefix := regexp.MustCompile(fmt.Sprintf(\"{%s=([^}]*)}\", k))\n\t\tif v != \"\" {\n\t\t\ts = prefix.ReplaceAllString(s, \"$1\")\n\t\t} else {\n\t\t\ts = prefix.ReplaceAllString(s, \"\")\n\t\t}\n\t\ts = strings.Replace(s, fmt.Sprintf(\"{%s}\", k), v, -1)\n\t}\n\treturn s\n}\n\ntype linterState struct {\n\t*Linter\n\tissues   chan *Issue\n\tvars     Vars\n\texclude  *regexp.Regexp\n\tinclude  *regexp.Regexp\n\tdeadline <-chan time.Time\n}\n\nfunc (l *linterState) Partitions(paths []string) ([][]string, error) {\n\tcmdArgs, err := parseCommand(l.command())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tparts, err := l.Linter.PartitionStrategy(cmdArgs, paths)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn parts, nil\n}\n\nfunc (l *linterState) command() string {\n\treturn l.vars.Replace(l.Command)\n}\n\nfunc runLinters(linters map[string]*Linter, paths []string, concurrency int, exclude, include *regexp.Regexp) (chan *Issue, chan error) {\n\terrch := make(chan error, len(linters))\n\tconcurrencych := make(chan bool, concurrency)\n\tincomingIssues := make(chan *Issue, 1000000)\n\n\tdirectiveParser := newDirectiveParser()\n\tif config.WarnUnmatchedDirective {\n\t\tdirectiveParser.LoadFiles(paths)\n\t}\n\n\tprocessedIssues := maybeSortIssues(filterIssuesViaDirectives(\n\t\tdirectiveParser, maybeAggregateIssues(incomingIssues)))\n\n\tvars := Vars{\n\t\t\"duplthreshold\":    fmt.Sprintf(\"%d\", config.DuplThreshold),\n\t\t\"mincyclo\":         fmt.Sprintf(\"%d\", config.Cyclo),\n\t\t\"maxlinelength\":    fmt.Sprintf(\"%d\", config.LineLength),\n\t\t\"misspelllocale\":   fmt.Sprintf(\"%s\", config.MisspellLocale),\n\t\t\"min_confidence\":   fmt.Sprintf(\"%f\", config.MinConfidence),\n\t\t\"min_occurrences\":  fmt.Sprintf(\"%d\", config.MinOccurrences),\n\t\t\"min_const_length\": fmt.Sprintf(\"%d\", config.MinConstLength),\n\t\t\"tests\":            \"\",\n\t\t\"not_tests\":        \"true\",\n\t}\n\tif config.Test {\n\t\tvars[\"tests\"] = \"true\"\n\t\tvars[\"not_tests\"] = \"\"\n\t}\n\n\twg := &sync.WaitGroup{}\n\tid := 1\n\tfor _, linter := range linters {\n\t\tdeadline := time.After(config.Deadline.Duration())\n\t\tstate := &linterState{\n\t\t\tLinter:   linter,\n\t\t\tissues:   incomingIssues,\n\t\t\tvars:     vars,\n\t\t\texclude:  exclude,\n\t\t\tinclude:  include,\n\t\t\tdeadline: deadline,\n\t\t}\n\n\t\tpartitions, err := state.Partitions(paths)\n\t\tif err != nil {\n\t\t\terrch <- err\n\t\t\tcontinue\n\t\t}\n\t\tfor _, args := range partitions {\n\t\t\twg.Add(1)\n\t\t\tconcurrencych <- true\n\t\t\t// Call the goroutine with a copy of the args array so that the\n\t\t\t// contents of the array are not modified by the next iteration of\n\t\t\t// the above for loop\n\t\t\tgo func(id int, args []string) {\n\t\t\t\terr := executeLinter(id, state, args)\n\t\t\t\tif err != nil {\n\t\t\t\t\terrch <- err\n\t\t\t\t}\n\t\t\t\t<-concurrencych\n\t\t\t\twg.Done()\n\t\t\t}(id, args)\n\t\t\tid++\n\t\t}\n\t}\n\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(incomingIssues)\n\t\tclose(errch)\n\t}()\n\treturn processedIssues, errch\n}\n\nfunc executeLinter(id int, state *linterState, args []string) error {\n\tif len(args) == 0 {\n\t\treturn fmt.Errorf(\"missing linter command\")\n\t}\n\n\tstart := time.Now()\n\tdbg := namespacedDebug(fmt.Sprintf(\"[%s.%d]: \", state.Name, id))\n\tdbg(\"executing %s\", strings.Join(args, \" \"))\n\tbuf := bytes.NewBuffer(nil)\n\tcommand := args[0]\n\tcmd := exec.Command(command, args[1:]...) // nolint: gosec\n\tcmd.Stdout = buf\n\tcmd.Stderr = buf\n\terr := cmd.Start()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to execute linter %s: %s\", command, err)\n\t}\n\n\tdone := make(chan error)\n\tgo func() {\n\t\tdone <- cmd.Wait()\n\t}()\n\n\t// Wait for process to complete or deadline to expire.\n\tselect {\n\tcase err = <-done:\n\n\tcase <-state.deadline:\n\t\terr = fmt.Errorf(\"deadline exceeded by linter %s (try increasing --deadline)\",\n\t\t\tstate.Name)\n\t\tkerr := cmd.Process.Kill()\n\t\tif kerr != nil {\n\t\t\twarning(\"failed to kill %s: %s\", state.Name, kerr)\n\t\t}\n\t\treturn err\n\t}\n\n\tif err != nil {\n\t\tdbg(\"warning: %s returned %s: %s\", command, err, buf.String())\n\t}\n\n\tprocessOutput(dbg, state, buf.Bytes())\n\telapsed := time.Since(start)\n\tdbg(\"%s linter took %s\", state.Name, elapsed)\n\treturn nil\n}\n\nfunc parseCommand(command string) ([]string, error) {\n\targs, err := shlex.Split(command)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif len(args) == 0 {\n\t\treturn nil, fmt.Errorf(\"invalid command %q\", command)\n\t}\n\texe, err := exec.LookPath(args[0])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn append([]string{exe}, args[1:]...), nil\n}\n\n// nolint: gocyclo\nfunc processOutput(dbg debugFunction, state *linterState, out []byte) {\n\tre := state.regex\n\tall := re.FindAllSubmatchIndex(out, -1)\n\tdbg(\"%s hits %d: %s\", state.Name, len(all), state.Pattern)\n\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\twarning(\"failed to get working directory %s\", err)\n\t}\n\n\t// Create a local copy of vars so they can be modified by the linter output\n\tvars := state.vars.Copy()\n\n\tfor _, indices := range all {\n\t\tgroup := [][]byte{}\n\t\tfor i := 0; i < len(indices); i += 2 {\n\t\t\tvar fragment []byte\n\t\t\tif indices[i] != -1 {\n\t\t\t\tfragment = out[indices[i]:indices[i+1]]\n\t\t\t}\n\t\t\tgroup = append(group, fragment)\n\t\t}\n\n\t\tissue, err := NewIssue(state.Linter.Name, config.formatTemplate)\n\t\tkingpin.FatalIfError(err, \"Invalid output format\")\n\n\t\tfor i, name := range re.SubexpNames() {\n\t\t\tif group[i] == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tpart := string(group[i])\n\t\t\tif name != \"\" {\n\t\t\t\tvars[name] = part\n\t\t\t}\n\t\t\tswitch name {\n\t\t\tcase \"path\":\n\t\t\t\tissue.Path, err = newIssuePathFromAbsPath(cwd, part)\n\t\t\t\tif err != nil {\n\t\t\t\t\twarning(\"failed to make %s a relative path: %s\", part, err)\n\t\t\t\t}\n\t\t\tcase \"line\":\n\t\t\t\tn, err := strconv.ParseInt(part, 10, 32)\n\t\t\t\tkingpin.FatalIfError(err, \"line matched invalid integer\")\n\t\t\t\tissue.Line = int(n)\n\n\t\t\tcase \"col\":\n\t\t\t\tn, err := strconv.ParseInt(part, 10, 32)\n\t\t\t\tkingpin.FatalIfError(err, \"col matched invalid integer\")\n\t\t\t\tissue.Col = int(n)\n\n\t\t\tcase \"message\":\n\t\t\t\tissue.Message = part\n\n\t\t\tcase \"\":\n\t\t\t}\n\t\t}\n\t\t// TODO: set messageOveride and severity on the Linter instead of reading\n\t\t// them directly from the static config\n\t\tif m, ok := config.MessageOverride[state.Name]; ok {\n\t\t\tissue.Message = vars.Replace(m)\n\t\t}\n\t\tif sev, ok := config.Severity[state.Name]; ok {\n\t\t\tissue.Severity = Severity(sev)\n\t\t}\n\t\tif state.exclude != nil && state.exclude.MatchString(issue.String()) {\n\t\t\tcontinue\n\t\t}\n\t\tif state.include != nil && !state.include.MatchString(issue.String()) {\n\t\t\tcontinue\n\t\t}\n\t\tstate.issues <- issue\n\t}\n}\n\nfunc maybeSortIssues(issues chan *Issue) chan *Issue {\n\tif reflect.DeepEqual([]string{\"none\"}, config.Sort) {\n\t\treturn issues\n\t}\n\treturn SortIssueChan(issues, config.Sort)\n}\n\nfunc maybeAggregateIssues(issues chan *Issue) chan *Issue {\n\tif !config.Aggregate {\n\t\treturn issues\n\t}\n\treturn AggregateIssueChan(issues)\n}\n"
        },
        {
          "name": "execute_test.go",
          "type": "blob",
          "size": 1.228515625,
          "content": "package main\n\nimport (\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestLinterStateCommand(t *testing.T) {\n\tvarsDefault := Vars{\"tests\": \"\", \"not_tests\": \"true\"}\n\tvarsWithTest := Vars{\"tests\": \"true\", \"not_tests\": \"\"}\n\n\tvar testcases = []struct {\n\t\tlinter   string\n\t\tvars     Vars\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tlinter:   \"errcheck\",\n\t\t\tvars:     varsWithTest,\n\t\t\texpected: `errcheck -abspath `,\n\t\t},\n\t\t{\n\t\t\tlinter:   \"errcheck\",\n\t\t\tvars:     varsDefault,\n\t\t\texpected: `errcheck -abspath -ignoretests`,\n\t\t},\n\t\t{\n\t\t\tlinter:   \"gotype\",\n\t\t\tvars:     varsDefault,\n\t\t\texpected: `gotype -e `,\n\t\t},\n\t\t{\n\t\t\tlinter:   \"gotype\",\n\t\t\tvars:     varsWithTest,\n\t\t\texpected: `gotype -e -t`,\n\t\t},\n\t\t{\n\t\t\tlinter:   \"structcheck\",\n\t\t\tvars:     varsDefault,\n\t\t\texpected: `structcheck `,\n\t\t},\n\t\t{\n\t\t\tlinter:   \"structcheck\",\n\t\t\tvars:     varsWithTest,\n\t\t\texpected: `structcheck -t`,\n\t\t},\n\t\t{\n\t\t\tlinter: \"unparam\",\n\t\t\tvars: varsDefault,\n\t\t\texpected: `unparam -tests=false`,\n\t\t},\n\t\t{\n\t\t\tlinter: \"unparam\",\n\t\t\tvars: varsWithTest,\n\t\t\texpected: `unparam `,\n\t\t},\n\t}\n\n\tfor _, testcase := range testcases {\n\t\tls := linterState{\n\t\t\tLinter: getLinterByName(testcase.linter, LinterConfig{}),\n\t\t\tvars:   testcase.vars,\n\t\t}\n\t\tassert.Equal(t, testcase.expected, ls.command())\n\t}\n}\n"
        },
        {
          "name": "issue.go",
          "type": "blob",
          "size": 3.908203125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/template\"\n)\n\n// DefaultIssueFormat used to print an issue\nconst DefaultIssueFormat = \"{{.Path}}:{{.Line}}:{{if .Col}}{{.Col}}{{end}}:{{.Severity}}: {{.Message}} ({{.Linter}})\"\n\n// Severity of linter message\ntype Severity string\n\n// Linter message severity levels.\nconst (\n\tError   Severity = \"error\"\n\tWarning Severity = \"warning\"\n)\n\ntype IssuePath struct {\n\troot string\n\tpath string\n}\n\nfunc (i IssuePath) String() string {\n\treturn i.Relative()\n}\n\nfunc (i IssuePath) Relative() string {\n\treturn i.path\n}\n\nfunc (i IssuePath) Abs() string {\n\treturn filepath.Join(i.root, i.path)\n}\n\nfunc (i IssuePath) MarshalJSON() ([]byte, error) {\n\treturn json.Marshal(i.String())\n}\n\nfunc newIssuePath(root, path string) IssuePath {\n\treturn IssuePath{root: root, path: path}\n}\n\n// newIssuePathFromAbsPath returns a new issuePath from a path that may be\n// an absolute path. root must be an absolute path.\nfunc newIssuePathFromAbsPath(root, path string) (IssuePath, error) {\n\tresolvedRoot, err := filepath.EvalSymlinks(root)\n\tif err != nil {\n\t\treturn newIssuePath(root, path), err\n\t}\n\n\tresolvedPath, err := filepath.EvalSymlinks(path)\n\tif err != nil {\n\t\treturn newIssuePath(root, path), err\n\t}\n\n\tif !filepath.IsAbs(path) {\n\t\treturn newIssuePath(resolvedRoot, resolvedPath), nil\n\t}\n\n\trelPath, err := filepath.Rel(resolvedRoot, resolvedPath)\n\treturn newIssuePath(resolvedRoot, relPath), err\n}\n\ntype Issue struct {\n\tLinter     string    `json:\"linter\"`\n\tSeverity   Severity  `json:\"severity\"`\n\tPath       IssuePath `json:\"path\"`\n\tLine       int       `json:\"line\"`\n\tCol        int       `json:\"col\"`\n\tMessage    string    `json:\"message\"`\n\tformatTmpl *template.Template\n}\n\n// NewIssue returns a new issue. Returns an error if formatTmpl is not a valid\n// template for an Issue.\nfunc NewIssue(linter string, formatTmpl *template.Template) (*Issue, error) {\n\tissue := &Issue{\n\t\tLine:       1,\n\t\tSeverity:   Warning,\n\t\tLinter:     linter,\n\t\tformatTmpl: formatTmpl,\n\t}\n\terr := formatTmpl.Execute(ioutil.Discard, issue)\n\treturn issue, err\n}\n\nfunc (i *Issue) String() string {\n\tif i.formatTmpl == nil {\n\t\tcol := \"\"\n\t\tif i.Col != 0 {\n\t\t\tcol = fmt.Sprintf(\"%d\", i.Col)\n\t\t}\n\t\treturn fmt.Sprintf(\"%s:%d:%s:%s: %s (%s)\",\n\t\t\tstrings.TrimSpace(i.Path.Relative()),\n\t\t\ti.Line, col, i.Severity,\n\t\t\tstrings.TrimSpace(i.Message),\n\t\t\ti.Linter)\n\t}\n\tbuf := new(bytes.Buffer)\n\t_ = i.formatTmpl.Execute(buf, i)\n\treturn buf.String()\n}\n\ntype sortedIssues struct {\n\tissues []*Issue\n\torder  []string\n}\n\nfunc (s *sortedIssues) Len() int      { return len(s.issues) }\nfunc (s *sortedIssues) Swap(i, j int) { s.issues[i], s.issues[j] = s.issues[j], s.issues[i] }\n\nfunc (s *sortedIssues) Less(i, j int) bool {\n\tl, r := s.issues[i], s.issues[j]\n\treturn CompareIssue(*l, *r, s.order)\n}\n\n// CompareIssue two Issues and return true if left should sort before right\n// nolint: gocyclo\nfunc CompareIssue(l, r Issue, order []string) bool {\n\tfor _, key := range order {\n\t\tswitch {\n\t\tcase key == \"path\" && l.Path != r.Path:\n\t\t\treturn l.Path.String() < r.Path.String()\n\t\tcase key == \"line\" && l.Line != r.Line:\n\t\t\treturn l.Line < r.Line\n\t\tcase key == \"column\" && l.Col != r.Col:\n\t\t\treturn l.Col < r.Col\n\t\tcase key == \"severity\" && l.Severity != r.Severity:\n\t\t\treturn l.Severity < r.Severity\n\t\tcase key == \"message\" && l.Message != r.Message:\n\t\t\treturn l.Message < r.Message\n\t\tcase key == \"linter\" && l.Linter != r.Linter:\n\t\t\treturn l.Linter < r.Linter\n\t\t}\n\t}\n\treturn true\n}\n\n// SortIssueChan reads issues from one channel, sorts them, and returns them to another\n// channel\nfunc SortIssueChan(issues chan *Issue, order []string) chan *Issue {\n\tout := make(chan *Issue, 1000000)\n\tsorted := &sortedIssues{\n\t\tissues: []*Issue{},\n\t\torder:  order,\n\t}\n\tgo func() {\n\t\tfor issue := range issues {\n\t\t\tsorted.issues = append(sorted.issues, issue)\n\t\t}\n\t\tsort.Sort(sorted)\n\t\tfor _, issue := range sorted.issues {\n\t\t\tout <- issue\n\t\t}\n\t\tclose(out)\n\t}()\n\treturn out\n}\n"
        },
        {
          "name": "issue_template.md",
          "type": "blob",
          "size": 0.1298828125,
          "content": "<!--\nUse \"--debug\" to debug gometalinter before filing an issue.\nPlease read CONTRIBUTING.md for full instructions on debugging.\n-->\n"
        },
        {
          "name": "issue_test.go",
          "type": "blob",
          "size": 1.1201171875,
          "content": "package main\n\nimport (\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestSortedIssues(t *testing.T) {\n\tactual := []*Issue{\n\t\t{Path: newIssuePath(\"\", \"b.go\"), Line: 5, Col: 1},\n\t\t{Path: newIssuePath(\"\", \"a.go\"), Line: 3, Col: 2},\n\t\t{Path: newIssuePath(\"\", \"b.go\"), Line: 1, Col: 3},\n\t\t{Path: newIssuePath(\"\", \"a.go\"), Line: 1, Col: 4},\n\t}\n\tissues := &sortedIssues{\n\t\tissues: actual,\n\t\torder:  []string{\"path\", \"line\", \"column\"},\n\t}\n\tsort.Sort(issues)\n\texpected := []*Issue{\n\t\t{Path: newIssuePath(\"\", \"a.go\"), Line: 1, Col: 4},\n\t\t{Path: newIssuePath(\"\", \"a.go\"), Line: 3, Col: 2},\n\t\t{Path: newIssuePath( \"\", \"b.go\"), Line: 1, Col: 3},\n\t\t{Path: newIssuePath( \"\", \"b.go\"), Line: 5, Col: 1},\n\t}\n\trequire.Equal(t, expected, actual)\n}\n\nfunc TestCompareOrderWithMessage(t *testing.T) {\n\torder := []string{\"path\", \"line\", \"column\", \"message\"}\n\tissueM := Issue{Path: newIssuePath(\"\", \"file.go\"), Message: \"message\"}\n\tissueU := Issue{Path: newIssuePath(\"\", \"file.go\"), Message: \"unknown\"}\n\n\tassert.True(t, CompareIssue(issueM, issueU, order))\n\tassert.False(t, CompareIssue(issueU, issueM, order))\n}\n"
        },
        {
          "name": "linters.go",
          "type": "blob",
          "size": 12.16015625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"sort\"\n\t\"strings\"\n\n\tkingpin \"gopkg.in/alecthomas/kingpin.v3-unstable\"\n)\n\ntype LinterConfig struct {\n\tCommand           string\n\tPattern           string\n\tInstallFrom       string\n\tPartitionStrategy partitionStrategy\n\tIsFast            bool\n\tdefaultEnabled    bool\n}\n\ntype Linter struct {\n\tLinterConfig\n\tName  string\n\tregex *regexp.Regexp\n}\n\n// NewLinter returns a new linter from a config\nfunc NewLinter(name string, config LinterConfig) (*Linter, error) {\n\tif p, ok := predefinedPatterns[config.Pattern]; ok {\n\t\tconfig.Pattern = p\n\t}\n\tregex, err := regexp.Compile(\"(?m:\" + config.Pattern + \")\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif config.PartitionStrategy == nil {\n\t\tconfig.PartitionStrategy = partitionPathsAsDirectories\n\t}\n\treturn &Linter{\n\t\tLinterConfig: config,\n\t\tName:         name,\n\t\tregex:        regex,\n\t}, nil\n}\n\nfunc (l *Linter) String() string {\n\treturn l.Name\n}\n\nvar predefinedPatterns = map[string]string{\n\t\"PATH:LINE:COL:MESSAGE\": `^(?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.*)$`,\n\t\"PATH:LINE:MESSAGE\":     `^(?P<path>.*?\\.go):(?P<line>\\d+):\\s*(?P<message>.*)$`,\n}\n\nfunc getLinterByName(name string, overrideConf LinterConfig) *Linter {\n\tconf := defaultLinters[name]\n\tif val := overrideConf.Command; val != \"\" {\n\t\tconf.Command = val\n\t}\n\tif val := overrideConf.Pattern; val != \"\" {\n\t\tconf.Pattern = val\n\t}\n\tif val := overrideConf.InstallFrom; val != \"\" {\n\t\tconf.InstallFrom = val\n\t}\n\tif overrideConf.IsFast {\n\t\tconf.IsFast = true\n\t}\n\tif val := overrideConf.PartitionStrategy; val != nil {\n\t\tconf.PartitionStrategy = val\n\t}\n\n\tlinter, _ := NewLinter(name, conf)\n\treturn linter\n}\n\nfunc parseLinterConfigSpec(name string, spec string) (LinterConfig, error) {\n\tparts := strings.SplitN(spec, \":\", 2)\n\tif len(parts) < 2 {\n\t\treturn LinterConfig{}, fmt.Errorf(\"linter spec needs at least two components\")\n\t}\n\n\tconfig := defaultLinters[name]\n\tconfig.Command, config.Pattern = parts[0], parts[1]\n\tif predefined, ok := predefinedPatterns[config.Pattern]; ok {\n\t\tconfig.Pattern = predefined\n\t}\n\n\treturn config, nil\n}\n\nfunc makeInstallCommand(linters ...string) []string {\n\tcmd := []string{\"get\"}\n\tif config.VendoredLinters {\n\t\tcmd = []string{\"install\"}\n\t} else {\n\t\tif config.Update {\n\t\t\tcmd = append(cmd, \"-u\")\n\t\t}\n\t\tif config.Force {\n\t\t\tcmd = append(cmd, \"-f\")\n\t\t}\n\t\tif config.DownloadOnly {\n\t\t\tcmd = append(cmd, \"-d\")\n\t\t}\n\t}\n\tif config.Debug {\n\t\tcmd = append(cmd, \"-v\")\n\t}\n\tcmd = append(cmd, linters...)\n\treturn cmd\n}\n\nfunc installLintersWithOneCommand(targets []string) error {\n\tcmd := makeInstallCommand(targets...)\n\tdebug(\"go %s\", strings.Join(cmd, \" \"))\n\tc := exec.Command(\"go\", cmd...) // nolint: gosec\n\tc.Stdout = os.Stdout\n\tc.Stderr = os.Stderr\n\treturn c.Run()\n}\n\nfunc installLintersIndividually(targets []string) {\n\tfailed := []string{}\n\tfor _, target := range targets {\n\t\tcmd := makeInstallCommand(target)\n\t\tdebug(\"go %s\", strings.Join(cmd, \" \"))\n\t\tc := exec.Command(\"go\", cmd...) // nolint: gosec\n\t\tc.Stdout = os.Stdout\n\t\tc.Stderr = os.Stderr\n\t\tif err := c.Run(); err != nil {\n\t\t\twarning(\"failed to install %s: %s\", target, err)\n\t\t\tfailed = append(failed, target)\n\t\t}\n\t}\n\tif len(failed) > 0 {\n\t\tkingpin.Fatalf(\"failed to install the following linters: %s\", strings.Join(failed, \", \"))\n\t}\n}\n\nfunc installLinters() {\n\tnames := make([]string, 0, len(defaultLinters))\n\ttargets := make([]string, 0, len(defaultLinters))\n\tfor name, config := range defaultLinters {\n\t\tif config.InstallFrom == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tnames = append(names, name)\n\t\ttargets = append(targets, config.InstallFrom)\n\t}\n\tsort.Strings(names)\n\tnamesStr := strings.Join(names, \"\\n  \")\n\tif config.DownloadOnly {\n\t\tfmt.Printf(\"Downloading:\\n  %s\\n\", namesStr)\n\t} else {\n\t\tfmt.Printf(\"Installing:\\n  %s\\n\", namesStr)\n\t}\n\terr := installLintersWithOneCommand(targets)\n\tif err == nil {\n\t\treturn\n\t}\n\twarning(\"failed to install one or more linters: %s (installing individually)\", err)\n\tinstallLintersIndividually(targets)\n}\n\nfunc getDefaultLinters() []*Linter {\n\tout := []*Linter{}\n\tfor name, config := range defaultLinters {\n\t\tlinter, err := NewLinter(name, config)\n\t\tkingpin.FatalIfError(err, \"invalid linter %q\", name)\n\t\tout = append(out, linter)\n\t}\n\treturn out\n}\n\nfunc defaultEnabled() []string {\n\tenabled := []string{}\n\tfor name, config := range defaultLinters {\n\t\tif config.defaultEnabled {\n\t\t\tenabled = append(enabled, name)\n\t\t}\n\t}\n\treturn enabled\n}\n\nfunc validateLinters(linters map[string]*Linter, config *Config) error {\n\tvar unknownLinters []string\n\tfor name := range linters {\n\t\tif _, isDefault := defaultLinters[name]; !isDefault {\n\t\t\tif _, isCustom := config.Linters[name]; !isCustom {\n\t\t\t\tunknownLinters = append(unknownLinters, name)\n\t\t\t}\n\t\t}\n\t}\n\tif len(unknownLinters) > 0 {\n\t\treturn fmt.Errorf(\"unknown linters: %s\", strings.Join(unknownLinters, \", \"))\n\t}\n\treturn nil\n}\n\nconst vetPattern = `^(?:vet:.*?\\.go:\\s+(?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.*))|((?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.*))|(?:(?P<path>.*?\\.go):(?P<line>\\d+):\\s*(?P<message>.*))$`\n\nvar defaultLinters = map[string]LinterConfig{\n\t\"maligned\": {\n\t\tCommand:           \"maligned\",\n\t\tPattern:           `^(?:[^:]+: )?(?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.+)$`,\n\t\tInstallFrom:       \"github.com/mdempsky/maligned\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"deadcode\": {\n\t\tCommand:           \"deadcode\",\n\t\tPattern:           `^deadcode: (?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.*)$`,\n\t\tInstallFrom:       \"github.com/tsenart/deadcode\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"dupl\": {\n\t\tCommand:           `dupl -plumbing -threshold {duplthreshold}`,\n\t\tPattern:           `^(?P<path>.*?\\.go):(?P<line>\\d+)-\\d+:\\s*(?P<message>.*)$`,\n\t\tInstallFrom:       \"github.com/mibk/dupl\",\n\t\tPartitionStrategy: partitionPathsAsFiles,\n\t\tIsFast:            true,\n\t},\n\t\"errcheck\": {\n\t\tCommand:           `errcheck -abspath {not_tests=-ignoretests}`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"github.com/kisielk/errcheck\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"gosec\": {\n\t\tCommand:           `gosec -fmt=csv`,\n\t\tPattern:           `^(?P<path>.*?\\.go),(?P<line>\\d+)(-\\d+)?,(?P<message>[^,]+,[^,]+,[^,]+)`,\n\t\tInstallFrom:       \"github.com/securego/gosec/cmd/gosec\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"gochecknoinits\": {\n\t\tCommand:           `gochecknoinits`,\n\t\tPattern:           `^(?P<path>.*?\\.go):(?P<line>\\d+) (?P<message>.*)`,\n\t\tInstallFrom:       \"4d63.com/gochecknoinits\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    false,\n\t\tIsFast:            true,\n\t},\n\t\"gochecknoglobals\": {\n\t\tCommand:           `gochecknoglobals`,\n\t\tPattern:           `^(?P<path>.*?\\.go):(?P<line>\\d+) (?P<message>.*)`,\n\t\tInstallFrom:       \"4d63.com/gochecknoglobals\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    false,\n\t\tIsFast:            true,\n\t},\n\t\"goconst\": {\n\t\tCommand:           `goconst -min-occurrences {min_occurrences} -min-length {min_const_length}`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"github.com/jgautheron/goconst/cmd/goconst\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"gocyclo\": {\n\t\tCommand:           `gocyclo -over {mincyclo}`,\n\t\tPattern:           `^(?P<cyclo>\\d+)\\s+\\S+\\s(?P<function>\\S+)\\s+(?P<path>.*?\\.go):(?P<line>\\d+):(\\d+)$`,\n\t\tInstallFrom:       \"github.com/alecthomas/gocyclo\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"gofmt\": {\n\t\tCommand:           `gofmt -l -s`,\n\t\tPattern:           `^(?P<path>.*?\\.go)$`,\n\t\tPartitionStrategy: partitionPathsAsFiles,\n\t\tIsFast:            true,\n\t},\n\t\"goimports\": {\n\t\tCommand:           `goimports -l`,\n\t\tPattern:           `^(?P<path>.*?\\.go)$`,\n\t\tInstallFrom:       \"golang.org/x/tools/cmd/goimports\",\n\t\tPartitionStrategy: partitionPathsAsFiles,\n\t\tIsFast:            true,\n\t},\n\t\"golint\": {\n\t\tCommand:           `golint -min_confidence {min_confidence}`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"github.com/golang/lint/golint\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"gotype\": {\n\t\tCommand:           `gotype -e {tests=-t}`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"golang.org/x/tools/cmd/gotype\",\n\t\tPartitionStrategy: partitionPathsByDirectory,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"gotypex\": {\n\t\tCommand:           `gotype -e -x`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"golang.org/x/tools/cmd/gotype\",\n\t\tPartitionStrategy: partitionPathsByDirectory,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"ineffassign\": {\n\t\tCommand:           `ineffassign -n`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"github.com/gordonklaus/ineffassign\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"interfacer\": {\n\t\tCommand:           `interfacer`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"mvdan.cc/interfacer\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"lll\": {\n\t\tCommand:           `lll -g -l {maxlinelength}`,\n\t\tPattern:           `PATH:LINE:MESSAGE`,\n\t\tInstallFrom:       \"github.com/walle/lll/cmd/lll\",\n\t\tPartitionStrategy: partitionPathsAsFiles,\n\t\tIsFast:            true,\n\t},\n\t\"misspell\": {\n\t\tCommand:           `misspell -j 1 --locale \"{misspelllocale}\"`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"github.com/client9/misspell/cmd/misspell\",\n\t\tPartitionStrategy: partitionPathsAsFiles,\n\t\tIsFast:            true,\n\t},\n\t\"nakedret\": {\n\t\tCommand:           `nakedret`,\n\t\tPattern:           `^(?P<path>.*?\\.go):(?P<line>\\d+)\\s*(?P<message>.*)$`,\n\t\tInstallFrom:       \"github.com/alexkohler/nakedret\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t},\n\t\"safesql\": {\n\t\tCommand:           `safesql`,\n\t\tPattern:           `^- (?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+)$`,\n\t\tInstallFrom:       \"github.com/stripe/safesql\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t},\n\t\"staticcheck\": {\n\t\tCommand:           `staticcheck`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"honnef.co/go/tools/cmd/staticcheck\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled: true,\n\t},\n\t\"structcheck\": {\n\t\tCommand:           `structcheck {tests=-t}`,\n\t\tPattern:           `^(?:[^:]+: )?(?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.+)$`,\n\t\tInstallFrom:       \"github.com/opennota/check/cmd/structcheck\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"test\": {\n\t\tCommand:           `go test`,\n\t\tPattern:           `(?m:^\\t(?P<path>.*?\\.go):(?P<line>\\d+): (?P<message>.+)$)`,\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t},\n\t\"testify\": {\n\t\tCommand:           `go test`,\n\t\tPattern:           `(?m:^\\s+Error Trace:\\s+(?P<path>.+?.go):(?P<line>\\d+)\\n\\s+Error:\\s+(?P<message>.+?)[:\\s]*$)`,\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t},\n\t\"unconvert\": {\n\t\tCommand:           `unconvert`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"github.com/mdempsky/unconvert\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"unparam\": {\n\t\tCommand:           `unparam {not_tests=-tests=false}`,\n\t\tPattern:           `PATH:LINE:COL:MESSAGE`,\n\t\tInstallFrom:       \"mvdan.cc/unparam\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t},\n\t\"varcheck\": {\n\t\tCommand:           `varcheck`,\n\t\tPattern:           `^(?:[^:]+: )?(?P<path>.*?\\.go):(?P<line>\\d+):(?P<col>\\d+):\\s*(?P<message>.*)$`,\n\t\tInstallFrom:       \"github.com/opennota/check/cmd/varcheck\",\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t},\n\t\"vet\": {\n\t\tCommand:           `go vet`,\n\t\tPattern:           vetPattern,\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n\t\"vetshadow\": {\n\t\tCommand:           `go vet --shadow`,\n\t\tPattern:           vetPattern,\n\t\tPartitionStrategy: partitionPathsAsPackages,\n\t\tdefaultEnabled:    true,\n\t\tIsFast:            true,\n\t},\n}\n"
        },
        {
          "name": "linters_test.go",
          "type": "blob",
          "size": 5.111328125,
          "content": "package main\n\nimport (\n\t\"reflect\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestNewLinterWithCustomLinter(t *testing.T) {\n\tconfig := LinterConfig{\n\t\tCommand: \"/usr/bin/custom\",\n\t\tPattern: \"path\",\n\t}\n\tlinter, err := NewLinter(\"thename\", config)\n\trequire.NoError(t, err)\n\tassert.Equal(t, functionName(partitionPathsAsDirectories), functionName(linter.LinterConfig.PartitionStrategy))\n\tassert.Equal(t, \"(?m:path)\", linter.regex.String())\n\tassert.Equal(t, \"thename\", linter.Name)\n\tassert.Equal(t, config.Command, linter.Command)\n}\n\nfunc TestGetLinterByName(t *testing.T) {\n\tconfig := LinterConfig{\n\t\tCommand:           \"maligned\",\n\t\tPattern:           \"path\",\n\t\tInstallFrom:       \"./install/path\",\n\t\tPartitionStrategy: partitionPathsAsDirectories,\n\t\tIsFast:            true,\n\t}\n\toverrideConfig := getLinterByName(config.Command, config)\n\tassert.Equal(t, config.Command, overrideConfig.Command)\n\tassert.Equal(t, config.Pattern, overrideConfig.Pattern)\n\tassert.Equal(t, config.InstallFrom, overrideConfig.InstallFrom)\n\tassert.Equal(t, functionName(config.PartitionStrategy), functionName(overrideConfig.PartitionStrategy))\n\tassert.Equal(t, config.IsFast, overrideConfig.IsFast)\n}\n\nfunc TestValidateLinters(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\tconfig = &Config{\n\t\tEnable: []string{\"_dummylinter_\"},\n\t}\n\n\terr := validateLinters(lintersFromConfig(config), config)\n\trequire.Error(t, err, \"expected unknown linter error for _dummylinter_\")\n\n\tconfig = &Config{\n\t\tEnable: defaultEnabled(),\n\t}\n\terr = validateLinters(lintersFromConfig(config), config)\n\trequire.NoError(t, err)\n}\n\nfunc TestLinter_test(t *testing.T) {\n\texampleOutput := `--- FAIL: TestHello (0.00s)\n\tother_test.go:11: \n\t\t\tError Trace:\tother_test.go:11\n\t\t\tError:      \tNot equal: \n\t\t\t            \texpected: \"This is not\"\n\t\t\t            \tactual  : \"equal to this\"\n\t\t\t            \t\n\t\t\t            \tDiff:\n\t\t\t            \t--- Expected\n\t\t\t            \t+++ Actual\n\t\t\t            \t@@ -1 +1 @@\n\t\t\t            \t-This is not\n\t\t\t            \t+equal to this\n\t\t\tTest:       \tTestHello\n\tother_test.go:12: this should fail\n\tother_test.go:13: fail again\n\tother_test.go:14: last fail\n\tother_test.go:15:   \n\tother_test.go:16: \n\trequire.go:1159: \n\t\t\tError Trace:\tother_test.go:17\n\t\t\tError:      \tShould be true\n\t\t\tTest:       \tTestHello\nFAIL\nFAIL\ttest\t0.003s`\n\n\tpattern := regexp.MustCompile(defaultLinters[\"test\"].Pattern)\n\tmatches := pattern.FindAllStringSubmatch(exampleOutput, -1)\n\tvar errors []map[string]string\n\tfor _, match := range matches {\n\t\tm := make(map[string]string)\n\t\tfor i, name := range pattern.SubexpNames() {\n\t\t\tif i != 0 && name != \"\" {\n\t\t\t\tm[name] = string(match[i])\n\t\t\t}\n\t\t}\n\t\terrors = append(errors, m)\n\t}\n\n\t// Assert expected errors\n\tassert.Equal(t, \"other_test.go\", errors[0][\"path\"])\n\tassert.Equal(t, \"12\", errors[0][\"line\"])\n\tassert.Equal(t, \"this should fail\", errors[0][\"message\"])\n\n\tassert.Equal(t, \"other_test.go\", errors[1][\"path\"])\n\tassert.Equal(t, \"13\", errors[1][\"line\"])\n\tassert.Equal(t, \"fail again\", errors[1][\"message\"])\n\n\tassert.Equal(t, \"other_test.go\", errors[2][\"path\"])\n\tassert.Equal(t, \"14\", errors[2][\"line\"])\n\tassert.Equal(t, \"last fail\", errors[2][\"message\"])\n\n\tassert.Equal(t, \"other_test.go\", errors[3][\"path\"])\n\tassert.Equal(t, \"15\", errors[3][\"line\"])\n\tassert.Equal(t, \"  \", errors[3][\"message\"])\n\n\t// Go metalinter does not support errors without a message as there is little or no output to parse\n\t// E.g. t.Fail() or t.Error(\"\")\n\t//  assert.Equal(t, \"other_test.go\", errors[5][\"path\"])\n\t//\tassert.Equal(t, \"15\", errors[5][\"line\"])\n\t//\tassert.Equal(t, \"\", errors[5][\"message\"])\n}\n\nfunc TestLinter_testify(t *testing.T) {\n\texampleOutput := `--- FAIL: TestHello (0.00s)\n\tother_test.go:11: \n\t\t\tError Trace:\tother_test.go:11\n\t\t\tError:      \tNot equal: \n\t\t\t            \texpected: \"This is not\"\n\t\t\t            \tactual  : \"equal to this\"\n\t\t\t            \t\n\t\t\t            \tDiff:\n\t\t\t            \t--- Expected\n\t\t\t            \t+++ Actual\n\t\t\t            \t@@ -1 +1 @@\n\t\t\t            \t-This is not\n\t\t\t            \t+equal to this\n\t\t\tTest:       \tTestHello\n\tother_test.go:12: this should fail\n\tother_test.go:13: fail again\n\tother_test.go:14: last fail\n\tother_test.go:15:   \n\tother_test.go:16: \n\trequire.go:1159: \n\t\t\tError Trace:\tother_test.go:17\n\t\t\tError:      \tShould be true\n\t\t\tTest:       \tTestHello\nFAIL\nFAIL\ttest\t0.003s`\n\n\tpattern := regexp.MustCompile(defaultLinters[\"testify\"].Pattern)\n\tmatches := pattern.FindAllStringSubmatch(exampleOutput, -1)\n\tvar errors []map[string]string\n\tfor _, match := range matches {\n\t\tm := make(map[string]string)\n\t\tfor i, name := range pattern.SubexpNames() {\n\t\t\tif i != 0 && name != \"\" {\n\t\t\t\tm[name] = string(match[i])\n\t\t\t}\n\t\t}\n\t\terrors = append(errors, m)\n\t}\n\n\t// Assert expected errors\n\tassert.Equal(t, \"other_test.go\", errors[0][\"path\"])\n\tassert.Equal(t, \"11\", errors[0][\"line\"])\n\tassert.Equal(t, \"Not equal\", errors[0][\"message\"])\n\n\tassert.Equal(t, \"other_test.go\", errors[1][\"path\"])\n\tassert.Equal(t, \"17\", errors[1][\"line\"])\n\tassert.Equal(t, \"Should be true\", errors[1][\"message\"])\n}\n\nfunc functionName(i interface{}) string {\n\treturn runtime.FuncForPC(reflect.ValueOf(i).Pointer()).Name()\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 16.470703125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"text/template\"\n\t\"time\"\n\n\tkingpin \"gopkg.in/alecthomas/kingpin.v3-unstable\"\n)\n\nvar (\n\t// Locations to look for vendored linters.\n\tvendoredSearchPaths = [][]string{\n\t\t{\"github.com\", \"alecthomas\", \"gometalinter\", \"_linters\"},\n\t\t{\"gopkg.in\", \"alecthomas\", \"gometalinter.v2\", \"_linters\"},\n\t}\n\tdefaultConfigPath = \".gometalinter.json\"\n\n\t// Populated by goreleaser.\n\tversion = \"master\"\n\tcommit  = \"?\"\n\tdate    = \"\"\n)\n\nfunc setupFlags(app *kingpin.Application) {\n\tapp.Flag(\"config\", \"Load JSON configuration from file.\").Envar(\"GOMETALINTER_CONFIG\").Action(loadConfig).String()\n\tapp.Flag(\"no-config\", \"Disable automatic loading of config file.\").Bool()\n\tapp.Flag(\"disable\", \"Disable previously enabled linters.\").PlaceHolder(\"LINTER\").Short('D').Action(disableAction).Strings()\n\tapp.Flag(\"enable\", \"Enable previously disabled linters.\").PlaceHolder(\"LINTER\").Short('E').Action(enableAction).Strings()\n\tapp.Flag(\"linter\", \"Define a linter.\").PlaceHolder(\"NAME:COMMAND:PATTERN\").Action(cliLinterOverrides).StringMap()\n\tapp.Flag(\"message-overrides\", \"Override message from linter. {message} will be expanded to the original message.\").PlaceHolder(\"LINTER:MESSAGE\").StringMapVar(&config.MessageOverride)\n\tapp.Flag(\"severity\", \"Map of linter severities.\").PlaceHolder(\"LINTER:SEVERITY\").StringMapVar(&config.Severity)\n\tapp.Flag(\"disable-all\", \"Disable all linters.\").Action(disableAllAction).Bool()\n\tapp.Flag(\"enable-all\", \"Enable all linters.\").Action(enableAllAction).Bool()\n\tapp.Flag(\"format\", \"Output format.\").PlaceHolder(config.Format).StringVar(&config.Format)\n\tapp.Flag(\"vendored-linters\", \"Use vendored linters (recommended) (DEPRECATED - use binary packages).\").BoolVar(&config.VendoredLinters)\n\tapp.Flag(\"fast\", \"Only run fast linters.\").BoolVar(&config.Fast)\n\tapp.Flag(\"install\", \"Attempt to install all known linters (DEPRECATED - use binary packages).\").Short('i').BoolVar(&config.Install)\n\tapp.Flag(\"update\", \"Pass -u to go tool when installing (DEPRECATED - use binary packages).\").Short('u').BoolVar(&config.Update)\n\tapp.Flag(\"force\", \"Pass -f to go tool when installing (DEPRECATED - use binary packages).\").Short('f').BoolVar(&config.Force)\n\tapp.Flag(\"download-only\", \"Pass -d to go tool when installing (DEPRECATED - use binary packages).\").BoolVar(&config.DownloadOnly)\n\tapp.Flag(\"debug\", \"Display messages for failed linters, etc.\").Short('d').BoolVar(&config.Debug)\n\tapp.Flag(\"concurrency\", \"Number of concurrent linters to run.\").PlaceHolder(fmt.Sprintf(\"%d\", runtime.NumCPU())).Short('j').IntVar(&config.Concurrency)\n\tapp.Flag(\"exclude\", \"Exclude messages matching these regular expressions.\").Short('e').PlaceHolder(\"REGEXP\").StringsVar(&config.Exclude)\n\tapp.Flag(\"include\", \"Include messages matching these regular expressions.\").Short('I').PlaceHolder(\"REGEXP\").StringsVar(&config.Include)\n\tapp.Flag(\"skip\", \"Skip directories with this name when expanding '...'.\").Short('s').PlaceHolder(\"DIR...\").StringsVar(&config.Skip)\n\tapp.Flag(\"vendor\", \"Enable vendoring support (skips 'vendor' directories and sets GO15VENDOREXPERIMENT=1).\").BoolVar(&config.Vendor)\n\tapp.Flag(\"cyclo-over\", \"Report functions with cyclomatic complexity over N (using gocyclo).\").PlaceHolder(\"10\").IntVar(&config.Cyclo)\n\tapp.Flag(\"line-length\", \"Report lines longer than N (using lll).\").PlaceHolder(\"80\").IntVar(&config.LineLength)\n\tapp.Flag(\"misspell-locale\", \"Specify locale to use (using misspell).\").PlaceHolder(\"\").StringVar(&config.MisspellLocale)\n\tapp.Flag(\"min-confidence\", \"Minimum confidence interval to pass to golint.\").PlaceHolder(\".80\").FloatVar(&config.MinConfidence)\n\tapp.Flag(\"min-occurrences\", \"Minimum occurrences to pass to goconst.\").PlaceHolder(\"3\").IntVar(&config.MinOccurrences)\n\tapp.Flag(\"min-const-length\", \"Minimum constant length.\").PlaceHolder(\"3\").IntVar(&config.MinConstLength)\n\tapp.Flag(\"dupl-threshold\", \"Minimum token sequence as a clone for dupl.\").PlaceHolder(\"50\").IntVar(&config.DuplThreshold)\n\tapp.Flag(\"sort\", fmt.Sprintf(\"Sort output by any of %s.\", strings.Join(sortKeys, \", \"))).PlaceHolder(\"none\").EnumsVar(&config.Sort, sortKeys...)\n\tapp.Flag(\"tests\", \"Include test files for linters that support this option.\").Short('t').BoolVar(&config.Test)\n\tapp.Flag(\"deadline\", \"Cancel linters if they have not completed within this duration.\").PlaceHolder(\"30s\").DurationVar((*time.Duration)(&config.Deadline))\n\tapp.Flag(\"errors\", \"Only show errors.\").BoolVar(&config.Errors)\n\tapp.Flag(\"json\", \"Generate structured JSON rather than standard line-based output.\").BoolVar(&config.JSON)\n\tapp.Flag(\"checkstyle\", \"Generate checkstyle XML rather than standard line-based output.\").BoolVar(&config.Checkstyle)\n\tapp.Flag(\"enable-gc\", \"Enable GC for linters (useful on large repositories).\").BoolVar(&config.EnableGC)\n\tapp.Flag(\"aggregate\", \"Aggregate issues reported by several linters.\").BoolVar(&config.Aggregate)\n\tapp.Flag(\"warn-unmatched-nolint\", \"Warn if a nolint directive is not matched with an issue.\").BoolVar(&config.WarnUnmatchedDirective)\n\tapp.GetFlag(\"help\").Short('h')\n}\n\nfunc cliLinterOverrides(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\t// expected input structure - <name>:<command-spec>\n\tparts := strings.SplitN(*element.Value, \":\", 2)\n\tif len(parts) < 2 {\n\t\treturn fmt.Errorf(\"incorrectly formatted input: %s\", *element.Value)\n\t}\n\tname := parts[0]\n\tspec := parts[1]\n\tconf, err := parseLinterConfigSpec(name, spec)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"incorrectly formatted input: %s\", *element.Value)\n\t}\n\tconfig.Linters[name] = StringOrLinterConfig(conf)\n\treturn nil\n}\n\nfunc loadDefaultConfig(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\tif element != nil {\n\t\treturn nil\n\t}\n\n\tfor _, elem := range ctx.Elements {\n\t\tif f := elem.OneOf.Flag; f == app.GetFlag(\"config\") || f == app.GetFlag(\"no-config\") {\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tconfigFile, found, err := findDefaultConfigFile()\n\tif err != nil || !found {\n\t\treturn err\n\t}\n\n\treturn loadConfigFile(configFile)\n}\n\nfunc loadConfig(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\treturn loadConfigFile(*element.Value)\n}\n\nfunc disableAction(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\tout := []string{}\n\tfor _, linter := range config.Enable {\n\t\tif linter != *element.Value {\n\t\t\tout = append(out, linter)\n\t\t}\n\t}\n\tconfig.Enable = out\n\treturn nil\n}\n\nfunc enableAction(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\tconfig.Enable = append(config.Enable, *element.Value)\n\treturn nil\n}\n\nfunc disableAllAction(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\tconfig.Enable = []string{}\n\treturn nil\n}\n\nfunc enableAllAction(app *kingpin.Application, element *kingpin.ParseElement, ctx *kingpin.ParseContext) error {\n\tfor linter := range defaultLinters {\n\t\tconfig.Enable = append(config.Enable, linter)\n\t}\n\tconfig.EnableAll = true\n\treturn nil\n}\n\ntype debugFunction func(format string, args ...interface{})\n\nfunc debug(format string, args ...interface{}) {\n\tif config.Debug {\n\t\tt := time.Now().UTC()\n\t\tfmt.Fprintf(os.Stderr, \"DEBUG: [%s] \", t.Format(time.StampMilli))\n\t\tfmt.Fprintf(os.Stderr, format+\"\\n\", args...)\n\t}\n}\n\nfunc namespacedDebug(prefix string) debugFunction {\n\treturn func(format string, args ...interface{}) {\n\t\tdebug(prefix+format, args...)\n\t}\n}\n\nfunc warning(format string, args ...interface{}) {\n\tfmt.Fprintf(os.Stderr, \"WARNING: \"+format+\"\\n\", args...)\n}\n\nfunc formatLinters() string {\n\tnameToLinter := map[string]*Linter{}\n\tvar linterNames []string\n\tfor _, linter := range getDefaultLinters() {\n\t\tlinterNames = append(linterNames, linter.Name)\n\t\tnameToLinter[linter.Name] = linter\n\t}\n\tsort.Strings(linterNames)\n\n\tw := bytes.NewBuffer(nil)\n\tfor _, linterName := range linterNames {\n\t\tlinter := nameToLinter[linterName]\n\n\t\tinstall := \"(\" + linter.InstallFrom + \")\"\n\t\tif install == \"()\" {\n\t\t\tinstall = \"\"\n\t\t}\n\t\tfmt.Fprintf(w, \"  %s: %s\\n\\tcommand: %s\\n\\tregex: %s\\n\\tfast: %t\\n\\tdefault enabled: %t\\n\\n\",\n\t\t\tlinter.Name, install, linter.Command, linter.Pattern, linter.IsFast, linter.defaultEnabled)\n\t}\n\treturn w.String()\n}\n\nfunc formatSeverity() string {\n\tw := bytes.NewBuffer(nil)\n\tfor name, severity := range config.Severity {\n\t\tfmt.Fprintf(w, \"  %s -> %s\\n\", name, severity)\n\t}\n\treturn w.String()\n}\n\nfunc main() {\n\tkingpin.Version(fmt.Sprintf(\"gometalinter version %s built from %s on %s\", version, commit, date))\n\tpathsArg := kingpin.Arg(\"path\", \"Directories to lint. Defaults to \\\".\\\". <path>/... will recurse.\").Strings()\n\tapp := kingpin.CommandLine\n\tapp.Action(loadDefaultConfig)\n\tsetupFlags(app)\n\tapp.Help = fmt.Sprintf(`Aggregate and normalise the output of a whole bunch of Go linters.\n\nPlaceHolder linters:\n\n%s\n\nSeverity override map (default is \"warning\"):\n\n%s\n`, formatLinters(), formatSeverity())\n\tkingpin.Parse()\n\n\tif config.Install {\n\t\tif config.VendoredLinters {\n\t\t\tconfigureEnvironmentForInstall()\n\t\t}\n\t\tinstallLinters()\n\t\treturn\n\t}\n\n\tconfigureEnvironment()\n\tinclude, exclude := processConfig(config)\n\n\tstart := time.Now()\n\tpaths := resolvePaths(*pathsArg, config.Skip)\n\n\tlinters := lintersFromConfig(config)\n\terr := validateLinters(linters, config)\n\tkingpin.FatalIfError(err, \"\")\n\n\tissues, errch := runLinters(linters, paths, config.Concurrency, exclude, include)\n\tstatus := 0\n\tif config.JSON {\n\t\tstatus |= outputToJSON(issues)\n\t} else if config.Checkstyle {\n\t\tstatus |= outputToCheckstyle(issues)\n\t} else {\n\t\tstatus |= outputToConsole(issues)\n\t}\n\tfor err := range errch {\n\t\twarning(\"%s\", err)\n\t\tstatus |= 2\n\t}\n\telapsed := time.Since(start)\n\tdebug(\"total elapsed time %s\", elapsed)\n\tos.Exit(status)\n}\n\n// nolint: gocyclo\nfunc processConfig(config *Config) (include *regexp.Regexp, exclude *regexp.Regexp) {\n\ttmpl, err := template.New(\"output\").Parse(config.Format)\n\tkingpin.FatalIfError(err, \"invalid format %q\", config.Format)\n\tconfig.formatTemplate = tmpl\n\n\t// Ensure that gometalinter manages threads, not linters.\n\tos.Setenv(\"GOMAXPROCS\", \"1\")\n\t// Force sorting by path if checkstyle mode is selected\n\t// !jsonFlag check is required to handle:\n\t// \tgometalinter --json --checkstyle --sort=severity\n\tif config.Checkstyle && !config.JSON {\n\t\tconfig.Sort = []string{\"path\"}\n\t}\n\n\t// PlaceHolder to skipping \"vendor\" directory if GO15VENDOREXPERIMENT=1 is enabled.\n\t// TODO(alec): This will probably need to be enabled by default at a later time.\n\tif os.Getenv(\"GO15VENDOREXPERIMENT\") == \"1\" || config.Vendor {\n\t\tif err := os.Setenv(\"GO15VENDOREXPERIMENT\", \"1\"); err != nil {\n\t\t\twarning(\"setenv GO15VENDOREXPERIMENT: %s\", err)\n\t\t}\n\t\tconfig.Skip = append(config.Skip, \"vendor\")\n\t\tconfig.Vendor = true\n\t}\n\tif len(config.Exclude) > 0 {\n\t\texclude = regexp.MustCompile(strings.Join(config.Exclude, \"|\"))\n\t}\n\n\tif len(config.Include) > 0 {\n\t\tinclude = regexp.MustCompile(strings.Join(config.Include, \"|\"))\n\t}\n\n\truntime.GOMAXPROCS(config.Concurrency)\n\treturn include, exclude\n}\n\nfunc outputToConsole(issues chan *Issue) int {\n\tstatus := 0\n\tfor issue := range issues {\n\t\tif config.Errors && issue.Severity != Error {\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Println(issue.String())\n\t\tstatus = 1\n\t}\n\treturn status\n}\n\nfunc outputToJSON(issues chan *Issue) int {\n\tfmt.Println(\"[\")\n\tstatus := 0\n\tfor issue := range issues {\n\t\tif config.Errors && issue.Severity != Error {\n\t\t\tcontinue\n\t\t}\n\t\tif status != 0 {\n\t\t\tfmt.Printf(\",\\n\")\n\t\t}\n\t\td, err := json.Marshal(issue)\n\t\tkingpin.FatalIfError(err, \"\")\n\t\tfmt.Printf(\"  %s\", d)\n\t\tstatus = 1\n\t}\n\tfmt.Printf(\"\\n]\\n\")\n\treturn status\n}\n\nfunc resolvePaths(paths, skip []string) []string {\n\tif len(paths) == 0 {\n\t\treturn []string{\".\"}\n\t}\n\n\tskipPath := newPathFilter(skip)\n\tdirs := newStringSet()\n\tfor _, path := range paths {\n\t\tif strings.HasSuffix(path, \"/...\") {\n\t\t\troot := filepath.Dir(path)\n\t\t\tif lstat, err := os.Lstat(root); err == nil && (lstat.Mode()&os.ModeSymlink) != 0 {\n\t\t\t\t// if we have a symlink append os.PathSeparator to force a dereference of the symlink\n\t\t\t\t// to workaround bug in filepath.Walk that won't dereference a root path that\n\t\t\t\t// is a dir symlink\n\t\t\t\troot = root + string(os.PathSeparator)\n\t\t\t}\n\t\t\t_ = filepath.Walk(root, func(p string, i os.FileInfo, err error) error {\n\t\t\t\tif err != nil {\n\t\t\t\t\twarning(\"invalid path %q: %s\", p, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tskip := skipPath(p)\n\t\t\t\tswitch {\n\t\t\t\tcase i.IsDir() && skip:\n\t\t\t\t\treturn filepath.SkipDir\n\t\t\t\tcase !i.IsDir() && !skip && strings.HasSuffix(p, \".go\"):\n\t\t\t\t\tdirs.add(filepath.Clean(filepath.Dir(p)))\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t})\n\t\t} else {\n\t\t\tdirs.add(filepath.Clean(path))\n\t\t}\n\t}\n\tout := make([]string, 0, dirs.size())\n\tfor _, d := range dirs.asSlice() {\n\t\tout = append(out, relativePackagePath(d))\n\t}\n\tsort.Strings(out)\n\tfor _, d := range out {\n\t\tdebug(\"linting path %s\", d)\n\t}\n\treturn out\n}\n\nfunc newPathFilter(skip []string) func(string) bool {\n\tfilter := map[string]bool{}\n\tfor _, name := range skip {\n\t\tfilter[name] = true\n\t}\n\n\treturn func(path string) bool {\n\t\tbase := filepath.Base(path)\n\t\tif filter[base] || filter[path] {\n\t\t\treturn true\n\t\t}\n\t\treturn base != \".\" && base != \"..\" && strings.ContainsAny(base[0:1], \"_.\")\n\t}\n}\n\nfunc relativePackagePath(dir string) string {\n\tif filepath.IsAbs(dir) || strings.HasPrefix(dir, \".\") {\n\t\treturn dir\n\t}\n\t// package names must start with a ./\n\treturn \"./\" + dir\n}\n\nfunc lintersFromConfig(config *Config) map[string]*Linter {\n\tout := map[string]*Linter{}\n\tfor _, name := range config.Enable {\n\t\tlinter := getLinterByName(name, LinterConfig(config.Linters[name]))\n\t\tif config.Fast && !linter.IsFast {\n\t\t\tcontinue\n\t\t}\n\t\tout[name] = linter\n\t}\n\tfor _, linter := range config.Disable {\n\t\tdelete(out, linter)\n\t}\n\treturn out\n}\n\nfunc findVendoredLinters() string {\n\tgopaths := getGoPathList()\n\tfor _, home := range vendoredSearchPaths {\n\t\tfor _, p := range gopaths {\n\t\t\tjoined := append([]string{p, \"src\"}, home...)\n\t\t\tvendorRoot := filepath.Join(joined...)\n\t\t\tif _, err := os.Stat(vendorRoot); err == nil {\n\t\t\t\treturn vendorRoot\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\n// Go 1.8 compatible GOPATH.\nfunc getGoPath() string {\n\tpath := os.Getenv(\"GOPATH\")\n\tif path == \"\" {\n\t\tuser, err := user.Current()\n\t\tkingpin.FatalIfError(err, \"\")\n\t\tpath = filepath.Join(user.HomeDir, \"go\")\n\t}\n\treturn path\n}\n\nfunc getGoPathList() []string {\n\treturn strings.Split(getGoPath(), string(os.PathListSeparator))\n}\n\n// addPath appends path to paths if path does not already exist in paths. Returns\n// the new paths.\nfunc addPath(paths []string, path string) []string {\n\tfor _, existingpath := range paths {\n\t\tif path == existingpath {\n\t\t\treturn paths\n\t\t}\n\t}\n\treturn append(paths, path)\n}\n\n// configureEnvironment adds all `bin/` directories from $GOPATH to $PATH\nfunc configureEnvironment() {\n\tpaths := addGoBinsToPath(getGoPathList())\n\tsetEnv(\"PATH\", strings.Join(paths, string(os.PathListSeparator)))\n\tsetEnv(\"GOROOT\", discoverGoRoot())\n\tdebugPrintEnv()\n}\n\nfunc discoverGoRoot() string {\n\tgoroot := os.Getenv(\"GOROOT\")\n\tif goroot == \"\" {\n\t\toutput, err := exec.Command(\"go\", \"env\", \"GOROOT\").Output()\n\t\tkingpin.FatalIfError(err, \"could not find go binary\")\n\t\tgoroot = string(output)\n\t}\n\treturn strings.TrimSpace(goroot)\n}\n\nfunc addGoBinsToPath(gopaths []string) []string {\n\tpaths := strings.Split(os.Getenv(\"PATH\"), string(os.PathListSeparator))\n\tfor _, p := range gopaths {\n\t\tpaths = addPath(paths, filepath.Join(p, \"bin\"))\n\t}\n\tgobin := os.Getenv(\"GOBIN\")\n\tif gobin != \"\" {\n\t\tpaths = addPath(paths, gobin)\n\t}\n\treturn paths\n}\n\n// configureEnvironmentForInstall sets GOPATH and GOBIN so that vendored linters\n// can be installed\nfunc configureEnvironmentForInstall() {\n\tif config.Update {\n\t\twarning(`Linters are now vendored by default, --update ignored. The original\nbehaviour can be re-enabled with --no-vendored-linters.\n\nTo request an update for a vendored linter file an issue at:\nhttps://github.com/alecthomas/gometalinter/issues/new\n`)\n\t}\n\tgopaths := getGoPathList()\n\tvendorRoot := findVendoredLinters()\n\tif vendorRoot == \"\" {\n\t\tkingpin.Fatalf(\"could not find vendored linters in GOPATH=%q\", getGoPath())\n\t}\n\tdebug(\"found vendored linters at %s, updating environment\", vendorRoot)\n\n\tgobin := os.Getenv(\"GOBIN\")\n\tif gobin == \"\" {\n\t\tgobin = filepath.Join(gopaths[0], \"bin\")\n\t}\n\tsetEnv(\"GOBIN\", gobin)\n\n\t// \"go install\" panics when one GOPATH element is beneath another, so set\n\t// GOPATH to the vendor root\n\tsetEnv(\"GOPATH\", vendorRoot)\n\tdebugPrintEnv()\n}\n\nfunc setEnv(key, value string) {\n\tif err := os.Setenv(key, value); err != nil {\n\t\twarning(\"setenv %s: %s\", key, err)\n\t} else {\n\t\tdebug(\"setenv %s=%q\", key, value)\n\t}\n}\n\nfunc debugPrintEnv() {\n\tdebug(\"Current environment:\")\n\tdebug(\"PATH=%q\", os.Getenv(\"PATH\"))\n\tdebug(\"GOPATH=%q\", os.Getenv(\"GOPATH\"))\n\tdebug(\"GOBIN=%q\", os.Getenv(\"GOBIN\"))\n\tdebug(\"GOROOT=%q\", os.Getenv(\"GOROOT\"))\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 7.90625,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"gopkg.in/alecthomas/kingpin.v3-unstable\"\n)\n\nfunc TestRelativePackagePath(t *testing.T) {\n\tvar testcases = []struct {\n\t\tdir      string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tdir:      \"/abs/path\",\n\t\t\texpected: \"/abs/path\",\n\t\t},\n\t\t{\n\t\t\tdir:      \".\",\n\t\t\texpected: \".\",\n\t\t},\n\t\t{\n\t\t\tdir:      \"./foo\",\n\t\t\texpected: \"./foo\",\n\t\t},\n\t\t{\n\t\t\tdir:      \"relative/path\",\n\t\t\texpected: \"./relative/path\",\n\t\t},\n\t}\n\n\tfor _, testcase := range testcases {\n\t\tassert.Equal(t, testcase.expected, relativePackagePath(testcase.dir))\n\t}\n}\n\nfunc TestResolvePathsNoPaths(t *testing.T) {\n\tpaths := resolvePaths(nil, nil)\n\tassert.Equal(t, []string{\".\"}, paths)\n}\n\nfunc TestResolvePathsNoExpands(t *testing.T) {\n\t// Non-expanded paths should not be filtered by the skip path list\n\tpaths := resolvePaths([]string{\".\", \"foo\", \"foo/bar\"}, []string{\"foo/bar\"})\n\texpected := []string{\".\", \"./foo\", \"./foo/bar\"}\n\tassert.Equal(t, expected, paths)\n}\n\nfunc TestResolvePathsWithExpands(t *testing.T) {\n\ttmpdir, cleanup := setupTempDir(t)\n\tdefer cleanup()\n\n\tmkGoFile(t, tmpdir, \"file.go\")\n\tmkDir(t, tmpdir, \"exclude\")\n\tmkDir(t, tmpdir, \"other\", \"exclude\")\n\tmkDir(t, tmpdir, \"include\")\n\tmkDir(t, tmpdir, \"include\", \"foo\")\n\tmkDir(t, tmpdir, \"duplicate\")\n\tmkDir(t, tmpdir, \".exclude\")\n\tmkDir(t, tmpdir, \"include\", \".exclude\")\n\tmkDir(t, tmpdir, \"_exclude\")\n\tmkDir(t, tmpdir, \"include\", \"_exclude\")\n\n\tfilterPaths := []string{\"exclude\", \"other/exclude\"}\n\tpaths := resolvePaths([]string{\"./...\", \"foo\", \"duplicate\"}, filterPaths)\n\n\texpected := []string{\n\t\t\".\",\n\t\t\"./duplicate\",\n\t\t\"./foo\",\n\t\t\"./include\",\n\t\t\"./include/foo\",\n\t}\n\tassert.Equal(t, expected, paths)\n}\n\nfunc setupTempDir(t *testing.T) (string, func()) {\n\ttmpdir, err := ioutil.TempDir(\"\", \"test-expand-paths\")\n\trequire.NoError(t, err)\n\n\ttmpdir, err = filepath.EvalSymlinks(tmpdir)\n\trequire.NoError(t, err)\n\n\toldwd, err := os.Getwd()\n\trequire.NoError(t, err)\n\trequire.NoError(t, os.Chdir(tmpdir))\n\n\treturn tmpdir, func() {\n\t\tos.RemoveAll(tmpdir)\n\t\trequire.NoError(t, os.Chdir(oldwd))\n\t}\n}\n\nfunc mkDir(t *testing.T, paths ...string) {\n\tfullPath := filepath.Join(paths...)\n\trequire.NoError(t, os.MkdirAll(fullPath, 0755))\n\tmkGoFile(t, fullPath, \"file.go\")\n}\n\nfunc mkFile(t *testing.T, path string, filename string, content string) {\n\terr := ioutil.WriteFile(filepath.Join(path, filename), []byte(content), 0644)\n\trequire.NoError(t, err)\n}\n\nfunc mkGoFile(t *testing.T, path string, filename string) {\n\tmkFile(t, path, filename, \"package foo\")\n}\n\nfunc TestPathFilter(t *testing.T) {\n\tskip := []string{\"exclude\", \"skip.go\"}\n\tpathFilter := newPathFilter(skip)\n\n\tvar testcases = []struct {\n\t\tpath     string\n\t\texpected bool\n\t}{\n\t\t{path: \"exclude\", expected: true},\n\t\t{path: \"something/skip.go\", expected: true},\n\t\t{path: \"skip.go\", expected: true},\n\t\t{path: \".git\", expected: true},\n\t\t{path: \"_ignore\", expected: true},\n\t\t{path: \"include.go\", expected: false},\n\t\t{path: \".\", expected: false},\n\t\t{path: \"..\", expected: false},\n\t}\n\n\tfor _, testcase := range testcases {\n\t\tassert.Equal(t, testcase.expected, pathFilter(testcase.path), testcase.path)\n\t}\n}\n\nfunc TestLoadDefaultConfig(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpdir, cleanup := setupTempDir(t)\n\tdefer cleanup()\n\n\tmkFile(t, tmpdir, defaultConfigPath, `{\"Deadline\": \"3m\"}`)\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tapp.Action(loadDefaultConfig)\n\tsetupFlags(app)\n\n\t_, err := app.Parse([]string{})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 3*time.Minute, config.Deadline.Duration())\n}\n\nfunc TestNoConfigFlag(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpdir, cleanup := setupTempDir(t)\n\tdefer cleanup()\n\n\tmkFile(t, tmpdir, defaultConfigPath, `{\"Deadline\": \"3m\"}`)\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tapp.Action(loadDefaultConfig)\n\tsetupFlags(app)\n\n\t_, err := app.Parse([]string{\"--no-config\"})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 30*time.Second, config.Deadline.Duration())\n}\n\nfunc TestConfigFlagSkipsDefault(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpdir, cleanup := setupTempDir(t)\n\tdefer cleanup()\n\n\tmkFile(t, tmpdir, defaultConfigPath, `{\"Deadline\": \"3m\"}`)\n\tmkFile(t, tmpdir, \"test-config\", `{\"Fast\": true}`)\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tapp.Action(loadDefaultConfig)\n\tsetupFlags(app)\n\n\t_, err := app.Parse([]string{\"--config\", filepath.Join(tmpdir, \"test-config\")})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 30*time.Second, config.Deadline.Duration())\n\trequire.Equal(t, true, config.Fast)\n}\n\nfunc TestLoadConfigWithDeadline(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpfile, err := ioutil.TempFile(\"\", \"test-config\")\n\trequire.NoError(t, err)\n\tdefer os.Remove(tmpfile.Name())\n\n\t_, err = tmpfile.Write([]byte(`{\"Deadline\": \"3m\"}`))\n\trequire.NoError(t, err)\n\trequire.NoError(t, tmpfile.Close())\n\n\tfilename := tmpfile.Name()\n\terr = loadConfig(nil, &kingpin.ParseElement{Value: &filename}, nil)\n\trequire.NoError(t, err)\n\n\trequire.Equal(t, 3*time.Minute, config.Deadline.Duration())\n}\n\nfunc TestDeadlineFlag(t *testing.T) {\n\tapp := kingpin.New(\"test-app\", \"\")\n\tsetupFlags(app)\n\t_, err := app.Parse([]string{\"--deadline\", \"2m\"})\n\trequire.NoError(t, err)\n\trequire.Equal(t, 2*time.Minute, config.Deadline.Duration())\n}\n\nfunc TestAddPath(t *testing.T) {\n\tpaths := []string{\"existing\"}\n\tassert.Equal(t, paths, addPath(paths, \"existing\"))\n\texpected := []string{\"existing\", \"new\"}\n\tassert.Equal(t, expected, addPath(paths, \"new\"))\n}\n\nfunc TestSetupFlagsLinterFlag(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tsetupFlags(app)\n\t_, err := app.Parse([]string{\"--linter\", \"a:b:c\"})\n\trequire.NoError(t, err)\n\tlinter, ok := config.Linters[\"a\"]\n\tassert.True(t, ok)\n\tassert.Equal(t, \"b\", linter.Command)\n\tassert.Equal(t, \"c\", linter.Pattern)\n}\n\nfunc TestSetupFlagsConfigWithLinterString(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpfile, err := ioutil.TempFile(\"\", \"test-config\")\n\trequire.NoError(t, err)\n\tdefer os.Remove(tmpfile.Name())\n\n\t_, err = tmpfile.Write([]byte(`{\"Linters\": {\"linter\": \"command:path\"} }`))\n\trequire.NoError(t, err)\n\trequire.NoError(t, tmpfile.Close())\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tsetupFlags(app)\n\n\t_, err = app.Parse([]string{\"--config\", tmpfile.Name()})\n\trequire.NoError(t, err)\n\tlinter, ok := config.Linters[\"linter\"]\n\tassert.True(t, ok)\n\tassert.Equal(t, \"command\", linter.Command)\n\tassert.Equal(t, \"path\", linter.Pattern)\n}\n\nfunc TestSetupFlagsConfigWithLinterMap(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpfile, err := ioutil.TempFile(\"\", \"test-config\")\n\trequire.NoError(t, err)\n\tdefer os.Remove(tmpfile.Name())\n\n\t_, err = tmpfile.Write([]byte(`{\"Linters\":\n\t\t{\"linter\":\n\t\t\t{ \"Command\": \"command\" }}}`))\n\trequire.NoError(t, err)\n\trequire.NoError(t, tmpfile.Close())\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tsetupFlags(app)\n\n\t_, err = app.Parse([]string{\"--config\", tmpfile.Name()})\n\trequire.NoError(t, err)\n\tlinter, ok := config.Linters[\"linter\"]\n\tassert.True(t, ok)\n\tassert.Equal(t, \"command\", linter.Command)\n\tassert.Equal(t, \"\", linter.Pattern)\n}\n\nfunc TestSetupFlagsConfigAndLinterFlag(t *testing.T) {\n\toriginalConfig := *config\n\tdefer func() { config = &originalConfig }()\n\n\ttmpfile, err := ioutil.TempFile(\"\", \"test-config\")\n\trequire.NoError(t, err)\n\tdefer os.Remove(tmpfile.Name())\n\n\t_, err = tmpfile.Write([]byte(`{\"Linters\":\n\t\t{\"linter\": { \"Command\": \"some-command\" }}}`))\n\trequire.NoError(t, err)\n\trequire.NoError(t, tmpfile.Close())\n\n\tapp := kingpin.New(\"test-app\", \"\")\n\tsetupFlags(app)\n\n\t_, err = app.Parse([]string{\n\t\t\"--config\", tmpfile.Name(),\n\t\t\"--linter\", \"linter:command:pattern\"})\n\trequire.NoError(t, err)\n\tlinter, ok := config.Linters[\"linter\"]\n\tassert.True(t, ok)\n\tassert.Equal(t, \"command\", linter.Command)\n\tassert.Equal(t, \"pattern\", linter.Pattern)\n}\n"
        },
        {
          "name": "partition.go",
          "type": "blob",
          "size": 3.708984375,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"path/filepath\"\n)\n\n// MaxCommandBytes is the maximum number of bytes used when executing a command\nconst MaxCommandBytes = 32000\n\ntype partitionStrategy func([]string, []string) ([][]string, error)\n\nfunc (ps *partitionStrategy) UnmarshalJSON(raw []byte) error {\n\tvar strategyName string\n\tif err := json.Unmarshal(raw, &strategyName); err != nil {\n\t\treturn err\n\t}\n\n\tswitch strategyName {\n\tcase \"directories\":\n\t\t*ps = partitionPathsAsDirectories\n\tcase \"files\":\n\t\t*ps = partitionPathsAsFiles\n\tcase \"packages\":\n\t\t*ps = partitionPathsAsPackages\n\tcase \"files-by-package\":\n\t\t*ps = partitionPathsAsFilesGroupedByPackage\n\tcase \"single-directory\":\n\t\t*ps = partitionPathsByDirectory\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown parition strategy %s\", strategyName)\n\t}\n\treturn nil\n}\n\nfunc pathsToFileGlobs(paths []string) ([]string, error) {\n\tfilePaths := []string{}\n\tfor _, dir := range paths {\n\t\tpaths, err := filepath.Glob(filepath.Join(dir, \"*.go\"))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfilePaths = append(filePaths, paths...)\n\t}\n\treturn filePaths, nil\n}\n\nfunc partitionPathsAsDirectories(cmdArgs []string, paths []string) ([][]string, error) {\n\treturn partitionToMaxSize(cmdArgs, paths, MaxCommandBytes), nil\n}\n\nfunc partitionToMaxSize(cmdArgs []string, paths []string, maxSize int) [][]string {\n\tpartitions := newSizePartitioner(cmdArgs, maxSize)\n\tfor _, path := range paths {\n\t\tpartitions.add(path)\n\t}\n\treturn partitions.end()\n}\n\ntype sizePartitioner struct {\n\tbase    []string\n\tparts   [][]string\n\tcurrent []string\n\tsize    int\n\tmax     int\n}\n\nfunc newSizePartitioner(base []string, max int) *sizePartitioner {\n\tp := &sizePartitioner{base: base, max: max}\n\tp.new()\n\treturn p\n}\n\nfunc (p *sizePartitioner) add(arg string) {\n\tif p.size+len(arg)+1 > p.max {\n\t\tp.new()\n\t}\n\tp.current = append(p.current, arg)\n\tp.size += len(arg) + 1\n}\n\nfunc (p *sizePartitioner) new() {\n\tp.end()\n\tp.size = 0\n\tp.current = []string{}\n\tfor _, arg := range p.base {\n\t\tp.add(arg)\n\t}\n}\n\nfunc (p *sizePartitioner) end() [][]string {\n\tif len(p.current) > 0 {\n\t\tp.parts = append(p.parts, p.current)\n\t}\n\treturn p.parts\n}\n\nfunc partitionPathsAsFiles(cmdArgs []string, paths []string) ([][]string, error) {\n\tfilePaths, err := pathsToFileGlobs(paths)\n\tif err != nil || len(filePaths) == 0 {\n\t\treturn nil, err\n\t}\n\treturn partitionPathsAsDirectories(cmdArgs, filePaths)\n}\n\nfunc partitionPathsAsFilesGroupedByPackage(cmdArgs []string, paths []string) ([][]string, error) {\n\tparts := [][]string{}\n\tfor _, path := range paths {\n\t\tfilePaths, err := pathsToFileGlobs([]string{path})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif len(filePaths) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tparts = append(parts, append(cmdArgs, filePaths...))\n\t}\n\treturn parts, nil\n}\n\nfunc partitionPathsAsPackages(cmdArgs []string, paths []string) ([][]string, error) {\n\tpackagePaths, err := pathsToPackagePaths(paths)\n\tif err != nil || len(packagePaths) == 0 {\n\t\treturn nil, err\n\t}\n\treturn partitionPathsAsDirectories(cmdArgs, packagePaths)\n}\n\nfunc pathsToPackagePaths(paths []string) ([]string, error) {\n\tpackages := []string{}\n\n\tfor _, path := range paths {\n\t\tpkg, err := packageNameFromPath(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpackages = append(packages, pkg)\n\t}\n\treturn packages, nil\n}\n\nfunc packageNameFromPath(path string) (string, error) {\n\tif !filepath.IsAbs(path) {\n\t\treturn path, nil\n\t}\n\tfor _, gopath := range getGoPathList() {\n\t\trel, err := filepath.Rel(filepath.Join(gopath, \"src\"), path)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn rel, nil\n\t}\n\treturn \"\", fmt.Errorf(\"%s not in GOPATH\", path)\n}\n\nfunc partitionPathsByDirectory(cmdArgs []string, paths []string) ([][]string, error) {\n\tparts := [][]string{}\n\tfor _, path := range paths {\n\t\tparts = append(parts, append(cmdArgs, path))\n\t}\n\treturn parts, nil\n}\n"
        },
        {
          "name": "partition_test.go",
          "type": "blob",
          "size": 3.029296875,
          "content": "package main\n\nimport (\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestPartitionToMaxSize(t *testing.T) {\n\tcmdArgs := []string{\"/usr/bin/foo\", \"-c\"}\n\tpaths := []string{\"one\", \"two\", \"three\", \"four\"}\n\n\tparts := partitionToMaxSize(cmdArgs, paths, 24)\n\texpected := [][]string{\n\t\tappend(cmdArgs, \"one\", \"two\"),\n\t\tappend(cmdArgs, \"three\"),\n\t\tappend(cmdArgs, \"four\"),\n\t}\n\tassert.Equal(t, expected, parts)\n}\n\nfunc TestPartitionToPackageFileGlobs(t *testing.T) {\n\ttmpdir, err := ioutil.TempDir(\"\", \"test-expand-paths\")\n\trequire.NoError(t, err)\n\tdefer os.RemoveAll(tmpdir)\n\n\tcmdArgs := []string{\"/usr/bin/foo\", \"-c\"}\n\tpaths := []string{\n\t\tfilepath.Join(tmpdir, \"one\"),\n\t\tfilepath.Join(tmpdir, \"two\"),\n\t}\n\tfor _, dir := range paths {\n\t\tmkDir(t, dir)\n\t\tmkGoFile(t, dir, \"other.go\")\n\t}\n\n\tparts, err := partitionPathsAsFilesGroupedByPackage(cmdArgs, paths)\n\trequire.NoError(t, err)\n\texpected := [][]string{\n\t\tappend(cmdArgs, packagePaths(paths[0], \"file.go\", \"other.go\")...),\n\t\tappend(cmdArgs, packagePaths(paths[1], \"file.go\", \"other.go\")...),\n\t}\n\tassert.Equal(t, expected, parts)\n}\n\nfunc packagePaths(dir string, filenames ...string) []string {\n\tpaths := []string{}\n\tfor _, filename := range filenames {\n\t\tpaths = append(paths, filepath.Join(dir, filename))\n\t}\n\treturn paths\n}\n\nfunc TestPartitionToPackageFileGlobsNoFiles(t *testing.T) {\n\ttmpdir, err := ioutil.TempDir(\"\", \"test-expand-paths\")\n\trequire.NoError(t, err)\n\tdefer os.RemoveAll(tmpdir)\n\n\tcmdArgs := []string{\"/usr/bin/foo\", \"-c\"}\n\tpaths := []string{filepath.Join(tmpdir, \"one\"), filepath.Join(tmpdir, \"two\")}\n\tparts, err := partitionPathsAsFilesGroupedByPackage(cmdArgs, paths)\n\trequire.NoError(t, err)\n\tassert.Len(t, parts, 0)\n}\n\nfunc TestPartitionToMaxArgSizeWithFileGlobsNoFiles(t *testing.T) {\n\ttmpdir, err := ioutil.TempDir(\"\", \"test-expand-paths\")\n\trequire.NoError(t, err)\n\tdefer os.RemoveAll(tmpdir)\n\n\tcmdArgs := []string{\"/usr/bin/foo\", \"-c\"}\n\tpaths := []string{filepath.Join(tmpdir, \"one\"), filepath.Join(tmpdir, \"two\")}\n\tparts, err := partitionPathsAsFiles(cmdArgs, paths)\n\trequire.NoError(t, err)\n\tassert.Len(t, parts, 0)\n}\n\nfunc TestPathsToPackagePaths(t *testing.T) {\n\troot := \"/fake/root\"\n\tdefer fakeGoPath(t, root)()\n\n\tpackagePaths, err := pathsToPackagePaths([]string{\n\t\tfilepath.Join(root, \"src\", \"example.com\", \"foo\"),\n\t\t\"./relative/package\",\n\t})\n\trequire.NoError(t, err)\n\texpected := []string{\"example.com/foo\", \"./relative/package\"}\n\tassert.Equal(t, expected, packagePaths)\n}\n\nfunc fakeGoPath(t *testing.T, path string) func() {\n\toldpath := os.Getenv(\"GOPATH\")\n\trequire.NoError(t, os.Setenv(\"GOPATH\", path))\n\treturn func() { require.NoError(t, os.Setenv(\"GOPATH\", oldpath)) }\n}\n\nfunc TestPartitionPathsByDirectory(t *testing.T) {\n\tcmdArgs := []string{\"/usr/bin/foo\", \"-c\"}\n\tpaths := []string{\"one\", \"two\", \"three\"}\n\n\tparts, err := partitionPathsByDirectory(cmdArgs, paths)\n\trequire.NoError(t, err)\n\texpected := [][]string{\n\t\tappend(cmdArgs, \"one\"),\n\t\tappend(cmdArgs, \"two\"),\n\t\tappend(cmdArgs, \"three\"),\n\t}\n\tassert.Equal(t, expected, parts)\n\n}\n"
        },
        {
          "name": "regressiontests",
          "type": "tree",
          "content": null
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "stringset.go",
          "type": "blob",
          "size": 0.5439453125,
          "content": "package main\n\ntype stringSet struct {\n\titems map[string]struct{}\n}\n\nfunc newStringSet(items ...string) *stringSet {\n\tsetItems := make(map[string]struct{}, len(items))\n\tfor _, item := range items {\n\t\tsetItems[item] = struct{}{}\n\t}\n\treturn &stringSet{items: setItems}\n}\n\nfunc (s *stringSet) add(item string) {\n\ts.items[item] = struct{}{}\n}\n\nfunc (s *stringSet) asSlice() []string {\n\titems := make([]string, 0, len(s.items))\n\tfor item := range s.items {\n\t\titems = append(items, item)\n\t}\n\treturn items\n}\n\nfunc (s *stringSet) size() int {\n\treturn len(s.items)\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}