{
  "metadata": {
    "timestamp": 1736566912860,
    "page": 484,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQ5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "valyala/quicktemplate",
      "stars": 3154,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0048828125,
          "content": "tags\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.328125,
          "content": "language: go\n\ngo:\n  - 1.11.x\n  - 1.12.x\n  - 1.13.x\n  - 1.14.x\n  - tip\n\nbefore_install:\n  - go get -u github.com/valyala/quicktemplate/qtc\n  - go generate\n\nscript:\n  # build test for supported platforms\n  - GOOS=linux go build\n  - GOOS=darwin go build\n  - GOOS=freebsd go build\n\n  # run tests on a standard platform\n  - go test -v ./...\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.07421875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Aliaksandr Valialkin, VertaMedia\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
        },
        {
          "name": "QuickTemplate.xml",
          "type": "blob",
          "size": 0.9052734375,
          "content": "<filetype binary=\"false\" description=\"QuickTemplate\" name=\"QuickTemplate\">\n    <highlighting>\n        <options>\n            <option name=\"LINE_COMMENT\" value=\"//\" />\n            <option name=\"COMMENT_START\" value=\"\" />\n            <option name=\"COMMENT_END\" value=\"\" />\n            <option name=\"HEX_PREFIX\" value=\"\" />\n            <option name=\"NUM_POSTFIXES\" value=\"\" />\n        </options>\n        <keywords keywords=\"case;cat;code;collapsespace;comment;default;else;elseif;endcollapsespace;endcomment;endfor;endfunc;endif;endplain;endstripspace;endswitch;for;func;if;import;interface;package;plain;space;stripspace;struct;switch;type\" ignore_case=\"false\" />\n        <keywords3 keywords=\"{%=;{%=h;{%=j;{%=jh;{%=q;{%=qh;{%=u;{%=uh;{%d;{%d=;{%f;{%f.;{%f.=;{%f=;{%j;{%j=;{%q;{%q=;{%s=;{%u;{%u=;{%uz;{%uz=;{%v;{%v=;{%z;{%z=\" />\n    </highlighting>\n    <extensionMap>\n        <mapping ext=\"qtpl\" />\n    </extensionMap>\n</filetype>"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.7578125,
          "content": "[![Build Status](https://travis-ci.org/valyala/quicktemplate.svg)](https://travis-ci.org/valyala/quicktemplate)\n[![GoDoc](https://godoc.org/github.com/valyala/quicktemplate?status.svg)](http://godoc.org/github.com/valyala/quicktemplate)\n[![Go Report Card](https://goreportcard.com/badge/github.com/valyala/quicktemplate)](https://goreportcard.com/report/github.com/valyala/quicktemplate)\n\n# quicktemplate\n\nA fast, powerful, yet easy to use template engine for Go.\nInspired by the [Mako templates](http://www.makotemplates.org/) philosophy.\n\n# Features\n\n  * [Extremely fast](#performance-comparison-with-htmltemplate).\n    Templates are converted into Go code and then compiled.\n  * Quicktemplate syntax is very close to Go - there is no need to learn\n    yet another template language before starting to use quicktemplate.\n  * Almost all bugs are caught during template compilation, so production\n    suffers less from template-related bugs.\n  * Easy to use. See [quickstart](#quick-start) and [examples](https://github.com/valyala/quicktemplate/tree/master/examples)\n    for details.\n  * Powerful. Arbitrary Go code may be embedded into and mixed with templates.\n    Be careful with this power - do not query the database and/or external resources from\n    templates unless you miss the PHP way in Go :) This power is mostly for\n    arbitrary data transformations.\n  * Easy to use template inheritance powered by [Go interfaces](https://golang.org/doc/effective_go.html#interfaces).\n    See [this example](https://github.com/valyala/quicktemplate/tree/master/examples/basicserver) for details.\n  * Templates are compiled into a single binary, so there is no need to copy\n    template files to the server.\n\n# Drawbacks\n\n  * Templates cannot be updated on the fly on the server, since they\n    are compiled into a single binary.\n    Take a look at [fasttemplate](https://github.com/valyala/fasttemplate)\n    if you need a fast template engine for simple dynamically updated templates.\n    [There are ways](https://www.reddit.com/r/golang/comments/f290ja/hot_reloading_with_quicktemplates_sqlc_and/) to dynamically update the templates during development.\n\n# Performance comparison with html/template\n\nQuicktemplate is more than 20x faster than [html/template](https://golang.org/pkg/html/template/).\nThe following simple template is used in the benchmark:\n\n  * [html/template version](https://github.com/valyala/quicktemplate/blob/master/testdata/templates/bench.tpl)\n  * [quicktemplate version](https://github.com/valyala/quicktemplate/blob/master/testdata/templates/bench.qtpl)\n\nBenchmark results:\n\n```\n$ go test -bench='Benchmark(Quick|HTML)Template' -benchmem github.com/valyala/quicktemplate/tests\nBenchmarkQuickTemplate1-4                 \t10000000\t       120 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkQuickTemplate10-4                \t 3000000\t       441 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkQuickTemplate100-4               \t  300000\t      3945 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkHTMLTemplate1-4                  \t  500000\t      2501 ns/op\t     752 B/op\t      23 allocs/op\nBenchmarkHTMLTemplate10-4                 \t  100000\t     12442 ns/op\t    3521 B/op\t     117 allocs/op\nBenchmarkHTMLTemplate100-4                \t   10000\t    123392 ns/op\t   34498 B/op\t    1152 allocs/op\n```\n\n[goTemplateBenchmark](https://github.com/SlinSo/goTemplateBenchmark) compares QuickTemplate with numerous Go templating packages. QuickTemplate performs favorably.\n\n# Security\n\n  * All template placeholders are HTML-escaped by default.\n  * Template placeholders for JSON strings prevent from `</script>`-based\n    XSS attacks:\n\n  ```qtpl\n  {% func FailedXSS() %}\n  <script>\n      var s = {%q= \"</script><script>alert('you pwned!')\" %};\n  </script>\n  {% endfunc %}\n  ```\n\n# Examples\n\nSee [examples](https://github.com/valyala/quicktemplate/tree/master/examples).\n\n# Quick start\n\nFirst of all, install the `quicktemplate` package\nand [quicktemplate compiler](https://github.com/valyala/quicktemplate/tree/master/qtc) (`qtc`):\n\n```\ngo get -u github.com/valyala/quicktemplate\ngo get -u github.com/valyala/quicktemplate/qtc\n```\n\nIf you using `go generate`, you just need put following into your `main.go`\n\nImportant: please specify your own folder (-dir) to generate template file\n\n```\n//go:generate go get -u github.com/valyala/quicktemplate/qtc\n//go:generate qtc -dir=app/views  \n```\n\nLet's start with a minimal template example:\n\n```qtpl\nAll text outside function templates is treated as comments,\ni.e. it is just ignored by quicktemplate compiler (`qtc`). It is for humans.\n\nHello is a simple template function.\n{% func Hello(name string) %}\n\tHello, {%s name %}!\n{% endfunc %}\n```\n\nSave this file into a `templates` folder under the name `hello.qtpl`\nand run `qtc` inside this folder.\n\nIf everything went OK, `hello.qtpl.go` file should appear in the `templates` folder.\nThis file contains Go code for `hello.qtpl`. Let's use it!\n\nCreate a file main.go outside `templates` folder and put the following\ncode there:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"./templates\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%s\\n\", templates.Hello(\"Foo\"))\n\tfmt.Printf(\"%s\\n\", templates.Hello(\"Bar\"))\n}\n```\n\nThen issue `go run`. If everything went OK, you'll see something like this:\n\n```\n\n\tHello, Foo!\n\n\n\tHello, Bar!\n\n```\n\nLet's create more a complex template which calls other template functions,\ncontains loops, conditions, breaks, continues and returns.\nPut the following template into `templates/greetings.qtpl`:\n\n```qtpl\n\nGreetings greets up to 42 names.\nIt also greets John differently comparing to others.\n{% func Greetings(names []string) %}\n\t{% if len(names) == 0 %}\n\t\tNobody to greet :(\n\t\t{% return %}\n\t{% endif %}\n\n\t{% for i, name := range names %}\n\t\t{% if i == 42 %}\n\t\t\tI'm tired to greet so many people...\n\t\t\t{% break %}\n\t\t{% elseif name == \"John\" %}\n\t\t\t{%= sayHi(\"Mr. \" + name) %}\n\t\t\t{% continue %}\n\t\t{% else %}\n\t\t\t{%= Hello(name) %}\n\t\t{% endif %}\n\t{% endfor %}\n{% endfunc %}\n\nsayHi is unexported, since it starts with lowercase letter.\n{% func sayHi(name string) %}\n\tHi, {%s name %}\n{% endfunc %}\n\nNote that every template file may contain an arbitrary number\nof template functions. For instance, this file contains Greetings and sayHi\nfunctions.\n```\n\nRun `qtc` inside `templates` folder. Now the folder should contain\ntwo files with Go code: `hello.qtpl.go` and `greetings.qtpl.go`. These files\nform a single `templates` Go package. Template functions and other template\nstuff is shared between template files located in the same folder.\nSo `Hello` template function may be used inside `greetings.qtpl` while\nit is defined in `hello.qtpl`.\nMoreover, the folder may contain ordinary Go files, so its contents may\nbe used inside templates and vice versa.\nThe package name inside template files may be overriden\nwith `{% package packageName %}`.\n\nNow put the following code into `main.go`:\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"./templates\"\n)\n\nfunc main() {\n\tnames := []string{\"Kate\", \"Go\", \"John\", \"Brad\"}\n\n\t// qtc creates Write* function for each template function.\n\t// Such functions accept io.Writer as first parameter:\n\tvar buf bytes.Buffer\n\ttemplates.WriteGreetings(&buf, names)\n\n\tfmt.Printf(\"buf=\\n%s\", buf.Bytes())\n}\n```\n\nCareful readers may notice different output tags were used in these\ntemplates: `{%s name %}` and `{%= Hello(name) %}`. What's the difference?\nThe `{%s x %}` is used for printing HTML-safe strings, while `{%= F() %}`\nis used for embedding template function calls. Quicktemplate supports also\nother output tags:\n\n  * `{%d int %}` and `{%dl int64 %}` `{%dul uint64 %}` for integers.\n  * `{%f float %}` for float64.\n    Floating point precision may be set via `{%f.precision float %}`.\n    For example, `{%f.2 1.2345 %}` outputs `1.23`.\n  * `{%z bytes %}` for byte slices.\n  * `{%q str %}` and `{%qz bytes %}` for JSON-compatible quoted strings.\n  * `{%j str %}` and `{%jz bytes %}` for embedding str into a JSON string. Unlike `{%q str %}`,\n    it doesn't quote the string.\n  * `{%u str %}` and `{%uz bytes %}` for [URL encoding](https://en.wikipedia.org/wiki/Percent-encoding)\n    the given str.\n  * `{%v anything %}` is equivalent to `%v` in [printf-like functions](https://golang.org/pkg/fmt/).\n\nAll the output tags except `{%= F() %}` produce HTML-safe output, i.e. they\nescape `<` to `&lt;`, `>` to `&gt;`, etc. If you don't want HTML-safe output,\nthen just put `=` after the tag. For example: `{%s= \"<h1>This h1 won't be escaped</h1>\" %}`.\n\nAs you may notice `{%= F() %}` and `{%s= F() %}` produce the same output for `{% func F() %}`.\nBut the first one is optimized for speed - it avoids memory allocations and copies.\nIt is therefore recommended to stick to it when embedding template function calls.\n\nAdditionally, the following extensions are supported for `{%= F() %}`:\n\n  * `{%=h F() %}` produces html-escaped output.\n  * `{%=u F() %}` produces [URL-encoded](https://en.wikipedia.org/wiki/Percent-encoding) output.\n  * `{%=q F() %}` produces quoted json string.\n  * `{%=j F() %}` produces json string without quotes.\n  * `{%=uh F() %}` produces html-safe URL-encoded output.\n  * `{%=qh F() %}` produces html-safe quoted json string.\n  * `{%=jh F() %}` produces html-safe json string without quotes.\n\nAll output tags except `{%= F() %}` family may contain arbitrary valid\nGo expressions instead of just an identifier. For example:\n\n```qtpl\nImport fmt for fmt.Sprintf()\n{% import \"fmt\" %}\n\nFmtFunc uses fmt.Sprintf() inside output tag\n{% func FmtFunc(s string) %}\n\t{%s fmt.Sprintf(\"FmtFunc accepted %q string\", s) %}\n{% endfunc %}\n```\n\nThere are other useful tags supported by quicktemplate:\n\n  * `{% comment %}`\n\n    ```qtpl\n    {% comment %}\n        This is a comment. It won't trap into the output.\n        It may contain {% arbitrary tags %}. They are just ignored.\n    {% endcomment %}\n    ```\n\n  * `{% plain %}`\n\n    ```qtpl\n    {% plain %}\n        Tags will {% trap into %} the output {% unmodified %}.\n        Plain block may contain invalid and {% incomplete tags.\n    {% endplain %}\n    ```\n\n  * `{% collapsespace %}`\n\n    ```qtpl\n    {% collapsespace %}\n        <div>\n            <div>space between lines</div>\n               and {%s \"tags\" %}\n             <div>is collapsed into a single space\n             unless{% newline %}or{% space %}is used</div>\n        </div>\n    {% endcollapsespace %}\n    ```\n\n    Is converted into:\n\n    ```\n    <div> <div>space between lines</div> and tags <div>is collapsed into a single space unless\n    or is used</div> </div>\n    ```\n\n  * `{% stripspace %}`\n\n    ```qtpl\n    {% stripspace %}\n         <div>\n             <div>space between lines</div>\n                and {%s \" tags\" %}\n             <div>is removed unless{% newline %}or{% space %}is used</div>\n         </div>\n    {% endstripspace %}\n    ```\n\n    Is converted into:\n\n    ```\n    <div><div>space between lines</div>and tags<div>is removed unless\n    or is used</div></div>\n    ```\n\n  * It is possible removing whitespace before and after the tag by adding `-` after `{%` or prepending `%}` with `-`. For example:\n\n    ```qtpl\n    var sum int\n    {%- for i := 1; i <= 3; i++ -%}\n    sum += {%d i %}\n    {%- endfor -%}\n    return sum\n    ```\n\n    Is converted into:\n    ```\n    var sum int\n    sum += 1\n    sum += 2\n    sum += 3\n    return sum\n    ```\n\n  * `{% switch %}`, `{% case %}` and `{% default %}`:\n\n\n    ```qtpl\n    1 + 1 =\n    {% switch 1+1 %}\n    {% case 2 %}\n\t2?\n    {% case 42 %}\n\t42!\n    {% default %}\n        I don't know :(\n    {% endswitch %}\n    ```\n\n  * `{% code %}`:\n\n    ```qtpl\n    {% code\n    // arbitrary Go code may be embedded here!\n    type FooArg struct {\n        Name string\n        Age int\n    }\n    %}\n    ```\n\n  * `{% package %}`:\n\n    ```qtpl\n    Override default package name with the custom name\n    {% package customPackageName %}\n    ```\n\n  * `{% import %}`:\n\n    ```qtpl\n    Import external packages.\n    {% import \"foo/bar\" %}\n    {% import (\n        \"foo\"\n        bar \"baz/baa\"\n    ) %}\n    ```\n\n  * `{% cat \"/path/to/file\" %}`:\n\n    ```qtpl\n    Cat emits the given file contents as a plaintext:\n    {% func passwords() %}\n        /etc/passwd contents:\n        {% cat \"/etc/passwd\" %}\n    {% endfunc %}\n    ```\n\n  * `{% interface %}`:\n\n    ```qtpl\n    Interfaces allow powerful templates' inheritance\n    {%\n    interface Page {\n        Title()\n        Body(s string, n int)\n        Footer()\n    }\n    %}\n\n    PrintPage prints Page\n    {% func PrintPage(p Page) %}\n        <html>\n            <head><title>{%= p.Title() %}</title></head>\n            <body>\n                <div>{%= p.Body(\"foo\", 42) %}</div>\n                <div>{%= p.Footer() %}</div>\n            </body>\n        </html>\n    {% endfunc %}\n\n    Base page implementation\n    {% code\n    type BasePage struct {\n        TitleStr string\n        FooterStr string\n    }\n    %}\n    {% func (bp *BasePage) Title() %}{%s bp.TitleStr %}{% endfunc %}\n    {% func (bp *BasePage) Body(s string, n int) %}\n        <b>s={%q s %}, n={%d n %}</b>\n    {% endfunc %}\n    {% func (bp *BasePage) Footer() %}{%s bp.FooterStr %}{% endfunc %}\n\n    Main page implementation\n    {% code\n    type MainPage struct {\n        // inherit from BasePage\n        BasePage\n\n        // real body for main page\n        BodyStr string\n    }\n    %}\n\n    Override only Body\n    Title and Footer are used from BasePage.\n    {% func (mp *MainPage) Body(s string, n int) %}\n        <div>\n            main body: {%s mp.BodyStr %}\n        </div>\n        <div>\n            base body: {%= mp.BasePage.Body(s, n) %}\n        </div>\n    {% endfunc %}\n    ```\n\n    See [basicserver example](https://github.com/valyala/quicktemplate/tree/master/examples/basicserver)\n    for more details.\n\n# Performance optimization tips\n\n  * Prefer calling `WriteFoo` instead of `Foo` when generating template output\n    for `{% func Foo() %}`. This avoids unnesessary memory allocation and a copy\n    for a `string` returned from `Foo()`.\n\n  * Prefer `{%= Foo() %}` instead of `{%s= Foo() %}` when embedding\n    a function template `{% func Foo() %}`. Though both approaches generate\n    identical output, the first approach is optimized for speed.\n\n  * Prefer using existing output tags instead of passing `fmt.Sprintf`\n    to `{%s %}`. For instance, use `{%d num %}` instead\n    of `{%s fmt.Sprintf(\"%d\", num) %}`, because the first approach is optimized\n    for speed.\n\n  * Prefer using specific output tags instead of generic output tag\n    `{%v %}`. For example, use `{%s str %}` instead of `{%v str %}`, since\n    specific output tags are optimized for speed.\n\n  * Prefer creating custom function templates instead of composing complex\n    strings by hands before passing them to `{%s %}`.\n    For instance, the first approach is slower than the second one:\n\n    ```qtpl\n    {% func Foo(n int) %}\n        {% code\n        // construct complex string\n        complexStr := \"\"\n        for i := 0; i < n; i++ {\n            complexStr += fmt.Sprintf(\"num %d,\", i)\n        }\n        %}\n        complex string = {%s= complexStr %}\n    {% endfunc %}\n    ```\n\n    ```qtpl\n    {% func Foo(n int) %}\n        complex string = {%= complexStr(n) %}\n    {% endfunc %}\n\n    // Wrap complexStr func into stripspace for stripping unnesessary space\n    // between tags and lines.\n    {% stripspace %}\n    {% func complexStr(n int) %}\n        {% for i := 0; i < n; i++ %}\n            num{% space %}{%d i %}{% newline %}\n        {% endfor %}\n    {% endfunc %}\n    {% endstripspace %}\n    ```\n\n  * Make sure that the `io.Writer` passed to `Write*` functions\n    is [buffered](https://golang.org/pkg/bufio/#Writer).\n    This will minimize the number of `write`\n    [syscalls](https://en.wikipedia.org/wiki/System_call),\n    which may be quite expensive.\n\n    Note: There is no need to wrap [fasthttp.RequestCtx](https://godoc.org/github.com/valyala/fasthttp#RequestCtx)\n    into [bufio.Writer](https://golang.org/pkg/bufio/#Writer), since it is already buffered.\n\n  * [Profile](http://blog.golang.org/profiling-go-programs) your programs\n    for memory allocations and fix the most demanding functions based on\n    the output of `go tool pprof --alloc_objects`.\n\n# Use cases\n\nWhile the main quicktemplate purpose is generating HTML, it may be used\nfor generating other data too. For example, JSON and XML marshalling may\nbe easily implemented with quicktemplate:\n\n```qtpl\n{% code\ntype MarshalRow struct {\n\tMsg string\n\tN int\n}\n\ntype MarshalData struct {\n\tFoo int\n\tBar string\n\tRows []MarshalRow\n}\n%}\n\n// JSON marshaling\n{% stripspace %}\n{% func (d *MarshalData) JSON() %}\n{\n\t\"Foo\": {%d d.Foo %},\n\t\"Bar\": {%q= d.Bar %},\n\t\"Rows\":[\n\t\t{% for i, r := range d.Rows %}\n\t\t\t{\n\t\t\t\t\"Msg\": {%q= r.Msg %},\n\t\t\t\t\"N\": {%d r.N %}\n\t\t\t}\n\t\t\t{% if i + 1 < len(d.Rows) %},{% endif %}\n\t\t{% endfor %}\n\t]\n}\n{% endfunc %}\n{% endstripspace %}\n\n// XML marshalling\n{% stripspace %}\n{% func (d *MarshalData) XML() %}\n<MarshalData>\n\t<Foo>{%d d.Foo %}</Foo>\n\t<Bar>{%s d.Bar %}</Bar>\n\t<Rows>\n\t{% for _, r := range d.Rows %}\n\t\t<Row>\n\t\t\t<Msg>{%s r.Msg %}</Msg>\n\t\t\t<N>{%d r.N %}</N>\n\t\t</Row>\n\t{% endfor %}\n\t</Rows>\n</MarshalData>\n{% endfunc %}\n{% endstripspace %}\n```\n\nUsually, marshalling built with quicktemplate works faster than the marshalling\nimplemented via standard [encoding/json](https://golang.org/pkg/encoding/json/)\nand [encoding/xml](https://golang.org/pkg/encoding/xml/).\nSee the corresponding benchmark results:\n\n```\ngo test -bench=Marshal -benchmem github.com/valyala/quicktemplate/tests\nBenchmarkMarshalJSONStd1-4                \t 3000000\t       480 ns/op\t       8 B/op\t       1 allocs/op\nBenchmarkMarshalJSONStd10-4               \t 1000000\t      1842 ns/op\t       8 B/op\t       1 allocs/op\nBenchmarkMarshalJSONStd100-4              \t  100000\t     15820 ns/op\t       8 B/op\t       1 allocs/op\nBenchmarkMarshalJSONStd1000-4             \t   10000\t    159327 ns/op\t      59 B/op\t       1 allocs/op\nBenchmarkMarshalJSONQuickTemplate1-4      \t10000000\t       162 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkMarshalJSONQuickTemplate10-4     \t 2000000\t       748 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkMarshalJSONQuickTemplate100-4    \t  200000\t      6572 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkMarshalJSONQuickTemplate1000-4   \t   20000\t     66784 ns/op\t      29 B/op\t       0 allocs/op\nBenchmarkMarshalXMLStd1-4                 \t 1000000\t      1652 ns/op\t       2 B/op\t       2 allocs/op\nBenchmarkMarshalXMLStd10-4                \t  200000\t      7533 ns/op\t      11 B/op\t      11 allocs/op\nBenchmarkMarshalXMLStd100-4               \t   20000\t     65763 ns/op\t     195 B/op\t     101 allocs/op\nBenchmarkMarshalXMLStd1000-4              \t    2000\t    663373 ns/op\t    3522 B/op\t    1002 allocs/op\nBenchmarkMarshalXMLQuickTemplate1-4       \t10000000\t       145 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkMarshalXMLQuickTemplate10-4      \t 3000000\t       597 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkMarshalXMLQuickTemplate100-4     \t  300000\t      5833 ns/op\t       0 B/op\t       0 allocs/op\nBenchmarkMarshalXMLQuickTemplate1000-4    \t   30000\t     53000 ns/op\t      32 B/op\t       0 allocs/op\n```\n\n# FAQ\n\n  * *Why is the quicktemplate syntax incompatible with [html/template](https://golang.org/pkg/html/template/)?*\n\n    Because `html/template` syntax isn't expressive enough for `quicktemplate`.\n\n  * *What's the difference between quicktemplate and [ego](https://github.com/benbjohnson/ego)?*\n\n    `Ego` is similar to `quicktemplate` in the sense it converts templates into Go code.\n    But it misses the following stuff, which makes `quicktemplate` so powerful\n    and easy to use:\n\n      * Defining multiple function templates in a single template file.\n      * Embedding function templates inside other function templates.\n      * Template interfaces, inheritance and overriding.\n        See [this example](https://github.com/valyala/quicktemplate/tree/master/examples/basicserver)\n        for details.\n      * Top-level comments outside function templates.\n      * Template packages.\n      * Combining arbitrary Go files with template files in template packages.\n      * Performance optimizations.\n\n  * *What's the difference between quicktemplate and [gorazor](https://github.com/sipin/gorazor)?*\n\n    `Gorazor` is similar to `quicktemplate` in the sense it converts templates into Go code.\n    But it misses the following useful features:\n\n      * Clear syntax instead of hard-to-understand magic stuff related\n        to template arguments, template inheritance and embedding function\n        templates into other templates.\n\n* *Is there a syntax highlighting for qtpl files?*\n\n  Yes - see [this issue](https://github.com/valyala/quicktemplate/issues/19) for details.\n  If you are using JetBrains products (syntax highlighting and autocomplete):\n    * cd [JetBrains settings directory](https://intellij-support.jetbrains.com/hc/en-us/articles/206544519-Directories-used-by-the-IDE-to-store-settings-caches-plugins-and-logs)\n    * mkdir -p filetypes && cd filetypes\n    * curl https://raw.githubusercontent.com/valyala/quicktemplate/master/QuickTemplate.xml >> QuickTemplate.xml\n    * Restart your IDE\n\n* *I didn't find an answer for my question here.*\n\n  Try exploring [these questions](https://github.com/valyala/quicktemplate/issues?q=label%3Aquestion).\n"
        },
        {
          "name": "bytebuffer.go",
          "type": "blob",
          "size": 1.12890625,
          "content": "package quicktemplate\n\nimport (\n\t\"github.com/valyala/bytebufferpool\"\n)\n\n// ByteBuffer implements io.Writer on top of byte slice.\n//\n// Recycle byte buffers via AcquireByteBuffer and ReleaseByteBuffer\n// in order to reduce memory allocations.\n//\n// Deprecated: use github.com/valyala/bytebufferpool instead.\ntype ByteBuffer bytebufferpool.ByteBuffer\n\n// Write implements io.Writer.\nfunc (b *ByteBuffer) Write(p []byte) (int, error) {\n\treturn bb(b).Write(p)\n}\n\n// Reset resets the byte buffer.\nfunc (b *ByteBuffer) Reset() {\n\tbb(b).Reset()\n}\n\n// AcquireByteBuffer returns new ByteBuffer from the pool.\n//\n// Return unneeded buffers to the pool by calling ReleaseByteBuffer\n// in order to reduce memory allocations.\nfunc AcquireByteBuffer() *ByteBuffer {\n\treturn (*ByteBuffer)(byteBufferPool.Get())\n}\n\n// ReleaseByteBuffer retruns byte buffer to the pool.\n//\n// Do not access byte buffer after returning it to the pool,\n// otherwise data races may occur.\nfunc ReleaseByteBuffer(b *ByteBuffer) {\n\tbyteBufferPool.Put(bb(b))\n}\n\nfunc bb(b *ByteBuffer) *bytebufferpool.ByteBuffer {\n\treturn (*bytebufferpool.ByteBuffer)(b)\n}\n\nvar byteBufferPool bytebufferpool.Pool\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1494140625,
          "content": "/*\nPackage quicktemplate provides fast and powerful template engine.\n\nSee https://github.com/valyala/quicktemplate for details.\n*/\npackage quicktemplate\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2490234375,
          "content": "module github.com/valyala/quicktemplate\n\ngo 1.17\n\nrequire (\n\tgithub.com/valyala/bytebufferpool v1.0.0\n\tgithub.com/valyala/fasthttp v1.55.0\n)\n\nrequire (\n\tgithub.com/andybalholm/brotli v1.1.0 // indirect\n\tgithub.com/klauspost/compress v1.17.9 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 6.384765625,
          "content": "github.com/andybalholm/brotli v1.1.0 h1:eLKJA0d02Lf0mVpIDgYnqXcUn0GqVmEFny3VuID1U3M=\ngithub.com/andybalholm/brotli v1.1.0/go.mod h1:sms7XGricyQI9K10gOSf56VKKWS4oLer58Q+mhRPtnY=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/klauspost/compress v1.17.9 h1:6KIumPrER1LHsvBVuDa0r5xaG0Es51mhhB9BQB2qeMA=\ngithub.com/klauspost/compress v1.17.9/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=\ngithub.com/valyala/bytebufferpool v1.0.0 h1:GqA5TC/0021Y/b9FG4Oi9Mr3q7XYx6KllzawFIhcdPw=\ngithub.com/valyala/bytebufferpool v1.0.0/go.mod h1:6bBcMArwyJ5K/AmCkWv1jt77kVWyCJ6HpOuEn7z0Csc=\ngithub.com/valyala/fasthttp v1.55.0 h1:Zkefzgt6a7+bVKHnu/YaYSOPfNYNisSVBo/unVCf8k8=\ngithub.com/valyala/fasthttp v1.55.0/go.mod h1:NkY9JtkrpPKmgwV3HTaS2HWaJss9RSIsRVfcxxoHiOM=\ngithub.com/valyala/tcplisten v1.0.0/go.mod h1:T0xQ8SeCZGxckz9qRXTfG43PvQ/mcWh7FwZEA7Ioqkc=\ngithub.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/crypto v0.13.0/go.mod h1:y6Z2r+Rw4iayiXXAIxJIDAJ1zMW4yaTpebo8fPOliYc=\ngolang.org/x/crypto v0.19.0/go.mod h1:Iy9bg/ha4yyC70EfRS8jz+B6ybOBKMaSxLj6P6oBDfU=\ngolang.org/x/crypto v0.23.0/go.mod h1:CKFgDieR+mRhux2Lsu27y0fO304Db0wZe70UKqHu0v8=\ngolang.org/x/crypto v0.24.0/go.mod h1:Z1PMYSOR5nyMcyAVAIQSKCDwalqy85Aqn1x3Ws4L5DM=\ngolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=\ngolang.org/x/mod v0.8.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.12.0/go.mod h1:iBbtSCu2XBx23ZKBPSOrRkjjQPZFPuis4dIYUhu/chs=\ngolang.org/x/mod v0.15.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/mod v0.17.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=\ngolang.org/x/net v0.6.0/go.mod h1:2Tu9+aMcznHK/AK1HMvgo6xiTLG5rD5rZLDS+rp2Bjs=\ngolang.org/x/net v0.10.0/go.mod h1:0qNGK6F8kojg2nk9dLZ2mShWaEBan6FAoqfSigmmuDg=\ngolang.org/x/net v0.15.0/go.mod h1:idbUs1IY1+zTqbi8yxTbhexhEEk5ur9LInksu6HrEpk=\ngolang.org/x/net v0.21.0/go.mod h1:bIjVDfnllIU7BJ2DNgfnXvpSvtn8VRwhlsaeUTyUS44=\ngolang.org/x/net v0.25.0/go.mod h1:JkAGAh7GEvH74S6FOH42FLoXpXbE/aqXSrIQjXgsiwM=\ngolang.org/x/net v0.26.0/go.mod h1:5YKkiSynbBIh3p6iOc/vibscux0x38BZDkn8sCUPxHE=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.1.0/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.3.0/go.mod h1:FU7BRWz2tNW+3quACPkgCx/L+uEAv1htQ0V83Z9Rj+Y=\ngolang.org/x/sync v0.6.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sync v0.7.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.5.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.12.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.17.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/sys v0.21.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/telemetry v0.0.0-20240228155512-f48c80bd79b2/go.mod h1:TeRTkGYfJXctD9OcfyVLyj2J3IxLnKwHJR8f4D8a3YE=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/term v0.5.0/go.mod h1:jMB1sMXY+tzblOD4FWmEbocvup2/aLOaQEp7JmGp78k=\ngolang.org/x/term v0.8.0/go.mod h1:xPskH00ivmX89bAKVGSKKtLOWNx2+17Eiy94tnKShWo=\ngolang.org/x/term v0.12.0/go.mod h1:owVbMEjm3cBLCHdkQu9b1opXd4ETQWc3BhuQGKgXgvU=\ngolang.org/x/term v0.17.0/go.mod h1:lLRBjIVuehSbZlaOtGMbcMncT+aqLLLmKrsjNrUguwk=\ngolang.org/x/term v0.20.0/go.mod h1:8UkIAJTvZgivsXaD6/pH6U9ecQzZ45awqEOzuCvwpFY=\ngolang.org/x/term v0.21.0/go.mod h1:ooXLefLobQVslOqselCNF4SxFAaoS6KujMbsGzSDmX0=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/text v0.7.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=\ngolang.org/x/text v0.9.0/go.mod h1:e1OnstbJyHTd6l/uOt8jFFHp6TRDWZR/bV3emEE/zU8=\ngolang.org/x/text v0.13.0/go.mod h1:TvPlkZtksWOMsz7fbANvkp4WM8x/WCo/om8BMLbz+aE=\ngolang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.15.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=\ngolang.org/x/text v0.16.0/go.mod h1:GhwF1Be+LQoKShO3cGOHzqOgRrGaYc9AvblQOmPVHnI=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=\ngolang.org/x/tools v0.6.0/go.mod h1:Xwgl3UAJ/d3gWutnCtw505GrjyAbvKui8lOU390QaIU=\ngolang.org/x/tools v0.13.0/go.mod h1:HvlwmtVNQAhOuCjW7xxvovg8wbNq7LwfXh/k7wXUl58=\ngolang.org/x/tools v0.21.1-0.20240508182429-e35e4ccd0d2d/go.mod h1:aiJjzUbINMkxbQROHiO6hDPo2LHcIPhhQsa9DLh0yGk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "htmlescapewriter.go",
          "type": "blob",
          "size": 0.970703125,
          "content": "package quicktemplate\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\ntype htmlEscapeWriter struct {\n\tw io.Writer\n}\n\nfunc (w *htmlEscapeWriter) Write(b []byte) (int, error) {\n\tif bytes.IndexByte(b, '<') < 0 &&\n\t\tbytes.IndexByte(b, '>') < 0 &&\n\t\tbytes.IndexByte(b, '\"') < 0 &&\n\t\tbytes.IndexByte(b, '\\'') < 0 &&\n\t\tbytes.IndexByte(b, '&') < 0 {\n\n\t\t// fast path - nothing to escape\n\t\treturn w.w.Write(b)\n\t}\n\n\t// slow path\n\twrite := w.w.Write\n\tj := 0\n\tfor i, c := range b {\n\t\tswitch c {\n\t\tcase '<':\n\t\t\twrite(b[j:i])\n\t\t\twrite(strLT)\n\t\t\tj = i + 1\n\t\tcase '>':\n\t\t\twrite(b[j:i])\n\t\t\twrite(strGT)\n\t\t\tj = i + 1\n\t\tcase '\"':\n\t\t\twrite(b[j:i])\n\t\t\twrite(strQuot)\n\t\t\tj = i + 1\n\t\tcase '\\'':\n\t\t\twrite(b[j:i])\n\t\t\twrite(strApos)\n\t\t\tj = i + 1\n\t\tcase '&':\n\t\t\twrite(b[j:i])\n\t\t\twrite(strAmp)\n\t\t\tj = i + 1\n\t\t}\n\t}\n\tif n, err := write(b[j:]); err != nil {\n\t\treturn j + n, err\n\t}\n\treturn len(b), nil\n}\n\nvar (\n\tstrLT   = []byte(\"&lt;\")\n\tstrGT   = []byte(\"&gt;\")\n\tstrQuot = []byte(\"&quot;\")\n\tstrApos = []byte(\"&#39;\")\n\tstrAmp  = []byte(\"&amp;\")\n)\n"
        },
        {
          "name": "htmlescapewriter_test.go",
          "type": "blob",
          "size": 0.7900390625,
          "content": "package quicktemplate\n\nimport (\n\t\"testing\"\n)\n\nfunc TestHTMLEscapeWriter(t *testing.T) {\n\ttestHTMLEscapeWriter(t, \"\", \"\")\n\ttestHTMLEscapeWriter(t, \"foobar\", \"foobar\")\n\ttestHTMLEscapeWriter(t, `<h1>fo'\"bar&</h1>`, \"&lt;h1&gt;fo&#39;&quot;bar&amp;&lt;/h1&gt;\")\n\ttestHTMLEscapeWriter(t, \"fo<b>bar привет\\n\\tbaz\", \"fo&lt;b&gt;bar привет\\n\\tbaz\")\n}\n\nfunc testHTMLEscapeWriter(t *testing.T, s, expectedS string) {\n\tbb := AcquireByteBuffer()\n\tw := &htmlEscapeWriter{w: bb}\n\tn, err := w.Write([]byte(s))\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when writing %q: %s\", s, err)\n\t}\n\tif n != len(s) {\n\t\tt.Fatalf(\"unexpected n returned: %d. Expecting %d. s=%q\", n, len(s), s)\n\t}\n\n\tif string(bb.B) != expectedS {\n\t\tt.Fatalf(\"unexpected result: %q. Expecting %q\", bb.B, expectedS)\n\t}\n\tReleaseByteBuffer(bb)\n}\n"
        },
        {
          "name": "htmlescapewriter_timing_test.go",
          "type": "blob",
          "size": 0.619140625,
          "content": "package quicktemplate\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkHTMLEscapeWriterNoHTML(b *testing.B) {\n\ts := \"foobarbazabcdefghjkl\"\n\tbenchmarkHTMLEscapeWriter(b, s)\n}\n\nfunc BenchmarkHTMLEscapeWriterWithHTML(b *testing.B) {\n\ts := \"foo<a>baza</a>fghjkl\"\n\tbenchmarkHTMLEscapeWriter(b, s)\n}\n\nfunc benchmarkHTMLEscapeWriter(b *testing.B, s string) {\n\tsBytes := []byte(s)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar err error\n\t\tbb := AcquireByteBuffer()\n\t\tw := &htmlEscapeWriter{w: bb}\n\t\tfor pb.Next() {\n\t\t\tif _, err = w.Write(sBytes); err != nil {\n\t\t\t\tb.Fatalf(\"unexpected error: %s\", err)\n\t\t\t}\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n"
        },
        {
          "name": "jsonstring.go",
          "type": "blob",
          "size": 2.208984375,
          "content": "package quicktemplate\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc hasSpecialChars(s string) bool {\n\tif strings.IndexByte(s, '\"') >= 0 || strings.IndexByte(s, '\\\\') >= 0 || strings.IndexByte(s, '<') >= 0 || strings.IndexByte(s, '\\'') >= 0 {\n\t\treturn true\n\t}\n\tfor i := 0; i < len(s); i++ {\n\t\tif s[i] < 0x20 {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// AppendJSONString appends json-encoded string s to dst and returns the result.\n//\n// If addQuotes is true, then the appended json string is wrapped into double quotes.\nfunc AppendJSONString(dst []byte, s string, addQuotes bool) []byte {\n\tif !hasSpecialChars(s) {\n\t\t// Fast path - nothing to escape.\n\t\tif !addQuotes {\n\t\t\treturn append(dst, s...)\n\t\t}\n\t\tdst = append(dst, '\"')\n\t\tdst = append(dst, s...)\n\t\tdst = append(dst, '\"')\n\t\treturn dst\n\t}\n\n\t// Slow path - there are chars to escape.\n\tif addQuotes {\n\t\tdst = append(dst, '\"')\n\t}\n\tdst = jsonReplacer.AppendReplace(dst, s)\n\tif addQuotes {\n\t\tdst = append(dst, '\"')\n\t}\n\treturn dst\n}\n\nvar jsonReplacer = newByteReplacer(func() ([]byte, []string) {\n\toldChars := []byte(\"\\n\\r\\t\\b\\f\\\"\\\\<'\")\n\tnewStrings := []string{`\\n`, `\\r`, `\\t`, `\\b`, `\\f`, `\\\"`, `\\\\`, `\\u003c`, `\\u0027`}\n\tfor i := 0; i < 0x20; i++ {\n\t\tc := byte(i)\n\t\tif n := bytes.IndexByte(oldChars, c); n >= 0 {\n\t\t\tcontinue\n\t\t}\n\t\toldChars = append(oldChars, byte(i))\n\t\tnewStrings = append(newStrings, fmt.Sprintf(`\\u%04x`, i))\n\t}\n\treturn oldChars, newStrings\n}())\n\ntype byteReplacer struct {\n\tm   [256]byte\n\tnewStrings []string\n}\n\nfunc newByteReplacer(oldChars []byte, newStrings []string) *byteReplacer {\n\tif len(oldChars) != len(newStrings) {\n\t\tpanic(fmt.Errorf(\"len(oldChars)=%d must be equal to len(newStrings)=%d\", len(oldChars), len(newStrings)))\n\t}\n\tif len(oldChars) >= 255 {\n\t\tpanic(fmt.Errorf(\"len(oldChars)=%d must be smaller than 255\", len(oldChars)))\n\t}\n\n\tvar m [256]byte\n\tfor i := range m[:] {\n\t\tm[i] = 255\n\t}\n\tfor i, c := range oldChars {\n\t\tm[c] = byte(i)\n\t}\n\treturn &byteReplacer{\n\t\tm:   m,\n\t\tnewStrings: newStrings,\n\t}\n}\n\nfunc (br *byteReplacer) AppendReplace(dst []byte, s string) []byte {\n\tm := br.m\n\tnewStrings := br.newStrings\n\tfor i := 0; i < len(s); i++ {\n\t\tc := s[i]\n\t\tn := m[c]\n\t\tif n == 255 {\n\t\t\tdst = append(dst, c)\n\t\t} else {\n\t\t\tdst = append(dst, newStrings[n]...)\n\t\t}\n\t}\n\treturn dst\n}\n"
        },
        {
          "name": "jsonstring_test.go",
          "type": "blob",
          "size": 1.3017578125,
          "content": "package quicktemplate\n\nimport (\n\t\"encoding/json\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestAppendJSONString(t *testing.T) {\n\ttestAppendJSONString(t, ``)\n\ttestAppendJSONString(t, `f`)\n\ttestAppendJSONString(t, `\"`)\n\ttestAppendJSONString(t, `<`)\n\ttestAppendJSONString(t, \"\\x00\\n\\r\\t\\b\\f\"+`\"\\`)\n\ttestAppendJSONString(t, `\"foobar`)\n\ttestAppendJSONString(t, `foobar\"`)\n\ttestAppendJSONString(t, `foo \"bar\"\n\t\tbaz`)\n\ttestAppendJSONString(t, `this is a \"тест\"`)\n\ttestAppendJSONString(t, `привет test ыва`)\n\n\ttestAppendJSONString(t, `</script><script>alert('evil')</script>`)\n\ttestAppendJSONString(t, \"\\u001b\")\n}\n\nfunc testAppendJSONString(t *testing.T, s string) {\n\texpectedResult, err := json.Marshal(s)\n\tif err != nil {\n\t\tt.Fatalf(\"unexpected error when encoding string %q: %s\", s, err)\n\t}\n\texpectedResult = expectedResult[1 : len(expectedResult)-1]\n\n\tbb := AcquireByteBuffer()\n\tbb.B = AppendJSONString(bb.B[:0], s, false)\n\tresult := string(bb.B)\n\tReleaseByteBuffer(bb)\n\n\tif strings.Contains(result, \"'\") {\n\t\tt.Fatalf(\"json string shouldn't contain single quote: %q, src %q\", result, s)\n\t}\n\tresult = strings.Replace(result, `\\u0027`, \"'\", -1)\n\tresult = strings.Replace(result, \">\", `\\u003e`, -1)\n\tif result != string(expectedResult) {\n\t\tt.Fatalf(\"unexpected result %q. Expecting %q. original string %q\", result, expectedResult, s)\n\t}\n}\n"
        },
        {
          "name": "jsonstring_timing_test.go",
          "type": "blob",
          "size": 1.1884765625,
          "content": "package quicktemplate\n\nimport (\n\t\"strconv\"\n\t\"testing\"\n)\n\nfunc BenchmarkAppendJSONString(b *testing.B) {\n\tb.Run(\"no-special-chars\", func(b *testing.B) {\n\t\tbenchmarkAppendJSONString(b, \"foo bar baz abc defkjlkj lkjdfs klsdjflfdjoqjo lkj ss\")\n\t})\n\tb.Run(\"with-special-chars\", func(b *testing.B) {\n\t\tbenchmarkAppendJSONString(b, `foo bar baz abc defkjlkj lkjdf\" klsdjflfdjoqjo\\lkj ss`)\n\t})\n}\n\nfunc benchmarkAppendJSONString(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar buf []byte\n\t\tfor pb.Next() {\n\t\t\tbuf = AppendJSONString(buf[:0], s, true)\n\t\t}\n\t})\n}\n\nfunc BenchmarkAppendJSONStringViaStrconv(b *testing.B) {\n\tb.Run(\"no-special-chars\", func(b *testing.B) {\n\t\tbenchmarkAppendJSONStringViaStrconv(b, \"foo bar baz abc defkjlkj lkjdfs klsdjflfdjoqjo lkj ss\")\n\t})\n\tb.Run(\"with-special-chars\", func(b *testing.B) {\n\t\tbenchmarkAppendJSONStringViaStrconv(b, `foo bar baz abc defkjlkj lkjdf\" klsdjflfdjoqjo\\lkj ss`)\n\t})\n}\n\nfunc benchmarkAppendJSONStringViaStrconv(b *testing.B, s string) {\n\tb.ReportAllocs()\n\tb.SetBytes(int64(len(s)))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar buf []byte\n\t\tfor pb.Next() {\n\t\t\tbuf = strconv.AppendQuote(buf[:0], s)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "parser",
          "type": "tree",
          "content": null
        },
        {
          "name": "qtc",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "urlencode.go",
          "type": "blob",
          "size": 0.6748046875,
          "content": "package quicktemplate\n\nfunc appendURLEncode(dst []byte, src string) []byte {\n\tn := len(src)\n\tif n > 0 {\n\t\t// Hint the compiler to remove bounds checks in the loop below.\n\t\t_ = src[n-1]\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tc := src[i]\n\n\t\t// See http://www.w3.org/TR/html5/forms.html#form-submission-algorithm\n\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' && c <= '9' ||\n\t\t\tc == '-' || c == '.' || c == '_' {\n\t\t\tdst = append(dst, c)\n\t\t} else {\n\t\t\tif c == ' ' {\n\t\t\t\tdst = append(dst, '+')\n\t\t\t} else {\n\t\t\t\tdst = append(dst, '%', hexCharUpper(c>>4), hexCharUpper(c&15))\n\t\t\t}\n\t\t}\n\t}\n\treturn dst\n}\n\nfunc hexCharUpper(c byte) byte {\n\tif c < 10 {\n\t\treturn '0' + c\n\t}\n\treturn c - 10 + 'A'\n}\n"
        },
        {
          "name": "urlencode_test.go",
          "type": "blob",
          "size": 0.5126953125,
          "content": "package quicktemplate\n\nimport (\n\t\"net/url\"\n\t\"testing\"\n)\n\nfunc TestAppendURLEncode(t *testing.T) {\n\ttestAppendURLEncode(t, \"\")\n\ttestAppendURLEncode(t, \"f\")\n\ttestAppendURLEncode(t, \" \")\n\ttestAppendURLEncode(t, \".-_\")\n\ttestAppendURLEncode(t, \"тест+this/&=;?\\n\\t\\rabc\")\n}\n\nfunc testAppendURLEncode(t *testing.T, s string) {\n\texpectedResult := url.QueryEscape(s)\n\tresult := appendURLEncode(nil, s)\n\tif string(result) != expectedResult {\n\t\tt.Fatalf(\"unexpected result %q. Expecting %q. str=%q\", result, expectedResult, s)\n\t}\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 0.0634765625,
          "content": "package quicktemplate\n\n//go:generate qtc -dir=testdata/templates\n"
        },
        {
          "name": "util_appengine.go",
          "type": "blob",
          "size": 0.2099609375,
          "content": "//go:build appengine || appenginevm\n// +build appengine appenginevm\n\npackage quicktemplate\n\nfunc unsafeStrToBytes(s string) []byte {\n\treturn []byte(s)\n}\n\nfunc unsafeBytesToStr(z []byte) string {\n\treturn string(z)\n}\n"
        },
        {
          "name": "util_noappengine.go",
          "type": "blob",
          "size": 0.4130859375,
          "content": "//go:build !appengine && !appenginevm\n// +build !appengine,!appenginevm\n\npackage quicktemplate\n\nimport (\n\t\"reflect\"\n\t\"unsafe\"\n)\n\nfunc unsafeStrToBytes(s string) (b []byte) {\n\tsh := (*reflect.StringHeader)(unsafe.Pointer(&s))\n\tbh := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n\tbh.Data = sh.Data\n\tbh.Len = sh.Len\n\tbh.Cap = sh.Len\n\treturn b\n}\n\nfunc unsafeBytesToStr(z []byte) string {\n\treturn *(*string)(unsafe.Pointer(&z))\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "writer.go",
          "type": "blob",
          "size": 3.9619140625,
          "content": "package quicktemplate\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"strconv\"\n\t\"sync\"\n)\n\n// Writer implements auxiliary writer used by quicktemplate functions.\n//\n// Use AcquireWriter for creating new writers.\ntype Writer struct {\n\te QWriter\n\tn QWriter\n}\n\n// W returns the underlying writer passed to AcquireWriter.\nfunc (qw *Writer) W() io.Writer {\n\treturn qw.n.w\n}\n\n// E returns QWriter with enabled html escaping.\nfunc (qw *Writer) E() *QWriter {\n\treturn &qw.e\n}\n\n// N returns QWriter without html escaping.\nfunc (qw *Writer) N() *QWriter {\n\treturn &qw.n\n}\n\n// AcquireWriter returns new writer from the pool.\n//\n// Return unneeded writer to the pool by calling ReleaseWriter\n// in order to reduce memory allocations.\nfunc AcquireWriter(w io.Writer) *Writer {\n\tv := writerPool.Get()\n\tif v == nil {\n\t\tqw := &Writer{}\n\t\tqw.e.w = &htmlEscapeWriter{}\n\t\tv = qw\n\t}\n\tqw := v.(*Writer)\n\tqw.e.w.(*htmlEscapeWriter).w = w\n\tqw.n.w = w\n\treturn qw\n}\n\n// ReleaseWriter returns the writer to the pool.\n//\n// Do not access released writer, otherwise data races may occur.\nfunc ReleaseWriter(qw *Writer) {\n\thw := qw.e.w.(*htmlEscapeWriter)\n\thw.w = nil\n\tqw.e.Reset()\n\tqw.e.w = hw\n\n\tqw.n.Reset()\n\n\twriterPool.Put(qw)\n}\n\nvar writerPool sync.Pool\n\n// QWriter is auxiliary writer used by Writer.\ntype QWriter struct {\n\tw   io.Writer\n\terr error\n\tb   []byte\n}\n\n// Write implements io.Writer.\nfunc (w *QWriter) Write(p []byte) (int, error) {\n\tif w.err != nil {\n\t\treturn 0, w.err\n\t}\n\tn, err := w.w.Write(p)\n\tif err != nil {\n\t\tw.err = err\n\t}\n\treturn n, err\n}\n\n// Reset resets QWriter to the original state.\nfunc (w *QWriter) Reset() {\n\tw.w = nil\n\tw.err = nil\n}\n\n// S writes s to w.\nfunc (w *QWriter) S(s string) {\n\tw.Write(unsafeStrToBytes(s))\n}\n\n// Z writes z to w.\nfunc (w *QWriter) Z(z []byte) {\n\tw.Write(z)\n}\n\n// SZ is a synonym to Z.\nfunc (w *QWriter) SZ(z []byte) {\n\tw.Write(z)\n}\n\n// D writes n to w.\nfunc (w *QWriter) D(n int) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = strconv.AppendInt(bb.B, int64(n), 10)\n\t} else {\n\t\tw.b = strconv.AppendInt(w.b[:0], int64(n), 10)\n\t\tw.Write(w.b)\n\t}\n}\n\n// DL writes n to w\nfunc (w *QWriter) DL(n int64) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = strconv.AppendInt(bb.B, n, 10)\n\t} else {\n\t\tw.b = strconv.AppendInt(w.b[:0], n, 10)\n\t\tw.Write(w.b)\n\t}\n}\n\n// DUL writes n to w\nfunc (w *QWriter) DUL(n uint64) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = strconv.AppendUint(bb.B, n, 10)\n\t} else {\n\t\tw.b = strconv.AppendUint(w.b[:0], n, 10)\n\t\tw.Write(w.b)\n\t}\n}\n\n// F writes f to w.\nfunc (w *QWriter) F(f float64) {\n\tn := int(f)\n\tif float64(n) == f {\n\t\t// Fast path - just int.\n\t\tw.D(n)\n\t\treturn\n\t}\n\n\t// Slow path.\n\tw.FPrec(f, -1)\n}\n\n// FPrec writes f to w using the given floating point precision.\nfunc (w *QWriter) FPrec(f float64, prec int) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = strconv.AppendFloat(bb.B, f, 'f', prec, 64)\n\t} else {\n\t\tw.b = strconv.AppendFloat(w.b[:0], f, 'f', prec, 64)\n\t\tw.Write(w.b)\n\t}\n}\n\n// Q writes quoted json-safe s to w.\nfunc (w *QWriter) Q(s string) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = AppendJSONString(bb.B, s, true)\n\t} else {\n\t\tw.b = AppendJSONString(w.b[:0], s, true)\n\t\tw.Write(w.b)\n\t}\n}\n\nvar strQuote = []byte(`\"`)\n\n// QZ writes quoted json-safe z to w.\nfunc (w *QWriter) QZ(z []byte) {\n\tw.Q(unsafeBytesToStr(z))\n}\n\n// J writes json-safe s to w.\n//\n// Unlike Q it doesn't qoute resulting s.\nfunc (w *QWriter) J(s string) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = AppendJSONString(bb.B, s, false)\n\t} else {\n\t\tw.b = AppendJSONString(w.b[:0], s, false)\n\t\tw.Write(w.b)\n\t}\n}\n\n// JZ writes json-safe z to w.\n//\n// Unlike Q it doesn't qoute resulting z.\nfunc (w *QWriter) JZ(z []byte) {\n\tw.J(unsafeBytesToStr(z))\n}\n\n// V writes v to w.\nfunc (w *QWriter) V(v interface{}) {\n\tfmt.Fprintf(w, \"%v\", v)\n}\n\n// U writes url-encoded s to w.\nfunc (w *QWriter) U(s string) {\n\tbb, ok := w.w.(*ByteBuffer)\n\tif ok {\n\t\tbb.B = appendURLEncode(bb.B, s)\n\t} else {\n\t\tw.b = appendURLEncode(w.b[:0], s)\n\t\tw.Write(w.b)\n\t}\n}\n\n// UZ writes url-encoded z to w.\nfunc (w *QWriter) UZ(z []byte) {\n\tw.U(unsafeBytesToStr(z))\n}\n"
        },
        {
          "name": "writer_test.go",
          "type": "blob",
          "size": 5.31640625,
          "content": "package quicktemplate\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWriter(t *testing.T) {\n\tbb := AcquireByteBuffer()\n\tqw := AcquireWriter(bb)\n\tw := qw.W()\n\tbbNew, ok := w.(*ByteBuffer)\n\tif !ok {\n\t\tt.Fatalf(\"W() must return ByteBuffer, not %T\", w)\n\t}\n\tif bbNew != bb {\n\t\tt.Fatalf(\"unexpected ByteBuffer returned: %p. Expecting %p\", bbNew, bb)\n\t}\n\n\twn := qw.N()\n\twe := qw.E()\n\n\twn.S(\"<a></a>\")\n\twn.D(123)\n\twe.DUL(18446744073709551615)\n\twn.Z([]byte(\"'\"))\n\twn.Q(\"foo\")\n\twn.J(\"ds\")\n\twn.F(1.23)\n\twn.U(\"абв\")\n\twn.V(struct{}{})\n\twn.SZ([]byte(\"aaa\"))\n\twn.QZ([]byte(\"asadf\"))\n\twn.JZ([]byte(\"asd\"))\n\twn.UZ([]byte(\"abc\"))\n\n\twe.S(\"<a></a>\")\n\twe.D(321)\n\twe.DUL(18446744073709551615)\n\twe.Z([]byte(\"'\"))\n\twe.Q(\"foo\")\n\twe.J(\"ds\")\n\twe.F(1.23)\n\twe.U(\"абв\")\n\twe.V(struct{}{})\n\twe.SZ([]byte(\"aaa\"))\n\twe.QZ([]byte(\"asadf\"))\n\twe.JZ([]byte(\"asd\"))\n\twe.UZ([]byte(\"abc\"))\n\n\tReleaseWriter(qw)\n\n\texpectedS := \"<a></a>12318446744073709551615'\\\"foo\\\"ds1.23%D0%B0%D0%B1%D0%B2{}aaa\\\"asadf\\\"asdabc\" +\n\t\t\"&lt;a&gt;&lt;/a&gt;32118446744073709551615&#39;&quot;foo&quot;ds1.23%D0%B0%D0%B1%D0%B2{}aaa&quot;asadf&quot;asdabc\"\n\tif string(bb.B) != expectedS {\n\t\tt.Fatalf(\"unexpected output:\\n%q\\nExpecting\\n%q\", bb.B, expectedS)\n\t}\n\n\tReleaseByteBuffer(bb)\n}\n\nfunc TestQWriterS(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\x00foo<>&'\\\" bar\\n\\t</script>=;\\\\/+%йцу\\x00foo&lt;&gt;&amp;&#39;&quot; bar\\n\\t&lt;/script&gt;=;\\\\/+%йцу\"\n\t\twn.S(s)\n\t\twe.S(s)\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterZ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\x00foo<>&'\\\" bar\\n\\t</script>=;\\\\/+%йцу\\x00foo&lt;&gt;&amp;&#39;&quot; bar\\n\\t&lt;/script&gt;=;\\\\/+%йцу\"\n\t\twn.Z([]byte(s))\n\t\twe.Z([]byte(s))\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterSZ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\x00foo<>&'\\\" bar\\n\\t</script>=;\\\\/+%йцу\\x00foo&lt;&gt;&amp;&#39;&quot; bar\\n\\t&lt;/script&gt;=;\\\\/+%йцу\"\n\t\twn.SZ([]byte(s))\n\t\twe.SZ([]byte(s))\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterQ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\\"\\\\u0000foo\\\\u003c>&\\\\u0027\\\\\\\" bar\\\\n\\\\t\\\\u003c/script>=;\\\\\\\\/+%йцу\\\"&quot;\\\\u0000foo\\\\u003c&gt;&amp;\\\\u0027\\\\&quot; bar\\\\n\\\\t\\\\u003c/script&gt;=;\\\\\\\\/+%йцу&quot;\"\n\t\twn.Q(s)\n\t\twe.Q(s)\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterQZ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\\"\\\\u0000foo\\\\u003c>&\\\\u0027\\\\\\\" bar\\\\n\\\\t\\\\u003c/script>=;\\\\\\\\/+%йцу\\\"&quot;\\\\u0000foo\\\\u003c&gt;&amp;\\\\u0027\\\\&quot; bar\\\\n\\\\t\\\\u003c/script&gt;=;\\\\\\\\/+%йцу&quot;\"\n\t\twn.QZ([]byte(s))\n\t\twe.QZ([]byte(s))\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterJ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\\\u0000foo\\\\u003c>&\\\\u0027\\\\\\\" bar\\\\n\\\\t\\\\u003c/script>=;\\\\\\\\/+%йцу\\\\u0000foo\\\\u003c&gt;&amp;\\\\u0027\\\\&quot; bar\\\\n\\\\t\\\\u003c/script&gt;=;\\\\\\\\/+%йцу\"\n\t\twn.J(s)\n\t\twe.J(s)\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterJZ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"\\\\u0000foo\\\\u003c>&\\\\u0027\\\\\\\" bar\\\\n\\\\t\\\\u003c/script>=;\\\\\\\\/+%йцу\\\\u0000foo\\\\u003c&gt;&amp;\\\\u0027\\\\&quot; bar\\\\n\\\\t\\\\u003c/script&gt;=;\\\\\\\\/+%йцу\"\n\t\twn.JZ([]byte(s))\n\t\twe.JZ([]byte(s))\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterU(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"%00foo%3C%3E%26%27%22+bar%0A%09%3C%2Fscript%3E%3D%3B%5C%2F%2B%25%D0%B9%D1%86%D1%83%00foo%3C%3E%26%27%22+bar%0A%09%3C%2Fscript%3E%3D%3B%5C%2F%2B%25%D0%B9%D1%86%D1%83\"\n\t\twn.U(s)\n\t\twe.U(s)\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterUZ(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"%00foo%3C%3E%26%27%22+bar%0A%09%3C%2Fscript%3E%3D%3B%5C%2F%2B%25%D0%B9%D1%86%D1%83%00foo%3C%3E%26%27%22+bar%0A%09%3C%2Fscript%3E%3D%3B%5C%2F%2B%25%D0%B9%D1%86%D1%83\"\n\t\twn.UZ([]byte(s))\n\t\twe.UZ([]byte(s))\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterV(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\ts := \"\\u0000\" + `foo<>&'\" bar\n\t</script>=;\\/+%йцу`\n\t\texpectedS := \"{\\x00foo<>&'\\\" bar\\n\\t</script>=;\\\\/+%йцу}{\\x00foo&lt;&gt;&amp;&#39;&quot; bar\\n\\t&lt;/script&gt;=;\\\\/+%йцу}\"\n\t\tss := struct{ S string }{s}\n\t\twn.V(ss)\n\t\twe.V(ss)\n\t\treturn expectedS\n\t})\n}\n\nfunc TestQWriterF(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\tf := 1.9234\n\t\twn.F(f)\n\t\twe.F(f)\n\t\treturn \"1.92341.9234\"\n\t})\n}\n\nfunc TestQWriterFPrec(t *testing.T) {\n\ttestQWriter(t, func(wn, we *QWriter) string {\n\t\tf := 1.9254\n\t\twn.FPrec(f, 2)\n\t\twe.FPrec(f, 3)\n\t\twn.FPrec(f, 0)\n\t\twe.FPrec(f, 1)\n\t\treturn \"1.931.92521.9\"\n\t})\n}\n\nfunc testQWriter(t *testing.T, f func(wn, we *QWriter) (expectedS string)) {\n\tbb := AcquireByteBuffer()\n\tqw := AcquireWriter(bb)\n\twn := qw.N()\n\twe := qw.E()\n\n\texpectedS := f(wn, we)\n\n\tReleaseWriter(qw)\n\n\tif string(bb.B) != expectedS {\n\t\tt.Fatalf(\"unexpected output:\\n%q\\nExpecting\\n%q\", bb.B, expectedS)\n\t}\n\n\tReleaseByteBuffer(bb)\n}\n"
        },
        {
          "name": "writer_timing_test.go",
          "type": "blob",
          "size": 4.5048828125,
          "content": "package quicktemplate\n\nimport (\n\t\"testing\"\n)\n\nfunc BenchmarkQWriterVString(b *testing.B) {\n\tv := createTestS(100)\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.V(v)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterVInt(b *testing.B) {\n\tv := 1233455\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.V(v)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterQ1(b *testing.B) {\n\tbenchmarkQWriterQ(b, 1)\n}\n\nfunc BenchmarkQWriterQ10(b *testing.B) {\n\tbenchmarkQWriterQ(b, 10)\n}\n\nfunc BenchmarkQWriterQ100(b *testing.B) {\n\tbenchmarkQWriterQ(b, 100)\n}\n\nfunc BenchmarkQWriterQ1K(b *testing.B) {\n\tbenchmarkQWriterQ(b, 1000)\n}\n\nfunc BenchmarkQWriterQ10K(b *testing.B) {\n\tbenchmarkQWriterQ(b, 10000)\n}\n\nfunc benchmarkQWriterQ(b *testing.B, size int) {\n\ts := createTestS(size)\n\tb.SetBytes(int64(size))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.Q(s)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterJ1(b *testing.B) {\n\tbenchmarkQWriterJ(b, 1)\n}\n\nfunc BenchmarkQWriterJ10(b *testing.B) {\n\tbenchmarkQWriterJ(b, 10)\n}\n\nfunc BenchmarkQWriterJ100(b *testing.B) {\n\tbenchmarkQWriterJ(b, 100)\n}\n\nfunc BenchmarkQWriterJ1K(b *testing.B) {\n\tbenchmarkQWriterJ(b, 1000)\n}\n\nfunc BenchmarkQWriterJ10K(b *testing.B) {\n\tbenchmarkQWriterJ(b, 10000)\n}\n\nfunc benchmarkQWriterJ(b *testing.B, size int) {\n\ts := createTestS(size)\n\tb.SetBytes(int64(size))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.J(s)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterU1(b *testing.B) {\n\tbenchmarkQWriterU(b, 1)\n}\n\nfunc BenchmarkQWriterU10(b *testing.B) {\n\tbenchmarkQWriterU(b, 10)\n}\n\nfunc BenchmarkQWriterU100(b *testing.B) {\n\tbenchmarkQWriterU(b, 100)\n}\n\nfunc BenchmarkQWriterU1K(b *testing.B) {\n\tbenchmarkQWriterU(b, 1000)\n}\n\nfunc BenchmarkQWriterU10K(b *testing.B) {\n\tbenchmarkQWriterU(b, 10000)\n}\n\nfunc benchmarkQWriterU(b *testing.B, size int) {\n\ts := createTestS(size)\n\tb.SetBytes(int64(size))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.U(s)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterFfloat(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tf := 123.456\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.F(f)\n\t\t\tbb.Reset()\n\t\t\tf++\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterFint(b *testing.B) {\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tf := 123.0\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.F(f)\n\t\t\tbb.Reset()\n\t\t\tf++\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterD(b *testing.B) {\n\tn := 123456\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.D(n)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc BenchmarkQWriterZ1(b *testing.B) {\n\tbenchmarkQWriterZ(b, 1)\n}\n\nfunc BenchmarkQWriterZ10(b *testing.B) {\n\tbenchmarkQWriterZ(b, 10)\n}\n\nfunc BenchmarkQWriterZ100(b *testing.B) {\n\tbenchmarkQWriterZ(b, 100)\n}\n\nfunc BenchmarkQWriterZ1K(b *testing.B) {\n\tbenchmarkQWriterZ(b, 1000)\n}\n\nfunc BenchmarkQWriterZ10K(b *testing.B) {\n\tbenchmarkQWriterZ(b, 10000)\n}\n\nfunc BenchmarkQWriterS1(b *testing.B) {\n\tbenchmarkQWriterS(b, 1)\n}\n\nfunc BenchmarkQWriterS10(b *testing.B) {\n\tbenchmarkQWriterS(b, 10)\n}\n\nfunc BenchmarkQWriterS100(b *testing.B) {\n\tbenchmarkQWriterS(b, 100)\n}\n\nfunc BenchmarkQWriterS1K(b *testing.B) {\n\tbenchmarkQWriterS(b, 1000)\n}\n\nfunc BenchmarkQWriterS10K(b *testing.B) {\n\tbenchmarkQWriterS(b, 10000)\n}\n\nfunc benchmarkQWriterZ(b *testing.B, size int) {\n\tz := createTestZ(size)\n\tb.SetBytes(int64(size))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.Z(z)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc benchmarkQWriterS(b *testing.B, size int) {\n\ts := createTestS(size)\n\tb.SetBytes(int64(size))\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tvar w QWriter\n\t\tbb := AcquireByteBuffer()\n\t\tw.w = bb\n\t\tfor pb.Next() {\n\t\t\tw.S(s)\n\t\t\tbb.Reset()\n\t\t}\n\t\tReleaseByteBuffer(bb)\n\t})\n}\n\nfunc createTestS(size int) string {\n\treturn string(createTestZ(size))\n}\n\nvar sample = []byte(`0123456789qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM`)\n\nfunc createTestZ(size int) []byte {\n\tvar b []byte\n\tfor i := 0; i < size; i++ {\n\t\tb = append(b, sample[i%len(sample)])\n\t}\n\treturn b\n}\n"
        }
      ]
    }
  ]
}