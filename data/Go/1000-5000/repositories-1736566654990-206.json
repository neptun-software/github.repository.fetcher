{
  "metadata": {
    "timestamp": 1736566654990,
    "page": 206,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjIxMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ochinchina/supervisord",
      "stars": 4057,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1083984375,
          "content": ".idea\nsupervisord\nsupervisord.exe\ntest.log*\n.tags*\ndebug\ngo-debug.json\nvendor\nsupervisord_linux_amd64\nupx\ndist\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 1.779296875,
          "content": "project_name: supervisord\n\nenv:\n  - GO111MODULE=on\n\nbefore:\n  hooks:\n    - go generate ./...\n    - go mod download\n\nbuilds:\n\n  - id: dynamic\n    binary: supervisord\n    env:\n      - CGO_ENABLED=0\n    ldflags:\n      - \"-s -w\"\n    flags:\n      - -tags=release\n    goos:\n      - linux\n      - darwin\n      - windows\n    goarch:\n      - amd64\n      - arm64\n      - arm\n    goarm:\n      - \"6\"\n      - \"7\"\n\n  - id: static\n    binary: supervisord\n    env:\n      - CGO_ENABLED=1\n    ldflags:\n      - \"-linkmode external -extldflags -static\"\n    flags:\n      - -tags=release\n    goos:\n      - linux\n    goarch:\n      - amd64\n      - arm64\n    overrides:\n      - goos: linux\n        goarch: amd64\n        env:\n          - CC=gcc\n\n      - goos: linux\n        goarch: arm64\n        env:\n          - CC=aarch64-linux-gnu-gcc\n    hooks:\n      post:\n        - cmd: upx \"{{ .Path }}\"\n\narchives:\n\n  - id: archive_multi\n    builds: [dynamic]\n    name_template: >-\n      {{ .ProjectName }}_{{ .Version }}_\n      {{- title .Os }}_\n      {{- if eq .Arch \"amd64\" }}x86_64\n      {{- else if eq .Arch \"386\" }}i386\n      {{- else }}{{ .Arch }}{{ end }}\n      {{- if .Arm }}v{{ .Arm }}{{ end }}\n    format: tar.gz\n    format_overrides:\n      - goos: windows\n        format: zip\n    wrap_in_directory: true\n    files:\n      - none*\n\n  - id: archive_static\n    builds: [static]\n    name_template: >-\n      {{ .ProjectName }}_static_{{ .Version }}_\n      {{- title .Os }}_\n      {{- if eq .Arch \"amd64\" }}x86_64\n      {{- else if eq .Arch \"386\" }}i386\n      {{- else }}{{ .Arch }}{{ end }}\n      {{- if .Arm }}v{{ .Arm }}{{ end }}\n    format: tar.gz\n    wrap_in_directory: true\n    files:\n      - none*\n\nrelease:\n  github:\n    owner: ochinchina\n    name: supervisord\n  draft: false\n  prerelease: auto\n  name_template: \"{{.ProjectName}}-v{{.Version}}\"\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3701171875,
          "content": "FROM golang:alpine AS builder\n\nRUN apk add --no-cache --update git gcc rust\n\nCOPY . /src\nWORKDIR /src\n\nRUN CGO_ENABLED=0 go build -a -ldflags \"-linkmode external -extldflags -static\" -o /usr/local/bin/supervisord github.com/ochinchina/supervisord\n\nFROM scratch\n\nCOPY --from=builder /usr/local/bin/supervisord /usr/local/bin/supervisord\n\nENTRYPOINT [\"/usr/local/bin/supervisord\"]\n"
        },
        {
          "name": "Dockerfile.github",
          "type": "blob",
          "size": 0.7490234375,
          "content": "# Use this file when golang.org/go.googlesource.com is blocked.\n#\n# Build with:\n#\n# docker build . -f Dockerfile.github -t ochinchina/supervisord:latest\n#\nFROM golang:alpine as builder\n\nRUN apk add --no-cache --update git\n\nRUN mkdir -p $GOPATH/src/golang.org/x && \\\n    cd $GOPATH/src/golang.org/x && \\\n    git clone https://github.com/golang/crypto && \\\n    git clone https://github.com/golang/sys\n\n# Exit 0 to ignore meta tag complaints\nRUN go get -v -u github.com/ochinchina/supervisord; exit 0\n\nRUN CGO_ENABLED=0 GOOS=linux go build -a -ldflags \"-extldflags -static\" -o /usr/local/bin/supervisord github.com/ochinchina/supervisord\n\nFROM scratch\n\nCOPY --from=builder /usr/local/bin/supervisord /usr/local/bin/supervisord\n\nENTRYPOINT [\"/usr/local/bin/supervisord\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2017 Steven Ou\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 12.6689453125,
          "content": "[![Go Report Card](https://goreportcard.com/badge/github.com/ochinchina/supervisord)](https://goreportcard.com/report/github.com/ochinchina/supervisord)\n\n# Why this project?\n\nThe python script supervisord is a powerful tool used by a lot of guys to manage the processes. I like  supervisord too.\n\nBut this tool requires that the big python environment be installed in target system. In some situation, for example in the docker environment, the python is too big for us.\n\nThis project re-implements supervisord in go-lang. Compiled supervisord is very suitable for environments where python is not installed.\n\n# Building the supervisord\n\nBefore compiling the supervisord, make sure the go-lang 1.11+ is installed in your environment.\n\nTo compile supervisord for **linux**, run following commands:\n\n1. go generate\n2. GOOS=linux go build -tags release -a -ldflags \"-linkmode external -extldflags -static\" -o supervisord\n\n# Run the supervisord\n\nAfter a supervisord binary has been generated, create a supervisord configuration file and start the supervisord like this:\n\n```Shell\n$ cat supervisor.conf\n[program:test]\ncommand = /your/program args\n$ supervisord -c supervisor.conf\n```\n\nPlease note that config-file location autodetected in this order:\n\n1. $CWD/supervisord.conf\n2. $CWD/etc/supervisord.conf\n3. /etc/supervisord.conf\n4. /etc/supervisor/supervisord.conf (since Supervisor 3.3.0)\n5. ../etc/supervisord.conf (Relative to the executable)\n6. ../supervisord.conf (Relative to the executable)\n\n\n# Run as daemon with web-ui\n\nAdd the inet interface in your configuration:\n\n```ini\n[inet_http_server]\nport=127.0.0.1:9001\n```\n\nthen run\n\n```shell\n$ supervisord -c supervisor.conf -d\n```\n\nIn order to manage the daemon, you can use `supervisord ctl` subcommand, available subcommands are: `status`, `start`, `stop`, `shutdown`, `reload`.\n\n```shell\n$ supervisord ctl status\n$ supervisord ctl status program-1 program-2...\n$ supervisord ctl status group:*\n$ supervisord ctl stop program-1 program-2...\n$ supervisord ctl stop group:*\n$ supervisord ctl stop all\n$ supervisord ctl start program-1 program-2...\n$ supervisord ctl start group:*\n$ supervisord ctl start all\n$ supervisord ctl shutdown\n$ supervisord ctl reload\n$ supervisord ctl signal <signal_name> <process_name> <process_name> ...\n$ supervisord ctl signal all\n$ supervisord ctl pid <process_name>\n$ supervisord ctl fg <process_name>\n```\n\nPlease note that `supervisor ctl` subcommand works correctly only if http server is enabled in [inet_http_server], and **serverurl** correctly set. Unix domain socket is not currently supported for this pupose.\n\nServerurl parameter detected in the following order:\n\n- check if option -s or --serverurl is present, use this url\n- check if -c option is present, and the \"serverurl\" in \"supervisorctl\" section is present, use \"serverurl\" in section \"supervisorctl\"\n- check if \"serverurl\" in section \"supervisorctl\" is defined in autodetected supervisord.conf-file location and if it is - use found value\n- use http://localhost:9001\n\n# Check the version\n\nCommand \"version\" will show the current supervisord binary version.\n\n```shell\n$ supervisord version\n```\n\n# Supported features\n\n## Http server\n\nHttp server can work via both unix domain socket and TCP. Basic auth is optional and supported too.\n\nThe unix domain socket setting is in the \"unix_http_server\" section.\nThe TCP http server setting is in \"inet_http_server\" section.\n\nIf both \"inet_http_server\" and \"unix_http_server\" are not set up in the configuration file, no http server will be started.\n\n## Supervisord daemon settings\n\nFollowing parameters configured in \"supervisord\" section:\n\n- **logfile**. Where to put log of supervisord itself.\n- **logfile_maxbytes**. Rotate log-file after it exceeds this length.\n- **logfile_backups**. Number of rotated log-files to preserve.\n- **loglevel**. Logging verbosity, can be trace, debug, info, warning, error, fatal and panic (according to documentation of module used for this feature). Defaults to info.\n- **pidfile**. Full path to file containing process id of current supervisord instance.\n- **minfds**. Reserve al least this amount of file descriptors on supervisord startup. (Rlimit nofiles).\n- **minprocs**. Reserve at least this amount of processes resource on supervisord startup. (Rlimit noproc).\n- **identifier**. Identifier of this supervisord instance. Required if there is more than one supervisord run on one machine in same namespace.\n\n## Supervised program settings\n\nSupervised program settings configured in [program:programName] section and include these options:\n\n- **command**. Command to supervise. It can be given as full path to executable or can be calculated via PATH variable. Command line parameters also should be supplied in this string. \n- **process_name**. the process name\n- **numprocs**. number of process\n- **numprocs_start**. ??\n- **autostart**. Should be supervised command run on supervisord start? Defaults to **true**.\n- **startsecs**. The total number of seconds which the program needs to stay running after a startup to consider the start successful (moving the process from the STARTING state to the RUNNING state). Set to 0 to indicate that the program needn’t stay running for any particular amount of time.\n- **startretries**. The number of serial failure attempts that supervisord will allow when attempting to start the program before giving up and putting the process into an FATAL state. See Process States for explanation of the FATAL state.\n- **autorestart**. Automatically re-run supervised command if it dies.\n- **exitcodes**. The list of “expected” exit codes for this program used with autorestart. If the autorestart parameter is set to unexpected, and the process exits in any other way than as a result of a supervisor stop request, supervisord will restart the process if it exits with an exit code that is not defined in this list.\n- **stopsignal**. Signal to send to command to gracefully stop it. If more than one stopsignal is configured, when stoping the program, the supervisor will send the signals to the program one by one with interval \"stopwaitsecs\". If the program does not exit after all the signals sent to the program, supervisord will kill the program.\n- **stopwaitsecs**. Amount of time to wait before sending SIGKILL to supervised command to make it stop ungracefully.\n- **stdout_logfile**. Where STDOUT of supervised command should be redirected. (Particular values described lower in this file).\n- **stdout_logfile_maxbytes**. Log size after exceed which log will be rotated.\n- **stdout_logfile_backups**. Number of rotated log-files to preserve.\n- **redirect_stderr**. Should STDERR be redirected to STDOUT.\n- **stderr_logfile**. Where STDERR of supervised command should be redirected. (Particular values described lower in this file).\n- **stderr_logfile_maxbytes**. Log size after exceed which log will be rotated.\n- **stderr_logfile_backups**. Number of rotated log-files to preserve.\n- **environment**. List of VARIABLE=value to be passed to supervised program. It has higher priority than `envFiles`.\n- **envFiles**. List of .env files to be loaded and passed to supervised program. \n- **priority**. The relative priority of the program in the start and shutdown ordering\n- **user**. Sudo to this USER or USER:GROUP right before exec supervised command.\n- **directory**. Jump to this path and exec supervised command there.\n- **stopasgroup**. Also stop this program when stopping group of programs where this program is listed.\n- **killasgroup**. Also kill this program when stopping group of programs where this program is listed.\n- **restartpause**. Wait (at least) this amount of seconds after stpping suprevised program before strt it again.\n- **restart_when_binary_changed**. Boolean value (false or true) to control if the supervised command should be restarted when its executable binary changes. Defaults to false.\n- **restart_cmd_when_binary_changed**. The command to restart the program if the program binary itself is changed.\n- **restart_signal_when_binary_changed**. The signal sent to the program for restarting if the program binary is changed.\n- **restart_directory_monitor**. Path to be monitored for restarting purpose.\n- **restart_file_pattern**. If a file changes under restart_directory_monitor and filename matches this pattern, the supervised command will be restarted.\n- **restart_cmd_when_file_changed**. The command to restart the program if any monitored files under **restart_directory_monitor** with pattern **restart_file_pattern** are changed.\n- **restart_signal_when_file_changed**. The signal will be sent to the proram, such as Nginx, for restarting if any monitored files under **restart_directory_monitor** with pattern **restart_file_pattern** are changed.\n- **depends_on**. Define supervised command start dependency. If program A depends on program B, C, the program B, C will be started before program A. Example:\n\n```ini\n[program:A]\ndepends_on = B, C\n\n[program:B]\n...\n[program:C]\n...\n```\n\n## Set default parameters for all supervised programs\n\nAll common parameters that are identical for all supervised programs can be defined once in \"program-default\" section and omitted in all other program sections.\n\nIn example below the VAR1 and VAR2 environment variables apply to both test1 and test2 supervised programs:\n\n```ini\n[program-default]\nenvironment=VAR1=\"value1\",VAR2=\"value2\"\nenvFiles=global.env,prod.env\n\n[program:test1]\n...\n\n[program:test2]\n...\n\n```\n\n## Group\n\nSection \"group\" is supported and you can set \"programs\" item\n\n## Events\n\nSupervisord 3.x defined events are supported partially. Now it supports following events:\n\n- all process state related events\n- process communication event\n- remote communication event\n- tick related events\n- process log related events\n\n## Logs\n\nSupervisord can redirect stdout and stderr ( fields stdout_logfile, stderr_logfile ) of supervised programs to:\n\n- **/dev/null**. Ignore the log - send it to /dev/null.\n- **/dev/stdout**. Write log to STDOUT.\n- **/dev/stderr**. Write log to STDERR.\n- **syslog**. Send the log to local syslog service.\n- **syslog @[protocol:]host[:port]**. Send log events to remote syslog server. Protocol must be \"tcp\" or \"udp\", if missing, \"udp\" assumed. If port is missing, for \"udp\" protocol, it's defaults to 514 and for \"tcp\" protocol, it's value is 6514.\n- **file name**. Write log to specified file.\n\nMultiple log files can be configured for the stdout_logfile and stderr_logfile with ',' as delimiter. For example:\n\n```ini\nstdout_logfile = test.log, /dev/stdout\n```\n\n### syslog settings\n\nif write the log to the syslog, following additional parameter can be set like:\n```ini\nsyslog_facility=local0\nsyslog_tag=test\nsyslog_stdout_priority=info\nsyslog_stderr_priority=err\n```\n- **syslog_facility**, can be one of(case insensitive): KERNEL, USER, MAIL, DAEMON, AUTH, SYSLOG, LPR, NEWS, UUCP, CRON, AUTHPRIV, FTP, LOCAL0~LOCAL7\n- **syslog_stdout_priority**, can be one of(case insensitive): EMERG, ALERT, CRIT, ERR, WARN, NOTICE, INFO, DEBUG\n- **syslog_stderr_priority**, can be one of(case insensitive): EMERG, ALERT, CRIT, ERR, WARN, NOTICE, INFO, DEBUG\n\n\n# Web GUI\n\nSupervisord has builtin web GUI: you can start, stop & check the status of program from the GUI. Following picture shows the default web GUI:\n\n![alt text](https://github.com/ochinchina/supervisord/blob/master/go_supervisord_gui.png)\n\nPlease note that in order to see|use Web GUI you should configure it in /etc/supervisord.conf both in [inet_http_server] (and|or [unix_http_server] if you prefer unix domain socket) and [supervisorctl]:\n\n```ini\n[inet_http_server]\nport=127.0.0.1:9001\n;username=test1\n;password=thepassword\n\n[supervisorctl]\nserverurl=http://127.0.0.1:9001\n```\n\n# Usage from a Docker container\n\nsupervisord is compiled inside a Docker image to be used directly inside another image, from the Docker Hub version.\n\n```Dockerfile\nFROM debian:latest\nCOPY --from=ochinchina/supervisord:latest /usr/local/bin/supervisord /usr/local/bin/supervisord\nCMD [\"/usr/local/bin/supervisord\"]\n```\n\n# Integrate with Prometheus\n\nThe Prometheus node exporter supported supervisord metrics are now integrated into the supervisor. So there is no need to deploy an extra node_exporter to collect the supervisord metrics. To collect the metrics, the port parameter in section \"inet_http_server\" must be configured and the metrics server is started on the path /metrics of the supervisor http server.\n\nFor example, if the port parameter in \"inet_http_server\" is \"127.0.0.1:9001\" and then the metrics server should be accessed in url \"http://127.0.0.1:9001/metrics\" \n\n\n# Register service\n\nAutostart supervisord after os started. Look up supported platforms at [kardianos/service](https://github.com/kardianos/service).\n\n```Shell\n# install\nsudo supervisord service install -c full_path_to_conf_file\n# uninstall\nsudo supervisord service uninstall\n# start\nsupervisord service start\n# stop\nsupervisord service stop\n```\n\n"
        },
        {
          "name": "assets_dev.go",
          "type": "blob",
          "size": 0.14453125,
          "content": "//go:build !release\n// +build !release\n\npackage main\n\nimport (\n\t\"net/http\"\n)\n\n//HTTP auto generated\nvar HTTP http.FileSystem = http.Dir(\"./webgui\")\n"
        },
        {
          "name": "assets_release.go",
          "type": "blob",
          "size": 0.26953125,
          "content": "//go:build release\n// +build release\n\npackage main\n\nimport (\n\t\"embed\"\n\t\"io/fs\"\n\t\"net/http\"\n)\n\n//go:embed webgui\nvar content embed.FS\n\nvar HTTP http.FileSystem\n\nfunc init() {\n\twebgui, err := fs.Sub(content, \"webgui\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tHTTP = http.FS(webgui)\n}\n"
        },
        {
          "name": "circle.yml",
          "type": "blob",
          "size": 0.353515625,
          "content": "deployment:\n  master:\n    branch: [master]\n    commands:\n      - go version\n      - go get github.com/mitchellh/gox\n      - go get github.com/tcnksm/ghr\n      - gox -output \"dist/supervisord_{{.OS}}_{{.Arch}}\" -osarch=\"linux/amd64 linux/386 darwin/amd64\"\n      - ghr -t $GITHUB_TOKEN -u $CIRCLE_PROJECT_USERNAME -r $CIRCLE_PROJECT_REPONAME --replace v1.0.0 dist/"
        },
        {
          "name": "confApi.go",
          "type": "blob",
          "size": 1.068359375,
          "content": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype ConfApi struct {\n\trouter     *mux.Router\n\tsupervisor *Supervisor\n}\n\n// NewLogtail creates a Logtail object\nfunc NewConfApi(supervisor *Supervisor) *ConfApi {\n\treturn &ConfApi{router: mux.NewRouter(), supervisor: supervisor}\n}\n\n// CreateHandler creates http handlers to process the program stdout and stderr through http interface\nfunc (ca *ConfApi) CreateHandler() http.Handler {\n\tca.router.HandleFunc(\"/conf/{program}\", ca.getProgramConfFile).Methods(\"GET\")\n\treturn ca.router\n}\n\nfunc (ca *ConfApi) getProgramConfFile(writer http.ResponseWriter, request *http.Request) {\n\tvars := mux.Vars(request)\n\tif vars == nil {\n\t\twriter.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tprogramName := vars[\"program\"]\n\tprogramConfigPath := getProgramConfigPath(programName, ca.supervisor)\n\tif programConfigPath == \"\" {\n\t\twriter.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\tb, err := readFile(programConfigPath)\n\tif err != nil {\n\t\twriter.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\twriter.WriteHeader(http.StatusOK)\n\twriter.Write(b)\n}\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "config_template.go",
          "type": "blob",
          "size": 3.00390625,
          "content": "package main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\nvar configTemplate = `[unix_http_server]\nfile=/tmp/supervisord.sock\n#chmod=not support\n#chown=not support\nusername=test1\npassword={SHA}82ab876d1387bfafe46cc1c8a2ef074eae50cb1d\n\n[inet_http_server]\nport=127.0.0.1:9001\nusername=test1\npassword=thepassword\n\n[supervisord]\nlogfile=%(here)s/supervisord.log\nlogfileMaxbytes=50MB\nlogfileBackups=10\nloglevel=info\npidfile=%(here)s/supervisord.pid\n#umask=not support\n#nodaemon=not support\n#minfds=not support\n#minprocs=not support\n#nocleanup=not support\n#childlogdir=not support\n#user=not support\n#directory=not support\n#strip_ansi=not support\n#environment=not support\nidentifier=supervisor\n\n[program:x]\ncommand=/bin/cat\nprocess_name=%(program_name)s\nnumprocs=1\n#numprocs_start=not support\nautostart=true\nstartsecs=3\nstartretries=3\nautorestart=true\nexitcodes=0,2\nstopsignal=TERM\nstopwaitsecs=10\nstopasgroup=true\nkillasgroup=true\nuser=user1\nredirect_stderr=false\nstdout_logfile=AUTO\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_capture_maxbytes=0\nstdout_events_enabled=true\nstderr_logfile=AUTO\nstderr_logfile_maxbytes=50MB\nstderr_logfile_backups=10\nstderr_capture_maxbytes=0\nstderr_events_enabled=false\nenvironment=KEY=\"val\",KEY2=\"val2\"\nenvFiles=global.env,prod.env\ndirectory=/tmp\n#umask=not support\nserverurl=AUTO\n\n[include]\nfiles=/an/absolute/filename.conf /an/absolute/*.conf foo.conf config??.conf\n\n[group:x]\nprograms=bar,baz\npriority=999\n\n[eventlistener:x]\ncommand=/bin/eventlistener\nprocess_name=%(program_name)s\nnumprocs=1\n#numprocs_start=not support\nautostart=true\nstartsecs=3\nstartretries=3\nautorestart=true\nexitcodes=0,2\nstopsignal=TERM\nstopwaitsecs=10\n#stopasgroup=not support\n#killasgroup=not support\nuser=user1\nredirect_stderr=false\nstdout_logfile=AUTO\nstdout_logfile_maxbytes=50MB\nstdout_logfile_backups=10\nstdout_capture_maxbytes=0\nstdout_events_enabled=true\nstderr_logfile=AUTO\nstderr_logfile_maxbytes=50MB\nstderr_logfile_backups=10\nstderr_capture_maxbytes=0\nstderr_events_enabled=false\nenvironment=KEY=\"val\",KEY2=\"val2\"\nenvFiles=global.env,prod.env\ndirectory=/tmp\n#umask=not support\nserverurl=AUTO\nbuffer_size=10240\nevents=PROCESS_STATE\n#result_handler=not support\n\n[supervisorctl]\nserverurl = unix:///tmp/supervisor.sock\nusername = chris\npassword = 123\n#prompt = not support\n`\n\n// InitTemplateCommand implements flags.Commander interface\ntype InitTemplateCommand struct {\n\tOutFile string `short:\"o\" long:\"output\" description:\"the output file name\" required:\"true\"`\n}\n\nvar initTemplateCommand InitTemplateCommand\n\n// Execute execute the init command\nfunc (x *InitTemplateCommand) Execute(args []string) error {\n\tf, err := os.Create(x.OutFile)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func(f *os.File) {\n\t\t_ = f.Close()\n\t}(f)\n\treturn GenTemplate(f)\n}\n\n// GenTemplate generate the template\nfunc GenTemplate(writer io.Writer) error {\n\t_, err := writer.Write([]byte(configTemplate))\n\treturn err\n}\n\nfunc init() {\n\tparser.AddCommand(\"init\",\n\t\t\"initialize a template\",\n\t\t\"The init subcommand writes the supported configurations to specified file\",\n\t\t&initTemplateCommand)\n\n}\n"
        },
        {
          "name": "content_checker.go",
          "type": "blob",
          "size": 3.3486328125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os/exec\"\n\t\"strings\"\n\t\"time\"\n)\n\n// ContentChecker defines check interface\ntype ContentChecker interface {\n\tCheck() bool\n}\n\n// BaseChecker basic implementation of ContentChecker\ntype BaseChecker struct {\n\tdata     string\n\tincludes []string\n\t// timeout in second\n\ttimeoutTime   time.Time\n\tnotifyChannel chan string\n}\n\n// NewBaseChecker creates BaseChecker object\nfunc NewBaseChecker(includes []string, timeout int) *BaseChecker {\n\treturn &BaseChecker{data: \"\",\n\t\tincludes:      includes,\n\t\ttimeoutTime:   time.Now().Add(time.Duration(timeout) * time.Second),\n\t\tnotifyChannel: make(chan string, 1)}\n}\n\n// Write data to the checker\nfunc (bc *BaseChecker) Write(b []byte) (int, error) {\n\tbc.notifyChannel <- string(b)\n\treturn len(b), nil\n}\n\nfunc (bc *BaseChecker) isReady() bool {\n\tfor _, include := range bc.includes {\n\t\tif strings.Index(bc.data, include) == -1 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Check content of the input data\nfunc (bc *BaseChecker) Check() bool {\n\td := bc.timeoutTime.Sub(time.Now())\n\tif d < 0 {\n\t\treturn false\n\t}\n\ttimeoutSignal := time.After(d)\n\n\tfor {\n\t\tselect {\n\t\tcase data := <-bc.notifyChannel:\n\t\t\tbc.data = bc.data + data\n\t\t\tif bc.isReady() {\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase <-timeoutSignal:\n\t\t\treturn false\n\t\t}\n\t}\n}\n\n// ScriptChecker implements ContentChecker by calling external script\ntype ScriptChecker struct {\n\targs []string\n}\n\n// NewScriptChecker creates ScriptChecker object\nfunc NewScriptChecker(args []string) *ScriptChecker {\n\treturn &ScriptChecker{args: args}\n}\n\n// Check return code of the script. If return code is 0, check is successful\nfunc (sc *ScriptChecker) Check() bool {\n\tcmd := exec.Command(sc.args[0])\n\tif len(sc.args) > 1 {\n\t\tcmd.Args = sc.args\n\t}\n\terr := cmd.Run()\n\treturn err == nil && cmd.ProcessState != nil && cmd.ProcessState.Success()\n}\n\n// TCPChecker check by TCP protocol\ntype TCPChecker struct {\n\thost        string\n\tport        int\n\tconn        net.Conn\n\tbaseChecker *BaseChecker\n}\n\n// NewTCPChecker creates TCPChecker object\nfunc NewTCPChecker(host string, port int, includes []string, timeout int) *TCPChecker {\n\tchecker := &TCPChecker{host: host,\n\t\tport:        port,\n\t\tbaseChecker: NewBaseChecker(includes, timeout)}\n\tchecker.start()\n\treturn checker\n}\n\nfunc (tc *TCPChecker) start() {\n\tgo func() {\n\t\tb := make([]byte, 1024)\n\t\tvar err error\n\t\tfor {\n\t\t\ttc.conn, err = net.Dial(\"tcp\", fmt.Sprintf(\"%s:%d\", tc.host, tc.port))\n\t\t\tif err == nil || tc.baseChecker.timeoutTime.Before(time.Now()) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif err == nil {\n\t\t\tfor {\n\t\t\t\tn, err := tc.conn.Read(b)\n\t\t\t\tif err != nil {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\ttc.baseChecker.Write(b[0:n])\n\t\t\t}\n\t\t}\n\t}()\n}\n\n// Check if it is ready by reading the tcp data\nfunc (tc *TCPChecker) Check() bool {\n\tret := tc.baseChecker.Check()\n\tif tc.conn != nil {\n\t\ttc.conn.Close()\n\t}\n\treturn ret\n}\n\n// HTTPChecker implements the ContentChecker by HTTP protocol\ntype HTTPChecker struct {\n\turl         string\n\ttimeoutTime time.Time\n}\n\n// NewHTTPChecker creates HTTPChecker object\nfunc NewHTTPChecker(url string, timeout int) *HTTPChecker {\n\treturn &HTTPChecker{url: url,\n\t\ttimeoutTime: time.Now().Add(time.Duration(timeout) * time.Second)}\n}\n\n// Check content of HTTP response\nfunc (hc *HTTPChecker) Check() bool {\n\tfor {\n\t\tif hc.timeoutTime.After(time.Now()) {\n\t\t\tresp, err := http.Get(hc.url)\n\t\t\tif err == nil {\n\t\t\t\treturn resp.StatusCode >= 200 && resp.StatusCode < 300\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "content_checker_test.go",
          "type": "blob",
          "size": 2.189453125,
          "content": "package main\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestBaseCheckOk(t *testing.T) {\n\tchecker := NewBaseChecker([]string{\"Hello\", \"world\"}, 10)\n\n\tgo func() {\n\t\tchecker.Write([]byte(\"this is a world\"))\n\t\ttime.Sleep(2 * time.Second)\n\t\tchecker.Write([]byte(\"Hello, how are you?\"))\n\t}()\n\tif !checker.Check() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestBaseCheckFail(t *testing.T) {\n\tchecker := NewBaseChecker([]string{\"Hello\", \"world\"}, 2)\n\n\tgo func() {\n\t\tchecker.Write([]byte(\"this is a world\"))\n\t}()\n\tif checker.Check() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestTcpCheckOk(t *testing.T) {\n\tgo func() {\n\t\tlistener, err := net.Listen(\"tcp\", \":8999\")\n\t\tif err == nil {\n\t\t\tdefer listener.Close()\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err == nil {\n\t\t\t\tdefer conn.Close()\n\t\t\t\tconn.Write([]byte(\"this is a world\"))\n\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\tconn.Write([]byte(\"Hello, how are you?\"))\n\t\t\t}\n\t\t}\n\t}()\n\tchecker := NewTCPChecker(\"127.0.0.1\", 8999, []string{\"Hello\", \"world\"}, 10)\n\tif !checker.Check() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestTcpCheckFail(t *testing.T) {\n\tgo func() {\n\t\tlistener, err := net.Listen(\"tcp\", \":8989\")\n\t\tif err == nil {\n\t\t\tconn, err := listener.Accept()\n\t\t\tif err == nil {\n\t\t\t\tconn.Write([]byte(\"this is a world\"))\n\t\t\t\ttime.Sleep(3 * time.Second)\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t\tlistener.Close()\n\t\t}\n\t}()\n\tchecker := NewTCPChecker(\"127.0.0.1\", 8989, []string{\"Hello\", \"world\"}, 2)\n\tif checker.Check() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestHttpCheckOk(t *testing.T) {\n\tgo func() {\n\t\tlistener, err := net.Listen(\"tcp\", \":8999\")\n\t\tif err == nil {\n\n\t\t\thttp.Serve(listener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tdefer listener.Close()\n\t\t\t\tw.WriteHeader(http.StatusOK)\n\t\t\t\tw.Write([]byte(\"this is an response\"))\n\t\t\t}))\n\n\t\t}\n\t}()\n\tchecker := NewHTTPChecker(\"http://127.0.0.1:8999\", 2)\n\tif !checker.Check() {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestHttpCheckFail(t *testing.T) {\n\tgo func() {\n\t\tlistener, err := net.Listen(\"tcp\", \":8999\")\n\t\tif err == nil {\n\t\t\thttp.Serve(listener, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\t\t\tdefer listener.Close()\n\t\t\t\tw.WriteHeader(http.StatusNotFound)\n\t\t\t\tw.Write([]byte(\"not found\"))\n\t\t\t}))\n\n\t\t}\n\t}()\n\tchecker := NewHTTPChecker(\"http://127.0.0.1:8999\", 2)\n\tif checker.Check() {\n\t\tt.Fail()\n\t}\n}\n"
        },
        {
          "name": "ctl.go",
          "type": "blob",
          "size": 13.9482421875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/jessevdk/go-flags\"\n\t\"github.com/ochinchina/supervisord/config\"\n\t\"github.com/ochinchina/supervisord/types\"\n\t\"github.com/ochinchina/supervisord/xmlrpcclient\"\n)\n\n// CtlCommand the entry of ctl command\ntype CtlCommand struct {\n\tServerURL string `short:\"s\" long:\"serverurl\" description:\"URL on which supervisord server is listening\"`\n\tUser      string `short:\"u\" long:\"user\" description:\"the user name\"`\n\tPassword  string `short:\"P\" long:\"password\" description:\"the password\"`\n\tVerbose   bool   `short:\"v\" long:\"verbose\" description:\"Show verbose debug information\"`\n}\n\n// StatusCommand get the status of all supervisor managed programs\ntype StatusCommand struct {\n}\n\n// StartCommand start the given program\ntype StartCommand struct {\n}\n\n// StopCommand stop the given program\ntype StopCommand struct {\n}\n\n// RestartCommand restart the given program\ntype RestartCommand struct {\n}\n\n// ShutdownCommand shutdown the supervisor\ntype ShutdownCommand struct {\n}\n\n// ReloadCommand reload all the programs\ntype ReloadCommand struct {\n}\n\n// PidCommand get the pid of program\ntype PidCommand struct {\n}\n\n// SignalCommand send signal of program\ntype SignalCommand struct {\n}\n\n// LogtailCommand tail the stdout/stderr log of program through http interface\ntype LogtailCommand struct {\n}\n\n// CmdCheckWrapperCommand A wrapper can be used to check whether\n// number of parameters is valid or not\ntype CmdCheckWrapperCommand struct {\n\t// Original cmd\n\tcmd flags.Commander\n\t// leastNumArgs indicates how many arguments\n\t// this cmd should have at least\n\tleastNumArgs int\n\t// Print usage when arguments not valid\n\tusage string\n}\n\nvar ctlCommand CtlCommand\nvar statusCommand = CmdCheckWrapperCommand{&StatusCommand{}, 0, \"\"}\nvar startCommand = CmdCheckWrapperCommand{&StartCommand{}, 0, \"\"}\nvar stopCommand = CmdCheckWrapperCommand{&StopCommand{}, 0, \"\"}\nvar restartCommand = CmdCheckWrapperCommand{&RestartCommand{}, 0, \"\"}\nvar shutdownCommand = CmdCheckWrapperCommand{&ShutdownCommand{}, 0, \"\"}\nvar reloadCommand = CmdCheckWrapperCommand{&ReloadCommand{}, 0, \"\"}\nvar pidCommand = CmdCheckWrapperCommand{&PidCommand{}, 1, \"pid <program>\"}\nvar signalCommand = CmdCheckWrapperCommand{&SignalCommand{}, 2, \"signal <signal_name> <program>[...]\"}\nvar logtailCommand = CmdCheckWrapperCommand{&LogtailCommand{}, 1, \"logtail <program>\"}\n\nfunc (x *CtlCommand) getServerURL() string {\n\toptions.Configuration, _ = findSupervisordConf()\n\n\tif x.ServerURL != \"\" {\n\t\treturn x.ServerURL\n\t} else if _, err := os.Stat(options.Configuration); err == nil {\n\t\tmyconfig := config.NewConfig(options.Configuration)\n\t\tmyconfig.Load()\n\t\tif entry, ok := myconfig.GetSupervisorctl(); ok {\n\t\t\tserverurl := entry.GetString(\"serverurl\", \"\")\n\t\t\tif serverurl != \"\" {\n\t\t\t\treturn serverurl\n\t\t\t}\n\t\t}\n\t}\n\treturn \"http://localhost:9001\"\n}\n\nfunc (x *CtlCommand) getUser() string {\n\toptions.Configuration, _ = findSupervisordConf()\n\n\tif x.User != \"\" {\n\t\treturn x.User\n\t} else if _, err := os.Stat(options.Configuration); err == nil {\n\t\tmyconfig := config.NewConfig(options.Configuration)\n\t\tmyconfig.Load()\n\t\tif entry, ok := myconfig.GetSupervisorctl(); ok {\n\t\t\tuser := entry.GetString(\"username\", \"\")\n\t\t\treturn user\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (x *CtlCommand) getPassword() string {\n\toptions.Configuration, _ = findSupervisordConf()\n\n\tif x.Password != \"\" {\n\t\treturn x.Password\n\t} else if _, err := os.Stat(options.Configuration); err == nil {\n\t\tmyconfig := config.NewConfig(options.Configuration)\n\t\tmyconfig.Load()\n\t\tif entry, ok := myconfig.GetSupervisorctl(); ok {\n\t\t\tpassword := entry.GetString(\"password\", \"\")\n\t\t\treturn password\n\t\t}\n\t}\n\treturn \"\"\n}\n\nfunc (x *CtlCommand) createRPCClient() *xmlrpcclient.XMLRPCClient {\n\trpcc := xmlrpcclient.NewXMLRPCClient(x.getServerURL(), x.Verbose)\n\trpcc.SetUser(x.getUser())\n\trpcc.SetPassword(x.getPassword())\n\treturn rpcc\n}\n\n// Execute implements flags.Commander interface to execute the control commands\nfunc (x *CtlCommand) Execute(args []string) error {\n\tif len(args) == 0 {\n\t\treturn nil\n\t}\n\n\trpcc := x.createRPCClient()\n\tverb := args[0]\n\n\tswitch verb {\n\n\t////////////////////////////////////////////////////////////////////////////////\n\t// STATUS\n\t////////////////////////////////////////////////////////////////////////////////\n\tcase \"status\":\n\t\tx.status(rpcc, args[1:])\n\n\t\t////////////////////////////////////////////////////////////////////////////////\n\t\t// START or STOP\n\t\t////////////////////////////////////////////////////////////////////////////////\n\tcase \"start\", \"stop\":\n\t\tx.startStopProcesses(rpcc, verb, args[1:])\n\n\t\t////////////////////////////////////////////////////////////////////////////////\n\t\t// SHUTDOWN\n\t\t////////////////////////////////////////////////////////////////////////////////\n\tcase \"shutdown\":\n\t\tx.shutdown(rpcc)\n\tcase \"reload\":\n\t\tx.reload(rpcc)\n\tcase \"signal\":\n\t\tsigName, processes := args[1], args[2:]\n\t\tx.signal(rpcc, sigName, processes)\n\tcase \"pid\":\n\t\tx.getPid(rpcc, args[1])\n\tdefault:\n\t\tfmt.Println(\"unknown command\")\n\t}\n\n\treturn nil\n}\n\n// get the status of processes\nfunc (x *CtlCommand) status(rpcc *xmlrpcclient.XMLRPCClient, processes []string) {\n\tprocessesMap := make(map[string]bool)\n\tfor _, process := range processes {\n\t\tprocessesMap[process] = true\n\t}\n\tif reply, err := rpcc.GetAllProcessInfo(); err == nil {\n\t\tx.showProcessInfo(&reply, processesMap)\n\t} else {\n\t\tos.Exit(1)\n\t}\n}\n\n// start or stop the processes\n// verb must be: start or stop\nfunc (x *CtlCommand) startStopProcesses(rpcc *xmlrpcclient.XMLRPCClient, verb string, processes []string) {\n\tstate := map[string]string{\n\t\t\"start\": \"started\",\n\t\t\"stop\":  \"stopped\",\n\t}\n\tx._startStopProcesses(rpcc, verb, processes, state[verb], true)\n}\n\nfunc (x *CtlCommand) _startStopProcesses(rpcc *xmlrpcclient.XMLRPCClient, verb string, processes []string, state string, showProcessInfo bool) {\n\tif len(processes) <= 0 {\n\t\tfmt.Printf(\"Please specify process for %s\\n\", verb)\n\t}\n\tfor _, pname := range processes {\n\t\tif pname == \"all\" {\n\t\t\treply, err := rpcc.ChangeAllProcessState(verb)\n\t\t\tif err == nil {\n\t\t\t\tif showProcessInfo {\n\t\t\t\t\tx.showProcessInfo(&reply, make(map[string]bool))\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Fail to change all process state to %s\", state)\n\t\t\t}\n\t\t} else {\n\t\t\tif reply, err := rpcc.ChangeProcessState(verb, pname); err == nil {\n\t\t\t\tif showProcessInfo {\n\t\t\t\t\tfmt.Printf(\"%s: \", pname)\n\t\t\t\t\tif !reply.Value {\n\t\t\t\t\t\tfmt.Printf(\"not \")\n\t\t\t\t\t}\n\t\t\t\t\tfmt.Printf(\"%s\\n\", state)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"%s: failed [%v]\\n\", pname, err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (x *CtlCommand) restartProcesses(rpcc *xmlrpcclient.XMLRPCClient, processes []string) {\n\tx._startStopProcesses(rpcc, \"stop\", processes, \"stopped\", false)\n\tx._startStopProcesses(rpcc, \"start\", processes, \"restarted\", true)\n}\n\n// shutdown the supervisord\nfunc (x *CtlCommand) shutdown(rpcc *xmlrpcclient.XMLRPCClient) {\n\tif reply, err := rpcc.Shutdown(); err == nil {\n\t\tif reply.Value {\n\t\t\tfmt.Printf(\"Shut Down\\n\")\n\t\t} else {\n\t\t\tfmt.Printf(\"Hmmm! Something gone wrong?!\\n\")\n\t\t}\n\t} else {\n\t\tos.Exit(1)\n\t}\n}\n\n// reload all the programs in the supervisord\nfunc (x *CtlCommand) reload(rpcc *xmlrpcclient.XMLRPCClient) {\n\tif reply, err := rpcc.ReloadConfig(); err == nil {\n\n\t\tif len(reply.AddedGroup) > 0 {\n\t\t\tfmt.Printf(\"Added Groups: %s\\n\", strings.Join(reply.AddedGroup, \",\"))\n\t\t}\n\t\tif len(reply.ChangedGroup) > 0 {\n\t\t\tfmt.Printf(\"Changed Groups: %s\\n\", strings.Join(reply.ChangedGroup, \",\"))\n\t\t}\n\t\tif len(reply.RemovedGroup) > 0 {\n\t\t\tfmt.Printf(\"Removed Groups: %s\\n\", strings.Join(reply.RemovedGroup, \",\"))\n\t\t}\n\t} else {\n\t\tos.Exit(1)\n\t}\n}\n\n// send signal to one or more processes\nfunc (x *CtlCommand) signal(rpcc *xmlrpcclient.XMLRPCClient, sigName string, processes []string) {\n\tfor _, process := range processes {\n\t\tif process == \"all\" {\n\t\t\treply, err := rpcc.SignalAll(process)\n\t\t\tif err == nil {\n\t\t\t\tx.showProcessInfo(&reply, make(map[string]bool))\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Fail to send signal %s to all process\", sigName)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t} else {\n\t\t\treply, err := rpcc.SignalProcess(sigName, process)\n\t\t\tif err == nil && reply.Success {\n\t\t\t\tfmt.Printf(\"Succeed to send signal %s to process %s\\n\", sigName, process)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"Fail to send signal %s to process %s\\n\", sigName, process)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// get the pid of running program\nfunc (x *CtlCommand) getPid(rpcc *xmlrpcclient.XMLRPCClient, process string) {\n\tprocInfo, err := rpcc.GetProcessInfo(process)\n\tif err != nil {\n\t\tfmt.Printf(\"program '%s' not found\\n\", process)\n\t\tos.Exit(1)\n\t} else {\n\t\tfmt.Printf(\"%d\\n\", procInfo.Pid)\n\t}\n}\n\nfunc (x *CtlCommand) getProcessInfo(rpcc *xmlrpcclient.XMLRPCClient, process string) (types.ProcessInfo, error) {\n\treturn rpcc.GetProcessInfo(process)\n}\n\n// check if group name should be displayed\nfunc (x *CtlCommand) showGroupName() bool {\n\tval, ok := os.LookupEnv(\"SUPERVISOR_GROUP_DISPLAY\")\n\tif !ok {\n\t\treturn false\n\t}\n\n\tval = strings.ToLower(val)\n\treturn val == \"yes\" || val == \"true\" || val == \"y\" || val == \"t\" || val == \"1\"\n}\n\nfunc (x *CtlCommand) showProcessInfo(reply *xmlrpcclient.AllProcessInfoReply, processesMap map[string]bool) {\n\tfor _, pinfo := range reply.Value {\n\t\tdescription := pinfo.Description\n\t\tif strings.ToLower(description) == \"<string></string>\" {\n\t\t\tdescription = \"\"\n\t\t}\n\t\tif x.inProcessMap(&pinfo, processesMap) {\n\t\t\tprocessName := pinfo.GetFullName()\n\t\t\tif !x.showGroupName() {\n\t\t\t\tprocessName = pinfo.Name\n\t\t\t}\n\t\t\tfmt.Printf(\"%s%-33s%-10s%s%s\\n\", x.getANSIColor(strings.ToUpper(pinfo.Statename)), processName, pinfo.Statename, description, \"\\x1b[0m\")\n\t\t}\n\t}\n}\n\nfunc (x *CtlCommand) inProcessMap(procInfo *types.ProcessInfo, processesMap map[string]bool) bool {\n\tif len(processesMap) <= 0 {\n\t\treturn true\n\t}\n\tfor procName := range processesMap {\n\t\tif procName == procInfo.Name || procName == procInfo.GetFullName() {\n\t\t\treturn true\n\t\t}\n\n\t\t// check the wildcast '*'\n\t\tpos := strings.Index(procName, \":\")\n\t\tif pos != -1 {\n\t\t\tgroupName := procName[0:pos]\n\t\t\tprogramName := procName[pos+1:]\n\t\t\tif programName == \"*\" && groupName == procInfo.Group {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (x *CtlCommand) getANSIColor(statename string) string {\n\tif statename == \"RUNNING\" {\n\t\t// green\n\t\treturn \"\\x1b[0;32m\"\n\t} else if statename == \"BACKOFF\" || statename == \"FATAL\" {\n\t\t// red\n\t\treturn \"\\x1b[0;31m\"\n\t} else {\n\t\t// yellow\n\t\treturn \"\\x1b[1;33m\"\n\t}\n}\n\n// Execute implements flags.Commander interface to get status of program\nfunc (sc *StatusCommand) Execute(args []string) error {\n\tctlCommand.status(ctlCommand.createRPCClient(), args)\n\treturn nil\n}\n\n// Execute start the given programs\nfunc (sc *StartCommand) Execute(args []string) error {\n\tctlCommand.startStopProcesses(ctlCommand.createRPCClient(), \"start\", args)\n\treturn nil\n}\n\n// Execute stop the given programs\nfunc (sc *StopCommand) Execute(args []string) error {\n\tctlCommand.startStopProcesses(ctlCommand.createRPCClient(), \"stop\", args)\n\treturn nil\n}\n\n// Execute restart the programs\nfunc (rc *RestartCommand) Execute(args []string) error {\n\tctlCommand.restartProcesses(ctlCommand.createRPCClient(), args)\n\treturn nil\n}\n\n// Execute shutdown the supervisor\nfunc (sc *ShutdownCommand) Execute(args []string) error {\n\tctlCommand.shutdown(ctlCommand.createRPCClient())\n\treturn nil\n}\n\n// Execute stop the running programs and reload the supervisor configuration\nfunc (rc *ReloadCommand) Execute(args []string) error {\n\tctlCommand.reload(ctlCommand.createRPCClient())\n\treturn nil\n}\n\n// Execute send signal to program\nfunc (rc *SignalCommand) Execute(args []string) error {\n\tsigName, processes := args[0], args[1:]\n\tctlCommand.signal(ctlCommand.createRPCClient(), sigName, processes)\n\treturn nil\n}\n\n// Execute get the pid of program\nfunc (pc *PidCommand) Execute(args []string) error {\n\tctlCommand.getPid(ctlCommand.createRPCClient(), args[0])\n\treturn nil\n}\n\n// Execute tail the stdout/stderr of a program through http interface\nfunc (lc *LogtailCommand) Execute(args []string) error {\n\tprogram := args[0]\n\tgo func() {\n\t\tlc.tailLog(program, \"stderr\")\n\t}()\n\treturn lc.tailLog(program, \"stdout\")\n}\n\nfunc (lc *LogtailCommand) tailLog(program string, dev string) error {\n\t_, err := ctlCommand.getProcessInfo(ctlCommand.createRPCClient(), program)\n\tif err != nil {\n\t\tfmt.Printf(\"Not exist program %s\\n\", program)\n\t\treturn err\n\t}\n\turl := fmt.Sprintf(\"%s/logtail/%s/%s\", ctlCommand.getServerURL(), program, dev)\n\treq, err := http.NewRequest(\"GET\", url, nil)\n\tif err != nil {\n\t\treturn err\n\t}\n\treq.SetBasicAuth(ctlCommand.getUser(), ctlCommand.getPassword())\n\tclient := http.Client{}\n\tresp, err := client.Do(req)\n\tif err != nil {\n\t\treturn err\n\t}\n\tbuf := make([]byte, 10240)\n\tfor {\n\t\tn, err := resp.Body.Read(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif dev == \"stdout\" {\n\t\t\tos.Stdout.Write(buf[0:n])\n\t\t} else {\n\t\t\tos.Stderr.Write(buf[0:n])\n\t\t}\n\t}\n\treturn nil\n}\n\n// Execute check if the number of arguments is ok\nfunc (wc *CmdCheckWrapperCommand) Execute(args []string) error {\n\tif len(args) < wc.leastNumArgs {\n\t\terr := fmt.Errorf(\"Invalid arguments.\\nUsage: supervisord ctl %v\", wc.usage)\n\t\tfmt.Printf(\"%v\\n\", err)\n\t\treturn err\n\t}\n\treturn wc.cmd.Execute(args)\n}\n\nfunc init() {\n\tctlCmd, _ := parser.AddCommand(\"ctl\",\n\t\t\"Control a running daemon\",\n\t\t\"The ctl subcommand resembles supervisorctl command of original daemon.\",\n\t\t&ctlCommand)\n\tctlCmd.AddCommand(\"status\",\n\t\t\"show program status\",\n\t\t\"show all or some program status\",\n\t\t&statusCommand)\n\tctlCmd.AddCommand(\"start\",\n\t\t\"start programs\",\n\t\t\"start one or more programs\",\n\t\t&startCommand)\n\tctlCmd.AddCommand(\"stop\",\n\t\t\"stop programs\",\n\t\t\"stop one or more programs\",\n\t\t&stopCommand)\n\tctlCmd.AddCommand(\"restart\",\n\t\t\"restart programs\",\n\t\t\"restart one or more programs\",\n\t\t&restartCommand)\n\tctlCmd.AddCommand(\"shutdown\",\n\t\t\"shutdown supervisord\",\n\t\t\"shutdown supervisord\",\n\t\t&shutdownCommand)\n\tctlCmd.AddCommand(\"reload\",\n\t\t\"reload the programs\",\n\t\t\"reload the programs\",\n\t\t&reloadCommand)\n\tctlCmd.AddCommand(\"signal\",\n\t\t\"send signal to program\",\n\t\t\"send signal to program\",\n\t\t&signalCommand)\n\tctlCmd.AddCommand(\"pid\",\n\t\t\"get the pid of specified program\",\n\t\t\"get the pid of specified program\",\n\t\t&pidCommand)\n\tctlCmd.AddCommand(\"logtail\",\n\t\t\"get the standard output&standard error of the program\",\n\t\t\"get the standard output&standard error of the program\",\n\t\t&logtailCommand)\n\n}\n"
        },
        {
          "name": "daemonize.go",
          "type": "blob",
          "size": 0.5615234375,
          "content": "//go:build !windows\n// +build !windows\n\npackage main\n\nimport (\n\t\"github.com/ochinchina/go-daemon\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// Daemonize run this process in daemon mode\nfunc Daemonize(logfile string, proc func()) {\n\tcontext := daemon.Context{LogFileName: logfile, PidFileName: \"supervisord.pid\"}\n\n\tchild, err := context.Reborn()\n\tif err != nil {\n\t\tcontext := daemon.Context{}\n\t\tchild, err = context.Reborn()\n\t\tif err != nil {\n\t\t\tlog.WithFields(log.Fields{\"err\": err}).Fatal(\"Unable to run\")\n\t\t}\n\t}\n\tif child != nil {\n\t\treturn\n\t}\n\tdefer context.Release()\n\tproc()\n}\n"
        },
        {
          "name": "daemonize_windows.go",
          "type": "blob",
          "size": 0.0869140625,
          "content": "// +build windows\n\npackage main\n\nfunc Daemonize(logfile string, proc func()) {\n\tproc()\n}\n"
        },
        {
          "name": "events",
          "type": "tree",
          "content": null
        },
        {
          "name": "faults",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.5302734375,
          "content": "module github.com/ochinchina/supervisord\n\ngo 1.17\n\nrequire (\n\tgithub.com/gorilla/mux v1.8.0\n\tgithub.com/gorilla/rpc v1.2.0\n\tgithub.com/jessevdk/go-flags v1.5.0\n\tgithub.com/kardianos/service v1.2.1\n\tgithub.com/ochinchina/go-daemon v0.1.5\n\tgithub.com/ochinchina/go-ini v1.0.1\n\tgithub.com/ochinchina/go-reaper v0.0.0-20181016012355-6b11389e79fc\n\tgithub.com/ochinchina/gorilla-xmlrpc v0.0.0-20171012055324-ecf2fe693a2c\n\tgithub.com/ochinchina/supervisord/config v0.0.0-20220721095143-c2527852d28f\n\tgithub.com/ochinchina/supervisord/events v0.0.0-20220721095143-c2527852d28f\n\tgithub.com/ochinchina/supervisord/faults v0.0.0-20220721095143-c2527852d28f\n\tgithub.com/ochinchina/supervisord/logger v0.0.0-20220721095143-c2527852d28f\n\tgithub.com/ochinchina/supervisord/process v0.0.0-20220520055329-8fdf6b62a44f\n\tgithub.com/ochinchina/supervisord/signals v0.0.0-20220721095143-c2527852d28f\n\tgithub.com/ochinchina/supervisord/types v0.0.0-20220520055329-8fdf6b62a44f\n\tgithub.com/ochinchina/supervisord/util v0.0.0-20220721095143-c2527852d28f\n\tgithub.com/ochinchina/supervisord/xmlrpcclient v0.0.0-20220520055329-8fdf6b62a44f\n\tgithub.com/prometheus/client_golang v1.12.2\n\tgithub.com/sirupsen/logrus v1.9.0\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.1.2 // indirect\n\tgithub.com/golang/protobuf v1.5.2 // indirect\n\tgithub.com/hashicorp/go-envparse v0.1.0 // indirect\n\tgithub.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.1 // indirect\n\tgithub.com/ochinchina/filechangemonitor v0.3.1 // indirect\n\tgithub.com/prometheus/client_model v0.2.0 // indirect\n\tgithub.com/prometheus/common v0.37.0 // indirect\n\tgithub.com/prometheus/procfs v0.7.3 // indirect\n\tgithub.com/robfig/cron/v3 v3.0.1 // indirect\n\tgithub.com/rogpeppe/go-charset v0.0.0-20190617161244-0dc95cdf6f31 // indirect\n\tgithub.com/stretchr/testify v1.7.1 // indirect\n\tgolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8 // indirect\n\tgoogle.golang.org/protobuf v1.28.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0 // indirect\n)\n\nreplace (\n\tgithub.com/ochinchina/supervisord/config => ./config\n\tgithub.com/ochinchina/supervisord/events => ./events\n\tgithub.com/ochinchina/supervisord/faults => ./faults\n\tgithub.com/ochinchina/supervisord/logger => ./logger\n\tgithub.com/ochinchina/supervisord/process => ./process\n\tgithub.com/ochinchina/supervisord/signals => ./signals\n\tgithub.com/ochinchina/supervisord/types => ./types\n\tgithub.com/ochinchina/supervisord/util => ./util\n\tgithub.com/ochinchina/supervisord/xmlrpcclient => ./xmlrpcclient\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 50.4345703125,
          "content": "cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=\ncloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=\ncloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=\ncloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=\ncloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=\ncloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=\ncloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=\ncloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=\ncloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=\ncloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=\ncloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=\ncloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=\ncloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=\ncloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=\ncloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=\ncloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=\ncloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=\ncloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=\ncloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=\ncloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=\ncloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=\ncloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=\ncloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=\ncloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=\ncloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=\ncloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=\ncloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=\ncloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/census-instrumentation/opencensus-proto v0.2.1/go.mod h1:f6KPmirojxKA12rnyqOA5BBL4O983OfeGPqjHWSTneU=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=\ngithub.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/cncf/udpa/go v0.0.0-20191209042840-269d4d468f6f/go.mod h1:M8M6+tZqaGXZJjfX53e64911xZQV5JYwmTeXPW+k8Sc=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/envoyproxy/go-control-plane v0.9.0/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.1-0.20191026205805-5f8ba28d4473/go.mod h1:YTl/9mNaCwkRvm6d1a2C3ymFceY/DCBVvsKhRF0iEA4=\ngithub.com/envoyproxy/go-control-plane v0.9.4/go.mod h1:6rpuAdCZL397s3pYoYcLgu1mIlRU8Am5FuJP05cCM98=\ngithub.com/envoyproxy/protoc-gen-validate v0.1.0/go.mod h1:iSmxcyjqTsJpI2R4NaDN7+kN2VEUnK/pcBlmesArF7c=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=\ngithub.com/go-kit/log v0.2.0/go.mod h1:NwTd00d/i8cPZ3xOwwiv2PO5MOcx78fFErGNcVmBjv0=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=\ngithub.com/go-logfmt/logfmt v0.5.1/go.mod h1:WYhtIu8zTZfxdn5+rREduYbwxfcBr/Vr6KEVveWlfTs=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.2/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.3/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.4/go.mod h1:vzj43D7+SQXF/4pzW/hwtAqwc6iTitCiVSaWz5lYuqw=\ngithub.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=\ngithub.com/golang/protobuf v1.4.0-rc.1/go.mod h1:ceaxUfeHdC40wWswd/P6IGgMaK3YpKi5j83Wpe3EHw8=\ngithub.com/golang/protobuf v1.4.0-rc.1.0.20200221234624-67d41d38c208/go.mod h1:xKAWHe0F5eneWXFV3EuXVDTCmh+JuBKY0li0aMyXATA=\ngithub.com/golang/protobuf v1.4.0-rc.2/go.mod h1:LlEzMj4AhA7rCAGe4KMBDvJI+AwstrUpVNzEA03Pprs=\ngithub.com/golang/protobuf v1.4.0-rc.4.0.20200313231945-b860323f09d0/go.mod h1:WU3c8KckQ9AFe+yFwt9sWVRKCVIyN9cPHBJSNnbL67w=\ngithub.com/golang/protobuf v1.4.0/go.mod h1:jodUvKwWbYaEsadDk5Fwe5c77LiNKVO9IDvqG2KuDX0=\ngithub.com/golang/protobuf v1.4.1/go.mod h1:U8fpvMrcmy5pZrNK1lt4xCsGvpyWQ/VVv6QDs8UjoX8=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.4.3/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2 h1:ROPKBNFfQgOUMifHyP+KYbvpjbdoFNs+aK7DXlji0Tw=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5 h1:Khx7svrCpmxxtHBq5j2mp/xVjsi8hQMfNLvJFAlrGgU=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvkdNIeFDP5koI=\ngithub.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/rpc v1.2.0 h1:WvvdC2lNeT1SP32zrIce5l0ECBfbAlmrmSBsuc57wfk=\ngithub.com/gorilla/rpc v1.2.0/go.mod h1:V4h9r+4sF5HnzqbwIez0fKSpANP0zlYd3qR7p36jkTQ=\ngithub.com/hashicorp/go-envparse v0.1.0 h1:bE++6bhIsNCPLvgDZkYqo3nA+/PFI51pkrHdmPSDFPY=\ngithub.com/hashicorp/go-envparse v0.1.0/go.mod h1:OHheN1GoygLlAkTlXLXvAdnXdZxy8JUweQ1rAXx1xnc=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/jessevdk/go-flags v1.5.0 h1:1jKYvbxEjfUl0fmqTCOfonvskHHXMjBySTLW4y9LFvc=\ngithub.com/jessevdk/go-flags v1.5.0/go.mod h1:Fw0T6WPc1dYxT4mKEZRfG5kJhaTDP9pj1c2EWnYs/m4=\ngithub.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.11/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=\ngithub.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0 h1:iQTw/8FWTuc7uiaSepXwyf3o52HaUYcV+Tu66S3F5GA=\ngithub.com/kardianos/osext v0.0.0-20190222173326-2bc1f35cddc0/go.mod h1:1NbS8ALrpOvjt0rHPNLyCIeMtbizbir8U//inJ+zuB8=\ngithub.com/kardianos/service v1.2.1 h1:AYndMsehS+ywIS6RB9KOlcXzteWUzxgMgBymJD7+BYk=\ngithub.com/kardianos/service v1.2.1/go.mod h1:CIMRFEJVL+0DS1a3Nx06NaMn4Dz63Ng6O7dl0qH0zVM=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.3/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1 h1:4hp9jkHxhMHkqkrB3Ix0jegS5sx/RkqARlsWZ6pIwiU=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/ochinchina/filechangemonitor v0.3.1 h1:Fyt8iE44kFwmI3ncNWAi21GZnmRBrAUSlMunpcDlMjQ=\ngithub.com/ochinchina/filechangemonitor v0.3.1/go.mod h1:OLRTJMpgb3yP1zBKA2g5GMYsKzJUoLq01lNOsReEzbQ=\ngithub.com/ochinchina/go-daemon v0.1.5 h1:XZoQ1NUXfeIGkU5rgbAwiNb1sr5btc2NbUqYUXmR5Zs=\ngithub.com/ochinchina/go-daemon v0.1.5/go.mod h1:oqEZ8HaYtoTxjkIpaizQ75VT5PWgpVeIennFIYSIkzQ=\ngithub.com/ochinchina/go-ini v1.0.1 h1:qrKGrgxJjY+4H8aV7B2HPohShzHGrymW+/X1Gx933zU=\ngithub.com/ochinchina/go-ini v1.0.1/go.mod h1:Tqs5+JmccLSNMX1KXbbyG/B3ro4J9uXVYC5U5VOeRE8=\ngithub.com/ochinchina/go-reaper v0.0.0-20181016012355-6b11389e79fc h1:oyaVoTfmN7Xe06URvpaKK8GDZr0YJFKhmKi37rE0a3c=\ngithub.com/ochinchina/go-reaper v0.0.0-20181016012355-6b11389e79fc/go.mod h1:SmX+KYO+b7mEApGBUNwjdJpRQwAdb0Rlzoh8G77K55I=\ngithub.com/ochinchina/gorilla-xmlrpc v0.0.0-20171012055324-ecf2fe693a2c h1:6xgMUqscagnZicBedm1h4T3q6IQHbrrZp7bker+toOI=\ngithub.com/ochinchina/gorilla-xmlrpc v0.0.0-20171012055324-ecf2fe693a2c/go.mod h1:/gFmJ8Das0jFgYxzt/RkvAO62T/ZPcyTaZlOkEBu/jw=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=\ngithub.com/prometheus/client_golang v1.7.1/go.mod h1:PY5Wy2awLA44sXw4AOSfFBetzPP4j5+D6mVACh+pe2M=\ngithub.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=\ngithub.com/prometheus/client_golang v1.11.1/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=\ngithub.com/prometheus/client_golang v1.12.1/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=\ngithub.com/prometheus/client_golang v1.12.2 h1:51L9cDoUHVrXx4zWYlcLQIZ+d+VXHgqnYKkIuq4g/34=\ngithub.com/prometheus/client_golang v1.12.2/go.mod h1:3Z9XVyYiZYEO+YQWt3RD2R3jrbd179Rt297l4aS6nDY=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.0.0-20190812154241-14fe0d1b01d4/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0 h1:uq5h0d+GuxiXLJLNABMgp2qUWDPiLvgCzz2dUR+/W/M=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.10.0/go.mod h1:Tlit/dnDKsSWFlCLTWaA1cyBgKHSMdTB80sz/V91rCo=\ngithub.com/prometheus/common v0.26.0/go.mod h1:M7rCNAaPfAosfx8veZJCuw84e35h3Cfd9VFqTh1DIvc=\ngithub.com/prometheus/common v0.32.1/go.mod h1:vu+V0TpY+O6vW9J44gczi3Ap/oXXR10b+M/gUGO4Hls=\ngithub.com/prometheus/common v0.37.0 h1:ccBbHCgIiT9uSoFY0vX8H3zsNR5eLt17/RQLUvn8pXE=\ngithub.com/prometheus/common v0.37.0/go.mod h1:phzohg0JFMnBEFGxTDbfu3QyL5GI8gTQJFhYO5B3mfA=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=\ngithub.com/prometheus/procfs v0.6.0/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=\ngithub.com/prometheus/procfs v0.7.3 h1:4jVXhlkAyzOScmCkXBTOLRLTz8EeU+eyjrwB/EPq0VU=\ngithub.com/prometheus/procfs v0.7.3/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=\ngithub.com/robfig/cron/v3 v3.0.1 h1:WdRxkvbJztn8LMz/QEvLN5sBU+xKpSqwwUO1Pjr4qDs=\ngithub.com/robfig/cron/v3 v3.0.1/go.mod h1:eQICP3HwyT7UooqI/z+Ov+PtYAWygg1TEWWzGIFLtro=\ngithub.com/rogpeppe/go-charset v0.0.0-20190617161244-0dc95cdf6f31 h1:DE4LcMKyqAVa6a0CGmVxANbnVb7stzMmPkQiieyNmfQ=\ngithub.com/rogpeppe/go-charset v0.0.0-20190617161244-0dc95cdf6f31/go.mod h1:qgYeAmZ5ZIpBWTGllZSQnw97Dj+woV0toclVaRGI8pc=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.6.0/go.mod h1:7uNnSEd1DgxDLC74fIahvMZmmYsHGZGEOFrfsX/uA88=\ngithub.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/sirupsen/logrus v1.9.0 h1:trlNQbNUG3OdDrDil03MCb1H2o9nJ1x4/5LYw7byDE0=\ngithub.com/sirupsen/logrus v1.9.0/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.1 h1:5TQK59W5E3v0r2duFAb7P95B6hEeOyEnHRa8MjYSMTY=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=\ngolang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=\ngolang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20210525063256-abc453219eb5/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20220127200216-cd36cc0744dd/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/net v0.0.0-20220225172249-27dd8689420f/go.mod h1:CfG3xpIq0wQ8r1q4Su4UZFWDARRcnwPjda9FqA0JpMk=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20210514164344-f6687ab2804c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20220223155221-ee480838109b/go.mod h1:DAh4E804XQdzx2j+YRIaUnCqCV2RuMz24cGBJ5QYIrc=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200625212154-ddb9806d33ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201015000850-e3ed0017c211/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210603081109-ebe580a85c40/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211216021012-1d35b9e2eb4e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220114195835-da31bd327af9/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8 h1:0A+M6Uqn+Eje4kHMK80dtF3JCXC4ykBgQG4Fe06QRhQ=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=\ngolang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=\ngoogle.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=\ngoogle.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=\ngoogle.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=\ngoogle.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=\ngoogle.golang.org/grpc v1.21.1/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=\ngoogle.golang.org/grpc v1.23.0/go.mod h1:Y5yQAOtifL1yxbo5wqy6BxZv8vAUGQwXBOALyacEbxg=\ngoogle.golang.org/grpc v1.25.1/go.mod h1:c3i+UQWmh7LiEpx4sFZnkU36qjEYZ0imhYfXVyQciAY=\ngoogle.golang.org/grpc v1.26.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.0/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.27.1/go.mod h1:qbnxyOmOxrQa7FizSgH+ReBfzJrCY1pSN7KXBS8abTk=\ngoogle.golang.org/grpc v1.28.0/go.mod h1:rpkK4SK4GF4Ach/+MFLZUBavHOvF2JJB5uozKKal+60=\ngoogle.golang.org/grpc v1.29.1/go.mod h1:itym6AZVZYACWQqET3MqgPpjcuV5QH3BxFS3IjizoKk=\ngoogle.golang.org/grpc v1.30.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/grpc v1.31.0/go.mod h1:N36X2cJ7JwdamYAgDz+s+rVMFjt3numwzf/HckM8pak=\ngoogle.golang.org/protobuf v0.0.0-20200109180630-ec00e32a8dfd/go.mod h1:DFci5gLYBciE7Vtevhsrf46CRTquxDuWsQurQQe4oz8=\ngoogle.golang.org/protobuf v0.0.0-20200221191635-4d8936d0db64/go.mod h1:kwYJMbMJ01Woi6D6+Kah6886xMZcty6N08ah7+eCXa0=\ngoogle.golang.org/protobuf v0.0.0-20200228230310-ab0ca4ff8a60/go.mod h1:cfTl7dwQJ+fmap5saPgwCLgHXTUD7jkjRqWcaiX5VyM=\ngoogle.golang.org/protobuf v1.20.1-0.20200309200217-e05f789c0967/go.mod h1:A+miEFZTKqfCUM6K7xSMQL9OKL/b6hQv+e19PK+JZNE=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.28.0 h1:w43yiav+6bVFTBQFZX0r7ipe9JQ1QsbMgHwbBziscLw=\ngoogle.golang.org/protobuf v1.28.0/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0 h1:hjy8E9ON/egN1tAYqKb61G10WtihqetD4sz2H+8nIeA=\ngopkg.in/yaml.v3 v3.0.0/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhonnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n"
        },
        {
          "name": "go_supervisord_gui.png",
          "type": "blob",
          "size": 49.9189453125,
          "content": null
        },
        {
          "name": "logger",
          "type": "tree",
          "content": null
        },
        {
          "name": "logtail.go",
          "type": "blob",
          "size": 2.208984375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"github.com/ochinchina/supervisord/logger\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// Logtail tails the process log through http interface\ntype Logtail struct {\n\trouter     *mux.Router\n\tsupervisor *Supervisor\n}\n\n// NewLogtail creates a Logtail object\nfunc NewLogtail(supervisor *Supervisor) *Logtail {\n\treturn &Logtail{router: mux.NewRouter(), supervisor: supervisor}\n}\n\n// CreateHandler creates http handlers to process the program stdout and stderr through http interface\nfunc (lt *Logtail) CreateHandler() http.Handler {\n\tlt.router.HandleFunc(\"/logtail/{program}/stdout\", lt.getStdoutLog).Methods(\"GET\")\n\tlt.router.HandleFunc(\"/logtail/{program}/stderr\", lt.getStderrLog).Methods(\"GET\")\n\treturn lt.router\n}\n\nfunc (lt *Logtail) getStdoutLog(w http.ResponseWriter, req *http.Request) {\n\tlt.getLog(\"stdout\", w, req)\n}\n\nfunc (lt *Logtail) getStderrLog(w http.ResponseWriter, req *http.Request) {\n\tlt.getLog(\"stderr\", w, req)\n}\n\nfunc (lt *Logtail) getLog(logType string, w http.ResponseWriter, req *http.Request) {\n\tvars := mux.Vars(req)\n\tprogram := vars[\"program\"]\n\tprocMgr := lt.supervisor.GetManager()\n\tproc := procMgr.Find(program)\n\n\tif proc == nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar ok bool = false\n\tvar compositeLogger *logger.CompositeLogger = nil\n\tif logType == \"stdout\" {\n\t\tcompositeLogger, ok = proc.StdoutLog.(*logger.CompositeLogger)\n\t} else {\n\t\tcompositeLogger, ok = proc.StderrLog.(*logger.CompositeLogger)\n\t}\n\n\tif !ok {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ts, err := compositeLogger.ReadLog(0, 0)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\treturn\n\t}\n\tw.Header().Set(\"Transfer-Encoding\", \"chunked\")\n\tw.WriteHeader(http.StatusOK)\n\n\tw.Write([]byte(s))\n\t//\n\t//if ok {\n\t//\tw.Header().Set(\"Transfer-Encoding\", \"chunked\")\n\t//\tw.WriteHeader(http.StatusOK)\n\t//\tflusher, _ := w.(http.Flusher)\n\t//\tch := make(chan []byte, 100)\n\t//\tchanLogger := logger.NewChanLogger(ch)\n\t//\tcompositeLogger.AddLogger(chanLogger)\n\t//\tfor {\n\t//\t\ttext, ok := <-ch\n\t//\t\tif !ok {\n\t//\t\t\tbreak\n\t//\t\t}\n\t//\t\t_, err := w.Write(text)\n\t//\t\tif err != nil {\n\t//\t\t\tbreak\n\t//\t\t}\n\t//\t\tflusher.Flush()\n\t//\t}\n\t//\tcompositeLogger.RemoveLogger(chanLogger)\n\t//\t_ = chanLogger.Close()\n\t//}\n\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 4.9794921875,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strings\"\n\t\"syscall\"\n\t\"unicode\"\n\n\t\"github.com/jessevdk/go-flags\"\n\t\"github.com/ochinchina/go-ini\"\n\t\"github.com/ochinchina/supervisord/config\"\n\t\"github.com/ochinchina/supervisord/logger\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// Options the command line options\ntype Options struct {\n\tConfiguration string `short:\"c\" long:\"configuration\" description:\"the configuration file\"`\n\tDaemon        bool   `short:\"d\" long:\"daemon\" description:\"run as daemon\"`\n\tEnvFile       string `long:\"env-file\" description:\"the environment file\"`\n}\n\nfunc init() {\n\tnullLogger := logger.NewNullLogger(logger.NewNullLogEventEmitter())\n\tlog.SetOutput(nullLogger)\n\tlogFormat := os.Getenv(\"LOG_FORMAT\")\n\tif logFormat == \"json\" {\n\t\tlog.SetFormatter(&log.JSONFormatter{})\n\t} else {\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tlog.SetFormatter(&log.TextFormatter{DisableColors: true, FullTimestamp: true})\n\t\t} else {\n\t\t\tlog.SetFormatter(&log.TextFormatter{DisableColors: false, FullTimestamp: true})\n\t\t}\n\t}\n\tlog.SetLevel(log.DebugLevel)\n}\n\nfunc initSignals(s *Supervisor) {\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)\n\tgo func() {\n\t\tsig := <-sigs\n\t\tlog.WithFields(log.Fields{\"signal\": sig}).Info(\"receive a signal to stop all process & exit\")\n\t\ts.procMgr.StopAllProcesses()\n\t\tos.Exit(-1)\n\t}()\n\n}\n\nvar options Options\nvar parser = flags.NewParser(&options, flags.Default & ^flags.PrintErrors)\n\nfunc loadEnvFile() {\n\tif len(options.EnvFile) <= 0 {\n\t\treturn\n\t}\n\t// try to open the environment file\n\tf, err := os.Open(options.EnvFile)\n\tif err != nil {\n\t\tlog.WithFields(log.Fields{\"file\": options.EnvFile}).Error(\"Fail to open environment file\")\n\t\treturn\n\t}\n\tdefer f.Close()\n\treader := bufio.NewReader(f)\n\tfor {\n\t\t// for each line\n\t\tline, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\t// if line starts with '#', it is a comment line, ignore it\n\t\tline = strings.TrimSpace(line)\n\t\tif len(line) > 0 && line[0] == '#' {\n\t\t\tcontinue\n\t\t}\n\t\t// if environment variable is exported with \"export\"\n\t\tif strings.HasPrefix(line, \"export\") && len(line) > len(\"export\") && unicode.IsSpace(rune(line[len(\"export\")])) {\n\t\t\tline = strings.TrimSpace(line[len(\"export\"):])\n\t\t}\n\t\t// split the environment variable with \"=\"\n\t\tpos := strings.Index(line, \"=\")\n\t\tif pos != -1 {\n\t\t\tk := strings.TrimSpace(line[0:pos])\n\t\t\tv := strings.TrimSpace(line[pos+1:])\n\t\t\t// if key and value are not empty, put it into the environment\n\t\t\tif len(k) > 0 && len(v) > 0 {\n\t\t\t\tos.Setenv(k, v)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// find the supervisord.conf in following order:\n//\n// 1. $CWD/supervisord.conf\n// 2. $CWD/etc/supervisord.conf\n// 3. /etc/supervisord.conf\n// 4. /etc/supervisor/supervisord.conf (since Supervisor 3.3.0)\n// 5. ../etc/supervisord.conf (Relative to the executable)\n// 6. ../supervisord.conf (Relative to the executable)\nfunc findSupervisordConf() (string, error) {\n\tpossibleSupervisordConf := []string{options.Configuration,\n\t\t\"./supervisord.ini\",\n\t\t\"./etc/supervisord.conf\",\n\t\t\"/etc/supervisord.conf\",\n\t\t\"/etc/supervisor/supervisord.conf\",\n\t\t\"../etc/supervisord.conf\",\n\t\t\"../supervisord.conf\"}\n\n\tfor _, file := range possibleSupervisordConf {\n\t\tif _, err := os.Stat(file); err == nil {\n\t\t\tabsFile, err := filepath.Abs(file)\n\t\t\tif err == nil {\n\t\t\t\treturn absFile, nil\n\t\t\t}\n\t\t\treturn file, nil\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"fail to find supervisord.conf\")\n}\n\nfunc runServer() {\n\t// infinite loop for handling Restart ('reload' command)\n\tloadEnvFile()\n\tfor {\n\t\tif len(options.Configuration) <= 0 {\n\t\t\toptions.Configuration, _ = findSupervisordConf()\n\t\t}\n\t\ts := NewSupervisor(options.Configuration)\n\t\tinitSignals(s)\n\t\tif _, _, _, sErr := s.Reload(true); sErr != nil {\n\t\t\tpanic(sErr)\n\t\t}\n\t\ts.WaitForExit()\n\t}\n}\n\n// Get the supervisord log file\nfunc getSupervisordLogFile(configFile string) string {\n\tconfigFileDir := filepath.Dir(configFile)\n\tenv := config.NewStringExpression(\"here\", configFileDir)\n\tmyini := ini.NewIni()\n\tmyini.LoadFile(configFile)\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tcwd = \".\"\n\t}\n\tlogFile := myini.GetValueWithDefault(\"supervisord\", \"logfile\", filepath.Join(cwd, \"supervisord.log\"))\n\tlogFile, err = env.Eval(logFile)\n\tif err == nil {\n\t\treturn logFile\n\t} else {\n\t\treturn filepath.Join(\".\", \"supervisord.log\")\n\t}\n}\n\nfunc main() {\n\tReapZombie()\n\n\t// when execute `supervisord` without sub-command, it should start the server\n\tparser.Command.SubcommandsOptional = true\n\tparser.CommandHandler = func(command flags.Commander, args []string) error {\n\t\tif command == nil {\n\t\t\tlog.SetOutput(os.Stdout)\n\t\t\tif options.Daemon {\n\t\t\t\tlogFile := getSupervisordLogFile(options.Configuration)\n\t\t\t\tDaemonize(logFile, runServer)\n\t\t\t} else {\n\t\t\t\trunServer()\n\t\t\t}\n\t\t\tos.Exit(0)\n\t\t}\n\t\treturn command.Execute(args)\n\t}\n\n\tif _, err := parser.Parse(); err != nil {\n\t\tflagsErr, ok := err.(*flags.Error)\n\t\tif ok {\n\t\t\tswitch flagsErr.Type {\n\t\t\tcase flags.ErrHelp:\n\t\t\t\t_, _ = fmt.Fprintln(os.Stdout, err)\n\t\t\t\tos.Exit(0)\n\t\t\tdefault:\n\t\t\t\t_, _ = fmt.Fprintf(os.Stderr, \"error when parsing command: %s\\n\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pidproxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "process",
          "type": "tree",
          "content": null
        },
        {
          "name": "rest-rpc.go",
          "type": "blob",
          "size": 5.03515625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/ochinchina/supervisord/types\"\n)\n\n// SupervisorRestful the restful interface to control the programs defined in configuration file\ntype SupervisorRestful struct {\n\trouter     *mux.Router\n\tsupervisor *Supervisor\n}\n\n// NewSupervisorRestful create a new SupervisorRestful object\nfunc NewSupervisorRestful(supervisor *Supervisor) *SupervisorRestful {\n\treturn &SupervisorRestful{router: mux.NewRouter(), supervisor: supervisor}\n}\n\n// CreateProgramHandler create http handler to process program related restful request\nfunc (sr *SupervisorRestful) CreateProgramHandler() http.Handler {\n\tsr.router.HandleFunc(\"/program/list\", sr.ListProgram).Methods(\"GET\")\n\tsr.router.HandleFunc(\"/program/start/{name}\", sr.StartProgram).Methods(\"POST\", \"PUT\")\n\tsr.router.HandleFunc(\"/program/stop/{name}\", sr.StopProgram).Methods(\"POST\", \"PUT\")\n\tsr.router.HandleFunc(\"/program/log/{name}/stdout\", sr.ReadStdoutLog).Methods(\"GET\")\n\tsr.router.HandleFunc(\"/program/startPrograms\", sr.StartPrograms).Methods(\"POST\", \"PUT\")\n\tsr.router.HandleFunc(\"/program/stopPrograms\", sr.StopPrograms).Methods(\"POST\", \"PUT\")\n\treturn sr.router\n}\n\n// CreateSupervisorHandler create http rest interface to control supervisor itself\nfunc (sr *SupervisorRestful) CreateSupervisorHandler() http.Handler {\n\tsr.router.HandleFunc(\"/supervisor/shutdown\", sr.Shutdown).Methods(\"PUT\", \"POST\")\n\tsr.router.HandleFunc(\"/supervisor/reload\", sr.Reload).Methods(\"PUT\", \"POST\")\n\treturn sr.router\n}\n\n// ListProgram list the status of all the programs\n//\n// json array to present the status of all programs\nfunc (sr *SupervisorRestful) ListProgram(w http.ResponseWriter, req *http.Request) {\n\tresult := struct{ AllProcessInfo []types.ProcessInfo }{make([]types.ProcessInfo, 0)}\n\tif sr.supervisor.GetAllProcessInfo(nil, nil, &result) == nil {\n\t\tjson.NewEncoder(w).Encode(result.AllProcessInfo)\n\t} else {\n\t\tr := map[string]bool{\"success\": false}\n\t\tjson.NewEncoder(w).Encode(r)\n\t}\n}\n\n// StartProgram start the given program through restful interface\nfunc (sr *SupervisorRestful) StartProgram(w http.ResponseWriter, req *http.Request) {\n\tdefer req.Body.Close()\n\tparams := mux.Vars(req)\n\tsuccess, err := sr._startProgram(params[\"name\"])\n\tr := map[string]bool{\"success\": err == nil && success}\n\tjson.NewEncoder(w).Encode(&r)\n}\n\nfunc (sr *SupervisorRestful) _startProgram(program string) (bool, error) {\n\tstartArgs := StartProcessArgs{Name: program, Wait: true}\n\tresult := struct{ Success bool }{false}\n\terr := sr.supervisor.StartProcess(nil, &startArgs, &result)\n\treturn result.Success, err\n}\n\n// StartPrograms start one or more programs through restful interface\nfunc (sr *SupervisorRestful) StartPrograms(w http.ResponseWriter, req *http.Request) {\n\tdefer req.Body.Close()\n\tvar b []byte\n\tvar err error\n\n\tif b, err = ioutil.ReadAll(req.Body); err != nil {\n\t\tw.WriteHeader(400)\n\t\tw.Write([]byte(\"not a valid request\"))\n\t\treturn\n\t}\n\n\tvar programs []string\n\tif err = json.Unmarshal(b, &programs); err != nil {\n\t\tw.WriteHeader(400)\n\t\tw.Write([]byte(\"not a valid request\"))\n\t} else {\n\t\tfor _, program := range programs {\n\t\t\tsr._startProgram(program)\n\t\t}\n\t\tw.Write([]byte(\"Success to start the programs\"))\n\t}\n}\n\n// StopProgram stop a program through the restful interface\nfunc (sr *SupervisorRestful) StopProgram(w http.ResponseWriter, req *http.Request) {\n\tdefer req.Body.Close()\n\n\tparams := mux.Vars(req)\n\tsuccess, err := sr._stopProgram(params[\"name\"])\n\tr := map[string]bool{\"success\": err == nil && success}\n\tjson.NewEncoder(w).Encode(&r)\n}\n\nfunc (sr *SupervisorRestful) _stopProgram(programName string) (bool, error) {\n\tstopArgs := StartProcessArgs{Name: programName, Wait: true}\n\tresult := struct{ Success bool }{false}\n\terr := sr.supervisor.StopProcess(nil, &stopArgs, &result)\n\treturn result.Success, err\n}\n\n// StopPrograms stop programs through the restful interface\nfunc (sr *SupervisorRestful) StopPrograms(w http.ResponseWriter, req *http.Request) {\n\tdefer req.Body.Close()\n\n\tvar programs []string\n\tvar b []byte\n\tvar err error\n\tif b, err = ioutil.ReadAll(req.Body); err != nil {\n\t\tw.WriteHeader(400)\n\t\tw.Write([]byte(\"not a valid request\"))\n\t\treturn\n\t}\n\n\tif err := json.Unmarshal(b, &programs); err != nil {\n\t\tw.WriteHeader(400)\n\t\tw.Write([]byte(\"not a valid request\"))\n\t} else {\n\t\tfor _, program := range programs {\n\t\t\tsr._stopProgram(program)\n\t\t}\n\t\tw.Write([]byte(\"Success to stop the programs\"))\n\t}\n\n}\n\n// ReadStdoutLog read the stdout of given program\nfunc (sr *SupervisorRestful) ReadStdoutLog(w http.ResponseWriter, req *http.Request) {\n}\n\n// Shutdown the supervisor itself\nfunc (sr *SupervisorRestful) Shutdown(w http.ResponseWriter, req *http.Request) {\n\tdefer req.Body.Close()\n\n\treply := struct{ Ret bool }{false}\n\tsr.supervisor.Shutdown(nil, nil, &reply)\n\tw.Write([]byte(\"Shutdown...\"))\n}\n\n// Reload the supervisor configuration file through rest interface\nfunc (sr *SupervisorRestful) Reload(w http.ResponseWriter, req *http.Request) {\n\tdefer req.Body.Close()\n\n\treply := struct{ Ret bool }{false}\n\tsr.supervisor.Reload(false)\n\tr := map[string]bool{\"success\": reply.Ret}\n\tjson.NewEncoder(w).Encode(&r)\n}\n"
        },
        {
          "name": "rlimit.go",
          "type": "blob",
          "size": 1.3603515625,
          "content": "// +build !windows,!freebsd\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\nfunc (s *Supervisor) checkRequiredResources() error {\n\tif minfds, vErr := s.getMinRequiredRes(\"minfds\"); vErr == nil {\n\t\treturn s.checkMinLimit(syscall.RLIMIT_NOFILE, \"NOFILE\", minfds)\n\t}\n\tif minprocs, vErr := s.getMinRequiredRes(\"minprocs\"); vErr == nil {\n\t\t// RPROC = 6\n\t\treturn s.checkMinLimit(6, \"NPROC\", minprocs)\n\t}\n\treturn nil\n\n}\n\nfunc (s *Supervisor) getMinRequiredRes(resourceName string) (uint64, error) {\n\tif entry, ok := s.config.GetSupervisord(); ok {\n\t\tvalue := uint64(entry.GetInt(resourceName, 0))\n\t\tif value > 0 {\n\t\t\treturn value, nil\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"No such key %s\", resourceName)\n\t\t}\n\t} else {\n\t\treturn 0, fmt.Errorf(\"No supervisord section\")\n\t}\n\n}\n\nfunc (s *Supervisor) checkMinLimit(resource int, resourceName string, minRequiredSource uint64) error {\n\tvar limit syscall.Rlimit\n\n\tif syscall.Getrlimit(resource, &limit) != nil {\n\t\treturn fmt.Errorf(\"fail to get the %s limit\", resourceName)\n\t}\n\n\tif minRequiredSource > limit.Max {\n\t\treturn fmt.Errorf(\"%s %d is greater than Hard limit %d\", resourceName, minRequiredSource, limit.Max)\n\t}\n\n\tif limit.Cur >= minRequiredSource {\n\t\treturn nil\n\t}\n\n\tlimit.Cur = limit.Max\n\tif syscall.Setrlimit(syscall.RLIMIT_NOFILE, &limit) != nil {\n\t\treturn fmt.Errorf(fmt.Sprintf(\"fail to set the %s to %d\", resourceName, limit.Cur))\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "rlimit_freebsd.go",
          "type": "blob",
          "size": 1.3466796875,
          "content": "// +build freebsd\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"syscall\"\n)\n\nfunc (s *Supervisor) checkRequiredResources() error {\n\tif minfds, vErr := s.getMinRequiredRes(\"minfds\"); vErr == nil {\n\t\treturn s.checkMinLimit(syscall.RLIMIT_NOFILE, \"NOFILE\", minfds)\n\t}\n\tif minprocs, vErr := s.getMinRequiredRes(\"minprocs\"); vErr == nil {\n\t\t//RPROC = 6\n\t\treturn s.checkMinLimit(6, \"NPROC\", minprocs)\n\t}\n\treturn nil\n\n}\n\nfunc (s *Supervisor) getMinRequiredRes(resourceName string) (int64, error) {\n\tif entry, ok := s.config.GetSupervisord(); ok {\n\t\tvalue := int64(entry.GetInt(resourceName, 0))\n\t\tif value > 0 {\n\t\t\treturn value, nil\n\t\t} else {\n\t\t\treturn 0, fmt.Errorf(\"No such key %s\", resourceName)\n\t\t}\n\t} else {\n\t\treturn 0, fmt.Errorf(\"No supervisord section\")\n\t}\n\n}\n\nfunc (s *Supervisor) checkMinLimit(resource int, resourceName string, minRequiredSource int64) error {\n\tvar limit syscall.Rlimit\n\n\tif syscall.Getrlimit(resource, &limit) != nil {\n\t\treturn fmt.Errorf(\"fail to get the %s limit\", resourceName)\n\t}\n\n\tif minRequiredSource > limit.Max {\n\t\treturn fmt.Errorf(\"%s %d is greater than Hard limit %d\", resourceName, minRequiredSource, limit.Max)\n\t}\n\n\tif limit.Cur >= minRequiredSource {\n\t\treturn nil\n\t}\n\n\tlimit.Cur = limit.Max\n\tif syscall.Setrlimit(syscall.RLIMIT_NOFILE, &limit) != nil {\n\t\treturn fmt.Errorf(fmt.Sprintf(\"fail to set the %s to %d\", resourceName, limit.Cur))\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "rlimit_windows.go",
          "type": "blob",
          "size": 0.0986328125,
          "content": "// +build windows\n\npackage main\n\nfunc (s *Supervisor) checkRequiredResources() error {\n\treturn nil\n}\n"
        },
        {
          "name": "service.go",
          "type": "blob",
          "size": 2.6005859375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/kardianos/service\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// ServiceCommand install/uninstall/start/stop supervisord service\ntype ServiceCommand struct {\n}\n\nvar serviceCommand ServiceCommand\n\ntype program struct{}\n\n// Start supervised service\nfunc (p *program) Start(s service.Service) error {\n\tgo p.run()\n\treturn nil\n}\n\nfunc (p *program) run() {}\n\n// Stop supervised service\nfunc (p *program) Stop(s service.Service) error {\n\t// Stop should not block. Return with a few seconds.\n\treturn nil\n}\n\n// Execute implement Execute() method defined in flags.Commander interface, executes the given command\nfunc (sc ServiceCommand) Execute(args []string) error {\n\tif len(args) == 0 {\n\t\tshowUsage()\n\t\treturn nil\n\t}\n\n\tserviceArgs := make([]string, 0)\n\tif options.Configuration != \"\" {\n\t\tserviceArgs = append(serviceArgs, \"--configuration=\"+options.Configuration)\n\t}\n\tif options.EnvFile != \"\" {\n\t\tserviceArgs = append(serviceArgs, \"--env-file=\"+options.EnvFile)\n\t}\n\n\tsvcConfig := &service.Config{\n\t\tName:        \"go-supervisord\",\n\t\tDisplayName: \"go-supervisord\",\n\t\tDescription: \"Supervisord service in golang\",\n\t\tArguments:   serviceArgs,\n\t}\n\tprg := &program{}\n\ts, err := service.New(prg, svcConfig)\n\tif err != nil {\n\t\tlog.Error(\"service init failed\", err)\n\t\treturn err\n\t}\n\n\taction := args[0]\n\tswitch action {\n\tcase \"install\":\n\t\terr := s.Install()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed to install service go-supervisord: \", err)\n\t\t\tfmt.Println(\"Failed to install service go-supervisord: \", err)\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println(\"Succeed to install service go-supervisord\")\n\t\t}\n\tcase \"uninstall\":\n\t\ts.Stop()\n\t\terr := s.Uninstall()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed to uninstall service go-supervisord: \", err)\n\t\t\tfmt.Println(\"Failed to uninstall service go-supervisord: \", err)\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println(\"Succeed to uninstall service go-supervisord\")\n\t\t}\n\tcase \"start\":\n\t\terr := s.Start()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed to start service: \", err)\n\t\t\tfmt.Println(\"Failed to start service: \", err)\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println(\"Succeed to start service go-supervisord\")\n\t\t}\n\tcase \"stop\":\n\t\terr := s.Stop()\n\t\tif err != nil {\n\t\t\tlog.Error(\"Failed to stop service: \", err)\n\t\t\tfmt.Println(\"Failed to stop service: \", err)\n\t\t\treturn err\n\t\t} else {\n\t\t\tfmt.Println(\"Succeed to stop service go-supervisord\")\n\t\t}\n\n\tdefault:\n\t\tshowUsage()\n\t}\n\n\treturn nil\n}\n\nfunc showUsage() {\n\tfmt.Println(\"usage: supervisord service install/uninstall/start/stop\")\n}\n\nfunc init() {\n\tparser.AddCommand(\"service\",\n\t\t\"install/uninstall/start/stop service\",\n\t\t\"install/uninstall/start/stop service\",\n\t\t&serviceCommand)\n}\n"
        },
        {
          "name": "signals",
          "type": "tree",
          "content": null
        },
        {
          "name": "supervisor.go",
          "type": "blob",
          "size": 21.4365234375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/ochinchina/supervisord/config\"\n\t\"github.com/ochinchina/supervisord/events\"\n\t\"github.com/ochinchina/supervisord/faults\"\n\t\"github.com/ochinchina/supervisord/logger\"\n\t\"github.com/ochinchina/supervisord/process\"\n\t\"github.com/ochinchina/supervisord/signals\"\n\t\"github.com/ochinchina/supervisord/types\"\n\t\"github.com/ochinchina/supervisord/util\"\n\n\tlog \"github.com/sirupsen/logrus\"\n)\n\nconst (\n\t// SupervisorVersion the version of supervisor\n\tSupervisorVersion = \"3.0\"\n)\n\n// Supervisor manage all the processes defined in the supervisor configuration file.\n// All the supervisor public interface is defined in this class\ntype Supervisor struct {\n\tconfig     *config.Config   // supervisor configuration\n\tprocMgr    *process.Manager // process manager\n\txmlRPC     *XMLRPC          // XMLRPC interface\n\tlogger     logger.Logger    // logger manager\n\tlock       sync.Mutex\n\trestarting bool // if supervisor is in restarting state\n}\n\n// StartProcessArgs arguments for starting a process\ntype StartProcessArgs struct {\n\tName string // program name\n\tWait bool   `default:\"true\"` // Wait the program starting finished\n}\n\n// ProcessStdin  process stdin from client\ntype ProcessStdin struct {\n\tName  string // program name\n\tChars string // inputs from client\n}\n\n// RemoteCommEvent remove communication event from client side\ntype RemoteCommEvent struct {\n\tType string // the event type\n\tData string // the data of event\n}\n\n// StateInfo describe the state of supervisor\ntype StateInfo struct {\n\tStatecode int    `xml:\"statecode\"`\n\tStatename string `xml:\"statename\"`\n}\n\n// RPCTaskResult result of some remote commands\ntype RPCTaskResult struct {\n\tName        string `xml:\"name\"`        // the program name\n\tGroup       string `xml:\"group\"`       // the group of the program\n\tStatus      int    `xml:\"status\"`      // the status of the program\n\tDescription string `xml:\"description\"` // the description of program\n}\n\n// LogReadInfo the input argument to read the log of supervisor\ntype LogReadInfo struct {\n\tOffset int // the log offset\n\tLength int // the length of log to read\n}\n\n// ProcessLogReadInfo the input argument to read the log of program\ntype ProcessLogReadInfo struct {\n\tName   string // the program name\n\tOffset int    // the offset of the program log\n\tLength int    // the length of log to read\n}\n\n// ProcessTailLog the output of tail the program log\ntype ProcessTailLog struct {\n\tLogData  string\n\tOffset   int64\n\tOverflow bool\n}\n\n// NewSupervisor create a Supervisor object with supervisor configuration file\nfunc NewSupervisor(configFile string) *Supervisor {\n\treturn &Supervisor{config: config.NewConfig(configFile),\n\t\tprocMgr:    process.NewManager(),\n\t\txmlRPC:     NewXMLRPC(),\n\t\trestarting: false}\n}\n\n// GetConfig get the loaded supervisor configuration\nfunc (s *Supervisor) GetConfig() *config.Config {\n\treturn s.config\n}\n\n// GetVersion get the version of supervisor\nfunc (s *Supervisor) GetVersion(r *http.Request, args *struct{}, reply *struct{ Version string }) error {\n\treply.Version = SupervisorVersion\n\treturn nil\n}\n\n// GetSupervisorVersion get the supervisor version\nfunc (s *Supervisor) GetSupervisorVersion(r *http.Request, args *struct{}, reply *struct{ Version string }) error {\n\treply.Version = SupervisorVersion\n\treturn nil\n}\n\n// GetIdentification get the supervisor identifier configured in the file\nfunc (s *Supervisor) GetIdentification(r *http.Request, args *struct{}, reply *struct{ ID string }) error {\n\treply.ID = s.GetSupervisorID()\n\treturn nil\n}\n\n// GetSupervisorID get the supervisor identifier from configuration file\nfunc (s *Supervisor) GetSupervisorID() string {\n\tentry, ok := s.config.GetSupervisord()\n\tif !ok {\n\t\treturn \"supervisor\"\n\t}\n\treturn entry.GetString(\"identifier\", \"supervisor\")\n}\n\n// GetState get the state of supervisor\nfunc (s *Supervisor) GetState(r *http.Request, args *struct{}, reply *struct{ StateInfo StateInfo }) error {\n\t// statecode    statename\n\t// =======================\n\t// 2            FATAL\n\t// 1            RUNNING\n\t// 0            RESTARTING\n\t// -1           SHUTDOWN\n\tlog.Debug(\"Get state\")\n\treply.StateInfo.Statecode = 1\n\treply.StateInfo.Statename = \"RUNNING\"\n\treturn nil\n}\n\n// GetPrograms Get all the name of programs\n//\n// Return the name of all the programs\nfunc (s *Supervisor) GetPrograms() []string {\n\treturn s.config.GetProgramNames()\n}\n\n// GetPID get the pid of supervisor\nfunc (s *Supervisor) GetPID(r *http.Request, args *struct{}, reply *struct{ Pid int }) error {\n\treply.Pid = os.Getpid()\n\treturn nil\n}\n\n// ReadLog read the log of supervisor\nfunc (s *Supervisor) ReadLog(r *http.Request, args *LogReadInfo, reply *struct{ Log string }) error {\n\tdata, err := s.logger.ReadLog(int64(args.Offset), int64(args.Length))\n\treply.Log = data\n\treturn err\n}\n\n// ClearLog clear the supervisor log\nfunc (s *Supervisor) ClearLog(r *http.Request, args *struct{}, reply *struct{ Ret bool }) error {\n\terr := s.logger.ClearAllLogFile()\n\treply.Ret = err == nil\n\treturn err\n}\n\n// Shutdown the supervisor\nfunc (s *Supervisor) Shutdown(r *http.Request, args *struct{}, reply *struct{ Ret bool }) error {\n\treply.Ret = true\n\tlog.Info(\"received rpc request to stop all processes & exit\")\n\ts.procMgr.StopAllProcesses()\n\tgo func() {\n\t\ttime.Sleep(1 * time.Second)\n\t\tos.Exit(0)\n\t}()\n\treturn nil\n}\n\n// Restart the supervisor\nfunc (s *Supervisor) Restart(r *http.Request, args *struct{}, reply *struct{ Ret bool }) error {\n\tlog.Info(\"Receive instruction to restart\")\n\ts.restarting = true\n\treply.Ret = true\n\treturn nil\n}\n\n// IsRestarting check if supervisor is in restarting state\nfunc (s *Supervisor) IsRestarting() bool {\n\treturn s.restarting\n}\n\nfunc getProcessInfo(proc *process.Process) *types.ProcessInfo {\n\treturn &types.ProcessInfo{Name: proc.GetName(),\n\t\tGroup:         proc.GetGroup(),\n\t\tDescription:   proc.GetDescription(),\n\t\tStart:         int(proc.GetStartTime().Unix()),\n\t\tStop:          int(proc.GetStopTime().Unix()),\n\t\tNow:           int(time.Now().Unix()),\n\t\tState:         int(proc.GetState()),\n\t\tStatename:     proc.GetState().String(),\n\t\tSpawnerr:      \"\",\n\t\tExitstatus:    proc.GetExitstatus(),\n\t\tLogfile:       proc.GetStdoutLogfile(),\n\t\tStdoutLogfile: proc.GetStdoutLogfile(),\n\t\tStderrLogfile: proc.GetStderrLogfile(),\n\t\tPid:           proc.GetPid()}\n\n}\n\n// GetAllProcessInfo get all the program information managed by supervisor\nfunc (s *Supervisor) GetAllProcessInfo(r *http.Request, args *struct{}, reply *struct{ AllProcessInfo []types.ProcessInfo }) error {\n\treply.AllProcessInfo = make([]types.ProcessInfo, 0)\n\ts.procMgr.ForEachProcess(func(proc *process.Process) {\n\t\tprocInfo := getProcessInfo(proc)\n\t\treply.AllProcessInfo = append(reply.AllProcessInfo, *procInfo)\n\t})\n\ttypes.SortProcessInfos(reply.AllProcessInfo)\n\treturn nil\n}\n\n// GetProcessInfo get the process information of one program\nfunc (s *Supervisor) GetProcessInfo(r *http.Request, args *struct{ Name string }, reply *struct{ ProcInfo types.ProcessInfo }) error {\n\tlog.Info(\"Get process info of: \", args.Name)\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\treturn fmt.Errorf(\"BAD_NAME no process named %s\", args.Name)\n\t}\n\n\treply.ProcInfo = *getProcessInfo(proc)\n\treturn nil\n}\n\n// StartProcess start the given program\nfunc (s *Supervisor) StartProcess(r *http.Request, args *StartProcessArgs, reply *struct{ Success bool }) error {\n\tprocs := s.procMgr.FindMatch(args.Name)\n\n\tif len(procs) <= 0 {\n\t\treturn fmt.Errorf(\"fail to find process %s\", args.Name)\n\t}\n\tfor _, proc := range procs {\n\t\tproc.Start(args.Wait)\n\t}\n\treply.Success = true\n\treturn nil\n}\n\n// StartAllProcesses start all the programs\nfunc (s *Supervisor) StartAllProcesses(r *http.Request, args *struct {\n\tWait bool `default:\"true\"`\n}, reply *struct{ RPCTaskResults []RPCTaskResult }) error {\n\n\tfinishedProcCh := make(chan *process.Process)\n\n\tn := s.procMgr.AsyncForEachProcess(func(proc *process.Process) {\n\t\tproc.Start(args.Wait)\n\t}, finishedProcCh)\n\n\tfor i := 0; i < n; i++ {\n\t\tproc, ok := <-finishedProcCh\n\t\tif ok {\n\t\t\tprocessInfo := *getProcessInfo(proc)\n\t\t\treply.RPCTaskResults = append(reply.RPCTaskResults, RPCTaskResult{\n\t\t\t\tName:        processInfo.Name,\n\t\t\t\tGroup:       processInfo.Group,\n\t\t\t\tStatus:      faults.Success,\n\t\t\t\tDescription: \"OK\",\n\t\t\t})\n\t\t}\n\t}\n\treturn nil\n}\n\n// StartProcessGroup start all the processes in one group\nfunc (s *Supervisor) StartProcessGroup(r *http.Request, args *StartProcessArgs, reply *struct{ AllProcessInfo []types.ProcessInfo }) error {\n\tlog.WithFields(log.Fields{\"group\": args.Name}).Info(\"start process group\")\n\tfinishedProcCh := make(chan *process.Process)\n\n\tn := s.procMgr.AsyncForEachProcess(func(proc *process.Process) {\n\t\tif proc.GetGroup() == args.Name {\n\t\t\tproc.Start(args.Wait)\n\t\t}\n\t}, finishedProcCh)\n\n\tfor i := 0; i < n; i++ {\n\t\tproc, ok := <-finishedProcCh\n\t\tif ok && proc.GetGroup() == args.Name {\n\t\t\treply.AllProcessInfo = append(reply.AllProcessInfo, *getProcessInfo(proc))\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// StopProcess stop given program\nfunc (s *Supervisor) StopProcess(r *http.Request, args *StartProcessArgs, reply *struct{ Success bool }) error {\n\tlog.WithFields(log.Fields{\"program\": args.Name}).Info(\"stop process\")\n\tprocs := s.procMgr.FindMatch(args.Name)\n\tif len(procs) <= 0 {\n\t\treturn fmt.Errorf(\"fail to find process %s\", args.Name)\n\t}\n\tfor _, proc := range procs {\n\t\tproc.Stop(args.Wait)\n\t}\n\treply.Success = true\n\treturn nil\n}\n\n// StopProcessGroup stop all processes in one group\nfunc (s *Supervisor) StopProcessGroup(r *http.Request, args *StartProcessArgs, reply *struct{ AllProcessInfo []types.ProcessInfo }) error {\n\tlog.WithFields(log.Fields{\"group\": args.Name}).Info(\"stop process group\")\n\tfinishedProcCh := make(chan *process.Process)\n\tn := s.procMgr.AsyncForEachProcess(func(proc *process.Process) {\n\t\tif proc.GetGroup() == args.Name {\n\t\t\tproc.Stop(args.Wait)\n\t\t}\n\t}, finishedProcCh)\n\n\tfor i := 0; i < n; i++ {\n\t\tproc, ok := <-finishedProcCh\n\t\tif ok && proc.GetGroup() == args.Name {\n\t\t\treply.AllProcessInfo = append(reply.AllProcessInfo, *getProcessInfo(proc))\n\t\t}\n\t}\n\treturn nil\n}\n\n// StopAllProcesses stop all programs managed by supervisor\nfunc (s *Supervisor) StopAllProcesses(r *http.Request, args *struct {\n\tWait bool `default:\"true\"`\n}, reply *struct{ RPCTaskResults []RPCTaskResult }) error {\n\tfinishedProcCh := make(chan *process.Process)\n\n\tn := s.procMgr.AsyncForEachProcess(func(proc *process.Process) {\n\t\tproc.Stop(args.Wait)\n\t}, finishedProcCh)\n\n\tfor i := 0; i < n; i++ {\n\t\tproc, ok := <-finishedProcCh\n\t\tif ok {\n\t\t\tprocessInfo := *getProcessInfo(proc)\n\t\t\treply.RPCTaskResults = append(reply.RPCTaskResults, RPCTaskResult{\n\t\t\t\tName:        processInfo.Name,\n\t\t\t\tGroup:       processInfo.Group,\n\t\t\t\tStatus:      faults.Success,\n\t\t\t\tDescription: \"OK\",\n\t\t\t})\n\t\t}\n\t}\n\treturn nil\n}\n\n// SignalProcess send a signal to running program\nfunc (s *Supervisor) SignalProcess(r *http.Request, args *types.ProcessSignal, reply *struct{ Success bool }) error {\n\tprocs := s.procMgr.FindMatch(args.Name)\n\tif len(procs) <= 0 {\n\t\treply.Success = false\n\t\treturn fmt.Errorf(\"No process named %s\", args.Name)\n\t}\n\tsig, err := signals.ToSignal(args.Signal)\n\tif err == nil {\n\t\tfor _, proc := range procs {\n\t\t\tproc.Signal(sig, false)\n\t\t}\n\t}\n\treply.Success = true\n\treturn nil\n}\n\n// SignalProcessGroup send signal to all processes in one group\nfunc (s *Supervisor) SignalProcessGroup(r *http.Request, args *types.ProcessSignal, reply *struct{ AllProcessInfo []types.ProcessInfo }) error {\n\ts.procMgr.ForEachProcess(func(proc *process.Process) {\n\t\tif proc.GetGroup() == args.Name {\n\t\t\tsig, err := signals.ToSignal(args.Signal)\n\t\t\tif err == nil {\n\t\t\t\tproc.Signal(sig, false)\n\t\t\t}\n\t\t}\n\t})\n\n\ts.procMgr.ForEachProcess(func(proc *process.Process) {\n\t\tif proc.GetGroup() == args.Name {\n\t\t\treply.AllProcessInfo = append(reply.AllProcessInfo, *getProcessInfo(proc))\n\t\t}\n\t})\n\treturn nil\n}\n\n// SignalAllProcesses send signal to all the processes in the supervisor\nfunc (s *Supervisor) SignalAllProcesses(r *http.Request, args *types.ProcessSignal, reply *struct{ AllProcessInfo []types.ProcessInfo }) error {\n\ts.procMgr.ForEachProcess(func(proc *process.Process) {\n\t\tsig, err := signals.ToSignal(args.Signal)\n\t\tif err == nil {\n\t\t\tproc.Signal(sig, false)\n\t\t}\n\t})\n\ts.procMgr.ForEachProcess(func(proc *process.Process) {\n\t\treply.AllProcessInfo = append(reply.AllProcessInfo, *getProcessInfo(proc))\n\t})\n\treturn nil\n}\n\n// SendProcessStdin send data to program through stdin\nfunc (s *Supervisor) SendProcessStdin(r *http.Request, args *ProcessStdin, reply *struct{ Success bool }) error {\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\tlog.WithFields(log.Fields{\"program\": args.Name}).Error(\"program does not exist\")\n\t\treturn fmt.Errorf(\"NOT_RUNNING\")\n\t}\n\tif proc.GetState() != process.Running {\n\t\tlog.WithFields(log.Fields{\"program\": args.Name}).Error(\"program does not run\")\n\t\treturn fmt.Errorf(\"NOT_RUNNING\")\n\t}\n\terr := proc.SendProcessStdin(args.Chars)\n\tif err == nil {\n\t\treply.Success = true\n\t} else {\n\t\treply.Success = false\n\t}\n\treturn err\n}\n\n// SendRemoteCommEvent emit a remote communication event\nfunc (s *Supervisor) SendRemoteCommEvent(r *http.Request, args *RemoteCommEvent, reply *struct{ Success bool }) error {\n\tevents.EmitEvent(events.NewRemoteCommunicationEvent(args.Type, args.Data))\n\treply.Success = true\n\treturn nil\n}\n\n// Reload supervisord configuration.\nfunc (s *Supervisor) Reload(restart bool) (addedGroup []string, changedGroup []string, removedGroup []string, err error) {\n\ts.lock.Lock()\n\tdefer s.lock.Unlock()\n\t// get the previous loaded programs\n\tprevPrograms := s.config.GetProgramNames()\n\tprevProgGroup := s.config.ProgramGroup.Clone()\n\n\tloadedPrograms, err := s.config.Load()\n\n\tif checkErr := s.checkRequiredResources(); checkErr != nil {\n\t\tlog.Error(checkErr)\n\t\tos.Exit(1)\n\n\t}\n\tif err == nil {\n\t\ts.setSupervisordInfo()\n\t\ts.startEventListeners()\n\t\ts.createPrograms(prevPrograms)\n\t\tif restart {\n\t\t\ts.startHTTPServer()\n\t\t}\n\t\ts.startAutoStartPrograms()\n\t}\n\tremovedPrograms := util.Sub(prevPrograms, loadedPrograms)\n\tfor _, removedProg := range removedPrograms {\n\t\tlog.WithFields(log.Fields{\"program\": removedProg}).Info(\"the program is removed and will be stopped\")\n\t\ts.config.RemoveProgram(removedProg)\n\t\tproc := s.procMgr.Remove(removedProg)\n\t\tif proc != nil {\n\t\t\tproc.Stop(false)\n\t\t}\n\n\t}\n\taddedGroup, changedGroup, removedGroup = s.config.ProgramGroup.Sub(prevProgGroup)\n\treturn addedGroup, changedGroup, removedGroup, err\n\n}\n\n// WaitForExit waits for supervisord to exit\nfunc (s *Supervisor) WaitForExit() {\n\tfor {\n\t\tif s.IsRestarting() {\n\t\t\ts.procMgr.StopAllProcesses()\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(10 * time.Second)\n\t}\n}\n\nfunc (s *Supervisor) createPrograms(prevPrograms []string) {\n\n\tprograms := s.config.GetProgramNames()\n\tfor _, entry := range s.config.GetPrograms() {\n\t\ts.procMgr.CreateProcess(s.GetSupervisorID(), entry)\n\t}\n\tremovedPrograms := util.Sub(prevPrograms, programs)\n\tfor _, p := range removedPrograms {\n\t\ts.procMgr.Remove(p)\n\t}\n}\n\nfunc (s *Supervisor) startAutoStartPrograms() {\n\ts.procMgr.StartAutoStartPrograms()\n}\n\nfunc (s *Supervisor) startEventListeners() {\n\teventListeners := s.config.GetEventListeners()\n\tfor _, entry := range eventListeners {\n\t\tproc := s.procMgr.CreateProcess(s.GetSupervisorID(), entry)\n\t\tproc.Start(false)\n\t}\n\n\tif len(eventListeners) > 0 {\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nfunc (s *Supervisor) startHTTPServer() {\n\thttpServerConfig, ok := s.config.GetInetHTTPServer()\n\ts.xmlRPC.Stop()\n\tif ok {\n\t\taddr := httpServerConfig.GetString(\"port\", \"\")\n\t\tif addr != \"\" {\n\t\t\tcond := sync.NewCond(&sync.Mutex{})\n\t\t\tcond.L.Lock()\n\t\t\tdefer cond.L.Unlock()\n\t\t\tgo s.xmlRPC.StartInetHTTPServer(httpServerConfig.GetString(\"username\", \"\"),\n\t\t\t\thttpServerConfig.GetString(\"password\", \"\"),\n\t\t\t\taddr,\n\t\t\t\ts,\n\t\t\t\tfunc() {\n\t\t\t\t\tcond.L.Lock()\n\t\t\t\t\tcond.Signal()\n\t\t\t\t\tcond.L.Unlock()\n\t\t\t\t})\n\t\t\tcond.Wait()\n\t\t}\n\t}\n\n\thttpServerConfig, ok = s.config.GetUnixHTTPServer()\n\tif ok {\n\t\tenv := config.NewStringExpression(\"here\", s.config.GetConfigFileDir())\n\t\tsockFile, err := env.Eval(httpServerConfig.GetString(\"file\", \"/tmp/supervisord.sock\"))\n\t\tif err == nil {\n\t\t\tcond := sync.NewCond(&sync.Mutex{})\n\t\t\tcond.L.Lock()\n\t\t\tdefer cond.L.Unlock()\n\t\t\tgo s.xmlRPC.StartUnixHTTPServer(httpServerConfig.GetString(\"username\", \"\"),\n\t\t\t\thttpServerConfig.GetString(\"password\", \"\"),\n\t\t\t\tsockFile,\n\t\t\t\ts,\n\t\t\t\tfunc() {\n\t\t\t\t\tcond.L.Lock()\n\t\t\t\t\tcond.Signal()\n\t\t\t\t\tcond.L.Unlock()\n\t\t\t\t})\n\t\t\tcond.Wait()\n\t\t}\n\t}\n\n}\n\nfunc (s *Supervisor) setSupervisordInfo() {\n\tsupervisordConf, ok := s.config.GetSupervisord()\n\tif ok {\n\t\t// set supervisord log\n\n\t\tenv := config.NewStringExpression(\"here\", s.config.GetConfigFileDir())\n\t\tlogFile, err := env.Eval(supervisordConf.GetString(\"logfile\", \"supervisord.log\"))\n\t\tif err != nil {\n\t\t\tlogFile, err = process.PathExpand(logFile)\n\t\t}\n\t\tif logFile == \"/dev/stdout\" {\n\t\t\treturn\n\t\t}\n\t\tlogEventEmitter := logger.NewNullLogEventEmitter()\n\t\ts.logger = logger.NewNullLogger(logEventEmitter)\n\t\tif err == nil {\n\t\t\tlogfileMaxbytes := int64(supervisordConf.GetBytes(\"logfile_maxbytes\", 50*1024*1024))\n\t\t\tlogfileBackups := supervisordConf.GetInt(\"logfile_backups\", 10)\n\t\t\tloglevel := supervisordConf.GetString(\"loglevel\", \"info\")\n\t\t\tprops := make(map[string]string)\n\t\t\ts.logger = logger.NewLogger(\"supervisord\", logFile, &sync.Mutex{}, logfileMaxbytes, logfileBackups, props, logEventEmitter)\n\t\t\tlog.SetLevel(toLogLevel(loglevel))\n\t\t\tlog.SetFormatter(&log.TextFormatter{DisableColors: true, FullTimestamp: true})\n\t\t\tlog.SetOutput(s.logger)\n\t\t}\n\t\t// set the pid\n\t\tpidfile, err := env.Eval(supervisordConf.GetString(\"pidfile\", \"supervisord.pid\"))\n\t\tif err == nil {\n\t\t\tf, err := os.Create(pidfile)\n\t\t\tif err == nil {\n\t\t\t\tfmt.Fprintf(f, \"%d\", os.Getpid())\n\t\t\t\tf.Close()\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc toLogLevel(level string) log.Level {\n\tswitch strings.ToLower(level) {\n\tcase \"critical\":\n\t\treturn log.FatalLevel\n\tcase \"error\":\n\t\treturn log.ErrorLevel\n\tcase \"warn\":\n\t\treturn log.WarnLevel\n\tcase \"info\":\n\t\treturn log.InfoLevel\n\tdefault:\n\t\treturn log.DebugLevel\n\t}\n}\n\n// ReloadConfig reloads supervisord configuration file\nfunc (s *Supervisor) ReloadConfig(r *http.Request, args *struct{}, reply *types.ReloadConfigResult) error {\n\tlog.Info(\"start to reload config\")\n\taddedGroup, changedGroup, removedGroup, err := s.Reload(false)\n\tif len(addedGroup) > 0 {\n\t\tlog.WithFields(log.Fields{\"groups\": strings.Join(addedGroup, \",\")}).Info(\"added groups\")\n\t}\n\n\tif len(changedGroup) > 0 {\n\t\tlog.WithFields(log.Fields{\"groups\": strings.Join(changedGroup, \",\")}).Info(\"changed groups\")\n\t}\n\n\tif len(removedGroup) > 0 {\n\t\tlog.WithFields(log.Fields{\"groups\": strings.Join(removedGroup, \",\")}).Info(\"removed groups\")\n\t}\n\treply.AddedGroup = addedGroup\n\treply.ChangedGroup = changedGroup\n\treply.RemovedGroup = removedGroup\n\treturn err\n}\n\n// AddProcessGroup adds a process group to the supervisor\nfunc (s *Supervisor) AddProcessGroup(r *http.Request, args *struct{ Name string }, reply *struct{ Success bool }) error {\n\treply.Success = false\n\treturn nil\n}\n\n// RemoveProcessGroup removes a process group from the supervisor\nfunc (s *Supervisor) RemoveProcessGroup(r *http.Request, args *struct{ Name string }, reply *struct{ Success bool }) error {\n\treply.Success = false\n\treturn nil\n}\n\n// ReadProcessStdoutLog reads stdout of given program\nfunc (s *Supervisor) ReadProcessStdoutLog(r *http.Request, args *ProcessLogReadInfo, reply *struct{ LogData string }) error {\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\treturn fmt.Errorf(\"No such process %s\", args.Name)\n\t}\n\tvar err error\n\treply.LogData, err = proc.StdoutLog.ReadLog(int64(args.Offset), int64(args.Length))\n\treturn err\n}\n\n// ReadProcessStderrLog reads stderr log of given program\nfunc (s *Supervisor) ReadProcessStderrLog(r *http.Request, args *ProcessLogReadInfo, reply *struct{ LogData string }) error {\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\treturn fmt.Errorf(\"No such process %s\", args.Name)\n\t}\n\tvar err error\n\treply.LogData, err = proc.StderrLog.ReadLog(int64(args.Offset), int64(args.Length))\n\treturn err\n}\n\n// TailProcessStdoutLog tails stdout of the program\nfunc (s *Supervisor) TailProcessStdoutLog(r *http.Request, args *ProcessLogReadInfo, reply *ProcessTailLog) error {\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\treturn fmt.Errorf(\"No such process %s\", args.Name)\n\t}\n\tvar err error\n\treply.LogData, reply.Offset, reply.Overflow, err = proc.StdoutLog.ReadTailLog(int64(args.Offset), int64(args.Length))\n\treturn err\n}\n\n// TailProcessStderrLog tails stderr of the program\nfunc (s *Supervisor) TailProcessStderrLog(r *http.Request, args *ProcessLogReadInfo, reply *ProcessTailLog) error {\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\treturn fmt.Errorf(\"No such process %s\", args.Name)\n\t}\n\tvar err error\n\treply.LogData, reply.Offset, reply.Overflow, err = proc.StderrLog.ReadTailLog(int64(args.Offset), int64(args.Length))\n\treturn err\n}\n\n// ClearProcessLogs clears log of given program\nfunc (s *Supervisor) ClearProcessLogs(r *http.Request, args *struct{ Name string }, reply *struct{ Success bool }) error {\n\tproc := s.procMgr.Find(args.Name)\n\tif proc == nil {\n\t\treturn fmt.Errorf(\"No such process %s\", args.Name)\n\t}\n\terr1 := proc.StdoutLog.ClearAllLogFile()\n\terr2 := proc.StderrLog.ClearAllLogFile()\n\treply.Success = err1 == nil && err2 == nil\n\tif err1 != nil {\n\t\treturn err1\n\t}\n\treturn err2\n}\n\n// ClearAllProcessLogs clears logs of all programs\nfunc (s *Supervisor) ClearAllProcessLogs(r *http.Request, args *struct{}, reply *struct{ RPCTaskResults []RPCTaskResult }) error {\n\n\ts.procMgr.ForEachProcess(func(proc *process.Process) {\n\t\tproc.StdoutLog.ClearAllLogFile()\n\t\tproc.StderrLog.ClearAllLogFile()\n\t\tprocInfo := getProcessInfo(proc)\n\t\treply.RPCTaskResults = append(reply.RPCTaskResults, RPCTaskResult{\n\t\t\tName:        procInfo.Name,\n\t\t\tGroup:       procInfo.Group,\n\t\t\tStatus:      faults.Success,\n\t\t\tDescription: \"OK\",\n\t\t})\n\t})\n\n\treturn nil\n}\n\n// GetManager get the Manager object created by supervisor\nfunc (s *Supervisor) GetManager() *process.Manager {\n\treturn s.procMgr\n}\n"
        },
        {
          "name": "supervisor.ini",
          "type": "blob",
          "size": 0.4404296875,
          "content": "[inet_http_server]\nport = :9001\n\n[program:linx-test]\ndirectory = /export/home/maguozhi/code/go/test_prometheus\ncommand = ./test\n\n[program:ddc]\ndirectory = /export/home/maguozhi/unrealddc\ncommand = ./unreal_httpddc_server\nstdout_logfile = /export/home/maguozhi/unrealddc/logs/console.log\nstderr_logfile = /export/home/maguozhi/unrealddc/logs/console.log\n\n[program:env-test]\ncommand = ./env-test.py\nstdout_logfile=/dev/stdout\nstderr_logfile=/dev/stderr\n"
        },
        {
          "name": "types",
          "type": "tree",
          "content": null
        },
        {
          "name": "util",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.5400390625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n)\n\n// VERSION the version of supervisor\nconst VERSION = \"v0.7.3\"\n\n// VersionCommand implement the flags.Commander interface\ntype VersionCommand struct {\n}\n\nvar versionCommand VersionCommand\n\n// Execute implement Execute() method defined in flags.Commander interface, executes the given command\nfunc (v VersionCommand) Execute(args []string) error {\n\tfmt.Println(VERSION)\n\treturn nil\n}\n\nfunc init() {\n\tparser.AddCommand(\"version\",\n\t\t\"show the version of supervisor\",\n\t\t\"display the supervisor version\",\n\t\t&versionCommand)\n}\n"
        },
        {
          "name": "webgui.go",
          "type": "blob",
          "size": 0.64453125,
          "content": "package main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n\n// SupervisorWebgui the interface to show a WEBGUI to control the supervisor\ntype SupervisorWebgui struct {\n\trouter     *mux.Router\n\tsupervisor *Supervisor\n}\n\n// NewSupervisorWebgui create a new SupervisorWebgui object\nfunc NewSupervisorWebgui(supervisor *Supervisor) *SupervisorWebgui {\n\trouter := mux.NewRouter()\n\treturn &SupervisorWebgui{router: router, supervisor: supervisor}\n}\n\n// CreateHandler create a http handler to process the request from WEBGUI\nfunc (sw *SupervisorWebgui) CreateHandler() http.Handler {\n\tsw.router.PathPrefix(\"/\").Handler(http.FileServer(HTTP))\n\treturn sw.router\n}\n"
        },
        {
          "name": "webgui",
          "type": "tree",
          "content": null
        },
        {
          "name": "xmlrpc.go",
          "type": "blob",
          "size": 8.7392578125,
          "content": "package main\n\nimport (\n\t\"crypto/sha1\" //nolint:gosec\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/gorilla/rpc\"\n\t\"github.com/ochinchina/gorilla-xmlrpc/xml\"\n\t\"github.com/ochinchina/supervisord/process\"\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n\tlog \"github.com/sirupsen/logrus\"\n)\n\n// XMLRPC mange the XML RPC servers\n// start XML RPC servers to accept the XML RPC request from client side\ntype XMLRPC struct {\n\t// all the listeners to accept the XML RPC request\n\tlisteners map[string]net.Listener\n}\n\ntype httpBasicAuth struct {\n\tuser     string\n\tpassword string\n\thandler  http.Handler\n}\n\n// create a new HttpBasicAuth object with username, password and the http request handler\nfunc newHTTPBasicAuth(user string, password string, handler http.Handler) *httpBasicAuth {\n\tif user != \"\" && password != \"\" {\n\t\tlog.Debug(\"require authentication\")\n\t}\n\treturn &httpBasicAuth{user: user, password: password, handler: handler}\n}\n\nfunc (h *httpBasicAuth) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif h.user == \"\" || h.password == \"\" {\n\t\tlog.Debug(\"no auth required\")\n\t\th.handler.ServeHTTP(w, r)\n\t\treturn\n\t}\n\tusername, password, ok := r.BasicAuth()\n\tif ok && username == h.user {\n\t\tif strings.HasPrefix(h.password, \"{SHA}\") {\n\t\t\tlog.Debug(\"auth with SHA\")\n\t\t\thash := sha1.New() //nolint:gosec\n\t\t\tio.WriteString(hash, password)\n\t\t\tif hex.EncodeToString(hash.Sum(nil)) == h.password[5:] {\n\t\t\t\th.handler.ServeHTTP(w, r)\n\t\t\t\treturn\n\t\t\t}\n\t\t} else if password == h.password {\n\t\t\tlog.Debug(\"Auth with normal password\")\n\t\t\th.handler.ServeHTTP(w, r)\n\t\t\treturn\n\t\t}\n\t}\n\tw.Header().Set(\"WWW-Authenticate\", \"Basic realm=\\\"supervisor\\\"\")\n\tw.WriteHeader(401)\n}\n\n// NewXMLRPC create a new XML RPC object\nfunc NewXMLRPC() *XMLRPC {\n\treturn &XMLRPC{listeners: make(map[string]net.Listener)}\n}\n\n// Stop network listening\nfunc (p *XMLRPC) Stop() {\n\tlog.Info(\"stop listening\")\n\tfor _, listener := range p.listeners {\n\t\tlistener.Close()\n\t}\n\tp.listeners = make(map[string]net.Listener)\n}\n\n// StartUnixHTTPServer start http server on unix domain socket with path listenAddr. If both user and password are not empty, the user\n// must provide user and password for basic authentication when making an XML RPC request.\nfunc (p *XMLRPC) StartUnixHTTPServer(user string, password string, listenAddr string, s *Supervisor, startedCb func()) {\n\tos.Remove(listenAddr)\n\tp.startHTTPServer(user, password, \"unix\", listenAddr, s, startedCb)\n}\n\n// StartInetHTTPServer start http server on tcp with path listenAddr. If both user and password are not empty, the user\n// must provide user and password for basic authentication when making an XML RPC request.\nfunc (p *XMLRPC) StartInetHTTPServer(user string, password string, listenAddr string, s *Supervisor, startedCb func()) {\n\tp.startHTTPServer(user, password, \"tcp\", listenAddr, s, startedCb)\n}\n\nfunc (p *XMLRPC) isHTTPServerStartedOnProtocol(protocol string) bool {\n\t_, ok := p.listeners[protocol]\n\treturn ok\n}\n\nfunc readFile(path string) ([]byte, error) {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\tb, err := ioutil.ReadAll(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn b, nil\n}\n\nfunc getProgramConfigPath(programName string, s *Supervisor) string {\n\tc := s.config.GetProgram(programName)\n\tif c == nil {\n\t\treturn \"\"\n\t}\n\n\tres := c.GetString(\"conf_file\", \"\")\n\treturn res\n}\n\nfunc readLogHtml(writer http.ResponseWriter, request *http.Request) {\n\tb, err := readFile(\"webgui/log.html\")\n\tif err != nil {\n\t\twriter.WriteHeader(http.StatusNotFound)\n\t\treturn\n\t}\n\n\twriter.WriteHeader(http.StatusOK)\n\twriter.Write(b)\n}\n\nfunc (p *XMLRPC) startHTTPServer(user string, password string, protocol string, listenAddr string, s *Supervisor, startedCb func()) {\n\tif p.isHTTPServerStartedOnProtocol(protocol) {\n\t\tstartedCb()\n\t\treturn\n\t}\n\tprocCollector := process.NewProcCollector(s.procMgr)\n\tprometheus.Register(procCollector)\n\tmux := http.NewServeMux()\n\tmux.Handle(\"/RPC2\", newHTTPBasicAuth(user, password, p.createRPCServer(s)))\n\n\tprogRestHandler := NewSupervisorRestful(s).CreateProgramHandler()\n\tmux.Handle(\"/program/\", newHTTPBasicAuth(user, password, progRestHandler))\n\n\tsupervisorRestHandler := NewSupervisorRestful(s).CreateSupervisorHandler()\n\tmux.Handle(\"/supervisor/\", newHTTPBasicAuth(user, password, supervisorRestHandler))\n\n\t// 有bug已弃用\n\tlogtailHandler := NewLogtail(s).CreateHandler()\n\tmux.Handle(\"/logtail/\", newHTTPBasicAuth(user, password, logtailHandler))\n\n\twebguiHandler := NewSupervisorWebgui(s).CreateHandler()\n\tmux.Handle(\"/\", newHTTPBasicAuth(user, password, webguiHandler))\n\n\t// conf 文件\n\tconfHandler := NewConfApi(s).CreateHandler()\n\tmux.Handle(\"/conf/\", newHTTPBasicAuth(user, password, confHandler))\n\tmux.HandleFunc(\"/confFile\", func(writer http.ResponseWriter, request *http.Request) {\n\t\tb, err := readFile(\"webgui/conf.html\")\n\t\tif err != nil {\n\t\t\twriter.WriteHeader(http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\twriter.WriteHeader(http.StatusOK)\n\t\twriter.Write(b)\n\t})\n\n\t// 读log.html文件\n\tmux.HandleFunc(\"/log\", readLogHtml)\n\n\tmux.Handle(\"/metrics\", promhttp.Handler())\n\n\t// 注册日志路由,可以查看日志目录\n\tentryList := s.config.GetPrograms()\n\tfor _, c := range entryList {\n\t\trealName := c.GetProgramName()\n\t\tif realName == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tfilePath := c.GetString(\"stdout_logfile\", \"\")\n\t\tif filePath == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tdir := filepath.Dir(filePath)\n\t\tfmt.Println(dir)\n\t\tmux.Handle(\"/log/\"+realName+\"/\", http.StripPrefix(\"/log/\"+realName+\"/\", http.FileServer(http.Dir(dir))))\n\t}\n\n\tlistener, err := net.Listen(protocol, listenAddr)\n\tif err == nil {\n\t\tlog.WithFields(log.Fields{\"addr\": listenAddr, \"protocol\": protocol}).Info(\"success to listen on address\")\n\t\tp.listeners[protocol] = listener\n\t\tstartedCb()\n\t\thttp.Serve(listener, mux)\n\t} else {\n\t\tstartedCb()\n\t\tlog.WithFields(log.Fields{\"addr\": listenAddr, \"protocol\": protocol}).Fatal(\"fail to listen on address\")\n\t}\n\n}\nfunc (p *XMLRPC) createRPCServer(s *Supervisor) *rpc.Server {\n\tRPC := rpc.NewServer()\n\txmlrpcCodec := xml.NewCodec()\n\tRPC.RegisterCodec(xmlrpcCodec, \"text/xml\")\n\tRPC.RegisterService(s, \"\")\n\n\txmlrpcCodec.RegisterAlias(\"supervisor.getVersion\", \"Supervisor.GetVersion\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getAPIVersion\", \"Supervisor.GetVersion\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getIdentification\", \"Supervisor.GetIdentification\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getState\", \"Supervisor.GetState\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getPID\", \"Supervisor.GetPID\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.readLog\", \"Supervisor.ReadLog\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.clearLog\", \"Supervisor.ClearLog\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.shutdown\", \"Supervisor.Shutdown\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.restart\", \"Supervisor.Restart\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getProcessInfo\", \"Supervisor.GetProcessInfo\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getSupervisorVersion\", \"Supervisor.GetVersion\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.getAllProcessInfo\", \"Supervisor.GetAllProcessInfo\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.startProcess\", \"Supervisor.StartProcess\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.startAllProcesses\", \"Supervisor.StartAllProcesses\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.startProcessGroup\", \"Supervisor.StartProcessGroup\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.stopProcess\", \"Supervisor.StopProcess\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.stopProcessGroup\", \"Supervisor.StopProcessGroup\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.stopAllProcesses\", \"Supervisor.StopAllProcesses\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.signalProcess\", \"Supervisor.SignalProcess\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.signalProcessGroup\", \"Supervisor.SignalProcessGroup\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.signalAllProcesses\", \"Supervisor.SignalAllProcesses\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.sendProcessStdin\", \"Supervisor.SendProcessStdin\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.sendRemoteCommEvent\", \"Supervisor.SendRemoteCommEvent\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.reloadConfig\", \"Supervisor.ReloadConfig\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.addProcessGroup\", \"Supervisor.AddProcessGroup\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.removeProcessGroup\", \"Supervisor.RemoveProcessGroup\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.readProcessStdoutLog\", \"Supervisor.ReadProcessStdoutLog\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.readProcessStderrLog\", \"Supervisor.ReadProcessStderrLog\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.tailProcessStdoutLog\", \"Supervisor.TailProcessStdoutLog\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.tailProcessStderrLog\", \"Supervisor.TailProcessStderrLog\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.clearProcessLogs\", \"Supervisor.ClearProcessLogs\")\n\txmlrpcCodec.RegisterAlias(\"supervisor.clearAllProcessLogs\", \"Supervisor.ClearAllProcessLogs\")\n\treturn RPC\n}\n"
        },
        {
          "name": "xmlrpcclient",
          "type": "tree",
          "content": null
        },
        {
          "name": "zombie_reaper.go",
          "type": "blob",
          "size": 0.1611328125,
          "content": "// +build !windows\n\npackage main\n\nimport (\n\t\"github.com/ochinchina/go-reaper\"\n)\n\n// ReapZombie reap the zombie child process\nfunc ReapZombie() {\n\tgo reaper.Reap()\n}\n"
        },
        {
          "name": "zombie_reaper_windows.go",
          "type": "blob",
          "size": 0.0537109375,
          "content": "// +build windows\n\npackage main\n\nfunc ReapZombie() {\n}\n"
        }
      ]
    }
  ]
}