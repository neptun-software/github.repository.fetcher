{
  "metadata": {
    "timestamp": 1736567292880,
    "page": 892,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "hashicorp/yamux",
      "stars": 2291,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2529296875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 15.58203125,
          "content": "Copyright (c) 2014 HashiCorp, Inc.\n\nMozilla Public License, version 2.0\n\n1. Definitions\n\n1.1. \"Contributor\"\n\n     means each individual or legal entity that creates, contributes to the\n     creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n\n     means the combination of the Contributions of others (if any) used by a\n     Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n\n     means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n\n     means Source Code Form to which the initial Contributor has attached the\n     notice in Exhibit A, the Executable Form of such Source Code Form, and\n     Modifications of such Source Code Form, in each case including portions\n     thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n     means\n\n     a. that the initial Contributor has attached the notice described in\n        Exhibit B to the Covered Software; or\n\n     b. that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the terms of\n        a Secondary License.\n\n1.6. \"Executable Form\"\n\n     means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n\n     means a work that combines Covered Software with other material, in a\n     separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n\n     means this document.\n\n1.9. \"Licensable\"\n\n     means having the right to grant, to the maximum extent possible, whether\n     at the time of the initial grant or subsequently, any and all of the\n     rights conveyed by this License.\n\n1.10. \"Modifications\"\n\n     means any of the following:\n\n     a. any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered Software; or\n\n     b. any new file in Source Code Form that contains any Covered Software.\n\n1.11. \"Patent Claims\" of a Contributor\n\n      means any patent claim(s), including without limitation, method,\n      process, and apparatus claims, in any patent Licensable by such\n      Contributor that would be infringed, but for the grant of the License,\n      by the making, using, selling, offering for sale, having made, import,\n      or transfer of either its Contributions or its Contributor Version.\n\n1.12. \"Secondary License\"\n\n      means either the GNU General Public License, Version 2.0, the GNU Lesser\n      General Public License, Version 2.1, the GNU Affero General Public\n      License, Version 3.0, or any later versions of those licenses.\n\n1.13. \"Source Code Form\"\n\n      means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n\n      means an individual or a legal entity exercising rights under this\n      License. For legal entities, \"You\" includes any entity that controls, is\n      controlled by, or is under common control with You. For purposes of this\n      definition, \"control\" means (a) the power, direct or indirect, to cause\n      the direction or management of such entity, whether by contract or\n      otherwise, or (b) ownership of more than fifty percent (50%) of the\n      outstanding shares or beneficial ownership of such entity.\n\n\n2. License Grants and Conditions\n\n2.1. Grants\n\n     Each Contributor hereby grants You a world-wide, royalty-free,\n     non-exclusive license:\n\n     a. under intellectual property rights (other than patent or trademark)\n        Licensable by such Contributor to use, reproduce, make available,\n        modify, display, perform, distribute, and otherwise exploit its\n        Contributions, either on an unmodified basis, with Modifications, or\n        as part of a Larger Work; and\n\n     b. under Patent Claims of such Contributor to make, use, sell, offer for\n        sale, have made, import, and otherwise transfer either its\n        Contributions or its Contributor Version.\n\n2.2. Effective Date\n\n     The licenses granted in Section 2.1 with respect to any Contribution\n     become effective for each Contribution on the date the Contributor first\n     distributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\n     The licenses granted in this Section 2 are the only rights granted under\n     this License. No additional rights or licenses will be implied from the\n     distribution or licensing of Covered Software under this License.\n     Notwithstanding Section 2.1(b) above, no patent license is granted by a\n     Contributor:\n\n     a. for any code that a Contributor has removed from Covered Software; or\n\n     b. for infringements caused by: (i) Your and any other third party's\n        modifications of Covered Software, or (ii) the combination of its\n        Contributions with other software (except as part of its Contributor\n        Version); or\n\n     c. under Patent Claims infringed by Covered Software in the absence of\n        its Contributions.\n\n     This License does not grant any rights in the trademarks, service marks,\n     or logos of any Contributor (except as may be necessary to comply with\n     the notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\n     No Contributor makes additional grants as a result of Your choice to\n     distribute the Covered Software under a subsequent version of this\n     License (see Section 10.2) or under the terms of a Secondary License (if\n     permitted under the terms of Section 3.3).\n\n2.5. Representation\n\n     Each Contributor represents that the Contributor believes its\n     Contributions are its original creation(s) or it has sufficient rights to\n     grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\n     This License is not intended to limit any rights You have under\n     applicable copyright doctrines of fair use, fair dealing, or other\n     equivalents.\n\n2.7. Conditions\n\n     Sections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted in\n     Section 2.1.\n\n\n3. Responsibilities\n\n3.1. Distribution of Source Form\n\n     All distribution of Covered Software in Source Code Form, including any\n     Modifications that You create or to which You contribute, must be under\n     the terms of this License. You must inform recipients that the Source\n     Code Form of the Covered Software is governed by the terms of this\n     License, and how they can obtain a copy of this License. You may not\n     attempt to alter or restrict the recipients' rights in the Source Code\n     Form.\n\n3.2. Distribution of Executable Form\n\n     If You distribute Covered Software in Executable Form then:\n\n     a. such Covered Software must also be made available in Source Code Form,\n        as described in Section 3.1, and You must inform recipients of the\n        Executable Form how they can obtain a copy of such Source Code Form by\n        reasonable means in a timely manner, at a charge no more than the cost\n        of distribution to the recipient; and\n\n     b. You may distribute such Executable Form under the terms of this\n        License, or sublicense it under different terms, provided that the\n        license for the Executable Form does not attempt to limit or alter the\n        recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\n     You may create and distribute a Larger Work under terms of Your choice,\n     provided that You also comply with the requirements of this License for\n     the Covered Software. If the Larger Work is a combination of Covered\n     Software with a work governed by one or more Secondary Licenses, and the\n     Covered Software is not Incompatible With Secondary Licenses, this\n     License permits You to additionally distribute such Covered Software\n     under the terms of such Secondary License(s), so that the recipient of\n     the Larger Work may, at their option, further distribute the Covered\n     Software under the terms of either this License or such Secondary\n     License(s).\n\n3.4. Notices\n\n     You may not remove or alter the substance of any license notices\n     (including copyright notices, patent notices, disclaimers of warranty, or\n     limitations of liability) contained within the Source Code Form of the\n     Covered Software, except that You may alter any license notices to the\n     extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\n     You may choose to offer, and to charge a fee for, warranty, support,\n     indemnity or liability obligations to one or more recipients of Covered\n     Software. However, You may do so only on Your own behalf, and not on\n     behalf of any Contributor. You must make it absolutely clear that any\n     such warranty, support, indemnity, or liability obligation is offered by\n     You alone, and You hereby agree to indemnify every Contributor for any\n     liability incurred by such Contributor as a result of warranty, support,\n     indemnity or liability terms You offer. You may include additional\n     disclaimers of warranty and limitations of liability specific to any\n     jurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n\n   If it is impossible for You to comply with any of the terms of this License\n   with respect to some or all of the Covered Software due to statute,\n   judicial order, or regulation then You must: (a) comply with the terms of\n   this License to the maximum extent possible; and (b) describe the\n   limitations and the code they affect. Such description must be placed in a\n   text file included with all distributions of the Covered Software under\n   this License. Except to the extent prohibited by statute or regulation,\n   such description must be sufficiently detailed for a recipient of ordinary\n   skill to be able to understand it.\n\n5. Termination\n\n5.1. The rights granted under this License will terminate automatically if You\n     fail to comply with any of its terms. However, if You become compliant,\n     then the rights granted under this License from a particular Contributor\n     are reinstated (a) provisionally, unless and until such Contributor\n     explicitly and finally terminates Your grants, and (b) on an ongoing\n     basis, if such Contributor fails to notify You of the non-compliance by\n     some reasonable means prior to 60 days after You have come back into\n     compliance. Moreover, Your grants from a particular Contributor are\n     reinstated on an ongoing basis if such Contributor notifies You of the\n     non-compliance by some reasonable means, this is the first time You have\n     received notice of non-compliance with this License from such\n     Contributor, and You become compliant prior to 30 days after Your receipt\n     of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\n     infringement claim (excluding declaratory judgment actions,\n     counter-claims, and cross-claims) alleging that a Contributor Version\n     directly or indirectly infringes any patent, then the rights granted to\n     You by any and all Contributors for the Covered Software under Section\n     2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all end user\n     license agreements (excluding distributors and resellers) which have been\n     validly granted by You or Your distributors under this License prior to\n     termination shall survive termination.\n\n6. Disclaimer of Warranty\n\n   Covered Software is provided under this License on an \"as is\" basis,\n   without warranty of any kind, either expressed, implied, or statutory,\n   including, without limitation, warranties that the Covered Software is free\n   of defects, merchantable, fit for a particular purpose or non-infringing.\n   The entire risk as to the quality and performance of the Covered Software\n   is with You. Should any Covered Software prove defective in any respect,\n   You (not any Contributor) assume the cost of any necessary servicing,\n   repair, or correction. This disclaimer of warranty constitutes an essential\n   part of this License. No use of  any Covered Software is authorized under\n   this License except under this disclaimer.\n\n7. Limitation of Liability\n\n   Under no circumstances and under no legal theory, whether tort (including\n   negligence), contract, or otherwise, shall any Contributor, or anyone who\n   distributes Covered Software as permitted above, be liable to You for any\n   direct, indirect, special, incidental, or consequential damages of any\n   character including, without limitation, damages for lost profits, loss of\n   goodwill, work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses, even if such party shall have been\n   informed of the possibility of such damages. This limitation of liability\n   shall not apply to liability for death or personal injury resulting from\n   such party's negligence to the extent applicable law prohibits such\n   limitation. Some jurisdictions do not allow the exclusion or limitation of\n   incidental or consequential damages, so this exclusion and limitation may\n   not apply to You.\n\n8. Litigation\n\n   Any litigation relating to this License may be brought only in the courts\n   of a jurisdiction where the defendant maintains its principal place of\n   business and such litigation shall be governed by laws of that\n   jurisdiction, without reference to its conflict-of-law provisions. Nothing\n   in this Section shall prevent a party's ability to bring cross-claims or\n   counter-claims.\n\n9. Miscellaneous\n\n   This License represents the complete agreement concerning the subject\n   matter hereof. If any provision of this License is held to be\n   unenforceable, such provision shall be reformed only to the extent\n   necessary to make it enforceable. Any law or regulation which provides that\n   the language of a contract shall be construed against the drafter shall not\n   be used to construe this License against a Contributor.\n\n\n10. Versions of the License\n\n10.1. New Versions\n\n      Mozilla Foundation is the license steward. Except as provided in Section\n      10.3, no one other than the license steward has the right to modify or\n      publish new versions of this License. Each version will be given a\n      distinguishing version number.\n\n10.2. Effect of New Versions\n\n      You may distribute the Covered Software under the terms of the version\n      of the License under which You originally received the Covered Software,\n      or under the terms of any subsequent version published by the license\n      steward.\n\n10.3. Modified Versions\n\n      If you create software not governed by this License, and you want to\n      create a new license for such software, you may create and use a\n      modified version of this License if you rename the license and remove\n      any references to the name of the license steward (except to note that\n      such modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\n      Licenses If You choose to distribute Source Code Form that is\n      Incompatible With Secondary Licenses under the terms of this version of\n      the License, the notice described in Exhibit B of this License must be\n      attached.\n\nExhibit A - Source Code Form License Notice\n\n      This Source Code Form is subject to the\n      terms of the Mozilla Public License, v.\n      2.0. If a copy of the MPL was not\n      distributed with this file, You can\n      obtain one at\n      http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular file,\nthen You may include the notice in a location (such as a LICENSE file in a\nrelevant directory) where a recipient would be likely to look for such a\nnotice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n\n      This Source Code Form is \"Incompatible\n      With Secondary Licenses\", as defined by\n      the Mozilla Public License, v. 2.0."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 1.8291015625,
          "content": "# Yamux\n\nYamux (Yet another Multiplexer) is a multiplexing library for Golang.\nIt relies on an underlying connection to provide reliability\nand ordering, such as TCP or Unix domain sockets, and provides\nstream-oriented multiplexing. It is inspired by SPDY but is not\ninteroperable with it.\n\nYamux features include:\n\n* Bi-directional streams\n  * Streams can be opened by either client or server\n  * Useful for NAT traversal\n  * Server-side push support\n* Flow control\n  * Avoid starvation\n  * Back-pressure to prevent overwhelming a receiver\n* Keep Alives\n  * Enables persistent connections over a load balancer\n* Efficient\n  * Enables thousands of logical streams with low overhead\n\n## Documentation\n\nFor complete documentation, see the associated [Godoc](http://godoc.org/github.com/hashicorp/yamux).\n\n## Specification\n\nThe full specification for Yamux is provided in the `spec.md` file.\nIt can be used as a guide to implementors of interoperable libraries.\n\n## Usage\n\nUsing Yamux is remarkably simple:\n\n```go\n\nfunc client() {\n    // Get a TCP connection\n    conn, err := net.Dial(...)\n    if err != nil {\n        panic(err)\n    }\n\n    // Setup client side of yamux\n    session, err := yamux.Client(conn, nil)\n    if err != nil {\n        panic(err)\n    }\n\n    // Open a new stream\n    stream, err := session.Open()\n    if err != nil {\n        panic(err)\n    }\n\n    // Stream implements net.Conn\n    stream.Write([]byte(\"ping\"))\n}\n\nfunc server() {\n    // Accept a TCP connection\n    conn, err := listener.Accept()\n    if err != nil {\n        panic(err)\n    }\n\n    // Setup server side of yamux\n    session, err := yamux.Server(conn, nil)\n    if err != nil {\n        panic(err)\n    }\n\n    // Accept a stream\n    stream, err := session.Accept()\n    if err != nil {\n        panic(err)\n    }\n\n    // Listen for a message\n    buf := make([]byte, 4)\n    stream.Read(buf)\n}\n\n```\n\n"
        },
        {
          "name": "addr.go",
          "type": "blob",
          "size": 1.185546875,
          "content": "package yamux\n\nimport (\n\t\"fmt\"\n\t\"net\"\n)\n\n// hasAddr is used to get the address from the underlying connection\ntype hasAddr interface {\n\tLocalAddr() net.Addr\n\tRemoteAddr() net.Addr\n}\n\n// yamuxAddr is used when we cannot get the underlying address\ntype yamuxAddr struct {\n\tAddr string\n}\n\nfunc (*yamuxAddr) Network() string {\n\treturn \"yamux\"\n}\n\nfunc (y *yamuxAddr) String() string {\n\treturn fmt.Sprintf(\"yamux:%s\", y.Addr)\n}\n\n// Addr is used to get the address of the listener.\nfunc (s *Session) Addr() net.Addr {\n\treturn s.LocalAddr()\n}\n\n// LocalAddr is used to get the local address of the\n// underlying connection.\nfunc (s *Session) LocalAddr() net.Addr {\n\taddr, ok := s.conn.(hasAddr)\n\tif !ok {\n\t\treturn &yamuxAddr{\"local\"}\n\t}\n\treturn addr.LocalAddr()\n}\n\n// RemoteAddr is used to get the address of remote end\n// of the underlying connection\nfunc (s *Session) RemoteAddr() net.Addr {\n\taddr, ok := s.conn.(hasAddr)\n\tif !ok {\n\t\treturn &yamuxAddr{\"remote\"}\n\t}\n\treturn addr.RemoteAddr()\n}\n\n// LocalAddr returns the local address\nfunc (s *Stream) LocalAddr() net.Addr {\n\treturn s.session.LocalAddr()\n}\n\n// RemoteAddr returns the remote address\nfunc (s *Stream) RemoteAddr() net.Addr {\n\treturn s.session.RemoteAddr()\n}\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 4.7763671875,
          "content": "package yamux\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"testing\"\n)\n\nfunc BenchmarkPing(b *testing.B) {\n\tclient, _ := testClientServer(b)\n\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\trtt, err := client.Ping()\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tif rtt == 0 {\n\t\t\tb.Fatalf(\"bad: %v\", rtt)\n\t\t}\n\t}\n}\n\nfunc BenchmarkAccept(b *testing.B) {\n\tclient, server := testClientServer(b)\n\n\tdoneCh := make(chan struct{})\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tgo func() {\n\t\tdefer close(doneCh)\n\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tstream, err := server.AcceptStream()\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tstream.Close()\n\t\t}\n\t}()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tstream.Close()\n\t}\n\t<-doneCh\n}\n\nfunc BenchmarkSendRecv32(b *testing.B) {\n\tconst payloadSize = 32\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv64(b *testing.B) {\n\tconst payloadSize = 64\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv128(b *testing.B) {\n\tconst payloadSize = 128\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv256(b *testing.B) {\n\tconst payloadSize = 256\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv512(b *testing.B) {\n\tconst payloadSize = 512\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv1024(b *testing.B) {\n\tconst payloadSize = 1024\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv2048(b *testing.B) {\n\tconst payloadSize = 2048\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecv4096(b *testing.B) {\n\tconst payloadSize = 4096\n\tbenchmarkSendRecv(b, payloadSize, payloadSize)\n}\n\nfunc BenchmarkSendRecvLarge(b *testing.B) {\n\tconst sendSize = 512 * 1024 * 1024 //512 MB\n\tconst recvSize = 4 * 1024          //4 KB\n\tbenchmarkSendRecv(b, sendSize, recvSize)\n}\n\nfunc benchmarkSendRecv(b *testing.B, sendSize, recvSize int) {\n\tclient, server := testClientServer(b)\n\n\tsendBuf := make([]byte, sendSize)\n\trecvBuf := make([]byte, recvSize)\n\terrCh := make(chan error, 1)\n\n\tb.SetBytes(int64(sendSize))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tswitch {\n\t\tcase sendSize == recvSize:\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tif _, err := stream.Read(recvBuf); err != nil {\n\t\t\t\t\terrCh <- err\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\tcase recvSize > sendSize:\n\t\t\terrCh <- fmt.Errorf(\"bad test case; recvSize was: %d and sendSize was: %d, but recvSize must be <= sendSize!\", recvSize, sendSize)\n\t\t\treturn\n\n\t\tdefault:\n\t\t\tchunks := sendSize / recvSize\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\tfor j := 0; j < chunks; j++ {\n\t\t\t\t\tif _, err := stream.Read(recvBuf); err != nil {\n\t\t\t\t\t\terrCh <- err\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tb.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream.Close()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif _, err := stream.Write(sendBuf); err != nil {\n\t\t\tb.Fatalf(\"err: %v\", err)\n\t\t}\n\t}\n\n\tdrainErrorsUntil(b, errCh, 1, 0, \"\")\n}\n\nfunc BenchmarkSendRecvParallel32(b *testing.B) {\n\tconst payloadSize = 32\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel64(b *testing.B) {\n\tconst payloadSize = 64\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel128(b *testing.B) {\n\tconst payloadSize = 128\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel256(b *testing.B) {\n\tconst payloadSize = 256\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel512(b *testing.B) {\n\tconst payloadSize = 512\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel1024(b *testing.B) {\n\tconst payloadSize = 1024\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel2048(b *testing.B) {\n\tconst payloadSize = 2048\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc BenchmarkSendRecvParallel4096(b *testing.B) {\n\tconst payloadSize = 4096\n\tbenchmarkSendRecvParallel(b, payloadSize)\n}\n\nfunc benchmarkSendRecvParallel(b *testing.B, sendSize int) {\n\tclient, server := testClientServer(b)\n\n\tsendBuf := make([]byte, sendSize)\n\tdiscarder := io.Discard.(io.ReaderFrom)\n\tb.SetBytes(int64(sendSize))\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\n\tb.RunParallel(func(pb *testing.PB) {\n\t\terrCh := make(chan error, 1)\n\t\tgo func() {\n\t\t\tstream, err := server.AcceptStream()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer stream.Close()\n\n\t\t\tif _, err := discarder.ReadFrom(stream); err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\terrCh <- nil\n\t\t}()\n\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\tb.Fatalf(\"err: %v\", err)\n\t\t}\n\n\t\tfor pb.Next() {\n\t\t\tif _, err := stream.Write(sendBuf); err != nil {\n\t\t\t\tb.Fatalf(\"err: %v\", err)\n\t\t\t}\n\t\t}\n\n\t\tstream.Close()\n\n\t\tdrainErrorsUntil(b, errCh, 1, 0, \"\")\n\t})\n}\n"
        },
        {
          "name": "const.go",
          "type": "blob",
          "size": 4.4814453125,
          "content": "package yamux\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n)\n\n// NetError implements net.Error\ntype NetError struct {\n\terr       error\n\ttimeout   bool\n\ttemporary bool\n}\n\nfunc (e *NetError) Error() string {\n\treturn e.err.Error()\n}\n\nfunc (e *NetError) Timeout() bool {\n\treturn e.timeout\n}\n\nfunc (e *NetError) Temporary() bool {\n\treturn e.temporary\n}\n\nvar (\n\t// ErrInvalidVersion means we received a frame with an\n\t// invalid version\n\tErrInvalidVersion = fmt.Errorf(\"invalid protocol version\")\n\n\t// ErrInvalidMsgType means we received a frame with an\n\t// invalid message type\n\tErrInvalidMsgType = fmt.Errorf(\"invalid msg type\")\n\n\t// ErrSessionShutdown is used if there is a shutdown during\n\t// an operation\n\tErrSessionShutdown = fmt.Errorf(\"session shutdown\")\n\n\t// ErrStreamsExhausted is returned if we have no more\n\t// stream ids to issue\n\tErrStreamsExhausted = fmt.Errorf(\"streams exhausted\")\n\n\t// ErrDuplicateStream is used if a duplicate stream is\n\t// opened inbound\n\tErrDuplicateStream = fmt.Errorf(\"duplicate stream initiated\")\n\n\t// ErrReceiveWindowExceeded indicates the window was exceeded\n\tErrRecvWindowExceeded = fmt.Errorf(\"recv window exceeded\")\n\n\t// ErrTimeout is used when we reach an IO deadline\n\tErrTimeout = &NetError{\n\t\terr: fmt.Errorf(\"i/o deadline reached\"),\n\n\t\t// Error should meet net.Error interface for timeouts for compatability\n\t\t// with standard library expectations, such as http servers.\n\t\ttimeout: true,\n\t}\n\n\t// ErrStreamClosed is returned when using a closed stream\n\tErrStreamClosed = fmt.Errorf(\"stream closed\")\n\n\t// ErrUnexpectedFlag is set when we get an unexpected flag\n\tErrUnexpectedFlag = fmt.Errorf(\"unexpected flag\")\n\n\t// ErrRemoteGoAway is used when we get a go away from the other side\n\tErrRemoteGoAway = fmt.Errorf(\"remote end is not accepting connections\")\n\n\t// ErrConnectionReset is sent if a stream is reset. This can happen\n\t// if the backlog is exceeded, or if there was a remote GoAway.\n\tErrConnectionReset = fmt.Errorf(\"connection reset\")\n\n\t// ErrConnectionWriteTimeout indicates that we hit the \"safety valve\"\n\t// timeout writing to the underlying stream connection.\n\tErrConnectionWriteTimeout = fmt.Errorf(\"connection write timeout\")\n\n\t// ErrKeepAliveTimeout is sent if a missed keepalive caused the stream close\n\tErrKeepAliveTimeout = fmt.Errorf(\"keepalive timeout\")\n)\n\nconst (\n\t// protoVersion is the only version we support\n\tprotoVersion uint8 = 0\n)\n\nconst (\n\t// Data is used for data frames. They are followed\n\t// by length bytes worth of payload.\n\ttypeData uint8 = iota\n\n\t// WindowUpdate is used to change the window of\n\t// a given stream. The length indicates the delta\n\t// update to the window.\n\ttypeWindowUpdate\n\n\t// Ping is sent as a keep-alive or to measure\n\t// the RTT. The StreamID and Length value are echoed\n\t// back in the response.\n\ttypePing\n\n\t// GoAway is sent to terminate a session. The StreamID\n\t// should be 0 and the length is an error code.\n\ttypeGoAway\n)\n\nconst (\n\t// SYN is sent to signal a new stream. May\n\t// be sent with a data payload\n\tflagSYN uint16 = 1 << iota\n\n\t// ACK is sent to acknowledge a new stream. May\n\t// be sent with a data payload\n\tflagACK\n\n\t// FIN is sent to half-close the given stream.\n\t// May be sent with a data payload.\n\tflagFIN\n\n\t// RST is used to hard close a given stream.\n\tflagRST\n)\n\nconst (\n\t// initialStreamWindow is the initial stream window size\n\tinitialStreamWindow uint32 = 256 * 1024\n)\n\nconst (\n\t// goAwayNormal is sent on a normal termination\n\tgoAwayNormal uint32 = iota\n\n\t// goAwayProtoErr sent on a protocol error\n\tgoAwayProtoErr\n\n\t// goAwayInternalErr sent on an internal error\n\tgoAwayInternalErr\n)\n\nconst (\n\tsizeOfVersion  = 1\n\tsizeOfType     = 1\n\tsizeOfFlags    = 2\n\tsizeOfStreamID = 4\n\tsizeOfLength   = 4\n\theaderSize     = sizeOfVersion + sizeOfType + sizeOfFlags +\n\t\tsizeOfStreamID + sizeOfLength\n)\n\ntype header []byte\n\nfunc (h header) Version() uint8 {\n\treturn h[0]\n}\n\nfunc (h header) MsgType() uint8 {\n\treturn h[1]\n}\n\nfunc (h header) Flags() uint16 {\n\treturn binary.BigEndian.Uint16(h[2:4])\n}\n\nfunc (h header) StreamID() uint32 {\n\treturn binary.BigEndian.Uint32(h[4:8])\n}\n\nfunc (h header) Length() uint32 {\n\treturn binary.BigEndian.Uint32(h[8:12])\n}\n\nfunc (h header) String() string {\n\treturn fmt.Sprintf(\"Vsn:%d Type:%d Flags:%d StreamID:%d Length:%d\",\n\t\th.Version(), h.MsgType(), h.Flags(), h.StreamID(), h.Length())\n}\n\nfunc (h header) encode(msgType uint8, flags uint16, streamID uint32, length uint32) {\n\th[0] = protoVersion\n\th[1] = msgType\n\tbinary.BigEndian.PutUint16(h[2:4], flags)\n\tbinary.BigEndian.PutUint32(h[4:8], streamID)\n\tbinary.BigEndian.PutUint32(h[8:12], length)\n}\n"
        },
        {
          "name": "const_test.go",
          "type": "blob",
          "size": 1.279296875,
          "content": "package yamux\n\nimport (\n\t\"testing\"\n)\n\nfunc TestConst(t *testing.T) {\n\tif protoVersion != 0 {\n\t\tt.Fatalf(\"bad: %v\", protoVersion)\n\t}\n\n\tif typeData != 0 {\n\t\tt.Fatalf(\"bad: %v\", typeData)\n\t}\n\tif typeWindowUpdate != 1 {\n\t\tt.Fatalf(\"bad: %v\", typeWindowUpdate)\n\t}\n\tif typePing != 2 {\n\t\tt.Fatalf(\"bad: %v\", typePing)\n\t}\n\tif typeGoAway != 3 {\n\t\tt.Fatalf(\"bad: %v\", typeGoAway)\n\t}\n\n\tif flagSYN != 1 {\n\t\tt.Fatalf(\"bad: %v\", flagSYN)\n\t}\n\tif flagACK != 2 {\n\t\tt.Fatalf(\"bad: %v\", flagACK)\n\t}\n\tif flagFIN != 4 {\n\t\tt.Fatalf(\"bad: %v\", flagFIN)\n\t}\n\tif flagRST != 8 {\n\t\tt.Fatalf(\"bad: %v\", flagRST)\n\t}\n\n\tif goAwayNormal != 0 {\n\t\tt.Fatalf(\"bad: %v\", goAwayNormal)\n\t}\n\tif goAwayProtoErr != 1 {\n\t\tt.Fatalf(\"bad: %v\", goAwayProtoErr)\n\t}\n\tif goAwayInternalErr != 2 {\n\t\tt.Fatalf(\"bad: %v\", goAwayInternalErr)\n\t}\n\n\tif headerSize != 12 {\n\t\tt.Fatalf(\"bad header size\")\n\t}\n}\n\nfunc TestEncodeDecode(t *testing.T) {\n\thdr := header(make([]byte, headerSize))\n\thdr.encode(typeWindowUpdate, flagACK|flagRST, 1234, 4321)\n\n\tif hdr.Version() != protoVersion {\n\t\tt.Fatalf(\"bad: %v\", hdr)\n\t}\n\tif hdr.MsgType() != typeWindowUpdate {\n\t\tt.Fatalf(\"bad: %v\", hdr)\n\t}\n\tif hdr.Flags() != flagACK|flagRST {\n\t\tt.Fatalf(\"bad: %v\", hdr)\n\t}\n\tif hdr.StreamID() != 1234 {\n\t\tt.Fatalf(\"bad: %v\", hdr)\n\t}\n\tif hdr.Length() != 4321 {\n\t\tt.Fatalf(\"bad: %v\", hdr)\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0419921875,
          "content": "module github.com/hashicorp/yamux\n\ngo 1.20\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "mux.go",
          "type": "blob",
          "size": 3.7236328125,
          "content": "package yamux\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"time\"\n)\n\n// Config is used to tune the Yamux session\ntype Config struct {\n\t// AcceptBacklog is used to limit how many streams may be\n\t// waiting an accept.\n\tAcceptBacklog int\n\n\t// EnableKeepalive is used to do a period keep alive\n\t// messages using a ping.\n\tEnableKeepAlive bool\n\n\t// KeepAliveInterval is how often to perform the keep alive\n\tKeepAliveInterval time.Duration\n\n\t// ConnectionWriteTimeout is meant to be a \"safety valve\" timeout after\n\t// we which will suspect a problem with the underlying connection and\n\t// close it. This is only applied to writes, where's there's generally\n\t// an expectation that things will move along quickly.\n\tConnectionWriteTimeout time.Duration\n\n\t// MaxStreamWindowSize is used to control the maximum\n\t// window size that we allow for a stream.\n\tMaxStreamWindowSize uint32\n\n\t// StreamOpenTimeout is the maximum amount of time that a stream will\n\t// be allowed to remain in pending state while waiting for an ack from the peer.\n\t// Once the timeout is reached the session will be gracefully closed.\n\t// A zero value disables the StreamOpenTimeout allowing unbounded\n\t// blocking on OpenStream calls.\n\tStreamOpenTimeout time.Duration\n\n\t// StreamCloseTimeout is the maximum time that a stream will allowed to\n\t// be in a half-closed state when `Close` is called before forcibly\n\t// closing the connection. Forcibly closed connections will empty the\n\t// receive buffer, drop any future packets received for that stream,\n\t// and send a RST to the remote side.\n\tStreamCloseTimeout time.Duration\n\n\t// LogOutput is used to control the log destination. Either Logger or\n\t// LogOutput can be set, not both.\n\tLogOutput io.Writer\n\n\t// Logger is used to pass in the logger to be used. Either Logger or\n\t// LogOutput can be set, not both.\n\tLogger Logger\n}\n\nfunc (c *Config) Clone() *Config {\n\tc2 := *c\n\treturn &c2\n}\n\n// DefaultConfig is used to return a default configuration\nfunc DefaultConfig() *Config {\n\treturn &Config{\n\t\tAcceptBacklog:          256,\n\t\tEnableKeepAlive:        true,\n\t\tKeepAliveInterval:      30 * time.Second,\n\t\tConnectionWriteTimeout: 10 * time.Second,\n\t\tMaxStreamWindowSize:    initialStreamWindow,\n\t\tStreamCloseTimeout:     5 * time.Minute,\n\t\tStreamOpenTimeout:      75 * time.Second,\n\t\tLogOutput:              os.Stderr,\n\t}\n}\n\n// VerifyConfig is used to verify the sanity of configuration\nfunc VerifyConfig(config *Config) error {\n\tif config.AcceptBacklog <= 0 {\n\t\treturn fmt.Errorf(\"backlog must be positive\")\n\t}\n\tif config.KeepAliveInterval == 0 {\n\t\treturn fmt.Errorf(\"keep-alive interval must be positive\")\n\t}\n\tif config.MaxStreamWindowSize < initialStreamWindow {\n\t\treturn fmt.Errorf(\"MaxStreamWindowSize must be larger than %d\", initialStreamWindow)\n\t}\n\tif config.LogOutput != nil && config.Logger != nil {\n\t\treturn fmt.Errorf(\"both Logger and LogOutput may not be set, select one\")\n\t} else if config.LogOutput == nil && config.Logger == nil {\n\t\treturn fmt.Errorf(\"one of Logger or LogOutput must be set, select one\")\n\t}\n\treturn nil\n}\n\n// Server is used to initialize a new server-side connection.\n// There must be at most one server-side connection. If a nil config is\n// provided, the DefaultConfiguration will be used.\nfunc Server(conn io.ReadWriteCloser, config *Config) (*Session, error) {\n\tif config == nil {\n\t\tconfig = DefaultConfig()\n\t}\n\tif err := VerifyConfig(config); err != nil {\n\t\treturn nil, err\n\t}\n\treturn newSession(config, conn, false), nil\n}\n\n// Client is used to initialize a new client-side connection.\n// There must be at most one client-side connection.\nfunc Client(conn io.ReadWriteCloser, config *Config) (*Session, error) {\n\tif config == nil {\n\t\tconfig = DefaultConfig()\n\t}\n\n\tif err := VerifyConfig(config); err != nil {\n\t\treturn nil, err\n\t}\n\treturn newSession(config, conn, true), nil\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 18.4560546875,
          "content": "package yamux\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"math\"\n\t\"net\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\n// Session is used to wrap a reliable ordered connection and to\n// multiplex it into multiple streams.\ntype Session struct {\n\t// remoteGoAway indicates the remote side does\n\t// not want futher connections. Must be first for alignment.\n\tremoteGoAway int32\n\n\t// localGoAway indicates that we should stop\n\t// accepting futher connections. Must be first for alignment.\n\tlocalGoAway int32\n\n\t// nextStreamID is the next stream we should\n\t// send. This depends if we are a client/server.\n\tnextStreamID uint32\n\n\t// config holds our configuration\n\tconfig *Config\n\n\t// logger is used for our logs\n\tlogger Logger\n\n\t// conn is the underlying connection\n\tconn io.ReadWriteCloser\n\n\t// bufRead is a buffered reader\n\tbufRead *bufio.Reader\n\n\t// pings is used to track inflight pings\n\tpings    map[uint32]chan struct{}\n\tpingID   uint32\n\tpingLock sync.Mutex\n\n\t// streams maps a stream id to a stream, and inflight has an entry\n\t// for any outgoing stream that has not yet been established. Both are\n\t// protected by streamLock.\n\tstreams    map[uint32]*Stream\n\tinflight   map[uint32]struct{}\n\tstreamLock sync.Mutex\n\n\t// synCh acts like a semaphore. It is sized to the AcceptBacklog which\n\t// is assumed to be symmetric between the client and server. This allows\n\t// the client to avoid exceeding the backlog and instead blocks the open.\n\tsynCh chan struct{}\n\n\t// acceptCh is used to pass ready streams to the client\n\tacceptCh chan *Stream\n\n\t// sendCh is used to mark a stream as ready to send,\n\t// or to send a header out directly.\n\tsendCh chan *sendReady\n\n\t// recvDoneCh is closed when recv() exits to avoid a race\n\t// between stream registration and stream shutdown\n\trecvDoneCh chan struct{}\n\tsendDoneCh chan struct{}\n\n\t// shutdown is used to safely close a session\n\tshutdown        bool\n\tshutdownErr     error\n\tshutdownCh      chan struct{}\n\tshutdownLock    sync.Mutex\n\tshutdownErrLock sync.Mutex\n}\n\n// sendReady is used to either mark a stream as ready\n// or to directly send a header\ntype sendReady struct {\n\tHdr  []byte\n\tmu   sync.Mutex // Protects Body from unsafe reads.\n\tBody []byte\n\tErr  chan error\n}\n\n// newSession is used to construct a new session\nfunc newSession(config *Config, conn io.ReadWriteCloser, client bool) *Session {\n\tlogger := config.Logger\n\tif logger == nil {\n\t\tlogger = log.New(config.LogOutput, \"\", log.LstdFlags)\n\t}\n\n\ts := &Session{\n\t\tconfig:     config,\n\t\tlogger:     logger,\n\t\tconn:       conn,\n\t\tbufRead:    bufio.NewReader(conn),\n\t\tpings:      make(map[uint32]chan struct{}),\n\t\tstreams:    make(map[uint32]*Stream),\n\t\tinflight:   make(map[uint32]struct{}),\n\t\tsynCh:      make(chan struct{}, config.AcceptBacklog),\n\t\tacceptCh:   make(chan *Stream, config.AcceptBacklog),\n\t\tsendCh:     make(chan *sendReady, 64),\n\t\trecvDoneCh: make(chan struct{}),\n\t\tsendDoneCh: make(chan struct{}),\n\t\tshutdownCh: make(chan struct{}),\n\t}\n\tif client {\n\t\ts.nextStreamID = 1\n\t} else {\n\t\ts.nextStreamID = 2\n\t}\n\tgo s.recv()\n\tgo s.send()\n\tif config.EnableKeepAlive {\n\t\tgo s.keepalive()\n\t}\n\treturn s\n}\n\n// IsClosed does a safe check to see if we have shutdown\nfunc (s *Session) IsClosed() bool {\n\tselect {\n\tcase <-s.shutdownCh:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// CloseChan returns a read-only channel which is closed as\n// soon as the session is closed.\nfunc (s *Session) CloseChan() <-chan struct{} {\n\treturn s.shutdownCh\n}\n\n// NumStreams returns the number of currently open streams\nfunc (s *Session) NumStreams() int {\n\ts.streamLock.Lock()\n\tnum := len(s.streams)\n\ts.streamLock.Unlock()\n\treturn num\n}\n\n// Open is used to create a new stream as a net.Conn\nfunc (s *Session) Open() (net.Conn, error) {\n\tconn, err := s.OpenStream()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n\n// OpenStream is used to create a new stream\nfunc (s *Session) OpenStream() (*Stream, error) {\n\tif s.IsClosed() {\n\t\treturn nil, ErrSessionShutdown\n\t}\n\tif atomic.LoadInt32(&s.remoteGoAway) == 1 {\n\t\treturn nil, ErrRemoteGoAway\n\t}\n\n\t// Block if we have too many inflight SYNs\n\tselect {\n\tcase s.synCh <- struct{}{}:\n\tcase <-s.shutdownCh:\n\t\treturn nil, ErrSessionShutdown\n\t}\n\nGET_ID:\n\t// Get an ID, and check for stream exhaustion\n\tid := atomic.LoadUint32(&s.nextStreamID)\n\tif id >= math.MaxUint32-1 {\n\t\treturn nil, ErrStreamsExhausted\n\t}\n\tif !atomic.CompareAndSwapUint32(&s.nextStreamID, id, id+2) {\n\t\tgoto GET_ID\n\t}\n\n\t// Register the stream\n\tstream := newStream(s, id, streamInit)\n\ts.streamLock.Lock()\n\ts.streams[id] = stream\n\ts.inflight[id] = struct{}{}\n\ts.streamLock.Unlock()\n\n\tif s.config.StreamOpenTimeout > 0 {\n\t\tgo s.setOpenTimeout(stream)\n\t}\n\n\t// Send the window update to create\n\tif err := stream.sendWindowUpdate(); err != nil {\n\t\tselect {\n\t\tcase <-s.synCh:\n\t\tdefault:\n\t\t\ts.logger.Printf(\"[ERR] yamux: aborted stream open without inflight syn semaphore\")\n\t\t}\n\t\treturn nil, err\n\t}\n\treturn stream, nil\n}\n\n// setOpenTimeout implements a timeout for streams that are opened but not established.\n// If the StreamOpenTimeout is exceeded we assume the peer is unable to ACK,\n// and close the session.\n// The number of running timers is bounded by the capacity of the synCh.\nfunc (s *Session) setOpenTimeout(stream *Stream) {\n\ttimer := time.NewTimer(s.config.StreamOpenTimeout)\n\tdefer timer.Stop()\n\n\tselect {\n\tcase <-stream.establishCh:\n\t\treturn\n\tcase <-s.shutdownCh:\n\t\treturn\n\tcase <-timer.C:\n\t\t// Timeout reached while waiting for ACK.\n\t\t// Close the session to force connection re-establishment.\n\t\ts.logger.Printf(\"[ERR] yamux: aborted stream open (destination=%s): %v\", s.RemoteAddr().String(), ErrTimeout.err)\n\t\ts.Close()\n\t}\n}\n\n// Accept is used to block until the next available stream\n// is ready to be accepted.\nfunc (s *Session) Accept() (net.Conn, error) {\n\tconn, err := s.AcceptStream()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, err\n}\n\n// AcceptStream is used to block until the next available stream\n// is ready to be accepted.\nfunc (s *Session) AcceptStream() (*Stream, error) {\n\tselect {\n\tcase stream := <-s.acceptCh:\n\t\tif err := stream.sendWindowUpdate(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn stream, nil\n\tcase <-s.shutdownCh:\n\t\treturn nil, s.shutdownErr\n\t}\n}\n\n// AcceptStream is used to block until the next available stream\n// is ready to be accepted.\nfunc (s *Session) AcceptStreamWithContext(ctx context.Context) (*Stream, error) {\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn nil, ctx.Err()\n\tcase stream := <-s.acceptCh:\n\t\tif err := stream.sendWindowUpdate(); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn stream, nil\n\tcase <-s.shutdownCh:\n\t\treturn nil, s.shutdownErr\n\t}\n}\n\n// Close is used to close the session and all streams.\n// Attempts to send a GoAway before closing the connection.\nfunc (s *Session) Close() error {\n\ts.shutdownLock.Lock()\n\tdefer s.shutdownLock.Unlock()\n\n\tif s.shutdown {\n\t\treturn nil\n\t}\n\ts.shutdown = true\n\n\ts.shutdownErrLock.Lock()\n\tif s.shutdownErr == nil {\n\t\ts.shutdownErr = ErrSessionShutdown\n\t}\n\ts.shutdownErrLock.Unlock()\n\n\tclose(s.shutdownCh)\n\n\ts.conn.Close()\n\t<-s.recvDoneCh\n\n\ts.streamLock.Lock()\n\tdefer s.streamLock.Unlock()\n\tfor _, stream := range s.streams {\n\t\tstream.forceClose()\n\t}\n\t<-s.sendDoneCh\n\treturn nil\n}\n\n// exitErr is used to handle an error that is causing the\n// session to terminate.\nfunc (s *Session) exitErr(err error) {\n\ts.shutdownErrLock.Lock()\n\tif s.shutdownErr == nil {\n\t\ts.shutdownErr = err\n\t}\n\ts.shutdownErrLock.Unlock()\n\ts.Close()\n}\n\n// GoAway can be used to prevent accepting further\n// connections. It does not close the underlying conn.\nfunc (s *Session) GoAway() error {\n\treturn s.waitForSend(s.goAway(goAwayNormal), nil)\n}\n\n// goAway is used to send a goAway message\nfunc (s *Session) goAway(reason uint32) header {\n\tatomic.SwapInt32(&s.localGoAway, 1)\n\thdr := header(make([]byte, headerSize))\n\thdr.encode(typeGoAway, 0, 0, reason)\n\treturn hdr\n}\n\n// Ping is used to measure the RTT response time\nfunc (s *Session) Ping() (time.Duration, error) {\n\t// Get a channel for the ping\n\tch := make(chan struct{})\n\n\t// Get a new ping id, mark as pending\n\ts.pingLock.Lock()\n\tid := s.pingID\n\ts.pingID++\n\ts.pings[id] = ch\n\ts.pingLock.Unlock()\n\n\t// Send the ping request\n\thdr := header(make([]byte, headerSize))\n\thdr.encode(typePing, flagSYN, 0, id)\n\tif err := s.waitForSend(hdr, nil); err != nil {\n\t\treturn 0, err\n\t}\n\n\t// Wait for a response\n\tstart := time.Now()\n\tselect {\n\tcase <-ch:\n\tcase <-time.After(s.config.ConnectionWriteTimeout):\n\t\ts.pingLock.Lock()\n\t\tdelete(s.pings, id) // Ignore it if a response comes later.\n\t\ts.pingLock.Unlock()\n\t\treturn 0, ErrTimeout\n\tcase <-s.shutdownCh:\n\t\treturn 0, ErrSessionShutdown\n\t}\n\n\t// Compute the RTT\n\treturn time.Since(start), nil\n}\n\n// keepalive is a long running goroutine that periodically does\n// a ping to keep the connection alive.\nfunc (s *Session) keepalive() {\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(s.config.KeepAliveInterval):\n\t\t\t_, err := s.Ping()\n\t\t\tif err != nil {\n\t\t\t\tif err != ErrSessionShutdown {\n\t\t\t\t\ts.logger.Printf(\"[ERR] yamux: keepalive failed: %v\", err)\n\t\t\t\t\ts.exitErr(ErrKeepAliveTimeout)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\tcase <-s.shutdownCh:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// waitForSendErr waits to send a header, checking for a potential shutdown\nfunc (s *Session) waitForSend(hdr header, body []byte) error {\n\terrCh := make(chan error, 1)\n\treturn s.waitForSendErr(hdr, body, errCh)\n}\n\n// waitForSendErr waits to send a header with optional data, checking for a\n// potential shutdown. Since there's the expectation that sends can happen\n// in a timely manner, we enforce the connection write timeout here.\nfunc (s *Session) waitForSendErr(hdr header, body []byte, errCh chan error) error {\n\tt := timerPool.Get()\n\ttimer := t.(*time.Timer)\n\ttimer.Reset(s.config.ConnectionWriteTimeout)\n\tdefer func() {\n\t\ttimer.Stop()\n\t\tselect {\n\t\tcase <-timer.C:\n\t\tdefault:\n\t\t}\n\t\ttimerPool.Put(t)\n\t}()\n\n\tready := &sendReady{Hdr: hdr, Body: body, Err: errCh}\n\tselect {\n\tcase s.sendCh <- ready:\n\tcase <-s.shutdownCh:\n\t\treturn ErrSessionShutdown\n\tcase <-timer.C:\n\t\treturn ErrConnectionWriteTimeout\n\t}\n\n\tbodyCopy := func() {\n\t\tif body == nil {\n\t\t\treturn // A nil body is ignored.\n\t\t}\n\n\t\t// In the event of session shutdown or connection write timeout,\n\t\t// we need to prevent `send` from reading the body buffer after\n\t\t// returning from this function since the caller may re-use the\n\t\t// underlying array.\n\t\tready.mu.Lock()\n\t\tdefer ready.mu.Unlock()\n\n\t\tif ready.Body == nil {\n\t\t\treturn // Body was already copied in `send`.\n\t\t}\n\t\tnewBody := make([]byte, len(body))\n\t\tcopy(newBody, body)\n\t\tready.Body = newBody\n\t}\n\n\tselect {\n\tcase err := <-errCh:\n\t\treturn err\n\tcase <-s.shutdownCh:\n\t\tbodyCopy()\n\t\treturn ErrSessionShutdown\n\tcase <-timer.C:\n\t\tbodyCopy()\n\t\treturn ErrConnectionWriteTimeout\n\t}\n}\n\n// sendNoWait does a send without waiting. Since there's the expectation that\n// the send happens right here, we enforce the connection write timeout if we\n// can't queue the header to be sent.\nfunc (s *Session) sendNoWait(hdr header) error {\n\tt := timerPool.Get()\n\ttimer := t.(*time.Timer)\n\ttimer.Reset(s.config.ConnectionWriteTimeout)\n\tdefer func() {\n\t\ttimer.Stop()\n\t\tselect {\n\t\tcase <-timer.C:\n\t\tdefault:\n\t\t}\n\t\ttimerPool.Put(t)\n\t}()\n\n\tselect {\n\tcase s.sendCh <- &sendReady{Hdr: hdr}:\n\t\treturn nil\n\tcase <-s.shutdownCh:\n\t\treturn ErrSessionShutdown\n\tcase <-timer.C:\n\t\treturn ErrConnectionWriteTimeout\n\t}\n}\n\n// send is a long running goroutine that sends data\nfunc (s *Session) send() {\n\tif err := s.sendLoop(); err != nil {\n\t\ts.exitErr(err)\n\t}\n}\n\nfunc (s *Session) sendLoop() error {\n\tdefer close(s.sendDoneCh)\n\tvar bodyBuf bytes.Buffer\n\tfor {\n\t\tbodyBuf.Reset()\n\n\t\tselect {\n\t\tcase ready := <-s.sendCh:\n\t\t\t// Send a header if ready\n\t\t\tif ready.Hdr != nil {\n\t\t\t\t_, err := s.conn.Write(ready.Hdr)\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.logger.Printf(\"[ERR] yamux: Failed to write header: %v\", err)\n\t\t\t\t\tasyncSendErr(ready.Err, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tready.mu.Lock()\n\t\t\tif ready.Body != nil {\n\t\t\t\t// Copy the body into the buffer to avoid\n\t\t\t\t// holding a mutex lock during the write.\n\t\t\t\t_, err := bodyBuf.Write(ready.Body)\n\t\t\t\tif err != nil {\n\t\t\t\t\tready.Body = nil\n\t\t\t\t\tready.mu.Unlock()\n\t\t\t\t\ts.logger.Printf(\"[ERR] yamux: Failed to copy body into buffer: %v\", err)\n\t\t\t\t\tasyncSendErr(ready.Err, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tready.Body = nil\n\t\t\t}\n\t\t\tready.mu.Unlock()\n\n\t\t\tif bodyBuf.Len() > 0 {\n\t\t\t\t// Send data from a body if given\n\t\t\t\t_, err := s.conn.Write(bodyBuf.Bytes())\n\t\t\t\tif err != nil {\n\t\t\t\t\ts.logger.Printf(\"[ERR] yamux: Failed to write body: %v\", err)\n\t\t\t\t\tasyncSendErr(ready.Err, err)\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// No error, successful send\n\t\t\tasyncSendErr(ready.Err, nil)\n\t\tcase <-s.shutdownCh:\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\n// recv is a long running goroutine that accepts new data\nfunc (s *Session) recv() {\n\tif err := s.recvLoop(); err != nil {\n\t\ts.exitErr(err)\n\t}\n}\n\n// Ensure that the index of the handler (typeData/typeWindowUpdate/etc) matches the message type\nvar (\n\thandlers = []func(*Session, header) error{\n\t\ttypeData:         (*Session).handleStreamMessage,\n\t\ttypeWindowUpdate: (*Session).handleStreamMessage,\n\t\ttypePing:         (*Session).handlePing,\n\t\ttypeGoAway:       (*Session).handleGoAway,\n\t}\n)\n\n// recvLoop continues to receive data until a fatal error is encountered\nfunc (s *Session) recvLoop() error {\n\tdefer close(s.recvDoneCh)\n\thdr := header(make([]byte, headerSize))\n\tfor {\n\t\t// Read the header\n\t\tif _, err := io.ReadFull(s.bufRead, hdr); err != nil {\n\t\t\tif err != io.EOF && !strings.Contains(err.Error(), \"closed\") && !strings.Contains(err.Error(), \"reset by peer\") {\n\t\t\t\ts.logger.Printf(\"[ERR] yamux: Failed to read header: %v\", err)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\t// Verify the version\n\t\tif hdr.Version() != protoVersion {\n\t\t\ts.logger.Printf(\"[ERR] yamux: Invalid protocol version: %d\", hdr.Version())\n\t\t\treturn ErrInvalidVersion\n\t\t}\n\n\t\tmt := hdr.MsgType()\n\t\tif mt < typeData || mt > typeGoAway {\n\t\t\treturn ErrInvalidMsgType\n\t\t}\n\n\t\tif err := handlers[mt](s, hdr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n}\n\n// handleStreamMessage handles either a data or window update frame\nfunc (s *Session) handleStreamMessage(hdr header) error {\n\t// Check for a new stream creation\n\tid := hdr.StreamID()\n\tflags := hdr.Flags()\n\tif flags&flagSYN == flagSYN {\n\t\tif err := s.incomingStream(id); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Get the stream\n\ts.streamLock.Lock()\n\tstream := s.streams[id]\n\ts.streamLock.Unlock()\n\n\t// If we do not have a stream, likely we sent a RST\n\tif stream == nil {\n\t\t// Drain any data on the wire\n\t\tif hdr.MsgType() == typeData && hdr.Length() > 0 {\n\t\t\ts.logger.Printf(\"[WARN] yamux: Discarding data for stream: %d\", id)\n\t\t\tif _, err := io.CopyN(ioutil.Discard, s.bufRead, int64(hdr.Length())); err != nil {\n\t\t\t\ts.logger.Printf(\"[ERR] yamux: Failed to discard data: %v\", err)\n\t\t\t\treturn nil\n\t\t\t}\n\t\t} else {\n\t\t\ts.logger.Printf(\"[WARN] yamux: frame for missing stream: %v\", hdr)\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Check if this is a window update\n\tif hdr.MsgType() == typeWindowUpdate {\n\t\tif err := stream.incrSendWindow(hdr, flags); err != nil {\n\t\t\tif sendErr := s.sendNoWait(s.goAway(goAwayProtoErr)); sendErr != nil {\n\t\t\t\ts.logger.Printf(\"[WARN] yamux: failed to send go away: %v\", sendErr)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Read the new data\n\tif err := stream.readData(hdr, flags, s.bufRead); err != nil {\n\t\tif sendErr := s.sendNoWait(s.goAway(goAwayProtoErr)); sendErr != nil {\n\t\t\ts.logger.Printf(\"[WARN] yamux: failed to send go away: %v\", sendErr)\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// handlePing is invokde for a typePing frame\nfunc (s *Session) handlePing(hdr header) error {\n\tflags := hdr.Flags()\n\tpingID := hdr.Length()\n\n\t// Check if this is a query, respond back in a separate context so we\n\t// don't interfere with the receiving thread blocking for the write.\n\tif flags&flagSYN == flagSYN {\n\t\tgo func() {\n\t\t\thdr := header(make([]byte, headerSize))\n\t\t\thdr.encode(typePing, flagACK, 0, pingID)\n\t\t\tif err := s.sendNoWait(hdr); err != nil {\n\t\t\t\ts.logger.Printf(\"[WARN] yamux: failed to send ping reply: %v\", err)\n\t\t\t}\n\t\t}()\n\t\treturn nil\n\t}\n\n\t// Handle a response\n\ts.pingLock.Lock()\n\tch := s.pings[pingID]\n\tif ch != nil {\n\t\tdelete(s.pings, pingID)\n\t\tclose(ch)\n\t}\n\ts.pingLock.Unlock()\n\treturn nil\n}\n\n// handleGoAway is invokde for a typeGoAway frame\nfunc (s *Session) handleGoAway(hdr header) error {\n\tcode := hdr.Length()\n\tswitch code {\n\tcase goAwayNormal:\n\t\tatomic.SwapInt32(&s.remoteGoAway, 1)\n\tcase goAwayProtoErr:\n\t\ts.logger.Printf(\"[ERR] yamux: received protocol error go away\")\n\t\treturn fmt.Errorf(\"yamux protocol error\")\n\tcase goAwayInternalErr:\n\t\ts.logger.Printf(\"[ERR] yamux: received internal error go away\")\n\t\treturn fmt.Errorf(\"remote yamux internal error\")\n\tdefault:\n\t\ts.logger.Printf(\"[ERR] yamux: received unexpected go away\")\n\t\treturn fmt.Errorf(\"unexpected go away received\")\n\t}\n\treturn nil\n}\n\n// incomingStream is used to create a new incoming stream\nfunc (s *Session) incomingStream(id uint32) error {\n\t// Reject immediately if we are doing a go away\n\tif atomic.LoadInt32(&s.localGoAway) == 1 {\n\t\thdr := header(make([]byte, headerSize))\n\t\thdr.encode(typeWindowUpdate, flagRST, id, 0)\n\t\treturn s.sendNoWait(hdr)\n\t}\n\n\t// Allocate a new stream\n\tstream := newStream(s, id, streamSYNReceived)\n\n\ts.streamLock.Lock()\n\tdefer s.streamLock.Unlock()\n\n\t// Check if stream already exists\n\tif _, ok := s.streams[id]; ok {\n\t\ts.logger.Printf(\"[ERR] yamux: duplicate stream declared\")\n\t\tif sendErr := s.sendNoWait(s.goAway(goAwayProtoErr)); sendErr != nil {\n\t\t\ts.logger.Printf(\"[WARN] yamux: failed to send go away: %v\", sendErr)\n\t\t}\n\t\treturn ErrDuplicateStream\n\t}\n\n\t// Register the stream\n\ts.streams[id] = stream\n\n\t// Check if we've exceeded the backlog\n\tselect {\n\tcase s.acceptCh <- stream:\n\t\treturn nil\n\tdefault:\n\t\t// Backlog exceeded! RST the stream\n\t\ts.logger.Printf(\"[WARN] yamux: backlog exceeded, forcing connection reset\")\n\t\tdelete(s.streams, id)\n\t\thdr := header(make([]byte, headerSize))\n\t\thdr.encode(typeWindowUpdate, flagRST, id, 0)\n\t\treturn s.sendNoWait(hdr)\n\t}\n}\n\n// closeStream is used to close a stream once both sides have\n// issued a close. If there was an in-flight SYN and the stream\n// was not yet established, then this will give the credit back.\nfunc (s *Session) closeStream(id uint32) {\n\ts.streamLock.Lock()\n\tif _, ok := s.inflight[id]; ok {\n\t\tselect {\n\t\tcase <-s.synCh:\n\t\tdefault:\n\t\t\ts.logger.Printf(\"[ERR] yamux: SYN tracking out of sync\")\n\t\t}\n\t}\n\tdelete(s.streams, id)\n\ts.streamLock.Unlock()\n}\n\n// establishStream is used to mark a stream that was in the\n// SYN Sent state as established.\nfunc (s *Session) establishStream(id uint32) {\n\ts.streamLock.Lock()\n\tif _, ok := s.inflight[id]; ok {\n\t\tdelete(s.inflight, id)\n\t} else {\n\t\ts.logger.Printf(\"[ERR] yamux: established stream without inflight SYN (no tracking entry)\")\n\t}\n\tselect {\n\tcase <-s.synCh:\n\tdefault:\n\t\ts.logger.Printf(\"[ERR] yamux: established stream without inflight SYN (didn't have semaphore)\")\n\t}\n\ts.streamLock.Unlock()\n}\n"
        },
        {
          "name": "session_test.go",
          "type": "blob",
          "size": 37.380859375,
          "content": "package yamux\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype logCapture struct {\n\tmu  sync.Mutex\n\tbuf *bytes.Buffer\n}\n\nvar _ io.Writer = (*logCapture)(nil)\n\nfunc (l *logCapture) Write(p []byte) (n int, err error) {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\tif l.buf == nil {\n\t\tl.buf = &bytes.Buffer{}\n\t}\n\treturn l.buf.Write(p)\n}\nfunc (l *logCapture) String() string {\n\tl.mu.Lock()\n\tdefer l.mu.Unlock()\n\treturn l.buf.String()\n}\n\nfunc (l *logCapture) logs() []string {\n\treturn strings.Split(strings.TrimSpace(l.String()), \"\\n\")\n}\n\nfunc (l *logCapture) match(expect []string) bool {\n\treturn reflect.DeepEqual(l.logs(), expect)\n}\n\ntype pipeConn struct {\n\treader       *io.PipeReader\n\twriter       *io.PipeWriter\n\twriteBlocker sync.Mutex\n}\n\nfunc (p *pipeConn) Read(b []byte) (int, error) {\n\treturn p.reader.Read(b)\n}\n\nfunc (p *pipeConn) Write(b []byte) (int, error) {\n\tp.writeBlocker.Lock()\n\tdefer p.writeBlocker.Unlock()\n\treturn p.writer.Write(b)\n}\n\nfunc (p *pipeConn) Close() error {\n\tp.reader.Close()\n\treturn p.writer.Close()\n}\n\nfunc testConnPipe(testing.TB) (io.ReadWriteCloser, io.ReadWriteCloser) {\n\tread1, write1 := io.Pipe()\n\tread2, write2 := io.Pipe()\n\tconn1 := &pipeConn{reader: read1, writer: write2}\n\tconn2 := &pipeConn{reader: read2, writer: write1}\n\treturn conn1, conn2\n}\n\nfunc testConnTCP(t testing.TB) (io.ReadWriteCloser, io.ReadWriteCloser) {\n\tl, err := net.ListenTCP(\"tcp\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating listener: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = l.Close() })\n\n\tnetwork := l.Addr().Network()\n\taddr := l.Addr().String()\n\n\tvar server net.Conn\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\tdefer close(errCh)\n\t\tvar err error\n\t\tserver, err = l.Accept()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t}()\n\n\tt.Logf(\"Connecting to %s: %s\", network, addr)\n\tclient, err := net.DialTimeout(network, addr, 10*time.Second)\n\tif err != nil {\n\t\tt.Fatalf(\"error dialing tls listener: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = client.Close() })\n\n\tif err := <-errCh; err != nil {\n\t\tt.Fatalf(\"error creating tls server: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = server.Close() })\n\n\treturn client, server\n}\n\nfunc testConnTLS(t testing.TB) (io.ReadWriteCloser, io.ReadWriteCloser) {\n\tcert, err := tls.LoadX509KeyPair(\"testdata/cert.pem\", \"testdata/key.pem\")\n\tif err != nil {\n\t\tt.Fatalf(\"error loading certificate: %v\", err)\n\t}\n\n\tl, err := net.ListenTCP(\"tcp\", nil)\n\tif err != nil {\n\t\tt.Fatalf(\"error creating listener: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = l.Close() })\n\n\tvar server net.Conn\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\tdefer close(errCh)\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\tserver = tls.Server(conn, &tls.Config{\n\t\t\tCertificates: []tls.Certificate{cert},\n\t\t})\n\t}()\n\n\tt.Logf(\"Connecting to %s: %s\", l.Addr().Network(), l.Addr())\n\tclient, err := net.DialTimeout(l.Addr().Network(), l.Addr().String(), 10*time.Second)\n\tif err != nil {\n\t\tt.Fatalf(\"error dialing tls listener: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = client.Close() })\n\n\ttlsClient := tls.Client(client, &tls.Config{\n\t\t// InsecureSkipVerify is safe to use here since this is only for tests.\n\t\tInsecureSkipVerify: true,\n\t})\n\n\tif err := <-errCh; err != nil {\n\t\tt.Fatalf(\"error creating tls server: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = server.Close() })\n\n\treturn tlsClient, server\n}\n\n// connTypeFunc is func that returns a client and server connection for testing\n// like testConnTLS.\n//\n// See connTypeTest\ntype connTypeFunc func(t testing.TB) (io.ReadWriteCloser, io.ReadWriteCloser)\n\n// connTypeTest is a test case for a specific conn type.\n//\n// See testConnType\ntype connTypeTest struct {\n\tName  string\n\tConns connTypeFunc\n}\n\n// testConnType runs subtests of the given testFunc against multiple connection\n// types.\nfunc testConnTypes(t *testing.T, testFunc func(t testing.TB, client, server io.ReadWriteCloser)) {\n\treverse := func(f connTypeFunc) connTypeFunc {\n\t\treturn func(t testing.TB) (io.ReadWriteCloser, io.ReadWriteCloser) {\n\t\t\tc, s := f(t)\n\t\t\treturn s, c\n\t\t}\n\t}\n\tcases := []connTypeTest{\n\t\t{\n\t\t\tName:  \"Pipes\",\n\t\t\tConns: testConnPipe,\n\t\t},\n\t\t{\n\t\t\tName:  \"TCP\",\n\t\t\tConns: testConnTCP,\n\t\t},\n\t\t{\n\t\t\tName:  \"TCP_Reverse\",\n\t\t\tConns: reverse(testConnTCP),\n\t\t},\n\t\t{\n\t\t\tName:  \"TLS\",\n\t\t\tConns: testConnTLS,\n\t\t},\n\t\t{\n\t\t\tName:  \"TLS_Reverse\",\n\t\t\tConns: reverse(testConnTLS),\n\t\t},\n\t}\n\tfor i := range cases {\n\t\ttc := cases[i]\n\t\tt.Run(tc.Name, func(t *testing.T) {\n\t\t\tclient, server := tc.Conns(t)\n\t\t\ttestFunc(t, client, server)\n\t\t})\n\t}\n}\n\nfunc testConf() *Config {\n\tconf := DefaultConfig()\n\tconf.AcceptBacklog = 64\n\tconf.KeepAliveInterval = 100 * time.Millisecond\n\tconf.ConnectionWriteTimeout = 250 * time.Millisecond\n\treturn conf\n}\n\nfunc captureLogs(conf *Config) *logCapture {\n\tbuf := new(logCapture)\n\tconf.Logger = log.New(buf, \"\", 0)\n\tconf.LogOutput = nil\n\treturn buf\n}\n\nfunc testConfNoKeepAlive() *Config {\n\tconf := testConf()\n\tconf.EnableKeepAlive = false\n\treturn conf\n}\n\nfunc testClientServer(t testing.TB) (*Session, *Session) {\n\tclient, server := testConnTLS(t)\n\treturn testClientServerConfig(t, client, server, testConf(), testConf())\n}\n\nfunc testClientServerConfig(\n\tt testing.TB,\n\tclientConn, serverConn io.ReadWriteCloser,\n\tclientConf, serverConf *Config,\n) (clientSession *Session, serverSession *Session) {\n\n\tvar err error\n\n\tclientSession, err = Client(clientConn, clientConf)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = clientSession.Close() })\n\n\tserverSession, err = Server(serverConn, serverConf)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tt.Cleanup(func() { _ = serverSession.Close() })\n\treturn clientSession, serverSession\n}\n\nfunc TestPing(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\trtt, err := client.Ping()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif rtt == 0 {\n\t\tt.Fatalf(\"bad: %v\", rtt)\n\t}\n\n\trtt, err = server.Ping()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif rtt == 0 {\n\t\tt.Fatalf(\"bad: %v\", rtt)\n\t}\n}\n\nfunc TestPing_Timeout(t *testing.T) {\n\tconf := testConfNoKeepAlive()\n\tclientPipe, serverPipe := testConnPipe(t)\n\tclient, server := testClientServerConfig(t, clientPipe, serverPipe, conf.Clone(), conf.Clone())\n\n\t// Prevent the client from responding\n\tclientConn := client.conn.(*pipeConn)\n\tclientConn.writeBlocker.Lock()\n\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\t_, err := server.Ping() // Ping via the server session\n\t\terrCh <- err\n\t}()\n\n\tselect {\n\tcase err := <-errCh:\n\t\tif err != ErrTimeout {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\tcase <-time.After(client.config.ConnectionWriteTimeout * 2):\n\t\tt.Fatalf(\"failed to timeout within expected %v\", client.config.ConnectionWriteTimeout)\n\t}\n\n\t// Verify that we recover, even if we gave up\n\tclientConn.writeBlocker.Unlock()\n\n\tgo func() {\n\t\t_, err := server.Ping() // Ping via the server session\n\t\terrCh <- err\n\t}()\n\n\tselect {\n\tcase err := <-errCh:\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\tcase <-time.After(client.config.ConnectionWriteTimeout):\n\t\tt.Fatalf(\"timeout\")\n\t}\n}\n\nfunc TestCloseBeforeAck(t *testing.T) {\n\ttestConnTypes(t, func(t testing.TB, clientConn, serverConn io.ReadWriteCloser) {\n\t\tcfg := testConf()\n\t\tcfg.AcceptBacklog = 8\n\t\tclient, server := testClientServerConfig(t, clientConn, serverConn, cfg, cfg.Clone())\n\n\t\tfor i := 0; i < 8; i++ {\n\t\t\ts, err := client.OpenStream()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\ts.Close()\n\t\t}\n\n\t\tfor i := 0; i < 8; i++ {\n\t\t\ts, err := server.AcceptStream()\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\ts.Close()\n\t\t}\n\n\t\terrCh := make(chan error, 1)\n\t\tgo func() {\n\t\t\ts, err := client.OpenStream()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\ts.Close()\n\t\t\terrCh <- nil\n\t\t}()\n\n\t\tdrainErrorsUntil(t, errCh, 1, time.Second*5, \"timed out trying to open stream\")\n\t})\n}\n\nfunc TestAccept(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tif client.NumStreams() != 0 {\n\t\tt.Fatalf(\"bad\")\n\t}\n\tif server.NumStreams() != 0 {\n\t\tt.Fatalf(\"bad\")\n\t}\n\n\terrCh := make(chan error, 4)\n\tacceptOne := func(streamFunc func() (*Stream, error), expectID uint32) {\n\t\tstream, err := streamFunc()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tif id := stream.StreamID(); id != expectID {\n\t\t\terrCh <- fmt.Errorf(\"bad: %v\", id)\n\t\t\treturn\n\t\t}\n\t\tif err := stream.Close(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\terrCh <- nil\n\t}\n\n\tgo acceptOne(server.AcceptStream, 1)\n\tgo acceptOne(client.AcceptStream, 2)\n\tgo acceptOne(server.OpenStream, 2)\n\tgo acceptOne(client.OpenStream, 1)\n\n\tdrainErrorsUntil(t, errCh, 4, time.Second, \"timeout\")\n}\n\nfunc TestOpenStreamTimeout(t *testing.T) {\n\tconst timeout = 25 * time.Millisecond\n\n\ttestConnTypes(t, func(t testing.TB, clientConn, serverConn io.ReadWriteCloser) {\n\t\tserverConf := testConf()\n\t\tserverConf.StreamOpenTimeout = timeout\n\n\t\tclientConf := serverConf.Clone()\n\t\tclientLogs := captureLogs(clientConf)\n\n\t\tclient, _ := testClientServerConfig(t, clientConn, serverConn, clientConf, serverConf)\n\n\t\t// Open a single stream without a server to acknowledge it.\n\t\ts, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Sleep for longer than the stream open timeout.\n\t\t// Since no ACKs are received, the stream and session should be closed.\n\t\ttime.Sleep(timeout * 5)\n\n\t\t// Support multiple underlying connection types\n\t\tvar dest string\n\t\tswitch conn := clientConn.(type) {\n\t\tcase net.Conn:\n\t\t\tdest = conn.RemoteAddr().String()\n\t\tcase *pipeConn:\n\t\t\tdest = \"yamux:remote\"\n\t\tdefault:\n\t\t\tt.Fatalf(\"unsupported connection type %T - please update test\", conn)\n\t\t}\n\t\texp := fmt.Sprintf(\"[ERR] yamux: aborted stream open (destination=%s): i/o deadline reached\", dest)\n\n\t\tif !clientLogs.match([]string{exp}) {\n\t\t\tt.Fatalf(\"server log incorect: %v\\nexpected: %v\", clientLogs.logs(), exp)\n\t\t}\n\n\t\ts.stateLock.Lock()\n\t\tstate := s.state\n\t\ts.stateLock.Unlock()\n\n\t\tif state != streamClosed {\n\t\t\tt.Fatalf(\"stream should have been closed\")\n\t\t}\n\t\tif !client.IsClosed() {\n\t\t\tt.Fatalf(\"session should have been closed\")\n\t\t}\n\t})\n}\n\nfunc TestClose_closeTimeout(t *testing.T) {\n\tconf := testConf()\n\tconf.StreamCloseTimeout = 10 * time.Millisecond\n\tclientConn, serverConn := testConnTLS(t)\n\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\tif client.NumStreams() != 0 {\n\t\tt.Fatalf(\"bad\")\n\t}\n\tif server.NumStreams() != 0 {\n\t\tt.Fatalf(\"bad\")\n\t}\n\n\terrCh := make(chan error, 2)\n\n\t// Open a stream on the client but only close it on the server.\n\t// We want to see if the stream ever gets cleaned up on the client.\n\n\tvar clientStream *Stream\n\tgo func() {\n\t\tvar err error\n\t\tclientStream, err = client.OpenStream()\n\t\terrCh <- err\n\t}()\n\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tif err := stream.Close(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, time.Second, \"timeout\")\n\n\t// We should have zero streams after our timeout period\n\ttime.Sleep(100 * time.Millisecond)\n\n\tif v := server.NumStreams(); v > 0 {\n\t\tt.Fatalf(\"should have zero streams: %d\", v)\n\t}\n\tif v := client.NumStreams(); v > 0 {\n\t\tt.Fatalf(\"should have zero streams: %d\", v)\n\t}\n\n\tif _, err := clientStream.Write([]byte(\"hello\")); err == nil {\n\t\tt.Fatal(\"should error on write\")\n\t} else if err.Error() != \"connection reset\" {\n\t\tt.Fatalf(\"expected connection reset, got %q\", err)\n\t}\n}\n\nfunc TestNonNilInterface(t *testing.T) {\n\t_, server := testClientServer(t)\n\tserver.Close()\n\n\tconn, err := server.Accept()\n\tif err == nil || !errors.Is(err, ErrSessionShutdown) || conn != nil {\n\t\tt.Fatal(\"bad: accept should return a shutdown error and a connection of nil value\")\n\t}\n\tif err != nil && conn != nil {\n\t\tt.Error(\"bad: accept should return a connection of nil value\")\n\t}\n\n\tconn, err = server.Open()\n\tif err == nil || !errors.Is(err, ErrSessionShutdown) || conn != nil {\n\t\tt.Fatal(\"bad: open should return a shutdown error and a connection of nil value\")\n\t}\n}\n\nfunc TestSendData_Small(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\terrCh := make(chan error, 2)\n\n\t// Accept an incoming client and perform some reads before closing\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\tif server.NumStreams() != 1 {\n\t\t\terrCh <- fmt.Errorf(\"bad\")\n\t\t\treturn\n\t\t}\n\n\t\tbuf := make([]byte, 4)\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tn, err := stream.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != 4 {\n\t\t\t\terrCh <- fmt.Errorf(\"short read: %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif string(buf) != \"test\" {\n\t\t\t\terrCh <- fmt.Errorf(\"bad: %s\", buf)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif err := stream.Close(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\t// Open a client and perform some writes before closing\n\tgo func() {\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\tif client.NumStreams() != 1 {\n\t\t\terrCh <- fmt.Errorf(\"bad\")\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tn, err := stream.Write([]byte(\"test\"))\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != 4 {\n\t\t\t\terrCh <- fmt.Errorf(\"short write %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tif err := stream.Close(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, 5*time.Second, \"timeout\")\n\n\t// Give client and server a second to receive FINs and close streams\n\ttime.Sleep(time.Second)\n\n\tif n := client.NumStreams(); n != 0 {\n\t\tt.Errorf(\"expected 0 client streams but found %d\", n)\n\t}\n\tif n := server.NumStreams(); n != 0 {\n\t\tt.Errorf(\"expected 0 server streams but found %d\", n)\n\t}\n}\n\nfunc TestSendData_Large(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping slow test that may time out on the race detector\")\n\t}\n\tclient, server := testClientServer(t)\n\n\tconst (\n\t\tsendSize = 250 * 1024 * 1024\n\t\trecvSize = 4 * 1024\n\t)\n\n\tdata := make([]byte, sendSize)\n\tfor idx := range data {\n\t\tdata[idx] = byte(idx % 256)\n\t}\n\n\terrCh := make(chan error, 2)\n\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tvar sz int\n\t\tbuf := make([]byte, recvSize)\n\t\tfor i := 0; i < sendSize/recvSize; i++ {\n\t\t\tn, err := stream.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != recvSize {\n\t\t\t\terrCh <- fmt.Errorf(\"short read: %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tsz += n\n\t\t\tfor idx := range buf {\n\t\t\t\tif buf[idx] != byte(idx%256) {\n\t\t\t\t\terrCh <- fmt.Errorf(\"bad: %v %v %v\", i, idx, buf[idx])\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif err := stream.Close(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\tt.Logf(\"cap=%d, n=%d\\n\", stream.recvBuf.Cap(), sz)\n\t\terrCh <- nil\n\t}()\n\n\tgo func() {\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\tn, err := stream.Write(data)\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tif n != len(data) {\n\t\t\terrCh <- fmt.Errorf(\"short write %d\", n)\n\t\t\treturn\n\t\t}\n\n\t\tif err := stream.Close(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, 10*time.Second, \"timeout\")\n}\n\nfunc TestGoAway(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tif err := server.GoAway(); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\t// Give the other side time to process the goaway after receiving it.\n\ttime.Sleep(100 * time.Millisecond)\n\n\t_, err := client.Open()\n\tif err != ErrRemoteGoAway {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n}\n\nfunc TestManyStreams(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tconst streams = 50\n\n\terrCh := make(chan error, 2*streams)\n\n\tacceptor := func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tbuf := make([]byte, 512)\n\t\tfor {\n\t\t\tn, err := stream.Read(buf)\n\t\t\tif err == io.EOF {\n\t\t\t\terrCh <- nil\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n == 0 {\n\t\t\t\terrCh <- fmt.Errorf(\"no bytes read\")\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tsender := func(id int) {\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tmsg := fmt.Sprintf(\"%08d\", id)\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\tn, err := stream.Write([]byte(msg))\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != len(msg) {\n\t\t\t\terrCh <- fmt.Errorf(\"short write %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\terrCh <- nil\n\t}\n\n\tfor i := 0; i < streams; i++ {\n\t\tgo acceptor()\n\t\tgo sender(i)\n\t}\n\n\tdrainErrorsUntil(t, errCh, 2*streams, 0, \"\")\n}\n\nfunc TestManyStreams_PingPong(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tconst streams = 50\n\n\terrCh := make(chan error, 2*streams)\n\n\tping := []byte(\"ping\")\n\tpong := []byte(\"pong\")\n\n\tacceptor := func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tbuf := make([]byte, 4)\n\t\tfor {\n\t\t\t// Read the 'ping'\n\t\t\tn, err := stream.Read(buf)\n\t\t\tif err == io.EOF {\n\t\t\t\terrCh <- nil\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != 4 {\n\t\t\t\terrCh <- fmt.Errorf(\"short read %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !bytes.Equal(buf, ping) {\n\t\t\t\terrCh <- fmt.Errorf(\"bad: %s\", buf)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Shrink the internal buffer!\n\t\t\tstream.Shrink()\n\n\t\t\t// Write out the 'pong'\n\t\t\tn, err = stream.Write(pong)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != 4 {\n\t\t\t\terrCh <- fmt.Errorf(\"short write %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tsender := func() {\n\t\tstream, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tbuf := make([]byte, 4)\n\t\tfor i := 0; i < 1000; i++ {\n\t\t\t// Send the 'ping'\n\t\t\tn, err := stream.Write(ping)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != 4 {\n\t\t\t\terrCh <- fmt.Errorf(\"short write %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Read the 'pong'\n\t\t\tn, err = stream.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif n != 4 {\n\t\t\t\terrCh <- fmt.Errorf(\"short read %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !bytes.Equal(buf, pong) {\n\t\t\t\terrCh <- fmt.Errorf(\"bad: %s\", buf)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\t// Shrink the buffer\n\t\t\tstream.Shrink()\n\t\t}\n\t\terrCh <- nil\n\t}\n\n\tfor i := 0; i < streams; i++ {\n\t\tgo acceptor()\n\t\tgo sender()\n\t}\n\n\tdrainErrorsUntil(t, errCh, 2*streams, 0, \"\")\n}\n\n// TestHalfClose asserts that half closed streams can still read.\nfunc TestHalfClose(t *testing.T) {\n\ttestConnTypes(t, func(t testing.TB, clientConn, serverConn io.ReadWriteCloser) {\n\t\tclient, server := testClientServerConfig(t, clientConn, serverConn, testConf(), testConf())\n\n\t\tclientStream, err := client.Open()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tif _, err = clientStream.Write([]byte(\"a\")); err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\n\t\tserverStream, err := server.Accept()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tserverStream.Close() // Half close\n\n\t\t// Server reads 1 byte written by Client\n\t\tbuf := make([]byte, 4)\n\t\tn, err := serverStream.Read(buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tif n != 1 {\n\t\t\tt.Fatalf(\"bad: %v\", n)\n\t\t}\n\n\t\t// Send more\n\t\tif _, err = clientStream.Write([]byte(\"bcd\")); err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tclientStream.Close()\n\n\t\t// Read after close always returns the bytes written but may or may not\n\t\t// receive the EOF.\n\t\tn, err = serverStream.Read(buf)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tif n != 3 {\n\t\t\tt.Fatalf(\"bad: %v\", n)\n\t\t}\n\n\t\t// EOF after close\n\t\tn, err = serverStream.Read(buf)\n\t\tif err != io.EOF {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tif n != 0 {\n\t\t\tt.Fatalf(\"bad: %v\", n)\n\t\t}\n\t})\n}\n\nfunc TestHalfCloseSessionShutdown(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\t// dataSize must be large enough to ensure the server will send a window\n\t// update\n\tdataSize := int64(server.config.MaxStreamWindowSize)\n\n\tdata := make([]byte, dataSize)\n\tfor idx := range data {\n\t\tdata[idx] = byte(idx % 256)\n\t}\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif _, err = stream.Write(data); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tstream2, err := server.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tif err := stream.Close(); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\t// Shut down the session of the sending side. This should not cause reads\n\t// to fail on the receiving side.\n\tif err := client.Close(); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tbuf := make([]byte, dataSize)\n\tn, err := stream2.Read(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif int64(n) != dataSize {\n\t\tt.Fatalf(\"bad: %v\", n)\n\t}\n\n\t// EOF after close\n\tn, err = stream2.Read(buf)\n\tif err != io.EOF {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif n != 0 {\n\t\tt.Fatalf(\"bad: %v\", n)\n\t}\n}\n\nfunc TestReadDeadline(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream.Close()\n\n\tstream2, err := server.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream2.Close()\n\n\tif err := stream.SetReadDeadline(time.Now().Add(5 * time.Millisecond)); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tbuf := make([]byte, 4)\n\t_, err = stream.Read(buf)\n\tif err != ErrTimeout {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\t// See https://github.com/hashicorp/yamux/issues/90\n\t// The standard library's http server package will read from connections in\n\t// the background to detect if they are alive.\n\t//\n\t// It sets a read deadline on connections and detect if the returned error\n\t// is a network timeout error which implements net.Error.\n\t//\n\t// The HTTP server will cancel all server requests if it isn't timeout error\n\t// from the connection.\n\t//\n\t// We assert that we return an error meeting the interface to avoid\n\t// accidently breaking yamux session compatability with the standard\n\t// library's http server implementation.\n\tif netErr, ok := err.(net.Error); !ok || !netErr.Timeout() {\n\t\tt.Fatalf(\"reading timeout error is expected to implement net.Error and return true when calling Timeout()\")\n\t}\n}\n\nfunc TestReadDeadline_BlockedRead(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream.Close()\n\n\tstream2, err := server.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream2.Close()\n\n\t// Start a read that will block\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 4)\n\t\t_, err := stream.Read(buf)\n\t\terrCh <- err\n\t\tclose(errCh)\n\t}()\n\n\t// Wait to ensure the read has started.\n\ttime.Sleep(5 * time.Millisecond)\n\n\t// Update the read deadline\n\tif err := stream.SetReadDeadline(time.Now().Add(5 * time.Millisecond)); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tselect {\n\tcase <-time.After(100 * time.Millisecond):\n\t\tt.Fatal(\"expected read timeout\")\n\tcase err := <-errCh:\n\t\tif err != ErrTimeout {\n\t\t\tt.Fatalf(\"expected ErrTimeout; got %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestWriteDeadline(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream.Close()\n\n\tstream2, err := server.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream2.Close()\n\n\tif err := stream.SetWriteDeadline(time.Now().Add(50 * time.Millisecond)); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tbuf := make([]byte, 512)\n\tfor i := 0; i < int(initialStreamWindow); i++ {\n\t\t_, err := stream.Write(buf)\n\t\tif err != nil && err == ErrTimeout {\n\t\t\treturn\n\t\t} else if err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t}\n\tt.Fatalf(\"Expected timeout\")\n}\n\nfunc TestWriteDeadline_BlockedWrite(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream.Close()\n\n\tstream2, err := server.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream2.Close()\n\n\t// Start a goroutine making writes that will block\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\tbuf := make([]byte, 512)\n\t\tfor i := 0; i < int(initialStreamWindow); i++ {\n\t\t\t_, err := stream.Write(buf)\n\t\t\tif err == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\terrCh <- err\n\t\t\tclose(errCh)\n\t\t\treturn\n\t\t}\n\n\t\tclose(errCh)\n\t}()\n\n\t// Wait to ensure the write has started.\n\ttime.Sleep(5 * time.Millisecond)\n\n\t// Update the write deadline\n\tif err := stream.SetWriteDeadline(time.Now().Add(5 * time.Millisecond)); err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\n\tselect {\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatal(\"expected write timeout\")\n\tcase err := <-errCh:\n\t\tif err != ErrTimeout {\n\t\t\tt.Fatalf(\"expected ErrTimeout; got %v\", err)\n\t\t}\n\t}\n}\n\nfunc TestBacklogExceeded(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\t// Fill the backlog\n\tmax := client.config.AcceptBacklog\n\tfor i := 0; i < max; i++ {\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tif _, err := stream.Write([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t}\n\n\t// Attempt to open a new stream\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\t_, err := client.Open()\n\t\terrCh <- err\n\t}()\n\n\t// Shutdown the server\n\tgo func() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tserver.Close()\n\t}()\n\n\tselect {\n\tcase err := <-errCh:\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"open should fail\")\n\t\t}\n\tcase <-time.After(time.Second):\n\t\tt.Fatalf(\"timeout\")\n\t}\n}\n\nfunc TestKeepAlive(t *testing.T) {\n\ttestConnTypes(t, func(t testing.TB, clientConn, serverConn io.ReadWriteCloser) {\n\t\tclient, server := testClientServerConfig(t, clientConn, serverConn, testConf(), testConf())\n\n\t\t// Give keepalives time to happen\n\t\ttime.Sleep(200 * time.Millisecond)\n\n\t\t// Ping value should increase\n\t\tclient.pingLock.Lock()\n\t\tdefer client.pingLock.Unlock()\n\t\tif client.pingID == 0 {\n\t\t\tt.Fatalf(\"should ping\")\n\t\t}\n\n\t\tserver.pingLock.Lock()\n\t\tdefer server.pingLock.Unlock()\n\t\tif server.pingID == 0 {\n\t\t\tt.Fatalf(\"should ping\")\n\t\t}\n\t})\n}\n\nfunc TestKeepAlive_Timeout(t *testing.T) {\n\tconn1, conn2 := testConnPipe(t)\n\n\tclientConf := testConf()\n\tclientConf.ConnectionWriteTimeout = time.Hour // We're testing keep alives, not connection writes\n\tclientConf.EnableKeepAlive = false            // Just test one direction, so it's deterministic who hangs up on whom\n\t_ = captureLogs(clientConf)                   // Client logs aren't part of the test\n\tclient, err := Client(conn1, clientConf)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer client.Close()\n\n\tserverConf := testConf()\n\tserverLogs := captureLogs(serverConf)\n\tserver, err := Server(conn2, serverConf)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer server.Close()\n\n\terrCh := make(chan error, 1)\n\tgo func() {\n\t\t_, err := server.Accept() // Wait until server closes\n\t\terrCh <- err\n\t}()\n\n\t// Prevent the client from responding\n\tclientConn := client.conn.(*pipeConn)\n\tclientConn.writeBlocker.Lock()\n\n\tselect {\n\tcase err := <-errCh:\n\t\tif err != ErrKeepAliveTimeout {\n\t\t\tt.Fatalf(\"unexpected error: %v\", err)\n\t\t}\n\tcase <-time.After(1 * time.Second):\n\t\tt.Fatalf(\"timeout waiting for timeout\")\n\t}\n\n\tclientConn.writeBlocker.Unlock()\n\n\tif !server.IsClosed() {\n\t\tt.Fatalf(\"server should have closed\")\n\t}\n\n\tif !serverLogs.match([]string{\"[ERR] yamux: keepalive failed: i/o deadline reached\"}) {\n\t\tt.Fatalf(\"server log incorect: %v\", serverLogs.logs())\n\t}\n}\n\nfunc TestLargeWindow(t *testing.T) {\n\tconf := DefaultConfig()\n\tconf.MaxStreamWindowSize *= 2\n\n\tclientConn, serverConn := testConnTLS(t)\n\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\tstream, err := client.Open()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream.Close()\n\n\tstream2, err := server.Accept()\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tdefer stream2.Close()\n\n\terr = stream.SetWriteDeadline(time.Now().Add(10 * time.Millisecond))\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tbuf := make([]byte, conf.MaxStreamWindowSize)\n\tn, err := stream.Write(buf)\n\tif err != nil {\n\t\tt.Fatalf(\"err: %v\", err)\n\t}\n\tif n != len(buf) {\n\t\tt.Fatalf(\"short write: %d\", n)\n\t}\n}\n\ntype UnlimitedReader struct{}\n\nfunc (u *UnlimitedReader) Read(p []byte) (int, error) {\n\truntime.Gosched()\n\treturn len(p), nil\n}\n\nfunc TestSendData_VeryLarge(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping slow test that may time out on the race detector\")\n\t}\n\tclient, server := testClientServer(t)\n\n\tvar n int64 = 1 * 1024 * 1024 * 1024\n\tvar workers int = 16\n\n\terrCh := make(chan error, workers*2)\n\n\tfor i := 0; i < workers; i++ {\n\t\tgo func() {\n\t\t\tstream, err := server.AcceptStream()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer stream.Close()\n\n\t\t\tbuf := make([]byte, 4)\n\t\t\t_, err = stream.Read(buf)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif !bytes.Equal(buf, []byte{0, 1, 2, 3}) {\n\t\t\t\terrCh <- errors.New(\"bad header\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trecv, err := io.Copy(io.Discard, stream)\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif recv != n {\n\t\t\t\terrCh <- fmt.Errorf(\"bad: %v\", recv)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrCh <- nil\n\t\t}()\n\t}\n\tfor i := 0; i < workers; i++ {\n\t\tgo func() {\n\t\t\tstream, err := client.Open()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer stream.Close()\n\n\t\t\t_, err = stream.Write([]byte{0, 1, 2, 3})\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tunlimited := &UnlimitedReader{}\n\t\t\tsent, err := io.Copy(stream, io.LimitReader(unlimited, n))\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif sent != n {\n\t\t\t\terrCh <- fmt.Errorf(\"bad: %v\", sent)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terrCh <- nil\n\t\t}()\n\t}\n\n\tdrainErrorsUntil(t, errCh, workers*2, 120*time.Second, \"timeout\")\n}\n\nfunc TestBacklogExceeded_Accept(t *testing.T) {\n\tclient, server := testClientServer(t)\n\n\tmax := 5 * client.config.AcceptBacklog\n\n\terrCh := make(chan error, max)\n\tgo func() {\n\t\tfor i := 0; i < max; i++ {\n\t\t\tstream, err := server.Accept()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer stream.Close()\n\t\t\terrCh <- nil\n\t\t}\n\t}()\n\n\t// Fill the backlog\n\tfor i := 0; i < max; i++ {\n\t\tstream, err := client.Open()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tif _, err := stream.Write([]byte(\"foo\")); err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t}\n\n\tdrainErrorsUntil(t, errCh, max, 0, \"\")\n}\n\nfunc TestSession_WindowUpdateWriteDuringRead(t *testing.T) {\n\tconf := testConfNoKeepAlive()\n\n\tclientConn, serverConn := testConnPipe(t)\n\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\t// Choose a huge flood size that we know will result in a window update.\n\tflood := int64(client.config.MaxStreamWindowSize) - 1\n\n\terrCh := make(chan error, 2)\n\n\t// The server will accept a new stream and then flood data to it.\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tn, err := stream.Write(make([]byte, flood))\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tif int64(n) != flood {\n\t\t\terrCh <- fmt.Errorf(\"short write: %d\", n)\n\t\t}\n\n\t\terrCh <- nil\n\t}()\n\n\t// The client will open a stream, block outbound writes, and then\n\t// listen to the flood from the server, which should time out since\n\t// it won't be able to send the window update.\n\tgo func() {\n\t\tstream, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tconn := clientConn.(*pipeConn)\n\t\tconn.writeBlocker.Lock()\n\t\tdefer conn.writeBlocker.Unlock()\n\n\t\t_, err = stream.Read(make([]byte, flood))\n\t\tif err != ErrConnectionWriteTimeout {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, 0, \"\")\n}\n\n// TestSession_PartialReadWindowUpdate asserts that when a client performs a\n// partial read it updates the server's send window.\nfunc TestSession_PartialReadWindowUpdate(t *testing.T) {\n\ttestConnTypes(t, func(t testing.TB, clientConn, serverConn io.ReadWriteCloser) {\n\t\tconf := testConfNoKeepAlive()\n\n\t\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\t\terrCh := make(chan error, 1)\n\n\t\t// Choose a huge flood size that we know will result in a window update.\n\t\tflood := int64(client.config.MaxStreamWindowSize)\n\t\tvar wr *Stream\n\n\t\t// The server will accept a new stream and then flood data to it.\n\t\tgo func() {\n\t\t\tvar err error\n\t\t\twr, err = server.AcceptStream()\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer wr.Close()\n\n\t\t\twindow := atomic.LoadUint32(&wr.sendWindow)\n\t\t\tif window != client.config.MaxStreamWindowSize {\n\t\t\t\terrCh <- fmt.Errorf(\"sendWindow: exp=%d, got=%d\", client.config.MaxStreamWindowSize, window)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tn, err := wr.Write(make([]byte, flood))\n\t\t\tif err != nil {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif int64(n) != flood {\n\t\t\t\terrCh <- fmt.Errorf(\"short write: %d\", n)\n\t\t\t\treturn\n\t\t\t}\n\t\t\twindow = atomic.LoadUint32(&wr.sendWindow)\n\t\t\tif window != 0 {\n\t\t\t\terrCh <- fmt.Errorf(\"sendWindow: exp=%d, got=%d\", 0, window)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terrCh <- err\n\t\t}()\n\n\t\tstream, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tdrainErrorsUntil(t, errCh, 1, 0, \"\")\n\n\t\t// Only read part of the flood\n\t\tpartialReadSize := flood/2 + 1\n\t\t_, err = stream.Read(make([]byte, partialReadSize))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t}\n\n\t\t// Wait for window update to be applied by server. Should be \"instant\" but CI\n\t\t// can be slow.\n\t\ttime.Sleep(2 * time.Second)\n\n\t\t// Assert server received window update\n\t\twindow := atomic.LoadUint32(&wr.sendWindow)\n\t\tif exp := uint32(partialReadSize); window != exp {\n\t\t\tt.Fatalf(\"sendWindow: exp=%d, got=%d\", exp, window)\n\t\t}\n\t})\n}\n\nfunc TestSession_sendNoWait_Timeout(t *testing.T) {\n\tconf := testConfNoKeepAlive()\n\n\tclientConn, serverConn := testConnPipe(t)\n\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\terrCh := make(chan error, 2)\n\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\t\terrCh <- nil\n\t}()\n\n\t// The client will open the stream and then block outbound writes, we'll\n\t// probe sendNoWait once it gets into that state.\n\tgo func() {\n\t\tstream, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tconn := clientConn.(*pipeConn)\n\t\tconn.writeBlocker.Lock()\n\t\tdefer conn.writeBlocker.Unlock()\n\n\t\thdr := header(make([]byte, headerSize))\n\t\thdr.encode(typePing, flagACK, 0, 0)\n\t\tfor {\n\t\t\terr = client.sendNoWait(hdr)\n\t\t\tif err == nil {\n\t\t\t\tcontinue\n\t\t\t} else if err == ErrConnectionWriteTimeout {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, 0, \"\")\n}\n\nfunc TestSession_PingOfDeath(t *testing.T) {\n\tconf := testConfNoKeepAlive()\n\n\tclientConn, serverConn := testConnPipe(t)\n\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\terrCh := make(chan error, 2)\n\n\tvar doPingOfDeath sync.Mutex\n\tdoPingOfDeath.Lock()\n\n\t// This is used later to block outbound writes.\n\tconn := server.conn.(*pipeConn)\n\n\t// The server will accept a stream, block outbound writes, and then\n\t// flood its send channel so that no more headers can be queued.\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tconn.writeBlocker.Lock()\n\t\tfor {\n\t\t\thdr := header(make([]byte, headerSize))\n\t\t\thdr.encode(typePing, 0, 0, 0)\n\t\t\terr = server.sendNoWait(hdr)\n\t\t\tif err == nil {\n\t\t\t\tcontinue\n\t\t\t} else if err == ErrConnectionWriteTimeout {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\terrCh <- err\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\tdoPingOfDeath.Unlock()\n\t\terrCh <- nil\n\t}()\n\n\t// The client will open a stream and then send the server a ping once it\n\t// can no longer write. This makes sure the server doesn't deadlock reads\n\t// while trying to reply to the ping with no ability to write.\n\tgo func() {\n\t\tstream, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\t// This ping will never unblock because the ping id will never\n\t\t// show up in a response.\n\t\tdoPingOfDeath.Lock()\n\t\tgo func() { _, _ = client.Ping() }()\n\n\t\t// Wait for a while to make sure the previous ping times out,\n\t\t// then turn writes back on and make sure a ping works again.\n\t\ttime.Sleep(2 * server.config.ConnectionWriteTimeout)\n\t\tconn.writeBlocker.Unlock()\n\t\tif _, err = client.Ping(); err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, 0, \"\")\n}\n\nfunc TestSession_ConnectionWriteTimeout(t *testing.T) {\n\tconf := testConfNoKeepAlive()\n\n\tclientConn, serverConn := testConnPipe(t)\n\tclient, server := testClientServerConfig(t, clientConn, serverConn, conf, conf.Clone())\n\n\terrCh := make(chan error, 2)\n\n\tgo func() {\n\t\tstream, err := server.AcceptStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\t\terrCh <- nil\n\t}()\n\n\t// The client will open the stream and then block outbound writes, we'll\n\t// tee up a write and make sure it eventually times out.\n\tgo func() {\n\t\tstream, err := client.OpenStream()\n\t\tif err != nil {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tdefer stream.Close()\n\n\t\tconn := clientConn.(*pipeConn)\n\t\tconn.writeBlocker.Lock()\n\t\tdefer conn.writeBlocker.Unlock()\n\n\t\t// Since the write goroutine is blocked then this will return a\n\t\t// timeout since it can't get feedback about whether the write\n\t\t// worked.\n\t\tn, err := stream.Write([]byte(\"hello\"))\n\t\tif err != ErrConnectionWriteTimeout {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\t\tif n != 0 {\n\t\t\terrCh <- fmt.Errorf(\"lied about writes: %d\", n)\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tdrainErrorsUntil(t, errCh, 2, 0, \"\")\n}\n\nfunc TestCancelAccept(t *testing.T) {\n\t_, server := testClientServer(t)\n\n\tctx, cancel := context.WithCancel(context.Background())\n\tt.Cleanup(cancel)\n\n\terrCh := make(chan error, 1)\n\n\tgo func() {\n\t\tstream, err := server.AcceptStreamWithContext(ctx)\n\t\tif err != context.Canceled {\n\t\t\terrCh <- err\n\t\t\treturn\n\t\t}\n\n\t\tif stream != nil {\n\t\t\tdefer stream.Close()\n\t\t}\n\t\terrCh <- nil\n\t}()\n\n\tcancel()\n\n\tdrainErrorsUntil(t, errCh, 1, 0, \"\")\n}\n\n// drainErrorsUntil receives `expect` errors from errCh within `timeout`. Fails\n// on any non-nil errors.\nfunc drainErrorsUntil(t testing.TB, errCh chan error, expect int, timeout time.Duration, msg string) {\n\tt.Helper()\n\tstart := time.Now()\n\tvar timerC <-chan time.Time\n\tif timeout > 0 {\n\t\ttimerC = time.After(timeout)\n\t}\n\n\tfor found := 0; found < expect; {\n\t\tselect {\n\t\tcase <-timerC:\n\t\t\tt.Fatalf(msg+\" (timeout was %v)\", timeout)\n\t\tcase err := <-errCh:\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"err: %v\", err)\n\t\t\t} else {\n\t\t\t\tfound++\n\t\t\t}\n\t\t}\n\t}\n\tt.Logf(\"drain took %v (timeout was %v)\", time.Since(start), timeout)\n}\n"
        },
        {
          "name": "spec.md",
          "type": "blob",
          "size": 4.677734375,
          "content": "# Specification\n\nWe use this document to detail the internal specification of Yamux.\nThis is used both as a guide for implementing Yamux, but also for\nalternative interoperable libraries to be built.\n\n# Framing\n\nYamux uses a streaming connection underneath, but imposes a message\nframing so that it can be shared between many logical streams. Each\nframe contains a header like:\n\n* Version (8 bits)\n* Type (8 bits)\n* Flags (16 bits)\n* StreamID (32 bits)\n* Length (32 bits)\n\nThis means that each header has a 12 byte overhead.\nAll fields are encoded in network order (big endian).\nEach field is described below:\n\n## Version Field\n\nThe version field is used for future backward compatibility. At the\ncurrent time, the field is always set to 0, to indicate the initial\nversion.\n\n## Type Field\n\nThe type field is used to switch the frame message type. The following\nmessage types are supported:\n\n* 0x0 Data - Used to transmit data. May transmit zero length payloads\n  depending on the flags.\n\n* 0x1 Window Update - Used to updated the senders receive window size.\n  This is used to implement per-session flow control.\n\n* 0x2 Ping - Used to measure RTT. It can also be used to heart-beat\n  and do keep-alives over TCP.\n\n* 0x3 Go Away - Used to close a session.\n\n## Flag Field\n\nThe flags field is used to provide additional information related\nto the message type. The following flags are supported:\n\n* 0x1 SYN - Signals the start of a new stream. May be sent with a data or\n  window update message. Also sent with a ping to indicate outbound.\n\n* 0x2 ACK - Acknowledges the start of a new stream. May be sent with a data\n  or window update message. Also sent with a ping to indicate response.\n\n* 0x4 FIN - Performs a half-close of a stream. May be sent with a data\n  message or window update.\n\n* 0x8 RST - Reset a stream immediately. May be sent with a data or\n  window update message.\n\n## StreamID Field\n\nThe StreamID field is used to identify the logical stream the frame\nis addressing. The client side should use odd ID's, and the server even.\nThis prevents any collisions. Additionally, the 0 ID is reserved to represent\nthe session.\n\nBoth Ping and Go Away messages should always use the 0 StreamID.\n\n## Length Field\n\nThe meaning of the length field depends on the message type:\n\n* Data - provides the length of bytes following the header\n* Window update - provides a delta update to the window size\n* Ping - Contains an opaque value, echoed back\n* Go Away - Contains an error code\n\n# Message Flow\n\nThere is no explicit connection setup, as Yamux relies on an underlying\ntransport to be provided. However, there is a distinction between client\nand server side of the connection.\n\n## Opening a stream\n\nTo open a stream, an initial data or window update frame is sent\nwith a new StreamID. The SYN flag should be set to signal a new stream.\n\nThe receiver must then reply with either a data or window update frame\nwith the StreamID along with the ACK flag to accept the stream or with\nthe RST flag to reject the stream.\n\nBecause we are relying on the reliable stream underneath, a connection\ncan begin sending data once the SYN flag is sent. The corresponding\nACK does not need to be received. This is particularly well suited\nfor an RPC system where a client wants to open a stream and immediately\nfire a request without waiting for the RTT of the ACK.\n\nThis does introduce the possibility of a connection being rejected\nafter data has been sent already. This is a slight semantic difference\nfrom TCP, where the connection cannot be refused after it is opened.\nClients should be prepared to handle this by checking for an error\nthat indicates a RST was received.\n\n## Closing a stream\n\nTo close a stream, either side sends a data or window update frame\nalong with the FIN flag. This does a half-close indicating the sender\nwill send no further data.\n\nOnce both sides have closed the connection, the stream is closed.\n\nAlternatively, if an error occurs, the RST flag can be used to\nhard close a stream immediately.\n\n## Flow Control\n\nWhen Yamux is initially starts each stream with a 256KB window size.\nThere is no window size for the session.\n\nTo prevent the streams from stalling, window update frames should be\nsent regularly. Yamux can be configured to provide a larger limit for\nwindows sizes. Both sides assume the initial 256KB window, but can\nimmediately send a window update as part of the SYN/ACK indicating a\nlarger window.\n\nBoth sides should track the number of bytes sent in Data frames\nonly, as only they are tracked as part of the window size.\n\n## Session termination\n\nWhen a session is being terminated, the Go Away message should\nbe sent. The Length should be set to one of the following to\nprovide an error code:\n\n* 0x0 Normal termination\n* 0x1 Protocol error\n* 0x2 Internal error\n"
        },
        {
          "name": "stream.go",
          "type": "blob",
          "size": 13.541015625,
          "content": "package yamux\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\ntype streamState int\n\nconst (\n\tstreamInit streamState = iota\n\tstreamSYNSent\n\tstreamSYNReceived\n\tstreamEstablished\n\tstreamLocalClose\n\tstreamRemoteClose\n\tstreamClosed\n\tstreamReset\n)\n\n// Stream is used to represent a logical stream within a session. Methods on\n// Stream are safe to call concurrently with one another, but all Read calls\n// must be on the same goroutine and all Write calls must be on the same\n// goroutine.\ntype Stream struct {\n\trecvWindow uint32\n\tsendWindow uint32\n\n\tid      uint32\n\tsession *Session\n\n\tstate     streamState\n\tstateLock sync.Mutex\n\n\trecvBuf  *bytes.Buffer\n\trecvLock sync.Mutex\n\n\tcontrolHdr     header\n\tcontrolErr     chan error\n\tcontrolHdrLock sync.Mutex\n\n\tsendHdr  header\n\tsendErr  chan error\n\tsendLock sync.Mutex\n\n\trecvNotifyCh chan struct{}\n\tsendNotifyCh chan struct{}\n\n\treadDeadline  atomic.Value // time.Time\n\twriteDeadline atomic.Value // time.Time\n\n\t// establishCh is notified if the stream is established or being closed.\n\testablishCh chan struct{}\n\n\t// closeTimer is set with stateLock held to honor the StreamCloseTimeout\n\t// setting on Session.\n\tcloseTimer *time.Timer\n}\n\n// newStream is used to construct a new stream within\n// a given session for an ID\nfunc newStream(session *Session, id uint32, state streamState) *Stream {\n\ts := &Stream{\n\t\tid:           id,\n\t\tsession:      session,\n\t\tstate:        state,\n\t\tcontrolHdr:   header(make([]byte, headerSize)),\n\t\tcontrolErr:   make(chan error, 1),\n\t\tsendHdr:      header(make([]byte, headerSize)),\n\t\tsendErr:      make(chan error, 1),\n\t\trecvWindow:   initialStreamWindow,\n\t\tsendWindow:   initialStreamWindow,\n\t\trecvNotifyCh: make(chan struct{}, 1),\n\t\tsendNotifyCh: make(chan struct{}, 1),\n\t\testablishCh:  make(chan struct{}, 1),\n\t}\n\ts.readDeadline.Store(time.Time{})\n\ts.writeDeadline.Store(time.Time{})\n\treturn s\n}\n\n// Session returns the associated stream session\nfunc (s *Stream) Session() *Session {\n\treturn s.session\n}\n\n// StreamID returns the ID of this stream\nfunc (s *Stream) StreamID() uint32 {\n\treturn s.id\n}\n\n// Read is used to read from the stream. It is safe to call Write, Read, and/or\n// Close concurrently with each other, but calls to Read are not reentrant and\n// should not be called from multiple goroutines. Multiple Read goroutines would\n// receive different chunks of data from the Stream and be unable to reassemble\n// them in order or along message boundaries, and may encounter deadlocks.\nfunc (s *Stream) Read(b []byte) (n int, err error) {\n\tdefer asyncNotify(s.recvNotifyCh)\nSTART:\n\n\t// If the stream is closed and there's no data buffered, return EOF\n\ts.stateLock.Lock()\n\tswitch s.state {\n\tcase streamLocalClose:\n\t\t// LocalClose only prohibits further local writes. Handle reads normally.\n\tcase streamRemoteClose:\n\t\tfallthrough\n\tcase streamClosed:\n\t\ts.recvLock.Lock()\n\t\tif s.recvBuf == nil || s.recvBuf.Len() == 0 {\n\t\t\ts.recvLock.Unlock()\n\t\t\ts.stateLock.Unlock()\n\t\t\treturn 0, io.EOF\n\t\t}\n\t\ts.recvLock.Unlock()\n\tcase streamReset:\n\t\ts.stateLock.Unlock()\n\t\treturn 0, ErrConnectionReset\n\t}\n\ts.stateLock.Unlock()\n\n\t// If there is no data available, block\n\ts.recvLock.Lock()\n\tif s.recvBuf == nil || s.recvBuf.Len() == 0 {\n\t\ts.recvLock.Unlock()\n\t\tgoto WAIT\n\t}\n\n\t// Read any bytes\n\tn, _ = s.recvBuf.Read(b)\n\ts.recvLock.Unlock()\n\n\t// Send a window update potentially\n\terr = s.sendWindowUpdate()\n\tif err == ErrSessionShutdown {\n\t\terr = nil\n\t}\n\treturn n, err\n\nWAIT:\n\tvar timeout <-chan time.Time\n\tvar timer *time.Timer\n\treadDeadline := s.readDeadline.Load().(time.Time)\n\tif !readDeadline.IsZero() {\n\t\tdelay := time.Until(readDeadline)\n\t\ttimer = time.NewTimer(delay)\n\t\ttimeout = timer.C\n\t}\n\tselect {\n\tcase <-s.session.shutdownCh:\n\tcase <-s.recvNotifyCh:\n\tcase <-timeout:\n\t\treturn 0, ErrTimeout\n\t}\n\tif timer != nil {\n\t\tif !timer.Stop() {\n\t\t\t<-timeout\n\t\t}\n\t}\n\tgoto START\n}\n\n// Write is used to write to the stream. It is safe to call Write, Read, and/or\n// Close concurrently with each other, but calls to Write are not reentrant and\n// should not be called from multiple goroutines.\nfunc (s *Stream) Write(b []byte) (n int, err error) {\n\ts.sendLock.Lock()\n\tdefer s.sendLock.Unlock()\n\ttotal := 0\n\tfor total < len(b) {\n\t\tn, err := s.write(b[total:])\n\t\ttotal += n\n\t\tif err != nil {\n\t\t\treturn total, err\n\t\t}\n\t}\n\treturn total, nil\n}\n\n// write is used to write to the stream, may return on\n// a short write.\nfunc (s *Stream) write(b []byte) (n int, err error) {\n\tvar flags uint16\n\tvar max uint32\n\tvar body []byte\nSTART:\n\ts.stateLock.Lock()\n\tswitch s.state {\n\tcase streamLocalClose:\n\t\tfallthrough\n\tcase streamClosed:\n\t\ts.stateLock.Unlock()\n\t\treturn 0, ErrStreamClosed\n\tcase streamReset:\n\t\ts.stateLock.Unlock()\n\t\treturn 0, ErrConnectionReset\n\t}\n\ts.stateLock.Unlock()\n\n\t// If there is no data available, block\n\twindow := atomic.LoadUint32(&s.sendWindow)\n\tif window == 0 {\n\t\tgoto WAIT\n\t}\n\n\t// Determine the flags if any\n\tflags = s.sendFlags()\n\n\t// Send up to our send window\n\tmax = min(window, uint32(len(b)))\n\tbody = b[:max]\n\n\t// Send the header\n\ts.sendHdr.encode(typeData, flags, s.id, max)\n\tif err = s.session.waitForSendErr(s.sendHdr, body, s.sendErr); err != nil {\n\t\tif errors.Is(err, ErrSessionShutdown) || errors.Is(err, ErrConnectionWriteTimeout) {\n\t\t\t// Message left in ready queue, header re-use is unsafe.\n\t\t\ts.sendHdr = header(make([]byte, headerSize))\n\t\t}\n\t\treturn 0, err\n\t}\n\n\t// Reduce our send window\n\tatomic.AddUint32(&s.sendWindow, ^uint32(max-1))\n\n\t// Unlock\n\treturn int(max), err\n\nWAIT:\n\tvar timeout <-chan time.Time\n\tvar timer *time.Timer\n\twriteDeadline := s.writeDeadline.Load().(time.Time)\n\tif !writeDeadline.IsZero() {\n\t\tdelay := time.Until(writeDeadline)\n\t\ttimer = time.NewTimer(delay)\n\t\ttimeout = timer.C\n\t}\n\tselect {\n\tcase <-s.session.shutdownCh:\n\tcase <-s.sendNotifyCh:\n\tcase <-timeout:\n\t\treturn 0, ErrTimeout\n\t}\n\tif timer != nil {\n\t\tif !timer.Stop() {\n\t\t\t<-timeout\n\t\t}\n\t}\n\tgoto START\n}\n\n// sendFlags determines any flags that are appropriate\n// based on the current stream state\nfunc (s *Stream) sendFlags() uint16 {\n\ts.stateLock.Lock()\n\tdefer s.stateLock.Unlock()\n\tvar flags uint16\n\tswitch s.state {\n\tcase streamInit:\n\t\tflags |= flagSYN\n\t\ts.state = streamSYNSent\n\tcase streamSYNReceived:\n\t\tflags |= flagACK\n\t\ts.state = streamEstablished\n\t}\n\treturn flags\n}\n\n// sendWindowUpdate potentially sends a window update enabling\n// further writes to take place. Must be invoked with the lock.\nfunc (s *Stream) sendWindowUpdate() error {\n\ts.controlHdrLock.Lock()\n\tdefer s.controlHdrLock.Unlock()\n\n\t// Determine the delta update\n\tmax := s.session.config.MaxStreamWindowSize\n\tvar bufLen uint32\n\ts.recvLock.Lock()\n\tif s.recvBuf != nil {\n\t\tbufLen = uint32(s.recvBuf.Len())\n\t}\n\tdelta := (max - bufLen) - s.recvWindow\n\n\t// Determine the flags if any\n\tflags := s.sendFlags()\n\n\t// Check if we can omit the update\n\tif delta < (max/2) && flags == 0 {\n\t\ts.recvLock.Unlock()\n\t\treturn nil\n\t}\n\n\t// Update our window\n\ts.recvWindow += delta\n\ts.recvLock.Unlock()\n\n\t// Send the header\n\ts.controlHdr.encode(typeWindowUpdate, flags, s.id, delta)\n\tif err := s.session.waitForSendErr(s.controlHdr, nil, s.controlErr); err != nil {\n\t\tif errors.Is(err, ErrSessionShutdown) || errors.Is(err, ErrConnectionWriteTimeout) {\n\t\t\t// Message left in ready queue, header re-use is unsafe.\n\t\t\ts.controlHdr = header(make([]byte, headerSize))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// sendClose is used to send a FIN\nfunc (s *Stream) sendClose() error {\n\ts.controlHdrLock.Lock()\n\tdefer s.controlHdrLock.Unlock()\n\n\tflags := s.sendFlags()\n\tflags |= flagFIN\n\ts.controlHdr.encode(typeWindowUpdate, flags, s.id, 0)\n\tif err := s.session.waitForSendErr(s.controlHdr, nil, s.controlErr); err != nil {\n\t\tif errors.Is(err, ErrSessionShutdown) || errors.Is(err, ErrConnectionWriteTimeout) {\n\t\t\t// Message left in ready queue, header re-use is unsafe.\n\t\t\ts.controlHdr = header(make([]byte, headerSize))\n\t\t}\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Close is used to close the stream. It is safe to call Close concurrently.\nfunc (s *Stream) Close() error {\n\tcloseStream := false\n\ts.stateLock.Lock()\n\tswitch s.state {\n\t// Opened means we need to signal a close\n\tcase streamSYNSent:\n\t\tfallthrough\n\tcase streamSYNReceived:\n\t\tfallthrough\n\tcase streamEstablished:\n\t\ts.state = streamLocalClose\n\t\tgoto SEND_CLOSE\n\n\tcase streamLocalClose:\n\tcase streamRemoteClose:\n\t\ts.state = streamClosed\n\t\tcloseStream = true\n\t\tgoto SEND_CLOSE\n\n\tcase streamClosed:\n\tcase streamReset:\n\tdefault:\n\t\tpanic(\"unhandled state\")\n\t}\n\ts.stateLock.Unlock()\n\treturn nil\nSEND_CLOSE:\n\t// This shouldn't happen (the more realistic scenario to cancel the\n\t// timer is via processFlags) but just in case this ever happens, we\n\t// cancel the timer to prevent dangling timers.\n\tif s.closeTimer != nil {\n\t\ts.closeTimer.Stop()\n\t\ts.closeTimer = nil\n\t}\n\n\t// If we have a StreamCloseTimeout set we start the timeout timer.\n\t// We do this only if we're not already closing the stream since that\n\t// means this was a graceful close.\n\t//\n\t// This prevents memory leaks if one side (this side) closes and the\n\t// remote side poorly behaves and never responds with a FIN to complete\n\t// the close. After the specified timeout, we clean our resources up no\n\t// matter what.\n\tif !closeStream && s.session.config.StreamCloseTimeout > 0 {\n\t\ts.closeTimer = time.AfterFunc(\n\t\t\ts.session.config.StreamCloseTimeout, s.closeTimeout)\n\t}\n\n\ts.stateLock.Unlock()\n\ts.sendClose()\n\ts.notifyWaiting()\n\tif closeStream {\n\t\ts.session.closeStream(s.id)\n\t}\n\treturn nil\n}\n\n// closeTimeout is called after StreamCloseTimeout during a close to\n// close this stream.\nfunc (s *Stream) closeTimeout() {\n\t// Close our side forcibly\n\ts.forceClose()\n\n\t// Free the stream from the session map\n\ts.session.closeStream(s.id)\n\n\t// Send a RST so the remote side closes too.\n\ts.sendLock.Lock()\n\tdefer s.sendLock.Unlock()\n\thdr := header(make([]byte, headerSize))\n\thdr.encode(typeWindowUpdate, flagRST, s.id, 0)\n\t_ = s.session.sendNoWait(hdr)\n}\n\n// forceClose is used for when the session is exiting\nfunc (s *Stream) forceClose() {\n\ts.stateLock.Lock()\n\ts.state = streamClosed\n\ts.stateLock.Unlock()\n\ts.notifyWaiting()\n}\n\n// processFlags is used to update the state of the stream\n// based on set flags, if any. Lock must be held\nfunc (s *Stream) processFlags(flags uint16) error {\n\ts.stateLock.Lock()\n\tdefer s.stateLock.Unlock()\n\n\t// Close the stream without holding the state lock\n\tcloseStream := false\n\tdefer func() {\n\t\tif closeStream {\n\t\t\tif s.closeTimer != nil {\n\t\t\t\t// Stop our close timeout timer since we gracefully closed\n\t\t\t\ts.closeTimer.Stop()\n\t\t\t}\n\n\t\t\ts.session.closeStream(s.id)\n\t\t}\n\t}()\n\n\tif flags&flagACK == flagACK {\n\t\tif s.state == streamSYNSent {\n\t\t\ts.state = streamEstablished\n\t\t}\n\t\tasyncNotify(s.establishCh)\n\t\ts.session.establishStream(s.id)\n\t}\n\tif flags&flagFIN == flagFIN {\n\t\tswitch s.state {\n\t\tcase streamSYNSent:\n\t\t\tfallthrough\n\t\tcase streamSYNReceived:\n\t\t\tfallthrough\n\t\tcase streamEstablished:\n\t\t\ts.state = streamRemoteClose\n\t\t\ts.notifyWaiting()\n\t\tcase streamLocalClose:\n\t\t\ts.state = streamClosed\n\t\t\tcloseStream = true\n\t\t\ts.notifyWaiting()\n\t\tdefault:\n\t\t\ts.session.logger.Printf(\"[ERR] yamux: unexpected FIN flag in state %d\", s.state)\n\t\t\treturn ErrUnexpectedFlag\n\t\t}\n\t}\n\tif flags&flagRST == flagRST {\n\t\ts.state = streamReset\n\t\tcloseStream = true\n\t\ts.notifyWaiting()\n\t}\n\treturn nil\n}\n\n// notifyWaiting notifies all the waiting channels\nfunc (s *Stream) notifyWaiting() {\n\tasyncNotify(s.recvNotifyCh)\n\tasyncNotify(s.sendNotifyCh)\n\tasyncNotify(s.establishCh)\n}\n\n// incrSendWindow updates the size of our send window\nfunc (s *Stream) incrSendWindow(hdr header, flags uint16) error {\n\tif err := s.processFlags(flags); err != nil {\n\t\treturn err\n\t}\n\n\t// Increase window, unblock a sender\n\tatomic.AddUint32(&s.sendWindow, hdr.Length())\n\tasyncNotify(s.sendNotifyCh)\n\treturn nil\n}\n\n// readData is used to handle a data frame\nfunc (s *Stream) readData(hdr header, flags uint16, conn io.Reader) error {\n\tif err := s.processFlags(flags); err != nil {\n\t\treturn err\n\t}\n\n\t// Check that our recv window is not exceeded\n\tlength := hdr.Length()\n\tif length == 0 {\n\t\treturn nil\n\t}\n\n\t// Wrap in a limited reader\n\tconn = &io.LimitedReader{R: conn, N: int64(length)}\n\n\t// Copy into buffer\n\ts.recvLock.Lock()\n\n\tif length > s.recvWindow {\n\t\ts.session.logger.Printf(\"[ERR] yamux: receive window exceeded (stream: %d, remain: %d, recv: %d)\", s.id, s.recvWindow, length)\n\t\ts.recvLock.Unlock()\n\t\treturn ErrRecvWindowExceeded\n\t}\n\n\tif s.recvBuf == nil {\n\t\t// Allocate the receive buffer just-in-time to fit the full data frame.\n\t\t// This way we can read in the whole packet without further allocations.\n\t\ts.recvBuf = bytes.NewBuffer(make([]byte, 0, length))\n\t}\n\tcopiedLength, err := io.Copy(s.recvBuf, conn)\n\tif err != nil {\n\t\ts.session.logger.Printf(\"[ERR] yamux: Failed to read stream data: %v\", err)\n\t\ts.recvLock.Unlock()\n\t\treturn err\n\t}\n\n\t// Decrement the receive window\n\ts.recvWindow -= uint32(copiedLength)\n\ts.recvLock.Unlock()\n\n\t// Unblock any readers\n\tasyncNotify(s.recvNotifyCh)\n\treturn nil\n}\n\n// SetDeadline sets the read and write deadlines\nfunc (s *Stream) SetDeadline(t time.Time) error {\n\tif err := s.SetReadDeadline(t); err != nil {\n\t\treturn err\n\t}\n\tif err := s.SetWriteDeadline(t); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// SetReadDeadline sets the deadline for blocked and future Read calls.\nfunc (s *Stream) SetReadDeadline(t time.Time) error {\n\ts.readDeadline.Store(t)\n\tasyncNotify(s.recvNotifyCh)\n\treturn nil\n}\n\n// SetWriteDeadline sets the deadline for blocked and future Write calls\nfunc (s *Stream) SetWriteDeadline(t time.Time) error {\n\ts.writeDeadline.Store(t)\n\tasyncNotify(s.sendNotifyCh)\n\treturn nil\n}\n\n// Shrink is used to compact the amount of buffers utilized\n// This is useful when using Yamux in a connection pool to reduce\n// the idle memory utilization.\nfunc (s *Stream) Shrink() {\n\ts.recvLock.Lock()\n\tif s.recvBuf != nil && s.recvBuf.Len() == 0 {\n\t\ts.recvBuf = nil\n\t}\n\ts.recvLock.Unlock()\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 0.75390625,
          "content": "package yamux\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// Logger is a abstract of *log.Logger\ntype Logger interface {\n\tPrint(v ...interface{})\n\tPrintf(format string, v ...interface{})\n\tPrintln(v ...interface{})\n}\n\nvar (\n\ttimerPool = &sync.Pool{\n\t\tNew: func() interface{} {\n\t\t\ttimer := time.NewTimer(time.Hour * 1e6)\n\t\t\ttimer.Stop()\n\t\t\treturn timer\n\t\t},\n\t}\n)\n\n// asyncSendErr is used to try an async send of an error\nfunc asyncSendErr(ch chan error, err error) {\n\tif ch == nil {\n\t\treturn\n\t}\n\tselect {\n\tcase ch <- err:\n\tdefault:\n\t}\n}\n\n// asyncNotify is used to signal a waiting goroutine\nfunc asyncNotify(ch chan struct{}) {\n\tselect {\n\tcase ch <- struct{}{}:\n\tdefault:\n\t}\n}\n\n// min computes the minimum of two values\nfunc min(a, b uint32) uint32 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "util_test.go",
          "type": "blob",
          "size": 0.66796875,
          "content": "package yamux\n\nimport (\n\t\"testing\"\n)\n\nfunc TestAsyncSendErr(t *testing.T) {\n\tch := make(chan error)\n\tasyncSendErr(ch, ErrTimeout)\n\tselect {\n\tcase <-ch:\n\t\tt.Fatalf(\"should not get\")\n\tdefault:\n\t}\n\n\tch = make(chan error, 1)\n\tasyncSendErr(ch, ErrTimeout)\n\tselect {\n\tcase <-ch:\n\tdefault:\n\t\tt.Fatalf(\"should get\")\n\t}\n}\n\nfunc TestAsyncNotify(t *testing.T) {\n\tch := make(chan struct{})\n\tasyncNotify(ch)\n\tselect {\n\tcase <-ch:\n\t\tt.Fatalf(\"should not get\")\n\tdefault:\n\t}\n\n\tch = make(chan struct{}, 1)\n\tasyncNotify(ch)\n\tselect {\n\tcase <-ch:\n\tdefault:\n\t\tt.Fatalf(\"should get\")\n\t}\n}\n\nfunc TestMin(t *testing.T) {\n\tif min(1, 2) != 1 {\n\t\tt.Fatalf(\"bad\")\n\t}\n\tif min(2, 1) != 1 {\n\t\tt.Fatalf(\"bad\")\n\t}\n}\n"
        }
      ]
    }
  ]
}