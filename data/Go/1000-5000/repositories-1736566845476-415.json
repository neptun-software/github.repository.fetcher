{
  "metadata": {
    "timestamp": 1736566845476,
    "page": 415,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kevwan/tproxy",
      "stars": 3322,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.267578125,
          "content": "# Ignore all\n*\n\n# Unignore all with extensions\n!*.*\n!**/Dockerfile\n!**/Makefile\n\n# Unignore all dirs\n!*/\n!api\n\n# ignore\n.idea\n**/.DS_Store\n**/logs\nmodd.conf\nmakefile\n\n# for test purpose\n**/adhoc\napp\ngo.work\ngo.work.sum\n\n# gitlab ci\n.cache\n\n# vim auto backup file\n*~\n!OWNERS\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.6494140625,
          "content": "FROM golang:alpine AS builder\n\nLABEL stage=gobuilder\n\nENV CGO_ENABLED 0\nENV GOPROXY https://goproxy.cn,direct\nRUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories\n\nRUN apk update --no-cache && apk add --no-cache tzdata\n\nWORKDIR /build\n\nADD go.mod .\nADD go.sum .\nRUN go mod download\nCOPY . .\nRUN go build -ldflags=\"-s -w\" -o /app/tproxy .\n\n\nFROM scratch\n\nCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt\nCOPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /usr/share/zoneinfo/Asia/Shanghai\nENV TZ Asia/Shanghai\n\nWORKDIR /app\nCOPY --from=builder /app/tproxy /usr/local/bin/tproxy\n\nCMD [\"tproxy\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.041015625,
          "content": "MIT License\n\nCopyright (c) 2022 Kevin Wan\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 3.5205078125,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/juju/ratelimit\"\n\t\"github.com/kevwan/tproxy/display\"\n\t\"github.com/kevwan/tproxy/protocol\"\n)\n\nconst (\n\tuseOfClosedConn = \"use of closed network connection\"\n\tstatInterval    = time.Second * 5\n)\n\nvar (\n\terrClientCanceled = errors.New(\"client canceled\")\n\tstat              Stater\n)\n\ntype PairedConnection struct {\n\tid       int\n\tcliConn  net.Conn\n\tsvrConn  net.Conn\n\tonce     sync.Once\n\tstopChan chan struct{}\n}\n\nfunc NewPairedConnection(id int, cliConn net.Conn) *PairedConnection {\n\treturn &PairedConnection{\n\t\tid:       id,\n\t\tcliConn:  cliConn,\n\t\tstopChan: make(chan struct{}),\n\t}\n}\n\nfunc (c *PairedConnection) copyData(dst io.Writer, src io.Reader, tag string) {\n\t_, e := io.Copy(dst, src)\n\tif e != nil {\n\t\tnetOpError, ok := e.(*net.OpError)\n\t\tif ok && netOpError.Err.Error() != useOfClosedConn {\n\t\t\treason := netOpError.Unwrap().Error()\n\t\t\tdisplay.PrintlnWithTime(color.HiRedString(\"[%d] %s error, %s\", c.id, tag, reason))\n\t\t}\n\t}\n}\n\nfunc (c *PairedConnection) copyDataWithRateLimit(dst io.Writer, src io.Reader, tag string, limit int64) {\n\tif limit > 0 {\n\t\tbucket := ratelimit.NewBucket(time.Second, limit)\n\t\tsrc = ratelimit.Reader(src, bucket)\n\t}\n\n\tc.copyData(dst, src, tag)\n}\n\nfunc (c *PairedConnection) handleClientMessage() {\n\t// client closed also trigger server close.\n\tdefer c.stop()\n\n\tr, w := io.Pipe()\n\ttee := io.MultiWriter(c.svrConn, w)\n\tgo protocol.CreateInterop(settings.Protocol).Dump(r, protocol.ClientSide, c.id, settings.Quiet)\n\tc.copyDataWithRateLimit(tee, c.cliConn, protocol.ClientSide, settings.UpLimit)\n}\n\nfunc (c *PairedConnection) handleServerMessage() {\n\t// server closed also trigger client close.\n\tdefer c.stop()\n\n\tr, w := io.Pipe()\n\ttee := io.MultiWriter(newDelayedWriter(c.cliConn, settings.Delay, c.stopChan), w)\n\tgo protocol.CreateInterop(settings.Protocol).Dump(r, protocol.ServerSide, c.id, settings.Quiet)\n\tc.copyDataWithRateLimit(tee, c.svrConn, protocol.ServerSide, settings.DownLimit)\n}\n\nfunc (c *PairedConnection) process() {\n\tdefer c.stop()\n\n\tconn, err := net.Dial(\"tcp\", settings.Remote)\n\tif err != nil {\n\t\tdisplay.PrintlnWithTime(color.HiRedString(\"[x][%d] Couldn't connect to server: %v\", c.id, err))\n\t\treturn\n\t}\n\n\tdisplay.PrintlnWithTime(color.HiGreenString(\"[%d] Connected to server: %s\", c.id, conn.RemoteAddr()))\n\n\tstat.AddConn(strconv.Itoa(c.id), conn.(*net.TCPConn))\n\tc.svrConn = conn\n\tgo c.handleServerMessage()\n\n\tc.handleClientMessage()\n}\n\nfunc (c *PairedConnection) stop() {\n\tc.once.Do(func() {\n\t\tclose(c.stopChan)\n\t\tstat.DelConn(strconv.Itoa(c.id))\n\n\t\tif c.cliConn != nil {\n\t\t\tdisplay.PrintlnWithTime(color.HiBlueString(\"[%d] Client connection closed\", c.id))\n\t\t\tc.cliConn.Close()\n\t\t}\n\t\tif c.svrConn != nil {\n\t\t\tdisplay.PrintlnWithTime(color.HiBlueString(\"[%d] Server connection closed\", c.id))\n\t\t\tc.svrConn.Close()\n\t\t}\n\t})\n}\n\nfunc startListener() error {\n\tstat = NewStater(NewConnCounter(), NewStatPrinter(statInterval))\n\tgo stat.Start()\n\n\tconn, err := net.Listen(\"tcp\", fmt.Sprintf(\"%s:%d\", settings.LocalHost, settings.LocalPort))\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to start listener: %w\", err)\n\t}\n\tdefer conn.Close()\n\n\tdisplay.PrintfWithTime(\"Listening on %s...\\n\", conn.Addr().String())\n\n\tvar connIndex int\n\tfor {\n\t\tcliConn, err := conn.Accept()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"server: accept: %w\", err)\n\t\t}\n\n\t\tconnIndex++\n\t\tdisplay.PrintlnWithTime(color.HiGreenString(\"[%d] Accepted from: %s\",\n\t\t\tconnIndex, cliConn.RemoteAddr()))\n\n\t\tpconn := NewPairedConnection(connIndex, cliConn)\n\t\tgo pconn.process()\n\t}\n}\n"
        },
        {
          "name": "counter.go",
          "type": "blob",
          "size": 1.4384765625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/fatih/color\"\n)\n\ntype connCounter struct {\n\ttotal       int64\n\tconcurrent  int64\n\tmax         int64\n\tconns       map[string]time.Time\n\tmaxLifetime time.Duration\n\tlock        sync.Mutex\n}\n\nfunc NewConnCounter() Stater {\n\treturn &connCounter{\n\t\tconns: make(map[string]time.Time),\n\t}\n}\n\nfunc (c *connCounter) AddConn(key string, _ *net.TCPConn) {\n\tatomic.AddInt64(&c.total, 1)\n\tval := atomic.AddInt64(&c.concurrent, 1)\n\tmax := atomic.LoadInt64(&c.max)\n\tif val > max {\n\t\tatomic.CompareAndSwapInt64(&c.max, max, val)\n\t}\n\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tc.conns[key] = time.Now()\n}\n\nfunc (c *connCounter) DelConn(key string) {\n\tatomic.AddInt64(&c.concurrent, -1)\n\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tstart, ok := c.conns[key]\n\tdelete(c.conns, key)\n\tif ok {\n\t\tlifetime := time.Since(start)\n\t\tif lifetime > c.maxLifetime {\n\t\t\tc.maxLifetime = lifetime\n\t\t}\n\t}\n}\n\nfunc (c *connCounter) Start() {\n}\n\nfunc (c *connCounter) Stop() {\n\tc.lock.Lock()\n\tfor _, start := range c.conns {\n\t\tlifetime := time.Since(start)\n\t\tif lifetime > c.maxLifetime {\n\t\t\tc.maxLifetime = lifetime\n\t\t}\n\t}\n\tdefer c.lock.Unlock()\n\n\tfmt.Println()\n\tcolor.HiWhite(\"Connection stats (client -> tproxy -> server):\")\n\tcolor.HiWhite(\"  Total connections: %d\", atomic.LoadInt64(&c.total))\n\tcolor.HiWhite(\"  Max concurrent connections: %d\", atomic.LoadInt64(&c.max))\n\tcolor.HiWhite(\"  Max connection lifetime: %s\", c.maxLifetime)\n}\n"
        },
        {
          "name": "delayedwriter.go",
          "type": "blob",
          "size": 0.5869140625,
          "content": "package main\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\ntype delayedWriter struct {\n\twriter   io.Writer\n\tdelay    time.Duration\n\tstopChan <-chan struct{}\n}\n\nfunc newDelayedWriter(writer io.Writer, delay time.Duration, stopChan <-chan struct{}) delayedWriter {\n\treturn delayedWriter{\n\t\twriter:   writer,\n\t\tdelay:    delay,\n\t\tstopChan: stopChan,\n\t}\n}\n\nfunc (w delayedWriter) Write(p []byte) (int, error) {\n\tif w.delay == 0 {\n\t\treturn w.writer.Write(p)\n\t}\n\n\ttimer := time.NewTimer(w.delay)\n\tdefer timer.Stop()\n\n\tselect {\n\tcase <-timer.C:\n\t\treturn w.writer.Write(p)\n\tcase <-w.stopChan:\n\t\treturn 0, errClientCanceled\n\t}\n}\n"
        },
        {
          "name": "display",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.638671875,
          "content": "module github.com/kevwan/tproxy\n\ngo 1.18\n\nrequire (\n\tgithub.com/eclipse/paho.mqtt.golang v1.5.0\n\tgithub.com/fatih/color v1.18.0\n\tgithub.com/juju/ratelimit v1.0.2\n\tgithub.com/olekukonko/tablewriter v0.0.5\n\tgo.mongodb.org/mongo-driver v1.17.2\n\tgolang.org/x/net v0.34.0\n\tgoogle.golang.org/protobuf v1.36.2\n)\n\nrequire (\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.14 // indirect\n\tgithub.com/rivo/uniseg v0.4.4 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.3486328125,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/eclipse/paho.mqtt.golang v1.5.0 h1:EH+bUVJNgttidWFkLLVKaQPGmkTUfQQqjOsyvMGvD6o=\ngithub.com/eclipse/paho.mqtt.golang v1.5.0/go.mod h1:du/2qNQVqJf/Sqs4MEL77kR8QTqANF7XU7Fk0aOTAgk=\ngithub.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=\ngithub.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/juju/ratelimit v1.0.2 h1:sRxmtRiajbvrcLQT7S+JbqU0ntsb9W2yhSdNN8tWfaI=\ngithub.com/juju/ratelimit v1.0.2/go.mod h1:qapgC/Gy+xNh9UxzV13HGGl/6UXNN+ct+vwSgWNm/qk=\ngithub.com/kr/pretty v0.2.1 h1:Fmg33tUaq4/8ym9TJN1x7sLJnHVwhP33CNkpYV/7rwI=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.14 h1:+xnbZSEeDbOIg5/mE6JF0w6n9duR1l3/WmbinWVwUuU=\ngithub.com/mattn/go-runewidth v0.0.14/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/olekukonko/tablewriter v0.0.5 h1:P2Ga83D34wi1o9J6Wh1mRuqd4mF/x/lgBS7N7AbDhec=\ngithub.com/olekukonko/tablewriter v0.0.5/go.mod h1:hPp6KlRPjbx+hW8ykQs1w3UBbZlj6HuIJcUGPhkA7kY=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.4 h1:8TfxU8dW6PdqD27gjM8MVNuicgxIjxpm4K7x4jp8sis=\ngithub.com/rivo/uniseg v0.4.4/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngo.mongodb.org/mongo-driver v1.17.2 h1:gvZyk8352qSfzyZ2UMWcpDpMSGEr1eqE4T793SqyhzM=\ngo.mongodb.org/mongo-driver v1.17.2/go.mod h1:Hy04i7O2kC4RS06ZrhPRqj/u4DTYkFDAAccj+rVKqgQ=\ngolang.org/x/net v0.34.0 h1:Mb7Mrk043xzHgnRM88suvJFwzVrRfHEHJEl5/71CKw0=\ngolang.org/x/net v0.34.0/go.mod h1:di0qlW3YNM5oh6GqDGQr92MyTozJPmybPK4Ev/Gm31k=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngoogle.golang.org/protobuf v1.36.2 h1:R8FeyR1/eLmkutZOM5CWghmo5itiG9z0ktFlTVLuTmU=\ngoogle.golang.org/protobuf v1.36.2/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\n"
        },
        {
          "name": "images",
          "type": "tree",
          "content": null
        },
        {
          "name": "protocol",
          "type": "tree",
          "content": null
        },
        {
          "name": "readme-cn.md",
          "type": "blob",
          "size": 3.4501953125,
          "content": "# tproxy\n\n[English](readme.md) | 简体中文 | [日本語](readme-ja.md)\n\n[![Go](https://github.com/kevwan/tproxy/workflows/Go/badge.svg?branch=main)](https://github.com/kevwan/tproxy/actions)\n[![Go Report Card](https://goreportcard.com/badge/github.com/kevwan/tproxy)](https://goreportcard.com/report/github.com/kevwan/tproxy)\n[![Release](https://img.shields.io/github/v/release/kevwan/tproxy.svg?style=flat-square)](https://github.com/kevwan/tproxy)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n<a href=\"https://www.buymeacoffee.com/kevwan\" target=\"_blank\"><img src=\"https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png\" alt=\"Buy Me A Coffee\" style=\"height: 60px !important;width: 217px !important;\" ></a>\n\n## 为啥写这个工具\n\n当我在做后端开发或者写 [go-zero](https://github.com/zeromicro/go-zero) 的时候，经常会需要监控网络连接，分析请求内容。比如：\n1. 分析 gRPC 连接何时连接、何时重连\n2. 分析 MySQL 连接池，当前多少连接，连接的生命周期是什么策略\n3. 也可以用来观察和分析任何 TCP 连接\n\n## 安装\n\n```shell\n$ GOPROXY=https://goproxy.cn/,direct go install github.com/kevwan/tproxy@latest\n```\n\n或者使用 docker 镜像：\n\n```shell\n$ docker run --rm -it -p <listen-port>:<listen-port> -p <remote-port>:<remote-port> kevinwan/tproxy:v1 tproxy -l 0.0.0.0 -p <listen-port> -r host.docker.internal:<remote-port>\n```\n\narm64 系统:\n\n```shell\n$ docker run --rm -it -p <listen-port>:<listen-port> -p <remote-port>:<remote-port> kevinwan/tproxy:v1-arm64 tproxy -l 0.0.0.0 -p <listen-port> -r host.docker.internal:<remote-port>\n```\n\nWindows:\n\n```shell\n$ scoop install tproxy\n```\n\n## 用法\n\n```shell\n$ tproxy --help\nUsage of tproxy:\n  -d duration\n    \tthe delay to relay packets\n  -down int\n    \tDownward speed limit(bytes/second)\n  -l string\n    \tLocal address to listen on (default \"localhost\")\n  -p int\n    \tLocal port to listen on, default to pick a random port\n  -q\tQuiet mode, only prints connection open/close and stats, default false\n  -r string\n    \tRemote address (host:port) to connect\n  -s\tEnable statistics\n  -t string\n    \tThe type of protocol, currently support http2, grpc, redis and mongodb\n  -up int\n    \tUpward speed limit(bytes/second)\n```\n\n## 示例\n\n### 分析 gRPC 连接\n\n```shell\n$ tproxy -p 8088 -r localhost:8081 -t grpc -d 100ms\n```\n\n- 侦听在 localhost 和 8088 端口\n- 重定向请求到 `localhost:8081`\n- 识别数据包格式为 gRPC\n- 数据包延迟100毫秒\n\n<img width=\"579\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/181794530-5b25f75f-0c1a-4477-8021-56946903830a.png\">\n\n### 分析 MySQL 连接\n\n```shell\n$ tproxy -p 3307 -r localhost:3306\n```\n\n<img width=\"600\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/173970130-944e4265-8ba6-4d2e-b091-1f6a5de81070.png\">\n\n### 查看网络状况（重传率和RTT）\n\n```shell\n$ tproxy -p 3307 -r remotehost:3306 -s -q\n```\n\n<img width=\"548\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/180252614-7cf4d1f9-9ba8-4aa4-a964-6f37cf991749.png\">\n\n### 查看连接池（总连接数、最大并发连接数、最长生命周期等）\n\n```shell\n$ tproxy -p 3307 -r :3306 -s -q\n```\n\n<img width=\"404\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/236633144-9136e415-5763-4051-8c59-78ac363229ac.png\">\n\n## 欢迎 star！⭐\n\n如果你正在使用或者觉得这个项目对你有帮助，请 **star** 支持，感谢！\n"
        },
        {
          "name": "readme-ja.md",
          "type": "blob",
          "size": 3.8623046875,
          "content": "# tproxy\n\n[English](readme.md) | [简体中文](readme-cn.md) | 日本語\n\n[![Go](https://github.com/kevwan/tproxy/workflows/Go/badge.svg?branch=main)](https://github.com/kevwan/tproxy/actions)\n[![Go Report Card](https://goreportcard.com/badge/github.com/kevwan/tproxy)](https://goreportcard.com/report/github.com/kevwan/tproxy)\n[![Release](https://img.shields.io/github/v/release/kevwan/tproxy.svg?style=flat-square)](https://github.com/kevwan/tproxy)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n<a href=\"https://www.buymeacoffee.com/kevwan\" target=\"_blank\"><img src=\"https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png\" alt=\"Buy Me A Coffee\" style=\"height: 60px !important;width: 217px !important;\" ></a>\n\n## なぜこのツールを書いたのか\n\nバックエンドサービスを開発し、[go-zero](https://github.com/zeromicro/go-zero)を書くとき、ネットワークトラフィックを監視する必要がよくあります。例えば：\n1. gRPC接続の監視、接続のタイミングと再接続のタイミング\n2. MySQL接続プールの監視、接続数とライフタイムポリシーの把握\n3. 任意のTCP接続のリアルタイム監視\n\n## インストール\n\n```shell\n$ go install github.com/kevwan/tproxy@latest\n```\n\nまたは、dockerイメージを使用します：\n\n```shell\n$ docker run --rm -it -p <listen-port>:<listen-port> -p <remote-port>:<remote-port> kevinwan/tproxy:v1 tproxy -l 0.0.0.0 -p <listen-port> -r host.docker.internal:<remote-port>\n```\n\narm64の場合：\n\n```shell\n$ docker run --rm -it -p <listen-port>:<listen-port> -p <remote-port>:<remote-port> kevinwan/tproxy:v1-arm64 tproxy -l 0.0.0.0 -p <listen-port> -r host.docker.internal:<remote-port>\n```\n\nWindowsの場合、[scoop](https://scoop.sh/)を使用できます：\n\n```shell\n$ scoop install tproxy\n```\n\n## 使用方法\n\n```shell\n$ tproxy --help\nUsage of tproxy:\n  -d duration\n    \tパケットを中継する遅延時間\n  -down int\n    \t下り速度制限（バイト/秒）\n  -l string\n    \tリッスンするローカルアドレス（デフォルトは \"localhost\"）\n  -p int\n    \tリッスンするローカルポート、デフォルトはランダムポート\n  -q\t静音モード、接続の開閉と統計のみを表示、デフォルトはfalse\n  -r string\n    \t接続するリモートアドレス（ホスト：ポート）\n  -s\t統計を有効にする\n  -t string\n    \tプロトコルの種類、現在サポートされているのはhttp2、grpc、redis、mongodb\n  -up int\n    \t上り速度制限（バイト/秒）\n```\n\n## 例\n\n### gRPC接続の監視\n\n```shell\n$ tproxy -p 8088 -r localhost:8081 -t grpc -d 100ms\n```\n\n- localhostとポート8088でリッスン\n- トラフィックを`localhost:8081`にリダイレクト\n- プロトコルタイプをgRPCに設定\n- 各パケットの遅延時間を100msに設定\n\n<img width=\"579\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/181794530-5b25f75f-0c1a-4477-8021-56946903830a.png\">\n\n### MySQL接続の監視\n\n```shell\n$ tproxy -p 3307 -r localhost:3306\n```\n\n<img width=\"600\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/173970130-944e4265-8ba6-4d2e-b091-1f6a5de81070.png\">\n\n### 接続の信頼性の確認（再送率とRTT）\n\n```shell\n$ tproxy -p 3307 -r remotehost:3306 -s -q\n```\n\n<img width=\"548\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/180252614-7cf4d1f9-9ba8-4aa4-a964-6f37cf991749.png\">\n\n### 接続プールの動作を学ぶ\n\n```shell\n$ tproxy -p 3307 -r localhost:3306 -q -s\n```\n\n<img width=\"404\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/236633144-9136e415-5763-4051-8c59-78ac363229ac.png\">\n\n## スターを付けてください！ ⭐\n\nこのプロジェクトが気に入ったり、使用している場合は、**スター**を付けてください。ありがとうございます！\n"
        },
        {
          "name": "readme.md",
          "type": "blob",
          "size": 3.4404296875,
          "content": "# tproxy\n\nEnglish | [简体中文](readme-cn.md) | [日本語](readme-ja.md)\n\n[![Go](https://github.com/kevwan/tproxy/workflows/Go/badge.svg?branch=main)](https://github.com/kevwan/tproxy/actions)\n[![Go Report Card](https://goreportcard.com/badge/github.com/kevwan/tproxy)](https://goreportcard.com/report/github.com/kevwan/tproxy)\n[![Release](https://img.shields.io/github/v/release/kevwan/tproxy.svg?style=flat-square)](https://github.com/kevwan/tproxy)\n[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)\n\n<a href=\"https://www.buymeacoffee.com/kevwan\" target=\"_blank\"><img src=\"https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png\" alt=\"Buy Me A Coffee\" style=\"height: 60px !important;width: 217px !important;\" ></a>\n\n## Why I wrote this tool\n\nWhen I develop backend services and write [go-zero](https://github.com/zeromicro/go-zero), I often need to monitor the network traffic. For example:\n1. monitoring gRPC connections, when to connect and when to reconnect\n2. monitoring MySQL connection pools, how many connections and figure out the lifetime policy\n3. monitoring any TCP connections on the fly\n\n## Installation\n\n```shell\n$ go install github.com/kevwan/tproxy@latest\n```\n\nOr use docker images:\n\n```shell\n$ docker run --rm -it -p <listen-port>:<listen-port> -p <remote-port>:<remote-port> kevinwan/tproxy:v1 tproxy -l 0.0.0.0 -p <listen-port> -r host.docker.internal:<remote-port>\n```\n\nFor arm64:\n\n```shell\n$ docker run --rm -it -p <listen-port>:<listen-port> -p <remote-port>:<remote-port> kevinwan/tproxy:v1-arm64 tproxy -l 0.0.0.0 -p <listen-port> -r host.docker.internal:<remote-port>\n```\n\nOn Windows, you can use [scoop](https://scoop.sh/):\n\n```shell\n$ scoop install tproxy\n```\n\n## Usages\n\n```shell\n$ tproxy --help\nUsage of tproxy:\n  -d duration\n    \tthe delay to relay packets\n  -down int\n    \tDownward speed limit(bytes/second)\n  -l string\n    \tLocal address to listen on (default \"localhost\")\n  -p int\n    \tLocal port to listen on, default to pick a random port\n  -q\tQuiet mode, only prints connection open/close and stats, default false\n  -r string\n    \tRemote address (host:port) to connect\n  -s\tEnable statistics\n  -t string\n    \tThe type of protocol, currently support http2, grpc, redis and mongodb\n  -up int\n    \tUpward speed limit(bytes/second)\n```\n\n## Examples\n\n### Monitor gRPC connections\n\n```shell\n$ tproxy -p 8088 -r localhost:8081 -t grpc -d 100ms\n```\n\n- listen on localhost and port 8088\n- redirect the traffic to `localhost:8081`\n- protocol type to be gRPC\n- delay 100ms for each packets\n\n<img width=\"579\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/181794530-5b25f75f-0c1a-4477-8021-56946903830a.png\">\n\n### Monitor MySQL connections\n\n```shell\n$ tproxy -p 3307 -r localhost:3306\n```\n\n<img width=\"600\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/173970130-944e4265-8ba6-4d2e-b091-1f6a5de81070.png\">\n\n### Check the connection reliability (Retrans rate and RTT)\n\n```shell\n$ tproxy -p 3307 -r remotehost:3306 -s -q\n```\n\n<img width=\"548\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/180252614-7cf4d1f9-9ba8-4aa4-a964-6f37cf991749.png\">\n\n### Learn the connection pool behaviors\n\n```shell\n$ tproxy -p 3307 -r localhost:3306 -q -s\n```\n\n<img width=\"404\" alt=\"image\" src=\"https://user-images.githubusercontent.com/1918356/236633144-9136e415-5763-4051-8c59-78ac363229ac.png\">\n\n## Give a Star! ⭐\n\nIf you like or are using this project, please give it a **star**. Thanks!\n"
        },
        {
          "name": "settings.go",
          "type": "blob",
          "size": 0.67578125,
          "content": "package main\n\nimport \"time\"\n\ntype Settings struct {\n\tRemote    string\n\tLocalHost string\n\tLocalPort int\n\tDelay     time.Duration\n\tProtocol  string\n\tStat      bool\n\tQuiet     bool\n\tUpLimit   int64\n\tDownLimit int64\n}\n\nfunc saveSettings(localHost string, localPort int, remote string, delay time.Duration,\n\tprotocol string, stat, quiet bool, upLimit, downLimit int64) {\n\tif localHost != \"\" {\n\t\tsettings.LocalHost = localHost\n\t}\n\tif localPort != 0 {\n\t\tsettings.LocalPort = localPort\n\t}\n\tif remote != \"\" {\n\t\tsettings.Remote = remote\n\t}\n\tsettings.Delay = delay\n\tsettings.Protocol = protocol\n\tsettings.Stat = stat\n\tsettings.Quiet = quiet\n\tsettings.UpLimit = upLimit\n\tsettings.DownLimit = downLimit\n}\n"
        },
        {
          "name": "stat+polyfill.go",
          "type": "blob",
          "size": 0.3203125,
          "content": "//go:build !linux\n\npackage main\n\nimport (\n\t\"net\"\n\t\"time\"\n)\n\ntype StatPrinter struct{}\n\nfunc NewStatPrinter(_ time.Duration) Stater {\n\treturn StatPrinter{}\n}\n\nfunc (p StatPrinter) AddConn(_ string, _ *net.TCPConn) {\n}\n\nfunc (p StatPrinter) DelConn(_ string) {\n}\n\nfunc (p StatPrinter) Start() {\n}\n\nfunc (p StatPrinter) Stop() {\n}\n"
        },
        {
          "name": "stat.go",
          "type": "blob",
          "size": 1.3349609375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"os/signal\"\n\t\"syscall\"\n\t\"time\"\n)\n\ntype (\n\tStater interface {\n\t\tAddConn(key string, conn *net.TCPConn)\n\t\tDelConn(key string)\n\t\tStart()\n\t\tStop()\n\t}\n\n\tcompositeStater struct {\n\t\tstaters []Stater\n\t}\n)\n\nfunc NewStater(staters ...Stater) Stater {\n\tstat := compositeStater{\n\t\tstaters: append([]Stater(nil), staters...),\n\t}\n\n\tgo func() {\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, os.Interrupt, syscall.SIGTERM)\n\n\t\tfor sig := range c {\n\t\t\tsignal.Stop(c)\n\t\t\tstat.Stop()\n\n\t\t\tp, err := os.FindProcess(syscall.Getpid())\n\t\t\tif err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t\tos.Exit(0)\n\t\t\t}\n\n\t\t\tif err := p.Signal(sig); err != nil {\n\t\t\t\tfmt.Println(err)\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn stat\n}\n\nfunc (c compositeStater) AddConn(key string, conn *net.TCPConn) {\n\tfor _, s := range c.staters {\n\t\ts.AddConn(key, conn)\n\t}\n}\n\nfunc (c compositeStater) DelConn(key string) {\n\tfor _, s := range c.staters {\n\t\ts.DelConn(key)\n\t}\n}\n\nfunc (c compositeStater) Start() {\n\tfor _, s := range c.staters {\n\t\ts.Start()\n\t}\n}\n\nfunc (c compositeStater) Stop() {\n\tfor _, s := range c.staters {\n\t\ts.Stop()\n\t}\n}\n\ntype NilPrinter struct{}\n\nfunc NewNilPrinter(_ time.Duration) Stater {\n\treturn NilPrinter{}\n}\n\nfunc (p NilPrinter) AddConn(_ string, _ *net.TCPConn) {\n}\n\nfunc (p NilPrinter) DelConn(_ string) {\n}\n\nfunc (p NilPrinter) Start() {\n}\n\nfunc (p NilPrinter) Stop() {\n}\n"
        },
        {
          "name": "stat_linux.go",
          "type": "blob",
          "size": 1.9384765625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"sort\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/kevwan/tproxy/display\"\n\t\"github.com/olekukonko/tablewriter\"\n)\n\ntype StatPrinter struct {\n\tduration time.Duration\n\tconns    map[string]*net.TCPConn\n\tprev     map[string]*TcpInfo\n\tlock     sync.RWMutex\n}\n\nfunc NewStatPrinter(duration time.Duration) Stater {\n\tif !settings.Stat {\n\t\treturn NilPrinter{}\n\t}\n\n\treturn &StatPrinter{\n\t\tduration: duration,\n\t\tconns:    make(map[string]*net.TCPConn),\n\t}\n}\n\nfunc (p *StatPrinter) AddConn(key string, conn *net.TCPConn) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tp.conns[key] = conn\n}\n\nfunc (p *StatPrinter) DelConn(key string) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\tdelete(p.conns, key)\n}\n\nfunc (p *StatPrinter) Start() {\n\tticker := time.NewTicker(p.duration)\n\tdefer ticker.Stop()\n\n\tfor range ticker.C {\n\t\tp.print()\n\t}\n}\n\nfunc (p *StatPrinter) Stop() {\n\tp.print()\n}\n\nfunc (p *StatPrinter) buildRows() [][]string {\n\tvar keys []string\n\tinfos := make(map[string]*TcpInfo)\n\tp.lock.RLock()\n\tprev := p.prev\n\tfor k, v := range p.conns {\n\t\tinfo, err := GetTcpInfo(v)\n\t\tif err != nil {\n\t\t\tdisplay.PrintfWithTime(\"GetTcpInfo: %v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tkeys = append(keys, k)\n\t\tinfos[k] = info\n\t}\n\tp.prev = infos\n\tp.lock.RUnlock()\n\n\tvar rows [][]string\n\tnow := time.Now().Format(display.TimeFormat)\n\tsort.Strings(keys)\n\tfor _, k := range keys {\n\t\tv, ok := infos[k]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar rate string\n\t\tpinfo, ok := prev[k]\n\t\tif ok {\n\t\t\trate = fmt.Sprintf(\"%.2f\", GetRetransRate(pinfo, v))\n\t\t} else {\n\t\t\trate = \"-\"\n\t\t}\n\t\trtt, rttv := v.GetRTT()\n\t\trows = append(rows, []string{now, k, rate, fmt.Sprint(rtt), fmt.Sprint(rttv)})\n\t}\n\n\treturn rows\n}\n\nfunc (p *StatPrinter) print() {\n\trows := p.buildRows()\n\tif len(rows) == 0 {\n\t\treturn\n\t}\n\n\ttable := tablewriter.NewWriter(os.Stdout)\n\ttable.SetHeader([]string{\"Timestamp\", \"Connection\", \"RetransRate(%)\", \"RTT(ms)\", \"RTT/Variance(ms)\"})\n\ttable.SetBorder(false)\n\ttable.AppendBulk(rows)\n\ttable.Render()\n\tfmt.Println()\n}\n"
        },
        {
          "name": "tcpstat_linux.go",
          "type": "blob",
          "size": 3.822265625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nconst lostRateThreshold = 1e-6\n\ntype TcpInfo struct {\n\tState         uint8  `json:\"state\"`\n\tCAState       uint8  `json:\"ca_state\"`\n\tRetransmits   uint8  `json:\"retransmits\"`\n\tProbes        uint8  `json:\"probes\"`\n\tBackoff       uint8  `json:\"backoff\"`\n\tOptions       uint8  `json:\"options\"`\n\tWScale        uint8  `json:\"w_scale\"`\n\tAppLimited    uint8  `json:\"app_limited\"`\n\tRTO           uint32 `json:\"rto\"`\n\tATO           uint32 `json:\"ato\"`\n\tSndMSS        uint32 `json:\"snd_mss\"`\n\tRcvMSS        uint32 `json:\"rcv_mss\"`\n\tUnacked       uint32 `json:\"unacked\"`\n\tSacked        uint32 `json:\"sacked\"`\n\tLost          uint32 `json:\"lost\"`\n\tRetrans       uint32 `json:\"retrans\"`\n\tFackets       uint32 `json:\"f_ackets\"`\n\tLastDataSent  uint32 `json:\"last_data_sent\"`\n\tLastAckSent   uint32 `json:\"last_ack_sent\"`\n\tLastDataRecv  uint32 `json:\"last_data_recv\"`\n\tLastAckRecv   uint32 `json:\"last_ack_recv\"`\n\tPathMTU       uint32 `json:\"p_mtu\"`\n\tRcvSsThresh   uint32 `json:\"rcv_ss_thresh\"`\n\tRTT           uint32 `json:\"rtt\"`\n\tRTTVar        uint32 `json:\"rtt_var\"`\n\tSndSsThresh   uint32 `json:\"snd_ss_thresh\"`\n\tSndCwnd       uint32 `json:\"snd_cwnd\"`\n\tAdvMSS        uint32 `json:\"adv_mss\"`\n\tReordering    uint32 `json:\"reordering\"`\n\tRcvRTT        uint32 `json:\"rcv_rtt\"`\n\tRcvSpace      uint32 `json:\"rcv_space\"`\n\tTotalRetrans  uint32 `json:\"total_retrans\"`\n\tPacingRate    int64  `json:\"pacing_rate\"`\n\tMaxPacingRate int64  `json:\"max_pacing_rate\"`\n\tBytesAcked    int64  `json:\"bytes_acked\"`\n\tBytesReceived int64  `json:\"bytes_received\"`\n\tSegsOut       int32  `json:\"segs_out\"`\n\tSegsIn        int32  `json:\"segs_in\"` // RFC4898 tcpEStatsPerfSegsIn\n\tNotSentBytes  uint32 `json:\"notsent_bytes\"`\n\tMinRTT        uint32 `json:\"min_rtt\"`\n\tDataSegsIn    uint32 `json:\"data_segs_in\"`  // RFC4898 tcpEStatsDataSegsIn\n\tDataSegsOut   uint32 `json:\"data_segs_out\"` // RFC4898 tcpEStatsDataSegsOut\n\tDeliveryRate  int64  `json:\"delivery_rate\"`\n\tBusyTime      int64  `json:\"busy_time\"`       // Time (usec) busy sending data\n\tRWndLimited   int64  `json:\"r_wnd_limited\"`   // Time (usec) limited by receive window\n\tSndBufLimited int64  `json:\"snd_buf_limited\"` // Time (usec) limited by send buffer\n\tDelivered     uint32 `json:\"delivered\"`\n\tDeliveredCE   uint32 `json:\"delivered_ce\"`\n\tBytesSent     int64  `json:\"bytes_sent\"`    // RFC4898 tcpEStatsPerfHCDataOctetsOut\n\tBytesRetrans  int64  `json:\"bytes_retrans\"` // RFC4898 tcpEStatsPerfOctetsRetrans\n\tDSackDups     uint32 `json:\"d_sack_dups\"`   // RFC4898 tcpEStatsStackDSACKDups\n\tReordSeen     uint32 `json:\"reord_seen\"`    // reordering events seen\n}\n\nfunc GetTcpInfo(tcpConn *net.TCPConn) (*TcpInfo, error) {\n\trawConn, err := tcpConn.SyscallConn()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting raw connection. error: %v\", err)\n\t}\n\n\ttcpInfo := TcpInfo{}\n\tsize := unsafe.Sizeof(tcpInfo)\n\n\tvar errno syscall.Errno\n\terr = rawConn.Control(func(fd uintptr) {\n\t\t_, _, errno = syscall.Syscall6(syscall.SYS_GETSOCKOPT, fd, syscall.SOL_TCP, syscall.TCP_INFO,\n\t\t\tuintptr(unsafe.Pointer(&tcpInfo)), uintptr(unsafe.Pointer(&size)), 0)\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"conn control failed, error: %v\", err)\n\t}\n\tif errno != 0 {\n\t\treturn nil, fmt.Errorf(\"syscall failed, errno: %d\", errno)\n\t}\n\n\treturn &tcpInfo, nil\n}\n\n// GetRetransRate returns the percent of lost packets.\nfunc GetRetransRate(preTi, ti *TcpInfo) float64 {\n\tif preTi == nil {\n\t\treturn 0\n\t}\n\n\tbytesDelta := ti.BytesSent - preTi.BytesSent\n\tvar lostRate float64\n\tif bytesDelta != 0 {\n\t\tlostRate = 100 * float64(ti.BytesRetrans-preTi.BytesRetrans) / float64(bytesDelta)\n\t\tif lostRate < lostRateThreshold {\n\t\t\tlostRate = 0\n\t\t}\n\t}\n\tif lostRate < 0 {\n\t\treturn 0\n\t} else if lostRate > 1 {\n\t\treturn 1\n\t}\n\n\treturn lostRate\n}\n\n// GetRTT returns Round Trip Time in milliseconds.\nfunc (ti *TcpInfo) GetRTT() (uint32, uint32) {\n\treturn ti.RTT / 1000, ti.RTTVar / 1000\n}\n"
        },
        {
          "name": "tproxy.go",
          "type": "blob",
          "size": 1.291015625,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/fatih/color\"\n)\n\nvar settings Settings\n\nfunc main() {\n\tvar (\n\t\tlocalPort = flag.Int(\"p\", 0, \"Local port to listen on, default to pick a random port\")\n\t\tlocalHost = flag.String(\"l\", \"localhost\", \"Local address to listen on\")\n\t\tremote    = flag.String(\"r\", \"\", \"Remote address (host:port) to connect\")\n\t\tdelay     = flag.Duration(\"d\", 0, \"the delay to relay packets\")\n\t\tprotocol  = flag.String(\"t\", \"\", \"The type of protocol, currently support http2, grpc, mysql, redis, mongodb and mqtt\")\n\t\tstat      = flag.Bool(\"s\", false, \"Enable statistics\")\n\t\tquiet     = flag.Bool(\"q\", false, \"Quiet mode, only prints connection open/close and stats, default false\")\n\t\tupLimit   = flag.Int64(\"up\", 0, \"Upward speed limit(bytes/second)\")\n\t\tdownLimit = flag.Int64(\"down\", 0, \"Downward speed limit(bytes/second)\")\n\t)\n\n\tif len(os.Args) <= 1 {\n\t\tflag.Usage()\n\t\treturn\n\t}\n\n\tflag.Parse()\n\tsaveSettings(*localHost, *localPort, *remote, *delay, *protocol, *stat, *quiet, *upLimit, *downLimit)\n\n\tif len(settings.Remote) == 0 {\n\t\tfmt.Fprintln(os.Stderr, color.HiRedString(\"[x] Remote target required\"))\n\t\tflag.PrintDefaults()\n\t\tos.Exit(1)\n\t}\n\n\tif err := startListener(); err != nil {\n\t\tfmt.Fprintln(os.Stderr, color.HiRedString(\"[x] Failed to start listener: %v\", err))\n\t\tos.Exit(1)\n\t}\n}\n"
        }
      ]
    }
  ]
}