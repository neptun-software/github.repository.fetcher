{
  "metadata": {
    "timestamp": 1736566615900,
    "page": 172,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjE4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "Jeiwan/blockchain_go",
      "stars": 4201,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0107421875,
          "content": "*.db\n*.dat\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.6259765625,
          "content": "# Blockchain in Go\n\nA blockchain implementation in Go, as described in these articles:\n\n1. [Basic Prototype](https://jeiwan.net/posts/building-blockchain-in-go-part-1/)\n2. [Proof-of-Work](https://jeiwan.net/posts/building-blockchain-in-go-part-2/)\n3. [Persistence and CLI](https://jeiwan.net/posts/building-blockchain-in-go-part-3/)\n4. [Transactions 1](https://jeiwan.net/posts/building-blockchain-in-go-part-4/)\n5. [Addresses](https://jeiwan.net/posts/building-blockchain-in-go-part-5/)\n6. [Transactions 2](https://jeiwan.net/posts/building-blockchain-in-go-part-6/)\n7. [Network](https://jeiwan.net/posts/building-blockchain-in-go-part-7/)\n"
        },
        {
          "name": "base58.go",
          "type": "blob",
          "size": 1.029296875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"math/big\"\n)\n\nvar b58Alphabet = []byte(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\")\n\n// Base58Encode encodes a byte array to Base58\nfunc Base58Encode(input []byte) []byte {\n\tvar result []byte\n\n\tx := big.NewInt(0).SetBytes(input)\n\n\tbase := big.NewInt(int64(len(b58Alphabet)))\n\tzero := big.NewInt(0)\n\tmod := &big.Int{}\n\n\tfor x.Cmp(zero) != 0 {\n\t\tx.DivMod(x, base, mod)\n\t\tresult = append(result, b58Alphabet[mod.Int64()])\n\t}\n\n\t// https://en.bitcoin.it/wiki/Base58Check_encoding#Version_bytes\n\tif input[0] == 0x00 {\n\t\tresult = append(result, b58Alphabet[0])\n\t}\n\n\tReverseBytes(result)\n\n\treturn result\n}\n\n// Base58Decode decodes Base58-encoded data\nfunc Base58Decode(input []byte) []byte {\n\tresult := big.NewInt(0)\n\n\tfor _, b := range input {\n\t\tcharIndex := bytes.IndexByte(b58Alphabet, b)\n\t\tresult.Mul(result, big.NewInt(58))\n\t\tresult.Add(result, big.NewInt(int64(charIndex)))\n\t}\n\n\tdecoded := result.Bytes()\n\n\tif input[0] == b58Alphabet[0] {\n\t\tdecoded = append([]byte{0x00}, decoded...)\n\t}\n\n\treturn decoded\n}\n"
        },
        {
          "name": "base58_test.go",
          "type": "blob",
          "size": 0.5634765625,
          "content": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"log\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestBase58(t *testing.T) {\n\trawHash := \"00010966776006953D5567439E5E39F86A0D273BEED61967F6\"\n\thash, err := hex.DecodeString(rawHash)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tencoded := Base58Encode(hash)\n\tassert.Equal(t, \"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM\", string(encoded))\n\n\tdecoded := Base58Decode([]byte(\"16UwLL9Risc3QfPqBUvKofHmBQ7wMtjvM\"))\n\tassert.Equal(t, strings.ToLower(\"00010966776006953D5567439E5E39F86A0D273BEED61967F6\"), hex.EncodeToString(decoded))\n}\n"
        },
        {
          "name": "block.go",
          "type": "blob",
          "size": 1.4853515625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"log\"\n\t\"time\"\n)\n\n// Block represents a block in the blockchain\ntype Block struct {\n\tTimestamp     int64\n\tTransactions  []*Transaction\n\tPrevBlockHash []byte\n\tHash          []byte\n\tNonce         int\n\tHeight        int\n}\n\n// NewBlock creates and returns Block\nfunc NewBlock(transactions []*Transaction, prevBlockHash []byte, height int) *Block {\n\tblock := &Block{time.Now().Unix(), transactions, prevBlockHash, []byte{}, 0, height}\n\tpow := NewProofOfWork(block)\n\tnonce, hash := pow.Run()\n\n\tblock.Hash = hash[:]\n\tblock.Nonce = nonce\n\n\treturn block\n}\n\n// NewGenesisBlock creates and returns genesis Block\nfunc NewGenesisBlock(coinbase *Transaction) *Block {\n\treturn NewBlock([]*Transaction{coinbase}, []byte{}, 0)\n}\n\n// HashTransactions returns a hash of the transactions in the block\nfunc (b *Block) HashTransactions() []byte {\n\tvar transactions [][]byte\n\n\tfor _, tx := range b.Transactions {\n\t\ttransactions = append(transactions, tx.Serialize())\n\t}\n\tmTree := NewMerkleTree(transactions)\n\n\treturn mTree.RootNode.Data\n}\n\n// Serialize serializes the block\nfunc (b *Block) Serialize() []byte {\n\tvar result bytes.Buffer\n\tencoder := gob.NewEncoder(&result)\n\n\terr := encoder.Encode(b)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn result.Bytes()\n}\n\n// DeserializeBlock deserializes a block\nfunc DeserializeBlock(d []byte) *Block {\n\tvar block Block\n\n\tdecoder := gob.NewDecoder(bytes.NewReader(d))\n\terr := decoder.Decode(&block)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn &block\n}\n"
        },
        {
          "name": "blockchain.go",
          "type": "blob",
          "size": 6.9306640625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"encoding/hex\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nconst dbFile = \"blockchain_%s.db\"\nconst blocksBucket = \"blocks\"\nconst genesisCoinbaseData = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\"\n\n// Blockchain implements interactions with a DB\ntype Blockchain struct {\n\ttip []byte\n\tdb  *bolt.DB\n}\n\n// CreateBlockchain creates a new blockchain DB\nfunc CreateBlockchain(address, nodeID string) *Blockchain {\n\tdbFile := fmt.Sprintf(dbFile, nodeID)\n\tif dbExists(dbFile) {\n\t\tfmt.Println(\"Blockchain already exists.\")\n\t\tos.Exit(1)\n\t}\n\n\tvar tip []byte\n\n\tcbtx := NewCoinbaseTX(address, genesisCoinbaseData)\n\tgenesis := NewGenesisBlock(cbtx)\n\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tb, err := tx.CreateBucket([]byte(blocksBucket))\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\terr = b.Put(genesis.Hash, genesis.Serialize())\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\terr = b.Put([]byte(\"l\"), genesis.Hash)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t\ttip = genesis.Hash\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tbc := Blockchain{tip, db}\n\n\treturn &bc\n}\n\n// NewBlockchain creates a new Blockchain with genesis Block\nfunc NewBlockchain(nodeID string) *Blockchain {\n\tdbFile := fmt.Sprintf(dbFile, nodeID)\n\tif dbExists(dbFile) == false {\n\t\tfmt.Println(\"No existing blockchain found. Create one first.\")\n\t\tos.Exit(1)\n\t}\n\n\tvar tip []byte\n\tdb, err := bolt.Open(dbFile, 0600, nil)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\t\ttip = b.Get([]byte(\"l\"))\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tbc := Blockchain{tip, db}\n\n\treturn &bc\n}\n\n// AddBlock saves the block into the blockchain\nfunc (bc *Blockchain) AddBlock(block *Block) {\n\terr := bc.db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\t\tblockInDb := b.Get(block.Hash)\n\n\t\tif blockInDb != nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tblockData := block.Serialize()\n\t\terr := b.Put(block.Hash, blockData)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\tlastHash := b.Get([]byte(\"l\"))\n\t\tlastBlockData := b.Get(lastHash)\n\t\tlastBlock := DeserializeBlock(lastBlockData)\n\n\t\tif block.Height > lastBlock.Height {\n\t\t\terr = b.Put([]byte(\"l\"), block.Hash)\n\t\t\tif err != nil {\n\t\t\t\tlog.Panic(err)\n\t\t\t}\n\t\t\tbc.tip = block.Hash\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n}\n\n// FindTransaction finds a transaction by its ID\nfunc (bc *Blockchain) FindTransaction(ID []byte) (Transaction, error) {\n\tbci := bc.Iterator()\n\n\tfor {\n\t\tblock := bci.Next()\n\n\t\tfor _, tx := range block.Transactions {\n\t\t\tif bytes.Compare(tx.ID, ID) == 0 {\n\t\t\t\treturn *tx, nil\n\t\t\t}\n\t\t}\n\n\t\tif len(block.PrevBlockHash) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn Transaction{}, errors.New(\"Transaction is not found\")\n}\n\n// FindUTXO finds all unspent transaction outputs and returns transactions with spent outputs removed\nfunc (bc *Blockchain) FindUTXO() map[string]TXOutputs {\n\tUTXO := make(map[string]TXOutputs)\n\tspentTXOs := make(map[string][]int)\n\tbci := bc.Iterator()\n\n\tfor {\n\t\tblock := bci.Next()\n\n\t\tfor _, tx := range block.Transactions {\n\t\t\ttxID := hex.EncodeToString(tx.ID)\n\n\t\tOutputs:\n\t\t\tfor outIdx, out := range tx.Vout {\n\t\t\t\t// Was the output spent?\n\t\t\t\tif spentTXOs[txID] != nil {\n\t\t\t\t\tfor _, spentOutIdx := range spentTXOs[txID] {\n\t\t\t\t\t\tif spentOutIdx == outIdx {\n\t\t\t\t\t\t\tcontinue Outputs\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\touts := UTXO[txID]\n\t\t\t\touts.Outputs = append(outs.Outputs, out)\n\t\t\t\tUTXO[txID] = outs\n\t\t\t}\n\n\t\t\tif tx.IsCoinbase() == false {\n\t\t\t\tfor _, in := range tx.Vin {\n\t\t\t\t\tinTxID := hex.EncodeToString(in.Txid)\n\t\t\t\t\tspentTXOs[inTxID] = append(spentTXOs[inTxID], in.Vout)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(block.PrevBlockHash) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn UTXO\n}\n\n// Iterator returns a BlockchainIterat\nfunc (bc *Blockchain) Iterator() *BlockchainIterator {\n\tbci := &BlockchainIterator{bc.tip, bc.db}\n\n\treturn bci\n}\n\n// GetBestHeight returns the height of the latest block\nfunc (bc *Blockchain) GetBestHeight() int {\n\tvar lastBlock Block\n\n\terr := bc.db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\t\tlastHash := b.Get([]byte(\"l\"))\n\t\tblockData := b.Get(lastHash)\n\t\tlastBlock = *DeserializeBlock(blockData)\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn lastBlock.Height\n}\n\n// GetBlock finds a block by its hash and returns it\nfunc (bc *Blockchain) GetBlock(blockHash []byte) (Block, error) {\n\tvar block Block\n\n\terr := bc.db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\n\t\tblockData := b.Get(blockHash)\n\n\t\tif blockData == nil {\n\t\t\treturn errors.New(\"Block is not found.\")\n\t\t}\n\n\t\tblock = *DeserializeBlock(blockData)\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn block, err\n\t}\n\n\treturn block, nil\n}\n\n// GetBlockHashes returns a list of hashes of all the blocks in the chain\nfunc (bc *Blockchain) GetBlockHashes() [][]byte {\n\tvar blocks [][]byte\n\tbci := bc.Iterator()\n\n\tfor {\n\t\tblock := bci.Next()\n\n\t\tblocks = append(blocks, block.Hash)\n\n\t\tif len(block.PrevBlockHash) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn blocks\n}\n\n// MineBlock mines a new block with the provided transactions\nfunc (bc *Blockchain) MineBlock(transactions []*Transaction) *Block {\n\tvar lastHash []byte\n\tvar lastHeight int\n\n\tfor _, tx := range transactions {\n\t\t// TODO: ignore transaction if it's not valid\n\t\tif bc.VerifyTransaction(tx) != true {\n\t\t\tlog.Panic(\"ERROR: Invalid transaction\")\n\t\t}\n\t}\n\n\terr := bc.db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\t\tlastHash = b.Get([]byte(\"l\"))\n\n\t\tblockData := b.Get(lastHash)\n\t\tblock := DeserializeBlock(blockData)\n\n\t\tlastHeight = block.Height\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tnewBlock := NewBlock(transactions, lastHash, lastHeight+1)\n\n\terr = bc.db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\t\terr := b.Put(newBlock.Hash, newBlock.Serialize())\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\terr = b.Put([]byte(\"l\"), newBlock.Hash)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\tbc.tip = newBlock.Hash\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn newBlock\n}\n\n// SignTransaction signs inputs of a Transaction\nfunc (bc *Blockchain) SignTransaction(tx *Transaction, privKey ecdsa.PrivateKey) {\n\tprevTXs := make(map[string]Transaction)\n\n\tfor _, vin := range tx.Vin {\n\t\tprevTX, err := bc.FindTransaction(vin.Txid)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t\tprevTXs[hex.EncodeToString(prevTX.ID)] = prevTX\n\t}\n\n\ttx.Sign(privKey, prevTXs)\n}\n\n// VerifyTransaction verifies transaction input signatures\nfunc (bc *Blockchain) VerifyTransaction(tx *Transaction) bool {\n\tif tx.IsCoinbase() {\n\t\treturn true\n\t}\n\n\tprevTXs := make(map[string]Transaction)\n\n\tfor _, vin := range tx.Vin {\n\t\tprevTX, err := bc.FindTransaction(vin.Txid)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t\tprevTXs[hex.EncodeToString(prevTX.ID)] = prevTX\n\t}\n\n\treturn tx.Verify(prevTXs)\n}\n\nfunc dbExists(dbFile string) bool {\n\tif _, err := os.Stat(dbFile); os.IsNotExist(err) {\n\t\treturn false\n\t}\n\n\treturn true\n}\n"
        },
        {
          "name": "blockchain_iterator.go",
          "type": "blob",
          "size": 0.5751953125,
          "content": "package main\n\nimport (\n\t\"log\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\n// BlockchainIterator is used to iterate over blockchain blocks\ntype BlockchainIterator struct {\n\tcurrentHash []byte\n\tdb          *bolt.DB\n}\n\n// Next returns next block starting from the tip\nfunc (i *BlockchainIterator) Next() *Block {\n\tvar block *Block\n\n\terr := i.db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(blocksBucket))\n\t\tencodedBlock := b.Get(i.currentHash)\n\t\tblock = DeserializeBlock(encodedBlock)\n\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\ti.currentHash = block.PrevBlockHash\n\n\treturn block\n}\n"
        },
        {
          "name": "cli.go",
          "type": "blob",
          "size": 4.0966796875,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"os\"\n)\n\n// CLI responsible for processing command line arguments\ntype CLI struct{}\n\nfunc (cli *CLI) printUsage() {\n\tfmt.Println(\"Usage:\")\n\tfmt.Println(\"  createblockchain -address ADDRESS - Create a blockchain and send genesis block reward to ADDRESS\")\n\tfmt.Println(\"  createwallet - Generates a new key-pair and saves it into the wallet file\")\n\tfmt.Println(\"  getbalance -address ADDRESS - Get balance of ADDRESS\")\n\tfmt.Println(\"  listaddresses - Lists all addresses from the wallet file\")\n\tfmt.Println(\"  printchain - Print all the blocks of the blockchain\")\n\tfmt.Println(\"  reindexutxo - Rebuilds the UTXO set\")\n\tfmt.Println(\"  send -from FROM -to TO -amount AMOUNT -mine - Send AMOUNT of coins from FROM address to TO. Mine on the same node, when -mine is set.\")\n\tfmt.Println(\"  startnode -miner ADDRESS - Start a node with ID specified in NODE_ID env. var. -miner enables mining\")\n}\n\nfunc (cli *CLI) validateArgs() {\n\tif len(os.Args) < 2 {\n\t\tcli.printUsage()\n\t\tos.Exit(1)\n\t}\n}\n\n// Run parses command line arguments and processes commands\nfunc (cli *CLI) Run() {\n\tcli.validateArgs()\n\n\tnodeID := os.Getenv(\"NODE_ID\")\n\tif nodeID == \"\" {\n\t\tfmt.Printf(\"NODE_ID env. var is not set!\")\n\t\tos.Exit(1)\n\t}\n\n\tgetBalanceCmd := flag.NewFlagSet(\"getbalance\", flag.ExitOnError)\n\tcreateBlockchainCmd := flag.NewFlagSet(\"createblockchain\", flag.ExitOnError)\n\tcreateWalletCmd := flag.NewFlagSet(\"createwallet\", flag.ExitOnError)\n\tlistAddressesCmd := flag.NewFlagSet(\"listaddresses\", flag.ExitOnError)\n\tprintChainCmd := flag.NewFlagSet(\"printchain\", flag.ExitOnError)\n\treindexUTXOCmd := flag.NewFlagSet(\"reindexutxo\", flag.ExitOnError)\n\tsendCmd := flag.NewFlagSet(\"send\", flag.ExitOnError)\n\tstartNodeCmd := flag.NewFlagSet(\"startnode\", flag.ExitOnError)\n\n\tgetBalanceAddress := getBalanceCmd.String(\"address\", \"\", \"The address to get balance for\")\n\tcreateBlockchainAddress := createBlockchainCmd.String(\"address\", \"\", \"The address to send genesis block reward to\")\n\tsendFrom := sendCmd.String(\"from\", \"\", \"Source wallet address\")\n\tsendTo := sendCmd.String(\"to\", \"\", \"Destination wallet address\")\n\tsendAmount := sendCmd.Int(\"amount\", 0, \"Amount to send\")\n\tsendMine := sendCmd.Bool(\"mine\", false, \"Mine immediately on the same node\")\n\tstartNodeMiner := startNodeCmd.String(\"miner\", \"\", \"Enable mining mode and send reward to ADDRESS\")\n\n\tswitch os.Args[1] {\n\tcase \"getbalance\":\n\t\terr := getBalanceCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"createblockchain\":\n\t\terr := createBlockchainCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"createwallet\":\n\t\terr := createWalletCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"listaddresses\":\n\t\terr := listAddressesCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"printchain\":\n\t\terr := printChainCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"reindexutxo\":\n\t\terr := reindexUTXOCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"send\":\n\t\terr := sendCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tcase \"startnode\":\n\t\terr := startNodeCmd.Parse(os.Args[2:])\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\tdefault:\n\t\tcli.printUsage()\n\t\tos.Exit(1)\n\t}\n\n\tif getBalanceCmd.Parsed() {\n\t\tif *getBalanceAddress == \"\" {\n\t\t\tgetBalanceCmd.Usage()\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcli.getBalance(*getBalanceAddress, nodeID)\n\t}\n\n\tif createBlockchainCmd.Parsed() {\n\t\tif *createBlockchainAddress == \"\" {\n\t\t\tcreateBlockchainCmd.Usage()\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcli.createBlockchain(*createBlockchainAddress, nodeID)\n\t}\n\n\tif createWalletCmd.Parsed() {\n\t\tcli.createWallet(nodeID)\n\t}\n\n\tif listAddressesCmd.Parsed() {\n\t\tcli.listAddresses(nodeID)\n\t}\n\n\tif printChainCmd.Parsed() {\n\t\tcli.printChain(nodeID)\n\t}\n\n\tif reindexUTXOCmd.Parsed() {\n\t\tcli.reindexUTXO(nodeID)\n\t}\n\n\tif sendCmd.Parsed() {\n\t\tif *sendFrom == \"\" || *sendTo == \"\" || *sendAmount <= 0 {\n\t\t\tsendCmd.Usage()\n\t\t\tos.Exit(1)\n\t\t}\n\n\t\tcli.send(*sendFrom, *sendTo, *sendAmount, nodeID, *sendMine)\n\t}\n\n\tif startNodeCmd.Parsed() {\n\t\tnodeID := os.Getenv(\"NODE_ID\")\n\t\tif nodeID == \"\" {\n\t\t\tstartNodeCmd.Usage()\n\t\t\tos.Exit(1)\n\t\t}\n\t\tcli.startNode(nodeID, *startNodeMiner)\n\t}\n}\n"
        },
        {
          "name": "cli_createblockchain.go",
          "type": "blob",
          "size": 0.30078125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc (cli *CLI) createBlockchain(address, nodeID string) {\n\tif !ValidateAddress(address) {\n\t\tlog.Panic(\"ERROR: Address is not valid\")\n\t}\n\tbc := CreateBlockchain(address, nodeID)\n\tdefer bc.db.Close()\n\n\tUTXOSet := UTXOSet{bc}\n\tUTXOSet.Reindex()\n\n\tfmt.Println(\"Done!\")\n}\n"
        },
        {
          "name": "cli_createwallet.go",
          "type": "blob",
          "size": 0.2158203125,
          "content": "package main\n\nimport \"fmt\"\n\nfunc (cli *CLI) createWallet(nodeID string) {\n\twallets, _ := NewWallets(nodeID)\n\taddress := wallets.CreateWallet()\n\twallets.SaveToFile(nodeID)\n\n\tfmt.Printf(\"Your new address: %s\\n\", address)\n}\n"
        },
        {
          "name": "cli_getbalance.go",
          "type": "blob",
          "size": 0.494140625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc (cli *CLI) getBalance(address, nodeID string) {\n\tif !ValidateAddress(address) {\n\t\tlog.Panic(\"ERROR: Address is not valid\")\n\t}\n\tbc := NewBlockchain(nodeID)\n\tUTXOSet := UTXOSet{bc}\n\tdefer bc.db.Close()\n\n\tbalance := 0\n\tpubKeyHash := Base58Decode([]byte(address))\n\tpubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]\n\tUTXOs := UTXOSet.FindUTXO(pubKeyHash)\n\n\tfor _, out := range UTXOs {\n\t\tbalance += out.Value\n\t}\n\n\tfmt.Printf(\"Balance of '%s': %d\\n\", address, balance)\n}\n"
        },
        {
          "name": "cli_listaddress.go",
          "type": "blob",
          "size": 0.2568359375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc (cli *CLI) listAddresses(nodeID string) {\n\twallets, err := NewWallets(nodeID)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\taddresses := wallets.GetAddresses()\n\n\tfor _, address := range addresses {\n\t\tfmt.Println(address)\n\t}\n}\n"
        },
        {
          "name": "cli_printchain.go",
          "type": "blob",
          "size": 0.578125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc (cli *CLI) printChain(nodeID string) {\n\tbc := NewBlockchain(nodeID)\n\tdefer bc.db.Close()\n\n\tbci := bc.Iterator()\n\n\tfor {\n\t\tblock := bci.Next()\n\n\t\tfmt.Printf(\"============ Block %x ============\\n\", block.Hash)\n\t\tfmt.Printf(\"Height: %d\\n\", block.Height)\n\t\tfmt.Printf(\"Prev. block: %x\\n\", block.PrevBlockHash)\n\t\tpow := NewProofOfWork(block)\n\t\tfmt.Printf(\"PoW: %s\\n\\n\", strconv.FormatBool(pow.Validate()))\n\t\tfor _, tx := range block.Transactions {\n\t\t\tfmt.Println(tx)\n\t\t}\n\t\tfmt.Printf(\"\\n\\n\")\n\n\t\tif len(block.PrevBlockHash) == 0 {\n\t\t\tbreak\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "cli_reindexutxo.go",
          "type": "blob",
          "size": 0.2529296875,
          "content": "package main\n\nimport \"fmt\"\n\nfunc (cli *CLI) reindexUTXO(nodeID string) {\n\tbc := NewBlockchain(nodeID)\n\tUTXOSet := UTXOSet{bc}\n\tUTXOSet.Reindex()\n\n\tcount := UTXOSet.CountTransactions()\n\tfmt.Printf(\"Done! There are %d transactions in the UTXO set.\\n\", count)\n}\n"
        },
        {
          "name": "cli_send.go",
          "type": "blob",
          "size": 0.72265625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc (cli *CLI) send(from, to string, amount int, nodeID string, mineNow bool) {\n\tif !ValidateAddress(from) {\n\t\tlog.Panic(\"ERROR: Sender address is not valid\")\n\t}\n\tif !ValidateAddress(to) {\n\t\tlog.Panic(\"ERROR: Recipient address is not valid\")\n\t}\n\n\tbc := NewBlockchain(nodeID)\n\tUTXOSet := UTXOSet{bc}\n\tdefer bc.db.Close()\n\n\twallets, err := NewWallets(nodeID)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\twallet := wallets.GetWallet(from)\n\n\ttx := NewUTXOTransaction(&wallet, to, amount, &UTXOSet)\n\n\tif mineNow {\n\t\tcbTx := NewCoinbaseTX(from, \"\")\n\t\ttxs := []*Transaction{cbTx, tx}\n\n\t\tnewBlock := bc.MineBlock(txs)\n\t\tUTXOSet.Update(newBlock)\n\t} else {\n\t\tsendTx(knownNodes[0], tx)\n\t}\n\n\tfmt.Println(\"Success!\")\n}\n"
        },
        {
          "name": "cli_startnode.go",
          "type": "blob",
          "size": 0.3623046875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n)\n\nfunc (cli *CLI) startNode(nodeID, minerAddress string) {\n\tfmt.Printf(\"Starting node %s\\n\", nodeID)\n\tif len(minerAddress) > 0 {\n\t\tif ValidateAddress(minerAddress) {\n\t\t\tfmt.Println(\"Mining is on. Address to receive rewards: \", minerAddress)\n\t\t} else {\n\t\t\tlog.Panic(\"Wrong miner address!\")\n\t\t}\n\t}\n\tStartServer(nodeID, minerAddress)\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 0.0537109375,
          "content": "package main\n\nfunc main() {\n\tcli := CLI{}\n\tcli.Run()\n}\n"
        },
        {
          "name": "merkle_tree.go",
          "type": "blob",
          "size": 1.2236328125,
          "content": "package main\n\nimport (\n\t\"crypto/sha256\"\n)\n\n// MerkleTree represent a Merkle tree\ntype MerkleTree struct {\n\tRootNode *MerkleNode\n}\n\n// MerkleNode represent a Merkle tree node\ntype MerkleNode struct {\n\tLeft  *MerkleNode\n\tRight *MerkleNode\n\tData  []byte\n}\n\n// NewMerkleTree creates a new Merkle tree from a sequence of data\nfunc NewMerkleTree(data [][]byte) *MerkleTree {\n\tvar nodes []MerkleNode\n\n\tif len(data)%2 != 0 {\n\t\tdata = append(data, data[len(data)-1])\n\t}\n\n\tfor _, datum := range data {\n\t\tnode := NewMerkleNode(nil, nil, datum)\n\t\tnodes = append(nodes, *node)\n\t}\n\n\tfor i := 0; i < len(data)/2; i++ {\n\t\tvar newLevel []MerkleNode\n\n\t\tfor j := 0; j < len(nodes); j += 2 {\n\t\t\tnode := NewMerkleNode(&nodes[j], &nodes[j+1], nil)\n\t\t\tnewLevel = append(newLevel, *node)\n\t\t}\n\n\t\tnodes = newLevel\n\t}\n\n\tmTree := MerkleTree{&nodes[0]}\n\n\treturn &mTree\n}\n\n// NewMerkleNode creates a new Merkle tree node\nfunc NewMerkleNode(left, right *MerkleNode, data []byte) *MerkleNode {\n\tmNode := MerkleNode{}\n\n\tif left == nil && right == nil {\n\t\thash := sha256.Sum256(data)\n\t\tmNode.Data = hash[:]\n\t} else {\n\t\tprevHashes := append(left.Data, right.Data...)\n\t\thash := sha256.Sum256(prevHashes)\n\t\tmNode.Data = hash[:]\n\t}\n\n\tmNode.Left = left\n\tmNode.Right = right\n\n\treturn &mNode\n}\n"
        },
        {
          "name": "merkle_tree_test.go",
          "type": "blob",
          "size": 1.541015625,
          "content": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewMerkleNode(t *testing.T) {\n\tdata := [][]byte{\n\t\t[]byte(\"node1\"),\n\t\t[]byte(\"node2\"),\n\t\t[]byte(\"node3\"),\n\t}\n\n\t// Level 1\n\n\tn1 := NewMerkleNode(nil, nil, data[0])\n\tn2 := NewMerkleNode(nil, nil, data[1])\n\tn3 := NewMerkleNode(nil, nil, data[2])\n\tn4 := NewMerkleNode(nil, nil, data[2])\n\n\t// Level 2\n\tn5 := NewMerkleNode(n1, n2, nil)\n\tn6 := NewMerkleNode(n3, n4, nil)\n\n\t// Level 3\n\tn7 := NewMerkleNode(n5, n6, nil)\n\n\tassert.Equal(\n\t\tt,\n\t\t\"64b04b718d8b7c5b6fd17f7ec221945c034cfce3be4118da33244966150c4bd4\",\n\t\thex.EncodeToString(n5.Data),\n\t\t\"Level 1 hash 1 is correct\",\n\t)\n\tassert.Equal(\n\t\tt,\n\t\t\"08bd0d1426f87a78bfc2f0b13eccdf6f5b58dac6b37a7b9441c1a2fab415d76c\",\n\t\thex.EncodeToString(n6.Data),\n\t\t\"Level 1 hash 2 is correct\",\n\t)\n\tassert.Equal(\n\t\tt,\n\t\t\"4e3e44e55926330ab6c31892f980f8bfd1a6e910ff1ebc3f778211377f35227e\",\n\t\thex.EncodeToString(n7.Data),\n\t\t\"Root hash is correct\",\n\t)\n}\n\nfunc TestNewMerkleTree(t *testing.T) {\n\tdata := [][]byte{\n\t\t[]byte(\"node1\"),\n\t\t[]byte(\"node2\"),\n\t\t[]byte(\"node3\"),\n\t}\n\t// Level 1\n\tn1 := NewMerkleNode(nil, nil, data[0])\n\tn2 := NewMerkleNode(nil, nil, data[1])\n\tn3 := NewMerkleNode(nil, nil, data[2])\n\tn4 := NewMerkleNode(nil, nil, data[2])\n\n\t// Level 2\n\tn5 := NewMerkleNode(n1, n2, nil)\n\tn6 := NewMerkleNode(n3, n4, nil)\n\n\t// Level 3\n\tn7 := NewMerkleNode(n5, n6, nil)\n\n\trootHash := fmt.Sprintf(\"%x\", n7.Data)\n\tmTree := NewMerkleTree(data)\n\n\tassert.Equal(t, rootHash, fmt.Sprintf(\"%x\", mTree.RootNode.Data), \"Merkle tree root hash is correct\")\n}\n"
        },
        {
          "name": "proofofwork.go",
          "type": "blob",
          "size": 1.4404296875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n)\n\nvar (\n\tmaxNonce = math.MaxInt64\n)\n\nconst targetBits = 16\n\n// ProofOfWork represents a proof-of-work\ntype ProofOfWork struct {\n\tblock  *Block\n\ttarget *big.Int\n}\n\n// NewProofOfWork builds and returns a ProofOfWork\nfunc NewProofOfWork(b *Block) *ProofOfWork {\n\ttarget := big.NewInt(1)\n\ttarget.Lsh(target, uint(256-targetBits))\n\n\tpow := &ProofOfWork{b, target}\n\n\treturn pow\n}\n\nfunc (pow *ProofOfWork) prepareData(nonce int) []byte {\n\tdata := bytes.Join(\n\t\t[][]byte{\n\t\t\tpow.block.PrevBlockHash,\n\t\t\tpow.block.HashTransactions(),\n\t\t\tIntToHex(pow.block.Timestamp),\n\t\t\tIntToHex(int64(targetBits)),\n\t\t\tIntToHex(int64(nonce)),\n\t\t},\n\t\t[]byte{},\n\t)\n\n\treturn data\n}\n\n// Run performs a proof-of-work\nfunc (pow *ProofOfWork) Run() (int, []byte) {\n\tvar hashInt big.Int\n\tvar hash [32]byte\n\tnonce := 0\n\n\tfmt.Printf(\"Mining a new block\")\n\tfor nonce < maxNonce {\n\t\tdata := pow.prepareData(nonce)\n\n\t\thash = sha256.Sum256(data)\n\t\tif math.Remainder(float64(nonce), 100000) == 0 {\n\t\t\tfmt.Printf(\"\\r%x\", hash)\n\t\t}\n\t\thashInt.SetBytes(hash[:])\n\n\t\tif hashInt.Cmp(pow.target) == -1 {\n\t\t\tbreak\n\t\t} else {\n\t\t\tnonce++\n\t\t}\n\t}\n\tfmt.Print(\"\\n\\n\")\n\n\treturn nonce, hash[:]\n}\n\n// Validate validates block's PoW\nfunc (pow *ProofOfWork) Validate() bool {\n\tvar hashInt big.Int\n\n\tdata := pow.prepareData(pow.block.Nonce)\n\thash := sha256.Sum256(data)\n\thashInt.SetBytes(hash[:])\n\n\tisValid := hashInt.Cmp(pow.target) == -1\n\n\treturn isValid\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 8.916015625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n)\n\nconst protocol = \"tcp\"\nconst nodeVersion = 1\nconst commandLength = 12\n\nvar nodeAddress string\nvar miningAddress string\nvar knownNodes = []string{\"localhost:3000\"}\nvar blocksInTransit = [][]byte{}\nvar mempool = make(map[string]Transaction)\n\ntype addr struct {\n\tAddrList []string\n}\n\ntype block struct {\n\tAddrFrom string\n\tBlock    []byte\n}\n\ntype getblocks struct {\n\tAddrFrom string\n}\n\ntype getdata struct {\n\tAddrFrom string\n\tType     string\n\tID       []byte\n}\n\ntype inv struct {\n\tAddrFrom string\n\tType     string\n\tItems    [][]byte\n}\n\ntype tx struct {\n\tAddFrom     string\n\tTransaction []byte\n}\n\ntype verzion struct {\n\tVersion    int\n\tBestHeight int\n\tAddrFrom   string\n}\n\nfunc commandToBytes(command string) []byte {\n\tvar bytes [commandLength]byte\n\n\tfor i, c := range command {\n\t\tbytes[i] = byte(c)\n\t}\n\n\treturn bytes[:]\n}\n\nfunc bytesToCommand(bytes []byte) string {\n\tvar command []byte\n\n\tfor _, b := range bytes {\n\t\tif b != 0x0 {\n\t\t\tcommand = append(command, b)\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"%s\", command)\n}\n\nfunc extractCommand(request []byte) []byte {\n\treturn request[:commandLength]\n}\n\nfunc requestBlocks() {\n\tfor _, node := range knownNodes {\n\t\tsendGetBlocks(node)\n\t}\n}\n\nfunc sendAddr(address string) {\n\tnodes := addr{knownNodes}\n\tnodes.AddrList = append(nodes.AddrList, nodeAddress)\n\tpayload := gobEncode(nodes)\n\trequest := append(commandToBytes(\"addr\"), payload...)\n\n\tsendData(address, request)\n}\n\nfunc sendBlock(addr string, b *Block) {\n\tdata := block{nodeAddress, b.Serialize()}\n\tpayload := gobEncode(data)\n\trequest := append(commandToBytes(\"block\"), payload...)\n\n\tsendData(addr, request)\n}\n\nfunc sendData(addr string, data []byte) {\n\tconn, err := net.Dial(protocol, addr)\n\tif err != nil {\n\t\tfmt.Printf(\"%s is not available\\n\", addr)\n\t\tvar updatedNodes []string\n\n\t\tfor _, node := range knownNodes {\n\t\t\tif node != addr {\n\t\t\t\tupdatedNodes = append(updatedNodes, node)\n\t\t\t}\n\t\t}\n\n\t\tknownNodes = updatedNodes\n\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t_, err = io.Copy(conn, bytes.NewReader(data))\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n}\n\nfunc sendInv(address, kind string, items [][]byte) {\n\tinventory := inv{nodeAddress, kind, items}\n\tpayload := gobEncode(inventory)\n\trequest := append(commandToBytes(\"inv\"), payload...)\n\n\tsendData(address, request)\n}\n\nfunc sendGetBlocks(address string) {\n\tpayload := gobEncode(getblocks{nodeAddress})\n\trequest := append(commandToBytes(\"getblocks\"), payload...)\n\n\tsendData(address, request)\n}\n\nfunc sendGetData(address, kind string, id []byte) {\n\tpayload := gobEncode(getdata{nodeAddress, kind, id})\n\trequest := append(commandToBytes(\"getdata\"), payload...)\n\n\tsendData(address, request)\n}\n\nfunc sendTx(addr string, tnx *Transaction) {\n\tdata := tx{nodeAddress, tnx.Serialize()}\n\tpayload := gobEncode(data)\n\trequest := append(commandToBytes(\"tx\"), payload...)\n\n\tsendData(addr, request)\n}\n\nfunc sendVersion(addr string, bc *Blockchain) {\n\tbestHeight := bc.GetBestHeight()\n\tpayload := gobEncode(verzion{nodeVersion, bestHeight, nodeAddress})\n\n\trequest := append(commandToBytes(\"version\"), payload...)\n\n\tsendData(addr, request)\n}\n\nfunc handleAddr(request []byte) {\n\tvar buff bytes.Buffer\n\tvar payload addr\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tknownNodes = append(knownNodes, payload.AddrList...)\n\tfmt.Printf(\"There are %d known nodes now!\\n\", len(knownNodes))\n\trequestBlocks()\n}\n\nfunc handleBlock(request []byte, bc *Blockchain) {\n\tvar buff bytes.Buffer\n\tvar payload block\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tblockData := payload.Block\n\tblock := DeserializeBlock(blockData)\n\n\tfmt.Println(\"Recevied a new block!\")\n\tbc.AddBlock(block)\n\n\tfmt.Printf(\"Added block %x\\n\", block.Hash)\n\n\tif len(blocksInTransit) > 0 {\n\t\tblockHash := blocksInTransit[0]\n\t\tsendGetData(payload.AddrFrom, \"block\", blockHash)\n\n\t\tblocksInTransit = blocksInTransit[1:]\n\t} else {\n\t\tUTXOSet := UTXOSet{bc}\n\t\tUTXOSet.Reindex()\n\t}\n}\n\nfunc handleInv(request []byte, bc *Blockchain) {\n\tvar buff bytes.Buffer\n\tvar payload inv\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tfmt.Printf(\"Recevied inventory with %d %s\\n\", len(payload.Items), payload.Type)\n\n\tif payload.Type == \"block\" {\n\t\tblocksInTransit = payload.Items\n\n\t\tblockHash := payload.Items[0]\n\t\tsendGetData(payload.AddrFrom, \"block\", blockHash)\n\n\t\tnewInTransit := [][]byte{}\n\t\tfor _, b := range blocksInTransit {\n\t\t\tif bytes.Compare(b, blockHash) != 0 {\n\t\t\t\tnewInTransit = append(newInTransit, b)\n\t\t\t}\n\t\t}\n\t\tblocksInTransit = newInTransit\n\t}\n\n\tif payload.Type == \"tx\" {\n\t\ttxID := payload.Items[0]\n\n\t\tif mempool[hex.EncodeToString(txID)].ID == nil {\n\t\t\tsendGetData(payload.AddrFrom, \"tx\", txID)\n\t\t}\n\t}\n}\n\nfunc handleGetBlocks(request []byte, bc *Blockchain) {\n\tvar buff bytes.Buffer\n\tvar payload getblocks\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tblocks := bc.GetBlockHashes()\n\tsendInv(payload.AddrFrom, \"block\", blocks)\n}\n\nfunc handleGetData(request []byte, bc *Blockchain) {\n\tvar buff bytes.Buffer\n\tvar payload getdata\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tif payload.Type == \"block\" {\n\t\tblock, err := bc.GetBlock([]byte(payload.ID))\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\n\t\tsendBlock(payload.AddrFrom, &block)\n\t}\n\n\tif payload.Type == \"tx\" {\n\t\ttxID := hex.EncodeToString(payload.ID)\n\t\ttx := mempool[txID]\n\n\t\tsendTx(payload.AddrFrom, &tx)\n\t\t// delete(mempool, txID)\n\t}\n}\n\nfunc handleTx(request []byte, bc *Blockchain) {\n\tvar buff bytes.Buffer\n\tvar payload tx\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\ttxData := payload.Transaction\n\ttx := DeserializeTransaction(txData)\n\tmempool[hex.EncodeToString(tx.ID)] = tx\n\n\tif nodeAddress == knownNodes[0] {\n\t\tfor _, node := range knownNodes {\n\t\t\tif node != nodeAddress && node != payload.AddFrom {\n\t\t\t\tsendInv(node, \"tx\", [][]byte{tx.ID})\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif len(mempool) >= 2 && len(miningAddress) > 0 {\n\t\tMineTransactions:\n\t\t\tvar txs []*Transaction\n\n\t\t\tfor id := range mempool {\n\t\t\t\ttx := mempool[id]\n\t\t\t\tif bc.VerifyTransaction(&tx) {\n\t\t\t\t\ttxs = append(txs, &tx)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(txs) == 0 {\n\t\t\t\tfmt.Println(\"All transactions are invalid! Waiting for new ones...\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tcbTx := NewCoinbaseTX(miningAddress, \"\")\n\t\t\ttxs = append(txs, cbTx)\n\n\t\t\tnewBlock := bc.MineBlock(txs)\n\t\t\tUTXOSet := UTXOSet{bc}\n\t\t\tUTXOSet.Reindex()\n\n\t\t\tfmt.Println(\"New block is mined!\")\n\n\t\t\tfor _, tx := range txs {\n\t\t\t\ttxID := hex.EncodeToString(tx.ID)\n\t\t\t\tdelete(mempool, txID)\n\t\t\t}\n\n\t\t\tfor _, node := range knownNodes {\n\t\t\t\tif node != nodeAddress {\n\t\t\t\t\tsendInv(node, \"block\", [][]byte{newBlock.Hash})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif len(mempool) > 0 {\n\t\t\t\tgoto MineTransactions\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc handleVersion(request []byte, bc *Blockchain) {\n\tvar buff bytes.Buffer\n\tvar payload verzion\n\n\tbuff.Write(request[commandLength:])\n\tdec := gob.NewDecoder(&buff)\n\terr := dec.Decode(&payload)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tmyBestHeight := bc.GetBestHeight()\n\tforeignerBestHeight := payload.BestHeight\n\n\tif myBestHeight < foreignerBestHeight {\n\t\tsendGetBlocks(payload.AddrFrom)\n\t} else if myBestHeight > foreignerBestHeight {\n\t\tsendVersion(payload.AddrFrom, bc)\n\t}\n\n\t// sendAddr(payload.AddrFrom)\n\tif !nodeIsKnown(payload.AddrFrom) {\n\t\tknownNodes = append(knownNodes, payload.AddrFrom)\n\t}\n}\n\nfunc handleConnection(conn net.Conn, bc *Blockchain) {\n\trequest, err := ioutil.ReadAll(conn)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tcommand := bytesToCommand(request[:commandLength])\n\tfmt.Printf(\"Received %s command\\n\", command)\n\n\tswitch command {\n\tcase \"addr\":\n\t\thandleAddr(request)\n\tcase \"block\":\n\t\thandleBlock(request, bc)\n\tcase \"inv\":\n\t\thandleInv(request, bc)\n\tcase \"getblocks\":\n\t\thandleGetBlocks(request, bc)\n\tcase \"getdata\":\n\t\thandleGetData(request, bc)\n\tcase \"tx\":\n\t\thandleTx(request, bc)\n\tcase \"version\":\n\t\thandleVersion(request, bc)\n\tdefault:\n\t\tfmt.Println(\"Unknown command!\")\n\t}\n\n\tconn.Close()\n}\n\n// StartServer starts a node\nfunc StartServer(nodeID, minerAddress string) {\n\tnodeAddress = fmt.Sprintf(\"localhost:%s\", nodeID)\n\tminingAddress = minerAddress\n\tln, err := net.Listen(protocol, nodeAddress)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tdefer ln.Close()\n\n\tbc := NewBlockchain(nodeID)\n\n\tif nodeAddress != knownNodes[0] {\n\t\tsendVersion(knownNodes[0], bc)\n\t}\n\n\tfor {\n\t\tconn, err := ln.Accept()\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t\tgo handleConnection(conn, bc)\n\t}\n}\n\nfunc gobEncode(data interface{}) []byte {\n\tvar buff bytes.Buffer\n\n\tenc := gob.NewEncoder(&buff)\n\terr := enc.Encode(data)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn buff.Bytes()\n}\n\nfunc nodeIsKnown(addr string) bool {\n\tfor _, node := range knownNodes {\n\t\tif node == addr {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n"
        },
        {
          "name": "transaction.go",
          "type": "blob",
          "size": 5.7392578125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"math/big\"\n\t\"strings\"\n\n\t\"encoding/gob\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"log\"\n)\n\nconst subsidy = 10\n\n// Transaction represents a Bitcoin transaction\ntype Transaction struct {\n\tID   []byte\n\tVin  []TXInput\n\tVout []TXOutput\n}\n\n// IsCoinbase checks whether the transaction is coinbase\nfunc (tx Transaction) IsCoinbase() bool {\n\treturn len(tx.Vin) == 1 && len(tx.Vin[0].Txid) == 0 && tx.Vin[0].Vout == -1\n}\n\n// Serialize returns a serialized Transaction\nfunc (tx Transaction) Serialize() []byte {\n\tvar encoded bytes.Buffer\n\n\tenc := gob.NewEncoder(&encoded)\n\terr := enc.Encode(tx)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn encoded.Bytes()\n}\n\n// Hash returns the hash of the Transaction\nfunc (tx *Transaction) Hash() []byte {\n\tvar hash [32]byte\n\n\ttxCopy := *tx\n\ttxCopy.ID = []byte{}\n\n\thash = sha256.Sum256(txCopy.Serialize())\n\n\treturn hash[:]\n}\n\n// Sign signs each input of a Transaction\nfunc (tx *Transaction) Sign(privKey ecdsa.PrivateKey, prevTXs map[string]Transaction) {\n\tif tx.IsCoinbase() {\n\t\treturn\n\t}\n\n\tfor _, vin := range tx.Vin {\n\t\tif prevTXs[hex.EncodeToString(vin.Txid)].ID == nil {\n\t\t\tlog.Panic(\"ERROR: Previous transaction is not correct\")\n\t\t}\n\t}\n\n\ttxCopy := tx.TrimmedCopy()\n\n\tfor inID, vin := range txCopy.Vin {\n\t\tprevTx := prevTXs[hex.EncodeToString(vin.Txid)]\n\t\ttxCopy.Vin[inID].Signature = nil\n\t\ttxCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash\n\n\t\tdataToSign := fmt.Sprintf(\"%x\\n\", txCopy)\n\n\t\tr, s, err := ecdsa.Sign(rand.Reader, &privKey, []byte(dataToSign))\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\t\tsignature := append(r.Bytes(), s.Bytes()...)\n\n\t\ttx.Vin[inID].Signature = signature\n\t\ttxCopy.Vin[inID].PubKey = nil\n\t}\n}\n\n// String returns a human-readable representation of a transaction\nfunc (tx Transaction) String() string {\n\tvar lines []string\n\n\tlines = append(lines, fmt.Sprintf(\"--- Transaction %x:\", tx.ID))\n\n\tfor i, input := range tx.Vin {\n\n\t\tlines = append(lines, fmt.Sprintf(\"     Input %d:\", i))\n\t\tlines = append(lines, fmt.Sprintf(\"       TXID:      %x\", input.Txid))\n\t\tlines = append(lines, fmt.Sprintf(\"       Out:       %d\", input.Vout))\n\t\tlines = append(lines, fmt.Sprintf(\"       Signature: %x\", input.Signature))\n\t\tlines = append(lines, fmt.Sprintf(\"       PubKey:    %x\", input.PubKey))\n\t}\n\n\tfor i, output := range tx.Vout {\n\t\tlines = append(lines, fmt.Sprintf(\"     Output %d:\", i))\n\t\tlines = append(lines, fmt.Sprintf(\"       Value:  %d\", output.Value))\n\t\tlines = append(lines, fmt.Sprintf(\"       Script: %x\", output.PubKeyHash))\n\t}\n\n\treturn strings.Join(lines, \"\\n\")\n}\n\n// TrimmedCopy creates a trimmed copy of Transaction to be used in signing\nfunc (tx *Transaction) TrimmedCopy() Transaction {\n\tvar inputs []TXInput\n\tvar outputs []TXOutput\n\n\tfor _, vin := range tx.Vin {\n\t\tinputs = append(inputs, TXInput{vin.Txid, vin.Vout, nil, nil})\n\t}\n\n\tfor _, vout := range tx.Vout {\n\t\toutputs = append(outputs, TXOutput{vout.Value, vout.PubKeyHash})\n\t}\n\n\ttxCopy := Transaction{tx.ID, inputs, outputs}\n\n\treturn txCopy\n}\n\n// Verify verifies signatures of Transaction inputs\nfunc (tx *Transaction) Verify(prevTXs map[string]Transaction) bool {\n\tif tx.IsCoinbase() {\n\t\treturn true\n\t}\n\n\tfor _, vin := range tx.Vin {\n\t\tif prevTXs[hex.EncodeToString(vin.Txid)].ID == nil {\n\t\t\tlog.Panic(\"ERROR: Previous transaction is not correct\")\n\t\t}\n\t}\n\n\ttxCopy := tx.TrimmedCopy()\n\tcurve := elliptic.P256()\n\n\tfor inID, vin := range tx.Vin {\n\t\tprevTx := prevTXs[hex.EncodeToString(vin.Txid)]\n\t\ttxCopy.Vin[inID].Signature = nil\n\t\ttxCopy.Vin[inID].PubKey = prevTx.Vout[vin.Vout].PubKeyHash\n\n\t\tr := big.Int{}\n\t\ts := big.Int{}\n\t\tsigLen := len(vin.Signature)\n\t\tr.SetBytes(vin.Signature[:(sigLen / 2)])\n\t\ts.SetBytes(vin.Signature[(sigLen / 2):])\n\n\t\tx := big.Int{}\n\t\ty := big.Int{}\n\t\tkeyLen := len(vin.PubKey)\n\t\tx.SetBytes(vin.PubKey[:(keyLen / 2)])\n\t\ty.SetBytes(vin.PubKey[(keyLen / 2):])\n\n\t\tdataToVerify := fmt.Sprintf(\"%x\\n\", txCopy)\n\n\t\trawPubKey := ecdsa.PublicKey{Curve: curve, X: &x, Y: &y}\n\t\tif ecdsa.Verify(&rawPubKey, []byte(dataToVerify), &r, &s) == false {\n\t\t\treturn false\n\t\t}\n\t\ttxCopy.Vin[inID].PubKey = nil\n\t}\n\n\treturn true\n}\n\n// NewCoinbaseTX creates a new coinbase transaction\nfunc NewCoinbaseTX(to, data string) *Transaction {\n\tif data == \"\" {\n\t\trandData := make([]byte, 20)\n\t\t_, err := rand.Read(randData)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\tdata = fmt.Sprintf(\"%x\", randData)\n\t}\n\n\ttxin := TXInput{[]byte{}, -1, nil, []byte(data)}\n\ttxout := NewTXOutput(subsidy, to)\n\ttx := Transaction{nil, []TXInput{txin}, []TXOutput{*txout}}\n\ttx.ID = tx.Hash()\n\n\treturn &tx\n}\n\n// NewUTXOTransaction creates a new transaction\nfunc NewUTXOTransaction(wallet *Wallet, to string, amount int, UTXOSet *UTXOSet) *Transaction {\n\tvar inputs []TXInput\n\tvar outputs []TXOutput\n\n\tpubKeyHash := HashPubKey(wallet.PublicKey)\n\tacc, validOutputs := UTXOSet.FindSpendableOutputs(pubKeyHash, amount)\n\n\tif acc < amount {\n\t\tlog.Panic(\"ERROR: Not enough funds\")\n\t}\n\n\t// Build a list of inputs\n\tfor txid, outs := range validOutputs {\n\t\ttxID, err := hex.DecodeString(txid)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\tfor _, out := range outs {\n\t\t\tinput := TXInput{txID, out, nil, wallet.PublicKey}\n\t\t\tinputs = append(inputs, input)\n\t\t}\n\t}\n\n\t// Build a list of outputs\n\tfrom := fmt.Sprintf(\"%s\", wallet.GetAddress())\n\toutputs = append(outputs, *NewTXOutput(amount, to))\n\tif acc > amount {\n\t\toutputs = append(outputs, *NewTXOutput(acc-amount, from)) // a change\n\t}\n\n\ttx := Transaction{nil, inputs, outputs}\n\ttx.ID = tx.Hash()\n\tUTXOSet.Blockchain.SignTransaction(&tx, wallet.PrivateKey)\n\n\treturn &tx\n}\n\n// DeserializeTransaction deserializes a transaction\nfunc DeserializeTransaction(data []byte) Transaction {\n\tvar transaction Transaction\n\n\tdecoder := gob.NewDecoder(bytes.NewReader(data))\n\terr := decoder.Decode(&transaction)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn transaction\n}\n"
        },
        {
          "name": "transaction_input.go",
          "type": "blob",
          "size": 0.3671875,
          "content": "package main\n\nimport \"bytes\"\n\n// TXInput represents a transaction input\ntype TXInput struct {\n\tTxid      []byte\n\tVout      int\n\tSignature []byte\n\tPubKey    []byte\n}\n\n// UsesKey checks whether the address initiated the transaction\nfunc (in *TXInput) UsesKey(pubKeyHash []byte) bool {\n\tlockingHash := HashPubKey(in.PubKey)\n\n\treturn bytes.Compare(lockingHash, pubKeyHash) == 0\n}\n"
        },
        {
          "name": "transaction_output.go",
          "type": "blob",
          "size": 1.23046875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"log\"\n)\n\n// TXOutput represents a transaction output\ntype TXOutput struct {\n\tValue      int\n\tPubKeyHash []byte\n}\n\n// Lock signs the output\nfunc (out *TXOutput) Lock(address []byte) {\n\tpubKeyHash := Base58Decode(address)\n\tpubKeyHash = pubKeyHash[1 : len(pubKeyHash)-4]\n\tout.PubKeyHash = pubKeyHash\n}\n\n// IsLockedWithKey checks if the output can be used by the owner of the pubkey\nfunc (out *TXOutput) IsLockedWithKey(pubKeyHash []byte) bool {\n\treturn bytes.Compare(out.PubKeyHash, pubKeyHash) == 0\n}\n\n// NewTXOutput create a new TXOutput\nfunc NewTXOutput(value int, address string) *TXOutput {\n\ttxo := &TXOutput{value, nil}\n\ttxo.Lock([]byte(address))\n\n\treturn txo\n}\n\n// TXOutputs collects TXOutput\ntype TXOutputs struct {\n\tOutputs []TXOutput\n}\n\n// Serialize serializes TXOutputs\nfunc (outs TXOutputs) Serialize() []byte {\n\tvar buff bytes.Buffer\n\n\tenc := gob.NewEncoder(&buff)\n\terr := enc.Encode(outs)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn buff.Bytes()\n}\n\n// DeserializeOutputs deserializes TXOutputs\nfunc DeserializeOutputs(data []byte) TXOutputs {\n\tvar outputs TXOutputs\n\n\tdec := gob.NewDecoder(bytes.NewReader(data))\n\terr := dec.Decode(&outputs)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn outputs\n}\n"
        },
        {
          "name": "utils.go",
          "type": "blob",
          "size": 0.4375,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"log\"\n)\n\n// IntToHex converts an int64 to a byte array\nfunc IntToHex(num int64) []byte {\n\tbuff := new(bytes.Buffer)\n\terr := binary.Write(buff, binary.BigEndian, num)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn buff.Bytes()\n}\n\n// ReverseBytes reverses a byte array\nfunc ReverseBytes(data []byte) {\n\tfor i, j := 0, len(data)-1; i < j; i, j = i+1, j-1 {\n\t\tdata[i], data[j] = data[j], data[i]\n\t}\n}\n"
        },
        {
          "name": "utxo_set.go",
          "type": "blob",
          "size": 3.7353515625,
          "content": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"log\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nconst utxoBucket = \"chainstate\"\n\n// UTXOSet represents UTXO set\ntype UTXOSet struct {\n\tBlockchain *Blockchain\n}\n\n// FindSpendableOutputs finds and returns unspent outputs to reference in inputs\nfunc (u UTXOSet) FindSpendableOutputs(pubkeyHash []byte, amount int) (int, map[string][]int) {\n\tunspentOutputs := make(map[string][]int)\n\taccumulated := 0\n\tdb := u.Blockchain.db\n\n\terr := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(utxoBucket))\n\t\tc := b.Cursor()\n\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\ttxID := hex.EncodeToString(k)\n\t\t\touts := DeserializeOutputs(v)\n\n\t\t\tfor outIdx, out := range outs.Outputs {\n\t\t\t\tif out.IsLockedWithKey(pubkeyHash) && accumulated < amount {\n\t\t\t\t\taccumulated += out.Value\n\t\t\t\t\tunspentOutputs[txID] = append(unspentOutputs[txID], outIdx)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn accumulated, unspentOutputs\n}\n\n// FindUTXO finds UTXO for a public key hash\nfunc (u UTXOSet) FindUTXO(pubKeyHash []byte) []TXOutput {\n\tvar UTXOs []TXOutput\n\tdb := u.Blockchain.db\n\n\terr := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(utxoBucket))\n\t\tc := b.Cursor()\n\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\touts := DeserializeOutputs(v)\n\n\t\t\tfor _, out := range outs.Outputs {\n\t\t\t\tif out.IsLockedWithKey(pubKeyHash) {\n\t\t\t\t\tUTXOs = append(UTXOs, out)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn UTXOs\n}\n\n// CountTransactions returns the number of transactions in the UTXO set\nfunc (u UTXOSet) CountTransactions() int {\n\tdb := u.Blockchain.db\n\tcounter := 0\n\n\terr := db.View(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(utxoBucket))\n\t\tc := b.Cursor()\n\n\t\tfor k, _ := c.First(); k != nil; k, _ = c.Next() {\n\t\t\tcounter++\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\treturn counter\n}\n\n// Reindex rebuilds the UTXO set\nfunc (u UTXOSet) Reindex() {\n\tdb := u.Blockchain.db\n\tbucketName := []byte(utxoBucket)\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\terr := tx.DeleteBucket(bucketName)\n\t\tif err != nil && err != bolt.ErrBucketNotFound {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\t_, err = tx.CreateBucket(bucketName)\n\t\tif err != nil {\n\t\t\tlog.Panic(err)\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tUTXO := u.Blockchain.FindUTXO()\n\n\terr = db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket(bucketName)\n\n\t\tfor txID, outs := range UTXO {\n\t\t\tkey, err := hex.DecodeString(txID)\n\t\t\tif err != nil {\n\t\t\t\tlog.Panic(err)\n\t\t\t}\n\n\t\t\terr = b.Put(key, outs.Serialize())\n\t\t\tif err != nil {\n\t\t\t\tlog.Panic(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n}\n\n// Update updates the UTXO set with transactions from the Block\n// The Block is considered to be the tip of a blockchain\nfunc (u UTXOSet) Update(block *Block) {\n\tdb := u.Blockchain.db\n\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(utxoBucket))\n\n\t\tfor _, tx := range block.Transactions {\n\t\t\tif tx.IsCoinbase() == false {\n\t\t\t\tfor _, vin := range tx.Vin {\n\t\t\t\t\tupdatedOuts := TXOutputs{}\n\t\t\t\t\toutsBytes := b.Get(vin.Txid)\n\t\t\t\t\touts := DeserializeOutputs(outsBytes)\n\n\t\t\t\t\tfor outIdx, out := range outs.Outputs {\n\t\t\t\t\t\tif outIdx != vin.Vout {\n\t\t\t\t\t\t\tupdatedOuts.Outputs = append(updatedOuts.Outputs, out)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(updatedOuts.Outputs) == 0 {\n\t\t\t\t\t\terr := b.Delete(vin.Txid)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlog.Panic(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr := b.Put(vin.Txid, updatedOuts.Serialize())\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\tlog.Panic(err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnewOutputs := TXOutputs{}\n\t\t\tfor _, out := range tx.Vout {\n\t\t\t\tnewOutputs.Outputs = append(newOutputs.Outputs, out)\n\t\t\t}\n\n\t\t\terr := b.Put(tx.ID, newOutputs.Serialize())\n\t\t\tif err != nil {\n\t\t\t\tlog.Panic(err)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n}\n"
        },
        {
          "name": "wallet.go",
          "type": "blob",
          "size": 1.962890625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"log\"\n\n\t\"golang.org/x/crypto/ripemd160\"\n)\n\nconst version = byte(0x00)\nconst addressChecksumLen = 4\n\n// Wallet stores private and public keys\ntype Wallet struct {\n\tPrivateKey ecdsa.PrivateKey\n\tPublicKey  []byte\n}\n\n// NewWallet creates and returns a Wallet\nfunc NewWallet() *Wallet {\n\tprivate, public := newKeyPair()\n\twallet := Wallet{private, public}\n\n\treturn &wallet\n}\n\n// GetAddress returns wallet address\nfunc (w Wallet) GetAddress() []byte {\n\tpubKeyHash := HashPubKey(w.PublicKey)\n\n\tversionedPayload := append([]byte{version}, pubKeyHash...)\n\tchecksum := checksum(versionedPayload)\n\n\tfullPayload := append(versionedPayload, checksum...)\n\taddress := Base58Encode(fullPayload)\n\n\treturn address\n}\n\n// HashPubKey hashes public key\nfunc HashPubKey(pubKey []byte) []byte {\n\tpublicSHA256 := sha256.Sum256(pubKey)\n\n\tRIPEMD160Hasher := ripemd160.New()\n\t_, err := RIPEMD160Hasher.Write(publicSHA256[:])\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tpublicRIPEMD160 := RIPEMD160Hasher.Sum(nil)\n\n\treturn publicRIPEMD160\n}\n\n// ValidateAddress check if address if valid\nfunc ValidateAddress(address string) bool {\n\tpubKeyHash := Base58Decode([]byte(address))\n\tactualChecksum := pubKeyHash[len(pubKeyHash)-addressChecksumLen:]\n\tversion := pubKeyHash[0]\n\tpubKeyHash = pubKeyHash[1 : len(pubKeyHash)-addressChecksumLen]\n\ttargetChecksum := checksum(append([]byte{version}, pubKeyHash...))\n\n\treturn bytes.Compare(actualChecksum, targetChecksum) == 0\n}\n\n// Checksum generates a checksum for a public key\nfunc checksum(payload []byte) []byte {\n\tfirstSHA := sha256.Sum256(payload)\n\tsecondSHA := sha256.Sum256(firstSHA[:])\n\n\treturn secondSHA[:addressChecksumLen]\n}\n\nfunc newKeyPair() (ecdsa.PrivateKey, []byte) {\n\tcurve := elliptic.P256()\n\tprivate, err := ecdsa.GenerateKey(curve, rand.Reader)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\tpubKey := append(private.PublicKey.X.Bytes(), private.PublicKey.Y.Bytes()...)\n\n\treturn *private, pubKey\n}\n"
        },
        {
          "name": "wallets.go",
          "type": "blob",
          "size": 1.939453125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n)\n\nconst walletFile = \"wallet_%s.dat\"\n\n// Wallets stores a collection of wallets\ntype Wallets struct {\n\tWallets map[string]*Wallet\n}\n\n// NewWallets creates Wallets and fills it from a file if it exists\nfunc NewWallets(nodeID string) (*Wallets, error) {\n\twallets := Wallets{}\n\twallets.Wallets = make(map[string]*Wallet)\n\n\terr := wallets.LoadFromFile(nodeID)\n\n\treturn &wallets, err\n}\n\n// CreateWallet adds a Wallet to Wallets\nfunc (ws *Wallets) CreateWallet() string {\n\twallet := NewWallet()\n\taddress := fmt.Sprintf(\"%s\", wallet.GetAddress())\n\n\tws.Wallets[address] = wallet\n\n\treturn address\n}\n\n// GetAddresses returns an array of addresses stored in the wallet file\nfunc (ws *Wallets) GetAddresses() []string {\n\tvar addresses []string\n\n\tfor address := range ws.Wallets {\n\t\taddresses = append(addresses, address)\n\t}\n\n\treturn addresses\n}\n\n// GetWallet returns a Wallet by its address\nfunc (ws Wallets) GetWallet(address string) Wallet {\n\treturn *ws.Wallets[address]\n}\n\n// LoadFromFile loads wallets from the file\nfunc (ws *Wallets) LoadFromFile(nodeID string) error {\n\twalletFile := fmt.Sprintf(walletFile, nodeID)\n\tif _, err := os.Stat(walletFile); os.IsNotExist(err) {\n\t\treturn err\n\t}\n\n\tfileContent, err := ioutil.ReadFile(walletFile)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tvar wallets Wallets\n\tgob.Register(elliptic.P256())\n\tdecoder := gob.NewDecoder(bytes.NewReader(fileContent))\n\terr = decoder.Decode(&wallets)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\tws.Wallets = wallets.Wallets\n\n\treturn nil\n}\n\n// SaveToFile saves wallets to a file\nfunc (ws Wallets) SaveToFile(nodeID string) {\n\tvar content bytes.Buffer\n\twalletFile := fmt.Sprintf(walletFile, nodeID)\n\n\tgob.Register(elliptic.P256())\n\n\tencoder := gob.NewEncoder(&content)\n\terr := encoder.Encode(ws)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\n\terr = ioutil.WriteFile(walletFile, content.Bytes(), 0644)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n}\n"
        }
      ]
    }
  ]
}