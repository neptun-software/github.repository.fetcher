{
  "metadata": {
    "timestamp": 1736567365632,
    "page": 972,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "inconshreveable/go-update",
      "stars": 2174,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.5380859375,
          "content": "Copyright 2015 Alan Shreve\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.2802734375,
          "content": "# go-update: Build self-updating Go programs [![godoc reference](https://godoc.org/github.com/inconshreveable/go-update?status.png)](https://godoc.org/github.com/inconshreveable/go-update)\n\nPackage update provides functionality to implement secure, self-updating Go programs (or other single-file targets)\nA program can update itself by replacing its executable file with a new version.\n\nIt provides the flexibility to implement different updating user experiences\nlike auto-updating, or manual user-initiated updates. It also boasts\nadvanced features like binary patching and code signing verification.\n\nExample of updating from a URL:\n\n```go\nimport (\n    \"fmt\"\n    \"net/http\"\n\n    \"github.com/inconshreveable/go-update\"\n)\n\nfunc doUpdate(url string) error {\n    resp, err := http.Get(url)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n    err := update.Apply(resp.Body, update.Options{})\n    if err != nil {\n        // error handling\n    }\n    return err\n}\n```\n\n## Features\n\n- Cross platform support (Windows too!)\n- Binary patch application\n- Checksum verification\n- Code signing verification\n- Support for updating arbitrary files\n\n## [equinox.io](https://equinox.io)\n[equinox.io](https://equinox.io) is a complete ready-to-go updating solution built on top of go-update that provides:\n\n- Hosted updates\n- Update channels (stable, beta, nightly, ...)\n- Dynamically computed binary diffs\n- Automatic key generation and code\n- Release tooling with proper code signing\n- Update/download metrics\n\n## API Compatibility Promises\nThe master branch of `go-update` is *not* guaranteed to have a stable API over time. For any production application, you should vendor\nyour dependency on `go-update` with a tool like git submodules, [gb](http://getgb.io/) or [govendor](https://github.com/kardianos/govendor).\n\nThe `go-update` package makes the following promises about API compatibility:\n1. A list of all API-breaking changes will be documented in this README.\n1. `go-update` will strive for as few API-breaking changes as possible.\n\n## API Breaking Changes\n- **Sept 3, 2015**: The `Options` struct passed to `Apply` was changed to be passed by value instead of passed by pointer. Old API at `28de026`.\n- **Aug 9, 2015**: 2.0 API. Old API at `221d034` or `gopkg.in/inconshreveable/go-update.v0`.\n\n## License\nApache\n"
        },
        {
          "name": "apply.go",
          "type": "blob",
          "size": 9.1025390625,
          "content": "package update\n\nimport (\n\t\"bytes\"\n\t\"crypto\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/inconshreveable/go-update/internal/osext\"\n)\n\nvar (\n\topenFile = os.OpenFile\n)\n\n// Apply performs an update of the current executable (or opts.TargetFile, if set) with the contents of the given io.Reader.\n//\n// Apply performs the following actions to ensure a safe cross-platform update:\n//\n// 1. If configured, applies the contents of the update io.Reader as a binary patch.\n//\n// 2. If configured, computes the checksum of the new executable and verifies it matches.\n//\n// 3. If configured, verifies the signature with a public key.\n//\n// 4. Creates a new file, /path/to/.target.new with the TargetMode with the contents of the updated file\n//\n// 5. Renames /path/to/target to /path/to/.target.old\n//\n// 6. Renames /path/to/.target.new to /path/to/target\n//\n// 7. If the final rename is successful, deletes /path/to/.target.old, returns no error. On Windows,\n// the removal of /path/to/target.old always fails, so instead Apply hides the old file instead.\n//\n// 8. If the final rename fails, attempts to roll back by renaming /path/to/.target.old\n// back to /path/to/target.\n//\n// If the roll back operation fails, the file system is left in an inconsistent state (betweet steps 5 and 6) where\n// there is no new executable file and the old executable file could not be be moved to its original location. In this\n// case you should notify the user of the bad news and ask them to recover manually. Applications can determine whether\n// the rollback failed by calling RollbackError, see the documentation on that function for additional detail.\nfunc Apply(update io.Reader, opts Options) error {\n\t// validate\n\tverify := false\n\tswitch {\n\tcase opts.Signature != nil && opts.PublicKey != nil:\n\t\t// okay\n\t\tverify = true\n\tcase opts.Signature != nil:\n\t\treturn errors.New(\"no public key to verify signature with\")\n\tcase opts.PublicKey != nil:\n\t\treturn errors.New(\"No signature to verify with\")\n\t}\n\n\t// set defaults\n\tif opts.Hash == 0 {\n\t\topts.Hash = crypto.SHA256\n\t}\n\tif opts.Verifier == nil {\n\t\topts.Verifier = NewECDSAVerifier()\n\t}\n\tif opts.TargetMode == 0 {\n\t\topts.TargetMode = 0755\n\t}\n\n\t// get target path\n\tvar err error\n\topts.TargetPath, err = opts.getPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar newBytes []byte\n\tif opts.Patcher != nil {\n\t\tif newBytes, err = opts.applyPatch(update); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// no patch to apply, go on through\n\t\tif newBytes, err = ioutil.ReadAll(update); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// verify checksum if requested\n\tif opts.Checksum != nil {\n\t\tif err = opts.verifyChecksum(newBytes); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif verify {\n\t\tif err = opts.verifySignature(newBytes); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// get the directory the executable exists in\n\tupdateDir := filepath.Dir(opts.TargetPath)\n\tfilename := filepath.Base(opts.TargetPath)\n\n\t// Copy the contents of newbinary to a new executable file\n\tnewPath := filepath.Join(updateDir, fmt.Sprintf(\".%s.new\", filename))\n\tfp, err := openFile(newPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, opts.TargetMode)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fp.Close()\n\n\t_, err = io.Copy(fp, bytes.NewReader(newBytes))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// if we don't call fp.Close(), windows won't let us move the new executable\n\t// because the file will still be \"in use\"\n\tfp.Close()\n\n\t// this is where we'll move the executable to so that we can swap in the updated replacement\n\toldPath := opts.OldSavePath\n\tremoveOld := opts.OldSavePath == \"\"\n\tif removeOld {\n\t\toldPath = filepath.Join(updateDir, fmt.Sprintf(\".%s.old\", filename))\n\t}\n\n\t// delete any existing old exec file - this is necessary on Windows for two reasons:\n\t// 1. after a successful update, Windows can't remove the .old file because the process is still running\n\t// 2. windows rename operations fail if the destination file already exists\n\t_ = os.Remove(oldPath)\n\n\t// move the existing executable to a new file in the same directory\n\terr = os.Rename(opts.TargetPath, oldPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// move the new exectuable in to become the new program\n\terr = os.Rename(newPath, opts.TargetPath)\n\n\tif err != nil {\n\t\t// move unsuccessful\n\t\t//\n\t\t// The filesystem is now in a bad state. We have successfully\n\t\t// moved the existing binary to a new location, but we couldn't move the new\n\t\t// binary to take its place. That means there is no file where the current executable binary\n\t\t// used to be!\n\t\t// Try to rollback by restoring the old binary to its original path.\n\t\trerr := os.Rename(oldPath, opts.TargetPath)\n\t\tif rerr != nil {\n\t\t\treturn &rollbackErr{err, rerr}\n\t\t}\n\n\t\treturn err\n\t}\n\n\t// move successful, remove the old binary if needed\n\tif removeOld {\n\t\terrRemove := os.Remove(oldPath)\n\n\t\t// windows has trouble with removing old binaries, so hide it instead\n\t\tif errRemove != nil {\n\t\t\t_ = hideFile(oldPath)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// RollbackError takes an error value returned by Apply and returns the error, if any,\n// that occurred when attempting to roll back from a failed update. Applications should\n// always call this function on any non-nil errors returned by Apply.\n//\n// If no rollback was needed or if the rollback was successful, RollbackError returns nil,\n// otherwise it returns the error encountered when trying to roll back.\nfunc RollbackError(err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif rerr, ok := err.(*rollbackErr); ok {\n\t\treturn rerr.rollbackErr\n\t}\n\treturn nil\n}\n\ntype rollbackErr struct {\n\terror             // original error\n\trollbackErr error // error encountered while rolling back\n}\n\ntype Options struct {\n\t// TargetPath defines the path to the file to update.\n\t// The emptry string means 'the executable file of the running program'.\n\tTargetPath string\n\n\t// Create TargetPath replacement with this file mode. If zero, defaults to 0755.\n\tTargetMode os.FileMode\n\n\t// Checksum of the new binary to verify against. If nil, no checksum or signature verification is done.\n\tChecksum []byte\n\n\t// Public key to use for signature verification. If nil, no signature verification is done.\n\tPublicKey crypto.PublicKey\n\n\t// Signature to verify the updated file. If nil, no signature verification is done.\n\tSignature []byte\n\n\t// Pluggable signature verification algorithm. If nil, ECDSA is used.\n\tVerifier Verifier\n\n\t// Use this hash function to generate the checksum. If not set, SHA256 is used.\n\tHash crypto.Hash\n\n\t// If nil, treat the update as a complete replacement for the contents of the file at TargetPath.\n\t// If non-nil, treat the update contents as a patch and use this object to apply the patch.\n\tPatcher Patcher\n\n\t// Store the old executable file at this path after a successful update.\n\t// The empty string means the old executable file will be removed after the update.\n\tOldSavePath string\n}\n\n// CheckPermissions determines whether the process has the correct permissions to\n// perform the requested update. If the update can proceed, it returns nil, otherwise\n// it returns the error that would occur if an update were attempted.\nfunc (o *Options) CheckPermissions() error {\n\t// get the directory the file exists in\n\tpath, err := o.getPath()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfileDir := filepath.Dir(path)\n\tfileName := filepath.Base(path)\n\n\t// attempt to open a file in the file's directory\n\tnewPath := filepath.Join(fileDir, fmt.Sprintf(\".%s.new\", fileName))\n\tfp, err := openFile(newPath, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, o.TargetMode)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfp.Close()\n\n\t_ = os.Remove(newPath)\n\treturn nil\n}\n\n// SetPublicKeyPEM is a convenience method to set the PublicKey property\n// used for checking a completed update's signature by parsing a\n// Public Key formatted as PEM data.\nfunc (o *Options) SetPublicKeyPEM(pembytes []byte) error {\n\tblock, _ := pem.Decode(pembytes)\n\tif block == nil {\n\t\treturn errors.New(\"couldn't parse PEM data\")\n\t}\n\n\tpub, err := x509.ParsePKIXPublicKey(block.Bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\to.PublicKey = pub\n\treturn nil\n}\n\nfunc (o *Options) getPath() (string, error) {\n\tif o.TargetPath == \"\" {\n\t\treturn osext.Executable()\n\t} else {\n\t\treturn o.TargetPath, nil\n\t}\n}\n\nfunc (o *Options) applyPatch(patch io.Reader) ([]byte, error) {\n\t// open the file to patch\n\told, err := os.Open(o.TargetPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer old.Close()\n\n\t// apply the patch\n\tvar applied bytes.Buffer\n\tif err = o.Patcher.Patch(old, &applied, patch); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn applied.Bytes(), nil\n}\n\nfunc (o *Options) verifyChecksum(updated []byte) error {\n\tchecksum, err := checksumFor(o.Hash, updated)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !bytes.Equal(o.Checksum, checksum) {\n\t\treturn fmt.Errorf(\"Updated file has wrong checksum. Expected: %x, got: %x\", o.Checksum, checksum)\n\t}\n\treturn nil\n}\n\nfunc (o *Options) verifySignature(updated []byte) error {\n\tchecksum, err := checksumFor(o.Hash, updated)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn o.Verifier.VerifySignature(checksum, o.Signature, o.Hash, o.PublicKey)\n}\n\nfunc checksumFor(h crypto.Hash, payload []byte) ([]byte, error) {\n\tif !h.Available() {\n\t\treturn nil, errors.New(\"requested hash function not available\")\n\t}\n\thash := h.New()\n\thash.Write(payload) // guaranteed not to error\n\treturn hash.Sum([]byte{}), nil\n}\n"
        },
        {
          "name": "apply_test.go",
          "type": "blob",
          "size": 11.216796875,
          "content": "package update\n\nimport (\n\t\"bytes\"\n\t\"crypto\"\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"crypto/x509\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n\n\t\"github.com/inconshreveable/go-update/internal/binarydist\"\n)\n\nvar (\n\toldFile         = []byte{0xDE, 0xAD, 0xBE, 0xEF}\n\tnewFile         = []byte{0x01, 0x02, 0x03, 0x04, 0x05, 0x06}\n\tnewFileChecksum = sha256.Sum256(newFile)\n)\n\nfunc cleanup(path string) {\n\tos.Remove(path)\n\tos.Remove(fmt.Sprintf(\".%s.new\", path))\n}\n\n// we write with a separate name for each test so that we can run them in parallel\nfunc writeOldFile(path string, t *testing.T) {\n\tif err := ioutil.WriteFile(path, oldFile, 0777); err != nil {\n\t\tt.Fatalf(\"Failed to write file for testing preparation: %v\", err)\n\t}\n}\n\nfunc validateUpdate(path string, err error, t *testing.T) {\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to update: %v\", err)\n\t}\n\n\tbuf, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to read file post-update: %v\", err)\n\t}\n\n\tif !bytes.Equal(buf, newFile) {\n\t\tt.Fatalf(\"File was not updated! Bytes read: %v, Bytes expected: %v\", buf, newFile)\n\t}\n}\n\nfunc TestApplySimple(t *testing.T) {\n\tfName := \"TestApplySimple\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\terr := Apply(bytes.NewReader(newFile), Options{\n\t\tTargetPath: fName,\n\t})\n\tvalidateUpdate(fName, err, t)\n}\n\nfunc TestApplyOldSavePath(t *testing.T) {\n\tfName := \"TestApplyOldSavePath\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\toldfName := \"OldSavePath\"\n\n\terr := Apply(bytes.NewReader(newFile), Options{\n\t\tTargetPath:  fName,\n\t\tOldSavePath: oldfName,\n\t})\n\tvalidateUpdate(fName, err, t)\n\n\tif _, err := os.Stat(oldfName); os.IsNotExist(err) {\n\t\tt.Fatalf(\"Failed to find the old file: %v\", err)\n\t}\n\n\tcleanup(oldfName)\n}\n\nfunc TestVerifyChecksum(t *testing.T) {\n\tfName := \"TestVerifyChecksum\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\terr := Apply(bytes.NewReader(newFile), Options{\n\t\tTargetPath: fName,\n\t\tChecksum:   newFileChecksum[:],\n\t})\n\tvalidateUpdate(fName, err, t)\n}\n\nfunc TestVerifyChecksumNegative(t *testing.T) {\n\tfName := \"TestVerifyChecksumNegative\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\tbadChecksum := []byte{0x0A, 0x0B, 0x0C, 0xFF}\n\terr := Apply(bytes.NewReader(newFile), Options{\n\t\tTargetPath: fName,\n\t\tChecksum:   badChecksum,\n\t})\n\tif err == nil {\n\t\tt.Fatalf(\"Failed to detect bad checksum!\")\n\t}\n}\n\nfunc TestApplyPatch(t *testing.T) {\n\tfName := \"TestApplyPatch\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\tpatch := new(bytes.Buffer)\n\terr := binarydist.Diff(bytes.NewReader(oldFile), bytes.NewReader(newFile), patch)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create patch: %v\", err)\n\t}\n\n\terr = Apply(patch, Options{\n\t\tTargetPath: fName,\n\t\tPatcher:    NewBSDiffPatcher(),\n\t})\n\tvalidateUpdate(fName, err, t)\n}\n\nfunc TestCorruptPatch(t *testing.T) {\n\tfName := \"TestCorruptPatch\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\tbadPatch := []byte{0x44, 0x38, 0x86, 0x3c, 0x4f, 0x8d, 0x26, 0x54, 0xb, 0x11, 0xce, 0xfe, 0xc1, 0xc0, 0xf8, 0x31, 0x38, 0xa0, 0x12, 0x1a, 0xa2, 0x57, 0x2a, 0xe1, 0x3a, 0x48, 0x62, 0x40, 0x2b, 0x81, 0x12, 0xb1, 0x21, 0xa5, 0x16, 0xed, 0x73, 0xd6, 0x54, 0x84, 0x29, 0xa6, 0xd6, 0xb2, 0x1b, 0xfb, 0xe6, 0xbe, 0x7b, 0x70}\n\terr := Apply(bytes.NewReader(badPatch), Options{\n\t\tTargetPath: fName,\n\t\tPatcher:    NewBSDiffPatcher(),\n\t})\n\tif err == nil {\n\t\tt.Fatalf(\"Failed to detect corrupt patch!\")\n\t}\n}\n\nfunc TestVerifyChecksumPatchNegative(t *testing.T) {\n\tfName := \"TestVerifyChecksumPatchNegative\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\tpatch := new(bytes.Buffer)\n\tanotherFile := []byte{0x77, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66}\n\terr := binarydist.Diff(bytes.NewReader(oldFile), bytes.NewReader(anotherFile), patch)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to create patch: %v\", err)\n\t}\n\n\terr = Apply(patch, Options{\n\t\tTargetPath: fName,\n\t\tChecksum:   newFileChecksum[:],\n\t\tPatcher:    NewBSDiffPatcher(),\n\t})\n\tif err == nil {\n\t\tt.Fatalf(\"Failed to detect patch to wrong file!\")\n\t}\n}\n\nconst ecdsaPublicKey = `\n-----BEGIN PUBLIC KEY-----\nMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAEL8ThbSyEucsCxnd4dCZR2hIy5nea54ko\nO+jUUfIjkvwhCWzASm0lpCVdVpXKZXIe+NZ+44RQRv3+OqJkCCGzUgJkPNI3lxdG\n9zu8rbrnxISV06VQ8No7Ei9wiTpqmTBB\n-----END PUBLIC KEY-----\n`\n\nconst ecdsaPrivateKey = `\n-----BEGIN EC PRIVATE KEY-----\nMIGkAgEBBDBttCB/1NOY4T+WrG4FSV49Ayn3gK1DNzfGaJ01JUXeiNFCWQM2pqpU\nom8ATPP/dkegBwYFK4EEACKhZANiAAQvxOFtLIS5ywLGd3h0JlHaEjLmd5rniSg7\n6NRR8iOS/CEJbMBKbSWkJV1Wlcplch741n7jhFBG/f46omQIIbNSAmQ80jeXF0b3\nO7ytuufEhJXTpVDw2jsSL3CJOmqZMEE=\n-----END EC PRIVATE KEY-----\n`\n\nconst rsaPublicKey = `\n-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSWmu7trWKAwDFjiCN2D\nTk2jj2sgcr/CMlI4cSSiIOHrXCFxP1I8i9PvQkd4hasXQrLbT5WXKrRGv1HKUKab\nb9ead+kD0kxk7i2bFYvKX43oq66IW0mOLTQBO7I9UyT4L7svcMD+HUQ2BqHoaQe4\ny20C59dPr9Dpcz8DZkdLsBV6YKF6Ieb3iGk8oRLMWNaUqPa8f1BGgxAkvPHcqDjT\nx4xRnjgTRRRlZvRtALHMUkIChgxDOhoEzKpGiqnX7HtMJfrhV6h0PAXNA4h9Kjv5\n5fhJ08Rz7mmZmtH5JxTK5XTquo59sihSajR4bSjZbbkQ1uLkeFlY3eli3xdQ7Nrf\nfQIDAQAB\n-----END PUBLIC KEY-----`\n\nconst rsaPrivateKey = `\n-----BEGIN RSA PRIVATE KEY-----\nMIIEogIBAAKCAQEAxSWmu7trWKAwDFjiCN2DTk2jj2sgcr/CMlI4cSSiIOHrXCFx\nP1I8i9PvQkd4hasXQrLbT5WXKrRGv1HKUKabb9ead+kD0kxk7i2bFYvKX43oq66I\nW0mOLTQBO7I9UyT4L7svcMD+HUQ2BqHoaQe4y20C59dPr9Dpcz8DZkdLsBV6YKF6\nIeb3iGk8oRLMWNaUqPa8f1BGgxAkvPHcqDjTx4xRnjgTRRRlZvRtALHMUkIChgxD\nOhoEzKpGiqnX7HtMJfrhV6h0PAXNA4h9Kjv55fhJ08Rz7mmZmtH5JxTK5XTquo59\nsihSajR4bSjZbbkQ1uLkeFlY3eli3xdQ7NrffQIDAQABAoIBAAkN+6RvrTR61voa\nMvd5RQiZpEN4Bht/Fyo8gH8h0Zh1B9xJZOwlmMZLS5fdtHlfLEhR8qSrGDBL61vq\nI8KkhEsUufF78EL+YzxVN+Q7cWYGHIOWFokqza7hzpSxUQO6lPOMQ1eIZaNueJTB\nZu07/47ISPPg/bXzgGVcpYlTCPTjUwKjtfyMqvX9AD7fIyYRm6zfE7EHj1J2sBFt\nYz1OGELg6HfJwXfpnPfBvftD0hWGzJ78Bp71fPJe6n5gnqmSqRvrcXNWFnH/yqkN\nd6vPIxD6Z3LjvyZpkA7JillLva2L/zcIFhg4HZvQnWd8/PpDnUDonu36hcj4SC5j\nW4aVPLkCgYEA4XzNKWxqYcajzFGZeSxlRHupSAl2MT7Cc5085MmE7dd31wK2T8O4\nn7N4bkm/rjTbX85NsfWdKtWb6mpp8W3VlLP0rp4a/12OicVOkg4pv9LZDmY0sRlE\nYuDJk1FeCZ50UrwTZI3rZ9IhZHhkgVA6uWAs7tYndONkxNHG0pjqs4sCgYEA39MZ\nJwMqo3qsPntpgP940cCLflEsjS9hYNO3+Sv8Dq3P0HLVhBYajJnotf8VuU0fsQZG\ngrmtVn1yThFbMq7X1oY4F0XBA+paSiU18c4YyUnwax2u4sw9U/Q9tmQUZad5+ueT\nqriMBwGv+ewO+nQxqvAsMUmemrVzrfwA5Oct+hcCgYAfiyXoNZJsOy2O15twqBVC\nj0oPGcO+/9iT89sg5lACNbI+EdMPNYIOVTzzsL1v0VUfAe08h++Enn1BPcG0VHkc\nZFBGXTfJoXzfKQrkw7ZzbzuOGB4m6DH44xlP0oIlNlVvfX/5ASF9VJf3RiBJNsAA\nTsP6ZVr/rw/ZuL7nlxy+IQKBgDhL/HOXlE3yOQiuOec8WsNHTs7C1BXe6PtVxVxi\n988pYK/pclL6zEq5G5NLSceF4obAMVQIJ9UtUGbabrncyGUo9UrFPLsjYvprSZo8\nYHegpVwL50UcYgCP2kXZ/ldjPIcjYDz8lhvdDMor2cidGTEJn9P11HLNWP9V91Ob\n4jCZAoGAPNRSC5cC8iP/9j+s2/kdkfWJiNaolPYAUrmrkL6H39PYYZM5tnhaIYJV\nOh9AgABamU0eb3p3vXTISClVgV7ifq1HyZ7BSUhMfaY2Jk/s3sUHCWFxPZe9sgEG\nKinIY/373KIkIV/5g4h2v1w330IWcfptxKcY/Er3DJr38f695GE=\n-----END RSA PRIVATE KEY-----`\n\nfunc signec(privatePEM string, source []byte, t *testing.T) []byte {\n\tparseFn := func(p []byte) (crypto.Signer, error) { return x509.ParseECPrivateKey(p) }\n\treturn sign(parseFn, privatePEM, source, t)\n}\n\nfunc signrsa(privatePEM string, source []byte, t *testing.T) []byte {\n\tparseFn := func(p []byte) (crypto.Signer, error) { return x509.ParsePKCS1PrivateKey(p) }\n\treturn sign(parseFn, privatePEM, source, t)\n}\n\nfunc sign(parsePrivKey func([]byte) (crypto.Signer, error), privatePEM string, source []byte, t *testing.T) []byte {\n\tblock, _ := pem.Decode([]byte(privatePEM))\n\tif block == nil {\n\t\tt.Fatalf(\"Failed to parse private key PEM\")\n\t}\n\n\tpriv, err := parsePrivKey(block.Bytes)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to parse private key DER: %v\", err)\n\t}\n\n\tchecksum := sha256.Sum256(source)\n\tsig, err := priv.Sign(rand.Reader, checksum[:], crypto.SHA256)\n\tif err != nil {\n\t\tt.Fatalf(\"Failed to sign: %v\", sig)\n\t}\n\n\treturn sig\n}\n\nfunc TestVerifyECSignature(t *testing.T) {\n\tfName := \"TestVerifyECSignature\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topts := Options{TargetPath: fName}\n\terr := opts.SetPublicKeyPEM([]byte(ecdsaPublicKey))\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse public key: %v\", err)\n\t}\n\n\topts.Signature = signec(ecdsaPrivateKey, newFile, t)\n\terr = Apply(bytes.NewReader(newFile), opts)\n\tvalidateUpdate(fName, err, t)\n}\n\nfunc TestVerifyRSASignature(t *testing.T) {\n\tfName := \"TestVerifyRSASignature\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topts := Options{\n\t\tTargetPath: fName,\n\t\tVerifier:   NewRSAVerifier(),\n\t}\n\terr := opts.SetPublicKeyPEM([]byte(rsaPublicKey))\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse public key: %v\", err)\n\t}\n\n\topts.Signature = signrsa(rsaPrivateKey, newFile, t)\n\terr = Apply(bytes.NewReader(newFile), opts)\n\tvalidateUpdate(fName, err, t)\n}\n\nfunc TestVerifyFailBadSignature(t *testing.T) {\n\tfName := \"TestVerifyFailBadSignature\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topts := Options{\n\t\tTargetPath: fName,\n\t\tSignature:  []byte{0xFF, 0xEE, 0xDD, 0xCC, 0xBB, 0xAA},\n\t}\n\terr := opts.SetPublicKeyPEM([]byte(ecdsaPublicKey))\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse public key: %v\", err)\n\t}\n\n\terr = Apply(bytes.NewReader(newFile), opts)\n\tif err == nil {\n\t\tt.Fatalf(\"Did not fail with bad signature\")\n\t}\n}\n\nfunc TestVerifyFailNoSignature(t *testing.T) {\n\tfName := \"TestVerifySignatureWithPEM\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topts := Options{TargetPath: fName}\n\terr := opts.SetPublicKeyPEM([]byte(ecdsaPublicKey))\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse public key: %v\", err)\n\t}\n\n\terr = Apply(bytes.NewReader(newFile), opts)\n\tif err == nil {\n\t\tt.Fatalf(\"Did not fail with empty signature\")\n\t}\n}\n\nconst wrongKey = `\n-----BEGIN EC PRIVATE KEY-----\nMIGkAgEBBDBzqYp6N2s8YWYifBjS03/fFfmGeIPcxQEi+bbFeekIYt8NIKIkhD+r\nhpaIwSmot+qgBwYFK4EEACKhZANiAAR0EC8Usbkc4k30frfEB2ECmsIghu9DJSqE\nRbH7jfq2ULNv8tN/clRjxf2YXgp+iP3SQF1R1EYERKpWr8I57pgfIZtoZXjwpbQC\nVBbP/Ff+05HOqwPC7rJMy1VAJLKg7Cw=\n-----END EC PRIVATE KEY-----\n`\n\nfunc TestVerifyFailWrongSignature(t *testing.T) {\n\tfName := \"TestVerifyFailWrongSignature\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topts := Options{TargetPath: fName}\n\terr := opts.SetPublicKeyPEM([]byte(ecdsaPublicKey))\n\tif err != nil {\n\t\tt.Fatalf(\"Could not parse public key: %v\", err)\n\t}\n\n\topts.Signature = signec(wrongKey, newFile, t)\n\terr = Apply(bytes.NewReader(newFile), opts)\n\tif err == nil {\n\t\tt.Fatalf(\"Verified an update that was signed by an untrusted key!\")\n\t}\n}\n\nfunc TestSignatureButNoPublicKey(t *testing.T) {\n\tfName := \"TestSignatureButNoPublicKey\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\terr := Apply(bytes.NewReader(newFile), Options{\n\t\tTargetPath: fName,\n\t\tSignature:  signec(ecdsaPrivateKey, newFile, t),\n\t})\n\tif err == nil {\n\t\tt.Fatalf(\"Allowed an update with a signautre verification when no public key was specified!\")\n\t}\n}\n\nfunc TestPublicKeyButNoSignature(t *testing.T) {\n\tfName := \"TestPublicKeyButNoSignature\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topts := Options{TargetPath: fName}\n\tif err := opts.SetPublicKeyPEM([]byte(ecdsaPublicKey)); err != nil {\n\t\tt.Fatalf(\"Could not parse public key: %v\", err)\n\t}\n\terr := Apply(bytes.NewReader(newFile), opts)\n\tif err == nil {\n\t\tt.Fatalf(\"Allowed an update with no signautre when a public key was specified!\")\n\t}\n}\n\nfunc TestWriteError(t *testing.T) {\n\tfName := \"TestWriteError\"\n\tdefer cleanup(fName)\n\twriteOldFile(fName, t)\n\n\topenFile = func(name string, flags int, perm os.FileMode) (*os.File, error) {\n\t\tf, err := os.OpenFile(name, flags, perm)\n\n\t\t// simulate Write() error by closing the file prematurely\n\t\tf.Close()\n\n\t\treturn f, err\n\t}\n\tdefer func() {\n\t\topenFile = os.OpenFile\n\t}()\n\n\terr := Apply(bytes.NewReader(newFile), Options{TargetPath: fName})\n\tif err == nil {\n\t\tt.Fatalf(\"Allowed an update to an empty file\")\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 5.1123046875,
          "content": "/*\nPackage update provides functionality to implement secure, self-updating Go programs (or other single-file targets).\n\nFor complete updating solutions please see Equinox (https://equinox.io) and go-tuf (https://github.com/flynn/go-tuf).\n\nBasic Example\n\nThis example shows how to update a program remotely from a URL.\n\n\timport (\n\t\t\"fmt\"\n\t\t\"net/http\"\n\n\t\t\"github.com/inconshreveable/go-update\"\n\t)\n\n\tfunc doUpdate(url string) error {\n\t\t// request the new file\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer resp.Body.Close()\n\t\terr := update.Apply(resp.Body, update.Options{})\n\t\tif err != nil {\n\t\t\tif rerr := update.RollbackError(err); rerr != nil {\n\t\t\t\tfmt.Println(\"Failed to rollback from bad update: %v\", rerr)\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\nBinary Patching\n\nGo binaries can often be large. It can be advantageous to only ship a binary patch to a client\ninstead of the complete program text of a new version.\n\nThis example shows how to update a program with a bsdiff binary patch. Other patch formats\nmay be applied by implementing the Patcher interface.\n\n\timport (\n\t\t\"encoding/hex\"\n\t\t\"io\"\n\n\t\t\"github.com/inconshreveable/go-update\"\n\t)\n\n\tfunc updateWithPatch(patch io.Reader) error {\n\t\terr := update.Apply(patch, update.Options{\n\t\t\tPatcher: update.NewBSDiffPatcher()\n\t\t})\n\t\tif err != nil {\n\t\t\t// error handling\n\t\t}\n\t\treturn err\n\t}\n\nChecksum Verification\n\nUpdating executable code on a computer can be a dangerous operation unless you\ntake the appropriate steps to guarantee the authenticity of the new code. While\nchecksum verification is important, it should always be combined with signature\nverification (next section) to guarantee that the code came from a trusted party.\n\ngo-update validates SHA256 checksums by default, but this is pluggable via the Hash\nproperty on the Options struct.\n\nThis example shows how to guarantee that the newly-updated binary is verified to\nhave an appropriate checksum (that was otherwise retrived via a secure channel)\nspecified as a hex string.\n\n\timport (\n\t\t\"crypto\"\n\t\t_ \"crypto/sha256\"\n\t\t\"encoding/hex\"\n\t\t\"io\"\n\n\t\t\"github.com/inconshreveable/go-update\"\n\t)\n\n\tfunc updateWithChecksum(binary io.Reader, hexChecksum string) error {\n\t\tchecksum, err := hex.DecodeString(hexChecksum)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = update.Apply(binary, update.Options{\n\t\t\tHash: crypto.SHA256, \t// this is the default, you don't need to specify it\n\t\t\tChecksum: checksum,\n\t\t})\n\t\tif err != nil {\n\t\t\t// error handling\n\t\t}\n\t\treturn err\n\t}\n\nCryptographic Signature Verification\n\nCryptographic verification of new code from an update is an extremely important way to guarantee the\nsecurity and integrity of your updates.\n\nVerification is performed by validating the signature of a hash of the new file. This\nmeans nothing changes if you apply your update with a patch.\n\nThis example shows how to add signature verification to your updates. To make all of this work\nan application distributor must first create a public/private key pair and embed the public key\ninto their application. When they issue a new release, the issuer must sign the new executable file\nwith the private key and distribute the signature along with the update.\n\n\timport (\n\t\t\"crypto\"\n\t\t_ \"crypto/sha256\"\n\t\t\"encoding/hex\"\n\t\t\"io\"\n\n\t\t\"github.com/inconshreveable/go-update\"\n\t)\n\n\tvar publicKey = []byte(`\n\t-----BEGIN PUBLIC KEY-----\n\tMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAEtrVmBxQvheRArXjg2vG1xIprWGuCyESx\n\tMMY8pjmjepSy2kuz+nl9aFLqmr+rDNdYvEBqQaZrYMc6k29gjvoQnQ==\n\t-----END PUBLIC KEY-----\n\t`)\n\n\tfunc verifiedUpdate(binary io.Reader, hexChecksum, hexSignature string) {\n\t\tchecksum, err := hex.DecodeString(hexChecksum)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsignature, err := hex.DecodeString(hexSignature)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\topts := update.Options{\n\t\t\tChecksum: checksum,\n\t\t\tSignature: signature,\n\t\t\tHash: crypto.SHA256, \t                 // this is the default, you don't need to specify it\n\t\t\tVerifier: update.NewECDSAVerifier(),   // this is the default, you don't need to specify it\n\t\t}\n\t\terr = opts.SetPublicKeyPEM(publicKey)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\terr = update.Apply(binary, opts)\n\t\tif err != nil {\n\t\t\t// error handling\n\t\t}\n\t\treturn err\n\t}\n\n\nBuilding Single-File Go Binaries\n\nIn order to update a Go application with go-update, you must distributed it as a single executable.\nThis is often easy, but some applications require static assets (like HTML and CSS asset files or TLS certificates).\nIn order to update applications like these, you'll want to make sure to embed those asset files into\nthe distributed binary with a tool like go-bindata (my favorite): https://github.com/jteeuwen/go-bindata\n\nNon-Goals\n\nMechanisms and protocols for determining whether an update should be applied and, if so, which one are\nout of scope for this package. Please consult go-tuf (https://github.com/flynn/go-tuf) or Equinox (https://equinox.io)\nfor more complete solutions.\n\ngo-update only works for self-updating applications that are distributed as a single binary, i.e.\napplications that do not have additional assets or dependency files.\nUpdating application that are distributed as mutliple on-disk files is out of scope, although this\nmay change in future versions of this library.\n\n*/\npackage update\n"
        },
        {
          "name": "hide_noop.go",
          "type": "blob",
          "size": 0.0830078125,
          "content": "// +build !windows\n\npackage update\n\nfunc hideFile(path string) error {\n\treturn nil\n}\n"
        },
        {
          "name": "hide_windows.go",
          "type": "blob",
          "size": 0.33984375,
          "content": "package update\n\nimport (\n\t\"syscall\"\n\t\"unsafe\"\n)\n\nfunc hideFile(path string) error {\n\tkernel32 := syscall.NewLazyDLL(\"kernel32.dll\")\n\tsetFileAttributes := kernel32.NewProc(\"SetFileAttributesW\")\n\n\tr1, _, err := setFileAttributes.Call(uintptr(unsafe.Pointer(syscall.StringToUTF16Ptr(path))), 2)\n\n\tif r1 == 0 {\n\t\treturn err\n\t} else {\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "patcher.go",
          "type": "blob",
          "size": 0.646484375,
          "content": "package update\n\nimport (\n\t\"io\"\n\n\t\"github.com/inconshreveable/go-update/internal/binarydist\"\n)\n\n// Patcher defines an interface for applying binary patches to an old item to get an updated item.\ntype Patcher interface {\n\tPatch(old io.Reader, new io.Writer, patch io.Reader) error\n}\n\ntype patchFn func(io.Reader, io.Writer, io.Reader) error\n\nfunc (fn patchFn) Patch(old io.Reader, new io.Writer, patch io.Reader) error {\n\treturn fn(old, new, patch)\n}\n\n// NewBSDifferPatcher returns a new Patcher that applies binary patches using\n// the bsdiff algorithm. See http://www.daemonology.net/bsdiff/\nfunc NewBSDiffPatcher() Patcher {\n\treturn patchFn(binarydist.Patch)\n}\n"
        },
        {
          "name": "verifier.go",
          "type": "blob",
          "size": 2.0771484375,
          "content": "package update\n\nimport (\n\t\"crypto\"\n\t\"crypto/dsa\"\n\t\"crypto/ecdsa\"\n\t\"crypto/rsa\"\n\t\"encoding/asn1\"\n\t\"errors\"\n\t\"math/big\"\n)\n\n// Verifier defines an interface for verfiying an update's signature with a public key.\ntype Verifier interface {\n\tVerifySignature(checksum, signature []byte, h crypto.Hash, publicKey crypto.PublicKey) error\n}\n\ntype verifyFn func([]byte, []byte, crypto.Hash, crypto.PublicKey) error\n\nfunc (fn verifyFn) VerifySignature(checksum []byte, signature []byte, hash crypto.Hash, publicKey crypto.PublicKey) error {\n\treturn fn(checksum, signature, hash, publicKey)\n}\n\n// NewRSAVerifier returns a Verifier that uses the RSA algorithm to verify updates.\nfunc NewRSAVerifier() Verifier {\n\treturn verifyFn(func(checksum, signature []byte, hash crypto.Hash, publicKey crypto.PublicKey) error {\n\t\tkey, ok := publicKey.(*rsa.PublicKey)\n\t\tif !ok {\n\t\t\treturn errors.New(\"not a valid RSA public key\")\n\t\t}\n\t\treturn rsa.VerifyPKCS1v15(key, hash, checksum, signature)\n\t})\n}\n\ntype rsDER struct {\n\tR *big.Int\n\tS *big.Int\n}\n\n// NewECDSAVerifier returns a Verifier that uses the ECDSA algorithm to verify updates.\nfunc NewECDSAVerifier() Verifier {\n\treturn verifyFn(func(checksum, signature []byte, hash crypto.Hash, publicKey crypto.PublicKey) error {\n\t\tkey, ok := publicKey.(*ecdsa.PublicKey)\n\t\tif !ok {\n\t\t\treturn errors.New(\"not a valid ECDSA public key\")\n\t\t}\n\t\tvar rs rsDER\n\t\tif _, err := asn1.Unmarshal(signature, &rs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !ecdsa.Verify(key, checksum, rs.R, rs.S) {\n\t\t\treturn errors.New(\"failed to verify ecsda signature\")\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// NewDSAVerifier returns a Verifier that uses the DSA algorithm to verify updates.\nfunc NewDSAVerifier() Verifier {\n\treturn verifyFn(func(checksum, signature []byte, hash crypto.Hash, publicKey crypto.PublicKey) error {\n\t\tkey, ok := publicKey.(*dsa.PublicKey)\n\t\tif !ok {\n\t\t\treturn errors.New(\"not a valid DSA public key\")\n\t\t}\n\t\tvar rs rsDER\n\t\tif _, err := asn1.Unmarshal(signature, &rs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !dsa.Verify(key, checksum, rs.R, rs.S) {\n\t\t\treturn errors.New(\"failed to verify ecsda signature\")\n\t\t}\n\t\treturn nil\n\t})\n}\n"
        }
      ]
    }
  ]
}