{
  "metadata": {
    "timestamp": 1736566853264,
    "page": 424,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gokrazy/gokrazy",
      "stars": 3296,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4453125,
          "content": "Copyright (c) 2017 the gokrazy authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of gokrazy nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.064453125,
          "content": "[![GitHub Actions CI](https://github.com/gokrazy/gokrazy/actions/workflows/main.yml/badge.svg)](https://github.com/gokrazy/gokrazy/actions/workflows/main.yml)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gokrazy/gokrazy)](https://goreportcard.com/report/github.com/gokrazy/gokrazy)\n\n# Overview\n\nWith gokrazy, you can deploy your Go programs as appliances to a Raspberry Pi or\nPC ([→ supported platforms](https://gokrazy.org/platforms/)).\n\nFor a long time, we were unhappy with having to care about security issues and\nLinux distribution maintenance on our various Raspberry Pis.\n\nThen, we had a crazy idea: what if we got rid of memory-unsafe languages and all\nsoftware we don’t strictly need?\n\nTurns out this is feasible. gokrazy is the result.\n\n[→ Learn more at gokrazy.org](https://gokrazy.org/)\n\n# GitHub Repository structure\n\n* [github.com/gokrazy/gokrazy](https://github.com/gokrazy/gokrazy): system code, main issue tracker, documentation\n* [github.com/gokrazy/tools](https://github.com/gokrazy/tools): SD card image creation code, pulling in:\n    * [github.com/gokrazy/firmware](https://github.com/gokrazy/firmware): Raspberry Pi 3 or 4 firmware files\n    * [github.com/gokrazy/rpi-eeprom](https://github.com/gokrazy/rpi-eeprom): Raspberry Pi 4 EEPROM files\n    * [github.com/gokrazy/kernel](https://github.com/gokrazy/kernel): pre-built kernel image and bootloader config\n\n# Documentation\n\n[gokrazy.org](https://gokrazy.org) uses [hugo](https://gohugo.io/) for creating and generating the website.\nYou can find the hugo install instructions here: [Install Hugo](https://gohugo.io/getting-started/installing/).\nWith hugo you can write documentation in Markdown and generate a static website from it.\n\nThe `website` subdirectory is hugo’s root directory. In order to preview the\ndocumentation or to re-generate the website, switch the directory to `website`.\n\nTo preview the website, run the hugo webserver:\n\n```bash\nhugo serve\n```\n\nGenerate the website:\n\n```bash\nhugo\n```\n\nThe updated website content will be stored in the `./docs` directory.\nDo not update anything here manually.\n\n"
        },
        {
          "name": "authenticated.go",
          "type": "blob",
          "size": 1.5751953125,
          "content": "package gokrazy\n\nimport (\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n)\n\nfunc authenticated(w http.ResponseWriter, r *http.Request) {\n\t// If httpPassword is empty, we only allow access via the unix socket. Out\n\t// of paranoia, even though it should only be listening via the unix socket,\n\t// verify that's where it came from.\n\t//\n\t// See https://github.com/gokrazy/gokrazy/issues/265\n\tif httpPassword == \"\" {\n\t\taddr, ok := r.Context().Value(http.LocalAddrContextKey).(*net.UnixAddr)\n\t\tif ok && addr.Name == gokrazyHTTPUnixSocket {\n\t\t\thttp.DefaultServeMux.ServeHTTP(w, r)\n\t\t} else {\n\t\t\thttp.Error(w, \"httpPassword not set and request from unexpected address\", http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\n\tkind, encoded, found := strings.Cut(r.Header.Get(\"Authorization\"), \" \")\n\tif !found || kind != \"Basic\" {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"gokrazy\"`)\n\t\thttp.Error(w, \"no Basic Authorization header set\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tb, err := base64.StdEncoding.DecodeString(encoded)\n\tif err != nil {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"gokrazy\"`)\n\t\thttp.Error(w, fmt.Sprintf(\"could not decode Authorization header as base64: %v\", err), http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tusername, password, found := strings.Cut(string(b), \":\")\n\tif !found ||\n\t\tusername != \"gokrazy\" ||\n\t\tsubtle.ConstantTimeCompare([]byte(password), []byte(httpPassword)) != 1 {\n\t\tw.Header().Set(\"WWW-Authenticate\", `Basic realm=\"gokrazy\"`)\n\t\thttp.Error(w, \"invalid username/password\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\thttp.DefaultServeMux.ServeHTTP(w, r)\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.2109375,
          "content": "// gokrazy packs your Go application(s) into an SD card image for the\n// Raspberry Pi 3 which — aside from the Linux kernel and proprietary\n// Raspberry Pi bootloader — only contains Go software.\npackage gokrazy\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "eeprom.go",
          "type": "blob",
          "size": 1.4619140625,
          "content": "package gokrazy\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/gokrazy/internal/fat\"\n\t\"github.com/gokrazy/internal/rootdev\"\n)\n\ntype eepromVersion struct {\n\tPieepromSHA256 string // pieeprom.sig\n\tVL805SHA256    string // vl805.sig\n}\n\n// filled by SuperviseServices()\nvar lastInstalledEepromVersion *eepromVersion\n\nfunc readLastInstalledEepromVersion() (*eepromVersion, error) {\n\tf, err := os.OpenFile(rootdev.Partition(rootdev.Boot), os.O_RDONLY, 0600)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\n\trd, err := fat.NewReader(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := rd.ModTime(\"/RECOVERY.000\"); err != nil {\n\t\treturn nil, fmt.Errorf(\"RECOVERY.000 not found, assuming update unsuccessful\")\n\t}\n\t// Get all extents before we start seeking, which confuses the fat.Reader.\n\toffsetE, lengthE, err := rd.Extents(\"/pieeprom.sig\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toffsetV, lengthV, err := rd.Extents(\"/vl805.sig\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := &eepromVersion{}\n\n\t{\n\t\tif _, err := f.Seek(offsetE, io.SeekStart); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb := make([]byte, lengthE)\n\t\tif _, err := f.Read(b); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult.PieepromSHA256 = strings.TrimSpace(string(b))\n\t}\n\n\t{\n\t\tif _, err := f.Seek(offsetV, io.SeekStart); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tb := make([]byte, lengthV)\n\t\tif _, err := f.Read(b); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tresult.VL805SHA256 = strings.TrimSpace(string(b))\n\t}\n\n\treturn result, nil\n}\n"
        },
        {
          "name": "empty",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.8525390625,
          "content": "module github.com/gokrazy/gokrazy\n\ngo 1.22\n\nrequire (\n\tgithub.com/anatol/vmtest v0.0.0-20211215032353-afd7b1dd38ef\n\tgithub.com/beevik/ntp v0.3.0\n\tgithub.com/gokrazy/internal v0.0.0-20240629150625-a0f1dee26ef5\n\tgithub.com/google/gopacket v1.1.19\n\tgithub.com/google/renameio/v2 v2.0.0\n\tgithub.com/kenshaw/evdev v0.1.0\n\tgithub.com/mdlayher/packet v1.0.0\n\tgithub.com/mdlayher/watchdog v0.0.0-20201005150459-8bdc4f41966b\n\tgithub.com/rtr7/dhcp4 v0.0.0-20220302171438-18c84d089b46\n\tgithub.com/vishvananda/netlink v1.1.0\n\tgolang.org/x/sys v0.20.0\n)\n\nrequire (\n\tgithub.com/josharian/native v1.0.0 // indirect\n\tgithub.com/mdlayher/socket v0.2.3 // indirect\n\tgithub.com/spf13/pflag v1.0.5 // indirect\n\tgithub.com/vishvananda/netns v0.0.0-20211101163701-50045581ed74 // indirect\n\tgolang.org/x/net v0.23.0 // indirect\n\tgolang.org/x/sync v0.0.0-20210220032951-036812b2e83c // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 5.876953125,
          "content": "github.com/anatol/vmtest v0.0.0-20211215032353-afd7b1dd38ef h1:YQzm9r8/ArTsQ6C3/h+w4Dz5dfkYkQbK/3ETLWW2i7Q=\ngithub.com/anatol/vmtest v0.0.0-20211215032353-afd7b1dd38ef/go.mod h1:JiDFhD1zjgMx9ONsHhhucGwMvCLrJMl/yu/l5qP4XFw=\ngithub.com/beevik/ntp v0.3.0 h1:xzVrPrE4ziasFXgBVBZJDP0Wg/KpMwk2KHJ4Ba8GrDw=\ngithub.com/beevik/ntp v0.3.0/go.mod h1:hIHWr+l3+/clUnF44zdK+CWW7fO8dR5cIylAQ76NRpg=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gokrazy/internal v0.0.0-20240607160728-3c7bf66a62e9 h1:SLjEgU2ufDL13xVW4+BWTcwhGFTOwf2LXAiJQiolASU=\ngithub.com/gokrazy/internal v0.0.0-20240607160728-3c7bf66a62e9/go.mod h1:t3ZirVhcs9bH+fPAJuGh51rzT7sVCZ9yfXvszf0ZjF0=\ngithub.com/gokrazy/internal v0.0.0-20240629150625-a0f1dee26ef5 h1:XDklMxV0pE5jWiNaoo5TzvWfqdoiRRScmr4ZtDzE4Uw=\ngithub.com/gokrazy/internal v0.0.0-20240629150625-a0f1dee26ef5/go.mod h1:t3ZirVhcs9bH+fPAJuGh51rzT7sVCZ9yfXvszf0ZjF0=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/google/gopacket v1.1.19 h1:ves8RnFZPGiFnTS0uPQStjwru6uO6h+nlr9j6fL7kF8=\ngithub.com/google/gopacket v1.1.19/go.mod h1:iJ8V8n6KS+z2U1A8pUwu8bW5SyEMkXJB8Yo/Vo+TKTo=\ngithub.com/google/renameio/v2 v2.0.0 h1:UifI23ZTGY8Tt29JbYFiuyIU3eX+RNFtUwefq9qAhxg=\ngithub.com/google/renameio/v2 v2.0.0/go.mod h1:BtmJXm5YlszgC+TD4HOEEUFgkJP3nLxehU6hfe7jRt4=\ngithub.com/josharian/native v1.0.0 h1:Ts/E8zCSEsG17dUqv7joXJFybuMLjQfWE04tsBODTxk=\ngithub.com/josharian/native v1.0.0/go.mod h1:7X/raswPFr05uY3HiLlYeyQntB6OO7E/d2Cu7qoaN2w=\ngithub.com/kenshaw/evdev v0.1.0 h1:wmtceEOFfilChgdNT+c/djPJ2JineVsQ0N14kGzFRUo=\ngithub.com/kenshaw/evdev v0.1.0/go.mod h1:B/fErKCihUyEobz0mjn2qQbHgyJKFQAxkXSvkeeA/Wo=\ngithub.com/mdlayher/packet v1.0.0 h1:InhZJbdShQYt6XV2GPj5XHxChzOfhJJOMbvnGAmOfQ8=\ngithub.com/mdlayher/packet v1.0.0/go.mod h1:eE7/ctqDhoiRhQ44ko5JZU2zxB88g+JH/6jmnjzPjOU=\ngithub.com/mdlayher/socket v0.2.3 h1:XZA2X2TjdOwNoNPVPclRCURoX/hokBY8nkTmRZFEheM=\ngithub.com/mdlayher/socket v0.2.3/go.mod h1:bz12/FozYNH/VbvC3q7TRIK/Y6dH1kCKsXaUeXi/FmY=\ngithub.com/mdlayher/watchdog v0.0.0-20201005150459-8bdc4f41966b h1:7tUBfsEEBWfFeHOB7CUfoOamak+Gx/BlirfXyPk1WjI=\ngithub.com/mdlayher/watchdog v0.0.0-20201005150459-8bdc4f41966b/go.mod h1:bmoJUS6qOA3uKFvF3KVuhf7mU1KQirzQMeHXtPyKEqg=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rtr7/dhcp4 v0.0.0-20220302171438-18c84d089b46 h1:3psQveH4RUiv5yc3p7kRySilf1nSXLQhAvJFwg4fgnE=\ngithub.com/rtr7/dhcp4 v0.0.0-20220302171438-18c84d089b46/go.mod h1:Ng1F/s+z0zCMsbEFEneh+30LJa9DrTfmA+REbEqcTPk=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/vishvananda/netlink v1.1.0 h1:1iyaYNBLmP6L0220aDnYQpo1QEV4t4hJ+xEEhhJH8j0=\ngithub.com/vishvananda/netlink v1.1.0/go.mod h1:cTgwzPIzzgDAYoQrMm0EdrjRUBkTqKYppBueQtXaqoE=\ngithub.com/vishvananda/netns v0.0.0-20191106174202-0a2b9b5464df/go.mod h1:JP3t17pCcGlemwknint6hfoeCVQrEMVwxRLRjXpq+BU=\ngithub.com/vishvananda/netns v0.0.0-20211101163701-50045581ed74 h1:gga7acRE695APm9hlsSMoOoE65U4/TcqNj90mc69Rlg=\ngithub.com/vishvananda/netns v0.0.0-20211101163701-50045581ed74/go.mod h1:DD4vA1DwXk04H54A1oHXtwZmA0grkVMdPxx/VGLCah0=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.23.0 h1:7EYJ93RZ9vYSZAIb2x3lnuvqO5zneoD6IvWjuhfxjTs=\ngolang.org/x/net v0.23.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c h1:5KslGYwFpkhGh+Q16bwMP3cOontH8FOep7tGV86Y7SQ=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606203320-7fc4e5ec1444/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200217220822-9197077df867/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201005065044-765f4ea38db3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.20.0 h1:Od9JTbYCk261bKm4M/mw7AklTlFYIa0bIp9BgSm1S8Y=\ngolang.org/x/sys v0.20.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b h1:h8qDotaEPuJATrMmW04NCwg7v22aHH28wwpauUhK9Oo=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gokrazy.go",
          "type": "blob",
          "size": 14.51171875,
          "content": "// Boot and Supervise are called by the auto-generated init\n// program. They are provided in case you need to implement a custom\n// init program.\n//\n// PrivateInterfaceAddrs is useful for init and other processes.\n//\n// DontStartOnBoot and WaitForClock are useful for non-init processes.\npackage gokrazy\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/mdlayher/watchdog\"\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/gokrazy/gokrazy/internal/iface\"\n\t\"github.com/gokrazy/internal/rootdev\"\n)\n\nvar (\n\tbuildTimestamp = \"uninitialized\"\n\thttpPassword   string // or empty to only permit unix socket access\n\thostname       string\n\ttlsConfig      *tls.Config\n\tuseTLS         bool\n)\n\nfunc configureLoopback() error {\n\tcs, err := iface.NewConfigSocket(\"lo\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"config socket: %v\", err)\n\t}\n\tdefer cs.Close()\n\n\tif err := cs.Up(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := cs.SetAddress(net.IP([]byte{127, 0, 0, 1})); err != nil {\n\t\treturn err\n\t}\n\n\treturn cs.SetNetmask(net.IPMask([]byte{255, 0, 0, 0}))\n}\n\n// runWatchdog periodically pings the hardware watchdog.\nfunc runWatchdog() {\n\td, err := watchdog.Open()\n\tif err != nil {\n\t\tlog.Printf(\"disabling hardware watchdog, as it could not be opened: %v\", err)\n\t\treturn\n\t}\n\tdefer d.Close()\n\n\tvar timeout string\n\tif t, err := d.Timeout(); err != nil {\n\t\t// Assume the device cannot report the watchdog timeout.\n\t\ttimeout = \"unknown\"\n\t} else {\n\t\ttimeout = t.String()\n\t}\n\n\tlog.Printf(\"found hardware watchdog %q with timeout %s, pinging...\", d.Identity, timeout)\n\n\tfor {\n\t\tif err := d.Ping(); err != nil {\n\t\t\tlog.Printf(\"hardware watchdog ping failed: %v\", err)\n\t\t}\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nfunc setupTLS() error {\n\tif _, err := os.Stat(\"/etc/ssl/gokrazy-web.pem\"); os.IsNotExist(err) {\n\t\treturn nil // Nothing to set up\n\t}\n\tcert, err := tls.LoadX509KeyPair(\"/etc/ssl/gokrazy-web.pem\", \"/etc/ssl/gokrazy-web.key.pem\")\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed loading certificate: %v\", err)\n\t}\n\tuseTLS = true\n\ttlsConfig = &tls.Config{\n\t\tCertificates:             []tls.Certificate{cert},\n\t\tMinVersion:               tls.VersionTLS12,\n\t\tCurvePreferences:         []tls.CurveID{tls.CurveP521, tls.CurveP384, tls.CurveP256},\n\t\tPreferServerCipherSuites: true,\n\t\tCipherSuites: []uint16{\n\t\t\t// required for http/2\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\t\t// See https://cipherlist.eu/\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n\t\t},\n\t}\n\treturn nil\n}\n\n// readConfigFile reads configuration files from /perm /etc or / and returns trimmed content as string\nfunc readConfigFile(fileName string) (string, error) {\n\tstr, err := ioutil.ReadFile(\"/perm/\" + fileName)\n\tif err != nil {\n\t\tstr, err = ioutil.ReadFile(\"/etc/\" + fileName)\n\t}\n\tif err != nil && os.IsNotExist(err) {\n\t\tstr, err = ioutil.ReadFile(\"/\" + fileName)\n\t}\n\n\treturn strings.TrimSpace(string(str)), err\n}\n\n// readPortFromConfigFile reads port from config file\nfunc readPortFromConfigFile(fileName, defaultPort string) string {\n\tport, err := readConfigFile(fileName)\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tlog.Printf(\"reading %s failed: %v\", fileName, err)\n\t\t}\n\t\treturn defaultPort\n\t}\n\n\tif _, err := strconv.Atoi(port); err != nil {\n\t\tlog.Printf(\"invalid port in %s: %v\", fileName, err)\n\t\treturn defaultPort\n\t}\n\n\treturn port\n}\n\nfunc switchToInactiveRoot() error {\n\t// mount the inactive root partition on a temporary mountpoint\n\ttmpmnt := filepath.Join(os.TempDir(), \"mnt\")\n\tif err := os.MkdirAll(tmpmnt, 0755); err != nil {\n\t\treturn err\n\t}\n\n\tif err := syscall.Mount(rootdev.Partition(rootdev.InactiveRootPartition()), tmpmnt, \"squashfs\", syscall.MS_RDONLY, \"\"); err != nil {\n\t\treturn fmt.Errorf(\"mount inactive root: %v\", err)\n\t}\n\n\tif err := os.Chdir(tmpmnt); err != nil {\n\t\treturn fmt.Errorf(\"chdir: %v\", err)\n\t}\n\n\tif err := syscall.Mount(\".\", \"/\", \"\", syscall.MS_MOVE, \"\"); err != nil {\n\t\treturn fmt.Errorf(\"mount . /: %v\", err)\n\t}\n\n\tif err := syscall.Chroot(\".\"); err != nil {\n\t\treturn fmt.Errorf(\"chroot .: %v\", err)\n\t}\n\n\tif err := os.Chdir(\"/\"); err != nil {\n\t\treturn fmt.Errorf(\"chdir: %v\", err)\n\t}\n\n\tif err := syscall.Exec(\"/gokrazy/init\", []string{\"/gokrazy/init\"}, os.Environ()); err != nil {\n\t\treturn fmt.Errorf(\"exec(init): %v\", err)\n\t}\n\treturn nil\n}\n\nfunc maybeSwitchToInactive() {\n\tcmdline, err := readCmdline()\n\tif err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\tlog.Printf(\"cmdline: %s\", string(cmdline))\n\n\tif !strings.Contains(string(cmdline), \"gokrazy.try_boot_inactive=1\") {\n\t\treturn\n\t}\n\tlog.Printf(\"switching to inactive root partition\")\n\n\t// update the cmdline to have the device boot into the old environment next time\n\tif err := modifyCmdline(func(b []byte) []byte {\n\t\treturn bytes.ReplaceAll(b,\n\t\t\t[]byte(\"gokrazy.try_boot_inactive=1\"),\n\t\t\t[]byte(\"gokrazy.switch_on_boot=1\"))\n\t}); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n\n\t// switch to the inactive root partition instead\n\tif err := switchToInactiveRoot(); err != nil {\n\t\tlog.Print(err)\n\t\treturn\n\t}\n}\n\n// Boot configures basic system settings. More specifically, it:\n//\n//   - mounts /dev, /tmp, /proc, /sys and /perm file systems\n//   - mounts and populate /etc tmpfs overlay\n//   - sets hostname from the /etc/hostname file\n//   - sets HTTP password from the gokr-pw.txt file\n//   - configures the loopback network interface\n//\n// Boot should always be called to transition the machine into a\n// useful state, even in custom init process implementations or\n// single-process applications.\n//\n// userBuildTimestamp will be exposed on the HTTP status handlers that\n// are set up by Supervise.\nfunc Boot(userBuildTimestamp string) error {\n\t// TODO: think about whether the watchdog needs a different setup during the\n\t// update process\n\tgo runWatchdog()\n\n\tbuildTimestamp = userBuildTimestamp\n\n\tif err := mountfs(); err != nil {\n\t\treturn err\n\t}\n\n\tmaybeSwitchToInactive()\n\n\tif err := loadModules(); err != nil {\n\t\tlog.Printf(\"loading modules: %v\", err)\n\t}\n\n\thostnameb, err := ioutil.ReadFile(\"/etc/hostname\")\n\tif err != nil && os.IsNotExist(err) {\n\t\thostnameb, err = ioutil.ReadFile(\"/hostname\")\n\t}\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := unix.Sethostname(hostnameb); err != nil {\n\t\treturn err\n\t}\n\thostname = string(hostnameb)\n\n\thttpPassword, err = readConfigFile(\"gokr-pw.txt\")\n\tif err != nil && !os.IsNotExist(err) {\n\t\t// Only return an error for e.g. corruption reasons.\n\t\t// The file may legitimately be absent if the image\n\t\t// was built with NoPassword. In that case,\n\t\t// httpPassword remains the empty string, meaning\n\t\t// no access other than via unix socket.\n\t\treturn err\n\t}\n\n\tif err := configureLoopback(); err != nil {\n\t\treturn err\n\t}\n\n\tinitRemoteSyslog()\n\tif err := setupTLS(); err != nil {\n\t\treturn err\n\t}\n\n\t// create /dev/serial0 symlink in /dev, which was mounted by mountfs() earlier\n\tif err := createSerialSymlink(); err != nil {\n\t\tlog.Printf(\"creating serial symlink failed: %v\", err)\n\t}\n\n\t// create a /dev/ttyAMA0 symlink to /dev/ttyS0 so that software which does\n\t// not yet use /dev/serial0 keeps working without changes.\n\tif err := os.Symlink(\"/dev/ttyS0\", \"/dev/ttyAMA0\"); err != nil && !os.IsExist(err) {\n\t\tlog.Printf(\"creating compatibility symlink /dev/ttyAMA0 -> /dev/ttyS0 failed: %v\", err)\n\t}\n\n\tif err := pollPowerButtons(); err != nil {\n\t\tlog.Printf(\"polling power buttons: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc createSerialSymlink() error {\n\tuart0, uart0err := ioutil.ReadFile(\"/proc/device-tree/aliases/uart0\")\n\tuart1, uart1err := ioutil.ReadFile(\"/proc/device-tree/aliases/uart1\")\n\tserial0, serial0err := ioutil.ReadFile(\"/proc/device-tree/aliases/serial0\")\n\tif uart0err == nil && serial0err == nil && bytes.Equal(uart0, serial0) {\n\t\t// old kernel (before https://github.com/gokrazy/gokrazy/issues/49)\n\t\treturn os.Symlink(\"/dev/ttyAMA0\", \"/dev/serial0\")\n\t} else if os.IsNotExist(uart1err) ||\n\t\t(uart1err == nil && serial0err == nil && bytes.Equal(uart1, serial0)) {\n\t\t// new kernel (after https://github.com/gokrazy/gokrazy/issues/49)\n\t\treturn os.Symlink(\"/dev/ttyS0\", \"/dev/serial0\")\n\t}\n\treturn fmt.Errorf(\"unexpected device tree state: uart0=%s, %v / uart1=%s, %v / serial0=%s, %v\", string(uart0), uart0err, string(uart1), uart1err, string(serial0), serial0err)\n}\n\nfunc updateListenerPairs(httpPort, httpsPort string, useTLS bool, tlsConfig *tls.Config) error {\n\tif err := updateListeners(httpPort, httpsPort, useTLS, nil); err != nil {\n\t\treturn err\n\t}\n\tif useTLS {\n\t\tif err := updateListeners(httpsPort, \"\", useTLS, tlsConfig); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// By default, stdio is open on /dev/console which cannot be a controlling tty\n// so set up stdio on a normal tty (e.g. tty1, ttyS0, ttyAMA0)\n// See https://busybox.net/FAQ.html#job_control\nfunc runWithCtty(shell string) error {\n\t// find TTY device connected to /dev/console\n\t// https://www.kernel.org/doc/Documentation/ABI/testing/sysfs-tty\n\tbuf, err := ioutil.ReadFile(\"/sys/class/tty/console/active\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdevs := strings.Split(strings.TrimSpace(string(buf)), \" \")\n\tttyDev := \"/dev/\" + devs[len(devs)-1]\n\n\tstdin, err := os.OpenFile(ttyDev, os.O_RDWR, 0600)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stdin: %v\", err)\n\t}\n\tdefer stdin.Close()\n\n\tstdout, err := os.OpenFile(ttyDev, os.O_RDWR, 0600)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stdout: %v\", err)\n\t}\n\tdefer stdout.Close()\n\n\tstderr, err := os.OpenFile(ttyDev, os.O_RDWR, 0600)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"stderr: %v\", err)\n\t}\n\tdefer stderr.Close()\n\n\tsh := exec.Command(shell)\n\tsh.Stdin = stdin\n\tsh.Stdout = stdout\n\tsh.Stderr = stderr\n\tsh.SysProcAttr = &syscall.SysProcAttr{\n\t\tSetsid:  true,\n\t\tSetctty: true,\n\t\tCtty:    0,\n\t}\n\n\treturn sh.Run()\n}\n\nfunc tryStartShell() error {\n\tvar lastErr error\n\tfor _, shell := range []string{\n\t\t\"/tmp/serial-busybox/ash\",\n\t\t\"/perm/sh\",\n\t} {\n\t\t_, err := os.Stat(shell)\n\t\tlastErr = err\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tlog.Printf(\"starting shell %s upon input on serial console\", shell)\n\n\t\tif err := runWithCtty(shell); err != nil {\n\t\t\tlog.Printf(\"runWithCtty: %v\", err)\n\t\t\tlastErr = err\n\t\t}\n\t\treturn nil\n\t}\n\treturn lastErr\n}\n\n// Service is a gokrazy service.\ntype Service struct {\n\t// TODO: refactor the fields of service into this type, but\n\t// visibility-restricted.\n\ts *service\n}\n\nfunc newService(cmd *exec.Cmd, stopped, waitForClock bool) *Service {\n\ts := &service{\n\t\tcmd:          cmd,\n\t\tstopped:      stopped,\n\t\twaitForClock: waitForClock,\n\t}\n\n\ts.state = NewProcessState()\n\n\ttag := filepath.Base(s.Cmd().Path)\n\ts.Stdout = newLogWriter(tag)\n\ts.Stderr = newLogWriter(tag)\n\n\treturn &Service{s}\n}\n\n// NewService constructs a new gokrazy service from the specified command.\nfunc NewService(cmd *exec.Cmd) *Service {\n\treturn newService(cmd, false, false)\n}\n\n// NewStoppedService is like NewService, but the created gokrazy service will\n// not be supervised, i.e. remain stopped on boot.\nfunc NewStoppedService(cmd *exec.Cmd) *Service {\n\treturn newService(cmd, true, false)\n}\n\n// NewWaitForClockService is like NewService, but the created gokrazy service\n// will wait for clock to be synchronized, i.e. blocked till the clock is accurate.\nfunc NewWaitForClockService(cmd *exec.Cmd) *Service {\n\treturn newService(cmd, false, true)\n}\n\n// Supervise runs SuperviseServices, creating services from commands.\n//\n// Deprecated: newer versions of gokr-packer run gokrazy.SuperviseServices()\n// instead\nfunc Supervise(commands []*exec.Cmd) error {\n\tservices := make([]*Service, len(commands))\n\tfor idx, cmd := range commands {\n\t\tservices[idx] = &Service{&service{cmd: cmd}}\n\t}\n\treturn SuperviseServices(services)\n}\n\n// SuperviseServices continuously restarts the processes specified in services\n// unless they run DontStartOnBoot.\n//\n// Password-protected HTTP handlers are installed, allowing to inspect\n// the supervised services and update the gokrazy installation over\n// the network.\n//\n// HTTP is served on PrivateInterfaceAddrs(). New IP addresses will be\n// picked up upon receiving SIGHUP.\nfunc SuperviseServices(services []*Service) error {\n\tunwrapped := make([]*service, len(services))\n\tfor idx, svc := range services {\n\t\tunwrapped[idx] = svc.s\n\t}\n\n\tvar err error\n\tlastInstalledEepromVersion, err = readLastInstalledEepromVersion()\n\tif err != nil {\n\t\tlog.Printf(\"getting EEPROM version: %v\", err)\n\t}\n\n\tinitStatus()\n\tsetupDeviceSpecifics()\n\n\tif err := initUpdate(); err != nil {\n\t\treturn err\n\t}\n\n\thttpPort := readPortFromConfigFile(\"http-port.txt\", \"80\")\n\thttpsPort := readPortFromConfigFile(\"https-port.txt\", \"443\")\n\n\tif err := updateListenerPairs(httpPort, httpsPort, useTLS, tlsConfig); err != nil {\n\t\treturn fmt.Errorf(\"updating listeners: %v\", err)\n\t}\n\n\tif nl, err := listenNetlink(); err == nil {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tmsgs, err := nl.ReadMsgs()\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"netlink.ReadMsgs: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tfor _, m := range msgs {\n\t\t\t\t\tif m.Header.Type != syscall.RTM_NEWADDR &&\n\t\t\t\t\t\tm.Header.Type != syscall.RTM_DELADDR {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tif err := updateListenerPairs(httpPort, httpsPort, useTLS, tlsConfig); err != nil {\n\t\t\t\t\t\tlog.Printf(\"updating listeners: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t} else {\n\t\tlog.Printf(\"cannot listen for new IP addresses: %v\", err)\n\t}\n\n\tlistenForSignals(func() {\n\t\tif err := updateListenerPairs(httpPort, httpsPort, useTLS, tlsConfig); err != nil {\n\t\t\tlog.Printf(\"updating listeners: %v\", err)\n\t\t}\n\t})\n\n\t// Only supervise services after the SIGHUP handler is set up, otherwise a\n\t// particularly fast dhcp client (e.g. when running in qemu) might send\n\t// SIGHUP before the signal handler is set up, thereby killing init and\n\t// panic the system!\n\tsuperviseServices(unwrapped)\n\n\tgo func() {\n\t\tbuf := make([]byte, 1)\n\t\tfor {\n\t\t\tif _, err := os.Stdin.Read(buf); err != nil {\n\t\t\t\tlog.Printf(\"read(stdin): %v\", err)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tif err := tryStartShell(); err != nil {\n\t\t\t\tlog.Printf(\"could not start shell: %v\", err)\n\t\t\t\tif err := updateListenerPairs(httpPort, httpsPort, useTLS, tlsConfig); err != nil {\n\t\t\t\t\tlog.Printf(\"updating listeners: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn nil\n}\n\n// WaitForClock returns once the system clock appears to have been\n// set. Assumes that the system boots with a clock value of January 1,\n// 1970 UTC (UNIX epoch), as is the case on the Raspberry Pi 3.\nfunc WaitForClock() {\n\tepochPlus1Year := time.Unix(60*60*24*365, 0)\n\tfor {\n\t\tif time.Now().After(epochPlus1Year) {\n\t\t\treturn\n\t\t}\n\t\t// Sleeps for 1 real second, regardless of wall-clock time.\n\t\t// See https://github.com/golang/proposal/blob/master/design/12914-monotonic.md\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\n// DontStartOnBoot informs the gokrazy init process to not supervise\n// the process and exits. The user can manually start supervision,\n// which turns DontStartOnBoot into a no-op.\nfunc DontStartOnBoot() {\n\tif os.Getenv(\"GOKRAZY_FIRST_START\") == \"1\" {\n\t\tos.Exit(125)\n\t}\n}\n"
        },
        {
          "name": "httpsredirect.go",
          "type": "blob",
          "size": 0.3720703125,
          "content": "package gokrazy\n\nimport (\n\t\"net/http\"\n)\n\nfunc httpsRedirect(redirectPort string) func(w http.ResponseWriter, r *http.Request) {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tr.URL.Host = r.Host\n\t\tif redirectPort != \"443\" {\n\t\t\tr.URL.Host += \":\" + redirectPort\n\t\t}\n\t\tr.URL.Scheme = \"https\"\n\t\thttp.Redirect(w, r, r.URL.String(), http.StatusFound) // Redirect to https\n\t}\n}\n"
        },
        {
          "name": "ifaddr",
          "type": "tree",
          "content": null
        },
        {
          "name": "integration",
          "type": "tree",
          "content": null
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "listeners.go",
          "type": "blob",
          "size": 3.6796875,
          "content": "package gokrazy\n\nimport (\n\t\"crypto/tls\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/gokrazy/gokrazy/ifaddr\"\n)\n\n// IsInPrivateNet reports whether the specified IP address is a private address,\n// including loopback and link-local unicast addresses.\nfunc IsInPrivateNet(ip net.IP) bool {\n\treturn ifaddr.IsInPrivateNet(ip)\n}\n\n// PrivateInterfaceAddrs returns all private (as per RFC1918, RFC4193,\n// RFC3330, RFC3513, RFC3927, RFC4291) host addresses of all active\n// interfaces, suitable to be passed to net.JoinHostPort.\nfunc PrivateInterfaceAddrs() ([]string, error) {\n\treturn ifaddr.PrivateInterfaceAddrs()\n}\n\n// PublicInterfaceAddrs returns all public (excluding RFC1918, RFC4193,\n// RFC3330, RFC3513, RFC3927, RFC4291) host addresses of all active\n// interfaces, suitable to be passed to net.JoinHostPort.\nfunc PublicInterfaceAddrs() ([]string, error) {\n\treturn ifaddr.PublicInterfaceAddrs()\n}\n\n// Wrapper to keep track of allocated servers per host\ntype krazyServer struct {\n\tsrv  *http.Server\n\tport string\n}\n\nvar (\n\tlistenersMu sync.Mutex\n\tlisteners   = make(map[string][]*krazyServer) // by private IP address or unix socket path\n)\n\n// gokrazyHTTPUnixSocket is the unix socket path that\n// the HTTP server listens on when httpPassword is empty.\nconst gokrazyHTTPUnixSocket = \"/run/gokrazy-http.sock\"\n\n// tlsConfig: tlsConfig. nil, if the listeners should not use https (e.g. for redirects)\nfunc updateListeners(port, redirectPort string, tlsEnabled bool, tlsConfig *tls.Config) error {\n\tvar hosts []string // private IP addresses or unix socket path\n\tvar err error\n\n\t// If NoPassword is used, the HTTP server doesn't run over HTTP\n\t// and instead only listens on a Unix socket. Packages running\n\t// in the appliance can proxy to the Unix socket as desired.\n\tif httpPassword == \"\" {\n\t\thosts = []string{gokrazyHTTPUnixSocket}\n\t} else {\n\t\thosts, err = PrivateInterfaceAddrs()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tlistenersMu.Lock()\n\tdefer listenersMu.Unlock()\n\tvanished := make(map[string]bool)\n\tfor host := range listeners {\n\t\tvanished[host] = false\n\t}\n\tfor _, host := range hosts {\n\t\tif servers, ok := listeners[host]; ok {\n\t\t\t// confirm found\n\t\t\tdelete(vanished, host)\n\t\t\tcont := false\n\t\t\tfor _, server := range servers {\n\t\t\t\tif server.port == port {\n\t\t\t\t\tcont = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif cont {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\t\tvar ln net.Listener\n\t\tvar addr string\n\t\tif strings.HasPrefix(host, \"/\") {\n\t\t\t// Unix socket\n\t\t\tln, err = net.Listen(\"unix\", host)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"listen: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"now listening on %s\", host)\n\t\t} else {\n\t\t\taddr = net.JoinHostPort(host, port)\n\t\t\tln, err = net.Listen(\"tcp\", addr)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"listen: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlog.Printf(\"now listening on %s\", addr)\n\t\t}\n\t\t// add a new listener\n\t\tvar srv *http.Server\n\t\tif tlsEnabled && tlsConfig == nil {\n\t\t\t// \"Redirect\" server\n\t\t\tsrv = &http.Server{\n\t\t\t\tHandler:   http.HandlerFunc(httpsRedirect(redirectPort)),\n\t\t\t\tTLSConfig: tlsConfig,\n\t\t\t}\n\t\t} else {\n\t\t\t// \"Content\" server\n\t\t\tsrv = &http.Server{\n\t\t\t\tHandler:   http.HandlerFunc(authenticated),\n\t\t\t\tTLSConfig: tlsConfig,\n\t\t\t}\n\t\t}\n\t\tlisteners[host] = append(listeners[host], &krazyServer{srv, port})\n\t\tgo func(host string, srv *http.Server) {\n\t\t\tvar err error\n\t\t\tif tlsEnabled && tlsConfig != nil {\n\t\t\t\terr = srv.ServeTLS(ln, \"\", \"\")\n\t\t\t} else {\n\t\t\t\terr = srv.Serve(ln)\n\t\t\t}\n\t\t\tlog.Printf(\"serving on %s: %v\", addr, err)\n\t\t\tlistenersMu.Lock()\n\t\t\tdefer listenersMu.Unlock()\n\t\t\tdelete(listeners, host)\n\t\t}(host, srv)\n\n\t}\n\tfor host := range vanished {\n\t\tlog.Printf(\"no longer listening on %s\", net.JoinHostPort(host, port))\n\t\tfor _, server := range listeners[host] {\n\t\t\tserver.srv.Close()\n\t\t}\n\t\tdelete(listeners, host)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "machineid.go",
          "type": "blob",
          "size": 0.525390625,
          "content": "package gokrazy\n\nimport (\n\t\"os\"\n\t\"strings\"\n)\n\n// MachineID returns the machine id (see\n// https://manpages.debian.org/machine-id.5) of the running gokrazy instance.\n//\n// `gok new` creates a random machine id, but on older gokrazy installations,\n// the hostname is used as a fallback.\nfunc MachineID() string {\n\tfor _, fn := range []string{\n\t\t\"/perm/machine-id\",\n\t\t\"/etc/machine-id\",\n\t\t\"/etc/hostname\",\n\t} {\n\t\tb, err := os.ReadFile(fn)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\treturn strings.TrimSpace(string(b))\n\t}\n\treturn \"machine-id-BUG\"\n}\n"
        },
        {
          "name": "modules.go",
          "type": "blob",
          "size": 1.11328125,
          "content": "package gokrazy\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc getRelease() string {\n\tvar uts unix.Utsname\n\tif err := unix.Uname(&uts); err != nil {\n\t\tfmt.Fprintf(os.Stderr, \"minitrd: %v\\n\", err)\n\t\treturn \"\"\n\t}\n\treturn string(uts.Release[:bytes.IndexByte(uts.Release[:], 0)])\n}\n\nfunc loadModule(release, mod string) error {\n\tf, err := os.Open(filepath.Join(\"/lib/modules\", release, mod))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\tif err := unix.FinitModule(int(f.Fd()), \"\", 0); err != nil {\n\t\tif err != unix.EEXIST &&\n\t\t\terr != unix.EBUSY &&\n\t\t\terr != unix.ENODEV &&\n\t\t\terr != unix.ENOENT {\n\t\t\treturn fmt.Errorf(\"FinitModule(%v): %v\", mod, err)\n\t\t}\n\t}\n\treturn nil\n}\n\n// loadModules currently contains a hard-coded list of modules but can be\n// extended to read a configuration file.\nfunc loadModules() error {\n\t// The Raspberry Pi 5 needs the pwm-fan module to be loaded for fan control\n\t// to work. We do not build it into the kernel so that users can unload the\n\t// module if they want to use their own custom fan control.\n\treturn loadModule(getRelease(), \"kernel/drivers/hwmon/pwm-fan.ko\")\n}\n"
        },
        {
          "name": "mount.go",
          "type": "blob",
          "size": 10.1064453125,
          "content": "package gokrazy\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/gokrazy/internal/config\"\n\t\"github.com/gokrazy/internal/gpt\"\n\t\"github.com/gokrazy/internal/rootdev\"\n)\n\nvar flagKeywords = map[string]struct {\n\tclear bool\n\tflag  uintptr\n}{\n\t\"ro\":            {false, unix.MS_RDONLY},\n\t\"rw\":            {true, unix.MS_RDONLY},\n\t\"suid\":          {true, unix.MS_NOSUID},\n\t\"nosuid\":        {false, unix.MS_NOSUID},\n\t\"dev\":           {true, unix.MS_NODEV},\n\t\"nodev\":         {false, unix.MS_NODEV},\n\t\"exec\":          {true, unix.MS_NOEXEC},\n\t\"noexec\":        {false, unix.MS_NOEXEC},\n\t\"sync\":          {false, unix.MS_SYNCHRONOUS},\n\t\"async\":         {true, unix.MS_SYNCHRONOUS},\n\t\"dirsync\":       {false, unix.MS_DIRSYNC},\n\t\"remount\":       {false, unix.MS_REMOUNT},\n\t\"mand\":          {false, unix.MS_MANDLOCK},\n\t\"nomand\":        {true, unix.MS_MANDLOCK},\n\t\"atime\":         {true, unix.MS_NOATIME},\n\t\"noatime\":       {false, unix.MS_NOATIME},\n\t\"diratime\":      {true, unix.MS_NODIRATIME},\n\t\"nodiratime\":    {false, unix.MS_NODIRATIME},\n\t\"bind\":          {false, unix.MS_BIND},\n\t\"rbind\":         {false, unix.MS_BIND | unix.MS_REC},\n\t\"unbindable\":    {false, unix.MS_UNBINDABLE},\n\t\"runbindable\":   {false, unix.MS_UNBINDABLE | unix.MS_REC},\n\t\"private\":       {false, unix.MS_PRIVATE},\n\t\"rprivate\":      {false, unix.MS_PRIVATE | unix.MS_REC},\n\t\"shared\":        {false, unix.MS_SHARED},\n\t\"rshared\":       {false, unix.MS_SLAVE | unix.MS_REC},\n\t\"slave\":         {false, unix.MS_SLAVE},\n\t\"rslave\":        {false, unix.MS_SHARED | unix.MS_REC},\n\t\"relatime\":      {false, unix.MS_RELATIME},\n\t\"norelatime\":    {true, unix.MS_RELATIME},\n\t\"strictatime\":   {false, unix.MS_STRICTATIME},\n\t\"nostrictatime\": {true, unix.MS_STRICTATIME},\n}\n\n// mountCompat deals with old FAT root file systems, to cover the case where\n// users use an old gokr-packer with a new github.com/gokrazy/gokrazy package.\nfunc mountCompat() error {\n\t// Symlink /etc/resolv.conf. We cannot do this in the root file\n\t// system itself, as FAT does not support symlinks.\n\tif err := syscall.Mount(\"tmpfs\", \"/etc\", \"tmpfs\", syscall.MS_NOSUID|syscall.MS_NODEV|syscall.MS_RELATIME, \"size=1M\"); err != nil {\n\t\treturn fmt.Errorf(\"tmpfs on /etc: %v\", err)\n\t}\n\n\tif err := os.Symlink(\"/proc/net/pnp\", \"/etc/resolv.conf\"); err != nil {\n\t\treturn fmt.Errorf(\"etc: %v\", err)\n\t}\n\n\t// Symlink /etc/localtime. We cannot do this in the root file\n\t// system, as FAT filenames are limited to 8.3.\n\tif err := os.Symlink(\"/localtim\", \"/etc/localtime\"); err != nil {\n\t\treturn fmt.Errorf(\"etc: %v\", err)\n\t}\n\n\tif err := os.Mkdir(\"/etc/ssl\", 0755); err != nil {\n\t\treturn fmt.Errorf(\"/etc/ssl: %v\", err)\n\t}\n\n\tif err := os.Symlink(\"/cacerts\", \"/etc/ssl/ca-bundle.pem\"); err != nil {\n\t\treturn fmt.Errorf(\"/etc/ssl: %v\", err)\n\t}\n\n\tif err := ioutil.WriteFile(\"/etc/hosts\", []byte(\"127.0.0.1 localhost\\n::1 localhost\\n\"), 0644); err != nil {\n\t\treturn fmt.Errorf(\"/etc/hosts: %v\", err)\n\t}\n\treturn nil\n}\n\nfunc mountfs() error {\n\tif err := syscall.Mount(\"tmpfs\", \"/tmp\", \"tmpfs\", syscall.MS_NOSUID|syscall.MS_NODEV|syscall.MS_RELATIME, \"\"); err != nil {\n\t\treturn fmt.Errorf(\"tmpfs on /tmp: %v\", err)\n\t}\n\n\tif err := os.Symlink(\"/proc/net/pnp\", \"/tmp/resolv.conf\"); err != nil {\n\t\treturn fmt.Errorf(\"etc: %v\", err)\n\t}\n\n\tif _, err := os.Lstat(\"/etc/resolv.conf\"); err != nil && os.IsNotExist(err) {\n\t\tif err := mountCompat(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := syscall.Mount(\"devtmpfs\", \"/dev\", \"devtmpfs\", 0, \"\"); err != nil {\n\t\tif sce, ok := err.(syscall.Errno); ok && sce == syscall.EBUSY {\n\t\t\t// /dev was already mounted (common in setups using nfsroot= or initramfs)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"devtmpfs: %v\", err)\n\t\t}\n\t}\n\n\tif err := os.MkdirAll(\"/dev/pts\", 0755); err != nil {\n\t\treturn fmt.Errorf(\"mkdir /dev/pts: %v\", err)\n\t}\n\n\tif err := syscall.Mount(\"devpts\", \"/dev/pts\", \"devpts\", 0, \"\"); err != nil {\n\t\treturn fmt.Errorf(\"devpts: %v\", err)\n\t}\n\n\tif err := os.MkdirAll(\"/dev/shm\", 0755); err != nil {\n\t\treturn fmt.Errorf(\"mkdir /dev/shm: %v\", err)\n\t}\n\n\tif err := syscall.Mount(\"tmpfs\", \"/dev/shm\", \"tmpfs\", 0, \"\"); err != nil {\n\t\treturn fmt.Errorf(\"tmpfs on /dev/shm: %v\", err)\n\t}\n\n\tif err := syscall.Mount(\"tmpfs\", \"/run\", \"tmpfs\", 0, \"\"); err != nil {\n\t\tlog.Printf(\"tmpfs on /run: %v\", err)\n\t}\n\n\t// /proc is useful for exposing process details and for\n\t// interactive debugging sessions.\n\tif err := syscall.Mount(\"proc\", \"/proc\", \"proc\", 0, \"\"); err != nil {\n\t\tif sce, ok := err.(syscall.Errno); ok && sce == syscall.EBUSY {\n\t\t\t// /proc was already mounted (common in setups using nfsroot= or initramfs)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"proc: %v\", err)\n\t\t}\n\t}\n\n\t// /sys is useful for retrieving additional status from the\n\t// kernel, e.g. ethernet device carrier status.\n\tif err := syscall.Mount(\"sysfs\", \"/sys\", \"sysfs\", 0, \"\"); err != nil {\n\t\tif sce, ok := err.(syscall.Errno); ok && sce == syscall.EBUSY {\n\t\t\t// /sys was already mounted (common in setups using nfsroot= or initramfs)\n\t\t} else {\n\t\t\treturn fmt.Errorf(\"sys: %v\", err)\n\t\t}\n\t}\n\n\tdev := rootdev.Partition(rootdev.Perm)\n\tfor _, fstype := range []string{\"ext4\", \"vfat\", \"bcachefs\"} {\n\t\tif err := syscall.Mount(dev, \"/perm\", fstype, 0, \"\"); err != nil {\n\t\t\tlog.Printf(\"Could not mount permanent storage partition %s as %s: %v\", dev, fstype, err)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Create /perm/var if needed so that the /var symlink resolves\n\tif err := os.MkdirAll(\"/perm/var\", 0755); err != nil {\n\t\tlog.Printf(\"mkdir /perm/var: %v\", err)\n\t}\n\n\tif err := os.Symlink(\"/run\", \"/perm/var/run\"); err != nil && !os.IsExist(err) {\n\t\tlog.Printf(\"symlink /perm/var/run to /run: %v\", err)\n\t}\n\n\tif err := syscall.Mount(\"cgroup2\", \"/sys/fs/cgroup\", \"cgroup2\", 0, \"\"); err != nil {\n\t\tlog.Printf(\"cgroup2 on /sys/fs/cgroup: %v\", err)\n\t}\n\n\tif err := mountDevices(); err != nil {\n\t\tlog.Printf(\"mountDevices: %v\", err)\n\t}\n\n\treturn nil\n}\n\nfunc findGPTPartUUID(uuid string) (_ string, _ error) {\n\tvar dev string\n\tuuid = strings.ToLower(uuid)\n\terr := filepath.Walk(\"/sys/block\", func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\tlog.Printf(\"findGPTPartUUID: %v\", err)\n\t\t\treturn nil\n\t\t}\n\t\tif info.Mode()&os.ModeSymlink == 0 {\n\t\t\treturn nil\n\t\t}\n\t\tdevname := \"/dev/\" + filepath.Base(path)\n\t\tf, err := os.Open(devname)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"findGPTPartUUID: %v\", err)\n\t\t\treturn nil\n\t\t}\n\t\tdefer f.Close()\n\t\tfor idx, partUUID := range gpt.PartitionUUIDs(f) {\n\t\t\tif strings.ToLower(partUUID) != uuid {\n\t\t\t\tif partUUID != \"00000000-0000-0000-0000-000000000000\" {\n\t\t\t\t\tlog.Printf(\"  not matching: %s with PARTUUID=%s\", devname, partUUID)\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdev = devname\n\t\t\tif (strings.HasPrefix(dev, \"/dev/mmcblk\") ||\n\t\t\t\tstrings.HasPrefix(dev, \"/dev/loop\") ||\n\t\t\t\tstrings.HasPrefix(dev, \"/dev/nvme\")) &&\n\t\t\t\t!strings.HasSuffix(dev, \"p\") {\n\t\t\t\tdev += \"p\"\n\t\t\t}\n\t\t\tdev += strconv.Itoa(idx + 1)\n\n\t\t\t// TODO: abort early with sentinel error code\n\t\t\treturn nil\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif dev == \"\" {\n\t\treturn \"\", fmt.Errorf(\"PARTUUID=%s not found\", uuid)\n\t}\n\treturn dev, nil\n}\n\nfunc findFilesystemUUID(uuid string) (string, error) {\n\tvar dev string\n\tuuid = strings.ToLower(uuid)\n\tdirents, err := os.ReadDir(\"/dev\")\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tfor _, de := range dirents {\n\t\tdev := de.Name()\n\t\tif strings.HasPrefix(dev, \"mmcblk\") ||\n\t\t\tstrings.HasPrefix(dev, \"loop\") ||\n\t\t\tstrings.HasPrefix(dev, \"nvme\") ||\n\t\t\tstrings.HasPrefix(dev, \"sd\") ||\n\t\t\tstrings.HasPrefix(dev, \"hd\") ||\n\t\t\tstrings.HasPrefix(dev, \"vd\") {\n\t\t\tdevname := filepath.Join(\"/dev\", dev)\n\t\t\tf, err := os.Open(devname)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"findFilesystemUUID: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdefer f.Close()\n\t\t\tfsUUID, err := probeExt4(f)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"probeExt4(%s): %v\", dev, err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif strings.ToLower(fsUUID) == uuid {\n\t\t\t\treturn devname, nil\n\t\t\t}\n\t\t\tlog.Printf(\"  not matching: %s with UUID=%s\", devname, fsUUID)\n\t\t}\n\t}\n\tif dev == \"\" {\n\t\treturn \"\", fmt.Errorf(\"UUID=%s not found\", uuid)\n\t}\n\treturn dev, nil\n}\n\nfunc deviceForSource(source string) (string, error) {\n\tif strings.HasPrefix(source, \"PARTUUID=\") {\n\t\treturn findGPTPartUUID(strings.TrimPrefix(source, \"PARTUUID=\"))\n\t}\n\tif strings.HasPrefix(source, \"UUID=\") {\n\t\treturn findFilesystemUUID(strings.TrimPrefix(source, \"UUID=\"))\n\t}\n\n\treturn source, nil\n}\n\n// Parse a comma-delimited mount options string into the flags and data\n// arguments which may be passed to syscall.Mount.\n// This function is derived from github.com/moby/sys.\nfunc parseMountOptions(options string) (uintptr, string) {\n\tvar (\n\t\tflags uintptr\n\t\tdata  []string\n\t)\n\n\tfor _, o := range strings.Split(options, \",\") {\n\t\t// If the option does not exist in the flags table, it is a data value\n\t\t// for a specific fs type\n\t\tif f, exists := flagKeywords[o]; exists && f.flag != 0 {\n\t\t\tif f.clear {\n\t\t\t\tflags &= ^f.flag\n\t\t\t} else {\n\t\t\t\tflags |= f.flag\n\t\t\t}\n\t\t} else {\n\t\t\tdata = append(data, o)\n\t\t}\n\t}\n\treturn flags, strings.Join(data, \",\")\n\n}\n\nfunc mountDevice(md config.MountDevice) error {\n\tdev, err := deviceForSource(md.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tflags, data := parseMountOptions(md.Options)\n\n\toptions := \"\"\n\tif md.Options != \"\" {\n\t\toptions = \" with options: \" + md.Options\n\t}\n\tlog.Printf(\"mounting %s on %s%s\", dev, md.Target, options)\n\tif err := syscall.Mount(dev, md.Target, md.Type, flags, data); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// mountDevices mounts the user-specified devices. The packer persists them from\n// the instance config to mountdevices.json.\nfunc mountDevices() error {\n\tb, err := os.ReadFile(\"/etc/gokrazy/mountdevices.json\")\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil // packer too old\n\t\t}\n\t\treturn fmt.Errorf(\"reading mountdevices.json: %v\", err)\n\t}\n\n\tvar mountdevices []config.MountDevice\n\tif err := json.Unmarshal(b, &mountdevices); err != nil {\n\t\treturn err\n\t}\n\n\t// Start one goroutine per mount device\n\tfor _, md := range mountdevices {\n\t\tmd := md // remove once we are on Go 1.22\n\t\tgo func() {\n\t\t\tfor attempt := 0; ; attempt++ {\n\t\t\t\terr := mountDevice(md)\n\t\t\t\tif err == nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlog.Printf(\"mounting %s: %v\", md.Source, err)\n\t\t\t\tif attempt < 10 {\n\t\t\t\t\ttime.Sleep(1 * time.Second)\n\t\t\t\t} else {\n\t\t\t\t\ttime.Sleep(5 * time.Second)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "mountext4.go",
          "type": "blob",
          "size": 1.6455078125,
          "content": "package gokrazy\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc probeExt4(r io.ReadSeeker) (string, error) {\n\t// probe ext4\n\tconst extSuperblockOffset = 0x400\n\tif _, err := r.Seek(extSuperblockOffset, io.SeekStart); err != nil {\n\t\treturn \"\", err\n\t}\n\tvar sb ext2SuperBlock\n\tif err := binary.Read(r, binary.LittleEndian, &sb); err != nil {\n\t\treturn \"\", err\n\t}\n\tif sb.Magic != 0xef53 {\n\t\treturn \"\", fmt.Errorf(\"no ext4 superblock found\")\n\t}\n\tbuf := sb.UUID\n\treturn fmt.Sprintf(\n\t\t\"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n\t\tbuf[0], buf[1], buf[2], buf[3],\n\t\tbuf[4], buf[5],\n\t\tbuf[6], buf[7],\n\t\tbuf[8], buf[9],\n\t\tbuf[10], buf[11], buf[12], buf[13], buf[14], buf[15]), nil\n}\n\ntype ext2SuperBlock struct {\n\tInodesCount         uint32\n\tBlocksCount         uint32\n\tReservedBlocksCount uint32\n\tFreeBlocksCount     uint32\n\tFreeInodesCount     uint32\n\tFirstDataBlock      uint32\n\tLogBlockSize        uint32\n\tLogFragSize         int32\n\tBlocksPerGroup      uint32\n\tFragsPerGroup       uint32\n\tInodesPerGroup      uint32\n\tMtime               uint32\n\tWtime               uint32\n\tMountCount          uint16\n\tMaxMountCount       int16\n\tMagic               uint16\n\tState               uint16\n\tErrors              uint16\n\tMinorRevLevel       uint16\n\tLastCheck           uint32\n\tCheckInterval       uint32\n\tCreatorOS           uint32\n\tRevLevel            uint32\n\tDefResuid           uint16\n\tDefResgid           uint16\n\tFirstIno            uint32\n\tInodeSize           uint16\n\tBlockGroupNr        uint16\n\tFeatureCompat       uint32\n\tFeatureIncompat     uint32\n\tFeatureRoCompat     uint32\n\tUUID                [16]uint8\n\n\t// remaining fields elided (irrelevant for probing)\n}\n"
        },
        {
          "name": "netlink.go",
          "type": "blob",
          "size": 1.0478515625,
          "content": "package gokrazy\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"syscall\"\n)\n\ntype netlinkListener struct {\n\tfd  int\n\tbuf []byte\n}\n\nfunc listenNetlink() (*netlinkListener, error) {\n\tfd, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_DGRAM, syscall.NETLINK_ROUTE)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"socket(AF_NETLINK, SOCK_DGRAM, NETLINK_ROUTE): %v\", err)\n\t}\n\n\tsaddr := &syscall.SockaddrNetlink{\n\t\tFamily: syscall.AF_NETLINK,\n\t\tGroups: (1 << (syscall.RTNLGRP_IPV4_IFADDR - 1)) |\n\t\t\t(1 << (syscall.RTNLGRP_IPV6_IFADDR - 1)),\n\t}\n\n\tif err := syscall.Bind(fd, saddr); err != nil {\n\t\treturn nil, fmt.Errorf(\"bind: %v\", err)\n\t}\n\n\treturn &netlinkListener{\n\t\tfd: fd,\n\t\t// use the page size as buffer size, like libnl\n\t\tbuf: make([]byte, os.Getpagesize()),\n\t}, nil\n}\n\nfunc (l *netlinkListener) ReadMsgs() ([]syscall.NetlinkMessage, error) {\n\tn, err := syscall.Read(l.fd, l.buf)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"Read: %v\", err)\n\t}\n\n\tmsgs, err := syscall.ParseNetlinkMessage(l.buf[:n])\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"ParseNetlinkMessage: %v\", err)\n\t}\n\n\treturn msgs, nil\n}\n"
        },
        {
          "name": "powerbutton.go",
          "type": "blob",
          "size": 1.1181640625,
          "content": "package gokrazy\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"path/filepath\"\n\n\t\"github.com/kenshaw/evdev\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc pollPowerButton1(path string) error {\n\tdev, err := evdev.OpenFile(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dev.Close()\n\n\tif !dev.KeyTypes()[evdev.KeyPower] {\n\t\treturn nil\n\t}\n\tlog.Printf(\"polling device %s for power button events\", path)\n\n\tch := dev.Poll(context.Background())\n\tfor event := range ch {\n\t\tk, ok := event.Type.(evdev.KeyType)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\tif k != evdev.KeyPower {\n\t\t\tcontinue\n\t\t}\n\t\tif event.Value != 1 {\n\t\t\tcontinue\n\t\t}\n\t\tlog.Printf(\"power pressed, event %+v\", event)\n\n\t\tkillSupervisedServicesAndUmountPerm(defaultSignalDelay)\n\n\t\tlog.Println(\"Powering off\")\n\t\tif err := unix.Reboot(unix.LINUX_REBOOT_CMD_POWER_OFF); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc pollPowerButtons() error {\n\tmatches, err := filepath.Glob(\"/dev/input/event*\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, match := range matches {\n\t\tmatch := match // copy\n\t\tgo func() {\n\t\t\tif err := pollPowerButton1(match); err != nil {\n\t\t\t\tlog.Printf(\"pollPowerButton1(%s): %v\", match, err)\n\t\t\t}\n\t\t}()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "proc.go",
          "type": "blob",
          "size": 0.9755859375,
          "content": "package gokrazy\n\nimport \"sync\"\n\ntype statusCode int32\n\nconst (\n\tStopped  statusCode = iota // Process not running\n\tRunning                    // Process was started and is very likely still running\n\tStopping                   // Process is being stopped, but it might still be running\n)\n\ntype processState struct {\n\tlock         sync.Mutex\n\tstatusChange *sync.Cond\n\tstatus       statusCode\n}\n\nfunc NewProcessState() *processState {\n\tp := &processState{}\n\tp.statusChange = sync.NewCond(&p.lock)\n\n\treturn p\n}\n\nfunc (p *processState) Get() statusCode {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\treturn p.status\n}\n\nfunc (p *processState) Set(status statusCode) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tif p.status == Stopped && status == Stopping {\n\t\t// Not a valid state transition. Ignore it.\n\t\treturn\n\t}\n\n\tp.status = status\n\tp.statusChange.Broadcast()\n}\n\nfunc (p *processState) WaitTill(status statusCode) {\n\tp.lock.Lock()\n\tdefer p.lock.Unlock()\n\n\tfor p.status != status {\n\t\tp.statusChange.Wait()\n\t}\n}\n"
        },
        {
          "name": "reboot.go",
          "type": "blob",
          "size": 0.1689453125,
          "content": "//go:build !amd64\n// +build !amd64\n\npackage gokrazy\n\nimport \"golang.org/x/sys/unix\"\n\nfunc reboot(tryKexec bool) error {\n\treturn unix.Reboot(unix.LINUX_REBOOT_CMD_RESTART)\n}\n"
        },
        {
          "name": "reboot_amd64.go",
          "type": "blob",
          "size": 1.0478515625,
          "content": "package gokrazy\n\nimport (\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"syscall\"\n\n\t\"github.com/gokrazy/internal/rootdev\"\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc kexecReboot() error {\n\ttmpdir, err := ioutil.TempDir(\"\", \"kexec\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := syscall.Mount(rootdev.Partition(rootdev.Boot), tmpdir, \"vfat\", 0, \"\"); err != nil {\n\t\treturn err\n\t}\n\n\tkernel, err := os.Open(filepath.Join(tmpdir, \"vmlinuz\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer kernel.Close()\n\tcmdline, err := ioutil.ReadFile(filepath.Join(tmpdir, \"cmdline.txt\"))\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tflags := unix.KEXEC_ARCH_DEFAULT | unix.KEXEC_FILE_NO_INITRAMFS\n\tif err := unix.KexecFileLoad(int(kernel.Fd()), 0, string(cmdline), flags); err != nil {\n\t\t// err is syscall.ENOSYS on kernels without CONFIG_KEXEC_FILE_LOAD=y\n\t\treturn err\n\t}\n\n\treturn unix.Reboot(unix.LINUX_REBOOT_CMD_KEXEC)\n}\n\nfunc reboot(tryKexec bool) error {\n\tif tryKexec {\n\t\tif err := kexecReboot(); err != nil {\n\t\t\tlog.Printf(\"kexec reboot failed: %v\", err)\n\t\t}\n\t}\n\treturn unix.Reboot(unix.LINUX_REBOOT_CMD_RESTART)\n}\n"
        },
        {
          "name": "sbom.go",
          "type": "blob",
          "size": 0.435546875,
          "content": "package gokrazy\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n)\n\nfunc ReadSBOM() (*json.RawMessage, string, error) {\n\tb, err := os.ReadFile(\"/etc/gokrazy/sbom.json\")\n\tif err != nil {\n\t\treturn nil, \"\", err\n\t}\n\n\ttype SBOMWithHash struct {\n\t\tSBOMHash string           `json:\"sbom_hash\"`\n\t\tSBOM     *json.RawMessage `json:\"sbom\"`\n\t}\n\tvar sh SBOMWithHash\n\tif err := json.Unmarshal(b, &sh); err != nil {\n\t\treturn nil, \"\", err\n\t}\n\treturn sh.SBOM, sh.SBOMHash, nil\n}\n"
        },
        {
          "name": "signals.go",
          "type": "blob",
          "size": 0.9267578125,
          "content": "package gokrazy\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"os/signal\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc listenForSignals(sighup func()) {\n\t{\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, unix.SIGHUP)\n\t\tgo func() {\n\t\t\tfor range c {\n\t\t\t\tsighup()\n\t\t\t}\n\t\t}()\n\t}\n\n\t{\n\t\tc := make(chan os.Signal, 1)\n\t\tsignal.Notify(c, unix.SIGTERM, unix.SIGUSR1, unix.SIGUSR2)\n\t\tgo func() {\n\t\t\tfor sig := range c {\n\t\t\t\tlog.Printf(\"received signal %s, killing services\", sig)\n\n\t\t\t\tkillSupervisedServicesAndUmountPerm(defaultSignalDelay)\n\n\t\t\t\tswitch sig {\n\t\t\t\tcase unix.SIGTERM:\n\t\t\t\t\treboot(true)\n\n\t\t\t\tcase unix.SIGUSR1:\n\t\t\t\t\tlog.Println(\"Halting\")\n\t\t\t\t\tcode := uint(unix.LINUX_REBOOT_CMD_HALT)\n\t\t\t\t\tif err := unix.Reboot(int(code)); err != nil {\n\t\t\t\t\t\tlog.Printf(\"HALT: %v\", err)\n\t\t\t\t\t}\n\n\t\t\t\tcase unix.SIGUSR2:\n\t\t\t\t\tlog.Println(\"Powering off\")\n\t\t\t\t\tif err := unix.Reboot(unix.LINUX_REBOOT_CMD_POWER_OFF); err != nil {\n\t\t\t\t\t\tlog.Printf(\"POWER_OFF: %v\", err)\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n"
        },
        {
          "name": "status.go",
          "type": "blob",
          "size": 11.6650390625,
          "content": "package gokrazy\n\nimport (\n\t\"bytes\"\n\t\"debug/buildinfo\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/gokrazy/gokrazy/internal/assets\"\n\t\"github.com/gokrazy/internal/config\"\n\t\"github.com/gokrazy/internal/rootdev\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc parseMeminfo() map[string]int64 {\n\tmeminfo, err := ioutil.ReadFile(\"/proc/meminfo\")\n\tif err != nil {\n\t\treturn nil\n\t}\n\tvals := make(map[string]int64)\n\tfor _, line := range strings.Split(string(meminfo), \"\\n\") {\n\t\tif !strings.HasPrefix(line, \"MemTotal\") &&\n\t\t\t!strings.HasPrefix(line, \"MemAvailable\") {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.Split(line, \":\")\n\t\tif len(parts) < 2 {\n\t\t\tcontinue\n\t\t}\n\t\tval, err := strconv.ParseInt(strings.TrimSpace(strings.TrimSuffix(parts[1], \" kB\")), 0, 64)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tvals[parts[0]] = val * 1024 // KiB to B\n\t}\n\treturn vals\n}\n\n// readFile0 returns the file contents or an empty string if the file could not\n// be read. All bytes from any \\0 byte onwards are stripped (as found in\n// /proc/device-tree/model).\n//\n// Additionally, whitespace is trimmed.\nfunc readFile0(filename string) string {\n\tb, _ := ioutil.ReadFile(filename)\n\tif idx := bytes.IndexByte(b, 0); idx > -1 {\n\t\tb = b[:idx]\n\t}\n\treturn string(bytes.TrimSpace(b))\n}\n\nvar modelCache atomic.Value // of string\n\n// Model returns a human readable description of the current device model,\n// e.g. “Raspberry Pi 4 Model B Rev 1.1” or “PC Engines apu2” or “QEMU”\n// or ultimately “unknown model”.\nfunc Model() string {\n\tif s, ok := modelCache.Load().(string); ok {\n\t\treturn s\n\t}\n\tandCache := func(s string) string {\n\t\tmodelCache.Store(s)\n\t\treturn s\n\t}\n\t// the supported Raspberry Pis have this file\n\tif m := readFile0(\"/proc/device-tree/model\"); m != \"\" {\n\t\treturn andCache(m)\n\t}\n\t// The PC Engines apu2c4 (and other PCs) have this file instead:\n\tvendor := readFile0(\"/sys/class/dmi/id/board_vendor\")\n\tname := readFile0(\"/sys/class/dmi/id/board_name\")\n\tif vendor != \"\" || name != \"\" {\n\t\treturn andCache(vendor + \" \" + name)\n\t}\n\t// QEMU has none of that. But it does say \"QEMU\" here, so use this as\n\t// another fallback:\n\tif v := readFile0(\"/sys/class/dmi/id/sys_vendor\"); v != \"\" {\n\t\treturn andCache(v)\n\t}\n\t// If we can't find anything else, at least return some non-empty string so\n\t// fbstatus doesn't render funny with empty parens. Plus this gives people\n\t// something to grep for to add more model detection.\n\treturn \"unknown model\"\n}\n\nfunc readModuleInfo(path string) (string, error) {\n\tbi, err := buildinfo.ReadFile(path)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tlines := strings.Split(strings.TrimSpace(bi.String()), \"\\n\")\n\tshortened := make([]string, len(lines))\n\tfor idx, line := range lines {\n\t\trow := strings.Split(line, \"\\t\")\n\t\tif len(row) > 3 {\n\t\t\trow = row[:3]\n\t\t}\n\t\tshortened[idx] = strings.Join(row, \"\\t\")\n\t}\n\treturn strings.Join(shortened, \"\\n\"), nil\n}\n\nfunc parseUtsname(u unix.Utsname) string {\n\tif u == (unix.Utsname{}) {\n\t\t// Empty utsname, no info to parse.\n\t\treturn \"unknown\"\n\t}\n\n\tstr := func(b [65]byte) string {\n\t\t// Trim all trailing NULL bytes.\n\t\treturn string(bytes.TrimRight(b[:], \"\\x00\"))\n\t}\n\n\treturn fmt.Sprintf(\"%s %s (%s)\",\n\t\tstr(u.Sysname), str(u.Release), str(u.Machine))\n}\n\nfunc jsonRequested(r *http.Request) bool {\n\t// When this function was introduced, it incorrectly checked the\n\t// Content-Type header (which specifies the type of the body, if any), where\n\t// it should have looked at the Accept header. Hence, we now consider both,\n\t// at least for some time.\n\treturn strings.Contains(strings.ToLower(r.Header.Get(\"Accept\")), \"application/json\") ||\n\t\tstrings.Contains(strings.ToLower(r.Header.Get(\"Content-type\")), \"application/json\")\n}\n\nfunc eventStreamRequested(r *http.Request) bool {\n\treturn strings.Contains(strings.ToLower(r.Header.Get(\"Accept\")), \"text/event-stream\")\n}\n\nvar templates = template.Must(template.New(\"root\").\n\tFuncs(map[string]interface{}{\n\t\t\"printSBOMHash\": func(sbomHash string) string {\n\t\t\tconst sbomHashLen = 10\n\t\t\tif len(sbomHash) < sbomHashLen {\n\t\t\t\treturn sbomHash\n\t\t\t}\n\t\t\treturn sbomHash[:sbomHashLen]\n\t\t},\n\n\t\t\"shortenSHA256\": func(hash string) string {\n\t\t\tif len(hash) > 10 {\n\t\t\t\treturn hash[:10]\n\t\t\t}\n\t\t\treturn hash\n\t\t},\n\t\t\"restarting\": func(t time.Time) bool {\n\t\t\treturn time.Since(t).Seconds() < 5\n\t\t},\n\n\t\t\"last\": func(s []string) string {\n\t\t\tif len(s) == 0 {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn s[len(s)-1]\n\t\t},\n\n\t\t\"megabytes\": func(val int64) string {\n\t\t\treturn fmt.Sprintf(\"%.1f MiB\", float64(val)/1024/1024)\n\t\t},\n\n\t\t\"gigabytes\": func(val int64) string {\n\t\t\treturn fmt.Sprintf(\"%.1f GiB\", float64(val)/1024/1024/1024)\n\t\t},\n\n\t\t\"baseName\": func(path string) string {\n\t\t\treturn filepath.Base(path)\n\t\t},\n\n\t\t\"initRss\": func() int64 {\n\t\t\treturn rssOfPid(1)\n\t\t},\n\n\t\t\"rssPercentage\": func(meminfo map[string]int64, rss int64) string {\n\t\t\tused := float64(meminfo[\"MemTotal\"] - meminfo[\"MemAvailable\"])\n\t\t\treturn fmt.Sprintf(\"%.f\", float64(rss)/used*100)\n\t\t},\n\t}).\n\tParseFS(assets.Assets, \"*.tmpl\"))\n\nfunc mountTargets() ([]string, error) {\n\tb, err := os.ReadFile(\"/etc/gokrazy/mountdevices.json\")\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\treturn nil, nil\n\t\t}\n\t\treturn nil, fmt.Errorf(\"reading mountdevices.json: %v\", err)\n\t}\n\tvar mountdevices []config.MountDevice\n\tif err := json.Unmarshal(b, &mountdevices); err != nil {\n\t\treturn nil, fmt.Errorf(\"reading mountdevices.json: %v\", err)\n\t}\n\tvar targets []string\n\tfor _, dev := range mountdevices {\n\t\ttargets = append(targets, dev.Target)\n\t}\n\treturn targets, nil\n}\n\ntype filesystemStatus struct {\n\tDev   string\n\tUsed  int64\n\tAvail int64\n\tTotal int64\n}\n\nfunc initStatus() {\n\tmodel := Model()\n\n\tvar uname unix.Utsname\n\tif err := unix.Uname(&uname); err != nil {\n\t\tlog.Printf(\"getting uname: %v\", err)\n\t}\n\tkernel := parseUtsname(uname)\n\n\t_, sbomHash, err := ReadSBOM()\n\tif err != nil {\n\t\tlog.Printf(\"getting SBOM: %v\", err)\n\t}\n\n\tmountTargets, err := mountTargets()\n\tif err != nil {\n\t\tlog.Printf(\"getting mount targets: %v\", err)\n\t}\n\n\thttp.Handle(\"/assets/\", http.StripPrefix(\"/assets/\", http.FileServer(http.FS(assets.Assets))))\n\n\thttp.HandleFunc(\"/status\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t\ttoken := xsrfTokenFromCookies(r.Cookies())\n\t\tif token == 0 {\n\t\t\t// Only generate a new XSRF token if the old one is expired, so that\n\t\t\t// loading a different form in the background doesn’t render the\n\t\t\t// current one unusable.\n\t\t\ttoken = xsrfToken()\n\t\t}\n\n\t\thttp.SetCookie(w, &http.Cookie{\n\t\t\tName:     \"gokrazy_xsrf\",\n\t\t\tValue:    fmt.Sprintf(\"%d\", token),\n\t\t\tExpires:  time.Now().Add(24 * time.Hour),\n\t\t\tHttpOnly: true,\n\t\t})\n\n\t\tpath := r.FormValue(\"path\")\n\t\tsvc := findSvc(path)\n\t\tif svc == nil {\n\t\t\thttp.Error(w, \"service not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tif jsonRequested(r) {\n\t\t\tb, err := json.Marshal(svc)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, _ = w.Write(b)\n\t\t\treturn\n\t\t}\n\n\t\tvar buf bytes.Buffer\n\t\tif err := templates.ExecuteTemplate(&buf, \"status.tmpl\", struct {\n\t\t\tService        *service\n\t\t\tBuildTimestamp string\n\t\t\tSBOMHash       string\n\t\t\tHostname       string\n\t\t\tModel          string\n\t\t\tXsrfToken      int32\n\t\t\tEEPROM         *eepromVersion\n\t\t\tKernel         string\n\t\t}{\n\t\t\tService:        svc,\n\t\t\tBuildTimestamp: buildTimestamp,\n\t\t\tSBOMHash:       sbomHash,\n\t\t\tHostname:       hostname,\n\t\t\tModel:          model,\n\t\t\tXsrfToken:      token,\n\t\t\tEEPROM:         lastInstalledEepromVersion,\n\t\t\tKernel:         kernel,\n\t\t}); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tstatus := \"started\"\n\t\tif svc.Stopped() {\n\t\t\tstatus = \"stopped\"\n\t\t}\n\t\tw.Header().Set(\"X-Gokrazy-Status\", status)\n\t\tw.Header().Set(\"X-Gokrazy-GOARCH\", runtime.GOARCH)\n\t\tio.Copy(w, &buf)\n\t})\n\n\thttp.HandleFunc(\"/log\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t\tevtStream := eventStreamRequested(r)\n\t\tif evtStream {\n\t\t\tw.Header().Set(\"Content-type\", \"text/event-stream\")\n\t\t}\n\n\t\tpath := r.FormValue(\"path\")\n\t\tsvc := findSvc(path)\n\t\tif svc == nil {\n\t\t\thttp.Error(w, \"service not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\n\t\tstreamName := r.FormValue(\"stream\")\n\n\t\tvar stream <-chan string\n\t\tvar closeFunc func()\n\n\t\tswitch streamName {\n\t\tcase \"stdout\":\n\t\t\tstream, closeFunc = svc.Stdout.Stream()\n\t\tcase \"stderr\":\n\t\t\tstream, closeFunc = svc.Stderr.Stream()\n\t\tdefault:\n\t\t\thttp.Error(w, \"stream not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tdefer closeFunc()\n\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase line := <-stream:\n\t\t\t\t// See https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events for description\n\t\t\t\t// of server-sent events protocol.\n\t\t\t\tif evtStream {\n\t\t\t\t\tline = fmt.Sprintf(\"data: %s\\n\", line)\n\t\t\t\t}\n\t\t\t\tif _, err := fmt.Fprintln(w, line); err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif f, ok := w.(http.Flusher); ok {\n\t\t\t\t\tf.Flush()\n\t\t\t\t}\n\t\t\tcase <-r.Context().Done():\n\t\t\t\t// Client closed stream. Stop and release all resources immediately.\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t})\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.URL.Path != \"/\" {\n\t\t\thttp.Error(w, \"not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Access-Control-Allow-Origin\", \"*\")\n\n\t\tvar st unix.Statfs_t\n\t\tif err := unix.Statfs(\"/perm\", &st); err != nil {\n\t\t\tlog.Printf(\"could not stat /perm: %v\", err)\n\t\t}\n\t\tprivateAddrs, err := PrivateInterfaceAddrs()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"could not get private addrs: %v\", err)\n\t\t}\n\t\tpublicAddrs, err := PublicInterfaceAddrs()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"could not get public addrs: %v\", err)\n\t\t}\n\n\t\tpermUUID := rootdev.PARTUUID()\n\t\tif strings.Contains(permUUID, \"-\") {\n\t\t\tpermUUID = strings.TrimSuffix(permUUID, \"01\") + \"04\"\n\t\t} else {\n\t\t\tpermUUID += \"-04\"\n\t\t}\n\n\t\tvar mountDevices []filesystemStatus\n\t\tfor _, target := range mountTargets {\n\t\t\tvar st unix.Statfs_t\n\t\t\tif err := unix.Statfs(target, &st); err != nil {\n\t\t\t\tlog.Printf(\"could not stat %s: %v\", target, err)\n\t\t\t}\n\t\t\tmountDevices = append(mountDevices, filesystemStatus{\n\t\t\t\tDev:   target,\n\t\t\t\tUsed:  int64(st.Bsize) * int64(st.Blocks-st.Bfree),\n\t\t\t\tAvail: int64(st.Bsize) * int64(st.Bavail),\n\t\t\t\tTotal: int64(st.Bsize) * int64(st.Blocks),\n\t\t\t})\n\t\t}\n\n\t\tservices.Lock()\n\t\tdefer services.Unlock()\n\t\tstatus := struct {\n\t\t\tServices       []*service\n\t\t\tPermDev        string\n\t\t\tPermUsed       int64\n\t\t\tPermAvail      int64\n\t\t\tPermTotal      int64\n\t\t\tPrivateAddrs   []string\n\t\t\tPublicAddrs    []string\n\t\t\tBuildTimestamp string\n\t\t\tSBOMHash       string\n\t\t\tMeminfo        map[string]int64\n\t\t\tHostname       string\n\t\t\tModel          string\n\t\t\tPermUUID       string\n\t\t\tEEPROM         *eepromVersion\n\t\t\tKernel         string\n\t\t\tMountDevices   []filesystemStatus\n\t\t}{\n\t\t\tServices:       services.S,\n\t\t\tPermDev:        rootdev.Partition(rootdev.Perm),\n\t\t\tPermUsed:       int64(st.Bsize) * int64(st.Blocks-st.Bfree),\n\t\t\tPermAvail:      int64(st.Bsize) * int64(st.Bavail),\n\t\t\tPermTotal:      int64(st.Bsize) * int64(st.Blocks),\n\t\t\tPrivateAddrs:   privateAddrs,\n\t\t\tPublicAddrs:    publicAddrs,\n\t\t\tBuildTimestamp: buildTimestamp,\n\t\t\tSBOMHash:       sbomHash,\n\t\t\tMeminfo:        parseMeminfo(),\n\t\t\tHostname:       hostname,\n\t\t\tModel:          model,\n\t\t\tPermUUID:       permUUID,\n\t\t\tEEPROM:         lastInstalledEepromVersion,\n\t\t\tKernel:         kernel,\n\t\t\tMountDevices:   mountDevices,\n\t\t}\n\n\t\tif jsonRequested(r) {\n\t\t\tb, err := json.Marshal(status)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\t_, _ = w.Write(b)\n\t\t\treturn\n\t\t}\n\n\t\tvar buf bytes.Buffer\n\t\tif err := templates.ExecuteTemplate(&buf, \"overview.tmpl\", status); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tio.Copy(w, &buf)\n\t})\n}\n"
        },
        {
          "name": "status_test.go",
          "type": "blob",
          "size": 0.015625,
          "content": "package gokrazy\n"
        },
        {
          "name": "supervise.go",
          "type": "blob",
          "size": 15.4033203125,
          "content": "package gokrazy\n\nimport (\n\t\"container/ring\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"log/syslog\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n)\n\n// remoteSyslogError throttles printing error messages about remote\n// syslog. Since a remote syslog writer is created for stdout and stderr of each\n// supervised process, error messages during early boot spam the serial console\n// without limiting. When the value is 0, a log message can be printed. A\n// background goroutine resets the value to 0 once a second.\nvar remoteSyslogError uint32\n\nfunc init() {\n\tgo func() {\n\t\tfor range time.Tick(1 * time.Second) {\n\t\t\tatomic.StoreUint32(&remoteSyslogError, 0)\n\t\t}\n\t}()\n}\n\ntype remoteSyslogWriter struct {\n\traddr, tag string\n\n\tlines *lineRingBuffer\n\n\tsyslogMu sync.Mutex\n\tsyslog   io.Writer\n}\n\nfunc (w *remoteSyslogWriter) establish() {\n\tfor {\n\t\tsl, err := syslog.Dial(\"udp\", w.raddr, syslog.LOG_INFO, w.tag)\n\t\tif err != nil {\n\t\t\tif atomic.SwapUint32(&remoteSyslogError, 1) == 0 {\n\t\t\t\tlog.Printf(\"remote syslog: %v\", err)\n\t\t\t}\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tcontinue\n\t\t}\n\t\tw.syslogMu.Lock()\n\t\tdefer w.syslogMu.Unlock()\n\t\t// replay buffer in case any messages were sent before the connection\n\t\t// could be established (before the network is ready)\n\t\tfor _, line := range w.lines.Lines() {\n\t\t\tsl.Write([]byte(line + \"\\n\"))\n\t\t}\n\t\t// send all future writes to syslog\n\t\tw.syslog = sl\n\t\treturn\n\t}\n}\n\nfunc (w *remoteSyslogWriter) Lines() []string {\n\treturn w.lines.Lines()\n}\n\nfunc (w *remoteSyslogWriter) Stream() (<-chan string, func()) {\n\treturn w.lines.Stream()\n}\n\nfunc (w *remoteSyslogWriter) Write(b []byte) (int, error) {\n\tw.lines.Write(b)\n\tw.syslogMu.Lock()\n\tdefer w.syslogMu.Unlock()\n\tif w.syslog == nil {\n\t\treturn len(b), nil\n\t}\n\tfor _, line := range strings.Split(strings.TrimSpace(string(b)), \"\\n\") {\n\t\tw.syslog.Write([]byte(line + \"\\n\"))\n\t}\n\treturn len(b), nil\n}\n\ntype lineRingBuffer struct {\n\tsync.RWMutex\n\tremainder string\n\tr         *ring.Ring\n\tstreams   map[chan string]struct{}\n}\n\nfunc newLineRingBuffer(size int) *lineRingBuffer {\n\treturn &lineRingBuffer{\n\t\tr:       ring.New(size),\n\t\tstreams: make(map[chan string]struct{}),\n\t}\n}\n\nfunc (lrb *lineRingBuffer) Write(b []byte) (int, error) {\n\tlrb.Lock()\n\tdefer lrb.Unlock()\n\ttext := lrb.remainder + string(b)\n\tfor {\n\t\tidx := strings.Index(text, \"\\n\")\n\t\tif idx == -1 {\n\t\t\tbreak\n\t\t}\n\n\t\tline := text[:idx]\n\t\tlrb.r.Value = line\n\t\tfor stream := range lrb.streams {\n\t\t\tselect {\n\t\t\tcase stream <- line:\n\t\t\tdefault:\n\t\t\t\t// If receiver channel is blocking, skip. This means streams\n\t\t\t\t// will miss log lines if they are full.\n\t\t\t}\n\t\t}\n\t\tlrb.r = lrb.r.Next()\n\t\ttext = text[idx+1:]\n\t}\n\tlrb.remainder = text\n\treturn len(b), nil\n}\n\nfunc (lrb *lineRingBuffer) Lines() []string {\n\tlrb.RLock()\n\tdefer lrb.RUnlock()\n\tlines := make([]string, 0, lrb.r.Len())\n\tlrb.r.Do(func(x interface{}) {\n\t\tif x != nil {\n\t\t\tlines = append(lines, x.(string))\n\t\t}\n\t})\n\treturn lines\n}\n\n// Stream generates a new channel which will stream any logged lines, including everything currently\n// in the ring buffer. Deregister the stream by calling the close function.\nfunc (lrb *lineRingBuffer) Stream() (<-chan string, func()) {\n\tlrb.Lock()\n\tdefer lrb.Unlock()\n\n\t// Need a chan that has at least len(ring) entries in it, otherwise populating it with existing\n\t// contents of the ring will block forever.\n\tstream := make(chan string, 101)\n\tlrb.r.Do(func(x interface{}) {\n\t\tif x != nil {\n\t\t\tstream <- x.(string)\n\t\t}\n\t})\n\tlrb.streams[stream] = struct{}{}\n\n\treturn stream, func() {\n\t\tlrb.Lock()\n\t\tdefer lrb.Unlock()\n\n\t\tdelete(lrb.streams, stream)\n\t\tclose(stream)\n\t}\n}\n\ntype lineswriter interface {\n\tio.Writer\n\tLines() []string\n\tStream() (<-chan string, func())\n}\n\ntype supervisionMode int\n\nconst (\n\tsuperviseLoop supervisionMode = iota\n\tsuperviseOnce\n\tsuperviseDone\n)\n\ntype service struct {\n\t// config (never updated)\n\tModuleInfo string\n\n\t// state\n\tstopped   bool\n\tstoppedMu sync.RWMutex\n\tcmd       *exec.Cmd\n\tcmdMu     sync.Mutex\n\tStdout    lineswriter\n\tStderr    lineswriter\n\tstarted   time.Time\n\tstartedMu sync.RWMutex\n\tprocess   *os.Process\n\tprocessMu sync.RWMutex\n\n\tdiversionMu sync.Mutex\n\tdiversion   string\n\n\tsupervisionMu sync.Mutex\n\tsupervision   supervisionMode\n\n\twaitForClock bool\n\n\tstate *processState\n}\n\nfunc (s *service) setDiversion(d string) {\n\ts.diversionMu.Lock()\n\tdefer s.diversionMu.Unlock()\n\ts.diversion = d\n}\n\nfunc (s *service) Diverted() string {\n\ts.diversionMu.Lock()\n\tdefer s.diversionMu.Unlock()\n\treturn s.diversion\n}\n\nfunc (s *service) Path() string {\n\tif d := s.Diverted(); d != \"\" {\n\t\treturn d\n\t}\n\treturn s.Cmd().Path\n}\n\nfunc (s *service) Cmd() *exec.Cmd {\n\ts.cmdMu.Lock()\n\tdefer s.cmdMu.Unlock()\n\treturn s.cmd\n}\n\nfunc (s *service) setCmd(cmd *exec.Cmd) {\n\ts.cmdMu.Lock()\n\tdefer s.cmdMu.Unlock()\n\ts.cmd = cmd\n}\n\nfunc (s *service) Name() string {\n\treturn s.Cmd().Args[0]\n}\n\nfunc (s *service) supervisionMode() supervisionMode {\n\ts.supervisionMu.Lock()\n\tdefer s.supervisionMu.Unlock()\n\treturn s.supervision\n}\n\nfunc (s *service) setSupervisionMode(mode supervisionMode) {\n\ts.supervisionMu.Lock()\n\tdefer s.supervisionMu.Unlock()\n\ts.supervision = mode\n}\n\nfunc (s *service) Stopped() bool {\n\ts.stoppedMu.RLock()\n\tdefer s.stoppedMu.RUnlock()\n\treturn s.stopped\n}\n\nfunc (s *service) setStopped(val bool) {\n\ts.stoppedMu.Lock()\n\tdefer s.stoppedMu.Unlock()\n\ts.stopped = val\n}\n\nfunc (s *service) Started() time.Time {\n\ts.startedMu.RLock()\n\tdefer s.startedMu.RUnlock()\n\treturn s.started\n}\n\nfunc (s *service) setStarted(t time.Time) {\n\ts.startedMu.Lock()\n\tdefer s.startedMu.Unlock()\n\ts.started = t\n}\n\nfunc (s *service) Process() *os.Process {\n\ts.processMu.RLock()\n\tdefer s.processMu.RUnlock()\n\treturn s.process\n}\n\nfunc (s *service) Signal(signal syscall.Signal) error {\n\ts.processMu.RLock()\n\tdefer s.processMu.RUnlock()\n\tif s.process != nil {\n\t\t// Use syscall.Kill instead of s.process.Signal since we want\n\t\t// to the send the signal to all process of the group (-pid)\n\t\terr := syscall.Kill(-s.process.Pid, signal)\n\t\tif errno, ok := err.(syscall.Errno); ok {\n\t\t\tif errno == syscall.ESRCH {\n\t\t\t\treturn nil // no such process, nothing to signal\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\treturn nil // no process, nothing to signal\n}\n\nfunc (s *service) setProcess(p *os.Process) {\n\ts.processMu.Lock()\n\tdefer s.processMu.Unlock()\n\ts.process = p\n}\n\nfunc (s *service) MarshalJSON() ([]byte, error) {\n\tpid := 0\n\tif proc := s.Process(); proc != nil {\n\t\tpid = proc.Pid\n\t}\n\treturn json.Marshal(&struct {\n\t\tStopped   bool\n\t\tStartTime time.Time\n\t\tPid       int\n\t\tPath      string\n\t\tArgs      []string\n\t\tDiverted  string\n\t}{\n\t\tStopped:   s.Stopped(),\n\t\tStartTime: s.Started(),\n\t\tPid:       pid,\n\t\tPath:      s.Cmd().Path,\n\t\tArgs:      s.Cmd().Args,\n\t\tDiverted:  s.Diverted(),\n\t})\n}\n\nfunc rssOfPid(pid int) int64 {\n\tstatm, err := os.ReadFile(fmt.Sprintf(\"/proc/%d/statm\", pid))\n\tif err != nil {\n\t\treturn 0\n\t}\n\tparts := strings.Split(strings.TrimSpace(string(statm)), \" \")\n\tif len(parts) < 2 {\n\t\treturn 0\n\t}\n\trss, err := strconv.ParseInt(parts[1], 0, 64)\n\tif err != nil {\n\t\treturn 0\n\t}\n\treturn rss * 4096\n}\n\nfunc (s *service) RSS() int64 {\n\tif p := s.Process(); p != nil {\n\t\treturn rssOfPid(s.Process().Pid)\n\t}\n\treturn 0\n}\n\nvar syslogRaddr string\n\nfunc initRemoteSyslog() {\n\tb, err := os.ReadFile(\"/perm/remote_syslog/target\")\n\tif err != nil {\n\t\tif !os.IsNotExist(err) {\n\t\t\tlog.Print(err)\n\t\t}\n\t\treturn\n\t}\n\traddr := strings.TrimSpace(string(b))\n\tlog.Printf(\"sending process stdout/stderr to remote syslog %s\", raddr)\n\tsyslogRaddr = raddr\n}\n\nfunc newLogWriter(tag string) lineswriter {\n\tlb := newLineRingBuffer(100)\n\tif syslogRaddr == \"\" {\n\t\treturn lb\n\t}\n\twr := &remoteSyslogWriter{\n\t\traddr: syslogRaddr,\n\t\ttag:   tag,\n\t\tlines: lb,\n\t}\n\tgo wr.establish()\n\treturn wr\n}\n\nfunc isDontSupervise(err error) bool {\n\tee, ok := err.(*exec.ExitError)\n\tif !ok {\n\t\treturn false\n\t}\n\n\tws, ok := ee.Sys().(syscall.WaitStatus)\n\tif !ok {\n\t\treturn false\n\t}\n\n\treturn ws.ExitStatus() == 125\n}\n\nfunc supervise(s *service) {\n\tif modInfo, err := readModuleInfo(s.Path()); err == nil {\n\t\ts.ModuleInfo = modInfo\n\t} else {\n\t\tlog.Printf(\"cannot read module info from %s: %v\", s.Cmd().Path, err)\n\t}\n\n\tl := log.New(s.Stderr, \"\", log.LstdFlags|log.Ldate|log.Ltime)\n\tattempt := 0\n\n\t// Wait for clock to be updated via ntp for services\n\t// that need correct time. This can be enabled\n\t// by adding a settings file named waitforclock.txt under\n\t// waitforclock/<package> directory.\n\tif strings.HasPrefix(s.Cmd().Path, \"/user/\") && s.waitForClock {\n\t\tl.Print(\"gokrazy: waiting for clock to be synced\")\n\t\tWaitForClock()\n\t}\n\n\tfor {\n\t\tif s.Stopped() {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t\tcontinue\n\t\t}\n\n\t\tcmd := &exec.Cmd{\n\t\t\tPath:   s.Cmd().Path,\n\t\t\tArgs:   s.Cmd().Args,\n\t\t\tEnv:    s.Cmd().Env,\n\t\t\tStdout: s.Stdout,\n\t\t\tStderr: s.Stderr,\n\t\t\tSysProcAttr: &syscall.SysProcAttr{\n\t\t\t\t// create a new process group for each service to make it easier to terminate all its\n\t\t\t\t// processes with a single signal.\n\t\t\t\tSetpgid: true,\n\t\t\t},\n\t\t}\n\t\tif d := s.Diverted(); d != \"\" {\n\t\t\tcmd.Path = d\n\t\t\targs := make([]string, len(cmd.Args))\n\t\t\tcopy(args, cmd.Args)\n\t\t\targs[0] = d\n\t\t\tcmd.Args = args\n\t\t}\n\t\tif cmd.Env == nil {\n\t\t\tcmd.Env = os.Environ() // for older gokr-packer versions\n\t\t}\n\t\tif attempt == 0 {\n\t\t\tcmd.Env = append(cmd.Env, \"GOKRAZY_FIRST_START=1\")\n\t\t}\n\t\t// Designate a subdirectory under /perm/home as $HOME.\n\t\t// This mirrors what gokrazy system daemons and\n\t\t// ported daemons would do, so setting $HOME\n\t\t// increases the chance that third-party daemons\n\t\t// just work.\n\t\tbase := filepath.Base(s.Cmd().Path)\n\t\toldDir := \"/perm/\" + base\n\t\thomeDir := \"/perm/home/\" + base\n\t\t// Older gokrazy installations used /perm/<base>,\n\t\t// but since we started creating one directory for each\n\t\t// supervised process, it is better to use /perm/home/<base>\n\t\t// to avoid cluttering the /perm partition.\n\t\tif _, err := os.Stat(oldDir); err == nil {\n\t\t\thomeDir = oldDir\n\t\t}\n\t\tcmd.Env = append(cmd.Env, \"HOME=\"+homeDir)\n\t\tif err := os.MkdirAll(homeDir, 0700); err != nil {\n\t\t\tif errors.Is(err, syscall.EROFS) {\n\t\t\t\tl.Printf(\"gokrazy: cannot create $HOME directory without writeable /perm partition\")\n\t\t\t} else {\n\t\t\t\tl.Printf(\"gokrazy: creating $HOME: %v\", err)\n\t\t\t}\n\t\t} else {\n\t\t\t// Process execution fails when cmd.Dir points to\n\t\t\t// a non-existant directory.\n\t\t\tcmd.Dir = homeDir\n\t\t}\n\n\t\tl.Printf(\"gokrazy: attempt %d, starting %q\", attempt, cmd.Args)\n\t\ts.setStarted(time.Now())\n\t\tattempt++\n\n\t\tpid := -1\n\t\tif err := cmd.Start(); err != nil {\n\t\t\tif d := s.Diverted(); os.IsNotExist(err) && d != \"\" {\n\t\t\t\tl.Printf(\"gokrazy: removing no longer existing diversion %q\", d)\n\t\t\t\ts.setDiversion(\"\")\n\t\t\t}\n\t\t\tl.Println(\"gokrazy: \" + err.Error())\n\t\t} else {\n\t\t\tpid = cmd.Process.Pid\n\t\t}\n\n\t\ts.state.Set(Running)\n\t\ts.setProcess(cmd.Process)\n\n\t\terr := cmd.Wait()\n\t\tif err != nil {\n\t\t\tif isDontSupervise(err) {\n\t\t\t\tl.Println(\"gokrazy: process should not be supervised, stopping\")\n\t\t\t\ts.setStopped(true)\n\t\t\t}\n\t\t\tl.Println(\"gokrazy: \" + err.Error())\n\t\t} else {\n\t\t\tl.Printf(\"gokrazy: exited successfully, stopping\")\n\t\t\ts.setStopped(true)\n\t\t}\n\n\t\tif s.supervisionMode() == superviseOnce {\n\t\t\ts.setSupervisionMode(superviseDone)\n\t\t\tif !s.Stopped() {\n\t\t\t\tl.Println(\"gokrazy: running process only once, stopping\")\n\t\t\t\ts.setStopped(true)\n\t\t\t}\n\t\t}\n\n\t\tfor {\n\t\t\tif pid <= 0 {\n\t\t\t\t// Sanity check pid value.\n\t\t\t\t// Sending 0 for pid in Wait4 has special meaning, which we don't want.\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Wait4 return the pid of a process that exited,\n\t\t\t// or -1 if there are no processes to be waited on (or error).\n\t\t\twpid, _ := syscall.Wait4(-pid, nil, 0, nil)\n\t\t\tif wpid == -1 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ts.state.Set(Stopped)\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\n\nvar services struct {\n\tsync.Mutex\n\tS []*service\n}\n\n// signalSupervisedServices sends a given signal to all non-stopped processes.\n// It returns the corresponding processState to allow waiting for a given state.\nfunc signalSupervisedServices(signal syscall.Signal) []*processState {\n\tservices.Lock()\n\tdefer services.Unlock()\n\n\tstates := make([]*processState, 0, len(services.S))\n\tfor _, s := range services.S {\n\t\t// s.Stopped() only checks the \"stopped\" flag of the service (if it shouldn't restart).\n\t\t// We check the actual state as well to be sure to re-send a signal if we are already\n\t\t// in the \"Stopping\" state.\n\t\tif s.Stopped() && s.state.Get() == Stopped {\n\t\t\tcontinue\n\t\t}\n\n\t\t// NOTE: Stopping can be inaccurate if the process exited after the check above.\n\t\t// In that case, `state.Set(Stopping)` will be ignored - see `processState.Set()`.\n\t\ts.state.Set(Stopping)\n\n\t\ts.setStopped(true)\n\t\ts.Signal(signal)\n\t\tstates = append(states, s.state)\n\t}\n\treturn states\n}\n\n// killSupervisedServices is called before rebooting when upgrading, allowing\n// processes to terminate in an orderly fashion.\nfunc killSupervisedServices(signalDelay time.Duration) {\n\tlog.Println(\"sending sigterm to all services\")\n\ttermStates := signalSupervisedServices(syscall.SIGTERM)\n\ttermDone := make(chan struct{})\n\tgo func() {\n\t\tfor _, s := range termStates {\n\t\t\ts.WaitTill(Stopped)\n\t\t}\n\t\tclose(termDone)\n\t}()\n\n\tselect {\n\tcase <-termDone:\n\t\tlog.Println(\"all services shut down\")\n\t\treturn\n\tcase <-time.After(signalDelay):\n\t}\n\tlog.Println(\"some services did not stop, send sigkill\")\n\n\tkillStates := signalSupervisedServices(syscall.SIGKILL)\n\tkillDone := make(chan struct{})\n\tgo func() {\n\t\tfor _, s := range killStates {\n\t\t\ts.WaitTill(Stopped)\n\t\t}\n\t\tclose(killDone)\n\t}()\n\n\tselect {\n\tcase <-killDone:\n\t\tlog.Println(\"all services shut down\")\n\t\treturn\n\tcase <-time.After(signalDelay):\n\t}\n\n\tlog.Println(\"some services did not stop after sigkill\")\n}\n\nfunc findSvc(path string) *service {\n\tservices.Lock()\n\tdefer services.Unlock()\n\tfor _, s := range services.S {\n\t\tif s.Cmd().Path == path {\n\t\t\treturn s\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc restart(s *service, signal syscall.Signal) error {\n\tif s.Stopped() {\n\t\ts.setStopped(false) // start process in next supervise iteration\n\t\treturn nil\n\t}\n\n\treturn s.Signal(signal) // kill to restart\n}\n\nfunc stop(s *service, signal syscall.Signal) error {\n\tif s.Stopped() {\n\t\treturn nil // nothing to do\n\t}\n\n\ts.setStopped(true)\n\treturn s.Signal(signal)\n}\n\nfunc stopstartHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"expected a POST request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tcookieToken := xsrfTokenFromCookies(r.Cookies())\n\tif cookieToken == 0 {\n\t\thttp.Error(w, \"XSRF cookie missing\", http.StatusBadRequest)\n\t\treturn\n\t}\n\ti, err := strconv.ParseInt(r.FormValue(\"xsrftoken\"), 0, 32)\n\tif err != nil {\n\t\thttp.Error(w, fmt.Sprintf(\"parsing XSRF token form value: %v\", err), http.StatusBadRequest)\n\t\treturn\n\t}\n\tif formToken := int32(i); cookieToken != formToken {\n\t\thttp.Error(w, \"XSRF token mismatch\", http.StatusForbidden)\n\t\treturn\n\t}\n\n\tsignal := syscall.SIGTERM\n\tif r.FormValue(\"signal\") == \"kill\" {\n\t\tsignal = syscall.SIGKILL\n\t}\n\n\tpath := r.FormValue(\"path\")\n\ts := findSvc(path)\n\tif s == nil {\n\t\thttp.Error(w, \"no such service\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tif r.URL.Path == \"/restart\" {\n\t\tif r.FormValue(\"supervise\") == \"once\" {\n\t\t\ts.setSupervisionMode(superviseOnce)\n\t\t} else {\n\t\t\ts.setSupervisionMode(superviseLoop)\n\t\t}\n\t\terr = restart(s, signal)\n\t} else {\n\t\terr = stop(s, signal)\n\t}\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\t// StatusSeeOther will result in a GET request for the\n\t// redirect location\n\tu, _ := url.Parse(\"/status\")\n\tu.RawQuery = url.Values{\n\t\t\"path\": []string{path},\n\t}.Encode()\n\thttp.Redirect(w, r, u.String(), http.StatusSeeOther)\n}\n\nfunc superviseServices(svc []*service) {\n\tservices.Lock()\n\tservices.S = svc\n\tdefer services.Unlock()\n\tfor _, s := range services.S {\n\t\tgo supervise(s)\n\t}\n\n\thttp.HandleFunc(\"/stop\", stopstartHandler)\n\thttp.HandleFunc(\"/restart\", stopstartHandler)\n}\n"
        },
        {
          "name": "update.go",
          "type": "blob",
          "size": 14.1787109375,
          "content": "package gokrazy\n\nimport (\n\t\"bytes\"\n\t\"crypto/sha256\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"hash\"\n\t\"hash/crc32\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/sys/unix\"\n\n\t\"github.com/gokrazy/internal/deviceconfig\"\n\t\"github.com/gokrazy/internal/fat\"\n\t\"github.com/gokrazy/internal/rootdev\"\n\t\"github.com/google/renameio/v2\"\n)\n\nvar rootRe = regexp.MustCompile(`root=[^ ]+`)\n\nfunc readCmdline() ([]byte, error) {\n\tf, err := os.OpenFile(rootdev.Partition(rootdev.Boot), os.O_RDWR, 0600)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer f.Close()\n\trd, err := fat.NewReader(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\toffset, length, err := rd.Extents(\"/cmdline.txt\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif _, err := f.Seek(offset, io.SeekStart); err != nil {\n\t\treturn nil, err\n\t}\n\tb := make([]byte, length)\n\tif _, err := f.Read(b); err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, nil\n}\n\nfunc modifyCmdlineFile(f *os.File, offset, length int64, replace func([]byte) []byte) error {\n\tif _, err := f.Seek(offset, io.SeekStart); err != nil {\n\t\treturn err\n\t}\n\tb := make([]byte, length)\n\tif _, err := f.Read(b); err != nil {\n\t\treturn err\n\t}\n\tif _, err := f.Seek(offset, io.SeekStart); err != nil {\n\t\treturn err\n\t}\n\n\trep := replace(b)\n\tif pad := len(b) - len(rep); pad > 0 {\n\t\t// The file content length can shrink when switching from PARTUUID= (the\n\t\t// default) to /dev/mmcblk0p[23], on an older gokrazy installation.\n\t\t// Because we overwrite the file in place and have no means to truncate\n\t\t// it to a smaller length, we pad the command line with spaces instead.\n\t\t// Note that we need to insert spaces before the trailing newline,\n\t\t// otherwise the system won’t boot:\n\t\trep = bytes.ReplaceAll(rep,\n\t\t\t[]byte{'\\n'},\n\t\t\tappend(bytes.Repeat([]byte{' '}, pad), '\\n'))\n\t}\n\n\tif _, err := f.Write(rep); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc modifyCmdline(replace func([]byte) []byte) error {\n\tf, err := os.OpenFile(rootdev.Partition(rootdev.Boot), os.O_RDWR, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\trd, err := fat.NewReader(f)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toffset, length, err := rd.Extents(\"/cmdline.txt\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err := modifyCmdlineFile(f, offset, length, replace); err != nil {\n\t\treturn err\n\t}\n\n\toffset, length, err = rd.Extents(\"/loader/entries/gokrazy.conf\")\n\tif err != nil {\n\t\t// This file might not be present yet when using a recent gokrazy\n\t\t// installation with an older gokr-packer.\n\t\tlog.Printf(\"updating systemd-boot config: %v\", err)\n\t\treturn nil\n\t}\n\tif err := modifyCmdlineFile(f, offset, length, replace); err != nil {\n\t\treturn err\n\t}\n\treturn f.Close()\n}\n\nfunc switchRootPartition(newRootPartition int) error {\n\treturn modifyCmdline(func(b []byte) []byte {\n\t\treturn rootRe.ReplaceAllLiteral(b, []byte(\"root=\"+rootdev.PartitionCmdline(newRootPartition)))\n\t})\n}\n\nfunc enableTestboot() error {\n\treturn modifyCmdline(func(b []byte) []byte {\n\t\treturn bytes.ReplaceAll(b,\n\t\t\t[]byte{'\\n'},\n\t\t\t[]byte(\" gokrazy.try_boot_inactive=1\\n\"))\n\t})\n}\n\nfunc streamRequestTo(path string, offset int64, r io.Reader) error {\n\tf, err := os.OpenFile(path, os.O_WRONLY, 0600)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\n\tif offset > 0 {\n\t\tif _, err := f.Seek(offset, io.SeekStart); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif _, err := io.Copy(f, r); err != nil {\n\t\treturn err\n\t}\n\tif err := f.Sync(); err != nil {\n\t\treturn err\n\t}\n\treturn f.Close()\n}\n\n// createFile is different from streamRequestTo in that it creates new files\n// (instead of just overwriting existing ones) and not syncing to disk, because\n// it is intended for the /uploadtemp handler.\nfunc createFile(path string, r io.Reader) error {\n\tf, err := renameio.TempFile(\"\", path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Cleanup()\n\tif _, err := io.Copy(f, r); err != nil {\n\t\treturn err\n\t}\n\treturn f.CloseAtomicallyReplace()\n}\n\nfunc nonConcurrentUpdateHandler(dest string) func(http.ResponseWriter, *http.Request) {\n\treturn nonConcurrentLimitedUpdateHandler(dest, 0, 0)\n}\n\nfunc nonConcurrentLimitedUpdateHandler(dest string, offset int64, maxLength int64) func(http.ResponseWriter, *http.Request) {\n\tvar mu sync.Mutex\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPut {\n\t\t\thttp.Error(w, \"expected a PUT request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tvar hash hash.Hash\n\t\tswitch r.Header.Get(\"X-Gokrazy-Update-Hash\") {\n\t\tcase \"crc32\":\n\t\t\thash = crc32.NewIEEE()\n\t\tdefault:\n\t\t\thash = sha256.New()\n\t\t}\n\n\t\tvar reader io.Reader = r.Body\n\t\tif maxLength > 0 {\n\t\t\treader = io.LimitReader(reader, maxLength)\n\t\t}\n\n\t\tif err := streamRequestTo(dest, offset, io.TeeReader(reader, hash)); err != nil {\n\t\t\tlog.Printf(\"updating %q failed: %v\", dest, err)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tfmt.Fprintf(w, \"%x\", hash.Sum(nil))\n\t}\n}\n\nfunc nonConcurrentSwitchHandler(newRootPartition int) func(http.ResponseWriter, *http.Request) {\n\tvar mu sync.Mutex\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"expected a POST request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tif err := switchRootPartition(newRootPartition); err != nil {\n\t\t\tlog.Printf(\"switching root partition to %q failed: %v\", newRootPartition, err)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc nonConcurrentTestbootHandler(newRootPartition int) func(http.ResponseWriter, *http.Request) {\n\tvar mu sync.Mutex\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"expected a POST request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tif err := enableTestboot(); err != nil {\n\t\t\tlog.Printf(\"enabling test-boot of new root partition %q failed: %v\", newRootPartition, err)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n}\n\ntype extraUpdateHandler struct {\n\tname      string\n\tdevice    string\n\toffset    int64\n\tmaxLength int64\n}\n\nvar extraUpdateHandlers []*extraUpdateHandler\n\nfunc setupDeviceSpecifics() {\n\tmodelName := Model()\n\tcfg, ok := deviceconfig.DeviceConfigs[modelName]\n\tif !ok {\n\t\treturn\n\t}\n\n\tlog.Printf(\"setting up device-specific update handlers for %q\", modelName)\n\n\tfor _, rootDevFile := range cfg.RootDeviceFiles {\n\t\textraUpdateHandlers = append(extraUpdateHandlers, &extraUpdateHandler{\n\t\t\tname:      rootDevFile.Name,\n\t\t\tdevice:    rootdev.BlockDevice(),\n\t\t\toffset:    rootDevFile.Offset,\n\t\t\tmaxLength: rootDevFile.MaxLength,\n\t\t})\n\t}\n}\n\n// Allow for slow VM shutdown of 90 seconds, and then some\nconst defaultSignalDelay = 100 * time.Second\n\nfunc initUpdate() error {\n\t// The /update/features handler is used for negotiation of individual\n\t// feature support (e.g. PARTUUID= support) between the packer and update\n\t// target.\n\tgpt := \"\"\n\tif strings.Contains(rootdev.PARTUUID(), \"-\") {\n\t\tgpt = \",gpt\"\n\t}\n\tfeatureStr := fmt.Sprintf(\"partuuid,updatehash%s,\", gpt)\n\thttp.HandleFunc(\"/update/features\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif !jsonRequested(r) {\n\t\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n\t\t\tio.WriteString(w, featureStr)\n\t\t\treturn\n\t\t}\n\n\t\t// This response contains all information that the\n\t\t// github.com/gokrazy/updater package needs to obtain from the\n\t\t// target device, in one single go.\n\t\tb, err := json.Marshal(struct {\n\t\t\tFeatures string         `json:\"features\"`\n\t\t\tEEPROM   *eepromVersion `json:\"EEPROM\"`\n\t\t}{\n\t\t\tFeatures: featureStr,\n\t\t\tEEPROM:   lastInstalledEepromVersion,\n\t\t})\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(b)\n\t})\n\tinactiveRootPartition := rootdev.InactiveRootPartition()\n\tlog.Printf(\"update handler will be called with inactiveRootPartition = %v\", inactiveRootPartition)\n\thttp.HandleFunc(\"/update/mbr\", nonConcurrentUpdateHandler(rootdev.BlockDevice()))\n\thttp.HandleFunc(\"/update/root\", nonConcurrentUpdateHandler(rootdev.Partition(inactiveRootPartition)))\n\thttp.HandleFunc(\"/update/switch\", nonConcurrentSwitchHandler(inactiveRootPartition))\n\thttp.HandleFunc(\"/update/testboot\", nonConcurrentTestbootHandler(inactiveRootPartition))\n\n\tfor _, extraUpdateHandler := range extraUpdateHandlers {\n\t\thttp.HandleFunc(fmt.Sprintf(\"/update/device-specific/%s\", extraUpdateHandler.name), nonConcurrentLimitedUpdateHandler(extraUpdateHandler.device, extraUpdateHandler.offset, extraUpdateHandler.maxLength))\n\t}\n\n\t// bakery updates only the boot partition, which would reset the active root\n\t// partition to 2.\n\tupdateHandler := nonConcurrentUpdateHandler(rootdev.Partition(rootdev.Boot))\n\thttp.HandleFunc(\"/update/boot\", updateHandler)\n\thttp.HandleFunc(\"/update/bootonly\", func(w http.ResponseWriter, r *http.Request) {\n\t\tupdateHandler(w, r)\n\t\tif err := switchRootPartition(rootdev.ActiveRootPartition()); err != nil {\n\t\t\tlog.Printf(\"switching root partition to %d failed: %v\", rootdev.ActiveRootPartition(), err)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t})\n\thttp.HandleFunc(\"/reboot\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"expected a POST request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tsignalDelay := defaultSignalDelay\n\t\tif s := r.FormValue(\"wait_per_signal\"); s != \"\" {\n\t\t\tvar err error\n\t\t\tsignalDelay, err = time.ParseDuration(s)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\trc := http.NewResponseController(w)\n\t\tstart := time.Now()\n\t\tkillSupervisedServicesAndUmountPerm(signalDelay)\n\t\tfmt.Fprintf(w, \"All services killed in %s\\n\", time.Since(start))\n\t\trc.Flush()\n\n\t\tlog.Println(\"Rebooting\")\n\t\tw.Write([]byte(\"Rebooting...\\n\"))\n\t\trc.Flush()\n\n\t\tgo func() {\n\t\t\ttime.Sleep(time.Second) // give the http response some time to be sent\n\t\t\tif err := reboot(r.FormValue(\"kexec\") != \"off\"); err != nil {\n\t\t\t\tlog.Println(\"could not reboot:\", err)\n\t\t\t}\n\t\t}()\n\t})\n\thttp.HandleFunc(\"/poweroff\", func(w http.ResponseWriter, r *http.Request) {\n\t\tif r.Method != http.MethodPost {\n\t\t\thttp.Error(w, \"expected a POST request\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tsignalDelay := defaultSignalDelay\n\t\tif s := r.FormValue(\"wait_per_signal\"); s != \"\" {\n\t\t\tvar err error\n\t\t\tsignalDelay, err = time.ParseDuration(s)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\n\t\trc := http.NewResponseController(w)\n\t\tstart := time.Now()\n\t\tkillSupervisedServicesAndUmountPerm(signalDelay)\n\t\tfmt.Fprintf(w, \"All services killed in %s\\n\", time.Since(start))\n\t\trc.Flush()\n\n\t\tlog.Println(\"Powering off\")\n\t\tw.Write([]byte(\"Powering off...\\n\"))\n\t\trc.Flush()\n\n\t\tgo func() {\n\t\t\ttime.Sleep(time.Second) // give the http response some time to be sent\n\t\t\tif err := unix.Reboot(unix.LINUX_REBOOT_CMD_POWER_OFF); err != nil {\n\t\t\t\tlog.Println(\"could not power off:\", err)\n\t\t\t}\n\t\t}()\n\t})\n\thttp.HandleFunc(\"/uploadtemp/\", uploadTemp)\n\thttp.HandleFunc(\"/divert\", divert)\n\n\treturn nil\n}\n\nfunc killSupervisedServicesAndUmountPerm(signalDelay time.Duration) {\n\tkillSupervisedServices(signalDelay)\n\n\tlog.Println(\"Unmounting /perm\")\n\tif err := syscall.Unmount(\"/perm\", unix.MNT_FORCE); err != nil {\n\t\tlog.Printf(\"unmounting /perm failed: %v\", err)\n\t}\n}\n\nfunc uploadTemp(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPut {\n\t\thttp.Error(w, \"expected a PUT request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdest := strings.TrimPrefix(r.URL.Path, \"/uploadtemp/\")\n\tlog.Printf(\"uploadtemp dest=%q\", dest)\n\tif strings.Contains(dest, \"/\") {\n\t\t// relative path in the temp directory\n\t\tdest = filepath.Join(os.TempDir(), dest)\n\t\tif err := os.MkdirAll(filepath.Dir(dest), 0700); err != nil {\n\t\t\tlog.Printf(\"updating %q failed: %v\", dest, err)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\t// not relative, create a subdirectory underneath the temp directory\n\t\ttmpdir, err := os.MkdirTemp(\"\", \"uploadtemp\")\n\t\tif err != nil {\n\t\t\tlog.Printf(\"updating %q failed: %v\", dest, err)\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\t// tmpdir will intentionally not be deleted, as the caller of\n\t\t// /uploadtemp will use the uploaded file afterwards.\n\t\tdest = filepath.Join(tmpdir, dest)\n\t}\n\n\tif err := createFile(dest, r.Body); err != nil {\n\t\tlog.Printf(\"updating %q failed: %v\", dest, err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tb, err := json.Marshal(struct {\n\t\tDest string `json:\"dest\"`\n\t}{\n\t\tDest: dest,\n\t})\n\tif err != nil {\n\t\tlog.Print(err)\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif _, err := w.Write(b); err != nil {\n\t\tlog.Print(err)\n\t}\n}\n\ntype divertRequest struct {\n\tPath      string   `json:\"Path\"`\n\tDiversion string   `json:\"Diversion\"`\n\tFlags     []string `json:\"Flags\"`\n}\n\nfunc divert(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"expected a POST request\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tvar req divertRequest\n\tif r.Header.Get(\"Content-Type\") == \"application/json\" {\n\t\tbody, err := io.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"couldn't read request body\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\terr = json.Unmarshal(body, &req)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"couldn't unmarshal request body\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t} else {\n\t\treq.Diversion = r.FormValue(\"diversion\")\n\t\treq.Path = r.FormValue(\"path\")\n\t}\n\n\tif req.Diversion == \"\" {\n\t\thttp.Error(w, \"diversion parameter is not set\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tsvc := findSvc(req.Path)\n\tnewService := svc == nil\n\tif newService {\n\t\tlog.Printf(\"adding new service in-memory to make diversion work\")\n\t\tcmd := exec.Command(req.Path, req.Flags...)\n\t\tsvc = NewService(cmd).s\n\t}\n\n\t// Ensure diversion binary is executable (/uploadtemp creates regular,\n\t// non-executable files).\n\tdiversion := filepath.Join(os.TempDir(), req.Diversion)\n\tif err := os.Chmod(diversion, 0755); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tsvc.setDiversion(diversion)\n\tcmd := svc.Cmd()\n\tcmd.Args = append([]string{cmd.Args[0]}, req.Flags...)\n\tsvc.setCmd(cmd)\n\n\tif newService {\n\t\tservices.Lock()\n\t\tservices.S = append(services.S, svc)\n\t\tservices.Unlock()\n\t\tgo supervise(svc)\n\t}\n\n\tif err := restart(svc, syscall.SIGTERM); err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "website",
          "type": "tree",
          "content": null
        },
        {
          "name": "xsrf.go",
          "type": "blob",
          "size": 0.9052734375,
          "content": "package gokrazy\n\nimport (\n\tcryptorand \"crypto/rand\"\n\t\"encoding/binary\"\n\t\"log\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"strconv\"\n\t\"sync\"\n)\n\nfunc xsrfTokenFromCookies(cookies []*http.Cookie) int32 {\n\tfor _, c := range cookies {\n\t\tif c.Name != \"gokrazy_xsrf\" {\n\t\t\tcontinue\n\t\t}\n\t\tif i, err := strconv.ParseInt(c.Value, 0, 32); err == nil {\n\t\t\treturn int32(i)\n\t\t}\n\t}\n\treturn 0\n}\n\n// lazyXsrf is a lazily initialized source of random numbers for generating XSRF\n// tokens. It is lazily initialized to not block early boot when reading\n// cryptographically strong random bytes to seed the RNG.\nvar lazyXsrf struct {\n\tonce sync.Once\n\trnd  *rand.Rand\n}\n\nfunc xsrfToken() int32 {\n\tlazyXsrf.once.Do(func() {\n\t\tvar buf [8]byte\n\t\tif _, err := cryptorand.Read(buf[:]); err != nil {\n\t\t\tlog.Fatalf(\"lazyXsrf: cryptorand.Read: %v\", err)\n\t\t}\n\t\tlazyXsrf.rnd = rand.New(rand.NewSource(int64(binary.BigEndian.Uint64(buf[:]))))\n\t})\n\treturn lazyXsrf.rnd.Int31()\n}\n"
        }
      ]
    }
  ]
}