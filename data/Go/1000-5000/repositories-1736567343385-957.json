{
  "metadata": {
    "timestamp": 1736567343385,
    "page": 957,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "thedevsaddam/gojsonq",
      "stars": 2195,
      "defaultBranch": "v2",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.025390625,
          "content": "data.json\n.idea\n.DS_Store\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.482421875,
          "content": "language: go\nsudo: false\n\nmatrix:\n  include:\n    - go: 1.6\n    - go: 1.7\n    - go: 1.8\n    - go: 1.9\n    - go: 1.10.x\n    - go: 1.11.x\n    - go: 1.12.x\n    - go: 1.13.x\n    - go: tip\n  allow_failures:\n    - go: tip\nbefore_install:\n  - go get github.com/mattn/goveralls\nscript:\n  - $GOPATH/bin/goveralls -service=travis-ci\n  - go get -t -v ./...\n  - diff -u <(echo -n) <(gofmt -d .)\n  - go vet $(go list ./... | grep -v /vendor/)\n  - go test -v -race ./...\n  - go test --bench . --benchmem=true\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.6123046875,
          "content": "# Contributing\n\n## Must follow the guide for issues\n  - Use the search tool before opening a new issue.\n  - Please provide source code and stack trace if you found a bug.\n  - Please review the existing issues and then provide feedback\n\n## Pull Request Process\n  - Before sending PR, create issue and discuss about the changes\n  - You MUST send pull requests against `dev` branch\n  - It should pass all tests in the available continuous integrations systems such as TravisCI.\n  - You should add/modify tests to cover your proposed code changes.\n  - If your pull request contains a new feature, please document it on the README.\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.107421875,
          "content": "# The MIT License (MIT)\n\nCopyright (c) 2018 Saddam H <thedevsaddam@gmail.com>\n\n> Permission is hereby granted, free of charge, to any person obtaining a copy\n> of this software and associated documentation files (the \"Software\"), to deal\n> in the Software without restriction, including without limitation the rights\n> to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n> copies of the Software, and to permit persons to whom the Software is\n> furnished to do so, subject to the following conditions:\n>\n> The above copyright notice and this permission notice shall be included in\n> all copies or substantial portions of the Software.\n>\n> THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n> IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n> FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n> AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n> LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n> OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n> THE SOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.3349609375,
          "content": "# Makefile includes some useful commands to build or format incentives\n# More commands could be added\n\n# Variables\nPROJECT = gojsonq\nREPO_ROOT = github.com/thedevsaddam\nROOT = ${REPO_ROOT}/${PROJECT}\n\nfmt:\n\tgoimports -w .\n\tgofmt -s -w .\n\ncompile: fmt\n\tgo install .\n\ncheck: fmt\n\tgolangci-lint run --deadline 10m ./...\n\tstaticcheck -checks=\"all,-S1*\" ./...\n\ndep:\n\tgo mod download\n\tgo mod vendor\n\tgo mod tidy\n\n# A user can invoke tests in different ways:\n#  - make test runs all tests;\n#  - make test TEST_TIMEOUT=10 runs all tests with a timeout of 10 seconds;\n#  - make test TEST_PKG=./model/... only runs tests for the model package;\n#  - make test TEST_ARGS=\"-v -short\" runs tests with the specified arguments;\n#  - make test-race runs tests with race detector enabled.\nTEST_TIMEOUT = 60\nTEST_PKGS ?= ./...\nTEST_TARGETS := test-short test-verbose test-race test-cover\n.PHONY: $(TEST_TARGETS) test\ntest-short:   TEST_ARGS=-short\ntest-verbose: TEST_ARGS=-v\ntest-race:    TEST_ARGS=-race\ntest-cover:   TEST_ARGS=-cover\n$(TEST_TARGETS): test\n\ntest: compile\n\tgo test -timeout $(TEST_TIMEOUT)s $(TEST_ARGS) $(TEST_PKGS)\n\nclean:\n\t@go clean\n\n.PHONY: help\nhelp:\n\t@$(MAKE) -pRrq -f $(lastword $(MAKEFILE_LIST)) : 2>/dev/null | \\\n\t\tawk -v RS= -F: '/^# File/,/^# Finished Make data base/ {if ($$1 !~ \"^[#.]\") {print $$1}}' | \\\n\t\tsort | \\\n\t\tegrep -v -e '^[^[:alnum:]]' -e '^$@$$'"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.6787109375,
          "content": "![gojsonq-logo](gojsonq.png)\n\n[![Build Status](https://travis-ci.org/thedevsaddam/gojsonq.svg?branch=master)](https://travis-ci.org/thedevsaddam/gojsonq)\n[![Project status](https://img.shields.io/badge/version-v2-green.svg)](https://github.com/thedevsaddam/gojsonq/releases)\n[![Go Report Card](https://goreportcard.com/badge/github.com/thedevsaddam/gojsonq)](https://goreportcard.com/report/github.com/thedevsaddam/gojsonq)\n[![Coverage Status](https://coveralls.io/repos/github/thedevsaddam/gojsonq/badge.svg?branch=master)](https://coveralls.io/github/thedevsaddam/gojsonq)\n[![GoDoc](https://godoc.org/github.com/thedevsaddam/gojsonq?status.svg)](https://pkg.go.dev/github.com/thedevsaddam/gojsonq/v2)\n[![License](https://img.shields.io/dub/l/vibe-d.svg)](LICENSE.md)\n\nA simple Go package to Query over JSON Data. It provides [simple](https://github.com/thedevsaddam/gojsonq/wiki/Queries#jsonstringjson), [elegant](https://github.com/thedevsaddam/gojsonq/wiki/Queries#selectproperties) and [fast](https://github.com/thedevsaddam/gojsonq/wiki/Benchmark) [ODM](https://github.com/thedevsaddam/gojsonq/wiki/Queries#frompath) like API to access, query JSON document\n\n### Installation\n\nInstall the package using\n```go\n$ go get github.com/thedevsaddam/gojsonq/v2\n```\n\n### Usage\n\nTo use the package import it in your `*.go` code\n```go\nimport \"github.com/thedevsaddam/gojsonq/v2\"\n```\n\nLet's see a quick example:\n\n[See in playground](https://play.golang.org/p/UiqyllP2vkn)\n\n```go\npackage main\n\nimport gojsonq \"github.com/thedevsaddam/gojsonq/v2\"\n\nfunc main() {\n\tconst json = `{\"name\":{\"first\":\"Tom\",\"last\":\"Hanks\"},\"age\":61}`\n\tname := gojsonq.New().FromString(json).Find(\"name.first\")\n\tprintln(name.(string)) // Tom\n}\n```\n\nAnother example:\n\n[See in playground](https://play.golang.org/p/QLVxpi6nVbi)\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\tgojsonq \"github.com/thedevsaddam/gojsonq/v2\"\n)\n\nfunc main() {\n\tconst json = `{\"city\":\"dhaka\",\"type\":\"weekly\",\"temperatures\":[30,39.9,35.4,33.5,31.6,33.2,30.7]}`\n\tavg := gojsonq.New().FromString(json).From(\"temperatures\").Avg()\n\tfmt.Printf(\"Average temperature: %.2f\", avg) // 33.471428571428575\n}\n```\n\nYou can query your document using the various query methods such as **[Find](https://github.com/thedevsaddam/gojsonq/wiki/Queries#findpath)**, **[First](https://github.com/thedevsaddam/gojsonq/wiki/Queries#first)**, **[Nth](https://github.com/thedevsaddam/gojsonq/wiki/Queries#nthindex)**, **[Pluck](https://github.com/thedevsaddam/gojsonq/wiki/Queries#pluckproperty)**,  **[Where](https://github.com/thedevsaddam/gojsonq/wiki/Queries#wherekey-op-val)**, **[OrWhere](https://github.com/thedevsaddam/gojsonq/wiki/Queries#orwherekey-op-val)**, **[WhereIn](https://github.com/thedevsaddam/gojsonq/wiki/Queries#whereinkey-val)**, **[WhereStartsWith](https://github.com/thedevsaddam/gojsonq/wiki/Queries#wherestartswithkey-val)**, **[WhereEndsWith](https://github.com/thedevsaddam/gojsonq/wiki/Queries#whereendswithkey-val)**, **[WhereContains](https://github.com/thedevsaddam/gojsonq/wiki/Queries#wherecontainskey-val)**, **[Sort](https://github.com/thedevsaddam/gojsonq/wiki/Queries#sortorder)**,  **[GroupBy](https://github.com/thedevsaddam/gojsonq/wiki/Queries#groupbyproperty)**,  **[SortBy](https://github.com/thedevsaddam/gojsonq/wiki/Queries#sortbyproperty-order)** and so on. Also you can aggregate data after query using **[Avg](https://github.com/thedevsaddam/gojsonq/wiki/Queries#avgproperty)**,  **[Count](https://github.com/thedevsaddam/gojsonq/wiki/Queries#count)**, **[Max](https://github.com/thedevsaddam/gojsonq/wiki/Queries#maxproperty)**, **[Min](https://github.com/thedevsaddam/gojsonq/wiki/Queries#minproperty)**, **[Sum](https://github.com/thedevsaddam/gojsonq/wiki/Queries#sumproperty)** etc.\n\n## Find more query API in [Wiki page](https://github.com/thedevsaddam/gojsonq/wiki/Queries)\n\n## Bugs and Issues\n\nIf you encounter any bugs or issues, feel free to [open an issue at\ngithub](https://github.com/thedevsaddam/gojsonq/issues).\n\nAlso, you can shoot me an email to\n<mailto:thedevsaddam@gmail.com> for hugs or bugs.\n\n## Credit\n\nSpecial thanks to [Nahid Bin Azhar](https://github.com/nahid) for the inspiration and guidance for the package. Thanks to [Ahmed Shamim Hasan Shaon](https://github.com/me-shaon) for his support from the very beginning.\n\n## Contributors\n* [Lenin Hasda](https://github.com/leninhasda)\n* [Sadlil Rhythom](https://github.com/sadlil)\n* [See contributors list here](https://github.com/thedevsaddam/gojsonq/graphs/contributors)\n\n## Contribution\nIf you are interested to make the package better please send pull requests or create an issue so that others can fix.\n[Read the contribution guide here](CONTRIBUTING.md)\n\n## License\nThe **gojsonq** is an open-source software licensed under the [MIT License](LICENSE.md).\n"
        },
        {
          "name": "decoder.go",
          "type": "blob",
          "size": 0.388671875,
          "content": "package gojsonq\n\nimport \"encoding/json\"\n\n// Decoder provide contract to decode JSON using custom decoder\ntype Decoder interface {\n\tDecode(data []byte, v interface{}) error\n}\n\n// DefaultDecoder use json.Unmarshal to decode JSON\ntype DefaultDecoder struct{}\n\n// Decode decodes using json.Unmarshal\nfunc (u *DefaultDecoder) Decode(data []byte, v interface{}) error {\n\treturn json.Unmarshal(data, v)\n}\n"
        },
        {
          "name": "decoder_test.go",
          "type": "blob",
          "size": 0.4287109375,
          "content": "package gojsonq\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_DefaultDecoder(t *testing.T) {\n\tdd := DefaultDecoder{}\n\tvar user = struct {\n\t\tName string `json:\"name\"`\n\t\tAge  int    `json:\"age\"`\n\t}{}\n\tif err := dd.Decode([]byte(`{\"name\": \"tom\", \"age\": 27}`), &user); err != nil {\n\t\tt.Errorf(\"failed to decode using default decoder: %v\", err)\n\t}\n\n\tif user.Name != \"tom\" || user.Age != 27 {\n\t\tt.Error(\"failed to decode properly by default decoder\")\n\t}\n\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.5849609375,
          "content": "// Package gojsonq provides a simple, elegant and fast ODM like API to access/query JSON document.\n//\n// JSON document can be read from file, string or io.Reader.\n// Accessing the value of json property or querying document is simple as the example below:\n//\n//  package main\n//\n//  import \"github.com/thedevsaddam/gojsonq\"\n//\n//  const json = `{\"name\":{\"first\":\"Tom\",\"last\":\"Hanks\"},\"age\":61}`\n//\n//  func main() {\n// \t name := gojsonq.New().FromString(json).Find(\"name.first\")\n// \t println(name.(string)) // Tom\n//  }\n//\n// For more details, see the documentation and examples.\n//\npackage gojsonq\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0498046875,
          "content": "module github.com/thedevsaddam/gojsonq/v2\n\ngo 1.13\n"
        },
        {
          "name": "gojsonq.png",
          "type": "blob",
          "size": 26.572265625,
          "content": null
        },
        {
          "name": "helper.go",
          "type": "blob",
          "size": 5.26171875,
          "content": "package gojsonq\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc abs(i int) int {\n\tif i < 0 {\n\t\ti = -1 * i\n\t}\n\treturn i\n}\n\nfunc isIndex(in string) bool {\n\treturn strings.HasPrefix(in, \"[\") && strings.HasSuffix(in, \"]\")\n}\n\nfunc getIndex(in string) (int, error) {\n\tif !isIndex(in) {\n\t\treturn -1, fmt.Errorf(\"invalid index\")\n\t}\n\tis := strings.TrimLeft(in, \"[\")\n\tis = strings.TrimRight(is, \"]\")\n\toint, err := strconv.Atoi(is)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\treturn oint, nil\n}\n\nfunc toString(v interface{}) string {\n\treturn fmt.Sprintf(\"%v\", v)\n}\n\n// toFloat64 converts interface{} value to float64 if value is numeric else return false\nfunc toFloat64(v interface{}) (float64, bool) {\n\tvar f float64\n\tflag := true\n\t// as Go convert the json Numeric value to float64\n\tswitch u := v.(type) {\n\tcase int:\n\t\tf = float64(u)\n\tcase int8:\n\t\tf = float64(u)\n\tcase int16:\n\t\tf = float64(u)\n\tcase int32:\n\t\tf = float64(u)\n\tcase int64:\n\t\tf = float64(u)\n\tcase float32:\n\t\tf = float64(u)\n\tcase float64:\n\t\tf = u\n\tdefault:\n\t\tflag = false\n\t}\n\treturn f, flag\n}\n\n// sortList sorts a list of interfaces\nfunc sortList(list []interface{}, asc bool) []interface{} {\n\tvar ss []string\n\tvar ff []float64\n\tvar result []interface{}\n\tfor _, v := range list {\n\t\t// sort elements for string\n\t\tif sv, ok := v.(string); ok {\n\t\t\tss = append(ss, sv)\n\t\t}\n\t\t// sort elements for float64\n\t\tif fv, ok := v.(float64); ok {\n\t\t\tff = append(ff, fv)\n\t\t}\n\t}\n\n\tif len(ss) > 0 {\n\t\tif asc {\n\t\t\tsort.Strings(ss)\n\t\t} else {\n\t\t\tsort.Sort(sort.Reverse(sort.StringSlice(ss)))\n\t\t}\n\t\tfor _, v := range ss {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\tif len(ff) > 0 {\n\t\tif asc {\n\t\t\tsort.Float64s(ff)\n\t\t} else {\n\t\t\tsort.Sort(sort.Reverse(sort.Float64Slice(ff)))\n\t\t}\n\t\tfor _, v := range ff {\n\t\t\tresult = append(result, v)\n\t\t}\n\t}\n\treturn result\n}\n\ntype sortMap struct {\n\tdata      interface{}\n\tkey       string\n\tdesc      bool\n\tseparator string\n\terrs      []error\n}\n\n// Sort sorts the slice of maps\nfunc (s *sortMap) Sort(data interface{}) {\n\ts.data = data\n\tsort.Sort(s)\n}\n\n// Len satisfies the sort.Interface\nfunc (s *sortMap) Len() int {\n\treturn reflect.ValueOf(s.data).Len()\n}\n\n// Swap satisfies the sort.Interface\nfunc (s *sortMap) Swap(i, j int) {\n\tif i > j {\n\t\ti, j = j, i\n\t}\n\tlist := reflect.ValueOf(s.data)\n\ttmp := list.Index(i).Interface()\n\tlist.Index(i).Set(list.Index(j))\n\tlist.Index(j).Set(reflect.ValueOf(tmp))\n}\n\n// TODO: need improvement\n// Less satisfies the sort.Interface\n// This will work for string/float64 only\nfunc (s *sortMap) Less(i, j int) (res bool) {\n\tlist := reflect.ValueOf(s.data)\n\tx := list.Index(i).Interface()\n\ty := list.Index(j).Interface()\n\n\t// compare nested values\n\tif strings.Contains(s.key, s.separator) {\n\t\txv, errX := getNestedValue(x, s.key, s.separator)\n\t\tif errX != nil {\n\t\t\ts.errs = append(s.errs, errX)\n\t\t}\n\t\tyv, errY := getNestedValue(y, s.key, s.separator)\n\t\tif errY != nil {\n\t\t\ts.errs = append(s.errs, errY)\n\t\t}\n\t\tres = s.compare(xv, yv)\n\t}\n\n\txv, okX := x.(map[string]interface{})\n\tif !okX {\n\t\treturn\n\t}\n\tyv := y.(map[string]interface{})\n\tif mvx, ok := xv[s.key]; ok {\n\t\tmvy := yv[s.key]\n\t\tres = s.compare(mvx, mvy)\n\t}\n\n\treturn\n}\n\n// compare compare two values\nfunc (s *sortMap) compare(x, y interface{}) (res bool) {\n\tif mfv, ok := x.(float64); ok {\n\t\tif mvy, oky := y.(float64); oky {\n\t\t\tif s.desc {\n\t\t\t\treturn mfv > mvy\n\t\t\t}\n\t\t\tres = mfv < mvy\n\t\t}\n\t}\n\n\tif mfv, ok := x.(string); ok {\n\t\tif mvy, oky := y.(string); oky {\n\t\t\tif s.desc {\n\t\t\t\treturn mfv > mvy\n\t\t\t}\n\t\t\tres = mfv < mvy\n\t\t}\n\t}\n\n\treturn\n}\n\n// getNestedValue fetch nested value from node\nfunc getNestedValue(input interface{}, node, separator string) (interface{}, error) {\n\tpp := strings.Split(node, separator)\n\tfor _, n := range pp {\n\t\tif isIndex(n) {\n\t\t\t// find slice/array\n\t\t\tif arr, ok := input.([]interface{}); ok {\n\t\t\t\tindx, err := getIndex(n)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn input, err\n\t\t\t\t}\n\t\t\t\tarrLen := len(arr)\n\t\t\t\tif arrLen == 0 ||\n\t\t\t\t\tindx > arrLen-1 {\n\t\t\t\t\treturn empty, errors.New(\"empty array\")\n\t\t\t\t}\n\t\t\t\tinput = arr[indx]\n\t\t\t}\n\t\t} else {\n\t\t\t// find in map\n\t\t\tvalidNode := false\n\t\t\tif mp, ok := input.(map[string]interface{}); ok {\n\t\t\t\tinput, ok = mp[n]\n\t\t\t\tvalidNode = ok\n\t\t\t}\n\n\t\t\t// find in group data\n\t\t\tif mp, ok := input.(map[string][]interface{}); ok {\n\t\t\t\tinput, ok = mp[n]\n\t\t\t\tvalidNode = ok\n\t\t\t}\n\n\t\t\tif !validNode {\n\t\t\t\treturn empty, fmt.Errorf(\"invalid node name %s\", n)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn input, nil\n}\n\n// makeAlias provide syntactic suger. when provide Property name as \"user.name as userName\"\n// it return userName as output and pure node name like: \"user.name\".\n// If \"user.name\" does not use \"as\" clause then it'll return \"user.name\", \"user.name\"\nfunc makeAlias(in, separator string) (string, string) {\n\tconst alias = \" as \"\n\tin = strings.Replace(in, \" As \", alias, -1)\n\tin = strings.Replace(in, \" AS \", alias, -1)\n\n\tif strings.Contains(in, alias) {\n\t\tss := strings.Split(in, alias)\n\t\treturn strings.TrimSpace(ss[0]), strings.TrimSpace(ss[1])\n\t}\n\n\tif strings.Contains(in, separator) {\n\t\tss := strings.Split(in, separator)\n\t\treturn in, ss[len(ss)-1]\n\t}\n\n\treturn in, in\n}\n\n// length return length of strings/array/map\nfunc length(v interface{}) (int, error) {\n\tswitch val := v.(type) {\n\tcase string:\n\t\treturn len(val), nil\n\tcase []interface{}:\n\t\treturn len(val), nil\n\tcase map[string]interface{}:\n\t\treturn len(val), nil\n\tdefault:\n\t\treturn -1, errors.New(\"invalid type for length\")\n\t}\n}\n"
        },
        {
          "name": "helper_test.go",
          "type": "blob",
          "size": 9.5830078125,
          "content": "package gojsonq\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"testing\"\n)\n\nfunc Test_abs(t *testing.T) {\n\ttestCases := []struct {\n\t\tdata     int\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tdata:     15,\n\t\t\texpected: 15,\n\t\t},\n\t\t{\n\t\t\tdata:     -25,\n\t\t\texpected: 25,\n\t\t},\n\t\t{\n\t\t\tdata:     0,\n\t\t\texpected: 0,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tif o := abs(tc.data); o != tc.expected {\n\t\t\tt.Errorf(\"expected: %v got: %v\", tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_isIndex(t *testing.T) {\n\ttestCases := []struct {\n\t\tnode     string\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tnode:     \"items\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tnode:     \"[0]\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tnode:     \"[101]\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tnode:     \"101\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tif o := isIndex(tc.node); o != tc.expected {\n\t\t\tt.Errorf(\"expected: %v got: %v\", tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_getIndex(t *testing.T) {\n\ttestCases := []struct {\n\t\tnode     string\n\t\texpected int\n\t}{\n\t\t{\n\t\t\tnode:     \"Invalid integer\",\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tnode:     \"item\",\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tnode:     \"[0]\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tnode:     \"101\",\n\t\t\texpected: -1,\n\t\t},\n\t\t{\n\t\t\tnode:     \"[101]\",\n\t\t\texpected: 101,\n\t\t},\n\t}\n\tfor _, tc := range testCases {\n\t\tif o, _ := getIndex(tc.node); o != tc.expected {\n\t\t\tt.Errorf(\"expected: %v got: %v\", tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_toString(t *testing.T) {\n\ttestCases := []struct {\n\t\tval      interface{}\n\t\texpected string\n\t}{\n\t\t{\n\t\t\tval:      10,\n\t\t\texpected: \"10\",\n\t\t},\n\t\t{\n\t\t\tval:      -10,\n\t\t\texpected: \"-10\",\n\t\t},\n\t\t{\n\t\t\tval:      10.99,\n\t\t\texpected: \"10.99\",\n\t\t},\n\t\t{\n\t\t\tval:      -10.99,\n\t\t\texpected: \"-10.99\",\n\t\t},\n\t\t{\n\t\t\tval:      true,\n\t\t\texpected: \"true\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o := toString(tc.val); o != tc.expected {\n\t\t\tt.Errorf(\"expected: %v got: %v\", tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_toFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\tval      interface{}\n\t\texpected float64\n\t}{\n\t\t{\n\t\t\tval:      10,\n\t\t\texpected: 10,\n\t\t},\n\t\t{\n\t\t\tval:      int8(1),\n\t\t\texpected: 1,\n\t\t},\n\t\t{\n\t\t\tval:      int16(91),\n\t\t\texpected: 91,\n\t\t},\n\t\t{\n\t\t\tval:      int32(88),\n\t\t\texpected: 88,\n\t\t},\n\t\t{\n\t\t\tval:      int64(898),\n\t\t\texpected: 898,\n\t\t},\n\t\t{\n\t\t\tval: float32(99.01),\n\t\t\t// The nearest IEEE754 float32 value of 99.01 is 99.01000213623047; which are not equal (while using ==).\n\t\t\t// Need suggestions for precision float value.\n\t\t\t// one way to solve the comparison using convertFloat(string with float precision)==float64\n\t\t\texpected: 99.01000213623047,\n\t\t},\n\t\t{\n\t\t\tval:      float32(-99),\n\t\t\texpected: -99,\n\t\t},\n\t\t{\n\t\t\tval:      -99.91,\n\t\t\texpected: -99.91,\n\t\t},\n\t\t{\n\t\t\tval:      \"\",\n\t\t\texpected: 0,\n\t\t},\n\t\t{\n\t\t\tval:      []int{},\n\t\t\texpected: 0,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := toFloat64(tc.val); o != tc.expected {\n\t\t\tt.Errorf(\"expected: %v got: %v\", tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_sorter(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag    string\n\t\tasc    bool\n\t\tinArr  []interface{}\n\t\toutArr []interface{}\n\t}{\n\t\t{\n\t\t\ttag:    \"list of string, result should be in ascending order\",\n\t\t\tasc:    true,\n\t\t\tinArr:  []interface{}{\"x\", \"b\", \"a\", \"c\", \"z\"},\n\t\t\toutArr: []interface{}{\"a\", \"b\", \"c\", \"x\", \"z\"},\n\t\t},\n\t\t{\n\t\t\ttag:    \"list of string, result should be in descending order\",\n\t\t\tasc:    false,\n\t\t\tinArr:  []interface{}{\"x\", \"b\", \"a\", \"c\", \"z\"},\n\t\t\toutArr: []interface{}{\"z\", \"x\", \"c\", \"b\", \"a\"},\n\t\t},\n\t\t{\n\t\t\ttag:    \"list of float64, result should be in ascending order\",\n\t\t\tasc:    true,\n\t\t\tinArr:  []interface{}{8.0, 7.0, 1.0, 3.0, 5.0, 8.0},\n\t\t\toutArr: []interface{}{1.0, 3.0, 5.0, 7.0, 8.0, 8.0},\n\t\t},\n\t\t{\n\t\t\ttag:    \"list of float64, result should be in descending order\",\n\t\t\tasc:    false,\n\t\t\tinArr:  []interface{}{8.0, 7.0, 1.0, 3.0, 5.0, 8.0},\n\t\t\toutArr: []interface{}{8.0, 8.0, 7.0, 5.0, 3.0, 1.0},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tobb, _ := json.Marshal(sortList(tc.inArr, tc.asc))\n\t\tebb, _ := json.Marshal(tc.outArr)\n\t\tif !bytes.Equal(obb, ebb) {\n\t\t\tt.Errorf(\"expected: %v got: %v\", string(obb), string(ebb))\n\t\t}\n\t}\n}\n\nfunc Test_sortMap(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag     string\n\t\tinObjs  interface{}\n\t\toutObjs interface{}\n\t\tkey     string\n\t\tasc     bool\n\t}{\n\t\t{\n\t\t\ttag: \"should return in ascending order of string value name\",\n\t\t\tkey: \"name\",\n\t\t\tasc: true,\n\t\t\tinObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t},\n\t\t\toutObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttag: \"should return in descending order of string value name\",\n\t\t\tkey: \"name\",\n\t\t\tasc: false,\n\t\t\tinObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t},\n\t\t\toutObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttag: \"should return in ascending order of float value height\",\n\t\t\tkey: \"height\",\n\t\t\tasc: true,\n\t\t\tinObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t},\n\t\t\toutObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\ttag: \"should return in descending order of float value height\",\n\t\t\tkey: \"height\",\n\t\t\tasc: false,\n\t\t\tinObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t},\n\t\t\toutObjs: []map[string]interface{}{\n\t\t\t\t{\"name\": \"X\", \"height\": 5.9},\n\t\t\t\t{\"name\": \"Z\", \"height\": 5.8},\n\t\t\t\t{\"name\": \"A\", \"height\": 5.5},\n\t\t\t\t{\"name\": \"D\", \"height\": 4.9},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tkey:     \"height\",\n\t\t\tasc:     false,\n\t\t\tinObjs:  []string{\"a\", \"z\", \"x\"},\n\t\t\toutObjs: []string{\"a\", \"z\", \"x\"},\n\t\t},\n\t\t{\n\t\t\tkey:     \"invalid_key\",\n\t\t\tasc:     false,\n\t\t\tinObjs:  []string{\"x\", \"z\", \"a\"},\n\t\t\toutObjs: []string{\"x\", \"z\", \"a\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tinObjs := tc.inObjs\n\t\tsm := &sortMap{}\n\t\tsm.key = tc.key\n\t\tsm.desc = !tc.asc\n\t\tsm.Sort(inObjs)\n\t\tassertInterface(t, inObjs, tc.outObjs, tc.tag)\n\t}\n}\n\nfunc Test_getNestedValue(t *testing.T) {\n\tvar content interface{}\n\tif err := json.Unmarshal([]byte(jsonStr), &content); err != nil {\n\t\tt.Error(\"failed to decode json:\", err)\n\t}\n\n\ttestCases := []struct {\n\t\ttag         string\n\t\tquery       string\n\t\texpected    interface{}\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\ttag:         \"accessing node\",\n\t\t\tquery:       \"vendor.name\",\n\t\t\texpected:    `Star Trek`,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"should return nil\",\n\t\t\tquery:       \"vendor.xox\",\n\t\t\texpected:    nil,\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\ttag:         \"should return a map\",\n\t\t\tquery:       \"vendor.items.[0]\",\n\t\t\texpected:    map[string]interface{}{\"id\": 1, \"name\": \"MacBook Pro 13 inch retina\", \"price\": 1350},\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"accessing not existed index\",\n\t\t\tquery:       \"vendor.items.[10]\",\n\t\t\texpected:    nil,\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\ttag:         \"accessing invalid index error\",\n\t\t\tquery:       \"vendor.items.[x]\",\n\t\t\texpected:    nil,\n\t\t\texpectError: true,\n\t\t},\n\t\t{\n\t\t\ttag:         \"should receive valid float value\",\n\t\t\tquery:       \"vendor.items.[0].price\",\n\t\t\texpected:    1350,\n\t\t\texpectError: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tout, err := getNestedValue(content, tc.query, defaultSeparator)\n\t\tif tc.expectError && err == nil {\n\t\t\tt.Error(\"failed to catch error\")\n\t\t}\n\t\tif !tc.expectError {\n\t\t\tassertInterface(t, tc.expected, out, tc.tag)\n\t\t}\n\t}\n}\n\nfunc Test_makeAlias(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tinput     string\n\t\tnode      string\n\t\talias     string\n\t\tseparator string\n\t}{\n\t\t{\n\t\t\ttag:       \"scenario 1\",\n\t\t\tinput:     \"user.name as uname\",\n\t\t\tnode:      \"user.name\",\n\t\t\talias:     \"uname\",\n\t\t\tseparator: \".\",\n\t\t},\n\t\t{\n\t\t\ttag:       \"scenario 2\",\n\t\t\tinput:     \"post.title\",\n\t\t\tnode:      \"post.title\",\n\t\t\talias:     \"title\",\n\t\t\tseparator: \".\",\n\t\t},\n\t\t{\n\t\t\ttag:       \"scenario 3\",\n\t\t\tinput:     \"name\",\n\t\t\tnode:      \"name\",\n\t\t\talias:     \"name\",\n\t\t\tseparator: \".\",\n\t\t},\n\t\t{\n\t\t\ttag:       \"scenario 4\",\n\t\t\tinput:     \"post->title\",\n\t\t\tnode:      \"post->title\",\n\t\t\talias:     \"title\",\n\t\t\tseparator: \"->\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tn, a := makeAlias(tc.input, tc.separator)\n\t\tif tc.node != n || tc.alias != a {\n\t\t\tt.Errorf(\"Tag: %v\\nExpected: %v %v \\nGot: %v %v\\n\", tc.tag, tc.node, tc.alias, n, a)\n\t\t}\n\t}\n}\n\nfunc Test_length(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag         string\n\t\tinput       interface{}\n\t\toutput      int\n\t\terrExpected bool\n\t}{\n\t\t{\n\t\t\ttag:         \"scenario 1: should return 5 with no error\",\n\t\t\tinput:       \"Hello\",\n\t\t\toutput:      5,\n\t\t\terrExpected: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"scenario 2: must return error with -1\",\n\t\t\tinput:       45,\n\t\t\toutput:      -1,\n\t\t\terrExpected: true,\n\t\t},\n\t\t{\n\t\t\ttag:         \"scenario 3: must return length of array\",\n\t\t\tinput:       []interface{}{\"john\", \"31\", false},\n\t\t\toutput:      3,\n\t\t\terrExpected: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"scenario 4: must return length of map\",\n\t\t\tinput:       map[string]interface{}{\"name\": \"john\", \"age\": 31, \"is_designer\": false},\n\t\t\toutput:      3,\n\t\t\terrExpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tout, outErr := length(tc.input)\n\t\tif out != tc.output {\n\t\t\tif tc.errExpected && outErr == nil {\n\t\t\t\tt.Errorf(\"tag: %s\\nExpected: %v\\nGot: %v\", tc.tag, tc.output, out)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "jetbrains-grayscale.png",
          "type": "blob",
          "size": 102.849609375,
          "content": null
        },
        {
          "name": "jsonq.go",
          "type": "blob",
          "size": 21.20703125,
          "content": "package gojsonq\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n)\n\n// New returns a new instance of JSONQ\nfunc New(options ...OptionFunc) *JSONQ {\n\tjq := &JSONQ{\n\t\tqueryMap: defaultQueries(),\n\t\toption: option{\n\t\t\tdecoder:   &DefaultDecoder{},\n\t\t\tseparator: defaultSeparator,\n\t\t},\n\t}\n\tfor _, option := range options {\n\t\tif err := option(jq); err != nil {\n\t\t\tjq.addError(err)\n\t\t}\n\t}\n\treturn jq\n}\n\n// empty represents an empty result\nvar empty interface{}\n\nconst defaultSeparator = \".\"\n\n// query describes a query\ntype query struct {\n\tkey, operator string\n\tvalue         interface{}\n}\n\n// JSONQ describes a JSONQ type which contains all the state\ntype JSONQ struct {\n\toption           option               // contains options for JSONQ\n\tqueryMap         map[string]QueryFunc // contains query functions\n\tnode             string               // contains node name\n\traw              json.RawMessage      // raw message from source (reader, string or file)\n\trootJSONContent  interface{}          // original decoded json data\n\tjsonContent      interface{}          // copy of original decoded json data for further processing\n\tqueryIndex       int                  // contains number of orWhere query call\n\tqueries          [][]query            // nested queries\n\tattributes       []string             // select attributes that will be available in final resuls\n\toffsetRecords    int                  // number of records that will be skipped in final result\n\tlimitRecords     int                  // number of records that will be available in final result\n\tdistinctProperty string               // contain the distinct attribute name\n\terrors           []error              // contains all the errors when processing\n}\n\n// String satisfies stringer interface\nfunc (j *JSONQ) String() string {\n\treturn fmt.Sprintf(\"\\nContent: %s\\nQueries:%v\\n\", string(j.raw), j.queries)\n}\n\n// decode decodes the raw message to Go data structure\nfunc (j *JSONQ) decode() *JSONQ {\n\terr := j.option.decoder.Decode(j.raw, &j.rootJSONContent)\n\tif err != nil {\n\t\treturn j.addError(err)\n\t}\n\tj.jsonContent = j.rootJSONContent\n\treturn j\n}\n\n// Copy returns a new fresh instance of JSONQ with the original copy of data so that you can do\n// concurrent operation on the same data without being decoded again\nfunc (j *JSONQ) Copy() *JSONQ {\n\ttmp := *j\n\treturn tmp.reset()\n}\n\n// File read the json content from physical file\nfunc (j *JSONQ) File(filename string) *JSONQ {\n\tbb, err := ioutil.ReadFile(filename)\n\tif err != nil {\n\t\treturn j.addError(err)\n\t}\n\tj.raw = bb\n\treturn j.decode() // handle error\n}\n\n// JSONString reads the json content from valid json string\n// Deprecated: this method will remove in next major release\nfunc (j *JSONQ) JSONString(json string) *JSONQ {\n\treturn j.FromString(json)\n}\n\n// FromString reads the content from valid json/xml/csv/yml string\nfunc (j *JSONQ) FromString(str string) *JSONQ {\n\tj.raw = []byte(str)\n\treturn j.decode() // handle error\n}\n\n// Reader reads the json content from io reader\nfunc (j *JSONQ) Reader(r io.Reader) *JSONQ {\n\tbuf := new(bytes.Buffer)\n\t_, err := buf.ReadFrom(r)\n\tif err != nil {\n\t\treturn j.addError(err)\n\t}\n\tj.raw = buf.Bytes()\n\tbuf.Reset() // reset the buffer\n\treturn j.decode()\n}\n\n// Error returns first occurred error\nfunc (j *JSONQ) Error() error {\n\terrsln := len(j.errors)\n\tif errsln == 0 {\n\t\treturn nil\n\t}\n\treturn j.errors[0]\n}\n\n// Errors returns list of all errors\nfunc (j *JSONQ) Errors() []error {\n\treturn j.errors\n}\n\n// addError adds error to error list\nfunc (j *JSONQ) addError(err error) *JSONQ {\n\tj.errors = append(j.errors, fmt.Errorf(\"gojsonq: %v\", err))\n\treturn j\n}\n\n// Macro adds a new query func to the JSONQ\nfunc (j *JSONQ) Macro(operator string, fn QueryFunc) *JSONQ {\n\tif _, ok := j.queryMap[operator]; ok {\n\t\tj.addError(fmt.Errorf(\"%s is already registered in query map\", operator))\n\t\treturn j\n\t}\n\tj.queryMap[operator] = fn\n\treturn j\n}\n\n// From seeks the json content to provided node. e.g: \"users.[0]\"  or \"users.[0].name\"\nfunc (j *JSONQ) From(node string) *JSONQ {\n\tj.node = node\n\tv, err := getNestedValue(j.jsonContent, node, j.option.separator)\n\tif err != nil {\n\t\tj.addError(err)\n\t}\n\tj.jsonContent = v\n\treturn j\n}\n\n// FromInterface reads the content from valid map[string]interface{}\nfunc (j *JSONQ) FromInterface(v interface{}) *JSONQ {\n\tswitch data := v.(type) {\n\tcase []interface{}, map[string]interface{}, map[string][]interface{}:\n\t\tj.rootJSONContent = data\n\t\tj.jsonContent = j.rootJSONContent\n\tdefault:\n\t\tj.addError(fmt.Errorf(\"invalid type [%T]\", v))\n\t}\n\treturn j\n}\n\n// Select use for selection of the properties from query result\nfunc (j *JSONQ) Select(properties ...string) *JSONQ {\n\tj.attributes = append(j.attributes, properties...)\n\treturn j\n}\n\n// Offset skips the number of records in result\nfunc (j *JSONQ) Offset(offset int) *JSONQ {\n\tj.offsetRecords = offset\n\treturn j\n}\n\n// offset skips the records from result\nfunc (j *JSONQ) offset() *JSONQ {\n\tif list, ok := j.jsonContent.([]interface{}); ok {\n\t\tif j.offsetRecords < 0 {\n\t\t\tj.addError(fmt.Errorf(\"%d is invalid offset\", j.offsetRecords))\n\t\t\treturn j\n\t\t}\n\t\tif len(list) >= j.offsetRecords {\n\t\t\tj.jsonContent = list[j.offsetRecords:]\n\t\t} else {\n\t\t\tj.jsonContent = make([]interface{}, 0)\n\t\t}\n\t}\n\treturn j\n}\n\n// Limit limits the number of records in result\nfunc (j *JSONQ) Limit(limit int) *JSONQ {\n\tj.limitRecords = limit\n\treturn j\n}\n\n// limit return the number of records in result set depending on the limit value\nfunc (j *JSONQ) limit() *JSONQ {\n\tif list, ok := j.jsonContent.([]interface{}); ok {\n\t\tif j.limitRecords <= 0 {\n\t\t\tj.addError(fmt.Errorf(\"%d is invalid limit\", j.limitRecords))\n\t\t\treturn j\n\t\t}\n\t\tif len(list) > j.limitRecords {\n\t\t\tj.jsonContent = list[:j.limitRecords]\n\t\t}\n\t}\n\treturn j\n}\n\n// Where builds a where clause. e.g: Where(\"name\", \"contains\", \"doe\")\nfunc (j *JSONQ) Where(key, cond string, val interface{}) *JSONQ {\n\tq := query{\n\t\tkey:      key,\n\t\toperator: cond,\n\t\tvalue:    val,\n\t}\n\tif j.queryIndex == 0 && len(j.queries) == 0 {\n\t\tvar qq []query\n\t\tqq = append(qq, q)\n\t\tj.queries = append(j.queries, qq)\n\t} else {\n\t\tj.queries[j.queryIndex] = append(j.queries[j.queryIndex], q)\n\t}\n\n\treturn j\n}\n\n// WhereEqual is an alias of Where(\"key\", \"=\", val)\nfunc (j *JSONQ) WhereEqual(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorEq, val)\n}\n\n// WhereNotEqual is an alias of Where(\"key\", \"!=\", val)\nfunc (j *JSONQ) WhereNotEqual(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorNotEq, val)\n}\n\n// WhereNil is an alias of Where(\"key\", \"=\", nil)\nfunc (j *JSONQ) WhereNil(key string) *JSONQ {\n\treturn j.Where(key, operatorEq, nil)\n}\n\n// WhereNotNil is an alias of Where(\"key\", \"!=\", nil)\nfunc (j *JSONQ) WhereNotNil(key string) *JSONQ {\n\treturn j.Where(key, operatorNotEq, nil)\n}\n\n// WhereIn is an alias for where(\"key\", \"in\", []string{\"a\", \"b\"})\nfunc (j *JSONQ) WhereIn(key string, val interface{}) *JSONQ {\n\tj.Where(key, operatorIn, val)\n\treturn j\n}\n\n// WhereNotIn is an alias for where(\"key\", \"notIn\", []string{\"a\", \"b\"})\nfunc (j *JSONQ) WhereNotIn(key string, val interface{}) *JSONQ {\n\tj.Where(key, operatorNotIn, val)\n\treturn j\n}\n\n// OrWhere builds an OrWhere clause, basically it's a group of AND clauses\nfunc (j *JSONQ) OrWhere(key, cond string, val interface{}) *JSONQ {\n\tj.queryIndex++\n\tvar qq []query\n\tqq = append(qq, query{\n\t\tkey:      key,\n\t\toperator: cond,\n\t\tvalue:    val,\n\t})\n\tj.queries = append(j.queries, qq)\n\treturn j\n}\n\n// WhereStartsWith satisfies Where clause which starts with provided value(string)\nfunc (j *JSONQ) WhereStartsWith(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorStartsWith, val)\n}\n\n// WhereEndsWith satisfies Where clause which ends with provided value(string)\nfunc (j *JSONQ) WhereEndsWith(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorEndsWith, val)\n}\n\n// WhereContains satisfies Where clause which contains provided value(string)\nfunc (j *JSONQ) WhereContains(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorContains, val)\n}\n\n// WhereStrictContains satisfies Where clause which contains provided value(string).\n// This is case sensitive\nfunc (j *JSONQ) WhereStrictContains(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorStrictContains, val)\n}\n\n// WhereLenEqual is an alias of Where(\"key\", \"leneq\", val)\nfunc (j *JSONQ) WhereLenEqual(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorLenEq, val)\n}\n\n// WhereLenNotEqual is an alias of Where(\"key\", \"lenneq\", val)\nfunc (j *JSONQ) WhereLenNotEqual(key string, val interface{}) *JSONQ {\n\treturn j.Where(key, operatorLenNotEq, val)\n}\n\n// findInArray traverses through a list and returns the value list.\n// This helps to process Where/OrWhere queries\nfunc (j *JSONQ) findInArray(aa []interface{}) []interface{} {\n\tresult := make([]interface{}, 0)\n\tfor _, a := range aa {\n\t\tif m, ok := a.(map[string]interface{}); ok {\n\t\t\tresult = append(result, j.findInMap(m)...)\n\t\t}\n\t}\n\treturn result\n}\n\n// findInMap traverses through a map and returns the matched value list.\n// This helps to process Where/OrWhere queries\nfunc (j *JSONQ) findInMap(vm map[string]interface{}) []interface{} {\n\tresult := make([]interface{}, 0)\n\torPassed := false\n\tfor _, qList := range j.queries {\n\t\tandPassed := true\n\t\tfor _, q := range qList {\n\t\t\tcf, ok := j.queryMap[q.operator]\n\t\t\tif !ok {\n\t\t\t\tj.addError(fmt.Errorf(\"invalid operator %s\", q.operator))\n\t\t\t\treturn result\n\t\t\t}\n\t\t\tnv, errnv := getNestedValue(vm, q.key, j.option.separator)\n\t\t\tif errnv != nil {\n\t\t\t\tj.addError(errnv)\n\t\t\t\tandPassed = false\n\t\t\t} else {\n\t\t\t\tqb, err := cf(nv, q.value)\n\t\t\t\tif err != nil {\n\t\t\t\t\tj.addError(err)\n\t\t\t\t}\n\t\t\t\tandPassed = andPassed && qb\n\t\t\t}\n\t\t}\n\t\torPassed = orPassed || andPassed\n\t}\n\tif orPassed {\n\t\tresult = append(result, vm)\n\t}\n\treturn result\n}\n\n// processQuery makes the result\nfunc (j *JSONQ) processQuery() *JSONQ {\n\tif aa, ok := j.jsonContent.([]interface{}); ok {\n\t\tj.jsonContent = j.findInArray(aa)\n\t}\n\treturn j\n}\n\n// prepare builds the queries\nfunc (j *JSONQ) prepare() *JSONQ {\n\tif len(j.queries) > 0 {\n\t\tj.processQuery()\n\t}\n\tif j.distinctProperty != \"\" {\n\t\tj.distinct()\n\t}\n\tif len(j.attributes) > 0 {\n\t\tj.jsonContent = j.only(j.attributes...)\n\t}\n\tj.queryIndex = 0\n\treturn j\n}\n\n// GroupBy builds a chunk of exact matched data in a group list using provided attribute/column/property\nfunc (j *JSONQ) GroupBy(property string) *JSONQ {\n\tj.prepare()\n\n\tdt := map[string][]interface{}{}\n\tif aa, ok := j.jsonContent.([]interface{}); ok {\n\t\tfor _, a := range aa {\n\t\t\tif vm, ok := a.(map[string]interface{}); ok {\n\t\t\t\tv, err := getNestedValue(vm, property, j.option.separator)\n\t\t\t\tif err != nil {\n\t\t\t\t\tj.addError(err)\n\t\t\t\t} else {\n\t\t\t\t\tdt[toString(v)] = append(dt[toString(v)], vm)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// replace the new result with the previous result\n\tj.jsonContent = dt\n\treturn j\n}\n\n// Sort sorts an array\n// default ascending order, pass \"desc\" for descending order\nfunc (j *JSONQ) Sort(order ...string) *JSONQ {\n\tj.prepare()\n\n\tasc := true\n\tif len(order) > 1 {\n\t\treturn j.addError(fmt.Errorf(\"sort accepts only one argument asc/desc\"))\n\t}\n\tif len(order) > 0 && order[0] == \"desc\" {\n\t\tasc = false\n\t}\n\tif arr, ok := j.jsonContent.([]interface{}); ok {\n\t\tj.jsonContent = sortList(arr, asc)\n\t}\n\treturn j\n}\n\n// SortBy sorts an array\n// default ascending order, pass \"desc\" for descending order\nfunc (j *JSONQ) SortBy(order ...string) *JSONQ {\n\tj.prepare()\n\tasc := true\n\tif len(order) == 0 {\n\t\treturn j.addError(fmt.Errorf(\"provide at least one argument as property name\"))\n\t}\n\tif len(order) > 2 {\n\t\treturn j.addError(fmt.Errorf(\"sort accepts only two arguments. first argument property name and second argument asc/desc\"))\n\t}\n\n\tif len(order) > 1 && order[1] == \"desc\" {\n\t\tasc = false\n\t}\n\n\treturn j.sortBy(order[0], asc)\n}\n\n// Distinct builds distinct value using provided attribute/column/property\nfunc (j *JSONQ) Distinct(property string) *JSONQ {\n\tj.distinctProperty = property\n\treturn j\n}\n\n// distinct builds distinct value using provided attribute/column/property\nfunc (j *JSONQ) distinct() *JSONQ {\n\tm := map[string]bool{}\n\tvar dt = make([]interface{}, 0)\n\tif aa, ok := j.jsonContent.([]interface{}); ok {\n\t\tfor _, a := range aa {\n\t\t\tif vm, ok := a.(map[string]interface{}); ok {\n\t\t\t\tv, err := getNestedValue(vm, j.distinctProperty, j.option.separator)\n\t\t\t\tif err != nil {\n\t\t\t\t\tj.addError(err)\n\t\t\t\t} else {\n\t\t\t\t\tif _, exist := m[toString(v)]; !exist {\n\t\t\t\t\t\tdt = append(dt, vm)\n\t\t\t\t\t\tm[toString(v)] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// replace the new result with the previous result\n\tj.jsonContent = dt\n\treturn j\n}\n\n// sortBy sorts list of map\nfunc (j *JSONQ) sortBy(property string, asc bool) *JSONQ {\n\tsortResult, ok := j.jsonContent.([]interface{})\n\tif !ok {\n\t\treturn j\n\t}\n\tif len(sortResult) == 0 {\n\t\treturn j\n\t}\n\n\tsm := &sortMap{}\n\tsm.separator = j.option.separator\n\tsm.key = property\n\tif !asc {\n\t\tsm.desc = true\n\t}\n\tsm.Sort(sortResult)\n\n\tfor _, e := range sm.errs {\n\t\tj.addError(e)\n\t}\n\n\t// replace the new result with the previous result\n\tj.jsonContent = sortResult\n\treturn j\n}\n\n// only return selected properties in result\nfunc (j *JSONQ) only(properties ...string) interface{} {\n\tvar result = make([]interface{}, 0)\n\tif aa, ok := j.jsonContent.([]interface{}); ok {\n\t\tfor _, am := range aa {\n\t\t\ttmap := map[string]interface{}{}\n\t\t\tfor _, prop := range properties {\n\t\t\t\tnode, alias := makeAlias(prop, j.option.separator)\n\t\t\t\trv, errV := getNestedValue(am, node, j.option.separator)\n\t\t\t\tif errV != nil {\n\t\t\t\t\tj.addError(errV)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\ttmap[alias] = rv\n\t\t\t}\n\t\t\tif len(tmap) > 0 {\n\t\t\t\tresult = append(result, tmap)\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n// Only collects the properties from a list of object\nfunc (j *JSONQ) Only(properties ...string) interface{} {\n\treturn j.prepare().only(properties...)\n}\n\n// OnlyR collects the properties from a list of object and return as Result instance\nfunc (j *JSONQ) OnlyR(properties ...string) (*Result, error) {\n\tv := j.Only(properties...)\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// Pluck build an array of values form a property of a list of objects\nfunc (j *JSONQ) Pluck(property string) interface{} {\n\tj.prepare()\n\tif j.distinctProperty != \"\" {\n\t\tj.distinct()\n\t}\n\tif j.limitRecords != 0 {\n\t\tj.limit()\n\t}\n\tvar result = make([]interface{}, 0)\n\tif aa, ok := j.jsonContent.([]interface{}); ok {\n\t\tfor _, am := range aa {\n\t\t\tif mv, ok := am.(map[string]interface{}); ok {\n\t\t\t\tif v, ok := mv[property]; ok {\n\t\t\t\t\tresult = append(result, v)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result\n}\n\n// PluckR build an array of values form a property of a list of objects and return as Result instance\nfunc (j *JSONQ) PluckR(property string) (*Result, error) {\n\tv := j.Pluck(property)\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// reset resets the current state of JSONQ instance\nfunc (j *JSONQ) reset() *JSONQ {\n\tj.raw = nil\n\tj.jsonContent = j.rootJSONContent\n\tj.node = \"\"\n\tj.queries = make([][]query, 0)\n\tj.attributes = make([]string, 0)\n\tj.queryIndex = 0\n\tj.offsetRecords = 0\n\tj.limitRecords = 0\n\tj.distinctProperty = \"\"\n\tj.errors = make([]error, 0)\n\treturn j\n}\n\n// Reset resets the current state of JSON instance and make a fresh object with the original json content\nfunc (j *JSONQ) Reset() *JSONQ {\n\treturn j.reset()\n}\n\n// Get return the result\nfunc (j *JSONQ) Get() interface{} {\n\tj.prepare()\n\tif j.offsetRecords != 0 {\n\t\tj.offset()\n\t}\n\tif j.limitRecords != 0 {\n\t\tj.limit()\n\t}\n\treturn j.jsonContent\n}\n\n// GetR return the query results as Result instance\nfunc (j *JSONQ) GetR() (*Result, error) {\n\tv := j.Get()\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// First returns the first element of a list\nfunc (j *JSONQ) First() interface{} {\n\tj.prepare()\n\tif arr, ok := j.jsonContent.([]interface{}); ok {\n\t\tif len(arr) > 0 {\n\t\t\treturn arr[0]\n\t\t}\n\t}\n\treturn empty\n}\n\n// FirstR returns the first element of a list as Result instance\nfunc (j *JSONQ) FirstR() (*Result, error) {\n\tv := j.First()\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// Last returns the last element of a list\nfunc (j *JSONQ) Last() interface{} {\n\tj.prepare()\n\tif arr, ok := j.jsonContent.([]interface{}); ok {\n\t\tif l := len(arr); l > 0 {\n\t\t\treturn arr[l-1]\n\t\t}\n\t}\n\treturn empty\n}\n\n// LastR returns the last element of a list as Result instance\nfunc (j *JSONQ) LastR() (*Result, error) {\n\tv := j.Last()\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// Nth returns the nth element of a list\nfunc (j *JSONQ) Nth(index int) interface{} {\n\tif index == 0 {\n\t\tj.addError(fmt.Errorf(\"index is not zero based\"))\n\t\treturn empty\n\t}\n\n\tj.prepare()\n\tif arr, ok := j.jsonContent.([]interface{}); ok {\n\t\talen := len(arr)\n\t\tif alen == 0 {\n\t\t\tj.addError(fmt.Errorf(\"list is empty\"))\n\t\t\treturn empty\n\t\t}\n\t\tif abs(index) > alen {\n\t\t\tj.addError(fmt.Errorf(\"index out of range\"))\n\t\t\treturn empty\n\t\t}\n\t\tif index > 0 {\n\t\t\treturn arr[index-1]\n\t\t}\n\t\treturn arr[alen+index]\n\t}\n\treturn empty\n}\n\n// NthR returns the nth element of a list as Result instance\nfunc (j *JSONQ) NthR(index int) (*Result, error) {\n\tv := j.Nth(index)\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// Find returns the result of a exact matching path\nfunc (j *JSONQ) Find(path string) interface{} {\n\treturn j.From(path).Get()\n}\n\n// FindR returns the result as Result instance from the exact matching path\nfunc (j *JSONQ) FindR(path string) (*Result, error) {\n\tv := j.Find(path)\n\tif err := j.Error(); err != nil {\n\t\treturn nil, err\n\t}\n\treturn NewResult(v), nil\n}\n\n// Count returns the number of total items.\n// This could be a length of list/array/map\nfunc (j *JSONQ) Count() int {\n\tj.prepare()\n\tvar lnth int\n\t// list of items\n\tif list, ok := j.jsonContent.([]interface{}); ok {\n\t\tlnth = len(list)\n\t}\n\t// return map len // TODO: need to think about map\n\tif m, ok := j.jsonContent.(map[string]interface{}); ok {\n\t\tlnth = len(m)\n\t}\n\t// group data items\n\tif m, ok := j.jsonContent.(map[string][]interface{}); ok {\n\t\tlnth = len(m)\n\t}\n\n\treturn lnth\n}\n\n// Out write the queried data to defined custom type\nfunc (j *JSONQ) Out(v interface{}) {\n\tdata, err := json.Marshal(j.Get())\n\tif err != nil {\n\t\tj.addError(err)\n\t\treturn\n\t}\n\tif err := json.Unmarshal(data, &v); err != nil {\n\t\tj.addError(err)\n\t}\n}\n\n// Writer write the queried data to a io.Writer\nfunc (j *JSONQ) Writer(w io.Writer) {\n\terr := json.NewEncoder(w).Encode(j.Get())\n\tif err != nil {\n\t\tj.addError(err)\n\t\treturn\n\t}\n}\n\n// More provides the functionality to query over the resultant data. See https://github.com/thedevsaddam/gojsonq/wiki/Queries#More\nfunc (j *JSONQ) More() *JSONQ {\n\tj.raw = nil\n\tj.rootJSONContent = j.Get()\n\tj.node = \"\"\n\tj.queries = make([][]query, 0)\n\tj.attributes = make([]string, 0)\n\tj.queryIndex = 0\n\tj.limitRecords = 0\n\tj.distinctProperty = \"\"\n\treturn j\n}\n\n// getFloatValFromArray returns a list of float64 values from array/map for aggregation\nfunc (j *JSONQ) getFloatValFromArray(arr []interface{}, property ...string) []float64 {\n\tvar ff []float64\n\tfor _, a := range arr {\n\t\tif av, ok := a.(float64); ok {\n\t\t\tif len(property) > 0 {\n\t\t\t\tj.addError(fmt.Errorf(\"unnecessary property name for array\"))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tff = append(ff, av)\n\t\t}\n\t\tif mv, ok := a.(map[string]interface{}); ok {\n\t\t\tif len(property) == 0 {\n\t\t\t\tj.addError(fmt.Errorf(\"property name can not be empty for object\"))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tif fi, ok := mv[property[0]]; ok {\n\t\t\t\tif flt, ok := fi.(float64); ok {\n\t\t\t\t\tff = append(ff, flt)\n\t\t\t\t} else {\n\t\t\t\t\tj.addError(fmt.Errorf(\"property %s's value '%v' is not numeric\", property[0], fi))\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tj.addError(fmt.Errorf(\"property '%s' does not exist\", property[0]))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ff\n}\n\n// getAggregationValues returns a list of float64 values for aggregation\nfunc (j *JSONQ) getAggregationValues(property ...string) []float64 {\n\tj.prepare()\n\tif j.distinctProperty != \"\" {\n\t\tj.distinct()\n\t}\n\tif j.limitRecords != 0 {\n\t\tj.limit()\n\t}\n\n\tvar ff []float64\n\tif arr, ok := j.jsonContent.([]interface{}); ok {\n\t\tff = j.getFloatValFromArray(arr, property...)\n\t}\n\n\tif mv, ok := j.jsonContent.(map[string]interface{}); ok {\n\t\tif len(property) == 0 {\n\t\t\tj.addError(fmt.Errorf(\"property can not be empty for object\"))\n\t\t\treturn nil\n\t\t}\n\t\tif fi, ok := mv[property[0]]; ok {\n\t\t\tif flt, ok := fi.(float64); ok {\n\t\t\t\tff = append(ff, flt)\n\t\t\t} else {\n\t\t\t\tj.addError(fmt.Errorf(\"property %s's value '%v' is not numeric\", property[0], fi))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t} else {\n\t\t\tj.addError(fmt.Errorf(\"property '%s' does not exist\", property[0]))\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn ff\n}\n\n// Sum returns sum of values from array or from map using property\nfunc (j *JSONQ) Sum(property ...string) float64 {\n\tvar sum float64\n\tfor _, flt := range j.getAggregationValues(property...) {\n\t\tsum += flt\n\t}\n\treturn sum\n}\n\n// Avg returns average of values from array or from map using property\nfunc (j *JSONQ) Avg(property ...string) float64 {\n\tvar sum float64\n\tfl := j.getAggregationValues(property...)\n\tfor _, flt := range fl {\n\t\tsum += flt\n\t}\n\treturn sum / float64(len(fl))\n}\n\n// Min returns minimum value from array or from map using property\nfunc (j *JSONQ) Min(property ...string) float64 {\n\tvar min float64\n\tflist := j.getAggregationValues(property...)\n\tif len(flist) > 0 {\n\t\tmin = flist[0]\n\t}\n\tfor _, flt := range flist {\n\t\tif flt < min {\n\t\t\tmin = flt\n\t\t}\n\t}\n\treturn min\n}\n\n// Max returns maximum value from array or from map using property\nfunc (j *JSONQ) Max(property ...string) float64 {\n\tvar max float64\n\tflist := j.getAggregationValues(property...)\n\tif len(flist) > 0 {\n\t\tmax = flist[0]\n\t}\n\tfor _, flt := range flist {\n\t\tif flt > max {\n\t\t\tmax = flt\n\t\t}\n\t}\n\treturn max\n}\n"
        },
        {
          "name": "jsonq_test.go",
          "type": "blob",
          "size": 45.9697265625,
          "content": "package gojsonq\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestNew(t *testing.T) {\n\tjq := New()\n\tif reflect.ValueOf(jq).Type().String() != \"*gojsonq.JSONQ\" {\n\t\tt.Error(\"failed to match JSONQ type\")\n\t}\n}\n\nfunc TestJSONQ_String(t *testing.T) {\n\tjq := New()\n\texpected := fmt.Sprintf(\"\\nContent: %s\\nQueries:%v\\n\", string(jq.raw), jq.queries)\n\tif out := jq.String(); out != expected {\n\t\tt.Errorf(\"Expected: %v\\n Got: %v\", expected, out)\n\t}\n}\n\nfunc TestJSONQ_decode(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tjsonStr   string\n\t\terrExpect bool\n\t}{\n\t\t{\n\t\t\ttag:       \"valid json\",\n\t\t\tjsonStr:   `{\"name\": \"John Doe\", \"age\": 30}`,\n\t\t\terrExpect: false,\n\t\t},\n\t\t{\n\t\t\ttag:       \"invalid json should return error\",\n\t\t\tjsonStr:   `{\"name\": \"John Doe\", \"age\": 30, \"only_key\"}`,\n\t\t\terrExpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tjq := New()\n\t\tjq.raw = json.RawMessage(tc.jsonStr)\n\t\tjq.decode()\n\t\tif err := jq.Error(); err != nil && !tc.errExpect {\n\t\t\tt.Errorf(\"failed %s\", tc.tag)\n\t\t}\n\t}\n}\n\nfunc TestJSONQ_Copy(t *testing.T) {\n\tjq := New()\n\tmp := map[string]int{}\n\tfor i := 0; i < 100; i++ {\n\t\tadr := fmt.Sprintf(\"%p\", jq.Copy())\n\t\tif _, ok := mp[adr]; ok {\n\t\t\tt.Error(\"failed to copy JSONQ\")\n\t\t} else {\n\t\t\tmp[adr] = i\n\t\t}\n\t}\n}\n\nfunc TestJSONQ_File(t *testing.T) {\n\tfilename := \"data.json\"\n\n\tpath, f := createTestFile(t, filename)\n\tdefer f()\n\n\ttestCases := []struct {\n\t\ttag         string\n\t\tfilename    string\n\t\texpectedErr bool\n\t}{\n\t\t{\n\t\t\ttag:         \"valid file name does not expect error\",\n\t\t\tfilename:    path,\n\t\t\texpectedErr: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"invalid valid file name expecting error\",\n\t\t\tfilename:    \"invalid_file.xjson\",\n\t\t\texpectedErr: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\terr := New().File(tc.filename).Error()\n\t\tif tc.expectedErr && err == nil {\n\t\t\tt.Errorf(\"%s\", tc.tag)\n\t\t}\n\t}\n}\n\nfunc TestJSONQ_JSONString(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tjsonStr   string\n\t\terrExpect bool\n\t}{\n\t\t{\n\t\t\ttag:       \"valid json\",\n\t\t\tjsonStr:   `{\"name\": \"John Doe\", \"age\": 30}`,\n\t\t\terrExpect: false,\n\t\t},\n\t\t{\n\t\t\ttag:       \"invalid json should return error\",\n\t\t\tjsonStr:   `{\"name\": \"John Doe\", \"age\": 30, \"only_key\"}`,\n\t\t\terrExpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif err := New().FromString(tc.jsonStr).Error(); err != nil && !tc.errExpect {\n\t\t\tt.Errorf(\"failed %s\", tc.tag)\n\t\t}\n\t}\n}\n\nfunc TestJSONQ_FromString(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tinputStr  string\n\t\terrExpect bool\n\t}{\n\t\t// TODO: Doesn't need to test decoder for input content\n\t\t{\n\t\t\ttag:       \"valid json\",\n\t\t\tinputStr:  `{\"name\": \"John Doe\", \"age\": 30}`,\n\t\t\terrExpect: false,\n\t\t},\n\t\t{\n\t\t\ttag:       \"invalid json should return error\",\n\t\t\tinputStr:  `{\"name\": \"John Doe\", \"age\": 30, \"only_key\"}`,\n\t\t\terrExpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif err := New().FromString(tc.inputStr).Error(); err != nil && !tc.errExpect {\n\t\t\tt.Errorf(\"failed %s\", tc.tag)\n\t\t}\n\t}\n}\n\nfunc TestJSONQ_Reader(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tjsonStr   string\n\t\terrExpect bool\n\t}{\n\t\t{\n\t\t\ttag:       \"valid json\",\n\t\t\tjsonStr:   `{\"name\": \"John Doe\", \"age\": 30}`,\n\t\t\terrExpect: false,\n\t\t},\n\t\t{\n\t\t\ttag:       \"invalid json should return error\",\n\t\t\tjsonStr:   `{\"name\": \"John Doe\", \"age\": 30, \"only_key\"}`,\n\t\t\terrExpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\trdr := strings.NewReader(tc.jsonStr)\n\t\tif err := New().Reader(rdr).Error(); err != nil && !tc.errExpect {\n\t\t\tt.Errorf(\"failed %s\", tc.tag)\n\t\t}\n\t}\n}\n\ntype invalidReader string\n\nfunc (invalidReader) Read(p []byte) (n int, err error) {\n\treturn 0, errors.New(\"this reader always return an error\")\n}\n\nfunc TestJSONQ_Reader_expecting_error(t *testing.T) {\n\tvar rdr invalidReader\n\tif err := New().Reader(rdr).Error(); err == nil {\n\t\tt.Errorf(\"failed to catch Reader error\")\n\t}\n}\n\nfunc TestJSONQ_Errors(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag     string\n\t\tjsonStr string\n\t}{\n\t\t{\n\t\t\ttag:     \"invalid json 1\",\n\t\t\tjsonStr: `{\"name\": \"John Doe\", \"age\": 30, :\"\"}`,\n\t\t},\n\t\t{\n\t\t\ttag:     \"invalid json 2\",\n\t\t\tjsonStr: `{\"name\": \"John Doe\", \"age\": 30, \"only_key\"}`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif errs := New().FromString(tc.jsonStr).Errors(); len(errs) == 0 {\n\t\t\tt.Errorf(\"failed %s\", tc.tag)\n\t\t}\n\t}\n}\n\nfunc TestJSONQ_Macro(t *testing.T) {\n\tjq := New()\n\tjq.Macro(\"mac1\", func(x, y interface{}) (bool, error) {\n\t\treturn true, nil\n\t})\n\n\tif _, ok := jq.queryMap[\"mac1\"]; !ok {\n\t\tt.Error(\"failed to register macro\")\n\t}\n\n\tjq.Macro(\"mac1\", func(x, y interface{}) (bool, error) {\n\t\treturn true, nil\n\t})\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to throw error for already registered macro\")\n\t}\n}\n\nfunc TestJSONQ_From_Set(t *testing.T) {\n\tnode := \"root.items.[0].name\"\n\tjq := New().From(node)\n\tif jq.node != node {\n\t\tt.Error(\"failed to set node name\")\n\t}\n}\n\nfunc TestJSONQ_Select(t *testing.T) {\n\tjq := New().Select(\"id\", \"name\")\n\tif len(jq.attributes) != 2 {\n\t\tt.Error(\"failed to set properties\")\n\t}\n}\n\nfunc TestJSONQ_Offset(t *testing.T) {\n\tjq := New().Offset(3)\n\tif jq.offsetRecords != 3 {\n\t\tt.Error(\"failed to set offset records value\")\n\t}\n}\n\nfunc TestJSONQ_Limit(t *testing.T) {\n\tjq := New().Limit(12)\n\tif jq.limitRecords != 12 {\n\t\tt.Error(\"failed to set limit records value\")\n\t}\n}\n\nfunc TestJSONQ_reset(t *testing.T) {\n\tnode := \"root.items\"\n\tjq := New().From(node).Select(\"name\", \"age\").WhereEqual(\"price\", \"1900\").WhereEqual(\"id\", 1)\n\tjq.reset()\n\tif len(jq.queries) != 0 ||\n\t\tlen(jq.attributes) != 0 ||\n\t\tjq.queryIndex != 0 {\n\t\tt.Error(\"reset failed\")\n\t}\n}\n\nfunc TestJSONQ_Reset(t *testing.T) {\n\tnode := \"root.items\"\n\tjq := New().From(node).WhereEqual(\"price\", \"1900\").WhereEqual(\"id\", 1)\n\tjq.Reset()\n\tif len(jq.queries) != 0 || jq.queryIndex != 0 || jq.node != \"\" {\n\t\tt.Error(\"reset failed\")\n\t}\n}\n\nfunc TestJSONQ_From(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag         string\n\t\tquery       string\n\t\texpected    string\n\t\texpectError bool\n\t}{\n\t\t{\n\t\t\ttag:         \"accessing node\",\n\t\t\tquery:       \"vendor.name\",\n\t\t\texpected:    `\"Star Trek\"`,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"accessing not existed index\",\n\t\t\tquery:       \"vendor.items.[0]\",\n\t\t\texpected:    `{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}`,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"accessing not existed index\",\n\t\t\tquery:       \"vendor.items.[10]\",\n\t\t\texpected:    `null`,\n\t\t\texpectError: false,\n\t\t},\n\t\t{\n\t\t\ttag:         \"accessing invalid index error\",\n\t\t\tquery:       \"vendor.items.[x]\",\n\t\t\texpectError: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tjq := New().FromString(jsonStr)\n\t\tout := jq.From(tc.query).Get()\n\t\tif tc.expectError && jq.Error() == nil {\n\t\t\tt.Error(\"failed to catch error\")\n\t\t}\n\t\tif !tc.expectError {\n\t\t\tassertJSON(t, out, tc.expected, tc.tag)\n\t\t}\n\t}\n\n\tjq := New().FromString(jsonStr)\n\texpJSON := `[{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200}]`\n\tout := jq.From(\"vendor.items\").GroupBy(\"price\").From(\"1200\").Get()\n\tassertJSON(t, out, expJSON, \"accessing group by data\")\n}\n\nfunc TestJSONQ_FromInterface(t *testing.T) {\n\tvar v map[string]interface{}\n\terr := json.Unmarshal([]byte(jsonStr), &v)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\tjq := New().FromInterface(v)\n\tif jq.rootJSONContent == nil || jq.jsonContent == nil {\n\t\tt.Errorf(\"failed to assign value using FromInterface method\")\n\t}\n\n\tvar customType float64\n\tjq = New().FromInterface(customType)\n\tif jq.Error() == nil {\n\t\tt.Errorf(\"failed to set error properly for FromInterface method\")\n\t}\n}\n\nfunc TestJSONQ_Where_single_where(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \"=\", 1700)\n\texpected := `[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"single Where\")\n}\n\nfunc TestJSONQ_Where_deep_nested_value(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tWhere(\"name.first\", \"=\", \"John\")\n\texpected := `[{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Ramboo\"}},{\"id\":3,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"single Where with nested value\")\n}\n\nfunc TestJSONQ_Where_multiple_where_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \"=\", 1700).\n\t\tWhere(\"id\", \"=\", 2)\n\texpected := `[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"multiple Where expecting data\")\n}\n\nfunc TestJSONQ_Where_multiple_where_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \"=\", 1700).\n\t\tWhere(\"id\", \"=\", \"1700\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"multiple Where expecting empty result\")\n}\n\nfunc TestJSONQ_Where_multiple_where_with_invalid_operator_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \"invalid_op\", 1700)\n\tjq.Get()\n\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: invalid operator invalid_op\")\n\t}\n}\n\nfunc TestJSONQ_Where_multiple_where_with_invalid_operand_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \"contains\", 1700)\n\tjq.Get()\n\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: invalid operator invalid_op\")\n\t}\n}\n\nfunc TestJSONQ_single_WhereEqual(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereEqual(\"price\", 1700)\n\texpected := `[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"single WhereEqual\")\n}\n\nfunc TestJSONQ_multiple_WhereEqual_expecting_data(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereEqual(\"price\", 1700).\n\t\tWhereEqual(\"id\", 2)\n\texpected := `[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"multiple WhereEqual expecting data\")\n}\n\nfunc TestJSONQ_multiple_WhereEqual_expecting_empty_data(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereEqual(\"price\", 1700).\n\t\tWhereEqual(\"id\", \"1700\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"multiple WhereEqual expecting empty result\")\n}\n\nfunc TestJSONQ_single_WhereNotEqual(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereNotEqual(\"price\", 850)\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":6,\"name\":\"HP core i7\",\"price\":950}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"single WhereNotEqual\")\n}\n\nfunc TestJSONQ_multiple_WhereNotEqual(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereNotEqual(\"price\", 850).\n\t\tWhereNotEqual(\"id\", 2)\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":6,\"name\":\"HP core i7\",\"price\":950}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"multiple WhereNotEqual expecting result\")\n}\n\nfunc TestJSONQ_WhereNil(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereNil(\"id\")\n\texpected := `[{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected)\n}\n\nfunc TestJSONQ_WhereNotNil(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereNotNil(\"id\")\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":6,\"name\":\"HP core i7\",\"price\":950}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected)\n}\n\nfunc TestJSONQ_WhereIn_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereIn(\"id\", []int{1, 3, 5})\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereIn expecting result\")\n}\n\nfunc TestJSONQ_WhereIn_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereIn(\"id\", []int{18, 39, 85})\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereIn expecting empty result\")\n}\n\nfunc TestJSONQ_WhereNotIn_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereNotIn(\"id\", []int{1, 3, 5, 6})\n\texpected := `[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereIn expecting result\")\n}\n\nfunc TestJSONQ_WhereNotIn_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereNotIn(\"price\", []float64{850, 950, 1200, 1700, 1350})\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereIn expecting empty result\")\n}\n\nfunc TestJSONQ_OrWhere(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tOrWhere(\"price\", \">\", 1200)\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"OrWhere expecting result\")\n}\n\nfunc TestJSONQ_WhereStartsWith_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereStartsWith(\"name\", \"Mac\")\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereStartsWith expecting result\")\n}\n\nfunc TestJSONQ_WhereStartsWith_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereStartsWith(\"name\", \"xyz\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereStartsWith expecting empty result\")\n}\n\nfunc TestJSONQ_WhereEndsWith(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereEndsWith(\"name\", \"retina\")\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereStartsWith expecting result\")\n}\n\nfunc TestJSONQ_WhereEndsWith_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereEndsWith(\"name\", \"xyz\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereStartsWith expecting empty result\")\n}\n\nfunc TestJSONQ_WhereContains_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereContains(\"name\", \"RetinA\")\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereContains expecting result\")\n}\n\nfunc TestJSONQ_WhereContains_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereContains(\"name\", \"xyz\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereContains expecting empty result\")\n}\n\nfunc TestJSONQ_WhereStrictContains_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereStrictContains(\"name\", \"retina\")\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereContains expecting result\")\n}\n\nfunc TestJSONQ_WhereStrictContains_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhereStrictContains(\"name\", \"RetinA\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"WhereContains expecting empty result\")\n}\n\nfunc TestJSONQ_GroupBy(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tGroupBy(\"price\")\n\texpected := `{\"1200\":[{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200}],\"1350\":[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}],\"1700\":[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}],\"850\":[{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}],\"950\":[{\"id\":6,\"name\":\"HP core i7\",\"price\":950}]}`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"GroupBy expecting result\")\n}\n\nfunc TestJSONQ_GroupBy_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tGroupBy(\"invalid_key\")\n\texpected := `{}`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"GroupBy expecting empty result\")\n\tif len(jq.Errors()) == 0 {\n\t\tt.Error(\"failed to catch GroupBy error\")\n\t}\n}\n\nfunc TestJSONQ_GroupBy_nested_property(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tGroupBy(\"name.first\")\n\texpected := `{\"Ethan\":[{\"id\":2,\"name\":{\"first\":\"Ethan\",\"last\":\"Hunt\"}}],\"John\":[{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Ramboo\"}},{\"id\":3,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}]}`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"GroupBy nested expecting result\")\n}\n\nfunc TestJSONQ_GroupBy_nested_property_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tGroupBy(\"name.invalid_key\")\n\tout := jq.Get()\n\texpected := `{}`\n\tassertJSON(t, out, expected, \"Nsested GroupBy expecting empty result\")\n\tif len(jq.errors) == 0 {\n\t\tt.Error(\"failed to catch GroupBy nested property error\")\n\t}\n}\n\nfunc TestJSONQ_Sort_string_ascending_order(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.names\").\n\t\tSort()\n\texpected := `[\"Abby\",\"Jane Doe\",\"Jerry\",\"John Doe\",\"Nicolas\",\"Tom\"]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of string in ascending desc\")\n}\n\nfunc TestJSONQ_Sort_float64_descending_order(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\").\n\t\tSort(\"desc\")\n\texpected := `[2400,2100,1200,400.87,150.1,89.9]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of float in descending order\")\n}\n\nfunc TestJSONQ_Sort_with_two_args_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\").\n\t\tSort(\"asc\", \"desc\")\n\tjq.Get()\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting an error\")\n\t}\n}\n\nfunc TestJSONQ_SortBy_float_ascending_order(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSortBy(\"price\")\n\texpected := `[{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850},{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":6,\"name\":\"HP core i7\",\"price\":950},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of object by its key (price-float64) in ascending desc\")\n}\n\nfunc TestJSONQ_SortBy_float_descending_order(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSortBy(\"price\", \"desc\")\n\texpected := `[{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":6,\"name\":\"HP core i7\",\"price\":950},{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of object by its key (price-float64) in descending desc\")\n}\n\nfunc TestJSONQ_SortBy_string_ascending_order(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSortBy(\"name\")\n\texpected := `[{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":6,\"name\":\"HP core i7\",\"price\":950},{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of object by its key (name-string) in ascending desc\")\n}\n\nfunc TestJSONQ_SortBy_string_descending_order(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSortBy(\"name\", \"desc\")\n\texpected := `[{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":6,\"name\":\"HP core i7\",\"price\":950},{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850},{\"id\":4,\"name\":\"Fujitsu\",\"price\":850}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of object by its key (name-string) in descending desc\")\n}\n\nfunc TestJSONQ_SortBy_deep_nested_string_ascending_order(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tSortBy(\"name.first\")\n\texpected := `[{\"id\":2,\"name\":{\"first\":\"Ethan\",\"last\":\"Hunt\"}},{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Ramboo\"}},{\"id\":3,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of object by its key (name-string) in descending desc\")\n}\n\nfunc TestJSONQ_SortBy_deep_nested_string_invalid_key_should_return_error(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tSortBy(\"name.middle\")\n\texpected := `[{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Ramboo\"}},{\"id\":2,\"name\":{\"first\":\"Ethan\",\"last\":\"Hunt\"}},{\"id\":3,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}]` // no ordering, remain same\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"sorting array of object by its key (name-string) in descending desc\")\n\tif len(jq.errors) == 0 {\n\t\tt.Error(\"invalid path should return error/errors in SortBy\")\n\t}\n}\n\nfunc TestJSONQ_SortBy_no_argument_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSortBy()\n\tjq.Get()\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting an error\")\n\t}\n}\n\nfunc TestJSONQ_SortBy_more_than_two_argument_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSortBy(\"name\", \"desc\", \"asc\")\n\tjq.Get()\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting an error\")\n\t}\n}\n\nfunc TestJSONQ_SortBy_expecting_as_provided_node_is_not_list(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"name\").\n\t\tSortBy(\"name\", \"desc\")\n\tout := jq.Get()\n\texpJSON := `\"computers\"`\n\tassertJSON(t, out, expJSON)\n}\n\nfunc TestJSONQ_SortBy_expecting_empty_as_provided_node_is_not_list(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Where(\"price\", \">\", 2500).\n\t\tSortBy(\"name\", \"desc\")\n\tout := jq.Get()\n\texpJSON := `[]`\n\tassertJSON(t, out, expJSON)\n}\n\nfunc TestJSONQ_Distinct(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tDistinct(\"price\")\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200},{\"id\":4,\"name\":\"Fujitsu\",\"price\":850},{\"id\":6,\"name\":\"HP core i7\",\"price\":950}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"Distinct expecting result\")\n}\n\nfunc TestJSONQ_Distinct_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tDistinct(\"invalid_key\")\n\texpected := `[]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"Distinct expecting empty result\")\n\tif len(jq.Errors()) == 0 {\n\t\tt.Error(\"failed to catch Distinct error\")\n\t}\n}\n\nfunc TestJSONQ_Only(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\texpected := `[{\"id\":1,\"price\":1350},{\"id\":2,\"price\":1700},{\"id\":3,\"price\":1200},{\"id\":4,\"price\":850},{\"id\":5,\"price\":850},{\"id\":6,\"price\":950},{\"id\":null,\"price\":850}]`\n\tout := jq.Only(\"id\", \"price\")\n\tassertJSON(t, out, expected)\n}\n\nfunc TestJSONQ_Only_with_distinct(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\")\n\texpected := `[{\"id\":1,\"price\":1350},{\"id\":2,\"price\":1700},{\"id\":3,\"price\":1200},{\"id\":4,\"price\":850},{\"id\":6,\"price\":950}]`\n\tout := jq.Only(\"id\", \"price\")\n\tassertJSON(t, out, expected)\n}\n\nfunc TestJSONQ_OnlyR(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tresult, err := jq.OnlyR(\"name\", \"price\")\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_OnlyR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"invalid_path\")\n\tresult, err := jq.OnlyR(\"name\", \"price\")\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_First_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\texpected := `{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}`\n\tout := jq.First()\n\tassertJSON(t, out, expected, \"First expecting result\")\n}\n\nfunc TestJSONQ_First_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \">\", 1800)\n\texpected := `null`\n\tout := jq.First()\n\tassertJSON(t, out, expected, \"First expecting empty result\")\n}\n\nfunc TestJSONQ_First_distinct_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\texpected := `{\"id\":4,\"name\":\"Fujitsu\",\"price\":850}`\n\tout := jq.First()\n\tassertJSON(t, out, expected, \"First with distinct & where expecting result result\")\n}\n\nfunc TestJSONQ_FirstR(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\tresult, err := jq.FirstR()\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_FirstR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"invalid\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\tresult, err := jq.FirstR()\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_Last_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\texpected := `{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}`\n\tout := jq.Last()\n\tassertJSON(t, out, expected, \"Last expecting result\")\n}\n\nfunc TestJSONQ_Last_expecting_empty_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \">\", 1800)\n\texpected := `null`\n\tout := jq.Last()\n\tassertJSON(t, out, expected, \"Last expecting empty result\")\n}\n\nfunc TestJSONQ_Last_distinct_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\texpected := `{\"id\":4,\"name\":\"Fujitsu\",\"price\":850}`\n\tout := jq.Last()\n\tassertJSON(t, out, expected, \"Last with distinct & where expecting result result\")\n}\n\nfunc TestJSONQ_LastR(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\tresult, err := jq.LastR()\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_LastR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"invalid_path\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\tresult, err := jq.LastR()\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_Nth_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\texpected := `{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}`\n\tout := jq.Nth(1)\n\tassertJSON(t, out, expected, \"Nth expecting result\")\n}\n\nfunc TestJSONQ_Nth_expecting_empty_result_with_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \">\", 1800)\n\texpected := `null`\n\tout := jq.Nth(1)\n\tassertJSON(t, out, expected, \"Nth expecting empty result with an error\")\n\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting an error for empty result nth value\")\n\t}\n}\n\nfunc TestJSONQ_Nth_expecting_empty_result_with_error_index_out_of_range(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\texpected := `null`\n\tout := jq.Nth(100)\n\tassertJSON(t, out, expected, \"Nth expecting empty result with an error of index out of range\")\n\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting an error for empty result nth value\")\n\t}\n}\n\nfunc TestJSONQ_Nth_expecting_result_from_last_using_negative_index(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\texpected := `{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}`\n\tout := jq.Nth(-1)\n\tassertJSON(t, out, expected, \"Nth expecting result form last when providing -1\")\n}\n\nfunc TestJSONQ_Nth_expecting_error_providing_zero_as_index(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"price\", \">\", 1800)\n\tjq.Nth(0)\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting error\")\n\t}\n}\n\nfunc TestJSONQ_Nth_expecting_empty_result_as_node_is_map(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tout := jq.Nth(0)\n\texpected := `null`\n\tassertJSON(t, out, expected, \"Nth expecting empty result if the node is a map\")\n}\n\nfunc TestJSONQ_Nth_expecting_empty_result_as_node_is_object(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tout := jq.Nth(1)\n\texpected := `null`\n\tassertJSON(t, out, expected, \"Nth expecting empty result if the node is a object\")\n}\n\nfunc TestJSONQ_Nth_distinct_expecting_result(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\")\n\texpected := `{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}`\n\tout := jq.Nth(1)\n\tassertJSON(t, out, expected, \"Last with distinct & where expecting result result\")\n}\n\nfunc TestJSONQ_NthR(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\tresult, err := jq.NthR(1)\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_NthR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"invalid_path\").Distinct(\"price\").Where(\"price\", \"=\", 850)\n\tresult, err := jq.NthR(1)\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_Find_simple_property(t *testing.T) {\n\tjq := New().FromString(jsonStr)\n\tout := jq.Find(\"name\")\n\texpected := `\"computers\"`\n\tassertJSON(t, out, expected, \"Find expecting name computers\")\n}\n\nfunc TestJSONQ_Find_nested_property(t *testing.T) {\n\tjq := New().FromString(jsonStr)\n\tout := jq.Find(\"vendor.items.[0]\")\n\texpected := `{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}`\n\tassertJSON(t, out, expected, \"Find expecting a nested object\")\n}\n\nfunc TestJSONQ_FindR(t *testing.T) {\n\tjq := New().FromString(jsonStr)\n\tresult, err := jq.FindR(\"vendor.items.[0]\")\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_FindR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr)\n\tresult, err := jq.FindR(\"invalid_path\")\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_Pluck_expecting_list_of_float64(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Pluck(\"price\")\n\texpected := `[1350,1700,1200,850,850,950,850]`\n\tassertJSON(t, out, expected, \"Pluck expecting prices from list of objects\")\n}\n\nfunc TestJSONQ_Pluck_expecting_empty_list_of_float64(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Pluck(\"invalid_prop\")\n\texpected := `[]`\n\tassertJSON(t, out, expected, \"Pluck expecting empty list from list of objects, because of invalid property name\")\n}\n\nfunc TestJSONQ_Pluck_expecting_with_distinct(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Limit(3)\n\tout := jq.Pluck(\"price\")\n\texpected := `[1350,1700,1200]`\n\tassertJSON(t, out, expected, \"Expecting distinct price with limit 3\")\n}\n\nfunc TestJSONQ_PluckR(t *testing.T) {\n\tjq := New().FromString(jsonStr).From(\"vendor.items\")\n\tresult, err := jq.PluckR(\"price\")\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_PluckR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).From(\"invalid_path\")\n\tresult, err := jq.PluckR(\"price\")\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_Count_expecting_int_from_list(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Count()\n\texpected := `7`\n\tassertJSON(t, out, expected, \"Count expecting a int number of total item of an array\")\n}\n\nfunc TestJSONQ_Count_expecting_int_from_list_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tout := jq.Count()\n\texpected := `3`\n\tassertJSON(t, out, expected, \"Count expecting a int number of total item of an array of objects\")\n}\n\nfunc TestJSONQ_Count_expecting_int_from_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tGroupBy(\"price\")\n\tout := jq.Count()\n\texpected := `5`\n\tassertJSON(t, out, expected, \"Count expecting a int number of total item of an array of grouped objects\")\n}\n\nfunc TestJSONQ_Count_with_Distinct_expecting_int_from_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\")\n\tout := jq.Count()\n\texpected := `5`\n\tassertJSON(t, out, expected, \"Count expecting a int number of total item of an array of distinct priced objects\")\n}\n\nfunc TestJSONQ_Out_expecting_result(t *testing.T) {\n\ttype item struct {\n\t\tID    int    `json:\"id\"`\n\t\tName  string `json:\"name\"`\n\t\tPrice int    `json:\"price\"`\n\t}\n\texptItm := item{\n\t\tID:    1,\n\t\tName:  \"MacBook Pro 13 inch retina\",\n\t\tPrice: 1350,\n\t}\n\titm := item{}\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tjq.Out(&itm)\n\tassertInterface(t, exptItm, itm, \"failed to get Out result\")\n}\n\nfunc TestJSONQ_Out_expecting_decoding_error(t *testing.T) {\n\ttype item struct {\n\t\tID    bool   `json:\"id\"`\n\t\tName  string `json:\"name\"`\n\t\tPrice int    `json:\"price\"`\n\t}\n\titm := item{}\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tjq.Out(&itm)\n\tif jq.Error() == nil {\n\t\tt.Errorf(\"failed to get Out decoding error: %v\", jq.Error())\n\t}\n}\n\nfunc TestJSONQ_Out_expecting_encoding_error(t *testing.T) {\n\ttype item struct {\n\t\tID    bool   `json:\"id\"`\n\t\tName  string `json:\"name\"`\n\t\tPrice int    `json:\"price\"`\n\t}\n\titm := item{}\n\tjq := New()\n\tjq.jsonContent = math.Inf(1)\n\tjq.Out(&itm)\n\tif jq.Error() == nil {\n\t\tt.Errorf(\"failed to get Out encoding error: %v\", jq.Error())\n\t}\n}\n\nfunc TestJSONQ_Writer_expecting_result(t *testing.T) {\n\tvar b bytes.Buffer\n\tNew().FromString(jsonStr).From(\"vendor.prices\").Writer(&b)\n\texpected := \"[2400,2100,1200,400.87,89.9,150.1]\\n\"\n\tassertInterface(t, expected, b.String(), \"failed to get Writer result\")\n}\n\nfunc TestJSONQ_Writer_encoding_error(t *testing.T) {\n\tvar b bytes.Buffer\n\tjq := New().FromString(jsonStr)\n\tjq.jsonContent = math.Inf(1)\n\tjq.Writer(&b)\n\tif jq.Error() == nil {\n\t\tt.Errorf(\"failed to get Writer encoding error: %v\", jq.Error())\n\t}\n}\n\nfunc TestJSONQ_Sum_of_array_numeric_values(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\")\n\tout := jq.Sum()\n\texpected := `6340.87`\n\tassertJSON(t, out, expected, \"Sum expecting sum an array\")\n}\n\nfunc TestJSONQ_Sum_of_array_objects_property_numeric_values(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Sum(\"price\")\n\texpected := `7750`\n\tassertJSON(t, out, expected, \"Sum expecting sum an array of objects property\")\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_providing_property_of_array(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\")\n\tjq.Sum(\"key\")\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: unnecessary property name for array\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_not_providing_property_of_array_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tjq.Sum()\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: property name can not be empty for object\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_not_providing_property_of_object(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tjq.Sum()\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: property name can not be empty for object\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_providing_invalid_property_of_array_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tjq.Sum(\"invalid_property\")\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: property 'invalid_property' does not exist\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_providing_invalid_property_of_object(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor\")\n\tjq.Sum(\"invalid_property\")\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: property 'invalid_property' does not exist\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_providing_non_numeric_property_of_array_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tjq.Sum(\"name\")\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: property 'MacBook Pro 13 inch retina' is not numeric\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_error_for_providing_non_numeric_property_of_object(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor\")\n\tjq.Sum(\"name\")\n\tif jq.Error() == nil {\n\t\tt.Error(\"expecting: property 'invalid_property' does not exist\")\n\t}\n}\n\nfunc TestJSONQ_Sum_expecting_result_from_nested_object(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items.[0]\")\n\tout := jq.Sum(\"price\")\n\texpected := `1350`\n\tassertJSON(t, out, expected, \"Sum expecting result from nested object\")\n}\n\nfunc TestJSONQ_Sum_of_distinct_array_numeric_values(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Distinct(\"price\").Limit(3)\n\tout := jq.Sum(\"price\")\n\texpected := `4250`\n\tassertJSON(t, out, expected, \"Sum expecting sum a distinct & limited array\")\n}\n\nfunc TestJSONQ_Avg_array(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\")\n\tout := jq.Avg()\n\texpected := `1056.8116666666667`\n\tassertJSON(t, out, expected, \"Avg expecting average an array\")\n}\n\nfunc TestJSONQ_Avg_array_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Avg(\"price\")\n\texpected := `1107.142857142857`\n\tassertJSON(t, out, expected, \"Avg expecting average an array of objects property\")\n}\n\nfunc TestJSONQ_Min_array(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\")\n\tout := jq.Min()\n\texpected := `89.9`\n\tassertJSON(t, out, expected, \"Min expecting min an array\")\n}\n\nfunc TestJSONQ_Min_array_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Min(\"price\")\n\texpected := `850`\n\tassertJSON(t, out, expected, \"Min expecting min an array of objects property\")\n}\n\nfunc TestJSONQ_Max_array(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.prices\")\n\tout := jq.Max()\n\texpected := `2400`\n\tassertJSON(t, out, expected, \"Max expecting max an array\")\n}\n\nfunc TestJSONQ_Max_array_of_objects(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\")\n\tout := jq.Max(\"price\")\n\texpected := `1700`\n\tassertJSON(t, out, expected, \"Max expecting max an array of objects property\")\n}\n\n// TODO: Need to write some more combined query test\nfunc TestJSONQ_CombinedWhereOrWhere(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"id\", \"=\", 1).\n\t\tOrWhere(\"name\", \"=\", \"Sony VAIO\").\n\t\tWhere(\"price\", \"=\", 1200)\n\tout := jq.Get()\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":3,\"name\":\"Sony VAIO\",\"price\":1200}]`\n\tassertJSON(t, out, expected, \"combined Where with orWhere\")\n}\n\nfunc TestJSONQ_CombinedWhereOrWhere_invalid_key(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tWhere(\"id\", \"=\", 1).\n\t\tOrWhere(\"invalid_key\", \"=\", \"Sony VAIO\")\n\tout := jq.Get()\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350}]`\n\tassertJSON(t, out, expected, \"combined Where with orWhere containing invalid key\")\n}\n\nfunc TestJSONQ_Get_with_Select_method(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tSelect(\"id\", \"name\").\n\t\tWhere(\"price\", \"=\", 1350)\n\tout := jq.Get()\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\"}]`\n\tassertJSON(t, out, expected, \"Select method Using Get\")\n}\n\nfunc TestJSONQ_Get_with_nested_Select_method(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tSelect(\"id as uid\", \"name.first as fname\", \"name.last\")\n\tout := jq.Get()\n\texpected := `[{\"fname\":\"John\",\"last\":\"Ramboo\",\"uid\":1},{\"fname\":\"Ethan\",\"last\":\"Hunt\",\"uid\":2},{\"fname\":\"John\",\"last\":\"Doe\",\"uid\":3}]`\n\tassertJSON(t, out, expected, \"nested Select method using alias\")\n}\n\nfunc TestJSONQ_Get_with_nested_invalid_property_in_Select_method_expecting_error(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tSelect(\"id as uid\", \"name.middle\")\n\tout := jq.Get()\n\tif jq.Error() == nil {\n\t\tt.Error(\"nested property in Select method failed to catch error\")\n\t}\n\texpected := `[{\"uid\":1},{\"uid\":2},{\"uid\":3}]`\n\tassertJSON(t, out, expected, \"nested Select method using alias\")\n}\n\nfunc TestJSONQ_GetR(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").Select(\"name\")\n\tresult, err := jq.GetR()\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" && err != nil {\n\t\tt.Error(\"failed to match Result type\")\n\t}\n}\n\nfunc TestJSONQ_GetR_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"invalid_path\")\n\tresult, err := jq.GetR()\n\tif result != nil && err == nil {\n\t\tt.Error(\"failed to catch error\")\n\t}\n}\n\nfunc TestJSONQ_Offset_method(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tOffset(4)\n\tout := jq.Get()\n\texpected := `[{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":6,\"name\":\"HP core i7\",\"price\":950},{\"id\":null,\"name\":\"HP core i3 SSD\",\"price\":850}]`\n\tassertJSON(t, out, expected, \"failed to offset records\")\n}\n\nfunc TestJSONQ_Offset_Where_method(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tOffset(4).WhereNotNil(\"id\")\n\tout := jq.Get()\n\texpected := `[{\"id\":5,\"key\":2300,\"name\":\"HP core i5\",\"price\":850},{\"id\":6,\"name\":\"HP core i7\",\"price\":950}]`\n\tassertJSON(t, out, expected, \"failed to limit records\")\n}\n\nfunc TestJSONQ_Offset_greater_than_the_original_value_with_Where_method(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tOffset(40).WhereNotNil(\"id\")\n\tout := jq.Get()\n\texpected := `[]`\n\tassertJSON(t, out, expected, \"failed to offset records when offset value is greater than the length of orignal result\")\n}\n\nfunc TestJSONQ_Limit_method(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tLimit(2)\n\tout := jq.Get()\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tassertJSON(t, out, expected, \"failed to limit records\")\n}\n\nfunc TestJSONQ_Limit_Where_method(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tLimit(2).WhereNotNil(\"id\")\n\tout := jq.Get()\n\texpected := `[{\"id\":1,\"name\":\"MacBook Pro 13 inch retina\",\"price\":1350},{\"id\":2,\"name\":\"MacBook Pro 15 inch retina\",\"price\":1700}]`\n\tassertJSON(t, out, expected, \"failed to limit records\")\n}\n\nfunc TestJSONQ_Offset_invalid_number_should_return_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tOffset(-2)\n\tjq.Get()\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to catch invalid offset error\")\n\t}\n}\nfunc TestJSONQ_Limit_invalid_number_should_return_error(t *testing.T) {\n\tjq := New().FromString(jsonStr).\n\t\tFrom(\"vendor.items\").\n\t\tLimit(-2)\n\tjq.Get()\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to catch invalid limit error\")\n\t}\n}\n\nfunc TestJSONQ_WhereLenEqual(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tWhereLenEqual(\"name.first\", 4)\n\texpected := `[{\"id\":1,\"name\":{\"first\":\"John\",\"last\":\"Ramboo\"}},{\"id\":3,\"name\":{\"first\":\"John\",\"last\":\"Doe\"}}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"single WhereLenEqual\")\n}\n\nfunc TestJSONQ_WhereLenNotEqual(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).\n\t\tFrom(\"users\").\n\t\tWhereLenNotEqual(\"name.first\", 4)\n\texpected := `[{\"id\":2,\"name\":{\"first\":\"Ethan\",\"last\":\"Hunt\"}}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"single WhereLenEqual\")\n}\n\nfunc TestJSONQ_More(t *testing.T) {\n\tjq := New().FromString(jsonStrUsers).From(\"users\")\n\tjq.Where(\"id\", \"<\", 3)\n\tjq.More() // start query again\n\tjq.Where(\"id\", \">\", 1)\n\texpected := `[{\"id\":2,\"name\":{\"first\":\"Ethan\",\"last\":\"Hunt\"}}]`\n\tout := jq.Get()\n\tassertJSON(t, out, expected, \"More\")\n}\n\n// ======================== Benchmark ======================== //\n\nfunc Benchmark_Copy(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.Copy()\n\t}\n}\n\nfunc Benchmark_Find(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.Find(\"name\")\n\t}\n}\n\nfunc Benchmark_Get(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.Get()\n\t}\n}\n\nfunc Benchmark_From_Get(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").Get()\n\t}\n}\n\nfunc Benchmark_From_Where_Get(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").Where(\"id\", \"=\", 1).Get()\n\t}\n}\n\nfunc Benchmark_From_Where_Select_Get(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").Where(\"id\", \"=\", 1).Select(\"id\", \"name\").Get()\n\t}\n}\n\nfunc Benchmark_From_Sum(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").Sum(\"price\")\n\t}\n}\n\nfunc Benchmark_From_Avg(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").Avg(\"price\")\n\t}\n}\n\nfunc Benchmark_From_Count(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").Count()\n\t}\n}\n\nfunc Benchmark_From_First(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").First()\n\t}\n}\n\nfunc Benchmark_From_GroupBy(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").GroupBy(\"price\")\n\t}\n}\n\nfunc Benchmark_From_SortBy(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").SortBy(\"price\")\n\t}\n}\n\nfunc Benchmark_From_Where_nested_element_Get(b *testing.B) {\n\tjq := New().FromString(jsonStrUsers)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"users\").WhereEqual(\"name.first\", \"John\").Get()\n\t}\n}\n\nfunc Benchmark_From_WhereLenEqual_Get(b *testing.B) {\n\tjq := New().FromString(jsonStr)\n\tfor n := 0; n < b.N; n++ {\n\t\tjq.From(\"vendor.items\").WhereLenEqual(\"name\", 10).Get()\n\t}\n}\n"
        },
        {
          "name": "jsonq_testdata_test.go",
          "type": "blob",
          "size": 3.3359375,
          "content": "package gojsonq\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"testing\"\n)\n\n// ==================== Test Data===================\n// ==================== DO NOT EDIT===================\nvar (\n\tjsonStr = `\n{\n   \"name\":\"computers\",\n   \"description\":\"List of computer products\",\n   \"vendor\":{\n      \"name\":\"Star Trek\",\n      \"email\":\"info@example.com\",\n      \"website\":\"www.example.com\",\n      \"items\":[\n         {\n            \"id\":1,\n            \"name\":\"MacBook Pro 13 inch retina\",\n            \"price\":1350\n         },\n         {\n            \"id\":2,\n            \"name\":\"MacBook Pro 15 inch retina\",\n            \"price\":1700\n         },\n         {\n            \"id\":3,\n            \"name\":\"Sony VAIO\",\n            \"price\":1200\n         },\n         {\n            \"id\":4,\n            \"name\":\"Fujitsu\",\n            \"price\":850\n         },\n         {\n            \"id\":5,\n            \"name\":\"HP core i5\",\n            \"price\":850,\n            \"key\": 2300\n         },\n         {\n            \"id\":6,\n            \"name\":\"HP core i7\",\n            \"price\":950\n         },\n         {\n            \"id\":null,\n            \"name\":\"HP core i3 SSD\",\n            \"price\":850\n         }\n      ],\n      \"prices\":[\n         2400,\n         2100,\n         1200,\n         400.87,\n         89.90,\n         150.10\n     ],\n     \"names\":[\n        \"John Doe\",\n        \"Jane Doe\",\n        \"Tom\",\n        \"Jerry\",\n        \"Nicolas\",\n        \"Abby\"\n     ]\n   }\n}\n`\n\tjsonStrUsers = `{\n  \"users\":[\n    {\n      \"id\":1,\n      \"name\":{\n        \"first\":\"John\",\n        \"last\":\"Ramboo\"\n      }\n    },\n    {\n      \"id\":2,\n      \"name\":{\n        \"first\":\"Ethan\",\n        \"last\":\"Hunt\"\n      }\n    },\n    {\n      \"id\":3,\n      \"name\":{\n        \"first\":\"John\",\n        \"last\":\"Doe\"\n      }\n    }\n  ]\n}`\n)\n\n// ================= Test Helpers===========================\n\nfunc createTestFile(t *testing.T, filename string) (string, func()) {\n\tfile, err := ioutil.TempFile(\"\", filename)\n\tif err != nil {\n\t\tt.Errorf(\"failed to create %s test file %v\", filename, err)\n\t}\n\n\t// create data.json file from the jsonStr above\n\tif _, err := file.Write([]byte(jsonStr)); err != nil {\n\t\tt.Errorf(\"failed to create %s test file %v\", filename, err)\n\t}\n\n\treturn file.Name(), func() {\n\t\tif err := os.Remove(file.Name()); err != nil {\n\t\t\tt.Errorf(\"failed to remove %s test file %v\", filename, err)\n\t\t}\n\t}\n}\n\nfunc assertJSON(t *testing.T, v interface{}, expJSON string, tag ...string) {\n\tbb, err := json.Marshal(v)\n\tif err != nil {\n\t\tt.Errorf(\"failed to marshal: %v\", err)\n\t}\n\teb := []byte(expJSON)\n\tif !bytes.Equal(bb, eb) {\n\t\tif len(tag) > 0 {\n\t\t\tt.Errorf(\"Tag: %s\\nExpected: %v\\nGot: %v\", tag[0], expJSON, string(bb))\n\t\t} else {\n\t\t\tt.Errorf(\"Expected: %v\\nGot: %v\", expJSON, string(bb))\n\t\t}\n\t}\n}\n\nfunc assertInterface(t *testing.T, x, y interface{}, tag ...string) {\n\tbbX, err := json.Marshal(x)\n\tif err != nil {\n\t\tt.Errorf(\"failed to marshal x: %v\", err)\n\t}\n\n\tbbY, err := json.Marshal(y)\n\tif err != nil {\n\t\tt.Errorf(\"failed to marshal x: %v\", err)\n\t}\n\n\tif !bytes.Equal(bbX, bbY) {\n\t\tif len(tag) > 0 {\n\t\t\tt.Errorf(\"Tag: %s\\nExpected: %v\\nGot: %v\", tag[0], x, y)\n\t\t} else {\n\t\t\tt.Errorf(\"Expected: %v\\nGot: %v\", x, y)\n\t\t}\n\t}\n}\n\n// cDecoder will be used as a custom decoder for testing// though it use std lib\ntype cDecoder struct {\n}\n\nfunc (c *cDecoder) Decode(data []byte, v interface{}) error {\n\treturn json.Unmarshal(data, &v) // let's assume this is a custom unmarshaler\n}\n"
        },
        {
          "name": "option.go",
          "type": "blob",
          "size": 1.1357421875,
          "content": "package gojsonq\n\nimport \"errors\"\n\n// option describes type for providing configuration options to JSONQ\ntype option struct {\n\tdecoder   Decoder\n\tseparator string\n}\n\n// OptionFunc represents a contract for option func, it basically set options to jsonq instance options\ntype OptionFunc func(*JSONQ) error\n\n// SetDecoder take a custom decoder to decode JSON\n// Deprecated - use WithDecoder\nfunc SetDecoder(u Decoder) OptionFunc {\n\treturn WithDecoder(u)\n}\n\n// SetSeparator set custom separator for traversing child node, default separator is DOT (.)\n// Deprecated - use WithSeparator\nfunc SetSeparator(s string) OptionFunc {\n\treturn WithSeparator(s)\n}\n\n// WithDecoder take a custom decoder to decode JSON\nfunc WithDecoder(u Decoder) OptionFunc {\n\treturn func(j *JSONQ) error {\n\t\tif u == nil {\n\t\t\treturn errors.New(\"decoder can not be nil\")\n\t\t}\n\t\tj.option.decoder = u\n\t\treturn nil\n\t}\n}\n\n// WithSeparator set custom separator for traversing child node, default separator is DOT (.)\nfunc WithSeparator(s string) OptionFunc {\n\treturn func(j *JSONQ) error {\n\t\tif s == \"\" {\n\t\t\treturn errors.New(\"separator can not be empty\")\n\t\t}\n\t\tj.option.separator = s\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "option_test.go",
          "type": "blob",
          "size": 1.384765625,
          "content": "package gojsonq\n\nimport (\n\t\"testing\"\n)\n\nfunc TestWithDecoder(t *testing.T) {\n\tjq := New(WithDecoder(&cDecoder{}))\n\tif jq.option.decoder == nil {\n\t\tt.Error(\"failed to set decoder as option\")\n\t}\n}\n\nfunc TestWithDecoder_with_nil_expecting_an_error(t *testing.T) {\n\tjq := New(WithDecoder(nil))\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to catch nil in WithDecoder\")\n\t}\n}\n\nfunc TestWithSeparator(t *testing.T) {\n\tjq := New(WithSeparator(\"->\"))\n\tif jq.option.separator != \"->\" {\n\t\tt.Error(\"failed to set separator as option\")\n\t}\n}\n\nfunc TestWithSeparator_with_nil_expecting_an_error(t *testing.T) {\n\tjq := New(WithSeparator(\"\"))\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to catch nil in WithSeparator\")\n\t}\n}\n\n// to increase the code coverage; will remove in major release\nfunc TestSetDecoder(t *testing.T) {\n\tjq := New(SetDecoder(&cDecoder{}))\n\tif jq.option.decoder == nil {\n\t\tt.Error(\"failed to set decoder as option\")\n\t}\n}\n\nfunc TestSetDecoder_with_nil_expecting_an_error(t *testing.T) {\n\tjq := New(SetDecoder(nil))\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to catch nil in SetDecoder\")\n\t}\n}\n\nfunc TestSetSeparator(t *testing.T) {\n\tjq := New(SetSeparator(\"->\"))\n\tif jq.option.separator != \"->\" {\n\t\tt.Error(\"failed to set separator as option\")\n\t}\n}\n\nfunc TestSetSeparator_with_nil_expecting_an_error(t *testing.T) {\n\tjq := New(SetSeparator(\"\"))\n\tif jq.Error() == nil {\n\t\tt.Error(\"failed to catch nil in SetSeparator\")\n\t}\n}\n"
        },
        {
          "name": "query.go",
          "type": "blob",
          "size": 7.181640625,
          "content": "package gojsonq\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\nconst (\n\toperatorEq             = \"=\"\n\toperatorEqEng          = \"eq\"\n\toperatorNotEq          = \"!=\"\n\toperatorNotEqEng       = \"neq\"\n\toperatorNotEqAnother   = \"<>\"\n\toperatorGt             = \">\"\n\toperatorGtEng          = \"gt\"\n\toperatorLt             = \"<\"\n\toperatorLtEng          = \"lt\"\n\toperatorGtE            = \">=\"\n\toperatorGtEEng         = \"gte\"\n\toperatorLtE            = \"<=\"\n\toperatorLtEEng         = \"lte\"\n\toperatorStrictContains = \"strictContains\"\n\toperatorContains       = \"contains\"\n\toperatorEndsWith       = \"endsWith\"\n\toperatorStartsWith     = \"startsWith\"\n\toperatorIn             = \"in\"\n\toperatorNotIn          = \"notIn\"\n\toperatorLenEq          = \"leneq\"\n\toperatorLenNotEq       = \"lenneq\"\n\toperatorLenGt          = \"lengt\"\n\toperatorLenGte         = \"lengte\"\n\toperatorLenLt          = \"lenlt\"\n\toperatorLenLte         = \"lenlte\"\n)\n\nfunc defaultQueries() map[string]QueryFunc {\n\treturn map[string]QueryFunc{\n\t\toperatorEq:             eq,\n\t\toperatorEqEng:          eq,\n\t\toperatorNotEq:          neq,\n\t\toperatorNotEqEng:       neq,\n\t\toperatorNotEqAnother:   neq,\n\t\toperatorGt:             gt,\n\t\toperatorGtEng:          gt,\n\t\toperatorLt:             lt,\n\t\toperatorLtEng:          lt,\n\t\toperatorGtE:            gte,\n\t\toperatorGtEEng:         gte,\n\t\toperatorLtE:            lte,\n\t\toperatorLtEEng:         lte,\n\t\toperatorStrictContains: strStrictContains,\n\t\toperatorContains:       strContains,\n\t\toperatorStartsWith:     strStartsWith,\n\t\toperatorEndsWith:       strEndsWith,\n\t\toperatorIn:             in,\n\t\toperatorNotIn:          notIn,\n\t\toperatorLenEq:          lenEq,\n\t\toperatorLenNotEq:       lenNotEq,\n\t\toperatorLenGt:          lenGt,\n\t\toperatorLenGte:         lenGte,\n\t\toperatorLenLt:          lenLt,\n\t\toperatorLenLte:         lenLte,\n\t}\n}\n\n// QueryFunc describes a conditional function which perform comparison\ntype QueryFunc func(x, y interface{}) (bool, error)\n\n// eq checks whether x, y are deeply eq\nfunc eq(x, y interface{}) (bool, error) {\n\t// if the y value is numeric (int/int8-int64/float32/float64) then convert to float64\n\tif fv, ok := toFloat64(y); ok {\n\t\ty = fv\n\t}\n\treturn reflect.DeepEqual(x, y), nil\n}\n\n// neq checks whether x, y are deeply not equal\nfunc neq(x, y interface{}) (bool, error) {\n\tb, err := eq(x, y)\n\treturn !b, err\n}\n\n// gt checks whether x is greather than y\nfunc gt(x, y interface{}) (bool, error) {\n\txv, ok := x.(float64)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be numeric\", x)\n\t}\n\t// if the y value is numeric (int/int8-int64/float32/float64) then convert to float64\n\tif fv, ok := toFloat64(y); ok {\n\t\treturn xv > fv, nil\n\t}\n\treturn false, nil\n}\n\n// lt checks whether x is less than y\nfunc lt(x, y interface{}) (bool, error) {\n\txv, ok := x.(float64)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be numeric\", x)\n\t}\n\t// if the y value is numeric (int/int8-int64/float32/float64) then convert to float64\n\tif fv, ok := toFloat64(y); ok {\n\t\treturn xv < fv, nil\n\t}\n\treturn false, nil\n}\n\n// gte checks whether x is greater than or equal to y\nfunc gte(x, y interface{}) (bool, error) {\n\txv, ok := x.(float64)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be numeric\", x)\n\t}\n\t// if the y value is numeric (int/int8-int64/float32/float64) then convert to float64\n\tif fv, ok := toFloat64(y); ok {\n\t\treturn xv >= fv, nil\n\t}\n\treturn false, nil\n}\n\n// lte checks whether x is less than or equal to y\nfunc lte(x, y interface{}) (bool, error) {\n\txv, ok := x.(float64)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be numeric\", x)\n\t}\n\t// if the y value is numeric (int/int8-int64/float32/float64) then convert to float64\n\tif fv, ok := toFloat64(y); ok {\n\t\treturn xv <= fv, nil\n\t}\n\treturn false, nil\n}\n\n// strStrictContains checks if x contains y\n// This is case sensitive search\nfunc strStrictContains(x, y interface{}) (bool, error) {\n\txv, okX := x.(string)\n\tif !okX {\n\t\treturn false, fmt.Errorf(\"%v must be string\", x)\n\t}\n\tyv, okY := y.(string)\n\tif !okY {\n\t\treturn false, fmt.Errorf(\"%v must be string\", y)\n\t}\n\treturn strings.Contains(xv, yv), nil\n}\n\n// strContains checks if x contains y\n// This is case insensitive search\nfunc strContains(x, y interface{}) (bool, error) {\n\txv, okX := x.(string)\n\tif !okX {\n\t\treturn false, fmt.Errorf(\"%v must be string\", x)\n\t}\n\tyv, okY := y.(string)\n\tif !okY {\n\t\treturn false, fmt.Errorf(\"%v must be string\", y)\n\t}\n\treturn strings.Contains(strings.ToLower(xv), strings.ToLower(yv)), nil\n}\n\n// strStartsWith checks if x starts with y\nfunc strStartsWith(x, y interface{}) (bool, error) {\n\txv, okX := x.(string)\n\tif !okX {\n\t\treturn false, fmt.Errorf(\"%v must be string\", x)\n\t}\n\tyv, okY := y.(string)\n\tif !okY {\n\t\treturn false, fmt.Errorf(\"%v must be string\", y)\n\t}\n\treturn strings.HasPrefix(xv, yv), nil\n}\n\n// strEndsWith checks if x ends with y\nfunc strEndsWith(x, y interface{}) (bool, error) {\n\txv, okX := x.(string)\n\tif !okX {\n\t\treturn false, fmt.Errorf(\"%v must be string\", x)\n\t}\n\tyv, okY := y.(string)\n\tif !okY {\n\t\treturn false, fmt.Errorf(\"%v must be string\", y)\n\t}\n\treturn strings.HasSuffix(xv, yv), nil\n}\n\n// in checks if x exists in y e.g: in(\"id\", []int{1,3,5,8})\nfunc in(x, y interface{}) (bool, error) {\n\tif yv, ok := y.([]string); ok {\n\t\tfor _, v := range yv {\n\t\t\tif ok, _ := eq(x, v); ok {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\tif yv, ok := y.([]int); ok {\n\t\tfor _, v := range yv {\n\t\t\tif ok, _ := eq(x, v); ok {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\tif yv, ok := y.([]float64); ok {\n\t\tfor _, v := range yv {\n\t\t\tif ok, _ := eq(x, v); ok {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// notIn checks if x doesn't exists in y e.g: in(\"id\", []int{1,3,5,8})\nfunc notIn(x, y interface{}) (bool, error) {\n\tb, err := in(x, y)\n\treturn !b, err\n}\n\n// lenEq checks if the string/array/list value is equal\nfunc lenEq(x, y interface{}) (bool, error) {\n\tyv, ok := y.(int)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be integer\", y)\n\t}\n\txv, err := length(x)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn xv == yv, nil\n}\n\n// lenNotEq checks if the string/array/list value is not equal\nfunc lenNotEq(x, y interface{}) (bool, error) {\n\tyv, ok := y.(int)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be integer\", y)\n\t}\n\txv, err := length(x)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn xv != yv, nil\n}\n\n// lenGt checks if the string/array/list value is greater\nfunc lenGt(x, y interface{}) (bool, error) {\n\tyv, ok := y.(int)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be integer\", y)\n\t}\n\txv, err := length(x)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn xv > yv, nil\n}\n\n// lenLt checks if the string/array/list value is less\nfunc lenLt(x, y interface{}) (bool, error) {\n\tyv, ok := y.(int)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be integer\", y)\n\t}\n\txv, err := length(x)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn xv < yv, nil\n}\n\n// lenGte checks if the string/array/list value is greater than equal\nfunc lenGte(x, y interface{}) (bool, error) {\n\tyv, ok := y.(int)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be integer\", y)\n\t}\n\txv, err := length(x)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn xv >= yv, nil\n}\n\n// lenLte checks if the string/array/list value is less than equal\nfunc lenLte(x, y interface{}) (bool, error) {\n\tyv, ok := y.(int)\n\tif !ok {\n\t\treturn false, fmt.Errorf(\"%v must be integer\", y)\n\t}\n\txv, err := length(x)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn xv <= yv, nil\n}\n"
        },
        {
          "name": "query_test.go",
          "type": "blob",
          "size": 13.115234375,
          "content": "package gojsonq\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_eq(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\t// our expectation for json unmarshaller is little bit different. here 9 provided by user will be equal to float64 9\n\t\t\tx:        9.0,\n\t\t\ty:        9,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        110,\n\t\t\ty:        120,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        10.09,\n\t\t\ty:        10.09,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        10.09,\n\t\t\ty:        10.89,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"john\",\n\t\t\ty:        \"john\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"tom\",\n\t\t\ty:        \"jane\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"\",\n\t\t\ty:        \"\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        nil,\n\t\t\ty:        nil,\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := eq(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_neq(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        9.0, // as x is out json unmarshal value which is float64\n\t\t\ty:        9,   // our expectation for json unmarshalar is little bit different. here 9 provided by user will be equal to float64 9\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        110,\n\t\t\ty:        120,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        10.09,\n\t\t\ty:        10.09,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        10.09,\n\t\t\ty:        10.89,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"john\",\n\t\t\ty:        \"john\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"tom\",\n\t\t\ty:        \"jane\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"\",\n\t\t\ty:        \"\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        nil,\n\t\t\ty:        nil,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := neq(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_gt(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        5,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        15,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"101\",\n\t\t\ty:        \"101\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := gt(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lt(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        5,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        15,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"101\",\n\t\t\ty:        \"101\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lt(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_gte(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        5,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        15,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(18),\n\t\t\ty:        18,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(30.9),\n\t\t\ty:        30.9,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"101\",\n\t\t\ty:        \"101\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := gte(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lte(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        5,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        15,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(18),\n\t\t\ty:        18,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(30.9),\n\t\t\ty:        30.9,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(40.9),\n\t\t\ty:        30.9,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"101\",\n\t\t\ty:        \"101\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lte(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_strStrictContains(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(11),\n\t\t\ty:        float64(11),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"131\",\n\t\t\ty:        float64(131),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"458\",\n\t\t\ty:        \"458\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"arch\",\n\t\t\ty:        \"arch\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"Arch\",\n\t\t\ty:        \"arch\",\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := strStrictContains(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_strContains(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(11),\n\t\t\ty:        float64(11),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"131\",\n\t\t\ty:        float64(131),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"458\",\n\t\t\ty:        \"458\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"arch\",\n\t\t\ty:        \"arch\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"Arch\",\n\t\t\ty:        \"arcH\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := strContains(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_strStartsWith(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(11),\n\t\t\ty:        float64(11),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"131\",\n\t\t\ty:        float64(131),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"458\",\n\t\t\ty:        \"458\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"arch\",\n\t\t\ty:        \"arch\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"erik\",\n\t\t\ty:        \"er\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := strStartsWith(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_strEndsWith(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        \"10\",\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(11),\n\t\t\ty:        float64(11),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"131\",\n\t\t\ty:        float64(131),\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"458\",\n\t\t\ty:        \"458\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"arch\",\n\t\t\ty:        \"arch\",\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sky\",\n\t\t\ty:        \"ky\",\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := strEndsWith(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_in(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        \"sky\",\n\t\t\ty:        []string{\"river\", \"sun\", \"moon\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        []string{\"river\", \"sun\", \"moon\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10), // ass json numeric value will be treat as float64\n\t\t\ty:        []int{11, 12, 14, 18},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(14), // ass json numeric value will be treat as float64\n\t\t\ty:        []int{11, 12, 14, 18},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        []float64{11, 12, 14, 18},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(14),\n\t\t\ty:        []float64{11, 12, 14, 18},\n\t\t\texpected: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := in(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_notIn(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        \"sky\",\n\t\t\ty:        []string{\"river\", \"sun\", \"moon\"},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        []string{\"river\", \"sun\", \"moon\"},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10), // ass json numeric value will be treat as float64\n\t\t\ty:        []int{11, 12, 14, 18},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(14), // ass json numeric value will be treat as float64\n\t\t\ty:        []int{11, 12, 14, 18},\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        float64(10),\n\t\t\ty:        []float64{11, 12, 14, 18},\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        float64(14),\n\t\t\ty:        []float64{11, 12, 14, 18},\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := notIn(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lenEq(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        []interface{}{\"river\", \"sun\", \"moon\"},\n\t\t\ty:        3,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        3,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        100,\n\t\t\ty:        3,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        100,\n\t\t\ty:        3,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        4.0,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lenEq(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lenNotEq(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        []interface{}{\"river\", \"sun\", \"moon\"},\n\t\t\ty:        6,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        8,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        100.6,\n\t\t\ty:        4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        4.0,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lenNotEq(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lenGt(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        []interface{}{\"river\", \"sun\", \"moon\"},\n\t\t\ty:        6,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        2,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        2,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        100.6,\n\t\t\ty:        4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        4.0,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lenGt(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lenLt(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        []interface{}{\"river\", \"sun\", \"moon\"},\n\t\t\ty:        6,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        20,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        3,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        100.6,\n\t\t\ty:        4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"john\",\n\t\t\ty:        4.0,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lenLt(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lenGte(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        []interface{}{\"river\", \"sun\", \"moon\"},\n\t\t\ty:        3,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        2,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"jane\",\n\t\t\ty:        5,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        100.6,\n\t\t\ty:        4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        4.0,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lenGte(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_lenLte(t *testing.T) {\n\ttestCases := []struct {\n\t\tx        interface{}\n\t\ty        interface{}\n\t\texpected bool\n\t}{\n\t\t{\n\t\t\tx:        []interface{}{\"river\", \"sun\", \"moon\"},\n\t\t\ty:        3,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"sun\",\n\t\t\ty:        12,\n\t\t\texpected: true,\n\t\t},\n\t\t{\n\t\t\tx:        \"jane\",\n\t\t\ty:        2,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        100.6,\n\t\t\ty:        4,\n\t\t\texpected: false,\n\t\t},\n\t\t{\n\t\t\tx:        \"moon\",\n\t\t\ty:        4.0,\n\t\t\texpected: false,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif o, _ := lenLte(tc.x, tc.y); o != tc.expected {\n\t\t\tt.Errorf(\"for %v expected: %v got: %v\", tc.x, tc.expected, o)\n\t\t}\n\t}\n}\n\nfunc Test_loadDefaultQueryMap(t *testing.T) {\n\tif len(defaultQueries()) != 25 {\n\t\tt.Error(\"mismatched default query map size\")\n\t}\n}\n"
        },
        {
          "name": "result.go",
          "type": "blob",
          "size": 12.337890625,
          "content": "package gojsonq\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst errMessage = \"gojsonq: wrong method call for %v\"\n\n// Available named error values\nvar (\n\tErrExpectsPointer = fmt.Errorf(\"gojsonq: failed to unmarshal, expects pointer\")\n\tErrImmutable      = fmt.Errorf(\"gojsonq: failed to unmarshal, target is not mutable\")\n\tErrTypeMismatch   = fmt.Errorf(\"gojsonq: failed to unmarshal, target type misatched\")\n)\n\n// NewResult return an instance of Result\nfunc NewResult(v interface{}) *Result {\n\treturn &Result{value: v}\n}\n\n// Result represent custom type\ntype Result struct {\n\tvalue interface{}\n}\n\n// Nil check the query has result or not\nfunc (r *Result) Nil() bool {\n\treturn r.value == nil\n}\n\n// As sets the value of Result to v; It does not support methods with argument available in Result\nfunc (r *Result) As(v interface{}) error {\n\tif r.value != nil {\n\t\trv := reflect.ValueOf(v)\n\t\tif rv.Kind() != reflect.Ptr || rv.IsNil() {\n\t\t\treturn ErrExpectsPointer\n\t\t}\n\n\t\telm := rv.Elem()\n\t\tif !elm.CanSet() {\n\t\t\treturn ErrImmutable\n\t\t}\n\n\t\tmethod := rv.Type().String()\n\t\tmethodMap := map[string]string{\n\t\t\t\"*string\": \"String\", \"*bool\": \"Bool\", \"*time.Duration\": \"Duration\",\n\t\t\t\"*int\": \"Int\", \"*int8\": \"Int8\", \"*int16\": \"Int16\", \"*int32\": \"Int32\",\n\t\t\t\"*uint\": \"Uint\", \"*uint8\": \"Uint8\", \"*uint16\": \"Uint16\", \"*uint32\": \"Uint32\",\n\t\t\t\"*float32\": \"Float32\", \"*float64\": \"Float64\",\n\n\t\t\t\"*[]string\": \"StringSlice\", \"*[]bool\": \"BoolSlice\", \"*[]time.Duration\": \"DurationSlice\",\n\t\t\t\"*[]int\": \"IntSlice\", \"*[]int8\": \"Int8Slice\", \"*[]int16\": \"Int16Slice\", \"*[]int32\": \"Int32Slice\",\n\t\t\t\"*[]uint\": \"UintSlice\", \"*[]uint8\": \"Uint8Slice\", \"*[]uint16\": \"Uint16Slice\", \"*[]uint32\": \"Uint32Slice\",\n\t\t\t\"*[]float32\": \"Float32Slice\", \"*[]float64\": \"Float64Slice\",\n\t\t}\n\n\t\tif methodMap[method] == \"\" {\n\t\t\treturn fmt.Errorf(\"gojsonq: type [%T] is not available\", v)\n\t\t}\n\n\t\tvv := reflect.ValueOf(r).MethodByName(methodMap[method]).Call(nil)\n\t\tif vv != nil {\n\t\t\tif vv[1].Interface() != nil {\n\t\t\t\treturn ErrTypeMismatch\n\t\t\t}\n\t\t\trv.Elem().Set(vv[0])\n\t\t}\n\t}\n\treturn nil\n}\n\n// Bool assert the result to boolean value\nfunc (r *Result) Bool() (bool, error) {\n\tswitch v := r.value.(type) {\n\tcase bool:\n\t\treturn v, nil\n\tdefault:\n\t\treturn false, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Time assert the result to time.Time\nfunc (r *Result) Time(layout string) (time.Time, error) {\n\tswitch v := r.value.(type) {\n\tcase string:\n\t\treturn time.Parse(layout, v)\n\tdefault:\n\t\treturn time.Time{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Duration assert the result to time.Duration\nfunc (r *Result) Duration() (time.Duration, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn time.Duration(v), nil\n\tcase string:\n\t\tif strings.ContainsAny(v, \"nsumh\") {\n\t\t\treturn time.ParseDuration(v)\n\t\t}\n\t\treturn time.ParseDuration(v + \"ns\")\n\tdefault:\n\t\treturn time.Duration(0), fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// String assert the result to String\nfunc (r *Result) String() (string, error) {\n\tswitch v := r.value.(type) {\n\tcase string:\n\t\treturn v, nil\n\tdefault:\n\t\treturn \"\", fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int assert the result to int\nfunc (r *Result) Int() (int, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn int(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int8 assert the result to int8\nfunc (r *Result) Int8() (int8, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn int8(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int16 assert the result to int16\nfunc (r *Result) Int16() (int16, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn int16(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int32 assert the result to int32\nfunc (r *Result) Int32() (int32, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn int32(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int64 assert the result to int64\nfunc (r *Result) Int64() (int64, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn int64(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint assert the result to uint\nfunc (r *Result) Uint() (uint, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn uint(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint8 assert the result to uint8\nfunc (r *Result) Uint8() (uint8, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn uint8(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint16 assert the result to uint16\nfunc (r *Result) Uint16() (uint16, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn uint16(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint32 assert the result to uint32\nfunc (r *Result) Uint32() (uint32, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn uint32(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint64 assert the result to uint64\nfunc (r *Result) Uint64() (uint64, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn uint64(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Float32 assert the result to float32\nfunc (r *Result) Float32() (float32, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn float32(v), nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Float64 assert the result to 64\nfunc (r *Result) Float64() (float64, error) {\n\tswitch v := r.value.(type) {\n\tcase float64:\n\t\treturn v, nil\n\tdefault:\n\t\treturn 0, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// TODO: Slice related methods - ideally they should return nil instead of empty struct\n// in case of any error or no result. To keep compatibility with older version refactored\n// to use make, in order to create slices.\n\n// BoolSlice assert the result to []bool\nfunc (r *Result) BoolSlice() ([]bool, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar bb = make([]bool, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(bool); ok {\n\t\t\t\tbb = append(bb, s)\n\t\t\t}\n\t\t}\n\t\treturn bb, nil\n\tdefault:\n\t\treturn []bool{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// TimeSlice assert the result to []time.Time\nfunc (r *Result) TimeSlice(layout string) ([]time.Time, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar tt = make([]time.Time, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(string); ok {\n\t\t\t\tts, err := time.Parse(layout, s)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn tt, err\n\t\t\t\t}\n\t\t\t\ttt = append(tt, ts)\n\t\t\t}\n\t\t}\n\t\treturn tt, nil\n\tdefault:\n\t\treturn []time.Time{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// DurationSlice assert the result to []time.Duration\nfunc (r *Result) DurationSlice() ([]time.Duration, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar dd = make([]time.Duration, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(string); ok {\n\t\t\t\tvar d time.Duration\n\t\t\t\tvar err error\n\t\t\t\tif strings.ContainsAny(s, \"nsumh\") {\n\t\t\t\t\td, err = time.ParseDuration(s)\n\t\t\t\t} else {\n\t\t\t\t\td, err = time.ParseDuration(s + \"ns\")\n\t\t\t\t}\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn dd, err\n\t\t\t\t}\n\t\t\t\tdd = append(dd, d)\n\t\t\t}\n\n\t\t\tif v, ok := si.(float64); ok {\n\t\t\t\tdd = append(dd, time.Duration(v))\n\t\t\t}\n\t\t}\n\t\treturn dd, nil\n\tdefault:\n\t\treturn []time.Duration{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// StringSlice assert the result to []string\nfunc (r *Result) StringSlice() ([]string, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ss = make([]string, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(string); ok {\n\t\t\t\tss = append(ss, s)\n\t\t\t}\n\t\t}\n\t\treturn ss, nil\n\tdefault:\n\t\treturn []string{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// IntSlice assert the result to []int\nfunc (r *Result) IntSlice() ([]int, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ii = make([]int, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tii = append(ii, int(s))\n\t\t\t}\n\t\t}\n\t\treturn ii, nil\n\tdefault:\n\t\treturn []int{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int8Slice assert the result to []int8\nfunc (r *Result) Int8Slice() ([]int8, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ii = make([]int8, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tii = append(ii, int8(s))\n\t\t\t}\n\t\t}\n\t\treturn ii, nil\n\tdefault:\n\t\treturn []int8{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int16Slice assert the result to []int16\nfunc (r *Result) Int16Slice() ([]int16, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ii = make([]int16, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tii = append(ii, int16(s))\n\t\t\t}\n\t\t}\n\t\treturn ii, nil\n\tdefault:\n\t\treturn []int16{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int32Slice assert the result to []int32\nfunc (r *Result) Int32Slice() ([]int32, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ii = make([]int32, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tii = append(ii, int32(s))\n\t\t\t}\n\t\t}\n\t\treturn ii, nil\n\tdefault:\n\t\treturn []int32{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Int64Slice assert the result to []int64\nfunc (r *Result) Int64Slice() ([]int64, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ii = make([]int64, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tii = append(ii, int64(s))\n\t\t\t}\n\t\t}\n\t\treturn ii, nil\n\tdefault:\n\t\treturn []int64{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// UintSlice assert the result to []uint\nfunc (r *Result) UintSlice() ([]uint, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar uu = make([]uint, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tuu = append(uu, uint(s))\n\t\t\t}\n\t\t}\n\t\treturn uu, nil\n\tdefault:\n\t\treturn []uint{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint8Slice assert the result to []uint8\nfunc (r *Result) Uint8Slice() ([]uint8, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar uu = make([]uint8, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tuu = append(uu, uint8(s))\n\t\t\t}\n\t\t}\n\t\treturn uu, nil\n\tdefault:\n\t\treturn []uint8{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint16Slice assert the result to []uint16\nfunc (r *Result) Uint16Slice() ([]uint16, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar uu = make([]uint16, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tuu = append(uu, uint16(s))\n\t\t\t}\n\t\t}\n\t\treturn uu, nil\n\tdefault:\n\t\treturn []uint16{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint32Slice assert the result to []uint32\nfunc (r *Result) Uint32Slice() ([]uint32, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar uu = make([]uint32, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tuu = append(uu, uint32(s))\n\t\t\t}\n\t\t}\n\t\treturn uu, nil\n\tdefault:\n\t\treturn []uint32{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Uint64Slice assert the result to []uint64\nfunc (r *Result) Uint64Slice() ([]uint64, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar uu = make([]uint64, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tuu = append(uu, uint64(s))\n\t\t\t}\n\t\t}\n\t\treturn uu, nil\n\tdefault:\n\t\treturn []uint64{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Float32Slice assert the result to []float32\nfunc (r *Result) Float32Slice() ([]float32, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ff = make([]float32, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tff = append(ff, float32(s))\n\t\t\t}\n\t\t}\n\t\treturn ff, nil\n\tdefault:\n\t\treturn []float32{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n\n// Float64Slice assert the result to []float64\nfunc (r *Result) Float64Slice() ([]float64, error) {\n\tswitch v := r.value.(type) {\n\tcase []interface{}:\n\t\tvar ff = make([]float64, 0)\n\t\tfor _, si := range v {\n\t\t\tif s, ok := si.(float64); ok {\n\t\t\t\tff = append(ff, s)\n\t\t\t}\n\t\t}\n\t\treturn ff, nil\n\tdefault:\n\t\treturn []float64{}, fmt.Errorf(errMessage, reflect.ValueOf(r.value).Kind())\n\t}\n}\n"
        },
        {
          "name": "result_test.go",
          "type": "blob",
          "size": 28.84375,
          "content": "package gojsonq\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestNewResult(t *testing.T) {\n\tresult := NewResult(\"gojsonq\")\n\tif reflect.ValueOf(result).Type().String() != \"*gojsonq.Result\" {\n\t\tt.Error(\"failed to match gojsonq.Result type\")\n\t}\n}\n\nfunc TestNil(t *testing.T) {\n\tresult := NewResult(nil)\n\tif result.Nil() == false {\n\t\tt.Error(\"failed to check Nil\")\n\t}\n}\n\nfunc TestAs(t *testing.T) {\n\ttype flt float64\n\ttestCases := []struct {\n\t\ttag              string\n\t\tvalue            interface{}\n\t\tnewExpectedValue func() interface{}\n\t\texpect           func(value, i interface{}) bool\n\t\terrExpect        bool\n\t}{\n\t\t{\n\t\t\ttag:   \"float64 as int\", // golang unmarshal number to float64\n\t\t\tvalue: float64(1),\n\t\t\tnewExpectedValue: func() interface{} {\n\t\t\t\tvar a int\n\t\t\t\treturn &a\n\t\t\t},\n\t\t\texpect: func(value, i interface{}) bool {\n\t\t\t\tval, ok := i.(int)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\treturn val == (value.(int))\n\t\t\t},\n\t\t\terrExpect: false,\n\t\t},\n\t\t{\n\t\t\ttag:   \"float64 as uint\",\n\t\t\tvalue: float64(1),\n\t\t\tnewExpectedValue: func() interface{} {\n\t\t\t\tvar a uint\n\t\t\t\treturn &a\n\t\t\t},\n\t\t\texpect: func(value, i interface{}) bool {\n\t\t\t\tval, ok := i.(uint)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\treturn val == (value.(uint))\n\t\t\t},\n\t\t\terrExpect: false,\n\t\t},\n\t\t{\n\t\t\ttag:   \"float64 assign to non ptr\",\n\t\t\tvalue: float64(1),\n\t\t\tnewExpectedValue: func() interface{} {\n\t\t\t\tvar a float64\n\t\t\t\treturn a\n\t\t\t},\n\t\t\texpect: func(value, i interface{}) bool {\n\t\t\t\tval, ok := i.(float64)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\treturn val == (value.(float64))\n\t\t\t},\n\t\t\terrExpect: true,\n\t\t},\n\t\t{\n\t\t\ttag:   \"string assign to int\",\n\t\t\tvalue: string(\"*nop\"),\n\t\t\tnewExpectedValue: func() interface{} {\n\t\t\t\tvar a float64\n\t\t\t\treturn &a\n\t\t\t},\n\t\t\texpect: func(value, i interface{}) bool {\n\t\t\t\tval, ok := i.(string)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\treturn val == (value.(string))\n\t\t\t},\n\t\t\terrExpect: true,\n\t\t},\n\t\t{\n\t\t\ttag:   \"custom type error check\",\n\t\t\tvalue: string(\"*nop\"),\n\t\t\tnewExpectedValue: func() interface{} {\n\t\t\t\tvar a flt\n\t\t\t\treturn &a\n\t\t\t},\n\t\t\texpect: func(value, i interface{}) bool {\n\t\t\t\tval, ok := i.(string)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\treturn val == (value.(string))\n\t\t\t},\n\t\t\terrExpect: true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\texpected := tc.newExpectedValue()\n\t\terr := NewResult(tc.value).As(expected)\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(tc.tag, err)\n\t\t}\n\t\tif tc.expect(tc.value, expected) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.value, reflect.ValueOf(expected).Elem())\n\t\t}\n\t}\n}\n\nfunc TestBool(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect bool\n\t\terrExpect bool\n\t}{\n\n\t\t{tag: \"bool value as expected\", value: true, valExpect: true, errExpect: false},\n\t\t{tag: \"invalid bool, error expected\", value: 123, valExpect: false, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Bool()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"bool:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestTime(t *testing.T) {\n\tlayout := \"2006-01-02T15:04:05.000Z\"\n\tstr := \"2014-11-12T11:45:26.371Z\"\n\ttm, err := time.Parse(layout, str)\n\tif err != nil {\n\t\tt.Error(\"failed to parse time:\", err)\n\t}\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect time.Time\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"time value as expected\", value: \"2014-11-12T11:45:26.371Z\", valExpect: tm, errExpect: false},\n\t\t{tag: \"invalid time, error expected\", value: \"2014-11-12\", valExpect: time.Time{}, errExpect: true},\n\t\t{tag: \"invalid time, error expected\", value: 12322, valExpect: time.Time{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Time(layout)\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"time:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(v, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestDuration(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect time.Duration\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"duration value as expected\", value: \"10s\", valExpect: time.Duration(10 * time.Second), errExpect: false},\n\t\t{tag: \"duration value as expected\", value: \"10m\", valExpect: time.Duration(10 * time.Minute), errExpect: false},\n\t\t{tag: \"duration value as expected\", value: float64(10), valExpect: time.Duration(10 * time.Nanosecond), errExpect: false}, // go decode number to float64\n\t\t{tag: \"invalid duration, error expected\", value: \"1\", valExpect: time.Duration(0), errExpect: true},\n\t\t{tag: \"invalid duration, error expected\", value: 1, valExpect: time.Duration(0), errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Duration()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"duration:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(v, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestString(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect string\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"string value as expected\", value: \"hello\", valExpect: \"hello\", errExpect: false},\n\t\t{tag: \"invalid string, error expected\", value: 123, valExpect: \"\", errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).String()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"string: \", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestInt(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect int\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int value as expected\", value: 123.8, valExpect: 123, errExpect: false},\n\t\t{tag: \"int value as expected\", value: 12.3, valExpect: 12, errExpect: false},\n\t\t{tag: \"invalid int, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Int()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestInt8(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect int8\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int8 value as expected\", value: 123.8, valExpect: int8(123), errExpect: false},\n\t\t{tag: \"int8 value as expected\", value: 12.3, valExpect: int8(12), errExpect: false},\n\t\t{tag: \"invalid int8, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Int8()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int8:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestInt16(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect int16\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int16 value as expected\", value: 123.8, valExpect: int16(123), errExpect: false},\n\t\t{tag: \"int16 value as expected\", value: 12.3, valExpect: int16(12), errExpect: false},\n\t\t{tag: \"invalid int16, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Int16()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int16:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestInt32(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect int32\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int32 value as expected\", value: 123.8, valExpect: int32(123), errExpect: false},\n\t\t{tag: \"int32 value as expected\", value: 12.3, valExpect: int32(12), errExpect: false},\n\t\t{tag: \"invalid int32, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Int32()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int32:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestInt64(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect int64\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int64 value as expected\", value: 123.8, valExpect: int64(123), errExpect: false},\n\t\t{tag: \"int64 value as expected\", value: 12.3, valExpect: int64(12), errExpect: false},\n\t\t{tag: \"invalid int64, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Int64()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int64:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestUint(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect uint\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint value as expected\", value: 123.8, valExpect: uint(123), errExpect: false},\n\t\t{tag: \"uint value as expected\", value: 12.3, valExpect: uint(12), errExpect: false},\n\t\t{tag: \"invalid uint, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Uint()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestUint8(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect uint8\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint8 value as expected\", value: 123.8, valExpect: uint8(123), errExpect: false},\n\t\t{tag: \"uint8 value as expected\", value: 12.3, valExpect: uint8(12), errExpect: false},\n\t\t{tag: \"invalid uint8, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Uint8()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint8:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestUint16(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect uint16\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint16 value as expected\", value: 123.8, valExpect: uint16(123), errExpect: false},\n\t\t{tag: \"uint16 value as expected\", value: 12.3, valExpect: uint16(12), errExpect: false},\n\t\t{tag: \"invalid uint16, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Uint16()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint16:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestUint32(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect uint32\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint32 value as expected\", value: 123.8, valExpect: uint32(123), errExpect: false},\n\t\t{tag: \"uint32 value as expected\", value: 12.3, valExpect: uint32(12), errExpect: false},\n\t\t{tag: \"invalid uint32, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Uint32()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint32:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestUint64(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect uint64\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint64 value as expected\", value: 123.8, valExpect: uint64(123), errExpect: false},\n\t\t{tag: \"uint64 value as expected\", value: 12.3, valExpect: uint64(12), errExpect: false},\n\t\t{tag: \"invalid uint64, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Uint64()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint64:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestFloat32(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect float32\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"float32 value as expected\", value: 123.8, valExpect: float32(123.8), errExpect: false},\n\t\t{tag: \"float32 value as expected\", value: 12.3, valExpect: float32(12.3), errExpect: false},\n\t\t{tag: \"invalid float32, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Float32()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"float32:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestFloat64(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect float64\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"float64 value as expected\", value: 123.8, valExpect: float64(123.8), errExpect: false},\n\t\t{tag: \"float64 value as expected\", value: 12.3, valExpect: float64(12.3), errExpect: true},\n\t\t{tag: \"invalid float64, error expected\", value: \"123\", valExpect: 0, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tv, err := NewResult(tc.value).Float64()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"float64:\", err)\n\t\t}\n\t\tif v != tc.valExpect && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, v)\n\t\t}\n\t}\n}\n\nfunc TestBoolSlice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []bool\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"boolSlice value as expected\", value: []interface{}{true, false}, valExpect: []bool{true, false}, errExpect: false},\n\t\t{tag: \"boolSlice value as expected\", value: []interface{}{false, true, true}, valExpect: []bool{false, true, true}, errExpect: false},\n\t\t{tag: \"invalid boolSlice, error expected\", value: []interface{}{1, 3}, valExpect: []bool{}, errExpect: false},\n\t\t{tag: \"invalid boolSlice, error expected\", value: []int{1, 3}, valExpect: []bool{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).BoolSlice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"boolSlice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestTimelice(t *testing.T) {\n\tlayout := \"2006-01-02T15:04:05.000Z\"\n\tt1, err1 := time.Parse(layout, \"2014-11-12T11:45:26.371Z\")\n\tif err1 != nil {\n\t\tt.Error(\"failed to parse time1:\", err1)\n\t}\n\tt2, err2 := time.Parse(layout, \"2019-11-12T11:45:26.371Z\")\n\tif err2 != nil {\n\t\tt.Error(\"failed to parse time2:\", err2)\n\t}\n\ttestCases := []struct {\n\t\ttag        string\n\t\tvalue      interface{}\n\t\ttimeLayout string\n\t\tvalExpect  []time.Time\n\t\terrExpect  bool\n\t}{\n\t\t{tag: \"timeSlice value as expected\", value: []interface{}{\"2014-11-12T11:45:26.371Z\", \"2019-11-12T11:45:26.371Z\"}, timeLayout: layout, valExpect: []time.Time{t1, t2}, errExpect: false},\n\t\t{tag: \"invalid timeSlice layout, error expected\", value: []interface{}{\"2014-11-12T11:45:26.371Z\", \"2019-11-12T11:45:26.371Z\"}, timeLayout: \"invalid layout\", valExpect: []time.Time{}, errExpect: true},\n\t\t{tag: \"invalid timeSlice, error expected\", value: []int{1, 3}, timeLayout: layout, valExpect: []time.Time{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).TimeSlice(tc.timeLayout)\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"timeSlice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n\n}\n\nfunc TestDurationlice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []time.Duration\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"durationSlice value as expected\", value: []interface{}{\"1s\", \"1m\"}, valExpect: []time.Duration{1 * time.Second, 1 * time.Minute}, errExpect: false},\n\t\t{tag: \"durationSlice value as expected\", value: []interface{}{\"1\", \"2\"}, valExpect: []time.Duration{1 * time.Nanosecond, 2 * time.Nanosecond}, errExpect: false},\n\t\t{tag: \"durationSlice value as expected\", value: []interface{}{float64(2), float64(3)}, valExpect: []time.Duration{2 * time.Nanosecond, 3 * time.Nanosecond}, errExpect: false},\n\t\t{tag: \"invalid durationSlice, error expected\", value: []interface{}{\"invalid duration 1\", \"invalid duration 2\"}, valExpect: []time.Duration{}, errExpect: true},\n\t\t{tag: \"invalid durationSlice, error expected\", value: []float64{3, 5}, valExpect: []time.Duration{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).DurationSlice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"durationSlice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestStringSlice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []string\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"stringSlice value as expected\", value: []interface{}{\"hello\", \"world\"}, valExpect: []string{\"hello\", \"world\"}, errExpect: false},\n\t\t{tag: \"stringSlice value as expected\", value: []interface{}{\"tom\", \"jerry\"}, valExpect: []string{\"tom\", \"jerry\"}, errExpect: false},\n\t\t{tag: \"invalid stringSlice, error expected\", value: []interface{}{1, 3}, valExpect: []string{}, errExpect: false},\n\t\t{tag: \"invalid stringSlice, error expected\", value: []int{1, 3}, valExpect: []string{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).StringSlice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"stringSlice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestIntSlice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []int\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"intSlice value as expected\", value: []interface{}{132.1, 12.99}, valExpect: []int{132, 12}, errExpect: false},\n\t\t{tag: \"intSlice value as expected\", value: []interface{}{float64(131), float64(12)}, valExpect: []int{131, 12}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid intSlice, error expected\", value: []interface{}{1, 3}, valExpect: []int{}, errExpect: false},\n\t\t{tag: \"invalid intSlice, error expected\", value: []int{1, 3}, valExpect: []int{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).IntSlice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"intSlice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestInt8Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []int8\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int8Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []int8{3, 12}, errExpect: false},\n\t\t{tag: \"int8Slice value as expected\", value: []interface{}{float64(11), float64(12)}, valExpect: []int8{11, 12}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid int8Slice, error expected\", value: []interface{}{1, 3}, valExpect: []int8{}, errExpect: false},\n\t\t{tag: \"invalid int8Slice, error expected\", value: []int{1, 3}, valExpect: []int8{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Int8Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int8Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestInt16Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []int16\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int16Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []int16{3, 12}, errExpect: false},\n\t\t{tag: \"int16Slice value as expected\", value: []interface{}{float64(11), float64(12)}, valExpect: []int16{11, 12}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid int16Slice, error expected\", value: []interface{}{1, 3}, valExpect: []int16{}, errExpect: false},\n\t\t{tag: \"invalid int16Slice, error expected\", value: []int{1, 3}, valExpect: []int16{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Int16Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int16Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestInt32Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []int32\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int32Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []int32{3, 12}, errExpect: false},\n\t\t{tag: \"int32Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []int32{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid int32Slice, error expected\", value: []interface{}{1, 3}, valExpect: []int32{}, errExpect: false},\n\t\t{tag: \"invalid int32Slice, error expected\", value: []int{1, 3}, valExpect: []int32{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Int32Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int32Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestInt64Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []int64\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"int64Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []int64{3, 12}, errExpect: false},\n\t\t{tag: \"int64Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []int64{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid int64Slice, error expected\", value: []interface{}{1, 3}, valExpect: []int64{}, errExpect: false},\n\t\t{tag: \"invalid int64Slice, error expected\", value: []int{1, 3}, valExpect: []int64{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Int64Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"int64Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestUintSlice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []uint\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uintSlice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []uint{3, 12}, errExpect: false},\n\t\t{tag: \"uintSlice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []uint{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid uintSlice, error expected\", value: []interface{}{1, 3}, valExpect: []uint{}, errExpect: false},\n\t\t{tag: \"invalid uintSlice, error expected\", value: []int{1, 3}, valExpect: []uint{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).UintSlice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uintSlice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestUint8Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []uint8\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint8Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []uint8{3, 12}, errExpect: false},\n\t\t{tag: \"uint8Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []uint8{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid uint8Slice, error expected\", value: []interface{}{1, 3}, valExpect: []uint8{}, errExpect: false},\n\t\t{tag: \"invalid uint8Slice, error expected\", value: []int{1, 3}, valExpect: []uint8{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Uint8Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint8Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestUint16Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []uint16\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint16Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []uint16{3, 12}, errExpect: false},\n\t\t{tag: \"uint16Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []uint16{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid uint16Slice, error expected\", value: []interface{}{1, 3}, valExpect: []uint16{}, errExpect: false},\n\t\t{tag: \"invalid uint16Slice, error expected\", value: []int{1, 3}, valExpect: []uint16{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Uint16Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint16Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestUint32Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []uint32\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint32Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []uint32{3, 12}, errExpect: false},\n\t\t{tag: \"uint32Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []uint32{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid uint32Slice, error expected\", value: []interface{}{1, 3}, valExpect: []uint32{}, errExpect: false},\n\t\t{tag: \"invalid uint32Slice, error expected\", value: []int{1, 3}, valExpect: []uint32{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Uint32Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint32Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestUint64Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []uint64\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"uint64Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []uint64{3, 12}, errExpect: false},\n\t\t{tag: \"uint64Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []uint64{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid uint64Slice, error expected\", value: []interface{}{1, 3}, valExpect: []uint64{}, errExpect: false},\n\t\t{tag: \"invalid uint64Slice, error expected\", value: []int{1, 3}, valExpect: []uint64{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Uint64Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"uint64Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestFloat32Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []float32\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"float32Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []float32{3.1, 12.99}, errExpect: false},\n\t\t{tag: \"float32Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []float32{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid float32Slice, error expected\", value: []interface{}{1, 3}, valExpect: []float32{}, errExpect: false},\n\t\t{tag: \"invalid float32Slice, error expected\", value: []int{1, 3}, valExpect: []float32{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Float32Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"float32Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n\nfunc TestFloat64Slice(t *testing.T) {\n\ttestCases := []struct {\n\t\ttag       string\n\t\tvalue     interface{}\n\t\tvalExpect []float64\n\t\terrExpect bool\n\t}{\n\t\t{tag: \"float64Slice value as expected\", value: []interface{}{3.1, 12.99}, valExpect: []float64{3.1, 12.99}, errExpect: false},\n\t\t{tag: \"float64Slice value as expected\", value: []interface{}{float64(131), float64(132)}, valExpect: []float64{131, 132}, errExpect: false}, // as golang decode number to float64\n\t\t{tag: \"invalid float64Slice, error expected\", value: []interface{}{1, 3}, valExpect: []float64{}, errExpect: false},\n\t\t{tag: \"invalid float64Slice, error expected\", value: []int{1, 3}, valExpect: []float64{}, errExpect: true},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tvv, err := NewResult(tc.value).Float64Slice()\n\t\tif err != nil && !tc.errExpect {\n\t\t\tt.Error(\"float64Slice:\", err)\n\t\t}\n\t\tif !reflect.DeepEqual(vv, tc.valExpect) && !tc.errExpect {\n\t\t\tt.Errorf(\"tag: %s\\nexpected: %v got %v\", tc.tag, tc.valExpect, vv)\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}