{
  "metadata": {
    "timestamp": 1736567237888,
    "page": 834,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "ory/ladon",
      "stars": 2399,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".bin",
          "type": "tree",
          "content": null
        },
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.314453125,
          "content": "root = true\n\n; Unix-style newlines with a newline ending every file\n[*]\nend_of_line = lf\nindent_size = 4\nindent_style = space\ninsert_final_newline = true\ntrim_trailing_whitespace  = true\ninsert_final_newline = true\ncharset = utf-8\n\n; Golang\n[*.go]\nindent_style = tab\nindent_size = 4\n\n; YAML\n[*.{yaml,yml}]\nindent_size = 2\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.041015625,
          "content": ".idea\n*.iml\nvendor/\nsqlite-test.db\ntests/\n"
        },
        {
          "name": ".reference-ignore",
          "type": "blob",
          "size": 0.033203125,
          "content": "**/node_modules\ndocs\nCHANGELOG.md\n"
        },
        {
          "name": ".reports",
          "type": "tree",
          "content": null
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.46875,
          "content": "sudo: required\n\nenv:\n  - GO111MODULE=on\n\nlanguage: go\n\ngo_import_path: github.com/ory/ladon\n\ngo:\n  - 1.11\n\ninstall:\n  - go get github.com/mattn/goveralls golang.org/x/tools/cmd/cover github.com/pierrre/gotestcover\n\nscript:\n  - gotestcover -coverprofile=\"cover.out\" -race -covermode=\"atomic\" $(go list ./... | grep -v /vendor/)\n\nafter_success:\n  - go vet -x $(go list ./... | grep -v /vendor/)\n  - golint $(go list ./... | grep -v /vendor/)\n  - goveralls -coverprofile=\"cover.out\"\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 6.064453125,
          "content": "<!-- AUTO-GENERATED, DO NOT EDIT! -->\n<!-- Please edit the original at https://github.com/ory/meta/blob/master/templates/repository/common/CODE_OF_CONDUCT.md -->\n\n# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nWe as members, contributors, and leaders pledge to make participation in our\ncommunity a harassment-free experience for everyone, regardless of age, body\nsize, visible or invisible disability, ethnicity, sex characteristics, gender\nidentity and expression, level of experience, education, socio-economic status,\nnationality, personal appearance, race, caste, color, religion, or sexual\nidentity and orientation.\n\nWe pledge to act and interact in ways that contribute to an open, welcoming,\ndiverse, inclusive, and healthy community.\n\n## Our Standards\n\nExamples of behavior that contributes to a positive environment for our\ncommunity include:\n\n- Demonstrating empathy and kindness toward other people\n- Being respectful of differing opinions, viewpoints, and experiences\n- Giving and gracefully accepting constructive feedback\n- Accepting responsibility and apologizing to those affected by our mistakes,\n  and learning from the experience\n- Focusing on what is best not just for us as individuals, but for the overall\n  community\n\nExamples of unacceptable behavior include:\n\n- The use of sexualized language or imagery, and sexual attention or advances of\n  any kind\n- Trolling, insulting or derogatory comments, and personal or political attacks\n- Public or private harassment\n- Publishing others' private information, such as a physical or email address,\n  without their explicit permission\n- Other conduct which could reasonably be considered inappropriate in a\n  professional setting\n\n## Open Source Community Support\n\nOry Open source software is collaborative and based on contributions by\ndevelopers in the Ory community. There is no obligation from Ory to help with\nindividual problems. If Ory open source software is used in production in a\nfor-profit company or enterprise environment, we mandate a paid support contract\nwhere Ory is obligated under their service level agreements (SLAs) to offer a\ndefined level of availability and responsibility. For more information about\npaid support please contact us at sales@ory.sh.\n\n## Enforcement Responsibilities\n\nCommunity leaders are responsible for clarifying and enforcing our standards of\nacceptable behavior and will take appropriate and fair corrective action in\nresponse to any behavior that they deem inappropriate, threatening, offensive,\nor harmful.\n\nCommunity leaders have the right and responsibility to remove, edit, or reject\ncomments, commits, code, wiki edits, issues, and other contributions that are\nnot aligned to this Code of Conduct, and will communicate reasons for moderation\ndecisions when appropriate.\n\n## Scope\n\nThis Code of Conduct applies within all community spaces, and also applies when\nan individual is officially representing the community in public spaces.\nExamples of representing our community include using an official e-mail address,\nposting via an official social media account, or acting as an appointed\nrepresentative at an online or offline event.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be\nreported to the community leaders responsible for enforcement at\n[office@ory.sh](mailto:office@ory.sh). All complaints will be reviewed and\ninvestigated promptly and fairly.\n\nAll community leaders are obligated to respect the privacy and security of the\nreporter of any incident.\n\n## Enforcement Guidelines\n\nCommunity leaders will follow these Community Impact Guidelines in determining\nthe consequences for any action they deem in violation of this Code of Conduct:\n\n### 1. Correction\n\n**Community Impact**: Use of inappropriate language or other behavior deemed\nunprofessional or unwelcome in the community.\n\n**Consequence**: A private, written warning from community leaders, providing\nclarity around the nature of the violation and an explanation of why the\nbehavior was inappropriate. A public apology may be requested.\n\n### 2. Warning\n\n**Community Impact**: A violation through a single incident or series of\nactions.\n\n**Consequence**: A warning with consequences for continued behavior. No\ninteraction with the people involved, including unsolicited interaction with\nthose enforcing the Code of Conduct, for a specified period of time. This\nincludes avoiding interactions in community spaces as well as external channels\nlike social media. Violating these terms may lead to a temporary or permanent\nban.\n\n### 3. Temporary Ban\n\n**Community Impact**: A serious violation of community standards, including\nsustained inappropriate behavior.\n\n**Consequence**: A temporary ban from any sort of interaction or public\ncommunication with the community for a specified period of time. No public or\nprivate interaction with the people involved, including unsolicited interaction\nwith those enforcing the Code of Conduct, is allowed during this period.\nViolating these terms may lead to a permanent ban.\n\n### 4. Permanent Ban\n\n**Community Impact**: Demonstrating a pattern of violation of community\nstandards, including sustained inappropriate behavior, harassment of an\nindividual, or aggression toward or disparagement of classes of individuals.\n\n**Consequence**: A permanent ban from any sort of public interaction within the\ncommunity.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage],\nversion 2.1, available at\n[https://www.contributor-covenant.org/version/2/1/code_of_conduct.html][v2.1].\n\nCommunity Impact Guidelines were inspired by [Mozilla's code of conduct\nenforcement ladder][mozilla coc].\n\nFor answers to common questions about this code of conduct, see the FAQ at\n[https://www.contributor-covenant.org/faq][faq]. Translations are available at\n[https://www.contributor-covenant.org/translations][translations].\n\n[homepage]: https://www.contributor-covenant.org\n[v2.1]: https://www.contributor-covenant.org/version/2/1/code_of_conduct.html\n[mozilla coc]: https://github.com/mozilla/diversity\n[faq]: https://www.contributor-covenant.org/faq\n[translations]: https://www.contributor-covenant.org/translations\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 12.1474609375,
          "content": "<!-- AUTO-GENERATED, DO NOT EDIT! -->\n<!-- Please edit the original at https://github.com/ory/meta/blob/master/templates/repository/common/CONTRIBUTING.md -->\n\n# Contribute to Ory ladon<!-- omit in toc -->\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n- [Introduction](#introduction)\n- [FAQ](#faq)\n- [How can I contribute?](#how-can-i-contribute)\n- [Communication](#communication)\n- [Contribute examples](#contribute-examples)\n- [Contribute code](#contribute-code)\n- [Contribute documentation](#contribute-documentation)\n- [Disclosing vulnerabilities](#disclosing-vulnerabilities)\n- [Code style](#code-style)\n  - [Working with forks](#working-with-forks)\n- [Conduct](#conduct)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## Introduction\n\n_Please note_: We take Ory ladon's security and our users' trust very\nseriously. If you believe you have found a security issue in Ory ladon,\nplease disclose it by contacting us at security@ory.sh.\n\nThere are many ways in which you can contribute. The goal of this document is to\nprovide a high-level overview of how you can get involved in Ory.\n\nAs a potential contributor, your changes and ideas are welcome at any hour of\nthe day or night, on weekdays, weekends, and holidays. Please do not ever\nhesitate to ask a question or send a pull request.\n\nIf you are unsure, just ask or submit the issue or pull request anyways. You\nwon't be yelled at for giving it your best effort. The worst that can happen is\nthat you'll be politely asked to change something. We appreciate any sort of\ncontributions and don't want a wall of rules to get in the way of that.\n\nThat said, if you want to ensure that a pull request is likely to be merged,\ntalk to us! You can find out our thoughts and ensure that your contribution\nwon't clash with Ory\nladon's direction. A great way to\ndo this is via\n[Ory ladon Discussions](https://github.com/orgs/ory/discussions)\nor the [Ory Chat](https://www.ory.sh/chat).\n\n## FAQ\n\n- I am new to the community. Where can I find the\n  [Ory Community Code of Conduct?](https://github.com/ory/ladon/blob/master/CODE_OF_CONDUCT.md)\n\n- I have a question. Where can I get\n  [answers to questions regarding Ory ladon?](#communication)\n\n- I would like to contribute but I am not sure how. Are there\n  [easy ways to contribute?](#how-can-i-contribute)\n  [Or good first issues?](https://github.com/search?l=&o=desc&q=label%3A%22help+wanted%22+label%3A%22good+first+issue%22+is%3Aopen+user%3Aory+user%3Aory-corp&s=updated&type=Issues)\n\n- I want to talk to other Ory ladon users.\n  [How can I become a part of the community?](#communication)\n\n- I would like to know what I am agreeing to when I contribute to Ory\n  ladon.\n  Does Ory have\n  [a Contributors License Agreement?](https://cla-assistant.io/ory/ladon)\n\n- I would like updates about new versions of Ory ladon.\n  [How are new releases announced?](https://www.ory.sh/l/sign-up-newsletter)\n\n## How can I contribute?\n\nIf you want to start to contribute code right away, take a look at the\n[list of good first issues](https://github.com/ory/ladon/labels/good%20first%20issue).\n\nThere are many other ways you can contribute. Here are a few things you can do\nto help out:\n\n- **Give us a star.** It may not seem like much, but it really makes a\n  difference. This is something that everyone can do to help out Ory ladon.\n  Github stars help the project gain visibility and stand out.\n\n- **Join the community.** Sometimes helping people can be as easy as listening\n  to their problems and offering a different perspective. Join our Slack, have a\n  look at discussions in the forum and take part in community events. More info\n  on this in [Communication](#communication).\n\n- **Answer discussions.** At all times, there are several unanswered discussions\n  on GitHub. You can see an\n  [overview here](https://github.com/discussions?discussions_q=is%3Aunanswered+org%3Aory+sort%3Aupdated-desc).\n  If you think you know an answer or can provide some information that might\n  help, please share it! Bonus: You get GitHub achievements for answered\n  discussions.\n\n- **Help with open issues.** We have a lot of open issues for Ory ladon and\n  some of them may lack necessary information, some are duplicates of older\n  issues. You can help out by guiding people through the process of filling out\n  the issue template, asking for clarifying information or pointing them to\n  existing issues that match their description of the problem.\n\n- **Review documentation changes.** Most documentation just needs a review for\n  proper spelling and grammar. If you think a document can be improved in any\n  way, feel free to hit the `edit` button at the top of the page. More info on\n  contributing to the documentation [here](#contribute-documentation).\n\n- **Help with tests.** Pull requests may lack proper tests or test plans. These\n  are needed for the change to be implemented safely.\n\n## Communication\n\nWe use [Slack](https://www.ory.sh/chat). You are welcome to drop in and ask\nquestions, discuss bugs and feature requests, talk to other users of Ory, etc.\n\nCheck out [Ory ladon Discussions](https://github.com/orgs/ory/discussions). This is a great place for\nin-depth discussions and lots of code examples, logs and similar data.\n\nYou can also join our community calls if you want to speak to the Ory team\ndirectly or ask some questions. You can find more info and participate in\n[Slack](https://www.ory.sh/chat) in the #community-call channel.\n\nIf you want to receive regular notifications about updates to Ory ladon,\nconsider joining the mailing list. We will _only_ send you vital information on\nthe projects that you are interested in.\n\nAlso, [follow us on Twitter](https://twitter.com/orycorp).\n\n## Contribute examples\n\nOne of the most impactful ways to contribute is by adding examples. You can find\nan overview of examples using Ory services on the\n[documentation examples page](https://www.ory.sh/docs/examples). Source code for\nexamples can be found in most cases in the\n[ory/examples](https://github.com/ory/examples) repository.\n\n_If you would like to contribute a new example, we would love to hear from you!_\n\nPlease [open an issue](https://github.com/ory/examples/issues/new/choose) to\ndescribe your example before you start working on it. We would love to provide\nguidance to make for a pleasant contribution experience. Go through this\nchecklist to contribute an example:\n\n1. Create a GitHub issue proposing a new example and make sure it's different\n   from an existing one.\n1. Fork the repo and create a feature branch off of `master` so that changes do\n   not get mixed up.\n1. Add a descriptive prefix to commits. This ensures a uniform commit history\n   and helps structure the changelog. Please refer to this\n   [Convential Commits configuration](https://github.com/ory/ladon/blob/master/.github/workflows/conventional_commits.yml)\n   for the list of accepted prefixes. You can read more about the Conventional\n   Commit specification\n   [at their site](https://www.conventionalcommits.org/en/v1.0.0/).\n1. Create a `README.md` that explains how to use the example. (Use\n   [the README template](https://github.com/ory/examples/blob/master/_common/README.md)).\n1. Open a pull request and maintainers will review and merge your example.\n\n## Contribute code\n\nUnless you are fixing a known bug, we **strongly** recommend discussing it with\nthe core team via a GitHub issue or [in our chat](https://www.ory.sh/chat)\nbefore getting started to ensure your work is consistent with Ory ladon's\nroadmap and architecture.\n\nAll contributions are made via pull requests. To make a pull request, you will\nneed a GitHub account; if you are unclear on this process, see GitHub's\ndocumentation on [forking](https://help.github.com/articles/fork-a-repo) and\n[pull requests](https://help.github.com/articles/using-pull-requests). Pull\nrequests should be targeted at the `master` branch. Before creating a pull\nrequest, go through this checklist:\n\n1. Create a feature branch off of `master` so that changes do not get mixed up.\n1. [Rebase](http://git-scm.com/book/en/Git-Branching-Rebasing) your local\n   changes against the `master` branch.\n1. Run the full project test suite with the `go test -tags sqlite ./...` (or\n   equivalent) command and confirm that it passes.\n1. Run `make format`\n1. Add a descriptive prefix to commits. This ensures a uniform commit history\n   and helps structure the changelog. Please refer to this\n   [Convential Commits configuration](https://github.com/ory/ladon/blob/master/.github/workflows/conventional_commits.yml)\n   for the list of accepted prefixes. You can read more about the Conventional\n   Commit specification\n   [at their site](https://www.conventionalcommits.org/en/v1.0.0/).\n\nIf a pull request is not ready to be reviewed yet\n[it should be marked as a \"Draft\"](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/changing-the-stage-of-a-pull-request).\n\nBefore your contributions can be reviewed you need to sign our\n[Contributor License Agreement](https://cla-assistant.io/ory/ladon).\n\nThis agreement defines the terms under which your code is contributed to Ory.\nMore specifically it declares that you have the right to, and actually do, grant\nus the rights to use your contribution. You can see the Apache 2.0 license under\nwhich our projects are published\n[here](https://github.com/ory/meta/blob/master/LICENSE).\n\nWhen pull requests fail the automated testing stages (for example unit or E2E\ntests), authors are expected to update their pull requests to address the\nfailures until the tests pass.\n\nPull requests eligible for review\n\n1. follow the repository's code formatting conventions;\n2. include tests that prove that the change works as intended and does not add\n   regressions;\n3. document the changes in the code and/or the project's documentation;\n4. pass the CI pipeline;\n5. have signed our\n   [Contributor License Agreement](https://cla-assistant.io/ory/ladon);\n6. include a proper git commit message following the\n   [Conventional Commit Specification](https://www.conventionalcommits.org/en/v1.0.0/).\n\nIf all of these items are checked, the pull request is ready to be reviewed and\nyou should change the status to \"Ready for review\" and\n[request review from a maintainer](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/requesting-a-pull-request-review).\n\nReviewers will approve the pull request once they are satisfied with the patch.\n\n## Contribute documentation\n\nPlease provide documentation when changing, removing, or adding features. All\nOry Documentation resides in the\n[Ory documentation repository](https://github.com/ory/docs/). For further\ninstructions please head over to the Ory Documentation\n[README.md](https://github.com/ory/docs/blob/master/README.md).\n\n## Disclosing vulnerabilities\n\nPlease disclose vulnerabilities exclusively to\n[security@ory.sh](mailto:security@ory.sh). Do not use GitHub issues.\n\n## Code style\n\nPlease run `make format` to format all source code following the Ory standard.\n\n### Working with forks\n\n```bash\n# First you clone the original repository\ngit clone git@github.com:ory/ory/ladon.git\n\n# Next you add a git remote that is your fork:\ngit remote add fork git@github.com:<YOUR-GITHUB-USERNAME-HERE>/ory/ladon.git\n\n# Next you fetch the latest changes from origin for master:\ngit fetch origin\ngit checkout master\ngit pull --rebase\n\n# Next you create a new feature branch off of master:\ngit checkout my-feature-branch\n\n# Now you do your work and commit your changes:\ngit add -A\ngit commit -a -m \"fix: this is the subject line\" -m \"This is the body line. Closes #123\"\n\n# And the last step is pushing this to your fork\ngit push -u fork my-feature-branch\n```\n\nNow go to the project's GitHub Pull Request page and click \"New pull request\"\n\n## Conduct\n\nWhether you are a regular contributor or a newcomer, we care about making this\ncommunity a safe place for you and we've got your back.\n\n[Ory Community Code of Conduct](https://github.com/ory/ladon/blob/master/CODE_OF_CONDUCT.md)\n\nWe welcome discussion about creating a welcoming, safe, and productive\nenvironment for the community. If you have any questions, feedback, or concerns\n[please let us know](https://www.ory.sh/chat).\n"
        },
        {
          "name": "HISTORY.md",
          "type": "blob",
          "size": 3.2529296875,
          "content": "# History of breaking changes\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n\n\n- [0.7.0](#070)\n- [0.6.0](#060)\n  - [New location](#new-location)\n  - [Deprecating Redis and RethinkDB](#deprecating-redis-and-rethinkdb)\n  - [New packages](#new-packages)\n  - [IMPORTANT: SQL Changes](#important-sql-changes)\n  - [Manager API Changes](#manager-api-changes)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n## 1.0.0\n\nThe SQL storage implementation has been removed. The reason being that it had serious scalability issues which could\ncause trouble in high-throughput environments.\n\nEverything else stays the same, ORY Ladon is now feature-complete.\n\n## 0.8.0\n\nManagers now must implement `Update(policy Policy) error`.\n\n## 0.7.0\n\nVersion 0.7.0 includes two minor BC breaks in the SQLManager. The method signature `CreateSchemas() ( error)`\nwas changed to `CreateSchemas(schema, table string) (int, error)` where int now returns the number of migrations applied.\nArguments `schema` and `table` are passed to the migration script, defining which schema and table name should be used\nto store and look up migration plans.\n\nTo keep the default values from the migrate package, use `CreateSchemas(\"\", \"\")`. It is safe to reapply all migration\ncommands with this version - implying that you can choose an arbitrary name and it won't break your schema.\n\n## 0.6.0\n\nVersion 0.6.0 includes some larger BC breaks. This version focuses on various\nperformance boosts for both in-memory and SQL adapters, removes some technical debt\nand restructures the repository.\n\n### New location\n\nThe location of this library changed from `github.com/ory-am/ladon` to `github.com/ory/ladon`.\n\n### Deprecating Redis and RethinkDB\n\nRedis and RethinkDB are no longer maintained by ORY and were moved to\n[ory/ladon-community](https://github.com/ory/ladon-community). The adapters had various\nbugs and performance issues which is why they were removed from the official repository.\n\n### New packages\n\nThe SQLManager and MemoryManager moved to their own packages in `ladon/manager/sql` and `ladon/manager/memory`.\nThis change was made to avoid pulling dependencies that are not required by the user.\n\n### IMPORTANT: SQL Changes\n\nThe SQLManager was rewritten completely. Now, the database is 3NF (normalized) and includes\nvarious improvements over the previous, naive adapter. The greatest challenge is matching\nregular expressions within SQL databases, which causes significant overhead.\n\nWhile there is an auto-migration for the schema, the data **is not automatically transferred to\nthe new schema**.\n\nHowever, we provided a migration helper. For usage, check out\n[xxx_manager_sql_migrator_test.go](xxx_manager_sql_migrator_test.go) or this short example:\n\n```go\nvar db = getSqlDatabaseFromSomewhere()\ns := NewSQLManager(db, nil)\n\nif err := s.CreateSchemas(); err != nil {\n    log.Fatalf(\"Could not create mysql schema: %v\", err)\n}\n\nmigrator := &SQLManagerMigrateFromMajor0Minor6ToMajor0Minor7{\n    DB:db,\n    SQLManager:s,\n}\n\nerr := migrator.Migrate()\n```\n\nPlease run this migrator **only once and make back ups before you run it**.\n\n### Manager API Changes\n\n`Manager.FindPoliciesForSubject` is now `Manager.FindRequestCandidates`\n"
        },
        {
          "name": "ISSUE_TEMPLATE.md",
          "type": "blob",
          "size": 0.3740234375,
          "content": "Please use issues only to raise potential bugs or request features. For everything else ask\nthe [ORY Community](https://community.ory.am/) or join the [ORY Chat](https://gitter.im/ory-am/hydra).\n\nIf you think you found a security vulnerability, please refrain from posting it publicly on the forums, the chat, or GitHub\nand send us an email to [hi@ory.am](mailto:hi@ory.am) instead.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 11.0908203125,
          "content": "                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n   Copyright [yyyy] [name of copyright owner]\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 0.046875,
          "content": "Aeneas Rekkas <aeneas@ory.am> (github: arekkas)\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.8603515625,
          "content": "<h1 align=\"center\"><img src=\"./docs/images/banner_ladon.png\" alt=\"ORY Ladon - Policy-based Access Control\"></h1>\n\n[![Join the chat at https://www.ory.sh/chat](https://img.shields.io/badge/join-chat-00cc99.svg)](https://www.ory.sh/chat)\n[![Join newsletter](https://img.shields.io/badge/join-newsletter-00cc99.svg)](https://www.ory.sh/l/sign-up-newsletter)\n\n[![Build Status](https://travis-ci.org/ory/ladon.svg?branch=master)](https://travis-ci.org/ory/ladon)\n[![Coverage Status](https://coveralls.io/repos/ory/ladon/badge.svg?branch=master&service=github)](https://coveralls.io/github/ory/ladon?branch=master)\n[![Go Report Card](https://goreportcard.com/badge/github.com/ory/ladon)](https://goreportcard.com/report/github.com/ory/ladon)\n[![GoDoc](https://godoc.org/github.com/ory/ladon?status.png)](https://godoc.org/github.com/ory/ladon)\n\n[Ladon](https://en.wikipedia.org/wiki/Ladon_%28mythology%29) is the serpent dragon protecting your resources.\n\nLadon is a library written in [Go](https://golang.org) for access control policies, similar to [Role Based Access Control](https://en.wikipedia.org/wiki/Role-based_access_control)\nor [Access Control Lists](https://en.wikipedia.org/wiki/Access_control_list).\nIn contrast to [ACL](https://en.wikipedia.org/wiki/Access_control_list) and [RBAC](https://en.wikipedia.org/wiki/Role-based_access_control)\nyou get fine-grained access control with the ability to answer questions in complex environments such as multi-tenant or distributed applications\nand large organizations. Ladon is inspired by [AWS IAM Policies](http://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html).\n\nLadon officially ships with an exemplary in-memory storage implementations.\nCommunity-supported adapters are available for [CockroachDB](https://github.com/wehco/ladon-crdb).\n\nLadon is now considered stable.\n\n---\n\nORY builds solutions for better internet security and accessibility. We have a couple more projects you might enjoy:\n\n* **[Hydra](https://github.com/ory/hydra)**, a security-first open source OAuth2 and OpenID Connect server for new and existing infrastructures that uses Ladon for access control.\n* **[ORY Editor](https://github.com/ory/editor)**, an extensible, modern WYSI editor for the web written in React.\n* **[Fosite](https://github.com/ory/fosite)**, an extensible security first OAuth 2.0 and OpenID Connect SDK for Go.\n* **[Dockertest](https://github.com/ory/dockertest)**: Write better integration tests with dockertest!\n\n---\n\n<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**\n\n- [Installation](#installation)\n- [Concepts](#concepts)\n- [Usage](#usage)\n  - [Policies](#policies)\n    - [Conditions](#conditions)\n      - [CIDR Condition](#cidr-condition)\n      - [String Equal Condition](#string-equal-condition)\n      - [Boolean Condition](#boolean-condition)\n      - [String Match Condition](#string-match-condition)\n      - [Subject Condition](#subject-condition)\n      - [String Pairs Equal Condition](#string-pairs-equal-condition)\n      - [Resource Contains Condition](#resource-contains-condition)\n      - [Adding Custom Conditions](#adding-custom-conditions)\n    - [Persistence](#persistence)\n  - [Access Control (Warden)](#access-control-warden)\n  - [Audit Log (Warden)](#audit-log-warden)\n  - [Metrics](#metrics)\n- [Limitations](#limitations)\n  - [Regular expressions](#regular-expressions)\n- [Examples](#examples)\n- [Good to know](#good-to-know)\n- [Useful commands](#useful-commands)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\nLadon utilizes ory-am/dockertest for tests.\nPlease refer to [ory-am/dockertest](https://github.com/ory-am/dockertest) for more information of how to setup testing environment.\n\n## Installation\n\nThis library works with Go 1.11+.\n\n```\nexport GO111MODULE=on\ngo get github.com/ory/ladon\n```\n\nLadon uses [semantic versioning](http://semver.org/) and versions beginning with zero (`0.1.2`) might introduce backwards compatibility\nbreaks with [each minor version](http://semver.org/#how-should-i-deal-with-revisions-in-the-0yz-initial-development-phase).\n\n## Concepts\n\nLadon is an access control library that answers the question:\n\n> **Who** is **able** to do **what** on **something** given some **context**\n\n* **Who**: An arbitrary unique subject name, for example \"ken\" or \"printer-service.mydomain.com\".\n* **Able**: The effect which can be either \"allow\" or \"deny\".\n* **What**: An arbitrary action name, for example \"delete\", \"create\" or \"scoped:action:something\".\n* **Something**: An arbitrary unique resource name, for example \"something\", \"resources.articles.1234\" or some uniform\n    resource name like \"urn:isbn:3827370191\".\n* **Context**: The current context containing information about the environment such as the IP Address,\n    request date, the resource owner name, the department ken is working in or any other information you want to pass along.\n    (optional)\n\nTo decide what the answer is, Ladon uses policy documents which can be represented as JSON\n\n```json\n{\n  \"description\": \"One policy to rule them all.\",\n  \"subjects\": [\"users:<peter|ken>\", \"users:maria\", \"groups:admins\"],\n  \"actions\" : [\"delete\", \"<create|update>\"],\n  \"effect\": \"allow\",\n  \"resources\": [\n    \"resources:articles:<.*>\",\n    \"resources:printer\"\n  ],\n  \"conditions\": {\n    \"remoteIP\": {\n        \"type\": \"CIDRCondition\",\n        \"options\": {\n            \"cidr\": \"192.168.0.1/16\"\n        }\n    }\n  }\n}\n```\n\nand can answer access requests that look like:\n\n```json\n{\n  \"subject\": \"users:peter\",\n  \"action\" : \"delete\",\n  \"resource\": \"resources:articles:ladon-introduction\",\n  \"context\": {\n    \"remoteIP\": \"192.168.0.5\"\n  }\n}\n```\n\nHowever, Ladon does not come with a HTTP or server implementation. It does not restrict JSON either. We believe that it is your job to decide\nif you want to use Protobuf, RESTful, HTTP, AMQP, or some other protocol. It's up to you to write the server!\n\nThe following example should give you an idea what a RESTful flow *could* look like. Initially we create a policy by\nPOSTing it to an artificial HTTP endpoint:\n\n```\n> curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      -d@- \\\n      \"https://my-ladon-implementation.localhost/policies\" <<EOF\n        {\n          \"description\": \"One policy to rule them all.\",\n          \"subjects\": [\"users:<peter|ken>\", \"users:maria\", \"groups:admins\"],\n          \"actions\" : [\"delete\", \"<create|update>\"],\n          \"effect\": \"allow\",\n          \"resources\": [\n            \"resources:articles:<.*>\",\n            \"resources:printer\"\n          ],\n          \"conditions\": {\n            \"remoteIP\": {\n                \"type\": \"CIDRCondition\",\n                \"options\": {\n                    \"cidr\": \"192.168.0.1/16\"\n                }\n            }\n          }\n        }\n  EOF\n```\n\nThen we test if \"peter\" (ip: \"192.168.0.5\") is allowed to \"delete\" the \"ladon-introduction\" article:\n\n```\n> curl \\\n      -X POST \\\n      -H \"Content-Type: application/json\" \\\n      -d@- \\\n      \"https://my-ladon-implementation.localhost/warden\" <<EOF\n        {\n          \"subject\": \"users:peter\",\n          \"action\" : \"delete\",\n          \"resource\": \"resources:articles:ladon-introduction\",\n          \"context\": {\n            \"remoteIP\": \"192.168.0.5\"\n          }\n        }\n  EOF\n\n{\n    \"allowed\": true\n}\n```\n\n## Usage\n\nWe already discussed two essential parts of Ladon: policies and access control requests. Let's take a closer look at those two.\n\n### Policies\n\nPolicies are the basis for access control decisions. Think of them as a set of rules. In this library, policies\nare abstracted as the `ladon.Policy` interface, and Ladon comes with a standard implementation of this interface\nwhich is `ladon.DefaultPolicy`. Creating such a policy could look like:\n\n```go\nimport \"github.com/ory/ladon\"\n\nvar pol = &ladon.DefaultPolicy{\n\t// A required unique identifier. Used primarily for database retrieval.\n\tID: \"68819e5a-738b-41ec-b03c-b58a1b19d043\",\n\n\t// A optional human readable description.\n\tDescription: \"something humanly readable\",\n\n\t// A subject can be an user or a service. It is the \"who\" in \"who is allowed to do what on something\".\n\t// As you can see here, you can use regular expressions inside < >.\n\tSubjects: []string{\"max\", \"peter\", \"<zac|ken>\"},\n\n\t// Which resources this policy affects.\n\t// Again, you can put regular expressions in inside < >.\n\tResources: []string{\n            \"myrn:some.domain.com:resource:123\", \"myrn:some.domain.com:resource:345\",\n            \"myrn:something:foo:<.+>\", \"myrn:some.domain.com:resource:<(?!protected).*>\",\n            \"myrn:some.domain.com:resource:<[[:digit:]]+>\",\n        },\n\n\t// Which actions this policy affects. Supports RegExp\n\t// Again, you can put regular expressions in inside < >.\n\tActions: []string{\"<create|delete>\", \"get\"},\n\n\t// Should access be allowed or denied?\n\t// Note: If multiple policies match an access request, ladon.DenyAccess will always override ladon.AllowAccess\n\t// and thus deny access.\n\tEffect: ladon.AllowAccess,\n\n\t// Under which conditions this policy is \"active\".\n\tConditions: ladon.Conditions{\n\t\t// In this example, the policy is only \"active\" when the requested subject is the owner of the resource as well.\n\t\t\"resourceOwner\": &ladon.EqualsSubjectCondition{},\n\n\t\t// Additionally, the policy will only match if the requests remote ip address matches address range 127.0.0.1/32\n\t\t\"remoteIPAddress\": &ladon.CIDRCondition{\n\t\t\tCIDR: \"127.0.0.1/32\",\n\t\t},\n\t},\n}\n```\n\n#### Conditions\n\nConditions are functions returning true or false given a context. Because conditions implement logic, they must\nbe programmed. Adding conditions to a policy consist of two parts, a key name and an implementation of `ladon.Condition`:\n\n```go\n// StringEqualCondition is an exemplary condition.\ntype StringEqualCondition struct {\n\tEquals string `json:\"equals\"`\n}\n\n// Fulfills returns true if the given value is a string and is the\n// same as in StringEqualCondition.Equals\nfunc (c *StringEqualCondition) Fulfills(value interface{}, _ *ladon.Request) bool {\n\ts, ok := value.(string)\n\n\treturn ok && s == c.Equals\n}\n\n// GetName returns the condition's name.\nfunc (c *StringEqualCondition) GetName() string {\n\treturn \"StringEqualCondition\"\n}\n\nvar pol = &ladon.DefaultPolicy{\n    // ...\n    Conditions: ladon.Conditions{\n        \"some-arbitrary-key\": &StringEqualCondition{\n            Equals: \"the-value-should-be-this\"\n        }\n    },\n}\n```\n\nThe default implementation of `Policy` supports JSON un-/marshalling. In JSON, this policy would look like:\n\n```json\n{\n  \"conditions\": {\n    \"some-arbitrary-key\": {\n        \"type\": \"StringEqualCondition\",\n        \"options\": {\n            \"equals\": \"the-value-should-be-this\"\n        }\n    }\n  }\n}\n```\n\nAs you can see, `type` is the value that `StringEqualCondition.GetName()` is returning and `options` is used to\nset the value of `StringEqualCondition.Equals`.\n\nThis condition is fulfilled by (we will cover the warden in the next section)\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n        \"some-arbitrary-key\": \"the-value-should-be-this\",\n    },\n}\n```\n\nbut not by\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n        \"some-arbitrary-key\": \"some other value\",\n    },\n}\n```\n\nand neither by:\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n        \"same value but other key\": \"the-value-should-be-this\",\n    },\n}\n```\n\nLadon ships with a couple of default conditions:\n\n##### [CIDR Condition](condition_cidr.go)\n\nThe CIDR condition matches CIDR IP Ranges. Using this condition would look like this in JSON:\n\n```json\n{\n    \"conditions\": {\n        \"remoteIPAddress\": {\n            \"type\": \"CIDRCondition\",\n            \"options\": {\n                \"cidr\": \"192.168.0.1/16\"\n            }\n        }\n    }\n}\n```\n\nand in Go:\n\n```go\nvar pol = &ladon.DefaultPolicy{\n    Conditions: ladon.Conditions{\n        \"remoteIPAddress\": &ladon.CIDRCondition{\n            CIDR: \"192.168.0.1/16\",\n        },\n    },\n}\n```\n\nIn this case, we expect that the context of an access request contains a field `\"remoteIpAddress\"` matching\nthe CIDR `\"192.168.0.1/16\"`, for example `\"192.168.0.5\"`.\n\n\n##### [String Equal Condition](condition_string_equal.go)\n\nChecks if the value passed in the access request's context is identical with the string that was given initially\n\n```go\nvar pol = &ladon.DefaultPolicy{\n    Conditions: ladon.Conditions{\n        \"some-arbitrary-key\": &ladon.StringEqualCondition{\n            Equals: \"the-value-should-be-this\"\n        }\n    },\n}\n```\n\nand would match in the following case:\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n         \"some-arbitrary-key\": \"the-value-should-be-this\",\n    },\n}\n```\n\n##### [Boolean Condition](condition_boolean.go)\n\nChecks if the boolean value passed in the access request's context is identical with the expected boolean value in the policy\n```go\nvar pol = &ladon.DefaultPolicy{\n    Conditions: ladon.Conditions{\n        \"some-arbitrary-key\": &ladon.BooleanCondition{\n            BooleanValue: true,\n        }\n    },\n}\n```\n\nand would match in the following case:\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n        \"some-arbitrary-key\": true,\n    },\n})\n```\n\nThis condition type is particularly useful if you need to assert a policy dynamically on resources for multiple subjects. For example, consider\nif you wanted to enforce policy that only allows individuals that own a resource to view that resource. You'd have to be able to create a Ladon\npolicy that permits access to every resource for every subject that enters your system.\n\nWith the Boolean Condition type, you can use conditional logic at runtime to create a match for a policy's condition.\n\n##### [String Match Condition](condition_string_match.go)\n\nChecks if the value passed in the access request's context matches the regular expression that was given initially\n\n```go\nvar pol = &ladon.DefaultPolicy{\n    Conditions: ladon.Conditions{\n      \"some-arbitrary-key\": &ladon.StringMatchCondition{\n          Matches: \"regex-pattern-here.+\"\n      }\n    }\n}\n```\n\nand would match in the following case:\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n          \"some-arbitrary-key\": \"regex-pattern-here111\"\n    }\n  }\n})\n```\n\n##### [Subject Condition](condition_subject_equal.go)\n\nChecks if the access request's subject is identical with the string that was given initially\n\n```go\nvar pol = &ladon.DefaultPolicy{\n    Conditions: ladon.Conditions{\n        \"some-arbitrary-key\": &ladon.EqualsSubjectCondition{}\n    },\n}\n```\n\nand would match\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Subject: \"peter\",\n    Context: ladon.Context{\n         \"some-arbitrary-key\": \"peter\",\n    },\n}\n```\n\nbut not:\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Subject: \"peter\",\n    Context: ladon.Context{\n         \"some-arbitrary-key\": \"max\",\n    },\n}\n```\n\n##### [String Pairs Equal Condition](condition_string_pairs_equal.go)\n\nChecks if the value passed in the access request's context contains two-element arrays\nand that both elements in each pair are equal.\n\n```go\nvar pol = &ladon.DefaultPolicy{\n    Conditions: ladon.Conditions{\n        \"some-arbitrary-key\": &ladon.StringPairsEqualCondition{}\n    },\n}\n```\n\nand would match\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n         \"some-arbitrary-key\": [\n             [\"some-arbitrary-pair-value\", \"some-arbitrary-pair-value\"],\n             [\"some-other-arbitrary-pair-value\", \"some-other-arbitrary-pair-value\"],\n         ]\n    },\n}\n```\n\nbut not:\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Context: ladon.Context{\n         \"some-arbitrary-key\": [\n             [\"some-arbitrary-pair-value\", \"some-other-arbitrary-pair-value\"],\n         ]\n    },\n}\n```\n\n\n##### [Resource Contains Condition](condition_resource_contains.go)\n\nChecks if the string value passed in the access request's context is present in the resource string.\n\nThe Condition requires a value string and an optional delimiter (needs to match the resource string) to be passed.\n\nA resource could for instance be: `myrn:some.domain.com:resource:123` and `myrn:some.otherdomain.com:resource:123` (the `:` is then considered a delimiter, and used by the condition to be able to separate the resource components from each other) to allow an action to the resources on `myrn:some.otherdomain.com` you could for instance create a resource condition  with\n\n{value: `myrn:some.otherdomain.com`, Delimiter: \":\"}\n\nalternatively:\n\n{value: `myrn:some.otherdomain.com`}\n\n> The delimiter is optional *but needed for* the condition to be able to separate resource string components:\n> i.e. to make sure the value `foo:bar` matches `foo:bar` but not `foo:bara` nor `foo:bara:baz`.\n>\n> That is, a delimiter is necessary to separate:\n>\n> `{value: \"myrn:fo\", delimiter: \":\"}` from `{value: \"myrn:foo\", delimiter: \":\"}` or\n> `{value: \"myid:12\"}` from `{value: \"myid:123\"}`.\n\n\n\nThis condition is fulfilled by this (allow for all resources containing `part:north`):\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Resource: \"rn:city:laholm:part:north\"\n    Context: ladon.Context{\n      delimiter: \":\",\n      value: \"part:north\"\n    },\n}\n```\n\nor ( allow all resources with `city:laholm`)\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Resource: \"rn:city:laholm:part:north\"\n    Context: ladon.Context{\n      delimiter: \":\",\n      value: \"city:laholm\"\n    },\n}\n```\n\nbut not (allow for all resources containing `part:west`, the resource does not contain `part:west`):\n\n```go\nvar err = warden.IsAllowed(&ladon.Request{\n    // ...\n    Resource: \"rn:city:laholm:part:north\"\n    Context: ladon.Context{\n      delimiter: \":\",\n      value: \"part:west\"\n    },\n}\n```\n\n\n##### Adding Custom Conditions\n\nYou can add custom conditions by appending it to `ladon.ConditionFactories`:\n\n```go\nimport \"github.com/ory/ladon\"\n\nfunc main() {\n    // ...\n\n    ladon.ConditionFactories[new(CustomCondition).GetName()] = func() Condition {\n        return new(CustomCondition)\n    }\n\n    // ...\n}\n```\n\n#### Persistence\n\nObviously, creating such a policy is not enough. You want to persist it too. Ladon ships an interface `ladon.Manager` for\nthis purpose. You have to implement that interface for persistence. An exemplary in-memory adapter can be found in\n[./manager/memory/manager_memory.go](./manager/memory/manager_memory.go):\n\nLet's take a look how to instantiate those:\n\n**In-Memory** (officially supported)\n\n```go\nimport (\n\t\"github.com/ory/ladon\"\n\tmanager \"github.com/ory/ladon/manager/memory\"\n)\n\n\nfunc main() {\n\twarden := &ladon.Ladon{\n\t\tManager: manager.NewMemoryManager(),\n\t}\n\terr := warden.Manager.Create(pol)\n\n    // ...\n}\n```\n\n### Access Control (Warden)\n\nNow that we have defined our policies, we can use the warden to check if a request is valid.\n`ladon.Ladon`, which is the default implementation for the `ladon.Warden` interface defines `ladon.Ladon.IsAllowed()` which\nwill return `nil` if the access request can be granted and an error otherwise.\n\n```go\nimport \"github.com/ory/ladon\"\n\nfunc main() {\n    // ...\n\n    err := warden.IsAllowed(&ladon.Request{\n        Subject: \"peter\",\n        Action: \"delete\",\n        Resource: \"myrn:some.domain.com:resource:123\",\n        Context: ladon.Context{\n            \"ip\": \"127.0.0.1\",\n        },\n    })\n    if err != nil {\n        log.Fatal(\"Access denied\")\n    }\n\n    // ...\n}\n```\n\n### Audit Log (Warden)\n\nIn order to keep track of authorization grants and denials, it is possible to attach a `ladon.AuditLogger`.\nThe provided `ladon.AuditLoggerInfo` outputs information about the policies involved when responding to authorization requests.\n\n```go\nimport \"github.com/ory/ladon\"\nimport manager \"github.com/ory/ladon/manager/memory\"\n\nfunc main() {\n\n    warden := ladon.Ladon{\n        Manager: manager.NewMemoryManager(),\n        AuditLogger: &ladon.AuditLoggerInfo{}\n    }\n\n    // ...\n\n```\n\nIt will output to `stderr` by default.\n\n### Metrics\n\nAbility to track authorization grants,denials and errors, it is possible to implement own interface for processing metrics.\n\n```go\ntype prometheusMetrics struct{}\n\nfunc (mtr *prometheusMetrics) RequestDeniedBy(r ladon.Request, p ladon.Policy) {}\nfunc (mtr *prometheusMetrics) RequestAllowedBy(r ladon.Request, policies ladon.Policies) {}\nfunc (mtr *prometheusMetrics) RequestNoMatch(r ladon.Request) {}\nfunc (mtr *prometheusMetrics) RequestProcessingError(r ladon.Request, err error) {}\n\nfunc main() {\n\n    warden := ladon.Ladon{\n        Manager: manager.NewMemoryManager(),\n        Metric:  &prometheusMetrics{},\n    }\n\n    // ...\n```\n\n## Limitations\n\nLadon's limitations are listed here.\n\n### Regular expressions\n\nMatching regular expressions has a complexity of `O(n)` ([except](https://groups.google.com/d/msg/golang-nuts/7qgSDWPIh_E/OHTAm4wRZL0J) lookahead/lookbehind assertions) and databases such as MySQL or Postgres can not\nleverage indexes when parsing regular expressions. Thus, there is considerable overhead when using regular\nexpressions.\n\nWe have implemented various strategies for reducing policy matching time:\n\n1. An LRU cache is used for caching frequently compiled regular expressions. This reduces cpu complexity\nsignificantly for memory manager implementations.\n2. The SQL schema is 3NF normalized.\n3. Policies, subjects and actions are stored uniquely, reducing the total number of rows.\n4. Only one query per look up is executed.\n5. If no regular expression is used, a simple equal match is done in SQL back-ends.\n\nYou will get the best performance with the in-memory manager. The SQL adapters perform about 1000:1 compared to the in-memory solution. Please note that these tests where in laboratory environments with Docker, without an SSD, and single-threaded. You might get better results on your system. We are thinking about introducing simple cache strategies such as LRU with a maximum age to further reduce runtime complexity.\n\nWe are also considering to offer different matching strategies (e.g. wildcard match) in the future, which will perform better\nwith SQL databases. If you have ideas or suggestions, leave us an issue.\n\n## Examples\n\nCheck out [ladon_test.go](ladon_test.go) which includes a couple of policies and tests cases. You can run the code with `go test -run=TestLadon -v .`\n\n## Good to know\n\n* All checks are *case sensitive* because subject values could be case sensitive IDs.\n* If `ladon.Ladon` is not able to match a policy with the request, it will default to denying the request and return an error.\n\nLadon does not use reflection for matching conditions to their appropriate structs due to security considerations.\n\n## Useful commands\n\n**Create mocks**\n```sh\nmockgen -package ladon_test -destination manager_mock_test.go github.com/ory/ladon Manager\n```\n\n## Third Party Libraries\nBy implementing the warden.Manager it is possible to create your own adapters to persist data in a datastore of your choice. Below are a list of third party implementations.\n\n- [Redis and RethinkDB](https://github.com/ory/ladon-community)\n- [CockroachDB](https://github.com/dwin/ladon-crdb)\n- [sql.DB](https://github.com/wirepair/ladonsqlmanager)\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 2.4453125,
          "content": "<!-- AUTO-GENERATED, DO NOT EDIT! -->\n<!-- Please edit the original at https://github.com/ory/meta/blob/master/templates/repository/common/SECURITY.md -->\n\n# Ory Security Policy\n\nThis policy outlines Ory's security commitments and practices for users across\ndifferent licensing and deployment models.\n\nTo learn more about Ory's security service level agreements (SLAs) and\nprocesses, please [contact us](https://www.ory.sh/contact/).\n\n## Ory Network Users\n\n- **Security SLA:** Ory addresses vulnerabilities in the Ory Network according\n  to the following guidelines:\n  - Critical: Typically addressed within 14 days.\n  - High: Typically addressed within 30 days.\n  - Medium: Typically addressed within 90 days.\n  - Low: Typically addressed within 180 days.\n  - Informational: Addressed as necessary.  \n    These timelines are targets and may vary based on specific circumstances.\n- **Release Schedule:** Updates are deployed to the Ory Network as\n  vulnerabilities are resolved.\n- **Version Support:** The Ory Network always runs the latest version, ensuring\n  up-to-date security fixes.\n\n## Ory Enterprise License Customers\n\n- **Security SLA:** Ory addresses vulnerabilities based on their severity:\n  - Critical: Typically addressed within 14 days.\n  - High: Typically addressed within 30 days.\n  - Medium: Typically addressed within 90 days.\n  - Low: Typically addressed within 180 days.\n  - Informational: Addressed as necessary.  \n    These timelines are targets and may vary based on specific circumstances.\n- **Release Schedule:** Updates are made available as vulnerabilities are\n  resolved. Ory works closely with enterprise customers to ensure timely updates\n  that align with their operational needs.\n- **Version Support:** Ory may provide security support for multiple versions,\n  depending on the terms of the enterprise agreement.\n\n## Apache 2.0 License Users\n\n- **Security SLA:** Ory does not provide a formal SLA for security issues under\n  the Apache 2.0 License.\n- **Release Schedule:** Releases prioritize new functionality and include fixes\n  for known security vulnerabilities at the time of release. While major\n  releases typically occur one to two times per year, Ory does not guarantee a\n  fixed release schedule.\n- **Version Support:** Security patches are only provided for the latest release\n  version.\n\n## Reporting a Vulnerability\n\nFor details on how to report security vulnerabilities, visit our\n[security policy documentation](https://www.ory.sh/docs/ecosystem/security).\n"
        },
        {
          "name": "audit_logger.go",
          "type": "blob",
          "size": 1.0595703125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// AuditLogger tracks denied and granted authorizations.\ntype AuditLogger interface {\n\tLogRejectedAccessRequest(ctx context.Context, request *Request, pool Policies, deciders Policies)\n\tLogGrantedAccessRequest(ctx context.Context, request *Request, pool Policies, deciders Policies)\n}\n"
        },
        {
          "name": "audit_logger_info.go",
          "type": "blob",
          "size": 1.923828125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\n// AuditLoggerInfo outputs information about granting or rejecting policies.\ntype AuditLoggerInfo struct {\n\tLogger *log.Logger\n}\n\nfunc (a *AuditLoggerInfo) logger() *log.Logger {\n\tif a.Logger == nil {\n\t\ta.Logger = log.New(os.Stderr, \"\", log.LstdFlags)\n\t}\n\treturn a.Logger\n}\n\nfunc (a *AuditLoggerInfo) LogRejectedAccessRequest(ctx context.Context, r *Request, p Policies, d Policies) {\n\tif len(d) > 1 {\n\t\tallowed := joinPoliciesNames(d[0 : len(d)-1])\n\t\tdenied := d[len(d)-1].GetID()\n\t\ta.logger().Printf(\"policies %s allow access, but policy %s forcefully denied it\", allowed, denied)\n\t} else if len(d) == 1 {\n\t\tdenied := d[len(d)-1].GetID()\n\t\ta.logger().Printf(\"policy %s forcefully denied the access\", denied)\n\t} else {\n\t\ta.logger().Printf(\"no policy allowed access\")\n\t}\n}\n\nfunc (a *AuditLoggerInfo) LogGrantedAccessRequest(ctx context.Context, r *Request, p Policies, d Policies) {\n\ta.logger().Printf(\"policies %s allow access\", joinPoliciesNames(d))\n}\n\nfunc joinPoliciesNames(policies Policies) string {\n\tnames := []string{}\n\tfor _, policy := range policies {\n\t\tnames = append(names, policy.GetID())\n\t}\n\treturn strings.Join(names, \", \")\n}\n"
        },
        {
          "name": "audit_logger_noop.go",
          "type": "blob",
          "size": 1.1357421875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// AuditLoggerNoOp is the default AuditLogger, that tracks nothing.\ntype AuditLoggerNoOp struct{}\n\nfunc (*AuditLoggerNoOp) LogRejectedAccessRequest(ctx context.Context, r *Request, p Policies, d Policies) {\n}\nfunc (*AuditLoggerNoOp) LogGrantedAccessRequest(ctx context.Context, r *Request, p Policies, d Policies) {\n}\n\nvar DefaultAuditLogger = &AuditLoggerNoOp{}\n"
        },
        {
          "name": "audit_logger_test.go",
          "type": "blob",
          "size": 2.42578125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"log\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\n\t. \"github.com/ory/ladon\"\n\t. \"github.com/ory/ladon/manager/memory\"\n)\n\nfunc TestAuditLogger(t *testing.T) {\n\tvar output bytes.Buffer\n\n\twarden := &Ladon{\n\t\tManager: NewMemoryManager(),\n\t\tAuditLogger: &AuditLoggerInfo{\n\t\t\tLogger: log.New(&output, \"\", 0),\n\t\t},\n\t}\n\n\tctx := context.Background()\n\n\twarden.Manager.Create(ctx, &DefaultPolicy{\n\t\tID:        \"no-updates\",\n\t\tSubjects:  []string{\"<.*>\"},\n\t\tActions:   []string{\"update\"},\n\t\tResources: []string{\"<.*>\"},\n\t\tEffect:    DenyAccess,\n\t})\n\twarden.Manager.Create(ctx, &DefaultPolicy{\n\t\tID:        \"yes-deletes\",\n\t\tSubjects:  []string{\"<.*>\"},\n\t\tActions:   []string{\"delete\"},\n\t\tResources: []string{\"<.*>\"},\n\t\tEffect:    AllowAccess,\n\t})\n\twarden.Manager.Create(ctx, &DefaultPolicy{\n\t\tID:        \"no-bob\",\n\t\tSubjects:  []string{\"bob\"},\n\t\tActions:   []string{\"delete\"},\n\t\tResources: []string{\"<.*>\"},\n\t\tEffect:    DenyAccess,\n\t})\n\n\tr := &Request{}\n\tassert.NotNil(t, warden.IsAllowed(ctx, r))\n\tassert.Equal(t, \"no policy allowed access\\n\", output.String())\n\n\toutput.Reset()\n\n\tr = &Request{\n\t\tAction: \"update\",\n\t}\n\tassert.NotNil(t, warden.IsAllowed(ctx, r))\n\tassert.Equal(t, \"policy no-updates forcefully denied the access\\n\", output.String())\n\n\toutput.Reset()\n\n\tr = &Request{\n\t\tSubject: \"bob\",\n\t\tAction:  \"delete\",\n\t}\n\tassert.NotNil(t, warden.IsAllowed(ctx, r))\n\tassert.Equal(t, \"policies yes-deletes allow access, but policy no-bob forcefully denied it\\n\", output.String())\n\n\toutput.Reset()\n\n\tr = &Request{\n\t\tSubject: \"alice\",\n\t\tAction:  \"delete\",\n\t}\n\tassert.Nil(t, warden.IsAllowed(ctx, r))\n\tassert.Equal(t, \"policies yes-deletes allow access\\n\", output.String())\n}\n"
        },
        {
          "name": "benchmark_warden_test.go",
          "type": "blob",
          "size": 3.1044921875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"testing\"\n\n\t\"github.com/pborman/uuid\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/ladon\"\n\t\"github.com/ory/ladon/manager/memory\"\n)\n\nfunc benchmarkLadon(i int, b *testing.B, warden *ladon.Ladon) {\n\t//var concurrency = 30\n\t//var sem = make(chan bool, concurrency)\n\t//\n\t//for _, pol := range generatePolicies(i) {\n\t//\tsem <- true\n\t//\tgo func(pol ladon.Policy) {\n\t//\t\tdefer func() { <-sem }()\n\t//\t\tif err := warden.Manager.Create(pol); err != nil {\n\t//\t\t\tb.Logf(\"Got error from warden.Manager.Create: %s\", err)\n\t//\t\t}\n\t//\t}(pol)\n\t//}\n\t//\n\t//for i := 0; i < cap(sem); i++ {\n\t//\tsem <- true\n\t//}\n\n\tctx := context.Background()\n\n\tfor _, pol := range generatePolicies(i) {\n\t\tif err := warden.Manager.Create(ctx, pol); err != nil {\n\t\t\tb.Logf(\"Got error from warden.Manager.Create: %s\", err)\n\t\t}\n\t}\n\n\tb.ResetTimer()\n\tvar err error\n\tfor n := 0; n < b.N; n++ {\n\t\tif err = warden.IsAllowed(ctx, &ladon.Request{\n\t\t\tSubject:  \"5\",\n\t\t\tAction:   \"bar\",\n\t\t\tResource: \"baz\",\n\t\t}); errors.Cause(err) == ladon.ErrRequestDenied || errors.Cause(err) == ladon.ErrRequestForcefullyDenied || err == nil {\n\t\t} else {\n\t\t\tb.Logf(\"Got error from warden: %s\", err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLadon(b *testing.B) {\n\tfor _, num := range []int{10, 100, 1000, 10000, 100000, 1000000} {\n\t\tb.Run(fmt.Sprintf(\"store=memory/policies=%d\", num), func(b *testing.B) {\n\t\t\tmatcher := ladon.NewRegexpMatcher(4096)\n\t\t\tbenchmarkLadon(num, b, &ladon.Ladon{\n\t\t\t\tManager: memory.NewMemoryManager(),\n\t\t\t\tMatcher: matcher,\n\t\t\t})\n\t\t})\n\n\t\tb.Run(fmt.Sprintf(\"store=mysql/policies=%d\", num), func(b *testing.B) {\n\t\t\tbenchmarkLadon(num, b, &ladon.Ladon{\n\t\t\t\tManager: managers[\"mysql\"],\n\t\t\t\tMatcher: ladon.NewRegexpMatcher(4096),\n\t\t\t})\n\t\t})\n\n\t\tb.Run(fmt.Sprintf(\"store=postgres/policies=%d\", num), func(b *testing.B) {\n\t\t\tbenchmarkLadon(num, b, &ladon.Ladon{\n\t\t\t\tManager: managers[\"postgres\"],\n\t\t\t\tMatcher: ladon.NewRegexpMatcher(4096),\n\t\t\t})\n\t\t})\n\t}\n}\n\nfunc generatePolicies(n int) map[string]ladon.Policy {\n\tpolicies := map[string]ladon.Policy{}\n\tfor i := 0; i <= n; i++ {\n\t\tid := uuid.New()\n\t\tpolicies[id] = &ladon.DefaultPolicy{\n\t\t\tID:        id,\n\t\t\tSubjects:  []string{\"foobar\", \"some-resource\" + fmt.Sprintf(\"%d\", i%100), strconv.Itoa(i)},\n\t\t\tActions:   []string{\"foobar\", \"foobar\", \"foobar\", \"foobar\", \"foobar\"},\n\t\t\tResources: []string{\"foobar\", id},\n\t\t\tEffect:    ladon.AllowAccess,\n\t\t}\n\t}\n\treturn policies\n}\n"
        },
        {
          "name": "compiler",
          "type": "tree",
          "content": null
        },
        {
          "name": "condition.go",
          "type": "blob",
          "size": 3.3203125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// Condition either do or do not fulfill an access request.\ntype Condition interface {\n\t// GetName returns the condition's name.\n\tGetName() string\n\n\t// Fulfills returns true if the request is fulfilled by the condition.\n\tFulfills(context.Context, interface{}, *Request) bool\n}\n\n// Conditions is a collection of conditions.\ntype Conditions map[string]Condition\n\n// AddCondition adds a condition to the collection.\nfunc (cs Conditions) AddCondition(key string, c Condition) {\n\tcs[key] = c\n}\n\n// MarshalJSON marshals a list of conditions to json.\nfunc (cs Conditions) MarshalJSON() ([]byte, error) {\n\tout := make(map[string]*jsonCondition, len(cs))\n\tfor k, c := range cs {\n\t\traw, err := json.Marshal(c)\n\t\tif err != nil {\n\t\t\treturn []byte{}, errors.WithStack(err)\n\t\t}\n\n\t\tout[k] = &jsonCondition{\n\t\t\tType:    c.GetName(),\n\t\t\tOptions: json.RawMessage(raw),\n\t\t}\n\t}\n\n\treturn json.Marshal(out)\n}\n\n// UnmarshalJSON unmarshals a list of conditions from json.\nfunc (cs Conditions) UnmarshalJSON(data []byte) error {\n\tif cs == nil {\n\t\treturn errors.New(\"Can not be nil\")\n\t}\n\n\tvar jcs map[string]jsonCondition\n\tvar dc Condition\n\n\tif err := json.Unmarshal(data, &jcs); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tfor k, jc := range jcs {\n\t\tvar found bool\n\t\tfor name, c := range ConditionFactories {\n\t\t\tif name == jc.Type {\n\t\t\t\tfound = true\n\t\t\t\tdc = c()\n\n\t\t\t\tif len(jc.Options) == 0 {\n\t\t\t\t\tcs[k] = dc\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\tif err := json.Unmarshal(jc.Options, dc); err != nil {\n\t\t\t\t\treturn errors.WithStack(err)\n\t\t\t\t}\n\n\t\t\t\tcs[k] = dc\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\treturn errors.Errorf(\"Could not find condition type %s\", jc.Type)\n\t\t}\n\t}\n\n\treturn nil\n}\n\ntype jsonCondition struct {\n\tType    string          `json:\"type\"`\n\tOptions json.RawMessage `json:\"options\"`\n}\n\n// ConditionFactories is where you can add custom conditions\nvar ConditionFactories = map[string]func() Condition{\n\tnew(StringEqualCondition).GetName(): func() Condition {\n\t\treturn new(StringEqualCondition)\n\t},\n\tnew(CIDRCondition).GetName(): func() Condition {\n\t\treturn new(CIDRCondition)\n\t},\n\tnew(EqualsSubjectCondition).GetName(): func() Condition {\n\t\treturn new(EqualsSubjectCondition)\n\t},\n\tnew(StringPairsEqualCondition).GetName(): func() Condition {\n\t\treturn new(StringPairsEqualCondition)\n\t},\n\tnew(StringMatchCondition).GetName(): func() Condition {\n\t\treturn new(StringMatchCondition)\n\t},\n\tnew(ResourceContainsCondition).GetName(): func() Condition {\n\t\treturn new(ResourceContainsCondition)\n\t},\n\tnew(BooleanCondition).GetName(): func() Condition {\n\t\treturn new(BooleanCondition)\n\t},\n}\n"
        },
        {
          "name": "condition_boolean.go",
          "type": "blob",
          "size": 0.7578125,
          "content": "package ladon\n\nimport \"context\"\n\n/*\nBooleanCondition is used to determine if a boolean context matches an expected\nboolean condition.\n\nBooleanCondition implements the ladon.Condition interface.\nSee https://github.com/ory/ladon/blob/master/condition.go\n*/\ntype BooleanCondition struct {\n\tBooleanValue bool `json:\"value\"`\n}\n\n// GetName returns the name of the BooleanCondition\nfunc (c *BooleanCondition) GetName() string {\n\treturn \"BooleanCondition\"\n}\n\n// Fulfills determines if the BooleanCondition is fulfilled.\n// The BooleanCondition is fulfilled if the provided boolean value matches the conditions boolean value.\nfunc (c *BooleanCondition) Fulfills(ctx context.Context, value interface{}, _ *Request) bool {\n\tval, ok := value.(bool)\n\n\treturn ok && val == c.BooleanValue\n}\n"
        },
        {
          "name": "condition_cidr.go",
          "type": "blob",
          "size": 1.4248046875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"net\"\n)\n\n// CIDRCondition makes sure that the warden requests' IP address is in the given CIDR.\ntype CIDRCondition struct {\n\tCIDR string `json:\"cidr\"`\n}\n\n// Fulfills returns true if the the request is fulfilled by the condition.\nfunc (c *CIDRCondition) Fulfills(ctx context.Context, value interface{}, _ *Request) bool {\n\tips, ok := value.(string)\n\tif !ok {\n\t\treturn false\n\t}\n\n\t_, cidrnet, err := net.ParseCIDR(c.CIDR)\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tip := net.ParseIP(ips)\n\tif ip == nil {\n\t\treturn false\n\t}\n\n\treturn cidrnet.Contains(ip)\n}\n\n// GetName returns the condition's name.\nfunc (c *CIDRCondition) GetName() string {\n\treturn \"CIDRCondition\"\n}\n"
        },
        {
          "name": "condition_cidr_test.go",
          "type": "blob",
          "size": 1.3798828125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestCIDRMatch(t *testing.T) {\n\tfor _, c := range []struct {\n\t\tcidr string\n\t\tip   string\n\t\tpass bool\n\t}{\n\t\t{ip: \"192.168.1.67\", cidr: \"192.168.1.0/24\", pass: true},\n\t\t{ip: \"192.168.1.67\", cidr: \"192.168.1.0/28\", pass: false},\n\t\t{ip: \"192.168.1.67\", cidr: \"1\", pass: false},\n\t\t{ip: \"1\", cidr: \"192.168.1.0/28\", pass: false},\n\t\t{ip: \"192.168.1.67\", cidr: \"0.0.0.0/0\", pass: true},\n\t} {\n\t\tcondition := &CIDRCondition{\n\t\t\tCIDR: c.cidr,\n\t\t}\n\n\t\tassert.Equal(t, c.pass, condition.Fulfills(context.Background(), c.ip, new(Request)), \"%s; %s\", c.ip, c.cidr)\n\t}\n}\n"
        },
        {
          "name": "condition_resource_contains.go",
          "type": "blob",
          "size": 1.8837890625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"strings\"\n)\n\n// ResourceContainsCondition is fulfilled if the context matches a substring within the resource name\ntype ResourceContainsCondition struct{}\n\n// Fulfills returns true if the request's resouce contains the given value string\nfunc (c *ResourceContainsCondition) Fulfills(ctx context.Context, value interface{}, r *Request) bool {\n\n\tfilter, ok := value.(map[string]interface{})\n\tif !ok {\n\t\treturn false\n\t}\n\n\tvalueString, ok := filter[\"value\"].(string)\n\tif !ok || len(valueString) < 1 {\n\t\treturn false\n\t}\n\n\t//If no delimiter provided default to \"equals\" check\n\tdelimiterString, ok := filter[\"delimiter\"].(string)\n\tif !ok || len(delimiterString) < 1 {\n\t\tdelimiterString = \"\"\n\t}\n\n\t// Append delimiter to strings to prevent delim+1 being interpreted as delim+10 being present\n\tfilterValue := delimiterString + valueString + delimiterString\n\tresourceString := delimiterString + r.Resource + delimiterString\n\n\tmatches := strings.Contains(resourceString, filterValue)\n\treturn matches\n\n}\n\n// GetName returns the condition's name.\nfunc (c *ResourceContainsCondition) GetName() string {\n\treturn \"ResourceContainsCondition\"\n}\n"
        },
        {
          "name": "condition_resource_contains_test.go",
          "type": "blob",
          "size": 4.27734375,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestResourceContains(t *testing.T) {\n\tfor _, c := range []struct {\n\t\tmatches   string\n\t\tdelimiter string\n\t\tresource  string\n\t\tvalue     string\n\t\tpass      bool\n\t}{\n\t\t//Correct matching within resource string with delimiter:\n\t\t{matches: \"Find value fails incomplete resource string parts.\", delimiter: \":\", value: \"foo:ba\", resource: \"foo:bar\", pass: false},\n\n\t\t{matches: \"Find value as equal to a resource string\", delimiter: \":\", value: \"foo:bar\", resource: \"foo:bar\", pass: true},\n\t\t{matches: \"Find value as prefix of resource string\", delimiter: \":\", value: \"foo:bar\", resource: \"foo:bar:baz\", pass: true},\n\t\t{matches: \"Find value not being prefix of resource string\", delimiter: \":\", value: \"foo:baz\", resource: \"foo:bar:baz\", pass: false},\n\t\t{matches: \"Find value as afix of resource string\", delimiter: \":\", value: \"bar:baz\", resource: \"foo:bar:baz\", pass: true},\n\t\t{matches: \"Find value not being afix of resource string\", delimiter: \":\", value: \"foo:baz\", resource: \"foo:bar:baz\", pass: false},\n\t\t{matches: \"Find value as in middle of resource string\", delimiter: \":\", value: \"bar\", resource: \"foo:bar:baz\", pass: true},\n\t\t{matches: \"Find value not being in middle of resource string\", delimiter: \":\", value: \"bar\", resource: \"baz:foo:baz\", pass: false},\n\n\t\t//Correct matching within resource string without delimiter:\n\t\t{matches: \"Find value does not work for part incomplete resource string parts without delimiter.\", value: \"foo:ba\", resource: \"foo:bar\", pass: true},\n\t\t{matches: \"Find value as equal to a resource string\", value: \"foo:bar\", resource: \"foo:bar\", pass: true},\n\t\t{matches: \"Find value as prefix of resource string\", value: \"foo:bar\", resource: \"foo:bar:baz\", pass: true},\n\t\t{matches: \"Find value not being prefix of resource string\", value: \"foo:baz\", resource: \"foo:bar:baz\", pass: false},\n\t\t{matches: \"Find value as afix of resource string\", value: \"bar:baz\", resource: \"foo:bar:baz\", pass: true},\n\t\t{matches: \"Find value not being afix of resource string\", value: \"foo:baz\", resource: \"foo:bar:baz\", pass: false},\n\t\t{matches: \"Find value as in middle of resource string\", value: \"bar\", resource: \"foo:bar:baz\", pass: true},\n\t\t{matches: \"Find value not being in middle of resource string\", value: \"bar\", resource: \"baz:foo:baz\", pass: false},\n\n\t\t//Erroneous requests:\n\t\t{matches: \"value missing from request\", delimiter: \":\", value: \"\", resource: \"abc\", pass: false},\n\t} {\n\t\tcondition := &ResourceContainsCondition{}\n\n\t\tctx := make(Context)\n\t\trequest := &Request{Resource: c.resource, Subject: \"users:arneanka\", Context: ctx}\n\n\t\t//The context:\n\t\tresourceFilter := make(map[string]interface{})\n\t\tif len(c.delimiter) > 0 {\n\t\t\tresourceFilter[\"delimiter\"] = c.delimiter\n\t\t}\n\t\tresourceFilter[\"value\"] = c.value\n\n\t\tassert.Equal(t, c.pass, condition.Fulfills(context.Background(), resourceFilter, request), \"%s\", c.matches)\n\t\tassert.Equal(t, condition.GetName(), \"ResourceContainsCondition\", \"should be called ResourceContainsCondition\")\n\t}\n}\n"
        },
        {
          "name": "condition_string_equal.go",
          "type": "blob",
          "size": 1.361328125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// StringEqualCondition is a condition which is fulfilled if the given\n// string value is the same as specified in StringEqualCondition\ntype StringEqualCondition struct {\n\tEquals string `json:\"equals\"`\n}\n\n// Fulfills returns true if the given value is a string and is the\n// same as in StringEqualCondition.Equals\nfunc (c *StringEqualCondition) Fulfills(ctx context.Context, value interface{}, _ *Request) bool {\n\ts, ok := value.(string)\n\n\treturn ok && s == c.Equals\n}\n\n// GetName returns the condition's name.\nfunc (c *StringEqualCondition) GetName() string {\n\treturn \"StringEqualCondition\"\n}\n"
        },
        {
          "name": "condition_string_match.go",
          "type": "blob",
          "size": 1.4423828125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"regexp\"\n)\n\n// StringMatchCondition is a condition which is fulfilled if the given\n// string value matches the regex pattern specified in StringMatchCondition\ntype StringMatchCondition struct {\n\tMatches string `json:\"matches\"`\n}\n\n// Fulfills returns true if the given value is a string and matches the regex\n// pattern in StringMatchCondition.Matches\nfunc (c *StringMatchCondition) Fulfills(ctx context.Context, value interface{}, _ *Request) bool {\n\ts, ok := value.(string)\n\n\tmatches, _ := regexp.MatchString(c.Matches, s)\n\n\treturn ok && matches\n}\n\n// GetName returns the condition's name.\nfunc (c *StringMatchCondition) GetName() string {\n\treturn \"StringMatchCondition\"\n}\n"
        },
        {
          "name": "condition_string_match_test.go",
          "type": "blob",
          "size": 1.275390625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStringMatch(t *testing.T) {\n\tfor _, c := range []struct {\n\t\tmatches string\n\t\tvalue   interface{}\n\t\tpass    bool\n\t}{\n\t\t{matches: \".*\", value: \"abc\", pass: true},\n\t\t{matches: \"abc.*\", value: \"abc\", pass: true},\n\t\t{matches: \"abc.+\", value: \"abc\", pass: false},\n\t} {\n\t\tcondition := &StringMatchCondition{\n\t\t\tMatches: c.matches,\n\t\t}\n\n\t\tassert.Equal(t, c.pass, condition.Fulfills(context.Background(), c.value, new(Request)), \"%s\", c.matches)\n\t}\n}\n"
        },
        {
          "name": "condition_string_pairs_equal.go",
          "type": "blob",
          "size": 1.6826171875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// StringPairsEqualCondition is a condition which is fulfilled if the given\n// array of pairs contains two-element string arrays where both elements\n// in the string array are equal\ntype StringPairsEqualCondition struct{}\n\n// Fulfills returns true if the given value is an array of string arrays and\n// each string array has exactly two values which are equal\nfunc (c *StringPairsEqualCondition) Fulfills(ctx context.Context, value interface{}, _ *Request) bool {\n\tpairs, PairsOk := value.([]interface{})\n\tif !PairsOk {\n\t\treturn false\n\t}\n\n\tfor _, v := range pairs {\n\t\tpair, PairOk := v.([]interface{})\n\t\tif !PairOk || (len(pair) != 2) {\n\t\t\treturn false\n\t\t}\n\n\t\ta, AOk := pair[0].(string)\n\t\tb, BOk := pair[1].(string)\n\n\t\tif !AOk || !BOk || (a != b) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\n// GetName returns the condition's name.\nfunc (c *StringPairsEqualCondition) GetName() string {\n\treturn \"StringPairsEqualCondition\"\n}\n"
        },
        {
          "name": "condition_string_pairs_equal_test.go",
          "type": "blob",
          "size": 1.650390625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestStringPairsEqualMatch(t *testing.T) {\n\tfor _, c := range []struct {\n\t\tpairs interface{}\n\t\tpass  bool\n\t}{\n\t\t{pairs: \"junk\", pass: false},\n\t\t{pairs: []interface{}{[]interface{}{}}, pass: false},\n\t\t{pairs: []interface{}{[]interface{}{\"1\"}}, pass: false},\n\t\t{pairs: []interface{}{[]interface{}{\"1\", \"1\", \"2\"}}, pass: false},\n\t\t{pairs: []interface{}{[]interface{}{\"1\", \"2\"}}, pass: false},\n\t\t{pairs: []interface{}{[]interface{}{\"1\", \"1\"}, []interface{}{\"2\", \"3\"}}, pass: false},\n\t\t{pairs: []interface{}{}, pass: true},\n\t\t{pairs: []interface{}{[]interface{}{\"1\", \"1\"}}, pass: true},\n\t\t{pairs: []interface{}{[]interface{}{\"1\", \"1\"}, []interface{}{\"2\", \"2\"}}, pass: true},\n\t} {\n\t\tcondition := &StringPairsEqualCondition{}\n\n\t\tassert.Equal(t, c.pass, condition.Fulfills(context.Background(), c.pairs, new(Request)), \"%s\", c.pairs)\n\t}\n}\n"
        },
        {
          "name": "condition_subject_equal.go",
          "type": "blob",
          "size": 1.298828125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// EqualsSubjectCondition is a condition which is fulfilled if the request's subject is equal to the given value string\ntype EqualsSubjectCondition struct{}\n\n// Fulfills returns true if the request's subject is equal to the given value string\nfunc (c *EqualsSubjectCondition) Fulfills(ctx context.Context, value interface{}, r *Request) bool {\n\ts, ok := value.(string)\n\n\treturn ok && s == r.Subject\n}\n\n// GetName returns the condition's name.\nfunc (c *EqualsSubjectCondition) GetName() string {\n\treturn \"EqualsSubjectCondition\"\n}\n"
        },
        {
          "name": "condition_test.go",
          "type": "blob",
          "size": 2.6298828125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"encoding/json\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc TestConditionsAppend(t *testing.T) {\n\tcs := Conditions{}\n\tc := &CIDRCondition{}\n\tcs.AddCondition(\"clientIP\", c)\n\tassert.Equal(t, c, cs[\"clientIP\"])\n}\n\nfunc TestMarshalUnmarshalNative(t *testing.T) {\n\tcss := &Conditions{\n\t\t\"clientIP\": &CIDRCondition{CIDR: \"127.0.0.1/0\"},\n\t\t\"owner\":    &EqualsSubjectCondition{},\n\t}\n\tout, err := json.Marshal(css)\n\trequire.Nil(t, err)\n\tt.Logf(\"%s\", out)\n\n\tcs := Conditions{}\n\trequire.Nil(t, cs.UnmarshalJSON(out))\n}\n\nfunc TestMarshalUnmarshal(t *testing.T) {\n\tcss := &Conditions{\n\t\t\"clientIP\":              &CIDRCondition{CIDR: \"127.0.0.1/0\"},\n\t\t\"owner\":                 &EqualsSubjectCondition{},\n\t\t\"role\":                  &StringMatchCondition{Matches: \".*\"},\n\t\t\"hasElevatedPrivileges\": &BooleanCondition{BooleanValue: true},\n\t}\n\tout, err := json.Marshal(css)\n\trequire.Nil(t, err)\n\tt.Logf(\"%s\", out)\n\n\tcs := Conditions{}\n\trequire.Nil(t, json.Unmarshal([]byte(`{\n\t\"owner\": {\n\t\t\"type\": \"EqualsSubjectCondition\"\n\t},\n\t\"clientIP\": {\n\t\t\"type\": \"CIDRCondition\",\n\t\t\"options\": {\n\t\t\t\"cidr\": \"127.0.0.1/0\"\n\t\t}\n\t},\n\t\"role\": {\n\t\t\"type\": \"StringMatchCondition\",\n\t\t\"options\": {\n\t\t\t\"matches\": \".*\"\n\t\t}\n\t},\n\t\"hasElevatedPrivileges\": {\n\t\t\"type\": \"BooleanCondition\",\n\t\t\"options\": {\n\t\t\t\"value\": true\n\t\t}\n\t},\n\t\"resourceFilter\": {\n\t\t\t\"type\": \"ResourceContainsCondition\"\n\t\t}\n}`), &cs))\n\n\trequire.Len(t, cs, 5)\n\tassert.IsType(t, &EqualsSubjectCondition{}, cs[\"owner\"])\n\tassert.IsType(t, &CIDRCondition{}, cs[\"clientIP\"])\n\tassert.IsType(t, &StringMatchCondition{}, cs[\"role\"])\n\tassert.IsType(t, &BooleanCondition{}, cs[\"hasElevatedPrivileges\"])\n\tassert.IsType(t, &ResourceContainsCondition{}, cs[\"resourceFilter\"])\n}\n\nfunc TestUnmarshalFails(t *testing.T) {\n\tcs := Conditions{}\n\trequire.NotNil(t, json.Unmarshal([]byte(`{\n\t\"somefield\": {\n\t\t\"type\": \"DoesntExist\"\n\t}\n}`), &cs))\n}\n"
        },
        {
          "name": "const.go",
          "type": "blob",
          "size": 0.9560546875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\n// AllowAccess should be used as effect for policies that allow access.\nconst AllowAccess = \"allow\"\n\n// DenyAccess should be used as effect for policies that deny access.\nconst DenyAccess = \"deny\"\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 0.8388671875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\n// Context is used as request's context.\ntype Context map[string]interface{}\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 2.7421875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/pkg/errors\"\n)\n\nvar (\n\t// ErrRequestDenied is returned when an access request can not be satisfied by any policy.\n\tErrRequestDenied = &errorWithContext{\n\t\terror:  errors.New(\"Request was denied by default\"),\n\t\tcode:   http.StatusForbidden,\n\t\tstatus: http.StatusText(http.StatusForbidden),\n\t\treason: \"The request was denied because no matching policy was found.\",\n\t}\n\n\t// ErrRequestForcefullyDenied is returned when an access request is explicitly denied by a policy.\n\tErrRequestForcefullyDenied = &errorWithContext{\n\t\terror:  errors.New(\"Request was forcefully denied\"),\n\t\tcode:   http.StatusForbidden,\n\t\tstatus: http.StatusText(http.StatusForbidden),\n\t\treason: \"The request was denied because a policy denied request.\",\n\t}\n\n\t// ErrNotFound is returned when a resource can not be found.\n\tErrNotFound = &errorWithContext{\n\t\terror:  errors.New(\"Resource could not be found\"),\n\t\tcode:   http.StatusNotFound,\n\t\tstatus: http.StatusText(http.StatusNotFound),\n\t}\n)\n\nfunc NewErrResourceNotFound(err error) error {\n\tif err == nil {\n\t\terr = errors.New(\"not found\")\n\t}\n\n\treturn errors.WithStack(&errorWithContext{\n\t\terror:  err,\n\t\tcode:   http.StatusNotFound,\n\t\tstatus: http.StatusText(http.StatusNotFound),\n\t\treason: \"The requested resource could not be found.\",\n\t})\n}\n\ntype errorWithContext struct {\n\tcode   int\n\treason string\n\tstatus string\n\terror\n}\n\n// StatusCode returns the status code of this error.\nfunc (e *errorWithContext) StatusCode() int {\n\treturn e.code\n}\n\n// RequestID returns the ID of the request that caused the error, if applicable.\nfunc (e *errorWithContext) RequestID() string {\n\treturn \"\"\n}\n\n// Reason returns the reason for the error, if applicable.\nfunc (e *errorWithContext) Reason() string {\n\treturn e.reason\n}\n\n// ID returns the error id, if applicable.\nfunc (e *errorWithContext) Status() string {\n\treturn e.status\n}\n\n// Details returns details on the error, if applicable.\nfunc (e *errorWithContext) Details() []map[string]interface{} {\n\treturn []map[string]interface{}{}\n}\n"
        },
        {
          "name": "errors_test.go",
          "type": "blob",
          "size": 0.96484375,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewErrResourceNotFound(t *testing.T) {\n\tassert.EqualError(t, NewErrResourceNotFound(errors.New(\"not found\")), \"not found\")\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4306640625,
          "content": "module github.com/ory/ladon\n\ngo 1.19\n\nrequire (\n\tgithub.com/dlclark/regexp2 v1.2.0\n\tgithub.com/golang/mock v1.6.0\n\tgithub.com/hashicorp/golang-lru v0.5.0\n\tgithub.com/ory/pagination v0.0.1\n\tgithub.com/pborman/uuid v1.2.0\n\tgithub.com/pkg/errors v0.8.0\n\tgithub.com/stretchr/testify v1.2.2\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/google/uuid v1.0.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.95703125,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/dlclark/regexp2 v1.2.0 h1:8sAhBGEM0dRWogWqWyQeIJnxjWO6oIjl8FKqREDsGfk=\ngithub.com/dlclark/regexp2 v1.2.0/go.mod h1:2pZnwuY/m+8K6iRw6wQdMtk+rH5tNGR1i55kozfMjCc=\ngithub.com/golang/mock v1.6.0 h1:ErTB+efbowRARo13NNdxyJji2egdxLGQhRaY+DUumQc=\ngithub.com/golang/mock v1.6.0/go.mod h1:p6yTPP+5HYm5mzsMV8JkE6ZKdX+/wYM6Hr+LicevLPs=\ngithub.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=\ngithub.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/hashicorp/golang-lru v0.5.0 h1:CL2msUPvZTLb5O648aiLNJw3hnBxN2+1Jq8rCOH9wdo=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/ory/pagination v0.0.1 h1:Zp+0n/UXSGYlJAMN0BuRjZhULsQRebGHfqByKtZXNYI=\ngithub.com/ory/pagination v0.0.1/go.mod h1:d1ToRROAUleriPhmb2dYbhANhhLwZ8s395m2yJCDFh8=\ngithub.com/pborman/uuid v1.2.0 h1:J7Q5mO4ysT1dv8hyrUGHb9+ooztCXu1D8MY8DZYsu3g=\ngithub.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=\ngithub.com/pkg/errors v0.8.0 h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.2.2 h1:bSDNvY7ZPG5RlJ8otE/7V6gMiyenm9RtJ7IUVIAoJ1w=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.1.1/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\n"
        },
        {
          "name": "ladon.go",
          "type": "blob",
          "size": 4.5693359375,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"context\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// Ladon is an implementation of Warden.\ntype Ladon struct {\n\tManager     Manager\n\tMatcher     matcher\n\tAuditLogger AuditLogger\n\tMetric      Metric\n}\n\nfunc (l *Ladon) matcher() matcher {\n\tif l.Matcher != nil {\n\t\treturn l.Matcher\n\t}\n\treturn DefaultMatcher\n}\n\nfunc (l *Ladon) auditLogger() AuditLogger {\n\tif l.AuditLogger != nil {\n\t\treturn l.AuditLogger\n\t}\n\treturn DefaultAuditLogger\n}\n\nfunc (l *Ladon) metric() Metric {\n\tif l.Metric == nil {\n\t\tl.Metric = DefaultMetric\n\t}\n\treturn l.Metric\n}\n\n// IsAllowed returns nil if subject s has permission p on resource r with context c or an error otherwise.\nfunc (l *Ladon) IsAllowed(ctx context.Context, r *Request) (err error) {\n\tpolicies, err := l.Manager.FindRequestCandidates(ctx, r)\n\tif err != nil {\n\t\tgo l.metric().RequestProcessingError(*r, nil, err)\n\t\treturn err\n\t}\n\n\t// Although the manager is responsible of matching the policies, it might decide to just scan for\n\t// subjects, it might return all policies, or it might have a different pattern matching than Golang.\n\t// Thus, we need to make sure that we actually matched the right policies.\n\treturn l.DoPoliciesAllow(ctx, r, policies)\n}\n\n// DoPoliciesAllow returns nil if subject s has permission p on resource r with context c for a given policy list or an error otherwise.\n// The IsAllowed interface should be preferred since it uses the manager directly. This is a lower level interface for when you don't want to use the ladon manager.\nfunc (l *Ladon) DoPoliciesAllow(ctx context.Context, r *Request, policies []Policy) (err error) {\n\tvar allowed = false\n\tvar deciders = Policies{}\n\n\t// Iterate through all policies\n\tfor _, p := range policies {\n\n\t\t// Does the action match with one of the policies?\n\t\t// This is the first check because usually actions are a superset of get|update|delete|set\n\t\t// and thus match faster.\n\t\tif pm, err := l.matcher().Matches(p, p.GetActions(), r.Action); err != nil {\n\t\t\tgo l.metric().RequestProcessingError(*r, p, err)\n\t\t\treturn errors.WithStack(err)\n\t\t} else if !pm {\n\t\t\t// no, continue to next policy\n\t\t\tcontinue\n\t\t}\n\n\t\t// Does the subject match with one of the policies?\n\t\t// There are usually less subjects than resources which is why this is checked\n\t\t// before checking for resources.\n\t\tif sm, err := l.matcher().Matches(p, p.GetSubjects(), r.Subject); err != nil {\n\t\t\tgo l.metric().RequestProcessingError(*r, p, err)\n\t\t\treturn err\n\t\t} else if !sm {\n\t\t\t// no, continue to next policy\n\t\t\tcontinue\n\t\t}\n\n\t\t// Does the resource match with one of the policies?\n\t\tif rm, err := l.matcher().Matches(p, p.GetResources(), r.Resource); err != nil {\n\t\t\tgo l.metric().RequestProcessingError(*r, p, err)\n\t\t\treturn errors.WithStack(err)\n\t\t} else if !rm {\n\t\t\t// no, continue to next policy\n\t\t\tcontinue\n\t\t}\n\n\t\t// Are the policies conditions met?\n\t\t// This is checked first because it usually has a small complexity.\n\t\tif !l.passesConditions(ctx, p, r) {\n\t\t\t// no, continue to next policy\n\t\t\tcontinue\n\t\t}\n\n\t\t// Is the policy's effect `deny`? If yes, this overrides all allow policies -> access denied.\n\t\tif !p.AllowAccess() {\n\t\t\tdeciders = append(deciders, p)\n\t\t\tl.auditLogger().LogRejectedAccessRequest(ctx, r, policies, deciders)\n\t\t\tgo l.metric().RequestDeniedBy(*r, p)\n\t\t\treturn errors.WithStack(ErrRequestForcefullyDenied)\n\t\t}\n\n\t\tallowed = true\n\t\tdeciders = append(deciders, p)\n\t}\n\n\tif !allowed {\n\t\tgo l.metric().RequestNoMatch(*r)\n\n\t\tl.auditLogger().LogRejectedAccessRequest(ctx, r, policies, deciders)\n\t\treturn errors.WithStack(ErrRequestDenied)\n\t}\n\n\tl.auditLogger().LogGrantedAccessRequest(ctx, r, policies, deciders)\n\tl.metric().RequestAllowedBy(*r, deciders)\n\n\treturn nil\n}\n\nfunc (l *Ladon) passesConditions(ctx context.Context, p Policy, r *Request) bool {\n\tfor key, condition := range p.GetConditions() {\n\t\tif pass := condition.Fulfills(ctx, r.Context[key], r); !pass {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"
        },
        {
          "name": "ladon_test.go",
          "type": "blob",
          "size": 6.9892578125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t. \"github.com/ory/ladon\"\n\t. \"github.com/ory/ladon/manager/memory\"\n)\n\n// A bunch of exemplary policies\nvar pols = []Policy{\n\t&DefaultPolicy{\n\t\tID: \"0\",\n\t\tDescription: `This policy allows max, peter, zac and ken to create, delete and get the listed resources,\n\t\t\tbut only if the client ip matches and the request states that they are the owner of those resources as well.`,\n\t\tSubjects:  []string{\"max\", \"peter\", \"<zac|ken>\"},\n\t\tResources: []string{\"myrn:some.domain.com:resource:123\", \"myrn:some.domain.com:resource:345\", \"myrn:something:foo:<.+>\"},\n\t\tActions:   []string{\"<create|delete>\", \"get\"},\n\t\tEffect:    AllowAccess,\n\t\tConditions: Conditions{\n\t\t\t\"owner\": &EqualsSubjectCondition{},\n\t\t\t\"clientIP\": &CIDRCondition{\n\t\t\t\tCIDR: \"127.0.0.1/32\",\n\t\t\t},\n\t\t},\n\t},\n\t&DefaultPolicy{\n\t\tID:          \"1\",\n\t\tDescription: \"This policy allows max to update any resource\",\n\t\tSubjects:    []string{\"max\"},\n\t\tActions:     []string{\"update\"},\n\t\tResources:   []string{\"<.*>\"},\n\t\tEffect:      AllowAccess,\n\t},\n\t&DefaultPolicy{\n\t\tID:          \"3\",\n\t\tDescription: \"This policy denies max to broadcast any of the resources\",\n\t\tSubjects:    []string{\"max\"},\n\t\tActions:     []string{\"broadcast\"},\n\t\tResources:   []string{\"<.*>\"},\n\t\tEffect:      DenyAccess,\n\t},\n\t&DefaultPolicy{\n\t\tID:          \"2\",\n\t\tDescription: \"This policy denies max to broadcast any of the resources\",\n\t\tSubjects:    []string{\"max\"},\n\t\tActions:     []string{\"random\"},\n\t\tResources:   []string{\"<.*>\"},\n\t\tEffect:      DenyAccess,\n\t},\n\t&DefaultPolicy{\n\t\tID:          \"4\",\n\t\tDescription: \"This policy allows swen to update any resource except `protected` resources\",\n\t\tSubjects:    []string{\"swen\"},\n\t\tActions:     []string{\"update\"},\n\t\tResources:   []string{\"myrn:some.domain.com:resource:<(?!protected).*>\"},\n\t\tEffect:      AllowAccess,\n\t},\n\t&DefaultPolicy{\n\t\tID:          \"5\",\n\t\tDescription: \"This policy allows richard to update resources which names consists of digits only\",\n\t\tSubjects:    []string{\"richard\"},\n\t\tActions:     []string{\"update\"},\n\t\tResources:   []string{\"myrn:some.domain.com:resource:<[[:digit:]]+>\"},\n\t\tEffect:      AllowAccess,\n\t},\n}\n\n// Some test cases\nvar cases = []struct {\n\tdescription   string\n\taccessRequest *Request\n\texpectErr     bool\n}{\n\t{\n\t\tdescription: \"should fail because no policy is matching as field clientIP does not satisfy the CIDR condition of policy 1.\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"peter\",\n\t\t\tAction:   \"delete\",\n\t\t\tResource: \"myrn:some.domain.com:resource:123\",\n\t\t\tContext: Context{\n\t\t\t\t\"owner\":    \"peter\",\n\t\t\t\t\"clientIP\": \"0.0.0.0\",\n\t\t\t},\n\t\t},\n\t\texpectErr: true,\n\t},\n\t{\n\t\tdescription: \"should fail because no policy is matching as the owner of the resource 123 is zac, not peter!\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"peter\",\n\t\t\tAction:   \"delete\",\n\t\t\tResource: \"myrn:some.domain.com:resource:123\",\n\t\t\tContext: Context{\n\t\t\t\t\"owner\":    \"zac\",\n\t\t\t\t\"clientIP\": \"127.0.0.1\",\n\t\t\t},\n\t\t},\n\t\texpectErr: true,\n\t},\n\t{\n\t\tdescription: \"should pass because policy 1 is matching and has effect allow.\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"peter\",\n\t\t\tAction:   \"delete\",\n\t\t\tResource: \"myrn:some.domain.com:resource:123\",\n\t\t\tContext: Context{\n\t\t\t\t\"owner\":    \"peter\",\n\t\t\t\t\"clientIP\": \"127.0.0.1\",\n\t\t\t},\n\t\t},\n\t\texpectErr: false,\n\t},\n\t{\n\t\tdescription: \"should pass because max is allowed to update all resources.\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"max\",\n\t\t\tAction:   \"update\",\n\t\t\tResource: \"myrn:some.domain.com:resource:123\",\n\t\t},\n\t\texpectErr: false,\n\t},\n\t{\n\t\tdescription: \"should pass because max is allowed to update all resource, even if none is given.\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"max\",\n\t\t\tAction:   \"update\",\n\t\t\tResource: \"\",\n\t\t},\n\t\texpectErr: false,\n\t},\n\t{\n\t\tdescription: \"should fail because max is not allowed to broadcast any resource.\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"max\",\n\t\t\tAction:   \"broadcast\",\n\t\t\tResource: \"myrn:some.domain.com:resource:123\",\n\t\t},\n\t\texpectErr: true,\n\t},\n\t{\n\t\tdescription: \"should fail because max is not allowed to broadcast any resource, even empty ones!\",\n\t\taccessRequest: &Request{\n\t\t\tSubject: \"max\",\n\t\t\tAction:  \"broadcast\",\n\t\t},\n\t\texpectErr: true,\n\t},\n\t{\n\t\tdescription: \"should pass because swen is allowed to update all resources except `protected` resources.\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"swen\",\n\t\t\tAction:   \"update\",\n\t\t\tResource: \"myrn:some.domain.com:resource:123\",\n\t\t},\n\t\texpectErr: false,\n\t},\n\t{\n\t\tdescription: \"should fail because swen is not allowed to update `protected` resource\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"swen\",\n\t\t\tAction:   \"update\",\n\t\t\tResource: \"myrn:some.domain.com:resource:protected123\",\n\t\t},\n\t\texpectErr: true,\n\t},\n\t{\n\t\tdescription: \"should fail because richard is not allowed to update a resource with alphanumeric name\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"richard\",\n\t\t\tAction:   \"update\",\n\t\t\tResource: \"myrn:some.domain.com:resource:protected123\",\n\t\t},\n\t\texpectErr: true,\n\t},\n\t{\n\t\tdescription: \"should pass because richard is allowed to update a resources with a name containing digits only\",\n\t\taccessRequest: &Request{\n\t\t\tSubject:  \"richard\",\n\t\t\tAction:   \"update\",\n\t\t\tResource: \"myrn:some.domain.com:resource:25222\",\n\t\t},\n\t\texpectErr: false,\n\t},\n}\n\nfunc TestLadon(t *testing.T) {\n\n\tctx := context.Background()\n\n\t// Instantiate ladon with the default in-memory store.\n\twarden := &Ladon{Manager: NewMemoryManager()}\n\n\t// Add the policies defined above to the memory manager.\n\tfor _, pol := range pols {\n\t\trequire.Nil(t, warden.Manager.Create(ctx, pol))\n\t}\n\n\tfor i := 0; i < len(pols); i++ {\n\t\tpolices, err := warden.Manager.GetAll(ctx, int64(1), int64(i))\n\t\trequire.NoError(t, err)\n\t\tp, err := warden.Manager.Get(ctx, fmt.Sprintf(\"%d\", i))\n\t\tif err == nil {\n\t\t\tAssertPolicyEqual(t, p, polices[0])\n\t\t}\n\t}\n\n\tfor k, c := range cases {\n\t\tt.Run(fmt.Sprintf(\"case=%d-%s\", k, c.description), func(t *testing.T) {\n\n\t\t\t// This is where we ask the warden if the access requests should be granted\n\t\t\terr := warden.IsAllowed(ctx, c.accessRequest)\n\n\t\t\tassert.Equal(t, c.expectErr, err != nil)\n\t\t})\n\t}\n\n}\n\nfunc TestLadonEmpty(t *testing.T) {\n\n\tctx := context.Background()\n\n\t// If no policy was given, the warden must return an error!\n\twarden := &Ladon{Manager: NewMemoryManager()}\n\tassert.NotNil(t, warden.IsAllowed(ctx, &Request{}))\n}\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 47.02734375,
          "content": null
        },
        {
          "name": "manager.go",
          "type": "blob",
          "size": 2.1669921875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// Manager is responsible for managing and persisting policies.\ntype Manager interface {\n\n\t// Create persists the policy.\n\tCreate(ctx context.Context, policy Policy) error\n\n\t// Update updates an existing policy.\n\tUpdate(ctx context.Context, policy Policy) error\n\n\t// Get retrieves a policy.\n\tGet(ctx context.Context, id string) (Policy, error)\n\n\t// Delete removes a policy.\n\tDelete(ctx context.Context, id string) error\n\n\t// GetAll retrieves all policies.\n\tGetAll(ctx context.Context, limit, offset int64) (Policies, error)\n\n\t// FindRequestCandidates returns candidates that could match the request object. It either returns\n\t// a set that exactly matches the request, or a superset of it. If an error occurs, it returns nil and\n\t// the error.\n\tFindRequestCandidates(ctx context.Context, r *Request) (Policies, error)\n\n\t// FindPoliciesForSubject returns policies that could match the subject. It either returns\n\t// a set of policies that applies to the subject, or a superset of it.\n\t// If an error occurs, it returns nil and the error.\n\tFindPoliciesForSubject(ctx context.Context, subject string) (Policies, error)\n\n\t// FindPoliciesForResource returns policies that could match the resource. It either returns\n\t// a set of policies that apply to the resource, or a superset of it.\n\t// If an error occurs, it returns nil and the error.\n\tFindPoliciesForResource(ctx context.Context, resource string) (Policies, error)\n}\n"
        },
        {
          "name": "manager",
          "type": "tree",
          "content": null
        },
        {
          "name": "manager_all_test.go",
          "type": "blob",
          "size": 1.638671875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t. \"github.com/ory/ladon\"\n\t. \"github.com/ory/ladon/manager/memory\"\n)\n\nvar managers = map[string]Manager{}\n\nfunc TestMain(m *testing.M) {\n\tconnectMEM()\n}\n\nfunc connectMEM() {\n\tmanagers[\"memory\"] = NewMemoryManager()\n}\n\nfunc TestManagers(t *testing.T) {\n\tt.Run(\"type=get errors\", func(t *testing.T) {\n\t\tfor k, s := range managers {\n\t\t\tt.Run(\"manager=\"+k, HelperTestGetErrors(s))\n\t\t}\n\t})\n\n\tt.Run(\"type=CRUD\", func(t *testing.T) {\n\t\tfor k, s := range managers {\n\t\t\tt.Run(fmt.Sprintf(\"manager=%s\", k), HelperTestCreateGetDelete(s))\n\t\t}\n\t})\n\n\tt.Run(\"type=find\", func(t *testing.T) {\n\t\tfor k, s := range map[string]Manager{\n\t\t\t\"postgres\": managers[\"postgres\"],\n\t\t\t\"mysql\":    managers[\"mysql\"],\n\t\t} {\n\t\t\tt.Run(fmt.Sprintf(\"manager=%s\", k), HelperTestFindPoliciesForSubject(k, s))\n\t\t\tt.Run(fmt.Sprintf(\"manager=%s\", k), HelperTestFindPoliciesForResource(k, s))\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "manager_helper_test.go",
          "type": "blob",
          "size": 12.3779296875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/ory/ladon\"\n\t\"github.com/pborman/uuid\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nvar TestManagerPolicies = []*ladon.DefaultPolicy{\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"user\", \"anonymous\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"article\", \"user\"},\n\t\tActions:     []string{\"create\", \"update\"},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"<article|user>\"},\n\t\tActions:     []string{\"view\"},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{},\n\t\tActions:     []string{\"view\"},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{},\n\t\tActions:     []string{},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"foo\"},\n\t\tActions:     []string{},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"foo\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"foo\"},\n\t\tActions:     []string{},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"foo\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{},\n\t\tActions:     []string{},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tEffect:      ladon.AllowAccess,\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"<peter|max>\"},\n\t\tEffect:      ladon.DenyAccess,\n\t\tResources:   []string{\"article\", \"user\"},\n\t\tActions:     []string{\"view\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"owner\": &ladon.EqualsSubjectCondition{},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"<user|max|anonymous>\", \"peter\"},\n\t\tEffect:      ladon.DenyAccess,\n\t\tResources:   []string{\".*\"},\n\t\tActions:     []string{\"disable\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"ip\": &ladon.CIDRCondition{\n\t\t\t\tCIDR: \"1234\",\n\t\t\t},\n\t\t\t\"owner\": &ladon.EqualsSubjectCondition{},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"<.*>\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"<article|user>\"},\n\t\tActions:     []string{\"view\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"ip\": &ladon.CIDRCondition{\n\t\t\t\tCIDR: \"1234\",\n\t\t\t},\n\t\t\t\"owner\": &ladon.EqualsSubjectCondition{},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"<us[er]+>\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"<article|user>\"},\n\t\tActions:     []string{\"view\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"ip\": &ladon.CIDRCondition{\n\t\t\t\tCIDR: \"1234\",\n\t\t\t},\n\t\t\t\"owner\": &ladon.EqualsSubjectCondition{},\n\t\t},\n\t},\n\t//Two new policies which do not persist in MySQL correctly\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"A failed policy\",\n\t\tSubjects:    []string{\"supplier\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"product:<.*>\"},\n\t\tActions:     []string{\"update\"},\n\t\tConditions:  ladon.Conditions{},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"Another failed policy\",\n\t\tSubjects:    []string{\"buyer\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"products:attributeGroup:<.*>\"},\n\t\tActions:     []string{\"create\"},\n\t\tConditions:  ladon.Conditions{},\n\t},\n}\n\nvar testPolicies = []*ladon.DefaultPolicy{\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"sql<.*>match\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"master\", \"user\", \"article\"},\n\t\tActions:     []string{\"create\", \"update\", \"delete\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"foo\": &ladon.StringEqualCondition{\n\t\t\t\tEquals: \"foo\",\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"sqlmatch\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"master\", \"user\", \"article\"},\n\t\tActions:     []string{\"create\", \"update\", \"delete\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"foo\": &ladon.StringEqualCondition{\n\t\t\t\tEquals: \"foo\",\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"master\", \"user\", \"article\"},\n\t\tActions:     []string{\"create\", \"update\", \"delete\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"foo\": &ladon.StringEqualCondition{\n\t\t\t\tEquals: \"foo\",\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"master\", \"user\", \"article\"},\n\t\tActions:     []string{\"create\", \"update\", \"delete\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"foo\": &ladon.StringEqualCondition{\n\t\t\t\tEquals: \"foo\",\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"some\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"sqlmatch_resource\"},\n\t\tActions:     []string{\"create\", \"update\", \"delete\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"foo\": &ladon.StringEqualCondition{\n\t\t\t\tEquals: \"foo\",\n\t\t\t},\n\t\t},\n\t},\n\t{\n\t\tID:          uuid.New(),\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"other\"},\n\t\tEffect:      ladon.AllowAccess,\n\t\tResources:   []string{\"sql<.*>resource\"},\n\t\tActions:     []string{\"create\", \"update\", \"delete\"},\n\t\tConditions: ladon.Conditions{\n\t\t\t\"foo\": &ladon.StringEqualCondition{\n\t\t\t\tEquals: \"foo\",\n\t\t\t},\n\t\t},\n\t},\n}\n\nfunc HelperTestFindPoliciesForSubject(k string, s ladon.Manager) func(t *testing.T) {\n\tctx := context.Background()\n\n\treturn func(t *testing.T) {\n\t\tfor _, c := range testPolicies {\n\t\t\tt.Run(fmt.Sprintf(\"create=%s\", k), func(t *testing.T) {\n\t\t\t\trequire.NoError(t, s.Create(ctx, c))\n\t\t\t})\n\t\t}\n\n\t\tres, err := s.FindRequestCandidates(ctx, &ladon.Request{\n\t\t\tSubject:  \"sqlmatch\",\n\t\t\tResource: \"article\",\n\t\t\tAction:   \"create\",\n\t\t})\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, res, 2)\n\n\t\tif testPolicies[0].ID == res[0].GetID() {\n\t\t\tAssertPolicyEqual(t, testPolicies[0], res[0])\n\t\t\tAssertPolicyEqual(t, testPolicies[1], res[1])\n\t\t} else {\n\t\t\tAssertPolicyEqual(t, testPolicies[0], res[1])\n\t\t\tAssertPolicyEqual(t, testPolicies[1], res[0])\n\t\t}\n\n\t\tres, err = s.FindRequestCandidates(ctx, &ladon.Request{\n\t\t\tSubject:  \"sqlamatch\",\n\t\t\tResource: \"article\",\n\t\t\tAction:   \"create\",\n\t\t})\n\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, res, 1)\n\t\tAssertPolicyEqual(t, testPolicies[0], res[0])\n\t}\n}\n\nfunc HelperTestFindPoliciesForResource(k string, s ladon.Manager) func(t *testing.T) {\n\tctx := context.Background()\n\n\treturn func(t *testing.T) {\n\t\tfor _, c := range testPolicies {\n\t\t\tt.Run(fmt.Sprintf(\"create=%s\", k), func(t *testing.T) {\n\t\t\t\trequire.NoError(t, s.Create(ctx, c))\n\t\t\t})\n\t\t}\n\n\t\tres, err := s.FindPoliciesForResource(ctx, \"sqlmatch_resource\")\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, res, 2)\n\n\t\tif testPolicies[len(testPolicies)-2].ID == res[0].GetID() {\n\t\t\tAssertPolicyEqual(t, testPolicies[len(testPolicies)-2], res[0])\n\t\t\tAssertPolicyEqual(t, testPolicies[len(testPolicies)-1], res[1])\n\t\t} else {\n\t\t\tAssertPolicyEqual(t, testPolicies[len(testPolicies)-2], res[1])\n\t\t\tAssertPolicyEqual(t, testPolicies[len(testPolicies)-1], res[0])\n\t\t}\n\n\t\tres, err = s.FindPoliciesForResource(ctx, \"sqlamatch_resource\")\n\n\t\trequire.NoError(t, err)\n\t\trequire.Len(t, res, 1)\n\t\tAssertPolicyEqual(t, testPolicies[len(testPolicies)-1], res[0])\n\t}\n}\n\nfunc AssertPolicyEqual(t *testing.T, expected, got ladon.Policy) {\n\tassert.Equal(t, expected.GetID(), got.GetID())\n\tassert.Equal(t, expected.GetDescription(), got.GetDescription())\n\tassert.Equal(t, expected.GetEffect(), got.GetEffect())\n\n\t// This won't work in the memory manager\n\t//assert.NotNil(t, got.GetActions())\n\t//assert.NotNil(t, got.GetResources())\n\t//assert.NotNil(t, got.GetSubjects())\n\n\tassert.NoError(t, testEq(expected.GetActions(), got.GetActions()))\n\tassert.NoError(t, testEq(expected.GetResources(), got.GetResources()))\n\tassert.NoError(t, testEq(expected.GetSubjects(), got.GetSubjects()))\n\tassert.EqualValues(t, expected.GetConditions(), got.GetConditions())\n}\n\nfunc testEq(a, b []string) error {\n\t// We don't care about nil types\n\t//if a == nil && b == nil {\n\t//\treturn true\n\t//}\n\t//\n\t//if a == nil || b == nil {\n\t//\treturn false\n\t//}\n\n\tif len(a) != len(b) {\n\t\treturn errors.Errorf(\"Length not equal: %v (%d) != %v (%d)\", a, len(a), b, len(b))\n\t}\n\n\tvar found bool\n\tfor i := range a {\n\t\tfound = false\n\n\t\tfor y := range b {\n\t\t\tif a[i] == b[y] {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\treturn errors.Errorf(\"No match found: %d from %v in %v\", i, a, b)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc HelperTestGetErrors(s ladon.Manager) func(t *testing.T) {\n\tctx := context.Background()\n\n\treturn func(t *testing.T) {\n\t\t_, err := s.Get(ctx, uuid.New())\n\t\tassert.Error(t, err)\n\n\t\t_, err = s.Get(ctx, \"asdf\")\n\t\tassert.Error(t, err)\n\t}\n}\n\nfunc HelperTestCreateGetDelete(s ladon.Manager) func(t *testing.T) {\n\tctx := context.Background()\n\n\treturn func(t *testing.T) {\n\t\tfor i, c := range TestManagerPolicies {\n\t\t\tt.Run(fmt.Sprintf(\"case=%d/id=%s/type=create\", i, c.GetID()), func(t *testing.T) {\n\t\t\t\t_, err := s.Get(ctx, c.GetID())\n\t\t\t\trequire.Error(t, err)\n\t\t\t\trequire.NoError(t, s.Create(ctx, c))\n\t\t\t})\n\n\t\t\tt.Run(fmt.Sprintf(\"case=%d/id=%s/type=query\", i, c.GetID()), func(t *testing.T) {\n\t\t\t\tget, err := s.Get(ctx, c.GetID())\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tAssertPolicyEqual(t, c, get)\n\t\t\t})\n\n\t\t\tt.Run(fmt.Sprintf(\"case=%d/id=%s/type=update\", i, c.GetID()), func(t *testing.T) {\n\t\t\t\tc.Description = c.Description + \"_updated\"\n\t\t\t\trequire.NoError(t, s.Update(ctx, c))\n\n\t\t\t\tget, err := s.Get(ctx, c.GetID())\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tAssertPolicyEqual(t, c, get)\n\t\t\t})\n\n\t\t\tt.Run(fmt.Sprintf(\"case=%d/id=%s/type=query\", i, c.GetID()), func(t *testing.T) {\n\t\t\t\tget, err := s.Get(ctx, c.GetID())\n\t\t\t\trequire.NoError(t, err)\n\n\t\t\t\tAssertPolicyEqual(t, c, get)\n\t\t\t})\n\t\t}\n\n\t\tt.Run(\"type=query-all\", func(t *testing.T) {\n\t\t\tcount := int64(len(TestManagerPolicies))\n\n\t\t\tpols, err := s.GetAll(ctx, 100, 0)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Len(t, pols, len(TestManagerPolicies))\n\n\t\t\tpols4, err := s.GetAll(ctx, 1, 0)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Len(t, pols4, 1)\n\n\t\t\tpols2, err := s.GetAll(ctx, 100, count-1)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Len(t, pols2, 1)\n\n\t\t\tpols3, err := s.GetAll(ctx, 100, count)\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Len(t, pols3, 0)\n\n\t\t\tfound := map[string]int{}\n\t\t\tfor _, got := range pols {\n\t\t\t\tfor _, expect := range TestManagerPolicies {\n\t\t\t\t\tif got.GetID() == expect.GetID() {\n\t\t\t\t\t\tassert.ObjectsAreEqualValues(t, reflect.DeepEqual(expect, got))\n\t\t\t\t\t\tfound[got.GetID()]++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for _, got := range pols {\n\t\t\t// \tfor _, expect := range TestManagerPolicies {\n\t\t\t// \t\t//This is a modified equality check\n\t\t\t// \t\tif got.GetID() == expect.GetID() && reflect.DeepEqual(got.GetResources(), expect.GetResources()) && reflect.DeepEqual(got.GetActions(), expect.GetActions()) {\n\t\t\t// \t\t\tfound[got.GetID()]++\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t\tassert.Len(t, found, len(TestManagerPolicies))\n\n\t\t\tfor _, f := range found {\n\t\t\t\t//This assert is supposed to pass\n\t\t\t\tassert.Equal(t, 1, f)\n\t\t\t}\n\t\t})\n\n\t\tfor i, c := range TestManagerPolicies {\n\t\t\tt.Run(fmt.Sprintf(\"case=%d/id=%s/type=delete\", i, c.GetID()), func(t *testing.T) {\n\t\t\t\tassert.NoError(t, s.Delete(ctx, c.ID))\n\n\t\t\t\t_, err := s.Get(ctx, c.GetID())\n\t\t\t\tassert.Error(t, err)\n\t\t\t})\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "manager_migrator.go",
          "type": "blob",
          "size": 0.8759765625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\ntype ManagerMigrator interface {\n\tCreate(policy Policy) (err error)\n\tMigrate() (err error)\n\tGetManager() Manager\n}\n"
        },
        {
          "name": "manager_mock_test.go",
          "type": "blob",
          "size": 5.3759765625,
          "content": "// Code generated by MockGen. DO NOT EDIT.\n// Source: github.com/ory/ladon (interfaces: Manager)\n\n// Package ladon_test is a generated GoMock package.\npackage ladon_test\n\nimport (\n\tcontext \"context\"\n\treflect \"reflect\"\n\n\tgomock \"github.com/golang/mock/gomock\"\n\tladon \"github.com/ory/ladon\"\n)\n\n// MockManager is a mock of Manager interface.\ntype MockManager struct {\n\tctrl     *gomock.Controller\n\trecorder *MockManagerMockRecorder\n}\n\n// MockManagerMockRecorder is the mock recorder for MockManager.\ntype MockManagerMockRecorder struct {\n\tmock *MockManager\n}\n\n// NewMockManager creates a new mock instance.\nfunc NewMockManager(ctrl *gomock.Controller) *MockManager {\n\tmock := &MockManager{ctrl: ctrl}\n\tmock.recorder = &MockManagerMockRecorder{mock}\n\treturn mock\n}\n\n// EXPECT returns an object that allows the caller to indicate expected use.\nfunc (m *MockManager) EXPECT() *MockManagerMockRecorder {\n\treturn m.recorder\n}\n\n// Create mocks base method.\nfunc (m *MockManager) Create(arg0 context.Context, arg1 ladon.Policy) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Create\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Create indicates an expected call of Create.\nfunc (mr *MockManagerMockRecorder) Create(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Create\", reflect.TypeOf((*MockManager)(nil).Create), arg0, arg1)\n}\n\n// Delete mocks base method.\nfunc (m *MockManager) Delete(arg0 context.Context, arg1 string) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Delete\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Delete indicates an expected call of Delete.\nfunc (mr *MockManagerMockRecorder) Delete(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Delete\", reflect.TypeOf((*MockManager)(nil).Delete), arg0, arg1)\n}\n\n// FindPoliciesForResource mocks base method.\nfunc (m *MockManager) FindPoliciesForResource(arg0 context.Context, arg1 string) (ladon.Policies, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindPoliciesForResource\", arg0, arg1)\n\tret0, _ := ret[0].(ladon.Policies)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// FindPoliciesForResource indicates an expected call of FindPoliciesForResource.\nfunc (mr *MockManagerMockRecorder) FindPoliciesForResource(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindPoliciesForResource\", reflect.TypeOf((*MockManager)(nil).FindPoliciesForResource), arg0, arg1)\n}\n\n// FindPoliciesForSubject mocks base method.\nfunc (m *MockManager) FindPoliciesForSubject(arg0 context.Context, arg1 string) (ladon.Policies, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindPoliciesForSubject\", arg0, arg1)\n\tret0, _ := ret[0].(ladon.Policies)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// FindPoliciesForSubject indicates an expected call of FindPoliciesForSubject.\nfunc (mr *MockManagerMockRecorder) FindPoliciesForSubject(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindPoliciesForSubject\", reflect.TypeOf((*MockManager)(nil).FindPoliciesForSubject), arg0, arg1)\n}\n\n// FindRequestCandidates mocks base method.\nfunc (m *MockManager) FindRequestCandidates(arg0 context.Context, arg1 *ladon.Request) (ladon.Policies, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"FindRequestCandidates\", arg0, arg1)\n\tret0, _ := ret[0].(ladon.Policies)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// FindRequestCandidates indicates an expected call of FindRequestCandidates.\nfunc (mr *MockManagerMockRecorder) FindRequestCandidates(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"FindRequestCandidates\", reflect.TypeOf((*MockManager)(nil).FindRequestCandidates), arg0, arg1)\n}\n\n// Get mocks base method.\nfunc (m *MockManager) Get(arg0 context.Context, arg1 string) (ladon.Policy, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Get\", arg0, arg1)\n\tret0, _ := ret[0].(ladon.Policy)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// Get indicates an expected call of Get.\nfunc (mr *MockManagerMockRecorder) Get(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Get\", reflect.TypeOf((*MockManager)(nil).Get), arg0, arg1)\n}\n\n// GetAll mocks base method.\nfunc (m *MockManager) GetAll(arg0 context.Context, arg1, arg2 int64) (ladon.Policies, error) {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"GetAll\", arg0, arg1, arg2)\n\tret0, _ := ret[0].(ladon.Policies)\n\tret1, _ := ret[1].(error)\n\treturn ret0, ret1\n}\n\n// GetAll indicates an expected call of GetAll.\nfunc (mr *MockManagerMockRecorder) GetAll(arg0, arg1, arg2 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"GetAll\", reflect.TypeOf((*MockManager)(nil).GetAll), arg0, arg1, arg2)\n}\n\n// Update mocks base method.\nfunc (m *MockManager) Update(arg0 context.Context, arg1 ladon.Policy) error {\n\tm.ctrl.T.Helper()\n\tret := m.ctrl.Call(m, \"Update\", arg0, arg1)\n\tret0, _ := ret[0].(error)\n\treturn ret0\n}\n\n// Update indicates an expected call of Update.\nfunc (mr *MockManagerMockRecorder) Update(arg0, arg1 interface{}) *gomock.Call {\n\tmr.mock.ctrl.T.Helper()\n\treturn mr.mock.ctrl.RecordCallWithMethodType(mr.mock, \"Update\", reflect.TypeOf((*MockManager)(nil).Update), arg0, arg1)\n}\n"
        },
        {
          "name": "matcher.go",
          "type": "blob",
          "size": 0.912109375,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\ntype matcher interface {\n\tMatches(p Policy, haystack []string, needle string) (matches bool, error error)\n}\n\nvar DefaultMatcher = NewRegexpMatcher(512)\n"
        },
        {
          "name": "matcher_regexp.go",
          "type": "blob",
          "size": 3.0966796875,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"strings\"\n\n\t\"github.com/dlclark/regexp2\"\n\t\"github.com/hashicorp/golang-lru\"\n\t\"github.com/pkg/errors\"\n\n\t\"github.com/ory/ladon/compiler\"\n)\n\nfunc NewRegexpMatcher(size int) *RegexpMatcher {\n\tif size <= 0 {\n\t\tsize = 512\n\t}\n\n\t// golang-lru only returns an error if the cache's size is 0. This, we can safely ignore this error.\n\tcache, _ := lru.New(size)\n\treturn &RegexpMatcher{\n\t\tCache: cache,\n\t}\n}\n\ntype RegexpMatcher struct {\n\t*lru.Cache\n}\n\nfunc (m *RegexpMatcher) get(pattern string) *regexp2.Regexp {\n\tif val, ok := m.Cache.Get(pattern); !ok {\n\t\treturn nil\n\t} else if reg, ok := val.(*regexp2.Regexp); !ok {\n\t\treturn nil\n\t} else {\n\t\treturn reg\n\t}\n}\n\nfunc (m *RegexpMatcher) set(pattern string, reg *regexp2.Regexp) {\n\tm.Cache.Add(pattern, reg)\n}\n\n// Matches a needle with an array of regular expressions and returns true if a match was found.\nfunc (m *RegexpMatcher) Matches(p Policy, haystack []string, needle string) (bool, error) {\n\tvar reg *regexp2.Regexp\n\tvar err error\n\tfor _, h := range haystack {\n\n\t\t// This means that the current haystack item does not contain a regular expression\n\t\tif strings.Count(h, string(p.GetStartDelimiter())) == 0 {\n\t\t\t// If we have a simple string match, we've got a match!\n\t\t\tif h == needle {\n\t\t\t\treturn true, nil\n\t\t\t}\n\n\t\t\t// Not string match, but also no regexp, continue with next haystack item\n\t\t\tcontinue\n\t\t}\n\n\t\tif reg = m.get(h); reg != nil {\n\t\t\tif matched, err := reg.MatchString(needle); err != nil {\n\t\t\t\t// according to regexp2 documentation: https://github.com/dlclark/regexp2#usage\n\t\t\t\t// The only error that the *Match* methods should return is a Timeout if you set the\n\t\t\t\t// re.MatchTimeout field. Any other error is a bug in the regexp2 package.\n\t\t\t\treturn false, errors.WithStack(err)\n\t\t\t} else if matched {\n\t\t\t\treturn true, nil\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\treg, err = compiler.CompileRegex(h, p.GetStartDelimiter(), p.GetEndDelimiter())\n\t\tif err != nil {\n\t\t\treturn false, errors.WithStack(err)\n\t\t}\n\n\t\tm.set(h, reg)\n\t\tif matched, err := reg.MatchString(needle); err != nil {\n\t\t\t// according to regexp2 documentation: https://github.com/dlclark/regexp2#usage\n\t\t\t// The only error that the *Match* methods should return is a Timeout if you set the\n\t\t\t// re.MatchTimeout field. Any other error is a bug in the regexp2 package.\n\t\t\treturn false, errors.WithStack(err)\n\t\t} else if matched {\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n"
        },
        {
          "name": "metric.go",
          "type": "blob",
          "size": 1.2412109375,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\n// Metric is used to expose metrics about authz\ntype Metric interface {\n\t// RequestDeniedBy is called when we get explicit deny by policy\n\tRequestDeniedBy(Request, Policy)\n\t// RequestAllowedBy is called when a matching policy has been found.\n\tRequestAllowedBy(Request, Policies)\n\t// RequestNoMatch is called when no policy has matched our request\n\tRequestNoMatch(Request)\n\t// RequestProcessingError is called when unexpected error occured\n\tRequestProcessingError(Request, Policy, error)\n}\n"
        },
        {
          "name": "metric_noop.go",
          "type": "blob",
          "size": 1.197265625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\n// MetricNoOp is the default metrics implementation , that tracks nothing.\ntype MetricNoOp struct{}\n\nfunc (*MetricNoOp) RequestDeniedBy(r Request, p Policy)                   {}\nfunc (*MetricNoOp) RequestAllowedBy(r Request, p Policies)                {}\nfunc (*MetricNoOp) RequestNoMatch(r Request)                              {}\nfunc (*MetricNoOp) RequestProcessingError(r Request, p Policy, err error) {}\n\nvar DefaultMetric = &MetricNoOp{}\n"
        },
        {
          "name": "policy.go",
          "type": "blob",
          "size": 5.1533203125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport (\n\t\"encoding/json\"\n\n\t\"github.com/pkg/errors\"\n)\n\n// Policies is an array of policies.\ntype Policies []Policy\n\n// Policy represent a policy model.\ntype Policy interface {\n\t// GetID returns the policies id.\n\tGetID() string\n\n\t// GetDescription returns the policies description.\n\tGetDescription() string\n\n\t// GetSubjects returns the policies subjects.\n\tGetSubjects() []string\n\n\t// AllowAccess returns true if the policy effect is allow, otherwise false.\n\tAllowAccess() bool\n\n\t// GetEffect returns the policies effect which might be 'allow' or 'deny'.\n\tGetEffect() string\n\n\t// GetResources returns the policies resources.\n\tGetResources() []string\n\n\t// GetActions returns the policies actions.\n\tGetActions() []string\n\n\t// GetConditions returns the policies conditions.\n\tGetConditions() Conditions\n\n\t// GetMeta returns the policies arbitrary metadata set by the user.\n\tGetMeta() []byte\n\n\t// GetStartDelimiter returns the delimiter which identifies the beginning of a regular expression.\n\tGetStartDelimiter() byte\n\n\t// GetEndDelimiter returns the delimiter which identifies the end of a regular expression.\n\tGetEndDelimiter() byte\n}\n\n// DefaultPolicy is the default implementation of the policy interface.\ntype DefaultPolicy struct {\n\tID          string     `json:\"id\" gorethink:\"id\"`\n\tDescription string     `json:\"description\" gorethink:\"description\"`\n\tSubjects    []string   `json:\"subjects\" gorethink:\"subjects\"`\n\tEffect      string     `json:\"effect\" gorethink:\"effect\"`\n\tResources   []string   `json:\"resources\" gorethink:\"resources\"`\n\tActions     []string   `json:\"actions\" gorethink:\"actions\"`\n\tConditions  Conditions `json:\"conditions\" gorethink:\"conditions\"`\n\tMeta        []byte     `json:\"meta\" gorethink:\"meta\"`\n}\n\n// UnmarshalJSON overwrite own policy with values of the given in policy in JSON format\nfunc (p *DefaultPolicy) UnmarshalJSON(data []byte) error {\n\tvar pol = struct {\n\t\tID          string     `json:\"id\" gorethink:\"id\"`\n\t\tDescription string     `json:\"description\" gorethink:\"description\"`\n\t\tSubjects    []string   `json:\"subjects\" gorethink:\"subjects\"`\n\t\tEffect      string     `json:\"effect\" gorethink:\"effect\"`\n\t\tResources   []string   `json:\"resources\" gorethink:\"resources\"`\n\t\tActions     []string   `json:\"actions\" gorethink:\"actions\"`\n\t\tConditions  Conditions `json:\"conditions\" gorethink:\"conditions\"`\n\t\tMeta        []byte     `json:\"meta\" gorethink:\"meta\"`\n\t}{\n\t\tConditions: Conditions{},\n\t}\n\n\tif err := json.Unmarshal(data, &pol); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t*p = *&DefaultPolicy{\n\t\tID:          pol.ID,\n\t\tDescription: pol.Description,\n\t\tSubjects:    pol.Subjects,\n\t\tEffect:      pol.Effect,\n\t\tResources:   pol.Resources,\n\t\tActions:     pol.Actions,\n\t\tConditions:  pol.Conditions,\n\t\tMeta:        pol.Meta,\n\t}\n\treturn nil\n}\n\n// UnmarshalMeta parses the policies []byte encoded metadata and stores the result in the value pointed to by v.\nfunc (p *DefaultPolicy) UnmarshalMeta(v interface{}) error {\n\tif err := json.Unmarshal(p.Meta, &v); err != nil {\n\t\treturn errors.WithStack(err)\n\t}\n\n\treturn nil\n}\n\n// GetID returns the policies id.\nfunc (p *DefaultPolicy) GetID() string {\n\treturn p.ID\n}\n\n// GetDescription returns the policies description.\nfunc (p *DefaultPolicy) GetDescription() string {\n\treturn p.Description\n}\n\n// GetSubjects returns the policies subjects.\nfunc (p *DefaultPolicy) GetSubjects() []string {\n\treturn p.Subjects\n}\n\n// AllowAccess returns true if the policy effect is allow, otherwise false.\nfunc (p *DefaultPolicy) AllowAccess() bool {\n\treturn p.Effect == AllowAccess\n}\n\n// GetEffect returns the policies effect which might be 'allow' or 'deny'.\nfunc (p *DefaultPolicy) GetEffect() string {\n\treturn p.Effect\n}\n\n// GetResources returns the policies resources.\nfunc (p *DefaultPolicy) GetResources() []string {\n\treturn p.Resources\n}\n\n// GetActions returns the policies actions.\nfunc (p *DefaultPolicy) GetActions() []string {\n\treturn p.Actions\n}\n\n// GetConditions returns the policies conditions.\nfunc (p *DefaultPolicy) GetConditions() Conditions {\n\treturn p.Conditions\n}\n\n// GetMeta returns the policies arbitrary metadata set by the user.\nfunc (p *DefaultPolicy) GetMeta() []byte {\n\treturn p.Meta\n}\n\n// GetEndDelimiter returns the delimiter which identifies the end of a regular expression.\nfunc (p *DefaultPolicy) GetEndDelimiter() byte {\n\treturn '>'\n}\n\n// GetStartDelimiter returns the delimiter which identifies the beginning of a regular expression.\nfunc (p *DefaultPolicy) GetStartDelimiter() byte {\n\treturn '<'\n}\n"
        },
        {
          "name": "policy_test.go",
          "type": "blob",
          "size": 2.884765625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\t. \"github.com/ory/ladon\"\n)\n\nvar policyConditions = Conditions{\n\t\"owner\": &EqualsSubjectCondition{},\n}\n\nvar policyCases = []*DefaultPolicy{\n\t{\n\t\tID:          \"1\",\n\t\tDescription: \"description\",\n\t\tSubjects:    []string{\"user\"},\n\t\tEffect:      AllowAccess,\n\t\tResources:   []string{\"articles:<[0-9]+>\"},\n\t\tActions:     []string{\"create\", \"update\"},\n\t\tConditions:  policyConditions,\n\t},\n\t{\n\t\tEffect:     DenyAccess,\n\t\tConditions: make(Conditions),\n\t},\n}\n\ntype TestMeta struct {\n\tKey string `json:\"key\"`\n}\n\nfunc TestHasAccess(t *testing.T) {\n\tassert.True(t, policyCases[0].AllowAccess())\n\tassert.False(t, policyCases[1].AllowAccess())\n}\n\nfunc TestMarshalling(t *testing.T) {\n\tfor k, c := range policyCases {\n\t\tt.Run(fmt.Sprintf(\"case=%d\", k), func(t *testing.T) {\n\t\t\tvar cc = DefaultPolicy{\n\t\t\t\tConditions: make(Conditions),\n\t\t\t}\n\t\t\tdata, err := json.Marshal(c)\n\t\t\tRequireError(t, false, err)\n\n\t\t\tjson.Unmarshal(data, &cc)\n\t\t\tRequireError(t, false, err)\n\t\t\tassert.Equal(t, c, &cc)\n\t\t})\n\t}\n}\n\nfunc TestMetaUnmarshalling(t *testing.T) {\n\tvar m = TestMeta{\n\t\tKey: \"test\",\n\t}\n\tvar mm TestMeta\n\tvar p = DefaultPolicy{}\n\n\tdata, err := json.Marshal(&m)\n\tRequireError(t, false, err)\n\n\tp.Meta = data\n\n\terr = p.UnmarshalMeta(&mm)\n\tRequireError(t, false, err)\n\n\tassert.Equal(t, &m, &mm)\n}\n\nfunc TestGetters(t *testing.T) {\n\tfor _, c := range policyCases {\n\t\tassert.Equal(t, c.ID, c.GetID())\n\t\tassert.Equal(t, c.Description, c.GetDescription())\n\t\tassert.Equal(t, c.Resources, c.GetResources())\n\t\tassert.Equal(t, c.Subjects, c.GetSubjects())\n\t\tassert.Equal(t, len(c.Conditions), len(c.GetConditions()))\n\t\tassert.Equal(t, c.Effect, c.GetEffect())\n\t\tassert.Equal(t, c.Actions, c.GetActions())\n\t\tassert.Equal(t, byte('<'), c.GetStartDelimiter())\n\t\tassert.Equal(t, byte('>'), c.GetEndDelimiter())\n\t}\n}\n\nfunc RequireError(t *testing.T, expectError bool, err error, args ...interface{}) {\n\tif err != nil && !expectError {\n\t\tt.Logf(\"Unexpected error: %s\\n\", err.Error())\n\t\tt.Logf(\"Arguments: %v\\n\", args)\n\t\tt.Logf(\"\\n\\n\")\n\t}\n\trequire.Equal(t, expectError, err != nil)\n}\n"
        },
        {
          "name": "warden.go",
          "type": "blob",
          "size": 1.642578125,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon\n\nimport \"context\"\n\n// Request is the warden's request object.\ntype Request struct {\n\t// Resource is the resource that access is requested to.\n\tResource string `json:\"resource\"`\n\n\t// Action is the action that is requested on the resource.\n\tAction string `json:\"action\"`\n\n\t// Subejct is the subject that is requesting access.\n\tSubject string `json:\"subject\"`\n\n\t// Context is the request's environmental context.\n\tContext Context `json:\"context\"`\n}\n\n// Warden is responsible for deciding if subject s can perform action a on resource r with context c.\ntype Warden interface {\n\t// IsAllowed returns nil if subject s can perform action a on resource r with context c or an error otherwise.\n\t//  if err := guard.IsAllowed(&Request{Resource: \"article/1234\", Action: \"update\", Subject: \"peter\"}); err != nil {\n\t//    return errors.New(\"Not allowed\")\n\t//  }\n\tIsAllowed(ctx context.Context, r *Request) error\n}\n"
        },
        {
          "name": "warden_test.go",
          "type": "blob",
          "size": 4.765625,
          "content": "/*\n * Copyright  2016-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @author\t\tAeneas Rekkas <aeneas+oss@aeneas.io>\n * @copyright \t2015-2018 Aeneas Rekkas <aeneas+oss@aeneas.io>\n * @license \tApache-2.0\n */\n\npackage ladon_test\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/golang/mock/gomock\"\n\t\"github.com/pkg/errors\"\n\t\"github.com/stretchr/testify/assert\"\n\n\t. \"github.com/ory/ladon\"\n)\n\nfunc TestWardenIsGranted(t *testing.T) {\n\tctrl := gomock.NewController(t)\n\tm := NewMockManager(ctrl)\n\tdefer ctrl.Finish()\n\n\tw := &Ladon{\n\t\tManager: m,\n\t}\n\n\tctx := context.Background()\n\n\tfor k, c := range []struct {\n\t\tr           *Request\n\t\tdescription string\n\t\tsetup       func()\n\t\texpectErr   bool\n\t}{\n\t\t{\n\t\t\tdescription: \"should fail because no policies are found for peter\",\n\t\t\tr:           &Request{Subject: \"peter\"},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{Subject: \"peter\"})).Return(Policies{}, nil)\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail because lookup failure when accessing policies for peter\",\n\t\t\tr:           &Request{Subject: \"peter\"},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{Subject: \"peter\"})).Return(Policies{}, errors.New(\"asdf\"))\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass\",\n\t\t\tr: &Request{\n\t\t\t\tSubject:  \"peter\",\n\t\t\t\tResource: \"articles:1234\",\n\t\t\t\tAction:   \"view\",\n\t\t\t},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{\n\t\t\t\t\tSubject:  \"peter\",\n\t\t\t\t\tResource: \"articles:1234\",\n\t\t\t\t\tAction:   \"view\",\n\t\t\t\t})).Return(Policies{\n\t\t\t\t\t&DefaultPolicy{\n\t\t\t\t\t\tSubjects:  []string{\"<zac|peter>\"},\n\t\t\t\t\t\tEffect:    AllowAccess,\n\t\t\t\t\t\tResources: []string{\"articles:<[0-9]+>\"},\n\t\t\t\t\t\tActions:   []string{\"view\"},\n\t\t\t\t\t},\n\t\t\t\t}, nil)\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail because subjects don't match (unlikely event)\",\n\t\t\tr: &Request{\n\t\t\t\tSubject:  \"ken\",\n\t\t\t\tResource: \"articles:1234\",\n\t\t\t\tAction:   \"view\",\n\t\t\t},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{\n\t\t\t\t\tSubject:  \"ken\",\n\t\t\t\t\tResource: \"articles:1234\",\n\t\t\t\t\tAction:   \"view\",\n\t\t\t\t})).Return(Policies{\n\t\t\t\t\t&DefaultPolicy{\n\t\t\t\t\t\tSubjects:  []string{\"<zac|peter>\"},\n\t\t\t\t\t\tEffect:    AllowAccess,\n\t\t\t\t\t\tResources: []string{\"articles:<[0-9]+>\"},\n\t\t\t\t\t\tActions:   []string{\"view\"},\n\t\t\t\t\t},\n\t\t\t\t}, nil)\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail because resources mismatch\",\n\t\t\tr: &Request{\n\t\t\t\tSubject:  \"ken\",\n\t\t\t\tResource: \"printers:321\",\n\t\t\t\tAction:   \"view\",\n\t\t\t},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{\n\t\t\t\t\tSubject:  \"ken\",\n\t\t\t\t\tResource: \"printers:321\",\n\t\t\t\t\tAction:   \"view\",\n\t\t\t\t})).Return(Policies{\n\t\t\t\t\t&DefaultPolicy{\n\t\t\t\t\t\tSubjects:  []string{\"ken\", \"peter\"},\n\t\t\t\t\t\tEffect:    AllowAccess,\n\t\t\t\t\t\tResources: []string{\"articles:<[0-9]+>\"},\n\t\t\t\t\t\tActions:   []string{\"view\"},\n\t\t\t\t\t},\n\t\t\t\t}, nil)\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"should fail because action mismatch\",\n\t\t\tr: &Request{\n\t\t\t\tSubject:  \"ken\",\n\t\t\t\tResource: \"articles:321\",\n\t\t\t\tAction:   \"view\",\n\t\t\t},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{\n\t\t\t\t\tSubject:  \"ken\",\n\t\t\t\t\tResource: \"articles:321\",\n\t\t\t\t\tAction:   \"view\",\n\t\t\t\t})).Return(Policies{\n\t\t\t\t\t&DefaultPolicy{\n\t\t\t\t\t\tSubjects:  []string{\"ken\", \"peter\"},\n\t\t\t\t\t\tEffect:    AllowAccess,\n\t\t\t\t\t\tResources: []string{\"articles:<[0-9]+>\"},\n\t\t\t\t\t\tActions:   []string{\"<foo|bar>\"},\n\t\t\t\t\t},\n\t\t\t\t}, nil)\n\t\t\t},\n\t\t\texpectErr: true,\n\t\t},\n\t\t{\n\t\t\tdescription: \"should pass\",\n\t\t\tr: &Request{\n\t\t\t\tSubject:  \"ken\",\n\t\t\t\tResource: \"articles:321\",\n\t\t\t\tAction:   \"foo\",\n\t\t\t},\n\t\t\tsetup: func() {\n\t\t\t\tm.EXPECT().FindRequestCandidates(ctx, gomock.Eq(&Request{\n\t\t\t\t\tSubject:  \"ken\",\n\t\t\t\t\tResource: \"articles:321\",\n\t\t\t\t\tAction:   \"foo\",\n\t\t\t\t})).Return(Policies{\n\t\t\t\t\t&DefaultPolicy{\n\t\t\t\t\t\tSubjects:  []string{\"ken\", \"peter\"},\n\t\t\t\t\t\tEffect:    AllowAccess,\n\t\t\t\t\t\tResources: []string{\"articles:<[0-9]+>\"},\n\t\t\t\t\t\tActions:   []string{\"<foo|bar>\"},\n\t\t\t\t\t},\n\t\t\t\t}, nil)\n\t\t\t},\n\t\t\texpectErr: false,\n\t\t},\n\t} {\n\t\tt.Run(fmt.Sprintf(\"case=%d/description=%s\", k, c.description), func(t *testing.T) {\n\t\t\tc.setup()\n\t\t\terr := w.IsAllowed(ctx, c.r)\n\t\t\tif c.expectErr {\n\t\t\t\tassert.NotNil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        }
      ]
    }
  ]
}