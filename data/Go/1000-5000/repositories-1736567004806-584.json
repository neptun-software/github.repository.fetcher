{
  "metadata": {
    "timestamp": 1736567004806,
    "page": 584,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rhysd/actionlint",
      "stars": 2913,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".codecov.yaml",
          "type": "blob",
          "size": 0.1298828125,
          "content": "# https://docs.codecov.com/docs/commit-status#disabling-a-status\ncoverage:\n  status:\n    project: off\n    patch: off\n\ncomment: false\n"
        },
        {
          "name": ".git-hooks",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.216796875,
          "content": "/testdata/** -text\n/scripts/generate-popular-actions/testdata/** -text\n/scripts/generate-webhook-events/testdata/** -text\n/scripts/generate-availability/testdata/** -text\n/scripts/generate-actionlint-matcher/test/** -text\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.283203125,
          "content": "/actionlint\n/actionlint.exe\n/.testtimestamp\n/.linttimestamp\n/.bumptimestamp\n/env.sh\n/.github/actionlint.yaml\n/.github/actionlint.yml\n/actionlint_fuzz-fuzz.zip\n/corpus\n/crashers\n/man/actionlint.1\n/man/actionlint.1.html\n/playground-dist\n/actionlint-workflow-ast\n/.git-hooks/.timestamp\n/.idea\n"
        },
        {
          "name": ".goreleaser.yaml",
          "type": "blob",
          "size": 1.5673828125,
          "content": "version: 2\n\nrelease:\n  draft: false\n  prerelease: true\n\nbefore:\n  hooks:\n    - go mod download\n\nbuilds:\n  - <<: &build_defaults\n      main: ./cmd/actionlint\n      ldflags: -s -w -X github.com/rhysd/actionlint.version={{.Version}} -X \"github.com/rhysd/actionlint.installedFrom=installed by downloading from release page\"\n      env:\n        - CGO_ENABLED=0\n    id: macos\n    goos: [darwin]\n    goarch: [amd64, arm64]\n\n  - <<: *build_defaults\n    id: linux\n    goos: [linux]\n    goarch: [386, arm, amd64, arm64]\n\n  - <<: *build_defaults\n    id: windows\n    goos: [windows]\n    goarch: [386, amd64, arm64]\n\n  - <<: *build_defaults\n    id: freebsd\n    goos: [freebsd]\n    goarch: [386, amd64]\n\nchecksum:\n  name_template: \"actionlint_{{.Version}}_checksums.txt\"\n  algorithm: sha256\n\narchives:\n  - <<: &archives_defaults\n      files:\n        - README.md\n        - LICENSE.txt\n        - docs\n        - man/actionlint.1\n    id: nix\n    builds: [macos, linux, freebsd]\n    format: tar.gz\n  - <<: *archives_defaults\n    id: windows\n    builds: [windows]\n    format: zip\n\nbrews:\n  - name: actionlint\n    repository:\n      owner: rhysd\n      name: actionlint\n    directory: HomebrewFormula\n    commit_author:\n      name: 'github-actions[bot]'\n      email: '41898282+github-actions[bot]@users.noreply.github.com'\n    homepage: https://github.com/rhysd/actionlint#readme\n    description: Static checker for GitHub Actions workflow files\n    license: MIT\n    install: |\n      bin.install \"actionlint\"\n      man1.install \"man/actionlint.1\"\n    test: |\n      system \"#{bin}/actionlint -version\"\n\nchangelog:\n  disable: true\n"
        },
        {
          "name": ".pre-commit-hooks.yaml",
          "type": "blob",
          "size": 0.7421875,
          "content": "---\n- id: actionlint\n  name: Lint GitHub Actions workflow files\n  description: Runs actionlint to lint GitHub Actions workflow files\n  language: golang\n  types: [\"yaml\"]\n  files: ^\\.github/workflows/\n  entry: actionlint\n  minimum_pre_commit_version: 3.0.0\n- id: actionlint-docker\n  name: Lint GitHub Actions workflow files\n  description: Runs actionlint Docker image to lint GitHub Actions workflow files\n  language: docker_image\n  types: [\"yaml\"]\n  files: ^\\.github/workflows/\n  entry: docker.io/rhysd/actionlint:1.7.6\n- id: actionlint-system\n  name: Lint GitHub Actions workflow files\n  description: Runs system-installed actionlint to lint GitHub Actions workflow files\n  language: system\n  types: [\"yaml\"]\n  files: ^\\.github/workflows/\n  entry: actionlint\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 117.2265625,
          "content": "<a id=\"v1.7.6\"></a>\n# [v1.7.6](https://github.com/rhysd/actionlint/releases/tag/v1.7.6) - 2025-01-04\n\n- Using contexts at specific workflow keys is incorrectly reported as not allowed. Affected workflow keys are as follows. ([#495](https://github.com/rhysd/actionlint/issues/495), [#497](https://github.com/rhysd/actionlint/issues/497), [#498](https://github.com/rhysd/actionlint/issues/498), [#500](https://github.com/rhysd/actionlint/issues/500))\n  - `jobs.<job_id>.steps.with.args`\n  - `jobs.<job_id>.steps.with.entrypoint`\n  - `jobs.<job_id>.services.<service_id>.env`\n- Update Go dependencies to the latest.\n\n[Changes][v1.7.6]\n\n\n<a id=\"v1.7.5\"></a>\n# [v1.7.5](https://github.com/rhysd/actionlint/releases/tag/v1.7.5) - 2024-12-28\n\n- Strictly check available contexts in `${{ }}` placeholders following the ['Context availability' table](https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs#context-availability) in the official document.\n  - For example, `jobs.<job_id>.defaults.run.shell` allows `env` context but `shell` workflow keys in other places allow no context.\n    ```yaml\n    defaults:\n      run:\n        # ERROR: No context is available here\n        shell: ${{ env.SHELL }}\n\n    jobs:\n      test:\n        runs-on: ubuntu-latest\n        defaults:\n          run:\n            # OK: 'env' context is available here\n            shell: ${{ env.SHELL }}\n        steps:\n          - run: echo hello\n            # ERROR: No context is available here\n            shell: ${{ env.SHELL}}\n    ```\n- Check a string literal passed to `fromJSON()` call. This pattern is [popular](https://github.com/search?q=fromJSON%28%27+lang%3Ayaml&type=code) to create array or object constants because GitHub Actions does not provide the literal syntax for them. See the [document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#contexts-and-built-in-functions) for more details. ([#464](https://github.com/rhysd/actionlint/issues/464))\n  ```yaml\n  jobs:\n    test:\n      # ERROR: Key 'mac' does not exist in the object returned by the fromJSON()\n      runs-on: ${{ fromJSON('{\"win\":\"windows-latest\",\"linux\":\"ubuntul-latest\"}')['mac'] }}\n      steps:\n        - run: echo This is a special branch!\n          # ERROR: Broken JSON string passed to fromJSON.\n          if: contains(fromJSON('[\"main\",\"release\",\"dev\"'), github.ref_name)\n  ```\n- Allow passing command arguments to `-shellcheck` argument. ([#483](https://github.com/rhysd/actionlint/issues/483), thanks [@anuraaga](https://github.com/anuraaga))\n  - This is useful when you want to use alternative build of shellcheck like [go-shellcheck](https://github.com/wasilibs/go-shellcheck/).\n    ```sh\n    actionlint -shellcheck=\"go run github.com/wasilibs/go-shellcheck/cmd/shellcheck@latest\"\n    ```\n- Support undocumented `repository_visibility`, `artifact_cache_size_limit`, `step_summary`, `output`, `state` properties in `github` context. ([#489](https://github.com/rhysd/actionlint/issues/489), thanks [@rasa](https://github.com/rasa) for adding `repository_visibility` property)\n- Remove `macos-12` runner label from known labels because it was [dropped](https://github.com/actions/runner-images/issues/10721) from GitHub-hosted runners on Dec. 3 and is no longer available.\n- Add `windows-2025` runner label to the known labels. The runner is in [public preview](https://github.blog/changelog/2024-12-19-windows-server-2025-is-now-in-public-preview/). ([#491](https://github.com/rhysd/actionlint/issues/491), thanks [@ericcornelissen](https://github.com/ericcornelissen))\n- Add `black` to the list of colors for `branding.color` action metadata. ([#485](https://github.com/rhysd/actionlint/issues/485), thanks [@eifinger](https://github.com/eifinger))\n- Add `table` to the list of icons for `branding.icon` action metadata.\n- Fix parsing escaped `{` in `format()` function call's first argument.\n- Fix the incorrect `join()` function overload. `join(s1: string, s2: string)` was wrongly accepted.\n- Update popular actions data set to the latest.\n  - Add `download-artifact/v3-node20` to the data set. ([#468](https://github.com/rhysd/actionlint/issues/468))\n  - Fix missing the `reviewdog/action-hadolint@v1` action input. ([#487](https://github.com/rhysd/actionlint/issues/487), thanks [@mi-wada](https://github.com/mi-wada))\n- Link to the documents of the stable version in actionlint `man` page and `-help` output.\n- Refactor `LintStdin()` API example and some unit tests. ([#472](https://github.com/rhysd/actionlint/issues/472), [#475](https://github.com/rhysd/actionlint/issues/475), thanks [@alexandear](https://github.com/alexandear))\n- Improve the configuration example in `actionlint.yaml` document to explain glob patterns for `paths`. ([#481](https://github.com/rhysd/actionlint/issues/481))\n\n[Changes][v1.7.5]\n\n\n<a id=\"v1.7.4\"></a>\n# [v1.7.4](https://github.com/rhysd/actionlint/releases/tag/v1.7.4) - 2024-11-04\n\n- Disallow the usage of popular actions that run on `node16` runner. The `node16` runner [will reach the end of life on November 12](https://github.blog/changelog/2024-09-25-end-of-life-for-actions-node16/).\n  - In case of the error, please update your actions to the latest version so that they run on the latest `node20` runner.\n  - If you're using self-hosted runner and you cannot upgrade your runner to `node20` soon, please consider to ignore the error by the `paths` configuration described below.\n  - If you're using `actions/upload-artifact@v3` and `actions/download-artifact@v3` on GHES, please replace them with `actions/upload-artifact@v3-node20` and `actions/download-artifact@v3-node20`. ([#468](https://github.com/rhysd/actionlint/issues/468))\n- Provide the configuration for ignoring errors by regular expressions in `actionlint.yml` (or `actionlint.yaml`). Please see the [document](https://github.com/rhysd/actionlint/blob/v1.7.4/docs/config.md) for more details. ([#217](https://github.com/rhysd/actionlint/issues/217), [#342](https://github.com/rhysd/actionlint/issues/342))\n  - The `paths` is a mapping from the file path glob pattern to the corresponding configuration. The `ignore` configuration is a list of regular expressions to match error messages (similar to the `-ignore` command line option).\n    ```yaml\n    paths:\n      # This pattern matches any YAML file under the '.github/workflows/' directory.\n      .github/workflows/**/*.yaml:\n        ignore:\n          # Ignore the specific error from shellcheck\n          - 'shellcheck reported issue in this script: SC2086:.+'\n      # This pattern only matches '.github/workflows/release.yaml' file.\n      .github/workflows/release.yaml:\n        ignore:\n          # Ignore errors from the old runner check. This may be useful for (outdated) self-hosted runner environment.\n          - 'the runner of \".+\" action is too old to run on GitHub Actions'\n    ```\n  - This configuration was not implemented initially because I wanted to keep the configuration as minimal as possible. However, due to several requests for it, the configuration has now been added.\n- Untrusted inputs check is safely skipped inside specific function calls. ([#459](https://github.com/rhysd/actionlint/issues/459), thanks [@IlyaGulya](https://github.com/IlyaGulya))\n  - For example, the following step contains the untrusted input `github.head_ref`, but it is safe because it's passed to the `contains()` argument.\n    ```yaml\n    - run: echo \"is_release_branch=${{ contains(github.head_ref, 'release') }}\" >> \"$GITHUB_OUTPUT\"\n    ```\n  - For more details, please read the [rule document](https://github.com/rhysd/actionlint/blob/v1.7.4/docs/checks.md#untrusted-inputs).\n- Recognize `gcr.io` and `gcr.dev` as the correct container registry hosts. ([#463](https://github.com/rhysd/actionlint/issues/463), thanks [@takaidohigasi](https://github.com/takaidohigasi))\n  - Note that it is recommended explicitly specifying the scheme like `docker://gcr.io/...`.\n- Remove `macos-x.0` runner labels which are no longer available. ([#452](https://github.com/rhysd/actionlint/issues/452))\n- Disable shellcheck [`SC2043`](https://www.shellcheck.net/wiki/SC2043) rule because it can cause false positives on checking `run:`. ([#355](https://github.com/rhysd/actionlint/issues/355))\n  - The [rule document](https://github.com/rhysd/actionlint/blob/v1.7.4/docs/checks.md#check-shellcheck-integ) was updated as well. ([#466](https://github.com/rhysd/actionlint/issues/466), thanks [@risu729](https://github.com/risu729))\n- Fix the error message was not deterministic when detecting cycles in `needs` dependencies.\n- Fix the check for `format()` function was not applied when the function name contains upper case like `Format()`. Note that function names in `${{ }}` placeholders are case-insensitive.\n- Update the popular actions data set to the latest.\n  - This includes the [new `ref` and `commit` outputs](https://github.com/actions/checkout/pull/1180) of `actions/checkout`.\n- Add [`actions/cache/save`](https://github.com/actions/cache/tree/main/save) and [`actions/cache/restore`](https://github.com/actions/cache/tree/main/restore) to the popular actions data set.\n- Links in the [README.md](https://github.com/rhysd/actionlint/blob/main/README.md) now point to the document of the latest version tag instead of HEAD of `main` branch.\n- Add [`Linter.LintStdin`](https://pkg.go.dev/github.com/rhysd/actionlint#Linter.LintStdin) method dedicated to linting STDIN instead of handling STDIN in `Command`.\n- (Dev) Add new [`check-checks` script](https://github.com/rhysd/actionlint/tree/main/scripts/check-checks) to maintain the ['Checks' document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md). It automatically updates the outputs and playground links for example inputs in the document. It also checks the document is up-to-date on CI. Please read the [document](https://github.com/rhysd/actionlint/blob/main/scripts/check-checks/README.md) for more details.\n\n[Documentation](https://github.com/rhysd/actionlint/tree/v1.7.4/docs)\n\n[Changes][v1.7.4]\n\n\n<a id=\"v1.7.3\"></a>\n# [v1.7.3](https://github.com/rhysd/actionlint/releases/tag/v1.7.3) - 2024-09-29\n\n- Remove `macos-11` runner labels because [macOS 11 runner was dropped on 6/28/2024](https://github.blog/changelog/2024-05-20-actions-upcoming-changes-to-github-hosted-macos-runners/#macos-11-deprecation-and-removal). ([#451](https://github.com/rhysd/actionlint/issues/451), thanks [@muzimuzhi](https://github.com/muzimuzhi))\n- Support `macos-15`, `macos-15-large`, and `macos-15-xlarge` runner labels. The macOS 15 runner is not globally available yet, but [they are available in beta](https://github.com/actions/runner-images?tab=readme-ov-file#available-images). ([#453](https://github.com/rhysd/actionlint/issues/453), thanks [@muzimuzhi](https://github.com/muzimuzhi))\n- Release artifact includes checksums for the released binaries. The file name is `actionlint_{version}_checksums.txt`. ([#449](https://github.com/rhysd/actionlint/issues/449))\n  - For example, the checksums for v1.7.3 can be found [here](https://github.com/rhysd/actionlint/releases/download/v1.7.3/actionlint_1.7.3_checksums.txt).\n- Fix `download-path` output is missing in `actions/download-artifact@v3` action. ([#442](https://github.com/rhysd/actionlint/issues/442))\n  - Note that the latest version `actions/download-artifact@v4` was not affected by this issue.\n- Support Go 1.23.\n\n[Documentation](https://github.com/rhysd/actionlint/blob/v1.7.3/docs/checks.md)\n\n[Changes][v1.7.3]\n\n\n<a id=\"v1.7.2\"></a>\n# [v1.7.2](https://github.com/rhysd/actionlint/releases/tag/v1.7.2) - 2024-09-23\n\n- Fix child processes to run in parallel.\n- Update the popular actions data set to the latest. ([#442](https://github.com/rhysd/actionlint/issues/442), [#445](https://github.com/rhysd/actionlint/issues/445), [#446](https://github.com/rhysd/actionlint/issues/446), [#447](https://github.com/rhysd/actionlint/issues/447), thanks [@maikelvdh](https://github.com/maikelvdh))\n- Add support for checking branch filters on [`merge_group` event](https://docs.github.com/en/actions/writing-workflows/choosing-when-your-workflow-runs/events-that-trigger-workflows#merge_group). ([#448](https://github.com/rhysd/actionlint/issues/448), thanks [@muzimuzhi](https://github.com/muzimuzhi))\n- [The playground](https://rhysd.github.io/actionlint/) now supports both light and dark modes and automatically applies the system's theme.\n- Fix releasing a failure on making a new winget package. ([#438](https://github.com/rhysd/actionlint/issues/438), thanks [@vedantmgoyal9](https://github.com/vedantmgoyal9))\n\n[Changes][v1.7.2]\n\n\n<a id=\"v1.7.1\"></a>\n# [v1.7.1](https://github.com/rhysd/actionlint/releases/tag/v1.7.1) - 2024-05-28\n\n- Support `ubuntu-24.04` runner label, which was [recently introduced as beta](https://github.blog/changelog/2024-05-14-github-hosted-runners-public-beta-of-ubuntu-24-04-is-now-available/). ([#425](https://github.com/rhysd/actionlint/issues/425), thanks [@bitcoin-tools](https://github.com/bitcoin-tools))\n- Remove the support for `macos-10` runner label which was [officially dropped about 2 years ago](https://github.blog/changelog/2022-07-20-github-actions-the-macos-10-15-actions-runner-image-is-being-deprecated-and-will-be-removed-by-8-30-22/).\n- Remove the support for `windows-2016` runner label which was [officially dropped about 2 years ago](https://github.blog/changelog/2021-10-19-github-actions-the-windows-2016-runner-image-will-be-removed-from-github-hosted-runners-on-march-15-2022/).\n- Document URLs used in help output and links in the playground prefer specific version tag rather than `main` branch. For example,\n  - Before: https://github.com/rhysd/actionlint/tree/main/docs\n  - After: https://github.com/rhysd/actionlint/tree/v1.7.1/docs\n- Fix actionlint wrongly reports an error when using `ghcr.io` or `docker.io` at `image` field of action metadata file of Docker action without `docker://` scheme. ([#428](https://github.com/rhysd/actionlint/issues/428))\n  ```yaml\n  runs:\n    using: 'docker'\n    # This should be OK\n    image: 'ghcr.io/user/repo:latest'\n  ```\n- Fix checking `preactjs/compressed-size-action@v2` usage caused a false positive. ([#422](https://github.com/rhysd/actionlint/issues/422))\n- Fix an error message when invalid escaping is found in globs.\n- The design of the [playground page](https://rhysd.github.io/actionlint/) is overhauled following the upgrade of bulma package to v1.\n  - Current actionlint version is shown in the heading.\n  - The color theme is changed to the official dark theme.\n  - The list of useful links is added to the bottom of the page as 'Resources' section.\n\n[Changes][v1.7.1]\n\n\n<a id=\"v1.7.0\"></a>\n# [v1.7.0](https://github.com/rhysd/actionlint/releases/tag/v1.7.0) - 2024-05-08\n\n- From this version, actionlint starts to check action metadata file `action.yml` (or `action.yaml`). At this point, only very basic checks are implemented and contents of `steps:` are not checked yet.\n  - It checks properties under `runs:` section (e.g. `main:` can be specified when it is a JavaScript action), `branding:` properties, and so on.\n    ```yaml\n    name: 'My action'\n    author: '...'\n    # ERROR: 'description' section is missing\n\n    branding:\n      # ERROR: Invalid icon name\n      icon: dog\n\n    runs:\n      # ERROR: Node.js runtime version is too old\n      using: 'node12'\n      # ERROR: The source file being run by this action does not exist\n      main: 'this-file-does-not-exist.js'\n      # ERROR: 'env' configuration is only allowed for Docker actions\n      env:\n        SOME_VAR: SOME_VALUE\n    ```\n  - actionlint still focuses on checking workflow files. So there is no way to directly specify `action.yml` as an argument of `actionlint` command. actionlint checks all local actions which are used by given workflows. If you want to use actionlint for your action development, prepare a test/example workflow which uses your action, and check it with actionlint instead.\n  - Checks for `steps:` contents are planned to be implemented. Since several differences are expected between `steps:` in workflow file and `steps:` in action metadata file (e.g. available contexts), the implementation is delayed to later version. And the current implementation of action metadata parser is ad hoc. I'm planning a large refactorying and breaking changes Go API around it are expected.\n- Add `runner.environment` property. ([#412](https://github.com/rhysd/actionlint/issues/412))\n  ```yaml\n  - run: echo 'Run by GitHub-hosted runner'\n    if: runner.environment == 'github-hosted'\n  ```\n- Using outdated popular actions is now detected at error. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#detect-outdated-popular-actions) for more details.\n  - Here 'outdated' means actions which use runtimes no longer supported by GitHub-hosted runners such as `node12`.\n    ```yaml\n    # ERROR: actions/checkout@v2 is using the outdated runner 'node12'\n    - uses: actions/checkout@v2\n    ```\n- Support `attestations` permission which was [recently added to GitHub Actions as beta](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds). ([#418](https://github.com/rhysd/actionlint/issues/418), thanks [@bdehamer](https://github.com/bdehamer))\n  ```yaml\n  permissions:\n    id-token: write\n    contents: read\n    attestations: write\n  ```\n- Check comparison expressions more strictly. Arbitrary types of operands can be compared as [the official document](https://docs.github.com/en/actions/learn-github-actions/expressions#operators) explains. However, comparisons between some types are actually meaningless because the values are converted to numbers implicitly. actionlint catches such meaningless comparisons as errors. Please see [the check document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-comparison-types) for more details.\n  ```yaml\n  on:\n    workflow_call:\n      inputs:\n        timeout:\n          type: boolean\n\n  jobs:\n    test:\n      runs-on: ubuntu-latest\n      steps:\n        - run: echo 'called!'\n          # ERROR: Comparing string to object is always evaluated to false\n          if: ${{ github.event == 'workflow_call' }}\n        - run: echo 'timeout is too long'\n          # ERROR: Comparing boolean value with `>` doesn't make sense\n          if: ${{ inputs.timeout > 60 }}\n  ```\n- Follow the update that `macos-latest` is now an alias to `macos-14` runner.\n- Support a custom python shell by `pyflakes` rule.\n- Add workaround actionlint reports that `dorny/paths-filter`'s `predicate-quantifier` input is not defined. ([#416](https://github.com/rhysd/actionlint/issues/416))\n- Fix the type of a conditional expression by comparison operators is wider than expected by implementing type narrowing. ([#384](https://github.com/rhysd/actionlint/issues/384))\n  - For example, the type of following expression should be `number` but it was actually `string | number` and actionlint complained that `timeout-minutes` must take a number value.\n    ```yaml\n    timeout-minutes: ${{ env.FOO && 10 || 60 }}\n    ```\n- Fix `${{ }}` placeholder is not available at `jobs.<job_id>.services`. ([#402](https://github.com/rhysd/actionlint/issues/402))\n  ```yaml\n  jobs:\n    test:\n      services: ${{ fromJSON('...') }}\n      runs-on: ubuntu-latest\n      steps:\n        - run: ...\n  ```\n- Do not check outputs of `google-github-actions/get-secretmanager-secrets` because this action sets outputs dynamically. ([#404](https://github.com/rhysd/actionlint/issues/404))\n- Fix `defaults.run` is ignored on detecting the shell used in `run:`. ([#409](https://github.com/rhysd/actionlint/issues/409))\n  ```yaml\n  defaults:\n    run:\n      shell: pwsh\n  jobs:\n    test:\n      runs-on: ubuntu-latest\n      steps:\n        # This was wrongly detected as bash script\n        - run: $Env:FOO = \"FOO\"\n  ```\n- Fix parsing a syntax error reported from pyflakes when checking a Python script in `run:`. ([#411](https://github.com/rhysd/actionlint/issues/411))\n  ```yaml\n  - run: print(\n    shell: python\n  ```\n- Skip checking `exclude:` items in `matrix:` when they are constructed from `${{ }}` dynamically. ([#414](https://github.com/rhysd/actionlint/issues/414))\n  ```yaml\n  matrix:\n    foo: ['a', 'b']\n    exclude:\n      # actionlint complained this value didn't exist in matrix combinations\n      - foo: ${{ env.EXCLUDE_FOO }}\n  ```\n- Fix checking `exclude:` items when `${{ }}` is used in nested arrays at matrix items.\n  ```yaml\n  matrix:\n    foo:\n      - [\"${{ fromJSON('...') }}\"]\n    exclude:\n      # actionlint complained this value didn't match to any matrix combinations\n      - foo: ['foo']\n  ```\n- Update popular actions data set. New major versions are added and the following actions are newly added.\n  - `peaceiris/actions-hugo`\n  - `actions/attest-build-provenance`\n  - `actions/add-to-project`\n  - `octokit/graphql-action`\n- Update Go dependencies to the latest.\n- Reduce the size of `actionlint` executable by removing redundant data from popular actions data set.\n  - x86_64 executable binary size was reduced from 6.9MB to 6.7MB (2.9% smaller).\n  - Wasm binary size was reduced from 9.4MB to 8.9MB (5.3% smaller).\n- Describe how to [integrate actionlint to Pulsar Edit](https://web.pulsar-edit.dev/packages/linter-github-actions) in [the document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#pulsar-edit). ([#408](https://github.com/rhysd/actionlint/issues/408), thanks [@mschuchard](https://github.com/mschuchard))\n- Update outdated action versions in the usage document. ([#413](https://github.com/rhysd/actionlint/issues/413), thanks [@naglis](https://github.com/naglis))\n\n[Changes][v1.7.0]\n\n\n<a id=\"v1.6.27\"></a>\n# [v1.6.27](https://github.com/rhysd/actionlint/releases/tag/v1.6.27) - 2024-02-24\n\n- Add macOS 14 runner labels for [Apple Silicon support](https://github.blog/changelog/2024-01-30-github-actions-macos-14-sonoma-is-now-available/). The following labels are added. (thanks [@harryzcy](https://github.com/harryzcy), [#392](https://github.com/rhysd/actionlint/issues/392))\n  - `macos-14`\n  - `macos-14-xlarge`\n  - `macos-14-large`\n- Remove `ubuntu-18.04` runner label from runners list since [it is no longer supported](https://github.blog/changelog/2022-08-09-github-actions-the-ubuntu-18-04-actions-runner-image-is-being-deprecated-and-will-be-removed-by-12-1-22/). ([#363](https://github.com/rhysd/actionlint/issues/363))\n- Allow glob patterns in `self-hosted-runner.labels` configuration. For example, the following configuration defines any runner labels prefixed with `private-linux-`. (thanks [@kishaningithub](https://github.com/kishaningithub), [#378](https://github.com/rhysd/actionlint/issues/378))\n  ```yaml\n  self-hosted-runner:\n    labels:\n      - private-linux-*\n  ```\n- Fix a race condition bug when `-format` option is used for linting multiple workflow files. Thanks [@ReinAchten-TomTom](https://github.com/ReinAchten-TomTom) for your help on the investigation. ([#370](https://github.com/rhysd/actionlint/issues/370))\n- Fix a race condition due to conflicts between some goroutine which starts to run shellcheck process and other goroutine which starts to wait until all processes finish.\n- The popular actions data set was updated to the latest and the following actions were newly added. (thanks [@jmarshall](https://github.com/jmarshall), [#380](https://github.com/rhysd/actionlint/issues/380))\n  - `google-github-actions/auth`\n  - `google-github-actions/get-secretmanager-secrets`\n  - `google-github-actions/setup-gcloud`\n  - `google-github-actions/upload-cloud-storage`\n  - `pulumi/actions`\n  - `pypa/gh-action-pypi-publish`\n- Add support for larger runner labels. The following labels are added. (thanks [@therealdwright](https://github.com/therealdwright), [#371](https://github.com/rhysd/actionlint/issues/371))\n  - `windows-latest-8-cores`\n  - `ubuntu-latest-4-cores`\n  - `ubuntu-latest-8-cores`\n  - `ubuntu-latest-16-cores`\n- The following WebHook types are supported for `pull_request` event.\n  - `enqueued`\n  - `dequeued`\n  - `milestoned`\n  - `demilestoned`\n- Explain how to control shellckeck behavior in the [shellcheck rule document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-shellcheck-integ). Use `SHELLCHECK_OPTS` environment variable to pass arguments to shellcheck. See [the shellcheck's official document](https://github.com/koalaman/shellcheck/wiki/Integration#environment-variables) for more details.\n  ```\n  # Enable some optional rules\n  SHELLCHECK_OPTS='--enable=avoid-nullary-conditions' actionlint\n  # Disable some rules\n  SHELLCHECK_OPTS='--exclude=SC2129' actionlint\n  ```\n- Explicitly specify `docker.io` host name in pre-commit hook. (thanks [@gotmax23](https://github.com/gotmax23), [#382](https://github.com/rhysd/actionlint/issues/382))\n- Explain how to report issues and send patches in [CONTRIBUTING.md](https://github.com/rhysd/actionlint/blob/main/CONTRIBUTING.md).\n- Fix the link to super-linter project. (thanks [@zkoppert](https://github.com/zkoppert), [#376](https://github.com/rhysd/actionlint/issues/376))\n- Add the instruction to install actionlint via the Arch Linux's official repository. (thanks [@sorairolake](https://github.com/sorairolake), [#381](https://github.com/rhysd/actionlint/issues/381))\n- Prefer fixed revisions in the pre-commit usage. (thanks [@corneliusroemer](https://github.com/corneliusroemer), [#354](https://github.com/rhysd/actionlint/issues/354))\n- Add instructions to use actionlint with Emacs. (thanks [@tirimia](https://github.com/tirimia), [#341](https://github.com/rhysd/actionlint/issues/341))\n- Add instructions to use actionlint with Vim and Neovim text editors.\n- Add [`actionlint.RuleBase.Config`](https://pkg.go.dev/github.com/rhysd/actionlint#RuleBase.Config) method to get the actionlint configuration passed to rules. (thanks [@hugo-syn](https://github.com/hugo-syn), [#387](https://github.com/rhysd/actionlint/issues/387))\n- Add [`actionlint.ContainsExpression`](https://pkg.go.dev/github.com/rhysd/actionlint#ContainsExpression) function to check if the given string contains `${{ }}` placeholders or not. (thanks [@hugo-syn](https://github.com/hugo-syn), [#388](https://github.com/rhysd/actionlint/issues/388))\n- Support Go 1.22 and set the minimum supported Go version to 1.18 for `x/sys` package.\n- Update Go dependencies to the latest.\n\n[Changes][v1.6.27]\n\n\n<a id=\"v1.6.26\"></a>\n# [v1.6.26](https://github.com/rhysd/actionlint/releases/tag/v1.6.26) - 2023-09-18\n\n- Several template fields and template actions were added. All fields and actions are listed in [the document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#format-error-messages). Please read it for more details. ([#311](https://github.com/rhysd/actionlint/issues/311))\n  - By these additions, now actionlint can output the result in [the SARIF format](https://docs.oasis-open.org/sarif/sarif/v2.1.0/sarif-v2.1.0.html). SARIF is a format for the output of static analysis tools used by [GitHub CodeQL](https://codeql.github.com/). [the example Go template](https://github.com/rhysd/actionlint/blob/main/testdata/format/sarif_template.txt) to format actionlint output in SARIF.\n    ```sh\n    actionlint -format \"$(cat /path/to/sarif_template.txt)\" > output.json\n    ```\n  - `allKinds` returns the kinds (lint rules) information as an array. You can include what lint rules are defined in the command output.\n  - `toPascalCase` converts snake case (`foo_bar`) or kebab case (`foo-bar`) into pascal case (`FooBar`).\n- Report an error when the condition at `if:` is always evaluated to true. See [the check document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#if-cond-always-true) to know more details. ([#272](https://github.com/rhysd/actionlint/issues/272))\n  ```yaml\n  # ERROR: All the following `if:` conditions are always evaluated to true\n  - run: echo 'Commit is pushed'\n    if: |\n      ${{ github.event_name == 'push' }}\n  - run: echo 'Commit is pushed'\n    if: \"${{ github.event_name == 'push' }} \"\n  - run: echo 'Commit is pushed to main'\n    if: ${{ github.event_name == 'push' }} && ${{ github.ref_name == 'main' }}\n  ```\n- Fix actionlint didn't understand `${{ }}` placeholders in environment variable names. ([#312](https://github.com/rhysd/actionlint/issues/312))\n  ```yaml\n  env:\n    \"${{ steps.x.outputs.value }}\": \"...\"\n  ```\n- Fix type of matrix row when some expression is assigned to it with `${{ }}` ([#285](https://github.com/rhysd/actionlint/issues/285))\n  ```yaml\n  strategy:\n    matrix:\n      test:\n        # Matrix rows are assigned from JSON string\n        - ${{ fromJson(inputs.matrix) }}\n  steps:\n    - run: echo ${{ matrix.test.foo.bar }}\n  ```\n- Fix checking `exclude` of matrix was incorrect when some matrix row is dynamically constructed with `${{ }}`. ([#261](https://github.com/rhysd/actionlint/issues/261))\n  ```yaml\n  strategy:\n    matrix:\n      build-type:\n        - debug\n        - ${{ fromJson(inputs.custom-build-type) }}\n      exclude:\n        # 'release' is not listed in 'build-type' row, but it should not be reported as error\n        # since the second row of 'build-type' is dynamically constructed with ${{ }}.\n        - build-type: release\n  ```\n- Fix checking `exclude` of matrix was incorrect when object is nested at row of the matrix. ([#249](https://github.com/rhysd/actionlint/issues/249))\n  ```yaml\n  matrix:\n    os:\n      - name: Ubuntu\n        matrix: ubuntu\n      - name: Windows\n        matrix: windows\n    arch:\n      - name: ARM\n        matrix: arm\n      - name: Intel\n        matrix: intel\n    exclude:\n      # This should exclude { os: { name: Windows, matrix: windows }, arch: {name: ARM, matrix: arm } }\n      - os:\n          matrix: windows\n        arch:\n          matrix: arm\n  ```\n- Fix data race when `actionlint.yml` config file is used by multiple goroutines to check multiple workflow files. ([#333](https://github.com/rhysd/actionlint/issues/333))\n- Check keys' case sensitivity. ([#302](https://github.com/rhysd/actionlint/issues/302))\n  ```yaml\n  steps:\n    # ERROR: 'run:' is correct\n    - ruN: echo \"hello\"\n  ```\n- Add `number` as [input type of `workflow_dispatch` event](https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context). ([#316](https://github.com/rhysd/actionlint/issues/316))\n- Check max number of inputs of `workflow_dispatch` event is 10.\n- Check numbers at `timeout-minutes` and `max-parallel` are greater than zero.\n- Add Go APIs to define a custom rule. Please read [the code example](https://pkg.go.dev/github.com/rhysd/actionlint/#example_Linter_yourOwnRule) to know the usage.\n  - Make some [`RuleBase`](https://pkg.go.dev/github.com/rhysd/actionlint#RuleBase) methods public which are useful to implement your own custom rule type. (thanks [@hugo-syn](https://github.com/hugo-syn), [#327](https://github.com/rhysd/actionlint/issues/327), [#331](https://github.com/rhysd/actionlint/issues/331))\n  - `OnRulesCreated` field is added to [`LinterOptions`](https://pkg.go.dev/github.com/rhysd/actionlint#LinterOptions) struct. You can modify applied rules with the hook (add your own rule, remove some rule, ...).\n- Add `NewProject()` Go API to create a [`Project`](https://pkg.go.dev/github.com/rhysd/actionlint#Project) instance.\n- Fix tests failed when sources are downloaded from `.tar.gz` link. ([#307](https://github.com/rhysd/actionlint/issues/307))\n- Improve [the pre-commit document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#pre-commit) to explain all pre-commit hooks by this repository.\n- Clarify the regular expression syntax of `-ignore` option is [RE2](https://github.com/google/re2/wiki/Syntax). ([#320](https://github.com/rhysd/actionlint/issues/320))\n- Use ubuntu-latest runner to create winget release. (thanks [@sitiom](https://github.com/sitiom), [#308](https://github.com/rhysd/actionlint/issues/308))\n- Update popular actions data set, available contexts, webhook types to the latest.\n  - Fix typo in `watch` webhook's types (thanks [@suzuki-shunsuke](https://github.com/suzuki-shunsuke), [#334](https://github.com/rhysd/actionlint/issues/334))\n  - Add `secret_source` property to [`github` context](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context). (thanks [@asml-mdroogle](https://github.com/asml-mdroogle), [#339](https://github.com/rhysd/actionlint/issues/339))\n  - Many new major releases are added to the popular actions data set (including `actions/checkout@v4`).\n- Use Go 1.21 to build release binaries.\n- Update Go dependencies to the latest. (thanks [@harryzcy](https://github.com/harryzcy), [#322](https://github.com/rhysd/actionlint/issues/322))\n\n[Changes][v1.6.26]\n\n\n<a id=\"v1.6.25\"></a>\n# [v1.6.25](https://github.com/rhysd/actionlint/releases/tag/v1.6.25) - 2023-06-15\n\n- Parse new syntax at `runs-on:`. Now `runs-on:` can have `group:` and `labels:` configurations. Please read [the official document](https://docs.github.com/en/actions/using-github-hosted-runners/using-larger-runners#running-jobs-on-your-runner) for more details. ([#280](https://github.com/rhysd/actionlint/issues/280))\n  ```yaml\n  runs-on:\n    group: ubuntu-runners\n    labels: ubuntu-20.04-16core\n  ```\n- Add support for macOS XL runners. `macos-latest-xl`, `macos-13-xl`, `macos-12-xl` labels are available at `runs-on:`. ([#299](https://github.com/rhysd/actionlint/issues/299), thanks [@woa7](https://github.com/woa7))\n- Find Git project directory from `-stdin-filename` command line argument. Even if the workflow content is passed via stdin, actionlint can recognize reusable workflows depended by the workflow using file path passed at `-stdin-filename` argument. ([#283](https://github.com/rhysd/actionlint/issues/283))\n- Fix order of errors is not deterministic when multiple errors happen at the same location (file name, line number, column number). It happens only when building actionlint with Go 1.20 or later.\n- Fix type name of `watch` webhook.\n- Fix type of matrix row (property of `matrix` context) when `${{ }}` is used in the row value. ([#294](https://github.com/rhysd/actionlint/issues/294))\n- Fix `go install ./...` doesn't work. ([#297](https://github.com/rhysd/actionlint/issues/297))\n- Update `actionlint` pre-commit hook to use Go toolchain. Now pre-commit automatically installs `actionlint` command so you don't need to install it manually. Note that this hook requires pre-commit v3.0.0 or later. For those who don't have Go toolchain, the previous hook is maintained as `actionlint-system` hook. Please read [the document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#pre-commit) to know the usage details. ([#301](https://github.com/rhysd/actionlint/issues/301), thanks [@Freed-Wu](https://github.com/Freed-Wu) and [@dokempf](https://github.com/dokempf))\n- Update Go dependencies to the latest.\n- Update npm dependencies for playground to the latest and fix optimizing Wasm binary with `wasm-opt`.\n- Update popular actions data set. New major versions and new inputs of many popular actions are now supported like `sparse-checkout` input of `actions/checkout` action.  ([#305](https://github.com/rhysd/actionlint/issues/305))\n- Fix outdated document for Problem Matchers. ([#289](https://github.com/rhysd/actionlint/issues/289), thanks [@carlcsaposs-canonical](https://github.com/carlcsaposs-canonical))\n- Fix outdated links in document for super-linter. ([#303](https://github.com/rhysd/actionlint/issues/303), thanks [@gmacario](https://github.com/gmacario))\n- Automate releasing the Winget package with GitHub Actions. ([#276](https://github.com/rhysd/actionlint/issues/276), [#293](https://github.com/rhysd/actionlint/issues/293), thanks [@sitiom](https://github.com/sitiom))\n\n[Changes][v1.6.25]\n\n\n<a id=\"v1.6.24\"></a>\n# [v1.6.24](https://github.com/rhysd/actionlint/releases/tag/v1.6.24) - 2023-04-04\n\n- Add support for [configuration variables](https://docs.github.com/en/actions/learn-github-actions/variables). However actionlint doesn't know what variables are defined in the repository on GitHub. To notify them, [you need to configure your variables in your repository](https://github.com/rhysd/actionlint/blob/main/docs/config.md).\n  ```yaml\n  config-variables:\n    - DEFAULT_RUNNER\n    - DEFAULT_TIMEOUT\n  ```\n- Fix type error when `inputs` context is shared by multiple events. ([#263](https://github.com/rhysd/actionlint/issues/263))\n- Add document for [how to install actionlint with winget](https://github.com/rhysd/actionlint/blob/main/docs/install.md#winget). ([#267](https://github.com/rhysd/actionlint/issues/267), thanks [@sitiom](https://github.com/sitiom))\n- Add document for [how to integrate actionlint to trunk.io](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#trunk). ([#269](https://github.com/rhysd/actionlint/issues/269), thanks [@dapirian](https://github.com/dapirian))\n- Add document for [how to install actionlint with Nix package manager](https://github.com/rhysd/actionlint/blob/main/docs/install.md#nix). ([#273](https://github.com/rhysd/actionlint/issues/273), thanks [@diohabara](https://github.com/diohabara))\n- Update popular actions data set to the latest\n- Add support for Go 1.20 and build release binaries with Go 1.20\n\n\n[Changes][v1.6.24]\n\n\n<a id=\"v1.6.23\"></a>\n# [v1.6.23](https://github.com/rhysd/actionlint/releases/tag/v1.6.23) - 2023-01-19\n\n- Fix using [`vars` context](https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context) causes 'undefined context' error. This context is for ['Variables' feature](https://docs.github.com/en/actions/learn-github-actions/variables) which was recently added to GitHub Actions. ([#260](https://github.com/rhysd/actionlint/issues/260))\n  ```yaml\n  - name: Use variables\n    run: |\n      echo \"repository variable : ${{ vars.REPOSITORY_VAR }}\"\n      echo \"organization variable : ${{ vars.ORGANIZATION_VAR }}\"\n      echo \"overridden variable : ${{ vars.OVERRIDE_VAR }}\"\n      echo \"variable from shell environment : $env_var\"\n  ```\n- Fix 'no property' error on accessing some `github` context's properties which were added recently. ([#259](https://github.com/rhysd/actionlint/issues/259))\n- Update popular actions data set and add some new actions to it\n  - [actions/dependency-review-action](https://github.com/actions/dependency-review-action)\n  - [dtolnay/rust-toolchain](https://github.com/dtolnay/rust-toolchain)\n- Playground is improved by making the right pane sticky. It is useful when many errors are reported. ([#253](https://github.com/rhysd/actionlint/issues/253), thanks [@ericcornelissen](https://github.com/ericcornelissen))\n- Update Go modules dependencies and playground dependencies\n\n[Changes][v1.6.23]\n\n\n<a id=\"v1.6.22\"></a>\n# [v1.6.22](https://github.com/rhysd/actionlint/releases/tag/v1.6.22) - 2022-11-01\n\n- Detect deprecated workflow commands such as [`set-output` or `save-state`](https://github.blog/changelog/2022-10-11-github-actions-deprecating-save-state-and-set-output-commands/) and suggest the alternative. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-deprecated-workflow-commands) for more details. ([#234](https://github.com/rhysd/actionlint/issues/234))\n  ```yaml\n  # ERROR: This format of 'set-output' workflow command was deprecated\n  - run: echo '::set-output name=foo::bar'\n  ```\n- Fix that `${{ }}` expression at `on.workflow_call.inputs.<id>.default` caused an error. ([#235](https://github.com/rhysd/actionlint/issues/235))\n  ```yaml\n  on:\n    workflow_call:\n      inputs:\n        project:\n          type: string\n          # OK: The default value is generated dynamically\n          default: ${{ github.event.repository.name }}\n  ```\n- Improve type of `inputs` context to grow gradually while checking inputs in `workflow_call` event.\n  ```yaml\n  on:\n    workflow_call:\n      inputs:\n        input1:\n          type: string\n          # ERROR: `input2` is not defined yet\n          default: ${{ inputs.input2 }}\n        input2:\n          type: string\n          # OK: `input1` was already defined above\n          default: ${{ inputs.input1 }}\n  ```\n- Check types of default values of workflow call inputs even if `${{ }}` expression is used.\n  ```yaml\n  on:\n    workflow_call:\n      inputs:\n        input1:\n          type: boolean\n        input2:\n          type: number\n          # ERROR: Boolean value cannot be assigned to number\n          default: ${{ inputs.input1 }}\n  ```\n- Fix the download script is broken since GHE server does not support the new `set-output` format yet. ([#240](https://github.com/rhysd/actionlint/issues/240))\n- Replace the deprecated `set-output` workflow command in our own workflows. ([#239](https://github.com/rhysd/actionlint/issues/239), thanks [@Mrtenz](https://github.com/Mrtenz))\n- Popular actions data set was updated to the latest as usual.\n\n[Changes][v1.6.22]\n\n\n<a id=\"v1.6.21\"></a>\n# [v1.6.21](https://github.com/rhysd/actionlint/releases/tag/v1.6.21) - 2022-10-09\n\n- [Check contexts availability](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#ctx-spfunc-availability). Some contexts limit where they can be used. For example, `jobs.<job_id>.env` workflow key does not allow accessing `env` context, but `jobs.<job_id>.steps.env` allows. See [the official document](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability) for the complete list of contexts availability. ([#180](https://github.com/rhysd/actionlint/issues/180))\n  ```yaml\n  ...\n\n  env:\n    TOPLEVEL: ...\n\n  jobs:\n    test:\n      runs-on: ubuntu-latest\n      env:\n        # ERROR: 'env' context is not available here\n        JOB_LEVEL: ${{ env.TOPLEVEL }}\n      steps:\n        - env:\n            # OK: 'env' context is available here\n            STEP_LEVEL: ${{ env.TOPLEVEL }}\n          ...\n  ```\n  actionlint reports the context is not available and what contexts are available as follows:\n  ```\n  test.yaml:11:22: context \"env\" is not allowed here. available contexts are \"github\", \"inputs\", \"matrix\", \"needs\", \"secrets\", \"strategy\". see https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability for more details [expression]\n     |\n  11 |       JOB_LEVEL: ${{ env.TOPLEVEL }}\n     |                      ^~~~~~~~~~~~\n  ```\n- [Check special functions availability](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#ctx-spfunc-availability). Some functions limit where they can be used. For example, status functions like `success()` or `failure()` are only available in conditions of `if:`. See [the official document](https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability) for the complete list of special functions availability. ([#214](https://github.com/rhysd/actionlint/issues/214))\n  ```yaml\n  ...\n\n  steps:\n    # ERROR: 'success()' function is not available here\n    - run: echo 'Success? ${{ success() }}'\n      # OK: 'success()' function is available here\n      if: success()\n  ```\n  actionlint reports `success()` is not available and where the function is available as follows:\n  ```\n  test.yaml:8:33: calling function \"success\" is not allowed here. \"success\" is only available in \"jobs.<job_id>.if\", \"jobs.<job_id>.steps.if\". see https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability for more details [expression]\n    |\n  8 |       - run: echo 'Success? ${{ success() }}'\n    |                                 ^~~~~~~~~\n  ```\n- Fix `inputs` context is not available in `run-name:` section. ([#223](https://github.com/rhysd/actionlint/issues/223))\n- Allow dynamic shell configuration like `shell: ${{ env.SHELL }}`.\n- Fix no error is reported when `on:` does not exist at toplevel. ([#232](https://github.com/rhysd/actionlint/issues/232))\n- Fix an error position is not correct when the error happens at root node of workflow AST.\n- Fix an incorrect empty event is parsed when `on:` section is empty.\n- Fix the error message when parsing an unexpected key on toplevel. (thanks [@norwd](https://github.com/norwd), [#231](https://github.com/rhysd/actionlint/issues/231))\n- Add `in_progress` type to `workflow_run` webhook event trigger.\n- Describe [the actionlint extension](https://extensions.panic.com/extensions/org.netwrk/org.netwrk.actionlint/) for [Nova.app](https://nova.app) in [the usage document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#nova). (thanks [@jbergstroem](https://github.com/jbergstroem), [#222](https://github.com/rhysd/actionlint/issues/222))\n- Note [Super-Linter](https://github.com/github/super-linter) uses a different place for configuration file. (thanks [@per-oestergaard](https://github.com/per-oestergaard), [#227](https://github.com/rhysd/actionlint/issues/227))\n- Add `actions/setup-dotnet@v3` to popular actions data set.\n- [`generate-availability` script](https://github.com/rhysd/actionlint/tree/main/scripts/generate-availability) was created to scrape the information about contexts and special functions availability from the official document. The information can be used through [`actionlint.WorkflowKeyAvailability()`](https://pkg.go.dev/github.com/rhysd/actionlint#WorkflowKeyAvailability) Go API. This script is run once a week on CI to keep the information up-to-date.\n\n\n\n[Changes][v1.6.21]\n\n\n<a id=\"v1.6.20\"></a>\n# [v1.6.20](https://github.com/rhysd/actionlint/releases/tag/v1.6.20) - 2022-09-30\n\n- Support `run-name` which [GitHub introduced recently](https://github.blog/changelog/2022-09-26-github-actions-dynamic-names-for-workflow-runs/). It is a name of workflow run dynamically configured. See [the official document](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#run-name) for more details. ([#220](https://github.com/rhysd/actionlint/issues/220))\n  ```yaml\n  on: push\n  run-name: Deploy by @${{ github.actor }}\n\n  jobs:\n    ...\n  ```\n- Add `end_column` property to JSON representation of error. The property indicates a column of the end position of `^~~~~~~` indicator in snippet. Note that `end_column` is equal to `column` when the indicator cannot be shown. ([#219](https://github.com/rhysd/actionlint/issues/219))\n  ```console\n  $ actionlint -format '{{json .}}' test.yaml | jq\n  [\n    {\n      \"message\": \"property \\\"unknown_prop\\\" is not defined in object type {arch: string; debug: string; name: string; os: string; temp: string; tool_cache: string; workspace: string}\",\n      \"filepath\": \"test.yaml\",\n      \"line\": 7,\n      \"column\": 23,\n      \"kind\": \"expression\",\n      \"snippet\": \"      - run: echo ${{ runner.unknown_prop }}\\n                      ^~~~~~~~~~~~~~~~~~~\",\n      \"end_column\": 41\n    }\n  ]\n  ```\n- Overhaul the workflow parser to parse workflow keys in case-insensitive. This is a work derived from the fix of [#216](https://github.com/rhysd/actionlint/issues/216). Now the parser parses all workflow keys in case-insensitive way correctly. Note that permission names at `permissions:` are exceptionally case-sensitive.\n  - This fixes properties of `inputs` for `workflow_dispatch` were not case-insensitive.\n  - This fixes inputs and outputs of local actions were not handled in case-insensitive way.\n- Update popular actions data set. `actions/stale@v6` was newly added.\n\n[Changes][v1.6.20]\n\n\n<a id=\"v1.6.19\"></a>\n# [v1.6.19](https://github.com/rhysd/actionlint/releases/tag/v1.6.19) - 2022-09-22\n\n- Fix inputs, outputs, and secrets of reusable workflow should be case-insensitive. ([#216](https://github.com/rhysd/actionlint/issues/216))\n  ```yaml\n  # .github/workflows/reusable.yaml\n  on:\n    workflow_call:\n      inputs:\n        INPUT_UPPER:\n          type: string\n        input_lower:\n          type: string\n      secrets:\n        SECRET_UPPER:\n        secret_lower:\n  ...\n\n  # .github/workflows/test.yaml\n  ...\n\n  jobs:\n    caller:\n      uses: ./.github/workflows/reusable.yaml\n      # Inputs and secrets are case-insensitive. So all the followings should be OK\n      with:\n        input_upper: ...\n        INPUT_LOWER: ...\n      secrets:\n        secret_upper: ...\n        SECRET_LOWER: ...\n  ```\n- Describe [how to install specific version of `actionlint` binary with the download script](https://github.com/rhysd/actionlint/blob/main/docs/install.md#download-script). ([#218](https://github.com/rhysd/actionlint/issues/218))\n\n[Changes][v1.6.19]\n\n\n<a id=\"v1.6.18\"></a>\n# [v1.6.18](https://github.com/rhysd/actionlint/releases/tag/v1.6.18) - 2022-09-17\n\n- This release much enhances checks for local reusable workflow calls. Note that these checks are done for local reusable workflows (starting with `./`). ([#179](https://github.com/rhysd/actionlint/issues/179)).\n  - Detect missing required inputs/secrets and undefined inputs/secrets at `jobs.<job_id>.with` and `jobs.<job_id>.secrets`. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-inputs-and-secrets-in-workflow-call) for more details.\n    ```yaml\n    # .github/workflows/reusable.yml\n    on:\n      workflow_call:\n        inputs:\n          name:\n            type: string\n            required: true\n        secrets:\n          password:\n            required: true\n    ...\n\n    # .github/workflows/test.yml\n    ...\n\n    jobs:\n      missing-required:\n        uses: ./.github/workflows/reusable.yml\n        with:\n          # ERROR: Undefined input \"user\"\n          user: rhysd\n          # ERROR: Required input \"name\" is missing\n        secrets:\n          # ERROR: Undefined secret \"credentials\"\n          credentials: my-token\n          # ERROR: Required secret \"password\" is missing\n    ```\n  - Type check for reusable workflow inputs at `jobs.<job_id>.with`. Types are defined at `on.workflow_call.inputs.<name>.type` in reusable workflow. actionlint checks types of expressions in workflow calls. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-inputs-and-secrets-in-workflow-call) for more details.\n    ```yaml\n    # .github/workflows/reusable.yml\n    on:\n      workflow_call:\n        inputs:\n          id:\n            type: number\n          message:\n            type: string\n    ...\n\n    # .github/workflows/test.yml\n    ...\n\n    jobs:\n      type-checks:\n        uses: ./.github/workflows/reusable.yml\n        with:\n          # ERROR: Cannot assign string value to number input. format() returns string value\n          id: ${{ format('runner name is {0}', runner.name) }}\n          # ERROR: Cannot assign null to string input. If you want to pass string \"null\", use ${{ 'null' }}\n          message: null\n    ```\n  - Detect local reusable workflow which does not exist at `jobs.<job_id>.uses`. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-workflow-call-syntax) for more details.\n    ```yaml\n    jobs:\n      test:\n        # ERROR: This workflow file does not exist\n        with: ./.github/workflows/does-not-exist.yml\n    ```\n  - Check `needs.<job_id>.outputs.<output_id>` in downstream jobs of workflow call jobs. The outputs object is now typed strictly based on `on.workflow_call.outputs.<name>` in the called reusable workflow. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-outputs-of-workflow-call-in-downstream-jobs) for more details.\n    ```yaml\n    # .github/workflows/get-build-info.yml\n    on:\n      workflow_call:\n        outputs:\n          version:\n            value: ...\n            description: version of software\n    ...\n\n    # .github/workflows/test.yml\n    ...\n\n    jobs:\n      # This job's outputs object is typed as {version: string}\n      get_build_info:\n        uses: ./.github/workflows/get-build-info.yml\n      downstream:\n        needs: [get_build_info]\n        runs-on: ubuntu-latest\n        steps:\n          # OK. `version` is defined in the reusable workflow\n          - run: echo '${{ needs.get_build_info.outputs.version }}'\n          # ERROR: `tag` is not defined in the reusable workflow\n          - run: echo '${{ needs.get_build_info.outputs.tag }}'\n    ```\n- Add missing properties in contexts and improve types of some properties looking at [the official contexts document](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context).\n  - `github.action_status`\n  - `runner.debug`\n  - `services.<service_id>.ports`\n- Fix `on.workflow_call.inputs.<name>.description` and `on.workflow_call.secrets.<name>.description` were incorrectly mandatory. They are actually optional.\n- Report parse errors when parsing `action.yml` in local actions. They were ignored in previous versions.\n- Sort the order of properties in an object type displayed in error message. In previous versions, actionlint sometimes displayed `{a: true, b: string}`, or it displayed `{b: string, a: true}` for the same object type. This randomness was caused by random iteration of map values in Go.\n- Update popular actions data set to the latest.\n\n[Changes][v1.6.18]\n\n\n<a id=\"v1.6.17\"></a>\n# [v1.6.17](https://github.com/rhysd/actionlint/releases/tag/v1.6.17) - 2022-08-28\n\n- Allow workflow calls are available in matrix jobs. See [the official announcement](https://github.blog/changelog/2022-08-22-github-actions-improvements-to-reusable-workflows-2/) for more details. ([#197](https://github.com/rhysd/actionlint/issues/197))\n  ```yaml\n  jobs:\n    ReusableMatrixJobForDeployment:\n      strategy:\n        matrix:\n          target: [dev, stage, prod]\n      uses: octocat/octo-repo/.github/workflows/deployment.yml@main\n      with:\n        target: ${{ matrix.target }}\n  ```\n- Allow nested workflow calls. See [the official announcement](https://github.blog/changelog/2022-08-22-github-actions-improvements-to-reusable-workflows-2/) for more details. ([#201](https://github.com/rhysd/actionlint/issues/201))\n  ```yaml\n  on: workflow_call\n\n  jobs:\n    call-another-reusable:\n      uses: path/to/another-reusable.yml@v1\n  ```\n- Fix job outputs should be passed to `needs.*.outputs` of only direct children. Until v1.6.16, they are passed to any downstream jobs. ([#151](https://github.com/rhysd/actionlint/issues/151))\n  ```yaml\n  jobs:\n    first:\n      runs-on: ubuntu-latest\n      outputs:\n        first: 'output from first job'\n      steps:\n        - run: echo 'first'\n\n    second:\n      needs: [first]\n      runs-on: ubuntu-latest\n      outputs:\n        second: 'output from second job'\n      steps:\n        - run: echo 'second'\n\n    third:\n      needs: [second]\n      runs-on: ubuntu-latest\n      steps:\n        - run: echo '${{ toJSON(needs.second.outputs) }}'\n        # ERROR: `needs.first` does not exist, but v1.6.16 reported no error\n        - run: echo '${{ toJSON(needs.first.outputs) }}'\n  ```\n  When you need both `needs.first` and `needs.second`, add the both to `needs:`.\n  ```yaml\n    third:\n      needs: [first, second]\n      runs-on: ubuntu-latest\n      steps:\n        # OK\n        -  echo '${{ toJSON(needs.first.outputs) }}'\n  ```\n- Fix `}}` in string literals are detected as end marker of placeholder `${{ }}`. ([#205](https://github.com/rhysd/actionlint/issues/205))\n  ```yaml\n  jobs:\n    test:\n      runs-on: ubuntu-latest\n      strategy:\n        # This caused an incorrect error until v1.6.16\n        matrix: ${{ fromJSON('{\"foo\":{}}') }}\n  ```\n- Fix `working-directory:` should not be available with `uses:` in steps. `working-directory:` is only available with `run:`. ([#207](https://github.com/rhysd/actionlint/issues/207))\n  ```yaml\n  steps:\n    - uses: actions/checkout@v3\n      # ERROR: `working-directory:` is not available here\n      working-directory: ./foo\n  ```\n- The working directory for running `actionlint` command can be set via [`WorkingDir` field of `LinterOptions` struct](https://pkg.go.dev/github.com/rhysd/actionlint#LinterOptions). When it is empty, the return value from `os.Getwd` will be used.\n- Update popular actions data set. `actions/configure-pages@v2` was added.\n- Use Go 1.19 on CI by default. It is used to build release binaries.\n- Update dependencies (go-yaml/yaml v3.0.1).\n- Update playground dependencies (except for CodeMirror v6).\n\n[Changes][v1.6.17]\n\n\n<a id=\"v1.6.16\"></a>\n# [v1.6.16](https://github.com/rhysd/actionlint/releases/tag/v1.6.16) - 2022-08-19\n\n- Allow an empty object at `permissions:`. You can use it to disable permissions for all of the available scopes. ([#170](https://github.com/rhysd/actionlint/issues/170), [#171](https://github.com/rhysd/actionlint/issues/171), thanks [@peaceiris](https://github.com/peaceiris))\n  ```yaml\n  permissions: {}\n  ```\n- Support `github.triggering_actor` context value. ([#190](https://github.com/rhysd/actionlint/issues/190), thanks [@stefreak](https://github.com/stefreak))\n- Rename `step-id` rule to `id` rule. Now the rule checks both job IDs and step IDs. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#id-naming-convention) for more details. ([#182](https://github.com/rhysd/actionlint/issues/182))\n  ```yaml\n  jobs:\n    # ERROR: '.' cannot be contained in ID\n    v1.2.3:\n      runs-on: ubuntu-latest\n      steps:\n        - run: echo 'job ID with version'\n          # ERROR: ID cannot contain spaces\n          id: echo for test\n    # ERROR: ID cannot start with numbers\n    2d-game:\n      runs-on: ubuntu-latest\n      steps:\n        - run: echo 'oops'\n  ```\n- Accessing `env` context in `jobs.<id>.if` is now reported as error. ([#155](https://github.com/rhysd/actionlint/issues/155))\n  ```yaml\n  jobs:\n    test:\n      runs-on: ubuntu-latest\n      # ERROR: `env` is not available here\n      if: ${{ env.DIST == 'arch' }}\n      steps:\n        - run: ...\n  ```\n- Fix actionlint wrongly typed some matrix value when the matrix is expanded with `${{ }}`. For example, `matrix.foo` in the following code is typed as `{x: string}`, but it should be `any` because it is initialized with the value from `fromJSON`. ([#145](https://github.com/rhysd/actionlint/issues/145))\n  ```yaml\n  strategy:\n    matrix:\n      foo: ${{ fromJSON(...) }}\n      exclude:\n        - foo:\n            x: y\n  ```\n- Fix incorrect type check when multiple runner labels are set to `runs-on:` via expanding `${{ }}` for selecting self-hosted runners. ([#164](https://github.com/rhysd/actionlint/issues/164))\n  ```yaml\n  jobs:\n    test:\n      strategy:\n        matrix:\n          include:\n            - labels: [\"self-hosted\", \"macOS\", \"X64\"]\n            - labels: [\"self-hosted\", \"linux\"]\n      # actionlint incorrectly reported type error here\n      runs-on: ${{ matrix.labels }}\n  ```\n- Fix usage of local actions (`uses: ./path/to/action`) was not checked when multiple workflow files were passed to `actionlint` command. ([#173](https://github.com/rhysd/actionlint/issues/173))\n- Allow `description:` is missing in `secrets:` of reusable workflow call definition since it is optional. ([#174](https://github.com/rhysd/actionlint/issues/174))\n- Fix type of property of `github.event.inputs` is string unlike `inputs` context. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#workflow-dispatch-event-validation) for more details. ([#181](https://github.com/rhysd/actionlint/issues/181))\n  ```yaml\n  on:\n    workflow_dispatch:\n      inputs:\n        is-valid:\n          # Type of `inputs.is-valid` is bool\n          # Type of `github.event.inputs.is-valid` is string\n          type: boolean\n  ```\n- Fix crash when a value is expanded with `${{ }}` at `continue-on-error:`. ([#193](https://github.com/rhysd/actionlint/issues/193))\n- Fix some error was caused by some other error. For example, the following code reported two errors. '\" is not available for string literal' error caused another 'one placeholder should be included in boolean value string' error. This was caused because the `${{ x == \"foo\" }}` placeholder was not counted due to the previous type error.\n  ```yaml\n  if: ${{ x == \"foo\" }}\n  ```\n- Add support for [`merge_group` workflow trigger](https://github.blog/changelog/2022-08-18-merge-group-webhook-event-and-github-actions-workflow-trigger/).\n- Add official actions to manage GitHub Pages to popular actions data set.\n  - `actions/configure-pages@v1`\n  - `actions/deploy-pages@v1`\n  - `actions/upload-pages-artifact@v1`\n- Update popular actions data set to the latest. Several new major versions and new inputs of actions were added to it.\n- Describe how to install actionlint via [Chocolatey](https://chocolatey.org/), [scoop](https://scoop.sh/), and [AUR](https://aur.archlinux.org/) in [the installation document](https://github.com/rhysd/actionlint/blob/main/docs/install.md). ([#167](https://github.com/rhysd/actionlint/issues/167), [#168](https://github.com/rhysd/actionlint/issues/168), thanks [@sitiom](https://github.com/sitiom))\n- [VS Code extension for actionlint](https://marketplace.visualstudio.com/items?itemName=arahata.linter-actionlint) was created by [@arahatashun](https://github.com/arahatashun). See [the document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#vs-code) for more details.\n- Describe how to use [the Docker image](https://hub.docker.com/r/rhysd/actionlint) at step of GitHub Actions workflow. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#use-actionlint-on-github-actions) for the details. ([#146](https://github.com/rhysd/actionlint/issues/146))\n  ```yaml\n  - uses: docker://rhysd/actionlint:latest\n    with:\n      args: -color\n  ```\n- Clarify the behavior if empty strings are set to some command line options in documents. `-shellcheck=` disables shellcheck integration and `-pyflakes=` disables pyflakes integration. ([#156](https://github.com/rhysd/actionlint/issues/156))\n- Update Go module dependencies.\n\n[Changes][v1.6.16]\n\n\n<a id=\"v1.6.15\"></a>\n# [v1.6.15](https://github.com/rhysd/actionlint/releases/tag/v1.6.15) - 2022-06-28\n\n- Fix referring `env` context from `env:` at step level caused an error. `env:` at toplevel and job level cannot refer `env` context, but `env:` at step level can. ([#158](https://github.com/rhysd/actionlint/issues/158))\n  ```yaml\n  on: push\n\n  env:\n    # ERROR: 'env:' at toplevel cannot refer 'env' context\n    ERROR1: ${{ env.PATH }}\n\n  jobs:\n    my_job:\n      runs-on: ubuntu-latest\n      env:\n        # ERROR: 'env:' at job level cannot refer 'env' context\n        ERROR2: ${{ env.PATH }}\n      steps:\n        - run: echo \"$THIS_IS_OK\"\n          env:\n            # OK: 'env:' at step level CAN refer 'env' context\n            THIS_IS_OK: ${{ env.PATH }}\n  ```\n- [Docker image for linux/arm64](https://hub.docker.com/layers/rhysd/actionlint/1.6.15/images/sha256-f63ee59f1846abce86ca9de1d41a1fc22bc7148d14b788cb455a9594d83e73f7?context=repo) is now provided. It is useful for M1 Mac users. ([#159](https://github.com/rhysd/actionlint/issues/159), thanks [@politician](https://github.com/politician))\n- Fix [the download script](https://github.com/rhysd/actionlint/blob/main/scripts/download-actionlint.bash) did not respect the version specified via the first argument. ([#162](https://github.com/rhysd/actionlint/issues/162), thanks [@mateiidavid](https://github.com/mateiidavid))\n\n[Changes][v1.6.15]\n\n\n<a id=\"v1.6.14\"></a>\n# [v1.6.14](https://github.com/rhysd/actionlint/releases/tag/v1.6.14) - 2022-06-26\n\n- Some filters are exclusive in events at `on:`. Now actionlint checks the exclusive filters are used in the same event. `paths` and `paths-ignore`, `branches` and `branches-ignore`, `tags` and `tags-ignore` are exclusive. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#webhook-events-validation) for the details.\n  ```yaml\n  on:\n    push:\n      # ERROR: Both 'paths' and 'paths-ignore' filters cannot be used for the same event\n      paths: ...\n      paths-ignore: ...\n  ```\n- Some event filters are checked more strictly. Some filters are only available with specific events. Now actionlint checks the limitation. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#webhook-events-validation) for complete list of such filters.\n  ```yaml\n  on:\n    release:\n      # ERROR: 'tags' filter is only available for 'push' event\n      tags: v*.*.*\n  ```\n- Paths starting/ending with spaces are now reported as error.\n- Inputs of workflow which specify both `default` and `required` are now reported as error. When `required` is specified at input of workflow call, a caller of it must specify value of the input. So the default value will never be used. ([#154](https://github.com/rhysd/actionlint/issues/154), thanks [@sksat](https://github.com/sksat))\n  ```yaml\n  on:\n    workflow_call:\n      inputs:\n        my_input:\n          description: test\n          type: string\n          # ERROR: The default value 'aaa' will never be used\n          required: true\n          default: aaa\n  ```\n- Fix inputs of `workflow_dispatch` are set to `inputs` context as well as `github.event.inputs`. This was added by [the recent change of GitHub Actions](https://github.blog/changelog/2022-06-10-github-actions-inputs-unified-across-manual-and-reusable-workflows/). ([#152](https://github.com/rhysd/actionlint/issues/152))\n  ```yaml\n  on:\n    workflow_dispatch:\n      inputs:\n        my_input:\n          type: string\n          required: true\n  jobs:\n    my_job:\n      runs-on: ubuntu-latest\n      steps:\n        - run: echo ${{ github.event.inputs.my_input }}\n        # Now the input is also set to `inputs` context\n        - run: echo ${{ inputs.my_input }}\n  ```\n- Improve that `env` context is now not defined in values of `env:`, `id:` and `uses:`. actionlint now reports usage of `env` context in such places as type errors. ([#158](https://github.com/rhysd/actionlint/issues/158))\n  ```yaml\n  runs-on: ubuntu-latest\n  env:\n    FOO: aaa\n  steps:\n    # ERROR: 'env' context is not defined in values of 'env:', 'id:' and 'uses:'\n    - uses: test/${{ env.FOO }}@main\n      env:\n        BAR: ${{ env.FOO }}\n      id: foo-${{ env.FOO }}\n  ```\n- `actionlint` command gains `-stdin-filename` command line option. When it is specified, the file name is used on reading input from stdin instead of `<stdin>`. ([#157](https://github.com/rhysd/actionlint/issues/157), thanks [@arahatashun](https://github.com/arahatashun))\n  ```sh\n  # Error message shows foo.yml as file name where the error happened\n  ... | actionlint -stdin-filename foo.yml -\n  ```\n- [The download script](https://github.com/rhysd/actionlint/blob/main/docs/install.md#download-script) allows to specify a directory path to install `actionlint` executable with the second argument of the script. For example, the following command downloads `/path/to/bin/actionlint`:\n  ```sh\n  # Downloads the latest stable version at `/path/to/bin/actionlint`\n  bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash) latest /path/to/bin\n  # Downloads actionlint v1.6.14 at `/path/to/bin/actionlint`\n  bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash) 1.6.14 /path/to/bin\n  ```\n- Update popular actions data set including `goreleaser-action@v3`, `setup-python@v4`, `aks-set-context@v3`.\n- Update Go dependencies including go-yaml/yaml v3.\n\n[Changes][v1.6.14]\n\n\n<a id=\"v1.6.13\"></a>\n# [v1.6.13](https://github.com/rhysd/actionlint/releases/tag/v1.6.13) - 2022-05-18\n\n- [`secrets: inherit` in reusable workflow](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_callsecretsinherit) is now supported ([#138](https://github.com/rhysd/actionlint/issues/138))\n  ```yaml\n  on:\n    workflow_dispatch:\n\n  jobs:\n    pass-secrets-to-workflow:\n      uses: ./.github/workflows/called-workflow.yml\n      secrets: inherit\n  ```\n  This means that actionlint cannot know the workflow inherits secrets or not when checking a reusable workflow. To support `secrets: inherit` without giving up on checking `secrets` context, actionlint assumes the followings. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-types-of-inputs-and-secrets-in-reusable-workflow) for the details.\n  - when `secrets:` is omitted in a reusable workflow, the workflow inherits secrets from a caller\n  - when `secrets:` exists in a reusable workflow, the workflow inherits no other secret\n- [`macos-12` runner](https://github.blog/changelog/2022-04-25-github-actions-public-beta-of-macos-12-for-github-hosted-runners-is-now-available/) is now supported ([#134](https://github.com/rhysd/actionlint/issues/134), thanks [@shogo82148](https://github.com/shogo82148))\n- [`ubuntu-22.04` runner](https://github.blog/changelog/2022-05-10-github-actions-beta-of-ubuntu-22-04-for-github-hosted-runners-is-now-available/) is now supported ([#142](https://github.com/rhysd/actionlint/issues/142), thanks [@shogo82148](https://github.com/shogo82148))\n- `concurrency` is available on reusable workflow call ([#136](https://github.com/rhysd/actionlint/issues/136))\n  ```yaml\n  jobs:\n    checks:\n      concurrency:\n        group: ${{ github.ref }}-${{ github.workflow }}\n        cancel-in-progress: true\n      uses: ./path/to/workflow.yaml\n  ```\n- [pre-commit](https://pre-commit.com/) hook now uses a fixed version of actionlint. For example, the following configuration continues to use actionlint v1.6.13 even if v1.6.14 is released. ([#116](https://github.com/rhysd/actionlint/issues/116))\n  ```yaml\n  repos:\n    - repo: https://github.com/rhysd/actionlint\n      rev: v1.6.13\n      hooks:\n        - id: actionlint-docker\n  ```\n- Update popular actions data set including new versions of `docker/*`, `haskell/actions/setup`,  `actions/setup-go`, ... ([#140](https://github.com/rhysd/actionlint/issues/140), thanks [@bflad](https://github.com/bflad))\n- Update Go module dependencies\n\n\n[Changes][v1.6.13]\n\n\n<a id=\"v1.6.12\"></a>\n# [v1.6.12](https://github.com/rhysd/actionlint/releases/tag/v1.6.12) - 2022-04-14\n\n- Fix `secrets.ACTIONS_RUNNER_DEBUG` and `secrets.ACTIONS_STEP_DEBUG` are not pre-defined in a reusable workflow. ([#130](https://github.com/rhysd/actionlint/issues/130))\n- Fix checking permissions is outdated. `pages` and `discussions` permissions were added and `metadata` permission was removed. ([#131](https://github.com/rhysd/actionlint/issues/131), thanks [@suzuki-shunsuke](https://github.com/suzuki-shunsuke))\n- Disable [SC2157](https://github.com/koalaman/shellcheck/wiki/SC2157) shellcheck rule to avoid a false positive due to [the replacement of `${{ }}`](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#shellcheck-integration-for-run) in script. For example, in the below script `-z ${{ env.FOO }}` was replaced with `-z ______________` and it caused 'always false due to literal strings' error. ([#113](https://github.com/rhysd/actionlint/issues/113))\n  ```yaml\n  - run: |\n      if [[ -z ${{ env.FOO }} ]]; then\n        echo \"FOO is empty\"\n      fi\n  ```\n- Add codecov-action@v3 to popular actions data set.\n\n[Changes][v1.6.12]\n\n\n<a id=\"v1.6.11\"></a>\n# [v1.6.11](https://github.com/rhysd/actionlint/releases/tag/v1.6.11) - 2022-04-05\n\n- Fix crash on making [outputs in JSON format](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#format-error-messages) with `actionlint -format '{{json .}}'`. ([#128](https://github.com/rhysd/actionlint/issues/128))\n- Allow any outputs from `actions/github-script` action because it allows to set arbitrary outputs via calling `core.setOutput()` in JavaScript. ([#104](https://github.com/rhysd/actionlint/issues/104))\n  ```yaml\n  - id: test\n    uses: actions/github-script@v5\n    with:\n      script: |\n        core.setOutput('answer', 42);\n  - run: |\n      echo \"The answer is ${{ steps.test.outputs.answer }}\"\n  ```\n- Add support for Go 1.18. All released binaries were built with Go 1.18 compiler. The bottom supported version is Go 1.16 and it's not been changed.\n- Update popular actions data set (`actions/cache`, `code-ql-actions/*`, ...)\n- Update some Go module dependencies\n\n[Changes][v1.6.11]\n\n\n<a id=\"v1.6.10\"></a>\n# [v1.6.10](https://github.com/rhysd/actionlint/releases/tag/v1.6.10) - 2022-03-11\n\n- Support outputs in reusable workflow call. See [the official document](https://docs.github.com/en/actions/using-workflows/reusing-workflows#using-outputs-from-a-reusable-workflow) for the usage of the outputs syntax. ([#119](https://github.com/rhysd/actionlint/issues/119), [#121](https://github.com/rhysd/actionlint/issues/121))\n  Example of reusable workflow definition:\n  ```yaml\n  on:\n    workflow_call:\n      outputs:\n        some_output:\n          description: \"Some awesome output\"\n          value: 'result value of workflow call'\n  jobs:\n    job:\n      runs-on: ubuntu-latest\n      steps:\n        ...\n  ```\n  Example of reusable workflow call:\n  ```yaml\n  jobs:\n    job1:\n      uses: ./.github/workflows/some_workflow.yml\n    job2:\n      runs-on: ubuntu-latest\n      needs: job1\n      steps:\n        - run: echo ${{ needs.job1.outputs.some_output }}\n  ```\n- Support checking `jobs` context, which is only available in `on.workflow_call.outputs.<name>.value`. Outputs of jobs can be referred via the context. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-outputs-of-reusable-workflow) for more details.\n  ```yaml\n  on:\n    workflow_call:\n      outputs:\n        image-version:\n          description: \"Docker image version\"\n          # ERROR: 'imagetag' does not exist (typo of 'image_tag')\n          value: ${{ jobs.gen-image-version.outputs.imagetag }}\n  jobs:\n    gen-image-version:\n      runs-on: ubuntu-latest\n      outputs:\n        image_tag: \"${{ steps.get_tag.outputs.tag }}\"\n      steps:\n        - run: ./output_image_tag.sh\n          id: get_tag\n  ```\n- Add new major releases in `actions/*` actions including `actions/checkout@v3`, `actions/setup-go@v3`, `actions/setup-python@v3`, ...\n- Check job IDs. They must start with a letter or `_` and contain only alphanumeric characters, `-` or `_`. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#job-id-naming-convention) for more details. ([#80](https://github.com/rhysd/actionlint/issues/80))\n  ```yaml\n  on: push\n  jobs:\n    # ERROR: '.' cannot be contained in job ID\n    foo-v1.2.3:\n      runs-on: ubuntu-latest\n      steps:\n        - run: 'job ID with version'\n  ```\n- Fix `windows-latest` now means `windows-2022` runner. See [virtual-environments#4856](https://github.com/actions/virtual-environments/issues/4856) for the details. ([#120](https://github.com/rhysd/actionlint/issues/120))\n- Update [the playground](https://rhysd.github.io/actionlint/) dependencies to the latest.\n- Update Go module dependencies\n\n[Changes][v1.6.10]\n\n\n<a id=\"v1.6.9\"></a>\n# [v1.6.9](https://github.com/rhysd/actionlint/releases/tag/v1.6.9) - 2022-02-24\n\n- Support [`runner.arch` context value](https://docs.github.com/en/actions/learn-github-actions/contexts#runner-context). (thanks [@shogo82148](https://github.com/shogo82148), [#101](https://github.com/rhysd/actionlint/issues/101))\n  ```yaml\n  steps:\n    - run: ./do_something_64bit.sh\n      if: ${{ runner.arch == 'x64' }}\n  ```\n- Support [calling reusable workflows in local directories](https://docs.github.com/en/actions/using-workflows/reusing-workflows#calling-a-reusable-workflow). (thanks [@jsok](https://github.com/jsok), [#107](https://github.com/rhysd/actionlint/issues/107))\n  ```yaml\n  jobs:\n    call-workflow-in-local-repo:\n      uses: ./.github/workflows/useful_workflow.yml\n  ```\n- Add [a document](https://github.com/rhysd/actionlint/blob/main/docs/install.md#asdf) to install actionlint via [asdf](https://asdf-vm.com/) version manager. (thanks [@crazy-matt](https://github.com/crazy-matt), [#99](https://github.com/rhysd/actionlint/issues/99))\n- Fix using `secrets.GITHUB_TOKEN` caused a type error when some other secret is defined. (thanks [@mkj-is](https://github.com/mkj-is), [#106](https://github.com/rhysd/actionlint/issues/106))\n- Fix nil check is missing on parsing `uses:` step. (thanks [@shogo82148](https://github.com/shogo82148), [#102](https://github.com/rhysd/actionlint/issues/102))\n- Fix some documents including broken links. (thanks [@ohkinozomu](https://github.com/ohkinozomu), [#105](https://github.com/rhysd/actionlint/issues/105))\n- Update popular actions data set to the latest. More arguments are added to many actions. And a few actions had new major versions.\n- Update webhook payload data set to the latest. `requested_action` type was added to `check_run` hook. `requested` and `rerequested` types were removed from `check_suite` hook. `updated` type was removed from `project` hook.\n\n\n[Changes][v1.6.9]\n\n\n<a id=\"v1.6.8\"></a>\n# [v1.6.8](https://github.com/rhysd/actionlint/releases/tag/v1.6.8) - 2021-11-15\n\n- [Untrusted inputs](https://docs.github.com/en/actions/security-guides/security-hardening-for-github-actions) detection can detect untrusted inputs in object filter syntax. For example, `github.event.*.body` filters `body` properties and it includes the untrusted input `github.event.comment.body`. actionlint detects such filters and causes an error. The error message includes all untrusted input names which are filtered by the object filter so that you can know what inputs are untrusted easily. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#untrusted-inputs) for more details.\n  Input example:\n  ```yaml\n  - name: Get comments\n    run: echo '${{ toJSON(github.event.*.body) }}'\n  ```\n  Error message:\n  ```\n  object filter extracts potentially untrusted properties \"github.event.comment.body\", \"github.event.discussion.body\", \"github.event.issue.body\", ...\n  ```\n  Instead you should do:\n  ```yaml\n  - name: Get comments\n    run: echo \"$JSON\"\n    env:\n      JSON: {{ toJSON(github.event.*.body) }}\n  ```\n- Support [the new input type syntax for `workflow_dispatch` event](https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/), which was introduced recently. You can declare types of inputs on triggering a workflow manually. actionlint does two things with this new syntax.\n  - actionlint checks the syntax. Unknown input types, invalid default values, missing options for 'choice' type.\n    ```yaml\n    inputs:\n      # Unknown input type\n      id:\n        type: number\n      # ERROR: No options for 'choice' input type\n      kind:\n        type: choice\n      name:\n        type: choice\n        options:\n          - Tama\n          - Mike\n        # ERROR: Default value is not in options\n        default: Chobi\n      verbose:\n        type: boolean\n        # ERROR: Boolean value must be 'true' or 'false'\n        default: yes\n    ```\n  - actionlint give a strict object type to `github.event.inputs` so that a type checker can check unknown input names and type mismatches on using the value.\n    ```yaml\n    on:\n      workflow_dispatch:\n        inputs:\n          message:\n            type: string\n          verbose:\n            type: boolean\n    # Type of `github.event.inputs` is {\"message\": string; \"verbose\": bool}\n    jobs:\n      test:\n        runs-on: ubuntu-latest\n        steps:\n          # ERROR: Undefined input\n          - run: echo \"${{ github.event.inputs.massage }}\"\n          # ERROR: Bool value is not available for object key\n          - run: echo \"${{ env[github.event.inputs.verbose] }}\"\n    ```\n  - See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-workflow-dispatch-events) for more details.\n- Add missing properties in `github` context. See [the contexts document](https://docs.github.com/en/actions/learn-github-actions/contexts#github-context) to know the full list of properties.\n  - `github.ref_name` (thanks [@dihmandrake](https://github.com/dihmandrake), [#72](https://github.com/rhysd/actionlint/issues/72))\n  - `github.ref_protected`\n  - `github.ref_type`\n- Filtered array by object filters is typed more strictly.\n  ```\n  # `env` is a map object { string => string }\n  # Previously typed as array<any> now it is typed as array<string>\n  env.*\n  ```\n- Update Go module dependencies and playground dependencies.\n\n[Changes][v1.6.8]\n\n\n<a id=\"v1.6.7\"></a>\n# [v1.6.7](https://github.com/rhysd/actionlint/releases/tag/v1.6.7) - 2021-11-08\n\n- Fix missing property `name` in `runner` context object (thanks [@ioanrogers](https://github.com/ioanrogers), [#67](https://github.com/rhysd/actionlint/issues/67)).\n- Fix a false positive on type checking at `x.*` object filtering syntax where the receiver is an object. actionlint previously only allowed arrays as receiver of object filtering ([#66](https://github.com/rhysd/actionlint/issues/66)).\n  ```ruby\n  fromJSON('{\"a\": \"from a\", \"b\": \"from b\"}').*\n  # => [\"from a\", \"from b\"]\n\n  fromJSON('{\"a\": {\"x\": \"from a.x\"}, \"b\": {\"x\": \"from b.x\"}}').*.x\n  # => [\"from a.x\", \"from b.x\"]\n  ```\n- Add [rust-cache](https://github.com/Swatinem/rust-cache) as new popular action.\n- Remove `bottle: unneeded` from Homebrew formula (thanks [@oppara](https://github.com/oppara), [#63](https://github.com/rhysd/actionlint/issues/63)).\n- Support `branch_protection_rule` webhook again.\n- Update popular actions data set to the latest ([#64](https://github.com/rhysd/actionlint/issues/64), [#70](https://github.com/rhysd/actionlint/issues/70)).\n\n[Changes][v1.6.7]\n\n\n<a id=\"v1.6.6\"></a>\n# [v1.6.6](https://github.com/rhysd/actionlint/releases/tag/v1.6.6) - 2021-10-17\n\n- `inputs` and `secrets` objects are now typed looking at `workflow_call` event at `on:`. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-types-of-inputs-and-secrets-in-reusable-workflow) for more details.\n  - `inputs` object is typed with definitions at `on.workflow_call.inputs`. When the workflow is not callable, it is typed at `{}` (empty object) so any `inputs.*` access causes a type error.\n  - `secrets` object is typed with definitions at `on.workflow_call.secrets`.\n  ```yaml\n  on:\n    workflow_call:\n      # `inputs` object is typed {url: string; lucky_number: number}\n      inputs:\n        url:\n          description: 'your URL'\n          type: string\n        lucky_number:\n          description: 'your lucky number'\n          type: number\n      # `secrets` object is typed {user: string; credential: string}\n      secrets:\n        user:\n          description: 'your user name'\n        credential:\n          description: 'your credential'\n  jobs:\n    test:\n      runs-on: ubuntu-20.04\n      steps:\n        - name: Send data\n          # ERROR: uri is typo of url\n          run: curl ${{ inputs.uri }} -d ${{ inputs.lucky_number }}\n          env:\n            # ERROR: credentials is typo of credential\n            TOKEN: ${{ secrets.credentials }}\n  ```\n- `id-token` is added to permissions (thanks [@cmmarslender](https://github.com/cmmarslender), [#62](https://github.com/rhysd/actionlint/issues/62)).\n- Report an error on nested workflow calls since it is [not allowed](https://docs.github.com/en/actions/learn-github-actions/reusing-workflows#limitations).\n  ```yaml\n  on:\n    # This workflow is reusable\n    workflow_call:\n\n  jobs:\n    test:\n      # ERROR: Nested workflow call is not allowed\n      uses: owner/repo/path/to/workflow.yml@ref\n  ```\n- Parse `uses:` at reusable workflow call more strictly following `{owner}/{repo}/{path}@{ref}` format.\n- Popular actions data set was updated to the latest ([#61](https://github.com/rhysd/actionlint/issues/61)).\n- Dependencies of playground were updated to the latest (including eslint v8).\n\n[Changes][v1.6.6]\n\n\n<a id=\"v1.6.5\"></a>\n# [v1.6.5](https://github.com/rhysd/actionlint/releases/tag/v1.6.5) - 2021-10-08\n\n- Support [reusable workflows](https://docs.github.com/en/actions/learn-github-actions/reusing-workflows) syntax which is now in beta. Only very basic syntax checks are supported at this time. Please see [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-reusable-workflows) to know checks for reusable workflow syntax.\n  - Example of `workflow_call` event\n    ```yaml\n    on:\n      workflow_call:\n        inputs:\n          name:\n            description: your name\n            type: string\n        secrets:\n          token:\n            required: true\n\n    jobs:\n      ...\n    ```\n  - Example of reusable workflow call with `uses:` at `job.<job_id>`\n    ```yaml\n    on: ...\n    jobs:\n      hello:\n        uses: owner/repo/path/to/workflow.yml@main\n        with:\n          name: Octocat\n        secrets:\n          token: ${{ secrets.token }}\n    ```\n- Support `github.run_attempt` property in `${{ }}` expression ([#57](https://github.com/rhysd/actionlint/issues/57)).\n- Add support for `windows-2022` runner which is now in [public beta](https://github.com/actions/virtual-environments/issues/3949).\n- Remove support for `ubuntu-16.04` runner which was [removed from GitHub Actions at the end of September](https://github.com/actions/virtual-environments/issues/3287).\n- Ignore [SC2154](https://github.com/koalaman/shellcheck/wiki/SC2154) shellcheck rule which can cause false positive ([#53](https://github.com/rhysd/actionlint/issues/53)).\n- Fix error position was not correct when required keys are not existing in job configuration.\n- Update popular actions data set. New major versions of github-script and lock-threads actions are supported ([#59](https://github.com/rhysd/actionlint/issues/59)).\n- Fix document (thanks [@fornwall](https://github.com/fornwall) at [#52](https://github.com/rhysd/actionlint/issues/52), thanks [@equal-l2](https://github.com/equal-l2) at [#56](https://github.com/rhysd/actionlint/issues/56)).\n  - Now actionlint is [an official package of Homebrew](https://formulae.brew.sh/formula/actionlint). Simply executing `brew install actionlint` can install actionlint.\n\n[Changes][v1.6.5]\n\n\n<a id=\"v1.6.4\"></a>\n# [v1.6.4](https://github.com/rhysd/actionlint/releases/tag/v1.6.4) - 2021-09-21\n\n- Implement 'map' object types `{ string => T }`, where all properties of the object are typed as `T`. Since a key of object is always string, left hand side of `=>` is fixed to `string`. For example, `env` context only has string properties so it is typed as `{ string => string}`. Previously its properties were typed `any`.\n  ```yaml\n  # typed as string (previously any)\n  env.FOO\n\n  # typed as { id: string; network: string; ports: object; } (previously any)\n  job.services.redis\n  ```\n- `github.event.discussion.title` and `github.event.discussion.body` are now checked as untrusted inputs.\n- Update popular actions data set. ([#50](https://github.com/rhysd/actionlint/issues/50), [#51](https://github.com/rhysd/actionlint/issues/51))\n- Update webhooks payload data set. `branch_protection_rule` hook was dropped from the list due to [github/docs@179a6d3](https://github.com/github/docs/commit/179a6d334e92b9ade8626ef42a546dae66b49951). ([#50](https://github.com/rhysd/actionlint/issues/50), [#51](https://github.com/rhysd/actionlint/issues/51))\n\n[Changes][v1.6.4]\n\n\n<a id=\"v1.6.3\"></a>\n# [v1.6.3](https://github.com/rhysd/actionlint/releases/tag/v1.6.3) - 2021-09-04\n\n- Improve guessing a type of matrix value. When a matrix contains numbers and strings, previously the type fell back to `any`. Now it is deduced as string.\n  ```yaml\n  strategy:\n    matrix:\n      # matrix.node is now deduced as `string` instead of `any`\n      node: [14, 'latest']\n  ```\n- Fix types of `||` and `&&` expressions. Previously they were typed as `bool` but it was not correct. Correct type is sum of types of both sides of the operator like TypeScript. For example, type of `'foo' || 'bar'` is a string, and `github.event && matrix` is an object.\n- actionlint no longer reports an error when a local action does not exist in the repository. It is a popular pattern that a local action directory is cloned while a workflow running. ([#25](https://github.com/rhysd/actionlint/issues/25), [#40](https://github.com/rhysd/actionlint/issues/40))\n- Disable [SC2050](https://github.com/koalaman/shellcheck/wiki/SC2050) shellcheck rule since it causes some false positive. ([#45](https://github.com/rhysd/actionlint/issues/45))\n- Fix `-version` did not work when running actionlint via [the Docker image](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#docker) ([#47](https://github.com/rhysd/actionlint/issues/47)).\n- Fix pre-commit hook file name. (thanks [@xsc27](https://github.com/xsc27), [#38](https://github.com/rhysd/actionlint/issues/38))\n- [New `branch_protection_rule` event](https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#branch_protection_rule) is supported. ([#48](https://github.com/rhysd/actionlint/issues/48))\n- Update popular actions data set. ([#41](https://github.com/rhysd/actionlint/issues/41), [#48](https://github.com/rhysd/actionlint/issues/48))\n- Update Go library dependencies.\n- Update playground dependencies.\n\n[Changes][v1.6.3]\n\n\n<a id=\"v1.6.2\"></a>\n# [v1.6.2](https://github.com/rhysd/actionlint/releases/tag/v1.6.2) - 2021-08-23\n\n- actionlint now checks evaluated values at `${{ }}` are not an object nor an array since they are not useful. See [the check document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-type-check-expression) for more details.\n```yaml\n# ERROR: This will always be replaced with `echo 'Object'`\n- run: echo '${{ runner }}'\n# OK: Serialize an object into JSON to check the content\n- run: echo '${{ toJSON(runner) }}'\n```\n- Add [pre-commit](https://pre-commit.com/) support. pre-commit is a framework for managing Git `pre-commit` hooks. See [the usage document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#pre-commit) for more details. (thanks [@xsc27](https://github.com/xsc27) for adding the integration at [#33](https://github.com/rhysd/actionlint/issues/33)) ([#23](https://github.com/rhysd/actionlint/issues/23))\n- Add [an official Docker image](https://hub.docker.com/repository/docker/rhysd/actionlint). The Docker image contains shellcheck and pyflakes as dependencies. Now actionlint can be run with `docker run` command easily. See [the usage document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#docker) for more details. (thanks [@xsc27](https://github.com/xsc27) for the help at [#34](https://github.com/rhysd/actionlint/issues/34))\n```sh\ndocker run --rm -v $(pwd):/repo --workdir /repo rhysd/actionlint:latest -color\n```\n- Go 1.17 is now a default compiler to build actionlint. Built binaries are faster than before by 2~7% when the process is CPU-bound. Sizes of built binaries are about 2% smaller. Note that Go 1.16 continues to be supported.\n- `windows/arm64` target is added to released binaries thanks to Go 1.17.\n- Now any value can be converted into bool implicitly. Previously this was not permitted as actionlint provides stricter type check. However it is not useful that a condition like `if: github.event.foo` causes a type error.\n- Fix a prefix operator cannot be applied repeatedly like `!!42`.\n- Fix a potential crash when type checking on expanding an object with `${{ }}` like `matrix: ${{ fromJSON(env.FOO) }}`\n- Update popular actions data set ([#36](https://github.com/rhysd/actionlint/issues/36))\n\n[Changes][v1.6.2]\n\n\n<a id=\"v1.6.1\"></a>\n# [v1.6.1](https://github.com/rhysd/actionlint/releases/tag/v1.6.1) - 2021-08-16\n\n- [Problem Matchers](https://github.com/actions/toolkit/blob/master/docs/problem-matchers.md) is now officially supported by actionlint, which annotates errors from actionlint on GitHub as follows. The matcher definition is maintained at [`.github/actionlint-matcher.json`](https://github.com/rhysd/actionlint/blob/main/.github/actionlint-matcher.json) by [script](https://github.com/rhysd/actionlint/tree/main/scripts/generate-actionlint-matcher). For the usage, see [the document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#problem-matchers).\n\n<img src=\"https://github.com/rhysd/ss/blob/master/actionlint/problem-matcher.png?raw=true\" alt=\"annotation by Problem Matchers\" width=\"715\" height=\"221\"/>\n\n- `runner_label` rule now checks conflicts in labels at `runs-on`. For example, there is no runner which meats both `ubuntu-latest` and `windows-latest`. This kind of misconfiguration sometimes happen when a beginner misunderstands the usage of `runs-on:`. To run a job on each runners, `matrix:` should be used. See [the document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#check-runner-labels) for more information.\n\n```yaml\non: push\njobs:\n  test:\n    # These labels match to no runner\n    runs-on: [ubuntu-latest, windows-latest]\n    steps:\n      - run: echo ...\n```\n\n- Reduce memory footprint (around 16%) on starting `actionlint` command by removing unnecessary data from `PopularActions` global variable. This also slightly reduces binary size (about 3.7% at `playground/main.wasm`).\n- Fix accessing `steps.*` objects in job's `environment:` configuration caused a type error ([#30](https://github.com/rhysd/actionlint/issues/30)).\n- Fix checking that action's input names at `with:` were not in case insensitive ([#31](https://github.com/rhysd/actionlint/issues/31)).\n- Ignore outputs of [getsentry/paths-filter](https://github.com/getsentry/paths-filter). It is a fork of [dorny/paths-filter](https://github.com/dorny/paths-filter). actionlint cannot check the outputs statically because it sets outputs dynamically.\n- Add [Azure/functions-action](https://github.com/Azure/functions-action) to popular actions.\n- Update popular actions data set ([#29](https://github.com/rhysd/actionlint/issues/29)).\n\n[Changes][v1.6.1]\n\n\n<a id=\"v1.6.0\"></a>\n# [v1.6.0](https://github.com/rhysd/actionlint/releases/tag/v1.6.0) - 2021-08-11\n\n- Check potentially untrusted inputs to prevent [a script injection vulnerability](https://securitylab.github.com/research/github-actions-untrusted-input/) at `run:` and `script` input of [actions/github-script](https://github.com/actions/github-script). See [the rule document](https://github.com/rhysd/actionlint/blob/main/docs/checks.md#untrusted-inputs) for more explanations and workflow example. (thanks [@azu](https://github.com/azu) for the feature request at [#19](https://github.com/rhysd/actionlint/issues/19))\n\nIncorrect code\n\n```yaml\n- run: echo '${{ github.event.pull_request.title }}'\n```\n\nshould be replaced with\n\n```yaml\n- run: echo \"issue ${TITLE}\"\n  env:\n    TITLE: ${{github.event.issue.title}}\n```\n\n- Add `-format` option to `actionlint` command. It allows to flexibly format error messages as you like with [Go template syntax](https://pkg.go.dev/text/template). See [the usage document](https://github.com/rhysd/actionlint/blob/main/docs/usage.md#format) for more details. (thanks [@ybiquitous](https://github.com/ybiquitous) for the feature request at [#20](https://github.com/rhysd/actionlint/issues/20))\n\nSimple example to output error messages as JSON:\n\n```sh\nactionlint -format '{{json .}}'\n```\n\nMore compliated example to output error messages as markdown:\n\n```sh\nactionlint -format '{{range $ := .}}### Error at line {{$.Line}}, col {{$.Column}} of `{{$.Filepath}}`\\n\\n{{$.Message}}\\n\\n```\\n{{$.Snippet}}\\n```\\n\\n{{end}}'\n```\n\n- Documents are reorganized. Long `README.md` is separated into several document files ([#28](https://github.com/rhysd/actionlint/issues/28))\n  - [`README.md`](https://github.com/rhysd/actionlint/blob/main/README.md): Introduction, Quick start, Document links\n  - [`docs/checks.md`](https://github.com/rhysd/actionlint/tree/main/docs/checks.md): Full list of all checks done by actionlint with example inputs, outputs, and playground links\n  - [`docs/install.md`](https://github.com/rhysd/actionlint/tree/main/docs/install.md): Installation instruction\n  - [`docs/usage.md`](https://github.com/rhysd/actionlint/tree/main/docs/usage.md): Advanced usage of `actionlint` command, usage of playground, integration with [reviewdog](https://github.com/reviewdog/reviewdog), [Problem Matchers](https://github.com/actions/toolkit/blob/master/docs/problem-matchers.md), [super-linter](https://github.com/github/super-linter)\n  - [`docs/config.md`](https://github.com/rhysd/actionlint/tree/main/docs/config.md): About configuration file\n  - [`doc/api.md`](https://github.com/rhysd/actionlint/tree/main/docs/api.md): Using actionlint as Go library\n  - [`doc/reference.md`](https://github.com/rhysd/actionlint/tree/main/docs/reference.md): Links to resources\n- Fix checking shell names was not case-insensitive, for example `PowerShell` was detected as invalid shell name\n- Update popular actions data set to the latest\n- Make lexer errors on checking `${{ }}` expressions more meaningful\n\n[Changes][v1.6.0]\n\n\n<a id=\"v1.5.3\"></a>\n# [v1.5.3](https://github.com/rhysd/actionlint/releases/tag/v1.5.3) - 2021-08-04\n\n- Now actionlint allows to use any operators outside `${{ }}` on `if:` condition like `if: github.repository_owner == 'rhysd'` ([#22](https://github.com/rhysd/actionlint/issues/22)). [The official document](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idif) said that using any operator outside `${{ }}` was invalid even if it was on `if:` condition. However, [github/docs#8786](https://github.com/github/docs/pull/8786) clarified that the document was not correct.\n\n[Changes][v1.5.3]\n\n\n<a id=\"v1.5.2\"></a>\n# [v1.5.2](https://github.com/rhysd/actionlint/releases/tag/v1.5.2) - 2021-08-02\n\n- Outputs of [dorny/paths-filter](https://github.com/dorny/paths-filter) are now not typed strictly because the action dynamically sets outputs which are not defined in its `action.yml`. actionlint cannot check such outputs statically ([#18](https://github.com/rhysd/actionlint/issues/18)).\n- [The table](https://github.com/rhysd/actionlint/blob/main/all_webhooks.go) for checking [Webhooks supported by GitHub Actions](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#webhook-events) is now generated from the official document automatically with [script](https://github.com/rhysd/actionlint/tree/main/scripts/generate-webhook-events). The table continues to be updated weekly by [the CI workflow](https://github.com/rhysd/actionlint/actions/workflows/generate.yaml).\n- Improve error messages while lexing expressions as follows.\n- Fix column numbers are off-by-one on some lexer errors.\n- Fix checking invalid numbers where some digit follows zero in a hex number (e.g. `0x01`) or an exponent part of number (e.g. `1e0123`).\n- Fix a parse error message when some tokens still remain after parsing finishes.\n- Refactor the expression lexer to lex an input incrementally. It slightly reduces memory consumption.\n\nLex error until v1.5.1:\n\n```test.yaml:9:26: got unexpected character '+' while lexing expression, expecting '_', '\\'', '}', '(', ')', '[', ']', '.', '!', '<', '>', '=', '&', '|', '*', ',', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z' [expression]```\n\nLex error from v1.5.2:\n\n```test.yaml:9:26: got unexpected character '+' while lexing expression, expecting 'a'..'z', 'A'..'Z', '0'..'9', ''', '}', '(', ')', '[', ']', '.', '!', '<', '>', '=', '&', '|', '*', ',', '_' [expression]```\n\n[Changes][v1.5.2]\n\n\n<a id=\"v1.5.1\"></a>\n# [v1.5.1](https://github.com/rhysd/actionlint/releases/tag/v1.5.1) - 2021-07-29\n\n- Improve checking the intervals of scheduled events ([#14](https://github.com/rhysd/actionlint/issues/14), [#15](https://github.com/rhysd/actionlint/issues/15)). Since GitHub Actions [limits the interval to once every 5 minutes](https://github.blog/changelog/2019-11-01-github-actions-scheduled-jobs-maximum-frequency-is-changing/), actionlint now reports an error when a workflow is configured to be run once per less than 5 minutes.\n- Skip checking inputs of [octokit/request-action](https://github.com/octokit/request-action) since it allows to specify arbitrary inputs though they are not defined in its `action.yml` ([#16](https://github.com/rhysd/actionlint/issues/16)).\n  - Outputs of the action are still be typed strictly. Only its inputs are not checked.\n- The help text of `actionlint` is now hosted online: https://rhysd.github.io/actionlint/usage.html\n- Add new fuzzing target for parsing glob patterns.\n\n[Changes][v1.5.1]\n\n\n<a id=\"v1.5.0\"></a>\n# [v1.5.0](https://github.com/rhysd/actionlint/releases/tag/v1.5.0) - 2021-07-26\n\n- `action` rule now validates inputs of popular actions at `with:`. When a required input is not specified or an undefined input is specified, actionlint will report it.\n  - Popular actions are updated automatically once a week and the data set is embedded to executable directly. The check does not need any network request and does not affect performance of actionlint. Sources of the actions are listed [here](https://github.com/rhysd/actionlint/blob/main/scripts/generate-popular-actions/main.go#L51). If you have some request to support new action, please report it at [the issue form](https://github.com/rhysd/actionlint/issues/new).\n  - Please see [the document](https://github.com/rhysd/actionlint#check-popular-action-inputs) for example ([Playground](https://rhysd.github.io/actionlint#eJyFj0EKwjAQRfc9xV8I1UJbcJmVK+8xDYOpqUlwEkVq725apYgbV8PMe/Dne6cQkpiiOPtOVAFEljhP4Jqc1D4LqUsupnqgmS1IIgd5W0CNJCwKpGPvnbSatOHDbf/BwL2PRq0bYPmR9efXBdiMIwyJOfYDy7asqrZqBq9tucM0/TWXyF81UI5F0wbSlk4s67u5mMKFLL8A+h9EEw==)).\n- `expression` rule now types outputs of popular actions (type of `steps.{id}.outputs` object) more strictly.\n  - For example, `actions/cache@v2` sets `cache-hit` output. The outputs object is typed as `{ cache-hit: any }`. Previously it was typed as `any` which means no further type check was performed.\n  - Please see the second example of [the document](https://github.com/rhysd/actionlint#check-contextual-step-object) ([Playground](https://rhysd.github.io/actionlint#eJyNTksKwjAQ3fcUbyFUC0nBZVauvIakMZjY0gRnokjp3W3TUl26Gt53XugVYiJXFPfQkCoAtsTzBR6pJxEmQ2pSz0l0etayRGwjLS5AIJElBW3Yh55qo42zp+dxlQF/Vcjkxrw8O7UhoLVvhd0wwGlyZ99Z2pdVVVeyC6YtDxjHH3PUUxiyjtq0+mZpmzENVrDGhVyVN8r8V4bEMfGKhPP8bfw7dlliH1xHWso=)).\n- Outputs of local actions (their names start with `./`) are also typed more strictly as well as popular actions.\n- Metadata (`action.yml`) of local actions are now cached to avoid reading and parsing `action.yml` files repeatedly for the same action.\n- Add new rule `permissions` to check [permission scopes](https://docs.github.com/en/actions/reference/authentication-in-a-workflow#permissions-for-the-github_token) for default `secrets.GITHUB_TOKEN`. Please see [the document](https://github.com/rhysd/actionlint#permissions) for more details ([Playground](https://rhysd.github.io/actionlint/#eJxNjd0NwyAMhN89xS3AAmwDxBK0FCOMlfUDiVr16aTv/qR5dNNM1Hl8imqRph7nKJOJXhLVEzBZ51ZgWFMnq2TR2jRXw/Zu63/gBkDKnN7ftQethPF6GByOEOuDdXL/ldw+8eCUBZlrlQvntjLp)).\n- Structure of [`actionlint.Permissions`](https://pkg.go.dev/github.com/rhysd/actionlint#Permissions) struct was changed. A parser no longer checks values of `permissions:` configuration. The check is now done by `permissions` rule.\n\n[Changes][v1.5.0]\n\n\n<a id=\"v1.4.3\"></a>\n# [v1.4.3](https://github.com/rhysd/actionlint/releases/tag/v1.4.3) - 2021-07-21\n\n- Support new Webhook events [`discussion` and `discussion_comment`](https://docs.github.com/en/actions/reference/events-that-trigger-workflows#discussion) ([#8](https://github.com/rhysd/actionlint/issues/8)).\n- Read file concurrently with limiting concurrency to number of CPUs. This improves performance when checking many files and disabling shellcheck/pyflakes integration.\n- Support Linux based on musl libc by [the download script](https://github.com/rhysd/actionlint/blob/main/scripts/download-actionlint.bash) ([#5](https://github.com/rhysd/actionlint/issues/5)).\n- Reduce number of goroutines created while running shellcheck/pyflakes processes. This has small impact on memory usage when your workflows have many `run:` steps.\n- Reduce built binary size by splitting an external library which is only used for debugging into a separate command line tool.\n- Introduce several micro benchmark suites to track performance.\n- Enable code scanning for Go/TypeScript/JavaScript sources in actionlint repository.\n\n[Changes][v1.4.3]\n\n\n<a id=\"v1.4.2\"></a>\n# [v1.4.2](https://github.com/rhysd/actionlint/releases/tag/v1.4.2) - 2021-07-16\n\n- Fix executables in the current directory may be used unexpectedly to run `shellcheck` or `pyflakes` on Windows. This behavior could be security vulnerability since an attacker might put malicious executables in shared directories. actionlint searched an executable with [`exec.LookPath`](https://pkg.go.dev/os/exec#LookPath), but it searched the current directory on Windows as [golang/go#43724](https://github.com/golang/go/issues/43724) pointed. Now actionlint uses [`execabs.LookPath`](https://pkg.go.dev/golang.org/x/sys/execabs#LookPath) instead, which does not have the issue. (ref: [sharkdp/bat#1724](https://github.com/sharkdp/bat/pull/1724))\n- Fix issue caused by running so many processes concurrently. Since checking workflows by actionlint is highly parallelized, checking many workflow files makes too many `shellcheck` processes and opens many files in parallel. This hit OS resources limitation (issue [#3](https://github.com/rhysd/actionlint/issues/3)). Now reading files is serialized and number of processes run concurrently is limited for fixing the issue. Note that checking workflows is still done in parallel so this fix does not affect actionlint's performance.\n- Ensure cleanup processes even if actionlint stops due to some fatal issue while visiting a workflow tree.\n- Improve fatal error message to know which workflow file caused the error.\n- [Playground](https://rhysd.github.io/actionlint/) improvements\n  - \"Permalink\" button was added to make permalink directly linked to the current workflow source code. The source code is embedded in hash of the URL.\n  - \"Check\" button and URL input form was added to check workflow files on https://github.com or https://gist.github.com easily. Visit a workflow file on GitHub, copy the URL, paste it to the input form and click the button. It instantly fetches the workflow file content and checks it with actionlint.\n  - `u=` URL parameter was added to specify GitHub or Gist URL like https://rhysd.github.io/actionlint/?u=https://github.com/rhysd/actionlint/blob/main/.github/workflows/ci.yaml\n\n[Changes][v1.4.2]\n\n\n<a id=\"v1.4.1\"></a>\n# [v1.4.1](https://github.com/rhysd/actionlint/releases/tag/v1.4.1) - 2021-07-12\n\n- A pre-built executable for `darwin/arm64` (Apple M1) was added to CI ([#1](https://github.com/rhysd/actionlint/issues/1))\n  - Managing `actionlint` command with Homebrew on M1 Mac is now available. See [the instruction](https://github.com/rhysd/actionlint#homebrew-on-macos) for more details\n  - Since the author doesn't have M1 Mac and GitHub Actions does not support M1 Mac yet, the built binary is not tested\n- Pre-built executables are now built with Go 1.16 compiler (previously it was 1.15)\n- Fix error message is sometimes not in one line when the error message was caused by go-yaml/yaml parser\n- Fix playground does not work on Safari browsers on both iOS and Mac since they don't support `WebAssembly.instantiateStreaming()` yet\n- Make URLs in error messages clickable on playground\n- Code base of playground was migrated from JavaScript to Typescript along with improving error handlings\n\n[Changes][v1.4.1]\n\n\n<a id=\"v1.4.0\"></a>\n# [v1.4.0](https://github.com/rhysd/actionlint/releases/tag/v1.4.0) - 2021-07-09\n\n- New rule to validate [glob pattern syntax](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet) to filter branches, tags and paths. For more details, see [documentation](https://github.com/rhysd/actionlint#check-glob-pattern).\n  - syntax errors like missing closing brackets for character range `[..]`\n  - invalid usage like `?` following `*`, invalid character range `[9-1]`, ...\n  - invalid character usage for Git ref names (branch name, tag name)\n    - ref name cannot start/end with `/`\n    - ref name cannot contain `[`, `:`, `\\`, ...\n- Fix column of error position is off by one when the error is caused by quoted strings like `'...'` or `\"...\"`.\n- Add `--norc` option to `shellcheck` command to check shell scripts in `run:` in order not to be affected by any user configuration.\n- Improve some error messages\n- Explain playground in `man` manual\n\n[Changes][v1.4.0]\n\n\n<a id=\"v1.3.2\"></a>\n# [v1.3.2](https://github.com/rhysd/actionlint/releases/tag/v1.3.2) - 2021-07-04\n\n- [actionlint playground](https://rhysd.github.io/actionlint) was implemented thanks to WebAssembly. actionlint is now available on browser without installing anything. The playground does not send user's workflow content to any remote server.\n- Some margins are added to code snippets in error message. See below examples. I believe it's easier to recognize code in bunch of error messages than before.\n- Line number is parsed from YAML syntax error. Since errors from [go-yaml/go](https://github.com/go-yaml/yaml) don't have position information, previously YAML syntax errors are reported at line:0, col:0. Now line number is parsed from error message and set correctly (if error message includes line number).\n- Code snippet is shown in error message even if column number of the error position is unknown.\n- Fix error message on detecting duplicate of step IDs.\n- Fix and improve validating arguments of `format()` calls.\n- All rule documents have links to actionlint playground with example code.\n- `man` manual covers usage of actionlint on CI services.\n\nError message until v1.3.1:\n\n```\ntest.yaml:4:13: invalid CRON format \"0 */3 * *\" in schedule event: Expected exactly 5 fields, found 4: 0 */3 * * [events]\n4|     - cron: '0 */3 * *'\n |             ^~\n```\n\nError message at v1.3.2:\n\n```\ntest.yaml:4:13: invalid CRON format \"0 */3 * *\" in schedule event: Expected exactly 5 fields, found 4: 0 */3 * * [events]\n  |\n4 |     - cron: '0 */3 * *'\n  |             ^~\n```\n\n[Changes][v1.3.2]\n\n\n<a id=\"v1.3.1\"></a>\n# [v1.3.1](https://github.com/rhysd/actionlint/releases/tag/v1.3.1) - 2021-06-30\n\n- Files are checked in parallel. This made actionlint around 1.3x faster with 3 workflow files in my environment\n- Manual for `man` command was added. `actionlint.1` is included in released archives. If you installed actionlint via Homebrew, the manual is also installed automatically\n- `-version` now reports how the binary was built (Go version, arch, os, ...)\n- Added [`Command`](https://pkg.go.dev/github.com/rhysd/actionlint#Command) struct to manage entire command lifecycle\n- Order of checked files is now stable. When all the workflows in the current repository are checked, the order is sorted by file names\n- Added fuzz target for rule checkers\n\n[Changes][v1.3.1]\n\n\n<a id=\"v1.3.0\"></a>\n# [v1.3.0](https://github.com/rhysd/actionlint/releases/tag/v1.3.0) - 2021-06-26\n\n- `-version` now outputs how the executable was installed.\n- Fix errors output to stdout was not colorful on Windows.\n- Add new `-color` flag to force to enable colorful outputs. This is useful when running actionlint on GitHub Actions since scripts at `run:` don't enable colors.\n- `Linter.LintFiles` and `Linter.LintFile` methods take `project` parameter to explicitly specify what project the files belong to. Leaving it `nil` automatically detects projects from their file paths.\n- `LintOptions.NoColor` is replaced by `LintOptions.Color`.\n\nExample of `-version` output:\n\n```console\n$ brew install actionlint\n$ actionlint -version\n1.3.0\ndownloaded from release page\n\n$ go install github.com/rhysd/actionlint/cmd/actionlint@v1.3.0\ngo: downloading github.com/rhysd/actionlint v1.3.0\n$ actionlint -version\nv1.3.0\nbuilt from source\n```\n\nExample of running actionlint on GitHub Actions forcing to enable color output:\n\n```yaml\n- name: Check workflow files\n  run: |\n    bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash)\n    ./actionlint -color\n  shell: bash\n```\n\n[Changes][v1.3.0]\n\n\n<a id=\"v1.2.0\"></a>\n# [v1.2.0](https://github.com/rhysd/actionlint/releases/tag/v1.2.0) - 2021-06-25\n\n- [pyflakes](https://github.com/PyCQA/pyflakes) integration was added. If `pyflakes` is installed on your system, actionlint checks Python scripts in `run:` (when `shell: python`) with it. See [the rule document](https://github.com/rhysd/actionlint#check-pyflakes-integ) for more details.\n- Error handling while running rule checkers was improved. When some internal error occurs while applying rules, actionlint stops correctly due to the error. Previously, such errors were only shown in debug logs and actionlint continued checks.\n- Fixed sanitizing `${{ }}` expressions in scripts before passing them to shellcheck or pyflakes. Previously expressions were not correctly sanitized when `}}` came before `${{`.\n\n[Changes][v1.2.0]\n\n\n<a id=\"v1.1.2\"></a>\n# [v1.1.2](https://github.com/rhysd/actionlint/releases/tag/v1.1.2) - 2021-06-21\n\n- Run `shellcheck` command for scripts at `run:` in parallel. Since executing an external process is heavy and running shellcheck was bottleneck of actionlint, this brought better performance. In my environment, it was **more than 3x faster** than before.\n- Sort errors by their positions in the source file.\n\n[Changes][v1.1.2]\n\n\n<a id=\"v1.1.1\"></a>\n# [v1.1.1](https://github.com/rhysd/actionlint/releases/tag/v1.1.1) - 2021-06-20\n\n- [`download-actionlint.yaml`](https://github.com/rhysd/actionlint/blob/main/scripts/download-actionlint.bash) now sets `executable` output when it is run in GitHub Actions environment. Please see [instruction in 'Install' document](https://github.com/rhysd/actionlint#ci-services) for the usage.\n- Redundant type `ArrayDerefType` was removed. Instead, [`Deref` field](https://pkg.go.dev/github.com/rhysd/actionlint#ArrayType) is now provided in `ArrayType`.\n- Fix crash on broken YAML input.\n- `actionlint -version` returns correct version string even if the `actionlint` command was installed via `go install`.\n\n[Changes][v1.1.1]\n\n\n<a id=\"v1.1.0\"></a>\n# [v1.1.0](https://github.com/rhysd/actionlint/releases/tag/v1.1.0) - 2021-06-19\n\n- Ignore [SC1091](https://github.com/koalaman/shellcheck/wiki/SC1091) and [SC2194](https://github.com/koalaman/shellcheck/wiki/SC2194) on running shellcheck. These are reported as false positives due to sanitization of `${{ ... }}`. See [the check doc](https://github.com/rhysd/actionlint#check-shellcheck-integ) to know the sanitization.\n- actionlint replaces `${{ }}` in `run:` scripts before passing them to shellcheck. v1.0.0 replaced `${{ }}` with whitespaces, but it caused syntax errors in some scripts (e.g. `if ${{ ... }}; then ...`). Instead, v1.1.0 replaces `${{ }}` with underscores. For example, `${{ matrix.os }}` is replaced with `________________`.\n- Add [`download-actionlint.bash`](https://github.com/rhysd/actionlint/blob/main/scripts/download-actionlint.bash) script to download pre-built binaries easily on CI services. See [installation document](https://github.com/rhysd/actionlint#on-ci) for the usage.\n- Better error message on lexing `\"` in `${{ }}` expression since double quote is usually misused for string delimiters\n- `-ignore` option can now be specified multiple times.\n- Fix `github.repositoryUrl` was not correctly resolved in `${{ }}` expression\n- Reports an error when `if:` condition does not use `${{ }}` but the expression contains any operators. [The official document](https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idstepsif) prohibits this explicitly to avoid conflicts with YAML syntax.\n- Clarify that the version of this repository is for `actionlint` CLI tool, not for library. It means that the APIs may have breaking changes on minor or patch version bumps.\n- Add more tests and refactor some code. Enumerating quoted items in error message is now done more efficiently and in deterministic order.\n\n[Changes][v1.1.0]\n\n\n<a id=\"v1.0.0\"></a>\n# [v1.0.0](https://github.com/rhysd/actionlint/releases/tag/v1.0.0) - 2021-06-16\n\nFirst release :tada:\n\nSee documentation for more details:\n\n- [Installation](https://github.com/rhysd/actionlint#install)\n- [Usage](https://github.com/rhysd/actionlint#usage)\n- [Checks done by actionlint](https://github.com/rhysd/actionlint#checks)\n\n[Changes][v1.0.0]\n\n\n[v1.7.6]: https://github.com/rhysd/actionlint/compare/v1.7.5...v1.7.6\n[v1.7.5]: https://github.com/rhysd/actionlint/compare/v1.7.4...v1.7.5\n[v1.7.4]: https://github.com/rhysd/actionlint/compare/v1.7.3...v1.7.4\n[v1.7.3]: https://github.com/rhysd/actionlint/compare/v1.7.2...v1.7.3\n[v1.7.2]: https://github.com/rhysd/actionlint/compare/v1.7.1...v1.7.2\n[v1.7.1]: https://github.com/rhysd/actionlint/compare/v1.7.0...v1.7.1\n[v1.7.0]: https://github.com/rhysd/actionlint/compare/v1.6.27...v1.7.0\n[v1.6.27]: https://github.com/rhysd/actionlint/compare/v1.6.26...v1.6.27\n[v1.6.26]: https://github.com/rhysd/actionlint/compare/v1.6.25...v1.6.26\n[v1.6.25]: https://github.com/rhysd/actionlint/compare/v1.6.24...v1.6.25\n[v1.6.24]: https://github.com/rhysd/actionlint/compare/v1.6.23...v1.6.24\n[v1.6.23]: https://github.com/rhysd/actionlint/compare/v1.6.22...v1.6.23\n[v1.6.22]: https://github.com/rhysd/actionlint/compare/v1.6.21...v1.6.22\n[v1.6.21]: https://github.com/rhysd/actionlint/compare/v1.6.20...v1.6.21\n[v1.6.20]: https://github.com/rhysd/actionlint/compare/v1.6.19...v1.6.20\n[v1.6.19]: https://github.com/rhysd/actionlint/compare/v1.6.18...v1.6.19\n[v1.6.18]: https://github.com/rhysd/actionlint/compare/v1.6.17...v1.6.18\n[v1.6.17]: https://github.com/rhysd/actionlint/compare/v1.6.16...v1.6.17\n[v1.6.16]: https://github.com/rhysd/actionlint/compare/v1.6.15...v1.6.16\n[v1.6.15]: https://github.com/rhysd/actionlint/compare/v1.6.14...v1.6.15\n[v1.6.14]: https://github.com/rhysd/actionlint/compare/v1.6.13...v1.6.14\n[v1.6.13]: https://github.com/rhysd/actionlint/compare/v1.6.12...v1.6.13\n[v1.6.12]: https://github.com/rhysd/actionlint/compare/v1.6.11...v1.6.12\n[v1.6.11]: https://github.com/rhysd/actionlint/compare/v1.6.10...v1.6.11\n[v1.6.10]: https://github.com/rhysd/actionlint/compare/v1.6.9...v1.6.10\n[v1.6.9]: https://github.com/rhysd/actionlint/compare/v1.6.8...v1.6.9\n[v1.6.8]: https://github.com/rhysd/actionlint/compare/v1.6.7...v1.6.8\n[v1.6.7]: https://github.com/rhysd/actionlint/compare/v1.6.6...v1.6.7\n[v1.6.6]: https://github.com/rhysd/actionlint/compare/v1.6.5...v1.6.6\n[v1.6.5]: https://github.com/rhysd/actionlint/compare/v1.6.4...v1.6.5\n[v1.6.4]: https://github.com/rhysd/actionlint/compare/v1.6.3...v1.6.4\n[v1.6.3]: https://github.com/rhysd/actionlint/compare/v1.6.2...v1.6.3\n[v1.6.2]: https://github.com/rhysd/actionlint/compare/v1.6.1...v1.6.2\n[v1.6.1]: https://github.com/rhysd/actionlint/compare/v1.6.0...v1.6.1\n[v1.6.0]: https://github.com/rhysd/actionlint/compare/v1.5.3...v1.6.0\n[v1.5.3]: https://github.com/rhysd/actionlint/compare/v1.5.2...v1.5.3\n[v1.5.2]: https://github.com/rhysd/actionlint/compare/v1.5.1...v1.5.2\n[v1.5.1]: https://github.com/rhysd/actionlint/compare/v1.5.0...v1.5.1\n[v1.5.0]: https://github.com/rhysd/actionlint/compare/v1.4.3...v1.5.0\n[v1.4.3]: https://github.com/rhysd/actionlint/compare/v1.4.2...v1.4.3\n[v1.4.2]: https://github.com/rhysd/actionlint/compare/v1.4.1...v1.4.2\n[v1.4.1]: https://github.com/rhysd/actionlint/compare/v1.4.0...v1.4.1\n[v1.4.0]: https://github.com/rhysd/actionlint/compare/v1.3.2...v1.4.0\n[v1.3.2]: https://github.com/rhysd/actionlint/compare/v1.3.1...v1.3.2\n[v1.3.1]: https://github.com/rhysd/actionlint/compare/v1.3.0...v1.3.1\n[v1.3.0]: https://github.com/rhysd/actionlint/compare/v1.2.0...v1.3.0\n[v1.2.0]: https://github.com/rhysd/actionlint/compare/v1.1.2...v1.2.0\n[v1.1.2]: https://github.com/rhysd/actionlint/compare/v1.1.1...v1.1.2\n[v1.1.1]: https://github.com/rhysd/actionlint/compare/v1.1.0...v1.1.1\n[v1.1.0]: https://github.com/rhysd/actionlint/compare/v1.0.0...v1.1.0\n[v1.0.0]: https://github.com/rhysd/actionlint/tree/v1.0.0\n\n<!-- Generated by https://github.com/rhysd/changelog-from-release v3.8.1 -->\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 9.9638671875,
          "content": "# Policy for actionlint's features\n\n- actionlint focuses on detecting mistakes. Feature requests and patches for checks that enforces code style or\n  some conventions are generally not accepted.\n- actionlint tries to keep [the configuration](docs/config.md) as minimal as possible. Feature requests and patches\n  for checks that require user configurations are generally not accepted.\n\nThese are important to keep actionlint useful and convenient for everyone. I believe that no one wants to create and\nmaintain a heavy configuration file just for linting CI workflows.\n\nIt's helpful to check if a similar patch has been rejected in the past before submitting it.\n\n# Reporting an issue\n\nTo report a bug, please submit a new ticket on GitHub. It's helpful to search similar tickets before making it.\n\nhttps://github.com/rhysd/actionlint/issues/new\n\nProviding a reproducible workflow content is much appreciated. If only a small snippet of workflow is provided or no\ninput is provided at all, such issue tickets may get lower priority because they are occasionally time consuming to\ninvestigate.\n\n# Sending a patch\n\nThank you for taking your time to improve this project. To send a patch, please submit a new pull request on GitHub.\n\nhttps://github.com/rhysd/actionlint/pulls\n\nBefore submitting your PR, please ensure the following points:\n\n- Confirm build/tests/lints passed. How to run them is described in the following sections.\n- If you added a new feature, consider to add tests and explain it in [the usage document](docs/usage.md).\n- If you added a new public API, consider to add tests and a doc comment for the API.\n- If you updated [the checks document](docs/checks.md), ensure to run [the maintenance script](#about-checks-doc).\n\nSpecial thanks to the native English speakers for proofreading the documentation and error messages, as the author is not\nproficient in English.\n\n# Development\n\n`make` (3.81 or later) is useful to run each tasks and reduce redundant builds/tests.\n\n## How to build\n\n```sh\ngo build ./cmd/actionlint\n./actionlint -h\n```\n\nor\n\n```sh\nmake build\n```\n\n`make build` generates some sources with `go generate`. When you want to avoid it, add `SKIP_GO_GENERATE=1` to `make` arguments.\n\nSince actionlint doesn't use any cgo features, setting `CGO_ENABLED=0` environment variable is recommended to avoid troubles\naround linking libc. `make build` does this by default.\n\n## How to run tests\n\n```sh\ngo test\n```\n\nor\n\n```sh\nmake test\n```\n\n## How to run lint\n\n[staticcheck](https://staticcheck.io/) is used to lint Go sources.\n\n```sh\nstaticcheck ./...\n```\n\nor\n\n```sh\nmake lint\n```\n\n## How to run fuzzer\n\nFuzz tests use [go-fuzz](https://github.com/dvyukov/go-fuzz). Install `go-fuzz` and `go-fuzz-build` in your system.\n\nSince there are multiple fuzzing targets, `-func` argument is necessary. Specify a target which you want to run.\n\n```sh\n# Create first corpus\ngo-fuzz-build ./fuzz\n\n# Run fuzzer\ngo-fuzz -bin ./actionlint_fuzz-fuzz.zip -func FuzzParse\n```\n\nor\n\n```sh\nmake fuzz FUZZ_FUNC=FuzzParse\n```\n\n## How to release\n\nWhen releasing v1.2.3 as example:\n\n1. Ensure all changes were already pushed to remote by checking `git push origin master` outputs `Everything up-to-date`\n2. Run `bash ./scripts/bump-version.bash 1.2.3`\n3. Wait until [the CI release job](.github/workflows/release.yaml) completes successfully:\n   - GoReleaser builds release binaries and make pre-release at GitHub and updates [Homebrew formula](./HomebrewFormula/actionlint.rb)\n   - The CI job also updates version string in `./scripts/download-actionlint.bash`\n4. Open the pre-release at [release page](https://github.com/rhysd/actionlint/releases) with browser\n5. Write up release notes, uncheck pre-release checkbox and publish the new release\n6. Run `make CHANGELOG.md` to update [CHANGELOG.md](./CHANGELOG.md) and make a commit for the change. This step requires\n   [changelog-from-release](https://github.com/rhysd/changelog-from-release).\n7. Run `git pull` to merge upstream changes to local `main` branch and run `git push origin main`\n8. Update the playground by `./playground/deploy.bash` if it is not updated yet for the release\n\n## How to generate the manual\n\n`actionlint.1` manual is generated from [`actionlint.1.ronn`](./man/actionlint.1.ronn) by [ronn](https://github.com/rtomayko/ronn).\n\n```sh\nronn ./man/actionlint.1.ronn\n```\n\nor\n\n```sh\nmake man\n```\n\n## How to develop playground\n\nVisit [`playground/README.md`](./playground/README.md).\n\n## How to deploy playground\n\nRun [`deploy.bash`](./playground/deploy.bash) at root of repository. It does:\n\n1. Ensure to install dependencies and to build `main.wasm`\n2. Copy all assets to `./playground-dist` directory\n3. Optimize `main.wasm` with `wasm-opt` which is a part of [Binaryen](https://github.com/WebAssembly/binaryen) toolchain\n3. Switch branch to `gh-pages`\n4. Move all files in `./playground-dist` to root of repository and add to repository\n5. Make commit for deployment\n\n```sh\n# Prepare deployment\nbash ./playground/deploy.bash\n# Check it works fine by visiting localhost:1234\nnpm run serve\n# If it looks good, deploy it\ngit push\n```\n\nNote: `SKIP_BUILD_WASM` environment variable can skip building `main.wasm` binary. Please set it when the Wasm binary\ndoesn't need to be updated. It is important to avoid bloating a repository size by including a big Wasm binary in a\ncommit.\n\n```sh\nSKIP_BUILD_WASM=true bash ./playground/deploy.bash\n```\n\n## Maintain auto-generated sources\n\nSome files are generated by scripts in [`scripts/`](./scripts) directory. These files are kept up-to-date by CI workflows.\n\n### Maintain `popular_actions.go`\n\n[`popular_actions.go`](./popular_actions.go) is a data set of metadata of popular actions hosted on GitHub. It is generated\nautomatically with `go generate`. The command runs [`generate-popular-actions`](./scripts/generate-popular-actions) script.\n\nThe script also can detect new major releases of popular actions on GitHub by giving `-d` flag.\n\nThe [`generate`](.github/workflows/generate.yaml) CI workflow weekly runs to detect new major releases and update\n`popular_actions.go`. Runs can be found [here](https://github.com/rhysd/actionlint/actions/workflows/generate.yaml).\n\n### Maintain `all_webhooks.go`\n\n[`all_webhooks.go`](./all_webhooks.go) is a table all webhooks supported by GitHub Actions to trigger workflows. Note that\nnot all webhooks are supported by GitHub Actions.\n\nIt is generated automatically with `go generate` running [`generate-webhook-events`](./scripts/generate-webhook-events) script.\n\nIt fetches [`events-that-trigger-workflows.md`](https://github.com/github/docs/blob/main/content/actions/learn-github-actions/events-that-trigger-workflows.md),\nparses the markdown document, and extracts webhook names and their types. For more details, see\n[README.md at the script directory](./scripts/generate-webhook-events/README.md).\n\nUpdating `all_webhooks.go` is run weekly on CI by [`generate`](.github/workflows/generate.yaml) workflow.\n\n### Maintain `actionlint-matcher.json`\n\n[`actionlint-matcher.json`](.github/actionlint-matcher.json) is a matcher configuration to extract error annotations from outputs\nof `actionlint` command. See [the document](docs/usage.md#problem-matchers) for its usage.\n\nThe regular expression is complicated because it can matches to outputs which contain ANSI color escape sequences. So the JSON\nfile is not modified manually.\n\nIt is generated by [`generate-actionlint-matcher`](./scripts/generate-actionlint-matcher) script. See the README.md file for the\nusage of the script and how to run the tests for it.\n\n### Maintain `availability.go`\n\n[`availability.go`](./availability.go) is a table for conversion from workflow key (like `jobs.<job_id>.if`) to availability of\ncontexts and special functions. GitHub Actions limits contexts and functions in certain places. For example:\n\n- limited workflow keys can access `secrets` context\n- `jobs.<job_id>.if` and `jobs.<job_id>.steps.if` can use `always()` function.\n\n`availability.go` is generated from [the contexts document](https://github.com/github/docs/blob/main/content/actions/learn-github-actions/contexts.md#context-availability)\nusing [generate-availability](./scripts/generate-availability) script. It is run through `go generate` in `rule_expression.go`.\nSee [the readme of the script](./scripts/generate-availability/README.md) for the usage of the script.\n\nUpdate for `availability.go` is run weekly on CI by [`generate`](.github/workflows/generate.yaml) workflow.\n\n## Testing\n\nAll tests are automated.\n\n- Unit tests are implemented in `*_test.go` files for testing the corresponding APIs. Test data for unit tests are put in\n  `testdata/` directory.\n- UI tests based on matching to error messages are implemented in `linter_test.go` and all test data are stored in `testdata/`\n  directory.\n  - `testdata/examples/` contains tests for all examples in ['Checks' document](docs/checks.md). `*.yaml` files are an input\n    workflow and `*.out` files are expected error messages.\n  - `testdata/ok/` contains 'OK' tests. All workflow files in this directory should cause no errors.\n  - `testdata/err/` contains 'Error' tests. Each `*.yaml` files are workflow inputs and corresponding `*.out` files are expected\n    error messages (one error per line).\n  - `testdata/projects/` contains 'Project' tests. Each directories represent a single project (meaning a repository on GitHub).\n    Corresponding `*.out` files are expected error messages. Empty `*.out` file means the test case should cause no errors.\n    'Project' test is used for use cases where multiple files are related (reusable workflows, local actions, config files, ...).\n\n<a id=\"about-checks-doc\"></a>\n## How to write checks document\n\nThe ['Checks' document](./docs/checks.md) is a large document to explain all checks by actionlint.\n\nThis document is maintained with [`check-checks`](./scripts/check-checks) script. This script automatically updates\nthe code blocks after `Output:` and the `Playground` links. This script should be run after modifying the document.\n\nPlease see [the readme of the script](./scripts/check-checks/README.md) for the usage and knowing the details of the\ndocument format that this script assumes.\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.55859375,
          "content": "ARG GOLANG_VER=latest\nARG ALPINE_VER=latest\n\nFROM golang:${GOLANG_VER} as builder\nWORKDIR /go/src/app\nCOPY go.* *.go ./\nCOPY cmd cmd/\nENV CGO_ENABLED 0\nARG ACTIONLINT_VER=\nRUN go build -v -ldflags \"-s -w -X github.com/rhysd/actionlint.version=${ACTIONLINT_VER}\" ./cmd/actionlint\n\nFROM koalaman/shellcheck-alpine:stable as shellcheck\n\nFROM alpine:${ALPINE_VER}\nCOPY --from=builder /go/src/app/actionlint /usr/local/bin/\nCOPY --from=shellcheck /bin/shellcheck /usr/local/bin/shellcheck\nRUN apk add --no-cache py3-pyflakes\nUSER guest\nENTRYPOINT [\"/usr/local/bin/actionlint\"]\n"
        },
        {
          "name": "HomebrewFormula",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE.txt",
          "type": "blob",
          "size": 1.0419921875,
          "content": "the MIT License\n\nCopyright (c) 2021 rhysd\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\nINCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\nPURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\nTHE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.6494140625,
          "content": "SRCS := $(filter-out %_test.go, $(wildcard *.go cmd/actionlint/*.go)) go.mod go.sum .git-hooks/.timestamp\nTESTS := $(filter %_test.go, $(wildcard *.go))\nTOOL := $(filter %_test.go, $(wildcard scripts/*/*.go))\nTESTDATA := $(wildcard \\\n\t\ttestdata/examples/* \\\n\t\ttestdata/err/* \\\n\t\ttestdata/ok/* \\\n\t\ttestdata/config/* \\\n\t\ttestdata/format/* \\\n\t\ttestdata/projects/* \\\n\t\ttestdata/reusable_workflow_metadata/* \\\n\t)\nGO_GEN_SRCS := scripts/generate-popular-actions/main.go \\\n\t\t\t\tscripts/generate-popular-actions/popular_actions.json \\\n\t\t\t\tscripts/generate-webhook-events/main.go \\\n\t\t\t\tscripts/generate-availability/main.go\n\nall: build test lint\n\n.testtimestamp: $(TESTS) $(SRCS) $(TESTDATA) $(TOOL)\n\tgo test ./...\n\ttouch .testtimestamp\n\nt test: .testtimestamp\n\n.linttimestamp: $(TESTS) $(SRCS) $(TOOL) docs/checks.md\n\tgo vet ./...\n\tstaticcheck ./...\n\tGOOS=js GOARCH=wasm staticcheck ./playground\n\tgo run ./scripts/check-checks -quiet ./docs/checks.md\n\ttouch .linttimestamp\n\nl lint: .linttimestamp\n\npopular_actions.go all_webhooks.go availability.go: $(GO_GEN_SRCS)\nifdef SKIP_GO_GENERATE\n\ttouch popular_actions.go all_webhooks.go availability.go\nelse\n\tgo generate\nendif\n\nactionlint: $(SRCS)\n\tCGO_ENABLED=0 go build ./cmd/actionlint\n\nb build: actionlint\n\nactionlint_fuzz-fuzz.zip:\n\tgo-fuzz-build ./fuzz\n\nfuzz: actionlint_fuzz-fuzz.zip\n\tgo-fuzz -bin ./actionlint_fuzz-fuzz.zip -func $(FUZZ_FUNC)\n\nman/actionlint.1 man/actionlint.1.html: man/actionlint.1.ronn\n\tronn man/actionlint.1.ronn\n\nman: man/actionlint.1\n\nbench:\n\tgo test -bench Lint -benchmem\n\n.github/actionlint-matcher.json: scripts/generate-actionlint-matcher/object.mjs\n\tnode ./scripts/generate-actionlint-matcher/main.mjs .github/actionlint-matcher.json\n\nscripts/generate-actionlint-matcher/test/escape.txt: actionlint\n\t./actionlint -color ./testdata/err/one_error.yaml > ./scripts/generate-actionlint-matcher/test/escape.txt || true\nscripts/generate-actionlint-matcher/test/no_escape.txt: actionlint\n\t./actionlint -no-color ./testdata/err/one_error.yaml > ./scripts/generate-actionlint-matcher/test/no_escape.txt || true\nscripts/generate-actionlint-matcher/test/want.json: actionlint\n\t./actionlint -format '{{json .}}' ./testdata/err/one_error.yaml > scripts/generate-actionlint-matcher/test/want.json || true\n\nCHANGELOG.md: .bumptimestamp\n\tchangelog-from-release > CHANGELOG.md\n\nc clean:\n\trm -f ./actionlint ./.testtimestamp ./.linttimestamp ./actionlint_fuzz-fuzz.zip ./man/actionlint.1 ./man/actionlint.1.html ./actionlint-workflow-ast\n\trm -rf ./corpus ./crashers\n\n.git-hooks/.timestamp: .git-hooks/pre-push\n\t[ -z \"${CI}\" ] && git config core.hooksPath .git-hooks || true\n\ttouch .git-hooks/.timestamp\n\n.PHONY: all test clean build lint fuzz man bench b t c l\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 8.009765625,
          "content": "actionlint\n==========\n[![CI Status][ci-badge]][ci]\n[![API Document][apidoc-badge]][apidoc]\n\n[actionlint][repo] is a static checker for GitHub Actions workflow files. [Try it online!][playground]\n\nFeatures:\n\n- **Syntax check for workflow files** to check unexpected or missing keys following [workflow syntax][syntax-doc]\n- **Strong type check for `${{ }}` expressions** to catch several semantic errors like access to not existing property,\n  type mismatches, ...\n- **Actions usage check** to check that inputs at `with:` and outputs in `steps.{id}.outputs` are correct\n- **Reusable workflow check** to check inputs/outputs/secrets of reusable workflows and workflow calls\n- **[shellcheck][] and [pyflakes][] integrations** for scripts at `run:`\n- **Security checks**; [script injection][script-injection-doc] by untrusted inputs, hard-coded credentials\n- **Other several useful checks**; [glob syntax][filter-pattern-doc] validation, dependencies check for `needs:`,\n  runner label validation, cron syntax validation, ...\n\nSee the [full list][checks] of checks done by actionlint.\n\n<img src=\"https://github.com/rhysd/ss/blob/master/actionlint/main.gif?raw=true\" alt=\"actionlint reports 7 errors\" width=\"806\" height=\"492\"/>\n\n**Example of broken workflow:**\n\n```yaml\non:\n  push:\n    branch: main\n    tags:\n      - 'v\\d+'\njobs:\n  test:\n    strategy:\n      matrix:\n        os: [macos-latest, linux-latest]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - run: echo \"Checking commit '${{ github.event.head_commit.message }}'\"\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node_version: 18.x\n      - uses: actions/cache@v4\n        with:\n          path: ~/.npm\n          key: ${{ matrix.platform }}-node-${{ hashFiles('**/package-lock.json') }}\n        if: ${{ github.repository.permissions.admin == true }}\n      - run: npm install && npm test\n```\n\n**actionlint reports 7 errors:**\n\n```\ntest.yaml:3:5: unexpected key \"branch\" for \"push\" section. expected one of \"branches\", \"branches-ignore\", \"paths\", \"paths-ignore\", \"tags\", \"tags-ignore\", \"types\", \"workflows\" [syntax-check]\n  |\n3 |     branch: main\n  |     ^~~~~~~\ntest.yaml:5:11: character '\\' is invalid for branch and tag names. only special characters [, ?, +, *, \\, ! can be escaped with \\. see `man git-check-ref-format` for more details. note that regular expression is unavailable. note: filter pattern syntax is explained at https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet [glob]\n  |\n5 |       - 'v\\d+'\n  |           ^~~~\ntest.yaml:10:28: label \"linux-latest\" is unknown. available labels are \"windows-latest\", \"windows-latest-8-cores\", \"windows-2025\", \"windows-2022\", \"windows-2019\", \"ubuntu-latest\", \"ubuntu-latest-4-cores\", \"ubuntu-latest-8-cores\", \"ubuntu-latest-16-cores\", \"ubuntu-24.04\", \"ubuntu-22.04\", \"ubuntu-20.04\", \"macos-latest\", \"macos-latest-xl\", \"macos-latest-xlarge\", \"macos-latest-large\", \"macos-15-xlarge\", \"macos-15-large\", \"macos-15\", \"macos-14-xl\", \"macos-14-xlarge\", \"macos-14-large\", \"macos-14\", \"macos-13-xl\", \"macos-13-xlarge\", \"macos-13-large\", \"macos-13\", \"self-hosted\", \"x64\", \"arm\", \"arm64\", \"linux\", \"macos\", \"windows\". if it is a custom label for self-hosted runner, set list of labels in actionlint.yaml config file [runner-label]\n   |\n10 |         os: [macos-latest, linux-latest]\n   |                            ^~~~~~~~~~~~~\ntest.yaml:13:41: \"github.event.head_commit.message\" is potentially untrusted. avoid using it directly in inline scripts. instead, pass it through an environment variable. see https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions for more details [expression]\n   |\n13 |       - run: echo \"Checking commit '${{ github.event.head_commit.message }}'\"\n   |                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ntest.yaml:17:11: input \"node_version\" is not defined in action \"actions/setup-node@v4\". available inputs are \"always-auth\", \"architecture\", \"cache\", \"cache-dependency-path\", \"check-latest\", \"node-version\", \"node-version-file\", \"registry-url\", \"scope\", \"token\" [action]\n   |\n17 |           node_version: 18.x\n   |           ^~~~~~~~~~~~~\ntest.yaml:21:20: property \"platform\" is not defined in object type {os: string} [expression]\n   |\n21 |           key: ${{ matrix.platform }}-node-${{ hashFiles('**/package-lock.json') }}\n   |                    ^~~~~~~~~~~~~~~\ntest.yaml:22:17: receiver of object dereference \"permissions\" must be type of object but got \"string\" [expression]\n   |\n22 |         if: ${{ github.repository.permissions.admin == true }}\n   |                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n```\n\n## Quick start\n\nInstall `actionlint` command by downloading [the released binary][releases] or by Homebrew or by `go install`. See\n[the installation document][install] for more details like how to manage the command with several package managers\nor run via Docker container.\n\n```sh\ngo install github.com/rhysd/actionlint/cmd/actionlint@latest\n```\n\nBasically all you need to do is run the `actionlint` command in your repository. actionlint automatically detects workflows and\nchecks errors. actionlint focuses on finding out mistakes. It tries to catch errors as much as possible and make false positives\nas minimal as possible.\n\n```sh\nactionlint\n```\n\nAnother option to try actionlint is [the online playground][playground]. Your browser can run actionlint through WebAssembly.\n\nSee [the usage document][usage] for more details.\n\n## Documents\n\n- [Checks][checks]: Full list of all checks done by actionlint with example inputs, outputs, and playground links.\n- [Installation][install]: Installation instructions. Prebuilt binaries, a Docker image, building from source, a download script\n  (for CI), supports by several package managers are available.\n- [Usage][usage]: How to use `actionlint` command locally or on GitHub Actions, the online playground, an official Docker image,\n  and integrations with reviewdog, Problem Matchers, super-linter, pre-commit, VS Code.\n- [Configuration][config]: How to configure actionlint behavior. Currently, the labels of self-hosted runners, the configuration\n  variables, and ignore patterns of errors for each file paths can be set.\n- [Go API][api]: How to use actionlint as Go library.\n- [References][refs]: Links to resources.\n\n## Bug reporting\n\nWhen you see some bugs or false positives, it is helpful to [file a new issue][issue-form] with a minimal example\nof input. Giving me some feedbacks like feature requests or ideas of additional checks is also welcome.\n\nSee the [contribution guide](./CONTRIBUTING.md) for more details.\n\n## License\n\nactionlint is distributed under [the MIT license](./LICENSE.txt).\n\n[ci-badge]: https://github.com/rhysd/actionlint/actions/workflows/ci.yaml/badge.svg\n[ci]: https://github.com/rhysd/actionlint/actions/workflows/ci.yaml\n[apidoc-badge]: https://pkg.go.dev/badge/github.com/rhysd/actionlint.svg\n[apidoc]: https://pkg.go.dev/github.com/rhysd/actionlint\n[repo]: https://github.com/rhysd/actionlint\n[playground]: https://rhysd.github.io/actionlint/\n[shellcheck]: https://github.com/koalaman/shellcheck\n[pyflakes]: https://github.com/PyCQA/pyflakes\n[syntax-doc]: https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions\n[filter-pattern-doc]: https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet\n[script-injection-doc]: https://docs.github.com/en/actions/learn-github-actions/security-hardening-for-github-actions#understanding-the-risk-of-script-injections\n[releases]: https://github.com/rhysd/actionlint/releases\n[checks]: https://github.com/rhysd/actionlint/blob/v1.7.6/docs/checks.md\n[install]: https://github.com/rhysd/actionlint/blob/v1.7.6/docs/install.md\n[usage]: https://github.com/rhysd/actionlint/blob/v1.7.6/docs/usage.md\n[config]: https://github.com/rhysd/actionlint/blob/v1.7.6/docs/config.md\n[api]: https://github.com/rhysd/actionlint/blob/v1.7.6/docs/api.md\n[refs]: https://github.com/rhysd/actionlint/blob/v1.7.6/docs/reference.md\n[issue-form]: https://github.com/rhysd/actionlint/issues/new\n"
        },
        {
          "name": "action_metadata.go",
          "type": "blob",
          "size": 10.373046875,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\n//go:generate go run ./scripts/generate-popular-actions ./popular_actions.go\n\n// ActionMetadataInput is input metadata in \"inputs\" section in action.yml metadata file.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs\ntype ActionMetadataInput struct {\n\t// Name is a name of this input.\n\tName string `json:\"name\"`\n\t// Required is true when this input is mandatory to run the action.\n\tRequired bool `json:\"required\"`\n}\n\n// ActionMetadataInputs is a map from input ID to its metadata. Keys are in lower case since input\n// names are case-insensitive.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#inputs\ntype ActionMetadataInputs map[string]*ActionMetadataInput\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (inputs *ActionMetadataInputs) UnmarshalYAML(n *yaml.Node) error {\n\tif n.Kind != yaml.MappingNode {\n\t\treturn expectedMapping(\"inputs\", n)\n\t}\n\n\ttype actionInputMetadata struct {\n\t\tRequired bool    `yaml:\"required\"`\n\t\tDefault  *string `yaml:\"default\"`\n\t}\n\n\tmd := make(ActionMetadataInputs, len(n.Content)/2)\n\tfor i := 0; i < len(n.Content); i += 2 {\n\t\tk, v := n.Content[i].Value, n.Content[i+1]\n\n\t\tvar m actionInputMetadata\n\t\tif err := v.Decode(&m); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tid := strings.ToLower(k)\n\t\tif _, ok := md[id]; ok {\n\t\t\treturn fmt.Errorf(\"input %q is duplicated\", k)\n\t\t}\n\n\t\tmd[id] = &ActionMetadataInput{k, m.Required && m.Default == nil}\n\t}\n\n\t*inputs = md\n\treturn nil\n}\n\n// ActionMetadataOutput is output metadata in \"outputs\" section in action.yml metadata file.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#outputs-for-composite-actions\ntype ActionMetadataOutput struct {\n\tName string `json:\"name\"`\n}\n\n// ActionMetadataOutputs is a map from output ID to its metadata. Keys are in lower case since output\n// names are case-insensitive.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#outputs-for-composite-actions\ntype ActionMetadataOutputs map[string]*ActionMetadataOutput\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (inputs *ActionMetadataOutputs) UnmarshalYAML(n *yaml.Node) error {\n\tif n.Kind != yaml.MappingNode {\n\t\treturn expectedMapping(\"outputs\", n)\n\t}\n\n\tmd := make(ActionMetadataOutputs, len(n.Content)/2)\n\tfor i := 0; i < len(n.Content); i += 2 {\n\t\tk := n.Content[i].Value\n\t\tid := strings.ToLower(k)\n\t\tif _, ok := md[id]; ok {\n\t\t\treturn fmt.Errorf(\"output %q is duplicated\", k)\n\t\t}\n\t\tmd[id] = &ActionMetadataOutput{k}\n\t}\n\n\t*inputs = md\n\treturn nil\n}\n\n// ActionMetadataRuns is \"runs\" section of action.yaml. It defines how the action is run.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runs\ntype ActionMetadataRuns struct {\n\t// Using is `using` configuration of action.yaml. It defines what runner is used for the action.\n\tUsing string `yaml:\"using\" json:\"using\"`\n\t// Main is `main` configuration of action.yaml for JavaScript action.\n\tMain string `yaml:\"main\" json:\"main\"`\n\t// Pre is `pre` configuration of action.yaml for JavaScript action.\n\tPre string `yaml:\"pre\" json:\"pre\"`\n\t// PreIf is `pre-if` configuration of action.yaml for JavaScript action.\n\tPreIf string `yaml:\"pre-if\" json:\"pre-if\"`\n\t// Post is `post` configuration of action.yaml for JavaScript action.\n\tPost string `yaml:\"post\" json:\"post\"`\n\t// PostIf is `post-if` configuration of action.yaml for JavaScript action.\n\tPostIf string `yaml:\"post-if\" json:\"post-if\"`\n\t// Steps is `steps` configuration of action.yaml for Composite action.\n\tSteps []any `yaml:\"steps\" json:\"steps\"`\n\t// Image is `image` of action.yaml for Docker action.\n\tImage string `yaml:\"image\" json:\"image\"`\n\t// PreEntrypoint is `pre-entrypoint` of action.yaml for Docker action.\n\tPreEntrypoint string `yaml:\"pre-entrypoint\" json:\"pre-entrypoint\"`\n\t// Entrypoint is `entrypoint` of action.yaml for Docker action.\n\tEntrypoint string `yaml:\"entrypoint\" json:\"entrypoint\"`\n\t// PostEntrypoint is `post-entrypoint` of action.yaml for Docker action.\n\tPostEntrypoint string `yaml:\"post-entrypoint\" json:\"post-entrypoint\"`\n\t// Args is `args` of action.yaml for Docker action.\n\tArgs []any `yaml:\"args\" json:\"args\"`\n\t// Env is `env` of action.yaml for Docker action.\n\tEnv map[string]any `yaml:\"env\" json:\"env\"`\n}\n\n// ActionMetadataBranding is \"branding\" section of action.yaml.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#branding\ntype ActionMetadataBranding struct {\n\tIcon  string `yaml:\"icon\"`\n\tColor string `yaml:\"color\"`\n}\n\n// ActionMetadata represents structure of action.yaml.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions\ntype ActionMetadata struct {\n\tdir  string\n\tfile string\n\t// Name is \"name\" field of action.yaml.\n\tName string `yaml:\"name\" json:\"name\"`\n\t// Description is \"description\" field of action.yaml.\n\tDescription string `yaml:\"description\" json:\"-\"`\n\t// Inputs is \"inputs\" field of action.yaml.\n\tInputs ActionMetadataInputs `yaml:\"inputs\" json:\"inputs\"`\n\t// Outputs is \"outputs\" field of action.yaml. Key is name of output. Description is omitted\n\t// since actionlint does not use it.\n\tOutputs ActionMetadataOutputs `yaml:\"outputs\" json:\"outputs\"`\n\t// SkipInputs is flag to specify behavior of inputs check. When it is true, inputs for this\n\t// action will not be checked.\n\tSkipInputs bool `yaml:\"-\" json:\"skip_inputs\"`\n\t// SkipOutputs is flag to specify a bit loose typing to outputs object. If it is set to\n\t// true, the outputs object accepts any properties along with strictly typed props.\n\tSkipOutputs bool `yaml:\"-\" json:\"skip_outputs\"`\n\t// Runs is \"runs\" field of action.yaml.\n\tRuns ActionMetadataRuns `yaml:\"runs\" json:\"runs\"`\n\t// Branding is \"branding\" field of action.yaml.\n\tBranding ActionMetadataBranding `yaml:\"branding\" json:\"-\"`\n}\n\n// Dir returns a directory path of the action.\nfunc (md *ActionMetadata) Dir() string {\n\treturn md.dir\n}\n\n// Path returns a file path of the action's metadata file.\nfunc (md *ActionMetadata) Path() string {\n\treturn filepath.Join(md.dir, md.file)\n}\n\n// LocalActionsCache is cache for local actions' metadata. It avoids repeating to find/read/parse\n// local action's metadata file (action.yml).\n// This cache is not available across multiple repositories. One LocalActionsCache instance needs\n// to be created per one repository.\ntype LocalActionsCache struct {\n\tmu    sync.RWMutex\n\tproj  *Project // might be nil\n\tcache map[string]*ActionMetadata\n\tdbg   io.Writer\n}\n\n// NewLocalActionsCache creates new LocalActionsCache instance for the given project.\nfunc NewLocalActionsCache(proj *Project, dbg io.Writer) *LocalActionsCache {\n\treturn &LocalActionsCache{\n\t\tproj:  proj,\n\t\tcache: map[string]*ActionMetadata{},\n\t\tdbg:   dbg,\n\t}\n}\n\nfunc newNullLocalActionsCache(dbg io.Writer) *LocalActionsCache {\n\t// Null cache. Cache never hits. It is used when project is not found\n\treturn &LocalActionsCache{dbg: dbg}\n}\n\nfunc (c *LocalActionsCache) debug(format string, args ...interface{}) {\n\tif c.dbg == nil {\n\t\treturn\n\t}\n\tformat = \"[LocalActionsCache] \" + format + \"\\n\"\n\tfmt.Fprintf(c.dbg, format, args...)\n}\n\nfunc (c *LocalActionsCache) readCache(key string) (*ActionMetadata, bool) {\n\tc.mu.RLock()\n\tm, ok := c.cache[key]\n\tc.mu.RUnlock()\n\treturn m, ok\n}\n\nfunc (c *LocalActionsCache) writeCache(key string, val *ActionMetadata) {\n\tc.mu.Lock()\n\tc.cache[key] = val\n\tc.mu.Unlock()\n}\n\n// FindMetadata finds metadata for given spec. The spec should indicate for local action hence it\n// should start with \"./\". The first return value can be nil even if error did not occur.\n// LocalActionCache caches that the action was not found. At first search, it returns an error that\n// the action was not found. But at the second search, it does not return an error even if the result\n// is nil. This behavior prevents repeating to report the same error from multiple places.\n// Calling this method is thread-safe.\nfunc (c *LocalActionsCache) FindMetadata(spec string) (*ActionMetadata, bool, error) {\n\tif c.proj == nil || !strings.HasPrefix(spec, \"./\") {\n\t\treturn nil, false, nil\n\t}\n\n\tif m, ok := c.readCache(spec); ok {\n\t\tc.debug(\"Cache hit for %s: %v\", spec, m)\n\t\treturn m, true, nil\n\t}\n\n\tdir := filepath.Join(c.proj.RootDir(), filepath.FromSlash(spec))\n\tb, f, ok := c.readLocalActionMetadataFile(dir)\n\tif !ok {\n\t\tc.debug(\"No action metadata found in %s\", dir)\n\t\t// Remember action was not found\n\t\tc.writeCache(spec, nil)\n\t\t// Do not complain about the action does not exist (#25, #40).\n\t\t// It seems a common pattern that the local action does not exist in the repository\n\t\t// (e.g. Git submodule) and it is cloned at running workflow (due to a private repository).\n\t\treturn nil, false, nil\n\t}\n\n\tvar meta ActionMetadata\n\tif err := yaml.Unmarshal(b, &meta); err != nil {\n\t\tc.writeCache(spec, nil) // Remember action was invalid\n\t\tmsg := strings.ReplaceAll(err.Error(), \"\\n\", \" \")\n\t\treturn nil, false, fmt.Errorf(\"could not parse action metadata in %q: %s\", dir, msg)\n\t}\n\tmeta.file = f\n\tmeta.dir = dir\n\n\tc.debug(\"New metadata parsed from action %s: %v\", dir, &meta)\n\tc.writeCache(spec, &meta)\n\treturn &meta, false, nil\n}\n\nfunc (c *LocalActionsCache) readLocalActionMetadataFile(dir string) ([]byte, string, bool) {\n\tfor _, f := range []string{\"action.yaml\", \"action.yml\"} {\n\t\tp := filepath.Join(dir, f)\n\t\tif b, err := os.ReadFile(p); err == nil {\n\t\t\treturn b, f, true\n\t\t}\n\t}\n\n\treturn nil, \"\", false\n}\n\n// LocalActionsCacheFactory is a factory to create LocalActionsCache instances. LocalActionsCache\n// should be created for each repositories. LocalActionsCacheFactory creates new LocalActionsCache\n// instance per repository (project).\ntype LocalActionsCacheFactory struct {\n\tcaches map[string]*LocalActionsCache\n\tdbg    io.Writer\n}\n\n// GetCache returns LocalActionsCache instance for the given project. One LocalActionsCache is\n// created per one repository. Created instances are cached and will be used when caches are\n// requested for the same projects. This method is not thread safe.\nfunc (f *LocalActionsCacheFactory) GetCache(p *Project) *LocalActionsCache {\n\tif p == nil {\n\t\treturn newNullLocalActionsCache(f.dbg)\n\t}\n\tr := p.RootDir()\n\tif c, ok := f.caches[r]; ok {\n\t\treturn c\n\t}\n\tc := NewLocalActionsCache(p, f.dbg)\n\tf.caches[r] = c\n\treturn c\n}\n\n// NewLocalActionsCacheFactory creates a new LocalActionsCacheFactory instance.\nfunc NewLocalActionsCacheFactory(dbg io.Writer) *LocalActionsCacheFactory {\n\treturn &LocalActionsCacheFactory{map[string]*LocalActionsCache{}, dbg}\n}\n"
        },
        {
          "name": "action_metadata_test.go",
          "type": "blob",
          "size": 13.65234375,
          "content": "package actionlint\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc testGetWantedActionMetadata() *ActionMetadata {\n\twant := &ActionMetadata{\n\t\tName:        \"My action\",\n\t\tDescription: \"my action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"name\":     {\"name\", false},\n\t\t\t\"message\":  {\"message\", true},\n\t\t\t\"addition\": {\"addition\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"user_id\": {\"user_id\"},\n\t\t},\n\t\tRuns: ActionMetadataRuns{\n\t\t\tUsing: \"node20\",\n\t\t\tMain:  \"index.js\",\n\t\t},\n\t}\n\treturn want\n}\n\nfunc testDiffActionMetadata(t *testing.T, want, have *ActionMetadata, opts ...cmp.Option) {\n\tt.Helper()\n\topts = append(opts, cmpopts.IgnoreUnexported(ActionMetadata{}))\n\tif diff := cmp.Diff(want, have, opts...); diff != \"\" {\n\t\tt.Fatal(diff)\n\t}\n}\n\nfunc testCheckActionMetadataPath(t *testing.T, dir string, m *ActionMetadata) {\n\tt.Helper()\n\n\tvar want string\n\td := filepath.Join(\"testdata\", \"action_metadata\", dir)\n\tfor _, f := range []string{\"action.yml\", \"action.yaml\"} {\n\t\tp := filepath.Join(d, f)\n\t\tif _, err := os.Stat(p); err == nil {\n\t\t\twant = p\n\t\t}\n\t}\n\tif want == \"\" {\n\t\tpanic(\"metadata file doesn't exist in \" + d)\n\t}\n\n\tif have := m.Path(); have != want {\n\t\tt.Errorf(\"action metadata file path for %q is actually %q but wanted %q\", dir, have, want)\n\t}\n\n\twant = filepath.Dir(want)\n\tif have := m.Dir(); have != want {\n\t\tt.Errorf(\"action directory path for %q is actually %q but wanted %q\", dir, have, want)\n\t}\n}\n\nfunc testCheckCachedFlag(t *testing.T, want, have bool) {\n\tt.Helper()\n\tif want != have {\n\t\tmsg := \"metadata should be cached but actually it is not cached\"\n\t\tif !want {\n\t\t\tmsg = \"metadata should not be cached but actually it is cached\"\n\t\t}\n\t\tt.Error(msg)\n\t}\n}\n\n// Normal cases\n\nfunc TestLocalActionsFindMetadataOK(t *testing.T) {\n\ttestdir := filepath.Join(\"testdata\", \"action_metadata\")\n\tproj := &Project{testdir, nil}\n\tc := NewLocalActionsCache(proj, nil)\n\n\twant := testGetWantedActionMetadata()\n\n\twantEmpty := testGetWantedActionMetadata()\n\twantEmpty.Inputs = nil\n\twantEmpty.Outputs = nil\n\n\twantUpper := testGetWantedActionMetadata()\n\tfor _, i := range wantUpper.Inputs {\n\t\ti.Name = strings.ToUpper(i.Name)\n\t}\n\tfor _, o := range wantUpper.Outputs {\n\t\to.Name = strings.ToUpper(o.Name)\n\t}\n\n\twantBranding := testGetWantedActionMetadata()\n\twantBranding.Branding.Icon = \"edit\"\n\twantBranding.Branding.Color = \"white\"\n\n\ttests := []struct {\n\t\tspec string\n\t\twant *ActionMetadata\n\t\tcmp  []cmp.Option\n\t}{\n\t\t{\n\t\t\tspec: \"./action-yml\",\n\t\t\twant: want,\n\t\t},\n\t\t{\n\t\t\tspec: \"./action-yaml\",\n\t\t\twant: want,\n\t\t},\n\t\t{\n\t\t\tspec: \"./empty\",\n\t\t\twant: wantEmpty,\n\t\t},\n\t\t{\n\t\t\tspec: \"./uppercase\",\n\t\t\twant: wantUpper,\n\t\t},\n\t\t{\n\t\t\tspec: \"./docker\",\n\t\t\twant: &ActionMetadata{\n\t\t\t\tName:        \"My action\",\n\t\t\t\tDescription: \"my action\",\n\t\t\t\tRuns: ActionMetadataRuns{\n\t\t\t\t\tUsing: \"docker\",\n\t\t\t\t\tImage: \"Dockerfile\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tspec: \"./composite\",\n\t\t\twant: &ActionMetadata{\n\t\t\t\tName:        \"My action\",\n\t\t\t\tDescription: \"my action\",\n\t\t\t\tRuns: ActionMetadataRuns{\n\t\t\t\t\tUsing: \"composite\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tcmp: []cmp.Option{\n\t\t\t\tcmpopts.IgnoreFields(ActionMetadataRuns{}, \"Steps\"),\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tspec: \"./branding\",\n\t\t\twant: wantBranding,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.spec, func(t *testing.T) {\n\t\t\t// read metadata repeatedly (should be cached)\n\t\t\tfor i := 0; i < 3; i++ {\n\t\t\t\thave, cached, err := c.FindMetadata(tc.spec)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(i, err)\n\t\t\t\t}\n\t\t\t\tif have == nil {\n\t\t\t\t\tt.Fatal(i, \"metadata is nil\")\n\t\t\t\t}\n\t\t\t\ttestCheckCachedFlag(t, cached, i > 0)\n\t\t\t\ttestDiffActionMetadata(t, tc.want, have, tc.cmp...)\n\t\t\t\ttestCheckActionMetadataPath(t, tc.spec, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLocalActionsFindConcurrently(t *testing.T) {\n\tn := 10\n\tproj := &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil}\n\tc := NewLocalActionsCache(proj, nil)\n\tret := make(chan *ActionMetadata)\n\terr := make(chan error)\n\n\tfor i := 0; i < n; i++ {\n\t\tgo func() {\n\t\t\tm, _, e := c.FindMetadata(\"./action-yml\")\n\t\t\tif e != nil {\n\t\t\t\terr <- e\n\t\t\t\treturn\n\t\t\t}\n\t\t\tret <- m\n\t\t}()\n\t}\n\n\tms := []*ActionMetadata{}\n\terrs := []error{}\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase m := <-ret:\n\t\t\tms = append(ms, m)\n\t\tcase e := <-err:\n\t\t\terrs = append(errs, e)\n\t\t}\n\t}\n\n\tif len(errs) != 0 {\n\t\tt.Fatal(\"some error occurred:\", errs)\n\t}\n\n\twant := testGetWantedActionMetadata()\n\tfor _, have := range ms {\n\t\ttestDiffActionMetadata(t, want, have)\n\t}\n\n\t_, cached, _ := c.FindMetadata(\"./action-yml\")\n\ttestCheckCachedFlag(t, true, cached)\n}\n\nfunc TestLocalActionsParsingSkipped(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\tproj *Project\n\t\tspec string\n\t}{\n\t\t{\n\t\t\twhat: \"project is nil\",\n\t\t\tproj: nil,\n\t\t\tspec: \"./action\",\n\t\t},\n\t\t{\n\t\t\twhat: \"not a local action\",\n\t\t\tproj: &Project{\"\", nil},\n\t\t\tspec: \"actions/checkout@v4\",\n\t\t},\n\t\t{\n\t\t\twhat: \"action does not exist (#25, #40)\",\n\t\t\tproj: &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil},\n\t\t\tspec: \"./this-action-does-not-exist\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tc := NewLocalActionsCache(tc.proj, nil)\n\t\t\tm, cached, err := c.FindMetadata(tc.spec)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(tc.spec, \"error occurred:\", err)\n\t\t\t}\n\t\t\tif m != nil {\n\t\t\t\tt.Fatal(tc.spec, \"metadata was parsed\", m)\n\t\t\t}\n\t\t\ttestCheckCachedFlag(t, false, cached)\n\t\t})\n\t}\n}\n\nfunc TestLocalActionsIgnoreRemoteActions(t *testing.T) {\n\tproj := &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil}\n\tc := NewLocalActionsCache(proj, nil)\n\tfor _, spec := range []string{\"actions/checkout@v2\", \"docker://example.com/foo/bar\"} {\n\t\tm, cached, err := c.FindMetadata(spec)\n\t\tif err != nil {\n\t\t\tt.Fatal(spec, \"error occurred:\", err)\n\t\t}\n\t\tif m != nil {\n\t\t\tt.Fatal(spec, \"metadata was parsed\", m)\n\t\t}\n\t\ttestCheckCachedFlag(t, false, cached)\n\t}\n}\n\nfunc TestLocalActionsLogCacheHit(t *testing.T) {\n\tdbg := &bytes.Buffer{}\n\ttestdir := filepath.Join(\"testdata\", \"action_metadata\")\n\tproj := &Project{testdir, nil}\n\tc := NewLocalActionsCache(proj, dbg)\n\n\twant := testGetWantedActionMetadata()\n\tfor i := 0; i < 2; i++ {\n\t\thave, _, err := c.FindMetadata(\"./action-yml\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ttestDiffActionMetadata(t, want, have)\n\t}\n\n\tlogs := strings.Split(strings.TrimSpace(dbg.String()), \"\\n\")\n\tif len(logs) != 2 {\n\t\tt.Fatalf(\"2 logs were expected but got %d logs: %#v\", len(logs), logs)\n\t}\n\tdir := filepath.Join(testdir, \"action-yml\")\n\tif !strings.Contains(logs[0], \"New metadata parsed from action \"+dir) {\n\t\tt.Fatalf(\"first log should be 'new metadata' but got %q\", logs[0])\n\t}\n\tif !strings.Contains(logs[1], \"Cache hit for ./action-yml\") {\n\t\tt.Fatalf(\"second log should be 'cache hit' but got %q\", logs[1])\n\t}\n}\n\nfunc TestLocalActionsNullCache(t *testing.T) {\n\tc := newNullLocalActionsCache(io.Discard)\n\tm, cached, err := c.FindMetadata(\"./path/to/action.yaml\")\n\tif m != nil {\n\t\tt.Error(\"metadata should not be found:\", m)\n\t}\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n\ttestCheckCachedFlag(t, false, cached)\n}\n\n// Error cases\n\nfunc TestLocalActionsBrokenMetadata(t *testing.T) {\n\ttests := []struct {\n\t\tspec string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tspec: \"./broken\",\n\t\t\twant: \"could not parse action metadata\",\n\t\t},\n\t}\n\n\tproj := &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil}\n\tc := NewLocalActionsCache(proj, nil)\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.spec, func(t *testing.T) {\n\t\t\tm, cached, err := c.FindMetadata(tc.spec)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"error was not returned\", m)\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.want) {\n\t\t\t\tt.Fatalf(\"expected error message %q to contain %q\", err, tc.want)\n\t\t\t}\n\t\t\ttestCheckCachedFlag(t, false, cached)\n\n\t\t\t// Second try does not return error, but metadata is also nil not to show the same error from\n\t\t\t// multiple rules.\n\t\t\tm, cached, err = c.FindMetadata(tc.spec)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"error was returned at second try\", err)\n\t\t\t}\n\t\t\tif m != nil {\n\t\t\t\tt.Fatal(\"metadata was not nil even if it does not exist\", m)\n\t\t\t}\n\t\t\ttestCheckCachedFlag(t, true, cached)\n\t\t})\n\t}\n}\n\nfunc TestLocalActionsDuplicateInputsOutputs(t *testing.T) {\n\tproj := &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil}\n\tc := NewLocalActionsCache(proj, nil)\n\n\tfor _, tc := range []struct {\n\t\tspec string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tspec: \"./input-duplicate\",\n\t\t\twant: \"input \\\"FOO\\\" is duplicated\",\n\t\t},\n\t\t{\n\t\t\tspec: \"./output-duplicate\",\n\t\t\twant: \"output \\\"FOO\\\" is duplicated\",\n\t\t},\n\t} {\n\t\tt.Run(tc.spec, func(t *testing.T) {\n\t\t\tm, cached, err := c.FindMetadata(tc.spec)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"error was not returned\", m)\n\t\t\t}\n\t\t\tmsg := err.Error()\n\t\t\tif !strings.Contains(msg, tc.want) {\n\t\t\t\tt.Fatalf(\"error %q was expected to include %q\", msg, tc.want)\n\t\t\t}\n\t\t\ttestCheckCachedFlag(t, false, cached)\n\t\t})\n\t}\n}\n\nfunc TestLocalActionsConcurrentFailures(t *testing.T) {\n\tn := 10\n\tproj := &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil}\n\tc := NewLocalActionsCache(proj, nil)\n\terrC := make(chan error)\n\n\tfor i := 0; i < n; i++ {\n\t\tgo func() {\n\t\t\t_, _, err := c.FindMetadata(\"./broken\")\n\t\t\terrC <- err\n\t\t}()\n\t}\n\n\terrs := []error{}\n\tfor i := 0; i < n; i++ {\n\t\terrs = append(errs, <-errC)\n\t}\n\n\t// At least once error was reported\n\tvar err error\n\tfor _, e := range errs {\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\", err)\n\t}\n\tif !strings.Contains(err.Error(), \"could not parse action metadata\") {\n\t\tt.Fatal(\"unexpected error:\", err)\n\t}\n}\n\nfunc TestLocalActionsConcurrentMultipleMetadataAndFailures(t *testing.T) {\n\tproj := &Project{filepath.Join(\"testdata\", \"action_metadata\"), nil}\n\tc := NewLocalActionsCache(proj, nil)\n\n\tinputs := []string{\n\t\t\"./action-yml\",\n\t\t\"./action-yaml\",\n\t\t\"./action-yml\",\n\t\t\"./broken\",\n\t\t\"./action-yaml\",\n\t\t\"./action-yaml\",\n\t\t\"./broken\",\n\t\t\"./action-yml\",\n\t\t\"./broken\",\n\t\t\"./action-yaml\",\n\t}\n\n\treqC := make(chan string)\n\tretC := make(chan *ActionMetadata)\n\terrC := make(chan error)\n\tdone := make(chan struct{})\n\n\tfor i := 0; i < 3; i++ {\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tselect {\n\t\t\t\tcase spec := <-reqC:\n\t\t\t\t\tm, _, err := c.FindMetadata(spec)\n\t\t\t\t\tif m == nil {\n\t\t\t\t\t\terrC <- err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\tretC <- m\n\t\t\t\tcase <-done:\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n\n\tgo func() {\n\t\tfor _, in := range inputs {\n\t\t\tselect {\n\t\t\tcase reqC <- in:\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\tret := []*ActionMetadata{}\n\terrs := []error{}\n\tfor i := 0; i < len(inputs); i++ {\n\t\tselect {\n\t\tcase m := <-retC:\n\t\t\tret = append(ret, m)\n\t\tcase err := <-errC:\n\t\t\terrs = append(errs, err)\n\t\t}\n\t}\n\tclose(done)\n\n\tnumErrs := 0\n\tfor _, in := range inputs {\n\t\tif in == \"./broken\" {\n\t\t\tnumErrs++\n\t\t}\n\t}\n\tnumRet := len(inputs) - numErrs\n\n\tif len(errs) != numErrs {\n\t\tt.Fatalf(\"wanted %d errors but got %d: %v\", numErrs, len(errs), errs)\n\t}\n\tif len(ret) != numRet {\n\t\tt.Fatalf(\"wanted %d errors but got %d: %v\", numRet, len(ret), ret)\n\t}\n\n\tvar err error\n\tfor _, e := range errs {\n\t\tif e != nil {\n\t\t\terr = e\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\", err)\n\t}\n\tif !strings.Contains(err.Error(), \"could not parse action metadata\") {\n\t\tt.Fatal(\"unexpected error:\", err)\n\t}\n\n\twant := testGetWantedActionMetadata()\n\tfor _, have := range ret {\n\t\ttestDiffActionMetadata(t, want, have)\n\t}\n}\n\nfunc TestActionMetadataYAMLUnmarshalOK(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat  string\n\t\tinput string\n\t\twant  ActionMetadata\n\t}{\n\t\t{\n\t\t\twhat:  \"no input and no output\",\n\t\t\tinput: `name: Test`,\n\t\t\twant: ActionMetadata{\n\t\t\t\tName: \"Test\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"inputs\",\n\t\t\tinput: `name: Test\ninputs:\n  input1:\n    description: test\n  input2:\n    description: test\n    required: false\n  input3:\n    description: test\n    required: true\n    default: 'default'\n  input4:\n    description: test\n    required: false\n    default: 'default'\n  input5:\n    description: test\n    required: true`,\n\t\t\twant: ActionMetadata{\n\t\t\t\tName: \"Test\",\n\t\t\t\tInputs: ActionMetadataInputs{\n\t\t\t\t\t\"input1\": {\"input1\", false},\n\t\t\t\t\t\"input2\": {\"input2\", false},\n\t\t\t\t\t\"input3\": {\"input3\", false},\n\t\t\t\t\t\"input4\": {\"input4\", false},\n\t\t\t\t\t\"input5\": {\"input5\", true},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"outputs\",\n\t\t\tinput: `name: Test\noutputs:\n  output1:\n    description: test\n  output2:\n    description: test\n`,\n\t\t\twant: ActionMetadata{\n\t\t\t\tName: \"Test\",\n\t\t\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\t\t\"output1\": {\"output1\"},\n\t\t\t\t\t\"output2\": {\"output2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tvar have ActionMetadata\n\t\t\tif err := yaml.Unmarshal([]byte(tc.input), &have); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\ttestDiffActionMetadata(t, &tc.want, &have)\n\t\t})\n\t}\n}\n\nfunc TestActionMetadataYAMLUnmarshalError(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat  string\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\twhat: \"invalid inputs\",\n\t\t\tinput: `name: Test\ninputs: \"foo\"`,\n\t\t\twant: \"inputs must be mapping node\",\n\t\t},\n\t\t{\n\t\t\twhat: \"invalid inputs.*\",\n\t\t\tinput: `name: Test\ninputs:\n  input1: \"foo\"`,\n\t\t\twant: \"into actionlint.actionInputMetadata\",\n\t\t},\n\t\t{\n\t\t\twhat: \"invalid outputs\",\n\t\t\tinput: `name: Test\noutputs: \"foo\"`,\n\t\t\twant: \"outputs must be mapping node\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tvar data ActionMetadata\n\t\t\terr := yaml.Unmarshal([]byte(tc.input), &data)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"error did not occur\")\n\t\t\t}\n\t\t\tmsg := err.Error()\n\t\t\tif !strings.Contains(msg, tc.want) {\n\t\t\t\tt.Fatalf(\"%q is not contained in error message %q\", tc.want, msg)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLocalActionsCacheFactory(t *testing.T) {\n\tf := NewLocalActionsCacheFactory(io.Discard)\n\tp1 := &Project{\"path/to/project1\", nil}\n\tc1 := f.GetCache(p1)\n\n\tp2 := &Project{\"path/to/project2\", nil}\n\tc2 := f.GetCache(p2)\n\tif c1 == c2 {\n\t\tt.Errorf(\"different cache was not created: %v\", c1)\n\t}\n\n\tc3 := f.GetCache(p1)\n\tif c1 != c3 {\n\t\tt.Errorf(\"same cache is not returned for the same project: %v vs %v\", c1, c3)\n\t}\n\n\tc4 := f.GetCache(nil)\n\tif c4.proj != nil {\n\t\tt.Errorf(\"null cache must be returned if given project is nil: %v\", c4)\n\t}\n}\n"
        },
        {
          "name": "all_webhooks.go",
          "type": "blob",
          "size": 3.060546875,
          "content": "// Code generated by actionlint/scripts/generate-webhook-events. DO NOT EDIT.\n\npackage actionlint\n\n// AllWebhookTypes is a table of all webhooks with their types. This variable was generated by\n// script at ./scripts/generate-webhook-events based on\n// https://github.com/github/docs/blob/main/content/actions/using-workflows/events-that-trigger-workflows.md\nvar AllWebhookTypes = map[string][]string{\n\t\"branch_protection_rule\":      {\"created\", \"edited\", \"deleted\"},\n\t\"check_run\":                   {\"created\", \"rerequested\", \"completed\", \"requested_action\"},\n\t\"check_suite\":                 {\"completed\"},\n\t\"create\":                      {},\n\t\"delete\":                      {},\n\t\"deployment\":                  {},\n\t\"deployment_status\":           {},\n\t\"discussion\":                  {\"created\", \"edited\", \"deleted\", \"transferred\", \"pinned\", \"unpinned\", \"labeled\", \"unlabeled\", \"locked\", \"unlocked\", \"category_changed\", \"answered\", \"unanswered\"},\n\t\"discussion_comment\":          {\"created\", \"edited\", \"deleted\"},\n\t\"fork\":                        {},\n\t\"gollum\":                      {},\n\t\"issue_comment\":               {\"created\", \"edited\", \"deleted\"},\n\t\"issues\":                      {\"opened\", \"edited\", \"deleted\", \"transferred\", \"pinned\", \"unpinned\", \"closed\", \"reopened\", \"assigned\", \"unassigned\", \"labeled\", \"unlabeled\", \"locked\", \"unlocked\", \"milestoned\", \"demilestoned\"},\n\t\"label\":                       {\"created\", \"edited\", \"deleted\"},\n\t\"merge_group\":                 {\"checks_requested\"},\n\t\"milestone\":                   {\"created\", \"closed\", \"opened\", \"edited\", \"deleted\"},\n\t\"page_build\":                  {},\n\t\"project\":                     {\"created\", \"closed\", \"reopened\", \"edited\", \"deleted\"},\n\t\"project_card\":                {\"created\", \"moved\", \"converted\", \"edited\", \"deleted\"},\n\t\"project_column\":              {\"created\", \"updated\", \"moved\", \"deleted\"},\n\t\"public\":                      {},\n\t\"pull_request\":                {\"assigned\", \"unassigned\", \"labeled\", \"unlabeled\", \"opened\", \"edited\", \"closed\", \"reopened\", \"synchronize\", \"converted_to_draft\", \"locked\", \"unlocked\", \"enqueued\", \"dequeued\", \"milestoned\", \"demilestoned\", \"ready_for_review\", \"review_requested\", \"review_request_removed\", \"auto_merge_enabled\", \"auto_merge_disabled\"},\n\t\"pull_request_review\":         {\"submitted\", \"edited\", \"dismissed\"},\n\t\"pull_request_review_comment\": {\"created\", \"edited\", \"deleted\"},\n\t\"pull_request_target\":         {\"assigned\", \"unassigned\", \"labeled\", \"unlabeled\", \"opened\", \"edited\", \"closed\", \"reopened\", \"synchronize\", \"converted_to_draft\", \"ready_for_review\", \"locked\", \"unlocked\", \"review_requested\", \"review_request_removed\", \"auto_merge_enabled\", \"auto_merge_disabled\"},\n\t\"push\":                        {},\n\t\"registry_package\":            {\"published\", \"updated\"},\n\t\"release\":                     {\"published\", \"unpublished\", \"created\", \"edited\", \"deleted\", \"prereleased\", \"released\"},\n\t\"repository_dispatch\":         {},\n\t\"status\":                      {},\n\t\"watch\":                       {\"started\"},\n\t\"workflow_dispatch\":           {},\n\t\"workflow_run\":                {\"completed\", \"requested\", \"in_progress\"},\n}\n"
        },
        {
          "name": "all_webhooks_test.go",
          "type": "blob",
          "size": 0.4853515625,
          "content": "package actionlint\n\nimport \"testing\"\n\nfunc TestGeneratedAllWebhooks(t *testing.T) {\n\tif len(AllWebhookTypes) == 0 {\n\t\tt.Fatal(\"AllWebhookTypes is empty\")\n\t}\n\n\tfor name, types := range AllWebhookTypes {\n\t\tif name == \"\" {\n\t\t\tt.Errorf(\"Name is empty (types=%v)\", types)\n\t\t\tcontinue\n\t\t}\n\n\t\tseen := map[string]struct{}{}\n\t\tfor _, ty := range types {\n\t\t\tif _, ok := seen[ty]; ok {\n\t\t\t\tt.Errorf(\"type %q duplicates in webhook %q: %v\", ty, name, types)\n\t\t\t} else {\n\t\t\t\tseen[ty] = struct{}{}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ast.go",
          "type": "blob",
          "size": 35.9423828125,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\n// Pos represents position in the file.\ntype Pos struct {\n\t// Line is a line number of the position. This value is 1-based.\n\tLine int\n\t// Col is a column number of the position. This value is 1-based.\n\tCol int\n}\n\nfunc (p *Pos) String() string {\n\treturn fmt.Sprintf(\"line:%d,col:%d\", p.Line, p.Col)\n}\n\n// IsBefore returns if the position is before the other position. If they are equal, this function returns false.\nfunc (p *Pos) IsBefore(other *Pos) bool {\n\tif p.Line < other.Line {\n\t\treturn true\n\t}\n\tif p.Line > other.Line {\n\t\treturn false\n\t}\n\treturn p.Col < other.Col\n}\n\n// String represents generic string value in YAML file with position.\ntype String struct {\n\t// Value is a raw value of the string.\n\tValue string\n\t// Quoted represents the string is quoted with ' or \" in the YAML source.\n\tQuoted bool\n\t// Pos is a position of the string in source.\n\tPos *Pos\n}\n\n// ContainsExpression checks if the given string contains a ${{ }} placeholder or not. This function\n// is identical to String.ContainsExpression method except for taking a standard string value.\nfunc ContainsExpression(s string) bool {\n\ti := strings.Index(s, \"${{\")\n\treturn i >= 0 && i < strings.Index(s, \"}}\")\n}\n\n// ContainsExpression returns whether the string contains at least one ${{ }} expression.\nfunc (s *String) ContainsExpression() bool {\n\treturn ContainsExpression(s.Value)\n}\n\nfunc isExprAssigned(s string) bool {\n\tv := strings.TrimSpace(s)\n\t// Do not check `strings.Count(s.Value, \"}}\") == 1` because it might appear in JSON string\n\t//   if: ${{ env.foo == '{\"foo\": {\"bar\": true}}' }}\n\treturn strings.HasPrefix(v, \"${{\") &&\n\t\tstrings.HasSuffix(v, \"}}\") &&\n\t\tstrings.Count(v, \"${{\") == 1\n}\n\n// IsExpressionAssigned returns whether a single expression is assigned to the string.\nfunc (s *String) IsExpressionAssigned() bool {\n\treturn isExprAssigned(s.Value)\n}\n\n// Bool represents generic boolean value in YAML file with position.\ntype Bool struct {\n\t// Value is a raw value of the bool string.\n\tValue bool\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\nfunc (b *Bool) String() string {\n\tif b.Expression != nil {\n\t\treturn b.Expression.Value\n\t}\n\tif b.Value {\n\t\treturn \"true\"\n\t}\n\treturn \"false\"\n}\n\n// Int represents generic integer value in YAML file with position.\ntype Int struct {\n\t// Value is a raw value of the integer string.\n\tValue int\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Float represents generic float value in YAML file with position.\ntype Float struct {\n\t// Value is a raw value of the float string.\n\tValue float64\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Event interface represents workflow events in 'on' section\ntype Event interface {\n\t// EventName returns name of the event to trigger this workflow.\n\tEventName() string\n}\n\n// WebhookEventFilter is a filter for Webhook events such as 'branches', 'paths-ignore', ...\n// Webhook events are filtered by those filters. Some filters are exclusive.\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#using-filters\ntype WebhookEventFilter struct {\n\t// Name is a name of filter such like 'branches', 'tags'\n\tName *String\n\t// Values is a list of filter values.\n\tValues []*String\n}\n\n// IsEmpty returns true when it has no value. This may mean the WebhookEventFilter instance itself is nil.\nfunc (f *WebhookEventFilter) IsEmpty() bool {\n\treturn f == nil || len(f.Values) == 0\n}\n\n// WebhookEvent represents event type based on webhook events.\n// Some events can't have 'types' field. Only 'push' and 'pull' events can have 'tags', 'tags-ignore',\n// 'paths' and 'paths-ignore' fields. Only 'workflow_run' event can have 'workflows' field.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onevent_nametypes\ntype WebhookEvent struct {\n\t// Hook is a name of the webhook event.\n\tHook *String\n\t// Types is list of types of the webhook event. Only the types enumerated here will trigger\n\t// the workflow.\n\tTypes []*String\n\t// Branches is 'branches' filter. This value is nil when it is omitted.\n\tBranches *WebhookEventFilter\n\t// BranchesIgnore is 'branches-ignore' filter. This value is nil when it is omitted.\n\tBranchesIgnore *WebhookEventFilter\n\t// Tags is 'tags' filter. This value is nil when it is omitted.\n\tTags *WebhookEventFilter\n\t// TagsIgnore is 'tags-ignore' filter. This value is nil when it is omitted.\n\tTagsIgnore *WebhookEventFilter\n\t// Paths is 'paths' filter. This value is nil when it is omitted.\n\tPaths *WebhookEventFilter\n\t// PathsIgnore is 'paths-ignore' filter. This value is nil when it is omitted.\n\tPathsIgnore *WebhookEventFilter\n\t// Workflows is list of workflow names which are triggered by 'workflow_run' event.\n\tWorkflows []*String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// EventName returns name of the event to trigger this workflow.\nfunc (e *WebhookEvent) EventName() string {\n\treturn e.Hook.Value\n}\n\n// ScheduledEvent is event scheduled by workflow.\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#scheduled-events\ntype ScheduledEvent struct {\n\t// Cron is list of cron strings which schedules workflow.\n\tCron []*String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// EventName returns name of the event to trigger this workflow.\nfunc (e *ScheduledEvent) EventName() string {\n\treturn \"schedule\"\n}\n\n// WorkflowDispatchEventInputType is a type for input types of workflow_dispatch events.\n// https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/\ntype WorkflowDispatchEventInputType uint8\n\nconst (\n\t// WorkflowDispatchEventInputTypeNone represents no type is specified to the input of workflow_dispatch event.\n\tWorkflowDispatchEventInputTypeNone WorkflowDispatchEventInputType = iota\n\t// WorkflowDispatchEventInputTypeString is string type of input of workflow_dispatch event.\n\tWorkflowDispatchEventInputTypeString\n\t// WorkflowDispatchEventInputTypeNumber is number type of input of workflow_dispatch event.\n\tWorkflowDispatchEventInputTypeNumber\n\t// WorkflowDispatchEventInputTypeBoolean is boolean type of input of workflow_dispatch event.\n\tWorkflowDispatchEventInputTypeBoolean\n\t// WorkflowDispatchEventInputTypeChoice is choice type of input of workflow_dispatch event.\n\tWorkflowDispatchEventInputTypeChoice\n\t// WorkflowDispatchEventInputTypeEnvironment is environment type of input of workflow_dispatch event.\n\tWorkflowDispatchEventInputTypeEnvironment\n)\n\n// DispatchInput is input specified on dispatching workflow manually.\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow_dispatch\ntype DispatchInput struct {\n\t// Name is a name of input value specified on dispatching workflow manually.\n\tName *String\n\t// Description is a description of input value specified on dispatching workflow manually.\n\tDescription *String\n\t// Required is a flag to show if this input is mandatory or not on dispatching workflow manually.\n\tRequired *Bool\n\t// Default is a default value of input value on dispatching workflow manually.\n\tDefault *String\n\t// Type is a type of the input\n\t// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow_dispatch\n\tType WorkflowDispatchEventInputType\n\t// Options is list of options of choice type\n\tOptions []*String\n}\n\n// WorkflowDispatchEvent is event on dispatching workflow manually.\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow_dispatch\ntype WorkflowDispatchEvent struct {\n\t// Inputs is map from input names to input attributes. Keys are in lower case since they are case insensitive.\n\tInputs map[string]*DispatchInput\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// EventName returns name of the event to trigger this workflow.\nfunc (e *WorkflowDispatchEvent) EventName() string {\n\treturn \"workflow_dispatch\"\n}\n\n// RepositoryDispatchEvent is repository_dispatch event configuration.\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#repository_dispatch\ntype RepositoryDispatchEvent struct {\n\t// Types is list of types which can trigger workflow.\n\tTypes []*String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// EventName returns name of the event to trigger this workflow.\nfunc (e *RepositoryDispatchEvent) EventName() string {\n\treturn \"repository_dispatch\"\n}\n\n// WorkflowCallEventInputType is a type of inputs at workflow_call event.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callinput_idtype\ntype WorkflowCallEventInputType uint8\n\nconst (\n\t// WorkflowCallEventInputTypeInvalid represents invalid type input as default value of the type.\n\tWorkflowCallEventInputTypeInvalid WorkflowCallEventInputType = iota\n\t// WorkflowCallEventInputTypeBoolean represents boolean type input.\n\tWorkflowCallEventInputTypeBoolean\n\t// WorkflowCallEventInputTypeNumber represents number type input.\n\tWorkflowCallEventInputTypeNumber\n\t// WorkflowCallEventInputTypeString represents string type input.\n\tWorkflowCallEventInputTypeString\n)\n\n// WorkflowCallEventInput is an input configuration of workflow_call event.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callinputs\ntype WorkflowCallEventInput struct {\n\t// Name is a name of the input.\n\tName *String\n\t// Description is a description of the input.\n\tDescription *String\n\t// Default is a default value of the input. Nil means no default value.\n\tDefault *String\n\t// Required represents if the input is required or optional. When this value is nil, it was not explicitly specified.\n\t// In the case the default value is 'not required'.\n\tRequired *Bool\n\t// Type of the input, which must be one of 'boolean', 'number' or 'string'. This property is required.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callinput_idtype\n\tType WorkflowCallEventInputType\n\t// ID is an ID of the input. Input ID is in lower case because it is case-insensitive.\n\tID string\n}\n\n// IsRequired returns if the input is marked as required or not.\n// require\nfunc (i *WorkflowCallEventInput) IsRequired() bool {\n\treturn i.Required != nil && i.Required.Value\n}\n\n// WorkflowCallEventSecret is a secret configuration of workflow_call event.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callsecrets\ntype WorkflowCallEventSecret struct {\n\t// Name is a name of the secret.\n\tName *String\n\t// Description is a description of the secret.\n\tDescription *String\n\t// Required represents if the secret is required or optional. When this value is nil, it means optional.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callsecretssecret_idrequired\n\tRequired *Bool\n}\n\n// WorkflowCallEventOutput is an output configuration of workflow_call event.\n// https://docs.github.com/en/actions/using-workflows/reusing-workflows#using-outputs-from-a-reusable-workflow\ntype WorkflowCallEventOutput struct {\n\t// Name is a name of the output.\n\tName *String\n\t// Description is a description of the output.\n\tDescription *String\n\t// Value is an expression for the value of the output.\n\tValue *String\n}\n\n// WorkflowCallEvent is workflow_call event configuration.\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow-reuse-events\ntype WorkflowCallEvent struct {\n\t// Inputs is an array of inputs of the workflow_call event. This value is not a map unlike other fields of this\n\t// struct since its order is important when checking the default values of inputs.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callinputs\n\tInputs []*WorkflowCallEventInput\n\t// Secrets is a map from name of secret to secret configuration. When 'secrets' is omitted, nil is set to this\n\t// field. Keys are in lower case since they are case-insensitive.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callsecrets\n\tSecrets map[string]*WorkflowCallEventSecret\n\t// Outputs is a map from name of output to output configuration. Keys are in lower case since they are case-insensitive.\n\t// https://docs.github.com/en/actions/using-workflows/reusing-workflows#using-outputs-from-a-reusable-workflow\n\tOutputs map[string]*WorkflowCallEventOutput\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// EventName returns name of the event to trigger this workflow.\nfunc (e *WorkflowCallEvent) EventName() string {\n\treturn \"workflow_call\"\n}\n\n// PermissionScope is struct for respective permission scope like \"issues\", \"checks\", ...\n// https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication#permissions-for-the-github_token\ntype PermissionScope struct {\n\t// Name is name of the scope.\n\tName *String\n\t// Value is permission value of the scope.\n\tValue *String\n}\n\n// Permissions is set of permission configurations in workflow file. All permissions can be set at\n// once. Or each permission can be configured respectively.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#permissions\ntype Permissions struct {\n\t// All represents a permission value for all the scopes at once.\n\tAll *String\n\t// Scopes is mappings from scope name to its permission configuration\n\tScopes map[string]*PermissionScope\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// DefaultsRun is configuration that shell is how to be run.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#defaultsrun\ntype DefaultsRun struct {\n\t// Shell is shell name to be run.\n\tShell *String\n\t// WorkingDirectory is a default working directory path.\n\tWorkingDirectory *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Defaults is set of default configurations to run shell.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#defaults\ntype Defaults struct {\n\t// Run is configuration of how to run shell.\n\tRun *DefaultsRun\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Concurrency is a configuration of concurrency of the workflow.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#concurrency\ntype Concurrency struct {\n\t// Group is name of the concurrency group.\n\tGroup *String\n\t// CancelInProgress is a flag that shows if canceling this workflow cancels other jobs in progress.\n\tCancelInProgress *Bool\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Environment is a configuration of environment.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idenvironment\ntype Environment struct {\n\t// Name is a name of environment which the workflow uses.\n\tName *String\n\t// URL is the URL mapped to 'environment_url' in the deployments API. Empty value means no value was specified.\n\tURL *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// ExecKind is kind of how the step is executed. A step runs some action or runs some shell script.\ntype ExecKind uint8\n\nconst (\n\t// ExecKindAction is kind for step to run action\n\tExecKindAction ExecKind = iota\n\t// ExecKindRun is kind for step to run shell script\n\tExecKindRun\n)\n\n// Exec is an interface how the step is executed. Step in workflow runs either an action or a script\ntype Exec interface {\n\t// Kind returns kind of the step execution.\n\tKind() ExecKind\n}\n\n// ExecRun is configuration how to run shell script at the step.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsrun\ntype ExecRun struct {\n\t// Run is script to run.\n\tRun *String\n\t// Shell represents optional 'shell' field. Nil means nothing specified.\n\tShell *String\n\t// WorkingDirectory represents optional 'working-directory' field. Nil means nothing specified.\n\tWorkingDirectory *String\n\t// RunPos is position of 'run' section\n\tRunPos *Pos\n}\n\n// Kind returns kind of the step execution.\nfunc (e *ExecRun) Kind() ExecKind {\n\treturn ExecKindRun\n}\n\n// Input is an input field for running an action.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswith\ntype Input struct {\n\t// Name is a name of the input.\n\tName *String\n\t// Value is a value of the input.\n\tValue *String\n}\n\n// ExecAction is configuration how to run action at the step.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsuses\ntype ExecAction struct {\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsuses\n\tUses *String\n\t// Inputs represents inputs to the action to execute in 'with' section. Keys are in lower case since they are case-insensitive.\n\tInputs map[string]*Input\n\t// Entrypoint represents optional 'entrypoint' field in 'with' section. Nil field means nothing specified\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithentrypoint\n\tEntrypoint *String\n\t// Args represents optional 'args' field in 'with' section. Nil field means nothing specified\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithargs\n\tArgs *String\n}\n\n// Kind returns kind of the step execution.\nfunc (e *ExecAction) Kind() ExecKind {\n\treturn ExecKindAction\n}\n\n// RawYAMLValueKind is kind of raw YAML values\ntype RawYAMLValueKind int\n\nconst (\n\t// RawYAMLValueKindObject is kind for an object value of raw YAML value.\n\tRawYAMLValueKindObject = RawYAMLValueKind(yaml.MappingNode)\n\t// RawYAMLValueKindArray is kind for an array value of raw YAML value.\n\tRawYAMLValueKindArray = RawYAMLValueKind(yaml.SequenceNode)\n\t// RawYAMLValueKindString is kind for a string value of raw YAML value.\n\tRawYAMLValueKindString = RawYAMLValueKind(yaml.ScalarNode)\n)\n\n// RawYAMLValue is a value at matrix variation. Any value can be put at matrix variations\n// including mappings and arrays.\ntype RawYAMLValue interface {\n\t// Kind returns kind of raw YAML value.\n\tKind() RawYAMLValueKind\n\t// Equals returns if the other value is equal to the value.\n\tEquals(other RawYAMLValue) bool\n\t// Pos returns the start position of the value in the source file\n\tPos() *Pos\n\t// String returns string representation of the value\n\tString() string\n}\n\n// RawYAMLObject is raw YAML mapping value.\ntype RawYAMLObject struct {\n\t// Props is map from property names to their values. Keys are in lower case since they are case-insensitive.\n\tProps map[string]RawYAMLValue\n\tpos   *Pos\n}\n\n// Kind returns kind of raw YAML value.\nfunc (o *RawYAMLObject) Kind() RawYAMLValueKind {\n\treturn RawYAMLValueKindObject\n}\n\n// Equals returns if the other value is equal to the value.\nfunc (o *RawYAMLObject) Equals(other RawYAMLValue) bool {\n\tswitch other := other.(type) {\n\tcase *RawYAMLObject:\n\t\tfor n, p1 := range o.Props {\n\t\t\tif p2, ok := other.Props[n]; !ok || !p1.Equals(p2) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Pos returns the start position of the value in the source file\nfunc (o *RawYAMLObject) Pos() *Pos {\n\treturn o.pos\n}\n\nfunc (o *RawYAMLObject) String() string {\n\tqs := make([]string, 0, len(o.Props))\n\tfor n, p := range o.Props {\n\t\tqs = append(qs, fmt.Sprintf(\"%q: %s\", n, p.String()))\n\t}\n\tsort.Strings(qs)\n\treturn \"{\" + strings.Join(qs, \", \") + \"}\"\n}\n\n// RawYAMLArray is raw YAML sequence value.\ntype RawYAMLArray struct {\n\t// Elems is list of elements of the array value.\n\tElems []RawYAMLValue\n\tpos   *Pos\n}\n\n// Kind returns kind of raw YAML value.\nfunc (a *RawYAMLArray) Kind() RawYAMLValueKind {\n\treturn RawYAMLValueKindArray\n}\n\n// Equals returns if the other value is equal to the value.\nfunc (a *RawYAMLArray) Equals(other RawYAMLValue) bool {\n\tswitch other := other.(type) {\n\tcase *RawYAMLArray:\n\t\tif len(a.Elems) != len(other.Elems) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, e1 := range a.Elems {\n\t\t\tif !e1.Equals(other.Elems[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Pos returns the start position of the value in the source file\nfunc (a *RawYAMLArray) Pos() *Pos {\n\treturn a.pos\n}\n\nfunc (a *RawYAMLArray) String() string {\n\tvar b strings.Builder\n\tb.WriteRune('[')\n\n\tcomma := false\n\tfor _, e := range a.Elems {\n\t\tif comma {\n\t\t\tb.WriteString(\", \")\n\t\t} else {\n\t\t\tcomma = true\n\t\t}\n\t\tb.WriteString(e.String())\n\t}\n\n\tb.WriteRune(']')\n\treturn b.String()\n}\n\n// RawYAMLString is raw YAML scalar value.\ntype RawYAMLString struct {\n\t// Note: Might be useful to add kind to check the string value is int/float/bool/null.\n\n\t// Value is string representation of the scalar node.\n\tValue string\n\tpos   *Pos\n}\n\n// Kind returns kind of raw YAML value.\nfunc (s *RawYAMLString) Kind() RawYAMLValueKind {\n\treturn RawYAMLValueKindString\n}\n\n// Equals returns if the other value is equal to the value.\nfunc (s *RawYAMLString) Equals(other RawYAMLValue) bool {\n\tswitch other := other.(type) {\n\tcase *RawYAMLString:\n\t\treturn s.Value == other.Value\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Pos returns the start position of the value in the source file\nfunc (s *RawYAMLString) Pos() *Pos {\n\treturn s.pos\n}\n\nfunc (s *RawYAMLString) String() string {\n\treturn strconv.Quote(s.Value)\n}\n\n// MatrixRow is one row of matrix. One matrix row can take multiple values. Those variations are\n// stored as row of values in this struct.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix\ntype MatrixRow struct {\n\t// Name is a name of matrix value.\n\tName *String\n\t// Values is variations of values which the matrix value can take.\n\tValues []RawYAMLValue\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n}\n\n// MatrixAssign represents which value should be taken in the row of the matrix.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix\ntype MatrixAssign struct {\n\t// Key is a name of the matrix value.\n\tKey *String\n\t// Value is the value selected from values in row.\n\tValue RawYAMLValue\n}\n\n// MatrixCombination is combination of matrix value assignments to define one of matrix variations.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix\ntype MatrixCombination struct {\n\tAssigns map[string]*MatrixAssign\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n}\n\n// MatrixCombinations is list of combinations of matrix assignments used for 'include' and 'exclude'\n// sections.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix\ntype MatrixCombinations struct {\n\tCombinations []*MatrixCombination\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n}\n\n// ContainsExpression returns if the combinations section includes at least one expression node.\nfunc (cs *MatrixCombinations) ContainsExpression() bool {\n\tif cs.Expression != nil {\n\t\treturn true\n\t}\n\tfor _, c := range cs.Combinations {\n\t\tif c.Expression != nil {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Matrix is matrix variations configuration of a job.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix\ntype Matrix struct {\n\t// Values stores mappings from name to values. Keys are in lower case since they are case-insensitive.\n\tRows map[string]*MatrixRow\n\t// Include is list of combinations of matrix values and additional values on running matrix combinations.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#example-including-additional-values-into-combinations\n\tInclude *MatrixCombinations\n\t// Exclude is list of combinations of matrix values which should not be run. Combinations in\n\t// this list will be removed from combinations of matrix to run.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#example-excluding-configurations-from-a-matrix\n\tExclude *MatrixCombinations\n\t// Expression is a string when expression syntax ${{ }} is used for this section.\n\tExpression *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Strategy is strategy configuration of how the job is run.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategy\ntype Strategy struct {\n\t// Matrix is matrix of combinations of values. Each combination will run the job once.\n\tMatrix *Matrix\n\t// FailFast is flag to show if other jobs should stop when one job fails.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategyfail-fast\n\tFailFast *Bool\n\t// MaxParallel is how many jobs should be run at once.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel\n\tMaxParallel *Int\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// EnvVar represents key-value of environment variable setup.\ntype EnvVar struct {\n\t// Name is name of the environment variable.\n\tName *String\n\t// Value is string value of the environment variable.\n\tValue *String\n}\n\n// Env represents set of environment variables.\ntype Env struct {\n\t// Vars is mapping from env var name to env var value.\n\tVars map[string]*EnvVar\n\t// Expression is an expression string which contains ${{ ... }}. When this value is not empty,\n\t// Vars should be nil.\n\tExpression *String\n}\n\n// Step is step configuration. Step runs one action or one shell script.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idsteps\ntype Step struct {\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsid\n\tID *String\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsif\n\tIf *String\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsname\n\tName *String\n\tExec Exec\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsenv\n\tEnv *Env\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepscontinue-on-error\n\tContinueOnError *Bool\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepstimeout-minutes\n\tTimeoutMinutes *Float\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Credentials is credentials configuration.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainercredentials\ntype Credentials struct {\n\t// Username is username for authentication.\n\tUsername *String\n\t// Password is password for authentication.\n\tPassword *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Container is configuration of how to run the container.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainer\ntype Container struct {\n\t// Image is specification of Docker image.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainerimage\n\tImage *String\n\t// Credentials is credentials configuration of the Docker container.\n\tCredentials *Credentials\n\t// Env is environment variables setup in the container.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainerenv\n\tEnv *Env\n\t// Ports is list of port number mappings of the container.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainerports\n\tPorts []*String\n\t// Volumes are list of volumes to be mounted to the container.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainervolumes\n\tVolumes []*String\n\t// Options is options string to run the container.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontaineroptions\n\tOptions *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Service is configuration to run a service like database.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idservices\ntype Service struct {\n\t// Name is name of the service.\n\tName *String\n\t// Container is configuration of container which runs the service.\n\tContainer *Container\n}\n\n// Services is a mapping from service ID to its configuration.\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idservices\ntype Services struct {\n\t// Value is a mapping from service ID to its Service instances. Keys are in lower case since\n\t// they are case-insensitive.\n\tValue map[string]*Service\n\t// Expression is an expression assigned to the services mapping by ${{ }} placeholder. Otherwise\n\t// this field is nil.\n\tExpression *String\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Output is output entry of the job.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idoutputs\ntype Output struct {\n\t// Name is name of output.\n\tName *String\n\t// Value is value of output.\n\tValue *String\n}\n\n// Runner is struct for runner configuration.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idruns-on\ntype Runner struct {\n\t// Labels is list label names to select a runner to run a job. There are preset labels and user\n\t// defined labels. Runner matching to the labels is selected.\n\tLabels []*String\n\t// LabelsExpr is a string when expression syntax ${{ }} is used for this section. Related issue is #164.\n\tLabelsExpr *String\n\t// Group is a group of runners specified in runs-on: section. It is nil when no group is specified.\n\t// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#choosing-runners-in-a-group\n\tGroup *String\n}\n\n// WorkflowCallInput is a normal input for workflow call.\ntype WorkflowCallInput struct {\n\t// Name is a name of the input.\n\tName *String\n\t// Value is a value of the input.\n\tValue *String\n}\n\n// WorkflowCallSecret is a secret input for workflow call.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idwith\ntype WorkflowCallSecret struct {\n\t// Name is a name of the secret\n\tName *String\n\t// Value is a value of the secret\n\tValue *String\n}\n\n// WorkflowCall is a struct to represent workflow call at jobs.<job_id>.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_iduses\ntype WorkflowCall struct {\n\t// Uses is a workflow specification to be called. This field is mandatory.\n\tUses *String\n\t// Inputs is a map from input name to input value at 'with:'. Keys are in lower case since input names\n\t// are case-insensitive.\n\tInputs map[string]*WorkflowCallInput\n\t// Secrets is a map from secret name to secret value at 'secrets:'. Keys are in lower case since input\n\t// names are case-insensitive.\n\tSecrets map[string]*WorkflowCallSecret\n\t// InheritSecrets is true when 'secrets: inherit' is specified. In this case, Secrets must be empty.\n\t// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_callsecretsinherit\n\tInheritSecrets bool\n}\n\n// Job is configuration of how to run a job.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobs\ntype Job struct {\n\t// ID is an ID of the job, which is key of job configuration objects.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_id\n\tID *String\n\t// Name is a name of job that user can specify freely.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idname\n\tName *String\n\t// Needs is list of job IDs which should be run before running this job.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idneeds\n\tNeeds []*String\n\t// RunsOn is runner configuration which run the job.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idruns-on\n\tRunsOn *Runner\n\t// Permissions is permission configuration for running the job.\n\tPermissions *Permissions\n\t// Environment is environment specification where the job runs.\n\tEnvironment *Environment\n\t// Concurrency is concurrency configuration on running the job.\n\tConcurrency *Concurrency\n\t// Outputs is map from output name to output specifications.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idoutputs\n\tOutputs map[string]*Output\n\t// Env is environment variables setup while running the job.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idenv\n\tEnv *Env\n\t// Defaults is default configurations of how to run scripts.\n\tDefaults *Defaults\n\t// If is a condition whether this job should be run.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idif\n\tIf *String\n\t// Steps is list of steps to be run in the job.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idsteps\n\tSteps []*Step\n\t// TimeoutMinutes is timeout value of running the job in minutes.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idtimeout-minutes\n\tTimeoutMinutes *Float\n\t// Strategy is strategy configuration of running the job.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategy\n\tStrategy *Strategy\n\t// ContinueOnError is a flag to show if execution should continue on error.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontinue-on-error\n\tContinueOnError *Bool\n\t// Container is container configuration to run the job.\n\tContainer *Container\n\t// Services is a services configurations.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idservices\n\tServices *Services\n\t// WorkflowCall is a workflow call by 'uses:'.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_iduses\n\tWorkflowCall *WorkflowCall\n\t// Pos is a position in source.\n\tPos *Pos\n}\n\n// Workflow is root of workflow syntax tree, which represents one workflow configuration file.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions\ntype Workflow struct {\n\t// Name is name of the workflow. This field can be nil when user didn't specify the name explicitly.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#name\n\tName *String\n\t// RunName is the name of workflow runs. This field can be set dynamically using ${{ }}.\n\t// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#run-name\n\tRunName *String\n\t// On is list of events which can trigger this workflow.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onpushpull_requestbranchestags\n\tOn []Event\n\t// Permissions is configuration of permissions of this workflow.\n\tPermissions *Permissions\n\t// Env is a default set of environment variables while running this workflow.\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#env\n\tEnv *Env\n\t// Defaults is default configuration of how to run scripts.\n\tDefaults *Defaults\n\t// Concurrency is concurrency configuration of entire workflow. Each jobs also can their own\n\t// concurrency configurations.\n\tConcurrency *Concurrency\n\t// Jobs is mappings from job ID to the job object. Keys are in lower case since they are case-insensitive.\n\tJobs map[string]*Job\n}\n\n// FindWorkflowCallEvent returns workflow_call event node if exists\nfunc (w *Workflow) FindWorkflowCallEvent() (*WorkflowCallEvent, bool) {\n\tfor _, e := range w.On {\n\t\tif e, ok := e.(*WorkflowCallEvent); ok {\n\t\t\treturn e, true\n\t\t}\n\t}\n\treturn nil, false\n}\n"
        },
        {
          "name": "ast_test.go",
          "type": "blob",
          "size": 1.345703125,
          "content": "package actionlint\n\nimport \"testing\"\n\nfunc TestStringIsExpressionAssigned(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  bool\n\t}{\n\t\t{\"${{...}}\", true},\n\t\t{\" ${{...}} \", true},\n\t\t{`${{ foo == '{\"a\": {\"b\": \"c\"}}' }}`, true}, // edge case\n\t\t{\"\", false},\n\t\t{\"${}\", false},\n\t\t{\"{{}}\", false},\n\t\t{\"${{\", false},\n\t\t{\"}}\", false},\n\t\t{\"${{ ${{ }}\", false},\n\t\t{\"abc ${{...}}\", false},\n\t\t{\"${{...}} abc\", false},\n\t\t{\"${{...}}${{...}}\", false},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\ts := &String{Value: tc.input}\n\t\t\thave := s.IsExpressionAssigned()\n\t\t\tif tc.want != have {\n\t\t\t\tt.Fatalf(\"wanted %v but got %v for input %q\", tc.want, have, tc.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestStringContainsExpression(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  bool\n\t}{\n\t\t{\"${{...}}\", true},\n\t\t{\"foo-${{...}}-bar\", true},\n\t\t{\"${{...}}-${{...}}\", true},\n\t\t{\"${{...\", false},\n\t\t{\"...}}\", false},\n\t\t{\"${{...} }\", false},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\ts := &String{Value: tc.input}\n\t\t\tif have := s.ContainsExpression(); tc.want != have {\n\t\t\t\tt.Fatalf(\"wanted %v but the method returned %v for input %q\", tc.want, have, tc.input)\n\t\t\t}\n\t\t\tif have := ContainsExpression(tc.input); tc.want != have {\n\t\t\t\tt.Fatalf(\"wanted %v but the function returned %v for input %q\", tc.want, have, tc.input)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "availability.go",
          "type": "blob",
          "size": 5.5498046875,
          "content": "// Code generated by actionlint/scripts/generate-availability. DO NOT EDIT.\n\npackage actionlint\n\n// WorkflowKeyAvailability returns contexts and special functions availability of the given workflow key.\n// 1st return value indicates what contexts are available. Empty slice means any contexts are available.\n// 2nd return value indicates what special functions are available. Empty slice means no special functions are available.\n// The 'key' parameter should represents a workflow key like \"jobs.<job_id>.concurrency\".\n//\n// This function was generated from https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability.\n// See the script for more details: https://github.com/rhysd/actionlint/blob/main/scripts/generate-availability/\nfunc WorkflowKeyAvailability(key string) ([]string, []string) {\n\tswitch key {\n\tcase \"jobs.<job_id>.outputs.<output_id>\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"job\", \"matrix\", \"needs\", \"runner\", \"secrets\", \"steps\", \"strategy\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.steps.continue-on-error\", \"jobs.<job_id>.steps.env\", \"jobs.<job_id>.steps.name\", \"jobs.<job_id>.steps.run\", \"jobs.<job_id>.steps.timeout-minutes\", \"jobs.<job_id>.steps.with\", \"jobs.<job_id>.steps.working-directory\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"job\", \"matrix\", \"needs\", \"runner\", \"secrets\", \"steps\", \"strategy\", \"vars\"}, []string{\"hashfiles\"}\n\tcase \"jobs.<job_id>.container.env.<env_id>\", \"jobs.<job_id>.services.<service_id>.env.<env_id>\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"job\", \"matrix\", \"needs\", \"runner\", \"secrets\", \"strategy\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.environment.url\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"job\", \"matrix\", \"needs\", \"runner\", \"steps\", \"strategy\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.steps.if\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"job\", \"matrix\", \"needs\", \"runner\", \"steps\", \"strategy\", \"vars\"}, []string{\"always\", \"cancelled\", \"failure\", \"hashfiles\", \"success\"}\n\tcase \"jobs.<job_id>.container.credentials\", \"jobs.<job_id>.services.<service_id>.credentials\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"matrix\", \"needs\", \"secrets\", \"strategy\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.defaults.run\":\n\t\treturn []string{\"env\", \"github\", \"inputs\", \"matrix\", \"needs\", \"strategy\", \"vars\"}, []string{}\n\tcase \"on.workflow_call.outputs.<output_id>.value\":\n\t\treturn []string{\"github\", \"inputs\", \"jobs\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.env\", \"jobs.<job_id>.secrets.<secrets_id>\":\n\t\treturn []string{\"github\", \"inputs\", \"matrix\", \"needs\", \"secrets\", \"strategy\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.concurrency\", \"jobs.<job_id>.container\", \"jobs.<job_id>.container.image\", \"jobs.<job_id>.continue-on-error\", \"jobs.<job_id>.environment\", \"jobs.<job_id>.name\", \"jobs.<job_id>.runs-on\", \"jobs.<job_id>.services\", \"jobs.<job_id>.timeout-minutes\", \"jobs.<job_id>.with.<with_id>\":\n\t\treturn []string{\"github\", \"inputs\", \"matrix\", \"needs\", \"strategy\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.strategy\":\n\t\treturn []string{\"github\", \"inputs\", \"needs\", \"vars\"}, []string{}\n\tcase \"jobs.<job_id>.if\":\n\t\treturn []string{\"github\", \"inputs\", \"needs\", \"vars\"}, []string{\"always\", \"cancelled\", \"failure\", \"success\"}\n\tcase \"env\":\n\t\treturn []string{\"github\", \"inputs\", \"secrets\", \"vars\"}, []string{}\n\tcase \"concurrency\", \"on.workflow_call.inputs.<inputs_id>.default\", \"run-name\":\n\t\treturn []string{\"github\", \"inputs\", \"vars\"}, []string{}\n\tdefault:\n\t\treturn nil, nil\n\t}\n}\n\n// SpecialFunctionNames is a map from special function name to available workflow keys.\n// Some functions are only available at specific positions. This variable is useful when you want to\n// know which functions are special and what workflow keys support them.\n//\n// This function was generated from https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability.\n// See the script for more details: https://github.com/rhysd/actionlint/blob/main/scripts/generate-availability/\nvar SpecialFunctionNames = map[string][]string{\"always\": []string{\"jobs.<job_id>.if\", \"jobs.<job_id>.steps.if\"}, \"cancelled\": []string{\"jobs.<job_id>.if\", \"jobs.<job_id>.steps.if\"}, \"failure\": []string{\"jobs.<job_id>.if\", \"jobs.<job_id>.steps.if\"}, \"hashfiles\": []string{\"jobs.<job_id>.steps.continue-on-error\", \"jobs.<job_id>.steps.env\", \"jobs.<job_id>.steps.if\", \"jobs.<job_id>.steps.name\", \"jobs.<job_id>.steps.run\", \"jobs.<job_id>.steps.timeout-minutes\", \"jobs.<job_id>.steps.with\", \"jobs.<job_id>.steps.working-directory\"}, \"success\": []string{\"jobs.<job_id>.if\", \"jobs.<job_id>.steps.if\"}}\n\n// For test\nvar allWorkflowKeys = []string{\"concurrency\", \"env\", \"jobs.<job_id>.concurrency\", \"jobs.<job_id>.container\", \"jobs.<job_id>.container.credentials\", \"jobs.<job_id>.container.env.<env_id>\", \"jobs.<job_id>.container.image\", \"jobs.<job_id>.continue-on-error\", \"jobs.<job_id>.defaults.run\", \"jobs.<job_id>.env\", \"jobs.<job_id>.environment\", \"jobs.<job_id>.environment.url\", \"jobs.<job_id>.if\", \"jobs.<job_id>.name\", \"jobs.<job_id>.outputs.<output_id>\", \"jobs.<job_id>.runs-on\", \"jobs.<job_id>.secrets.<secrets_id>\", \"jobs.<job_id>.services\", \"jobs.<job_id>.services.<service_id>.credentials\", \"jobs.<job_id>.services.<service_id>.env.<env_id>\", \"jobs.<job_id>.steps.continue-on-error\", \"jobs.<job_id>.steps.env\", \"jobs.<job_id>.steps.if\", \"jobs.<job_id>.steps.name\", \"jobs.<job_id>.steps.run\", \"jobs.<job_id>.steps.timeout-minutes\", \"jobs.<job_id>.steps.with\", \"jobs.<job_id>.steps.working-directory\", \"jobs.<job_id>.strategy\", \"jobs.<job_id>.timeout-minutes\", \"jobs.<job_id>.with.<with_id>\", \"on.workflow_call.inputs.<inputs_id>.default\", \"on.workflow_call.outputs.<output_id>.value\", \"run-name\"}\n"
        },
        {
          "name": "availability_test.go",
          "type": "blob",
          "size": 1.6904296875,
          "content": "package actionlint\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n)\n\nfunc TestWorkflowKeyAvailability(t *testing.T) {\n\tfor _, key := range allWorkflowKeys {\n\t\tt.Run(key, func(t *testing.T) {\n\t\t\tctx, sp := WorkflowKeyAvailability(key)\n\t\t\tif ctx == nil || sp == nil {\n\t\t\t\tt.Error(\"workflow key has not availability info:\", key)\n\t\t\t}\n\t\t\tif len(ctx) == 0 {\n\t\t\t\tt.Error(\"no context is available for key\", key)\n\t\t\t}\n\n\t\t\tr := regexp.MustCompile(`^[a-z][a-z0-9_]*$`)\n\t\t\tfor _, c := range ctx {\n\t\t\t\tif !r.MatchString(c) {\n\t\t\t\t\tt.Errorf(\"context %q does not match to pattern %s\", c, r)\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, s := range sp {\n\t\t\t\tif !r.MatchString(s) {\n\t\t\t\t\tt.Errorf(\"context %q does not match to pattern %s\", s, r)\n\t\t\t\t}\n\t\t\t\tks, ok := SpecialFunctionNames[s]\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"special function %q is not registered in SpecialFunctionNames: %v\", s, SpecialFunctionNames)\n\t\t\t\t}\n\t\t\t\tok = false\n\t\t\t\tfor _, k := range ks {\n\t\t\t\t\tif k == key {\n\t\t\t\t\t\tok = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !ok {\n\t\t\t\t\tt.Errorf(\"Key %q is not in candidates of special function %q: %v\", key, s, ks)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tctx, sp := WorkflowKeyAvailability(\"unknown.workflow.key\")\n\tif len(ctx) != 0 {\n\t\tt.Error(\"some context was returned\", ctx)\n\t}\n\tif len(sp) != 0 {\n\t\tt.Error(\"some special function name was returned\", sp)\n\t}\n}\n\nfunc TestSpecialFunctionNames(t *testing.T) {\n\tif len(SpecialFunctionNames) == 0 {\n\t\tt.Error(\"No special function is registered in SpecialFunctionNames\")\n\t}\n\n\tr := regexp.MustCompile(`^[a-z][a-z0-9_]*$`)\n\tfor f, ws := range SpecialFunctionNames {\n\t\tif len(ws) == 0 {\n\t\t\tt.Errorf(\"No workflow key is available for special function %q\", f)\n\t\t}\n\t\tif !r.MatchString(f) {\n\t\t\tt.Errorf(\"Special function name does not match to pattern %s\", r)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "command.go",
          "type": "blob",
          "size": 5.9755859375,
          "content": "package actionlint\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"runtime/debug\"\n)\n\n// These variables might be modified by ldflags on building release binaries by GoReleaser. Do not modify manually\nvar (\n\tversion       = \"\"\n\tinstalledFrom = \"installed by building from source\"\n)\n\nconst (\n\t// ExitStatusSuccessNoProblem is the exit status when the command ran successfully with no problem found.\n\tExitStatusSuccessNoProblem = 0\n\t// ExitStatusSuccessProblemFound is the exit status when the command ran successfully with some problem found.\n\tExitStatusSuccessProblemFound = 1\n\t// ExitStatusInvalidCommandOption is the exit status when parsing command line options failed.\n\tExitStatusInvalidCommandOption = 2\n\t// ExitStatusFailure is the exit status when the command stopped due to some fatal error while checking workflows.\n\tExitStatusFailure = 3\n)\n\nfunc printUsageHeader(out io.Writer) {\n\tv := getCommandVersion()\n\tb := \"main\"\n\tif regexp.MustCompile(`^\\d+\\.\\d+\\.\\d+$`).MatchString(v) {\n\t\tb = \"v\" + v\n\t}\n\n\tfmt.Fprintf(out, `Usage: actionlint [FLAGS] [FILES...] [-]\n\n  actionlint is a linter for GitHub Actions workflow files.\n\n  To check all YAML files in current repository, just run actionlint without\n  arguments. It automatically finds the nearest '.github/workflows' directory:\n\n    $ actionlint\n\n  To check specific files, pass the file paths as arguments:\n\n    $ actionlint file1.yaml file2.yaml\n\n  To check content which is not saved in file yet (e.g. output from some\n  command), pass - argument. It reads stdin and checks it as workflow file:\n\n    $ actionlint -\n\n  To serialize errors into JSON, use -format option. It allows to format error\n  messages flexibly with Go template syntax.\n\n    $ actionlint -format '{{json .}}'\n\nDocuments:\n\n  - List of checks: https://github.com/rhysd/actionlint/tree/%s/docs/checks.md\n  - Usage:          https://github.com/rhysd/actionlint/tree/%s/docs/usage.md\n  - Configuration:  https://github.com/rhysd/actionlint/tree/%s/docs/config.md\n\nFlags:\n`, b, b, b)\n}\n\nfunc getCommandVersion() string {\n\tif version != \"\" {\n\t\treturn version\n\t}\n\n\tinfo, ok := debug.ReadBuildInfo()\n\tif !ok {\n\t\treturn \"unknown\" // Reaches only when actionlint package is built outside module\n\t}\n\n\treturn info.Main.Version\n}\n\n// Command represents entire actionlint command. Given stdin/stdout/stderr are used for input/output.\ntype Command struct {\n\t// Stdin is a reader to read input from stdin\n\tStdin io.Reader\n\t// Stdout is a writer to write output to stdout\n\tStdout io.Writer\n\t// Stderr is a writer to write output to stderr\n\tStderr io.Writer\n}\n\nfunc (cmd *Command) runLinter(args []string, opts *LinterOptions, initConfig bool) ([]*Error, error) {\n\tl, err := NewLinter(cmd.Stdout, opts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif initConfig {\n\t\treturn nil, l.GenerateDefaultConfig(\"\")\n\t}\n\n\tif len(args) == 0 {\n\t\treturn l.LintRepository(\"\")\n\t}\n\n\tif len(args) == 1 && args[0] == \"-\" {\n\t\treturn l.LintStdin(cmd.Stdin)\n\t}\n\n\treturn l.LintFiles(args, nil)\n}\n\ntype ignorePatternFlags []string\n\nfunc (i *ignorePatternFlags) String() string {\n\treturn \"option for ignore patterns\"\n}\nfunc (i *ignorePatternFlags) Set(v string) error {\n\t*i = append(*i, v)\n\treturn nil\n}\n\n// Main is main function of actionlint. It takes command line arguments as string slice and returns\n// exit status. The args should be entire arguments including the program name, usually given via\n// os.Args.\nfunc (cmd *Command) Main(args []string) int {\n\tvar ver bool\n\tvar opts LinterOptions\n\tvar ignorePats ignorePatternFlags\n\tvar initConfig bool\n\tvar noColor bool\n\tvar color bool\n\n\tflags := flag.NewFlagSet(args[0], flag.ContinueOnError)\n\tflags.SetOutput(cmd.Stderr)\n\tflags.Var(&ignorePats, \"ignore\", \"Regular expression matching to error messages you want to ignore. This flag is repeatable\")\n\tflags.StringVar(&opts.Shellcheck, \"shellcheck\", \"shellcheck\", \"Command name or file path of \\\"shellcheck\\\" external command. If empty, shellcheck integration will be disabled\")\n\tflags.StringVar(&opts.Pyflakes, \"pyflakes\", \"pyflakes\", \"Command name or file path of \\\"pyflakes\\\" external command. If empty, pyflakes integration will be disabled\")\n\tflags.BoolVar(&opts.Oneline, \"oneline\", false, \"Use one line per one error. Useful for reading error messages from programs\")\n\tflags.StringVar(&opts.Format, \"format\", \"\", \"Custom template to format error messages in Go template syntax. See the usage documentation for more details\")\n\tflags.StringVar(&opts.ConfigFile, \"config-file\", \"\", \"File path to config file\")\n\tflags.BoolVar(&initConfig, \"init-config\", false, \"Generate default config file at .github/actionlint.yaml in current project\")\n\tflags.BoolVar(&noColor, \"no-color\", false, \"Disable colorful output\")\n\tflags.BoolVar(&color, \"color\", false, \"Always enable colorful output. This is useful to force colorful outputs\")\n\tflags.BoolVar(&opts.Verbose, \"verbose\", false, \"Enable verbose output\")\n\tflags.BoolVar(&opts.Debug, \"debug\", false, \"Enable debug output (for development)\")\n\tflags.BoolVar(&ver, \"version\", false, \"Show version and how this binary was installed\")\n\tflags.StringVar(&opts.StdinFileName, \"stdin-filename\", \"<stdin>\", \"File name when reading input from stdin\")\n\tflags.Usage = func() {\n\t\tprintUsageHeader(cmd.Stderr)\n\t\tflags.PrintDefaults()\n\t}\n\tif err := flags.Parse(args[1:]); err != nil {\n\t\tif err == flag.ErrHelp {\n\t\t\t// When -h or -help\n\t\t\treturn ExitStatusSuccessNoProblem\n\t\t}\n\t\treturn ExitStatusInvalidCommandOption\n\t}\n\n\tif ver {\n\t\tfmt.Fprintf(\n\t\t\tcmd.Stdout,\n\t\t\t\"%s\\n%s\\nbuilt with %s compiler for %s/%s\\n\",\n\t\t\tgetCommandVersion(),\n\t\t\tinstalledFrom,\n\t\t\truntime.Version(),\n\t\t\truntime.GOOS,\n\t\t\truntime.GOARCH,\n\t\t)\n\t\treturn ExitStatusSuccessNoProblem\n\t}\n\n\topts.IgnorePatterns = ignorePats\n\topts.LogWriter = cmd.Stderr\n\n\tif color {\n\t\topts.Color = ColorOptionKindAlways\n\t}\n\tif noColor {\n\t\topts.Color = ColorOptionKindNever\n\t}\n\n\terrs, err := cmd.runLinter(flags.Args(), &opts, initConfig)\n\tif err != nil {\n\t\tfmt.Fprintln(cmd.Stderr, err.Error())\n\t\treturn ExitStatusFailure\n\t}\n\tif len(errs) > 0 {\n\t\treturn ExitStatusSuccessProblemFound // Linter found some issues, yay!\n\t}\n\n\treturn ExitStatusSuccessNoProblem\n}\n"
        },
        {
          "name": "command_test.go",
          "type": "blob",
          "size": 0.9990234375,
          "content": "package actionlint\n\nimport (\n\t\"bytes\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestCommandMain(t *testing.T) {\n\tvar output bytes.Buffer\n\n\t// Create command instance populating stdin/stdout/stderr\n\tcmd := Command{\n\t\tStdin:  os.Stdin,\n\t\tStdout: &output,\n\t\tStderr: &output,\n\t}\n\n\t// Run the command end-to-end. Note that given args should contain program name\n\tworkflow := filepath.Join(\"testdata\", \"examples\", \"main.yaml\")\n\tstatus := cmd.Main([]string{\"actionlint\", \"-shellcheck=\", \"-pyflakes=\", \"-ignore\", `label .+ is unknown\\.`, workflow})\n\n\tif status != 1 {\n\t\tt.Fatal(\"exit status should be 1 but got\", status)\n\t}\n\n\tout := output.String()\n\n\tfor _, s := range []string{\n\t\t\"main.yaml:3:5:\",\n\t\t\"unexpected key \\\"branch\\\" for \\\"push\\\" section\",\n\t\t\"^~~~~~~~~~~~~~~\",\n\t} {\n\t\tif !strings.Contains(out, s) {\n\t\t\tt.Errorf(\"output should contain %q: %q\", s, out)\n\t\t}\n\t}\n\n\tif strings.Contains(out, \"[runner-label]\") {\n\t\tt.Errorf(\"runner-label rule should be ignored by -ignore but it is included in output: %q\", out)\n\t}\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 5.2587890625,
          "content": "package actionlint\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/bmatcuk/doublestar/v4\"\n\t\"gopkg.in/yaml.v3\"\n)\n\n// IgnorePatterns is a list of regular expressions. These patterns are used for filtering errors by\n// matching the error messages.\ntype IgnorePatterns []*regexp.Regexp\n\n// Match returns whether the given error should be ignored due to the \"ignore\" configuration.\nfunc (pats IgnorePatterns) Match(err *Error) bool {\n\tfor _, r := range pats {\n\t\tif r.MatchString(err.Message) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (pats *IgnorePatterns) UnmarshalYAML(n *yaml.Node) error {\n\tif n.Kind != yaml.SequenceNode {\n\t\treturn fmt.Errorf(\"yaml: \\\"ignore\\\" must be a sequence node at line:%d,col:%d\", n.Line, n.Column)\n\t}\n\trs := make([]*regexp.Regexp, 0, len(n.Content))\n\tfor _, p := range n.Content {\n\t\tr, err := regexp.Compile(p.Value)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"invalid regular expression %q in \\\"ignore\\\" at line%d,col:%d: %w\", p.Value, n.Line, n.Column, err)\n\t\t}\n\t\trs = append(rs, r)\n\t}\n\t*pats = rs\n\treturn nil\n}\n\n// PathConfig is a configuration for specific file path pattern. This is for values of the \"paths\" mapping\n// in the configuration file.\ntype PathConfig struct {\n\t// Ignore is a list of patterns. They are used for ignoring errors by matching to the error messages.\n\t// It is similar to the \"-ignore\" command line option.\n\tIgnore IgnorePatterns `yaml:\"ignore\"`\n}\n\n// Config is configuration of actionlint. This struct instance is parsed from \"actionlint.yaml\"\n// file usually put in \".github\" directory.\ntype Config struct {\n\t// SelfHostedRunner is configuration for self-hosted runner.\n\tSelfHostedRunner struct {\n\t\t// Labels is label names for self-hosted runner.\n\t\tLabels []string `yaml:\"labels\"`\n\t} `yaml:\"self-hosted-runner\"`\n\t// ConfigVariables is names of configuration variables used in the checked workflows. When this value is nil,\n\t// property names of `vars` context will not be checked. Otherwise actionlint will report a name which is not\n\t// listed here as undefined config variables.\n\t// https://docs.github.com/en/actions/learn-github-actions/variables\n\tConfigVariables []string `yaml:\"config-variables\"`\n\t// Paths is a \"paths\" mapping in the configuration file. The keys are glob patterns to match file paths.\n\t// And the values are corresponding configurations applied to the file paths.\n\tPaths map[string]PathConfig `yaml:\"paths\"`\n}\n\n// PathConfigs returns a list of all PathConfig values matching to the given file path. The path must\n// be relative to the root of the project.\nfunc (cfg *Config) PathConfigs(path string) []PathConfig {\n\tpath = filepath.ToSlash(path)\n\n\tvar ret []PathConfig\n\tif cfg != nil {\n\t\tfor p, c := range cfg.Paths {\n\t\t\t// Glob patterns were validated in `ParseConfig()`\n\t\t\tif doublestar.MatchUnvalidated(p, path) {\n\t\t\t\tret = append(ret, c)\n\t\t\t}\n\t\t}\n\t}\n\treturn ret\n}\n\n// ParseConfig parses the given bytes as an actionlint config file. When deserializing the YAML file\n// or the config validation fails, this function returns an error.\nfunc ParseConfig(b []byte) (*Config, error) {\n\tvar c Config\n\tif err := yaml.Unmarshal(b, &c); err != nil {\n\t\tmsg := strings.ReplaceAll(err.Error(), \"\\n\", \" \")\n\t\treturn nil, errors.New(msg)\n\t}\n\tfor pat := range c.Paths {\n\t\tif !doublestar.ValidatePattern(pat) {\n\t\t\treturn nil, fmt.Errorf(\"invalid glob pattern %q in \\\"paths\\\"\", pat)\n\t\t}\n\t}\n\treturn &c, nil\n}\n\n// ReadConfigFile reads actionlint config file (actionlint.yaml) from the given file path.\nfunc ReadConfigFile(path string) (*Config, error) {\n\tb, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read config file %q: %w\", path, err)\n\t}\n\tc, err := ParseConfig(b)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not parse config file %q: %w\", path, err)\n\t}\n\treturn c, nil\n}\n\n// loadRepoConfig reads config file from the repository's .github/actionlint.yml or\n// .github/actionlint.yaml.\nfunc loadRepoConfig(root string) (*Config, error) {\n\tfor _, f := range []string{\"actionlint.yaml\", \"actionlint.yml\"} {\n\t\tp := filepath.Join(root, \".github\", f)\n\t\tc, err := ReadConfigFile(p)\n\t\tswitch {\n\t\tcase errors.Is(err, os.ErrNotExist):\n\t\t\tcontinue\n\t\tcase err != nil:\n\t\t\treturn nil, fmt.Errorf(\"could not parse config file %q: %w\", p, err)\n\t\tdefault:\n\t\t\treturn c, nil\n\t\t}\n\t}\n\treturn nil, nil\n}\n\nfunc writeDefaultConfigFile(path string) error {\n\tb := []byte(`self-hosted-runner:\n  # Labels of self-hosted runner in array of strings.\n  labels: []\n\n# Configuration variables in array of strings defined in your repository or\n# organization. ` + \"`null`\" + ` means disabling configuration variables check.\n# Empty array means no configuration variable is allowed.\nconfig-variables: null\n\n# Configuration for file paths. The keys are glob patterns to match to file\n# paths relative to the repository root. The values are the configurations for\n# the file paths. Note that the path separator is always '/'.\n# The following configurations are available.\n#\n# \"ignore\" is an array of regular expression patterns. Matched error messages\n# are ignored. This is similar to the \"-ignore\" command line option.\npaths:\n#  .github/workflows/**/*.yml:\n#    ignore: []\n`)\n\tif err := os.WriteFile(path, b, 0644); err != nil {\n\t\treturn fmt.Errorf(\"could not write default configuration file at %q: %w\", path, err)\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "config_test.go",
          "type": "blob",
          "size": 6.4306640625,
          "content": "package actionlint\n\nimport (\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc TestConfigParseSelfHostedRunnerOK(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat   string\n\t\tinput  string\n\t\tlabels []string\n\t}{\n\t\t{\n\t\t\twhat:   \"empty config\",\n\t\t\tinput:  \"\",\n\t\t\tlabels: nil,\n\t\t},\n\t\t{\n\t\t\twhat:   \"empty self-hosted-runner\",\n\t\t\tinput:  \"self-hosted-runner:\\n\",\n\t\t\tlabels: nil,\n\t\t},\n\t\t{\n\t\t\twhat:   \"null self-hosted-runner labels\",\n\t\t\tinput:  \"self-hosted-runner:\\n  labels:\",\n\t\t\tlabels: nil,\n\t\t},\n\t\t{\n\t\t\twhat:   \"empty self-hosted-runner labels\",\n\t\t\tinput:  \"self-hosted-runner:\\n  labels: []\",\n\t\t\tlabels: []string{},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted-runner labels\",\n\t\t\tinput:  \"self-hosted-runner:\\n  labels: [foo, bar]\",\n\t\t\tlabels: []string{\"foo\", \"bar\"},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tc, err := ParseConfig([]byte(tc.input))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(c.SelfHostedRunner.Labels, tc.labels); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConfigParseError(t *testing.T) {\n\ttests := []struct {\n\t\tin   string\n\t\twant string\n\t}{\n\t\t{\n\t\t\tin:   `self-hosted-runner: 42`,\n\t\t\twant: `cannot unmarshal`,\n\t\t},\n\t\t{\n\t\t\tin: `\npaths:\n  foo:\n    ignore: foo+\n`,\n\t\t\twant: `\"ignore\" must be a sequence node`,\n\t\t},\n\t\t{\n\t\t\tin: `\npaths:\n  foo:\n    ignore: ['(foo']\n`,\n\t\t\twant: `invalid regular expression \"(foo\" in \"ignore\"`,\n\t\t},\n\t\t{\n\t\t\tin: `\npaths:\n  foo.{txt,xml:\n`,\n\t\t\twant: `invalid glob pattern`,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.want, func(t *testing.T) {\n\t\t\t_, err := ParseConfig([]byte(tc.in))\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"no error occurred\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.want) {\n\t\t\t\tt.Fatalf(\"wanted error message %q to contain %q\", err.Error(), tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConfigPathConfigIgnores(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\tmsg   string\n\t\twant  bool\n\t}{\n\t\t{\n\t\t\tinput: ``,\n\t\t\tmsg:   \"this is test\",\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: `ignore: []`,\n\t\t\tmsg:   \"this is test\",\n\t\t\twant:  false,\n\t\t},\n\t\t{\n\t\t\tinput: `ignore: ['(is )+']`,\n\t\t\tmsg:   \"this is test\",\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `ignore: ['does not match', '(is )+']`,\n\t\t\tmsg:   \"this is test\",\n\t\t\twant:  true,\n\t\t},\n\t\t{\n\t\t\tinput: `ignore: ['does not match', 'does not match 2']`,\n\t\t\tmsg:   \"this is test\",\n\t\t\twant:  false,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input+\"_\"+tc.msg, func(t *testing.T) {\n\t\t\tvar c PathConfig\n\t\t\tif err := yaml.Unmarshal([]byte(tc.input), &c); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\thave := c.Ignore.Match(&Error{Message: tc.msg})\n\t\t\tif tc.want != have {\n\t\t\t\tt.Fatalf(\"wanted %v but got %v for message %q and input %q\", tc.want, have, tc.msg, tc.input)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestConfigIgnoreErrors(t *testing.T) {\n\tsrc := `\npaths:\n  .github/workflows/**/*.yaml:\n    ignore: [xxx]\n  .github/workflows/*.yaml:\n    ignore: [yyy]\n  .github/workflows/a/*.yaml:\n    ignore: [zzz]\n  .github/workflows/*/b.yaml:\n    ignore: [uuu]\n  .github/workflows/a/b.yaml:\n    ignore: [vvv]\n  .github/workflows/**/x.yaml:\n    ignore: [www]\n  .github/workflows/**/*.{yml,yaml}:\n    ignore: [ttt]\n`\n\n\tvar cfg Config\n\tif err := yaml.Unmarshal([]byte(src), &cfg); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\ttests := []struct {\n\t\tpath string\n\t\tmsg  string\n\t\twant bool\n\t}{\n\t\t{\"foo.yaml\", \"xxx\", false},\n\t\t{\".github/workflows/a.yaml\", \"xxx\", true},\n\t\t{\".github/workflows/a/b.yaml\", \"xxx\", true},\n\t\t{\".github/workflows/a/b/c/d/e/f/g/h.yaml\", \"xxx\", true},\n\t\t{\".github/workflows/a.yaml\", \"yyy\", true},\n\t\t{\".github/workflows/a/b.yaml\", \"yyy\", false},\n\t\t{\".github/workflows/a/b.yaml\", \"zzz\", true},\n\t\t{\".github/workflows/a/a.yaml\", \"zzz\", true},\n\t\t{\".github/workflows/b/b.yaml\", \"zzz\", false},\n\t\t{\".github/workflows/a/b.yaml\", \"uuu\", true},\n\t\t{\".github/workflows/b/b.yaml\", \"uuu\", true},\n\t\t{\".github/workflows/a/a.yaml\", \"uuu\", false},\n\t\t{\".github/workflows/a/b.yaml\", \"vvv\", true},\n\t\t{\".github/workflows/b/b.yaml\", \"vvv\", false},\n\t\t{\".github/workflows/a/a.yaml\", \"vvv\", false},\n\t\t{\".github/workflows/x.yaml\", \"www\", true},\n\t\t{\".github/workflows/a/x.yaml\", \"www\", true},\n\t\t{\".github/workflows/a/b/x.yaml\", \"www\", true},\n\t\t{\".github/workflows/a/b/c/x.yaml\", \"www\", true},\n\t\t{\".github/workflows/a/b.yaml\", \"this is not ignored\", false},\n\t\t{\".github/workflows/a.yml\", \"xxx\", false},\n\t\t{\".github/workflows/a.yml\", \"ttt\", true},\n\t}\n\n\tfor _, tc := range tests {\n\t\tvar ignored bool\n\t\tfor _, c := range cfg.PathConfigs(tc.path) {\n\t\t\tif c.Ignore.Match(&Error{Message: tc.msg}) {\n\t\t\t\tignored = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif ignored != tc.want {\n\t\t\twant, have := \"not be ignored\", \"was ignored\"\n\t\t\tif tc.want {\n\t\t\t\twant, have = \"be ignored\", \"was not ignored\"\n\t\t\t}\n\t\t\tt.Fatalf(\"error message %q with path %q should %s but actually %s\", tc.msg, tc.path, want, have)\n\t\t}\n\t}\n}\n\nfunc TestConfigReadFileOK(t *testing.T) {\n\tp := filepath.Join(\"testdata\", \"config\", \"ok.yml\")\n\tc, err := ReadConfigFile(p)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tlabels := []string{\"foo\", \"bar\"}\n\tif diff := cmp.Diff(c.SelfHostedRunner.Labels, labels); diff != \"\" {\n\t\tt.Fatal(diff)\n\t}\n}\n\nfunc TestConfigReadFileReadError(t *testing.T) {\n\tp := filepath.Join(\"testdata\", \"config\", \"does-not-exist.yml\")\n\t_, err := ReadConfigFile(p)\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\")\n\t}\n\tmsg := err.Error()\n\tif !strings.Contains(msg, \"could not read config file\") {\n\t\tt.Fatalf(\"unexpected error message: %q\", msg)\n\t}\n}\n\nfunc TestConfigReadFileParseError(t *testing.T) {\n\tp := filepath.Join(\"testdata\", \"config\", \"broken.yml\")\n\t_, err := ReadConfigFile(p)\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\")\n\t}\n\tmsg := err.Error()\n\tif !strings.Contains(msg, \"could not parse config file\") {\n\t\tt.Fatalf(\"unexpected error message: %q\", msg)\n\t}\n}\n\nfunc TestConfigGenerateDefaultConfigFileOK(t *testing.T) {\n\tf := filepath.Join(t.TempDir(), \"default-config-for-test.yml\")\n\tif err := writeDefaultConfigFile(f); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tc, err := ReadConfigFile(f)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(c.SelfHostedRunner.Labels) != 0 {\n\t\tt.Fatal(c.SelfHostedRunner.Labels)\n\t}\n\tif c.ConfigVariables != nil {\n\t\tt.Fatal(c.SelfHostedRunner.Labels)\n\t}\n\tif len(c.Paths) != 0 {\n\t\tt.Fatal(c.Paths)\n\t}\n}\n\nfunc TestConfigGenerateDefaultConfigFileError(t *testing.T) {\n\tp := filepath.Join(\"testdata\", \"config\", \"dir-does-not-exist\", \"test.yml\")\n\terr := writeDefaultConfigFile(p)\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\")\n\t}\n\tmsg := err.Error()\n\tif !strings.Contains(msg, \"could not write default configuration file\") {\n\t\tt.Fatalf(\"unexpected error message: %q\", msg)\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.619140625,
          "content": "/*\nPackage actionlint is the implementation of actionlint linter. It's a static checker for GitHub\nActions workflow files.\n\nhttps://github.com/rhysd/actionlint\n\nactionlint is a command line tool but it also provides Go API for Go programs. It includes a\nworkflow file parser built on top of go-yaml/yaml, lexer/parser/checker for expressions embedded by\n${{ }} placeholder, popular actions data, available contexts information, etc.\n\nTo run the linter, Linter is the struct which manages the entire linter lifecycle. Please see the\nfirst example.\n\nactionlint also provides the flexibility to add your own rules by implementing Rule interface.\nPlease read the YourOwnRule example.\n\n# Library versioning\n\nThe version is for the command line tool. So it does not represent the version of the library. It\nmeans that the library does not follow semantic versioning and any patch version bump may introduce\nsome breaking changes.\n\n# Go version compatibility\n\nMinimum supported Go version is written in go.mod file in this library. That said, older Go versions\nare actually not tested on CI. Last two major Go versions are recommended because they're tested on\nCI. For example, when the latest Go version is v1.22, v1.21 and v1.22 are nice to use.\n\nhttps://github.com/rhysd/actionlint/blob/main/go.mod\n\n# Other documentations\n\nAll documentations for actionlint can be found in the following page.\n\nhttps://github.com/rhysd/actionlint/tree/main/docs\n\n# License\n\nThis library is provided under the MIT license.\n\n> Copyright (c) 2021 rhysd\n\nFull text can be found in the following page.\n\nhttps://github.com/rhysd/actionlint/blob/main/LICENSE.txt\n*/\npackage actionlint\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 8.9208984375,
          "content": "package actionlint\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"sort\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/mattn/go-runewidth\"\n)\n\nvar (\n\tbold   = color.New(color.Bold)\n\tgreen  = color.New(color.FgGreen)\n\tyellow = color.New(color.FgYellow)\n\tgray   = color.New(color.FgHiBlack)\n)\n\n// Error represents an error detected by actionlint rules\ntype Error struct {\n\t// Message is an error message.\n\tMessage string\n\t// Filepath is a file path where the error occurred.\n\tFilepath string\n\t// Line is a line number where the error occurred. This value is 1-based.\n\tLine int\n\t// Column is a column number where the error occurred. This value is 1-based.\n\tColumn int\n\t// Kind is a string to represent kind of the error. Usually rule name which found the error.\n\tKind string\n}\n\n// Error returns summary of the error as string.\nfunc (e *Error) Error() string {\n\treturn fmt.Sprintf(\"%s:%d:%d: %s [%s]\", e.Filepath, e.Line, e.Column, e.Message, e.Kind)\n}\n\nfunc (e *Error) String() string {\n\treturn e.Error()\n}\n\nfunc errorAt(pos *Pos, kind string, msg string) *Error {\n\treturn &Error{\n\t\tMessage: msg,\n\t\tLine:    pos.Line,\n\t\tColumn:  pos.Col,\n\t\tKind:    kind,\n\t}\n}\n\nfunc errorfAt(pos *Pos, kind string, format string, args ...interface{}) *Error {\n\treturn &Error{\n\t\tMessage: fmt.Sprintf(format, args...),\n\t\tLine:    pos.Line,\n\t\tColumn:  pos.Col,\n\t\tKind:    kind,\n\t}\n}\n\n// GetTemplateFields fields for formatting this error with Go template.\nfunc (e *Error) GetTemplateFields(source []byte) *ErrorTemplateFields {\n\tsnippet := \"\"\n\tend := e.Column\n\tif len(source) > 0 && e.Line > 0 {\n\t\tif l, ok := e.getLine(source); ok {\n\t\t\tsnippet = l\n\t\t\tif len(l) >= e.Column-1 {\n\t\t\t\tif i := e.getIndicator(l); i != \"\" {\n\t\t\t\t\tsnippet += \"\\n\" + i\n\t\t\t\t\tend = len(i) // Byte length can be used here because this line only contains ASCII\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn &ErrorTemplateFields{\n\t\tMessage:   e.Message,\n\t\tFilepath:  e.Filepath,\n\t\tLine:      e.Line,\n\t\tColumn:    e.Column,\n\t\tKind:      e.Kind,\n\t\tSnippet:   snippet,\n\t\tEndColumn: end,\n\t}\n}\n\n// PrettyPrint prints the error with user-friendly way. It prints file name, source position, error\n// message with colorful output and source snippet with indicator. When nil is set to source, no\n// source snippet is not printed. To disable colorful output, set true to fatih/color.NoColor.\nfunc (e *Error) PrettyPrint(w io.Writer, source []byte) {\n\tyellow.Fprint(w, e.Filepath)\n\tgray.Fprint(w, \":\")\n\tfmt.Fprint(w, e.Line)\n\tgray.Fprint(w, \":\")\n\tfmt.Fprint(w, e.Column)\n\tgray.Fprint(w, \": \")\n\tbold.Fprint(w, e.Message)\n\tgray.Fprintf(w, \" [%s]\\n\", e.Kind)\n\n\tif len(source) == 0 || e.Line <= 0 {\n\t\treturn\n\t}\n\tline, ok := e.getLine(source)\n\tif !ok || len(line) < e.Column-1 {\n\t\treturn\n\t}\n\n\tlnum := fmt.Sprintf(\"%d | \", e.Line)\n\tindent := strings.Repeat(\" \", len(lnum)-2)\n\tgray.Fprintf(w, \"%s|\\n\", indent)\n\tgray.Fprint(w, lnum)\n\tfmt.Fprintln(w, line)\n\tgray.Fprintf(w, \"%s| \", indent)\n\tgreen.Fprintln(w, e.getIndicator(line))\n}\n\nfunc (e *Error) getLine(source []byte) (string, bool) {\n\ts := bufio.NewScanner(bytes.NewReader(source))\n\tl := 0\n\tfor s.Scan() {\n\t\tl++\n\t\tif l == e.Line {\n\t\t\treturn s.Text(), true\n\t\t}\n\t}\n\treturn \"\", false\n}\n\nfunc (e *Error) getIndicator(line string) string {\n\tif e.Column <= 0 {\n\t\treturn \"\"\n\t}\n\n\tstart := e.Column - 1 // Column is 1-based\n\n\t// Count width of non-space characters after '^' for underline\n\tuw := 0\n\tr := strings.NewReader(line[start:])\n\tfor {\n\t\tc, s, err := r.ReadRune()\n\t\tif err != nil || s == 0 || c == ' ' || c == '\\t' || c == '\\n' || c == '\\r' {\n\t\t\tbreak\n\t\t}\n\t\tuw += runewidth.RuneWidth(c)\n\t}\n\tif uw > 0 {\n\t\tuw-- // Decrement for place for '^'\n\t}\n\n\t// Count width of spaces before '^'\n\tsw := runewidth.StringWidth(line[:start])\n\treturn fmt.Sprintf(\"%s^%s\", strings.Repeat(\" \", sw), strings.Repeat(\"~\", uw))\n}\n\n// ByErrorPosition is predicate for sort.Interface. It sorts errors slice by file path, line, and\n// column.\ntype ByErrorPosition []*Error\n\nfunc (by ByErrorPosition) Len() int {\n\treturn len(by)\n}\n\nfunc (by ByErrorPosition) Less(i, j int) bool {\n\tif c := strings.Compare(by[i].Filepath, by[j].Filepath); c != 0 {\n\t\treturn c < 0\n\t}\n\tif by[i].Line == by[j].Line {\n\t\treturn by[i].Column < by[j].Column\n\t}\n\treturn by[i].Line < by[j].Line\n}\n\nfunc (by ByErrorPosition) Swap(i, j int) {\n\tby[i], by[j] = by[j], by[i]\n}\n\n// ErrorTemplateFields holds all fields to format one error message.\ntype ErrorTemplateFields struct {\n\t// Message is error message body.\n\tMessage string `json:\"message\"`\n\t// Filepath is a canonical relative file path. This is empty when input was read from stdin.\n\t// When encoding into JSON, this field may be omitted when the file path is empty.\n\tFilepath string `json:\"filepath,omitempty\"`\n\t// Line is a line number of error position.\n\tLine int `json:\"line\"`\n\t// Column is a column number of error position.\n\tColumn int `json:\"column\"`\n\t// Kind is a rule name the error belongs to.\n\tKind string `json:\"kind\"`\n\t// Snippet is a code snippet and indicator to indicate where the error occurred.\n\t// When encoding into JSON, this field may be omitted when the snippet is empty.\n\tSnippet string `json:\"snippet,omitempty\"`\n\t// EndColumn is a column number where the error indicator (^~~~~~~) ends. When no indicator\n\t// can be shown, EndColumn is equal to Column.\n\tEndColumn int `json:\"end_column\"`\n}\n\nfunc unescapeBackslash(s string) string {\n\t// https://golang.org/ref/spec#Rune_literals\n\tr := strings.NewReplacer(\n\t\t`\\a`, \"\\a\",\n\t\t`\\b`, \"\\b\",\n\t\t`\\f`, \"\\f\",\n\t\t`\\n`, \"\\n\",\n\t\t`\\r`, \"\\r\",\n\t\t`\\t`, \"\\t\",\n\t\t`\\v`, \"\\v\",\n\t\t`\\\\`, \"\\\\\",\n\t)\n\treturn r.Replace(s)\n}\n\nfunc toPascalCase(s string) string {\n\tss := strings.FieldsFunc(s, func(r rune) bool {\n\t\treturn !('a' <= r && r <= 'z' || 'A' <= r && r <= 'Z' || '0' <= r && r <= '9')\n\t})\n\tfor i, s := range ss {\n\t\tvar c rune\n\t\tfor _, c = range s {\n\t\t\tbreak\n\t\t}\n\t\tif 'a' <= c && c <= 'z' {\n\t\t\tss[i] = strings.ToUpper(s[:1]) + s[1:]\n\t\t}\n\t}\n\treturn strings.Join(ss, \"\")\n}\n\ntype ruleTemplateFields struct {\n\tName        string\n\tDescription string\n}\n\ntype byRuleNameField []*ruleTemplateFields\n\nfunc (by byRuleNameField) Len() int {\n\treturn len(by)\n}\nfunc (by byRuleNameField) Less(i, j int) bool {\n\treturn strings.Compare(by[i].Name, by[j].Name) < 0\n}\nfunc (by byRuleNameField) Swap(i, j int) {\n\tby[i], by[j] = by[j], by[i]\n}\n\n// ErrorFormatter is a formatter to format a slice of ErrorTemplateFields. It is used for\n// formatting error messages with -format option.\ntype ErrorFormatter struct {\n\ttemp    *template.Template\n\trules   map[string]*ruleTemplateFields\n\trulesMu sync.Mutex\n}\n\n// NewErrorFormatter creates new ErrorFormatter instance. Given format must contain at least one\n// {{ }} placeholder. Escaped characters like \\n in the format string are unescaped.\nfunc NewErrorFormatter(format string) (*ErrorFormatter, error) {\n\tif !strings.Contains(format, \"{{\") {\n\t\treturn nil, fmt.Errorf(\"template to format error messages must contain at least one {{ }} placeholder: %s\", format)\n\t}\n\n\tr := map[string]*ruleTemplateFields{\n\t\t\"syntax-check\": {\"syntax-check\", \"Checks for GitHub Actions workflow syntax\"},\n\t}\n\n\tfuncs := template.FuncMap(map[string]interface{}{\n\t\t\"json\": func(data interface{}) (string, error) {\n\t\t\tvar b strings.Builder\n\t\t\tenc := json.NewEncoder(&b)\n\t\t\tif err := enc.Encode(data); err != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"could not encode template value into JSON: %w\", err)\n\t\t\t}\n\t\t\treturn b.String(), nil\n\t\t},\n\t\t\"replace\": func(s string, oldnew ...string) string {\n\t\t\treturn strings.NewReplacer(oldnew...).Replace(s)\n\t\t},\n\t\t\"toPascalCase\": toPascalCase,\n\t\t\"getVersion\":   getCommandVersion,\n\t\t\"allKinds\": func() []*ruleTemplateFields {\n\t\t\tret := make([]*ruleTemplateFields, 0, len(r))\n\t\t\tfor _, e := range r {\n\t\t\t\tret = append(ret, e)\n\t\t\t}\n\t\t\tsort.Sort(byRuleNameField(ret))\n\t\t\treturn ret\n\t\t},\n\t})\n\tt, err := template.New(\"error formatter\").Funcs(funcs).Parse(unescapeBackslash(format))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"template %q to format error messages could not be parsed: %w\", format, err)\n\t}\n\n\treturn &ErrorFormatter{t, r, sync.Mutex{}}, nil\n}\n\n// Print formats the slice of template fields and prints it with given writer.\nfunc (f *ErrorFormatter) Print(out io.Writer, t []*ErrorTemplateFields) error {\n\tif err := f.temp.Execute(out, t); err != nil {\n\t\treturn fmt.Errorf(\"could not format error messages: %w\", err)\n\t}\n\treturn nil\n}\n\n// PrintErrors prints the errors after formatting them with template.\nfunc (f *ErrorFormatter) PrintErrors(out io.Writer, errs []*Error, src []byte) error {\n\tt := make([]*ErrorTemplateFields, 0, len(errs))\n\tfor _, err := range errs {\n\t\tt = append(t, err.GetTemplateFields(src))\n\t}\n\treturn f.Print(out, t)\n}\n\n// RegisterRule registers the rule. Registered rules are used to get description and index of error\n// kinds when you use `kindDescription` or `kindIndex` functions in an error format template. This\n// method can be called multiple times safely in parallel.\nfunc (f *ErrorFormatter) RegisterRule(r Rule) {\n\t// Synchronize access to f.rules (#370)\n\tf.rulesMu.Lock()\n\tdefer f.rulesMu.Unlock()\n\n\tn := r.Name()\n\tif _, ok := f.rules[n]; !ok {\n\t\tf.rules[n] = &ruleTemplateFields{n, r.Description()}\n\t}\n}\n"
        },
        {
          "name": "error_test.go",
          "type": "blob",
          "size": 14.591796875,
          "content": "package actionlint\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc init() {\n\tcolor.NoColor = true\n}\n\ntype testErrorWriter struct{}\n\nfunc (w testErrorWriter) Write(b []byte) (int, error) {\n\treturn 0, errors.New(\"dummy write error\")\n}\n\nfunc TestErrorErrorAt(t *testing.T) {\n\tm := \"message\"\n\tk := \"kind\"\n\terr := errorAt(&Pos{1, 2}, k, m)\n\tif err.Message != m {\n\t\tt.Errorf(\"wanted %q but got %q\", m, err.Message)\n\t}\n\tif err.Filepath != \"\" {\n\t\tt.Errorf(\"wanted %q to be empty\", err.Filepath)\n\t}\n\tif err.Line != 1 {\n\t\tt.Errorf(\"wanted line 1 but got %q\", err.Line)\n\t}\n\tif err.Column != 2 {\n\t\tt.Errorf(\"wanted col 2 but got %q\", err.Column)\n\t}\n\tif err.Kind != k {\n\t\tt.Errorf(\"wanted %q but got %q\", k, err.Kind)\n\t}\n}\n\nfunc TestErrorErrorfAt(t *testing.T) {\n\tm := \"this is message\"\n\tk := \"kind\"\n\terr := errorfAt(&Pos{1, 2}, k, \"%s is %s\", \"this\", \"message\")\n\tif err.Message != m {\n\t\tt.Errorf(\"wanted %q but got %q\", m, err.Message)\n\t}\n\tif err.Filepath != \"\" {\n\t\tt.Errorf(\"wanted %q to be empty\", err.Filepath)\n\t}\n\tif err.Line != 1 {\n\t\tt.Errorf(\"wanted line 1 but got %q\", err.Line)\n\t}\n\tif err.Column != 2 {\n\t\tt.Errorf(\"wanted col 2 but got %q\", err.Column)\n\t}\n\tif err.Kind != k {\n\t\tt.Errorf(\"wanted %q but got %q\", k, err.Kind)\n\t}\n}\n\nfunc TestErrorPrettyPrint(t *testing.T) {\n\ttestCases := []struct {\n\t\tmessage  string\n\t\tline     int\n\t\tcolumn   int\n\t\tkind     string\n\t\texpected string\n\t\tsource   string\n\t}{\n\t\t{\n\t\t\tmessage:  \"simple message\",\n\t\t\tline:     1,\n\t\t\tcolumn:   1,\n\t\t\texpected: \"filename.txt:1:1: simple message [kind]\",\n\t\t},\n\t\t{\n\t\t\tmessage: \"simple message with source\",\n\t\t\tline:    1,\n\t\t\tcolumn:  1,\n\t\t\tsource:  \"this is source\",\n\t\t\texpected: `filename.txt:1:1: simple message with source [kind]\n  |\n1 | this is source\n  | ^~~~`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at middle of source\",\n\t\t\tline:    1,\n\t\t\tcolumn:  6,\n\t\t\tsource:  \"this is source\",\n\t\t\texpected: `filename.txt:1:6: error at middle of source [kind]\n  |\n1 | this is source\n  |      ^~`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at end of source\",\n\t\t\tline:    1,\n\t\t\tcolumn:  15,\n\t\t\tsource:  \"this is source\",\n\t\t\texpected: `filename.txt:1:15: error at end of source [kind]\n  |\n1 | this is source\n  |               ^`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at one character word in source\",\n\t\t\tline:    1,\n\t\t\tcolumn:  5,\n\t\t\tsource:  \"foo . bar\",\n\t\t\texpected: `filename.txt:1:5: error at one character word in source [kind]\n  |\n1 | foo . bar\n  |     ^`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at space in source\",\n\t\t\tline:    1,\n\t\t\tcolumn:  4,\n\t\t\tsource:  \"foo bar\",\n\t\t\texpected: `filename.txt:1:4: error at space in source [kind]\n  |\n1 | foo bar\n  |    ^`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"simple message with multi-line source\",\n\t\t\tline:    3,\n\t\t\tcolumn:  3,\n\t\t\tsource:  \"this\\nis\\nsource\",\n\t\t\texpected: `filename.txt:3:3: simple message with multi-line source [kind]\n  |\n3 | source\n  |   ^~~~`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at end of multi-line source\",\n\t\t\tline:    3,\n\t\t\tcolumn:  7,\n\t\t\tsource:  \"this\\nis\\nsource\",\n\t\t\texpected: `filename.txt:3:7: error at end of multi-line source [kind]\n  |\n3 | source\n  |       ^`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at newline of multi-line source\",\n\t\t\tline:    2,\n\t\t\tcolumn:  3,\n\t\t\tsource:  \"this\\nis\\nsource\",\n\t\t\texpected: `filename.txt:2:3: error at newline of multi-line source [kind]\n  |\n2 | is\n  |   ^`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at blank line of multi-line source\",\n\t\t\tline:    2,\n\t\t\tcolumn:  1,\n\t\t\tsource:  \"this\\n\\nsource\",\n\t\t\texpected: `filename.txt:2:1: error at blank line of multi-line source [kind]\n  |\n2 | \n  | ^`,\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at line more than 10\",\n\t\t\tline:    11,\n\t\t\tcolumn:  2,\n\t\t\tsource:  \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nfooo\",\n\t\t\texpected: `filename.txt:11:2: error at line more than 10 [kind]\n   |\n11 | fooo\n   |  ^~~`,\n\t\t},\n\t\t{\n\t\t\tmessage:  \"error at out of source\",\n\t\t\tline:     2,\n\t\t\tcolumn:   6,\n\t\t\tsource:   \"aaa\\nbbb\\nccc\",\n\t\t\texpected: \"filename.txt:2:6: error at out of source [kind]\",\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at zero column\",\n\t\t\tline:    1,\n\t\t\tcolumn:  0,\n\t\t\tsource:  \"this is source\",\n\t\t\texpected: `filename.txt:1:0: error at zero column [kind]\n  |\n1 | this is source\n  | `,\n\t\t},\n\t\t{\n\t\t\tmessage:  \"error at zero line and zero column\",\n\t\t\tline:     0,\n\t\t\tcolumn:   0,\n\t\t\tsource:   \"this is source\",\n\t\t\texpected: `filename.txt:0:0: error at zero line and zero column [kind]`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.message, func(t *testing.T) {\n\t\t\terr := errorAt(&Pos{tc.line, tc.column}, \"kind\", tc.message)\n\t\t\terr.Filepath = \"filename.txt\"\n\n\t\t\tvar buf bytes.Buffer\n\t\t\terr.PrettyPrint(&buf, []byte(tc.source))\n\n\t\t\tout := buf.String()\n\t\t\twant := tc.expected + \"\\n\"\n\t\t\tif out != want {\n\t\t\t\tt.Fatalf(\"wanted:\\n%q\\n\\nhave:\\n%q\", want, out)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorSortErrorsByPosition(t *testing.T) {\n\ttestCases := [][]struct {\n\t\tline int\n\t\tcol  int\n\t}{\n\t\t{},\n\t\t{\n\t\t\t{1, 2},\n\t\t},\n\t\t{\n\t\t\t{1, 2},\n\t\t\t{4, 1},\n\t\t\t{3, 20},\n\t\t\t{1, 1},\n\t\t},\n\t\t{\n\t\t\t{1, 1},\n\t\t\t{1, 1},\n\t\t\t{1, 1},\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\terrs := make([]*Error, 0, len(tc))\n\t\t\tfor _, p := range tc {\n\t\t\t\terrs = append(errs, &Error{Line: p.line, Column: p.col})\n\t\t\t}\n\n\t\t\tsort.Stable(ByErrorPosition(errs))\n\n\t\t\tfor i := 0; i < len(errs)-1; i++ {\n\t\t\t\tl, r := errs[i], errs[i+1]\n\t\t\t\tsorted := l.Line <= r.Line\n\t\t\t\tif l.Line == r.Line {\n\t\t\t\t\tsorted = l.Column <= r.Column\n\t\t\t\t}\n\t\t\t\tif !sorted {\n\t\t\t\t\tt.Fatalf(\"errs[%d] and errs[%d] are not sorted: %s\", i, i+1, errs)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorSortErrorsByFile(t *testing.T) {\n\terrs := []*Error{\n\t\t{\n\t\t\tFilepath: \"path/to/C.txt\",\n\t\t\tLine:     1,\n\t\t\tColumn:   2,\n\t\t},\n\t\t{\n\t\t\tFilepath: \"path/to/A.txt\",\n\t\t\tLine:     2,\n\t\t\tColumn:   4,\n\t\t},\n\t\t{\n\t\t\tFilepath: \"path/to/B.txt\",\n\t\t\tLine:     3,\n\t\t\tColumn:   6,\n\t\t},\n\t}\n\n\tsort.Stable(ByErrorPosition(errs))\n\n\tfor i, want := range []string{\n\t\t\"path/to/A.txt\",\n\t\t\"path/to/B.txt\",\n\t\t\"path/to/C.txt\",\n\t} {\n\t\tif have := errs[i].Filepath; have != want {\n\t\t\tt.Errorf(\"Errors were not sorted correctly. expected %q for errs[%d] but got %q: %v\", want, i, have, errs)\n\t\t}\n\t}\n}\n\nfunc TestErrorGetTemplateFieldsOK(t *testing.T) {\n\ttestCases := []struct {\n\t\tmessage string\n\t\tcolumn  int\n\t\tendCol  int\n\t\tsource  string\n\t\tsnippet string\n\t}{\n\t\t{\n\t\t\tmessage: \"simple message with source\",\n\t\t\tcolumn:  1,\n\t\t\tendCol:  4,\n\t\t\tsource:  \"this is source\",\n\t\t\tsnippet: \"this is source\\n^~~~\",\n\t\t},\n\t\t{\n\t\t\tmessage: \"simple message\",\n\t\t\tcolumn:  1,\n\t\t\tendCol:  1,\n\t\t\tsnippet: \"\",\n\t\t},\n\t\t{\n\t\t\tmessage: \"error at zero column\",\n\t\t\tcolumn:  0,\n\t\t\tendCol:  0,\n\t\t\tsource:  \"this is source\",\n\t\t\tsnippet: \"this is source\",\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\terr := errorAt(&Pos{1, tc.column}, \"kind\", tc.message)\n\t\t\terr.Filepath = \"filename.txt\"\n\t\t\tf := err.GetTemplateFields([]byte(tc.source))\n\t\t\tif f.Message != tc.message {\n\t\t\t\tt.Fatalf(\"wanted %q but have %q\", tc.message, f.Message)\n\t\t\t}\n\t\t\tif f.Line != err.Line {\n\t\t\t\tt.Fatalf(\"wanted %d but have %d\", err.Line, f.Line)\n\t\t\t}\n\t\t\tif f.Column != tc.column {\n\t\t\t\tt.Fatalf(\"wanted %d but have %d\", tc.column, f.Column)\n\t\t\t}\n\t\t\tif f.Filepath != err.Filepath {\n\t\t\t\tt.Fatalf(\"wanted %q but have %q\", err.Filepath, f.Filepath)\n\t\t\t}\n\t\t\tif f.Kind != err.Kind {\n\t\t\t\tt.Fatalf(\"wanted %q but have %q\", err.Kind, f.Kind)\n\t\t\t}\n\t\t\tif f.Snippet != tc.snippet {\n\t\t\t\tt.Fatalf(\"wanted %q but have %q\", tc.snippet, f.Snippet)\n\t\t\t}\n\t\t\tif f.EndColumn != tc.endCol {\n\t\t\t\tt.Fatalf(\"wanted %d but have %d\", tc.endCol, f.EndColumn)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Regression test for #128\nfunc TestErrorGetTemplateFieldsColumnIsOutOfBounds(t *testing.T) {\n\terr := errorAt(&Pos{1, 9999}, \"kind\", \"this is message\")\n\terr.Filepath = \"filename.yaml\"\n\tf := err.GetTemplateFields([]byte(\"this is source\"))\n\tif strings.Contains(f.Snippet, \"\\n\") {\n\t\tt.Fatalf(\"snippet should contain indicator but it has: %q\", f.Snippet)\n\t}\n}\n\nfunc TestErrorErrorToString(t *testing.T) {\n\terr := &Error{\n\t\tMessage: \"this is message\",\n\t\tLine:    1,\n\t\tColumn:  2,\n\t\tKind:    \"test\",\n\t}\n\twant := err.Error()\n\thave := err.String()\n\tif want != have {\n\t\tt.Fatalf(\"wanted %q but have %q\", want, have)\n\t}\n}\n\nvar testErrorTemplateFields = []*ErrorTemplateFields{\n\t{\n\t\tMessage:   \"message 1\",\n\t\tFilepath:  \"file1\",\n\t\tLine:      1,\n\t\tColumn:    2,\n\t\tEndColumn: 3,\n\t\tSnippet:   \"snippet 1\",\n\t\tKind:      \"kind1\",\n\t},\n\t{\n\t\tMessage:   \"message 2\",\n\t\tFilepath:  \"file2\",\n\t\tLine:      3,\n\t\tColumn:    4,\n\t\tEndColumn: 5,\n\t\tSnippet:   \"snippet 2\",\n\t\tKind:      \"kind2\",\n\t},\n}\n\nfunc TestErrorPrintFormattedWithTemplateFields(t *testing.T) {\n\ttestCases := []struct {\n\t\ttemp string\n\t\twant string\n\t}{\n\t\t{\n\t\t\ttemp: \"{{(index . 0).Message}} {{(index . 1).Message}}\",\n\t\t\twant: \"message 1 message 2\",\n\t\t},\n\t\t{\n\t\t\ttemp: \"{{range $ = .}}({{$.Line}}, {{$.Column}}){{end}}\",\n\t\t\twant: \"(1, 2)(3, 4)\",\n\t\t},\n\t\t{\n\t\t\ttemp: \"{{range $ = .}}[{{$.Column}}..{{$.EndColumn}}]{{end}}\",\n\t\t\twant: \"[2..3][4..5]\",\n\t\t},\n\t\t{\n\t\t\ttemp: \"{{range $ = .}}{{json $.Snippet}}{{end}}\",\n\t\t\twant: \"\\\"snippet 1\\\"\\n\\\"snippet 2\\\"\\n\",\n\t\t},\n\t\t{\n\t\t\ttemp: \"{{range $ = .}}{{replace $.Kind \\\"kind\\\" \\\"king\\\"}}{{end}}\",\n\t\t\twant: \"king1king2\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.temp, func(t *testing.T) {\n\t\t\tf, err := NewErrorFormatter(tc.temp)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar b strings.Builder\n\t\t\tif err := f.Print(&b, testErrorTemplateFields); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\thave := b.String()\n\t\t\tif tc.want != have {\n\t\t\t\tt.Fatalf(\"wanted %q but have %q\", tc.want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorPrintFormattedErrors(t *testing.T) {\n\terrs := []*Error{\n\t\terrorAt(&Pos{1, 1}, \"kind1\", \"error1\"),\n\t\terrorAt(&Pos{1, 0}, \"kind2\", \"error2\"),\n\t}\n\n\tf, err := NewErrorFormatter(\"{{range $ = .}}({{$.Message | printf \\\"%q\\\"}},{{$.Snippet | printf \\\"%q\\\"}}){{end}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b strings.Builder\n\tif err := f.PrintErrors(&b, errs, []byte(\"this is source\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\thave := b.String()\n\twant := `(\"error1\",\"this is source\\n^~~~\")(\"error2\",\"this is source\")`\n\tif want != have {\n\t\tt.Fatalf(\"wanted %q but have %q\", want, have)\n\t}\n}\n\nfunc TestErrorPrintSerializedIntoJSON(t *testing.T) {\n\tf, err := NewErrorFormatter(\"{{json .}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b bytes.Buffer\n\tif err := f.Print(&b, testErrorTemplateFields); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdecoded := []*ErrorTemplateFields{}\n\tif err := json.Unmarshal(b.Bytes(), &decoded); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := cmp.Diff(testErrorTemplateFields, decoded); diff != \"\" {\n\t\tt.Fatal(diff)\n\t}\n}\n\nfunc TestErrorPrintAllKinds(t *testing.T) {\n\tf, err := NewErrorFormatter(\"{{range $ = allKinds}}{{$.Name}}: {{$.Description}}\\n{{end}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tf.RegisterRule(&RuleBase{\n\t\tname: \"rule1\",\n\t\tdesc: \"description for rule1\",\n\t})\n\tf.RegisterRule(&RuleBase{\n\t\tname: \"rule2\",\n\t\tdesc: \"description for rule2\",\n\t})\n\n\tvar b bytes.Buffer\n\tif err := f.PrintErrors(&b, []*Error{}, []byte(\"dummy source\")); err != nil {\n\t\tt.Fatal(err)\n\t}\n\toutput := b.String()\n\n\tfor _, want := range []string{\n\t\t\"syntax-check: Checks for GitHub Actions workflow syntax\\n\",\n\t\t\"rule1: description for rule1\\n\",\n\t\t\"rule2: description for rule2\\n\",\n\t} {\n\t\tif !strings.Contains(output, want) {\n\t\t\tt.Errorf(\"%q is not included in `allKinds` output: %q\", want, output)\n\t\t}\n\t}\n}\n\nfunc TestErrorNewErrorFormatterError(t *testing.T) {\n\ttestCases := []struct {\n\t\ttemp string\n\t\twant string\n\t}{\n\t\t{\"hello\", \"template to format error messages must contain at least one {{ }} placeholder\"},\n\t\t{\"{{xxx\", \"template \\\"{{xxx\\\" to format error messages could not be parsed\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.temp, func(t *testing.T) {\n\t\t\t_, err := NewErrorFormatter(tc.temp)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"error did not occur\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.want) {\n\t\t\t\tt.Fatalf(\"%q is not contained in error message %q\", tc.want, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorFormatterPrintError(t *testing.T) {\n\ttestCases := []struct {\n\t\tout  io.Writer\n\t\ttemp string\n\t\twant string\n\t}{\n\t\t{io.Discard, \"{{.Foo}}\", \"can't evaluate field Foo in type\"},\n\t\t{testErrorWriter{}, \"{{(index . 0).Message}}\", \"dummy write error\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.temp, func(t *testing.T) {\n\t\t\tf, err := NewErrorFormatter(tc.temp)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terr = f.Print(tc.out, testErrorTemplateFields)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"error did not occur\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.want) {\n\t\t\t\tt.Fatalf(\"%q is not contained in error message %q\", tc.want, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorFormatterPrintJSONEncodeError(t *testing.T) {\n\tf, err := NewErrorFormatter(\"{{json .}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b strings.Builder\n\terr = f.temp.Execute(&b, math.NaN())\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\", b.String())\n\t}\n\twant := \"could not encode template value into JSON\"\n\tif !strings.Contains(err.Error(), want) {\n\t\tt.Fatalf(\"%q is not contained in error message %q\", want, err.Error())\n\t}\n}\n\nfunc TestErrorFormatterPrintToPascalCase(t *testing.T) {\n\ttests := []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\"\", \"\"},\n\t\t{\"foo\", \"Foo\"},\n\t\t{\"Foo\", \"Foo\"},\n\t\t{\"foo-bar\", \"FooBar\"},\n\t\t{\"fooBar\", \"FooBar\"},\n\t\t{\"FooBar\", \"FooBar\"},\n\t\t{\"foo_bar\", \"FooBar\"},\n\t\t{\"foo.bar\", \"FooBar\"},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tf, err := NewErrorFormatter(\"{{range $ = .}}{{toPascalCase .Message}}{{end}}\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tvar b strings.Builder\n\n\t\t\tfs := []*ErrorTemplateFields{{Message: tc.input}}\n\t\t\tif err := f.Print(&b, fs); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\thave := b.String()\n\t\t\tif have != tc.want {\n\t\t\t\tt.Fatalf(\"wanted %q but have %q\", tc.want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestErrorFormatterPrintGetVersion(t *testing.T) {\n\tsaved := version\n\tdefer func() {\n\t\tversion = saved\n\t}()\n\tversion = \"dummy version\"\n\n\tf, err := NewErrorFormatter(\"{{getVersion}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar b strings.Builder\n\n\tif err := f.Print(&b, []*ErrorTemplateFields{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tout := b.String()\n\tif out != \"dummy version\" {\n\t\tt.Fatalf(\"version should be \\\"dummy version\\\" but have %q\", out)\n\t}\n}\n\n// Regression test for #370\nfunc TestErrorFormatterRegisterRuleInParallel(t *testing.T) {\n\tf, err := NewErrorFormatter(\"{{json .}}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\trules := []Rule{}\n\tfor i := 0; i < 100; i++ {\n\t\trules = append(rules,\n\t\t\t&RuleBase{\n\t\t\t\tname: fmt.Sprintf(\"rule%d\", i),\n\t\t\t\tdesc: fmt.Sprintf(\"description for rule%d\", i),\n\t\t\t},\n\t\t)\n\t}\n\n\tdone := make(chan struct{})\n\n\tfor i := 0; i < 100; i++ {\n\t\tgo func() {\n\t\t\tfor _, r := range rules {\n\t\t\t\tf.RegisterRule(r)\n\t\t\t}\n\t\t\tdone <- struct{}{}\n\t\t}()\n\t}\n\n\tfor i := 0; i < 100; i++ {\n\t\t<-done\n\t}\n\n\t// Note: `syntax-check` rule is registered by NewErrorFormatter\n\tif len(f.rules) != 101 {\n\t\tt.Fatalf(\"not all rules were registered. %d rules were registered\", len(f.rules))\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 2.802734375,
          "content": "package actionlint_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/rhysd/actionlint\"\n)\n\nfunc ExampleLinter() {\n\t// Specify linter options\n\to := &actionlint.LinterOptions{\n\t\tIgnorePatterns: []string{`'label \".+\" is unknown'`},\n\t\t// Other options...\n\t}\n\n\t// Create Linter instance which outputs errors to stdout\n\tl, err := actionlint.NewLinter(os.Stdout, o)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// File to check\n\tf := filepath.Join(\"testdata\", \"examples\", \"main.yaml\")\n\n\t// First return value is an array of lint errors found in the workflow files. The second return\n\t// value is an error of actionlint itself. This call outputs the lint errors to stdout. Use\n\t// io.Discard to prevent the output.\n\t//\n\t// There are several methods to run linter.\n\t// - LintFile: Check the given single file\n\t// - LintFiles: Check the given multiple files\n\t// - LintDir: Check all workflow files in the given single directory recursively\n\t// - LintRepository: Check all workflow files under .github/workflows in the given repository\n\t// - LintStdin: Check the given workflow content read from STDIN\n\t// - Lint: Check the given workflow content assuming the given file path\n\terrs, err := l.LintFile(f, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(len(errs), \"lint errors found by actionlint\")\n}\n\nfunc ExampleErrorFormatter() {\n\t// Errors returned from Linter methods\n\terrs := []*actionlint.Error{\n\t\t{\n\t\t\tMessage:  \"error message 1\",\n\t\t\tFilepath: \"foo.yaml\",\n\t\t\tLine:     1,\n\t\t\tColumn:   4,\n\t\t\tKind:     \"rule1\",\n\t\t},\n\t\t{\n\t\t\tMessage:  \"error message 2\",\n\t\t\tFilepath: \"foo.yaml\",\n\t\t\tLine:     3,\n\t\t\tColumn:   1,\n\t\t\tKind:     \"rule2\",\n\t\t},\n\t}\n\n\t// Create ErrorFormatter instance with template\n\tf, err := actionlint.NewErrorFormatter(`{{range $ := .}}{{$.Filepath}}:{{$.Line}}:{{$.Column}}: {{$.Message}}\\n{{end}}`)\n\tif err != nil {\n\t\t// Some error happened while creating the formatter (e.g. syntax error)\n\t\tpanic(err)\n\t}\n\n\tsrc := `on: push\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo\n`\n\n\t// Prints all errors to stdout following the template\n\tif err := f.PrintErrors(os.Stdout, errs, []byte(src)); err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Output:\n\t// foo.yaml:1:4: error message 1\n\t// foo.yaml:3:1: error message 2\n}\n\nfunc ExampleCommand() {\n\t// Write command output to this buffer\n\tvar output bytes.Buffer\n\n\t// Create command instance populating stdin/stdout/stderr\n\tcmd := actionlint.Command{\n\t\tStdin:  os.Stdin,\n\t\tStdout: &output,\n\t\tStderr: &output,\n\t}\n\n\t// Run the command end-to-end. Note that given args should contain program name\n\tworkflow := filepath.Join(\".github\", \"workflows\", \"release.yaml\")\n\tstatus := cmd.Main([]string{\"actionlint\", \"-shellcheck=\", \"-pyflakes=\", workflow})\n\n\tfmt.Println(\"Exited with status\", status)\n\t// Output: Exited with status 0\n\n\tif status != 0 {\n\t\tpanic(\"actionlint command failed: \" + output.String())\n\t}\n}\n"
        },
        {
          "name": "example_your_own_rule_test.go",
          "type": "blob",
          "size": 1.7392578125,
          "content": "package actionlint_test\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"path/filepath\"\n\n\t\"github.com/rhysd/actionlint\"\n)\n\n// A rule type to check every steps have their names.\ntype RuleStepName struct {\n\t// Embedding RuleBase struct implements the minimal Rule interface.\n\tactionlint.RuleBase\n}\n\n// Reimplement methods in RuleBase. Visit* methods are called on checking workflows.\nfunc (r *RuleStepName) VisitStep(n *actionlint.Step) error {\n\t// Implement your own check\n\tif n.Name == nil {\n\t\t// RuleBase provides methods to report errors. See RuleBase.Error and RuleBase.Errorf.\n\t\tr.Error(n.Pos, \"every step must have its name\")\n\t}\n\treturn nil\n}\n\nfunc NewRuleStepName() *RuleStepName {\n\treturn &RuleStepName{\n\t\tRuleBase: actionlint.NewRuleBase(\"step-name\", \"Checks every step has their own name\"),\n\t}\n}\n\nfunc ExampleLinter_yourOwnRule() {\n\t// The function set at OnRulesCreated is called after rule instances are created. You can\n\t// add/remove some rules and return the modified slice. This function is called on linting\n\t// each workflow files.\n\to := &actionlint.LinterOptions{\n\t\tOnRulesCreated: func(rules []actionlint.Rule) []actionlint.Rule {\n\t\t\trules = append(rules, NewRuleStepName())\n\t\t\treturn rules\n\t\t},\n\t}\n\n\tl, err := actionlint.NewLinter(io.Discard, o)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tf := filepath.Join(\"testdata\", \"ok\", \"minimal.yaml\")\n\n\t// First return value is an array of lint errors found in the workflow file.\n\terrs, err := l.LintFile(f, nil)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// `errs` includes errors like below:\n\t//\n\t// testdata/examples/main.yaml:14:9: every step must have its name [step-name]\n\t//    |\n\t// 14 |       - uses: actions/checkout@v4\n\t//    |         ^~~~~\n\tfmt.Println(len(errs), \"lint errors found by actionlint\")\n\t// Output: 1 lint errors found by actionlint\n}\n"
        },
        {
          "name": "expr.go",
          "type": "blob",
          "size": 0.7099609375,
          "content": "package actionlint\n\nimport \"fmt\"\n\n// ExprError is an error type caused by lexing/parsing expression syntax. For more details, see\n// https://docs.github.com/en/actions/learn-github-actions/expressions\ntype ExprError struct {\n\t// Message is an error message\n\tMessage string\n\t// Offset is byte offset position which caused the error\n\tOffset int\n\t// Offset is line number position which caused the error. Note that this value is 1-based.\n\tLine int\n\t// Column is column number position which caused the error. Note that this value is 1-based.\n\tColumn int\n}\n\nfunc (e *ExprError) Error() string {\n\treturn fmt.Sprintf(\"%d:%d:%d: %s\", e.Line, e.Column, e.Offset, e.Message)\n}\n\nfunc (e *ExprError) String() string {\n\treturn e.Error()\n}\n"
        },
        {
          "name": "expr_ast.go",
          "type": "blob",
          "size": 8.306640625,
          "content": "package actionlint\n\n// ExprNode is a node of expression syntax tree. To know the syntax, see\n// https://docs.github.com/en/actions/learn-github-actions/expressions\ntype ExprNode interface {\n\t// Token returns the first token of the node. This method is useful to get position of this node.\n\tToken() *Token\n}\n\n// Variable\n\n// VariableNode is node for variable access.\ntype VariableNode struct {\n\t// Name is name of the variable\n\tName string\n\ttok  *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *VariableNode) Token() *Token {\n\treturn n.tok\n}\n\n// Literals\n\n// NullNode is node for null literal.\ntype NullNode struct {\n\ttok *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *NullNode) Token() *Token {\n\treturn n.tok\n}\n\n// BoolNode is node for boolean literal, true or false.\ntype BoolNode struct {\n\t// Value is value of the boolean literal.\n\tValue bool\n\ttok   *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *BoolNode) Token() *Token {\n\treturn n.tok\n}\n\n// IntNode is node for integer literal.\ntype IntNode struct {\n\t// Value is value of the integer literal.\n\tValue int\n\ttok   *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *IntNode) Token() *Token {\n\treturn n.tok\n}\n\n// FloatNode is node for float literal.\ntype FloatNode struct {\n\t// Value is value of the float literal.\n\tValue float64\n\ttok   *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *FloatNode) Token() *Token {\n\treturn n.tok\n}\n\n// StringNode is node for string literal.\ntype StringNode struct {\n\t// Value is value of the string literal. Escapes are resolved and quotes at both edges are\n\t// removed.\n\tValue string\n\ttok   *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *StringNode) Token() *Token {\n\treturn n.tok\n}\n\n// Operators\n\n// ObjectDerefNode represents property dereference of object like 'foo.bar'.\ntype ObjectDerefNode struct {\n\t// Receiver is an expression at receiver of property dereference.\n\tReceiver ExprNode\n\t// Property is a name of property to access.\n\tProperty string\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n ObjectDerefNode) Token() *Token {\n\treturn n.Receiver.Token()\n}\n\n// ArrayDerefNode represents elements dereference of arrays like '*' in 'foo.bar.*.piyo'.\ntype ArrayDerefNode struct {\n\t// Receiver is an expression at receiver of array element dereference.\n\tReceiver ExprNode\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n ArrayDerefNode) Token() *Token {\n\treturn n.Receiver.Token()\n}\n\n// IndexAccessNode is node for index access, which represents dynamic object property access or\n// array index access.\ntype IndexAccessNode struct {\n\t// Operand is an expression at operand of index access, which should be array or object.\n\tOperand ExprNode\n\t// Index is an expression at index, which should be integer or string.\n\tIndex ExprNode\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *IndexAccessNode) Token() *Token {\n\treturn n.Operand.Token()\n}\n\n// Note: Currently only ! is a logical unary operator\n\n// NotOpNode is node for unary ! operator.\ntype NotOpNode struct {\n\t// Operand is an expression at operand of ! operator.\n\tOperand ExprNode\n\ttok     *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *NotOpNode) Token() *Token {\n\treturn n.tok\n}\n\n// CompareOpNodeKind is a kind of compare operators; ==, !=, <, <=, >, >=.\ntype CompareOpNodeKind int\n\nconst (\n\t// CompareOpNodeKindInvalid is invalid and initial value of CompareOpNodeKind values.\n\tCompareOpNodeKindInvalid CompareOpNodeKind = iota\n\t// CompareOpNodeKindLess is kind for < operator.\n\tCompareOpNodeKindLess\n\t// CompareOpNodeKindLessEq is kind for <= operator.\n\tCompareOpNodeKindLessEq\n\t// CompareOpNodeKindGreater is kind for > operator.\n\tCompareOpNodeKindGreater\n\t// CompareOpNodeKindGreaterEq is kind for >= operator.\n\tCompareOpNodeKindGreaterEq\n\t// CompareOpNodeKindEq is kind for == operator.\n\tCompareOpNodeKindEq\n\t// CompareOpNodeKindNotEq is kind for != operator.\n\tCompareOpNodeKindNotEq\n)\n\n// IsEqualityOp returns true when it represents == or != operator.\nfunc (kind CompareOpNodeKind) IsEqualityOp() bool {\n\treturn kind == CompareOpNodeKindEq || kind == CompareOpNodeKindNotEq\n}\n\nfunc (kind CompareOpNodeKind) String() string {\n\tswitch kind {\n\tcase CompareOpNodeKindLess:\n\t\treturn \"<\"\n\tcase CompareOpNodeKindLessEq:\n\t\treturn \"<=\"\n\tcase CompareOpNodeKindGreater:\n\t\treturn \">\"\n\tcase CompareOpNodeKindGreaterEq:\n\t\treturn \">=\"\n\tcase CompareOpNodeKindEq:\n\t\treturn \"==\"\n\tcase CompareOpNodeKindNotEq:\n\t\treturn \"!=\"\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n\n// CompareOpNode is node for binary expression to compare values; ==, !=, <, <=, > or >=.\ntype CompareOpNode struct {\n\t// Kind is a kind of this expression to show which operator is used.\n\tKind CompareOpNodeKind\n\t// Left is an expression for left hand side of the binary operator.\n\tLeft ExprNode\n\t// Right is an expression for right hand side of the binary operator.\n\tRight ExprNode\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *CompareOpNode) Token() *Token {\n\treturn n.Left.Token()\n}\n\n// LogicalOpNodeKind is a kind of logical operators; && and ||.\ntype LogicalOpNodeKind int\n\nconst (\n\t// LogicalOpNodeKindInvalid is an invalid and initial value of LogicalOpNodeKind.\n\tLogicalOpNodeKindInvalid LogicalOpNodeKind = iota\n\t// LogicalOpNodeKindAnd is a kind for && operator.\n\tLogicalOpNodeKindAnd\n\t// LogicalOpNodeKindOr is a kind for || operator.\n\tLogicalOpNodeKindOr\n)\n\nfunc (k LogicalOpNodeKind) String() string {\n\tswitch k {\n\tcase LogicalOpNodeKindAnd:\n\t\treturn \"&&\"\n\tcase LogicalOpNodeKindOr:\n\t\treturn \"||\"\n\tdefault:\n\t\treturn \"INVALID LOGICAL OPERATOR\"\n\t}\n}\n\n// LogicalOpNode is node for logical binary operators; && or ||.\ntype LogicalOpNode struct {\n\t// Kind is a kind to show which operator is used.\n\tKind LogicalOpNodeKind\n\t// Left is an expression for left hand side of the binary operator.\n\tLeft ExprNode\n\t// Right is an expression for right hand side of the binary operator.\n\tRight ExprNode\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *LogicalOpNode) Token() *Token {\n\treturn n.Left.Token()\n}\n\n// FuncCallNode represents function call in expression.\n// Note that currently only calling builtin functions is supported.\ntype FuncCallNode struct {\n\t// Callee is a name of called function. This is string value because currently only built-in\n\t// functions can be called.\n\tCallee string\n\t// Args is arguments of the function call.\n\tArgs []ExprNode\n\ttok  *Token\n}\n\n// Token returns the first token of the node. This method is useful to get position of this node.\nfunc (n *FuncCallNode) Token() *Token {\n\treturn n.tok\n}\n\n// VisitExprNodeFunc is a visitor function for VisitExprNode(). The entering argument is set to\n// true when it is called before visiting children. It is set to false when it is called after\n// visiting children. It means that this function is called twice for the same node. The parent\n// argument is the parent of the node. When the node is root, its parent is nil.\ntype VisitExprNodeFunc func(node, parent ExprNode, entering bool)\n\nfunc visitExprNode(n, p ExprNode, f VisitExprNodeFunc) {\n\tf(n, p, true)\n\tswitch n := n.(type) {\n\tcase *ObjectDerefNode:\n\t\tvisitExprNode(n.Receiver, n, f)\n\tcase *ArrayDerefNode:\n\t\tvisitExprNode(n.Receiver, n, f)\n\tcase *IndexAccessNode:\n\t\t// Index must be visited before Operand to make UntrustedInputChecker work correctly.\n\t\tvisitExprNode(n.Index, n, f)\n\t\tvisitExprNode(n.Operand, n, f)\n\tcase *NotOpNode:\n\t\tvisitExprNode(n.Operand, n, f)\n\tcase *CompareOpNode:\n\t\tvisitExprNode(n.Left, n, f)\n\t\tvisitExprNode(n.Right, n, f)\n\tcase *LogicalOpNode:\n\t\tvisitExprNode(n.Left, n, f)\n\t\tvisitExprNode(n.Right, n, f)\n\tcase *FuncCallNode:\n\t\tfor _, a := range n.Args {\n\t\t\tvisitExprNode(a, n, f)\n\t\t}\n\t}\n\tf(n, p, false)\n}\n\n// VisitExprNode visits the given expression syntax tree with given function f.\nfunc VisitExprNode(n ExprNode, f VisitExprNodeFunc) {\n\tvisitExprNode(n, nil, f)\n}\n"
        },
        {
          "name": "expr_insecure.go",
          "type": "blob",
          "size": 9.7294921875,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n)\n\nfunc isSafeFuncCall(call *FuncCallNode) bool {\n\tc := strings.ToLower(call.Callee)\n\treturn c == \"contains\" || c == \"startswith\" || c == \"endswith\"\n}\n\n// UntrustedInputMap is a recursive map to match context object property dereferences.\n// Root of this map represents each context names and their ancestors represent recursive properties.\ntype UntrustedInputMap struct {\n\tName     string\n\tParent   *UntrustedInputMap\n\tChildren map[string]*UntrustedInputMap\n}\n\nfunc (m *UntrustedInputMap) String() string {\n\tvar b strings.Builder\n\tm.buildPath(&b)\n\treturn b.String()\n}\n\n// Find child object property in this map\nfunc (m *UntrustedInputMap) findObjectProp(name string) (*UntrustedInputMap, bool) {\n\tif m != nil && m.Children != nil {\n\t\tif c, ok := m.Children[name]; ok {\n\t\t\treturn c, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\n// Find child array element in this map. This is special case with object filter where its receiver is an array\nfunc (m *UntrustedInputMap) findArrayElem() (*UntrustedInputMap, bool) {\n\treturn m.findObjectProp(\"*\")\n}\n\n// Build path like `github.event.commits.*.body` by following parents\nfunc (m *UntrustedInputMap) buildPath(b *strings.Builder) {\n\tif m.Parent != nil && m.Parent.Name != \"\" {\n\t\tm.Parent.buildPath(b)\n\t\tb.WriteRune('.')\n\t}\n\tb.WriteString(m.Name)\n}\n\n// NewUntrustedInputMap creates new instance of UntrustedInputMap. It is used for node of search\n// tree of untrusted input checker.\nfunc NewUntrustedInputMap(name string, children ...*UntrustedInputMap) *UntrustedInputMap {\n\tm := &UntrustedInputMap{\n\t\tName:     name,\n\t\tParent:   nil,\n\t\tChildren: nil, // Leaf of the tree is nil\n\t}\n\tif len(children) > 0 {\n\t\tm.Children = make(map[string]*UntrustedInputMap, len(children))\n\t\tfor _, c := range children {\n\t\t\tc.Parent = m\n\t\t\tm.Children[c.Name] = c\n\t\t}\n\t}\n\treturn m\n}\n\n// UntrustedInputSearchRoots is a list of untrusted inputs. It forms tree structure to detect\n// untrusted inputs in nested object property access, array index access, and object filters\n// efficiently. Each value of this map represents a root of the search so their names are context\n// names.\ntype UntrustedInputSearchRoots map[string]*UntrustedInputMap\n\n// AddRoot adds a new root to search for detecting untrusted input.\nfunc (ms UntrustedInputSearchRoots) AddRoot(m *UntrustedInputMap) {\n\tms[m.Name] = m\n}\n\n// TODO: Automatically generate BuiltinUntrustedInputs from https://github.com/github/codeql/blob/main/javascript/ql/src/experimental/Security/CWE-094/ExpressionInjection.ql\n\n// BuiltinUntrustedInputs is list of untrusted inputs. These inputs are detected as untrusted in\n// `run:` scripts. See the URL for more details.\n// - https://securitylab.github.com/research/github-actions-untrusted-input/\n// - https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions\n// - https://github.com/github/codeql/blob/main/javascript/ql/src/experimental/Security/CWE-094/ExpressionInjection.ql\nvar BuiltinUntrustedInputs = UntrustedInputSearchRoots{\n\t\"github\": NewUntrustedInputMap(\"github\",\n\t\tNewUntrustedInputMap(\"event\",\n\t\t\tNewUntrustedInputMap(\"issue\",\n\t\t\t\tNewUntrustedInputMap(\"title\"),\n\t\t\t\tNewUntrustedInputMap(\"body\"),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"pull_request\",\n\t\t\t\tNewUntrustedInputMap(\"title\"),\n\t\t\t\tNewUntrustedInputMap(\"body\"),\n\t\t\t\tNewUntrustedInputMap(\"head\",\n\t\t\t\t\tNewUntrustedInputMap(\"ref\"),\n\t\t\t\t\tNewUntrustedInputMap(\"label\"),\n\t\t\t\t\tNewUntrustedInputMap(\"repo\",\n\t\t\t\t\t\tNewUntrustedInputMap(\"default_branch\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"comment\",\n\t\t\t\tNewUntrustedInputMap(\"body\"),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"review\",\n\t\t\t\tNewUntrustedInputMap(\"body\"),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"review_comment\",\n\t\t\t\tNewUntrustedInputMap(\"body\"),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"pages\",\n\t\t\t\tNewUntrustedInputMap(\"*\",\n\t\t\t\t\tNewUntrustedInputMap(\"page_name\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"commits\",\n\t\t\t\tNewUntrustedInputMap(\"*\",\n\t\t\t\t\tNewUntrustedInputMap(\"message\"),\n\t\t\t\t\tNewUntrustedInputMap(\"author\",\n\t\t\t\t\t\tNewUntrustedInputMap(\"email\"),\n\t\t\t\t\t\tNewUntrustedInputMap(\"name\"),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"head_commit\",\n\t\t\t\tNewUntrustedInputMap(\"message\"),\n\t\t\t\tNewUntrustedInputMap(\"author\",\n\t\t\t\t\tNewUntrustedInputMap(\"email\"),\n\t\t\t\t\tNewUntrustedInputMap(\"name\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tNewUntrustedInputMap(\"discussion\",\n\t\t\t\tNewUntrustedInputMap(\"title\"),\n\t\t\t\tNewUntrustedInputMap(\"body\"),\n\t\t\t),\n\t\t),\n\t\tNewUntrustedInputMap(\"head_ref\"),\n\t),\n}\n\n// UntrustedInputChecker is a checker to detect untrusted inputs in an expression syntax tree.\n// This checker checks object property accesses, array index accesses, and object filters. And\n// detects paths to untrusted inputs. Found errors are stored in this instance and can be get via\n// Errs method.\n//\n// Note: To avoid breaking the state of checking property accesses on nested property accesses like\n// foo[aaa.bbb].bar, IndexAccessNode.Index must be visited before IndexAccessNode.Operand.\ntype UntrustedInputChecker struct {\n\troots           UntrustedInputSearchRoots\n\tfilteringObject bool\n\tcur             []*UntrustedInputMap\n\tstart           ExprNode\n\terrs            []*ExprError\n\tsafeCalls       int\n}\n\n// NewUntrustedInputChecker creates a new UntrustedInputChecker instance. The roots argument is a\n// search tree which defines untrusted input paths as trees.\nfunc NewUntrustedInputChecker(roots UntrustedInputSearchRoots) *UntrustedInputChecker {\n\treturn &UntrustedInputChecker{\n\t\troots: roots,\n\t\terrs:  []*ExprError{},\n\t}\n}\n\n// Reset the state for next search\nfunc (u *UntrustedInputChecker) reset() {\n\tu.start = nil\n\tu.filteringObject = false\n\tu.cur = u.cur[:0]\n}\n\nfunc (u *UntrustedInputChecker) compact() {\n\tdelta := 0\n\tfor i, c := range u.cur {\n\t\tif c == nil {\n\t\t\tdelta++\n\t\t\tcontinue\n\t\t}\n\t\tif delta > 0 {\n\t\t\tu.cur[i-delta] = c\n\t\t}\n\t}\n\tu.cur = u.cur[:len(u.cur)-delta]\n}\n\nfunc (u *UntrustedInputChecker) onVar(v *VariableNode) {\n\tc, ok := u.roots[v.Name] // Find root context (currently only \"github\" exists)\n\tif !ok {\n\t\treturn\n\t}\n\tu.start = v\n\tu.cur = append(u.cur, c)\n}\n\nfunc (u *UntrustedInputChecker) onPropAccess(name string) {\n\tcompact := false\n\tfor i, cur := range u.cur {\n\t\tc, ok := cur.findObjectProp(name)\n\t\tif !ok {\n\t\t\tu.cur[i] = nil\n\t\t\tcompact = true\n\t\t\tcontinue\n\t\t}\n\t\tu.cur[i] = c // depth + 1\n\t}\n\tif compact {\n\t\tu.compact()\n\t}\n}\n\nfunc (u *UntrustedInputChecker) onIndexAccess() {\n\tif u.filteringObject {\n\t\tu.filteringObject = false\n\t\treturn // For example, match `github.event.*.body[0]` as `github.event.commits[0].body`\n\t}\n\n\tcompact := false\n\tfor i, cur := range u.cur {\n\t\tif c, ok := cur.findArrayElem(); ok {\n\t\t\tu.cur[i] = c\n\t\t\tcontinue\n\t\t}\n\t\tu.cur[i] = nil\n\t\tcompact = true\n\t}\n\tif compact {\n\t\tu.compact()\n\t}\n}\n\nfunc (u *UntrustedInputChecker) onObjectFilter() {\n\tu.filteringObject = true\n\n\tcompact := false\n\tfor i, cur := range u.cur {\n\t\t// Object filter for arrays\n\t\tif c, ok := cur.findArrayElem(); ok {\n\t\t\tu.cur[i] = c\n\t\t\tcontinue\n\t\t}\n\n\t\tif len(cur.Children) == 0 {\n\t\t\tu.cur[i] = nil\n\t\t\tcompact = true\n\t\t}\n\n\t\t// Object filter for objects\n\t\tfirst := true\n\t\tfor _, c := range cur.Children {\n\t\t\tif first {\n\t\t\t\tu.cur[i] = c\n\t\t\t\tfirst = false\n\t\t\t} else {\n\t\t\t\tu.cur = append(u.cur, c)\n\t\t\t}\n\t\t}\n\t}\n\tif compact {\n\t\tu.compact()\n\t}\n}\n\nfunc (u *UntrustedInputChecker) end() {\n\tvar inputs []string\n\tfor _, cur := range u.cur {\n\t\tif cur.Children != nil {\n\t\t\tcontinue // When `Children` is nil, the node is a leaf\n\t\t}\n\t\tvar b strings.Builder\n\t\tcur.buildPath(&b)\n\t\tinputs = append(inputs, b.String())\n\t}\n\n\tif len(inputs) == 1 {\n\t\terr := errorfAtExpr(\n\t\t\tu.start,\n\t\t\t\"%q is potentially untrusted. avoid using it directly in inline scripts. instead, pass it through an environment variable. see https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions for more details\",\n\t\t\tinputs[0],\n\t\t)\n\t\tu.errs = append(u.errs, err)\n\t} else if len(inputs) > 1 {\n\t\t// When multiple untrusted inputs are detected, it means the expression extracts multiple properties with object\n\t\t// filter syntax. Show all properties in error message.\n\t\terr := errorfAtExpr(\n\t\t\tu.start,\n\t\t\t\"object filter extracts potentially untrusted properties %s. avoid using the value directly in inline scripts. instead, pass the value through an environment variable. see https://docs.github.com/en/actions/security-for-github-actions/security-guides/security-hardening-for-github-actions for more details\",\n\t\t\tsortedQuotes(inputs),\n\t\t)\n\t\tu.errs = append(u.errs, err)\n\t}\n\n\tu.reset()\n}\n\nfunc (u *UntrustedInputChecker) OnVisitNodeEnter(n ExprNode) {\n\tif f, ok := n.(*FuncCallNode); ok && isSafeFuncCall(f) {\n\t\tu.safeCalls++\n\t}\n}\n\n// OnVisitNodeLeave is a callback which should be called on visiting node after visiting its children.\nfunc (u *UntrustedInputChecker) OnVisitNodeLeave(n ExprNode) {\n\t// Skip unsafe checks if we are inside of safe function call expression\n\tif u.safeCalls > 0 {\n\t\tif f, ok := n.(*FuncCallNode); ok && isSafeFuncCall(f) {\n\t\t\tu.safeCalls--\n\t\t}\n\t\treturn\n\t}\n\n\tswitch n := n.(type) {\n\tcase *VariableNode:\n\t\tu.end()\n\t\tu.onVar(n)\n\tcase *ObjectDerefNode:\n\t\tu.onPropAccess(n.Property)\n\tcase *IndexAccessNode:\n\t\tif lit, ok := n.Index.(*StringNode); ok {\n\t\t\t// Special case like github['event']['issue']['title']\n\t\t\tu.onPropAccess(lit.Value)\n\t\t\tbreak\n\t\t}\n\t\tu.onIndexAccess()\n\tcase *ArrayDerefNode:\n\t\tu.onObjectFilter()\n\tdefault:\n\t\tu.end()\n\t}\n}\n\n// OnVisitEnd is a callback which should be called after visiting whole syntax tree. This callback\n// is necessary to handle the case where an untrusted input access is at root of expression.\nfunc (u *UntrustedInputChecker) OnVisitEnd() {\n\tu.end()\n}\n\n// Errs returns errors detected by this checker. This method should be called after visiting all\n// nodes in a syntax tree.\nfunc (u *UntrustedInputChecker) Errs() []*ExprError {\n\treturn u.errs\n}\n\n// Init initializes a state of checker.\nfunc (u *UntrustedInputChecker) Init() {\n\tu.errs = u.errs[:0]\n\tu.safeCalls = 0\n\tu.reset()\n}\n"
        },
        {
          "name": "expr_insecure_test.go",
          "type": "blob",
          "size": 19.1806640625,
          "content": "package actionlint\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// From https://securitylab.github.com/research/github-actions-untrusted-input/\nvar testAllUntrustedInputs = []string{\n\t\"github.event.issue.title\",\n\t\"github.event.issue.body\",\n\t\"github.event.pull_request.title\",\n\t\"github.event.pull_request.body\",\n\t\"github.event.comment.body\",\n\t\"github.event.review.body\",\n\t\"github.event.review_comment.body\",\n\t\"github.event.pages.*.page_name\",\n\t\"github.event.commits.*.message\",\n\t\"github.event.head_commit.message\",\n\t\"github.event.head_commit.author.email\",\n\t\"github.event.head_commit.author.name\",\n\t\"github.event.commits.*.author.email\",\n\t\"github.event.commits.*.author.name\",\n\t\"github.event.pull_request.head.ref\",\n\t\"github.event.pull_request.head.label\",\n\t\"github.event.pull_request.head.repo.default_branch\",\n\t\"github.event.discussion.title\",\n\t\"github.event.discussion.body\",\n\t\"github.head_ref\",\n}\n\nfunc TestExprInsecureBuiltinUntrustedInputs(t *testing.T) {\n\tfor _, input := range testAllUntrustedInputs {\n\t\tcur := BuiltinUntrustedInputs\n\t\tfor _, name := range strings.Split(input, \".\") {\n\t\t\tif m, ok := cur[name]; ok {\n\t\t\t\tcur = m.Children\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif m, ok := cur[\"*\"]; ok {\n\t\t\t\tcur = m.Children\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt.Fatalf(\"%s in %s does not match to builtin untrusted inputs map: %v\", name, input, cur)\n\t\t}\n\t\tif cur != nil {\n\t\t\tt.Fatalf(\"%s does not reach end of builtin untrusted inputs map: %v\", input, cur)\n\t\t}\n\t}\n\n\tre := regexp.MustCompile(`^[a-z_]+$`)\n\tvar rec func(m map[string]*UntrustedInputMap, path []string)\n\trec = func(m map[string]*UntrustedInputMap, path []string) {\n\t\tfor k, v := range m {\n\t\t\tp := append(path, k)\n\t\t\tif k == \"*\" {\n\t\t\t\tif len(m) != 1 {\n\t\t\t\t\tt.Errorf(\"%v has * key but it also has other keys in %v\", k, p)\n\t\t\t\t}\n\t\t\t} else if !re.MatchString(k) {\n\t\t\t\tt.Errorf(\"%v does not match to ^[a-z_]+$ in %v\", k, p)\n\t\t\t}\n\t\t\trec(v.Children, p)\n\t\t}\n\t}\n\n\trec(BuiltinUntrustedInputs, []string{})\n}\n\nfunc testRunTrustedInputsCheckerForNode(t *testing.T, c *UntrustedInputChecker, input string) {\n\tt.Helper()\n\tn, err := NewExprParser().Parse(NewExprLexer(input + \"}}\"))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tVisitExprNode(n, func(n, p ExprNode, entering bool) {\n\t\tif entering {\n\t\t\tc.OnVisitNodeEnter(n)\n\t\t} else {\n\t\t\tc.OnVisitNodeLeave(n)\n\t\t}\n\t})\n\tc.OnVisitEnd()\n\tif c.safeCalls != 0 {\n\t\tt.Fatalf(\"%q safe calls counter is not zero: %d\", input, c.safeCalls)\n\t}\n}\n\nfunc TestExprInsecureDetectUntrustedValue(t *testing.T) {\n\ttype testCase struct {\n\t\tinput string\n\t\twant  []string\n\t}\n\n\ttests := []testCase{}\n\tfor _, input := range testAllUntrustedInputs {\n\t\ttests = append(tests, testCase{input, []string{input}})\n\t\tprops := strings.Split(input, \".\")\n\t\t{\n\t\t\t// github.foo.*.bar -> github['foo'].*['bar']\n\t\t\tvar b strings.Builder\n\t\t\tb.WriteString(props[0])\n\t\t\tfor _, p := range props[1:] {\n\t\t\t\tif p == \"*\" {\n\t\t\t\t\tb.WriteString(\".*\")\n\t\t\t\t} else {\n\t\t\t\t\tb.WriteString(\"['\")\n\t\t\t\t\tb.WriteString(p)\n\t\t\t\t\tb.WriteString(\"']\")\n\t\t\t\t}\n\t\t\t}\n\t\t\ttests = append(tests, testCase{b.String(), []string{input}})\n\t\t}\n\n\t\tif strings.Contains(input, \".*\") {\n\t\t\t// Add both array dereference version and array index access version\n\t\t\ttests = append(tests, testCase{strings.ReplaceAll(input, \".*\", \"[0]\"), []string{input}})\n\t\t\t{\n\t\t\t\t// github.foo.*.bar -> github['foo'][0]['bar']\n\t\t\t\tvar b strings.Builder\n\t\t\t\tb.WriteString(props[0])\n\t\t\t\tfor _, p := range props[1:] {\n\t\t\t\t\tif p == \"*\" {\n\t\t\t\t\t\tb.WriteString(\"[0]\")\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb.WriteString(\"['\")\n\t\t\t\t\t\tb.WriteString(p)\n\t\t\t\t\t\tb.WriteString(\"']\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttests = append(tests, testCase{b.String(), []string{input}})\n\t\t\t}\n\t\t}\n\t}\n\n\ttests = append(tests,\n\t\ttestCase{\n\t\t\t\"github.event.issue.body || github.event.issue.title\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.body\",\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"matrix.foo[github.event.issue.title].bar[github.event.issue.body]\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.body\",\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.pages[github.event.issue.title].page_name\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.pages[foo[github.event.issue.title]].page_name\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.issue.body[github.event.issue.title][github.head_ref]\",\n\t\t\t[]string{\n\t\t\t\t\"github.head_ref\",\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.pages[format('0')].page_name\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.pages[matrix.page_num].page_name\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.pages[github.event.commits[github.event.issue.title].author.name].page_name\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t\t\"github.event.commits.*.author.name\",\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.pages[format('{0}', github.event.issue.title)].page_name\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"format('{0} {1}', github.event.pages.*.page_name, github.event.issue.title)\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.pages.*.page_name\",\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"format('{0} {1}', github.event.*.body, github.event.*.*)\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.\",\n\t\t\t\t\"github.event.\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"contains(github.event.issue.body, 'foo') || github.event.issue.title\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"github.event.issue.title && contains(github.event.issue.body, 'foo')\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t\ttestCase{\n\t\t\t\"format('{0}{1}{2}', github.event.issue.title, contains(github.event.issue.body, 'foo'), github.event.issue.title)\",\n\t\t\t[]string{\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t\t\"github.event.issue.title\",\n\t\t\t},\n\t\t},\n\t)\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t\t\ttestRunTrustedInputsCheckerForNode(t, c, tc.input)\n\t\t\terrs := c.Errs()\n\t\t\tif len(tc.want) != len(errs) {\n\t\t\t\tt.Fatalf(\"wanted %d error(s) but got %d error(s): %v\", len(tc.want), len(errs), errs)\n\t\t\t}\n\t\t\tfor i, err := range errs {\n\t\t\t\twant := tc.want[i]\n\t\t\t\tif !strings.Contains(err.Message, want) {\n\t\t\t\t\tt.Errorf(\"%q is not contained in error message: %v\", want, err)\n\t\t\t\t}\n\t\t\t\tif err.Line != 1 {\n\t\t\t\t\tt.Error(\"line should be 1 but got\", err.Line)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprInsecureAllUntrustedValuesAtOnce(t *testing.T) {\n\targs := make([]string, 0, len(testAllUntrustedInputs))\n\tfor _, i := range testAllUntrustedInputs {\n\t\targs = append(args, i)\n\t\tif strings.Contains(i, \".*\") {\n\t\t\targs = append(args, strings.ReplaceAll(i, \".*\", \"[0]\")) // also add index access version\n\t\t}\n\t}\n\t// Generate function call with all untrusted inputs as its arguments\n\texpr := \"someFunc(\" + strings.Join(args, \", \") + \")\"\n\n\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\ttestRunTrustedInputsCheckerForNode(t, c, expr)\n\terrs := c.Errs()\n\n\tif len(errs) != len(args) {\n\t\tt.Fatalf(\"# of args %d v.s. # of errs %d. errs: %v\", len(args), len(errs), errs)\n\t}\n\n\tcol := 0\n\tfor i, err := range errs {\n\t\targ := args[i]\n\t\tif !strings.Contains(arg, \"[0]\") && !strings.Contains(err.Message, arg) {\n\t\t\tt.Errorf(\"%q is not contained in error: %v\", arg, err)\n\t\t}\n\t\tif err.Line != 1 {\n\t\t\tt.Error(\"line should be 1 but got\", err.Line)\n\t\t}\n\t\tif err.Column <= col {\n\t\t\tt.Errorf(\"column should be greater than %d but got %d\", col, err.Column)\n\t\t}\n\t\tcol = err.Column\n\t}\n}\n\nfunc TestExprInsecureInitState(t *testing.T) {\n\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\ttestRunTrustedInputsCheckerForNode(t, c, \"github.event.issue.title\")\n\tif len(c.Errs()) == 0 {\n\t\tt.Fatal(\"no error occurred\")\n\t}\n\n\tc.Init()\n\tif len(c.Errs()) != 0 {\n\t\tt.Fatal(c.Errs())\n\t}\n\n\ttestRunTrustedInputsCheckerForNode(t, c, \"github.event.issue.title\")\n\tif len(c.Errs()) == 0 {\n\t\tt.Fatal(\"no error occurred\")\n\t}\n}\n\nfunc TestExprInsecureNoUntrustedValue(t *testing.T) {\n\tinputs := []string{\n\t\t\"0\",\n\t\t\"true\",\n\t\t\"null\",\n\t\t\"'github.event.issue.title'\",\n\t\t\"matrix.foo\",\n\t\t\"matrix.github.event.issue.title\",\n\t\t\"matrix.event.issue.title\",\n\t\t\"github\",\n\t\t\"github.event\",\n\t\t\"github.event.issue\",\n\t\t\"github.event.commits.foo.message\",\n\t\t\"github.event.commits[0]\",\n\t\t\"github.event.commits.*\",\n\t\t\"github.event.commits.*.foo\",\n\t\t\"github.event.foo.body\",\n\t\t\"github[x].issue.title\",\n\t\t\"github.event[foo].title\",\n\t\t\"github.event.issue[0].title\",\n\t\t\"foo(github.event, pull_request.body)\",\n\t\t\"foo(github.event, github.pull_request.body)\",\n\t\t\"foo(github.event, bar().pull_request.body)\",\n\t\t\"github.event[pull_request.body]\",\n\t\t\"github[event.pull_request].body\",\n\t\t\"github[github.event.pull_request].body\",\n\t\t\"matrix.foo[github.event.pages].page_name\",\n\t\t\"github.event.issue.body.foo.bar\",\n\t\t\"github.event.issue.body[0]\",\n\t\t\"contains(github.event.issue.body, github.event.issue.title)\",\n\t\t\"startsWith(github.event.comment.body, 'LGTM')\",\n\t\t\"endsWith(github.event.pull_request.title, github.event.issue.title)\",\n\t\t\"contains(contains(github.event.issue.body, github.event.issue.title), github.event.issue.title)\", // safe -> safe\n\t\t\"contains(fromJSON(github.event.issue.body), github.event.issue.title)\",                           // safe -> unsafe\n\t\t\"fromJSON(contains(github.event.issue.body, github.event.issue.title))\",                           // unsafe -> safe\n\t}\n\n\tfor _, input := range inputs {\n\t\tt.Run(input, func(t *testing.T) {\n\t\t\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t\t\ttestRunTrustedInputsCheckerForNode(t, c, input)\n\t\t\tif errs := c.Errs(); len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"%q caused %d error(s): %v\", input, len(errs), errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprInsecureCustomizedUntrustedInputMapping(t *testing.T) {\n\ttestCases := []struct {\n\t\tmapping *UntrustedInputMap\n\t\tinput   string\n\t\twant    string\n\t}{\n\t\t{\n\t\t\tmapping: NewUntrustedInputMap(\"foo\"),\n\t\t\tinput:   \"foo\",\n\t\t\twant:    `\"foo\"`,\n\t\t},\n\t\t{\n\t\t\tmapping: NewUntrustedInputMap(\"foo\",\n\t\t\t\tNewUntrustedInputMap(\"bar\",\n\t\t\t\t\tNewUntrustedInputMap(\"piyo\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinput: \"foo.bar.piyo\",\n\t\t\twant:  `\"foo.bar.piyo\"`,\n\t\t},\n\t\t{\n\t\t\tmapping: NewUntrustedInputMap(\"github\",\n\t\t\t\tNewUntrustedInputMap(\"foo\",\n\t\t\t\t\tNewUntrustedInputMap(\"*\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinput: \"github.foo[0]\",\n\t\t\twant:  `\"github.foo.*\"`,\n\t\t},\n\t\t{\n\t\t\tmapping: NewUntrustedInputMap(\"github\",\n\t\t\t\tNewUntrustedInputMap(\"foo\",\n\t\t\t\t\tNewUntrustedInputMap(\"*\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinput: \"github.foo.*\",\n\t\t\twant:  `\"github.foo.*\"`,\n\t\t},\n\t\t{\n\t\t\tmapping: NewUntrustedInputMap(\"foo\",\n\t\t\t\tNewUntrustedInputMap(\"bar\",\n\t\t\t\t\tNewUntrustedInputMap(\"piyo\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinput: \"foo.*.piyo\",\n\t\t\twant:  `\"foo.bar.piyo\"`,\n\t\t},\n\t\t{\n\t\t\tmapping: NewUntrustedInputMap(\"foo\",\n\t\t\t\tNewUntrustedInputMap(\"bar\",\n\t\t\t\t\tNewUntrustedInputMap(\"piyo\"),\n\t\t\t\t),\n\t\t\t),\n\t\t\tinput: \"foo.*.piyo[0]\",\n\t\t\twant:  `\"foo.bar.piyo\"`,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\troots := UntrustedInputSearchRoots{}\n\t\t\troots.AddRoot(tc.mapping)\n\t\t\tc := NewUntrustedInputChecker(roots)\n\t\t\ttestRunTrustedInputsCheckerForNode(t, c, tc.input)\n\t\t\terrs := c.Errs()\n\t\t\tif len(errs) != 1 {\n\t\t\t\tt.Fatalf(\"1 error was wanted but got %d error(s)\", len(errs))\n\t\t\t}\n\t\t\terr := errs[0]\n\t\t\tif !strings.Contains(err.Error(), tc.want) {\n\t\t\t\tt.Fatalf(\"%q was wanted to be contained in error message %q\", tc.want, err.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprInsecureDetectUntrustedObjectFiltering(t *testing.T) {\n\ttests := []struct {\n\t\tinput    string\n\t\tdetected []string\n\t}{\n\t\t{\n\t\t\tinput: \"github.event.*.body\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.issue.body\",\n\t\t\t\t\"github.event.comment.body\",\n\t\t\t\t\"github.event.review.body\",\n\t\t\t\t\"github.event.review_comment.body\",\n\t\t\t\t\"github.event.pull_request.body\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.body[0]\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.issue.body\",\n\t\t\t\t\"github.event.comment.body\",\n\t\t\t\t\"github.event.review.body\",\n\t\t\t\t\"github.event.review_comment.body\",\n\t\t\t\t\"github.event.pull_request.body\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.*.email\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.*.email[0]\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github['event'].*.body\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.issue.body\",\n\t\t\t\t\"github.event.comment.body\",\n\t\t\t\t\"github.event.review.body\",\n\t\t\t\t\"github.event.review_comment.body\",\n\t\t\t\t\"github.event.pull_request.body\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.*['email']\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.*['email'][0]\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.author.email\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*['author']['email']\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.*.message\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.commits.*.message\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.event.*.*.*\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.commits.*.message\",\n\t\t\t\t\"github.event.head_commit.author.email\",\n\t\t\t\t\"github.event.head_commit.author.name\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.*\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.head_ref\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.*[0]\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.head_ref\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.*.*.body\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.issue.body\",\n\t\t\t\t\"github.event.comment.body\",\n\t\t\t\t\"github.event.review.body\",\n\t\t\t\t\"github.event.review_comment.body\",\n\t\t\t\t\"github.event.pull_request.body\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tinput: \"github.*.commits.*.message\",\n\t\t\tdetected: []string{\n\t\t\t\t\"github.event.commits.*.message\", // Second .* is for array\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t\t\ttestRunTrustedInputsCheckerForNode(t, c, tc.input)\n\t\t\terrs := c.Errs()\n\t\t\tif len(errs) != 1 {\n\t\t\t\tt.Fatalf(\"wanted 1 error but got %d error(s): %v\", len(errs), errs)\n\t\t\t}\n\t\t\tmsg := errs[0].Error()\n\t\t\tfor _, want := range tc.detected {\n\t\t\t\tif !strings.Contains(msg, want) {\n\t\t\t\t\tt.Fatalf(\"error message did not include expected untrusted input %q: %q. input was %q\", want, msg, tc.input)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\t// Check all inputs with one checker\n\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\tfor _, tc := range tests {\n\t\tc.Init()\n\t\ttestRunTrustedInputsCheckerForNode(t, c, tc.input)\n\t\terrs := c.Errs()\n\t\tif len(errs) != 1 {\n\t\t\tt.Fatalf(\"%q: wanted 1 error but got %d error(s): %v\", tc.input, len(errs), errs)\n\t\t}\n\t\tmsg := errs[0].Error()\n\t\tfor _, want := range tc.detected {\n\t\t\tif !strings.Contains(msg, want) {\n\t\t\t\tt.Fatalf(\"error message did not include expected untrusted input %q: %q. input was %q\", want, msg, tc.input)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestExprInsecureNoUntrustedObjectFiltering(t *testing.T) {\n\tinputs := []string{\n\t\t\"github.*.foo\",\n\t\t\"github.*['foo']\",\n\t\t\"github.event.*.body.foo\",\n\t\t\"github.event.*.body.*\", // `['aaa', 'bbb'].*` is `[]`\n\t\t\"github.*.*.foo\",\n\t\t\"github.*.commits.*.foo\",\n\t\t\"github.*['commits'].*.foo\",\n\t\t\"github.*.commits.*.message.foo\",\n\t\t\"a.*\",\n\t}\n\n\tfor _, input := range inputs {\n\t\tt.Run(input, func(t *testing.T) {\n\t\t\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t\t\ttestRunTrustedInputsCheckerForNode(t, c, input)\n\t\t\terrs := c.Errs()\n\t\t\tif len(errs) != 0 {\n\t\t\t\tt.Fatalf(\"unexpected %d error(s): %v\", len(errs), errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkInsecureDetectUntrustedInputs(b *testing.B) {\n\tparseNodes := func(exprs []string) []ExprNode {\n\t\tns := make([]ExprNode, 0, len(exprs))\n\t\tp := NewExprParser()\n\t\tfor _, e := range exprs {\n\t\t\tn, err := p.Parse(NewExprLexer(e + \"}}\"))\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\tns = append(ns, n)\n\t\t}\n\t\treturn ns\n\t}\n\n\tuntrustedExprs := []string{\n\t\t\"github.event.issue.title\",\n\t\t\"github.event.issue.body\",\n\t\t\"github.event.pull_request.title\",\n\t\t\"github.event.pull_request.body\",\n\t\t\"github.event.comment.body\",\n\t\t\"github.event.review.body\",\n\t\t\"github.event.review_comment.body\",\n\t\t\"github.event.pages.*.page_name\",\n\t\t\"github.event.commits.*.message\",\n\t\t\"github.event.head_commit.message\",\n\t\t\"github.event.head_commit.author.email\",\n\t\t\"github.event.head_commit.author.name\",\n\t\t\"github.event.commits.*.author.email\",\n\t\t\"github.event.commits.*.author.name\",\n\t\t\"github.event.pull_request.head.ref\",\n\t\t\"github.event.pull_request.head.label\",\n\t\t\"github.event.pull_request.head.repo.default_branch\",\n\t\t\"github.event.discussion.title\",\n\t\t\"github.event.discussion.body\",\n\t\t\"github.head_ref\",\n\t\t\"github.event.issue.body || github.event.issue.title\",\n\t\t\"matrix.foo[github.event.issue.title].bar[github.event.issue.body]\",\n\t\t\"github.event.pages[github.event.issue.title].page_name\",\n\t\t\"github.event.pages[foo[github.event.issue.title]].page_name\",\n\t\t\"github.event.issue.body[github.event.issue.title][github.head_ref]\",\n\t\t\"github.event.pages[format('0')].page_name\",\n\t\t\"github.event.pages[matrix.page_num].page_name\",\n\t\t\"github.event.pages[github.event.commits[github.event.issue.title].author.name].page_name\",\n\t\t\"github.event.pages[format('{0}', github.event.issue.title)].page_name\",\n\t\t\"contains(github.event.pages.*.page_name, github.event.issue.title)\",\n\t\t\"github.event.*.body\",\n\t\t\"github.event.*.body[0]\",\n\t\t\"github.event.*.*.email\",\n\t\t\"github.event.*.*.email[0]\",\n\t\t\"github.event.*.author.email\",\n\t\t\"github.event.*.*\",\n\t\t\"github.*\",\n\t\t\"github.*.*.body\",\n\t\t\"github.*.commits.*.message\",\n\t}\n\tuntrustedNodes := parseNodes(untrustedExprs)\n\n\tb.Run(\"UntrustedInput\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t\t\tfor j, n := range untrustedNodes {\n\t\t\t\tc.Init()\n\t\t\t\tVisitExprNode(n, func(n, p ExprNode, entering bool) {\n\t\t\t\t\tif !entering {\n\t\t\t\t\t\tc.OnVisitNodeLeave(n)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tc.OnVisitEnd()\n\t\t\t\terrs := c.Errs()\n\t\t\t\tif len(errs) == 0 {\n\t\t\t\t\tb.Fatalf(\"no error detected: %q\", untrustedExprs[j])\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\ttrustedExprs := []string{\n\t\t\"0\",\n\t\t\"true\",\n\t\t\"null\",\n\t\t\"'github.event.issue.title'\",\n\t\t\"matrix.foo\",\n\t\t\"matrix.github.event.issue.title\",\n\t\t\"matrix.event.issue.title\",\n\t\t\"github\",\n\t\t\"github.event.issue\",\n\t\t\"github.event.commits.foo.message\",\n\t\t\"github.event.commits[0]\",\n\t\t\"github.event.commits.*\",\n\t\t\"github.event.commits.*.foo\",\n\t\t\"github.event.foo.body\",\n\t\t\"github[x].issue.title\",\n\t\t\"github.event[foo].title\",\n\t\t\"github.event.issue[0].title\",\n\t\t\"foo(github.event, pull_request.body)\",\n\t\t\"foo(github.event, github.pull_request.body)\",\n\t\t\"foo(github.event, bar().pull_request.body)\",\n\t\t\"github.event[pull_request.body]\",\n\t\t\"github[event.pull_request].body\",\n\t\t\"github[github.event.pull_request].body\",\n\t\t\"matrix.foo[github.event.pages].page_name\",\n\t\t\"github.event.issue.body.foo.bar\",\n\t\t\"github.event.issue.body[0]\",\n\t\t\"github.*.foo\",\n\t\t\"github.event.*.body.foo\",\n\t\t\"github.event.*.body.*\",\n\t\t\"github.*.*.foo\",\n\t\t\"github.*.commits.*.foo\",\n\t\t\"github.*.commits.*.message.foo\",\n\t\t\"a.*\",\n\t}\n\ttrustedNodes := parseNodes(trustedExprs)\n\n\tb.Run(\"NoUntrustedInput\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tc := NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t\t\tfor j, n := range trustedNodes {\n\t\t\t\tc.Init()\n\t\t\t\tVisitExprNode(n, func(n, p ExprNode, entering bool) {\n\t\t\t\t\tif !entering {\n\t\t\t\t\t\tc.OnVisitNodeLeave(n)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tc.OnVisitEnd()\n\t\t\t\terrs := c.Errs()\n\t\t\t\tif len(errs) != 0 {\n\t\t\t\t\tb.Fatalf(\"error detected: %q: %v\", trustedExprs[j], errs)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "expr_lexer.go",
          "type": "blob",
          "size": 11.7548828125,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"text/scanner\"\n)\n\n// TokenKind is kind of token.\ntype TokenKind int\n\nconst (\n\t// TokenKindUnknown is a default value of token as unknown token value.\n\tTokenKindUnknown TokenKind = iota\n\t// TokenKindEnd is a token for end of token sequence. Sequence without this\n\t// token means invalid.\n\tTokenKindEnd\n\t// TokenKindIdent is a token for identifier.\n\tTokenKindIdent\n\t// TokenKindString is a token for string literals.\n\tTokenKindString\n\t// TokenKindInt is a token for integers including hex integers.\n\tTokenKindInt\n\t// TokenKindFloat is a token for float numbers.\n\tTokenKindFloat\n\t// TokenKindLeftParen is a token for '('.\n\tTokenKindLeftParen\n\t// TokenKindRightParen is a token for ')'.\n\tTokenKindRightParen\n\t// TokenKindLeftBracket is a token for '['.\n\tTokenKindLeftBracket\n\t// TokenKindRightBracket is a token for ']'.\n\tTokenKindRightBracket\n\t// TokenKindDot is a token for '.'.\n\tTokenKindDot\n\t// TokenKindNot is a token for '!'.\n\tTokenKindNot\n\t// TokenKindLess is a token for '<'.\n\tTokenKindLess\n\t// TokenKindLessEq is a token for '<='.\n\tTokenKindLessEq\n\t// TokenKindGreater is a token for '>'.\n\tTokenKindGreater\n\t// TokenKindGreaterEq is a token for '>='.\n\tTokenKindGreaterEq\n\t// TokenKindEq is a token for '=='.\n\tTokenKindEq\n\t// TokenKindNotEq is a token for '!='.\n\tTokenKindNotEq\n\t// TokenKindAnd is a token for '&&'.\n\tTokenKindAnd\n\t// TokenKindOr is a token for '||'.\n\tTokenKindOr\n\t// TokenKindStar is a token for '*'.\n\tTokenKindStar\n\t// TokenKindComma is a token for ','.\n\tTokenKindComma\n)\n\nfunc (t TokenKind) String() string {\n\tswitch t {\n\tcase TokenKindUnknown:\n\t\treturn \"UNKNOWN\"\n\tcase TokenKindEnd:\n\t\treturn \"END\"\n\tcase TokenKindIdent:\n\t\treturn \"IDENT\"\n\tcase TokenKindString:\n\t\treturn \"STRING\"\n\tcase TokenKindInt:\n\t\treturn \"INTEGER\"\n\tcase TokenKindFloat:\n\t\treturn \"FLOAT\"\n\tcase TokenKindLeftParen:\n\t\treturn \"(\"\n\tcase TokenKindRightParen:\n\t\treturn \")\"\n\tcase TokenKindLeftBracket:\n\t\treturn \"[\"\n\tcase TokenKindRightBracket:\n\t\treturn \"]\"\n\tcase TokenKindDot:\n\t\treturn \".\"\n\tcase TokenKindNot:\n\t\treturn \"!\"\n\tcase TokenKindLess:\n\t\treturn \"<\"\n\tcase TokenKindLessEq:\n\t\treturn \"<=\"\n\tcase TokenKindGreater:\n\t\treturn \">\"\n\tcase TokenKindGreaterEq:\n\t\treturn \">=\"\n\tcase TokenKindEq:\n\t\treturn \"==\"\n\tcase TokenKindNotEq:\n\t\treturn \"!=\"\n\tcase TokenKindAnd:\n\t\treturn \"&&\"\n\tcase TokenKindOr:\n\t\treturn \"||\"\n\tcase TokenKindStar:\n\t\treturn \"*\"\n\tcase TokenKindComma:\n\t\treturn \",\"\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\n// Token is a token lexed from expression syntax. For more details, see\n// https://docs.github.com/en/actions/learn-github-actions/expressions\ntype Token struct {\n\t// Kind is kind of the token.\n\tKind TokenKind\n\t// Value is string representation of the token.\n\tValue string\n\t// Offset is byte offset of token string starting.\n\tOffset int\n\t// Line is line number of start position of the token. Note that this value is 1-based.\n\tLine int\n\t// Column is column number of start position of the token. Note that this value is 1-based.\n\tColumn int\n}\n\nfunc (t *Token) String() string {\n\treturn fmt.Sprintf(\"%s:%d:%d:%d\", t.Kind.String(), t.Line, t.Column, t.Offset)\n}\n\nfunc isWhitespace(r rune) bool {\n\treturn r == ' ' || r == '\\n' || r == '\\r' || r == '\\t'\n}\n\nfunc isAlpha(r rune) bool {\n\treturn 'a' <= r && r <= 'z' || 'A' <= r && r <= 'Z'\n}\n\nfunc isNum(r rune) bool {\n\treturn '0' <= r && r <= '9'\n}\n\nfunc isHexNum(r rune) bool {\n\treturn isNum(r) || 'a' <= r && r <= 'f' || 'A' <= r && r <= 'F'\n}\n\nfunc isAlnum(r rune) bool {\n\treturn isAlpha(r) || isNum(r)\n}\n\nconst expectedPunctChars = \"''', '}', '(', ')', '[', ']', '.', '!', '<', '>', '=', '&', '|', '*', ',', ' '\"\nconst expectedDigitChars = \"'0'..'9'\"\nconst expectedAlphaChars = \"'a'..'z', 'A'..'Z', '_'\"\nconst expectedAllChars = expectedAlphaChars + \", \" + expectedDigitChars + \", \" + expectedPunctChars\n\n// ExprLexer is a struct to lex expression syntax. To know the syntax, see\n// https://docs.github.com/en/actions/learn-github-actions/expressions\ntype ExprLexer struct {\n\tsrc    string\n\tscan   scanner.Scanner\n\tlexErr *ExprError\n\tstart  scanner.Position\n}\n\n// NewExprLexer makes new ExprLexer instance.\nfunc NewExprLexer(src string) *ExprLexer {\n\tl := &ExprLexer{\n\t\tsrc: src,\n\t\tstart: scanner.Position{\n\t\t\tOffset: 0,\n\t\t\tLine:   1,\n\t\t\tColumn: 1,\n\t\t},\n\t}\n\tl.scan.Init(strings.NewReader(src))\n\tl.scan.Error = func(_ *scanner.Scanner, m string) {\n\t\tl.error(fmt.Sprintf(\"scan error while lexing expression: %s\", m))\n\t}\n\treturn l\n}\n\nfunc (lex *ExprLexer) error(msg string) {\n\tif lex.lexErr == nil {\n\t\tp := lex.scan.Pos()\n\t\tlex.lexErr = &ExprError{\n\t\t\tMessage: msg,\n\t\t\tOffset:  p.Offset,\n\t\t\tLine:    p.Line,\n\t\t\tColumn:  p.Column,\n\t\t}\n\t}\n}\n\nfunc (lex *ExprLexer) token(kind TokenKind) *Token {\n\tp := lex.scan.Pos()\n\ts := lex.start\n\tt := &Token{\n\t\tKind:   kind,\n\t\tValue:  lex.src[s.Offset:p.Offset],\n\t\tOffset: s.Offset,\n\t\tLine:   s.Line,\n\t\tColumn: s.Column,\n\t}\n\tlex.start = p\n\treturn t\n}\n\nfunc (lex *ExprLexer) eof() *Token {\n\treturn &Token{\n\t\tKind:   TokenKindEnd,\n\t\tValue:  \"\",\n\t\tOffset: lex.start.Offset,\n\t\tLine:   lex.start.Line,\n\t\tColumn: lex.start.Column,\n\t}\n}\n\nfunc (lex *ExprLexer) eat() rune {\n\tlex.scan.Next()\n\treturn lex.scan.Peek() // unlike lex.scan.Next(), return top char *after* eating\n}\n\nfunc (lex *ExprLexer) skipWhite() {\n\tfor {\n\t\tif r := lex.scan.Peek(); !isWhitespace(r) {\n\t\t\treturn\n\t\t}\n\t\tlex.scan.Next()\n\t\tlex.start = lex.scan.Pos()\n\t}\n}\n\nfunc (lex *ExprLexer) unexpected(r rune, where string, expected string) *Token {\n\tvar what string\n\tif r == scanner.EOF {\n\t\twhat = \"EOF\"\n\t} else {\n\t\twhat = \"character \" + strconv.QuoteRune(r)\n\t}\n\n\tvar note string\n\tif r == '\"' {\n\t\tnote = \". do you mean string literals? only single quotes are available for string delimiter\"\n\t}\n\n\tmsg := fmt.Sprintf(\n\t\t\"got unexpected %s while lexing %s, expecting %s%s\",\n\t\twhat,\n\t\twhere,\n\t\texpected,\n\t\tnote,\n\t)\n\n\tlex.error(msg)\n\treturn lex.eof()\n}\n\nfunc (lex *ExprLexer) unexpectedEOF() *Token {\n\tlex.error(\"unexpected EOF while lexing expression\")\n\treturn lex.eof()\n}\n\nfunc (lex *ExprLexer) lexIdent() *Token {\n\tfor {\n\t\t// a-z, A-Z, 0-9, - or _\n\t\t// https://docs.github.com/en/actions/learn-github-actions/contexts\n\t\tif r := lex.eat(); !isAlnum(r) && r != '_' && r != '-' {\n\t\t\treturn lex.token(TokenKindIdent)\n\t\t}\n\t}\n}\n\nfunc (lex *ExprLexer) lexNum() *Token {\n\t// The official document says number literals are 'Any number format supported by JSON' but actually\n\t// hex numbers starting with 0x are supported.\n\n\tr := lex.scan.Peek() // precond: r is digit or '-'\n\n\tif r == '-' {\n\t\tr = lex.eat()\n\t}\n\n\tif r == '0' {\n\t\tr = lex.eat()\n\t\tif r == 'x' {\n\t\t\tlex.scan.Next()\n\t\t\treturn lex.lexHexInt()\n\t\t}\n\t} else {\n\t\t// r is 1..9\n\t\tif !isNum(r) {\n\t\t\treturn lex.unexpected(r, \"integer part of number\", expectedDigitChars)\n\t\t}\n\t\tfor {\n\t\t\tr = lex.eat()\n\t\t\tif !isNum(r) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tk := TokenKindInt\n\n\tif r == '.' {\n\t\tr = lex.eat() // eat '.'\n\t\tif !isNum(r) {\n\t\t\treturn lex.unexpected(r, \"fraction part of float number\", expectedDigitChars)\n\t\t}\n\n\t\tfor {\n\t\t\tr = lex.eat()\n\t\t\tif !isNum(r) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tk = TokenKindFloat\n\t}\n\n\tif r == 'e' || r == 'E' {\n\t\tr = lex.eat() // eat 'e' or 'E'\n\t\tif r == '-' {\n\t\t\tr = lex.eat()\n\t\t}\n\n\t\tif r == '0' {\n\t\t\tr = lex.eat() // eat the '0'\n\t\t} else {\n\t\t\t// r is 1..9\n\t\t\tif !isNum(r) {\n\t\t\t\treturn lex.unexpected(r, \"exponent part of float number\", expectedDigitChars)\n\t\t\t}\n\t\t\tfor {\n\t\t\t\tr = lex.eat()\n\t\t\t\tif !isNum(r) {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tk = TokenKindFloat\n\t}\n\n\tif isAlnum(r) {\n\t\ts := lex.src[lex.start.Offset:lex.scan.Pos().Offset]\n\t\treturn lex.unexpected(r, \"character following number \"+s, expectedPunctChars)\n\t}\n\n\treturn lex.token(k)\n}\n\nfunc (lex *ExprLexer) lexHexInt() *Token {\n\tr := lex.scan.Peek()\n\n\tif r == '0' {\n\t\tr = lex.eat()\n\t} else {\n\t\tif !isHexNum(r) {\n\t\t\te := expectedDigitChars + \", 'a'..'f', 'A'..'F'\"\n\t\t\treturn lex.unexpected(r, \"hex integer\", e)\n\t\t}\n\t\tfor {\n\t\t\tr = lex.eat()\n\t\t\tif !isHexNum(r) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Note: GitHub Actions does not support exponent part like 0x1f2p-a8\n\n\tif isAlnum(r) {\n\t\ts := lex.src[lex.start.Offset:lex.scan.Pos().Offset]\n\t\treturn lex.unexpected(r, \"character following hex integer \"+s, expectedPunctChars)\n\t}\n\n\treturn lex.token(TokenKindInt)\n}\n\nfunc (lex *ExprLexer) lexString() *Token {\n\t// precond: current char is '\n\tfor {\n\t\tswitch lex.eat() {\n\t\tcase '\\'':\n\t\t\tif lex.eat() != '\\'' { // when not escaped single quote ''\n\t\t\t\treturn lex.token(TokenKindString)\n\t\t\t}\n\t\tcase scanner.EOF:\n\t\t\treturn lex.unexpected(scanner.EOF, \"end of string literal\", \"'''\")\n\t\t}\n\t}\n}\n\nfunc (lex *ExprLexer) lexEnd() *Token {\n\tr := lex.eat() // eat the first '}'\n\tif r != '}' {\n\t\treturn lex.unexpected(r, \"end marker }}\", \"'}'\")\n\t}\n\tlex.scan.Next()\n\t// }} is an end marker of interpolation\n\treturn lex.token(TokenKindEnd)\n}\n\nfunc (lex *ExprLexer) lexLess() *Token {\n\tk := TokenKindLess\n\tif lex.eat() == '=' { // eat '<'\n\t\tk = TokenKindLessEq\n\t\tlex.scan.Next()\n\t}\n\treturn lex.token(k)\n}\n\nfunc (lex *ExprLexer) lexGreater() *Token {\n\tk := TokenKindGreater\n\tif lex.eat() == '=' { // eat '>'\n\t\tk = TokenKindGreaterEq\n\t\tlex.scan.Next()\n\t}\n\treturn lex.token(k)\n}\n\nfunc (lex *ExprLexer) lexEq() *Token {\n\tif r := lex.eat(); r != '=' { // eat '='\n\t\treturn lex.unexpected(r, \"== operator\", \"'='\")\n\t}\n\tlex.scan.Next()\n\treturn lex.token(TokenKindEq)\n}\n\nfunc (lex *ExprLexer) lexBang() *Token {\n\tk := TokenKindNot\n\tif lex.eat() == '=' { // eat '!'\n\t\tlex.scan.Next() // eat '='\n\t\tk = TokenKindNotEq\n\t}\n\treturn lex.token(k)\n}\n\nfunc (lex *ExprLexer) lexAnd() *Token {\n\tif r := lex.eat(); r != '&' { // eat the first '&'\n\t\treturn lex.unexpected(r, \"&& operator\", \"'&'\")\n\t}\n\tlex.scan.Next() // eat the second '&'\n\treturn lex.token(TokenKindAnd)\n}\n\nfunc (lex *ExprLexer) lexOr() *Token {\n\tif r := lex.eat(); r != '|' { // eat the first '|'\n\t\treturn lex.unexpected(r, \"|| operator\", \"'|'\")\n\t}\n\tlex.scan.Next() // eat the second '|'\n\treturn lex.token(TokenKindOr)\n}\n\nfunc (lex *ExprLexer) lexChar(k TokenKind) *Token {\n\tlex.scan.Next()\n\treturn lex.token(k)\n}\n\n// Next lexes next token to lex input incrementally. Lexer must be initialized with Init() method\n// before the first call of this method. This method is stateful. Lexer advances offset by lexing\n// token. To get the offset, use Offset() method.\nfunc (lex *ExprLexer) Next() *Token {\n\tlex.skipWhite()\n\n\tr := lex.scan.Peek()\n\tif r == scanner.EOF {\n\t\treturn lex.unexpectedEOF()\n\t}\n\n\t// Ident starts with a-z or A-Z or _\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts\n\tif isAlpha(r) || r == '_' {\n\t\treturn lex.lexIdent()\n\t}\n\n\tif isNum(r) || r == '-' {\n\t\treturn lex.lexNum()\n\t}\n\n\tswitch r {\n\tcase '\\'':\n\t\treturn lex.lexString()\n\tcase '}':\n\t\treturn lex.lexEnd()\n\tcase '!':\n\t\treturn lex.lexBang()\n\tcase '<':\n\t\treturn lex.lexLess()\n\tcase '>':\n\t\treturn lex.lexGreater()\n\tcase '=':\n\t\treturn lex.lexEq()\n\tcase '&':\n\t\treturn lex.lexAnd()\n\tcase '|':\n\t\treturn lex.lexOr()\n\tcase '(':\n\t\treturn lex.lexChar(TokenKindLeftParen)\n\tcase ')':\n\t\treturn lex.lexChar(TokenKindRightParen)\n\tcase '[':\n\t\treturn lex.lexChar(TokenKindLeftBracket)\n\tcase ']':\n\t\treturn lex.lexChar(TokenKindRightBracket)\n\tcase '.':\n\t\treturn lex.lexChar(TokenKindDot)\n\tcase '*':\n\t\treturn lex.lexChar(TokenKindStar)\n\tcase ',':\n\t\treturn lex.lexChar(TokenKindComma)\n\tdefault:\n\t\treturn lex.unexpected(r, \"expression\", expectedAllChars)\n\t}\n}\n\n// Offset returns the current offset (scanning position).\nfunc (lex *ExprLexer) Offset() int {\n\treturn lex.scan.Pos().Offset\n}\n\n// Err returns an error while lexing. When multiple errors occur, the first one is returned.\nfunc (lex *ExprLexer) Err() *ExprError {\n\treturn lex.lexErr\n}\n\n// LexExpression lexes the given string as expression syntax. The parameter must contain '}}' which\n// represents end of expression. Otherwise this function will report an error that it encountered\n// unexpected EOF.\nfunc LexExpression(src string) ([]*Token, int, *ExprError) {\n\tl := NewExprLexer(src)\n\tts := []*Token{}\n\tfor {\n\t\tt := l.Next()\n\t\tif l.lexErr != nil {\n\t\t\treturn nil, l.scan.Pos().Offset, l.lexErr\n\t\t}\n\t\tts = append(ts, t)\n\t\tif t.Kind == TokenKindEnd {\n\t\t\treturn ts, l.scan.Pos().Offset, nil\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "expr_lexer_test.go",
          "type": "blob",
          "size": 16.505859375,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestLexOneToken(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat  string\n\t\tinput string\n\t\tkind  TokenKind\n\t}{\n\t\t{\n\t\t\twhat:  \"identifier\",\n\t\t\tinput: \"foo\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"identifier with _\",\n\t\t\tinput: \"foo_bar\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"identifier with -\",\n\t\t\tinput: \"foo_bar\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"identifier with _ and -\",\n\t\t\tinput: \"foo_bar-piyo\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"_\",\n\t\t\tinput: \"_\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"_-\",\n\t\t\tinput: \"_-\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"null\",\n\t\t\tinput: \"null\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"bool\",\n\t\t\tinput: \"true\",\n\t\t\tkind:  TokenKindIdent,\n\t\t},\n\t\t{\n\t\t\twhat:  \"string\",\n\t\t\tinput: \"'hello world'\",\n\t\t\tkind:  TokenKindString,\n\t\t},\n\t\t{\n\t\t\twhat:  \"empty string\",\n\t\t\tinput: \"''\",\n\t\t\tkind:  TokenKindString,\n\t\t},\n\t\t{\n\t\t\twhat:  \"string with escapes\",\n\t\t\tinput: \"'''hello''world'''\",\n\t\t\tkind:  TokenKindString,\n\t\t},\n\t\t{\n\t\t\twhat:  \"string with braces\",\n\t\t\tinput: \"'braces {in} string {{is}} ok!'\",\n\t\t\tkind:  TokenKindString,\n\t\t},\n\t\t{\n\t\t\twhat:  \"string with non-ascii chars\",\n\t\t\tinput: \"'(^o^)'\",\n\t\t\tkind:  TokenKindString,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int\",\n\t\t\tinput: \"42\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"zero\",\n\t\t\tinput: \"0\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"negative int\",\n\t\t\tinput: \"-42\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"negative zero\",\n\t\t\tinput: \"-0\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex int\",\n\t\t\tinput: \"0x1e\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex int part2\",\n\t\t\tinput: \"0xf\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex int with upper case\",\n\t\t\tinput: \"0x1E\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex int part3\",\n\t\t\tinput: \"0xa\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"negative hex int\",\n\t\t\tinput: \"-0x1e\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex zero\",\n\t\t\tinput: \"0x0\",\n\t\t\tkind:  TokenKindInt,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float\",\n\t\t\tinput: \"1.0\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float smaller than 1\",\n\t\t\tinput: \"0.123\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float zero\",\n\t\t\tinput: \"0.0\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float exp part\",\n\t\t\tinput: \"1.0e3\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float exp part with upper E\",\n\t\t\tinput: \"1.0E3\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float negative exp part\",\n\t\t\tinput: \"1.0e-99\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float negative exp part with upper E\",\n\t\t\tinput: \"1.0E-99\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float zero with negative exp part\",\n\t\t\tinput: \"0.0e-99\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float zero exp part\",\n\t\t\tinput: \"1.0e0\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int with exp part\",\n\t\t\tinput: \"3e42\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int with exp part with big E\",\n\t\t\tinput: \"3E42\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int zero with exp part\",\n\t\t\tinput: \"0e42\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int with zero exp part\",\n\t\t\tinput: \"3e0\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int with negative exp part\",\n\t\t\tinput: \"3e-9\",\n\t\t\tkind:  TokenKindFloat,\n\t\t},\n\t\t{\n\t\t\twhat:  \"left paren\",\n\t\t\tinput: \"(\",\n\t\t\tkind:  TokenKindLeftParen,\n\t\t},\n\t\t{\n\t\t\twhat:  \"right paren\",\n\t\t\tinput: \")\",\n\t\t\tkind:  TokenKindRightParen,\n\t\t},\n\t\t{\n\t\t\twhat:  \"left bracket\",\n\t\t\tinput: \"[\",\n\t\t\tkind:  TokenKindLeftBracket,\n\t\t},\n\t\t{\n\t\t\twhat:  \"right bracket\",\n\t\t\tinput: \"]\",\n\t\t\tkind:  TokenKindRightBracket,\n\t\t},\n\t\t{\n\t\t\twhat:  \"dot operator\",\n\t\t\tinput: \".\",\n\t\t\tkind:  TokenKindDot,\n\t\t},\n\t\t{\n\t\t\twhat:  \"not operator\",\n\t\t\tinput: \"!\",\n\t\t\tkind:  TokenKindNot,\n\t\t},\n\t\t{\n\t\t\twhat:  \"less\",\n\t\t\tinput: \"<\",\n\t\t\tkind:  TokenKindLess,\n\t\t},\n\t\t{\n\t\t\twhat:  \"less equal\",\n\t\t\tinput: \"<=\",\n\t\t\tkind:  TokenKindLessEq,\n\t\t},\n\t\t{\n\t\t\twhat:  \"greater\",\n\t\t\tinput: \">\",\n\t\t\tkind:  TokenKindGreater,\n\t\t},\n\t\t{\n\t\t\twhat:  \"greater equal\",\n\t\t\tinput: \">=\",\n\t\t\tkind:  TokenKindGreaterEq,\n\t\t},\n\t\t{\n\t\t\twhat:  \"equal operator\",\n\t\t\tinput: \"==\",\n\t\t\tkind:  TokenKindEq,\n\t\t},\n\t\t{\n\t\t\twhat:  \"not equal operator\",\n\t\t\tinput: \"!=\",\n\t\t\tkind:  TokenKindNotEq,\n\t\t},\n\t\t{\n\t\t\twhat:  \"and operator\",\n\t\t\tinput: \"&&\",\n\t\t\tkind:  TokenKindAnd,\n\t\t},\n\t\t{\n\t\t\twhat:  \"or operator\",\n\t\t\tinput: \"||\",\n\t\t\tkind:  TokenKindOr,\n\t\t},\n\t\t{\n\t\t\twhat:  \"array access\",\n\t\t\tinput: \"*\",\n\t\t\tkind:  TokenKindStar,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\ttokens, offset, err := LexExpression(tc.input + \"}}\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"error while lexing:\", err)\n\t\t\t}\n\t\t\tif len(tokens) != 2 {\n\t\t\t\tt.Fatal(\"wanted token\", tc.kind.String(), \"followed by End token but got\", tokens)\n\t\t\t}\n\t\t\tif tokens[1].Kind != TokenKindEnd {\n\t\t\t\tt.Fatal(\"wanted End token at end but got\", tokens[1])\n\t\t\t}\n\t\t\ttok := tokens[0]\n\t\t\tif tok.Kind != tc.kind {\n\t\t\t\tt.Fatal(\"wanted token\", tc.kind.String(), \"but got\", tok)\n\t\t\t}\n\t\t\tif tok.Value != tc.input {\n\t\t\t\tt.Fatalf(\"wanted token value %#v but got %#v\", tc.input, tok.Value)\n\t\t\t}\n\t\t\tif offset != len(tc.input)+len(\"}}\") {\n\t\t\t\tt.Fatal(\"wanted\", len(tc.input)+len(\"}}\"), \"but got\", offset, \"tokens:\", tokens)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLexExpression(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat   string\n\t\tinput  string\n\t\ttokens []TokenKind\n\t\tvalues []string\n\t}{\n\t\t{\n\t\t\twhat:  \"property dereference\",\n\t\t\tinput: \"github.action_path\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"github\",\n\t\t\t\t\".\",\n\t\t\t\t\"action_path\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"property dereference with -\",\n\t\t\tinput: \"job.services.foo-bar.id\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"job\",\n\t\t\t\t\".\",\n\t\t\t\t\"services\",\n\t\t\t\t\".\",\n\t\t\t\t\"foo-bar\",\n\t\t\t\t\".\",\n\t\t\t\t\"id\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index syntax\",\n\t\t\tinput: \"github['sha']\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftBracket,\n\t\t\t\tTokenKindString,\n\t\t\t\tTokenKindRightBracket,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"github\",\n\t\t\t\t\"[\",\n\t\t\t\t\"'sha'\",\n\t\t\t\t\"]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"array elements dereference\",\n\t\t\tinput: \"labels.*.name\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindStar,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"labels\",\n\t\t\t\t\".\",\n\t\t\t\t\"*\",\n\t\t\t\t\".\",\n\t\t\t\t\"name\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"startsWith\",\n\t\t\tinput: \"startsWith('hello, world', 'hello')\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindString,\n\t\t\t\tTokenKindComma,\n\t\t\t\tTokenKindString,\n\t\t\t\tTokenKindRightParen,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"startsWith\",\n\t\t\t\t\"(\",\n\t\t\t\t\"'hello, world'\",\n\t\t\t\t\",\",\n\t\t\t\t\"'hello'\",\n\t\t\t\t\")\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"join\",\n\t\t\tinput: \"join(labels.*.name, ', ')\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindStar,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindComma,\n\t\t\t\tTokenKindString,\n\t\t\t\tTokenKindRightParen,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"join\",\n\t\t\t\t\"(\",\n\t\t\t\t\"labels\",\n\t\t\t\t\".\",\n\t\t\t\t\"*\",\n\t\t\t\t\".\",\n\t\t\t\t\"name\",\n\t\t\t\t\",\",\n\t\t\t\t\"', '\",\n\t\t\t\t\")\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"success\",\n\t\t\tinput: \"success()\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindRightParen,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"success\",\n\t\t\t\t\"(\",\n\t\t\t\t\")\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"operator twice\",\n\t\t\tinput: \"!!success()\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindNot,\n\t\t\t\tTokenKindNot,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindRightParen,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"!\",\n\t\t\t\t\"!\",\n\t\t\t\t\"success\",\n\t\t\t\t\"(\",\n\t\t\t\t\")\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested expression\",\n\t\t\tinput: \"((a || b) && (c || d))\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindOr,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindRightParen,\n\t\t\t\tTokenKindAnd,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindOr,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindRightParen,\n\t\t\t\tTokenKindRightParen,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"(\",\n\t\t\t\t\"(\",\n\t\t\t\t\"a\",\n\t\t\t\t\"||\",\n\t\t\t\t\"b\",\n\t\t\t\t\")\",\n\t\t\t\t\"&&\",\n\t\t\t\t\"(\",\n\t\t\t\t\"c\",\n\t\t\t\t\"||\",\n\t\t\t\t\"d\",\n\t\t\t\t\")\",\n\t\t\t\t\")\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"equal expression\",\n\t\t\tinput: \"0 == 1\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindInt,\n\t\t\t\tTokenKindEq,\n\t\t\t\tTokenKindInt,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"0\",\n\t\t\t\t\"==\",\n\t\t\t\t\"1\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"skip white spaces\",\n\t\t\tinput: \" \ta .b .c\tx ( 'foo bar' ,\t42\t) [ true ]\t\",\n\t\t\ttokens: []TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindDot,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindString,\n\t\t\t\tTokenKindComma,\n\t\t\t\tTokenKindInt,\n\t\t\t\tTokenKindRightParen,\n\t\t\t\tTokenKindLeftBracket,\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindRightBracket,\n\t\t\t},\n\t\t\tvalues: []string{\n\t\t\t\t\"a\",\n\t\t\t\t\".\",\n\t\t\t\t\"b\",\n\t\t\t\t\".\",\n\t\t\t\t\"c\",\n\t\t\t\t\"x\",\n\t\t\t\t\"(\",\n\t\t\t\t\"'foo bar'\",\n\t\t\t\t\",\",\n\t\t\t\t\"42\",\n\t\t\t\t\")\",\n\t\t\t\t\"[\",\n\t\t\t\t\"true\",\n\t\t\t\t\"]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:   \"empty expression\",\n\t\t\tinput:  \"\",\n\t\t\ttokens: []TokenKind{},\n\t\t\tvalues: []string{},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tif len(tc.tokens) != len(tc.values) {\n\t\t\tpanic(tc)\n\t\t}\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\ttokens, offset, err := LexExpression(tc.input + \"}}\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"error while lexing:\", err)\n\t\t\t}\n\t\t\tif len(tokens) != len(tc.tokens)+1 {\n\t\t\t\tt.Fatal(\"wanted tokens\", tc.tokens, \"followed by End token but got\", tokens)\n\t\t\t}\n\t\t\tlast := tokens[len(tokens)-1]\n\t\t\tif last.Kind != TokenKindEnd {\n\t\t\t\tt.Fatal(\"wanted End token at end but got\", last)\n\t\t\t}\n\n\t\t\ttokens = tokens[:len(tokens)-1]\n\n\t\t\tkinds := make([]TokenKind, 0, len(tokens))\n\t\t\tvalues := make([]string, 0, len(tokens))\n\t\t\tfor _, t := range tokens {\n\t\t\t\tkinds = append(kinds, t.Kind)\n\t\t\t\tvalues = append(values, t.Value)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(kinds, tc.tokens); diff != \"\" {\n\t\t\t\tt.Error(\"unexpectedtoken kinds:\", diff)\n\t\t\t}\n\t\t\tif diff := cmp.Diff(values, tc.values); diff != \"\" {\n\t\t\t\tt.Error(\"unexpectedtoken values:\", diff)\n\t\t\t}\n\n\t\t\tif offset != len(tc.input)+len(\"}}\") {\n\t\t\t\tt.Fatal(\"wanted offset\", len(tc.input)+len(\"}}\"), \"but got\", offset, \"tokens:\", tokens)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLexExprError(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat  string\n\t\tinput string\n\t\twant  string\n\t\tcol   int\n\t}{\n\t\t{\n\t\t\twhat:  \"unknown char\",\n\t\t\tinput: \"?\",\n\t\t\twant:  \"unexpected character '?' while lexing expression\",\n\t\t\tcol:   1,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF\",\n\t\t\tinput: \"42\",\n\t\t\twant:  \"unexpected EOF while lexing expression\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twant:  \"unexpected EOF while lexing expression\",\n\t\t\tcol:   1,\n\t\t},\n\t\t{\n\t\t\twhat:  \"broken string literal\",\n\t\t\tinput: \"'foo bar\",\n\t\t\twant:  \"unexpected EOF while lexing end of string literal\",\n\t\t\tcol:   9,\n\t\t},\n\t\t{\n\t\t\twhat:  \"broken string literal with escape\",\n\t\t\tinput: \"'foo bar''\",\n\t\t\twant:  \"unexpected EOF while lexing end of string literal\",\n\t\t\tcol:   11,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after -\",\n\t\t\tinput: \"-a\",\n\t\t\twant:  \"got unexpected character 'a' while lexing integer part of number\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"EOF after -\",\n\t\t\tinput: \"-\",\n\t\t\twant:  \"got unexpected EOF while lexing integer part of number\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after 0\",\n\t\t\tinput: \"0d\",\n\t\t\twant:  \"got unexpected character 'd' while lexing character following number 0\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after number\",\n\t\t\tinput: \"123d\",\n\t\t\twant:  \"got unexpected character 'd' while lexing character following number 123\",\n\t\t\tcol:   4,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char in fraction part of float\",\n\t\t\tinput: \"1.e1\",\n\t\t\twant:  \"unexpected character 'e' while lexing fraction part of float number\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char in exponent part of float\",\n\t\t\tinput: \"1.0e_\",\n\t\t\twant:  \"unexpected character '_' while lexing exponent part of float number\",\n\t\t\tcol:   5,\n\t\t},\n\t\t{\n\t\t\twhat:  \"no number after - in exponent part\",\n\t\t\tinput: \"1.0e-\",\n\t\t\twant:  \"unexpected EOF while lexing exponent part of float number\",\n\t\t\tcol:   6,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char in hex int\",\n\t\t\tinput: \"0xg\",\n\t\t\twant:  \"unexpected character 'g' while lexing hex integer\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF after 0x\",\n\t\t\tinput: \"0x\",\n\t\t\twant:  \"unexpected EOF while lexing hex integer\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char at end of input\",\n\t\t\tinput: \"'in {string} it {{is}} ok'}_\",\n\t\t\twant:  \"unexpected character '_' while lexing end marker\",\n\t\t\tcol:   28,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after =\",\n\t\t\tinput: \"=3\",\n\t\t\twant:  \"unexpected character '3' while lexing == operator\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after &\",\n\t\t\tinput: \"&3\",\n\t\t\twant:  \"unexpected character '3' while lexing && operator\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after |\",\n\t\t\tinput: \"|3\",\n\t\t\twant:  \"unexpected character '3' while lexing || operator\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing int\",\n\t\t\tinput: \"0x\",\n\t\t\twant:  \"unexpected EOF while lexing hex integer\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing fraction of float\",\n\t\t\tinput: \"0.\",\n\t\t\twant:  \"unexpected EOF while lexing fraction part of float number\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing exponent of float\",\n\t\t\tinput: \"0.1e\",\n\t\t\twant:  \"unexpected EOF while lexing exponent part of float number\",\n\t\t\tcol:   5,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing end marker\",\n\t\t\tinput: \"}\",\n\t\t\twant:  \"unexpected EOF while lexing end marker }}\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing == operator\",\n\t\t\tinput: \"=\",\n\t\t\twant:  \"unexpected EOF while lexing == operator\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing && operator\",\n\t\t\tinput: \"&\",\n\t\t\twant:  \"unexpected EOF while lexing && operator\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"unexpected EOF while lexing || operator\",\n\t\t\tinput: \"|\",\n\t\t\twant:  \"unexpected EOF while lexing || operator\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"empty string\",\n\t\t\tinput: \"\",\n\t\t\twant:  \"unexpected EOF while lexing expression\",\n\t\t\tcol:   1,\n\t\t},\n\t\t{\n\t\t\twhat:  \"special note for string literals with double quotes\",\n\t\t\tinput: \"\\\"hello\\\"\",\n\t\t\twant:  \"do you mean string literals? only single quotes are available for string delimiter\",\n\t\t\tcol:   1,\n\t\t},\n\t\t{\n\t\t\twhat:  \"integer starts with zero\",\n\t\t\tinput: \"0123\",\n\t\t\twant:  \"unexpected character '1' while lexing character following number 0\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex integer starts with zero\",\n\t\t\tinput: \"0x0123\",\n\t\t\twant:  \"unexpected character '1' while lexing character following hex integer 0x0\",\n\t\t\tcol:   4,\n\t\t},\n\t\t{\n\t\t\twhat:  \"hex integer starts with zero and followed by e\",\n\t\t\tinput: \"0x0e1\",\n\t\t\twant:  \"unexpected character 'e' while lexing character following hex integer 0x0\",\n\t\t\tcol:   4,\n\t\t},\n\t\t{\n\t\t\twhat:  \"integer exponent part starts with zero\",\n\t\t\tinput: \"1e01\",\n\t\t\twant:  \"unexpected character '1' while lexing character following number 1e0\",\n\t\t\tcol:   4,\n\t\t},\n\t\t{\n\t\t\twhat:  \"float number exponent part starts with zero\",\n\t\t\tinput: \"1.0e01\",\n\t\t\twant:  \"unexpected character '1' while lexing character following number 1.0e0\",\n\t\t\tcol:   6,\n\t\t},\n\t\t{\n\t\t\twhat:  \"integer part lacks in float number\",\n\t\t\tinput: \"-.0\",\n\t\t\twant:  \"got unexpected character '.'\",\n\t\t\tcol:   2,\n\t\t},\n\t\t{\n\t\t\twhat:  \"fraction part lacks in float number\",\n\t\t\tinput: \"0.e1\",\n\t\t\twant:  \"got unexpected character 'e' while lexing fraction part\",\n\t\t\tcol:   3,\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid char after hex number\",\n\t\t\tinput: \"0x1fz\",\n\t\t\twant:  \"unexpected character 'z' while lexing character following hex integer 0x1\",\n\t\t\tcol:   5,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\t_, _, err := LexExpression(tc.input)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"error did not occur\")\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.want) {\n\t\t\t\tt.Fatalf(\"Error message %q does not contain %q\", err.Error(), tc.want)\n\t\t\t}\n\t\t\tif err.Column != tc.col {\n\t\t\t\tt.Fatalf(\"Error occurred at column %d expecting %d\", err.Column, tc.col)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLexTokenPos(t *testing.T) {\n\tinput := \"foo( true && 0.1234, github.issue )\"\n\twant := []int{0, 3, 5, 10, 13, 19, 21, 27, 28, 34, 35}\n\n\tts, _, err := LexExpression(input + \"}}\")\n\tif err != nil {\n\t\tt.Fatal(\"error while lexing:\", err)\n\t}\n\n\tif len(ts) != len(want) {\n\t\tt.Fatalf(\"length of inputs mismatch. want=%d, have=%d\", len(want), len(ts))\n\t}\n\n\tfor i := 0; i < len(ts); i++ {\n\t\tif ts[i].Offset != want[i] {\n\t\t\tt.Errorf(\"%dth token offsets mismatch. want=%d, have=%d\", i+1, want[i], ts[i].Offset)\n\t\t}\n\t\tif ts[i].Line != 1 {\n\t\t\tt.Errorf(\"%dth token line should be 1 but got %d\", i+1, ts[i].Line)\n\t\t}\n\t\tif ts[i].Column != want[i]+1 {\n\t\t\tt.Errorf(\"%dth token column should be %d but got %d\", i+1, want[i]+1, ts[i].Column)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "expr_parser.go",
          "type": "blob",
          "size": 7.708984375,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc errorAtToken(t *Token, msg string) *ExprError {\n\treturn &ExprError{\n\t\tMessage: msg,\n\t\tOffset:  t.Offset,\n\t\tLine:    t.Line,\n\t\tColumn:  t.Column,\n\t}\n}\n\n// ExprParser is a parser for expression syntax. To know the details, see\n// https://docs.github.com/en/actions/learn-github-actions/expressions\ntype ExprParser struct {\n\tcur   *Token\n\tlexer *ExprLexer\n\terr   *ExprError\n}\n\n// NewExprParser creates new ExprParser instance.\nfunc NewExprParser() *ExprParser {\n\treturn &ExprParser{}\n}\n\nfunc (p *ExprParser) error(msg string) {\n\tif p.err == nil {\n\t\tp.err = errorAtToken(p.cur, msg)\n\t}\n}\n\nfunc (p *ExprParser) errorf(format string, args ...interface{}) {\n\tp.error(fmt.Sprintf(format, args...))\n}\n\nfunc (p *ExprParser) unexpected(where string, expected []TokenKind) {\n\tif p.err != nil {\n\t\treturn\n\t}\n\tqb := quotesBuilder{}\n\tfor _, e := range expected {\n\t\tqb.append(e.String())\n\t}\n\tvar what string\n\tif p.cur.Kind == TokenKindEnd {\n\t\twhat = \"end of input\"\n\t} else {\n\t\twhat = fmt.Sprintf(\"token %q\", p.cur.Kind.String())\n\t}\n\tmsg := fmt.Sprintf(\"unexpected %s while parsing %s. expecting %s\", what, where, qb.build())\n\tp.error(msg)\n}\n\nfunc (p *ExprParser) next() *Token {\n\tret := p.cur\n\tp.cur = p.lexer.Next()\n\treturn ret\n}\n\nfunc (p *ExprParser) peek() *Token {\n\treturn p.cur\n}\n\nfunc (p *ExprParser) parseIdent() ExprNode {\n\tident := p.next() // eat ident\n\tswitch p.peek().Kind {\n\tcase TokenKindLeftParen:\n\t\t// Parse function call as primary expression though generally function call is parsed as\n\t\t// postfix expression. The reason is that only built-in function call is allowed in workflow\n\t\t// expression syntax, meant that callee is always built-in function name, not a general\n\t\t// expression.\n\t\tp.next() // eat '('\n\t\targs := []ExprNode{}\n\t\tif p.peek().Kind == TokenKindRightParen {\n\t\t\t// no arguments\n\t\t\tp.next() // eat ')'\n\t\t} else {\n\t\tLoopArgs:\n\t\t\tfor {\n\t\t\t\targ := p.parseLogicalOr()\n\t\t\t\tif arg == nil {\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\n\t\t\t\targs = append(args, arg)\n\n\t\t\t\tswitch p.peek().Kind {\n\t\t\t\tcase TokenKindComma:\n\t\t\t\t\tp.next() // eat ','\n\t\t\t\t\t// continue to next argument\n\t\t\t\tcase TokenKindRightParen:\n\t\t\t\t\tp.next() // eat ')'\n\t\t\t\t\tbreak LoopArgs\n\t\t\t\tdefault:\n\t\t\t\t\tp.unexpected(\"arguments of function call\", []TokenKind{TokenKindComma, TokenKindRightParen})\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn &FuncCallNode{ident.Value, args, ident}\n\tdefault:\n\t\t// Handle keywords. Note that keywords are case sensitive. TRUE, FALSE, NULL are invalid named value.\n\t\tswitch ident.Value {\n\t\tcase \"null\":\n\t\t\treturn &NullNode{ident}\n\t\tcase \"true\":\n\t\t\treturn &BoolNode{true, ident}\n\t\tcase \"false\":\n\t\t\treturn &BoolNode{false, ident}\n\t\tdefault:\n\t\t\t// Variable name access is case insensitive. github.event and GITHUB.event are the same.\n\t\t\treturn &VariableNode{strings.ToLower(ident.Value), ident}\n\t\t}\n\t}\n}\n\nfunc (p *ExprParser) parseNestedExpr() ExprNode {\n\tp.next() // eat '('\n\n\tnested := p.parseLogicalOr()\n\tif nested == nil {\n\t\treturn nil\n\t}\n\n\tif p.peek().Kind == TokenKindRightParen {\n\t\tp.next() // eat ')'\n\t} else {\n\t\tp.unexpected(\"closing ')' of nested expression (...)\", []TokenKind{TokenKindRightParen})\n\t\treturn nil\n\t}\n\n\treturn nested\n}\n\nfunc (p *ExprParser) parseInt() ExprNode {\n\tt := p.peek()\n\ti, err := strconv.ParseInt(t.Value, 0, 32)\n\tif err != nil {\n\t\tp.errorf(\"parsing invalid integer literal %q: %s\", t.Value, err)\n\t\treturn nil\n\t}\n\n\tp.next() // eat int\n\n\treturn &IntNode{int(i), t}\n}\n\nfunc (p *ExprParser) parseFloat() ExprNode {\n\tt := p.peek()\n\tf, err := strconv.ParseFloat(t.Value, 64)\n\tif err != nil {\n\t\tp.errorf(\"parsing invalid float literal %q: %s\", t.Value, err)\n\t\treturn nil\n\t}\n\n\tp.next() // eat float\n\n\treturn &FloatNode{f, t}\n}\n\nfunc (p *ExprParser) parseString() ExprNode {\n\tt := p.next() // eat string\n\ts := t.Value\n\ts = s[1 : len(s)-1]                  // strip first and last single quotes\n\ts = strings.ReplaceAll(s, \"''\", \"'\") // unescape ''\n\treturn &StringNode{s, t}\n}\n\nfunc (p *ExprParser) parsePrimaryExpr() ExprNode {\n\tswitch p.peek().Kind {\n\tcase TokenKindIdent:\n\t\treturn p.parseIdent()\n\tcase TokenKindLeftParen:\n\t\treturn p.parseNestedExpr()\n\tcase TokenKindInt:\n\t\treturn p.parseInt()\n\tcase TokenKindFloat:\n\t\treturn p.parseFloat()\n\tcase TokenKindString:\n\t\treturn p.parseString()\n\tdefault:\n\t\tp.unexpected(\n\t\t\t\"variable access, function call, null, bool, int, float or string\",\n\t\t\t[]TokenKind{\n\t\t\t\tTokenKindIdent,\n\t\t\t\tTokenKindLeftParen,\n\t\t\t\tTokenKindInt,\n\t\t\t\tTokenKindFloat,\n\t\t\t\tTokenKindString,\n\t\t\t},\n\t\t)\n\t\treturn nil\n\t}\n}\n\nfunc (p *ExprParser) parsePostfixOp() ExprNode {\n\tret := p.parsePrimaryExpr()\n\tif ret == nil {\n\t\treturn nil\n\t}\n\n\tfor {\n\t\tswitch p.peek().Kind {\n\t\tcase TokenKindDot:\n\t\t\tp.next() // eat '.'\n\t\t\tswitch p.peek().Kind {\n\t\t\tcase TokenKindStar:\n\t\t\t\tp.next() // eat '*'\n\t\t\t\tret = &ArrayDerefNode{ret}\n\t\t\tcase TokenKindIdent:\n\t\t\t\tt := p.next() // eat 'b' of 'a.b'\n\t\t\t\t// Property name is case insensitive. github.event and github.EVENT are the same\n\t\t\t\tret = &ObjectDerefNode{ret, strings.ToLower(t.Value)}\n\t\t\tdefault:\n\t\t\t\tp.unexpected(\n\t\t\t\t\t\"object property dereference like 'a.b' or array element dereference like 'a.*'\",\n\t\t\t\t\t[]TokenKind{TokenKindIdent, TokenKindStar},\n\t\t\t\t)\n\t\t\t\treturn nil\n\t\t\t}\n\t\tcase TokenKindLeftBracket:\n\t\t\tp.next() // eat '['\n\t\t\tidx := p.parseLogicalOr()\n\t\t\tif idx == nil {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tret = &IndexAccessNode{ret, idx}\n\t\t\tif p.peek().Kind != TokenKindRightBracket {\n\t\t\t\tp.unexpected(\"closing bracket ']' for index access\", []TokenKind{TokenKindRightBracket})\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tp.next() // eat ']'\n\t\tdefault:\n\t\t\treturn ret\n\t\t}\n\t}\n}\n\nfunc (p *ExprParser) parsePrefixOp() ExprNode {\n\tt := p.peek()\n\tif t.Kind != TokenKindNot {\n\t\treturn p.parsePostfixOp()\n\t}\n\tp.next() // eat '!' token\n\n\to := p.parsePrefixOp()\n\tif o == nil {\n\t\treturn nil\n\t}\n\n\treturn &NotOpNode{o, t}\n}\n\nfunc (p *ExprParser) parseCompareBinOp() ExprNode {\n\tl := p.parsePrefixOp()\n\tif l == nil {\n\t\treturn nil\n\t}\n\n\tk := CompareOpNodeKindInvalid\n\tswitch p.peek().Kind {\n\tcase TokenKindLess:\n\t\tk = CompareOpNodeKindLess\n\tcase TokenKindLessEq:\n\t\tk = CompareOpNodeKindLessEq\n\tcase TokenKindGreater:\n\t\tk = CompareOpNodeKindGreater\n\tcase TokenKindGreaterEq:\n\t\tk = CompareOpNodeKindGreaterEq\n\tcase TokenKindEq:\n\t\tk = CompareOpNodeKindEq\n\tcase TokenKindNotEq:\n\t\tk = CompareOpNodeKindNotEq\n\tdefault:\n\t\treturn l\n\t}\n\tp.next() // eat the operator token\n\n\tr := p.parseCompareBinOp()\n\tif r == nil {\n\t\treturn nil\n\t}\n\n\treturn &CompareOpNode{k, l, r}\n}\n\nfunc (p *ExprParser) parseLogicalAnd() ExprNode {\n\tl := p.parseCompareBinOp()\n\tif l == nil {\n\t\treturn nil\n\t}\n\tif p.peek().Kind != TokenKindAnd {\n\t\treturn l\n\t}\n\tp.next() // eat &&\n\tr := p.parseLogicalAnd()\n\tif r == nil {\n\t\treturn nil\n\t}\n\treturn &LogicalOpNode{LogicalOpNodeKindAnd, l, r}\n}\n\nfunc (p *ExprParser) parseLogicalOr() ExprNode {\n\tl := p.parseLogicalAnd()\n\tif l == nil {\n\t\treturn nil\n\t}\n\tif p.peek().Kind != TokenKindOr {\n\t\treturn l\n\t}\n\tp.next() // eat ||\n\tr := p.parseLogicalOr()\n\tif r == nil {\n\t\treturn nil\n\t}\n\treturn &LogicalOpNode{LogicalOpNodeKindOr, l, r}\n}\n\n// Err returns an error which was caused while previous parsing.\nfunc (p *ExprParser) Err() *ExprError {\n\tif err := p.lexer.Err(); err != nil {\n\t\treturn err\n\t}\n\treturn p.err\n}\n\n// Parse parses token sequence lexed by a given lexer into syntax tree.\nfunc (p *ExprParser) Parse(l *ExprLexer) (ExprNode, *ExprError) {\n\t// Init\n\tp.err = nil\n\tp.lexer = l\n\tp.cur = l.Next()\n\n\troot := p.parseLogicalOr()\n\tif err := p.Err(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif t := p.peek(); t.Kind != TokenKindEnd {\n\t\t// It did not reach the end of sequence\n\t\tqb := quotesBuilder{}\n\t\tqb.append(t.Kind.String())\n\t\tc := 1\n\t\tfor {\n\t\t\tt := l.Next()\n\t\t\tif t.Kind == TokenKindEnd {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tqb.append(t.Kind.String())\n\t\t\tc++\n\t\t}\n\t\tp.errorf(\"parser did not reach end of input after parsing the expression. %d remaining token(s) in the input: %s\", c, qb.build())\n\t\treturn nil, p.err\n\t}\n\n\treturn root, nil\n}\n"
        },
        {
          "name": "expr_parser_test.go",
          "type": "blob",
          "size": 20.783203125,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n)\n\nfunc TestParseExpressionSyntaxOK(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat     string\n\t\tinput    string\n\t\texpected ExprNode\n\t}{\n\t\t// simple expressions\n\t\t{\n\t\t\twhat:     \"null literal\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: &NullNode{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"boolean literal true\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: &BoolNode{Value: true},\n\t\t},\n\t\t{\n\t\t\twhat:     \"boolean literal false\",\n\t\t\tinput:    \"false\",\n\t\t\texpected: &BoolNode{Value: false},\n\t\t},\n\t\t{\n\t\t\twhat:     \"integer literal\",\n\t\t\tinput:    \"711\",\n\t\t\texpected: &IntNode{Value: 711},\n\t\t},\n\t\t{\n\t\t\twhat:     \"negative integer literal\",\n\t\t\tinput:    \"-10\",\n\t\t\texpected: &IntNode{Value: -10},\n\t\t},\n\t\t{\n\t\t\twhat:     \"zero integer literal\",\n\t\t\tinput:    \"0\",\n\t\t\texpected: &IntNode{Value: 0},\n\t\t},\n\t\t{\n\t\t\twhat:     \"hex integer literal\",\n\t\t\tinput:    \"0x1f\",\n\t\t\texpected: &IntNode{Value: 0x1f},\n\t\t},\n\t\t{\n\t\t\twhat:     \"negative hex integer literal\",\n\t\t\tinput:    \"-0xaf\",\n\t\t\texpected: &IntNode{Value: -0xaf},\n\t\t},\n\t\t{\n\t\t\twhat:     \"hex integer zero\",\n\t\t\tinput:    \"0x0\",\n\t\t\texpected: &IntNode{Value: 0x0},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal\",\n\t\t\tinput:    \"1234.567\",\n\t\t\texpected: &FloatNode{Value: 1234.567},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal smaller than 1\",\n\t\t\tinput:    \"0.567\",\n\t\t\texpected: &FloatNode{Value: 0.567},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal zero\",\n\t\t\tinput:    \"0.0\",\n\t\t\texpected: &FloatNode{Value: 0.0},\n\t\t},\n\t\t{\n\t\t\twhat:     \"negative float literal\",\n\t\t\tinput:    \"-1234.567\",\n\t\t\texpected: &FloatNode{Value: -1234.567},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal with exponent part\",\n\t\t\tinput:    \"12e3\",\n\t\t\texpected: &FloatNode{Value: 12e3},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal with negative exponent part\",\n\t\t\tinput:    \"-99e-1\",\n\t\t\texpected: &FloatNode{Value: -99e-1},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal with fraction and exponent part\",\n\t\t\tinput:    \"1.2e3\",\n\t\t\texpected: &FloatNode{Value: 1.2e3},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float literal with fraction and negative exponent part\",\n\t\t\tinput:    \"-0.123e-12\",\n\t\t\texpected: &FloatNode{Value: -0.123e-12},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float zero value with exponent part\",\n\t\t\tinput:    \"0e3\",\n\t\t\texpected: &FloatNode{Value: 0e3},\n\t\t},\n\t\t{\n\t\t\twhat:     \"string literal\",\n\t\t\tinput:    \"'hello, world'\",\n\t\t\texpected: &StringNode{Value: \"hello, world\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"empty string literal\",\n\t\t\tinput:    \"''\",\n\t\t\texpected: &StringNode{Value: \"\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"string literal with escapes\",\n\t\t\tinput:    \"'''hello''world'''\",\n\t\t\texpected: &StringNode{Value: \"'hello'world'\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"string literal with non-ascii chars\",\n\t\t\tinput:    \"'(^o^)'\",\n\t\t\texpected: &StringNode{Value: \"(^o^)\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"variable\",\n\t\t\tinput:    \"github\",\n\t\t\texpected: &VariableNode{Name: \"github\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"variable with uppercase name\",\n\t\t\tinput:    \"GITHUB\",\n\t\t\texpected: &VariableNode{Name: \"github\"},\n\t\t},\n\t\t{\n\t\t\twhat:  \"func call\",\n\t\t\tinput: \"success()\",\n\t\t\texpected: &FuncCallNode{\n\t\t\t\tCallee: \"success\",\n\t\t\t\tArgs:   []ExprNode{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"func call with 1 argument\",\n\t\t\tinput: \"fromJSON(object)\",\n\t\t\texpected: &FuncCallNode{\n\t\t\t\tCallee: \"fromJSON\",\n\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t&VariableNode{Name: \"object\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"func call with multiple arguments\",\n\t\t\tinput: \"contains('hello, world', 'o, w')\",\n\t\t\texpected: &FuncCallNode{\n\t\t\t\tCallee: \"contains\",\n\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t&StringNode{Value: \"hello, world\"},\n\t\t\t\t\t&StringNode{Value: \"o, w\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access\",\n\t\t\tinput: \"obj['key']\",\n\t\t\texpected: &IndexAccessNode{\n\t\t\t\tOperand: &VariableNode{Name: \"obj\"},\n\t\t\t\tIndex:   &StringNode{Value: \"key\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access with variable\",\n\t\t\tinput: \"obj[a.b]\",\n\t\t\texpected: &IndexAccessNode{\n\t\t\t\tOperand: &VariableNode{Name: \"obj\"},\n\t\t\t\tIndex: &ObjectDerefNode{\n\t\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t\t\tProperty: \"b\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"< operator\",\n\t\t\tinput: \"0 < 1\",\n\t\t\texpected: &CompareOpNode{\n\t\t\t\tKind:  CompareOpNodeKindLess,\n\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\tRight: &IntNode{Value: 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"! operator\",\n\t\t\tinput: \"!true\",\n\t\t\texpected: &NotOpNode{\n\t\t\t\tOperand: &BoolNode{Value: true},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"! operator twice\",\n\t\t\tinput: \"!!true\",\n\t\t\texpected: &NotOpNode{\n\t\t\t\tOperand: &NotOpNode{\n\t\t\t\t\tOperand: &BoolNode{Value: true},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"<= operator\",\n\t\t\tinput: \"0 <= 1\",\n\t\t\texpected: &CompareOpNode{\n\t\t\t\tKind:  CompareOpNodeKindLessEq,\n\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\tRight: &IntNode{Value: 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"> operator\",\n\t\t\tinput: \"0 > 1\",\n\t\t\texpected: &CompareOpNode{\n\t\t\t\tKind:  CompareOpNodeKindGreater,\n\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\tRight: &IntNode{Value: 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \">= operator\",\n\t\t\tinput: \"0 >= 1\",\n\t\t\texpected: &CompareOpNode{\n\t\t\t\tKind:  CompareOpNodeKindGreaterEq,\n\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\tRight: &IntNode{Value: 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"== operator\",\n\t\t\tinput: \"0 == 1\",\n\t\t\texpected: &CompareOpNode{\n\t\t\t\tKind:  CompareOpNodeKindEq,\n\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\tRight: &IntNode{Value: 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"!= operator\",\n\t\t\tinput: \"0 != 1\",\n\t\t\texpected: &CompareOpNode{\n\t\t\t\tKind:  CompareOpNodeKindNotEq,\n\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\tRight: &IntNode{Value: 1},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"&& operator\",\n\t\t\tinput: \"true && false\",\n\t\t\texpected: &LogicalOpNode{\n\t\t\t\tKind:  LogicalOpNodeKindAnd,\n\t\t\t\tLeft:  &BoolNode{Value: true},\n\t\t\t\tRight: &BoolNode{Value: false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"|| operator\",\n\t\t\tinput: \"true || false\",\n\t\t\texpected: &LogicalOpNode{\n\t\t\t\tKind:  LogicalOpNodeKindOr,\n\t\t\t\tLeft:  &BoolNode{Value: true},\n\t\t\t\tRight: &BoolNode{Value: false},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"nested value\",\n\t\t\tinput:    \"(42)\",\n\t\t\texpected: &IntNode{Value: 42},\n\t\t},\n\t\t{\n\t\t\twhat:     \"very nested value\",\n\t\t\tinput:    \"((((((((((((((((((42))))))))))))))))))\",\n\t\t\texpected: &IntNode{Value: 42},\n\t\t},\n\t\t{\n\t\t\twhat:  \"object property dereference\",\n\t\t\tinput: \"a.b\",\n\t\t\texpected: &ObjectDerefNode{\n\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t\tProperty: \"b\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"object property dereference with uppercase name\",\n\t\t\tinput: \"github.EVENT\",\n\t\t\texpected: &ObjectDerefNode{\n\t\t\t\tReceiver: &VariableNode{Name: \"github\"},\n\t\t\t\tProperty: \"event\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested object property dereference\",\n\t\t\tinput: \"a.b.c.d\",\n\t\t\texpected: &ObjectDerefNode{\n\t\t\t\tProperty: \"d\",\n\t\t\t\tReceiver: &ObjectDerefNode{\n\t\t\t\t\tProperty: \"c\",\n\t\t\t\t\tReceiver: &ObjectDerefNode{\n\t\t\t\t\t\tProperty: \"b\",\n\t\t\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"property includes uppercase character\",\n\t\t\tinput: \"a.doSomething\",\n\t\t\texpected: &ObjectDerefNode{\n\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t\tProperty: \"dosomething\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"property includes -\",\n\t\t\tinput: \"a.foo-bar\",\n\t\t\texpected: &ObjectDerefNode{\n\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t\tProperty: \"foo-bar\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"array element dereference\",\n\t\t\tinput: \"a.*\",\n\t\t\texpected: &ArrayDerefNode{\n\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested array element dereference\",\n\t\t\tinput: \"a.*.*.*\",\n\t\t\texpected: &ArrayDerefNode{\n\t\t\t\tReceiver: &ArrayDerefNode{\n\t\t\t\t\tReceiver: &ArrayDerefNode{\n\t\t\t\t\t\tReceiver: &VariableNode{Name: \"a\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// compound expressions\n\t\t{\n\t\t\twhat:  \"logical expressions\",\n\t\t\tinput: \"0 == 0.1 && a < b || x >= !y && true != false\",\n\t\t\texpected: &LogicalOpNode{\n\t\t\t\tKind: LogicalOpNodeKindOr,\n\t\t\t\tLeft: &LogicalOpNode{\n\t\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\t\tLeft: &CompareOpNode{\n\t\t\t\t\t\tKind:  CompareOpNodeKindEq,\n\t\t\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\t\t\tRight: &FloatNode{Value: 0.1},\n\t\t\t\t\t},\n\t\t\t\t\tRight: &CompareOpNode{\n\t\t\t\t\t\tKind:  CompareOpNodeKindLess,\n\t\t\t\t\t\tLeft:  &VariableNode{Name: \"a\"},\n\t\t\t\t\t\tRight: &VariableNode{Name: \"b\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRight: &LogicalOpNode{\n\t\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\t\tLeft: &CompareOpNode{\n\t\t\t\t\t\tKind: CompareOpNodeKindGreaterEq,\n\t\t\t\t\t\tLeft: &VariableNode{Name: \"x\"},\n\t\t\t\t\t\tRight: &NotOpNode{\n\t\t\t\t\t\t\tOperand: &VariableNode{Name: \"y\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRight: &CompareOpNode{\n\t\t\t\t\t\tKind:  CompareOpNodeKindNotEq,\n\t\t\t\t\t\tLeft:  &BoolNode{Value: true},\n\t\t\t\t\t\tRight: &BoolNode{Value: false},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"logical expressions with nested expressions\",\n\t\t\tinput: \"(0 == 0.1) && (a < b || x >= !y) && (true != false)\",\n\t\t\texpected: &LogicalOpNode{\n\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\tLeft: &CompareOpNode{\n\t\t\t\t\tKind:  CompareOpNodeKindEq,\n\t\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\t\tRight: &FloatNode{Value: 0.1},\n\t\t\t\t},\n\t\t\t\tRight: &LogicalOpNode{\n\t\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\t\tLeft: &LogicalOpNode{\n\t\t\t\t\t\tKind: LogicalOpNodeKindOr,\n\t\t\t\t\t\tLeft: &CompareOpNode{\n\t\t\t\t\t\t\tKind:  CompareOpNodeKindLess,\n\t\t\t\t\t\t\tLeft:  &VariableNode{Name: \"a\"},\n\t\t\t\t\t\t\tRight: &VariableNode{Name: \"b\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRight: &CompareOpNode{\n\t\t\t\t\t\t\tKind: CompareOpNodeKindGreaterEq,\n\t\t\t\t\t\t\tLeft: &VariableNode{Name: \"x\"},\n\t\t\t\t\t\t\tRight: &NotOpNode{\n\t\t\t\t\t\t\t\tOperand: &VariableNode{Name: \"y\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRight: &CompareOpNode{\n\t\t\t\t\t\tKind:  CompareOpNodeKindNotEq,\n\t\t\t\t\t\tLeft:  &BoolNode{Value: true},\n\t\t\t\t\t\tRight: &BoolNode{Value: false},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"logical expressions with more nested expressions\",\n\t\t\tinput: \"((0 == 0.1) && (a < b || x >= !y)) && (true != false)\",\n\t\t\texpected: &LogicalOpNode{\n\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\tLeft: &LogicalOpNode{\n\t\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\t\tLeft: &CompareOpNode{\n\t\t\t\t\t\tKind:  CompareOpNodeKindEq,\n\t\t\t\t\t\tLeft:  &IntNode{Value: 0},\n\t\t\t\t\t\tRight: &FloatNode{Value: 0.1},\n\t\t\t\t\t},\n\t\t\t\t\tRight: &LogicalOpNode{\n\t\t\t\t\t\tKind: LogicalOpNodeKindOr,\n\t\t\t\t\t\tLeft: &CompareOpNode{\n\t\t\t\t\t\t\tKind:  CompareOpNodeKindLess,\n\t\t\t\t\t\t\tLeft:  &VariableNode{Name: \"a\"},\n\t\t\t\t\t\t\tRight: &VariableNode{Name: \"b\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tRight: &CompareOpNode{\n\t\t\t\t\t\t\tKind: CompareOpNodeKindGreaterEq,\n\t\t\t\t\t\t\tLeft: &VariableNode{Name: \"x\"},\n\t\t\t\t\t\t\tRight: &NotOpNode{\n\t\t\t\t\t\t\t\tOperand: &VariableNode{Name: \"y\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRight: &CompareOpNode{\n\t\t\t\t\tKind:  CompareOpNodeKindNotEq,\n\t\t\t\t\tLeft:  &BoolNode{Value: true},\n\t\t\t\t\tRight: &BoolNode{Value: false},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested function calls\",\n\t\t\tinput: \"!contains(some.value, 'foo') && endsWith(join(x.*.y, ', '), 'bar')\",\n\t\t\texpected: &LogicalOpNode{\n\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\tLeft: &NotOpNode{\n\t\t\t\t\tOperand: &FuncCallNode{\n\t\t\t\t\t\tCallee: \"contains\",\n\t\t\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t\t\t&ObjectDerefNode{\n\t\t\t\t\t\t\t\tReceiver: &VariableNode{Name: \"some\"},\n\t\t\t\t\t\t\t\tProperty: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&StringNode{Value: \"foo\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tRight: &FuncCallNode{\n\t\t\t\t\tCallee: \"endsWith\",\n\t\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t\t&FuncCallNode{\n\t\t\t\t\t\t\tCallee: \"join\",\n\t\t\t\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t\t\t\t&ObjectDerefNode{\n\t\t\t\t\t\t\t\t\tReceiver: &ArrayDerefNode{\n\t\t\t\t\t\t\t\t\t\tReceiver: &VariableNode{Name: \"x\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tProperty: \"y\",\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t&StringNode{Value: \", \"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t&StringNode{Value: \"bar\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested function calls with nested expressions\",\n\t\t\tinput: \"!((contains((some.value), ('foo'))) && (endsWith((join((x.*.y), (', '))), ('bar'))))\",\n\t\t\texpected: &NotOpNode{\n\t\t\t\tOperand: &LogicalOpNode{\n\t\t\t\t\tKind: LogicalOpNodeKindAnd,\n\t\t\t\t\tLeft: &FuncCallNode{\n\t\t\t\t\t\tCallee: \"contains\",\n\t\t\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t\t\t&ObjectDerefNode{\n\t\t\t\t\t\t\t\tReceiver: &VariableNode{Name: \"some\"},\n\t\t\t\t\t\t\t\tProperty: \"value\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&StringNode{Value: \"foo\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tRight: &FuncCallNode{\n\t\t\t\t\t\tCallee: \"endsWith\",\n\t\t\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t\t\t&FuncCallNode{\n\t\t\t\t\t\t\t\tCallee: \"join\",\n\t\t\t\t\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t\t\t\t\t&ObjectDerefNode{\n\t\t\t\t\t\t\t\t\t\tReceiver: &ArrayDerefNode{\n\t\t\t\t\t\t\t\t\t\t\tReceiver: &VariableNode{Name: \"x\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tProperty: \"y\",\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t&StringNode{Value: \", \"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t&StringNode{Value: \"bar\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested dereferences\",\n\t\t\tinput: \"contains(github.event['issue'].labels.*.name, 'bug')\",\n\t\t\texpected: &FuncCallNode{\n\t\t\t\tCallee: \"contains\",\n\t\t\t\tArgs: []ExprNode{\n\t\t\t\t\t&ObjectDerefNode{\n\t\t\t\t\t\tProperty: \"name\",\n\t\t\t\t\t\tReceiver: &ArrayDerefNode{\n\t\t\t\t\t\t\tReceiver: &ObjectDerefNode{\n\t\t\t\t\t\t\t\tProperty: \"labels\",\n\t\t\t\t\t\t\t\tReceiver: &IndexAccessNode{\n\t\t\t\t\t\t\t\t\tIndex: &StringNode{Value: \"issue\"},\n\t\t\t\t\t\t\t\t\tOperand: &ObjectDerefNode{\n\t\t\t\t\t\t\t\t\t\tProperty: \"event\",\n\t\t\t\t\t\t\t\t\t\tReceiver: &VariableNode{Name: \"github\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\t&StringNode{Value: \"bug\"},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested dereferences with nested expressions\",\n\t\t\tinput: \"(((((github.event)['issue']).labels).*).name)\",\n\t\t\texpected: &ObjectDerefNode{\n\t\t\t\tProperty: \"name\",\n\t\t\t\tReceiver: &ArrayDerefNode{\n\t\t\t\t\tReceiver: &ObjectDerefNode{\n\t\t\t\t\t\tProperty: \"labels\",\n\t\t\t\t\t\tReceiver: &IndexAccessNode{\n\t\t\t\t\t\t\tIndex: &StringNode{Value: \"issue\"},\n\t\t\t\t\t\t\tOperand: &ObjectDerefNode{\n\t\t\t\t\t\t\t\tProperty: \"event\",\n\t\t\t\t\t\t\t\tReceiver: &VariableNode{Name: \"github\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\topts := []cmp.Option{\n\t\tcmpopts.IgnoreUnexported(VariableNode{}),\n\t\tcmpopts.IgnoreUnexported(NullNode{}),\n\t\tcmpopts.IgnoreUnexported(BoolNode{}),\n\t\tcmpopts.IgnoreUnexported(IntNode{}),\n\t\tcmpopts.IgnoreUnexported(FloatNode{}),\n\t\tcmpopts.IgnoreUnexported(StringNode{}),\n\t\tcmpopts.IgnoreUnexported(ObjectDerefNode{}),\n\t\tcmpopts.IgnoreUnexported(ArrayDerefNode{}),\n\t\tcmpopts.IgnoreUnexported(IndexAccessNode{}),\n\t\tcmpopts.IgnoreUnexported(NotOpNode{}),\n\t\tcmpopts.IgnoreUnexported(CompareOpNode{}),\n\t\tcmpopts.IgnoreUnexported(LogicalOpNode{}),\n\t\tcmpopts.IgnoreUnexported(FuncCallNode{}),\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tp := NewExprParser()\n\t\t\tn, err := p.Parse(NewExprLexer(tc.input + \"}}\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Parse error:\", err)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.expected, n, opts...); diff != \"\" {\n\t\t\t\tt.Fatalf(\"wanted:\\n%#v\\n\\nbut got:\\n%#v\\n\\ndiff:\\n%s\\n\", tc.expected, n, diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseExpressionSyntaxError(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat     string\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\n\t\t\twhat:     \"remaining inputs\",\n\t\t\tinput:    \"42 foo bar\",\n\t\t\texpected: \"2 remaining token(s) in the input: \\\"IDENT\\\", \\\"IDENT\\\"\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in || operator\",\n\t\t\tinput:    \"true ||\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in && operator\",\n\t\t\tinput:    \"true &&\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in < operator\",\n\t\t\tinput:    \"0 <\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in <= operator\",\n\t\t\tinput:    \"0 <=\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in > operator\",\n\t\t\tinput:    \"0 >\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in >= operator\",\n\t\t\tinput:    \"0 >=\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in == operator\",\n\t\t\tinput:    \"0 ==\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand in != operator\",\n\t\t\tinput:    \"0 !=\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand after ! operator\",\n\t\t\tinput:    \"!\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing operand after . operator\",\n\t\t\tinput:    \"foo.\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"ident must come after .\",\n\t\t\tinput:    \"foo.42\",\n\t\t\texpected: \"unexpected token \\\"INTEGER\\\" while parsing object property dereference\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"broken index access part1\",\n\t\t\tinput:    \"foo[0\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"broken index access part2\",\n\t\t\tinput:    \"foo[\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"unexpected closing at index access\",\n\t\t\tinput:    \"foo[0)\",\n\t\t\texpected: \"unexpected token \\\")\\\" while parsing closing bracket ']' for index access\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"starting with invalid token\",\n\t\t\tinput:    \"[\",\n\t\t\texpected: \"unexpected token \\\"[\\\" while parsing variable access, function call, null, bool, int, float or string\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing closing ) for nested expression\",\n\t\t\tinput:    \"(a\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"invalid token at closing nested expression\",\n\t\t\tinput:    \"(a]\",\n\t\t\texpected: \"unexpected token \\\"]\\\" while parsing closing ')'\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"unexpected end of input while function call part1\",\n\t\t\tinput:    \"foo(\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"unexpected end of input while function call part2\",\n\t\t\tinput:    \"foo(0\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"unexpected end of input while function call part3\",\n\t\t\tinput:    \"foo(0,\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"unexpected end of input while function call part4\",\n\t\t\tinput:    \"foo(0, a\",\n\t\t\texpected: \"unexpected end of input\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"unexpected closing at function call\",\n\t\t\tinput:    \"foo(0]\",\n\t\t\texpected: \"unexpected token \\\"]\\\" while parsing arguments of function call\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"error while parsing nested expression\",\n\t\t\tinput:    \"([\",\n\t\t\texpected: \"unexpected token \\\"[\\\"\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"empty expression\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"unexpected end of input while parsing\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tp := NewExprParser()\n\t\t\t_, err := p.Parse(NewExprLexer(tc.input + \"}}\"))\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Parse error did not occur:\", tc.input)\n\t\t\t}\n\n\t\t\tif !strings.Contains(err.Error(), tc.expected) {\n\t\t\t\tt.Fatalf(\"error message %q does not contain expected string %q\", err.Error(), tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseExpressionNumberLiteralsError(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat  string\n\t\ttok   *Token\n\t\tparse func(*ExprParser) ExprNode\n\t}{\n\t\t{\n\t\t\twhat: \"integer literal\",\n\t\t\ttok: &Token{\n\t\t\t\tKind:  TokenKindInt,\n\t\t\t\tValue: \"abc\",\n\t\t\t},\n\t\t\tparse: func(p *ExprParser) ExprNode {\n\t\t\t\treturn p.parseInt()\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"float literal\",\n\t\t\ttok: &Token{\n\t\t\t\tKind:  TokenKindFloat,\n\t\t\t\tValue: \"abc\",\n\t\t\t},\n\t\t\tparse: func(p *ExprParser) ExprNode {\n\t\t\t\treturn p.parseFloat()\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\t// This is really hacky depending on internal structure of parser. It is necessary\n\t\t\t// because parsing int/float token never fails. To check the error handling, we need to\n\t\t\t// inject an invalid token.\n\t\t\tp := NewExprParser()\n\t\t\tp.cur = tc.tok\n\t\t\ttc.parse(p)\n\t\t\terr := p.err\n\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Parse error did not occur:\", tc.tok.Value)\n\t\t\t}\n\t\t\twant := fmt.Sprintf(\"parsing invalid %s\", tc.what)\n\t\t\tif !strings.Contains(err.Error(), want) {\n\t\t\t\tt.Fatalf(\"error message %q does not contain %q\", err.Error(), want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseExpressionTokenPosition(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat   string\n\t\tinput  string\n\t\toffset int\n\t}{\n\t\t{\n\t\t\twhat:  \"null\",\n\t\t\tinput: \"null\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"bool literal\",\n\t\t\tinput: \"true\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"variable\",\n\t\t\tinput: \"foo\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"function call\",\n\t\t\tinput: \"foo(1, 2, 3)\",\n\t\t},\n\t\t{\n\t\t\twhat:   \"nested expression\",\n\t\t\tinput:  \"(42)\",\n\t\t\toffset: 1,\n\t\t},\n\t\t{\n\t\t\twhat:  \"int\",\n\t\t\tinput: \"-10\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"float\",\n\t\t\tinput: \"-1.0e3\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"object property dereference\",\n\t\t\tinput: \"github.issue.label.name\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"array element dereference\",\n\t\t\tinput: \"labels.*\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access\",\n\t\t\tinput: \"arr[idx]\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"! op\",\n\t\t\tinput: \"!true\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"< op\",\n\t\t\tinput: \"0 < 1\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"<= op\",\n\t\t\tinput: \"0 <= 1\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"> op\",\n\t\t\tinput: \"0 > 1\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"== op\",\n\t\t\tinput: \"0 == 1\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"!= op\",\n\t\t\tinput: \"0 != 1\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"&& op\",\n\t\t\tinput: \"true && false\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"|| op\",\n\t\t\tinput: \"true || false\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\t// Add 2 spaces so start position of token must be offset 2\n\t\t\tp := NewExprParser()\n\t\t\te, err := p.Parse(NewExprLexer(\"  \" + tc.input + \"}}\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Parse error:\", err)\n\t\t\t}\n\n\t\t\toffset := tc.offset + len(\"  \")\n\n\t\t\tgot := e.Token()\n\t\t\t// Offset is 0-based\n\t\t\tif got.Offset != offset {\n\t\t\t\tt.Error(\"Offset of token of parsed node was not 2:\", got)\n\t\t\t}\n\t\t\t// Line is 1-based\n\t\t\tif got.Line != 1 {\n\t\t\t\tt.Error(\"Line of token of parsed node was not 0:\", got)\n\t\t\t}\n\t\t\t// Column is 1-based\n\t\t\tif got.Column != offset+1 {\n\t\t\t\tt.Error(\"Column of token of parsed node was not 2:\", got)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestParseReturnFirstErrorOnMultipleErrors(t *testing.T) {\n\tp := NewExprParser()\n\t_, want := p.Parse(NewExprLexer(\".}}\"))\n\tif want == nil {\n\t\tt.Fatal(\"error did not occur\")\n\t}\n\tp.unexpected(\"foo\", nil)\n\thave := p.Err()\n\tif want != have {\n\t\tt.Fatalf(\"first error %q was expected but got %q\", want, have)\n\t}\n}\n"
        },
        {
          "name": "expr_sema.go",
          "type": "blob",
          "size": 31.5673828125,
          "content": "package actionlint\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc ordinal(i int) string {\n\tsuffix := \"th\"\n\tswitch i % 10 {\n\tcase 1:\n\t\tif i%100 != 11 {\n\t\t\tsuffix = \"st\"\n\t\t}\n\tcase 2:\n\t\tif i%100 != 12 {\n\t\t\tsuffix = \"nd\"\n\t\t}\n\tcase 3:\n\t\tif i%100 != 13 {\n\t\t\tsuffix = \"rd\"\n\t\t}\n\t}\n\treturn fmt.Sprintf(\"%d%s\", i, suffix)\n}\n\n// parseFormatFuncSpecifiers parses the format string passed to `format()` calls.\n// https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/evaluate-expressions-in-workflows-and-actions#format\nfunc parseFormatFuncSpecifiers(f string, n int) map[int]struct{} {\n\tret := make(map[int]struct{}, n)\n\tstart := -1\n\tfor i, r := range f {\n\t\tif r == '{' {\n\t\t\tif start == i {\n\t\t\t\tstart = -1 // When the '{' is escaped like '{{'\n\t\t\t} else {\n\t\t\t\tstart = i + 1 // `+ 1` because `i` points char '{'\n\t\t\t}\n\t\t} else if start >= 0 {\n\t\t\tif '0' <= r && r <= '9' {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif r == '}' && start < i {\n\t\t\t\ti, _ := strconv.Atoi(f[start:i])\n\t\t\t\tret[i] = struct{}{}\n\t\t\t}\n\t\t\tstart = -1 // Done\n\t\t}\n\t}\n\treturn ret\n}\n\n// Functions\n\n// FuncSignature is a signature of function, which holds return and arguments types.\ntype FuncSignature struct {\n\t// Name is a name of the function.\n\tName string\n\t// Ret is a return type of the function.\n\tRet ExprType\n\t// Params is a list of parameter types of the function. The final element of this list might\n\t// be repeated as variable length arguments.\n\tParams []ExprType\n\t// VariableLengthParams is a flag to handle variable length parameters. When this flag is set to\n\t// true, it means that the last type of params might be specified multiple times (including zero\n\t// times). Setting true implies length of Params is more than 0.\n\tVariableLengthParams bool\n}\n\nfunc (sig *FuncSignature) String() string {\n\tts := make([]string, 0, len(sig.Params))\n\tfor _, p := range sig.Params {\n\t\tts = append(ts, p.String())\n\t}\n\telip := \"\"\n\tif sig.VariableLengthParams {\n\t\telip = \"...\"\n\t}\n\treturn fmt.Sprintf(\"%s(%s%s) -> %s\", sig.Name, strings.Join(ts, \", \"), elip, sig.Ret.String())\n}\n\n// BuiltinFuncSignatures is a set of all builtin function signatures. All function names are in\n// lower case because function names are compared in case insensitive.\n// https://docs.github.com/en/actions/learn-github-actions/expressions#functions\nvar BuiltinFuncSignatures = map[string][]*FuncSignature{\n\t\"contains\": {\n\t\t{\n\t\t\tName: \"contains\",\n\t\t\tRet:  BoolType{},\n\t\t\tParams: []ExprType{\n\t\t\t\tStringType{},\n\t\t\t\tStringType{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\tName: \"contains\",\n\t\t\tRet:  BoolType{},\n\t\t\tParams: []ExprType{\n\t\t\t\t&ArrayType{Elem: AnyType{}},\n\t\t\t\tAnyType{},\n\t\t\t},\n\t\t},\n\t},\n\t\"startswith\": {\n\t\t{\n\t\t\tName: \"startsWith\",\n\t\t\tRet:  BoolType{},\n\t\t\tParams: []ExprType{\n\t\t\t\tStringType{},\n\t\t\t\tStringType{},\n\t\t\t},\n\t\t},\n\t},\n\t\"endswith\": {\n\t\t{\n\t\t\tName: \"endsWith\",\n\t\t\tRet:  BoolType{},\n\t\t\tParams: []ExprType{\n\t\t\t\tStringType{},\n\t\t\t\tStringType{},\n\t\t\t},\n\t\t},\n\t},\n\t\"format\": {\n\t\t{\n\t\t\tName: \"format\",\n\t\t\tRet:  StringType{},\n\t\t\tParams: []ExprType{\n\t\t\t\tStringType{},\n\t\t\t\tAnyType{}, // variable length\n\t\t\t},\n\t\t\tVariableLengthParams: true,\n\t\t},\n\t},\n\t\"join\": {\n\t\t{\n\t\t\tName: \"join\",\n\t\t\tRet:  StringType{},\n\t\t\tParams: []ExprType{\n\t\t\t\t&ArrayType{Elem: StringType{}},\n\t\t\t\tStringType{},\n\t\t\t},\n\t\t},\n\t\t// When the second parameter is omitted, values are concatenated with ','.\n\t\t{\n\t\t\tName: \"join\",\n\t\t\tRet:  StringType{},\n\t\t\tParams: []ExprType{\n\t\t\t\t&ArrayType{Elem: StringType{}},\n\t\t\t},\n\t\t},\n\t},\n\t\"tojson\": {{\n\t\tName: \"toJSON\",\n\t\tRet:  StringType{},\n\t\tParams: []ExprType{\n\t\t\tAnyType{},\n\t\t},\n\t}},\n\t\"fromjson\": {{\n\t\tName: \"fromJSON\",\n\t\tRet:  AnyType{},\n\t\tParams: []ExprType{\n\t\t\tStringType{},\n\t\t},\n\t}},\n\t\"hashfiles\": {{\n\t\tName: \"hashFiles\",\n\t\tRet:  StringType{},\n\t\tParams: []ExprType{\n\t\t\tStringType{},\n\t\t},\n\t\tVariableLengthParams: true,\n\t}},\n\t\"success\": {{\n\t\tName:   \"success\",\n\t\tRet:    BoolType{},\n\t\tParams: []ExprType{},\n\t}},\n\t\"always\": {{\n\t\tName:   \"always\",\n\t\tRet:    BoolType{},\n\t\tParams: []ExprType{},\n\t}},\n\t\"cancelled\": {{\n\t\tName:   \"cancelled\",\n\t\tRet:    BoolType{},\n\t\tParams: []ExprType{},\n\t}},\n\t\"failure\": {{\n\t\tName:   \"failure\",\n\t\tRet:    BoolType{},\n\t\tParams: []ExprType{},\n\t}},\n}\n\n// Global variables\n\n// BuiltinGlobalVariableTypes defines types of all global variables. All context variables are\n// documented at https://docs.github.com/en/actions/learn-github-actions/contexts\nvar BuiltinGlobalVariableTypes = map[string]ExprType{\n\t// https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/accessing-contextual-information-about-workflow-runs#github-context\n\t\"github\": NewStrictObjectType(map[string]ExprType{\n\t\t\"action\":                    StringType{},\n\t\t\"action_path\":               StringType{}, // Note: Composite actions only\n\t\t\"action_ref\":                StringType{},\n\t\t\"action_repository\":         StringType{},\n\t\t\"action_status\":             StringType{}, // Note: Composite actions only\n\t\t\"actor\":                     StringType{},\n\t\t\"actor_id\":                  StringType{},\n\t\t\"api_url\":                   StringType{},\n\t\t\"artifact_cache_size_limit\": NumberType{}, // Note: Undocumented\n\t\t\"base_ref\":                  StringType{},\n\t\t\"env\":                       StringType{},\n\t\t\"event\":                     NewEmptyObjectType(), // Note: Stricter type check for this payload would be possible\n\t\t\"event_name\":                StringType{},\n\t\t\"event_path\":                StringType{},\n\t\t\"graphql_url\":               StringType{},\n\t\t\"head_ref\":                  StringType{},\n\t\t\"job\":                       StringType{},\n\t\t\"output\":                    StringType{}, // Note: Undocumented\n\t\t\"path\":                      StringType{},\n\t\t\"ref\":                       StringType{},\n\t\t\"ref_name\":                  StringType{},\n\t\t\"ref_protected\":             BoolType{},\n\t\t\"ref_type\":                  StringType{},\n\t\t\"repository\":                StringType{},\n\t\t\"repository_id\":             StringType{},\n\t\t\"repository_owner\":          StringType{},\n\t\t\"repository_owner_id\":       StringType{},\n\t\t\"repository_visibility\":     StringType{}, // Note: Undocumented\n\t\t\"repositoryurl\":             StringType{}, // repositoryUrl\n\t\t\"retention_days\":            NumberType{},\n\t\t\"run_attempt\":               StringType{},\n\t\t\"run_id\":                    StringType{},\n\t\t\"run_number\":                StringType{},\n\t\t\"secret_source\":             StringType{},\n\t\t\"server_url\":                StringType{},\n\t\t\"sha\":                       StringType{},\n\t\t\"state\":                     StringType{}, // Note: Undocumented\n\t\t\"step_summary\":              StringType{}, // Note: Undocumented\n\t\t\"token\":                     StringType{},\n\t\t\"triggering_actor\":          StringType{},\n\t\t\"workflow\":                  StringType{},\n\t\t\"workflow_ref\":              StringType{},\n\t\t\"workflow_sha\":              StringType{},\n\t\t\"workspace\":                 StringType{},\n\t}),\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#env-context\n\t\"env\": NewMapObjectType(StringType{}), // env.<env_name>\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#job-context\n\t\"job\": NewStrictObjectType(map[string]ExprType{\n\t\t\"container\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\"id\":      StringType{},\n\t\t\t\"network\": StringType{},\n\t\t}),\n\t\t\"services\": NewMapObjectType(\n\t\t\tNewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"id\":      StringType{}, // job.services.<service id>.id\n\t\t\t\t\"network\": StringType{},\n\t\t\t\t\"ports\":   NewMapObjectType(StringType{}),\n\t\t\t}),\n\t\t),\n\t\t\"status\": StringType{},\n\t}),\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#steps-context\n\t\"steps\": NewEmptyStrictObjectType(), // This value will be updated contextually\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#runner-context\n\t\"runner\": NewStrictObjectType(map[string]ExprType{\n\t\t\"name\":        StringType{},\n\t\t\"os\":          StringType{},\n\t\t\"arch\":        StringType{},\n\t\t\"temp\":        StringType{},\n\t\t\"tool_cache\":  StringType{},\n\t\t\"debug\":       StringType{},\n\t\t\"environment\": StringType{}, // https://github.com/github/docs/issues/32443\n\t}),\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#secrets-context\n\t\"secrets\": NewMapObjectType(StringType{}),\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#strategy-context\n\t\"strategy\": NewObjectType(map[string]ExprType{\n\t\t\"fail-fast\":    BoolType{},\n\t\t\"job-index\":    NumberType{},\n\t\t\"job-total\":    NumberType{},\n\t\t\"max-parallel\": NumberType{},\n\t}),\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#matrix-context\n\t\"matrix\": NewEmptyStrictObjectType(), // This value will be updated contextually\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context\n\t\"needs\": NewEmptyStrictObjectType(), // This value will be updated contextually\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#inputs-context\n\t// https://docs.github.com/en/actions/learn-github-actions/reusing-workflows\n\t\"inputs\": NewEmptyStrictObjectType(),\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#vars-context\n\t\"vars\": NewMapObjectType(StringType{}), // vars.<var_name>\n}\n\n// Semantics checker\n\n// ExprSemanticsChecker is a semantics checker for expression syntax. It checks types of values\n// in given expression syntax tree. It additionally checks other semantics like arguments of\n// format() built-in function. To know the details of the syntax, see\n//\n// - https://docs.github.com/en/actions/learn-github-actions/contexts\n// - https://docs.github.com/en/actions/learn-github-actions/expressions\ntype ExprSemanticsChecker struct {\n\tfuncs                 map[string][]*FuncSignature\n\tvars                  map[string]ExprType\n\terrs                  []*ExprError\n\tvarsCopied            bool\n\tgithubVarCopied       bool\n\tuntrusted             *UntrustedInputChecker\n\tavailableContexts     []string\n\tavailableSpecialFuncs []string\n\tconfigVars            []string\n}\n\n// NewExprSemanticsChecker creates new ExprSemanticsChecker instance. When checkUntrustedInput is\n// set to true, the checker will make use of possibly untrusted inputs error.\nfunc NewExprSemanticsChecker(checkUntrustedInput bool, configVars []string) *ExprSemanticsChecker {\n\tc := &ExprSemanticsChecker{\n\t\tfuncs:           BuiltinFuncSignatures,\n\t\tvars:            BuiltinGlobalVariableTypes,\n\t\tvarsCopied:      false,\n\t\tgithubVarCopied: false,\n\t\tconfigVars:      configVars,\n\t}\n\tif checkUntrustedInput {\n\t\tc.untrusted = NewUntrustedInputChecker(BuiltinUntrustedInputs)\n\t}\n\treturn c\n}\n\nfunc errorAtExpr(e ExprNode, msg string) *ExprError {\n\tt := e.Token()\n\treturn &ExprError{\n\t\tMessage: msg,\n\t\tOffset:  t.Offset,\n\t\tLine:    t.Line,\n\t\tColumn:  t.Column,\n\t}\n}\n\nfunc errorfAtExpr(e ExprNode, format string, args ...interface{}) *ExprError {\n\treturn errorAtExpr(e, fmt.Sprintf(format, args...))\n}\n\nfunc (sema *ExprSemanticsChecker) errorf(e ExprNode, format string, args ...interface{}) {\n\tsema.errs = append(sema.errs, errorfAtExpr(e, format, args...))\n}\n\nfunc (sema *ExprSemanticsChecker) ensureVarsCopied() {\n\tif sema.varsCopied {\n\t\treturn\n\t}\n\n\t// Make shallow copy of current variables map not to pollute global variable\n\tcopied := make(map[string]ExprType, len(sema.vars))\n\tfor k, v := range sema.vars {\n\t\tcopied[k] = v\n\t}\n\tsema.vars = copied\n\tsema.varsCopied = true\n}\n\nfunc (sema *ExprSemanticsChecker) ensureGithubVarCopied() {\n\tif sema.githubVarCopied {\n\t\treturn\n\t}\n\tsema.ensureVarsCopied()\n\n\tsema.vars[\"github\"] = sema.vars[\"github\"].DeepCopy()\n}\n\n// UpdateMatrix updates matrix object to given object type. Since matrix values change according to\n// 'matrix' section of job configuration, the type needs to be updated.\nfunc (sema *ExprSemanticsChecker) UpdateMatrix(ty *ObjectType) {\n\tsema.ensureVarsCopied()\n\tsema.vars[\"matrix\"] = ty\n}\n\n// UpdateSteps updates 'steps' context object to given object type.\nfunc (sema *ExprSemanticsChecker) UpdateSteps(ty *ObjectType) {\n\tsema.ensureVarsCopied()\n\tsema.vars[\"steps\"] = ty\n}\n\n// UpdateNeeds updates 'needs' context object to given object type.\nfunc (sema *ExprSemanticsChecker) UpdateNeeds(ty *ObjectType) {\n\tsema.ensureVarsCopied()\n\tsema.vars[\"needs\"] = ty\n}\n\n// UpdateSecrets updates 'secrets' context object to given object type.\nfunc (sema *ExprSemanticsChecker) UpdateSecrets(ty *ObjectType) {\n\tsema.ensureVarsCopied()\n\n\t// Merges automatically supplied secrets with manually defined secrets.\n\t// ACTIONS_STEP_DEBUG and ACTIONS_RUNNER_DEBUG seem supplied from caller of the workflow (#130)\n\tcopied := NewStrictObjectType(map[string]ExprType{\n\t\t\"github_token\":         StringType{},\n\t\t\"actions_step_debug\":   StringType{},\n\t\t\"actions_runner_debug\": StringType{},\n\t})\n\tfor n, v := range ty.Props {\n\t\tcopied.Props[n] = v\n\t}\n\tsema.vars[\"secrets\"] = copied\n}\n\n// UpdateInputs updates 'inputs' context object to given object type.\nfunc (sema *ExprSemanticsChecker) UpdateInputs(ty *ObjectType) {\n\tsema.ensureVarsCopied()\n\to := sema.vars[\"inputs\"].(*ObjectType)\n\tif len(o.Props) == 0 && o.IsStrict() {\n\t\tsema.vars[\"inputs\"] = ty\n\t\treturn\n\t}\n\t// When both `workflow_call` and `workflow_dispatch` are the triggers of the workflow, `inputs` context can be used\n\t// by both events. To cover both cases, merge `inputs` contexts into one object type. (#263)\n\tsema.vars[\"inputs\"] = o.Merge(ty)\n}\n\n// UpdateDispatchInputs updates 'github.event.inputs' and 'inputs' objects to given object type.\n// https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#workflow_dispatch\nfunc (sema *ExprSemanticsChecker) UpdateDispatchInputs(ty *ObjectType) {\n\tsema.UpdateInputs(ty)\n\n\t// Update `github.event.inputs`.\n\t// Unlike `inputs.*`, type of `github.event.inputs.*` is always string unlike `inputs.*`. We need\n\t// to create a new type from `ty` (e.g. {foo: boolean, bar: number} -> {foo: string, bar: string})\n\n\tp := make(map[string]ExprType, len(ty.Props))\n\tfor n := range ty.Props {\n\t\tp[n] = StringType{}\n\t}\n\tty = NewStrictObjectType(p)\n\n\tsema.ensureGithubVarCopied()\n\tsema.vars[\"github\"].(*ObjectType).Props[\"event\"].(*ObjectType).Props[\"inputs\"] = ty\n}\n\n// UpdateJobs updates 'jobs' context object to given object type.\nfunc (sema *ExprSemanticsChecker) UpdateJobs(ty *ObjectType) {\n\tsema.ensureVarsCopied()\n\tsema.vars[\"jobs\"] = ty\n}\n\n// SetContextAvailability sets available context names while semantics checks. Some contexts limit\n// where they can be used.\n// https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability\n//\n// Elements of 'avail' parameter must be in lower case to check context names in case-insensitive.\n//\n// If this method is not called before checks, ExprSemanticsChecker considers any contexts are\n// available by default.\n// Available contexts for workflow keys can be obtained from actionlint.ContextAvailability.\nfunc (sema *ExprSemanticsChecker) SetContextAvailability(avail []string) {\n\tsema.availableContexts = avail\n}\n\nfunc (sema *ExprSemanticsChecker) checkAvailableContext(n *VariableNode) {\n\tctx := strings.ToLower(n.Name)\n\tfor _, c := range sema.availableContexts {\n\t\tif c == ctx {\n\t\t\treturn\n\t\t}\n\t}\n\n\tvar notes string\n\tswitch len(sema.availableContexts) {\n\tcase 0:\n\t\tnotes = \"no context is available here\"\n\tcase 1:\n\t\tnotes = \"available context is \" + quotes(sema.availableContexts)\n\tdefault:\n\t\tnotes = \"available contexts are \" + quotes(sema.availableContexts)\n\t}\n\tsema.errorf(\n\t\tn,\n\t\t\"context %q is not allowed here. %s. see https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability for more details\",\n\t\tn.Name,\n\t\tnotes,\n\t)\n}\n\n// SetSpecialFunctionAvailability sets names of available special functions while semantics checks.\n// Some functions limit where they can be used.\n// https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability\n//\n// Elements of 'avail' parameter must be in lower case to check function names in case-insensitive.\n//\n// If this method is not called before checks, ExprSemanticsChecker considers no special function is\n// allowed by default. Allowed functions can be obtained from actionlint.SpecialFunctionNames global\n// constant.\n//\n// Available function names for workflow keys can be obtained from actionlint.ContextAvailability.\nfunc (sema *ExprSemanticsChecker) SetSpecialFunctionAvailability(avail []string) {\n\tsema.availableSpecialFuncs = avail\n}\n\nfunc (sema *ExprSemanticsChecker) checkSpecialFunctionAvailability(n *FuncCallNode) {\n\tf := strings.ToLower(n.Callee)\n\n\tallowed, ok := SpecialFunctionNames[f]\n\tif !ok {\n\t\treturn // This function is not special\n\t}\n\n\tfor _, sp := range sema.availableSpecialFuncs {\n\t\tif sp == f {\n\t\t\treturn\n\t\t}\n\t}\n\n\tsema.errorf(\n\t\tn,\n\t\t\"calling function %q is not allowed here. %q is only available in %s. see https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability for more details\",\n\t\tn.Callee,\n\t\tn.Callee,\n\t\tquotes(allowed),\n\t)\n}\n\nfunc (sema *ExprSemanticsChecker) visitUntrustedCheckerOnEnterNode(n ExprNode) {\n\tif sema.untrusted != nil {\n\t\tsema.untrusted.OnVisitNodeEnter(n)\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) visitUntrustedCheckerOnLeaveNode(n ExprNode) {\n\tif sema.untrusted != nil {\n\t\tsema.untrusted.OnVisitNodeLeave(n)\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) checkVariable(n *VariableNode) ExprType {\n\tv, ok := sema.vars[n.Name]\n\tif !ok {\n\t\tss := make([]string, 0, len(sema.vars))\n\t\tfor n := range sema.vars {\n\t\t\tss = append(ss, n)\n\t\t}\n\t\tsema.errorf(n, \"undefined variable %q. available variables are %s\", n.Token().Value, sortedQuotes(ss))\n\t\treturn AnyType{}\n\t}\n\n\tsema.checkAvailableContext(n)\n\treturn v\n}\n\nfunc (sema *ExprSemanticsChecker) checkObjectDeref(n *ObjectDerefNode) ExprType {\n\tswitch ty := sema.check(n.Receiver).(type) {\n\tcase AnyType:\n\t\treturn AnyType{}\n\tcase *ObjectType:\n\t\tif t, ok := ty.Props[n.Property]; ok {\n\t\t\treturn t\n\t\t}\n\t\tif ty.Mapped != nil {\n\t\t\tif v, ok := n.Receiver.(*VariableNode); ok && v.Name == \"vars\" {\n\t\t\t\tsema.checkConfigVariables(n)\n\t\t\t}\n\t\t\treturn ty.Mapped\n\t\t}\n\t\tif ty.IsStrict() {\n\t\t\tsema.errorf(n, \"property %q is not defined in object type %s\", n.Property, ty.String())\n\t\t}\n\t\treturn AnyType{}\n\tcase *ArrayType:\n\t\tif !ty.Deref {\n\t\t\tsema.errorf(n, \"receiver of object dereference %q must be type of object but got %q\", n.Property, ty.String())\n\t\t\treturn AnyType{}\n\t\t}\n\t\tswitch et := ty.Elem.(type) {\n\t\tcase AnyType:\n\t\t\t// When element type is any, map the any type to any. Reuse `ty`\n\t\t\treturn ty\n\t\tcase *ObjectType:\n\t\t\t// Map element type of delererenced array\n\t\t\tvar elem ExprType = AnyType{}\n\t\t\tif t, ok := et.Props[n.Property]; ok {\n\t\t\t\telem = t\n\t\t\t} else if et.Mapped != nil {\n\t\t\t\telem = et.Mapped\n\t\t\t} else if et.IsStrict() {\n\t\t\t\tsema.errorf(n, \"property %q is not defined in object type %s as element of filtered array\", n.Property, et.String())\n\t\t\t}\n\t\t\treturn &ArrayType{elem, true}\n\t\tdefault:\n\t\t\tsema.errorf(\n\t\t\t\tn,\n\t\t\t\t\"property filtered by %q at object filtering must be type of object but got %q\",\n\t\t\t\tn.Property,\n\t\t\t\tty.Elem.String(),\n\t\t\t)\n\t\t\treturn AnyType{}\n\t\t}\n\tdefault:\n\t\tsema.errorf(n, \"receiver of object dereference %q must be type of object but got %q\", n.Property, ty.String())\n\t\treturn AnyType{}\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) checkConfigVariables(n *ObjectDerefNode) {\n\t// https://docs.github.com/en/actions/learn-github-actions/variables#naming-conventions-for-configuration-variables\n\tif strings.HasPrefix(n.Property, \"github_\") {\n\t\tsema.errorf(\n\t\t\tn,\n\t\t\t\"configuration variable name %q must not start with the GITHUB_ prefix (case insensitive). note: see the convention at https://docs.github.com/en/actions/learn-github-actions/variables#naming-conventions-for-configuration-variables\",\n\t\t\tn.Property,\n\t\t)\n\t\treturn\n\t}\n\tfor _, r := range n.Property {\n\t\t// Note: `n.Property` was already converted to lower case by parser\n\t\t// Note: First character cannot be number, but it was already checked by parser\n\t\tif '0' <= r && r <= '9' || 'a' <= r && r <= 'z' || r == '_' {\n\t\t\tcontinue\n\t\t}\n\t\tsema.errorf(\n\t\t\tn,\n\t\t\t\"configuration variable name %q can only contain alphabets, decimal numbers, and '_'. note: see the convention at https://docs.github.com/en/actions/learn-github-actions/variables#naming-conventions-for-configuration-variables\",\n\t\t\tn.Property,\n\t\t)\n\t\treturn\n\t}\n\n\tif sema.configVars == nil {\n\t\treturn\n\t}\n\tif len(sema.configVars) == 0 {\n\t\tsema.errorf(\n\t\t\tn,\n\t\t\t\"no configuration variable is allowed since the variables list is empty in actionlint.yaml. you may forget adding the variable %q to the list\",\n\t\t\tn.Property,\n\t\t)\n\t\treturn\n\t}\n\n\tfor _, v := range sema.configVars {\n\t\tif strings.EqualFold(v, n.Property) {\n\t\t\treturn\n\t\t}\n\t}\n\n\tsema.errorf(\n\t\tn,\n\t\t\"undefined configuration variable %q. defined configuration variables in actionlint.yaml are %s\",\n\t\tn.Property,\n\t\tsortedQuotes(sema.configVars),\n\t)\n}\n\nfunc (sema *ExprSemanticsChecker) checkArrayDeref(n *ArrayDerefNode) ExprType {\n\tswitch ty := sema.check(n.Receiver).(type) {\n\tcase AnyType:\n\t\treturn &ArrayType{AnyType{}, true}\n\tcase *ArrayType:\n\t\tty.Deref = true\n\t\treturn ty\n\tcase *ObjectType:\n\t\t// Object filtering is available for objects, not only arrays (#66)\n\n\t\tif ty.Mapped != nil {\n\t\t\t// For map object or loose object at receiver of .*\n\t\t\tswitch mty := ty.Mapped.(type) {\n\t\t\tcase AnyType:\n\t\t\t\treturn &ArrayType{AnyType{}, true}\n\t\t\tcase *ObjectType:\n\t\t\t\treturn &ArrayType{mty, true}\n\t\t\tdefault:\n\t\t\t\tsema.errorf(n, \"elements of object at receiver of object filtering `.*` must be type of object but got %q. the type of receiver was %q\", mty.String(), ty.String())\n\t\t\t\treturn AnyType{}\n\t\t\t}\n\t\t}\n\n\t\t// For strict object at receiver of .*\n\t\tfound := false\n\t\tfor _, t := range ty.Props {\n\t\t\tif _, ok := t.(*ObjectType); ok {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\tsema.errorf(n, \"object type %q cannot be filtered by object filtering `.*` since it has no object element\", ty.String())\n\t\t\treturn AnyType{}\n\t\t}\n\n\t\treturn &ArrayType{AnyType{}, true}\n\tdefault:\n\t\tsema.errorf(n, \"receiver of object filtering `.*` must be type of array or object but got %q\", ty.String())\n\t\treturn AnyType{}\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) checkIndexAccess(n *IndexAccessNode) ExprType {\n\t// Note: Index must be visited before Index to make UntrustedInputChecker work correctly even if\n\t// the expression has some nest like foo[aaa.bbb].bar. Nest happens in top-down order and\n\t// properties/indices access check is done in bottom-up order. So, as far as we visit nested\n\t// index nodes before visiting operand, the index is recursively checked first.\n\tidx := sema.check(n.Index)\n\n\tswitch ty := sema.check(n.Operand).(type) {\n\tcase AnyType:\n\t\treturn AnyType{}\n\tcase *ArrayType:\n\t\tswitch idx.(type) {\n\t\tcase AnyType, NumberType:\n\t\t\treturn ty.Elem\n\t\tdefault:\n\t\t\tsema.errorf(n.Index, \"index access of array must be type of number but got %q\", idx.String())\n\t\t\treturn AnyType{}\n\t\t}\n\tcase *ObjectType:\n\t\tswitch idx.(type) {\n\t\tcase AnyType:\n\t\t\treturn AnyType{}\n\t\tcase StringType:\n\t\t\t// Index access with string literal like foo['bar']\n\t\t\tif lit, ok := n.Index.(*StringNode); ok {\n\t\t\t\tif prop, ok := ty.Props[lit.Value]; ok {\n\t\t\t\t\treturn prop\n\t\t\t\t}\n\t\t\t\tif ty.Mapped != nil {\n\t\t\t\t\treturn ty.Mapped\n\t\t\t\t}\n\t\t\t\tif ty.IsStrict() {\n\t\t\t\t\tsema.errorf(n, \"property %q is not defined in object type %s\", lit.Value, ty.String())\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ty.Mapped != nil {\n\t\t\t\treturn ty.Mapped\n\t\t\t}\n\t\t\treturn AnyType{} // Fallback\n\t\tdefault:\n\t\t\tsema.errorf(n.Index, \"property access of object must be type of string but got %q\", idx.String())\n\t\t\treturn AnyType{}\n\t\t}\n\tdefault:\n\t\tsema.errorf(n, \"index access operand must be type of object or array but got %q\", ty.String())\n\t\treturn AnyType{}\n\t}\n}\n\nfunc checkFuncSignature(n *FuncCallNode, sig *FuncSignature, args []ExprType) *ExprError {\n\tlp, la := len(sig.Params), len(args)\n\tif sig.VariableLengthParams && (lp > la) || !sig.VariableLengthParams && lp != la {\n\t\tatLeast := \"\"\n\t\tif sig.VariableLengthParams {\n\t\t\tatLeast = \"at least \"\n\t\t}\n\t\treturn errorfAtExpr(\n\t\t\tn,\n\t\t\t\"number of arguments is wrong. function %q takes %s%d parameters but %d arguments are given\",\n\t\t\tsig.String(),\n\t\t\tatLeast,\n\t\t\tlp,\n\t\t\tla,\n\t\t)\n\t}\n\n\tfor i := 0; i < len(sig.Params); i++ {\n\t\tp, a := sig.Params[i], args[i]\n\t\tif !p.Assignable(a) {\n\t\t\treturn errorfAtExpr(\n\t\t\t\tn.Args[i],\n\t\t\t\t\"%s argument of function call is not assignable. %q cannot be assigned to %q. called function type is %q\",\n\t\t\t\tordinal(i+1),\n\t\t\t\ta.String(),\n\t\t\t\tp.String(),\n\t\t\t\tsig.String(),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Note: Unlike many languages, this check does not allow 0 argument for the variable length\n\t// parameter since it is useful for checking hashFiles() and format().\n\tif sig.VariableLengthParams {\n\t\trest := args[lp:]\n\t\tp := sig.Params[lp-1]\n\t\tfor i, a := range rest {\n\t\t\tif !p.Assignable(a) {\n\t\t\t\treturn errorfAtExpr(\n\t\t\t\t\tn.Args[lp+i],\n\t\t\t\t\t\"%s argument of function call is not assignable. %q cannot be assigned to %q. called function type is %q\",\n\t\t\t\t\tordinal(lp+i+1),\n\t\t\t\t\ta.String(),\n\t\t\t\t\tp.String(),\n\t\t\t\t\tsig.String(),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (sema *ExprSemanticsChecker) checkBuiltinFuncCall(n *FuncCallNode, sig *FuncSignature) ExprType {\n\tsema.checkSpecialFunctionAvailability(n)\n\n\t// Special checks for specific built-in functions\n\tswitch strings.ToLower(n.Callee) {\n\tcase \"format\":\n\t\tlit, ok := n.Args[0].(*StringNode)\n\t\tif !ok {\n\t\t\treturn sig.Ret\n\t\t}\n\t\tl := len(n.Args) - 1 // -1 means removing first format string argument\n\n\t\tholders := parseFormatFuncSpecifiers(lit.Value, l)\n\n\t\tfor i := 0; i < l; i++ {\n\t\t\tif _, ok := holders[i]; !ok {\n\t\t\t\tsema.errorf(n, \"format string %q does not contain placeholder {%d}. remove argument which is unused in the format string\", lit.Value, i)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdelete(holders, i) // forget it to check unused placeholders\n\t\t}\n\n\t\tfor i := range holders {\n\t\t\tsema.errorf(n, \"format string %q contains placeholder {%d} but only %d arguments are given to format\", lit.Value, i, l)\n\t\t}\n\tcase \"fromjson\":\n\t\tlit, ok := n.Args[0].(*StringNode)\n\t\tif !ok {\n\t\t\treturn sig.Ret\n\t\t}\n\t\tvar v any\n\t\terr := json.Unmarshal([]byte(lit.Value), &v)\n\t\tif err == nil {\n\t\t\treturn typeOfJSONValue(v)\n\t\t}\n\t\tif s, ok := err.(*json.SyntaxError); ok {\n\t\t\tsema.errorf(lit, \"broken JSON string is passed to fromJSON() at offset %d: %s\", s.Offset, s)\n\t\t}\n\t}\n\n\treturn sig.Ret\n}\n\nfunc (sema *ExprSemanticsChecker) checkFuncCall(n *FuncCallNode) ExprType {\n\t// Check function name in case insensitive. For example, toJson and toJSON are the same function.\n\tcallee := strings.ToLower(n.Callee)\n\tsigs, ok := sema.funcs[callee]\n\tif !ok {\n\t\tss := make([]string, 0, len(sema.funcs))\n\t\tfor n := range sema.funcs {\n\t\t\tss = append(ss, n)\n\t\t}\n\t\tsema.errorf(n, \"undefined function %q. available functions are %s\", n.Callee, sortedQuotes(ss))\n\t\treturn AnyType{}\n\t}\n\n\ttys := make([]ExprType, 0, len(n.Args))\n\tfor _, a := range n.Args {\n\t\ttys = append(tys, sema.check(a))\n\t}\n\n\t// Check all overloads\n\terrs := []*ExprError{}\n\tfor _, sig := range sigs {\n\t\terr := checkFuncSignature(n, sig, tys)\n\t\tif err == nil {\n\t\t\t// When one of overload pass type check, overload was resolved correctly\n\t\t\treturn sema.checkBuiltinFuncCall(n, sig)\n\t\t}\n\t\terrs = append(errs, err)\n\t}\n\n\t// All candidates failed\n\tsema.errs = append(sema.errs, errs...)\n\n\treturn AnyType{}\n}\n\nfunc (sema *ExprSemanticsChecker) checkNotOp(n *NotOpNode) ExprType {\n\tty := sema.check(n.Operand)\n\tif !(BoolType{}).Assignable(ty) {\n\t\tsema.errorf(n, \"type of operand of ! operator %q is not assignable to type \\\"bool\\\"\", ty.String())\n\t}\n\treturn BoolType{}\n}\n\nfunc validateCompareOpOperands(op CompareOpNodeKind, l, r ExprType) bool {\n\t// Comparison behavior: https://docs.github.com/en/actions/learn-github-actions/expressions#operators\n\tswitch op {\n\tcase CompareOpNodeKindEq, CompareOpNodeKindNotEq:\n\t\tswitch l := l.(type) {\n\t\tcase AnyType, NullType:\n\t\t\treturn true\n\t\tcase NumberType, BoolType, StringType:\n\t\t\tswitch r.(type) {\n\t\t\tcase *ObjectType, *ArrayType:\n\t\t\t\t// These are coerced to NaN hence the comparison result is always false\n\t\t\t\treturn false\n\t\t\tdefault:\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase *ObjectType:\n\t\t\tswitch r.(type) {\n\t\t\tcase *ObjectType, NullType, AnyType:\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\treturn false\n\t\t\t}\n\t\tcase *ArrayType:\n\t\t\tswitch r := r.(type) {\n\t\t\tcase *ArrayType:\n\t\t\t\treturn validateCompareOpOperands(op, l.Elem, r.Elem)\n\t\t\tcase NullType, AnyType:\n\t\t\t\treturn true\n\t\t\tdefault:\n\t\t\t\treturn false\n\t\t\t}\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\tcase CompareOpNodeKindLess, CompareOpNodeKindLessEq, CompareOpNodeKindGreater, CompareOpNodeKindGreaterEq:\n\t\t// null, bool, array, and object cannot be compared with these operators\n\t\tswitch l.(type) {\n\t\tcase AnyType, NumberType, StringType:\n\t\t\tswitch r.(type) {\n\t\t\tcase NullType, BoolType, *ObjectType, *ArrayType:\n\t\t\t\treturn false\n\t\t\tdefault:\n\t\t\t\treturn true\n\t\t\t}\n\t\tcase NullType, BoolType, *ObjectType, *ArrayType:\n\t\t\treturn false\n\t\tdefault:\n\t\t\tpanic(\"unreachable\")\n\t\t}\n\tdefault:\n\t\treturn true\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) checkCompareOp(n *CompareOpNode) ExprType {\n\tl := sema.check(n.Left)\n\tr := sema.check(n.Right)\n\n\tif !validateCompareOpOperands(n.Kind, l, r) {\n\t\tsema.errorf(n, \"%q value cannot be compared to %q value with %q operator\", l.String(), r.String(), n.Kind.String())\n\t}\n\n\treturn BoolType{}\n}\n\n// checkWithNarrowing checks type of given expression with type narrowing. Type narrowing narrows\n// down the type of the expression by assuming its value. For example, `l && r` is typed as\n// `typeof(l) | typeof(r)` usually. However when the expression is assumed to be true, its type can\n// be narrowed down to `typeof(r)`.\n// This analysis is useful to make type checking more accurate. For example, `some_var && 60 || 20`\n// can be typed as `number` instead of `typeof(some_var) | number`. (#384)\nfunc (sema *ExprSemanticsChecker) checkWithNarrowing(n ExprNode, isTruthy bool) ExprType {\n\tswitch n := n.(type) {\n\tcase *LogicalOpNode:\n\t\tswitch n.Kind {\n\t\tcase LogicalOpNodeKindAnd:\n\t\t\t// When `l && r` is true, narrow its type to `typeof(r)`\n\t\t\tif isTruthy {\n\t\t\t\tsema.check(n.Left)\n\t\t\t\treturn sema.check(n.Right)\n\t\t\t}\n\t\tcase LogicalOpNodeKindOr:\n\t\t\t// When `l || r` is false, narrow its type to `typeof(r)`\n\t\t\tif !isTruthy {\n\t\t\t\tsema.check(n.Left)\n\t\t\t\treturn sema.check(n.Right)\n\t\t\t}\n\t\t}\n\t\treturn sema.checkLogicalOp(n)\n\tcase *NotOpNode:\n\t\treturn sema.checkWithNarrowing(n.Operand, !isTruthy)\n\tdefault:\n\t\treturn sema.check(n)\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) checkLogicalOp(n *LogicalOpNode) ExprType {\n\tswitch n.Kind {\n\tcase LogicalOpNodeKindAnd:\n\t\t// When `l` is false in `l && r`, its type is `typeof(l)`. Otherwise `typeof(r)`.\n\t\t// Narrow the type of LHS expression by assuming its value is falsy.\n\t\treturn sema.checkWithNarrowing(n.Left, false).Merge(sema.check(n.Right))\n\tcase LogicalOpNodeKindOr:\n\t\t// When `l` is true in `l || r`, its type is `typeof(l)`. Otherwise `typeof(r).\n\t\t// Narrow the type of LHS expression by assuming its value is truthy.\n\t\treturn sema.checkWithNarrowing(n.Left, true).Merge(sema.check(n.Right))\n\tdefault:\n\t\tsema.check(n.Left)\n\t\tsema.check(n.Right)\n\t\treturn AnyType{}\n\t}\n}\n\nfunc (sema *ExprSemanticsChecker) check(expr ExprNode) ExprType {\n\tsema.visitUntrustedCheckerOnEnterNode(expr)\n\tdefer sema.visitUntrustedCheckerOnLeaveNode(expr) // Call this method in bottom-up order\n\n\tswitch e := expr.(type) {\n\tcase *VariableNode:\n\t\treturn sema.checkVariable(e)\n\tcase *NullNode:\n\t\treturn NullType{}\n\tcase *BoolNode:\n\t\treturn BoolType{}\n\tcase *StringNode:\n\t\treturn StringType{}\n\tcase *IntNode, *FloatNode:\n\t\treturn NumberType{}\n\tcase *ObjectDerefNode:\n\t\treturn sema.checkObjectDeref(e)\n\tcase *ArrayDerefNode:\n\t\treturn sema.checkArrayDeref(e)\n\tcase *IndexAccessNode:\n\t\treturn sema.checkIndexAccess(e)\n\tcase *FuncCallNode:\n\t\treturn sema.checkFuncCall(e)\n\tcase *NotOpNode:\n\t\treturn sema.checkNotOp(e)\n\tcase *CompareOpNode:\n\t\treturn sema.checkCompareOp(e)\n\tcase *LogicalOpNode:\n\t\treturn sema.checkLogicalOp(e)\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\n// Check checks semantics of given expression syntax tree. It returns the type of the expression as\n// the first return value when the check was successfully done. And it returns all errors found\n// while checking the expression as the second return value.\nfunc (sema *ExprSemanticsChecker) Check(expr ExprNode) (ExprType, []*ExprError) {\n\tsema.errs = []*ExprError{}\n\tif sema.untrusted != nil {\n\t\tsema.untrusted.Init()\n\t}\n\tty := sema.check(expr)\n\terrs := sema.errs\n\tif sema.untrusted != nil {\n\t\tsema.untrusted.OnVisitEnd()\n\t\terrs = append(errs, sema.untrusted.Errs()...)\n\t}\n\treturn ty, errs\n}\n"
        },
        {
          "name": "expr_sema_test.go",
          "type": "blob",
          "size": 43.9228515625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n\t\"unicode\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestExprSemanticsCheckOK(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat          string\n\t\tinput         string\n\t\texpected      ExprType\n\t\tfuncs         map[string][]*FuncSignature\n\t\tmatrix        *ObjectType\n\t\tsteps         *ObjectType\n\t\tneeds         *ObjectType\n\t\tinputs        *ObjectType\n\t\tsecrets       *ObjectType\n\t\tjobs          *ObjectType\n\t\tavailContexts []string\n\t\tavailSPFuncs  []string\n\t\tconfigVars    []string\n\t}{\n\t\t{\n\t\t\twhat:     \"null\",\n\t\t\tinput:    \"null\",\n\t\t\texpected: NullType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"bool\",\n\t\t\tinput:    \"true\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"integer\",\n\t\t\tinput:    \"42\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"float\",\n\t\t\tinput:    \"-3.14e16\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"string\",\n\t\t\tinput:    \"'this is string'\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"variable\",\n\t\t\tinput:    \"github\",\n\t\t\texpected: BuiltinGlobalVariableTypes[\"github\"],\n\t\t},\n\t\t{\n\t\t\twhat:     \"object property dereference\",\n\t\t\tinput:    \"test().bar.piyo\",\n\t\t\texpected: BoolType{},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"bar\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\"piyo\": BoolType{},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"object property dereference of global variable\",\n\t\t\tinput:    \"job.container.network\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"object property dereference for any type\",\n\t\t\tinput:    \"github.event.labels\",\n\t\t\texpected: AnyType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"array element dereference\",\n\t\t\tinput:    \"test().bar.*\",\n\t\t\texpected: &ArrayType{BoolType{}, true},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"bar\": &ArrayType{Elem: BoolType{}},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"filter object property by array element dereference\",\n\t\t\tinput:    \"test().foo.*.bar.piyo\",\n\t\t\texpected: &ArrayType{StringType{}, true},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"foo\": &ArrayType{\n\t\t\t\t\t\t\t\tElem: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\t\"bar\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\t\t\"piyo\": StringType{},\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"filter strict object property by array element dereference\",\n\t\t\tinput:    \"test().foo.*.bar.piyo\",\n\t\t\texpected: &ArrayType{StringType{}, true},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"foo\": &ArrayType{\n\t\t\t\t\t\t\t\tElem: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\t\"bar\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\t\t\"piyo\": StringType{},\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t// TODO: Add strictprops\n\t\t{\n\t\t\twhat:     \"array element dereference with any type\",\n\t\t\tinput:    \"github.event.labels.*.name\",\n\t\t\texpected: &ArrayType{AnyType{}, true},\n\t\t},\n\t\t{\n\t\t\twhat:     \"nested array element dereference\",\n\t\t\tinput:    \"github.event.issues.*.labels.*.name\",\n\t\t\texpected: &ArrayType{AnyType{}, true},\n\t\t},\n\t\t{\n\t\t\twhat:     \"array element dereference with object type\",\n\t\t\tinput:    \"github.*.name\",\n\t\t\texpected: &ArrayType{AnyType{}, true},\n\t\t},\n\t\t{\n\t\t\twhat:     \"function call\",\n\t\t\tinput:    \"contains('hello', 'll')\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"function call overload\",\n\t\t\tinput:    \"contains(github.event.labels, 'foo')\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"function call zero arguments\",\n\t\t\tinput:    \"always()\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"function call variable length parameters\",\n\t\t\tinput:    \"format('hello {0} {1}', 42, true)\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"object property index access\",\n\t\t\tinput:    \"test()['bar']['piyo']\",\n\t\t\texpected: BoolType{},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"bar\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\"piyo\": BoolType{},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"object property index access with any type\",\n\t\t\tinput:    \"github.event['FOOO']\",\n\t\t\texpected: AnyType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"array element dereference\",\n\t\t\tinput:    \"test()[0]\",\n\t\t\texpected: BoolType{},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet:  &ArrayType{Elem: BoolType{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"array element index access with any type fallback\",\n\t\t\tinput:    \"github.event.labels[0]\",\n\t\t\texpected: AnyType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"index access to dereferenced array\",\n\t\t\tinput:    \"test().foo.*.bar[0]\",\n\t\t\texpected: StringType{},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"foo\": &ArrayType{\n\t\t\t\t\t\t\t\tElem: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\t\"bar\": StringType{},\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"coerce array dereference into array at function parameter\",\n\t\t\tinput:    \"contains(test().*.x, 10)\",\n\t\t\texpected: BoolType{},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: &ArrayType{\n\t\t\t\t\t\t\tElem: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\"x\": NumberType{},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"contains\": BuiltinFuncSignatures[\"contains\"],\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"index access to dereferenced array with any type fallback\",\n\t\t\tinput:    \"github.event.labels.*.name[0]\",\n\t\t\texpected: AnyType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"! operator\",\n\t\t\tinput:    \"!true\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"! operator with non-bool operand\",\n\t\t\tinput:    \"!null\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"< operator\",\n\t\t\tinput:    \"0 < 1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"<= operator\",\n\t\t\tinput:    \"0 <= 1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"> operator\",\n\t\t\tinput:    \"0 > 1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \">= operator\",\n\t\t\tinput:    \"0 >= 1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"== operator\",\n\t\t\tinput:    \"0 == 1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"!= operator\",\n\t\t\tinput:    \"0 != 1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"&& operator\",\n\t\t\tinput:    \"true && false\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"|| operator\",\n\t\t\tinput:    \"true || false\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"&& operator with non-bool operands\",\n\t\t\tinput:    \"10 && 'foo'\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"|| operator with non-bool operands\",\n\t\t\tinput:    \"'foo' || 42\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"coercing two objects on && operator\",\n\t\t\tinput: \"foo() && bar()\",\n\t\t\texpected: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\"bar\": BoolType{},\n\t\t\t}),\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"foo\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\tRet: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"bar\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"bar\",\n\t\t\t\t\t\tRet: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"bar\": BoolType{},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"coercing two objects on || operator\",\n\t\t\tinput: \"foo() || bar()\",\n\t\t\texpected: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\"bar\": BoolType{},\n\t\t\t}),\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"foo\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"foo\",\n\t\t\t\t\t\tRet: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"bar\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"bar\",\n\t\t\t\t\t\tRet: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"bar\": BoolType{},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"== operator with loose equality check\",\n\t\t\tinput:    \"true == 1.1\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"arguments of format() is not checked when first argument is not a literal\",\n\t\t\tinput:    \"format(github.action, 1, 2, 3)\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"matrix value with typed matrix values\",\n\t\t\tinput:    \"matrix.foooo\",\n\t\t\texpected: StringType{},\n\t\t\tmatrix: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foooo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"step output value with typed steps outputs\",\n\t\t\tinput:    \"steps.foo.outputs\",\n\t\t\texpected: NewEmptyObjectType(),\n\t\t\tsteps: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\":    NewEmptyObjectType(),\n\t\t\t\t\t\"conclusion\": StringType{},\n\t\t\t\t\t\"outcome\":    StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"step conclusion with typed steps outputs\",\n\t\t\tinput:    \"steps.foo.conclusion\",\n\t\t\texpected: StringType{},\n\t\t\tsteps: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\":    NewEmptyObjectType(),\n\t\t\t\t\t\"conclusion\": StringType{},\n\t\t\t\t\t\"outcome\":    StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"needs context object\",\n\t\t\tinput:    \"needs\",\n\t\t\texpected: NewEmptyStrictObjectType(),\n\t\t},\n\t\t{\n\t\t\twhat:     \"output string in needs context object\",\n\t\t\tinput:    \"needs.foo.outputs.out1\",\n\t\t\texpected: StringType{},\n\t\t\tneeds: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\"out1\": StringType{},\n\t\t\t\t\t\t\"out2\": StringType{},\n\t\t\t\t\t}),\n\t\t\t\t\t\"result\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"result in needs context object\",\n\t\t\tinput:    \"needs.foo.result\",\n\t\t\texpected: StringType{},\n\t\t\tneeds: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\"out1\": StringType{},\n\t\t\t\t\t\t\"out2\": StringType{},\n\t\t\t\t\t}),\n\t\t\t\t\t\"result\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"number is coerced into string\",\n\t\t\tinput:    \"startsWith('42foo', 42)\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"string is coerced into bool\",\n\t\t\tinput:    \"!'hello'\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"coerce number into bool\",\n\t\t\tinput:    \"!42\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"coerce null into bool\",\n\t\t\tinput:    \"!null\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"coerce string into bool\",\n\t\t\tinput:    \"!'hello'\",\n\t\t\texpected: BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"case insensitive comparison for object property\",\n\t\t\tinput:    \"test().foo-Bar_PIYO\",\n\t\t\texpected: NullType{},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\"foo-bar_piyo\": NullType{},\n\t\t\t\t\t\t}),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"case insensitive comparison for function name\",\n\t\t\tinput:    \"toJSON(fromjson(toJson(github)))\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"case insensitive comparison for context name\",\n\t\t\tinput:    \"JOB.CONTAINER.NETWORK\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"format() function arguments validation\",\n\t\t\tinput:    \"format('{0}{0}{0} {1}{2}{1} {1}{2}{1}{2} {0} {1}{1}{1} {2}{2}{2} {0}{0}{0}{0} {0}', 1, 'foo', true)\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"braces not for placeholders in format string of format() call\",\n\t\t\tinput:    \"format('{0} {} {x} {', 1)\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"map object dereference\",\n\t\t\tinput:    \"env.FOO\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"map object dreference on array filter\",\n\t\t\tinput:    \"test().*.foo\",\n\t\t\texpected: &ArrayType{NumberType{}, true},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: &ArrayType{\n\t\t\t\t\t\t\tElem: NewMapObjectType(NumberType{}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"map object dreference on object filter\",\n\t\t\tinput:    \"test().*.foo\",\n\t\t\texpected: &ArrayType{NumberType{}, true},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: NewMapObjectType(\n\t\t\t\t\t\t\tNewMapObjectType(NumberType{}),\n\t\t\t\t\t\t),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"loose object at object filter\",\n\t\t\tinput:    \"github.event.*.foo\",\n\t\t\texpected: &ArrayType{AnyType{}, true},\n\t\t},\n\t\t{\n\t\t\twhat:     \"strict object which has at least one object element at object filter\",\n\t\t\tinput:    \"github.*.foo\",\n\t\t\texpected: &ArrayType{AnyType{}, true},\n\t\t},\n\t\t{\n\t\t\twhat:     \"map object index access with string literal\",\n\t\t\tinput:    \"env['FOO']\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"map object index access with dynamic value\",\n\t\t\tinput:    \"env[github.action]\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"nested object in map object\",\n\t\t\tinput:    \"job.services.my_service.network\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrowed inputs object\",\n\t\t\tinput:    \"inputs.hello\",\n\t\t\texpected: NumberType{},\n\t\t\tinputs: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"hello\": NumberType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrowed secrets object\",\n\t\t\tinput:    \"secrets.token\",\n\t\t\texpected: StringType{},\n\t\t\tsecrets: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"token\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"default secrets object\",\n\t\t\tinput:    \"secrets.any_value\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"automatically supplied secret\",\n\t\t\tinput:    \"secrets.github_token\",\n\t\t\texpected: StringType{},\n\t\t\tsecrets: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"automatically supplied secret\",\n\t\t\tinput:    \"secrets.ACTIONS_STEP_DEBUG\",\n\t\t\texpected: StringType{},\n\t\t\tsecrets: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"automatically supplied secret\",\n\t\t\tinput:    \"secrets.ACTIONS_RUNNER_DEBUG\",\n\t\t\texpected: StringType{},\n\t\t\tsecrets: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:     \"jobs object\",\n\t\t\tinput:    \"jobs.some_job\",\n\t\t\texpected: NewEmptyObjectType(),\n\t\t\tjobs: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"some_job\": NewEmptyObjectType(),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:          \"available context\",\n\t\t\tinput:         \"strategy.fail-fast\",\n\t\t\texpected:      BoolType{},\n\t\t\tavailContexts: []string{\"strategy\"},\n\t\t},\n\t\t{\n\t\t\twhat:          \"available contexts\",\n\t\t\tinput:         \"strategy.fail-fast\",\n\t\t\texpected:      BoolType{},\n\t\t\tavailContexts: []string{\"matrix\", \"strategy\"},\n\t\t},\n\t\t{\n\t\t\twhat:         \"special function\",\n\t\t\tinput:        \"success()\",\n\t\t\texpected:     BoolType{},\n\t\t\tavailSPFuncs: []string{\"success\"},\n\t\t},\n\t\t{\n\t\t\twhat:         \"non-special function\",\n\t\t\tinput:        \"contains('hello, world', 'o, w')\",\n\t\t\texpected:     BoolType{},\n\t\t\tavailSPFuncs: []string{\"always\"},\n\t\t},\n\t\t{\n\t\t\twhat:         \"case-insensitive special function name\",\n\t\t\tinput:        \"hashFiles('aaa.txt')\",\n\t\t\texpected:     StringType{},\n\t\t\tavailSPFuncs: []string{\"hashfiles\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"configuration variable\",\n\t\t\tinput:    \"vars.SOME_VARIABLE\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:       \"known configuration variable\",\n\t\t\tinput:      \"vars.SOME_VARIABLE\",\n\t\t\texpected:   StringType{},\n\t\t\tconfigVars: []string{\"SOME_VARIABLE\"},\n\t\t},\n\t\t{\n\t\t\twhat:       \"configuration variable name is case insensitive\",\n\t\t\tinput:      \"vars.SOME_VARIABLE\",\n\t\t\texpected:   StringType{},\n\t\t\tconfigVars: []string{\"some_variable\"},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrow type of && operator by assumed value (#384)\",\n\t\t\tinput:    \"('foo' && 10) || 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrow type of || operator by assumed value (#384)\",\n\t\t\tinput:    \"('foo' || 10) && 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrow type of nested && operator\",\n\t\t\tinput:    \"((('foo' && true) || false) && 10) || 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrow type of nested || operator\",\n\t\t\tinput:    \"((('foo' || true) && false) || 10) && 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"don't narrow type on nested && operator\",\n\t\t\tinput:    \"('foo' && 10) && 20\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"don't narrow type on nested || operator\",\n\t\t\tinput:    \"('foo' || 10) || 20\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrowed || operator at LHS and && operator at RHS\",\n\t\t\tinput:    \"('foo' || 10) && (('foo' && 10) || 20)\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"narrowed && operator at LHS and || operator at RHS\",\n\t\t\tinput:    \"('foo' && 10) || (('foo' || 10) && 20)\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"not operator negates && operator type narrowing\",\n\t\t\tinput:    \"!('foo' && 10) && 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"not operator negates || operator type narrowing\",\n\t\t\tinput:    \"!('foo' || 10) || 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"double not operators does nothing on type narrowing\",\n\t\t\tinput:    \"!!('foo' || 10) && 20\",\n\t\t\texpected: NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"escaped braces in format string\",\n\t\t\tinput:    \"format('hello {{1}} {0}', 42)\",\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:     \"format specifier is escaped\",\n\t\t\tinput:    \"format('hello {{{0}', 'world')\", // First {{ is escaped. {0} is not escaped\n\t\t\texpected: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"fromJSON with JSON constant value\",\n\t\t\tinput: `fromJSON('{\"foo\":true,\"bar\":[\"foo\", 12.3],\"piyo\":null}')`,\n\t\t\texpected: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\":  BoolType{},\n\t\t\t\t\"bar\":  &ArrayType{Elem: StringType{}}, // Element type was merged\n\t\t\t\t\"piyo\": NullType{},\n\t\t\t}),\n\t\t},\n\t}\n\n\tallSPFuncs := []string{}\n\tfor f := range SpecialFunctionNames {\n\t\tallSPFuncs = append(allSPFuncs, f)\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tp := NewExprParser()\n\t\t\te, err := p.Parse(NewExprLexer(tc.input + \"}}\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Parse error:\", tc.input)\n\t\t\t}\n\n\t\t\tc := NewExprSemanticsChecker(false, nil)\n\t\t\tc.SetContextAvailability([]string{\"github\", \"job\", \"jobs\", \"matrix\", \"steps\", \"needs\", \"env\", \"inputs\", \"secrets\", \"vars\", \"runner\"})\n\t\t\tif tc.funcs != nil {\n\t\t\t\tc.funcs = tc.funcs\n\t\t\t}\n\t\t\tif tc.matrix != nil {\n\t\t\t\tc.UpdateMatrix(tc.matrix)\n\t\t\t}\n\t\t\tif tc.steps != nil {\n\t\t\t\tc.UpdateSteps(tc.steps)\n\t\t\t}\n\t\t\tif tc.needs != nil {\n\t\t\t\tc.UpdateNeeds(tc.needs)\n\t\t\t}\n\t\t\tif tc.inputs != nil {\n\t\t\t\tc.UpdateInputs(tc.inputs)\n\t\t\t}\n\t\t\tif tc.secrets != nil {\n\t\t\t\tc.UpdateSecrets(tc.secrets)\n\t\t\t}\n\t\t\tif tc.jobs != nil {\n\t\t\t\tc.UpdateJobs(tc.jobs)\n\t\t\t}\n\t\t\tif len(tc.availContexts) > 0 {\n\t\t\t\tc.SetContextAvailability(tc.availContexts)\n\t\t\t}\n\t\t\tif len(tc.availSPFuncs) > 0 {\n\t\t\t\tc.SetSpecialFunctionAvailability(tc.availSPFuncs)\n\t\t\t} else {\n\t\t\t\tc.SetSpecialFunctionAvailability(allSPFuncs)\n\t\t\t}\n\t\t\tty, errs := c.Check(e)\n\t\t\tif len(errs) > 0 {\n\t\t\t\tt.Fatal(\"semantics check failed:\", errs)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(tc.expected, ty); diff != \"\" {\n\t\t\t\tt.Fatalf(\"wanted: %s\\nbut got:%s\\ndiff:\\n%s\", tc.expected.String(), ty.String(), diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprSemanticsCheckError(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat       string\n\t\tinput      string\n\t\texpected   []string\n\t\tfuncs      map[string][]*FuncSignature\n\t\tmatrix     *ObjectType\n\t\tsteps      *ObjectType\n\t\tneeds      *ObjectType\n\t\tavailCtx   []string\n\t\tavailSP    []string\n\t\tconfigVars []string\n\t}{\n\t\t{\n\t\t\twhat:  \"undefined variable\",\n\t\t\tinput: \"fooooo\",\n\t\t\texpected: []string{\n\t\t\t\t\"undefined variable \\\"fooooo\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"receiver of object dereference is not an object\",\n\t\t\tinput: \"true.foo\",\n\t\t\texpected: []string{\n\t\t\t\t\"receiver of object dereference \\\"foo\\\" must be type of object but got \\\"bool\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"strict prop check\",\n\t\t\tinput: \"github.foo\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"foo\\\" is not defined in object type\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"strict prop check at object property filter for array dereference\",\n\t\t\tinput: \"test().*.bar\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"bar\\\" is not defined in object type\",\n\t\t\t},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: &ArrayType{\n\t\t\t\t\t\t\tElem: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\t\t\"foo\": BoolType{},\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"array element is not object for filtering array dereference\",\n\t\t\tinput: \"test().*.bar\",\n\t\t\texpected: []string{\n\t\t\t\t\"property filtered by \\\"bar\\\" at object filtering must be type of object but got \\\"string\\\"\",\n\t\t\t},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: &ArrayType{\n\t\t\t\t\t\t\tElem: StringType{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"receiver of array dereference is not an array\",\n\t\t\tinput: \"true.*\",\n\t\t\texpected: []string{\n\t\t\t\t\"receiver of object filtering `.*` must be type of array or object but got \\\"bool\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"receiver of object filter is not an object which has object element\",\n\t\t\tinput: \"env.*\",\n\t\t\texpected: []string{\n\t\t\t\t\"elements of object at receiver of object filtering `.*` must be type of object but got \\\"string\\\". the type of receiver was \\\"{string => string}\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"receiver of object filter is an object which has no object element\",\n\t\t\tinput: \"runner.*\",\n\t\t\texpected: []string{\n\t\t\t\t\"cannot be filtered by object filtering `.*` since it has no object element\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access to invalid value (number)\",\n\t\t\tinput: \"true[0]\",\n\t\t\texpected: []string{\n\t\t\t\t\"index access operand must be type of object or array but got \\\"bool\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access to invalid value (string)\",\n\t\t\tinput: \"true['hello']\",\n\t\t\texpected: []string{\n\t\t\t\t\"index access operand must be type of object or array but got \\\"bool\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access to array with not a number\",\n\t\t\tinput: \"test()['hi']\",\n\t\t\texpected: []string{\n\t\t\t\t\"index access of array must be type of number but got \\\"string\\\"\",\n\t\t\t},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: &ArrayType{\n\t\t\t\t\t\t\tElem: StringType{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access to array dereference with not a number\",\n\t\t\tinput: \"test().*['hi']\",\n\t\t\texpected: []string{\n\t\t\t\t\"index access of array must be type of number but got \\\"string\\\"\",\n\t\t\t},\n\t\t\tfuncs: map[string][]*FuncSignature{\n\t\t\t\t\"test\": {\n\t\t\t\t\t{\n\t\t\t\t\t\tName: \"test\",\n\t\t\t\t\t\tRet: &ArrayType{\n\t\t\t\t\t\t\tElem: StringType{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"index access to object with not a string\",\n\t\t\tinput: \"env[0]\",\n\t\t\texpected: []string{\n\t\t\t\t\"property access of object must be type of string but got \\\"number\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"strict prop check with string literal index access to object\",\n\t\t\tinput: \"github['fooooo']\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"fooooo\\\" is not defined in object type\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined function\",\n\t\t\tinput: \"foooo()\",\n\t\t\texpected: []string{\n\t\t\t\t\"undefined function \\\"foooo\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"wrong number of arguments at function call\",\n\t\t\tinput: \"contains('foo')\",\n\t\t\texpected: []string{\n\t\t\t\t\"number of arguments is wrong. function \\\"contains(string, string) -> bool\\\" takes 2 parameters but 1 arguments are given\",\n\t\t\t\t\"number of arguments is wrong. function \\\"contains(array<any>, any) -> bool\\\" takes 2 parameters but 1 arguments are given\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"wrong number of arguments at function call for variable length parameters\",\n\t\t\tinput: \"hashFiles()\",\n\t\t\texpected: []string{\n\t\t\t\t\"number of arguments is wrong. function \\\"hashFiles(string...) -> string\\\" takes at least 1 parameters but 0 arguments are given\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"wrong type at parameter\",\n\t\t\tinput: \"startsWith('foo', null)\",\n\t\t\texpected: []string{\n\t\t\t\t\"2nd argument of function call is not assignable. \\\"null\\\" cannot be assigned to \\\"string\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"wrong type at parameter of overloaded function\",\n\t\t\tinput: \"contains('foo', null)\",\n\t\t\texpected: []string{\n\t\t\t\t\"2nd argument of function call is not assignable. \\\"null\\\" cannot be assigned to \\\"string\\\"\",\n\t\t\t\t\"1st argument of function call is not assignable. \\\"string\\\" cannot be assigned to \\\"array<any>\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"wrong type at rest parameter\",\n\t\t\tinput: \"hashFiles(null)\",\n\t\t\texpected: []string{\n\t\t\t\t\"1st argument of function call is not assignable. \\\"null\\\" cannot be assigned to \\\"string\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"wrong type at rest parameter part2\",\n\t\t\tinput: \"hashFiles('foo', null)\",\n\t\t\texpected: []string{\n\t\t\t\t\"2nd argument of function call is not assignable. \\\"null\\\" cannot be assigned to \\\"string\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"less arguments for format() builtin function call\",\n\t\t\tinput: \"format('format {0} {1}', 'foo')\",\n\t\t\texpected: []string{\n\t\t\t\t\"format string \\\"format {0} {1}\\\" contains placeholder {1} but only 1 arguments are given to format\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"more arguments for format() builtin function call\",\n\t\t\tinput: \"format('format {0} {1} {2}', 'foo', 1, true, null)\",\n\t\t\texpected: []string{\n\t\t\t\t\"format string \\\"format {0} {1} {2}\\\" does not contain placeholder {3}. remove argument which is unused in the format string\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"unused placeholder in format string of format()\",\n\t\t\tinput: \"format('format {0} {2}', 1, 2, 3)\",\n\t\t\texpected: []string{\n\t\t\t\t\"format string \\\"format {0} {2}\\\" does not contain placeholder {1}. remove argument which is unused in the format string\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"missing placeholder and less argument at the same time in format string of format()\",\n\t\t\tinput: \"format('format {0} {2}', 1, 2)\",\n\t\t\texpected: []string{\n\t\t\t\t\"format string \\\"format {0} {2}\\\" does not contain placeholder {1}. remove argument which is unused in the format string\",\n\t\t\t\t\"format string \\\"format {0} {2}\\\" contains placeholder {2} but only 2 arguments are given to format\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"zero format arguments for format() call\",\n\t\t\tinput: \"format('hi')\",\n\t\t\texpected: []string{\n\t\t\t\t\"takes at least 2 parameters but 1 arguments are given\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"function name of format() call check is case insensitive\",\n\t\t\tinput: \"Format('{0}', 1, 2)\",\n\t\t\texpected: []string{\n\t\t\t\t`format string \"{0}\" does not contain placeholder {1}`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"format specifier is escaped\",\n\t\t\tinput: \"format('hello {{0}}', 'world')\",\n\t\t\texpected: []string{\n\t\t\t\t\"does not contain placeholder {0}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"format specifier is still escaped\",\n\t\t\tinput: \"format('hello {{{{0}}', 'world')\", // First {{ is escaped. {{0}} is still escaped\n\t\t\texpected: []string{\n\t\t\t\t\"does not contain placeholder {0}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined matrix value\",\n\t\t\tinput: \"matrix.bar\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"bar\\\" is not defined in object type {foo: any}\",\n\t\t\t},\n\t\t\tmatrix: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"type mismatch in matrix value\",\n\t\t\tinput: \"startsWith('hello', matrix.foo)\",\n\t\t\texpected: []string{\n\t\t\t\t\"2nd argument of function call is not assignable. \\\"null\\\" cannot be assigned to \\\"string\\\"\",\n\t\t\t},\n\t\t\tmatrix: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"matrix value with untyped matrix values\",\n\t\t\tinput: \"matrix.foooo\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"foooo\\\" is not defined in object type {}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined step id\",\n\t\t\tinput: \"steps.foo\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"foo\\\" is not defined in object type {bar: \", // order of prop types in object type changes randomly so we cannot check it easily\n\t\t\t},\n\t\t\tsteps: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\":    NewEmptyObjectType(),\n\t\t\t\t\t\"conclusion\": StringType{},\n\t\t\t\t\t\"outcome\":    StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"invalid property in step object\",\n\t\t\tinput: \"steps.bar.foo\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"foo\\\" is not defined in object type {\", // order of prop types in object type changes randomly so we cannot check it easily\n\t\t\t},\n\t\t\tsteps: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\":    NewEmptyObjectType(),\n\t\t\t\t\t\"conclusion\": StringType{},\n\t\t\t\t\t\"outcome\":    StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"step output value without typed steps outputs\",\n\t\t\tinput: \"steps.foo.outputs\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"foo\\\" is not defined in object type {}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined job id in needs context\",\n\t\t\tinput: \"needs.bar\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"bar\\\" is not defined in object type \",\n\t\t\t},\n\t\t\tneeds: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\"out1\": StringType{},\n\t\t\t\t\t\t\"out2\": StringType{},\n\t\t\t\t\t}),\n\t\t\t\t\t\"result\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined output in needs context\",\n\t\t\tinput: \"needs.foo.outputs.out3\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"out3\\\" is not defined in object type \",\n\t\t\t},\n\t\t\tneeds: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\"out1\": StringType{},\n\t\t\t\t\t\t\"out2\": StringType{},\n\t\t\t\t\t}),\n\t\t\t\t\t\"result\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined prop in needs context\",\n\t\t\tinput: \"needs.foo.bar\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"bar\\\" is not defined in object type \",\n\t\t\t},\n\t\t\tneeds: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"outputs\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\"out1\": StringType{},\n\t\t\t\t\t\t\"out2\": StringType{},\n\t\t\t\t\t}),\n\t\t\t\t\t\"result\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat:  \"undefined prop in untyped needs context\",\n\t\t\tinput: \"needs.foo\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"foo\\\" is not defined in object type \",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"bool literal in upper case\",\n\t\t\tinput: \"TRUE\",\n\t\t\texpected: []string{\n\t\t\t\t\"undefined variable \\\"TRUE\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"null literal in upper case\",\n\t\t\tinput: \"NULL\",\n\t\t\texpected: []string{\n\t\t\t\t\"undefined variable \\\"NULL\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"inputs context accepts nothing by default\",\n\t\t\tinput: \"inputs.hello\",\n\t\t\texpected: []string{\n\t\t\t\t\"property \\\"hello\\\" is not defined in object type {}\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"available context\",\n\t\t\tinput: \"env.FOO\",\n\t\t\texpected: []string{\n\t\t\t\t\"context \\\"env\\\" is not allowed here. available context is \\\"github\\\"\",\n\t\t\t},\n\t\t\tavailCtx: []string{\"github\"},\n\t\t},\n\t\t{\n\t\t\twhat:  \"available contexts\",\n\t\t\tinput: \"github.event.labels\",\n\t\t\texpected: []string{\n\t\t\t\t\"context \\\"github\\\" is not allowed here. available contexts are \\\"env\\\", \\\"matrix\\\"\",\n\t\t\t},\n\t\t\tavailCtx: []string{\"env\", \"matrix\"},\n\t\t},\n\t\t{\n\t\t\twhat:  \"no available context\",\n\t\t\tinput: \"github\",\n\t\t\texpected: []string{\n\t\t\t\t\"context \\\"github\\\" is not allowed here. no context is available\",\n\t\t\t},\n\t\t\tavailCtx: []string{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"no special function allowed\",\n\t\t\tinput: \"success()\",\n\t\t\texpected: []string{\n\t\t\t\t\"calling function \\\"success\\\" is not allowed here. \\\"success\\\" is only available in \",\n\t\t\t},\n\t\t\tavailSP: []string{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"special function\",\n\t\t\tinput: \"always()\",\n\t\t\texpected: []string{\n\t\t\t\t\"calling function \\\"always\\\" is not allowed here. \\\"always\\\" is only available in \",\n\t\t\t},\n\t\t\tavailSP: []string{\"fail\", \"success\"},\n\t\t},\n\t\t{\n\t\t\twhat:  \"case-insensitive special function name\",\n\t\t\tinput: \"hashFiles('aaa.txt')\",\n\t\t\texpected: []string{\n\t\t\t\t\"calling function \\\"hashFiles\\\" is not allowed here. \\\"hashFiles\\\" is only available in \",\n\t\t\t},\n\t\t\tavailSP: []string{\"fail\"},\n\t\t},\n\t\t{\n\t\t\twhat:  \"no configuration variable is allowed\",\n\t\t\tinput: \"vars.UNKNOWN_VARIABLE\",\n\t\t\texpected: []string{\n\t\t\t\t\"no configuration variable is allowed since the variables list is empty\",\n\t\t\t},\n\t\t\tconfigVars: []string{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"unknown configuration variable\",\n\t\t\tinput: \"vars.UNKNOWN_VARIABLE\",\n\t\t\texpected: []string{\n\t\t\t\t\"undefined configuration variable \\\"unknown_variable\\\".\",\n\t\t\t},\n\t\t\tconfigVars: []string{\"FOO_BAR\"},\n\t\t},\n\t\t{\n\t\t\twhat:  \"config variable naming convention\",\n\t\t\tinput: \"vars.FOO-BAR\",\n\t\t\texpected: []string{\n\t\t\t\t\"configuration variable name \\\"foo-bar\\\" can only contain alphabets, decimal numbers, and '_'.\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"config variable name cannot start with GITHUB_\",\n\t\t\tinput: \"vars.GITHUB_FOOOOOOOO\",\n\t\t\texpected: []string{\n\t\t\t\t\"must not start with the GITHUB_ prefix\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"broken JSON value at fromJSON argument\",\n\t\t\tinput: `fromJSON('{\"foo\": true')`,\n\t\t\texpected: []string{\n\t\t\t\t\"broken JSON string is passed to fromJSON() at offset 12\",\n\t\t\t},\n\t\t},\n\t}\n\n\tallSP := []string{}\n\tfor f := range SpecialFunctionNames {\n\t\tallSP = append(allSP, f)\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tp := NewExprParser()\n\t\t\te, err := p.Parse(NewExprLexer(tc.input + \"}}\"))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"Parse error:\", tc.input)\n\t\t\t}\n\n\t\t\tc := NewExprSemanticsChecker(false, tc.configVars)\n\t\t\tif tc.funcs != nil {\n\t\t\t\tc.funcs = tc.funcs // Set functions for testing\n\t\t\t}\n\t\t\tif tc.matrix != nil {\n\t\t\t\tc.UpdateMatrix(tc.matrix)\n\t\t\t}\n\t\t\tif tc.steps != nil {\n\t\t\t\tc.UpdateSteps(tc.steps)\n\t\t\t}\n\t\t\tif tc.needs != nil {\n\t\t\t\tc.UpdateNeeds(tc.needs)\n\t\t\t}\n\t\t\tif tc.availCtx != nil {\n\t\t\t\tc.SetContextAvailability(tc.availCtx)\n\t\t\t} else {\n\t\t\t\tc.SetContextAvailability([]string{\"github\", \"job\", \"jobs\", \"matrix\", \"steps\", \"needs\", \"env\", \"inputs\", \"secrets\", \"vars\", \"runner\"})\n\t\t\t}\n\t\t\tif tc.availSP != nil {\n\t\t\t\tc.SetSpecialFunctionAvailability(tc.availSP)\n\t\t\t} else {\n\t\t\t\tc.SetSpecialFunctionAvailability(allSP)\n\t\t\t}\n\n\t\t\t_, errs := c.Check(e)\n\t\t\tif len(errs) != len(tc.expected) {\n\t\t\t\tt.Fatalf(\"semantics check should report %d errors but got %d errors: %v\", len(tc.expected), len(errs), errs)\n\t\t\t}\n\t\tLoopErrs:\n\t\t\tfor _, err := range errs {\n\t\t\t\tfor _, want := range tc.expected {\n\t\t\t\t\tif strings.Contains(err.Error(), want) {\n\t\t\t\t\t\tcontinue LoopErrs\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"error %q did not match any expected error messages %#v\", err.Error(), tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprCompareOperandsCheck(t *testing.T) {\n\t// Matrix of operator -> lhs type -> rhs type -> result\n\t// Result `true` means the comparison is allowed. `false` means the comparison causes an error.\n\tmatrix := map[string]map[string]map[string]bool{\n\t\t\"==\": {\n\t\t\t\"number\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   true,\n\t\t\t\t\"null\":   true,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"string\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   true,\n\t\t\t\t\"null\":   true,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"bool\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   true,\n\t\t\t\t\"null\":   true,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"null\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   true,\n\t\t\t\t\"null\":   true,\n\t\t\t\t\"object\": true,\n\t\t\t\t\"array\":  true,\n\t\t\t},\n\t\t\t\"object\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": false,\n\t\t\t\t\"string\": false,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   true,\n\t\t\t\t\"object\": true,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"array\": {\n\t\t\t\t\"any\":      true,\n\t\t\t\t\"number\":   false,\n\t\t\t\t\"string\":   false,\n\t\t\t\t\"bool\":     false,\n\t\t\t\t\"null\":     true,\n\t\t\t\t\"object\":   false,\n\t\t\t\t\"array\":    true,\n\t\t\t\t\"array_2d\": false,\n\t\t\t},\n\t\t\t\"array_2d\": {\n\t\t\t\t\"any\":      true,\n\t\t\t\t\"number\":   false,\n\t\t\t\t\"string\":   false,\n\t\t\t\t\"bool\":     false,\n\t\t\t\t\"null\":     true,\n\t\t\t\t\"object\":   false,\n\t\t\t\t\"array\":    false,\n\t\t\t\t\"array_2d\": true,\n\t\t\t},\n\t\t\t\"any\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   true,\n\t\t\t\t\"null\":   true,\n\t\t\t\t\"object\": true,\n\t\t\t\t\"array\":  true,\n\t\t\t},\n\t\t},\n\t\t\"<\": {\n\t\t\t\"number\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   false,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"string\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   false,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"bool\": {\n\t\t\t\t\"any\":    false,\n\t\t\t\t\"number\": false,\n\t\t\t\t\"string\": false,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   false,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"null\": {\n\t\t\t\t\"any\":    false,\n\t\t\t\t\"number\": false,\n\t\t\t\t\"string\": false,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   false,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"any\": {\n\t\t\t\t\"any\":    true,\n\t\t\t\t\"number\": true,\n\t\t\t\t\"string\": true,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   false,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"object\": {\n\t\t\t\t\"any\":    false,\n\t\t\t\t\"number\": false,\n\t\t\t\t\"string\": false,\n\t\t\t\t\"bool\":   false,\n\t\t\t\t\"null\":   false,\n\t\t\t\t\"object\": false,\n\t\t\t\t\"array\":  false,\n\t\t\t},\n\t\t\t\"array\": {\n\t\t\t\t\"any\":      false,\n\t\t\t\t\"number\":   false,\n\t\t\t\t\"string\":   false,\n\t\t\t\t\"bool\":     false,\n\t\t\t\t\"null\":     false,\n\t\t\t\t\"object\":   false,\n\t\t\t\t\"array\":    false,\n\t\t\t\t\"array_2d\": false,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor op, expr := range matrix {\n\t\tfor lhs, rest := range expr {\n\t\t\tfor rhs, ok := range rest {\n\t\t\t\tinput := lhs + \" \" + op + \" \" + rhs\n\t\t\t\tt.Run(input, func(t *testing.T) {\n\t\t\t\t\tp := NewExprParser()\n\t\t\t\t\te, err := p.Parse(NewExprLexer(input + \"}}\"))\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(\"Parse error:\", input)\n\t\t\t\t\t}\n\n\t\t\t\t\tc := NewExprSemanticsChecker(false, nil)\n\t\t\t\t\tc.vars = map[string]ExprType{\n\t\t\t\t\t\t\"number\": NumberType{},\n\t\t\t\t\t\t\"string\": StringType{},\n\t\t\t\t\t\t\"bool\":   BoolType{},\n\t\t\t\t\t\t\"object\": NewEmptyObjectType(),\n\t\t\t\t\t\t\"array\":  &ArrayType{Elem: NumberType{}},\n\t\t\t\t\t\t\"array_2d\": &ArrayType{\n\t\t\t\t\t\t\tElem: &ArrayType{Elem: NumberType{}},\n\t\t\t\t\t\t},\n\t\t\t\t\t\t\"any\": AnyType{},\n\t\t\t\t\t}\n\t\t\t\t\tc.SetContextAvailability([]string{\n\t\t\t\t\t\t\"any\",\n\t\t\t\t\t\t\"number\",\n\t\t\t\t\t\t\"string\",\n\t\t\t\t\t\t\"bool\",\n\t\t\t\t\t\t\"null\",\n\t\t\t\t\t\t\"object\",\n\t\t\t\t\t\t\"array\",\n\t\t\t\t\t\t\"array_2d\",\n\t\t\t\t\t})\n\n\t\t\t\t\tty, errs := c.Check(e)\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tif len(errs) > 0 {\n\t\t\t\t\t\t\tt.Fatal(\"semantics check failed:\", errs)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif _, ok := ty.(BoolType); !ok {\n\t\t\t\t\t\t\tt.Fatalf(\"wanted bool type but have %q\", ty)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif len(errs) != 1 {\n\t\t\t\t\t\t\tt.Fatal(\"more than one error occurred\", errs)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmsg := errs[0].Error()\n\n\t\t\t\t\t\ttoType := func(n string) string {\n\t\t\t\t\t\t\tswitch n {\n\t\t\t\t\t\t\tcase \"array\":\n\t\t\t\t\t\t\t\treturn \"array<number>\"\n\t\t\t\t\t\t\tcase \"array_2d\":\n\t\t\t\t\t\t\t\treturn \"array<array<number>>\"\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\twant := fmt.Sprintf(\"%q value cannot be compared to %q value with %q operator\", toType(lhs), toType(rhs), op)\n\n\t\t\t\t\t\tif !strings.Contains(msg, want) {\n\t\t\t\t\t\t\tt.Fatalf(\"error message %q doesn't contain expected message %q\", msg, want)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestExprBuiltinFunctionSignatures(t *testing.T) {\n\tfor name, sigs := range BuiltinFuncSignatures {\n\t\tif len(sigs) == 0 {\n\t\t\tt.Errorf(\"overload candidates of %q should not be empty\", name)\n\t\t}\n\t\t{\n\t\t\tok := true\n\t\t\tfor _, r := range name {\n\t\t\t\tif !unicode.IsLower(r) {\n\t\t\t\t\tok = false\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !ok {\n\t\t\t\tt.Errorf(\"name of function must be in lower case to check in case insensitive: %q\", name)\n\t\t\t}\n\t\t}\n\t\tfor i, sig := range sigs {\n\t\t\tif name != strings.ToLower(sig.Name) {\n\t\t\t\tt.Errorf(\"name of %dth overload is different from its key: name=%q vs key=%q\", i+1, sig.Name, name)\n\t\t\t}\n\t\t\tif sig.VariableLengthParams && len(sig.Params) == 0 {\n\t\t\t\tt.Errorf(\"number of arguments of %dth overload of %q must not be empty because VariableLengthParams is set to true\", i+1, name)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestExprSemanticsCheckerUpdateMatrix(t *testing.T) {\n\tc := NewExprSemanticsChecker(false, nil)\n\tty := NewEmptyObjectType()\n\tprev := c.vars[\"matrix\"]\n\tc.UpdateMatrix(ty)\n\tif c.vars[\"matrix\"] == prev {\n\t\tt.Fatalf(\"Global variables map was not copied\")\n\t}\n\tprev = c.vars[\"matrix\"]\n\tc.UpdateMatrix(ty)\n\tif c.vars[\"matrix\"] != prev {\n\t\tt.Fatalf(\"Global variables map was copied when calling UpdateMatrix again\")\n\t}\n}\n\nfunc TestExprSemanticsCheckerUpdateSteps(t *testing.T) {\n\tc := NewExprSemanticsChecker(false, nil)\n\tty := NewEmptyObjectType()\n\tprev := c.vars[\"steps\"]\n\tc.UpdateSteps(ty)\n\tif c.vars[\"steps\"] == prev {\n\t\tt.Fatalf(\"Global variables map was not copied\")\n\t}\n\tprev = c.vars[\"steps\"]\n\tc.UpdateSteps(ty)\n\tif c.vars[\"steps\"] != prev {\n\t\tt.Fatalf(\"Global variables map was copied when calling UpdateSteps again\")\n\t}\n}\n\nfunc TestExprSematincsCheckerUpdateDispatchInputsVarType(t *testing.T) {\n\tty := NewStrictObjectType(map[string]ExprType{\"foo\": NullType{}})\n\tc := NewExprSemanticsChecker(false, nil)\n\tc.UpdateDispatchInputs(ty)\n\to := c.vars[\"github\"].(*ObjectType).Props[\"event\"].(*ObjectType).Props[\"inputs\"].(*ObjectType)\n\tif _, ok := o.Props[\"foo\"]; !ok {\n\t\tt.Error(\"Local github.event.inputs is not updated\", o)\n\t}\n\tif !o.IsStrict() {\n\t\tt.Error(\"Local github.event.inputs is not strict\")\n\t}\n\tfor n, ty := range o.Props {\n\t\tif _, ok := ty.(StringType); !ok {\n\t\t\tt.Errorf(\"Type of %q input is not string: %s\", n, ty)\n\t\t}\n\t}\n\n\t// Check global value is not polluted\n\to = BuiltinGlobalVariableTypes[\"github\"].(*ObjectType).Props[\"event\"].(*ObjectType)\n\tif _, ok := o.Props[\"inputs\"]; ok {\n\t\tt.Error(\"Global github.event.inputs exists\", o)\n\t}\n}\n\nfunc TestExprSemanticsCheckerUpdateInputsMultipleTimes(t *testing.T) {\n\ttests := []struct {\n\t\tfirst  *ObjectType\n\t\tsecond *ObjectType\n\t\twant   *ObjectType\n\t}{\n\t\t{\n\t\t\tfirst: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\tsecond: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": NumberType{},\n\t\t\t}),\n\t\t\twant: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t\t\"bar\": NumberType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tfirst: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\tsecond: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tfirst: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": BoolType{},\n\t\t\t}),\n\t\t\tsecond: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t\twant: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tname := fmt.Sprintf(\"%v then %v\", tc.first, tc.second)\n\t\tt.Run(name, func(t *testing.T) {\n\t\t\tc := NewExprSemanticsChecker(false, nil)\n\t\t\tc.UpdateInputs(tc.first)\n\t\t\tc.UpdateDispatchInputs(tc.second)\n\t\t\thave := c.vars[\"inputs\"]\n\t\t\tif diff := cmp.Diff(have, tc.want); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testObjectPropertiesAreInLowerCase(t *testing.T, ty ExprType) {\n\tt.Helper()\n\tswitch ty := ty.(type) {\n\tcase *ObjectType:\n\t\tfor n, ty := range ty.Props {\n\t\t\tfor _, r := range n {\n\t\t\t\tif 'A' <= r && r <= 'Z' {\n\t\t\t\t\tt.Errorf(\"Property of object must not contain uppercase character because comparison is case insensitive but got %q\", n)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\ttestObjectPropertiesAreInLowerCase(t, ty)\n\t\t}\n\tcase *ArrayType:\n\t\ttestObjectPropertiesAreInLowerCase(t, ty.Elem)\n\t}\n}\n\nfunc TestBuiltinGlobalVariableTypesValidation(t *testing.T) {\n\tfor ctx, ty := range BuiltinGlobalVariableTypes {\n\t\tfor _, r := range ctx {\n\t\t\tif 'A' <= r && r <= 'Z' {\n\t\t\t\tt.Errorf(\"Context name must not contain uppercase character because comparison is case insensitive but got %q\", ctx)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\ttestObjectPropertiesAreInLowerCase(t, ty)\n\t}\n}\n\nfunc TestParseFormatSpecifiers(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\tin   string\n\t\twant []int // Specifiers in the `in` string\n\t}{\n\t\t{\n\t\t\twhat: \"empty input\",\n\t\t\tin:   \"\",\n\t\t},\n\t\t{\n\t\t\twhat: \"no specifier\",\n\t\t\tin:   \"hello, world!\",\n\t\t},\n\t\t{\n\t\t\twhat: \"single specifier\",\n\t\t\tin:   \"Hello{0}specifier\",\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple specifiers\",\n\t\t\tin:   \"{0} {1}{2}x{3}}{4}!\",\n\t\t\twant: []int{0, 1, 2, 3, 4},\n\t\t},\n\t\t{\n\t\t\twhat: \"many specifiers\",\n\t\t\tin:   \"{0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}!\",\n\t\t\twant: []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},\n\t\t},\n\t\t{\n\t\t\twhat: \"unordered\",\n\t\t\tin:   \"{2}foo{4} {0}{3}\",\n\t\t\twant: []int{2, 4, 0, 3},\n\t\t},\n\t\t{\n\t\t\twhat: \"uncontiguous\",\n\t\t\tin:   \"{0} {2}foo{5} {1}\",\n\t\t\twant: []int{0, 2, 5, 1},\n\t\t},\n\t\t{\n\t\t\twhat: \"unclosed\",\n\t\t\tin:   \"{12foo\",\n\t\t},\n\t\t{\n\t\t\twhat: \"not digit\",\n\t\t\tin:   \"{hello}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"space in digits\",\n\t\t\tin:   \"{1 2}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"empty\",\n\t\t\tin:   \"{}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"specifier inside specifier\",\n\t\t\tin:   \"{1{0}2}\",\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\twhat: \"escaped\",\n\t\t\tin:   \"{{hello{{0}{{{{1}world}}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"after escaped\",\n\t\t\tin:   \"{{{{{0}\",\n\t\t\twant: []int{0},\n\t\t},\n\t\t{\n\t\t\twhat: \"kuma-\",\n\t\t\tin:   \"{{}}\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\twant := map[int]struct{}{}\n\t\t\tfor _, i := range tc.want {\n\t\t\t\twant[i] = struct{}{}\n\t\t\t}\n\t\t\thave := parseFormatFuncSpecifiers(tc.in, len(tc.want))\n\n\t\t\tif diff := cmp.Diff(want, have); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// vim: nofoldenable\n"
        },
        {
          "name": "expr_test.go",
          "type": "blob",
          "size": 2.2177734375,
          "content": "package actionlint\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\nfunc TestExprSemanticsCheckRealWorld(t *testing.T) {\n\tf, err := os.Open(filepath.Join(\"testdata\", \"bench\", \"expressions.txt\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer f.Close()\n\n\ts := bufio.NewScanner(f)\n\tfor s.Scan() {\n\t\texpr := s.Text()\n\t\tl := NewExprLexer(expr + \"}}\")\n\t\tp := NewExprParser()\n\t\troot, err := p.Parse(l)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"%q caused parse error: %v\", expr, err)\n\t\t\tcontinue\n\t\t}\n\t\tc := NewExprSemanticsChecker(true, nil)\n\t\tc.Check(root)\n\t}\n\tif err := s.Err(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc BenchmarkExprRealWorld(b *testing.B) {\n\tf, err := os.Open(filepath.Join(\"testdata\", \"bench\", \"expressions.txt\"))\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\texprs := []string{}\n\ts := bufio.NewScanner(f)\n\tfor s.Scan() {\n\t\texprs = append(exprs, s.Text()+\"}}\")\n\t}\n\tf.Close()\n\tif err := s.Err(); err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tb.Run(\"Lex\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, expr := range exprs {\n\t\t\t\tl := NewExprLexer(expr)\n\t\t\t\tfor {\n\t\t\t\t\tt := l.Next()\n\t\t\t\t\tif l.lexErr != nil {\n\t\t\t\t\t\tb.Fatal(l.lexErr)\n\t\t\t\t\t}\n\t\t\t\t\tif t.Kind == TokenKindEnd {\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"LexParse\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, expr := range exprs {\n\t\t\t\tif _, err := NewExprParser().Parse(NewExprLexer(expr)); err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"LexParseSema\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, expr := range exprs {\n\t\t\t\troot, err := NewExprParser().Parse(NewExprLexer(expr + \"}}\"))\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatalf(\"%q caused parse error: %v\", expr, err)\n\t\t\t\t}\n\t\t\t\tNewExprSemanticsChecker(true, nil).Check(root)\n\t\t\t}\n\t\t}\n\t})\n\n\ttrees := []ExprNode{}\n\tfor i := 0; i < b.N; i++ {\n\t\tfor _, expr := range exprs {\n\t\t\tt, err := NewExprParser().Parse(NewExprLexer(expr))\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t\ttrees = append(trees, t)\n\t\t}\n\t}\n\n\tb.Run(\"Sema-untrust\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, t := range trees {\n\t\t\t\tNewExprSemanticsChecker(true, nil).Check(t)\n\t\t\t}\n\t\t}\n\t})\n\n\tb.Run(\"Sema-trust\", func(b *testing.B) {\n\t\tfor i := 0; i < b.N; i++ {\n\t\t\tfor _, t := range trees {\n\t\t\t\tNewExprSemanticsChecker(false, nil).Check(t)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "expr_type.go",
          "type": "blob",
          "size": 11.80078125,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n)\n\n// Types\n\n// ExprType is interface for types of values in expression.\ntype ExprType interface {\n\t// String returns string representation of the type.\n\tString() string\n\t// Assignable returns if other type can be assignable to the type.\n\tAssignable(other ExprType) bool\n\t// Merge merges other type into this type. When other type conflicts with this type, the merged\n\t// result is any type as fallback.\n\tMerge(other ExprType) ExprType\n\t// DeepCopy duplicates itself. All its child types are copied recursively.\n\tDeepCopy() ExprType\n}\n\n// AnyType represents type which can be any type. It also indicates that a value of the type cannot\n// be type-checked since it's type cannot be known statically.\ntype AnyType struct{}\n\nfunc (ty AnyType) String() string {\n\treturn \"any\"\n}\n\n// Assignable returns if other type can be assignable to the type.\nfunc (ty AnyType) Assignable(_ ExprType) bool {\n\treturn true\n}\n\n// Merge merges other type into this type. When other type conflicts with this type, the merged\n// result is any type as fallback.\nfunc (ty AnyType) Merge(other ExprType) ExprType {\n\treturn ty\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty AnyType) DeepCopy() ExprType {\n\treturn ty\n}\n\n// NullType is type for null value.\ntype NullType struct{}\n\nfunc (ty NullType) String() string {\n\treturn \"null\"\n}\n\n// Assignable returns if other type can be assignable to the type.\nfunc (ty NullType) Assignable(other ExprType) bool {\n\tswitch other.(type) {\n\tcase NullType, AnyType:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Merge merges other type into this type. When other type conflicts with this type, the merged\n// result is any type as fallback.\nfunc (ty NullType) Merge(other ExprType) ExprType {\n\tif _, ok := other.(NullType); ok {\n\t\treturn ty\n\t}\n\treturn AnyType{}\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty NullType) DeepCopy() ExprType {\n\treturn ty\n}\n\n// NumberType is type for number values such as integer or float.\ntype NumberType struct{}\n\nfunc (ty NumberType) String() string {\n\treturn \"number\"\n}\n\n// Assignable returns if other type can be assignable to the type.\nfunc (ty NumberType) Assignable(other ExprType) bool {\n\t// TODO: Is string of numbers corced into number?\n\tswitch other.(type) {\n\tcase NumberType, AnyType:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Merge merges other type into this type. When other type conflicts with this type, the merged\n// result is any type as fallback.\nfunc (ty NumberType) Merge(other ExprType) ExprType {\n\tswitch other.(type) {\n\tcase NumberType:\n\t\treturn ty\n\tcase StringType:\n\t\treturn other\n\tdefault:\n\t\treturn AnyType{}\n\t}\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty NumberType) DeepCopy() ExprType {\n\treturn ty\n}\n\n// BoolType is type for boolean values.\ntype BoolType struct{}\n\nfunc (ty BoolType) String() string {\n\treturn \"bool\"\n}\n\n// Assignable returns if other type can be assignable to the type.\nfunc (ty BoolType) Assignable(other ExprType) bool {\n\t// Any type can be converted into bool..\n\t// e.g.\n\t//    if: ${{ steps.foo }}\n\treturn true\n}\n\n// Merge merges other type into this type. When other type conflicts with this type, the merged\n// result is any type as fallback.\nfunc (ty BoolType) Merge(other ExprType) ExprType {\n\tswitch other.(type) {\n\tcase BoolType:\n\t\treturn ty\n\tcase StringType:\n\t\treturn other\n\tdefault:\n\t\treturn AnyType{}\n\t}\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty BoolType) DeepCopy() ExprType {\n\treturn ty\n}\n\n// StringType is type for string values.\ntype StringType struct{}\n\nfunc (ty StringType) String() string {\n\treturn \"string\"\n}\n\n// Assignable returns if other type can be assignable to the type.\nfunc (ty StringType) Assignable(other ExprType) bool {\n\t// Bool and null types also can be coerced into string. But in almost all case, those coercing\n\t// would be mistakes.\n\tswitch other.(type) {\n\tcase StringType, NumberType, AnyType:\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Merge merges other type into this type. When other type conflicts with this type, the merged\n// result is any type as fallback.\nfunc (ty StringType) Merge(other ExprType) ExprType {\n\tswitch other.(type) {\n\tcase StringType, NumberType, BoolType:\n\t\treturn ty\n\tdefault:\n\t\treturn AnyType{}\n\t}\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty StringType) DeepCopy() ExprType {\n\treturn ty\n}\n\n// ObjectType is type for objects, which can hold key-values.\ntype ObjectType struct {\n\t// Props is map from properties name to their type.\n\tProps map[string]ExprType\n\t// Mapped is an element type of this object. This means all props have the type. For example,\n\t// The element type of env context is string.\n\t// AnyType means its property types can be any type so it shapes a loose object. Setting nil\n\t// means properties are mapped to no type so it shapes a strict object.\n\t//\n\t// Invariant: All types in Props field must be assignable to this type.\n\tMapped ExprType\n}\n\n// NewEmptyObjectType creates new loose ObjectType instance which allows unknown props. When\n// accessing to unknown props, their values will fall back to any.\nfunc NewEmptyObjectType() *ObjectType {\n\treturn &ObjectType{map[string]ExprType{}, AnyType{}}\n}\n\n// NewObjectType creates new loose ObjectType instance which allows unknown props with given props.\nfunc NewObjectType(props map[string]ExprType) *ObjectType {\n\treturn &ObjectType{props, AnyType{}}\n}\n\n// NewEmptyStrictObjectType creates new ObjectType instance which does not allow unknown props.\nfunc NewEmptyStrictObjectType() *ObjectType {\n\treturn &ObjectType{map[string]ExprType{}, nil}\n}\n\n// NewStrictObjectType creates new ObjectType instance which does not allow unknown props with\n// given prop types.\nfunc NewStrictObjectType(props map[string]ExprType) *ObjectType {\n\treturn &ObjectType{props, nil}\n}\n\n// NewMapObjectType creates new ObjectType which maps keys to a specific type value.\nfunc NewMapObjectType(t ExprType) *ObjectType {\n\treturn &ObjectType{nil, t}\n}\n\n// IsStrict returns if the type is a strict object, which means no unknown prop is allowed.\nfunc (ty *ObjectType) IsStrict() bool {\n\treturn ty.Mapped == nil\n}\n\n// IsLoose returns if the type is a loose object, which allows any unknown props.\nfunc (ty *ObjectType) IsLoose() bool {\n\t_, ok := ty.Mapped.(AnyType)\n\treturn ok\n}\n\n// Strict sets the object is strict, which means only known properties are allowed.\nfunc (ty *ObjectType) Strict() {\n\tty.Mapped = nil\n}\n\n// Loose sets the object is loose, which means any properties can be set.\nfunc (ty *ObjectType) Loose() {\n\tty.Mapped = AnyType{}\n}\n\nfunc (ty *ObjectType) String() string {\n\tif !ty.IsStrict() {\n\t\tif ty.IsLoose() {\n\t\t\treturn \"object\"\n\t\t}\n\t\treturn fmt.Sprintf(\"{string => %s}\", ty.Mapped.String())\n\t}\n\n\tps := make([]string, 0, len(ty.Props))\n\tfor n := range ty.Props {\n\t\tps = append(ps, n)\n\t}\n\tsort.Strings(ps)\n\n\tvar b strings.Builder\n\tb.WriteByte('{')\n\tfirst := true\n\tfor _, p := range ps {\n\t\tif first {\n\t\t\tfirst = false\n\t\t} else {\n\t\t\tb.WriteString(\"; \")\n\t\t}\n\t\tb.WriteString(p)\n\t\tb.WriteString(\": \")\n\t\tb.WriteString(ty.Props[p].String())\n\t}\n\tb.WriteByte('}')\n\n\treturn b.String()\n}\n\n// Assignable returns if other type can be assignable to the type.\n// In other words, rhs type is more strict than lhs (receiver) type.\nfunc (ty *ObjectType) Assignable(other ExprType) bool {\n\tswitch other := other.(type) {\n\tcase AnyType:\n\t\treturn true\n\tcase *ObjectType:\n\t\tif !ty.IsStrict() {\n\t\t\tif !other.IsStrict() {\n\t\t\t\treturn ty.Mapped.Assignable(other.Mapped)\n\t\t\t}\n\t\t\tfor _, t := range other.Props {\n\t\t\t\tif !ty.Mapped.Assignable(t) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\t// ty is strict\n\n\t\tif !other.IsStrict() {\n\t\t\tfor _, t := range ty.Props {\n\t\t\t\tif !t.Assignable(other.Mapped) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t}\n\t\t// ty and other are strict\n\n\t\tfor n, r := range other.Props {\n\t\t\tif l, ok := ty.Props[n]; !ok || !l.Assignable(r) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Merge merges two object types into one. When other object has unknown props, they are merged into\n// current object. When both have same property, when they are assignable, it remains as-is.\n// Otherwise, the property falls back to any type.\nfunc (ty *ObjectType) Merge(other ExprType) ExprType {\n\tswitch other := other.(type) {\n\tcase *ObjectType:\n\t\t// Shortcuts\n\t\tif len(ty.Props) == 0 && other.IsLoose() {\n\t\t\treturn other\n\t\t}\n\t\tif len(other.Props) == 0 && ty.IsLoose() {\n\t\t\treturn ty\n\t\t}\n\n\t\tmapped := ty.Mapped\n\t\tif mapped == nil {\n\t\t\tmapped = other.Mapped\n\t\t} else if other.Mapped != nil {\n\t\t\tmapped = mapped.Merge(other.Mapped)\n\t\t}\n\n\t\tprops := make(map[string]ExprType, len(ty.Props))\n\t\tfor n, l := range ty.Props {\n\t\t\tprops[n] = l\n\t\t}\n\t\tfor n, r := range other.Props {\n\t\t\tif l, ok := props[n]; ok {\n\t\t\t\tprops[n] = l.Merge(r)\n\t\t\t} else {\n\t\t\t\tprops[n] = r\n\t\t\t\tif mapped != nil {\n\t\t\t\t\tmapped = mapped.Merge(r)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn &ObjectType{\n\t\t\tProps:  props,\n\t\t\tMapped: mapped,\n\t\t}\n\tdefault:\n\t\treturn AnyType{}\n\t}\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty *ObjectType) DeepCopy() ExprType {\n\tp := make(map[string]ExprType, len(ty.Props))\n\tfor n, t := range ty.Props {\n\t\tp[n] = t.DeepCopy()\n\t}\n\tm := ty.Mapped\n\tif m != nil {\n\t\tm = m.DeepCopy()\n\t}\n\treturn &ObjectType{p, m}\n}\n\n// ArrayType is type for arrays.\ntype ArrayType struct {\n\t// Elem is type of element of the array.\n\tElem ExprType\n\t// Deref is true when this type was derived from object filtering syntax (foo.*).\n\tDeref bool\n}\n\nfunc (ty *ArrayType) String() string {\n\treturn fmt.Sprintf(\"array<%s>\", ty.Elem.String())\n}\n\n// Assignable returns if other type can be assignable to the type.\nfunc (ty *ArrayType) Assignable(other ExprType) bool {\n\tswitch other := other.(type) {\n\tcase AnyType:\n\t\treturn true\n\tcase *ArrayType:\n\t\treturn ty.Elem.Assignable(other.Elem)\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Merge merges two object types into one. When other object has unknown props, they are merged into\n// current object. When both have same property, when they are assignable, it remains as-is.\n// Otherwise, the property falls back to any type.\nfunc (ty *ArrayType) Merge(other ExprType) ExprType {\n\tswitch other := other.(type) {\n\tcase *ArrayType:\n\t\tif _, ok := ty.Elem.(AnyType); ok {\n\t\t\treturn ty\n\t\t}\n\t\tif _, ok := other.Elem.(AnyType); ok {\n\t\t\treturn other\n\t\t}\n\t\treturn &ArrayType{\n\t\t\tElem:  ty.Elem.Merge(other.Elem),\n\t\t\tDeref: false, // When fusing array deref type, it means prop deref chain breaks\n\t\t}\n\tdefault:\n\t\treturn AnyType{}\n\t}\n}\n\n// DeepCopy duplicates itself. All its child types are copied recursively.\nfunc (ty *ArrayType) DeepCopy() ExprType {\n\treturn &ArrayType{ty.Elem.DeepCopy(), ty.Deref}\n}\n\n// EqualTypes returns if the two types are equal.\nfunc EqualTypes(l, r ExprType) bool {\n\treturn l.Assignable(r) && r.Assignable(l)\n}\n\n// typeOfJSONValue returns the type of the given JSON value. The JSON value is an any value decoded by json.Unmarshal.\n// https://pkg.go.dev/encoding/json#Unmarshal\n//\n// To unmarshal JSON into an interface value, Unmarshal stores one of these in the interface value:\n//   - bool, for JSON booleans\n//   - float64, for JSON numbers\n//   - string, for JSON strings\n//   - []interface{}, for JSON arrays\n//   - map[string]interface{}, for JSON objects\n//   - nil for JSON null\nfunc typeOfJSONValue(v any) ExprType {\n\tswitch v := v.(type) {\n\tcase bool:\n\t\treturn BoolType{}\n\tcase float64:\n\t\treturn NumberType{}\n\tcase string:\n\t\treturn StringType{}\n\tcase []any:\n\t\tvar elem ExprType\n\t\tfor _, e := range v {\n\t\t\tt := typeOfJSONValue(e)\n\t\t\tif elem == nil {\n\t\t\t\telem = t\n\t\t\t} else {\n\t\t\t\telem = elem.Merge(t)\n\t\t\t}\n\t\t}\n\t\tif elem == nil {\n\t\t\telem = AnyType{}\n\t\t}\n\t\treturn &ArrayType{Elem: elem}\n\tcase map[string]any:\n\t\tprops := make(map[string]ExprType, len(v))\n\t\tfor k, v := range v {\n\t\t\tprops[k] = typeOfJSONValue(v)\n\t\t}\n\t\treturn NewStrictObjectType(props)\n\tcase nil:\n\t\treturn NullType{}\n\tdefault:\n\t\tpanic(v) // Unreachable\n\t}\n}\n"
        },
        {
          "name": "expr_type_test.go",
          "type": "blob",
          "size": 22.20703125,
          "content": "package actionlint\n\nimport (\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"github.com/google/go-cmp/cmp/cmpopts\"\n)\n\nfunc TestExprNewMapObjectType(t *testing.T) {\n\to := NewMapObjectType(StringType{})\n\tif o.Props != nil {\n\t\tt.Fatalf(\"props should be nil but %v\", o.Props)\n\t}\n\tif _, ok := o.Mapped.(StringType); !ok {\n\t\tt.Fatalf(\"mapped type is not string: %v\", o.Mapped)\n\t}\n\tif o.IsStrict() {\n\t\tt.Fatalf(\"map object is not strict object but got %v\", o)\n\t}\n}\n\nfunc TestExprObjectTypeSetStrict(t *testing.T) {\n\to := NewEmptyObjectType()\n\tif o.IsStrict() || !o.IsLoose() {\n\t\tt.Fatal(\"should be loose\")\n\t}\n\to.Strict()\n\tif !o.IsStrict() || o.IsLoose() {\n\t\tt.Fatal(\"should be strict\")\n\t}\n\to.Loose()\n\tif o.IsStrict() || !o.IsLoose() {\n\t\tt.Fatal(\"should be loose\")\n\t}\n}\n\nfunc TestExprAssignableSimple(t *testing.T) {\n\ttestCases := []ExprType{\n\t\tAnyType{},\n\t\tNullType{},\n\t\tNumberType{},\n\t\tBoolType{},\n\t\tStringType{},\n\t\tNewObjectType(map[string]ExprType{\"n\": NumberType{}}),\n\t\tNewStrictObjectType(map[string]ExprType{\"b\": BoolType{}}),\n\t\tNewMapObjectType(NullType{}),\n\t\t&ArrayType{Elem: StringType{}},\n\t}\n\n\tfor _, ty := range testCases {\n\t\ts := ty.String()\n\t\tt.Run(s, func(t *testing.T) {\n\t\t\tif !ty.Assignable(ty) {\n\t\t\t\tt.Fatalf(\"%s is not self-assignable\", ty)\n\t\t\t}\n\n\t\t\tswitch ty.(type) {\n\t\t\tcase NullType:\n\t\t\tcase AnyType:\n\t\t\tdefault:\n\t\t\t\tif (NullType{}).Assignable(ty) {\n\t\t\t\t\tt.Fatalf(\"%s is assignable to null\", ty)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !(AnyType{}).Assignable(ty) {\n\t\t\t\tt.Fatalf(\"%s is not assignable to any\", ty)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprAssignableObject(t *testing.T) {\n\ttestCases := []struct {\n\t\tfrom, to ExprType\n\t\tno       bool\n\t}{\n\t\t{\n\t\t\tfrom: NewMapObjectType(NumberType{}),\n\t\t\tto:   NewMapObjectType(StringType{}),\n\t\t},\n\t\t{\n\t\t\tfrom: NewEmptyObjectType(),\n\t\t\tto:   NewMapObjectType(StringType{}),\n\t\t},\n\t\t{\n\t\t\tfrom: NewMapObjectType(StringType{}),\n\t\t\tto:   NewEmptyObjectType(),\n\t\t},\n\t\t{\n\t\t\tfrom: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"a\": NumberType{},\n\t\t\t\t\"b\": StringType{},\n\t\t\t}),\n\t\t\tto: NewMapObjectType(StringType{}),\n\t\t},\n\t\t{\n\t\t\tfrom: NewStrictObjectType(map[string]ExprType{\"a\": NullType{}}),\n\t\t\tto:   NewMapObjectType(StringType{}),\n\t\t\tno:   true,\n\t\t},\n\t\t{\n\t\t\tfrom: NewMapObjectType(NumberType{}),\n\t\t\tto: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"a\": AnyType{},\n\t\t\t\t\"b\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\tfrom: NewMapObjectType(NumberType{}),\n\t\t\tto: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"a\": NullType{},\n\t\t\t\t\"b\": StringType{},\n\t\t\t}),\n\t\t\tno: true,\n\t\t},\n\t\t{\n\t\t\tfrom: NewStrictObjectType(map[string]ExprType{\"a\": NumberType{}}),\n\t\t\tto:   NewStrictObjectType(map[string]ExprType{\"a\": StringType{}}),\n\t\t},\n\t\t{\n\t\t\tfrom: NewStrictObjectType(map[string]ExprType{\"a\": StringType{}}),\n\t\t\tto:   NewStrictObjectType(map[string]ExprType{\"b\": StringType{}}),\n\t\t\tno:   true,\n\t\t},\n\t\t{\n\t\t\tfrom: NewStrictObjectType(map[string]ExprType{\"a\": NullType{}}),\n\t\t\tto:   NewStrictObjectType(map[string]ExprType{\"a\": StringType{}}),\n\t\t\tno:   true,\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tl, r := tc.to.String(), tc.from.String()\n\t\tt.Run(l+\" := \"+r, func(t *testing.T) {\n\t\t\tif tc.to.Assignable(tc.from) == tc.no {\n\t\t\t\tnot := \"\"\n\t\t\t\tif tc.no {\n\t\t\t\t\tnot = \" not\"\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"%s should%s be assignable to %s\", r, not, l)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprEqualTypes(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat string\n\t\tty   ExprType\n\t\tneq  ExprType\n\t\teq   ExprType\n\t}{\n\t\t{\n\t\t\twhat: \"null\",\n\t\t\tty:   NullType{},\n\t\t\tneq:  StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"number\",\n\t\t\tty:   NumberType{},\n\t\t\tneq:  StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"bool\",\n\t\t\tty:   BoolType{},\n\t\t\tneq:  StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"string\",\n\t\t\tty:   StringType{},\n\t\t\tneq:  BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"object\",\n\t\t\tty:   NewEmptyObjectType(),\n\t\t\tneq:  &ArrayType{Elem: AnyType{}},\n\t\t},\n\t\t{\n\t\t\twhat: \"strict props object\",\n\t\t\tty:   NewEmptyStrictObjectType(),\n\t\t\tneq:  &ArrayType{Elem: AnyType{}},\n\t\t},\n\t\t{\n\t\t\twhat: \"nested object\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\"bar\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t\tneq: &ArrayType{Elem: AnyType{}},\n\t\t},\n\t\t{\n\t\t\twhat: \"nested strict props object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"bar\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t\tneq: &ArrayType{Elem: AnyType{}},\n\t\t},\n\t\t{\n\t\t\twhat: \"nested object prop name\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\tneq: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"nested object prop type\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\tneq: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": BoolType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"strict props object and loose object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t\teq: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"loose object and strict props object\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t\teq: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map objects\",\n\t\t\tty:   NewMapObjectType(NullType{}),\n\t\t\teq:   NewMapObjectType(NullType{}),\n\t\t\tneq:  NewMapObjectType(NumberType{}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object equals loose object\",\n\t\t\tty:   NewMapObjectType(StringType{}),\n\t\t\teq:   NewEmptyObjectType(),\n\t\t},\n\t\t{\n\t\t\twhat: \"loose object equals map object\",\n\t\t\tty:   NewEmptyObjectType(),\n\t\t\teq:   NewMapObjectType(StringType{}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object equals strict object\",\n\t\t\tty:   NewMapObjectType(StringType{}),\n\t\t\teq: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\tneq: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object equals strict object including any prop\",\n\t\t\tty:   NewMapObjectType(StringType{}),\n\t\t\teq: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t\t\"bar\": AnyType{},\n\t\t\t}),\n\t\t\tneq: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t\t\"bar\": AnyType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"strict object equals map object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\teq:  NewMapObjectType(StringType{}),\n\t\t\tneq: NewMapObjectType(NullType{}),\n\t\t},\n\t\t{\n\t\t\twhat: \"array\",\n\t\t\tty:   &ArrayType{Elem: StringType{}},\n\t\t\tneq:  NewEmptyObjectType(),\n\t\t},\n\t\t{\n\t\t\twhat: \"array element type\",\n\t\t\tty:   &ArrayType{Elem: StringType{}},\n\t\t\tneq:  &ArrayType{Elem: BoolType{}},\n\t\t},\n\t\t{\n\t\t\twhat: \"nested array\",\n\t\t\tty: &ArrayType{\n\t\t\t\tElem: &ArrayType{Elem: StringType{}},\n\t\t\t},\n\t\t\tneq: &ArrayType{\n\t\t\t\tElem: &ArrayType{Elem: BoolType{}},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tvar l, r ExprType\n\n\t\t\tl, r = tc.ty, tc.ty\n\t\t\tif !EqualTypes(l, r) {\n\t\t\t\tt.Errorf(\"%s should equal to %s\", l.String(), r.String())\n\t\t\t}\n\t\t\tif tc.neq != nil {\n\t\t\t\tl, r = tc.ty, tc.neq\n\t\t\t\tif EqualTypes(l, r) {\n\t\t\t\t\tt.Errorf(\"%s should not equal to %s\", l.String(), r.String())\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tc.eq != nil {\n\t\t\t\tl, r = tc.ty, tc.eq\n\t\t\t\tif !EqualTypes(l, r) {\n\t\t\t\t\tt.Errorf(\"%s should equal to %s\", l.String(), r.String())\n\t\t\t\t}\n\t\t\t}\n\t\t\tl, r = tc.ty, AnyType{}\n\t\t\tif !EqualTypes(l, r) {\n\t\t\t\tt.Errorf(\"%s should equal to %s\", l.String(), r.String())\n\t\t\t}\n\t\t\tl, r = AnyType{}, tc.ty\n\t\t\tif !EqualTypes(l, r) {\n\t\t\t\tt.Errorf(\"%s should equal to %s\", l.String(), r.String())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprTypeStringize(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat string\n\t\tty   ExprType\n\t\twant string\n\t}{\n\t\t{\n\t\t\twhat: \"any\",\n\t\t\tty:   AnyType{},\n\t\t\twant: \"any\",\n\t\t},\n\t\t{\n\t\t\twhat: \"null\",\n\t\t\tty:   NullType{},\n\t\t\twant: \"null\",\n\t\t},\n\t\t{\n\t\t\twhat: \"number\",\n\t\t\tty:   NumberType{},\n\t\t\twant: \"number\",\n\t\t},\n\t\t{\n\t\t\twhat: \"bool\",\n\t\t\tty:   BoolType{},\n\t\t\twant: \"bool\",\n\t\t},\n\t\t{\n\t\t\twhat: \"string\",\n\t\t\tty:   StringType{},\n\t\t\twant: \"string\",\n\t\t},\n\t\t{\n\t\t\twhat: \"empty object\",\n\t\t\tty:   NewEmptyObjectType(),\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\twhat: \"empty strict props object\",\n\t\t\tty:   NewEmptyStrictObjectType(),\n\t\t\twant: \"{}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"strict object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: \"{foo: string}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"loose object\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: \"object\",\n\t\t},\n\t\t{\n\t\t\twhat: \"strict object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: \"{foo: string}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple props object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t\t\"bar\": NumberType{},\n\t\t\t}),\n\t\t\twant: \"{bar: number; foo: string}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"nested objects\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t\t\"nested\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"foo\": StringType{},\n\t\t\t\t\t\"bar\": NumberType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t\twant: \"{foo: string; nested: {bar: number; foo: string}}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"array\",\n\t\t\tty:   &ArrayType{Elem: AnyType{}},\n\t\t\twant: \"array<any>\",\n\t\t},\n\t\t{\n\t\t\twhat: \"nested arrays\",\n\t\t\tty:   &ArrayType{Elem: &ArrayType{BoolType{}, true}},\n\t\t\twant: \"array<array<bool>>\",\n\t\t},\n\t\t{\n\t\t\twhat: \"array nested in object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": &ArrayType{\n\t\t\t\t\tElem: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\t\"bar\": &ArrayType{\n\t\t\t\t\t\t\tElem: StringType{},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t},\n\t\t\t}),\n\t\t\twant: \"{foo: array<{bar: array<string>}>}\",\n\t\t},\n\t\t{\n\t\t\twhat: \"map object\",\n\t\t\tty:   NewMapObjectType(NumberType{}),\n\t\t\twant: \"{string => number}\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\thave := tc.ty.String()\n\t\t\tif have != tc.want {\n\t\t\t\tt.Fatalf(\"wanted %q but got %q\", tc.want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprTypeMergeSimple(t *testing.T) {\n\ttestCases := []ExprType{\n\t\tAnyType{},\n\t\tNullType{},\n\t\tNumberType{},\n\t\tBoolType{},\n\t\tStringType{},\n\t\tNewEmptyObjectType(),\n\t\tNewEmptyStrictObjectType(),\n\t\tNewMapObjectType(NullType{}),\n\t\t&ArrayType{Elem: StringType{}},\n\t}\n\n\topt := cmpopts.EquateEmpty()\n\n\tfor _, ty := range testCases {\n\t\tt.Run(\"any/\"+ty.String(), func(t *testing.T) {\n\t\t\thave := ty.Merge(AnyType{})\n\t\t\tif _, ok := have.(AnyType); !ok {\n\t\t\t\tt.Errorf(\"any type merged with %s was %s while expecting any\", ty.String(), have.String())\n\t\t\t}\n\n\t\t\thave = (AnyType{}).Merge(ty)\n\t\t\tif _, ok := have.(AnyType); !ok {\n\t\t\t\tt.Errorf(\"%s merged with any type was %s while expecting any\", ty.String(), have.String())\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, ty := range testCases {\n\t\tt.Run(\"incompatible/\"+ty.String(), func(t *testing.T) {\n\t\t\tvar in ExprType\n\t\t\tin = NullType{}\n\t\t\tif ty == (NullType{}) {\n\t\t\t\tin = StringType{} // null is compatible with null so use string instead\n\t\t\t}\n\n\t\t\thave := ty.Merge(in)\n\t\t\tif _, ok := have.(AnyType); !ok {\n\t\t\t\tt.Errorf(\"incompatible %s type merged with %s was %s while expecting any\", in.String(), ty.String(), have.String())\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, ty := range testCases {\n\t\tt.Run(\"self/\"+ty.String(), func(t *testing.T) {\n\t\t\thave := ty.Merge(ty)\n\t\t\tif !cmp.Equal(ty, have, opt) {\n\t\t\t\ts := ty.String()\n\t\t\t\tt.Errorf(\"%s merged with %s was %s while expecting %s\", s, s, have.String(), s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprTypeMergeComplicated(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat string\n\t\tty   ExprType\n\t\twith ExprType\n\t\twant ExprType\n\t}{\n\t\t{\n\t\t\twhat: \"number merges with string\",\n\t\t\tty:   NumberType{},\n\t\t\twith: StringType{},\n\t\t\twant: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"string is merged by number\",\n\t\t\tty:   StringType{},\n\t\t\twith: NumberType{},\n\t\t\twant: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"bool merges with string\",\n\t\t\tty:   BoolType{},\n\t\t\twith: StringType{},\n\t\t\twant: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"string is merged by bool\",\n\t\t\tty:   StringType{},\n\t\t\twith: BoolType{},\n\t\t\twant: StringType{},\n\t\t},\n\t\t{\n\t\t\twhat: \"object props\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"loose object with strict object\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t\twith: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"strict object with strict object\",\n\t\t\tty: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t\twith: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t\twant: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t\t\"bar\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"compatible prop\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"any prop with prop\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"prop with any prop\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"incompatible prop\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NullType{},\n\t\t\t}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": AnyType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"compatible array element\",\n\t\t\tty: &ArrayType{\n\t\t\t\tElem: NumberType{},\n\t\t\t},\n\t\t\twith: &ArrayType{\n\t\t\t\tElem: StringType{},\n\t\t\t},\n\t\t\twant: &ArrayType{\n\t\t\t\tElem: StringType{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"incompatible array element\",\n\t\t\tty: &ArrayType{\n\t\t\t\tElem: NullType{},\n\t\t\t},\n\t\t\twith: &ArrayType{\n\t\t\t\tElem: StringType{},\n\t\t\t},\n\t\t\twant: &ArrayType{\n\t\t\t\tElem: AnyType{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"any array element with element\",\n\t\t\tty: &ArrayType{\n\t\t\t\tElem: AnyType{},\n\t\t\t},\n\t\t\twith: &ArrayType{\n\t\t\t\tElem: StringType{},\n\t\t\t},\n\t\t\twant: &ArrayType{\n\t\t\t\tElem: AnyType{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"array element with any element\",\n\t\t\tty: &ArrayType{\n\t\t\t\tElem: StringType{},\n\t\t\t},\n\t\t\twith: &ArrayType{\n\t\t\t\tElem: AnyType{},\n\t\t\t},\n\t\t\twant: &ArrayType{\n\t\t\t\tElem: AnyType{},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"array with array deref\",\n\t\t\tty:   &ArrayType{StringType{}, false},\n\t\t\twith: &ArrayType{StringType{}, true},\n\t\t\twant: &ArrayType{StringType{}, false},\n\t\t},\n\t\t{\n\t\t\twhat: \"array deref with array\",\n\t\t\tty:   &ArrayType{StringType{}, true},\n\t\t\twith: &ArrayType{StringType{}, false},\n\t\t\twant: &ArrayType{StringType{}, false},\n\t\t},\n\t\t{\n\t\t\twhat: \"array deref with array deref\",\n\t\t\tty:   &ArrayType{StringType{}, true},\n\t\t\twith: &ArrayType{StringType{}, true},\n\t\t\twant: &ArrayType{StringType{}, false},\n\t\t},\n\t\t{\n\t\t\twhat: \"object no prop at left hand side\",\n\t\t\tty:   NewEmptyObjectType(),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"object no prop at right hand side\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t\twith: NewEmptyObjectType(),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"any elem array at left hand side\",\n\t\t\tty:   &ArrayType{AnyType{}, false},\n\t\t\twith: &ArrayType{StringType{}, false},\n\t\t\twant: &ArrayType{AnyType{}, false},\n\t\t},\n\t\t{\n\t\t\twhat: \"any elem array at right hand side\",\n\t\t\tty:   &ArrayType{StringType{}, false},\n\t\t\twith: &ArrayType{AnyType{}, false},\n\t\t\twant: &ArrayType{AnyType{}, false},\n\t\t},\n\t\t{\n\t\t\twhat: \"nested array\",\n\t\t\tty: &ArrayType{\n\t\t\t\tElem: &ArrayType{\n\t\t\t\t\tElem: NumberType{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twith: &ArrayType{\n\t\t\t\tElem: &ArrayType{\n\t\t\t\t\tElem: StringType{},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: &ArrayType{\n\t\t\t\tElem: &ArrayType{\n\t\t\t\t\tElem: StringType{},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"nested objects\",\n\t\t\tty: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\"foo\":  NumberType{},\n\t\t\t\t\t\"piyo\": NumberType{},\n\t\t\t\t}),\n\t\t\t\t\"aaa\": NumberType{},\n\t\t\t\t\"ccc\": NumberType{},\n\t\t\t}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\"bar\":  StringType{},\n\t\t\t\t\t\"piyo\": StringType{},\n\t\t\t\t}),\n\t\t\t\t\"bbb\": StringType{},\n\t\t\t\t\"ccc\": StringType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NewObjectType(map[string]ExprType{\n\t\t\t\t\t\"foo\":  NumberType{},\n\t\t\t\t\t\"bar\":  StringType{},\n\t\t\t\t\t\"piyo\": StringType{},\n\t\t\t\t}),\n\t\t\t\t\"aaa\": NumberType{},\n\t\t\t\t\"bbb\": StringType{},\n\t\t\t\t\"ccc\": StringType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object with compatible map object\",\n\t\t\tty:   NewMapObjectType(NumberType{}),\n\t\t\twith: NewMapObjectType(StringType{}),\n\t\t\twant: NewMapObjectType(StringType{}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object with incompatible map object\",\n\t\t\tty:   NewMapObjectType(NumberType{}),\n\t\t\twith: NewMapObjectType(NullType{}),\n\t\t\twant: NewEmptyObjectType(),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object with compatible object\",\n\t\t\tty:   NewMapObjectType(NumberType{}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": NumberType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"map object with incompatible object\",\n\t\t\tty:   NewMapObjectType(NumberType{}),\n\t\t\twith: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": BoolType{},\n\t\t\t}),\n\t\t\twant: NewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": BoolType{},\n\t\t\t}),\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\topt := cmpopts.EquateEmpty()\n\t\t\tty := tc.with.Merge(tc.ty)\n\t\t\tif diff := cmp.Diff(tc.want, ty, opt); diff != \"\" {\n\t\t\t\tt.Fatalf(\n\t\t\t\t\t\"%s was merged with %s as %s while expecting %s\\ndiff:\\n%s\",\n\t\t\t\t\ttc.ty.String(),\n\t\t\t\t\ttc.with.String(),\n\t\t\t\t\tty.String(),\n\t\t\t\t\ttc.want.String(),\n\t\t\t\t\tdiff,\n\t\t\t\t)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprTypeMergeCreateNewInstance(t *testing.T) {\n\t{\n\t\tty := &ArrayType{\n\t\t\tElem: NumberType{},\n\t\t}\n\t\tty2 := ty.Merge(&ArrayType{\n\t\t\tElem: StringType{},\n\t\t})\n\t\tif ty == ty2 {\n\t\t\tt.Fatalf(\"did not make a new instance (%v => %v)\", ty, ty2)\n\t\t}\n\t\tif _, ok := ty.Elem.(NumberType); !ok {\n\t\t\tt.Fatalf(\"original element type was modified: %v\", ty)\n\t\t}\n\t}\n\n\t{\n\t\tty := NewObjectType(map[string]ExprType{\n\t\t\t\"foo\": NumberType{},\n\t\t})\n\t\tty2 := ty.Merge(\n\t\t\tNewObjectType(map[string]ExprType{\n\t\t\t\t\"foo\": StringType{},\n\t\t\t\t\"bar\": BoolType{},\n\t\t\t}),\n\t\t)\n\t\tif ty == ty2 {\n\t\t\tt.Fatalf(\"did not make a new instance (%v => %v)\", ty, ty2)\n\t\t}\n\t\tif len(ty.Props) != 1 {\n\t\t\tt.Fatalf(\"new prop was added: %v\", ty)\n\t\t}\n\t\tif _, ok := ty.Props[\"foo\"].(NumberType); !ok {\n\t\t\tt.Fatalf(\"prop type was modified: %v\", ty)\n\t\t}\n\t}\n}\n\nfunc TestExprTypeDeepCopy(t *testing.T) {\n\tfor _, ty := range []ExprType{\n\t\tAnyType{},\n\t\tNullType{},\n\t\tBoolType{},\n\t\tStringType{},\n\t\tNumberType{},\n\t} {\n\t\tcopied := ty.DeepCopy()\n\t\tif ty != copied {\n\t\t\tt.Errorf(\"%q and cloned %q must be equal\", ty, copied)\n\t\t}\n\t}\n\n\t{\n\t\tnested := NewObjectType(map[string]ExprType{\n\t\t\t\"piyo\": StringType{},\n\t\t})\n\t\to := NewObjectType(map[string]ExprType{\n\t\t\t\"foo\": NumberType{},\n\t\t\t\"bar\": nested,\n\t\t})\n\n\t\to2 := o.DeepCopy().(*ObjectType)\n\t\tif o2.Props[\"foo\"] != (NumberType{}) {\n\t\t\tt.Fatal(\"o2.foo is not number\", o2.Props[\"foo\"])\n\t\t}\n\t\tnested2 := o2.Props[\"bar\"].(*ObjectType)\n\t\tif nested2.Props[\"piyo\"] != (StringType{}) {\n\t\t\tt.Fatal(\"o2.bar.piyo is not string\", nested2.Props[\"piyo\"])\n\t\t}\n\t\tif o2.Mapped != (AnyType{}) {\n\t\t\tt.Fatal(\"key of o2 is not any\", o2.Mapped)\n\t\t}\n\n\t\to2.Props[\"foo\"] = BoolType{}\n\t\to2.Mapped = NumberType{}\n\t\tnested2.Props[\"piyo\"] = NullType{}\n\t\tif o.Props[\"foo\"] != (NumberType{}) {\n\t\t\tt.Fatal(\"o.foo is not number\", o.Props[\"foo\"])\n\t\t}\n\t\tif nested.Props[\"piyo\"] != (StringType{}) {\n\t\t\tt.Fatal(\"o.bar.piyo is not string\", nested.Props[\"piyo\"])\n\t\t}\n\t\tif o.Mapped != (AnyType{}) {\n\t\t\tt.Fatal(\"key of o is not any\", o2.Mapped)\n\t\t}\n\t}\n\n\t{\n\t\tnested := &ArrayType{StringType{}, false}\n\t\tarr := &ArrayType{nested, false}\n\n\t\tarr2 := arr.DeepCopy().(*ArrayType)\n\t\tnested2 := arr2.Elem.(*ArrayType)\n\t\tif nested2.Elem != (StringType{}) {\n\t\t\tt.Fatal(\"arr2[][] is not string type\", nested2.Elem)\n\t\t}\n\n\t\tnested2.Elem = NullType{}\n\t\tif nested.Elem != (StringType{}) {\n\t\t\tt.Fatal(\"arr[][] is not string type\", nested.Elem)\n\t\t}\n\t}\n}\n\nfunc TestExprTypeTypeOfJSONValue(t *testing.T) {\n\ttests := []struct {\n\t\twhat  string\n\t\tvalue any\n\t\twant  ExprType\n\t}{\n\t\t{\n\t\t\twhat:  \"null\",\n\t\t\tvalue: nil,\n\t\t\twant:  NullType{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"num\",\n\t\t\tvalue: 1.0,\n\t\t\twant:  NumberType{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"string\",\n\t\t\tvalue: \"hello\",\n\t\t\twant:  StringType{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"bool\",\n\t\t\tvalue: true,\n\t\t\twant:  BoolType{},\n\t\t},\n\t\t{\n\t\t\twhat:  \"empty array\",\n\t\t\tvalue: []any{},\n\t\t\twant:  &ArrayType{Elem: AnyType{}},\n\t\t},\n\t\t{\n\t\t\twhat:  \"array\",\n\t\t\tvalue: []any{\"hello\", \"world\"},\n\t\t\twant:  &ArrayType{Elem: StringType{}},\n\t\t},\n\t\t{\n\t\t\twhat:  \"nested array\",\n\t\t\tvalue: []any{[]any{[]any{[]any{\"hi\"}}}},\n\t\t\twant: &ArrayType{\n\t\t\t\tElem: &ArrayType{\n\t\t\t\t\tElem: &ArrayType{\n\t\t\t\t\t\tElem: &ArrayType{\n\t\t\t\t\t\t\tElem: StringType{},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"merged array element\",\n\t\t\tvalue: []any{\"hello\", 1.0, true},\n\t\t\twant:  &ArrayType{Elem: StringType{}},\n\t\t},\n\t\t{\n\t\t\twhat:  \"recursively merged array element\",\n\t\t\tvalue: []any{[]any{\"hello\"}, []any{1.0}, []any{true}},\n\t\t\twant:  &ArrayType{Elem: &ArrayType{Elem: StringType{}}},\n\t\t},\n\t\t{\n\t\t\twhat:  \"array element fallback to any\",\n\t\t\tvalue: []any{\"hello\", nil},\n\t\t\twant:  &ArrayType{Elem: AnyType{}},\n\t\t},\n\t\t{\n\t\t\twhat:  \"empty object\",\n\t\t\tvalue: map[string]any{},\n\t\t\twant:  NewEmptyStrictObjectType(),\n\t\t},\n\t\t{\n\t\t\twhat:  \"object\",\n\t\t\tvalue: map[string]any{\"hello\": 1.0, \"world\": true},\n\t\t\twant: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"hello\": NumberType{},\n\t\t\t\t\"world\": BoolType{},\n\t\t\t}),\n\t\t},\n\t\t{\n\t\t\twhat: \"nested object\",\n\t\t\tvalue: map[string]any{\n\t\t\t\t\"hello\": []any{1.0},\n\t\t\t\t\"world\": map[string]any{\n\t\t\t\t\t\"foo\": true,\n\t\t\t\t\t\"bar\": \"x\",\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\"hello\": &ArrayType{Elem: NumberType{}},\n\t\t\t\t\"world\": NewStrictObjectType(map[string]ExprType{\n\t\t\t\t\t\"foo\": BoolType{},\n\t\t\t\t\t\"bar\": StringType{},\n\t\t\t\t}),\n\t\t\t}),\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\thave := typeOfJSONValue(tc.value)\n\t\t\tif diff := cmp.Diff(tc.want, have); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestExprTypePanicTypeOfJSONValue(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r == nil {\n\t\t\tt.Fatal(\"error didn't occur\")\n\t\t}\n\t}()\n\ttypeOfJSONValue(struct{}{})\n}\n"
        },
        {
          "name": "fuzz",
          "type": "tree",
          "content": null
        },
        {
          "name": "glob.go",
          "type": "blob",
          "size": 7.0625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"text/scanner\"\n\t\"unicode\"\n)\n\n// Note:\n// - Broken pattern causes a syntax error\n//   - '+' or '?' at top of pattern\n//   - preceding character of '+' or '?' is special character like '+', '?', '*'\n//   - Missing ] in [...] pattern like '[0-9'\n//   - Missing end of range in [...] like '[0-]'\n// - \\ can escape special characters like '['. Otherwise \\ is handled as normal character\n// - invalid characters for Git ref names are not checked on GitHub Actions runtime\n//   - `man git-check-ref-format` for more details\n//   - \\ is invalid character for ref names. it means that \\ can be used only for escaping special chars\n\n// InvalidGlobPattern is an error on invalid glob pattern.\ntype InvalidGlobPattern struct {\n\t// Message is a human readable error message.\n\tMessage string\n\t// Column is a column number of the error in the glob pattern. This value is 1-based, but zero\n\t// is valid value. Zero means the error occurred before reading first character. This happens\n\t// when a given pattern is empty. When the given pattern include a newline and line number\n\t// increases (invalid pattern), the column number falls back into always 0.\n\tColumn int\n}\n\nfunc (err *InvalidGlobPattern) Error() string {\n\treturn fmt.Sprintf(\"%d: %s\", err.Column, err.Message)\n}\n\nfunc (err *InvalidGlobPattern) String() string {\n\treturn err.Error()\n}\n\ntype globValidator struct {\n\tisRef bool\n\tprec  bool\n\terrs  []InvalidGlobPattern\n\tscan  scanner.Scanner\n}\n\nfunc (v *globValidator) error(msg string) {\n\tp := v.scan.Pos()\n\t// - 1 because character at the error position is already eaten from scanner\n\tc := p.Column - 1\n\tif p.Line > 1 {\n\t\tc = 0 // fallback to 0\n\t}\n\tv.errs = append(v.errs, InvalidGlobPattern{msg, c})\n}\n\nfunc (v *globValidator) unexpected(char rune, what, why string) {\n\tunexpected := \"unexpected EOF\"\n\tif char != scanner.EOF {\n\t\tunexpected = fmt.Sprintf(\"unexpected character %q\", char)\n\t}\n\n\twhile := \"\"\n\tif what != \"\" {\n\t\twhile = fmt.Sprintf(\" while checking %s\", what)\n\t}\n\n\tv.error(fmt.Sprintf(\"invalid glob pattern. %s%s. %s\", unexpected, while, why))\n}\n\nfunc (v *globValidator) invalidRefChar(c rune, why string) {\n\tcfmt := \"%q\"\n\tif unicode.IsPrint(c) {\n\t\tcfmt = \"'%c'\" // avoid '\\\\'\n\t}\n\tformat := \"character \" + cfmt + \" is invalid for branch and tag names. %s. see `man git-check-ref-format` for more details. note that regular expression is unavailable\"\n\tmsg := fmt.Sprintf(format, c, why)\n\tv.error(msg)\n}\n\nfunc (v *globValidator) init(pat string) {\n\tv.errs = []InvalidGlobPattern{}\n\tv.prec = false\n\tv.scan.Init(strings.NewReader(pat))\n\tv.scan.Error = func(s *scanner.Scanner, m string) {\n\t\tv.error(fmt.Sprintf(\"error while scanning glob pattern %q: %s\", pat, m))\n\t}\n}\n\nfunc (v *globValidator) validateNext() bool {\n\tc := v.scan.Next()\n\tprec := true\n\n\tswitch c {\n\tcase '\\\\':\n\t\tswitch v.scan.Peek() {\n\t\tcase '[', '?', '*':\n\t\t\tc = v.scan.Next() // eat escaped character\n\t\t\tif v.isRef {\n\t\t\t\tv.invalidRefChar(v.scan.Peek(), \"ref name cannot contain spaces, ~, ^, :, [, ?, *\")\n\t\t\t}\n\t\tcase '+', '\\\\', '!':\n\t\t\tc = v.scan.Next() // eat escaped character\n\t\tdefault:\n\t\t\t// file path can contain '\\' (`mkdir 'foo\\bar'` works)\n\t\t\tif v.isRef {\n\t\t\t\tv.invalidRefChar('\\\\', \"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\")\n\t\t\t\tc = v.scan.Next()\n\t\t\t}\n\t\t}\n\tcase '?':\n\t\tif !v.prec {\n\t\t\tv.unexpected('?', \"special character ? (zero or one)\", \"the preceding character must not be special character\")\n\t\t}\n\t\tprec = false\n\tcase '+':\n\t\tif !v.prec {\n\t\t\tv.unexpected('+', \"special character + (one or more)\", \"the preceding character must not be special character\")\n\t\t}\n\t\tprec = false\n\tcase '*':\n\t\tprec = false\n\tcase '[':\n\t\tif v.scan.Peek() == ']' {\n\t\t\tc = v.scan.Next() // eat ]\n\t\t\tv.unexpected(']', \"content of character match []\", \"character match must not be empty\")\n\t\t\tbreak\n\t\t}\n\n\t\tchars := 0\n\tLoop:\n\t\tfor {\n\t\t\tc = v.scan.Next()\n\t\t\tswitch c {\n\t\t\tcase ']':\n\t\t\t\tbreak Loop\n\t\t\tcase scanner.EOF:\n\t\t\t\tv.unexpected(c, \"end of character match []\", \"missing ]\")\n\t\t\t\treturn false\n\t\t\tdefault:\n\t\t\t\tif v.scan.Peek() != '-' {\n\t\t\t\t\t// in case of single character\n\t\t\t\t\tchars++\n\t\t\t\t\tcontinue Loop\n\t\t\t\t}\n\t\t\t\t// When match is range of character like 0-9\n\n\t\t\t\tchars += 2 // actually one or more. but this is ok since we only check chars > 1 later\n\t\t\t\ts := c\n\t\t\t\t//lint:ignore SA4006 c should always holds the current character even if it is unused\n\t\t\t\tc = v.scan.Next() // eat -\n\t\t\t\tswitch v.scan.Peek() {\n\t\t\t\tcase ']':\n\t\t\t\t\tc = v.scan.Next() // eat ]\n\t\t\t\t\tv.unexpected(c, \"character range in []\", \"end of range is missing\")\n\t\t\t\t\tbreak Loop\n\t\t\t\tcase scanner.EOF:\n\t\t\t\t\t// do nothing\n\t\t\t\tdefault:\n\t\t\t\t\tc = v.scan.Next() // eat end of range\n\t\t\t\t\tif s > c {\n\t\t\t\t\t\twhy := fmt.Sprintf(\"start of range %q (%d) is larger than end of range %q (%d)\", s, s, c, c)\n\t\t\t\t\t\tv.unexpected(c, \"character range in []\", why)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif chars == 1 {\n\t\t\tv.unexpected(c, \"character match []\", \"character match with single character is useless. simply use x instead of [x]\")\n\t\t}\n\tcase '\\r':\n\t\tif v.scan.Peek() == '\\n' {\n\t\t\tc = v.scan.Next()\n\t\t}\n\t\tv.unexpected(c, \"\", \"newline cannot be contained\")\n\tcase '\\n':\n\t\tv.unexpected('\\n', \"\", \"newline cannot be contained\")\n\tcase ' ', '\\t', '~', '^', ':':\n\t\tif v.isRef {\n\t\t\tv.invalidRefChar(c, \"ref name cannot contain spaces, ~, ^, :, [, ?, *\")\n\t\t}\n\tdefault:\n\t}\n\tv.prec = prec\n\n\tif v.scan.Peek() == scanner.EOF {\n\t\tif v.isRef && (c == '/' || c == '.') {\n\t\t\tv.invalidRefChar(c, \"ref name must not end with / and .\")\n\t\t}\n\t\treturn false\n\t}\n\n\treturn true\n}\n\nfunc (v *globValidator) validate(pat string) {\n\tv.init(pat)\n\n\tif pat == \"\" {\n\t\tv.error(\"glob pattern cannot be empty\")\n\t\treturn\n\t}\n\n\t// Handle first character if necessary\n\tswitch v.scan.Peek() {\n\tcase '/':\n\t\tif v.isRef {\n\t\t\tv.scan.Next()\n\t\t\tv.invalidRefChar('/', \"ref name must not start with /\")\n\t\t\tv.prec = true\n\t\t}\n\tcase '!':\n\t\tv.scan.Next()\n\t\tif v.scan.Peek() == scanner.EOF {\n\t\t\tv.unexpected('!', \"! at first character (negate pattern)\", \"at least one character must follow !\")\n\t\t\treturn\n\t\t}\n\t\tv.prec = false\n\t}\n\n\tfor v.validateNext() {\n\t}\n}\n\nfunc validateGlob(pat string, isRef bool) []InvalidGlobPattern {\n\tv := globValidator{}\n\tv.isRef = isRef\n\tv.validate(pat)\n\treturn v.errs\n}\n\n// ValidateRefGlob checks a given input as glob pattern for Git ref names. It returns list of\n// errors found by the validation. See the following URL for more details of the syntax:\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet\nfunc ValidateRefGlob(pat string) []InvalidGlobPattern {\n\treturn validateGlob(pat, true)\n}\n\n// ValidatePathGlob checks a given input as glob pattern for file paths. It returns list of\n// errors found by the validation. See the following URL for more details of the syntax:\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet\nfunc ValidatePathGlob(pat string) []InvalidGlobPattern {\n\tif strings.HasPrefix(pat, \" \") {\n\t\treturn []InvalidGlobPattern{\n\t\t\t{\"path value must not start with spaces\", 0},\n\t\t}\n\t}\n\tif strings.HasSuffix(pat, \" \") {\n\t\treturn []InvalidGlobPattern{\n\t\t\t{\"path value must not end with spaces\", len(pat)},\n\t\t}\n\t}\n\treturn validateGlob(pat, false)\n}\n"
        },
        {
          "name": "glob_test.go",
          "type": "blob",
          "size": 9.439453125,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestInvalidGlobPatternMessage(t *testing.T) {\n\twant := \"42: this is message\"\n\terr := &InvalidGlobPattern{\"this is message\", 42}\n\thave := err.Error()\n\tif want != have {\n\t\tt.Fatalf(\"want %q but have %q\", want, have)\n\t}\n}\n\nfunc TestValidateGlobOK(t *testing.T) {\n\ttestCases := []string{\n\t\t\"a\",\n\t\t\"abc/def\",\n\t\t\"[ab]\",\n\t\t\"[a-z]\",\n\t\t\"[a-zA-Z_]\",\n\t\t\"[xA-Zy0-9z]\",\n\t\t\"[xy][A-Z][yz][0-9][zx]\",\n\t\t\"xy[A-Z]yz[0-9]zx\",\n\t\t\"*\",\n\t\t\"**\",\n\t\t\"*/*\",\n\t\t\"*/**\",\n\t\t\"a?\",\n\t\t\"a+\",\n\t\t`\\+`,\n\t\t`\\\\`,\n\t\t`\\!`,       // escaped as \"!\"\n\t\t`foo\\!bar`, // escaped as \"foo!bar\"\n\t\t`\\++\\\\?`,\n\t\t\"[a-z]+\",\n\t\t\"[a-z]?\",\n\t\t\"*.*.*-**\",\n\t\t\"!a\",\n\t\t\"a!\",\n\t\t\"a!+\", // this is ok because ! has no special meaning\n\t\t\"a!?\",\n\t\t\"!*\",\n\t\t// examples in official documents\n\t\t\"feature/*\",\n\t\t\"feature/**\",\n\t\t\"main\",\n\t\t\"releases/mona-the-octcat\",\n\t\t\"*\",\n\t\t\"**\",\n\t\t\"*feature\",\n\t\t\"v2*\",\n\t\t\"v[12].[0-9]+.[0-9]+\",\n\t}\n\n\tfor _, input := range testCases {\n\t\tt.Run(input, func(t *testing.T) {\n\t\t\tif errs := ValidateRefGlob(input); len(errs) > 0 {\n\t\t\t\tt.Errorf(\"ref glob %q caused %d errors: %v\", input, len(errs), errs)\n\t\t\t}\n\t\t\tif errs := ValidatePathGlob(input); len(errs) > 0 {\n\t\t\t\tt.Errorf(\"path glob %q caused %d errors: %v\", input, len(errs), errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateGlobPathOnlyOK(t *testing.T) {\n\ttestCases := []string{\n\t\t\".\",\n\t\t\"/foo\",\n\t\t\"/foo/\",\n\t\t\"/foo/bar\",\n\t\t`\\[\\?\\*\\+\\\\`,\n\t\t\"foo bar\",\n\t\t\"~/foo\",\n\t\t\"foo:bar\",\n\t\t\"foo^bar\",\n\t\t// examples in official document\n\t\t\"*.jsx?\",\n\t\t\"*.js\",\n\t\t\"**.js\",\n\t\t\"docs/*\",\n\t\t\"docs/**\",\n\t\t\"docs/**/*.md\",\n\t\t\"**/docs/**\",\n\t\t\"**/README.md\",\n\t\t\"**/*src/**\",\n\t\t\"*/*-post.md\",\n\t\t\"**/migrate-*.sql\",\n\t\t\"!README.md\",\n\t}\n\n\tfor _, input := range testCases {\n\t\tt.Run(input, func(t *testing.T) {\n\t\t\tif errs := ValidatePathGlob(input); len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"path glob %q caused errors: %v\", input, errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateGlobSyntaxError(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat        string\n\t\tinput       string\n\t\texpected    string\n\t\texpectedAll []string\n\t}{\n\t\t{\n\t\t\twhat:     \"empty\",\n\t\t\tinput:    \"\",\n\t\t\texpected: \"glob pattern cannot be empty\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"nothing after negate\",\n\t\t\tinput:    \"!\",\n\t\t\texpected: \"at least one character must follow !\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"? as first character\",\n\t\t\tinput:    \"?\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"? following special character\",\n\t\t\tinput:    \"*?\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"? following ?\",\n\t\t\tinput:    \"a??\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"+ as first character\",\n\t\t\tinput:    \"+\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"+ following special character\",\n\t\t\tinput:    \"*+\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"+ following +\",\n\t\t\tinput:    \"a++\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"newline in pattern\",\n\t\t\tinput:    \"\\n\",\n\t\t\texpected: \"newline cannot be contained\",\n\t\t},\n\t\t{\n\t\t\twhat:     `newline with \\r in pattern`,\n\t\t\tinput:    \"\\r\",\n\t\t\texpected: `'\\r'`,\n\t\t},\n\t\t{\n\t\t\twhat:     `newline with \\r\\n in pattern`,\n\t\t\tinput:    \"\\r\\n\",\n\t\t\texpected: `'\\n'`,\n\t\t},\n\t\t{\n\t\t\twhat:     \"empty match\",\n\t\t\tinput:    \"[]\",\n\t\t\texpected: \"character match must not be empty\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing [ with empty match\",\n\t\t\tinput:    \"[\",\n\t\t\texpected: \"missing ]\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing [\",\n\t\t\tinput:    \"[a\",\n\t\t\texpected: \"missing ]\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing [ with range\",\n\t\t\tinput:    \"[a-c\",\n\t\t\texpected: \"missing ]\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"missing end of range\",\n\t\t\tinput:    \"[a-]\",\n\t\t\texpected: \"end of range is missing\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"EOF inside range\",\n\t\t\tinput:    \"[a-\",\n\t\t\texpected: \"missing ]\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"invalid range\",\n\t\t\tinput:    \"[b-a]\",\n\t\t\texpected: \"start of range 'b' (98) is larger than end of range 'a' (97)\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"single character match\",\n\t\t\tinput:    \"[x]\",\n\t\t\texpected: \"character match with single character is useless\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"multiple errors\",\n\t\t\tinput: \"+?[][a-]*+\\n[b\",\n\t\t\texpectedAll: []string{\n\t\t\t\t\"the preceding character must not be special character\",\n\t\t\t\t\"the preceding character must not be special character\",\n\t\t\t\t\"character match must not be empty\",\n\t\t\t\t\"end of range is missing\",\n\t\t\t\t\"the preceding character must not be special character\",\n\t\t\t\t\"newline cannot be contained\",\n\t\t\t\t\"missing ]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"preceding character is negate for ?\",\n\t\t\tinput:    \"!?\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"preceding character is negate for +\",\n\t\t\tinput:    \"!+\",\n\t\t\texpected: \"the preceding character must not be special character\",\n\t\t},\n\t}\n\n\tfor _, kind := range []string{\"ref\", \"path\"} {\n\t\tfor _, tc := range testCases {\n\t\t\tt.Run(kind+\"/\"+tc.what, func(t *testing.T) {\n\t\t\t\tvar errs []InvalidGlobPattern\n\t\t\t\tif kind == \"ref\" {\n\t\t\t\t\terrs = ValidateRefGlob(tc.input)\n\t\t\t\t} else {\n\t\t\t\t\terrs = ValidatePathGlob(tc.input)\n\t\t\t\t}\n\n\t\t\t\texpected := tc.expectedAll\n\t\t\t\tif len(expected) == 0 {\n\t\t\t\t\texpected = []string{tc.expected}\n\t\t\t\t}\n\n\t\t\t\tif len(errs) != len(expected) {\n\t\t\t\t\tt.Fatalf(\"wanted %d errors from %s glob %q but got %d errors\", len(expected), kind, tc.input, len(errs))\n\t\t\t\t}\n\n\t\t\t\tfor i := range errs {\n\t\t\t\t\terr := errs[i]\n\t\t\t\t\twant, have := expected[i], err.Message\n\t\t\t\t\tif !strings.Contains(have, want) {\n\t\t\t\t\t\tt.Errorf(\"%dth error message at col:%d from %s glob %q does not contain expected string:\\n  want: %s\\n  have: %s\", i+1, err.Column, kind, tc.input, want, have)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestValidateGlobGitRefNameInvalidCharacter(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat        string\n\t\tinput       string\n\t\texpected    string\n\t\texpectedAll []string\n\t}{\n\t\t{\n\t\t\twhat:     \"start with /\",\n\t\t\tinput:    \"/foo\",\n\t\t\texpected: \"ref name must not start with /\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"end with /\",\n\t\t\tinput:    \"foo/\",\n\t\t\texpected: \"ref name must not end with / and .\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"end with .\",\n\t\t\tinput:    \"foo.\",\n\t\t\texpected: \"ref name must not end with / and .\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"escaped special chars\",\n\t\t\tinput: `\\[\\?\\*`,\n\t\t\texpectedAll: []string{\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:     \"escaped non-special character\",\n\t\t\tinput:    `\\d`,\n\t\t\texpected: \"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"prohibited characters for ref names\",\n\t\t\tinput: \" \t~^:\",\n\t\t\texpectedAll: []string{\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"regular expression string\",\n\t\t\tinput: `/^v\\d+\\.\\d+\\.(x|\\d+)$/`,\n\t\t\texpectedAll: []string{\n\t\t\t\t\"ref name must not start with /\",\n\t\t\t\t\"ref name cannot contain spaces, ~, ^, :, [, ?, *\",\n\t\t\t\t\"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\",\n\t\t\t\t\"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\",\n\t\t\t\t\"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\",\n\t\t\t\t\"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\",\n\t\t\t\t\"only special characters [, ?, +, *, \\\\, ! can be escaped with \\\\\",\n\t\t\t\t\"ref name must not end with / and .\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\terrs := ValidateRefGlob(tc.input)\n\n\t\t\texpected := tc.expectedAll\n\t\t\tif len(expected) == 0 {\n\t\t\t\texpected = []string{tc.expected}\n\t\t\t}\n\n\t\t\tif len(errs) != len(expected) {\n\t\t\t\tt.Fatalf(\"wanted %d errors from %q but got %d errors\", len(expected), tc.input, len(errs))\n\t\t\t}\n\n\t\t\tfor i := range errs {\n\t\t\t\terr := errs[i]\n\t\t\t\twant, have := expected[i], err.Message\n\t\t\t\tif !strings.Contains(have, want) {\n\t\t\t\t\tt.Errorf(\"%dth error message at col:%d from %q does not contain expected string:\\n  want: %s\\n  have: %s\", i+1, err.Column, tc.input, want, have)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateGlobErrorColumn(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput string\n\t\tcol   int\n\t}{\n\t\t{\"\", 0},\n\t\t{\"!\", 1},\n\t\t{\"?\", 1},\n\t\t{\"+\", 1},\n\t\t{\"*?\", 2},\n\t\t{\"a++\", 3},\n\t\t{\"a\\n\", 0}, // fallback\n\t\t{\"[]\", 2},\n\t\t{\"[0\", 2},\n\t\t{\"[0-]\", 4},\n\t\t{\"[0-\", 3},\n\t\t{\"[b-a]\", 4},\n\t\t{\"/foo\", 1},\n\t\t{\"foo/\", 4},\n\t\t{\"foo.\", 4},\n\t\t{`\\[`, 2},\n\t\t{`foo bar`, 4},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.input, func(t *testing.T) {\n\t\t\terrs := ValidateRefGlob(tc.input)\n\n\t\t\tif len(errs) != 1 {\n\t\t\t\tt.Fatalf(\"wanted 1 error from %q but got %d errors: %v\", tc.input, len(errs), errs)\n\t\t\t}\n\n\t\t\twant, have := tc.col, errs[0].Column\n\t\t\tif want != have {\n\t\t\t\tt.Errorf(\"error position is unexpected. wanted col:%d but have col:%d: %s\", want, have, errs[0].Message)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestValidateGlobQuoteCharacterInErrorMessage(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput    string\n\t\texpected string\n\t}{\n\t\t{\"!\", \"'!'\"},\n\t\t{`\\d`, `'\\'`},\n\t\t{\"\\n\", `'\\n'`},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"%q shows %s\", tc.input, tc.expected), func(t *testing.T) {\n\t\t\terrs := ValidateRefGlob(tc.input)\n\t\t\tif len(errs) == 0 {\n\t\t\t\tt.Fatalf(\"no error found in %q\", tc.input)\n\t\t\t}\n\t\t\tm := errs[0].Message\n\t\t\tif !strings.Contains(m, tc.expected) {\n\t\t\t\tt.Fatalf(\"error message %q does not contain %q\", m, tc.expected)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.517578125,
          "content": "module github.com/rhysd/actionlint\n\ngo 1.18\n\nrequire (\n\tgithub.com/bmatcuk/doublestar/v4 v4.7.1\n\tgithub.com/fatih/color v1.18.0\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/mattn/go-colorable v0.1.13\n\tgithub.com/mattn/go-runewidth v0.0.16\n\tgithub.com/mattn/go-shellwords v1.0.12\n\tgithub.com/robfig/cron/v3 v3.0.1\n\tgithub.com/yuin/goldmark v1.7.8\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/sys v0.29.0\n\tgopkg.in/yaml.v3 v3.0.1\n)\n\nrequire (\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.6904296875,
          "content": "github.com/bmatcuk/doublestar/v4 v4.7.1 h1:fdDeAqgT47acgwd9bd9HxJRDmc9UAmPpc+2m0CXv75Q=\ngithub.com/bmatcuk/doublestar/v4 v4.7.1/go.mod h1:xBQ8jztBU6kakFMg+8WGxn0c6z1fTSPVIjEY1Wr7jzc=\ngithub.com/fatih/color v1.18.0 h1:S8gINlzdQ840/4pfAwic/ZE0djQEH3wM94VfqLTZcOM=\ngithub.com/fatih/color v1.18.0/go.mod h1:4FelSpRwEGDpQ12mAdzqdOukCy4u8WUtOY6lkT/6HfU=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/mattn/go-colorable v0.1.13 h1:fFA4WZxdEF4tXPZVKMLwD8oUnCTTo08duU7wxecdEvA=\ngithub.com/mattn/go-colorable v0.1.13/go.mod h1:7S9/ev0klgBDR4GtXTXX8a3vIGJpMovkB8vQcUbaXHg=\ngithub.com/mattn/go-isatty v0.0.16/go.mod h1:kYGgaQfpe5nmfYZH+SKPsOc2e4SrIfOl2e/yFXSvRLM=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/mattn/go-shellwords v1.0.12 h1:M2zGm7EW6UQJvDeQxo4T51eKPurbeFbe8WtebGE2xrk=\ngithub.com/mattn/go-shellwords v1.0.12/go.mod h1:EZzvwXDESEeg03EKmM+RmDnNOPKG4lLtQsUlTZDWQ8Y=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/robfig/cron/v3 v3.0.1 h1:WdRxkvbJztn8LMz/QEvLN5sBU+xKpSqwwUO1Pjr4qDs=\ngithub.com/robfig/cron/v3 v3.0.1/go.mod h1:eQICP3HwyT7UooqI/z+Ov+PtYAWygg1TEWWzGIFLtro=\ngithub.com/yuin/goldmark v1.7.8 h1:iERMLn0/QJeHFhxSt3p6PeN9mGnvIKSpG9YYorDMnic=\ngithub.com/yuin/goldmark v1.7.8/go.mod h1:uzxRWxtg69N339t3louHJ7+O03ezfj6PlliRlaOzY1E=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20220811171246-fbc7d0a398ab/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "linter.go",
          "type": "blob",
          "size": 18.48828125,
          "content": "package actionlint\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/fatih/color\"\n\t\"github.com/mattn/go-colorable\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"golang.org/x/sync/semaphore\"\n)\n\n// LogLevel is log level of logger used in Linter instance.\ntype LogLevel int\n\nconst (\n\t// LogLevelNone does not output any log output.\n\tLogLevelNone LogLevel = 0\n\t// LogLevelVerbose shows verbose log output. This is equivalent to specifying -verbose option\n\t// to actionlint command.\n\tLogLevelVerbose = 1\n\t// LogLevelDebug shows all log output including debug information.\n\tLogLevelDebug = 2\n)\n\n// ColorOptionKind is kind of colorful output behavior.\ntype ColorOptionKind int\n\nconst (\n\t// ColorOptionKindAuto is kind to determine to colorize errors output automatically. It is\n\t// determined based on pty and $NO_COLOR environment variable. See document of fatih/color\n\t// for more details.\n\tColorOptionKindAuto ColorOptionKind = iota\n\t// ColorOptionKindAlways is kind to always colorize errors output.\n\tColorOptionKindAlways\n\t// ColorOptionKindNever is kind never to colorize errors output.\n\tColorOptionKindNever\n)\n\n// LinterOptions is set of options for Linter instance. This struct is used for NewLinter factory\n// function call. The zero value LinterOptions{} represents the default behavior.\ntype LinterOptions struct {\n\t// Verbose is flag if verbose log output is enabled.\n\tVerbose bool\n\t// Debug is flag if debug log output is enabled.\n\tDebug bool\n\t// LogWriter is io.Writer object to use to print log outputs. Note that error outputs detected\n\t// by the linter are not included in the log outputs.\n\tLogWriter io.Writer\n\t// Color is option for colorizing error outputs. See ColorOptionKind document for each enum values.\n\tColor ColorOptionKind\n\t// Oneline is flag if one line output is enabled. When enabling it, one error is output per one\n\t// line. It is useful when reading outputs from programs.\n\tOneline bool\n\t// Shellcheck is executable for running shellcheck external command. It can be command name like\n\t// \"shellcheck\" or file path like \"/path/to/shellcheck\", \"path/to/shellcheck\". When this value\n\t// is empty, shellcheck won't run to check scripts in workflow file.\n\tShellcheck string\n\t// Pyflakes is executable for running pyflakes external command. It can be command name like \"pyflakes\"\n\t// or file path like \"/path/to/pyflakes\", \"path/to/pyflakes\". When this value is empty, pyflakes\n\t// won't run to check scripts in workflow file.\n\tPyflakes string\n\t// IgnorePatterns is list of regular expression to filter errors. The pattern is applied to error\n\t// messages. When an error is matched, the error is ignored.\n\tIgnorePatterns []string\n\t// ConfigFile is a path to config file. Empty string means no config file path is given. In\n\t// the case, actionlint will try to read config from .github/actionlint.yaml.\n\tConfigFile string\n\t// Format is a custom template to format error messages. It must follow Go Template format and\n\t// contain at least one {{ }} placeholder. https://pkg.go.dev/text/template\n\tFormat string\n\t// StdinFileName is a file name when reading input from stdin. When this value is empty, \"<stdin>\"\n\t// is used as the default value.\n\tStdinFileName string\n\t// WorkingDir is a file path to the current working directory. When this value is empty, os.Getwd\n\t// will be used to get a working directory.\n\tWorkingDir string\n\t// OnRulesCreated is a hook to add or remove the check rules. This function is called on checking\n\t// every workflow files. Rules created by Linter instance are passed to the argument and the\n\t// function should return the modified rules.\n\t// Note that syntax errors may be reported even if this function returns nil or an empty slice.\n\tOnRulesCreated func([]Rule) []Rule\n\t// More options will come here\n}\n\n// Linter is struct to lint workflow files.\ntype Linter struct {\n\tprojects       *Projects\n\tout            io.Writer\n\tlogOut         io.Writer\n\tlogLevel       LogLevel\n\toneline        bool\n\tshellcheck     string\n\tpyflakes       string\n\tignorePats     IgnorePatterns\n\tstdin          string\n\tdefaultConfig  *Config\n\terrFmt         *ErrorFormatter\n\tcwd            string\n\tonRulesCreated func([]Rule) []Rule\n}\n\n// NewLinter creates a new Linter instance.\n// The out parameter is used to output errors from Linter instance. Set io.Discard if you don't\n// want the outputs.\n// The opts parameter is LinterOptions instance which configures behavior of linting.\nfunc NewLinter(out io.Writer, opts *LinterOptions) (*Linter, error) {\n\tlevel := LogLevelNone\n\tif opts.Verbose {\n\t\tlevel = LogLevelVerbose\n\t} else if opts.Debug {\n\t\tlevel = LogLevelDebug\n\t}\n\n\tif opts.Color == ColorOptionKindNever {\n\t\tcolor.NoColor = true\n\t} else {\n\t\tif opts.Color == ColorOptionKindAlways {\n\t\t\tcolor.NoColor = false\n\t\t}\n\t\t// Allow colorful output on Windows\n\t\tif f, ok := out.(*os.File); ok {\n\t\t\tout = colorable.NewColorable(f)\n\t\t}\n\t}\n\n\tvar lout io.Writer = io.Discard\n\tif opts.LogWriter != nil {\n\t\tlout = opts.LogWriter\n\t}\n\n\tvar cfg *Config\n\tif opts.ConfigFile != \"\" {\n\t\tc, err := ReadConfigFile(opts.ConfigFile)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcfg = c\n\t}\n\n\tignore := make([]*regexp.Regexp, 0, len(opts.IgnorePatterns))\n\tfor _, s := range opts.IgnorePatterns {\n\t\tr, err := regexp.Compile(s)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"invalid regular expression for ignore pattern %q: %s\", s, err.Error())\n\t\t}\n\t\tignore = append(ignore, r)\n\t}\n\n\tvar formatter *ErrorFormatter\n\tif opts.Format != \"\" {\n\t\tf, err := NewErrorFormatter(opts.Format)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tformatter = f\n\t}\n\n\tcwd := \".\"\n\tif opts.WorkingDir != \"\" {\n\t\tcwd = opts.WorkingDir\n\t} else if d, err := os.Getwd(); err == nil {\n\t\tcwd = d\n\t}\n\n\tstdin := \"<stdin>\"\n\tif opts.StdinFileName != \"\" {\n\t\tstdin = opts.StdinFileName\n\t}\n\n\tl := &Linter{\n\t\tNewProjects(),\n\t\tout,\n\t\tlout,\n\t\tlevel,\n\t\topts.Oneline,\n\t\topts.Shellcheck,\n\t\topts.Pyflakes,\n\t\tignore,\n\t\tstdin,\n\t\tcfg,\n\t\tformatter,\n\t\tcwd,\n\t\topts.OnRulesCreated,\n\t}\n\n\tl.debug(\"Create a Linter instance with option %#v\", opts)\n\treturn l, nil\n}\n\nfunc (l *Linter) log(args ...interface{}) {\n\tif l.logLevel < LogLevelVerbose {\n\t\treturn\n\t}\n\tfmt.Fprint(l.logOut, \"verbose: \")\n\tfmt.Fprintln(l.logOut, args...)\n}\n\nfunc (l *Linter) debug(format string, args ...interface{}) {\n\tif l.logLevel < LogLevelDebug {\n\t\treturn\n\t}\n\tformat = fmt.Sprintf(\"[Linter] %s\\n\", format)\n\tfmt.Fprintf(l.logOut, format, args...)\n}\n\nfunc (l *Linter) debugWriter() io.Writer {\n\tif l.logLevel < LogLevelDebug {\n\t\treturn nil\n\t}\n\treturn l.logOut\n}\n\n// GenerateDefaultConfig generates default config file at \".github/actionlint.yaml\" in the project\n// which the given directory path belongs to. When the directory path is empty, the current directory\n// will be used instead.\nfunc (l *Linter) GenerateDefaultConfig(dir string) error {\n\tif dir == \"\" {\n\t\tdir = l.cwd\n\t}\n\n\tl.log(\"Generating default actionlint.yaml in repository:\", dir)\n\n\tproj, err := l.projects.At(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif proj == nil {\n\t\treturn errors.New(\"project is not found. check current project is initialized as Git repository and \\\".github/workflows\\\" directory exists\")\n\t}\n\n\td := filepath.Join(proj.RootDir(), \".github\")\n\tfor _, f := range []string{\"actionlint.yaml\", \"actionlint.yml\"} {\n\t\tp := filepath.Join(d, f)\n\t\tif _, err := os.Stat(p); err == nil {\n\t\t\treturn fmt.Errorf(\"config file already exists at %q\", p)\n\t\t}\n\t}\n\n\tp := filepath.Join(d, \"actionlint.yaml\")\n\tif err := writeDefaultConfigFile(p); err != nil {\n\t\treturn err\n\t}\n\n\tfmt.Fprintf(l.out, \"Config file was generated at %q\\n\", p)\n\treturn nil\n}\n\n// LintRepository lints YAML workflow files and outputs the errors to given writer. It finds the\n// nearest `.github/workflows` directory based on `dir` and applies lint rules to all YAML workflow\n// files under the directory. When the directory path is empty, the current working directory will\n// be used instead.\nfunc (l *Linter) LintRepository(dir string) ([]*Error, error) {\n\tif dir == \"\" {\n\t\tdir = l.cwd\n\t}\n\n\tl.log(\"Linting all workflow files in repository:\", dir)\n\n\tp, err := l.projects.At(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif p == nil {\n\t\treturn nil, fmt.Errorf(\"no project was found in any parent directories of %q. check workflows directory is put correctly in your Git repository\", dir)\n\t}\n\n\tl.log(\"Detected project:\", p.RootDir())\n\twd := p.WorkflowsDir()\n\treturn l.LintDir(wd, p)\n}\n\n// LintDir lints all YAML workflow files in the given directory recursively.\nfunc (l *Linter) LintDir(dir string, project *Project) ([]*Error, error) {\n\tfiles := []string{}\n\tif err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif strings.HasSuffix(path, \".yml\") || strings.HasSuffix(path, \".yaml\") {\n\t\t\tfiles = append(files, path)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read files in %q: %w\", dir, err)\n\t}\n\n\tif len(files) == 0 {\n\t\treturn nil, fmt.Errorf(\"no YAML file was found in %q\", dir)\n\t}\n\tl.log(\"Collected\", len(files), \"YAML files\")\n\n\t// To make output deterministic, sort order of file paths\n\tsort.Strings(files)\n\n\treturn l.LintFiles(files, project)\n}\n\n// LintFiles lints YAML workflow files and outputs the errors to given writer. It applies lint\n// rules to all given files. The project parameter can be nil. In the case, a project is detected\n// from the file path.\nfunc (l *Linter) LintFiles(filepaths []string, project *Project) ([]*Error, error) {\n\tn := len(filepaths)\n\tswitch n {\n\tcase 0:\n\t\treturn []*Error{}, nil\n\tcase 1:\n\t\treturn l.LintFile(filepaths[0], project)\n\t}\n\n\tl.log(\"Linting\", n, \"files\")\n\n\tcwd := l.cwd\n\tcpus := runtime.NumCPU()\n\tproc := newConcurrentProcess(cpus)\n\tsema := semaphore.NewWeighted(int64(cpus))\n\tctx := context.Background()\n\tdbg := l.debugWriter()\n\tacf := NewLocalActionsCacheFactory(dbg)\n\trwcf := NewLocalReusableWorkflowCacheFactory(cwd, dbg)\n\n\ttype workspace struct {\n\t\tpath string\n\t\terrs []*Error\n\t\tsrc  []byte\n\t}\n\n\tws := make([]workspace, 0, len(filepaths))\n\tfor _, p := range filepaths {\n\t\tws = append(ws, workspace{path: p})\n\t}\n\n\teg := errgroup.Group{}\n\tfor i := range ws {\n\t\t// Each element of ws is accessed by single goroutine so mutex is unnecessary\n\t\tw := &ws[i]\n\t\tproj := project\n\t\tif proj == nil {\n\t\t\t// This method modifies state of l.projects so it cannot be called in parallel.\n\t\t\t// Before entering goroutine, resolve project instance.\n\t\t\tp, err := l.projects.At(w.path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tproj = p\n\t\t}\n\t\tac := acf.GetCache(proj) // #173\n\t\trwc := rwcf.GetCache(proj)\n\n\t\teg.Go(func() error {\n\t\t\t// Bound concurrency on reading files to avoid \"too many files to open\" error (issue #3)\n\t\t\tsema.Acquire(ctx, 1)\n\t\t\tsrc, err := os.ReadFile(w.path)\n\t\t\tsema.Release(1)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"could not read %q: %w\", w.path, err)\n\t\t\t}\n\n\t\t\tif cwd != \"\" {\n\t\t\t\tif r, err := filepath.Rel(cwd, w.path); err == nil {\n\t\t\t\t\tw.path = r // Use relative path if possible\n\t\t\t\t}\n\t\t\t}\n\t\t\terrs, err := l.check(w.path, src, proj, proc, ac, rwc)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"fatal error while checking %s: %w\", w.path, err)\n\t\t\t}\n\t\t\tw.src = src\n\t\t\tw.errs = errs\n\t\t\treturn nil\n\t\t})\n\t}\n\n\tif err := eg.Wait(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Ensure that all processes finish. `proc.wait()` must be called after `eg.Wait()`.\n\t// Calling `WaitGroup.Add` after `WaitGroup.Wait` can cause a race condition (specifically when\n\t// increasing the group count from 0 to 1 and calling `Wait` and at the same time).\n\t// `WaitGroup.Add` is called in `proc.run()` and `WaitGroup.Wait` is called in `proc.wait()`.\n\t// After traversing all workflows, `proc.run()` is no longer called so `proc.wait()` can be\n\t// called safely.\n\tproc.wait()\n\n\ttotal := 0\n\tfor i := range ws {\n\t\ttotal += len(ws[i].errs)\n\t}\n\n\tall := make([]*Error, 0, total)\n\tif l.errFmt != nil {\n\t\ttemp := make([]*ErrorTemplateFields, 0, total)\n\t\tfor i := range ws {\n\t\t\tw := &ws[i]\n\t\t\tfor _, err := range w.errs {\n\t\t\t\ttemp = append(temp, err.GetTemplateFields(w.src))\n\t\t\t}\n\t\t\tall = append(all, w.errs...)\n\t\t}\n\t\tif err := l.errFmt.Print(l.out, temp); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tfor i := range ws {\n\t\t\tw := &ws[i]\n\t\t\tl.printErrors(w.errs, w.src)\n\t\t\tall = append(all, w.errs...)\n\t\t}\n\t}\n\n\tl.log(\"Found\", total, \"errors in\", n, \"files\")\n\n\treturn all, nil\n}\n\n// LintFile lints one YAML workflow file and outputs the errors to given writer. The project\n// parameter can be nil. In the case, the project is detected from the given path.\nfunc (l *Linter) LintFile(path string, project *Project) ([]*Error, error) {\n\tif project == nil {\n\t\tp, err := l.projects.At(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tproject = p\n\t}\n\n\tsrc, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read %q: %w\", path, err)\n\t}\n\n\tif l.cwd != \"\" {\n\t\tif r, err := filepath.Rel(l.cwd, path); err == nil {\n\t\t\tpath = r\n\t\t}\n\t}\n\n\tproc := newConcurrentProcess(runtime.NumCPU())\n\tdbg := l.debugWriter()\n\tlocalActions := NewLocalActionsCache(project, dbg)\n\tlocalReusableWorkflows := NewLocalReusableWorkflowCache(project, l.cwd, dbg)\n\terrs, err := l.check(path, src, project, proc, localActions, localReusableWorkflows)\n\tproc.wait()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif l.errFmt != nil {\n\t\tl.errFmt.PrintErrors(l.out, errs, src)\n\t} else {\n\t\tl.printErrors(errs, src)\n\t}\n\treturn errs, err\n}\n\n// LintStdin lints the content read from STDIN. The stdin parameter is a reader to read from STDIN,\n// which is usually os.Stdin. The file name is determined by LinterOptions.StdinFileName. When the\n// option is empty, \"<stdin>\" is the default value.\nfunc (l *Linter) LintStdin(stdin io.Reader) ([]*Error, error) {\n\tl.log(\"Reading the input from stdin\")\n\tb, err := io.ReadAll(stdin)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not read stdin: %w\", err)\n\t}\n\treturn l.Lint(l.stdin, b, nil)\n}\n\n// Lint lints YAML workflow file content given as byte slice. The path parameter is used as file\n// path where the content came from.\n// When nil is passed to the project parameter, it tries to find the project from the path parameter.\nfunc (l *Linter) Lint(path string, content []byte, project *Project) ([]*Error, error) {\n\tif project == nil && path != \"<stdin>\" {\n\t\tif _, err := os.Stat(path); !errors.Is(err, fs.ErrNotExist) {\n\t\t\tp, err := l.projects.At(path)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tproject = p\n\t\t}\n\t}\n\tproc := newConcurrentProcess(runtime.NumCPU())\n\tdbg := l.debugWriter()\n\tlocalActions := NewLocalActionsCache(project, dbg)\n\tlocalReusableWorkflows := NewLocalReusableWorkflowCache(project, l.cwd, dbg)\n\terrs, err := l.check(path, content, project, proc, localActions, localReusableWorkflows)\n\tproc.wait()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif l.errFmt != nil {\n\t\tl.errFmt.PrintErrors(l.out, errs, content)\n\t} else {\n\t\tl.printErrors(errs, content)\n\t}\n\treturn errs, nil\n}\n\nfunc (l *Linter) check(\n\tpath string,\n\tcontent []byte,\n\tproject *Project,\n\tproc *concurrentProcess,\n\tlocalActions *LocalActionsCache,\n\tlocalReusableWorkflows *LocalReusableWorkflowCache,\n) ([]*Error, error) {\n\t// Note: This method is called to check multiple files in parallel.\n\t// It must be thread safe assuming fields of Linter are not modified while running.\n\n\tvar start time.Time\n\tif l.logLevel >= LogLevelVerbose {\n\t\tstart = time.Now()\n\t}\n\n\tl.log(\"Linting\", path)\n\tif project != nil {\n\t\tl.log(\"Using project at\", project.RootDir())\n\t}\n\n\tvar cfg *Config\n\tif l.defaultConfig != nil {\n\t\t// `-config-file` option has higher priority than repository config file\n\t\tcfg = l.defaultConfig\n\t} else if project != nil {\n\t\tcfg = project.Config()\n\t}\n\tif cfg != nil {\n\t\tl.debug(\"Config: %#v\", cfg)\n\t} else {\n\t\tl.debug(\"No config was found\")\n\t}\n\n\tw, all := Parse(content)\n\n\tif l.logLevel >= LogLevelVerbose {\n\t\telapsed := time.Since(start)\n\t\tl.log(\"Found\", len(all), \"parse errors in\", elapsed.Milliseconds(), \"ms for\", path)\n\t}\n\n\tif w != nil {\n\t\tdbg := l.debugWriter()\n\n\t\trules := []Rule{\n\t\t\tNewRuleMatrix(),\n\t\t\tNewRuleCredentials(),\n\t\t\tNewRuleShellName(),\n\t\t\tNewRuleRunnerLabel(),\n\t\t\tNewRuleEvents(),\n\t\t\tNewRuleJobNeeds(),\n\t\t\tNewRuleAction(localActions),\n\t\t\tNewRuleEnvVar(),\n\t\t\tNewRuleID(),\n\t\t\tNewRuleGlob(),\n\t\t\tNewRulePermissions(),\n\t\t\tNewRuleWorkflowCall(path, localReusableWorkflows),\n\t\t\tNewRuleExpression(localActions, localReusableWorkflows),\n\t\t\tNewRuleDeprecatedCommands(),\n\t\t\tNewRuleIfCond(),\n\t\t}\n\t\tif l.shellcheck != \"\" {\n\t\t\tr, err := NewRuleShellcheck(l.shellcheck, proc)\n\t\t\tif err == nil {\n\t\t\t\trules = append(rules, r)\n\t\t\t} else {\n\t\t\t\tl.log(\"Rule \\\"shellcheck\\\" was disabled:\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tl.log(\"Rule \\\"shellcheck\\\" was disabled since shellcheck command name was empty\")\n\t\t}\n\t\tif l.pyflakes != \"\" {\n\t\t\tr, err := NewRulePyflakes(l.pyflakes, proc)\n\t\t\tif err == nil {\n\t\t\t\trules = append(rules, r)\n\t\t\t} else {\n\t\t\t\tl.log(\"Rule \\\"pyflakes\\\" was disabled:\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tl.log(\"Rule \\\"pyflakes\\\" was disabled since pyflakes command name was empty\")\n\t\t}\n\t\tif l.onRulesCreated != nil {\n\t\t\trules = l.onRulesCreated(rules)\n\t\t}\n\n\t\tv := NewVisitor()\n\t\tfor _, rule := range rules {\n\t\t\tv.AddPass(rule)\n\t\t}\n\t\tif dbg != nil {\n\t\t\tv.EnableDebug(dbg)\n\t\t\tfor _, r := range rules {\n\t\t\t\tr.EnableDebug(dbg)\n\t\t\t}\n\t\t}\n\t\tif cfg != nil {\n\t\t\tfor _, r := range rules {\n\t\t\t\tr.SetConfig(cfg)\n\t\t\t}\n\t\t}\n\n\t\tif err := v.Visit(w); err != nil {\n\t\t\tl.debug(\"Error occurred while visiting workflow syntax tree: %v\", err)\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor _, rule := range rules {\n\t\t\terrs := rule.Errs()\n\t\t\tl.debug(\"%s found %d errors\", rule.Name(), len(errs))\n\t\t\tall = append(all, errs...)\n\t\t}\n\n\t\tif l.errFmt != nil {\n\t\t\tfor _, rule := range rules {\n\t\t\t\tl.errFmt.RegisterRule(rule)\n\t\t\t}\n\t\t}\n\t}\n\n\tall = l.filterErrors(all, cfg.PathConfigs(path))\n\n\tfor _, err := range all {\n\t\terr.Filepath = path // Populate filename in the error\n\t}\n\n\tsort.Stable(ByErrorPosition(all))\n\n\tif l.logLevel >= LogLevelVerbose {\n\t\telapsed := time.Since(start)\n\t\tl.log(\"Found total\", len(all), \"errors in\", elapsed.Milliseconds(), \"ms for\", path)\n\t}\n\n\treturn all, nil\n}\n\nfunc (l *Linter) filterErrors(errs []*Error, cfgs []PathConfig) []*Error {\n\tif len(l.ignorePats) == 0 && len(cfgs) == 0 {\n\t\treturn errs\n\t}\n\n\tfiltered := make([]*Error, 0, len(errs))\nLoop:\n\tfor _, err := range errs {\n\t\tif l.ignorePats.Match(err) {\n\t\t\tl.debug(\"Error %q is ignored due to -ignore command line option\", err.Message)\n\t\t\tcontinue Loop\n\t\t}\n\t\tfor _, c := range cfgs {\n\t\t\tif c.Ignore.Match(err) {\n\t\t\t\tl.debug(\"Error %q is ignored due to the \\\"ignore\\\" config in the config file\", err.Message)\n\t\t\t\tcontinue Loop\n\t\t\t}\n\t\t}\n\t\tfiltered = append(filtered, err)\n\t}\n\tif len(filtered) != len(errs) {\n\t\tl.log(\"Filtered\", len(errs)-len(filtered), \"error(s) due to \\\"-ignore\\\" command line option and \\\"ignore\\\" configuration\")\n\t}\n\treturn filtered\n}\n\nfunc (l *Linter) printErrors(errs []*Error, src []byte) {\n\tif l.oneline {\n\t\tsrc = nil\n\t}\n\tfor _, err := range errs {\n\t\terr.PrettyPrint(l.out, src)\n\t}\n}\n"
        },
        {
          "name": "linter_test.go",
          "type": "blob",
          "size": 19.8896484375,
          "content": "package actionlint\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"golang.org/x/sys/execabs\"\n)\n\ntype testErrorReader struct{}\n\nfunc (r testErrorReader) Read(p []byte) (int, error) {\n\treturn 0, errors.New(\"dummy read error\")\n}\n\nfunc TestLinterLintOK(t *testing.T) {\n\tdir := filepath.Join(\"testdata\", \"ok\")\n\n\tes, err := os.ReadDir(dir)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfs := make([]string, 0, len(es))\n\tfor _, e := range es {\n\t\tif e.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tn := e.Name()\n\t\tif strings.HasSuffix(n, \".yaml\") || strings.HasSuffix(n, \".yml\") {\n\t\t\tfs = append(fs, filepath.Join(dir, n))\n\t\t}\n\t}\n\n\tproj := &Project{root: dir}\n\tshellcheck, _ := execabs.LookPath(\"shellcheck\")\n\tpyflakes, _ := execabs.LookPath(\"pyflakes\")\n\n\tfor _, f := range fs {\n\t\tt.Run(filepath.Base(f), func(t *testing.T) {\n\t\t\tif strings.Contains(f, \"shellcheck\") && shellcheck == \"\" {\n\t\t\t\tt.Skip(\"skipping\", f, \"because \\\"shellcheck\\\" command does not exist in system\")\n\t\t\t}\n\t\t\tif strings.Contains(f, \"pyflakes\") && pyflakes == \"\" {\n\t\t\t\tt.Skip(\"skipping\", f, \"because \\\"pyflakes\\\" command does not exist in system\")\n\t\t\t}\n\n\t\t\topts := LinterOptions{\n\t\t\t\tShellcheck: shellcheck,\n\t\t\t\tPyflakes:   pyflakes,\n\t\t\t}\n\n\t\t\tlinter, err := NewLinter(io.Discard, &opts)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tconfig := Config{}\n\t\t\tlinter.defaultConfig = &config\n\n\t\t\tt.Log(\"Linting workflow file\", f)\n\t\t\terrs, err := linter.LintFile(f, proj)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(errs) > 0 {\n\t\t\t\tt.Fatal(errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc testFindAllWorkflowsInDir(subdir string) (string, []string, error) {\n\tdir := filepath.Join(\"testdata\", subdir)\n\n\tentries, err := os.ReadDir(dir)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\n\tfs := make([]string, 0, len(entries))\n\tfor _, info := range entries {\n\t\tif info.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tn := info.Name()\n\t\tif strings.HasSuffix(n, \".yaml\") || strings.HasSuffix(n, \".yml\") {\n\t\t\tfs = append(fs, filepath.Join(dir, n))\n\t\t}\n\t}\n\n\treturn dir, fs, nil\n}\n\nfunc checkErrors(t *testing.T, outfile string, errs []*Error) {\n\tt.Helper()\n\tt.Log(\"Checking errors with\", outfile)\n\n\texpected := []string{}\n\t{\n\t\tf, err := os.Open(outfile)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\ts := bufio.NewScanner(f)\n\t\tfor s.Scan() {\n\t\t\texpected = append(expected, s.Text())\n\t\t}\n\t\tif err := s.Err(); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\tsort.Stable(ByErrorPosition(errs))\n\n\tif len(errs) != len(expected) {\n\t\tms := make([]string, 0, len(errs))\n\t\tfor _, err := range errs {\n\t\t\tms = append(ms, err.Error())\n\t\t}\n\t\tt.Fatalf(\"%d errors are expected but actually got %d errors:\\n%v\", len(expected), len(errs), strings.Join(ms, \"\\n\"))\n\t}\n\n\tfor i := 0; i < len(errs); i++ {\n\t\terrs[i].Filepath = filepath.ToSlash(errs[i].Filepath) // For Windows\n\t\twant, have := expected[i], errs[i].Error()\n\t\tif strings.HasPrefix(want, \"/\") && strings.HasSuffix(want, \"/\") {\n\t\t\twant := regexp.MustCompile(want[1 : len(want)-1])\n\t\t\tif !want.MatchString(have) {\n\t\t\t\tt.Errorf(\"error message mismatch at %dth error does not match to regular expression\\n  want: /%s/\\n  have: %q\", i+1, want, have)\n\t\t\t}\n\t\t} else {\n\t\t\tif want != have {\n\t\t\t\tt.Errorf(\"error message mismatch at %dth error does not match exactly\\n  want: %q\\n  have: %q\", i+1, want, have)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestLinterLintError(t *testing.T) {\n\tfor _, subdir := range []string{\"examples\", \"err\"} {\n\t\tdir, infiles, err := testFindAllWorkflowsInDir(subdir)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tproj := &Project{root: dir}\n\n\t\tshellcheck := \"\"\n\t\tif p, err := execabs.LookPath(\"shellcheck\"); err == nil {\n\t\t\tshellcheck = p\n\t\t}\n\n\t\tpyflakes := \"\"\n\t\tif p, err := execabs.LookPath(\"pyflakes\"); err == nil {\n\t\t\tpyflakes = p\n\t\t}\n\n\t\tfor _, infile := range infiles {\n\t\t\tbase := strings.TrimSuffix(infile, filepath.Ext(infile))\n\t\t\ttestName := filepath.Base(base)\n\t\t\tt.Run(subdir+\"/\"+testName, func(t *testing.T) {\n\t\t\t\tt.Log(\"Linting workflow file\", infile)\n\t\t\t\tb, err := os.ReadFile(infile)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\n\t\t\t\to := LinterOptions{}\n\n\t\t\t\tif strings.Contains(testName, \"shellcheck\") {\n\t\t\t\t\tif shellcheck == \"\" {\n\t\t\t\t\t\tt.Skip(\"skipped because \\\"shellcheck\\\" command does not exist in system\")\n\t\t\t\t\t}\n\t\t\t\t\to.Shellcheck = shellcheck\n\t\t\t\t}\n\n\t\t\t\tif strings.Contains(testName, \"pyflakes\") {\n\t\t\t\t\tif pyflakes == \"\" {\n\t\t\t\t\t\tt.Skip(\"skipped because \\\"pyflakes\\\" command does not exist in system\")\n\t\t\t\t\t}\n\t\t\t\t\to.Pyflakes = pyflakes\n\t\t\t\t}\n\n\t\t\t\tl, err := NewLinter(io.Discard, &o)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tl.defaultConfig = &Config{}\n\n\t\t\t\terrs, err := l.Lint(\"test.yaml\", b, proj)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tcheckErrors(t, base+\".out\", errs)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestLinterLintAllErrorWorkflowsAtOnce(t *testing.T) {\n\tshellcheck, err := execabs.LookPath(\"shellcheck\")\n\tif err != nil {\n\t\tt.Skipf(\"shellcheck is not found: %s\", err)\n\t}\n\n\tpyflakes, err := execabs.LookPath(\"pyflakes\")\n\tif err != nil {\n\t\tt.Skipf(\"pyflakes is not found: %s\", err)\n\t}\n\n\tdir, files, err := testFindAllWorkflowsInDir(\"examples\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Root directory must be testdata/examples/ since some workflow assumes it\n\tproj := &Project{root: dir}\n\n\t_, fs, err := testFindAllWorkflowsInDir(\"err\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfiles = append(files, fs...)\n\n\to := LinterOptions{\n\t\tShellcheck: shellcheck,\n\t\tPyflakes:   pyflakes,\n\t}\n\n\tl, err := NewLinter(io.Discard, &o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tl.defaultConfig = &Config{}\n\n\terrs, err := l.LintFiles(files, proj)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// Check each example workflow file caused at least one error\nCheckFiles:\n\tfor _, f := range files {\n\t\tfor _, e := range errs {\n\t\t\tif e.Filepath == f {\n\t\t\t\tcontinue CheckFiles\n\t\t\t}\n\t\t}\n\t\tif !strings.Contains(f, \"pyflakes\") && !strings.Contains(f, \"shellcheck\") {\n\t\t\tt.Errorf(\"Workflow %q caused no error: %v\", f, errs)\n\t\t}\n\t}\n}\n\nfunc TestLintFindProjectFromPath(t *testing.T) {\n\td := filepath.Join(\"testdata\", \"find_project\")\n\tf := filepath.Join(d, \".github\", \"workflows\", \"test.yaml\")\n\tb, err := os.ReadFile(f)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttestEnsureDotGitDir(d)\n\n\tlint := func(path string) []*Error {\n\t\tl, err := NewLinter(io.Discard, &LinterOptions{})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tl.defaultConfig = &Config{}\n\t\terrs, err := l.Lint(path, b, nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn errs\n\t}\n\n\terrs := lint(f)\n\tif len(errs) == 0 {\n\t\tt.Fatal(\"no error was detected though the project was found from path parameter\")\n\t}\n\n\terrs = lint(\"<stdin>\")\n\tif len(errs) > 0 {\n\t\tt.Fatal(\"some error was detected though path parameter is stdin\", errs)\n\t}\n\n\terrs = lint(filepath.Join(\"this-dir-doesnt-exist\", \"not-found.yaml\"))\n\tif len(errs) > 0 {\n\t\tt.Fatal(\"some error was detected though path parameter does not exist\", errs)\n\t}\n}\n\nfunc TestLinterLintProject(t *testing.T) {\n\troot := filepath.Join(\"testdata\", \"projects\")\n\tentries, err := os.ReadDir(root)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor _, info := range entries {\n\t\tif !info.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tname := info.Name()\n\t\tt.Run(\"project/\"+name, func(t *testing.T) {\n\t\t\trepo := filepath.Join(root, name)\n\t\t\tt.Log(\"Linting project at\", repo)\n\n\t\t\topts := LinterOptions{\n\t\t\t\tWorkingDir: repo,\n\t\t\t}\n\t\t\tcfg := filepath.Join(repo, \"actionlint.yaml\")\n\t\t\tif _, err := os.Stat(cfg); err == nil {\n\t\t\t\topts.ConfigFile = cfg\n\t\t\t}\n\t\t\tlinter, err := NewLinter(io.Discard, &opts)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tproj := &Project{root: repo}\n\t\t\terrs, err := linter.LintDir(filepath.Join(repo, \"workflows\"), proj)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tcheckErrors(t, repo+\".out\", errs)\n\t\t})\n\t}\n}\n\nfunc TestLinterFormatErrorMessageOK(t *testing.T) {\n\ttests := []struct {\n\t\tfile   string\n\t\tformat string\n\t}{\n\t\t{\n\t\t\tfile:   \"test.json\",\n\t\t\tformat: \"{{json .}}\",\n\t\t},\n\t\t{\n\t\t\tfile:   \"test.jsonl\",\n\t\t\tformat: \"{{range $err := .}}{{json $err}}{{end}}\",\n\t\t},\n\t\t{\n\t\t\tfile:   \"test.md\",\n\t\t\tformat: \"{{range $ := .}}### Error at line {{$.Line}}, col {{$.Column}} of `{{$.Filepath}}`\\\\n\\\\n{{$.Message}}\\\\n\\\\n```\\\\n{{$.Snippet}}\\\\n```\\\\n\\\\n{{end}}\",\n\t\t},\n\t}\n\n\tdir := filepath.Join(\"testdata\", \"format\")\n\tproj := &Project{root: dir}\n\tinfile := filepath.Join(dir, \"test.yaml\")\n\tfor _, tc := range tests {\n\t\tt.Run(tc.file, func(t *testing.T) {\n\t\t\topts := LinterOptions{Format: tc.format}\n\n\t\t\tvar b strings.Builder\n\t\t\tl, err := NewLinter(&b, &opts)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tl.defaultConfig = &Config{}\n\t\t\terrs, err := l.LintFile(infile, proj)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif len(errs) == 0 {\n\t\t\t\tt.Fatal(\"no error\")\n\t\t\t}\n\n\t\t\tbuf, err := os.ReadFile(filepath.Join(dir, tc.file))\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\twant := string(buf)\n\n\t\t\thave := b.String()\n\t\t\t// Fix path separators on Windows\n\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\tslash := filepath.ToSlash(infile)\n\t\t\t\thave = strings.ReplaceAll(have, infile, slash)\n\t\t\t\tescaped := strings.ReplaceAll(slash, \"/\", `\\\\`)\n\t\t\t\thave = strings.ReplaceAll(have, escaped, slash)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(want, have); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestLinterFormatErrorMessageInSARIF(t *testing.T) {\n\tdir := filepath.Join(\"testdata\", \"format\")\n\tproj := &Project{root: dir}\n\tfile := filepath.Join(dir, \"test.yaml\")\n\n\tbytes, err := os.ReadFile(filepath.Join(dir, \"sarif_template.txt\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tformat := string(bytes)\n\n\topts := LinterOptions{Format: format}\n\tvar b strings.Builder\n\tl, err := NewLinter(&b, &opts)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tl.defaultConfig = &Config{}\n\terrs, err := l.LintFile(file, proj)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(errs) == 0 {\n\t\tt.Fatal(\"no error\")\n\t}\n\n\tout := b.String()\n\t// Fix path separators on Windows\n\tif runtime.GOOS == \"windows\" {\n\t\tslash := filepath.ToSlash(file)\n\t\tescaped := strings.ReplaceAll(file, `\\`, `\\\\`)\n\t\tout = strings.ReplaceAll(out, escaped, slash)\n\t}\n\n\tvar have interface{}\n\tif err := json.Unmarshal([]byte(out), &have); err != nil {\n\t\tt.Fatalf(\"output is not JSON: %v: %q\", err, out)\n\t}\n\n\tbytes, err = os.ReadFile(filepath.Join(dir, \"test.sarif\"))\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar want interface{}\n\tif err := json.Unmarshal(bytes, &want); err != nil {\n\t\tpanic(err)\n\t}\n\n\tif diff := cmp.Diff(want, have); diff != \"\" {\n\t\tt.Fatal(diff)\n\t}\n}\n\nfunc TestLinterLintStdinOK(t *testing.T) {\n\tfor _, f := range []string{\"\", \"foo.yaml\"} {\n\t\tl, err := NewLinter(io.Discard, &LinterOptions{StdinFileName: f})\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"creating Linter object with stdin file name %q caused error: %v\", f, err)\n\t\t}\n\n\t\tin := []byte(`on: push\njobs:\n  job:\n    runs-on: foo\n\tsteps:\n\t  - run: echo`)\n\t\terrs, err := l.LintStdin(bytes.NewReader(in))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"linting input with stdin file name %q caused error: %v\", f, err)\n\t\t}\n\t\tif len(errs) != 1 {\n\t\t\tt.Fatalf(\"unexpected number of errors with stdin file name %q: %v\", f, errs)\n\t\t}\n\n\t\twant := f\n\t\tif want == \"\" {\n\t\t\twant = \"<stdin>\"\n\t\t}\n\t\tif errs[0].Filepath != want {\n\t\t\tt.Fatalf(\"file path in the error with stdin file name %q should be %q but got %q\", f, want, errs[0].Filepath)\n\t\t}\n\t}\n}\n\nfunc TestLinterLintStdinReadError(t *testing.T) {\n\tl, err := NewLinter(io.Discard, &LinterOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t_, err = l.LintStdin(testErrorReader{})\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\")\n\t}\n\twant := \"could not read stdin: dummy read error\"\n\thave := err.Error()\n\tif want != have {\n\t\tt.Fatalf(\"wanted error message %q but have %q\", want, have)\n\t}\n}\n\nfunc TestLinterPathsNotFound(t *testing.T) {\n\tl, err := NewLinter(io.Discard, &LinterOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tcwd, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tpaths := []string{\n\t\tfilepath.Join(\"testdata\", \"this-file-doesnt-exist.yaml\"),                   // Relative file path (parent exists)\n\t\tfilepath.Join(\"this-dir-doesnt-exist\", \"this-file-doesnt-exist.yaml\"),      // Relative file path (parent doesn't exist)\n\t\tfilepath.Join(cwd, \"this-file-doesnt-exist.yaml\"),                          // Absolute file path (parent exists)\n\t\tfilepath.Join(cwd, \"this-dir-doesnt-exist\", \"this-file-doesnt-exist.yaml\"), // Absolute file path (parent doesn't exist)\n\t}\n\n\t_, err = l.LintFiles(paths, nil)\n\tif err == nil {\n\t\tt.Fatal(\"no error happened\")\n\t}\n\tmsg := err.Error()\n\tif !strings.Contains(msg, \"could not read\") {\n\t\tt.Fatal(\"unexpected error:\", msg)\n\t}\n}\n\ntype customRuleForTest struct {\n\tRuleBase\n\tcount int\n}\n\nfunc (r *customRuleForTest) VisitStep(n *Step) error {\n\tr.count++\n\tif r.count > 1 {\n\t\tr.Errorf(n.Pos, \"only single step is allowed but got %d steps\", r.count)\n\t}\n\treturn nil\n}\n\nfunc TestLinterAddCustomRuleOnRulesCreatedHook(t *testing.T) {\n\to := &LinterOptions{\n\t\tOnRulesCreated: func(rules []Rule) []Rule {\n\t\t\tr := &customRuleForTest{\n\t\t\t\tRuleBase: NewRuleBase(\"this-is-test\", \"\"),\n\t\t\t}\n\t\t\treturn append(rules, r)\n\t\t},\n\t}\n\n\tl, err := NewLinter(io.Discard, o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tl.defaultConfig = &Config{}\n\n\t{\n\t\tw := `on: push\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo\n`\n\t\terrs, err := l.Lint(\"test.yaml\", []byte(w), nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(errs) != 0 {\n\t\t\tt.Fatal(\"wanted no error but have\", errs)\n\t\t}\n\t}\n\n\t{\n\t\tw := `on: push\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo\n      - run: echo\n`\n\t\terrs, err := l.Lint(\"test.yaml\", []byte(w), nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif len(errs) != 1 {\n\t\t\tt.Fatal(\"wanted 1 error but have\", errs)\n\t\t}\n\n\t\tvar b strings.Builder\n\t\terrs[0].PrettyPrint(&b, nil)\n\t\thave := b.String()\n\t\twant := \"test.yaml:7:9: only single step is allowed but got 2 steps [this-is-test]\\n\"\n\t\tif have != want {\n\t\t\tt.Fatalf(\"wanted error message %q but have %q\", want, have)\n\t\t}\n\t}\n}\n\nfunc TestLinterRemoveRuleOnRulesCreatedHook(t *testing.T) {\n\to := &LinterOptions{\n\t\tOnRulesCreated: func(rules []Rule) []Rule {\n\t\t\tfor i, r := range rules {\n\t\t\t\tif r.Name() == \"runner-label\" {\n\t\t\t\t\trules = append(rules[:i], rules[i+1:]...)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn rules\n\t\t},\n\t}\n\n\tl, err := NewLinter(io.Discard, o)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tl.defaultConfig = &Config{}\n\n\tf := filepath.Join(\"testdata\", \"err\", \"invalid_runner_labels.yaml\")\n\terrs, err := l.LintFile(f, nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(errs) != 0 {\n\t\tt.Fatal(\"no error was expected because runner-label rule was removed but got:\", errs)\n\t}\n}\n\nfunc TestLinterGenerateDefaultConfigAlreadyExists(t *testing.T) {\n\tl, err := NewLinter(io.Discard, &LinterOptions{})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor _, n := range []string{\"ok\", \"yml\"} {\n\t\td := filepath.Join(\"testdata\", \"config\", \"projects\", n)\n\t\ttestEnsureDotGitDir(d)\n\n\t\terr := l.GenerateDefaultConfig(d)\n\t\tif err == nil {\n\t\t\tt.Fatal(\"error did not occur for project\", d)\n\t\t}\n\t\twant := \"config file already exists at\"\n\t\tmsg := err.Error()\n\t\tif !strings.Contains(msg, want) {\n\t\t\tt.Fatalf(\"error message %q does not contain expected text %q\", msg, want)\n\t\t}\n\t}\n}\n\nfunc BenchmarkLintWorkflowFiles(b *testing.B) {\n\tlarge := filepath.Join(\"testdata\", \"bench\", \"many_scripts.yaml\")\n\tsmall := filepath.Join(\"testdata\", \"bench\", \"small.yaml\")\n\tmin := filepath.Join(\"testdata\", \"bench\", \"minimal.yaml\")\n\tproj := &Project{root: \".\"}\n\tshellcheck, err := execabs.LookPath(\"shellcheck\")\n\tif err != nil {\n\t\tb.Skipf(\"shellcheck is not found: %s\", err)\n\t}\n\tformat := \"{{range $ := .}}### Error at line {{$.Line}}, col {{$.Column}} of `{{$.Filepath}}`\\\\n\\\\n{{$.Message}}\\\\n\\\\n```\\\\n{{$.Snippet}}\\\\n```\\\\n\\\\n{{end}}\"\n\n\t// Workflow files for this repository\n\tours := []string{}\n\t{\n\t\td := filepath.Join(\".github\", \"workflows\")\n\t\tes, err := os.ReadDir(d)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfor _, e := range es {\n\t\t\tours = append(ours, filepath.Join(d, e.Name()))\n\t\t}\n\t}\n\n\tbms := []struct {\n\t\twhat       string\n\t\tfiles      []string\n\t\tshellcheck string\n\t\tformat     string\n\t}{\n\t\t{\n\t\t\twhat:  \"minimal\",\n\t\t\tfiles: []string{min},\n\t\t},\n\t\t{\n\t\t\twhat:  \"minimal\",\n\t\t\tfiles: []string{min, min, min, min, min},\n\t\t},\n\t\t{\n\t\t\twhat:  \"minimal\",\n\t\t\tfiles: []string{min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min},\n\t\t},\n\t\t{\n\t\t\twhat: \"minimal\",\n\t\t\tfiles: []string{\n\t\t\t\tmin, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min,\n\t\t\t\tmin, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min, min,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:  \"small\",\n\t\t\tfiles: []string{small},\n\t\t},\n\t\t{\n\t\t\twhat:  \"small\",\n\t\t\tfiles: []string{small, small, small},\n\t\t},\n\t\t{\n\t\t\twhat:  \"small\",\n\t\t\tfiles: []string{small, small, small, small, small, small, small, small, small, small},\n\t\t},\n\t\t{\n\t\t\twhat:       \"small\",\n\t\t\tfiles:      []string{small},\n\t\t\tshellcheck: shellcheck,\n\t\t},\n\t\t{\n\t\t\twhat:       \"small\",\n\t\t\tfiles:      []string{small, small, small},\n\t\t\tshellcheck: shellcheck,\n\t\t},\n\t\t{\n\t\t\twhat:       \"small\",\n\t\t\tfiles:      []string{small, small, small, small, small, small, small, small, small, small},\n\t\t\tshellcheck: shellcheck,\n\t\t},\n\t\t{\n\t\t\twhat:       \"large\",\n\t\t\tfiles:      []string{large},\n\t\t\tshellcheck: shellcheck,\n\t\t},\n\t\t{\n\t\t\twhat:       \"large\",\n\t\t\tfiles:      []string{large, large, large},\n\t\t\tshellcheck: shellcheck,\n\t\t},\n\t\t{\n\t\t\twhat:       \"large\",\n\t\t\tfiles:      []string{large, large, large, large, large, large, large, large, large, large},\n\t\t\tshellcheck: shellcheck,\n\t\t},\n\t\t{\n\t\t\twhat:   \"small\",\n\t\t\tfiles:  []string{small, small, small, small, small, small, small, small, small, small},\n\t\t\tformat: format,\n\t\t},\n\t\t{\n\t\t\twhat:  \"our workflows\",\n\t\t\tfiles: ours,\n\t\t},\n\t}\n\n\tfor _, bm := range bms {\n\t\tsc := \"\"\n\t\tif bm.shellcheck != \"\" {\n\t\t\tsc = \"-shellcheck\"\n\t\t}\n\t\tfm := \"\"\n\t\tif bm.format != \"\" {\n\t\t\tfm = \"-format\"\n\t\t}\n\t\tb.Run(fmt.Sprintf(\"%s%s%s-%d\", bm.what, sc, fm, len(bm.files)), func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\topts := LinterOptions{\n\t\t\t\t\tShellcheck: bm.shellcheck,\n\t\t\t\t\tFormat:     bm.format,\n\t\t\t\t}\n\n\t\t\t\tl, err := NewLinter(io.Discard, &opts)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t\tl.defaultConfig = &Config{}\n\n\t\t\t\terrs, err := l.LintFiles(bm.files, proj)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\n\t\t\t\tif len(errs) > 0 {\n\t\t\t\t\tb.Fatal(\"some error occurred:\", errs)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkLintWorkflowContent(b *testing.B) {\n\tdir, err := os.Getwd()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tproj := &Project{root: dir}\n\n\t// Measure performance of traversing with checks except for external process rules (shellcheck, pyflakes)\n\t// Reading file content is not included in benchmark measurement.\n\n\tfor _, name := range []string{\"minimal\", \"small\", \"large\"} {\n\t\tvar f string\n\t\tswitch name {\n\t\tcase \"minimal\":\n\t\t\tf = filepath.Join(dir, \"testdata\", \"bench\", \"minimal.yaml\")\n\t\tcase \"small\":\n\t\t\tf = filepath.Join(dir, \"testdata\", \"bench\", \"small.yaml\")\n\t\tcase \"large\":\n\t\t\tf = filepath.Join(dir, \"testdata\", \"bench\", \"many_scripts.yaml\")\n\t\t}\n\t\tcontent, err := os.ReadFile(f)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tb.Run(name, func(b *testing.B) {\n\t\t\tfor i := 0; i < b.N; i++ {\n\t\t\t\topts := LinterOptions{}\n\t\t\t\tl, err := NewLinter(io.Discard, &opts)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t\tl.defaultConfig = &Config{}\n\t\t\t\terrs, err := l.Lint(f, content, proj)\n\t\t\t\tif err != nil {\n\t\t\t\t\tb.Fatal(err)\n\t\t\t\t}\n\t\t\t\tif len(errs) > 0 {\n\t\t\t\t\tb.Fatal(\"some error occurred:\", errs)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc BenchmarkExamplesLintFiles(b *testing.B) {\n\tdir, files, err := testFindAllWorkflowsInDir(\"examples\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tproj := &Project{root: dir}\n\tshellcheck, err := execabs.LookPath(\"shellcheck\")\n\tif err != nil {\n\t\tb.Skipf(\"shellcheck is not found: %s\", err)\n\t}\n\tpyflakes, err := execabs.LookPath(\"pyflakes\")\n\tif err != nil {\n\t\tb.Skipf(\"pyflakes is not found: %s\", err)\n\t}\n\n\tfor i := 0; i < b.N; i++ {\n\t\topts := LinterOptions{\n\t\t\tShellcheck: shellcheck,\n\t\t\tPyflakes:   pyflakes,\n\t\t}\n\n\t\tl, err := NewLinter(io.Discard, &opts)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tl.defaultConfig = &Config{}\n\n\t\terrs, err := l.LintFiles(files, proj)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\tif len(errs) == 0 {\n\t\t\tb.Fatal(\"no error found\")\n\t\t}\n\t}\n}\n\nfunc BenchmarkLintRepository(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\topts := LinterOptions{}\n\t\tl, err := NewLinter(io.Discard, &opts)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\terrs, err := l.LintRepository(\".\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif len(errs) > 0 {\n\t\t\tb.Fatal(errs)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "man",
          "type": "tree",
          "content": null
        },
        {
          "name": "parse.go",
          "type": "blob",
          "size": 40.8125,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\n// https://pkg.go.dev/gopkg.in/yaml.v3#Kind\nfunc nodeKindName(k yaml.Kind) string {\n\tswitch k {\n\tcase yaml.DocumentNode:\n\t\treturn \"document\"\n\tcase yaml.SequenceNode:\n\t\treturn \"sequence\"\n\tcase yaml.MappingNode:\n\t\treturn \"mapping\"\n\tcase yaml.ScalarNode:\n\t\treturn \"scalar\"\n\tcase yaml.AliasNode:\n\t\treturn \"alias\"\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unreachable: unknown YAML kind: %v\", k))\n\t}\n}\n\nfunc posAt(n *yaml.Node) *Pos {\n\treturn &Pos{n.Line, n.Column}\n}\n\nfunc isNull(n *yaml.Node) bool {\n\treturn n.Kind == yaml.ScalarNode && n.Tag == \"!!null\"\n}\n\nfunc newString(n *yaml.Node) *String {\n\tquoted := n.Style&(yaml.DoubleQuotedStyle|yaml.SingleQuotedStyle) != 0\n\treturn &String{n.Value, quoted, posAt(n)}\n}\n\ntype workflowKeyVal struct {\n\t// id is used for comparing keys. When the key is case insensitive, this field is in lower case.\n\tid  string\n\tkey *String\n\tval *yaml.Node\n}\n\ntype parser struct {\n\terrors []*Error\n}\n\nfunc (p *parser) error(n *yaml.Node, m string) {\n\tp.errors = append(p.errors, &Error{m, \"\", n.Line, n.Column, \"syntax-check\"})\n}\n\nfunc (p *parser) errorAt(pos *Pos, m string) {\n\tp.errors = append(p.errors, &Error{m, \"\", pos.Line, pos.Col, \"syntax-check\"})\n}\n\nfunc (p *parser) errorfAt(pos *Pos, format string, args ...interface{}) {\n\tm := fmt.Sprintf(format, args...)\n\tp.errorAt(pos, m)\n}\n\nfunc (p *parser) errorf(n *yaml.Node, format string, args ...interface{}) {\n\tm := fmt.Sprintf(format, args...)\n\tp.error(n, m)\n}\n\nfunc (p *parser) unexpectedKey(s *String, sec string, expected []string) {\n\tl := len(expected)\n\tvar m string\n\tif l == 1 {\n\t\tm = fmt.Sprintf(\"expected %q key for %q section but got %q\", expected[0], sec, s.Value)\n\t} else if l > 1 {\n\t\tm = fmt.Sprintf(\"unexpected key %q for %q section. expected one of %v\", s.Value, sec, sortedQuotes(expected))\n\t} else {\n\t\tm = fmt.Sprintf(\"unexpected key %q for %q section\", s.Value, sec)\n\t}\n\tp.errorAt(s.Pos, m)\n}\n\nfunc (p *parser) checkNotEmpty(sec string, len int, n *yaml.Node) bool {\n\tif len == 0 {\n\t\tp.errorf(n, \"%q section should not be empty\", sec)\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (p *parser) checkSequence(sec string, n *yaml.Node, allowEmpty bool) bool {\n\tif n.Kind != yaml.SequenceNode {\n\t\tp.errorf(n, \"%q section must be sequence node but got %s node with %q tag\", sec, nodeKindName(n.Kind), n.Tag)\n\t\treturn false\n\t}\n\treturn allowEmpty || p.checkNotEmpty(sec, len(n.Content), n)\n}\n\nfunc (p *parser) checkString(n *yaml.Node, allowEmpty bool) bool {\n\t// Do not check n.Tag is !!str because we don't need to check the node is string strictly.\n\t// In almost all cases, other nodes (like 42) are handled as string with its string representation.\n\tif n.Kind != yaml.ScalarNode {\n\t\tp.errorf(n, \"expected scalar node for string value but found %s node with %q tag\", nodeKindName(n.Kind), n.Tag)\n\t\treturn false\n\t}\n\tif !allowEmpty && n.Value == \"\" {\n\t\tp.error(n, \"string should not be empty\")\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (p *parser) missingExpression(n *yaml.Node, expecting string) {\n\tp.errorf(n, \"expecting a single ${{...}} expression or %s, but found plain text node\", expecting)\n}\n\nfunc (p *parser) parseExpression(n *yaml.Node, expecting string) *String {\n\tif !isExprAssigned(n.Value) {\n\t\tp.missingExpression(n, expecting)\n\t\treturn nil\n\t}\n\treturn newString(n)\n}\n\nfunc (p *parser) mayParseExpression(n *yaml.Node) *String {\n\tif n.Tag != \"!!str\" {\n\t\treturn nil\n\t}\n\tif !isExprAssigned(n.Value) {\n\t\treturn nil\n\t}\n\treturn newString(n)\n}\n\nfunc (p *parser) parseString(n *yaml.Node, allowEmpty bool) *String {\n\tif !p.checkString(n, allowEmpty) {\n\t\treturn &String{\"\", false, posAt(n)}\n\t}\n\treturn newString(n)\n}\n\nfunc (p *parser) parseStringSequence(sec string, n *yaml.Node, allowEmpty bool, allowElemEmpty bool) []*String {\n\tif ok := p.checkSequence(sec, n, allowEmpty); !ok {\n\t\treturn nil\n\t}\n\n\tss := make([]*String, 0, len(n.Content))\n\tfor _, c := range n.Content {\n\t\ts := p.parseString(c, allowElemEmpty)\n\t\tif s != nil {\n\t\t\tss = append(ss, s)\n\t\t}\n\t}\n\treturn ss\n}\n\nfunc (p *parser) parseStringOrStringSequence(sec string, n *yaml.Node, allowEmpty bool, allowElemEmpty bool) []*String {\n\tswitch n.Kind {\n\tcase yaml.ScalarNode:\n\t\tif allowEmpty && n.Tag == \"!!null\" {\n\t\t\treturn []*String{} // In the case of 'foo:'\n\t\t}\n\t\treturn []*String{p.parseString(n, allowElemEmpty)}\n\tdefault:\n\t\treturn p.parseStringSequence(sec, n, allowEmpty, allowElemEmpty)\n\t}\n}\n\nfunc (p *parser) parseBool(n *yaml.Node) *Bool {\n\tif n.Kind != yaml.ScalarNode || (n.Tag != \"!!bool\" && n.Tag != \"!!str\") {\n\t\tp.errorf(n, \"expected bool value but found %s node with %q tag\", nodeKindName(n.Kind), n.Tag)\n\t\treturn nil\n\t}\n\n\tif n.Tag == \"!!str\" {\n\t\te := p.parseExpression(n, \"boolean literal \\\"true\\\" or \\\"false\\\"\")\n\t\treturn &Bool{\n\t\t\tExpression: e,\n\t\t\tPos:        posAt(n),\n\t\t}\n\t}\n\n\treturn &Bool{\n\t\tValue: n.Value == \"true\",\n\t\tPos:   posAt(n),\n\t}\n}\n\nfunc (p *parser) parseInt(n *yaml.Node) *Int {\n\tif n.Kind != yaml.ScalarNode || (n.Tag != \"!!int\" && n.Tag != \"!!str\") {\n\t\tp.errorf(n, \"expected scalar node for integer value but found %s node with %q tag\", nodeKindName(n.Kind), n.Tag)\n\t\treturn nil\n\t}\n\n\tif n.Tag == \"!!str\" {\n\t\te := p.parseExpression(n, \"integer literal\")\n\t\tif e == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &Int{\n\t\t\tExpression: e,\n\t\t\tPos:        posAt(n),\n\t\t}\n\t}\n\n\ti, err := strconv.Atoi(n.Value)\n\tif err != nil {\n\t\tp.errorf(n, \"invalid integer value: %q: %s\", n.Value, err.Error())\n\t\treturn nil\n\t}\n\n\treturn &Int{\n\t\tValue: i,\n\t\tPos:   posAt(n),\n\t}\n}\n\nfunc (p *parser) parseFloat(n *yaml.Node) *Float {\n\tif n.Kind != yaml.ScalarNode || (n.Tag != \"!!float\" && n.Tag != \"!!int\" && n.Tag != \"!!str\") {\n\t\tp.errorf(n, \"expected scalar node for float value but found %s node with %q tag\", nodeKindName(n.Kind), n.Tag)\n\t\treturn nil\n\t}\n\n\tif n.Tag == \"!!str\" {\n\t\te := p.parseExpression(n, \"float number literal\")\n\t\tif e == nil {\n\t\t\treturn nil\n\t\t}\n\t\treturn &Float{\n\t\t\tExpression: e,\n\t\t\tPos:        posAt(n),\n\t\t}\n\t}\n\n\tf, err := strconv.ParseFloat(n.Value, 64)\n\tif err != nil || math.IsNaN(f) {\n\t\tp.errorf(n, \"invalid float value: %q: %s\", n.Value, err.Error())\n\t\treturn nil\n\t}\n\n\treturn &Float{\n\t\tValue: f,\n\t\tPos:   posAt(n),\n\t}\n}\n\nfunc (p *parser) parseMapping(what string, n *yaml.Node, allowEmpty, caseSensitive bool) []workflowKeyVal {\n\tisNull := isNull(n)\n\n\tif !isNull && n.Kind != yaml.MappingNode {\n\t\tp.errorf(n, \"%s is %s node but mapping node is expected\", what, nodeKindName(n.Kind))\n\t\treturn nil\n\t}\n\n\tif !allowEmpty && isNull {\n\t\tp.errorf(n, \"%s should not be empty. please remove this section if it's unnecessary\", what)\n\t\treturn nil\n\t}\n\n\tl := len(n.Content) / 2\n\tkeys := make(map[string]*Pos, l)\n\tm := make([]workflowKeyVal, 0, l)\n\tfor i := 0; i < len(n.Content); i += 2 {\n\t\tk := p.parseString(n.Content[i], false)\n\t\tif k == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tid := k.Value\n\t\tif !caseSensitive {\n\t\t\t// Keys of mappings are sometimes case insensitive. For example, following matrix is invalid.\n\t\t\t//   matrix:\n\t\t\t//     foo: [1, 2, 3]\n\t\t\t//     FOO: [1, 2, 3]\n\t\t\t// To detect case insensitive duplicate keys, we use lowercase keys\n\t\t\tid = strings.ToLower(id)\n\t\t}\n\n\t\tif pos, ok := keys[id]; ok {\n\t\t\tvar note string\n\t\t\tif !caseSensitive {\n\t\t\t\tnote = \". note that this key is case insensitive\"\n\t\t\t}\n\t\t\tp.errorfAt(k.Pos, \"key %q is duplicated in %s. previously defined at %s%s\", k.Value, what, pos.String(), note)\n\t\t\tcontinue\n\t\t}\n\t\tm = append(m, workflowKeyVal{id, k, n.Content[i+1]})\n\t\tkeys[id] = k.Pos\n\t}\n\n\tif !allowEmpty && len(m) == 0 {\n\t\tp.errorf(n, \"%s should not be empty. please remove this section if it's unnecessary\", what)\n\t}\n\n\treturn m\n}\n\nfunc (p *parser) parseSectionMapping(sec string, n *yaml.Node, allowEmpty, caseSensitive bool) []workflowKeyVal {\n\treturn p.parseMapping(fmt.Sprintf(\"%q section\", sec), n, allowEmpty, caseSensitive)\n}\n\nfunc (p *parser) parseScheduleEvent(pos *Pos, n *yaml.Node) *ScheduledEvent {\n\tif ok := p.checkSequence(\"schedule\", n, false); !ok {\n\t\treturn nil\n\t}\n\n\tcron := make([]*String, 0, len(n.Content))\n\tfor _, c := range n.Content {\n\t\tm := p.parseMapping(\"element of \\\"schedule\\\" section\", c, false, true)\n\t\tif len(m) != 1 || m[0].id != \"cron\" {\n\t\t\tp.error(c, \"element of \\\"schedule\\\" section must be mapping and must contain one key \\\"cron\\\"\")\n\t\t\tcontinue\n\t\t}\n\t\ts := p.parseString(m[0].val, false)\n\t\tif s != nil {\n\t\t\tcron = append(cron, s)\n\t\t}\n\t}\n\n\treturn &ScheduledEvent{cron, pos}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow_dispatch\nfunc (p *parser) parseWorkflowDispatchEvent(pos *Pos, n *yaml.Node) *WorkflowDispatchEvent {\n\tret := &WorkflowDispatchEvent{Pos: pos}\n\n\tfor _, kv := range p.parseSectionMapping(\"workflow_dispatch\", n, true, true) {\n\t\tif kv.id != \"inputs\" {\n\t\t\tp.unexpectedKey(kv.key, \"workflow_dispatch\", []string{\"inputs\"})\n\t\t\tcontinue\n\t\t}\n\n\t\tinputs := p.parseSectionMapping(\"inputs\", kv.val, true, false)\n\t\tret.Inputs = make(map[string]*DispatchInput, len(inputs))\n\t\tfor _, input := range inputs {\n\t\t\tname, spec := input.key, input.val\n\n\t\t\tvar desc *String\n\t\t\tvar req *Bool\n\t\t\tvar def *String\n\t\t\tvar ty WorkflowDispatchEventInputType = WorkflowDispatchEventInputTypeNone\n\t\t\tvar opts []*String\n\n\t\t\tfor _, attr := range p.parseMapping(\"input settings of workflow_dispatch event\", spec, true, true) {\n\t\t\t\tswitch attr.id {\n\t\t\t\tcase \"description\":\n\t\t\t\t\tdesc = p.parseString(attr.val, true)\n\t\t\t\tcase \"required\":\n\t\t\t\t\treq = p.parseBool(attr.val)\n\t\t\t\tcase \"default\":\n\t\t\t\t\tdef = p.parseString(attr.val, true)\n\t\t\t\tcase \"type\":\n\t\t\t\t\tif !p.checkString(attr.val, false) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tswitch attr.val.Value {\n\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\tty = WorkflowDispatchEventInputTypeString\n\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\tty = WorkflowDispatchEventInputTypeNumber\n\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\tty = WorkflowDispatchEventInputTypeBoolean\n\t\t\t\t\tcase \"choice\":\n\t\t\t\t\t\tty = WorkflowDispatchEventInputTypeChoice\n\t\t\t\t\tcase \"environment\":\n\t\t\t\t\t\tty = WorkflowDispatchEventInputTypeEnvironment\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.errorf(attr.val, `input type of workflow_dispatch event must be one of \"string\", \"number\", \"boolean\", \"choice\", \"environment\" but got %q`, attr.val.Value)\n\t\t\t\t\t}\n\t\t\t\tcase \"options\":\n\t\t\t\t\topts = p.parseStringSequence(\"options\", attr.val, false, false)\n\t\t\t\tdefault:\n\t\t\t\t\tp.unexpectedKey(attr.key, \"inputs\", []string{\"description\", \"required\", \"default\"})\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret.Inputs[input.id] = &DispatchInput{\n\t\t\t\tName:        name,\n\t\t\t\tDescription: desc,\n\t\t\t\tRequired:    req,\n\t\t\t\tDefault:     def,\n\t\t\t\tType:        ty,\n\t\t\t\tOptions:     opts,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#repository_dispatch\nfunc (p *parser) parseRepositoryDispatchEvent(pos *Pos, n *yaml.Node) *RepositoryDispatchEvent {\n\tret := &RepositoryDispatchEvent{Pos: pos}\n\n\t// Note: Omitting 'types' is ok. In the case, all types trigger the workflow\n\tfor _, kv := range p.parseSectionMapping(\"repository_dispatch\", n, true, true) {\n\t\tif kv.id == \"types\" {\n\t\t\tret.Types = p.parseStringOrStringSequence(\"types\", kv.val, false, false)\n\t\t} else {\n\t\t\tp.unexpectedKey(kv.key, \"repository_dispatch\", []string{\"types\"})\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#using-filters\nfunc (p *parser) parseWebhookEventFilter(name *String, n *yaml.Node) *WebhookEventFilter {\n\tv := p.parseStringOrStringSequence(name.Value, n, false, false)\n\treturn &WebhookEventFilter{name, v}\n}\n\nfunc (p *parser) parseWebhookEvent(name *String, n *yaml.Node) *WebhookEvent {\n\tret := &WebhookEvent{Hook: name, Pos: name.Pos}\n\n\t// Note: 'tags', 'tags-ignore', 'branches', 'branches-ignore' can be empty. Since there are\n\t// some cases where setting empty values to them is necessary.\n\t//\n\t// > If only define only tags filter (tags/tags-ignore) or only branches filter\n\t// > (branches/branches-ignore) for on.push, the workflow wont run for events affecting the\n\t// > undefined Git ref.\n\t//\n\t// https://github.community/t/using-on-push-tags-ignore-and-paths-ignore-together/16931\n\tfor _, kv := range p.parseSectionMapping(name.Value, n, true, true) {\n\t\t// Note: Glob pattern cannot be empty, but it is checked by 'glob' rule with better error\n\t\t// message. So parser allows empty patterns here.\n\t\tswitch kv.id {\n\t\tcase \"types\":\n\t\t\tret.Types = p.parseStringOrStringSequence(kv.key.Value, kv.val, false, false)\n\t\tcase \"branches\":\n\t\t\tret.Branches = p.parseWebhookEventFilter(kv.key, kv.val)\n\t\tcase \"branches-ignore\":\n\t\t\tret.BranchesIgnore = p.parseWebhookEventFilter(kv.key, kv.val)\n\t\tcase \"tags\":\n\t\t\tret.Tags = p.parseWebhookEventFilter(kv.key, kv.val)\n\t\tcase \"tags-ignore\":\n\t\t\tret.TagsIgnore = p.parseWebhookEventFilter(kv.key, kv.val)\n\t\tcase \"paths\":\n\t\t\tret.Paths = p.parseWebhookEventFilter(kv.key, kv.val)\n\t\tcase \"paths-ignore\":\n\t\t\tret.PathsIgnore = p.parseWebhookEventFilter(kv.key, kv.val)\n\t\tcase \"workflows\":\n\t\t\tret.Workflows = p.parseStringOrStringSequence(kv.key.Value, kv.val, false, false)\n\t\tdefault:\n\t\t\tp.unexpectedKey(kv.key, name.Value, []string{\n\t\t\t\t\"types\",\n\t\t\t\t\"branches\",\n\t\t\t\t\"branches-ignore\",\n\t\t\t\t\"tags\",\n\t\t\t\t\"tags-ignore\",\n\t\t\t\t\"paths\",\n\t\t\t\t\"paths-ignore\",\n\t\t\t\t\"workflows\",\n\t\t\t})\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// - https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#workflow-reuse-events\n// - https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_callinputs\n// - https://docs.github.com/en/actions/learn-github-actions/reusing-workflows\nfunc (p *parser) parseWorkflowCallEvent(pos *Pos, n *yaml.Node) *WorkflowCallEvent {\n\tret := &WorkflowCallEvent{Pos: pos}\n\n\tfor _, kv := range p.parseSectionMapping(\"workflow_call\", n, true, true) {\n\t\tswitch kv.id {\n\t\tcase \"inputs\":\n\t\t\tinputs := p.parseSectionMapping(\"inputs\", kv.val, true, false)\n\t\t\tret.Inputs = make([]*WorkflowCallEventInput, 0, len(inputs))\n\t\t\tfor _, kv := range inputs {\n\t\t\t\tname, spec := kv.key, kv.val\n\t\t\t\tinput := &WorkflowCallEventInput{Name: name, ID: kv.id}\n\t\t\t\tsawType := false\n\n\t\t\t\tfor _, attr := range p.parseMapping(\"input of workflow_call event\", spec, true, true) {\n\t\t\t\t\tswitch attr.id {\n\t\t\t\t\tcase \"description\":\n\t\t\t\t\t\tinput.Description = p.parseString(attr.val, true)\n\t\t\t\t\tcase \"required\":\n\t\t\t\t\t\tinput.Required = p.parseBool(attr.val)\n\t\t\t\t\tcase \"default\":\n\t\t\t\t\t\tinput.Default = p.parseString(attr.val, true)\n\t\t\t\t\tcase \"type\":\n\t\t\t\t\t\tswitch attr.val.Value {\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\tinput.Type = WorkflowCallEventInputTypeBoolean\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\t\tinput.Type = WorkflowCallEventInputTypeNumber\n\t\t\t\t\t\tcase \"string\":\n\t\t\t\t\t\t\tinput.Type = WorkflowCallEventInputTypeString\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tp.errorf(attr.val, \"invalid value %q for input type of workflow_call event. it must be one of \\\"boolean\\\", \\\"number\\\", or \\\"string\\\"\", attr.val.Value)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsawType = true\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.unexpectedKey(attr.key, \"inputs at workflow_call event\", []string{\"description\", \"required\", \"default\", \"type\"})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif !sawType {\n\t\t\t\t\tp.errorfAt(name.Pos, \"\\\"type\\\" is missing at %q input of workflow_call event\", name.Value)\n\t\t\t\t}\n\n\t\t\t\tret.Inputs = append(ret.Inputs, input)\n\t\t\t}\n\t\tcase \"secrets\":\n\t\t\tsecrets := p.parseSectionMapping(\"secrets\", kv.val, true, false)\n\t\t\tret.Secrets = make(map[string]*WorkflowCallEventSecret, len(secrets))\n\t\t\tfor _, kv := range secrets {\n\t\t\t\tname, spec := kv.key, kv.val\n\t\t\t\tsecret := &WorkflowCallEventSecret{Name: name}\n\n\t\t\t\tfor _, attr := range p.parseMapping(\"secret of workflow_call event\", spec, true, true) {\n\t\t\t\t\tswitch attr.id {\n\t\t\t\t\tcase \"description\":\n\t\t\t\t\t\tsecret.Description = p.parseString(attr.val, true)\n\t\t\t\t\tcase \"required\":\n\t\t\t\t\t\tsecret.Required = p.parseBool(attr.val)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.unexpectedKey(attr.key, \"secrets\", []string{\"description\", \"required\"})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tret.Secrets[kv.id] = secret\n\t\t\t}\n\t\tcase \"outputs\":\n\t\t\toutputs := p.parseSectionMapping(\"outputs\", kv.val, true, false)\n\t\t\tret.Outputs = make(map[string]*WorkflowCallEventOutput, len(outputs))\n\t\t\tfor _, kv := range outputs {\n\t\t\t\tname, spec := kv.key, kv.val\n\t\t\t\toutput := &WorkflowCallEventOutput{Name: name}\n\n\t\t\t\tfor _, attr := range p.parseMapping(\"output of workflow_call event\", spec, true, true) {\n\t\t\t\t\tswitch attr.id {\n\t\t\t\t\tcase \"description\":\n\t\t\t\t\t\toutput.Description = p.parseString(attr.val, true)\n\t\t\t\t\tcase \"value\":\n\t\t\t\t\t\toutput.Value = p.parseString(attr.val, false)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.unexpectedKey(attr.key, \"outputs at workflow_call event\", []string{\"description\", \"value\"})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif output.Value == nil {\n\t\t\t\t\tp.errorfAt(name.Pos, \"\\\"value\\\" is missing at %q output of workflow_call event\", name.Value)\n\t\t\t\t}\n\n\t\t\t\tret.Outputs[kv.id] = output\n\t\t\t}\n\t\tdefault:\n\t\t\tp.unexpectedKey(kv.key, \"workflow_call\", []string{\"inputs\", \"secrets\", \"outputs\"})\n\t\t}\n\t}\n\n\treturn ret\n}\n\nfunc (p *parser) parseEvents(pos *Pos, n *yaml.Node) []Event {\n\tswitch n.Kind {\n\tcase yaml.ScalarNode:\n\t\tswitch n.Value {\n\t\tcase \"workflow_dispatch\":\n\t\t\treturn []Event{\n\t\t\t\t&WorkflowDispatchEvent{Pos: posAt(n)},\n\t\t\t}\n\t\tcase \"repository_dispatch\":\n\t\t\treturn []Event{\n\t\t\t\t&RepositoryDispatchEvent{Pos: posAt(n)},\n\t\t\t}\n\t\tcase \"schedule\":\n\t\t\tp.errorAt(pos, \"schedule event must be configured with mapping\")\n\t\t\treturn []Event{}\n\t\tcase \"workflow_call\":\n\t\t\treturn []Event{\n\t\t\t\t&WorkflowCallEvent{Pos: posAt(n)},\n\t\t\t}\n\t\tdefault:\n\t\t\th := p.parseString(n, false)\n\t\t\tif h.Value == \"\" {\n\t\t\t\treturn []Event{}\n\t\t\t}\n\t\t\treturn []Event{\n\t\t\t\t&WebhookEvent{\n\t\t\t\t\tHook: h,\n\t\t\t\t\tPos:  posAt(n),\n\t\t\t\t},\n\t\t\t}\n\t\t}\n\tcase yaml.MappingNode:\n\t\tkvs := p.parseSectionMapping(\"on\", n, false, true)\n\t\tret := make([]Event, 0, len(kvs))\n\n\t\tfor _, kv := range kvs {\n\t\t\tpos := kv.key.Pos\n\t\t\tswitch kv.id {\n\t\t\tcase \"schedule\":\n\t\t\t\tif e := p.parseScheduleEvent(pos, kv.val); e != nil {\n\t\t\t\t\tret = append(ret, e)\n\t\t\t\t}\n\t\t\tcase \"workflow_dispatch\":\n\t\t\t\tret = append(ret, p.parseWorkflowDispatchEvent(pos, kv.val))\n\t\t\tcase \"repository_dispatch\":\n\t\t\t\tret = append(ret, p.parseRepositoryDispatchEvent(pos, kv.val))\n\t\t\tcase \"workflow_call\":\n\t\t\t\tret = append(ret, p.parseWorkflowCallEvent(pos, kv.val))\n\t\t\tdefault:\n\t\t\t\tret = append(ret, p.parseWebhookEvent(kv.key, kv.val))\n\t\t\t}\n\t\t}\n\n\t\treturn ret\n\tcase yaml.SequenceNode:\n\t\tl := len(n.Content)\n\t\tp.checkNotEmpty(\"on\", l, n)\n\t\tret := make([]Event, 0, l)\n\n\t\tfor _, c := range n.Content {\n\t\t\tif s := p.parseString(c, false); s != nil {\n\t\t\t\tswitch s.Value {\n\t\t\t\tcase \"schedule\", \"repository_dispatch\":\n\t\t\t\t\tp.errorf(c, \"%q event should not be listed in sequence. Use mapping for \\\"on\\\" section and configure the event as values of the mapping\", s.Value)\n\t\t\t\tcase \"workflow_dispatch\":\n\t\t\t\t\tret = append(ret, &WorkflowDispatchEvent{Pos: posAt(c)})\n\t\t\t\tcase \"workflow_call\":\n\t\t\t\t\tret = append(ret, &WorkflowCallEvent{Pos: posAt(c)})\n\t\t\t\tdefault:\n\t\t\t\t\tret = append(ret, &WebhookEvent{Hook: s, Pos: posAt(c)})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ret\n\tdefault:\n\t\tp.errorf(n, \"\\\"on\\\" section value is expected to be mapping or sequence but found %s node\", nodeKindName(n.Kind))\n\t\treturn nil\n\t}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#permissions\nfunc (p *parser) parsePermissions(pos *Pos, n *yaml.Node) *Permissions {\n\tret := &Permissions{Pos: pos}\n\n\tif n.Kind == yaml.ScalarNode {\n\t\tret.All = p.parseString(n, false)\n\t} else {\n\t\tm := p.parseSectionMapping(\"permissions\", n, true, false) // XXX: Is the permission scope case insensitive?\n\t\tscopes := make(map[string]*PermissionScope, len(m))\n\t\tfor _, kv := range m {\n\t\t\tscopes[kv.id] = &PermissionScope{\n\t\t\t\tName:  kv.key,\n\t\t\t\tValue: p.parseString(kv.val, false),\n\t\t\t}\n\t\t}\n\t\tret.Scopes = scopes\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#env\nfunc (p *parser) parseEnv(n *yaml.Node) *Env {\n\tif n.Kind == yaml.ScalarNode {\n\t\treturn &Env{\n\t\t\tExpression: p.parseExpression(n, \"mapping value for \\\"env\\\" section\"),\n\t\t}\n\t}\n\n\tm := p.parseMapping(\"env\", n, false, false)\n\tvars := make(map[string]*EnvVar, len(m))\n\n\tfor _, kv := range m {\n\t\tvars[kv.id] = &EnvVar{\n\t\t\tName:  kv.key,\n\t\t\tValue: p.parseString(kv.val, true),\n\t\t}\n\t}\n\n\treturn &Env{Vars: vars}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#defaults\nfunc (p *parser) parseDefaults(pos *Pos, n *yaml.Node) *Defaults {\n\tret := &Defaults{Pos: pos}\n\n\tfor _, kv := range p.parseSectionMapping(\"defaults\", n, false, true) {\n\t\tif kv.id != \"run\" {\n\t\t\tp.unexpectedKey(kv.key, \"defaults\", []string{\"run\"})\n\t\t\tcontinue\n\t\t}\n\t\tret.Run = &DefaultsRun{Pos: kv.key.Pos}\n\n\t\tfor _, attr := range p.parseSectionMapping(\"run\", kv.val, false, true) {\n\t\t\tswitch attr.id {\n\t\t\tcase \"shell\":\n\t\t\t\tret.Run.Shell = p.parseString(attr.val, false)\n\t\t\tcase \"working-directory\":\n\t\t\t\tret.Run.WorkingDirectory = p.parseString(attr.val, false)\n\t\t\tdefault:\n\t\t\t\tp.unexpectedKey(attr.key, \"run\", []string{\"shell\", \"working-directory\"})\n\t\t\t}\n\t\t}\n\t}\n\n\tif ret.Run == nil {\n\t\tp.error(n, \"\\\"defaults\\\" section should have \\\"run\\\" section\")\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idconcurrency\nfunc (p *parser) parseConcurrency(pos *Pos, n *yaml.Node) *Concurrency {\n\tret := &Concurrency{Pos: pos}\n\n\tif n.Kind == yaml.ScalarNode {\n\t\tret.Group = p.parseString(n, false)\n\t} else {\n\t\tgroupFound := false\n\t\tfor _, kv := range p.parseSectionMapping(\"concurrency\", n, false, true) {\n\t\t\tswitch kv.id {\n\t\t\tcase \"group\":\n\t\t\t\tret.Group = p.parseString(kv.val, false)\n\t\t\t\tgroupFound = true\n\t\t\tcase \"cancel-in-progress\":\n\t\t\t\tret.CancelInProgress = p.parseBool(kv.val)\n\t\t\tdefault:\n\t\t\t\tp.unexpectedKey(kv.key, \"concurrency\", []string{\"group\", \"cancel-in-progress\"})\n\t\t\t}\n\t\t}\n\t\tif !groupFound {\n\t\t\tp.errorAt(pos, \"group name is missing in \\\"concurrency\\\" section\")\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idenvironment\nfunc (p *parser) parseEnvironment(pos *Pos, n *yaml.Node) *Environment {\n\tret := &Environment{Pos: pos}\n\n\tif n.Kind == yaml.ScalarNode {\n\t\tret.Name = p.parseString(n, false)\n\t} else {\n\t\tnameFound := false\n\t\tfor _, kv := range p.parseSectionMapping(\"environment\", n, false, true) {\n\t\t\tswitch kv.id {\n\t\t\tcase \"name\":\n\t\t\t\tret.Name = p.parseString(kv.val, false)\n\t\t\t\tnameFound = true\n\t\t\tcase \"url\":\n\t\t\t\tret.URL = p.parseString(kv.val, false)\n\t\t\tdefault:\n\t\t\t\tp.unexpectedKey(kv.key, \"environment\", []string{\"name\", \"url\"})\n\t\t\t}\n\t\t}\n\t\tif !nameFound {\n\t\t\tp.errorAt(pos, \"name is missing in \\\"environment\\\" section\")\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idoutputs\nfunc (p *parser) parseOutputs(n *yaml.Node) map[string]*Output {\n\toutputs := p.parseSectionMapping(\"outputs\", n, false, false)\n\tret := make(map[string]*Output, len(outputs))\n\tfor _, output := range outputs {\n\t\tret[output.id] = &Output{\n\t\t\tName:  output.key,\n\t\t\tValue: p.parseString(output.val, true),\n\t\t}\n\t}\n\tp.checkNotEmpty(\"outputs\", len(ret), n)\n\treturn ret\n}\n\nfunc (p *parser) parseRawYAMLValue(n *yaml.Node) RawYAMLValue {\n\tswitch n.Kind {\n\tcase yaml.ScalarNode:\n\t\treturn &RawYAMLString{n.Value, posAt(n)}\n\tcase yaml.SequenceNode:\n\t\tvs := make([]RawYAMLValue, 0, len(n.Content))\n\t\tfor _, c := range n.Content {\n\t\t\tif v := p.parseRawYAMLValue(c); v != nil {\n\t\t\t\tvs = append(vs, v)\n\t\t\t}\n\t\t}\n\t\treturn &RawYAMLArray{vs, posAt(n)}\n\tcase yaml.MappingNode:\n\t\tparsed := p.parseMapping(\"matrix row value\", n, true, false)\n\t\tm := make(map[string]RawYAMLValue, len(parsed))\n\t\tfor _, kv := range parsed {\n\t\t\tif v := p.parseRawYAMLValue(kv.val); v != nil {\n\t\t\t\tm[kv.id] = v\n\t\t\t}\n\t\t}\n\t\treturn &RawYAMLObject{m, posAt(n)}\n\tdefault:\n\t\tp.errorf(n, \"unexpected %s node on parsing value in matrix row\", nodeKindName(n.Kind))\n\t\treturn nil\n\t}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#example-including-additional-values-into-combinations\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#example-excluding-configurations-from-a-matrix\nfunc (p *parser) parseMatrixCombinations(sec string, n *yaml.Node) *MatrixCombinations {\n\tif n.Kind == yaml.ScalarNode {\n\t\treturn &MatrixCombinations{\n\t\t\tExpression: p.parseExpression(n, \"array of matrix combination\"),\n\t\t}\n\t}\n\n\tif ok := p.checkSequence(sec, n, false); !ok {\n\t\treturn nil\n\t}\n\n\tret := make([]*MatrixCombination, 0, len(n.Content))\n\tfor _, c := range n.Content {\n\t\tif c.Kind == yaml.ScalarNode {\n\t\t\tif e := p.parseExpression(c, \"mapping of matrix combination\"); e != nil {\n\t\t\t\tret = append(ret, &MatrixCombination{Expression: e})\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tkvs := p.parseMapping(fmt.Sprintf(\"element in %q section\", sec), c, false, false)\n\t\tassigns := make(map[string]*MatrixAssign, len(kvs))\n\t\tfor _, kv := range kvs {\n\t\t\tif v := p.parseRawYAMLValue(kv.val); v != nil {\n\t\t\t\tassigns[kv.id] = &MatrixAssign{kv.key, v}\n\t\t\t}\n\t\t}\n\t\tret = append(ret, &MatrixCombination{Assigns: assigns})\n\t}\n\treturn &MatrixCombinations{Combinations: ret}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategymatrix\nfunc (p *parser) parseMatrix(pos *Pos, n *yaml.Node) *Matrix {\n\tif n.Kind == yaml.ScalarNode {\n\t\treturn &Matrix{\n\t\t\tExpression: p.parseExpression(n, \"matrix\"),\n\t\t\tPos:        posAt(n),\n\t\t}\n\t}\n\n\tret := &Matrix{Pos: pos, Rows: make(map[string]*MatrixRow)}\n\n\tfor _, kv := range p.parseSectionMapping(\"matrix\", n, false, false) {\n\t\tswitch kv.id {\n\t\tcase \"include\":\n\t\t\tret.Include = p.parseMatrixCombinations(\"include\", kv.val)\n\t\tcase \"exclude\":\n\t\t\tret.Exclude = p.parseMatrixCombinations(\"exclude\", kv.val)\n\t\tdefault:\n\t\t\tif kv.val.Kind == yaml.ScalarNode {\n\t\t\t\tret.Rows[kv.id] = &MatrixRow{\n\t\t\t\t\tExpression: p.parseExpression(kv.val, \"array value for matrix variations\"),\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif ok := p.checkSequence(\"matrix values\", kv.val, false); !ok {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvalues := make([]RawYAMLValue, 0, len(kv.val.Content))\n\t\t\tfor _, c := range kv.val.Content {\n\t\t\t\tif v := p.parseRawYAMLValue(c); v != nil {\n\t\t\t\t\tvalues = append(values, v)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tret.Rows[kv.id] = &MatrixRow{\n\t\t\t\tName:   kv.key,\n\t\t\t\tValues: values,\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idstrategymax-parallel\nfunc (p *parser) parseMaxParallel(n *yaml.Node) *Int {\n\ti := p.parseInt(n)\n\tif i != nil && i.Expression == nil && i.Value <= 0 {\n\t\tp.errorf(n, \"value at \\\"max-parallel\\\" must be greater than zero: %v\", i.Value)\n\t}\n\treturn i\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstrategy\nfunc (p *parser) parseStrategy(pos *Pos, n *yaml.Node) *Strategy {\n\tret := &Strategy{Pos: pos}\n\n\tfor _, kv := range p.parseSectionMapping(\"strategy\", n, false, true) {\n\t\tswitch kv.id {\n\t\tcase \"matrix\":\n\t\t\tret.Matrix = p.parseMatrix(kv.key.Pos, kv.val)\n\t\tcase \"fail-fast\":\n\t\t\tret.FailFast = p.parseBool(kv.val)\n\t\tcase \"max-parallel\":\n\t\t\tret.MaxParallel = p.parseMaxParallel(kv.val)\n\t\tdefault:\n\t\t\tp.unexpectedKey(kv.key, \"strategy\", []string{\"matrix\", \"fail-fast\", \"max-parallel\"})\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idcontainer\nfunc (p *parser) parseContainer(sec string, pos *Pos, n *yaml.Node) *Container {\n\tret := &Container{Pos: pos}\n\n\tif n.Kind == yaml.ScalarNode {\n\t\t// When you only specify a container image, you can omit the image keyword.\n\t\tret.Image = p.parseString(n, false)\n\t} else {\n\t\tfor _, kv := range p.parseSectionMapping(sec, n, false, true) {\n\t\t\tswitch kv.id {\n\t\t\tcase \"image\":\n\t\t\t\tret.Image = p.parseString(kv.val, false)\n\t\t\tcase \"credentials\":\n\t\t\t\tcred := &Credentials{Pos: kv.key.Pos}\n\t\t\t\tfor _, c := range p.parseSectionMapping(\"credentials\", kv.val, false, true) {\n\t\t\t\t\tswitch c.id {\n\t\t\t\t\tcase \"username\":\n\t\t\t\t\t\tcred.Username = p.parseString(c.val, false)\n\t\t\t\t\tcase \"password\":\n\t\t\t\t\t\tcred.Password = p.parseString(c.val, false)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tp.unexpectedKey(c.key, \"credentials\", []string{\"username\", \"password\"})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif cred.Username == nil || cred.Password == nil {\n\t\t\t\t\tp.errorAt(kv.key.Pos, \"both \\\"username\\\" and \\\"password\\\" must be specified in \\\"credentials\\\" section\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tret.Credentials = cred\n\t\t\tcase \"env\":\n\t\t\t\tret.Env = p.parseEnv(kv.val)\n\t\t\tcase \"ports\":\n\t\t\t\tret.Ports = p.parseStringSequence(\"ports\", kv.val, true, false)\n\t\t\tcase \"volumes\":\n\t\t\t\tret.Ports = p.parseStringSequence(\"volumes\", kv.val, true, false)\n\t\t\tcase \"options\":\n\t\t\t\tret.Options = p.parseString(kv.val, true)\n\t\t\tdefault:\n\t\t\t\tp.unexpectedKey(kv.key, sec, []string{\n\t\t\t\t\t\"image\",\n\t\t\t\t\t\"credentials\",\n\t\t\t\t\t\"env\",\n\t\t\t\t\t\"ports\",\n\t\t\t\t\t\"volumes\",\n\t\t\t\t\t\"options\",\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret\n}\n\nfunc (p *parser) parseServices(n *yaml.Node) *Services {\n\tret := &Services{Pos: posAt(n)}\n\tif e := p.mayParseExpression(n); e != nil {\n\t\tret.Expression = e\n\t} else {\n\t\tservices := p.parseSectionMapping(\"services\", n, false, false) // XXX: Is the key case-insensitive?\n\t\tss := make(map[string]*Service, len(services))\n\t\tfor _, s := range services {\n\t\t\tss[s.id] = &Service{\n\t\t\t\tName:      s.key,\n\t\t\t\tContainer: p.parseContainer(\"services\", s.key.Pos, s.val),\n\t\t\t}\n\t\t}\n\t\tret.Value = ss\n\t}\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idtimeout-minutes\nfunc (p *parser) parseTimeoutMinutes(n *yaml.Node) *Float {\n\tf := p.parseFloat(n)\n\tif f != nil && f.Expression == nil && f.Value <= 0.0 {\n\t\tp.errorf(n, \"value at \\\"timeout-minutes\\\" must be greater than zero: %v\", f.Value)\n\t}\n\treturn f\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idsteps\nfunc (p *parser) parseStep(n *yaml.Node) *Step {\n\tret := &Step{Pos: posAt(n)}\n\tvar workDir *String\n\n\tfor _, kv := range p.parseMapping(\"element of \\\"steps\\\" section\", n, false, true) {\n\t\tswitch kv.id {\n\t\tcase \"id\":\n\t\t\tret.ID = p.parseString(kv.val, false)\n\t\tcase \"if\":\n\t\t\tret.If = p.parseString(kv.val, false)\n\t\tcase \"name\":\n\t\t\tret.Name = p.parseString(kv.val, true)\n\t\tcase \"env\":\n\t\t\tret.Env = p.parseEnv(kv.val)\n\t\tcase \"continue-on-error\":\n\t\t\tret.ContinueOnError = p.parseBool(kv.val)\n\t\tcase \"timeout-minutes\":\n\t\t\tret.TimeoutMinutes = p.parseTimeoutMinutes(kv.val)\n\t\tcase \"uses\", \"with\":\n\t\t\tvar exec *ExecAction\n\t\t\tif ret.Exec == nil {\n\t\t\t\texec = &ExecAction{}\n\t\t\t} else if e, ok := ret.Exec.(*ExecAction); ok {\n\t\t\t\texec = e\n\t\t\t} else {\n\t\t\t\tp.errorfAt(kv.key.Pos, \"this step is for running shell command since it contains at least one of \\\"run\\\", \\\"shell\\\" keys, but also contains %q key which is used for running action\", kv.key.Value)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif kv.id == \"uses\" {\n\t\t\t\texec.Uses = p.parseString(kv.val, false)\n\t\t\t} else {\n\t\t\t\t// kv.key == \"with\"\n\t\t\t\twith := p.parseSectionMapping(\"with\", kv.val, false, false)\n\t\t\t\texec.Inputs = make(map[string]*Input, len(with))\n\t\t\t\tfor _, input := range with {\n\t\t\t\t\tswitch input.id {\n\t\t\t\t\tcase \"entrypoint\":\n\t\t\t\t\t\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithentrypoint\n\t\t\t\t\t\texec.Entrypoint = p.parseString(input.val, false)\n\t\t\t\t\tcase \"args\":\n\t\t\t\t\t\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepswithargs\n\t\t\t\t\t\texec.Args = p.parseString(input.val, true)\n\t\t\t\t\tdefault:\n\t\t\t\t\t\texec.Inputs[input.id] = &Input{input.key, p.parseString(input.val, true)}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tret.Exec = exec\n\t\tcase \"run\", \"shell\":\n\t\t\tvar exec *ExecRun\n\t\t\tif ret.Exec == nil {\n\t\t\t\texec = &ExecRun{}\n\t\t\t} else if e, ok := ret.Exec.(*ExecRun); ok {\n\t\t\t\texec = e\n\t\t\t} else {\n\t\t\t\tp.errorfAt(kv.key.Pos, \"this step is for running action since it contains at least one of \\\"uses\\\", \\\"with\\\" keys, but also contains %q key which is used for running shell command\", kv.key.Value)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tswitch kv.id {\n\t\t\tcase \"run\":\n\t\t\t\texec.Run = p.parseString(kv.val, false)\n\t\t\t\texec.RunPos = kv.key.Pos\n\t\t\tcase \"shell\":\n\t\t\t\texec.Shell = p.parseString(kv.val, false)\n\t\t\t}\n\t\t\texec.WorkingDirectory = workDir\n\t\t\tret.Exec = exec\n\t\tcase \"working-directory\":\n\t\t\tworkDir = p.parseString(kv.val, false)\n\t\t\tif e, ok := ret.Exec.(*ExecRun); ok {\n\t\t\t\te.WorkingDirectory = workDir\n\t\t\t}\n\t\tdefault:\n\t\t\tp.unexpectedKey(kv.key, \"step\", []string{\n\t\t\t\t\"id\",\n\t\t\t\t\"if\",\n\t\t\t\t\"name\",\n\t\t\t\t\"env\",\n\t\t\t\t\"continue-on-error\",\n\t\t\t\t\"timeout-minutes\",\n\t\t\t\t\"uses\",\n\t\t\t\t\"with\",\n\t\t\t\t\"run\",\n\t\t\t\t\"working-directory\",\n\t\t\t\t\"shell\",\n\t\t\t})\n\t\t}\n\t}\n\n\tswitch e := ret.Exec.(type) {\n\tcase *ExecAction:\n\t\tif e.Uses == nil {\n\t\t\tp.error(n, \"\\\"uses\\\" is required to run action in step\")\n\t\t}\n\t\tif workDir != nil {\n\t\t\tp.errorAt(workDir.Pos, \"\\\"working-directory\\\" is not available with \\\"uses\\\". it is only available with \\\"run\\\"\")\n\t\t}\n\tcase *ExecRun:\n\t\tif e.Run == nil {\n\t\t\tp.error(n, \"\\\"run\\\" is required to run script in step\")\n\t\t}\n\tdefault:\n\t\tp.error(n, \"step must run script with \\\"run\\\" section or run action with \\\"uses\\\" section\")\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idsteps\nfunc (p *parser) parseSteps(n *yaml.Node) []*Step {\n\tif ok := p.checkSequence(\"steps\", n, false); !ok {\n\t\treturn nil\n\t}\n\n\tret := make([]*Step, 0, len(n.Content))\n\n\tfor _, c := range n.Content {\n\t\tif s := p.parseStep(c); s != nil {\n\t\t\tret = append(ret, s)\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#jobsjob_idruns-on\nfunc (p *parser) parseRunsOn(n *yaml.Node) *Runner {\n\tif expr := p.mayParseExpression(n); expr != nil {\n\t\treturn &Runner{nil, expr, nil}\n\t}\n\n\tif n.Kind == yaml.ScalarNode || n.Kind == yaml.SequenceNode {\n\t\tlabels := p.parseStringOrStringSequence(\"runs-on\", n, false, false)\n\t\treturn &Runner{labels, nil, nil}\n\t}\n\n\tr := &Runner{}\n\tfor _, kv := range p.parseSectionMapping(\"runs-on\", n, false, true) {\n\t\tswitch kv.id {\n\t\tcase \"labels\":\n\t\t\tif expr := p.mayParseExpression(kv.val); expr != nil {\n\t\t\t\tr.LabelsExpr = expr\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tr.Labels = p.parseStringOrStringSequence(\"labels\", kv.val, false, false)\n\t\tcase \"group\":\n\t\t\tr.Group = p.parseString(kv.val, false)\n\t\tdefault:\n\t\t\tp.unexpectedKey(kv.key, \"runs-on\", []string{\"labels\", \"group\"})\n\t\t}\n\t}\n\n\treturn r\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_id\nfunc (p *parser) parseJob(id *String, n *yaml.Node) *Job {\n\tret := &Job{ID: id, Pos: id.Pos}\n\tcall := &WorkflowCall{}\n\n\t// Only below keys are allowed on reusable workflow call\n\t// https://docs.github.com/en/actions/learn-github-actions/reusing-workflows#supported-keywords-for-jobs-that-call-a-reusable-workflow\n\t//   - jobs.<job_id>.name\n\t//   - jobs.<job_id>.uses\n\t//   - jobs.<job_id>.with\n\t//   - jobs.<job_id>.with.<input_id>\n\t//   - jobs.<job_id>.secrets\n\t//   - jobs.<job_id>.secrets.<secret_id>\n\t//   - jobs.<job_id>.needs\n\t//   - jobs.<job_id>.if\n\t//   - jobs.<job_id>.permissions\n\n\t// https://docs.github.com/en/actions/using-workflows/reusing-workflows#supported-keywords-for-jobs-that-call-a-reusable-workflow\n\tvar stepsOnlyKey *String\n\tvar callOnlyKey *String\n\n\tfor _, kv := range p.parseMapping(fmt.Sprintf(\"%q job\", id.Value), n, false, true) {\n\t\tk, v := kv.key, kv.val\n\t\tswitch kv.id {\n\t\tcase \"name\":\n\t\t\tret.Name = p.parseString(v, true)\n\t\tcase \"needs\":\n\t\t\tif v.Kind == yaml.ScalarNode {\n\t\t\t\t// needs: job1\n\t\t\t\tret.Needs = []*String{p.parseString(v, false)}\n\t\t\t} else {\n\t\t\t\t// needs: [job1, job2]\n\t\t\t\tret.Needs = p.parseStringSequence(\"needs\", v, false, false)\n\t\t\t}\n\t\tcase \"runs-on\":\n\t\t\tret.RunsOn = p.parseRunsOn(v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"permissions\":\n\t\t\tret.Permissions = p.parsePermissions(k.Pos, v)\n\t\tcase \"environment\":\n\t\t\tret.Environment = p.parseEnvironment(k.Pos, v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"concurrency\":\n\t\t\tret.Concurrency = p.parseConcurrency(k.Pos, v)\n\t\tcase \"outputs\":\n\t\t\tret.Outputs = p.parseOutputs(v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"env\":\n\t\t\tret.Env = p.parseEnv(v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"defaults\":\n\t\t\tret.Defaults = p.parseDefaults(k.Pos, v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"if\":\n\t\t\tret.If = p.parseString(v, false)\n\t\tcase \"steps\":\n\t\t\tret.Steps = p.parseSteps(v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"timeout-minutes\":\n\t\t\tret.TimeoutMinutes = p.parseTimeoutMinutes(v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"strategy\":\n\t\t\tret.Strategy = p.parseStrategy(k.Pos, v)\n\t\tcase \"continue-on-error\":\n\t\t\tret.ContinueOnError = p.parseBool(v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"container\":\n\t\t\tret.Container = p.parseContainer(\"container\", k.Pos, v)\n\t\t\tstepsOnlyKey = k\n\t\tcase \"services\":\n\t\t\tret.Services = p.parseServices(v)\n\t\tcase \"uses\":\n\t\t\tcall.Uses = p.parseString(v, false)\n\t\t\tcallOnlyKey = k\n\t\tcase \"with\":\n\t\t\twith := p.parseSectionMapping(\"with\", v, false, false)\n\t\t\tcall.Inputs = make(map[string]*WorkflowCallInput, len(with))\n\t\t\tfor _, i := range with {\n\t\t\t\tcall.Inputs[i.id] = &WorkflowCallInput{\n\t\t\t\t\tName:  i.key,\n\t\t\t\t\tValue: p.parseString(i.val, true),\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallOnlyKey = k\n\t\tcase \"secrets\":\n\t\t\tif kv.val.Kind == yaml.ScalarNode {\n\t\t\t\t// `secrets: inherit` special case\n\t\t\t\t// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_callsecretsinherit\n\t\t\t\tif kv.val.Value == \"inherit\" {\n\t\t\t\t\tcall.InheritSecrets = true\n\t\t\t\t} else {\n\t\t\t\t\tp.errorf(kv.val, \"expected mapping node for secrets or \\\"inherit\\\" string node but found %q node\", kv.val.Value)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsecrets := p.parseSectionMapping(\"secrets\", v, false, false)\n\t\t\t\tcall.Secrets = make(map[string]*WorkflowCallSecret, len(secrets))\n\t\t\t\tfor _, s := range secrets {\n\t\t\t\t\tcall.Secrets[s.id] = &WorkflowCallSecret{\n\t\t\t\t\t\tName:  s.key,\n\t\t\t\t\t\tValue: p.parseString(s.val, true),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallOnlyKey = k\n\t\tdefault:\n\t\t\tp.unexpectedKey(kv.key, \"job\", []string{\n\t\t\t\t\"name\",\n\t\t\t\t\"needs\",\n\t\t\t\t\"runs-on\",\n\t\t\t\t\"permissions\",\n\t\t\t\t\"environment\",\n\t\t\t\t\"concurrency\",\n\t\t\t\t\"outputs\",\n\t\t\t\t\"env\",\n\t\t\t\t\"defaults\",\n\t\t\t\t\"if\",\n\t\t\t\t\"steps\",\n\t\t\t\t\"timeout-minutes\",\n\t\t\t\t\"strategy\",\n\t\t\t\t\"continue-on-error\",\n\t\t\t\t\"container\",\n\t\t\t\t\"services\",\n\t\t\t\t\"uses\",\n\t\t\t\t\"with\",\n\t\t\t\t\"secrets\",\n\t\t\t})\n\t\t}\n\t}\n\n\tif call.Uses != nil {\n\t\tif stepsOnlyKey != nil {\n\t\t\tp.errorfAt(\n\t\t\t\tstepsOnlyKey.Pos,\n\t\t\t\t\"when a reusable workflow is called with \\\"uses\\\", %q is not available. only following keys are allowed: \\\"name\\\", \\\"uses\\\", \\\"with\\\", \\\"secrets\\\", \\\"needs\\\", \\\"if\\\", and \\\"permissions\\\" in job %q\",\n\t\t\t\tstepsOnlyKey.Value,\n\t\t\t\tid.Value,\n\t\t\t)\n\t\t} else {\n\t\t\tret.WorkflowCall = call\n\t\t}\n\t} else {\n\t\t// When not a reusable call\n\t\tif ret.Steps == nil {\n\t\t\tp.errorfAt(id.Pos, \"\\\"steps\\\" section is missing in job %q\", id.Value)\n\t\t}\n\t\tif ret.RunsOn == nil {\n\t\t\tp.errorfAt(id.Pos, \"\\\"runs-on\\\" section is missing in job %q\", id.Value)\n\t\t}\n\t\tif callOnlyKey != nil {\n\t\t\tp.errorfAt(\n\t\t\t\tcallOnlyKey.Pos,\n\t\t\t\t\"%q is only available for a reusable workflow call with \\\"uses\\\" but \\\"uses\\\" is not found in job %q\",\n\t\t\t\tcallOnlyKey.Value,\n\t\t\t\tid.Value,\n\t\t\t)\n\t\t}\n\t}\n\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobs\nfunc (p *parser) parseJobs(n *yaml.Node) map[string]*Job {\n\tjobs := p.parseSectionMapping(\"jobs\", n, false, false)\n\tret := make(map[string]*Job, len(jobs))\n\tfor _, kv := range jobs {\n\t\tret[kv.id] = p.parseJob(kv.key, kv.val)\n\t}\n\treturn ret\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions\nfunc (p *parser) parse(n *yaml.Node) *Workflow {\n\tw := &Workflow{}\n\n\tif n.Line == 0 {\n\t\tn.Line = 1\n\t}\n\tif n.Column == 0 {\n\t\tn.Column = 1\n\t}\n\n\tif len(n.Content) == 0 {\n\t\tp.error(n, \"workflow is empty\")\n\t\treturn w\n\t}\n\n\tfor _, kv := range p.parseMapping(\"workflow\", n.Content[0], false, true) {\n\t\tk, v := kv.key, kv.val\n\t\tswitch kv.id {\n\t\tcase \"name\":\n\t\t\tw.Name = p.parseString(v, true)\n\t\tcase \"on\":\n\t\t\tw.On = p.parseEvents(k.Pos, v)\n\t\tcase \"permissions\":\n\t\t\tw.Permissions = p.parsePermissions(k.Pos, v)\n\t\tcase \"env\":\n\t\t\tw.Env = p.parseEnv(v)\n\t\tcase \"defaults\":\n\t\t\tw.Defaults = p.parseDefaults(k.Pos, v)\n\t\tcase \"concurrency\":\n\t\t\tw.Concurrency = p.parseConcurrency(k.Pos, v)\n\t\tcase \"jobs\":\n\t\t\tw.Jobs = p.parseJobs(v)\n\t\tcase \"run-name\":\n\t\t\tw.RunName = p.parseString(v, false)\n\t\tdefault:\n\t\t\tp.unexpectedKey(k, \"workflow\", []string{\n\t\t\t\t\"name\",\n\t\t\t\t\"run-name\",\n\t\t\t\t\"on\",\n\t\t\t\t\"permissions\",\n\t\t\t\t\"env\",\n\t\t\t\t\"defaults\",\n\t\t\t\t\"concurrency\",\n\t\t\t\t\"jobs\",\n\t\t\t})\n\t\t}\n\t}\n\n\tif w.On == nil {\n\t\tp.error(n, \"\\\"on\\\" section is missing in workflow\")\n\t}\n\tif w.Jobs == nil {\n\t\tp.error(n, \"\\\"jobs\\\" section is missing in workflow\")\n\t}\n\n\treturn w\n}\n\n// func dumpYAML(n *yaml.Node, level int) {\n// \tfmt.Printf(\"%s%s (%s, %d,%d): %q\\n\", strings.Repeat(\". \", level), nodeKindName(n.Kind), n.Tag, n.Line, n.Column, n.Value)\n// \tfor _, c := range n.Content {\n// \t\tdumpYAML(c, level+1)\n// \t}\n// }\n\nfunc handleYAMLError(err error) []*Error {\n\tre := regexp.MustCompile(`\\bline (\\d+):`)\n\n\tyamlErr := func(msg string) *Error {\n\t\tl := 0\n\t\tif ss := re.FindStringSubmatch(msg); len(ss) > 1 {\n\t\t\tl, _ = strconv.Atoi(ss[1])\n\t\t}\n\t\tmsg = fmt.Sprintf(\"could not parse as YAML: %s\", msg)\n\t\treturn &Error{msg, \"\", l, 0, \"syntax-check\"}\n\t}\n\n\tif te, ok := err.(*yaml.TypeError); ok {\n\t\terrs := make([]*Error, 0, len(te.Errors))\n\t\tfor _, msg := range te.Errors {\n\t\t\terrs = append(errs, yamlErr(msg))\n\t\t}\n\t\treturn errs\n\t}\n\n\treturn []*Error{yamlErr(err.Error())}\n}\n\n// Parse parses given source as byte sequence into workflow syntax tree. It returns all errors\n// detected while parsing the input. It means that detecting one error does not stop parsing. Even\n// if one or more errors are detected, parser will try to continue parsing and finding more errors.\nfunc Parse(b []byte) (*Workflow, []*Error) {\n\tvar n yaml.Node\n\n\tif err := yaml.Unmarshal(b, &n); err != nil {\n\t\treturn nil, handleYAMLError(err)\n\t}\n\n\t// Uncomment for checking YAML tree\n\t// dumpYAML(&n, 0)\n\n\tp := &parser{}\n\tw := p.parse(&n)\n\n\treturn w, p.errors\n}\n"
        },
        {
          "name": "pass.go",
          "type": "blob",
          "size": 3.4248046875,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n)\n\n// Pass is an interface to traverse a workflow syntax tree\ntype Pass interface {\n\t// VisitStep is callback when visiting Step node. It returns internal error when it cannot continue the process\n\tVisitStep(node *Step) error\n\t// VisitJobPre is callback when visiting Job node before visiting its children. It returns internal error when it cannot continue the process\n\tVisitJobPre(node *Job) error\n\t// VisitJobPost is callback when visiting Job node after visiting its children. It returns internal error when it cannot continue the process\n\tVisitJobPost(node *Job) error\n\t// VisitWorkflowPre is callback when visiting Workflow node before visiting its children. It returns internal error when it cannot continue the process\n\tVisitWorkflowPre(node *Workflow) error\n\t// VisitWorkflowPost is callback when visiting Workflow node after visiting its children. It returns internal error when it cannot continue the process\n\tVisitWorkflowPost(node *Workflow) error\n}\n\n// Visitor visits syntax tree from root in depth-first order\ntype Visitor struct {\n\tpasses []Pass\n\tdbg    io.Writer\n}\n\n// NewVisitor creates Visitor instance\nfunc NewVisitor() *Visitor {\n\treturn &Visitor{}\n}\n\n// AddPass adds new pass which is called on traversing a syntax tree\nfunc (v *Visitor) AddPass(p Pass) {\n\tv.passes = append(v.passes, p)\n}\n\n// EnableDebug enables debug output when non-nil io.Writer value is given. All debug outputs from\n// visitor will be written to the writer.\nfunc (v *Visitor) EnableDebug(w io.Writer) {\n\tv.dbg = w\n}\n\nfunc (v *Visitor) reportElapsedTime(what string, start time.Time) {\n\tfmt.Fprintf(v.dbg, \"[Visitor] %s took %vms\\n\", what, time.Since(start).Milliseconds())\n}\n\n// Visit visits given syntax tree in depth-first order\nfunc (v *Visitor) Visit(n *Workflow) error {\n\tvar t time.Time\n\tif v.dbg != nil {\n\t\tt = time.Now()\n\t}\n\n\tfor _, p := range v.passes {\n\t\tif err := p.VisitWorkflowPre(n); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(\"VisitWorkflowPre\", t)\n\t\tt = time.Now()\n\t}\n\n\tfor _, j := range n.Jobs {\n\t\tif err := v.visitJob(j); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(fmt.Sprintf(\"Visiting %d jobs\", len(n.Jobs)), t)\n\t\tt = time.Now()\n\t}\n\n\tfor _, p := range v.passes {\n\t\tif err := p.VisitWorkflowPost(n); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(\"VisitWorkflowPost\", t)\n\t}\n\n\treturn nil\n}\n\nfunc (v *Visitor) visitJob(n *Job) error {\n\tvar t time.Time\n\tif v.dbg != nil {\n\t\tt = time.Now()\n\t}\n\n\tfor _, p := range v.passes {\n\t\tif err := p.VisitJobPre(n); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(fmt.Sprintf(\"VisitWorkflowJobPre at job %q\", n.ID.Value), t)\n\t\tt = time.Now()\n\t}\n\n\tfor _, s := range n.Steps {\n\t\tif err := v.visitStep(s); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(fmt.Sprintf(\"Visiting %d steps at job %q\", len(n.Steps), n.ID.Value), t)\n\t\tt = time.Now()\n\t}\n\n\tfor _, p := range v.passes {\n\t\tif err := p.VisitJobPost(n); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(fmt.Sprintf(\"VisitWorkflowJobPost at job %q\", n.ID.Value), t)\n\t}\n\n\treturn nil\n}\n\nfunc (v *Visitor) visitStep(n *Step) error {\n\tvar t time.Time\n\tif v.dbg != nil {\n\t\tt = time.Now()\n\t}\n\n\tfor _, p := range v.passes {\n\t\tif err := p.VisitStep(n); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif v.dbg != nil {\n\t\tv.reportElapsedTime(fmt.Sprintf(\"VisitStep at %s\", n.Pos), t)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "playground",
          "type": "tree",
          "content": null
        },
        {
          "name": "popular_actions.go",
          "type": "blob",
          "size": 113.18359375,
          "content": "// Code generated by actionlint/scripts/generate-popular-actions. DO NOT EDIT.\n\npackage actionlint\n\n// PopularActions is data set of known popular actions. Keys are specs (owner/repo@ref) of actions\n// and values are their metadata.\nvar PopularActions = map[string]*ActionMetadata{\n\t\"8398a7/action-slack@v3\": {\n\t\tName: \"action-slack\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"author_name\":     {\"author_name\", false},\n\t\t\t\"channel\":         {\"channel\", false},\n\t\t\t\"custom_payload\":  {\"custom_payload\", false},\n\t\t\t\"fields\":          {\"fields\", false},\n\t\t\t\"github_base_url\": {\"github_base_url\", false},\n\t\t\t\"github_token\":    {\"github_token\", false},\n\t\t\t\"icon_emoji\":      {\"icon_emoji\", false},\n\t\t\t\"icon_url\":        {\"icon_url\", false},\n\t\t\t\"if_mention\":      {\"if_mention\", false},\n\t\t\t\"job_name\":        {\"job_name\", false},\n\t\t\t\"mention\":         {\"mention\", false},\n\t\t\t\"status\":          {\"status\", true},\n\t\t\t\"text\":            {\"text\", false},\n\t\t\t\"username\":        {\"username\", false},\n\t\t},\n\t},\n\t\"Azure/functions-action@v1\": {\n\t\tName: \"Azure Functions Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"app-name\":                       {\"app-name\", true},\n\t\t\t\"enable-oryx-build\":              {\"enable-oryx-build\", false},\n\t\t\t\"package\":                        {\"package\", false},\n\t\t\t\"publish-profile\":                {\"publish-profile\", false},\n\t\t\t\"remote-build\":                   {\"remote-build\", false},\n\t\t\t\"respect-funcignore\":             {\"respect-funcignore\", false},\n\t\t\t\"respect-pom-xml\":                {\"respect-pom-xml\", false},\n\t\t\t\"scm-do-build-during-deployment\": {\"scm-do-build-during-deployment\", false},\n\t\t\t\"sku\":                            {\"sku\", false},\n\t\t\t\"slot-name\":                      {\"slot-name\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"app-url\":     {\"app-url\"},\n\t\t\t\"package-url\": {\"package-url\"},\n\t\t},\n\t},\n\t\"EnricoMi/publish-unit-test-result-action@v1\": {\n\t\tName: \"Publish Test Results\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"check_name\":                       {\"check_name\", false},\n\t\t\t\"check_run_annotations\":            {\"check_run_annotations\", false},\n\t\t\t\"check_run_annotations_branch\":     {\"check_run_annotations_branch\", false},\n\t\t\t\"comment_mode\":                     {\"comment_mode\", false},\n\t\t\t\"comment_on_pr\":                    {\"comment_on_pr\", false},\n\t\t\t\"comment_title\":                    {\"comment_title\", false},\n\t\t\t\"commit\":                           {\"commit\", false},\n\t\t\t\"compare_to_earlier_commit\":        {\"compare_to_earlier_commit\", false},\n\t\t\t\"deduplicate_classes_by_file_name\": {\"deduplicate_classes_by_file_name\", false},\n\t\t\t\"event_file\":                       {\"event_file\", false},\n\t\t\t\"event_name\":                       {\"event_name\", false},\n\t\t\t\"fail_on\":                          {\"fail_on\", false},\n\t\t\t\"files\":                            {\"files\", true},\n\t\t\t\"github_retries\":                   {\"github_retries\", false},\n\t\t\t\"github_token\":                     {\"github_token\", false},\n\t\t\t\"hide_comments\":                    {\"hide_comments\", false},\n\t\t\t\"ignore_runs\":                      {\"ignore_runs\", false},\n\t\t\t\"job_summary\":                      {\"job_summary\", false},\n\t\t\t\"json_file\":                        {\"json_file\", false},\n\t\t\t\"json_thousands_separator\":         {\"json_thousands_separator\", false},\n\t\t\t\"pull_request_build\":               {\"pull_request_build\", false},\n\t\t\t\"report_individual_runs\":           {\"report_individual_runs\", false},\n\t\t\t\"seconds_between_github_reads\":     {\"seconds_between_github_reads\", false},\n\t\t\t\"seconds_between_github_writes\":    {\"seconds_between_github_writes\", false},\n\t\t\t\"test_changes_limit\":               {\"test_changes_limit\", false},\n\t\t\t\"time_unit\":                        {\"time_unit\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"json\": {\"json\"},\n\t\t},\n\t},\n\t\"EnricoMi/publish-unit-test-result-action@v2\": {\n\t\tName: \"Publish Test Results\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"action_fail\":                       {\"action_fail\", false},\n\t\t\t\"action_fail_on_inconclusive\":       {\"action_fail_on_inconclusive\", false},\n\t\t\t\"check_name\":                        {\"check_name\", false},\n\t\t\t\"check_run\":                         {\"check_run\", false},\n\t\t\t\"check_run_annotations\":             {\"check_run_annotations\", false},\n\t\t\t\"check_run_annotations_branch\":      {\"check_run_annotations_branch\", false},\n\t\t\t\"comment_mode\":                      {\"comment_mode\", false},\n\t\t\t\"comment_title\":                     {\"comment_title\", false},\n\t\t\t\"commit\":                            {\"commit\", false},\n\t\t\t\"compare_to_earlier_commit\":         {\"compare_to_earlier_commit\", false},\n\t\t\t\"deduplicate_classes_by_file_name\":  {\"deduplicate_classes_by_file_name\", false},\n\t\t\t\"event_file\":                        {\"event_file\", false},\n\t\t\t\"event_name\":                        {\"event_name\", false},\n\t\t\t\"fail_on\":                           {\"fail_on\", false},\n\t\t\t\"files\":                             {\"files\", false},\n\t\t\t\"github_retries\":                    {\"github_retries\", false},\n\t\t\t\"github_token\":                      {\"github_token\", false},\n\t\t\t\"github_token_actor\":                {\"github_token_actor\", false},\n\t\t\t\"ignore_runs\":                       {\"ignore_runs\", false},\n\t\t\t\"job_summary\":                       {\"job_summary\", false},\n\t\t\t\"json_file\":                         {\"json_file\", false},\n\t\t\t\"json_suite_details\":                {\"json_suite_details\", false},\n\t\t\t\"json_test_case_results\":            {\"json_test_case_results\", false},\n\t\t\t\"json_thousands_separator\":          {\"json_thousands_separator\", false},\n\t\t\t\"junit_files\":                       {\"junit_files\", false},\n\t\t\t\"large_files\":                       {\"large_files\", false},\n\t\t\t\"nunit_files\":                       {\"nunit_files\", false},\n\t\t\t\"pull_request_build\":                {\"pull_request_build\", false},\n\t\t\t\"report_individual_runs\":            {\"report_individual_runs\", false},\n\t\t\t\"report_suite_logs\":                 {\"report_suite_logs\", false},\n\t\t\t\"search_pull_requests\":              {\"search_pull_requests\", false},\n\t\t\t\"secondary_rate_limit_wait_seconds\": {\"secondary_rate_limit_wait_seconds\", false},\n\t\t\t\"seconds_between_github_reads\":      {\"seconds_between_github_reads\", false},\n\t\t\t\"seconds_between_github_writes\":     {\"seconds_between_github_writes\", false},\n\t\t\t\"test_changes_limit\":                {\"test_changes_limit\", false},\n\t\t\t\"test_file_prefix\":                  {\"test_file_prefix\", false},\n\t\t\t\"time_unit\":                         {\"time_unit\", false},\n\t\t\t\"trx_files\":                         {\"trx_files\", false},\n\t\t\t\"xunit_files\":                       {\"xunit_files\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"json\": {\"json\"},\n\t\t},\n\t},\n\t\"JamesIves/github-pages-deploy-action@v4\": {\n\t\tName: \"Deploy to GitHub Pages\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"branch\":           {\"branch\", false},\n\t\t\t\"clean\":            {\"clean\", false},\n\t\t\t\"clean-exclude\":    {\"clean-exclude\", false},\n\t\t\t\"commit-message\":   {\"commit-message\", false},\n\t\t\t\"dry-run\":          {\"dry-run\", false},\n\t\t\t\"folder\":           {\"folder\", true},\n\t\t\t\"force\":            {\"force\", false},\n\t\t\t\"git-config-email\": {\"git-config-email\", false},\n\t\t\t\"git-config-name\":  {\"git-config-name\", false},\n\t\t\t\"repository-name\":  {\"repository-name\", false},\n\t\t\t\"silent\":           {\"silent\", false},\n\t\t\t\"single-commit\":    {\"single-commit\", false},\n\t\t\t\"ssh-key\":          {\"ssh-key\", false},\n\t\t\t\"tag\":              {\"tag\", false},\n\t\t\t\"target-folder\":    {\"target-folder\", false},\n\t\t\t\"token\":            {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"deployment-status\": {\"deployment-status\"},\n\t\t},\n\t},\n\t\"ReactiveCircus/android-emulator-runner@v2\": {\n\t\tName: \"Android Emulator Runner\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"api-level\":                  {\"api-level\", true},\n\t\t\t\"arch\":                       {\"arch\", false},\n\t\t\t\"avd-name\":                   {\"avd-name\", false},\n\t\t\t\"channel\":                    {\"channel\", false},\n\t\t\t\"cmake\":                      {\"cmake\", false},\n\t\t\t\"cores\":                      {\"cores\", false},\n\t\t\t\"disable-animations\":         {\"disable-animations\", false},\n\t\t\t\"disable-linux-hw-accel\":     {\"disable-linux-hw-accel\", false},\n\t\t\t\"disable-spellchecker\":       {\"disable-spellchecker\", false},\n\t\t\t\"disk-size\":                  {\"disk-size\", false},\n\t\t\t\"emulator-boot-timeout\":      {\"emulator-boot-timeout\", false},\n\t\t\t\"emulator-build\":             {\"emulator-build\", false},\n\t\t\t\"emulator-options\":           {\"emulator-options\", false},\n\t\t\t\"emulator-port\":              {\"emulator-port\", false},\n\t\t\t\"enable-hw-keyboard\":         {\"enable-hw-keyboard\", false},\n\t\t\t\"force-avd-creation\":         {\"force-avd-creation\", false},\n\t\t\t\"heap-size\":                  {\"heap-size\", false},\n\t\t\t\"ndk\":                        {\"ndk\", false},\n\t\t\t\"pre-emulator-launch-script\": {\"pre-emulator-launch-script\", false},\n\t\t\t\"profile\":                    {\"profile\", false},\n\t\t\t\"ram-size\":                   {\"ram-size\", false},\n\t\t\t\"script\":                     {\"script\", true},\n\t\t\t\"sdcard-path-or-size\":        {\"sdcard-path-or-size\", false},\n\t\t\t\"target\":                     {\"target\", false},\n\t\t\t\"working-directory\":          {\"working-directory\", false},\n\t\t},\n\t},\n\t\"Swatinem/rust-cache@v2\": {\n\t\tName: \"Rust Cache\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"cache-all-crates\":  {\"cache-all-crates\", false},\n\t\t\t\"cache-bin\":         {\"cache-bin\", false},\n\t\t\t\"cache-directories\": {\"cache-directories\", false},\n\t\t\t\"cache-on-failure\":  {\"cache-on-failure\", false},\n\t\t\t\"cache-provider\":    {\"cache-provider\", false},\n\t\t\t\"cache-targets\":     {\"cache-targets\", false},\n\t\t\t\"env-vars\":          {\"env-vars\", false},\n\t\t\t\"key\":               {\"key\", false},\n\t\t\t\"lookup-only\":       {\"lookup-only\", false},\n\t\t\t\"prefix-key\":        {\"prefix-key\", false},\n\t\t\t\"save-if\":           {\"save-if\", false},\n\t\t\t\"shared-key\":        {\"shared-key\", false},\n\t\t\t\"workspaces\":        {\"workspaces\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\": {\"cache-hit\"},\n\t\t},\n\t},\n\t\"actions-cool/issues-helper@v3\": {\n\t\tName: \"Issues Helper\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"actions\":            {\"actions\", false},\n\t\t\t\"assign-command\":     {\"assign-command\", false},\n\t\t\t\"assignee-includes\":  {\"assignee-includes\", false},\n\t\t\t\"assignees\":          {\"assignees\", false},\n\t\t\t\"body\":               {\"body\", false},\n\t\t\t\"body-includes\":      {\"body-includes\", false},\n\t\t\t\"close-issue\":        {\"close-issue\", false},\n\t\t\t\"close-reason\":       {\"close-reason\", false},\n\t\t\t\"comment-auth\":       {\"comment-auth\", false},\n\t\t\t\"comment-id\":         {\"comment-id\", false},\n\t\t\t\"direction\":          {\"direction\", false},\n\t\t\t\"duplicate-command\":  {\"duplicate-command\", false},\n\t\t\t\"duplicate-labels\":   {\"duplicate-labels\", false},\n\t\t\t\"emoji\":              {\"emoji\", false},\n\t\t\t\"exclude-labels\":     {\"exclude-labels\", false},\n\t\t\t\"inactive-day\":       {\"inactive-day\", false},\n\t\t\t\"inactive-label\":     {\"inactive-label\", false},\n\t\t\t\"inactive-mode\":      {\"inactive-mode\", false},\n\t\t\t\"issue-assignee\":     {\"issue-assignee\", false},\n\t\t\t\"issue-creator\":      {\"issue-creator\", false},\n\t\t\t\"issue-emoji\":        {\"issue-emoji\", false},\n\t\t\t\"issue-mentioned\":    {\"issue-mentioned\", false},\n\t\t\t\"issue-number\":       {\"issue-number\", false},\n\t\t\t\"issue-state\":        {\"issue-state\", false},\n\t\t\t\"label-color\":        {\"label-color\", false},\n\t\t\t\"label-desc\":         {\"label-desc\", false},\n\t\t\t\"label-name\":         {\"label-name\", false},\n\t\t\t\"labels\":             {\"labels\", false},\n\t\t\t\"lock-reason\":        {\"lock-reason\", false},\n\t\t\t\"random-to\":          {\"random-to\", false},\n\t\t\t\"remove-labels\":      {\"remove-labels\", false},\n\t\t\t\"repo\":               {\"repo\", false},\n\t\t\t\"require-permission\": {\"require-permission\", false},\n\t\t\t\"state\":              {\"state\", false},\n\t\t\t\"title\":              {\"title\", false},\n\t\t\t\"title-excludes\":     {\"title-excludes\", false},\n\t\t\t\"title-includes\":     {\"title-includes\", false},\n\t\t\t\"token\":              {\"token\", false},\n\t\t\t\"update-mode\":        {\"update-mode\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"check-result\":    {\"check-result\"},\n\t\t\t\"comment-id\":      {\"comment-id\"},\n\t\t\t\"comments\":        {\"comments\"},\n\t\t\t\"issue-assignees\": {\"issue-assignees\"},\n\t\t\t\"issue-body\":      {\"issue-body\"},\n\t\t\t\"issue-labels\":    {\"issue-labels\"},\n\t\t\t\"issue-number\":    {\"issue-number\"},\n\t\t\t\"issue-state\":     {\"issue-state\"},\n\t\t\t\"issue-title\":     {\"issue-title\"},\n\t\t\t\"issues\":          {\"issues\"},\n\t\t},\n\t},\n\t\"actions/add-to-project@v1.0.1\": {\n\t\tName: \"Add To GitHub projects\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"github-token\":   {\"github-token\", true},\n\t\t\t\"label-operator\": {\"label-operator\", false},\n\t\t\t\"labeled\":        {\"labeled\", false},\n\t\t\t\"project-url\":    {\"project-url\", true},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"itemid\": {\"itemId\"},\n\t\t},\n\t},\n\t\"actions/attest-build-provenance@v1\": {\n\t\tName: \"Attest Build Provenance\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"github-token\":     {\"github-token\", false},\n\t\t\t\"push-to-registry\": {\"push-to-registry\", false},\n\t\t\t\"show-summary\":     {\"show-summary\", false},\n\t\t\t\"subject-digest\":   {\"subject-digest\", false},\n\t\t\t\"subject-name\":     {\"subject-name\", false},\n\t\t\t\"subject-path\":     {\"subject-path\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"bundle-path\": {\"bundle-path\"},\n\t\t},\n\t},\n\t\"actions/attest-build-provenance@v2\": {\n\t\tName: \"Attest Build Provenance\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"github-token\":     {\"github-token\", false},\n\t\t\t\"push-to-registry\": {\"push-to-registry\", false},\n\t\t\t\"show-summary\":     {\"show-summary\", false},\n\t\t\t\"subject-digest\":   {\"subject-digest\", false},\n\t\t\t\"subject-name\":     {\"subject-name\", false},\n\t\t\t\"subject-path\":     {\"subject-path\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"attestation-id\":  {\"attestation-id\"},\n\t\t\t\"attestation-url\": {\"attestation-url\"},\n\t\t\t\"bundle-path\":     {\"bundle-path\"},\n\t\t},\n\t},\n\t\"actions/cache/restore@v4\": {\n\t\tName: \"Restore Cache\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"enablecrossosarchive\": {\"enableCrossOsArchive\", false},\n\t\t\t\"fail-on-cache-miss\":   {\"fail-on-cache-miss\", false},\n\t\t\t\"key\":                  {\"key\", true},\n\t\t\t\"lookup-only\":          {\"lookup-only\", false},\n\t\t\t\"path\":                 {\"path\", true},\n\t\t\t\"restore-keys\":         {\"restore-keys\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\":         {\"cache-hit\"},\n\t\t\t\"cache-matched-key\": {\"cache-matched-key\"},\n\t\t\t\"cache-primary-key\": {\"cache-primary-key\"},\n\t\t},\n\t},\n\t\"actions/cache/save@v4\": {\n\t\tName: \"Save a cache\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"enablecrossosarchive\": {\"enableCrossOsArchive\", false},\n\t\t\t\"key\":                  {\"key\", true},\n\t\t\t\"path\":                 {\"path\", true},\n\t\t\t\"upload-chunk-size\":    {\"upload-chunk-size\", false},\n\t\t},\n\t},\n\t\"actions/cache@v4\": {\n\t\tName: \"Cache\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"enablecrossosarchive\": {\"enableCrossOsArchive\", false},\n\t\t\t\"fail-on-cache-miss\":   {\"fail-on-cache-miss\", false},\n\t\t\t\"key\":                  {\"key\", true},\n\t\t\t\"lookup-only\":          {\"lookup-only\", false},\n\t\t\t\"path\":                 {\"path\", true},\n\t\t\t\"restore-keys\":         {\"restore-keys\", false},\n\t\t\t\"save-always\":          {\"save-always\", false},\n\t\t\t\"upload-chunk-size\":    {\"upload-chunk-size\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\": {\"cache-hit\"},\n\t\t},\n\t},\n\t\"actions/checkout@v4\": {\n\t\tName: \"Checkout\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"clean\":                     {\"clean\", false},\n\t\t\t\"fetch-depth\":               {\"fetch-depth\", false},\n\t\t\t\"fetch-tags\":                {\"fetch-tags\", false},\n\t\t\t\"filter\":                    {\"filter\", false},\n\t\t\t\"github-server-url\":         {\"github-server-url\", false},\n\t\t\t\"lfs\":                       {\"lfs\", false},\n\t\t\t\"path\":                      {\"path\", false},\n\t\t\t\"persist-credentials\":       {\"persist-credentials\", false},\n\t\t\t\"ref\":                       {\"ref\", false},\n\t\t\t\"repository\":                {\"repository\", false},\n\t\t\t\"set-safe-directory\":        {\"set-safe-directory\", false},\n\t\t\t\"show-progress\":             {\"show-progress\", false},\n\t\t\t\"sparse-checkout\":           {\"sparse-checkout\", false},\n\t\t\t\"sparse-checkout-cone-mode\": {\"sparse-checkout-cone-mode\", false},\n\t\t\t\"ssh-key\":                   {\"ssh-key\", false},\n\t\t\t\"ssh-known-hosts\":           {\"ssh-known-hosts\", false},\n\t\t\t\"ssh-strict\":                {\"ssh-strict\", false},\n\t\t\t\"ssh-user\":                  {\"ssh-user\", false},\n\t\t\t\"submodules\":                {\"submodules\", false},\n\t\t\t\"token\":                     {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"commit\": {\"commit\"},\n\t\t\t\"ref\":    {\"ref\"},\n\t\t},\n\t},\n\t\"actions/configure-pages@v4\": {\n\t\tName: \"Configure GitHub Pages\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"enablement\":            {\"enablement\", false},\n\t\t\t\"generator_config_file\": {\"generator_config_file\", false},\n\t\t\t\"static_site_generator\": {\"static_site_generator\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"base_path\": {\"base_path\"},\n\t\t\t\"base_url\":  {\"base_url\"},\n\t\t\t\"host\":      {\"host\"},\n\t\t\t\"origin\":    {\"origin\"},\n\t\t},\n\t},\n\t\"actions/configure-pages@v5\": {\n\t\tName: \"Configure GitHub Pages\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"enablement\":            {\"enablement\", false},\n\t\t\t\"generator_config_file\": {\"generator_config_file\", false},\n\t\t\t\"static_site_generator\": {\"static_site_generator\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"base_path\": {\"base_path\"},\n\t\t\t\"base_url\":  {\"base_url\"},\n\t\t\t\"host\":      {\"host\"},\n\t\t\t\"origin\":    {\"origin\"},\n\t\t},\n\t},\n\t\"actions/delete-package-versions@v5\": {\n\t\tName: \"Delete Package Versions\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"delete-only-pre-release-versions\": {\"delete-only-pre-release-versions\", false},\n\t\t\t\"delete-only-untagged-versions\":    {\"delete-only-untagged-versions\", false},\n\t\t\t\"ignore-versions\":                  {\"ignore-versions\", false},\n\t\t\t\"min-versions-to-keep\":             {\"min-versions-to-keep\", false},\n\t\t\t\"num-old-versions-to-delete\":       {\"num-old-versions-to-delete\", false},\n\t\t\t\"owner\":                            {\"owner\", false},\n\t\t\t\"package-name\":                     {\"package-name\", true},\n\t\t\t\"package-type\":                     {\"package-type\", true},\n\t\t\t\"package-version-ids\":              {\"package-version-ids\", false},\n\t\t\t\"token\":                            {\"token\", false},\n\t\t},\n\t},\n\t\"actions/dependency-review-action@v4\": {\n\t\tName: \"Dependency Review\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow-dependencies-licenses\":        {\"allow-dependencies-licenses\", false},\n\t\t\t\"allow-ghsas\":                        {\"allow-ghsas\", false},\n\t\t\t\"allow-licenses\":                     {\"allow-licenses\", false},\n\t\t\t\"base-ref\":                           {\"base-ref\", false},\n\t\t\t\"comment-summary-in-pr\":              {\"comment-summary-in-pr\", false},\n\t\t\t\"config-file\":                        {\"config-file\", false},\n\t\t\t\"deny-groups\":                        {\"deny-groups\", false},\n\t\t\t\"deny-licenses\":                      {\"deny-licenses\", false},\n\t\t\t\"deny-packages\":                      {\"deny-packages\", false},\n\t\t\t\"external-repo-token\":                {\"external-repo-token\", false},\n\t\t\t\"fail-on-scopes\":                     {\"fail-on-scopes\", false},\n\t\t\t\"fail-on-severity\":                   {\"fail-on-severity\", false},\n\t\t\t\"head-ref\":                           {\"head-ref\", false},\n\t\t\t\"license-check\":                      {\"license-check\", false},\n\t\t\t\"repo-token\":                         {\"repo-token\", false},\n\t\t\t\"retry-on-snapshot-warnings\":         {\"retry-on-snapshot-warnings\", false},\n\t\t\t\"retry-on-snapshot-warnings-timeout\": {\"retry-on-snapshot-warnings-timeout\", false},\n\t\t\t\"show-openssf-scorecard\":             {\"show-openssf-scorecard\", false},\n\t\t\t\"vulnerability-check\":                {\"vulnerability-check\", false},\n\t\t\t\"warn-on-openssf-scorecard-level\":    {\"warn-on-openssf-scorecard-level\", false},\n\t\t\t\"warn-only\":                          {\"warn-only\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"comment-content\":         {\"comment-content\"},\n\t\t\t\"denied-changes\":          {\"denied-changes\"},\n\t\t\t\"dependency-changes\":      {\"dependency-changes\"},\n\t\t\t\"invalid-license-changes\": {\"invalid-license-changes\"},\n\t\t\t\"vulnerable-changes\":      {\"vulnerable-changes\"},\n\t\t},\n\t},\n\t\"actions/deploy-pages@v3\": {\n\t\tName: \"Deploy GitHub Pages site\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"artifact_name\":      {\"artifact_name\", false},\n\t\t\t\"error_count\":        {\"error_count\", false},\n\t\t\t\"preview\":            {\"preview\", false},\n\t\t\t\"reporting_interval\": {\"reporting_interval\", false},\n\t\t\t\"timeout\":            {\"timeout\", false},\n\t\t\t\"token\":              {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"page_url\": {\"page_url\"},\n\t\t},\n\t},\n\t\"actions/deploy-pages@v4\": {\n\t\tName: \"Deploy GitHub Pages site\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"artifact_name\":      {\"artifact_name\", false},\n\t\t\t\"error_count\":        {\"error_count\", false},\n\t\t\t\"preview\":            {\"preview\", false},\n\t\t\t\"reporting_interval\": {\"reporting_interval\", false},\n\t\t\t\"timeout\":            {\"timeout\", false},\n\t\t\t\"token\":              {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"page_url\": {\"page_url\"},\n\t\t},\n\t},\n\t\"actions/download-artifact@v3-node20\": {\n\t\tName: \"Download a Build Artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"name\": {\"name\", false},\n\t\t\t\"path\": {\"path\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"download-path\": {\"download-path\"},\n\t\t},\n\t},\n\t\"actions/download-artifact@v4\": {\n\t\tName: \"Download a Build Artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"github-token\":   {\"github-token\", false},\n\t\t\t\"merge-multiple\": {\"merge-multiple\", false},\n\t\t\t\"name\":           {\"name\", false},\n\t\t\t\"path\":           {\"path\", false},\n\t\t\t\"pattern\":        {\"pattern\", false},\n\t\t\t\"repository\":     {\"repository\", false},\n\t\t\t\"run-id\":         {\"run-id\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"download-path\": {\"download-path\"},\n\t\t},\n\t},\n\t\"actions/first-interaction@v1\": {\n\t\tName: \"First interaction\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"issue-message\": {\"issue-message\", false},\n\t\t\t\"pr-message\":    {\"pr-message\", false},\n\t\t\t\"repo-token\":    {\"repo-token\", true},\n\t\t},\n\t},\n\t\"actions/github-script@v7\": {\n\t\tName: \"GitHub Script\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"base-url\":                  {\"base-url\", false},\n\t\t\t\"debug\":                     {\"debug\", false},\n\t\t\t\"github-token\":              {\"github-token\", false},\n\t\t\t\"previews\":                  {\"previews\", false},\n\t\t\t\"result-encoding\":           {\"result-encoding\", false},\n\t\t\t\"retries\":                   {\"retries\", false},\n\t\t\t\"retry-exempt-status-codes\": {\"retry-exempt-status-codes\", false},\n\t\t\t\"script\":                    {\"script\", true},\n\t\t\t\"user-agent\":                {\"user-agent\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"result\": {\"result\"},\n\t\t},\n\t},\n\t\"actions/labeler@v5\": {\n\t\tName: \"Labeler\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"configuration-path\": {\"configuration-path\", false},\n\t\t\t\"dot\":                {\"dot\", false},\n\t\t\t\"pr-number\":          {\"pr-number\", false},\n\t\t\t\"repo-token\":         {\"repo-token\", false},\n\t\t\t\"sync-labels\":        {\"sync-labels\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"all-labels\": {\"all-labels\"},\n\t\t\t\"new-labels\": {\"new-labels\"},\n\t\t},\n\t},\n\t\"actions/setup-dotnet@v4\": {\n\t\tName: \"Setup .NET Core SDK\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"cache\":                 {\"cache\", false},\n\t\t\t\"cache-dependency-path\": {\"cache-dependency-path\", false},\n\t\t\t\"config-file\":           {\"config-file\", false},\n\t\t\t\"dotnet-quality\":        {\"dotnet-quality\", false},\n\t\t\t\"dotnet-version\":        {\"dotnet-version\", false},\n\t\t\t\"global-json-file\":      {\"global-json-file\", false},\n\t\t\t\"owner\":                 {\"owner\", false},\n\t\t\t\"source-url\":            {\"source-url\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\":      {\"cache-hit\"},\n\t\t\t\"dotnet-version\": {\"dotnet-version\"},\n\t\t},\n\t},\n\t\"actions/setup-go@v5\": {\n\t\tName: \"Setup Go environment\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"architecture\":          {\"architecture\", false},\n\t\t\t\"cache\":                 {\"cache\", false},\n\t\t\t\"cache-dependency-path\": {\"cache-dependency-path\", false},\n\t\t\t\"check-latest\":          {\"check-latest\", false},\n\t\t\t\"go-version\":            {\"go-version\", false},\n\t\t\t\"go-version-file\":       {\"go-version-file\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\":  {\"cache-hit\"},\n\t\t\t\"go-version\": {\"go-version\"},\n\t\t},\n\t},\n\t\"actions/setup-java@v4\": {\n\t\tName: \"Setup Java JDK\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"architecture\":          {\"architecture\", false},\n\t\t\t\"cache\":                 {\"cache\", false},\n\t\t\t\"cache-dependency-path\": {\"cache-dependency-path\", false},\n\t\t\t\"check-latest\":          {\"check-latest\", false},\n\t\t\t\"distribution\":          {\"distribution\", true},\n\t\t\t\"gpg-passphrase\":        {\"gpg-passphrase\", false},\n\t\t\t\"gpg-private-key\":       {\"gpg-private-key\", false},\n\t\t\t\"java-package\":          {\"java-package\", false},\n\t\t\t\"java-version\":          {\"java-version\", false},\n\t\t\t\"java-version-file\":     {\"java-version-file\", false},\n\t\t\t\"jdkfile\":               {\"jdkFile\", false},\n\t\t\t\"job-status\":            {\"job-status\", false},\n\t\t\t\"mvn-toolchain-id\":      {\"mvn-toolchain-id\", false},\n\t\t\t\"mvn-toolchain-vendor\":  {\"mvn-toolchain-vendor\", false},\n\t\t\t\"overwrite-settings\":    {\"overwrite-settings\", false},\n\t\t\t\"server-id\":             {\"server-id\", false},\n\t\t\t\"server-password\":       {\"server-password\", false},\n\t\t\t\"server-username\":       {\"server-username\", false},\n\t\t\t\"settings-path\":         {\"settings-path\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\":    {\"cache-hit\"},\n\t\t\t\"distribution\": {\"distribution\"},\n\t\t\t\"path\":         {\"path\"},\n\t\t\t\"version\":      {\"version\"},\n\t\t},\n\t},\n\t\"actions/setup-node@v4\": {\n\t\tName: \"Setup Node.js environment\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"always-auth\":           {\"always-auth\", false},\n\t\t\t\"architecture\":          {\"architecture\", false},\n\t\t\t\"cache\":                 {\"cache\", false},\n\t\t\t\"cache-dependency-path\": {\"cache-dependency-path\", false},\n\t\t\t\"check-latest\":          {\"check-latest\", false},\n\t\t\t\"node-version\":          {\"node-version\", false},\n\t\t\t\"node-version-file\":     {\"node-version-file\", false},\n\t\t\t\"registry-url\":          {\"registry-url\", false},\n\t\t\t\"scope\":                 {\"scope\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\":    {\"cache-hit\"},\n\t\t\t\"node-version\": {\"node-version\"},\n\t\t},\n\t},\n\t\"actions/setup-python@v5\": {\n\t\tName: \"Setup Python\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow-prereleases\":     {\"allow-prereleases\", false},\n\t\t\t\"architecture\":          {\"architecture\", false},\n\t\t\t\"cache\":                 {\"cache\", false},\n\t\t\t\"cache-dependency-path\": {\"cache-dependency-path\", false},\n\t\t\t\"check-latest\":          {\"check-latest\", false},\n\t\t\t\"python-version\":        {\"python-version\", false},\n\t\t\t\"python-version-file\":   {\"python-version-file\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t\t\"update-environment\":    {\"update-environment\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache-hit\":      {\"cache-hit\"},\n\t\t\t\"python-path\":    {\"python-path\"},\n\t\t\t\"python-version\": {\"python-version\"},\n\t\t},\n\t},\n\t\"actions/stale@v9\": {\n\t\tName: \"Close Stale Issues\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"any-of-issue-labels\":             {\"any-of-issue-labels\", false},\n\t\t\t\"any-of-labels\":                   {\"any-of-labels\", false},\n\t\t\t\"any-of-pr-labels\":                {\"any-of-pr-labels\", false},\n\t\t\t\"ascending\":                       {\"ascending\", false},\n\t\t\t\"close-issue-label\":               {\"close-issue-label\", false},\n\t\t\t\"close-issue-message\":             {\"close-issue-message\", false},\n\t\t\t\"close-issue-reason\":              {\"close-issue-reason\", false},\n\t\t\t\"close-pr-label\":                  {\"close-pr-label\", false},\n\t\t\t\"close-pr-message\":                {\"close-pr-message\", false},\n\t\t\t\"days-before-close\":               {\"days-before-close\", false},\n\t\t\t\"days-before-issue-close\":         {\"days-before-issue-close\", false},\n\t\t\t\"days-before-issue-stale\":         {\"days-before-issue-stale\", false},\n\t\t\t\"days-before-pr-close\":            {\"days-before-pr-close\", false},\n\t\t\t\"days-before-pr-stale\":            {\"days-before-pr-stale\", false},\n\t\t\t\"days-before-stale\":               {\"days-before-stale\", false},\n\t\t\t\"debug-only\":                      {\"debug-only\", false},\n\t\t\t\"delete-branch\":                   {\"delete-branch\", false},\n\t\t\t\"enable-statistics\":               {\"enable-statistics\", false},\n\t\t\t\"exempt-all-assignees\":            {\"exempt-all-assignees\", false},\n\t\t\t\"exempt-all-issue-assignees\":      {\"exempt-all-issue-assignees\", false},\n\t\t\t\"exempt-all-issue-milestones\":     {\"exempt-all-issue-milestones\", false},\n\t\t\t\"exempt-all-milestones\":           {\"exempt-all-milestones\", false},\n\t\t\t\"exempt-all-pr-assignees\":         {\"exempt-all-pr-assignees\", false},\n\t\t\t\"exempt-all-pr-milestones\":        {\"exempt-all-pr-milestones\", false},\n\t\t\t\"exempt-assignees\":                {\"exempt-assignees\", false},\n\t\t\t\"exempt-draft-pr\":                 {\"exempt-draft-pr\", false},\n\t\t\t\"exempt-issue-assignees\":          {\"exempt-issue-assignees\", false},\n\t\t\t\"exempt-issue-labels\":             {\"exempt-issue-labels\", false},\n\t\t\t\"exempt-issue-milestones\":         {\"exempt-issue-milestones\", false},\n\t\t\t\"exempt-milestones\":               {\"exempt-milestones\", false},\n\t\t\t\"exempt-pr-assignees\":             {\"exempt-pr-assignees\", false},\n\t\t\t\"exempt-pr-labels\":                {\"exempt-pr-labels\", false},\n\t\t\t\"exempt-pr-milestones\":            {\"exempt-pr-milestones\", false},\n\t\t\t\"ignore-issue-updates\":            {\"ignore-issue-updates\", false},\n\t\t\t\"ignore-pr-updates\":               {\"ignore-pr-updates\", false},\n\t\t\t\"ignore-updates\":                  {\"ignore-updates\", false},\n\t\t\t\"include-only-assigned\":           {\"include-only-assigned\", false},\n\t\t\t\"labels-to-add-when-unstale\":      {\"labels-to-add-when-unstale\", false},\n\t\t\t\"labels-to-remove-when-stale\":     {\"labels-to-remove-when-stale\", false},\n\t\t\t\"labels-to-remove-when-unstale\":   {\"labels-to-remove-when-unstale\", false},\n\t\t\t\"only-issue-labels\":               {\"only-issue-labels\", false},\n\t\t\t\"only-labels\":                     {\"only-labels\", false},\n\t\t\t\"only-pr-labels\":                  {\"only-pr-labels\", false},\n\t\t\t\"operations-per-run\":              {\"operations-per-run\", false},\n\t\t\t\"remove-issue-stale-when-updated\": {\"remove-issue-stale-when-updated\", false},\n\t\t\t\"remove-pr-stale-when-updated\":    {\"remove-pr-stale-when-updated\", false},\n\t\t\t\"remove-stale-when-updated\":       {\"remove-stale-when-updated\", false},\n\t\t\t\"repo-token\":                      {\"repo-token\", false},\n\t\t\t\"stale-issue-label\":               {\"stale-issue-label\", false},\n\t\t\t\"stale-issue-message\":             {\"stale-issue-message\", false},\n\t\t\t\"stale-pr-label\":                  {\"stale-pr-label\", false},\n\t\t\t\"stale-pr-message\":                {\"stale-pr-message\", false},\n\t\t\t\"start-date\":                      {\"start-date\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"closed-issues-prs\": {\"closed-issues-prs\"},\n\t\t\t\"staled-issues-prs\": {\"staled-issues-prs\"},\n\t\t},\n\t},\n\t\"actions/upload-artifact@v3-node20\": {\n\t\tName: \"Upload a Build Artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"if-no-files-found\":    {\"if-no-files-found\", false},\n\t\t\t\"include-hidden-files\": {\"include-hidden-files\", false},\n\t\t\t\"name\":                 {\"name\", false},\n\t\t\t\"path\":                 {\"path\", true},\n\t\t\t\"retention-days\":       {\"retention-days\", false},\n\t\t},\n\t},\n\t\"actions/upload-artifact@v4\": {\n\t\tName: \"Upload a Build Artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"compression-level\":    {\"compression-level\", false},\n\t\t\t\"if-no-files-found\":    {\"if-no-files-found\", false},\n\t\t\t\"include-hidden-files\": {\"include-hidden-files\", false},\n\t\t\t\"name\":                 {\"name\", false},\n\t\t\t\"overwrite\":            {\"overwrite\", false},\n\t\t\t\"path\":                 {\"path\", true},\n\t\t\t\"retention-days\":       {\"retention-days\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifact-digest\": {\"artifact-digest\"},\n\t\t\t\"artifact-id\":     {\"artifact-id\"},\n\t\t\t\"artifact-url\":    {\"artifact-url\"},\n\t\t},\n\t},\n\t\"actions/upload-pages-artifact@v1\": {\n\t\tName: \"Upload GitHub Pages artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"name\":           {\"name\", false},\n\t\t\t\"path\":           {\"path\", false},\n\t\t\t\"retention-days\": {\"retention-days\", false},\n\t\t},\n\t},\n\t\"actions/upload-pages-artifact@v2\": {\n\t\tName: \"Upload GitHub Pages artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"name\":           {\"name\", false},\n\t\t\t\"path\":           {\"path\", false},\n\t\t\t\"retention-days\": {\"retention-days\", false},\n\t\t},\n\t},\n\t\"actions/upload-pages-artifact@v3\": {\n\t\tName: \"Upload GitHub Pages artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"name\":           {\"name\", false},\n\t\t\t\"path\":           {\"path\", false},\n\t\t\t\"retention-days\": {\"retention-days\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifact_id\": {\"artifact_id\"},\n\t\t},\n\t},\n\t\"aws-actions/configure-aws-credentials@v4\": {\n\t\tName: \"\\\"Configure AWS Credentials\\\" Action for GitHub Actions\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"audience\":                      {\"audience\", false},\n\t\t\t\"aws-access-key-id\":             {\"aws-access-key-id\", false},\n\t\t\t\"aws-region\":                    {\"aws-region\", true},\n\t\t\t\"aws-secret-access-key\":         {\"aws-secret-access-key\", false},\n\t\t\t\"aws-session-token\":             {\"aws-session-token\", false},\n\t\t\t\"disable-retry\":                 {\"disable-retry\", false},\n\t\t\t\"http-proxy\":                    {\"http-proxy\", false},\n\t\t\t\"inline-session-policy\":         {\"inline-session-policy\", false},\n\t\t\t\"managed-session-policies\":      {\"managed-session-policies\", false},\n\t\t\t\"mask-aws-account-id\":           {\"mask-aws-account-id\", false},\n\t\t\t\"output-credentials\":            {\"output-credentials\", false},\n\t\t\t\"retry-max-attempts\":            {\"retry-max-attempts\", false},\n\t\t\t\"role-chaining\":                 {\"role-chaining\", false},\n\t\t\t\"role-duration-seconds\":         {\"role-duration-seconds\", false},\n\t\t\t\"role-external-id\":              {\"role-external-id\", false},\n\t\t\t\"role-session-name\":             {\"role-session-name\", false},\n\t\t\t\"role-skip-session-tagging\":     {\"role-skip-session-tagging\", false},\n\t\t\t\"role-to-assume\":                {\"role-to-assume\", false},\n\t\t\t\"special-characters-workaround\": {\"special-characters-workaround\", false},\n\t\t\t\"unset-current-credentials\":     {\"unset-current-credentials\", false},\n\t\t\t\"web-identity-token-file\":       {\"web-identity-token-file\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"aws-access-key-id\":     {\"aws-access-key-id\"},\n\t\t\t\"aws-account-id\":        {\"aws-account-id\"},\n\t\t\t\"aws-secret-access-key\": {\"aws-secret-access-key\"},\n\t\t\t\"aws-session-token\":     {\"aws-session-token\"},\n\t\t},\n\t},\n\t\"azure/aks-set-context@v4\": {\n\t\tName: \"Azure Kubernetes set context\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"admin\":          {\"admin\", false},\n\t\t\t\"cluster-name\":   {\"cluster-name\", true},\n\t\t\t\"public-fqdn\":    {\"public-fqdn\", false},\n\t\t\t\"resource-group\": {\"resource-group\", true},\n\t\t\t\"subscription\":   {\"subscription\", false},\n\t\t\t\"use-kubelogin\":  {\"use-kubelogin\", false},\n\t\t},\n\t},\n\t\"azure/login@v2\": {\n\t\tName: \"Azure Login\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow-no-subscriptions\": {\"allow-no-subscriptions\", false},\n\t\t\t\"audience\":               {\"audience\", false},\n\t\t\t\"auth-type\":              {\"auth-type\", false},\n\t\t\t\"client-id\":              {\"client-id\", false},\n\t\t\t\"creds\":                  {\"creds\", false},\n\t\t\t\"enable-azpssession\":     {\"enable-AzPSSession\", false},\n\t\t\t\"environment\":            {\"environment\", false},\n\t\t\t\"subscription-id\":        {\"subscription-id\", false},\n\t\t\t\"tenant-id\":              {\"tenant-id\", false},\n\t\t},\n\t},\n\t\"bahmutov/npm-install@v1\": {\n\t\tName: \"NPM or Yarn install with caching\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"cache-key-prefix\":  {\"cache-key-prefix\", false},\n\t\t\t\"install-command\":   {\"install-command\", false},\n\t\t\t\"uselockfile\":       {\"useLockFile\", false},\n\t\t\t\"userollingcache\":   {\"useRollingCache\", false},\n\t\t\t\"working-directory\": {\"working-directory\", false},\n\t\t},\n\t},\n\t\"codecov/codecov-action@v4\": {\n\t\tName: \"Codecov\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"codecov_yml_path\":           {\"codecov_yml_path\", false},\n\t\t\t\"commit_parent\":              {\"commit_parent\", false},\n\t\t\t\"directory\":                  {\"directory\", false},\n\t\t\t\"disable_file_fixes\":         {\"disable_file_fixes\", false},\n\t\t\t\"disable_safe_directory\":     {\"disable_safe_directory\", false},\n\t\t\t\"disable_search\":             {\"disable_search\", false},\n\t\t\t\"dry_run\":                    {\"dry_run\", false},\n\t\t\t\"env_vars\":                   {\"env_vars\", false},\n\t\t\t\"exclude\":                    {\"exclude\", false},\n\t\t\t\"fail_ci_if_error\":           {\"fail_ci_if_error\", false},\n\t\t\t\"file\":                       {\"file\", false},\n\t\t\t\"files\":                      {\"files\", false},\n\t\t\t\"flags\":                      {\"flags\", false},\n\t\t\t\"git_service\":                {\"git_service\", false},\n\t\t\t\"handle_no_reports_found\":    {\"handle_no_reports_found\", false},\n\t\t\t\"job_code\":                   {\"job_code\", false},\n\t\t\t\"name\":                       {\"name\", false},\n\t\t\t\"network_filter\":             {\"network_filter\", false},\n\t\t\t\"network_prefix\":             {\"network_prefix\", false},\n\t\t\t\"os\":                         {\"os\", false},\n\t\t\t\"override_branch\":            {\"override_branch\", false},\n\t\t\t\"override_build\":             {\"override_build\", false},\n\t\t\t\"override_build_url\":         {\"override_build_url\", false},\n\t\t\t\"override_commit\":            {\"override_commit\", false},\n\t\t\t\"override_pr\":                {\"override_pr\", false},\n\t\t\t\"plugin\":                     {\"plugin\", false},\n\t\t\t\"plugins\":                    {\"plugins\", false},\n\t\t\t\"report_code\":                {\"report_code\", false},\n\t\t\t\"root_dir\":                   {\"root_dir\", false},\n\t\t\t\"slug\":                       {\"slug\", false},\n\t\t\t\"token\":                      {\"token\", false},\n\t\t\t\"url\":                        {\"url\", false},\n\t\t\t\"use_legacy_upload_endpoint\": {\"use_legacy_upload_endpoint\", false},\n\t\t\t\"use_oidc\":                   {\"use_oidc\", false},\n\t\t\t\"verbose\":                    {\"verbose\", false},\n\t\t\t\"version\":                    {\"version\", false},\n\t\t\t\"working-directory\":          {\"working-directory\", false},\n\t\t},\n\t},\n\t\"codecov/codecov-action@v5\": {\n\t\tName: \"Codecov\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"binary\":                     {\"binary\", false},\n\t\t\t\"codecov_yml_path\":           {\"codecov_yml_path\", false},\n\t\t\t\"commit_parent\":              {\"commit_parent\", false},\n\t\t\t\"directory\":                  {\"directory\", false},\n\t\t\t\"disable_file_fixes\":         {\"disable_file_fixes\", false},\n\t\t\t\"disable_safe_directory\":     {\"disable_safe_directory\", false},\n\t\t\t\"disable_search\":             {\"disable_search\", false},\n\t\t\t\"dry_run\":                    {\"dry_run\", false},\n\t\t\t\"env_vars\":                   {\"env_vars\", false},\n\t\t\t\"exclude\":                    {\"exclude\", false},\n\t\t\t\"fail_ci_if_error\":           {\"fail_ci_if_error\", false},\n\t\t\t\"files\":                      {\"files\", false},\n\t\t\t\"flags\":                      {\"flags\", false},\n\t\t\t\"gcov_args\":                  {\"gcov_args\", false},\n\t\t\t\"gcov_executable\":            {\"gcov_executable\", false},\n\t\t\t\"gcov_ignore\":                {\"gcov_ignore\", false},\n\t\t\t\"gcov_include\":               {\"gcov_include\", false},\n\t\t\t\"git_service\":                {\"git_service\", false},\n\t\t\t\"handle_no_reports_found\":    {\"handle_no_reports_found\", false},\n\t\t\t\"job_code\":                   {\"job_code\", false},\n\t\t\t\"name\":                       {\"name\", false},\n\t\t\t\"network_filter\":             {\"network_filter\", false},\n\t\t\t\"network_prefix\":             {\"network_prefix\", false},\n\t\t\t\"os\":                         {\"os\", false},\n\t\t\t\"override_branch\":            {\"override_branch\", false},\n\t\t\t\"override_build\":             {\"override_build\", false},\n\t\t\t\"override_build_url\":         {\"override_build_url\", false},\n\t\t\t\"override_commit\":            {\"override_commit\", false},\n\t\t\t\"override_pr\":                {\"override_pr\", false},\n\t\t\t\"plugins\":                    {\"plugins\", false},\n\t\t\t\"report_code\":                {\"report_code\", false},\n\t\t\t\"report_type\":                {\"report_type\", false},\n\t\t\t\"root_dir\":                   {\"root_dir\", false},\n\t\t\t\"skip_validation\":            {\"skip_validation\", false},\n\t\t\t\"slug\":                       {\"slug\", false},\n\t\t\t\"swift_project\":              {\"swift_project\", false},\n\t\t\t\"token\":                      {\"token\", false},\n\t\t\t\"url\":                        {\"url\", false},\n\t\t\t\"use_legacy_upload_endpoint\": {\"use_legacy_upload_endpoint\", false},\n\t\t\t\"use_oidc\":                   {\"use_oidc\", false},\n\t\t\t\"verbose\":                    {\"verbose\", false},\n\t\t\t\"version\":                    {\"version\", false},\n\t\t\t\"working-directory\":          {\"working-directory\", false},\n\t\t},\n\t},\n\t\"dawidd6/action-download-artifact@v3\": {\n\t\tName: \"Download workflow artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow_forks\":          {\"allow_forks\", false},\n\t\t\t\"branch\":               {\"branch\", false},\n\t\t\t\"check_artifacts\":      {\"check_artifacts\", false},\n\t\t\t\"commit\":               {\"commit\", false},\n\t\t\t\"dry_run\":              {\"dry_run\", false},\n\t\t\t\"event\":                {\"event\", false},\n\t\t\t\"github_token\":         {\"github_token\", false},\n\t\t\t\"if_no_artifact_found\": {\"if_no_artifact_found\", false},\n\t\t\t\"name\":                 {\"name\", false},\n\t\t\t\"name_is_regexp\":       {\"name_is_regexp\", false},\n\t\t\t\"path\":                 {\"path\", false},\n\t\t\t\"pr\":                   {\"pr\", false},\n\t\t\t\"repo\":                 {\"repo\", false},\n\t\t\t\"run_id\":               {\"run_id\", false},\n\t\t\t\"run_number\":           {\"run_number\", false},\n\t\t\t\"search_artifacts\":     {\"search_artifacts\", false},\n\t\t\t\"skip_unpack\":          {\"skip_unpack\", false},\n\t\t\t\"workflow\":             {\"workflow\", false},\n\t\t\t\"workflow_conclusion\":  {\"workflow_conclusion\", false},\n\t\t\t\"workflow_search\":      {\"workflow_search\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifacts\":      {\"artifacts\"},\n\t\t\t\"dry_run\":        {\"dry_run\"},\n\t\t\t\"error_message\":  {\"error_message\"},\n\t\t\t\"found_artifact\": {\"found_artifact\"},\n\t\t},\n\t},\n\t\"dawidd6/action-download-artifact@v5\": {\n\t\tName: \"Download workflow artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow_forks\":          {\"allow_forks\", false},\n\t\t\t\"branch\":               {\"branch\", false},\n\t\t\t\"check_artifacts\":      {\"check_artifacts\", false},\n\t\t\t\"commit\":               {\"commit\", false},\n\t\t\t\"dry_run\":              {\"dry_run\", false},\n\t\t\t\"event\":                {\"event\", false},\n\t\t\t\"github_token\":         {\"github_token\", false},\n\t\t\t\"if_no_artifact_found\": {\"if_no_artifact_found\", false},\n\t\t\t\"name\":                 {\"name\", false},\n\t\t\t\"name_is_regexp\":       {\"name_is_regexp\", false},\n\t\t\t\"path\":                 {\"path\", false},\n\t\t\t\"pr\":                   {\"pr\", false},\n\t\t\t\"repo\":                 {\"repo\", false},\n\t\t\t\"run_id\":               {\"run_id\", false},\n\t\t\t\"run_number\":           {\"run_number\", false},\n\t\t\t\"search_artifacts\":     {\"search_artifacts\", false},\n\t\t\t\"skip_unpack\":          {\"skip_unpack\", false},\n\t\t\t\"workflow\":             {\"workflow\", false},\n\t\t\t\"workflow_conclusion\":  {\"workflow_conclusion\", false},\n\t\t\t\"workflow_search\":      {\"workflow_search\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifacts\":      {\"artifacts\"},\n\t\t\t\"dry_run\":        {\"dry_run\"},\n\t\t\t\"error_message\":  {\"error_message\"},\n\t\t\t\"found_artifact\": {\"found_artifact\"},\n\t\t},\n\t},\n\t\"dawidd6/action-download-artifact@v6\": {\n\t\tName: \"Download workflow artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow_forks\":          {\"allow_forks\", false},\n\t\t\t\"branch\":               {\"branch\", false},\n\t\t\t\"check_artifacts\":      {\"check_artifacts\", false},\n\t\t\t\"commit\":               {\"commit\", false},\n\t\t\t\"dry_run\":              {\"dry_run\", false},\n\t\t\t\"event\":                {\"event\", false},\n\t\t\t\"github_token\":         {\"github_token\", false},\n\t\t\t\"if_no_artifact_found\": {\"if_no_artifact_found\", false},\n\t\t\t\"name\":                 {\"name\", false},\n\t\t\t\"name_is_regexp\":       {\"name_is_regexp\", false},\n\t\t\t\"path\":                 {\"path\", false},\n\t\t\t\"pr\":                   {\"pr\", false},\n\t\t\t\"repo\":                 {\"repo\", false},\n\t\t\t\"run_id\":               {\"run_id\", false},\n\t\t\t\"run_number\":           {\"run_number\", false},\n\t\t\t\"search_artifacts\":     {\"search_artifacts\", false},\n\t\t\t\"skip_unpack\":          {\"skip_unpack\", false},\n\t\t\t\"workflow\":             {\"workflow\", false},\n\t\t\t\"workflow_conclusion\":  {\"workflow_conclusion\", false},\n\t\t\t\"workflow_search\":      {\"workflow_search\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifacts\":      {\"artifacts\"},\n\t\t\t\"dry_run\":        {\"dry_run\"},\n\t\t\t\"error_message\":  {\"error_message\"},\n\t\t\t\"found_artifact\": {\"found_artifact\"},\n\t\t},\n\t},\n\t\"dawidd6/action-download-artifact@v7\": {\n\t\tName: \"Download workflow artifact\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow_forks\":          {\"allow_forks\", false},\n\t\t\t\"branch\":               {\"branch\", false},\n\t\t\t\"check_artifacts\":      {\"check_artifacts\", false},\n\t\t\t\"commit\":               {\"commit\", false},\n\t\t\t\"dry_run\":              {\"dry_run\", false},\n\t\t\t\"event\":                {\"event\", false},\n\t\t\t\"github_token\":         {\"github_token\", false},\n\t\t\t\"if_no_artifact_found\": {\"if_no_artifact_found\", false},\n\t\t\t\"name\":                 {\"name\", false},\n\t\t\t\"name_is_regexp\":       {\"name_is_regexp\", false},\n\t\t\t\"path\":                 {\"path\", false},\n\t\t\t\"pr\":                   {\"pr\", false},\n\t\t\t\"repo\":                 {\"repo\", false},\n\t\t\t\"run_id\":               {\"run_id\", false},\n\t\t\t\"run_number\":           {\"run_number\", false},\n\t\t\t\"search_artifacts\":     {\"search_artifacts\", false},\n\t\t\t\"skip_unpack\":          {\"skip_unpack\", false},\n\t\t\t\"workflow\":             {\"workflow\", false},\n\t\t\t\"workflow_conclusion\":  {\"workflow_conclusion\", false},\n\t\t\t\"workflow_search\":      {\"workflow_search\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifacts\":      {\"artifacts\"},\n\t\t\t\"dry_run\":        {\"dry_run\"},\n\t\t\t\"error_message\":  {\"error_message\"},\n\t\t\t\"found_artifact\": {\"found_artifact\"},\n\t\t},\n\t},\n\t\"dawidd6/action-send-mail@v1\": {\n\t\tName: \"Send email\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"body\":           {\"body\", true},\n\t\t\t\"content_type\":   {\"content_type\", false},\n\t\t\t\"from\":           {\"from\", true},\n\t\t\t\"password\":       {\"password\", true},\n\t\t\t\"server_address\": {\"server_address\", true},\n\t\t\t\"server_port\":    {\"server_port\", true},\n\t\t\t\"subject\":        {\"subject\", true},\n\t\t\t\"to\":             {\"to\", true},\n\t\t\t\"username\":       {\"username\", true},\n\t\t},\n\t},\n\t\"dawidd6/action-send-mail@v3\": {\n\t\tName: \"Send email\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"attachments\":      {\"attachments\", false},\n\t\t\t\"bcc\":              {\"bcc\", false},\n\t\t\t\"body\":             {\"body\", false},\n\t\t\t\"cc\":               {\"cc\", false},\n\t\t\t\"connection_url\":   {\"connection_url\", false},\n\t\t\t\"convert_markdown\": {\"convert_markdown\", false},\n\t\t\t\"from\":             {\"from\", true},\n\t\t\t\"html_body\":        {\"html_body\", false},\n\t\t\t\"ignore_cert\":      {\"ignore_cert\", false},\n\t\t\t\"in_reply_to\":      {\"in_reply_to\", false},\n\t\t\t\"nodemailerdebug\":  {\"nodemailerdebug\", false},\n\t\t\t\"nodemailerlog\":    {\"nodemailerlog\", false},\n\t\t\t\"password\":         {\"password\", false},\n\t\t\t\"priority\":         {\"priority\", false},\n\t\t\t\"reply_to\":         {\"reply_to\", false},\n\t\t\t\"secure\":           {\"secure\", false},\n\t\t\t\"server_address\":   {\"server_address\", false},\n\t\t\t\"server_port\":      {\"server_port\", false},\n\t\t\t\"subject\":          {\"subject\", true},\n\t\t\t\"to\":               {\"to\", false},\n\t\t\t\"username\":         {\"username\", false},\n\t\t},\n\t},\n\t\"dawidd6/action-send-mail@v4\": {\n\t\tName: \"Send email\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"attachments\":      {\"attachments\", false},\n\t\t\t\"bcc\":              {\"bcc\", false},\n\t\t\t\"body\":             {\"body\", false},\n\t\t\t\"cc\":               {\"cc\", false},\n\t\t\t\"connection_url\":   {\"connection_url\", false},\n\t\t\t\"convert_markdown\": {\"convert_markdown\", false},\n\t\t\t\"from\":             {\"from\", true},\n\t\t\t\"html_body\":        {\"html_body\", false},\n\t\t\t\"ignore_cert\":      {\"ignore_cert\", false},\n\t\t\t\"in_reply_to\":      {\"in_reply_to\", false},\n\t\t\t\"nodemailerdebug\":  {\"nodemailerdebug\", false},\n\t\t\t\"nodemailerlog\":    {\"nodemailerlog\", false},\n\t\t\t\"password\":         {\"password\", false},\n\t\t\t\"priority\":         {\"priority\", false},\n\t\t\t\"reply_to\":         {\"reply_to\", false},\n\t\t\t\"secure\":           {\"secure\", false},\n\t\t\t\"server_address\":   {\"server_address\", false},\n\t\t\t\"server_port\":      {\"server_port\", false},\n\t\t\t\"subject\":          {\"subject\", true},\n\t\t\t\"to\":               {\"to\", false},\n\t\t\t\"username\":         {\"username\", false},\n\t\t},\n\t},\n\t\"dessant/lock-threads@v5\": {\n\t\tName: \"Lock Threads\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add-discussion-labels\":              {\"add-discussion-labels\", false},\n\t\t\t\"add-issue-labels\":                   {\"add-issue-labels\", false},\n\t\t\t\"add-pr-labels\":                      {\"add-pr-labels\", false},\n\t\t\t\"discussion-comment\":                 {\"discussion-comment\", false},\n\t\t\t\"discussion-inactive-days\":           {\"discussion-inactive-days\", false},\n\t\t\t\"exclude-any-discussion-labels\":      {\"exclude-any-discussion-labels\", false},\n\t\t\t\"exclude-any-issue-labels\":           {\"exclude-any-issue-labels\", false},\n\t\t\t\"exclude-any-pr-labels\":              {\"exclude-any-pr-labels\", false},\n\t\t\t\"exclude-discussion-closed-after\":    {\"exclude-discussion-closed-after\", false},\n\t\t\t\"exclude-discussion-closed-before\":   {\"exclude-discussion-closed-before\", false},\n\t\t\t\"exclude-discussion-closed-between\":  {\"exclude-discussion-closed-between\", false},\n\t\t\t\"exclude-discussion-created-after\":   {\"exclude-discussion-created-after\", false},\n\t\t\t\"exclude-discussion-created-before\":  {\"exclude-discussion-created-before\", false},\n\t\t\t\"exclude-discussion-created-between\": {\"exclude-discussion-created-between\", false},\n\t\t\t\"exclude-issue-closed-after\":         {\"exclude-issue-closed-after\", false},\n\t\t\t\"exclude-issue-closed-before\":        {\"exclude-issue-closed-before\", false},\n\t\t\t\"exclude-issue-closed-between\":       {\"exclude-issue-closed-between\", false},\n\t\t\t\"exclude-issue-created-after\":        {\"exclude-issue-created-after\", false},\n\t\t\t\"exclude-issue-created-before\":       {\"exclude-issue-created-before\", false},\n\t\t\t\"exclude-issue-created-between\":      {\"exclude-issue-created-between\", false},\n\t\t\t\"exclude-pr-closed-after\":            {\"exclude-pr-closed-after\", false},\n\t\t\t\"exclude-pr-closed-before\":           {\"exclude-pr-closed-before\", false},\n\t\t\t\"exclude-pr-closed-between\":          {\"exclude-pr-closed-between\", false},\n\t\t\t\"exclude-pr-created-after\":           {\"exclude-pr-created-after\", false},\n\t\t\t\"exclude-pr-created-before\":          {\"exclude-pr-created-before\", false},\n\t\t\t\"exclude-pr-created-between\":         {\"exclude-pr-created-between\", false},\n\t\t\t\"github-token\":                       {\"github-token\", false},\n\t\t\t\"include-all-discussion-labels\":      {\"include-all-discussion-labels\", false},\n\t\t\t\"include-all-issue-labels\":           {\"include-all-issue-labels\", false},\n\t\t\t\"include-all-pr-labels\":              {\"include-all-pr-labels\", false},\n\t\t\t\"include-any-discussion-labels\":      {\"include-any-discussion-labels\", false},\n\t\t\t\"include-any-issue-labels\":           {\"include-any-issue-labels\", false},\n\t\t\t\"include-any-pr-labels\":              {\"include-any-pr-labels\", false},\n\t\t\t\"issue-comment\":                      {\"issue-comment\", false},\n\t\t\t\"issue-inactive-days\":                {\"issue-inactive-days\", false},\n\t\t\t\"issue-lock-reason\":                  {\"issue-lock-reason\", false},\n\t\t\t\"log-output\":                         {\"log-output\", false},\n\t\t\t\"pr-comment\":                         {\"pr-comment\", false},\n\t\t\t\"pr-inactive-days\":                   {\"pr-inactive-days\", false},\n\t\t\t\"pr-lock-reason\":                     {\"pr-lock-reason\", false},\n\t\t\t\"process-only\":                       {\"process-only\", false},\n\t\t\t\"remove-discussion-labels\":           {\"remove-discussion-labels\", false},\n\t\t\t\"remove-issue-labels\":                {\"remove-issue-labels\", false},\n\t\t\t\"remove-pr-labels\":                   {\"remove-pr-labels\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"discussions\": {\"discussions\"},\n\t\t\t\"issues\":      {\"issues\"},\n\t\t\t\"prs\":         {\"prs\"},\n\t\t},\n\t},\n\t\"docker/build-push-action@v1\": {\n\t\tName: \"Build and push Docker images\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add_git_labels\": {\"add_git_labels\", false},\n\t\t\t\"always_pull\":    {\"always_pull\", false},\n\t\t\t\"build_args\":     {\"build_args\", false},\n\t\t\t\"cache_froms\":    {\"cache_froms\", false},\n\t\t\t\"dockerfile\":     {\"dockerfile\", false},\n\t\t\t\"labels\":         {\"labels\", false},\n\t\t\t\"password\":       {\"password\", false},\n\t\t\t\"path\":           {\"path\", false},\n\t\t\t\"push\":           {\"push\", false},\n\t\t\t\"registry\":       {\"registry\", false},\n\t\t\t\"repository\":     {\"repository\", true},\n\t\t\t\"tag_with_ref\":   {\"tag_with_ref\", false},\n\t\t\t\"tag_with_sha\":   {\"tag_with_sha\", false},\n\t\t\t\"tags\":           {\"tags\", false},\n\t\t\t\"target\":         {\"target\", false},\n\t\t\t\"username\":       {\"username\", false},\n\t\t},\n\t},\n\t\"docker/build-push-action@v5\": {\n\t\tName: \"Build and push Docker images\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add-hosts\":        {\"add-hosts\", false},\n\t\t\t\"allow\":            {\"allow\", false},\n\t\t\t\"annotations\":      {\"annotations\", false},\n\t\t\t\"attests\":          {\"attests\", false},\n\t\t\t\"build-args\":       {\"build-args\", false},\n\t\t\t\"build-contexts\":   {\"build-contexts\", false},\n\t\t\t\"builder\":          {\"builder\", false},\n\t\t\t\"cache-from\":       {\"cache-from\", false},\n\t\t\t\"cache-to\":         {\"cache-to\", false},\n\t\t\t\"cgroup-parent\":    {\"cgroup-parent\", false},\n\t\t\t\"context\":          {\"context\", false},\n\t\t\t\"file\":             {\"file\", false},\n\t\t\t\"github-token\":     {\"github-token\", false},\n\t\t\t\"labels\":           {\"labels\", false},\n\t\t\t\"load\":             {\"load\", false},\n\t\t\t\"network\":          {\"network\", false},\n\t\t\t\"no-cache\":         {\"no-cache\", false},\n\t\t\t\"no-cache-filters\": {\"no-cache-filters\", false},\n\t\t\t\"outputs\":          {\"outputs\", false},\n\t\t\t\"platforms\":        {\"platforms\", false},\n\t\t\t\"provenance\":       {\"provenance\", false},\n\t\t\t\"pull\":             {\"pull\", false},\n\t\t\t\"push\":             {\"push\", false},\n\t\t\t\"sbom\":             {\"sbom\", false},\n\t\t\t\"secret-envs\":      {\"secret-envs\", false},\n\t\t\t\"secret-files\":     {\"secret-files\", false},\n\t\t\t\"secrets\":          {\"secrets\", false},\n\t\t\t\"shm-size\":         {\"shm-size\", false},\n\t\t\t\"ssh\":              {\"ssh\", false},\n\t\t\t\"tags\":             {\"tags\", false},\n\t\t\t\"target\":           {\"target\", false},\n\t\t\t\"ulimit\":           {\"ulimit\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"digest\":   {\"digest\"},\n\t\t\t\"imageid\":  {\"imageid\"},\n\t\t\t\"metadata\": {\"metadata\"},\n\t\t},\n\t},\n\t\"docker/build-push-action@v6\": {\n\t\tName: \"Build and push Docker images\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add-hosts\":        {\"add-hosts\", false},\n\t\t\t\"allow\":            {\"allow\", false},\n\t\t\t\"annotations\":      {\"annotations\", false},\n\t\t\t\"attests\":          {\"attests\", false},\n\t\t\t\"build-args\":       {\"build-args\", false},\n\t\t\t\"build-contexts\":   {\"build-contexts\", false},\n\t\t\t\"builder\":          {\"builder\", false},\n\t\t\t\"cache-from\":       {\"cache-from\", false},\n\t\t\t\"cache-to\":         {\"cache-to\", false},\n\t\t\t\"call\":             {\"call\", false},\n\t\t\t\"cgroup-parent\":    {\"cgroup-parent\", false},\n\t\t\t\"context\":          {\"context\", false},\n\t\t\t\"file\":             {\"file\", false},\n\t\t\t\"github-token\":     {\"github-token\", false},\n\t\t\t\"labels\":           {\"labels\", false},\n\t\t\t\"load\":             {\"load\", false},\n\t\t\t\"network\":          {\"network\", false},\n\t\t\t\"no-cache\":         {\"no-cache\", false},\n\t\t\t\"no-cache-filters\": {\"no-cache-filters\", false},\n\t\t\t\"outputs\":          {\"outputs\", false},\n\t\t\t\"platforms\":        {\"platforms\", false},\n\t\t\t\"provenance\":       {\"provenance\", false},\n\t\t\t\"pull\":             {\"pull\", false},\n\t\t\t\"push\":             {\"push\", false},\n\t\t\t\"sbom\":             {\"sbom\", false},\n\t\t\t\"secret-envs\":      {\"secret-envs\", false},\n\t\t\t\"secret-files\":     {\"secret-files\", false},\n\t\t\t\"secrets\":          {\"secrets\", false},\n\t\t\t\"shm-size\":         {\"shm-size\", false},\n\t\t\t\"ssh\":              {\"ssh\", false},\n\t\t\t\"tags\":             {\"tags\", false},\n\t\t\t\"target\":           {\"target\", false},\n\t\t\t\"ulimit\":           {\"ulimit\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"digest\":   {\"digest\"},\n\t\t\t\"imageid\":  {\"imageid\"},\n\t\t\t\"metadata\": {\"metadata\"},\n\t\t},\n\t},\n\t\"docker/login-action@v3\": {\n\t\tName: \"Docker Login\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"ecr\":      {\"ecr\", false},\n\t\t\t\"logout\":   {\"logout\", false},\n\t\t\t\"password\": {\"password\", false},\n\t\t\t\"registry\": {\"registry\", false},\n\t\t\t\"username\": {\"username\", false},\n\t\t},\n\t},\n\t\"docker/metadata-action@v5\": {\n\t\tName: \"Docker Metadata action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"annotations\":     {\"annotations\", false},\n\t\t\t\"bake-target\":     {\"bake-target\", false},\n\t\t\t\"context\":         {\"context\", false},\n\t\t\t\"flavor\":          {\"flavor\", false},\n\t\t\t\"github-token\":    {\"github-token\", false},\n\t\t\t\"images\":          {\"images\", false},\n\t\t\t\"labels\":          {\"labels\", false},\n\t\t\t\"sep-annotations\": {\"sep-annotations\", false},\n\t\t\t\"sep-labels\":      {\"sep-labels\", false},\n\t\t\t\"sep-tags\":        {\"sep-tags\", false},\n\t\t\t\"tags\":            {\"tags\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"annotations\":           {\"annotations\"},\n\t\t\t\"bake-file\":             {\"bake-file\"},\n\t\t\t\"bake-file-annotations\": {\"bake-file-annotations\"},\n\t\t\t\"bake-file-labels\":      {\"bake-file-labels\"},\n\t\t\t\"bake-file-tags\":        {\"bake-file-tags\"},\n\t\t\t\"json\":                  {\"json\"},\n\t\t\t\"labels\":                {\"labels\"},\n\t\t\t\"tags\":                  {\"tags\"},\n\t\t\t\"version\":               {\"version\"},\n\t\t},\n\t},\n\t\"docker/setup-buildx-action@v3\": {\n\t\tName: \"Docker Setup Buildx\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"append\":                  {\"append\", false},\n\t\t\t\"buildkitd-config\":        {\"buildkitd-config\", false},\n\t\t\t\"buildkitd-config-inline\": {\"buildkitd-config-inline\", false},\n\t\t\t\"buildkitd-flags\":         {\"buildkitd-flags\", false},\n\t\t\t\"cache-binary\":            {\"cache-binary\", false},\n\t\t\t\"cleanup\":                 {\"cleanup\", false},\n\t\t\t\"config\":                  {\"config\", false},\n\t\t\t\"config-inline\":           {\"config-inline\", false},\n\t\t\t\"driver\":                  {\"driver\", false},\n\t\t\t\"driver-opts\":             {\"driver-opts\", false},\n\t\t\t\"endpoint\":                {\"endpoint\", false},\n\t\t\t\"install\":                 {\"install\", false},\n\t\t\t\"platforms\":               {\"platforms\", false},\n\t\t\t\"use\":                     {\"use\", false},\n\t\t\t\"version\":                 {\"version\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"driver\":    {\"driver\"},\n\t\t\t\"endpoint\":  {\"endpoint\"},\n\t\t\t\"flags\":     {\"flags\"},\n\t\t\t\"name\":      {\"name\"},\n\t\t\t\"nodes\":     {\"nodes\"},\n\t\t\t\"platforms\": {\"platforms\"},\n\t\t\t\"status\":    {\"status\"},\n\t\t},\n\t},\n\t\"docker/setup-qemu-action@v3\": {\n\t\tName: \"Docker Setup QEMU\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"image\":     {\"image\", false},\n\t\t\t\"platforms\": {\"platforms\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"platforms\": {\"platforms\"},\n\t\t},\n\t},\n\t\"dorny/paths-filter@v3\": {\n\t\tName: \"Paths Changes Filter\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"base\":                 {\"base\", false},\n\t\t\t\"filters\":              {\"filters\", true},\n\t\t\t\"initial-fetch-depth\":  {\"initial-fetch-depth\", false},\n\t\t\t\"list-files\":           {\"list-files\", false},\n\t\t\t\"predicate-quantifier\": {\"predicate-quantifier\", false},\n\t\t\t\"ref\":                  {\"ref\", false},\n\t\t\t\"token\":                {\"token\", false},\n\t\t\t\"working-directory\":    {\"working-directory\", false},\n\t\t},\n\t\tSkipOutputs: true,\n\t},\n\t\"dtolnay/rust-toolchain@beta\": {\n\t\tName: \"rustup toolchain install\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"components\": {\"components\", false},\n\t\t\t\"target\":     {\"target\", false},\n\t\t\t\"targets\":    {\"targets\", false},\n\t\t\t\"toolchain\":  {\"toolchain\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cachekey\": {\"cachekey\"},\n\t\t\t\"name\":     {\"name\"},\n\t\t},\n\t},\n\t\"dtolnay/rust-toolchain@nightly\": {\n\t\tName: \"rustup toolchain install\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"components\": {\"components\", false},\n\t\t\t\"target\":     {\"target\", false},\n\t\t\t\"targets\":    {\"targets\", false},\n\t\t\t\"toolchain\":  {\"toolchain\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cachekey\": {\"cachekey\"},\n\t\t\t\"name\":     {\"name\"},\n\t\t},\n\t},\n\t\"dtolnay/rust-toolchain@stable\": {\n\t\tName: \"rustup toolchain install\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"components\": {\"components\", false},\n\t\t\t\"target\":     {\"target\", false},\n\t\t\t\"targets\":    {\"targets\", false},\n\t\t\t\"toolchain\":  {\"toolchain\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cachekey\": {\"cachekey\"},\n\t\t\t\"name\":     {\"name\"},\n\t\t},\n\t},\n\t\"erlef/setup-beam@v1\": {\n\t\tName: \"setup-beam\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"disable_problem_matchers\": {\"disable_problem_matchers\", false},\n\t\t\t\"elixir-version\":           {\"elixir-version\", false},\n\t\t\t\"github-token\":             {\"github-token\", false},\n\t\t\t\"gleam-version\":            {\"gleam-version\", false},\n\t\t\t\"hexpm-mirrors\":            {\"hexpm-mirrors\", false},\n\t\t\t\"install-hex\":              {\"install-hex\", false},\n\t\t\t\"install-rebar\":            {\"install-rebar\", false},\n\t\t\t\"otp-version\":              {\"otp-version\", false},\n\t\t\t\"rebar3-version\":           {\"rebar3-version\", false},\n\t\t\t\"version-file\":             {\"version-file\", false},\n\t\t\t\"version-type\":             {\"version-type\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"elixir-version\":     {\"elixir-version\"},\n\t\t\t\"gleam-version\":      {\"gleam-version\"},\n\t\t\t\"otp-version\":        {\"otp-version\"},\n\t\t\t\"rebar3-version\":     {\"rebar3-version\"},\n\t\t\t\"setup-beam-version\": {\"setup-beam-version\"},\n\t\t},\n\t},\n\t\"game-ci/unity-builder@v4\": {\n\t\tName: \"Unity - Builder\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allowdirtybuild\":               {\"allowDirtyBuild\", false},\n\t\t\t\"androidexporttype\":             {\"androidExportType\", false},\n\t\t\t\"androidkeyaliasname\":           {\"androidKeyaliasName\", false},\n\t\t\t\"androidkeyaliaspass\":           {\"androidKeyaliasPass\", false},\n\t\t\t\"androidkeystorebase64\":         {\"androidKeystoreBase64\", false},\n\t\t\t\"androidkeystorename\":           {\"androidKeystoreName\", false},\n\t\t\t\"androidkeystorepass\":           {\"androidKeystorePass\", false},\n\t\t\t\"androidsymboltype\":             {\"androidSymbolType\", false},\n\t\t\t\"androidtargetsdkversion\":       {\"androidTargetSdkVersion\", false},\n\t\t\t\"androidversioncode\":            {\"androidVersionCode\", false},\n\t\t\t\"awsstackname\":                  {\"awsStackName\", false},\n\t\t\t\"buildmethod\":                   {\"buildMethod\", false},\n\t\t\t\"buildname\":                     {\"buildName\", false},\n\t\t\t\"buildspath\":                    {\"buildsPath\", false},\n\t\t\t\"cachekey\":                      {\"cacheKey\", false},\n\t\t\t\"cacheunityinstallationonmac\":   {\"cacheUnityInstallationOnMac\", false},\n\t\t\t\"chownfilesto\":                  {\"chownFilesTo\", false},\n\t\t\t\"containercpu\":                  {\"containerCpu\", false},\n\t\t\t\"containerhookfiles\":            {\"containerHookFiles\", false},\n\t\t\t\"containermemory\":               {\"containerMemory\", false},\n\t\t\t\"containerregistryimageversion\": {\"containerRegistryImageVersion\", false},\n\t\t\t\"containerregistryrepository\":   {\"containerRegistryRepository\", false},\n\t\t\t\"customcommandhooks\":            {\"customCommandHooks\", false},\n\t\t\t\"customhookfiles\":               {\"customHookFiles\", false},\n\t\t\t\"customimage\":                   {\"customImage\", false},\n\t\t\t\"customjob\":                     {\"customJob\", false},\n\t\t\t\"customparameters\":              {\"customParameters\", false},\n\t\t\t\"dockercpulimit\":                {\"dockerCpuLimit\", false},\n\t\t\t\"dockerisolationmode\":           {\"dockerIsolationMode\", false},\n\t\t\t\"dockermemorylimit\":             {\"dockerMemoryLimit\", false},\n\t\t\t\"dockerworkspacepath\":           {\"dockerWorkspacePath\", false},\n\t\t\t\"enablegpu\":                     {\"enableGpu\", false},\n\t\t\t\"githubowner\":                   {\"githubOwner\", false},\n\t\t\t\"gitprivatetoken\":               {\"gitPrivateToken\", false},\n\t\t\t\"kubeconfig\":                    {\"kubeConfig\", false},\n\t\t\t\"kubestorageclass\":              {\"kubeStorageClass\", false},\n\t\t\t\"kubevolume\":                    {\"kubeVolume\", false},\n\t\t\t\"kubevolumesize\":                {\"kubeVolumeSize\", false},\n\t\t\t\"manualexit\":                    {\"manualExit\", false},\n\t\t\t\"postbuildsteps\":                {\"postBuildSteps\", false},\n\t\t\t\"prebuildsteps\":                 {\"preBuildSteps\", false},\n\t\t\t\"projectpath\":                   {\"projectPath\", false},\n\t\t\t\"providerstrategy\":              {\"providerStrategy\", false},\n\t\t\t\"readinputfromoverridelist\":     {\"readInputFromOverrideList\", false},\n\t\t\t\"readinputoverridecommand\":      {\"readInputOverrideCommand\", false},\n\t\t\t\"runashostuser\":                 {\"runAsHostUser\", false},\n\t\t\t\"skipactivation\":                {\"skipActivation\", false},\n\t\t\t\"sshagent\":                      {\"sshAgent\", false},\n\t\t\t\"sshpublickeysdirectorypath\":    {\"sshPublicKeysDirectoryPath\", false},\n\t\t\t\"targetplatform\":                {\"targetPlatform\", false},\n\t\t\t\"unityhubversiononmac\":          {\"unityHubVersionOnMac\", false},\n\t\t\t\"unitylicensingserver\":          {\"unityLicensingServer\", false},\n\t\t\t\"unityversion\":                  {\"unityVersion\", false},\n\t\t\t\"version\":                       {\"version\", false},\n\t\t\t\"versioning\":                    {\"versioning\", false},\n\t\t\t\"watchtoend\":                    {\"watchToEnd\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"androidversioncode\": {\"androidVersionCode\"},\n\t\t\t\"buildversion\":       {\"buildVersion\"},\n\t\t\t\"engineexitcode\":     {\"engineExitCode\"},\n\t\t\t\"volume\":             {\"volume\"},\n\t\t},\n\t},\n\t\"github/codeql-action/analyze@v3\": {\n\t\tName: \"CodeQL: Finish\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add-snippets\":        {\"add-snippets\", false},\n\t\t\t\"category\":            {\"category\", false},\n\t\t\t\"check_name\":          {\"check_name\", false},\n\t\t\t\"checkout_path\":       {\"checkout_path\", false},\n\t\t\t\"cleanup-level\":       {\"cleanup-level\", false},\n\t\t\t\"expect-error\":        {\"expect-error\", false},\n\t\t\t\"matrix\":              {\"matrix\", false},\n\t\t\t\"output\":              {\"output\", false},\n\t\t\t\"ram\":                 {\"ram\", false},\n\t\t\t\"ref\":                 {\"ref\", false},\n\t\t\t\"sha\":                 {\"sha\", false},\n\t\t\t\"skip-queries\":        {\"skip-queries\", false},\n\t\t\t\"threads\":             {\"threads\", false},\n\t\t\t\"token\":               {\"token\", false},\n\t\t\t\"upload\":              {\"upload\", false},\n\t\t\t\"upload-database\":     {\"upload-database\", false},\n\t\t\t\"wait-for-processing\": {\"wait-for-processing\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"db-locations\": {\"db-locations\"},\n\t\t\t\"sarif-id\":     {\"sarif-id\"},\n\t\t\t\"sarif-output\": {\"sarif-output\"},\n\t\t},\n\t},\n\t\"github/codeql-action/autobuild@v3\": {\n\t\tName: \"CodeQL: Autobuild\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"matrix\":            {\"matrix\", false},\n\t\t\t\"token\":             {\"token\", false},\n\t\t\t\"working-directory\": {\"working-directory\", false},\n\t\t},\n\t},\n\t\"github/codeql-action/init@v3\": {\n\t\tName: \"CodeQL: Init\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"build-mode\":                {\"build-mode\", false},\n\t\t\t\"config\":                    {\"config\", false},\n\t\t\t\"config-file\":               {\"config-file\", false},\n\t\t\t\"db-location\":               {\"db-location\", false},\n\t\t\t\"debug\":                     {\"debug\", false},\n\t\t\t\"debug-artifact-name\":       {\"debug-artifact-name\", false},\n\t\t\t\"debug-database-name\":       {\"debug-database-name\", false},\n\t\t\t\"dependency-caching\":        {\"dependency-caching\", false},\n\t\t\t\"external-repository-token\": {\"external-repository-token\", false},\n\t\t\t\"languages\":                 {\"languages\", false},\n\t\t\t\"matrix\":                    {\"matrix\", false},\n\t\t\t\"packs\":                     {\"packs\", false},\n\t\t\t\"queries\":                   {\"queries\", false},\n\t\t\t\"ram\":                       {\"ram\", false},\n\t\t\t\"registries\":                {\"registries\", false},\n\t\t\t\"setup-python-dependencies\": {\"setup-python-dependencies\", false},\n\t\t\t\"source-root\":               {\"source-root\", false},\n\t\t\t\"threads\":                   {\"threads\", false},\n\t\t\t\"token\":                     {\"token\", false},\n\t\t\t\"tools\":                     {\"tools\", false},\n\t\t\t\"trap-caching\":              {\"trap-caching\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"codeql-path\":    {\"codeql-path\"},\n\t\t\t\"codeql-version\": {\"codeql-version\"},\n\t\t},\n\t},\n\t\"github/super-linter@v3\": {\n\t\tName: \"Super-Linter\",\n\t},\n\t\"github/super-linter@v4\": {\n\t\tName: \"Super-Linter\",\n\t},\n\t\"github/super-linter@v5\": {\n\t\tName: \"Super-Linter\",\n\t},\n\t\"github/super-linter@v6\": {\n\t\tName: \"Super-Linter\",\n\t},\n\t\"github/super-linter@v7\": {\n\t\tName: \"Super-Linter\",\n\t},\n\t\"golangci/golangci-lint-action@v4\": {\n\t\tName: \"Run golangci-lint\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"args\":              {\"args\", false},\n\t\t\t\"github-token\":      {\"github-token\", false},\n\t\t\t\"install-mode\":      {\"install-mode\", false},\n\t\t\t\"only-new-issues\":   {\"only-new-issues\", false},\n\t\t\t\"skip-build-cache\":  {\"skip-build-cache\", false},\n\t\t\t\"skip-cache\":        {\"skip-cache\", false},\n\t\t\t\"skip-pkg-cache\":    {\"skip-pkg-cache\", false},\n\t\t\t\"version\":           {\"version\", false},\n\t\t\t\"working-directory\": {\"working-directory\", false},\n\t\t},\n\t},\n\t\"golangci/golangci-lint-action@v5\": {\n\t\tName: \"Golangci-lint\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"annotations\":                 {\"annotations\", false},\n\t\t\t\"args\":                        {\"args\", false},\n\t\t\t\"cache-invalidation-interval\": {\"cache-invalidation-interval\", false},\n\t\t\t\"github-token\":                {\"github-token\", false},\n\t\t\t\"install-mode\":                {\"install-mode\", false},\n\t\t\t\"only-new-issues\":             {\"only-new-issues\", false},\n\t\t\t\"skip-cache\":                  {\"skip-cache\", false},\n\t\t\t\"skip-save-cache\":             {\"skip-save-cache\", false},\n\t\t\t\"version\":                     {\"version\", false},\n\t\t\t\"working-directory\":           {\"working-directory\", false},\n\t\t},\n\t},\n\t\"golangci/golangci-lint-action@v6\": {\n\t\tName: \"Golangci-lint\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"args\":                        {\"args\", false},\n\t\t\t\"cache-invalidation-interval\": {\"cache-invalidation-interval\", false},\n\t\t\t\"github-token\":                {\"github-token\", false},\n\t\t\t\"install-mode\":                {\"install-mode\", false},\n\t\t\t\"only-new-issues\":             {\"only-new-issues\", false},\n\t\t\t\"problem-matchers\":            {\"problem-matchers\", false},\n\t\t\t\"skip-cache\":                  {\"skip-cache\", false},\n\t\t\t\"skip-save-cache\":             {\"skip-save-cache\", false},\n\t\t\t\"version\":                     {\"version\", false},\n\t\t\t\"working-directory\":           {\"working-directory\", false},\n\t\t},\n\t},\n\t\"google-github-actions/auth@v2\": {\n\t\tName: \"Authenticate to Google Cloud\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"access_token_lifetime\":        {\"access_token_lifetime\", false},\n\t\t\t\"access_token_scopes\":          {\"access_token_scopes\", false},\n\t\t\t\"access_token_subject\":         {\"access_token_subject\", false},\n\t\t\t\"audience\":                     {\"audience\", false},\n\t\t\t\"backoff\":                      {\"backoff\", false},\n\t\t\t\"backoff_limit\":                {\"backoff_limit\", false},\n\t\t\t\"cleanup_credentials\":          {\"cleanup_credentials\", false},\n\t\t\t\"create_credentials_file\":      {\"create_credentials_file\", false},\n\t\t\t\"credentials_json\":             {\"credentials_json\", false},\n\t\t\t\"delegates\":                    {\"delegates\", false},\n\t\t\t\"export_environment_variables\": {\"export_environment_variables\", false},\n\t\t\t\"id_token_audience\":            {\"id_token_audience\", false},\n\t\t\t\"id_token_include_email\":       {\"id_token_include_email\", false},\n\t\t\t\"project_id\":                   {\"project_id\", false},\n\t\t\t\"request_reason\":               {\"request_reason\", false},\n\t\t\t\"retries\":                      {\"retries\", false},\n\t\t\t\"service_account\":              {\"service_account\", false},\n\t\t\t\"token_format\":                 {\"token_format\", false},\n\t\t\t\"universe\":                     {\"universe\", false},\n\t\t\t\"workload_identity_provider\":   {\"workload_identity_provider\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"access_token\":          {\"access_token\"},\n\t\t\t\"auth_token\":            {\"auth_token\"},\n\t\t\t\"credentials_file_path\": {\"credentials_file_path\"},\n\t\t\t\"id_token\":              {\"id_token\"},\n\t\t\t\"project_id\":            {\"project_id\"},\n\t\t},\n\t},\n\t\"google-github-actions/get-secretmanager-secrets@v2\": {\n\t\tName: \"Get Secret Manager secrets\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"encoding\":              {\"encoding\", false},\n\t\t\t\"export_to_environment\": {\"export_to_environment\", false},\n\t\t\t\"min_mask_length\":       {\"min_mask_length\", false},\n\t\t\t\"secrets\":               {\"secrets\", true},\n\t\t\t\"universe\":              {\"universe\", false},\n\t\t},\n\t\tSkipOutputs: true,\n\t},\n\t\"google-github-actions/setup-gcloud@v2\": {\n\t\tName: \"Set up gcloud Cloud SDK environment\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"install_components\": {\"install_components\", false},\n\t\t\t\"project_id\":         {\"project_id\", false},\n\t\t\t\"skip_install\":       {\"skip_install\", false},\n\t\t\t\"version\":            {\"version\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"version\": {\"version\"},\n\t\t},\n\t},\n\t\"google-github-actions/upload-cloud-storage@v2\": {\n\t\tName: \"Cloud Storage Uploader\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"concurrency\":          {\"concurrency\", false},\n\t\t\t\"destination\":          {\"destination\", true},\n\t\t\t\"gcloudignore_path\":    {\"gcloudignore_path\", false},\n\t\t\t\"glob\":                 {\"glob\", false},\n\t\t\t\"gzip\":                 {\"gzip\", false},\n\t\t\t\"headers\":              {\"headers\", false},\n\t\t\t\"parent\":               {\"parent\", false},\n\t\t\t\"path\":                 {\"path\", true},\n\t\t\t\"predefinedacl\":        {\"predefinedAcl\", false},\n\t\t\t\"process_gcloudignore\": {\"process_gcloudignore\", false},\n\t\t\t\"project_id\":           {\"project_id\", false},\n\t\t\t\"resumable\":            {\"resumable\", false},\n\t\t\t\"universe\":             {\"universe\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"uploaded\": {\"uploaded\"},\n\t\t},\n\t},\n\t\"goreleaser/goreleaser-action@v5\": {\n\t\tName: \"GoReleaser Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"args\":         {\"args\", false},\n\t\t\t\"distribution\": {\"distribution\", false},\n\t\t\t\"install-only\": {\"install-only\", false},\n\t\t\t\"version\":      {\"version\", false},\n\t\t\t\"workdir\":      {\"workdir\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifacts\": {\"artifacts\"},\n\t\t\t\"metadata\":  {\"metadata\"},\n\t\t},\n\t},\n\t\"goreleaser/goreleaser-action@v6\": {\n\t\tName: \"GoReleaser Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"args\":         {\"args\", false},\n\t\t\t\"distribution\": {\"distribution\", false},\n\t\t\t\"install-only\": {\"install-only\", false},\n\t\t\t\"version\":      {\"version\", false},\n\t\t\t\"workdir\":      {\"workdir\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"artifacts\": {\"artifacts\"},\n\t\t\t\"metadata\":  {\"metadata\"},\n\t\t},\n\t},\n\t\"gradle/wrapper-validation-action@v2\": {\n\t\tName: \"Gradle Wrapper Validation\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow-checksums\":   {\"allow-checksums\", false},\n\t\t\t\"allow-snapshots\":   {\"allow-snapshots\", false},\n\t\t\t\"min-wrapper-count\": {\"min-wrapper-count\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"failed-wrapper\": {\"failed-wrapper\"},\n\t\t},\n\t},\n\t\"gradle/wrapper-validation-action@v3\": {\n\t\tName: \"Gradle Wrapper Validation\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow-checksums\":   {\"allow-checksums\", false},\n\t\t\t\"allow-snapshots\":   {\"allow-snapshots\", false},\n\t\t\t\"min-wrapper-count\": {\"min-wrapper-count\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"failed-wrapper\": {\"failed-wrapper\"},\n\t\t},\n\t},\n\t\"microsoft/playwright-github-action@v1\": {\n\t\tName: \"Run Playwright tests\",\n\t},\n\t\"mikepenz/release-changelog-builder-action@v4\": {\n\t\tName: \"Release Changelog Builder\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"baseurl\":                 {\"baseUrl\", false},\n\t\t\t\"cache\":                   {\"cache\", false},\n\t\t\t\"commitmode\":              {\"commitMode\", false},\n\t\t\t\"configuration\":           {\"configuration\", false},\n\t\t\t\"configurationjson\":       {\"configurationJson\", false},\n\t\t\t\"exportcache\":             {\"exportCache\", false},\n\t\t\t\"exportonly\":              {\"exportOnly\", false},\n\t\t\t\"failonerror\":             {\"failOnError\", false},\n\t\t\t\"fetchreleaseinformation\": {\"fetchReleaseInformation\", false},\n\t\t\t\"fetchreviewers\":          {\"fetchReviewers\", false},\n\t\t\t\"fetchreviews\":            {\"fetchReviews\", false},\n\t\t\t\"fetchviacommits\":         {\"fetchViaCommits\", false},\n\t\t\t\"fromtag\":                 {\"fromTag\", false},\n\t\t\t\"ignoreprereleases\":       {\"ignorePreReleases\", false},\n\t\t\t\"includeopen\":             {\"includeOpen\", false},\n\t\t\t\"outputfile\":              {\"outputFile\", false},\n\t\t\t\"owner\":                   {\"owner\", false},\n\t\t\t\"path\":                    {\"path\", false},\n\t\t\t\"platform\":                {\"platform\", false},\n\t\t\t\"repo\":                    {\"repo\", false},\n\t\t\t\"token\":                   {\"token\", false},\n\t\t\t\"totag\":                   {\"toTag\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache\":             {\"cache\"},\n\t\t\t\"categorized_prs\":   {\"categorized_prs\"},\n\t\t\t\"changelog\":         {\"changelog\"},\n\t\t\t\"failed\":            {\"failed\"},\n\t\t\t\"fromtag\":           {\"fromTag\"},\n\t\t\t\"open_prs\":          {\"open_prs\"},\n\t\t\t\"owner\":             {\"owner\"},\n\t\t\t\"pull_requests\":     {\"pull_requests\"},\n\t\t\t\"repo\":              {\"repo\"},\n\t\t\t\"totag\":             {\"toTag\"},\n\t\t\t\"uncategorized_prs\": {\"uncategorized_prs\"},\n\t\t},\n\t},\n\t\"mikepenz/release-changelog-builder-action@v5\": {\n\t\tName: \"Release Changelog Builder\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"baseurl\":                 {\"baseUrl\", false},\n\t\t\t\"cache\":                   {\"cache\", false},\n\t\t\t\"commitmode\":              {\"commitMode\", false},\n\t\t\t\"configuration\":           {\"configuration\", false},\n\t\t\t\"configurationjson\":       {\"configurationJson\", false},\n\t\t\t\"exportcache\":             {\"exportCache\", false},\n\t\t\t\"exportonly\":              {\"exportOnly\", false},\n\t\t\t\"failonerror\":             {\"failOnError\", false},\n\t\t\t\"fetchreleaseinformation\": {\"fetchReleaseInformation\", false},\n\t\t\t\"fetchreviewers\":          {\"fetchReviewers\", false},\n\t\t\t\"fetchreviews\":            {\"fetchReviews\", false},\n\t\t\t\"fetchviacommits\":         {\"fetchViaCommits\", false},\n\t\t\t\"fromtag\":                 {\"fromTag\", false},\n\t\t\t\"ignoreprereleases\":       {\"ignorePreReleases\", false},\n\t\t\t\"includeopen\":             {\"includeOpen\", false},\n\t\t\t\"mode\":                    {\"mode\", false},\n\t\t\t\"outputfile\":              {\"outputFile\", false},\n\t\t\t\"owner\":                   {\"owner\", false},\n\t\t\t\"path\":                    {\"path\", false},\n\t\t\t\"platform\":                {\"platform\", false},\n\t\t\t\"repo\":                    {\"repo\", false},\n\t\t\t\"token\":                   {\"token\", false},\n\t\t\t\"totag\":                   {\"toTag\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"cache\":             {\"cache\"},\n\t\t\t\"categorized_prs\":   {\"categorized_prs\"},\n\t\t\t\"changelog\":         {\"changelog\"},\n\t\t\t\"failed\":            {\"failed\"},\n\t\t\t\"fromtag\":           {\"fromTag\"},\n\t\t\t\"open_prs\":          {\"open_prs\"},\n\t\t\t\"owner\":             {\"owner\"},\n\t\t\t\"pull_requests\":     {\"pull_requests\"},\n\t\t\t\"repo\":              {\"repo\"},\n\t\t\t\"totag\":             {\"toTag\"},\n\t\t\t\"uncategorized_prs\": {\"uncategorized_prs\"},\n\t\t},\n\t},\n\t\"msys2/setup-msys2@v2\": {\n\t\tName: \"Setup MSYS2\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"cache\":                   {\"cache\", false},\n\t\t\t\"install\":                 {\"install\", false},\n\t\t\t\"location\":                {\"location\", false},\n\t\t\t\"msystem\":                 {\"msystem\", false},\n\t\t\t\"pacboy\":                  {\"pacboy\", false},\n\t\t\t\"path-type\":               {\"path-type\", false},\n\t\t\t\"platform-check-severity\": {\"platform-check-severity\", false},\n\t\t\t\"release\":                 {\"release\", false},\n\t\t\t\"update\":                  {\"update\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"msys2-location\": {\"msys2-location\"},\n\t\t},\n\t},\n\t\"ncipollo/release-action@v1\": {\n\t\tName: \"Create Release\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allowupdates\":               {\"allowUpdates\", false},\n\t\t\t\"artifact\":                   {\"artifact\", false},\n\t\t\t\"artifactcontenttype\":        {\"artifactContentType\", false},\n\t\t\t\"artifacterrorsfailbuild\":    {\"artifactErrorsFailBuild\", false},\n\t\t\t\"artifacts\":                  {\"artifacts\", false},\n\t\t\t\"body\":                       {\"body\", false},\n\t\t\t\"bodyfile\":                   {\"bodyFile\", false},\n\t\t\t\"commit\":                     {\"commit\", false},\n\t\t\t\"discussioncategory\":         {\"discussionCategory\", false},\n\t\t\t\"draft\":                      {\"draft\", false},\n\t\t\t\"generatereleasenotes\":       {\"generateReleaseNotes\", false},\n\t\t\t\"makelatest\":                 {\"makeLatest\", false},\n\t\t\t\"name\":                       {\"name\", false},\n\t\t\t\"omitbody\":                   {\"omitBody\", false},\n\t\t\t\"omitbodyduringupdate\":       {\"omitBodyDuringUpdate\", false},\n\t\t\t\"omitdraftduringupdate\":      {\"omitDraftDuringUpdate\", false},\n\t\t\t\"omitname\":                   {\"omitName\", false},\n\t\t\t\"omitnameduringupdate\":       {\"omitNameDuringUpdate\", false},\n\t\t\t\"omitprereleaseduringupdate\": {\"omitPrereleaseDuringUpdate\", false},\n\t\t\t\"owner\":                      {\"owner\", false},\n\t\t\t\"prerelease\":                 {\"prerelease\", false},\n\t\t\t\"removeartifacts\":            {\"removeArtifacts\", false},\n\t\t\t\"replacesartifacts\":          {\"replacesArtifacts\", false},\n\t\t\t\"repo\":                       {\"repo\", false},\n\t\t\t\"skipifreleaseexists\":        {\"skipIfReleaseExists\", false},\n\t\t\t\"tag\":                        {\"tag\", false},\n\t\t\t\"token\":                      {\"token\", false},\n\t\t\t\"updateonlyunreleased\":       {\"updateOnlyUnreleased\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"html_url\":   {\"html_url\"},\n\t\t\t\"id\":         {\"id\"},\n\t\t\t\"upload_url\": {\"upload_url\"},\n\t\t},\n\t},\n\t\"nwtgck/actions-netlify@v3\": {\n\t\tName: \"Netlify Actions\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"alias\":                           {\"alias\", false},\n\t\t\t\"deploy-message\":                  {\"deploy-message\", false},\n\t\t\t\"enable-commit-comment\":           {\"enable-commit-comment\", false},\n\t\t\t\"enable-commit-status\":            {\"enable-commit-status\", false},\n\t\t\t\"enable-github-deployment\":        {\"enable-github-deployment\", false},\n\t\t\t\"enable-pull-request-comment\":     {\"enable-pull-request-comment\", false},\n\t\t\t\"fails-without-credentials\":       {\"fails-without-credentials\", false},\n\t\t\t\"functions-dir\":                   {\"functions-dir\", false},\n\t\t\t\"github-deployment-description\":   {\"github-deployment-description\", false},\n\t\t\t\"github-deployment-environment\":   {\"github-deployment-environment\", false},\n\t\t\t\"github-token\":                    {\"github-token\", false},\n\t\t\t\"netlify-config-path\":             {\"netlify-config-path\", false},\n\t\t\t\"overwrites-pull-request-comment\": {\"overwrites-pull-request-comment\", false},\n\t\t\t\"production-branch\":               {\"production-branch\", false},\n\t\t\t\"production-deploy\":               {\"production-deploy\", false},\n\t\t\t\"publish-dir\":                     {\"publish-dir\", true},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"deploy-url\": {\"deploy-url\"},\n\t\t},\n\t},\n\t\"octokit/graphql-action@v2.x\": {\n\t\tName: \"GitHub GraphQL API Query\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"mediatype\": {\"mediaType\", false},\n\t\t\t\"query\":     {\"query\", true},\n\t\t\t\"variables\": {\"variables\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"data\": {\"data\"},\n\t\t},\n\t},\n\t\"octokit/request-action@v2.x\": {\n\t\tName:       \"GitHub API Request\",\n\t\tSkipInputs: true,\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"data\":    {\"data\"},\n\t\t\t\"headers\": {\"headers\"},\n\t\t\t\"status\":  {\"status\"},\n\t\t},\n\t},\n\t\"peaceiris/actions-gh-pages@v2\": {\n\t\tName: \"GitHub Pages action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"commitmessage\": {\"commitMessage\", false},\n\t\t\t\"emptycommits\":  {\"emptyCommits\", false},\n\t\t\t\"forceorphan\":   {\"forceOrphan\", false},\n\t\t\t\"keepfiles\":     {\"keepFiles\", false},\n\t\t\t\"tagmessage\":    {\"tagMessage\", false},\n\t\t\t\"tagname\":       {\"tagName\", false},\n\t\t\t\"tagoverwrite\":  {\"tagOverwrite\", false},\n\t\t\t\"useremail\":     {\"useremail\", false},\n\t\t\t\"username\":      {\"username\", false},\n\t\t},\n\t},\n\t\"peaceiris/actions-gh-pages@v4\": {\n\t\tName: \"GitHub Pages action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"allow_empty_commit\":  {\"allow_empty_commit\", false},\n\t\t\t\"cname\":               {\"cname\", false},\n\t\t\t\"commit_message\":      {\"commit_message\", false},\n\t\t\t\"deploy_key\":          {\"deploy_key\", false},\n\t\t\t\"destination_dir\":     {\"destination_dir\", false},\n\t\t\t\"disable_nojekyll\":    {\"disable_nojekyll\", false},\n\t\t\t\"enable_jekyll\":       {\"enable_jekyll\", false},\n\t\t\t\"exclude_assets\":      {\"exclude_assets\", false},\n\t\t\t\"external_repository\": {\"external_repository\", false},\n\t\t\t\"force_orphan\":        {\"force_orphan\", false},\n\t\t\t\"full_commit_message\": {\"full_commit_message\", false},\n\t\t\t\"github_token\":        {\"github_token\", false},\n\t\t\t\"keep_files\":          {\"keep_files\", false},\n\t\t\t\"personal_token\":      {\"personal_token\", false},\n\t\t\t\"publish_branch\":      {\"publish_branch\", false},\n\t\t\t\"publish_dir\":         {\"publish_dir\", false},\n\t\t\t\"tag_message\":         {\"tag_message\", false},\n\t\t\t\"tag_name\":            {\"tag_name\", false},\n\t\t\t\"user_email\":          {\"user_email\", false},\n\t\t\t\"user_name\":           {\"user_name\", false},\n\t\t},\n\t},\n\t\"peaceiris/actions-hugo@v3\": {\n\t\tName: \"Hugo setup\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"extended\":     {\"extended\", false},\n\t\t\t\"hugo-version\": {\"hugo-version\", false},\n\t\t},\n\t},\n\t\"peter-evans/create-pull-request@v6\": {\n\t\tName: \"Create Pull Request\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add-paths\":      {\"add-paths\", false},\n\t\t\t\"assignees\":      {\"assignees\", false},\n\t\t\t\"author\":         {\"author\", false},\n\t\t\t\"base\":           {\"base\", false},\n\t\t\t\"body\":           {\"body\", false},\n\t\t\t\"body-path\":      {\"body-path\", false},\n\t\t\t\"branch\":         {\"branch\", false},\n\t\t\t\"branch-suffix\":  {\"branch-suffix\", false},\n\t\t\t\"commit-message\": {\"commit-message\", false},\n\t\t\t\"committer\":      {\"committer\", false},\n\t\t\t\"delete-branch\":  {\"delete-branch\", false},\n\t\t\t\"draft\":          {\"draft\", false},\n\t\t\t\"git-token\":      {\"git-token\", false},\n\t\t\t\"labels\":         {\"labels\", false},\n\t\t\t\"milestone\":      {\"milestone\", false},\n\t\t\t\"path\":           {\"path\", false},\n\t\t\t\"push-to-fork\":   {\"push-to-fork\", false},\n\t\t\t\"reviewers\":      {\"reviewers\", false},\n\t\t\t\"signoff\":        {\"signoff\", false},\n\t\t\t\"team-reviewers\": {\"team-reviewers\", false},\n\t\t\t\"title\":          {\"title\", false},\n\t\t\t\"token\":          {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"pull-request-branch\":    {\"pull-request-branch\"},\n\t\t\t\"pull-request-head-sha\":  {\"pull-request-head-sha\"},\n\t\t\t\"pull-request-number\":    {\"pull-request-number\"},\n\t\t\t\"pull-request-operation\": {\"pull-request-operation\"},\n\t\t\t\"pull-request-url\":       {\"pull-request-url\"},\n\t\t},\n\t},\n\t\"peter-evans/create-pull-request@v7\": {\n\t\tName: \"Create Pull Request\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"add-paths\":             {\"add-paths\", false},\n\t\t\t\"assignees\":             {\"assignees\", false},\n\t\t\t\"author\":                {\"author\", false},\n\t\t\t\"base\":                  {\"base\", false},\n\t\t\t\"body\":                  {\"body\", false},\n\t\t\t\"body-path\":             {\"body-path\", false},\n\t\t\t\"branch\":                {\"branch\", false},\n\t\t\t\"branch-suffix\":         {\"branch-suffix\", false},\n\t\t\t\"branch-token\":          {\"branch-token\", false},\n\t\t\t\"commit-message\":        {\"commit-message\", false},\n\t\t\t\"committer\":             {\"committer\", false},\n\t\t\t\"delete-branch\":         {\"delete-branch\", false},\n\t\t\t\"draft\":                 {\"draft\", false},\n\t\t\t\"labels\":                {\"labels\", false},\n\t\t\t\"maintainer-can-modify\": {\"maintainer-can-modify\", false},\n\t\t\t\"milestone\":             {\"milestone\", false},\n\t\t\t\"path\":                  {\"path\", false},\n\t\t\t\"push-to-fork\":          {\"push-to-fork\", false},\n\t\t\t\"reviewers\":             {\"reviewers\", false},\n\t\t\t\"sign-commits\":          {\"sign-commits\", false},\n\t\t\t\"signoff\":               {\"signoff\", false},\n\t\t\t\"team-reviewers\":        {\"team-reviewers\", false},\n\t\t\t\"title\":                 {\"title\", false},\n\t\t\t\"token\":                 {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"pull-request-branch\":    {\"pull-request-branch\"},\n\t\t\t\"pull-request-head-sha\":  {\"pull-request-head-sha\"},\n\t\t\t\"pull-request-number\":    {\"pull-request-number\"},\n\t\t\t\"pull-request-operation\": {\"pull-request-operation\"},\n\t\t\t\"pull-request-url\":       {\"pull-request-url\"},\n\t\t},\n\t},\n\t\"preactjs/compressed-size-action@v2\": {\n\t\tName: \"compressed-size-action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"build-script\":             {\"build-script\", false},\n\t\t\t\"clean-script\":             {\"clean-script\", false},\n\t\t\t\"collapse-unchanged\":       {\"collapse-unchanged\", false},\n\t\t\t\"comment-key\":              {\"comment-key\", false},\n\t\t\t\"compression\":              {\"compression\", false},\n\t\t\t\"cwd\":                      {\"cwd\", false},\n\t\t\t\"exclude\":                  {\"exclude\", false},\n\t\t\t\"install-script\":           {\"install-script\", false},\n\t\t\t\"minimum-change-threshold\": {\"minimum-change-threshold\", false},\n\t\t\t\"omit-unchanged\":           {\"omit-unchanged\", false},\n\t\t\t\"pattern\":                  {\"pattern\", false},\n\t\t\t\"repo-token\":               {\"repo-token\", false},\n\t\t\t\"show-total\":               {\"show-total\", false},\n\t\t\t\"strip-hash\":               {\"strip-hash\", false},\n\t\t\t\"use-check\":                {\"use-check\", false},\n\t\t},\n\t},\n\t\"pulumi/actions@v1\": {\n\t\tName: \"Pulumi CLI Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"command\": {\"command\", true},\n\t\t},\n\t},\n\t\"pulumi/actions@v5\": {\n\t\tName: \"Pulumi CLI Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"always-include-summary\": {\"always-include-summary\", false},\n\t\t\t\"cloud-url\":              {\"cloud-url\", false},\n\t\t\t\"color\":                  {\"color\", false},\n\t\t\t\"command\":                {\"command\", false},\n\t\t\t\"comment-on-pr\":          {\"comment-on-pr\", false},\n\t\t\t\"comment-on-pr-number\":   {\"comment-on-pr-number\", false},\n\t\t\t\"comment-on-summary\":     {\"comment-on-summary\", false},\n\t\t\t\"config-map\":             {\"config-map\", false},\n\t\t\t\"diff\":                   {\"diff\", false},\n\t\t\t\"edit-pr-comment\":        {\"edit-pr-comment\", false},\n\t\t\t\"exclude-protected\":      {\"exclude-protected\", false},\n\t\t\t\"expect-no-changes\":      {\"expect-no-changes\", false},\n\t\t\t\"github-token\":           {\"github-token\", false},\n\t\t\t\"message\":                {\"message\", false},\n\t\t\t\"parallel\":               {\"parallel\", false},\n\t\t\t\"plan\":                   {\"plan\", false},\n\t\t\t\"policypackconfigs\":      {\"policyPackConfigs\", false},\n\t\t\t\"policypacks\":            {\"policyPacks\", false},\n\t\t\t\"pulumi-version\":         {\"pulumi-version\", false},\n\t\t\t\"pulumi-version-file\":    {\"pulumi-version-file\", false},\n\t\t\t\"refresh\":                {\"refresh\", false},\n\t\t\t\"remove\":                 {\"remove\", false},\n\t\t\t\"replace\":                {\"replace\", false},\n\t\t\t\"secrets-provider\":       {\"secrets-provider\", false},\n\t\t\t\"stack-name\":             {\"stack-name\", false},\n\t\t\t\"suppress-outputs\":       {\"suppress-outputs\", false},\n\t\t\t\"suppress-progress\":      {\"suppress-progress\", false},\n\t\t\t\"target\":                 {\"target\", false},\n\t\t\t\"target-dependents\":      {\"target-dependents\", false},\n\t\t\t\"upsert\":                 {\"upsert\", false},\n\t\t\t\"work-dir\":               {\"work-dir\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"output\": {\"output\"},\n\t\t},\n\t},\n\t\"pulumi/actions@v6\": {\n\t\tName: \"Pulumi CLI Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"always-include-summary\": {\"always-include-summary\", false},\n\t\t\t\"cloud-url\":              {\"cloud-url\", false},\n\t\t\t\"color\":                  {\"color\", false},\n\t\t\t\"command\":                {\"command\", false},\n\t\t\t\"comment-on-pr\":          {\"comment-on-pr\", false},\n\t\t\t\"comment-on-pr-number\":   {\"comment-on-pr-number\", false},\n\t\t\t\"comment-on-summary\":     {\"comment-on-summary\", false},\n\t\t\t\"config-map\":             {\"config-map\", false},\n\t\t\t\"diff\":                   {\"diff\", false},\n\t\t\t\"edit-pr-comment\":        {\"edit-pr-comment\", false},\n\t\t\t\"exclude-protected\":      {\"exclude-protected\", false},\n\t\t\t\"expect-no-changes\":      {\"expect-no-changes\", false},\n\t\t\t\"github-token\":           {\"github-token\", false},\n\t\t\t\"message\":                {\"message\", false},\n\t\t\t\"parallel\":               {\"parallel\", false},\n\t\t\t\"plan\":                   {\"plan\", false},\n\t\t\t\"policypackconfigs\":      {\"policyPackConfigs\", false},\n\t\t\t\"policypacks\":            {\"policyPacks\", false},\n\t\t\t\"pulumi-version\":         {\"pulumi-version\", false},\n\t\t\t\"pulumi-version-file\":    {\"pulumi-version-file\", false},\n\t\t\t\"refresh\":                {\"refresh\", false},\n\t\t\t\"remove\":                 {\"remove\", false},\n\t\t\t\"replace\":                {\"replace\", false},\n\t\t\t\"secrets-provider\":       {\"secrets-provider\", false},\n\t\t\t\"stack-name\":             {\"stack-name\", false},\n\t\t\t\"suppress-outputs\":       {\"suppress-outputs\", false},\n\t\t\t\"suppress-progress\":      {\"suppress-progress\", false},\n\t\t\t\"target\":                 {\"target\", false},\n\t\t\t\"target-dependents\":      {\"target-dependents\", false},\n\t\t\t\"upsert\":                 {\"upsert\", false},\n\t\t\t\"work-dir\":               {\"work-dir\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"output\": {\"output\"},\n\t\t},\n\t},\n\t\"pypa/gh-action-pypi-publish@release/v1\": {\n\t\tName: \"pypi-publish\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"attestations\":    {\"attestations\", false},\n\t\t\t\"packages-dir\":    {\"packages-dir\", false},\n\t\t\t\"packages_dir\":    {\"packages_dir\", false},\n\t\t\t\"password\":        {\"password\", false},\n\t\t\t\"print-hash\":      {\"print-hash\", false},\n\t\t\t\"print_hash\":      {\"print_hash\", false},\n\t\t\t\"repository-url\":  {\"repository-url\", false},\n\t\t\t\"repository_url\":  {\"repository_url\", false},\n\t\t\t\"skip-existing\":   {\"skip-existing\", false},\n\t\t\t\"skip_existing\":   {\"skip_existing\", false},\n\t\t\t\"user\":            {\"user\", false},\n\t\t\t\"verbose\":         {\"verbose\", false},\n\t\t\t\"verify-metadata\": {\"verify-metadata\", false},\n\t\t\t\"verify_metadata\": {\"verify_metadata\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-actionlint@v1\": {\n\t\tName: \"actionlint with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"actionlint_flags\": {\"actionlint_flags\", false},\n\t\t\t\"fail_level\":       {\"fail_level\", false},\n\t\t\t\"fail_on_error\":    {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":      {\"filter_mode\", false},\n\t\t\t\"github_token\":     {\"github_token\", false},\n\t\t\t\"level\":            {\"level\", false},\n\t\t\t\"reporter\":         {\"reporter\", false},\n\t\t\t\"reviewdog_flags\":  {\"reviewdog_flags\", false},\n\t\t\t\"tool_name\":        {\"tool_name\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-eslint@v1\": {\n\t\tName: \"Run eslint with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"eslint_flags\":    {\"eslint_flags\", false},\n\t\t\t\"fail_level\":      {\"fail_level\", false},\n\t\t\t\"fail_on_error\":   {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":     {\"filter_mode\", false},\n\t\t\t\"github_token\":    {\"github_token\", false},\n\t\t\t\"level\":           {\"level\", false},\n\t\t\t\"node_options\":    {\"node_options\", false},\n\t\t\t\"reporter\":        {\"reporter\", false},\n\t\t\t\"reviewdog_flags\": {\"reviewdog_flags\", false},\n\t\t\t\"tool_name\":       {\"tool_name\", false},\n\t\t\t\"workdir\":         {\"workdir\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-golangci-lint@v1\": {\n\t\tName: \"Run golangci-lint with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"fail_on_error\":       {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":         {\"filter_mode\", false},\n\t\t\t\"github_token\":        {\"github_token\", false},\n\t\t\t\"golangci_lint_flags\": {\"golangci_lint_flags\", false},\n\t\t\t\"level\":               {\"level\", false},\n\t\t\t\"reporter\":            {\"reporter\", false},\n\t\t\t\"reviewdog_flags\":     {\"reviewdog_flags\", false},\n\t\t\t\"tool_name\":           {\"tool_name\", false},\n\t\t\t\"workdir\":             {\"workdir\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-golangci-lint@v2\": {\n\t\tName: \"Run golangci-lint with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"cache\":                 {\"cache\", false},\n\t\t\t\"fail_level\":            {\"fail_level\", false},\n\t\t\t\"fail_on_error\":         {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":           {\"filter_mode\", false},\n\t\t\t\"github_token\":          {\"github_token\", false},\n\t\t\t\"go_version\":            {\"go_version\", false},\n\t\t\t\"go_version_file\":       {\"go_version_file\", false},\n\t\t\t\"golangci_lint_flags\":   {\"golangci_lint_flags\", false},\n\t\t\t\"golangci_lint_version\": {\"golangci_lint_version\", false},\n\t\t\t\"level\":                 {\"level\", false},\n\t\t\t\"reporter\":              {\"reporter\", false},\n\t\t\t\"reviewdog_flags\":       {\"reviewdog_flags\", false},\n\t\t\t\"reviewdog_version\":     {\"reviewdog_version\", false},\n\t\t\t\"tool_name\":             {\"tool_name\", false},\n\t\t\t\"workdir\":               {\"workdir\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-hadolint@v1\": {\n\t\tName: \"Run hadolint with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"exclude\":         {\"exclude\", false},\n\t\t\t\"fail_level\":      {\"fail_level\", false},\n\t\t\t\"fail_on_error\":   {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":     {\"filter_mode\", false},\n\t\t\t\"github_token\":    {\"github_token\", false},\n\t\t\t\"hadolint_flags\":  {\"hadolint_flags\", false},\n\t\t\t\"hadolint_ignore\": {\"hadolint_ignore\", false},\n\t\t\t\"level\":           {\"level\", false},\n\t\t\t\"reporter\":        {\"reporter\", false},\n\t\t\t\"reviewdog_flags\": {\"reviewdog_flags\", false},\n\t\t\t\"tool_name\":       {\"tool_name\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-misspell@v1\": {\n\t\tName: \"Run misspell with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"exclude\":       {\"exclude\", false},\n\t\t\t\"fail_level\":    {\"fail_level\", false},\n\t\t\t\"fail_on_error\": {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":   {\"filter_mode\", false},\n\t\t\t\"github_token\":  {\"github_token\", false},\n\t\t\t\"ignore\":        {\"ignore\", false},\n\t\t\t\"level\":         {\"level\", false},\n\t\t\t\"locale\":        {\"locale\", false},\n\t\t\t\"path\":          {\"path\", false},\n\t\t\t\"pattern\":       {\"pattern\", false},\n\t\t\t\"reporter\":      {\"reporter\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-rubocop@v1\": {\n\t\tName: \"Run rubocop with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"fail_on_error\":      {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":        {\"filter_mode\", false},\n\t\t\t\"github_token\":       {\"github_token\", true},\n\t\t\t\"level\":              {\"level\", false},\n\t\t\t\"reporter\":           {\"reporter\", false},\n\t\t\t\"reviewdog_flags\":    {\"reviewdog_flags\", false},\n\t\t\t\"rubocop_extensions\": {\"rubocop_extensions\", false},\n\t\t\t\"rubocop_flags\":      {\"rubocop_flags\", false},\n\t\t\t\"rubocop_version\":    {\"rubocop_version\", false},\n\t\t\t\"skip_install\":       {\"skip_install\", false},\n\t\t\t\"tool_name\":          {\"tool_name\", false},\n\t\t\t\"use_bundler\":        {\"use_bundler\", false},\n\t\t\t\"workdir\":            {\"workdir\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-rubocop@v2\": {\n\t\tName: \"Run rubocop with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"fail_level\":         {\"fail_level\", false},\n\t\t\t\"fail_on_error\":      {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":        {\"filter_mode\", false},\n\t\t\t\"github_token\":       {\"github_token\", false},\n\t\t\t\"level\":              {\"level\", false},\n\t\t\t\"only_changed\":       {\"only_changed\", false},\n\t\t\t\"reporter\":           {\"reporter\", false},\n\t\t\t\"reviewdog_flags\":    {\"reviewdog_flags\", false},\n\t\t\t\"rubocop_extensions\": {\"rubocop_extensions\", false},\n\t\t\t\"rubocop_flags\":      {\"rubocop_flags\", false},\n\t\t\t\"rubocop_version\":    {\"rubocop_version\", false},\n\t\t\t\"skip_install\":       {\"skip_install\", false},\n\t\t\t\"tool_name\":          {\"tool_name\", false},\n\t\t\t\"use_bundler\":        {\"use_bundler\", false},\n\t\t\t\"workdir\":            {\"workdir\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-shellcheck@v1\": {\n\t\tName: \"Run shellcheck with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"check_all_files_with_shebangs\": {\"check_all_files_with_shebangs\", false},\n\t\t\t\"exclude\":                       {\"exclude\", false},\n\t\t\t\"fail_level\":                    {\"fail_level\", false},\n\t\t\t\"fail_on_error\":                 {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":                   {\"filter_mode\", false},\n\t\t\t\"github_token\":                  {\"github_token\", false},\n\t\t\t\"level\":                         {\"level\", false},\n\t\t\t\"path\":                          {\"path\", false},\n\t\t\t\"pattern\":                       {\"pattern\", false},\n\t\t\t\"reporter\":                      {\"reporter\", false},\n\t\t\t\"reviewdog_flags\":               {\"reviewdog_flags\", false},\n\t\t\t\"shellcheck_flags\":              {\"shellcheck_flags\", false},\n\t\t},\n\t},\n\t\"reviewdog/action-tflint@v1\": {\n\t\tName: \"Run tflint with reviewdog\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"fail_level\":        {\"fail_level\", false},\n\t\t\t\"fail_on_error\":     {\"fail_on_error\", false},\n\t\t\t\"filter_mode\":       {\"filter_mode\", false},\n\t\t\t\"flags\":             {\"flags\", false},\n\t\t\t\"github_token\":      {\"github_token\", false},\n\t\t\t\"level\":             {\"level\", false},\n\t\t\t\"reporter\":          {\"reporter\", false},\n\t\t\t\"tflint_config\":     {\"tflint_config\", false},\n\t\t\t\"tflint_init\":       {\"tflint_init\", false},\n\t\t\t\"tflint_rulesets\":   {\"tflint_rulesets\", false},\n\t\t\t\"tflint_target_dir\": {\"tflint_target_dir\", false},\n\t\t\t\"tflint_version\":    {\"tflint_version\", false},\n\t\t\t\"working_directory\": {\"working_directory\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"reviewdog-return-code\": {\"reviewdog-return-code\"},\n\t\t\t\"tflint-return-code\":    {\"tflint-return-code\"},\n\t\t},\n\t},\n\t\"rhysd/action-setup-vim@v1\": {\n\t\tName: \"Setup Vim\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"configure-args\": {\"configure-args\", false},\n\t\t\t\"neovim\":         {\"neovim\", false},\n\t\t\t\"token\":          {\"token\", false},\n\t\t\t\"version\":        {\"version\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"executable\": {\"executable\"},\n\t\t},\n\t},\n\t\"ridedott/merge-me-action@v2\": {\n\t\tName: \"Merge me!\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"enable_github_api_preview\":  {\"ENABLE_GITHUB_API_PREVIEW\", false},\n\t\t\t\"enabled_for_manual_changes\": {\"ENABLED_FOR_MANUAL_CHANGES\", false},\n\t\t\t\"github_login\":               {\"GITHUB_LOGIN\", false},\n\t\t\t\"github_token\":               {\"GITHUB_TOKEN\", true},\n\t\t\t\"maximum_retries\":            {\"MAXIMUM_RETRIES\", false},\n\t\t\t\"merge_method\":               {\"MERGE_METHOD\", false},\n\t\t\t\"preset\":                     {\"PRESET\", false},\n\t\t},\n\t},\n\t\"rtCamp/action-slack-notify@v2\": {\n\t\tName: \"Slack Notify\",\n\t},\n\t\"ruby/setup-ruby@v1\": {\n\t\tName: \"Setup Ruby, JRuby and TruffleRuby\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"bundler\":           {\"bundler\", false},\n\t\t\t\"bundler-cache\":     {\"bundler-cache\", false},\n\t\t\t\"cache-version\":     {\"cache-version\", false},\n\t\t\t\"ruby-version\":      {\"ruby-version\", false},\n\t\t\t\"rubygems\":          {\"rubygems\", false},\n\t\t\t\"self-hosted\":       {\"self-hosted\", false},\n\t\t\t\"windows-toolchain\": {\"windows-toolchain\", false},\n\t\t\t\"working-directory\": {\"working-directory\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"ruby-prefix\": {\"ruby-prefix\"},\n\t\t},\n\t},\n\t\"shivammathur/setup-php@v2\": {\n\t\tName: \"Setup PHP Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"coverage\":         {\"coverage\", false},\n\t\t\t\"extensions\":       {\"extensions\", false},\n\t\t\t\"ini-file\":         {\"ini-file\", false},\n\t\t\t\"ini-values\":       {\"ini-values\", false},\n\t\t\t\"php-version\":      {\"php-version\", false},\n\t\t\t\"php-version-file\": {\"php-version-file\", false},\n\t\t\t\"tools\":            {\"tools\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"php-version\": {\"php-version\"},\n\t\t},\n\t},\n\t\"softprops/action-gh-release@v2\": {\n\t\tName: \"GH Release\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"append_body\":              {\"append_body\", false},\n\t\t\t\"body\":                     {\"body\", false},\n\t\t\t\"body_path\":                {\"body_path\", false},\n\t\t\t\"discussion_category_name\": {\"discussion_category_name\", false},\n\t\t\t\"draft\":                    {\"draft\", false},\n\t\t\t\"fail_on_unmatched_files\":  {\"fail_on_unmatched_files\", false},\n\t\t\t\"files\":                    {\"files\", false},\n\t\t\t\"generate_release_notes\":   {\"generate_release_notes\", false},\n\t\t\t\"make_latest\":              {\"make_latest\", false},\n\t\t\t\"name\":                     {\"name\", false},\n\t\t\t\"prerelease\":               {\"prerelease\", false},\n\t\t\t\"repository\":               {\"repository\", false},\n\t\t\t\"tag_name\":                 {\"tag_name\", false},\n\t\t\t\"target_commitish\":         {\"target_commitish\", false},\n\t\t\t\"token\":                    {\"token\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"assets\":     {\"assets\"},\n\t\t\t\"id\":         {\"id\"},\n\t\t\t\"upload_url\": {\"upload_url\"},\n\t\t\t\"url\":        {\"url\"},\n\t\t},\n\t},\n\t\"subosito/flutter-action@v2\": {\n\t\tName: \"Set up Flutter\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"architecture\":         {\"architecture\", false},\n\t\t\t\"cache\":                {\"cache\", false},\n\t\t\t\"cache-key\":            {\"cache-key\", false},\n\t\t\t\"cache-path\":           {\"cache-path\", false},\n\t\t\t\"channel\":              {\"channel\", false},\n\t\t\t\"dry-run\":              {\"dry-run\", false},\n\t\t\t\"flutter-version\":      {\"flutter-version\", false},\n\t\t\t\"flutter-version-file\": {\"flutter-version-file\", false},\n\t\t\t\"pub-cache-key\":        {\"pub-cache-key\", false},\n\t\t\t\"pub-cache-path\":       {\"pub-cache-path\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"architecture\":   {\"ARCHITECTURE\"},\n\t\t\t\"cache-key\":      {\"CACHE-KEY\"},\n\t\t\t\"cache-path\":     {\"CACHE-PATH\"},\n\t\t\t\"channel\":        {\"CHANNEL\"},\n\t\t\t\"pub-cache-key\":  {\"PUB-CACHE-KEY\"},\n\t\t\t\"pub-cache-path\": {\"PUB-CACHE-PATH\"},\n\t\t\t\"version\":        {\"VERSION\"},\n\t\t},\n\t},\n\t\"treosh/lighthouse-ci-action@v11\": {\n\t\tName: \"Lighthouse CI Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"artifactname\":           {\"artifactName\", false},\n\t\t\t\"basicauthpassword\":      {\"basicAuthPassword\", false},\n\t\t\t\"basicauthusername\":      {\"basicAuthUsername\", false},\n\t\t\t\"budgetpath\":             {\"budgetPath\", false},\n\t\t\t\"configpath\":             {\"configPath\", false},\n\t\t\t\"runs\":                   {\"runs\", false},\n\t\t\t\"serverbaseurl\":          {\"serverBaseUrl\", false},\n\t\t\t\"servertoken\":            {\"serverToken\", false},\n\t\t\t\"temporarypublicstorage\": {\"temporaryPublicStorage\", false},\n\t\t\t\"uploadartifacts\":        {\"uploadArtifacts\", false},\n\t\t\t\"uploadextraargs\":        {\"uploadExtraArgs\", false},\n\t\t\t\"urls\":                   {\"urls\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"assertionresults\": {\"assertionResults\"},\n\t\t\t\"links\":            {\"links\"},\n\t\t\t\"resultspath\":      {\"resultsPath\"},\n\t\t},\n\t},\n\t\"treosh/lighthouse-ci-action@v12\": {\n\t\tName: \"Lighthouse CI Action\",\n\t\tInputs: ActionMetadataInputs{\n\t\t\t\"artifactname\":           {\"artifactName\", false},\n\t\t\t\"basicauthpassword\":      {\"basicAuthPassword\", false},\n\t\t\t\"basicauthusername\":      {\"basicAuthUsername\", false},\n\t\t\t\"budgetpath\":             {\"budgetPath\", false},\n\t\t\t\"configpath\":             {\"configPath\", false},\n\t\t\t\"runs\":                   {\"runs\", false},\n\t\t\t\"serverbaseurl\":          {\"serverBaseUrl\", false},\n\t\t\t\"servertoken\":            {\"serverToken\", false},\n\t\t\t\"temporarypublicstorage\": {\"temporaryPublicStorage\", false},\n\t\t\t\"uploadartifacts\":        {\"uploadArtifacts\", false},\n\t\t\t\"uploadextraargs\":        {\"uploadExtraArgs\", false},\n\t\t\t\"urls\":                   {\"urls\", false},\n\t\t},\n\t\tOutputs: ActionMetadataOutputs{\n\t\t\t\"assertionresults\": {\"assertionResults\"},\n\t\t\t\"links\":            {\"links\"},\n\t\t\t\"resultspath\":      {\"resultsPath\"},\n\t\t},\n\t},\n}\n\n// OutdatedPopularActionSpecs is a spec set of known outdated popular actions. The word 'outdated'\n// means that the runner used by the action is no longer available such as \"node12\", \"node16\".\nvar OutdatedPopularActionSpecs = map[string]struct{}{\n\t\"8398a7/action-slack@v1\":                             {},\n\t\"8398a7/action-slack@v2\":                             {},\n\t\"Azure/container-scan@v0\":                            {},\n\t\"JamesIves/github-pages-deploy-action@releases/v3\":   {},\n\t\"ReactiveCircus/android-emulator-runner@v1\":          {},\n\t\"Swatinem/rust-cache@v1\":                             {},\n\t\"actions-cool/issues-helper@v1\":                      {},\n\t\"actions-cool/issues-helper@v2\":                      {},\n\t\"actions-rs/audit-check@v1\":                          {},\n\t\"actions-rs/cargo@v1\":                                {},\n\t\"actions-rs/clippy-check@v1\":                         {},\n\t\"actions-rs/toolchain@v1\":                            {},\n\t\"actions/cache@v1\":                                   {},\n\t\"actions/cache@v2\":                                   {},\n\t\"actions/cache@v3\":                                   {},\n\t\"actions/checkout@v1\":                                {},\n\t\"actions/checkout@v2\":                                {},\n\t\"actions/checkout@v3\":                                {},\n\t\"actions/configure-pages@v1\":                         {},\n\t\"actions/configure-pages@v2\":                         {},\n\t\"actions/configure-pages@v3\":                         {},\n\t\"actions/delete-package-versions@v1\":                 {},\n\t\"actions/delete-package-versions@v2\":                 {},\n\t\"actions/delete-package-versions@v3\":                 {},\n\t\"actions/delete-package-versions@v4\":                 {},\n\t\"actions/dependency-review-action@v3\":                {},\n\t\"actions/deploy-pages@v1\":                            {},\n\t\"actions/deploy-pages@v2\":                            {},\n\t\"actions/download-artifact@v1\":                       {},\n\t\"actions/download-artifact@v2\":                       {},\n\t\"actions/download-artifact@v3\":                       {},\n\t\"actions/github-script@v1\":                           {},\n\t\"actions/github-script@v2\":                           {},\n\t\"actions/github-script@v3\":                           {},\n\t\"actions/github-script@v4\":                           {},\n\t\"actions/github-script@v5\":                           {},\n\t\"actions/github-script@v6\":                           {},\n\t\"actions/labeler@v2\":                                 {},\n\t\"actions/labeler@v3\":                                 {},\n\t\"actions/labeler@v4\":                                 {},\n\t\"actions/setup-dotnet@v1\":                            {},\n\t\"actions/setup-dotnet@v2\":                            {},\n\t\"actions/setup-dotnet@v3\":                            {},\n\t\"actions/setup-go@v1\":                                {},\n\t\"actions/setup-go@v2\":                                {},\n\t\"actions/setup-go@v3\":                                {},\n\t\"actions/setup-go@v4\":                                {},\n\t\"actions/setup-java@v1\":                              {},\n\t\"actions/setup-java@v2\":                              {},\n\t\"actions/setup-java@v3\":                              {},\n\t\"actions/setup-node@v1\":                              {},\n\t\"actions/setup-node@v2\":                              {},\n\t\"actions/setup-node@v3\":                              {},\n\t\"actions/setup-python@v1\":                            {},\n\t\"actions/setup-python@v2\":                            {},\n\t\"actions/setup-python@v3\":                            {},\n\t\"actions/setup-python@v4\":                            {},\n\t\"actions/stale@v1\":                                   {},\n\t\"actions/stale@v2\":                                   {},\n\t\"actions/stale@v3\":                                   {},\n\t\"actions/stale@v4\":                                   {},\n\t\"actions/stale@v5\":                                   {},\n\t\"actions/stale@v6\":                                   {},\n\t\"actions/stale@v7\":                                   {},\n\t\"actions/stale@v8\":                                   {},\n\t\"actions/upload-artifact@v1\":                         {},\n\t\"actions/upload-artifact@v2\":                         {},\n\t\"actions/upload-artifact@v3\":                         {},\n\t\"aws-actions/configure-aws-credentials@v1\":           {},\n\t\"aws-actions/configure-aws-credentials@v2\":           {},\n\t\"aws-actions/configure-aws-credentials@v3\":           {},\n\t\"azure/aks-set-context@v1\":                           {},\n\t\"azure/aks-set-context@v2\":                           {},\n\t\"azure/aks-set-context@v3\":                           {},\n\t\"azure/login@v1\":                                     {},\n\t\"codecov/codecov-action@v1\":                          {},\n\t\"codecov/codecov-action@v2\":                          {},\n\t\"codecov/codecov-action@v3\":                          {},\n\t\"dawidd6/action-download-artifact@v2\":                {},\n\t\"dawidd6/action-send-mail@v2\":                        {},\n\t\"dessant/lock-threads@v2\":                            {},\n\t\"dessant/lock-threads@v3\":                            {},\n\t\"dessant/lock-threads@v4\":                            {},\n\t\"docker/build-push-action@v2\":                        {},\n\t\"docker/build-push-action@v3\":                        {},\n\t\"docker/build-push-action@v4\":                        {},\n\t\"docker/login-action@v1\":                             {},\n\t\"docker/login-action@v2\":                             {},\n\t\"docker/metadata-action@v1\":                          {},\n\t\"docker/metadata-action@v2\":                          {},\n\t\"docker/metadata-action@v3\":                          {},\n\t\"docker/metadata-action@v4\":                          {},\n\t\"docker/setup-buildx-action@v1\":                      {},\n\t\"docker/setup-buildx-action@v2\":                      {},\n\t\"docker/setup-qemu-action@v1\":                        {},\n\t\"docker/setup-qemu-action@v2\":                        {},\n\t\"dorny/paths-filter@v1\":                              {},\n\t\"dorny/paths-filter@v2\":                              {},\n\t\"enriikke/gatsby-gh-pages-action@v2\":                 {},\n\t\"game-ci/unity-builder@v2\":                           {},\n\t\"game-ci/unity-builder@v3\":                           {},\n\t\"github/codeql-action/analyze@v1\":                    {},\n\t\"github/codeql-action/analyze@v2\":                    {},\n\t\"github/codeql-action/autobuild@v1\":                  {},\n\t\"github/codeql-action/autobuild@v2\":                  {},\n\t\"github/codeql-action/init@v1\":                       {},\n\t\"github/codeql-action/init@v2\":                       {},\n\t\"githubocto/flat@v1\":                                 {},\n\t\"githubocto/flat@v2\":                                 {},\n\t\"githubocto/flat@v3\":                                 {},\n\t\"golangci/golangci-lint-action@v1\":                   {},\n\t\"golangci/golangci-lint-action@v2\":                   {},\n\t\"golangci/golangci-lint-action@v3\":                   {},\n\t\"google-github-actions/auth@v1\":                      {},\n\t\"google-github-actions/get-secretmanager-secrets@v1\": {},\n\t\"google-github-actions/setup-gcloud@v1\":              {},\n\t\"google-github-actions/upload-cloud-storage@v1\":      {},\n\t\"goreleaser/goreleaser-action@v1\":                    {},\n\t\"goreleaser/goreleaser-action@v2\":                    {},\n\t\"goreleaser/goreleaser-action@v3\":                    {},\n\t\"goreleaser/goreleaser-action@v4\":                    {},\n\t\"gradle/wrapper-validation-action@v1\":                {},\n\t\"haskell/actions/setup@v1\":                           {},\n\t\"haskell/actions/setup@v2\":                           {},\n\t\"marvinpinto/action-automatic-releases@latest\":       {},\n\t\"mikepenz/release-changelog-builder-action@v1\":       {},\n\t\"mikepenz/release-changelog-builder-action@v2\":       {},\n\t\"mikepenz/release-changelog-builder-action@v3\":       {},\n\t\"msys2/setup-msys2@v1\":                               {},\n\t\"nwtgck/actions-netlify@v1\":                          {},\n\t\"nwtgck/actions-netlify@v2\":                          {},\n\t\"octokit/request-action@v1.x\":                        {},\n\t\"peaceiris/actions-gh-pages@v3\":                      {},\n\t\"peter-evans/create-pull-request@v1\":                 {},\n\t\"peter-evans/create-pull-request@v2\":                 {},\n\t\"peter-evans/create-pull-request@v3\":                 {},\n\t\"peter-evans/create-pull-request@v4\":                 {},\n\t\"peter-evans/create-pull-request@v5\":                 {},\n\t\"preactjs/compressed-size-action@v1\":                 {},\n\t\"pulumi/actions@v2\":                                  {},\n\t\"pulumi/actions@v3\":                                  {},\n\t\"pulumi/actions@v4\":                                  {},\n\t\"ridedott/merge-me-action@v1\":                        {},\n\t\"shivammathur/setup-php@v1\":                          {},\n\t\"softprops/action-gh-release@v1\":                     {},\n\t\"treosh/lighthouse-ci-action@v1\":                     {},\n\t\"treosh/lighthouse-ci-action@v10\":                    {},\n\t\"treosh/lighthouse-ci-action@v2\":                     {},\n\t\"treosh/lighthouse-ci-action@v3\":                     {},\n\t\"treosh/lighthouse-ci-action@v7\":                     {},\n\t\"treosh/lighthouse-ci-action@v8\":                     {},\n\t\"treosh/lighthouse-ci-action@v9\":                     {},\n\t\"wearerequired/lint-action@v1\":                       {},\n\t\"wearerequired/lint-action@v2\":                       {},\n}\n"
        },
        {
          "name": "popular_actions_test.go",
          "type": "blob",
          "size": 0.8037109375,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestPopularActionsDataset(t *testing.T) {\n\tif len(PopularActions) == 0 {\n\t\tt.Fatal(\"popular actions data set is empty\")\n\t}\n\n\tfor n, meta := range PopularActions {\n\t\tif meta == nil {\n\t\t\tt.Fatalf(\"metadata for %s is nil\", n)\n\t\t}\n\t\tif meta.Name == \"\" {\n\t\t\tt.Fatalf(\"action name for %s is empty\", n)\n\t\t}\n\t\tfor id, i := range meta.Inputs {\n\t\t\tif id != strings.ToLower(id) {\n\t\t\t\tt.Errorf(\"input ID %q is not in lower case at %q\", id, n)\n\t\t\t}\n\t\t\tif i.Name == \"\" {\n\t\t\t\tt.Errorf(\"input name is not empty at ID %q at %q\", id, n)\n\t\t\t}\n\t\t}\n\t\tfor id, o := range meta.Outputs {\n\t\t\tif id != strings.ToLower(id) {\n\t\t\t\tt.Errorf(\"output ID %q is not in lower case at %q\", id, n)\n\t\t\t}\n\t\t\tif o.Name == \"\" {\n\t\t\t\tt.Errorf(\"output name is not empty at ID %q at %q\", id, n)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "process.go",
          "type": "blob",
          "size": 4.9921875,
          "content": "package actionlint\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"os/exec\"\n\t\"sync\"\n\n\t\"github.com/mattn/go-shellwords\"\n\t\"golang.org/x/sync/errgroup\"\n\t\"golang.org/x/sync/semaphore\"\n\t\"golang.org/x/sys/execabs\"\n)\n\n// cmdExecution represents a single command line execution.\ntype cmdExecution struct {\n\tcmd           string\n\targs          []string\n\tstdin         string\n\tcombineOutput bool\n}\n\nfunc (e *cmdExecution) run() ([]byte, error) {\n\tcmd := exec.Command(e.cmd, e.args...)\n\tcmd.Stderr = nil\n\n\tp, err := cmd.StdinPipe()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"could not make stdin pipe for %s process: %w\", e.cmd, err)\n\t}\n\tif _, err := io.WriteString(p, e.stdin); err != nil {\n\t\tp.Close()\n\t\treturn nil, fmt.Errorf(\"could not write to stdin of %s process: %w\", e.cmd, err)\n\t}\n\tp.Close()\n\n\tvar stdout []byte\n\tif e.combineOutput {\n\t\tstdout, err = cmd.CombinedOutput()\n\t} else {\n\t\tstdout, err = cmd.Output()\n\t}\n\n\tif err != nil {\n\t\tif exitErr, ok := err.(*exec.ExitError); ok {\n\t\t\tcode := exitErr.ExitCode()\n\n\t\t\tstderr := exitErr.Stderr\n\t\t\tif e.combineOutput {\n\t\t\t\tstderr = stdout\n\t\t\t}\n\n\t\t\tif code < 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%s was terminated. stderr: %q\", e.cmd, stderr)\n\t\t\t}\n\n\t\t\tif len(stdout) == 0 {\n\t\t\t\treturn nil, fmt.Errorf(\"%s exited with status %d but stdout was empty. stderr: %q\", e.cmd, code, stderr)\n\t\t\t}\n\n\t\t\t// Reaches here when exit status is non-zero and stdout is not empty, shellcheck successfully found some errors\n\t\t} else {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn stdout, nil\n}\n\n// concurrentProcess is a manager to run process concurrently. Since running process consumes OS\n// resources, running too many processes concurrently causes some issues. On macOS, making too many\n// process makes the parent process hang (see issue #3). And running processes which open files can\n// cause the error \"pipe: too many files to open\". To avoid it, this type manages how many processes\n// are run at once.\ntype concurrentProcess struct {\n\tctx  context.Context\n\tsema *semaphore.Weighted\n\twg   sync.WaitGroup\n}\n\n// newConcurrentProcess creates a new ConcurrentProcess instance. The `par` argument represents how\n// many processes can be run in parallel. It is recommended to use the value returned from\n// runtime.NumCPU() for the argument.\nfunc newConcurrentProcess(par int) *concurrentProcess {\n\treturn &concurrentProcess{\n\t\tctx:  context.Background(),\n\t\tsema: semaphore.NewWeighted(int64(par)),\n\t}\n}\n\nfunc (proc *concurrentProcess) run(eg *errgroup.Group, exec *cmdExecution, callback func([]byte, error) error) {\n\tproc.wg.Add(1)\n\teg.Go(func() error {\n\t\tdefer proc.wg.Done()\n\t\tif err := proc.sema.Acquire(proc.ctx, 1); err != nil {\n\t\t\treturn fmt.Errorf(\"could not acquire semaphore to run %q: %w\", exec.cmd, err)\n\t\t}\n\t\tstdout, err := exec.run()\n\t\tproc.sema.Release(1)\n\t\treturn callback(stdout, err)\n\t})\n}\n\n// wait waits all goroutines started by this concurrentProcess instance finish.\nfunc (proc *concurrentProcess) wait() {\n\tproc.wg.Wait() // Wait for all goroutines completing to shutdown\n}\n\n// newCommandRunner creates new external command runner for given executable. The executable path\n// is resolved in this function.\nfunc (proc *concurrentProcess) newCommandRunner(exe string, combineOutput bool) (*externalCommand, error) {\n\tvar args []string\n\tp, args, err := resolveExternalCommand(exe)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcmd := &externalCommand{\n\t\tproc:          proc,\n\t\texe:           p,\n\t\targs:          args,\n\t\tcombineOutput: combineOutput,\n\t}\n\treturn cmd, nil\n}\n\nfunc resolveExternalCommand(exe string) (string, []string, error) {\n\tc, err := execabs.LookPath(exe)\n\tif err == nil {\n\t\treturn c, nil, nil\n\t}\n\n\t// Try to parse the string as a command line instead of a single executable file path.\n\tif a, err := shellwords.Parse(exe); err == nil && len(a) > 0 {\n\t\tif c, err := execabs.LookPath(a[0]); err == nil {\n\t\t\treturn c, a[1:], nil\n\t\t}\n\t}\n\n\treturn \"\", nil, err\n}\n\n// externalCommand is struct to run specific command concurrently with concurrentProcess bounding\n// number of processes at the same time. This type manages fatal errors while running the command\n// by using errgroup.Group. The wait() method must be called at the end for checking if some fatal\n// error occurred.\ntype externalCommand struct {\n\tproc          *concurrentProcess\n\teg            errgroup.Group\n\texe           string\n\targs          []string\n\tcombineOutput bool\n}\n\n// run runs the command with given arguments and stdin. The callback function is called after the\n// process runs. First argument is stdout and the second argument is an error while running the\n// process.\nfunc (cmd *externalCommand) run(args []string, stdin string, callback func([]byte, error) error) {\n\tif len(cmd.args) > 0 {\n\t\tvar allArgs []string\n\t\tallArgs = append(allArgs, cmd.args...)\n\t\tallArgs = append(allArgs, args...)\n\t\targs = allArgs\n\t}\n\texec := &cmdExecution{cmd.exe, args, stdin, cmd.combineOutput}\n\tcmd.proc.run(&cmd.eg, exec, callback)\n}\n\n// wait waits until all goroutines for this command finish. Note that it does not wait for\n// goroutines for other commands.\nfunc (cmd *externalCommand) wait() error {\n\treturn cmd.eg.Wait()\n}\n"
        },
        {
          "name": "process_test.go",
          "type": "blob",
          "size": 7.6806640625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync/atomic\" // Note: atomic.Bool was added at Go 1.19\n\t\"testing\"\n\t\"time\"\n\n\t\"golang.org/x/sys/execabs\"\n)\n\nfunc testStartEchoCommand(t *testing.T, proc *concurrentProcess, done *atomic.Bool) {\n\tt.Helper()\n\n\tdone.Store(false)\n\techo := testSkipIfNoCommand(t, proc, \"echo\")\n\techo.run([]string{}, \"\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tdone.Store(true)\n\t\treturn nil\n\t})\n\t// This function does not wait the command finishes\n}\n\nfunc testSkipIfNoCommand(t *testing.T, p *concurrentProcess, cmd string) *externalCommand {\n\tt.Helper()\n\tc, err := p.newCommandRunner(cmd, false)\n\tif err != nil {\n\t\tt.Skipf(\"%s command is necessary to run this test: %s\", cmd, err)\n\t}\n\treturn c\n}\n\nfunc TestProcessRunConcurrently(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"this test is flaky on Windows\")\n\t}\n\n\tp := newConcurrentProcess(5)\n\tsleep := testSkipIfNoCommand(t, p, \"sleep\")\n\n\tstart := time.Now()\n\tfor i := 0; i < 5; i++ {\n\t\tsleep.run([]string{\"0.1\"}, \"\", func(b []byte, err error) error {\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t}\n\tif err := sleep.wait(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp.wait()\n\n\tsec := time.Since(start).Seconds()\n\tif sec >= 0.5 {\n\t\tt.Fatalf(\"commands did not run concurrently. running five `sleep 0.1` commands took %v seconds\", sec)\n\t}\n}\n\nfunc TestProcessRunWithArgs(t *testing.T) {\n\tif _, err := execabs.LookPath(\"echo\"); err != nil {\n\t\tt.Skipf(\"echo command is necessary to run this test: %s\", err)\n\t}\n\n\tvar done atomic.Bool\n\tp := newConcurrentProcess(1)\n\techo, err := p.newCommandRunner(\"echo hello\", false)\n\tif err != nil {\n\t\tt.Fatalf(`parsing \"echo hello\" failed: %v`, err)\n\t}\n\techo.run(nil, \"\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tif string(b) != \"hello\\n\" {\n\t\t\tt.Errorf(\"unexpected output: %q\", b)\n\t\t}\n\t\tdone.Store(true)\n\t\treturn nil\n\t})\n\tp.wait()\n\n\tif !done.Load() {\n\t\tt.Error(\"callback did not run\")\n\t}\n}\n\nfunc TestProcessRunMultipleCommandsConcurrently(t *testing.T) {\n\tp := newConcurrentProcess(3)\n\n\tdone := make([]bool, 5)\n\tcmds := make([]*externalCommand, 0, 5)\n\tfor i := 0; i < 5; i++ {\n\t\tidx := i\n\t\techo := testSkipIfNoCommand(t, p, \"echo\")\n\t\techo.run([]string{\"hello\"}, \"\", func(b []byte, err error) error {\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdone[idx] = true\n\t\t\treturn nil\n\t\t})\n\t\tcmds = append(cmds, echo)\n\t}\n\n\tfor i, c := range cmds {\n\t\tif err := c.wait(); err != nil {\n\t\t\tt.Errorf(\"cmds[%d] failed: %s\", i, err)\n\t\t}\n\t}\n\n\tfor i, b := range done {\n\t\tif !b {\n\t\t\tt.Errorf(\"cmds[%d] did not finish\", i)\n\t\t}\n\t}\n}\n\nfunc TestProcessWaitMultipleCommandsFinish(t *testing.T) {\n\tp := newConcurrentProcess(2)\n\n\tdone := make([]bool, 3)\n\tfor i := 0; i < 3; i++ {\n\t\tidx := i\n\t\techo := testSkipIfNoCommand(t, p, \"echo\")\n\t\techo.run([]string{\"hello\"}, \"\", func(b []byte, err error) error {\n\t\t\tif err != nil {\n\t\t\t\tt.Error(err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdone[idx] = true\n\t\t\treturn nil\n\t\t})\n\t}\n\n\tp.wait()\n\n\tfor i, b := range done {\n\t\tif !b {\n\t\t\tt.Errorf(\"cmds[%d] did not finish\", i)\n\t\t}\n\t}\n}\n\nfunc TestProcessInputStdin(t *testing.T) {\n\tp := newConcurrentProcess(1)\n\tcat := testSkipIfNoCommand(t, p, \"cat\")\n\tout := \"\"\n\n\tcat.run([]string{}, \"this is test\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn err\n\t\t}\n\t\tout = string(b)\n\t\treturn nil\n\t})\n\n\tif err := cat.wait(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp.wait()\n\n\tif out != \"this is test\" {\n\t\tt.Fatalf(\"stdin was not input to `cat` command: %q\", out)\n\t}\n}\n\nfunc TestProcessErrorCommandNotFound(t *testing.T) {\n\tp := newConcurrentProcess(1)\n\tc := &externalCommand{\n\t\tproc: p,\n\t\texe:  \"this-command-does-not-exist\",\n\t}\n\n\tc.run([]string{}, \"\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"yay! error found! %w\", err)\n\t\t}\n\t\tt.Error(\"command not found error did not occur\")\n\t\treturn nil\n\t})\n\n\techoDone := &atomic.Bool{}\n\ttestStartEchoCommand(t, p, echoDone)\n\n\terr := c.wait()\n\tif err == nil || !strings.Contains(err.Error(), \"yay! error found!\") {\n\t\tt.Fatalf(\"error was not reported by p.Wait(): %v\", err)\n\t}\n\n\tp.wait()\n\n\tif !echoDone.Load() {\n\t\tt.Fatal(\"a command following the error did not run\")\n\t}\n}\n\nfunc TestProcessErrorInCallback(t *testing.T) {\n\tp := newConcurrentProcess(1)\n\techo := testSkipIfNoCommand(t, p, \"echo\")\n\n\techo.run([]string{}, \"\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t\treturn err\n\t\t}\n\t\treturn fmt.Errorf(\"dummy error\")\n\t})\n\n\techoDone := &atomic.Bool{}\n\ttestStartEchoCommand(t, p, echoDone)\n\n\terr := echo.wait()\n\tif err == nil || err.Error() != \"dummy error\" {\n\t\tt.Fatalf(\"error was not reported by p.Wait(): %v\", err)\n\t}\n\n\tp.wait()\n\n\tif !echoDone.Load() {\n\t\tt.Fatal(\"a command following the error did not run\")\n\t}\n}\n\nfunc TestProcessErrorLinterFailed(t *testing.T) {\n\tp := newConcurrentProcess(1)\n\tls := testSkipIfNoCommand(t, p, \"ls\")\n\n\t// Running ls with directory which does not exist emulates external liter's failure.\n\t// For example shellcheck exits with non-zero status but it outputs nothing to stdout when it\n\t// fails to run.\n\tls.run([]string{\"oops-this-directory-does-not-exist\"}, \"\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tt.Error(\"error did not occur on running the process\")\n\t\treturn nil\n\t})\n\n\techoDone := &atomic.Bool{}\n\ttestStartEchoCommand(t, p, echoDone)\n\n\terr := ls.wait()\n\tif err == nil {\n\t\tt.Fatal(\"error did not occur\")\n\t}\n\tmsg := err.Error()\n\tif !strings.Contains(msg, \"but stdout was empty\") || !strings.Contains(msg, \"oops-this-directory-does-not-exist\") {\n\t\tt.Fatalf(\"Error message was unexpected: %q\", msg)\n\t}\n\n\tp.wait()\n\n\tif !echoDone.Load() {\n\t\tt.Fatal(\"a command following the error did not run\")\n\t}\n}\n\nfunc TestProcessRunConcurrentlyAndWait(t *testing.T) {\n\tp := newConcurrentProcess(2)\n\techo := testSkipIfNoCommand(t, p, \"echo\")\n\n\tc := make(chan struct{})\n\tfor i := 0; i < 3; i++ {\n\t\tgo func() {\n\t\t\tfor i := 0; i < 5; i++ {\n\t\t\t\techo.run(nil, \"\", func(b []byte, err error) error {\n\t\t\t\t\treturn err\n\t\t\t\t})\n\t\t\t}\n\t\t\tc <- struct{}{}\n\t\t}()\n\t}\n\n\tfor i := 0; i < 3; i++ {\n\t\t<-c\n\t}\n\n\tp.wait()\n}\n\nfunc TestProcessCombineStdoutAndStderr(t *testing.T) {\n\tp := newConcurrentProcess(1)\n\tbash := testSkipIfNoCommand(t, p, \"bash\")\n\tbash.combineOutput = true\n\tscript := \"echo 'hello stdout'; echo 'hello stderr' >&2\"\n\tdone := make(chan string)\n\n\tbash.run([]string{\"-c\", script}, \"\", func(b []byte, err error) error {\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t\treturn err\n\t\t}\n\t\tdone <- string(b)\n\t\treturn nil\n\t})\n\n\tout := <-done\n\tif err := bash.wait(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp.wait()\n\n\tif !strings.Contains(out, \"hello stdout\") {\n\t\tt.Errorf(\"stdout was not captured: %q\", out)\n\t}\n\tif !strings.Contains(out, \"hello stderr\") {\n\t\tt.Errorf(\"stderr was not captured: %q\", out)\n\t}\n}\n\nfunc TestProcessCommandExitStatusNonZero(t *testing.T) {\n\tp := newConcurrentProcess(1)\n\tbash := testSkipIfNoCommand(t, p, \"false\")\n\tdone := make(chan error)\n\n\tbash.run([]string{}, \"\", func(b []byte, err error) error {\n\t\tdone <- err\n\t\treturn nil\n\t})\n\n\terr := <-done\n\tif err := bash.wait(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp.wait()\n\tif err == nil {\n\t\tt.Fatal(\"Error did not happen\")\n\t}\n\tmsg := err.Error()\n\tif !strings.Contains(msg, \"exited with status 1\") {\n\t\tt.Fatalf(\"Unexpected error happened: %q\", msg)\n\t}\n}\n\nfunc TestProcessCommandlineParseError(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\tcmd  string\n\t}{\n\t\t{\n\t\t\twhat: \"broken command line\",\n\t\t\tcmd:  \"'broken' 'arg\",\n\t\t},\n\t\t{\n\t\t\twhat: \"executable file not found\",\n\t\t\tcmd:  \"this-command-does-not-exist\",\n\t\t},\n\t\t{\n\t\t\twhat: \"empty\",\n\t\t\tcmd:  \"\",\n\t\t},\n\t}\n\n\tp := newConcurrentProcess(1)\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\t_, err := p.newCommandRunner(tc.cmd, true)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatalf(\"Command %q caused no error\", tc)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "project.go",
          "type": "blob",
          "size": 2.8388671875,
          "content": "package actionlint\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Project represents one GitHub project. One Git repository corresponds to one project.\ntype Project struct {\n\troot   string\n\tconfig *Config\n}\n\nfunc absPath(path string) string {\n\tif p, err := filepath.Abs(path); err == nil {\n\t\tpath = p\n\t}\n\treturn path\n}\n\n// findProject creates new Project instance by finding a project which the given path belongs to.\n// A project must be a Git repository and have \".github/workflows\" directory.\nfunc findProject(path string) (*Project, error) {\n\td := absPath(path)\n\tfor {\n\t\tif s, err := os.Stat(filepath.Join(d, \".github\", \"workflows\")); err == nil && s.IsDir() {\n\t\t\tif _, err := os.Stat(filepath.Join(d, \".git\")); err == nil { // Note: .git may be a file\n\t\t\t\treturn NewProject(d)\n\t\t\t}\n\t\t}\n\n\t\tp := filepath.Dir(d)\n\t\tif p == d {\n\t\t\treturn nil, nil\n\t\t}\n\t\td = p\n\t}\n}\n\n// NewProject creates a new instance with a file path to the root directory of the repository.\n// This function returns an error when failing to parse an actionlint config file in the repository.\nfunc NewProject(root string) (*Project, error) {\n\tc, err := loadRepoConfig(root)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &Project{root, c}, nil\n}\n\n// RootDir returns a root directory path of the GitHub project repository.\nfunc (p *Project) RootDir() string {\n\treturn p.root\n}\n\n// WorkflowsDir returns a \".github/workflows\" directory path of the GitHub project repository.\n// This method does not check if the directory exists.\nfunc (p *Project) WorkflowsDir() string {\n\treturn filepath.Join(p.root, \".github\", \"workflows\")\n}\n\n// Knows returns true when the project knows the given file. When a file is included in the\n// project's directory, the project knows the file.\nfunc (p *Project) Knows(path string) bool {\n\t// TODO: strings.HasPrefix is not perfect to check file path\n\treturn strings.HasPrefix(absPath(path), p.root)\n}\n\n// Config returns config object of the GitHub project repository. The config file was read from\n// \".github/actionlint.yaml\" or \".github/actionlint.yml\" when this Project instance was created.\n// When no config was found, this method returns nil.\nfunc (p *Project) Config() *Config {\n\t// Note: Calling this method must be thread safe (#333)\n\treturn p.config\n}\n\n// Projects represents set of projects. It caches Project instances which was created previously\n// and reuses them.\ntype Projects struct {\n\tknown []*Project\n}\n\n// NewProjects creates new Projects instance.\nfunc NewProjects() *Projects {\n\treturn &Projects{}\n}\n\n// At returns the Project instance which the path belongs to. It returns nil if no project is found\n// from the path.\nfunc (ps *Projects) At(path string) (*Project, error) {\n\tfor _, p := range ps.known {\n\t\tif p.Knows(path) {\n\t\t\treturn p, nil\n\t\t}\n\t}\n\n\tp, err := findProject(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif p != nil {\n\t\tps.known = append(ps.known, p)\n\t}\n\n\treturn p, nil\n}\n"
        },
        {
          "name": "project_test.go",
          "type": "blob",
          "size": 3.5126953125,
          "content": "package actionlint\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// Create `.git` directory since actionlint finds the directory to detect the repository root.\n// Without creating this directory, this test case will fail when `actionlint/.git` directory\n// doesn't exist. When cloning actionlint repository with Git, it never happens. However, when\n// downloading sources tarball from github.com, it doesn't contain `.git` directory so it\n// happens. Please see #307 for more details.\nfunc testEnsureDotGitDir(dir string) {\n\td := filepath.Join(dir, \".git\")\n\tif err := os.MkdirAll(d, 0750); err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TestProjectsFindProjectFromPath(t *testing.T) {\n\td := filepath.Join(\"testdata\", \"find_project\")\n\tabs, err := filepath.Abs(d)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttestEnsureDotGitDir(d)\n\n\tps := NewProjects()\n\tfor _, tc := range []struct {\n\t\twhat string\n\t\tpath string\n\t}{\n\t\t{\n\t\t\twhat: \"project root\",\n\t\t\tpath: d,\n\t\t},\n\t\t{\n\t\t\twhat: \"workflows directory\",\n\t\t\tpath: filepath.Join(d, \".github\", \"workflows\"),\n\t\t},\n\t\t{\n\t\t\twhat: \"workflow file\",\n\t\t\tpath: filepath.Join(d, \".github\", \"workflows\", \"test.yaml\"),\n\t\t},\n\t\t{\n\t\t\twhat: \"outside workflows directory\",\n\t\t\tpath: filepath.Join(d, \".github\", \"reusable\", \"broken.yaml\"),\n\t\t},\n\t\t{\n\t\t\twhat: \"directory outside .github\",\n\t\t\tpath: filepath.Join(d, \"foo\"),\n\t\t},\n\t\t{\n\t\t\twhat: \"file outside .github\",\n\t\t\tpath: filepath.Join(d, \"foo\", \"test.txt\"),\n\t\t},\n\t} {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tp, err := ps.At(tc.path)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tr := p.RootDir()\n\t\t\tif r != abs {\n\t\t\t\tt.Fatalf(\"root directory of project %v should be %q but got %q\", p, abs, r)\n\t\t\t}\n\n\t\t\t// Result should be cached\n\t\t\tp2, err := ps.At(tc.path)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif p != p2 {\n\t\t\t\tt.Fatalf(\"project %v is not cached. New project is %v. %p v.s. %p\", p, p2, p, p2)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestProjectsDoesNotFindProjectFromOutside(t *testing.T) {\n\td := filepath.Join(\"testdata\", \"find_project\")\n\tabs, err := filepath.Abs(d)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttestEnsureDotGitDir(d)\n\n\toutside := filepath.Join(d, \"..\")\n\tps := NewProjects()\n\tp, err := ps.At(outside)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif p != nil && p.RootDir() == abs {\n\t\tt.Fatalf(\"project %v is detected from outside of the project %q\", p, outside)\n\t}\n}\n\nfunc TestProjectsLoadProjectConfig(t *testing.T) {\n\tfor _, n := range []string{\"ok\", \"yml\"} {\n\t\td := filepath.Join(\"testdata\", \"config\", \"projects\", n)\n\t\ttestEnsureDotGitDir(d)\n\t\tps := NewProjects()\n\t\tp, err := ps.At(d)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif p == nil {\n\t\t\tt.Fatal(\"project was not found at\", d)\n\t\t}\n\t\tif c := p.Config(); c == nil {\n\t\t\tt.Fatal(\"config was not found for directory\", d)\n\t\t}\n\t}\n}\n\nfunc TestProjectsLoadingNoProjectConfig(t *testing.T) {\n\td := filepath.Join(\"testdata\", \"config\", \"projects\", \"none\")\n\ttestEnsureDotGitDir(d)\n\tps := NewProjects()\n\tp, err := ps.At(d)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif p == nil {\n\t\tt.Fatal(\"project was not found at\", d)\n\t}\n\tif c := p.Config(); c != nil {\n\t\tt.Fatal(\"config was found for directory\", d)\n\t}\n}\n\nfunc TestProjectsLoadingBrokenProjectConfig(t *testing.T) {\n\twant := \"could not parse config file\"\n\td := filepath.Join(\"testdata\", \"config\", \"projects\", \"err\")\n\ttestEnsureDotGitDir(d)\n\tps := NewProjects()\n\tp, err := ps.At(d)\n\tif err == nil {\n\t\tt.Fatalf(\"wanted error %q but have no error\", want)\n\t}\n\tif p != nil {\n\t\tt.Fatal(\"project was returned though getting config failed\", p)\n\t}\n\tif msg := err.Error(); !strings.Contains(msg, want) {\n\t\tt.Fatalf(\"wanted error %q but have error %q\", want, msg)\n\t}\n}\n"
        },
        {
          "name": "quotes.go",
          "type": "blob",
          "size": 1.41796875,
          "content": "package actionlint\n\nimport (\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype quotesBuilder struct {\n\tinner strings.Builder\n\tbuf   []byte\n\tcomma bool\n}\n\nfunc (b *quotesBuilder) append(s string) {\n\tif b.comma {\n\t\tb.inner.WriteString(\", \")\n\t} else {\n\t\tb.comma = true\n\t}\n\tb.buf = strconv.AppendQuote(b.buf[:0], s)\n\tb.inner.Write(b.buf)\n}\n\nfunc (b *quotesBuilder) appendRune(r rune) {\n\tif b.comma {\n\t\tb.inner.WriteString(\", \")\n\t} else {\n\t\tb.comma = true\n\t}\n\tb.buf = strconv.AppendQuoteRune(b.buf[:0], r)\n\tb.inner.Write(b.buf)\n}\n\nfunc (b *quotesBuilder) build() string {\n\treturn b.inner.String()\n}\n\nfunc quotes(ss []string) string {\n\tl := len(ss)\n\tif l == 0 {\n\t\treturn \"\"\n\t}\n\tn, max := 0, 0\n\tfor _, s := range ss {\n\t\tm := len(s) + 2 // 2 for delims\n\t\tn += m\n\t\tif m > max {\n\t\t\tmax = m\n\t\t}\n\t}\n\tn += (l - 1) * 2 // comma\n\tb := quotesBuilder{}\n\tb.buf = make([]byte, 0, max)\n\tb.inner.Grow(n)\n\tfor _, s := range ss {\n\t\tb.append(s)\n\t}\n\treturn b.build()\n}\n\nfunc sortedQuotes(ss []string) string {\n\tsort.Strings(ss)\n\treturn quotes(ss)\n}\n\nfunc quotesAll(sss ...[]string) string {\n\tn, max := 0, 0\n\tfor _, ss := range sss {\n\t\tfor _, s := range ss {\n\t\t\tm := len(s) + 2 // 2 for delims\n\t\t\tn += m\n\t\t\tif m > max {\n\t\t\t\tmax = m\n\t\t\t}\n\t\t}\n\t\tn += (len(ss) - 1) * 2 // comma\n\t}\n\tb := quotesBuilder{}\n\tb.buf = make([]byte, 0, max)\n\tn += (len(sss) - 1) * 2 // comma\n\tif n > 0 {\n\t\tb.inner.Grow(n)\n\t}\n\tfor _, ss := range sss {\n\t\tfor _, s := range ss {\n\t\t\tb.append(s)\n\t\t}\n\t}\n\treturn b.build()\n}\n"
        },
        {
          "name": "quotes_test.go",
          "type": "blob",
          "size": 1.609375,
          "content": "package actionlint\n\nimport (\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestQuotesSortedQuotes(t *testing.T) {\n\ttestCases := [][]string{\n\t\t{},\n\t\t{\"foo\"},\n\t\t{\"foo\", \"bar\", \"piyo\"},\n\t\t{\"\\n\", \"\\t\"},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tss := tc[:]\n\t\t\tsort.Strings(ss)\n\t\t\tqs := make([]string, 0, len(ss))\n\t\t\tfor _, s := range tc {\n\t\t\t\tqs = append(qs, strconv.Quote(s))\n\t\t\t}\n\t\t\twant := strings.Join(qs, \", \")\n\t\t\thave := sortedQuotes(tc)\n\t\t\tif want != have {\n\t\t\t\tt.Errorf(\"want: %s\\nhave: %s\", want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestQuotesQuotesRunes(t *testing.T) {\n\ttestCases := [][]rune{\n\t\t{},\n\t\t{'a'},\n\t\t{'a', 'b', 'c'},\n\t\t{'\\n', '\\t', '\\\\'},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tqs := make([]string, 0, len(tc))\n\t\t\tfor _, r := range tc {\n\t\t\t\tqs = append(qs, strconv.QuoteRune(r))\n\t\t\t}\n\t\t\twant := strings.Join(qs, \", \")\n\t\t\tqb := quotesBuilder{}\n\t\t\tfor _, r := range tc {\n\t\t\t\tqb.appendRune(r)\n\t\t\t}\n\t\t\thave := qb.build()\n\t\t\tif want != have {\n\t\t\t\tt.Errorf(\"want: %s\\nhave: %s\", want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestQuotesQuotesAll(t *testing.T) {\n\ttestCases := [][][]string{\n\t\t{{}},\n\t\t{{\"foo\"}},\n\t\t{{\"foo\", \"bar\"}},\n\t\t{{\"foo\"}, {\"bar\"}},\n\t\t{{}, {\"foo\"}, {\"bar\", \"piyo\"}},\n\t\t{{\"\\n\", \"\\t\"}, {\"\\v\"}, {}},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(strconv.Itoa(i), func(t *testing.T) {\n\t\t\tqs := []string{}\n\t\t\tfor _, ss := range tc {\n\t\t\t\tfor _, s := range ss {\n\t\t\t\t\tqs = append(qs, strconv.Quote(s))\n\t\t\t\t}\n\t\t\t}\n\t\t\twant := strings.Join(qs, \", \")\n\t\t\thave := quotesAll(tc...)\n\t\t\tif want != have {\n\t\t\t\tt.Errorf(\"want: %s\\nhave: %s\", want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "reusable_workflow.go",
          "type": "blob",
          "size": 12.44140625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"gopkg.in/yaml.v3\"\n)\n\nfunc expectedMapping(where string, n *yaml.Node) error {\n\treturn fmt.Errorf(\n\t\t\"yaml: %s must be mapping node but %s node was found at line:%d, col:%d\",\n\t\twhere,\n\t\tnodeKindName(n.Kind),\n\t\tn.Line,\n\t\tn.Column,\n\t)\n}\n\n// ReusableWorkflowMetadataInput is an input metadata for validating local reusable workflow file.\ntype ReusableWorkflowMetadataInput struct {\n\t// Name is a name of the input defined in the reusable workflow.\n\tName string\n\t// Required is true when 'required' field of the input is set to true and no default value is set.\n\tRequired bool\n\t// Type is a type of the input. When the input type is unknown, 'any' type is set.\n\tType ExprType\n}\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (input *ReusableWorkflowMetadataInput) UnmarshalYAML(n *yaml.Node) error {\n\ttype metadata struct {\n\t\tRequired bool    `yaml:\"required\"`\n\t\tDefault  *string `yaml:\"default\"`\n\t\tType     string  `yaml:\"type\"`\n\t}\n\n\tvar md metadata\n\tif err := n.Decode(&md); err != nil {\n\t\treturn err\n\t}\n\n\tinput.Required = md.Required && md.Default == nil\n\tswitch md.Type {\n\tcase \"boolean\":\n\t\tinput.Type = BoolType{}\n\tcase \"number\":\n\t\tinput.Type = NumberType{}\n\tcase \"string\":\n\t\tinput.Type = StringType{}\n\tdefault:\n\t\tinput.Type = AnyType{}\n\t}\n\n\treturn nil\n}\n\n// ReusableWorkflowMetadataInputs is a map from input name to reusable wokflow input metadata. The\n// keys are in lower case since input names of workflow calls are case insensitive.\ntype ReusableWorkflowMetadataInputs map[string]*ReusableWorkflowMetadataInput\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (inputs *ReusableWorkflowMetadataInputs) UnmarshalYAML(n *yaml.Node) error {\n\tif n.Kind != yaml.MappingNode {\n\t\treturn expectedMapping(\"on.workflow_call.inputs\", n)\n\t}\n\n\tmd := make(ReusableWorkflowMetadataInputs, len(n.Content)/2)\n\tfor i := 0; i < len(n.Content); i += 2 {\n\t\tk, v := n.Content[i], n.Content[i+1]\n\n\t\tvar m ReusableWorkflowMetadataInput\n\t\tif err := v.Decode(&m); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm.Name = k.Value\n\t\tif m.Type == nil {\n\t\t\tm.Type = AnyType{} // Reach here when `v` is null node\n\t\t}\n\n\t\tmd[strings.ToLower(k.Value)] = &m\n\t}\n\n\t*inputs = md\n\treturn nil\n}\n\n// ReusableWorkflowMetadataSecret is a secret metadata for validating local reusable workflow file.\ntype ReusableWorkflowMetadataSecret struct {\n\t// Name is a name of the secret in the reusable workflow.\n\tName string\n\t// Required indicates whether the secret is required by its reusable workflow. When this value\n\t// is true, workflow calls must set this secret unless secrets are not inherited.\n\tRequired bool `yaml:\"required\"`\n}\n\n// ReusableWorkflowMetadataSecrets is a map from secret name to reusable wokflow secret metadata.\n// The keys are in lower case since secret names of workflow calls are case insensitive.\ntype ReusableWorkflowMetadataSecrets map[string]*ReusableWorkflowMetadataSecret\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (secrets *ReusableWorkflowMetadataSecrets) UnmarshalYAML(n *yaml.Node) error {\n\tif n.Kind != yaml.MappingNode {\n\t\treturn expectedMapping(\"on.workflow_call.secrets\", n)\n\t}\n\n\tmd := make(ReusableWorkflowMetadataSecrets, len(n.Content)/2)\n\tfor i := 0; i < len(n.Content); i += 2 {\n\t\tk, v := n.Content[i], n.Content[i+1]\n\n\t\tvar s ReusableWorkflowMetadataSecret\n\t\tif err := v.Decode(&s); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts.Name = k.Value\n\n\t\tmd[strings.ToLower(k.Value)] = &s\n\t}\n\n\t*secrets = md\n\treturn nil\n}\n\n// ReusableWorkflowMetadataOutput is an output metadata for validating local reusable workflow file.\ntype ReusableWorkflowMetadataOutput struct {\n\t// Name is a name of the output in the reusable workflow.\n\tName string\n}\n\n// ReusableWorkflowMetadataOutputs is a map from output name to reusable wokflow output metadata.\n// The keys are in lower case since output names of workflow calls are case insensitive.\ntype ReusableWorkflowMetadataOutputs map[string]*ReusableWorkflowMetadataOutput\n\n// UnmarshalYAML implements yaml.Unmarshaler.\nfunc (outputs *ReusableWorkflowMetadataOutputs) UnmarshalYAML(n *yaml.Node) error {\n\tif n.Kind != yaml.MappingNode {\n\t\treturn expectedMapping(\"on.workflow_call.outputs\", n)\n\t}\n\n\tmd := make(ReusableWorkflowMetadataOutputs, len(n.Content)/2)\n\tfor i := 0; i < len(n.Content); i += 2 {\n\t\tk := n.Content[i]\n\t\tmd[strings.ToLower(k.Value)] = &ReusableWorkflowMetadataOutput{\n\t\t\tName: k.Value,\n\t\t}\n\t}\n\n\t*outputs = md\n\treturn nil\n}\n\n// ReusableWorkflowMetadata is metadata to validate local reusable workflows. This struct does not\n// contain all metadata from YAML file. It only contains metadata which is necessary to validate\n// reusable workflow files by actionlint.\ntype ReusableWorkflowMetadata struct {\n\tInputs  ReusableWorkflowMetadataInputs  `yaml:\"inputs\"`\n\tOutputs ReusableWorkflowMetadataOutputs `yaml:\"outputs\"`\n\tSecrets ReusableWorkflowMetadataSecrets `yaml:\"secrets\"`\n}\n\n// LocalReusableWorkflowCache is a cache for local reusable workflow metadata files. It avoids find/read/parse\n// local reusable workflow YAML files. This cache is dedicated for a single project (repository)\n// indicated by 'proj' field. One LocalReusableWorkflowCache instance needs to be created per one\n// project.\ntype LocalReusableWorkflowCache struct {\n\tmu    sync.RWMutex\n\tproj  *Project // maybe nil\n\tcache map[string]*ReusableWorkflowMetadata\n\tcwd   string\n\tdbg   io.Writer\n}\n\nfunc (c *LocalReusableWorkflowCache) debug(format string, args ...interface{}) {\n\tif c.dbg == nil {\n\t\treturn\n\t}\n\tformat = \"[LocalReusableWorkflowCache] \" + format + \"\\n\"\n\tfmt.Fprintf(c.dbg, format, args...)\n}\n\nfunc (c *LocalReusableWorkflowCache) readCache(key string) (*ReusableWorkflowMetadata, bool) {\n\tc.mu.RLock()\n\tm, ok := c.cache[key]\n\tc.mu.RUnlock()\n\treturn m, ok\n}\n\nfunc (c *LocalReusableWorkflowCache) writeCache(key string, val *ReusableWorkflowMetadata) {\n\tc.mu.Lock()\n\tc.cache[key] = val\n\tc.mu.Unlock()\n}\n\n// FindMetadata finds/parses a reusable workflow metadata located by the 'spec' argument. When project\n// is not set to 'proj' field or the spec does not start with \"./\", this method immediately returns with nil.\n//\n// Note that an error is not cached. At first search, let's say this method returned an error since\n// the reusable workflow is invalid. In this case, calling this method with the same spec later will\n// not return the error again. It just will return nil. This behavior prevents repeating to report\n// the same error from multiple places.\n//\n// Calling this method is thread-safe.\nfunc (c *LocalReusableWorkflowCache) FindMetadata(spec string) (*ReusableWorkflowMetadata, error) {\n\tif c.proj == nil || !strings.HasPrefix(spec, \"./\") || ContainsExpression(spec) {\n\t\treturn nil, nil\n\t}\n\n\tif m, ok := c.readCache(spec); ok {\n\t\tc.debug(\"Cache hit for %s: %v\", spec, m)\n\t\treturn m, nil\n\t}\n\n\tfile := filepath.Join(c.proj.RootDir(), filepath.FromSlash(spec))\n\tsrc, err := os.ReadFile(file)\n\tif err != nil {\n\t\tc.writeCache(spec, nil) // Remember the workflow file was not found\n\t\treturn nil, fmt.Errorf(\"could not read reusable workflow file for %q: %w\", spec, err)\n\t}\n\n\tm, err := parseReusableWorkflowMetadata(src)\n\tif err != nil {\n\t\tc.writeCache(spec, nil) // Remember the workflow file was invalid\n\t\tmsg := strings.ReplaceAll(err.Error(), \"\\n\", \" \")\n\t\treturn nil, fmt.Errorf(\"error while parsing reusable workflow %q: %s\", spec, msg)\n\t}\n\n\tc.debug(\"New reusable workflow metadata at %s: %v\", file, m)\n\tc.writeCache(spec, m)\n\treturn m, nil\n}\n\nfunc (c *LocalReusableWorkflowCache) convWorkflowPathToSpec(p string) (string, bool) {\n\tif c.proj == nil {\n\t\treturn \"\", false\n\t}\n\tif !filepath.IsAbs(p) {\n\t\tp = filepath.Join(c.cwd, p)\n\t}\n\tr := c.proj.RootDir()\n\tif !strings.HasPrefix(p, r) {\n\t\treturn \"\", false\n\t}\n\tp, err := filepath.Rel(r, p)\n\tif err != nil {\n\t\treturn \"\", false // Unreachable\n\t}\n\tp = filepath.ToSlash(p)\n\tif !strings.HasPrefix(p, \"./\") {\n\t\tp = \"./\" + p\n\t}\n\treturn p, true\n}\n\n// WriteWorkflowCallEvent writes reusable workflow metadata by converting from WorkflowCallEvent AST\n// node. The 'wpath' parameter is a path to the workflow file of the AST, which is a relative to the\n// project root directory or an absolute path.\n// This method does nothing when (1) no project is set, (2) it could not convert the workflow path\n// to workflow call spec, (3) some cache for the workflow is already existing.\n// This method is thread safe.\nfunc (c *LocalReusableWorkflowCache) WriteWorkflowCallEvent(wpath string, event *WorkflowCallEvent) {\n\t// Convert workflow path to workflow call spec\n\tspec, ok := c.convWorkflowPathToSpec(wpath)\n\tif !ok {\n\t\treturn\n\t}\n\tc.debug(\"Workflow call spec from workflow path %s: %s\", wpath, spec)\n\n\tc.mu.RLock()\n\t_, ok = c.cache[spec]\n\tc.mu.RUnlock()\n\tif ok {\n\t\treturn\n\t}\n\n\tm := &ReusableWorkflowMetadata{\n\t\tInputs:  ReusableWorkflowMetadataInputs{},\n\t\tOutputs: ReusableWorkflowMetadataOutputs{},\n\t\tSecrets: ReusableWorkflowMetadataSecrets{},\n\t}\n\n\tfor _, i := range event.Inputs {\n\t\tvar t ExprType = AnyType{}\n\t\tswitch i.Type {\n\t\tcase WorkflowCallEventInputTypeBoolean:\n\t\t\tt = BoolType{}\n\t\tcase WorkflowCallEventInputTypeNumber:\n\t\t\tt = NumberType{}\n\t\tcase WorkflowCallEventInputTypeString:\n\t\t\tt = StringType{}\n\t\t}\n\t\tm.Inputs[i.ID] = &ReusableWorkflowMetadataInput{\n\t\t\tType:     t,\n\t\t\tRequired: i.Required != nil && i.Required.Value && i.Default == nil,\n\t\t\tName:     i.Name.Value,\n\t\t}\n\t}\n\n\tfor n, o := range event.Outputs {\n\t\tm.Outputs[n] = &ReusableWorkflowMetadataOutput{\n\t\t\tName: o.Name.Value,\n\t\t}\n\t}\n\n\tfor n, s := range event.Secrets {\n\t\tr := s.Required != nil && s.Required.Value\n\t\tm.Secrets[n] = &ReusableWorkflowMetadataSecret{\n\t\t\tRequired: r,\n\t\t\tName:     s.Name.Value,\n\t\t}\n\t}\n\n\tc.mu.Lock()\n\tc.cache[spec] = m\n\tc.mu.Unlock()\n\n\tc.debug(\"Workflow call metadata from workflow %s: %v\", wpath, m)\n}\n\nfunc parseReusableWorkflowMetadata(src []byte) (*ReusableWorkflowMetadata, error) {\n\ttype workflow struct {\n\t\tOn yaml.Node `yaml:\"on\"`\n\t}\n\n\tvar w workflow\n\tif err := yaml.Unmarshal(src, &w); err != nil {\n\t\treturn nil, err // Unreachable\n\t}\n\n\tn := &w.On\n\tif n.Line == 0 && n.Column == 0 {\n\t\treturn nil, fmt.Errorf(\"\\\"on:\\\" is not found\")\n\t}\n\n\tswitch n.Kind {\n\tcase yaml.MappingNode:\n\t\t// on:\n\t\t//   workflow_call:\n\t\tfor i := 0; i < len(n.Content); i += 2 {\n\t\t\tk := strings.ToLower(n.Content[i].Value)\n\t\t\tif k == \"workflow_call\" {\n\t\t\t\tvar m ReusableWorkflowMetadata\n\t\t\t\tif err := n.Content[i+1].Decode(&m); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn &m, nil\n\t\t\t}\n\t\t}\n\tcase yaml.ScalarNode:\n\t\t// on: workflow_call\n\t\tif v := strings.ToLower(n.Value); v == \"workflow_call\" {\n\t\t\treturn &ReusableWorkflowMetadata{}, nil\n\t\t}\n\tcase yaml.SequenceNode:\n\t\t// on: [workflow_call]\n\t\tfor _, c := range n.Content {\n\t\t\te := strings.ToLower(c.Value)\n\t\t\tif e == \"workflow_call\" {\n\t\t\t\treturn &ReusableWorkflowMetadata{}, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, fmt.Errorf(\"\\\"workflow_call\\\" event trigger is not found in \\\"on:\\\" at line:%d, column:%d\", n.Line, n.Column)\n}\n\n// NewLocalReusableWorkflowCache creates a new LocalReusableWorkflowCache instance for the given\n// project. 'cwd' is a current working directory as an absolute file path. The 'Local' means that\n// the cache instance is project-local. It is not available across multiple projects.\nfunc NewLocalReusableWorkflowCache(proj *Project, cwd string, dbg io.Writer) *LocalReusableWorkflowCache {\n\treturn &LocalReusableWorkflowCache{\n\t\tproj:  proj,\n\t\tcache: map[string]*ReusableWorkflowMetadata{},\n\t\tcwd:   cwd,\n\t\tdbg:   dbg,\n\t}\n}\n\nfunc newNullLocalReusableWorkflowCache(dbg io.Writer) *LocalReusableWorkflowCache {\n\t// Null cache. Cache never hits. It is used when project is not found\n\treturn &LocalReusableWorkflowCache{dbg: dbg}\n}\n\n// LocalReusableWorkflowCacheFactory is a factory object to create a LocalReusableWorkflowCache\n// instance per project.\ntype LocalReusableWorkflowCacheFactory struct {\n\tcaches map[string]*LocalReusableWorkflowCache\n\tcwd    string\n\tdbg    io.Writer\n}\n\n// NewLocalReusableWorkflowCacheFactory creates a new LocalReusableWorkflowCacheFactory instance.\nfunc NewLocalReusableWorkflowCacheFactory(cwd string, dbg io.Writer) *LocalReusableWorkflowCacheFactory {\n\treturn &LocalReusableWorkflowCacheFactory{map[string]*LocalReusableWorkflowCache{}, cwd, dbg}\n}\n\n// GetCache returns a new or existing LocalReusableWorkflowCache instance per project. When a instance\n// was already created for the project, this method returns the existing instance. Otherwise it creates\n// a new instance and returns it.\nfunc (f *LocalReusableWorkflowCacheFactory) GetCache(p *Project) *LocalReusableWorkflowCache {\n\tif p == nil {\n\t\treturn newNullLocalReusableWorkflowCache(f.dbg)\n\t}\n\tr := p.RootDir()\n\tif c, ok := f.caches[r]; ok {\n\t\treturn c\n\t}\n\tc := NewLocalReusableWorkflowCache(p, f.cwd, f.dbg)\n\tf.caches[r] = c\n\treturn c\n}\n"
        },
        {
          "name": "reusable_workflow_test.go",
          "type": "blob",
          "size": 20.6943359375,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestReusableWorkflowUnmarshalOK(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\tsrc  string\n\t\twant *ReusableWorkflowMetadata\n\t}{\n\t\t{\n\t\t\twhat: \"minimal\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t    inputs:\n\t\t\t      i:\n\t\t\t        type: string\n\t\t\t    outputs:\n\t\t\t      o:\n\t\t\t        value: foo\n\t\t\t    secrets:\n\t\t\t      x:\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\t\t\"i\": {\"i\", false, StringType{}},\n\t\t\t\t},\n\t\t\t\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\t\t\t\"o\": {\"o\"},\n\t\t\t\t},\n\t\t\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\t\t\"x\": {\"x\", false},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"empty\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs:  nil,\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"empty values\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t    inputs:\n\t\t\t    outputs:\n\t\t\t    secrets:\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs:  nil,\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"inputs\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t    inputs:\n\t\t\t      a:\n\t\t\t        type: string\n\t\t\t      b:\n\t\t\t        type: number\n\t\t\t      c:\n\t\t\t        type: boolean\n\t\t\t      d:\n\t\t\t      e:\n\t\t\t        type: string\n\t\t\t        required: false\n\t\t\t      f:\n\t\t\t        type: string\n\t\t\t        required: true\n\t\t\t      g:\n\t\t\t        type: string\n\t\t\t        default: abc\n\t\t\t      h:\n\t\t\t        type: string\n\t\t\t        default: abc\n\t\t\t        required: true\n\t\t\t      i:\n\t\t\t        required: true\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\t\t\"a\": {\"a\", false, StringType{}},\n\t\t\t\t\t\"b\": {\"b\", false, NumberType{}},\n\t\t\t\t\t\"c\": {\"c\", false, BoolType{}},\n\t\t\t\t\t\"d\": {\"d\", false, AnyType{}},\n\t\t\t\t\t\"e\": {\"e\", false, StringType{}},\n\t\t\t\t\t\"f\": {\"f\", true, StringType{}},\n\t\t\t\t\t\"g\": {\"g\", false, StringType{}},\n\t\t\t\t\t\"h\": {\"h\", false, StringType{}},\n\t\t\t\t\t\"i\": {\"i\", true, AnyType{}},\n\t\t\t\t},\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"outputs\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t    inputs:\n\t\t\t      i:\n\t\t\t        type: string\n\t\t\t    outputs:\n\t\t\t      o:\n\t\t\t        value: foo\n\t\t\t    secrets:\n\t\t\t      x:\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\t\t\"i\": {\"i\", false, StringType{}},\n\t\t\t\t},\n\t\t\t\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\t\t\t\"o\": {\"o\"},\n\t\t\t\t},\n\t\t\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\t\t\"x\": {\"x\", false},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"secrets\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t    secrets:\n\t\t\t      x:\n\t\t\t      y:\n\t\t\t        required: false\n\t\t\t      z:\n\t\t\t        required: true\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs:  nil,\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\t\t\"x\": {\"x\", false},\n\t\t\t\t\t\"y\": {\"y\", false},\n\t\t\t\t\t\"z\": {\"z\", true},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"empty event in scalar node\",\n\t\t\tsrc: `\n\t\t\ton: workflow_call\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs:  nil,\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"empty event in sequence node\",\n\t\t\tsrc: `\n\t\t\ton: [workflow_call]\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs:  nil,\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"empty event in sequence node with other events\",\n\t\t\tsrc: `\n\t\t\ton: [pull_request, workflow_call, push]\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs:  nil,\n\t\t\t\tOutputs: nil,\n\t\t\t\tSecrets: nil,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"upper case\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  workflow_call:\n\t\t\t    inputs:\n\t\t\t      MY_INPUT1:\n\t\t\t        type: string\n\t\t\t      MY_INPUT2:\n\t\t\t        type: number\n\t\t\t    outputs:\n\t\t\t      MY_OUTPUT1:\n\t\t\t        value: foo\n\t\t\t      MY_OUTPUT2:\n\t\t\t        value: foo\n\t\t\t    secrets:\n\t\t\t      MY_SECRET1:\n\t\t\t      MY_SECRET2:\n\t\t\t        required: true\n\t\t\t`,\n\t\t\twant: &ReusableWorkflowMetadata{\n\t\t\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\t\t\"my_input1\": {\"MY_INPUT1\", false, StringType{}},\n\t\t\t\t\t\"my_input2\": {\"MY_INPUT2\", false, NumberType{}},\n\t\t\t\t},\n\t\t\t\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\t\t\t\"my_output1\": {\"MY_OUTPUT1\"},\n\t\t\t\t\t\"my_output2\": {\"MY_OUTPUT2\"},\n\t\t\t\t},\n\t\t\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\t\t\"my_secret1\": {\"MY_SECRET1\", false},\n\t\t\t\t\t\"my_secret2\": {\"MY_SECRET2\", true},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tsrc := strings.TrimSpace(tc.src)\n\t\t\tsrc = strings.ReplaceAll(src, \"\\t\", \"\")\n\n\t\t\tm, err := parseReusableWorkflowMetadata([]byte(src))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(m, tc.want); diff != \"\" {\n\t\t\t\tt.Fatal(\"Parse result is unexpected. diff:\\n\" + diff)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowUnmarshalOnNodeNotFound(t *testing.T) {\n\tsrc := \"hello: world\"\n\t_, err := parseReusableWorkflowMetadata([]byte(src))\n\tif err == nil {\n\t\tt.Fatal(\"Error did not happen\")\n\t}\n\tif msg := err.Error(); msg != \"\\\"on:\\\" is not found\" {\n\t\tt.Fatal(\"Unexpected error:\", msg)\n\t}\n}\n\nfunc TestReusableWorkflowUnmarshalEventNotFound(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\tsrc  string\n\t\tline int\n\t\tcol  int\n\t}{\n\t\t{\n\t\t\twhat: \"scalar\",\n\t\t\tsrc: `\n\t\t\ton: push\n\t\t\t`,\n\t\t\tline: 1,\n\t\t\tcol:  5,\n\t\t},\n\t\t{\n\t\t\twhat: \"sequence\",\n\t\t\tsrc: `\n\t\t\ton: [push, pull_request]\n\t\t\t`,\n\t\t\tline: 1,\n\t\t\tcol:  5,\n\t\t},\n\t\t{\n\t\t\twhat: \"empty sequence\",\n\t\t\tsrc: `\n\t\t\ton: []\n\t\t\t`,\n\t\t\tline: 1,\n\t\t\tcol:  5,\n\t\t},\n\t\t{\n\t\t\twhat: \"mapping\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t  push:\n\t\t\t  pull_request:\n\t\t\t`,\n\t\t\tline: 2,\n\t\t\tcol:  3,\n\t\t},\n\t\t{\n\t\t\twhat: \"empty mapping\",\n\t\t\tsrc: `\n\t\t\ton: {}\n\t\t\t`,\n\t\t\tline: 1,\n\t\t\tcol:  5,\n\t\t},\n\t\t{\n\t\t\twhat: \"null\",\n\t\t\tsrc: `\n\t\t\ton:\n\t\t\t`,\n\t\t\tline: 1,\n\t\t\tcol:  4,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tsrc := strings.TrimSpace(tc.src)\n\t\t\tsrc = strings.ReplaceAll(src, \"\\t\", \"\")\n\n\t\t\t_, err := parseReusableWorkflowMetadata([]byte(src))\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"Error did not happen\")\n\t\t\t}\n\n\t\t\tmsg := err.Error()\n\t\t\tif !strings.Contains(msg, \"\\\"workflow_call\\\" event trigger is not found in \\\"on:\\\"\") {\n\t\t\t\tt.Fatal(\"Unexpected error:\", msg)\n\t\t\t}\n\t\t\tloc := fmt.Sprintf(\"line:%d, column:%d\", tc.line, tc.col)\n\t\t\tif !strings.Contains(msg, loc) {\n\t\t\t\tt.Fatalf(\"location is not %q: %s\", loc, msg)\n\t\t\t}\n\t\t})\n\t}\n}\n\nvar testReusableWorkflowWantedMetadata *ReusableWorkflowMetadata = &ReusableWorkflowMetadata{\n\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\"input1\": {\"input1\", false, StringType{}},\n\t\t\"input2\": {\"input2\", true, BoolType{}},\n\t},\n\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\"output1\": {\"output1\"},\n\t},\n\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\"secret1\": {\"secret1\", false},\n\t\t\"secret2\": {\"secret2\", true},\n\t},\n}\n\nfunc TestReusableWorkflowCacheFindMetadataOK(t *testing.T) {\n\tproj := &Project{filepath.Join(\"testdata\", \"reusable_workflow_metadata\"), nil}\n\tc := NewLocalReusableWorkflowCache(proj, \"\", nil)\n\n\tm, err := c.FindMetadata(\"./ok.yaml\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif diff := cmp.Diff(m, testReusableWorkflowWantedMetadata); diff != \"\" {\n\t\tt.Fatal(diff)\n\t}\n\n\tm2, err := c.FindMetadata(\"./ok.yaml\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif m != m2 {\n\t\tt.Error(\"metadata is not cached\")\n\t}\n}\n\nfunc TestReusableWorkflowCacheFindMetadataError(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\tspec string\n\t\twant string\n\t}{\n\t\t{\n\t\t\twhat: \"broken workflow\",\n\t\t\tspec: \"./broken.yaml\",\n\t\t\twant: \"error while parsing reusable workflow \\\"./broken.yaml\\\"\",\n\t\t},\n\t\t{\n\t\t\twhat: \"no hook\",\n\t\t\tspec: \"./no_hook.yaml\",\n\t\t\twant: \"\\\"workflow_call\\\" event trigger is not found in \\\"on:\\\"\",\n\t\t},\n\t\t{\n\t\t\twhat: \"no on\",\n\t\t\tspec: \"./no_on.yaml\",\n\t\t\twant: \"\\\"on:\\\" is not found\",\n\t\t},\n\t\t{\n\t\t\twhat: \"not existing workflow\",\n\t\t\tspec: \"./this-workflow-does-not-exist.yaml\",\n\t\t\twant: \"could not read reusable workflow file for \\\"./this-workflow-does-not-exist.yaml\\\":\",\n\t\t},\n\t\t{\n\t\t\twhat: \"broken inputs\",\n\t\t\tspec: \"./broken_inputs.yaml\",\n\t\t\twant: \"error while parsing reusable workflow \\\"./broken_inputs.yaml\\\"\",\n\t\t},\n\t\t{\n\t\t\twhat: \"broken secrets\",\n\t\t\tspec: \"./broken_secrets.yaml\",\n\t\t\twant: \"error while parsing reusable workflow \\\"./broken_secrets.yaml\\\"\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tproj := &Project{filepath.Join(\"testdata\", \"reusable_workflow_metadata\"), nil}\n\t\t\tc := NewLocalReusableWorkflowCache(proj, \"\", nil)\n\t\t\t_, err := c.FindMetadata(tc.spec)\n\t\t\tif err == nil {\n\t\t\t\tt.Fatal(\"no error happened\")\n\t\t\t}\n\t\t\tmsg := err.Error()\n\t\t\tif !strings.Contains(msg, tc.want) {\n\t\t\t\tt.Fatalf(\"unexpected error. wanted %q but got %q\", tc.want, msg)\n\t\t\t}\n\t\t\t// Trying to find metadata with the same spec later returns nil to avoid duplicate errors\n\t\t\tm, err := c.FindMetadata(tc.spec)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(\"error happens when finding metadata again:\", err)\n\t\t\t}\n\t\t\tif m != nil {\n\t\t\t\tt.Fatal(\"nil is not cached:\", m)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowCacheFindMetadataSkipParsing(t *testing.T) {\n\tp := &Project{filepath.Join(\"testdata\", \"reusable_workflow_metadata\"), nil}\n\ttests := []struct {\n\t\twhat string\n\t\tproj *Project\n\t\tspec string\n\t}{\n\t\t{\n\t\t\twhat: \"no project\",\n\t\t\tproj: nil,\n\t\t\tspec: \"./ok.yaml\",\n\t\t},\n\t\t{\n\t\t\twhat: \"external workflow\",\n\t\t\tproj: p,\n\t\t\tspec: \"repo/owner/workflow@main\",\n\t\t},\n\t\t{\n\t\t\twhat: \"template placeholder\",\n\t\t\tproj: p,\n\t\t\tspec: \"./${{ some_expression }}.yaml\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tc := NewLocalReusableWorkflowCache(tc.proj, \"\", nil)\n\t\t\tm, err := c.FindMetadata(tc.spec)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m != nil {\n\t\t\t\tt.Fatal(\"metadata should be nil:\", m)\n\t\t\t}\n\t\t\tm, err = c.FindMetadata(tc.spec)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tif m != nil {\n\t\t\t\tt.Fatal(\"nil is not cached:\", m)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowConvertWorkflowPathToSpec(t *testing.T) {\n\tp := &Project{filepath.Join(\"path\", \"to\", \"project\"), nil}\n\tcwd := filepath.Join(\"path\", \"to\", \"project\", \"cwd\")\n\ttests := []struct {\n\t\twhat string\n\t\tproj *Project\n\t\tpath string\n\t\twant string\n\t\tok   bool\n\t}{\n\t\t{\n\t\t\twhat: \"current dir\",\n\t\t\tproj: p,\n\t\t\tpath: filepath.Join(\"workflow.yaml\"),\n\t\t\twant: \"./cwd/workflow.yaml\",\n\t\t\tok:   true,\n\t\t},\n\t\t{\n\t\t\twhat: \"child dir\",\n\t\t\tproj: p,\n\t\t\tpath: filepath.Join(\"dir\", \"workflow.yaml\"),\n\t\t\twant: \"./cwd/dir/workflow.yaml\",\n\t\t\tok:   true,\n\t\t},\n\t\t{\n\t\t\twhat: \"parent dir\",\n\t\t\tproj: p,\n\t\t\tpath: filepath.Join(\"..\", \"dir\", \"workflow.yaml\"),\n\t\t\twant: \"./dir/workflow.yaml\",\n\t\t\tok:   true,\n\t\t},\n\t\t{\n\t\t\twhat: \"no project\",\n\t\t\tproj: nil,\n\t\t\tok:   false,\n\t\t},\n\t\t{\n\t\t\twhat: \"other project\",\n\t\t\tproj: &Project{filepath.Join(\"path\", \"to\", \"other-project\"), nil},\n\t\t\tok:   false,\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tc := NewLocalReusableWorkflowCache(tc.proj, cwd, nil)\n\t\t\ts, ok := c.convWorkflowPathToSpec(tc.path)\n\t\t\tif ok != tc.ok {\n\t\t\t\tt.Fatalf(\"should return %v but got %v (spec=%q)\", tc.ok, ok, s)\n\t\t\t}\n\t\t\tif ok && s != tc.want {\n\t\t\t\tt.Fatalf(\"wanted spec %q but got %q\", tc.want, s)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowMetadataFromASTNodeInputs(t *testing.T) {\n\ttests := []struct {\n\t\twhat   string\n\t\tinputs map[string]*WorkflowCallEventInput\n\t\twant   ReusableWorkflowMetadataInputs\n\t}{\n\t\t{\n\t\t\twhat: \"type of inputs\",\n\t\t\tinputs: map[string]*WorkflowCallEventInput{\n\t\t\t\t\"string_input\":  {Type: WorkflowCallEventInputTypeString},\n\t\t\t\t\"number_input\":  {Type: WorkflowCallEventInputTypeNumber},\n\t\t\t\t\"bool_input\":    {Type: WorkflowCallEventInputTypeBoolean},\n\t\t\t\t\"unknown_input\": {},\n\t\t\t},\n\t\t\twant: ReusableWorkflowMetadataInputs{\n\t\t\t\t\"string_input\":  {\"string_input\", false, StringType{}},\n\t\t\t\t\"number_input\":  {\"number_input\", false, NumberType{}},\n\t\t\t\t\"bool_input\":    {\"bool_input\", false, BoolType{}},\n\t\t\t\t\"unknown_input\": {\"unknown_input\", false, AnyType{}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"required or optional\",\n\t\t\tinputs: map[string]*WorkflowCallEventInput{\n\t\t\t\t\"unspecified\":  {},\n\t\t\t\t\"not_required\": {Required: &Bool{Value: false, Pos: &Pos{}}},\n\t\t\t\t\"required\":     {Required: &Bool{Value: true, Pos: &Pos{}}},\n\t\t\t\t\"required_but_default\": {\n\t\t\t\t\tRequired: &Bool{Value: true, Pos: &Pos{}},\n\t\t\t\t\tDefault:  &String{Pos: &Pos{}},\n\t\t\t\t},\n\t\t\t\t\"expression\": {\n\t\t\t\t\tRequired: &Bool{\n\t\t\t\t\t\tExpression: &String{Pos: &Pos{}},\n\t\t\t\t\t\tPos:        &Pos{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\twant: ReusableWorkflowMetadataInputs{\n\t\t\t\t\"unspecified\":          {\"unspecified\", false, AnyType{}},\n\t\t\t\t\"not_required\":         {\"not_required\", false, AnyType{}},\n\t\t\t\t\"required\":             {\"required\", true, AnyType{}},\n\t\t\t\t\"required_but_default\": {\"required_but_default\", false, AnyType{}},\n\t\t\t\t\"expression\":           {\"expression\", false, AnyType{}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:   \"empty\",\n\t\t\tinputs: map[string]*WorkflowCallEventInput{},\n\t\t\twant:   ReusableWorkflowMetadataInputs{},\n\t\t},\n\t\t{\n\t\t\twhat: \"upper case input\",\n\t\t\tinputs: map[string]*WorkflowCallEventInput{\n\t\t\t\t\"MY_INPUT\": {Type: WorkflowCallEventInputTypeString},\n\t\t\t},\n\t\t\twant: ReusableWorkflowMetadataInputs{\n\t\t\t\t\"my_input\": {\"MY_INPUT\", false, StringType{}},\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"upper case inputs\",\n\t\t\tinputs: map[string]*WorkflowCallEventInput{\n\t\t\t\t\"MY_INPUT\": {},\n\t\t\t},\n\t\t\twant: ReusableWorkflowMetadataInputs{\n\t\t\t\t\"my_input\": {\"MY_INPUT\", false, AnyType{}},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tcwd := filepath.Join(\"path\", \"to\", \"project\")\n\t\t\tproj := &Project{cwd, nil}\n\t\t\tc := NewLocalReusableWorkflowCache(proj, cwd, nil)\n\t\t\te := &WorkflowCallEvent{Inputs: []*WorkflowCallEventInput{}}\n\t\t\tfor n, i := range tc.inputs {\n\t\t\t\ti.Name = &String{Value: n, Pos: &Pos{}}\n\t\t\t\ti.ID = strings.ToLower(n)\n\t\t\t\te.Inputs = append(e.Inputs, i)\n\t\t\t}\n\n\t\t\tc.WriteWorkflowCallEvent(filepath.Join(\"foo\", \"test.yaml\"), e)\n\n\t\t\tm, ok := c.readCache(\"./foo/test.yaml\")\n\t\t\tif !ok {\n\t\t\t\tt.Fatal(\"Event was not converted to event\")\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(m.Inputs, tc.want); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t\tif len(m.Outputs) != 0 {\n\t\t\t\tt.Error(\"Outputs are not empty\", m.Outputs)\n\t\t\t}\n\t\t\tif len(m.Secrets) != 0 {\n\t\t\t\tt.Error(\"Secrets are not empty\", m.Secrets)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowMetadataFromASTNodeOutputs(t *testing.T) {\n\ttests := [][]string{\n\t\t{},\n\t\t{\"foo\"},\n\t\t{\"a\", \"b\", \"c\"},\n\t\t{\"A\", \"B\", \"C\"},\n\t}\n\tfor _, outputs := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s\", outputs), func(t *testing.T) {\n\t\t\tcwd := filepath.Join(\"path\", \"to\", \"project\")\n\t\t\tproj := &Project{cwd, nil}\n\t\t\tc := NewLocalReusableWorkflowCache(proj, cwd, nil)\n\t\t\te := &WorkflowCallEvent{Outputs: map[string]*WorkflowCallEventOutput{}}\n\t\t\tfor _, o := range outputs {\n\t\t\t\te.Outputs[strings.ToLower(o)] = &WorkflowCallEventOutput{\n\t\t\t\t\tName: &String{Value: o, Pos: &Pos{}},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.WriteWorkflowCallEvent(filepath.Join(\"foo\", \"test.yaml\"), e)\n\n\t\t\tm, ok := c.readCache(\"./foo/test.yaml\")\n\t\t\tif !ok {\n\t\t\t\tt.Fatal(\"Event was not converted to event\")\n\t\t\t}\n\n\t\t\twant := ReusableWorkflowMetadataOutputs{}\n\t\t\tfor _, o := range outputs {\n\t\t\t\twant[strings.ToLower(o)] = &ReusableWorkflowMetadataOutput{o}\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(m.Outputs, want); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t\tif len(m.Inputs) != 0 {\n\t\t\t\tt.Error(\"Inputs are not empty\", m.Inputs)\n\t\t\t}\n\t\t\tif len(m.Secrets) != 0 {\n\t\t\t\tt.Error(\"Secrets are not empty\", m.Secrets)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowMetadataFromASTNodeSecrets(t *testing.T) {\n\ttests := []map[string]*Bool{\n\t\t{},\n\t\t{\"a\": nil},\n\t\t{\"a\": &Bool{Value: false, Pos: &Pos{}}},\n\t\t{\"a\": &Bool{Value: true, Pos: &Pos{}}},\n\t\t{\"a\": &Bool{Expression: &String{Pos: &Pos{}}, Pos: &Pos{}}},\n\t\t{\n\t\t\t\"a\": &Bool{Value: false, Pos: &Pos{}},\n\t\t\t\"b\": &Bool{Value: true, Pos: &Pos{}},\n\t\t\t\"c\": nil,\n\t\t},\n\t\t{\n\t\t\t\"A\": &Bool{Value: false, Pos: &Pos{}},\n\t\t\t\"B\": &Bool{Value: true, Pos: &Pos{}},\n\t\t\t\"C\": nil,\n\t\t},\n\t}\n\tfor _, secrets := range tests {\n\t\tt.Run(fmt.Sprintf(\"%s\", secrets), func(t *testing.T) {\n\t\t\tcwd := filepath.Join(\"path\", \"to\", \"project\")\n\t\t\tproj := &Project{cwd, nil}\n\t\t\tc := NewLocalReusableWorkflowCache(proj, cwd, nil)\n\t\t\te := &WorkflowCallEvent{Secrets: map[string]*WorkflowCallEventSecret{}}\n\t\t\tfor n, r := range secrets {\n\t\t\t\te.Secrets[strings.ToLower(n)] = &WorkflowCallEventSecret{\n\t\t\t\t\tName:     &String{Value: n, Pos: &Pos{}},\n\t\t\t\t\tRequired: r,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc.WriteWorkflowCallEvent(filepath.Join(\"foo\", \"test.yaml\"), e)\n\n\t\t\tm, ok := c.readCache(\"./foo/test.yaml\")\n\t\t\tif !ok {\n\t\t\t\tt.Fatal(\"Event was not converted to event\")\n\t\t\t}\n\n\t\t\twant := ReusableWorkflowMetadataSecrets{}\n\t\t\tfor n, r := range secrets {\n\t\t\t\twant[strings.ToLower(n)] = &ReusableWorkflowMetadataSecret{\n\t\t\t\t\tName:     n,\n\t\t\t\t\tRequired: r != nil && r.Value,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(m.Secrets, want); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t\tif len(m.Inputs) != 0 {\n\t\t\t\tt.Error(\"Inputs are not empty\", m.Inputs)\n\t\t\t}\n\t\t\tif len(m.Outputs) != 0 {\n\t\t\t\tt.Error(\"Outputs are not empty\", m.Outputs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReusableWorkflowMetadataFromASTNodeDoNothing(t *testing.T) {\n\tcwd := filepath.Join(\"path\", \"to\", \"project\")\n\tc := NewLocalReusableWorkflowCache(nil, cwd, nil)\n\tc.WriteWorkflowCallEvent(\"workflow.yaml\", &WorkflowCallEvent{})\n\tm, ok := c.readCache(\"./workflow.yaml\")\n\tif ok {\n\t\tt.Fatal(\"Metadata created:\", m)\n\t}\n\n\tproj := &Project{cwd, nil}\n\tc = NewLocalReusableWorkflowCache(proj, filepath.Join(\"path\", \"to\", \"another-project\"), nil)\n\tc.WriteWorkflowCallEvent(\"workflow.yaml\", &WorkflowCallEvent{})\n\tm, ok = c.readCache(\"./workflow.yaml\")\n\tif ok {\n\t\tt.Fatal(\"Metadata created:\", m)\n\t}\n\n\tm1 := &ReusableWorkflowMetadata{}\n\tc = NewLocalReusableWorkflowCache(proj, cwd, nil)\n\tc.writeCache(\"./dir/workflow.yaml\", m1)\n\tc.WriteWorkflowCallEvent(filepath.Join(\"dir\", \"workflow.yaml\"), &WorkflowCallEvent{})\n\tm2, ok := c.readCache(\"./dir/workflow.yaml\")\n\tif !ok {\n\t\tt.Fatal(\"Metadata was not created for ./dir/workflow.yaml\")\n\t}\n\tif m1 != m2 {\n\t\tt.Fatalf(\"Metadata was not cached for ./dir/workflow.yaml %v vs %v\", m1, m2)\n\t}\n}\n\nfunc TestReusableWorkflowMetadataCacheFindOneMetadataConcurrently(t *testing.T) {\n\tn := 10\n\tcwd := filepath.Join(\"testdata\", \"reusable_workflow_metadata\")\n\tproj := &Project{cwd, nil}\n\tc := NewLocalReusableWorkflowCache(proj, cwd, nil)\n\tret := make(chan *ReusableWorkflowMetadata)\n\terr := make(chan error)\n\n\tfor i := 0; i < n; i++ {\n\t\tgo func() {\n\t\t\tm, e := c.FindMetadata(\"./ok.yaml\")\n\t\t\tif e != nil {\n\t\t\t\terr <- e\n\t\t\t\treturn\n\t\t\t}\n\t\t\tret <- m\n\t\t}()\n\t}\n\n\tms := []*ReusableWorkflowMetadata{}\n\terrs := []error{}\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase m := <-ret:\n\t\t\tms = append(ms, m)\n\t\tcase e := <-err:\n\t\t\terrs = append(errs, e)\n\t\t}\n\t}\n\n\tif len(errs) != 0 {\n\t\tt.Fatal(\"Error occurred:\", errs)\n\t}\n\n\tfor _, m := range ms {\n\t\tif diff := cmp.Diff(testReusableWorkflowWantedMetadata, m); diff != \"\" {\n\t\t\tt.Fatal(diff)\n\t\t}\n\t}\n\n\tif len(c.cache) != 1 {\n\t\tt.Errorf(\"Unexpected %d caches are stored: %v\", len(c.cache), c.cache)\n\t}\n\tm, ok := c.readCache(\"./ok.yaml\")\n\tif !ok {\n\t\tt.Fatal(\"Cache did not exist\")\n\t}\n\tif m == nil {\n\t\tt.Fatal(\"nil is stored in cache\")\n\t}\n}\n\nfunc TestReusableWorkflowMetadataCacheWriteFromFileAndASTNodeConcurrently(t *testing.T) {\n\tn := 10\n\tcwd := filepath.Join(\"testdata\", \"reusable_workflow_metadata\")\n\tproj := &Project{cwd, nil}\n\tc := NewLocalReusableWorkflowCache(proj, cwd, nil)\n\tret := make(chan struct{})\n\terr := make(chan error)\n\n\tfromFile := func() {\n\t\tif _, e := c.FindMetadata(\"./ok.yaml\"); e != nil {\n\t\t\terr <- e\n\t\t\treturn\n\t\t}\n\t\tret <- struct{}{}\n\t}\n\tfromNode := func() {\n\t\tc.WriteWorkflowCallEvent(\"workflow.yaml\", &WorkflowCallEvent{})\n\t\tif _, ok := c.readCache(\"./workflow.yaml\"); !ok {\n\t\t\terr <- fmt.Errorf(\"Cache was not created from WorkflowCallEvent\")\n\t\t\treturn\n\t\t}\n\t\tret <- struct{}{}\n\t}\n\n\tfor i := 0; i < n/2; i++ {\n\t\tgo fromFile()\n\t\tgo fromNode()\n\t}\n\n\terrs := []error{}\n\tfor i := 0; i < n; i++ {\n\t\tselect {\n\t\tcase <-ret:\n\t\tcase e := <-err:\n\t\t\terrs = append(errs, e)\n\t\t}\n\t}\n\n\tif len(errs) != 0 {\n\t\tt.Fatal(\"Error occurred:\", errs)\n\t}\n\n\tif len(c.cache) != 2 {\n\t\tt.Errorf(\"Size of cache should be 2 but got %d: %v\", len(c.cache), c.cache)\n\t}\n\tif _, ok := c.cache[\"./ok.yaml\"]; !ok {\n\t\tt.Error(\"Cache for ./ok.yaml was not created\", c.cache)\n\t}\n\tif _, ok := c.cache[\"./workflow.yaml\"]; !ok {\n\t\tt.Error(\"Cache for WorkflowCallEvent was not created\", c.cache)\n\t}\n}\n\nfunc TestReusableWorkflowNullCache(t *testing.T) {\n\tc := newNullLocalReusableWorkflowCache(io.Discard)\n\te := &WorkflowCallEvent{Inputs: []*WorkflowCallEventInput{}}\n\n\t// This should do nothing\n\tc.WriteWorkflowCallEvent(filepath.Join(\"foo\", \"test.yaml\"), e)\n\n\tm, err := c.FindMetadata(\"./foo/test.yaml\")\n\tif m != nil {\n\t\tt.Errorf(\"metadata should never be found with null cache: %v\", m)\n\t}\n\tif err != nil {\n\t\tt.Errorf(\"error should not happen since the cache simply doesn't hit: %v\", err)\n\t}\n}\n\nfunc TestReusableWorkflowCacheFactory(t *testing.T) {\n\tcwd := filepath.Join(\"path\", \"to\", \"project1\")\n\tf := NewLocalReusableWorkflowCacheFactory(cwd, nil)\n\n\tp1 := &Project{cwd, nil}\n\tc1 := f.GetCache(p1)\n\n\tp2 := &Project{filepath.Join(\"path\", \"to\", \"project2\"), nil}\n\tc2 := f.GetCache(p2)\n\tif c1 == c2 {\n\t\tt.Errorf(\"Different cache was not created: %v\", c1)\n\t}\n\n\tc3 := f.GetCache(p1)\n\tif c1 != c3 {\n\t\tt.Errorf(\"Same cache was not used: %v vs %v\", c1, c3)\n\t}\n\n\tc4 := f.GetCache(nil)\n\tif c4.proj != nil {\n\t\tt.Errorf(\"Null cache should be returned when project is nil: %v\", c4)\n\t}\n}\n"
        },
        {
          "name": "rule.go",
          "type": "blob",
          "size": 3.2275390625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"io\"\n)\n\n// RuleBase is a struct to be a base of rule structs. Embed this struct to define default methods\n// automatically\ntype RuleBase struct {\n\tname   string\n\tdesc   string\n\terrs   []*Error\n\tdbg    io.Writer\n\tconfig *Config\n}\n\n// NewRuleBase creates a new RuleBase instance. It should be embedded to your own\n// rule instance.\nfunc NewRuleBase(name string, desc string) RuleBase {\n\treturn RuleBase{\n\t\tname: name,\n\t\tdesc: desc,\n\t}\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (r *RuleBase) VisitStep(node *Step) error { return nil }\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (r *RuleBase) VisitJobPre(node *Job) error { return nil }\n\n// VisitJobPost is callback when visiting Job node after visiting its children.\nfunc (r *RuleBase) VisitJobPost(node *Job) error { return nil }\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (r *RuleBase) VisitWorkflowPre(node *Workflow) error { return nil }\n\n// VisitWorkflowPost is callback when visiting Workflow node after visiting its children.\nfunc (r *RuleBase) VisitWorkflowPost(node *Workflow) error { return nil }\n\n// Error creates a new error from the source position and the error message and stores it in the\n// rule instance. The errors can be accessed by Errs method.\nfunc (r *RuleBase) Error(pos *Pos, msg string) {\n\terr := errorAt(pos, r.name, msg)\n\tr.errs = append(r.errs, err)\n}\n\n// Errorf reports a new error with the source position and the formatted error message and stores it\n// in the rule instance. The errors can be accessed by Errs method.\nfunc (r *RuleBase) Errorf(pos *Pos, format string, args ...interface{}) {\n\terr := errorfAt(pos, r.name, format, args...)\n\tr.errs = append(r.errs, err)\n}\n\n// Debug prints debug log to the output. The output is specified by the argument of EnableDebug method.\n// By default, no output is set so debug log is not printed.\nfunc (r *RuleBase) Debug(format string, args ...interface{}) {\n\tif r.dbg == nil {\n\t\treturn\n\t}\n\tformat = fmt.Sprintf(\"[%s] %s\\n\", r.name, format)\n\tfmt.Fprintf(r.dbg, format, args...)\n}\n\n// Errs returns errors found by the rule.\nfunc (r *RuleBase) Errs() []*Error {\n\treturn r.errs\n}\n\n// Name returns the name of the rule.\nfunc (r *RuleBase) Name() string {\n\treturn r.name\n}\n\n// Description returns the description of the rule.\nfunc (r *RuleBase) Description() string {\n\treturn r.desc\n}\n\n// EnableDebug enables debug output from the rule. Given io.Writer instance is used to print debug\n// information to console. Setting nil means disabling debug output.\nfunc (r *RuleBase) EnableDebug(out io.Writer) {\n\tr.dbg = out\n}\n\n// SetConfig populates user configuration of actionlint to the rule. When no config is set, rules\n// should behave as if the default configuration is set.\nfunc (r *RuleBase) SetConfig(cfg *Config) {\n\tr.config = cfg\n}\n\n// Config returns the user configuration of actionlint. When no config was set to this rule by SetConfig,\n// this method returns nil.\nfunc (r *RuleBase) Config() *Config {\n\treturn r.config\n}\n\n// Rule is an interface which all rule structs must meet.\ntype Rule interface {\n\tPass\n\tErrs() []*Error\n\tName() string\n\tDescription() string\n\tEnableDebug(out io.Writer)\n\tSetConfig(cfg *Config)\n\tConfig() *Config\n}\n"
        },
        {
          "name": "rule_action.go",
          "type": "blob",
          "size": 19.0390625,
          "content": "package actionlint\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net/url\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// BrandingColors is a set of colors allowed at branding.color in action.yaml.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#brandingcolor\nvar BrandingColors = map[string]struct{}{\n\t\"white\":     {},\n\t\"black\":     {},\n\t\"yellow\":    {},\n\t\"blue\":      {},\n\t\"green\":     {},\n\t\"orange\":    {},\n\t\"red\":       {},\n\t\"purple\":    {},\n\t\"gray-dark\": {},\n}\n\n// BrandingIcons is a set of icon names allowed at branding.icon in action.yaml.\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#brandingicon\nvar BrandingIcons = map[string]struct{}{\n\t\"activity\":           {},\n\t\"airplay\":            {},\n\t\"alert-circle\":       {},\n\t\"alert-octagon\":      {},\n\t\"alert-triangle\":     {},\n\t\"align-center\":       {},\n\t\"align-justify\":      {},\n\t\"align-left\":         {},\n\t\"align-right\":        {},\n\t\"anchor\":             {},\n\t\"aperture\":           {},\n\t\"archive\":            {},\n\t\"arrow-down-circle\":  {},\n\t\"arrow-down-left\":    {},\n\t\"arrow-down-right\":   {},\n\t\"arrow-down\":         {},\n\t\"arrow-left-circle\":  {},\n\t\"arrow-left\":         {},\n\t\"arrow-right-circle\": {},\n\t\"arrow-right\":        {},\n\t\"arrow-up-circle\":    {},\n\t\"arrow-up-left\":      {},\n\t\"arrow-up-right\":     {},\n\t\"arrow-up\":           {},\n\t\"at-sign\":            {},\n\t\"award\":              {},\n\t\"bar-chart-2\":        {},\n\t\"bar-chart\":          {},\n\t\"battery-charging\":   {},\n\t\"battery\":            {},\n\t\"bell-off\":           {},\n\t\"bell\":               {},\n\t\"bluetooth\":          {},\n\t\"bold\":               {},\n\t\"book-open\":          {},\n\t\"book\":               {},\n\t\"bookmark\":           {},\n\t\"box\":                {},\n\t\"briefcase\":          {},\n\t\"calendar\":           {},\n\t\"camera-off\":         {},\n\t\"camera\":             {},\n\t\"cast\":               {},\n\t\"check-circle\":       {},\n\t\"check-square\":       {},\n\t\"check\":              {},\n\t\"chevron-down\":       {},\n\t\"chevron-left\":       {},\n\t\"chevron-right\":      {},\n\t\"chevron-up\":         {},\n\t\"chevrons-down\":      {},\n\t\"chevrons-left\":      {},\n\t\"chevrons-right\":     {},\n\t\"chevrons-up\":        {},\n\t\"circle\":             {},\n\t\"clipboard\":          {},\n\t\"clock\":              {},\n\t\"cloud-drizzle\":      {},\n\t\"cloud-lightning\":    {},\n\t\"cloud-off\":          {},\n\t\"cloud-rain\":         {},\n\t\"cloud-snow\":         {},\n\t\"cloud\":              {},\n\t\"code\":               {},\n\t\"command\":            {},\n\t\"compass\":            {},\n\t\"copy\":               {},\n\t\"corner-down-left\":   {},\n\t\"corner-down-right\":  {},\n\t\"corner-left-down\":   {},\n\t\"corner-left-up\":     {},\n\t\"corner-right-down\":  {},\n\t\"corner-right-up\":    {},\n\t\"corner-up-left\":     {},\n\t\"corner-up-right\":    {},\n\t\"cpu\":                {},\n\t\"credit-card\":        {},\n\t\"crop\":               {},\n\t\"crosshair\":          {},\n\t\"database\":           {},\n\t\"delete\":             {},\n\t\"disc\":               {},\n\t\"dollar-sign\":        {},\n\t\"download-cloud\":     {},\n\t\"download\":           {},\n\t\"droplet\":            {},\n\t\"edit-2\":             {},\n\t\"edit-3\":             {},\n\t\"edit\":               {},\n\t\"external-link\":      {},\n\t\"eye-off\":            {},\n\t\"eye\":                {},\n\t\"fast-forward\":       {},\n\t\"feather\":            {},\n\t\"file-minus\":         {},\n\t\"file-plus\":          {},\n\t\"file-text\":          {},\n\t\"file\":               {},\n\t\"film\":               {},\n\t\"filter\":             {},\n\t\"flag\":               {},\n\t\"folder-minus\":       {},\n\t\"folder-plus\":        {},\n\t\"folder\":             {},\n\t\"gift\":               {},\n\t\"git-branch\":         {},\n\t\"git-commit\":         {},\n\t\"git-merge\":          {},\n\t\"git-pull-request\":   {},\n\t\"globe\":              {},\n\t\"grid\":               {},\n\t\"hard-drive\":         {},\n\t\"hash\":               {},\n\t\"headphones\":         {},\n\t\"heart\":              {},\n\t\"help-circle\":        {},\n\t\"home\":               {},\n\t\"image\":              {},\n\t\"inbox\":              {},\n\t\"info\":               {},\n\t\"italic\":             {},\n\t\"layers\":             {},\n\t\"layout\":             {},\n\t\"life-buoy\":          {},\n\t\"link-2\":             {},\n\t\"link\":               {},\n\t\"list\":               {},\n\t\"loader\":             {},\n\t\"lock\":               {},\n\t\"log-in\":             {},\n\t\"log-out\":            {},\n\t\"mail\":               {},\n\t\"map-pin\":            {},\n\t\"map\":                {},\n\t\"maximize-2\":         {},\n\t\"maximize\":           {},\n\t\"menu\":               {},\n\t\"message-circle\":     {},\n\t\"message-square\":     {},\n\t\"mic-off\":            {},\n\t\"mic\":                {},\n\t\"minimize-2\":         {},\n\t\"minimize\":           {},\n\t\"minus-circle\":       {},\n\t\"minus-square\":       {},\n\t\"minus\":              {},\n\t\"monitor\":            {},\n\t\"moon\":               {},\n\t\"more-horizontal\":    {},\n\t\"more-vertical\":      {},\n\t\"move\":               {},\n\t\"music\":              {},\n\t\"navigation-2\":       {},\n\t\"navigation\":         {},\n\t\"octagon\":            {},\n\t\"package\":            {},\n\t\"paperclip\":          {},\n\t\"pause-circle\":       {},\n\t\"pause\":              {},\n\t\"percent\":            {},\n\t\"phone-call\":         {},\n\t\"phone-forwarded\":    {},\n\t\"phone-incoming\":     {},\n\t\"phone-missed\":       {},\n\t\"phone-off\":          {},\n\t\"phone-outgoing\":     {},\n\t\"phone\":              {},\n\t\"pie-chart\":          {},\n\t\"play-circle\":        {},\n\t\"play\":               {},\n\t\"plus-circle\":        {},\n\t\"plus-square\":        {},\n\t\"plus\":               {},\n\t\"pocket\":             {},\n\t\"power\":              {},\n\t\"printer\":            {},\n\t\"radio\":              {},\n\t\"refresh-ccw\":        {},\n\t\"refresh-cw\":         {},\n\t\"repeat\":             {},\n\t\"rewind\":             {},\n\t\"rotate-ccw\":         {},\n\t\"rotate-cw\":          {},\n\t\"rss\":                {},\n\t\"save\":               {},\n\t\"scissors\":           {},\n\t\"search\":             {},\n\t\"send\":               {},\n\t\"server\":             {},\n\t\"settings\":           {},\n\t\"share-2\":            {},\n\t\"share\":              {},\n\t\"shield-off\":         {},\n\t\"shield\":             {},\n\t\"shopping-bag\":       {},\n\t\"shopping-cart\":      {},\n\t\"shuffle\":            {},\n\t\"sidebar\":            {},\n\t\"skip-back\":          {},\n\t\"skip-forward\":       {},\n\t\"slash\":              {},\n\t\"sliders\":            {},\n\t\"smartphone\":         {},\n\t\"speaker\":            {},\n\t\"square\":             {},\n\t\"star\":               {},\n\t\"stop-circle\":        {},\n\t\"sun\":                {},\n\t\"sunrise\":            {},\n\t\"sunset\":             {},\n\t\"table\":              {},\n\t\"tablet\":             {},\n\t\"tag\":                {},\n\t\"target\":             {},\n\t\"terminal\":           {},\n\t\"thermometer\":        {},\n\t\"thumbs-down\":        {},\n\t\"thumbs-up\":          {},\n\t\"toggle-left\":        {},\n\t\"toggle-right\":       {},\n\t\"trash-2\":            {},\n\t\"trash\":              {},\n\t\"trending-down\":      {},\n\t\"trending-up\":        {},\n\t\"triangle\":           {},\n\t\"truck\":              {},\n\t\"tv\":                 {},\n\t\"type\":               {},\n\t\"umbrella\":           {},\n\t\"underline\":          {},\n\t\"unlock\":             {},\n\t\"upload-cloud\":       {},\n\t\"upload\":             {},\n\t\"user-check\":         {},\n\t\"user-minus\":         {},\n\t\"user-plus\":          {},\n\t\"user-x\":             {},\n\t\"user\":               {},\n\t\"users\":              {},\n\t\"video-off\":          {},\n\t\"video\":              {},\n\t\"voicemail\":          {},\n\t\"volume-1\":           {},\n\t\"volume-2\":           {},\n\t\"volume-x\":           {},\n\t\"volume\":             {},\n\t\"watch\":              {},\n\t\"wifi-off\":           {},\n\t\"wifi\":               {},\n\t\"wind\":               {},\n\t\"x-circle\":           {},\n\t\"x-square\":           {},\n\t\"x\":                  {},\n\t\"zap-off\":            {},\n\t\"zap\":                {},\n\t\"zoom-in\":            {},\n\t\"zoom-out\":           {},\n}\n\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runsimage\nfunc isImageOnDockerRegistry(image string) bool {\n\treturn strings.HasPrefix(image, \"docker://\") ||\n\t\tstrings.HasPrefix(image, \"gcr.io/\") ||\n\t\tstrings.HasPrefix(image, \"pkg.dev/\") ||\n\t\tstrings.HasPrefix(image, \"ghcr.io/\") ||\n\t\tstrings.HasPrefix(image, \"docker.io/\")\n}\n\n// RuleAction is a rule to check running action in steps of jobs.\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsuses\ntype RuleAction struct {\n\tRuleBase\n\tcache *LocalActionsCache\n}\n\n// NewRuleAction creates new RuleAction instance.\nfunc NewRuleAction(cache *LocalActionsCache) *RuleAction {\n\treturn &RuleAction{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"action\",\n\t\t\tdesc: \"Checks for popular actions released on GitHub, local actions, and action calls at \\\"uses:\\\"\",\n\t\t},\n\t\tcache: cache,\n\t}\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleAction) VisitStep(n *Step) error {\n\te, ok := n.Exec.(*ExecAction)\n\tif !ok || e.Uses == nil {\n\t\treturn nil\n\t}\n\n\tif e.Uses.ContainsExpression() {\n\t\t// Cannot parse specification made with interpolation. Give up\n\t\treturn nil\n\t}\n\n\tspec := e.Uses.Value\n\n\tif strings.HasPrefix(spec, \"./\") {\n\t\t// Relative to repository root\n\t\trule.checkLocalAction(spec, e)\n\t\treturn nil\n\t}\n\n\tif strings.HasPrefix(spec, \"docker://\") {\n\t\trule.checkDockerAction(spec, e)\n\t\treturn nil\n\t}\n\n\trule.checkRepoAction(spec, e)\n\treturn nil\n}\n\n// Parse {owner}/{repo}@{ref} or {owner}/{repo}/{path}@{ref}\nfunc (rule *RuleAction) checkRepoAction(spec string, exec *ExecAction) {\n\ts := spec\n\tidx := strings.IndexRune(s, '@')\n\tif idx == -1 {\n\t\trule.invalidActionFormat(exec.Uses.Pos, spec, \"ref is missing\")\n\t\treturn\n\t}\n\tref := s[idx+1:]\n\ts = s[:idx] // remove {ref}\n\n\tidx = strings.IndexRune(s, '/')\n\tif idx == -1 {\n\t\trule.invalidActionFormat(exec.Uses.Pos, spec, \"owner is missing\")\n\t\treturn\n\t}\n\n\towner := s[:idx]\n\ts = s[idx+1:] // eat {owner}\n\n\trepo := s\n\tif idx := strings.IndexRune(s, '/'); idx >= 0 {\n\t\trepo = s[:idx]\n\t}\n\n\tif owner == \"\" || repo == \"\" || ref == \"\" {\n\t\trule.invalidActionFormat(exec.Uses.Pos, spec, \"owner and repo and ref should not be empty\")\n\t}\n\n\tmeta, ok := PopularActions[spec]\n\tif !ok {\n\t\tif _, ok := OutdatedPopularActionSpecs[spec]; ok {\n\t\t\trule.Errorf(exec.Uses.Pos, \"the runner of %q action is too old to run on GitHub Actions. update the action's version to fix this issue\", spec)\n\t\t\treturn\n\t\t}\n\t\trule.Debug(\"This action is not found in popular actions data set: %s\", spec)\n\t\treturn\n\t}\n\tif meta.SkipInputs {\n\t\trule.Debug(\"This action skips to check inputs: %s\", spec)\n\t\treturn\n\t}\n\n\trule.checkAction(meta, exec, func(m *ActionMetadata) string {\n\t\treturn strconv.Quote(spec)\n\t})\n}\n\nfunc (rule *RuleAction) invalidActionFormat(pos *Pos, spec string, why string) {\n\trule.Errorf(pos, \"specifying action %q in invalid format because %s. available formats are \\\"{owner}/{repo}@{ref}\\\" or \\\"{owner}/{repo}/{path}@{ref}\\\"\", spec, why)\n}\n\nfunc (rule *RuleAction) missingRunsProp(pos *Pos, prop, ty, action, path string) {\n\trule.Errorf(pos, `%q is required in \"runs\" section because %q is a %s action. the action is defined at %q`, prop, action, ty, path)\n}\n\nfunc (rule *RuleAction) checkInvalidRunsProps(pos *Pos, r *ActionMetadataRuns, ty, action, path string, props []string) {\n\tfor _, prop := range props {\n\t\tinvalid := prop == \"main\" && r.Main != \"\" ||\n\t\t\tprop == \"pre\" && r.Pre != \"\" ||\n\t\t\tprop == \"pre-if\" && r.PreIf != \"\" ||\n\t\t\tprop == \"post\" && r.Post != \"\" ||\n\t\t\tprop == \"post-if\" && r.PostIf != \"\" ||\n\t\t\tprop == \"steps\" && len(r.Steps) > 0 ||\n\t\t\tprop == \"image\" && r.Image != \"\" ||\n\t\t\tprop == \"pre-entrypoint\" && r.PreEntrypoint != \"\" ||\n\t\t\tprop == \"entrypoint\" && r.Entrypoint != \"\" ||\n\t\t\tprop == \"post-entrypoint\" && r.PostEntrypoint != \"\" ||\n\t\t\tprop == \"args\" && r.Args != nil ||\n\t\t\tprop == \"env\" && r.Env != nil\n\n\t\tif invalid {\n\t\t\trule.Errorf(pos, `%q is not allowed in \"runs\" section because %q is a %s action. the action is defined at %q`, prop, action, ty, path)\n\t\t}\n\t}\n}\n\nfunc (rule *RuleAction) checkRunsFileExists(file, dir, prop, name string, pos *Pos) {\n\tf := filepath.FromSlash(file)\n\tif f == \"\" {\n\t\treturn\n\t}\n\tp := filepath.Join(dir, f)\n\tif _, err := os.Stat(p); errors.Is(err, os.ErrNotExist) {\n\t\trule.Errorf(pos, `file %q does not exist in %q. it is specified at %q key in \"runs\" section in %q action`, f, dir, prop, name)\n\t}\n}\n\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runs-for-docker-container-actions\nfunc (rule *RuleAction) checkLocalDockerActionRuns(r *ActionMetadataRuns, dir, name string, pos *Pos) {\n\tif r.Image == \"\" {\n\t\trule.missingRunsProp(pos, \"image\", \"Docker\", name, dir)\n\t} else if !isImageOnDockerRegistry(r.Image) {\n\t\trule.checkRunsFileExists(r.Image, dir, \"image\", name, pos)\n\t\tif filepath.Base(filepath.FromSlash(r.Image)) != \"Dockerfile\" {\n\t\t\trule.Errorf(pos, `the local file %q referenced from \"image\" key must be named \"Dockerfile\" in %q action. the action is defined at %q`, r.Image, name, dir)\n\t\t}\n\t}\n\trule.checkRunsFileExists(r.PreEntrypoint, dir, \"pre-entrypoint\", name, pos)\n\trule.checkRunsFileExists(r.Entrypoint, dir, \"entrypoint\", name, pos)\n\trule.checkRunsFileExists(r.PostEntrypoint, dir, \"post-entrypoint\", name, pos)\n\trule.checkInvalidRunsProps(pos, r, \"Docker\", name, dir, []string{\"main\", \"pre\", \"pre-if\", \"post\", \"post-if\", \"steps\"})\n}\n\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runs-for-composite-actions\nfunc (rule *RuleAction) checkLocalCompositeActionRuns(r *ActionMetadataRuns, dir, name string, pos *Pos) {\n\tif r.Steps == nil {\n\t\trule.missingRunsProp(pos, \"steps\", \"Composite\", name, dir)\n\t}\n\trule.checkInvalidRunsProps(pos, r, \"Composite\", name, dir, []string{\"main\", \"pre\", \"pre-if\", \"post\", \"post-if\", \"image\", \"pre-entrypoint\", \"entrypoint\", \"post-entrypoint\", \"args\", \"env\"})\n}\n\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runs-for-javascript-actions\nfunc (rule *RuleAction) checkLocalJavaScriptActionRuns(r *ActionMetadataRuns, dir, name string, pos *Pos) {\n\tif r.Main == \"\" {\n\t\trule.missingRunsProp(pos, \"main\", \"JavaScript\", name, dir)\n\t} else {\n\t\trule.checkRunsFileExists(r.Main, dir, \"main\", name, pos)\n\t}\n\n\trule.checkRunsFileExists(r.Pre, dir, \"pre\", name, pos)\n\tif r.Pre == \"\" && r.PreIf != \"\" {\n\t\trule.Errorf(pos, `\"pre\" is required when \"pre-if\" is specified in \"runs\" section in %q action. the action is defined at %q`, name, dir)\n\t}\n\n\trule.checkRunsFileExists(r.Post, dir, \"post\", name, pos)\n\tif r.Post == \"\" && r.PostIf != \"\" {\n\t\trule.Errorf(pos, `\"post\" is required when \"post-if\" is specified in \"runs\" section in %q action. the action is defined at %q`, name, dir)\n\t}\n\n\trule.checkInvalidRunsProps(pos, r, \"JavaScript\", name, dir, []string{\"steps\", \"image\", \"pre-entrypoint\", \"entrypoint\", \"post-entrypoint\", \"args\", \"env\"})\n}\n\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runs\nfunc (rule *RuleAction) checkLocalActionRuns(meta *ActionMetadata, pos *Pos) {\n\tswitch r := &meta.Runs; r.Using {\n\tcase \"\":\n\t\trule.Errorf(pos, `\"runs.using\" is missing in local action %q defined at %q`, meta.Name, meta.Dir())\n\tcase \"docker\":\n\t\trule.checkLocalDockerActionRuns(r, meta.Dir(), meta.Name, pos)\n\tcase \"composite\":\n\t\trule.checkLocalCompositeActionRuns(r, meta.Dir(), meta.Name, pos)\n\tcase \"node20\":\n\t\trule.checkLocalJavaScriptActionRuns(r, meta.Dir(), meta.Name, pos)\n\tdefault:\n\t\trule.Errorf(pos, `invalid runner name %q at runs.using in %q action defined at %q. valid runners are \"composite\", \"docker\", and \"node20\". see https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#runs`, r.Using, meta.Name, meta.Dir())\n\n\t\t// Probably invalid version of Node.js runner. Assume it is JavaScript action to find as many errors as possible\n\t\tif strings.HasPrefix(r.Using, \"node\") {\n\t\t\trule.checkLocalJavaScriptActionRuns(r, meta.Dir(), meta.Name, pos)\n\t\t}\n\t}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#example-using-the-github-packages-container-registry\nfunc (rule *RuleAction) checkDockerAction(uri string, exec *ExecAction) {\n\ttag := \"\"\n\ttagExists := false\n\tif idx := strings.IndexRune(uri[len(\"docker://\"):], ':'); idx != -1 {\n\t\tidx += len(\"docker://\")\n\t\tif idx < len(uri) {\n\t\t\ttag = uri[idx+1:]\n\t\t\turi = uri[:idx]\n\t\t\ttagExists = true\n\t\t}\n\t}\n\n\tif _, err := url.Parse(uri); err != nil {\n\t\trule.Errorf(\n\t\t\texec.Uses.Pos,\n\t\t\t\"URI for Docker container %q is invalid: %s (tag=%s)\",\n\t\t\turi,\n\t\t\terr.Error(),\n\t\t\ttag,\n\t\t)\n\t}\n\n\tif tagExists && tag == \"\" {\n\t\trule.Errorf(exec.Uses.Pos, \"tag of Docker action should not be empty: %q\", uri)\n\t}\n}\n\n// https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions\nfunc (rule *RuleAction) checkLocalActionMetadata(meta *ActionMetadata, action *ExecAction) {\n\tif meta.Name == \"\" {\n\t\trule.Errorf(action.Uses.Pos, \"name is required in action metadata %q\", meta.Path())\n\t}\n\tif meta.Description == \"\" {\n\t\trule.Errorf(action.Uses.Pos, \"description is required in metadata of %q action at %q\", meta.Name, meta.Path())\n\t}\n\tif meta.Branding.Icon != \"\" {\n\t\tif _, ok := BrandingIcons[strings.ToLower(meta.Branding.Icon)]; !ok {\n\t\t\trule.Errorf(\n\t\t\t\taction.Uses.Pos,\n\t\t\t\t\"incorrect icon name %q at branding.icon in metadata of %q action at %q. see the official document to know the exhaustive list of supported icons: https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#brandingicon\",\n\t\t\t\tmeta.Branding.Icon,\n\t\t\t\tmeta.Name,\n\t\t\t\tmeta.Path(),\n\t\t\t)\n\t\t}\n\t}\n\tif meta.Branding.Color != \"\" {\n\t\tif _, ok := BrandingColors[strings.ToLower(meta.Branding.Color)]; !ok {\n\t\t\trule.Errorf(\n\t\t\t\taction.Uses.Pos,\n\t\t\t\t\"incorrect color %q at branding.icon in metadata of %q action at %q. see the official document to know the exhaustive list of supported colors: https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions#brandingcolor\",\n\t\t\t\tmeta.Branding.Color,\n\t\t\t\tmeta.Name,\n\t\t\t\tmeta.Path(),\n\t\t\t)\n\t\t}\n\t}\n\trule.checkLocalActionRuns(meta, action.Uses.Pos)\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#example-using-action-in-the-same-repository-as-the-workflow\nfunc (rule *RuleAction) checkLocalAction(spec string, action *ExecAction) {\n\tmeta, cached, err := rule.cache.FindMetadata(spec)\n\tif err != nil {\n\t\trule.Error(action.Uses.Pos, err.Error())\n\t\treturn\n\t}\n\tif meta == nil {\n\t\treturn\n\t}\n\n\tif !cached {\n\t\trule.Debug(\"Checking metadata of %s action %q at %q\", meta.Runs, meta.Name, spec)\n\t\trule.checkLocalActionMetadata(meta, action)\n\t}\n\n\trule.checkAction(meta, action, func(m *ActionMetadata) string {\n\t\treturn fmt.Sprintf(\"%q defined at %q\", m.Name, spec)\n\t})\n}\n\nfunc (rule *RuleAction) checkAction(meta *ActionMetadata, exec *ExecAction, describe func(*ActionMetadata) string) {\n\t// Check specified inputs are defined in action's inputs spec\n\tfor id, i := range exec.Inputs {\n\t\tif _, ok := meta.Inputs[id]; !ok {\n\t\t\tns := make([]string, 0, len(meta.Inputs))\n\t\t\tfor _, i := range meta.Inputs {\n\t\t\t\tns = append(ns, i.Name)\n\t\t\t}\n\t\t\trule.Errorf(\n\t\t\t\ti.Name.Pos,\n\t\t\t\t\"input %q is not defined in action %s. available inputs are %s\",\n\t\t\t\ti.Name.Value,\n\t\t\t\tdescribe(meta),\n\t\t\t\tsortedQuotes(ns),\n\t\t\t)\n\t\t}\n\t}\n\n\t// Check mandatory inputs are specified\n\tfor id, i := range meta.Inputs {\n\t\tif i.Required {\n\t\t\tif _, ok := exec.Inputs[id]; !ok {\n\t\t\t\tns := make([]string, 0, len(meta.Inputs))\n\t\t\t\tfor _, i := range meta.Inputs {\n\t\t\t\t\tif i.Required {\n\t\t\t\t\t\tns = append(ns, i.Name)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trule.Errorf(\n\t\t\t\t\texec.Uses.Pos,\n\t\t\t\t\t\"missing input %q which is required by action %s. all required inputs are %s\",\n\t\t\t\t\ti.Name,\n\t\t\t\t\tdescribe(meta),\n\t\t\t\t\tsortedQuotes(ns),\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "rule_credentials.go",
          "type": "blob",
          "size": 1.09765625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n)\n\n// RuleCredentials is a rule to check credentials in workflows\ntype RuleCredentials struct {\n\tRuleBase\n}\n\n// NewRuleCredentials creates new RuleCredentials instance\nfunc NewRuleCredentials() *RuleCredentials {\n\treturn &RuleCredentials{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"credentials\",\n\t\t\tdesc: \"Checks for credentials in \\\"services:\\\" configuration\",\n\t\t},\n\t}\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleCredentials) VisitJobPre(n *Job) error {\n\tif n.Container != nil {\n\t\trule.checkContainer(\"\\\"container\\\" section\", n.Container)\n\t}\n\tif n.Services != nil {\n\t\tfor _, s := range n.Services.Value {\n\t\t\trule.checkContainer(fmt.Sprintf(\"%q service\", s.Name.Value), s.Container)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (rule *RuleCredentials) checkContainer(where string, n *Container) {\n\tif n.Credentials == nil || n.Credentials.Password == nil {\n\t\treturn\n\t}\n\n\tp := n.Credentials.Password\n\tif !p.IsExpressionAssigned() {\n\t\trule.Errorf(p.Pos, \"\\\"password\\\" section in %s should be specified via secrets. do not put password value directly\", where)\n\t}\n}\n"
        },
        {
          "name": "rule_deprecated_commands.go",
          "type": "blob",
          "size": 1.796875,
          "content": "package actionlint\n\nimport \"regexp\"\n\nvar deprecatedCommandsPattern = regexp.MustCompile(`(?:::(save-state|set-output|set-env)\\s+name=[a-zA-Z][a-zA-Z_-]*::\\S+|::(add-path)::\\S+)`)\n\n// RuleDeprecatedCommands is a rule checker to detect deprecated workflow commands. Currently\n// 'set-state', 'set-output', `set-env' and 'add-path' are detected as deprecated.\n//\n// - https://github.blog/changelog/2020-10-01-github-actions-deprecating-set-env-and-add-path-commands/\n// - https://github.blog/changelog/2022-10-11-github-actions-deprecating-save-state-and-set-output-commands/\ntype RuleDeprecatedCommands struct {\n\tRuleBase\n}\n\n// NewRuleDeprecatedCommands creates a new RuleDeprecatedCommands instance.\nfunc NewRuleDeprecatedCommands() *RuleDeprecatedCommands {\n\treturn &RuleDeprecatedCommands{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"deprecated-commands\",\n\t\t\tdesc: \"Checks for deprecated \\\"set-output\\\", \\\"save-state\\\", \\\"set-env\\\", and \\\"add-path\\\" commands at \\\"run:\\\"\",\n\t\t},\n\t}\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleDeprecatedCommands) VisitStep(n *Step) error {\n\tif r, ok := n.Exec.(*ExecRun); ok && r.Run != nil {\n\t\tfor _, m := range deprecatedCommandsPattern.FindAllStringSubmatch(r.Run.Value, -1) {\n\t\t\tc := m[1]\n\t\t\tif len(c) == 0 {\n\t\t\t\tc = m[2]\n\t\t\t}\n\n\t\t\tvar a string\n\t\t\tswitch c {\n\t\t\tcase \"set-output\":\n\t\t\t\ta = `echo \"{name}={value}\" >> $GITHUB_OUTPUT`\n\t\t\tcase \"save-state\":\n\t\t\t\ta = `echo \"{name}={value}\" >> $GITHUB_STATE`\n\t\t\tcase \"set-env\":\n\t\t\t\ta = `echo \"{name}={value}\" >> $GITHUB_ENV`\n\t\t\tcase \"add-path\":\n\t\t\t\ta = `echo \"{path}\" >> $GITHUB_PATH`\n\t\t\tdefault:\n\t\t\t\tpanic(\"unreachable\")\n\t\t\t}\n\n\t\t\trule.Errorf(\n\t\t\t\tr.Run.Pos,\n\t\t\t\t\"workflow command %q was deprecated. use `%s` instead: https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions\",\n\t\t\t\tc,\n\t\t\t\ta,\n\t\t\t)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "rule_deprecated_commands_test.go",
          "type": "blob",
          "size": 2.6552734375,
          "content": "package actionlint\n\nimport (\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestRuleDeprecatedCommandsDetectTargetCommands(t *testing.T) {\n\ttests := []struct {\n\t\twhat string\n\t\trun  string\n\t\twant []string\n\t}{\n\t\t{\n\t\t\twhat: \"save-state\",\n\t\t\trun:  \"::save-state name=foo::42\",\n\t\t\twant: []string{\"save-state\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"set-output\",\n\t\t\trun:  \"::set-output name=foo::42\",\n\t\t\twant: []string{\"set-output\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"set-env\",\n\t\t\trun:  \"::set-env name=foo::42\",\n\t\t\twant: []string{\"set-env\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"add-path\",\n\t\t\trun:  \"::add-path::/path/to/foo\",\n\t\t\twant: []string{\"add-path\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"submatch\",\n\t\t\trun:  \"hello::set-output name=foo::42 world\",\n\t\t\twant: []string{\"set-output\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple same commands\",\n\t\t\trun:  \"::set-output name=foo::42 ::set-output name=bar::xxx\",\n\t\t\twant: []string{\"set-output\", \"set-output\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple different commands\",\n\t\t\trun:  \"::set-output name=foo::42 ::add-path::/path/to/foo ::save-state name=foo::42\",\n\t\t\twant: []string{\"set-output\", \"add-path\", \"save-state\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple submatches\",\n\t\t\trun:  \"hello::set-output name=foo::42 how ::add-path::/path/to/foo are ::save-state name=foo::42 you\",\n\t\t\twant: []string{\"set-output\", \"add-path\", \"save-state\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"something between command and arguments\",\n\t\t\trun:  \"::set-output hello name=foo::42\",\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple spaces\",\n\t\t\trun:  \"::set-output    \t\t    name=foo::42\",\n\t\t\twant: []string{\"set-output\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"empty string\",\n\t\t\trun:  \"\",\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\twhat: \"no command\",\n\t\t\trun:  \"echo 'do not use set-output!'\",\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\twhat: \"hyphen and underscore in name\",\n\t\t\trun:  \"::save-state name=foo_bar-woo::42\",\n\t\t\twant: []string{\"save-state\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"invalid name\",\n\t\t\trun:  \"::save-state name=-foo::42\",\n\t\t\twant: []string{},\n\t\t},\n\t\t{\n\t\t\twhat: \"different argument\",\n\t\t\trun:  \"::save-state myname=foo::42\",\n\t\t\twant: []string{},\n\t\t},\n\t}\n\tre := regexp.MustCompile(`\\s+workflow command \"([a-z-]+)\" was deprecated\\.`)\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\ts := &Step{\n\t\t\t\tExec: &ExecRun{\n\t\t\t\t\tRun: &String{\n\t\t\t\t\t\tValue: tc.run,\n\t\t\t\t\t\tPos:   &Pos{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tr := NewRuleDeprecatedCommands()\n\t\t\tif err := r.VisitStep(s); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terrs := r.Errs()\n\t\t\thave := []string{}\n\t\t\tfor i, err := range errs {\n\t\t\t\tm := err.Error()\n\t\t\t\tss := re.FindStringSubmatch(m)\n\t\t\t\tif len(ss) == 0 {\n\t\t\t\t\tt.Fatalf(\"%dth error was unexpected: %q\", i, m)\n\t\t\t\t}\n\t\t\t\thave = append(have, ss[1])\n\t\t\t}\n\n\t\t\tif diff := cmp.Diff(have, tc.want); diff != \"\" {\n\t\t\t\tt.Fatal(diff)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "rule_env_var.go",
          "type": "blob",
          "size": 1.4306640625,
          "content": "package actionlint\n\nimport \"strings\"\n\n// RuleEnvVar is a rule checker to check environment variables setup.\ntype RuleEnvVar struct {\n\tRuleBase\n}\n\n// NewRuleEnvVar creates new RuleEnvVar instance.\nfunc NewRuleEnvVar() *RuleEnvVar {\n\treturn &RuleEnvVar{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"env-var\",\n\t\t\tdesc: \"Checks for environment variables configuration at \\\"env:\\\"\",\n\t\t},\n\t}\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleEnvVar) VisitStep(n *Step) error {\n\trule.checkEnv(n.Env)\n\treturn nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleEnvVar) VisitJobPre(n *Job) error {\n\trule.checkEnv(n.Env)\n\tif n.Container != nil {\n\t\trule.checkEnv(n.Container.Env)\n\t}\n\tif n.Services != nil {\n\t\tfor _, s := range n.Services.Value {\n\t\t\trule.checkEnv(s.Container.Env)\n\t\t}\n\t}\n\treturn nil\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleEnvVar) VisitWorkflowPre(n *Workflow) error {\n\trule.checkEnv(n.Env)\n\treturn nil\n}\n\nfunc (rule *RuleEnvVar) checkEnv(env *Env) {\n\tif env == nil || env.Expression != nil {\n\t\treturn\n\t}\n\tfor _, v := range env.Vars {\n\t\tif v.Name.ContainsExpression() {\n\t\t\tcontinue // Key name can contain expressions (#312)\n\t\t}\n\t\tif strings.ContainsAny(v.Name.Value, \"&= \t\") {\n\t\t\trule.Errorf(\n\t\t\t\tv.Name.Pos,\n\t\t\t\t\"environment variable name %q is invalid. '&', '=' and spaces should not be contained\",\n\t\t\t\tv.Name.Value,\n\t\t\t)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "rule_env_var_test.go",
          "type": "blob",
          "size": 1.5576171875,
          "content": "package actionlint\n\nimport \"testing\"\n\nfunc testValidateEnvVarName(t *testing.T, name string) []*Error {\n\tt.Helper()\n\tn := &String{Value: name, Pos: &Pos{}}\n\te := &Env{\n\t\tVars: map[string]*EnvVar{\n\t\t\tname: {n, &String{Value: \"\", Pos: &Pos{}}},\n\t\t},\n\t}\n\tw := &Workflow{Env: e}\n\tr := NewRuleEnvVar()\n\tif err := r.VisitWorkflowPre(w); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn r.Errs()\n}\n\nfunc TestRuleEnvVarCheckValidName(t *testing.T) {\n\tvalids := []string{\n\t\t\"foo_bar\",\n\t\t\"FOO_BAR\",\n\t\t\"foo-bar\",\n\t\t\"_\",\n\t\t\"-\",\n\t}\n\n\tfor _, n := range valids {\n\t\tt.Run(n, func(t *testing.T) {\n\t\t\tif errs := testValidateEnvVarName(t, n); len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"env var %q should be valid but got errors: %v\", n, errs)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleEnvVarCheckInvalidName(t *testing.T) {\n\tinvalids := []string{\n\t\t\"a b\",\n\t\t\"a=b\",\n\t\t\"a=b\",\n\t}\n\n\tfor _, n := range invalids {\n\t\tt.Run(n, func(t *testing.T) {\n\t\t\tif errs := testValidateEnvVarName(t, n); len(errs) == 0 {\n\t\t\t\tt.Fatalf(\"env var %q should be invalid but got no error\", n)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleEnvVarSkipEdgeCaseEnv(t *testing.T) {\n\tw := &Workflow{Env: nil}\n\tr := NewRuleEnvVar()\n\tif err := r.VisitWorkflowPre(w); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif errs := r.Errs(); len(errs) > 0 {\n\t\tt.Fatal(\"no error should be detected when `Env` is nil but got\", errs)\n\t}\n\n\tw = &Workflow{\n\t\tEnv: &Env{\n\t\t\tExpression: &String{Value: \"\"},\n\t\t},\n\t}\n\tr = NewRuleEnvVar()\n\tif err := r.VisitWorkflowPre(w); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif errs := r.Errs(); len(errs) > 0 {\n\t\tt.Fatal(\"no error should be detected when `Env` is constructed by expression\", errs)\n\t}\n\n}\n"
        },
        {
          "name": "rule_events.go",
          "type": "blob",
          "size": 8.8408203125,
          "content": "package actionlint\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/robfig/cron/v3\"\n)\n\n//go:generate go run ./scripts/generate-webhook-events ./all_webhooks.go\n\n// RuleEvents is a rule to check 'on' field in workflow.\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows\ntype RuleEvents struct {\n\tRuleBase\n}\n\n// NewRuleEvents creates new RuleEvents instance.\nfunc NewRuleEvents() *RuleEvents {\n\treturn &RuleEvents{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"events\",\n\t\t\tdesc: \"Checks for workflow trigger events at \\\"on:\\\"\",\n\t\t},\n\t}\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleEvents) VisitWorkflowPre(n *Workflow) error {\n\tfor _, e := range n.On {\n\t\trule.checkEvent(e)\n\t}\n\treturn nil\n}\n\nfunc (rule *RuleEvents) checkEvent(event Event) {\n\tswitch e := event.(type) {\n\tcase *ScheduledEvent:\n\t\tfor _, c := range e.Cron {\n\t\t\trule.checkCron(c)\n\t\t}\n\tcase *WorkflowDispatchEvent:\n\t\trule.checkWorkflowDispatchEvent(e)\n\tcase *RepositoryDispatchEvent:\n\t\t// Nothing to do\n\tcase *WorkflowCallEvent:\n\t\trule.checkWorkflowCallEvent(e)\n\tcase *WebhookEvent:\n\t\trule.checkWebhookEvent(e)\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onschedule\nfunc (rule *RuleEvents) checkCron(spec *String) {\n\tp := cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)\n\tsched, err := p.Parse(spec.Value)\n\tif err != nil {\n\t\trule.Errorf(spec.Pos, \"invalid CRON format %q in schedule event: %s\", spec.Value, err.Error())\n\t\treturn\n\t}\n\n\tstart := sched.Next(time.Unix(0, 0))\n\tnext := sched.Next(start)\n\tdiff := next.Sub(start).Seconds()\n\n\t// (#14) https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#scheduled-events\n\t//\n\t// > The shortest interval you can run scheduled workflows is once every 5 minutes.\n\tif diff < 60.0*5 {\n\t\trule.Errorf(spec.Pos, \"scheduled job runs too frequently. it runs once per %g seconds. the shortest interval is once every 5 minutes\", diff)\n\t}\n}\n\nfunc (rule *RuleEvents) filterNotAvailable(pos *Pos, filter, hook string, available []string) {\n\te := \"events\"\n\tif len(available) < 2 {\n\t\te = \"event\"\n\t}\n\trule.Errorf(pos, \"%q filter is not available for %s event. it is only for %s %s\", filter, hook, strings.Join(available, \", \"), e)\n}\n\nfunc (rule *RuleEvents) checkExclusiveFilters(filter, ignore *WebhookEventFilter, hook string, available []string) {\n\tok := false\n\tfor _, a := range available {\n\t\tif a == hook {\n\t\t\tok = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif ok {\n\t\tif !filter.IsEmpty() && !ignore.IsEmpty() {\n\t\t\tp := filter.Name.Pos\n\t\t\tif p.IsBefore(ignore.Name.Pos) {\n\t\t\t\tp = ignore.Name.Pos\n\t\t\t}\n\t\t\trule.Errorf(p, \"both %q and %q filters cannot be used for the same event %q. note: use '!' to negate patterns\", filter.Name.Value, ignore.Name.Value, hook)\n\t\t}\n\t} else {\n\t\tif !filter.IsEmpty() {\n\t\t\trule.filterNotAvailable(filter.Name.Pos, filter.Name.Value, hook, available)\n\t\t}\n\t\tif !ignore.IsEmpty() {\n\t\t\trule.filterNotAvailable(ignore.Name.Pos, ignore.Name.Value, hook, available)\n\t\t}\n\t}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#webhook-events\nfunc (rule *RuleEvents) checkWebhookEvent(event *WebhookEvent) {\n\thook := event.Hook.Value\n\n\ttypes, ok := AllWebhookTypes[hook]\n\tif !ok {\n\t\trule.Errorf(event.Pos, \"unknown Webhook event %q. see https://docs.github.com/en/actions/learn-github-actions/events-that-trigger-workflows#webhook-events for list of all Webhook event names\", hook)\n\t\treturn\n\t}\n\n\trule.checkTypes(event.Hook, event.Types, types)\n\n\tif hook == \"workflow_run\" {\n\t\tif len(event.Workflows) == 0 {\n\t\t\trule.Error(event.Pos, \"no workflow is configured for \\\"workflow_run\\\" event\")\n\t\t}\n\t} else {\n\t\tif len(event.Workflows) != 0 {\n\t\t\trule.Errorf(event.Pos, \"\\\"workflows\\\" cannot be configured for %q event. it is only for workflow_run event\", hook)\n\t\t}\n\t}\n\n\t// Some filters are available with specific events and exclusive\n\t// - on.merge_group.<branches|branches-ignore>\n\t// - on.<push|pull_request|pull_request_target>.<paths|paths-ignore>\n\t// - on.push.<branches|tags|branches-ignore|tags-ignore>\n\t// - on.<pull_request|pull_request_target>.<branches|branches-ignore>\n\t// - on.workflow_run.<branches|branches-ignore>\n\trule.checkExclusiveFilters(\n\t\tevent.Paths,\n\t\tevent.PathsIgnore,\n\t\thook,\n\t\t[]string{\"push\", \"pull_request\", \"pull_request_target\"},\n\t)\n\trule.checkExclusiveFilters(\n\t\tevent.Branches,\n\t\tevent.BranchesIgnore,\n\t\thook,\n\t\t[]string{\"merge_group\", \"push\", \"pull_request\", \"pull_request_target\", \"workflow_run\"},\n\t)\n\trule.checkExclusiveFilters(\n\t\tevent.Tags,\n\t\tevent.TagsIgnore,\n\t\thook,\n\t\t[]string{\"push\"},\n\t)\n}\n\nfunc (rule *RuleEvents) checkTypes(hook *String, types []*String, expected []string) {\n\tif len(expected) == 0 && len(types) > 0 {\n\t\trule.Errorf(hook.Pos, \"\\\"types\\\" cannot be specified for %q Webhook event\", hook.Value)\n\t\treturn\n\t}\n\n\tfor _, ty := range types {\n\t\tvalid := false\n\t\tfor _, e := range expected {\n\t\t\tif ty.Value == e {\n\t\t\t\tvalid = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !valid {\n\t\t\trule.Errorf(\n\t\t\t\tty.Pos,\n\t\t\t\t\"invalid activity type %q for %q Webhook event. available types are %s\",\n\t\t\t\tty.Value,\n\t\t\t\thook.Value,\n\t\t\t\tsortedQuotes(expected),\n\t\t\t)\n\t\t}\n\t}\n}\n\n// https://docs.github.com/en/actions/learn-github-actions/reusing-workflows\nfunc (rule *RuleEvents) checkWorkflowCallEvent(event *WorkflowCallEvent) {\n\tfor _, i := range event.Inputs {\n\t\tif i.Default == nil {\n\t\t\tcontinue\n\t\t}\n\t\t// ${{ }} is available in the default value\n\t\tif !i.Default.ContainsExpression() {\n\t\t\tswitch i.Type {\n\t\t\tcase WorkflowCallEventInputTypeNumber:\n\t\t\t\tif _, err := strconv.ParseFloat(i.Default.Value, 64); err != nil {\n\t\t\t\t\trule.Errorf(\n\t\t\t\t\t\ti.Default.Pos,\n\t\t\t\t\t\t\"input of workflow_call event %q is typed as number but its default value %q cannot be parsed as a float number: %s\",\n\t\t\t\t\t\ti.Name.Value,\n\t\t\t\t\t\ti.Default.Value,\n\t\t\t\t\t\terr,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\tcase WorkflowCallEventInputTypeBoolean:\n\t\t\t\tif d := strings.ToLower(i.Default.Value); d != \"true\" && d != \"false\" {\n\t\t\t\t\trule.Errorf(\n\t\t\t\t\t\ti.Default.Pos,\n\t\t\t\t\t\t\"input of workflow_call event %q is typed as boolean. its default value must be true or false but got %q\",\n\t\t\t\t\t\ti.Name.Value,\n\t\t\t\t\t\ti.Default.Value,\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif i.IsRequired() {\n\t\t\trule.Errorf(\n\t\t\t\ti.Default.Pos,\n\t\t\t\t\"input %q of workflow_call event has the default value %q, but it is also required. if an input is marked as required, its default value will never be used\",\n\t\t\t\ti.Name.Value,\n\t\t\t\ti.Default.Value,\n\t\t\t)\n\t\t}\n\t}\n}\n\n// https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#onworkflow_dispatchinputs\nfunc (rule *RuleEvents) checkWorkflowDispatchEvent(event *WorkflowDispatchEvent) {\n\tfor n, i := range event.Inputs {\n\t\tif i.Type == WorkflowDispatchEventInputTypeChoice {\n\t\t\tif len(i.Options) == 0 {\n\t\t\t\trule.Errorf(i.Name.Pos, \"input type of %q is \\\"choice\\\" but \\\"options\\\" is not set\", n)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tseen := make(map[string]struct{}, len(i.Options))\n\t\t\tfor _, o := range i.Options {\n\t\t\t\tif _, ok := seen[o.Value]; ok {\n\t\t\t\t\trule.Errorf(o.Pos, \"option %q is duplicated in options of %q input\", o.Value, n)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tseen[o.Value] = struct{}{}\n\t\t\t}\n\t\t\tif i.Default != nil {\n\t\t\t\tvar b quotesBuilder\n\t\t\t\tfor _, o := range i.Options {\n\t\t\t\t\tb.append(o.Value)\n\t\t\t\t}\n\t\t\t\tif _, ok := seen[i.Default.Value]; !ok {\n\t\t\t\t\trule.Errorf(i.Default.Pos, \"default value %q of %q input is not included in its options %q\", i.Default.Value, n, b.build())\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif len(i.Options) > 0 {\n\t\t\t\trule.Errorf(i.Name.Pos, \"\\\"options\\\" can not be set to %q input because its input type is not \\\"choice\\\"\", n)\n\t\t\t}\n\t\t\tif i.Default != nil {\n\t\t\t\t// TODO: Can some check be done for WorkflowDispatchEventInputTypeEnvironment?\n\t\t\t\t// What is suitable for default value of the type? (Or is a default value never suitable?)\n\t\t\t\tswitch i.Type {\n\t\t\t\tcase WorkflowDispatchEventInputTypeNumber:\n\t\t\t\t\tif _, err := strconv.ParseFloat(i.Default.Value, 64); err != nil {\n\t\t\t\t\t\trule.Errorf(\n\t\t\t\t\t\t\ti.Default.Pos,\n\t\t\t\t\t\t\t\"type of %q input is \\\"number\\\" but its default value %q cannot be parsed as a float number: %s\",\n\t\t\t\t\t\t\ti.Name.Value,\n\t\t\t\t\t\t\ti.Default.Value,\n\t\t\t\t\t\t\terr,\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\t\t\t\tcase WorkflowDispatchEventInputTypeBoolean:\n\t\t\t\t\tif d := strings.ToLower(i.Default.Value); d != \"true\" && d != \"false\" {\n\t\t\t\t\t\trule.Errorf(i.Default.Pos, \"type of %q input is \\\"boolean\\\". its default value %q must be \\\"true\\\" or \\\"false\\\"\", n, i.Default.Value)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Maximum number of inputs is 10\n\t// https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#providing-inputs\n\tif len(event.Inputs) > 10 {\n\t\trule.Errorf(\n\t\t\tevent.Pos,\n\t\t\t\"maximum number of inputs for \\\"workflow_dispatch\\\" event is 10 but %d inputs are provided. see https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#providing-inputs\",\n\t\t\tlen(event.Inputs),\n\t\t)\n\t}\n}\n"
        },
        {
          "name": "rule_expression.go",
          "type": "blob",
          "size": 28.80859375,
          "content": "package actionlint\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\n//go:generate go run ./scripts/generate-availability ./availability.go\n\ntype typedExpr struct {\n\tty  ExprType\n\tpos Pos\n}\n\n// RuleExpression is a rule checker to check expression syntax in string values of workflow syntax.\n// It checks syntax and semantics of the expressions including type checks and functions/contexts\n// definitions. For more details see\n// - https://docs.github.com/en/actions/learn-github-actions/contexts\n// - https://docs.github.com/en/actions/learn-github-actions/expressions\ntype RuleExpression struct {\n\tRuleBase\n\tmatrixTy         *ObjectType\n\tstepsTy          *ObjectType\n\tneedsTy          *ObjectType\n\tsecretsTy        *ObjectType\n\tinputsTy         *ObjectType\n\tdispatchInputsTy *ObjectType\n\tjobsTy           *ObjectType\n\tworkflow         *Workflow\n\tlocalActions     *LocalActionsCache\n\tlocalWorkflows   *LocalReusableWorkflowCache\n}\n\n// NewRuleExpression creates new RuleExpression instance.\nfunc NewRuleExpression(actionsCache *LocalActionsCache, workflowCache *LocalReusableWorkflowCache) *RuleExpression {\n\treturn &RuleExpression{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"expression\",\n\t\t\tdesc: \"Syntax and semantics checks for expressions embedded with ${{ }} syntax\",\n\t\t},\n\t\tmatrixTy:         nil,\n\t\tstepsTy:          nil,\n\t\tneedsTy:          nil,\n\t\tsecretsTy:        nil,\n\t\tinputsTy:         nil,\n\t\tdispatchInputsTy: nil,\n\t\tjobsTy:           nil,\n\t\tworkflow:         nil,\n\t\tlocalActions:     actionsCache,\n\t\tlocalWorkflows:   workflowCache,\n\t}\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleExpression) VisitWorkflowPre(n *Workflow) error {\n\trule.checkString(n.Name, \"\")\n\n\tfor _, e := range n.On {\n\t\tswitch e := e.(type) {\n\t\tcase *WebhookEvent:\n\t\t\trule.checkStrings(e.Types, \"\")\n\t\t\trule.checkWebhookEventFilter(e.Branches)\n\t\t\trule.checkWebhookEventFilter(e.BranchesIgnore)\n\t\t\trule.checkWebhookEventFilter(e.Tags)\n\t\t\trule.checkWebhookEventFilter(e.TagsIgnore)\n\t\t\trule.checkWebhookEventFilter(e.Paths)\n\t\t\trule.checkWebhookEventFilter(e.PathsIgnore)\n\t\t\trule.checkStrings(e.Workflows, \"\")\n\t\tcase *ScheduledEvent:\n\t\t\trule.checkStrings(e.Cron, \"\")\n\t\tcase *WorkflowDispatchEvent:\n\t\t\tity := NewEmptyStrictObjectType()\n\t\t\tfor id, i := range e.Inputs {\n\t\t\t\trule.checkString(i.Description, \"\")\n\t\t\t\trule.checkString(i.Default, \"\")\n\t\t\t\trule.checkBool(i.Required, \"\")\n\t\t\t\trule.checkStrings(i.Options, \"\")\n\n\t\t\t\tvar ty ExprType\n\t\t\t\tswitch i.Type {\n\t\t\t\tcase WorkflowDispatchEventInputTypeBoolean:\n\t\t\t\t\tty = BoolType{}\n\t\t\t\tcase WorkflowDispatchEventInputTypeNumber:\n\t\t\t\t\tty = NumberType{}\n\t\t\t\tcase WorkflowDispatchEventInputTypeString, WorkflowDispatchEventInputTypeChoice, WorkflowDispatchEventInputTypeEnvironment:\n\t\t\t\t\tty = StringType{}\n\t\t\t\tdefault:\n\t\t\t\t\tty = AnyType{}\n\t\t\t\t}\n\t\t\t\tity.Props[id] = ty\n\t\t\t}\n\t\t\trule.dispatchInputsTy = ity\n\t\tcase *RepositoryDispatchEvent:\n\t\t\trule.checkStrings(e.Types, \"\")\n\t\tcase *WorkflowCallEvent:\n\t\t\tity := NewEmptyStrictObjectType()\n\n\t\t\t// Set `inputs` context object before checking inputs since input's default values can refer `inputs` context.\n\t\t\t//   inputs:\n\t\t\t//     input1:\n\t\t\t//       type: string\n\t\t\t//     input2:\n\t\t\t//       type: string\n\t\t\t//       default: ${{ inputs.input1 }}\n\t\t\trule.inputsTy = ity\n\n\t\t\tfor _, i := range e.Inputs {\n\t\t\t\trule.checkString(i.Description, \"\")\n\t\t\t\t// Check default value before setting type to `ity` because referring myself should cause an error.\n\t\t\t\t//   inputs:\n\t\t\t\t//     recursive:\n\t\t\t\t//       type: string\n\t\t\t\t//       default: ${{ inputs.recursive }}\n\t\t\t\tts := rule.checkString(i.Default, \"on.workflow_call.inputs.<inputs_id>.default\")\n\n\t\t\t\tvar ty ExprType\n\t\t\t\tswitch i.Type {\n\t\t\t\tcase WorkflowCallEventInputTypeString:\n\t\t\t\t\tty = StringType{}\n\t\t\t\tcase WorkflowCallEventInputTypeBoolean:\n\t\t\t\t\tty = BoolType{}\n\t\t\t\t\tif len(ts) == 1 && i.Default.IsExpressionAssigned() {\n\t\t\t\t\t\tswitch ts[0].ty.(type) {\n\t\t\t\t\t\tcase BoolType, AnyType:\n\t\t\t\t\t\t\t// ok\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\trule.Errorf(i.Default.Pos, \"type of input %q must be bool but found type %s\", i.Name.Value, ts[0].ty.String())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tcase WorkflowCallEventInputTypeNumber:\n\t\t\t\t\tty = NumberType{}\n\t\t\t\t\tif len(ts) == 1 && i.Default.IsExpressionAssigned() {\n\t\t\t\t\t\tswitch ts[0].ty.(type) {\n\t\t\t\t\t\tcase NumberType, AnyType:\n\t\t\t\t\t\t\t// ok\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\trule.Errorf(i.Default.Pos, \"type of input %q must be number but found type %s\", i.Name.Value, ts[0].ty.String())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tty = AnyType{}\n\t\t\t\t}\n\t\t\t\tity.Props[i.ID] = ty\n\t\t\t}\n\n\t\t\t// When no secret is passed, secrets may be inherited from a caller of the workflow.\n\t\t\t// So `secrets` context must be typed as { string => string }. `e.Secrets` is nil when `secrets:` does not\n\t\t\t// exist. When `e.Secrets` is an empty map, `secrets:` exists but it has no child.\n\t\t\tif e.Secrets != nil {\n\t\t\t\tsty := NewEmptyStrictObjectType()\n\t\t\t\tfor id, s := range e.Secrets {\n\t\t\t\t\tsty.Props[id] = StringType{}\n\t\t\t\t\trule.checkString(s.Description, \"\")\n\t\t\t\t}\n\t\t\t\trule.secretsTy = sty\n\t\t\t}\n\n\t\t\tfor _, o := range e.Outputs {\n\t\t\t\trule.checkString(o.Description, \"\")\n\t\t\t\t// o.Value will be checked in VisitWorkflowPost\n\t\t\t}\n\t\t}\n\t}\n\n\trule.checkString(n.RunName, \"run-name\")\n\trule.checkEnv(n.Env, \"env\")\n\n\trule.checkDefaults(n.Defaults, \"\")\n\trule.checkConcurrency(n.Concurrency, \"concurrency\")\n\n\trule.workflow = n\n\treturn nil\n}\n\n// VisitWorkflowPost is callback when visiting Workflow node after visiting its children\nfunc (rule *RuleExpression) VisitWorkflowPost(n *Workflow) error {\n\tif e, ok := n.FindWorkflowCallEvent(); ok {\n\t\trule.checkWorkflowCallOutputs(e.Outputs, n.Jobs)\n\t}\n\trule.workflow = nil\n\treturn nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleExpression) VisitJobPre(n *Job) error {\n\t// Type of needs must be resolved before resolving type of matrix because `needs` context can\n\t// be used in matrix configuration.\n\trule.needsTy = rule.calcNeedsType(n)\n\n\t// Set matrix type at start of VisitJobPre() because matrix values are available in\n\t// jobs.<job_id> section. For example:\n\t//   jobs:\n\t//     foo:\n\t//       strategy:\n\t//         matrix:\n\t//           os: [ubuntu-latest, macos-latest, windows-latest]\n\t//       runs-on: ${{ matrix.os }}\n\tif n.Strategy != nil && n.Strategy.Matrix != nil {\n\t\t// Check and guess type of the matrix\n\t\trule.matrixTy = rule.checkMatrix(n.Strategy.Matrix)\n\t}\n\n\trule.checkString(n.Name, \"jobs.<job_id>.name\")\n\trule.checkStrings(n.Needs, \"\")\n\n\tif n.RunsOn != nil {\n\t\tif n.RunsOn.LabelsExpr != nil {\n\t\t\tif ty := rule.checkOneExpression(n.RunsOn.LabelsExpr, \"runner label at \\\"runs-on\\\" section\", \"jobs.<job_id>.runs-on\"); ty != nil {\n\t\t\t\tswitch ty.(type) {\n\t\t\t\tcase *ArrayType, StringType, AnyType:\n\t\t\t\t\t// OK\n\t\t\t\tdefault:\n\t\t\t\t\trule.Errorf(n.RunsOn.LabelsExpr.Pos, \"type of expression at \\\"runs-on\\\" must be string or array but found type %q\", ty.String())\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, l := range n.RunsOn.Labels {\n\t\t\t\trule.checkString(l, \"jobs.<job_id>.runs-on\")\n\t\t\t}\n\t\t}\n\t\trule.checkString(n.RunsOn.Group, \"jobs.<job_id>.runs-on\")\n\t}\n\n\trule.checkConcurrency(n.Concurrency, \"jobs.<job_id>.concurrency\")\n\n\trule.checkEnv(n.Env, \"jobs.<job_id>.env\")\n\n\trule.checkDefaults(n.Defaults, \"jobs.<job_id>.defaults.run\")\n\trule.checkIfCondition(n.If, \"jobs.<job_id>.if\")\n\n\tif n.Strategy != nil {\n\t\t// Note: Types in \"jobs.<job_id>.strategy.matrix\" were checked `checkMatrix`\n\t\trule.checkBool(n.Strategy.FailFast, \"jobs.<job_id>.strategy\")\n\t\trule.checkInt(n.Strategy.MaxParallel, \"jobs.<job_id>.strategy\")\n\t}\n\n\trule.checkBool(n.ContinueOnError, \"jobs.<job_id>.continue-on-error\")\n\trule.checkFloat(n.TimeoutMinutes, \"jobs.<job_id>.timeout-minutes\")\n\trule.checkContainer(n.Container, \"jobs.<job_id>.container\", \"\")\n\n\tif n.Services != nil {\n\t\trule.checkObjectExpression(n.Services.Expression, \"services\", \"jobs.<job_id>.services\")\n\t\tfor _, s := range n.Services.Value {\n\t\t\trule.checkContainer(s.Container, \"jobs.<job_id>.services\", \"<service_id>\")\n\t\t}\n\t}\n\n\trule.checkWorkflowCall(n.WorkflowCall)\n\n\trule.stepsTy = NewEmptyStrictObjectType()\n\n\treturn nil\n}\n\n// VisitJobPost is callback when visiting Job node after visiting its children\nfunc (rule *RuleExpression) VisitJobPost(n *Job) error {\n\t// 'environment' and 'outputs' sections are evaluated after all steps are run\n\tif n.Environment != nil {\n\t\trule.checkString(n.Environment.Name, \"jobs.<job_id>.environment\")\n\t\trule.checkString(n.Environment.URL, \"jobs.<job_id>.environment.url\")\n\t}\n\tfor _, output := range n.Outputs {\n\t\trule.checkString(output.Value, \"jobs.<job_id>.outputs.<output_id>\")\n\t}\n\n\trule.matrixTy = nil\n\trule.stepsTy = nil\n\trule.needsTy = nil\n\n\treturn nil\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleExpression) VisitStep(n *Step) error {\n\trule.checkString(n.Name, \"jobs.<job_id>.steps.name\")\n\trule.checkIfCondition(n.If, \"jobs.<job_id>.steps.if\")\n\n\tvar spec *String\n\tswitch e := n.Exec.(type) {\n\tcase *ExecRun:\n\t\trule.checkScriptString(e.Run, \"jobs.<job_id>.steps.run\")\n\t\trule.checkString(e.Shell, \"\")\n\t\trule.checkString(e.WorkingDirectory, \"jobs.<job_id>.steps.working-directory\")\n\tcase *ExecAction:\n\t\trule.checkString(e.Uses, \"\")\n\t\tfor n, i := range e.Inputs {\n\t\t\tif e.Uses != nil && strings.HasPrefix(e.Uses.Value, \"actions/github-script@\") && n == \"script\" {\n\t\t\t\trule.checkScriptString(i.Value, \"jobs.<job_id>.steps.with\")\n\t\t\t} else {\n\t\t\t\trule.checkString(i.Value, \"jobs.<job_id>.steps.with\")\n\t\t\t}\n\t\t}\n\t\trule.checkString(e.Entrypoint, \"jobs.<job_id>.steps.with\")\n\t\trule.checkString(e.Args, \"jobs.<job_id>.steps.with\")\n\t\tspec = e.Uses\n\t}\n\n\trule.checkEnv(n.Env, \"jobs.<job_id>.steps.env\") // env: at step level can refer 'env' context (#158)\n\trule.checkBool(n.ContinueOnError, \"jobs.<job_id>.steps.continue-on-error\")\n\trule.checkFloat(n.TimeoutMinutes, \"jobs.<job_id>.steps.timeout-minutes\")\n\n\tif n.ID != nil {\n\t\tif n.ID.ContainsExpression() {\n\t\t\trule.checkString(n.ID, \"\")\n\t\t\trule.stepsTy.Loose()\n\t\t}\n\t\t// Step ID is case insensitive\n\t\tid := strings.ToLower(n.ID.Value)\n\t\trule.stepsTy.Props[id] = NewStrictObjectType(map[string]ExprType{\n\t\t\t\"outputs\":    rule.getActionOutputsType(spec),\n\t\t\t\"conclusion\": StringType{},\n\t\t\t\"outcome\":    StringType{},\n\t\t})\n\t}\n\n\treturn nil\n}\n\n// Get type of `outputs.<output name>`\nfunc (rule *RuleExpression) getActionOutputsType(spec *String) *ObjectType {\n\tif spec == nil {\n\t\treturn NewMapObjectType(StringType{})\n\t}\n\n\tif strings.HasPrefix(spec.Value, \"./\") {\n\t\tmeta, _, err := rule.localActions.FindMetadata(spec.Value)\n\t\tif err != nil {\n\t\t\trule.Error(spec.Pos, err.Error())\n\t\t\treturn NewMapObjectType(StringType{})\n\t\t}\n\t\tif meta == nil {\n\t\t\treturn NewMapObjectType(StringType{})\n\t\t}\n\n\t\treturn typeOfActionOutputs(meta)\n\t}\n\n\t// github-script action allows to set any outputs through calling `core.setOutput` directly.\n\t// So any `outputs.*` properties should be accepted (#104)\n\tif strings.HasPrefix(spec.Value, \"actions/github-script@\") {\n\t\treturn NewEmptyObjectType()\n\t}\n\n\t// When the action run at this step is a popular action, we know what outputs are set by it.\n\t// Set the output names to `steps.{step_id}.outputs.{name}`.\n\tif meta, ok := PopularActions[spec.Value]; ok {\n\t\treturn typeOfActionOutputs(meta)\n\t}\n\n\treturn NewMapObjectType(StringType{})\n}\n\nfunc (rule *RuleExpression) getWorkflowCallOutputsType(call *WorkflowCall) *ObjectType {\n\tif call.Uses == nil {\n\t\treturn NewMapObjectType(StringType{})\n\t}\n\n\tm, err := rule.localWorkflows.FindMetadata(call.Uses.Value)\n\tif err != nil {\n\t\trule.Error(call.Uses.Pos, err.Error())\n\t\treturn NewMapObjectType(StringType{})\n\t}\n\tif m == nil {\n\t\treturn NewMapObjectType(StringType{})\n\t}\n\n\tp := make(map[string]ExprType, len(m.Outputs))\n\tfor n := range m.Outputs {\n\t\tp[n] = StringType{}\n\t}\n\treturn NewStrictObjectType(p)\n}\n\nfunc (rule *RuleExpression) checkOneExpression(s *String, what, workflowKey string) ExprType {\n\t// checkString is not available since it checks types for embedding values into a string\n\tif s == nil {\n\t\treturn nil\n\t}\n\n\tts, ok := rule.checkExprsIn(s.Value, s.Pos, s.Quoted, false, workflowKey)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\tif len(ts) != 1 {\n\t\t// This case should be unreachable since only one ${{ }} is included is checked by parser\n\t\trule.Errorf(s.Pos, \"one ${{ }} expression should be included in %q value but got %d expressions\", what, len(ts))\n\t\treturn nil\n\t}\n\n\treturn ts[0].ty\n}\n\nfunc (rule *RuleExpression) checkObjectTy(ty ExprType, pos *Pos, what string) ExprType {\n\tif ty == nil {\n\t\treturn nil\n\t}\n\tswitch ty.(type) {\n\tcase *ObjectType, AnyType:\n\t\treturn ty\n\tdefault:\n\t\trule.Errorf(pos, \"type of expression at %q must be object but found type %s\", what, ty.String())\n\t\treturn nil\n\t}\n}\n\nfunc (rule *RuleExpression) checkArrayTy(ty ExprType, pos *Pos, what string) ExprType {\n\tif ty == nil {\n\t\treturn nil\n\t}\n\tswitch ty.(type) {\n\tcase *ArrayType, AnyType:\n\t\treturn ty\n\tdefault:\n\t\trule.Errorf(pos, \"type of expression at %q must be array but found type %s\", what, ty.String())\n\t\treturn nil\n\t}\n}\n\nfunc (rule *RuleExpression) checkNumberTy(ty ExprType, pos *Pos, what string) ExprType {\n\tif ty == nil {\n\t\treturn nil\n\t}\n\tswitch ty.(type) {\n\tcase NumberType, AnyType:\n\t\treturn ty\n\tdefault:\n\t\trule.Errorf(pos, \"type of expression at %q must be number but found type %s\", what, ty.String())\n\t\treturn nil\n\t}\n}\n\nfunc (rule *RuleExpression) checkObjectExpression(s *String, what, workflowKey string) ExprType {\n\tty := rule.checkOneExpression(s, what, workflowKey)\n\tif ty == nil {\n\t\treturn nil\n\t}\n\treturn rule.checkObjectTy(ty, s.Pos, what)\n}\n\nfunc (rule *RuleExpression) checkArrayExpression(s *String, what, workflowKey string) ExprType {\n\tty := rule.checkOneExpression(s, what, workflowKey)\n\tif ty == nil {\n\t\treturn nil\n\t}\n\treturn rule.checkArrayTy(ty, s.Pos, what)\n}\n\nfunc (rule *RuleExpression) checkNumberExpression(s *String, what, workflowKey string) ExprType {\n\tty := rule.checkOneExpression(s, what, workflowKey)\n\tif ty == nil {\n\t\treturn nil\n\t}\n\treturn rule.checkNumberTy(ty, s.Pos, what)\n}\n\nfunc (rule *RuleExpression) checkEnv(env *Env, workflowKey string) {\n\tif env == nil {\n\t\treturn\n\t}\n\n\tif env.Vars != nil {\n\t\tfor _, e := range env.Vars {\n\t\t\trule.checkString(e.Name, workflowKey)\n\t\t\trule.checkString(e.Value, workflowKey)\n\t\t}\n\t\treturn\n\t}\n\n\t// When form of \"env: ${{...}}\"\n\trule.checkObjectExpression(env.Expression, \"env\", workflowKey)\n}\n\nfunc (rule *RuleExpression) checkContainer(c *Container, workflowKey, childWorkflowKeyPrefix string) {\n\tif c == nil {\n\t\treturn\n\t}\n\tchildWorkflowKey := workflowKey\n\tif childWorkflowKeyPrefix != \"\" {\n\t\tchildWorkflowKey += \".\" + childWorkflowKeyPrefix\n\t}\n\trule.checkString(c.Image, workflowKey)\n\tif c.Credentials != nil {\n\t\tk := childWorkflowKey + \".credentials\" // e.g. jobs.<job_id>.container.credentials\n\t\trule.checkString(c.Credentials.Username, k)\n\t\trule.checkString(c.Credentials.Password, k)\n\t}\n\trule.checkEnv(c.Env, childWorkflowKey+\".env.<env_id>\") // e.g. jobs.<job_id>.container.env.<env_id>\n\trule.checkStrings(c.Ports, workflowKey)\n\trule.checkStrings(c.Volumes, workflowKey)\n\trule.checkString(c.Options, workflowKey)\n}\n\nfunc (rule *RuleExpression) checkConcurrency(c *Concurrency, workflowKey string) {\n\tif c == nil {\n\t\treturn\n\t}\n\trule.checkString(c.Group, workflowKey)\n\trule.checkBool(c.CancelInProgress, workflowKey)\n}\n\nfunc (rule *RuleExpression) checkDefaults(d *Defaults, workflowKey string) {\n\tif d == nil || d.Run == nil {\n\t\treturn\n\t}\n\trule.checkString(d.Run.Shell, workflowKey)\n\trule.checkString(d.Run.WorkingDirectory, workflowKey)\n}\n\nfunc (rule *RuleExpression) checkWorkflowCall(c *WorkflowCall) {\n\tif c == nil || c.Uses == nil {\n\t\treturn\n\t}\n\n\trule.checkString(c.Uses, \"\")\n\n\tm, err := rule.localWorkflows.FindMetadata(c.Uses.Value)\n\tif err != nil {\n\t\trule.Error(c.Uses.Pos, err.Error())\n\t}\n\n\tfor n, i := range c.Inputs {\n\t\tts := rule.checkString(i.Value, \"jobs.<job_id>.with.<with_id>\")\n\n\t\tif m == nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tmi, ok := m.Inputs[n]\n\t\tif !ok || mi == nil {\n\t\t\tcontinue\n\t\t}\n\t\tif _, ok := mi.Type.(AnyType); ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tv := strings.TrimSpace(i.Value.Value)\n\n\t\tvar ty ExprType = StringType{}\n\t\tswitch len(ts) {\n\t\tcase 0:\n\t\t\tswitch v {\n\t\t\tcase \"null\":\n\t\t\t\tty = NullType{}\n\t\t\tcase \"true\", \"false\":\n\t\t\t\tty = BoolType{}\n\t\t\tdefault:\n\t\t\t\tif _, err := strconv.ParseFloat(v, 64); err == nil {\n\t\t\t\t\tty = NumberType{}\n\t\t\t\t}\n\t\t\t}\n\t\tcase 1:\n\t\t\tif i.Value.IsExpressionAssigned() {\n\t\t\t\tty = ts[0].ty\n\t\t\t}\n\t\t}\n\n\t\tif !mi.Type.Assignable(ty) {\n\t\t\trule.Errorf(\n\t\t\t\ti.Value.Pos,\n\t\t\t\t\"input %q is typed as %s by reusable workflow %q. %s value cannot be assigned\",\n\t\t\t\tmi.Name,\n\t\t\t\tmi.Type.String(),\n\t\t\t\tc.Uses.Value,\n\t\t\t\tty.String(),\n\t\t\t)\n\t\t}\n\t}\n\n\tfor _, s := range c.Secrets {\n\t\trule.checkString(s.Value, \"jobs.<job_id>.secrets.<secrets_id>\")\n\t}\n}\n\nfunc (rule *RuleExpression) checkWebhookEventFilter(f *WebhookEventFilter) {\n\tif f == nil {\n\t\treturn\n\t}\n\trule.checkStrings(f.Values, \"\")\n}\n\nfunc (rule *RuleExpression) checkStrings(ss []*String, workflowKey string) {\n\tfor _, s := range ss {\n\t\trule.checkString(s, workflowKey)\n\t}\n}\n\nfunc (rule *RuleExpression) checkIfCondition(str *String, workflowKey string) {\n\tif str == nil {\n\t\treturn\n\t}\n\n\t// Note:\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idif\n\t//\n\t// > When you use expressions in an if conditional, you may omit the expression syntax (${{ }})\n\t// > because GitHub automatically evaluates the if conditional as an expression, unless the\n\t// > expression contains any operators. If the expression contains any operators, the expression\n\t// > must be contained within ${{ }} to explicitly mark it for evaluation.\n\t//\n\t// This document is actually wrong. I confirmed that any strings without surrounding in ${{ }}\n\t// are evaluated.\n\t//\n\t// - run: echo 'run'\n\t//   if: '!false'\n\t// - run: echo 'not run'\n\t//   if: '!true'\n\t// - run: echo 'run'\n\t//   if: false || true\n\t// - run: echo 'run'\n\t//   if: true && true\n\t// - run: echo 'not run'\n\t//   if: true && false\n\n\tvar condTy ExprType\n\tif str.ContainsExpression() {\n\t\tts := rule.checkString(str, workflowKey)\n\n\t\tif len(ts) == 1 {\n\t\t\tif str.IsExpressionAssigned() {\n\t\t\t\tcondTy = ts[0].ty\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc := str.Value + \"}}\" // }} is necessary since lexer lexes it as end of tokens\n\t\tline, col := str.Pos.Line, str.Pos.Col\n\n\t\tp := NewExprParser()\n\t\texpr, err := p.Parse(NewExprLexer(src))\n\t\tif err != nil {\n\t\t\trule.exprError(err, line, col)\n\t\t\treturn\n\t\t}\n\n\t\tif ty, ok := rule.checkSemanticsOfExprNode(expr, line, col, false, workflowKey); ok {\n\t\t\tcondTy = ty\n\t\t}\n\t}\n\n\tif condTy != nil && !(BoolType{}).Assignable(condTy) {\n\t\trule.Errorf(str.Pos, \"\\\"if\\\" condition should be type \\\"bool\\\" but got type %q\", condTy.String())\n\t}\n}\n\nfunc (rule *RuleExpression) checkTemplateEvaluatedType(ts []typedExpr) {\n\tfor _, t := range ts {\n\t\tswitch t.ty.(type) {\n\t\tcase *ObjectType, *ArrayType, NullType:\n\t\t\trule.Errorf(&t.pos, \"object, array, and null values should not be evaluated in template with ${{ }} but evaluating the value of type %s\", t.ty)\n\t\t}\n\t}\n}\n\nfunc (rule *RuleExpression) checkString(str *String, workflowKey string) []typedExpr {\n\tif str == nil {\n\t\treturn nil\n\t}\n\n\tts, ok := rule.checkExprsIn(str.Value, str.Pos, str.Quoted, false, workflowKey)\n\tif !ok {\n\t\treturn nil\n\t}\n\n\trule.checkTemplateEvaluatedType(ts)\n\treturn ts\n}\n\nfunc (rule *RuleExpression) checkScriptString(str *String, workflowKey string) {\n\tif str == nil {\n\t\treturn\n\t}\n\n\tts, ok := rule.checkExprsIn(str.Value, str.Pos, str.Quoted, true, workflowKey)\n\tif !ok {\n\t\treturn\n\t}\n\n\trule.checkTemplateEvaluatedType(ts)\n}\n\nfunc (rule *RuleExpression) checkBool(b *Bool, workflowKey string) {\n\tif b == nil || b.Expression == nil {\n\t\treturn\n\t}\n\n\tty := rule.checkOneExpression(b.Expression, \"bool value\", workflowKey)\n\tif ty == nil {\n\t\treturn\n\t}\n\n\tswitch ty.(type) {\n\tcase BoolType, AnyType:\n\t\t// ok\n\tdefault:\n\t\trule.Errorf(b.Expression.Pos, \"type of expression must be bool but found type %s\", ty.String())\n\t}\n}\n\nfunc (rule *RuleExpression) checkInt(i *Int, workflowKey string) {\n\tif i == nil {\n\t\treturn\n\t}\n\trule.checkNumberExpression(i.Expression, \"integer value\", workflowKey)\n}\n\nfunc (rule *RuleExpression) checkFloat(f *Float, workflowKey string) {\n\tif f == nil {\n\t\treturn\n\t}\n\trule.checkNumberExpression(f.Expression, \"float number value\", workflowKey)\n}\n\nfunc (rule *RuleExpression) checkExprsIn(s string, pos *Pos, quoted, checkUntrusted bool, workflowKey string) ([]typedExpr, bool) {\n\t// TODO: Line number is not correct when the string contains newlines.\n\n\tline, col := pos.Line, pos.Col\n\tif quoted {\n\t\tcol++ // when the string is quoted like 'foo' or \"foo\", column should be incremented\n\t}\n\toffset := 0\n\tts := []typedExpr{}\n\tfor {\n\t\tidx := strings.Index(s, \"${{\")\n\t\tif idx == -1 {\n\t\t\tbreak\n\t\t}\n\n\t\tstart := idx + 3 // 3 means removing \"${{\"\n\t\ts = s[start:]\n\t\toffset += start\n\t\tcol := col + offset\n\n\t\tty, offsetAfter, ok := rule.checkSemantics(s, line, col, checkUntrusted, workflowKey)\n\t\tif !ok {\n\t\t\treturn nil, false\n\t\t}\n\t\tif ty == nil || offsetAfter == 0 {\n\t\t\treturn nil, true\n\t\t}\n\t\tts = append(ts, typedExpr{ty, Pos{line, col - 3}})\n\n\t\ts = s[offsetAfter:]\n\t\toffset += offsetAfter\n\t}\n\n\treturn ts, true\n}\n\nfunc (rule *RuleExpression) exprError(err *ExprError, lineBase, colBase int) {\n\tpos := convertExprLineColToPos(err.Line, err.Column, lineBase, colBase)\n\trule.Error(pos, err.Message)\n}\n\nfunc (rule *RuleExpression) checkSemanticsOfExprNode(expr ExprNode, line, col int, checkUntrusted bool, workflowKey string) (ExprType, bool) {\n\tvar v []string\n\tif rule.config != nil {\n\t\tv = rule.config.ConfigVariables\n\t}\n\tc := NewExprSemanticsChecker(checkUntrusted, v)\n\tif rule.matrixTy != nil {\n\t\tc.UpdateMatrix(rule.matrixTy)\n\t}\n\tif rule.stepsTy != nil {\n\t\tc.UpdateSteps(rule.stepsTy)\n\t}\n\tif rule.needsTy != nil {\n\t\tc.UpdateNeeds(rule.needsTy)\n\t}\n\tif rule.secretsTy != nil {\n\t\tc.UpdateSecrets(rule.secretsTy)\n\t}\n\tif rule.inputsTy != nil {\n\t\tc.UpdateInputs(rule.inputsTy)\n\t}\n\tif rule.dispatchInputsTy != nil {\n\t\tc.UpdateDispatchInputs(rule.dispatchInputsTy)\n\t}\n\tif rule.jobsTy != nil {\n\t\tc.UpdateJobs(rule.jobsTy)\n\t}\n\tif workflowKey != \"\" {\n\t\tctx, sp := WorkflowKeyAvailability(workflowKey)\n\t\tif len(ctx) == 0 {\n\t\t\trule.Debug(\"No context availability was found for workflow key %q\", workflowKey)\n\t\t}\n\t\tc.SetContextAvailability(ctx)\n\t\tc.SetSpecialFunctionAvailability(sp)\n\t}\n\n\tty, errs := c.Check(expr)\n\tfor _, err := range errs {\n\t\trule.exprError(err, line, col)\n\t}\n\n\treturn ty, len(errs) == 0\n}\n\nfunc (rule *RuleExpression) checkSemantics(src string, line, col int, checkUntrusted bool, workflowKey string) (ExprType, int, bool) {\n\tl := NewExprLexer(src)\n\tp := NewExprParser()\n\texpr, err := p.Parse(l)\n\tif err != nil {\n\t\trule.exprError(err, line, col)\n\t\treturn nil, l.Offset(), false\n\t}\n\tt, ok := rule.checkSemanticsOfExprNode(expr, line, col, checkUntrusted, workflowKey)\n\treturn t, l.Offset(), ok\n}\n\nfunc (rule *RuleExpression) calcNeedsType(job *Job) *ObjectType {\n\t// https://docs.github.com/en/actions/learn-github-actions/contexts#needs-context\n\to := NewEmptyStrictObjectType()\n\trule.populateDependantNeedsTypes(o, job, job)\n\treturn o\n}\n\nfunc (rule *RuleExpression) populateDependantNeedsTypes(out *ObjectType, job *Job, root *Job) {\n\tfor _, id := range job.Needs {\n\t\ti := strings.ToLower(id.Value) // ID is case insensitive\n\t\tif i == root.ID.Value {\n\t\t\tcontinue // When cyclic dependency exists. This does not happen normally.\n\t\t}\n\t\tif _, ok := out.Props[i]; ok {\n\t\t\tcontinue // Already added\n\t\t}\n\n\t\tj, ok := rule.workflow.Jobs[i]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tvar outputs *ObjectType\n\t\tif j.WorkflowCall == nil {\n\t\t\toutputs = NewEmptyStrictObjectType()\n\t\t\tfor name := range j.Outputs {\n\t\t\t\toutputs.Props[name] = StringType{}\n\t\t\t}\n\t\t} else {\n\t\t\toutputs = rule.getWorkflowCallOutputsType(j.WorkflowCall)\n\t\t}\n\n\t\tout.Props[i] = NewStrictObjectType(map[string]ExprType{\n\t\t\t\"outputs\": outputs,\n\t\t\t\"result\":  StringType{},\n\t\t})\n\n\t\t// Do not collect outputs type from parent of parent recursively. (#151)\n\t}\n}\n\nfunc (rule *RuleExpression) checkMatrixExpression(expr *String) *ObjectType {\n\tty := rule.checkObjectExpression(expr, \"matrix\", \"jobs.<job_id>.strategy\")\n\tif ty == nil {\n\t\treturn NewEmptyObjectType()\n\t}\n\tmatTy, ok := ty.(*ObjectType)\n\tif !ok {\n\t\treturn NewEmptyObjectType()\n\t}\n\n\t// Consider properties in include section elements since 'include' section adds matrix values\n\tincTy, ok := matTy.Props[\"include\"]\n\tif ok {\n\t\tdelete(matTy.Props, \"include\")\n\t\tif a, ok := incTy.(*ArrayType); ok {\n\t\t\tif o, ok := a.Elem.(*ObjectType); ok {\n\t\t\t\tfor n, p := range o.Props {\n\t\t\t\t\tt, ok := matTy.Props[n]\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\tmatTy.Props[n] = p\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tmatTy.Props[n] = t.Merge(p)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdelete(matTy.Props, \"exclude\")\n\n\treturn matTy\n}\n\nfunc (rule *RuleExpression) checkMatrix(m *Matrix) *ObjectType {\n\tif m.Expression != nil {\n\t\treturn rule.checkMatrixExpression(m.Expression)\n\t}\n\n\t// Check types of \"exclude\" but they are not used to guess type of matrix\n\tif m.Exclude != nil {\n\t\tif m.Exclude.Expression != nil {\n\t\t\tif ty, ok := rule.checkArrayExpression(m.Exclude.Expression, \"exclude\", \"jobs.<job_id>.strategy\").(*ArrayType); ok {\n\t\t\t\trule.checkObjectTy(ty.Elem, m.Exclude.Expression.Pos, \"exclude\")\n\t\t\t}\n\t\t} else {\n\t\t\tfor _, combi := range m.Exclude.Combinations {\n\t\t\t\tif combi.Expression != nil {\n\t\t\t\t\trule.checkObjectExpression(combi.Expression, \"exclude\", \"jobs.<job_id>.strategy\")\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tfor _, a := range combi.Assigns {\n\t\t\t\t\trule.checkRawYAMLValue(a.Value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\to := NewEmptyStrictObjectType()\n\n\tfor n, r := range m.Rows {\n\t\to.Props[n] = rule.checkMatrixRow(r)\n\t}\n\n\tif m.Include == nil {\n\t\treturn o\n\t}\n\n\tif m.Include.Expression != nil {\n\t\tif a, ok := rule.checkOneExpression(m.Include.Expression, \"include\", \"jobs.<job_id>.strategy\").(*ArrayType); ok {\n\t\t\tif ret, ok := o.Merge(a.Elem).(*ObjectType); ok {\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t\treturn NewEmptyObjectType()\n\t}\n\n\tfor _, combi := range m.Include.Combinations {\n\t\tif combi.Expression != nil {\n\t\t\tty := rule.checkOneExpression(m.Include.Expression, \"matrix combination at element of include section\", \"jobs.<job_id>.strategy\")\n\t\t\tif ty == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif merged, ok := o.Merge(ty).(*ObjectType); ok {\n\t\t\t\to = merged\n\t\t\t} else {\n\t\t\t\to.Loose()\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tfor n, assign := range combi.Assigns {\n\t\t\tty := rule.checkRawYAMLValue(assign.Value)\n\t\t\tif t, ok := o.Props[n]; ok {\n\t\t\t\t// When the combination exists in 'matrix' section, merge type with existing one\n\t\t\t\tty = t.Merge(ty)\n\t\t\t}\n\t\t\to.Props[n] = ty\n\t\t}\n\t}\n\n\treturn o\n}\n\nfunc (rule *RuleExpression) checkMatrixRow(r *MatrixRow) ExprType {\n\tif r.Expression != nil {\n\t\tif a, ok := rule.checkArrayExpression(r.Expression, \"matrix row\", \"jobs.<job_id>.strategy\").(*ArrayType); ok {\n\t\t\treturn a.Elem\n\t\t}\n\t\treturn AnyType{}\n\t}\n\n\tvar ty ExprType\n\tfor _, v := range r.Values {\n\t\tt := rule.checkRawYAMLValue(v)\n\t\tif ty == nil {\n\t\t\tty = t\n\t\t} else {\n\t\t\tty = ty.Merge(t)\n\t\t}\n\t}\n\n\tif ty == nil {\n\t\treturn AnyType{} // No element\n\t}\n\n\treturn ty\n}\n\nfunc (rule *RuleExpression) checkWorkflowCallOutputs(outputs map[string]*WorkflowCallEventOutput, jobs map[string]*Job) {\n\tif len(outputs) == 0 || len(jobs) == 0 {\n\t\treturn\n\t}\n\n\tprops := make(map[string]ExprType, len(jobs))\n\tfor n, j := range jobs {\n\t\tvar o *ObjectType\n\t\tif j.WorkflowCall != nil {\n\t\t\t// Outputs are not defined in jobs.<job_id> section when it is reusable workflow call.\n\t\t\to = NewEmptyObjectType()\n\t\t} else {\n\t\t\tp := make(map[string]ExprType, len(j.Outputs))\n\t\t\tfor n := range j.Outputs {\n\t\t\t\tp[n] = StringType{}\n\t\t\t}\n\t\t\to = NewStrictObjectType(p)\n\t\t}\n\t\tprops[n] = NewStrictObjectType(map[string]ExprType{\n\t\t\t\"outputs\": o,\n\t\t})\n\t}\n\trule.jobsTy = NewStrictObjectType(props)\n\n\tfor _, o := range outputs {\n\t\trule.checkString(o.Value, \"on.workflow_call.outputs.<output_id>.value\")\n\t}\n}\n\nfunc (rule *RuleExpression) checkRawYAMLValue(v RawYAMLValue) ExprType {\n\tswitch v := v.(type) {\n\tcase *RawYAMLObject:\n\t\tm := make(map[string]ExprType, len(v.Props))\n\t\tfor k, p := range v.Props {\n\t\t\tm[k] = rule.checkRawYAMLValue(p)\n\t\t}\n\t\treturn NewStrictObjectType(m)\n\tcase *RawYAMLArray:\n\t\tif len(v.Elems) == 0 {\n\t\t\treturn &ArrayType{AnyType{}, false}\n\t\t}\n\t\telem := rule.checkRawYAMLValue(v.Elems[0])\n\t\tfor _, v := range v.Elems[1:] {\n\t\t\telem = elem.Merge(rule.checkRawYAMLValue(v))\n\t\t}\n\t\treturn &ArrayType{elem, false}\n\tcase *RawYAMLString:\n\t\treturn rule.checkRawYAMLString(v)\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (rule *RuleExpression) checkRawYAMLString(y *RawYAMLString) ExprType {\n\tts, ok := rule.checkExprsIn(y.Value, y.Pos(), false, false, \"jobs.<job_id>.strategy\")\n\n\tif isExprAssigned(y.Value) {\n\t\tif !ok || len(ts) != 1 {\n\t\t\treturn AnyType{}\n\t\t}\n\t\treturn ts[0].ty\n\t}\n\n\ts := strings.TrimSpace(y.Value)\n\t// Note that keywords are case sensitive. TRUE, FALSE, NULL are invalid named value.\n\tif s == \"true\" || s == \"false\" {\n\t\treturn BoolType{}\n\t}\n\tif s == \"null\" {\n\t\treturn NullType{}\n\t}\n\tif _, err := strconv.ParseFloat(s, 64); err == nil {\n\t\treturn NumberType{}\n\t}\n\treturn StringType{}\n}\n\nfunc convertExprLineColToPos(line, col, lineBase, colBase int) *Pos {\n\t// Line and column in ExprError are 1-based\n\treturn &Pos{\n\t\tLine: line - 1 + lineBase,\n\t\tCol:  col - 1 + colBase,\n\t}\n}\n\nfunc typeOfActionOutputs(meta *ActionMetadata) *ObjectType {\n\t// Some action sets outputs dynamically. Such outputs are not defined in action.yml. actionlint\n\t// cannot check such outputs statically so it allows any props (#18)\n\tif meta.SkipOutputs {\n\t\treturn NewEmptyObjectType()\n\t}\n\tprops := make(map[string]ExprType, len(meta.Outputs))\n\tfor n := range meta.Outputs {\n\t\tprops[strings.ToLower(n)] = StringType{}\n\t}\n\treturn NewStrictObjectType(props)\n}\n"
        },
        {
          "name": "rule_glob.go",
          "type": "blob",
          "size": 1.8779296875,
          "content": "package actionlint\n\n// RuleGlob is a rule to check glob syntax.\n// https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet\ntype RuleGlob struct {\n\tRuleBase\n}\n\n// NewRuleGlob creates new RuleGlob instance.\nfunc NewRuleGlob() *RuleGlob {\n\treturn &RuleGlob{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"glob\",\n\t\t\tdesc: \"Checks for glob syntax used in branch names, tags, and paths\",\n\t\t},\n\t}\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleGlob) VisitWorkflowPre(n *Workflow) error {\n\tfor _, e := range n.On {\n\t\tif w, ok := e.(*WebhookEvent); ok {\n\t\t\trule.checkGitRefGlobs(w.Branches)\n\t\t\trule.checkGitRefGlobs(w.BranchesIgnore)\n\t\t\trule.checkGitRefGlobs(w.Tags)\n\t\t\trule.checkGitRefGlobs(w.TagsIgnore)\n\t\t\trule.checkFilePathGlobs(w.Paths)\n\t\t\trule.checkFilePathGlobs(w.PathsIgnore)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (rule *RuleGlob) checkGitRefGlobs(filter *WebhookEventFilter) {\n\tif filter == nil {\n\t\treturn\n\t}\n\tfor _, v := range filter.Values {\n\t\t// Empty value is already checked by parser. Avoid duplicate errors\n\t\tif v.Value != \"\" {\n\t\t\trule.globErrors(ValidateRefGlob(v.Value), v.Pos, v.Quoted)\n\t\t}\n\t}\n}\n\nfunc (rule *RuleGlob) checkFilePathGlobs(filter *WebhookEventFilter) {\n\tif filter == nil {\n\t\treturn\n\t}\n\tfor _, v := range filter.Values {\n\t\t// Empty value is already checked by parser. Avoid duplicate errors\n\t\tif v.Value != \"\" {\n\t\t\trule.globErrors(ValidatePathGlob(v.Value), v.Pos, v.Quoted)\n\t\t}\n\t}\n}\n\nfunc (rule *RuleGlob) globErrors(errs []InvalidGlobPattern, pos *Pos, quoted bool) {\n\tfor i := range errs {\n\t\terr := &errs[i]\n\t\tp := *pos\n\t\tif quoted {\n\t\t\tp.Col++\n\t\t}\n\t\tif err.Column != 0 {\n\t\t\tp.Col += err.Column - 1\n\t\t}\n\t\trule.Errorf(&p, \"%s. note: filter pattern syntax is explained at https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet\", err.Message)\n\t}\n}\n"
        },
        {
          "name": "rule_id.go",
          "type": "blob",
          "size": 1.6474609375,
          "content": "package actionlint\n\nimport (\n\t\"regexp\"\n\t\"strings\"\n)\n\nvar jobIDPattern = regexp.MustCompile(`^[a-zA-Z_][a-zA-Z0-9_-]*$`)\n\n// RuleID is a rule to check step IDs in workflow.\ntype RuleID struct {\n\tRuleBase\n\tseen map[string]*Pos\n}\n\n// NewRuleID creates a new RuleID instance.\nfunc NewRuleID() *RuleID {\n\treturn &RuleID{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"id\",\n\t\t\tdesc: \"Checks for duplication and naming convention of job/step IDs\",\n\t\t},\n\t}\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleID) VisitJobPre(n *Job) error {\n\trule.seen = map[string]*Pos{}\n\n\trule.validateConvention(n.ID, \"job\")\n\tfor _, j := range n.Needs {\n\t\trule.validateConvention(j, \"job\")\n\t}\n\n\treturn nil\n}\n\n// VisitJobPost is callback when visiting Job node after visiting its children.\nfunc (rule *RuleID) VisitJobPost(n *Job) error {\n\trule.seen = nil\n\treturn nil\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleID) VisitStep(n *Step) error {\n\tif n.ID == nil {\n\t\treturn nil\n\t}\n\n\trule.validateConvention(n.ID, \"step\")\n\n\tid := strings.ToLower(n.ID.Value)\n\tif prev, ok := rule.seen[id]; ok {\n\t\trule.Errorf(n.ID.Pos, \"step ID %q duplicates. previously defined at %s. step ID must be unique within a job. note that step ID is case insensitive\", n.ID.Value, prev.String())\n\t\treturn nil\n\t}\n\trule.seen[id] = n.ID.Pos\n\treturn nil\n}\n\nfunc (rule *RuleID) validateConvention(id *String, what string) {\n\tif id == nil || id.Value == \"\" || id.ContainsExpression() || jobIDPattern.MatchString(id.Value) {\n\t\treturn\n\t}\n\trule.Errorf(id.Pos, \"invalid %s ID %q. %s ID must start with a letter or _ and contain only alphanumeric characters, -, or _\", what, id.Value, what)\n}\n"
        },
        {
          "name": "rule_id_test.go",
          "type": "blob",
          "size": 1.943359375,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestCheckInvalidJobNames(t *testing.T) {\n\t// Note: Empty string is already reported as error by parser\n\tinputs := []string{\n\t\t\"-foo\",\n\t\t\"v1.2.3\",\n\t\t\"hello!\",\n\t\t\"\",\n\t\t\"12345\",\n\t}\n\n\tfor _, input := range inputs {\n\t\ttests := []struct {\n\t\t\twhere    string\n\t\t\tjob      *Job\n\t\t\texpected string\n\t\t}{\n\t\t\t{\n\t\t\t\t\"jobs.<job_id>\",\n\t\t\t\t&Job{\n\t\t\t\t\tID: &String{Value: input, Pos: &Pos{}},\n\t\t\t\t},\n\t\t\t\t\"invalid job ID\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"jobs.<job_id>.needs\",\n\t\t\t\t&Job{\n\t\t\t\t\tID: &String{Value: \"test\", Pos: &Pos{}},\n\t\t\t\t\tNeeds: []*String{\n\t\t\t\t\t\t{Value: input, Pos: &Pos{}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"invalid job ID\",\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"steps.*.id\",\n\t\t\t\t&Job{\n\t\t\t\t\tSteps: []*Step{\n\t\t\t\t\t\t{ID: &String{Value: input, Pos: &Pos{}}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\t\"invalid step ID\",\n\t\t\t},\n\t\t}\n\n\t\tfor _, tc := range tests {\n\t\t\tt.Run(input+\"/\"+tc.where, func(t *testing.T) {\n\t\t\t\tr := NewRuleID()\n\t\t\t\tr.VisitJobPre(tc.job)\n\t\t\t\tfor _, s := range tc.job.Steps {\n\t\t\t\t\tr.VisitStep(s)\n\t\t\t\t}\n\t\t\t\terrs := r.Errs()\n\t\t\t\tif len(errs) != 1 {\n\t\t\t\t\tt.Fatalf(\"Wanted exactly one error but got %d errors: %v\", len(errs), errs)\n\t\t\t\t}\n\t\t\t\tmsg := errs[0].Error()\n\t\t\t\tif !strings.Contains(msg, tc.expected) {\n\t\t\t\t\tt.Errorf(\"Error message %q should contain %q\", msg, tc.expected)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc TestCheckValidJobNames(t *testing.T) {\n\tinputs := []string{\n\t\t\"foo-bar\",\n\t\t\"foo_bar\",\n\t\t\"foo--bar\",\n\t\t\"foo__bar\",\n\t\t\"_FOO123-\",\n\t\t\"abcdefhijklmnopqrstuvwxyzABCDEFHIJKLMNOPQRSTUVWXYZ\",\n\t\t\"_____\",\n\t\t\"_-_-_\",\n\t}\n\n\tfor _, input := range inputs {\n\t\tt.Run(input, func(t *testing.T) {\n\t\t\tjob := &Job{\n\t\t\t\tID: &String{Value: input, Pos: &Pos{}},\n\t\t\t\tNeeds: []*String{\n\t\t\t\t\t{Value: input, Pos: &Pos{}},\n\t\t\t\t},\n\t\t\t\tSteps: []*Step{\n\t\t\t\t\t{ID: &String{Value: input, Pos: &Pos{}}},\n\t\t\t\t},\n\t\t\t}\n\t\t\tr := NewRuleID()\n\t\t\tr.VisitJobPre(job)\n\t\t\tfor _, s := range job.Steps {\n\t\t\t\tr.VisitStep(s)\n\t\t\t}\n\t\t\terrs := r.Errs()\n\t\t\tif len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"Unexpected error(s): %#v\", errs)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "rule_if_cond.go",
          "type": "blob",
          "size": 1.126953125,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n)\n\n// RuleIfCond is a rule to check if: conditions.\ntype RuleIfCond struct {\n\tRuleBase\n}\n\n// NewRuleIfCond creates new RuleIfCond instance.\nfunc NewRuleIfCond() *RuleIfCond {\n\treturn &RuleIfCond{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"if-cond\",\n\t\t\tdesc: \"Checks for if: conditions which are always true/false\",\n\t\t},\n\t}\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleIfCond) VisitStep(n *Step) error {\n\trule.checkIfCond(n.If)\n\treturn nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleIfCond) VisitJobPre(n *Job) error {\n\trule.checkIfCond(n.If)\n\treturn nil\n}\n\nfunc (rule *RuleIfCond) checkIfCond(n *String) {\n\tif n == nil {\n\t\treturn\n\t}\n\tif !n.ContainsExpression() {\n\t\treturn\n\t}\n\t// Check number of ${{ }} for conditions like `${{ false }} || ${{ true }}` which are always evaluated to true\n\tif strings.HasPrefix(n.Value, \"${{\") && strings.HasSuffix(n.Value, \"}}\") && strings.Count(n.Value, \"${{\") == 1 {\n\t\treturn\n\t}\n\trule.Errorf(\n\t\tn.Pos,\n\t\t\"if: condition %q is always evaluated to true because extra characters are around ${{ }}\",\n\t\tn.Value,\n\t)\n}\n"
        },
        {
          "name": "rule_if_cond_test.go",
          "type": "blob",
          "size": 1.3974609375,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestRuleIfCond(t *testing.T) {\n\ttests := []struct {\n\t\tcond  string\n\t\tvalid bool\n\t}{\n\t\t{\"\", true},\n\t\t{\"true\", true},\n\t\t{\"true || false\", true},\n\t\t{\"${{ false }}\", true},\n\t\t{\"${{ false }}\\n\", false},\n\t\t{\"${{ false }} \", false},\n\t\t{\" ${{ false }}\", false},\n\t\t{\"${{ true }} && ${{ true }}\", false},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"%q at step\", tc.cond), func(t *testing.T) {\n\t\t\tvar s Step\n\t\t\tif len(tc.cond) > 0 {\n\t\t\t\ts.If = &String{Value: tc.cond, Pos: &Pos{}}\n\t\t\t}\n\n\t\t\tr := NewRuleIfCond()\n\t\t\tif err := r.VisitStep(&s); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terrs := r.Errs()\n\t\t\tif tc.valid && len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"wanted no error but have %q for condition %q\", errs, tc.cond)\n\t\t\t}\n\t\t\tif !tc.valid && len(errs) != 1 {\n\t\t\t\tt.Fatalf(\"wanted one error but have %q for condition %q\", errs, tc.cond)\n\t\t\t}\n\t\t})\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"%q at job\", tc.cond), func(t *testing.T) {\n\t\t\tvar j Job\n\t\t\tif len(tc.cond) > 0 {\n\t\t\t\tj.If = &String{Value: tc.cond, Pos: &Pos{}}\n\t\t\t}\n\n\t\t\tr := NewRuleIfCond()\n\t\t\tif err := r.VisitJobPre(&j); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terrs := r.Errs()\n\t\t\tif tc.valid && len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"wanted no error but have %q for condition %q\", errs, tc.cond)\n\t\t\t}\n\t\t\tif !tc.valid && len(errs) != 1 {\n\t\t\t\tt.Fatalf(\"wanted one error but have %q for condition %q\", errs, tc.cond)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "rule_job_needs.go",
          "type": "blob",
          "size": 4.283203125,
          "content": "package actionlint\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype nodeStatus int\n\nconst (\n\tnodeStatusNew nodeStatus = iota\n\tnodeStatusActive\n\tnodeStatusFinished\n)\n\ntype jobNode struct {\n\tid       string\n\tneeds    []string\n\tresolved []*jobNode\n\tstatus   nodeStatus\n\tpos      *Pos\n}\n\ntype edge struct {\n\tfrom *jobNode\n\tto   *jobNode\n}\n\n// RuleJobNeeds is a rule to check 'needs' field in each job configuration. For more details, see\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#jobsjob_idneeds\ntype RuleJobNeeds struct {\n\tRuleBase\n\tnodes map[string]*jobNode\n}\n\n// NewRuleJobNeeds creates new RuleJobNeeds instance.\nfunc NewRuleJobNeeds() *RuleJobNeeds {\n\treturn &RuleJobNeeds{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"job-needs\",\n\t\t\tdesc: \"Checks for job IDs in \\\"needs:\\\". Undefined IDs and cyclic dependencies are checked\",\n\t\t},\n\t\tnodes: map[string]*jobNode{},\n\t}\n}\n\nfunc contains[T comparable](heystack []T, needle T) bool {\n\tfor _, s := range heystack {\n\t\tif s == needle {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleJobNeeds) VisitJobPre(n *Job) error {\n\tneeds := make([]string, 0, len(n.Needs))\n\tfor _, j := range n.Needs {\n\t\tid := strings.ToLower(j.Value)\n\t\tif contains(needs, id) {\n\t\t\trule.Errorf(j.Pos, \"job ID %q duplicates in \\\"needs\\\" section. note that job ID is case insensitive\", j.Value)\n\t\t\tcontinue\n\t\t}\n\t\tif id != \"\" {\n\t\t\t// Job ID is key of mapping. Key mapping is stored in lowercase since it is case\n\t\t\t// insensitive. So values in 'needs' array must be compared in lowercase.\n\t\t\tneeds = append(needs, id)\n\t\t}\n\t}\n\n\tid := strings.ToLower(n.ID.Value)\n\tif id == \"\" {\n\t\treturn nil\n\t}\n\tif prev, ok := rule.nodes[id]; ok {\n\t\trule.Errorf(n.Pos, \"job ID %q duplicates. previously defined at %s. note that job ID is case insensitive\", n.ID.Value, prev.pos.String())\n\t}\n\n\trule.nodes[id] = &jobNode{\n\t\tid:     id,\n\t\tneeds:  needs,\n\t\tstatus: nodeStatusNew,\n\t\tpos:    n.ID.Pos,\n\t}\n\n\treturn nil\n}\n\n// VisitWorkflowPost is callback when visiting Workflow node after visiting its children.\nfunc (rule *RuleJobNeeds) VisitWorkflowPost(n *Workflow) error {\n\t// Resolve nodes\n\tvalid := true\n\tfor id, node := range rule.nodes {\n\t\tnode.resolved = make([]*jobNode, 0, len(node.needs))\n\t\tfor _, dep := range node.needs {\n\t\t\tn, ok := rule.nodes[dep]\n\t\t\tif !ok {\n\t\t\t\trule.Errorf(node.pos, \"job %q needs job %q which does not exist in this workflow\", id, dep)\n\t\t\t\tvalid = false\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tnode.resolved = append(node.resolved, n)\n\t\t}\n\t}\n\tif !valid {\n\t\treturn nil\n\t}\n\n\t// Note: Only the first cycle can be detected even if there are multiple cycles in \"needs:\" configurations.\n\tif edge := detectFirstCycle(rule.nodes); edge != nil {\n\t\tedges := map[*jobNode]*jobNode{}\n\t\tedges[edge.from] = edge.to\n\t\tcollectCycle(edge.to, edges)\n\n\t\t// Start cycle from the smallest position to make the error message deterministic\n\t\tstart := edge.from\n\t\tfor n := range edges {\n\t\t\tif n.pos.IsBefore(start.pos) {\n\t\t\t\tstart = n\n\t\t\t}\n\t\t}\n\n\t\tvar msg strings.Builder\n\t\tmsg.WriteString(\"cyclic dependencies in \\\"needs\\\" job configurations are detected. detected cycle is \")\n\n\t\tmsg.WriteString(strconv.Quote(start.id))\n\t\tfrom, to := start, edges[start]\n\t\tfor {\n\t\t\tmsg.WriteString(\" -> \")\n\t\t\tmsg.WriteString(strconv.Quote(to.id))\n\t\t\tfrom, to = to, edges[to]\n\t\t\tif from == start {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\trule.Error(start.pos, msg.String())\n\t}\n\n\treturn nil\n}\n\nfunc collectCycle(src *jobNode, edges map[*jobNode]*jobNode) bool {\n\tfor _, dest := range src.resolved {\n\t\tif dest.status != nodeStatusActive {\n\t\t\tcontinue\n\t\t}\n\t\tedges[src] = dest\n\t\tif _, ok := edges[dest]; ok {\n\t\t\treturn true\n\t\t}\n\t\tif collectCycle(dest, edges) {\n\t\t\treturn true\n\t\t}\n\t\tdelete(edges, src)\n\t}\n\treturn false\n}\n\n// Detect cyclic dependencies\n// https://inzkyk.xyz/algorithms/depth_first_search/detecting_cycles/\n\nfunc detectFirstCycle(nodes map[string]*jobNode) *edge {\n\tfor _, v := range nodes {\n\t\tif v.status == nodeStatusNew {\n\t\t\tif e := detectCyclicNode(v); e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc detectCyclicNode(v *jobNode) *edge {\n\tv.status = nodeStatusActive\n\tfor _, w := range v.resolved {\n\t\tswitch w.status {\n\t\tcase nodeStatusActive:\n\t\t\treturn &edge{v, w}\n\t\tcase nodeStatusNew:\n\t\t\tif e := detectCyclicNode(w); e != nil {\n\t\t\t\treturn e\n\t\t\t}\n\t\t}\n\t}\n\tv.status = nodeStatusFinished\n\treturn nil\n}\n"
        },
        {
          "name": "rule_matrix.go",
          "type": "blob",
          "size": 4.873046875,
          "content": "package actionlint\n\nimport \"strings\"\n\n// RuleMatrix is a rule checker to check 'matrix' field of job.\ntype RuleMatrix struct {\n\tRuleBase\n}\n\n// NewRuleMatrix creates new RuleMatrix instance.\nfunc NewRuleMatrix() *RuleMatrix {\n\treturn &RuleMatrix{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"matrix\",\n\t\t\tdesc: \"Checks for matrix combinations in \\\"matrix:\\\"\",\n\t\t},\n\t}\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleMatrix) VisitJobPre(n *Job) error {\n\tif n.Strategy == nil || n.Strategy.Matrix == nil || n.Strategy.Matrix.Expression != nil {\n\t\treturn nil\n\t}\n\n\tm := n.Strategy.Matrix\n\n\tfor _, row := range m.Rows {\n\t\trule.checkDuplicateInRow(row)\n\t}\n\n\t// Note:\n\t// Any new value can be set in the section as new combination. It can add new value to existing\n\t// column also.\n\t//\n\t// matrix:\n\t//   os: [ubuntu-latest, macos-latest]\n\t//   include:\n\t//     - os: windows-latest\n\t//       sh: pwsh\n\n\trule.checkExclude(m)\n\treturn nil\n}\n\nfunc (rule *RuleMatrix) checkDuplicateInRow(row *MatrixRow) {\n\tif row.Values == nil {\n\t\treturn // Give up when ${{ }} is specified\n\t}\n\tseen := make([]RawYAMLValue, 0, len(row.Values))\n\tfor _, v := range row.Values {\n\t\tok := true\n\t\tfor _, p := range seen {\n\t\t\tif p.Equals(v) {\n\t\t\t\trule.Errorf(\n\t\t\t\t\tv.Pos(),\n\t\t\t\t\t\"duplicate value %s is found in matrix %q. the same value is at %s\",\n\t\t\t\t\tv.String(),\n\t\t\t\t\trow.Name.Value,\n\t\t\t\t\tp.Pos().String(),\n\t\t\t\t)\n\t\t\t\tok = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif ok {\n\t\t\tseen = append(seen, v)\n\t\t}\n\t}\n}\n\nfunc isYAMLValueSubset(v, sub RawYAMLValue) bool {\n\t// When the filter side is dynamically constructed with some expression, it is not possible to statically check if the filter\n\t// matches the value. To avoid false positives, assume such filter always matches to the value. (#414)\n\t// ```\n\t// matrix:\n\t//   foo: ['a', 'b']\n\t//   exclude:\n\t//     foo: ${{ fromJSON('...') }}\n\t// ```\n\tif s, ok := sub.(*RawYAMLString); ok && ContainsExpression(s.Value) {\n\t\treturn true\n\t}\n\n\tswitch v := v.(type) {\n\tcase *RawYAMLObject:\n\t\t// `exclude` filter can match to objects in matrix as subset of them (#249).\n\t\t// For example,\n\t\t//\n\t\t// matrix:\n\t\t//   os:\n\t\t//     - { name: Ubuntu, matrix: ubuntu }\n\t\t//     - { name: Windows, matrix: windows }\n\t\t//   arch:\n\t\t//     - { name: ARM, matrix: arm }\n\t\t//     - { name: Intel, matrix: intel }\n\t\t//   exclude:\n\t\t//     - os: { matrix: windows }\n\t\t//       arch: { matrix: arm }\n\t\t//\n\t\t// The `exclude` filters out `{ os: { name: Windows, matrix: windows }, arch: {name: ARM, matrix: arm } }`\n\t\tsub, ok := sub.(*RawYAMLObject)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tfor n, s := range sub.Props {\n\t\t\tif p, ok := v.Props[n]; !ok || !isYAMLValueSubset(p, s) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase *RawYAMLArray:\n\t\tsub, ok := sub.(*RawYAMLArray)\n\t\tif !ok {\n\t\t\treturn false\n\t\t}\n\t\tif len(v.Elems) != len(sub.Elems) {\n\t\t\treturn false\n\t\t}\n\t\tfor i, v := range v.Elems {\n\t\t\tif !isYAMLValueSubset(v, sub.Elems[i]) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase *RawYAMLString:\n\t\t// When some item is constructed with ${{ }} dynamically, give up checking combinations (#261)\n\t\tif ContainsExpression(v.Value) {\n\t\t\treturn true\n\t\t}\n\t\treturn v.Equals(sub)\n\tdefault:\n\t\treturn v.Equals(sub)\n\t}\n}\n\nfunc (rule *RuleMatrix) checkExclude(m *Matrix) {\n\tif m.Exclude == nil || len(m.Exclude.Combinations) == 0 || (m.Include != nil && m.Include.ContainsExpression()) {\n\t\treturn\n\t}\n\n\tif len(m.Rows) == 0 && (m.Include == nil || len(m.Include.Combinations) == 0) {\n\t\trule.Error(m.Pos, \"\\\"exclude\\\" section exists but no matrix variation exists\")\n\t\treturn\n\t}\n\n\trows := make(map[string][]RawYAMLValue, len(m.Rows))\n\tignored := map[string]struct{}{}\n\n\tfor n, r := range m.Rows {\n\t\tif r.Expression != nil {\n\t\t\tignored[n] = struct{}{}\n\t\t\tcontinue\n\t\t}\n\t\trows[n] = r.Values\n\t}\n\n\tif m.Include != nil {\n\t\tfor _, c := range m.Include.Combinations {\n\t\tInclude:\n\t\t\tfor n, a := range c.Assigns {\n\t\t\t\tif _, ok := ignored[n]; ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\trow := rows[n]\n\t\t\t\tfor _, v := range row {\n\t\t\t\t\tif v.Equals(a.Value) {\n\t\t\t\t\t\tcontinue Include\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trows[n] = append(row, a.Value)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor _, c := range m.Exclude.Combinations {\n\tExclude:\n\t\tfor k, a := range c.Assigns {\n\t\t\tif _, ok := ignored[k]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trow, ok := rows[k]\n\t\t\tif !ok {\n\t\t\t\tss := make([]string, 0, len(rows))\n\t\t\t\tfor k := range rows {\n\t\t\t\t\tss = append(ss, k)\n\t\t\t\t}\n\t\t\t\trule.Errorf(\n\t\t\t\t\ta.Key.Pos,\n\t\t\t\t\t\"%q in \\\"exclude\\\" section does not exist in matrix. available matrix configurations are %s\",\n\t\t\t\t\tk,\n\t\t\t\t\tsortedQuotes(ss),\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tfor _, v := range row {\n\t\t\t\tif isYAMLValueSubset(v, a.Value) {\n\t\t\t\t\tcontinue Exclude\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tss := make([]string, 0, len(row))\n\t\t\tfor _, v := range row {\n\t\t\t\tss = append(ss, v.String())\n\t\t\t}\n\t\t\trule.Errorf(\n\t\t\t\ta.Value.Pos(),\n\t\t\t\t\"value %s in \\\"exclude\\\" does not match in matrix %q combinations. possible values are %s\",\n\t\t\t\ta.Value.String(),\n\t\t\t\tk,\n\t\t\t\tstrings.Join(ss, \", \"), // Note: do not use quotesBuilder\n\t\t\t)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "rule_permissions.go",
          "type": "blob",
          "size": 2.34375,
          "content": "package actionlint\n\nvar allPermissionScopes = map[string]struct{}{\n\t\"actions\":             {},\n\t\"attestations\":        {},\n\t\"checks\":              {},\n\t\"contents\":            {},\n\t\"deployments\":         {},\n\t\"id-token\":            {},\n\t\"issues\":              {},\n\t\"discussions\":         {},\n\t\"packages\":            {},\n\t\"pages\":               {},\n\t\"pull-requests\":       {},\n\t\"repository-projects\": {},\n\t\"security-events\":     {},\n\t\"statuses\":            {},\n}\n\n// RulePermissions is a rule checker to check permission configurations in a workflow.\n// https://docs.github.com/en/actions/security-for-github-actions/security-guides/automatic-token-authentication#permissions-for-the-github_token\ntype RulePermissions struct {\n\tRuleBase\n}\n\n// NewRulePermissions creates new RulePermissions instance.\nfunc NewRulePermissions() *RulePermissions {\n\treturn &RulePermissions{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"permissions\",\n\t\t\tdesc: \"Checks for permissions configuration in \\\"permissions:\\\". Permission names and permission scopes are checked\",\n\t\t},\n\t}\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RulePermissions) VisitJobPre(n *Job) error {\n\trule.checkPermissions(n.Permissions)\n\treturn nil\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RulePermissions) VisitWorkflowPre(n *Workflow) error {\n\trule.checkPermissions(n.Permissions)\n\treturn nil\n}\n\nfunc (rule *RulePermissions) checkPermissions(p *Permissions) {\n\tif p == nil {\n\t\treturn\n\t}\n\n\tif p.All != nil {\n\t\tswitch p.All.Value {\n\t\tcase \"write-all\", \"read-all\":\n\t\t\t// OK\n\t\tdefault:\n\t\t\trule.Errorf(p.All.Pos, \"%q is invalid for permission for all the scopes. available values are \\\"read-all\\\" and \\\"write-all\\\"\", p.All.Value)\n\t\t}\n\t\treturn\n\t}\n\n\tfor _, p := range p.Scopes {\n\t\tn := p.Name.Value // Permission names are case-sensitive\n\t\tif _, ok := allPermissionScopes[n]; !ok {\n\t\t\tss := make([]string, 0, len(allPermissionScopes))\n\t\t\tfor s := range allPermissionScopes {\n\t\t\t\tss = append(ss, s)\n\t\t\t}\n\t\t\trule.Errorf(p.Name.Pos, \"unknown permission scope %q. all available permission scopes are %s\", n, sortedQuotes(ss))\n\t\t}\n\t\tswitch p.Value.Value {\n\t\tcase \"read\", \"write\", \"none\":\n\t\t\t// OK\n\t\tdefault:\n\t\t\trule.Errorf(p.Value.Pos, \"%q is invalid for permission of scope %q. available values are \\\"read\\\", \\\"write\\\" or \\\"none\\\"\", p.Value.Value, n)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "rule_pyflakes.go",
          "type": "blob",
          "size": 4.9375,
          "content": "package actionlint\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n)\n\ntype shellIsPythonKind int\n\nconst (\n\tshellIsPythonKindUnspecified shellIsPythonKind = iota\n\tshellIsPythonKindPython\n\tshellIsPythonKindNotPython\n)\n\nfunc getShellIsPythonKind(shell *String) shellIsPythonKind {\n\tif shell == nil {\n\t\treturn shellIsPythonKindUnspecified\n\t}\n\tif shell.Value == \"python\" || strings.HasPrefix(shell.Value, \"python \") {\n\t\treturn shellIsPythonKindPython\n\t}\n\treturn shellIsPythonKindNotPython\n}\n\n// RulePyflakes is a rule to check Python scripts at 'run:' using pyflakes.\n// https://github.com/PyCQA/pyflakes\ntype RulePyflakes struct {\n\tRuleBase\n\tcmd                   *externalCommand\n\tworkflowShellIsPython shellIsPythonKind\n\tjobShellIsPython      shellIsPythonKind\n\tmu                    sync.Mutex\n}\n\nfunc newRulePyflakes(cmd *externalCommand) *RulePyflakes {\n\treturn &RulePyflakes{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"pyflakes\",\n\t\t\tdesc: \"Checks for Python script when \\\"shell: python\\\" is configured using Pyflakes\",\n\t\t},\n\t\tcmd:                   cmd,\n\t\tworkflowShellIsPython: shellIsPythonKindUnspecified,\n\t\tjobShellIsPython:      shellIsPythonKindUnspecified,\n\t}\n}\n\n// NewRulePyflakes creates new RulePyflakes instance. Parameter executable can be command name\n// or relative/absolute file path. When the given executable is not found in system, it returns\n// an error.\nfunc NewRulePyflakes(executable string, proc *concurrentProcess) (*RulePyflakes, error) {\n\t// Combine output because pyflakes outputs lint errors to stdout and outputs syntax errors to stderr. (#411)\n\tcmd, err := proc.newCommandRunner(executable, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newRulePyflakes(cmd), nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RulePyflakes) VisitJobPre(n *Job) error {\n\tif n.Defaults != nil && n.Defaults.Run != nil {\n\t\trule.jobShellIsPython = getShellIsPythonKind(n.Defaults.Run.Shell)\n\t}\n\treturn nil\n}\n\n// VisitJobPost is callback when visiting Job node after visiting its children.\nfunc (rule *RulePyflakes) VisitJobPost(n *Job) error {\n\trule.jobShellIsPython = shellIsPythonKindUnspecified // reset\n\treturn nil\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RulePyflakes) VisitWorkflowPre(n *Workflow) error {\n\tif n.Defaults != nil && n.Defaults.Run != nil {\n\t\trule.workflowShellIsPython = getShellIsPythonKind(n.Defaults.Run.Shell)\n\t}\n\treturn nil\n}\n\n// VisitWorkflowPost is callback when visiting Workflow node after visiting its children.\nfunc (rule *RulePyflakes) VisitWorkflowPost(n *Workflow) error {\n\trule.workflowShellIsPython = shellIsPythonKindUnspecified // reset\n\treturn rule.cmd.wait()                                    // Wait until all processes running for this rule\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RulePyflakes) VisitStep(n *Step) error {\n\trun, ok := n.Exec.(*ExecRun)\n\tif !ok || run.Run == nil {\n\t\treturn nil\n\t}\n\n\tif !rule.isPythonShell(run) {\n\t\treturn nil\n\t}\n\n\trule.runPyflakes(run.Run.Value, run.RunPos)\n\treturn nil\n}\n\nfunc (rule *RulePyflakes) isPythonShell(r *ExecRun) bool {\n\tif k := getShellIsPythonKind(r.Shell); k != shellIsPythonKindUnspecified {\n\t\treturn k == shellIsPythonKindPython\n\t}\n\n\tif rule.jobShellIsPython != shellIsPythonKindUnspecified {\n\t\treturn rule.jobShellIsPython == shellIsPythonKindPython\n\t}\n\n\treturn rule.workflowShellIsPython == shellIsPythonKindPython\n}\n\nfunc (rule *RulePyflakes) runPyflakes(src string, pos *Pos) {\n\tsrc = sanitizeExpressionsInScript(src) // Defined at rule_shellcheck.go\n\trule.Debug(\"%s: Running %s for Python script:\\n%s\", pos, rule.cmd.exe, src)\n\n\trule.cmd.run([]string{}, src, func(stdout []byte, err error) error {\n\t\tif err != nil {\n\t\t\trule.Debug(\"Command %s failed: %v\", rule.cmd.exe, err)\n\t\t\treturn fmt.Errorf(\"`%s` did not run successfully while checking script at %s: %w\", rule.cmd.exe, pos, err)\n\t\t}\n\t\tif len(stdout) == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\tfor len(stdout) > 0 {\n\t\t\tif stdout, err = rule.parseNextError(stdout, pos); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (rule *RulePyflakes) parseNextError(stdout []byte, pos *Pos) ([]byte, error) {\n\tb := stdout\n\n\t// Search the start of error message.\n\tidx := bytes.Index(b, []byte(\"<stdin>:\"))\n\tif idx == -1 {\n\t\t// Syntax errors from pyflake consist of multiple lines. Skip subsequent lines. (#411)\n\t\t// ```\n\t\t// <stdin>:1:7: unexpected EOF while parsing\n\t\t// print(\n\t\t//       ^\n\t\t// ```\n\t\treturn nil, nil\n\t}\n\tb = b[idx+len(\"<stdin>:\"):]\n\n\tidx = bytes.IndexByte(b, '\\n')\n\tif idx == -1 {\n\t\treturn nil, fmt.Errorf(`error message from pyflakes does not end with \\n nor \\r\\n while checking script at %s. output: %q`, pos, stdout)\n\t}\n\n\tmsg := b[:idx]\n\tif i := len(msg) - 1; i >= 0 && msg[i] == '\\r' {\n\t\tmsg = msg[:i]\n\t}\n\tb = b[idx+1:]\n\n\t// This method needs to be thread-safe since concurrentProcess.run calls its callback in a different goroutine.\n\trule.mu.Lock()\n\trule.Errorf(pos, \"pyflakes reported issue in this script: %s\", msg)\n\trule.mu.Unlock()\n\n\treturn b, nil\n}\n"
        },
        {
          "name": "rule_pyflakes_test.go",
          "type": "blob",
          "size": 4.8779296875,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRulePyflakesDetectPythonShell(t *testing.T) {\n\ttests := []struct {\n\t\twhat     string\n\t\tisPython bool\n\t\tworkflow string // Shell name set at 'defaults' in Workflow node\n\t\tjob      string // Shell name set at 'defaults' in Job node\n\t\tstep     string // Shell name set at 'shell' in Step node\n\t}{\n\t\t{\n\t\t\twhat:     \"no default shell\",\n\t\t\tisPython: false,\n\t\t},\n\t\t{\n\t\t\twhat:     \"workflow default\",\n\t\t\tisPython: true,\n\t\t\tworkflow: \"python\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"job default\",\n\t\t\tisPython: true,\n\t\t\tjob:      \"python\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"step shell\",\n\t\t\tisPython: true,\n\t\t\tstep:     \"python\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"custom shell\",\n\t\t\tisPython: true,\n\t\t\tworkflow: \"python {0}\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"other shell\",\n\t\t\tisPython: false,\n\t\t\tworkflow: \"pwsh\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"other custom shell\",\n\t\t\tisPython: false,\n\t\t\tworkflow: \"bash -e {0}\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tr := newRulePyflakes(&externalCommand{})\n\n\t\t\tw := &Workflow{}\n\t\t\tif tc.workflow != \"\" {\n\t\t\t\tw.Defaults = &Defaults{\n\t\t\t\t\tRun: &DefaultsRun{\n\t\t\t\t\t\tShell: &String{Value: tc.workflow},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.VisitWorkflowPre(w)\n\n\t\t\tj := &Job{}\n\t\t\tif tc.job != \"\" {\n\t\t\t\tj.Defaults = &Defaults{\n\t\t\t\t\tRun: &DefaultsRun{\n\t\t\t\t\t\tShell: &String{Value: tc.job},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.VisitJobPre(j)\n\n\t\t\te := &ExecRun{}\n\t\t\tif tc.step != \"\" {\n\t\t\t\te.Shell = &String{Value: tc.step}\n\t\t\t}\n\t\t\tif have := r.isPythonShell(e); have != tc.isPython {\n\t\t\t\tt.Fatalf(\"Actual isPython=%v but wanted isPython=%v\", have, tc.isPython)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRulePyflakesParsePyflakesOutputOK(t *testing.T) {\n\ttests := []struct {\n\t\twhat  string\n\t\tinput string\n\t\twant  []string\n\t}{\n\t\t{\n\t\t\twhat:  \"no error\",\n\t\t\tinput: \"\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"ignore unrelated lines\",\n\t\t\tinput: \"this line\\nshould be\\nignored\\n\",\n\t\t},\n\t\t{\n\t\t\twhat:  \"single error\",\n\t\t\tinput: \"<stdin>:1:7: undefined name 'foo'\\n\",\n\t\t\twant: []string{\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"multiple errors\",\n\t\t\tinput: \"<stdin>:1:7: undefined name 'foo'\\n\" +\n\t\t\t\t\"<stdin>:1:7: undefined name 'foo'\\n\" +\n\t\t\t\t\"<stdin>:1:7: undefined name 'foo'\\n\",\n\t\t\twant: []string{\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"syntax error\",\n\t\t\tinput: \"<stdin>:1:7: unexpected EOF while parsing\\n\" +\n\t\t\t\t\"print(\\n\" +\n\t\t\t\t\"      ^\\n\",\n\t\t\twant: []string{\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: unexpected EOF while parsing [pyflakes]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"ignore unrelated lines between multiple errors\",\n\t\t\tinput: \"this line should be ignored\\n\" +\n\t\t\t\t\"this line should be ignored\\n\" +\n\t\t\t\t\"<stdin>:1:7: undefined name 'foo'\\n\" +\n\t\t\t\t\"this line should be ignored\\n\" +\n\t\t\t\t\"this line should be ignored\\n\" +\n\t\t\t\t\"<stdin>:1:7: undefined name 'foo'\\n\" +\n\t\t\t\t\"this line should be ignored\\n\" +\n\t\t\t\t\"this line should be ignored\\n\",\n\t\t\twant: []string{\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"CRLF\",\n\t\t\tinput: \"<stdin>:1:7: undefined name 'foo'\\r\\n\" +\n\t\t\t\t\"<stdin>:1:7: undefined name 'foo'\\r\\n\",\n\t\t\twant: []string{\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t\t\":1:2: pyflakes reported issue in this script: 1:7: undefined name 'foo' [pyflakes]\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tr := newRulePyflakes(&externalCommand{})\n\t\t\tstdout := []byte(tc.input)\n\t\t\tpos := &Pos{Line: 1, Col: 2}\n\t\t\tfor len(stdout) > 0 {\n\t\t\t\to, err := r.parseNextError(stdout, pos)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Parse error %q while reading input %q\", err, stdout)\n\t\t\t\t}\n\t\t\t\tstdout = o\n\t\t\t}\n\t\t\thave := r.Errs()\n\t\t\tif len(have) != len(tc.want) {\n\t\t\t\tmsgs := []string{}\n\t\t\t\tfor _, e := range have {\n\t\t\t\t\tmsgs = append(msgs, e.Error())\n\t\t\t\t}\n\t\t\t\tt.Fatalf(\"%d errors were expected but got %d errors. got errors are:\\n%#v\", len(tc.want), len(have), msgs)\n\t\t\t}\n\n\t\t\tfor i, want := range tc.want {\n\t\t\t\thave := have[i]\n\t\t\t\tmsg := have.Error()\n\t\t\t\tif !strings.Contains(msg, want) {\n\t\t\t\t\tt.Errorf(\"Error %q does not contain expected message %q\", msg, want)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRulePyflakesParsePyflakesOutputError(t *testing.T) {\n\tr := newRulePyflakes(&externalCommand{})\n\t_, err := r.parseNextError([]byte(\"<stdin>:1:7: undefined name 'foo'\"), &Pos{})\n\tif err == nil {\n\t\tt.Fatal(\"Error did not happen\")\n\t}\n\thave := err.Error()\n\twant := `error message from pyflakes does not end with \\n nor \\r\\n`\n\tif !strings.Contains(have, want) {\n\t\tt.Fatalf(\"Error %q does not contain expected message %q\", have, want)\n\t}\n}\n"
        },
        {
          "name": "rule_runner_label.go",
          "type": "blob",
          "size": 8.775390625,
          "content": "package actionlint\n\nimport (\n\t\"path\"\n\t\"strings\"\n)\n\ntype runnerOSCompat uint\n\nconst (\n\tcompatInvalid                   = 0\n\tcompatUbuntu2004 runnerOSCompat = 1 << iota\n\tcompatUbuntu2204\n\tcompatUbuntu2404\n\tcompatMacOS130\n\tcompatMacOS130L\n\tcompatMacOS130XL\n\tcompatMacOS140\n\tcompatMacOS140L\n\tcompatMacOS140XL\n\tcompatMacOS150\n\tcompatMacOS150L\n\tcompatMacOS150XL\n\tcompatWindows2019\n\tcompatWindows2022\n\tcompatWindows2025\n)\n\n// https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners\nvar allGitHubHostedRunnerLabels = []string{\n\t\"windows-latest\",\n\t\"windows-latest-8-cores\",\n\t\"windows-2025\",\n\t\"windows-2022\",\n\t\"windows-2019\",\n\t\"ubuntu-latest\",\n\t\"ubuntu-latest-4-cores\",\n\t\"ubuntu-latest-8-cores\",\n\t\"ubuntu-latest-16-cores\",\n\t\"ubuntu-24.04\",\n\t\"ubuntu-22.04\",\n\t\"ubuntu-20.04\",\n\t\"macos-latest\",\n\t\"macos-latest-xl\",\n\t\"macos-latest-xlarge\",\n\t\"macos-latest-large\",\n\t\"macos-15-xlarge\",\n\t\"macos-15-large\",\n\t\"macos-15\",\n\t\"macos-14-xl\",\n\t\"macos-14-xlarge\",\n\t\"macos-14-large\",\n\t\"macos-14\",\n\t\"macos-13-xl\",\n\t\"macos-13-xlarge\",\n\t\"macos-13-large\",\n\t\"macos-13\",\n}\n\n// https://docs.github.com/en/actions/hosting-your-own-runners/using-self-hosted-runners-in-a-workflow#using-default-labels-to-route-jobs\nvar selfHostedRunnerPresetOSLabels = []string{\n\t\"linux\",\n\t\"macos\",\n\t\"windows\",\n}\n\n// https://docs.github.com/en/actions/hosting-your-own-runners/using-self-hosted-runners-in-a-workflow#using-default-labels-to-route-jobs\nvar selfHostedRunnerPresetOtherLabels = []string{\n\t\"self-hosted\",\n\t\"x64\",\n\t\"arm\",\n\t\"arm64\",\n}\n\nvar defaultRunnerOSCompats = map[string]runnerOSCompat{\n\t\"ubuntu-latest\":          compatUbuntu2204,\n\t\"ubuntu-latest-4-cores\":  compatUbuntu2204,\n\t\"ubuntu-latest-8-cores\":  compatUbuntu2204,\n\t\"ubuntu-latest-16-cores\": compatUbuntu2204,\n\t\"ubuntu-24.04\":           compatUbuntu2404,\n\t\"ubuntu-22.04\":           compatUbuntu2204,\n\t\"ubuntu-20.04\":           compatUbuntu2004,\n\t\"macos-latest-xl\":        compatMacOS140XL,\n\t\"macos-latest-xlarge\":    compatMacOS140XL,\n\t\"macos-latest-large\":     compatMacOS140L,\n\t\"macos-latest\":           compatMacOS140,\n\t\"macos-15-xlarge\":        compatMacOS150XL,\n\t\"macos-15-large\":         compatMacOS150L,\n\t\"macos-15\":               compatMacOS150,\n\t\"macos-14-xl\":            compatMacOS140XL,\n\t\"macos-14-xlarge\":        compatMacOS140XL,\n\t\"macos-14-large\":         compatMacOS140L,\n\t\"macos-14\":               compatMacOS140,\n\t\"macos-13-xl\":            compatMacOS130XL,\n\t\"macos-13-xlarge\":        compatMacOS130XL,\n\t\"macos-13-large\":         compatMacOS130L,\n\t\"macos-13\":               compatMacOS130,\n\t\"windows-latest\":         compatWindows2022,\n\t\"windows-latest-8-cores\": compatWindows2022,\n\t\"windows-2025\":           compatWindows2025,\n\t\"windows-2022\":           compatWindows2022,\n\t\"windows-2019\":           compatWindows2019,\n\t\"linux\":                  compatUbuntu2404 | compatUbuntu2204 | compatUbuntu2004, // Note: \"linux\" does not always indicate Ubuntu. It might be Fedora or Arch or ...\n\t\"macos\":                  compatMacOS150 | compatMacOS150L | compatMacOS150XL | compatMacOS140 | compatMacOS140L | compatMacOS140XL | compatMacOS130 | compatMacOS130L | compatMacOS130XL,\n\t\"windows\":                compatWindows2022 | compatWindows2019,\n}\n\n// RuleRunnerLabel is a rule to check runner label like \"ubuntu-latest\". There are two types of\n// runners, GitHub-hosted runner and Self-hosted runner. GitHub-hosted runner is described at\n// https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners .\n// And Self-hosted runner is described at\n// https://docs.github.com/en/actions/hosting-your-own-runners/using-self-hosted-runners-in-a-workflow .\ntype RuleRunnerLabel struct {\n\tRuleBase\n\t// Note: Using only one compatibility integer is enough to check compatibility. But we remember\n\t// all past compatibility values here for better error message. If accumulating all compatibility\n\t// values into one integer, we can no longer know what labels are conflicting.\n\tcompats map[runnerOSCompat]*String\n}\n\n// NewRuleRunnerLabel creates new RuleRunnerLabel instance.\nfunc NewRuleRunnerLabel() *RuleRunnerLabel {\n\treturn &RuleRunnerLabel{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"runner-label\",\n\t\t\tdesc: \"Checks for GitHub-hosted and preset self-hosted runner labels in \\\"runs-on:\\\"\",\n\t\t},\n\t\tcompats: nil,\n\t}\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleRunnerLabel) VisitJobPre(n *Job) error {\n\tif n.RunsOn == nil {\n\t\treturn nil\n\t}\n\n\tvar m *Matrix\n\tif n.Strategy != nil {\n\t\tm = n.Strategy.Matrix\n\t}\n\n\tif len(n.RunsOn.Labels) == 1 {\n\t\trule.checkLabel(n.RunsOn.Labels[0], m)\n\t\treturn nil\n\t}\n\n\trule.compats = map[runnerOSCompat]*String{}\n\tif n.RunsOn.LabelsExpr != nil {\n\t\trule.checkLabelAndConflict(n.RunsOn.LabelsExpr, m)\n\t} else {\n\t\tfor _, label := range n.RunsOn.Labels {\n\t\t\trule.checkLabelAndConflict(label, m)\n\t\t}\n\t}\n\n\trule.compats = nil // reset\n\treturn nil\n}\n\n// https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners\nfunc (rule *RuleRunnerLabel) checkLabelAndConflict(l *String, m *Matrix) {\n\tif l.ContainsExpression() {\n\t\tss := rule.tryToGetLabelsInMatrix(l, m)\n\t\tcs := make([]runnerOSCompat, 0, len(ss))\n\t\tfor _, s := range ss {\n\t\t\tcomp := rule.verifyRunnerLabel(s)\n\t\t\tcs = append(cs, comp)\n\t\t}\n\t\trule.checkCombiCompat(cs, ss)\n\t\treturn\n\t}\n\n\tcomp := rule.verifyRunnerLabel(l)\n\trule.checkCompat(comp, l)\n}\n\nfunc (rule *RuleRunnerLabel) checkLabel(l *String, m *Matrix) {\n\tif l.ContainsExpression() {\n\t\tss := rule.tryToGetLabelsInMatrix(l, m)\n\t\tfor _, s := range ss {\n\t\t\trule.verifyRunnerLabel(s)\n\t\t}\n\t\treturn\n\t}\n\n\trule.verifyRunnerLabel(l)\n}\n\nfunc (rule *RuleRunnerLabel) verifyRunnerLabel(label *String) runnerOSCompat {\n\tl := label.Value\n\tif c, ok := defaultRunnerOSCompats[strings.ToLower(l)]; ok {\n\t\treturn c\n\t}\n\n\tfor _, p := range selfHostedRunnerPresetOtherLabels {\n\t\tif strings.EqualFold(l, p) {\n\t\t\treturn compatInvalid\n\t\t}\n\t}\n\n\tknown := rule.getKnownLabels()\n\tfor _, k := range known {\n\t\tm, err := path.Match(k, l)\n\t\tif err != nil {\n\t\t\trule.Errorf(label.Pos, \"label pattern %q is an invalid glob. kindly check list of labels in actionlint.yaml config file: %v\", k, err)\n\t\t\treturn compatInvalid\n\t\t}\n\t\tif m {\n\t\t\treturn compatInvalid\n\t\t}\n\t}\n\n\trule.Errorf(\n\t\tlabel.Pos,\n\t\t\"label %q is unknown. available labels are %s. if it is a custom label for self-hosted runner, set list of labels in actionlint.yaml config file\",\n\t\tlabel.Value,\n\t\tquotesAll(\n\t\t\tallGitHubHostedRunnerLabels,\n\t\t\tselfHostedRunnerPresetOtherLabels,\n\t\t\tselfHostedRunnerPresetOSLabels,\n\t\t\tknown,\n\t\t),\n\t)\n\n\treturn compatInvalid\n}\n\nfunc (rule *RuleRunnerLabel) tryToGetLabelsInMatrix(label *String, m *Matrix) []*String {\n\tif m == nil {\n\t\treturn nil\n\t}\n\n\t// Only when the form of \"${{...}}\", evaluate the expression\n\tif !label.IsExpressionAssigned() {\n\t\treturn nil\n\t}\n\n\tl := strings.TrimSpace(label.Value)\n\tp := NewExprParser()\n\texpr, err := p.Parse(NewExprLexer(l[3:])) // 3 means omit first \"${{\"\n\tif err != nil {\n\t\treturn nil\n\t}\n\n\tderef, ok := expr.(*ObjectDerefNode)\n\tif !ok {\n\t\treturn nil\n\t}\n\trecv, ok := deref.Receiver.(*VariableNode)\n\tif !ok {\n\t\treturn nil\n\t}\n\tif recv.Name != \"matrix\" {\n\t\treturn nil\n\t}\n\n\tprop := deref.Property\n\tlabels := []*String{}\n\n\tif m.Rows != nil {\n\t\tif row, ok := m.Rows[prop]; ok {\n\t\t\tfor _, v := range row.Values {\n\t\t\t\tif s, ok := v.(*RawYAMLString); ok && !ContainsExpression(s.Value) {\n\t\t\t\t\tlabels = append(labels, &String{s.Value, false, s.Pos()})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif m.Include != nil {\n\t\tfor _, combi := range m.Include.Combinations {\n\t\t\tif combi.Assigns != nil {\n\t\t\t\tif assign, ok := combi.Assigns[prop]; ok {\n\t\t\t\t\tif s, ok := assign.Value.(*RawYAMLString); ok && !ContainsExpression(s.Value) {\n\t\t\t\t\t\tlabels = append(labels, &String{s.Value, false, s.Pos()})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn labels\n}\n\nfunc (rule *RuleRunnerLabel) checkConflict(comp runnerOSCompat, label *String) bool {\n\tfor c, l := range rule.compats {\n\t\tif c&comp == 0 {\n\t\t\trule.Errorf(label.Pos, \"label %q conflicts with label %q defined at %s. note: to run your job on each workers, use matrix\", label.Value, l.Value, l.Pos)\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc (rule *RuleRunnerLabel) checkCompat(comp runnerOSCompat, label *String) {\n\tif comp == compatInvalid || !rule.checkConflict(comp, label) {\n\t\treturn\n\t}\n\tif _, ok := rule.compats[comp]; !ok {\n\t\trule.compats[comp] = label\n\t}\n}\n\nfunc (rule *RuleRunnerLabel) checkCombiCompat(comps []runnerOSCompat, labels []*String) {\n\tfor i, c := range comps {\n\t\tif c != compatInvalid && !rule.checkConflict(c, labels[i]) {\n\t\t\t// Overwrite the compatibility value with compatInvalid at conflicted label not to\n\t\t\t// register the label to `rule.compats`.\n\t\t\tcomps[i] = compatInvalid\n\t\t}\n\t}\n\tfor i, c := range comps {\n\t\tif c != compatInvalid {\n\t\t\tif _, ok := rule.compats[c]; !ok {\n\t\t\t\trule.compats[c] = labels[i]\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (rule *RuleRunnerLabel) getKnownLabels() []string {\n\tif rule.config == nil {\n\t\treturn nil\n\t}\n\treturn rule.config.SelfHostedRunner.Labels\n}\n"
        },
        {
          "name": "rule_runner_label_test.go",
          "type": "blob",
          "size": 9.75,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n\t\"testing\"\n)\n\nfunc TestRuleRunnerLabelCheckLabels(t *testing.T) {\n\ttestCases := []struct {\n\t\twhat   string\n\t\tlabels []string\n\t\tmatrix []string\n\t\tknown  []string\n\t\terrs   []string\n\t}{\n\t\t// Normal cases\n\t\t{\n\t\t\twhat:   \"simple GH-hosted Linux runner label\",\n\t\t\tlabels: []string{\"ubuntu-20.04\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"simple GH-hosted Windows runner label\",\n\t\t\tlabels: []string{\"windows-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"simple GH-hosted macOS runner label\",\n\t\t\tlabels: []string{\"macos-14\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"simple GH-hosted runner label in upper case\",\n\t\t\tlabels: []string{\"macOS-14\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted Linux runner\",\n\t\t\tlabels: []string{\"self-hosted\", \"linux\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted all Linux runner labels\",\n\t\t\tlabels: []string{\"self-hosted\", \"linux\", \"ubuntu-22.04\", \"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted all macOS runner labels\",\n\t\t\tlabels: []string{\"self-hosted\", \"macOS\", \"macOS-latest\", \"macOS-14\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted Linux runner in upper case\",\n\t\t\tlabels: []string{\"SELF-HOSTED\", \"LINUX\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted macOS runner\",\n\t\t\tlabels: []string{\"self-hosted\", \"macos\", \"arm64\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted runner with GH-hosted runner label\",\n\t\t\tlabels: []string{\"self-hosted\", \"ubuntu-20.04\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"larger Ubuntu runner\",\n\t\t\tlabels: []string{\"ubuntu-latest-16-cores\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"larger Ubuntu runner with other labels\",\n\t\t\tlabels: []string{\"ubuntu-latest\", \"ubuntu-latest-16-cores\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"larger Windows runner\",\n\t\t\tlabels: []string{\"windows-latest-8-cores\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"multiple labels for GH-hosted runner\",\n\t\t\tlabels: []string{\"ubuntu-latest\", \"ubuntu-22.04\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"user-defined labels\",\n\t\t\tlabels: []string{\"self-hosted\", \"foo\", \"bar\", \"linux\"},\n\t\t\tknown:  []string{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"user-defined labels with patterns\",\n\t\t\tlabels: []string{\"self-hosted\", \"INSTANCE_TYPE=m6a.large\", \"some-base-prefix:size=large&cpu=8\"},\n\t\t\tknown:  []string{\"INSTANCE_TYPE=*\", \"some-base-prefix:size=*&cpu=?\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"some character is escaped in user-defined label patterns\",\n\t\t\tlabels: []string{`linux-[arch]`},\n\t\t\tknown:  []string{`*-\\[*]`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"matrix\",\n\t\t\tlabels: []string{\"${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\", \"windows-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"matrix at second label\",\n\t\t\tlabels: []string{\"self-hosted\", \"${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"linux\", \"windows\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"matrix at first label\",\n\t\t\tlabels: []string{\"${{matrix.os}}\", \"ubuntu-22.04\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"user-defined label with matrix\",\n\t\t\tlabels: []string{\"self-hosted\", \"${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"foo\", \"bar\"},\n\t\t\tknown:  []string{\"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"cannot check label: prefix\",\n\t\t\tlabels: []string{\"foo-${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"cannot check label: siffux\",\n\t\t\tlabels: []string{\"${{matrix.os}}-bar\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"cannot check label: not a matrix\",\n\t\t\tlabels: []string{\"${{fromJSON(env.FOO).os}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"cannot check label: not a matrix 2\",\n\t\t\tlabels: []string{\"${{env.os}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"cannot check label: matrix object\",\n\t\t\tlabels: []string{\"${{matrix}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"cannot parse expression\",\n\t\t\tlabels: []string{\"${{}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"give up checking matrix value containing expression\",\n\t\t\tlabels: []string{\"${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"ubuntu-latest\", \"${{env.OS}}\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"use matrix value but no matrix exist\",\n\t\t\tlabels: []string{\"${{matrix.os}}\"},\n\t\t},\n\t\t{\n\t\t\twhat:   \"ubuntu-24.04\",\n\t\t\tlabels: []string{\"ubuntu-24.04\"},\n\t\t},\n\t\t// TODO: Add tests for 'include:'\n\t\t// TODO: Check matrix with 'include:'\n\n\t\t// Error cases\n\t\t{\n\t\t\twhat:   \"undefined label\",\n\t\t\tlabels: []string{\"linux-latest\"},\n\t\t\terrs:   []string{`\"linux-latest\" is unknown`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"undefined self-hosted label\",\n\t\t\tlabels: []string{\"self-hosted\", \"foo\"},\n\t\t\terrs:   []string{`\"foo\" is unknown`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted runner labels conflict\",\n\t\t\tlabels: []string{\"ubuntu-latest\", \"windows-latest\"},\n\t\t\terrs:   []string{`label \"windows-latest\" conflicts with label \"ubuntu-latest\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted runner labels conflict\",\n\t\t\tlabels: []string{\"self-hosted\", \"windows\", \"linux\"},\n\t\t\terrs:   []string{`label \"linux\" conflicts with label \"windows\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"self-hosted runner labels conflict with GH-hosted runner label\",\n\t\t\tlabels: []string{\"self-hosted\", \"windows\", \"macOS-latest\"},\n\t\t\terrs:   []string{`label \"macOS-latest\" conflicts with label \"windows\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted labels multiple conflicts\",\n\t\t\tlabels: []string{\"ubuntu-latest\", \"windows-latest\", \"macos-latest\"},\n\t\t\terrs: []string{\n\t\t\t\t`label \"windows-latest\" conflicts with label \"ubuntu-latest\"`,\n\t\t\t\t`label \"macos-latest\" conflicts with label \"ubuntu-latest\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted labels conflict mixed with self-hosted runner labels\",\n\t\t\tlabels: []string{\"self-hosted\", \"ubuntu-latest\", \"x64\", \"windows-latest\", \"foo\"},\n\t\t\tknown:  []string{\"foo\"},\n\t\t\terrs:   []string{`label \"windows-latest\" conflicts with label \"ubuntu-latest\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted labels conflict ignore case\",\n\t\t\tlabels: []string{\"macOS-latest\", \"Windows-latest\"},\n\t\t\terrs:   []string{`label \"Windows-latest\" conflicts with label \"macOS-latest\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted labels conflict with matrix at second label\",\n\t\t\tlabels: []string{\"ubuntu-latest\", \"${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"windows-latest\", \"macos-latest\"},\n\t\t\terrs: []string{\n\t\t\t\t`label \"windows-latest\" conflicts with label \"ubuntu-latest\"`,\n\t\t\t\t`label \"macos-latest\" conflicts with label \"ubuntu-latest\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted labels conflict with matrix at first label\",\n\t\t\tlabels: []string{\"${{matrix.os}}\", \"ubuntu-latest\"},\n\t\t\tmatrix: []string{\"windows-latest\", \"macos-latest\"},\n\t\t\terrs:   []string{`label \"ubuntu-latest\" conflicts with label`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"GH-hosted labels conflicts with multiple matrixes\",\n\t\t\tlabels: []string{\"${{matrix.os}}\", \"${{matrix.os}}\"},\n\t\t\tmatrix: []string{\"windows-latest\", \"macos-latest\"},\n\t\t\terrs: []string{\n\t\t\t\t`label \"windows-latest\" conflicts with label \"macos-latest\"`,\n\t\t\t\t`label \"macos-latest\" conflicts with label \"windows-latest\"`,\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:   \"Linux labels conflict\",\n\t\t\tlabels: []string{\"ubuntu-latest\", \"ubuntu-20.04\"},\n\t\t\terrs:   []string{`label \"ubuntu-20.04\" conflicts with label \"ubuntu-latest\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"macOS labels conflict\",\n\t\t\tlabels: []string{\"macos-13\", \"macos-14\"},\n\t\t\terrs:   []string{`label \"macos-14\" conflicts with label \"macos-13\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"macOS XL and normal labels conflict\",\n\t\t\tlabels: []string{\"macos-13-xl\", \"macos-13\"},\n\t\t\terrs:   []string{`label \"macos-13\" conflicts with label \"macos-13-xl\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"larger runner labels conflict\",\n\t\t\tlabels: []string{\"ubuntu-latest-16-cores\", \"windows-latest-8-cores\"},\n\t\t\terrs:   []string{`label \"windows-latest-8-cores\" conflicts with label \"ubuntu-latest-16-cores\"`},\n\t\t},\n\t\t{\n\t\t\twhat:   \"user-defined labels with invalid glob pattern\",\n\t\t\tlabels: []string{\"self-hosted\", \"INSTANCE_TYPE=m6a.large\"},\n\t\t\tknown:  []string{\"INSTANCE_TYPE=[\"},\n\t\t\terrs:   []string{`label pattern \"INSTANCE_TYPE=[\" is an invalid glob. kindly check list of labels in actionlint.yaml config file: syntax error in pattern`},\n\t\t},\n\t\t// TODO: Add error tests for 'include:'\n\t}\n\n\tfor _, tc := range testCases {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tpos := &Pos{}\n\t\t\tlabels := make([]*String, 0, len(tc.labels))\n\t\t\tfor _, l := range tc.labels {\n\t\t\t\tlabels = append(labels, &String{l, false, pos})\n\t\t\t}\n\t\t\tnode := &Job{\n\t\t\t\tRunsOn: &Runner{\n\t\t\t\t\tLabels: labels,\n\t\t\t\t},\n\t\t\t}\n\n\t\t\tif tc.matrix != nil {\n\t\t\t\tn := &String{\"os\", false, pos}\n\t\t\t\trow := make([]RawYAMLValue, 0, len(tc.matrix))\n\t\t\t\tfor _, m := range tc.matrix {\n\t\t\t\t\trow = append(row, &RawYAMLString{m, pos})\n\t\t\t\t}\n\t\t\t\tst := &Strategy{\n\t\t\t\t\tMatrix: &Matrix{\n\t\t\t\t\t\tRows: map[string]*MatrixRow{\n\t\t\t\t\t\t\t\"os\": {\n\t\t\t\t\t\t\t\tName:   n,\n\t\t\t\t\t\t\t\tValues: row,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t\tPos: pos,\n\t\t\t\t}\n\t\t\t\tnode.Strategy = st\n\t\t\t}\n\n\t\t\trule := NewRuleRunnerLabel()\n\t\t\tcfg := Config{}\n\t\t\tcfg.SelfHostedRunner.Labels = tc.known\n\t\t\trule.SetConfig(&cfg)\n\t\t\tif err := rule.VisitJobPre(node); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terrs := rule.Errs()\n\t\t\tif len(errs) != len(tc.errs) {\n\t\t\t\tt.Fatalf(\"%d error(s) are wanted but got %d error(s) actually: %v\", len(tc.errs), len(errs), errs)\n\t\t\t}\n\t\t\tfor i, want := range tc.errs {\n\t\t\t\thave := errs[i].Error()\n\t\t\t\tif !strings.Contains(have, want) {\n\t\t\t\t\tt.Fatalf(\"%q is not contained in error message of errs[%d]: %q\", want, i, have)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleRunnerLabelDoNothingOnNoRunsOn(t *testing.T) {\n\trule := NewRuleRunnerLabel()\n\tif err := rule.VisitJobPre(&Job{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif errs := rule.Errs(); len(errs) > 0 {\n\t\tt.Fatalf(\"%d error(s) occurred: %v\", len(errs), errs)\n\t}\n}\n\nfunc TestRuleRunnerLabelAllGitHubHostedRunnerLabels(t *testing.T) {\n\tall := []string{}\n\tall = append(all, allGitHubHostedRunnerLabels...)\n\tall = append(all, selfHostedRunnerPresetOSLabels...)\n\n\tif len(all) != len(defaultRunnerOSCompats) {\n\t\tt.Errorf(\"%d elements in allGitHubHostedRunnerLabels but %d elements in githubHostedRunnerCompats\", len(all), len(defaultRunnerOSCompats))\n\t}\n\tfor _, l := range all {\n\t\tif l != strings.ToLower(l) {\n\t\t\tt.Errorf(\"label %q in allGitHubHostedRunnerLabels is not in lower-case\", l)\n\t\t}\n\t\tif _, ok := defaultRunnerOSCompats[l]; !ok {\n\t\t\tt.Errorf(\"%q is included in allGitHubHostedRunnerLabels but not included in githubHostedRunnerCompats\", l)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "rule_shell_name.go",
          "type": "blob",
          "size": 4.0869140625,
          "content": "package actionlint\n\nimport (\n\t\"strings\"\n)\n\ntype platformKind int\n\nconst (\n\tplatformKindAny platformKind = iota\n\tplatformKindMacOrLinux\n\tplatformKindWindows\n)\n\n// RuleShellName is a rule to check 'shell' field. For more details, see\n// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#using-a-specific-shell\ntype RuleShellName struct {\n\tRuleBase\n\tplatform platformKind\n}\n\n// NewRuleShellName creates new RuleShellName instance.\nfunc NewRuleShellName() *RuleShellName {\n\treturn &RuleShellName{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"shell-name\",\n\t\t\tdesc: \"Checks for shell names used for scripts in \\\"run:\\\"\",\n\t\t},\n\t\tplatform: platformKindAny,\n\t}\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleShellName) VisitStep(n *Step) error {\n\tif run, ok := n.Exec.(*ExecRun); ok {\n\t\trule.checkShellName(run.Shell)\n\t}\n\treturn nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleShellName) VisitJobPre(n *Job) error {\n\tif n.RunsOn == nil {\n\t\treturn nil\n\t}\n\trule.platform = rule.getPlatformFromRunner(n.RunsOn)\n\tif n.Defaults != nil && n.Defaults.Run != nil {\n\t\trule.checkShellName(n.Defaults.Run.Shell)\n\t}\n\treturn nil\n}\n\n// VisitJobPost is callback when visiting Job node after visiting its children.\nfunc (rule *RuleShellName) VisitJobPost(n *Job) error {\n\trule.platform = platformKindAny // Clear\n\treturn nil\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleShellName) VisitWorkflowPre(n *Workflow) error {\n\tif n.Defaults != nil && n.Defaults.Run != nil {\n\t\trule.checkShellName(n.Defaults.Run.Shell)\n\t}\n\treturn nil\n}\n\nfunc (rule *RuleShellName) checkShellName(node *String) {\n\tif node == nil {\n\t\treturn\n\t}\n\n\t// Ignore custom shell\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#custom-shell\n\tif strings.Contains(node.Value, \"{0}\") {\n\t\treturn\n\t}\n\n\t// Ignore dynamic shell name\n\tif node.ContainsExpression() {\n\t\treturn\n\t}\n\n\tname := strings.ToLower(node.Value)\n\tavailable := getAvailableShellNames(rule.platform)\n\n\tfor _, s := range available {\n\t\tif name == s {\n\t\t\treturn // ok\n\t\t}\n\t}\n\n\tonPlatform := \"\"\n\tswitch rule.platform {\n\tcase platformKindWindows:\n\t\tfor _, p := range getAvailableShellNames(platformKindAny) {\n\t\t\tif name == p {\n\t\t\t\tonPlatform = \" on Windows\" // only when the shell is unavailable on Windows\n\t\t\t}\n\t\t}\n\tcase platformKindMacOrLinux:\n\t\tfor _, p := range getAvailableShellNames(platformKindAny) {\n\t\t\tif name == p {\n\t\t\t\tonPlatform = \" on macOS or Linux\" // only when the shell is unavailable on macOS or Linux\n\t\t\t}\n\t\t}\n\t}\n\n\trule.Errorf(\n\t\tnode.Pos,\n\t\t\"shell name %q is invalid%s. available names are %s\",\n\t\tnode.Value,\n\t\tonPlatform,\n\t\tsortedQuotes(available),\n\t)\n}\n\nfunc getAvailableShellNames(kind platformKind) []string {\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#using-a-specific-shell\n\tswitch kind {\n\tcase platformKindAny:\n\t\treturn []string{\n\t\t\t\"bash\",\n\t\t\t\"pwsh\",\n\t\t\t\"python\",\n\t\t\t\"sh\",\n\t\t\t\"cmd\",\n\t\t\t\"powershell\",\n\t\t}\n\tcase platformKindWindows:\n\t\treturn []string{\n\t\t\t\"bash\",\n\t\t\t\"pwsh\",\n\t\t\t\"python\",\n\t\t\t\"cmd\",\n\t\t\t\"powershell\",\n\t\t}\n\tcase platformKindMacOrLinux:\n\t\treturn []string{\n\t\t\t\"bash\",\n\t\t\t\"pwsh\",\n\t\t\t\"python\",\n\t\t\t\"sh\",\n\t\t}\n\tdefault:\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc (rule *RuleShellName) getPlatformFromRunner(runner *Runner) platformKind {\n\tif runner == nil {\n\t\treturn platformKindAny\n\t}\n\n\t// Note: Labels for self-hosted runners:\n\t// https://docs.github.com/en/actions/hosting-your-own-runners/using-labels-with-self-hosted-runners\n\n\tret := platformKindAny\n\tfor _, label := range runner.Labels {\n\t\tk := platformKindAny\n\t\tl := strings.ToLower(label.Value)\n\t\tif strings.HasPrefix(l, \"windows-\") || l == \"windows\" {\n\t\t\tk = platformKindWindows\n\t\t} else if strings.HasPrefix(l, \"macos-\") || strings.HasPrefix(l, \"ubuntu-\") || l == \"macos\" || l == \"linux\" {\n\t\t\tk = platformKindMacOrLinux\n\t\t}\n\n\t\tif k == platformKindAny {\n\t\t\tcontinue\n\t\t}\n\t\tif ret != platformKindAny && ret != k {\n\t\t\t// Conflicts are reported by runner-label rule so simply ignore here\n\t\t\treturn platformKindAny\n\t\t}\n\t\tret = k\n\t}\n\n\treturn ret\n}\n"
        },
        {
          "name": "rule_shellcheck.go",
          "type": "blob",
          "size": 7.697265625,
          "content": "package actionlint\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strings\"\n\t\"sync\"\n)\n\ntype shellcheckError struct {\n\tLine    int    `json:\"line\"`\n\tColumn  int    `json:\"column\"`\n\tLevel   string `json:\"level\"`\n\tCode    int    `json:\"code\"`\n\tMessage string `json:\"message\"`\n}\n\n// RuleShellcheck is a rule to check shell scripts at 'run:' using shellcheck.\n// https://github.com/koalaman/shellcheck\ntype RuleShellcheck struct {\n\tRuleBase\n\tcmd           *externalCommand\n\tworkflowShell string\n\tjobShell      string\n\trunnerShell   string\n\tmu            sync.Mutex\n}\n\nfunc newRuleShellcheck(cmd *externalCommand) *RuleShellcheck {\n\treturn &RuleShellcheck{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"shellcheck\",\n\t\t\tdesc: \"Checks for shell script sources in \\\"run:\\\" using shellcheck\",\n\t\t},\n\t\tcmd:           cmd,\n\t\tworkflowShell: \"\",\n\t\tjobShell:      \"\",\n\t\trunnerShell:   \"\",\n\t}\n}\n\n// NewRuleShellcheck creates new RuleShellcheck instance. The executable argument can be command\n// name or relative/absolute file path. When the given executable is not found in system, it returns\n// an error as 2nd return value.\nfunc NewRuleShellcheck(executable string, proc *concurrentProcess) (*RuleShellcheck, error) {\n\tcmd, err := proc.newCommandRunner(executable, false)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn newRuleShellcheck(cmd), nil\n}\n\n// VisitStep is callback when visiting Step node.\nfunc (rule *RuleShellcheck) VisitStep(n *Step) error {\n\trun, ok := n.Exec.(*ExecRun)\n\tif !ok || run.Run == nil {\n\t\treturn nil\n\t}\n\n\trule.runShellcheck(run.Run.Value, rule.getShellName(run), run.RunPos)\n\treturn nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleShellcheck) VisitJobPre(n *Job) error {\n\tif n.Defaults != nil && n.Defaults.Run != nil && n.Defaults.Run.Shell != nil {\n\t\trule.jobShell = n.Defaults.Run.Shell.Value\n\t}\n\n\tif n.RunsOn != nil {\n\t\tfor _, label := range n.RunsOn.Labels {\n\t\t\tl := strings.ToLower(label.Value)\n\t\t\t// Default shell on Windows is PowerShell.\n\t\t\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#using-a-specific-shell\n\t\t\tif l == \"windows\" || strings.HasPrefix(l, \"windows-\") {\n\t\t\t\trule.runnerShell = \"pwsh\"\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// VisitJobPost is callback when visiting Job node after visiting its children.\nfunc (rule *RuleShellcheck) VisitJobPost(n *Job) error {\n\trule.jobShell = \"\"\n\trule.runnerShell = \"\"\n\treturn nil\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleShellcheck) VisitWorkflowPre(n *Workflow) error {\n\tif n.Defaults != nil && n.Defaults.Run != nil && n.Defaults.Run.Shell != nil {\n\t\trule.workflowShell = n.Defaults.Run.Shell.Value\n\t}\n\treturn nil\n}\n\n// VisitWorkflowPost is callback when visiting Workflow node after visiting its children.\nfunc (rule *RuleShellcheck) VisitWorkflowPost(n *Workflow) error {\n\trule.workflowShell = \"\"\n\treturn rule.cmd.wait() // Wait until all processes running for this rule\n}\n\nfunc (rule *RuleShellcheck) getShellName(exec *ExecRun) string {\n\tif exec.Shell != nil {\n\t\treturn exec.Shell.Value\n\t}\n\tif rule.jobShell != \"\" {\n\t\treturn rule.jobShell\n\t}\n\tif rule.workflowShell != \"\" {\n\t\treturn rule.workflowShell\n\t}\n\tif rule.runnerShell != \"\" {\n\t\treturn rule.runnerShell\n\t}\n\t// Note: Default shell on Windows is pwsh so this value is not always correct.\n\t// Note: When bash is not found, GitHub-hosted runner fallbacks to sh.\n\treturn \"bash\"\n}\n\n// Replace ${{ ... }} with underscores like __________\n// Note: replacing with spaces sometimes causes syntax error. For example,\n//\n//\tif ${{ contains(xs, s) }}; then\n//\t  echo 'hello'\n//\tfi\nfunc sanitizeExpressionsInScript(src string) string {\n\tb := strings.Builder{}\n\tfor {\n\t\ts := strings.Index(src, \"${{\")\n\t\tif s == -1 {\n\t\t\tif b.Len() == 0 {\n\t\t\t\treturn src\n\t\t\t}\n\t\t\tb.WriteString(src)\n\t\t\treturn b.String()\n\t\t}\n\n\t\te := strings.Index(src[s:], \"}}\")\n\t\tif e == -1 {\n\t\t\tif b.Len() == 0 {\n\t\t\t\treturn src\n\t\t\t}\n\t\t\tb.WriteString(src)\n\t\t\treturn b.String()\n\t\t}\n\t\te += s + 2 // 2 is offset for len(\"}}\")\n\n\t\t// Note: If ${{ ... }} includes newline, line and column reported by shellcheck will be\n\t\t// shifted.\n\t\tb.WriteString(src[:s])\n\t\tfor i := 0; i < e-s; i++ {\n\t\t\tb.WriteByte('_')\n\t\t}\n\n\t\tsrc = src[e:]\n\t}\n}\n\nfunc (rule *RuleShellcheck) runShellcheck(src, shell string, pos *Pos) {\n\tvar sh string\n\tif shell == \"bash\" || shell == \"sh\" {\n\t\tsh = shell\n\t} else if strings.HasPrefix(shell, \"bash \") {\n\t\tsh = \"bash\"\n\t} else if strings.HasPrefix(shell, \"sh \") {\n\t\tsh = \"sh\"\n\t} else {\n\t\treturn // Skip checking this shell script since shellcheck doesn't support it\n\t}\n\n\tsrc = sanitizeExpressionsInScript(src)\n\trule.Debug(\"%s: Run shellcheck for %s script:\\n%s\", pos, sh, src)\n\n\t// Reasons to exclude the rules:\n\t//\n\t// - SC1091: File not found. Scripts are for CI environment. Not suitable for checking this in current local\n\t//           environment\n\t// - SC2194: The word is constant. This sometimes happens at constants by replacing ${{ }} with underscores.\n\t//           For example, `if ${{ matrix.foo }}; then ...` -> `if _________________; then ...`\n\t// - SC2050: The expression is constant. This sometimes happens at `if` condition by replacing ${{ }} with\n\t//           underscores (#45). For example, `if [ \"${{ matrix.foo }}\" = \"x\" ]` -> `if [ \"_________________\" = \"x\" ]`\n\t// - SC2154: The var is referenced but not assigned. Script at `run:` can refer variables defined in `env:` section\n\t//           so this rule can cause false positives (#53).\n\t// - SC2157: Argument to -z is always false due to literal strings. When the argument of -z is replaced from ${{ }},\n\t//           this can happen. For example, `if [ -z ${{ env.FOO }} ]` -> `if [ -z ______________ ]` (#113).\n\t// - SC2043: Loop can be detected as only running once when the target of iteration is a placeholder. (#355)\n\t//           e.g. `for foo in ${{ inputs.foo }}; do`\n\targs := []string{\"--norc\", \"-f\", \"json\", \"-x\", \"--shell\", sh, \"-e\", \"SC1091,SC2194,SC2050,SC2154,SC2157,SC2043\", \"-\"}\n\trule.Debug(\"%s: Running %s command with %s\", pos, rule.cmd.exe, args)\n\n\t// Use same options to run shell process described at document\n\t// https://docs.github.com/en/actions/learn-github-actions/workflow-syntax-for-github-actions#using-a-specific-shell\n\tsetup := \"set -e\"\n\tif sh == \"bash\" {\n\t\tsetup = \"set -eo pipefail\"\n\t}\n\tscript := fmt.Sprintf(\"%s\\n%s\\n\", setup, src)\n\n\trule.cmd.run(args, script, func(stdout []byte, err error) error {\n\t\tif err != nil {\n\t\t\trule.Debug(\"Command %s %s failed: %v\", rule.cmd.exe, args, err)\n\t\t\treturn fmt.Errorf(\"`%s %s` did not run successfully while checking script at %s: %w\", rule.cmd.exe, strings.Join(args, \" \"), pos, err)\n\t\t}\n\n\t\terrs := []shellcheckError{}\n\t\tif err := json.Unmarshal(stdout, &errs); err != nil {\n\t\t\treturn fmt.Errorf(\"could not parse JSON output from shellcheck: %w: stdout=%q\", err, stdout)\n\t\t}\n\t\tif len(errs) == 0 {\n\t\t\treturn nil\n\t\t}\n\n\t\t// Synchronize rule.Errorf calls\n\t\trule.mu.Lock()\n\t\tdefer rule.mu.Unlock()\n\t\t// It's better to show source location in the script as position of error, but it's not\n\t\t// possible easily. YAML has multiple block styles with '|', '>', '|+', '>+', '|-', '>-'. Some\n\t\t// of them remove indentation and/or blank lines. So restoring source position in block string\n\t\t// is not possible. Sourcemap is necessary to do it.\n\t\t// Instead, actionlint shows position of 'run:' as position of error. And separately show\n\t\t// location in script which is reported by shellcheck in error message.\n\t\tfor _, err := range errs {\n\t\t\t// Consider the first line is setup for running shell which was implicitly added for better check\n\t\t\tline := err.Line - 1\n\t\t\tmsg := strings.TrimSuffix(err.Message, \".\") // Trim period aligning style of error message\n\t\t\trule.Errorf(pos, \"shellcheck reported issue in this script: SC%d:%s:%d:%d: %s\", err.Code, err.Level, line, err.Column, msg)\n\t\t}\n\n\t\treturn nil\n\t})\n}\n"
        },
        {
          "name": "rule_shellcheck_test.go",
          "type": "blob",
          "size": 3.44921875,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n)\n\nfunc TestRuleShellcheckSanitizeExpressionsInScript(t *testing.T) {\n\ttestCases := []struct {\n\t\tinput string\n\t\twant  string\n\t}{\n\t\t{\n\t\t\t\"\",\n\t\t\t\"\",\n\t\t},\n\t\t{\n\t\t\t\"foo\",\n\t\t\t\"foo\",\n\t\t},\n\t\t{\n\t\t\t\"${{}}\",\n\t\t\t\"_____\",\n\t\t},\n\t\t{\n\t\t\t\"${{ matrix.foo }}\",\n\t\t\t\"_________________\",\n\t\t},\n\t\t{\n\t\t\t\"aaa ${{ matrix.foo }} bbb\",\n\t\t\t\"aaa _________________ bbb\",\n\t\t},\n\t\t{\n\t\t\t\"${{}}${{}}\",\n\t\t\t\"__________\",\n\t\t},\n\t\t{\n\t\t\t\"p${{a}}q${{b}}r\",\n\t\t\t\"p______q______r\",\n\t\t},\n\t\t{\n\t\t\t\"${{\",\n\t\t\t\"${{\",\n\t\t},\n\t\t{\n\t\t\t\"}}\",\n\t\t\t\"}}\",\n\t\t},\n\t\t{\n\t\t\t\"aaa${{foo\",\n\t\t\t\"aaa${{foo\",\n\t\t},\n\t\t{\n\t\t\t\"a${{b}}${{c\",\n\t\t\t\"a______${{c\",\n\t\t},\n\t\t{\n\t\t\t\"a${{b}}c}}d\",\n\t\t\t\"a______c}}d\",\n\t\t},\n\t\t{\n\t\t\t\"a}}b${{c}}d\",\n\t\t\t\"a}}b______d\",\n\t\t},\n\t}\n\n\tfor i, tc := range testCases {\n\t\tt.Run(fmt.Sprintf(\"%d_%s\", i, tc.input), func(t *testing.T) {\n\t\t\thave := sanitizeExpressionsInScript(tc.input)\n\t\t\tif tc.want != have {\n\t\t\t\tt.Fatalf(\"sanitized result is unexpected.\\nwant: %q\\nhave: %q\", tc.want, have)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// Regression for #409\nfunc TestRuleShellcheckDetectShell(t *testing.T) {\n\ttests := []struct {\n\t\twhat     string\n\t\twant     string\n\t\tworkflow string // Shell name set at 'defaults' in Workflow node\n\t\tjob      string // Shell name set at 'defaults' in Job node\n\t\tstep     string // Shell name set at 'shell' in Step node\n\t\trunner   string // Runner name at 'runs-on' in Job node\n\t}{\n\t\t{\n\t\t\twhat: \"no default shell\",\n\t\t\twant: \"bash\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"workflow default\",\n\t\t\twant:     \"pwsh\",\n\t\t\tworkflow: \"pwsh\",\n\t\t},\n\t\t{\n\t\t\twhat: \"job default\",\n\t\t\twant: \"pwsh\",\n\t\t\tjob:  \"pwsh\",\n\t\t},\n\t\t{\n\t\t\twhat: \"step config\",\n\t\t\twant: \"pwsh\",\n\t\t\tstep: \"pwsh\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"job default is more proioritized than workflow\",\n\t\t\twant:     \"pwsh\",\n\t\t\tworkflow: \"bash\",\n\t\t\tjob:      \"pwsh\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"step config is more proioritized than job\",\n\t\t\twant:     \"pwsh\",\n\t\t\tworkflow: \"sh\",\n\t\t\tjob:      \"bash\",\n\t\t\tstep:     \"pwsh\",\n\t\t},\n\t\t{\n\t\t\twhat:   \"default shell detected from runner\",\n\t\t\twant:   \"pwsh\",\n\t\t\trunner: \"windows-latest\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"workflow default is more proioritized than runner\",\n\t\t\twant:     \"bash\",\n\t\t\tworkflow: \"bash\",\n\t\t\trunner:   \"windows-latest\",\n\t\t},\n\t\t{\n\t\t\twhat:   \"job default is more proioritized than runner\",\n\t\t\twant:   \"bash\",\n\t\t\tjob:    \"bash\",\n\t\t\trunner: \"windows-latest\",\n\t\t},\n\t\t{\n\t\t\twhat:   \"step config is more proioritized than runner\",\n\t\t\twant:   \"bash\",\n\t\t\tstep:   \"bash\",\n\t\t\trunner: \"windows-latest\",\n\t\t},\n\t\t{\n\t\t\twhat:   \"no shell is detected from Ubuntu runner\",\n\t\t\twant:   \"bash\",\n\t\t\trunner: \"ubuntu-latest\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"custom bash\",\n\t\t\twant:     \"bash -e {0}\",\n\t\t\tworkflow: \"bash -e {0}\",\n\t\t},\n\t\t{\n\t\t\twhat:     \"custom sh\",\n\t\t\twant:     \"sh -e {0}\",\n\t\t\tworkflow: \"sh -e {0}\",\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tr := newRuleShellcheck(&externalCommand{})\n\n\t\t\tw := &Workflow{}\n\t\t\tif tc.workflow != \"\" {\n\t\t\t\tw.Defaults = &Defaults{\n\t\t\t\t\tRun: &DefaultsRun{\n\t\t\t\t\t\tShell: &String{Value: tc.workflow},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.VisitWorkflowPre(w)\n\n\t\t\tj := &Job{}\n\t\t\tif tc.job != \"\" {\n\t\t\t\tj.Defaults = &Defaults{\n\t\t\t\t\tRun: &DefaultsRun{\n\t\t\t\t\t\tShell: &String{Value: tc.job},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tif tc.runner != \"\" {\n\t\t\t\tj.RunsOn = &Runner{\n\t\t\t\t\tLabels: []*String{\n\t\t\t\t\t\t{Value: tc.runner},\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t}\n\t\t\tr.VisitJobPre(j)\n\n\t\t\te := &ExecRun{}\n\t\t\tif tc.step != \"\" {\n\t\t\t\te.Shell = &String{Value: tc.step}\n\t\t\t}\n\t\t\tif s := r.getShellName(e); s != tc.want {\n\t\t\t\tt.Fatalf(\"detected shell %q but wanted %q\", s, tc.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "rule_test.go",
          "type": "blob",
          "size": 1.669921875,
          "content": "package actionlint\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestRuleBaseSetGetConfig(t *testing.T) {\n\tr := NewRuleBase(\"\", \"\")\n\tif r.Config() != nil {\n\t\tt.Error(\"Config must be nil after creating a rule\")\n\t}\n\twant := &Config{}\n\tr.SetConfig(want)\n\tif have := r.Config(); have != want {\n\t\tt.Errorf(\"Wanted config %v but got %v\", want, have)\n\t}\n}\n\nfunc TestRuleBaseErrorfAndErrs(t *testing.T) {\n\tr := NewRuleBase(\"dummy name\", \"dummy description\")\n\terrs := r.Errs()\n\tif len(errs) > 0 {\n\t\tt.Error(\"no error is expected\", errs)\n\t}\n\tr.Error(&Pos{Line: 1, Col: 2}, \"this is test 1\")\n\tr.Errorf(&Pos{Line: 3, Col: 4}, \"this is test %d\", 2)\n\terrs = r.Errs()\n\tif len(errs) != 2 {\n\t\tt.Error(\"wanted 2 errors but have\", errs)\n\t}\n\twant := []*Error{\n\t\t{\n\t\t\tMessage: \"this is test 1\",\n\t\t\tLine:    1,\n\t\t\tColumn:  2,\n\t\t\tKind:    \"dummy name\",\n\t\t},\n\t\t{\n\t\t\tMessage: \"this is test 2\",\n\t\t\tLine:    3,\n\t\t\tColumn:  4,\n\t\t\tKind:    \"dummy name\",\n\t\t},\n\t}\n\tif diff := cmp.Diff(errs, want); diff != \"\" {\n\t\tt.Error(\"unexpected errors from Errs() method:\", diff)\n\t}\n}\n\nfunc TestRuleBaseDebugOutput(t *testing.T) {\n\tr := NewRuleBase(\"dummy-name\", \"\")\n\tr.Debug(\"this %s output\", \"is not\")\n\n\tb := &bytes.Buffer{}\n\tr.EnableDebug(b)\n\tr.Debug(\"this %s output!\", \"IS\")\n\n\thave := b.String()\n\twant := \"[dummy-name] this IS output!\\n\"\n\tif want != have {\n\t\tt.Errorf(\"wanted %q as debug output but have %q\", want, have)\n\t}\n}\n\nfunc TestRuleBaseNameAndDescription(t *testing.T) {\n\tr := NewRuleBase(\"dummy name\", \"dummy description\")\n\tif r.Name() != \"dummy name\" {\n\t\tt.Errorf(\"name is unexpected: %q\", r.Name())\n\t}\n\tif r.Description() != \"dummy description\" {\n\t\tt.Errorf(\"description is unexpected: %q\", r.Description())\n\t}\n}\n"
        },
        {
          "name": "rule_workflow_call.go",
          "type": "blob",
          "size": 5.1484375,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// RuleWorkflowCall is a rule checker to check workflow call at jobs.<job_id>.\ntype RuleWorkflowCall struct {\n\tRuleBase\n\tworkflowCallEventPos *Pos\n\tworkflowPath         string\n\tcache                *LocalReusableWorkflowCache\n}\n\n// NewRuleWorkflowCall creates a new RuleWorkflowCall instance. 'workflowPath' is a file path to\n// the workflow which is relative to a project root directory or an absolute path.\nfunc NewRuleWorkflowCall(workflowPath string, cache *LocalReusableWorkflowCache) *RuleWorkflowCall {\n\treturn &RuleWorkflowCall{\n\t\tRuleBase: RuleBase{\n\t\t\tname: \"workflow-call\",\n\t\t\tdesc: \"Checks for reusable workflow calls. Inputs and outputs of called reusable workflow are checked\",\n\t\t},\n\t\tworkflowCallEventPos: nil,\n\t\tworkflowPath:         workflowPath,\n\t\tcache:                cache,\n\t}\n}\n\n// VisitWorkflowPre is callback when visiting Workflow node before visiting its children.\nfunc (rule *RuleWorkflowCall) VisitWorkflowPre(n *Workflow) error {\n\tfor _, e := range n.On {\n\t\tif e, ok := e.(*WorkflowCallEvent); ok {\n\t\t\trule.workflowCallEventPos = e.Pos\n\t\t\t// Register this reusable workflow in cache so that it does not need to parse this workflow\n\t\t\t// file again when this workflow is called by other workflows.\n\t\t\trule.cache.WriteWorkflowCallEvent(rule.workflowPath, e)\n\t\t\tbreak\n\t\t}\n\t}\n\treturn nil\n}\n\n// VisitJobPre is callback when visiting Job node before visiting its children.\nfunc (rule *RuleWorkflowCall) VisitJobPre(n *Job) error {\n\tif n.WorkflowCall == nil {\n\t\treturn nil\n\t}\n\n\tu := n.WorkflowCall.Uses\n\tif u == nil || u.Value == \"\" || u.ContainsExpression() {\n\t\treturn nil\n\t}\n\n\tif isWorkflowCallUsesLocalFormat(u.Value) {\n\t\trule.checkWorkflowCallUsesLocal(n.WorkflowCall)\n\t\treturn nil\n\t}\n\n\tif isWorkflowCallUsesRepoFormat(u.Value) {\n\t\treturn nil\n\t}\n\n\tif strings.HasPrefix(u.Value, \"./\") {\n\t\t// When the specification is invalid and it is local reusable workflow call, remember it caused\n\t\t// an error by setting `nil` to cache. This can prevent redundant 'could not read workflow call'\n\t\t// error.\n\t\trule.cache.writeCache(u.Value, nil)\n\t}\n\n\trule.Errorf(\n\t\tu.Pos,\n\t\t\"reusable workflow call %q at \\\"uses\\\" is not following the format \\\"owner/repo/path/to/workflow.yml@ref\\\" nor \\\"./path/to/workflow.yml\\\". see https://docs.github.com/en/actions/learn-github-actions/reusing-workflows for more details\",\n\t\tu.Value,\n\t)\n\treturn nil\n}\n\nfunc (rule *RuleWorkflowCall) checkWorkflowCallUsesLocal(call *WorkflowCall) {\n\tu := call.Uses\n\tm, err := rule.cache.FindMetadata(u.Value)\n\tif err != nil {\n\t\trule.Error(u.Pos, err.Error())\n\t\treturn\n\t}\n\tif m == nil {\n\t\trule.Debug(\"Skip workflow call %q since no metadata was found\", u.Value)\n\t\treturn\n\t}\n\n\t// Validate inputs\n\tfor n, i := range m.Inputs {\n\t\tif i != nil && i.Required {\n\t\t\tif _, ok := call.Inputs[n]; !ok {\n\t\t\t\trule.Errorf(u.Pos, \"input %q is required by %q reusable workflow\", i.Name, u.Value)\n\t\t\t}\n\t\t}\n\t}\n\tfor n, i := range call.Inputs {\n\t\tif _, ok := m.Inputs[n]; !ok {\n\t\t\tnote := \"no input is defined\"\n\t\t\tif len(m.Inputs) > 0 {\n\t\t\t\tis := make([]string, 0, len(m.Inputs))\n\t\t\t\tfor _, i := range m.Inputs {\n\t\t\t\t\tis = append(is, i.Name)\n\t\t\t\t}\n\t\t\t\tif len(is) == 1 {\n\t\t\t\t\tnote = fmt.Sprintf(\"defined input is %q\", is[0])\n\t\t\t\t} else {\n\t\t\t\t\tnote = \"defined inputs are \" + sortedQuotes(is)\n\t\t\t\t}\n\t\t\t}\n\t\t\trule.Errorf(i.Name.Pos, \"input %q is not defined in %q reusable workflow. %s\", i.Name.Value, u.Value, note)\n\t\t}\n\t}\n\n\t// Validate secrets\n\tif !call.InheritSecrets {\n\t\tfor n, s := range m.Secrets {\n\t\t\tif s.Required {\n\t\t\t\tif _, ok := call.Secrets[n]; !ok {\n\t\t\t\t\trule.Errorf(u.Pos, \"secret %q is required by %q reusable workflow\", s.Name, u.Value)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor n, s := range call.Secrets {\n\t\t\tif _, ok := m.Secrets[n]; !ok {\n\t\t\t\tnote := \"no secret is defined\"\n\t\t\t\tif len(m.Secrets) > 0 {\n\t\t\t\t\tss := make([]string, 0, len(m.Secrets))\n\t\t\t\t\tfor _, s := range m.Secrets {\n\t\t\t\t\t\tss = append(ss, s.Name)\n\t\t\t\t\t}\n\t\t\t\t\tif len(ss) == 1 {\n\t\t\t\t\t\tnote = fmt.Sprintf(\"defined secret is %q\", ss[0])\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnote = \"defined secrets are \" + sortedQuotes(ss)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trule.Errorf(s.Name.Pos, \"secret %q is not defined in %q reusable workflow. %s\", s.Name.Value, u.Value, note)\n\t\t\t}\n\t\t}\n\t}\n\n\trule.Debug(\"Validated reusable workflow %q\", u.Value)\n}\n\n// Parse ./{path/{filename}\n// https://docs.github.com/en/actions/learn-github-actions/reusing-workflows#calling-a-reusable-workflow\nfunc isWorkflowCallUsesLocalFormat(u string) bool {\n\tif !strings.HasPrefix(u, \"./\") {\n\t\treturn false\n\t}\n\tu = strings.TrimPrefix(u, \"./\")\n\n\t// Cannot container a ref\n\tidx := strings.IndexRune(u, '@')\n\tif idx > 0 {\n\t\treturn false\n\t}\n\n\treturn len(u) > 0\n}\n\n// Parse {owner}/{repo}/{path to workflow.yml}@{ref}\n// https://docs.github.com/en/actions/learn-github-actions/reusing-workflows#calling-a-reusable-workflow\nfunc isWorkflowCallUsesRepoFormat(u string) bool {\n\t// Repo reference must start with owner\n\tif strings.HasPrefix(u, \".\") {\n\t\treturn false\n\t}\n\n\tidx := strings.IndexRune(u, '/')\n\tif idx <= 0 {\n\t\treturn false\n\t}\n\tu = u[idx+1:] // Eat owner\n\n\tidx = strings.IndexRune(u, '/')\n\tif idx <= 0 {\n\t\treturn false\n\t}\n\tu = u[idx+1:] // Eat repo\n\n\tidx = strings.IndexRune(u, '@')\n\tif idx <= 0 {\n\t\treturn false\n\t}\n\tu = u[idx+1:] // Eat workflow path\n\n\treturn len(u) > 0\n}\n"
        },
        {
          "name": "rule_workflow_call_test.go",
          "type": "blob",
          "size": 9.91015625,
          "content": "package actionlint\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc TestRuleWorkflowCallCheckWorkflowCallUsesFormat(t *testing.T) {\n\ttests := []struct {\n\t\tuses string\n\t\tok   bool\n\t}{\n\t\t{\"owner/repo/x.yml@ref\", true},\n\t\t{\"owner/repo/x.yml@@\", true},\n\t\t{\"owner/repo/x.yml@release/v1\", true},\n\t\t{\"./path/to/x.yml\", true},\n\t\t{\"${{ env.FOO }}\", true},\n\t\t{\"./path/to/x.yml@ref\", false},\n\t\t{\"/path/to/x.yml@ref\", false},\n\t\t{\"./\", false},\n\t\t{\".\", false},\n\t\t{\"owner/x.yml@ref\", false},\n\t\t{\"owner/repo@ref\", false},\n\t\t{\"owner/repo/x.yml\", false},\n\t\t{\"/repo/x.yml@ref\", false},\n\t\t{\"owner//x.yml@ref\", false},\n\t\t{\"owner/repo/@ref\", false},\n\t\t{\"owner/repo/x.yml@\", false},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.uses, func(t *testing.T) {\n\t\t\tc := NewLocalReusableWorkflowCache(nil, \"\", nil)\n\t\t\tr := NewRuleWorkflowCall(\"\", c)\n\t\t\tj := &Job{\n\t\t\t\tWorkflowCall: &WorkflowCall{\n\t\t\t\t\tUses: &String{\n\t\t\t\t\t\tValue: tc.uses,\n\t\t\t\t\t\tPos:   &Pos{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\terr := r.VisitJobPre(j)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\terrs := r.Errs()\n\t\t\tif tc.ok && len(errs) > 0 {\n\t\t\t\tt.Fatalf(\"Error occurred: %v\", errs)\n\t\t\t}\n\t\t\tif !tc.ok {\n\t\t\t\tif len(errs) > 2 || len(errs) == 0 {\n\t\t\t\t\tt.Fatalf(\"Wanted one error but have: %v\", errs)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestRuleWorkflowCallNestedWorkflowCalls(t *testing.T) {\n\tw := &Workflow{\n\t\tOn: []Event{\n\t\t\t&WorkflowCallEvent{\n\t\t\t\tPos: &Pos{},\n\t\t\t},\n\t\t},\n\t}\n\n\tj := &Job{\n\t\tWorkflowCall: &WorkflowCall{\n\t\t\tUses: &String{\n\t\t\t\tValue: \"o/r/w.yaml@r\",\n\t\t\t\tPos:   &Pos{},\n\t\t\t},\n\t\t},\n\t}\n\n\tc := NewLocalReusableWorkflowCache(nil, \"\", nil)\n\tr := NewRuleWorkflowCall(\"\", c)\n\n\tif err := r.VisitWorkflowPre(w); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := r.VisitJobPre(j); err != nil {\n\t\tt.Fatal(err)\n\t}\n\terrs := r.Errs()\n\n\tif len(errs) > 0 {\n\t\tt.Fatal(\"unexpected errors:\", errs)\n\t}\n}\n\nfunc TestRuleWorkflowCallWriteEventNodeToMetadataCache(t *testing.T) {\n\ts := func(v string) *String {\n\t\treturn &String{Value: v, Pos: &Pos{}}\n\t}\n\tw := &Workflow{\n\t\tOn: []Event{\n\t\t\t&WorkflowCallEvent{\n\t\t\t\tInputs: []*WorkflowCallEventInput{\n\t\t\t\t\t{\n\t\t\t\t\t\tName: s(\"input1\"),\n\t\t\t\t\t\tType: WorkflowCallEventInputTypeString,\n\t\t\t\t\t\tID:   \"input1\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tOutputs: map[string]*WorkflowCallEventOutput{\n\t\t\t\t\t\"output1\": {Name: s(\"output1\")},\n\t\t\t\t},\n\t\t\t\tSecrets: map[string]*WorkflowCallEventSecret{\n\t\t\t\t\t\"secret1\": {Name: s(\"secret1\")},\n\t\t\t\t},\n\t\t\t\tPos: &Pos{},\n\t\t\t},\n\t\t},\n\t}\n\n\tcwd := filepath.Join(\"path\", \"to\", \"project\")\n\tc := NewLocalReusableWorkflowCache(&Project{cwd, nil}, cwd, nil)\n\tr := NewRuleWorkflowCall(\"test-workflow.yaml\", c)\n\n\tif err := r.VisitWorkflowPre(w); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terrs := r.Errs()\n\tif len(errs) > 0 {\n\t\tt.Fatal(errs)\n\t}\n\n\tm, ok := c.readCache(\"./test-workflow.yaml\")\n\tif !ok {\n\t\tt.Fatal(\"no metadata was created\")\n\t}\n\n\twant := &ReusableWorkflowMetadata{\n\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\"input1\": {\"input1\", false, StringType{}},\n\t\t},\n\t\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\t\"output1\": {\"output1\"},\n\t\t},\n\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\"secret1\": {\"secret1\", false},\n\t\t},\n\t}\n\n\tif diff := cmp.Diff(want, m); diff != \"\" {\n\t\tt.Fatal(diff)\n\t}\n}\n\nfunc TestRuleWorkflowCallCheckReusableWorkflowCall(t *testing.T) {\n\tcwd := filepath.Join(\"testdata\", \"reusable_workflow_metadata\")\n\tcache := NewLocalReusableWorkflowCache(&Project{cwd, nil}, cwd, nil)\n\n\tfor i, md := range []*ReusableWorkflowMetadata{\n\t\t// workflow0.yaml\n\t\t{\n\t\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\t\"optional_input\": {\"optional_input\", false, StringType{}},\n\t\t\t\t\"required_input\": {\"required_input\", true, StringType{}},\n\t\t\t},\n\t\t\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\t\t\"output\": {\"output\"},\n\t\t\t},\n\t\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\t\"optional_secret\": {\"optional_secret\", false},\n\t\t\t\t\"required_secret\": {\"required_secret\", true},\n\t\t\t},\n\t\t},\n\t\t// workflow1.yaml: Inputs and outputs in upper case (#216)\n\t\t{\n\t\t\tInputs: ReusableWorkflowMetadataInputs{\n\t\t\t\t\"optional_input\": {\"OPTIONAL_INPUT\", false, StringType{}},\n\t\t\t\t\"required_input\": {\"REQUIRED_INPUT\", true, StringType{}},\n\t\t\t},\n\t\t\tOutputs: ReusableWorkflowMetadataOutputs{\n\t\t\t\t\"output\": {\"OUTPUT\"},\n\t\t\t},\n\t\t\tSecrets: ReusableWorkflowMetadataSecrets{\n\t\t\t\t\"optional_secret\": {\"OPTIONAL_SECRET\", false},\n\t\t\t\t\"required_secret\": {\"REQUIRED_SECRET\", true},\n\t\t\t},\n\t\t},\n\t\t// workflow2.yaml: No input and secret are defined\n\t\t{\n\t\t\tInputs:  ReusableWorkflowMetadataInputs{},\n\t\t\tOutputs: ReusableWorkflowMetadataOutputs{},\n\t\t\tSecrets: ReusableWorkflowMetadataSecrets{},\n\t\t},\n\t} {\n\t\tcache.writeCache(fmt.Sprintf(\"./workflow%d.yaml\", i), md)\n\t}\n\n\ttests := []struct {\n\t\twhat           string\n\t\tuses           string\n\t\tinputs         []string\n\t\tsecrets        []string\n\t\tinheritSecrets bool\n\t\terrs           []string\n\t}{\n\t\t{\n\t\t\twhat:    \"all\",\n\t\t\tuses:    \"./workflow0.yaml\",\n\t\t\tinputs:  []string{\"optional_input\", \"required_input\"},\n\t\t\tsecrets: []string{\"optional_secret\", \"required_secret\"},\n\t\t},\n\t\t{\n\t\t\twhat:    \"only required\",\n\t\t\tuses:    \"./workflow0.yaml\",\n\t\t\tinputs:  []string{\"required_input\"},\n\t\t\tsecrets: []string{\"required_secret\"},\n\t\t},\n\t\t{\n\t\t\twhat:    \"unknown workflow\",\n\t\t\tuses:    \"./unknown-workflow.yaml\",\n\t\t\tinputs:  []string{\"aaa\", \"bbb\"},\n\t\t\tsecrets: []string{\"xxx\", \"yyy\"},\n\t\t\terrs: []string{\n\t\t\t\t\"could not read reusable workflow file for \\\"./unknown-workflow.yaml\\\":\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:    \"missing required input and secret\",\n\t\t\tuses:    \"./workflow0.yaml\",\n\t\t\tinputs:  []string{\"optional_input\"},\n\t\t\tsecrets: []string{\"optional_secret\"},\n\t\t\terrs: []string{\n\t\t\t\t\"input \\\"required_input\\\" is required\",\n\t\t\t\t\"secret \\\"required_secret\\\" is required\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:    \"undefined input and secret\",\n\t\t\tuses:    \"./workflow0.yaml\",\n\t\t\tinputs:  []string{\"required_input\", \"unknown_input\"},\n\t\t\tsecrets: []string{\"required_secret\", \"unknown_secret\"},\n\t\t\terrs: []string{\n\t\t\t\t\"input \\\"unknown_input\\\" is not defined in \\\"./workflow0.yaml\\\" reusable workflow. defined inputs are \\\"optional_input\\\", \\\"required_input\\\"\",\n\t\t\t\t\"secret \\\"unknown_secret\\\" is not defined in \\\"./workflow0.yaml\\\" reusable workflow. defined secrets are \\\"optional_secret\\\", \\\"required_secret\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:           \"inherit secrets\",\n\t\t\tuses:           \"./workflow0.yaml\",\n\t\t\tinputs:         []string{\"required_input\"},\n\t\t\tsecrets:        []string{\"unknown_secret\", \"optional_secret\"},\n\t\t\tinheritSecrets: true,\n\t\t},\n\t\t{\n\t\t\twhat:    \"read workflow\",\n\t\t\tuses:    \"./ok.yaml\", // Defined in testdata/reusable_workflow_metadata/ok.yaml\n\t\t\tinputs:  []string{\"input2\"},\n\t\t\tsecrets: []string{\"secret2\"},\n\t\t},\n\t\t{\n\t\t\twhat: \"read broken workflow\",\n\t\t\tuses: \"./broken.yaml\", // Defined in testdata/reusable_workflow_metadata/broken.yaml\n\t\t\terrs: []string{\n\t\t\t\t\"error while parsing reusable workflow \\\"./broken.yaml\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat: \"external workflow call with no input and no secret\",\n\t\t\tuses: \"owner/repo/path/to/workflow@main\",\n\t\t},\n\t\t{\n\t\t\twhat:    \"external workflow call with inputs and secrets\",\n\t\t\tuses:    \"owner/repo/path/to/workflow@main\",\n\t\t\tinputs:  []string{\"aaa\", \"bbb\"},\n\t\t\tsecrets: []string{\"xxx\", \"yyy\"},\n\t\t},\n\t\t{\n\t\t\twhat:    \"call in upper case and workflow in lower case\",\n\t\t\tuses:    \"./workflow0.yaml\",\n\t\t\tinputs:  []string{\"OPTIONAL_INPUT\", \"REQUIRED_INPUT\"},\n\t\t\tsecrets: []string{\"OPTIONAL_SECRET\", \"REQUIRED_SECRET\"},\n\t\t},\n\t\t{\n\t\t\twhat:    \"call in lower case and workflow in upper case\",\n\t\t\tuses:    \"./workflow1.yaml\",\n\t\t\tinputs:  []string{\"optional_input\", \"required_input\"},\n\t\t\tsecrets: []string{\"optional_secret\", \"required_secret\"},\n\t\t},\n\t\t{\n\t\t\twhat:    \"call in upper case and workflow in upper case\",\n\t\t\tuses:    \"./workflow1.yaml\",\n\t\t\tinputs:  []string{\"OPTIONAL_INPUT\", \"REQUIRED_INPUT\"},\n\t\t\tsecrets: []string{\"OPTIONAL_SECRET\", \"REQUIRED_SECRET\"},\n\t\t},\n\t\t{\n\t\t\twhat:    \"undefined upper input and secret\",\n\t\t\tuses:    \"./workflow0.yaml\",\n\t\t\tinputs:  []string{\"required_input\", \"UNKNOWN_INPUT\"},\n\t\t\tsecrets: []string{\"required_secret\", \"UNKNOWN_SECRET\"},\n\t\t\terrs: []string{\n\t\t\t\t\"input \\\"UNKNOWN_INPUT\\\" is not defined in \\\"./workflow0.yaml\\\"\",\n\t\t\t\t\"secret \\\"UNKNOWN_SECRET\\\" is not defined in \\\"./workflow0.yaml\\\"\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\twhat:    \"no input and secret defined\",\n\t\t\tuses:    \"./workflow2.yaml\",\n\t\t\tinputs:  []string{\"unknown_input\"},\n\t\t\tsecrets: []string{\"unknown_secret\"},\n\t\t\terrs: []string{\n\t\t\t\t\"input \\\"unknown_input\\\" is not defined in \\\"./workflow2.yaml\\\" reusable workflow. no input is defined\",\n\t\t\t\t\"secret \\\"unknown_secret\\\" is not defined in \\\"./workflow2.yaml\\\" reusable workflow. no secret is defined\",\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tc := range tests {\n\t\tt.Run(tc.what, func(t *testing.T) {\n\t\t\tr := NewRuleWorkflowCall(\"this-workflow.yaml\", cache)\n\n\t\t\tw := &Workflow{\n\t\t\t\tOn: []Event{\n\t\t\t\t\t&WorkflowCallEvent{\n\t\t\t\t\t\tPos: &Pos{},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}\n\t\t\tif err := r.VisitWorkflowPre(w); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\tc := &WorkflowCall{\n\t\t\t\tUses:           &String{Value: tc.uses, Pos: &Pos{}},\n\t\t\t\tInputs:         map[string]*WorkflowCallInput{},\n\t\t\t\tSecrets:        map[string]*WorkflowCallSecret{},\n\t\t\t\tInheritSecrets: tc.inheritSecrets,\n\t\t\t}\n\t\t\tfor _, i := range tc.inputs {\n\t\t\t\tc.Inputs[strings.ToLower(i)] = &WorkflowCallInput{\n\t\t\t\t\tName:  &String{Value: i, Pos: &Pos{}},\n\t\t\t\t\tValue: &String{Value: \"\", Pos: &Pos{}},\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor _, s := range tc.secrets {\n\t\t\t\tc.Secrets[strings.ToLower(s)] = &WorkflowCallSecret{\n\t\t\t\t\tName:  &String{Value: s, Pos: &Pos{}},\n\t\t\t\t\tValue: &String{Value: \"\", Pos: &Pos{}},\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tj := &Job{WorkflowCall: c}\n\t\t\tif err := r.VisitJobPre(j); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\n\t\t\terrs := []string{}\n\t\t\tfor _, err := range r.Errs() {\n\t\t\t\terrs = append(errs, err.Error())\n\t\t\t}\n\t\t\tsort.Strings(errs)\n\n\t\t\tif len(errs) != len(tc.errs) {\n\t\t\t\tt.Fatalf(\n\t\t\t\t\t\"Number of errors is unexpected. %d errors was expected but got %d errors. Expected errors are %v but actual errors are %v\",\n\t\t\t\t\tlen(tc.errs),\n\t\t\t\t\tlen(errs),\n\t\t\t\t\ttc.errs,\n\t\t\t\t\terrs,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tfor i, have := range errs {\n\t\t\t\twant := tc.errs[i]\n\t\t\t\tif !strings.Contains(have, want) {\n\t\t\t\t\tt.Errorf(\"%d-th error is unexpected. %q should be contained in error message %q\", i, want, have)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "scripts",
          "type": "tree",
          "content": null
        },
        {
          "name": "staticcheck.conf",
          "type": "blob",
          "size": 0.1689453125,
          "content": "# https://staticcheck.dev/docs/configuration/\n\n# https://staticcheck.dev/docs/checks/\nchecks = [\"inherit\", \"ST1016\", \"ST1020\", \"ST1021\", \"ST1022\", \"ST1000\"]\n\n# vim: ft=toml\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}