{
  "metadata": {
    "timestamp": 1736566858644,
    "page": 429,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjQzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nextdns/nextdns",
      "stars": 3290,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0498046875,
          "content": "dist/\n/test.conf\n/nextdns.exe\n/nextdns\n/nextdns-h3\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 3.0537109375,
          "content": "version: 2\nbefore:\n  hooks:\n    - go mod tidy\nbuilds:\n-\n  goos:\n  - freebsd\n  - netbsd\n  - openbsd\n  - dragonfly\n  - linux\n  - darwin\n  - windows\n  goarch:\n  - 386\n  - amd64\n  - arm\n  - arm64\n  - mips\n  - mipsle\n  - mips64\n  - mips64le\n  goarm:\n  - 5\n  - 6\n  - 7\n  gomips:\n  - softfloat\n  - hardfloat\n  env:\n  - CGO_ENABLED={{ if eq .Os \"darwin\" }}1{{ else }}0{{ end }}\n  flags:\n  - -trimpath\n  ignore:\n  -\n    goos: windows\n    goarch: arm64\narchives:\n-\n  format_overrides:\n  -\n    goos: windows\n    format: zip\n  files:\n  - LICENSE\n  - README.md\nchecksum:\n  name_template: 'checksums.txt'\nrelease:\n  github:\n    owner: nextdns\n    name: nextdns\n  name_template: \"{{.ProjectName}}-v{{.Version}}\"\nbrews:\n-\n  repository:\n    owner: nextdns\n    name: homebrew-tap\n  commit_author:\n    name: NextDNS Team\n    email: team@nextdns.io\n  homepage: https://nextdns.io\n  description: NextDNS DNS/53 to DoH Proxy\n  caveats: \"To install NextDNS, run the following command:\n\n    sudo nextdns install --profile <your_profile_id>\n\nThen setup your DNS manually to 127.0.0.1 or by running:\n\n    sudo nextdns activate\n\"\nnfpms:\n  -\n    vendor: NextDNS Inc\n    homepage: https://nextdns.io\n    maintainer: NextDNS Team <team@nextdns.io>\n    description: NextDNS DNS/53 to DoH Proxy\n    license: MIT\n    formats:\n      - deb\n      - rpm\n      - apk\n    bindir: /usr/bin\n    dependencies:\n      - curl\n    overrides:\n      deb:\n        scripts:\n          postinstall: \".goreleaser/deb/postinst\"\n          preremove: \".goreleaser/deb/prerm\"\n      rpm:\n        scripts:\n          postinstall: \".goreleaser/rpm/post\"\n          preremove: \".goreleaser/rpm/preun\"\n      apk:\n        scripts:\n          postinstall: \".goreleaser/apk/post-install\"\n          preremove: \".goreleaser/apk/pre-deinstall\"\n    apk:\n      scripts:\n          postupgrade: \".goreleaser/apk/post-upgrade\"\ndockers:\n  - image_templates:\n      - \"nextdns/nextdns:{{ .Version }}-amd64\"\n    use: buildx\n    dockerfile: Dockerfile\n    build_flag_templates: [\"--platform=linux/amd64\"]\n  - image_templates:\n      - \"nextdns/nextdns:{{ .Version }}-armv7\"\n    use: buildx\n    goarch: arm\n    goarm: 7\n    dockerfile: Dockerfile\n    build_flag_templates:\n      - \"--platform=linux/arm/v7\"\n  - image_templates:\n      - \"nextdns/nextdns:{{ .Version }}-arm64\"\n    use: buildx\n    goarch: arm64\n    dockerfile: Dockerfile\n    build_flag_templates:\n      - \"--platform=linux/arm64\"\ndocker_manifests:\n  - name_template: \"nextdns/nextdns:{{ .Version }}\"\n    image_templates:\n      - \"nextdns/nextdns:{{ .Version }}-amd64\"\n      - \"nextdns/nextdns:{{ .Version }}-amdv7\"\n      - \"nextdns/nextdns:{{ .Version }}-arm64\"\ndockerhub:\n  - username: nextdns\n    images:\n      - \"nextdns/nextdns:{{ .Version }}-arm64v8\"\n      - \"nextdns/nextdns:{{ .Version }}-arm64v8\"\nchangelog:\n  groups:\n    - title: \"âœ¨ New Features\"\n      regexp: '^.*?feat(\\([[:word:]]+\\))??!?:.+$'\n      order: 0\n    - title: \"ðŸ› Bug Fixes\"\n      regexp: '^.*?bug(\\([[:word:]]+\\))??!?:.+$'\n      order: 1\n    - title: \"ðŸ”§ Chores\"\n      regexp: '^.*?bug(\\([[:word:]]+\\))??!?:.+$'\n      order: 2\n    - title: Others\n      order: 999\n"
        },
        {
          "name": ".goreleaser",
          "type": "tree",
          "content": null
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.072265625,
          "content": "FROM alpine\nENTRYPOINT [\"/usr/bin/nextdns\"]\nCOPY nextdns /usr/bin/nextdns\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0419921875,
          "content": "MIT License\n\nCopyright (c) 2019 NextDNS Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE."
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.630859375,
          "content": "# NextDNS CLI Client\n\nNextDNS CLI is a command-line tool that allows you to use [NextDNS](https://nextdns.io)'s DNS-over-HTTPS (DoH) service with advanced capabilities. Although the most advanced features will only work with NextDNS, this program can work as a client for any DoH provider or a mix of NextDNS + another DNS (split horizon).\n\nThis CLI is mostly aimed at routers and UNIX based systems, but it is also a great client for Windows and macOS, especially for people who prefer a fully open-source client and don't mind the lack of a GUI.\n\nSee the [wiki](https://github.com/nextdns/nextdns/wiki) for installation and usage instructions.\n"
        },
        {
          "name": "activate.go",
          "type": "blob",
          "size": 1.6455078125,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"github.com/nextdns/nextdns/config\"\n\t\"github.com/nextdns/nextdns/host\"\n\t\"github.com/nextdns/nextdns/hosts\"\n)\n\nfunc activation(args []string) error {\n\tcmd := args[0]\n\tvar c config.Config\n\tc.Parse(\"nextdns \"+cmd, nil, true)\n\tdefer func() { _ = c.Save() }()\n\tswitch cmd {\n\tcase \"activate\":\n\t\tc.AutoActivate = true\n\t\treturn activate(c)\n\tcase \"deactivate\":\n\t\tc.AutoActivate = false\n\t\treturn deactivate()\n\tdefault:\n\t\treturn fmt.Errorf(\"%s: unknown command\", cmd)\n\t}\n}\n\nfunc listenIP(listen string) (string, error) {\n\thost, port, err := net.SplitHostPort(listen)\n\tif err != nil {\n\t\treturn \"127.0.0.1\", nil\n\t}\n\tswitch port {\n\tcase \"53\", \"domain\":\n\t\t// Can only activate on default port\n\tdefault:\n\t\treturn \"\", fmt.Errorf(\"activate: %s: non 53 port not supported\", listen)\n\t}\n\tswitch host {\n\tcase \"\", \"0.0.0.0\":\n\t\treturn \"127.0.0.1\", nil\n\tcase \"::\":\n\t\treturn \"::1\", nil\n\t}\n\tif net.ParseIP(host) != nil {\n\t\treturn host, nil\n\t}\n\taddrs := hosts.LookupHost(host)\n\tif len(addrs) == 0 {\n\t\treturn \"\", fmt.Errorf(\"activate: %s: no address found\", listen)\n\t}\n\treturn addrs[0], nil\n}\n\nfunc activate(c config.Config) error {\n\tif len(c.Listens) == 0 {\n\t\treturn errors.New(\"missing listen setting\")\n\t}\n\tlisten := c.Listens[0]\n\tif c.SetupRouter {\n\t\t// Setup router might make nextdns listen on a custom port so it can\n\t\t// be chained behind dnsmasq for instance. To make the router use\n\t\t// nextdns, we want it to go thru the whole chain so it benefits\n\t\t// from dnsmasq cache.\n\t\tlisten = \"127.0.0.1:53\"\n\t}\n\tlistenIP, err := listenIP(listen)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn host.SetDNS(listenIP)\n}\n\nfunc deactivate() error {\n\treturn host.ResetDNS()\n}\n"
        },
        {
          "name": "arp",
          "type": "tree",
          "content": null
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 1.4951171875,
          "content": "package main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\n\t\"github.com/nextdns/nextdns/config\"\n)\n\nfunc cfg(args []string) error {\n\targs = args[1:]\n\tsubCmd := \"list\"\n\tif len(args) > 0 {\n\t\tsubCmd = args[0]\n\t\targs = args[1:]\n\t}\n\tswitch subCmd {\n\tcase \"list\":\n\t\tvar c config.Config\n\t\tc.Parse(\"nextdns config list\", args, true)\n\t\treturn c.Write(os.Stdout)\n\tcase \"set\":\n\t\tvar c config.Config\n\t\tc.Parse(\"nextdns config set\", args, true)\n\t\treturn c.Save()\n\tcase \"edit\":\n\t\tvar c config.Config\n\t\tc.Parse(\"nextdns config edit\", nil, true)\n\t\ttmp, err := os.CreateTemp(\"\", \"\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer os.Remove(tmp.Name())\n\t\tif err := c.Write(tmp); err != nil {\n\t\t\ttmp.Close()\n\t\t\treturn err\n\t\t}\n\t\ttmp.Close()\n\t\teditor := os.Getenv(\"EDITOR\")\n\t\tif editor == \"\" {\n\t\t\teditor = \"vi\"\n\t\t}\n\t\tcmd := exec.Command(editor, tmp.Name())\n\t\tcmd.Stdin = os.Stdin\n\t\tcmd.Stdout = os.Stdout\n\t\tif err := cmd.Run(); err != nil {\n\t\t\treturn fmt.Errorf(\"%s: %v\", editor, err)\n\t\t}\n\t\tc = config.Config{}\n\t\tc.Parse(\"nextdns config edit\", []string{\"-config-file\", tmp.Name()}, true)\n\t\tc.File = \"\"\n\t\treturn c.Save()\n\tcase \"wizard\":\n\t\treturn installer(\"configure\")\n\tdefault:\n\t\treturn errors.New(\"usage: \\n\" +\n\t\t\t\"  config list              list configuration options\\n\" +\n\t\t\t\"  config set [options]     set a configuration option\\n\" +\n\t\t\t\"                           (see config set -h for list of options)\\n\" +\n\t\t\t\"  config edit              edit configuration using default editor\\n\" +\n\t\t\t\"  config wizard            run the configuration wizard\")\n\t}\n}\n"
        },
        {
          "name": "config",
          "type": "tree",
          "content": null
        },
        {
          "name": "ctl.go",
          "type": "blob",
          "size": 0.673828125,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"flag\"\n\t\"fmt\"\n\n\t\"github.com/nextdns/nextdns/config\"\n\t\"github.com/nextdns/nextdns/ctl\"\n)\n\nfunc ctlCmd(args []string) error {\n\tcmd := args[0]\n\tfs := flag.NewFlagSet(cmd, flag.ExitOnError)\n\tcontrol := fs.String(\"control\", config.DefaultControl, \"Address to the control socket\")\n\t_ = fs.Parse(args[1:])\n\tcl, err := ctl.Dial(*control)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer cl.Close()\n\tdata, err := cl.Send(ctl.Event{\n\t\tName: cmd,\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\tif s, ok := data.(string); ok {\n\t\tfmt.Println(s)\n\t\treturn nil\n\t}\n\tb, err := json.MarshalIndent(data, \"\", \"    \")\n\tif err != nil {\n\t\treturn err\n\t}\n\tfmt.Println(string(b))\n\treturn nil\n}\n"
        },
        {
          "name": "ctl",
          "type": "tree",
          "content": null
        },
        {
          "name": "discovery",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.2197265625,
          "content": "module github.com/nextdns/nextdns\n\ngo 1.20\n\nrequire (\n\tgithub.com/cespare/xxhash v1.1.0\n\tgithub.com/denisbrodbeck/machineid v1.0.1\n\tgithub.com/hashicorp/golang-lru v1.0.2\n\tgolang.org/x/net v0.33.0\n\tgolang.org/x/sys v0.28.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.2158203125,
          "content": "github.com/OneOfOne/xxhash v1.2.2 h1:KMrpdQIwFcEqXDklaen+P1axHaj9BSKzvpUUfnHldSE=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/cespare/xxhash v1.1.0 h1:a6HrQnmkObjyL+Gs60czilIUGqrzKutQD6XZog3p+ko=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/denisbrodbeck/machineid v1.0.1 h1:geKr9qtkB876mXguW2X6TU4ZynleN6ezuMSRhl4D7AQ=\ngithub.com/denisbrodbeck/machineid v1.0.1/go.mod h1:dJUwb7PTidGDeYyUBmXZ2GphQBbjJCrnectwCyxcUSI=\ngithub.com/hashicorp/golang-lru v1.0.2 h1:dV3g9Z/unq5DpblPpw+Oqcv4dU/1omnb4Ok8iPY6p1c=\ngithub.com/hashicorp/golang-lru v1.0.2/go.mod h1:iADmTwqILo4mZ8BN3D2Q6+9jd8WM5uGBxy+E8yxSoD4=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72 h1:qLC7fQah7D6K1B0ujays3HV9gkFtllcxhzImRR7ArPQ=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        },
        {
          "name": "host",
          "type": "tree",
          "content": null
        },
        {
          "name": "hosts",
          "type": "tree",
          "content": null
        },
        {
          "name": "install.sh",
          "type": "blob",
          "size": 29.1142578125,
          "content": "#!/bin/sh\n\nmain() {\n    OS=$(detect_os)\n    GOARCH=$(detect_goarch)\n    GOOS=$(detect_goos)\n    NEXTDNS_BIN=$(bin_location)\n    INSTALL_RELEASE=$(get_release)\n\n    export NEXTDNS_INSTALLER=1\n\n    log_info \"OS: $OS\"\n    log_info \"GOARCH: $GOARCH\"\n    log_info \"GOOS: $GOOS\"\n    log_info \"NEXTDNS_BIN: $NEXTDNS_BIN\"\n    log_info \"INSTALL_RELEASE: $INSTALL_RELEASE\"\n\n    if [ -z \"$OS\" ] || [ -z \"$GOARCH\" ] || [ -z \"$GOOS\" ] || [ -z \"$NEXTDNS_BIN\" ] || [ -z \"$INSTALL_RELEASE\" ]; then\n        log_error \"Cannot detect running environment.\"\n        exit 1\n    fi\n\n    case \"$RUN_COMMAND\" in\n    install|upgrade|uninstall|configure) \"$RUN_COMMAND\"; exit ;;\n    esac\n\n    while true; do\n        CURRENT_RELEASE=$(get_current_release)\n        log_debug \"Start install loop with CURRENT_RELEASE=$CURRENT_RELEASE\"\n\n        if [ \"$CURRENT_RELEASE\" ]; then\n            if ! is_version_current; then\n                log_debug \"NextDNS is out of date ($CURRENT_RELEASE != $INSTALL_RELEASE)\"\n                menu \\\n                    u \"Upgrade NextDNS from $CURRENT_RELEASE to $INSTALL_RELEASE\" upgrade \\\n                    c \"Configure NextDNS\" configure \\\n                    r \"Remove NextDNS\" uninstall \\\n                    e \"Exit\" exit\n            else\n                log_debug \"NextDNS is up to date ($CURRENT_RELEASE)\"\n                menu \\\n                    c \"Configure NextDNS\" configure \\\n                    r \"Remove NextDNS\" uninstall \\\n                    e \"Exit\" exit\n            fi\n        else\n            log_debug \"NextDNS is not installed\"\n            menu \\\n                i \"Install NextDNS\" install \\\n                e \"Exit\" exit\n        fi\n    done\n}\n\ninstall() {\n    if [ \"$(get_current_release)\" ]; then\n        log_info \"Already installed\"\n        return\n    fi\n    if type=$(install_type); then\n        log_info \"Installing NextDNS...\"\n        log_debug \"Using $type install type\"\n        if \"install_$type\"; then\n            if [ ! -x \"$NEXTDNS_BIN\" ]; then\n                log_error \"Installation failed: binary not installed in $NEXTDNS_BIN\"\n                return 1\n            fi\n            configure\n            post_install\n            exit 0\n        fi\n    else\n        return $?\n    fi\n}\n\nupgrade() {\n    if [ \"$(get_current_release)\" = \"$INSTALL_RELEASE\" ]; then\n        log_info \"Already on the latest version\"\n        return\n    fi\n    if type=$(install_type); then\n        log_info \"Upgrading NextDNS...\"\n        log_debug \"Using $type install type\"\n        \"upgrade_$type\"\n    else\n        return $?\n    fi\n}\n\nuninstall() {\n    if type=$(install_type); then\n        log_info \"Uninstalling NextDNS...\"\n        log_debug \"Using $type uninstall type\"\n        \"uninstall_$type\"\n    else\n        return $?\n    fi\n}\n\nprecheck() {\n    if [ -e \"/data/unifi\" ] && [ -f \"/run/dnsfilter/dnsfilter\" ]; then\n        log_warn \"UDM Content Filtering and/or Ad Blocking feature is enabled.\"\n        log_warn \"Please disable it to use NextDNS.\"\n        log_warn \"\"\n        log_warn \"  To disable Content Filtering, go to Settings > Network.\"\n        log_warn \"  For each network, set the Content Filtering feature to None.\"\n        log_warn \"\"\n        log_warn \"  To disable Ad Blocking, go to Settings > Application Firewall\"\n        log_warn \"  In the General tab, uncheck the Ad Blocking checkbox.\"\n        log_warn \"\"\n        while [ -f \"/run/dnsfilter/dnsfilter\" ]; do\n            sleep 1\n        done\n        log_info \"Content Filtering feature successfully disabled.\"\n    fi\n}\n\nconfigure() {\n    log_debug \"Start configure\"\n    precheck\n    args=\"\"\n    add_arg() {\n        for value in $2; do\n            log_debug \"Add arg -$1=$value\"\n            args=\"$args -$1=$value\"\n        done\n    }\n    add_arg_bool_ask() {\n        arg=$1\n        msg=$2\n        default=$3\n        if [ -z \"$default\" ]; then\n            default=$(get_config_bool \"$arg\")\n        fi\n        # shellcheck disable=SC2046\n        add_arg \"$arg\" $(ask_bool \"$msg\" \"$default\")\n    }\n    # Use profile from now on\n    add_arg profile \"$(get_profile_id)\"\n\n    doc \"Sending your devices name lets you filter analytics and logs by device.\"\n    add_arg_bool_ask report-client-info 'Report device name?' true\n\n    case $(guess_host_type) in\n    router)\n        add_arg setup-router true\n        ;;\n    unsure)\n        doc \"Accept DNS request from other network hosts.\"\n        if [ \"$(get_config_bool setup-router)\" = \"true\" ]; then\n            router_default=true\n        fi\n        if [ \"$(ask_bool 'Setup as a router?' $router_default)\" = \"true\" ]; then\n            add_arg setup-router true\n        fi\n        ;;\n    esac\n\n    doc \"Make NextDNS CLI cache responses. This improves latency and reduces the amount\"\n    doc \"of queries sent to NextDNS.\"\n    if [ \"$(guess_host_type)\" = \"router\" ]; then\n        doc \"Note that enabling this feature will disable dnsmasq for DNS to avoid double\"\n        doc \"caching.\"\n    fi\n    if [ \"$(get_config cache-size)\" != \"0\" ]; then\n        cache_default=true\n    fi\n    if [ \"$(ask_bool 'Enable caching?' $cache_default)\" = \"true\" ]; then\n        add_arg cache-size \"10MB\"\n\n        doc \"Instant refresh will force low TTL on responses sent to clients so they rely\"\n        doc \"on CLI DNS cache. This will allow changes on your NextDNS config to be applied\"\n        doc \"on your LAN hosts without having to wait for their cache to expire.\"\n        if [ \"$(get_config max-ttl)\" = \"5s\" ]; then\n            instant_refresh_default=true\n        fi\n        if [ \"$(ask_bool 'Enable instant refresh?' $instant_refresh_default)\" = \"true\" ]; then\n            add_arg max-ttl \"5s\"\n        fi\n    fi\n\n    if [ \"$(guess_host_type)\" != \"router\" ]; then\n        doc \"Changes DNS settings of the host automatically when NextDNS is started.\"\n        doc \"If you say no here, you will have to manually configure DNS to 127.0.0.1.\"\n        add_arg_bool_ask auto-activate 'Automatically setup local host DNS?' true\n    fi\n    # shellcheck disable=SC2086\n    asroot \"$NEXTDNS_BIN\" install $args\n}\n\npost_install() {\n    println\n    println \"Congratulations! NextDNS is now installed.\"\n    println\n    println \"To upgrade/uninstall, run this command again and select the appropriate option.\"\n    println\n    println \"You can use the NextDNS command to control the daemon.\"\n    println \"Here are a few important commands to know:\"\n    println\n    println \"# Start, stop, restart the daemon:\"\n    println \"nextdns start\"\n    println \"nextdns stop\"\n    println \"nextdns restart\"\n    println\n    println \"# Configure the local host to point to NextDNS or not:\"\n    println \"nextdns activate\"\n    println \"nextdns deactivate\"\n    println\n    println \"# Explore daemon logs:\"\n    println \"nextdns log\"\n    println\n    println \"# For more commands, use:\"\n    println \"nextdns help\"\n    println\n}\n\ninstall_bin() {\n    bin_path=$NEXTDNS_BIN\n    if [ \"$1\" ]; then\n        bin_path=$1\n    fi\n    log_debug \"Installing $INSTALL_RELEASE binary for $GOOS/$GOARCH to $bin_path\"\n    case \"$INSTALL_RELEASE\" in\n    */*)\n        # Snapshot\n        branch=${INSTALL_RELEASE%/*}\n        hash=${INSTALL_RELEASE#*/}\n        url=\"https://snapshot.nextdns.io/${branch}/nextdns-${hash}_${GOOS}_${GOARCH}.tar.gz\"\n        ;;\n    *)\n        url=\"https://github.com/nextdns/nextdns/releases/download/v${INSTALL_RELEASE}/nextdns_${INSTALL_RELEASE}_${GOOS}_${GOARCH}.tar.gz\"\n        ;;\n    esac\n    log_debug \"Downloading $url\"\n    asroot mkdir -p \"$(dirname \"$bin_path\")\" &&\n        curl -sL \"$url\" | asroot sh -c \"tar Ozxf - nextdns > \\\"$bin_path\\\"\" &&\n        asroot chmod 755 \"$bin_path\"\n}\n\nupgrade_bin() {\n    tmp=$NEXTDNS_BIN.tmp\n    if install_bin \"$tmp\"; then\n        asroot \"$NEXTDNS_BIN\" uninstall\n        asroot mv \"$tmp\" \"$NEXTDNS_BIN\"\n        asroot \"$NEXTDNS_BIN\" install\n    fi\n    log_debug \"Removing spurious temporary install file\"\n    asroot rm -rf \"$tmp\"\n}\n\nuninstall_bin() {\n    asroot \"$NEXTDNS_BIN\" uninstall\n    asroot rm -f \"$NEXTDNS_BIN\"\n}\n\ninstall_rpm() {\n    asroot curl -Ls https://repo.nextdns.io/nextdns.repo -o /etc/yum.repos.d/nextdns.repo &&\n        asroot yum install -y nextdns\n}\n\nupgrade_rpm() {\n    asroot yum update -y nextdns\n}\n\nuninstall_rpm() {\n    asroot yum remove -y nextdns\n}\n\ninstall_zypper() {\n    if asroot zypper repos | grep -q nextdns >/dev/null; then\n        echo \"Repository nextdns already exists. Skipping adding repository...\"\n    else\n        asroot zypper ar -f -r https://repo.nextdns.io/nextdns.repo nextdns\n    fi\n    asroot zypper refresh && asroot zypper in -y nextdns\n}\n\nupgrade_zypper() {\n    asroot zypper up nextdns\n}\n\nuninstall_zypper() {\n    asroot zypper remove -y nextdns\n    case $(ask_bool 'Do you want to remove the repository from the repositories list?' true) in\n    true)\n        asroot zypper removerepo nextdns\n        ;;\n    esac\n}\n\ninstall_deb_keyring() {\n    # Fallback on curl, some debian based distrib don't have wget while debian\n    # doesn't have curl by default.\n    asroot mkdir -p /etc/apt/keyrings\n    ( asroot wget -qO /etc/apt/keyrings/nextdns.gpg https://repo.nextdns.io/nextdns.gpg ||\n      asroot curl -sfL https://repo.nextdns.io/nextdns.gpg -o /etc/apt/keyrings/nextdns.gpg ) &&\n        asroot chmod 0644 /etc/apt/keyrings/nextdns.gpg\n}\n\ninstall_source() {\n    if [ ! -f /etc/apt/sources.list.d/nextdns.list ]; then\n        asroot sh -c 'echo \"deb [signed-by=/etc/apt/keyrings/nextdns.gpg] https://repo.nextdns.io/deb stable main\" > /etc/apt/sources.list.d/nextdns.list' &&\n        (dpkg --compare-versions $(dpkg-query --showformat='${Version}' --show apt) ge 1.1 ||\n         asroot ln -s /etc/apt/keyrings/nextdns.gpg /etc/apt/trusted.gpg.d/.)\n    fi\n\n    if [ -f /etc/default/ubnt-dpkg-cache ]; then\n        # On UnifiOS 2, make sure the package is persisted over upgrades\n        sed -e '/^DPKG_CACHE_UBNT_PKGS+=\" nextdns\"/{:a;n;ba;q}' \\\n            -e '$aDPKG_CACHE_UBNT_PKGS+=\" nextdns\"' \\\n            -i /etc/default/ubnt-dpkg-cache\n    fi\n}\n\ninstall_deb() {\n    install_deb_keyring && install_source &&\n        (test \"$OS\" = \"debian\" && asroot apt-get -y install apt-transport-https || true) &&\n        (asroot apt-get update || true) &&\n        asroot apt-get install -y nextdns\n}\n\nupgrade_deb() {\n    install_deb_keyring && install_source &&\n        (asroot apt-get update || true) &&\n        asroot apt-get install -y nextdns\n}\n\nuninstall_deb() {\n    asroot apt-get remove -y nextdns\n}\n\ninstall_apk() {\n    repo=https://repo.nextdns.io/apk\n    asroot wget -O /etc/apk/keys/nextdns.pub https://repo.nextdns.io/nextdns.pub &&\n        (grep -v $repo /etc/apk/repositories; echo $repo) | asroot tee /etc/apk/repositories >/dev/null &&\n        asroot apk update &&\n        asroot apk add nextdns\n}\n\nupgrade_apk() {\n    asroot apk update && asroot apk upgrade nextdns\n}\n\nuninstall_apk() {\n    asroot apk del nextdns\n}\n\ninstall_arch() {\n    asroot pacman -Sy yay &&\n        yay -Sy nextdns\n}\n\nupgrade_arch() {\n    yay -Suy nextdns\n}\n\nuninstall_arch() {\n    asroot pacman -R nextdns\n}\n\ninstall_merlin_path() {\n    # Add next to Merlin's path\n    mkdir -p /tmp/opt/sbin\n    ln -sf \"$NEXTDNS_BIN\" /tmp/opt/sbin/nextdns\n}\n\ninstall_merlin() {\n    if install_bin; then\n        install_merlin_path\n    fi\n}\n\nuninstall_merlin() {\n    uninstall_bin\n    rm -f /tmp/opt/sbin/nextdns\n}\n\nupgrade_merlin() {\n    if upgrade_bin; then\n        install_merlin_path\n    fi\n}\n\ninstall_openwrt() {\n    opkg update &&\n        opkg install nextdns\n    rt=$?\n    if [ $rt -eq 0 ]; then\n        case $(ask_bool 'Install the GUI?' true) in\n        true)\n            opkg install luci-app-nextdns\n            rt=$?\n            ;;\n        esac\n    fi\n    return $rt\n}\n\nupgrade_openwrt() {\n    opkg update &&\n        opkg upgrade nextdns\n}\n\nuninstall_openwrt() {\n    opkg remove nextdns\n}\n\ninstall_ddwrt() {\n    if [ \"$(nvram get enable_jffs2)\" = \"0\" ]; then\n        log_error \"JFFS support not enabled\"\n        log_info \"To enabled JFFS:\"\n        log_info \" 1. On the router web page click on Administration.\"\n        log_info \" 2. Scroll down until you see JFFS2 Support section.\"\n        log_info \" 3. Click Enable JFFS.\"\n        log_info \" 4. Click Save.\"\n        log_info \" 5. Wait couple seconds, then click Apply.\"\n        log_info \" 6. Wait again. Go back to the Enable JFFS section, and enable Clean JFFS.\"\n        log_info \" 7. Do not click Save. Click Apply instead.\"\n        log_info \" 8. Wait till you get the web-GUI back, then disable Clean JFFS again.\"\n        log_info \" 9. Click Save.\"\n        log_info \"10. Relaunch this installer.\"\n        exit 1\n    fi\n    mkdir -p /jffs/nextdns &&\n        openssl_get https://curl.haxx.se/ca/cacert.pem | http_body > /jffs/nextdns/ca.pem &&\n        install_bin\n}\n\nupgrade_ddwrt() {\n    upgrade_bin\n}\n\nuninstall_ddwrt() {\n    uninstall_bin\n    rm -rf /jffs/nextdns\n}\n\ninstall_brew() {\n    silent_exec brew install nextdns/tap/nextdns\n}\n\nupgrade_brew() {\n    silent_exec brew upgrade nextdns/tap/nextdns\n    asroot \"$NEXTDNS_BIN\" install\n}\n\nuninstall_brew() {\n    silent_exec brew uninstall nextdns/tap/nextdns\n}\n\ninstall_freebsd() {\n    # TODO: port install\n    install_bin\n}\n\nupgrade_freebsd() {\n    # TODO: port upgrade\n    upgrade_bin\n}\n\nuninstall_freebsd() {\n    # TODO: port uninstall\n    uninstall_bin\n}\n\ninstall_pfsense() {\n    # TODO: port install + UI\n    install_bin\n}\n\nupgrade_pfsense() {\n    # TODO: port upgrade\n    upgrade_bin\n}\n\nuninstall_pfsense() {\n    # TODO: port uninstall\n    uninstall_bin\n}\n\ninstall_opnsense() {\n    # TODO: port install + UI\n    install_bin\n}\n\nupgrade_opnsense() {\n    # TODO: port upgrade\n    upgrade_bin\n}\n\nuninstall_opnsense() {\n    # TODO: port uninstall\n    uninstall_bin\n}\n\nubios_install_source() {\n    echo \"deb [signed-by=/etc/apt/keyrings/nextdns.gpg] https://repo.nextdns.io/deb stable main\" > /data/nextdns.list\n    podman exec unifi-os mv /data/nextdns.list /etc/apt/sources.list.d/nextdns.list\n    rm -f /tmp/nextdns.list\n    podman exec unifi-os apt-get install -y gnupg1 curl\n    podman exec unifi-os mkdir -p /etc/apt/keyrings/\n    podman exec unifi-os curl -sfL https://repo.nextdns.io/nextdns.gpg -o /etc/apt/keyrings/nextdns.gpg\n    podman exec unifi-os apt-get update -o Dir::Etc::sourcelist=\"sources.list.d/nextdns.list\" -o Dir::Etc::sourceparts=\"-\" -o APT::Get::List-Cleanup=\"0\" || true\n}\n\ninstall_ubios() {\n    ubios_install_source\n    podman exec unifi-os apt-get install -y nextdns\n}\n\nupgrade_ubios() {\n    ubios_install_source\n    podman exec unifi-os apt-get install --only-upgrade -y nextdns\n}\n\nuninstall_ubios() {\n    podman exec unifi-os apt-get remove -y nextdns\n}\n\ninstall_ubios_snapshot() {\n    branch=${INSTALL_RELEASE%/*}\n    hash=${INSTALL_RELEASE#*/}\n    url=\"https://snapshot.nextdns.io/${branch}/nextdns-${hash}_${GOOS}_${GOARCH}.tar.gz\"\n    podman exec unifi-os sh -c \"curl -o- $url | tar Ozxf - nextdns > /usr/bin/nextdns; /usr/bin/nextdns install\"\n}\n\nupgrade_ubios_snapshot() {\n    /data/nextdns uninstall\n    install_ubios_snapshot\n}\n\ninstall_type() {\n    if [ \"$FORCE_INSTALL_TYPE\" ]; then\n        echo \"$FORCE_INSTALL_TYPE\"; return 0\n    fi\n    case \"$INSTALL_RELEASE\" in\n    */*)\n        case $OS in\n        ubios)\n            echo \"ubios_snapshot\"; return 0\n            ;;\n        *)\n            # Snapshot mode always use binary install\n            echo \"bin\"; return 0\n            ;;\n        esac\n    esac\n    case $OS in\n    centos|fedora|rhel)\n        echo \"rpm\"\n        ;;\n    opensuse-tumbleweed|opensuse-leap|opensuse)\n        echo \"zypper\"\n        ;;\n    debian|ubuntu|elementary|raspbian|linuxmint|pop|neon|sparky|Deepin)\n        echo \"deb\"\n        ;;\n    alpine)\n        echo \"apk\"\n        ;;\n    arch|manjaro|steamos)\n        #echo \"arch\" # TODO: fix AUR install\n        echo \"bin\"\n        ;;\n    openwrt)\n        # shellcheck disable=SC1091\n        . /etc/os-release\n        major=$(echo \"$VERSION_ID\" | cut -d. -f1)\n        case $major in\n            *[!0-9]*)\n                if [ \"$VERSION_ID\" = \"19.07.0-rc1\" ]; then\n                    # No opkg support before 19.07.0-rc2\n                    echo \"bin\"\n                else\n                    # Likely 'snapshot' build in this case, but still > major version 19\n                    echo \"openwrt\"\n                fi\n                ;;\n            *)\n                if [ \"$major\" -lt 19 ]; then\n                    # No opkg support before 19.07.0-rc2\n                    echo \"bin\"\n                else\n                    echo \"openwrt\"\n                fi\n                ;;\n        esac\n        ;;\n    asuswrt-merlin)\n        echo \"merlin\"\n        ;;\n    edgeos|synology|clear-linux-os|solus|openbsd|netbsd|overthebox|vyos)\n        echo \"bin\"\n        ;;\n    ddwrt)\n        echo \"ddwrt\"\n        ;;\n    darwin)\n        if [ -x /usr/local/bin/brew ] || [ -x /opt/homebrew/bin/brew ]; then\n            echo \"brew\"\n        else\n            log_debug \"Homebrew not installed, fallback on binary install\"\n            echo \"bin\"\n        fi\n        ;;\n    freebsd)\n        echo \"freebsd\"\n        ;;\n    pfsense)\n        echo \"pfsense\"\n        ;;\n    opnsense)\n        echo \"opnsense\"\n        ;;\n    ubios)\n        echo \"ubios\"\n        ;;\n    gentoo)\n        echo \"bin\"\n        ;;\n    void)\n        # TODO: pkg for xbps\n        echo \"bin\"\n        ;;\n    *)\n        log_error \"Unsupported installation for $(detect_os)\"\n        return 1\n        ;;\n    esac\n}\n\nget_config() {\n    \"$NEXTDNS_BIN\" config | grep -E \"^$1 \" | cut -d' ' -f 2\n}\n\nget_config_bool() {\n    val=$(get_config \"$1\")\n    case $val in\n        true|false)\n            echo \"$val\"\n            ;;\n    esac\n    echo \"$2\"\n}\n\nget_profile_id() {\n    log_debug \"Get profile ID\"\n    if [ \"$CONFIG_ID\" ]; then\n        # backward compat\n        PROFILE_ID=\"$CONFIG_ID\"\n    fi\n    while [ -z \"$PROFILE_ID\" ]; do\n        default=\n        prev_id=$(get_config profile)\n        if [ -z \"$prev_id\" ]; then\n            # backward compat\n            prev_id=$(get_config config)\n        fi\n        if [ \"$prev_id\" ]; then\n            log_debug \"Previous profile ID: $prev_id\"\n            default=\" (default=$prev_id)\"\n        fi\n        print \"NextDNS Profile ID%s: \" \"$default\"\n        read -r id\n        if [ -z \"$id\" ]; then\n            id=$prev_id\n        fi\n        if echo \"$id\" | grep -qE '^[0-9a-f]{6}$'; then\n            PROFILE_ID=$id\n            break\n        else\n            log_error \"Invalid profile ID.\"\n            println\n            println \"ID format is 6 alphanumerical lowercase characters (example: 123abc).\"\n            println \"Your ID can be found on the Setup tab of https://my.nextdns.io.\"\n            println\n        fi\n    done\n    echo \"$PROFILE_ID\"\n}\n\nlog_debug() {\n    if [ \"$DEBUG\" = \"1\" ]; then\n        printf \"\\033[30;1mDEBUG: %s\\033[0m\\n\" \"$*\" >&2\n    fi\n}\n\nlog_info() {\n    printf \"INFO: %s\\n\" \"$*\" >&2\n}\n\nlog_warn() {\n    printf \"\\033[33mWARN: %s\\033[0m\\n\" \"$*\" >&2\n}\n\nlog_error() {\n    printf \"\\033[31mERROR: %s\\033[0m\\n\" \"$*\" >&2\n}\n\nprint() {\n    format=$1\n    if [ $# -gt 0 ]; then\n        shift\n    fi\n    # shellcheck disable=SC2059\n    printf \"$format\" \"$@\" >&2\n}\n\nprintln() {\n    format=$1\n    if [ $# -gt 0 ]; then\n        shift\n    fi\n    # shellcheck disable=SC2059\n    printf \"$format\\n\" \"$@\" >&2\n}\n\ndoc() {\n    # shellcheck disable=SC2059\n    printf \"\\033[30;1m%s\\033[0m\\n\" \"$*\" >&2\n}\n\nmenu() {\n    while true; do\n        n=0\n        default=\n        for item in \"$@\"; do\n            case $((n%3)) in\n            0)\n                key=$item\n                if [ -z \"$default\" ]; then\n                    default=$key\n                fi\n                ;;\n            1)\n                echo \"$key) $item\"\n                ;;\n            esac\n            n=$((n+1))\n        done\n        print \"Choice (default=%s): \" \"$default\"\n        read -r choice\n        if [ -z \"$choice\" ]; then\n            choice=$default\n        fi\n        n=0\n        for item in \"$@\"; do\n            case $((n%3)) in\n            0)\n                key=$item\n                ;;\n            2)\n                if [ \"$key\" = \"$choice\" ]; then\n                    if ! \"$item\"; then\n                        log_error \"$item: exit $?\"\n                    fi\n                    break 2\n                fi\n                ;;\n            esac\n            n=$((n+1))\n        done\n        echo \"Invalid choice\"\n    done\n}\n\nask_bool() {\n    msg=$1\n    default=$2\n    case $default in\n    true)\n        msg=\"$msg [Y|n]: \"\n        ;;\n    false)\n        msg=\"$msg [y|N]: \"\n        ;;\n    *)\n        msg=\"$msg (y/n): \"\n    esac\n    while true; do\n        print \"%s\" \"$msg\"\n        read -r answer\n        if [ -z \"$answer\" ]; then\n            answer=$default\n        fi\n        case $answer in\n        y|Y|yes|YES|true)\n            echo \"true\"\n            return 0\n            ;;\n        n|N|no|NO|false)\n            echo \"false\"\n            return 0\n            ;;\n        *)\n            echo \"Invalid input, use yes or no\"\n            ;;\n        esac\n    done\n}\n\ndetect_endiannes() {\n    if ! hexdump /dev/null 2>/dev/null; then\n        # Some firmwares do not contain hexdump, for those, try to detect endianness\n        # differently.\n        case $(cat /proc/cpuinfo) in\n        *BCM5300*)\n            # RT-AC66U does not support Merlin version over 380.70 which\n            # lacks hexdump command.\n            echo \"le\"\n            ;;\n        *)\n            log_error \"Cannot determine endianness\"\n            return 1\n            ;;\n        esac\n        return 0\n    fi\n    case $(hexdump -s 5 -n 1 -e '\"%x\"' /bin/sh | head -c1) in\n    1)\n        echo \"le\"\n        ;;\n    2)\n        echo \"\"\n        ;;\n    esac\n}\n\ndetect_goarch() {\n    if [ \"$FORCE_GOARCH\" ]; then\n        echo \"$FORCE_GOARCH\"; return 0\n    fi\n    case $(uname -m) in\n    x86_64|amd64)\n        echo \"amd64\"\n        ;;\n    i386|i686)\n        echo \"386\"\n        ;;\n    arm)\n        # FreeBSD does not include arm version\n        case \"$(sysctl -b hw.model 2>/dev/null)\" in\n        *A9*)\n            echo \"armv7\"\n            ;;\n        *)\n            # Unknown version, fallback to the lowest\n            echo \"armv5\"\n            ;;\n        esac\n        ;;\n    armv5*)\n        echo \"armv5\"\n        ;;\n    armv6*|armv7*)\n        if grep -q vfp /proc/cpuinfo 2>/dev/null; then\n            echo \"armv$(uname -m | sed -e 's/[[:alpha:]]//g')\"\n        else\n            # Soft floating point\n            echo \"armv5\"\n        fi\n        ;;\n    aarch64)\n        case \"$(uname -o 2>/dev/null)\" in\n        ASUSWRT-Merlin*)\n            # XXX when using arm64 build on ASUS AC66U and ACG86U, we get Go error:\n            # \"out of memory allocating heap arena metadata\".\n            echo \"armv7\"\n            ;;\n        *)\n            echo \"arm64\"\n            ;;\n        esac\n        ;;\n    armv8*|arm64)\n        echo \"arm64\"\n        ;;\n    mips*)\n        # TODO: detect hardfloat\n        echo \"$(uname -m)$(detect_endiannes)_softfloat\"\n        ;;\n    *)\n        log_error \"Unsupported GOARCH: $(uname -m)\"\n        return 1\n        ;;\n    esac\n}\n\ndetect_goos() {\n    if [ \"$FORCE_GOOS\" ]; then\n        echo \"$FORCE_GOOS\"; return 0\n    fi\n    case $(uname -s) in\n    Linux)\n        echo \"linux\"\n        ;;\n    Darwin)\n        echo \"darwin\"\n        ;;\n    FreeBSD)\n        echo \"freebsd\"\n        ;;\n    NetBSD)\n        echo \"netbsd\"\n        ;;\n    OpenBSD)\n        echo \"openbsd\"\n        ;;\n    *)\n        log_error \"Unsupported GOOS: $(uname -s)\"\n        return 1\n    esac\n}\n\ndetect_os() {\n    if [ \"$FORCE_OS\" ]; then\n        echo \"$FORCE_OS\"; return 0\n    fi\n    case $(uname -s) in\n    Linux)\n        case $(uname -o) in\n        GNU/Linux|Linux)\n            if grep -q -e '^EdgeRouter' -e '^UniFiSecurityGateway' /etc/version 2> /dev/null; then\n                echo \"edgeos\"; return 0\n            fi\n            if uname -u 2>/dev/null | grep -q '^synology'; then\n                echo \"synology\"; return 0\n            fi\n            # shellcheck disable=SC1091\n            dist=$(. /etc/os-release; echo \"$ID\")\n            case $dist in\n            ubios)\n                if [ -z \"$(command -v podman)\" ]; then\n                    log_error \"This version of UnifiOS is not supported. Make sure you run version 1.7.0 or above.\"\n                    return 1\n                fi\n                echo \"$dist\"; return 0\n                ;;\n            debian|ubuntu|elementary|raspbian|centos|fedora|rhel|arch|manjaro|openwrt|clear-linux-os|linuxmint|opensuse-tumbleweed|opensuse-leap|opensuse|solus|pop|neon|overthebox|sparky|vyos|void|alpine|Deepin|gentoo|steamos)\n                echo \"$dist\"; return 0\n                ;;\n            esac\n            # shellcheck disable=SC1091\n            for dist in $(. /etc/os-release; echo \"$ID_LIKE\"); do\n                case $dist in\n                debian|ubuntu|rhel|fedora|openwrt|arch)\n                    log_debug \"Using ID_LIKE\"\n                    echo \"$dist\"; return 0\n                    ;;\n                esac\n            done\n            ;;\n        ASUSWRT-Merlin*)\n            echo \"asuswrt-merlin\"; return 0\n            ;;\n        DD-WRT)\n            echo \"ddwrt\"; return 0\n        esac\n        ;;\n    Darwin)\n        echo \"darwin\"; return 0\n        ;;\n    FreeBSD)\n        if [ -f /etc/platform ]; then\n            case $(cat /etc/platform) in\n            pfSense)\n                echo \"pfsense\"; return 0\n                ;;\n            esac\n        fi\n        if [ -x /usr/local/sbin/opnsense-version ]; then\n            case $(/usr/local/sbin/opnsense-version -N) in\n            OPNsense)\n                echo \"opnsense\"; return 0\n                ;;\n            esac\n        fi\n        echo \"freebsd\"; return 0\n        ;;\n    NetBSD)\n        echo \"netbsd\"; return 0\n        ;;\n    OpenBSD)\n        echo \"openbsd\"; return 0\n        ;;\n    *)\n    esac\n    log_error \"Unsupported OS: $(uname -o) $(grep ID \"/etc/os-release\" 2>/dev/null | xargs)\"\n    return 1\n}\n\nguess_host_type() {\n    if [ -d /data/unifi ]; then\n        # Special case when installer is run from inside the ubios podman\n        echo \"router\"; return 0\n    fi\n\n    case $OS in\n    pfsense|opnsense|openwrt|asuswrt-merlin|edgeos|ddwrt|synology|overthebox|ubios|vyos)\n        echo \"router\"\n        ;;\n    darwin|steamos)\n        echo \"workstation\"\n        ;;\n    *)\n        echo \"unsure\"\n        ;;\n    esac\n}\n\nasroot() {\n    # Some platform (Merlin) do not have the \"id\" command and $USER report a non root username with uid 0.\n    if [ \"$(grep '^Uid:' /proc/$$/status 2>/dev/null|cut -f2)\" = \"0\" ] || [ \"$USER\" = \"root\" ] || [ \"$(id -u 2>/dev/null)\" = \"0\" ]; then\n        \"$@\"\n    elif [ \"$(command -v sudo 2>/dev/null)\" ]; then\n        sudo \"$@\"\n    else\n        echo \"Root required\"\n        su -m root -c \"$*\"\n    fi\n}\n\nsilent_exec() {\n    if [ \"$DEBUG\" = 1 ]; then\n        \"$@\"\n    else\n        if ! out=$(\"$@\" 2>&1); then\n            rt=$?\n            println \"\\033[30;1m%s\\033[0m\" \"$out\"\n            return $rt\n        fi\n    fi\n}\n\nbin_location() {\n    case $OS in\n    centos|fedora|rhel|debian|ubuntu|elementary|raspbian|arch|manjaro|clear-linux-os|linuxmint|opensuse-tumbleweed|opensuse-leap|opensuse|solus|pop|neon|sparky|alpine|Deepin|gentoo)\n        echo \"/usr/bin/nextdns\"\n        ;;\n    openwrt|overthebox)\n        echo \"/usr/sbin/nextdns\"\n        ;;\n    synology)\n        echo \"/usr/local/bin/nextdns\"\n    ;;\n    darwin)\n        echo \"$(brew --prefix 2>/dev/null || echo /usr/local)/bin/nextdns\"\n        ;;\n    asuswrt-merlin|ddwrt)\n        echo \"/jffs/nextdns/nextdns\"\n        ;;\n    freebsd|pfsense|opnsense|netbsd|openbsd)\n        echo \"/usr/local/sbin/nextdns\"\n        ;;\n    edgeos|vyos)\n        echo \"/config/nextdns/nextdns\"\n        ;;\n    ubios)\n        echo \"/data/nextdns\"\n        ;;\n    steamos)\n        echo \"$HOME/.local/bin/nextdns\"\n        ;;\n    *)\n        log_error \"Unknown bin location for $OS\"\n        ;;\n    esac\n}\n\nis_version_current() {\n    case \"$INSTALL_RELEASE\" in\n    */*)\n        # Snapshot\n        hash=${INSTALL_RELEASE#*/}\n        test \"0.0.0-$hash\" = \"$CURRENT_RELEASE\"\n        ;;\n    *)\n        test \"$INSTALL_RELEASE\" = \"$CURRENT_RELEASE\"\n        ;;\n    esac\n}\n\nget_current_release() {\n    if [ -x \"$NEXTDNS_BIN\" ]; then\n        $NEXTDNS_BIN version|cut -d' ' -f 3\n    fi\n}\n\nget_release() {\n    if [ \"$NEXTDNS_VERSION\" ]; then\n        echo \"$NEXTDNS_VERSION\"\n    else\n        for cmd in curl wget openssl true; do\n            # command is the \"right\" way but may be compiled out of busybox shell\n            ! command -v $cmd > /dev/null 2>&1 || break\n            ! which $cmd > /dev/null 2>&1 || break\n        done\n        case \"$cmd\" in\n        curl) cmd=\"curl -A curl -s\" ;;\n        wget) cmd=\"wget -qO- -U curl\" ;;\n        openssl) cmd=\"openssl_get\" ;;\n        *)\n            log_error \"Cannot retrieve latest version\"\n            return\n            ;;\n        esac\n        v=$($cmd \"https://api.github.com/repos/nextdns/nextdns/releases/latest\" | \\\n            grep '\"tag_name\":' | esed 's/.*\"([^\"]+)\".*/\\1/' | sed -e 's/^v//')\n        if [ -z \"$v\" ]; then\n            log_error \"Cannot get latest version: $out\"\n        fi\n        echo \"$v\"\n    fi\n}\n\nesed() {\n    if (echo | sed -E '' >/dev/null 2>&1); then\n        sed -E \"$@\"\n    else\n        sed -r \"$@\"\n    fi\n}\n\nhttp_redirect() {\n    while read -r header; do\n        case $header in\n            Location:*)\n                echo \"${header#Location: }\"\n                return\n            ;;\n        esac\n        if [ \"$header\" = \"\" ]; then\n            break\n        fi\n    done\n    cat > /dev/null\n    return 1\n}\n\nhttp_body() {\n    sed -n '/^\\r/,$p' | sed 1d\n}\n\nopenssl_get() {\n    host=${1#https://*} # https://dom.com/path -> dom.com/path\n    path=/${host#*/}    # dom.com/path -> /path\n    host=${host%$path}  # dom.com/path -> dom.com\n    printf \"GET %s HTTP/1.0\\nHost: %s\\nUser-Agent: curl\\n\\n\" \"$path\" \"$host\" |\n        openssl s_client -quiet -connect \"$host:443\" 2>/dev/null\n}\n\numask 0022\nmain\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 1.806640625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"runtime\"\n)\n\nvar (\n\tversion  = \"dev\"\n\tplatform = runtime.GOOS\n)\n\ntype command struct {\n\tname string\n\trun  func(args []string) error\n\tdesc string\n}\n\nvar commands = []command{\n\t{\"install\", svc, \"install service init on the system\"},\n\t{\"uninstall\", svc, \"uninstall service init from the system\"},\n\t{\"start\", svc, \"start installed service\"},\n\t{\"stop\", svc, \"stop installed service\"},\n\t{\"restart\", svc, \"restart installed service\"},\n\t{\"status\", svc, \"return service status\"},\n\t{\"log\", svc, \"show service logs\"},\n\n\t{\"upgrade\", upgrade, \"upgrade the cli to the latest version\"},\n\n\t{\"run\", run, \"run the daemon\"},\n\n\t{\"config\", cfg, \"manage configuration\"},\n\n\t{\"activate\", activation, \"setup the system to use NextDNS as a resolver\"},\n\t{\"deactivate\", activation, \"restore the resolver configuration\"},\n\n\t{\"discovered\", ctlCmd, \"display discovered clients\"},\n\t{\"cache-stats\", ctlCmd, \"display cache statistics\"},\n\t{\"cache-keys\", ctlCmd, \"dump the list of cached entries\"},\n\t{\"trace\", ctlCmd, \"display a stack trace dump\"},\n\t{\"arp\", ctlCmd, \"dump the ARP table\"},\n\t{\"ndp\", ctlCmd, \"dump the NDP table\"},\n\n\t{\"version\", showVersion, \"show current version\"},\n}\n\nfunc showCommands() {\n\tfmt.Println(\"Usage: nextdns <command> [arguments]\")\n\tfmt.Println(\"\")\n\tfmt.Println(\"The commands are:\")\n\tfmt.Println(\"\")\n\tfor _, cmd := range commands {\n\t\tfmt.Printf(\"    %-15s %s\\n\", cmd.name, cmd.desc)\n\t}\n\tfmt.Println(\"\")\n\tos.Exit(1)\n}\n\nfunc showVersion(args []string) error {\n\tfmt.Printf(\"nextdns version %s\\n\", version)\n\treturn nil\n}\n\nfunc main() {\n\tif len(os.Args) < 2 {\n\t\tshowCommands()\n\t}\n\tcmd := os.Args[1]\n\tfor _, c := range commands {\n\t\tif c.name != cmd {\n\t\t\tcontinue\n\t\t}\n\t\tif err := c.run(os.Args[1:]); err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Error: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\treturn\n\t}\n\t// Command not found\n\tshowCommands()\n}\n"
        },
        {
          "name": "ndp",
          "type": "tree",
          "content": null
        },
        {
          "name": "netstatus",
          "type": "tree",
          "content": null
        },
        {
          "name": "proxy",
          "type": "tree",
          "content": null
        },
        {
          "name": "resolver",
          "type": "tree",
          "content": null
        },
        {
          "name": "router",
          "type": "tree",
          "content": null
        },
        {
          "name": "run.go",
          "type": "blob",
          "size": 17.21484375,
          "content": "package main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"github.com/cespare/xxhash\"\n\t\"github.com/denisbrodbeck/machineid\"\n\tlru \"github.com/hashicorp/golang-lru\"\n\n\t\"github.com/nextdns/nextdns/arp\"\n\t\"github.com/nextdns/nextdns/config\"\n\t\"github.com/nextdns/nextdns/ctl\"\n\t\"github.com/nextdns/nextdns/discovery\"\n\t\"github.com/nextdns/nextdns/host\"\n\t\"github.com/nextdns/nextdns/host/service\"\n\t\"github.com/nextdns/nextdns/hosts\"\n\t\"github.com/nextdns/nextdns/ndp\"\n\t\"github.com/nextdns/nextdns/netstatus\"\n\t\"github.com/nextdns/nextdns/proxy\"\n\t\"github.com/nextdns/nextdns/resolver\"\n\t\"github.com/nextdns/nextdns/resolver/endpoint\"\n\t\"github.com/nextdns/nextdns/resolver/query\"\n\t\"github.com/nextdns/nextdns/router\"\n)\n\ntype proxySvc struct {\n\tproxy.Proxy\n\tlog      host.Logger\n\tresolver *resolver.DNS\n\tstopFunc func()\n\tstopped  chan struct{}\n\n\t// OnInit is called every time the proxy is started or restarted. The ctx is\n\t// cancelled on stop or restart.\n\tOnInit []func(ctx context.Context)\n\n\t// OnStarted is called once the daemon is fully started.\n\tOnStarted []func()\n\n\t// OnStopped is called once the daemon is full stopped.\n\tOnStopped []func()\n}\n\nfunc (p *proxySvc) Start() (err error) {\n\tp.log.Infof(\"Starting NextDNS %s/%s on %s\", version, platform, strings.Join(p.Addrs, \", \"))\n\tbackoff := 100 * time.Millisecond\n\tfor {\n\t\tif err = p.start(); err != nil {\n\t\t\tif isErrNetUnreachable(err) {\n\t\t\t\tp.log.Infof(\"Network not yet ready, waiting\")\n\t\t\t\ttime.Sleep(backoff)\n\t\t\t\tbackoff <<= 1\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tbreak\n\t}\n\tfor _, f := range p.OnStarted {\n\t\tf()\n\t}\n\treturn nil\n}\n\nfunc isErrNetUnreachable(err error) bool {\n\tif strings.Contains(err.Error(), \"network is unreachable\") {\n\t\treturn true\n\t}\n\tfor ; err != nil; err = errors.Unwrap(err) {\n\t\tif sysErr, ok := err.(*os.SyscallError); ok {\n\t\t\treturn sysErr.Err == syscall.ENETUNREACH\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *proxySvc) start() (err error) {\n\terrC := make(chan error)\n\tvar ctx context.Context\n\tgo func() {\n\t\tctx, p.stopFunc = context.WithCancel(context.Background())\n\t\tdefer p.stopFunc()\n\t\tp.stopped = make(chan struct{})\n\t\tdefer close(p.stopped)\n\t\tfor _, f := range p.OnInit {\n\t\t\tgo f(ctx)\n\t\t}\n\t\tif err = p.ListenAndServe(ctx); err != nil && !errors.Is(err, context.Canceled) {\n\t\t\tselect {\n\t\t\tcase errC <- err:\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tselect {\n\tcase err := <-errC:\n\t\treturn err\n\tcase <-time.After(5 * time.Second):\n\t}\n\treturn nil\n}\n\nfunc (p *proxySvc) Restart() error {\n\tp.log.Infof(\"Restarting NextDNS %s/%s on %s\", version, platform, strings.Join(p.Addrs, \", \"))\n\t_ = p.stop()\n\treturn p.start()\n}\n\nfunc (p *proxySvc) Stop() error {\n\tp.log.Infof(\"Stopping NextDNS %s/%s\", version, platform)\n\tif p.stop() {\n\t\tfor _, f := range p.OnStopped {\n\t\t\tf()\n\t\t}\n\t}\n\tp.log.Infof(\"NextDNS %s/%s stopped\", version, platform)\n\treturn nil\n}\n\nfunc (p *proxySvc) stop() bool {\n\tif p.stopFunc == nil {\n\t\treturn false\n\t}\n\tp.stopFunc()\n\tp.stopFunc = nil\n\t<-p.stopped\n\treturn true\n}\n\nfunc (p *proxySvc) Log(msg string) {\n\tp.log.Info(msg)\n}\n\nfunc run(args []string) error {\n\tcmd := args[0]\n\targs = args[1:]\n\tvar c config.Config\n\t// When running interactive, ignore config file unless explicitly specified.\n\tuseStorage := service.CurrentRunMode() == service.RunModeService\n\tc.Parse(\"nextdns \"+cmd, args, useStorage)\n\n\tlog, err := host.NewLogger(\"nextdns\")\n\tif err != nil {\n\t\tlog = host.NewConsoleLogger(\"nextdns\")\n\t\tlog.Warningf(\"Service logger error (switching to console): %v\", err)\n\t}\n\tp := &proxySvc{\n\t\tlog: log,\n\t}\n\n\tctl := ctl.Server{\n\t\tAddr: c.Control,\n\t\tOnConnect: func(c net.Conn) {\n\t\t\tlog.Infof(\"Control client connected: %v\", c)\n\t\t},\n\t\tOnDisconnect: func(c net.Conn) {\n\t\t\tlog.Infof(\"Control client disconnected: %v\", c)\n\t\t},\n\t\tOnEvent: func(c net.Conn, e ctl.Event) {\n\t\t\tlog.Infof(\"Control client sent event: %v: %s(%v)\", c, e.Name, e.Data)\n\t\t},\n\t}\n\tif err := ctl.Start(); err != nil {\n\t\tlog.Errorf(\"Cannot start control server: %v\", err)\n\t}\n\tdefer func() { _ = ctl.Stop() }()\n\tctl.Command(\"trace\", func(data interface{}) interface{} {\n\t\tbuf := make([]byte, 100*1024)\n\t\tn := runtime.Stack(buf, true)\n\t\treturn string(buf[:n])\n\t})\n\tctl.Command(\"ndp\", func(data interface{}) interface{} {\n\t\tt, err := ndp.Get()\n\t\tif err != nil {\n\t\t\treturn err.Error()\n\t\t}\n\t\tvar sb strings.Builder\n\t\tfor _, i := range t {\n\t\t\tfmt.Fprintf(&sb, \"%s %s\\n\", i.IP, i.MAC)\n\t\t}\n\t\treturn sb.String()\n\t})\n\tctl.Command(\"arp\", func(data interface{}) interface{} {\n\t\tt, err := arp.Get()\n\t\tif err != nil {\n\t\t\treturn err.Error()\n\t\t}\n\t\tvar sb strings.Builder\n\t\tfor _, i := range t {\n\t\t\tfmt.Fprintf(&sb, \"%s %s\\n\", i.IP, i.MAC)\n\t\t}\n\t\treturn sb.String()\n\t})\n\n\tif c.SetupRouter {\n\t\tr := router.New()\n\t\tif err := r.Configure(&c); err != nil {\n\t\t\tlog.Errorf(\"Configuring %s router: %v\", r, err)\n\t\t}\n\t\tp.OnStarted = append(p.OnStarted, func() {\n\t\t\tlog.Infof(\"Setting up %s router\", r)\n\t\t\tif err := r.Setup(); err != nil {\n\t\t\t\tlog.Errorf(\"Setting up %s router: %v\", r, err)\n\t\t\t}\n\t\t})\n\t\tp.OnStopped = append(p.OnStopped, func() {\n\t\t\tlog.Infof(\"Restore %s router settings\", r)\n\t\t\tif err := r.Restore(); err != nil {\n\t\t\t\tlog.Errorf(\"Restore %s router settings: %v\", r, err)\n\t\t\t}\n\t\t})\n\t}\n\n\tif c.AutoActivate {\n\t\tp.OnStarted = append(p.OnStarted, func() {\n\t\t\tlog.Info(\"Activating\")\n\t\t\tif err := activate(c); err != nil {\n\t\t\t\tlog.Errorf(\"Activate: %v\", err)\n\t\t\t}\n\t\t})\n\t\tp.OnStopped = append(p.OnStopped, func() {\n\t\t\tlog.Info(\"Deactivating\")\n\t\t\tif err := deactivate(); err != nil {\n\t\t\t\tlog.Errorf(\"Deactivate: %v\", err)\n\t\t\t}\n\t\t})\n\t}\n\n\tstartup := time.Now()\n\tp.resolver = &resolver.DNS{\n\t\tDOH: resolver.DOH{\n\t\t\tExtraHeaders: http.Header{\n\t\t\t\t\"User-Agent\": []string{fmt.Sprintf(\"nextdns-cli/%s (%s; %s; %s)\", version, platform, runtime.GOARCH, host.InitType())},\n\t\t\t},\n\t\t},\n\t\tManager: nextdnsEndpointManager(log, c.Debug, func() bool {\n\t\t\t// Backward compat: the captive portal is now somewhat always enabled,\n\t\t\t// but for those who enabled it in the past, disable the delay after which\n\t\t\t// the fallback is disabled.\n\t\t\tif c.DetectCaptivePortals {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\t// Allow fallback to plain DNS for 10 minute after startup or after\n\t\t\t// a change of network configuration.\n\t\t\treturn time.Since(startup) < 10*time.Minute\n\t\t}),\n\t}\n\n\tcacheSize, err := config.ParseBytes(c.CacheSize)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"%s: cannot parse cache size: %v\", c.CacheSize, err)\n\t}\n\tif cacheSize > 0 {\n\t\tcc, err := lru.NewARC(int(cacheSize))\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Cache init failed: %v\", err)\n\t\t} else {\n\t\t\tmaxAge := uint32(c.CacheMaxAge / time.Second)\n\t\t\tp.resolver.DNS53.Cache = cc\n\t\t\tp.resolver.DNS53.CacheMaxAge = maxAge\n\t\t\tp.resolver.DOH.Cache = cc\n\t\t\tp.resolver.DOH.CacheMaxAge = maxAge\n\t\t\tctl.Command(\"cache-keys\", func(data interface{}) interface{} {\n\t\t\t\tkeys := []string{}\n\t\t\t\tfor _, k := range cc.Keys() {\n\t\t\t\t\tkeys = append(keys, fmt.Sprint(k))\n\t\t\t\t}\n\t\t\t\treturn keys\n\t\t\t})\n\t\t\tctl.Command(\"cache-stats\", func(data interface{}) interface{} {\n\t\t\t\treturn p.resolver.CacheStats()\n\t\t\t})\n\t\t}\n\t}\n\tmaxTTL := uint32(c.MaxTTL / time.Second)\n\tp.resolver.DNS53.MaxTTL = maxTTL\n\tp.resolver.DOH.MaxTTL = maxTTL\n\n\tif len(c.Profile) == 0 || (len(c.Profile) == 1 && c.Profile.Get(nil, nil, nil) != \"\") {\n\t\t// Optimize for no dynamic configuration.\n\t\tprofile := c.Profile.Get(nil, nil, nil)\n\t\tprofileURL := \"https://dns.nextdns.io/\" + profile\n\t\tp.resolver.DOH.GetProfileURL = func(q query.Query) (url, profile string) {\n\t\t\treturn profileURL, profile\n\t\t}\n\t} else {\n\t\tp.resolver.DOH.GetProfileURL = func(q query.Query) (url, profile string) {\n\t\t\tprofile = c.Profile.Get(q.PeerIP, q.LocalIP, q.MAC)\n\t\t\treturn \"https://dns.nextdns.io/\" + profile, profile\n\t\t}\n\t}\n\n\tp.Proxy = proxy.Proxy{\n\t\tAddrs:               c.Listens,\n\t\tUpstream:            p.resolver,\n\t\tBogusPriv:           c.BogusPriv,\n\t\tTimeout:             c.Timeout,\n\t\tMaxInflightRequests: c.MaxInflightRequests,\n\t}\n\n\tdiscoverHosts := &discovery.Hosts{OnError: func(err error) { log.Errorf(\"hosts: %v\", err) }}\n\tif c.UseHosts {\n\t\tp.Proxy.LocalResolver = discovery.Resolver{discoverHosts}\n\t}\n\tlocalhostMode := isLocalhostMode(&c)\n\tif c.ReportClientInfo {\n\t\t// Only enable discovery if configured to listen to requests outside\n\t\t// the local host or if setup router is on.\n\t\tenableDiscovery := !localhostMode\n\t\tvar r discovery.Resolver\n\t\tif enableDiscovery {\n\t\t\tdiscoverDHCP := &discovery.DHCP{OnError: func(err error) { log.Errorf(\"dhcp: %v\", err) }}\n\t\t\tdiscoverDNS := &discovery.DNS{Upstream: c.DiscoveryDNS}\n\t\t\tvar discoverMDNS discovery.Source = discovery.Dummy{}\n\t\t\tif c.MDNS != \"disabled\" {\n\t\t\t\tmdns := &discovery.MDNS{OnError: func(err error) { log.Errorf(\"mdns: %v\", err) }}\n\t\t\t\tdiscoverMDNS = mdns\n\t\t\t\tp.OnInit = append(p.OnInit, func(ctx context.Context) {\n\t\t\t\t\tlog.Info(\"Starting mDNS discovery\")\n\t\t\t\t\tif err := mdns.Start(ctx, c.MDNS); err != nil {\n\t\t\t\t\t\tlog.Errorf(\"Cannot start mDNS: %v\", err)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\tdiscoveryResolver := discovery.Resolver{discoverMDNS, discoverDHCP}\n\t\t\tif c.DiscoveryDNS != \"\" {\n\t\t\t\t// Only include discovery DNS as discovery resolver if\n\t\t\t\t// explicitly specified as auto-discovered DNS discovery can\n\t\t\t\t// create loops.\n\t\t\t\tdiscoveryResolver = append(discovery.Resolver{discoverDNS}, discoveryResolver...)\n\t\t\t}\n\t\t\tp.Proxy.DiscoveryResolver = discoveryResolver\n\t\t\tr = discovery.Resolver{discoverHosts, &discovery.Merlin{}, &discovery.Ubios{}, discoverMDNS, discoverDHCP, discoverDNS}\n\t\t\tctl.Command(\"discovered\", func(data interface{}) interface{} {\n\t\t\t\td := map[string]map[string][]string{}\n\t\t\t\tr.Visit(func(source, name string, addrs []string) {\n\t\t\t\t\tif d[source] == nil {\n\t\t\t\t\t\td[source] = map[string][]string{}\n\t\t\t\t\t}\n\t\t\t\t\td[source][name] = addrs\n\t\t\t\t})\n\t\t\t\treturn d\n\t\t\t})\n\t\t}\n\t\tsetupClientReporting(p, &c.Profile, r)\n\t}\n\tif p.Proxy.DiscoveryResolver == nil && c.DiscoveryDNS != \"\" {\n\t\tp.Proxy.DiscoveryResolver = &discovery.DNS{Upstream: c.DiscoveryDNS}\n\t}\n\n\tif len(c.Forwarders) > 0 {\n\t\t// Append default doh server at the end of the forwarder list as a catch all.\n\t\tfwd := make(config.Forwarders, 0, len(c.Forwarders)+1)\n\t\tfwd = append(fwd, c.Forwarders...)\n\t\tfwd = append(fwd, config.Resolver{Resolver: p.resolver})\n\t\tp.Upstream = &fwd\n\t}\n\n\tp.QueryLog = func(q proxy.QueryInfo) {\n\t\tif !c.LogQueries && q.Error == nil {\n\t\t\treturn\n\t\t}\n\t\tvar errStr string\n\t\tdur := \"cached\"\n\t\tif q.Error != nil {\n\t\t\terrStr = \": \" + q.Error.Error()\n\t\t\tif q.FromCache {\n\t\t\t\tdur = \"cache fallback\"\n\t\t\t}\n\t\t}\n\t\tif !q.FromCache {\n\t\t\tdur = fmt.Sprintf(\"%dms\", q.Duration/time.Millisecond)\n\t\t}\n\t\tprofile := q.Profile\n\t\tif profile == \"\" {\n\t\t\tprofile = \"none\"\n\t\t}\n\t\tlog.Infof(\"Query %s %s %s %s %s (qry=%d/res=%d) %s %s%s\",\n\t\t\tq.PeerIP.String(),\n\t\t\tq.Protocol,\n\t\t\tq.Type,\n\t\t\tq.Name,\n\t\t\tprofile,\n\t\t\tq.QuerySize,\n\t\t\tq.ResponseSize,\n\t\t\tdur,\n\t\t\tq.UpstreamTransport,\n\t\t\terrStr)\n\t}\n\tp.InfoLog = func(msg string) {\n\t\tlog.Info(msg)\n\t}\n\tp.ErrorLog = func(err error) {\n\t\tlog.Error(err)\n\t}\n\tif localhostMode {\n\t\t// If only listening on localhost, we may be running on a laptop or\n\t\t// other sort of device that might change network from time to time.\n\t\t// When such change is detected, it better to trigger a re-negotiation\n\t\t// of the best endpoint sooner than later. We also reset the startup\n\t\t// time so plain DNS fallback happen again (useful for captive portals).\n\t\tp.OnInit = append(p.OnInit, func(ctx context.Context) {\n\t\t\tnetChange := make(chan netstatus.Change)\n\t\t\tnetstatus.Notify(netChange)\n\t\t\tfor c := range netChange {\n\t\t\t\tlog.Infof(\"Network change detected: %s\", c)\n\t\t\t\tstartup = time.Now() // reset the startup marker so DNS fallback can happen again.\n\t\t\t\tif err := p.resolver.Manager.Test(ctx); err != nil {\n\t\t\t\t\tlog.Errorf(\"Test after network change failed: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n\n\tif err = service.Run(\"nextdns\", p); err != nil {\n\t\tlog.Errorf(\"Startup failed: %v\", err)\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// isLocalhostMode returns true if listen is only listening for the local host.\nfunc isLocalhostMode(c *config.Config) bool {\n\tif c.SetupRouter {\n\t\t// The listen arg is irrelevant when in router mode.\n\t\treturn false\n\t}\n\tfor _, listen := range c.Listens {\n\t\tif host, _, err := net.SplitHostPort(listen); err == nil {\n\t\t\tswitch host {\n\t\t\tcase \"localhost\", \"127.0.0.1\", \"::1\":\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif ips := hosts.LookupHost(host); len(ips) > 0 {\n\t\t\t\tfor _, ip := range ips {\n\t\t\t\t\tif !net.ParseIP(ip).IsLoopback() {\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if !net.ParseIP(host).IsLoopback() {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n\n// nextdnsEndpointManager returns a endpoint.Manager configured to connect to\n// NextDNS using different steering techniques.\nfunc nextdnsEndpointManager(log host.Logger, debug bool, canFallback func() bool) *endpoint.Manager {\n\tm := &endpoint.Manager{\n\t\tProviders: []endpoint.Provider{\n\t\t\t// Prefer unicast routing.\n\t\t\t&endpoint.SourceHTTPSSVCProvider{\n\t\t\t\tHostname: \"dns.nextdns.io\",\n\t\t\t\tSource:   endpoint.MustNew(\"https://dns.nextdns.io#45.90.28.0,2a07:a8c0::,45.90.30.0,2a07:a8c1::\"),\n\t\t\t},\n\t\t\t// Try routing without anycast bootstrap.\n\t\t\t// TOFIX: this creates circular dependency if the /etc/resolv.conf is setup to localhost.\n\t\t\t// &endpoint.SourceHTTPSSVCProvider{\n\t\t\t// \tHostname: \"dns.nextdns.io\",\n\t\t\t// \tSource:   endpoint.MustNew(\"https://dns.nextdns.io\"),\n\t\t\t// },\n\t\t\t// Fallback on anycast.\n\t\t\tendpoint.StaticProvider([]endpoint.Endpoint{\n\t\t\t\tendpoint.MustNew(\"https://dns1.nextdns.io#45.90.28.0,2a07:a8c0::\"),\n\t\t\t\tendpoint.MustNew(\"https://dns2.nextdns.io#45.90.30.0,2a07:a8c1::\"),\n\t\t\t}),\n\t\t},\n\t\tInitEndpoint: endpoint.MustNew(\"https://dns.nextdns.io#45.90.28.0,2a07:a8c0::,45.90.30.0,2a07:a8c1::\"),\n\t\tOnError: func(e endpoint.Endpoint, err error) {\n\t\t\tlog.Warningf(\"Endpoint failed: %v: %v\", e, err)\n\t\t},\n\t\tOnProviderError: func(p endpoint.Provider, err error) {\n\t\t\tlog.Warningf(\"Endpoint provider failed: %v: %v\", p, err)\n\t\t},\n\t\tOnConnect: func(ci *endpoint.ConnectInfo) {\n\t\t\tlog.Infof(\"Connected %s (con=%dms tls=%dms, %s, %s)\",\n\t\t\t\tci.ServerAddr,\n\t\t\t\tci.ConnectTimes[ci.ServerAddr]/time.Millisecond,\n\t\t\t\tci.TLSTime/time.Millisecond,\n\t\t\t\tci.Protocol,\n\t\t\t\tci.TLSVersion)\n\t\t},\n\t\tOnChange: func(e endpoint.Endpoint) {\n\t\t\tlog.Infof(\"Switching endpoint: %s\", e)\n\t\t},\n\t}\n\t// Fallback on system DNS and set a short min test interval for when plain\n\t// DNS protocol is used so we go back on safe DoH as soon as possible. This\n\t// allows automatic handling of captive portals as well as NTP / DNS\n\t// inter-dependency on some routers, when NTP needs DNS to sync the time,\n\t// and DoH needs time properly set to establish a TLS session.\n\tm.Providers = append(m.Providers, endpoint.ProviderFunc(func(ctx context.Context) ([]endpoint.Endpoint, error) {\n\t\tif !canFallback() {\n\t\t\t// Fallback disabled.\n\t\t\treturn nil, nil\n\t\t}\n\t\tips := host.DNS()\n\t\tendpoints := make([]endpoint.Endpoint, 0, len(ips)+1)\n\t\tfor _, ip := range ips {\n\t\t\tendpoints = append(endpoints, &endpoint.DNSEndpoint{\n\t\t\t\tAddr: net.JoinHostPort(ip, \"53\"),\n\t\t\t})\n\t\t}\n\t\t// Add NextDNS anycast IP in case none of the system DNS works or we did\n\t\t// not find any.\n\t\tendpoints = append(endpoints, &endpoint.DNSEndpoint{\n\t\t\tAddr: \"45.90.28.0:53\",\n\t\t})\n\t\treturn endpoints, nil\n\t}))\n\tm.EndpointTester = func(e endpoint.Endpoint) endpoint.Tester {\n\t\tif e.Protocol() == endpoint.ProtocolDNS {\n\t\t\t// Return a tester than never fail so we are always selected as\n\t\t\t// a last resort when all other endpoints failed.\n\t\t\treturn func(ctx context.Context, testDomain string) error {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\t\treturn nil // default tester\n\t}\n\tm.GetMinTestInterval = func(e endpoint.Endpoint) time.Duration {\n\t\tif e.Protocol() == endpoint.ProtocolDNS {\n\t\t\treturn 5 * time.Second\n\t\t}\n\t\treturn 0 // use default MinTestInterval\n\t}\n\tif debug {\n\t\tm.DebugLog = func(msg string) {\n\t\t\tlog.Debug(msg)\n\t\t}\n\t}\n\treturn m\n}\n\nfunc setupClientReporting(p *proxySvc, conf *config.Profiles, r discovery.Resolver) {\n\tdeviceName, _ := host.Name()\n\tdeviceID, _ := machineid.ProtectedID(\"NextDNS\")\n\tdeviceModel := host.Model()\n\tif len(deviceID) > 5 {\n\t\t// No need to be globally unique.\n\t\tdeviceID = deviceID[:5]\n\t}\n\tdeviceID = strings.ToUpper(deviceID)\n\n\tp.resolver.DOH.ClientInfo = func(q query.Query) (ci resolver.ClientInfo) {\n\t\tif !q.PeerIP.IsLoopback() {\n\t\t\t// When acting as router, try to guess as much info as possible from\n\t\t\t// LAN client.\n\t\t\tci.IP = q.PeerIP.String()\n\t\t\tci.Name = normalizeName(r.LookupAddr(q.PeerIP.String()))\n\t\t\tif q.MAC != nil {\n\t\t\t\tci.ID = shortID(conf.Get(q.PeerIP, q.LocalIP, q.MAC), q.MAC)\n\t\t\t\thex := q.MAC.String()\n\t\t\t\tif len(hex) >= 8 {\n\t\t\t\t\t// Only send the manufacturer part of the MAC.\n\t\t\t\t\tci.Model = \"mac:\" + hex[:8]\n\t\t\t\t}\n\t\t\t\tif names := r.LookupMAC(hex); len(names) > 0 {\n\t\t\t\t\tci.Name = normalizeName(names)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ci.ID == \"\" {\n\t\t\t\tci.ID = shortID(conf.Get(q.PeerIP, q.LocalIP, q.MAC), q.PeerIP)\n\t\t\t}\n\t\t\treturn\n\t\t}\n\n\t\tci.ID = deviceID\n\t\tci.Name = deviceName\n\t\tci.Model = deviceModel\n\t\treturn\n\t}\n}\n\nfunc normalizeName(names []string) string {\n\tif len(names) == 0 {\n\t\treturn \"\"\n\t}\n\tname := names[0]\n\tif idx := strings.IndexByte(name, '.'); idx != -1 {\n\t\tname = name[:idx] // remove .local. suffix\n\t}\n\treturn name\n}\n\n// shortID derives a non reversible 5 char long non globally unique ID from the\n// the config + a device ID so device could not be tracked across configs.\nfunc shortID(confID string, deviceID []byte) string {\n\t// Concat\n\tl := len(confID) + len(deviceID)\n\tif l < 13 {\n\t\tl = 13 // len(base32((1<<64)-1)) = 13\n\t}\n\tbuf := make([]byte, 0, l)\n\tbuf = append(buf, confID...)\n\tbuf = append(buf, deviceID...)\n\t// Hash\n\tsum := xxhash.Sum64(buf)\n\t// Base 32\n\tstrconv.AppendUint(buf[:0], sum, 32)\n\t// Trim 5\n\tbuf = buf[:5]\n\t// Uppercase\n\tfor i := range buf {\n\t\tif buf[i] >= 'a' {\n\t\t\tbuf[i] ^= 1 << 5\n\t\t}\n\t}\n\treturn string(buf)\n}\n"
        },
        {
          "name": "run_test.go",
          "type": "blob",
          "size": 0.6376953125,
          "content": "package main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/nextdns/nextdns/config\"\n)\n\nfunc Test_isLocalhostMode(t *testing.T) {\n\ttests := []struct {\n\t\tlistens []string\n\t\twant    bool\n\t}{\n\t\t{[]string{\"127.0.0.1:53\"}, true},\n\t\t{[]string{\"127.0.0.1:5353\"}, true},\n\t\t{[]string{\"10.0.0.1:53\"}, false},\n\t\t{[]string{\"127.0.0.1:53\", \"10.0.0.1:53\"}, false},\n\t\t{[]string{\"10.0.0.1:53\", \"127.0.0.1:53\"}, false},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(strings.Join(tt.listens, \",\"), func(t *testing.T) {\n\t\t\tif got := isLocalhostMode(&config.Config{Listens: tt.listens}); got != tt.want {\n\t\t\t\tt.Errorf(\"isLocalhostMode() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "service.go",
          "type": "blob",
          "size": 2.0673828125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/nextdns/nextdns/config\"\n\t\"github.com/nextdns/nextdns/host\"\n\t\"github.com/nextdns/nextdns/host/service\"\n)\n\nfunc svc(args []string) error {\n\tcmd := args[0]\n\targs = args[1:]\n\tvar c config.Config\n\tif cmd == \"install\" {\n\t\t// Reset the stored configuration when install is provided with\n\t\t// parameters. Only exception is if the only param is -bogus-priv as a\n\t\t// backward compatibility with post upgrade scripts in deb/rpm packages.\n\t\tuseStorage := len(args) == 0 || (len(args) == 1 && args[0] == \"-bogus-priv\")\n\t\tc.Parse(\"nextdns \"+cmd, args, useStorage)\n\t}\n\n\tsvcArgs := []string{\"run\"}\n\tif c.File != \"\" {\n\t\tsvcArgs = append(svcArgs, \"-config-file\", c.File)\n\t}\n\ts, err := host.NewService(service.Config{\n\t\tName:        \"nextdns\",\n\t\tDisplayName: \"NextDNS Proxy\",\n\t\tDescription: \"NextDNS DNS53 to DoH proxy.\",\n\t\tArguments:   svcArgs,\n\t})\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tswitch cmd {\n\tcase \"install\":\n\t\t_ = s.Stop()\n\t\t_ = s.Uninstall()\n\t\tif len(args) > 0 {\n\t\t\tif err := c.Save(); err != nil {\n\t\t\t\tfmt.Printf(\"Cannot write config: %v\\n\", err)\n\t\t\t\tos.Exit(1)\n\t\t\t}\n\t\t}\n\t\terr := s.Install()\n\t\tif err == nil {\n\t\t\terr = s.Start()\n\t\t}\n\t\tfmt.Printf(\"NextDNS installed and started using %s init\\n\", service.Name(s))\n\t\treturn err\n\tcase \"uninstall\":\n\t\t_ = deactivate()\n\t\t_ = s.Stop()\n\t\treturn s.Uninstall()\n\tcase \"start\":\n\t\treturn s.Start()\n\tcase \"stop\":\n\t\treturn s.Stop()\n\tcase \"restart\":\n\t\treturn s.Restart()\n\tcase \"status\":\n\t\tstatus := \"unknown\"\n\t\ts, err := s.Status()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tswitch s {\n\t\tcase service.StatusRunning:\n\t\t\tstatus = \"running\"\n\t\tcase service.StatusStopped:\n\t\t\tstatus = \"stopped\"\n\t\tcase service.StatusNotInstalled:\n\t\t\tstatus = \"not installed\"\n\t\t}\n\t\tfmt.Println(status)\n\t\treturn nil\n\tcase \"log\":\n\t\tif len(args) > 0 {\n\t\t\t// If user requests log following, otherwise fall through\n\t\t\t// to default behaviour.\n\t\t\tif args[0] == \"-f\" || args[0] == \"--follow\" {\n\t\t\t\treturn host.FollowLog(\"nextdns\")\n\t\t\t}\n\t\t}\n\n\t\tl, err := host.ReadLog(\"nextdns\")\n\t\tfmt.Printf(\"%s\", l)\n\t\treturn err\n\tdefault:\n\t\tpanic(\"unknown cmd: \" + cmd)\n\t}\n}\n"
        },
        {
          "name": "upgrade.go",
          "type": "blob",
          "size": 0.544921875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n)\n\nfunc upgrade(args []string) error {\n\treturn installer(\"upgrade\")\n}\n\nfunc installer(cmd string) error {\n\tres, err := http.Get(\"https://nextdns.io/install\")\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer res.Body.Close()\n\tvar script bytes.Buffer\n\tif _, err := io.Copy(&script, res.Body); err != nil {\n\t\treturn err\n\t}\n\tc := exec.Command(\"sh\", \"-c\", script.String())\n\tc.Env = append(os.Environ(), \"RUN_COMMAND=\"+cmd)\n\tc.Stdin = os.Stdin\n\tc.Stdout = os.Stdout\n\tc.Stderr = os.Stderr\n\treturn c.Run()\n}\n"
        }
      ]
    }
  ]
}