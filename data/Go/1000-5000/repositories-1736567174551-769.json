{
  "metadata": {
    "timestamp": 1736567174551,
    "page": 769,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjc3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "avast/retry-go",
      "stars": 2500,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3154296875,
          "content": "# Binaries for programs and plugins\n*.exe\n*.dll\n*.so\n*.dylib\n\n# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n\n# Project-local glide cache, RE: https://github.com/Masterminds/glide/issues/736\n.glide/\n\n# dep\nvendor/\nGopkg.lock\n\n# cover\ncoverage.txt\n"
        },
        {
          "name": ".godocdown.tmpl",
          "type": "blob",
          "size": 1.619140625,
          "content": "# {{ .Name }}\n\n[![Release](https://img.shields.io/github/release/avast/retry-go.svg?style=flat-square)](https://github.com/avast/retry-go/releases/latest)\n[![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square)](LICENSE.md)\n![GitHub Actions](https://github.com/avast/retry-go/actions/workflows/workflow.yaml/badge.svg)\n[![Go Report Card](https://goreportcard.com/badge/github.com/avast/retry-go?style=flat-square)](https://goreportcard.com/report/github.com/avast/retry-go)\n[![Go Reference](https://pkg.go.dev/badge/github.com/avast/retry-go/v4.svg)](https://pkg.go.dev/github.com/avast/retry-go/v4)\n[![codecov.io](https://codecov.io/github/avast/retry-go/coverage.svg?branch=master)](https://codecov.io/github/avast/retry-go?branch=master)\n[![Sourcegraph](https://sourcegraph.com/github.com/avast/retry-go/-/badge.svg)](https://sourcegraph.com/github.com/avast/retry-go?badge)\n\n{{ .EmitSynopsis }}\n\n{{ .EmitUsage }}\n\n## Contributing\n\nContributions are very much welcome.\n\n### Makefile\n\nMakefile provides several handy rules, like README.md `generator` , `setup` for prepare build/dev environment, `test`, `cover`, etc...\n\nTry `make help` for more information.\n\n### Before pull request\n\n> maybe you need `make setup` in order to setup environment\n\nplease try:\n* run tests (`make test`)\n* run linter (`make lint`)\n* if your IDE don't automaticaly do `go fmt`, run `go fmt` (`make fmt`)\n\n### README\n\nREADME.md are generate from template [.godocdown.tmpl](.godocdown.tmpl) and code documentation via [godocdown](https://github.com/robertkrimen/godocdown).\n\nNever edit README.md direct, because your change will be lost.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.037109375,
          "content": "MIT License\n\nCopyright (c) 2017 Avast\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 2.15625,
          "content": "SOURCE_FILES?=$$(go list ./... | grep -v /vendor/)\nTEST_PATTERN?=.\nTEST_OPTIONS?=\nVERSION?=$$(cat VERSION)\nLINTER?=$$(which golangci-lint)\nLINTER_VERSION=1.50.0\n\nifeq ($(OS),Windows_NT)\n\tLINTER_FILE=golangci-lint-$(LINTER_VERSION)-windows-amd64.zip\n\tLINTER_UNPACK= >| app.zip; unzip -j app.zip -d $$GOPATH/bin; rm app.zip\nelse ifeq ($(OS), Darwin)\n\tLINTER_FILE=golangci-lint-$(LINTER_VERSION)-darwin-amd64.tar.gz\n\tLINTER_UNPACK= | tar xzf - -C $$GOPATH/bin --wildcards --strip 1 \"**/golangci-lint\"\nelse\n\tLINTER_FILE=golangci-lint-$(LINTER_VERSION)-linux-amd64.tar.gz\n\tLINTER_UNPACK= | tar xzf - -C $$GOPATH/bin --wildcards --strip 1 \"**/golangci-lint\"\nendif\n\nsetup:\n\tgo install github.com/pierrre/gotestcover@latest\n\tgo install golang.org/x/tools/cmd/cover@latest\n\tgo install github.com/robertkrimen/godocdown/godocdown@latest\n\tgo mod download\n\ngenerate: ## Generate README.md\n\tgodocdown >| README.md\n\ntest: generate test_and_cover_report lint\n\ntest_and_cover_report:\n\tgotestcover $(TEST_OPTIONS) -covermode=atomic -coverprofile=coverage.txt $(SOURCE_FILES) -run $(TEST_PATTERN) -timeout=2m\n\ncover: test ## Run all the tests and opens the coverage report\n\tgo tool cover -html=coverage.txt\n\nfmt: ## gofmt and goimports all go files\n\tfind . -name '*.go' -not -wholename './vendor/*' | while read -r file; do gofmt -w -s \"$$file\"; goimports -w \"$$file\"; done\n\nlint: ## Run all the linters\n\t@if [ \"$(LINTER)\" = \"\" ]; then\\\n\t\tcurl -L https://github.com/golangci/golangci-lint/releases/download/v$(LINTER_VERSION)/$(LINTER_FILE) $(LINTER_UNPACK) ;\\\n\t\tchmod +x $$GOPATH/bin/golangci-lint;\\\n\tfi\n\n\tgolangci-lint run\n\nci: test_and_cover_report ## Run all the tests but no linters - use https://golangci.com integration instead\n\nbuild:\n\tgo build\n\nrelease: ## Release new version\n\tgit tag | grep -q $(VERSION) && echo This version was released! Increase VERSION! || git tag $(VERSION) && git push origin $(VERSION) && git tag v$(VERSION) && git push origin v$(VERSION)\n\n# Absolutely awesome: http://marmelab.com/blog/2016/02/29/auto-documented-makefile.html\nhelp:\n\t@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = \":.*?## \"}; {printf \"\\033[36m%-30s\\033[0m %s\\n\", $$1, $$2}'\n\n.DEFAULT_GOAL := build\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 11.3349609375,
          "content": "# retry\n\n[![Release](https://img.shields.io/github/release/avast/retry-go.svg?style=flat-square)](https://github.com/avast/retry-go/releases/latest)\n[![Software License](https://img.shields.io/badge/license-MIT-brightgreen.svg?style=flat-square)](LICENSE.md)\n![GitHub Actions](https://github.com/avast/retry-go/actions/workflows/workflow.yaml/badge.svg)\n[![Go Report Card](https://goreportcard.com/badge/github.com/avast/retry-go?style=flat-square)](https://goreportcard.com/report/github.com/avast/retry-go)\n[![Go Reference](https://pkg.go.dev/badge/github.com/avast/retry-go/v4.svg)](https://pkg.go.dev/github.com/avast/retry-go/v4)\n[![codecov.io](https://codecov.io/github/avast/retry-go/coverage.svg?branch=master)](https://codecov.io/github/avast/retry-go?branch=master)\n[![Sourcegraph](https://sourcegraph.com/github.com/avast/retry-go/-/badge.svg)](https://sourcegraph.com/github.com/avast/retry-go?badge)\n\nSimple library for retry mechanism\n\nSlightly inspired by\n[Try::Tiny::Retry](https://metacpan.org/pod/Try::Tiny::Retry)\n\n# SYNOPSIS\n\nHTTP GET with retry:\n\n    url := \"http://example.com\"\n    var body []byte\n\n    err := retry.Do(\n    \tfunc() error {\n    \t\tresp, err := http.Get(url)\n    \t\tif err != nil {\n    \t\t\treturn err\n    \t\t}\n    \t\tdefer resp.Body.Close()\n    \t\tbody, err = ioutil.ReadAll(resp.Body)\n    \t\tif err != nil {\n    \t\t\treturn err\n    \t\t}\n    \t\treturn nil\n    \t},\n    )\n\n    if err != nil {\n    \t// handle error\n    }\n\n    fmt.Println(string(body))\n\nHTTP GET with retry with data:\n\n    url := \"http://example.com\"\n\n    body, err := retry.DoWithData(\n    \tfunc() ([]byte, error) {\n    \t\tresp, err := http.Get(url)\n    \t\tif err != nil {\n    \t\t\treturn nil, err\n    \t\t}\n    \t\tdefer resp.Body.Close()\n    \t\tbody, err := ioutil.ReadAll(resp.Body)\n    \t\tif err != nil {\n    \t\t\treturn nil, err\n    \t\t}\n\n    \t\treturn body, nil\n    \t},\n    )\n\n    if err != nil {\n    \t// handle error\n    }\n\n    fmt.Println(string(body))\n\n[More examples](https://github.com/avast/retry-go/tree/master/examples)\n\n# SEE ALSO\n\n* [giantswarm/retry-go](https://github.com/giantswarm/retry-go) - slightly\ncomplicated interface.\n\n* [sethgrid/pester](https://github.com/sethgrid/pester) - only http retry for\nhttp calls with retries and backoff\n\n* [cenkalti/backoff](https://github.com/cenkalti/backoff) - Go port of the\nexponential backoff algorithm from Google's HTTP Client Library for Java. Really\ncomplicated interface.\n\n* [rafaeljesus/retry-go](https://github.com/rafaeljesus/retry-go) - looks good,\nslightly similar as this package, don't have 'simple' `Retry` method\n\n* [matryer/try](https://github.com/matryer/try) - very popular package,\nnonintuitive interface (for me)\n\n# BREAKING CHANGES\n\n* 4.0.0\n\n    - infinity retry is possible by set `Attempts(0)` by PR [#49](https://github.com/avast/retry-go/pull/49)\n\n* 3.0.0\n\n    - `DelayTypeFunc` accepts a new parameter `err` - this breaking change affects only your custom Delay Functions. This change allow [make delay functions based on error](examples/delay_based_on_error_test.go).\n\n* 1.0.2 -> 2.0.0\n\n    - argument of `retry.Delay` is final delay (no multiplication by `retry.Units` anymore)\n    - function `retry.Units` are removed\n    - [more about this breaking change](https://github.com/avast/retry-go/issues/7)\n\n* 0.3.0 -> 1.0.0\n\n    - `retry.Retry` function are changed to `retry.Do` function\n    - `retry.RetryCustom` (OnRetry) and `retry.RetryCustomWithOpts` functions are now implement via functions produces Options (aka `retry.OnRetry`)\n\n## Usage\n\n#### func  BackOffDelay\n\n```go\nfunc BackOffDelay(n uint, _ error, config *Config) time.Duration\n```\nBackOffDelay is a DelayType which increases delay between consecutive retries\n\n#### func  Do\n\n```go\nfunc Do(retryableFunc RetryableFunc, opts ...Option) error\n```\n\n#### func  DoWithData\n\n```go\nfunc DoWithData[T any](retryableFunc RetryableFuncWithData[T], opts ...Option) (T, error)\n```\n\n#### func  FixedDelay\n\n```go\nfunc FixedDelay(_ uint, _ error, config *Config) time.Duration\n```\nFixedDelay is a DelayType which keeps delay the same through all iterations\n\n#### func  IsRecoverable\n\n```go\nfunc IsRecoverable(err error) bool\n```\nIsRecoverable checks if error is an instance of `unrecoverableError`\n\n#### func  RandomDelay\n\n```go\nfunc RandomDelay(_ uint, _ error, config *Config) time.Duration\n```\nRandomDelay is a DelayType which picks a random delay up to config.maxJitter\n\n#### func  Unrecoverable\n\n```go\nfunc Unrecoverable(err error) error\n```\nUnrecoverable wraps an error in `unrecoverableError` struct\n\n#### type Config\n\n```go\ntype Config struct {\n}\n```\n\n\n#### type DelayTypeFunc\n\n```go\ntype DelayTypeFunc func(n uint, err error, config *Config) time.Duration\n```\n\nDelayTypeFunc is called to return the next delay to wait after the retriable\nfunction fails on `err` after `n` attempts.\n\n#### func  CombineDelay\n\n```go\nfunc CombineDelay(delays ...DelayTypeFunc) DelayTypeFunc\n```\nCombineDelay is a DelayType the combines all of the specified delays into a new\nDelayTypeFunc\n\n#### type Error\n\n```go\ntype Error []error\n```\n\nError type represents list of errors in retry\n\n#### func (Error) As\n\n```go\nfunc (e Error) As(target interface{}) bool\n```\n\n#### func (Error) Error\n\n```go\nfunc (e Error) Error() string\n```\nError method return string representation of Error It is an implementation of\nerror interface\n\n#### func (Error) Is\n\n```go\nfunc (e Error) Is(target error) bool\n```\n\n#### func (Error) Unwrap\n\n```go\nfunc (e Error) Unwrap() error\n```\nUnwrap the last error for compatibility with `errors.Unwrap()`. When you need to\nunwrap all errors, you should use `WrappedErrors()` instead.\n\n    err := Do(\n    \tfunc() error {\n    \t\treturn errors.New(\"original error\")\n    \t},\n    \tAttempts(1),\n    )\n\n    fmt.Println(errors.Unwrap(err)) # \"original error\" is printed\n\nAdded in version 4.2.0.\n\n#### func (Error) WrappedErrors\n\n```go\nfunc (e Error) WrappedErrors() []error\n```\nWrappedErrors returns the list of errors that this Error is wrapping. It is an\nimplementation of the `errwrap.Wrapper` interface in package\n[errwrap](https://github.com/hashicorp/errwrap) so that `retry.Error` can be\nused with that library.\n\n#### type OnRetryFunc\n\n```go\ntype OnRetryFunc func(attempt uint, err error)\n```\n\nFunction signature of OnRetry function\n\n#### type Option\n\n```go\ntype Option func(*Config)\n```\n\nOption represents an option for retry.\n\n#### func  Attempts\n\n```go\nfunc Attempts(attempts uint) Option\n```\nAttempts set count of retry. Setting to 0 will retry until the retried function\nsucceeds. default is 10\n\n#### func  AttemptsForError\n\n```go\nfunc AttemptsForError(attempts uint, err error) Option\n```\nAttemptsForError sets count of retry in case execution results in given `err`\nRetries for the given `err` are also counted against total retries. The retry\nwill stop if any of given retries is exhausted.\n\nadded in 4.3.0\n\n#### func  Context\n\n```go\nfunc Context(ctx context.Context) Option\n```\nContext allow to set context of retry default are Background context\n\nexample of immediately cancellation (maybe it isn't the best example, but it\ndescribes behavior enough; I hope)\n\n    ctx, cancel := context.WithCancel(context.Background())\n    cancel()\n\n    retry.Do(\n    \tfunc() error {\n    \t\t...\n    \t},\n    \tretry.Context(ctx),\n    )\n\n#### func  Delay\n\n```go\nfunc Delay(delay time.Duration) Option\n```\nDelay set delay between retry default is 100ms\n\n#### func  DelayType\n\n```go\nfunc DelayType(delayType DelayTypeFunc) Option\n```\nDelayType set type of the delay between retries default is BackOff\n\n#### func  LastErrorOnly\n\n```go\nfunc LastErrorOnly(lastErrorOnly bool) Option\n```\nreturn the direct last error that came from the retried function default is\nfalse (return wrapped errors with everything)\n\n#### func  MaxDelay\n\n```go\nfunc MaxDelay(maxDelay time.Duration) Option\n```\nMaxDelay set maximum delay between retry does not apply by default\n\n#### func  MaxJitter\n\n```go\nfunc MaxJitter(maxJitter time.Duration) Option\n```\nMaxJitter sets the maximum random Jitter between retries for RandomDelay\n\n#### func  OnRetry\n\n```go\nfunc OnRetry(onRetry OnRetryFunc) Option\n```\nOnRetry function callback are called each retry\n\nlog each retry example:\n\n    retry.Do(\n    \tfunc() error {\n    \t\treturn errors.New(\"some error\")\n    \t},\n    \tretry.OnRetry(func(n uint, err error) {\n    \t\tlog.Printf(\"#%d: %s\\n\", n, err)\n    \t}),\n    )\n\n#### func  RetryIf\n\n```go\nfunc RetryIf(retryIf RetryIfFunc) Option\n```\nRetryIf controls whether a retry should be attempted after an error (assuming\nthere are any retry attempts remaining)\n\nskip retry if special error example:\n\n    retry.Do(\n    \tfunc() error {\n    \t\treturn errors.New(\"special error\")\n    \t},\n    \tretry.RetryIf(func(err error) bool {\n    \t\tif err.Error() == \"special error\" {\n    \t\t\treturn false\n    \t\t}\n    \t\treturn true\n    \t})\n    )\n\nBy default RetryIf stops execution if the error is wrapped using\n`retry.Unrecoverable`, so above example may also be shortened to:\n\n    retry.Do(\n    \tfunc() error {\n    \t\treturn retry.Unrecoverable(errors.New(\"special error\"))\n    \t}\n    )\n\n#### func  UntilSucceeded\n\n```go\nfunc UntilSucceeded() Option\n```\nUntilSucceeded will retry until the retried function succeeds. Equivalent to\nsetting Attempts(0).\n\n#### func  WithTimer\n\n```go\nfunc WithTimer(t Timer) Option\n```\nWithTimer provides a way to swap out timer module implementations. This\nprimarily is useful for mocking/testing, where you may not want to explicitly\nwait for a set duration for retries.\n\nexample of augmenting time.After with a print statement\n\n    type struct MyTimer {}\n\n    func (t *MyTimer) After(d time.Duration) <- chan time.Time {\n        fmt.Print(\"Timer called!\")\n        return time.After(d)\n    }\n\n    retry.Do(\n        func() error { ... },\n    \t   retry.WithTimer(&MyTimer{})\n    )\n\n#### func  WrapContextErrorWithLastError\n\n```go\nfunc WrapContextErrorWithLastError(wrapContextErrorWithLastError bool) Option\n```\nWrapContextErrorWithLastError allows the context error to be returned wrapped\nwith the last error that the retried function returned. This is only applicable\nwhen Attempts is set to 0 to retry indefinitly and when using a context to\ncancel / timeout\n\ndefault is false\n\n    ctx, cancel := context.WithCancel(context.Background())\n    defer cancel()\n\n    retry.Do(\n    \tfunc() error {\n    \t\t...\n    \t},\n    \tretry.Context(ctx),\n    \tretry.Attempts(0),\n    \tretry.WrapContextErrorWithLastError(true),\n    )\n\n#### type RetryIfFunc\n\n```go\ntype RetryIfFunc func(error) bool\n```\n\nFunction signature of retry if function\n\n#### type RetryableFunc\n\n```go\ntype RetryableFunc func() error\n```\n\nFunction signature of retryable function\n\n#### type RetryableFuncWithData\n\n```go\ntype RetryableFuncWithData[T any] func() (T, error)\n```\n\nFunction signature of retryable function with data\n\n#### type Timer\n\n```go\ntype Timer interface {\n\tAfter(time.Duration) <-chan time.Time\n}\n```\n\nTimer represents the timer used to track time for a retry.\n\n## Contributing\n\nContributions are very much welcome.\n\n### Makefile\n\nMakefile provides several handy rules, like README.md `generator` , `setup` for prepare build/dev environment, `test`, `cover`, etc...\n\nTry `make help` for more information.\n\n### Before pull request\n\n> maybe you need `make setup` in order to setup environment\n\nplease try:\n* run tests (`make test`)\n* run linter (`make lint`)\n* if your IDE don't automaticaly do `go fmt`, run `go fmt` (`make fmt`)\n\n### README\n\nREADME.md are generate from template [.godocdown.tmpl](.godocdown.tmpl) and code documentation via [godocdown](https://github.com/robertkrimen/godocdown).\n\nNever edit README.md direct, because your change will be lost.\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "4.6.0\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.23046875,
          "content": "module github.com/avast/retry-go/v4\n\ngo 1.18\n\nrequire github.com/stretchr/testify v1.9.0\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.8603515625,
          "content": "github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=\ngithub.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 6.9541015625,
          "content": "package retry\n\nimport (\n\t\"context\"\n\t\"math\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// Function signature of retry if function\ntype RetryIfFunc func(error) bool\n\n// Function signature of OnRetry function\ntype OnRetryFunc func(attempt uint, err error)\n\n// DelayTypeFunc is called to return the next delay to wait after the retriable function fails on `err` after `n` attempts.\ntype DelayTypeFunc func(n uint, err error, config *Config) time.Duration\n\n// Timer represents the timer used to track time for a retry.\ntype Timer interface {\n\tAfter(time.Duration) <-chan time.Time\n}\n\ntype Config struct {\n\tattempts                      uint\n\tattemptsForError              map[error]uint\n\tdelay                         time.Duration\n\tmaxDelay                      time.Duration\n\tmaxJitter                     time.Duration\n\tonRetry                       OnRetryFunc\n\tretryIf                       RetryIfFunc\n\tdelayType                     DelayTypeFunc\n\tlastErrorOnly                 bool\n\tcontext                       context.Context\n\ttimer                         Timer\n\twrapContextErrorWithLastError bool\n\n\tmaxBackOffN uint\n}\n\n// Option represents an option for retry.\ntype Option func(*Config)\n\nfunc emptyOption(c *Config) {}\n\n// return the direct last error that came from the retried function\n// default is false (return wrapped errors with everything)\nfunc LastErrorOnly(lastErrorOnly bool) Option {\n\treturn func(c *Config) {\n\t\tc.lastErrorOnly = lastErrorOnly\n\t}\n}\n\n// Attempts set count of retry. Setting to 0 will retry until the retried function succeeds.\n// default is 10\nfunc Attempts(attempts uint) Option {\n\treturn func(c *Config) {\n\t\tc.attempts = attempts\n\t}\n}\n\n// UntilSucceeded will retry until the retried function succeeds. Equivalent to setting Attempts(0).\nfunc UntilSucceeded() Option {\n\treturn func(c *Config) {\n\t\tc.attempts = 0\n\t}\n}\n\n// AttemptsForError sets count of retry in case execution results in given `err`\n// Retries for the given `err` are also counted against total retries.\n// The retry will stop if any of given retries is exhausted.\n//\n// added in 4.3.0\nfunc AttemptsForError(attempts uint, err error) Option {\n\treturn func(c *Config) {\n\t\tc.attemptsForError[err] = attempts\n\t}\n}\n\n// Delay set delay between retry\n// default is 100ms\nfunc Delay(delay time.Duration) Option {\n\treturn func(c *Config) {\n\t\tc.delay = delay\n\t}\n}\n\n// MaxDelay set maximum delay between retry\n// does not apply by default\nfunc MaxDelay(maxDelay time.Duration) Option {\n\treturn func(c *Config) {\n\t\tc.maxDelay = maxDelay\n\t}\n}\n\n// MaxJitter sets the maximum random Jitter between retries for RandomDelay\nfunc MaxJitter(maxJitter time.Duration) Option {\n\treturn func(c *Config) {\n\t\tc.maxJitter = maxJitter\n\t}\n}\n\n// DelayType set type of the delay between retries\n// default is BackOff\nfunc DelayType(delayType DelayTypeFunc) Option {\n\tif delayType == nil {\n\t\treturn emptyOption\n\t}\n\treturn func(c *Config) {\n\t\tc.delayType = delayType\n\t}\n}\n\n// BackOffDelay is a DelayType which increases delay between consecutive retries\nfunc BackOffDelay(n uint, _ error, config *Config) time.Duration {\n\t// 1 << 63 would overflow signed int64 (time.Duration), thus 62.\n\tconst max uint = 62\n\n\tif config.maxBackOffN == 0 {\n\t\tif config.delay <= 0 {\n\t\t\tconfig.delay = 1\n\t\t}\n\n\t\tconfig.maxBackOffN = max - uint(math.Floor(math.Log2(float64(config.delay))))\n\t}\n\n\tif n > config.maxBackOffN {\n\t\tn = config.maxBackOffN\n\t}\n\n\treturn config.delay << n\n}\n\n// FixedDelay is a DelayType which keeps delay the same through all iterations\nfunc FixedDelay(_ uint, _ error, config *Config) time.Duration {\n\treturn config.delay\n}\n\n// RandomDelay is a DelayType which picks a random delay up to config.maxJitter\nfunc RandomDelay(_ uint, _ error, config *Config) time.Duration {\n\treturn time.Duration(rand.Int63n(int64(config.maxJitter)))\n}\n\n// CombineDelay is a DelayType the combines all of the specified delays into a new DelayTypeFunc\nfunc CombineDelay(delays ...DelayTypeFunc) DelayTypeFunc {\n\tconst maxInt64 = uint64(math.MaxInt64)\n\n\treturn func(n uint, err error, config *Config) time.Duration {\n\t\tvar total uint64\n\t\tfor _, delay := range delays {\n\t\t\ttotal += uint64(delay(n, err, config))\n\t\t\tif total > maxInt64 {\n\t\t\t\ttotal = maxInt64\n\t\t\t}\n\t\t}\n\n\t\treturn time.Duration(total)\n\t}\n}\n\n// OnRetry function callback are called each retry\n//\n// log each retry example:\n//\n//\tretry.Do(\n//\t\tfunc() error {\n//\t\t\treturn errors.New(\"some error\")\n//\t\t},\n//\t\tretry.OnRetry(func(n uint, err error) {\n//\t\t\tlog.Printf(\"#%d: %s\\n\", n, err)\n//\t\t}),\n//\t)\nfunc OnRetry(onRetry OnRetryFunc) Option {\n\tif onRetry == nil {\n\t\treturn emptyOption\n\t}\n\treturn func(c *Config) {\n\t\tc.onRetry = onRetry\n\t}\n}\n\n// RetryIf controls whether a retry should be attempted after an error\n// (assuming there are any retry attempts remaining)\n//\n// skip retry if special error example:\n//\n//\tretry.Do(\n//\t\tfunc() error {\n//\t\t\treturn errors.New(\"special error\")\n//\t\t},\n//\t\tretry.RetryIf(func(err error) bool {\n//\t\t\tif err.Error() == \"special error\" {\n//\t\t\t\treturn false\n//\t\t\t}\n//\t\t\treturn true\n//\t\t})\n//\t)\n//\n// By default RetryIf stops execution if the error is wrapped using `retry.Unrecoverable`,\n// so above example may also be shortened to:\n//\n//\tretry.Do(\n//\t\tfunc() error {\n//\t\t\treturn retry.Unrecoverable(errors.New(\"special error\"))\n//\t\t}\n//\t)\nfunc RetryIf(retryIf RetryIfFunc) Option {\n\tif retryIf == nil {\n\t\treturn emptyOption\n\t}\n\treturn func(c *Config) {\n\t\tc.retryIf = retryIf\n\t}\n}\n\n// Context allow to set context of retry\n// default are Background context\n//\n// example of immediately cancellation (maybe it isn't the best example, but it describes behavior enough; I hope)\n//\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tcancel()\n//\n//\tretry.Do(\n//\t\tfunc() error {\n//\t\t\t...\n//\t\t},\n//\t\tretry.Context(ctx),\n//\t)\nfunc Context(ctx context.Context) Option {\n\treturn func(c *Config) {\n\t\tc.context = ctx\n\t}\n}\n\n// WithTimer provides a way to swap out timer module implementations.\n// This primarily is useful for mocking/testing, where you may not want to explicitly wait for a set duration\n// for retries.\n//\n// example of augmenting time.After with a print statement\n//\n//\ttype struct MyTimer {}\n//\n//\tfunc (t *MyTimer) After(d time.Duration) <- chan time.Time {\n//\t    fmt.Print(\"Timer called!\")\n//\t    return time.After(d)\n//\t}\n//\n//\tretry.Do(\n//\t    func() error { ... },\n//\t\t   retry.WithTimer(&MyTimer{})\n//\t)\nfunc WithTimer(t Timer) Option {\n\treturn func(c *Config) {\n\t\tc.timer = t\n\t}\n}\n\n// WrapContextErrorWithLastError allows the context error to be returned wrapped with the last error that the\n// retried function returned. This is only applicable when Attempts is set to 0 to retry indefinitly and when\n// using a context to cancel / timeout\n//\n// default is false\n//\n//\tctx, cancel := context.WithCancel(context.Background())\n//\tdefer cancel()\n//\n//\tretry.Do(\n//\t\tfunc() error {\n//\t\t\t...\n//\t\t},\n//\t\tretry.Context(ctx),\n//\t\tretry.Attempts(0),\n//\t\tretry.WrapContextErrorWithLastError(true),\n//\t)\nfunc WrapContextErrorWithLastError(wrapContextErrorWithLastError bool) Option {\n\treturn func(c *Config) {\n\t\tc.wrapContextErrorWithLastError = wrapContextErrorWithLastError\n\t}\n}\n"
        },
        {
          "name": "retry.go",
          "type": "blob",
          "size": 7.8681640625,
          "content": "/*\nSimple library for retry mechanism\n\nSlightly inspired by [Try::Tiny::Retry](https://metacpan.org/pod/Try::Tiny::Retry)\n\n# SYNOPSIS\n\nHTTP GET with retry:\n\n\turl := \"http://example.com\"\n\tvar body []byte\n\n\terr := retry.Do(\n\t\tfunc() error {\n\t\t\tresp, err := http.Get(url)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\t\t\tbody, err = ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t)\n\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\tfmt.Println(string(body))\n\nHTTP GET with retry with data:\n\n\turl := \"http://example.com\"\n\n\tbody, err := retry.DoWithData(\n\t\tfunc() ([]byte, error) {\n\t\t\tresp, err := http.Get(url)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\t\t\tbody, err := ioutil.ReadAll(resp.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn body, nil\n\t\t},\n\t)\n\n\tif err != nil {\n\t\t// handle error\n\t}\n\n\tfmt.Println(string(body))\n\n[More examples](https://github.com/avast/retry-go/tree/master/examples)\n\n# SEE ALSO\n\n* [giantswarm/retry-go](https://github.com/giantswarm/retry-go) - slightly complicated interface.\n\n* [sethgrid/pester](https://github.com/sethgrid/pester) - only http retry for http calls with retries and backoff\n\n* [cenkalti/backoff](https://github.com/cenkalti/backoff) - Go port of the exponential backoff algorithm from Google's HTTP Client Library for Java. Really complicated interface.\n\n* [rafaeljesus/retry-go](https://github.com/rafaeljesus/retry-go) - looks good, slightly similar as this package, don't have 'simple' `Retry` method\n\n* [matryer/try](https://github.com/matryer/try) - very popular package, nonintuitive interface (for me)\n\n# BREAKING CHANGES\n\n* 4.0.0\n  - infinity retry is possible by set `Attempts(0)` by PR [#49](https://github.com/avast/retry-go/pull/49)\n\n* 3.0.0\n  - `DelayTypeFunc` accepts a new parameter `err` - this breaking change affects only your custom Delay Functions. This change allow [make delay functions based on error](examples/delay_based_on_error_test.go).\n\n* 1.0.2 -> 2.0.0\n  - argument of `retry.Delay` is final delay (no multiplication by `retry.Units` anymore)\n  - function `retry.Units` are removed\n  - [more about this breaking change](https://github.com/avast/retry-go/issues/7)\n\n* 0.3.0 -> 1.0.0\n  - `retry.Retry` function are changed to `retry.Do` function\n  - `retry.RetryCustom` (OnRetry) and `retry.RetryCustomWithOpts` functions are now implement via functions produces Options (aka `retry.OnRetry`)\n*/\npackage retry\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Function signature of retryable function\ntype RetryableFunc func() error\n\n// Function signature of retryable function with data\ntype RetryableFuncWithData[T any] func() (T, error)\n\n// Default timer is a wrapper around time.After\ntype timerImpl struct{}\n\nfunc (t *timerImpl) After(d time.Duration) <-chan time.Time {\n\treturn time.After(d)\n}\n\nfunc Do(retryableFunc RetryableFunc, opts ...Option) error {\n\tretryableFuncWithData := func() (any, error) {\n\t\treturn nil, retryableFunc()\n\t}\n\n\t_, err := DoWithData(retryableFuncWithData, opts...)\n\treturn err\n}\n\nfunc DoWithData[T any](retryableFunc RetryableFuncWithData[T], opts ...Option) (T, error) {\n\tvar n uint\n\tvar emptyT T\n\n\t// default\n\tconfig := newDefaultRetryConfig()\n\n\t// apply opts\n\tfor _, opt := range opts {\n\t\topt(config)\n\t}\n\n\tif err := config.context.Err(); err != nil {\n\t\treturn emptyT, err\n\t}\n\n\t// Setting attempts to 0 means we'll retry until we succeed\n\tvar lastErr error\n\tif config.attempts == 0 {\n\t\tfor {\n\t\t\tt, err := retryableFunc()\n\t\t\tif err == nil {\n\t\t\t\treturn t, nil\n\t\t\t}\n\n\t\t\tif !IsRecoverable(err) {\n\t\t\t\treturn emptyT, err\n\t\t\t}\n\n\t\t\tif !config.retryIf(err) {\n\t\t\t\treturn emptyT, err\n\t\t\t}\n\n\t\t\tlastErr = err\n\n\t\t\tconfig.onRetry(n, err)\n\t\t\tn++\n\t\t\tselect {\n\t\t\tcase <-config.timer.After(delay(config, n, err)):\n\t\t\tcase <-config.context.Done():\n\t\t\t\tif config.wrapContextErrorWithLastError {\n\t\t\t\t\treturn emptyT, Error{config.context.Err(), lastErr}\n\t\t\t\t}\n\t\t\t\treturn emptyT, config.context.Err()\n\t\t\t}\n\t\t}\n\t}\n\n\terrorLog := Error{}\n\n\tattemptsForError := make(map[error]uint, len(config.attemptsForError))\n\tfor err, attempts := range config.attemptsForError {\n\t\tattemptsForError[err] = attempts\n\t}\n\n\tshouldRetry := true\n\tfor shouldRetry {\n\t\tt, err := retryableFunc()\n\t\tif err == nil {\n\t\t\treturn t, nil\n\t\t}\n\n\t\terrorLog = append(errorLog, unpackUnrecoverable(err))\n\n\t\tif !config.retryIf(err) {\n\t\t\tbreak\n\t\t}\n\n\t\tconfig.onRetry(n, err)\n\n\t\tfor errToCheck, attempts := range attemptsForError {\n\t\t\tif errors.Is(err, errToCheck) {\n\t\t\t\tattempts--\n\t\t\t\tattemptsForError[errToCheck] = attempts\n\t\t\t\tshouldRetry = shouldRetry && attempts > 0\n\t\t\t}\n\t\t}\n\n\t\t// if this is last attempt - don't wait\n\t\tif n == config.attempts-1 {\n\t\t\tbreak\n\t\t}\n\n\t\tselect {\n\t\tcase <-config.timer.After(delay(config, n, err)):\n\t\tcase <-config.context.Done():\n\t\t\tif config.lastErrorOnly {\n\t\t\t\treturn emptyT, config.context.Err()\n\t\t\t}\n\n\t\t\treturn emptyT, append(errorLog, config.context.Err())\n\t\t}\n\n\t\tn++\n\t\tshouldRetry = shouldRetry && n < config.attempts\n\t}\n\n\tif config.lastErrorOnly {\n\t\treturn emptyT, errorLog.Unwrap()\n\t}\n\treturn emptyT, errorLog\n}\n\nfunc newDefaultRetryConfig() *Config {\n\treturn &Config{\n\t\tattempts:         uint(10),\n\t\tattemptsForError: make(map[error]uint),\n\t\tdelay:            100 * time.Millisecond,\n\t\tmaxJitter:        100 * time.Millisecond,\n\t\tonRetry:          func(n uint, err error) {},\n\t\tretryIf:          IsRecoverable,\n\t\tdelayType:        CombineDelay(BackOffDelay, RandomDelay),\n\t\tlastErrorOnly:    false,\n\t\tcontext:          context.Background(),\n\t\ttimer:            &timerImpl{},\n\t}\n}\n\n// Error type represents list of errors in retry\ntype Error []error\n\n// Error method return string representation of Error\n// It is an implementation of error interface\nfunc (e Error) Error() string {\n\tlogWithNumber := make([]string, len(e))\n\tfor i, l := range e {\n\t\tif l != nil {\n\t\t\tlogWithNumber[i] = fmt.Sprintf(\"#%d: %s\", i+1, l.Error())\n\t\t}\n\t}\n\n\treturn fmt.Sprintf(\"All attempts fail:\\n%s\", strings.Join(logWithNumber, \"\\n\"))\n}\n\nfunc (e Error) Is(target error) bool {\n\tfor _, v := range e {\n\t\tif errors.Is(v, target) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (e Error) As(target interface{}) bool {\n\tfor _, v := range e {\n\t\tif errors.As(v, target) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n/*\nUnwrap the last error for compatibility with `errors.Unwrap()`.\nWhen you need to unwrap all errors, you should use `WrappedErrors()` instead.\n\n\terr := Do(\n\t\tfunc() error {\n\t\t\treturn errors.New(\"original error\")\n\t\t},\n\t\tAttempts(1),\n\t)\n\n\tfmt.Println(errors.Unwrap(err)) # \"original error\" is printed\n\nAdded in version 4.2.0.\n*/\nfunc (e Error) Unwrap() error {\n\treturn e[len(e)-1]\n}\n\n// WrappedErrors returns the list of errors that this Error is wrapping.\n// It is an implementation of the `errwrap.Wrapper` interface\n// in package [errwrap](https://github.com/hashicorp/errwrap) so that\n// `retry.Error` can be used with that library.\nfunc (e Error) WrappedErrors() []error {\n\treturn e\n}\n\ntype unrecoverableError struct {\n\terror\n}\n\nfunc (e unrecoverableError) Error() string {\n\tif e.error == nil {\n\t\treturn \"unrecoverable error\"\n\t}\n\treturn e.error.Error()\n}\n\nfunc (e unrecoverableError) Unwrap() error {\n\treturn e.error\n}\n\n// Unrecoverable wraps an error in `unrecoverableError` struct\nfunc Unrecoverable(err error) error {\n\treturn unrecoverableError{err}\n}\n\n// IsRecoverable checks if error is an instance of `unrecoverableError`\nfunc IsRecoverable(err error) bool {\n\treturn !errors.Is(err, unrecoverableError{})\n}\n\n// Adds support for errors.Is usage on unrecoverableError\nfunc (unrecoverableError) Is(err error) bool {\n\t_, isUnrecoverable := err.(unrecoverableError)\n\treturn isUnrecoverable\n}\n\nfunc unpackUnrecoverable(err error) error {\n\tif unrecoverable, isUnrecoverable := err.(unrecoverableError); isUnrecoverable {\n\t\treturn unrecoverable.error\n\t}\n\n\treturn err\n}\n\nfunc delay(config *Config, n uint, err error) time.Duration {\n\tdelayTime := config.delayType(n, err, config)\n\tif config.maxDelay > 0 && delayTime > config.maxDelay {\n\t\tdelayTime = config.maxDelay\n\t}\n\n\treturn delayTime\n}\n"
        },
        {
          "name": "retry_test.go",
          "type": "blob",
          "size": 13.6201171875,
          "content": "package retry\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestDoWithDataAllFailed(t *testing.T) {\n\tvar retrySum uint\n\tv, err := DoWithData(\n\t\tfunc() (int, error) { return 7, errors.New(\"test\") },\n\t\tOnRetry(func(n uint, err error) { retrySum += n }),\n\t\tDelay(time.Nanosecond),\n\t)\n\tassert.Error(t, err)\n\tassert.Equal(t, 0, v)\n\n\texpectedErrorFormat := `All attempts fail:\n#1: test\n#2: test\n#3: test\n#4: test\n#5: test\n#6: test\n#7: test\n#8: test\n#9: test\n#10: test`\n\tassert.Len(t, err, 10)\n\tfmt.Println(err.Error())\n\tassert.Equal(t, expectedErrorFormat, err.Error(), \"retry error format\")\n\tassert.Equal(t, uint(45), retrySum, \"right count of retry\")\n}\n\nfunc TestDoFirstOk(t *testing.T) {\n\tvar retrySum uint\n\terr := Do(\n\t\tfunc() error { return nil },\n\t\tOnRetry(func(n uint, err error) { retrySum += n }),\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, uint(0), retrySum, \"no retry\")\n}\n\nfunc TestDoWithDataFirstOk(t *testing.T) {\n\treturnVal := 1\n\n\tvar retrySum uint\n\tval, err := DoWithData(\n\t\tfunc() (int, error) { return returnVal, nil },\n\t\tOnRetry(func(n uint, err error) { retrySum += n }),\n\t)\n\tassert.NoError(t, err)\n\tassert.Equal(t, returnVal, val)\n\tassert.Equal(t, uint(0), retrySum, \"no retry\")\n}\n\nfunc TestRetryIf(t *testing.T) {\n\tvar retryCount uint\n\terr := Do(\n\t\tfunc() error {\n\t\t\tif retryCount >= 2 {\n\t\t\t\treturn errors.New(\"special\")\n\t\t\t} else {\n\t\t\t\treturn errors.New(\"test\")\n\t\t\t}\n\t\t},\n\t\tOnRetry(func(n uint, err error) { retryCount++ }),\n\t\tRetryIf(func(err error) bool {\n\t\t\treturn err.Error() != \"special\"\n\t\t}),\n\t\tDelay(time.Nanosecond),\n\t)\n\tassert.Error(t, err)\n\n\texpectedErrorFormat := `All attempts fail:\n#1: test\n#2: test\n#3: special`\n\tassert.Len(t, err, 3)\n\tassert.Equal(t, expectedErrorFormat, err.Error(), \"retry error format\")\n\tassert.Equal(t, uint(2), retryCount, \"right count of retry\")\n}\n\nfunc TestRetryIf_ZeroAttempts(t *testing.T) {\n\tvar retryCount, onRetryCount uint\n\terr := Do(\n\t\tfunc() error {\n\t\t\tif retryCount >= 2 {\n\t\t\t\treturn errors.New(\"special\")\n\t\t\t} else {\n\t\t\t\tretryCount++\n\t\t\t\treturn errors.New(\"test\")\n\t\t\t}\n\t\t},\n\t\tOnRetry(func(n uint, err error) { onRetryCount = n }),\n\t\tRetryIf(func(err error) bool {\n\t\t\treturn err.Error() != \"special\"\n\t\t}),\n\t\tDelay(time.Nanosecond),\n\t\tAttempts(0),\n\t)\n\tassert.Error(t, err)\n\n\tassert.Equal(t, \"special\", err.Error(), \"retry error format\")\n\tassert.Equal(t, retryCount, onRetryCount+1, \"right count of retry\")\n}\n\nfunc TestZeroAttemptsWithError(t *testing.T) {\n\tconst maxErrors = 999\n\tcount := 0\n\n\terr := Do(\n\t\tfunc() error {\n\t\t\tif count < maxErrors {\n\t\t\t\tcount += 1\n\t\t\t\treturn errors.New(\"test\")\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tAttempts(0),\n\t\tMaxDelay(time.Nanosecond),\n\t)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, count, maxErrors)\n}\n\nfunc TestZeroAttemptsWithoutError(t *testing.T) {\n\tcount := 0\n\n\terr := Do(\n\t\tfunc() error {\n\t\t\tcount++\n\n\t\t\treturn nil\n\t\t},\n\t\tAttempts(0),\n\t)\n\tassert.NoError(t, err)\n\n\tassert.Equal(t, count, 1)\n}\n\nfunc TestZeroAttemptsWithUnrecoverableError(t *testing.T) {\n\terr := Do(\n\t\tfunc() error {\n\t\t\treturn Unrecoverable(assert.AnError)\n\t\t},\n\t\tAttempts(0),\n\t\tMaxDelay(time.Nanosecond),\n\t)\n\tassert.Error(t, err)\n\tassert.Equal(t, Unrecoverable(assert.AnError), err)\n}\n\nfunc TestAttemptsForError(t *testing.T) {\n\tcount := uint(0)\n\ttestErr := os.ErrInvalid\n\tattemptsForTestError := uint(3)\n\terr := Do(\n\t\tfunc() error {\n\t\t\tcount++\n\t\t\treturn testErr\n\t\t},\n\t\tAttemptsForError(attemptsForTestError, testErr),\n\t\tAttempts(5),\n\t)\n\tassert.Error(t, err)\n\tassert.Equal(t, attemptsForTestError, count)\n}\n\nfunc TestDefaultSleep(t *testing.T) {\n\tstart := time.Now()\n\terr := Do(\n\t\tfunc() error { return errors.New(\"test\") },\n\t\tAttempts(3),\n\t)\n\tdur := time.Since(start)\n\tassert.Error(t, err)\n\tassert.Greater(t, dur, 300*time.Millisecond, \"3 times default retry is longer then 300ms\")\n}\n\nfunc TestFixedSleep(t *testing.T) {\n\tstart := time.Now()\n\terr := Do(\n\t\tfunc() error { return errors.New(\"test\") },\n\t\tAttempts(3),\n\t\tDelayType(FixedDelay),\n\t)\n\tdur := time.Since(start)\n\tassert.Error(t, err)\n\tassert.Less(t, dur, 500*time.Millisecond, \"3 times default retry is shorter then 500ms\")\n}\n\nfunc TestLastErrorOnly(t *testing.T) {\n\tvar retrySum uint\n\terr := Do(\n\t\tfunc() error { return fmt.Errorf(\"%d\", retrySum) },\n\t\tOnRetry(func(n uint, err error) { retrySum += 1 }),\n\t\tDelay(time.Nanosecond),\n\t\tLastErrorOnly(true),\n\t)\n\tassert.Error(t, err)\n\tassert.Equal(t, \"9\", err.Error())\n}\n\nfunc TestUnrecoverableError(t *testing.T) {\n\tattempts := 0\n\ttestErr := errors.New(\"error\")\n\texpectedErr := Error{testErr}\n\terr := Do(\n\t\tfunc() error {\n\t\t\tattempts++\n\t\t\treturn Unrecoverable(testErr)\n\t\t},\n\t\tAttempts(2),\n\t)\n\tassert.Equal(t, expectedErr, err)\n\tassert.Equal(t, testErr, errors.Unwrap(err))\n\tassert.Equal(t, 1, attempts, \"unrecoverable error broke the loop\")\n}\n\nfunc TestCombineFixedDelays(t *testing.T) {\n\tif os.Getenv(\"OS\") == \"macos-latest\" {\n\t\tt.Skip(\"Skipping testing in MacOS GitHub actions - too slow, duration is wrong\")\n\t}\n\n\tstart := time.Now()\n\terr := Do(\n\t\tfunc() error { return errors.New(\"test\") },\n\t\tAttempts(3),\n\t\tDelayType(CombineDelay(FixedDelay, FixedDelay)),\n\t)\n\tdur := time.Since(start)\n\tassert.Error(t, err)\n\tassert.Greater(t, dur, 400*time.Millisecond, \"3 times combined, fixed retry is greater then 400ms\")\n\tassert.Less(t, dur, 500*time.Millisecond, \"3 times combined, fixed retry is less then 500ms\")\n}\n\nfunc TestRandomDelay(t *testing.T) {\n\tif os.Getenv(\"OS\") == \"macos-latest\" {\n\t\tt.Skip(\"Skipping testing in MacOS GitHub actions - too slow, duration is wrong\")\n\t}\n\n\tstart := time.Now()\n\terr := Do(\n\t\tfunc() error { return errors.New(\"test\") },\n\t\tAttempts(3),\n\t\tDelayType(RandomDelay),\n\t\tMaxJitter(50*time.Millisecond),\n\t)\n\tdur := time.Since(start)\n\tassert.Error(t, err)\n\tassert.Greater(t, dur, 2*time.Millisecond, \"3 times random retry is longer then 2ms\")\n\tassert.Less(t, dur, 150*time.Millisecond, \"3 times random retry is shorter then 150ms\")\n}\n\nfunc TestMaxDelay(t *testing.T) {\n\tif os.Getenv(\"OS\") == \"macos-latest\" {\n\t\tt.Skip(\"Skipping testing in MacOS GitHub actions - too slow, duration is wrong\")\n\t}\n\n\tstart := time.Now()\n\terr := Do(\n\t\tfunc() error { return errors.New(\"test\") },\n\t\tAttempts(5),\n\t\tDelay(10*time.Millisecond),\n\t\tMaxDelay(50*time.Millisecond),\n\t)\n\tdur := time.Since(start)\n\tassert.Error(t, err)\n\tassert.Greater(t, dur, 120*time.Millisecond, \"5 times with maximum delay retry is less than 120ms\")\n\tassert.Less(t, dur, 250*time.Millisecond, \"5 times with maximum delay retry is longer than 250ms\")\n}\n\nfunc TestBackOffDelay(t *testing.T) {\n\tfor _, c := range []struct {\n\t\tlabel         string\n\t\tdelay         time.Duration\n\t\texpectedMaxN  uint\n\t\tn             uint\n\t\texpectedDelay time.Duration\n\t}{\n\t\t{\n\t\t\tlabel:         \"negative-delay\",\n\t\t\tdelay:         -1,\n\t\t\texpectedMaxN:  62,\n\t\t\tn:             2,\n\t\t\texpectedDelay: 4,\n\t\t},\n\t\t{\n\t\t\tlabel:         \"zero-delay\",\n\t\t\tdelay:         0,\n\t\t\texpectedMaxN:  62,\n\t\t\tn:             65,\n\t\t\texpectedDelay: 1 << 62,\n\t\t},\n\t\t{\n\t\t\tlabel:         \"one-second\",\n\t\t\tdelay:         time.Second,\n\t\t\texpectedMaxN:  33,\n\t\t\tn:             62,\n\t\t\texpectedDelay: time.Second << 33,\n\t\t},\n\t} {\n\t\tt.Run(\n\t\t\tc.label,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tconfig := Config{\n\t\t\t\t\tdelay: c.delay,\n\t\t\t\t}\n\t\t\t\tdelay := BackOffDelay(c.n, nil, &config)\n\t\t\t\tassert.Equal(t, c.expectedMaxN, config.maxBackOffN, \"max n mismatch\")\n\t\t\t\tassert.Equal(t, c.expectedDelay, delay, \"delay duration mismatch\")\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestCombineDelay(t *testing.T) {\n\tf := func(d time.Duration) DelayTypeFunc {\n\t\treturn func(_ uint, _ error, _ *Config) time.Duration {\n\t\t\treturn d\n\t\t}\n\t}\n\tconst max = time.Duration(1<<63 - 1)\n\tfor _, c := range []struct {\n\t\tlabel    string\n\t\tdelays   []time.Duration\n\t\texpected time.Duration\n\t}{\n\t\t{\n\t\t\tlabel: \"empty\",\n\t\t},\n\t\t{\n\t\t\tlabel: \"single\",\n\t\t\tdelays: []time.Duration{\n\t\t\t\ttime.Second,\n\t\t\t},\n\t\t\texpected: time.Second,\n\t\t},\n\t\t{\n\t\t\tlabel: \"negative\",\n\t\t\tdelays: []time.Duration{\n\t\t\t\ttime.Second,\n\t\t\t\t-time.Millisecond,\n\t\t\t},\n\t\t\texpected: time.Second - time.Millisecond,\n\t\t},\n\t\t{\n\t\t\tlabel: \"overflow\",\n\t\t\tdelays: []time.Duration{\n\t\t\t\tmax,\n\t\t\t\ttime.Second,\n\t\t\t\ttime.Millisecond,\n\t\t\t},\n\t\t\texpected: max,\n\t\t},\n\t} {\n\t\tt.Run(\n\t\t\tc.label,\n\t\t\tfunc(t *testing.T) {\n\t\t\t\tfuncs := make([]DelayTypeFunc, len(c.delays))\n\t\t\t\tfor i, d := range c.delays {\n\t\t\t\t\tfuncs[i] = f(d)\n\t\t\t\t}\n\t\t\t\tactual := CombineDelay(funcs...)(0, nil, nil)\n\t\t\t\tassert.Equal(t, c.expected, actual, \"delay duration mismatch\")\n\t\t\t},\n\t\t)\n\t}\n}\n\nfunc TestContext(t *testing.T) {\n\tconst defaultDelay = 100 * time.Millisecond\n\tt.Run(\"cancel before\", func(t *testing.T) {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tcancel()\n\n\t\tretrySum := 0\n\t\tstart := time.Now()\n\t\terr := Do(\n\t\t\tfunc() error { return errors.New(\"test\") },\n\t\t\tOnRetry(func(n uint, err error) { retrySum += 1 }),\n\t\t\tContext(ctx),\n\t\t)\n\t\tdur := time.Since(start)\n\t\tassert.Error(t, err)\n\t\tassert.True(t, dur < defaultDelay, \"immediately cancellation\")\n\t\tassert.Equal(t, 0, retrySum, \"called at most once\")\n\t})\n\n\tt.Run(\"cancel in retry progress\", func(t *testing.T) {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\n\t\tretrySum := 0\n\t\terr := Do(\n\t\t\tfunc() error { return errors.New(\"test\") },\n\t\t\tOnRetry(func(n uint, err error) {\n\t\t\t\tretrySum += 1\n\t\t\t\tif retrySum > 1 {\n\t\t\t\t\tcancel()\n\t\t\t\t}\n\t\t\t}),\n\t\t\tContext(ctx),\n\t\t)\n\t\tassert.Error(t, err)\n\n\t\texpectedErrorFormat := `All attempts fail:\n#1: test\n#2: test\n#3: context canceled`\n\t\tassert.Len(t, err, 3)\n\t\tassert.Equal(t, expectedErrorFormat, err.Error(), \"retry error format\")\n\t\tassert.Equal(t, 2, retrySum, \"called at most once\")\n\t})\n\n\tt.Run(\"cancel in retry progress - last error only\", func(t *testing.T) {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\n\t\tretrySum := 0\n\t\terr := Do(\n\t\t\tfunc() error { return errors.New(\"test\") },\n\t\t\tOnRetry(func(n uint, err error) {\n\t\t\t\tretrySum += 1\n\t\t\t\tif retrySum > 1 {\n\t\t\t\t\tcancel()\n\t\t\t\t}\n\t\t\t}),\n\t\t\tContext(ctx),\n\t\t\tLastErrorOnly(true),\n\t\t)\n\t\tassert.Equal(t, context.Canceled, err)\n\n\t\tassert.Equal(t, 2, retrySum, \"called at most once\")\n\t})\n\n\tt.Run(\"cancel in retry progress - infinite attempts\", func(t *testing.T) {\n\t\tgo func() {\n\t\t\tctx, cancel := context.WithCancel(context.Background())\n\n\t\t\tretrySum := 0\n\t\t\terr := Do(\n\t\t\t\tfunc() error { return errors.New(\"test\") },\n\t\t\t\tOnRetry(func(n uint, err error) {\n\t\t\t\t\tfmt.Println(n)\n\t\t\t\t\tretrySum += 1\n\t\t\t\t\tif retrySum > 1 {\n\t\t\t\t\t\tcancel()\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\t\tContext(ctx),\n\t\t\t\tAttempts(0),\n\t\t\t)\n\n\t\t\tassert.Equal(t, context.Canceled, err)\n\n\t\t\tassert.Equal(t, 2, retrySum, \"called at most once\")\n\t\t}()\n\t})\n\n\tt.Run(\"cancelled on retry infinte attempts - wraps context error with last retried function error\", func(t *testing.T) {\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tdefer cancel()\n\n\t\tretrySum := 0\n\t\terr := Do(\n\t\t\tfunc() error { return fooErr{str: fmt.Sprintf(\"error %d\", retrySum+1)} },\n\t\t\tOnRetry(func(n uint, err error) {\n\t\t\t\tretrySum += 1\n\t\t\t\tif retrySum == 2 {\n\t\t\t\t\tcancel()\n\t\t\t\t}\n\t\t\t}),\n\t\t\tContext(ctx),\n\t\t\tAttempts(0),\n\t\t\tWrapContextErrorWithLastError(true),\n\t\t)\n\t\tassert.ErrorIs(t, err, context.Canceled)\n\t\tassert.ErrorIs(t, err, fooErr{str: \"error 2\"})\n\t})\n\n\tt.Run(\"timed out on retry infinte attempts - wraps context error with last retried function error\", func(t *testing.T) {\n\t\tctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*500)\n\t\tdefer cancel()\n\n\t\tretrySum := 0\n\t\terr := Do(\n\t\t\tfunc() error { return fooErr{str: fmt.Sprintf(\"error %d\", retrySum+1)} },\n\t\t\tOnRetry(func(n uint, err error) {\n\t\t\t\tretrySum += 1\n\t\t\t}),\n\t\t\tContext(ctx),\n\t\t\tAttempts(0),\n\t\t\tWrapContextErrorWithLastError(true),\n\t\t)\n\t\tassert.ErrorIs(t, err, context.DeadlineExceeded)\n\t\tassert.ErrorIs(t, err, fooErr{str: \"error 2\"})\n\t})\n}\n\ntype testTimer struct {\n\tcalled bool\n}\n\nfunc (t *testTimer) After(d time.Duration) <-chan time.Time {\n\tt.called = true\n\treturn time.After(d)\n}\n\nfunc TestTimerInterface(t *testing.T) {\n\tvar timer testTimer\n\terr := Do(\n\t\tfunc() error { return errors.New(\"test\") },\n\t\tAttempts(1),\n\t\tDelay(10*time.Millisecond),\n\t\tMaxDelay(50*time.Millisecond),\n\t\tWithTimer(&timer),\n\t)\n\n\tassert.Error(t, err)\n\n}\n\nfunc TestErrorIs(t *testing.T) {\n\tvar e Error\n\texpectErr := errors.New(\"error\")\n\tclosedErr := os.ErrClosed\n\te = append(e, expectErr)\n\te = append(e, closedErr)\n\n\tassert.True(t, errors.Is(e, expectErr))\n\tassert.True(t, errors.Is(e, closedErr))\n\tassert.False(t, errors.Is(e, errors.New(\"error\")))\n}\n\ntype fooErr struct{ str string }\n\nfunc (e fooErr) Error() string {\n\treturn e.str\n}\n\ntype barErr struct{ str string }\n\nfunc (e barErr) Error() string {\n\treturn e.str\n}\n\nfunc TestErrorAs(t *testing.T) {\n\tvar e Error\n\tfe := fooErr{str: \"foo\"}\n\te = append(e, fe)\n\n\tvar tf fooErr\n\tvar tb barErr\n\n\tassert.True(t, errors.As(e, &tf))\n\tassert.False(t, errors.As(e, &tb))\n\tassert.Equal(t, \"foo\", tf.str)\n}\n\nfunc TestUnwrap(t *testing.T) {\n\ttestError := errors.New(\"test error\")\n\terr := Do(\n\t\tfunc() error {\n\t\t\treturn testError\n\t\t},\n\t\tAttempts(1),\n\t)\n\n\tassert.Error(t, err)\n\tassert.Equal(t, testError, errors.Unwrap(err))\n}\n\nfunc BenchmarkDo(b *testing.B) {\n\ttestError := errors.New(\"test error\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = Do(\n\t\t\tfunc() error {\n\t\t\t\treturn testError\n\t\t\t},\n\t\t\tAttempts(10),\n\t\t\tDelay(0),\n\t\t)\n\t}\n}\n\nfunc BenchmarkDoWithData(b *testing.B) {\n\ttestError := errors.New(\"test error\")\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = DoWithData(\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 0, testError\n\t\t\t},\n\t\t\tAttempts(10),\n\t\t\tDelay(0),\n\t\t)\n\t}\n}\n\nfunc BenchmarkDoNoErrors(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_ = Do(\n\t\t\tfunc() error {\n\t\t\t\treturn nil\n\t\t\t},\n\t\t\tAttempts(10),\n\t\t\tDelay(0),\n\t\t)\n\t}\n}\n\nfunc BenchmarkDoWithDataNoErrors(b *testing.B) {\n\tfor i := 0; i < b.N; i++ {\n\t\t_, _ = DoWithData(\n\t\t\tfunc() (int, error) {\n\t\t\t\treturn 0, nil\n\t\t\t},\n\t\t\tAttempts(10),\n\t\t\tDelay(0),\n\t\t)\n\t}\n}\n\nfunc TestIsRecoverable(t *testing.T) {\n\terr := errors.New(\"err\")\n\tassert.True(t, IsRecoverable(err))\n\n\terr = Unrecoverable(err)\n\tassert.False(t, IsRecoverable(err))\n\n\terr = fmt.Errorf(\"wrapping: %w\", err)\n\tassert.False(t, IsRecoverable(err))\n}\n"
        }
      ]
    }
  ]
}