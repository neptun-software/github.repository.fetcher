{
  "metadata": {
    "timestamp": 1736567227337,
    "page": 822,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vmihailenco/msgpack",
      "stars": 2412,
      "defaultBranch": "v5",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".prettierrc",
          "type": "blob",
          "size": 0.0625,
          "content": "semi: false\nsingleQuote: true\nproseWrap: always\nprintWidth: 100\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3125,
          "content": "sudo: false\nlanguage: go\n\ngo:\n  - 1.15.x\n  - 1.16.x\n  - tip\n\nmatrix:\n  allow_failures:\n    - go: tip\n\nenv:\n  - GO111MODULE=on\n\ngo_import_path: github.com/vmihailenco/msgpack\n\nbefore_install:\n  - curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | sh -s -- -b $(go\n    env GOPATH)/bin v1.31.0\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 2.6435546875,
          "content": "## [5.4.1](https://github.com/vmihailenco/msgpack/compare/v5.4.0...v5.4.1) (2023-10-26)\n\n\n### Bug Fixes\n\n* **reflect:** not assignable to type ([edeaedd](https://github.com/vmihailenco/msgpack/commit/edeaeddb2d51868df8c6ff2d8a218b527aeaf5fd))\n\n\n\n# [5.4.0](https://github.com/vmihailenco/msgpack/compare/v5.3.6...v5.4.0) (2023-10-01)\n\n\n\n## [5.3.6](https://github.com/vmihailenco/msgpack/compare/v5.3.5...v5.3.6) (2023-10-01)\n\n\n### Features\n\n* allow overwriting time.Time parsing from extID 13 (for NodeJS Date) ([9a6b73b](https://github.com/vmihailenco/msgpack/commit/9a6b73b3588fd962d568715f4375e24b089f7066))\n* apply omitEmptyFlag to empty structs ([e5f8d03](https://github.com/vmihailenco/msgpack/commit/e5f8d03c0a1dd9cc571d648cd610305139078de5))\n* support sorted keys for map[string]bool ([690c1fa](https://github.com/vmihailenco/msgpack/commit/690c1fab9814fab4842295ea986111f49850d9a4))\n\n\n\n## [5.3.5](https://github.com/vmihailenco/msgpack/compare/v5.3.4...v5.3.5) (2021-10-22)\n\n- Allow decoding `nil` code as boolean false.\n\n## v5\n\n### Added\n\n- `DecodeMap` is split into `DecodeMap`, `DecodeTypedMap`, and `DecodeUntypedMap`.\n- New msgpack extensions API.\n\n### Changed\n\n- `Reset*` functions also reset flags.\n- `SetMapDecodeFunc` is renamed to `SetMapDecoder`.\n- `StructAsArray` is renamed to `UseArrayEncodedStructs`.\n- `SortMapKeys` is renamed to `SetSortMapKeys`.\n\n### Removed\n\n- `UseJSONTag` is removed. Use `SetCustomStructTag(\"json\")` instead.\n\n## v4\n\n- Encode, Decode, Marshal, and Unmarshal are changed to accept single argument. EncodeMulti and\n  DecodeMulti are added as replacement.\n- Added EncodeInt8/16/32/64 and EncodeUint8/16/32/64.\n- Encoder changed to preserve type of numbers instead of chosing most compact encoding. The old\n  behavior can be achieved with Encoder.UseCompactEncoding.\n\n## v3.3\n\n- `msgpack:\",inline\"` tag is restored to force inlining structs.\n\n## v3.2\n\n- Decoding extension types returns pointer to the value instead of the value. Fixes #153\n\n## v3\n\n- gopkg.in is not supported any more. Update import path to github.com/vmihailenco/msgpack.\n- Msgpack maps are decoded into map[string]interface{} by default.\n- EncodeSliceLen is removed in favor of EncodeArrayLen. DecodeSliceLen is removed in favor of\n  DecodeArrayLen.\n- Embedded structs are automatically inlined where possible.\n- Time is encoded using extension as described in https://github.com/msgpack/msgpack/pull/209. Old\n  format is supported as well.\n- EncodeInt8/16/32/64 is replaced with EncodeInt. EncodeUint8/16/32/64 is replaced with EncodeUint.\n  There should be no performance differences.\n- DecodeInterface can now return int8/16/32 and uint8/16/32.\n- PeekCode returns codes.Code instead of byte.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2919921875,
          "content": "Copyright (c) 2013 The github.com/vmihailenco/msgpack Authors.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.138671875,
          "content": "test:\n\tgo test ./...\n\tgo test ./... -short -race\n\tgo test ./... -run=NONE -bench=. -benchmem\n\tenv GOOS=linux GOARCH=386 go test ./...\n\tgo vet\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.8330078125,
          "content": "# MessagePack encoding for Golang\n\n[![Build Status](https://travis-ci.org/vmihailenco/msgpack.svg)](https://travis-ci.org/vmihailenco/msgpack)\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/vmihailenco/msgpack/v5)](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5)\n[![Documentation](https://img.shields.io/badge/msgpack-documentation-informational)](https://msgpack.uptrace.dev/)\n[![Chat](https://discordapp.com/api/guilds/752070105847955518/widget.png)](https://discord.gg/rWtp5Aj)\n\n> msgpack is brought to you by :star: [**uptrace/uptrace**](https://github.com/uptrace/uptrace).\n> Uptrace is an [open source APM](https://uptrace.dev/get/open-source-apm.html) and blazingly fast\n> [distributed tracing tool](https://get.uptrace.dev/compare/distributed-tracing-tools.html) powered\n> by OpenTelemetry and ClickHouse. Give it a star as well!\n\n## Resources\n\n- [Documentation](https://msgpack.uptrace.dev)\n- [Chat](https://discord.gg/rWtp5Aj)\n- [Reference](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5)\n- [Examples](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#pkg-examples)\n\n## Features\n\n- Primitives, arrays, maps, structs, time.Time and interface{}.\n- Appengine \\*datastore.Key and datastore.Cursor.\n- [CustomEncoder]/[CustomDecoder] interfaces for custom encoding.\n- [Extensions](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#example-RegisterExt) to encode\n  type information.\n- Renaming fields via `msgpack:\"my_field_name\"` and alias via `msgpack:\"alias:another_name\"`.\n- Omitting individual empty fields via `msgpack:\",omitempty\"` tag or all\n  [empty fields in a struct](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#example-Marshal-OmitEmpty).\n- [Map keys sorting](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#Encoder.SetSortMapKeys).\n- Encoding/decoding all\n  [structs as arrays](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#Encoder.UseArrayEncodedStructs)\n  or\n  [individual structs](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#example-Marshal-AsArray).\n- [Encoder.SetCustomStructTag] with [Decoder.SetCustomStructTag] can turn msgpack into drop-in\n  replacement for any tag.\n- Simple but very fast and efficient\n  [queries](https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#example-Decoder.Query).\n\n[customencoder]: https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#CustomEncoder\n[customdecoder]: https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#CustomDecoder\n[encoder.setcustomstructtag]:\n  https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#Encoder.SetCustomStructTag\n[decoder.setcustomstructtag]:\n  https://pkg.go.dev/github.com/vmihailenco/msgpack/v5#Decoder.SetCustomStructTag\n\n## Installation\n\nmsgpack supports 2 last Go versions and requires support for\n[Go modules](https://github.com/golang/go/wiki/Modules). So make sure to initialize a Go module:\n\n```shell\ngo mod init github.com/my/repo\n```\n\nAnd then install msgpack/v5 (note _v5_ in the import; omitting it is a popular mistake):\n\n```shell\ngo get github.com/vmihailenco/msgpack/v5\n```\n\n## Quickstart\n\n```go\nimport \"github.com/vmihailenco/msgpack/v5\"\n\nfunc ExampleMarshal() {\n    type Item struct {\n        Foo string\n    }\n\n    b, err := msgpack.Marshal(&Item{Foo: \"bar\"})\n    if err != nil {\n        panic(err)\n    }\n\n    var item Item\n    err = msgpack.Unmarshal(b, &item)\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(item.Foo)\n    // Output: bar\n}\n```\n\n## See also\n\n- [Golang ORM](https://github.com/uptrace/bun) for PostgreSQL, MySQL, MSSQL, and SQLite\n- [Golang PostgreSQL](https://bun.uptrace.dev/postgres/)\n- [Golang HTTP router](https://github.com/uptrace/bunrouter)\n- [Golang ClickHouse ORM](https://github.com/uptrace/go-clickhouse)\n\n## Contributors\n\nThanks to all the people who already contributed!\n\n<a href=\"https://github.com/vmihailenco/msgpack/graphs/contributors\">\n  <img src=\"https://contributors-img.web.app/image?repo=vmihailenco/msgpack\" />\n</a>\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 7.2802734375,
          "content": "package msgpack_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"math\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vmihailenco/msgpack/v5\"\n)\n\nfunc BenchmarkDiscard(b *testing.B) {\n\tenc := msgpack.NewEncoder(ioutil.Discard)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := enc.Encode(nil); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif err := enc.Encode(\"hello\"); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc benchmarkEncodeDecode(b *testing.B, src, dst interface{}) {\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tdec := msgpack.NewDecoder(&buf)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := enc.Encode(src); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif err := dec.Decode(dst); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc benchmarkJSONEncodeDecode(b *testing.B, src, dst interface{}) {\n\tvar buf bytes.Buffer\n\tenc := json.NewEncoder(&buf)\n\tdec := json.NewDecoder(&buf)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tif err := enc.Encode(src); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif err := dec.Decode(dst); err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkBool(b *testing.B) {\n\tvar dst bool\n\tbenchmarkEncodeDecode(b, true, &dst)\n}\n\nfunc BenchmarkInt0(b *testing.B) {\n\tvar dst int\n\tbenchmarkEncodeDecode(b, 1, &dst)\n}\n\nfunc BenchmarkInt1(b *testing.B) {\n\tvar dst int\n\tbenchmarkEncodeDecode(b, -33, &dst)\n}\n\nfunc BenchmarkInt2(b *testing.B) {\n\tvar dst int\n\tbenchmarkEncodeDecode(b, 128, &dst)\n}\n\nfunc BenchmarkInt4(b *testing.B) {\n\tvar dst int\n\tbenchmarkEncodeDecode(b, 32768, &dst)\n}\n\nfunc BenchmarkInt8(b *testing.B) {\n\tvar dst int\n\tbenchmarkEncodeDecode(b, int64(2147483648), &dst)\n}\n\nfunc BenchmarkInt32(b *testing.B) {\n\tvar dst int32\n\tbenchmarkEncodeDecode(b, int32(0), &dst)\n}\n\nfunc BenchmarkFloat32(b *testing.B) {\n\tvar dst float32\n\tbenchmarkEncodeDecode(b, float32(0), &dst)\n}\n\nfunc BenchmarkFloat32_Max(b *testing.B) {\n\tvar dst float32\n\tbenchmarkEncodeDecode(b, float32(math.MaxFloat32), &dst)\n}\n\nfunc BenchmarkFloat64(b *testing.B) {\n\tvar dst float64\n\tbenchmarkEncodeDecode(b, float64(0), &dst)\n}\n\nfunc BenchmarkFloat64_Max(b *testing.B) {\n\tvar dst float64\n\tbenchmarkEncodeDecode(b, float64(math.MaxFloat64), &dst)\n}\n\nfunc BenchmarkTime(b *testing.B) {\n\tvar dst time.Time\n\tbenchmarkEncodeDecode(b, time.Now(), &dst)\n}\n\nfunc BenchmarkDuration(b *testing.B) {\n\tvar dst time.Duration\n\tbenchmarkEncodeDecode(b, time.Hour, &dst)\n}\n\nfunc BenchmarkByteSlice(b *testing.B) {\n\tsrc := make([]byte, 1024)\n\tvar dst []byte\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkByteArray(b *testing.B) {\n\tvar src [1024]byte\n\tvar dst [1024]byte\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkByteArrayPtr(b *testing.B) {\n\tvar src [1024]byte\n\tvar dst [1024]byte\n\tbenchmarkEncodeDecode(b, &src, &dst)\n}\n\nfunc BenchmarkMapStringString(b *testing.B) {\n\tsrc := map[string]string{\n\t\t\"hello\": \"world\",\n\t\t\"foo\":   \"bar\",\n\t}\n\tvar dst map[string]string\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkMapStringStringPtr(b *testing.B) {\n\tsrc := map[string]string{\n\t\t\"hello\": \"world\",\n\t\t\"foo\":   \"bar\",\n\t}\n\tdst := new(map[string]string)\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkMapStringInterfaceMsgpack(b *testing.B) {\n\tsrc := map[string]interface{}{\n\t\t\"hello\": \"world\",\n\t\t\"foo\":   \"bar\",\n\t\t\"one\":   1111111,\n\t\t\"two\":   2222222,\n\t}\n\tvar dst map[string]interface{}\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkMapStringInterfaceJSON(b *testing.B) {\n\tsrc := map[string]interface{}{\n\t\t\"hello\": \"world\",\n\t\t\"foo\":   \"bar\",\n\t\t\"one\":   1111111,\n\t\t\"two\":   2222222,\n\t}\n\tvar dst map[string]interface{}\n\tbenchmarkJSONEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkMapIntInt(b *testing.B) {\n\tsrc := map[int]int{\n\t\t1: 10,\n\t\t2: 20,\n\t}\n\tvar dst map[int]int\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkStringSlice(b *testing.B) {\n\tsrc := []string{\"hello\", \"world\"}\n\tvar dst []string\n\tbenchmarkEncodeDecode(b, src, &dst)\n}\n\nfunc BenchmarkStringSlicePtr(b *testing.B) {\n\tsrc := []string{\"hello\", \"world\"}\n\tvar dst []string\n\tdstptr := &dst\n\tbenchmarkEncodeDecode(b, src, &dstptr)\n}\n\ntype benchmarkStruct struct {\n\tName      string\n\tAge       int\n\tColors    []string\n\tData      []byte\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n\ntype benchmarkStruct2 struct {\n\tName      string\n\tAge       int\n\tColors    []string\n\tData      []byte\n\tCreatedAt time.Time\n\tUpdatedAt time.Time\n}\n\nvar (\n\t_ msgpack.CustomEncoder = (*benchmarkStruct2)(nil)\n\t_ msgpack.CustomDecoder = (*benchmarkStruct2)(nil)\n)\n\nfunc (s *benchmarkStruct2) EncodeMsgpack(enc *msgpack.Encoder) error {\n\treturn enc.EncodeMulti(\n\t\ts.Name,\n\t\ts.Colors,\n\t\ts.Age,\n\t\ts.Data,\n\t\ts.CreatedAt,\n\t\ts.UpdatedAt,\n\t)\n}\n\nfunc (s *benchmarkStruct2) DecodeMsgpack(dec *msgpack.Decoder) error {\n\treturn dec.DecodeMulti(\n\t\t&s.Name,\n\t\t&s.Colors,\n\t\t&s.Age,\n\t\t&s.Data,\n\t\t&s.CreatedAt,\n\t\t&s.UpdatedAt,\n\t)\n}\n\nfunc structForBenchmark() *benchmarkStruct {\n\treturn &benchmarkStruct{\n\t\tName:      \"Hello World\",\n\t\tColors:    []string{\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\"},\n\t\tAge:       math.MaxInt32,\n\t\tData:      make([]byte, 1024),\n\t\tCreatedAt: time.Now(),\n\t\tUpdatedAt: time.Now(),\n\t}\n}\n\nfunc structForBenchmark2() *benchmarkStruct2 {\n\treturn &benchmarkStruct2{\n\t\tName:      \"Hello World\",\n\t\tColors:    []string{\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"violet\"},\n\t\tAge:       math.MaxInt32,\n\t\tData:      make([]byte, 1024),\n\t\tCreatedAt: time.Now(),\n\t\tUpdatedAt: time.Now(),\n\t}\n}\n\nfunc BenchmarkStructVmihailencoMsgpack(b *testing.B) {\n\tin := structForBenchmark()\n\tout := new(benchmarkStruct)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbuf, err := msgpack.Marshal(in)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\terr = msgpack.Unmarshal(buf, out)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkStructMarshal(b *testing.B) {\n\tin := structForBenchmark()\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err := msgpack.Marshal(in)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkStructUnmarshal(b *testing.B) {\n\tin := structForBenchmark()\n\tbuf, err := msgpack.Marshal(in)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tout := new(benchmarkStruct)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\terr = msgpack.Unmarshal(buf, out)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkStructManual(b *testing.B) {\n\tin := structForBenchmark2()\n\tout := new(benchmarkStruct2)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tbuf, err := msgpack.Marshal(in)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\terr = msgpack.Unmarshal(buf, out)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\ntype benchmarkStructPartially struct {\n\tName string\n\tAge  int\n}\n\nfunc BenchmarkStructUnmarshalPartially(b *testing.B) {\n\tin := structForBenchmark()\n\tbuf, err := msgpack.Marshal(in)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tout := new(benchmarkStructPartially)\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\terr = msgpack.Unmarshal(buf, out)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkQuery(b *testing.B) {\n\tvar records []map[string]interface{}\n\tfor i := 0; i < 1000; i++ {\n\t\trecord := map[string]interface{}{\n\t\t\t\"id\":    int64(i),\n\t\t\t\"attrs\": map[string]interface{}{\"phone\": int64(i)},\n\t\t}\n\t\trecords = append(records, record)\n\t}\n\n\tbs, err := msgpack.Marshal(records)\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\n\tdec := msgpack.NewDecoder(bytes.NewBuffer(bs))\n\n\tb.ResetTimer()\n\n\tfor i := 0; i < b.N; i++ {\n\t\tdec.Reset(bytes.NewBuffer(bs))\n\n\t\tvalues, err := dec.Query(\"10.attrs.phone\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\tif values[0].(int64) != 10 {\n\t\t\tb.Fatalf(\"%v != %d\", values[0], 10)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "commitlint.config.js",
          "type": "blob",
          "size": 0.064453125,
          "content": "module.exports = { extends: ['@commitlint/config-conventional'] }\n"
        },
        {
          "name": "decode.go",
          "type": "blob",
          "size": 14.83984375,
          "content": "package msgpack\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nconst (\n\tbytesAllocLimit = 1 << 20 // 1mb\n\tsliceAllocLimit = 1e6     // 1m elements\n\tmaxMapSize      = 1e6     // 1m elements\n)\n\nconst (\n\tlooseInterfaceDecodingFlag uint32 = 1 << iota\n\tdisallowUnknownFieldsFlag\n\tusePreallocateValues\n\tdisableAllocLimitFlag\n)\n\ntype bufReader interface {\n\tio.Reader\n\tio.ByteScanner\n}\n\n//------------------------------------------------------------------------------\n\nvar decPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn NewDecoder(nil)\n\t},\n}\n\nfunc GetDecoder() *Decoder {\n\treturn decPool.Get().(*Decoder)\n}\n\nfunc PutDecoder(dec *Decoder) {\n\tdec.r = nil\n\tdec.s = nil\n\tdecPool.Put(dec)\n}\n\n//------------------------------------------------------------------------------\n\n// Unmarshal decodes the MessagePack-encoded data and stores the result\n// in the value pointed to by v.\nfunc Unmarshal(data []byte, v interface{}) error {\n\tdec := GetDecoder()\n\tdec.UsePreallocateValues(true)\n\tdec.Reset(bytes.NewReader(data))\n\terr := dec.Decode(v)\n\n\tPutDecoder(dec)\n\n\treturn err\n}\n\n// A Decoder reads and decodes MessagePack values from an input stream.\ntype Decoder struct {\n\tr          io.Reader\n\ts          io.ByteScanner\n\tmapDecoder func(*Decoder) (interface{}, error)\n\tstructTag  string\n\tbuf        []byte\n\trec        []byte\n\tdict       []string\n\tflags      uint32\n}\n\n// NewDecoder returns a new decoder that reads from r.\n//\n// The decoder introduces its own buffering and may read data from r\n// beyond the requested msgpack values. Buffering can be disabled\n// by passing a reader that implements io.ByteScanner interface.\nfunc NewDecoder(r io.Reader) *Decoder {\n\td := new(Decoder)\n\td.Reset(r)\n\treturn d\n}\n\n// Reset discards any buffered data, resets all state, and switches the buffered\n// reader to read from r.\nfunc (d *Decoder) Reset(r io.Reader) {\n\td.ResetDict(r, nil)\n}\n\n// ResetDict is like Reset, but also resets the dict.\nfunc (d *Decoder) ResetDict(r io.Reader, dict []string) {\n\td.ResetReader(r)\n\td.flags = 0\n\td.structTag = \"\"\n\td.dict = dict\n}\n\nfunc (d *Decoder) WithDict(dict []string, fn func(*Decoder) error) error {\n\toldDict := d.dict\n\td.dict = dict\n\terr := fn(d)\n\td.dict = oldDict\n\treturn err\n}\n\nfunc (d *Decoder) ResetReader(r io.Reader) {\n\td.mapDecoder = nil\n\td.dict = nil\n\n\tif br, ok := r.(bufReader); ok {\n\t\td.r = br\n\t\td.s = br\n\t} else if r == nil {\n\t\td.r = nil\n\t\td.s = nil\n\t} else {\n\t\tbr := bufio.NewReader(r)\n\t\td.r = br\n\t\td.s = br\n\t}\n}\n\nfunc (d *Decoder) SetMapDecoder(fn func(*Decoder) (interface{}, error)) {\n\td.mapDecoder = fn\n}\n\n// UseLooseInterfaceDecoding causes decoder to use DecodeInterfaceLoose\n// to decode msgpack value into Go interface{}.\nfunc (d *Decoder) UseLooseInterfaceDecoding(on bool) {\n\tif on {\n\t\td.flags |= looseInterfaceDecodingFlag\n\t} else {\n\t\td.flags &= ^looseInterfaceDecodingFlag\n\t}\n}\n\n// SetCustomStructTag causes the decoder to use the supplied tag as a fallback option\n// if there is no msgpack tag.\nfunc (d *Decoder) SetCustomStructTag(tag string) {\n\td.structTag = tag\n}\n\n// DisallowUnknownFields causes the Decoder to return an error when the destination\n// is a struct and the input contains object keys which do not match any\n// non-ignored, exported fields in the destination.\nfunc (d *Decoder) DisallowUnknownFields(on bool) {\n\tif on {\n\t\td.flags |= disallowUnknownFieldsFlag\n\t} else {\n\t\td.flags &= ^disallowUnknownFieldsFlag\n\t}\n}\n\n// UseInternedStrings enables support for decoding interned strings.\nfunc (d *Decoder) UseInternedStrings(on bool) {\n\tif on {\n\t\td.flags |= useInternedStringsFlag\n\t} else {\n\t\td.flags &= ^useInternedStringsFlag\n\t}\n}\n\n// UsePreallocateValues enables preallocating values in chunks\nfunc (d *Decoder) UsePreallocateValues(on bool) {\n\tif on {\n\t\td.flags |= usePreallocateValues\n\t} else {\n\t\td.flags &= ^usePreallocateValues\n\t}\n}\n\n// DisableAllocLimit enables fully allocating slices/maps when the size is known\nfunc (d *Decoder) DisableAllocLimit(on bool) {\n\tif on {\n\t\td.flags |= disableAllocLimitFlag\n\t} else {\n\t\td.flags &= ^disableAllocLimitFlag\n\t}\n}\n\n// Buffered returns a reader of the data remaining in the Decoder's buffer.\n// The reader is valid until the next call to Decode.\nfunc (d *Decoder) Buffered() io.Reader {\n\treturn d.r\n}\n\n//nolint:gocyclo\nfunc (d *Decoder) Decode(v interface{}) error {\n\tvar err error\n\tswitch v := v.(type) {\n\tcase *string:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeString()\n\t\t\treturn err\n\t\t}\n\tcase *[]byte:\n\t\tif v != nil {\n\t\t\treturn d.decodeBytesPtr(v)\n\t\t}\n\tcase *int:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeInt()\n\t\t\treturn err\n\t\t}\n\tcase *int8:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeInt8()\n\t\t\treturn err\n\t\t}\n\tcase *int16:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeInt16()\n\t\t\treturn err\n\t\t}\n\tcase *int32:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeInt32()\n\t\t\treturn err\n\t\t}\n\tcase *int64:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeInt64()\n\t\t\treturn err\n\t\t}\n\tcase *uint:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeUint()\n\t\t\treturn err\n\t\t}\n\tcase *uint8:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeUint8()\n\t\t\treturn err\n\t\t}\n\tcase *uint16:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeUint16()\n\t\t\treturn err\n\t\t}\n\tcase *uint32:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeUint32()\n\t\t\treturn err\n\t\t}\n\tcase *uint64:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeUint64()\n\t\t\treturn err\n\t\t}\n\tcase *bool:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeBool()\n\t\t\treturn err\n\t\t}\n\tcase *float32:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeFloat32()\n\t\t\treturn err\n\t\t}\n\tcase *float64:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeFloat64()\n\t\t\treturn err\n\t\t}\n\tcase *[]string:\n\t\treturn d.decodeStringSlicePtr(v)\n\tcase *map[string]string:\n\t\treturn d.decodeMapStringStringPtr(v)\n\tcase *map[string]interface{}:\n\t\treturn d.decodeMapStringInterfacePtr(v)\n\tcase *time.Duration:\n\t\tif v != nil {\n\t\t\tvv, err := d.DecodeInt64()\n\t\t\t*v = time.Duration(vv)\n\t\t\treturn err\n\t\t}\n\tcase *time.Time:\n\t\tif v != nil {\n\t\t\t*v, err = d.DecodeTime()\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvv := reflect.ValueOf(v)\n\tif !vv.IsValid() {\n\t\treturn errors.New(\"msgpack: Decode(nil)\")\n\t}\n\tif vv.Kind() != reflect.Ptr {\n\t\treturn fmt.Errorf(\"msgpack: Decode(non-pointer %T)\", v)\n\t}\n\tif vv.IsNil() {\n\t\treturn fmt.Errorf(\"msgpack: Decode(non-settable %T)\", v)\n\t}\n\n\tvv = vv.Elem()\n\tif vv.Kind() == reflect.Interface {\n\t\tif !vv.IsNil() {\n\t\t\tvv = vv.Elem()\n\t\t\tif vv.Kind() != reflect.Ptr {\n\t\t\t\treturn fmt.Errorf(\"msgpack: Decode(non-pointer %s)\", vv.Type().String())\n\t\t\t}\n\t\t}\n\t}\n\n\treturn d.DecodeValue(vv)\n}\n\nfunc (d *Decoder) DecodeMulti(v ...interface{}) error {\n\tfor _, vv := range v {\n\t\tif err := d.Decode(vv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (d *Decoder) decodeInterfaceCond() (interface{}, error) {\n\tif d.flags&looseInterfaceDecodingFlag != 0 {\n\t\treturn d.DecodeInterfaceLoose()\n\t}\n\treturn d.DecodeInterface()\n}\n\nfunc (d *Decoder) DecodeValue(v reflect.Value) error {\n\tdecode := getDecoder(v.Type())\n\treturn decode(d, v)\n}\n\nfunc (d *Decoder) DecodeNil() error {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif c != msgpcode.Nil {\n\t\treturn fmt.Errorf(\"msgpack: invalid code=%x decoding nil\", c)\n\t}\n\treturn nil\n}\n\nfunc (d *Decoder) decodeNilValue(v reflect.Value) error {\n\terr := d.DecodeNil()\n\tif v.IsNil() {\n\t\treturn err\n\t}\n\tif v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tv.Set(reflect.Zero(v.Type()))\n\treturn err\n}\n\nfunc (d *Decoder) DecodeBool() (bool, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn d.bool(c)\n}\n\nfunc (d *Decoder) bool(c byte) (bool, error) {\n\tif c == msgpcode.Nil {\n\t\treturn false, nil\n\t}\n\tif c == msgpcode.False {\n\t\treturn false, nil\n\t}\n\tif c == msgpcode.True {\n\t\treturn true, nil\n\t}\n\treturn false, fmt.Errorf(\"msgpack: invalid code=%x decoding bool\", c)\n}\n\nfunc (d *Decoder) DecodeDuration() (time.Duration, error) {\n\tn, err := d.DecodeInt64()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn time.Duration(n), nil\n}\n\n// DecodeInterface decodes value into interface. It returns following types:\n//   - nil,\n//   - bool,\n//   - int8, int16, int32, int64,\n//   - uint8, uint16, uint32, uint64,\n//   - float32 and float64,\n//   - string,\n//   - []byte,\n//   - slices of any of the above,\n//   - maps of any of the above.\n//\n// DecodeInterface should be used only when you don't know the type of value\n// you are decoding. For example, if you are decoding number it is better to use\n// DecodeInt64 for negative numbers and DecodeUint64 for positive numbers.\nfunc (d *Decoder) DecodeInterface() (interface{}, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif msgpcode.IsFixedNum(c) {\n\t\treturn int8(c), nil\n\t}\n\tif msgpcode.IsFixedMap(c) {\n\t\terr = d.s.UnreadByte()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.decodeMapDefault()\n\t}\n\tif msgpcode.IsFixedArray(c) {\n\t\treturn d.decodeSlice(c)\n\t}\n\tif msgpcode.IsFixedString(c) {\n\t\treturn d.string(c)\n\t}\n\n\tswitch c {\n\tcase msgpcode.Nil:\n\t\treturn nil, nil\n\tcase msgpcode.False, msgpcode.True:\n\t\treturn d.bool(c)\n\tcase msgpcode.Float:\n\t\treturn d.float32(c)\n\tcase msgpcode.Double:\n\t\treturn d.float64(c)\n\tcase msgpcode.Uint8:\n\t\treturn d.uint8()\n\tcase msgpcode.Uint16:\n\t\treturn d.uint16()\n\tcase msgpcode.Uint32:\n\t\treturn d.uint32()\n\tcase msgpcode.Uint64:\n\t\treturn d.uint64()\n\tcase msgpcode.Int8:\n\t\treturn d.int8()\n\tcase msgpcode.Int16:\n\t\treturn d.int16()\n\tcase msgpcode.Int32:\n\t\treturn d.int32()\n\tcase msgpcode.Int64:\n\t\treturn d.int64()\n\tcase msgpcode.Bin8, msgpcode.Bin16, msgpcode.Bin32:\n\t\treturn d.bytes(c, nil)\n\tcase msgpcode.Str8, msgpcode.Str16, msgpcode.Str32:\n\t\treturn d.string(c)\n\tcase msgpcode.Array16, msgpcode.Array32:\n\t\treturn d.decodeSlice(c)\n\tcase msgpcode.Map16, msgpcode.Map32:\n\t\terr = d.s.UnreadByte()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.decodeMapDefault()\n\tcase msgpcode.FixExt1, msgpcode.FixExt2, msgpcode.FixExt4, msgpcode.FixExt8, msgpcode.FixExt16,\n\t\tmsgpcode.Ext8, msgpcode.Ext16, msgpcode.Ext32:\n\t\treturn d.decodeInterfaceExt(c)\n\t}\n\n\treturn 0, fmt.Errorf(\"msgpack: unknown code %x decoding interface{}\", c)\n}\n\n// DecodeInterfaceLoose is like DecodeInterface except that:\n//   - int8, int16, and int32 are converted to int64,\n//   - uint8, uint16, and uint32 are converted to uint64,\n//   - float32 is converted to float64.\n//   - []byte is converted to string.\nfunc (d *Decoder) DecodeInterfaceLoose() (interface{}, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif msgpcode.IsFixedNum(c) {\n\t\treturn int64(int8(c)), nil\n\t}\n\tif msgpcode.IsFixedMap(c) {\n\t\terr = d.s.UnreadByte()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.decodeMapDefault()\n\t}\n\tif msgpcode.IsFixedArray(c) {\n\t\treturn d.decodeSlice(c)\n\t}\n\tif msgpcode.IsFixedString(c) {\n\t\treturn d.string(c)\n\t}\n\n\tswitch c {\n\tcase msgpcode.Nil:\n\t\treturn nil, nil\n\tcase msgpcode.False, msgpcode.True:\n\t\treturn d.bool(c)\n\tcase msgpcode.Float, msgpcode.Double:\n\t\treturn d.float64(c)\n\tcase msgpcode.Uint8, msgpcode.Uint16, msgpcode.Uint32, msgpcode.Uint64:\n\t\treturn d.uint(c)\n\tcase msgpcode.Int8, msgpcode.Int16, msgpcode.Int32, msgpcode.Int64:\n\t\treturn d.int(c)\n\tcase msgpcode.Str8, msgpcode.Str16, msgpcode.Str32,\n\t\tmsgpcode.Bin8, msgpcode.Bin16, msgpcode.Bin32:\n\t\treturn d.string(c)\n\tcase msgpcode.Array16, msgpcode.Array32:\n\t\treturn d.decodeSlice(c)\n\tcase msgpcode.Map16, msgpcode.Map32:\n\t\terr = d.s.UnreadByte()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn d.decodeMapDefault()\n\tcase msgpcode.FixExt1, msgpcode.FixExt2, msgpcode.FixExt4, msgpcode.FixExt8, msgpcode.FixExt16,\n\t\tmsgpcode.Ext8, msgpcode.Ext16, msgpcode.Ext32:\n\t\treturn d.decodeInterfaceExt(c)\n\t}\n\n\treturn 0, fmt.Errorf(\"msgpack: unknown code %x decoding interface{}\", c)\n}\n\n// Skip skips next value.\nfunc (d *Decoder) Skip() error {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif msgpcode.IsFixedNum(c) {\n\t\treturn nil\n\t}\n\tif msgpcode.IsFixedMap(c) {\n\t\treturn d.skipMap(c)\n\t}\n\tif msgpcode.IsFixedArray(c) {\n\t\treturn d.skipSlice(c)\n\t}\n\tif msgpcode.IsFixedString(c) {\n\t\treturn d.skipBytes(c)\n\t}\n\n\tswitch c {\n\tcase msgpcode.Nil, msgpcode.False, msgpcode.True:\n\t\treturn nil\n\tcase msgpcode.Uint8, msgpcode.Int8:\n\t\treturn d.skipN(1)\n\tcase msgpcode.Uint16, msgpcode.Int16:\n\t\treturn d.skipN(2)\n\tcase msgpcode.Uint32, msgpcode.Int32, msgpcode.Float:\n\t\treturn d.skipN(4)\n\tcase msgpcode.Uint64, msgpcode.Int64, msgpcode.Double:\n\t\treturn d.skipN(8)\n\tcase msgpcode.Bin8, msgpcode.Bin16, msgpcode.Bin32:\n\t\treturn d.skipBytes(c)\n\tcase msgpcode.Str8, msgpcode.Str16, msgpcode.Str32:\n\t\treturn d.skipBytes(c)\n\tcase msgpcode.Array16, msgpcode.Array32:\n\t\treturn d.skipSlice(c)\n\tcase msgpcode.Map16, msgpcode.Map32:\n\t\treturn d.skipMap(c)\n\tcase msgpcode.FixExt1, msgpcode.FixExt2, msgpcode.FixExt4, msgpcode.FixExt8, msgpcode.FixExt16,\n\t\tmsgpcode.Ext8, msgpcode.Ext16, msgpcode.Ext32:\n\t\treturn d.skipExt(c)\n\t}\n\n\treturn fmt.Errorf(\"msgpack: unknown code %x\", c)\n}\n\nfunc (d *Decoder) DecodeRaw() (RawMessage, error) {\n\td.rec = make([]byte, 0)\n\tif err := d.Skip(); err != nil {\n\t\treturn nil, err\n\t}\n\tmsg := RawMessage(d.rec)\n\td.rec = nil\n\treturn msg, nil\n}\n\n// PeekCode returns the next MessagePack code without advancing the reader.\n// Subpackage msgpack/codes defines the list of available msgpcode.\nfunc (d *Decoder) PeekCode() (byte, error) {\n\tc, err := d.s.ReadByte()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn c, d.s.UnreadByte()\n}\n\n// ReadFull reads exactly len(buf) bytes into the buf.\nfunc (d *Decoder) ReadFull(buf []byte) error {\n\t_, err := readN(d.r, buf, len(buf))\n\treturn err\n}\n\nfunc (d *Decoder) hasNilCode() bool {\n\tcode, err := d.PeekCode()\n\treturn err == nil && code == msgpcode.Nil\n}\n\nfunc (d *Decoder) readCode() (byte, error) {\n\tc, err := d.s.ReadByte()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tif d.rec != nil {\n\t\td.rec = append(d.rec, c)\n\t}\n\treturn c, nil\n}\n\nfunc (d *Decoder) readFull(b []byte) error {\n\t_, err := io.ReadFull(d.r, b)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif d.rec != nil {\n\t\td.rec = append(d.rec, b...)\n\t}\n\treturn nil\n}\n\nfunc (d *Decoder) readN(n int) ([]byte, error) {\n\tvar err error\n\tif d.flags&disableAllocLimitFlag != 0 {\n\t\td.buf, err = readN(d.r, d.buf, n)\n\t} else {\n\t\td.buf, err = readNGrow(d.r, d.buf, n)\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif d.rec != nil {\n\t\t// TODO: read directly into d.rec?\n\t\td.rec = append(d.rec, d.buf...)\n\t}\n\treturn d.buf, nil\n}\n\nfunc readN(r io.Reader, b []byte, n int) ([]byte, error) {\n\tif b == nil {\n\t\tif n == 0 {\n\t\t\treturn make([]byte, 0), nil\n\t\t}\n\t\tb = make([]byte, 0, n)\n\t}\n\n\tif n > cap(b) {\n\t\tb = append(b, make([]byte, n-len(b))...)\n\t} else if n <= cap(b) {\n\t\tb = b[:n]\n\t}\n\n\t_, err := io.ReadFull(r, b)\n\treturn b, err\n}\n\nfunc readNGrow(r io.Reader, b []byte, n int) ([]byte, error) {\n\tif b == nil {\n\t\tif n == 0 {\n\t\t\treturn make([]byte, 0), nil\n\t\t}\n\t\tswitch {\n\t\tcase n < 64:\n\t\t\tb = make([]byte, 0, 64)\n\t\tcase n <= bytesAllocLimit:\n\t\t\tb = make([]byte, 0, n)\n\t\tdefault:\n\t\t\tb = make([]byte, 0, bytesAllocLimit)\n\t\t}\n\t}\n\n\tif n <= cap(b) {\n\t\tb = b[:n]\n\t\t_, err := io.ReadFull(r, b)\n\t\treturn b, err\n\t}\n\tb = b[:cap(b)]\n\n\tvar pos int\n\tfor {\n\t\talloc := min(n-len(b), bytesAllocLimit)\n\t\tb = append(b, make([]byte, alloc)...)\n\n\t\t_, err := io.ReadFull(r, b[pos:])\n\t\tif err != nil {\n\t\t\treturn b, err\n\t\t}\n\n\t\tif len(b) == n {\n\t\t\tbreak\n\t\t}\n\t\tpos = len(b)\n\t}\n\n\treturn b, nil\n}\n\nfunc min(a, b int) int { //nolint:unparam\n\tif a <= b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "decode_map.go",
          "type": "blob",
          "size": 6.541015625,
          "content": "package msgpack\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nvar errArrayStruct = errors.New(\"msgpack: number of fields in array-encoded struct has changed\")\n\nvar (\n\tmapStringStringPtrType = reflect.TypeOf((*map[string]string)(nil))\n\tmapStringStringType    = mapStringStringPtrType.Elem()\n\tmapStringBoolPtrType   = reflect.TypeOf((*map[string]bool)(nil))\n\tmapStringBoolType      = mapStringBoolPtrType.Elem()\n)\n\nvar (\n\tmapStringInterfacePtrType = reflect.TypeOf((*map[string]interface{})(nil))\n\tmapStringInterfaceType    = mapStringInterfacePtrType.Elem()\n)\n\nfunc decodeMapValue(d *Decoder, v reflect.Value) error {\n\tn, err := d.DecodeMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ttyp := v.Type()\n\tif n == -1 {\n\t\tv.Set(reflect.Zero(typ))\n\t\treturn nil\n\t}\n\n\tif v.IsNil() {\n\t\tln := n\n\t\tif d.flags&disableAllocLimitFlag == 0 {\n\t\t\tln = min(ln, maxMapSize)\n\t\t}\n\t\tv.Set(reflect.MakeMapWithSize(typ, ln))\n\t}\n\tif n == 0 {\n\t\treturn nil\n\t}\n\n\treturn d.decodeTypedMapValue(v, n)\n}\n\nfunc (d *Decoder) decodeMapDefault() (interface{}, error) {\n\tif d.mapDecoder != nil {\n\t\treturn d.mapDecoder(d)\n\t}\n\treturn d.DecodeMap()\n}\n\n// DecodeMapLen decodes map length. Length is -1 when map is nil.\nfunc (d *Decoder) DecodeMapLen() (int, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tif msgpcode.IsExt(c) {\n\t\tif err = d.skipExtHeader(c); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\tc, err = d.readCode()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn d.mapLen(c)\n}\n\nfunc (d *Decoder) mapLen(c byte) (int, error) {\n\tif c == msgpcode.Nil {\n\t\treturn -1, nil\n\t}\n\tif c >= msgpcode.FixedMapLow && c <= msgpcode.FixedMapHigh {\n\t\treturn int(c & msgpcode.FixedMapMask), nil\n\t}\n\tif c == msgpcode.Map16 {\n\t\tsize, err := d.uint16()\n\t\treturn int(size), err\n\t}\n\tif c == msgpcode.Map32 {\n\t\tsize, err := d.uint32()\n\t\treturn int(size), err\n\t}\n\treturn 0, unexpectedCodeError{code: c, hint: \"map length\"}\n}\n\nfunc decodeMapStringStringValue(d *Decoder, v reflect.Value) error {\n\tmptr := v.Addr().Convert(mapStringStringPtrType).Interface().(*map[string]string)\n\treturn d.decodeMapStringStringPtr(mptr)\n}\n\nfunc (d *Decoder) decodeMapStringStringPtr(ptr *map[string]string) error {\n\tsize, err := d.DecodeMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif size == -1 {\n\t\t*ptr = nil\n\t\treturn nil\n\t}\n\n\tm := *ptr\n\tif m == nil {\n\t\tln := size\n\t\tif d.flags&disableAllocLimitFlag == 0 {\n\t\t\tln = min(size, maxMapSize)\n\t\t}\n\t\t*ptr = make(map[string]string, ln)\n\t\tm = *ptr\n\t}\n\n\tfor i := 0; i < size; i++ {\n\t\tmk, err := d.DecodeString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tmv, err := d.DecodeString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tm[mk] = mv\n\t}\n\n\treturn nil\n}\n\nfunc decodeMapStringInterfaceValue(d *Decoder, v reflect.Value) error {\n\tptr := v.Addr().Convert(mapStringInterfacePtrType).Interface().(*map[string]interface{})\n\treturn d.decodeMapStringInterfacePtr(ptr)\n}\n\nfunc (d *Decoder) decodeMapStringInterfacePtr(ptr *map[string]interface{}) error {\n\tm, err := d.DecodeMap()\n\tif err != nil {\n\t\treturn err\n\t}\n\t*ptr = m\n\treturn nil\n}\n\nfunc (d *Decoder) DecodeMap() (map[string]interface{}, error) {\n\tn, err := d.DecodeMapLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif n == -1 {\n\t\treturn nil, nil\n\t}\n\n\tm := make(map[string]interface{}, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tmk, err := d.DecodeString()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tmv, err := d.decodeInterfaceCond()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tm[mk] = mv\n\t}\n\n\treturn m, nil\n}\n\nfunc (d *Decoder) DecodeUntypedMap() (map[interface{}]interface{}, error) {\n\tn, err := d.DecodeMapLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif n == -1 {\n\t\treturn nil, nil\n\t}\n\n\tm := make(map[interface{}]interface{}, n)\n\n\tfor i := 0; i < n; i++ {\n\t\tmk, err := d.decodeInterfaceCond()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tmv, err := d.decodeInterfaceCond()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tm[mk] = mv\n\t}\n\n\treturn m, nil\n}\n\n// DecodeTypedMap decodes a typed map. Typed map is a map that has a fixed type for keys and values.\n// Key and value types may be different.\nfunc (d *Decoder) DecodeTypedMap() (interface{}, error) {\n\tn, err := d.DecodeMapLen()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif n <= 0 {\n\t\treturn nil, nil\n\t}\n\n\tkey, err := d.decodeInterfaceCond()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalue, err := d.decodeInterfaceCond()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeyType := reflect.TypeOf(key)\n\tvalueType := reflect.TypeOf(value)\n\n\tif !keyType.Comparable() {\n\t\treturn nil, fmt.Errorf(\"msgpack: unsupported map key: %s\", keyType.String())\n\t}\n\n\tmapType := reflect.MapOf(keyType, valueType)\n\n\tln := n\n\tif d.flags&disableAllocLimitFlag == 0 {\n\t\tln = min(ln, maxMapSize)\n\t}\n\n\tmapValue := reflect.MakeMapWithSize(mapType, ln)\n\tmapValue.SetMapIndex(reflect.ValueOf(key), reflect.ValueOf(value))\n\n\tn--\n\tif err := d.decodeTypedMapValue(mapValue, n); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn mapValue.Interface(), nil\n}\n\nfunc (d *Decoder) decodeTypedMapValue(v reflect.Value, n int) error {\n\tvar (\n\t\ttyp       = v.Type()\n\t\tkeyType   = typ.Key()\n\t\tvalueType = typ.Elem()\n\t)\n\tfor i := 0; i < n; i++ {\n\t\tmk := d.newValue(keyType).Elem()\n\t\tif err := d.DecodeValue(mk); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmv := d.newValue(valueType).Elem()\n\t\tif err := d.DecodeValue(mv); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tv.SetMapIndex(mk, mv)\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) skipMap(c byte) error {\n\tn, err := d.mapLen(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < n; i++ {\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc decodeStructValue(d *Decoder, v reflect.Value) error {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tn, err := d.mapLen(c)\n\tif err == nil {\n\t\treturn d.decodeStruct(v, n)\n\t}\n\n\tvar err2 error\n\tn, err2 = d.arrayLen(c)\n\tif err2 != nil {\n\t\treturn err\n\t}\n\n\tif n <= 0 {\n\t\tv.Set(reflect.Zero(v.Type()))\n\t\treturn nil\n\t}\n\n\tfields := structs.Fields(v.Type(), d.structTag)\n\tif n != len(fields.List) {\n\t\treturn errArrayStruct\n\t}\n\n\tfor _, f := range fields.List {\n\t\tif err := f.DecodeValue(d, v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) decodeStruct(v reflect.Value, n int) error {\n\tif n == -1 {\n\t\tv.Set(reflect.Zero(v.Type()))\n\t\treturn nil\n\t}\n\n\tfields := structs.Fields(v.Type(), d.structTag)\n\tfor i := 0; i < n; i++ {\n\t\tname, err := d.decodeStringTemp()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif f := fields.Map[name]; f != nil {\n\t\t\tif err := f.DecodeValue(d, v); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif d.flags&disallowUnknownFieldsFlag != 0 {\n\t\t\treturn fmt.Errorf(\"msgpack: unknown field %q\", name)\n\t\t}\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "decode_number.go",
          "type": "blob",
          "size": 5.6025390625,
          "content": "package msgpack\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nfunc (d *Decoder) skipN(n int) error {\n\t_, err := d.readN(n)\n\treturn err\n}\n\nfunc (d *Decoder) uint8() (uint8, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn c, nil\n}\n\nfunc (d *Decoder) int8() (int8, error) {\n\tn, err := d.uint8()\n\treturn int8(n), err\n}\n\nfunc (d *Decoder) uint16() (uint16, error) {\n\tb, err := d.readN(2)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn (uint16(b[0]) << 8) | uint16(b[1]), nil\n}\n\nfunc (d *Decoder) int16() (int16, error) {\n\tn, err := d.uint16()\n\treturn int16(n), err\n}\n\nfunc (d *Decoder) uint32() (uint32, error) {\n\tb, err := d.readN(4)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn := (uint32(b[0]) << 24) |\n\t\t(uint32(b[1]) << 16) |\n\t\t(uint32(b[2]) << 8) |\n\t\tuint32(b[3])\n\treturn n, nil\n}\n\nfunc (d *Decoder) int32() (int32, error) {\n\tn, err := d.uint32()\n\treturn int32(n), err\n}\n\nfunc (d *Decoder) uint64() (uint64, error) {\n\tb, err := d.readN(8)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\tn := (uint64(b[0]) << 56) |\n\t\t(uint64(b[1]) << 48) |\n\t\t(uint64(b[2]) << 40) |\n\t\t(uint64(b[3]) << 32) |\n\t\t(uint64(b[4]) << 24) |\n\t\t(uint64(b[5]) << 16) |\n\t\t(uint64(b[6]) << 8) |\n\t\tuint64(b[7])\n\treturn n, nil\n}\n\nfunc (d *Decoder) int64() (int64, error) {\n\tn, err := d.uint64()\n\treturn int64(n), err\n}\n\n// DecodeUint64 decodes msgpack int8/16/32/64 and uint8/16/32/64\n// into Go uint64.\nfunc (d *Decoder) DecodeUint64() (uint64, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.uint(c)\n}\n\nfunc (d *Decoder) uint(c byte) (uint64, error) {\n\tif c == msgpcode.Nil {\n\t\treturn 0, nil\n\t}\n\tif msgpcode.IsFixedNum(c) {\n\t\treturn uint64(int8(c)), nil\n\t}\n\tswitch c {\n\tcase msgpcode.Uint8:\n\t\tn, err := d.uint8()\n\t\treturn uint64(n), err\n\tcase msgpcode.Int8:\n\t\tn, err := d.int8()\n\t\treturn uint64(n), err\n\tcase msgpcode.Uint16:\n\t\tn, err := d.uint16()\n\t\treturn uint64(n), err\n\tcase msgpcode.Int16:\n\t\tn, err := d.int16()\n\t\treturn uint64(n), err\n\tcase msgpcode.Uint32:\n\t\tn, err := d.uint32()\n\t\treturn uint64(n), err\n\tcase msgpcode.Int32:\n\t\tn, err := d.int32()\n\t\treturn uint64(n), err\n\tcase msgpcode.Uint64, msgpcode.Int64:\n\t\treturn d.uint64()\n\t}\n\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding uint64\", c)\n}\n\n// DecodeInt64 decodes msgpack int8/16/32/64 and uint8/16/32/64\n// into Go int64.\nfunc (d *Decoder) DecodeInt64() (int64, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.int(c)\n}\n\nfunc (d *Decoder) int(c byte) (int64, error) {\n\tif c == msgpcode.Nil {\n\t\treturn 0, nil\n\t}\n\tif msgpcode.IsFixedNum(c) {\n\t\treturn int64(int8(c)), nil\n\t}\n\tswitch c {\n\tcase msgpcode.Uint8:\n\t\tn, err := d.uint8()\n\t\treturn int64(n), err\n\tcase msgpcode.Int8:\n\t\tn, err := d.uint8()\n\t\treturn int64(int8(n)), err\n\tcase msgpcode.Uint16:\n\t\tn, err := d.uint16()\n\t\treturn int64(n), err\n\tcase msgpcode.Int16:\n\t\tn, err := d.uint16()\n\t\treturn int64(int16(n)), err\n\tcase msgpcode.Uint32:\n\t\tn, err := d.uint32()\n\t\treturn int64(n), err\n\tcase msgpcode.Int32:\n\t\tn, err := d.uint32()\n\t\treturn int64(int32(n)), err\n\tcase msgpcode.Uint64, msgpcode.Int64:\n\t\tn, err := d.uint64()\n\t\treturn int64(n), err\n\t}\n\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding int64\", c)\n}\n\nfunc (d *Decoder) DecodeFloat32() (float32, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.float32(c)\n}\n\nfunc (d *Decoder) float32(c byte) (float32, error) {\n\tif c == msgpcode.Float {\n\t\tn, err := d.uint32()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn math.Float32frombits(n), nil\n\t}\n\n\tn, err := d.int(c)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding float32\", c)\n\t}\n\treturn float32(n), nil\n}\n\n// DecodeFloat64 decodes msgpack float32/64 into Go float64.\nfunc (d *Decoder) DecodeFloat64() (float64, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.float64(c)\n}\n\nfunc (d *Decoder) float64(c byte) (float64, error) {\n\tswitch c {\n\tcase msgpcode.Float:\n\t\tn, err := d.float32(c)\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn float64(n), nil\n\tcase msgpcode.Double:\n\t\tn, err := d.uint64()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn math.Float64frombits(n), nil\n\t}\n\n\tn, err := d.int(c)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding float32\", c)\n\t}\n\treturn float64(n), nil\n}\n\nfunc (d *Decoder) DecodeUint() (uint, error) {\n\tn, err := d.DecodeUint64()\n\treturn uint(n), err\n}\n\nfunc (d *Decoder) DecodeUint8() (uint8, error) {\n\tn, err := d.DecodeUint64()\n\treturn uint8(n), err\n}\n\nfunc (d *Decoder) DecodeUint16() (uint16, error) {\n\tn, err := d.DecodeUint64()\n\treturn uint16(n), err\n}\n\nfunc (d *Decoder) DecodeUint32() (uint32, error) {\n\tn, err := d.DecodeUint64()\n\treturn uint32(n), err\n}\n\nfunc (d *Decoder) DecodeInt() (int, error) {\n\tn, err := d.DecodeInt64()\n\treturn int(n), err\n}\n\nfunc (d *Decoder) DecodeInt8() (int8, error) {\n\tn, err := d.DecodeInt64()\n\treturn int8(n), err\n}\n\nfunc (d *Decoder) DecodeInt16() (int16, error) {\n\tn, err := d.DecodeInt64()\n\treturn int16(n), err\n}\n\nfunc (d *Decoder) DecodeInt32() (int32, error) {\n\tn, err := d.DecodeInt64()\n\treturn int32(n), err\n}\n\nfunc decodeFloat32Value(d *Decoder, v reflect.Value) error {\n\tf, err := d.DecodeFloat32()\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.SetFloat(float64(f))\n\treturn nil\n}\n\nfunc decodeFloat64Value(d *Decoder, v reflect.Value) error {\n\tf, err := d.DecodeFloat64()\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.SetFloat(f)\n\treturn nil\n}\n\nfunc decodeInt64Value(d *Decoder, v reflect.Value) error {\n\tn, err := d.DecodeInt64()\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.SetInt(n)\n\treturn nil\n}\n\nfunc decodeUint64Value(d *Decoder, v reflect.Value) error {\n\tn, err := d.DecodeUint64()\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.SetUint(n)\n\treturn nil\n}\n"
        },
        {
          "name": "decode_query.go",
          "type": "blob",
          "size": 2.626953125,
          "content": "package msgpack\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\ntype queryResult struct {\n\tquery       string\n\tkey         string\n\tvalues      []interface{}\n\thasAsterisk bool\n}\n\nfunc (q *queryResult) nextKey() {\n\tind := strings.IndexByte(q.query, '.')\n\tif ind == -1 {\n\t\tq.key = q.query\n\t\tq.query = \"\"\n\t\treturn\n\t}\n\tq.key = q.query[:ind]\n\tq.query = q.query[ind+1:]\n}\n\n// Query extracts data specified by the query from the msgpack stream skipping\n// any other data. Query consists of map keys and array indexes separated with dot,\n// e.g. key1.0.key2.\nfunc (d *Decoder) Query(query string) ([]interface{}, error) {\n\tres := queryResult{\n\t\tquery: query,\n\t}\n\tif err := d.query(&res); err != nil {\n\t\treturn nil, err\n\t}\n\treturn res.values, nil\n}\n\nfunc (d *Decoder) query(q *queryResult) error {\n\tq.nextKey()\n\tif q.key == \"\" {\n\t\tv, err := d.decodeInterfaceCond()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tq.values = append(q.values, v)\n\t\treturn nil\n\t}\n\n\tcode, err := d.PeekCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch {\n\tcase code == msgpcode.Map16 || code == msgpcode.Map32 || msgpcode.IsFixedMap(code):\n\t\terr = d.queryMapKey(q)\n\tcase code == msgpcode.Array16 || code == msgpcode.Array32 || msgpcode.IsFixedArray(code):\n\t\terr = d.queryArrayIndex(q)\n\tdefault:\n\t\terr = fmt.Errorf(\"msgpack: unsupported code=%x decoding key=%q\", code, q.key)\n\t}\n\treturn err\n}\n\nfunc (d *Decoder) queryMapKey(q *queryResult) error {\n\tn, err := d.DecodeMapLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n == -1 {\n\t\treturn nil\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tkey, err := d.decodeStringTemp()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif key == q.key {\n\t\t\tif err := d.query(q); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif q.hasAsterisk {\n\t\t\t\treturn d.skipNext((n - i - 1) * 2)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) queryArrayIndex(q *queryResult) error {\n\tn, err := d.DecodeArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n == -1 {\n\t\treturn nil\n\t}\n\n\tif q.key == \"*\" {\n\t\tq.hasAsterisk = true\n\n\t\tquery := q.query\n\t\tfor i := 0; i < n; i++ {\n\t\t\tq.query = query\n\t\t\tif err := d.query(q); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tq.hasAsterisk = false\n\t\treturn nil\n\t}\n\n\tind, err := strconv.Atoi(q.key)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tif i == ind {\n\t\t\tif err := d.query(q); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif q.hasAsterisk {\n\t\t\t\treturn d.skipNext(n - i - 1)\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) skipNext(n int) error {\n\tfor i := 0; i < n; i++ {\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "decode_slice.go",
          "type": "blob",
          "size": 3.5634765625,
          "content": "package msgpack\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nvar sliceStringPtrType = reflect.TypeOf((*[]string)(nil))\n\n// DecodeArrayLen decodes array length. Length is -1 when array is nil.\nfunc (d *Decoder) DecodeArrayLen() (int, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.arrayLen(c)\n}\n\nfunc (d *Decoder) arrayLen(c byte) (int, error) {\n\tif c == msgpcode.Nil {\n\t\treturn -1, nil\n\t} else if c >= msgpcode.FixedArrayLow && c <= msgpcode.FixedArrayHigh {\n\t\treturn int(c & msgpcode.FixedArrayMask), nil\n\t}\n\tswitch c {\n\tcase msgpcode.Array16:\n\t\tn, err := d.uint16()\n\t\treturn int(n), err\n\tcase msgpcode.Array32:\n\t\tn, err := d.uint32()\n\t\treturn int(n), err\n\t}\n\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding array length\", c)\n}\n\nfunc decodeStringSliceValue(d *Decoder, v reflect.Value) error {\n\tptr := v.Addr().Convert(sliceStringPtrType).Interface().(*[]string)\n\treturn d.decodeStringSlicePtr(ptr)\n}\n\nfunc (d *Decoder) decodeStringSlicePtr(ptr *[]string) error {\n\tn, err := d.DecodeArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n == -1 {\n\t\treturn nil\n\t}\n\n\tss := makeStrings(*ptr, n, d.flags&disableAllocLimitFlag != 0)\n\tfor i := 0; i < n; i++ {\n\t\ts, err := d.DecodeString()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tss = append(ss, s)\n\t}\n\t*ptr = ss\n\n\treturn nil\n}\n\nfunc makeStrings(s []string, n int, noLimit bool) []string {\n\tif !noLimit && n > sliceAllocLimit {\n\t\tn = sliceAllocLimit\n\t}\n\n\tif s == nil {\n\t\treturn make([]string, 0, n)\n\t}\n\n\tif cap(s) >= n {\n\t\treturn s[:0]\n\t}\n\n\ts = s[:cap(s)]\n\ts = append(s, make([]string, n-len(s))...)\n\treturn s[:0]\n}\n\nfunc decodeSliceValue(d *Decoder, v reflect.Value) error {\n\tn, err := d.DecodeArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif n == -1 {\n\t\tv.Set(reflect.Zero(v.Type()))\n\t\treturn nil\n\t}\n\tif n == 0 && v.IsNil() {\n\t\tv.Set(reflect.MakeSlice(v.Type(), 0, 0))\n\t\treturn nil\n\t}\n\n\tif v.Cap() >= n {\n\t\tv.Set(v.Slice(0, n))\n\t} else if v.Len() < v.Cap() {\n\t\tv.Set(v.Slice(0, v.Cap()))\n\t}\n\n\tnoLimit := d.flags&disableAllocLimitFlag != 1\n\n\tif noLimit && n > v.Len() {\n\t\tv.Set(growSliceValue(v, n, noLimit))\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tif !noLimit && i >= v.Len() {\n\t\t\tv.Set(growSliceValue(v, n, noLimit))\n\t\t}\n\n\t\telem := v.Index(i)\n\t\tif err := d.DecodeValue(elem); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc growSliceValue(v reflect.Value, n int, noLimit bool) reflect.Value {\n\tdiff := n - v.Len()\n\tif !noLimit && diff > sliceAllocLimit {\n\t\tdiff = sliceAllocLimit\n\t}\n\tv = reflect.AppendSlice(v, reflect.MakeSlice(v.Type(), diff, diff))\n\treturn v\n}\n\nfunc decodeArrayValue(d *Decoder, v reflect.Value) error {\n\tn, err := d.DecodeArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif n == -1 {\n\t\treturn nil\n\t}\n\tif n > v.Len() {\n\t\treturn fmt.Errorf(\"%s len is %d, but msgpack has %d elements\", v.Type(), v.Len(), n)\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tsv := v.Index(i)\n\t\tif err := d.DecodeValue(sv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (d *Decoder) DecodeSlice() ([]interface{}, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn d.decodeSlice(c)\n}\n\nfunc (d *Decoder) decodeSlice(c byte) ([]interface{}, error) {\n\tn, err := d.arrayLen(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif n == -1 {\n\t\treturn nil, nil\n\t}\n\n\ts := make([]interface{}, 0, n)\n\tfor i := 0; i < n; i++ {\n\t\tv, err := d.decodeInterfaceCond()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ts = append(s, v)\n\t}\n\n\treturn s, nil\n}\n\nfunc (d *Decoder) skipSlice(c byte) error {\n\tn, err := d.arrayLen(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor i := 0; i < n; i++ {\n\t\tif err := d.Skip(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "decode_string.go",
          "type": "blob",
          "size": 3.203125,
          "content": "package msgpack\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nfunc (d *Decoder) bytesLen(c byte) (int, error) {\n\tif c == msgpcode.Nil {\n\t\treturn -1, nil\n\t}\n\n\tif msgpcode.IsFixedString(c) {\n\t\treturn int(c & msgpcode.FixedStrMask), nil\n\t}\n\n\tswitch c {\n\tcase msgpcode.Str8, msgpcode.Bin8:\n\t\tn, err := d.uint8()\n\t\treturn int(n), err\n\tcase msgpcode.Str16, msgpcode.Bin16:\n\t\tn, err := d.uint16()\n\t\treturn int(n), err\n\tcase msgpcode.Str32, msgpcode.Bin32:\n\t\tn, err := d.uint32()\n\t\treturn int(n), err\n\t}\n\n\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding string/bytes length\", c)\n}\n\nfunc (d *Decoder) DecodeString() (string, error) {\n\tif intern := d.flags&useInternedStringsFlag != 0; intern || len(d.dict) > 0 {\n\t\treturn d.decodeInternedString(intern)\n\t}\n\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn d.string(c)\n}\n\nfunc (d *Decoder) string(c byte) (string, error) {\n\tn, err := d.bytesLen(c)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn d.stringWithLen(n)\n}\n\nfunc (d *Decoder) stringWithLen(n int) (string, error) {\n\tif n <= 0 {\n\t\treturn \"\", nil\n\t}\n\tb, err := d.readN(n)\n\treturn string(b), err\n}\n\nfunc decodeStringValue(d *Decoder, v reflect.Value) error {\n\ts, err := d.DecodeString()\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.SetString(s)\n\treturn nil\n}\n\nfunc (d *Decoder) DecodeBytesLen() (int, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\treturn d.bytesLen(c)\n}\n\nfunc (d *Decoder) DecodeBytes() ([]byte, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn d.bytes(c, nil)\n}\n\nfunc (d *Decoder) bytes(c byte, b []byte) ([]byte, error) {\n\tn, err := d.bytesLen(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif n == -1 {\n\t\treturn nil, nil\n\t}\n\treturn readN(d.r, b, n)\n}\n\nfunc (d *Decoder) decodeStringTemp() (string, error) {\n\tif intern := d.flags&useInternedStringsFlag != 0; intern || len(d.dict) > 0 {\n\t\treturn d.decodeInternedString(intern)\n\t}\n\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tn, err := d.bytesLen(c)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tif n == -1 {\n\t\treturn \"\", nil\n\t}\n\n\tb, err := d.readN(n)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn bytesToString(b), nil\n}\n\nfunc (d *Decoder) decodeBytesPtr(ptr *[]byte) error {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn d.bytesPtr(c, ptr)\n}\n\nfunc (d *Decoder) bytesPtr(c byte, ptr *[]byte) error {\n\tn, err := d.bytesLen(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n == -1 {\n\t\t*ptr = nil\n\t\treturn nil\n\t}\n\n\t*ptr, err = readN(d.r, *ptr, n)\n\treturn err\n}\n\nfunc (d *Decoder) skipBytes(c byte) error {\n\tn, err := d.bytesLen(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n <= 0 {\n\t\treturn nil\n\t}\n\treturn d.skipN(n)\n}\n\nfunc decodeBytesValue(d *Decoder, v reflect.Value) error {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tb, err := d.bytes(c, v.Bytes())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tv.SetBytes(b)\n\n\treturn nil\n}\n\nfunc decodeByteArrayValue(d *Decoder, v reflect.Value) error {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tn, err := d.bytesLen(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif n == -1 {\n\t\treturn nil\n\t}\n\tif n > v.Len() {\n\t\treturn fmt.Errorf(\"%s len is %d, but msgpack has %d elements\", v.Type(), v.Len(), n)\n\t}\n\n\tb := v.Slice(0, n).Bytes()\n\treturn d.readFull(b)\n}\n"
        },
        {
          "name": "decode_typgen.go",
          "type": "blob",
          "size": 0.7509765625,
          "content": "package msgpack\n\nimport (\n\t\"reflect\"\n\t\"sync\"\n)\n\nvar cachedValues struct {\n\tm map[reflect.Type]chan reflect.Value\n\tsync.RWMutex\n}\n\nfunc cachedValue(t reflect.Type) reflect.Value {\n\tcachedValues.RLock()\n\tch := cachedValues.m[t]\n\tcachedValues.RUnlock()\n\tif ch != nil {\n\t\treturn <-ch\n\t}\n\n\tcachedValues.Lock()\n\tdefer cachedValues.Unlock()\n\tif ch = cachedValues.m[t]; ch != nil {\n\t\treturn <-ch\n\t}\n\n\tch = make(chan reflect.Value, 256)\n\tgo func() {\n\t\tfor {\n\t\t\tch <- reflect.New(t)\n\t\t}\n\t}()\n\tif cachedValues.m == nil {\n\t\tcachedValues.m = make(map[reflect.Type]chan reflect.Value, 8)\n\t}\n\tcachedValues.m[t] = ch\n\treturn <-ch\n}\n\nfunc (d *Decoder) newValue(t reflect.Type) reflect.Value {\n\tif d.flags&usePreallocateValues == 0 {\n\t\treturn reflect.New(t)\n\t}\n\n\treturn cachedValue(t)\n}\n"
        },
        {
          "name": "decode_value.go",
          "type": "blob",
          "size": 5.8515625,
          "content": "package msgpack\n\nimport (\n\t\"encoding\"\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar (\n\tinterfaceType = reflect.TypeOf((*interface{})(nil)).Elem()\n\tstringType    = reflect.TypeOf((*string)(nil)).Elem()\n\tboolType      = reflect.TypeOf((*bool)(nil)).Elem()\n)\n\nvar valueDecoders []decoderFunc\n\n//nolint:gochecknoinits\nfunc init() {\n\tvalueDecoders = []decoderFunc{\n\t\treflect.Bool:          decodeBoolValue,\n\t\treflect.Int:           decodeInt64Value,\n\t\treflect.Int8:          decodeInt64Value,\n\t\treflect.Int16:         decodeInt64Value,\n\t\treflect.Int32:         decodeInt64Value,\n\t\treflect.Int64:         decodeInt64Value,\n\t\treflect.Uint:          decodeUint64Value,\n\t\treflect.Uint8:         decodeUint64Value,\n\t\treflect.Uint16:        decodeUint64Value,\n\t\treflect.Uint32:        decodeUint64Value,\n\t\treflect.Uint64:        decodeUint64Value,\n\t\treflect.Float32:       decodeFloat32Value,\n\t\treflect.Float64:       decodeFloat64Value,\n\t\treflect.Complex64:     decodeUnsupportedValue,\n\t\treflect.Complex128:    decodeUnsupportedValue,\n\t\treflect.Array:         decodeArrayValue,\n\t\treflect.Chan:          decodeUnsupportedValue,\n\t\treflect.Func:          decodeUnsupportedValue,\n\t\treflect.Interface:     decodeInterfaceValue,\n\t\treflect.Map:           decodeMapValue,\n\t\treflect.Ptr:           decodeUnsupportedValue,\n\t\treflect.Slice:         decodeSliceValue,\n\t\treflect.String:        decodeStringValue,\n\t\treflect.Struct:        decodeStructValue,\n\t\treflect.UnsafePointer: decodeUnsupportedValue,\n\t}\n}\n\nfunc getDecoder(typ reflect.Type) decoderFunc {\n\tif v, ok := typeDecMap.Load(typ); ok {\n\t\treturn v.(decoderFunc)\n\t}\n\tfn := _getDecoder(typ)\n\ttypeDecMap.Store(typ, fn)\n\treturn fn\n}\n\nfunc _getDecoder(typ reflect.Type) decoderFunc {\n\tkind := typ.Kind()\n\n\tif kind == reflect.Ptr {\n\t\tif _, ok := typeDecMap.Load(typ.Elem()); ok {\n\t\t\treturn ptrValueDecoder(typ)\n\t\t}\n\t}\n\n\tif typ.Implements(customDecoderType) {\n\t\treturn nilAwareDecoder(typ, decodeCustomValue)\n\t}\n\tif typ.Implements(unmarshalerType) {\n\t\treturn nilAwareDecoder(typ, unmarshalValue)\n\t}\n\tif typ.Implements(binaryUnmarshalerType) {\n\t\treturn nilAwareDecoder(typ, unmarshalBinaryValue)\n\t}\n\tif typ.Implements(textUnmarshalerType) {\n\t\treturn nilAwareDecoder(typ, unmarshalTextValue)\n\t}\n\n\t// Addressable struct field value.\n\tif kind != reflect.Ptr {\n\t\tptr := reflect.PtrTo(typ)\n\t\tif ptr.Implements(customDecoderType) {\n\t\t\treturn addrDecoder(nilAwareDecoder(typ, decodeCustomValue))\n\t\t}\n\t\tif ptr.Implements(unmarshalerType) {\n\t\t\treturn addrDecoder(nilAwareDecoder(typ, unmarshalValue))\n\t\t}\n\t\tif ptr.Implements(binaryUnmarshalerType) {\n\t\t\treturn addrDecoder(nilAwareDecoder(typ, unmarshalBinaryValue))\n\t\t}\n\t\tif ptr.Implements(textUnmarshalerType) {\n\t\t\treturn addrDecoder(nilAwareDecoder(typ, unmarshalTextValue))\n\t\t}\n\t}\n\n\tswitch kind {\n\tcase reflect.Ptr:\n\t\treturn ptrValueDecoder(typ)\n\tcase reflect.Slice:\n\t\telem := typ.Elem()\n\t\tif elem.Kind() == reflect.Uint8 {\n\t\t\treturn decodeBytesValue\n\t\t}\n\t\tif elem == stringType {\n\t\t\treturn decodeStringSliceValue\n\t\t}\n\tcase reflect.Array:\n\t\tif typ.Elem().Kind() == reflect.Uint8 {\n\t\t\treturn decodeByteArrayValue\n\t\t}\n\tcase reflect.Map:\n\t\tif typ.Key() == stringType {\n\t\t\tswitch typ.Elem() {\n\t\t\tcase stringType:\n\t\t\t\treturn decodeMapStringStringValue\n\t\t\tcase interfaceType:\n\t\t\t\treturn decodeMapStringInterfaceValue\n\t\t\t}\n\t\t}\n\t}\n\n\treturn valueDecoders[kind]\n}\n\nfunc ptrValueDecoder(typ reflect.Type) decoderFunc {\n\tdecoder := getDecoder(typ.Elem())\n\treturn func(d *Decoder, v reflect.Value) error {\n\t\tif d.hasNilCode() {\n\t\t\tif !v.IsNil() {\n\t\t\t\tv.Set(d.newValue(typ).Elem())\n\t\t\t}\n\t\t\treturn d.DecodeNil()\n\t\t}\n\t\tif v.IsNil() {\n\t\t\tv.Set(d.newValue(typ.Elem()))\n\t\t}\n\t\treturn decoder(d, v.Elem())\n\t}\n}\n\nfunc addrDecoder(fn decoderFunc) decoderFunc {\n\treturn func(d *Decoder, v reflect.Value) error {\n\t\tif !v.CanAddr() {\n\t\t\treturn fmt.Errorf(\"msgpack: Decode(nonaddressable %T)\", v.Interface())\n\t\t}\n\t\treturn fn(d, v.Addr())\n\t}\n}\n\nfunc nilAwareDecoder(typ reflect.Type, fn decoderFunc) decoderFunc {\n\tif nilable(typ.Kind()) {\n\t\treturn func(d *Decoder, v reflect.Value) error {\n\t\t\tif d.hasNilCode() {\n\t\t\t\treturn d.decodeNilValue(v)\n\t\t\t}\n\t\t\tif v.IsNil() {\n\t\t\t\tv.Set(d.newValue(typ.Elem()))\n\t\t\t}\n\t\t\treturn fn(d, v)\n\t\t}\n\t}\n\n\treturn func(d *Decoder, v reflect.Value) error {\n\t\tif d.hasNilCode() {\n\t\t\treturn d.decodeNilValue(v)\n\t\t}\n\t\treturn fn(d, v)\n\t}\n}\n\nfunc decodeBoolValue(d *Decoder, v reflect.Value) error {\n\tflag, err := d.DecodeBool()\n\tif err != nil {\n\t\treturn err\n\t}\n\tv.SetBool(flag)\n\treturn nil\n}\n\nfunc decodeInterfaceValue(d *Decoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn d.interfaceValue(v)\n\t}\n\treturn d.DecodeValue(v.Elem())\n}\n\nfunc (d *Decoder) interfaceValue(v reflect.Value) error {\n\tvv, err := d.decodeInterfaceCond()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif vv != nil {\n\t\tif v.Type() == errorType {\n\t\t\tif vv, ok := vv.(string); ok {\n\t\t\t\tv.Set(reflect.ValueOf(errors.New(vv)))\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tv.Set(reflect.ValueOf(vv))\n\t}\n\n\treturn nil\n}\n\nfunc decodeUnsupportedValue(d *Decoder, v reflect.Value) error {\n\treturn fmt.Errorf(\"msgpack: Decode(unsupported %s)\", v.Type())\n}\n\n//------------------------------------------------------------------------------\n\nfunc decodeCustomValue(d *Decoder, v reflect.Value) error {\n\tdecoder := v.Interface().(CustomDecoder)\n\treturn decoder.DecodeMsgpack(d)\n}\n\nfunc unmarshalValue(d *Decoder, v reflect.Value) error {\n\tvar b []byte\n\n\td.rec = make([]byte, 0, 64)\n\tif err := d.Skip(); err != nil {\n\t\treturn err\n\t}\n\tb = d.rec\n\td.rec = nil\n\n\tunmarshaler := v.Interface().(Unmarshaler)\n\treturn unmarshaler.UnmarshalMsgpack(b)\n}\n\nfunc unmarshalBinaryValue(d *Decoder, v reflect.Value) error {\n\tdata, err := d.DecodeBytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tunmarshaler := v.Interface().(encoding.BinaryUnmarshaler)\n\treturn unmarshaler.UnmarshalBinary(data)\n}\n\nfunc unmarshalTextValue(d *Decoder, v reflect.Value) error {\n\tdata, err := d.DecodeBytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tunmarshaler := v.Interface().(encoding.TextUnmarshaler)\n\treturn unmarshaler.UnmarshalText(data)\n}\n"
        },
        {
          "name": "encode.go",
          "type": "blob",
          "size": 5.2333984375,
          "content": "package msgpack\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"reflect\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nconst (\n\tsortMapKeysFlag uint32 = 1 << iota\n\tarrayEncodedStructsFlag\n\tuseCompactIntsFlag\n\tuseCompactFloatsFlag\n\tuseInternedStringsFlag\n\tomitEmptyFlag\n)\n\ntype writer interface {\n\tio.Writer\n\tWriteByte(byte) error\n}\n\ntype byteWriter struct {\n\tio.Writer\n}\n\nfunc newByteWriter(w io.Writer) byteWriter {\n\treturn byteWriter{\n\t\tWriter: w,\n\t}\n}\n\nfunc (bw byteWriter) WriteByte(c byte) error {\n\t_, err := bw.Write([]byte{c})\n\treturn err\n}\n\n//------------------------------------------------------------------------------\n\nvar encPool = sync.Pool{\n\tNew: func() interface{} {\n\t\treturn NewEncoder(nil)\n\t},\n}\n\nfunc GetEncoder() *Encoder {\n\treturn encPool.Get().(*Encoder)\n}\n\nfunc PutEncoder(enc *Encoder) {\n\tenc.w = nil\n\tencPool.Put(enc)\n}\n\n// Marshal returns the MessagePack encoding of v.\nfunc Marshal(v interface{}) ([]byte, error) {\n\tenc := GetEncoder()\n\n\tvar buf bytes.Buffer\n\tenc.Reset(&buf)\n\n\terr := enc.Encode(v)\n\tb := buf.Bytes()\n\n\tPutEncoder(enc)\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn b, err\n}\n\ntype Encoder struct {\n\tw         writer\n\tdict      map[string]int\n\tstructTag string\n\tbuf       []byte\n\ttimeBuf   []byte\n\tflags     uint32\n}\n\n// NewEncoder returns a new encoder that writes to w.\nfunc NewEncoder(w io.Writer) *Encoder {\n\te := &Encoder{\n\t\tbuf: make([]byte, 9),\n\t}\n\te.Reset(w)\n\treturn e\n}\n\n// Writer returns the Encoder's writer.\nfunc (e *Encoder) Writer() io.Writer {\n\treturn e.w\n}\n\n// Reset discards any buffered data, resets all state, and switches the writer to write to w.\nfunc (e *Encoder) Reset(w io.Writer) {\n\te.ResetDict(w, nil)\n}\n\n// ResetDict is like Reset, but also resets the dict.\nfunc (e *Encoder) ResetDict(w io.Writer, dict map[string]int) {\n\te.ResetWriter(w)\n\te.flags = 0\n\te.structTag = \"\"\n\te.dict = dict\n}\n\nfunc (e *Encoder) WithDict(dict map[string]int, fn func(*Encoder) error) error {\n\toldDict := e.dict\n\te.dict = dict\n\terr := fn(e)\n\te.dict = oldDict\n\treturn err\n}\n\nfunc (e *Encoder) ResetWriter(w io.Writer) {\n\te.dict = nil\n\tif bw, ok := w.(writer); ok {\n\t\te.w = bw\n\t} else if w == nil {\n\t\te.w = nil\n\t} else {\n\t\te.w = newByteWriter(w)\n\t}\n}\n\n// SetSortMapKeys causes the Encoder to encode map keys in increasing order.\n// Supported map types are:\n//   - map[string]string\n//   - map[string]bool\n//   - map[string]interface{}\nfunc (e *Encoder) SetSortMapKeys(on bool) *Encoder {\n\tif on {\n\t\te.flags |= sortMapKeysFlag\n\t} else {\n\t\te.flags &= ^sortMapKeysFlag\n\t}\n\treturn e\n}\n\n// SetCustomStructTag causes the Encoder to use a custom struct tag as\n// fallback option if there is no msgpack tag.\nfunc (e *Encoder) SetCustomStructTag(tag string) {\n\te.structTag = tag\n}\n\n// SetOmitEmpty causes the Encoder to omit empty values by default.\nfunc (e *Encoder) SetOmitEmpty(on bool) {\n\tif on {\n\t\te.flags |= omitEmptyFlag\n\t} else {\n\t\te.flags &= ^omitEmptyFlag\n\t}\n}\n\n// UseArrayEncodedStructs causes the Encoder to encode Go structs as msgpack arrays.\nfunc (e *Encoder) UseArrayEncodedStructs(on bool) {\n\tif on {\n\t\te.flags |= arrayEncodedStructsFlag\n\t} else {\n\t\te.flags &= ^arrayEncodedStructsFlag\n\t}\n}\n\n// UseCompactEncoding causes the Encoder to chose the most compact encoding.\n// For example, it allows to encode small Go int64 as msgpack int8 saving 7 bytes.\nfunc (e *Encoder) UseCompactInts(on bool) {\n\tif on {\n\t\te.flags |= useCompactIntsFlag\n\t} else {\n\t\te.flags &= ^useCompactIntsFlag\n\t}\n}\n\n// UseCompactFloats causes the Encoder to chose a compact integer encoding\n// for floats that can be represented as integers.\nfunc (e *Encoder) UseCompactFloats(on bool) {\n\tif on {\n\t\te.flags |= useCompactFloatsFlag\n\t} else {\n\t\te.flags &= ^useCompactFloatsFlag\n\t}\n}\n\n// UseInternedStrings causes the Encoder to intern strings.\nfunc (e *Encoder) UseInternedStrings(on bool) {\n\tif on {\n\t\te.flags |= useInternedStringsFlag\n\t} else {\n\t\te.flags &= ^useInternedStringsFlag\n\t}\n}\n\nfunc (e *Encoder) Encode(v interface{}) error {\n\tswitch v := v.(type) {\n\tcase nil:\n\t\treturn e.EncodeNil()\n\tcase string:\n\t\treturn e.EncodeString(v)\n\tcase []byte:\n\t\treturn e.EncodeBytes(v)\n\tcase int:\n\t\treturn e.EncodeInt(int64(v))\n\tcase int64:\n\t\treturn e.encodeInt64Cond(v)\n\tcase uint:\n\t\treturn e.EncodeUint(uint64(v))\n\tcase uint64:\n\t\treturn e.encodeUint64Cond(v)\n\tcase bool:\n\t\treturn e.EncodeBool(v)\n\tcase float32:\n\t\treturn e.EncodeFloat32(v)\n\tcase float64:\n\t\treturn e.EncodeFloat64(v)\n\tcase time.Duration:\n\t\treturn e.encodeInt64Cond(int64(v))\n\tcase time.Time:\n\t\treturn e.EncodeTime(v)\n\t}\n\treturn e.EncodeValue(reflect.ValueOf(v))\n}\n\nfunc (e *Encoder) EncodeMulti(v ...interface{}) error {\n\tfor _, vv := range v {\n\t\tif err := e.Encode(vv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Encoder) EncodeValue(v reflect.Value) error {\n\tfn := getEncoder(v.Type())\n\treturn fn(e, v)\n}\n\nfunc (e *Encoder) EncodeNil() error {\n\treturn e.writeCode(msgpcode.Nil)\n}\n\nfunc (e *Encoder) EncodeBool(value bool) error {\n\tif value {\n\t\treturn e.writeCode(msgpcode.True)\n\t}\n\treturn e.writeCode(msgpcode.False)\n}\n\nfunc (e *Encoder) EncodeDuration(d time.Duration) error {\n\treturn e.EncodeInt(int64(d))\n}\n\nfunc (e *Encoder) writeCode(c byte) error {\n\treturn e.w.WriteByte(c)\n}\n\nfunc (e *Encoder) write(b []byte) error {\n\t_, err := e.w.Write(b)\n\treturn err\n}\n\nfunc (e *Encoder) writeString(s string) error {\n\t_, err := e.w.Write(stringToBytes(s))\n\treturn err\n}\n"
        },
        {
          "name": "encode_map.go",
          "type": "blob",
          "size": 4.1748046875,
          "content": "package msgpack\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nfunc encodeMapValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tif err := e.EncodeMapLen(v.Len()); err != nil {\n\t\treturn err\n\t}\n\n\titer := v.MapRange()\n\tfor iter.Next() {\n\t\tif err := e.EncodeValue(iter.Key()); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.EncodeValue(iter.Value()); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc encodeMapStringBoolValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tif err := e.EncodeMapLen(v.Len()); err != nil {\n\t\treturn err\n\t}\n\n\tm := v.Convert(mapStringBoolType).Interface().(map[string]bool)\n\tif e.flags&sortMapKeysFlag != 0 {\n\t\treturn e.encodeSortedMapStringBool(m)\n\t}\n\n\tfor mk, mv := range m {\n\t\tif err := e.EncodeString(mk); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.EncodeBool(mv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc encodeMapStringStringValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tif err := e.EncodeMapLen(v.Len()); err != nil {\n\t\treturn err\n\t}\n\n\tm := v.Convert(mapStringStringType).Interface().(map[string]string)\n\tif e.flags&sortMapKeysFlag != 0 {\n\t\treturn e.encodeSortedMapStringString(m)\n\t}\n\n\tfor mk, mv := range m {\n\t\tif err := e.EncodeString(mk); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.EncodeString(mv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc encodeMapStringInterfaceValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\tm := v.Convert(mapStringInterfaceType).Interface().(map[string]interface{})\n\tif e.flags&sortMapKeysFlag != 0 {\n\t\treturn e.EncodeMapSorted(m)\n\t}\n\treturn e.EncodeMap(m)\n}\n\nfunc (e *Encoder) EncodeMap(m map[string]interface{}) error {\n\tif m == nil {\n\t\treturn e.EncodeNil()\n\t}\n\tif err := e.EncodeMapLen(len(m)); err != nil {\n\t\treturn err\n\t}\n\tfor mk, mv := range m {\n\t\tif err := e.EncodeString(mk); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.Encode(mv); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (e *Encoder) EncodeMapSorted(m map[string]interface{}) error {\n\tif m == nil {\n\t\treturn e.EncodeNil()\n\t}\n\tif err := e.EncodeMapLen(len(m)); err != nil {\n\t\treturn err\n\t}\n\n\tkeys := make([]string, 0, len(m))\n\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\n\tsort.Strings(keys)\n\n\tfor _, k := range keys {\n\t\tif err := e.EncodeString(k); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := e.Encode(m[k]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (e *Encoder) encodeSortedMapStringBool(m map[string]bool) error {\n\tkeys := make([]string, 0, len(m))\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, k := range keys {\n\t\terr := e.EncodeString(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = e.EncodeBool(m[k]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (e *Encoder) encodeSortedMapStringString(m map[string]string) error {\n\tkeys := make([]string, 0, len(m))\n\tfor k := range m {\n\t\tkeys = append(keys, k)\n\t}\n\tsort.Strings(keys)\n\n\tfor _, k := range keys {\n\t\terr := e.EncodeString(k)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err = e.EncodeString(m[k]); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (e *Encoder) EncodeMapLen(l int) error {\n\tif l < 16 {\n\t\treturn e.writeCode(msgpcode.FixedMapLow | byte(l))\n\t}\n\tif l <= math.MaxUint16 {\n\t\treturn e.write2(msgpcode.Map16, uint16(l))\n\t}\n\treturn e.write4(msgpcode.Map32, uint32(l))\n}\n\nfunc encodeStructValue(e *Encoder, strct reflect.Value) error {\n\tstructFields := structs.Fields(strct.Type(), e.structTag)\n\tif e.flags&arrayEncodedStructsFlag != 0 || structFields.AsArray {\n\t\treturn encodeStructValueAsArray(e, strct, structFields.List)\n\t}\n\tfields := structFields.OmitEmpty(e, strct)\n\n\tif err := e.EncodeMapLen(len(fields)); err != nil {\n\t\treturn err\n\t}\n\n\tfor _, f := range fields {\n\t\tif err := e.EncodeString(f.name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := f.EncodeValue(e, strct); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc encodeStructValueAsArray(e *Encoder, strct reflect.Value, fields []*field) error {\n\tif err := e.EncodeArrayLen(len(fields)); err != nil {\n\t\treturn err\n\t}\n\tfor _, f := range fields {\n\t\tif err := f.EncodeValue(e, strct); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "encode_number.go",
          "type": "blob",
          "size": 6.142578125,
          "content": "package msgpack\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\n// EncodeUint8 encodes an uint8 in 2 bytes preserving type of the number.\nfunc (e *Encoder) EncodeUint8(n uint8) error {\n\treturn e.write1(msgpcode.Uint8, n)\n}\n\nfunc (e *Encoder) encodeUint8Cond(n uint8) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeUint(uint64(n))\n\t}\n\treturn e.EncodeUint8(n)\n}\n\n// EncodeUint16 encodes an uint16 in 3 bytes preserving type of the number.\nfunc (e *Encoder) EncodeUint16(n uint16) error {\n\treturn e.write2(msgpcode.Uint16, n)\n}\n\nfunc (e *Encoder) encodeUint16Cond(n uint16) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeUint(uint64(n))\n\t}\n\treturn e.EncodeUint16(n)\n}\n\n// EncodeUint32 encodes an uint16 in 5 bytes preserving type of the number.\nfunc (e *Encoder) EncodeUint32(n uint32) error {\n\treturn e.write4(msgpcode.Uint32, n)\n}\n\nfunc (e *Encoder) encodeUint32Cond(n uint32) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeUint(uint64(n))\n\t}\n\treturn e.EncodeUint32(n)\n}\n\n// EncodeUint64 encodes an uint16 in 9 bytes preserving type of the number.\nfunc (e *Encoder) EncodeUint64(n uint64) error {\n\treturn e.write8(msgpcode.Uint64, n)\n}\n\nfunc (e *Encoder) encodeUint64Cond(n uint64) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeUint(n)\n\t}\n\treturn e.EncodeUint64(n)\n}\n\n// EncodeInt8 encodes an int8 in 2 bytes preserving type of the number.\nfunc (e *Encoder) EncodeInt8(n int8) error {\n\treturn e.write1(msgpcode.Int8, uint8(n))\n}\n\nfunc (e *Encoder) encodeInt8Cond(n int8) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeInt(int64(n))\n\t}\n\treturn e.EncodeInt8(n)\n}\n\n// EncodeInt16 encodes an int16 in 3 bytes preserving type of the number.\nfunc (e *Encoder) EncodeInt16(n int16) error {\n\treturn e.write2(msgpcode.Int16, uint16(n))\n}\n\nfunc (e *Encoder) encodeInt16Cond(n int16) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeInt(int64(n))\n\t}\n\treturn e.EncodeInt16(n)\n}\n\n// EncodeInt32 encodes an int32 in 5 bytes preserving type of the number.\nfunc (e *Encoder) EncodeInt32(n int32) error {\n\treturn e.write4(msgpcode.Int32, uint32(n))\n}\n\nfunc (e *Encoder) encodeInt32Cond(n int32) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeInt(int64(n))\n\t}\n\treturn e.EncodeInt32(n)\n}\n\n// EncodeInt64 encodes an int64 in 9 bytes preserving type of the number.\nfunc (e *Encoder) EncodeInt64(n int64) error {\n\treturn e.write8(msgpcode.Int64, uint64(n))\n}\n\nfunc (e *Encoder) encodeInt64Cond(n int64) error {\n\tif e.flags&useCompactIntsFlag != 0 {\n\t\treturn e.EncodeInt(n)\n\t}\n\treturn e.EncodeInt64(n)\n}\n\n// EncodeUnsignedNumber encodes an uint64 in 1, 2, 3, 5, or 9 bytes.\n// Type of the number is lost during encoding.\nfunc (e *Encoder) EncodeUint(n uint64) error {\n\tif n <= math.MaxInt8 {\n\t\treturn e.w.WriteByte(byte(n))\n\t}\n\tif n <= math.MaxUint8 {\n\t\treturn e.EncodeUint8(uint8(n))\n\t}\n\tif n <= math.MaxUint16 {\n\t\treturn e.EncodeUint16(uint16(n))\n\t}\n\tif n <= math.MaxUint32 {\n\t\treturn e.EncodeUint32(uint32(n))\n\t}\n\treturn e.EncodeUint64(n)\n}\n\n// EncodeNumber encodes an int64 in 1, 2, 3, 5, or 9 bytes.\n// Type of the number is lost during encoding.\nfunc (e *Encoder) EncodeInt(n int64) error {\n\tif n >= 0 {\n\t\treturn e.EncodeUint(uint64(n))\n\t}\n\tif n >= int64(int8(msgpcode.NegFixedNumLow)) {\n\t\treturn e.w.WriteByte(byte(n))\n\t}\n\tif n >= math.MinInt8 {\n\t\treturn e.EncodeInt8(int8(n))\n\t}\n\tif n >= math.MinInt16 {\n\t\treturn e.EncodeInt16(int16(n))\n\t}\n\tif n >= math.MinInt32 {\n\t\treturn e.EncodeInt32(int32(n))\n\t}\n\treturn e.EncodeInt64(n)\n}\n\nfunc (e *Encoder) EncodeFloat32(n float32) error {\n\tif e.flags&useCompactFloatsFlag != 0 {\n\t\tif float32(int64(n)) == n {\n\t\t\treturn e.EncodeInt(int64(n))\n\t\t}\n\t}\n\treturn e.write4(msgpcode.Float, math.Float32bits(n))\n}\n\nfunc (e *Encoder) EncodeFloat64(n float64) error {\n\tif e.flags&useCompactFloatsFlag != 0 {\n\t\t// Both NaN and Inf convert to int64(-0x8000000000000000)\n\t\t// If n is NaN then it never compares true with any other value\n\t\t// If n is Inf then it doesn't convert from int64 back to +/-Inf\n\t\t// In both cases the comparison works.\n\t\tif float64(int64(n)) == n {\n\t\t\treturn e.EncodeInt(int64(n))\n\t\t}\n\t}\n\treturn e.write8(msgpcode.Double, math.Float64bits(n))\n}\n\nfunc (e *Encoder) write1(code byte, n uint8) error {\n\te.buf = e.buf[:2]\n\te.buf[0] = code\n\te.buf[1] = n\n\treturn e.write(e.buf)\n}\n\nfunc (e *Encoder) write2(code byte, n uint16) error {\n\te.buf = e.buf[:3]\n\te.buf[0] = code\n\te.buf[1] = byte(n >> 8)\n\te.buf[2] = byte(n)\n\treturn e.write(e.buf)\n}\n\nfunc (e *Encoder) write4(code byte, n uint32) error {\n\te.buf = e.buf[:5]\n\te.buf[0] = code\n\te.buf[1] = byte(n >> 24)\n\te.buf[2] = byte(n >> 16)\n\te.buf[3] = byte(n >> 8)\n\te.buf[4] = byte(n)\n\treturn e.write(e.buf)\n}\n\nfunc (e *Encoder) write8(code byte, n uint64) error {\n\te.buf = e.buf[:9]\n\te.buf[0] = code\n\te.buf[1] = byte(n >> 56)\n\te.buf[2] = byte(n >> 48)\n\te.buf[3] = byte(n >> 40)\n\te.buf[4] = byte(n >> 32)\n\te.buf[5] = byte(n >> 24)\n\te.buf[6] = byte(n >> 16)\n\te.buf[7] = byte(n >> 8)\n\te.buf[8] = byte(n)\n\treturn e.write(e.buf)\n}\n\nfunc encodeUintValue(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeUint(v.Uint())\n}\n\nfunc encodeIntValue(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeInt(v.Int())\n}\n\nfunc encodeUint8CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeUint8Cond(uint8(v.Uint()))\n}\n\nfunc encodeUint16CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeUint16Cond(uint16(v.Uint()))\n}\n\nfunc encodeUint32CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeUint32Cond(uint32(v.Uint()))\n}\n\nfunc encodeUint64CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeUint64Cond(v.Uint())\n}\n\nfunc encodeInt8CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeInt8Cond(int8(v.Int()))\n}\n\nfunc encodeInt16CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeInt16Cond(int16(v.Int()))\n}\n\nfunc encodeInt32CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeInt32Cond(int32(v.Int()))\n}\n\nfunc encodeInt64CondValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeInt64Cond(v.Int())\n}\n\nfunc encodeFloat32Value(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeFloat32(float32(v.Float()))\n}\n\nfunc encodeFloat64Value(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeFloat64(v.Float())\n}\n"
        },
        {
          "name": "encode_slice.go",
          "type": "blob",
          "size": 2.83984375,
          "content": "package msgpack\n\nimport (\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nvar stringSliceType = reflect.TypeOf(([]string)(nil))\n\nfunc encodeStringValue(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeString(v.String())\n}\n\nfunc encodeByteSliceValue(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeBytes(v.Bytes())\n}\n\nfunc encodeByteArrayValue(e *Encoder, v reflect.Value) error {\n\tif err := e.EncodeBytesLen(v.Len()); err != nil {\n\t\treturn err\n\t}\n\n\tif v.CanAddr() {\n\t\tb := v.Slice(0, v.Len()).Bytes()\n\t\treturn e.write(b)\n\t}\n\n\te.buf = grow(e.buf, v.Len())\n\treflect.Copy(reflect.ValueOf(e.buf), v)\n\treturn e.write(e.buf)\n}\n\nfunc grow(b []byte, n int) []byte {\n\tif cap(b) >= n {\n\t\treturn b[:n]\n\t}\n\tb = b[:cap(b)]\n\tb = append(b, make([]byte, n-len(b))...)\n\treturn b\n}\n\nfunc (e *Encoder) EncodeBytesLen(l int) error {\n\tif l < 256 {\n\t\treturn e.write1(msgpcode.Bin8, uint8(l))\n\t}\n\tif l <= math.MaxUint16 {\n\t\treturn e.write2(msgpcode.Bin16, uint16(l))\n\t}\n\treturn e.write4(msgpcode.Bin32, uint32(l))\n}\n\nfunc (e *Encoder) encodeStringLen(l int) error {\n\tif l < 32 {\n\t\treturn e.writeCode(msgpcode.FixedStrLow | byte(l))\n\t}\n\tif l < 256 {\n\t\treturn e.write1(msgpcode.Str8, uint8(l))\n\t}\n\tif l <= math.MaxUint16 {\n\t\treturn e.write2(msgpcode.Str16, uint16(l))\n\t}\n\treturn e.write4(msgpcode.Str32, uint32(l))\n}\n\nfunc (e *Encoder) EncodeString(v string) error {\n\tif intern := e.flags&useInternedStringsFlag != 0; intern || len(e.dict) > 0 {\n\t\treturn e.encodeInternedString(v, intern)\n\t}\n\treturn e.encodeNormalString(v)\n}\n\nfunc (e *Encoder) encodeNormalString(v string) error {\n\tif err := e.encodeStringLen(len(v)); err != nil {\n\t\treturn err\n\t}\n\treturn e.writeString(v)\n}\n\nfunc (e *Encoder) EncodeBytes(v []byte) error {\n\tif v == nil {\n\t\treturn e.EncodeNil()\n\t}\n\tif err := e.EncodeBytesLen(len(v)); err != nil {\n\t\treturn err\n\t}\n\treturn e.write(v)\n}\n\nfunc (e *Encoder) EncodeArrayLen(l int) error {\n\tif l < 16 {\n\t\treturn e.writeCode(msgpcode.FixedArrayLow | byte(l))\n\t}\n\tif l <= math.MaxUint16 {\n\t\treturn e.write2(msgpcode.Array16, uint16(l))\n\t}\n\treturn e.write4(msgpcode.Array32, uint32(l))\n}\n\nfunc encodeStringSliceValue(e *Encoder, v reflect.Value) error {\n\tss := v.Convert(stringSliceType).Interface().([]string)\n\treturn e.encodeStringSlice(ss)\n}\n\nfunc (e *Encoder) encodeStringSlice(s []string) error {\n\tif s == nil {\n\t\treturn e.EncodeNil()\n\t}\n\tif err := e.EncodeArrayLen(len(s)); err != nil {\n\t\treturn err\n\t}\n\tfor _, v := range s {\n\t\tif err := e.EncodeString(v); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc encodeSliceValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\treturn encodeArrayValue(e, v)\n}\n\nfunc encodeArrayValue(e *Encoder, v reflect.Value) error {\n\tl := v.Len()\n\tif err := e.EncodeArrayLen(l); err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < l; i++ {\n\t\tif err := e.EncodeValue(v.Index(i)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "encode_value.go",
          "type": "blob",
          "size": 5.9619140625,
          "content": "package msgpack\n\nimport (\n\t\"encoding\"\n\t\"fmt\"\n\t\"reflect\"\n)\n\nvar valueEncoders []encoderFunc\n\n//nolint:gochecknoinits\nfunc init() {\n\tvalueEncoders = []encoderFunc{\n\t\treflect.Bool:          encodeBoolValue,\n\t\treflect.Int:           encodeIntValue,\n\t\treflect.Int8:          encodeInt8CondValue,\n\t\treflect.Int16:         encodeInt16CondValue,\n\t\treflect.Int32:         encodeInt32CondValue,\n\t\treflect.Int64:         encodeInt64CondValue,\n\t\treflect.Uint:          encodeUintValue,\n\t\treflect.Uint8:         encodeUint8CondValue,\n\t\treflect.Uint16:        encodeUint16CondValue,\n\t\treflect.Uint32:        encodeUint32CondValue,\n\t\treflect.Uint64:        encodeUint64CondValue,\n\t\treflect.Float32:       encodeFloat32Value,\n\t\treflect.Float64:       encodeFloat64Value,\n\t\treflect.Complex64:     encodeUnsupportedValue,\n\t\treflect.Complex128:    encodeUnsupportedValue,\n\t\treflect.Array:         encodeArrayValue,\n\t\treflect.Chan:          encodeUnsupportedValue,\n\t\treflect.Func:          encodeUnsupportedValue,\n\t\treflect.Interface:     encodeInterfaceValue,\n\t\treflect.Map:           encodeMapValue,\n\t\treflect.Ptr:           encodeUnsupportedValue,\n\t\treflect.Slice:         encodeSliceValue,\n\t\treflect.String:        encodeStringValue,\n\t\treflect.Struct:        encodeStructValue,\n\t\treflect.UnsafePointer: encodeUnsupportedValue,\n\t}\n}\n\nfunc getEncoder(typ reflect.Type) encoderFunc {\n\tif v, ok := typeEncMap.Load(typ); ok {\n\t\treturn v.(encoderFunc)\n\t}\n\tfn := _getEncoder(typ)\n\ttypeEncMap.Store(typ, fn)\n\treturn fn\n}\n\nfunc _getEncoder(typ reflect.Type) encoderFunc {\n\tkind := typ.Kind()\n\n\tif kind == reflect.Ptr {\n\t\tif _, ok := typeEncMap.Load(typ.Elem()); ok {\n\t\t\treturn ptrEncoderFunc(typ)\n\t\t}\n\t}\n\n\tif typ.Implements(customEncoderType) {\n\t\treturn encodeCustomValue\n\t}\n\tif typ.Implements(marshalerType) {\n\t\treturn marshalValue\n\t}\n\tif typ.Implements(binaryMarshalerType) {\n\t\treturn marshalBinaryValue\n\t}\n\tif typ.Implements(textMarshalerType) {\n\t\treturn marshalTextValue\n\t}\n\n\t// Addressable struct field value.\n\tif kind != reflect.Ptr {\n\t\tptr := reflect.PtrTo(typ)\n\t\tif ptr.Implements(customEncoderType) {\n\t\t\treturn encodeCustomValuePtr\n\t\t}\n\t\tif ptr.Implements(marshalerType) {\n\t\t\treturn marshalValuePtr\n\t\t}\n\t\tif ptr.Implements(binaryMarshalerType) {\n\t\t\treturn marshalBinaryValueAddr\n\t\t}\n\t\tif ptr.Implements(textMarshalerType) {\n\t\t\treturn marshalTextValueAddr\n\t\t}\n\t}\n\n\tif typ == errorType {\n\t\treturn encodeErrorValue\n\t}\n\n\tswitch kind {\n\tcase reflect.Ptr:\n\t\treturn ptrEncoderFunc(typ)\n\tcase reflect.Slice:\n\t\telem := typ.Elem()\n\t\tif elem.Kind() == reflect.Uint8 {\n\t\t\treturn encodeByteSliceValue\n\t\t}\n\t\tif elem == stringType {\n\t\t\treturn encodeStringSliceValue\n\t\t}\n\tcase reflect.Array:\n\t\tif typ.Elem().Kind() == reflect.Uint8 {\n\t\t\treturn encodeByteArrayValue\n\t\t}\n\tcase reflect.Map:\n\t\tif typ.Key() == stringType {\n\t\t\tswitch typ.Elem() {\n\t\t\tcase stringType:\n\t\t\t\treturn encodeMapStringStringValue\n\t\t\tcase boolType:\n\t\t\t\treturn encodeMapStringBoolValue\n\t\t\tcase interfaceType:\n\t\t\t\treturn encodeMapStringInterfaceValue\n\t\t\t}\n\t\t}\n\t}\n\n\treturn valueEncoders[kind]\n}\n\nfunc ptrEncoderFunc(typ reflect.Type) encoderFunc {\n\tencoder := getEncoder(typ.Elem())\n\treturn func(e *Encoder, v reflect.Value) error {\n\t\tif v.IsNil() {\n\t\t\treturn e.EncodeNil()\n\t\t}\n\t\treturn encoder(e, v.Elem())\n\t}\n}\n\nfunc encodeCustomValuePtr(e *Encoder, v reflect.Value) error {\n\tif !v.CanAddr() {\n\t\treturn fmt.Errorf(\"msgpack: Encode(non-addressable %T)\", v.Interface())\n\t}\n\tencoder := v.Addr().Interface().(CustomEncoder)\n\treturn encoder.EncodeMsgpack(e)\n}\n\nfunc encodeCustomValue(e *Encoder, v reflect.Value) error {\n\tif nilable(v.Kind()) && v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tencoder := v.Interface().(CustomEncoder)\n\treturn encoder.EncodeMsgpack(e)\n}\n\nfunc marshalValuePtr(e *Encoder, v reflect.Value) error {\n\tif !v.CanAddr() {\n\t\treturn fmt.Errorf(\"msgpack: Encode(non-addressable %T)\", v.Interface())\n\t}\n\treturn marshalValue(e, v.Addr())\n}\n\nfunc marshalValue(e *Encoder, v reflect.Value) error {\n\tif nilable(v.Kind()) && v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tmarshaler := v.Interface().(Marshaler)\n\tb, err := marshaler.MarshalMsgpack()\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = e.w.Write(b)\n\treturn err\n}\n\nfunc encodeBoolValue(e *Encoder, v reflect.Value) error {\n\treturn e.EncodeBool(v.Bool())\n}\n\nfunc encodeInterfaceValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\treturn e.EncodeValue(v.Elem())\n}\n\nfunc encodeErrorValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\treturn e.EncodeString(v.Interface().(error).Error())\n}\n\nfunc encodeUnsupportedValue(e *Encoder, v reflect.Value) error {\n\treturn fmt.Errorf(\"msgpack: Encode(unsupported %s)\", v.Type())\n}\n\nfunc nilable(kind reflect.Kind) bool {\n\tswitch kind {\n\tcase reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc nilableType(t reflect.Type) bool {\n\tif t.Kind() == reflect.Ptr {\n\t\tt = t.Elem()\n\t}\n\treturn nilable(t.Kind())\n}\n\n//------------------------------------------------------------------------------\n\nfunc marshalBinaryValueAddr(e *Encoder, v reflect.Value) error {\n\tif !v.CanAddr() {\n\t\treturn fmt.Errorf(\"msgpack: Encode(non-addressable %T)\", v.Interface())\n\t}\n\treturn marshalBinaryValue(e, v.Addr())\n}\n\nfunc marshalBinaryValue(e *Encoder, v reflect.Value) error {\n\tif nilable(v.Kind()) && v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tmarshaler := v.Interface().(encoding.BinaryMarshaler)\n\tdata, err := marshaler.MarshalBinary()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn e.EncodeBytes(data)\n}\n\n//------------------------------------------------------------------------------\n\nfunc marshalTextValueAddr(e *Encoder, v reflect.Value) error {\n\tif !v.CanAddr() {\n\t\treturn fmt.Errorf(\"msgpack: Encode(non-addressable %T)\", v.Interface())\n\t}\n\treturn marshalTextValue(e, v.Addr())\n}\n\nfunc marshalTextValue(e *Encoder, v reflect.Value) error {\n\tif nilable(v.Kind()) && v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tmarshaler := v.Interface().(encoding.TextMarshaler)\n\tdata, err := marshaler.MarshalText()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn e.EncodeBytes(data)\n}\n"
        },
        {
          "name": "example_CustomEncoder_test.go",
          "type": "blob",
          "size": 0.7109375,
          "content": "package msgpack_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/vmihailenco/msgpack/v5\"\n)\n\ntype customStruct struct {\n\tS string\n\tN int\n}\n\nvar _ msgpack.CustomEncoder = (*customStruct)(nil)\nvar _ msgpack.CustomDecoder = (*customStruct)(nil)\n\nfunc (s *customStruct) EncodeMsgpack(enc *msgpack.Encoder) error {\n\treturn enc.EncodeMulti(s.S, s.N)\n}\n\nfunc (s *customStruct) DecodeMsgpack(dec *msgpack.Decoder) error {\n\treturn dec.DecodeMulti(&s.S, &s.N)\n}\n\nfunc ExampleCustomEncoder() {\n\tb, err := msgpack.Marshal(&customStruct{S: \"hello\", N: 42})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar v customStruct\n\terr = msgpack.Unmarshal(b, &v)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%#v\", v)\n\t// Output: msgpack_test.customStruct{S:\"hello\", N:42}\n}\n"
        },
        {
          "name": "example_registerExt_test.go",
          "type": "blob",
          "size": 3.87109375,
          "content": "package msgpack_test\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/vmihailenco/msgpack/v5\"\n)\n\n// https://github.com/fluent/fluentd/wiki/Forward-Protocol-Specification-v1#eventtime-ext-format\ntype EventTime struct {\n\ttime.Time\n}\n\ntype OneMoreSecondEventTime struct {\n\tEventTime\n}\n\nvar (\n\t_ msgpack.Marshaler   = (*EventTime)(nil)\n\t_ msgpack.Unmarshaler = (*EventTime)(nil)\n\t_ msgpack.Marshaler   = (*OneMoreSecondEventTime)(nil)\n\t_ msgpack.Unmarshaler = (*OneMoreSecondEventTime)(nil)\n)\n\nfunc (tm *EventTime) MarshalMsgpack() ([]byte, error) {\n\tb := make([]byte, 8)\n\tbinary.BigEndian.PutUint32(b, uint32(tm.Unix()))\n\tbinary.BigEndian.PutUint32(b[4:], uint32(tm.Nanosecond()))\n\treturn b, nil\n}\n\nfunc (tm *EventTime) UnmarshalMsgpack(b []byte) error {\n\tif len(b) != 8 {\n\t\treturn fmt.Errorf(\"invalid data length: got %d, wanted 8\", len(b))\n\t}\n\tsec := binary.BigEndian.Uint32(b)\n\tusec := binary.BigEndian.Uint32(b[4:])\n\ttm.Time = time.Unix(int64(sec), int64(usec))\n\treturn nil\n}\n\nfunc (tm *OneMoreSecondEventTime) MarshalMsgpack() ([]byte, error) {\n\tb := make([]byte, 8)\n\tbinary.BigEndian.PutUint32(b, uint32(tm.Unix()+1))\n\tbinary.BigEndian.PutUint32(b[4:], uint32(tm.Nanosecond()))\n\treturn b, nil\n}\n\nfunc (tm *OneMoreSecondEventTime) UnmarshalMsgpack(b []byte) error {\n\tif len(b) != 8 {\n\t\treturn fmt.Errorf(\"invalid data length: got %d, wanted 8\", len(b))\n\t}\n\tsec := binary.BigEndian.Uint32(b)\n\tusec := binary.BigEndian.Uint32(b[4:])\n\ttm.Time = time.Unix(int64(sec+1), int64(usec))\n\treturn nil\n}\n\nfunc ExampleRegisterExt() {\n\tt := time.Unix(123456789, 123)\n\n\t{\n\t\tmsgpack.RegisterExt(1, (*EventTime)(nil))\n\t\tb, err := msgpack.Marshal(&EventTime{t})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tvar v interface{}\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(v.(*EventTime).UTC())\n\n\t\ttm := new(EventTime)\n\t\terr = msgpack.Unmarshal(b, &tm)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(tm.UTC())\n\t}\n\n\t{\n\t\tmsgpack.RegisterExt(1, (*EventTime)(nil))\n\t\tb, err := msgpack.Marshal(&EventTime{t})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// override ext\n\t\tmsgpack.RegisterExt(1, (*OneMoreSecondEventTime)(nil))\n\n\t\tvar v interface{}\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(v.(*OneMoreSecondEventTime).UTC())\n\t}\n\n\t{\n\t\tmsgpack.RegisterExt(1, (*OneMoreSecondEventTime)(nil))\n\t\tb, err := msgpack.Marshal(&OneMoreSecondEventTime{\n\t\t\tEventTime{t},\n\t\t})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\t// override ext\n\t\tmsgpack.RegisterExt(1, (*EventTime)(nil))\n\t\tvar v interface{}\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(v.(*EventTime).UTC())\n\t}\n\n\t// Output: 1973-11-29 21:33:09.000000123 +0000 UTC\n\t// 1973-11-29 21:33:09.000000123 +0000 UTC\n\t// 1973-11-29 21:33:10.000000123 +0000 UTC\n\t// 1973-11-29 21:33:10.000000123 +0000 UTC\n}\n\nfunc ExampleUnregisterExt() {\n\tt := time.Unix(123456789, 123)\n\n\t{\n\t\tmsgpack.RegisterExt(1, (*EventTime)(nil))\n\t\tb, err := msgpack.Marshal(&EventTime{t})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmsgpack.UnregisterExt(1)\n\n\t\tvar v interface{}\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\twanted := \"msgpack: unknown ext id=1\"\n\t\tif err.Error() != wanted {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmsgpack.RegisterExt(1, (*OneMoreSecondEventTime)(nil))\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(v.(*OneMoreSecondEventTime).UTC())\n\t}\n\n\t{\n\t\tmsgpack.RegisterExt(1, (*OneMoreSecondEventTime)(nil))\n\t\tb, err := msgpack.Marshal(&OneMoreSecondEventTime{\n\t\t\tEventTime{t},\n\t\t})\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmsgpack.UnregisterExt(1)\n\t\tvar v interface{}\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\twanted := \"msgpack: unknown ext id=1\"\n\t\tif err.Error() != wanted {\n\t\t\tpanic(err)\n\t\t}\n\n\t\tmsgpack.RegisterExt(1, (*EventTime)(nil))\n\t\terr = msgpack.Unmarshal(b, &v)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(v.(*EventTime).UTC())\n\t}\n\n\t// Output: 1973-11-29 21:33:10.000000123 +0000 UTC\n\t// 1973-11-29 21:33:10.000000123 +0000 UTC\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 4.0244140625,
          "content": "package msgpack_test\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\n\t\"github.com/vmihailenco/msgpack/v5\"\n)\n\nfunc ExampleMarshal() {\n\ttype Item struct {\n\t\tFoo string\n\t}\n\n\tb, err := msgpack.Marshal(&Item{Foo: \"bar\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar item Item\n\terr = msgpack.Unmarshal(b, &item)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(item.Foo)\n\t// Output: bar\n}\n\nfunc ExampleMarshal_mapStringInterface() {\n\tin := map[string]interface{}{\"foo\": 1, \"hello\": \"world\"}\n\tb, err := msgpack.Marshal(in)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tvar out map[string]interface{}\n\terr = msgpack.Unmarshal(b, &out)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tfmt.Println(\"foo =\", out[\"foo\"])\n\tfmt.Println(\"hello =\", out[\"hello\"])\n\n\t// Output:\n\t// foo = 1\n\t// hello = world\n}\n\nfunc ExampleDecoder_SetMapDecoder() {\n\tbuf := new(bytes.Buffer)\n\n\tenc := msgpack.NewEncoder(buf)\n\tin := map[string]string{\"hello\": \"world\"}\n\terr := enc.Encode(in)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdec := msgpack.NewDecoder(buf)\n\n\t// Causes decoder to produce map[string]string instead of map[string]interface{}.\n\tdec.SetMapDecoder(func(d *msgpack.Decoder) (interface{}, error) {\n\t\tn, err := d.DecodeMapLen()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tm := make(map[string]string, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\tmk, err := d.DecodeString()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tmv, err := d.DecodeString()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\tm[mk] = mv\n\t\t}\n\t\treturn m, nil\n\t})\n\n\tout, err := dec.DecodeInterface()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%#v\", out)\n\t// Output: map[string]string{\"hello\":\"world\"}\n}\n\nfunc ExampleDecoder_Query() {\n\tb, err := msgpack.Marshal([]map[string]interface{}{\n\t\t{\"id\": 1, \"attrs\": map[string]interface{}{\"phone\": 12345}},\n\t\t{\"id\": 2, \"attrs\": map[string]interface{}{\"phone\": 54321}},\n\t})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdec := msgpack.NewDecoder(bytes.NewBuffer(b))\n\tvalues, err := dec.Query(\"*.attrs.phone\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"phones are\", values)\n\n\tdec.Reset(bytes.NewBuffer(b))\n\tvalues, err = dec.Query(\"1.attrs.phone\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(\"2nd phone is\", values[0])\n\t// Output: phones are [12345 54321]\n\t// 2nd phone is 54321\n}\n\nfunc ExampleEncoder_UseArrayEncodedStructs() {\n\ttype Item struct {\n\t\tFoo string\n\t\tBar string\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.UseArrayEncodedStructs(true)\n\n\terr := enc.Encode(&Item{Foo: \"foo\", Bar: \"bar\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdec := msgpack.NewDecoder(&buf)\n\tv, err := dec.DecodeInterface()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(v)\n\t// Output: [foo bar]\n}\n\nfunc ExampleMarshal_asArray() {\n\ttype Item struct {\n\t\t_msgpack struct{} `msgpack:\",as_array\"`\n\t\tFoo      string\n\t\tBar      string\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\terr := enc.Encode(&Item{Foo: \"foo\", Bar: \"bar\"})\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tdec := msgpack.NewDecoder(&buf)\n\tv, err := dec.DecodeInterface()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Println(v)\n\t// Output: [foo bar]\n}\n\nfunc ExampleMarshal_omitEmpty() {\n\ttype Item struct {\n\t\tFoo string\n\t\tBar string\n\t}\n\n\titem := &Item{\n\t\tFoo: \"hello\",\n\t}\n\tb, err := msgpack.Marshal(item)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"item: %q\\n\", b)\n\n\ttype ItemOmitEmpty struct {\n\t\t_msgpack struct{} `msgpack:\",omitempty\"`\n\t\tFoo      string\n\t\tBar      string\n\t}\n\n\titemOmitEmpty := &ItemOmitEmpty{\n\t\tFoo: \"hello\",\n\t}\n\tb, err = msgpack.Marshal(itemOmitEmpty)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"item2: %q\\n\", b)\n\n\t// Output: item: \"\\x82\\xa3Foo\\xa5hello\\xa3Bar\\xa0\"\n\t// item2: \"\\x81\\xa3Foo\\xa5hello\"\n}\n\nfunc ExampleMarshal_escapedNames() {\n\tog := map[string]interface{}{\n\t\t\"something:special\": uint(123),\n\t\t\"hello, world\":      \"hello!\",\n\t}\n\traw, err := msgpack.Marshal(og)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttype Item struct {\n\t\tSomethingSpecial uint   `msgpack:\"'something:special'\"`\n\t\tHelloWorld       string `msgpack:\"'hello, world'\"`\n\t}\n\tvar item Item\n\tif err := msgpack.Unmarshal(raw, &item); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%#v\\n\", item)\n\t//output: msgpack_test.Item{SomethingSpecial:0x7b, HelloWorld:\"hello!\"}\n}\n"
        },
        {
          "name": "ext.go",
          "type": "blob",
          "size": 6.1328125,
          "content": "package msgpack\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\ntype extInfo struct {\n\tType    reflect.Type\n\tDecoder func(d *Decoder, v reflect.Value, extLen int) error\n}\n\nvar extTypes = make(map[int8]*extInfo)\n\ntype MarshalerUnmarshaler interface {\n\tMarshaler\n\tUnmarshaler\n}\n\nfunc RegisterExt(extID int8, value MarshalerUnmarshaler) {\n\tRegisterExtEncoder(extID, value, func(e *Encoder, v reflect.Value) ([]byte, error) {\n\t\tmarshaler := v.Interface().(Marshaler)\n\t\treturn marshaler.MarshalMsgpack()\n\t})\n\tRegisterExtDecoder(extID, value, func(d *Decoder, v reflect.Value, extLen int) error {\n\t\tb, err := d.readN(extLen)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn v.Interface().(Unmarshaler).UnmarshalMsgpack(b)\n\t})\n}\n\nfunc UnregisterExt(extID int8) {\n\tunregisterExtEncoder(extID)\n\tunregisterExtDecoder(extID)\n}\n\nfunc RegisterExtEncoder(\n\textID int8,\n\tvalue interface{},\n\tencoder func(enc *Encoder, v reflect.Value) ([]byte, error),\n) {\n\tunregisterExtEncoder(extID)\n\n\ttyp := reflect.TypeOf(value)\n\textEncoder := makeExtEncoder(extID, typ, encoder)\n\ttypeEncMap.Store(extID, typ)\n\ttypeEncMap.Store(typ, extEncoder)\n\tif typ.Kind() == reflect.Ptr {\n\t\ttypeEncMap.Store(typ.Elem(), makeExtEncoderAddr(extEncoder))\n\t}\n}\n\nfunc unregisterExtEncoder(extID int8) {\n\tt, ok := typeEncMap.Load(extID)\n\tif !ok {\n\t\treturn\n\t}\n\ttypeEncMap.Delete(extID)\n\ttyp := t.(reflect.Type)\n\ttypeEncMap.Delete(typ)\n\tif typ.Kind() == reflect.Ptr {\n\t\ttypeEncMap.Delete(typ.Elem())\n\t}\n}\n\nfunc makeExtEncoder(\n\textID int8,\n\ttyp reflect.Type,\n\tencoder func(enc *Encoder, v reflect.Value) ([]byte, error),\n) encoderFunc {\n\tnilable := typ.Kind() == reflect.Ptr\n\n\treturn func(e *Encoder, v reflect.Value) error {\n\t\tif nilable && v.IsNil() {\n\t\t\treturn e.EncodeNil()\n\t\t}\n\n\t\tb, err := encoder(e, v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := e.EncodeExtHeader(extID, len(b)); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\treturn e.write(b)\n\t}\n}\n\nfunc makeExtEncoderAddr(extEncoder encoderFunc) encoderFunc {\n\treturn func(e *Encoder, v reflect.Value) error {\n\t\tif !v.CanAddr() {\n\t\t\treturn fmt.Errorf(\"msgpack: EncodeExt(nonaddressable %T)\", v.Interface())\n\t\t}\n\t\treturn extEncoder(e, v.Addr())\n\t}\n}\n\nfunc RegisterExtDecoder(\n\textID int8,\n\tvalue interface{},\n\tdecoder func(dec *Decoder, v reflect.Value, extLen int) error,\n) {\n\tunregisterExtDecoder(extID)\n\n\ttyp := reflect.TypeOf(value)\n\textDecoder := makeExtDecoder(extID, typ, decoder)\n\textTypes[extID] = &extInfo{\n\t\tType:    typ,\n\t\tDecoder: decoder,\n\t}\n\n\ttypeDecMap.Store(extID, typ)\n\ttypeDecMap.Store(typ, extDecoder)\n\tif typ.Kind() == reflect.Ptr {\n\t\ttypeDecMap.Store(typ.Elem(), makeExtDecoderAddr(extDecoder))\n\t}\n}\n\nfunc unregisterExtDecoder(extID int8) {\n\tt, ok := typeDecMap.Load(extID)\n\tif !ok {\n\t\treturn\n\t}\n\ttypeDecMap.Delete(extID)\n\tdelete(extTypes, extID)\n\ttyp := t.(reflect.Type)\n\ttypeDecMap.Delete(typ)\n\tif typ.Kind() == reflect.Ptr {\n\t\ttypeDecMap.Delete(typ.Elem())\n\t}\n}\n\nfunc makeExtDecoder(\n\twantedExtID int8,\n\ttyp reflect.Type,\n\tdecoder func(d *Decoder, v reflect.Value, extLen int) error,\n) decoderFunc {\n\treturn nilAwareDecoder(typ, func(d *Decoder, v reflect.Value) error {\n\t\textID, extLen, err := d.DecodeExtHeader()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif extID != wantedExtID {\n\t\t\treturn fmt.Errorf(\"msgpack: got ext type=%d, wanted %d\", extID, wantedExtID)\n\t\t}\n\t\treturn decoder(d, v, extLen)\n\t})\n}\n\nfunc makeExtDecoderAddr(extDecoder decoderFunc) decoderFunc {\n\treturn func(d *Decoder, v reflect.Value) error {\n\t\tif !v.CanAddr() {\n\t\t\treturn fmt.Errorf(\"msgpack: DecodeExt(nonaddressable %T)\", v.Interface())\n\t\t}\n\t\treturn extDecoder(d, v.Addr())\n\t}\n}\n\nfunc (e *Encoder) EncodeExtHeader(extID int8, extLen int) error {\n\tif err := e.encodeExtLen(extLen); err != nil {\n\t\treturn err\n\t}\n\tif err := e.w.WriteByte(byte(extID)); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc (e *Encoder) encodeExtLen(l int) error {\n\tswitch l {\n\tcase 1:\n\t\treturn e.writeCode(msgpcode.FixExt1)\n\tcase 2:\n\t\treturn e.writeCode(msgpcode.FixExt2)\n\tcase 4:\n\t\treturn e.writeCode(msgpcode.FixExt4)\n\tcase 8:\n\t\treturn e.writeCode(msgpcode.FixExt8)\n\tcase 16:\n\t\treturn e.writeCode(msgpcode.FixExt16)\n\t}\n\tif l <= math.MaxUint8 {\n\t\treturn e.write1(msgpcode.Ext8, uint8(l))\n\t}\n\tif l <= math.MaxUint16 {\n\t\treturn e.write2(msgpcode.Ext16, uint16(l))\n\t}\n\treturn e.write4(msgpcode.Ext32, uint32(l))\n}\n\nfunc (d *Decoder) DecodeExtHeader() (extID int8, extLen int, err error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn\n\t}\n\treturn d.extHeader(c)\n}\n\nfunc (d *Decoder) extHeader(c byte) (int8, int, error) {\n\textLen, err := d.parseExtLen(c)\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\textID, err := d.readCode()\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\treturn int8(extID), extLen, nil\n}\n\nfunc (d *Decoder) parseExtLen(c byte) (int, error) {\n\tswitch c {\n\tcase msgpcode.FixExt1:\n\t\treturn 1, nil\n\tcase msgpcode.FixExt2:\n\t\treturn 2, nil\n\tcase msgpcode.FixExt4:\n\t\treturn 4, nil\n\tcase msgpcode.FixExt8:\n\t\treturn 8, nil\n\tcase msgpcode.FixExt16:\n\t\treturn 16, nil\n\tcase msgpcode.Ext8:\n\t\tn, err := d.uint8()\n\t\treturn int(n), err\n\tcase msgpcode.Ext16:\n\t\tn, err := d.uint16()\n\t\treturn int(n), err\n\tcase msgpcode.Ext32:\n\t\tn, err := d.uint32()\n\t\treturn int(n), err\n\tdefault:\n\t\treturn 0, fmt.Errorf(\"msgpack: invalid code=%x decoding ext len\", c)\n\t}\n}\n\nfunc (d *Decoder) decodeInterfaceExt(c byte) (interface{}, error) {\n\textID, extLen, err := d.extHeader(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tinfo, ok := extTypes[extID]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"msgpack: unknown ext id=%d\", extID)\n\t}\n\n\tv := d.newValue(info.Type).Elem()\n\tif nilable(v.Kind()) && v.IsNil() {\n\t\tv.Set(d.newValue(info.Type.Elem()))\n\t}\n\n\tif err := info.Decoder(d, v, extLen); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn v.Interface(), nil\n}\n\nfunc (d *Decoder) skipExt(c byte) error {\n\tn, err := d.parseExtLen(c)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn d.skipN(n + 1)\n}\n\nfunc (d *Decoder) skipExtHeader(c byte) error {\n\t// Read ext type.\n\t_, err := d.readCode()\n\tif err != nil {\n\t\treturn err\n\t}\n\t// Read ext body len.\n\tfor i := 0; i < extHeaderLen(c); i++ {\n\t\t_, err := d.readCode()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc extHeaderLen(c byte) int {\n\tswitch c {\n\tcase msgpcode.Ext8:\n\t\treturn 1\n\tcase msgpcode.Ext16:\n\t\treturn 2\n\tcase msgpcode.Ext32:\n\t\treturn 4\n\t}\n\treturn 0\n}\n"
        },
        {
          "name": "ext_test.go",
          "type": "blob",
          "size": 3.2177734375,
          "content": "package msgpack_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/vmihailenco/msgpack/v5\"\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nfunc init() {\n\tmsgpack.RegisterExt(9, (*ExtTest)(nil))\n}\n\ntype ExtTest struct {\n\tS string\n}\n\nvar (\n\t_ msgpack.Marshaler   = (*ExtTest)(nil)\n\t_ msgpack.Unmarshaler = (*ExtTest)(nil)\n)\n\nfunc (ext ExtTest) MarshalMsgpack() ([]byte, error) {\n\treturn msgpack.Marshal(\"hello \" + ext.S)\n}\n\nfunc (ext *ExtTest) UnmarshalMsgpack(b []byte) error {\n\treturn msgpack.Unmarshal(b, &ext.S)\n}\n\nfunc TestEncodeDecodeExtHeader(t *testing.T) {\n\tv := &ExtTest{\"world\"}\n\n\tpayload, err := v.MarshalMsgpack()\n\trequire.Nil(t, err)\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\terr = enc.EncodeExtHeader(9, len(payload))\n\trequire.Nil(t, err)\n\n\t_, err = buf.Write(payload)\n\trequire.Nil(t, err)\n\n\tvar dst interface{}\n\terr = msgpack.Unmarshal(buf.Bytes(), &dst)\n\trequire.Nil(t, err)\n\n\tv = dst.(*ExtTest)\n\twanted := \"hello world\"\n\trequire.Equal(t, v.S, wanted)\n\n\tdec := msgpack.NewDecoder(&buf)\n\textID, extLen, err := dec.DecodeExtHeader()\n\trequire.Nil(t, err)\n\trequire.Equal(t, int8(9), extID)\n\trequire.Equal(t, len(payload), extLen)\n\n\tdata := make([]byte, extLen)\n\terr = dec.ReadFull(data)\n\trequire.Nil(t, err)\n\n\tv = &ExtTest{}\n\terr = v.UnmarshalMsgpack(data)\n\trequire.Nil(t, err)\n\trequire.Equal(t, wanted, v.S)\n}\n\nfunc TestExt(t *testing.T) {\n\tv := &ExtTest{\"world\"}\n\tb, err := msgpack.Marshal(v)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar dst interface{}\n\terr = msgpack.Unmarshal(b, &dst)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tv, ok := dst.(*ExtTest)\n\tif !ok {\n\t\tt.Fatalf(\"got %#v, wanted ExtTest\", dst)\n\t}\n\n\twanted := \"hello world\"\n\tif v.S != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", v.S, wanted)\n\t}\n\n\text := new(ExtTest)\n\terr = msgpack.Unmarshal(b, &ext)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif ext.S != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", ext.S, wanted)\n\t}\n}\n\nfunc TestUnknownExt(t *testing.T) {\n\tb := []byte{byte(msgpcode.FixExt1), 2, 0}\n\n\tvar dst interface{}\n\terr := msgpack.Unmarshal(b, &dst)\n\tif err == nil {\n\t\tt.Fatalf(\"got nil, wanted error\")\n\t}\n\tgot := err.Error()\n\twanted := \"msgpack: unknown ext id=2\"\n\tif got != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", got, wanted)\n\t}\n}\n\nfunc TestSliceOfTime(t *testing.T) {\n\tin := []interface{}{time.Now()}\n\tb, err := msgpack.Marshal(in)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar out []interface{}\n\terr = msgpack.Unmarshal(b, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\toutTime := out[0].(time.Time)\n\tinTime := in[0].(time.Time)\n\tif outTime.Unix() != inTime.Unix() {\n\t\tt.Fatalf(\"got %v, wanted %v\", outTime, inTime)\n\t}\n}\n\ntype customPayload struct {\n\tpayload []byte\n}\n\nfunc (cp *customPayload) MarshalMsgpack() ([]byte, error) {\n\treturn cp.payload, nil\n}\n\nfunc (cp *customPayload) UnmarshalMsgpack(b []byte) error {\n\tcp.payload = b\n\treturn nil\n}\n\nfunc TestDecodeCustomPayload(t *testing.T) {\n\tb, err := hex.DecodeString(\"c70500c09eec3100\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmsgpack.RegisterExt(0, (*customPayload)(nil))\n\n\tvar cp *customPayload\n\terr = msgpack.Unmarshal(b, &cp)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tpayload := hex.EncodeToString(cp.payload)\n\twanted := \"c09eec3100\"\n\tif payload != wanted {\n\t\tt.Fatalf(\"got %q, wanted %q\", payload, wanted)\n\t}\n}\n"
        },
        {
          "name": "extra",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.310546875,
          "content": "module github.com/vmihailenco/msgpack/v5\n\ngo 1.19\n\nrequire (\n\tgithub.com/stretchr/testify v1.6.1\n\tgithub.com/vmihailenco/tagparser/v2 v2.0.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.0 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.1845703125,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "intern.go",
          "type": "blob",
          "size": 4.8955078125,
          "content": "package msgpack\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nconst (\n\tminInternedStringLen = 3\n\tmaxDictLen           = math.MaxUint16\n)\n\nvar internedStringExtID = int8(math.MinInt8)\n\nfunc init() {\n\textTypes[internedStringExtID] = &extInfo{\n\t\tType:    stringType,\n\t\tDecoder: decodeInternedStringExt,\n\t}\n}\n\nfunc decodeInternedStringExt(d *Decoder, v reflect.Value, extLen int) error {\n\tidx, err := d.decodeInternedStringIndex(extLen)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts, err := d.internedStringAtIndex(idx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tv.SetString(s)\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\nfunc encodeInternedInterfaceValue(e *Encoder, v reflect.Value) error {\n\tif v.IsNil() {\n\t\treturn e.EncodeNil()\n\t}\n\n\tv = v.Elem()\n\tif v.Kind() == reflect.String {\n\t\treturn e.encodeInternedString(v.String(), true)\n\t}\n\treturn e.EncodeValue(v)\n}\n\nfunc encodeInternedStringValue(e *Encoder, v reflect.Value) error {\n\treturn e.encodeInternedString(v.String(), true)\n}\n\nfunc (e *Encoder) encodeInternedString(s string, intern bool) error {\n\t// Interned string takes at least 3 bytes. Plain string 1 byte + string len.\n\tif idx, ok := e.dict[s]; ok {\n\t\treturn e.encodeInternedStringIndex(idx)\n\t}\n\n\tif intern && len(s) >= minInternedStringLen && len(e.dict) < maxDictLen {\n\t\tif e.dict == nil {\n\t\t\te.dict = make(map[string]int)\n\t\t}\n\t\tidx := len(e.dict)\n\t\te.dict[s] = idx\n\t}\n\n\treturn e.encodeNormalString(s)\n}\n\nfunc (e *Encoder) encodeInternedStringIndex(idx int) error {\n\tif idx <= math.MaxUint8 {\n\t\tif err := e.writeCode(msgpcode.FixExt1); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e.write1(byte(internedStringExtID), uint8(idx))\n\t}\n\n\tif idx <= math.MaxUint16 {\n\t\tif err := e.writeCode(msgpcode.FixExt2); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e.write2(byte(internedStringExtID), uint16(idx))\n\t}\n\n\tif uint64(idx) <= math.MaxUint32 {\n\t\tif err := e.writeCode(msgpcode.FixExt4); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn e.write4(byte(internedStringExtID), uint32(idx))\n\t}\n\n\treturn fmt.Errorf(\"msgpack: interned string index=%d is too large\", idx)\n}\n\n//------------------------------------------------------------------------------\n\nfunc decodeInternedInterfaceValue(d *Decoder, v reflect.Value) error {\n\ts, err := d.decodeInternedString(true)\n\tif err == nil {\n\t\tv.Set(reflect.ValueOf(s))\n\t\treturn nil\n\t}\n\tif err != nil {\n\t\tif _, ok := err.(unexpectedCodeError); !ok {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := d.s.UnreadByte(); err != nil {\n\t\treturn err\n\t}\n\treturn decodeInterfaceValue(d, v)\n}\n\nfunc decodeInternedStringValue(d *Decoder, v reflect.Value) error {\n\ts, err := d.decodeInternedString(true)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tv.SetString(s)\n\treturn nil\n}\n\nfunc (d *Decoder) decodeInternedString(intern bool) (string, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif msgpcode.IsFixedString(c) {\n\t\tn := int(c & msgpcode.FixedStrMask)\n\t\treturn d.decodeInternedStringWithLen(n, intern)\n\t}\n\n\tswitch c {\n\tcase msgpcode.Nil:\n\t\treturn \"\", nil\n\tcase msgpcode.FixExt1, msgpcode.FixExt2, msgpcode.FixExt4:\n\t\ttypeID, extLen, err := d.extHeader(c)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\tif typeID != internedStringExtID {\n\t\t\terr := fmt.Errorf(\"msgpack: got ext type=%d, wanted %d\",\n\t\t\t\ttypeID, internedStringExtID)\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tidx, err := d.decodeInternedStringIndex(extLen)\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\treturn d.internedStringAtIndex(idx)\n\tcase msgpcode.Str8, msgpcode.Bin8:\n\t\tn, err := d.uint8()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn d.decodeInternedStringWithLen(int(n), intern)\n\tcase msgpcode.Str16, msgpcode.Bin16:\n\t\tn, err := d.uint16()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn d.decodeInternedStringWithLen(int(n), intern)\n\tcase msgpcode.Str32, msgpcode.Bin32:\n\t\tn, err := d.uint32()\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn d.decodeInternedStringWithLen(int(n), intern)\n\t}\n\n\treturn \"\", unexpectedCodeError{\n\t\tcode: c,\n\t\thint: \"interned string\",\n\t}\n}\n\nfunc (d *Decoder) decodeInternedStringIndex(extLen int) (int, error) {\n\tswitch extLen {\n\tcase 1:\n\t\tn, err := d.uint8()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn int(n), nil\n\tcase 2:\n\t\tn, err := d.uint16()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn int(n), nil\n\tcase 4:\n\t\tn, err := d.uint32()\n\t\tif err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\treturn int(n), nil\n\t}\n\n\terr := fmt.Errorf(\"msgpack: unsupported ext len=%d decoding interned string\", extLen)\n\treturn 0, err\n}\n\nfunc (d *Decoder) internedStringAtIndex(idx int) (string, error) {\n\tif idx >= len(d.dict) {\n\t\terr := fmt.Errorf(\"msgpack: interned string at index=%d does not exist\", idx)\n\t\treturn \"\", err\n\t}\n\treturn d.dict[idx], nil\n}\n\nfunc (d *Decoder) decodeInternedStringWithLen(n int, intern bool) (string, error) {\n\tif n <= 0 {\n\t\treturn \"\", nil\n\t}\n\n\ts, err := d.stringWithLen(n)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif intern && len(s) >= minInternedStringLen && len(d.dict) < maxDictLen {\n\t\td.dict = append(d.dict, s)\n\t}\n\n\treturn s, nil\n}\n"
        },
        {
          "name": "intern_test.go",
          "type": "blob",
          "size": 2.70703125,
          "content": "package msgpack_test\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/vmihailenco/msgpack/v5\"\n)\n\ntype NoIntern struct {\n\tA string\n\tB string\n\tC interface{}\n}\n\ntype Intern struct {\n\tA string      `msgpack:\",intern\"`\n\tB string      `msgpack:\",intern\"`\n\tC interface{} `msgpack:\",intern\"`\n}\n\nfunc TestInternedString(t *testing.T) {\n\tvar buf bytes.Buffer\n\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.UseInternedStrings(true)\n\n\tdec := msgpack.NewDecoder(&buf)\n\tdec.UseInternedStrings(true)\n\n\tfor i := 0; i < 3; i++ {\n\t\terr := enc.EncodeString(\"hello\")\n\t\trequire.Nil(t, err)\n\t}\n\n\tfor i := 0; i < 3; i++ {\n\t\ts, err := dec.DecodeString()\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, \"hello\", s)\n\t}\n\n\terr := enc.Encode(\"hello\")\n\trequire.Nil(t, err)\n\n\tv, err := dec.DecodeInterface()\n\trequire.Nil(t, err)\n\trequire.Equal(t, \"hello\", v)\n\n\t_, err = dec.DecodeInterface()\n\trequire.Equal(t, io.EOF, err)\n}\n\nfunc TestInternedStringTag(t *testing.T) {\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tdec := msgpack.NewDecoder(&buf)\n\n\tin := []Intern{\n\t\t{\"f\", \"f\", \"f\"},\n\t\t{\"fo\", \"fo\", \"fo\"},\n\t\t{\"foo\", \"foo\", \"foo\"},\n\t\t{\"f\", \"fo\", \"foo\"},\n\t}\n\terr := enc.Encode(in)\n\trequire.Nil(t, err)\n\n\tvar out []Intern\n\terr = dec.Decode(&out)\n\trequire.Nil(t, err)\n\trequire.Equal(t, in, out)\n}\n\nfunc TestResetDict(t *testing.T) {\n\tdict := []string{\"hello world\", \"foo bar\"}\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tdec := msgpack.NewDecoder(&buf)\n\n\t{\n\t\tenc.ResetDict(&buf, dictMap(dict))\n\t\terr := enc.EncodeString(\"hello world\")\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, 3, buf.Len())\n\n\t\tdec.ResetDict(&buf, dict)\n\t\ts, err := dec.DecodeString()\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, \"hello world\", s)\n\t}\n\n\t{\n\t\tenc.ResetDict(&buf, dictMap(dict))\n\t\terr := enc.Encode(\"foo bar\")\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, 3, buf.Len())\n\n\t\tdec.ResetDict(&buf, dict)\n\t\ts, err := dec.DecodeInterface()\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, \"foo bar\", s)\n\t}\n\n\tdec.ResetDict(&buf, dict)\n\t_ = enc.EncodeString(\"xxxx\")\n\trequire.Equal(t, 5, buf.Len())\n\t_ = enc.Encode(\"xxxx\")\n\trequire.Equal(t, 10, buf.Len())\n}\n\nfunc TestMapWithInternedString(t *testing.T) {\n\ttype M map[string]interface{}\n\n\tdict := []string{\"hello world\", \"foo bar\"}\n\n\tvar buf bytes.Buffer\n\n\tenc := msgpack.NewEncoder(nil)\n\tenc.ResetDict(&buf, dictMap(dict))\n\n\tdec := msgpack.NewDecoder(nil)\n\tdec.ResetDict(&buf, dict)\n\n\tfor i := 0; i < 100; i++ {\n\t\tin := M{\n\t\t\t\"foo bar\":     \"hello world\",\n\t\t\t\"hello world\": \"foo bar\",\n\t\t\t\"foo\":         \"bar\",\n\t\t}\n\t\terr := enc.Encode(in)\n\t\trequire.Nil(t, err)\n\n\t\t_, err = dec.DecodeInterface()\n\t\trequire.Nil(t, err)\n\t}\n}\n\nfunc dictMap(dict []string) map[string]int {\n\tm := make(map[string]int, len(dict))\n\tfor i, s := range dict {\n\t\tm[s] = i\n\t}\n\treturn m\n}\n"
        },
        {
          "name": "msgpack.go",
          "type": "blob",
          "size": 0.9560546875,
          "content": "package msgpack\n\nimport \"fmt\"\n\ntype Marshaler interface {\n\tMarshalMsgpack() ([]byte, error)\n}\n\ntype Unmarshaler interface {\n\tUnmarshalMsgpack([]byte) error\n}\n\ntype CustomEncoder interface {\n\tEncodeMsgpack(*Encoder) error\n}\n\ntype CustomDecoder interface {\n\tDecodeMsgpack(*Decoder) error\n}\n\n//------------------------------------------------------------------------------\n\ntype RawMessage []byte\n\nvar (\n\t_ CustomEncoder = (RawMessage)(nil)\n\t_ CustomDecoder = (*RawMessage)(nil)\n)\n\nfunc (m RawMessage) EncodeMsgpack(enc *Encoder) error {\n\treturn enc.write(m)\n}\n\nfunc (m *RawMessage) DecodeMsgpack(dec *Decoder) error {\n\tmsg, err := dec.DecodeRaw()\n\tif err != nil {\n\t\treturn err\n\t}\n\t*m = msg\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype unexpectedCodeError struct {\n\thint string\n\tcode byte\n}\n\nfunc (err unexpectedCodeError) Error() string {\n\treturn fmt.Sprintf(\"msgpack: unexpected code=%x decoding %s\", err.code, err.hint)\n}\n"
        },
        {
          "name": "msgpack_test.go",
          "type": "blob",
          "size": 10.6337890625,
          "content": "package msgpack_test\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/stretchr/testify/suite\"\n\t\"github.com/vmihailenco/msgpack/v5\"\n)\n\ntype nameStruct struct {\n\tName string\n}\n\ntype MsgpackTest struct {\n\tsuite.Suite\n\n\tbuf *bytes.Buffer\n\tenc *msgpack.Encoder\n\tdec *msgpack.Decoder\n}\n\nfunc (t *MsgpackTest) SetupTest() {\n\tt.buf = &bytes.Buffer{}\n\tt.enc = msgpack.NewEncoder(t.buf)\n\tt.dec = msgpack.NewDecoder(bufio.NewReader(t.buf))\n}\n\nfunc TestMsgpackTestSuite(t *testing.T) {\n\tsuite.Run(t, new(MsgpackTest))\n}\n\nfunc (t *MsgpackTest) TestDecodeNil() {\n\tt.NotNil(t.dec.Decode(nil))\n}\n\nfunc (t *MsgpackTest) TestTime() {\n\tin := time.Now()\n\tvar out time.Time\n\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.True(out.Equal(in))\n\n\tvar zero time.Time\n\tt.Nil(t.enc.Encode(zero))\n\tt.Nil(t.dec.Decode(&out))\n\tt.True(out.Equal(zero))\n\tt.True(out.IsZero())\n}\n\nfunc (t *MsgpackTest) TestLargeBytes() {\n\tN := int(1e6)\n\n\tsrc := bytes.Repeat([]byte{'1'}, N)\n\tt.Nil(t.enc.Encode(src))\n\tvar dst []byte\n\tt.Nil(t.dec.Decode(&dst))\n\tt.Equal(dst, src)\n}\n\nfunc (t *MsgpackTest) TestLargeString() {\n\tN := int(1e6)\n\n\tsrc := string(bytes.Repeat([]byte{'1'}, N))\n\tt.Nil(t.enc.Encode(src))\n\tvar dst string\n\tt.Nil(t.dec.Decode(&dst))\n\tt.Equal(dst, src)\n}\n\nfunc (t *MsgpackTest) TestSliceOfStructs() {\n\tin := []*nameStruct{{\"hello\"}}\n\tvar out []*nameStruct\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out, in)\n}\n\nfunc (t *MsgpackTest) TestMap() {\n\tfor _, i := range []struct {\n\t\tm map[string]string\n\t\tb []byte\n\t}{\n\t\t{map[string]string{}, []byte{0x80}},\n\t\t{map[string]string{\"hello\": \"world\"}, []byte{0x81, 0xa5, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0xa5, 0x77, 0x6f, 0x72, 0x6c, 0x64}},\n\t} {\n\t\tt.Nil(t.enc.Encode(i.m))\n\t\tt.Equal(t.buf.Bytes(), i.b, fmt.Errorf(\"err encoding %v\", i.m))\n\t\tvar m map[string]string\n\t\tt.Nil(t.dec.Decode(&m))\n\t\tt.Equal(m, i.m)\n\t}\n}\n\nfunc (t *MsgpackTest) TestStructNil() {\n\tvar dst *nameStruct\n\n\tt.Nil(t.enc.Encode(nameStruct{Name: \"foo\"}))\n\tt.Nil(t.dec.Decode(&dst))\n\tt.NotNil(dst)\n\tt.Equal(dst.Name, \"foo\")\n}\n\nfunc (t *MsgpackTest) TestStructUnknownField() {\n\tin := struct {\n\t\tField1 string\n\t\tField2 string\n\t\tField3 string\n\t}{\n\t\tField1: \"value1\",\n\t\tField2: \"value2\",\n\t\tField3: \"value3\",\n\t}\n\tt.Nil(t.enc.Encode(in))\n\n\tout := struct {\n\t\tField2 string\n\t}{}\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out.Field2, \"value2\")\n}\n\n//------------------------------------------------------------------------------\n\ntype coderStruct struct {\n\tname string\n}\n\ntype wrapperStruct struct {\n\tcoderStruct\n}\n\nvar (\n\t_ msgpack.CustomEncoder = (*coderStruct)(nil)\n\t_ msgpack.CustomDecoder = (*coderStruct)(nil)\n)\n\nfunc (s *coderStruct) Name() string {\n\treturn s.name\n}\n\nfunc (s *coderStruct) EncodeMsgpack(enc *msgpack.Encoder) error {\n\treturn enc.Encode(s.name)\n}\n\nfunc (s *coderStruct) DecodeMsgpack(dec *msgpack.Decoder) error {\n\treturn dec.Decode(&s.name)\n}\n\nfunc (t *MsgpackTest) TestCoder() {\n\tin := &coderStruct{name: \"hello\"}\n\tvar out coderStruct\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out.Name(), \"hello\")\n}\n\nfunc (t *MsgpackTest) TestNilCoder() {\n\tin := &coderStruct{name: \"hello\"}\n\tvar out *coderStruct\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out.Name(), \"hello\")\n}\n\nfunc (t *MsgpackTest) TestNilCoderValue() {\n\tin := &coderStruct{name: \"hello\"}\n\tvar out *coderStruct\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.DecodeValue(reflect.ValueOf(&out)))\n\tt.Equal(out.Name(), \"hello\")\n}\n\nfunc (t *MsgpackTest) TestPtrToCoder() {\n\tin := &coderStruct{name: \"hello\"}\n\tvar out coderStruct\n\tout2 := &out\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out2))\n\tt.Equal(out.Name(), \"hello\")\n}\n\nfunc (t *MsgpackTest) TestWrappedCoder() {\n\tin := &wrapperStruct{coderStruct: coderStruct{name: \"hello\"}}\n\tvar out wrapperStruct\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out.Name(), \"hello\")\n}\n\n//------------------------------------------------------------------------------\n\ntype struct2 struct {\n\tName string\n}\n\ntype struct1 struct {\n\tName    string\n\tStruct2 struct2\n}\n\nfunc (t *MsgpackTest) TestNestedStructs() {\n\tin := &struct1{Name: \"hello\", Struct2: struct2{Name: \"world\"}}\n\tvar out struct1\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out.Name, in.Name)\n\tt.Equal(out.Struct2.Name, in.Struct2.Name)\n}\n\ntype Struct4 struct {\n\tName2 string\n}\n\ntype Struct3 struct {\n\tStruct4\n\tName1 string\n}\n\nfunc TestEmbedding(t *testing.T) {\n\tin := &Struct3{\n\t\tName1: \"hello\",\n\t\tStruct4: Struct4{\n\t\t\tName2: \"world\",\n\t\t},\n\t}\n\tvar out Struct3\n\n\tb, err := msgpack.Marshal(in)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\terr = msgpack.Unmarshal(b, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif out.Name1 != in.Name1 {\n\t\tt.Fatalf(\"\")\n\t}\n\tif out.Name2 != in.Name2 {\n\t\tt.Fatalf(\"\")\n\t}\n}\n\nfunc TestEmptyTimeMarshalWithInterface(t *testing.T) {\n\ta := time.Time{}\n\tb, err := msgpack.Marshal(a)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar out interface{}\n\terr = msgpack.Unmarshal(b, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tname, _ := out.(time.Time).Zone()\n\tif name != \"UTC\" {\n\t\tt.Fatal(\"Got wrong timezone\")\n\t}\n\n\tvar out2 time.Time\n\terr = msgpack.Unmarshal(b, &out2)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tname, _ = out2.Zone()\n\tif name != \"UTC\" {\n\t\tt.Fatal(\"Got wrong timezone\")\n\t}\n}\n\nfunc (t *MsgpackTest) TestSliceNil() {\n\tin := [][]*int{nil}\n\tvar out [][]*int\n\n\tt.Nil(t.enc.Encode(in))\n\tt.Nil(t.dec.Decode(&out))\n\tt.Equal(out, in)\n}\n\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n\nfunc TestNoPanicOnUnsupportedKey(t *testing.T) {\n\tdata := []byte{0x81, 0x81, 0xa1, 0x78, 0xc3, 0xc3}\n\n\t_, err := msgpack.NewDecoder(bytes.NewReader(data)).DecodeTypedMap()\n\trequire.EqualError(t, err, \"msgpack: unsupported map key: map[string]interface {}\")\n}\n\nfunc TestMapDefault(t *testing.T) {\n\tin := map[string]interface{}{\n\t\t\"foo\": \"bar\",\n\t\t\"hello\": map[string]interface{}{\n\t\t\t\"foo\": \"bar\",\n\t\t},\n\t}\n\tb, err := msgpack.Marshal(in)\n\trequire.Nil(t, err)\n\n\tvar out map[string]interface{}\n\terr = msgpack.Unmarshal(b, &out)\n\trequire.Nil(t, err)\n\trequire.Equal(t, in, out)\n}\n\nfunc TestRawMessage(t *testing.T) {\n\ttype In struct {\n\t\tFoo map[string]interface{}\n\t}\n\n\ttype Out struct {\n\t\tFoo msgpack.RawMessage\n\t}\n\n\ttype Out2 struct {\n\t\tFoo interface{}\n\t}\n\n\tb, err := msgpack.Marshal(&In{\n\t\tFoo: map[string]interface{}{\n\t\t\t\"hello\": \"world\",\n\t\t},\n\t})\n\trequire.Nil(t, err)\n\n\tvar out Out\n\terr = msgpack.Unmarshal(b, &out)\n\trequire.Nil(t, err)\n\n\tvar m map[string]string\n\terr = msgpack.Unmarshal(out.Foo, &m)\n\trequire.Nil(t, err)\n\trequire.Equal(t, map[string]string{\n\t\t\"hello\": \"world\",\n\t}, m)\n\n\tmsg := new(msgpack.RawMessage)\n\tout2 := Out2{\n\t\tFoo: msg,\n\t}\n\terr = msgpack.Unmarshal(b, &out2)\n\trequire.Nil(t, err)\n\trequire.Equal(t, out.Foo, *msg)\n}\n\nfunc TestInterface(t *testing.T) {\n\ttype Interface struct {\n\t\tFoo interface{}\n\t}\n\n\tin := Interface{Foo: \"foo\"}\n\tb, err := msgpack.Marshal(in)\n\trequire.Nil(t, err)\n\n\tvar str string\n\tout := Interface{Foo: &str}\n\terr = msgpack.Unmarshal(b, &out)\n\trequire.Nil(t, err)\n\trequire.Equal(t, \"foo\", str)\n}\n\nfunc TestNaN(t *testing.T) {\n\tin := float64(math.NaN())\n\tb, err := msgpack.Marshal(in)\n\trequire.Nil(t, err)\n\n\tvar out float64\n\terr = msgpack.Unmarshal(b, &out)\n\trequire.Nil(t, err)\n\trequire.True(t, math.IsNaN(out))\n}\n\nfunc TestSetSortMapKeys(t *testing.T) {\n\tin := map[string]interface{}{\n\t\t\"a\": \"a\",\n\t\t\"b\": \"b\",\n\t\t\"c\": \"c\",\n\t\t\"d\": \"d\",\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.SetSortMapKeys(true)\n\tdec := msgpack.NewDecoder(&buf)\n\n\terr := enc.Encode(in)\n\trequire.Nil(t, err)\n\n\twanted := make([]byte, buf.Len())\n\tcopy(wanted, buf.Bytes())\n\tbuf.Reset()\n\n\tfor i := 0; i < 100; i++ {\n\t\terr := enc.Encode(in)\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, wanted, buf.Bytes())\n\n\t\tout, err := dec.DecodeMap()\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, in, out)\n\t}\n}\n\nfunc TestSetOmitEmpty(t *testing.T) {\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.SetOmitEmpty(true)\n\terr := enc.Encode(EmbeddingPtrTest{})\n\trequire.Nil(t, err)\n\n\tvar t2 *EmbeddingPtrTest\n\tdec := msgpack.NewDecoder(&buf)\n\terr = dec.Decode(&t2)\n\trequire.Nil(t, err)\n\trequire.Nil(t, t2.Exported)\n\n\ttype Nested struct {\n\t\tFoo string\n\t\tBar string\n\t}\n\ttype Item struct {\n\t\tX Nested\n\t\tY *Nested\n\t}\n\ti := Item{}\n\tbuf.Reset()\n\terr = enc.Encode(i)\n\trequire.Nil(t, err)\n\trequire.NotContains(t, buf.Bytes(), byte('X'))\n\trequire.NotContains(t, buf.Bytes(), byte('Y'))\n\n\ti = Item{Y: &Nested{}}\n\tbuf.Reset()\n\terr = enc.Encode(i)\n\trequire.Nil(t, err)\n\trequire.NotContains(t, buf.Bytes(), byte('X'))\n\trequire.Contains(t, buf.Bytes(), byte('Y'))\n}\n\ntype NullInt struct {\n\tValid bool\n\tInt   int\n}\n\nfunc (i *NullInt) Set(j int) {\n\ti.Int = j\n\ti.Valid = true\n}\n\nfunc (i NullInt) IsZero() bool {\n\treturn !i.Valid\n}\n\nfunc (i NullInt) MarshalMsgpack() ([]byte, error) {\n\treturn msgpack.Marshal(i.Int)\n}\n\nfunc (i *NullInt) UnmarshalMsgpack(b []byte) error {\n\tif err := msgpack.Unmarshal(b, &i.Int); err != nil {\n\t\treturn err\n\t}\n\ti.Valid = true\n\treturn nil\n}\n\ntype Secretive struct {\n\tVisible bool\n\thidden  bool\n}\n\ntype T struct {\n\tI NullInt `msgpack:\",omitempty\"`\n\tJ NullInt\n\t// Secretive is not a \"simple\" struct because it has an hidden field.\n\tS Secretive `msgpack:\",omitempty\"`\n}\n\nfunc ExampleMarshal_ignore_simple_zero_structs_when_tagged_with_omitempty() {\n\tvar t1 T\n\traw, err := msgpack.Marshal(t1)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar t2 T\n\tif err = msgpack.Unmarshal(raw, &t2); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%#v\\n\", t2)\n\n\tt2.I.Set(42)\n\tt2.S.hidden = true // won't be included because it is a hidden field\n\traw, err = msgpack.Marshal(t2)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tvar t3 T\n\tif err = msgpack.Unmarshal(raw, &t3); err != nil {\n\t\tpanic(err)\n\t}\n\tfmt.Printf(\"%#v\\n\", t3)\n\t// Output: msgpack_test.T{I:msgpack_test.NullInt{Valid:false, Int:0}, J:msgpack_test.NullInt{Valid:true, Int:0}, S:msgpack_test.Secretive{Visible:false, hidden:false}}\n\t// msgpack_test.T{I:msgpack_test.NullInt{Valid:true, Int:42}, J:msgpack_test.NullInt{Valid:true, Int:0}, S:msgpack_test.Secretive{Visible:false, hidden:false}}\n}\n\ntype (\n\tValue   interface{}\n\tWrapper struct {\n\t\tValue Value `msgpack:\"v,omitempty\"`\n\t}\n)\n\nfunc TestEncodeWrappedValue(t *testing.T) {\n\tv := (*time.Time)(nil)\n\tc := &Wrapper{\n\t\tValue: v,\n\t}\n\tvar buf bytes.Buffer\n\trequire.Nil(t, msgpack.NewEncoder(&buf).Encode(v))\n\trequire.Nil(t, msgpack.NewEncoder(&buf).Encode(c))\n}\n\nfunc TestPtrValueDecode(t *testing.T) {\n\ttype Foo struct {\n\t\tBar *int\n\t}\n\n\tb, err := msgpack.Marshal(Foo{})\n\trequire.Nil(t, err)\n\n\tbar1 := 123\n\tfoo := Foo{Bar: &bar1}\n\n\terr = msgpack.Unmarshal(b, &foo)\n\trequire.Nil(t, err)\n\trequire.Nil(t, foo.Bar)\n\n\tbar2 := 456\n\tb, err = msgpack.Marshal(Foo{Bar: &bar2})\n\trequire.Nil(t, err)\n\n\terr = msgpack.Unmarshal(b, &foo)\n\trequire.Nil(t, err)\n\trequire.NotNil(t, foo.Bar)\n\trequire.Equal(t, *foo.Bar, bar2)\n}\n"
        },
        {
          "name": "msgpcode",
          "type": "tree",
          "content": null
        },
        {
          "name": "package.json",
          "type": "blob",
          "size": 0.044921875,
          "content": "{\n  \"name\": \"msgpack\",\n  \"version\": \"5.4.1\"\n}\n"
        },
        {
          "name": "safe.go",
          "type": "blob",
          "size": 0.2451171875,
          "content": "// +build appengine\n\npackage msgpack\n\n// bytesToString converts byte slice to string.\nfunc bytesToString(b []byte) string {\n\treturn string(b)\n}\n\n// stringToBytes converts string to byte slice.\nfunc stringToBytes(s string) []byte {\n\treturn []byte(s)\n}\n"
        },
        {
          "name": "time.go",
          "type": "blob",
          "size": 2.953125,
          "content": "package msgpack\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"time\"\n\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\nvar timeExtID int8 = -1\n\nfunc init() {\n\tRegisterExtEncoder(timeExtID, time.Time{}, timeEncoder)\n\tRegisterExtDecoder(timeExtID, time.Time{}, timeDecoder)\n}\n\nfunc timeEncoder(e *Encoder, v reflect.Value) ([]byte, error) {\n\treturn e.encodeTime(v.Interface().(time.Time)), nil\n}\n\nfunc timeDecoder(d *Decoder, v reflect.Value, extLen int) error {\n\ttm, err := d.decodeTime(extLen)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif tm.IsZero() {\n\t\t// Zero time does not have timezone information.\n\t\ttm = tm.UTC()\n\t}\n\n\tptr := v.Addr().Interface().(*time.Time)\n\t*ptr = tm\n\n\treturn nil\n}\n\nfunc (e *Encoder) EncodeTime(tm time.Time) error {\n\tb := e.encodeTime(tm)\n\tif err := e.encodeExtLen(len(b)); err != nil {\n\t\treturn err\n\t}\n\tif err := e.w.WriteByte(byte(timeExtID)); err != nil {\n\t\treturn err\n\t}\n\treturn e.write(b)\n}\n\nfunc (e *Encoder) encodeTime(tm time.Time) []byte {\n\tif e.timeBuf == nil {\n\t\te.timeBuf = make([]byte, 12)\n\t}\n\n\tsecs := uint64(tm.Unix())\n\tif secs>>34 == 0 {\n\t\tdata := uint64(tm.Nanosecond())<<34 | secs\n\n\t\tif data&0xffffffff00000000 == 0 {\n\t\t\tb := e.timeBuf[:4]\n\t\t\tbinary.BigEndian.PutUint32(b, uint32(data))\n\t\t\treturn b\n\t\t}\n\n\t\tb := e.timeBuf[:8]\n\t\tbinary.BigEndian.PutUint64(b, data)\n\t\treturn b\n\t}\n\n\tb := e.timeBuf[:12]\n\tbinary.BigEndian.PutUint32(b, uint32(tm.Nanosecond()))\n\tbinary.BigEndian.PutUint64(b[4:], secs)\n\treturn b\n}\n\nfunc (d *Decoder) DecodeTime() (time.Time, error) {\n\tc, err := d.readCode()\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\t// Legacy format.\n\tif c == msgpcode.FixedArrayLow|2 {\n\t\tsec, err := d.DecodeInt64()\n\t\tif err != nil {\n\t\t\treturn time.Time{}, err\n\t\t}\n\n\t\tnsec, err := d.DecodeInt64()\n\t\tif err != nil {\n\t\t\treturn time.Time{}, err\n\t\t}\n\n\t\treturn time.Unix(sec, nsec), nil\n\t}\n\n\tif msgpcode.IsString(c) {\n\t\ts, err := d.string(c)\n\t\tif err != nil {\n\t\t\treturn time.Time{}, err\n\t\t}\n\t\treturn time.Parse(time.RFC3339Nano, s)\n\t}\n\n\textID, extLen, err := d.extHeader(c)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\t// NodeJS seems to use extID 13.\n\tif extID != timeExtID && extID != 13 {\n\t\treturn time.Time{}, fmt.Errorf(\"msgpack: invalid time ext id=%d\", extID)\n\t}\n\n\ttm, err := d.decodeTime(extLen)\n\tif err != nil {\n\t\treturn tm, err\n\t}\n\n\tif tm.IsZero() {\n\t\t// Zero time does not have timezone information.\n\t\treturn tm.UTC(), nil\n\t}\n\treturn tm, nil\n}\n\nfunc (d *Decoder) decodeTime(extLen int) (time.Time, error) {\n\tb, err := d.readN(extLen)\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\tswitch len(b) {\n\tcase 4:\n\t\tsec := binary.BigEndian.Uint32(b)\n\t\treturn time.Unix(int64(sec), 0), nil\n\tcase 8:\n\t\tsec := binary.BigEndian.Uint64(b)\n\t\tnsec := int64(sec >> 34)\n\t\tsec &= 0x00000003ffffffff\n\t\treturn time.Unix(int64(sec), nsec), nil\n\tcase 12:\n\t\tnsec := binary.BigEndian.Uint32(b)\n\t\tsec := binary.BigEndian.Uint64(b[4:])\n\t\treturn time.Unix(int64(sec), int64(nsec)), nil\n\tdefault:\n\t\terr = fmt.Errorf(\"msgpack: invalid ext len=%d decoding time\", extLen)\n\t\treturn time.Time{}, err\n\t}\n}\n"
        },
        {
          "name": "types.go",
          "type": "blob",
          "size": 8.59765625,
          "content": "package msgpack\n\nimport (\n\t\"encoding\"\n\t\"fmt\"\n\t\"log\"\n\t\"reflect\"\n\t\"sync\"\n\n\t\"github.com/vmihailenco/tagparser/v2\"\n)\n\nvar errorType = reflect.TypeOf((*error)(nil)).Elem()\n\nvar (\n\tcustomEncoderType = reflect.TypeOf((*CustomEncoder)(nil)).Elem()\n\tcustomDecoderType = reflect.TypeOf((*CustomDecoder)(nil)).Elem()\n)\n\nvar (\n\tmarshalerType   = reflect.TypeOf((*Marshaler)(nil)).Elem()\n\tunmarshalerType = reflect.TypeOf((*Unmarshaler)(nil)).Elem()\n)\n\nvar (\n\tbinaryMarshalerType   = reflect.TypeOf((*encoding.BinaryMarshaler)(nil)).Elem()\n\tbinaryUnmarshalerType = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()\n)\n\nvar (\n\ttextMarshalerType   = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()\n\ttextUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()\n)\n\ntype (\n\tencoderFunc func(*Encoder, reflect.Value) error\n\tdecoderFunc func(*Decoder, reflect.Value) error\n)\n\nvar (\n\ttypeEncMap sync.Map\n\ttypeDecMap sync.Map\n)\n\n// Register registers encoder and decoder functions for a value.\n// This is low level API and in most cases you should prefer implementing\n// CustomEncoder/CustomDecoder or Marshaler/Unmarshaler interfaces.\nfunc Register(value interface{}, enc encoderFunc, dec decoderFunc) {\n\ttyp := reflect.TypeOf(value)\n\tif enc != nil {\n\t\ttypeEncMap.Store(typ, enc)\n\t}\n\tif dec != nil {\n\t\ttypeDecMap.Store(typ, dec)\n\t}\n}\n\n//------------------------------------------------------------------------------\n\nconst defaultStructTag = \"msgpack\"\n\nvar structs = newStructCache()\n\ntype structCache struct {\n\tm sync.Map\n}\n\ntype structCacheKey struct {\n\ttyp reflect.Type\n\ttag string\n}\n\nfunc newStructCache() *structCache {\n\treturn new(structCache)\n}\n\nfunc (m *structCache) Fields(typ reflect.Type, tag string) *fields {\n\tkey := structCacheKey{tag: tag, typ: typ}\n\n\tif v, ok := m.m.Load(key); ok {\n\t\treturn v.(*fields)\n\t}\n\n\tfs := getFields(typ, tag)\n\tm.m.Store(key, fs)\n\n\treturn fs\n}\n\n//------------------------------------------------------------------------------\n\ntype field struct {\n\tencoder   encoderFunc\n\tdecoder   decoderFunc\n\tname      string\n\tindex     []int\n\tomitEmpty bool\n}\n\nfunc (f *field) Omit(e *Encoder, strct reflect.Value) bool {\n\tv, ok := fieldByIndex(strct, f.index)\n\tif !ok {\n\t\treturn true\n\t}\n\tforced := e.flags&omitEmptyFlag != 0\n\treturn (f.omitEmpty || forced) && e.isEmptyValue(v)\n}\n\nfunc (f *field) EncodeValue(e *Encoder, strct reflect.Value) error {\n\tv, ok := fieldByIndex(strct, f.index)\n\tif !ok {\n\t\treturn e.EncodeNil()\n\t}\n\treturn f.encoder(e, v)\n}\n\nfunc (f *field) DecodeValue(d *Decoder, strct reflect.Value) error {\n\tv := fieldByIndexAlloc(strct, f.index)\n\treturn f.decoder(d, v)\n}\n\n//------------------------------------------------------------------------------\n\ntype fields struct {\n\tType    reflect.Type\n\tMap     map[string]*field\n\tList    []*field\n\tAsArray bool\n\n\thasOmitEmpty bool\n}\n\nfunc newFields(typ reflect.Type) *fields {\n\treturn &fields{\n\t\tType: typ,\n\t\tMap:  make(map[string]*field, typ.NumField()),\n\t\tList: make([]*field, 0, typ.NumField()),\n\t}\n}\n\nfunc (fs *fields) Add(field *field) {\n\tfs.warnIfFieldExists(field.name)\n\tfs.Map[field.name] = field\n\tfs.List = append(fs.List, field)\n\tif field.omitEmpty {\n\t\tfs.hasOmitEmpty = true\n\t}\n}\n\nfunc (fs *fields) warnIfFieldExists(name string) {\n\tif _, ok := fs.Map[name]; ok {\n\t\tlog.Printf(\"msgpack: %s already has field=%s\", fs.Type, name)\n\t}\n}\n\nfunc (fs *fields) OmitEmpty(e *Encoder, strct reflect.Value) []*field {\n\tforced := e.flags&omitEmptyFlag != 0\n\tif !fs.hasOmitEmpty && !forced {\n\t\treturn fs.List\n\t}\n\n\tfields := make([]*field, 0, len(fs.List))\n\n\tfor _, f := range fs.List {\n\t\tif !f.Omit(e, strct) {\n\t\t\tfields = append(fields, f)\n\t\t}\n\t}\n\n\treturn fields\n}\n\nfunc getFields(typ reflect.Type, fallbackTag string) *fields {\n\tfs := newFields(typ)\n\n\tvar omitEmpty bool\n\tfor i := 0; i < typ.NumField(); i++ {\n\t\tf := typ.Field(i)\n\n\t\ttagStr := f.Tag.Get(defaultStructTag)\n\t\tif tagStr == \"\" && fallbackTag != \"\" {\n\t\t\ttagStr = f.Tag.Get(fallbackTag)\n\t\t}\n\n\t\ttag := tagparser.Parse(tagStr)\n\t\tif tag.Name == \"-\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tif f.Name == \"_msgpack\" {\n\t\t\tfs.AsArray = tag.HasOption(\"as_array\") || tag.HasOption(\"asArray\")\n\t\t\tif tag.HasOption(\"omitempty\") {\n\t\t\t\tomitEmpty = true\n\t\t\t}\n\t\t}\n\n\t\tif f.PkgPath != \"\" && !f.Anonymous {\n\t\t\tcontinue\n\t\t}\n\n\t\tfield := &field{\n\t\t\tname:      tag.Name,\n\t\t\tindex:     f.Index,\n\t\t\tomitEmpty: omitEmpty || tag.HasOption(\"omitempty\"),\n\t\t}\n\n\t\tif tag.HasOption(\"intern\") {\n\t\t\tswitch f.Type.Kind() {\n\t\t\tcase reflect.Interface:\n\t\t\t\tfield.encoder = encodeInternedInterfaceValue\n\t\t\t\tfield.decoder = decodeInternedInterfaceValue\n\t\t\tcase reflect.String:\n\t\t\t\tfield.encoder = encodeInternedStringValue\n\t\t\t\tfield.decoder = decodeInternedStringValue\n\t\t\tdefault:\n\t\t\t\terr := fmt.Errorf(\"msgpack: intern strings are not supported on %s\", f.Type)\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t} else {\n\t\t\tfield.encoder = getEncoder(f.Type)\n\t\t\tfield.decoder = getDecoder(f.Type)\n\t\t}\n\n\t\tif field.name == \"\" {\n\t\t\tfield.name = f.Name\n\t\t}\n\n\t\tif f.Anonymous && !tag.HasOption(\"noinline\") {\n\t\t\tinline := tag.HasOption(\"inline\")\n\t\t\tif inline {\n\t\t\t\tinlineFields(fs, f.Type, field, fallbackTag)\n\t\t\t} else {\n\t\t\t\tinline = shouldInline(fs, f.Type, field, fallbackTag)\n\t\t\t}\n\n\t\t\tif inline {\n\t\t\t\tif _, ok := fs.Map[field.name]; ok {\n\t\t\t\t\tlog.Printf(\"msgpack: %s already has field=%s\", fs.Type, field.name)\n\t\t\t\t}\n\t\t\t\tfs.Map[field.name] = field\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tfs.Add(field)\n\n\t\tif alias, ok := tag.Options[\"alias\"]; ok {\n\t\t\tfs.warnIfFieldExists(alias)\n\t\t\tfs.Map[alias] = field\n\t\t}\n\t}\n\treturn fs\n}\n\nvar (\n\tencodeStructValuePtr uintptr\n\tdecodeStructValuePtr uintptr\n)\n\n//nolint:gochecknoinits\nfunc init() {\n\tencodeStructValuePtr = reflect.ValueOf(encodeStructValue).Pointer()\n\tdecodeStructValuePtr = reflect.ValueOf(decodeStructValue).Pointer()\n}\n\nfunc inlineFields(fs *fields, typ reflect.Type, f *field, tag string) {\n\tinlinedFields := getFields(typ, tag).List\n\tfor _, field := range inlinedFields {\n\t\tif _, ok := fs.Map[field.name]; ok {\n\t\t\t// Don't inline shadowed fields.\n\t\t\tcontinue\n\t\t}\n\t\tfield.index = append(f.index, field.index...)\n\t\tfs.Add(field)\n\t}\n}\n\nfunc shouldInline(fs *fields, typ reflect.Type, f *field, tag string) bool {\n\tvar encoder encoderFunc\n\tvar decoder decoderFunc\n\n\tif typ.Kind() == reflect.Struct {\n\t\tencoder = f.encoder\n\t\tdecoder = f.decoder\n\t} else {\n\t\tfor typ.Kind() == reflect.Ptr {\n\t\t\ttyp = typ.Elem()\n\t\t\tencoder = getEncoder(typ)\n\t\t\tdecoder = getDecoder(typ)\n\t\t}\n\t\tif typ.Kind() != reflect.Struct {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tif reflect.ValueOf(encoder).Pointer() != encodeStructValuePtr {\n\t\treturn false\n\t}\n\tif reflect.ValueOf(decoder).Pointer() != decodeStructValuePtr {\n\t\treturn false\n\t}\n\n\tinlinedFields := getFields(typ, tag).List\n\tfor _, field := range inlinedFields {\n\t\tif _, ok := fs.Map[field.name]; ok {\n\t\t\t// Don't auto inline if there are shadowed fields.\n\t\t\treturn false\n\t\t}\n\t}\n\n\tfor _, field := range inlinedFields {\n\t\tfield.index = append(f.index, field.index...)\n\t\tfs.Add(field)\n\t}\n\treturn true\n}\n\ntype isZeroer interface {\n\tIsZero() bool\n}\n\nfunc (e *Encoder) isEmptyValue(v reflect.Value) bool {\n\tkind := v.Kind()\n\n\tfor kind == reflect.Interface {\n\t\tif v.IsNil() {\n\t\t\treturn true\n\t\t}\n\t\tv = v.Elem()\n\t\tkind = v.Kind()\n\t}\n\n\tif z, ok := v.Interface().(isZeroer); ok {\n\t\treturn nilable(kind) && v.IsNil() || z.IsZero()\n\t}\n\n\tswitch kind {\n\tcase reflect.Array, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.Len() == 0\n\tcase reflect.Struct:\n\t\tstructFields := structs.Fields(v.Type(), e.structTag)\n\t\tfields := structFields.OmitEmpty(e, v)\n\t\treturn len(fields) == 0\n\tcase reflect.Bool:\n\t\treturn !v.Bool()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.Int() == 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n\t\treturn v.Uint() == 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.Float() == 0\n\tcase reflect.Ptr:\n\t\treturn v.IsNil()\n\tdefault:\n\t\treturn false\n\t}\n}\n\nfunc fieldByIndex(v reflect.Value, index []int) (_ reflect.Value, ok bool) {\n\tif len(index) == 1 {\n\t\treturn v.Field(index[0]), true\n\t}\n\n\tfor i, idx := range index {\n\t\tif i > 0 {\n\t\t\tif v.Kind() == reflect.Ptr {\n\t\t\t\tif v.IsNil() {\n\t\t\t\t\treturn v, false\n\t\t\t\t}\n\t\t\t\tv = v.Elem()\n\t\t\t}\n\t\t}\n\t\tv = v.Field(idx)\n\t}\n\n\treturn v, true\n}\n\nfunc fieldByIndexAlloc(v reflect.Value, index []int) reflect.Value {\n\tif len(index) == 1 {\n\t\treturn v.Field(index[0])\n\t}\n\n\tfor i, idx := range index {\n\t\tif i > 0 {\n\t\t\tvar ok bool\n\t\t\tv, ok = indirectNil(v)\n\t\t\tif !ok {\n\t\t\t\treturn v\n\t\t\t}\n\t\t}\n\t\tv = v.Field(idx)\n\t}\n\n\treturn v\n}\n\nfunc indirectNil(v reflect.Value) (reflect.Value, bool) {\n\tif v.Kind() == reflect.Ptr {\n\t\tif v.IsNil() {\n\t\t\tif !v.CanSet() {\n\t\t\t\treturn v, false\n\t\t\t}\n\t\t\telemType := v.Type().Elem()\n\t\t\tif elemType.Kind() != reflect.Struct {\n\t\t\t\treturn v, false\n\t\t\t}\n\t\t\tv.Set(cachedValue(elemType))\n\t\t}\n\t\tv = v.Elem()\n\t}\n\treturn v, true\n}\n"
        },
        {
          "name": "types_test.go",
          "type": "blob",
          "size": 26.736328125,
          "content": "package msgpack_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/big\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/require\"\n\t\"github.com/vmihailenco/msgpack/v5\"\n\t\"github.com/vmihailenco/msgpack/v5/msgpcode\"\n)\n\n//------------------------------------------------------------------------------\n\ntype Object struct {\n\tn int64\n}\n\nfunc (o *Object) MarshalMsgpack() ([]byte, error) {\n\treturn msgpack.Marshal(o.n)\n}\n\nfunc (o *Object) UnmarshalMsgpack(b []byte) error {\n\treturn msgpack.Unmarshal(b, &o.n)\n}\n\n//------------------------------------------------------------------------------\n\ntype CustomTime time.Time\n\nfunc (t CustomTime) EncodeMsgpack(enc *msgpack.Encoder) error {\n\treturn enc.Encode(time.Time(t))\n}\n\nfunc (t *CustomTime) DecodeMsgpack(dec *msgpack.Decoder) error {\n\tvar tm time.Time\n\terr := dec.Decode(&tm)\n\tif err != nil {\n\t\treturn err\n\t}\n\t*t = CustomTime(tm)\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype IntSet map[int]struct{}\n\nvar (\n\t_ msgpack.CustomEncoder = (*IntSet)(nil)\n\t_ msgpack.CustomDecoder = (*IntSet)(nil)\n)\n\nfunc (set IntSet) EncodeMsgpack(enc *msgpack.Encoder) error {\n\tslice := make([]int, 0, len(set))\n\tfor n := range set {\n\t\tslice = append(slice, n)\n\t}\n\treturn enc.Encode(slice)\n}\n\nfunc (setptr *IntSet) DecodeMsgpack(dec *msgpack.Decoder) error {\n\tn, err := dec.DecodeArrayLen()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tset := make(IntSet, n)\n\tfor i := 0; i < n; i++ {\n\t\tn, err := dec.DecodeInt()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tset[n] = struct{}{}\n\t}\n\t*setptr = set\n\n\treturn nil\n}\n\n//------------------------------------------------------------------------------\n\ntype CustomEncoder struct {\n\tstr string\n\tref *CustomEncoder\n\tnum int\n}\n\nvar (\n\t_ msgpack.CustomEncoder = (*CustomEncoder)(nil)\n\t_ msgpack.CustomDecoder = (*CustomEncoder)(nil)\n)\n\nfunc (s *CustomEncoder) EncodeMsgpack(enc *msgpack.Encoder) error {\n\tif s == nil {\n\t\treturn enc.EncodeNil()\n\t}\n\treturn enc.EncodeMulti(s.str, s.ref, s.num)\n}\n\nfunc (s *CustomEncoder) DecodeMsgpack(dec *msgpack.Decoder) error {\n\treturn dec.DecodeMulti(&s.str, &s.ref, &s.num)\n}\n\ntype CustomEncoderField struct {\n\tField CustomEncoder\n}\n\ntype CustomEncoderEmbeddedPtr struct {\n\t*CustomEncoder\n}\n\nfunc (s *CustomEncoderEmbeddedPtr) DecodeMsgpack(dec *msgpack.Decoder) error {\n\tif s.CustomEncoder == nil {\n\t\ts.CustomEncoder = new(CustomEncoder)\n\t}\n\treturn s.CustomEncoder.DecodeMsgpack(dec)\n}\n\n//------------------------------------------------------------------------------\n\ntype JSONFallbackTest struct {\n\tFoo string `json:\"foo,omitempty\"`\n\tBar string `json:\",omitempty\" msgpack:\"bar\"`\n}\n\nfunc TestUseJsonTag(t *testing.T) {\n\tvar buf bytes.Buffer\n\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.SetCustomStructTag(\"json\")\n\n\tin := &JSONFallbackTest{Foo: \"hello\", Bar: \"world\"}\n\terr := enc.Encode(in)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdec := msgpack.NewDecoder(&buf)\n\tdec.SetCustomStructTag(\"json\")\n\n\tout := new(JSONFallbackTest)\n\terr = dec.Decode(out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif out.Foo != in.Foo {\n\t\tt.Fatalf(\"got %q, wanted %q\", out.Foo, in.Foo)\n\t}\n\tif out.Bar != in.Bar {\n\t\tt.Fatalf(\"got %q, wanted %q\", out.Foo, in.Foo)\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype CustomFallbackTest struct {\n\tFoo string `custom:\"foo,omitempty\"`\n\tBar string `custom:\",omitempty\" msgpack:\"bar\"`\n}\n\nfunc TestUseCustomTag(t *testing.T) {\n\tvar buf bytes.Buffer\n\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.SetCustomStructTag(\"custom\")\n\tin := &CustomFallbackTest{Foo: \"hello\", Bar: \"world\"}\n\terr := enc.Encode(in)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tdec := msgpack.NewDecoder(&buf)\n\tdec.SetCustomStructTag(\"custom\")\n\tout := new(CustomFallbackTest)\n\terr = dec.Decode(out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif out.Foo != in.Foo || out.Foo != \"hello\" {\n\t\tt.Fatalf(\"got %q, wanted %q\", out.Foo, in.Foo)\n\t}\n\tif out.Bar != in.Bar || out.Bar != \"world\" {\n\t\tt.Fatalf(\"got %q, wanted %q\", out.Foo, in.Foo)\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype OmitTimeTest struct {\n\tFoo time.Time  `msgpack:\",omitempty\"`\n\tBar *time.Time `msgpack:\",omitempty\"`\n}\n\ntype OmitEmptyTest struct {\n\tFoo string `msgpack:\",omitempty\"`\n\tBar string `msgpack:\",omitempty\"`\n}\n\ntype InlineTest struct {\n\tOmitEmptyTest\n}\n\ntype InlinePtrTest struct {\n\t*OmitEmptyTest\n}\n\ntype FooTest struct {\n\tFoo string\n}\n\ntype FooDupTest FooTest\n\ntype InlineDupTest struct {\n\tFooTest\n\tFooDupTest\n}\n\ntype AsArrayTest struct {\n\t_msgpack struct{} `msgpack:\",as_array\"`\n\n\tOmitEmptyTest\n}\n\ntype ExtTestField struct {\n\tExtTest ExtTest\n}\n\n//------------------------------------------------------------------------------\n\ntype encoderTest struct {\n\tin     interface{}\n\twanted string\n}\n\nvar encoderTests = []encoderTest{\n\t{nil, \"c0\"},\n\n\t{[]byte(nil), \"c0\"},\n\t{[]byte{1, 2, 3}, \"c403010203\"},\n\t{[3]byte{1, 2, 3}, \"c403010203\"},\n\n\t{time.Unix(0, 0), \"d6ff00000000\"},\n\t{time.Unix(1, 1), \"d7ff0000000400000001\"},\n\t{time.Time{}, \"c70cff00000000fffffff1886e0900\"},\n\n\t{IntSet{}, \"90\"},\n\t{IntSet{8: struct{}{}}, \"9108\"},\n\n\t{map[string]string(nil), \"c0\"},\n\t{\n\t\tmap[string]string{\"a\": \"\", \"b\": \"\", \"c\": \"\", \"d\": \"\", \"e\": \"\"},\n\t\t\"85a161a0a162a0a163a0a164a0a165a0\",\n\t},\n\n\t{(*Object)(nil), \"c0\"},\n\t{&Object{}, \"d30000000000000000\"},\n\t{&Object{42}, \"d3000000000000002a\"},\n\t{[]*Object{nil, nil}, \"92c0c0\"},\n\n\t{&CustomEncoder{}, \"a0c000\"},\n\t{\n\t\t&CustomEncoder{\"a\", &CustomEncoder{\"b\", nil, 7}, 6},\n\t\t\"a161a162c00706\",\n\t},\n\n\t{OmitEmptyTest{}, \"80\"},\n\t{&OmitEmptyTest{Foo: \"hello\"}, \"81a3466f6fa568656c6c6f\"},\n\n\t{&InlineTest{OmitEmptyTest: OmitEmptyTest{Bar: \"world\"}}, \"81a3426172a5776f726c64\"},\n\t{&InlinePtrTest{OmitEmptyTest: &OmitEmptyTest{Bar: \"world\"}}, \"81a3426172a5776f726c64\"},\n\n\t{&AsArrayTest{}, \"92a0a0\"},\n\n\t{&JSONFallbackTest{Foo: \"hello\"}, \"82a3666f6fa568656c6c6fa3626172a0\"},\n\t{&JSONFallbackTest{Bar: \"world\"}, \"81a3626172a5776f726c64\"},\n\t{&JSONFallbackTest{Foo: \"hello\", Bar: \"world\"}, \"82a3666f6fa568656c6c6fa3626172a5776f726c64\"},\n\n\t{&NoIntern{A: \"foo\", B: \"foo\", C: \"foo\"}, \"83a141a3666f6fa142a3666f6fa143a3666f6f\"},\n\t{&Intern{A: \"foo\", B: \"foo\", C: \"foo\"}, \"83a141a3666f6fa142d48000a143d48000\"},\n}\n\nfunc TestEncoder(t *testing.T) {\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.SetCustomStructTag(\"json\")\n\tenc.SetSortMapKeys(true)\n\tenc.UseCompactInts(true)\n\n\tfor i, test := range encoderTests {\n\t\tbuf.Reset()\n\n\t\terr := enc.Encode(test.in)\n\t\trequire.Nil(t, err)\n\n\t\ts := hex.EncodeToString(buf.Bytes())\n\t\trequire.Equal(t, test.wanted, s, \"#%d\", i)\n\t}\n}\n\ntype floatEncoderTest struct {\n\tin      interface{}\n\twanted  string\n\tcompact bool\n}\n\nvar floatEncoderTests = []floatEncoderTest{\n\t{float32(3.0), \"ca40400000\", false},\n\t{float32(3.0), \"03\", true},\n\n\t{float64(3.0), \"cb4008000000000000\", false},\n\t{float64(3.0), \"03\", true},\n\n\t{float64(-3.0), \"cbc008000000000000\", false},\n\t{float64(-3.0), \"fd\", true},\n\n\t{math.NaN(), \"cb7ff8000000000001\", false},\n\t{math.NaN(), \"cb7ff8000000000001\", true},\n\t{math.Inf(1), \"cb7ff0000000000000\", false},\n\t{math.Inf(1), \"cb7ff0000000000000\", true},\n}\n\nfunc TestFloatEncoding(t *testing.T) {\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.UseCompactInts(true)\n\n\tfor _, test := range floatEncoderTests {\n\t\tbuf.Reset()\n\n\t\tenc.UseCompactFloats(test.compact)\n\n\t\terr := enc.Encode(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\ts := hex.EncodeToString(buf.Bytes())\n\t\tif s != test.wanted {\n\t\t\tt.Fatalf(\"%s != %s (in=%#v)\", s, test.wanted, test.in)\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype decoderTest struct {\n\tb   []byte\n\tout interface{}\n\terr string\n}\n\nvar decoderTests = []decoderTest{\n\t{b: []byte{byte(msgpcode.Bin32), 0x0f, 0xff, 0xff, 0xff}, out: new([]byte), err: \"EOF\"},\n\t{b: []byte{byte(msgpcode.Str32), 0x0f, 0xff, 0xff, 0xff}, out: new([]byte), err: \"EOF\"},\n\t{b: []byte{byte(msgpcode.Array32), 0x0f, 0xff, 0xff, 0xff}, out: new([]int), err: \"EOF\"},\n\t{b: []byte{byte(msgpcode.Map32), 0x0f, 0xff, 0xff, 0xff}, out: new(map[int]int), err: \"EOF\"},\n}\n\nfunc TestDecoder(t *testing.T) {\n\tfor i, test := range decoderTests {\n\t\terr := msgpack.Unmarshal(test.b, test.out)\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"#%d err is nil, wanted %q\", i, test.err)\n\t\t}\n\t\tif err.Error() != test.err {\n\t\t\tt.Fatalf(\"#%d err is %q, wanted %q\", i, err.Error(), test.err)\n\t\t}\n\t}\n}\n\n//------------------------------------------------------------------------------\n\ntype unexported struct {\n\tFoo string\n}\n\ntype Exported struct {\n\tBar string\n}\n\ntype EmbeddingTest struct {\n\tunexported\n\tExported\n}\n\ntype EmbeddingPtrTest struct {\n\t*Exported\n}\n\ntype EmbeddedTime struct {\n\ttime.Time\n}\n\ntype (\n\tinterfaceAlias     interface{}\n\tbyteAlias          byte\n\tuint8Alias         uint8\n\tstringAlias        string\n\tsliceByte          []byte\n\tsliceString        []string\n\tmapStringString    map[string]string\n\tmapStringInterface map[string]interface{}\n)\n\ntype StructTest struct {\n\tF1 sliceString\n\tF2 []string\n}\n\ntype typeTest struct {\n\t*testing.T\n\n\tin       interface{}\n\tout      interface{}\n\tencErr   string\n\tdecErr   string\n\twantnil  bool\n\twantzero bool\n\twanted   interface{}\n}\n\nfunc (t typeTest) String() string {\n\treturn fmt.Sprintf(\"in=%#v, out=%#v\", t.in, t.out)\n}\n\nfunc (t *typeTest) requireErr(err error, s string) {\n\tif err == nil {\n\t\tt.Fatalf(\"got %v error, wanted %q\", err, s)\n\t}\n\tif err.Error() != s {\n\t\tt.Fatalf(\"got %q error, wanted %q\", err, s)\n\t}\n}\n\nvar (\n\tintSlice   = make([]int, 0, 3)\n\trepoURL, _ = url.Parse(\"https://github.com/vmihailenco/msgpack\")\n\ttypeTests  = []typeTest{\n\t\t{in: make(chan bool), encErr: \"msgpack: Encode(unsupported chan bool)\"},\n\n\t\t{in: nil, out: nil, decErr: \"msgpack: Decode(nil)\"},\n\t\t{in: nil, out: 0, decErr: \"msgpack: Decode(non-pointer int)\"},\n\t\t{in: nil, out: (*int)(nil), decErr: \"msgpack: Decode(non-settable *int)\"},\n\t\t{in: nil, out: new(chan bool), decErr: \"msgpack: Decode(unsupported chan bool)\"},\n\n\t\t{in: true, out: new(bool)},\n\t\t{in: false, out: new(bool)},\n\n\t\t{in: nil, out: new(int), wanted: int(0)},\n\t\t{in: nil, out: new(*int), wantnil: true},\n\n\t\t{in: float32(3.14), out: new(float32)},\n\t\t{in: int8(-1), out: new(float32), wanted: float32(-1)},\n\t\t{in: int32(1), out: new(float32), wanted: float32(1)},\n\t\t{in: int32(999999999), out: new(float32), wanted: float32(999999999)},\n\t\t{in: int64(math.MaxInt64), out: new(float32), wanted: float32(math.MaxInt64)},\n\n\t\t{in: float64(3.14), out: new(float64)},\n\t\t{in: int8(-1), out: new(float64), wanted: float64(-1)},\n\t\t{in: int64(1), out: new(float64), wanted: float64(1)},\n\t\t{in: int64(999999999), out: new(float64), wanted: float64(999999999)},\n\t\t{in: int64(math.MaxInt64), out: new(float64), wanted: float64(math.MaxInt64)},\n\n\t\t{in: nil, out: new(*string), wantnil: true},\n\t\t{in: nil, out: new(string), wanted: \"\"},\n\t\t{in: \"\", out: new(string)},\n\t\t{in: \"foo\", out: new(string)},\n\n\t\t{in: nil, out: new([]byte), wantnil: true},\n\t\t{in: []byte(nil), out: new([]byte), wantnil: true},\n\t\t{in: []byte(nil), out: &[]byte{}, wantnil: true},\n\t\t{in: []byte{1, 2, 3}, out: new([]byte)},\n\t\t{in: []byte{1, 2, 3}, out: new([]byte)},\n\t\t{in: sliceByte{1, 2, 3}, out: new(sliceByte)},\n\t\t{in: []byteAlias{1, 2, 3}, out: new([]byteAlias)},\n\t\t{in: []uint8Alias{1, 2, 3}, out: new([]uint8Alias)},\n\n\t\t{in: nil, out: new([3]byte), wanted: [3]byte{}},\n\t\t{in: [3]byte{1, 2, 3}, out: new([3]byte)},\n\t\t{in: [3]byte{1, 2, 3}, out: new([2]byte), decErr: \"[2]uint8 len is 2, but msgpack has 3 elements\"},\n\n\t\t{in: nil, out: new([]interface{}), wantnil: true},\n\t\t{in: nil, out: new([]interface{}), wantnil: true},\n\t\t{in: []interface{}{int8(1), \"hello\"}, out: new([]interface{})},\n\n\t\t{in: nil, out: new([]int), wantnil: true},\n\t\t{in: nil, out: &[]int{1, 2}, wantnil: true},\n\t\t{in: []int(nil), out: new([]int), wantnil: true},\n\t\t{in: make([]int, 0), out: new([]int)},\n\t\t{in: []int{}, out: new([]int)},\n\t\t{in: []int{1, 2, 3}, out: new([]int)},\n\t\t{in: []int{1, 2, 3}, out: &intSlice},\n\t\t{in: [3]int{1, 2, 3}, out: new([3]int)},\n\t\t{in: [3]int{1, 2, 3}, out: new([2]int), decErr: \"[2]int len is 2, but msgpack has 3 elements\"},\n\n\t\t{in: []string(nil), out: new([]string), wantnil: true},\n\t\t{in: []string{}, out: new([]string)},\n\t\t{in: []string{\"a\", \"b\"}, out: new([]string)},\n\t\t{in: [2]string{\"a\", \"b\"}, out: new([2]string)},\n\t\t{in: sliceString{\"foo\", \"bar\"}, out: new(sliceString)},\n\t\t{in: []stringAlias{\"hello\"}, out: new([]stringAlias)},\n\n\t\t{in: nil, out: new(map[string]string), wantnil: true},\n\t\t{in: nil, out: new(map[int]int), wantnil: true},\n\t\t{in: nil, out: &map[string]string{\"foo\": \"bar\"}, wantnil: true},\n\t\t{in: nil, out: &map[int]int{1: 2}, wantnil: true},\n\t\t{in: map[string]string(nil), out: new(map[string]string)},\n\t\t{in: map[string]interface{}{\"foo\": nil}, out: new(map[string]interface{})},\n\t\t{in: mapStringString{\"foo\": \"bar\"}, out: new(mapStringString)},\n\t\t{in: map[stringAlias]stringAlias{\"foo\": \"bar\"}, out: new(map[stringAlias]stringAlias)},\n\t\t{in: mapStringInterface{\"foo\": \"bar\"}, out: new(mapStringInterface)},\n\t\t{in: map[stringAlias]interfaceAlias{\"foo\": \"bar\"}, out: new(map[stringAlias]interfaceAlias)},\n\t\t{in: map[int]string{1: \"string\"}, out: new(map[int]string)},\n\n\t\t{in: (*Object)(nil), out: new(*Object)},\n\t\t{in: &Object{42}, out: new(Object)},\n\t\t{in: []*Object{new(Object), new(Object)}, out: new([]*Object)},\n\n\t\t{in: IntSet{}, out: new(IntSet)},\n\t\t{in: IntSet{42: struct{}{}}, out: new(IntSet)},\n\t\t{in: IntSet{42: struct{}{}}, out: new(*IntSet)},\n\n\t\t{in: StructTest{sliceString{\"foo\", \"bar\"}, []string{\"hello\"}}, out: new(StructTest)},\n\t\t{in: StructTest{sliceString{\"foo\", \"bar\"}, []string{\"hello\"}}, out: new(*StructTest)},\n\n\t\t{in: EmbeddingTest{}, out: new(EmbeddingTest)},\n\t\t{\n\t\t\tin:     EmbeddingTest{},\n\t\t\tout:    new(EmbeddingPtrTest),\n\t\t\twanted: EmbeddingPtrTest{Exported: new(Exported)},\n\t\t},\n\t\t{\n\t\t\tin:     EmbeddingPtrTest{},\n\t\t\tout:    new(EmbeddingPtrTest),\n\t\t\twanted: EmbeddingPtrTest{Exported: new(Exported)},\n\t\t},\n\t\t{in: EmbeddingTest{}, out: new(*EmbeddingTest)},\n\t\t{\n\t\t\tin: EmbeddingTest{\n\t\t\t\tunexported: unexported{Foo: \"hello\"},\n\t\t\t\tExported:   Exported{Bar: \"world\"},\n\t\t\t},\n\t\t\tout: new(EmbeddingTest),\n\t\t},\n\n\t\t{in: time.Unix(0, 0), out: new(time.Time)},\n\t\t{in: new(time.Time), out: new(time.Time)},\n\t\t{in: time.Unix(0, 1), out: new(time.Time)},\n\t\t{in: time.Unix(1, 0), out: new(time.Time)},\n\t\t{in: time.Unix(1, 1), out: new(time.Time)},\n\t\t{\n\t\t\tin:     time.Unix(0, 0).Format(time.RFC3339),\n\t\t\tout:    new(time.Time),\n\t\t\twanted: mustParseTime(time.RFC3339, time.Unix(0, 0).Format(time.RFC3339)),\n\t\t},\n\t\t{in: EmbeddedTime{Time: time.Unix(1, 1)}, out: new(EmbeddedTime)},\n\t\t{in: EmbeddedTime{Time: time.Unix(1, 1)}, out: new(*EmbeddedTime)},\n\t\t{in: CustomTime(time.Unix(0, 0)), out: new(CustomTime)},\n\n\t\t{in: nil, out: new(*CustomEncoder), wantnil: true},\n\t\t{in: nil, out: &CustomEncoder{str: \"a\"}, wantzero: true},\n\t\t{\n\t\t\tin:  &CustomEncoder{\"a\", &CustomEncoder{\"b\", nil, 1}, 2},\n\t\t\tout: new(CustomEncoder),\n\t\t},\n\t\t{\n\t\t\tin:  &CustomEncoderField{Field: CustomEncoder{\"a\", nil, 1}},\n\t\t\tout: new(CustomEncoderField),\n\t\t},\n\t\t{\n\t\t\tin:  &CustomEncoderEmbeddedPtr{&CustomEncoder{\"a\", nil, 1}},\n\t\t\tout: new(CustomEncoderEmbeddedPtr),\n\t\t},\n\n\t\t{in: repoURL, out: new(url.URL)},\n\t\t{in: repoURL, out: new(*url.URL)},\n\n\t\t{in: OmitEmptyTest{}, out: new(OmitEmptyTest)},\n\t\t{in: OmitTimeTest{}, out: new(OmitTimeTest)},\n\n\t\t{in: nil, out: new(*AsArrayTest), wantnil: true},\n\t\t{in: nil, out: new(AsArrayTest), wantzero: true},\n\t\t{in: AsArrayTest{OmitEmptyTest: OmitEmptyTest{\"foo\", \"bar\"}}, out: new(AsArrayTest)},\n\t\t{\n\t\t\tin:     AsArrayTest{OmitEmptyTest: OmitEmptyTest{\"foo\", \"bar\"}},\n\t\t\tout:    new(unexported),\n\t\t\tdecErr: \"msgpack: number of fields in array-encoded struct has changed\",\n\t\t},\n\n\t\t{in: (*EventTime)(nil), out: new(*EventTime)},\n\t\t{in: &EventTime{time.Unix(0, 0)}, out: new(*EventTime)},\n\n\t\t{in: (*ExtTest)(nil), out: new(*ExtTest)},\n\t\t{in: &ExtTest{\"world\"}, out: new(*ExtTest), wanted: ExtTest{\"hello world\"}},\n\t\t{\n\t\t\tin:     &ExtTestField{ExtTest{\"world\"}},\n\t\t\tout:    new(*ExtTestField),\n\t\t\twanted: ExtTestField{ExtTest{\"hello world\"}},\n\t\t},\n\n\t\t{\n\t\t\tin:  &InlineTest{OmitEmptyTest: OmitEmptyTest{Bar: \"world\"}},\n\t\t\tout: new(InlineTest),\n\t\t},\n\t\t{\n\t\t\tin:  &InlinePtrTest{OmitEmptyTest: &OmitEmptyTest{Bar: \"world\"}},\n\t\t\tout: new(InlinePtrTest),\n\t\t},\n\t\t{\n\t\t\tin:  InlineDupTest{FooTest{\"foo\"}, FooDupTest{\"foo\"}},\n\t\t\tout: new(InlineDupTest),\n\t\t},\n\n\t\t{in: big.NewInt(123), out: new(big.Int)},\n\t}\n)\n\nfunc indirect(viface interface{}) interface{} {\n\tv := reflect.ValueOf(viface)\n\tfor v.Kind() == reflect.Ptr {\n\t\tv = v.Elem()\n\t}\n\tif v.IsValid() {\n\t\treturn v.Interface()\n\t}\n\treturn nil\n}\n\nfunc TestTypes(t *testing.T) {\n\tmsgpack.RegisterExt(1, (*EventTime)(nil))\n\n\tfor _, test := range typeTests {\n\t\ttest.T = t\n\n\t\tvar buf bytes.Buffer\n\n\t\tenc := msgpack.NewEncoder(&buf)\n\t\terr := enc.Encode(test.in)\n\t\tif test.encErr != \"\" {\n\t\t\ttest.requireErr(err, test.encErr)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Encode failed: %s (in=%#v)\", err, test.in)\n\t\t}\n\n\t\tdec := msgpack.NewDecoder(&buf)\n\t\terr = dec.Decode(test.out)\n\t\tif test.decErr != \"\" {\n\t\t\ttest.requireErr(err, test.decErr)\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Decode failed: %s (%s)\", err, test)\n\t\t}\n\n\t\tif buf.Len() > 0 {\n\t\t\tt.Fatalf(\"unread data in the buffer: %q (%s)\", buf.Bytes(), test)\n\t\t}\n\n\t\tif test.wantnil {\n\t\t\tv := reflect.Indirect(reflect.ValueOf(test.out))\n\t\t\tif !v.IsNil() {\n\t\t\t\tt.Fatalf(\"got %#v, wanted nil (%s)\", test.out, test)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tout := indirect(test.out)\n\t\tvar wanted interface{}\n\t\tif test.wantzero {\n\t\t\ttyp := reflect.TypeOf(out)\n\t\t\twanted = reflect.Zero(typ).Interface()\n\t\t} else {\n\t\t\twanted = test.wanted\n\t\t}\n\t\tif wanted == nil {\n\t\t\twanted = indirect(test.in)\n\t\t}\n\t\trequire.Equal(t, wanted, out)\n\t}\n\n\tfor _, test := range typeTests {\n\t\tif test.encErr != \"\" || test.decErr != \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tb, err := msgpack.Marshal(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tvar dst interface{}\n\t\tdec := msgpack.NewDecoder(bytes.NewReader(b))\n\t\tdec.SetMapDecoder(func(dec *msgpack.Decoder) (interface{}, error) {\n\t\t\treturn dec.DecodeUntypedMap()\n\t\t})\n\n\t\terr = dec.Decode(&dst)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Unmarshal into interface{} failed: %s (%s)\", err, test)\n\t\t}\n\n\t\tdec = msgpack.NewDecoder(bytes.NewReader(b))\n\t\tdec.SetMapDecoder(func(dec *msgpack.Decoder) (interface{}, error) {\n\t\t\treturn dec.DecodeUntypedMap()\n\t\t})\n\n\t\t_, err = dec.DecodeInterface()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"DecodeInterface failed: %s (%s)\", err, test)\n\t\t}\n\t}\n}\n\nfunc TestStringsBin(t *testing.T) {\n\ttests := []struct {\n\t\tin     string\n\t\twanted string\n\t}{\n\t\t{\"\", \"a0\"},\n\t\t{\"a\", \"a161\"},\n\t\t{\"hello\", \"a568656c6c6f\"},\n\t\t{\n\t\t\tstrings.Repeat(\"x\", 31),\n\t\t\t\"bf\" + strings.Repeat(\"78\", 31),\n\t\t},\n\t\t{\n\t\t\tstrings.Repeat(\"x\", 32),\n\t\t\t\"d920\" + strings.Repeat(\"78\", 32),\n\t\t},\n\t\t{\n\t\t\tstrings.Repeat(\"x\", 255),\n\t\t\t\"d9ff\" + strings.Repeat(\"78\", 255),\n\t\t},\n\t\t{\n\t\t\tstrings.Repeat(\"x\", 256),\n\t\t\t\"da0100\" + strings.Repeat(\"78\", 256),\n\t\t},\n\t\t{\n\t\t\tstrings.Repeat(\"x\", 65535),\n\t\t\t\"daffff\" + strings.Repeat(\"78\", 65535),\n\t\t},\n\t\t{\n\t\t\tstrings.Repeat(\"x\", 65536),\n\t\t\t\"db00010000\" + strings.Repeat(\"78\", 65536),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tb, err := msgpack.Marshal(test.in)\n\t\trequire.Nil(t, err)\n\t\ts := hex.EncodeToString(b)\n\t\trequire.Equal(t, s, test.wanted)\n\n\t\tvar out string\n\t\terr = msgpack.Unmarshal(b, &out)\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, out, test.in)\n\n\t\tvar msg msgpack.RawMessage\n\t\terr = msgpack.Unmarshal(b, &msg)\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, []byte(msg), b)\n\n\t\tdec := msgpack.NewDecoder(bytes.NewReader(b))\n\t\tv, err := dec.DecodeInterface()\n\t\trequire.Nil(t, err)\n\t\trequire.Equal(t, v.(string), test.in)\n\n\t\tvar dst interface{} = \"\"\n\t\terr = msgpack.Unmarshal(b, &dst)\n\t\trequire.EqualError(t, err, \"msgpack: Decode(non-pointer string)\")\n\t}\n}\n\nfunc TestBin(t *testing.T) {\n\ttests := []struct {\n\t\tin     []byte\n\t\twanted string\n\t}{\n\t\t{[]byte{}, \"c400\"},\n\t\t{[]byte{0}, \"c40100\"},\n\t\t{\n\t\t\tbytes.Repeat([]byte{'x'}, 31),\n\t\t\t\"c41f\" + strings.Repeat(\"78\", 31),\n\t\t},\n\t\t{\n\t\t\tbytes.Repeat([]byte{'x'}, 32),\n\t\t\t\"c420\" + strings.Repeat(\"78\", 32),\n\t\t},\n\t\t{\n\t\t\tbytes.Repeat([]byte{'x'}, 255),\n\t\t\t\"c4ff\" + strings.Repeat(\"78\", 255),\n\t\t},\n\t\t{\n\t\t\tbytes.Repeat([]byte{'x'}, 256),\n\t\t\t\"c50100\" + strings.Repeat(\"78\", 256),\n\t\t},\n\t\t{\n\t\t\tbytes.Repeat([]byte{'x'}, 65535),\n\t\t\t\"c5ffff\" + strings.Repeat(\"78\", 65535),\n\t\t},\n\t\t{\n\t\t\tbytes.Repeat([]byte{'x'}, 65536),\n\t\t\t\"c600010000\" + strings.Repeat(\"78\", 65536),\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tb, err := msgpack.Marshal(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts := hex.EncodeToString(b)\n\t\tif s != test.wanted {\n\t\t\tt.Fatalf(\"%.32s != %.32s\", s, test.wanted)\n\t\t}\n\n\t\tvar out []byte\n\t\terr = msgpack.Unmarshal(b, &out)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(out, test.in) {\n\t\t\tt.Fatalf(\"%x != %x\", out, test.in)\n\t\t}\n\n\t\tdec := msgpack.NewDecoder(bytes.NewReader(b))\n\t\tv, err := dec.DecodeInterface()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(v.([]byte), test.in) {\n\t\t\tt.Fatalf(\"%x != %x\", v, test.in)\n\t\t}\n\n\t\tvar dst interface{} = make([]byte, 0)\n\t\terr = msgpack.Unmarshal(b, &dst)\n\t\tif err.Error() != \"msgpack: Decode(non-pointer []uint8)\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestUint64(t *testing.T) {\n\ttests := []struct {\n\t\tin     uint64\n\t\twanted string\n\t}{\n\t\t{0, \"00\"},\n\t\t{1, \"01\"},\n\t\t{math.MaxInt8 - 1, \"7e\"},\n\t\t{math.MaxInt8, \"7f\"},\n\t\t{math.MaxInt8 + 1, \"cc80\"},\n\t\t{math.MaxUint8 - 1, \"ccfe\"},\n\t\t{math.MaxUint8, \"ccff\"},\n\t\t{math.MaxUint8 + 1, \"cd0100\"},\n\t\t{math.MaxUint16 - 1, \"cdfffe\"},\n\t\t{math.MaxUint16, \"cdffff\"},\n\t\t{math.MaxUint16 + 1, \"ce00010000\"},\n\t\t{math.MaxUint32 - 1, \"cefffffffe\"},\n\t\t{math.MaxUint32, \"ceffffffff\"},\n\t\t{math.MaxUint32 + 1, \"cf0000000100000000\"},\n\t\t{math.MaxInt64 - 1, \"cf7ffffffffffffffe\"},\n\t\t{math.MaxInt64, \"cf7fffffffffffffff\"},\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.UseCompactInts(true)\n\n\tfor _, test := range tests {\n\t\terr := enc.Encode(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts := hex.EncodeToString(buf.Bytes())\n\t\tif s != test.wanted {\n\t\t\tt.Fatalf(\"%.32s != %.32s\", s, test.wanted)\n\t\t}\n\n\t\tvar out uint64\n\t\terr = msgpack.Unmarshal(buf.Bytes(), &out)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out != test.in {\n\t\t\tt.Fatalf(\"%d != %d\", out, test.in)\n\t\t}\n\n\t\tvar out2 int64\n\t\terr = msgpack.Unmarshal(buf.Bytes(), &out2)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out2 != int64(test.in) {\n\t\t\tt.Fatalf(\"%d != %d\", out2, int64(test.in))\n\t\t}\n\n\t\tvar out3 interface{} = uint64(0)\n\t\terr = msgpack.Unmarshal(buf.Bytes(), &out3)\n\t\tif err.Error() != \"msgpack: Decode(non-pointer uint64)\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdec := msgpack.NewDecoder(&buf)\n\t\t_, err = dec.DecodeInterface()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif buf.Len() != 0 {\n\t\t\tpanic(\"buffer is not empty\")\n\t\t}\n\t}\n}\n\nfunc TestInt64(t *testing.T) {\n\ttests := []struct {\n\t\tin     int64\n\t\twanted string\n\t}{\n\t\t{math.MinInt64, \"d38000000000000000\"},\n\t\t{math.MinInt32 - 1, \"d3ffffffff7fffffff\"},\n\t\t{math.MinInt32, \"d280000000\"},\n\t\t{math.MinInt32 + 1, \"d280000001\"},\n\t\t{math.MinInt16 - 1, \"d2ffff7fff\"},\n\t\t{math.MinInt16, \"d18000\"},\n\t\t{math.MinInt16 + 1, \"d18001\"},\n\t\t{math.MinInt8 - 1, \"d1ff7f\"},\n\t\t{math.MinInt8, \"d080\"},\n\t\t{math.MinInt8 + 1, \"d081\"},\n\t\t{-33, \"d0df\"},\n\t\t{-32, \"e0\"},\n\t\t{-31, \"e1\"},\n\t\t{-1, \"ff\"},\n\t\t{0, \"00\"},\n\t\t{1, \"01\"},\n\t\t{math.MaxInt8 - 1, \"7e\"},\n\t\t{math.MaxInt8, \"7f\"},\n\t\t{math.MaxInt8 + 1, \"cc80\"},\n\t\t{math.MaxUint8 - 1, \"ccfe\"},\n\t\t{math.MaxUint8, \"ccff\"},\n\t\t{math.MaxUint8 + 1, \"cd0100\"},\n\t\t{math.MaxUint16 - 1, \"cdfffe\"},\n\t\t{math.MaxUint16, \"cdffff\"},\n\t\t{math.MaxUint16 + 1, \"ce00010000\"},\n\t\t{math.MaxUint32 - 1, \"cefffffffe\"},\n\t\t{math.MaxUint32, \"ceffffffff\"},\n\t\t{math.MaxUint32 + 1, \"cf0000000100000000\"},\n\t\t{math.MaxInt64 - 1, \"cf7ffffffffffffffe\"},\n\t\t{math.MaxInt64, \"cf7fffffffffffffff\"},\n\t}\n\n\tvar buf bytes.Buffer\n\tenc := msgpack.NewEncoder(&buf)\n\tenc.UseCompactInts(true)\n\n\tfor _, test := range tests {\n\t\terr := enc.Encode(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts := hex.EncodeToString(buf.Bytes())\n\t\tif s != test.wanted {\n\t\t\tt.Fatalf(\"%.32s != %.32s\", s, test.wanted)\n\t\t}\n\n\t\tvar out int64\n\t\terr = msgpack.Unmarshal(buf.Bytes(), &out)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out != test.in {\n\t\t\tt.Fatalf(\"%d != %d\", out, test.in)\n\t\t}\n\n\t\tvar out2 uint64\n\t\terr = msgpack.Unmarshal(buf.Bytes(), &out2)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out2 != uint64(test.in) {\n\t\t\tt.Fatalf(\"%d != %d\", out2, uint64(test.in))\n\t\t}\n\n\t\tvar out3 interface{} = int64(0)\n\t\terr = msgpack.Unmarshal(buf.Bytes(), &out3)\n\t\tif err.Error() != \"msgpack: Decode(non-pointer int64)\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tdec := msgpack.NewDecoder(&buf)\n\t\t_, err = dec.DecodeInterface()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif buf.Len() != 0 {\n\t\t\tpanic(\"buffer is not empty\")\n\t\t}\n\t}\n}\n\nfunc TestFloat32(t *testing.T) {\n\ttests := []struct {\n\t\tin     float32\n\t\twanted string\n\t}{\n\t\t{0.1, \"ca3dcccccd\"},\n\t\t{0.2, \"ca3e4ccccd\"},\n\t\t{-0.1, \"cabdcccccd\"},\n\t\t{-0.2, \"cabe4ccccd\"},\n\t\t{float32(math.Inf(1)), \"ca7f800000\"},\n\t\t{float32(math.Inf(-1)), \"caff800000\"},\n\t\t{math.MaxFloat32, \"ca7f7fffff\"},\n\t\t{math.SmallestNonzeroFloat32, \"ca00000001\"},\n\t}\n\tfor _, test := range tests {\n\t\tb, err := msgpack.Marshal(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts := hex.EncodeToString(b)\n\t\tif s != test.wanted {\n\t\t\tt.Fatalf(\"%.32s != %.32s\", s, test.wanted)\n\t\t}\n\n\t\tvar out float32\n\t\terr = msgpack.Unmarshal(b, &out)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out != test.in {\n\t\t\tt.Fatalf(\"%f != %f\", out, test.in)\n\t\t}\n\n\t\tvar out2 float64\n\t\terr = msgpack.Unmarshal(b, &out2)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out2 != float64(test.in) {\n\t\t\tt.Fatalf(\"%f != %f\", out2, float64(test.in))\n\t\t}\n\n\t\tdec := msgpack.NewDecoder(bytes.NewReader(b))\n\t\tv, err := dec.DecodeInterface()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v.(float32) != test.in {\n\t\t\tt.Fatalf(\"%f != %f\", v, test.in)\n\t\t}\n\n\t\tvar dst interface{} = float32(0)\n\t\terr = msgpack.Unmarshal(b, &dst)\n\t\tif err.Error() != \"msgpack: Decode(non-pointer float32)\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\n\tin := float32(math.NaN())\n\tb, err := msgpack.Marshal(in)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar out float32\n\terr = msgpack.Unmarshal(b, &out)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !math.IsNaN(float64(out)) {\n\t\tt.Fatal(\"not NaN\")\n\t}\n}\n\nfunc TestFloat64(t *testing.T) {\n\ttable := []struct {\n\t\tin     float64\n\t\twanted string\n\t}{\n\t\t{0.1, \"cb3fb999999999999a\"},\n\t\t{0.2, \"cb3fc999999999999a\"},\n\t\t{-0.1, \"cbbfb999999999999a\"},\n\t\t{-0.2, \"cbbfc999999999999a\"},\n\t\t{math.Inf(1), \"cb7ff0000000000000\"},\n\t\t{math.Inf(-1), \"cbfff0000000000000\"},\n\t\t{math.MaxFloat64, \"cb7fefffffffffffff\"},\n\t\t{math.SmallestNonzeroFloat64, \"cb0000000000000001\"},\n\t}\n\tfor _, test := range table {\n\t\tb, err := msgpack.Marshal(test.in)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts := hex.EncodeToString(b)\n\t\tif s != test.wanted {\n\t\t\tt.Fatalf(\"%.32s != %.32s\", s, test.wanted)\n\t\t}\n\n\t\tvar out float64\n\t\terr = msgpack.Unmarshal(b, &out)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out != test.in {\n\t\t\tt.Fatalf(\"%f != %f\", out, test.in)\n\t\t}\n\n\t\tdec := msgpack.NewDecoder(bytes.NewReader(b))\n\t\tv, err := dec.DecodeInterface()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif v.(float64) != test.in {\n\t\t\tt.Fatalf(\"%f != %f\", v, test.in)\n\t\t}\n\n\t\tvar dst interface{} = float64(0)\n\t\terr = msgpack.Unmarshal(b, &dst)\n\t\tif err.Error() != \"msgpack: Decode(non-pointer float64)\" {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc mustParseTime(format, s string) time.Time {\n\ttm, err := time.Parse(format, s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn tm\n}\n"
        },
        {
          "name": "unsafe.go",
          "type": "blob",
          "size": 0.3564453125,
          "content": "// +build !appengine\n\npackage msgpack\n\nimport (\n\t\"unsafe\"\n)\n\n// bytesToString converts byte slice to string.\nfunc bytesToString(b []byte) string {\n\treturn *(*string)(unsafe.Pointer(&b))\n}\n\n// stringToBytes converts string to byte slice.\nfunc stringToBytes(s string) []byte {\n\treturn *(*[]byte)(unsafe.Pointer(\n\t\t&struct {\n\t\t\tstring\n\t\t\tCap int\n\t\t}{s, len(s)},\n\t))\n}\n"
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.099609375,
          "content": "package msgpack\n\n// Version is the current release version.\nfunc Version() string {\n\treturn \"5.4.1\"\n}\n"
        }
      ]
    }
  ]
}