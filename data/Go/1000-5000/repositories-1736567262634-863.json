{
  "metadata": {
    "timestamp": 1736567262634,
    "page": 863,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "vbauerster/mpb",
      "stars": 2351,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1201171875,
          "content": "# Test binary, build with `go test -c`\n*.test\n\n# Output of the go coverage tool, specifically when used with LiteIDE\n*.out\n"
        },
        {
          "name": "CONTRIBUTING",
          "type": "blob",
          "size": 0.6259765625,
          "content": "When contributing your first changes, please include an empty commit for\ncopyright waiver using the following message (replace 'John Doe' with\nyour name or nickname):\n\n  John Doe Copyright Waiver\n\n  I dedicate any and all copyright interest in this software to the\n  public domain.  I make this dedication for the benefit of the public at\n  large and to the detriment of my heirs and successors.  I intend this\n  dedication to be an overt act of relinquishment in perpetuity of all\n  present and future rights to this software under copyright law.\n\nThe command to create an empty commit from the command-line is:\n\n  git commit --allow-empty\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.064453125,
          "content": "# Multi Progress Bar\n\n[![GoDoc](https://pkg.go.dev/badge/github.com/vbauerster/mpb)](https://pkg.go.dev/github.com/vbauerster/mpb/v8)\n[![Test status](https://github.com/vbauerster/mpb/actions/workflows/test.yml/badge.svg)](https://github.com/vbauerster/mpb/actions/workflows/test.yml)\n[![Lint status](https://github.com/vbauerster/mpb/actions/workflows/golangci-lint.yml/badge.svg)](https://github.com/vbauerster/mpb/actions/workflows/golangci-lint.yml)\n\n**mpb** is a Go lib for rendering progress bars in terminal applications.\n\n## Features\n\n- **Multiple Bars**: Multiple progress bars are supported\n- **Dynamic Total**: Set total while bar is running\n- **Dynamic Add/Remove**: Dynamically add or remove bars\n- **Cancellation**: Cancel whole rendering process\n- **Predefined Decorators**: Elapsed time, [ewma](https://github.com/VividCortex/ewma) based ETA, Percentage, Bytes counter\n- **Decorator's width sync**: Synchronized decorator's width among multiple bars\n\n## Usage\n\n#### [Rendering single bar](_examples/singleBar/main.go)\n\n```go\npackage main\n\nimport (\n    \"math/rand\"\n    \"time\"\n\n    \"github.com/vbauerster/mpb/v8\"\n    \"github.com/vbauerster/mpb/v8/decor\"\n)\n\nfunc main() {\n    // initialize progress container, with custom width\n    p := mpb.New(mpb.WithWidth(64))\n\n    total := 100\n    name := \"Single Bar:\"\n    // create a single bar, which will inherit container's width\n    bar := p.New(int64(total),\n        // BarFillerBuilder with custom style\n        mpb.BarStyle().Lbound(\"╢\").Filler(\"▌\").Tip(\"▌\").Padding(\"░\").Rbound(\"╟\"),\n        mpb.PrependDecorators(\n            // display our name with one space on the right\n            decor.Name(name, decor.WC{C: decor.DindentRight | decor.DextraSpace}),\n            // replace ETA decorator with \"done\" message, OnComplete event\n            decor.OnComplete(decor.AverageETA(decor.ET_STYLE_GO), \"done\"),\n        ),\n        mpb.AppendDecorators(decor.Percentage()),\n    )\n    // simulating some work\n    max := 100 * time.Millisecond\n    for i := 0; i < total; i++ {\n        time.Sleep(time.Duration(rand.Intn(10)+1) * max / 10)\n        bar.Increment()\n    }\n    // wait for our bar to complete and flush\n    p.Wait()\n}\n```\n\n#### [Rendering multiple bars](_examples/multiBars/main.go)\n\n```go\n    var wg sync.WaitGroup\n    // passed wg will be accounted at p.Wait() call\n    p := mpb.New(mpb.WithWaitGroup(&wg))\n    total, numBars := 100, 3\n    wg.Add(numBars)\n\n    for i := 0; i < numBars; i++ {\n        name := fmt.Sprintf(\"Bar#%d:\", i)\n        bar := p.AddBar(int64(total),\n            mpb.PrependDecorators(\n                // simple name decorator\n                decor.Name(name),\n                // decor.DSyncWidth bit enables column width synchronization\n                decor.Percentage(decor.WCSyncSpace),\n            ),\n            mpb.AppendDecorators(\n                // replace ETA decorator with \"done\" message, OnComplete event\n                decor.OnComplete(\n                    // ETA decorator with ewma age of 30\n                    decor.EwmaETA(decor.ET_STYLE_GO, 30, decor.WCSyncWidth), \"done\",\n                ),\n            ),\n        )\n        // simulating some work\n        go func() {\n            defer wg.Done()\n            rng := rand.New(rand.NewSource(time.Now().UnixNano()))\n            max := 100 * time.Millisecond\n            for i := 0; i < total; i++ {\n                // start variable is solely for EWMA calculation\n                // EWMA's unit of measure is an iteration's duration\n                start := time.Now()\n                time.Sleep(time.Duration(rng.Intn(10)+1) * max / 10)\n                // we need to call EwmaIncrement to fulfill ewma decorator's contract\n                bar.EwmaIncrement(time.Since(start))\n            }\n        }()\n    }\n    // wait for passed wg and for all bars to complete and flush\n    p.Wait()\n```\n\n#### [Dynamic total](_examples/dynTotal/main.go)\n\n![dynamic total](_svg/godEMrCZmJkHYH1X9dN4Nm0U7.svg)\n\n#### [Complex example](_examples/complex/main.go)\n\n![complex](_svg/wHzf1M7sd7B3zVa2scBMnjqRf.svg)\n\n#### [Bytes counters](_examples/io/main.go)\n\n![byte counters](_svg/hIpTa3A5rQz65ssiVuRJu87X6.svg)\n"
        },
        {
          "name": "UNLICENSE",
          "type": "blob",
          "size": 1.1826171875,
          "content": "This is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org/>\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "_svg",
          "type": "tree",
          "content": null
        },
        {
          "name": "bar.go",
          "type": "blob",
          "size": 13.955078125,
          "content": "package mpb\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/acarl005/stripansi\"\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\n// Bar represents a progress bar.\ntype Bar struct {\n\tindex        int // used by heap\n\tpriority     int // used by heap\n\tframeCh      chan *renderFrame\n\toperateState chan func(*bState)\n\tcontainer    *Progress\n\tbs           *bState\n\tbsOk         chan struct{}\n\tctx          context.Context\n\tcancel       func()\n}\n\ntype syncTable [2][]chan int\ntype extenderFunc func(decor.Statistics, ...io.Reader) ([]io.Reader, error)\n\n// bState is actual bar's state.\ntype bState struct {\n\tid              int\n\tpriority        int\n\treqWidth        int\n\tshutdown        int\n\ttotal           int64\n\tcurrent         int64\n\trefill          int64\n\ttrimSpace       bool\n\taborted         bool\n\ttriggerComplete bool\n\trmOnComplete    bool\n\tnoPop           bool\n\tautoRefresh     bool\n\tbuffers         [3]*bytes.Buffer\n\tdecorators      [2][]decor.Decorator\n\tewmaDecorators  []decor.EwmaDecorator\n\tfiller          BarFiller\n\textender        extenderFunc\n\trenderReq       chan<- time.Time\n\twaitBar         *Bar // key for (*pState).queueBars\n}\n\ntype renderFrame struct {\n\trows         []io.Reader\n\tshutdown     int\n\trmOnComplete bool\n\tnoPop        bool\n\terr          error\n}\n\nfunc newBar(ctx context.Context, container *Progress, bs *bState) *Bar {\n\tctx, cancel := context.WithCancel(ctx)\n\n\tbar := &Bar{\n\t\tpriority:     bs.priority,\n\t\tframeCh:      make(chan *renderFrame, 1),\n\t\toperateState: make(chan func(*bState)),\n\t\tbsOk:         make(chan struct{}),\n\t\tcontainer:    container,\n\t\tctx:          ctx,\n\t\tcancel:       cancel,\n\t}\n\n\tcontainer.bwg.Add(1)\n\tgo bar.serve(bs)\n\treturn bar\n}\n\n// ProxyReader wraps io.Reader with metrics required for progress\n// tracking. If `r` is 'unknown total/size' reader it's mandatory\n// to call `(*Bar).SetTotal(-1, true)` after the wrapper returns\n// `io.EOF`. If bar is already completed or aborted, returns nil.\n// Panics if `r` is nil.\nfunc (b *Bar) ProxyReader(r io.Reader) io.ReadCloser {\n\tif r == nil {\n\t\tpanic(\"expected non nil io.Reader\")\n\t}\n\tresult := make(chan io.ReadCloser)\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tresult <- newProxyReader(r, b, len(s.ewmaDecorators) != 0)\n\t}:\n\t\treturn <-result\n\tcase <-b.ctx.Done():\n\t\treturn nil\n\t}\n}\n\n// ProxyWriter wraps io.Writer with metrics required for progress tracking.\n// If bar is already completed or aborted, returns nil.\n// Panics if `w` is nil.\nfunc (b *Bar) ProxyWriter(w io.Writer) io.WriteCloser {\n\tif w == nil {\n\t\tpanic(\"expected non nil io.Writer\")\n\t}\n\tresult := make(chan io.WriteCloser)\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tresult <- newProxyWriter(w, b, len(s.ewmaDecorators) != 0)\n\t}:\n\t\treturn <-result\n\tcase <-b.ctx.Done():\n\t\treturn nil\n\t}\n}\n\n// ID returs id of the bar.\nfunc (b *Bar) ID() int {\n\tresult := make(chan int)\n\tselect {\n\tcase b.operateState <- func(s *bState) { result <- s.id }:\n\t\treturn <-result\n\tcase <-b.bsOk:\n\t\treturn b.bs.id\n\t}\n}\n\n// Current returns bar's current value, in other words sum of all increments.\nfunc (b *Bar) Current() int64 {\n\tresult := make(chan int64)\n\tselect {\n\tcase b.operateState <- func(s *bState) { result <- s.current }:\n\t\treturn <-result\n\tcase <-b.bsOk:\n\t\treturn b.bs.current\n\t}\n}\n\n// SetRefill sets refill flag with specified amount.\n// The underlying BarFiller will change its visual representation, to\n// indicate refill event. Refill event may be referred to some retry\n// operation for example.\nfunc (b *Bar) SetRefill(amount int64) {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tif amount < s.current {\n\t\t\ts.refill = amount\n\t\t} else {\n\t\t\ts.refill = s.current\n\t\t}\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// TraverseDecorators traverses available decorators and calls cb func\n// on each in a new goroutine. Decorators implementing decor.Wrapper\n// interface are unwrapped first.\nfunc (b *Bar) TraverseDecorators(cb func(decor.Decorator)) {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tvar wg sync.WaitGroup\n\t\tfor _, decorators := range s.decorators {\n\t\t\twg.Add(len(decorators))\n\t\t\tfor _, d := range decorators {\n\t\t\t\td := d\n\t\t\t\tgo func() {\n\t\t\t\t\tcb(unwrap(d))\n\t\t\t\t\twg.Done()\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t\twg.Wait()\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// EnableTriggerComplete enables triggering complete event. It's effective\n// only for bars which were constructed with `total <= 0`. If `curren >= total`\n// at the moment of call, complete event is triggered right away.\nfunc (b *Bar) EnableTriggerComplete() {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tif s.triggerComplete {\n\t\t\treturn\n\t\t}\n\t\tif s.current >= s.total {\n\t\t\ts.current = s.total\n\t\t\ts.triggerCompletion(b)\n\t\t} else {\n\t\t\ts.triggerComplete = true\n\t\t}\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// SetTotal sets total to an arbitrary value. It's effective only for bar\n// which was constructed with `total <= 0`. Setting total to negative value\n// is equivalent to `(*Bar).SetTotal((*Bar).Current(), bool)` but faster.\n// If `complete` is true complete event is triggered right away.\n// Calling `(*Bar).EnableTriggerComplete` makes this one no operational.\nfunc (b *Bar) SetTotal(total int64, complete bool) {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tif s.triggerComplete {\n\t\t\treturn\n\t\t}\n\t\tif total < 0 {\n\t\t\ts.total = s.current\n\t\t} else {\n\t\t\ts.total = total\n\t\t}\n\t\tif complete {\n\t\t\ts.current = s.total\n\t\t\ts.triggerCompletion(b)\n\t\t}\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// SetCurrent sets progress' current to an arbitrary value.\nfunc (b *Bar) SetCurrent(current int64) {\n\tif current < 0 {\n\t\treturn\n\t}\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\ts.current = current\n\t\tif s.triggerComplete && s.current >= s.total {\n\t\t\ts.current = s.total\n\t\t\ts.triggerCompletion(b)\n\t\t}\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// Increment is a shorthand for b.IncrInt64(1).\nfunc (b *Bar) Increment() {\n\tb.IncrInt64(1)\n}\n\n// IncrBy is a shorthand for b.IncrInt64(int64(n)).\nfunc (b *Bar) IncrBy(n int) {\n\tb.IncrInt64(int64(n))\n}\n\n// IncrInt64 increments progress by amount of n.\nfunc (b *Bar) IncrInt64(n int64) {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\ts.current += n\n\t\tif s.triggerComplete && s.current >= s.total {\n\t\t\ts.current = s.total\n\t\t\ts.triggerCompletion(b)\n\t\t}\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// EwmaIncrement is a shorthand for b.EwmaIncrInt64(1, iterDur).\nfunc (b *Bar) EwmaIncrement(iterDur time.Duration) {\n\tb.EwmaIncrInt64(1, iterDur)\n}\n\n// EwmaIncrBy is a shorthand for b.EwmaIncrInt64(int64(n), iterDur).\nfunc (b *Bar) EwmaIncrBy(n int, iterDur time.Duration) {\n\tb.EwmaIncrInt64(int64(n), iterDur)\n}\n\n// EwmaIncrInt64 increments progress by amount of n and updates EWMA based\n// decorators by dur of a single iteration.\nfunc (b *Bar) EwmaIncrInt64(n int64, iterDur time.Duration) {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(len(s.ewmaDecorators))\n\t\tfor _, d := range s.ewmaDecorators {\n\t\t\td := d\n\t\t\tgo func() {\n\t\t\t\td.EwmaUpdate(n, iterDur)\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t}\n\t\ts.current += n\n\t\tif s.triggerComplete && s.current >= s.total {\n\t\t\ts.current = s.total\n\t\t\ts.triggerCompletion(b)\n\t\t}\n\t\twg.Wait()\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// EwmaSetCurrent sets progress' current to an arbitrary value and updates\n// EWMA based decorators by dur of a single iteration.\nfunc (b *Bar) EwmaSetCurrent(current int64, iterDur time.Duration) {\n\tif current < 0 {\n\t\treturn\n\t}\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tn := current - s.current\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(len(s.ewmaDecorators))\n\t\tfor _, d := range s.ewmaDecorators {\n\t\t\td := d\n\t\t\tgo func() {\n\t\t\t\td.EwmaUpdate(n, iterDur)\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t}\n\t\ts.current = current\n\t\tif s.triggerComplete && s.current >= s.total {\n\t\t\ts.current = s.total\n\t\t\ts.triggerCompletion(b)\n\t\t}\n\t\twg.Wait()\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// DecoratorAverageAdjust adjusts decorators implementing decor.AverageDecorator interface.\n// Call if there is need to set start time after decorators have been constructed.\nfunc (b *Bar) DecoratorAverageAdjust(start time.Time) {\n\tb.TraverseDecorators(func(d decor.Decorator) {\n\t\tif d, ok := d.(decor.AverageDecorator); ok {\n\t\t\td.AverageAdjust(start)\n\t\t}\n\t})\n}\n\n// SetPriority changes bar's order among multiple bars. Zero is highest\n// priority, i.e. bar will be on top. If you don't need to set priority\n// dynamically, better use BarPriority option.\nfunc (b *Bar) SetPriority(priority int) {\n\tb.container.UpdateBarPriority(b, priority, false)\n}\n\n// Abort interrupts bar's running goroutine. Abort won't be engaged\n// if bar is already in complete state. If drop is true bar will be\n// removed as well. To make sure that bar has been removed call\n// `(*Bar).Wait()` method.\nfunc (b *Bar) Abort(drop bool) {\n\tselect {\n\tcase b.operateState <- func(s *bState) {\n\t\tif s.aborted || s.completed() {\n\t\t\treturn\n\t\t}\n\t\ts.aborted = true\n\t\ts.rmOnComplete = drop\n\t\ts.triggerCompletion(b)\n\t}:\n\tcase <-b.ctx.Done():\n\t}\n}\n\n// Aborted reports whether the bar is in aborted state.\nfunc (b *Bar) Aborted() bool {\n\tresult := make(chan bool)\n\tselect {\n\tcase b.operateState <- func(s *bState) { result <- s.aborted }:\n\t\treturn <-result\n\tcase <-b.bsOk:\n\t\treturn b.bs.aborted\n\t}\n}\n\n// Completed reports whether the bar is in completed state.\nfunc (b *Bar) Completed() bool {\n\tresult := make(chan bool)\n\tselect {\n\tcase b.operateState <- func(s *bState) { result <- s.completed() }:\n\t\treturn <-result\n\tcase <-b.bsOk:\n\t\treturn b.bs.completed()\n\t}\n}\n\n// IsRunning reports whether the bar is in running state.\nfunc (b *Bar) IsRunning() bool {\n\tselect {\n\tcase <-b.ctx.Done():\n\t\treturn false\n\tdefault:\n\t\treturn true\n\t}\n}\n\n// Wait blocks until bar is completed or aborted.\nfunc (b *Bar) Wait() {\n\t<-b.bsOk\n}\n\nfunc (b *Bar) serve(bs *bState) {\n\tdecoratorsOnShutdown := func(decorators []decor.Decorator) {\n\t\tfor _, d := range decorators {\n\t\t\tif d, ok := unwrap(d).(decor.ShutdownListener); ok {\n\t\t\t\tb.container.bwg.Add(1)\n\t\t\t\tgo func() {\n\t\t\t\t\td.OnShutdown()\n\t\t\t\t\tb.container.bwg.Done()\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t}\n\tfor {\n\t\tselect {\n\t\tcase op := <-b.operateState:\n\t\t\top(bs)\n\t\tcase <-b.ctx.Done():\n\t\t\tdecoratorsOnShutdown(bs.decorators[0])\n\t\t\tdecoratorsOnShutdown(bs.decorators[1])\n\t\t\t// bar can be aborted by canceling parent ctx without calling b.Abort\n\t\t\tbs.aborted = !bs.completed()\n\t\t\tb.bs = bs\n\t\t\tclose(b.bsOk)\n\t\t\tb.container.bwg.Done()\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (b *Bar) render(tw int) {\n\tfn := func(s *bState) {\n\t\tframe := new(renderFrame)\n\t\tstat := s.newStatistics(tw)\n\t\tr, err := s.draw(stat)\n\t\tif err != nil {\n\t\t\tfor _, buf := range s.buffers {\n\t\t\t\tbuf.Reset()\n\t\t\t}\n\t\t\tframe.err = err\n\t\t\tb.frameCh <- frame\n\t\t\treturn\n\t\t}\n\t\tframe.rows, frame.err = s.extender(stat, r)\n\t\tif s.aborted || s.completed() {\n\t\t\tframe.shutdown = s.shutdown\n\t\t\tframe.rmOnComplete = s.rmOnComplete\n\t\t\tframe.noPop = s.noPop\n\t\t\t// post increment makes sure OnComplete decorators are rendered\n\t\t\ts.shutdown++\n\t\t}\n\t\tb.frameCh <- frame\n\t}\n\tselect {\n\tcase b.operateState <- fn:\n\tcase <-b.bsOk:\n\t\tfn(b.bs)\n\t}\n}\n\nfunc (b *Bar) tryEarlyRefresh(renderReq chan<- time.Time) {\n\tvar otherRunning int\n\tb.container.traverseBars(func(bar *Bar) bool {\n\t\tif b != bar && bar.IsRunning() {\n\t\t\totherRunning++\n\t\t\treturn false // stop traverse\n\t\t}\n\t\treturn true // continue traverse\n\t})\n\tif otherRunning == 0 {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase renderReq <- time.Now():\n\t\t\tcase <-b.ctx.Done():\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc (b *Bar) wSyncTable() syncTable {\n\tresult := make(chan syncTable)\n\tselect {\n\tcase b.operateState <- func(s *bState) { result <- s.wSyncTable() }:\n\t\treturn <-result\n\tcase <-b.bsOk:\n\t\treturn b.bs.wSyncTable()\n\t}\n}\n\nfunc (s *bState) draw(stat decor.Statistics) (_ io.Reader, err error) {\n\tdecorFiller := func(buf *bytes.Buffer, decorators []decor.Decorator) (err error) {\n\t\tfor _, d := range decorators {\n\t\t\t// need to call Decor in any case becase of width synchronization\n\t\t\tstr, width := d.Decor(stat)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif w := stat.AvailableWidth - width; w >= 0 {\n\t\t\t\t_, err = buf.WriteString(str)\n\t\t\t\tstat.AvailableWidth = w\n\t\t\t} else if stat.AvailableWidth > 0 {\n\t\t\t\ttrunc := runewidth.Truncate(stripansi.Strip(str), stat.AvailableWidth, \"…\")\n\t\t\t\t_, err = buf.WriteString(trunc)\n\t\t\t\tstat.AvailableWidth = 0\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\tfor i, buf := range s.buffers[:2] {\n\t\terr = decorFiller(buf, s.decorators[i])\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tspaces := []io.Reader{\n\t\tstrings.NewReader(\" \"),\n\t\tstrings.NewReader(\" \"),\n\t}\n\tif s.trimSpace || stat.AvailableWidth < 2 {\n\t\tfor _, r := range spaces {\n\t\t\t_, _ = io.Copy(io.Discard, r)\n\t\t}\n\t} else {\n\t\tstat.AvailableWidth -= 2\n\t}\n\n\terr = s.filler.Fill(s.buffers[2], stat)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn io.MultiReader(\n\t\ts.buffers[0],\n\t\tspaces[0],\n\t\ts.buffers[2],\n\t\tspaces[1],\n\t\ts.buffers[1],\n\t\tstrings.NewReader(\"\\n\"),\n\t), nil\n}\n\nfunc (s *bState) wSyncTable() (table syncTable) {\n\tvar count int\n\tvar row []chan int\n\n\tfor i, decorators := range s.decorators {\n\t\tfor _, d := range decorators {\n\t\t\tif ch, ok := d.Sync(); ok {\n\t\t\t\trow = append(row, ch)\n\t\t\t\tcount++\n\t\t\t}\n\t\t}\n\t\tswitch i {\n\t\tcase 0:\n\t\t\ttable[i] = row[0:count]\n\t\tdefault:\n\t\t\ttable[i] = row[len(table[i-1]):count]\n\t\t}\n\t}\n\treturn table\n}\n\nfunc (s *bState) populateEwmaDecorators(decorators []decor.Decorator) {\n\tfor _, d := range decorators {\n\t\tif d, ok := unwrap(d).(decor.EwmaDecorator); ok {\n\t\t\ts.ewmaDecorators = append(s.ewmaDecorators, d)\n\t\t}\n\t}\n}\n\nfunc (s *bState) triggerCompletion(b *Bar) {\n\ts.triggerComplete = true\n\tif s.autoRefresh {\n\t\t// Technically this call isn't required, but if refresh rate is set to\n\t\t// one hour for example and bar completes within a few minutes p.Wait()\n\t\t// will wait for one hour. This call helps to avoid unnecessary waiting.\n\t\tgo b.tryEarlyRefresh(s.renderReq)\n\t} else {\n\t\tb.cancel()\n\t}\n}\n\nfunc (s bState) completed() bool {\n\treturn s.triggerComplete && s.current == s.total\n}\n\nfunc (s bState) newStatistics(tw int) decor.Statistics {\n\treturn decor.Statistics{\n\t\tAvailableWidth: tw,\n\t\tRequestedWidth: s.reqWidth,\n\t\tID:             s.id,\n\t\tTotal:          s.total,\n\t\tCurrent:        s.current,\n\t\tRefill:         s.refill,\n\t\tCompleted:      s.completed(),\n\t\tAborted:        s.aborted,\n\t}\n}\n\nfunc unwrap(d decor.Decorator) decor.Decorator {\n\tif d, ok := d.(decor.Wrapper); ok {\n\t\treturn unwrap(d.Unwrap())\n\t}\n\treturn d\n}\n"
        },
        {
          "name": "bar_filler.go",
          "type": "blob",
          "size": 0.6513671875,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\n// BarFiller interface.\n// Bar (without decorators) renders itself by calling BarFiller's Fill method.\ntype BarFiller interface {\n\tFill(io.Writer, decor.Statistics) error\n}\n\n// BarFillerBuilder interface.\n// Default implementations are:\n//\n//\tBarStyle()\n//\tSpinnerStyle()\n//\tNopStyle()\ntype BarFillerBuilder interface {\n\tBuild() BarFiller\n}\n\n// BarFillerFunc is function type adapter to convert compatible function\n// into BarFiller interface.\ntype BarFillerFunc func(io.Writer, decor.Statistics) error\n\nfunc (f BarFillerFunc) Fill(w io.Writer, stat decor.Statistics) error {\n\treturn f(w, stat)\n}\n"
        },
        {
          "name": "bar_filler_bar.go",
          "type": "blob",
          "size": 6.7763671875,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n\t\"github.com/vbauerster/mpb/v8/internal\"\n)\n\nconst (\n\tiLbound = iota\n\tiRbound\n\tiRefiller\n\tiFiller\n\tiTip\n\tiPadding\n\tcomponents\n)\n\nvar defaultBarStyle = [components]string{\"[\", \"]\", \"+\", \"=\", \">\", \"-\"}\n\n// BarStyleComposer interface.\ntype BarStyleComposer interface {\n\tBarFillerBuilder\n\tLbound(string) BarStyleComposer\n\tLboundMeta(func(string) string) BarStyleComposer\n\tRbound(string) BarStyleComposer\n\tRboundMeta(func(string) string) BarStyleComposer\n\tFiller(string) BarStyleComposer\n\tFillerMeta(func(string) string) BarStyleComposer\n\tRefiller(string) BarStyleComposer\n\tRefillerMeta(func(string) string) BarStyleComposer\n\tPadding(string) BarStyleComposer\n\tPaddingMeta(func(string) string) BarStyleComposer\n\tTip(frames ...string) BarStyleComposer\n\tTipMeta(func(string) string) BarStyleComposer\n\tTipOnComplete() BarStyleComposer\n\tReverse() BarStyleComposer\n}\n\ntype component struct {\n\twidth int\n\tbytes []byte\n}\n\ntype flushSection struct {\n\tmeta  func(io.Writer, []byte) error\n\tbytes []byte\n}\n\ntype bFiller struct {\n\tcomponents [components]component\n\tmeta       [components]func(io.Writer, []byte) error\n\tflush      func(io.Writer, ...flushSection) error\n\ttip        struct {\n\t\tonComplete bool\n\t\tcount      uint\n\t\tframes     []component\n\t}\n}\n\ntype barStyle struct {\n\tstyle         [components]string\n\tmetaFuncs     [components]func(io.Writer, []byte) error\n\ttipFrames     []string\n\ttipOnComplete bool\n\trev           bool\n}\n\n// BarStyle constructs default bar style which can be altered via\n// BarStyleComposer interface.\nfunc BarStyle() BarStyleComposer {\n\tbs := barStyle{\n\t\tstyle:     defaultBarStyle,\n\t\ttipFrames: []string{defaultBarStyle[iTip]},\n\t}\n\tfor i := range bs.metaFuncs {\n\t\tbs.metaFuncs[i] = defaultMeta\n\t}\n\treturn bs\n}\n\nfunc (s barStyle) Lbound(bound string) BarStyleComposer {\n\ts.style[iLbound] = bound\n\treturn s\n}\n\nfunc (s barStyle) LboundMeta(fn func(string) string) BarStyleComposer {\n\ts.metaFuncs[iLbound] = makeMetaFunc(fn)\n\treturn s\n}\n\nfunc (s barStyle) Rbound(bound string) BarStyleComposer {\n\ts.style[iRbound] = bound\n\treturn s\n}\n\nfunc (s barStyle) RboundMeta(fn func(string) string) BarStyleComposer {\n\ts.metaFuncs[iRbound] = makeMetaFunc(fn)\n\treturn s\n}\n\nfunc (s barStyle) Filler(filler string) BarStyleComposer {\n\ts.style[iFiller] = filler\n\treturn s\n}\n\nfunc (s barStyle) FillerMeta(fn func(string) string) BarStyleComposer {\n\ts.metaFuncs[iFiller] = makeMetaFunc(fn)\n\treturn s\n}\n\nfunc (s barStyle) Refiller(refiller string) BarStyleComposer {\n\ts.style[iRefiller] = refiller\n\treturn s\n}\n\nfunc (s barStyle) RefillerMeta(fn func(string) string) BarStyleComposer {\n\ts.metaFuncs[iRefiller] = makeMetaFunc(fn)\n\treturn s\n}\n\nfunc (s barStyle) Padding(padding string) BarStyleComposer {\n\ts.style[iPadding] = padding\n\treturn s\n}\n\nfunc (s barStyle) PaddingMeta(fn func(string) string) BarStyleComposer {\n\ts.metaFuncs[iPadding] = makeMetaFunc(fn)\n\treturn s\n}\n\nfunc (s barStyle) Tip(frames ...string) BarStyleComposer {\n\tif len(frames) != 0 {\n\t\ts.tipFrames = frames\n\t}\n\treturn s\n}\n\nfunc (s barStyle) TipMeta(fn func(string) string) BarStyleComposer {\n\ts.metaFuncs[iTip] = makeMetaFunc(fn)\n\treturn s\n}\n\nfunc (s barStyle) TipOnComplete() BarStyleComposer {\n\ts.tipOnComplete = true\n\treturn s\n}\n\nfunc (s barStyle) Reverse() BarStyleComposer {\n\ts.rev = true\n\treturn s\n}\n\nfunc (s barStyle) Build() BarFiller {\n\tbf := &bFiller{\n\t\tmeta: s.metaFuncs,\n\t}\n\tbf.components[iLbound] = component{\n\t\twidth: runewidth.StringWidth(s.style[iLbound]),\n\t\tbytes: []byte(s.style[iLbound]),\n\t}\n\tbf.components[iRbound] = component{\n\t\twidth: runewidth.StringWidth(s.style[iRbound]),\n\t\tbytes: []byte(s.style[iRbound]),\n\t}\n\tbf.components[iFiller] = component{\n\t\twidth: runewidth.StringWidth(s.style[iFiller]),\n\t\tbytes: []byte(s.style[iFiller]),\n\t}\n\tbf.components[iRefiller] = component{\n\t\twidth: runewidth.StringWidth(s.style[iRefiller]),\n\t\tbytes: []byte(s.style[iRefiller]),\n\t}\n\tbf.components[iPadding] = component{\n\t\twidth: runewidth.StringWidth(s.style[iPadding]),\n\t\tbytes: []byte(s.style[iPadding]),\n\t}\n\tbf.tip.onComplete = s.tipOnComplete\n\tbf.tip.frames = make([]component, len(s.tipFrames))\n\tfor i, t := range s.tipFrames {\n\t\tbf.tip.frames[i] = component{\n\t\t\twidth: runewidth.StringWidth(t),\n\t\t\tbytes: []byte(t),\n\t\t}\n\t}\n\tif s.rev {\n\t\tbf.flush = func(w io.Writer, sections ...flushSection) error {\n\t\t\tfor i := len(sections) - 1; i >= 0; i-- {\n\t\t\t\tif s := sections[i]; len(s.bytes) != 0 {\n\t\t\t\t\terr := s.meta(w, s.bytes)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t} else {\n\t\tbf.flush = func(w io.Writer, sections ...flushSection) error {\n\t\t\tfor _, s := range sections {\n\t\t\t\tif len(s.bytes) != 0 {\n\t\t\t\t\terr := s.meta(w, s.bytes)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\treturn bf\n}\n\nfunc (s *bFiller) Fill(w io.Writer, stat decor.Statistics) error {\n\twidth := internal.CheckRequestedWidth(stat.RequestedWidth, stat.AvailableWidth)\n\t// don't count brackets as progress\n\twidth -= (s.components[iLbound].width + s.components[iRbound].width)\n\tif width < 0 {\n\t\treturn nil\n\t}\n\n\terr := s.meta[iLbound](w, s.components[iLbound].bytes)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif width == 0 {\n\t\treturn s.meta[iRbound](w, s.components[iRbound].bytes)\n\t}\n\n\tvar tip component\n\tvar refilling, filling, padding []byte\n\tvar fillCount int\n\tcurWidth := int(internal.PercentageRound(stat.Total, stat.Current, uint(width)))\n\n\tif curWidth != 0 {\n\t\tif !stat.Completed || s.tip.onComplete {\n\t\t\ttip = s.tip.frames[s.tip.count%uint(len(s.tip.frames))]\n\t\t\ts.tip.count++\n\t\t\tfillCount += tip.width\n\t\t}\n\t\tswitch refWidth := 0; {\n\t\tcase stat.Refill != 0:\n\t\t\trefWidth = int(internal.PercentageRound(stat.Total, stat.Refill, uint(width)))\n\t\t\tcurWidth -= refWidth\n\t\t\trefWidth += curWidth\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\tfor w := s.components[iFiller].width; curWidth-fillCount >= w; fillCount += w {\n\t\t\t\tfilling = append(filling, s.components[iFiller].bytes...)\n\t\t\t}\n\t\t\tfor w := s.components[iRefiller].width; refWidth-fillCount >= w; fillCount += w {\n\t\t\t\trefilling = append(refilling, s.components[iRefiller].bytes...)\n\t\t\t}\n\t\t}\n\t}\n\n\tfor w := s.components[iPadding].width; width-fillCount >= w; fillCount += w {\n\t\tpadding = append(padding, s.components[iPadding].bytes...)\n\t}\n\n\tfor w := 1; width-fillCount >= w; fillCount += w {\n\t\tpadding = append(padding, \"…\"...)\n\t}\n\n\terr = s.flush(w,\n\t\tflushSection{s.meta[iRefiller], refilling},\n\t\tflushSection{s.meta[iFiller], filling},\n\t\tflushSection{s.meta[iTip], tip.bytes},\n\t\tflushSection{s.meta[iPadding], padding},\n\t)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.meta[iRbound](w, s.components[iRbound].bytes)\n}\n\nfunc makeMetaFunc(fn func(string) string) func(io.Writer, []byte) error {\n\treturn func(w io.Writer, p []byte) (err error) {\n\t\t_, err = io.WriteString(w, fn(string(p)))\n\t\treturn err\n\t}\n}\n\nfunc defaultMeta(w io.Writer, p []byte) (err error) {\n\t_, err = w.Write(p)\n\treturn err\n}\n"
        },
        {
          "name": "bar_filler_nop.go",
          "type": "blob",
          "size": 0.521484375,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\n// barFillerBuilderFunc is function type adapter to convert compatible\n// function into BarFillerBuilder interface.\ntype barFillerBuilderFunc func() BarFiller\n\nfunc (f barFillerBuilderFunc) Build() BarFiller {\n\treturn f()\n}\n\n// NopStyle provides BarFillerBuilder which builds NOP BarFiller.\nfunc NopStyle() BarFillerBuilder {\n\treturn barFillerBuilderFunc(func() BarFiller {\n\t\treturn BarFillerFunc(func(io.Writer, decor.Statistics) error {\n\t\t\treturn nil\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "bar_filler_spinner.go",
          "type": "blob",
          "size": 2.2890625,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/mattn/go-runewidth\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n\t\"github.com/vbauerster/mpb/v8/internal\"\n)\n\nconst (\n\tpositionLeft = 1 + iota\n\tpositionRight\n)\n\nvar defaultSpinnerStyle = [...]string{\"⠋\", \"⠙\", \"⠹\", \"⠸\", \"⠼\", \"⠴\", \"⠦\", \"⠧\", \"⠇\", \"⠏\"}\n\n// SpinnerStyleComposer interface.\ntype SpinnerStyleComposer interface {\n\tBarFillerBuilder\n\tPositionLeft() SpinnerStyleComposer\n\tPositionRight() SpinnerStyleComposer\n\tMeta(func(string) string) SpinnerStyleComposer\n}\n\ntype sFiller struct {\n\tframes   []string\n\tcount    uint\n\tmeta     func(string) string\n\tposition func(string, int) string\n}\n\ntype spinnerStyle struct {\n\tposition uint\n\tframes   []string\n\tmeta     func(string) string\n}\n\n// SpinnerStyle constructs default spinner style which can be altered via\n// SpinnerStyleComposer interface.\nfunc SpinnerStyle(frames ...string) SpinnerStyleComposer {\n\tss := spinnerStyle{\n\t\tmeta: func(s string) string { return s },\n\t}\n\tif len(frames) != 0 {\n\t\tss.frames = frames\n\t} else {\n\t\tss.frames = defaultSpinnerStyle[:]\n\t}\n\treturn ss\n}\n\nfunc (s spinnerStyle) PositionLeft() SpinnerStyleComposer {\n\ts.position = positionLeft\n\treturn s\n}\n\nfunc (s spinnerStyle) PositionRight() SpinnerStyleComposer {\n\ts.position = positionRight\n\treturn s\n}\n\nfunc (s spinnerStyle) Meta(fn func(string) string) SpinnerStyleComposer {\n\ts.meta = fn\n\treturn s\n}\n\nfunc (s spinnerStyle) Build() BarFiller {\n\tsf := &sFiller{\n\t\tframes: s.frames,\n\t\tmeta:   s.meta,\n\t}\n\tswitch s.position {\n\tcase positionLeft:\n\t\tsf.position = func(frame string, padWidth int) string {\n\t\t\treturn frame + strings.Repeat(\" \", padWidth)\n\t\t}\n\tcase positionRight:\n\t\tsf.position = func(frame string, padWidth int) string {\n\t\t\treturn strings.Repeat(\" \", padWidth) + frame\n\t\t}\n\tdefault:\n\t\tsf.position = func(frame string, padWidth int) string {\n\t\t\treturn strings.Repeat(\" \", padWidth/2) + frame + strings.Repeat(\" \", padWidth/2+padWidth%2)\n\t\t}\n\t}\n\treturn sf\n}\n\nfunc (s *sFiller) Fill(w io.Writer, stat decor.Statistics) error {\n\twidth := internal.CheckRequestedWidth(stat.RequestedWidth, stat.AvailableWidth)\n\tframe := s.frames[s.count%uint(len(s.frames))]\n\tframeWidth := runewidth.StringWidth(frame)\n\ts.count++\n\n\tif width < frameWidth {\n\t\treturn nil\n\t}\n\n\t_, err := io.WriteString(w, s.position(s.meta(frame), width-frameWidth))\n\treturn err\n}\n"
        },
        {
          "name": "bar_option.go",
          "type": "blob",
          "size": 4.9931640625,
          "content": "package mpb\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\n// BarOption is a func option to alter default behavior of a bar.\ntype BarOption func(*bState)\n\nfunc inspect(decorators []decor.Decorator) (dest []decor.Decorator) {\n\tfor _, decorator := range decorators {\n\t\tif decorator == nil {\n\t\t\tcontinue\n\t\t}\n\t\tdest = append(dest, decorator)\n\t}\n\treturn\n}\n\n// PrependDecorators let you inject decorators to the bar's left side.\nfunc PrependDecorators(decorators ...decor.Decorator) BarOption {\n\tdecorators = inspect(decorators)\n\treturn func(s *bState) {\n\t\ts.populateEwmaDecorators(decorators)\n\t\ts.decorators[0] = decorators\n\t}\n}\n\n// AppendDecorators let you inject decorators to the bar's right side.\nfunc AppendDecorators(decorators ...decor.Decorator) BarOption {\n\tdecorators = inspect(decorators)\n\treturn func(s *bState) {\n\t\ts.populateEwmaDecorators(decorators)\n\t\ts.decorators[1] = decorators\n\t}\n}\n\n// BarID sets bar id.\nfunc BarID(id int) BarOption {\n\treturn func(s *bState) {\n\t\ts.id = id\n\t}\n}\n\n// BarWidth sets bar width independent of the container.\nfunc BarWidth(width int) BarOption {\n\treturn func(s *bState) {\n\t\ts.reqWidth = width\n\t}\n}\n\n// BarQueueAfter puts this (being constructed) bar into the queue.\n// BarPriority will be inherited from the argument bar.\n// When argument bar completes or aborts queued bar replaces its place.\nfunc BarQueueAfter(bar *Bar) BarOption {\n\treturn func(s *bState) {\n\t\ts.waitBar = bar\n\t}\n}\n\n// BarRemoveOnComplete removes both bar's filler and its decorators\n// on complete event.\nfunc BarRemoveOnComplete() BarOption {\n\treturn func(s *bState) {\n\t\ts.rmOnComplete = true\n\t}\n}\n\n// BarFillerClearOnComplete clears bar's filler on complete event.\n// It's shortcut for BarFillerOnComplete(\"\").\nfunc BarFillerClearOnComplete() BarOption {\n\treturn BarFillerOnComplete(\"\")\n}\n\n// BarFillerOnComplete replaces bar's filler with message, on complete event.\nfunc BarFillerOnComplete(message string) BarOption {\n\treturn BarFillerMiddleware(func(base BarFiller) BarFiller {\n\t\treturn BarFillerFunc(func(w io.Writer, st decor.Statistics) error {\n\t\t\tif st.Completed {\n\t\t\t\t_, err := io.WriteString(w, message)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn base.Fill(w, st)\n\t\t})\n\t})\n}\n\n// BarFillerMiddleware provides a way to augment the underlying BarFiller.\nfunc BarFillerMiddleware(middle func(BarFiller) BarFiller) BarOption {\n\tif middle == nil {\n\t\treturn nil\n\t}\n\treturn func(s *bState) {\n\t\ts.filler = middle(s.filler)\n\t}\n}\n\n// BarPriority sets bar's priority. Zero is highest priority, i.e. bar\n// will be on top. This option isn't effective with `BarQueueAfter` option.\nfunc BarPriority(priority int) BarOption {\n\treturn func(s *bState) {\n\t\ts.priority = priority\n\t}\n}\n\n// BarExtender extends bar with arbitrary lines. Provided BarFiller will be\n// called at each render/flush cycle. Any lines written to the underlying\n// io.Writer will extend the bar either in above (rev = true) or below\n// (rev = false) direction.\nfunc BarExtender(filler BarFiller, rev bool) BarOption {\n\tif filler == nil {\n\t\treturn nil\n\t}\n\tif f, ok := filler.(BarFillerFunc); ok && f == nil {\n\t\treturn nil\n\t}\n\tfn := makeExtenderFunc(filler, rev)\n\treturn func(s *bState) {\n\t\ts.extender = fn\n\t}\n}\n\nfunc makeExtenderFunc(filler BarFiller, rev bool) extenderFunc {\n\tbuf := new(bytes.Buffer)\n\tbase := func(stat decor.Statistics, rows ...io.Reader) ([]io.Reader, error) {\n\t\terr := filler.Fill(buf, stat)\n\t\tif err != nil {\n\t\t\tbuf.Reset()\n\t\t\treturn rows, err\n\t\t}\n\t\tfor {\n\t\t\tline, err := buf.ReadBytes('\\n')\n\t\t\tif err != nil {\n\t\t\t\tbuf.Reset()\n\t\t\t\tbreak\n\t\t\t}\n\t\t\trows = append(rows, bytes.NewReader(line))\n\t\t}\n\t\treturn rows, err\n\t}\n\tif !rev {\n\t\treturn base\n\t}\n\treturn func(stat decor.Statistics, rows ...io.Reader) ([]io.Reader, error) {\n\t\trows, err := base(stat, rows...)\n\t\tif err != nil {\n\t\t\treturn rows, err\n\t\t}\n\t\tfor left, right := 0, len(rows)-1; left < right; left, right = left+1, right-1 {\n\t\t\trows[left], rows[right] = rows[right], rows[left]\n\t\t}\n\t\treturn rows, err\n\t}\n}\n\n// BarFillerTrim removes leading and trailing space around the underlying BarFiller.\nfunc BarFillerTrim() BarOption {\n\treturn func(s *bState) {\n\t\ts.trimSpace = true\n\t}\n}\n\n// BarNoPop disables bar pop out of container. Effective when\n// PopCompletedMode of container is enabled.\nfunc BarNoPop() BarOption {\n\treturn func(s *bState) {\n\t\ts.noPop = true\n\t}\n}\n\n// BarOptional will return provided option only when cond is true.\nfunc BarOptional(option BarOption, cond bool) BarOption {\n\tif cond {\n\t\treturn option\n\t}\n\treturn nil\n}\n\n// BarOptOn will return provided option only when predicate evaluates to true.\nfunc BarOptOn(option BarOption, predicate func() bool) BarOption {\n\tif predicate() {\n\t\treturn option\n\t}\n\treturn nil\n}\n\n// BarFuncOptional will call option and return its value only when cond is true.\nfunc BarFuncOptional(option func() BarOption, cond bool) BarOption {\n\tif cond {\n\t\treturn option()\n\t}\n\treturn nil\n}\n\n// BarFuncOptOn will call option and return its value only when predicate evaluates to true.\nfunc BarFuncOptOn(option func() BarOption, predicate func() bool) BarOption {\n\tif predicate() {\n\t\treturn option()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "bar_test.go",
          "type": "blob",
          "size": 6.8798828125,
          "content": "package mpb_test\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\t\"unicode/utf8\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\nfunc TestBarCompleted(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\ttotal := 80\n\tbar := p.AddBar(int64(total))\n\n\tif bar.Completed() {\n\t\tt.Error(\"expected bar not to complete\")\n\t}\n\n\tbar.IncrBy(total)\n\n\tif !bar.Completed() {\n\t\tt.Error(\"expected bar to complete\")\n\t}\n\n\tp.Wait()\n}\n\nfunc TestBarAborted(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\ttotal := 80\n\tbar := p.AddBar(int64(total))\n\n\tif bar.Aborted() {\n\t\tt.Error(\"expected bar not to be aborted\")\n\t}\n\n\tbar.Abort(false)\n\n\tif !bar.Aborted() {\n\t\tt.Error(\"expected bar to be aborted\")\n\t}\n\n\tp.Wait()\n}\n\nfunc TestBarSetTotal(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\tbar := p.AddBar(0)\n\n\tbar.SetTotal(0, false)\n\tif bar.Completed() {\n\t\tt.Error(\"expected bar not to complete\")\n\t}\n\n\tbar.SetTotal(0, true)\n\tif !bar.Completed() {\n\t\tt.Error(\"expected bar to complete\")\n\t}\n\n\tp.Wait()\n}\n\nfunc TestBarEnableTriggerCompleteZeroBar(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\tbar := p.AddBar(0) // never complete bar\n\n\tif bar.Completed() {\n\t\tt.Error(\"expected bar not to complete\")\n\t}\n\n\t// Calling bar.SetTotal(0, true) has same effect\n\t// but this one is more concise and intuitive\n\tbar.EnableTriggerComplete()\n\n\tif !bar.Completed() {\n\t\tt.Error(\"expected bar to complete\")\n\t}\n\n\tp.Wait()\n}\n\nfunc TestBarEnableTriggerCompleteAndIncrementBefore(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\tbar := p.AddBar(0) // never complete bar\n\n\ttargetTotal := int64(80)\n\n\tfor _, f := range []func(){\n\t\tfunc() { bar.SetTotal(40, false) },\n\t\tfunc() { bar.IncrBy(60) },\n\t\tfunc() { bar.SetTotal(targetTotal, false) },\n\t\tfunc() { bar.IncrBy(20) },\n\t} {\n\t\tf()\n\t\tif bar.Completed() {\n\t\t\tt.Error(\"expected bar not to complete\")\n\t\t}\n\t}\n\n\tbar.EnableTriggerComplete()\n\n\tif !bar.Completed() {\n\t\tt.Error(\"expected bar to complete\")\n\t}\n\n\tif current := bar.Current(); current != targetTotal {\n\t\tt.Errorf(\"Expected current: %d, got: %d\", targetTotal, current)\n\t}\n\n\tp.Wait()\n}\n\nfunc TestBarEnableTriggerCompleteAndIncrementAfter(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\tbar := p.AddBar(0) // never complete bar\n\n\ttargetTotal := int64(80)\n\n\tfor _, f := range []func(){\n\t\tfunc() { bar.SetTotal(40, false) },\n\t\tfunc() { bar.IncrBy(60) },\n\t\tfunc() { bar.SetTotal(targetTotal, false) },\n\t\tfunc() { bar.EnableTriggerComplete() }, // disables any next SetTotal\n\t\tfunc() { bar.SetTotal(100, true) },     // nop\n\t} {\n\t\tf()\n\t\tif bar.Completed() {\n\t\t\tt.Error(\"expected bar not to complete\")\n\t\t}\n\t}\n\n\tbar.IncrBy(20)\n\n\tif !bar.Completed() {\n\t\tt.Error(\"expected bar to complete\")\n\t}\n\n\tif current := bar.Current(); current != targetTotal {\n\t\tt.Errorf(\"Expected current: %d, got: %d\", targetTotal, current)\n\t}\n\n\tp.Wait()\n}\n\nfunc TestBarID(t *testing.T) {\n\tp := mpb.New(mpb.WithWidth(80), mpb.WithOutput(io.Discard))\n\ttotal := 100\n\twantID := 11\n\tbar := p.AddBar(int64(total), mpb.BarID(wantID))\n\n\tgotID := bar.ID()\n\tif gotID != wantID {\n\t\tt.Errorf(\"Expected bar id: %d, got %d\", wantID, gotID)\n\t}\n\n\tbar.IncrBy(total)\n\n\tp.Wait()\n}\n\nfunc TestBarSetRefill(t *testing.T) {\n\tvar buf bytes.Buffer\n\tp := mpb.New(\n\t\tmpb.WithWidth(100),\n\t\tmpb.WithOutput(&buf),\n\t\tmpb.WithAutoRefresh(),\n\t)\n\n\ttotal := 100\n\ttill := 30\n\trefiller := \"+\"\n\n\tbar := p.New(int64(total), mpb.BarStyle().Refiller(refiller), mpb.BarFillerTrim())\n\n\tbar.IncrBy(till)\n\tbar.SetRefill(int64(till))\n\tbar.IncrBy(total - till)\n\n\tp.Wait()\n\n\twantBar := fmt.Sprintf(\"[%s%s]\",\n\t\tstrings.Repeat(refiller, till-1),\n\t\tstrings.Repeat(\"=\", total-till-1),\n\t)\n\n\tgot := string(bytes.Split(buf.Bytes(), []byte(\"\\n\"))[0])\n\n\tif !strings.Contains(got, wantBar) {\n\t\tt.Errorf(\"Want bar: %q, got bar: %q\", wantBar, got)\n\t}\n}\n\nfunc TestBarHas100PercentWithBarRemoveOnComplete(t *testing.T) {\n\tvar buf bytes.Buffer\n\tp := mpb.New(\n\t\tmpb.WithWidth(80),\n\t\tmpb.WithOutput(&buf),\n\t\tmpb.WithAutoRefresh(),\n\t)\n\n\ttotal := 50\n\n\tbar := p.AddBar(int64(total),\n\t\tmpb.BarRemoveOnComplete(),\n\t\tmpb.AppendDecorators(decor.Percentage()),\n\t)\n\n\tbar.IncrBy(total)\n\n\tp.Wait()\n\n\thundred := \"100 %\"\n\tif !bytes.Contains(buf.Bytes(), []byte(hundred)) {\n\t\tt.Errorf(\"Bar's buffer does not contain: %q\", hundred)\n\t}\n}\n\nfunc TestBarStyle(t *testing.T) {\n\tvar buf bytes.Buffer\n\tcustomFormat := \"╢▌▌░╟\"\n\trunes := []rune(customFormat)\n\ttotal := 80\n\tp := mpb.New(\n\t\tmpb.WithWidth(80),\n\t\tmpb.WithOutput(&buf),\n\t\tmpb.WithAutoRefresh(),\n\t)\n\tbs := mpb.BarStyle()\n\tbs = bs.Lbound(string(runes[0]))\n\tbs = bs.Filler(string(runes[1]))\n\tbs = bs.Tip(string(runes[2]))\n\tbs = bs.Padding(string(runes[3]))\n\tbs = bs.Rbound(string(runes[4]))\n\tbar := p.New(int64(total), bs, mpb.BarFillerTrim())\n\n\tbar.IncrBy(total)\n\n\tp.Wait()\n\n\twantBar := fmt.Sprintf(\"%s%s%s%s\",\n\t\tstring(runes[0]),\n\t\tstrings.Repeat(string(runes[1]), total-3),\n\t\tstring(runes[2]),\n\t\tstring(runes[4]),\n\t)\n\tgot := string(bytes.Split(buf.Bytes(), []byte(\"\\n\"))[0])\n\n\tif !strings.Contains(got, wantBar) {\n\t\tt.Errorf(\"Want bar: %q:%d, got bar: %q:%d\", wantBar, utf8.RuneCountInString(wantBar), got, utf8.RuneCountInString(got))\n\t}\n}\n\nfunc TestDecorStatisticsAvailableWidth(t *testing.T) {\n\tch := make(chan int, 2)\n\ttd1 := func(s decor.Statistics) string {\n\t\tch <- s.AvailableWidth\n\t\treturn strings.Repeat(\"0\", 20)\n\t}\n\ttd2 := func(s decor.Statistics) string {\n\t\tch <- s.AvailableWidth\n\t\treturn \"\"\n\t}\n\tctx, cancel := context.WithCancel(context.Background())\n\trefresh := make(chan interface{})\n\tp := mpb.NewWithContext(ctx,\n\t\tmpb.WithWidth(100),\n\t\tmpb.WithManualRefresh(refresh),\n\t\tmpb.WithOutput(io.Discard),\n\t)\n\t_ = p.AddBar(0,\n\t\tmpb.BarFillerTrim(),\n\t\tmpb.PrependDecorators(\n\t\t\tdecor.Name(strings.Repeat(\"0\", 20)),\n\t\t\tdecor.Meta(\n\t\t\t\tdecor.Any(td1),\n\t\t\t\tfunc(s string) string {\n\t\t\t\t\treturn \"\\x1b[31;1m\" + s + \"\\x1b[0m\"\n\t\t\t\t},\n\t\t\t),\n\t\t),\n\t\tmpb.AppendDecorators(\n\t\t\tdecor.Name(strings.Repeat(\"0\", 20)),\n\t\t\tdecor.Any(td2),\n\t\t),\n\t)\n\trefresh <- time.Now()\n\tgo func() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tcancel()\n\t}()\n\tp.Wait()\n\n\tif availableWidth := <-ch; availableWidth != 80 {\n\t\tt.Errorf(\"expected AvailableWidth %d got %d\", 80, availableWidth)\n\t}\n\n\tif availableWidth := <-ch; availableWidth != 40 {\n\t\tt.Errorf(\"expected AvailableWidth %d got %d\", 40, availableWidth)\n\t}\n}\n\nfunc TestBarQueueAfterBar(t *testing.T) {\n\tshutdown := make(chan interface{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tp := mpb.NewWithContext(ctx,\n\t\tmpb.WithOutput(io.Discard),\n\t\tmpb.WithAutoRefresh(),\n\t\tmpb.WithShutdownNotifier(shutdown),\n\t)\n\ta := p.AddBar(100)\n\tb := p.AddBar(100, mpb.BarQueueAfter(a))\n\tidentity := map[*mpb.Bar]string{\n\t\ta: \"a\",\n\t\tb: \"b\",\n\t}\n\n\ta.IncrBy(100)\n\ta.Wait()\n\tcancel()\n\n\tbars := (<-shutdown).([]*mpb.Bar)\n\tif l := len(bars); l != 1 {\n\t\tt.Errorf(\"Expected len of bars: %d, got: %d\", 1, l)\n\t}\n\n\tp.Wait()\n\tif bars[0] != b {\n\t\tt.Errorf(\"Expected bars[0] == b, got: %s\", identity[bars[0]])\n\t}\n}\n"
        },
        {
          "name": "barbench_test.go",
          "type": "blob",
          "size": 1.7119140625,
          "content": "package mpb_test\n\nimport (\n\t\"io\"\n\t\"testing\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n)\n\nconst total = 1000\n\nfunc BenchmarkNopStyleB1(b *testing.B) {\n\tbench(b, mpb.NopStyle(), false, 1)\n}\n\nfunc BenchmarkNopStyleWithAutoRefreshB1(b *testing.B) {\n\tbench(b, mpb.NopStyle(), true, 1)\n}\n\nfunc BenchmarkNopStylesB2(b *testing.B) {\n\tbench(b, mpb.NopStyle(), false, 2)\n}\n\nfunc BenchmarkNopStylesWithAutoRefreshB2(b *testing.B) {\n\tbench(b, mpb.NopStyle(), true, 2)\n}\n\nfunc BenchmarkNopStylesB3(b *testing.B) {\n\tbench(b, mpb.NopStyle(), false, 3)\n}\n\nfunc BenchmarkNopStylesWithAutoRefreshB3(b *testing.B) {\n\tbench(b, mpb.NopStyle(), true, 3)\n}\n\nfunc BenchmarkBarStyleB1(b *testing.B) {\n\tbench(b, mpb.BarStyle(), false, 1)\n}\n\nfunc BenchmarkBarStyleWithAutoRefreshB1(b *testing.B) {\n\tbench(b, mpb.BarStyle(), true, 1)\n}\n\nfunc BenchmarkBarStylesB2(b *testing.B) {\n\tbench(b, mpb.BarStyle(), false, 2)\n}\n\nfunc BenchmarkBarStylesWithAutoRefreshB2(b *testing.B) {\n\tbench(b, mpb.BarStyle(), true, 2)\n}\n\nfunc BenchmarkBarStylesB3(b *testing.B) {\n\tbench(b, mpb.BarStyle(), false, 3)\n}\n\nfunc BenchmarkBarStylesWithAutoRefreshB3(b *testing.B) {\n\tbench(b, mpb.BarStyle(), true, 3)\n}\n\nfunc bench(b *testing.B, builder mpb.BarFillerBuilder, autoRefresh bool, n int) {\n\tp := mpb.New(\n\t\tmpb.WithWidth(100),\n\t\tmpb.WithOutput(io.Discard),\n\t\tmpb.ContainerOptional(mpb.WithAutoRefresh(), autoRefresh),\n\t)\n\tdefer p.Wait()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tvar bars []*mpb.Bar\n\t\tfor j := 0; j < n; j++ {\n\t\t\tbars = append(bars, p.New(total, builder))\n\t\t\tswitch j {\n\t\t\tcase n - 1:\n\t\t\t\tcomplete(bars[j])\n\t\t\tdefault:\n\t\t\t\tgo complete(bars[j])\n\t\t\t}\n\t\t}\n\t\tfor _, bar := range bars {\n\t\t\tbar.Wait()\n\t\t}\n\t}\n}\n\nfunc complete(bar *mpb.Bar) {\n\tfor i := 0; i < total; i++ {\n\t\tbar.Increment()\n\t}\n}\n"
        },
        {
          "name": "container_option.go",
          "type": "blob",
          "size": 4.05859375,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\t\"sync\"\n\t\"time\"\n)\n\n// ContainerOption is a func option to alter default behavior of a bar\n// container. Container term refers to a Progress struct which can\n// hold one or more Bars.\ntype ContainerOption func(*pState)\n\n// WithWaitGroup provides means to have a single joint point. If\n// *sync.WaitGroup is provided, you can safely call just p.Wait()\n// without calling Wait() on provided *sync.WaitGroup. Makes sense\n// when there are more than one bar to render.\nfunc WithWaitGroup(wg *sync.WaitGroup) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.uwg = wg\n\t}\n}\n\n// WithWidth sets container width. If not set it defaults to terminal\n// width. A bar added to the container will inherit its width, unless\n// overridden by `func BarWidth(int) BarOption`.\nfunc WithWidth(width int) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.reqWidth = width\n\t}\n}\n\n// WithQueueLen sets buffer size of heap manager channel. Ideally it must be\n// kept at MAX value, where MAX is number of bars to be rendered at the same\n// time. If len < MAX then backpressure to the scheduler will be increased as\n// MAX-len extra goroutines will be launched at each render cycle.\n// Default queue len is 128.\nfunc WithQueueLen(len int) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.hmQueueLen = len\n\t}\n}\n\n// WithRefreshRate overrides default 150ms refresh rate.\nfunc WithRefreshRate(d time.Duration) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.refreshRate = d\n\t}\n}\n\n// WithManualRefresh disables internal auto refresh time.Ticker.\n// Refresh will occur upon receive value from provided ch.\nfunc WithManualRefresh(ch <-chan interface{}) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.manualRC = ch\n\t}\n}\n\n// WithRenderDelay delays rendering. By default rendering starts as\n// soon as bar is added, with this option it's possible to delay\n// rendering process by keeping provided chan unclosed. In other words\n// rendering will start as soon as provided chan is closed.\nfunc WithRenderDelay(ch <-chan struct{}) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.delayRC = ch\n\t}\n}\n\n// WithShutdownNotifier value of type `[]*mpb.Bar` will be send into provided\n// channel upon container shutdown.\nfunc WithShutdownNotifier(ch chan<- interface{}) ContainerOption {\n\treturn func(s *pState) {\n\t\ts.shutdownNotifier = ch\n\t}\n}\n\n// WithOutput overrides default os.Stdout output. If underlying io.Writer\n// is not a terminal then auto refresh is disabled unless WithAutoRefresh\n// option is set.\nfunc WithOutput(w io.Writer) ContainerOption {\n\tif w == nil {\n\t\tw = io.Discard\n\t}\n\treturn func(s *pState) {\n\t\ts.output = w\n\t}\n}\n\n// WithDebugOutput sets debug output.\nfunc WithDebugOutput(w io.Writer) ContainerOption {\n\tif w == nil {\n\t\tw = io.Discard\n\t}\n\treturn func(s *pState) {\n\t\ts.debugOut = w\n\t}\n}\n\n// WithAutoRefresh force auto refresh regardless of what output is set to.\n// Applicable only if not WithManualRefresh set.\nfunc WithAutoRefresh() ContainerOption {\n\treturn func(s *pState) {\n\t\ts.autoRefresh = true\n\t}\n}\n\n// PopCompletedMode pop completed bars out of progress container.\n// In this mode completed bars get moved to the top and stop\n// participating in rendering cycle.\nfunc PopCompletedMode() ContainerOption {\n\treturn func(s *pState) {\n\t\ts.popCompleted = true\n\t}\n}\n\n// ContainerOptional will return provided option only when cond is true.\nfunc ContainerOptional(option ContainerOption, cond bool) ContainerOption {\n\tif cond {\n\t\treturn option\n\t}\n\treturn nil\n}\n\n// ContainerOptOn will return provided option only when predicate evaluates to true.\nfunc ContainerOptOn(option ContainerOption, predicate func() bool) ContainerOption {\n\tif predicate() {\n\t\treturn option\n\t}\n\treturn nil\n}\n\n// ContainerFuncOptional will call option and return its value only when cond is true.\nfunc ContainerFuncOptional(option func() ContainerOption, cond bool) ContainerOption {\n\tif cond {\n\t\treturn option()\n\t}\n\treturn nil\n}\n\n// ContainerFuncOptOn will call option and return its value only when predicate evaluates to true.\nfunc ContainerFuncOptOn(option func() ContainerOption, predicate func() bool) ContainerOption {\n\tif predicate() {\n\t\treturn option()\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "cwriter",
          "type": "tree",
          "content": null
        },
        {
          "name": "decor",
          "type": "tree",
          "content": null
        },
        {
          "name": "decorators_test.go",
          "type": "blob",
          "size": 3.9951171875,
          "content": "package mpb_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\nfunc TestNameDecorator(t *testing.T) {\n\ttests := []struct {\n\t\tdecorator decor.Decorator\n\t\twant      string\n\t}{\n\t\t{\n\t\t\tdecorator: decor.Name(\"Test\"),\n\t\t\twant:      \"Test\",\n\t\t},\n\t\t{\n\t\t\tdecorator: decor.Name(\"Test\", decor.WC{W: len(\"Test\")}),\n\t\t\twant:      \"Test\",\n\t\t},\n\t\t{\n\t\t\tdecorator: decor.Name(\"Test\", decor.WC{W: 10}),\n\t\t\twant:      \"      Test\",\n\t\t},\n\t\t{\n\t\t\tdecorator: decor.Name(\"Test\", decor.WC{W: 10, C: decor.DindentRight}),\n\t\t\twant:      \"Test      \",\n\t\t},\n\t}\n\n\tfor _, test := range tests {\n\t\tgot, _ := test.decorator.Decor(decor.Statistics{})\n\t\tif got != test.want {\n\t\t\tt.Errorf(\"Want: %q, Got: %q\\n\", test.want, got)\n\t\t}\n\t}\n}\n\ntype step struct {\n\tstat      decor.Statistics\n\tdecorator decor.Decorator\n\twant      string\n}\n\nfunc TestPercentageDwidthSync(t *testing.T) {\n\n\ttestCases := [][]step{\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 8},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidth),\n\t\t\t\t\"8 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidth),\n\t\t\t\t\"9 %\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidth),\n\t\t\t\t\" 9 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 10},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidth),\n\t\t\t\t\"10 %\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidth),\n\t\t\t\t\"  9 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 100},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidth),\n\t\t\t\t\"100 %\",\n\t\t\t},\n\t\t},\n\t}\n\n\ttestDecoratorConcurrently(t, testCases)\n}\n\nfunc TestPercentageDwidthSyncDindentRight(t *testing.T) {\n\n\ttestCases := [][]step{\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 8},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidthR),\n\t\t\t\t\"8 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidthR),\n\t\t\t\t\"9 %\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidthR),\n\t\t\t\t\"9 % \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 10},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidthR),\n\t\t\t\t\"10 %\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidthR),\n\t\t\t\t\"9 %  \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 100},\n\t\t\t\tdecor.Percentage(decor.WCSyncWidthR),\n\t\t\t\t\"100 %\",\n\t\t\t},\n\t\t},\n\t}\n\n\ttestDecoratorConcurrently(t, testCases)\n}\n\nfunc TestPercentageDSyncSpace(t *testing.T) {\n\n\ttestCases := [][]step{\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 8},\n\t\t\t\tdecor.Percentage(decor.WCSyncSpace),\n\t\t\t\t\" 8 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncSpace),\n\t\t\t\t\" 9 %\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncSpace),\n\t\t\t\t\"  9 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 10},\n\t\t\t\tdecor.Percentage(decor.WCSyncSpace),\n\t\t\t\t\" 10 %\",\n\t\t\t},\n\t\t},\n\t\t{\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 9},\n\t\t\t\tdecor.Percentage(decor.WCSyncSpace),\n\t\t\t\t\"   9 %\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tdecor.Statistics{Total: 100, Current: 100},\n\t\t\t\tdecor.Percentage(decor.WCSyncSpace),\n\t\t\t\t\" 100 %\",\n\t\t\t},\n\t\t},\n\t}\n\n\ttestDecoratorConcurrently(t, testCases)\n}\n\nfunc testDecoratorConcurrently(t *testing.T, testCases [][]step) {\n\tif len(testCases) == 0 {\n\t\tt.Fail()\n\t}\n\n\tfor _, columnCase := range testCases {\n\t\tmpb.SyncWidth(toSyncMatrix(columnCase), nil)\n\t\tvar results []chan string\n\t\tfor _, step := range columnCase {\n\t\t\tstep := step\n\t\t\tch := make(chan string)\n\t\t\tgo func() {\n\t\t\t\tstr, _ := step.decorator.Decor(step.stat)\n\t\t\t\tch <- str\n\t\t\t}()\n\t\t\tresults = append(results, ch)\n\t\t}\n\n\t\tfor i, ch := range results {\n\t\t\tres := <-ch\n\t\t\twant := columnCase[i].want\n\t\t\tif res != want {\n\t\t\t\tt.Errorf(\"Want: %q, Got: %q\\n\", want, res)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc toSyncMatrix(ss []step) map[int][]chan int {\n\tvar column []chan int\n\tfor _, s := range ss {\n\t\tif ch, ok := s.decorator.Sync(); ok {\n\t\t\tcolumn = append(column, ch)\n\t\t}\n\t}\n\treturn map[int][]chan int{0: column}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.091796875,
          "content": "// Package mpb is a library for rendering progress bars in terminal applications.\npackage mpb\n"
        },
        {
          "name": "draw_test.go",
          "type": "blob",
          "size": 36.353515625,
          "content": "package mpb\n\nimport (\n\t\"bytes\"\n\t\"testing\"\n\t\"unicode/utf8\"\n)\n\nfunc TestDrawDefault(t *testing.T) {\n\t// key is termWidth\n\ttestSuite := map[int][]struct {\n\t\tstyle    BarStyleComposer\n\t\tname     string\n\t\ttotal    int64\n\t\tcurrent  int64\n\t\trefill   int64\n\t\tbarWidth int\n\t\ttrim     bool\n\t\twant     string\n\t}{\n\t\t0: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"\",\n\t\t\t},\n\t\t},\n\t\t1: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"\",\n\t\t\t},\n\t\t},\n\t\t2: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \"  \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[]\",\n\t\t\t},\n\t\t},\n\t\t3: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \"  \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \"  \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \"  \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=]\",\n\t\t\t},\n\t\t},\n\t\t4: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \" [] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[==]\",\n\t\t\t},\n\t\t},\n\t\t5: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \" [-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>--]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[==>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [=] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[===]\",\n\t\t\t},\n\t\t},\n\t\t6: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \" [>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>---]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [=>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[===>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [==] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[====]\",\n\t\t\t},\n\t\t},\n\t\t7: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \" [>--] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=>---]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [==>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[====>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [===] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=====]\",\n\t\t\t},\n\t\t},\n\t\t8: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \" [>---] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=>----]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [===>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=====>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [====] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[======]\",\n\t\t\t},\n\t\t},\n\t\t80: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\twant:    \" [========================>---------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,20}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 20,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=========================>----------------------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle(),\n\t\t\t\tname:     \"t,c,bw{60,20,60}\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  20,\n\t\t\t\tbarWidth: 60,\n\t\t\t\twant:     \" [==================>---------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle(),\n\t\t\t\tname:     \"t,c,bw{60,20,60}trim\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  20,\n\t\t\t\tbarWidth: 60,\n\t\t\t\ttrim:     true,\n\t\t\t\twant:     \"[==================>---------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [==========================================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[============================================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle(),\n\t\t\t\tname:     \"t,c,bw{60,59,60}\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  59,\n\t\t\t\tbarWidth: 60,\n\t\t\t\twant:     \" [========================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle(),\n\t\t\t\tname:     \"t,c,bw{60,59,60}trim\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  59,\n\t\t\t\tbarWidth: 60,\n\t\t\t\ttrim:     true,\n\t\t\t\twant:     \"[========================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [============================================================================] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[==============================================================================]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle(),\n\t\t\t\tname:     \"t,c,bw{60,60,60}\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  60,\n\t\t\t\tbarWidth: 60,\n\t\t\t\twant:     \" [==========================================================] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle(),\n\t\t\t\tname:     \"t,c,bw{60,60,60}trim\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  60,\n\t\t\t\tbarWidth: 60,\n\t\t\t\ttrim:     true,\n\t\t\t\twant:     \"[==========================================================]\",\n\t\t\t},\n\t\t},\n\t\t99: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,1}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\twant:    \" [>----------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,1}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>------------------------------------------------------------------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,40,33}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\twant:    \" [+++++++++++++++++++++++++++++++======>---------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,40,33}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++======>----------------------------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").Reverse(),\n\t\t\t\tname:    \"t,c,r{100,40,33},rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\twant:    \" [---------------------------------------------------------<======+++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").Reverse(),\n\t\t\t\tname:    \"t,c,r{100,40,33}trim,rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[----------------------------------------------------------<======++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [=============================================================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[===============================================================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [===============================================================================================] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=================================================================================================]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,99}rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [=++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,99}trim,rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,100}rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t},\n\t\t100: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,0}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 0,\n\t\t\t\twant:    \" [------------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,0}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 0,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[--------------------------------------------------------------------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,1}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\twant:    \" [>-----------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"\"),\n\t\t\t\tname:    \"t,c{100,1}empty_tip\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\twant:    \" [=-----------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,1}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>-------------------------------------------------------------------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [==============================================================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"\"),\n\t\t\t\tname:    \"t,c{100,99}empty_tip\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [===============================================================================================-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[================================================================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [================================================================================================] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c{100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[==================================================================================================]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++=]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,99}rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [=+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,99}trim,rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,100}rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Reverse(),\n\t\t\t\tname:    \"t,c,r{100,100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,40,33}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\twant:    \" [++++++++++++++++++++++++++++++++=====>----------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle(),\n\t\t\t\tname:    \"t,c,r{100,40,33}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++======>-----------------------------------------------------------]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").Reverse(),\n\t\t\t\tname:    \"t,c,r{100,40,33},rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\twant:    \" [----------------------------------------------------------<=====++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").Reverse(),\n\t\t\t\tname:    \"t,c,r{100,40,33}trim,rev\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 40,\n\t\t\t\trefill:  33,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[-----------------------------------------------------------<======++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t},\n\t}\n\n\tvar tmpBuf bytes.Buffer\n\tfor tw, cases := range testSuite {\n\t\tfor _, tc := range cases {\n\t\t\tps := pState{reqWidth: tc.barWidth}\n\t\t\ts := ps.makeBarState(tc.total, tc.style.Build())\n\t\t\ts.current = tc.current\n\t\t\ts.trimSpace = tc.trim\n\t\t\ts.refill = tc.refill\n\t\t\tr, err := s.draw(s.newStatistics(tw))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"tw: %d case %q draw error: %s\", tw, tc.name, err.Error())\n\t\t\t}\n\t\t\ttmpBuf.Reset()\n\t\t\t_, err = tmpBuf.ReadFrom(r)\n\t\t\tif err != nil {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\t\t\tby := tmpBuf.Bytes()\n\t\t\tgot := string(by[:len(by)-1])\n\t\t\tif !utf8.ValidString(got) {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"termWidth:%d %q want: %q %d, got: %q %d\\n\", tw, tc.name, tc.want, utf8.RuneCountInString(tc.want), got, utf8.RuneCountInString(got))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDrawTipOnComplete(t *testing.T) {\n\t// key is termWidth\n\ttestSuite := map[int][]struct {\n\t\tstyle    BarStyleComposer\n\t\tname     string\n\t\ttotal    int64\n\t\tcurrent  int64\n\t\trefill   int64\n\t\tbarWidth int\n\t\ttrim     bool\n\t\twant     string\n\t}{\n\t\t3: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \"  \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[>]\",\n\t\t\t},\n\t\t},\n\t\t4: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=>]\",\n\t\t\t},\n\t\t},\n\t\t5: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[==>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[==>]\",\n\t\t\t},\n\t\t},\n\t\t6: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [=>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[===>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [=>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[===>]\",\n\t\t\t},\n\t\t},\n\t\t7: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [==>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[====>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [==>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[====>]\",\n\t\t\t},\n\t\t},\n\t\t8: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [===>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=====>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [===>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=====>]\",\n\t\t\t},\n\t\t},\n\t\t80: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\twant:    \" [==========================================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,59}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 59,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[============================================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle().TipOnComplete(),\n\t\t\t\tname:     \"t,c,bw{60,59,60}\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  59,\n\t\t\t\tbarWidth: 60,\n\t\t\t\twant:     \" [========================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle().TipOnComplete(),\n\t\t\t\tname:     \"t,c,bw{60,59,60}trim\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  59,\n\t\t\t\tbarWidth: 60,\n\t\t\t\ttrim:     true,\n\t\t\t\twant:     \"[========================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\twant:    \" [===========================================================================>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{60,60}trim\",\n\t\t\t\ttotal:   60,\n\t\t\t\tcurrent: 60,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=============================================================================>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle().TipOnComplete(),\n\t\t\t\tname:     \"t,c,bw{60,60,60}\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  60,\n\t\t\t\tbarWidth: 60,\n\t\t\t\twant:     \" [=========================================================>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:    BarStyle().TipOnComplete(),\n\t\t\t\tname:     \"t,c,bw{60,60,60}trim\",\n\t\t\t\ttotal:    60,\n\t\t\t\tcurrent:  60,\n\t\t\t\tbarWidth: 60,\n\t\t\t\ttrim:     true,\n\t\t\t\twant:     \"[=========================================================>]\",\n\t\t\t},\n\t\t},\n\t\t99: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [=============================================================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[===============================================================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [==============================================================================================>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[================================================================================================>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").TipOnComplete().Reverse(),\n\t\t\t\tname:    `t,c,r{100,100,99}.Tip(\"<\").TipOnComplete().Reverse()`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [<++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").TipOnComplete().Reverse(),\n\t\t\t\tname:    `t,c,r{100,100,99}.Tip(\"<\").TipOnComplete().Reverse()trim`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[<++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").TipOnComplete().Reverse(),\n\t\t\t\tname:    `t,c,r{100,100,100}.Tip(\"<\").TipOnComplete().Reverse()`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [<++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"<\").TipOnComplete().Reverse(),\n\t\t\t\tname:    `t,c,r{100,100,100}.Tip(\"<\").TipOnComplete().Reverse()trim`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[<++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++]\",\n\t\t\t},\n\t\t},\n\t\t100: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [==============================================================================================>-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[================================================================================================>-]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [===============================================================================================>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c{100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[=================================================================================================>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,99}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,99}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>]\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,100}\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\twant:    \" [+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().TipOnComplete(),\n\t\t\t\tname:    \"t,c,r{100,100,100}trim\",\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  100,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++>]\",\n\t\t\t},\n\t\t},\n\t}\n\n\tvar tmpBuf bytes.Buffer\n\tfor tw, cases := range testSuite {\n\t\tfor _, tc := range cases {\n\t\t\tps := pState{reqWidth: tc.barWidth}\n\t\t\ts := ps.makeBarState(tc.total, tc.style.Build())\n\t\t\ts.current = tc.current\n\t\t\ts.trimSpace = tc.trim\n\t\t\ts.refill = tc.refill\n\t\t\tr, err := s.draw(s.newStatistics(tw))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"tw: %d case %q draw error: %s\", tw, tc.name, err.Error())\n\t\t\t}\n\t\t\ttmpBuf.Reset()\n\t\t\t_, err = tmpBuf.ReadFrom(r)\n\t\t\tif err != nil {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\t\t\tby := tmpBuf.Bytes()\n\n\t\t\tgot := string(by[:len(by)-1])\n\t\t\tif !utf8.ValidString(got) {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"termWidth:%d %q want: %q %d, got: %q %d\\n\", tw, tc.name, tc.want, utf8.RuneCountInString(tc.want), got, utf8.RuneCountInString(got))\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestDrawDoubleWidth(t *testing.T) {\n\t// key is termWidth\n\ttestSuite := map[int][]struct {\n\t\tstyle    BarStyleComposer\n\t\tname     string\n\t\ttotal    int64\n\t\tcurrent  int64\n\t\trefill   int64\n\t\tbarWidth int\n\t\ttrim     bool\n\t\twant     string\n\t}{\n\t\t99: {\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Lbound(\"の\").Rbound(\"の\"),\n\t\t\t\tname:    `t,c{100,1}.Lbound(\"の\").Rbound(\"の\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\twant:    \" の>--------------------------------------------------------------------------------------------の \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Lbound(\"の\").Rbound(\"の\"),\n\t\t\t\tname:    `t,c{100,1}.Lbound(\"の\").Rbound(\"の\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 2,\n\t\t\t\twant:    \" の=>-------------------------------------------------------------------------------------------の \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"だ\"),\n\t\t\t\tname:    `t,c{100,1}Tip(\"だ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\twant:    \" [だ---------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"だ\"),\n\t\t\t\tname:    `t,c{100,2}Tip(\"だ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 2,\n\t\t\t\twant:    \" [だ---------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"だ\"),\n\t\t\t\tname:    `t,c{100,3}Tip(\"だ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 3,\n\t\t\t\twant:    \" [=だ--------------------------------------------------------------------------------------------] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"だ\"),\n\t\t\t\tname:    `t,c{100,99}Tip(\"だ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [============================================================================================だ-] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"だ\"),\n\t\t\t\tname:    `t,c{100,100}Tip(\"だ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [===============================================================================================] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Tip(\"だ\").TipOnComplete(),\n\t\t\t\tname:    `t,c{100,100}.Tip(\"だ\").TipOnComplete()`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [=============================================================================================だ] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").Padding(\"つ\"),\n\t\t\t\tname:    `t,c{100,1}Filler(\"の\").Tip(\"だ\").Padding(\"つ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 1,\n\t\t\t\twant:    \" [だつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつ…] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").Padding(\"つ\"),\n\t\t\t\tname:    `t,c{100,2}Filler(\"の\").Tip(\"だ\").Padding(\"つ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 2,\n\t\t\t\twant:    \" [だつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつつ…] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").Padding(\"つ\"),\n\t\t\t\tname:    `t,c{100,99}Filler(\"の\").Tip(\"だ\").Padding(\"つ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [ののののののののののののののののののののののののののののののののののののののののののののののだ…] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").Padding(\"つ\"),\n\t\t\t\tname:    `t,c{100,100}.Filler(\"の\").Tip(\"だ\").Padding(\"つ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [ののののののののののののののののののののののののののののののののののののののののののののののの…] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").Padding(\"つ\").Reverse(),\n\t\t\t\tname:    `t,c{100,100}Filler(\"の\").Tip(\"だ\").Padding(\"つ\").Reverse()`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" […ののののののののののののののののののののののののののののののののののののののののののののののの] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").TipOnComplete().Padding(\"つ\"),\n\t\t\t\tname:    `t,c{100,99}Filler(\"の\").Tip(\"だ\").TipOnComplete().Padding(\"つ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 99,\n\t\t\t\twant:    \" [ののののののののののののののののののののののののののののののののののののののののののののののだ…] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").TipOnComplete().Padding(\"つ\"),\n\t\t\t\tname:    `t,c{100,100}.Filler(\"の\").Tip(\"だ\").TipOnComplete().Padding(\"つ\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" [ののののののののののののののののののののののののののののののののののののののののののののののだ…] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Filler(\"の\").Tip(\"だ\").TipOnComplete().Padding(\"つ\").Reverse(),\n\t\t\t\tname:    `t,c{100,100}.Filler(\"の\").Tip(\"だ\").TipOnComplete().Padding(\"つ\").Reverse()`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\twant:    \" […だのののののののののののののののののののののののののののののののののののののののののののののの] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Refiller(\"の\"),\n\t\t\t\tname:    `t,c,r{100,100,99}Refiller(\"の\")`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\twant:    \" [ののののののののののののののののののののののののののののののののののののののののののののののの=] \",\n\t\t\t},\n\t\t\t{\n\t\t\t\tstyle:   BarStyle().Refiller(\"の\"),\n\t\t\t\tname:    `t,c,r{100,100,99}Refiller(\"の\")trim`,\n\t\t\t\ttotal:   100,\n\t\t\t\tcurrent: 100,\n\t\t\t\trefill:  99,\n\t\t\t\ttrim:    true,\n\t\t\t\twant:    \"[のののののののののののののののののののののののののののののののののののののののののののののののの=]\",\n\t\t\t},\n\t\t},\n\t}\n\n\tvar tmpBuf bytes.Buffer\n\tfor tw, cases := range testSuite {\n\t\tfor _, tc := range cases {\n\t\t\tps := pState{reqWidth: tc.barWidth}\n\t\t\ts := ps.makeBarState(tc.total, tc.style.Build())\n\t\t\ts.current = tc.current\n\t\t\ts.trimSpace = tc.trim\n\t\t\ts.refill = tc.refill\n\t\t\tr, err := s.draw(s.newStatistics(tw))\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"tw: %d case %q draw error: %s\", tw, tc.name, err.Error())\n\t\t\t}\n\t\t\ttmpBuf.Reset()\n\t\t\t_, err = tmpBuf.ReadFrom(r)\n\t\t\tif err != nil {\n\t\t\t\tt.FailNow()\n\t\t\t}\n\t\t\tby := tmpBuf.Bytes()\n\n\t\t\tgot := string(by[:len(by)-1])\n\t\t\tif !utf8.ValidString(got) {\n\t\t\t\tt.Fail()\n\t\t\t}\n\t\t\tif got != tc.want {\n\t\t\t\tt.Errorf(\"termWidth:%d %q want: %q %d, got: %q %d\\n\", tw, tc.name, tc.want, utf8.RuneCountInString(tc.want), got, utf8.RuneCountInString(got))\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 1.6875,
          "content": "package mpb_test\n\nimport (\n\tcrand \"crypto/rand\"\n\t\"io\"\n\t\"math/rand\"\n\t\"time\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\nfunc Example() {\n\t// initialize progress container, with custom width\n\tp := mpb.New(mpb.WithWidth(64))\n\n\ttotal := 100\n\tname := \"Single Bar:\"\n\t// create a single bar, which will inherit container's width\n\tbar := p.New(int64(total),\n\t\t// BarFillerBuilder with custom style\n\t\tmpb.BarStyle().Lbound(\"╢\").Filler(\"▌\").Tip(\"▌\").Padding(\"░\").Rbound(\"╟\"),\n\t\tmpb.PrependDecorators(\n\t\t\t// display our name with one space on the right\n\t\t\tdecor.Name(name, decor.WC{C: decor.DindentRight | decor.DextraSpace}),\n\t\t\t// replace ETA decorator with \"done\" message, OnComplete event\n\t\t\tdecor.OnComplete(decor.AverageETA(decor.ET_STYLE_GO), \"done\"),\n\t\t),\n\t\tmpb.AppendDecorators(decor.Percentage()),\n\t)\n\t// simulating some work\n\tmax := 100 * time.Millisecond\n\tfor i := 0; i < total; i++ {\n\t\ttime.Sleep(time.Duration(rand.Intn(10)+1) * max / 10)\n\t\tbar.Increment()\n\t}\n\t// wait for our bar to complete and flush\n\tp.Wait()\n}\n\nfunc ExampleBar_Completed() {\n\tp := mpb.New()\n\tbar := p.AddBar(100)\n\n\tmax := 100 * time.Millisecond\n\tfor !bar.Completed() {\n\t\ttime.Sleep(time.Duration(rand.Intn(10)+1) * max / 10)\n\t\tbar.Increment()\n\t}\n\n\tp.Wait()\n}\n\nfunc ExampleBar_ProxyReader() {\n\t// import crand \"crypto/rand\"\n\n\tvar total int64 = 1024 * 1024 * 500\n\treader := io.LimitReader(crand.Reader, total)\n\n\tp := mpb.New()\n\tbar := p.AddBar(total,\n\t\tmpb.AppendDecorators(\n\t\t\tdecor.CountersKibiByte(\"% .2f / % .2f\"),\n\t\t),\n\t)\n\n\t// create proxy reader\n\tproxyReader := bar.ProxyReader(reader)\n\tdefer proxyReader.Close()\n\n\t// and copy from reader, ignoring errors\n\t_, _ = io.Copy(io.Discard, proxyReader)\n\n\tp.Wait()\n}\n"
        },
        {
          "name": "export_test.go",
          "type": "blob",
          "size": 0.1103515625,
          "content": "package mpb\n\n// make syncWidth func public in test\nvar SyncWidth = syncWidth\n\ntype PriorityQueue = priorityQueue\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.26953125,
          "content": "module github.com/vbauerster/mpb/v8\n\nrequire (\n\tgithub.com/VividCortex/ewma v1.2.0\n\tgithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d\n\tgithub.com/mattn/go-runewidth v0.0.16\n\tgolang.org/x/sys v0.29.0\n)\n\nrequire github.com/rivo/uniseg v0.4.7 // indirect\n\ngo 1.17\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.962890625,
          "content": "github.com/VividCortex/ewma v1.2.0 h1:f58SaIzcDXrSy3kWaHNvuJgJ3Nmz59Zji6XoJR/q1ow=\ngithub.com/VividCortex/ewma v1.2.0/go.mod h1:nz4BbCtbLyFDeC9SUHbtcT5644juEuWfUAUnGx7j5l4=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d h1:licZJFw2RwpHMqeKTCYkitsPqHNxTmd4SNR5r94FGM8=\ngithub.com/acarl005/stripansi v0.0.0-20180116102854-5a71ef0e047d/go.mod h1:asat636LX7Bqt5lYEZ27JNDcqxfjdBQuJ/MM4CN/Lzo=\ngithub.com/mattn/go-runewidth v0.0.16 h1:E5ScNMtiwvlvB5paMFdw9p4kSQzbXFikJ5SQO6TULQc=\ngithub.com/mattn/go-runewidth v0.0.16/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\n"
        },
        {
          "name": "heap_manager.go",
          "type": "blob",
          "size": 3.251953125,
          "content": "package mpb\n\nimport \"container/heap\"\n\ntype heapManager chan heapRequest\n\ntype heapCmd int\n\nconst (\n\th_sync heapCmd = iota\n\th_push\n\th_iter\n\th_fix\n\th_state\n\th_end\n)\n\ntype heapRequest struct {\n\tcmd  heapCmd\n\tdata interface{}\n}\n\ntype iterData struct {\n\tdrop    <-chan struct{}\n\titer    chan<- *Bar\n\titerPop chan<- *Bar\n}\n\ntype pushData struct {\n\tbar  *Bar\n\tsync bool\n}\n\ntype fixData struct {\n\tbar      *Bar\n\tpriority int\n\tlazy     bool\n}\n\nfunc (m heapManager) run() {\n\tvar bHeap priorityQueue\n\tvar pMatrix, aMatrix map[int][]chan int\n\n\tvar len int\n\tvar sync bool\n\n\tfor req := range m {\n\t\tswitch req.cmd {\n\t\tcase h_push:\n\t\t\tdata := req.data.(pushData)\n\t\t\theap.Push(&bHeap, data.bar)\n\t\t\tsync = sync || data.sync\n\t\tcase h_sync:\n\t\t\tif sync || len != bHeap.Len() {\n\t\t\t\tpMatrix = make(map[int][]chan int)\n\t\t\t\taMatrix = make(map[int][]chan int)\n\t\t\t\tfor _, b := range bHeap {\n\t\t\t\t\ttable := b.wSyncTable()\n\t\t\t\t\tfor i, ch := range table[0] {\n\t\t\t\t\t\tpMatrix[i] = append(pMatrix[i], ch)\n\t\t\t\t\t}\n\t\t\t\t\tfor i, ch := range table[1] {\n\t\t\t\t\t\taMatrix[i] = append(aMatrix[i], ch)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsync = false\n\t\t\t\tlen = bHeap.Len()\n\t\t\t}\n\t\t\tdrop := req.data.(<-chan struct{})\n\t\t\tsyncWidth(pMatrix, drop)\n\t\t\tsyncWidth(aMatrix, drop)\n\t\tcase h_iter:\n\t\t\tdata := req.data.(iterData)\n\t\tloop: // unordered iteration\n\t\t\tfor _, b := range bHeap {\n\t\t\t\tselect {\n\t\t\t\tcase data.iter <- b:\n\t\t\t\tcase <-data.drop:\n\t\t\t\t\tdata.iterPop = nil\n\t\t\t\t\tbreak loop\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(data.iter)\n\t\t\tif data.iterPop == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\tloop_pop: // ordered iteration\n\t\t\tfor bHeap.Len() != 0 {\n\t\t\t\tbar := heap.Pop(&bHeap).(*Bar)\n\t\t\t\tselect {\n\t\t\t\tcase data.iterPop <- bar:\n\t\t\t\tcase <-data.drop:\n\t\t\t\t\theap.Push(&bHeap, bar)\n\t\t\t\t\tbreak loop_pop\n\t\t\t\t}\n\t\t\t}\n\t\t\tclose(data.iterPop)\n\t\tcase h_fix:\n\t\t\tdata := req.data.(fixData)\n\t\t\tif data.bar.index < 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tdata.bar.priority = data.priority\n\t\t\tif !data.lazy {\n\t\t\t\theap.Fix(&bHeap, data.bar.index)\n\t\t\t}\n\t\tcase h_state:\n\t\t\tch := req.data.(chan<- bool)\n\t\t\tch <- sync || len != bHeap.Len()\n\t\tcase h_end:\n\t\t\tch := req.data.(chan<- interface{})\n\t\t\tif ch != nil {\n\t\t\t\tgo func() {\n\t\t\t\t\tch <- []*Bar(bHeap)\n\t\t\t\t}()\n\t\t\t}\n\t\t\tclose(m)\n\t\t}\n\t}\n}\n\nfunc (m heapManager) sync(drop <-chan struct{}) {\n\tm <- heapRequest{cmd: h_sync, data: drop}\n}\n\nfunc (m heapManager) push(b *Bar, sync bool) {\n\tdata := pushData{b, sync}\n\treq := heapRequest{cmd: h_push, data: data}\n\tselect {\n\tcase m <- req:\n\tdefault:\n\t\tgo func() {\n\t\t\tm <- req\n\t\t}()\n\t}\n}\n\nfunc (m heapManager) iter(drop <-chan struct{}, iter, iterPop chan<- *Bar) {\n\tdata := iterData{drop, iter, iterPop}\n\tm <- heapRequest{cmd: h_iter, data: data}\n}\n\nfunc (m heapManager) fix(b *Bar, priority int, lazy bool) {\n\tdata := fixData{b, priority, lazy}\n\tm <- heapRequest{cmd: h_fix, data: data}\n}\n\nfunc (m heapManager) state(ch chan<- bool) {\n\tm <- heapRequest{cmd: h_state, data: ch}\n}\n\nfunc (m heapManager) end(ch chan<- interface{}) {\n\tm <- heapRequest{cmd: h_end, data: ch}\n}\n\nfunc syncWidth(matrix map[int][]chan int, drop <-chan struct{}) {\n\tfor _, column := range matrix {\n\t\tgo maxWidthDistributor(column, drop)\n\t}\n}\n\nfunc maxWidthDistributor(column []chan int, drop <-chan struct{}) {\n\tvar maxWidth int\n\tfor _, ch := range column {\n\t\tselect {\n\t\tcase w := <-ch:\n\t\t\tif w > maxWidth {\n\t\t\t\tmaxWidth = w\n\t\t\t}\n\t\tcase <-drop:\n\t\t\treturn\n\t\t}\n\t}\n\tfor _, ch := range column {\n\t\tch <- maxWidth\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "priority_queue.go",
          "type": "blob",
          "size": 0.6845703125,
          "content": "package mpb\n\nimport \"container/heap\"\n\nvar _ heap.Interface = (*priorityQueue)(nil)\n\ntype priorityQueue []*Bar\n\nfunc (pq priorityQueue) Len() int { return len(pq) }\n\nfunc (pq priorityQueue) Less(i, j int) bool {\n\t// greater priority pops first\n\treturn pq[i].priority > pq[j].priority\n}\n\nfunc (pq priorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n\tpq[i].index = i\n\tpq[j].index = j\n}\n\nfunc (pq *priorityQueue) Push(x interface{}) {\n\tn := len(*pq)\n\tbar := x.(*Bar)\n\tbar.index = n\n\t*pq = append(*pq, bar)\n}\n\nfunc (pq *priorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\tbar := old[n-1]\n\told[n-1] = nil // avoid memory leak\n\tbar.index = -1 // for safety\n\t*pq = old[:n-1]\n\treturn bar\n}\n"
        },
        {
          "name": "progress.go",
          "type": "blob",
          "size": 10.466796875,
          "content": "package mpb\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/vbauerster/mpb/v8/cwriter\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\nconst defaultRefreshRate = 150 * time.Millisecond\nconst defaultHmQueueLength = 128\n\n// DoneError represents use after `(*Progress).Wait()` error.\nvar DoneError = fmt.Errorf(\"%T instance can't be reused after %[1]T.Wait()\", (*Progress)(nil))\n\n// Progress represents a container that renders one or more progress bars.\ntype Progress struct {\n\tuwg          *sync.WaitGroup\n\tpwg, bwg     sync.WaitGroup\n\toperateState chan func(*pState)\n\tinterceptIO  chan func(io.Writer)\n\tdone         <-chan struct{}\n\tcancel       func()\n}\n\n// pState holds bars in its priorityQueue, it gets passed to (*Progress).serve monitor goroutine.\ntype pState struct {\n\tctx         context.Context\n\thm          heapManager\n\titerDrop    chan struct{}\n\trenderReq   chan time.Time\n\tidCount     int\n\tpopPriority int\n\n\t// following are provided/overrided by user\n\thmQueueLen       int\n\treqWidth         int\n\trefreshRate      time.Duration\n\tpopCompleted     bool\n\tautoRefresh      bool\n\tdelayRC          <-chan struct{}\n\tmanualRC         <-chan interface{}\n\tshutdownNotifier chan<- interface{}\n\tqueueBars        map[*Bar]*Bar\n\toutput           io.Writer\n\tdebugOut         io.Writer\n\tuwg              *sync.WaitGroup\n}\n\n// New creates new Progress container instance. It's not possible to\n// reuse instance after `(*Progress).Wait` method has been called.\nfunc New(options ...ContainerOption) *Progress {\n\treturn NewWithContext(context.Background(), options...)\n}\n\n// NewWithContext creates new Progress container instance with provided\n// context. It's not possible to reuse instance after `(*Progress).Wait`\n// method has been called.\nfunc NewWithContext(ctx context.Context, options ...ContainerOption) *Progress {\n\tif ctx == nil {\n\t\tctx = context.Background()\n\t}\n\tctx, cancel := context.WithCancel(ctx)\n\ts := &pState{\n\t\tctx:         ctx,\n\t\thmQueueLen:  defaultHmQueueLength,\n\t\titerDrop:    make(chan struct{}),\n\t\trenderReq:   make(chan time.Time),\n\t\tpopPriority: math.MinInt32,\n\t\trefreshRate: defaultRefreshRate,\n\t\tqueueBars:   make(map[*Bar]*Bar),\n\t\toutput:      os.Stdout,\n\t\tdebugOut:    io.Discard,\n\t}\n\n\tfor _, opt := range options {\n\t\tif opt != nil {\n\t\t\topt(s)\n\t\t}\n\t}\n\n\ts.hm = make(heapManager, s.hmQueueLen)\n\n\tp := &Progress{\n\t\tuwg:          s.uwg,\n\t\toperateState: make(chan func(*pState)),\n\t\tinterceptIO:  make(chan func(io.Writer)),\n\t\tcancel:       cancel,\n\t}\n\n\tcw := cwriter.New(s.output)\n\tif s.manualRC != nil {\n\t\tdone := make(chan struct{})\n\t\tp.done = done\n\t\ts.autoRefresh = false\n\t\tgo s.manualRefreshListener(done)\n\t} else if cw.IsTerminal() || s.autoRefresh {\n\t\tdone := make(chan struct{})\n\t\tp.done = done\n\t\ts.autoRefresh = true\n\t\tgo s.autoRefreshListener(done)\n\t} else {\n\t\tp.done = ctx.Done()\n\t\ts.autoRefresh = false\n\t}\n\n\tp.pwg.Add(1)\n\tgo p.serve(s, cw)\n\tgo s.hm.run()\n\treturn p\n}\n\n// AddBar creates a bar with default bar filler.\nfunc (p *Progress) AddBar(total int64, options ...BarOption) *Bar {\n\treturn p.New(total, BarStyle(), options...)\n}\n\n// AddSpinner creates a bar with default spinner filler.\nfunc (p *Progress) AddSpinner(total int64, options ...BarOption) *Bar {\n\treturn p.New(total, SpinnerStyle(), options...)\n}\n\n// New creates a bar by calling `Build` method on provided `BarFillerBuilder`.\nfunc (p *Progress) New(total int64, builder BarFillerBuilder, options ...BarOption) *Bar {\n\tif builder == nil {\n\t\treturn p.MustAdd(total, nil, options...)\n\t}\n\treturn p.MustAdd(total, builder.Build(), options...)\n}\n\n// MustAdd creates a bar which renders itself by provided BarFiller.\n// If `total <= 0` triggering complete event by increment methods is\n// disabled. Panics if called after `(*Progress).Wait()`.\nfunc (p *Progress) MustAdd(total int64, filler BarFiller, options ...BarOption) *Bar {\n\tbar, err := p.Add(total, filler, options...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn bar\n}\n\n// Add creates a bar which renders itself by provided BarFiller.\n// If `total <= 0` triggering complete event by increment methods\n// is disabled. If called after `(*Progress).Wait()` then\n// `(nil, DoneError)` is returned.\nfunc (p *Progress) Add(total int64, filler BarFiller, options ...BarOption) (*Bar, error) {\n\tif filler == nil {\n\t\tfiller = NopStyle().Build()\n\t} else if f, ok := filler.(BarFillerFunc); ok && f == nil {\n\t\tfiller = NopStyle().Build()\n\t}\n\tch := make(chan *Bar)\n\tselect {\n\tcase p.operateState <- func(ps *pState) {\n\t\tbs := ps.makeBarState(total, filler, options...)\n\t\tbar := newBar(ps.ctx, p, bs)\n\t\tif bs.waitBar != nil {\n\t\t\tps.queueBars[bs.waitBar] = bar\n\t\t} else {\n\t\t\tps.hm.push(bar, true)\n\t\t}\n\t\tps.idCount++\n\t\tch <- bar\n\t}:\n\t\treturn <-ch, nil\n\tcase <-p.done:\n\t\treturn nil, DoneError\n\t}\n}\n\nfunc (p *Progress) traverseBars(cb func(b *Bar) bool) {\n\tdrop, iter := make(chan struct{}), make(chan *Bar)\n\tselect {\n\tcase p.operateState <- func(s *pState) { s.hm.iter(drop, iter, nil) }:\n\t\tfor b := range iter {\n\t\t\tif !cb(b) {\n\t\t\t\tclose(drop)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase <-p.done:\n\t}\n}\n\n// UpdateBarPriority either immediately or lazy.\n// With lazy flag order is updated after the next refresh cycle.\n// If you don't care about laziness just use `(*Bar).SetPriority(int)`.\nfunc (p *Progress) UpdateBarPriority(b *Bar, priority int, lazy bool) {\n\tif b == nil {\n\t\treturn\n\t}\n\tselect {\n\tcase p.operateState <- func(s *pState) { s.hm.fix(b, priority, lazy) }:\n\tcase <-p.done:\n\t}\n}\n\n// Write is implementation of io.Writer.\n// Writing to `*Progress` will print lines above a running bar.\n// Writes aren't flushed immediately, but at next refresh cycle.\n// If called after `(*Progress).Wait()` then `(0, DoneError)`\n// is returned.\nfunc (p *Progress) Write(b []byte) (int, error) {\n\ttype result struct {\n\t\tn   int\n\t\terr error\n\t}\n\tch := make(chan result)\n\tselect {\n\tcase p.interceptIO <- func(w io.Writer) {\n\t\tn, err := w.Write(b)\n\t\tch <- result{n, err}\n\t}:\n\t\tres := <-ch\n\t\treturn res.n, res.err\n\tcase <-p.done:\n\t\treturn 0, DoneError\n\t}\n}\n\n// Wait waits for all bars to complete and finally shutdowns container. After\n// this method has been called, there is no way to reuse `*Progress` instance.\nfunc (p *Progress) Wait() {\n\tp.bwg.Wait()\n\tp.Shutdown()\n\t// wait for user wg, if any\n\tif p.uwg != nil {\n\t\tp.uwg.Wait()\n\t}\n}\n\n// Shutdown cancels any running bar immediately and then shutdowns `*Progress`\n// instance. Normally this method shouldn't be called unless you know what you\n// are doing. Proper way to shutdown is to call `(*Progress).Wait()` instead.\nfunc (p *Progress) Shutdown() {\n\tp.cancel()\n\tp.pwg.Wait()\n}\n\nfunc (p *Progress) serve(s *pState, cw *cwriter.Writer) {\n\tdefer p.pwg.Done()\n\tvar err error\n\tvar w *cwriter.Writer\n\trenderReq := s.renderReq\n\toperateState := p.operateState\n\tinterceptIO := p.interceptIO\n\n\tif s.delayRC != nil {\n\t\tw = cwriter.New(io.Discard)\n\t} else {\n\t\tw, cw = cw, nil\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-s.delayRC:\n\t\t\tw, cw = cw, nil\n\t\t\ts.delayRC = nil\n\t\tcase op := <-operateState:\n\t\t\top(s)\n\t\tcase fn := <-interceptIO:\n\t\t\tfn(w)\n\t\tcase <-renderReq:\n\t\t\terr = s.render(w)\n\t\t\tif err != nil {\n\t\t\t\t// (*pState).(autoRefreshListener|manualRefreshListener) may block\n\t\t\t\t// if not launching following short lived goroutine\n\t\t\t\tgo func() {\n\t\t\t\t\tfor {\n\t\t\t\t\t\tselect {\n\t\t\t\t\t\tcase <-s.renderReq:\n\t\t\t\t\t\tcase <-p.done:\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}()\n\t\t\t\tp.cancel() // cancel all bars\n\t\t\t\trenderReq = nil\n\t\t\t\toperateState = nil\n\t\t\t\tinterceptIO = nil\n\t\t\t}\n\t\tcase <-p.done:\n\t\t\tif err != nil {\n\t\t\t\t_, _ = fmt.Fprintln(s.debugOut, err.Error())\n\t\t\t} else if s.autoRefresh {\n\t\t\t\tupdate := make(chan bool)\n\t\t\t\tfor i := 0; i == 0 || <-update; i++ {\n\t\t\t\t\tif err := s.render(w); err != nil {\n\t\t\t\t\t\t_, _ = fmt.Fprintln(s.debugOut, err.Error())\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t\ts.hm.state(update)\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.hm.end(s.shutdownNotifier)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *pState) autoRefreshListener(done chan struct{}) {\n\tticker := time.NewTicker(s.refreshRate)\n\tdefer ticker.Stop()\n\tfor {\n\t\tselect {\n\t\tcase t := <-ticker.C:\n\t\t\ts.renderReq <- t\n\t\tcase <-s.ctx.Done():\n\t\t\tclose(done)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *pState) manualRefreshListener(done chan struct{}) {\n\tfor {\n\t\tselect {\n\t\tcase x := <-s.manualRC:\n\t\t\tif t, ok := x.(time.Time); ok {\n\t\t\t\ts.renderReq <- t\n\t\t\t} else {\n\t\t\t\ts.renderReq <- time.Now()\n\t\t\t}\n\t\tcase <-s.ctx.Done():\n\t\t\tclose(done)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (s *pState) render(cw *cwriter.Writer) (err error) {\n\titer, iterPop := make(chan *Bar), make(chan *Bar)\n\ts.hm.sync(s.iterDrop)\n\ts.hm.iter(s.iterDrop, iter, iterPop)\n\n\tvar width, height int\n\tif cw.IsTerminal() {\n\t\twidth, height, err = cw.GetTermSize()\n\t\tif err != nil {\n\t\t\tclose(s.iterDrop)\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif s.reqWidth > 0 {\n\t\t\twidth = s.reqWidth\n\t\t} else {\n\t\t\twidth = 80\n\t\t}\n\t\theight = width\n\t}\n\n\tfor b := range iter {\n\t\tgo b.render(width)\n\t}\n\n\treturn s.flush(cw, height, iterPop)\n}\n\nfunc (s *pState) flush(cw *cwriter.Writer, height int, iter <-chan *Bar) error {\n\tvar popCount int\n\tvar rows []io.Reader\n\n\tfor b := range iter {\n\t\tframe := <-b.frameCh\n\t\tif frame.err != nil {\n\t\t\tclose(s.iterDrop)\n\t\t\tb.cancel()\n\t\t\treturn frame.err // b.frameCh is buffered it's ok to return here\n\t\t}\n\t\tvar usedRows int\n\t\tfor i := len(frame.rows) - 1; i >= 0; i-- {\n\t\t\tif row := frame.rows[i]; len(rows) < height {\n\t\t\t\trows = append(rows, row)\n\t\t\t\tusedRows++\n\t\t\t} else {\n\t\t\t\t_, _ = io.Copy(io.Discard, row)\n\t\t\t}\n\t\t}\n\n\t\tswitch frame.shutdown {\n\t\tcase 1:\n\t\t\tb.cancel()\n\t\t\tif qb, ok := s.queueBars[b]; ok {\n\t\t\t\tdelete(s.queueBars, b)\n\t\t\t\tqb.priority = b.priority\n\t\t\t\ts.hm.push(qb, true)\n\t\t\t} else if s.popCompleted && !frame.noPop {\n\t\t\t\tb.priority = s.popPriority\n\t\t\t\ts.popPriority++\n\t\t\t\ts.hm.push(b, false)\n\t\t\t} else if !frame.rmOnComplete {\n\t\t\t\ts.hm.push(b, false)\n\t\t\t}\n\t\tcase 2:\n\t\t\tif s.popCompleted && !frame.noPop {\n\t\t\t\tpopCount += usedRows\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tfallthrough\n\t\tdefault:\n\t\t\ts.hm.push(b, false)\n\t\t}\n\t}\n\n\tfor i := len(rows) - 1; i >= 0; i-- {\n\t\t_, err := cw.ReadFrom(rows[i])\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn cw.Flush(len(rows) - popCount)\n}\n\nfunc (s pState) makeBarState(total int64, filler BarFiller, options ...BarOption) *bState {\n\tbs := &bState{\n\t\tid:          s.idCount,\n\t\tpriority:    s.idCount,\n\t\treqWidth:    s.reqWidth,\n\t\ttotal:       total,\n\t\tfiller:      filler,\n\t\trenderReq:   s.renderReq,\n\t\tautoRefresh: s.autoRefresh,\n\t\textender: func(_ decor.Statistics, rows ...io.Reader) ([]io.Reader, error) {\n\t\t\treturn rows, nil\n\t\t},\n\t}\n\n\tif total > 0 {\n\t\tbs.triggerComplete = true\n\t}\n\n\tfor _, opt := range options {\n\t\tif opt != nil {\n\t\t\topt(bs)\n\t\t}\n\t}\n\n\tbs.buffers[0] = bytes.NewBuffer(make([]byte, 0, 128)) // prepend\n\tbs.buffers[1] = bytes.NewBuffer(make([]byte, 0, 128)) // append\n\tbs.buffers[2] = bytes.NewBuffer(make([]byte, 0, 256)) // filler\n\n\treturn bs\n}\n"
        },
        {
          "name": "progress_test.go",
          "type": "blob",
          "size": 6.09375,
          "content": "package mpb_test\n\nimport (\n\t\"bytes\"\n\t\"container/heap\"\n\t\"context\"\n\t\"errors\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n\t\"github.com/vbauerster/mpb/v8/decor\"\n)\n\nconst (\n\ttimeout = 300 * time.Millisecond\n)\n\nfunc TestWithContext(t *testing.T) {\n\tshutdown := make(chan interface{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tp := mpb.NewWithContext(ctx,\n\t\tmpb.WithOutput(io.Discard),\n\t\tmpb.WithShutdownNotifier(shutdown),\n\t)\n\t_ = p.AddBar(0) // never complete bar\n\t_ = p.AddBar(0) // never complete bar\n\tgo func() {\n\t\ttime.Sleep(10 * time.Millisecond)\n\t\tcancel()\n\t}()\n\n\tp.Wait()\n\n\tselect {\n\tcase v := <-shutdown:\n\t\tif l := len(v.([]*mpb.Bar)); l != 2 {\n\t\t\tt.Errorf(\"Expected len of bars: %d, got: %d\", 2, l)\n\t\t}\n\tcase <-time.After(timeout):\n\t\tt.Errorf(\"Progress didn't shutdown after %v\", timeout)\n\t}\n}\n\nfunc TestShutdownsWithErrFiller(t *testing.T) {\n\tvar debug bytes.Buffer\n\tshutdown := make(chan interface{})\n\tp := mpb.New(\n\t\tmpb.WithShutdownNotifier(shutdown),\n\t\tmpb.WithOutput(io.Discard),\n\t\tmpb.WithDebugOutput(&debug),\n\t\tmpb.WithAutoRefresh(),\n\t)\n\n\tvar errReturnCount int\n\ttestError := errors.New(\"test error\")\n\tbar := p.AddBar(100,\n\t\tmpb.BarFillerMiddleware(func(base mpb.BarFiller) mpb.BarFiller {\n\t\t\treturn mpb.BarFillerFunc(func(w io.Writer, st decor.Statistics) error {\n\t\t\t\tif st.Current >= 22 {\n\t\t\t\t\terrReturnCount++\n\t\t\t\t\treturn testError\n\t\t\t\t}\n\t\t\t\treturn base.Fill(w, st)\n\t\t\t})\n\t\t}),\n\t)\n\n\tgo func() {\n\t\tfor bar.IsRunning() {\n\t\t\tbar.Increment()\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}()\n\n\tp.Wait()\n\n\tif errReturnCount != 1 {\n\t\tt.Errorf(\"Expected errReturnCount: %d, got: %d\\n\", 1, errReturnCount)\n\t}\n\n\tselect {\n\tcase v := <-shutdown:\n\t\tif l := len(v.([]*mpb.Bar)); l != 0 {\n\t\t\tt.Errorf(\"Expected len of bars: %d, got: %d\\n\", 0, l)\n\t\t}\n\t\tif err := strings.TrimSpace(debug.String()); err != testError.Error() {\n\t\t\tt.Errorf(\"Expected err: %q, got %q\\n\", testError.Error(), err)\n\t\t}\n\tcase <-time.After(timeout):\n\t\tt.Errorf(\"Progress didn't shutdown after %v\", timeout)\n\t}\n}\n\nfunc TestShutdownAfterBarAbortWithDrop(t *testing.T) {\n\tshutdown := make(chan interface{})\n\tp := mpb.New(\n\t\tmpb.WithShutdownNotifier(shutdown),\n\t\tmpb.WithOutput(io.Discard),\n\t\tmpb.WithAutoRefresh(),\n\t)\n\tb := p.AddBar(100)\n\n\tvar count int\n\tfor i := 0; !b.Aborted(); i++ {\n\t\tif i >= 10 {\n\t\t\tcount++\n\t\t\tb.Abort(true)\n\t\t} else {\n\t\t\tb.Increment()\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n\n\tp.Wait()\n\n\tif count != 1 {\n\t\tt.Errorf(\"Expected count: %d, got: %d\", 1, count)\n\t}\n\n\tselect {\n\tcase v := <-shutdown:\n\t\tif l := len(v.([]*mpb.Bar)); l != 0 {\n\t\t\tt.Errorf(\"Expected len of bars: %d, got: %d\", 0, l)\n\t\t}\n\tcase <-time.After(timeout):\n\t\tt.Errorf(\"Progress didn't shutdown after %v\", timeout)\n\t}\n}\n\nfunc TestShutdownAfterBarAbortWithNoDrop(t *testing.T) {\n\tshutdown := make(chan interface{})\n\tp := mpb.New(\n\t\tmpb.WithShutdownNotifier(shutdown),\n\t\tmpb.WithOutput(io.Discard),\n\t\tmpb.WithAutoRefresh(),\n\t)\n\tb := p.AddBar(100)\n\n\tvar count int\n\tfor i := 0; !b.Aborted(); i++ {\n\t\tif i >= 10 {\n\t\t\tcount++\n\t\t\tb.Abort(false)\n\t\t} else {\n\t\t\tb.Increment()\n\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t}\n\t}\n\n\tp.Wait()\n\n\tif count != 1 {\n\t\tt.Errorf(\"Expected count: %d, got: %d\", 1, count)\n\t}\n\n\tselect {\n\tcase v := <-shutdown:\n\t\tif l := len(v.([]*mpb.Bar)); l != 1 {\n\t\t\tt.Errorf(\"Expected len of bars: %d, got: %d\", 1, l)\n\t\t}\n\tcase <-time.After(timeout):\n\t\tt.Errorf(\"Progress didn't shutdown after %v\", timeout)\n\t}\n}\n\nfunc TestBarPristinePopOrder(t *testing.T) {\n\tshutdown := make(chan interface{})\n\tctx, cancel := context.WithCancel(context.Background())\n\tp := mpb.NewWithContext(ctx,\n\t\tmpb.WithOutput(io.Discard), // auto refresh is disabled\n\t\tmpb.WithShutdownNotifier(shutdown),\n\t)\n\ta := p.AddBar(100, mpb.BarPriority(1), mpb.BarID(1))\n\tb := p.AddBar(100, mpb.BarPriority(2), mpb.BarID(2))\n\tc := p.AddBar(100, mpb.BarPriority(3), mpb.BarID(3))\n\tpristineOrder := []*mpb.Bar{c, b, a}\n\n\tgo cancel()\n\n\tbars := (<-shutdown).([]*mpb.Bar)\n\tif l := len(bars); l != 3 {\n\t\tt.Fatalf(\"Expected len of bars: %d, got: %d\", 3, l)\n\t}\n\n\tp.Wait()\n\tpq := mpb.PriorityQueue(bars)\n\n\tfor _, b := range pristineOrder {\n\t\t// higher priority pops first\n\t\tif bar := heap.Pop(&pq).(*mpb.Bar); bar.ID() != b.ID() {\n\t\t\tt.Errorf(\"Expected bar id: %d, got bar id: %d\", b.ID(), bar.ID())\n\t\t}\n\t}\n}\n\nfunc makeUpdateBarPriorityTest(refresh, lazy bool) func(*testing.T) {\n\treturn func(t *testing.T) {\n\t\tshutdown := make(chan interface{})\n\t\trefreshCh := make(chan interface{})\n\t\tctx, cancel := context.WithCancel(context.Background())\n\t\tp := mpb.NewWithContext(ctx,\n\t\t\tmpb.WithOutput(io.Discard),\n\t\t\tmpb.WithManualRefresh(refreshCh),\n\t\t\tmpb.WithShutdownNotifier(shutdown),\n\t\t)\n\t\ta := p.AddBar(100, mpb.BarPriority(1), mpb.BarID(1))\n\t\tb := p.AddBar(100, mpb.BarPriority(2), mpb.BarID(2))\n\t\tc := p.AddBar(100, mpb.BarPriority(3), mpb.BarID(3))\n\n\t\tp.UpdateBarPriority(c, 2, lazy)\n\t\tp.UpdateBarPriority(b, 3, lazy)\n\t\tcheckOrder := []*mpb.Bar{b, c, a} // updated order\n\n\t\tif refresh {\n\t\t\trefreshCh <- time.Now()\n\t\t} else if lazy {\n\t\t\tcheckOrder = []*mpb.Bar{c, b, a} // pristine order\n\t\t}\n\n\t\tgo cancel()\n\n\t\tbars := (<-shutdown).([]*mpb.Bar)\n\t\tif l := len(bars); l != 3 {\n\t\t\tt.Fatalf(\"Expected len of bars: %d, got: %d\", 3, l)\n\t\t}\n\n\t\tp.Wait()\n\t\tpq := mpb.PriorityQueue(bars)\n\n\t\tfor _, b := range checkOrder {\n\t\t\t// higher priority pops first\n\t\t\tif bar := heap.Pop(&pq).(*mpb.Bar); bar.ID() != b.ID() {\n\t\t\t\tt.Errorf(\"Expected bar id: %d, got bar id: %d\", b.ID(), bar.ID())\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestUpdateBarPriority(t *testing.T) {\n\tmakeUpdateBarPriorityTest(false, false)(t)\n\tmakeUpdateBarPriorityTest(true, false)(t)\n}\n\nfunc TestUpdateBarPriorityLazy(t *testing.T) {\n\tmakeUpdateBarPriorityTest(false, true)(t)\n\tmakeUpdateBarPriorityTest(true, true)(t)\n}\n\nfunc TestNoOutput(t *testing.T) {\n\tvar buf bytes.Buffer\n\tp := mpb.New(mpb.WithOutput(&buf))\n\tbar := p.AddBar(100)\n\n\tgo func() {\n\t\tfor !bar.Completed() {\n\t\t\tbar.Increment()\n\t\t}\n\t}()\n\n\tp.Wait()\n\n\tif buf.Len() != 0 {\n\t\tt.Errorf(\"Expected buf.Len == 0, got: %d\\n\", buf.Len())\n\t}\n}\n\nfunc TestAddAfterDone(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\tbar := p.AddBar(100)\n\tbar.IncrBy(100)\n\n\tp.Wait()\n\n\t_, err := p.Add(100, nil)\n\n\tif err != mpb.DoneError {\n\t\tt.Errorf(\"Expected %q, got: %q\\n\", mpb.DoneError, err)\n\t}\n}\n"
        },
        {
          "name": "proxyreader.go",
          "type": "blob",
          "size": 1.3037109375,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\ntype proxyReader struct {\n\tio.ReadCloser\n\tbar *Bar\n}\n\nfunc (x proxyReader) Read(p []byte) (int, error) {\n\tn, err := x.ReadCloser.Read(p)\n\tx.bar.IncrBy(n)\n\treturn n, err\n}\n\ntype proxyWriterTo struct {\n\tproxyReader\n}\n\nfunc (x proxyWriterTo) WriteTo(w io.Writer) (int64, error) {\n\tn, err := x.ReadCloser.(io.WriterTo).WriteTo(w)\n\tx.bar.IncrInt64(n)\n\treturn n, err\n}\n\ntype ewmaProxyReader struct {\n\tio.ReadCloser\n\tbar *Bar\n}\n\nfunc (x ewmaProxyReader) Read(p []byte) (int, error) {\n\tstart := time.Now()\n\tn, err := x.ReadCloser.Read(p)\n\tx.bar.EwmaIncrBy(n, time.Since(start))\n\treturn n, err\n}\n\ntype ewmaProxyWriterTo struct {\n\tewmaProxyReader\n}\n\nfunc (x ewmaProxyWriterTo) WriteTo(w io.Writer) (int64, error) {\n\tstart := time.Now()\n\tn, err := x.ReadCloser.(io.WriterTo).WriteTo(w)\n\tx.bar.EwmaIncrInt64(n, time.Since(start))\n\treturn n, err\n}\n\nfunc newProxyReader(r io.Reader, b *Bar, hasEwma bool) io.ReadCloser {\n\trc := toReadCloser(r)\n\tif hasEwma {\n\t\tepr := ewmaProxyReader{rc, b}\n\t\tif _, ok := r.(io.WriterTo); ok {\n\t\t\treturn ewmaProxyWriterTo{epr}\n\t\t}\n\t\treturn epr\n\t}\n\tpr := proxyReader{rc, b}\n\tif _, ok := r.(io.WriterTo); ok {\n\t\treturn proxyWriterTo{pr}\n\t}\n\treturn pr\n}\n\nfunc toReadCloser(r io.Reader) io.ReadCloser {\n\tif rc, ok := r.(io.ReadCloser); ok {\n\t\treturn rc\n\t}\n\treturn io.NopCloser(r)\n}\n"
        },
        {
          "name": "proxyreader_test.go",
          "type": "blob",
          "size": 2.3876953125,
          "content": "package mpb_test\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n)\n\nconst content = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do\n\t\teiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim\n\t\tveniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\n\t\tcommodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit\n\t\tesse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat\n\t\tcupidatat non proident, sunt in culpa qui officia deserunt mollit anim id\n\t\test laborum.`\n\ntype testReader struct {\n\tio.Reader\n\tcalled bool\n}\n\nfunc (r *testReader) Read(p []byte) (n int, err error) {\n\tr.called = true\n\treturn r.Reader.Read(p)\n}\n\nfunc TestProxyReader(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\n\ttr := &testReader{strings.NewReader(content), false}\n\n\tbar := p.New(int64(len(content)), mpb.NopStyle())\n\n\tvar buf bytes.Buffer\n\t_, err := io.Copy(&buf, bar.ProxyReader(tr))\n\tif err != nil {\n\t\tt.Errorf(\"io.Copy: %s\\n\", err.Error())\n\t}\n\n\tp.Wait()\n\n\tif !tr.called {\n\t\tt.Error(\"Read not called\")\n\t}\n\n\tif got := buf.String(); got != content {\n\t\tt.Errorf(\"Expected content: %s, got: %s\\n\", content, got)\n\t}\n}\n\ntype testReadCloser struct {\n\tio.Reader\n\tcalled bool\n}\n\nfunc (r *testReadCloser) Close() error {\n\tr.called = true\n\treturn nil\n}\n\nfunc TestProxyReadCloser(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\n\ttr := &testReadCloser{strings.NewReader(content), false}\n\n\tbar := p.New(int64(len(content)), mpb.NopStyle())\n\n\trc := bar.ProxyReader(tr)\n\t_, err := io.Copy(io.Discard, rc)\n\tif err != nil {\n\t\tt.Errorf(\"io.Copy: %s\\n\", err.Error())\n\t}\n\t_ = rc.Close()\n\n\tp.Wait()\n\n\tif !tr.called {\n\t\tt.Error(\"Close not called\")\n\t}\n}\n\ntype testReaderWriterTo struct {\n\tio.Reader\n\tcalled bool\n}\n\nfunc (r *testReaderWriterTo) WriteTo(w io.Writer) (n int64, err error) {\n\tr.called = true\n\treturn r.Reader.(io.WriterTo).WriteTo(w)\n}\n\nfunc TestProxyReaderWriterTo(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\n\ttr := &testReaderWriterTo{strings.NewReader(content), false}\n\n\tbar := p.New(int64(len(content)), mpb.NopStyle())\n\n\tvar buf bytes.Buffer\n\t_, err := io.Copy(&buf, bar.ProxyReader(tr))\n\tif err != nil {\n\t\tt.Errorf(\"io.Copy: %s\\n\", err.Error())\n\t}\n\n\tp.Wait()\n\n\tif !tr.called {\n\t\tt.Error(\"WriteTo not called\")\n\t}\n\n\tif got := buf.String(); got != content {\n\t\tt.Errorf(\"Expected content: %s, got: %s\\n\", content, got)\n\t}\n}\n"
        },
        {
          "name": "proxywriter.go",
          "type": "blob",
          "size": 1.8232421875,
          "content": "package mpb\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\ntype proxyWriter struct {\n\tio.WriteCloser\n\tbar *Bar\n}\n\nfunc (x proxyWriter) Write(p []byte) (int, error) {\n\tn, err := x.WriteCloser.Write(p)\n\tx.bar.IncrBy(n)\n\treturn n, err\n}\n\ntype proxyReaderFrom struct {\n\tproxyWriter\n}\n\nfunc (x proxyReaderFrom) ReadFrom(r io.Reader) (int64, error) {\n\tn, err := x.WriteCloser.(io.ReaderFrom).ReadFrom(r)\n\tx.bar.IncrInt64(n)\n\treturn n, err\n}\n\ntype ewmaProxyWriter struct {\n\tio.WriteCloser\n\tbar *Bar\n}\n\nfunc (x ewmaProxyWriter) Write(p []byte) (int, error) {\n\tstart := time.Now()\n\tn, err := x.WriteCloser.Write(p)\n\tx.bar.EwmaIncrBy(n, time.Since(start))\n\treturn n, err\n}\n\ntype ewmaProxyReaderFrom struct {\n\tewmaProxyWriter\n}\n\nfunc (x ewmaProxyReaderFrom) ReadFrom(r io.Reader) (int64, error) {\n\tstart := time.Now()\n\tn, err := x.WriteCloser.(io.ReaderFrom).ReadFrom(r)\n\tx.bar.EwmaIncrInt64(n, time.Since(start))\n\treturn n, err\n}\n\nfunc newProxyWriter(w io.Writer, b *Bar, hasEwma bool) io.WriteCloser {\n\twc := toWriteCloser(w)\n\tif hasEwma {\n\t\tepw := ewmaProxyWriter{wc, b}\n\t\tif _, ok := w.(io.ReaderFrom); ok {\n\t\t\treturn ewmaProxyReaderFrom{epw}\n\t\t}\n\t\treturn epw\n\t}\n\tpw := proxyWriter{wc, b}\n\tif _, ok := w.(io.ReaderFrom); ok {\n\t\treturn proxyReaderFrom{pw}\n\t}\n\treturn pw\n}\n\nfunc toWriteCloser(w io.Writer) io.WriteCloser {\n\tif wc, ok := w.(io.WriteCloser); ok {\n\t\treturn wc\n\t}\n\treturn toNopWriteCloser(w)\n}\n\nfunc toNopWriteCloser(w io.Writer) io.WriteCloser {\n\tif _, ok := w.(io.ReaderFrom); ok {\n\t\treturn nopWriteCloserReaderFrom{w}\n\t}\n\treturn nopWriteCloser{w}\n}\n\ntype nopWriteCloser struct {\n\tio.Writer\n}\n\nfunc (nopWriteCloser) Close() error { return nil }\n\ntype nopWriteCloserReaderFrom struct {\n\tio.Writer\n}\n\nfunc (nopWriteCloserReaderFrom) Close() error { return nil }\n\nfunc (c nopWriteCloserReaderFrom) ReadFrom(r io.Reader) (int64, error) {\n\treturn c.Writer.(io.ReaderFrom).ReadFrom(r)\n}\n"
        },
        {
          "name": "proxywriter_test.go",
          "type": "blob",
          "size": 2.15234375,
          "content": "package mpb_test\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/vbauerster/mpb/v8\"\n)\n\ntype testWriter struct {\n\tio.Writer\n\tcalled bool\n}\n\nfunc (w *testWriter) Write(p []byte) (n int, err error) {\n\tw.called = true\n\treturn w.Writer.Write(p)\n}\n\nfunc TestProxyWriter(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\n\tvar buf bytes.Buffer\n\ttw := &testWriter{&buf, false}\n\n\tbar := p.New(int64(len(content)), mpb.NopStyle())\n\n\t_, err := io.Copy(bar.ProxyWriter(tw), strings.NewReader(content))\n\tif err != nil {\n\t\tt.Errorf(\"io.Copy: %s\\n\", err.Error())\n\t}\n\n\tp.Wait()\n\n\tif !tw.called {\n\t\tt.Error(\"Read not called\")\n\t}\n\n\tif got := buf.String(); got != content {\n\t\tt.Errorf(\"Expected content: %s, got: %s\\n\", content, got)\n\t}\n}\n\ntype testWriteCloser struct {\n\tio.Writer\n\tcalled bool\n}\n\nfunc (w *testWriteCloser) Close() error {\n\tw.called = true\n\treturn nil\n}\n\nfunc TestProxyWriteCloser(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\n\tvar buf bytes.Buffer\n\ttw := &testWriteCloser{&buf, false}\n\n\tbar := p.New(int64(len(content)), mpb.NopStyle())\n\n\twc := bar.ProxyWriter(tw)\n\t_, err := io.Copy(wc, strings.NewReader(content))\n\tif err != nil {\n\t\tt.Errorf(\"io.Copy: %s\\n\", err.Error())\n\t}\n\t_ = wc.Close()\n\n\tp.Wait()\n\n\tif !tw.called {\n\t\tt.Error(\"Close not called\")\n\t}\n}\n\ntype testWriterReadFrom struct {\n\tio.Writer\n\tcalled bool\n}\n\nfunc (w *testWriterReadFrom) ReadFrom(r io.Reader) (n int64, err error) {\n\tw.called = true\n\treturn w.Writer.(io.ReaderFrom).ReadFrom(r)\n}\n\ntype dumbReader struct {\n\tr io.Reader\n}\n\nfunc (r dumbReader) Read(p []byte) (int, error) {\n\treturn r.r.Read(p)\n}\n\nfunc TestProxyWriterReadFrom(t *testing.T) {\n\tp := mpb.New(mpb.WithOutput(io.Discard))\n\n\tvar buf bytes.Buffer\n\ttw := &testWriterReadFrom{&buf, false}\n\n\tbar := p.New(int64(len(content)), mpb.NopStyle())\n\n\t// To trigger ReadFrom, WriteTo needs to be hidden, hence a dumb wrapper\n\tdr := dumbReader{strings.NewReader(content)}\n\t_, err := io.Copy(bar.ProxyWriter(tw), dr)\n\tif err != nil {\n\t\tt.Errorf(\"io.Copy: %s\\n\", err.Error())\n\t}\n\n\tp.Wait()\n\n\tif !tw.called {\n\t\tt.Error(\"ReadFrom not called\")\n\t}\n\n\tif got := buf.String(); got != content {\n\t\tt.Errorf(\"Expected content: %s, got: %s\\n\", content, got)\n\t}\n}\n"
        }
      ]
    }
  ]
}