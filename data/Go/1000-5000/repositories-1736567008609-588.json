{
  "metadata": {
    "timestamp": 1736567008609,
    "page": 588,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "flosch/pongo2",
      "stars": 2905,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitattributes",
          "type": "blob",
          "size": 0.013671875,
          "content": "* text eol=lf\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.447265625,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n.idea\n.vscode\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n\n.project\nEBNF.txt\ntest1.tpl\npongo2_internal_test.go\ntpl-error.out\n/count.out\n/cover.out\n*.swp\n*.iml\n/cpu.out\n/mem.out\n/pongo2.test\n*.error\n/profile\n/coverage.out\n/pongo2_internal_test.ignore\n"
        },
        {
          "name": ".replit",
          "type": "blob",
          "size": 0.0234375,
          "content": "language = \"go\"\nrun = \"\""
        },
        {
          "name": ".semaphore",
          "type": "tree",
          "content": null
        },
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.2490234375,
          "content": "Main author and maintainer of pongo2:\n\n* Florian Schlachter <flori@n-schlachter.de>\n\nContributors (in no specific order):\n\n* @romanoaugusto88\n* @vitalbh\n* @blaubaer\n\nFeel free to add yourself to the list or to modify your entry if you did a contribution.\n"
        },
        {
          "name": "CHANGELOG",
          "type": "blob",
          "size": 0.3876953125,
          "content": "# Changelog\n\n## v6.0.0\n\n- Go 1.18 is now the minimum required Go version.\n- Improved block performance (#293).\n- Support for variable subscript syntax (for maps/arrays/slices), such as `mymap[\"foo\"]` or\n  `myarray[0]` (#281).\n- Backwards-incompatible change: `block.Super` won't be escaped anymore by default (#301).\n- `nil` is now supported in function calls (#277).\n\nThanks to all contributors.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.064453125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2013-2022 Florian Schlachter\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 7.7900390625,
          "content": "# [pongo](https://en.wikipedia.org/wiki/Pongo_%28genus%29)2\n\n[![PkgGoDev](https://pkg.go.dev/badge/github.com/flosch/pongo2)](https://pkg.go.dev/github.com/flosch/pongo2)\n[![Build Status](https://schlachterinf.semaphoreci.com/badges/pongo2/branches/master.svg?style=shields&key=4ecde757-d6dd-4db2-8998-c84f55253d8f)](https://schlachterinf.semaphoreci.com/projects/pongo2)\n[![Run on Repl.it](https://repl.it/badge/github/flosch/pongo2)](https://repl.it/github/flosch/pongo2)\n\npongo2 is a Django-syntax like templating-language ([official website](https://www.schlachter.tech/solutions/pongo2-template-engine/)).\n\nInstall/update using `go get` (no dependencies required by pongo2):\n\n```sh\ngo get -u github.com/flosch/pongo2/v6\n```\n\nPlease use the [issue tracker](https://github.com/flosch/pongo2/issues) if you're encountering any problems with pongo2 or if you need help with implementing tags or filters ([create a ticket!](https://github.com/flosch/pongo2/issues/new)).\n\n:question: [**Looking for a Go developer/consultant?** I'm available for hire. :man_technologist:](mailto:florian@schlachter.tech )\n\n## First impression of a template\n\n```django\n<html>\n  <head>\n    <title>Our admins and users</title>\n  </head>\n  {# This is a short example to give you a quick overview of pongo2's syntax. #}\n  {% macro user_details(user, is_admin=false) %}\n  <div class=\"user_item\">\n    <!-- Let's indicate a user's good karma -->\n    <h2 {% if (user.karma>= 40) || (user.karma > calc_avg_karma(userlist)+5) %} class=\"karma-good\"{% endif %}>\n\n      <!-- This will call user.String() automatically if available: -->\n      {{ user }}\n    </h2>\n\n    <!-- Will print a human-readable time duration like \"3 weeks ago\" -->\n    <p>This user registered {{ user.register_date|naturaltime }}.</p>\n\n    <!-- Let's allow the users to write down their biography using markdown;\n             we will only show the first 15 words as a preview -->\n    <p>The user's biography:</p>\n    <p>\n      {{ user.biography|markdown|truncatewords_html:15 }}\n      <a href=\"/user/{{ user.id }}/\">read more</a>\n    </p>\n\n    {% if is_admin %}\n    <p>This user is an admin!</p>\n    {% endif %}\n  </div>\n  {% endmacro %}\n\n  <body>\n    <!-- Make use of the macro defined above to avoid repetitive HTML code\n         since we want to use the same code for admins AND members -->\n\n    <h1>Our admins</h1>\n    {% for admin in adminlist %} {{ user_details(admin, true) }} {% endfor %}\n\n    <h1>Our members</h1>\n    {% for user in userlist %} {{ user_details(user) }} {% endfor %}\n  </body>\n</html>\n```\n\n## Features\n\n- Syntax- and feature-set-compatible with [Django 1.7](https://django.readthedocs.io/en/1.7.x/topics/templates.html)\n- [Advanced C-like expressions](https://github.com/flosch/pongo2/blob/master/template_tests/expressions.tpl).\n- [Complex function calls within expressions](https://github.com/flosch/pongo2/blob/master/template_tests/function_calls_wrapper.tpl).\n- [Easy API to create new filters and tags](http://godoc.org/github.com/flosch/pongo2#RegisterFilter) ([including parsing arguments](http://godoc.org/github.com/flosch/pongo2#Parser))\n- Additional features:\n  - Macros including importing macros from other files (see [template_tests/macro.tpl](https://github.com/flosch/pongo2/blob/master/template_tests/macro.tpl))\n  - [Template sandboxing](https://godoc.org/github.com/flosch/pongo2#TemplateSet) ([directory patterns](http://golang.org/pkg/path/filepath/#Match), banned tags/filters)\n\n## Caveats\n\n### Filters\n\n- **date** / **time**: The `date` and `time` filter are taking the Golang specific time- and date-format (not Django's one) currently. [Take a look on the format here](http://golang.org/pkg/time/#Time.Format).\n- **stringformat**: `stringformat` does **not** take Python's string format syntax as a parameter, instead it takes Go's. Essentially `{{ 3.14|stringformat:\"pi is %.2f\" }}` is `fmt.Sprintf(\"pi is %.2f\", 3.14)`.\n- **escape** / **force_escape**: Unlike Django's behaviour, the `escape`-filter is applied immediately. Therefore there is no need for a `force_escape`-filter yet.\n\n### Tags\n\n- **for**: All the `forloop` fields (like `forloop.counter`) are written with a capital letter at the beginning. For example, the `counter` can be accessed by `forloop.Counter` and the parentloop by `forloop.Parentloop`.\n- **now**: takes Go's time format (see **date** and **time**-filter).\n\n### Misc\n\n- **not in-operator**: You can check whether a map/struct/string contains a key/field/substring by using the in-operator (or the negation of it):\n  `{% if key in map %}Key is in map{% else %}Key not in map{% endif %}` or `{% if !(key in map) %}Key is NOT in map{% else %}Key is in map{% endif %}`.\n\n## Add-ons, libraries and helpers\n\n### Official\n\n- [pongo2-addons](https://github.com/flosch/pongo2-addons) - Official additional filters/tags for pongo2 (for example a **markdown**-filter). They are in their own repository because they're relying on 3rd-party-libraries.\n\n### 3rd-party\n\n- [beego-pongo2](https://github.com/oal/beego-pongo2) - A tiny little helper for using Pongo2 with [Beego](https://github.com/astaxie/beego).\n- [beego-pongo2.v2](https://github.com/ipfans/beego-pongo2.v2) - Same as `beego-pongo2`, but for pongo2 v2.\n- [macaron-pongo2](https://github.com/macaron-contrib/pongo2) - pongo2 support for [Macaron](https://github.com/Unknwon/macaron), a modular web framework.\n- [ginpongo2](https://github.com/ngerakines/ginpongo2) - middleware for [gin](github.com/gin-gonic/gin) to use pongo2 templates\n- [Build'n support for Iris' template engine](https://github.com/kataras/iris)\n- [pongo2gin](https://gitlab.com/go-box/pongo2gin) - alternative renderer for [gin](github.com/gin-gonic/gin) to use pongo2 templates\n- [pongo2-trans](https://github.com/digitalcrab/pongo2trans) - `trans`-tag implementation for internationalization\n- [tpongo2](https://github.com/tango-contrib/tpongo2) - pongo2 support for [Tango](https://github.com/lunny/tango), a micro-kernel & pluggable web framework.\n- [p2cli](https://github.com/wrouesnel/p2cli) - command line templating utility based on pongo2\n- [pongorenderer](https://github.com/siredwin/pongorenderer) - minimal pongo2 renderer for [Echo](https://github.com/labstack/echo) web framework\n- [pongo2gcloud](https://github.com/dieselburner/pongo2gcloud) - Google Cloud Storage loader for pongo2 template files\n\nPlease add your project to this list and send me a pull request when you've developed something nice for pongo2.\n\n## Who's using pongo2\n\n[I'm compiling a list of pongo2 users](https://github.com/flosch/pongo2/issues/241). Add your project or company!\n\n## API-usage examples\n\nPlease see the documentation for a full list of provided API methods.\n\n### A tiny example (template string)\n\n```go\n// Compile the template first (i. e. creating the AST)\ntpl, err := pongo2.FromString(\"Hello {{ name|capfirst }}!\")\nif err != nil {\n    panic(err)\n}\n// Now you can render the template with the given\n// pongo2.Context how often you want to.\nout, err := tpl.Execute(pongo2.Context{\"name\": \"florian\"})\nif err != nil {\n    panic(err)\n}\nfmt.Println(out) // Output: Hello Florian!\n```\n\n## Example server-usage (template file)\n\n```go\npackage main\n\nimport (\n    \"github.com/flosch/pongo2/v6\"\n    \"net/http\"\n)\n\n// Pre-compiling the templates at application startup using the\n// little Must()-helper function (Must() will panic if FromFile()\n// or FromString() will return with an error - that's it).\n// It's faster to pre-compile it anywhere at startup and only\n// execute the template later.\nvar tplExample = pongo2.Must(pongo2.FromFile(\"example.html\"))\n\nfunc examplePage(w http.ResponseWriter, r *http.Request) {\n    // Execute the template per HTTP request\n    err := tplExample.ExecuteWriter(pongo2.Context{\"query\": r.FormValue(\"query\")}, w)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n    }\n}\n\nfunc main() {\n    http.HandleFunc(\"/\", examplePage)\n    http.ListenAndServe(\":8080\", nil)\n}\n```\n"
        },
        {
          "name": "SECURITY.md",
          "type": "blob",
          "size": 0.123046875,
          "content": "# Security Policy\n\nPlease report any potential security issues to flori@n-schlachter.de with subject \"pongo2 security issue\".\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 3.400390625,
          "content": "package pongo2\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n)\n\nvar reIdentifiers = regexp.MustCompile(\"^[a-zA-Z0-9_]+$\")\n\nvar autoescape = true\n\nfunc SetAutoescape(newValue bool) {\n\tautoescape = newValue\n}\n\n// A Context type provides constants, variables, instances or functions to a template.\n//\n// pongo2 automatically provides meta-information or functions through the \"pongo2\"-key.\n// Currently, context[\"pongo2\"] contains the following keys:\n//  1. version: returns the version string\n//\n// Template examples for accessing items from your context:\n//\n//\t{{ myconstant }}\n//\t{{ myfunc(\"test\", 42) }}\n//\t{{ user.name }}\n//\t{{ pongo2.version }}\ntype Context map[string]any\n\nfunc (c Context) checkForValidIdentifiers() *Error {\n\tfor k, v := range c {\n\t\tif !reIdentifiers.MatchString(k) {\n\t\t\treturn &Error{\n\t\t\t\tSender:    \"checkForValidIdentifiers\",\n\t\t\t\tOrigError: fmt.Errorf(\"context-key '%s' (value: '%+v') is not a valid identifier\", k, v),\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n// Update updates this context with the key/value-pairs from another context.\nfunc (c Context) Update(other Context) Context {\n\tfor k, v := range other {\n\t\tc[k] = v\n\t}\n\treturn c\n}\n\n// ExecutionContext contains all data important for the current rendering state.\n//\n// If you're writing a custom tag, your tag's Execute()-function will\n// have access to the ExecutionContext. This struct stores anything\n// about the current rendering process's Context including\n// the Context provided by the user (field Public).\n// You can safely use the Private context to provide data to the user's\n// template (like a 'forloop'-information). The Shared-context is used\n// to share data between tags. All ExecutionContexts share this context.\n//\n// Please be careful when accessing the Public data.\n// PLEASE DO NOT MODIFY THE PUBLIC CONTEXT (read-only).\n//\n// To create your own execution context within tags, use the\n// NewChildExecutionContext(parent) function.\ntype ExecutionContext struct {\n\ttemplate   *Template\n\tmacroDepth int\n\n\tAutoescape bool\n\tPublic     Context\n\tPrivate    Context\n\tShared     Context\n}\n\nvar pongo2MetaContext = Context{\n\t\"version\": Version,\n}\n\nfunc newExecutionContext(tpl *Template, ctx Context) *ExecutionContext {\n\tprivateCtx := make(Context)\n\n\t// Make the pongo2-related funcs/vars available to the context\n\tprivateCtx[\"pongo2\"] = pongo2MetaContext\n\n\treturn &ExecutionContext{\n\t\ttemplate: tpl,\n\n\t\tPublic:     ctx,\n\t\tPrivate:    privateCtx,\n\t\tAutoescape: autoescape,\n\t}\n}\n\nfunc NewChildExecutionContext(parent *ExecutionContext) *ExecutionContext {\n\tnewctx := &ExecutionContext{\n\t\ttemplate: parent.template,\n\n\t\tPublic:     parent.Public,\n\t\tPrivate:    make(Context),\n\t\tAutoescape: parent.Autoescape,\n\t}\n\tnewctx.Shared = parent.Shared\n\n\t// Copy all existing private items\n\tnewctx.Private.Update(parent.Private)\n\n\treturn newctx\n}\n\nfunc (ctx *ExecutionContext) Error(msg string, token *Token) *Error {\n\treturn ctx.OrigError(errors.New(msg), token)\n}\n\nfunc (ctx *ExecutionContext) OrigError(err error, token *Token) *Error {\n\tfilename := ctx.template.name\n\tvar line, col int\n\tif token != nil {\n\t\t// No tokens available\n\t\t// TODO: Add location (from where?)\n\t\tfilename = token.Filename\n\t\tline = token.Line\n\t\tcol = token.Col\n\t}\n\treturn &Error{\n\t\tTemplate:  ctx.template,\n\t\tFilename:  filename,\n\t\tLine:      line,\n\t\tColumn:    col,\n\t\tToken:     token,\n\t\tSender:    \"execution\",\n\t\tOrigError: err,\n\t}\n}\n\nfunc (ctx *ExecutionContext) Logf(format string, args ...any) {\n\tctx.template.set.logf(format, args...)\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.74609375,
          "content": "// Package pongo2 is a Django-syntax like template-engine\n//\n// More info about pongo2: https://www.schlachter.tech/pongo2\n//\n// Complete documentation on the template language:\n// https://docs.djangoproject.com/en/dev/topics/templates/\n//\n// Make sure to read README.md in the repository as well.\n//\n// A tiny example with template strings:\n//\n//\t// Compile the template first (i. e. creating the AST)\n//\ttpl, err := pongo2.FromString(\"Hello {{ name|capfirst }}!\")\n//\tif err != nil {\n//\t    panic(err)\n//\t}\n//\t// Now you can render the template with the given\n//\t// pongo2.Context how often you want to.\n//\tout, err := tpl.Execute(pongo2.Context{\"name\": \"fred\"})\n//\tif err != nil {\n//\t    panic(err)\n//\t}\n//\tfmt.Println(out) // Output: Hello Fred!\npackage pongo2\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "error.go",
          "type": "blob",
          "size": 1.951171875,
          "content": "package pongo2\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\n// The Error type is being used to address an error during lexing, parsing or\n// execution. If you want to return an error object (for example in your own\n// tag or filter) fill this object with as much information as you have.\n// Make sure \"Sender\" is always given (if you're returning an error within\n// a filter, make Sender equals 'filter:yourfilter'; same goes for tags: 'tag:mytag').\n// It's okay if you only fill in ErrorMsg if you don't have any other details at hand.\ntype Error struct {\n\tTemplate  *Template\n\tFilename  string\n\tLine      int\n\tColumn    int\n\tToken     *Token\n\tSender    string\n\tOrigError error\n}\n\nfunc (e *Error) updateFromTokenIfNeeded(template *Template, t *Token) *Error {\n\tif e.Template == nil {\n\t\te.Template = template\n\t}\n\n\tif e.Token == nil {\n\t\te.Token = t\n\t\tif e.Line <= 0 {\n\t\t\te.Line = t.Line\n\t\t\te.Column = t.Col\n\t\t}\n\t}\n\n\treturn e\n}\n\n// Returns a nice formatted error string.\nfunc (e *Error) Error() string {\n\ts := \"[Error\"\n\tif e.Sender != \"\" {\n\t\ts += \" (where: \" + e.Sender + \")\"\n\t}\n\tif e.Filename != \"\" {\n\t\ts += \" in \" + e.Filename\n\t}\n\tif e.Line > 0 {\n\t\ts += fmt.Sprintf(\" | Line %d Col %d\", e.Line, e.Column)\n\t\tif e.Token != nil {\n\t\t\ts += fmt.Sprintf(\" near '%s'\", e.Token.Val)\n\t\t}\n\t}\n\ts += \"] \"\n\ts += e.OrigError.Error()\n\treturn s\n}\n\n// RawLine returns the affected line from the original template, if available.\nfunc (e *Error) RawLine() (line string, available bool, outErr error) {\n\tif e.Line <= 0 || e.Filename == \"<string>\" {\n\t\treturn \"\", false, nil\n\t}\n\n\tfilename := e.Filename\n\tif e.Template != nil {\n\t\tfilename = e.Template.set.resolveFilename(e.Template, e.Filename)\n\t}\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn \"\", false, err\n\t}\n\tdefer func() {\n\t\terr := file.Close()\n\t\tif err != nil && outErr == nil {\n\t\t\toutErr = err\n\t\t}\n\t}()\n\n\tscanner := bufio.NewScanner(file)\n\tl := 0\n\tfor scanner.Scan() {\n\t\tl++\n\t\tif l == e.Line {\n\t\t\treturn scanner.Text(), true, nil\n\t\t}\n\t}\n\treturn \"\", false, nil\n}\n"
        },
        {
          "name": "filters.go",
          "type": "blob",
          "size": 3.35546875,
          "content": "package pongo2\n\nimport (\n\t\"fmt\"\n)\n\n// FilterFunction is the type filter functions must fulfil\ntype FilterFunction func(in *Value, param *Value) (out *Value, err *Error)\n\nvar filters map[string]FilterFunction\n\nfunc init() {\n\tfilters = make(map[string]FilterFunction)\n}\n\n// FilterExists returns true if the given filter is already registered\nfunc FilterExists(name string) bool {\n\t_, existing := filters[name]\n\treturn existing\n}\n\n// RegisterFilter registers a new filter. If there's already a filter with the same. You usually\n// want to call this function in the filter's init() function:\n//\n//\thttp://golang.org/doc/effective_go.html#init\nfunc RegisterFilter(name string, fn FilterFunction) error {\n\tif FilterExists(name) {\n\t\treturn fmt.Errorf(\"filter with name '%s' is already registered\", name)\n\t}\n\tfilters[name] = fn\n\treturn nil\n}\n\n// ReplaceFilter replaces an already registered filter with a new implementation. Use this\n// function with caution since it allows you to change existing filter behaviour.\nfunc ReplaceFilter(name string, fn FilterFunction) error {\n\tif !FilterExists(name) {\n\t\treturn fmt.Errorf(\"filter with name '%s' does not exist (therefore cannot be overridden)\", name)\n\t}\n\tfilters[name] = fn\n\treturn nil\n}\n\n// MustApplyFilter behaves like ApplyFilter, but panics on an error.\nfunc MustApplyFilter(name string, value *Value, param *Value) *Value {\n\tval, err := ApplyFilter(name, value, param)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn val\n}\n\n// ApplyFilter applies a filter to a given value using the given parameters.\n// Returns a *pongo2.Value or an error.\nfunc ApplyFilter(name string, value *Value, param *Value) (*Value, *Error) {\n\tfn, existing := filters[name]\n\tif !existing {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"applyfilter\",\n\t\t\tOrigError: fmt.Errorf(\"filter with name '%s' not found\", name),\n\t\t}\n\t}\n\n\t// Make sure param is a *Value\n\tif param == nil {\n\t\tparam = AsValue(nil)\n\t}\n\n\treturn fn(value, param)\n}\n\ntype filterCall struct {\n\ttoken *Token\n\n\tname      string\n\tparameter IEvaluator\n\n\tfilterFunc FilterFunction\n}\n\nfunc (fc *filterCall) Execute(v *Value, ctx *ExecutionContext) (*Value, *Error) {\n\tvar param *Value\n\tvar err *Error\n\n\tif fc.parameter != nil {\n\t\tparam, err = fc.parameter.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\tparam = AsValue(nil)\n\t}\n\n\tfilteredValue, err := fc.filterFunc(v, param)\n\tif err != nil {\n\t\treturn nil, err.updateFromTokenIfNeeded(ctx.template, fc.token)\n\t}\n\treturn filteredValue, nil\n}\n\n// Filter = IDENT | IDENT \":\" FilterArg | IDENT \"|\" Filter\nfunc (p *Parser) parseFilter() (*filterCall, *Error) {\n\tidentToken := p.MatchType(TokenIdentifier)\n\n\t// Check filter ident\n\tif identToken == nil {\n\t\treturn nil, p.Error(\"Filter name must be an identifier.\", nil)\n\t}\n\n\tfilter := &filterCall{\n\t\ttoken: identToken,\n\t\tname:  identToken.Val,\n\t}\n\n\t// Get the appropriate filter function and bind it\n\tfilterFn, exists := filters[identToken.Val]\n\tif !exists {\n\t\treturn nil, p.Error(fmt.Sprintf(\"Filter '%s' does not exist.\", identToken.Val), identToken)\n\t}\n\n\tfilter.filterFunc = filterFn\n\n\t// Check for filter-argument (2 tokens needed: ':' ARG)\n\tif p.Match(TokenSymbol, \":\") != nil {\n\t\tif p.Peek(TokenSymbol, \"}}\") != nil {\n\t\t\treturn nil, p.Error(\"Filter parameter required after ':'.\", nil)\n\t\t}\n\n\t\t// Get filter argument expression\n\t\tv, err := p.parseVariableOrLiteral()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfilter.parameter = v\n\t}\n\n\treturn filter, nil\n}\n"
        },
        {
          "name": "filters_builtin.go",
          "type": "blob",
          "size": 24.337890625,
          "content": "package pongo2\n\n/* Filters that are provided through github.com/flosch/pongo2-addons:\n   ------------------------------------------------------------------\n\n   filesizeformat\n   slugify\n   timesince\n   timeuntil\n\n   Filters that won't be added:\n   ----------------------------\n\n   get_static_prefix (reason: web-framework specific)\n   pprint (reason: python-specific)\n   static (reason: web-framework specific)\n\n   Reconsideration (not implemented yet):\n   --------------------------------------\n\n   force_escape (reason: not yet needed since this is the behaviour of pongo2's escape filter)\n   safeseq (reason: same reason as `force_escape`)\n   unordered_list (python-specific; not sure whether needed or not)\n   dictsort (python-specific; maybe one could add a filter to sort a list of structs by a specific field name)\n   dictsortreversed (see dictsort)\n*/\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\t\"unicode/utf8\"\n)\n\nfunc init() {\n\trand.Seed(time.Now().Unix())\n\n\tRegisterFilter(\"escape\", filterEscape)\n\tRegisterFilter(\"e\", filterEscape) // alias of `escape`\n\tRegisterFilter(\"safe\", filterSafe)\n\tRegisterFilter(\"escapejs\", filterEscapejs)\n\n\tRegisterFilter(\"add\", filterAdd)\n\tRegisterFilter(\"addslashes\", filterAddslashes)\n\tRegisterFilter(\"capfirst\", filterCapfirst)\n\tRegisterFilter(\"center\", filterCenter)\n\tRegisterFilter(\"cut\", filterCut)\n\tRegisterFilter(\"date\", filterDate)\n\tRegisterFilter(\"default\", filterDefault)\n\tRegisterFilter(\"default_if_none\", filterDefaultIfNone)\n\tRegisterFilter(\"divisibleby\", filterDivisibleby)\n\tRegisterFilter(\"first\", filterFirst)\n\tRegisterFilter(\"floatformat\", filterFloatformat)\n\tRegisterFilter(\"get_digit\", filterGetdigit)\n\tRegisterFilter(\"iriencode\", filterIriencode)\n\tRegisterFilter(\"join\", filterJoin)\n\tRegisterFilter(\"last\", filterLast)\n\tRegisterFilter(\"length\", filterLength)\n\tRegisterFilter(\"length_is\", filterLengthis)\n\tRegisterFilter(\"linebreaks\", filterLinebreaks)\n\tRegisterFilter(\"linebreaksbr\", filterLinebreaksbr)\n\tRegisterFilter(\"linenumbers\", filterLinenumbers)\n\tRegisterFilter(\"ljust\", filterLjust)\n\tRegisterFilter(\"lower\", filterLower)\n\tRegisterFilter(\"make_list\", filterMakelist)\n\tRegisterFilter(\"phone2numeric\", filterPhone2numeric)\n\tRegisterFilter(\"pluralize\", filterPluralize)\n\tRegisterFilter(\"random\", filterRandom)\n\tRegisterFilter(\"removetags\", filterRemovetags)\n\tRegisterFilter(\"rjust\", filterRjust)\n\tRegisterFilter(\"slice\", filterSlice)\n\tRegisterFilter(\"split\", filterSplit)\n\tRegisterFilter(\"stringformat\", filterStringformat)\n\tRegisterFilter(\"striptags\", filterStriptags)\n\tRegisterFilter(\"time\", filterDate) // time uses filterDate (same golang-format)\n\tRegisterFilter(\"title\", filterTitle)\n\tRegisterFilter(\"truncatechars\", filterTruncatechars)\n\tRegisterFilter(\"truncatechars_html\", filterTruncatecharsHTML)\n\tRegisterFilter(\"truncatewords\", filterTruncatewords)\n\tRegisterFilter(\"truncatewords_html\", filterTruncatewordsHTML)\n\tRegisterFilter(\"upper\", filterUpper)\n\tRegisterFilter(\"urlencode\", filterUrlencode)\n\tRegisterFilter(\"urlize\", filterUrlize)\n\tRegisterFilter(\"urlizetrunc\", filterUrlizetrunc)\n\tRegisterFilter(\"wordcount\", filterWordcount)\n\tRegisterFilter(\"wordwrap\", filterWordwrap)\n\tRegisterFilter(\"yesno\", filterYesno)\n\n\tRegisterFilter(\"float\", filterFloat)     // pongo-specific\n\tRegisterFilter(\"integer\", filterInteger) // pongo-specific\n}\n\nfunc filterTruncatecharsHelper(s string, newLen int) string {\n\tif newLen <= 0 {\n\t\treturn s\n\t}\n\trunes := []rune(s)\n\tif newLen < len(runes) {\n\t\tif newLen >= 3 {\n\t\t\treturn fmt.Sprintf(\"%s...\", string(runes[:newLen-3]))\n\t\t}\n\t\t// Not enough space for the ellipsis\n\t\treturn string(runes[:newLen])\n\t}\n\treturn string(runes)\n}\n\nfunc filterTruncateHTMLHelper(value string, newOutput *bytes.Buffer, cond func() bool, fn func(c rune, s int, idx int) int, finalize func()) {\n\tvLen := len(value)\n\tvar tagStack []string\n\tidx := 0\n\n\tfor idx < vLen && !cond() {\n\t\tc, s := utf8.DecodeRuneInString(value[idx:])\n\t\tif c == utf8.RuneError {\n\t\t\tidx += s\n\t\t\tcontinue\n\t\t}\n\n\t\tif c == '<' {\n\t\t\tnewOutput.WriteRune(c)\n\t\t\tidx += s // consume \"<\"\n\n\t\t\tif idx+1 < vLen {\n\t\t\t\tif value[idx] == '/' {\n\t\t\t\t\t// Close tag\n\n\t\t\t\t\tnewOutput.WriteString(\"/\")\n\n\t\t\t\t\ttag := \"\"\n\t\t\t\t\tidx++ // consume \"/\"\n\n\t\t\t\t\tfor idx < vLen {\n\t\t\t\t\t\tc2, size2 := utf8.DecodeRuneInString(value[idx:])\n\t\t\t\t\t\tif c2 == utf8.RuneError {\n\t\t\t\t\t\t\tidx += size2\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// End of tag found\n\t\t\t\t\t\tif c2 == '>' {\n\t\t\t\t\t\t\tidx++ // consume \">\"\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttag += string(c2)\n\t\t\t\t\t\tidx += size2\n\t\t\t\t\t}\n\n\t\t\t\t\tif len(tagStack) > 0 {\n\t\t\t\t\t\t// Ideally, the close tag is TOP of tag stack\n\t\t\t\t\t\t// In malformed HTML, it must not be, so iterate through the stack and remove the tag\n\t\t\t\t\t\tfor i := len(tagStack) - 1; i >= 0; i-- {\n\t\t\t\t\t\t\tif tagStack[i] == tag {\n\t\t\t\t\t\t\t\t// Found the tag\n\t\t\t\t\t\t\t\ttagStack[i] = tagStack[len(tagStack)-1]\n\t\t\t\t\t\t\t\ttagStack = tagStack[:len(tagStack)-1]\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tnewOutput.WriteString(tag)\n\t\t\t\t\tnewOutput.WriteString(\">\")\n\t\t\t\t} else {\n\t\t\t\t\t// Open tag\n\n\t\t\t\t\ttag := \"\"\n\n\t\t\t\t\tparams := false\n\t\t\t\t\tfor idx < vLen {\n\t\t\t\t\t\tc2, size2 := utf8.DecodeRuneInString(value[idx:])\n\t\t\t\t\t\tif c2 == utf8.RuneError {\n\t\t\t\t\t\t\tidx += size2\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnewOutput.WriteRune(c2)\n\n\t\t\t\t\t\t// End of tag found\n\t\t\t\t\t\tif c2 == '>' {\n\t\t\t\t\t\t\tidx++ // consume \">\"\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif !params {\n\t\t\t\t\t\t\tif c2 == ' ' {\n\t\t\t\t\t\t\t\tparams = true\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttag += string(c2)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tidx += size2\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add tag to stack\n\t\t\t\t\ttagStack = append(tagStack, tag)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tidx = fn(c, s, idx)\n\t\t}\n\t}\n\n\tfinalize()\n\n\tfor i := len(tagStack) - 1; i >= 0; i-- {\n\t\ttag := tagStack[i]\n\t\t// Close everything from the regular tag stack\n\t\tnewOutput.WriteString(fmt.Sprintf(\"</%s>\", tag))\n\t}\n}\n\nfunc filterTruncatechars(in *Value, param *Value) (*Value, *Error) {\n\ts := in.String()\n\tnewLen := param.Integer()\n\treturn AsValue(filterTruncatecharsHelper(s, newLen)), nil\n}\n\nfunc filterTruncatecharsHTML(in *Value, param *Value) (*Value, *Error) {\n\tvalue := in.String()\n\tnewLen := max(param.Integer()-3, 0)\n\n\tnewOutput := bytes.NewBuffer(nil)\n\n\ttextcounter := 0\n\n\tfilterTruncateHTMLHelper(value, newOutput, func() bool {\n\t\treturn textcounter >= newLen\n\t}, func(c rune, s int, idx int) int {\n\t\ttextcounter++\n\t\tnewOutput.WriteRune(c)\n\n\t\treturn idx + s\n\t}, func() {\n\t\tif textcounter >= newLen && textcounter < len(value) {\n\t\t\tnewOutput.WriteString(\"...\")\n\t\t}\n\t})\n\n\treturn AsSafeValue(newOutput.String()), nil\n}\n\nfunc filterTruncatewords(in *Value, param *Value) (*Value, *Error) {\n\twords := strings.Fields(in.String())\n\tn := param.Integer()\n\tif n <= 0 {\n\t\treturn AsValue(\"\"), nil\n\t}\n\tnlen := min(len(words), n)\n\tout := make([]string, 0, nlen)\n\tfor i := 0; i < nlen; i++ {\n\t\tout = append(out, words[i])\n\t}\n\n\tif n < len(words) {\n\t\tout = append(out, \"...\")\n\t}\n\n\treturn AsValue(strings.Join(out, \" \")), nil\n}\n\nfunc filterTruncatewordsHTML(in *Value, param *Value) (*Value, *Error) {\n\tvalue := in.String()\n\tnewLen := max(param.Integer(), 0)\n\n\tnewOutput := bytes.NewBuffer(nil)\n\n\twordcounter := 0\n\n\tfilterTruncateHTMLHelper(value, newOutput, func() bool {\n\t\treturn wordcounter >= newLen\n\t}, func(_ rune, _ int, idx int) int {\n\t\t// Get next word\n\t\twordFound := false\n\n\t\tfor idx < len(value) {\n\t\t\tc2, size2 := utf8.DecodeRuneInString(value[idx:])\n\t\t\tif c2 == utf8.RuneError {\n\t\t\t\tidx += size2\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif c2 == '<' {\n\t\t\t\t// HTML tag start, don't consume it\n\t\t\t\treturn idx\n\t\t\t}\n\n\t\t\tnewOutput.WriteRune(c2)\n\t\t\tidx += size2\n\n\t\t\tif c2 == ' ' || c2 == '.' || c2 == ',' || c2 == ';' {\n\t\t\t\t// Word ends here, stop capturing it now\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\twordFound = true\n\t\t\t}\n\t\t}\n\n\t\tif wordFound {\n\t\t\twordcounter++\n\t\t}\n\n\t\treturn idx\n\t}, func() {\n\t\tif wordcounter >= newLen {\n\t\t\tnewOutput.WriteString(\"...\")\n\t\t}\n\t})\n\n\treturn AsSafeValue(newOutput.String()), nil\n}\n\nfunc filterEscape(in *Value, param *Value) (*Value, *Error) {\n\toutput := strings.Replace(in.String(), \"&\", \"&amp;\", -1)\n\toutput = strings.Replace(output, \">\", \"&gt;\", -1)\n\toutput = strings.Replace(output, \"<\", \"&lt;\", -1)\n\toutput = strings.Replace(output, \"\\\"\", \"&quot;\", -1)\n\toutput = strings.Replace(output, \"'\", \"&#39;\", -1)\n\treturn AsValue(output), nil\n}\n\nfunc filterSafe(in *Value, param *Value) (*Value, *Error) {\n\treturn in, nil // nothing to do here, just to keep track of the safe application\n}\n\nfunc filterEscapejs(in *Value, param *Value) (*Value, *Error) {\n\tsin := in.String()\n\n\tvar b bytes.Buffer\n\n\tidx := 0\n\tfor idx < len(sin) {\n\t\tc, size := utf8.DecodeRuneInString(sin[idx:])\n\t\tif c == utf8.RuneError {\n\t\t\tidx += size\n\t\t\tcontinue\n\t\t}\n\n\t\tif c == '\\\\' {\n\t\t\t// Escape seq?\n\t\t\tif idx+1 < len(sin) {\n\t\t\t\tswitch sin[idx+1] {\n\t\t\t\tcase 'r':\n\t\t\t\t\tb.WriteString(fmt.Sprintf(`\\u%04X`, '\\r'))\n\t\t\t\t\tidx += 2\n\t\t\t\t\tcontinue\n\t\t\t\tcase 'n':\n\t\t\t\t\tb.WriteString(fmt.Sprintf(`\\u%04X`, '\\n'))\n\t\t\t\t\tidx += 2\n\t\t\t\t\tcontinue\n\t\t\t\t\t/*case '\\'':\n\t\t\t\t\t\tb.WriteString(fmt.Sprintf(`\\u%04X`, '\\''))\n\t\t\t\t\t\tidx += 2\n\t\t\t\t\t\tcontinue\n\t\t\t\t\tcase '\"':\n\t\t\t\t\t\tb.WriteString(fmt.Sprintf(`\\u%04X`, '\"'))\n\t\t\t\t\t\tidx += 2\n\t\t\t\t\t\tcontinue*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == ' ' || c == '/' {\n\t\t\tb.WriteRune(c)\n\t\t} else {\n\t\t\tb.WriteString(fmt.Sprintf(`\\u%04X`, c))\n\t\t}\n\n\t\tidx += size\n\t}\n\n\treturn AsValue(b.String()), nil\n}\n\nfunc filterAdd(in *Value, param *Value) (*Value, *Error) {\n\tif in.IsNumber() && param.IsNumber() {\n\t\tif in.IsFloat() || param.IsFloat() {\n\t\t\treturn AsValue(in.Float() + param.Float()), nil\n\t\t}\n\t\treturn AsValue(in.Integer() + param.Integer()), nil\n\t}\n\t// If in/param is not a number, we're relying on the\n\t// Value's String() conversion and just add them both together\n\treturn AsValue(in.String() + param.String()), nil\n}\n\nfunc filterAddslashes(in *Value, param *Value) (*Value, *Error) {\n\toutput := strings.Replace(in.String(), \"\\\\\", \"\\\\\\\\\", -1)\n\toutput = strings.Replace(output, \"\\\"\", \"\\\\\\\"\", -1)\n\toutput = strings.Replace(output, \"'\", \"\\\\'\", -1)\n\treturn AsValue(output), nil\n}\n\nfunc filterCut(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(strings.Replace(in.String(), param.String(), \"\", -1)), nil\n}\n\nfunc filterLength(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(in.Len()), nil\n}\n\nfunc filterLengthis(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(in.Len() == param.Integer()), nil\n}\n\nfunc filterDefault(in *Value, param *Value) (*Value, *Error) {\n\tif !in.IsTrue() {\n\t\treturn param, nil\n\t}\n\treturn in, nil\n}\n\nfunc filterDefaultIfNone(in *Value, param *Value) (*Value, *Error) {\n\tif in.IsNil() {\n\t\treturn param, nil\n\t}\n\treturn in, nil\n}\n\nfunc filterDivisibleby(in *Value, param *Value) (*Value, *Error) {\n\tif param.Integer() == 0 {\n\t\treturn AsValue(false), nil\n\t}\n\treturn AsValue(in.Integer()%param.Integer() == 0), nil\n}\n\nfunc filterFirst(in *Value, param *Value) (*Value, *Error) {\n\tif in.CanSlice() && in.Len() > 0 {\n\t\treturn in.Index(0), nil\n\t}\n\treturn AsValue(\"\"), nil\n}\n\nconst maxFloatFormatDecimals = 1000\n\nfunc filterFloatformat(in *Value, param *Value) (*Value, *Error) {\n\tval := in.Float()\n\n\tdecimals := -1\n\tif !param.IsNil() {\n\t\t// Any argument provided?\n\t\tdecimals = param.Integer()\n\t}\n\n\t// if the argument is not a number (e. g. empty), the default\n\t// behaviour is trim the result\n\ttrim := !param.IsNumber()\n\n\tif decimals <= 0 {\n\t\t// argument is negative or zero, so we\n\t\t// want the output being trimmed\n\t\tdecimals = -decimals\n\t\ttrim = true\n\t}\n\n\tif trim {\n\t\t// Remove zeroes\n\t\tif float64(int(val)) == val {\n\t\t\treturn AsValue(in.Integer()), nil\n\t\t}\n\t}\n\n\tif decimals > maxFloatFormatDecimals {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:floatformat\",\n\t\t\tOrigError: fmt.Errorf(\"filter floatformat doesn't support more than %v decimals\", maxFloatFormatDecimals),\n\t\t}\n\t}\n\n\treturn AsValue(strconv.FormatFloat(val, 'f', decimals, 64)), nil\n}\n\nfunc filterGetdigit(in *Value, param *Value) (*Value, *Error) {\n\ti := param.Integer()\n\tl := len(in.String()) // do NOT use in.Len() here!\n\tif i <= 0 || i > l {\n\t\treturn in, nil\n\t}\n\treturn AsValue(in.String()[l-i] - 48), nil\n}\n\nconst filterIRIChars = \"/#%[]=:;$&()+,!?*@'~\"\n\nfunc filterIriencode(in *Value, param *Value) (*Value, *Error) {\n\tvar b bytes.Buffer\n\n\tsin := in.String()\n\tfor _, r := range sin {\n\t\tif strings.ContainsRune(filterIRIChars, r) {\n\t\t\tb.WriteRune(r)\n\t\t} else {\n\t\t\tb.WriteString(url.QueryEscape(string(r)))\n\t\t}\n\t}\n\n\treturn AsValue(b.String()), nil\n}\n\nfunc filterJoin(in *Value, param *Value) (*Value, *Error) {\n\tif !in.CanSlice() {\n\t\treturn in, nil\n\t}\n\tsep := param.String()\n\tif sep == \"\" {\n\t\t// An empty string separator returns the input string.\n\t\treturn AsValue(in.String()), nil\n\t}\n\n\tsl := make([]string, 0, in.Len())\n\n\t// This is an optimization for very long strings. Index() splits `in` into runes with each\n\t// function invocation which hurts performance. Hence we're doing it just once (with ranging\n\t// over the string) and speeding things up.\n\tif in.getResolvedValue().Kind() == reflect.String {\n\t\tfor _, i := range in.String() {\n\t\t\tsl = append(sl, string(i))\n\t\t}\n\t} else {\n\t\tfor i := 0; i < in.Len(); i++ {\n\t\t\tsl = append(sl, in.Index(i).String())\n\t\t}\n\t}\n\n\treturn AsValue(strings.Join(sl, sep)), nil\n}\n\nfunc filterLast(in *Value, param *Value) (*Value, *Error) {\n\tif in.CanSlice() && in.Len() > 0 {\n\t\treturn in.Index(in.Len() - 1), nil\n\t}\n\treturn AsValue(\"\"), nil\n}\n\nfunc filterUpper(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(strings.ToUpper(in.String())), nil\n}\n\nfunc filterLower(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(strings.ToLower(in.String())), nil\n}\n\nfunc filterMakelist(in *Value, param *Value) (*Value, *Error) {\n\ts := in.String()\n\tresult := make([]string, 0, len(s))\n\tfor _, c := range s {\n\t\tresult = append(result, string(c))\n\t}\n\treturn AsValue(result), nil\n}\n\nfunc filterCapfirst(in *Value, param *Value) (*Value, *Error) {\n\tif in.Len() <= 0 {\n\t\treturn AsValue(\"\"), nil\n\t}\n\tt := in.String()\n\tr, size := utf8.DecodeRuneInString(t)\n\treturn AsValue(strings.ToUpper(string(r)) + t[size:]), nil\n}\n\nconst maxCharPadding = 10000\n\nfunc filterCenter(in *Value, param *Value) (*Value, *Error) {\n\twidth := param.Integer()\n\tslen := in.Len()\n\tif width <= slen {\n\t\treturn in, nil\n\t}\n\n\tspaces := width - slen\n\n\tif spaces > maxCharPadding {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:center\",\n\t\t\tOrigError: fmt.Errorf(\"filter center doesn't support more than %v padding chars\", maxCharPadding),\n\t\t}\n\t}\n\n\tleft := spaces/2 + spaces%2\n\tright := spaces / 2\n\n\treturn AsValue(fmt.Sprintf(\"%s%s%s\", strings.Repeat(\" \", left),\n\t\tin.String(), strings.Repeat(\" \", right))), nil\n}\n\nfunc filterDate(in *Value, param *Value) (*Value, *Error) {\n\tt, isTime := in.Interface().(time.Time)\n\tif !isTime {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:date\",\n\t\t\tOrigError: errors.New(\"filter input argument must be of type 'time.Time'\"),\n\t\t}\n\t}\n\treturn AsValue(t.Format(param.String())), nil\n}\n\nfunc filterFloat(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(in.Float()), nil\n}\n\nfunc filterInteger(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(in.Integer()), nil\n}\n\nfunc filterLinebreaks(in *Value, param *Value) (*Value, *Error) {\n\tif in.Len() == 0 {\n\t\treturn in, nil\n\t}\n\n\tvar b bytes.Buffer\n\n\t// Newline = <br />\n\t// Double newline = <p>...</p>\n\tlines := strings.Split(in.String(), \"\\n\")\n\tlenlines := len(lines)\n\n\topened := false\n\n\tfor idx, line := range lines {\n\n\t\tif !opened {\n\t\t\tb.WriteString(\"<p>\")\n\t\t\topened = true\n\t\t}\n\n\t\tb.WriteString(line)\n\n\t\tif idx < lenlines-1 && strings.TrimSpace(lines[idx]) != \"\" {\n\t\t\t// We've not reached the end\n\t\t\tif strings.TrimSpace(lines[idx+1]) == \"\" {\n\t\t\t\t// Next line is empty\n\t\t\t\tif opened {\n\t\t\t\t\tb.WriteString(\"</p>\")\n\t\t\t\t\topened = false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tb.WriteString(\"<br />\")\n\t\t\t}\n\t\t}\n\t}\n\n\tif opened {\n\t\tb.WriteString(\"</p>\")\n\t}\n\n\treturn AsValue(b.String()), nil\n}\n\nfunc filterSplit(in *Value, param *Value) (*Value, *Error) {\n\tchunks := strings.Split(in.String(), param.String())\n\n\treturn AsValue(chunks), nil\n}\n\nfunc filterLinebreaksbr(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(strings.Replace(in.String(), \"\\n\", \"<br />\", -1)), nil\n}\n\nfunc filterLinenumbers(in *Value, param *Value) (*Value, *Error) {\n\tlines := strings.Split(in.String(), \"\\n\")\n\toutput := make([]string, 0, len(lines))\n\tfor idx, line := range lines {\n\t\toutput = append(output, fmt.Sprintf(\"%d. %s\", idx+1, line))\n\t}\n\treturn AsValue(strings.Join(output, \"\\n\")), nil\n}\n\nfunc filterLjust(in *Value, param *Value) (*Value, *Error) {\n\ttimes := param.Integer() - in.Len()\n\tif times < 0 {\n\t\ttimes = 0\n\t}\n\tif times > maxCharPadding {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:ljust\",\n\t\t\tOrigError: fmt.Errorf(\"ljust doesn't support more padding than %c chars\", maxCharPadding),\n\t\t}\n\t}\n\treturn AsValue(fmt.Sprintf(\"%s%s\", in.String(), strings.Repeat(\" \", times))), nil\n}\n\nfunc filterUrlencode(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(url.QueryEscape(in.String())), nil\n}\n\n// TODO: This regexp could do some work\nvar (\n\tfilterUrlizeURLRegexp   = regexp.MustCompile(`((((http|https)://)|www\\.|((^|[ ])[0-9A-Za-z_\\-]+(\\.com|\\.net|\\.org|\\.info|\\.biz|\\.de))))(?U:.*)([ ]+|$)`)\n\tfilterUrlizeEmailRegexp = regexp.MustCompile(`(\\w+@\\w+\\.\\w{2,4})`)\n)\n\nfunc filterUrlizeHelper(input string, autoescape bool, trunc int) (string, error) {\n\tvar soutErr error\n\tsout := filterUrlizeURLRegexp.ReplaceAllStringFunc(input, func(raw_url string) string {\n\t\tvar prefix string\n\t\tvar suffix string\n\t\tif strings.HasPrefix(raw_url, \" \") {\n\t\t\tprefix = \" \"\n\t\t}\n\t\tif strings.HasSuffix(raw_url, \" \") {\n\t\t\tsuffix = \" \"\n\t\t}\n\n\t\traw_url = strings.TrimSpace(raw_url)\n\n\t\tt, err := ApplyFilter(\"iriencode\", AsValue(raw_url), nil)\n\t\tif err != nil {\n\t\t\tsoutErr = err\n\t\t\treturn \"\"\n\t\t}\n\t\turl := t.String()\n\n\t\tif !strings.HasPrefix(url, \"http\") {\n\t\t\turl = fmt.Sprintf(\"http://%s\", url)\n\t\t}\n\n\t\ttitle := raw_url\n\n\t\tif trunc > 3 && len(title) > trunc {\n\t\t\ttitle = fmt.Sprintf(\"%s...\", title[:trunc-3])\n\t\t}\n\n\t\tif autoescape {\n\t\t\tt, err := ApplyFilter(\"escape\", AsValue(title), nil)\n\t\t\tif err != nil {\n\t\t\t\tsoutErr = err\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\ttitle = t.String()\n\t\t}\n\n\t\treturn fmt.Sprintf(`%s<a href=\"%s\" rel=\"nofollow\">%s</a>%s`, prefix, url, title, suffix)\n\t})\n\tif soutErr != nil {\n\t\treturn \"\", soutErr\n\t}\n\n\tsout = filterUrlizeEmailRegexp.ReplaceAllStringFunc(sout, func(mail string) string {\n\t\ttitle := mail\n\n\t\tif trunc > 3 && len(title) > trunc {\n\t\t\ttitle = fmt.Sprintf(\"%s...\", title[:trunc-3])\n\t\t}\n\n\t\treturn fmt.Sprintf(`<a href=\"mailto:%s\">%s</a>`, mail, title)\n\t})\n\n\treturn sout, nil\n}\n\nfunc filterUrlize(in *Value, param *Value) (*Value, *Error) {\n\tautoescape := true\n\tif param.IsBool() {\n\t\tautoescape = param.Bool()\n\t}\n\n\ts, err := filterUrlizeHelper(in.String(), autoescape, -1)\n\tif err != nil {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:urlize\",\n\t\t\tOrigError: err,\n\t\t}\n\t}\n\n\treturn AsValue(s), nil\n}\n\nfunc filterUrlizetrunc(in *Value, param *Value) (*Value, *Error) {\n\ts, err := filterUrlizeHelper(in.String(), true, param.Integer())\n\tif err != nil {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:urlizetrunc\",\n\t\t\tOrigError: err,\n\t\t}\n\t}\n\treturn AsValue(s), nil\n}\n\nfunc filterStringformat(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(fmt.Sprintf(param.String(), in.Interface())), nil\n}\n\nvar reStriptags = regexp.MustCompile(\"<[^>]*?>\")\n\nfunc filterStriptags(in *Value, param *Value) (*Value, *Error) {\n\ts := in.String()\n\n\t// Strip all tags\n\ts = reStriptags.ReplaceAllString(s, \"\")\n\n\treturn AsValue(strings.TrimSpace(s)), nil\n}\n\n// https://en.wikipedia.org/wiki/Phoneword\nvar filterPhone2numericMap = map[string]string{\n\t\"a\": \"2\", \"b\": \"2\", \"c\": \"2\", \"d\": \"3\", \"e\": \"3\", \"f\": \"3\", \"g\": \"4\", \"h\": \"4\", \"i\": \"4\", \"j\": \"5\", \"k\": \"5\",\n\t\"l\": \"5\", \"m\": \"6\", \"n\": \"6\", \"o\": \"6\", \"p\": \"7\", \"q\": \"7\", \"r\": \"7\", \"s\": \"7\", \"t\": \"8\", \"u\": \"8\", \"v\": \"8\",\n\t\"w\": \"9\", \"x\": \"9\", \"y\": \"9\", \"z\": \"9\",\n}\n\nfunc filterPhone2numeric(in *Value, param *Value) (*Value, *Error) {\n\tsin := in.String()\n\tfor k, v := range filterPhone2numericMap {\n\t\tsin = strings.Replace(sin, k, v, -1)\n\t\tsin = strings.Replace(sin, strings.ToUpper(k), v, -1)\n\t}\n\treturn AsValue(sin), nil\n}\n\nfunc filterPluralize(in *Value, param *Value) (*Value, *Error) {\n\tif in.IsNumber() {\n\t\t// Works only on numbers\n\t\tif param.Len() > 0 {\n\t\t\tendings := strings.Split(param.String(), \",\")\n\t\t\tif len(endings) > 2 {\n\t\t\t\treturn nil, &Error{\n\t\t\t\t\tSender:    \"filter:pluralize\",\n\t\t\t\t\tOrigError: errors.New(\"you cannot pass more than 2 arguments to filter 'pluralize'\"),\n\t\t\t\t}\n\t\t\t}\n\t\t\tif len(endings) == 1 {\n\t\t\t\t// 1 argument\n\t\t\t\tif in.Integer() != 1 {\n\t\t\t\t\treturn AsValue(endings[0]), nil\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif in.Integer() != 1 {\n\t\t\t\t\t// 2 arguments\n\t\t\t\t\treturn AsValue(endings[1]), nil\n\t\t\t\t}\n\t\t\t\treturn AsValue(endings[0]), nil\n\t\t\t}\n\t\t} else {\n\t\t\tif in.Integer() != 1 {\n\t\t\t\t// return default 's'\n\t\t\t\treturn AsValue(\"s\"), nil\n\t\t\t}\n\t\t}\n\n\t\treturn AsValue(\"\"), nil\n\t}\n\treturn nil, &Error{\n\t\tSender:    \"filter:pluralize\",\n\t\tOrigError: errors.New(\"filter 'pluralize' does only work on numbers\"),\n\t}\n}\n\nfunc filterRandom(in *Value, param *Value) (*Value, *Error) {\n\tif !in.CanSlice() || in.Len() <= 0 {\n\t\treturn in, nil\n\t}\n\ti := rand.Intn(in.Len())\n\treturn in.Index(i), nil\n}\n\nvar reTag = regexp.MustCompile(`^[a-zA-Z]$`)\n\nfunc filterRemovetags(in *Value, param *Value) (*Value, *Error) {\n\ts := in.String()\n\ttags := strings.Split(param.String(), \",\")\n\n\t// Strip only specific tags\n\tfor _, tag := range tags {\n\t\tif !reTag.MatchString(tag) {\n\t\t\treturn nil, &Error{\n\t\t\t\tSender:    \"filter:removetags\",\n\t\t\t\tOrigError: fmt.Errorf(\"invalid tag '%s'\", tag),\n\t\t\t}\n\t\t}\n\n\t\tre, err := regexp.Compile(fmt.Sprintf(\"</?%s/?>\", tag))\n\t\tif err != nil {\n\t\t\treturn nil, &Error{\n\t\t\t\tSender:    \"filter:removetags\",\n\t\t\t\tOrigError: fmt.Errorf(\"removetags-filter regexp error with tag '%s': %v\", tag, err),\n\t\t\t}\n\t\t}\n\t\ts = re.ReplaceAllString(s, \"\")\n\t}\n\n\treturn AsValue(strings.TrimSpace(s)), nil\n}\n\nfunc filterRjust(in *Value, param *Value) (*Value, *Error) {\n\tpadding := param.Integer()\n\tif padding > maxCharPadding {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:rjust\",\n\t\t\tOrigError: fmt.Errorf(\"rjust doesn't support more padding than %c chars\", maxCharPadding),\n\t\t}\n\t}\n\treturn AsValue(fmt.Sprintf(fmt.Sprintf(\"%%%ds\", padding), in.String())), nil\n}\n\nfunc filterSlice(in *Value, param *Value) (*Value, *Error) {\n\tcomp := strings.Split(param.String(), \":\")\n\tif len(comp) != 2 {\n\t\treturn nil, &Error{\n\t\t\tSender:    \"filter:slice\",\n\t\t\tOrigError: errors.New(\"Slice string must have the format 'from:to' [from/to can be omitted, but the ':' is required]\"),\n\t\t}\n\t}\n\n\tif !in.CanSlice() {\n\t\treturn in, nil\n\t}\n\n\t// start with [x:len]\n\tfrom := AsValue(comp[0]).Integer()\n\tto := in.Len()\n\n\t// handle negative x\n\tif from < 0 {\n\t\tfrom = max(in.Len()+from, 0)\n\t}\n\n\t// handle x over bounds\n\tif from > to {\n\t\tfrom = to\n\t}\n\n\tvto := AsValue(comp[1]).Integer()\n\t// handle missing y\n\tif strings.TrimSpace(comp[1]) == \"\" {\n\t\tvto = in.Len()\n\t}\n\n\t// handle negative y\n\tif vto < 0 {\n\t\tvto = max(in.Len()+vto, 0)\n\t}\n\n\t// handle y < x\n\tif vto < from {\n\t\tvto = from\n\t}\n\n\t// y is within bounds, return the [x, y] slice\n\tif vto >= from && vto <= in.Len() {\n\t\tto = vto\n\t} // otherwise, the slice remains [x, len]\n\n\treturn in.Slice(from, to), nil\n}\n\nfunc filterTitle(in *Value, param *Value) (*Value, *Error) {\n\tif !in.IsString() {\n\t\treturn AsValue(\"\"), nil\n\t}\n\treturn AsValue(strings.Title(strings.ToLower(in.String()))), nil\n}\n\nfunc filterWordcount(in *Value, param *Value) (*Value, *Error) {\n\treturn AsValue(len(strings.Fields(in.String()))), nil\n}\n\nfunc filterWordwrap(in *Value, param *Value) (*Value, *Error) {\n\twords := strings.Fields(in.String())\n\twordsLen := len(words)\n\twrapAt := param.Integer()\n\tif wrapAt <= 0 {\n\t\treturn in, nil\n\t}\n\n\tlinecount := wordsLen / wrapAt\n\tif wordsLen%wrapAt > 0 {\n\t\tlinecount++\n\t}\n\tlines := make([]string, 0, linecount)\n\tfor i := 0; i < linecount; i++ {\n\t\tlines = append(lines, strings.Join(words[wrapAt*i:min(wrapAt*(i+1), wordsLen)], \" \"))\n\t}\n\treturn AsValue(strings.Join(lines, \"\\n\")), nil\n}\n\nfunc filterYesno(in *Value, param *Value) (*Value, *Error) {\n\tchoices := map[int]string{\n\t\t0: \"yes\",\n\t\t1: \"no\",\n\t\t2: \"maybe\",\n\t}\n\tparamString := param.String()\n\tcustomChoices := strings.Split(paramString, \",\")\n\tif len(paramString) > 0 {\n\t\tif len(customChoices) > 3 {\n\t\t\treturn nil, &Error{\n\t\t\t\tSender:    \"filter:yesno\",\n\t\t\t\tOrigError: fmt.Errorf(\"you cannot pass more than 3 options to the 'yesno'-filter (got: '%s')\", paramString),\n\t\t\t}\n\t\t}\n\t\tif len(customChoices) < 2 {\n\t\t\treturn nil, &Error{\n\t\t\t\tSender:    \"filter:yesno\",\n\t\t\t\tOrigError: fmt.Errorf(\"you must either pass no or at least 2 arguments to the 'yesno'-filter (got: '%s')\", paramString),\n\t\t\t}\n\t\t}\n\n\t\t// Map to the options now\n\t\tchoices[0] = customChoices[0]\n\t\tchoices[1] = customChoices[1]\n\t\tif len(customChoices) == 3 {\n\t\t\tchoices[2] = customChoices[2]\n\t\t}\n\t}\n\n\t// maybe\n\tif in.IsNil() {\n\t\treturn AsValue(choices[2]), nil\n\t}\n\n\t// yes\n\tif in.IsTrue() {\n\t\treturn AsValue(choices[0]), nil\n\t}\n\n\t// no\n\treturn AsValue(choices[1]), nil\n}\n"
        },
        {
          "name": "filters_builtin_test.go",
          "type": "blob",
          "size": 0.9228515625,
          "content": "package pongo2\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"path/filepath\"\n\t\"testing\"\n)\n\ntype DummyLoader struct{}\n\nfunc (l *DummyLoader) Abs(base, name string) string {\n\treturn filepath.Join(filepath.Dir(base), name)\n}\n\nfunc (l *DummyLoader) Get(path string) (io.Reader, error) {\n\treturn nil, errors.New(\"dummy not found\")\n}\n\nfunc FuzzBuiltinFilters(f *testing.F) {\n\tf.Add(\"foobar\", \"123\")\n\tf.Add(\"foobar\", `123,456`)\n\tf.Add(\"foobar\", `123,456,\"789\"`)\n\tf.Add(\"foobar\", `\"test\",\"test\"`)\n\tf.Add(\"foobar\", `123,\"test\"`)\n\tf.Add(\"foobar\", \"\")\n\tf.Add(\"123\", \"foobar\")\n\n\tf.Fuzz(func(t *testing.T, value, filterArg string) {\n\t\tts := NewSet(\"fuzz-test\", &DummyLoader{})\n\t\tfor name := range filters {\n\t\t\ttpl, err := ts.FromString(fmt.Sprintf(\"{{ %v|%v:%v }}\", value, name, filterArg))\n\t\t\tif tpl != nil && err != nil {\n\t\t\t\tt.Errorf(\"filter=%q value=%q, filterArg=%q, err=%v\", name, value, filterArg, err)\n\t\t\t}\n\t\t\tif err == nil {\n\t\t\t\ttpl.Execute(nil)\n\t\t\t}\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.04296875,
          "content": "module github.com/flosch/pongo2/v6\n\ngo 1.18\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0,
          "content": ""
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 0.1396484375,
          "content": "package pongo2\n\nfunc max(a, b int) int {\n\tif a > b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n"
        },
        {
          "name": "lexer.go",
          "type": "blob",
          "size": 8.4345703125,
          "content": "package pongo2\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode/utf8\"\n)\n\nconst (\n\tTokenError = iota\n\tEOF\n\n\tTokenHTML\n\n\tTokenKeyword\n\tTokenIdentifier\n\tTokenString\n\tTokenNumber\n\tTokenSymbol\n\tTokenNil\n)\n\nvar (\n\ttokenSpaceChars                = \" \\n\\r\\t\"\n\ttokenIdentifierChars           = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_\"\n\ttokenIdentifierCharsWithDigits = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789\"\n\ttokenDigits                    = \"0123456789\"\n\n\t// Available symbols in pongo2 (within filters/tag)\n\tTokenSymbols = []string{\n\t\t// 3-Char symbols\n\t\t\"{{-\", \"-}}\", \"{%-\", \"-%}\",\n\n\t\t// 2-Char symbols\n\t\t\"==\", \">=\", \"<=\", \"&&\", \"||\", \"{{\", \"}}\", \"{%\", \"%}\", \"!=\", \"<>\",\n\n\t\t// 1-Char symbol\n\t\t\"(\", \")\", \"+\", \"-\", \"*\", \"<\", \">\", \"/\", \"^\", \",\", \".\", \"!\", \"|\", \":\", \"=\", \"%\", \"[\", \"]\",\n\t}\n\n\t// Available keywords in pongo2\n\tTokenKeywords = []string{\"in\", \"and\", \"or\", \"not\", \"true\", \"false\", \"as\", \"export\"}\n)\n\ntype (\n\tTokenType int\n\tToken     struct {\n\t\tFilename        string\n\t\tTyp             TokenType\n\t\tVal             string\n\t\tLine            int\n\t\tCol             int\n\t\tTrimWhitespaces bool\n\t}\n)\n\ntype (\n\tlexerStateFn func() lexerStateFn\n\tlexer        struct {\n\t\tname      string\n\t\tinput     string\n\t\tstart     int // start pos of the item\n\t\tpos       int // current pos\n\t\twidth     int // width of last rune\n\t\ttokens    []*Token\n\t\terrored   bool\n\t\tstartline int\n\t\tstartcol  int\n\t\tline      int\n\t\tcol       int\n\n\t\tinVerbatim   bool\n\t\tverbatimName string\n\t}\n)\n\nfunc (t *Token) String() string {\n\tval := t.Val\n\tif len(val) > 1000 {\n\t\tval = fmt.Sprintf(\"%s...%s\", val[:10], val[len(val)-5:])\n\t}\n\n\ttyp := \"\"\n\tswitch t.Typ {\n\tcase TokenHTML:\n\t\ttyp = \"HTML\"\n\tcase TokenError:\n\t\ttyp = \"Error\"\n\tcase TokenIdentifier:\n\t\ttyp = \"Identifier\"\n\tcase TokenKeyword:\n\t\ttyp = \"Keyword\"\n\tcase TokenNumber:\n\t\ttyp = \"Number\"\n\tcase TokenString:\n\t\ttyp = \"String\"\n\tcase TokenSymbol:\n\t\ttyp = \"Symbol\"\n\tcase TokenNil:\n\t\ttyp = \"Nil\"\n\tdefault:\n\t\ttyp = \"Unknown\"\n\t}\n\n\treturn fmt.Sprintf(\"<Token Typ=%s (%d) Val='%s' Line=%d Col=%d, WT=%t>\",\n\t\ttyp, t.Typ, val, t.Line, t.Col, t.TrimWhitespaces)\n}\n\nfunc lex(name string, input string) ([]*Token, *Error) {\n\tl := &lexer{\n\t\tname:      name,\n\t\tinput:     input,\n\t\ttokens:    make([]*Token, 0, 100),\n\t\tline:      1,\n\t\tcol:       1,\n\t\tstartline: 1,\n\t\tstartcol:  1,\n\t}\n\tl.run()\n\tif l.errored {\n\t\terrtoken := l.tokens[len(l.tokens)-1]\n\t\treturn nil, &Error{\n\t\t\tFilename:  name,\n\t\t\tLine:      errtoken.Line,\n\t\t\tColumn:    errtoken.Col,\n\t\t\tSender:    \"lexer\",\n\t\t\tOrigError: errors.New(errtoken.Val),\n\t\t}\n\t}\n\treturn l.tokens, nil\n}\n\nfunc (l *lexer) value() string {\n\treturn l.input[l.start:l.pos]\n}\n\nfunc (l *lexer) length() int {\n\treturn l.pos - l.start\n}\n\nfunc (l *lexer) emit(t TokenType) {\n\ttok := &Token{\n\t\tFilename: l.name,\n\t\tTyp:      t,\n\t\tVal:      l.value(),\n\t\tLine:     l.startline,\n\t\tCol:      l.startcol,\n\t}\n\n\tif t == TokenString {\n\t\t// Escape sequence \\\" in strings\n\t\ttok.Val = strings.Replace(tok.Val, `\\\"`, `\"`, -1)\n\t\ttok.Val = strings.Replace(tok.Val, `\\\\`, `\\`, -1)\n\t}\n\n\tif t == TokenSymbol && len(tok.Val) == 3 && (strings.HasSuffix(tok.Val, \"-\") || strings.HasPrefix(tok.Val, \"-\")) {\n\t\ttok.TrimWhitespaces = true\n\t\ttok.Val = strings.Replace(tok.Val, \"-\", \"\", -1)\n\t}\n\n\tl.tokens = append(l.tokens, tok)\n\tl.start = l.pos\n\tl.startline = l.line\n\tl.startcol = l.col\n}\n\nfunc (l *lexer) next() rune {\n\tif l.pos >= len(l.input) {\n\t\tl.width = 0\n\t\treturn EOF\n\t}\n\tr, w := utf8.DecodeRuneInString(l.input[l.pos:])\n\tl.width = w\n\tl.pos += l.width\n\tl.col += l.width\n\treturn r\n}\n\nfunc (l *lexer) backup() {\n\tl.pos -= l.width\n\tl.col -= l.width\n}\n\nfunc (l *lexer) peek() rune {\n\tr := l.next()\n\tl.backup()\n\treturn r\n}\n\nfunc (l *lexer) ignore() {\n\tl.start = l.pos\n\tl.startline = l.line\n\tl.startcol = l.col\n}\n\nfunc (l *lexer) accept(what string) bool {\n\tif strings.ContainsRune(what, l.next()) {\n\t\treturn true\n\t}\n\tl.backup()\n\treturn false\n}\n\nfunc (l *lexer) acceptRun(what string) {\n\tfor strings.ContainsRune(what, l.next()) {\n\t}\n\tl.backup()\n}\n\nfunc (l *lexer) errorf(format string, args ...any) lexerStateFn {\n\tt := &Token{\n\t\tFilename: l.name,\n\t\tTyp:      TokenError,\n\t\tVal:      fmt.Sprintf(format, args...),\n\t\tLine:     l.startline,\n\t\tCol:      l.startcol,\n\t}\n\tl.tokens = append(l.tokens, t)\n\tl.errored = true\n\tl.startline = l.line\n\tl.startcol = l.col\n\treturn nil\n}\n\nfunc (l *lexer) run() {\n\tfor {\n\t\t// TODO: Support verbatim tag names\n\t\t// https://docs.djangoproject.com/en/dev/ref/templates/builtins/#verbatim\n\t\tif l.inVerbatim {\n\t\t\tname := l.verbatimName\n\t\t\tif name != \"\" {\n\t\t\t\tname += \" \"\n\t\t\t}\n\t\t\tif strings.HasPrefix(l.input[l.pos:], fmt.Sprintf(\"{%% endverbatim %s%%}\", name)) { // end verbatim\n\t\t\t\tif l.pos > l.start {\n\t\t\t\t\tl.emit(TokenHTML)\n\t\t\t\t}\n\t\t\t\tw := len(\"{% endverbatim %}\")\n\t\t\t\tl.pos += w\n\t\t\t\tl.col += w\n\t\t\t\tl.ignore()\n\t\t\t\tl.inVerbatim = false\n\t\t\t}\n\t\t} else if strings.HasPrefix(l.input[l.pos:], \"{% verbatim %}\") { // tag\n\t\t\tif l.pos > l.start {\n\t\t\t\tl.emit(TokenHTML)\n\t\t\t}\n\t\t\tl.inVerbatim = true\n\t\t\tw := len(\"{% verbatim %}\")\n\t\t\tl.pos += w\n\t\t\tl.col += w\n\t\t\tl.ignore()\n\t\t}\n\n\t\tif !l.inVerbatim {\n\t\t\t// Ignore single-line comments {# ... #}\n\t\t\tif strings.HasPrefix(l.input[l.pos:], \"{#\") {\n\t\t\t\tif l.pos > l.start {\n\t\t\t\t\tl.emit(TokenHTML)\n\t\t\t\t}\n\n\t\t\t\tl.pos += 2 // pass '{#'\n\t\t\t\tl.col += 2\n\n\t\t\t\tfor {\n\t\t\t\t\tswitch l.peek() {\n\t\t\t\t\tcase EOF:\n\t\t\t\t\t\tl.errorf(\"Single-line comment not closed.\")\n\t\t\t\t\t\treturn\n\t\t\t\t\tcase '\\n':\n\t\t\t\t\t\tl.errorf(\"Newline not permitted in a single-line comment.\")\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif strings.HasPrefix(l.input[l.pos:], \"#}\") {\n\t\t\t\t\t\tl.pos += 2 // pass '#}'\n\t\t\t\t\t\tl.col += 2\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\t\tl.next()\n\t\t\t\t}\n\t\t\t\tl.ignore() // ignore whole comment\n\n\t\t\t\t// Comment skipped\n\t\t\t\tcontinue // next token\n\t\t\t}\n\n\t\t\tif strings.HasPrefix(l.input[l.pos:], \"{{\") || // variable\n\t\t\t\tstrings.HasPrefix(l.input[l.pos:], \"{%\") { // tag\n\t\t\t\tif l.pos > l.start {\n\t\t\t\t\tl.emit(TokenHTML)\n\t\t\t\t}\n\t\t\t\tl.tokenize()\n\t\t\t\tif l.errored {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\tswitch l.peek() {\n\t\tcase '\\n':\n\t\t\tl.line++\n\t\t\tl.col = 0\n\t\t}\n\t\tif l.next() == EOF {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif l.pos > l.start {\n\t\tl.emit(TokenHTML)\n\t}\n\n\tif l.inVerbatim {\n\t\tl.errorf(\"verbatim-tag not closed, got EOF.\")\n\t}\n}\n\nfunc (l *lexer) tokenize() {\n\tfor state := l.stateCode; state != nil; {\n\t\tstate = state()\n\t}\n}\n\nfunc (l *lexer) stateCode() lexerStateFn {\nouter_loop:\n\tfor {\n\t\tswitch {\n\t\tcase l.accept(tokenSpaceChars):\n\t\t\tif l.value() == \"\\n\" {\n\t\t\t\treturn l.errorf(\"Newline not allowed within tag/variable.\")\n\t\t\t}\n\t\t\tl.ignore()\n\t\t\tcontinue\n\t\tcase l.accept(tokenIdentifierChars):\n\t\t\treturn l.stateIdentifier\n\t\tcase l.accept(tokenDigits):\n\t\t\treturn l.stateNumber\n\t\tcase l.accept(`\"'`):\n\t\t\treturn l.stateString\n\t\t}\n\n\t\t// Check for symbol\n\t\tfor _, sym := range TokenSymbols {\n\t\t\tif strings.HasPrefix(l.input[l.start:], sym) {\n\t\t\t\tl.pos += len(sym)\n\t\t\t\tl.col += l.length()\n\t\t\t\tl.emit(TokenSymbol)\n\n\t\t\t\tif sym == \"%}\" || sym == \"-%}\" || sym == \"}}\" || sym == \"-}}\" {\n\t\t\t\t\t// Tag/variable end, return after emit\n\t\t\t\t\treturn nil\n\t\t\t\t}\n\n\t\t\t\tcontinue outer_loop\n\t\t\t}\n\t\t}\n\n\t\tbreak\n\t}\n\n\t// Normal shut down\n\treturn nil\n}\n\nfunc (l *lexer) stateIdentifier() lexerStateFn {\n\tl.acceptRun(tokenIdentifierChars)\n\tl.acceptRun(tokenIdentifierCharsWithDigits)\n\tfor _, kw := range TokenKeywords {\n\t\tif kw == l.value() {\n\t\t\tl.emit(TokenKeyword)\n\t\t\treturn l.stateCode\n\t\t}\n\t\tif kw == \"nil\" {\n\t\t\tl.emit(TokenNil)\n\t\t\treturn l.stateCode\n\t\t}\n\t}\n\tl.emit(TokenIdentifier)\n\treturn l.stateCode\n}\n\nfunc (l *lexer) stateNumber() lexerStateFn {\n\tl.acceptRun(tokenDigits)\n\tif l.accept(tokenIdentifierCharsWithDigits) {\n\t\t// This seems to be an identifier starting with a number.\n\t\t// See https://github.com/flosch/pongo2/issues/151\n\t\treturn l.stateIdentifier()\n\t}\n\t/*\n\t\tMaybe context-sensitive number lexing?\n\t\t* comments.0.Text // first comment\n\t\t* usercomments.1.0 // second user, first comment\n\t\t* if (score >= 8.5) // 8.5 as a number\n\n\t\tif l.peek() == '.' {\n\t\t\tl.accept(\".\")\n\t\t\tif !l.accept(tokenDigits) {\n\t\t\t\treturn l.errorf(\"Malformed number.\")\n\t\t\t}\n\t\t\tl.acceptRun(tokenDigits)\n\t\t}\n\t*/\n\tl.emit(TokenNumber)\n\treturn l.stateCode\n}\n\nfunc (l *lexer) stateString() lexerStateFn {\n\tquotationMark := l.value()\n\tl.ignore()\n\tl.startcol-- // we're starting the position at the first \"\n\tfor !l.accept(quotationMark) {\n\t\tswitch l.next() {\n\t\tcase '\\\\':\n\t\t\t// escape sequence\n\t\t\tswitch l.peek() {\n\t\t\tcase '\"', '\\\\':\n\t\t\t\tl.next()\n\t\t\tdefault:\n\t\t\t\treturn l.errorf(\"Unknown escape sequence: \\\\%c\", l.peek())\n\t\t\t}\n\t\tcase EOF:\n\t\t\treturn l.errorf(\"Unexpected EOF, string not closed.\")\n\t\tcase '\\n':\n\t\t\treturn l.errorf(\"Newline in string is not allowed.\")\n\t\t}\n\t}\n\tl.backup()\n\tl.emit(TokenString)\n\n\tl.next()\n\tl.ignore()\n\n\treturn l.stateCode\n}\n"
        },
        {
          "name": "nodes.go",
          "type": "blob",
          "size": 0.279296875,
          "content": "package pongo2\n\n// The root document\ntype nodeDocument struct {\n\tNodes []INode\n}\n\nfunc (doc *nodeDocument) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tfor _, n := range doc.Nodes {\n\t\terr := n.Execute(ctx, writer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "nodes_html.go",
          "type": "blob",
          "size": 0.3828125,
          "content": "package pongo2\n\nimport (\n\t\"strings\"\n)\n\ntype nodeHTML struct {\n\ttoken     *Token\n\ttrimLeft  bool\n\ttrimRight bool\n}\n\nfunc (n *nodeHTML) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tres := n.token.Val\n\tif n.trimLeft {\n\t\tres = strings.TrimLeft(res, tokenSpaceChars)\n\t}\n\tif n.trimRight {\n\t\tres = strings.TrimRight(res, tokenSpaceChars)\n\t}\n\twriter.WriteString(res)\n\treturn nil\n}\n"
        },
        {
          "name": "nodes_wrapper.go",
          "type": "blob",
          "size": 0.2802734375,
          "content": "package pongo2\n\ntype NodeWrapper struct {\n\tEndtag string\n\tnodes  []INode\n}\n\nfunc (wrapper *NodeWrapper) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tfor _, n := range wrapper.nodes {\n\t\terr := n.Execute(ctx, writer)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 0.720703125,
          "content": "package pongo2\n\n// Options allow you to change the behavior of template-engine.\n// You can change the options before calling the Execute method.\ntype Options struct {\n\t// If this is set to true the first newline after a block is removed (block, not variable tag!). Defaults to false.\n\tTrimBlocks bool\n\n\t// If this is set to true leading spaces and tabs are stripped from the start of a line to a block. Defaults to false\n\tLStripBlocks bool\n}\n\nfunc newOptions() *Options {\n\treturn &Options{\n\t\tTrimBlocks:   false,\n\t\tLStripBlocks: false,\n\t}\n}\n\n// Update updates this options from another options.\nfunc (opt *Options) Update(other *Options) *Options {\n\topt.TrimBlocks = other.TrimBlocks\n\topt.LStripBlocks = other.LStripBlocks\n\n\treturn opt\n}\n"
        },
        {
          "name": "parser.go",
          "type": "blob",
          "size": 7.4306640625,
          "content": "package pongo2\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype INode interface {\n\tExecute(*ExecutionContext, TemplateWriter) *Error\n}\n\ntype IEvaluator interface {\n\tINode\n\tGetPositionToken() *Token\n\tEvaluate(*ExecutionContext) (*Value, *Error)\n\tFilterApplied(name string) bool\n}\n\n// The parser provides you a comprehensive and easy tool to\n// work with the template document and arguments provided by\n// the user for your custom tag.\n//\n// The parser works on a token list which will be provided by pongo2.\n// A token is a unit you can work with. Tokens are either of type identifier,\n// string, number, keyword, HTML or symbol.\n//\n// (See Token's documentation for more about tokens)\ntype Parser struct {\n\tname      string\n\tidx       int\n\ttokens    []*Token\n\tlastToken *Token\n\n\t// if the parser parses a template document, here will be\n\t// a reference to it (needed to access the template through Tags)\n\ttemplate *Template\n}\n\n// Creates a new parser to parse tokens.\n// Used inside pongo2 to parse documents and to provide an easy-to-use\n// parser for tag authors\nfunc newParser(name string, tokens []*Token, template *Template) *Parser {\n\tp := &Parser{\n\t\tname:     name,\n\t\ttokens:   tokens,\n\t\ttemplate: template,\n\t}\n\tif len(tokens) > 0 {\n\t\tp.lastToken = tokens[len(tokens)-1]\n\t}\n\treturn p\n}\n\n// Consume one token. It will be gone forever.\nfunc (p *Parser) Consume() {\n\tp.ConsumeN(1)\n}\n\n// Consume N tokens. They will be gone forever.\nfunc (p *Parser) ConsumeN(count int) {\n\tp.idx += count\n}\n\n// Returns the current token.\nfunc (p *Parser) Current() *Token {\n\treturn p.Get(p.idx)\n}\n\n// Returns the CURRENT token if the given type matches.\n// Consumes this token on success.\nfunc (p *Parser) MatchType(typ TokenType) *Token {\n\tif t := p.PeekType(typ); t != nil {\n\t\tp.Consume()\n\t\treturn t\n\t}\n\treturn nil\n}\n\n// Returns the CURRENT token if the given type AND value matches.\n// Consumes this token on success.\nfunc (p *Parser) Match(typ TokenType, val string) *Token {\n\tif t := p.Peek(typ, val); t != nil {\n\t\tp.Consume()\n\t\treturn t\n\t}\n\treturn nil\n}\n\n// Returns the CURRENT token if the given type AND *one* of\n// the given values matches.\n// Consumes this token on success.\nfunc (p *Parser) MatchOne(typ TokenType, vals ...string) *Token {\n\tfor _, val := range vals {\n\t\tif t := p.Peek(typ, val); t != nil {\n\t\t\tp.Consume()\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\n// Returns the CURRENT token if the given type matches.\n// It DOES NOT consume the token.\nfunc (p *Parser) PeekType(typ TokenType) *Token {\n\treturn p.PeekTypeN(0, typ)\n}\n\n// Returns the CURRENT token if the given type AND value matches.\n// It DOES NOT consume the token.\nfunc (p *Parser) Peek(typ TokenType, val string) *Token {\n\treturn p.PeekN(0, typ, val)\n}\n\n// Returns the CURRENT token if the given type AND *one* of\n// the given values matches.\n// It DOES NOT consume the token.\nfunc (p *Parser) PeekOne(typ TokenType, vals ...string) *Token {\n\tfor _, v := range vals {\n\t\tt := p.PeekN(0, typ, v)\n\t\tif t != nil {\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\n// Returns the tokens[current position + shift] token if the\n// given type AND value matches for that token.\n// DOES NOT consume the token.\nfunc (p *Parser) PeekN(shift int, typ TokenType, val string) *Token {\n\tt := p.Get(p.idx + shift)\n\tif t != nil {\n\t\tif t.Typ == typ && t.Val == val {\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\n// Returns the tokens[current position + shift] token if the given type matches.\n// DOES NOT consume the token for that token.\nfunc (p *Parser) PeekTypeN(shift int, typ TokenType) *Token {\n\tt := p.Get(p.idx + shift)\n\tif t != nil {\n\t\tif t.Typ == typ {\n\t\t\treturn t\n\t\t}\n\t}\n\treturn nil\n}\n\n// Returns the UNCONSUMED token count.\nfunc (p *Parser) Remaining() int {\n\treturn len(p.tokens) - p.idx\n}\n\n// Returns the total token count.\nfunc (p *Parser) Count() int {\n\treturn len(p.tokens)\n}\n\n// Returns tokens[i] or NIL (if i >= len(tokens))\nfunc (p *Parser) Get(i int) *Token {\n\tif i < len(p.tokens) && i >= 0 {\n\t\treturn p.tokens[i]\n\t}\n\treturn nil\n}\n\n// Returns tokens[current-position + shift] or NIL\n// (if (current-position + i) >= len(tokens))\nfunc (p *Parser) GetR(shift int) *Token {\n\ti := p.idx + shift\n\treturn p.Get(i)\n}\n\n// Error produces a nice error message and returns an error-object.\n// The 'token'-argument is optional. If provided, it will take\n// the token's position information. If not provided, it will\n// automatically use the CURRENT token's position information.\nfunc (p *Parser) Error(msg string, token *Token) *Error {\n\tif token == nil {\n\t\t// Set current token\n\t\ttoken = p.Current()\n\t\tif token == nil {\n\t\t\t// Set to last token\n\t\t\tif len(p.tokens) > 0 {\n\t\t\t\ttoken = p.tokens[len(p.tokens)-1]\n\t\t\t}\n\t\t}\n\t}\n\tvar line, col int\n\tif token != nil {\n\t\tline = token.Line\n\t\tcol = token.Col\n\t}\n\treturn &Error{\n\t\tTemplate:  p.template,\n\t\tFilename:  p.name,\n\t\tSender:    \"parser\",\n\t\tLine:      line,\n\t\tColumn:    col,\n\t\tToken:     token,\n\t\tOrigError: errors.New(msg),\n\t}\n}\n\n// Wraps all nodes between starting tag and \"{% endtag %}\" and provides\n// one simple interface to execute the wrapped nodes.\n// It returns a parser to process provided arguments to the tag.\nfunc (p *Parser) WrapUntilTag(names ...string) (*NodeWrapper, *Parser, *Error) {\n\twrapper := &NodeWrapper{}\n\n\tvar tagArgs []*Token\n\n\tfor p.Remaining() > 0 {\n\t\t// New tag, check whether we have to stop wrapping here\n\t\tif p.Peek(TokenSymbol, \"{%\") != nil {\n\t\t\ttagIdent := p.PeekTypeN(1, TokenIdentifier)\n\n\t\t\tif tagIdent != nil {\n\t\t\t\t// We've found a (!) end-tag\n\n\t\t\t\tfound := false\n\t\t\t\tfor _, n := range names {\n\t\t\t\t\tif tagIdent.Val == n {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We only process the tag if we've found an end tag\n\t\t\t\tif found {\n\t\t\t\t\t// Okay, endtag found.\n\t\t\t\t\tp.ConsumeN(2) // '{%' tagname\n\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif p.Match(TokenSymbol, \"%}\") != nil {\n\t\t\t\t\t\t\t// Okay, end the wrapping here\n\t\t\t\t\t\t\twrapper.Endtag = tagIdent.Val\n\t\t\t\t\t\t\treturn wrapper, newParser(p.template.name, tagArgs, p.template), nil\n\t\t\t\t\t\t}\n\t\t\t\t\t\tt := p.Current()\n\t\t\t\t\t\tp.Consume()\n\t\t\t\t\t\tif t == nil {\n\t\t\t\t\t\t\treturn nil, nil, p.Error(\"Unexpected EOF.\", p.lastToken)\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttagArgs = append(tagArgs, t)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t// Otherwise process next element to be wrapped\n\t\tnode, err := p.parseDocElement()\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\twrapper.nodes = append(wrapper.nodes, node)\n\t}\n\n\treturn nil, nil, p.Error(fmt.Sprintf(\"Unexpected EOF, expected tag %s.\", strings.Join(names, \" or \")),\n\t\tp.lastToken)\n}\n\n// Skips all nodes between starting tag and \"{% endtag %}\"\nfunc (p *Parser) SkipUntilTag(names ...string) *Error {\n\tfor p.Remaining() > 0 {\n\t\t// New tag, check whether we have to stop wrapping here\n\t\tif p.Peek(TokenSymbol, \"{%\") != nil {\n\t\t\ttagIdent := p.PeekTypeN(1, TokenIdentifier)\n\n\t\t\tif tagIdent != nil {\n\t\t\t\t// We've found an (!) end-tag\n\n\t\t\t\tfound := false\n\t\t\t\tfor _, n := range names {\n\t\t\t\t\tif tagIdent.Val == n {\n\t\t\t\t\t\tfound = true\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We only process the tag if we've found an end tag\n\t\t\t\tif found {\n\t\t\t\t\t// Okay, endtag found.\n\t\t\t\t\tp.ConsumeN(2) // '{%' tagname\n\n\t\t\t\t\tfor {\n\t\t\t\t\t\tif p.Match(TokenSymbol, \"%}\") != nil {\n\t\t\t\t\t\t\t// Done skipping, exit.\n\t\t\t\t\t\t\treturn nil\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// If we haven't encountered '%}', we consume whatever\n\t\t\t\t\t\t// there might be.\n\t\t\t\t\t\tp.Consume()\n\t\t\t\t\t\tif p.Current() == nil {\n\t\t\t\t\t\t\t// EOF encountered\n\t\t\t\t\t\t\treturn p.Error(\"Unexpected EOF, expected '%}'\", p.lastToken)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt := p.Current()\n\t\tp.Consume()\n\t\tif t == nil {\n\t\t\treturn p.Error(\"Unexpected EOF.\", p.lastToken)\n\t\t}\n\t}\n\n\treturn p.Error(fmt.Sprintf(\"Unexpected EOF, expected tag %s.\", strings.Join(names, \" or \")), p.lastToken)\n}\n"
        },
        {
          "name": "parser_document.go",
          "type": "blob",
          "size": 1.2412109375,
          "content": "package pongo2\n\n// Doc = { ( Filter | Tag | HTML ) }\nfunc (p *Parser) parseDocElement() (INode, *Error) {\n\tt := p.Current()\n\n\tswitch t.Typ {\n\tcase TokenHTML:\n\t\tn := &nodeHTML{token: t}\n\t\tleft := p.PeekTypeN(-1, TokenSymbol)\n\t\tright := p.PeekTypeN(1, TokenSymbol)\n\t\tn.trimLeft = left != nil && left.TrimWhitespaces\n\t\tn.trimRight = right != nil && right.TrimWhitespaces\n\t\tp.Consume() // consume HTML element\n\t\treturn n, nil\n\tcase TokenSymbol:\n\t\tswitch t.Val {\n\t\tcase \"{{\":\n\t\t\t// parse variable\n\t\t\tvariable, err := p.parseVariableElement()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn variable, nil\n\t\tcase \"{%\":\n\t\t\t// parse tag\n\t\t\ttag, err := p.parseTagElement()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\treturn tag, nil\n\t\t}\n\t}\n\treturn nil, p.Error(\"Unexpected token (only HTML/tags/filters in templates allowed)\", t)\n}\n\nfunc (tpl *Template) parse() *Error {\n\ttpl.parser = newParser(tpl.name, tpl.tokens, tpl)\n\tdoc, err := tpl.parser.parseDocument()\n\tif err != nil {\n\t\treturn err\n\t}\n\ttpl.root = doc\n\treturn nil\n}\n\nfunc (p *Parser) parseDocument() (*nodeDocument, *Error) {\n\tdoc := &nodeDocument{}\n\n\tfor p.Remaining() > 0 {\n\t\tnode, err := p.parseDocElement()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdoc.Nodes = append(doc.Nodes, node)\n\t}\n\n\treturn doc, nil\n}\n"
        },
        {
          "name": "parser_expression.go",
          "type": "blob",
          "size": 11.8427734375,
          "content": "package pongo2\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype Expression struct {\n\t// TODO: Add location token?\n\texpr1   IEvaluator\n\texpr2   IEvaluator\n\topToken *Token\n}\n\ntype relationalExpression struct {\n\t// TODO: Add location token?\n\texpr1   IEvaluator\n\texpr2   IEvaluator\n\topToken *Token\n}\n\ntype simpleExpression struct {\n\tnegate       bool\n\tnegativeSign bool\n\tterm1        IEvaluator\n\tterm2        IEvaluator\n\topToken      *Token\n}\n\ntype term struct {\n\t// TODO: Add location token?\n\tfactor1 IEvaluator\n\tfactor2 IEvaluator\n\topToken *Token\n}\n\ntype power struct {\n\t// TODO: Add location token?\n\tpower1 IEvaluator\n\tpower2 IEvaluator\n}\n\nfunc (expr *Expression) FilterApplied(name string) bool {\n\treturn expr.expr1.FilterApplied(name) && (expr.expr2 == nil ||\n\t\t(expr.expr2 != nil && expr.expr2.FilterApplied(name)))\n}\n\nfunc (expr *relationalExpression) FilterApplied(name string) bool {\n\treturn expr.expr1.FilterApplied(name) && (expr.expr2 == nil ||\n\t\t(expr.expr2 != nil && expr.expr2.FilterApplied(name)))\n}\n\nfunc (expr *simpleExpression) FilterApplied(name string) bool {\n\treturn expr.term1.FilterApplied(name) && (expr.term2 == nil ||\n\t\t(expr.term2 != nil && expr.term2.FilterApplied(name)))\n}\n\nfunc (expr *term) FilterApplied(name string) bool {\n\treturn expr.factor1.FilterApplied(name) && (expr.factor2 == nil ||\n\t\t(expr.factor2 != nil && expr.factor2.FilterApplied(name)))\n}\n\nfunc (expr *power) FilterApplied(name string) bool {\n\treturn expr.power1.FilterApplied(name) && (expr.power2 == nil ||\n\t\t(expr.power2 != nil && expr.power2.FilterApplied(name)))\n}\n\nfunc (expr *Expression) GetPositionToken() *Token {\n\treturn expr.expr1.GetPositionToken()\n}\n\nfunc (expr *relationalExpression) GetPositionToken() *Token {\n\treturn expr.expr1.GetPositionToken()\n}\n\nfunc (expr *simpleExpression) GetPositionToken() *Token {\n\treturn expr.term1.GetPositionToken()\n}\n\nfunc (expr *term) GetPositionToken() *Token {\n\treturn expr.factor1.GetPositionToken()\n}\n\nfunc (expr *power) GetPositionToken() *Token {\n\treturn expr.power1.GetPositionToken()\n}\n\nfunc (expr *Expression) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := expr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (expr *relationalExpression) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := expr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (expr *simpleExpression) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := expr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (expr *term) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := expr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (expr *power) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := expr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (expr *Expression) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tv1, err := expr.expr1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif expr.expr2 != nil {\n\t\tswitch expr.opToken.Val {\n\t\tcase \"and\", \"&&\":\n\t\t\tif !v1.IsTrue() {\n\t\t\t\treturn AsValue(false), nil\n\t\t\t} else {\n\t\t\t\tv2, err := expr.expr2.Evaluate(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn AsValue(v2.IsTrue()), nil\n\t\t\t}\n\t\tcase \"or\", \"||\":\n\t\t\tif v1.IsTrue() {\n\t\t\t\treturn AsValue(true), nil\n\t\t\t} else {\n\t\t\t\tv2, err := expr.expr2.Evaluate(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\treturn AsValue(v2.IsTrue()), nil\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, ctx.Error(fmt.Sprintf(\"unimplemented: %s\", expr.opToken.Val), expr.opToken)\n\t\t}\n\t} else {\n\t\treturn v1, nil\n\t}\n}\n\nfunc (expr *relationalExpression) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tv1, err := expr.expr1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif expr.expr2 != nil {\n\t\tv2, err := expr.expr2.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tswitch expr.opToken.Val {\n\t\tcase \"<=\":\n\t\t\tif v1.IsFloat() || v2.IsFloat() {\n\t\t\t\treturn AsValue(v1.Float() <= v2.Float()), nil\n\t\t\t}\n\t\t\tif v1.IsTime() && v2.IsTime() {\n\t\t\t\ttm1, tm2 := v1.Time(), v2.Time()\n\t\t\t\treturn AsValue(tm1.Before(tm2) || tm1.Equal(tm2)), nil\n\t\t\t}\n\t\t\treturn AsValue(v1.Integer() <= v2.Integer()), nil\n\t\tcase \">=\":\n\t\t\tif v1.IsFloat() || v2.IsFloat() {\n\t\t\t\treturn AsValue(v1.Float() >= v2.Float()), nil\n\t\t\t}\n\t\t\tif v1.IsTime() && v2.IsTime() {\n\t\t\t\ttm1, tm2 := v1.Time(), v2.Time()\n\t\t\t\treturn AsValue(tm1.After(tm2) || tm1.Equal(tm2)), nil\n\t\t\t}\n\t\t\treturn AsValue(v1.Integer() >= v2.Integer()), nil\n\t\tcase \"==\":\n\t\t\treturn AsValue(v1.EqualValueTo(v2)), nil\n\t\tcase \">\":\n\t\t\tif v1.IsFloat() || v2.IsFloat() {\n\t\t\t\treturn AsValue(v1.Float() > v2.Float()), nil\n\t\t\t}\n\t\t\tif v1.IsTime() && v2.IsTime() {\n\t\t\t\treturn AsValue(v1.Time().After(v2.Time())), nil\n\t\t\t}\n\t\t\treturn AsValue(v1.Integer() > v2.Integer()), nil\n\t\tcase \"<\":\n\t\t\tif v1.IsFloat() || v2.IsFloat() {\n\t\t\t\treturn AsValue(v1.Float() < v2.Float()), nil\n\t\t\t}\n\t\t\tif v1.IsTime() && v2.IsTime() {\n\t\t\t\treturn AsValue(v1.Time().Before(v2.Time())), nil\n\t\t\t}\n\t\t\treturn AsValue(v1.Integer() < v2.Integer()), nil\n\t\tcase \"!=\", \"<>\":\n\t\t\treturn AsValue(!v1.EqualValueTo(v2)), nil\n\t\tcase \"in\":\n\t\t\treturn AsValue(v2.Contains(v1)), nil\n\t\tdefault:\n\t\t\treturn nil, ctx.Error(fmt.Sprintf(\"unimplemented: %s\", expr.opToken.Val), expr.opToken)\n\t\t}\n\t} else {\n\t\treturn v1, nil\n\t}\n}\n\nfunc (expr *simpleExpression) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tt1, err := expr.term1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresult := t1\n\n\tif expr.negate {\n\t\tresult = result.Negate()\n\t}\n\n\tif expr.negativeSign {\n\t\tif result.IsNumber() {\n\t\t\tswitch {\n\t\t\tcase result.IsFloat():\n\t\t\t\tresult = AsValue(-1 * result.Float())\n\t\t\tcase result.IsInteger():\n\t\t\t\tresult = AsValue(-1 * result.Integer())\n\t\t\tdefault:\n\t\t\t\treturn nil, ctx.Error(\"Operation between a number and a non-(float/integer) is not possible\", nil)\n\t\t\t}\n\t\t} else {\n\t\t\treturn nil, ctx.Error(\"Negative sign on a non-number expression\", expr.GetPositionToken())\n\t\t}\n\t}\n\n\tif expr.term2 != nil {\n\t\tt2, err := expr.term2.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tswitch expr.opToken.Val {\n\t\tcase \"+\":\n\t\t\tif result.IsString() || t2.IsString() {\n\t\t\t\t// Result will be a string\n\t\t\t\treturn AsValue(result.String() + t2.String()), nil\n\t\t\t}\n\t\t\tif result.IsFloat() || t2.IsFloat() {\n\t\t\t\t// Result will be a float\n\t\t\t\treturn AsValue(result.Float() + t2.Float()), nil\n\t\t\t}\n\t\t\t// Result will be an integer\n\t\t\treturn AsValue(result.Integer() + t2.Integer()), nil\n\t\tcase \"-\":\n\t\t\tif result.IsFloat() || t2.IsFloat() {\n\t\t\t\t// Result will be a float\n\t\t\t\treturn AsValue(result.Float() - t2.Float()), nil\n\t\t\t}\n\t\t\t// Result will be an integer\n\t\t\treturn AsValue(result.Integer() - t2.Integer()), nil\n\t\tdefault:\n\t\t\treturn nil, ctx.Error(\"Unimplemented\", expr.GetPositionToken())\n\t\t}\n\t}\n\n\treturn result, nil\n}\n\nfunc (expr *term) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tf1, err := expr.factor1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif expr.factor2 != nil {\n\t\tf2, err := expr.factor2.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tswitch expr.opToken.Val {\n\t\tcase \"*\":\n\t\t\tif f1.IsFloat() || f2.IsFloat() {\n\t\t\t\t// Result will be float\n\t\t\t\treturn AsValue(f1.Float() * f2.Float()), nil\n\t\t\t}\n\t\t\t// Result will be int\n\t\t\treturn AsValue(f1.Integer() * f2.Integer()), nil\n\t\tcase \"/\":\n\t\t\tif f1.IsFloat() || f2.IsFloat() {\n\t\t\t\t// Result will be float\n\t\t\t\tdivisor := f2.Float()\n\t\t\t\tif divisor == 0 {\n\t\t\t\t\treturn nil, ctx.Error(\"float divide by zero\", expr.factor2.GetPositionToken())\n\t\t\t\t}\n\t\t\t\treturn AsValue(f1.Float() / divisor), nil\n\t\t\t}\n\t\t\t// Result will be int\n\t\t\tdivisor := f2.Integer()\n\t\t\tif divisor == 0 {\n\t\t\t\treturn nil, ctx.Error(\"integer divide by zero\", expr.factor2.GetPositionToken())\n\t\t\t}\n\t\t\treturn AsValue(f1.Integer() / divisor), nil\n\t\tcase \"%\":\n\t\t\t// Result will be int\n\t\t\tdivisor := f2.Integer()\n\t\t\tif divisor == 0 {\n\t\t\t\treturn nil, ctx.Error(\"integer divide by zero\", expr.factor2.GetPositionToken())\n\t\t\t}\n\t\t\treturn AsValue(f1.Integer() % divisor), nil\n\t\tdefault:\n\t\t\treturn nil, ctx.Error(\"unimplemented\", expr.opToken)\n\t\t}\n\t} else {\n\t\treturn f1, nil\n\t}\n}\n\nfunc (expr *power) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tp1, err := expr.power1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif expr.power2 != nil {\n\t\tp2, err := expr.power2.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn AsValue(math.Pow(p1.Float(), p2.Float())), nil\n\t}\n\treturn p1, nil\n}\n\nfunc (p *Parser) parseFactor() (IEvaluator, *Error) {\n\tif p.Match(TokenSymbol, \"(\") != nil {\n\t\texpr, err := p.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif p.Match(TokenSymbol, \")\") == nil {\n\t\t\treturn nil, p.Error(\"Closing bracket expected after expression\", nil)\n\t\t}\n\t\treturn expr, nil\n\t}\n\n\treturn p.parseVariableOrLiteralWithFilter()\n}\n\nfunc (p *Parser) parsePower() (IEvaluator, *Error) {\n\tpw := new(power)\n\n\tpower1, err := p.parseFactor()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpw.power1 = power1\n\n\tif p.Match(TokenSymbol, \"^\") != nil {\n\t\tpower2, err := p.parsePower()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpw.power2 = power2\n\t}\n\n\tif pw.power2 == nil {\n\t\t// Shortcut for faster evaluation\n\t\treturn pw.power1, nil\n\t}\n\n\treturn pw, nil\n}\n\nfunc (p *Parser) parseTerm() (IEvaluator, *Error) {\n\treturnTerm := new(term)\n\n\tfactor1, err := p.parsePower()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturnTerm.factor1 = factor1\n\n\tfor p.PeekOne(TokenSymbol, \"*\", \"/\", \"%\") != nil {\n\t\tif returnTerm.opToken != nil {\n\t\t\t// Create new sub-term\n\t\t\treturnTerm = &term{\n\t\t\t\tfactor1: returnTerm,\n\t\t\t}\n\t\t}\n\n\t\top := p.Current()\n\t\tp.Consume()\n\n\t\tfactor2, err := p.parsePower()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturnTerm.opToken = op\n\t\treturnTerm.factor2 = factor2\n\t}\n\n\tif returnTerm.opToken == nil {\n\t\t// Shortcut for faster evaluation\n\t\treturn returnTerm.factor1, nil\n\t}\n\n\treturn returnTerm, nil\n}\n\nfunc (p *Parser) parseSimpleExpression() (IEvaluator, *Error) {\n\texpr := new(simpleExpression)\n\n\tif sign := p.MatchOne(TokenSymbol, \"+\", \"-\"); sign != nil {\n\t\tif sign.Val == \"-\" {\n\t\t\texpr.negativeSign = true\n\t\t}\n\t}\n\n\tif p.Match(TokenSymbol, \"!\") != nil || p.Match(TokenKeyword, \"not\") != nil {\n\t\texpr.negate = true\n\t}\n\n\tterm1, err := p.parseTerm()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\texpr.term1 = term1\n\n\tfor p.PeekOne(TokenSymbol, \"+\", \"-\") != nil {\n\t\tif expr.opToken != nil {\n\t\t\t// New sub expr\n\t\t\texpr = &simpleExpression{\n\t\t\t\tterm1: expr,\n\t\t\t}\n\t\t}\n\n\t\top := p.Current()\n\t\tp.Consume()\n\n\t\tterm2, err := p.parseTerm()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\texpr.term2 = term2\n\t\texpr.opToken = op\n\t}\n\n\tif !expr.negate && !expr.negativeSign && expr.term2 == nil {\n\t\t// Shortcut for faster evaluation\n\t\treturn expr.term1, nil\n\t}\n\n\treturn expr, nil\n}\n\nfunc (p *Parser) parseRelationalExpression() (IEvaluator, *Error) {\n\texpr1, err := p.parseSimpleExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\texpr := &relationalExpression{\n\t\texpr1: expr1,\n\t}\n\n\tif t := p.MatchOne(TokenSymbol, \"==\", \"<=\", \">=\", \"!=\", \"<>\", \">\", \"<\"); t != nil {\n\t\texpr2, err := p.parseRelationalExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\texpr.opToken = t\n\t\texpr.expr2 = expr2\n\t} else if t := p.MatchOne(TokenKeyword, \"in\"); t != nil {\n\t\texpr2, err := p.parseSimpleExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\texpr.opToken = t\n\t\texpr.expr2 = expr2\n\t}\n\n\tif expr.expr2 == nil {\n\t\t// Shortcut for faster evaluation\n\t\treturn expr.expr1, nil\n\t}\n\n\treturn expr, nil\n}\n\nfunc (p *Parser) ParseExpression() (IEvaluator, *Error) {\n\trexpr1, err := p.parseRelationalExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\texp := &Expression{\n\t\texpr1: rexpr1,\n\t}\n\n\tif p.PeekOne(TokenSymbol, \"&&\", \"||\") != nil || p.PeekOne(TokenKeyword, \"and\", \"or\") != nil {\n\t\top := p.Current()\n\t\tp.Consume()\n\t\texpr2, err := p.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\texp.expr2 = expr2\n\t\texp.opToken = op\n\t}\n\n\tif exp.expr2 == nil {\n\t\t// Shortcut for faster evaluation\n\t\treturn exp.expr1, nil\n\t}\n\n\treturn exp, nil\n}\n"
        },
        {
          "name": "pongo2.go",
          "type": "blob",
          "size": 0.31640625,
          "content": "package pongo2\n\n// Version string\nconst Version = \"6.0.0\"\n\n// Must panics, if a Template couldn't successfully parsed. This is how you\n// would use it:\n//\n//\tvar baseTemplate = pongo2.Must(pongo2.FromFile(\"templates/base.html\"))\nfunc Must(tpl *Template, err error) *Template {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn tpl\n}\n"
        },
        {
          "name": "pongo2_issues_test.go",
          "type": "blob",
          "size": 0.880859375,
          "content": "package pongo2_test\n\nimport (\n\t\"testing\"\n\n\t\"github.com/flosch/pongo2/v6\"\n)\n\nfunc TestIssue151(t *testing.T) {\n\ttpl, err := pongo2.FromString(\"{{ mydict.51232_3 }}{{ 12345_123}}{{ 995189baz }}\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstr, err := tpl.Execute(pongo2.Context{\n\t\t\"mydict\": map[string]string{\n\t\t\t\"51232_3\": \"foo\",\n\t\t},\n\t\t\"12345_123\": \"bar\",\n\t\t\"995189baz\": \"baz\",\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif str != \"foobarbaz\" {\n\t\tt.Fatalf(\"Expected output 'foobarbaz', but got '%s'.\", str)\n\t}\n}\n\nfunc TestIssue297(t *testing.T) {\n\ttpl, err := pongo2.FromString(\"Testing: {{ input|wordwrap:4 }}!\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tstr, err := tpl.Execute(pongo2.Context{\"input\": \"one two three four five six\"})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif str != \"Testing: one two three four\\nfive six!\" {\n\t\tt.Fatalf(\"Expected `Testing: one two three four\\nfive six!`, but got `%v`.\", str)\n\t}\n}\n"
        },
        {
          "name": "pongo2_template_test.go",
          "type": "blob",
          "size": 20.44140625,
          "content": "package pongo2_test\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/flosch/pongo2/v6\"\n)\n\ntype stringerValueType int\n\nfunc (v stringerValueType) String() string {\n\treturn \"-\" + strconv.Itoa(int(v)) + \":\"\n}\n\nvar (\n\tstrPtr    = stringerValueType(1234)\n\tadminList = []string{\"user2\"}\n)\n\nvar (\n\ttime1 = time.Date(2014, 0o6, 10, 15, 30, 15, 0, time.UTC)\n\ttime2 = time.Date(2011, 0o3, 21, 8, 37, 56, 12, time.UTC)\n)\n\ntype post struct {\n\tText    string\n\tCreated time.Time\n}\n\ntype user struct {\n\tName      string\n\tValidated bool\n}\n\ntype comment struct {\n\tAuthor *user\n\tDate   time.Time\n\tText   string\n}\n\nfunc isAdmin(u *user) bool {\n\tfor _, a := range adminList {\n\t\tif a == u.Name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (u *user) Is_admin() *pongo2.Value {\n\treturn pongo2.AsValue(isAdmin(u))\n}\n\nfunc (u *user) Is_admin2() bool {\n\treturn isAdmin(u)\n}\n\nfunc (p *post) String() string {\n\treturn \":-)\"\n}\n\n/*\n * Start setup sandbox\n */\n\ntype tagSandboxDemoTag struct{}\n\nfunc (node *tagSandboxDemoTag) Execute(ctx *pongo2.ExecutionContext, writer pongo2.TemplateWriter) *pongo2.Error {\n\twriter.WriteString(\"hello\")\n\treturn nil\n}\n\nfunc tagSandboxDemoTagParser(doc *pongo2.Parser, start *pongo2.Token, arguments *pongo2.Parser) (pongo2.INodeTag, *pongo2.Error) {\n\treturn &tagSandboxDemoTag{}, nil\n}\n\nfunc BannedFilterFn(in *pongo2.Value, params *pongo2.Value) (*pongo2.Value, *pongo2.Error) {\n\treturn in, nil\n}\n\nfunc init() {\n\tpongo2.DefaultSet.Debug = true\n\n\tpongo2.RegisterFilter(\"banned_filter\", BannedFilterFn)\n\tpongo2.RegisterFilter(\"unbanned_filter\", BannedFilterFn)\n\tpongo2.RegisterTag(\"banned_tag\", tagSandboxDemoTagParser)\n\tpongo2.RegisterTag(\"unbanned_tag\", tagSandboxDemoTagParser)\n\n\tpongo2.DefaultSet.BanFilter(\"banned_filter\")\n\tpongo2.DefaultSet.BanTag(\"banned_tag\")\n\n\tf, err := os.CreateTemp(os.TempDir(), \"pongo2_\")\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"cannot write to %s\", os.TempDir()))\n\t}\n\tdefer f.Close()\n\t_, err = f.Write([]byte(\"Hello from pongo2\"))\n\tif err != nil {\n\t\tpanic(fmt.Sprintf(\"cannot write to %s\", os.TempDir()))\n\t}\n\tpongo2.DefaultSet.Globals[\"temp_file\"] = f.Name()\n}\n\n/*\n * End setup sandbox\n */\n\nvar tplContext = pongo2.Context{\n\t\"number\": 11,\n\t\"simple\": map[string]any{\n\t\t\"number\":                   42,\n\t\t\"name\":                     \"john doe\",\n\t\t\"included_file\":            \"INCLUDES.helper\",\n\t\t\"included_file_not_exists\": \"INCLUDES.helper.not_exists\",\n\t\t\"nil\":                      nil,\n\t\t\"uint\":                     uint(8),\n\t\t\"float\":                    float64(3.1415),\n\t\t\"str\":                      \"string\",\n\t\t\"chinese_hello_world\":      \"你好世界\",\n\t\t\"bool_true\":                true,\n\t\t\"bool_false\":               false,\n\t\t\"newline_text\": `this is a text\nwith a new line in it`,\n\t\t\"long_text\": `This is a simple text.\n\nThis too, as a paragraph.\nRight?\n\nYep!`,\n\t\t\"escape_js_test\":     `escape sequences \\r\\n\\'\\\" special chars \"?!=$<>`,\n\t\t\"one_item_list\":      []int{99},\n\t\t\"multiple_item_list\": []int{1, 1, 2, 3, 5, 8, 13, 21, 34, 55},\n\t\t\"unsorted_int_list\":  []int{192, 581, 22, 1, 249, 9999, 1828591, 8271},\n\t\t\"fixed_item_list\":    [...]int{1, 2, 3, 4},\n\t\t\"misc_list\":          []any{\"Hello\", 99, 3.14, \"good\"},\n\t\t\"escape_text\":        \"This is \\\\a Test. \\\"Yep\\\". 'Yep'.\",\n\t\t\"xss\":                \"<script>alert(\\\"uh oh\\\");</script>\",\n\t\t\"time1\":              time1,\n\t\t\"time2\":              time2,\n\t\t\"stringer\":           strPtr,\n\t\t\"stringerPtr\":        &strPtr,\n\t\t\"intmap\": map[int]string{\n\t\t\t1: \"one\",\n\t\t\t5: \"five\",\n\t\t\t2: \"two\",\n\t\t},\n\t\t\"strmap\": map[string]string{\n\t\t\t\"abc\": \"def\",\n\t\t\t\"bcd\": \"efg\",\n\t\t\t\"zab\": \"cde\",\n\t\t\t\"gh\":  \"kqm\",\n\t\t\t\"ukq\": \"qqa\",\n\t\t\t\"aab\": \"aba\",\n\t\t},\n\t\t\"func_add\": func(a, b int) int {\n\t\t\treturn a + b\n\t\t},\n\t\t\"func_add_iface\": func(a, b any) any {\n\t\t\tx, is1 := a.(int)\n\t\t\ty, is2 := b.(int)\n\t\t\tif is1 && is2 {\n\t\t\t\treturn x + y\n\t\t\t}\n\t\t\treturn 0\n\t\t},\n\t\t\"func_variadic\": func(msg string, args ...any) string {\n\t\t\treturn fmt.Sprintf(msg, args...)\n\t\t},\n\t\t\"func_variadic_sum_int\": func(args ...int) int {\n\t\t\t// Create a sum\n\t\t\ts := 0\n\t\t\tfor _, i := range args {\n\t\t\t\ts += i\n\t\t\t}\n\t\t\treturn s\n\t\t},\n\t\t\"func_variadic_sum_int2\": func(args ...*pongo2.Value) *pongo2.Value {\n\t\t\t// Create a sum\n\t\t\ts := 0\n\t\t\tfor _, i := range args {\n\t\t\t\ts += i.Integer()\n\t\t\t}\n\t\t\treturn pongo2.AsValue(s)\n\t\t},\n\t\t\"func_ensure_nil\": func(x any) bool {\n\t\t\treturn x == nil\n\t\t},\n\t\t\"func_ensure_nil_variadic\": func(args ...any) bool {\n\t\t\tfor _, i := range args {\n\t\t\t\tif i != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t},\n\t},\n\t\"complex\": map[string]any{\n\t\t\"is_admin\": isAdmin,\n\t\t\"post\": post{\n\t\t\tText:    \"<h2>Hello!</h2><p>Welcome to my new blog page. I'm using pongo2 which supports {{ variables }} and {% tags %}.</p>\",\n\t\t\tCreated: time2,\n\t\t},\n\t\t\"comments\": []*comment{\n\t\t\t{\n\t\t\t\tAuthor: &user{\n\t\t\t\t\tName:      \"user1\",\n\t\t\t\t\tValidated: true,\n\t\t\t\t},\n\t\t\t\tDate: time1,\n\t\t\t\tText: \"\\\"pongo2 is nice!\\\"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAuthor: &user{\n\t\t\t\t\tName:      \"user2\",\n\t\t\t\t\tValidated: true,\n\t\t\t\t},\n\t\t\t\tDate: time2,\n\t\t\t\tText: \"comment2 with <script>unsafe</script> tags in it\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAuthor: &user{\n\t\t\t\t\tName:      \"user3\",\n\t\t\t\t\tValidated: false,\n\t\t\t\t},\n\t\t\t\tDate: time1,\n\t\t\t\tText: \"<b>hello!</b> there\",\n\t\t\t},\n\t\t},\n\t\t\"comments2\": []*comment{\n\t\t\t{\n\t\t\t\tAuthor: &user{\n\t\t\t\t\tName:      \"user1\",\n\t\t\t\t\tValidated: true,\n\t\t\t\t},\n\t\t\t\tDate: time2,\n\t\t\t\tText: \"\\\"pongo2 is nice!\\\"\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAuthor: &user{\n\t\t\t\t\tName:      \"user1\",\n\t\t\t\t\tValidated: true,\n\t\t\t\t},\n\t\t\t\tDate: time1,\n\t\t\t\tText: \"comment2 with <script>unsafe</script> tags in it\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tAuthor: &user{\n\t\t\t\t\tName:      \"user3\",\n\t\t\t\t\tValidated: false,\n\t\t\t\t},\n\t\t\t\tDate: time1,\n\t\t\t\tText: \"<b>hello!</b> there\",\n\t\t\t},\n\t\t},\n\t},\n}\n\nfunc TestTemplate_Functions(t *testing.T) {\n\tmydict := map[string]any{\n\t\t\"foo\":    \"bar\",\n\t\t\"foobar\": 8379,\n\t}\n\n\ttests := []struct {\n\t\tname         string\n\t\ttemplate     string\n\t\tcontext      pongo2.Context\n\t\twant         string\n\t\terrorMessage string\n\t\twantErr      bool\n\t}{\n\t\t{\n\t\t\tname:     \"NoError\",\n\t\t\ttemplate: \"{{ testFunc(mydict) }}\",\n\t\t\tcontext: pongo2.Context{\n\t\t\t\t\"mydict\": mydict,\n\t\t\t\t\"testFunc\": func(i any) (string, error) {\n\t\t\t\t\td, err := json.Marshal(i)\n\t\t\t\t\treturn string(d), err\n\t\t\t\t},\n\t\t\t},\n\t\t\twant:    `{&quot;foo&quot;:&quot;bar&quot;,&quot;foobar&quot;:8379}`,\n\t\t\twantErr: false,\n\t\t},\n\t\t{\n\t\t\tname:     \"WithError\",\n\t\t\ttemplate: \"{{ testFunc(mydict) }}\",\n\t\t\tcontext: pongo2.Context{\n\t\t\t\t\"mydict\": mydict,\n\t\t\t\t\"testFunc\": func(i any) (string, error) {\n\t\t\t\t\treturn \"\", errors.New(\"something went wrong\")\n\t\t\t\t},\n\t\t\t},\n\t\t\terrorMessage: \"[Error (where: execution) in <string> | Line 1 Col 4 near 'testFunc'] something went wrong\",\n\t\t\twantErr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"TooMuchArguments\",\n\t\t\ttemplate: \"{{ testFunc(mydict) }}\",\n\t\t\tcontext: pongo2.Context{\n\t\t\t\t\"mydict\": mydict,\n\t\t\t\t\"testFunc\": func(i any) (string, int, error) {\n\t\t\t\t\treturn \"\", 0, nil\n\t\t\t\t},\n\t\t\t},\n\t\t\terrorMessage: \"[Error (where: execution) in <string> | Line 1 Col 4 near 'testFunc'] 'testFunc' must have exactly 1 or 2 output arguments, the second argument must be of type error\",\n\t\t\twantErr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"InvalidArguments\",\n\t\t\ttemplate: \"{{ testFunc(mydict) }}\",\n\t\t\tcontext: pongo2.Context{\n\t\t\t\t\"mydict\": map[string]any{\n\t\t\t\t\t\"foo\":    \"bar\",\n\t\t\t\t\t\"foobar\": 8379,\n\t\t\t\t},\n\t\t\t\t\"testFunc\": func(i any) (string, int) {\n\t\t\t\t\treturn \"\", 0\n\t\t\t\t},\n\t\t\t},\n\t\t\terrorMessage: \"[Error (where: execution) in <string> | Line 1 Col 4 near 'testFunc'] the second return value is not an error\",\n\t\t\twantErr:      true,\n\t\t},\n\t\t{\n\t\t\tname:     \"NilToNonNilParameter\",\n\t\t\ttemplate: \"{{ testFunc(nil) }}\",\n\t\t\tcontext: pongo2.Context{\n\t\t\t\t\"testFunc\": func(i int) int {\n\t\t\t\t\treturn 1\n\t\t\t\t},\n\t\t\t},\n\t\t\terrorMessage: \"[Error (where: execution) in <string> | Line 1 Col 4 near 'testFunc'] function input argument 0 of 'testFunc' must be of type int or *pongo2.Value (not <nil>)\",\n\t\t\twantErr:      true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\ttpl, _ := pongo2.FromString(\"{{ testFunc(mydict) }}\")\n\t\t\tgot, err := tpl.Execute(tt.context)\n\t\t\tif err != nil {\n\t\t\t\tif !tt.wantErr {\n\t\t\t\t\tt.Errorf(\"Template.Execute() error = %v, wantErr %v\", err, tt.wantErr)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif err.Error() != tt.errorMessage {\n\t\t\t\t\tt.Errorf(\"Template.Execute() error = %v, expected error %v\", err, tt.errorMessage)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tif got != tt.want {\n\t\t\t\tt.Errorf(\"Template.Execute() = %v, want %v\", got, tt.want)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestTemplates(t *testing.T) {\n\t// Add a global to the default set\n\tpongo2.Globals[\"this_is_a_global_variable\"] = \"this is a global text\"\n\n\tmatches, err := filepath.Glob(\"./template_tests/*.tpl\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor idx, match := range matches {\n\t\tt.Run(fmt.Sprintf(\"%03d-%s\", idx+1, match), func(t *testing.T) {\n\t\t\tt.Logf(\"[Template %3d] Testing '%s'\", idx+1, match)\n\t\t\ttpl, err := pongo2.FromFile(match)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error on FromFile('%s'): %s\", match, err.Error())\n\t\t\t}\n\n\t\t\t// Read options from file\n\t\t\toptsStr, _ := os.ReadFile(fmt.Sprintf(\"%s.options\", match))\n\t\t\ttrimBlocks := strings.Contains(string(optsStr), \"TrimBlocks=true\")\n\t\t\tlStripBlocks := strings.Contains(string(optsStr), \"LStripBlocks=true\")\n\n\t\t\ttpl.Options.TrimBlocks = trimBlocks\n\t\t\ttpl.Options.LStripBlocks = lStripBlocks\n\n\t\t\ttestFilename := fmt.Sprintf(\"%s.out\", match)\n\t\t\ttestOut, rerr := os.ReadFile(testFilename)\n\t\t\tif rerr != nil {\n\t\t\t\tt.Fatalf(\"Error on ReadFile('%s'): %s\", testFilename, rerr.Error())\n\t\t\t}\n\t\t\ttplOut, err := tpl.ExecuteBytes(tplContext)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error on Execute('%s'): %s\", match, err.Error())\n\t\t\t}\n\t\t\ttplOut = testTemplateFixes.fixIfNeeded(match, tplOut)\n\t\t\tif !bytes.Equal(testOut, tplOut) {\n\t\t\t\tt.Logf(\"Template (rendered) '%s': '%s'\", match, tplOut)\n\t\t\t\terrFilename := filepath.Base(fmt.Sprintf(\"%s.error\", match))\n\t\t\t\terr := os.WriteFile(errFilename, []byte(tplOut), 0o600)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(err.Error())\n\t\t\t\t}\n\t\t\t\tt.Logf(\"get a complete diff with command: 'diff -ya %s %s'\", testFilename, errFilename)\n\t\t\t\tt.Errorf(\"Failed: test_out != tpl_out for %s\", match)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBlockTemplates(t *testing.T) {\n\t// debug = true\n\n\tmatches, err := filepath.Glob(\"./template_tests/block_render/*.tpl\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor idx, match := range matches {\n\t\tt.Run(fmt.Sprintf(\"%03d-%s\", idx+1, match), func(t *testing.T) {\n\t\t\tt.Logf(\"[BlockTemplate %3d] Testing '%s'\", idx+1, match)\n\n\t\t\ttpl, err := pongo2.FromFile(match)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error on FromFile('%s'): %s\", match, err.Error())\n\t\t\t}\n\n\t\t\ttestFilename := fmt.Sprintf(\"%s.out\", match)\n\t\t\ttestOut, rerr := os.ReadFile(testFilename)\n\t\t\tif rerr != nil {\n\t\t\t\tt.Fatalf(\"Error on ReadFile('%s'): %s\", testFilename, rerr.Error())\n\t\t\t}\n\t\t\ttpl_out, err := tpl.ExecuteBlocks(tplContext, []string{\"content\", \"more_content\"})\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error on ExecuteBlocks('%s'): %s\", match, err.Error())\n\t\t\t}\n\n\t\t\tif _, ok := tpl_out[\"content\"]; !ok {\n\t\t\t\tt.Errorf(\"Failed: content not in tpl_out for %s\", match)\n\t\t\t}\n\t\t\tif _, ok := tpl_out[\"more_content\"]; !ok {\n\t\t\t\tt.Errorf(\"Failed: more_content not in tpl_out for %s\", match)\n\t\t\t}\n\t\t\ttestString := string(testOut[:])\n\t\t\tjoinedString := strings.Join([]string{tpl_out[\"content\"], tpl_out[\"more_content\"]}, \"\")\n\t\t\tif testString != joinedString {\n\t\t\t\tt.Logf(\"BlockTemplate (rendered) '%s': '%s'\", match, tpl_out[\"content\"])\n\t\t\t\terrFilename := filepath.Base(fmt.Sprintf(\"%s.error\", match))\n\t\t\t\terr := os.WriteFile(errFilename, []byte(joinedString), 0o600)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(err.Error())\n\t\t\t\t}\n\t\t\t\tt.Logf(\"get a complete diff with command: 'diff -ya %s %s'\", testFilename, errFilename)\n\t\t\t\tt.Errorf(\"Failed: test_out != tpl_out for %s\", match)\n\t\t\t}\n\t\t})\n\t}\n}\n\ntype testTemplateFixesT map[*regexp.Regexp]func(string) string\n\nfunc (instance testTemplateFixesT) fixIfNeeded(name string, in []byte) []byte {\n\tout := string(in)\n\tfor r, f := range instance {\n\t\tif r.MatchString(name) {\n\t\t\tout = f(out)\n\t\t}\n\t}\n\treturn []byte(out)\n}\n\nvar testTemplateFixes = testTemplateFixesT{\n\tregexp.MustCompile(`.*template_tests[/\\\\]macro\\.tpl`): func(in string) string {\n\t\tout := regexp.MustCompile(`(?:\\.[/\\\\]|)(template_tests)[/\\\\](macro\\.tpl)`).ReplaceAllString(in, \"$1/$2\")\n\t\treturn out\n\t},\n}\n\nfunc TestExecutionErrors(t *testing.T) {\n\t// debug = true\n\n\tmatches, err := filepath.Glob(\"./template_tests/*-execution.err\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor idx, match := range matches {\n\t\tt.Run(fmt.Sprintf(\"%03d-%s\", idx+1, match), func(t *testing.T) {\n\t\t\ttestData, err := os.ReadFile(match)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"could not read file '%v': %v\", match, err)\n\t\t\t}\n\t\t\ttests := strings.Split(string(testData), \"\\n\")\n\n\t\t\tcheckFilename := fmt.Sprintf(\"%s.out\", match)\n\t\t\tcheckData, err := os.ReadFile(checkFilename)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error on ReadFile('%s'): %s\", checkFilename, err.Error())\n\t\t\t}\n\t\t\tchecks := strings.Split(string(checkData), \"\\n\")\n\n\t\t\tif len(checks) != len(tests) {\n\t\t\t\tt.Fatal(\"Template lines != Checks lines\")\n\t\t\t}\n\n\t\t\tfor idx, test := range tests {\n\t\t\t\tif strings.TrimSpace(test) == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.TrimSpace(checks[idx]) == \"\" {\n\t\t\t\t\tt.Fatalf(\"[%s Line %d] Check is empty (must contain an regular expression).\",\n\t\t\t\t\t\tmatch, idx+1)\n\t\t\t\t}\n\n\t\t\t\t_, err = pongo2.FromString(test)\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Error on FromString('%s'): %s\", test, err.Error())\n\t\t\t\t}\n\n\t\t\t\ttpl, err := pongo2.FromBytes([]byte(test))\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fatalf(\"Error on FromBytes('%s'): %s\", test, err.Error())\n\t\t\t\t}\n\n\t\t\t\t_, err = tpl.ExecuteBytes(tplContext)\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"[%s Line %d] Expected error for (got none): %s\",\n\t\t\t\t\t\tmatch, idx+1, tests[idx])\n\t\t\t\t}\n\n\t\t\t\tre := regexp.MustCompile(fmt.Sprintf(\"^%s$\", checks[idx]))\n\t\t\t\tif !re.MatchString(err.Error()) {\n\t\t\t\t\tt.Fatalf(\"[%s Line %d] Error for '%s' (err = '%s') does not match the (regexp-)check: %s\",\n\t\t\t\t\t\tmatch, idx+1, test, err.Error(), checks[idx])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCompilationErrors(t *testing.T) {\n\t// debug = true\n\n\tmatches, err := filepath.Glob(\"./template_tests/*-compilation.err\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor idx, match := range matches {\n\t\tt.Run(fmt.Sprintf(\"%03d-%s\", idx+1, match), func(t *testing.T) {\n\t\t\ttestData, err := os.ReadFile(match)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"could not read file '%v': %v\", match, err)\n\t\t\t}\n\t\t\ttests := strings.Split(string(testData), \"\\n\")\n\n\t\t\tcheckFilename := fmt.Sprintf(\"%s.out\", match)\n\t\t\tcheckData, err := os.ReadFile(checkFilename)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"error on ReadFile('%s'): %s\", checkFilename, err.Error())\n\t\t\t}\n\t\t\tchecks := strings.Split(string(checkData), \"\\n\")\n\n\t\t\tif len(checks) != len(tests) {\n\t\t\t\tt.Fatal(\"Template lines != Checks lines\")\n\t\t\t}\n\n\t\t\tfor idx, test := range tests {\n\t\t\t\tif strings.TrimSpace(test) == \"\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif strings.TrimSpace(checks[idx]) == \"\" {\n\t\t\t\t\tt.Fatalf(\"[%s Line %d] Check is empty (must contain an regular expression).\",\n\t\t\t\t\t\tmatch, idx+1)\n\t\t\t\t}\n\n\t\t\t\t_, err = pongo2.FromString(test)\n\t\t\t\tif err == nil {\n\t\t\t\t\tt.Fatalf(\"[%s | Line %d] Expected error for (got none): %s\", match, idx+1, tests[idx])\n\t\t\t\t}\n\t\t\t\tre := regexp.MustCompile(fmt.Sprintf(\"^%s$\", checks[idx]))\n\t\t\t\tif !re.MatchString(err.Error()) {\n\t\t\t\t\tt.Fatalf(\"[%s | Line %d] Error for '%s' (err = '%s') does not match the (regexp-)check: %s\",\n\t\t\t\t\t\tmatch, idx+1, test, err.Error(), checks[idx])\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestBaseDirectory(t *testing.T) {\n\tmustStr := \"Hello from template_tests/base_dir_test/\"\n\n\tfs := pongo2.MustNewLocalFileSystemLoader(\"\")\n\ts := pongo2.NewSet(\"test set with base directory\", fs)\n\ts.Globals[\"base_directory\"] = \"template_tests/base_dir_test/\"\n\tif err := fs.SetBaseDir(s.Globals[\"base_directory\"].(string)); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmatches, err := filepath.Glob(\"./template_tests/base_dir_test/subdir/*\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfor _, match := range matches {\n\t\tmatch = strings.Replace(match, fmt.Sprintf(\"template_tests%cbase_dir_test%c\", filepath.Separator, filepath.Separator), \"\", -1)\n\n\t\ttpl, err := s.FromFile(match)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tout, err := tpl.Execute(nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif out != mustStr {\n\t\t\tt.Errorf(\"%s: out ('%s') != mustStr ('%s')\", match, out, mustStr)\n\t\t}\n\t}\n}\n\nfunc BenchmarkCache(b *testing.B) {\n\tcacheSet := pongo2.NewSet(\"cache set\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\tfor i := 0; i < b.N; i++ {\n\t\ttpl, err := cacheSet.FromCache(\"template_tests/complex.tpl\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\terr = tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkCacheDebugOn(b *testing.B) {\n\tcacheDebugSet := pongo2.NewSet(\"cache set\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\tcacheDebugSet.Debug = true\n\tfor i := 0; i < b.N; i++ {\n\t\ttpl, err := cacheDebugSet.FromFile(\"template_tests/complex.tpl\")\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t\terr = tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkExecuteComplexWithSandboxActive(b *testing.B) {\n\ttpl, err := pongo2.FromFile(\"template_tests/complex.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr = tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkCompileAndExecuteComplexWithSandboxActive(b *testing.B) {\n\tbuf, err := os.ReadFile(\"template_tests/complex.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tpreloadedTpl := string(buf)\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttpl, err := pongo2.FromString(preloadedTpl)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\terr = tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParallelExecuteComplexWithSandboxActive(b *testing.B) {\n\ttpl, err := pongo2.FromFile(\"template_tests/complex.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\terr := tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkExecuteComplexWithoutSandbox(b *testing.B) {\n\ts := pongo2.NewSet(\"set without sandbox\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\ttpl, err := s.FromFile(\"template_tests/complex.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\terr = tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkCompileAndExecuteComplexWithoutSandbox(b *testing.B) {\n\tbuf, err := os.ReadFile(\"template_tests/complex.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tpreloadedTpl := string(buf)\n\n\ts := pongo2.NewSet(\"set without sandbox\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttpl, err := s.FromString(preloadedTpl)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\n\t\terr = tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkParallelExecuteComplexWithoutSandbox(b *testing.B) {\n\ts := pongo2.NewSet(\"set without sandbox\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\ttpl, err := s.FromFile(\"template_tests/complex.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tb.RunParallel(func(pb *testing.PB) {\n\t\tfor pb.Next() {\n\t\t\terr := tpl.ExecuteWriterUnbuffered(tplContext, io.Discard)\n\t\t\tif err != nil {\n\t\t\t\tb.Fatal(err)\n\t\t\t}\n\t\t}\n\t})\n}\n\nfunc BenchmarkExecuteBlocksWithSandboxActive(b *testing.B) {\n\tblockNames := []string{\"content\", \"more_content\"}\n\ttpl, err := pongo2.FromFile(\"template_tests/block_render/block.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err = tpl.ExecuteBlocks(tplContext, blockNames)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkExecuteBlocksDeepWithSandboxActive(b *testing.B) {\n\tblockNames := []string{\"body\", \"more_content\"}\n\ttpl, err := pongo2.FromFile(\"template_tests/block_render/deep.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err = tpl.ExecuteBlocks(tplContext, blockNames)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkExecuteBlocksWithEmptyBlocksSandboxActive(b *testing.B) {\n\tblockNames := []string{}\n\ttpl, err := pongo2.FromFile(\"template_tests/block_render/block.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err = tpl.ExecuteBlocks(tplContext, blockNames)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc BenchmarkExecuteBlocksWithoutSandbox(b *testing.B) {\n\tblockNames := []string{\"content\", \"more_content\"}\n\ts := pongo2.NewSet(\"set without sandbox\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\ttpl, err := s.FromFile(\"template_tests/block_render/block.tpl\")\n\tif err != nil {\n\t\tb.Fatal(err)\n\t}\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t_, err = tpl.ExecuteBlocks(tplContext, blockNames)\n\t\tif err != nil {\n\t\t\tb.Fatal(err)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "pongo2_test.go",
          "type": "blob",
          "size": 3.8232421875,
          "content": "package pongo2_test\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"testing\"\n\n\t\"github.com/flosch/pongo2/v6\"\n)\n\nvar testSuite2 = pongo2.NewSet(\"test suite 2\", pongo2.MustNewLocalFileSystemLoader(\"\"))\n\nfunc mustEqual(t *testing.T, s, pattern string) {\n\tif !regexp.MustCompile(pattern).MatchString(s) {\n\t\tt.Fatalf(\"mustEqual failed: '%v' does not match pattern '%v'\", s, pattern)\n\t}\n}\n\nfunc mustPanicMatch(t *testing.T, fn func(), pattern string) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err == nil {\n\t\t\tt.Fatalf(\"Expected panic with pattern '%v', nothing happened\", pattern)\n\t\t}\n\n\t\tif !regexp.MustCompile(pattern).MatchString(fmt.Sprintf(\"%v\", err)) {\n\t\t\tt.Fatalf(\"Expected panic with pattern '%v', but got '%v'\", pattern, err)\n\t\t}\n\t}()\n\n\t// We expect fn to panic\n\tfn()\n}\n\nfunc parseTemplate(s string, c pongo2.Context) string {\n\tt, err := testSuite2.FromString(s)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tout, err := t.Execute(c)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn out\n}\n\nfunc parseTemplateFn(s string, c pongo2.Context) func() {\n\treturn func() {\n\t\tparseTemplate(s, c)\n\t}\n}\n\nfunc TestMisc(t *testing.T) {\n\t// Must\n\t// TODO: Add better error message (see issue #18)\n\tmustPanicMatch(\n\t\tt,\n\t\tfunc() { pongo2.Must(testSuite2.FromFile(\"template_tests/inheritance/base2.tpl\")) },\n\t\t`\\[Error \\(where: fromfile\\) in .*template_tests[/\\\\]inheritance[/\\\\]doesnotexist.tpl | Line 1 Col 12 near 'doesnotexist.tpl'\\] open .*template_tests[/\\\\]inheritance[/\\\\]doesnotexist.tpl: no such file or directory`,\n\t)\n\n\t// Context\n\tmustPanicMatch(t, parseTemplateFn(\"\", pongo2.Context{\"'illegal\": nil}), \".*not a valid identifier.*\")\n\n\t// Registers\n\tmustEqual(t, pongo2.RegisterFilter(\"escape\", nil).Error(), \".*is already registered\")\n\tmustEqual(t, pongo2.RegisterTag(\"for\", nil).Error(), \".*is already registered\")\n\n\t// ApplyFilter\n\tv, err := pongo2.ApplyFilter(\"title\", pongo2.AsValue(\"this is a title\"), nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tmustEqual(t, v.String(), \"This Is A Title\")\n\tmustPanicMatch(t, func() {\n\t\t_, err := pongo2.ApplyFilter(\"doesnotexist\", nil, nil)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}, `\\[Error \\(where: applyfilter\\)\\] filter with name 'doesnotexist' not found`)\n}\n\nfunc TestImplicitExecCtx(t *testing.T) {\n\ttpl, err := pongo2.FromString(\"{{ ImplicitExec }}\")\n\tif err != nil {\n\t\tt.Fatalf(\"Error in FromString: %v\", err)\n\t}\n\n\tval := \"a stringy thing\"\n\n\tres, err := tpl.Execute(pongo2.Context{\n\t\t\"Value\": val,\n\t\t\"ImplicitExec\": func(ctx *pongo2.ExecutionContext) string {\n\t\t\treturn ctx.Public[\"Value\"].(string)\n\t\t},\n\t})\n\tif err != nil {\n\t\tt.Fatalf(\"Error executing template: %v\", err)\n\t}\n\n\tmustEqual(t, res, val)\n\n\t// The implicit ctx should not be persisted from call-to-call\n\tres, err = tpl.Execute(pongo2.Context{\n\t\t\"ImplicitExec\": func() string {\n\t\t\treturn val\n\t\t},\n\t})\n\n\tif err != nil {\n\t\tt.Fatalf(\"Error executing template: %v\", err)\n\t}\n\n\tmustEqual(t, res, val)\n}\n\ntype DummyLoader struct{}\n\nfunc (l *DummyLoader) Abs(base, name string) string {\n\treturn filepath.Join(filepath.Dir(base), name)\n}\n\nfunc (l *DummyLoader) Get(path string) (io.Reader, error) {\n\treturn nil, errors.New(\"dummy not found\")\n}\n\nfunc FuzzSimpleExecution(f *testing.F) {\n\ttpls, err := filepath.Glob(\"template_tests/*.tpl\")\n\tif err != nil {\n\t\tf.Fatalf(\"glob: %v\", err)\n\t}\n\tfiles := []string{\"README.md\"}\n\tfiles = append(files, tpls...)\n\n\tfor _, tplPath := range files {\n\t\tbuf, err := os.ReadFile(tplPath)\n\t\tif err != nil {\n\t\t\tf.Fatalf(\"could not read file '%v': %v\", tplPath, err)\n\t\t}\n\t\tf.Add(string(buf), \"test-value\")\n\t}\n\n\tf.Add(\"{{ foobar }}\", \"00000000\")\n\n\tf.Fuzz(func(t *testing.T, tpl, contextValue string) {\n\t\tts := pongo2.NewSet(\"fuzz-test\", &DummyLoader{})\n\t\tout, err := ts.FromString(tpl)\n\t\tif err != nil && out != nil {\n\t\t\tt.Errorf(\"%v\", err)\n\t\t}\n\t\tif err == nil {\n\t\t\tmycontext := pongo2.Context{\n\t\t\t\t\"foobar\": contextValue,\n\t\t\t}\n\t\t\tmycontext.Update(tplContext)\n\t\t\tout.Execute(mycontext)\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "tags.go",
          "type": "blob",
          "size": 3.4072265625,
          "content": "package pongo2\n\n/* Incomplete:\n   -----------\n\n   verbatim (only the \"name\" argument is missing for verbatim)\n\n   Reconsideration:\n   ----------------\n\n   debug (reason: not sure what to output yet)\n   regroup / Grouping on other properties (reason: maybe too python-specific; not sure how useful this would be in Go)\n\n   Following built-in tags wont be added:\n   --------------------------------------\n\n   csrf_token (reason: web-framework specific)\n   load (reason: python-specific)\n   url (reason: web-framework specific)\n*/\n\nimport (\n\t\"fmt\"\n)\n\ntype INodeTag interface {\n\tINode\n}\n\n// This is the function signature of the tag's parser you will have\n// to implement in order to create a new tag.\n//\n// 'doc' is providing access to the whole document while 'arguments'\n// is providing access to the user's arguments to the tag:\n//\n//\t{% your_tag_name some \"arguments\" 123 %}\n//\n// start_token will be the *Token with the tag's name in it (here: your_tag_name).\n//\n// Please see the Parser documentation on how to use the parser.\n// See RegisterTag()'s documentation for more information about\n// writing a tag as well.\ntype TagParser func(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error)\n\ntype tag struct {\n\tname   string\n\tparser TagParser\n}\n\nvar tags map[string]*tag\n\nfunc init() {\n\ttags = make(map[string]*tag)\n}\n\n// Registers a new tag. You usually want to call this\n// function in the tag's init() function:\n// http://golang.org/doc/effective_go.html#init\nfunc RegisterTag(name string, parserFn TagParser) error {\n\t_, existing := tags[name]\n\tif existing {\n\t\treturn fmt.Errorf(\"tag with name '%s' is already registered\", name)\n\t}\n\ttags[name] = &tag{\n\t\tname:   name,\n\t\tparser: parserFn,\n\t}\n\treturn nil\n}\n\n// Replaces an already registered tag with a new implementation. Use this\n// function with caution since it allows you to change existing tag behaviour.\nfunc ReplaceTag(name string, parserFn TagParser) error {\n\t_, existing := tags[name]\n\tif !existing {\n\t\treturn fmt.Errorf(\"tag with name '%s' does not exist (therefore cannot be overridden)\", name)\n\t}\n\ttags[name] = &tag{\n\t\tname:   name,\n\t\tparser: parserFn,\n\t}\n\treturn nil\n}\n\n// Tag = \"{%\" IDENT ARGS \"%}\"\nfunc (p *Parser) parseTagElement() (INodeTag, *Error) {\n\tp.Consume() // consume \"{%\"\n\ttokenName := p.MatchType(TokenIdentifier)\n\n\t// Check for identifier\n\tif tokenName == nil {\n\t\treturn nil, p.Error(\"Tag name must be an identifier.\", nil)\n\t}\n\n\t// Check for the existing tag\n\ttag, exists := tags[tokenName.Val]\n\tif !exists {\n\t\t// Does not exists\n\t\treturn nil, p.Error(fmt.Sprintf(\"Tag '%s' not found (or beginning tag not provided)\", tokenName.Val), tokenName)\n\t}\n\n\t// Check sandbox tag restriction\n\tif _, isBanned := p.template.set.bannedTags[tokenName.Val]; isBanned {\n\t\treturn nil, p.Error(fmt.Sprintf(\"Usage of tag '%s' is not allowed (sandbox restriction active).\", tokenName.Val), tokenName)\n\t}\n\n\tvar argsToken []*Token\n\tfor p.Peek(TokenSymbol, \"%}\") == nil && p.Remaining() > 0 {\n\t\t// Add token to args\n\t\targsToken = append(argsToken, p.Current())\n\t\tp.Consume() // next token\n\t}\n\n\t// EOF?\n\tif p.Remaining() == 0 {\n\t\treturn nil, p.Error(\"Unexpectedly reached EOF, no tag end found.\", p.lastToken)\n\t}\n\n\tp.Match(TokenSymbol, \"%}\")\n\n\targParser := newParser(p.name, argsToken, p.template)\n\tif len(argsToken) == 0 {\n\t\t// This is done to have nice EOF error messages\n\t\targParser.lastToken = tokenName\n\t}\n\n\tp.template.level++\n\tdefer func() { p.template.level-- }()\n\treturn tag.parser(p, tokenName, argParser)\n}\n"
        },
        {
          "name": "tags_autoescape.go",
          "type": "blob",
          "size": 1.1875,
          "content": "package pongo2\n\ntype tagAutoescapeNode struct {\n\twrapper    *NodeWrapper\n\tautoescape bool\n}\n\nfunc (node *tagAutoescapeNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\told := ctx.Autoescape\n\tctx.Autoescape = node.autoescape\n\n\terr := node.wrapper.Execute(ctx, writer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx.Autoescape = old\n\n\treturn nil\n}\n\nfunc tagAutoescapeParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tautoescapeNode := &tagAutoescapeNode{}\n\n\twrapper, _, err := doc.WrapUntilTag(\"endautoescape\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tautoescapeNode.wrapper = wrapper\n\n\tmodeToken := arguments.MatchType(TokenIdentifier)\n\tif modeToken == nil {\n\t\treturn nil, arguments.Error(\"A mode is required for autoescape-tag.\", nil)\n\t}\n\tif modeToken.Val == \"on\" {\n\t\tautoescapeNode.autoescape = true\n\t} else if modeToken.Val == \"off\" {\n\t\tautoescapeNode.autoescape = false\n\t} else {\n\t\treturn nil, arguments.Error(\"Only 'on' or 'off' is valid as an autoescape-mode.\", nil)\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed autoescape-tag arguments.\", nil)\n\t}\n\n\treturn autoescapeNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"autoescape\", tagAutoescapeParser)\n}\n"
        },
        {
          "name": "tags_block.go",
          "type": "blob",
          "size": 3.1025390625,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\ntype tagBlockNode struct {\n\tname string\n}\n\nfunc (node *tagBlockNode) getBlockWrappers(tpl *Template) []*NodeWrapper {\n\tnodeWrappers := make([]*NodeWrapper, 0)\n\tvar t *NodeWrapper\n\n\tfor tpl != nil {\n\t\tt = tpl.blocks[node.name]\n\t\tif t != nil {\n\t\t\tnodeWrappers = append(nodeWrappers, t)\n\t\t}\n\t\ttpl = tpl.child\n\t}\n\n\treturn nodeWrappers\n}\n\nfunc (node *tagBlockNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\ttpl := ctx.template\n\tif tpl == nil {\n\t\tpanic(\"internal error: tpl == nil\")\n\t}\n\n\t// Determine the block to execute\n\tblockWrappers := node.getBlockWrappers(tpl)\n\tlenBlockWrappers := len(blockWrappers)\n\n\tif lenBlockWrappers == 0 {\n\t\treturn ctx.Error(\"internal error: len(block_wrappers) == 0 in tagBlockNode.Execute()\", nil)\n\t}\n\n\tblockWrapper := blockWrappers[lenBlockWrappers-1]\n\tctx.Private[\"block\"] = tagBlockInformation{\n\t\tctx:      ctx,\n\t\twrappers: blockWrappers[0 : lenBlockWrappers-1],\n\t}\n\terr := blockWrapper.Execute(ctx, writer)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\ntype tagBlockInformation struct {\n\tctx      *ExecutionContext\n\twrappers []*NodeWrapper\n}\n\nfunc (t tagBlockInformation) Super() (*Value, error) {\n\tlenWrappers := len(t.wrappers)\n\n\tif lenWrappers == 0 {\n\t\treturn AsSafeValue(\"\"), nil\n\t}\n\n\tsuperCtx := NewChildExecutionContext(t.ctx)\n\tsuperCtx.Private[\"block\"] = tagBlockInformation{\n\t\tctx:      t.ctx,\n\t\twrappers: t.wrappers[0 : lenWrappers-1],\n\t}\n\n\tblockWrapper := t.wrappers[lenWrappers-1]\n\tbuf := bytes.NewBufferString(\"\")\n\terr := blockWrapper.Execute(superCtx, &templateWriter{buf})\n\tif err != nil {\n\t\treturn AsSafeValue(\"\"), err\n\t}\n\treturn AsSafeValue(buf.String()), nil\n}\n\nfunc tagBlockParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tif arguments.Count() == 0 {\n\t\treturn nil, arguments.Error(\"Tag 'block' requires an identifier.\", nil)\n\t}\n\n\tnameToken := arguments.MatchType(TokenIdentifier)\n\tif nameToken == nil {\n\t\treturn nil, arguments.Error(\"First argument for tag 'block' must be an identifier.\", nil)\n\t}\n\n\tif arguments.Remaining() != 0 {\n\t\treturn nil, arguments.Error(\"Tag 'block' takes exactly 1 argument (an identifier).\", nil)\n\t}\n\n\twrapper, endtagargs, err := doc.WrapUntilTag(\"endblock\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif endtagargs.Remaining() > 0 {\n\t\tendtagnameToken := endtagargs.MatchType(TokenIdentifier)\n\t\tif endtagnameToken != nil {\n\t\t\tif endtagnameToken.Val != nameToken.Val {\n\t\t\t\treturn nil, endtagargs.Error(fmt.Sprintf(\"Name for 'endblock' must equal to 'block'-tag's name ('%s' != '%s').\",\n\t\t\t\t\tnameToken.Val, endtagnameToken.Val), nil)\n\t\t\t}\n\t\t}\n\n\t\tif endtagnameToken == nil || endtagargs.Remaining() > 0 {\n\t\t\treturn nil, endtagargs.Error(\"Either no or only one argument (identifier) allowed for 'endblock'.\", nil)\n\t\t}\n\t}\n\n\ttpl := doc.template\n\tif tpl == nil {\n\t\tpanic(\"internal error: tpl == nil\")\n\t}\n\t_, hasBlock := tpl.blocks[nameToken.Val]\n\tif !hasBlock {\n\t\ttpl.blocks[nameToken.Val] = wrapper\n\t} else {\n\t\treturn nil, arguments.Error(fmt.Sprintf(\"Block named '%s' already defined\", nameToken.Val), nil)\n\t}\n\n\treturn &tagBlockNode{name: nameToken.Val}, nil\n}\n\nfunc init() {\n\tRegisterTag(\"block\", tagBlockParser)\n}\n"
        },
        {
          "name": "tags_comment.go",
          "type": "blob",
          "size": 0.6201171875,
          "content": "package pongo2\n\ntype tagCommentNode struct{}\n\nfunc (node *tagCommentNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\treturn nil\n}\n\nfunc tagCommentParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tcommentNode := &tagCommentNode{}\n\n\t// TODO: Process the endtag's arguments (see django 'comment'-tag documentation)\n\terr := doc.SkipUntilTag(\"endcomment\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif arguments.Count() != 0 {\n\t\treturn nil, arguments.Error(\"Tag 'comment' does not take any argument.\", nil)\n\t}\n\n\treturn commentNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"comment\", tagCommentParser)\n}\n"
        },
        {
          "name": "tags_cycle.go",
          "type": "blob",
          "size": 2.017578125,
          "content": "package pongo2\n\ntype tagCycleValue struct {\n\tnode  *tagCycleNode\n\tvalue *Value\n}\n\ntype tagCycleNode struct {\n\tposition *Token\n\targs     []IEvaluator\n\tidx      int\n\tasName   string\n\tsilent   bool\n}\n\nfunc (cv *tagCycleValue) String() string {\n\treturn cv.value.String()\n}\n\nfunc (node *tagCycleNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\titem := node.args[node.idx%len(node.args)]\n\tnode.idx++\n\n\tval, err := item.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif t, ok := val.Interface().(*tagCycleValue); ok {\n\t\t// {% cycle \"test1\" \"test2\"\n\t\t// {% cycle cycleitem %}\n\n\t\t// Update the cycle value with next value\n\t\titem := t.node.args[t.node.idx%len(t.node.args)]\n\t\tt.node.idx++\n\n\t\tval, err := item.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tt.value = val\n\n\t\tif !t.node.silent {\n\t\t\twriter.WriteString(val.String())\n\t\t}\n\t} else {\n\t\t// Regular call\n\n\t\tcycleValue := &tagCycleValue{\n\t\t\tnode:  node,\n\t\t\tvalue: val,\n\t\t}\n\n\t\tif node.asName != \"\" {\n\t\t\tctx.Private[node.asName] = cycleValue\n\t\t}\n\t\tif !node.silent {\n\t\t\twriter.WriteString(val.String())\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// HINT: We're not supporting the old comma-separated list of expressions argument-style\nfunc tagCycleParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tcycleNode := &tagCycleNode{\n\t\tposition: start,\n\t}\n\n\tfor arguments.Remaining() > 0 {\n\t\tnode, err := arguments.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tcycleNode.args = append(cycleNode.args, node)\n\n\t\tif arguments.MatchOne(TokenKeyword, \"as\") != nil {\n\t\t\t// as\n\n\t\t\tnameToken := arguments.MatchType(TokenIdentifier)\n\t\t\tif nameToken == nil {\n\t\t\t\treturn nil, arguments.Error(\"Name (identifier) expected after 'as'.\", nil)\n\t\t\t}\n\t\t\tcycleNode.asName = nameToken.Val\n\n\t\t\tif arguments.MatchOne(TokenIdentifier, \"silent\") != nil {\n\t\t\t\tcycleNode.silent = true\n\t\t\t}\n\n\t\t\t// Now we're finished\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed cycle-tag.\", nil)\n\t}\n\n\treturn cycleNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"cycle\", tagCycleParser)\n}\n"
        },
        {
          "name": "tags_extends.go",
          "type": "blob",
          "size": 1.3388671875,
          "content": "package pongo2\n\ntype tagExtendsNode struct {\n\tfilename string\n}\n\nfunc (node *tagExtendsNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\treturn nil\n}\n\nfunc tagExtendsParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\textendsNode := &tagExtendsNode{}\n\n\tif doc.template.level > 1 {\n\t\treturn nil, arguments.Error(\"The 'extends' tag can only defined on root level.\", start)\n\t}\n\n\tif doc.template.parent != nil {\n\t\t// Already one parent\n\t\treturn nil, arguments.Error(\"This template has already one parent.\", start)\n\t}\n\n\tif filenameToken := arguments.MatchType(TokenString); filenameToken != nil {\n\t\t// prepared, static template\n\n\t\t// Get parent's filename\n\t\tparentFilename := doc.template.set.resolveFilename(doc.template, filenameToken.Val)\n\n\t\t// Parse the parent\n\t\tparentTemplate, err := doc.template.set.FromFile(parentFilename)\n\t\tif err != nil {\n\t\t\treturn nil, err.(*Error)\n\t\t}\n\n\t\t// Keep track of things\n\t\tparentTemplate.child = doc.template\n\t\tdoc.template.parent = parentTemplate\n\t\textendsNode.filename = parentFilename\n\t} else {\n\t\treturn nil, arguments.Error(\"Tag 'extends' requires a template filename as string.\", nil)\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Tag 'extends' does only take 1 argument.\", nil)\n\t}\n\n\treturn extendsNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"extends\", tagExtendsParser)\n}\n"
        },
        {
          "name": "tags_filter.go",
          "type": "blob",
          "size": 2.0068359375,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n)\n\ntype nodeFilterCall struct {\n\tname      string\n\tparamExpr IEvaluator\n}\n\ntype tagFilterNode struct {\n\tposition    *Token\n\tbodyWrapper *NodeWrapper\n\tfilterChain []*nodeFilterCall\n}\n\nfunc (node *tagFilterNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\ttemp := bytes.NewBuffer(make([]byte, 0, 1024)) // 1 KiB size\n\n\terr := node.bodyWrapper.Execute(ctx, temp)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalue := AsValue(temp.String())\n\n\tfor _, call := range node.filterChain {\n\t\tvar param *Value\n\t\tif call.paramExpr != nil {\n\t\t\tparam, err = call.paramExpr.Evaluate(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\tparam = AsValue(nil)\n\t\t}\n\t\tvalue, err = ApplyFilter(call.name, value, param)\n\t\tif err != nil {\n\t\t\treturn ctx.Error(err.Error(), node.position)\n\t\t}\n\t}\n\n\twriter.WriteString(value.String())\n\n\treturn nil\n}\n\nfunc tagFilterParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tfilterNode := &tagFilterNode{\n\t\tposition: start,\n\t}\n\n\twrapper, _, err := doc.WrapUntilTag(\"endfilter\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfilterNode.bodyWrapper = wrapper\n\n\tfor arguments.Remaining() > 0 {\n\t\tfilterCall := &nodeFilterCall{}\n\n\t\tnameToken := arguments.MatchType(TokenIdentifier)\n\t\tif nameToken == nil {\n\t\t\treturn nil, arguments.Error(\"Expected a filter name (identifier).\", nil)\n\t\t}\n\t\tfilterCall.name = nameToken.Val\n\n\t\tif arguments.MatchOne(TokenSymbol, \":\") != nil {\n\t\t\t// Filter parameter\n\t\t\t// NOTICE: we can't use ParseExpression() here, because it would parse the next filter \"|...\" as well in the argument list\n\t\t\texpr, err := arguments.parseVariableOrLiteral()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tfilterCall.paramExpr = expr\n\t\t}\n\n\t\tfilterNode.filterChain = append(filterNode.filterChain, filterCall)\n\n\t\tif arguments.MatchOne(TokenSymbol, \"|\") == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed filter-tag arguments.\", nil)\n\t}\n\n\treturn filterNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"filter\", tagFilterParser)\n}\n"
        },
        {
          "name": "tags_firstof.go",
          "type": "blob",
          "size": 0.904296875,
          "content": "package pongo2\n\ntype tagFirstofNode struct {\n\tposition *Token\n\targs     []IEvaluator\n}\n\nfunc (node *tagFirstofNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tfor _, arg := range node.args {\n\t\tval, err := arg.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif val.IsTrue() {\n\t\t\tif ctx.Autoescape && !arg.FilterApplied(\"safe\") {\n\t\t\t\tval, err = ApplyFilter(\"escape\", val, nil)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twriter.WriteString(val.String())\n\t\t\treturn nil\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc tagFirstofParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tfirstofNode := &tagFirstofNode{\n\t\tposition: start,\n\t}\n\n\tfor arguments.Remaining() > 0 {\n\t\tnode, err := arguments.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfirstofNode.args = append(firstofNode.args, node)\n\t}\n\n\treturn firstofNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"firstof\", tagFirstofParser)\n}\n"
        },
        {
          "name": "tags_for.go",
          "type": "blob",
          "size": 3.83203125,
          "content": "package pongo2\n\ntype tagForNode struct {\n\tkey             string\n\tvalue           string // only for maps: for key, value in map\n\tobjectEvaluator IEvaluator\n\treversed        bool\n\tsorted          bool\n\n\tbodyWrapper  *NodeWrapper\n\temptyWrapper *NodeWrapper\n}\n\ntype tagForLoopInformation struct {\n\tCounter     int\n\tCounter0    int\n\tRevcounter  int\n\tRevcounter0 int\n\tFirst       bool\n\tLast        bool\n\tParentloop  *tagForLoopInformation\n}\n\nfunc (node *tagForNode) Execute(ctx *ExecutionContext, writer TemplateWriter) (forError *Error) {\n\t// Backup forloop (as parentloop in public context), key-name and value-name\n\tforCtx := NewChildExecutionContext(ctx)\n\tparentloop := forCtx.Private[\"forloop\"]\n\n\t// Create loop struct\n\tloopInfo := &tagForLoopInformation{\n\t\tFirst: true,\n\t}\n\n\t// Is it a loop in a loop?\n\tif parentloop != nil {\n\t\tloopInfo.Parentloop = parentloop.(*tagForLoopInformation)\n\t}\n\n\t// Register loopInfo in public context\n\tforCtx.Private[\"forloop\"] = loopInfo\n\n\tobj, err := node.objectEvaluator.Evaluate(forCtx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tobj.IterateOrder(func(idx, count int, key, value *Value) bool {\n\t\t// There's something to iterate over (correct type and at least 1 item)\n\n\t\t// Update loop infos and public context\n\t\tforCtx.Private[node.key] = key\n\t\tif value != nil {\n\t\t\tforCtx.Private[node.value] = value\n\t\t}\n\t\tloopInfo.Counter = idx + 1\n\t\tloopInfo.Counter0 = idx\n\t\tif idx == 1 {\n\t\t\tloopInfo.First = false\n\t\t}\n\t\tif idx+1 == count {\n\t\t\tloopInfo.Last = true\n\t\t}\n\t\tloopInfo.Revcounter = count - idx        // TODO: Not sure about this, have to look it up\n\t\tloopInfo.Revcounter0 = count - (idx + 1) // TODO: Not sure about this, have to look it up\n\n\t\t// Render elements with updated context\n\t\terr := node.bodyWrapper.Execute(forCtx, writer)\n\t\tif err != nil {\n\t\t\tforError = err\n\t\t\treturn false\n\t\t}\n\t\treturn true\n\t}, func() {\n\t\t// Nothing to iterate over (maybe wrong type or no items)\n\t\tif node.emptyWrapper != nil {\n\t\t\terr := node.emptyWrapper.Execute(forCtx, writer)\n\t\t\tif err != nil {\n\t\t\t\tforError = err\n\t\t\t}\n\t\t}\n\t}, node.reversed, node.sorted)\n\n\treturn forError\n}\n\nfunc tagForParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tforNode := &tagForNode{}\n\n\t// Arguments parsing\n\tvar valueToken *Token\n\tkeyToken := arguments.MatchType(TokenIdentifier)\n\tif keyToken == nil {\n\t\treturn nil, arguments.Error(\"Expected an key identifier as first argument for 'for'-tag\", nil)\n\t}\n\n\tif arguments.Match(TokenSymbol, \",\") != nil {\n\t\t// Value name is provided\n\t\tvalueToken = arguments.MatchType(TokenIdentifier)\n\t\tif valueToken == nil {\n\t\t\treturn nil, arguments.Error(\"Value name must be an identifier.\", nil)\n\t\t}\n\t}\n\n\tif arguments.Match(TokenKeyword, \"in\") == nil {\n\t\treturn nil, arguments.Error(\"Expected keyword 'in'.\", nil)\n\t}\n\n\tobjectEvaluator, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tforNode.objectEvaluator = objectEvaluator\n\tforNode.key = keyToken.Val\n\tif valueToken != nil {\n\t\tforNode.value = valueToken.Val\n\t}\n\n\tif arguments.MatchOne(TokenIdentifier, \"reversed\") != nil {\n\t\tforNode.reversed = true\n\t}\n\n\tif arguments.MatchOne(TokenIdentifier, \"sorted\") != nil {\n\t\tforNode.sorted = true\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed for-loop arguments.\", nil)\n\t}\n\n\t// Body wrapping\n\twrapper, endargs, err := doc.WrapUntilTag(\"empty\", \"endfor\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tforNode.bodyWrapper = wrapper\n\n\tif endargs.Count() > 0 {\n\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t}\n\n\tif wrapper.Endtag == \"empty\" {\n\t\t// if there's an else in the if-statement, we need the else-Block as well\n\t\twrapper, endargs, err = doc.WrapUntilTag(\"endfor\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tforNode.emptyWrapper = wrapper\n\n\t\tif endargs.Count() > 0 {\n\t\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t\t}\n\t}\n\n\treturn forNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"for\", tagForParser)\n}\n"
        },
        {
          "name": "tags_if.go",
          "type": "blob",
          "size": 1.67578125,
          "content": "package pongo2\n\ntype tagIfNode struct {\n\tconditions []IEvaluator\n\twrappers   []*NodeWrapper\n}\n\nfunc (node *tagIfNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tfor i, condition := range node.conditions {\n\t\tresult, err := condition.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif result.IsTrue() {\n\t\t\treturn node.wrappers[i].Execute(ctx, writer)\n\t\t}\n\t\t// Last condition?\n\t\tif len(node.conditions) == i+1 && len(node.wrappers) > i+1 {\n\t\t\treturn node.wrappers[i+1].Execute(ctx, writer)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc tagIfParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tifNode := &tagIfNode{}\n\n\t// Parse first and main IF condition\n\tcondition, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tifNode.conditions = append(ifNode.conditions, condition)\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"If-condition is malformed.\", nil)\n\t}\n\n\t// Check the rest\n\tfor {\n\t\twrapper, tagArgs, err := doc.WrapUntilTag(\"elif\", \"else\", \"endif\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tifNode.wrappers = append(ifNode.wrappers, wrapper)\n\n\t\tif wrapper.Endtag == \"elif\" {\n\t\t\t// elif can take a condition\n\t\t\tcondition, err = tagArgs.ParseExpression()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tifNode.conditions = append(ifNode.conditions, condition)\n\n\t\t\tif tagArgs.Remaining() > 0 {\n\t\t\t\treturn nil, tagArgs.Error(\"Elif-condition is malformed.\", nil)\n\t\t\t}\n\t\t} else {\n\t\t\tif tagArgs.Count() > 0 {\n\t\t\t\t// else/endif can't take any conditions\n\t\t\t\treturn nil, tagArgs.Error(\"Arguments not allowed here.\", nil)\n\t\t\t}\n\t\t}\n\n\t\tif wrapper.Endtag == \"endif\" {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn ifNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"if\", tagIfParser)\n}\n"
        },
        {
          "name": "tags_ifchanged.go",
          "type": "blob",
          "size": 2.5791015625,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n)\n\ntype tagIfchangedNode struct {\n\twatchedExpr []IEvaluator\n\tlastValues  []*Value\n\tlastContent []byte\n\tthenWrapper *NodeWrapper\n\telseWrapper *NodeWrapper\n}\n\nfunc (node *tagIfchangedNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tif len(node.watchedExpr) == 0 {\n\t\t// Check against own rendered body\n\n\t\tbuf := bytes.NewBuffer(make([]byte, 0, 1024)) // 1 KiB\n\t\terr := node.thenWrapper.Execute(ctx, buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tbufBytes := buf.Bytes()\n\t\tif !bytes.Equal(node.lastContent, bufBytes) {\n\t\t\t// Rendered content changed, output it\n\t\t\twriter.Write(bufBytes)\n\t\t\tnode.lastContent = bufBytes\n\t\t}\n\t} else {\n\t\tnowValues := make([]*Value, 0, len(node.watchedExpr))\n\t\tfor _, expr := range node.watchedExpr {\n\t\t\tval, err := expr.Evaluate(ctx)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tnowValues = append(nowValues, val)\n\t\t}\n\n\t\t// Compare old to new values now\n\t\tchanged := len(node.lastValues) == 0\n\n\t\tfor idx, oldVal := range node.lastValues {\n\t\t\tif !oldVal.EqualValueTo(nowValues[idx]) {\n\t\t\t\tchanged = true\n\t\t\t\tbreak // we can stop here because ONE value changed\n\t\t\t}\n\t\t}\n\n\t\tnode.lastValues = nowValues\n\n\t\tif changed {\n\t\t\t// Render thenWrapper\n\t\t\terr := node.thenWrapper.Execute(ctx, writer)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\t// Render elseWrapper\n\t\t\tif node.elseWrapper != nil {\n\t\t\t\terr := node.elseWrapper.Execute(ctx, writer)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc tagIfchangedParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tifchangedNode := &tagIfchangedNode{}\n\n\tfor arguments.Remaining() > 0 {\n\t\t// Parse condition\n\t\texpr, err := arguments.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tifchangedNode.watchedExpr = append(ifchangedNode.watchedExpr, expr)\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Ifchanged-arguments are malformed.\", nil)\n\t}\n\n\t// Wrap then/else-blocks\n\twrapper, endargs, err := doc.WrapUntilTag(\"else\", \"endifchanged\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tifchangedNode.thenWrapper = wrapper\n\n\tif endargs.Count() > 0 {\n\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t}\n\n\tif wrapper.Endtag == \"else\" {\n\t\t// if there's an else in the if-statement, we need the else-Block as well\n\t\twrapper, endargs, err = doc.WrapUntilTag(\"endifchanged\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tifchangedNode.elseWrapper = wrapper\n\n\t\tif endargs.Count() > 0 {\n\t\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t\t}\n\t}\n\n\treturn ifchangedNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"ifchanged\", tagIfchangedParser)\n}\n"
        },
        {
          "name": "tags_ifequal.go",
          "type": "blob",
          "size": 1.658203125,
          "content": "package pongo2\n\ntype tagIfEqualNode struct {\n\tvar1, var2  IEvaluator\n\tthenWrapper *NodeWrapper\n\telseWrapper *NodeWrapper\n}\n\nfunc (node *tagIfEqualNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tr1, err := node.var1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr2, err := node.var2.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresult := r1.EqualValueTo(r2)\n\n\tif result {\n\t\treturn node.thenWrapper.Execute(ctx, writer)\n\t}\n\tif node.elseWrapper != nil {\n\t\treturn node.elseWrapper.Execute(ctx, writer)\n\t}\n\treturn nil\n}\n\nfunc tagIfEqualParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tifequalNode := &tagIfEqualNode{}\n\n\t// Parse two expressions\n\tvar1, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar2, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tifequalNode.var1 = var1\n\tifequalNode.var2 = var2\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"ifequal only takes 2 arguments.\", nil)\n\t}\n\n\t// Wrap then/else-blocks\n\twrapper, endargs, err := doc.WrapUntilTag(\"else\", \"endifequal\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tifequalNode.thenWrapper = wrapper\n\n\tif endargs.Count() > 0 {\n\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t}\n\n\tif wrapper.Endtag == \"else\" {\n\t\t// if there's an else in the if-statement, we need the else-Block as well\n\t\twrapper, endargs, err = doc.WrapUntilTag(\"endifequal\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tifequalNode.elseWrapper = wrapper\n\n\t\tif endargs.Count() > 0 {\n\t\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t\t}\n\t}\n\n\treturn ifequalNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"ifequal\", tagIfEqualParser)\n}\n"
        },
        {
          "name": "tags_ifnotequal.go",
          "type": "blob",
          "size": 1.7001953125,
          "content": "package pongo2\n\ntype tagIfNotEqualNode struct {\n\tvar1, var2  IEvaluator\n\tthenWrapper *NodeWrapper\n\telseWrapper *NodeWrapper\n}\n\nfunc (node *tagIfNotEqualNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tr1, err := node.var1.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\tr2, err := node.var2.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tresult := !r1.EqualValueTo(r2)\n\n\tif result {\n\t\treturn node.thenWrapper.Execute(ctx, writer)\n\t}\n\tif node.elseWrapper != nil {\n\t\treturn node.elseWrapper.Execute(ctx, writer)\n\t}\n\treturn nil\n}\n\nfunc tagIfNotEqualParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tifnotequalNode := &tagIfNotEqualNode{}\n\n\t// Parse two expressions\n\tvar1, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar2, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tifnotequalNode.var1 = var1\n\tifnotequalNode.var2 = var2\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"ifequal only takes 2 arguments.\", nil)\n\t}\n\n\t// Wrap then/else-blocks\n\twrapper, endargs, err := doc.WrapUntilTag(\"else\", \"endifnotequal\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tifnotequalNode.thenWrapper = wrapper\n\n\tif endargs.Count() > 0 {\n\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t}\n\n\tif wrapper.Endtag == \"else\" {\n\t\t// if there's an else in the if-statement, we need the else-Block as well\n\t\twrapper, endargs, err = doc.WrapUntilTag(\"endifnotequal\")\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tifnotequalNode.elseWrapper = wrapper\n\n\t\tif endargs.Count() > 0 {\n\t\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t\t}\n\t}\n\n\treturn ifnotequalNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"ifnotequal\", tagIfNotEqualParser)\n}\n"
        },
        {
          "name": "tags_import.go",
          "type": "blob",
          "size": 2.1630859375,
          "content": "package pongo2\n\nimport (\n\t\"fmt\"\n)\n\ntype tagImportNode struct {\n\tposition *Token\n\tfilename string\n\tmacros   map[string]*tagMacroNode // alias/name -> macro instance\n}\n\nfunc (node *tagImportNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tfor name, macro := range node.macros {\n\t\tfunc(name string, macro *tagMacroNode) {\n\t\t\tctx.Private[name] = func(args ...*Value) (*Value, error) {\n\t\t\t\treturn macro.call(ctx, args...)\n\t\t\t}\n\t\t}(name, macro)\n\t}\n\treturn nil\n}\n\nfunc tagImportParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\timportNode := &tagImportNode{\n\t\tposition: start,\n\t\tmacros:   make(map[string]*tagMacroNode),\n\t}\n\n\tfilenameToken := arguments.MatchType(TokenString)\n\tif filenameToken == nil {\n\t\treturn nil, arguments.Error(\"Import-tag needs a filename as string.\", nil)\n\t}\n\n\timportNode.filename = doc.template.set.resolveFilename(doc.template, filenameToken.Val)\n\n\tif arguments.Remaining() == 0 {\n\t\treturn nil, arguments.Error(\"You must at least specify one macro to import.\", nil)\n\t}\n\n\t// Compile the given template\n\ttpl, err := doc.template.set.FromFile(importNode.filename)\n\tif err != nil {\n\t\treturn nil, err.(*Error).updateFromTokenIfNeeded(doc.template, start)\n\t}\n\n\tfor arguments.Remaining() > 0 {\n\t\tmacroNameToken := arguments.MatchType(TokenIdentifier)\n\t\tif macroNameToken == nil {\n\t\t\treturn nil, arguments.Error(\"Expected macro name (identifier).\", nil)\n\t\t}\n\n\t\tasName := macroNameToken.Val\n\t\tif arguments.Match(TokenKeyword, \"as\") != nil {\n\t\t\taliasToken := arguments.MatchType(TokenIdentifier)\n\t\t\tif aliasToken == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected macro alias name (identifier).\", nil)\n\t\t\t}\n\t\t\tasName = aliasToken.Val\n\t\t}\n\n\t\tmacroInstance, has := tpl.exportedMacros[macroNameToken.Val]\n\t\tif !has {\n\t\t\treturn nil, arguments.Error(fmt.Sprintf(\"Macro '%s' not found (or not exported) in '%s'.\", macroNameToken.Val,\n\t\t\t\timportNode.filename), macroNameToken)\n\t\t}\n\n\t\timportNode.macros[asName] = macroInstance\n\n\t\tif arguments.Remaining() == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tif arguments.Match(TokenSymbol, \",\") == nil {\n\t\t\treturn nil, arguments.Error(\"Expected ','.\", nil)\n\t\t}\n\t}\n\n\treturn importNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"import\", tagImportParser)\n}\n"
        },
        {
          "name": "tags_include.go",
          "type": "blob",
          "size": 4.1279296875,
          "content": "package pongo2\n\ntype tagIncludeNode struct {\n\ttpl               *Template\n\tfilenameEvaluator IEvaluator\n\tlazy              bool\n\tonly              bool\n\tfilename          string\n\twithPairs         map[string]IEvaluator\n\tifExists          bool\n}\n\nfunc (node *tagIncludeNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\t// Building the context for the template\n\tincludeCtx := make(Context)\n\n\t// Fill the context with all data from the parent\n\tif !node.only {\n\t\tincludeCtx.Update(ctx.Public)\n\t\tincludeCtx.Update(ctx.Private)\n\t}\n\n\t// Put all custom with-pairs into the context\n\tfor key, value := range node.withPairs {\n\t\tval, err := value.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tincludeCtx[key] = val\n\t}\n\n\t// Execute the template\n\tif node.lazy {\n\t\t// Evaluate the filename\n\t\tfilename, err := node.filenameEvaluator.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif filename.String() == \"\" {\n\t\t\treturn ctx.Error(\"Filename for 'include'-tag evaluated to an empty string.\", nil)\n\t\t}\n\n\t\t// Get include-filename\n\t\tincludedFilename := ctx.template.set.resolveFilename(ctx.template, filename.String())\n\n\t\tincludedTpl, err2 := ctx.template.set.FromFile(includedFilename)\n\t\tif err2 != nil {\n\t\t\t// if this is ReadFile error, and \"if_exists\" flag is enabled\n\t\t\tif node.ifExists && err2.(*Error).Sender == \"fromfile\" {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err2.(*Error)\n\t\t}\n\t\terr2 = includedTpl.ExecuteWriter(includeCtx, writer)\n\t\tif err2 != nil {\n\t\t\treturn err2.(*Error)\n\t\t}\n\t\treturn nil\n\t}\n\t// Template is already parsed with static filename\n\terr := node.tpl.ExecuteWriter(includeCtx, writer)\n\tif err != nil {\n\t\treturn err.(*Error)\n\t}\n\treturn nil\n}\n\ntype tagIncludeEmptyNode struct{}\n\nfunc (node *tagIncludeEmptyNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\treturn nil\n}\n\nfunc tagIncludeParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tincludeNode := &tagIncludeNode{\n\t\twithPairs: make(map[string]IEvaluator),\n\t}\n\n\tif filenameToken := arguments.MatchType(TokenString); filenameToken != nil {\n\t\t// prepared, static template\n\n\t\t// \"if_exists\" flag\n\t\tifExists := arguments.Match(TokenIdentifier, \"if_exists\") != nil\n\n\t\t// Get include-filename\n\t\tincludedFilename := doc.template.set.resolveFilename(doc.template, filenameToken.Val)\n\n\t\t// Parse the parent\n\t\tincludeNode.filename = includedFilename\n\t\tincludedTpl, err := doc.template.set.FromFile(includedFilename)\n\t\tif err != nil {\n\t\t\t// if this is ReadFile error, and \"if_exists\" token presents we should create and empty node\n\t\t\tif err.(*Error).Sender == \"fromfile\" && ifExists {\n\t\t\t\treturn &tagIncludeEmptyNode{}, nil\n\t\t\t}\n\t\t\treturn nil, err.(*Error).updateFromTokenIfNeeded(doc.template, filenameToken)\n\t\t}\n\t\tincludeNode.tpl = includedTpl\n\t} else {\n\t\t// No String, then the user wants to use lazy-evaluation (slower, but possible)\n\t\tfilenameEvaluator, err := arguments.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err.updateFromTokenIfNeeded(doc.template, filenameToken)\n\t\t}\n\t\tincludeNode.filenameEvaluator = filenameEvaluator\n\t\tincludeNode.lazy = true\n\t\tincludeNode.ifExists = arguments.Match(TokenIdentifier, \"if_exists\") != nil // \"if_exists\" flag\n\t}\n\n\t// After having parsed the filename we're gonna parse the with+only options\n\tif arguments.Match(TokenIdentifier, \"with\") != nil {\n\t\tfor arguments.Remaining() > 0 {\n\t\t\t// We have at least one key=expr pair (because of starting \"with\")\n\t\t\tkeyToken := arguments.MatchType(TokenIdentifier)\n\t\t\tif keyToken == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected an identifier\", nil)\n\t\t\t}\n\t\t\tif arguments.Match(TokenSymbol, \"=\") == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected '='.\", nil)\n\t\t\t}\n\t\t\tvalueExpr, err := arguments.ParseExpression()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err.updateFromTokenIfNeeded(doc.template, keyToken)\n\t\t\t}\n\n\t\t\tincludeNode.withPairs[keyToken.Val] = valueExpr\n\n\t\t\t// Only?\n\t\t\tif arguments.Match(TokenIdentifier, \"only\") != nil {\n\t\t\t\tincludeNode.only = true\n\t\t\t\tbreak // stop parsing arguments because it's the last option\n\t\t\t}\n\t\t}\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed 'include'-tag arguments.\", nil)\n\t}\n\n\treturn includeNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"include\", tagIncludeParser)\n}\n"
        },
        {
          "name": "tags_lorem.go",
          "type": "blob",
          "size": 6.423828125,
          "content": "package pongo2\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst maxLoremCount = 100000\n\nvar (\n\ttagLoremParagraphs = strings.Split(tagLoremText, \"\\n\")\n\ttagLoremWords      = strings.Fields(tagLoremText)\n)\n\ntype tagLoremNode struct {\n\tposition *Token\n\tcount    int    // number of paragraphs\n\tmethod   string // w = words, p = HTML paragraphs, b = plain-text (default is b)\n\trandom   bool   // does not use the default paragraph \"Lorem ipsum dolor sit amet, ...\"\n}\n\nfunc (node *tagLoremNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tif node.count > maxLoremCount {\n\t\treturn ctx.Error(fmt.Sprintf(\"max count for lorem is %d\", maxLoremCount), node.position)\n\t}\n\n\tswitch node.method {\n\tcase \"b\":\n\t\tif node.random {\n\t\t\tfor i := 0; i < node.count; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\twriter.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\tpar := tagLoremParagraphs[rand.Intn(len(tagLoremParagraphs))]\n\t\t\t\twriter.WriteString(par)\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := 0; i < node.count; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\twriter.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\tpar := tagLoremParagraphs[i%len(tagLoremParagraphs)]\n\t\t\t\twriter.WriteString(par)\n\t\t\t}\n\t\t}\n\tcase \"w\":\n\t\tif node.random {\n\t\t\tfor i := 0; i < node.count; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\twriter.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\tword := tagLoremWords[rand.Intn(len(tagLoremWords))]\n\t\t\t\twriter.WriteString(word)\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := 0; i < node.count; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\twriter.WriteString(\" \")\n\t\t\t\t}\n\t\t\t\tword := tagLoremWords[i%len(tagLoremWords)]\n\t\t\t\twriter.WriteString(word)\n\t\t\t}\n\t\t}\n\tcase \"p\":\n\t\tif node.random {\n\t\t\tfor i := 0; i < node.count; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\twriter.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\twriter.WriteString(\"<p>\")\n\t\t\t\tpar := tagLoremParagraphs[rand.Intn(len(tagLoremParagraphs))]\n\t\t\t\twriter.WriteString(par)\n\t\t\t\twriter.WriteString(\"</p>\")\n\t\t\t}\n\t\t} else {\n\t\t\tfor i := 0; i < node.count; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\twriter.WriteString(\"\\n\")\n\t\t\t\t}\n\t\t\t\twriter.WriteString(\"<p>\")\n\t\t\t\tpar := tagLoremParagraphs[i%len(tagLoremParagraphs)]\n\t\t\t\twriter.WriteString(par)\n\t\t\t\twriter.WriteString(\"</p>\")\n\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn ctx.OrigError(fmt.Errorf(\"unsupported method: %s\", node.method), nil)\n\t}\n\n\treturn nil\n}\n\nfunc tagLoremParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tloremNode := &tagLoremNode{\n\t\tposition: start,\n\t\tcount:    1,\n\t\tmethod:   \"b\",\n\t}\n\n\tif countToken := arguments.MatchType(TokenNumber); countToken != nil {\n\t\tloremNode.count = AsValue(countToken.Val).Integer()\n\t}\n\n\tif methodToken := arguments.MatchType(TokenIdentifier); methodToken != nil {\n\t\tif methodToken.Val != \"w\" && methodToken.Val != \"p\" && methodToken.Val != \"b\" {\n\t\t\treturn nil, arguments.Error(\"lorem-method must be either 'w', 'p' or 'b'.\", nil)\n\t\t}\n\n\t\tloremNode.method = methodToken.Val\n\t}\n\n\tif arguments.MatchOne(TokenIdentifier, \"random\") != nil {\n\t\tloremNode.random = true\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed lorem-tag arguments.\", nil)\n\t}\n\n\treturn loremNode, nil\n}\n\nfunc init() {\n\trand.Seed(time.Now().Unix())\n\n\tRegisterTag(\"lorem\", tagLoremParser)\n}\n\nconst tagLoremText = `Lorem ipsum dolor sit amet, consectetur adipisici elit, sed eiusmod tempor incidunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquid ex ea commodi consequat. Quis aute iure reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint obcaecat cupiditat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nDuis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.\nUt wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat. Duis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis at vero eros et accumsan et iusto odio dignissim qui blandit praesent luptatum zzril delenit augue duis dolore te feugait nulla facilisi.\nNam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat. Ut wisi enim ad minim veniam, quis nostrud exerci tation ullamcorper suscipit lobortis nisl ut aliquip ex ea commodo consequat.\nDuis autem vel eum iriure dolor in hendrerit in vulputate velit esse molestie consequat, vel illum dolore eu feugiat nulla facilisis.\nAt vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, At accusam aliquyam diam diam dolore dolores duo eirmod eos erat, et nonumy sed tempor et et invidunt justo labore Stet clita ea et gubergren, kasd magna no rebum. sanctus sea sed takimata ut vero voluptua. est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat.\nConsetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet.`\n"
        },
        {
          "name": "tags_macro.go",
          "type": "blob",
          "size": 3.9091796875,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n)\n\nconst maxMacroDepth = 1000\n\ntype tagMacroNode struct {\n\tposition  *Token\n\tname      string\n\targsOrder []string\n\targs      map[string]IEvaluator\n\texported  bool\n\n\twrapper *NodeWrapper\n}\n\nfunc (node *tagMacroNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tctx.Private[node.name] = func(args ...*Value) (*Value, error) {\n\t\tctx.macroDepth++\n\t\tdefer func() {\n\t\t\tctx.macroDepth--\n\t\t}()\n\n\t\tif ctx.macroDepth > maxMacroDepth {\n\t\t\treturn nil, ctx.Error(fmt.Sprintf(\"maximum recursive macro call depth reached (max is %v)\", maxMacroDepth), node.position)\n\t\t}\n\n\t\treturn node.call(ctx, args...)\n\t}\n\n\treturn nil\n}\n\nfunc (node *tagMacroNode) call(ctx *ExecutionContext, args ...*Value) (*Value, error) {\n\targsCtx := make(Context)\n\n\tfor k, v := range node.args {\n\t\tif v == nil {\n\t\t\t// User did not provided a default value\n\t\t\targsCtx[k] = nil\n\t\t} else {\n\t\t\t// Evaluate the default value\n\t\t\tvalueExpr, err := v.Evaluate(ctx)\n\t\t\tif err != nil {\n\t\t\t\tctx.Logf(err.Error())\n\t\t\t\treturn AsSafeValue(\"\"), err\n\t\t\t}\n\n\t\t\targsCtx[k] = valueExpr\n\t\t}\n\t}\n\n\tif len(args) > len(node.argsOrder) {\n\t\t// Too many arguments, we're ignoring them and just logging into debug mode.\n\t\terr := ctx.Error(fmt.Sprintf(\"Macro '%s' called with too many arguments (%d instead of %d).\",\n\t\t\tnode.name, len(args), len(node.argsOrder)), nil).updateFromTokenIfNeeded(ctx.template, node.position)\n\n\t\treturn AsSafeValue(\"\"), err\n\t}\n\n\t// Make a context for the macro execution\n\tmacroCtx := NewChildExecutionContext(ctx)\n\n\t// Register all arguments in the private context\n\tmacroCtx.Private.Update(argsCtx)\n\n\tfor idx, argValue := range args {\n\t\tmacroCtx.Private[node.argsOrder[idx]] = argValue.Interface()\n\t}\n\n\tvar b bytes.Buffer\n\terr := node.wrapper.Execute(macroCtx, &b)\n\tif err != nil {\n\t\treturn AsSafeValue(\"\"), err.updateFromTokenIfNeeded(ctx.template, node.position)\n\t}\n\n\treturn AsSafeValue(b.String()), nil\n}\n\nfunc tagMacroParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tmacroNode := &tagMacroNode{\n\t\tposition: start,\n\t\targs:     make(map[string]IEvaluator),\n\t}\n\n\tnameToken := arguments.MatchType(TokenIdentifier)\n\tif nameToken == nil {\n\t\treturn nil, arguments.Error(\"Macro-tag needs at least an identifier as name.\", nil)\n\t}\n\tmacroNode.name = nameToken.Val\n\n\tif arguments.MatchOne(TokenSymbol, \"(\") == nil {\n\t\treturn nil, arguments.Error(\"Expected '('.\", nil)\n\t}\n\n\tfor arguments.Match(TokenSymbol, \")\") == nil {\n\t\targNameToken := arguments.MatchType(TokenIdentifier)\n\t\tif argNameToken == nil {\n\t\t\treturn nil, arguments.Error(\"Expected argument name as identifier.\", nil)\n\t\t}\n\t\tmacroNode.argsOrder = append(macroNode.argsOrder, argNameToken.Val)\n\n\t\tif arguments.Match(TokenSymbol, \"=\") != nil {\n\t\t\t// Default expression follows\n\t\t\targDefaultExpr, err := arguments.ParseExpression()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmacroNode.args[argNameToken.Val] = argDefaultExpr\n\t\t} else {\n\t\t\t// No default expression\n\t\t\tmacroNode.args[argNameToken.Val] = nil\n\t\t}\n\n\t\tif arguments.Match(TokenSymbol, \")\") != nil {\n\t\t\tbreak\n\t\t}\n\t\tif arguments.Match(TokenSymbol, \",\") == nil {\n\t\t\treturn nil, arguments.Error(\"Expected ',' or ')'.\", nil)\n\t\t}\n\t}\n\n\tif arguments.Match(TokenKeyword, \"export\") != nil {\n\t\tmacroNode.exported = true\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed macro-tag.\", nil)\n\t}\n\n\t// Body wrapping\n\twrapper, endargs, err := doc.WrapUntilTag(\"endmacro\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmacroNode.wrapper = wrapper\n\n\tif endargs.Count() > 0 {\n\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t}\n\n\tif macroNode.exported {\n\t\t// Now register the macro if it wants to be exported\n\t\t_, has := doc.template.exportedMacros[macroNode.name]\n\t\tif has {\n\t\t\treturn nil, doc.Error(fmt.Sprintf(\"another macro with name '%s' already exported\", macroNode.name), start)\n\t\t}\n\t\tdoc.template.exportedMacros[macroNode.name] = macroNode\n\t}\n\n\treturn macroNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"macro\", tagMacroParser)\n}\n"
        },
        {
          "name": "tags_now.go",
          "type": "blob",
          "size": 0.9365234375,
          "content": "package pongo2\n\nimport (\n\t\"time\"\n)\n\ntype tagNowNode struct {\n\tposition *Token\n\tformat   string\n\tfake     bool\n}\n\nfunc (node *tagNowNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvar t time.Time\n\tif node.fake {\n\t\tt = time.Date(2014, time.February, 05, 18, 31, 45, 00, time.UTC)\n\t} else {\n\t\tt = time.Now()\n\t}\n\n\twriter.WriteString(t.Format(node.format))\n\n\treturn nil\n}\n\nfunc tagNowParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tnowNode := &tagNowNode{\n\t\tposition: start,\n\t}\n\n\tformatToken := arguments.MatchType(TokenString)\n\tif formatToken == nil {\n\t\treturn nil, arguments.Error(\"Expected a format string.\", nil)\n\t}\n\tnowNode.format = formatToken.Val\n\n\tif arguments.MatchOne(TokenIdentifier, \"fake\") != nil {\n\t\tnowNode.fake = true\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed now-tag arguments.\", nil)\n\t}\n\n\treturn nowNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"now\", tagNowParser)\n}\n"
        },
        {
          "name": "tags_set.go",
          "type": "blob",
          "size": 1.0478515625,
          "content": "package pongo2\n\ntype tagSetNode struct {\n\tname       string\n\texpression IEvaluator\n}\n\nfunc (node *tagSetNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\t// Evaluate expression\n\tvalue, err := node.expression.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tctx.Private[node.name] = value\n\treturn nil\n}\n\nfunc tagSetParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tnode := &tagSetNode{}\n\n\t// Parse variable name\n\ttypeToken := arguments.MatchType(TokenIdentifier)\n\tif typeToken == nil {\n\t\treturn nil, arguments.Error(\"Expected an identifier.\", nil)\n\t}\n\tnode.name = typeToken.Val\n\n\tif arguments.Match(TokenSymbol, \"=\") == nil {\n\t\treturn nil, arguments.Error(\"Expected '='.\", nil)\n\t}\n\n\t// Variable expression\n\tkeyExpression, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnode.expression = keyExpression\n\n\t// Remaining arguments\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed 'set'-tag arguments.\", nil)\n\t}\n\n\treturn node, nil\n}\n\nfunc init() {\n\tRegisterTag(\"set\", tagSetParser)\n}\n"
        },
        {
          "name": "tags_spaceless.go",
          "type": "blob",
          "size": 1.0439453125,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n\t\"regexp\"\n)\n\ntype tagSpacelessNode struct {\n\twrapper *NodeWrapper\n}\n\nvar tagSpacelessRegexp = regexp.MustCompile(`(?U:(<.*>))([\\t\\n\\v\\f\\r ]+)(?U:(<.*>))`)\n\nfunc (node *tagSpacelessNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tb := bytes.NewBuffer(make([]byte, 0, 1024)) // 1 KiB\n\n\terr := node.wrapper.Execute(ctx, b)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ts := b.String()\n\t// Repeat this recursively\n\tchanged := true\n\tfor changed {\n\t\ts2 := tagSpacelessRegexp.ReplaceAllString(s, \"$1$3\")\n\t\tchanged = s != s2\n\t\ts = s2\n\t}\n\n\twriter.WriteString(s)\n\n\treturn nil\n}\n\nfunc tagSpacelessParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tspacelessNode := &tagSpacelessNode{}\n\n\twrapper, _, err := doc.WrapUntilTag(\"endspaceless\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tspacelessNode.wrapper = wrapper\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed spaceless-tag arguments.\", nil)\n\t}\n\n\treturn spacelessNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"spaceless\", tagSpacelessParser)\n}\n"
        },
        {
          "name": "tags_ssi.go",
          "type": "blob",
          "size": 1.6318359375,
          "content": "package pongo2\n\nimport \"os\"\n\ntype tagSSINode struct {\n\tfilename string\n\tcontent  string\n\ttemplate *Template\n}\n\nfunc (node *tagSSINode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tif node.template != nil {\n\t\t// Execute the template within the current context\n\t\tincludeCtx := make(Context)\n\t\tincludeCtx.Update(ctx.Public)\n\t\tincludeCtx.Update(ctx.Private)\n\n\t\terr := node.template.execute(includeCtx, writer)\n\t\tif err != nil {\n\t\t\treturn err.(*Error)\n\t\t}\n\t} else {\n\t\t// Just print out the content\n\t\twriter.WriteString(node.content)\n\t}\n\treturn nil\n}\n\nfunc tagSSIParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tSSINode := &tagSSINode{}\n\n\tif fileToken := arguments.MatchType(TokenString); fileToken != nil {\n\t\tSSINode.filename = fileToken.Val\n\n\t\tif arguments.Match(TokenIdentifier, \"parsed\") != nil {\n\t\t\t// parsed\n\t\t\ttemporaryTpl, err := doc.template.set.FromFile(doc.template.set.resolveFilename(doc.template, fileToken.Val))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err.(*Error).updateFromTokenIfNeeded(doc.template, fileToken)\n\t\t\t}\n\t\t\tSSINode.template = temporaryTpl\n\t\t} else {\n\t\t\t// plaintext\n\t\t\tbuf, err := os.ReadFile(doc.template.set.resolveFilename(doc.template, fileToken.Val))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, (&Error{\n\t\t\t\t\tSender:    \"tag:ssi\",\n\t\t\t\t\tOrigError: err,\n\t\t\t\t}).updateFromTokenIfNeeded(doc.template, fileToken)\n\t\t\t}\n\t\t\tSSINode.content = string(buf)\n\t\t}\n\t} else {\n\t\treturn nil, arguments.Error(\"First argument must be a string.\", nil)\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed SSI-tag argument.\", nil)\n\t}\n\n\treturn SSINode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"ssi\", tagSSIParser)\n}\n"
        },
        {
          "name": "tags_templatetag.go",
          "type": "blob",
          "size": 1.0537109375,
          "content": "package pongo2\n\ntype tagTemplateTagNode struct {\n\tcontent string\n}\n\nvar templateTagMapping = map[string]string{\n\t\"openblock\":     \"{%\",\n\t\"closeblock\":    \"%}\",\n\t\"openvariable\":  \"{{\",\n\t\"closevariable\": \"}}\",\n\t\"openbrace\":     \"{\",\n\t\"closebrace\":    \"}\",\n\t\"opencomment\":   \"{#\",\n\t\"closecomment\":  \"#}\",\n}\n\nfunc (node *tagTemplateTagNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\twriter.WriteString(node.content)\n\treturn nil\n}\n\nfunc tagTemplateTagParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\tttNode := &tagTemplateTagNode{}\n\n\tif argToken := arguments.MatchType(TokenIdentifier); argToken != nil {\n\t\toutput, found := templateTagMapping[argToken.Val]\n\t\tif !found {\n\t\t\treturn nil, arguments.Error(\"Argument not found\", argToken)\n\t\t}\n\t\tttNode.content = output\n\t} else {\n\t\treturn nil, arguments.Error(\"Identifier expected.\", nil)\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed templatetag-tag argument.\", nil)\n\t}\n\n\treturn ttNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"templatetag\", tagTemplateTagParser)\n}\n"
        },
        {
          "name": "tags_widthratio.go",
          "type": "blob",
          "size": 1.6162109375,
          "content": "package pongo2\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype tagWidthratioNode struct {\n\tposition     *Token\n\tcurrent, max IEvaluator\n\twidth        IEvaluator\n\tctxName      string\n}\n\nfunc (node *tagWidthratioNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tcurrent, err := node.current.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmax, err := node.max.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\twidth, err := node.width.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvalue := int(math.Ceil(current.Float()/max.Float()*width.Float() + 0.5))\n\n\tif node.ctxName == \"\" {\n\t\twriter.WriteString(fmt.Sprintf(\"%d\", value))\n\t} else {\n\t\tctx.Private[node.ctxName] = value\n\t}\n\n\treturn nil\n}\n\nfunc tagWidthratioParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\twidthratioNode := &tagWidthratioNode{\n\t\tposition: start,\n\t}\n\n\tcurrent, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twidthratioNode.current = current\n\n\tmax, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twidthratioNode.max = max\n\n\twidth, err := arguments.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twidthratioNode.width = width\n\n\tif arguments.MatchOne(TokenKeyword, \"as\") != nil {\n\t\t// Name follows\n\t\tnameToken := arguments.MatchType(TokenIdentifier)\n\t\tif nameToken == nil {\n\t\t\treturn nil, arguments.Error(\"Expected name (identifier).\", nil)\n\t\t}\n\t\twidthratioNode.ctxName = nameToken.Val\n\t}\n\n\tif arguments.Remaining() > 0 {\n\t\treturn nil, arguments.Error(\"Malformed widthratio-tag arguments.\", nil)\n\t}\n\n\treturn widthratioNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"widthratio\", tagWidthratioParser)\n}\n"
        },
        {
          "name": "tags_with.go",
          "type": "blob",
          "size": 2.2421875,
          "content": "package pongo2\n\ntype tagWithNode struct {\n\twithPairs map[string]IEvaluator\n\twrapper   *NodeWrapper\n}\n\nfunc (node *tagWithNode) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\t// new context for block\n\twithctx := NewChildExecutionContext(ctx)\n\n\t// Put all custom with-pairs into the context\n\tfor key, value := range node.withPairs {\n\t\tval, err := value.Evaluate(ctx)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\twithctx.Private[key] = val\n\t}\n\n\treturn node.wrapper.Execute(withctx, writer)\n}\n\nfunc tagWithParser(doc *Parser, start *Token, arguments *Parser) (INodeTag, *Error) {\n\twithNode := &tagWithNode{\n\t\twithPairs: make(map[string]IEvaluator),\n\t}\n\n\tif arguments.Count() == 0 {\n\t\treturn nil, arguments.Error(\"Tag 'with' requires at least one argument.\", nil)\n\t}\n\n\twrapper, endargs, err := doc.WrapUntilTag(\"endwith\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\twithNode.wrapper = wrapper\n\n\tif endargs.Count() > 0 {\n\t\treturn nil, endargs.Error(\"Arguments not allowed here.\", nil)\n\t}\n\n\t// Scan through all arguments to see which style the user uses (old or new style).\n\t// If we find any \"as\" keyword we will enforce old style; otherwise we will use new style.\n\toldStyle := false // by default we're using the new_style\n\tfor i := 0; i < arguments.Count(); i++ {\n\t\tif arguments.PeekN(i, TokenKeyword, \"as\") != nil {\n\t\t\toldStyle = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tfor arguments.Remaining() > 0 {\n\t\tif oldStyle {\n\t\t\tvalueExpr, err := arguments.ParseExpression()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tif arguments.Match(TokenKeyword, \"as\") == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected 'as' keyword.\", nil)\n\t\t\t}\n\t\t\tkeyToken := arguments.MatchType(TokenIdentifier)\n\t\t\tif keyToken == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected an identifier\", nil)\n\t\t\t}\n\t\t\twithNode.withPairs[keyToken.Val] = valueExpr\n\t\t} else {\n\t\t\tkeyToken := arguments.MatchType(TokenIdentifier)\n\t\t\tif keyToken == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected an identifier\", nil)\n\t\t\t}\n\t\t\tif arguments.Match(TokenSymbol, \"=\") == nil {\n\t\t\t\treturn nil, arguments.Error(\"Expected '='.\", nil)\n\t\t\t}\n\t\t\tvalueExpr, err := arguments.ParseExpression()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\twithNode.withPairs[keyToken.Val] = valueExpr\n\t\t}\n\t}\n\n\treturn withNode, nil\n}\n\nfunc init() {\n\tRegisterTag(\"with\", tagWithParser)\n}\n"
        },
        {
          "name": "template.go",
          "type": "blob",
          "size": 7.009765625,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n)\n\ntype TemplateWriter interface {\n\tio.Writer\n\tWriteString(string) (int, error)\n}\n\ntype templateWriter struct {\n\tw io.Writer\n}\n\nfunc (tw *templateWriter) WriteString(s string) (int, error) {\n\treturn tw.w.Write([]byte(s))\n}\n\nfunc (tw *templateWriter) Write(b []byte) (int, error) {\n\treturn tw.w.Write(b)\n}\n\ntype Template struct {\n\tset *TemplateSet\n\n\t// Input\n\tisTplString bool\n\tname        string\n\ttpl         string\n\tsize        int\n\n\t// Calculation\n\ttokens []*Token\n\tparser *Parser\n\n\t// first come, first serve (it's important to not override existing entries in here)\n\tlevel          int\n\tparent         *Template\n\tchild          *Template\n\tblocks         map[string]*NodeWrapper\n\texportedMacros map[string]*tagMacroNode\n\n\t// Output\n\troot *nodeDocument\n\n\t// Options allow you to change the behavior of template-engine.\n\t// You can change the options before calling the Execute method.\n\tOptions *Options\n}\n\nfunc newTemplateString(set *TemplateSet, tpl []byte) (*Template, error) {\n\treturn newTemplate(set, \"<string>\", true, tpl)\n}\n\nfunc newTemplate(set *TemplateSet, name string, isTplString bool, tpl []byte) (*Template, error) {\n\tstrTpl := string(tpl)\n\n\t// Create the template\n\tt := &Template{\n\t\tset:            set,\n\t\tisTplString:    isTplString,\n\t\tname:           name,\n\t\ttpl:            strTpl,\n\t\tsize:           len(strTpl),\n\t\tblocks:         make(map[string]*NodeWrapper),\n\t\texportedMacros: make(map[string]*tagMacroNode),\n\t\tOptions:        newOptions(),\n\t}\n\t// Copy all settings from another Options.\n\tt.Options.Update(set.Options)\n\n\t// Tokenize it\n\ttokens, err := lex(name, strTpl)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tt.tokens = tokens\n\n\t// For debugging purposes, show all tokens:\n\t/*for i, t := range tokens {\n\t\tfmt.Printf(\"%3d. %s\\n\", i, t)\n\t}*/\n\n\t// Parse it\n\terr = t.parse()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn t, nil\n}\n\nfunc (tpl *Template) newContextForExecution(context Context) (*Template, *ExecutionContext, error) {\n\tif tpl.Options.TrimBlocks || tpl.Options.LStripBlocks {\n\t\t// Issue #94 https://github.com/flosch/pongo2/issues/94\n\t\t// If an application configures pongo2 template to trim_blocks,\n\t\t// the first newline after a template tag is removed automatically (like in PHP).\n\t\tprev := &Token{\n\t\t\tTyp: TokenHTML,\n\t\t\tVal: \"\\n\",\n\t\t}\n\n\t\tfor _, t := range tpl.tokens {\n\t\t\tif tpl.Options.LStripBlocks {\n\t\t\t\tif prev.Typ == TokenHTML && t.Typ != TokenHTML && t.Val == \"{%\" {\n\t\t\t\t\tprev.Val = strings.TrimRight(prev.Val, \"\\t \")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif tpl.Options.TrimBlocks {\n\t\t\t\tif prev.Typ != TokenHTML && t.Typ == TokenHTML && prev.Val == \"%}\" {\n\t\t\t\t\tif len(t.Val) > 0 && t.Val[0] == '\\n' {\n\t\t\t\t\t\tt.Val = t.Val[1:len(t.Val)]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprev = t\n\t\t}\n\t}\n\n\t// Determine the parent to be executed (for template inheritance)\n\tparent := tpl\n\tfor parent.parent != nil {\n\t\tparent = parent.parent\n\t}\n\n\t// Create context if none is given\n\tnewContext := make(Context)\n\tnewContext.Update(tpl.set.Globals)\n\n\tif context != nil {\n\t\tnewContext.Update(context)\n\n\t\tif len(newContext) > 0 {\n\t\t\t// Check for context name syntax\n\t\t\terr := newContext.checkForValidIdentifiers()\n\t\t\tif err != nil {\n\t\t\t\treturn parent, nil, err\n\t\t\t}\n\n\t\t\t// Check for clashes with macro names\n\t\t\tfor k := range newContext {\n\t\t\t\t_, has := tpl.exportedMacros[k]\n\t\t\t\tif has {\n\t\t\t\t\treturn parent, nil, &Error{\n\t\t\t\t\t\tFilename:  tpl.name,\n\t\t\t\t\t\tSender:    \"execution\",\n\t\t\t\t\t\tOrigError: fmt.Errorf(\"context key name '%s' clashes with macro '%s'\", k, k),\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Create operational context\n\tctx := newExecutionContext(parent, newContext)\n\n\treturn parent, ctx, nil\n}\n\nfunc (tpl *Template) execute(context Context, writer TemplateWriter) error {\n\tparent, ctx, err := tpl.newContextForExecution(context)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Run the selected document\n\tif err := parent.root.Execute(ctx, writer); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (tpl *Template) newTemplateWriterAndExecute(context Context, writer io.Writer) error {\n\treturn tpl.execute(context, &templateWriter{w: writer})\n}\n\nfunc (tpl *Template) newBufferAndExecute(context Context) (*bytes.Buffer, error) {\n\t// Create output buffer\n\t// We assume that the rendered template will be 30% larger\n\tbuffer := bytes.NewBuffer(make([]byte, 0, int(float64(tpl.size)*1.3)))\n\tif err := tpl.execute(context, buffer); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer, nil\n}\n\n// Executes the template with the given context and writes to writer (io.Writer)\n// on success. Context can be nil. Nothing is written on error; instead the error\n// is being returned.\nfunc (tpl *Template) ExecuteWriter(context Context, writer io.Writer) error {\n\tbuf, err := tpl.newBufferAndExecute(context)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = buf.WriteTo(writer)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// Same as ExecuteWriter. The only difference between both functions is that\n// this function might already have written parts of the generated template in the\n// case of an execution error because there's no intermediate buffer involved for\n// performance reasons. This is handy if you need high performance template\n// generation or if you want to manage your own pool of buffers.\nfunc (tpl *Template) ExecuteWriterUnbuffered(context Context, writer io.Writer) error {\n\treturn tpl.newTemplateWriterAndExecute(context, writer)\n}\n\n// Executes the template and returns the rendered template as a []byte\nfunc (tpl *Template) ExecuteBytes(context Context) ([]byte, error) {\n\t// Execute template\n\tbuffer, err := tpl.newBufferAndExecute(context)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer.Bytes(), nil\n}\n\n// Executes the template and returns the rendered template as a string\nfunc (tpl *Template) Execute(context Context) (string, error) {\n\t// Execute template\n\tbuffer, err := tpl.newBufferAndExecute(context)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn buffer.String(), nil\n}\n\nfunc (tpl *Template) ExecuteBlocks(context Context, blocks []string) (map[string]string, error) {\n\tvar parents []*Template\n\tresult := make(map[string]string)\n\n\tparent := tpl\n\tfor parent != nil {\n\t\t// We only want to execute the template if it has a block we want\n\t\tfor _, block := range blocks {\n\t\t\tif _, ok := tpl.blocks[block]; ok {\n\t\t\t\tparents = append(parents, parent)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tparent = parent.parent\n\t}\n\n\tfor _, t := range parents {\n\t\tvar buffer *bytes.Buffer\n\t\tvar ctx *ExecutionContext\n\t\tvar err error\n\t\tfor _, blockName := range blocks {\n\t\t\tif _, ok := result[blockName]; ok {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif blockWrapper, ok := t.blocks[blockName]; ok {\n\t\t\t\t// assign the buffer if we haven't done so\n\t\t\t\tif buffer == nil {\n\t\t\t\t\tbuffer = bytes.NewBuffer(make([]byte, 0, int(float64(t.size)*1.3)))\n\t\t\t\t}\n\t\t\t\t// assign the context if we haven't done so\n\t\t\t\tif ctx == nil {\n\t\t\t\t\t_, ctx, err = t.newContextForExecution(context)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbErr := blockWrapper.Execute(ctx, buffer)\n\t\t\t\tif bErr != nil {\n\t\t\t\t\treturn nil, bErr\n\t\t\t\t}\n\t\t\t\tresult[blockName] = buffer.String()\n\t\t\t\tbuffer.Reset()\n\t\t\t}\n\t\t}\n\t\t// We have found all blocks\n\t\tif len(blocks) == len(result) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn result, nil\n}\n"
        },
        {
          "name": "template_loader.go",
          "type": "blob",
          "size": 6.330078125,
          "content": "package pongo2\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// FSLoader supports the fs.FS interface for loading templates\ntype FSLoader struct {\n\tfs fs.FS\n}\n\nfunc NewFSLoader(fs fs.FS) *FSLoader {\n\treturn &FSLoader{\n\t\tfs: fs,\n\t}\n}\n\nfunc (l *FSLoader) Abs(base, name string) string {\n\treturn filepath.Join(filepath.Dir(base), name)\n}\n\nfunc (l *FSLoader) Get(path string) (io.Reader, error) {\n\treturn l.fs.Open(path)\n}\n\n// LocalFilesystemLoader represents a local filesystem loader with basic\n// BaseDirectory capabilities. The access to the local filesystem is unrestricted.\ntype LocalFilesystemLoader struct {\n\tbaseDir string\n}\n\n// MustNewLocalFileSystemLoader creates a new LocalFilesystemLoader instance\n// and panics if there's any error during instantiation. The parameters\n// are the same like NewLocalFileSystemLoader.\nfunc MustNewLocalFileSystemLoader(baseDir string) *LocalFilesystemLoader {\n\tfs, err := NewLocalFileSystemLoader(baseDir)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\treturn fs\n}\n\n// NewLocalFileSystemLoader creates a new LocalFilesystemLoader and allows\n// templatesto be loaded from disk (unrestricted). If any base directory\n// is given (or being set using SetBaseDir), this base directory is being used\n// for path calculation in template inclusions/imports. Otherwise the path\n// is calculated based relatively to the including template's path.\nfunc NewLocalFileSystemLoader(baseDir string) (*LocalFilesystemLoader, error) {\n\tfs := &LocalFilesystemLoader{}\n\tif baseDir != \"\" {\n\t\tif err := fs.SetBaseDir(baseDir); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn fs, nil\n}\n\n// SetBaseDir sets the template's base directory. This directory will\n// be used for any relative path in filters, tags and From*-functions to determine\n// your template. See the comment for NewLocalFileSystemLoader as well.\nfunc (fs *LocalFilesystemLoader) SetBaseDir(path string) error {\n\t// Make the path absolute\n\tif !filepath.IsAbs(path) {\n\t\tabs, err := filepath.Abs(path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tpath = abs\n\t}\n\n\t// Check for existence\n\tfi, err := os.Stat(path)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !fi.IsDir() {\n\t\treturn fmt.Errorf(\"the given path '%s' is not a directory\", path)\n\t}\n\n\tfs.baseDir = path\n\treturn nil\n}\n\n// Get reads the path's content from your local filesystem.\nfunc (fs *LocalFilesystemLoader) Get(path string) (io.Reader, error) {\n\tbuf, err := os.ReadFile(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn bytes.NewReader(buf), nil\n}\n\n// Abs resolves a filename relative to the base directory. Absolute paths are allowed.\n// When there's no base dir set, the absolute path to the filename\n// will be calculated based on either the provided base directory (which\n// might be a path of a template which includes another template) or\n// the current working directory.\nfunc (fs *LocalFilesystemLoader) Abs(base, name string) string {\n\tif filepath.IsAbs(name) {\n\t\treturn name\n\t}\n\n\t// Our own base dir has always priority; if there's none\n\t// we use the path provided in base.\n\tvar err error\n\tif fs.baseDir == \"\" {\n\t\tif base == \"\" {\n\t\t\tbase, err = os.Getwd()\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\treturn filepath.Join(base, name)\n\t\t}\n\n\t\treturn filepath.Join(filepath.Dir(base), name)\n\t}\n\n\treturn filepath.Join(fs.baseDir, name)\n}\n\n// SandboxedFilesystemLoader is still WIP.\ntype SandboxedFilesystemLoader struct {\n\t*LocalFilesystemLoader\n}\n\n// NewSandboxedFilesystemLoader creates a new sandboxed local file system instance.\nfunc NewSandboxedFilesystemLoader(baseDir string) (*SandboxedFilesystemLoader, error) {\n\tfs, err := NewLocalFileSystemLoader(baseDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &SandboxedFilesystemLoader{\n\t\tLocalFilesystemLoader: fs,\n\t}, nil\n}\n\n// Move sandbox to a virtual fs\n\n/*\nif len(set.SandboxDirectories) > 0 {\n    defer func() {\n        // Remove any \"..\" or other crap\n        resolvedPath = filepath.Clean(resolvedPath)\n\n        // Make the path absolute\n        absPath, err := filepath.Abs(resolvedPath)\n        if err != nil {\n            panic(err)\n        }\n        resolvedPath = absPath\n\n        // Check against the sandbox directories (once one pattern matches, we're done and can allow it)\n        for _, pattern := range set.SandboxDirectories {\n            matched, err := filepath.Match(pattern, resolvedPath)\n            if err != nil {\n                panic(\"Wrong sandbox directory match pattern (see http://golang.org/pkg/path/filepath/#Match).\")\n            }\n            if matched {\n                // OK!\n                return\n            }\n        }\n\n        // No pattern matched, we have to log+deny the request\n        set.logf(\"Access attempt outside of the sandbox directories (blocked): '%s'\", resolvedPath)\n        resolvedPath = \"\"\n    }()\n}\n*/\n\n// HttpFilesystemLoader supports loading templates\n// from an http.FileSystem - useful for using one of several\n// file-to-code generators that packs static files into\n// a go binary (ex: https://github.com/jteeuwen/go-bindata)\ntype HttpFilesystemLoader struct {\n\tfs      http.FileSystem\n\tbaseDir string\n}\n\n// MustNewHttpFileSystemLoader creates a new HttpFilesystemLoader instance\n// and panics if there's any error during instantiation. The parameters\n// are the same like NewHttpFilesystemLoader.\nfunc MustNewHttpFileSystemLoader(httpfs http.FileSystem, baseDir string) *HttpFilesystemLoader {\n\tfs, err := NewHttpFileSystemLoader(httpfs, baseDir)\n\tif err != nil {\n\t\tlog.Panic(err)\n\t}\n\treturn fs\n}\n\n// NewHttpFileSystemLoader creates a new HttpFileSystemLoader and allows\n// templates to be loaded from the virtual filesystem. The path\n// is calculated based relatively from the root of the http.Filesystem.\nfunc NewHttpFileSystemLoader(httpfs http.FileSystem, baseDir string) (*HttpFilesystemLoader, error) {\n\thfs := &HttpFilesystemLoader{\n\t\tfs:      httpfs,\n\t\tbaseDir: baseDir,\n\t}\n\tif httpfs == nil {\n\t\terr := errors.New(\"httpfs cannot be nil\")\n\t\treturn nil, err\n\t}\n\treturn hfs, nil\n}\n\n// Abs in this instance simply returns the filename, since\n// there's no potential for an unexpanded path in an http.FileSystem\nfunc (h *HttpFilesystemLoader) Abs(base, name string) string {\n\treturn name\n}\n\n// Get returns an io.Reader where the template's content can be read from.\nfunc (h *HttpFilesystemLoader) Get(path string) (io.Reader, error) {\n\tfullPath := path\n\tif h.baseDir != \"\" {\n\t\tfullPath = fmt.Sprintf(\n\t\t\t\"%s/%s\",\n\t\t\th.baseDir,\n\t\t\tfullPath,\n\t\t)\n\t}\n\n\treturn h.fs.Open(fullPath)\n}\n"
        },
        {
          "name": "template_sets.go",
          "type": "blob",
          "size": 8.8046875,
          "content": "package pongo2\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"sync\"\n)\n\n// TemplateLoader allows to implement a virtual file system.\ntype TemplateLoader interface {\n\t// Abs calculates the path to a given template. Whenever a path must be resolved\n\t// due to an import from another template, the base equals the parent template's path.\n\tAbs(base, name string) string\n\n\t// Get returns an io.Reader where the template's content can be read from.\n\tGet(path string) (io.Reader, error)\n}\n\n// TemplateSet allows you to create your own group of templates with their own\n// global context (which is shared among all members of the set) and their own\n// configuration.\n// It's useful for a separation of different kind of templates\n// (e. g. web templates vs. mail templates).\ntype TemplateSet struct {\n\tname    string\n\tloaders []TemplateLoader\n\n\t// Globals will be provided to all templates created within this template set\n\tGlobals Context\n\n\t// If debug is true (default false), ExecutionContext.Logf() will work and output\n\t// to STDOUT. Furthermore, FromCache() won't cache the templates.\n\t// Make sure to synchronize the access to it in case you're changing this\n\t// variable during program execution (and template compilation/execution).\n\tDebug bool\n\n\t// Options allow you to change the behavior of template-engine.\n\t// You can change the options before calling the Execute method.\n\tOptions *Options\n\n\t// Sandbox features\n\t// - Disallow access to specific tags and/or filters (using BanTag() and BanFilter())\n\t//\n\t// For efficiency reasons you can ban tags/filters only *before* you have\n\t// added your first template to the set (restrictions are statically checked).\n\t// After you added one, it's not possible anymore (for your personal security).\n\tfirstTemplateCreated bool\n\tbannedTags           map[string]bool\n\tbannedFilters        map[string]bool\n\n\t// Template cache (for FromCache())\n\ttemplateCache      map[string]*Template\n\ttemplateCacheMutex sync.Mutex\n}\n\n// NewSet can be used to create sets with different kind of templates\n// (e. g. web from mail templates), with different globals or\n// other configurations.\nfunc NewSet(name string, loaders ...TemplateLoader) *TemplateSet {\n\tif len(loaders) == 0 {\n\t\tpanic(fmt.Errorf(\"at least one template loader must be specified\"))\n\t}\n\n\treturn &TemplateSet{\n\t\tname:          name,\n\t\tloaders:       loaders,\n\t\tGlobals:       make(Context),\n\t\tbannedTags:    make(map[string]bool),\n\t\tbannedFilters: make(map[string]bool),\n\t\ttemplateCache: make(map[string]*Template),\n\t\tOptions:       newOptions(),\n\t}\n}\n\nfunc (set *TemplateSet) AddLoader(loaders ...TemplateLoader) {\n\tset.loaders = append(set.loaders, loaders...)\n}\n\nfunc (set *TemplateSet) resolveFilename(tpl *Template, path string) string {\n\treturn set.resolveFilenameForLoader(set.loaders[0], tpl, path)\n}\n\nfunc (set *TemplateSet) resolveFilenameForLoader(loader TemplateLoader, tpl *Template, path string) string {\n\tname := \"\"\n\tif tpl != nil && tpl.isTplString {\n\t\treturn path\n\t}\n\tif tpl != nil {\n\t\tname = tpl.name\n\t}\n\n\treturn loader.Abs(name, path)\n}\n\n// BanTag bans a specific tag for this template set. See more in the documentation for TemplateSet.\nfunc (set *TemplateSet) BanTag(name string) error {\n\t_, has := tags[name]\n\tif !has {\n\t\treturn fmt.Errorf(\"tag '%s' not found\", name)\n\t}\n\tif set.firstTemplateCreated {\n\t\treturn errors.New(\"you cannot ban any tags after you've added your first template to your template set\")\n\t}\n\t_, has = set.bannedTags[name]\n\tif has {\n\t\treturn fmt.Errorf(\"tag '%s' is already banned\", name)\n\t}\n\tset.bannedTags[name] = true\n\n\treturn nil\n}\n\n// BanFilter bans a specific filter for this template set. See more in the documentation for TemplateSet.\nfunc (set *TemplateSet) BanFilter(name string) error {\n\t_, has := filters[name]\n\tif !has {\n\t\treturn fmt.Errorf(\"filter '%s' not found\", name)\n\t}\n\tif set.firstTemplateCreated {\n\t\treturn errors.New(\"you cannot ban any filters after you've added your first template to your template set\")\n\t}\n\t_, has = set.bannedFilters[name]\n\tif has {\n\t\treturn fmt.Errorf(\"filter '%s' is already banned\", name)\n\t}\n\tset.bannedFilters[name] = true\n\n\treturn nil\n}\n\nfunc (set *TemplateSet) resolveTemplate(tpl *Template, path string) (name string, loader TemplateLoader, fd io.Reader, err error) {\n\t// iterate over loaders until we appear to have a valid template\n\tfor _, loader = range set.loaders {\n\t\tname = set.resolveFilenameForLoader(loader, tpl, path)\n\t\tfd, err = loader.Get(name)\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\treturn path, nil, nil, fmt.Errorf(\"unable to resolve template\")\n}\n\n// CleanCache cleans the template cache. If filenames is not empty,\n// it will remove the template caches of those filenames.\n// Or it will empty the whole template cache. It is thread-safe.\nfunc (set *TemplateSet) CleanCache(filenames ...string) {\n\tset.templateCacheMutex.Lock()\n\tdefer set.templateCacheMutex.Unlock()\n\n\tif len(filenames) == 0 {\n\t\tset.templateCache = make(map[string]*Template, len(set.templateCache))\n\t}\n\n\tfor _, filename := range filenames {\n\t\tdelete(set.templateCache, set.resolveFilename(nil, filename))\n\t}\n}\n\n// FromCache is a convenient method to cache templates. It is thread-safe\n// and will only compile the template associated with a filename once.\n// If TemplateSet.Debug is true (for example during development phase),\n// FromCache() will not cache the template and instead recompile it on any\n// call (to make changes to a template live instantaneously).\nfunc (set *TemplateSet) FromCache(filename string) (*Template, error) {\n\tif set.Debug {\n\t\t// Recompile on any request\n\t\treturn set.FromFile(filename)\n\t}\n\t// Cache the template\n\tcleanedFilename := set.resolveFilename(nil, filename)\n\n\tset.templateCacheMutex.Lock()\n\tdefer set.templateCacheMutex.Unlock()\n\n\ttpl, has := set.templateCache[cleanedFilename]\n\n\t// Cache miss\n\tif !has {\n\t\ttpl, err := set.FromFile(cleanedFilename)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tset.templateCache[cleanedFilename] = tpl\n\t\treturn tpl, nil\n\t}\n\n\t// Cache hit\n\treturn tpl, nil\n}\n\n// FromString loads a template from string and returns a Template instance.\nfunc (set *TemplateSet) FromString(tpl string) (*Template, error) {\n\tset.firstTemplateCreated = true\n\n\treturn newTemplateString(set, []byte(tpl))\n}\n\n// FromBytes loads a template from bytes and returns a Template instance.\nfunc (set *TemplateSet) FromBytes(tpl []byte) (*Template, error) {\n\tset.firstTemplateCreated = true\n\n\treturn newTemplateString(set, tpl)\n}\n\n// FromFile loads a template from a filename and returns a Template instance.\nfunc (set *TemplateSet) FromFile(filename string) (*Template, error) {\n\tset.firstTemplateCreated = true\n\n\t_, _, fd, err := set.resolveTemplate(nil, filename)\n\tif err != nil {\n\t\treturn nil, &Error{\n\t\t\tFilename:  filename,\n\t\t\tSender:    \"fromfile\",\n\t\t\tOrigError: err,\n\t\t}\n\t}\n\tbuf, err := io.ReadAll(fd)\n\tif err != nil {\n\t\treturn nil, &Error{\n\t\t\tFilename:  filename,\n\t\t\tSender:    \"fromfile\",\n\t\t\tOrigError: err,\n\t\t}\n\t}\n\n\treturn newTemplate(set, filename, false, buf)\n}\n\n// RenderTemplateString is a shortcut and renders a template string directly.\nfunc (set *TemplateSet) RenderTemplateString(s string, ctx Context) (string, error) {\n\tset.firstTemplateCreated = true\n\n\ttpl := Must(set.FromString(s))\n\tresult, err := tpl.Execute(ctx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn result, nil\n}\n\n// RenderTemplateBytes is a shortcut and renders template bytes directly.\nfunc (set *TemplateSet) RenderTemplateBytes(b []byte, ctx Context) (string, error) {\n\tset.firstTemplateCreated = true\n\n\ttpl := Must(set.FromBytes(b))\n\tresult, err := tpl.Execute(ctx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn result, nil\n}\n\n// RenderTemplateFile is a shortcut and renders a template file directly.\nfunc (set *TemplateSet) RenderTemplateFile(fn string, ctx Context) (string, error) {\n\tset.firstTemplateCreated = true\n\n\ttpl := Must(set.FromFile(fn))\n\tresult, err := tpl.Execute(ctx)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn result, nil\n}\n\nfunc (set *TemplateSet) logf(format string, args ...any) {\n\tif set.Debug {\n\t\tlogger.Printf(fmt.Sprintf(\"[template set: %s] %s\", set.name, format), args...)\n\t}\n}\n\n// Logging function (internally used)\nfunc logf(format string, items ...any) {\n\tif debug {\n\t\tlogger.Printf(format, items...)\n\t}\n}\n\nvar (\n\tdebug  bool // internal debugging\n\tlogger = log.New(os.Stdout, \"[pongo2] \", log.LstdFlags|log.Lshortfile)\n\n\t// DefaultLoader allows the default un-sandboxed access to the local file\n\t// system and is being used by the DefaultSet.\n\tDefaultLoader = MustNewLocalFileSystemLoader(\"\")\n\n\t// DefaultSet is a set created for you for convinience reasons.\n\tDefaultSet = NewSet(\"default\", DefaultLoader)\n\n\t// Methods on the default set\n\tFromString           = DefaultSet.FromString\n\tFromBytes            = DefaultSet.FromBytes\n\tFromFile             = DefaultSet.FromFile\n\tFromCache            = DefaultSet.FromCache\n\tRenderTemplateString = DefaultSet.RenderTemplateString\n\tRenderTemplateFile   = DefaultSet.RenderTemplateFile\n\n\t// Globals for the default set\n\tGlobals = DefaultSet.Globals\n)\n"
        },
        {
          "name": "template_tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "value.go",
          "type": "blob",
          "size": 15.9130859375,
          "content": "package pongo2\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype Value struct {\n\tval  reflect.Value\n\tsafe bool // used to indicate whether a Value needs explicit escaping in the template\n}\n\n// AsValue converts any given value to a pongo2.Value\n// Usually being used within own functions passed to a template\n// through a Context or within filter functions.\n//\n// Example:\n//\n//\tAsValue(\"my string\")\nfunc AsValue(i any) *Value {\n\treturn &Value{\n\t\tval: reflect.ValueOf(i),\n\t}\n}\n\n// AsSafeValue works like AsValue, but does not apply the 'escape' filter.\nfunc AsSafeValue(i any) *Value {\n\treturn &Value{\n\t\tval:  reflect.ValueOf(i),\n\t\tsafe: true,\n\t}\n}\n\nfunc (v *Value) getResolvedValue() reflect.Value {\n\tif v.val.IsValid() && v.val.Kind() == reflect.Ptr {\n\t\treturn v.val.Elem()\n\t}\n\treturn v.val\n}\n\n// IsString checks whether the underlying value is a string\nfunc (v *Value) IsString() bool {\n\treturn v.getResolvedValue().Kind() == reflect.String\n}\n\n// IsBool checks whether the underlying value is a bool\nfunc (v *Value) IsBool() bool {\n\treturn v.getResolvedValue().Kind() == reflect.Bool\n}\n\n// IsFloat checks whether the underlying value is a float\nfunc (v *Value) IsFloat() bool {\n\treturn v.getResolvedValue().Kind() == reflect.Float32 ||\n\t\tv.getResolvedValue().Kind() == reflect.Float64\n}\n\n// IsInteger checks whether the underlying value is an integer\nfunc (v *Value) IsInteger() bool {\n\treturn v.getResolvedValue().Kind() == reflect.Int ||\n\t\tv.getResolvedValue().Kind() == reflect.Int8 ||\n\t\tv.getResolvedValue().Kind() == reflect.Int16 ||\n\t\tv.getResolvedValue().Kind() == reflect.Int32 ||\n\t\tv.getResolvedValue().Kind() == reflect.Int64 ||\n\t\tv.getResolvedValue().Kind() == reflect.Uint ||\n\t\tv.getResolvedValue().Kind() == reflect.Uint8 ||\n\t\tv.getResolvedValue().Kind() == reflect.Uint16 ||\n\t\tv.getResolvedValue().Kind() == reflect.Uint32 ||\n\t\tv.getResolvedValue().Kind() == reflect.Uint64\n}\n\n// IsNumber checks whether the underlying value is either an integer\n// or a float.\nfunc (v *Value) IsNumber() bool {\n\treturn v.IsInteger() || v.IsFloat()\n}\n\n// IsTime checks whether the underlying value is a time.Time.\nfunc (v *Value) IsTime() bool {\n\t_, ok := v.Interface().(time.Time)\n\treturn ok\n}\n\n// IsNil checks whether the underlying value is NIL\nfunc (v *Value) IsNil() bool {\n\t// fmt.Printf(\"%+v\\n\", v.getResolvedValue().Type().String())\n\treturn !v.getResolvedValue().IsValid()\n}\n\n// String returns a string for the underlying value. If this value is not\n// of type string, pongo2 tries to convert it. Currently the following\n// types for underlying values are supported:\n//\n//  1. string\n//  2. int/uint (any size)\n//  3. float (any precision)\n//  4. bool\n//  5. time.Time\n//  6. String() will be called on the underlying value if provided\n//\n// NIL values will lead to an empty string. Unsupported types are leading\n// to their respective type name.\nfunc (v *Value) String() string {\n\tif v.IsNil() {\n\t\treturn \"\"\n\t}\n\n\tif t, ok := v.Interface().(fmt.Stringer); ok {\n\t\treturn t.String()\n\t}\n\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.String:\n\t\treturn v.getResolvedValue().String()\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn strconv.FormatInt(v.getResolvedValue().Int(), 10)\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn strconv.FormatUint(v.getResolvedValue().Uint(), 10)\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn fmt.Sprintf(\"%f\", v.getResolvedValue().Float())\n\tcase reflect.Bool:\n\t\tif v.Bool() {\n\t\t\treturn \"True\"\n\t\t}\n\t\treturn \"False\"\n\t}\n\n\tlogf(\"Value.String() not implemented for type: %s\\n\", v.getResolvedValue().Kind().String())\n\treturn v.getResolvedValue().String()\n}\n\n// Integer returns the underlying value as an integer (converts the underlying\n// value, if necessary). If it's not possible to convert the underlying value,\n// it will return 0.\nfunc (v *Value) Integer() int {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn int(v.getResolvedValue().Int())\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn int(v.getResolvedValue().Uint())\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn int(v.getResolvedValue().Float())\n\tcase reflect.String:\n\t\t// Try to convert from string to int (base 10)\n\t\tf, err := strconv.ParseFloat(v.getResolvedValue().String(), 64)\n\t\tif err != nil {\n\t\t\treturn 0\n\t\t}\n\t\treturn int(f)\n\tdefault:\n\t\tlogf(\"Value.Integer() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn 0\n\t}\n}\n\n// Float returns the underlying value as a float (converts the underlying\n// value, if necessary). If it's not possible to convert the underlying value,\n// it will return 0.0.\nfunc (v *Value) Float() float64 {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn float64(v.getResolvedValue().Int())\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn float64(v.getResolvedValue().Uint())\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.getResolvedValue().Float()\n\tcase reflect.String:\n\t\t// Try to convert from string to float64 (base 10)\n\t\tf, err := strconv.ParseFloat(v.getResolvedValue().String(), 64)\n\t\tif err != nil {\n\t\t\treturn 0.0\n\t\t}\n\t\treturn f\n\tdefault:\n\t\tlogf(\"Value.Float() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn 0.0\n\t}\n}\n\n// Bool returns the underlying value as bool. If the value is not bool, false\n// will always be returned. If you're looking for true/false-evaluation of the\n// underlying value, have a look on the IsTrue()-function.\nfunc (v *Value) Bool() bool {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Bool:\n\t\treturn v.getResolvedValue().Bool()\n\tdefault:\n\t\tlogf(\"Value.Bool() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn false\n\t}\n}\n\n// Time returns the underlying value as time.Time.\n// If the underlying value is not a time.Time, it returns the zero value of time.Time.\nfunc (v *Value) Time() time.Time {\n\ttm, ok := v.Interface().(time.Time)\n\tif ok {\n\t\treturn tm\n\t}\n\treturn time.Time{}\n}\n\n// IsTrue tries to evaluate the underlying value the Pythonic-way:\n//\n// Returns TRUE in one the following cases:\n//\n//   - int != 0\n//   - uint != 0\n//   - float != 0.0\n//   - len(array/chan/map/slice/string) > 0\n//   - bool == true\n//   - underlying value is a struct\n//\n// Otherwise returns always FALSE.\nfunc (v *Value) IsTrue() bool {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\treturn v.getResolvedValue().Int() != 0\n\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\treturn v.getResolvedValue().Uint() != 0\n\tcase reflect.Float32, reflect.Float64:\n\t\treturn v.getResolvedValue().Float() != 0\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn v.getResolvedValue().Len() > 0\n\tcase reflect.Bool:\n\t\treturn v.getResolvedValue().Bool()\n\tcase reflect.Struct:\n\t\treturn true // struct instance is always true\n\tdefault:\n\t\tlogf(\"Value.IsTrue() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn false\n\t}\n}\n\n// Negate tries to negate the underlying value. It's mainly used for\n// the NOT-operator and in conjunction with a call to\n// return_value.IsTrue() afterwards.\n//\n// Example:\n//\n//\tAsValue(1).Negate().IsTrue() == false\nfunc (v *Value) Negate() *Value {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,\n\t\treflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\tif v.Integer() != 0 {\n\t\t\treturn AsValue(0)\n\t\t}\n\t\treturn AsValue(1)\n\tcase reflect.Float32, reflect.Float64:\n\t\tif v.Float() != 0.0 {\n\t\t\treturn AsValue(float64(0.0))\n\t\t}\n\t\treturn AsValue(float64(1.1))\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:\n\t\treturn AsValue(v.getResolvedValue().Len() == 0)\n\tcase reflect.Bool:\n\t\treturn AsValue(!v.getResolvedValue().Bool())\n\tcase reflect.Struct:\n\t\treturn AsValue(false)\n\tdefault:\n\t\tlogf(\"Value.IsTrue() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn AsValue(true)\n\t}\n}\n\n// Len returns the length for an array, chan, map, slice or string.\n// Otherwise it will return 0.\nfunc (v *Value) Len() int {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:\n\t\treturn v.getResolvedValue().Len()\n\tcase reflect.String:\n\t\trunes := []rune(v.getResolvedValue().String())\n\t\treturn len(runes)\n\tdefault:\n\t\tlogf(\"Value.Len() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn 0\n\t}\n}\n\n// Slice slices an array, slice or string. Otherwise it will\n// return an empty []int.\nfunc (v *Value) Slice(i, j int) *Value {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Array, reflect.Slice:\n\t\treturn AsValue(v.getResolvedValue().Slice(i, j).Interface())\n\tcase reflect.String:\n\t\trunes := []rune(v.getResolvedValue().String())\n\t\treturn AsValue(string(runes[i:j]))\n\tdefault:\n\t\tlogf(\"Value.Slice() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn AsValue([]int{})\n\t}\n}\n\n// Index gets the i-th item of an array, slice or string. Otherwise\n// it will return NIL.\nfunc (v *Value) Index(i int) *Value {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Array, reflect.Slice:\n\t\tif i >= v.Len() {\n\t\t\treturn AsValue(nil)\n\t\t}\n\t\treturn AsValue(v.getResolvedValue().Index(i).Interface())\n\tcase reflect.String:\n\t\ts := v.getResolvedValue().String()\n\t\trunes := []rune(s)\n\t\tif i < len(runes) {\n\t\t\treturn AsValue(string(runes[i]))\n\t\t}\n\t\treturn AsValue(\"\")\n\tdefault:\n\t\tlogf(\"Value.Slice() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t\treturn AsValue([]int{})\n\t}\n}\n\n// Contains checks whether the underlying value (which must be of type struct, map,\n// string, array or slice) contains of another Value (e. g. used to check\n// whether a struct contains of a specific field or a map contains a specific key).\n//\n// Example:\n//\n//\tAsValue(\"Hello, World!\").Contains(AsValue(\"World\")) == true\nfunc (v *Value) Contains(other *Value) bool {\n\tbaseValue := v.getResolvedValue()\n\tswitch baseValue.Kind() {\n\tcase reflect.Struct:\n\t\tfieldValue := baseValue.FieldByName(other.String())\n\t\treturn fieldValue.IsValid()\n\tcase reflect.Map:\n\t\t// We can't check against invalid types\n\t\tif !other.val.IsValid() {\n\t\t\treturn false\n\t\t}\n\t\t// Ensure that map key type is equal to other's type.\n\t\tif baseValue.Type().Key() != other.val.Type() {\n\t\t\treturn false\n\t\t}\n\n\t\tvar mapValue reflect.Value\n\t\tswitch other.Interface().(type) {\n\t\tcase int:\n\t\t\tmapValue = baseValue.MapIndex(other.getResolvedValue())\n\t\tcase string:\n\t\t\tmapValue = baseValue.MapIndex(other.getResolvedValue())\n\t\tdefault:\n\t\t\tlogf(\"Value.Contains() does not support lookup type '%s'\\n\", other.getResolvedValue().Kind().String())\n\t\t\treturn false\n\t\t}\n\n\t\treturn mapValue.IsValid()\n\tcase reflect.String:\n\t\treturn strings.Contains(v.getResolvedValue().String(), other.String())\n\n\tcase reflect.Slice, reflect.Array:\n\t\tfor i := 0; i < baseValue.Len(); i++ {\n\t\t\titem := baseValue.Index(i)\n\t\t\tif other.EqualValueTo(AsValue(item.Interface())) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\n\tdefault:\n\t\tlogf(\"Value.Contains() not available for type: %s\\n\", baseValue.Kind().String())\n\t\treturn false\n\t}\n}\n\n// CanSlice checks whether the underlying value is of type array, slice or string.\n// You normally would use CanSlice() before using the Slice() operation.\nfunc (v *Value) CanSlice() bool {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Array, reflect.Slice, reflect.String:\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Iterate iterates over a map, array, slice or a string. It calls the\n// function's first argument for every value with the following arguments:\n//\n//\tidx      current 0-index\n//\tcount    total amount of items\n//\tkey      *Value for the key or item\n//\tvalue    *Value (only for maps, the respective value for a specific key)\n//\n// If the underlying value has no items or is not one of the types above,\n// the empty function (function's second argument) will be called.\nfunc (v *Value) Iterate(fn func(idx, count int, key, value *Value) bool, empty func()) {\n\tv.IterateOrder(fn, empty, false, false)\n}\n\n// IterateOrder behaves like Value.Iterate, but can iterate through an array/slice/string in reverse. Does\n// not affect the iteration through a map because maps don't have any particular order.\n// However, you can force an order using the `sorted` keyword (and even use `reversed sorted`).\nfunc (v *Value) IterateOrder(fn func(idx, count int, key, value *Value) bool, empty func(), reverse bool, sorted bool) {\n\tswitch v.getResolvedValue().Kind() {\n\tcase reflect.Map:\n\t\tkeys := sortedKeys(v.getResolvedValue().MapKeys())\n\t\tif sorted {\n\t\t\tif reverse {\n\t\t\t\tsort.Sort(sort.Reverse(keys))\n\t\t\t} else {\n\t\t\t\tsort.Sort(keys)\n\t\t\t}\n\t\t}\n\t\tkeyLen := len(keys)\n\t\tfor idx, key := range keys {\n\t\t\tvalue := v.getResolvedValue().MapIndex(key)\n\t\t\tif !fn(idx, keyLen, &Value{val: key}, &Value{val: value}) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif keyLen == 0 {\n\t\t\tempty()\n\t\t}\n\t\treturn // done\n\tcase reflect.Array, reflect.Slice:\n\t\tvar items valuesList\n\n\t\titemCount := v.getResolvedValue().Len()\n\t\tfor i := 0; i < itemCount; i++ {\n\t\t\titems = append(items, &Value{val: v.getResolvedValue().Index(i)})\n\t\t}\n\n\t\tif sorted {\n\t\t\tif reverse {\n\t\t\t\tsort.Sort(sort.Reverse(items))\n\t\t\t} else {\n\t\t\t\tsort.Sort(items)\n\t\t\t}\n\t\t} else {\n\t\t\tif reverse {\n\t\t\t\tfor i := 0; i < itemCount/2; i++ {\n\t\t\t\t\titems[i], items[itemCount-1-i] = items[itemCount-1-i], items[i]\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif len(items) > 0 {\n\t\t\tfor idx, item := range items {\n\t\t\t\tif !fn(idx, itemCount, item, nil) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tempty()\n\t\t}\n\t\treturn // done\n\tcase reflect.String:\n\t\ts := v.getResolvedValue().String()\n\t\trs := []rune(s)\n\t\tcharCount := len(rs)\n\n\t\tif charCount > 0 {\n\t\t\tif sorted {\n\t\t\t\tsort.SliceStable(rs, func(i, j int) bool {\n\t\t\t\t\treturn rs[i] < rs[j]\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif reverse {\n\t\t\t\tfor i, j := 0, charCount-1; i < j; i, j = i+1, j-1 {\n\t\t\t\t\trs[i], rs[j] = rs[j], rs[i]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor i := 0; i < charCount; i++ {\n\t\t\t\tif !fn(i, charCount, &Value{val: reflect.ValueOf(string(rs[i]))}, nil) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tempty()\n\t\t}\n\t\treturn // done\n\tdefault:\n\t\tlogf(\"Value.Iterate() not available for type: %s\\n\", v.getResolvedValue().Kind().String())\n\t}\n\tempty()\n}\n\n// Interface gives you access to the underlying value.\nfunc (v *Value) Interface() any {\n\tif v.val.IsValid() {\n\t\treturn v.val.Interface()\n\t}\n\treturn nil\n}\n\n// EqualValueTo checks whether two values are containing the same value or object (if comparable).\nfunc (v *Value) EqualValueTo(other *Value) bool {\n\t// comparison of uint with int fails using .Interface()-comparison (see issue #64)\n\tif v.IsInteger() && other.IsInteger() {\n\t\treturn v.Integer() == other.Integer()\n\t}\n\tif v.IsTime() && other.IsTime() {\n\t\treturn v.Time().Equal(other.Time())\n\t}\n\tif !v.val.IsValid() || !other.val.IsValid() {\n\t\treturn false\n\t}\n\t// TODO(flosch): As of Go 1.20, reflect supports Comparable() and Equal(). This should potentially\n\t// be used here: https://pkg.go.dev/reflect#Value.Comparable\n\treturn v.val.CanInterface() && other.val.CanInterface() &&\n\t\tv.val.Type().Comparable() && other.val.Type().Comparable() &&\n\t\tv.Interface() == other.Interface()\n}\n\ntype sortedKeys []reflect.Value\n\nfunc (sk sortedKeys) Len() int {\n\treturn len(sk)\n}\n\nfunc (sk sortedKeys) Less(i, j int) bool {\n\tvi := &Value{val: sk[i]}\n\tvj := &Value{val: sk[j]}\n\tswitch {\n\tcase vi.IsInteger() && vj.IsInteger():\n\t\treturn vi.Integer() < vj.Integer()\n\tcase vi.IsFloat() && vj.IsFloat():\n\t\treturn vi.Float() < vj.Float()\n\tdefault:\n\t\treturn vi.String() < vj.String()\n\t}\n}\n\nfunc (sk sortedKeys) Swap(i, j int) {\n\tsk[i], sk[j] = sk[j], sk[i]\n}\n\ntype valuesList []*Value\n\nfunc (vl valuesList) Len() int {\n\treturn len(vl)\n}\n\nfunc (vl valuesList) Less(i, j int) bool {\n\tvi := vl[i]\n\tvj := vl[j]\n\tswitch {\n\tcase vi.IsInteger() && vj.IsInteger():\n\t\treturn vi.Integer() < vj.Integer()\n\tcase vi.IsFloat() && vj.IsFloat():\n\t\treturn vi.Float() < vj.Float()\n\tdefault:\n\t\treturn vi.String() < vj.String()\n\t}\n}\n\nfunc (vl valuesList) Swap(i, j int) {\n\tvl[i], vl[j] = vl[j], vl[i]\n}\n"
        },
        {
          "name": "variable.go",
          "type": "blob",
          "size": 20.8369140625,
          "content": "package pongo2\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tvarTypeInt = iota\n\tvarTypeIdent\n\tvarTypeSubscript\n\tvarTypeArray\n\tvarTypeNil\n)\n\nvar (\n\ttypeOfValuePtr   = reflect.TypeOf(new(Value))\n\ttypeOfExecCtxPtr = reflect.TypeOf(new(ExecutionContext))\n)\n\ntype variablePart struct {\n\ttyp       int\n\ts         string\n\ti         int\n\tsubscript IEvaluator\n\tisNil     bool\n\n\tisFunctionCall bool\n\tcallingArgs    []functionCallArgument // needed for a function call, represents all argument nodes (INode supports nested function calls)\n}\n\nfunc (p *variablePart) String() string {\n\tswitch p.typ {\n\tcase varTypeInt:\n\t\treturn strconv.Itoa(p.i)\n\tcase varTypeIdent:\n\t\treturn p.s\n\tcase varTypeSubscript:\n\t\treturn \"[subscript]\"\n\tcase varTypeArray:\n\t\treturn \"[array]\"\n\t}\n\n\tpanic(\"unimplemented\")\n}\n\ntype functionCallArgument interface {\n\tEvaluate(*ExecutionContext) (*Value, *Error)\n}\n\n// TODO: Add location tokens\ntype stringResolver struct {\n\tlocationToken *Token\n\tval           string\n}\n\ntype intResolver struct {\n\tlocationToken *Token\n\tval           int\n}\n\ntype floatResolver struct {\n\tlocationToken *Token\n\tval           float64\n}\n\ntype boolResolver struct {\n\tlocationToken *Token\n\tval           bool\n}\n\ntype variableResolver struct {\n\tlocationToken *Token\n\n\tparts []*variablePart\n}\n\ntype nodeFilteredVariable struct {\n\tlocationToken *Token\n\n\tresolver    IEvaluator\n\tfilterChain []*filterCall\n}\n\ntype nodeVariable struct {\n\tlocationToken *Token\n\texpr          IEvaluator\n}\n\ntype executionCtxEval struct{}\n\nfunc (v *nodeFilteredVariable) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := v.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (vr *variableResolver) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := vr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (s *stringResolver) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := s.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (i *intResolver) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := i.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (f *floatResolver) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := f.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (b *boolResolver) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := b.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (v *nodeFilteredVariable) GetPositionToken() *Token {\n\treturn v.locationToken\n}\n\nfunc (vr *variableResolver) GetPositionToken() *Token {\n\treturn vr.locationToken\n}\n\nfunc (s *stringResolver) GetPositionToken() *Token {\n\treturn s.locationToken\n}\n\nfunc (i *intResolver) GetPositionToken() *Token {\n\treturn i.locationToken\n}\n\nfunc (f *floatResolver) GetPositionToken() *Token {\n\treturn f.locationToken\n}\n\nfunc (b *boolResolver) GetPositionToken() *Token {\n\treturn b.locationToken\n}\n\nfunc (s *stringResolver) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\treturn AsValue(s.val), nil\n}\n\nfunc (i *intResolver) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\treturn AsValue(i.val), nil\n}\n\nfunc (f *floatResolver) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\treturn AsValue(f.val), nil\n}\n\nfunc (b *boolResolver) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\treturn AsValue(b.val), nil\n}\n\nfunc (s *stringResolver) FilterApplied(name string) bool {\n\treturn false\n}\n\nfunc (i *intResolver) FilterApplied(name string) bool {\n\treturn false\n}\n\nfunc (f *floatResolver) FilterApplied(name string) bool {\n\treturn false\n}\n\nfunc (b *boolResolver) FilterApplied(name string) bool {\n\treturn false\n}\n\nfunc (nv *nodeVariable) FilterApplied(name string) bool {\n\treturn nv.expr.FilterApplied(name)\n}\n\nfunc (nv *nodeVariable) Execute(ctx *ExecutionContext, writer TemplateWriter) *Error {\n\tvalue, err := nv.expr.Evaluate(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif !nv.expr.FilterApplied(\"safe\") && !value.safe && value.IsString() && ctx.Autoescape {\n\t\t// apply escape filter\n\t\tvalue, err = filters[\"escape\"](value, nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\twriter.WriteString(value.String())\n\treturn nil\n}\n\nfunc (executionCtxEval) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\treturn AsValue(ctx), nil\n}\n\nfunc (vr *variableResolver) FilterApplied(name string) bool {\n\treturn false\n}\n\nfunc (vr *variableResolver) String() string {\n\tparts := make([]string, 0, len(vr.parts))\n\tfor _, p := range vr.parts {\n\t\tparts = append(parts, p.String())\n\t}\n\n\treturn strings.Join(parts, \".\")\n}\n\nfunc (vr *variableResolver) resolve(ctx *ExecutionContext) (*Value, error) {\n\tvar current reflect.Value\n\tvar isSafe bool\n\n\t// we are resolving an in-template array definition\n\tif len(vr.parts) > 0 && vr.parts[0].typ == varTypeArray {\n\t\titems := make([]*Value, 0)\n\t\tfor _, part := range vr.parts {\n\t\t\tswitch v := part.subscript.(type) {\n\t\t\tcase *nodeFilteredVariable:\n\t\t\t\titem, err := v.resolver.Evaluate(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\titems = append(items, item)\n\t\t\tdefault:\n\t\t\t\treturn nil, errors.New(\"unknown variable type is given\")\n\t\t\t}\n\t\t}\n\n\t\treturn &Value{\n\t\t\tval:  reflect.ValueOf(items),\n\t\t\tsafe: true,\n\t\t}, nil\n\t}\n\n\tfor idx, part := range vr.parts {\n\t\tif idx == 0 {\n\t\t\t// We're looking up the first part of the variable.\n\t\t\t// First we're having a look in our private\n\t\t\t// context (e. g. information provided by tags, like the forloop)\n\t\t\tval, inPrivate := ctx.Private[vr.parts[0].s]\n\t\t\tif !inPrivate {\n\t\t\t\t// Nothing found? Then have a final lookup in the public context\n\t\t\t\tval = ctx.Public[vr.parts[0].s]\n\t\t\t}\n\t\t\tcurrent = reflect.ValueOf(val) // Get the initial value\n\t\t} else {\n\t\t\t// Next parts, resolve it from current\n\n\t\t\t// Before resolving the pointer, let's see if we have a method to call\n\t\t\t// Problem with resolving the pointer is we're changing the receiver\n\t\t\tisFunc := false\n\t\t\tif part.typ == varTypeIdent {\n\t\t\t\tfuncValue := current.MethodByName(part.s)\n\t\t\t\tif funcValue.IsValid() {\n\t\t\t\t\tcurrent = funcValue\n\t\t\t\t\tisFunc = true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif !isFunc {\n\t\t\t\t// If current a pointer, resolve it\n\t\t\t\tif current.Kind() == reflect.Ptr {\n\t\t\t\t\tcurrent = current.Elem()\n\t\t\t\t\tif !current.IsValid() {\n\t\t\t\t\t\t// Value is not valid (anymore)\n\t\t\t\t\t\treturn AsValue(nil), nil\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Look up which part must be called now\n\t\t\t\tswitch part.typ {\n\t\t\t\tcase varTypeInt:\n\t\t\t\t\t// Calling an index is only possible for:\n\t\t\t\t\t// * slices/arrays/strings\n\t\t\t\t\tswitch current.Kind() {\n\t\t\t\t\tcase reflect.String, reflect.Array, reflect.Slice:\n\t\t\t\t\t\tif part.i >= 0 && current.Len() > part.i {\n\t\t\t\t\t\t\tcurrent = current.Index(part.i)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// In Django, exceeding the length of a list is just empty.\n\t\t\t\t\t\t\treturn AsValue(nil), nil\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"can't access an index on type %s (variable %s)\",\n\t\t\t\t\t\t\tcurrent.Kind().String(), vr.String())\n\t\t\t\t\t}\n\t\t\t\tcase varTypeIdent:\n\t\t\t\t\t// Calling a field or key\n\t\t\t\t\tswitch current.Kind() {\n\t\t\t\t\tcase reflect.Struct:\n\t\t\t\t\t\tcurrent = current.FieldByName(part.s)\n\t\t\t\t\tcase reflect.Map:\n\t\t\t\t\t\tcurrent = current.MapIndex(reflect.ValueOf(part.s))\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"can't access a field by name on type %s (variable %s)\",\n\t\t\t\t\t\t\tcurrent.Kind().String(), vr.String())\n\t\t\t\t\t}\n\t\t\t\tcase varTypeSubscript:\n\t\t\t\t\t// Calling an index is only possible for:\n\t\t\t\t\t// * slices/arrays/strings\n\t\t\t\t\tswitch current.Kind() {\n\t\t\t\t\tcase reflect.String, reflect.Array, reflect.Slice:\n\t\t\t\t\t\tsv, err := part.subscript.Evaluate(ctx)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsi := sv.Integer()\n\t\t\t\t\t\tif si >= 0 && current.Len() > si {\n\t\t\t\t\t\t\tcurrent = current.Index(si)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// In Django, exceeding the length of a list is just empty.\n\t\t\t\t\t\t\treturn AsValue(nil), nil\n\t\t\t\t\t\t}\n\t\t\t\t\t// Calling a field or key\n\t\t\t\t\tcase reflect.Struct:\n\t\t\t\t\t\tsv, err := part.subscript.Evaluate(ctx)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcurrent = current.FieldByName(sv.String())\n\t\t\t\t\tcase reflect.Map:\n\t\t\t\t\t\tsv, err := part.subscript.Evaluate(ctx)\n\t\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif sv.IsNil() {\n\t\t\t\t\t\t\treturn AsValue(nil), nil\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif sv.val.Type().AssignableTo(current.Type().Key()) {\n\t\t\t\t\t\t\tcurrent = current.MapIndex(sv.val)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn AsValue(nil), nil\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"can't access an index on type %s (variable %s)\",\n\t\t\t\t\t\t\tcurrent.Kind().String(), vr.String())\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"unimplemented\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif !current.IsValid() {\n\t\t\t// Value is not valid (anymore)\n\t\t\treturn AsValue(nil), nil\n\t\t}\n\n\t\t// If current is a reflect.ValueOf(pongo2.Value), then unpack it\n\t\t// Happens in function calls (as a return value) or by injecting\n\t\t// into the execution context (e.g. in a for-loop)\n\t\tif current.Type() == typeOfValuePtr {\n\t\t\ttmpValue := current.Interface().(*Value)\n\t\t\tcurrent = tmpValue.val\n\t\t\tisSafe = tmpValue.safe\n\t\t}\n\n\t\t// Check whether this is an interface and resolve it where required\n\t\tif current.Kind() == reflect.Interface {\n\t\t\tcurrent = reflect.ValueOf(current.Interface())\n\t\t}\n\n\t\t// Check if the part is a function call\n\t\tif part.isFunctionCall || current.Kind() == reflect.Func {\n\t\t\t// Check for callable\n\t\t\tif current.Kind() != reflect.Func {\n\t\t\t\treturn nil, fmt.Errorf(\"'%s' is not a function (it is %s)\", vr.String(), current.Kind().String())\n\t\t\t}\n\n\t\t\t// Check for correct function syntax and types\n\t\t\t// func(*Value, ...) *Value\n\t\t\tt := current.Type()\n\t\t\tcurrArgs := part.callingArgs\n\n\t\t\t// If an implicit ExecCtx is needed\n\t\t\tif t.NumIn() > 0 && t.In(0) == typeOfExecCtxPtr {\n\t\t\t\tcurrArgs = append([]functionCallArgument{executionCtxEval{}}, currArgs...)\n\t\t\t}\n\n\t\t\t// Input arguments\n\t\t\tif len(currArgs) != t.NumIn() && !(len(currArgs) >= t.NumIn()-1 && t.IsVariadic()) {\n\t\t\t\treturn nil,\n\t\t\t\t\tfmt.Errorf(\"function input argument count (%d) of '%s' must be equal to the calling argument count (%d)\",\n\t\t\t\t\t\tt.NumIn(), vr.String(), len(currArgs))\n\t\t\t}\n\n\t\t\t// Output arguments\n\t\t\tif t.NumOut() != 1 && t.NumOut() != 2 {\n\t\t\t\treturn nil, fmt.Errorf(\"'%s' must have exactly 1 or 2 output arguments, the second argument must be of type error\", vr.String())\n\t\t\t}\n\n\t\t\t// Evaluate all parameters\n\t\t\tvar parameters []reflect.Value\n\n\t\t\tnumArgs := t.NumIn()\n\t\t\tisVariadic := t.IsVariadic()\n\t\t\tvar fnArg reflect.Type\n\n\t\t\tfor idx, arg := range currArgs {\n\t\t\t\tpv, err := arg.Evaluate(ctx)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\tif isVariadic {\n\t\t\t\t\tif idx >= t.NumIn()-1 {\n\t\t\t\t\t\tfnArg = t.In(numArgs - 1).Elem()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfnArg = t.In(idx)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfnArg = t.In(idx)\n\t\t\t\t}\n\n\t\t\t\tif fnArg != typeOfValuePtr {\n\t\t\t\t\t// Function's argument is not a *pongo2.Value, then we have to check whether input argument is of the same type as the function's argument\n\t\t\t\t\tif !isVariadic {\n\t\t\t\t\t\tif fnArg != reflect.TypeOf(pv.Interface()) && fnArg.Kind() != reflect.Interface {\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"function input argument %d of '%s' must be of type %s or *pongo2.Value (not %T)\",\n\t\t\t\t\t\t\t\tidx, vr.String(), fnArg.String(), pv.Interface())\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif fnArg != reflect.TypeOf(pv.Interface()) && fnArg.Kind() != reflect.Interface {\n\t\t\t\t\t\t\treturn nil, fmt.Errorf(\"function variadic input argument of '%s' must be of type %s or *pongo2.Value (not %T)\",\n\t\t\t\t\t\t\t\tvr.String(), fnArg.String(), pv.Interface())\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif pv.IsNil() {\n\t\t\t\t\t\t// Workaround to present an interface nil as reflect.Value\n\t\t\t\t\t\tvar empty any = nil\n\t\t\t\t\t\tparameters = append(parameters, reflect.ValueOf(&empty).Elem())\n\t\t\t\t\t} else {\n\t\t\t\t\t\tparameters = append(parameters, reflect.ValueOf(pv.Interface()))\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Function's argument is a *pongo2.Value\n\t\t\t\t\tparameters = append(parameters, reflect.ValueOf(pv))\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check if any of the values are invalid\n\t\t\tfor _, p := range parameters {\n\t\t\t\tif p.Kind() == reflect.Invalid {\n\t\t\t\t\treturn nil, fmt.Errorf(\"calling a function using an invalid parameter\")\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Call it and get first return parameter back\n\t\t\tvalues := current.Call(parameters)\n\t\t\trv := values[0]\n\t\t\tif t.NumOut() == 2 {\n\t\t\t\te := values[1].Interface()\n\t\t\t\tif e != nil {\n\t\t\t\t\terr, ok := e.(error)\n\t\t\t\t\tif !ok {\n\t\t\t\t\t\treturn nil, fmt.Errorf(\"the second return value is not an error\")\n\t\t\t\t\t}\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif rv.Type() != typeOfValuePtr {\n\t\t\t\tcurrent = reflect.ValueOf(rv.Interface())\n\t\t\t} else {\n\t\t\t\t// Return the function call value\n\t\t\t\tcurrent = rv.Interface().(*Value).val\n\t\t\t\tisSafe = rv.Interface().(*Value).safe\n\t\t\t}\n\t\t}\n\n\t\tif !current.IsValid() {\n\t\t\t// Value is not valid (e. g. NIL value)\n\t\t\treturn AsValue(nil), nil\n\t\t}\n\t}\n\n\treturn &Value{val: current, safe: isSafe}, nil\n}\n\nfunc (vr *variableResolver) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tvalue, err := vr.resolve(ctx)\n\tif err != nil {\n\t\treturn AsValue(nil), ctx.Error(err.Error(), vr.locationToken)\n\t}\n\treturn value, nil\n}\n\nfunc (v *nodeFilteredVariable) FilterApplied(name string) bool {\n\tfor _, filter := range v.filterChain {\n\t\tif filter.name == name {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (v *nodeFilteredVariable) Evaluate(ctx *ExecutionContext) (*Value, *Error) {\n\tvalue, err := v.resolver.Evaluate(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor _, filter := range v.filterChain {\n\t\tvalue, err = filter.Execute(value, ctx)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn value, nil\n}\n\n// \"[\" [expr {, expr}] \"]\"\nfunc (p *Parser) parseArray() (IEvaluator, *Error) {\n\tresolver := &variableResolver{\n\t\tlocationToken: p.Current(),\n\t}\n\tp.Consume() // We consume '['\n\n\t// We allow an empty list, so check for a closing bracket.\n\tif p.Match(TokenSymbol, \"]\") != nil {\n\t\treturn resolver, nil\n\t}\n\n\t// parsing an array declaration with at least one expression\n\tfor {\n\t\tif p.Remaining() == 0 {\n\t\t\treturn nil, p.Error(\"Unexpected EOF, unclosed array list.\", p.lastToken)\n\t\t}\n\n\t\t// No closing bracket, so we're parsing an expression\n\t\texprArg, err := p.ParseExpression()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tresolver.parts = append(resolver.parts, &variablePart{\n\t\t\ttyp:       varTypeArray,\n\t\t\tsubscript: exprArg,\n\t\t})\n\n\t\tif p.Match(TokenSymbol, \"]\") != nil {\n\t\t\t// If there's a closing bracket after an expression, we will stop parsing the arguments\n\t\t\tbreak\n\t\t}\n\n\t\t// If there's NO closing bracket, there MUST be an comma\n\t\tif p.Match(TokenSymbol, \",\") == nil {\n\t\t\treturn nil, p.Error(\"Missing comma or closing bracket after argument.\", p.Current())\n\t\t}\n\t}\n\n\treturn resolver, nil\n}\n\n// IDENT | IDENT.(IDENT|NUMBER)... | IDENT[expr]... | \"[\" [ expr {, expr}] \"]\"\nfunc (p *Parser) parseVariableOrLiteral() (IEvaluator, *Error) {\n\tt := p.Current()\n\n\tif t == nil {\n\t\treturn nil, p.Error(\"Unexpected EOF, expected a number, string, keyword or identifier.\", p.lastToken)\n\t}\n\n\t// Is first part a number or a string, there's nothing to resolve (because there's only to return the value then)\n\tswitch t.Typ {\n\tcase TokenNumber:\n\t\tp.Consume()\n\n\t\t// One exception to the rule that we don't have float64 literals is at the beginning\n\t\t// of an expression (or a variable name). Since we know we started with an integer\n\t\t// which can't obviously be a variable name, we can check whether the first number\n\t\t// is followed by dot (and then a number again). If so we're converting it to a float64.\n\n\t\tif p.Match(TokenSymbol, \".\") != nil {\n\t\t\t// float64\n\t\t\tt2 := p.MatchType(TokenNumber)\n\t\t\tif t2 == nil {\n\t\t\t\treturn nil, p.Error(\"Expected a number after the '.'.\", nil)\n\t\t\t}\n\t\t\tf, err := strconv.ParseFloat(fmt.Sprintf(\"%s.%s\", t.Val, t2.Val), 64)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, p.Error(err.Error(), t)\n\t\t\t}\n\t\t\tfr := &floatResolver{\n\t\t\t\tlocationToken: t,\n\t\t\t\tval:           f,\n\t\t\t}\n\t\t\treturn fr, nil\n\t\t}\n\t\ti, err := strconv.Atoi(t.Val)\n\t\tif err != nil {\n\t\t\treturn nil, p.Error(err.Error(), t)\n\t\t}\n\t\tnr := &intResolver{\n\t\t\tlocationToken: t,\n\t\t\tval:           i,\n\t\t}\n\t\treturn nr, nil\n\tcase TokenString:\n\t\tp.Consume()\n\t\tsr := &stringResolver{\n\t\t\tlocationToken: t,\n\t\t\tval:           t.Val,\n\t\t}\n\t\treturn sr, nil\n\tcase TokenKeyword:\n\t\tp.Consume()\n\t\tswitch t.Val {\n\t\tcase \"true\":\n\t\t\tbr := &boolResolver{\n\t\t\t\tlocationToken: t,\n\t\t\t\tval:           true,\n\t\t\t}\n\t\t\treturn br, nil\n\t\tcase \"false\":\n\t\t\tbr := &boolResolver{\n\t\t\t\tlocationToken: t,\n\t\t\t\tval:           false,\n\t\t\t}\n\t\t\treturn br, nil\n\t\tdefault:\n\t\t\treturn nil, p.Error(\"This keyword is not allowed here.\", nil)\n\t\t}\n\tcase TokenSymbol:\n\t\tif t.Val == \"[\" {\n\t\t\t// Parsing an array literal [expr {, expr}]\n\t\t\treturn p.parseArray()\n\t\t}\n\t}\n\n\tresolver := &variableResolver{\n\t\tlocationToken: t,\n\t}\n\n\tif t.Typ != TokenIdentifier {\n\t\t// First part of a variable MUST be an identifier\n\t\treturn nil, p.Error(\"Expected either a number, string, keyword or identifier.\", t)\n\t}\n\n\tresolver.parts = append(resolver.parts, &variablePart{\n\t\ttyp: varTypeIdent,\n\t\ts:   t.Val,\n\t})\n\tp.Consume() // we consumed the first identifier of the variable name\n\nvariableLoop:\n\tfor p.Remaining() > 0 {\n\t\tif p.Match(TokenSymbol, \".\") != nil {\n\t\t\t// Next variable part (can be either NUMBER or IDENT)\n\t\t\tt2 := p.Current()\n\t\t\tif t2 != nil {\n\t\t\t\tswitch t2.Typ {\n\t\t\t\tcase TokenIdentifier:\n\t\t\t\t\tresolver.parts = append(resolver.parts, &variablePart{\n\t\t\t\t\t\ttyp: varTypeIdent,\n\t\t\t\t\t\ts:   t2.Val,\n\t\t\t\t\t})\n\t\t\t\t\tp.Consume() // consume: IDENT\n\t\t\t\t\tcontinue variableLoop\n\t\t\t\tcase TokenNumber:\n\t\t\t\t\ti, err := strconv.Atoi(t2.Val)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, p.Error(err.Error(), t2)\n\t\t\t\t\t}\n\t\t\t\t\tresolver.parts = append(resolver.parts, &variablePart{\n\t\t\t\t\t\ttyp: varTypeInt,\n\t\t\t\t\t\ti:   i,\n\t\t\t\t\t})\n\t\t\t\t\tp.Consume() // consume: NUMBER\n\t\t\t\t\tcontinue variableLoop\n\t\t\t\tcase TokenNil:\n\t\t\t\t\tresolver.parts = append(resolver.parts, &variablePart{\n\t\t\t\t\t\ttyp:   varTypeNil,\n\t\t\t\t\t\tisNil: true,\n\t\t\t\t\t})\n\t\t\t\t\tp.Consume() // consume: NIL\n\t\t\t\t\tcontinue variableLoop\n\t\t\t\tdefault:\n\t\t\t\t\treturn nil, p.Error(\"This token is not allowed within a variable name.\", t2)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// EOF\n\t\t\t\treturn nil, p.Error(\"Unexpected EOF, expected either IDENTIFIER or NUMBER after DOT.\",\n\t\t\t\t\tp.lastToken)\n\t\t\t}\n\t\t} else if p.Match(TokenSymbol, \"[\") != nil {\n\t\t\t// Variable subscript\n\t\t\tif p.Remaining() == 0 {\n\t\t\t\treturn nil, p.Error(\"Unexpected EOF, expected subscript subscript.\", p.lastToken)\n\t\t\t}\n\n\t\t\texprSubscript, err := p.ParseExpression()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tresolver.parts = append(resolver.parts, &variablePart{\n\t\t\t\ttyp:       varTypeSubscript,\n\t\t\t\tsubscript: exprSubscript,\n\t\t\t})\n\t\t\tif p.Match(TokenSymbol, \"]\") == nil {\n\t\t\t\treturn nil, p.Error(\"Missing closing bracket after subscript argument.\", nil)\n\t\t\t}\n\n\t\t} else if p.Match(TokenSymbol, \"(\") != nil {\n\t\t\t// Function call\n\t\t\t// FunctionName '(' Comma-separated list of expressions ')'\n\t\t\tpart := resolver.parts[len(resolver.parts)-1]\n\t\t\tpart.isFunctionCall = true\n\t\targumentLoop:\n\t\t\tfor {\n\t\t\t\tif p.Remaining() == 0 {\n\t\t\t\t\treturn nil, p.Error(\"Unexpected EOF, expected function call argument list.\", p.lastToken)\n\t\t\t\t}\n\n\t\t\t\tif p.Peek(TokenSymbol, \")\") == nil {\n\t\t\t\t\t// No closing bracket, so we're parsing an expression\n\t\t\t\t\texprArg, err := p.ParseExpression()\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn nil, err\n\t\t\t\t\t}\n\t\t\t\t\tpart.callingArgs = append(part.callingArgs, exprArg)\n\n\t\t\t\t\tif p.Match(TokenSymbol, \")\") != nil {\n\t\t\t\t\t\t// If there's a closing bracket after an expression, we will stop parsing the arguments\n\t\t\t\t\t\tbreak argumentLoop\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If there's NO closing bracket, there MUST be an comma\n\t\t\t\t\t\tif p.Match(TokenSymbol, \",\") == nil {\n\t\t\t\t\t\t\treturn nil, p.Error(\"Missing comma or closing bracket after argument.\", nil)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// We got a closing bracket, so stop parsing arguments\n\t\t\t\t\tp.Consume()\n\t\t\t\t\tbreak argumentLoop\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t// We're done parsing the function call, next variable part\n\t\t\tcontinue variableLoop\n\t\t}\n\n\t\t// No dot, subscript or function call? Then we're done with the variable parsing\n\t\tbreak\n\t}\n\n\treturn resolver, nil\n}\n\nfunc (p *Parser) parseVariableOrLiteralWithFilter() (*nodeFilteredVariable, *Error) {\n\tv := &nodeFilteredVariable{\n\t\tlocationToken: p.Current(),\n\t}\n\n\t// Parse the variable name\n\tresolver, err := p.parseVariableOrLiteral()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tv.resolver = resolver\n\n\t// Parse all the filters\nfilterLoop:\n\tfor p.Match(TokenSymbol, \"|\") != nil {\n\t\t// Parse one single filter\n\t\tfilter, err := p.parseFilter()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Check sandbox filter restriction\n\t\tif _, isBanned := p.template.set.bannedFilters[filter.name]; isBanned {\n\t\t\treturn nil, p.Error(fmt.Sprintf(\"Usage of filter '%s' is not allowed (sandbox restriction active).\", filter.name), nil)\n\t\t}\n\n\t\tv.filterChain = append(v.filterChain, filter)\n\n\t\tcontinue filterLoop\n\t}\n\n\treturn v, nil\n}\n\nfunc (p *Parser) parseVariableElement() (INode, *Error) {\n\tnode := &nodeVariable{\n\t\tlocationToken: p.Current(),\n\t}\n\n\tp.Consume() // consume '{{'\n\n\texpr, err := p.ParseExpression()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnode.expr = expr\n\n\tif p.Match(TokenSymbol, \"}}\") == nil {\n\t\treturn nil, p.Error(\"'}}' expected\", nil)\n\t}\n\n\treturn node, nil\n}\n"
        }
      ]
    }
  ]
}