{
  "metadata": {
    "timestamp": 1736566921489,
    "page": 495,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjUwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cristaloleg/go-advice",
      "stars": 3124,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.181640625,
          "content": "This is free and unencumbered software released into the public domain.\n\nAnyone is free to copy, modify, publish, use, compile, sell, or\ndistribute this software, either in source code form or as a compiled\nbinary, for any purpose, commercial or non-commercial, and by any\nmeans.\n\nIn jurisdictions that recognize copyright laws, the author or authors\nof this software dedicate any and all copyright interest in the\nsoftware to the public domain. We make this dedication for the benefit\nof the public at large and to the detriment of our heirs and\nsuccessors. We intend this dedication to be an overt act of\nrelinquishment in perpetuity of all present and future rights to this\nsoftware under copyright law.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR\nOTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\nARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n\nFor more information, please refer to <http://unlicense.org>\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 15.7119140625,
          "content": "# Go-advice\n\n(Some of advices are implemented in [go-critic](https://github.com/go-critic/go-critic))\n\n- [中文版](./README_ZH.md)\n- [한국어](./README_KR.md)\n\n## Contents\n\n- [Go Proverbs](#go-proverbs)\n- [The Zen of Go](#the-zen-of-go)\n- [Code](#code)\n- [Concurrency](#concurrency)\n- [Performance](#performance)\n- [Modules](#modules)\n- [Build](#build)\n- [Testing](#testing)\n- [Tools](#tools)\n- [Misc](#misc)\n\n### Go Proverbs\n\n- Don't communicate by sharing memory, share memory by communicating.\n- Concurrency is not parallelism.\n- Channels orchestrate; mutexes serialize.\n- The bigger the interface, the weaker the abstraction.\n- Make the zero value useful.\n- `interface{}` says nothing.\n- Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.\n- A little copying is better than a little dependency.\n- Syscall must always be guarded with build tags.\n- Cgo must always be guarded with build tags.\n- Cgo is not Go.\n- With the unsafe package there are no guarantees.\n- Clear is better than clever.\n- Reflection is never clear.\n- Errors are values.\n- Don't just check errors, handle them gracefully.\n- Design the architecture, name the components, document the details.\n- Documentation is for users.\n- Don't panic.\n\nAuthor: Rob Pike\nSee more: https://go-proverbs.github.io/\n\n### The Zen of Go\n\n- Each package fulfils a single purpose\n- Handle errors explicitly\n- Return early rather than nesting deeply\n- Leave concurrency to the caller\n- Before you launch a goroutine, know when it will stop\n- Avoid package level state\n- Simplicity matters\n- Write tests to lock in the behaviour of your package’s API\n- If you think it’s slow, first prove it with a benchmark\n- Moderation is a virtue\n- Maintainability counts\n\nAuthor: Dave Cheney\nSee more: https://the-zen-of-go.netlify.com/\n\n### Code\n\n#### Always `go fmt` your code.\n\nCommunity uses the official Go format, do not reinvent the wheel.\n\nTry to reduce code entropy. This will help everyone to make code easy to read.\n\n#### Multiple if-else statements can be collapsed into a switch\n\n```go\n// NOT BAD\nif foo() {\n\t// ...\n} else if bar == baz {\n\t// ...\n} else {\n\t// ...\n}\n\n// BETTER\nswitch {\ncase foo():\n\t// ...\ncase bar == baz:\n\t// ...\ndefault:\n\t// ...\n}\n```\n\n#### To pass a signal prefer `chan struct{}` instead of `chan bool`.\n\nWhen you see a definition of `chan bool` in a structure, sometimes it's not that easy to understand how this value will be used, example:\n```go\ntype Service struct {\n\tdeleteCh chan bool // what does this bool mean? \n}\n```\n\nBut we can make it more clear by changing it to `chan struct{}` which explicitly says: we do not care about value (it's always a `struct{}`), we care about an event that might occur, example:\n```go\ntype Service struct {\n\tdeleteCh chan struct{} // ok, if event than delete something.\n}\n```\n\n#### Prefer `30 * time.Second` instead of `time.Duration(30) * time.Second`\n\nYou don't need to wrap untyped const in a type, compiler will figure it out. Also prefer to move const to the first place:\n```go\n// BAD\ndelay := time.Second * 60 * 24 * 60\n\n// VERY BAD\ndelay := 60 * time.Second * 60 * 24\n\n// GOOD\ndelay := 24 * 60 * 60 * time.Second\n\n// EVEN BETTER\ndelay := 24 * time.Hour\n```\n\n#### Use `time.Duration` instead of `int64` + variable name\n\n```go\n// BAD\nvar delayMillis int64 = 15000\n\n// GOOD\nvar delay time.Duration = 15 * time.Second\n```\n\n#### Group `const` declarations by type and `var` by logic and/or type\n\n```go\n// BAD\nconst (\n\tfoo     = 1\n\tbar     = 2\n\tmessage = \"warn message\"\n)\n\n// MOSTLY BAD\nconst foo = 1\nconst bar = 2\nconst message = \"warn message\"\n\n// GOOD\nconst (\n\tfoo = 1\n\tbar = 2\n)\n\nconst message = \"warn message\"\n```\n\nThis pattern works for `var` too.\n\n- [ ] every blocking or IO function call should be cancelable or at least timeoutable\n- [ ] implement `Stringer` interface for integers const values\n  - https://godoc.org/golang.org/x/tools/cmd/stringer\n- [ ] check your defer's error\n\n```go\ndefer func() {\n\terr := ocp.Close()\n\tif err != nil {\n\t\trerr = err\n\t}\n}()\n```\n\n- [ ] don't use `checkErr` function which panics or does `os.Exit`\n- [ ] use panic only in very specific situations, you have to handle error\n- [ ] don't use alias for enums 'cause this breaks type safety\n  - https://play.golang.org/p/MGbeDwtXN3\n\n```go\npackage main\n\ntype Status = int\ntype Format = int // remove `=` to have type safety\n\nconst A Status = 1\nconst B Format = 1\n\nfunc main() {\n\tprintln(A == B)\n}\n```\n\n- [ ] if you're going to omit returning params, do it explicitly\n  - so prefer this ` _ = f()` to this `f()`\n- [ ] the short form for slice initialization is `a := []T{}`\n- [ ] iterate over array or slice using range loop\n  -  instead of `for i := 3; i < 7; i++ {...}` prefer `for _, c := range a[3:7] {...}`\n- [ ] use backquote(\\`) for multiline strings\n- [ ] skip unused param with _\n\n```go\nfunc f(a int, _ string) {}\n```\n\n- [ ] If you are comparing timestamps, use `time.Before` or `time.After`. Don't use `time.Sub` to get a duration and then check its value.\n- [ ] always pass context as a first param to a func with a `ctx` name\n- [ ] few params of the same type can be defined in a short way\n\n```go\nfunc f(a int, b int, s string, p string)\n```\n\n```go\nfunc f(a, b int, s, p string)\n```\n\n- [ ] the zero value of a slice is nil\n  - https://play.golang.org/p/pNT0d_Bunq\n\n```go\nvar s []int\nfmt.Println(s, len(s), cap(s))\nif s == nil {\n\tfmt.Println(\"nil!\")\n}\n// Output:\n// [] 0 0\n// nil!\n```\n\n  - https://play.golang.org/p/meTInNyxtk\n\n```go\nvar a []string\nb := []string{}\n\nfmt.Println(reflect.DeepEqual(a, []string{}))\nfmt.Println(reflect.DeepEqual(b, []string{}))\n// Output:\n// false\n// true\n```\n\n- [ ] do not compare enum types with `<`, `>`, `<=` and `>=`\n  - use explicit values, don't do this:\n  \n```go\nvalue := reflect.ValueOf(object)\nkind := value.Kind()\nif kind >= reflect.Chan && kind <= reflect.Slice {\n\t// ...\n}\n```\n\n- [ ] use `%+v` to print data with sufficient details\n- [ ] be careful with empty struct `struct{}`, see issue: https://github.com/golang/go/issues/23440\n  - more: https://play.golang.org/p/9C0puRUstrP\n\n```go\nfunc f1() {\n\tvar a, b struct{}\n\tprint(&a, \"\\n\", &b, \"\\n\") // Prints same address\n\tfmt.Println(&a == &b)     // Comparison returns false\n}\n\nfunc f2() {\n\tvar a, b struct{}\n\tfmt.Printf(\"%p\\n%p\\n\", &a, &b) // Again, same address\n\tfmt.Println(&a == &b)          // ...but the comparison returns true\n}\n```\n\n- [ ] wrap errors with `fmt.Errorf`\n  - so: `fmt.Errorf(\"additional message to a given error: %w\", err)`\n- [ ] be careful with `range` in Go:\n  - `for i := range a` and `for i, v := range &a` doesn't make a copy of `a`\n  - but `for i, v := range a` does\n  - more: https://play.golang.org/p/4b181zkB1O\n- [ ] reading nonexistent key from map will not panic\n  - `value := map[\"no_key\"]` will be zero value\n  - `value, ok := map[\"no_key\"]` is much better\n- [ ] do not use raw params for file operation\n  - instead of an octal parameter like `os.MkdirAll(root, 0700)`\n  - use predefined constants of this type `os.FileMode`\n- [ ] don't forget to specify a type for `iota`\n  - https://play.golang.org/p/mZZdMaI92cI\n\n```go\nconst (\n\t_ = iota\n\ttestvar // will be int\n)\n```\n\n  vs\n\n```go\ntype myType int\nconst (\n\t_ myType = iota\n\ttestvar // will be myType\n)\n```\n\n#### Don’t use `encoding/gob` on structs you don’t own.\n\nAt some point structure may change and you might miss this. As a result this might cause a hard to find bug.\n\n#### Don't depend on the evaluation order, especially in a return statement.\n\n```go\n// BAD\nreturn res, json.Unmarshal(b, &res)\n\n// GOOD\nerr := json.Unmarshal(b, &res)\nreturn res, err\n```\n\n#### To prevent unkeyed literals add `_ struct{}` field:\n\n```go\ntype Point struct {\n\tX, Y float64\n\t_    struct{} // to prevent unkeyed literals\n}\n```\n\nFor `Point{X: 1, Y: 1}` everything will be fine, but for `Point{1,1}` you will get a compile error:\n```\n./file.go:1:11: too few values in Point literal\n```\n\nThere is a check in `go vet` command for this, there is no enough arguments to add `_ struct{}` in all your structs.\n\n#### To prevent structs comparison add an empty field of `func` type\n\n```go\ntype Point struct {\n\t_ [0]func()\t// unexported, zero-width non-comparable field\n\tX, Y float64\n}\n```\n\n#### Prefer `http.HandlerFunc` over `http.Handler`\n\nTo use the 1st one you just need a func, for the 2nd you need a type.\n\n#### Move `defer` to the top\n\nThis improves code readability and makes clear what will be invoked at the end of a function.\n\n#### JavaScript parses integers as floats and your int64 might overflow.\n\nUse `json:\"id,string\"` instead.\n\n```go\ntype Request struct {\n\tID int64 `json:\"id,string\"`\n}\n```\n\n### Concurrency\n- [ ] best candidate to make something once in a thread-safe way is `sync.Once`\n  - don't use flags, mutexes, channels or atomics\n- [ ] to block forever use `select{}`, omit channels, waiting for a signal\n- [ ] don't close in-channel, this is a responsibility of it's creator\n  - writing to a closed channel will cause a panic\n- [ ] `func NewSource(seed int64) Source` in `math/rand` is not concurrency-safe. The default `lockedSource` is concurrency-safe, see issue: https://github.com/golang/go/issues/3611\n  - more: https://golang.org/pkg/math/rand/\n- [ ] when you need an atomic value of a custom type use [atomic.Value](https://godoc.org/sync/atomic#Value)\n\n### Performance\n- [ ] do not omit `defer`\n  - 200ns speedup is negligible in most cases\n- [ ] always close http body aka `defer r.Body.Close()`\n  - unless you need leaked goroutine\n- [ ] filtering without allocating\n\n```go\nb := a[:0]\nfor _, x := range a {\n\tif f(x) {\n\t\tb = append(b, x)\n\t}\n}\n```\n\n#### To help compiler to remove bound checks see this pattern `_ = b[7]`\n\n- [ ] `time.Time` has pointer field `time.Location` and this is bad for go GC\n  - it's relevant only for big number of `time.Time`, use timestamp instead\n- [ ] prefer `regexp.MustCompile` instead of `regexp.Compile`\n  - in most cases your regex is immutable, so init it in `func init`\n- [ ] do not overuse `fmt.Sprintf` in your hot path. It is costly due to maintaining the buffer pool and dynamic dispatches for interfaces.\n  - if you are doing `fmt.Sprintf(\"%s%s\", var1, var2)`, consider simple string concatenation.\n  - if you are doing `fmt.Sprintf(\"%x\", var)`, consider using `hex.EncodeToString` or `strconv.FormatInt(var, 16)`\n- [ ] always discard body e.g. `io.Copy(ioutil.Discard, resp.Body)` if you don't use it\n  - HTTP client's Transport will not reuse connections unless the body is read to completion and closed\n\n```go\nres, _ := client.Do(req)\nio.Copy(ioutil.Discard, res.Body)\ndefer res.Body.Close()\n```\n\n- [ ] don't use defer in a loop or you'll get a small memory leak\n  - 'cause defers will grow your stack without the reason\n- [ ] don't forget to stop ticker, unless you need a leaked channel\n\n```go\nticker := time.NewTicker(1 * time.Second)\ndefer ticker.Stop()\n```\n\n- [ ] use custom marshaler to speed up marshaling\n  - but before using it - profile! ex: https://play.golang.org/p/SEm9Hvsi0r\n\n```go\nfunc (entry Entry) MarshalJSON() ([]byte, error) {\n\tbuffer := bytes.NewBufferString(\"{\")\n\tfirst := true\n\tfor key, value := range entry {\n\t\tjsonValue, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !first {\n\t\t\tbuffer.WriteString(\",\")\n\t\t}\n\t\tfirst = false\n\t\tbuffer.WriteString(key + \":\" + string(jsonValue))\n\t}\n\tbuffer.WriteString(\"}\")\n\treturn buffer.Bytes(), nil\n}\n```\n\n- [ ] `sync.Map` isn't a silver bullet, do not use it without a strong reasons\n  - more: https://github.com/golang/go/blob/master/src/sync/map.go#L12\n- [ ] storing non-pointer values in `sync.Pool` allocates memory\n  - more: https://staticcheck.io/docs/checks#SA6002\n- [ ] to hide a pointer from escape analysis you might carefully(!!!) use this func:\n  - source: https://go-review.googlesource.com/c/go/+/86976\n\n```go\n// noescape hides a pointer from escape analysis.  noescape is\n// the identity function but escape analysis doesn't think the\n// output depends on the input. noescape is inlined and currently\n// compiles down to zero instructions.\nfunc noescape(p unsafe.Pointer) unsafe.Pointer {\n\tx := uintptr(p)\n\treturn unsafe.Pointer(x ^ 0)\n}\n```\n\n- [ ] for fastest atomic swap you might use this\n  `m := (*map[int]int)(atomic.LoadPointer(&ptr))`\n- [ ] use buffered I/O if you do many sequential reads or writes\n  - to reduce number of syscalls\n- [ ] there are 2 ways to clear a map:\n  - reuse map memory\n\n```go\nfor k := range m {\n\tdelete(m, k)\n}\n```\n\n  - allocate new\n\n```go\nm = make(map[int]int)\n```\n\n### Modules\n- [ ] if you want to test that `go.mod` (and `go.sum`) is up to date in CI\n  https://blog.urth.org/2019/08/13/testing-go-mod-tidiness-in-ci/\n\n### Build\n- [ ] strip your binaries with this command `go build -ldflags=\"-s -w\" ...`\n- [ ] easy way to split test into different builds\n  - use `// +build integration` and run them with `go test -v --tags integration .`\n- [ ] tiniest Go docker image\n  - https://twitter.com/bbrodriges/status/873414658178396160\n  - `CGO_ENABLED=0 go build -ldflags=\"-s -w\" app.go && tar C app | docker import - myimage:latest`\n- [ ] run `go format` on CI and compare diff\n  - this will ensure that everything was generated and committed\n- [ ] to run Travis-CI with the latest Go use `travis 1`\n  - see more: https://github.com/travis-ci/travis-build/blob/master/public/version-aliases/go.json\n- [ ] check if there are mistakes in code formatting `diff -u <(echo -n) <(gofmt -d .)`\n\n### Testing\n- [ ] prefer `package_test` name for tests, rather than `package`\n- [ ] `go test -short` allows to reduce set of tests to be runned\n\n```go\nfunc TestSomething(t *testing.T) {\n\tif testing.Short() {\n\t\tt.Skip(\"skipping test in short mode.\")\n\t}\n}\n```\n\n- [ ] skip test depending on architecture\n\n```go\nif runtime.GOARM == \"arm\" {\n\tt.Skip(\"this doesn't work under ARM\")\n}\n```\n\n- [ ] track your allocations with `testing.AllocsPerRun`\n  - https://godoc.org/testing#AllocsPerRun\n- [ ] run your benchmarks multiple times, to get rid of noise\n  - `go test -test.bench=. -count=20`\n\n### Tools\n- [ ] quick replace `gofmt -w -l -r \"panic(err) -> log.Error(err)\" .`\n- [ ] `go list` allows to find all direct and transitive dependencies\n  - `go list -f '{{ .Imports }}' package`\n  - `go list -f '{{ .Deps }}' package`\n- [ ] for fast benchmark comparison we've a `benchstat` tool\n  - https://godoc.org/golang.org/x/perf/cmd/benchstat\n- [ ] [go-critic](https://github.com/go-critic/go-critic) linter enforces several advices from this document\n- [ ] `go mod why -m <module>` tells us why a particular module is in the `go.mod` file\n- [ ] `GOGC=off go build ...` should speed up your builds [source](https://twitter.com/mvdan_/status/1107579946501853191)\n- [ ] The memory profiler records one allocation every 512Kbytes. You can increase the rate via the `GODEBUG` environment variable to see more details in your profile.\n  - by https://twitter.com/bboreham/status/1105036740253937664\n\n### Misc\n- [ ] dump goroutines https://stackoverflow.com/a/27398062/433041\n\n```go\ngo func() {\n\tsigs := make(chan os.Signal, 1)\n\tsignal.Notify(sigs, syscall.SIGQUIT)\n\tbuf := make([]byte, 1<<20)\n\tfor {\n\t\t<-sigs\n\t\tstacklen := runtime.Stack(buf, true)\n\t\tlog.Printf(\"=== received SIGQUIT ===\\n*** goroutine dump...\\n%s\\n*** end\\n\", buf[:stacklen])\n\t}\n}()\n```\n\n- [ ] check interface implementation during compilation\n\n```go\nvar _ io.Reader = (*MyFastReader)(nil)\n```\n\n- [ ] if a param of len is nil then it's zero\n  - https://golang.org/pkg/builtin/#len\n- [ ] anonymous structs are cool\n\n```go\nvar hits struct {\n\tsync.Mutex\n\tn int\n}\nhits.Lock()\nhits.n++\nhits.Unlock()\n```\n\n- [ ] `httputil.DumpRequest` is very useful thing, don't create your own\n  - https://godoc.org/net/http/httputil#DumpRequest\n- [ ] to get call stack we've `runtime.Caller` https://golang.org/pkg/runtime/#Caller\n- [ ] to marshal arbitrary JSON you can marshal to `map[string]interface{}{}`\n- [ ] configure your `CDPATH` so you can do `cd github.com/golang/go` from any directore\n  - add this line to your `bashrc`(or analogue) `export CDPATH=$CDPATH:$GOPATH/src`\n- [ ] simple random element from a slice\n  - `[]string{\"one\", \"two\", \"three\"}[rand.Intn(3)]`\n"
        },
        {
          "name": "README_KR.md",
          "type": "blob",
          "size": 20.6474609375,
          "content": "# Go-advice\n\n(Some of advices are implemented in [go-critic](https://github.com/go-critic/go-critic))\n\n## Contents\n\n- [Go Proverbs](#go-proverbs)\n- [The Zen of Go](#the-zen-of-go)\n- [Code](#code)\n- [Concurrency](#concurrency)\n- [Performance](#performance)\n- [Modules](#modules)\n- [Build](#build)\n- [Testing](#testing)\n- [Tools](#tools)\n- [Misc](#misc)\n\n### Go Proverbs\n\n- 메모리를 공유하면서 통신하지 말고, 통신하면서 메모리를 공유해라.\n- 동시성(concurrency은 병렬(parallelism)처리가 아니다.\n- 채널 오케스트레이션; 뮤텍스 직렬화(serialise).\n- 인터페이스가 커질수록 추상화는 약해진다.\n- 제로값(zero value)를 유용하게 만들자.\n- `interface{}`는 아무 말도 하지 않는다 (say nothing).\n- `gofmt`의 스타일은 어느 누구의 취향(favourite)도 아니지만, `gofmt`는 모두가 좋아하는 스타일이다.\n- 약간의 복사(a little copy) 약간의 의존성(a little dependency)보다 낫다.\n- Syscall은 항상 build tags로 가드(guarded)되어야 한다.\n- Cgo는 항상 build tags로 가드(guarded)되어야 한다.\n- Cgo는 Go가 아니다.\n- `unsafe` 패키지는 어떠한 보증(guarantees)도 없다.\n- 명료함(clear)은 현명함(clever)보다 낫다.\n- 리플렉션(reflection)은 결코 명료하지 않다(is never clear).\n- 에러(errors)는 값(values)이다.\n- 단지 에러를 검사(check) 할 것만이 아니라, 우아하게 다뤄어라 (handle gracefully).\n- 아키텍쳐는 디자인 하라, 컴포넌트를 이름지어라, 상세사항은 문서화 해라(design the architecture, name the components, document the details).\n- 문서는 유저를 위한 것이다.\n- 패닉을 사용하지 말 것 (don't panic).\n\n저자: Rob Pike\n추가 정보: https://go-proverbs.github.io/\n\n### The Zen of Go\n\n- 각 package는 단일 목적을 이행/달성한다.\n- 에러를 분명하게(explicitly) 다루어라.\n- 깊게 중첩하지 말고(nesting deeply) 초기에 리턴(return early) 해라\n- 호출자(caller)에게 동시성(concurrency)를 맡겨라.\n- goroutine을 사용(launch)하기 전, 언제 멈춰어야 할 지 알자.\n- 패키지 레벨 상태를 피해라(avoid package level state).\n- 간단함은 중요하다(simplicity matters).\n- 여러러분들의 API의 행동(behaviour)을 고정하기 위해(to lock) 테스트를 작성해라.\n- 느리다고 생각되면, 먼저 벤치마크를 위해서 증명하라\n- 중재는 미덕이다(moderation is a virtue).\n- 유지보수성을 고려해라(maintainability counts).\n\n저자: Dave Cheney\n추가 정보: https://the-zen-of-go.netlify.com/\n\n### Code\n\n#### Always `go fmt` your code.\n\n커뮤니티는 공식적인 Go의 포맷을 사용한다. 새로운 바퀴를 재발명하지 않도록 하자. (do not reinvent the wheel).\n\n코드의 엔트로피를 감소하기 위해서 노력해라. 이는 다른사람들로 하여금 코드를 읽기 쉽게 도와 줄 것이다.\n\n#### Multiple if-else statements can be collapsed into a switch\n\n```go\n// NOT BAD\nif foo() {\n    // ...\n} else if bar == baz {\n    // ...\n} else {\n    // ...\n}\n\n// BETTER\nswitch {\ncase foo():\n    // ...\ncase bar == baz:\n    // ...\ndefault:\n    // ...\n}\n```\n\n#### To pass a signal prefer `chan struct{}` instead of `chan bool`.\n\n구조체 내에서 `chan bool`의 정의가 있는 경우, 때때로, 이 값이 어떻게 사용될 지에 대해서 이해하는 것이 쉽지 않을 수 있다. 예를들면:\n\n```go\ntype Service struct {\n    deleteCh chan bool // what does this bool mean?\n}\n```\n\n하지만, 우리는 이를 `chan struct{}`로 변경함으로써 더욱 더 분명하게 만들 수 있다. 여기서 `chan struct{}`는 명시적으로 값에 대해서 고려하지 않음을 의미한다(이는 항상 `struct{}`이다). 하지만, 아래의 예와 같이 발생할 수 있는 이벤트에 대해서 생각해 볼 수 있다:\n\n```go\ntype Service struct {\n    deleteCh chan struct{} // ok, if event than delete something.\n}\n```\n\n#### Prefer `30 * time.Second` instead of `time.Duration(30) * time.Second`\n\n타입이 지정되지 않은 const에 대해서 type으로 래핑(wrap)할 필요가 없다. 컴파일러가 이를 스스로 알아 낼 것이다. 또한 const를 우선적으로 명기하는 것을 선호한다. 아래를 참고해라:\n\n```go\n// BAD\ndelay := time.Second * 60 * 24 * 60\n\n// VERY BAD\ndelay := 60 * time.Second * 60 * 24\n\n// GOOD\ndelay := 24 * 60 * 60 * time.Second\n```\n\n#### Use `time.Duration` instead of `int64` + variable name\n\n```go\n// BAD\nvar delayMillis int64 = 15000\n\n// GOOD\nvar delay time.Duration = 15 * time.Second\n```\n\n#### Group `const` declarations by type and `var` by logic and/or type\n\n```go\n// BAD\nconst (\n    foo = 1\n    bar = 2\n    message = \"warn message\"\n)\n\n// MOSTLY BAD\nconst foo = 1\nconst bar = 2\nconst message = \"warn message\"\n\n// GOOD\nconst (\n    foo = 1\n    bar = 2\n)\n\nconst message = \"warn message\"\n```\n\n이 패턴은 `var`의 경우에도 적용된다.\n\n- [ ] 모든 블로킹(every blocking) 혹은 입출력 함수호출(IO function call)은 취소가능(cancelable)하거나 혹은 적어도 타임아웃가능(timeout-able) 해야 한다.\n- [ ] 정수의 상수 값을 위한 `Stringer`인터페이스를 구현해라\n  - https://godoc.org/golang.org/x/tools/cmd/stringer\n- [ ] 여러분들의 defer의 에러에 대해서 체크하자\n\n```go\n  defer func() {\n      err := ocp.Close()\n      if err != nil {\n          rerr = err\n      }\n  }()\n```\n\n- [ ] 패닉이나 `os.Exit`를 수행하는 `checkErr` 함수를 사용하지 말것.\n- [ ] 아주 특정한 상황에만 패닉을 사용하자, 여러분들은 에러를 다루어야 한다(You have to handle errors).\n- [ ] enums에 대해서 alias를 사용하지 말것. 왜냐하면 이는 타입안정성을 깨트릴 수 있기 때문이다.\n  - https://play.golang.org/p/MGbeDwtXN3\n\n```go\n  package main\n  type Status = int\n  type Format = int // remove `=` to have type safety\n\n  const A Status = 1\n  const B Format = 1\n\n  func main() {\n    println(A == B)\n  }\n```\n\n- [ ] 만약 여러분들이 반환되는 파라미터(returning params)를 생략하고자 한다면, 이를 명시적으로 수행해라\n  - 그러므로 ` _ = f()` 을 `f()`보다 선호한다.\n- [ ] 슬라이스 초기화의 약식 형식(short form)은 `a := []T{}`\n- [ ] `range` loop을 사용해서 배열(array)이나 슬라이스(slice)를 순회(iterate over)하라\n  - `for i := 3; i < 7; i++ {...}` 대신에 `for _, c := range a[3:7] {...}`를 사용할 것\n- [ ] 여러라인의 문자열(multiline strings)을 위해 backquote(\\`)를 사용할 것\n- [ ] 사용하지 않는 파라미터는 `_`로 스킵(skip)하자\n\n```go\n  func f(a int, _ string) {}\n```\n\n- [ ] 타임스탬프(timestamps)를 비교할 경우, `time.Before` 혹은 `time.After`를 사용할 것. Duration과 그것의 값을 구하기 위해서 `time.Sub`을 사용하지 말 것.\n- [ ] `context`는 `ctx`라는 이름으로 항상 첫번째 파라미터로 함수에 전달하자\n- [ ] 같은 타입의 소수의 파라미터(few params of the same type)는 짧은 방식으로 정의될 수 있다.\n\n```go\n  func f(a int, b int, s string, p string)\n```\n\n```go\n  func f(a, b int, s, p string)\n```\n\n- [ ] 슬라이스의 제로값(zero value)는 `nil` 이다.\n  - https://play.golang.org/p/pNT0d_Bunq\n  \n  ```go\n    var s []int\n    fmt.Println(s, len(s), cap(s))\n    if s == nil {\n      fmt.Println(\"nil!\")\n    }\n    // Output:\n    // [] 0 0\n    // nil!\n  ```\n\n  - https://play.golang.org/p/meTInNyxtk\n\n```go\n  var a []string\n  b := []string{}\n\n  fmt.Println(reflect.DeepEqual(a, []string{}))\n  fmt.Println(reflect.DeepEqual(b, []string{}))\n  // Output:\n  // false\n  // true\n```\n\n- [ ] 열거형(enum types)을 `<`, `>`, `<=` 그리고 `>=` 와 비교하지 말 것\n  - 명시적인 값을 사용하라. 아래와 같이 하지 말 것:\n\n```go\n  value := reflect.ValueOf(object)\n  kind := value.Kind()\n  if kind >= reflect.Chan && kind <= reflect.Slice {\n    // ...\n  }\n```\n\n- [ ] 충분한 세부사항과 함께 데이터를 출력하위해 `%+v`을 사용할 것\n- [ ] 빈 구조체(empty struct: `struct{}`)를 주의 할 것, 관련 이슈: https://github.com/golang/go/issues/23440\n  - 추가 정보: https://play.golang.org/p/9C0puRUstrP\n\n```go\n  func f1() {\n    var a, b struct{}\n    print(&a, \"\\n\", &b, \"\\n\") // Prints same address\n    fmt.Println(&a == &b)     // Comparison returns false\n  }\n\n  func f2() {\n    var a, b struct{}\n    fmt.Printf(\"%p\\n%p\\n\", &a, &b) // Again, same address\n    fmt.Println(&a == &b)          // ...but the comparison returns true\n  }\n```\n\n- [ ] http://github.com/pkg/errors 를 참고해 에러를 wrap할 것\n  - 그러므로: `errors.Wrap(err, \"additional message to a given error\")`\n- [ ] Go에서의 `range`에 대해서 주의 할 것:\n  - `for i := range a` 와 `for i, v := range &a` 에서 `a`의 카피를 만들지 않는다.\n  - 그러나, `for i, v := range a` 에서는 `a`의 카피를 만든다 (즉, 이와 같은 경우, for문 내에서 `v`의 수정은 `a`와 무관)\n  - 코드: https://play.golang.org/p/4b181zkB1관\n- [ ] 존재하지 않는 key값을 map으로 부터 읽으려고 할 때, panic은 일어나지 않는다.\n  - `value := map[\"no_key\"]` 는 제로 값(zero value)가 된다.\n  - `value, ok := map[\"no_key\"]` 가 훨씬 더 낫다.\n- [ ] file operation에 raw 파라미터를 사용하지 말 것\n  - 다음과 같은 8진수 파라미터(octal parameter) 대신에: `os.MkdirAll(root, 0700)`\n  - 사전정의된 상수 타입을 사용 할 것: `os.FileMode`\n- [ ] `iota`에 대한 타입을 특정지을(specify) 것을 잊지 말 것\n  - https://play.golang.org/p/mZZdMaI92cI\n\n```go\n  const (\n    _ = iota\n    testvar         // will be int\n  )\n```\n\n  vs\n\n```go\n  type myType int\n  const (\n    _ myType = iota\n    testvar         // will be myType\n  )\n```\n\n#### Don’t use `encoding/gob` on structs you don’t own.\n\n어느 순간에 있어서 구조체(structure)는 변경될 수 있으며, 여러분들은 이를 놓칠 수 있다. 결론적으로, 이러한 것은 버그를 찾기 어렵게 한다.\n\n#### Don't depend on the evaluation order, especially in a return statement.\n\n```go\n// BAD\nreturn res, json.Unmarshal(b, &res)\n\n// GOOD\nerr := json.Unmarshal(b, &res)\nreturn res, err\n```\n\n#### To prevent structs comparison add an empty field of `func` type\n\n```go\ntype Point struct {\n\t_ [0]func()\t// unexported, zero-width non-comparable field\n\tX, Y float64\n}\n```\n\n#### Prefer `http.HandlerFunc` over `http.Handler`\n\n`http.HandlerFunc` 사용하기 위해서 단지 하나의 함수만 필요로 하지만, `http.Handler`를 위해서는 타입이 필요하다.\n\n#### Move `defer` to the top\n\n이는 코드의 가독성(readability)를 향상시켜 주고 어떠한 것이 함수의 종료점(at the end of a function)에 작동할 지(invoked) 명확하게 해 준다.\n\n#### JavaScript parses integers as floats and your int64 might overflow.\n\n대신에 `json:\"id,string\"` 를 사용할 것.\n\n```go\ntype Request struct {\n\tID int64 `json:\"id,string\"`\n}\n```\n\n### Concurrency\n\n- [ ] 쓰레드 안정적인 방법(a thread-safe way)으로 한번에 무언가를 만드는 최적의 방법은 `sync.Once` 이다.\n  - 플래그(flags), 뮤텍스(mutexes), 채널(channels) 혹은 아토믹(atomics)를 사용하지 말 것.\n- [ ] 영원이 지속되는 것을 막기 위해서, `select{}`를 사용하고, 채널을 제거하고, 시그널을 기다릴 것. (to block forever use `select{}`, omit channels, waiting for a signal)\n- [ ] 채널 내부에서 종료하지 말자(don't close in-channel), 이는 채널의 생성자가 할 일이다(this is a responsibility of it's creator).\n  - 닫혀진 채널에 무언가를 작성하는 것은 패닉을 야기한다.\n- [ ] `math/rand`내의 `func NewSource(seed int64) Source`는 동시성-안정적이지 않음(not concurrency-safe). 디폴트의 `lockedSource`가 동시성 안정적(concurrency-safe)이다, 다음의 이슈를 참고해라: https://github.com/golang/go/issues/3611\n  - 추가정보: https://golang.org/pkg/math/rand/\n- [ ] 커스텀 타입의 아토믹 값(atomic value)가 필요 할 경우, [atomic.Value](https://godoc.org/sync/atomic#Value)을 사용할 것\n\n### Performance\n\n- [ ] `defer`를 생략하지 말 것\n  - 200ns의 속도향상은 대부분의 경우 무시(negligible)해도 좋다.\n- [ ] 항상 http의 body를 `defer r.Body.Close()`로 닫을 것\n  - 여러분이 누수된 고루틴(leaked goroutine)이 필요하지 않는 한...\n- [ ] allocating 없는 filtering\n\n```go\n    b := a[:0]\n    for _, x := range a {\n    \tif f(x) {\n\t\t    b = append(b, x)\n    \t}\n    }\n```\n\n#### To help compiler to remove bound checks see this pattern `_ = b[7]`\n\n- [ ] `time.Time`는 포인터 필드인 `time.Location`를 가지며, 이는 Go의 가비지컬렉터(GC)에 좋지 못함(bad)\n  - 이는 `time.Time`의 큰 수에만 유의미하고(relevant), 이외에는 대신 timestamp를 사용할 것.\n- [ ] `regexp.Compile` 대신, `regexp.MustCompile`을 선호한다.\n  - 거의 모든 케이스에서 정규표현식(regex)은 변경할 수 없으므로, `func init`에서 초기화 해라.\n- [ ] Hot path에서 `fmt.Sprintf`를 과하게 사용하지 말것. 인터페이스에 대한 버퍼 풀(Buffer Pool) 및 동적 디스패치(dynamic dispatches)를 유지보수하는 비용이 많이 든다.\n  - 만약 `fmt.Sprintf(\"%s%s\", var1, var2)`과 같은 것을 한다면, 간단한 문자열 연결(string concatenation)을 고려 할 것.\n  - 만약 `fmt.Sprintf(\"%x\", var)`과 같은 것을 한다면, `hex.EncodeToString` 혹은 `strconv.FormatInt(var, 16)`사용할 것을 고려할 것\n- [ ] `io.Copy(ioutil.Discard, resp.Body)` 와 같이, 이를 사용하지 않는다면, 항상 body를 삭제(discard)할 것\n  - Body가 종료를 위해서 읽혀지거나 닫히지 않는 한, HTTP client의 Transport는 connections을 재사용하지 않을 것이다.\n\n```go\n    res, _ := client.Do(req)\n    io.Copy(ioutil.Discard, res.Body)\n    defer res.Body.Close()\n```\n\n- [ ] 루프 내에서 defer를 사용하지 말자. 그렇지 않으면 약간의의메모리 누수(small memory leak)가 발생할 수 있다.\n  - 왜냐하면 defers는 특별한 이유 없이 스택(stack)을 증가(grow)시키기 때문이다.\n- [ ] 누수된 채널(leaked channel)이 필요하지 않는 한, ticker를 중지(stop)할 것을 잊지 말자.\n\n```go\n  ticker := time.NewTicker(1 * time.Second)\n  defer ticker.Stop()\n```\n\n- [ ] 사용자 지정 마샬러(custom marshaler)를 사용하여 마샬링(marshaling)속도를 올려라.\n  - 그러나 그것을 사용하기 전, 프로파일 해라! 예: https://play.golang.org/p/SEm9Hvsi0r\n\n```go\n  func (entry Entry) MarshalJSON() ([]byte, error) {\n\tbuffer := bytes.NewBufferString(\"{\")\n\tfirst := true\n\tfor key, value := range entry {\n\t\tjsonValue, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !first {\n\t\t\tbuffer.WriteString(\",\")\n\t\t}\n\t\tfirst = false\n\t\tbuffer.WriteString(key + \":\" + string(jsonValue))\n\t}\n\tbuffer.WriteString(\"}\")\n\treturn buffer.Bytes(), nil\n  }\n```\n\n- [ ] `sync.Map`은 만병통치약(silver bullet)이 아니므로, 강력한 이유가 없다면 사용하지 말 것.\n  - 참고: https://github.com/golang/go/blob/master/src/sync/map.go#L12\n- [ ] non-pointer값을 `sync.Pool`에 저장(storing)하면, 메모리가 할당된다.\n  - 참고: https://github.com/dominikh/go-tools/blob/master/cmd/staticcheck/docs/checks/SA6002\n\n- [ ] 탈출 분석(escape analysis)로부터 포인터를 숨기기 위해서, 여러분들은 \"신중하게(carefully!!!)\" 이 함수를 사용할 수 있다:\n  - 출처: https://go-review.googlesource.com/c/go/+/86976\n\n```go\n  // noescape hides a pointer from escape analysis.  noescape is\n  // the identity function but escape analysis doesn't think the\n  // output depends on the input. noescape is inlined and currently\n  // compiles down to zero instructions.\n  func noescape(p unsafe.Pointer) unsafe.Pointer {\n  \tx := uintptr(p)\n  \treturn unsafe.Pointer(x ^ 0)\n  }\n```\n\n- [ ] 가장 빠른 atomic swap을 위해서 아래를 사용할 수 있다:\n  `m := (*map[int]int)(atomic.LoadPointer(&ptr))`\n- [ ] 다수의 순차적 읽기 또는 쓰기(sequential reads or writes)를 수행 할 경우 buffered I/O를 사용.\n  - syscalls의 수를 감소하기 위해서\n- [ ] 맵(map)을 클리어(clear)하는 2가지 방법이 있다:\n  - 맵 메모리 재사용(reuse map memory)\n\n```go\n\tfor k := range m {\n\t\tdelete(m, k)\n\t}\n```\n\n  - 새로운 할당(allocate new)\n\n```go\n\tm = make(map[int]int)\n```\n\n### Modules\n\n- [ ] CI에서 `go.mod` (및 `go.sum`)가 최신(Up to date)인지 테스트하려면:\n  https://blog.urth.org/2019/08/13/testing-go-mod-tidiness-in-ci/\n\n### Build\n\n- [ ] 이 명령으로 바이너리(binaries)를 제거(strip)해라: `go build -ldflags=\"-s -w\" ...`\n- [ ] 테스트를 다른 빌드로 나누는 쉬운 방법\n  - `// +build integration`를 사용하고, 이를 `go test -v --tags integration .`과 함께 실행(run)하라\n- [ ] 가장 작은 Go Docker image\n  - https://twitter.com/bbrodriges/status/873414658178396160\n  - `CGO_ENABLED=0 go build -ldflags=\"-s -w\" app.go && tar C app | docker import - myimage:latest`\n- [ ] CI상에서 `go format`을 실행하고, diff을 비교할 것\n  - 이로 인해 모든것이 생성되고 커밋되는 것을 확인한다(ensure).\n- [ ] 최신의 Go와 함께 Travis-CI를 실행하기 위해서 `travis 1`을 사용할 것\n  - 추가 정보: https://github.com/travis-ci/travis-build/blob/master/public/version-aliases/go.json\n- [ ] 코드 포멧팅(code formatting)상 실수가 있는지 체크 할 것 `diff -u <(echo -n) <(gofmt -d .)`\n\n### Testing\n\n- [ ] 테스트에서 `package`보다 `package_test`의 패키지 이름을 선호한다.\n- [ ] `go test -short`는 테스트의 집합(set of tests)이 재실행(rerun)되는 것을 줄여준다.\n\n```go\n  func TestSomething(t *testing.T) {\n    if testing.Short() {\n      t.Skip(\"skipping test in short mode.\")\n    }\n  }\n```\n\n- [ ] 아키텍쳐에 따라 테스트를 건너 뛸 것\n\n```go\n  if runtime.GOARM == \"arm\" {\n    t.Skip(\"this doesn't work under ARM\")\n  }\n```\n\n- [ ] `testing.AllocsPerRun`를 통해서 할당(allocations)을 추적(track)할 것.\n  - https://godoc.org/testing#AllocsPerRun\n- [ ] 노이즈를 줄이기 위해, 벤치마크(benchmarks)를 여러번 수행할 것.\n  - `go test -test.bench=. -count=20`\n\n### Tools\n\n- [ ] 빠른 대체: `gofmt -w -l -r \"panic(err) -> log.Error(err)\" .`\n- [ ] `go list`는 직접적이고 전이적인(direct and transitive) 모든 의존성(dependencies)를 찾을 수 있다.\n  - `go list -f '{{ .Imports }}' package`\n  - `go list -f '{{ .Deps }}' package`\n- [ ] 빠른 벤치마크 비교를 위해서, `benchstat` 툴(tool) 사용\n  - https://godoc.org/golang.org/x/perf/cmd/benchstat\n- [ ] [go-critic](https://github.com/go-critic/go-critic) 린터(linter)는 이 문서로부터 몇 가지 조언(several advice)를 수행한다.\n- [ ] `go mod why -m <module>`는 `go.mod` 파일에 왜 특정 모듈이 있는지 말해준다.\n- [ ] `GOGC=off go build ...`는 여러분들의 빌드(builds)의 속도를 높여준다. [source](https://twitter.com/mvdan_/status/1107579946501853191)\n- [ ] 메모리 프로파일러는 매 512KB당 하나의 할당을 기록한다. Profile에서 세부사항을 보기 위해서 `GODEBUG`의 환경 변수를 통해서 이 비율(rate)를 높일 수 있다.\n  - by https://twitter.com/bboreham/status/1105036740253937664\n\n### Misc\n\n- [ ] 고루틴을 버려랴(dump goroutines) https://stackoverflow.com/a/27398062/433041\n\n```go\n  go func() {\n    sigs := make(chan os.Signal, 1)\n    signal.Notify(sigs, syscall.SIGQUIT)\n    buf := make([]byte, 1<<20)\n    for {\n      <-sigs\n      stacklen := runtime.Stack(buf, true)\n      log.Printf(\"=== received SIGQUIT ===\\n*** goroutine dump...\\n%s\\n*** end\\n\", buf[:stacklen])\n    }\n  }()\n```\n\n- [ ] 컴파일 중 인터페이스 구현을 확인할 것\n\n  ```go\n  var _ io.Reader = (*MyFastReader)(nil)\n  ```\n\n- [ ] 만약 len의 매개변수(param)이 `nil`일 경우, 이는 \"zero\"다.\n  - https://golang.org/pkg/builtin/#len\n- [ ] 익명 구조체(anonymous structs)는 멋지다(cool)\n\n```go\n  var hits struct {\n    sync.Mutex\n    n int\n  }\n  hits.Lock()\n  hits.n++\n  hits.Unlock()\n```\n\n- [ ] `httputil.DumpRequest`는 상당히 유용하다, 그러므로 여러분들의 별도의 것을 만들지 말 것.\n  - https://godoc.org/net/http/httputil#DumpRequest\n- [ ] 스택을 얻기 위해서 `runtime.Caller`가 있다 https://golang.org/pkg/runtime/#Caller\n- [ ] 임의의 JSON(arbitrary JSON)을 마샬링(to marshal)하기 위해, `map[string]interface{}{}`로 먀샬링(marshal)할 수 있다.\n- [ ] `CDPATH`를 구성하면, 모든 director로부터 `cd github.com/golang/go`을 할 수 있다.\n  - 이 라인을 여러분들의 `bashrc`(or analogue)에 추가하라: `export CDPATH=$CDPATH:$GOPATH/src`\n- [ ] 하나의 슬라이스로부터의 간단한 임의 원소(simple random element)\n  - `[]string{\"one\", \"two\", \"three\"}[rand.Intn(3)]`\n"
        },
        {
          "name": "README_ZH.md",
          "type": "blob",
          "size": 16.86328125,
          "content": "<!-- START doctoc generated TOC please keep comment here to allow auto update -->\n<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->\n**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*\n\n- [Go-advice 中文版本](#go-advice-%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC)\n    - [Go 箴言](#go-%E7%AE%B4%E8%A8%80)\n    - [Go 之禅](#go-%E4%B9%8B%E7%A6%85)\n    - [代码](#%E4%BB%A3%E7%A0%81)\n    - [并发](#%E5%B9%B6%E5%8F%91)\n    - [性能](#%E6%80%A7%E8%83%BD)\n    - [模块](#%E6%A8%A1%E5%9D%97)\n    - [构建](#%E6%9E%84%E5%BB%BA)\n    - [测试](#%E6%B5%8B%E8%AF%95)\n    - [工具](#%E5%B7%A5%E5%85%B7)\n    - [Misc](#misc)\n\n<!-- END doctoc generated TOC please keep comment here to allow auto update -->\n\n# Go-advice 中文版本 #\n\n### Go 箴言\n\n- 不要通过共享内存进行通信，通过通信共享内存\n- 并发不是并行\n- 管道用于协调；互斥量（锁）用于同步\n- 接口越大，抽象就越弱\n- 利用好零值\n- 空接口 `interface{}` 没有任何类型约束\n- Gofmt 的风格不是人们最喜欢的，但 gofmt 是每个人的最爱\n- 允许一点点重复比引入一点点依赖更好\n- 系统调用必须始终使用构建标记进行保护\n- 必须始终使用构建标记保护 Cgo\n- Cgo 不是 Go\n- 使用标准库的 `unsafe` 包，不能保证能如期运行\n- 清晰比聪明更好\n- 反射永远不清晰\n- 错误是值\n- 不要只检查错误，还要优雅地处理它们\n- 设计架构，命名组件，（文档）记录细节\n- 文档是供用户使用的\n- 不要（在生产环境）使用 `panic()`\n\nAuthor: Rob Pike\nSee more: https://go-proverbs.github.io/\n\n### Go 之禅\n\n- 每个 package 实现单一的目的\n- 显式处理错误\n- 尽早返回，而不是使用深嵌套\n- 让调用者处理并发（带来的问题）\n- 在启动一个 goroutine 时，需要知道何时它会停止\n- 避免 package 级别的状态\n- 简单很重要\n- 编写测试以锁定 package API 的行为\n- 如果你觉得慢，先编写 benchmark 来证明\n- 适度是一种美德\n- 可维护性\n\nAuthor: Dave Cheney\nSee more: https://the-zen-of-go.netlify.com/\n\n### 代码 ###\n\n#### 使用 `go fmt` 格式化\n\n让团队一起使用官方的 Go 格式工具，不要重新发明轮子。\n尝试减少代码复杂度。 这将帮助所有人使代码易于阅读。\n\n#### 多个 if 语句可以折叠成 switch\n\n```go\n// NOT BAD\nif foo() {\n    // ...\n} else if bar == baz {\n    // ...\n} else {\n    // ...\n}\n\n// BETTER\nswitch {\ncase foo():\n    // ...\ncase bar == baz:\n    // ...\ndefault:\n    // ...\n}\n```\n\n#### 用 `chan struct{}` 来传递信号, `chan bool` 表达的不够清楚\n\n当你在结构中看到 `chan bool` 的定义时，有时不容易理解如何使用该值，例如：\n\n```go\ntype Service struct {\n    deleteCh chan bool // what does this bool mean? \n}\n```\n\n但是我们可以将其改为明确的 `chan struct {}` 来使其更清楚：我们不在乎值（它始终是 `struct {}`），我们关心可能发生的事件，例如：\n\n```go\ntype Service struct {\n    deleteCh chan struct{} // ok, if event than delete something.\n}\n```\n\n#### `30 * time.Second` 比 `time.Duration(30) * time.Second` 更好\n\n你不需要将无类型的常量包装成类型，编译器会找出来。  \n另外最好将常量移到第一位：\n\n```go\n// BAD\ndelay := time.Second * 60 * 24 * 60\n\n// VERY BAD\ndelay := 60 * time.Second * 60 * 24\n\n// GOOD\ndelay := 24 * 60 * 60 * time.Second\n```\n\n#### 用 `time.Duration` 代替 `int64` + 变量名\n\n```go\n// BAD\nvar delayMillis int64 = 15000\n\n// GOOD\nvar delay time.Duration = 15 * time.Second\n```\n\n#### 按类型分组 `const` 声明，按逻辑和/或类型分组 `var`\n\n```go\n// BAD\nconst (\n    foo = 1\n    bar = 2\n    message = \"warn message\"\n)\n\n// MOSTLY BAD\nconst foo = 1\nconst bar = 2\nconst message = \"warn message\"\n\n// GOOD\nconst (\n    foo = 1\n    bar = 2\n)\n\nconst message = \"warn message\"\n```\n\n这个模式也适用于 `var`。\n\n- [ ] 每个阻塞或者 IO 函数操作应该是可取消的或者至少是可超时的\n- [ ] 为整型常量值实现 `Stringer` 接口\n    - https://godoc.org/golang.org/x/tools/cmd/stringer\n- [ ] 检查 `defer` 中的错误\n\n```go\n  defer func() {\n      err := ocp.Close()\n      if err != nil {\n          rerr = err\n      }\n  }()\n```\n\n- [ ] 不要在 `checkErr` 函数中使用 `panic()` 或 `os.Exit()`\n- [ ] 仅仅在很特殊情况下才使用 panic, 你必须要去处理 error\n- [ ] 不要给枚举使用别名，因为这打破了类型安全\n    - https://play.golang.org/p/MGbeDwtXN3\n\n```go\n  package main\n  type Status = int\n  type Format = int // remove `=` to have type safety\n  \n  const A Status = 1\n  const B Format = 1\n  \n  func main() {\n      println(A == B)\n  }\n```\n\n- [ ] 如果你想省略返回参数，你最好表示出来\n    - ` _ = f()` 比 `f()` 更好\n\n- [ ] 我们用 `a := []T{}` 来简单初始化 slice\n- [ ] 用 range 循环来进行数组或 slice 的迭代\n    -  `for _, c := range a[3:7] {...}` 比 `for i := 3; i < 7; i++ {...}` 更好\n- [ ] 多行字符串用反引号(\\`)\n- [ ] 用 `_` 来跳过不用的参数\n\n```go\n  func f(a int, _ string) {}\n```\n\n- [ ] 如果你要比较时间戳，请使用 `time.Before` 或 `time.After` ，不要使用 `time.Sub` 来获得 duration (持续时间)，然后检查它的值。\n- [ ] 带有上下文的函数第一个参数名为 `ctx`，形如：`func foo(ctx Context, ...)`\n- [ ] 几个相同类型的参数定义可以用简短的方式来进行\n\n```go\n  func f(a int, b int, s string, p string)\n```\n\n```go\n  func f(a, b int, s, p string)\n```\n\n- [ ] 一个 slice 的零值是 nil\n    - https://play.golang.org/p/pNT0d_Bunq\n```go\n  var s []int\n  fmt.Println(s, len(s), cap(s))\n  if s == nil {\n    fmt.Println(\"nil!\")\n  }\n  // Output:\n  // [] 0 0\n  // nil!\n```\n  - https://play.golang.org/p/meTInNyxtk\n\n```go\n  var a []string\n  b := []string{}\n\n  fmt.Println(reflect.DeepEqual(a, []string{}))\n  fmt.Println(reflect.DeepEqual(b, []string{}))\n  // Output:\n  // false\n  // true\n```\n\n- [ ] 不要将枚举类型与 `<`, `>`, `<=` 和 `>=` 进行比较\n    - 使用确定的值，不要像下面这样做:\n\n```go\n  value := reflect.ValueOf(object)\n  kind := value.Kind()\n  if kind >= reflect.Chan && kind <= reflect.Slice {\n    // ...\n  }\n```\n- [ ] 用 `%+v` 来打印数据的比较全的信息\n- [ ] 注意空结构 `struct{}`, 看 issue: https://github.com/golang/go/issues/23440\n    - more: https://play.golang.org/p/9C0puRUstrP\n\n```go\n  func f1() {\n    var a, b struct{}\n    print(&a, \"\\n\", &b, \"\\n\") // Prints same address\n    fmt.Println(&a == &b)     // Comparison returns false\n  }\n      \n  func f2() {\n    var a, b struct{}\n    fmt.Printf(\"%p\\n%p\\n\", &a, &b) // Again, same address\n    fmt.Println(&a == &b)          // ...but the comparison returns true\n  }\n```\n\n- [ ] 包装错误： http://github.com/pkg/errors\n    - 例如: `errors.Wrap(err, \"additional message to a given error\")`\n\n- [ ] 在 Go 里面要小心使用 `range`:\n\n    - `for i := range a` and `for i, v := range &a` ，都不是 `a` 的副本\n    - 但是 `for i, v := range a` 里面的就是 `a` 的副本\n    - 更多: https://play.golang.org/p/4b181zkB1O\n\n- [ ] 从 map 读取一个不存在的 key 将不会 panic\n  \n    - `value := map[\"no_key\"]` 将得到一个 0 值\n    - `value, ok := map[\"no_key\"]` 更好\n\n- [ ] 不要使用原始参数进行文件操作\n  \n    - 而不是一个八进制参数 `os.MkdirAll(root, 0700)`\n    - 使用此类型的预定义常量 `os.FileMode`\n\n- [ ] 不要忘记为 `iota` 指定一种类型\n    - https://play.golang.org/p/mZZdMaI92cI\n\n```go\n    const (\n      _ = iota\n      testvar         // testvar 将是 int 类型\n    )\n```\n\nvs\n\n```go\n    type myType int\n    const (\n      _ myType = iota\n      testvar         // testvar 将是 myType 类型\n    )\n```\n\n#### 不要在你不拥有的结构上使用 `encoding/gob`\n\n在某些时候，结构可能会改变，而你可能会错过这一点。因此，这可能会导致很难找到 bug。\n\n#### 不要依赖于计算顺序，特别是在 return 语句中。\n\n```go\n  // BAD\n  return res, json.Unmarshal(b, &res)\n\n  // GOOD\n  err := json.Unmarshal(b, &res)\n  return res, err\n```\n\n#### 防止结构体字段用纯值方式初始化，添加 `_ struct {}` 字段：\n\n```go\ntype Point struct {\n  X, Y float64\n  _    struct{} // to prevent unkeyed literals\n}\n```\n\n对于 `Point {X：1，Y：1}` 都可以，但是对于 `Point {1,1}` 则会出现编译错误：\n\n```\n./file.go:1:11: too few values in Point literal\n```\n\n当在你所有的结构体中添加了 `_ struct{}` 后，使用 `go vet` 命令进行检查，（原来声明的方式）就会提示没有足够的参数。\n\n#### 为了防止结构比较，添加 `func` 类型的空字段\n\n```go\n  type Point struct {\n    _ [0]func() // unexported, zero-width non-comparable field\n    X, Y float64\n  }\n```\n\n#### `http.HandlerFunc` 比 `http.Handler` 更好\n\n用 `http.HandlerFunc` 你仅需要一个 func，`http.Handler` 需要一个类型。\n\n#### 移动 `defer` 到顶部\n\n这可以提高代码可读性并明确函数结束时调用了什么。\n\n#### JavaScript 解析整数为浮点数并且你的 int64 可能溢出\n\n用 `json:\"id,string\"` 代替\n\n```go\ntype Request struct {\n  ID int64 `json:\"id,string\"`\n}\n```\n\n### 并发 ###\n- [ ] 以线程安全的方式创建单例（只创建一次）的最好选择是 `sync.Once`\n    - 不要用 flags, mutexes, channels or atomics\n- [ ] 永远不要使用 `select{}`, 省略通道， 等待信号\n- [ ] 不要关闭一个发送（写入）管道，应该由创建者关闭\n    - 往一个关闭的 channel 写数据会引起 panic\n- [ ] `math/rand` 中的 `func NewSource(seed int64) Source` 不是并发安全的，默认的 `lockedSource` 是并发安全的, see issue: https://github.com/golang/go/issues/3611\n    - 更多: https://golang.org/pkg/math/rand/\n- [ ] 当你需要一个自定义类型的 atomic 值时，可以使用 [atomic.Value](https://godoc.org/sync/atomic#Value)\n\n### 性能 ###\n- [ ] 不要省略 `defer`\n    - 在大多数情况下 200ns 加速可以忽略不计\n- [ ] 总是关闭 http body `defer r.Body.Close()`\n    - 除非你需要泄露 goroutine\n- [ ] 过滤但不分配新内存\n\n```go\n  b := a[:0]\n  for _, x := range a {\n  \tif f(x) {\n\t    b = append(b, x)\n  \t}\n  }\n```\n\n#### 为了帮助编译器删除绑定检查，请参见此模式 `_ = b [7]`\n\n- [ ] `time.Time` 有指针字段 `time.Location` 并且这对 go GC 不好\n    - 只有使用了大量的 `time.Time` 才（对性能）有意义，否则用 timestamp 代替\n- [ ] `regexp.MustCompile` 比 `regexp.Compile` 更好\n    - 在大多数情况下，你的正则表达式是不可变的，所以你最好在 `func init` 中初始化它\n- [ ] 请勿在你的热点代码中过度使用 `fmt.Sprintf`. 由于维护接口的缓冲池和动态调度，它是很昂贵的。\n    - 如果你正在使用 `fmt.Sprintf(\"%s%s\", var1, var2)`, 考虑使用简单的字符串连接。\n    - 如果你正在使用 `fmt.Sprintf(\"%x\", var)`, 考虑使用 `hex.EncodeToString` or `strconv.FormatInt(var, 16)`\n- [ ] 如果你不需要用它，可以考虑丢弃它，例如`io.Copy(ioutil.Discard, resp.Body)`\n    - HTTP 客户端的传输不会重用连接，直到body被读完和关闭。\n\n```go\n  res, _ := client.Do(req)\n  io.Copy(ioutil.Discard, res.Body)\n  defer res.Body.Close()\n```\n\n- [ ] 不要在循环中使用 defer，否则会导致内存泄露\n    - 因为这些 defer 会不断地填满你的栈（内存）\n- [ ] 不要忘记停止 ticker, 除非你需要泄露 channel\n  \n```go\n  ticker := time.NewTicker(1 * time.Second)\n  defer ticker.Stop()\n```\n\n- [ ] 用自定义的 marshaler 去加速 marshaler 过程\n    - 但是在使用它之前要进行定制！例如：https://play.golang.org/p/SEm9Hvsi0r\n\n```go\n  func (entry Entry) MarshalJSON() ([]byte, error) {\n\tbuffer := bytes.NewBufferString(\"{\")\n\tfirst := true\n\tfor key, value := range entry {\n\t\tjsonValue, err := json.Marshal(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif !first {\n\t\t\tbuffer.WriteString(\",\")\n\t\t}\n\t\tfirst = false\n\t\tbuffer.WriteString(key + \":\" + string(jsonValue))\n\t}\n\tbuffer.WriteString(\"}\")\n\treturn buffer.Bytes(), nil\n  }\n```\n\n- [ ] `sync.Map` 不是万能的，没有很强的理由就不要使用它。\n    - 了解更多: https://github.com/golang/go/blob/master/src/sync/map.go#L12\n- [ ] 在 `sync.Pool` 中分配内存存储非指针数据\n    - 了解更多: https://github.com/dominikh/go-tools/blob/master/cmd/staticcheck/docs/checks/SA6002\n\n- [ ] 为了隐藏逃生分析的指针，你可以小心使用这个函数：:\n    - 来源: https://go-review.googlesource.com/c/go/+/86976\n\n```go\n  // noescape hides a pointer from escape analysis.  noescape is\n  // the identity function but escape analysis doesn't think the\n  // output depends on the input. noescape is inlined and currently\n  // compiles down to zero instructions.\n  //go:nosplit\n  func noescape(p unsafe.Pointer) unsafe.Pointer {\n    x := uintptr(p)\n    return unsafe.Pointer(x ^ 0)\n  }\n```\n\n- [ ] 对于最快的原子交换，你可以使用这个 `m := (*map[int]int)(atomic.LoadPointer(&ptr))`\n- [ ] 如果执行许多顺序读取或写入操作，请使用缓冲 I/O\n\n   - 减少系统调用次数\n\n- [ ] 有 2 种方法清空一个 map：\n\n  - 重用 map 内存 （但是也要注意 m 的回收）\n\n```go\n  for k := range m {\n    delete(m, k)\n  }\n```\n\n  - 分配新的\n\n```go\n  m = make(map[int]int)\n```\n\n### 模块\n\n- [ ] 如果你想在 CI 中测试 `go.mod` （和 `go.sum`）是否是最新 https://blog.urth.org/2019/08/13/testing-go-mod-tidiness-in-ci/\n\n### 构建 ###\n\n- [ ] 用这个命令 `go build -ldflags=\"-s -w\" ...` 去掉你的二进制文件\n- [ ] 拆分构建不同版本的简单方法\n    - 用 `// +build integration` 并且运行他们 `go test -v --tags integration .`\n- [ ] 最小的 Go Docker 镜像\n    - https://twitter.com/bbrodriges/status/873414658178396160\n    - `CGO_ENABLED=0 go build -ldflags=\"-s -w\" app.go && tar C app | docker import - myimage:latest`\n- [ ] run go format on CI and compare diff\n    - 这将确保一切都是生成的和承诺的\n- [ ] 用最新的 Go 运行 Travis-CI，用 `travis 1`\n    - 了解更多：https://github.com/travis-ci/travis-build/blob/master/public/version-aliases/go.json\n- [ ] 检查代码格式是否有错误 `diff -u <(echo -n) <(gofmt -d .)`\n\n### 测试 ###\n\n- [ ] 测试名称 `package_test` 比 `package` 要好\n- [ ] `go test -short` 允许减少要运行的测试数\n\n```go\n  func TestSomething(t *testing.T) {\n    if testing.Short() {\n      t.Skip(\"skipping test in short mode.\")\n    }\n  }\n```\n\n- [ ] 根据系统架构跳过测试\n\n```go\n  if runtime.GOARM == \"arm\" {\n    t.Skip(\"this doesn't work under ARM\")\n  }\n```\n\n- [ ] 用 `testing.AllocsPerRun` 跟踪你的内存分配\n    - https://godoc.org/testing#AllocsPerRun\n- [ ] 多次运行你的基准测试可以避免噪音。\n    - `go test -test.bench=. -count=20`\n\n### 工具 ###\n\n- [ ] 快速替换 `gofmt -w -l -r \"panic(err) -> log.Error(err)\" .`\n- [ ] `go list` 允许找到所有直接和传递的依赖关系\n    - `go list -f '{{ .Imports }}' package`\n    - `go list -f '{{ .Deps }}' package`\n- [ ] 对于快速基准比较，我们有一个 `benchstat` 工具。\n    - https://godoc.org/golang.org/x/perf/cmd/benchstat\n- [ ] [go-critic](https://github.com/go-critic/go-critic) linter 从这个文件中强制执行几条建议\n- [ ] `go mod why -m <module>` 告诉我们为什么特定的模块在 `go.mod` 文件中。\n- [ ] `GOGC=off go build ...` 应该会加快构建速度 [source](https://twitter.com/mvdan_/status/1107579946501853191)\n- [ ] 内存分析器每 512KB 记录一次分配。你能通过 `GODEBUG` 环境变量增加比例，来查看你的文件的更多详细信息。\n  - 来源：https://twitter.com/bboreham/status/1105036740253937664\n\n- [ ] `go mod why -m <module>` 告诉我们为什么特定的模块是在 `go.mod` 文件中。\n\n### 其他 ###\n\n- [ ] dump goroutines https://stackoverflow.com/a/27398062/433041\n\n```go\n  go func() {\n    sigs := make(chan os.Signal, 1)\n    signal.Notify(sigs, syscall.SIGQUIT)\n    buf := make([]byte, 1<<20)\n    for {\n      <-sigs\n      stacklen := runtime.Stack(buf, true)\n      log.Printf(\"=== received SIGQUIT ===\\n*** goroutine dump...\\n%s\\n*** end\\n\"  , buf[:stacklen])\n    }\n  }()\n```\n\n- [ ] 在编译期检查接口的实现\n  ```go\n    var _ io.Reader = (*MyFastReader)(nil)\n  ```\n- [ ] len(nil) = 0\n    - https://golang.org/pkg/builtin/#len\n- [ ] 匿名结构很酷\n\n```go\n  var hits struct {\n    sync.Mutex\n    n int\n  }\n  hits.Lock()\n  hits.n++\n  hits.Unlock()\n```\n\n- [ ] `httputil.DumpRequest` 是非常有用的东西，不要自己创建\n    - https://godoc.org/net/http/httputil#DumpRequest\n- [ ] 获得调用堆栈，我们可以使用 `runtime.Caller`\n    - https://golang.org/pkg/runtime/#Caller\n- [ ] 要 marshal 任意的 JSON， 你可以 marshal 为 `map[string]interface{}{}`\n- [ ] 配置你的 `CDPATH` 以便你能在任何目录执行 `cd github.com/golang/go`\n    - 添加这一行代码到 `bashrc`(或者其他类似的) `export CDPATH=$CDPATH:$GOPATH/src`\n\n- [ ] 从一个 slice 生成简单的随机元素\n    - `[]string{\"one\", \"two\", \"three\"}[rand.Intn(3)]`\n"
        },
        {
          "name": "hello.go",
          "type": "blob",
          "size": 0.068359375,
          "content": "package main\n\nfunc main() {\n\tprintln(`Hello, world \\ʕ◔ϖ◔ʔ/`)\n}\n"
        }
      ]
    }
  ]
}