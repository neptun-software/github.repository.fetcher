{
  "metadata": {
    "timestamp": 1736566474568,
    "page": 22,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "satori/go.uuid",
      "stars": 4897,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.3623046875,
          "content": "language: go\nsudo: false\ngo:\n    - 1.6.x\n    - 1.7.x\n    - 1.8.x\n    - 1.9.x\n    - 1.10.x\n    - 1.11.x\n    - tip\nmatrix:\n    allow_failures:\n        - go: tip\n    fast_finish: true\nbefore_install:\n    - go get github.com/mattn/goveralls\n    - go get golang.org/x/tools/cmd/cover\nscript:\n    - $HOME/gopath/bin/goveralls -service=travis-ci\nnotifications:\n    email: false\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.056640625,
          "content": "Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.0361328125,
          "content": "# UUID package for Go language\n\n[![Build Status](https://travis-ci.org/satori/go.uuid.svg?branch=master)](https://travis-ci.org/satori/go.uuid)\n[![Coverage Status](https://coveralls.io/repos/github/satori/go.uuid/badge.svg?branch=master)](https://coveralls.io/github/satori/go.uuid)\n[![GoDoc](http://godoc.org/github.com/satori/go.uuid?status.svg)](http://godoc.org/github.com/satori/go.uuid)\n\nThis package provides pure Go implementation of Universally Unique Identifier (UUID). Supported both creation and parsing of UUIDs.\n\nWith 100% test coverage and benchmarks out of box.\n\nSupported versions:\n* Version 1, based on timestamp and MAC address (RFC 4122)\n* Version 2, based on timestamp, MAC address and POSIX UID/GID (DCE 1.1)\n* Version 3, based on MD5 hashing (RFC 4122)\n* Version 4, based on random numbers (RFC 4122)\n* Version 5, based on SHA-1 hashing (RFC 4122)\n\n## Installation\n\nUse the `go` command:\n\n\t$ go get github.com/satori/go.uuid\n\n## Requirements\n\nUUID package tested against Go >= 1.6.\n\n## Example\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"github.com/satori/go.uuid\"\n)\n\nfunc main() {\n\t// Creating UUID Version 4\n\t// panic on error\n\tu1 := uuid.Must(uuid.NewV4())\n\tfmt.Printf(\"UUIDv4: %s\\n\", u1)\n\n\t// or error handling\n\tu2, err := uuid.NewV4()\n\tif err != nil {\n\t\tfmt.Printf(\"Something went wrong: %s\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"UUIDv4: %s\\n\", u2)\n\n\t// Parsing UUID from string input\n\tu2, err := uuid.FromString(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\tif err != nil {\n\t\tfmt.Printf(\"Something went wrong: %s\", err)\n\t\treturn\n\t}\n\tfmt.Printf(\"Successfully parsed: %s\", u2)\n}\n```\n\n## Documentation\n\n[Documentation](http://godoc.org/github.com/satori/go.uuid) is hosted at GoDoc project.\n\n## Links\n* [RFC 4122](http://tools.ietf.org/html/rfc4122)\n* [DCE 1.1: Authentication and Security Services](http://pubs.opengroup.org/onlinepubs/9696989899/chap5.htm#tagcjh_08_02_01_01)\n\n## Copyright\n\nCopyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>.\n\nUUID package released under MIT License.\nSee [LICENSE](https://github.com/satori/go.uuid/blob/master/LICENSE) for details.\n"
        },
        {
          "name": "codec.go",
          "type": "blob",
          "size": 5.8876953125,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// FromBytes returns UUID converted from raw byte slice input.\n// It will return error if the slice isn't 16 bytes long.\nfunc FromBytes(input []byte) (u UUID, err error) {\n\terr = u.UnmarshalBinary(input)\n\treturn\n}\n\n// FromBytesOrNil returns UUID converted from raw byte slice input.\n// Same behavior as FromBytes, but returns a Nil UUID on error.\nfunc FromBytesOrNil(input []byte) UUID {\n\tuuid, err := FromBytes(input)\n\tif err != nil {\n\t\treturn Nil\n\t}\n\treturn uuid\n}\n\n// FromString returns UUID parsed from string input.\n// Input is expected in a form accepted by UnmarshalText.\nfunc FromString(input string) (u UUID, err error) {\n\terr = u.UnmarshalText([]byte(input))\n\treturn\n}\n\n// FromStringOrNil returns UUID parsed from string input.\n// Same behavior as FromString, but returns a Nil UUID on error.\nfunc FromStringOrNil(input string) UUID {\n\tuuid, err := FromString(input)\n\tif err != nil {\n\t\treturn Nil\n\t}\n\treturn uuid\n}\n\n// MarshalText implements the encoding.TextMarshaler interface.\n// The encoding is the same as returned by String.\nfunc (u UUID) MarshalText() (text []byte, err error) {\n\ttext = []byte(u.String())\n\treturn\n}\n\n// UnmarshalText implements the encoding.TextUnmarshaler interface.\n// Following formats are supported:\n//   \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n//   \"{6ba7b810-9dad-11d1-80b4-00c04fd430c8}\",\n//   \"urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n//   \"6ba7b8109dad11d180b400c04fd430c8\"\n// ABNF for supported UUID text representation follows:\n//   uuid := canonical | hashlike | braced | urn\n//   plain := canonical | hashlike\n//   canonical := 4hexoct '-' 2hexoct '-' 2hexoct '-' 6hexoct\n//   hashlike := 12hexoct\n//   braced := '{' plain '}'\n//   urn := URN ':' UUID-NID ':' plain\n//   URN := 'urn'\n//   UUID-NID := 'uuid'\n//   12hexoct := 6hexoct 6hexoct\n//   6hexoct := 4hexoct 2hexoct\n//   4hexoct := 2hexoct 2hexoct\n//   2hexoct := hexoct hexoct\n//   hexoct := hexdig hexdig\n//   hexdig := '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' |\n//             'a' | 'b' | 'c' | 'd' | 'e' | 'f' |\n//             'A' | 'B' | 'C' | 'D' | 'E' | 'F'\nfunc (u *UUID) UnmarshalText(text []byte) (err error) {\n\tswitch len(text) {\n\tcase 32:\n\t\treturn u.decodeHashLike(text)\n\tcase 36:\n\t\treturn u.decodeCanonical(text)\n\tcase 38:\n\t\treturn u.decodeBraced(text)\n\tcase 41:\n\t\tfallthrough\n\tcase 45:\n\t\treturn u.decodeURN(text)\n\tdefault:\n\t\treturn fmt.Errorf(\"uuid: incorrect UUID length: %s\", text)\n\t}\n}\n\n// decodeCanonical decodes UUID string in format\n// \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\".\nfunc (u *UUID) decodeCanonical(t []byte) (err error) {\n\tif t[8] != '-' || t[13] != '-' || t[18] != '-' || t[23] != '-' {\n\t\treturn fmt.Errorf(\"uuid: incorrect UUID format %s\", t)\n\t}\n\n\tsrc := t[:]\n\tdst := u[:]\n\n\tfor i, byteGroup := range byteGroups {\n\t\tif i > 0 {\n\t\t\tsrc = src[1:] // skip dash\n\t\t}\n\t\t_, err = hex.Decode(dst[:byteGroup/2], src[:byteGroup])\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tsrc = src[byteGroup:]\n\t\tdst = dst[byteGroup/2:]\n\t}\n\n\treturn\n}\n\n// decodeHashLike decodes UUID string in format\n// \"6ba7b8109dad11d180b400c04fd430c8\".\nfunc (u *UUID) decodeHashLike(t []byte) (err error) {\n\tsrc := t[:]\n\tdst := u[:]\n\n\tif _, err = hex.Decode(dst, src); err != nil {\n\t\treturn err\n\t}\n\treturn\n}\n\n// decodeBraced decodes UUID string in format\n// \"{6ba7b810-9dad-11d1-80b4-00c04fd430c8}\" or in format\n// \"{6ba7b8109dad11d180b400c04fd430c8}\".\nfunc (u *UUID) decodeBraced(t []byte) (err error) {\n\tl := len(t)\n\n\tif t[0] != '{' || t[l-1] != '}' {\n\t\treturn fmt.Errorf(\"uuid: incorrect UUID format %s\", t)\n\t}\n\n\treturn u.decodePlain(t[1 : l-1])\n}\n\n// decodeURN decodes UUID string in format\n// \"urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8\" or in format\n// \"urn:uuid:6ba7b8109dad11d180b400c04fd430c8\".\nfunc (u *UUID) decodeURN(t []byte) (err error) {\n\ttotal := len(t)\n\n\turn_uuid_prefix := t[:9]\n\n\tif !bytes.Equal(urn_uuid_prefix, urnPrefix) {\n\t\treturn fmt.Errorf(\"uuid: incorrect UUID format: %s\", t)\n\t}\n\n\treturn u.decodePlain(t[9:total])\n}\n\n// decodePlain decodes UUID string in canonical format\n// \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\" or in hash-like format\n// \"6ba7b8109dad11d180b400c04fd430c8\".\nfunc (u *UUID) decodePlain(t []byte) (err error) {\n\tswitch len(t) {\n\tcase 32:\n\t\treturn u.decodeHashLike(t)\n\tcase 36:\n\t\treturn u.decodeCanonical(t)\n\tdefault:\n\t\treturn fmt.Errorf(\"uuid: incorrrect UUID length: %s\", t)\n\t}\n}\n\n// MarshalBinary implements the encoding.BinaryMarshaler interface.\nfunc (u UUID) MarshalBinary() (data []byte, err error) {\n\tdata = u.Bytes()\n\treturn\n}\n\n// UnmarshalBinary implements the encoding.BinaryUnmarshaler interface.\n// It will return error if the slice isn't 16 bytes long.\nfunc (u *UUID) UnmarshalBinary(data []byte) (err error) {\n\tif len(data) != Size {\n\t\terr = fmt.Errorf(\"uuid: UUID must be exactly 16 bytes long, got %d bytes\", len(data))\n\t\treturn\n\t}\n\tcopy(u[:], data)\n\n\treturn\n}\n"
        },
        {
          "name": "codec_test.go",
          "type": "blob",
          "size": 6.9638671875,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype codecTestSuite struct{}\n\nvar _ = Suite(&codecTestSuite{})\n\nfunc (s *codecTestSuite) TestFromBytes(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\tu1, err := FromBytes(b1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Equals, u)\n\n\tb2 := []byte{}\n\t_, err = FromBytes(b2)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *codecTestSuite) BenchmarkFromBytes(c *C) {\n\tbytes := []byte{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tfor i := 0; i < c.N; i++ {\n\t\tFromBytes(bytes)\n\t}\n}\n\nfunc (s *codecTestSuite) TestMarshalBinary(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\tb2, err := u.MarshalBinary()\n\tc.Assert(err, IsNil)\n\tc.Assert(bytes.Equal(b1, b2), Equals, true)\n}\n\nfunc (s *codecTestSuite) BenchmarkMarshalBinary(c *C) {\n\tu, err := NewV4()\n\tc.Assert(err, IsNil)\n\tfor i := 0; i < c.N; i++ {\n\t\tu.MarshalBinary()\n\t}\n}\n\nfunc (s *codecTestSuite) TestUnmarshalBinary(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\tu1 := UUID{}\n\terr := u1.UnmarshalBinary(b1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Equals, u)\n\n\tb2 := []byte{}\n\tu2 := UUID{}\n\terr = u2.UnmarshalBinary(b2)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *codecTestSuite) TestFromString(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\ts1 := \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n\ts2 := \"{6ba7b810-9dad-11d1-80b4-00c04fd430c8}\"\n\ts3 := \"urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n\ts4 := \"6ba7b8109dad11d180b400c04fd430c8\"\n\ts5 := \"urn:uuid:6ba7b8109dad11d180b400c04fd430c8\"\n\n\t_, err := FromString(\"\")\n\tc.Assert(err, NotNil)\n\n\tu1, err := FromString(s1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Equals, u)\n\n\tu2, err := FromString(s2)\n\tc.Assert(err, IsNil)\n\tc.Assert(u2, Equals, u)\n\n\tu3, err := FromString(s3)\n\tc.Assert(err, IsNil)\n\tc.Assert(u3, Equals, u)\n\n\tu4, err := FromString(s4)\n\tc.Assert(err, IsNil)\n\tc.Assert(u4, Equals, u)\n\n\tu5, err := FromString(s5)\n\tc.Assert(err, IsNil)\n\tc.Assert(u5, Equals, u)\n}\n\nfunc (s *codecTestSuite) BenchmarkFromString(c *C) {\n\tstr := \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n\tfor i := 0; i < c.N; i++ {\n\t\tFromString(str)\n\t}\n}\n\nfunc (s *codecTestSuite) BenchmarkFromStringUrn(c *C) {\n\tstr := \"urn:uuid:6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n\tfor i := 0; i < c.N; i++ {\n\t\tFromString(str)\n\t}\n}\n\nfunc (s *codecTestSuite) BenchmarkFromStringWithBrackets(c *C) {\n\tstr := \"{6ba7b810-9dad-11d1-80b4-00c04fd430c8}\"\n\tfor i := 0; i < c.N; i++ {\n\t\tFromString(str)\n\t}\n}\n\nfunc (s *codecTestSuite) TestFromStringShort(c *C) {\n\t// Invalid 35-character UUID string\n\ts1 := \"6ba7b810-9dad-11d1-80b4-00c04fd430c\"\n\n\tfor i := len(s1); i >= 0; i-- {\n\t\t_, err := FromString(s1[:i])\n\t\tc.Assert(err, NotNil)\n\t}\n}\n\nfunc (s *codecTestSuite) TestFromStringLong(c *C) {\n\t// Invalid 37+ character UUID string\n\tstrings := []string{\n\t\t\"6ba7b810-9dad-11d1-80b4-00c04fd430c8=\",\n\t\t\"6ba7b810-9dad-11d1-80b4-00c04fd430c8}\",\n\t\t\"{6ba7b810-9dad-11d1-80b4-00c04fd430c8}f\",\n\t\t\"6ba7b810-9dad-11d1-80b4-00c04fd430c800c04fd430c8\",\n\t}\n\n\tfor _, str := range strings {\n\t\t_, err := FromString(str)\n\t\tc.Assert(err, NotNil)\n\t}\n}\n\nfunc (s *codecTestSuite) TestFromStringInvalid(c *C) {\n\t// Invalid UUID string formats\n\tstrings := []string{\n\t\t\"6ba7b8109dad11d180b400c04fd430c86ba7b8109dad11d180b400c04fd430c8\",\n\t\t\"urn:uuid:{6ba7b810-9dad-11d1-80b4-00c04fd430c8}\",\n\t\t\"uuid:urn:6ba7b810-9dad-11d1-80b4-00c04fd430c8\",\n\t\t\"uuid:urn:6ba7b8109dad11d180b400c04fd430c8\",\n\t\t\"6ba7b8109-dad-11d1-80b4-00c04fd430c8\",\n\t\t\"6ba7b810-9dad1-1d1-80b4-00c04fd430c8\",\n\t\t\"6ba7b810-9dad-11d18-0b4-00c04fd430c8\",\n\t\t\"6ba7b810-9dad-11d1-80b40-0c04fd430c8\",\n\t\t\"6ba7b810+9dad+11d1+80b4+00c04fd430c8\",\n\t\t\"(6ba7b810-9dad-11d1-80b4-00c04fd430c8}\",\n\t\t\"{6ba7b810-9dad-11d1-80b4-00c04fd430c8>\",\n\t\t\"zba7b810-9dad-11d1-80b4-00c04fd430c8\",\n\t\t\"6ba7b810-9dad11d180b400c04fd430c8\",\n\t\t\"6ba7b8109dad-11d180b400c04fd430c8\",\n\t\t\"6ba7b8109dad11d1-80b400c04fd430c8\",\n\t\t\"6ba7b8109dad11d180b4-00c04fd430c8\",\n\t}\n\n\tfor _, str := range strings {\n\t\t_, err := FromString(str)\n\t\tc.Assert(err, NotNil)\n\t}\n}\n\nfunc (s *codecTestSuite) TestFromStringOrNil(c *C) {\n\tu := FromStringOrNil(\"\")\n\tc.Assert(u, Equals, Nil)\n}\n\nfunc (s *codecTestSuite) TestFromBytesOrNil(c *C) {\n\tb := []byte{}\n\tu := FromBytesOrNil(b)\n\tc.Assert(u, Equals, Nil)\n}\n\nfunc (s *codecTestSuite) TestMarshalText(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\n\tb2, err := u.MarshalText()\n\tc.Assert(err, IsNil)\n\tc.Assert(bytes.Equal(b1, b2), Equals, true)\n}\n\nfunc (s *codecTestSuite) BenchmarkMarshalText(c *C) {\n\tu, err := NewV4()\n\tc.Assert(err, IsNil)\n\tfor i := 0; i < c.N; i++ {\n\t\tu.MarshalText()\n\t}\n}\n\nfunc (s *codecTestSuite) TestUnmarshalText(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\n\tu1 := UUID{}\n\terr := u1.UnmarshalText(b1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Equals, u)\n\n\tb2 := []byte(\"\")\n\tu2 := UUID{}\n\terr = u2.UnmarshalText(b2)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *codecTestSuite) BenchmarkUnmarshalText(c *C) {\n\tbytes := []byte(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\tu := UUID{}\n\tfor i := 0; i < c.N; i++ {\n\t\tu.UnmarshalText(bytes)\n\t}\n}\n\nvar sink string\n\nfunc (s *codecTestSuite) BenchmarkMarshalToString(c *C) {\n\tu, err := NewV4()\n\tc.Assert(err, IsNil)\n\tfor i := 0; i < c.N; i++ {\n\t\tsink = u.String()\n\t}\n}\n"
        },
        {
          "name": "generator.go",
          "type": "blob",
          "size": 6.4560546875,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t\"crypto/md5\"\n\t\"crypto/rand\"\n\t\"crypto/sha1\"\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"hash\"\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Difference in 100-nanosecond intervals between\n// UUID epoch (October 15, 1582) and Unix epoch (January 1, 1970).\nconst epochStart = 122192928000000000\n\ntype epochFunc func() time.Time\ntype hwAddrFunc func() (net.HardwareAddr, error)\n\nvar (\n\tglobal = newRFC4122Generator()\n\n\tposixUID = uint32(os.Getuid())\n\tposixGID = uint32(os.Getgid())\n)\n\n// NewV1 returns UUID based on current timestamp and MAC address.\nfunc NewV1() (UUID, error) {\n\treturn global.NewV1()\n}\n\n// NewV2 returns DCE Security UUID based on POSIX UID/GID.\nfunc NewV2(domain byte) (UUID, error) {\n\treturn global.NewV2(domain)\n}\n\n// NewV3 returns UUID based on MD5 hash of namespace UUID and name.\nfunc NewV3(ns UUID, name string) UUID {\n\treturn global.NewV3(ns, name)\n}\n\n// NewV4 returns random generated UUID.\nfunc NewV4() (UUID, error) {\n\treturn global.NewV4()\n}\n\n// NewV5 returns UUID based on SHA-1 hash of namespace UUID and name.\nfunc NewV5(ns UUID, name string) UUID {\n\treturn global.NewV5(ns, name)\n}\n\n// Generator provides interface for generating UUIDs.\ntype Generator interface {\n\tNewV1() (UUID, error)\n\tNewV2(domain byte) (UUID, error)\n\tNewV3(ns UUID, name string) UUID\n\tNewV4() (UUID, error)\n\tNewV5(ns UUID, name string) UUID\n}\n\n// Default generator implementation.\ntype rfc4122Generator struct {\n\tclockSequenceOnce sync.Once\n\thardwareAddrOnce  sync.Once\n\tstorageMutex      sync.Mutex\n\n\trand io.Reader\n\n\tepochFunc     epochFunc\n\thwAddrFunc    hwAddrFunc\n\tlastTime      uint64\n\tclockSequence uint16\n\thardwareAddr  [6]byte\n}\n\nfunc newRFC4122Generator() Generator {\n\treturn &rfc4122Generator{\n\t\tepochFunc:  time.Now,\n\t\thwAddrFunc: defaultHWAddrFunc,\n\t\trand:       rand.Reader,\n\t}\n}\n\n// NewV1 returns UUID based on current timestamp and MAC address.\nfunc (g *rfc4122Generator) NewV1() (UUID, error) {\n\tu := UUID{}\n\n\ttimeNow, clockSeq, err := g.getClockSequence()\n\tif err != nil {\n\t\treturn Nil, err\n\t}\n\tbinary.BigEndian.PutUint32(u[0:], uint32(timeNow))\n\tbinary.BigEndian.PutUint16(u[4:], uint16(timeNow>>32))\n\tbinary.BigEndian.PutUint16(u[6:], uint16(timeNow>>48))\n\tbinary.BigEndian.PutUint16(u[8:], clockSeq)\n\n\thardwareAddr, err := g.getHardwareAddr()\n\tif err != nil {\n\t\treturn Nil, err\n\t}\n\tcopy(u[10:], hardwareAddr)\n\n\tu.SetVersion(V1)\n\tu.SetVariant(VariantRFC4122)\n\n\treturn u, nil\n}\n\n// NewV2 returns DCE Security UUID based on POSIX UID/GID.\nfunc (g *rfc4122Generator) NewV2(domain byte) (UUID, error) {\n\tu, err := g.NewV1()\n\tif err != nil {\n\t\treturn Nil, err\n\t}\n\n\tswitch domain {\n\tcase DomainPerson:\n\t\tbinary.BigEndian.PutUint32(u[:], posixUID)\n\tcase DomainGroup:\n\t\tbinary.BigEndian.PutUint32(u[:], posixGID)\n\t}\n\n\tu[9] = domain\n\n\tu.SetVersion(V2)\n\tu.SetVariant(VariantRFC4122)\n\n\treturn u, nil\n}\n\n// NewV3 returns UUID based on MD5 hash of namespace UUID and name.\nfunc (g *rfc4122Generator) NewV3(ns UUID, name string) UUID {\n\tu := newFromHash(md5.New(), ns, name)\n\tu.SetVersion(V3)\n\tu.SetVariant(VariantRFC4122)\n\n\treturn u\n}\n\n// NewV4 returns random generated UUID.\nfunc (g *rfc4122Generator) NewV4() (UUID, error) {\n\tu := UUID{}\n\tif _, err := io.ReadFull(g.rand, u[:]); err != nil {\n\t\treturn Nil, err\n\t}\n\tu.SetVersion(V4)\n\tu.SetVariant(VariantRFC4122)\n\n\treturn u, nil\n}\n\n// NewV5 returns UUID based on SHA-1 hash of namespace UUID and name.\nfunc (g *rfc4122Generator) NewV5(ns UUID, name string) UUID {\n\tu := newFromHash(sha1.New(), ns, name)\n\tu.SetVersion(V5)\n\tu.SetVariant(VariantRFC4122)\n\n\treturn u\n}\n\n// Returns epoch and clock sequence.\nfunc (g *rfc4122Generator) getClockSequence() (uint64, uint16, error) {\n\tvar err error\n\tg.clockSequenceOnce.Do(func() {\n\t\tbuf := make([]byte, 2)\n\t\tif _, err = io.ReadFull(g.rand, buf); err != nil {\n\t\t\treturn\n\t\t}\n\t\tg.clockSequence = binary.BigEndian.Uint16(buf)\n\t})\n\tif err != nil {\n\t\treturn 0, 0, err\n\t}\n\n\tg.storageMutex.Lock()\n\tdefer g.storageMutex.Unlock()\n\n\ttimeNow := g.getEpoch()\n\t// Clock didn't change since last UUID generation.\n\t// Should increase clock sequence.\n\tif timeNow <= g.lastTime {\n\t\tg.clockSequence++\n\t}\n\tg.lastTime = timeNow\n\n\treturn timeNow, g.clockSequence, nil\n}\n\n// Returns hardware address.\nfunc (g *rfc4122Generator) getHardwareAddr() ([]byte, error) {\n\tvar err error\n\tg.hardwareAddrOnce.Do(func() {\n\t\tif hwAddr, err := g.hwAddrFunc(); err == nil {\n\t\t\tcopy(g.hardwareAddr[:], hwAddr)\n\t\t\treturn\n\t\t}\n\n\t\t// Initialize hardwareAddr randomly in case\n\t\t// of real network interfaces absence.\n\t\tif _, err = io.ReadFull(g.rand, g.hardwareAddr[:]); err != nil {\n\t\t\treturn\n\t\t}\n\t\t// Set multicast bit as recommended by RFC 4122\n\t\tg.hardwareAddr[0] |= 0x01\n\t})\n\tif err != nil {\n\t\treturn []byte{}, err\n\t}\n\treturn g.hardwareAddr[:], nil\n}\n\n// Returns difference in 100-nanosecond intervals between\n// UUID epoch (October 15, 1582) and current time.\nfunc (g *rfc4122Generator) getEpoch() uint64 {\n\treturn epochStart + uint64(g.epochFunc().UnixNano()/100)\n}\n\n// Returns UUID based on hashing of namespace UUID and name.\nfunc newFromHash(h hash.Hash, ns UUID, name string) UUID {\n\tu := UUID{}\n\th.Write(ns[:])\n\th.Write([]byte(name))\n\tcopy(u[:], h.Sum(nil))\n\n\treturn u\n}\n\n// Returns hardware address.\nfunc defaultHWAddrFunc() (net.HardwareAddr, error) {\n\tifaces, err := net.Interfaces()\n\tif err != nil {\n\t\treturn []byte{}, err\n\t}\n\tfor _, iface := range ifaces {\n\t\tif len(iface.HardwareAddr) >= 6 {\n\t\t\treturn iface.HardwareAddr, nil\n\t\t}\n\t}\n\treturn []byte{}, fmt.Errorf(\"uuid: no HW address found\")\n}\n"
        },
        {
          "name": "generator_test.go",
          "type": "blob",
          "size": 5.9033203125,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"net\"\n\t\"testing/iotest\"\n\t\"time\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\ntype faultyReader struct {\n\tcallsNum   int\n\treadToFail int // Read call number to fail\n}\n\nfunc (r *faultyReader) Read(dest []byte) (int, error) {\n\tr.callsNum++\n\tif (r.callsNum - 1) == r.readToFail {\n\t\treturn 0, fmt.Errorf(\"io: reader is faulty\")\n\t}\n\treturn rand.Read(dest)\n}\n\ntype genTestSuite struct{}\n\nvar _ = Suite(&genTestSuite{})\n\nfunc (s *genTestSuite) TestNewV1(c *C) {\n\tu1, err := NewV1()\n\tc.Assert(err, IsNil)\n\tc.Assert(u1.Version(), Equals, V1)\n\tc.Assert(u1.Variant(), Equals, VariantRFC4122)\n\n\tu2, err := NewV1()\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Not(Equals), u2)\n}\n\nfunc (s *genTestSuite) TestNewV1EpochStale(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc: func() time.Time {\n\t\t\treturn time.Unix(0, 0)\n\t\t},\n\t\thwAddrFunc: defaultHWAddrFunc,\n\t\trand:       rand.Reader,\n\t}\n\tu1, err := g.NewV1()\n\tc.Assert(err, IsNil)\n\tu2, err := g.NewV1()\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Not(Equals), u2)\n}\n\nfunc (s *genTestSuite) TestNewV1FaultyRand(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc:  time.Now,\n\t\thwAddrFunc: defaultHWAddrFunc,\n\t\trand:       &faultyReader{},\n\t}\n\tu1, err := g.NewV1()\n\tc.Assert(err, NotNil)\n\tc.Assert(u1, Equals, Nil)\n}\n\nfunc (s *genTestSuite) TestNewV1MissingNetworkInterfaces(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc: time.Now,\n\t\thwAddrFunc: func() (net.HardwareAddr, error) {\n\t\t\treturn []byte{}, fmt.Errorf(\"uuid: no hw address found\")\n\t\t},\n\t\trand: rand.Reader,\n\t}\n\t_, err := g.NewV1()\n\tc.Assert(err, IsNil)\n}\n\nfunc (s *genTestSuite) TestNewV1MissingNetInterfacesAndFaultyRand(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc: time.Now,\n\t\thwAddrFunc: func() (net.HardwareAddr, error) {\n\t\t\treturn []byte{}, fmt.Errorf(\"uuid: no hw address found\")\n\t\t},\n\t\trand: &faultyReader{\n\t\t\treadToFail: 1,\n\t\t},\n\t}\n\tu1, err := g.NewV1()\n\tc.Assert(err, NotNil)\n\tc.Assert(u1, Equals, Nil)\n}\n\nfunc (s *genTestSuite) BenchmarkNewV1(c *C) {\n\tfor i := 0; i < c.N; i++ {\n\t\tNewV1()\n\t}\n}\n\nfunc (s *genTestSuite) TestNewV2(c *C) {\n\tu1, err := NewV2(DomainPerson)\n\tc.Assert(err, IsNil)\n\tc.Assert(u1.Version(), Equals, V2)\n\tc.Assert(u1.Variant(), Equals, VariantRFC4122)\n\n\tu2, err := NewV2(DomainGroup)\n\tc.Assert(err, IsNil)\n\tc.Assert(u2.Version(), Equals, V2)\n\tc.Assert(u2.Variant(), Equals, VariantRFC4122)\n\n\tu3, err := NewV2(DomainOrg)\n\tc.Assert(err, IsNil)\n\tc.Assert(u3.Version(), Equals, V2)\n\tc.Assert(u3.Variant(), Equals, VariantRFC4122)\n}\n\nfunc (s *genTestSuite) TestNewV2FaultyRand(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc:  time.Now,\n\t\thwAddrFunc: defaultHWAddrFunc,\n\t\trand:       &faultyReader{},\n\t}\n\tu1, err := g.NewV2(DomainPerson)\n\tc.Assert(err, NotNil)\n\tc.Assert(u1, Equals, Nil)\n}\n\nfunc (s *genTestSuite) BenchmarkNewV2(c *C) {\n\tfor i := 0; i < c.N; i++ {\n\t\tNewV2(DomainPerson)\n\t}\n}\n\nfunc (s *genTestSuite) TestNewV3(c *C) {\n\tu1 := NewV3(NamespaceDNS, \"www.example.com\")\n\tc.Assert(u1.Version(), Equals, V3)\n\tc.Assert(u1.Variant(), Equals, VariantRFC4122)\n\tc.Assert(u1.String(), Equals, \"5df41881-3aed-3515-88a7-2f4a814cf09e\")\n\n\tu2 := NewV3(NamespaceDNS, \"example.com\")\n\tc.Assert(u2, Not(Equals), u1)\n\n\tu3 := NewV3(NamespaceDNS, \"example.com\")\n\tc.Assert(u3, Equals, u2)\n\n\tu4 := NewV3(NamespaceURL, \"example.com\")\n\tc.Assert(u4, Not(Equals), u3)\n}\n\nfunc (s *genTestSuite) BenchmarkNewV3(c *C) {\n\tfor i := 0; i < c.N; i++ {\n\t\tNewV3(NamespaceDNS, \"www.example.com\")\n\t}\n}\n\nfunc (s *genTestSuite) TestNewV4(c *C) {\n\tu1, err := NewV4()\n\tc.Assert(err, IsNil)\n\tc.Assert(u1.Version(), Equals, V4)\n\tc.Assert(u1.Variant(), Equals, VariantRFC4122)\n\n\tu2, err := NewV4()\n\tc.Assert(err, IsNil)\n\tc.Assert(u1, Not(Equals), u2)\n}\n\nfunc (s *genTestSuite) TestNewV4FaultyRand(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc:  time.Now,\n\t\thwAddrFunc: defaultHWAddrFunc,\n\t\trand:       &faultyReader{},\n\t}\n\tu1, err := g.NewV4()\n\tc.Assert(err, NotNil)\n\tc.Assert(u1, Equals, Nil)\n}\n\nfunc (s *genTestSuite) TestNewV4PartialRead(c *C) {\n\tg := &rfc4122Generator{\n\t\tepochFunc:  time.Now,\n\t\thwAddrFunc: defaultHWAddrFunc,\n\t\trand:       iotest.OneByteReader(rand.Reader),\n\t}\n\tu1, err := g.NewV4()\n\tzeros := bytes.Count(u1.Bytes(), []byte{0})\n\tmostlyZeros := zeros >= 10\n\n\tc.Assert(err, IsNil)\n\tc.Assert(mostlyZeros, Equals, false)\n}\n\nfunc (s *genTestSuite) BenchmarkNewV4(c *C) {\n\tfor i := 0; i < c.N; i++ {\n\t\tNewV4()\n\t}\n}\n\nfunc (s *genTestSuite) TestNewV5(c *C) {\n\tu1 := NewV5(NamespaceDNS, \"www.example.com\")\n\tc.Assert(u1.Version(), Equals, V5)\n\tc.Assert(u1.Variant(), Equals, VariantRFC4122)\n\tc.Assert(u1.String(), Equals, \"2ed6657d-e927-568b-95e1-2665a8aea6a2\")\n\n\tu2 := NewV5(NamespaceDNS, \"example.com\")\n\tc.Assert(u2, Not(Equals), u1)\n\n\tu3 := NewV5(NamespaceDNS, \"example.com\")\n\tc.Assert(u3, Equals, u2)\n\n\tu4 := NewV5(NamespaceURL, \"example.com\")\n\tc.Assert(u4, Not(Equals), u3)\n}\n\nfunc (s *genTestSuite) BenchmarkNewV5(c *C) {\n\tfor i := 0; i < c.N; i++ {\n\t\tNewV5(NamespaceDNS, \"www.example.com\")\n\t}\n}\n"
        },
        {
          "name": "sql.go",
          "type": "blob",
          "size": 2.326171875,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t\"database/sql/driver\"\n\t\"fmt\"\n)\n\n// Value implements the driver.Valuer interface.\nfunc (u UUID) Value() (driver.Value, error) {\n\treturn u.String(), nil\n}\n\n// Scan implements the sql.Scanner interface.\n// A 16-byte slice is handled by UnmarshalBinary, while\n// a longer byte slice or a string is handled by UnmarshalText.\nfunc (u *UUID) Scan(src interface{}) error {\n\tswitch src := src.(type) {\n\tcase []byte:\n\t\tif len(src) == Size {\n\t\t\treturn u.UnmarshalBinary(src)\n\t\t}\n\t\treturn u.UnmarshalText(src)\n\n\tcase string:\n\t\treturn u.UnmarshalText([]byte(src))\n\t}\n\n\treturn fmt.Errorf(\"uuid: cannot convert %T to UUID\", src)\n}\n\n// NullUUID can be used with the standard sql package to represent a\n// UUID value that can be NULL in the database\ntype NullUUID struct {\n\tUUID  UUID\n\tValid bool\n}\n\n// Value implements the driver.Valuer interface.\nfunc (u NullUUID) Value() (driver.Value, error) {\n\tif !u.Valid {\n\t\treturn nil, nil\n\t}\n\t// Delegate to UUID Value function\n\treturn u.UUID.Value()\n}\n\n// Scan implements the sql.Scanner interface.\nfunc (u *NullUUID) Scan(src interface{}) error {\n\tif src == nil {\n\t\tu.UUID, u.Valid = Nil, false\n\t\treturn nil\n\t}\n\n\t// Delegate to UUID Scan function\n\tu.Valid = true\n\treturn u.UUID.Scan(src)\n}\n"
        },
        {
          "name": "sql_test.go",
          "type": "blob",
          "size": 3.7177734375,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t. \"gopkg.in/check.v1\"\n)\n\ntype sqlTestSuite struct{}\n\nvar _ = Suite(&sqlTestSuite{})\n\nfunc (s *sqlTestSuite) TestValue(c *C) {\n\tu, err := FromString(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\tc.Assert(err, IsNil)\n\n\tval, err := u.Value()\n\tc.Assert(err, IsNil)\n\tc.Assert(val, Equals, u.String())\n}\n\nfunc (s *sqlTestSuite) TestValueNil(c *C) {\n\tu := UUID{}\n\n\tval, err := u.Value()\n\tc.Assert(err, IsNil)\n\tc.Assert(val, Equals, Nil.String())\n}\n\nfunc (s *sqlTestSuite) TestNullUUIDValueNil(c *C) {\n\tu := NullUUID{}\n\n\tval, err := u.Value()\n\tc.Assert(err, IsNil)\n\tc.Assert(val, IsNil)\n}\n\nfunc (s *sqlTestSuite) TestScanBinary(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\tu1 := UUID{}\n\terr := u1.Scan(b1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u, Equals, u1)\n\n\tb2 := []byte{}\n\tu2 := UUID{}\n\n\terr = u2.Scan(b2)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *sqlTestSuite) TestScanString(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\ts1 := \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n\n\tu1 := UUID{}\n\terr := u1.Scan(s1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u, Equals, u1)\n\n\ts2 := \"\"\n\tu2 := UUID{}\n\n\terr = u2.Scan(s2)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *sqlTestSuite) TestScanText(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\tb1 := []byte(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n\n\tu1 := UUID{}\n\terr := u1.Scan(b1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u, Equals, u1)\n\n\tb2 := []byte(\"\")\n\tu2 := UUID{}\n\terr = u2.Scan(b2)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *sqlTestSuite) TestScanUnsupported(c *C) {\n\tu := UUID{}\n\n\terr := u.Scan(true)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *sqlTestSuite) TestScanNil(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\terr := u.Scan(nil)\n\tc.Assert(err, NotNil)\n}\n\nfunc (s *sqlTestSuite) TestNullUUIDScanValid(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\ts1 := \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"\n\n\tu1 := NullUUID{}\n\terr := u1.Scan(s1)\n\tc.Assert(err, IsNil)\n\tc.Assert(u1.Valid, Equals, true)\n\tc.Assert(u1.UUID, Equals, u)\n}\n\nfunc (s *sqlTestSuite) TestNullUUIDScanNil(c *C) {\n\tu := NullUUID{UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}, true}\n\n\terr := u.Scan(nil)\n\tc.Assert(err, IsNil)\n\tc.Assert(u.Valid, Equals, false)\n\tc.Assert(u.UUID, Equals, Nil)\n}\n"
        },
        {
          "name": "uuid.go",
          "type": "blob",
          "size": 4.0859375,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Package uuid provides implementation of Universally Unique Identifier (UUID).\n// Supported versions are 1, 3, 4 and 5 (as specified in RFC 4122) and\n// version 2 (as specified in DCE 1.1).\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"encoding/hex\"\n)\n\n// Size of a UUID in bytes.\nconst Size = 16\n\n// UUID representation compliant with specification\n// described in RFC 4122.\ntype UUID [Size]byte\n\n// UUID versions\nconst (\n\t_ byte = iota\n\tV1\n\tV2\n\tV3\n\tV4\n\tV5\n)\n\n// UUID layout variants.\nconst (\n\tVariantNCS byte = iota\n\tVariantRFC4122\n\tVariantMicrosoft\n\tVariantFuture\n)\n\n// UUID DCE domains.\nconst (\n\tDomainPerson = iota\n\tDomainGroup\n\tDomainOrg\n)\n\n// String parse helpers.\nvar (\n\turnPrefix  = []byte(\"urn:uuid:\")\n\tbyteGroups = []int{8, 4, 4, 4, 12}\n)\n\n// Nil is special form of UUID that is specified to have all\n// 128 bits set to zero.\nvar Nil = UUID{}\n\n// Predefined namespace UUIDs.\nvar (\n\tNamespaceDNS  = Must(FromString(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\"))\n\tNamespaceURL  = Must(FromString(\"6ba7b811-9dad-11d1-80b4-00c04fd430c8\"))\n\tNamespaceOID  = Must(FromString(\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\"))\n\tNamespaceX500 = Must(FromString(\"6ba7b814-9dad-11d1-80b4-00c04fd430c8\"))\n)\n\n// Equal returns true if u1 and u2 equals, otherwise returns false.\nfunc Equal(u1 UUID, u2 UUID) bool {\n\treturn bytes.Equal(u1[:], u2[:])\n}\n\n// Version returns algorithm version used to generate UUID.\nfunc (u UUID) Version() byte {\n\treturn u[6] >> 4\n}\n\n// Variant returns UUID layout variant.\nfunc (u UUID) Variant() byte {\n\tswitch {\n\tcase (u[8] >> 7) == 0x00:\n\t\treturn VariantNCS\n\tcase (u[8] >> 6) == 0x02:\n\t\treturn VariantRFC4122\n\tcase (u[8] >> 5) == 0x06:\n\t\treturn VariantMicrosoft\n\tcase (u[8] >> 5) == 0x07:\n\t\tfallthrough\n\tdefault:\n\t\treturn VariantFuture\n\t}\n}\n\n// Bytes returns bytes slice representation of UUID.\nfunc (u UUID) Bytes() []byte {\n\treturn u[:]\n}\n\n// Returns canonical string representation of UUID:\n// xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\nfunc (u UUID) String() string {\n\tbuf := make([]byte, 36)\n\n\thex.Encode(buf[0:8], u[0:4])\n\tbuf[8] = '-'\n\thex.Encode(buf[9:13], u[4:6])\n\tbuf[13] = '-'\n\thex.Encode(buf[14:18], u[6:8])\n\tbuf[18] = '-'\n\thex.Encode(buf[19:23], u[8:10])\n\tbuf[23] = '-'\n\thex.Encode(buf[24:], u[10:])\n\n\treturn string(buf)\n}\n\n// SetVersion sets version bits.\nfunc (u *UUID) SetVersion(v byte) {\n\tu[6] = (u[6] & 0x0f) | (v << 4)\n}\n\n// SetVariant sets variant bits.\nfunc (u *UUID) SetVariant(v byte) {\n\tswitch v {\n\tcase VariantNCS:\n\t\tu[8] = (u[8]&(0xff>>1) | (0x00 << 7))\n\tcase VariantRFC4122:\n\t\tu[8] = (u[8]&(0xff>>2) | (0x02 << 6))\n\tcase VariantMicrosoft:\n\t\tu[8] = (u[8]&(0xff>>3) | (0x06 << 5))\n\tcase VariantFuture:\n\t\tfallthrough\n\tdefault:\n\t\tu[8] = (u[8]&(0xff>>3) | (0x07 << 5))\n\t}\n}\n\n// Must is a helper that wraps a call to a function returning (UUID, error)\n// and panics if the error is non-nil. It is intended for use in variable\n// initializations such as\n//\tvar packageUUID = uuid.Must(uuid.FromString(\"123e4567-e89b-12d3-a456-426655440000\"));\nfunc Must(u UUID, err error) UUID {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn u\n}\n"
        },
        {
          "name": "uuid_test.go",
          "type": "blob",
          "size": 3.3818359375,
          "content": "// Copyright (C) 2013-2018 by Maxim Bublis <b@codemonkey.ru>\n//\n// Permission is hereby granted, free of charge, to any person obtaining\n// a copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to\n// permit persons to whom the Software is furnished to do so, subject to\n// the following conditions:\n//\n// The above copyright notice and this permission notice shall be\n// included in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\npackage uuid\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"testing\"\n\n\t. \"gopkg.in/check.v1\"\n)\n\n// Hook up gocheck into the \"go test\" runner.\nfunc TestUUID(t *testing.T) { TestingT(t) }\n\ntype testSuite struct{}\n\nvar _ = Suite(&testSuite{})\n\nfunc (s *testSuite) TestBytes(c *C) {\n\tu := UUID{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\tbytes1 := []byte{0x6b, 0xa7, 0xb8, 0x10, 0x9d, 0xad, 0x11, 0xd1, 0x80, 0xb4, 0x00, 0xc0, 0x4f, 0xd4, 0x30, 0xc8}\n\n\tc.Assert(bytes.Equal(u.Bytes(), bytes1), Equals, true)\n}\n\nfunc (s *testSuite) TestString(c *C) {\n\tc.Assert(NamespaceDNS.String(), Equals, \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\n}\n\nfunc (s *testSuite) TestEqual(c *C) {\n\tc.Assert(Equal(NamespaceDNS, NamespaceDNS), Equals, true)\n\tc.Assert(Equal(NamespaceDNS, NamespaceURL), Equals, false)\n}\n\nfunc (s *testSuite) TestVersion(c *C) {\n\tu := UUID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tc.Assert(u.Version(), Equals, V1)\n}\n\nfunc (s *testSuite) TestSetVersion(c *C) {\n\tu := UUID{}\n\tu.SetVersion(4)\n\tc.Assert(u.Version(), Equals, V4)\n}\n\nfunc (s *testSuite) TestVariant(c *C) {\n\tu1 := UUID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tc.Assert(u1.Variant(), Equals, VariantNCS)\n\n\tu2 := UUID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tc.Assert(u2.Variant(), Equals, VariantRFC4122)\n\n\tu3 := UUID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tc.Assert(u3.Variant(), Equals, VariantMicrosoft)\n\n\tu4 := UUID{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n\tc.Assert(u4.Variant(), Equals, VariantFuture)\n}\n\nfunc (s *testSuite) TestSetVariant(c *C) {\n\tu := UUID{}\n\tu.SetVariant(VariantNCS)\n\tc.Assert(u.Variant(), Equals, VariantNCS)\n\tu.SetVariant(VariantRFC4122)\n\tc.Assert(u.Variant(), Equals, VariantRFC4122)\n\tu.SetVariant(VariantMicrosoft)\n\tc.Assert(u.Variant(), Equals, VariantMicrosoft)\n\tu.SetVariant(VariantFuture)\n\tc.Assert(u.Variant(), Equals, VariantFuture)\n}\n\nfunc (s *testSuite) TestMust(c *C) {\n\tdefer func() {\n\t\tc.Assert(recover(), NotNil)\n\t}()\n\tMust(func() (UUID, error) {\n\t\treturn Nil, fmt.Errorf(\"uuid: expected error\")\n\t}())\n}\n"
        }
      ]
    }
  ]
}