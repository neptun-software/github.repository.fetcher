{
  "metadata": {
    "timestamp": 1736567320390,
    "page": 926,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "FiloSottile/whoami.filippo.io",
      "stars": 2241,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0146484375,
          "content": "whoami.sqlite3\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3291015625,
          "content": "FROM golang:1.19-alpine3.16 AS builder\n\nRUN apk add --no-cache build-base\n\nCOPY *.go go.mod go.sum src\nWORKDIR src\nRUN go install -trimpath\n\nFROM alpine:3.16\n\nCOPY --from=builder /go/bin/whoami.filippo.io /usr/local/bin/\nCOPY whoami.sqlite3 /usr/local/share/\nENV DB_PATH /usr/local/share/whoami.sqlite3\n\nENTRYPOINT [\"whoami.filippo.io\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.7255859375,
          "content": "ISC License\n\nCopyright 2015 Filippo Valsorda\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.04296875,
          "content": "# whoami.filippo.io\nAn ssh server that knows who you are.\n\n## Try it (it's harmless)\n\n```\nssh whoami.filippo.io\n```\n\nED25519 key fingerprint is `SHA256:qGAqPqtlvFBCt4LfMME3IgJqZWlcrlBMxNmGjhLVYzY`.  \nRSA key fingerprint is `SHA256:O6zDQjQws92wQSA41wXusKquKMuugPVM/oBZXNmfyvI`.\n\n## How it works\n\nWhen ssh tries to authenticate via public key, it sends the server all your public keys, one by one, until the server accepts one. One can take advantage of this to enumerate all the client's installed public keys.\n\nOn the other hand, GitHub allows everyone to download users' public keys (which is very handy at times). Ben Cox took advantage of that and [built a dataset of all GitHub public keys](https://blog.benjojo.co.uk/post/auditing-github-users-keys).\n\nThis is a pretty vanilla `golang.org/x/crypto/ssh` Go server that will advertise `(publickey,keyboard-interactive)` authentication. It won't accept any public key, but it will take a note of them. Once the client is done with public keys, it will try `keyboard-interactive`, which the server will accept without sending any challenge, so that no user interaction is required.\n\nThen it just lets you open a shell+PTY, uses the public keys and Ben's database to find your username, asks the GitHub API your real name, prints all that and closes the terminal.  \n\nAll the interesting bits are in [server.go](https://github.com/FiloSottile/whosthere/blob/master/server.go).\n\n## How do I stop it?\n\nIf this behavior is problematic for you, you can tell ssh not to present your public keys to the server by default.\n\nAdd these lines at the end of your `~/.ssh/config` (after other \"Host\" directives)\n\n```\nHost *\n    PubkeyAuthentication no\n    IdentitiesOnly yes\n```\n\nAnd then specify what keys should be used for each host\n\n```\nHost example.com\n    PubkeyAuthentication yes\n    IdentityFile ~/.ssh/id_rsa\n    # IdentitiesOnly yes # Enable ssh-agent (PKCS11 etc.) keys\n```\n\nIf you want you can use different keys so that they can't be linked together\n\n```\nHost github.com\n    PubkeyAuthentication yes\n    IdentityFile ~/.ssh/github_id_rsa\n```\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "fly.toml",
          "type": "blob",
          "size": 0.3896484375,
          "content": "app = \"filippo-whoami\"\n\n[metrics]\n  port = 9091\n  path = \"/metrics\"\n\n[[services]]\n  internal_port = 8080\n  protocol = \"tcp\"\n\n  [[services.ports]]\n    handlers = [\"tls\", \"http\"]\n    port = \"443\"\n\n[[services]]\n  internal_port = 2222\n  protocol = \"tcp\"\n\n  [[services.ports]]\n    port = 22\n\n  [[services.tcp_checks]]\n    grace_period = \"1s\"\n    interval = \"10s\"\n    restart_limit = 6\n    timeout = \"2s\"\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.818359375,
          "content": "module github.com/FiloSottile/whoami.filippo.io\n\ngo 1.19\n\nrequire (\n\tcrawshaw.io/sqlite v0.3.2\n\tgithub.com/google/go-github/v42 v42.0.0\n\tgithub.com/prometheus/client_golang v1.14.0\n\tgolang.org/x/crypto v0.4.0\n\tgolang.org/x/oauth2 v0.3.0\n)\n\nrequire (\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.2.0 // indirect\n\tgithub.com/golang/protobuf v1.5.2 // indirect\n\tgithub.com/google/go-querystring v1.1.0 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.4 // indirect\n\tgithub.com/prometheus/client_model v0.3.0 // indirect\n\tgithub.com/prometheus/common v0.39.0 // indirect\n\tgithub.com/prometheus/procfs v0.9.0 // indirect\n\tgolang.org/x/net v0.4.0 // indirect\n\tgolang.org/x/sys v0.3.0 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgoogle.golang.org/protobuf v1.28.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 4.791015625,
          "content": "crawshaw.io/iox v0.0.0-20181124134642-c51c3df30797 h1:yDf7ARQc637HoxDho7xjqdvO5ZA2Yb+xzv/fOnnvZzw=\ncrawshaw.io/iox v0.0.0-20181124134642-c51c3df30797/go.mod h1:sXBiorCo8c46JlQV3oXPKINnZ8mcqnye1EkVkqsectk=\ncrawshaw.io/sqlite v0.3.2 h1:N6IzTjkiw9FItHAa0jp+ZKC6tuLzXqAYIv+ccIWos1I=\ncrawshaw.io/sqlite v0.3.2/go.mod h1:igAO5JulrQ1DbdZdtVq48mnZUBAPOeFzer7VhDWNtW4=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/cespare/xxhash/v2 v2.2.0 h1:DC2CZ1Ep5Y4k3ZQ899DldepgrayRUGE6BBZ/cd9Cj44=\ngithub.com/cespare/xxhash/v2 v2.2.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=\ngithub.com/golang/protobuf v1.3.5/go.mod h1:6O5/vntMXwX2lRkT1hjjk0nAC1IDOTvTlVgjlRvqsdk=\ngithub.com/golang/protobuf v1.5.0/go.mod h1:FsONVRAS9T7sI+LIUmWTfcYkHO4aIWwzhcaSAoJOfIk=\ngithub.com/golang/protobuf v1.5.2 h1:ROPKBNFfQgOUMifHyP+KYbvpjbdoFNs+aK7DXlji0Tw=\ngithub.com/golang/protobuf v1.5.2/go.mod h1:XVQd3VNwM+JqD3oG2Ue2ip4fOMUkwXdXDdiuN0vRsmY=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.9 h1:O2Tfq5qg4qc4AmwVlvv0oLiVAGB7enBSJ2x2DqQFi38=\ngithub.com/google/go-github/v42 v42.0.0 h1:YNT0FwjPrEysRkLIiKuEfSvBPCGKphW5aS5PxwaoLec=\ngithub.com/google/go-github/v42 v42.0.0/go.mod h1:jgg/jvyI0YlDOM1/ps6XYh04HNQ3vKf0CVko62/EhRg=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.4 h1:mmDVorXM7PCGKw94cs5zkfA9PSy5pEvNWRP0ET0TIVo=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.4/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=\ngithub.com/prometheus/client_golang v1.14.0 h1:nJdhIvne2eSX/XRAFV9PcvFFRbrjbcTUj0VP62TMhnw=\ngithub.com/prometheus/client_golang v1.14.0/go.mod h1:8vpkKitgIVNcqrRBWh1C4TIUQgYNtG/XQE4E/Zae36Y=\ngithub.com/prometheus/client_model v0.3.0 h1:UBgGFHqYdG/TPFD1B1ogZywDqEkwp3fBMvqdiQ7Xew4=\ngithub.com/prometheus/client_model v0.3.0/go.mod h1:LDGWKZIo7rky3hgvBe+caln+Dr3dPggB5dvjtD7w9+w=\ngithub.com/prometheus/common v0.39.0 h1:oOyhkDq05hPZKItWVBkJ6g6AtGxi+fy7F4JvUV8uhsI=\ngithub.com/prometheus/common v0.39.0/go.mod h1:6XBZ7lYdLCbkAVhwRsWTZn+IN5AB9F/NXd5w0BbEX0Y=\ngithub.com/prometheus/procfs v0.9.0 h1:wzCHvIvM5SxWqYvwgVL7yJY8Lz3PKn49KQtpgMYJfhI=\ngithub.com/prometheus/procfs v0.9.0/go.mod h1:+pB4zwohETzFnmlpe6yd2lSc+0/46IYZRB/chUwxUZY=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.4.0 h1:UVQgzMY87xqpKNgb+kDsll2Igd33HszWHFLmpaRMq/8=\ngolang.org/x/crypto v0.4.0/go.mod h1:3quD/ATkf6oY+rnes5c3ExXTbLc8mueNue5/DoinL80=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.4.0 h1:Q5QPcMlvfxFTAPV0+07Xz/MpK9NTXu2VDUuy0FeMfaU=\ngolang.org/x/net v0.4.0/go.mod h1:MBQ8lrhLObU/6UmLb4fmbmk5OcyYmqtbGd/9yIeKjEE=\ngolang.org/x/oauth2 v0.3.0 h1:6l90koy8/LaBLmLu8jpHeHexzMwEita0zFfYlggy2F8=\ngolang.org/x/oauth2 v0.3.0/go.mod h1:rQrIauxkUhJ6CuwEXwymO2/eh4xz2ZWF1nBkcxS+tGk=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.3.0 h1:w8ZOecv6NaNa/zC8944JTU3vz4u6Lagfk4RPQxv92NQ=\ngolang.org/x/sys v0.3.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.3.0 h1:qoo4akIqOcDME5bhc/NgxUdovd6BSS2uMsVjB56q1xI=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngoogle.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6c=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.28.1 h1:d0NfwRgPtno5B1Wa6L2DAG+KivqkdutMf1UhdNx175w=\ngoogle.golang.org/protobuf v1.28.1/go.mod h1:HV8QOd/L58Z+nl8r43ehVNZIU/HEI6OcFqwMG9pJV4I=\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 12.0556640625,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"crypto/sha256\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n\t\"text/template\"\n\t\"time\"\n\n\t\"crawshaw.io/sqlite/sqlitex\"\n\t\"github.com/google/go-github/v42/github\"\n\t\"golang.org/x/crypto/ssh\"\n\t\"golang.org/x/oauth2\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"github.com/prometheus/client_golang/prometheus/promauto\"\n\t\"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nvar sshConns = promauto.NewCounterVec(prometheus.CounterOpts{Name: \"ssh_connections_total\"},\n\t[]string{\"agent\", \"x11\", \"roaming\", \"keyCount\", \"identified\", \"error\"})\nvar hsErrs = promauto.NewCounter(prometheus.CounterOpts{Name: \"handshake_errors_total\"})\n\nfunc main() {\n\tmetricsMux := http.NewServeMux()\n\tmetricsMux.Handle(\"/metrics\", promhttp.Handler())\n\tmetricsServer := &http.Server{Addr: \":9091\", Handler: metricsMux,\n\t\tReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second}\n\tgo func() { log.Fatal(metricsServer.ListenAndServe()) }()\n\n\thttpServer := &http.Server{Addr: \":8080\",\n\t\tHandler:     http.RedirectHandler(\"https://words.filippo.io/dispatches/whoami-updated/\", 302),\n\t\tReadTimeout: 10 * time.Second, WriteTimeout: 10 * time.Second}\n\tgo func() { log.Fatal(httpServer.ListenAndServe()) }()\n\n\tts := oauth2.StaticTokenSource(\n\t\t&oauth2.Token{AccessToken: os.Getenv(\"GITHUB_TOKEN\")},\n\t)\n\ttc := oauth2.NewClient(context.Background(), ts)\n\tghClient := github.NewClient(tc)\n\t_, _, err := ghClient.Users.Get(context.Background(), \"\")\n\tfatalIfErr(err)\n\tlog.Println(\"Connected to GitHub...\")\n\n\tdb, err := sqlitex.Open(os.Getenv(\"DB_PATH\"), 0, 3)\n\tfatalIfErr(err)\n\tlog.Println(\"Opened database...\")\n\n\tserver := &Server{\n\t\tgithubClient: ghClient,\n\t\tdb:           db,\n\t\tsessionInfo:  make(map[string]sessionInfo),\n\t}\n\tserver.sshConfig = &ssh.ServerConfig{\n\t\tKeyboardInteractiveCallback: server.KeyboardInteractiveCallback,\n\t\tPublicKeyCallback:           server.PublicKeyCallback,\n\t}\n\n\tprivate, err := ssh.ParsePrivateKey([]byte(os.Getenv(\"SSH_HOST_KEY\")))\n\tfatalIfErr(err)\n\tserver.sshConfig.AddHostKey(private)\n\tprivateEd, err := ssh.ParsePrivateKey([]byte(os.Getenv(\"SSH_HOST_KEY_ED25519\")))\n\tfatalIfErr(err)\n\tserver.sshConfig.AddHostKey(privateEd)\n\tlog.Println(\"Loaded keys...\")\n\n\tlistener, err := net.Listen(\"tcp\", \":2222\")\n\tfatalIfErr(err)\n\tlog.Println(\"Listening...\")\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Accept failed:\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tgo server.Handle(conn)\n\t}\n}\n\nfunc fatalIfErr(err error) {\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n\nvar termTmpl = template.Must(template.New(\"termTmpl\").Parse(strings.Replace(`\n    +---------------------------------------------------------------------+\n    |                                                                     |\n    |             _o/ Hello {{ .Name }}!\n    |                                                                     |\n    |                                                                     |\n    |  Did you know that ssh sends all your public keys to any server     |\n    |  it tries to authenticate to?                                       |\n    |                                                                     |\n    |  We matched them to the keys of your GitHub account,                |\n    |  @{{ .User }}, which are available via the GraphQL API\n    |  and at https://github.com/{{ .User }}.keys\n    |                                                                     |\n    |  -- Filippo (https://filippo.io)                                    |\n    |                                                                     |\n    |                                                                     |\n    |  P.S. The source of this server is at                               |\n    |  https://github.com/FiloSottile/whoami.filippo.io                   |\n    |                                                                     |\n    +---------------------------------------------------------------------+\n\n`, \"\\n\", \"\\n\\r\", -1)))\n\nvar failedMsg = []byte(strings.Replace(`\n    +---------------------------------------------------------------------+\n    |                                                                     |\n    |             _o/ Hello!                                              |\n    |                                                                     |\n    |                                                                     |\n    |  Did you know that ssh sends all your public keys to any server     |\n    |  it tries to authenticate to? You can see yours echoed below.       |\n    |                                                                     |\n    |  We tried to use them to lookup your GitHub account,                |\n    |  but got no match :(                                                |\n    |                                                                     |\n    |  -- Filippo (https://filippo.io)                                    |\n    |                                                                     |\n    |                                                                     |\n    |  P.S. The source of this server is at                               |\n    |  https://github.com/FiloSottile/whoami.filippo.io                   |\n    |                                                                     |\n    +---------------------------------------------------------------------+\n\n`, \"\\n\", \"\\n\\r\", -1))\n\nvar agentMsg = []byte(strings.Replace(`\n                      ***** WARNING ***** WARNING *****\n\n           You have SSH agent forwarding turned (universally?) on.\n         That is a VERY BAD idea. For example, right now this server\n          has access to your agent and can use your keys however it\n                    likes as long as you are connected.\n\n               ANY SERVER YOU LOG IN TO AND ANYONE WITH ROOT ON\n                   THOSE SERVERS CAN LOGIN AS YOU ANYWHERE.\n\n                       Read more:  http://git.io/vO2A6\n`, \"\\n\", \"\\n\\r\", -1))\n\nvar x11Msg = []byte(strings.Replace(`\n                      ***** WARNING ***** WARNING *****\n\n               You have X11 forwarding turned (universally?) on.\n          That is a VERY BAD idea. For example, right now this server\n              has access to your desktop, windows, and keystrokes\n                         as long as you are connected.\n\n                ANY SERVER YOU LOG IN TO AND ANYONE WITH ROOT ON\n         THOSE SERVERS CAN SNIFF YOUR KEYSTROKES AND ACCESS YOUR WINDOWS.\n\n     Read more:  http://www.hackinglinuxexposed.com/articles/20040705.html\n`, \"\\n\", \"\\n\\r\", -1))\n\nvar roamingMsg = []byte(strings.Replace(`\n                      ***** WARNING ***** WARNING *****\n\n    You have roaming turned on. If you are using OpenSSH, that most likely\n       means you are vulnerable to the CVE-2016-0777 information leak.\n\n   THIS MEANS THAT ANY SERVER YOU CONNECT TO MIGHT OBTAIN YOUR PRIVATE KEYS.\n\n     Add \"UseRoaming no\" to the \"Host *\" section of your ~/.ssh/config or\n           /etc/ssh/ssh_config file, rotate keys and update ASAP.\n\nRead more:  https://www.qualys.com/2016/01/14/cve-2016-0777-cve-2016-0778/openssh-cve-2016-0777-cve-2016-0778.txt\n`, \"\\n\", \"\\n\\r\", -1))\n\ntype sessionInfo struct {\n\tUser string\n\tKeys []ssh.PublicKey\n}\n\ntype Server struct {\n\tgithubClient *github.Client\n\tsshConfig    *ssh.ServerConfig\n\tdb           *sqlitex.Pool\n\n\tmu          sync.RWMutex\n\tsessionInfo map[string]sessionInfo\n}\n\nfunc (s *Server) PublicKeyCallback(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {\n\ts.mu.Lock()\n\tsi := s.sessionInfo[string(conn.SessionID())]\n\tsi.User = conn.User()\n\tsi.Keys = append(si.Keys, key)\n\ts.sessionInfo[string(conn.SessionID())] = si\n\ts.mu.Unlock()\n\n\t// Never accept a key, or we might not see the next.\n\treturn nil, errors.New(\"\")\n}\n\nfunc (s *Server) KeyboardInteractiveCallback(ssh.ConnMetadata, ssh.KeyboardInteractiveChallenge) (*ssh.Permissions, error) {\n\t// keyboard-interactive is tried when all public keys failed, and\n\t// since it's server-driven we can just pass without user\n\t// interaction to let the user in once we got all the public keys.\n\treturn nil, nil\n}\n\ntype logEntry struct {\n\tTimestamp     string\n\tUsername      string   `json:\",omitempty\"`\n\tRequestTypes  []string `json:\",omitempty\"`\n\tError         string   `json:\",omitempty\"`\n\tKeysOffered   []string `json:\",omitempty\"`\n\tGitHubID      int64    `json:\",omitempty\"`\n\tGitHubName    string   `json:\",omitempty\"`\n\tClientVersion string   `json:\",omitempty\"`\n}\n\nfunc (s *Server) Handle(nConn net.Conn) {\n\tconn, chans, reqs, err := ssh.NewServerConn(nConn, s.sshConfig)\n\tif err != nil {\n\t\t// Port scan, health check, or dictionary attack.\n\t\thsErrs.Inc()\n\t\treturn\n\t}\n\tle := &logEntry{Timestamp: time.Now().Format(time.RFC3339)}\n\tdefer json.NewEncoder(os.Stdout).Encode(le)\n\tvar agentFwd, x11, roaming bool\n\tdefer func() {\n\t\tsshConns.With(prometheus.Labels{\n\t\t\t\"keyCount\":   fmt.Sprintf(\"%v\", len(le.KeysOffered)),\n\t\t\t\"error\":      fmt.Sprintf(\"%v\", le.Error != \"\"),\n\t\t\t\"identified\": fmt.Sprintf(\"%v\", le.GitHubID != 0),\n\t\t\t\"agent\":      fmt.Sprintf(\"%v\", agentFwd),\n\t\t\t\"x11\":        fmt.Sprintf(\"%v\", x11),\n\t\t\t\"roaming\":    fmt.Sprintf(\"%v\", roaming),\n\t\t}).Inc()\n\t\ts.mu.Lock()\n\t\tdelete(s.sessionInfo, string(conn.SessionID()))\n\t\ts.mu.Unlock()\n\t\ttime.Sleep(500 * time.Millisecond)\n\t\tconn.Close()\n\t}()\n\tgo func(in <-chan *ssh.Request) {\n\t\tfor req := range in {\n\t\t\tle.RequestTypes = append(le.RequestTypes, req.Type)\n\t\t\tif req.Type == \"roaming@appgate.com\" {\n\t\t\t\troaming = true\n\t\t\t}\n\t\t\tif req.WantReply {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t}\n\t\t}\n\t}(reqs)\n\n\ts.mu.RLock()\n\tsi := s.sessionInfo[string(conn.SessionID())]\n\ts.mu.RUnlock()\n\n\tle.Username = conn.User()\n\tle.ClientVersion = string(conn.ClientVersion())\n\tfor _, key := range si.Keys {\n\t\tle.KeysOffered = append(le.KeysOffered, string(ssh.MarshalAuthorizedKey(key)))\n\t}\n\n\tfor newChannel := range chans {\n\t\tif newChannel.ChannelType() != \"session\" {\n\t\t\tnewChannel.Reject(ssh.UnknownChannelType, \"unknown channel type\")\n\t\t\tcontinue\n\t\t}\n\t\tchannel, requests, err := newChannel.Accept()\n\t\tif err != nil {\n\t\t\tle.Error = \"Channel accept failed: \" + err.Error()\n\t\t\treturn\n\t\t}\n\t\tdefer channel.Close()\n\n\t\treqLock := &sync.Mutex{}\n\t\treqLock.Lock()\n\t\ttimeout := time.AfterFunc(30*time.Second, func() { reqLock.Unlock() })\n\n\t\tgo func(in <-chan *ssh.Request) {\n\t\t\tfor req := range in {\n\t\t\t\tle.RequestTypes = append(le.RequestTypes, req.Type)\n\t\t\t\tok := false\n\t\t\t\tswitch req.Type {\n\t\t\t\tcase \"shell\":\n\t\t\t\t\tfallthrough\n\t\t\t\tcase \"pty-req\":\n\t\t\t\t\tok = true\n\n\t\t\t\t\t// \"auth-agent-req@openssh.com\" and \"x11-req\" always arrive\n\t\t\t\t\t// before the \"pty-req\", so we can go ahead now\n\t\t\t\t\tif timeout.Stop() {\n\t\t\t\t\t\treqLock.Unlock()\n\t\t\t\t\t}\n\n\t\t\t\tcase \"auth-agent-req@openssh.com\":\n\t\t\t\t\tagentFwd = true\n\t\t\t\tcase \"x11-req\":\n\t\t\t\t\tx11 = true\n\t\t\t\t}\n\n\t\t\t\tif req.WantReply {\n\t\t\t\t\treq.Reply(ok, nil)\n\t\t\t\t}\n\t\t\t}\n\t\t}(requests)\n\n\t\treqLock.Lock()\n\t\tif agentFwd {\n\t\t\tchannel.Write(agentMsg)\n\t\t}\n\t\tif x11 {\n\t\t\tchannel.Write(x11Msg)\n\t\t}\n\t\tif roaming {\n\t\t\tchannel.Write(roamingMsg)\n\t\t}\n\n\t\tuserID, err := s.findUser(si.Keys)\n\t\tif err != nil {\n\t\t\tle.Error = \"findUser failed: \" + err.Error()\n\t\t\treturn\n\t\t}\n\n\t\tif userID == 0 {\n\t\t\tchannel.Write(failedMsg)\n\t\t\tfor _, key := range si.Keys {\n\t\t\t\tchannel.Write(ssh.MarshalAuthorizedKey(key))\n\t\t\t\tchannel.Write([]byte(\"\\r\"))\n\t\t\t}\n\t\t\tchannel.Write([]byte(\"\\n\\r\"))\n\t\t\treturn\n\t\t}\n\n\t\tle.GitHubID = userID\n\t\tu, _, err := s.githubClient.Users.GetByID(context.TODO(), userID)\n\t\tif err != nil {\n\t\t\tle.Error = \"getUserName failed: \" + err.Error()\n\t\t\treturn\n\t\t}\n\n\t\tlogin := *u.Login\n\t\tle.GitHubName = *u.Login\n\t\tname := \"@\" + login\n\t\tif u.Name != nil {\n\t\t\tname = *u.Name\n\t\t}\n\n\t\ttermTmpl.Execute(channel, struct{ Name, User string }{name, login})\n\t\treturn\n\t}\n}\n\nfunc (s *Server) findUser(keys []ssh.PublicKey) (int64, error) {\n\tconn := s.db.Get(context.TODO())\n\tif conn == nil {\n\t\treturn 0, errors.New(\"couldn't get db connection\")\n\t}\n\tdefer s.db.Put(conn)\n\tfor _, pk := range keys {\n\t\tkey := bytes.TrimSpace(ssh.MarshalAuthorizedKey(pk))\n\t\tkeyHash := sha256.Sum256(key)\n\t\tstmt := conn.Prep(\"SELECT userID FROM key_userid WHERE keyHash = $kh;\")\n\t\tstmt.SetBytes(\"$kh\", keyHash[:16])\n\t\tif hasRow, err := stmt.Step(); err != nil {\n\t\t\treturn 0, err\n\t\t} else if !hasRow {\n\t\t\tcontinue\n\t\t}\n\t\tdefer stmt.Reset()\n\t\treturn stmt.GetInt64(\"userID\"), nil\n\t}\n\n\treturn 0, nil\n}\n"
        }
      ]
    }
  ]
}