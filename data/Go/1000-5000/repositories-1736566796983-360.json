{
  "metadata": {
    "timestamp": 1736566796983,
    "page": 360,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-macaron/macaron",
      "stars": 3517,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.1337890625,
          "content": "# http://editorconfig.org\n\nroot = true\n\n[*]\ncharset = utf-8\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0546875,
          "content": "macaron.sublime-project\nmacaron.sublime-workspace\n.idea\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.3037109375,
          "content": "linters-settings:\n  nakedret:\n    max-func-lines: 0 # Disallow any unnamed return statement\n\nlinters:\n  enable:\n    - unused\n    - errcheck\n    - gosimple\n    - govet\n    - ineffassign\n    - staticcheck\n    - typecheck\n    - nakedret\n    - gofmt\n    - rowserrcheck\n    - unconvert\n    - goimports\n    - unparam\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.0244140625,
          "content": "Apache License\nVersion 2.0, January 2004\nhttp://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n\"License\" shall mean the terms and conditions for use, reproduction, and\ndistribution as defined by Sections 1 through 9 of this document.\n\n\"Licensor\" shall mean the copyright owner or entity authorized by the copyright\nowner that is granting the License.\n\n\"Legal Entity\" shall mean the union of the acting entity and all other entities\nthat control, are controlled by, or are under common control with that entity.\nFor the purposes of this definition, \"control\" means (i) the power, direct or\nindirect, to cause the direction or management of such entity, whether by\ncontract or otherwise, or (ii) ownership of fifty percent (50%) or more of the\noutstanding shares, or (iii) beneficial ownership of such entity.\n\n\"You\" (or \"Your\") shall mean an individual or Legal Entity exercising\npermissions granted by this License.\n\n\"Source\" form shall mean the preferred form for making modifications, including\nbut not limited to software source code, documentation source, and configuration\nfiles.\n\n\"Object\" form shall mean any form resulting from mechanical transformation or\ntranslation of a Source form, including but not limited to compiled object code,\ngenerated documentation, and conversions to other media types.\n\n\"Work\" shall mean the work of authorship, whether in Source or Object form, made\navailable under the License, as indicated by a copyright notice that is included\nin or attached to the work (an example is provided in the Appendix below).\n\n\"Derivative Works\" shall mean any work, whether in Source or Object form, that\nis based on (or derived from) the Work and for which the editorial revisions,\nannotations, elaborations, or other modifications represent, as a whole, an\noriginal work of authorship. For the purposes of this License, Derivative Works\nshall not include works that remain separable from, or merely link (or bind by\nname) to the interfaces of, the Work and Derivative Works thereof.\n\n\"Contribution\" shall mean any work of authorship, including the original version\nof the Work and any modifications or additions to that Work or Derivative Works\nthereof, that is intentionally submitted to Licensor for inclusion in the Work\nby the copyright owner or by an individual or Legal Entity authorized to submit\non behalf of the copyright owner. For the purposes of this definition,\n\"submitted\" means any form of electronic, verbal, or written communication sent\nto the Licensor or its representatives, including but not limited to\ncommunication on electronic mailing lists, source code control systems, and\nissue tracking systems that are managed by, or on behalf of, the Licensor for\nthe purpose of discussing and improving the Work, but excluding communication\nthat is conspicuously marked or otherwise designated in writing by the copyright\nowner as \"Not a Contribution.\"\n\n\"Contributor\" shall mean Licensor and any individual or Legal Entity on behalf\nof whom a Contribution has been received by Licensor and subsequently\nincorporated within the Work.\n\n2. Grant of Copyright License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable copyright license to reproduce, prepare Derivative Works of,\npublicly display, publicly perform, sublicense, and distribute the Work and such\nDerivative Works in Source or Object form.\n\n3. Grant of Patent License.\n\nSubject to the terms and conditions of this License, each Contributor hereby\ngrants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free,\nirrevocable (except as stated in this section) patent license to make, have\nmade, use, offer to sell, sell, import, and otherwise transfer the Work, where\nsuch license applies only to those patent claims licensable by such Contributor\nthat are necessarily infringed by their Contribution(s) alone or by combination\nof their Contribution(s) with the Work to which such Contribution(s) was\nsubmitted. If You institute patent litigation against any entity (including a\ncross-claim or counterclaim in a lawsuit) alleging that the Work or a\nContribution incorporated within the Work constitutes direct or contributory\npatent infringement, then any patent licenses granted to You under this License\nfor that Work shall terminate as of the date such litigation is filed.\n\n4. Redistribution.\n\nYou may reproduce and distribute copies of the Work or Derivative Works thereof\nin any medium, with or without modifications, and in Source or Object form,\nprovided that You meet the following conditions:\n\nYou must give any other recipients of the Work or Derivative Works a copy of\nthis License; and\nYou must cause any modified files to carry prominent notices stating that You\nchanged the files; and\nYou must retain, in the Source form of any Derivative Works that You distribute,\nall copyright, patent, trademark, and attribution notices from the Source form\nof the Work, excluding those notices that do not pertain to any part of the\nDerivative Works; and\nIf the Work includes a \"NOTICE\" text file as part of its distribution, then any\nDerivative Works that You distribute must include a readable copy of the\nattribution notices contained within such NOTICE file, excluding those notices\nthat do not pertain to any part of the Derivative Works, in at least one of the\nfollowing places: within a NOTICE text file distributed as part of the\nDerivative Works; within the Source form or documentation, if provided along\nwith the Derivative Works; or, within a display generated by the Derivative\nWorks, if and wherever such third-party notices normally appear. The contents of\nthe NOTICE file are for informational purposes only and do not modify the\nLicense. You may add Your own attribution notices within Derivative Works that\nYou distribute, alongside or as an addendum to the NOTICE text from the Work,\nprovided that such additional attribution notices cannot be construed as\nmodifying the License.\nYou may add Your own copyright statement to Your modifications and may provide\nadditional or different license terms and conditions for use, reproduction, or\ndistribution of Your modifications, or for any such Derivative Works as a whole,\nprovided Your use, reproduction, and distribution of the Work otherwise complies\nwith the conditions stated in this License.\n\n5. Submission of Contributions.\n\nUnless You explicitly state otherwise, any Contribution intentionally submitted\nfor inclusion in the Work by You to the Licensor shall be under the terms and\nconditions of this License, without any additional terms or conditions.\nNotwithstanding the above, nothing herein shall supersede or modify the terms of\nany separate license agreement you may have executed with Licensor regarding\nsuch Contributions.\n\n6. Trademarks.\n\nThis License does not grant permission to use the trade names, trademarks,\nservice marks, or product names of the Licensor, except as required for\nreasonable and customary use in describing the origin of the Work and\nreproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty.\n\nUnless required by applicable law or agreed to in writing, Licensor provides the\nWork (and each Contributor provides its Contributions) on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied,\nincluding, without limitation, any warranties or conditions of TITLE,\nNON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. You are\nsolely responsible for determining the appropriateness of using or\nredistributing the Work and assume any risks associated with Your exercise of\npermissions under this License.\n\n8. Limitation of Liability.\n\nIn no event and under no legal theory, whether in tort (including negligence),\ncontract, or otherwise, unless required by applicable law (such as deliberate\nand grossly negligent acts) or agreed to in writing, shall any Contributor be\nliable to You for damages, including any direct, indirect, special, incidental,\nor consequential damages of any character arising as a result of this License or\nout of the use or inability to use the Work (including but not limited to\ndamages for loss of goodwill, work stoppage, computer failure or malfunction, or\nany and all other commercial damages or losses), even if such Contributor has\nbeen advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability.\n\nWhile redistributing the Work or Derivative Works thereof, You may choose to\noffer, and charge a fee for, acceptance of support, warranty, indemnity, or\nother liability obligations and/or rights consistent with this License. However,\nin accepting such obligations, You may act only on Your own behalf and on Your\nsole responsibility, not on behalf of any other Contributor, and only if You\nagree to indemnify, defend, and hold each Contributor harmless for any liability\nincurred by, or claims asserted against, such Contributor by reason of your\naccepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n\nAPPENDIX: How to apply the Apache License to your work\n\nTo apply the Apache License to your work, attach the following boilerplate\nnotice, with the fields enclosed by brackets \"[]\" replaced with your own\nidentifying information. (Don't include the brackets!) The text should be\nenclosed in the appropriate comment syntax for the file format. We also\nrecommend that a file or class name and description of purpose be included on\nthe same \"printed page\" as the copyright notice for easier identification within\nthird-party archives.\n\n   Copyright 2014 The Macaron Authors\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.59765625,
          "content": "# Macaron\n\n[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/go-macaron/macaron/Go?logo=github&style=for-the-badge)](https://github.com/go-macaron/macaron/actions?query=workflow%3AGo)\n[![codecov](https://img.shields.io/codecov/c/github/go-macaron/macaron/master?logo=codecov&style=for-the-badge)](https://codecov.io/gh/go-macaron/macaron)\n[![GoDoc](https://img.shields.io/badge/GoDoc-Reference-blue?style=for-the-badge&logo=go)](https://pkg.go.dev/gopkg.in/macaron.v1?tab=doc)\n[![Sourcegraph](https://img.shields.io/badge/view%20on-Sourcegraph-brightgreen.svg?style=for-the-badge&logo=sourcegraph)](https://sourcegraph.com/github.com/go-macaron/macaron)\n\n![Macaron Logo](https://raw.githubusercontent.com/go-macaron/macaron/v1/macaronlogo.png)\n\nPackage macaron is a high productive and modular web framework in Go.\n\n## ðŸ“£ Announcement\n\n- If you're considering using Macaron, you may want to take a look at [Flamego](https://flamego.dev/) first, which is [the successor of the Macaron](https://flamego.dev/faqs.html#what-is-the-idea-behind-this-other-than-macaron-martini).\n- That means Macaron is officially in the maintenance mode, and no major features will be added to Macaron.\n\n## Getting Started\n\nThe minimum requirement of Go is **1.18**.\n\nTo install Macaron:\n\n\tgo get gopkg.in/macaron.v1\n\nThe very basic usage of Macaron:\n\n```go\npackage main\n\nimport \"gopkg.in/macaron.v1\"\n\nfunc main() {\n\tm := macaron.Classic()\n\tm.Get(\"/\", func() string {\n\t\treturn \"Hello world!\"\n\t})\n\tm.Run()\n}\n```\n\n## Features\n\n- Powerful routing with suburl.\n- Flexible routes combinations.\n- Unlimited nested group routers.\n- Directly integrate with existing services.\n- Dynamically change template files at runtime.\n- Allow to use in-memory template and static files.\n- Easy to plugin/unplugin features with modular design.\n- Handy dependency injection powered by [inject](https://github.com/codegangsta/inject).\n- Better router layer and less reflection make faster speed.\n\n## Middlewares\n\nMiddlewares allow you easily plugin/unplugin features for your Macaron applications.\n\nThere are already many [middlewares](https://github.com/go-macaron) to simplify your work:\n\n- render - Go template engine\n- static - Serves static files\n- [gzip](https://github.com/go-macaron/gzip) - Gzip compression to all responses\n- [binding](https://github.com/go-macaron/binding) - Request data binding and validation\n- [i18n](https://github.com/go-macaron/i18n) - Internationalization and Localization\n- [cache](https://github.com/go-macaron/cache) - Cache manager\n- [session](https://github.com/go-macaron/session) - Session manager\n- [csrf](https://github.com/go-macaron/csrf) - Generates and validates csrf tokens\n- [captcha](https://github.com/go-macaron/captcha) - Captcha service\n- [pongo2](https://github.com/go-macaron/pongo2) - Pongo2 template engine support\n- [sockets](https://github.com/go-macaron/sockets) - WebSockets channels binding\n- [bindata](https://github.com/go-macaron/bindata) - Embed binary data as static and template files\n- [toolbox](https://github.com/go-macaron/toolbox) - Health check, pprof, profile and statistic services\n- [oauth2](https://github.com/go-macaron/oauth2) - OAuth 2.0 backend\n- [authz](https://github.com/go-macaron/authz) - ACL/RBAC/ABAC authorization based on Casbin\n- [switcher](https://github.com/go-macaron/switcher) - Multiple-site support\n- [method](https://github.com/go-macaron/method) - HTTP method override\n- [permissions2](https://github.com/xyproto/permissions2) - Cookies, users and permissions\n- [renders](https://github.com/go-macaron/renders) - Beego-like render engine(Macaron has built-in template engine, this is another option)\n- [piwik](https://github.com/veecue/piwik-middleware) - Server-side piwik analytics\n\n## Use Cases\n\n- [Gogs](https://gogs.io): A painless self-hosted Git Service\n- [Grafana](http://grafana.org/): The open platform for beautiful analytics and monitoring\n- [Peach](https://peachdocs.org): A modern web documentation server\n- [Go Walker](https://gowalker.org): Go online API documentation\n- [Critical Stack Intel](https://intel.criticalstack.com/): A 100% free intel marketplace from Critical Stack, Inc.\n\n## Getting Help\n\n- [API Reference](https://gowalker.org/gopkg.in/macaron.v1)\n- [Documentation](https://go-macaron.com)\n- [FAQs](https://go-macaron.com/docs/faqs)\n\n## Credits\n\n- Basic design of [Martini](https://github.com/go-martini/martini).\n- Logo is modified by [@insionng](https://github.com/insionng) based on [Tribal Dragon](http://xtremeyamazaki.deviantart.com/art/Tribal-Dragon-27005087).\n\n## License\n\nThis project is under the Apache License, Version 2.0. See the [LICENSE](LICENSE) file for the full license text.\n"
        },
        {
          "name": "codecov.yml",
          "type": "blob",
          "size": 0.1201171875,
          "content": "coverage:\n  range: \"60...95\"\n  status:\n    project:\n      default:\n        threshold: 1%\n\ncomment:\n  layout: 'diff, files'\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 14.431640625,
          "content": "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"html/template\"\n\t\"io\"\n\t\"mime/multipart\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/go-macaron/inject\"\n\t\"github.com/unknwon/com\"\n\t\"golang.org/x/crypto/pbkdf2\"\n)\n\n// Locale reprents a localization interface.\ntype Locale interface {\n\tLanguage() string\n\tTr(string, ...interface{}) string\n}\n\n// RequestBody represents a request body.\ntype RequestBody struct {\n\treader io.ReadCloser\n}\n\n// Bytes reads and returns content of request body in bytes.\nfunc (rb *RequestBody) Bytes() ([]byte, error) {\n\treturn io.ReadAll(rb.reader)\n}\n\n// String reads and returns content of request body in string.\nfunc (rb *RequestBody) String() (string, error) {\n\tdata, err := rb.Bytes()\n\treturn string(data), err\n}\n\n// ReadCloser returns a ReadCloser for request body.\nfunc (rb *RequestBody) ReadCloser() io.ReadCloser {\n\treturn rb.reader\n}\n\n// Request represents an HTTP request received by a server or to be sent by a client.\ntype Request struct {\n\t*http.Request\n}\n\n// Body returns a RequestBody for the request\nfunc (r *Request) Body() *RequestBody {\n\treturn &RequestBody{r.Request.Body}\n}\n\n// ContextInvoker is an inject.FastInvoker wrapper of func(ctx *Context).\ntype ContextInvoker func(ctx *Context)\n\n// Invoke implements inject.FastInvoker which simplifies calls of `func(ctx *Context)` function.\nfunc (invoke ContextInvoker) Invoke(params []interface{}) ([]reflect.Value, error) {\n\tinvoke(params[0].(*Context))\n\treturn nil, nil\n}\n\n// Context represents the runtime context of current request of Macaron instance.\n// It is the integration of most frequently used middlewares and helper methods.\ntype Context struct {\n\tinject.Injector\n\thandlers []Handler\n\taction   Handler\n\tindex    int\n\n\t*Router\n\tReq    Request\n\tResp   ResponseWriter\n\tparams Params\n\tRender\n\tLocale\n\tData map[string]interface{}\n}\n\nfunc (ctx *Context) handler() Handler {\n\tif ctx.index < len(ctx.handlers) {\n\t\treturn ctx.handlers[ctx.index]\n\t}\n\tif ctx.index == len(ctx.handlers) {\n\t\treturn ctx.action\n\t}\n\tpanic(\"invalid index for context handler\")\n}\n\n// Next runs the next handler in the context chain\nfunc (ctx *Context) Next() {\n\tctx.index++\n\tctx.run()\n}\n\n// Written returns whether the context response has been written to\nfunc (ctx *Context) Written() bool {\n\treturn ctx.Resp.Written()\n}\n\nfunc (ctx *Context) run() {\n\tfor ctx.index <= len(ctx.handlers) {\n\t\tvals, err := ctx.Invoke(ctx.handler())\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tctx.index++\n\n\t\t// if the handler returned something, write it to the http response\n\t\tif len(vals) > 0 {\n\t\t\tev := ctx.GetVal(reflect.TypeOf(ReturnHandler(nil)))\n\t\t\thandleReturn := ev.Interface().(ReturnHandler)\n\t\t\thandleReturn(ctx, vals)\n\t\t}\n\n\t\tif ctx.Written() {\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// RemoteAddr returns more real IP address.\nfunc (ctx *Context) RemoteAddr() string {\n\taddr := ctx.Req.Header.Get(\"X-Real-IP\")\n\tif len(addr) == 0 {\n\t\taddr = ctx.Req.Header.Get(\"X-Forwarded-For\")\n\t\tif addr == \"\" {\n\t\t\taddr = ctx.Req.RemoteAddr\n\t\t\tif i := strings.LastIndex(addr, \":\"); i > -1 {\n\t\t\t\taddr = addr[:i]\n\t\t\t}\n\t\t}\n\t}\n\treturn addr\n}\n\nfunc (ctx *Context) renderHTML(status int, setName, tplName string, data ...interface{}) {\n\tif len(data) <= 0 {\n\t\tctx.Render.HTMLSet(status, setName, tplName, ctx.Data)\n\t} else if len(data) == 1 {\n\t\tctx.Render.HTMLSet(status, setName, tplName, data[0])\n\t} else {\n\t\tctx.Render.HTMLSet(status, setName, tplName, data[0], data[1].(HTMLOptions))\n\t}\n}\n\n// HTML renders the HTML with default template set.\nfunc (ctx *Context) HTML(status int, name string, data ...interface{}) {\n\tctx.renderHTML(status, DEFAULT_TPL_SET_NAME, name, data...)\n}\n\n// HTMLSet renders the HTML with given template set name.\nfunc (ctx *Context) HTMLSet(status int, setName, tplName string, data ...interface{}) {\n\tctx.renderHTML(status, setName, tplName, data...)\n}\n\n// Redirect sends a redirect response\nfunc (ctx *Context) Redirect(location string, status ...int) {\n\tcode := http.StatusFound\n\tif len(status) == 1 {\n\t\tcode = status[0]\n\t}\n\n\thttp.Redirect(ctx.Resp, ctx.Req.Request, location, code)\n}\n\n// MaxMemory is the maximum amount of memory to use when parsing a multipart form.\n// Set this to whatever value you prefer; default is 10 MB.\nvar MaxMemory = int64(1024 * 1024 * 10)\n\nfunc (ctx *Context) parseForm() {\n\tif ctx.Req.Form != nil {\n\t\treturn\n\t}\n\n\tcontentType := ctx.Req.Header.Get(_CONTENT_TYPE)\n\tif (ctx.Req.Method == \"POST\" || ctx.Req.Method == \"PUT\") &&\n\t\tlen(contentType) > 0 && strings.Contains(contentType, \"multipart/form-data\") {\n\t\t_ = ctx.Req.ParseMultipartForm(MaxMemory)\n\t} else {\n\t\t_ = ctx.Req.ParseForm()\n\t}\n}\n\n// Query querys form parameter.\nfunc (ctx *Context) Query(name string) string {\n\tctx.parseForm()\n\treturn ctx.Req.Form.Get(name)\n}\n\n// QueryTrim querys and trims spaces form parameter.\nfunc (ctx *Context) QueryTrim(name string) string {\n\treturn strings.TrimSpace(ctx.Query(name))\n}\n\n// QueryStrings returns a list of results by given query name.\nfunc (ctx *Context) QueryStrings(name string) []string {\n\tctx.parseForm()\n\n\tvals, ok := ctx.Req.Form[name]\n\tif !ok {\n\t\treturn []string{}\n\t}\n\treturn vals\n}\n\n// QueryEscape returns escapred query result.\nfunc (ctx *Context) QueryEscape(name string) string {\n\treturn template.HTMLEscapeString(ctx.Query(name))\n}\n\n// QueryBool returns query result in bool type.\nfunc (ctx *Context) QueryBool(name string) bool {\n\tv, _ := strconv.ParseBool(ctx.Query(name))\n\treturn v\n}\n\n// QueryInt returns query result in int type.\nfunc (ctx *Context) QueryInt(name string) int {\n\treturn com.StrTo(ctx.Query(name)).MustInt()\n}\n\n// QueryInt64 returns query result in int64 type.\nfunc (ctx *Context) QueryInt64(name string) int64 {\n\treturn com.StrTo(ctx.Query(name)).MustInt64()\n}\n\n// QueryFloat64 returns query result in float64 type.\nfunc (ctx *Context) QueryFloat64(name string) float64 {\n\tv, _ := strconv.ParseFloat(ctx.Query(name), 64)\n\treturn v\n}\n\n// Params returns value of given param name.\n// e.g. ctx.Params(\":uid\") or ctx.Params(\"uid\")\nfunc (ctx *Context) Params(name string) string {\n\tif len(name) == 0 {\n\t\treturn \"\"\n\t}\n\tif len(name) > 1 && name[0] != ':' {\n\t\tname = \":\" + name\n\t}\n\treturn ctx.params[name]\n}\n\n// AllParams returns all params.\nfunc (ctx *Context) AllParams() Params {\n\treturn ctx.params\n}\n\n// SetParams sets value of param with given name.\nfunc (ctx *Context) SetParams(name, val string) {\n\tif name != \"*\" && !strings.HasPrefix(name, \":\") {\n\t\tname = \":\" + name\n\t}\n\tctx.params[name] = val\n}\n\n// ReplaceAllParams replace all current params with given params\nfunc (ctx *Context) ReplaceAllParams(params Params) {\n\tctx.params = params\n}\n\n// ParamsEscape returns escapred params result.\n// e.g. ctx.ParamsEscape(\":uname\")\nfunc (ctx *Context) ParamsEscape(name string) string {\n\treturn template.HTMLEscapeString(ctx.Params(name))\n}\n\n// ParamsInt returns params result in int type.\n// e.g. ctx.ParamsInt(\":uid\")\nfunc (ctx *Context) ParamsInt(name string) int {\n\treturn com.StrTo(ctx.Params(name)).MustInt()\n}\n\n// ParamsInt64 returns params result in int64 type.\n// e.g. ctx.ParamsInt64(\":uid\")\nfunc (ctx *Context) ParamsInt64(name string) int64 {\n\treturn com.StrTo(ctx.Params(name)).MustInt64()\n}\n\n// ParamsFloat64 returns params result in int64 type.\n// e.g. ctx.ParamsFloat64(\":uid\")\nfunc (ctx *Context) ParamsFloat64(name string) float64 {\n\tv, _ := strconv.ParseFloat(ctx.Params(name), 64)\n\treturn v\n}\n\n// GetFile returns information about user upload file by given form field name.\nfunc (ctx *Context) GetFile(name string) (multipart.File, *multipart.FileHeader, error) {\n\treturn ctx.Req.FormFile(name)\n}\n\n// SaveToFile reads a file from request by field name and saves to given path.\nfunc (ctx *Context) SaveToFile(name, savePath string) error {\n\tfr, _, err := ctx.GetFile(name)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fr.Close()\n\n\tfw, err := os.OpenFile(savePath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer fw.Close()\n\n\t_, err = io.Copy(fw, fr)\n\treturn err\n}\n\n// SetCookie sets given cookie value to response header.\n// FIXME: IE support? http://golanghome.com/post/620#reply2\nfunc (ctx *Context) SetCookie(name string, value string, others ...interface{}) {\n\tcookie := http.Cookie{}\n\tcookie.Name = name\n\tcookie.Value = url.QueryEscape(value)\n\n\tif len(others) > 0 {\n\t\tswitch v := others[0].(type) {\n\t\tcase int:\n\t\t\tcookie.MaxAge = v\n\t\tcase int64:\n\t\t\tcookie.MaxAge = int(v)\n\t\tcase int32:\n\t\t\tcookie.MaxAge = int(v)\n\t\tcase func(*http.Cookie):\n\t\t\tv(&cookie)\n\t\t}\n\t}\n\n\tcookie.Path = \"/\"\n\tif len(others) > 1 {\n\t\tif v, ok := others[1].(string); ok && len(v) > 0 {\n\t\t\tcookie.Path = v\n\t\t} else if v, ok := others[1].(func(*http.Cookie)); ok {\n\t\t\tv(&cookie)\n\t\t}\n\t}\n\n\tif len(others) > 2 {\n\t\tif v, ok := others[2].(string); ok && len(v) > 0 {\n\t\t\tcookie.Domain = v\n\t\t} else if v, ok := others[1].(func(*http.Cookie)); ok {\n\t\t\tv(&cookie)\n\t\t}\n\t}\n\n\tif len(others) > 3 {\n\t\tswitch v := others[3].(type) {\n\t\tcase bool:\n\t\t\tcookie.Secure = v\n\t\tcase func(*http.Cookie):\n\t\t\tv(&cookie)\n\t\tdefault:\n\t\t\tif others[3] != nil {\n\t\t\t\tcookie.Secure = true\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(others) > 4 {\n\t\tif v, ok := others[4].(bool); ok && v {\n\t\t\tcookie.HttpOnly = true\n\t\t} else if v, ok := others[1].(func(*http.Cookie)); ok {\n\t\t\tv(&cookie)\n\t\t}\n\t}\n\n\tif len(others) > 5 {\n\t\tif v, ok := others[5].(time.Time); ok {\n\t\t\tcookie.Expires = v\n\t\t\tcookie.RawExpires = v.Format(time.UnixDate)\n\t\t} else if v, ok := others[1].(func(*http.Cookie)); ok {\n\t\t\tv(&cookie)\n\t\t}\n\t}\n\n\tif len(others) > 6 {\n\t\tfor _, other := range others[6:] {\n\t\t\tif v, ok := other.(func(*http.Cookie)); ok {\n\t\t\t\tv(&cookie)\n\t\t\t}\n\t\t}\n\t}\n\n\tctx.Resp.Header().Add(\"Set-Cookie\", cookie.String())\n}\n\n// GetCookie returns given cookie value from request header.\nfunc (ctx *Context) GetCookie(name string) string {\n\tcookie, err := ctx.Req.Cookie(name)\n\tif err != nil {\n\t\treturn \"\"\n\t}\n\tval, _ := url.QueryUnescape(cookie.Value)\n\treturn val\n}\n\n// GetCookieInt returns cookie result in int type.\nfunc (ctx *Context) GetCookieInt(name string) int {\n\treturn com.StrTo(ctx.GetCookie(name)).MustInt()\n}\n\n// GetCookieInt64 returns cookie result in int64 type.\nfunc (ctx *Context) GetCookieInt64(name string) int64 {\n\treturn com.StrTo(ctx.GetCookie(name)).MustInt64()\n}\n\n// GetCookieFloat64 returns cookie result in float64 type.\nfunc (ctx *Context) GetCookieFloat64(name string) float64 {\n\tv, _ := strconv.ParseFloat(ctx.GetCookie(name), 64)\n\treturn v\n}\n\nvar defaultCookieSecret string\n\n// SetDefaultCookieSecret sets global default secure cookie secret.\nfunc (m *Macaron) SetDefaultCookieSecret(secret string) {\n\tdefaultCookieSecret = secret\n}\n\n// SetSecureCookie sets given cookie value to response header with default secret string.\nfunc (ctx *Context) SetSecureCookie(name, value string, others ...interface{}) {\n\tctx.SetSuperSecureCookie(defaultCookieSecret, name, value, others...)\n}\n\n// GetSecureCookie returns given cookie value from request header with default secret string.\nfunc (ctx *Context) GetSecureCookie(key string) (string, bool) {\n\treturn ctx.GetSuperSecureCookie(defaultCookieSecret, key)\n}\n\n// SetSuperSecureCookie sets given cookie value to response header with secret string.\nfunc (ctx *Context) SetSuperSecureCookie(secret, name, value string, others ...interface{}) {\n\tkey := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)\n\ttext, err := com.AESGCMEncrypt(key, []byte(value))\n\tif err != nil {\n\t\tpanic(\"error encrypting cookie: \" + err.Error())\n\t}\n\n\tctx.SetCookie(name, hex.EncodeToString(text), others...)\n}\n\n// GetSuperSecureCookie returns given cookie value from request header with secret string.\nfunc (ctx *Context) GetSuperSecureCookie(secret, name string) (string, bool) {\n\tval := ctx.GetCookie(name)\n\tif val == \"\" {\n\t\treturn \"\", false\n\t}\n\n\ttext, err := hex.DecodeString(val)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\tkey := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)\n\ttext, err = com.AESGCMDecrypt(key, text)\n\treturn string(text), err == nil\n}\n\nfunc (ctx *Context) setRawContentHeader() {\n\tctx.Resp.Header().Set(\"Content-Description\", \"Raw content\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"text/plain\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n}\n\n// ServeContent serves given content to response.\nfunc (ctx *Context) ServeContent(name string, r io.ReadSeeker, params ...interface{}) {\n\tmodtime := time.Now()\n\tfor _, p := range params {\n\t\tswitch v := p.(type) {\n\t\tcase time.Time:\n\t\t\tmodtime = v\n\t\t}\n\t}\n\n\tctx.setRawContentHeader()\n\thttp.ServeContent(ctx.Resp, ctx.Req.Request, name, modtime, r)\n}\n\n// ServeFileContent serves given file as content to response.\nfunc (ctx *Context) ServeFileContent(file string, names ...string) {\n\tvar name string\n\tif len(names) > 0 {\n\t\tname = names[0]\n\t} else {\n\t\tname = path.Base(file)\n\t}\n\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\tif Env == PROD {\n\t\t\thttp.Error(ctx.Resp, \"Internal Server Error\", 500)\n\t\t} else {\n\t\t\thttp.Error(ctx.Resp, err.Error(), 500)\n\t\t}\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\tctx.setRawContentHeader()\n\thttp.ServeContent(ctx.Resp, ctx.Req.Request, name, time.Now(), f)\n}\n\n// ServeFile serves given file to response.\nfunc (ctx *Context) ServeFile(file string, names ...string) {\n\tvar name string\n\tif len(names) > 0 {\n\t\tname = names[0]\n\t} else {\n\t\tname = path.Base(file)\n\t}\n\tctx.Resp.Header().Set(\"Content-Description\", \"File Transfer\")\n\tctx.Resp.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\tctx.Resp.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+name)\n\tctx.Resp.Header().Set(\"Content-Transfer-Encoding\", \"binary\")\n\tctx.Resp.Header().Set(\"Expires\", \"0\")\n\tctx.Resp.Header().Set(\"Cache-Control\", \"must-revalidate\")\n\tctx.Resp.Header().Set(\"Pragma\", \"public\")\n\thttp.ServeFile(ctx.Resp, ctx.Req.Request, file)\n}\n\n// ChangeStaticPath changes static path from old to new one.\nfunc (ctx *Context) ChangeStaticPath(oldPath, newPath string) {\n\tif !filepath.IsAbs(oldPath) {\n\t\toldPath = filepath.Join(Root, oldPath)\n\t}\n\tdir := statics.Get(oldPath)\n\tif dir != nil {\n\t\tstatics.Delete(oldPath)\n\n\t\tif !filepath.IsAbs(newPath) {\n\t\t\tnewPath = filepath.Join(Root, newPath)\n\t\t}\n\t\t*dir = http.Dir(newPath)\n\t\tstatics.Set(dir)\n\t}\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 12.341796875,
          "content": "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"net/url\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/unknwon/com\"\n\t\"gopkg.in/macaron.v1/cookie\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_Context(t *testing.T) {\n\tConvey(\"Do advanced encapsulation operations\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderers(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}, \"fixtures/basic2\"))\n\n\t\tConvey(\"Get request body\", func() {\n\t\t\tm.Get(\"/body1\", func(ctx *Context) {\n\t\t\t\tdata, err := io.ReadAll(ctx.Req.Body().ReadCloser())\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tSo(string(data), ShouldEqual, \"This is my request body\")\n\t\t\t})\n\t\t\tm.Get(\"/body2\", func(ctx *Context) {\n\t\t\t\tdata, err := ctx.Req.Body().Bytes()\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tSo(string(data), ShouldEqual, \"This is my request body\")\n\t\t\t})\n\t\t\tm.Get(\"/body3\", func(ctx *Context) {\n\t\t\t\tdata, err := ctx.Req.Body().String()\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tSo(data, ShouldEqual, \"This is my request body\")\n\t\t\t})\n\t\t\tm.Get(\"/body4\", ContextInvoker(func(ctx *Context) {\n\t\t\t\tdata, err := ctx.Req.Body().String()\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tSo(data, ShouldEqual, \"This is my request body\")\n\t\t\t}))\n\n\t\t\tfor i := 1; i <= 4; i++ {\n\t\t\t\tresp := httptest.NewRecorder()\n\t\t\t\treq, err := http.NewRequest(\"GET\", \"/body\"+com.ToStr(i), nil)\n\t\t\t\treq.Body = io.NopCloser(bytes.NewBufferString(\"This is my request body\"))\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tm.ServeHTTP(resp, req)\n\t\t\t}\n\t\t})\n\n\t\tConvey(\"Get remote IP address\", func() {\n\t\t\tm.Get(\"/remoteaddr\", func(ctx *Context) string {\n\t\t\t\treturn ctx.RemoteAddr()\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/remoteaddr\", nil)\n\t\t\treq.RemoteAddr = \"127.0.0.1:3333\"\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"127.0.0.1\")\n\t\t})\n\n\t\tConvey(\"Render HTML\", func() {\n\n\t\t\tConvey(\"Normal HTML\", func() {\n\t\t\t\tm.Get(\"/html\", func(ctx *Context) {\n\t\t\t\t\tctx.HTML(304, \"hello\", \"Unknwon\") // 304 for logger test.\n\t\t\t\t})\n\n\t\t\t\tresp := httptest.NewRecorder()\n\t\t\t\treq, err := http.NewRequest(\"GET\", \"/html\", nil)\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tm.ServeHTTP(resp, req)\n\t\t\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Hello Unknwon</h1>\")\n\t\t\t})\n\n\t\t\tConvey(\"HTML template set\", func() {\n\t\t\t\tm.Get(\"/html2\", func(ctx *Context) {\n\t\t\t\t\tctx.Data[\"Name\"] = \"Unknwon\"\n\t\t\t\t\tctx.HTMLSet(200, \"basic2\", \"hello2\")\n\t\t\t\t})\n\n\t\t\t\tresp := httptest.NewRecorder()\n\t\t\t\treq, err := http.NewRequest(\"GET\", \"/html2\", nil)\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tm.ServeHTTP(resp, req)\n\t\t\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Hello Unknwon</h1>\")\n\t\t\t})\n\n\t\t\tConvey(\"With layout\", func() {\n\t\t\t\tm.Get(\"/layout\", func(ctx *Context) {\n\t\t\t\t\tctx.HTML(200, \"hello\", \"Unknwon\", HTMLOptions{\"layout\"})\n\t\t\t\t})\n\n\t\t\t\tresp := httptest.NewRecorder()\n\t\t\t\treq, err := http.NewRequest(\"GET\", \"/layout\", nil)\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tm.ServeHTTP(resp, req)\n\t\t\t\tSo(resp.Body.String(), ShouldEqual, \"head<h1>Hello Unknwon</h1>foot\")\n\t\t\t})\n\t\t})\n\n\t\tConvey(\"Parse from and query\", func() {\n\t\t\tm.Get(\"/query\", func(ctx *Context) string {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tbuf.WriteString(ctx.QueryTrim(\"name\") + \" \")\n\t\t\t\tbuf.WriteString(ctx.QueryEscape(\"name\") + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.QueryBool(\"bool\")) + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.QueryInt(\"int\")) + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.QueryInt64(\"int64\")) + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.QueryFloat64(\"float64\")) + \" \")\n\t\t\t\treturn buf.String()\n\t\t\t})\n\t\t\tm.Get(\"/query2\", func(ctx *Context) string {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tbuf.WriteString(strings.Join(ctx.QueryStrings(\"list\"), \",\") + \" \")\n\t\t\t\tbuf.WriteString(strings.Join(ctx.QueryStrings(\"404\"), \",\") + \" \")\n\t\t\t\treturn buf.String()\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/query?name=Unknwon&bool=t&int=12&int64=123&float64=1.25\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"Unknwon Unknwon true 12 123 1.25 \")\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/query2?list=item1&list=item2\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"item1,item2  \")\n\t\t})\n\n\t\tConvey(\"URL parameter\", func() {\n\t\t\tm.Get(\"/:name/:int/:int64/:float64\", func(ctx *Context) string {\n\t\t\t\tvar buf bytes.Buffer\n\t\t\t\tctx.SetParams(\"name\", ctx.Params(\"name\"))\n\t\t\t\tbuf.WriteString(ctx.Params(\"\"))\n\t\t\t\tbuf.WriteString(ctx.Params(\":name\") + \" \")\n\t\t\t\tbuf.WriteString(ctx.ParamsEscape(\":name\") + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.ParamsInt(\":int\")) + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.ParamsInt64(\":int64\")) + \" \")\n\t\t\t\tbuf.WriteString(com.ToStr(ctx.ParamsFloat64(\":float64\")) + \" \")\n\t\t\t\treturn buf.String()\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/user/1/13/1.24\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"user user 1 13 1.24 \")\n\t\t})\n\n\t\tConvey(\"Get all URL paramaters\", func() {\n\t\t\tm.Get(\"/:arg/:param/:flag\", func(ctx *Context) string {\n\t\t\t\tkvs := make([]string, 0, len(ctx.AllParams()))\n\t\t\t\tfor k, v := range ctx.AllParams() {\n\t\t\t\t\tkvs = append(kvs, k+\"=\"+v)\n\t\t\t\t}\n\t\t\t\tsort.Strings(kvs)\n\t\t\t\treturn strings.Join(kvs, \",\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/1/2/3\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \":arg=1,:flag=3,:param=2\")\n\t\t})\n\n\t\tConvey(\"Get file\", func() {\n\t\t\tm.Post(\"/getfile\", func(ctx *Context) {\n\t\t\t\tctx.Query(\"\")\n\t\t\t\t_, _, _ = ctx.GetFile(\"hi\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"POST\", \"/getfile\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\treq.Header.Set(\"Content-Type\", \"multipart/form-data\")\n\t\t\tm.ServeHTTP(resp, req)\n\t\t})\n\n\t\tConvey(\"Set and get cookie\", func() {\n\t\t\tm.Get(\"/set\", func(ctx *Context) {\n\t\t\t\tt, err := time.Parse(time.RFC1123, \"Sun, 13 Mar 2016 01:29:26 UTC\")\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tctx.SetCookie(\"user\", \"Unknwon\", 1, \"/\", \"localhost\", true, true, t)\n\t\t\t\tctx.SetCookie(\"user\", \"Unknwon\", int32(1), \"/\", \"localhost\", 1)\n\t\t\t\tcalled := false\n\t\t\t\tctx.SetCookie(\"user\", \"Unknwon\", int64(1), func(c *http.Cookie) {\n\t\t\t\t\tcalled = true\n\t\t\t\t})\n\t\t\t\tSo(called, ShouldBeTrue)\n\t\t\t\tctx.SetCookie(\"user\", \"Unknown\",\n\t\t\t\t\tcookie.Secure(true),\n\t\t\t\t\tcookie.HttpOnly(true),\n\t\t\t\t\tcookie.Path(\"/\"),\n\t\t\t\t\tcookie.MaxAge(1),\n\t\t\t\t\tcookie.Domain(\"localhost\"),\n\t\t\t\t)\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/set\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Header().Get(\"Set-Cookie\"), ShouldEqual, \"user=Unknwon; Path=/; Domain=localhost; Expires=Sun, 13 Mar 2016 01:29:26 GMT; Max-Age=1; HttpOnly; Secure\")\n\n\t\t\tm.Get(\"/get\", func(ctx *Context) string {\n\t\t\t\tctx.GetCookie(\"404\")\n\t\t\t\tSo(ctx.GetCookieInt(\"uid\"), ShouldEqual, 1)\n\t\t\t\tSo(ctx.GetCookieInt64(\"uid\"), ShouldEqual, 1)\n\t\t\t\tSo(ctx.GetCookieFloat64(\"balance\"), ShouldEqual, 1.25)\n\t\t\t\treturn ctx.GetCookie(\"user\")\n\t\t\t})\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/get\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\treq.Header.Set(\"Cookie\", \"user=Unknwon; uid=1; balance=1.25\")\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"Unknwon\")\n\t\t})\n\n\t\tConvey(\"Set and get secure cookie\", func() {\n\t\t\tm.SetDefaultCookieSecret(\"macaron\")\n\t\t\tm.Get(\"/set\", func(ctx *Context) {\n\t\t\t\tctx.SetSecureCookie(\"user\", \"Unknwon\", 1)\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/set\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tcookie := resp.Header().Get(\"Set-Cookie\")\n\n\t\t\tm.Get(\"/get\", func(ctx *Context) string {\n\t\t\t\tname, ok := ctx.GetSecureCookie(\"user\")\n\t\t\t\tSo(ok, ShouldBeTrue)\n\t\t\t\treturn name\n\t\t\t})\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/get\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\treq.Header.Set(\"Cookie\", cookie)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"Unknwon\")\n\t\t})\n\n\t\tConvey(\"Serve files\", func() {\n\t\t\tm.Get(\"/file\", func(ctx *Context) {\n\t\t\t\tctx.ServeFile(\"fixtures/custom_funcs/index.tmpl\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/file\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"{{ myCustomFunc }}\")\n\n\t\t\tm.Get(\"/file2\", func(ctx *Context) {\n\t\t\t\tctx.ServeFile(\"fixtures/custom_funcs/index.tmpl\", \"ok.tmpl\")\n\t\t\t})\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/file2\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"{{ myCustomFunc }}\")\n\t\t})\n\n\t\tConvey(\"Serve file content\", func() {\n\t\t\tm.Get(\"/file\", func(ctx *Context) {\n\t\t\t\tctx.ServeFileContent(\"fixtures/custom_funcs/index.tmpl\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/file\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"{{ myCustomFunc }}\")\n\n\t\t\tm.Get(\"/file2\", func(ctx *Context) {\n\t\t\t\tctx.ServeFileContent(\"fixtures/custom_funcs/index.tmpl\", \"ok.tmpl\")\n\t\t\t})\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/file2\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"{{ myCustomFunc }}\")\n\n\t\t\tm.Get(\"/file3\", func(ctx *Context) {\n\t\t\t\tctx.ServeFileContent(\"404.tmpl\")\n\t\t\t})\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/file3\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tif runtime.GOOS == \"windows\" {\n\t\t\t\tSo(resp.Body.String(), ShouldEqual, \"open 404.tmpl: The system cannot find the file specified.\\n\")\n\t\t\t} else {\n\t\t\t\tSo(resp.Body.String(), ShouldEqual, \"open 404.tmpl: no such file or directory\\n\")\n\t\t\t}\n\t\t\tSo(resp.Code, ShouldEqual, 500)\n\t\t})\n\n\t\tConvey(\"Serve content\", func() {\n\t\t\tm.Get(\"/content\", func(ctx *Context) {\n\t\t\t\tctx.ServeContent(\"content1\", bytes.NewReader([]byte(\"Hello world!\")))\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/content\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"Hello world!\")\n\n\t\t\tm.Get(\"/content2\", func(ctx *Context) {\n\t\t\t\tctx.ServeContent(\"content1\", bytes.NewReader([]byte(\"Hello world!\")), time.Now())\n\t\t\t})\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"/content2\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"Hello world!\")\n\t\t})\n\t})\n}\n\nfunc Test_Context_Render(t *testing.T) {\n\tConvey(\"Invalid render\", t, func() {\n\t\tdefer func() {\n\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t}()\n\n\t\tm := New()\n\n\t\tm.Get(\"/\", func(ctx *Context) {\n\t\t\tctx.HTML(200, \"hey\")\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tm.Get(\"/f\", ContextInvoker(func(ctx *Context) {\n\t\t\tctx.HTML(200, \"hey\")\n\t\t}))\n\t\treq, err = http.NewRequest(\"GET\", \"/f\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t})\n}\n\nfunc Test_Context_Redirect(t *testing.T) {\n\tConvey(\"Context with default redirect\", t, func() {\n\t\turl, err := url.Parse(\"http://localhost/path/one\")\n\t\tSo(err, ShouldBeNil)\n\t\tresp := httptest.NewRecorder()\n\t\treq := http.Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL:    url,\n\t\t}\n\t\tctx := &Context{\n\t\t\tReq:  Request{&req},\n\t\t\tResp: NewResponseWriter(req.Method, resp),\n\t\t\tData: make(map[string]interface{}),\n\t\t}\n\t\tctx.Redirect(\"two\")\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusFound)\n\t\tSo(resp.Result().Header[\"Location\"][0], ShouldEqual, \"/path/two\")\n\t})\n\n\tConvey(\"Context with custom redirect\", t, func() {\n\t\turl, err := url.Parse(\"http://localhost/path/one\")\n\t\tSo(err, ShouldBeNil)\n\t\tresp := httptest.NewRecorder()\n\t\treq := http.Request{\n\t\t\tMethod: \"GET\",\n\t\t\tURL:    url,\n\t\t}\n\t\tctx := &Context{\n\t\t\tReq:  Request{&req},\n\t\t\tResp: NewResponseWriter(req.Method, resp),\n\t\t\tData: make(map[string]interface{}),\n\t\t}\n\t\tctx.Redirect(\"two\", 307)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusTemporaryRedirect)\n\t\tSo(resp.Result().Header[\"Location\"][0], ShouldEqual, \"/path/two\")\n\t})\n}\n"
        },
        {
          "name": "cookie",
          "type": "tree",
          "content": null
        },
        {
          "name": "fixtures",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.474609375,
          "content": "module gopkg.in/macaron.v1\n\ngo 1.18\n\nrequire (\n\tgithub.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191\n\tgithub.com/smartystreets/goconvey v1.8.1\n\tgithub.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e\n\tgolang.org/x/crypto v0.31.0\n\tgopkg.in/ini.v1 v1.66.6\n)\n\nrequire (\n\tgithub.com/gopherjs/gopherjs v1.17.2 // indirect\n\tgithub.com/jtolds/gls v4.20.0+incompatible // indirect\n\tgithub.com/smarty/assertions v1.15.0 // indirect\n\tgithub.com/stretchr/testify v1.7.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 2.8095703125,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191 h1:NjHlg70DuOkcAMqgt0+XA+NHwtu66MkTVVgR4fFWbcI=\ngithub.com/go-macaron/inject v0.0.0-20160627170012-d8a0b8677191/go.mod h1:VFI2o2q9kYsC4o7VP1HrEVosiZZTd+MVT3YZx4gqvJw=\ngithub.com/gopherjs/gopherjs v0.0.0-20181103185306-d547d1d9531e/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gopherjs/gopherjs v1.17.2 h1:fQnZVsXk8uxXIStYb0N4bGk7jeyTalG/wsZjQ25dO0g=\ngithub.com/gopherjs/gopherjs v1.17.2/go.mod h1:pRRIvn/QzFLrKfvEz3qUuEhtE/zLCWfreZ6J5gM2i+k=\ngithub.com/jtolds/gls v4.2.1+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/jtolds/gls v4.20.0+incompatible h1:xdiiI2gbIgH/gLH7ADydsJ1uDOEzR8yvV7C0MuV77Wo=\ngithub.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/smarty/assertions v1.15.0 h1:cR//PqUBUiQRakZWqBiFFQ9wb8emQGDb0HeGdqGByCY=\ngithub.com/smarty/assertions v1.15.0/go.mod h1:yABtdzeQs6l1brC900WlRNwj6ZR55d7B+E8C6HtKdec=\ngithub.com/smartystreets/assertions v0.0.0-20190116191733-b6c0e53d7304/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/goconvey v0.0.0-20181108003508-044398e4856c/go.mod h1:XDJAKZRPZ1CvBcN2aX5YOUTYGHki24fSF0Iv48Ibg0s=\ngithub.com/smartystreets/goconvey v1.8.1 h1:qGjIddxOk4grTu9JPOU31tVfq3cNdBlNa5sSznIX1xY=\ngithub.com/smartystreets/goconvey v1.8.1/go.mod h1:+/u4qLyY6x1jReYOp7GOM2FSt8aP9CzCZL03bI28W60=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e h1:GSGeB9EAKY2spCABz6xOX5DbxZEXolK+nBSvmsQwRjM=\ngithub.com/unknwon/com v0.0.0-20190804042917-757f69c95f3e/go.mod h1:tOOxU81rwgoCLoOVVPHb6T/wt8HZygqH5id+GNnlCXM=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/ini.v1 v1.66.6 h1:LATuAqN/shcYAOkv3wl2L4rkaKqkcgTBQjOyYDvcPKI=\ngopkg.in/ini.v1 v1.66.6/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "logger.go",
          "type": "blob",
          "size": 2.171875,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"time\"\n)\n\nvar (\n\tColorLog      = true\n\tLogTimeFormat = \"2006-01-02 15:04:05\"\n)\n\nfunc init() {\n\tColorLog = runtime.GOOS != \"windows\"\n}\n\n// LoggerInvoker is an inject.FastInvoker wrapper of func(ctx *Context, log *log.Logger).\ntype LoggerInvoker func(ctx *Context, log *log.Logger)\n\nfunc (invoke LoggerInvoker) Invoke(params []interface{}) ([]reflect.Value, error) {\n\tinvoke(params[0].(*Context), params[1].(*log.Logger))\n\treturn nil, nil\n}\n\n// Logger returns a middleware handler that logs the request as it goes in and the response as it goes out.\nfunc Logger() Handler {\n\treturn func(ctx *Context, log *log.Logger) {\n\t\tstart := time.Now()\n\n\t\tlog.Printf(\"%s: Started %s %s for %s\", time.Now().Format(LogTimeFormat), ctx.Req.Method, ctx.Req.RequestURI, ctx.RemoteAddr())\n\n\t\tctx.Next()\n\n\t\tcontent := fmt.Sprintf(\"%s: Completed %s %s %v %s in %v\", time.Now().Format(LogTimeFormat), ctx.Req.Method, ctx.Req.RequestURI, ctx.Resp.Status(), http.StatusText(ctx.Resp.Status()), time.Since(start))\n\t\tif ColorLog {\n\t\t\tswitch ctx.Resp.Status() {\n\t\t\tcase 200, 201, 202:\n\t\t\t\tcontent = fmt.Sprintf(\"\\033[1;32m%s\\033[0m\", content)\n\t\t\tcase 301, 302:\n\t\t\t\tcontent = fmt.Sprintf(\"\\033[1;37m%s\\033[0m\", content)\n\t\t\tcase 304:\n\t\t\t\tcontent = fmt.Sprintf(\"\\033[1;33m%s\\033[0m\", content)\n\t\t\tcase 401, 403:\n\t\t\t\tcontent = fmt.Sprintf(\"\\033[4;31m%s\\033[0m\", content)\n\t\t\tcase 404:\n\t\t\t\tcontent = fmt.Sprintf(\"\\033[1;31m%s\\033[0m\", content)\n\t\t\tcase 500:\n\t\t\t\tcontent = fmt.Sprintf(\"\\033[1;36m%s\\033[0m\", content)\n\t\t\t}\n\t\t}\n\t\tlog.Println(content)\n\t}\n}\n"
        },
        {
          "name": "logger_test.go",
          "type": "blob",
          "size": 1.8408203125,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t\"github.com/unknwon/com\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_Logger(t *testing.T) {\n\tConvey(\"Global logger\", t, func() {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\tm := New()\n\t\tm.Map(log.New(buf, \"[Macaron] \", 0))\n\t\tm.Use(Logger())\n\t\tm.Use(func(res http.ResponseWriter) {\n\t\t\tres.WriteHeader(http.StatusNotFound)\n\t\t})\n\t\tm.Get(\"/\", func() {})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusNotFound)\n\t\tSo(len(buf.String()), ShouldBeGreaterThan, 0)\n\t})\n\n\tif ColorLog {\n\t\tConvey(\"Color console output\", t, func() {\n\t\t\tm := Classic()\n\t\t\tm.Get(\"/:code:int\", func(ctx *Context) (int, string) {\n\t\t\t\treturn ctx.ParamsInt(\":code\"), \"\"\n\t\t\t})\n\n\t\t\t// Just for testing if logger would capture.\n\t\t\tcodes := []int{200, 201, 202, 301, 302, 304, 401, 403, 404, 500}\n\t\t\tfor _, code := range codes {\n\t\t\t\tresp := httptest.NewRecorder()\n\t\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/\"+com.ToStr(code), nil)\n\t\t\t\tSo(err, ShouldBeNil)\n\t\t\t\tm.ServeHTTP(resp, req)\n\t\t\t\tSo(resp.Code, ShouldEqual, code)\n\t\t\t}\n\t\t})\n\t}\n}\n"
        },
        {
          "name": "macaron.go",
          "type": "blob",
          "size": 8.943359375,
          "content": "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\n// Package macaron is a high productive and modular web framework in Go.\npackage macaron // import \"gopkg.in/macaron.v1\"\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/unknwon/com\"\n\t\"gopkg.in/ini.v1\"\n\n\t\"github.com/go-macaron/inject\"\n)\n\nconst _VERSION = \"1.3.4.0805\"\n\nfunc Version() string {\n\treturn _VERSION\n}\n\n// Handler can be any callable function.\n// Macaron attempts to inject services into the handler's argument list,\n// and panics if an argument could not be fullfilled via dependency injection.\ntype Handler interface{}\n\n// handlerFuncInvoker is an inject.FastInvoker wrapper of func(http.ResponseWriter, *http.Request).\ntype handlerFuncInvoker func(http.ResponseWriter, *http.Request)\n\nfunc (invoke handlerFuncInvoker) Invoke(params []interface{}) ([]reflect.Value, error) {\n\tinvoke(params[0].(http.ResponseWriter), params[1].(*http.Request))\n\treturn nil, nil\n}\n\n// internalServerErrorInvoker is an inject.FastInvoker wrapper of func(rw http.ResponseWriter, err error).\ntype internalServerErrorInvoker func(rw http.ResponseWriter, err error)\n\nfunc (invoke internalServerErrorInvoker) Invoke(params []interface{}) ([]reflect.Value, error) {\n\tinvoke(params[0].(http.ResponseWriter), params[1].(error))\n\treturn nil, nil\n}\n\n// validateAndWrapHandler makes sure a handler is a callable function, it panics if not.\n// When the handler is also potential to be any built-in inject.FastInvoker,\n// it wraps the handler automatically to have some performance gain.\nfunc validateAndWrapHandler(h Handler) Handler {\n\tif reflect.TypeOf(h).Kind() != reflect.Func {\n\t\tpanic(\"Macaron handler must be a callable function\")\n\t}\n\n\tif !inject.IsFastInvoker(h) {\n\t\tswitch v := h.(type) {\n\t\tcase func(*Context):\n\t\t\treturn ContextInvoker(v)\n\t\tcase func(*Context, *log.Logger):\n\t\t\treturn LoggerInvoker(v)\n\t\tcase func(http.ResponseWriter, *http.Request):\n\t\t\treturn handlerFuncInvoker(v)\n\t\tcase func(http.ResponseWriter, error):\n\t\t\treturn internalServerErrorInvoker(v)\n\t\t}\n\t}\n\treturn h\n}\n\n// validateAndWrapHandlers preforms validation and wrapping for each input handler.\n// It accepts an optional wrapper function to perform custom wrapping on handlers.\nfunc validateAndWrapHandlers(handlers []Handler, wrappers ...func(Handler) Handler) []Handler {\n\tvar wrapper func(Handler) Handler\n\tif len(wrappers) > 0 {\n\t\twrapper = wrappers[0]\n\t}\n\n\twrappedHandlers := make([]Handler, len(handlers))\n\tfor i, h := range handlers {\n\t\th = validateAndWrapHandler(h)\n\t\tif wrapper != nil && !inject.IsFastInvoker(h) {\n\t\t\th = wrapper(h)\n\t\t}\n\t\twrappedHandlers[i] = h\n\t}\n\n\treturn wrappedHandlers\n}\n\n// Macaron represents the top level web application.\n// inject.Injector methods can be invoked to map services on a global level.\ntype Macaron struct {\n\tinject.Injector\n\tbefores  []BeforeHandler\n\thandlers []Handler\n\taction   Handler\n\n\thasURLPrefix bool\n\turlPrefix    string // For suburl support.\n\t*Router\n\n\tlogger *log.Logger\n}\n\n// NewWithLogger creates a bare bones Macaron instance.\n// Use this method if you want to have full control over the middleware that is used.\n// You can specify logger output writer with this function.\nfunc NewWithLogger(out io.Writer) *Macaron {\n\tm := &Macaron{\n\t\tInjector: inject.New(),\n\t\taction:   func() {},\n\t\tRouter:   NewRouter(),\n\t\tlogger:   log.New(out, \"[Macaron] \", 0),\n\t}\n\tm.Router.m = m\n\tm.Map(m.logger)\n\tm.Map(defaultReturnHandler())\n\tm.NotFound(http.NotFound)\n\tm.InternalServerError(func(rw http.ResponseWriter, err error) {\n\t\thttp.Error(rw, err.Error(), 500)\n\t})\n\treturn m\n}\n\n// New creates a bare bones Macaron instance.\n// Use this method if you want to have full control over the middleware that is used.\nfunc New() *Macaron {\n\treturn NewWithLogger(os.Stdout)\n}\n\n// Classic creates a classic Macaron with some basic default middleware:\n// macaron.Logger, macaron.Recovery and macaron.Static.\nfunc Classic() *Macaron {\n\tm := New()\n\tm.Use(Logger())\n\tm.Use(Recovery())\n\tm.Use(Static(\"public\"))\n\treturn m\n}\n\n// Handlers sets the entire middleware stack with the given Handlers.\n// This will clear any current middleware handlers,\n// and panics if any of the handlers is not a callable function\nfunc (m *Macaron) Handlers(handlers ...Handler) {\n\tm.handlers = make([]Handler, 0)\n\tfor _, handler := range handlers {\n\t\tm.Use(handler)\n\t}\n}\n\n// Action sets the handler that will be called after all the middleware has been invoked.\n// This is set to macaron.Router in a macaron.Classic().\nfunc (m *Macaron) Action(handler Handler) {\n\thandler = validateAndWrapHandler(handler)\n\tm.action = handler\n}\n\n// BeforeHandler represents a handler executes at beginning of every request.\n// Macaron stops future process when it returns true.\ntype BeforeHandler func(rw http.ResponseWriter, req *http.Request) bool\n\nfunc (m *Macaron) Before(handler BeforeHandler) {\n\tm.befores = append(m.befores, handler)\n}\n\n// Use adds a middleware Handler to the stack,\n// and panics if the handler is not a callable func.\n// Middleware Handlers are invoked in the order that they are added.\nfunc (m *Macaron) Use(handler Handler) {\n\thandler = validateAndWrapHandler(handler)\n\tm.handlers = append(m.handlers, handler)\n}\n\nfunc (m *Macaron) createContext(rw http.ResponseWriter, req *http.Request) *Context {\n\tc := &Context{\n\t\tInjector: inject.New(),\n\t\thandlers: m.handlers,\n\t\taction:   m.action,\n\t\tindex:    0,\n\t\tRouter:   m.Router,\n\t\tReq:      Request{req},\n\t\tResp:     NewResponseWriter(req.Method, rw),\n\t\tRender:   &DummyRender{rw},\n\t\tData:     make(map[string]interface{}),\n\t}\n\tc.SetParent(m)\n\tc.Map(c)\n\tc.MapTo(c.Resp, (*http.ResponseWriter)(nil))\n\tc.Map(req)\n\treturn c\n}\n\n// ServeHTTP is the HTTP Entry point for a Macaron instance.\n// Useful if you want to control your own HTTP server.\n// Be aware that none of middleware will run without registering any router.\nfunc (m *Macaron) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif m.hasURLPrefix {\n\t\treq.URL.Path = strings.TrimPrefix(req.URL.Path, m.urlPrefix)\n\t}\n\tfor _, h := range m.befores {\n\t\tif h(rw, req) {\n\t\t\treturn\n\t\t}\n\t}\n\tm.Router.ServeHTTP(rw, req)\n}\n\nfunc GetDefaultListenInfo() (string, int) {\n\thost := os.Getenv(\"HOST\")\n\tif len(host) == 0 {\n\t\thost = \"0.0.0.0\"\n\t}\n\tport := com.StrTo(os.Getenv(\"PORT\")).MustInt()\n\tif port == 0 {\n\t\tport = 4000\n\t}\n\treturn host, port\n}\n\n// Run the http server. Listening on os.GetEnv(\"PORT\") or 4000 by default.\nfunc (m *Macaron) Run(args ...interface{}) {\n\thost, port := GetDefaultListenInfo()\n\tif len(args) == 1 {\n\t\tswitch arg := args[0].(type) {\n\t\tcase string:\n\t\t\thost = arg\n\t\tcase int:\n\t\t\tport = arg\n\t\t}\n\t} else if len(args) >= 2 {\n\t\tif arg, ok := args[0].(string); ok {\n\t\t\thost = arg\n\t\t}\n\t\tif arg, ok := args[1].(int); ok {\n\t\t\tport = arg\n\t\t}\n\t}\n\n\taddr := host + \":\" + com.ToStr(port)\n\tlogger := m.GetVal(reflect.TypeOf(m.logger)).Interface().(*log.Logger)\n\tlogger.Printf(\"listening on %s (%s)\\n\", addr, safeEnv())\n\tlogger.Fatalln(http.ListenAndServe(addr, m))\n}\n\n// SetURLPrefix sets URL prefix of router layer, so that it support suburl.\nfunc (m *Macaron) SetURLPrefix(prefix string) {\n\tm.urlPrefix = prefix\n\tm.hasURLPrefix = len(m.urlPrefix) > 0\n}\n\n// ____   ____            .__      ___.   .__\n// \\   \\ /   /____ _______|__|____ \\_ |__ |  |   ____   ______\n//  \\   Y   /\\__  \\\\_  __ \\  \\__  \\ | __ \\|  | _/ __ \\ /  ___/\n//   \\     /  / __ \\|  | \\/  |/ __ \\| \\_\\ \\  |_\\  ___/ \\___ \\\n//    \\___/  (____  /__|  |__(____  /___  /____/\\___  >____  >\n//                \\/              \\/    \\/          \\/     \\/\n\nconst (\n\tDEV  = \"development\"\n\tPROD = \"production\"\n\tTEST = \"test\"\n)\n\nvar (\n\t// Env is the environment that Macaron is executing in.\n\t// The MACARON_ENV is read on initialization to set this variable.\n\tEnv     = DEV\n\tenvLock sync.Mutex\n\n\t// Path of work directory.\n\tRoot string\n\n\t// Flash applies to current request.\n\tFlashNow bool\n\n\t// Configuration convention object.\n\tcfg *ini.File\n)\n\nfunc setENV(e string) {\n\tenvLock.Lock()\n\tdefer envLock.Unlock()\n\n\tif len(e) > 0 {\n\t\tEnv = e\n\t}\n}\n\nfunc safeEnv() string {\n\tenvLock.Lock()\n\tdefer envLock.Unlock()\n\n\treturn Env\n}\n\nfunc init() {\n\tsetENV(os.Getenv(\"MACARON_ENV\"))\n\n\tvar err error\n\tRoot, err = os.Getwd()\n\tif err != nil {\n\t\tpanic(\"error getting work directory: \" + err.Error())\n\t}\n}\n\n// SetConfig sets data sources for configuration.\nfunc SetConfig(source interface{}, others ...interface{}) (_ *ini.File, err error) {\n\tcfg, err = ini.Load(source, others...)\n\treturn Config(), err\n}\n\n// Config returns configuration convention object.\n// It returns an empty object if there is no one available.\nfunc Config() *ini.File {\n\tif cfg == nil {\n\t\treturn ini.Empty()\n\t}\n\treturn cfg\n}\n"
        },
        {
          "name": "macaron_test.go",
          "type": "blob",
          "size": 4.9541015625,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_Version(t *testing.T) {\n\tConvey(\"Get version\", t, func() {\n\t\tSo(Version(), ShouldEqual, _VERSION)\n\t})\n}\n\nfunc Test_New(t *testing.T) {\n\tConvey(\"Initialize a new instance\", t, func() {\n\t\tSo(New(), ShouldNotBeNil)\n\t})\n\n\tConvey(\"Just test that Run doesn't bomb\", t, func() {\n\t\tgo New().Run()\n\t\ttime.Sleep(1 * time.Second)\n\t\tos.Setenv(\"PORT\", \"4001\")\n\t\tgo New().Run(\"0.0.0.0\")\n\t\tgo New().Run(4002)\n\t\tgo New().Run(\"0.0.0.0\", 4003)\n\t})\n}\n\nfunc Test_Macaron_Before(t *testing.T) {\n\tConvey(\"Register before handlers\", t, func() {\n\t\tm := New()\n\t\tm.Before(func(rw http.ResponseWriter, req *http.Request) bool {\n\t\t\treturn false\n\t\t})\n\t\tm.Before(func(rw http.ResponseWriter, req *http.Request) bool {\n\t\t\treturn true\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t})\n}\n\nfunc Test_Macaron_ServeHTTP(t *testing.T) {\n\tConvey(\"Serve HTTP requests\", t, func() {\n\t\tresult := \"\"\n\t\tm := New()\n\t\tm.Use(func(c *Context) {\n\t\t\tresult += \"foo\"\n\t\t\tc.Next()\n\t\t\tresult += \"ban\"\n\t\t})\n\t\tm.Use(func(c *Context) {\n\t\t\tresult += \"bar\"\n\t\t\tc.Next()\n\t\t\tresult += \"baz\"\n\t\t})\n\t\tm.Get(\"/\", func() {})\n\t\tm.Action(func(res http.ResponseWriter, req *http.Request) {\n\t\t\tresult += \"bat\"\n\t\t\tres.WriteHeader(http.StatusBadRequest)\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(result, ShouldEqual, \"foobarbatbazban\")\n\t\tSo(resp.Code, ShouldEqual, http.StatusBadRequest)\n\t})\n}\n\nfunc Test_Macaron_Handlers(t *testing.T) {\n\tConvey(\"Add custom handlers\", t, func() {\n\t\tresult := \"\"\n\t\tbatman := func(c *Context) {\n\t\t\tresult += \"batman!\"\n\t\t}\n\n\t\tm := New()\n\t\tm.Use(func(c *Context) {\n\t\t\tresult += \"foo\"\n\t\t\tc.Next()\n\t\t\tresult += \"ban\"\n\t\t})\n\t\tm.Handlers(\n\t\t\tbatman,\n\t\t\tbatman,\n\t\t\tbatman,\n\t\t)\n\n\t\tConvey(\"Add not callable function\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm.Use(\"shit\")\n\t\t})\n\n\t\tm.Get(\"/\", func() {})\n\t\tm.Action(func(res http.ResponseWriter, req *http.Request) {\n\t\t\tresult += \"bat\"\n\t\t\tres.WriteHeader(http.StatusBadRequest)\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(result, ShouldEqual, \"batman!batman!batman!bat\")\n\t\tSo(resp.Code, ShouldEqual, http.StatusBadRequest)\n\t})\n}\n\nfunc Test_Macaron_EarlyWrite(t *testing.T) {\n\tConvey(\"Write early content to response\", t, func() {\n\t\tresult := \"\"\n\t\tm := New()\n\t\tm.Use(func(res http.ResponseWriter) {\n\t\t\tresult += \"foobar\"\n\t\t\t_, _ = res.Write([]byte(\"Hello world\"))\n\t\t})\n\t\tm.Use(func() {\n\t\t\tresult += \"bat\"\n\t\t})\n\t\tm.Get(\"/\", func() {})\n\t\tm.Action(func(res http.ResponseWriter) {\n\t\t\tresult += \"baz\"\n\t\t\tres.WriteHeader(http.StatusBadRequest)\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(result, ShouldEqual, \"foobar\")\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t})\n}\n\nfunc Test_Macaron_Written(t *testing.T) {\n\tConvey(\"Written sign\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\tm := New()\n\t\tm.Handlers(func(res http.ResponseWriter) {\n\t\t\tres.WriteHeader(http.StatusOK)\n\t\t})\n\n\t\tctx := m.createContext(resp, &http.Request{Method: \"GET\"})\n\t\tSo(ctx.Written(), ShouldBeFalse)\n\n\t\tctx.run()\n\t\tSo(ctx.Written(), ShouldBeTrue)\n\t})\n}\n\nfunc Test_Macaron_Basic_NoRace(t *testing.T) {\n\tConvey(\"Make sure no race between requests\", t, func() {\n\t\tm := New()\n\t\thandlers := []Handler{func() {}, func() {}}\n\t\t// Ensure append will not realloc to trigger the race condition\n\t\tm.handlers = handlers[:1]\n\t\tm.Get(\"/\", func() {})\n\t\tfor i := 0; i < 2; i++ {\n\t\t\tgo func() {\n\t\t\t\treq, _ := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\t\tresp := httptest.NewRecorder()\n\t\t\t\tm.ServeHTTP(resp, req)\n\t\t\t}()\n\t\t}\n\t})\n}\n\nfunc Test_SetENV(t *testing.T) {\n\tConvey(\"Get and save environment variable\", t, func() {\n\t\ttests := []struct {\n\t\t\tin  string\n\t\t\tout string\n\t\t}{\n\t\t\t{\"\", \"development\"},\n\t\t\t{\"not_development\", \"not_development\"},\n\t\t}\n\n\t\tfor _, test := range tests {\n\t\t\tsetENV(test.in)\n\t\t\tSo(Env, ShouldEqual, test.out)\n\t\t}\n\t})\n}\n\nfunc Test_Config(t *testing.T) {\n\tConvey(\"Set and get configuration object\", t, func() {\n\t\tSo(Config(), ShouldNotBeNil)\n\t\tcfg, err := SetConfig([]byte(\"\"))\n\t\tSo(err, ShouldBeNil)\n\t\tSo(cfg, ShouldNotBeNil)\n\t})\n}\n"
        },
        {
          "name": "macaronlogo.png",
          "type": "blob",
          "size": 86.83984375,
          "content": null
        },
        {
          "name": "recovery.go",
          "type": "blob",
          "size": 4.2587890625,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"runtime\"\n\n\t\"github.com/go-macaron/inject\"\n)\n\nconst (\n\tpanicHtml = `<html>\n<head><title>PANIC: %s</title>\n<meta charset=\"utf-8\" />\n<style type=\"text/css\">\nhtml, body {\n\tfont-family: \"Roboto\", sans-serif;\n\tcolor: #333333;\n\tbackground-color: #ea5343;\n\tmargin: 0px;\n}\nh1 {\n\tcolor: #d04526;\n\tbackground-color: #ffffff;\n\tpadding: 20px;\n\tborder-bottom: 1px dashed #2b3848;\n}\npre {\n\tmargin: 20px;\n\tpadding: 20px;\n\tborder: 2px solid #2b3848;\n\tbackground-color: #ffffff;\n\twhite-space: pre-wrap;       /* css-3 */\n\twhite-space: -moz-pre-wrap;  /* Mozilla, since 1999 */\n\twhite-space: -pre-wrap;      /* Opera 4-6 */\n\twhite-space: -o-pre-wrap;    /* Opera 7 */\n\tword-wrap: break-word;       /* Internet Explorer 5.5+ */\n}\n</style>\n</head><body>\n<h1>PANIC</h1>\n<pre style=\"font-weight: bold;\">%s</pre>\n<pre>%s</pre>\n</body>\n</html>`\n)\n\nvar (\n\tdunno     = []byte(\"???\")\n\tcenterDot = []byte(\"Â·\")\n\tdot       = []byte(\".\")\n\tslash     = []byte(\"/\")\n)\n\n// stack returns a nicely formated stack frame, skipping skip frames\nfunc stack(skip int) []byte {\n\tbuf := new(bytes.Buffer) // the returned data\n\t// As we loop, we open files and read them. These variables record the currently\n\t// loaded file.\n\tvar lines [][]byte\n\tvar lastFile string\n\tfor i := skip; ; i++ { // Skip the expected number of frames\n\t\tpc, file, line, ok := runtime.Caller(i)\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\t// Print this much at least.  If we can't find the source, it won't show.\n\t\tfmt.Fprintf(buf, \"%s:%d (0x%x)\\n\", file, line, pc)\n\t\tif file != lastFile {\n\t\t\tdata, err := os.ReadFile(file)\n\t\t\tif err != nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tlines = bytes.Split(data, []byte{'\\n'})\n\t\t\tlastFile = file\n\t\t}\n\t\tfmt.Fprintf(buf, \"\\t%s: %s\\n\", function(pc), source(lines, line))\n\t}\n\treturn buf.Bytes()\n}\n\n// source returns a space-trimmed slice of the n'th line.\nfunc source(lines [][]byte, n int) []byte {\n\tn-- // in stack trace, lines are 1-indexed but our array is 0-indexed\n\tif n < 0 || n >= len(lines) {\n\t\treturn dunno\n\t}\n\treturn bytes.TrimSpace(lines[n])\n}\n\n// function returns, if possible, the name of the function containing the PC.\nfunc function(pc uintptr) []byte {\n\tfn := runtime.FuncForPC(pc)\n\tif fn == nil {\n\t\treturn dunno\n\t}\n\tname := []byte(fn.Name())\n\t// The name includes the path name to the package, which is unnecessary\n\t// since the file name is already included.  Plus, it has center dots.\n\t// That is, we see\n\t//\truntime/debug.*TÂ·ptrmethod\n\t// and want\n\t//\t*T.ptrmethod\n\t// Also the package path might contains dot (e.g. code.google.com/...),\n\t// so first eliminate the path prefix\n\tif lastslash := bytes.LastIndex(name, slash); lastslash >= 0 {\n\t\tname = name[lastslash+1:]\n\t}\n\tif period := bytes.Index(name, dot); period >= 0 {\n\t\tname = name[period+1:]\n\t}\n\tname = bytes.Replace(name, centerDot, dot, -1)\n\treturn name\n}\n\n// Recovery returns a middleware that recovers from any panics and writes a 500 if there was one.\n// While Martini is in development mode, Recovery will also output the panic as HTML.\nfunc Recovery() Handler {\n\treturn func(c *Context, log *log.Logger) {\n\t\tdefer func() {\n\t\t\tif err := recover(); err != nil {\n\t\t\t\tstack := stack(3)\n\t\t\t\tlog.Printf(\"PANIC: %s\\n%s\", err, stack)\n\n\t\t\t\t// Lookup the current responsewriter\n\t\t\t\tval := c.GetVal(inject.InterfaceOf((*http.ResponseWriter)(nil)))\n\t\t\t\tres := val.Interface().(http.ResponseWriter)\n\n\t\t\t\t// respond with panic message while in development mode\n\t\t\t\tvar body []byte\n\t\t\t\tif Env == DEV {\n\t\t\t\t\tres.Header().Set(\"Content-Type\", \"text/html\")\n\t\t\t\t\tbody = []byte(fmt.Sprintf(panicHtml, err, err, stack))\n\t\t\t\t}\n\n\t\t\t\tres.WriteHeader(http.StatusInternalServerError)\n\t\t\t\tif nil != body {\n\t\t\t\t\t_, _ = res.Write(body)\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\n\t\tc.Next()\n\t}\n}\n"
        },
        {
          "name": "recovery_test.go",
          "type": "blob",
          "size": 2.041015625,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_Recovery(t *testing.T) {\n\tConvey(\"Recovery from panic\", t, func() {\n\t\tbuf := bytes.NewBufferString(\"\")\n\t\tsetENV(DEV)\n\n\t\tm := New()\n\t\tm.Map(log.New(buf, \"[Macaron] \", 0))\n\t\tm.Use(func(res http.ResponseWriter, req *http.Request) {\n\t\t\tres.Header().Set(\"Content-Type\", \"unpredictable\")\n\t\t})\n\t\tm.Use(Recovery())\n\t\tm.Use(func(res http.ResponseWriter, req *http.Request) {\n\t\t\tpanic(\"here is a panic!\")\n\t\t})\n\t\tm.Get(\"/\", func() {})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusInternalServerError)\n\t\tSo(resp.Header().Get(\"Content-Type\"), ShouldEqual, \"text/html\")\n\t\tSo(buf.String(), ShouldNotBeEmpty)\n\t})\n\n\tConvey(\"Revocery panic to another response writer\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\tresp2 := httptest.NewRecorder()\n\t\tsetENV(DEV)\n\n\t\tm := New()\n\t\tm.Use(Recovery())\n\t\tm.Use(func(c *Context) {\n\t\t\tc.MapTo(resp2, (*http.ResponseWriter)(nil))\n\t\t\tpanic(\"here is a panic!\")\n\t\t})\n\t\tm.Get(\"/\", func() {})\n\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp2.Code, ShouldEqual, http.StatusInternalServerError)\n\t\tSo(resp2.Header().Get(\"Content-Type\"), ShouldEqual, \"text/html\")\n\t\tSo(resp2.Body.Len(), ShouldBeGreaterThan, 0)\n\t})\n}\n"
        },
        {
          "name": "render.go",
          "type": "blob",
          "size": 18.2236328125,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/unknwon/com\"\n)\n\nconst (\n\t_CONTENT_TYPE    = \"Content-Type\"\n\t_CONTENT_BINARY  = \"application/octet-stream\"\n\t_CONTENT_JSON    = \"application/json\"\n\t_CONTENT_HTML    = \"text/html\"\n\t_CONTENT_PLAIN   = \"text/plain\"\n\t_CONTENT_XHTML   = \"application/xhtml+xml\"\n\t_CONTENT_XML     = \"text/xml\"\n\t_DEFAULT_CHARSET = \"UTF-8\"\n)\n\nvar (\n\t// Provides a temporary buffer to execute templates into and catch errors.\n\tbufpool = sync.Pool{\n\t\tNew: func() interface{} { return new(bytes.Buffer) },\n\t}\n\n\t// Included helper functions for use when rendering html\n\thelperFuncs = template.FuncMap{\n\t\t\"yield\": func() (string, error) {\n\t\t\treturn \"\", fmt.Errorf(\"yield called with no layout defined\")\n\t\t},\n\t\t\"current\": func() (string, error) {\n\t\t\treturn \"\", nil\n\t\t},\n\t}\n)\n\ntype (\n\t// TemplateFile represents a interface of template file that has name and can be read.\n\tTemplateFile interface {\n\t\tName() string\n\t\tData() []byte\n\t\tExt() string\n\t}\n\t// TemplateFileSystem represents a interface of template file system that able to list all files.\n\tTemplateFileSystem interface {\n\t\tListFiles() []TemplateFile\n\t\tGet(string) (io.Reader, error)\n\t}\n\n\t// Delims represents a set of Left and Right delimiters for HTML template rendering\n\tDelims struct {\n\t\t// Left delimiter, defaults to {{\n\t\tLeft string\n\t\t// Right delimiter, defaults to }}\n\t\tRight string\n\t}\n\n\t// RenderOptions represents a struct for specifying configuration options for the Render middleware.\n\tRenderOptions struct {\n\t\t// Directory to load templates. Default is \"templates\".\n\t\tDirectory string\n\t\t// Addtional directories to overwite templates.\n\t\tAppendDirectories []string\n\t\t// Layout template name. Will not render a layout if \"\". Default is to \"\".\n\t\tLayout string\n\t\t// Extensions to parse template files from. Defaults are [\".tmpl\", \".html\"].\n\t\tExtensions []string\n\t\t// Funcs is a slice of FuncMaps to apply to the template upon compilation. This is useful for helper functions. Default is [].\n\t\tFuncs []template.FuncMap\n\t\t// Delims sets the action delimiters to the specified strings in the Delims struct.\n\t\tDelims Delims\n\t\t// Appends the given charset to the Content-Type header. Default is \"UTF-8\".\n\t\tCharset string\n\t\t// Outputs human readable JSON.\n\t\tIndentJSON bool\n\t\t// Outputs human readable XML.\n\t\tIndentXML bool\n\t\t// Prefixes the JSON output with the given bytes.\n\t\tPrefixJSON []byte\n\t\t// Prefixes the XML output with the given bytes.\n\t\tPrefixXML []byte\n\t\t// Allows changing of output to XHTML instead of HTML. Default is \"text/html\"\n\t\tHTMLContentType string\n\t\t// TemplateFileSystem is the interface for supporting any implmentation of template file system.\n\t\tTemplateFileSystem\n\t}\n\n\t// HTMLOptions is a struct for overriding some rendering Options for specific HTML call\n\tHTMLOptions struct {\n\t\t// Layout template name. Overrides Options.Layout.\n\t\tLayout string\n\t}\n\n\tRender interface {\n\t\thttp.ResponseWriter\n\t\tSetResponseWriter(http.ResponseWriter)\n\n\t\tJSON(int, interface{})\n\t\tJSONString(interface{}) (string, error)\n\t\tRawData(int, []byte)   // Serve content as binary\n\t\tPlainText(int, []byte) // Serve content as plain text\n\t\tHTML(int, string, interface{}, ...HTMLOptions)\n\t\tHTMLSet(int, string, string, interface{}, ...HTMLOptions)\n\t\tHTMLSetString(string, string, interface{}, ...HTMLOptions) (string, error)\n\t\tHTMLString(string, interface{}, ...HTMLOptions) (string, error)\n\t\tHTMLSetBytes(string, string, interface{}, ...HTMLOptions) ([]byte, error)\n\t\tHTMLBytes(string, interface{}, ...HTMLOptions) ([]byte, error)\n\t\tXML(int, interface{})\n\t\tError(int, ...string)\n\t\tStatus(int)\n\t\tSetTemplatePath(string, string)\n\t\tHasTemplateSet(string) bool\n\t}\n)\n\n// TplFile implements TemplateFile interface.\ntype TplFile struct {\n\tname string\n\tdata []byte\n\text  string\n}\n\n// NewTplFile cerates new template file with given name and data.\nfunc NewTplFile(name string, data []byte, ext string) *TplFile {\n\treturn &TplFile{name, data, ext}\n}\n\nfunc (f *TplFile) Name() string {\n\treturn f.name\n}\n\nfunc (f *TplFile) Data() []byte {\n\treturn f.data\n}\n\nfunc (f *TplFile) Ext() string {\n\treturn f.ext\n}\n\n// TplFileSystem implements TemplateFileSystem interface.\ntype TplFileSystem struct {\n\tfiles []TemplateFile\n}\n\n// NewTemplateFileSystem creates new template file system with given options.\nfunc NewTemplateFileSystem(opt RenderOptions, omitData bool) TplFileSystem {\n\tfs := TplFileSystem{}\n\tfs.files = make([]TemplateFile, 0, 10)\n\n\t// Directories are composed in reverse order because later one overwrites previous ones,\n\t// so once found, we can directly jump out of the loop.\n\tdirs := make([]string, 0, len(opt.AppendDirectories)+1)\n\tfor i := len(opt.AppendDirectories) - 1; i >= 0; i-- {\n\t\tdirs = append(dirs, opt.AppendDirectories[i])\n\t}\n\tdirs = append(dirs, opt.Directory)\n\n\tvar err error\n\tfor i := range dirs {\n\t\t// Skip ones that does not exists for symlink test,\n\t\t// but allow non-symlink ones added after start.\n\t\tif !com.IsExist(dirs[i]) {\n\t\t\tcontinue\n\t\t}\n\n\t\tdirs[i], err = filepath.EvalSymlinks(dirs[i])\n\t\tif err != nil {\n\t\t\tpanic(\"EvalSymlinks(\" + dirs[i] + \"): \" + err.Error())\n\t\t}\n\t}\n\tlastDir := dirs[len(dirs)-1]\n\n\t// We still walk the last (original) directory because it's non-sense we load templates not exist in original directory.\n\tif err = filepath.Walk(lastDir, func(path string, info os.FileInfo, _ error) error {\n\t\tr, err := filepath.Rel(lastDir, path)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\text := GetExt(r)\n\n\t\tfor _, extension := range opt.Extensions {\n\t\t\tif ext != extension {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar data []byte\n\t\t\tif !omitData {\n\t\t\t\t// Loop over candidates of directory, break out once found.\n\t\t\t\t// The file always exists because it's inside the walk function,\n\t\t\t\t// and read original file is the worst case.\n\t\t\t\tfor i := range dirs {\n\t\t\t\t\tpath = filepath.Join(dirs[i], r)\n\t\t\t\t\tif !com.IsFile(path) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tdata, err = os.ReadFile(path)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tname := filepath.ToSlash((r[0 : len(r)-len(ext)]))\n\t\t\tfs.files = append(fs.files, NewTplFile(name, data, ext))\n\t\t}\n\n\t\treturn nil\n\t}); err != nil {\n\t\tpanic(\"NewTemplateFileSystem: \" + err.Error())\n\t}\n\n\treturn fs\n}\n\nfunc (fs TplFileSystem) ListFiles() []TemplateFile {\n\treturn fs.files\n}\n\nfunc (fs TplFileSystem) Get(name string) (io.Reader, error) {\n\tfor i := range fs.files {\n\t\tif fs.files[i].Name()+fs.files[i].Ext() == name {\n\t\t\treturn bytes.NewReader(fs.files[i].Data()), nil\n\t\t}\n\t}\n\treturn nil, fmt.Errorf(\"file '%s' not found\", name)\n}\n\nfunc PrepareCharset(charset string) string {\n\tif len(charset) != 0 {\n\t\treturn \"; charset=\" + charset\n\t}\n\n\treturn \"; charset=\" + _DEFAULT_CHARSET\n}\n\nfunc GetExt(s string) string {\n\tindex := strings.Index(s, \".\")\n\tif index == -1 {\n\t\treturn \"\"\n\t}\n\treturn s[index:]\n}\n\nfunc compile(opt RenderOptions) *template.Template {\n\tt := template.New(opt.Directory)\n\tt.Delims(opt.Delims.Left, opt.Delims.Right)\n\t// Parse an initial template in case we don't have any.\n\ttemplate.Must(t.Parse(\"Macaron\"))\n\n\tif opt.TemplateFileSystem == nil {\n\t\topt.TemplateFileSystem = NewTemplateFileSystem(opt, false)\n\t}\n\n\tfor _, f := range opt.TemplateFileSystem.ListFiles() {\n\t\ttmpl := t.New(f.Name())\n\t\tfor _, funcs := range opt.Funcs {\n\t\t\ttmpl.Funcs(funcs)\n\t\t}\n\t\t// Bomb out if parse fails. We don't want any silent server starts.\n\t\ttemplate.Must(tmpl.Funcs(helperFuncs).Parse(string(f.Data())))\n\t}\n\n\treturn t\n}\n\nconst (\n\tDEFAULT_TPL_SET_NAME = \"DEFAULT\"\n)\n\n// TemplateSet represents a template set of type *template.Template.\ntype TemplateSet struct {\n\tlock sync.RWMutex\n\tsets map[string]*template.Template\n\tdirs map[string]string\n}\n\n// NewTemplateSet initializes a new empty template set.\nfunc NewTemplateSet() *TemplateSet {\n\treturn &TemplateSet{\n\t\tsets: make(map[string]*template.Template),\n\t\tdirs: make(map[string]string),\n\t}\n}\n\nfunc (ts *TemplateSet) Set(name string, opt *RenderOptions) *template.Template {\n\tt := compile(*opt)\n\n\tts.lock.Lock()\n\tdefer ts.lock.Unlock()\n\n\tts.sets[name] = t\n\tts.dirs[name] = opt.Directory\n\treturn t\n}\n\nfunc (ts *TemplateSet) Get(name string) *template.Template {\n\tts.lock.RLock()\n\tdefer ts.lock.RUnlock()\n\n\treturn ts.sets[name]\n}\n\nfunc (ts *TemplateSet) GetDir(name string) string {\n\tts.lock.RLock()\n\tdefer ts.lock.RUnlock()\n\n\treturn ts.dirs[name]\n}\n\nfunc prepareRenderOptions(options []RenderOptions) RenderOptions {\n\tvar opt RenderOptions\n\tif len(options) > 0 {\n\t\topt = options[0]\n\t}\n\n\t// Defaults.\n\tif len(opt.Directory) == 0 {\n\t\topt.Directory = \"templates\"\n\t}\n\tif len(opt.Extensions) == 0 {\n\t\topt.Extensions = []string{\".tmpl\", \".html\"}\n\t}\n\tif len(opt.HTMLContentType) == 0 {\n\t\topt.HTMLContentType = _CONTENT_HTML\n\t}\n\n\treturn opt\n}\n\nfunc ParseTplSet(tplSet string) (tplName string, tplDir string) {\n\ttplSet = strings.TrimSpace(tplSet)\n\tif len(tplSet) == 0 {\n\t\tpanic(\"empty template set argument\")\n\t}\n\tinfos := strings.Split(tplSet, \":\")\n\tif len(infos) == 1 {\n\t\ttplDir = infos[0]\n\t\ttplName = path.Base(tplDir)\n\t} else {\n\t\ttplName = infos[0]\n\t\ttplDir = infos[1]\n\t}\n\n\tif !com.IsDir(tplDir) {\n\t\tpanic(\"template set path does not exist or is not a directory\")\n\t}\n\treturn tplName, tplDir\n}\n\nfunc renderHandler(opt RenderOptions, tplSets []string) Handler {\n\tcs := PrepareCharset(opt.Charset)\n\tts := NewTemplateSet()\n\tts.Set(DEFAULT_TPL_SET_NAME, &opt)\n\n\tvar tmpOpt RenderOptions\n\tfor _, tplSet := range tplSets {\n\t\ttplName, tplDir := ParseTplSet(tplSet)\n\t\ttmpOpt = opt\n\t\ttmpOpt.Directory = tplDir\n\t\tts.Set(tplName, &tmpOpt)\n\t}\n\n\treturn func(ctx *Context) {\n\t\tr := &TplRender{\n\t\t\tResponseWriter:  ctx.Resp,\n\t\t\tTemplateSet:     ts,\n\t\t\tOpt:             &opt,\n\t\t\tCompiledCharset: cs,\n\t\t}\n\t\tctx.Data[\"TmplLoadTimes\"] = func() string {\n\t\t\tif r.startTime.IsZero() {\n\t\t\t\treturn \"\"\n\t\t\t}\n\t\t\treturn fmt.Sprint(time.Since(r.startTime).Nanoseconds()/1e6) + \"ms\"\n\t\t}\n\n\t\tctx.Render = r\n\t\tctx.MapTo(r, (*Render)(nil))\n\t}\n}\n\n// Renderer is a Middleware that maps a macaron.Render service into the Macaron handler chain.\n// An single variadic macaron.RenderOptions struct can be optionally provided to configure\n// HTML rendering. The default directory for templates is \"templates\" and the default\n// file extension is \".tmpl\" and \".html\".\n//\n// If MACARON_ENV is set to \"\" or \"development\" then templates will be recompiled on every request. For more performance, set the\n// MACARON_ENV environment variable to \"production\".\nfunc Renderer(options ...RenderOptions) Handler {\n\treturn renderHandler(prepareRenderOptions(options), []string{})\n}\n\nfunc Renderers(options RenderOptions, tplSets ...string) Handler {\n\treturn renderHandler(prepareRenderOptions([]RenderOptions{options}), tplSets)\n}\n\ntype TplRender struct {\n\thttp.ResponseWriter\n\t*TemplateSet\n\tOpt             *RenderOptions\n\tCompiledCharset string\n\n\tstartTime time.Time\n}\n\nfunc (r *TplRender) SetResponseWriter(rw http.ResponseWriter) {\n\tr.ResponseWriter = rw\n}\n\nfunc (r *TplRender) JSON(status int, v interface{}) {\n\tvar (\n\t\tresult []byte\n\t\terr    error\n\t)\n\tif r.Opt.IndentJSON {\n\t\tresult, err = json.MarshalIndent(v, \"\", \"  \")\n\t} else {\n\t\tresult, err = json.Marshal(v)\n\t}\n\tif err != nil {\n\t\thttp.Error(r, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// json rendered fine, write out the result\n\tr.Header().Set(_CONTENT_TYPE, _CONTENT_JSON+r.CompiledCharset)\n\tr.WriteHeader(status)\n\tif len(r.Opt.PrefixJSON) > 0 {\n\t\t_, _ = r.Write(r.Opt.PrefixJSON)\n\t}\n\t_, _ = r.Write(result)\n}\n\nfunc (r *TplRender) JSONString(v interface{}) (string, error) {\n\tvar result []byte\n\tvar err error\n\tif r.Opt.IndentJSON {\n\t\tresult, err = json.MarshalIndent(v, \"\", \"  \")\n\t} else {\n\t\tresult, err = json.Marshal(v)\n\t}\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\treturn string(result), nil\n}\n\nfunc (r *TplRender) XML(status int, v interface{}) {\n\tvar result []byte\n\tvar err error\n\tif r.Opt.IndentXML {\n\t\tresult, err = xml.MarshalIndent(v, \"\", \"  \")\n\t} else {\n\t\tresult, err = xml.Marshal(v)\n\t}\n\tif err != nil {\n\t\thttp.Error(r, err.Error(), 500)\n\t\treturn\n\t}\n\n\t// XML rendered fine, write out the result\n\tr.Header().Set(_CONTENT_TYPE, _CONTENT_XML+r.CompiledCharset)\n\tr.WriteHeader(status)\n\tif len(r.Opt.PrefixXML) > 0 {\n\t\t_, _ = r.Write(r.Opt.PrefixXML)\n\t}\n\t_, _ = r.Write(result)\n}\n\nfunc (r *TplRender) data(status int, contentType string, v []byte) {\n\tif r.Header().Get(_CONTENT_TYPE) == \"\" {\n\t\tr.Header().Set(_CONTENT_TYPE, contentType)\n\t}\n\tr.WriteHeader(status)\n\t_, _ = r.Write(v)\n}\n\nfunc (r *TplRender) RawData(status int, v []byte) {\n\tr.data(status, _CONTENT_BINARY, v)\n}\n\nfunc (r *TplRender) PlainText(status int, v []byte) {\n\tr.data(status, _CONTENT_PLAIN, v)\n}\n\nfunc (r *TplRender) execute(t *template.Template, name string, data interface{}) (*bytes.Buffer, error) {\n\tbuf := bufpool.Get().(*bytes.Buffer)\n\treturn buf, t.ExecuteTemplate(buf, name, data)\n}\n\nfunc (r *TplRender) addYield(t *template.Template, tplName string, data interface{}) {\n\tfuncs := template.FuncMap{\n\t\t\"yield\": func() (template.HTML, error) {\n\t\t\tbuf, err := r.execute(t, tplName, data)\n\t\t\t// return safe html here since we are rendering our own template\n\t\t\treturn template.HTML(buf.String()), err\n\t\t},\n\t\t\"current\": func() (string, error) {\n\t\t\treturn tplName, nil\n\t\t},\n\t}\n\tt.Funcs(funcs)\n}\n\nfunc (r *TplRender) renderBytes(setName, tplName string, data interface{}, htmlOpt ...HTMLOptions) (*bytes.Buffer, error) {\n\tt := r.TemplateSet.Get(setName)\n\tif Env == DEV {\n\t\topt := *r.Opt\n\t\topt.Directory = r.TemplateSet.GetDir(setName)\n\t\tt = r.TemplateSet.Set(setName, &opt)\n\t}\n\tif t == nil {\n\t\treturn nil, fmt.Errorf(\"html/template: template \\\"%s\\\" is undefined\", tplName)\n\t}\n\n\topt := r.prepareHTMLOptions(htmlOpt)\n\n\tif len(opt.Layout) > 0 {\n\t\tr.addYield(t, tplName, data)\n\t\ttplName = opt.Layout\n\t}\n\n\tout, err := r.execute(t, tplName, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn out, nil\n}\n\nfunc (r *TplRender) renderHTML(status int, setName, tplName string, data interface{}, htmlOpt ...HTMLOptions) {\n\tr.startTime = time.Now()\n\n\tout, err := r.renderBytes(setName, tplName, data, htmlOpt...)\n\tif err != nil {\n\t\thttp.Error(r, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tr.Header().Set(_CONTENT_TYPE, r.Opt.HTMLContentType+r.CompiledCharset)\n\tr.WriteHeader(status)\n\n\tif _, err := out.WriteTo(r); err != nil {\n\t\tout.Reset()\n\t}\n\tbufpool.Put(out)\n}\n\nfunc (r *TplRender) HTML(status int, name string, data interface{}, htmlOpt ...HTMLOptions) {\n\tr.renderHTML(status, DEFAULT_TPL_SET_NAME, name, data, htmlOpt...)\n}\n\nfunc (r *TplRender) HTMLSet(status int, setName, tplName string, data interface{}, htmlOpt ...HTMLOptions) {\n\tr.renderHTML(status, setName, tplName, data, htmlOpt...)\n}\n\nfunc (r *TplRender) HTMLSetBytes(setName, tplName string, data interface{}, htmlOpt ...HTMLOptions) ([]byte, error) {\n\tout, err := r.renderBytes(setName, tplName, data, htmlOpt...)\n\tif err != nil {\n\t\treturn []byte(\"\"), err\n\t}\n\treturn out.Bytes(), nil\n}\n\nfunc (r *TplRender) HTMLBytes(name string, data interface{}, htmlOpt ...HTMLOptions) ([]byte, error) {\n\treturn r.HTMLSetBytes(DEFAULT_TPL_SET_NAME, name, data, htmlOpt...)\n}\n\nfunc (r *TplRender) HTMLSetString(setName, tplName string, data interface{}, htmlOpt ...HTMLOptions) (string, error) {\n\tp, err := r.HTMLSetBytes(setName, tplName, data, htmlOpt...)\n\treturn string(p), err\n}\n\nfunc (r *TplRender) HTMLString(name string, data interface{}, htmlOpt ...HTMLOptions) (string, error) {\n\tp, err := r.HTMLBytes(name, data, htmlOpt...)\n\treturn string(p), err\n}\n\n// Error writes the given HTTP status to the current ResponseWriter\nfunc (r *TplRender) Error(status int, message ...string) {\n\tr.WriteHeader(status)\n\tif len(message) > 0 {\n\t\t_, _ = r.Write([]byte(message[0]))\n\t}\n}\n\nfunc (r *TplRender) Status(status int) {\n\tr.WriteHeader(status)\n}\n\nfunc (r *TplRender) prepareHTMLOptions(htmlOpt []HTMLOptions) HTMLOptions {\n\tif len(htmlOpt) > 0 {\n\t\treturn htmlOpt[0]\n\t}\n\n\treturn HTMLOptions{\n\t\tLayout: r.Opt.Layout,\n\t}\n}\n\nfunc (r *TplRender) SetTemplatePath(setName, dir string) {\n\tif len(setName) == 0 {\n\t\tsetName = DEFAULT_TPL_SET_NAME\n\t}\n\topt := *r.Opt\n\topt.Directory = dir\n\tr.TemplateSet.Set(setName, &opt)\n}\n\nfunc (r *TplRender) HasTemplateSet(name string) bool {\n\treturn r.TemplateSet.Get(name) != nil\n}\n\n// DummyRender is used when user does not choose any real render to use.\n// This way, we can print out friendly message which asks them to register one,\n// instead of ugly and confusing 'nil pointer' panic.\ntype DummyRender struct {\n\thttp.ResponseWriter\n}\n\nfunc renderNotRegistered() {\n\tpanic(\"middleware render hasn't been registered\")\n}\n\nfunc (r *DummyRender) SetResponseWriter(http.ResponseWriter) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) JSON(int, interface{}) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) JSONString(interface{}) (string, error) {\n\trenderNotRegistered()\n\treturn \"\", nil\n}\n\nfunc (r *DummyRender) RawData(int, []byte) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) PlainText(int, []byte) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) HTML(int, string, interface{}, ...HTMLOptions) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) HTMLSet(int, string, string, interface{}, ...HTMLOptions) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) HTMLSetString(string, string, interface{}, ...HTMLOptions) (string, error) {\n\trenderNotRegistered()\n\treturn \"\", nil\n}\n\nfunc (r *DummyRender) HTMLString(string, interface{}, ...HTMLOptions) (string, error) {\n\trenderNotRegistered()\n\treturn \"\", nil\n}\n\nfunc (r *DummyRender) HTMLSetBytes(string, string, interface{}, ...HTMLOptions) ([]byte, error) {\n\trenderNotRegistered()\n\treturn nil, nil\n}\n\nfunc (r *DummyRender) HTMLBytes(string, interface{}, ...HTMLOptions) ([]byte, error) {\n\trenderNotRegistered()\n\treturn nil, nil\n}\n\nfunc (r *DummyRender) XML(int, interface{}) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) Error(int, ...string) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) Status(int) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) SetTemplatePath(string, string) {\n\trenderNotRegistered()\n}\n\nfunc (r *DummyRender) HasTemplateSet(string) bool {\n\trenderNotRegistered()\n\treturn false\n}\n"
        },
        {
          "name": "render_test.go",
          "type": "blob",
          "size": 20.0166015625,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"encoding/xml\"\n\t\"html/template\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"runtime\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\ntype Greeting struct {\n\tOne string `json:\"one\"`\n\tTwo string `json:\"two\"`\n}\n\ntype GreetingXML struct {\n\tXMLName xml.Name `xml:\"greeting\"`\n\tOne     string   `xml:\"one,attr\"`\n\tTwo     string   `xml:\"two,attr\"`\n}\n\nfunc Test_Render_JSON(t *testing.T) {\n\tConvey(\"Render JSON\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer())\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.JSON(300, Greeting{\"hello\", \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_JSON+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, `{\"one\":\"hello\",\"two\":\"world\"}`)\n\t})\n\n\tConvey(\"Render JSON with prefix\", t, func() {\n\t\tm := Classic()\n\t\tprefix := \")]}',\\n\"\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tPrefixJSON: []byte(prefix),\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.JSON(300, Greeting{\"hello\", \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_JSON+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, prefix+`{\"one\":\"hello\",\"two\":\"world\"}`)\n\t})\n\n\tConvey(\"Render Indented JSON\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tIndentJSON: true,\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.JSON(300, Greeting{\"hello\", \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_JSON+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, `{\n  \"one\": \"hello\",\n  \"two\": \"world\"\n}`)\n\t})\n\n\tConvey(\"Render JSON and return string\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer())\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tresult, err := r.JSONString(Greeting{\"hello\", \"world\"})\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tSo(result, ShouldEqual, `{\"one\":\"hello\",\"two\":\"world\"}`)\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t})\n\n\tConvey(\"Render with charset JSON\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tCharset: \"foobar\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.JSON(300, Greeting{\"hello\", \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_JSON+\"; charset=foobar\")\n\t\tSo(resp.Body.String(), ShouldEqual, `{\"one\":\"hello\",\"two\":\"world\"}`)\n\t})\n}\n\nfunc Test_Render_XML(t *testing.T) {\n\tConvey(\"Render XML\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer())\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.XML(300, GreetingXML{One: \"hello\", Two: \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_XML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, `<greeting one=\"hello\" two=\"world\"></greeting>`)\n\t})\n\n\tConvey(\"Render XML with prefix\", t, func() {\n\t\tm := Classic()\n\t\tprefix := \")]}',\\n\"\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tPrefixXML: []byte(prefix),\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.XML(300, GreetingXML{One: \"hello\", Two: \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_XML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, prefix+`<greeting one=\"hello\" two=\"world\"></greeting>`)\n\t})\n\n\tConvey(\"Render Indented XML\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tIndentXML: true,\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.XML(300, GreetingXML{One: \"hello\", Two: \"world\"})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusMultipleChoices)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_XML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, `<greeting one=\"hello\" two=\"world\"></greeting>`)\n\t})\n}\n\nfunc Test_Render_HTML(t *testing.T) {\n\tConvey(\"Render HTML\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderers(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}, \"fixtures/basic2\"))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.SetResponseWriter(r.(*TplRender).ResponseWriter)\n\t\t\tr.HTML(200, \"hello\", \"jeremy\")\n\t\t\tr.SetTemplatePath(\"\", \"fixtures/basic2\")\n\t\t})\n\t\tm.Get(\"/foobar2\", func(r Render) {\n\t\t\tif r.HasTemplateSet(\"basic2\") {\n\t\t\t\tr.HTMLSet(200, \"basic2\", \"hello\", \"jeremy\")\n\t\t\t}\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Hello jeremy</h1>\")\n\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"GET\", \"/foobar2\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>What's up, jeremy</h1>\")\n\n\t\tConvey(\"Change render templates path\", func() {\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>What's up, jeremy</h1>\")\n\t\t})\n\t})\n\n\tConvey(\"Render HTML and return string\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderers(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}, \"basic2:fixtures/basic2\"))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tresult, err := r.HTMLString(\"hello\", \"jeremy\")\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tSo(result, ShouldEqual, \"<h1>Hello jeremy</h1>\")\n\t\t})\n\t\tm.Get(\"/foobar2\", func(r Render) {\n\t\t\tresult, err := r.HTMLSetString(\"basic2\", \"hello\", \"jeremy\")\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tSo(result, ShouldEqual, \"<h1>What's up, jeremy</h1>\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"GET\", \"/foobar2\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t})\n\n\tConvey(\"Render with nested HTML\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"admin/index\", \"jeremy\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Admin jeremy</h1>\")\n\t})\n\n\tConvey(\"Render bad HTML\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"nope\", nil)\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusInternalServerError)\n\t\tSo(resp.Body.String(), ShouldEqual, \"html/template: \\\"nope\\\" is undefined\\n\")\n\t})\n\n\tConvey(\"Invalid template set\", t, func() {\n\t\tConvey(\"Empty template set argument\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm := Classic()\n\t\t\tm.Use(Renderers(RenderOptions{\n\t\t\t\tDirectory: \"fixtures/basic\",\n\t\t\t}, \"\"))\n\t\t})\n\n\t\tConvey(\"Bad template set path\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm := Classic()\n\t\t\tm.Use(Renderers(RenderOptions{\n\t\t\t\tDirectory: \"fixtures/basic\",\n\t\t\t}, \"404\"))\n\t\t})\n\t})\n}\n\nfunc Test_Render_XHTML(t *testing.T) {\n\tConvey(\"Render XHTML\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory:       \"fixtures/basic\",\n\t\t\tHTMLContentType: _CONTENT_XHTML,\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"hello\", \"jeremy\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_XHTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Hello jeremy</h1>\")\n\t})\n}\n\nfunc Test_Render_Extensions(t *testing.T) {\n\tConvey(\"Render with extensions\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory:  \"fixtures/basic\",\n\t\t\tExtensions: []string{\".tmpl\", \".html\"},\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"hypertext\", nil)\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"Hypertext!\")\n\t})\n}\n\nfunc Test_Render_Funcs(t *testing.T) {\n\tConvey(\"Render with functions\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/custom_funcs\",\n\t\t\tFuncs: []template.FuncMap{\n\t\t\t\t{\n\t\t\t\t\t\"myCustomFunc\": func() string {\n\t\t\t\t\t\treturn \"My custom function\"\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"index\", \"jeremy\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Body.String(), ShouldEqual, \"My custom function\")\n\t})\n}\n\nfunc Test_Render_Layout(t *testing.T) {\n\tConvey(\"Render with layout\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t\tLayout:    \"layout\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"content\", \"jeremy\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Body.String(), ShouldEqual, \"head<h1>jeremy</h1>foot\")\n\t})\n\n\tConvey(\"Render with current layout\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t\tLayout:    \"current_layout\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"content\", \"jeremy\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Body.String(), ShouldEqual, \"content head<h1>jeremy</h1>content foot\")\n\t})\n\n\tConvey(\"Render with override layout\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t\tLayout:    \"layout\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"content\", \"jeremy\", HTMLOptions{\n\t\t\t\tLayout: \"another_layout\",\n\t\t\t})\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"another head<h1>jeremy</h1>another foot\")\n\t})\n}\n\nfunc Test_Render_Delimiters(t *testing.T) {\n\tConvey(\"Render with delimiters\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDelims:    Delims{\"{[{\", \"}]}\"},\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"delims\", \"jeremy\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_HTML+\"; charset=UTF-8\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Hello jeremy</h1>\")\n\t})\n}\n\nfunc Test_Render_BinaryData(t *testing.T) {\n\tConvey(\"Render binary data\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer())\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.RawData(200, []byte(\"hello there\"))\n\t\t})\n\t\tm.Get(\"/foobar2\", func(r Render) {\n\t\t\tr.PlainText(200, []byte(\"hello there\"))\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_BINARY)\n\t\tSo(resp.Body.String(), ShouldEqual, \"hello there\")\n\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"GET\", \"/foobar2\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, _CONTENT_PLAIN)\n\t\tSo(resp.Body.String(), ShouldEqual, \"hello there\")\n\t})\n\n\tConvey(\"Render binary data with mime type\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer())\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.(*TplRender).ResponseWriter.Header().Set(_CONTENT_TYPE, \"image/jpeg\")\n\t\t\tr.RawData(200, []byte(\"..jpeg data..\"))\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(_CONTENT_TYPE), ShouldEqual, \"image/jpeg\")\n\t\tSo(resp.Body.String(), ShouldEqual, \"..jpeg data..\")\n\t})\n}\n\nfunc Test_Render_Status(t *testing.T) {\n\tConvey(\"Render with status 204\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\tr := TplRender{resp, NewTemplateSet(), &RenderOptions{}, \"\", time.Now()}\n\t\tr.Status(204)\n\t\tSo(resp.Code, ShouldEqual, http.StatusNoContent)\n\t})\n\n\tConvey(\"Render with status 404\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\tr := TplRender{resp, NewTemplateSet(), &RenderOptions{}, \"\", time.Now()}\n\t\tr.Error(404)\n\t\tSo(resp.Code, ShouldEqual, http.StatusNotFound)\n\t})\n\n\tConvey(\"Render with status 500\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\tr := TplRender{resp, NewTemplateSet(), &RenderOptions{}, \"\", time.Now()}\n\t\tr.Error(500)\n\t\tSo(resp.Code, ShouldEqual, http.StatusInternalServerError)\n\t})\n}\n\nfunc Test_Render_NoRace(t *testing.T) {\n\tConvey(\"Make sure render has no race\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/basic\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"hello\", \"world\")\n\t\t})\n\n\t\tdone := make(chan bool)\n\t\tdoreq := func() {\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, _ := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tdone <- true\n\t\t}\n\t\t// Run two requests to check there is no race condition\n\t\tgo doreq()\n\t\tgo doreq()\n\t\t<-done\n\t\t<-done\n\t})\n}\n\nfunc Test_Render_Symlink(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip(\"Skipping testing on Windows\")\n\t}\n\n\tConvey(\"Render can follow symlinks\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory: \"fixtures/symlink\",\n\t\t}))\n\t\tm.Get(\"/foobar\", func(r Render) {\n\t\t\tr.HTML(200, \"hello\", \"world\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/foobar\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t})\n}\n\nfunc Test_Render_AppendDirectories(t *testing.T) {\n\tConvey(\"Render with additional templates\", t, func() {\n\t\tm := Classic()\n\t\tm.Use(Renderer(RenderOptions{\n\t\t\tDirectory:         \"fixtures/basic\",\n\t\t\tAppendDirectories: []string{\"fixtures/basic/custom\"},\n\t\t}))\n\n\t\tConvey(\"Request normal template\", func() {\n\t\t\tm.Get(\"/normal\", func(r Render) {\n\t\t\t\tr.HTML(200, \"content\", \"Macaron\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/normal\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>Macaron</h1>\")\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t})\n\n\t\tConvey(\"Request overwritten template\", func() {\n\t\t\tm.Get(\"/custom\", func(r Render) {\n\t\t\t\tr.HTML(200, \"hello\", \"world\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/custom\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"<h1>This is custom version of: Hello world</h1>\")\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t})\n\n\t})\n}\n\nfunc Test_GetExt(t *testing.T) {\n\tConvey(\"Get extension\", t, func() {\n\t\tSo(GetExt(\"test\"), ShouldBeBlank)\n\t\tSo(GetExt(\"test.tmpl\"), ShouldEqual, \".tmpl\")\n\t\tSo(GetExt(\"test.go.tmpl\"), ShouldEqual, \".go.tmpl\")\n\t})\n}\n\nfunc Test_dummyRender(t *testing.T) {\n\tshouldPanic := func() { So(recover(), ShouldNotBeNil) }\n\n\tConvey(\"Use dummy render to gracefully handle panic\", t, func() {\n\t\tm := New()\n\n\t\tperformRequest := func(method, path string) {\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(method, path, nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t}\n\n\t\tm.Get(\"/set_response_writer\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.SetResponseWriter(nil)\n\t\t})\n\t\tm.Get(\"/json\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.JSON(0, nil)\n\t\t})\n\t\tm.Get(\"/jsonstring\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\t_, _ = ctx.JSONString(nil)\n\t\t})\n\t\tm.Get(\"/rawdata\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.RawData(0, nil)\n\t\t})\n\t\tm.Get(\"/plaintext\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.PlainText(0, nil)\n\t\t})\n\t\tm.Get(\"/html\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.Render.HTML(0, \"\", nil)\n\t\t})\n\t\tm.Get(\"/htmlset\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.Render.HTMLSet(0, \"\", \"\", nil)\n\t\t})\n\t\tm.Get(\"/htmlsetstring\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\t_, _ = ctx.Render.HTMLSetString(\"\", \"\", nil)\n\t\t})\n\t\tm.Get(\"/htmlstring\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\t_, _ = ctx.Render.HTMLString(\"\", nil)\n\t\t})\n\t\tm.Get(\"/htmlsetbytes\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\t_, _ = ctx.Render.HTMLSetBytes(\"\", \"\", nil)\n\t\t})\n\t\tm.Get(\"/htmlbytes\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\t_, _ = ctx.Render.HTMLBytes(\"\", nil)\n\t\t})\n\t\tm.Get(\"/xml\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.XML(0, nil)\n\t\t})\n\t\tm.Get(\"/error\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.Error(0)\n\t\t})\n\t\tm.Get(\"/status\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.Status(0)\n\t\t})\n\t\tm.Get(\"/settemplatepath\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.SetTemplatePath(\"\", \"\")\n\t\t})\n\t\tm.Get(\"/hastemplateset\", func(ctx *Context) {\n\t\t\tdefer shouldPanic()\n\t\t\tctx.HasTemplateSet(\"\")\n\t\t})\n\n\t\tperformRequest(\"GET\", \"/set_response_writer\")\n\t\tperformRequest(\"GET\", \"/json\")\n\t\tperformRequest(\"GET\", \"/jsonstring\")\n\t\tperformRequest(\"GET\", \"/rawdata\")\n\t\tperformRequest(\"GET\", \"/jsonstring\")\n\t\tperformRequest(\"GET\", \"/plaintext\")\n\t\tperformRequest(\"GET\", \"/html\")\n\t\tperformRequest(\"GET\", \"/htmlset\")\n\t\tperformRequest(\"GET\", \"/htmlsetstring\")\n\t\tperformRequest(\"GET\", \"/htmlstring\")\n\t\tperformRequest(\"GET\", \"/htmlsetbytes\")\n\t\tperformRequest(\"GET\", \"/htmlbytes\")\n\t\tperformRequest(\"GET\", \"/xml\")\n\t\tperformRequest(\"GET\", \"/error\")\n\t\tperformRequest(\"GET\", \"/status\")\n\t\tperformRequest(\"GET\", \"/settemplatepath\")\n\t\tperformRequest(\"GET\", \"/hastemplateset\")\n\t})\n}\n"
        },
        {
          "name": "response_writer.go",
          "type": "blob",
          "size": 3.4375,
          "content": "// Copyright 2013 Martini Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// ResponseWriter is a wrapper around http.ResponseWriter that provides extra information about\n// the response. It is recommended that middleware handlers use this construct to wrap a responsewriter\n// if the functionality calls for it.\ntype ResponseWriter interface {\n\thttp.ResponseWriter\n\thttp.Flusher\n\thttp.Pusher\n\t// Status returns the status code of the response or 0 if the response has not been written.\n\tStatus() int\n\t// Written returns whether or not the ResponseWriter has been written.\n\tWritten() bool\n\t// Size returns the size of the response body.\n\tSize() int\n\t// Before allows for a function to be called before the ResponseWriter has been written to. This is\n\t// useful for setting headers or any other operations that must happen before a response has been written.\n\tBefore(BeforeFunc)\n}\n\n// BeforeFunc is a function that is called before the ResponseWriter has been written to.\ntype BeforeFunc func(ResponseWriter)\n\n// NewResponseWriter creates a ResponseWriter that wraps an http.ResponseWriter\nfunc NewResponseWriter(method string, rw http.ResponseWriter) ResponseWriter {\n\treturn &responseWriter{method, rw, 0, 0, nil}\n}\n\ntype responseWriter struct {\n\tmethod string\n\thttp.ResponseWriter\n\tstatus      int\n\tsize        int\n\tbeforeFuncs []BeforeFunc\n}\n\nfunc (rw *responseWriter) WriteHeader(s int) {\n\trw.callBefore()\n\trw.ResponseWriter.WriteHeader(s)\n\trw.status = s\n}\n\nfunc (rw *responseWriter) Write(b []byte) (size int, err error) {\n\tif !rw.Written() {\n\t\t// The status will be StatusOK if WriteHeader has not been called yet\n\t\trw.WriteHeader(http.StatusOK)\n\t}\n\tif rw.method != \"HEAD\" {\n\t\tsize, err = rw.ResponseWriter.Write(b)\n\t\trw.size += size\n\t}\n\treturn size, err\n}\n\nfunc (rw *responseWriter) Status() int {\n\treturn rw.status\n}\n\nfunc (rw *responseWriter) Size() int {\n\treturn rw.size\n}\n\nfunc (rw *responseWriter) Written() bool {\n\treturn rw.status != 0\n}\n\nfunc (rw *responseWriter) Before(before BeforeFunc) {\n\trw.beforeFuncs = append(rw.beforeFuncs, before)\n}\n\nfunc (rw *responseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\thijacker, ok := rw.ResponseWriter.(http.Hijacker)\n\tif !ok {\n\t\treturn nil, nil, errors.New(\"the ResponseWriter doesn't support the Hijacker interface\")\n\t}\n\treturn hijacker.Hijack()\n}\n\n//nolint\nfunc (rw *responseWriter) CloseNotify() <-chan bool {\n\treturn rw.ResponseWriter.(http.CloseNotifier).CloseNotify()\n}\n\nfunc (rw *responseWriter) callBefore() {\n\tfor i := len(rw.beforeFuncs) - 1; i >= 0; i-- {\n\t\trw.beforeFuncs[i](rw)\n\t}\n}\n\nfunc (rw *responseWriter) Flush() {\n\tflusher, ok := rw.ResponseWriter.(http.Flusher)\n\tif ok {\n\t\tflusher.Flush()\n\t}\n}\n\nfunc (rw *responseWriter) Push(target string, opts *http.PushOptions) error {\n\tpusher, ok := rw.ResponseWriter.(http.Pusher)\n\tif !ok {\n\t\treturn errors.New(\"the ResponseWriter doesn't support the Pusher interface\")\n\t}\n\treturn pusher.Push(target, opts)\n}\n"
        },
        {
          "name": "response_writer_test.go",
          "type": "blob",
          "size": 5.2841796875,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\ntype closeNotifyingRecorder struct {\n\t*httptest.ResponseRecorder\n\tclosed chan bool\n}\n\nfunc newCloseNotifyingRecorder() *closeNotifyingRecorder {\n\treturn &closeNotifyingRecorder{\n\t\thttptest.NewRecorder(),\n\t\tmake(chan bool, 1),\n\t}\n}\n\nfunc (c *closeNotifyingRecorder) close() {\n\tc.closed <- true\n}\n\nfunc (c *closeNotifyingRecorder) CloseNotify() <-chan bool {\n\treturn c.closed\n}\n\ntype hijackableResponse struct {\n\tHijacked bool\n}\n\nfunc newHijackableResponse() *hijackableResponse {\n\treturn &hijackableResponse{}\n}\n\nfunc (h *hijackableResponse) Header() http.Header           { return nil }\nfunc (h *hijackableResponse) Write(buf []byte) (int, error) { return 0, nil }\nfunc (h *hijackableResponse) WriteHeader(code int)          {}\nfunc (h *hijackableResponse) Flush()                        {}\nfunc (h *hijackableResponse) Hijack() (net.Conn, *bufio.ReadWriter, error) {\n\th.Hijacked = true\n\treturn nil, nil, nil\n}\n\nfunc Test_ResponseWriter(t *testing.T) {\n\tConvey(\"Write string to response writer\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\t_, _ = rw.Write([]byte(\"Hello world\"))\n\n\t\tSo(resp.Code, ShouldEqual, rw.Status())\n\t\tSo(resp.Body.String(), ShouldEqual, \"Hello world\")\n\t\tSo(rw.Status(), ShouldEqual, http.StatusOK)\n\t\tSo(rw.Size(), ShouldEqual, 11)\n\t\tSo(rw.Written(), ShouldBeTrue)\n\t})\n\n\tConvey(\"Write strings to response writer\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\t_, _ = rw.Write([]byte(\"Hello world\"))\n\t\t_, _ = rw.Write([]byte(\"foo bar bat baz\"))\n\n\t\tSo(resp.Code, ShouldEqual, rw.Status())\n\t\tSo(resp.Body.String(), ShouldEqual, \"Hello worldfoo bar bat baz\")\n\t\tSo(rw.Status(), ShouldEqual, http.StatusOK)\n\t\tSo(rw.Size(), ShouldEqual, 26)\n\t\tSo(rw.Written(), ShouldBeTrue)\n\t})\n\n\tConvey(\"Write header to response writer\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\trw.WriteHeader(http.StatusNotFound)\n\n\t\tSo(resp.Code, ShouldEqual, rw.Status())\n\t\tSo(resp.Body.String(), ShouldBeBlank)\n\t\tSo(rw.Status(), ShouldEqual, http.StatusNotFound)\n\t\tSo(rw.Size(), ShouldEqual, 0)\n\t})\n\n\tConvey(\"Write before response write\", t, func() {\n\t\tresult := \"\"\n\t\tresp := httptest.NewRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\trw.Before(func(ResponseWriter) {\n\t\t\tresult += \"foo\"\n\t\t})\n\t\trw.Before(func(ResponseWriter) {\n\t\t\tresult += \"bar\"\n\t\t})\n\t\trw.WriteHeader(http.StatusNotFound)\n\n\t\tSo(resp.Code, ShouldEqual, rw.Status())\n\t\tSo(resp.Body.String(), ShouldBeBlank)\n\t\tSo(rw.Status(), ShouldEqual, http.StatusNotFound)\n\t\tSo(rw.Size(), ShouldEqual, 0)\n\t\tSo(result, ShouldEqual, \"barfoo\")\n\t})\n\n\tConvey(\"Response writer with Hijack\", t, func() {\n\t\thijackable := newHijackableResponse()\n\t\trw := NewResponseWriter(\"GET\", hijackable)\n\t\thijacker, ok := rw.(http.Hijacker)\n\t\tSo(ok, ShouldBeTrue)\n\t\t_, _, err := hijacker.Hijack()\n\t\tSo(err, ShouldBeNil)\n\t\tSo(hijackable.Hijacked, ShouldBeTrue)\n\t})\n\n\tConvey(\"Response writer with bad Hijack\", t, func() {\n\t\thijackable := new(http.ResponseWriter)\n\t\trw := NewResponseWriter(\"GET\", *hijackable)\n\t\thijacker, ok := rw.(http.Hijacker)\n\t\tSo(ok, ShouldBeTrue)\n\t\t_, _, err := hijacker.Hijack()\n\t\tSo(err, ShouldNotBeNil)\n\t})\n\n\tConvey(\"Response writer with close notify\", t, func() {\n\t\tresp := newCloseNotifyingRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\tclosed := false\n\t\tnotifier := rw.(http.CloseNotifier).CloseNotify() //nolint\n\t\tresp.close()\n\t\tselect {\n\t\tcase <-notifier:\n\t\t\tclosed = true\n\t\tcase <-time.After(time.Second):\n\t\t}\n\t\tSo(closed, ShouldBeTrue)\n\t})\n\n\tConvey(\"Response writer with flusher\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\t_, ok := rw.(http.Flusher)\n\t\tSo(ok, ShouldBeTrue)\n\t})\n\n\tConvey(\"Response writer with flusher handler\", t, func() {\n\t\tm := Classic()\n\t\tm.Get(\"/events\", func(w http.ResponseWriter, r *http.Request) {\n\t\t\tf, ok := w.(http.Flusher)\n\t\t\tSo(ok, ShouldBeTrue)\n\n\t\t\tw.Header().Set(\"Content-Type\", \"text/event-stream\")\n\t\t\tw.Header().Set(\"Cache-Control\", \"no-cache\")\n\t\t\tw.Header().Set(\"Connection\", \"keep-alive\")\n\n\t\t\tfor i := 0; i < 2; i++ {\n\t\t\t\ttime.Sleep(10 * time.Millisecond)\n\t\t\t\t_, _ = io.WriteString(w, \"data: Hello\\n\\n\")\n\t\t\t\tf.Flush()\n\t\t\t}\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/events\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Body.String(), ShouldEqual, \"data: Hello\\n\\ndata: Hello\\n\\n\")\n\t})\n\n\tConvey(\"Response writer with http/2 push\", t, func() {\n\t\tresp := httptest.NewRecorder()\n\t\trw := NewResponseWriter(\"GET\", resp)\n\t\t_, ok := rw.(http.Pusher)\n\t\tSo(ok, ShouldBeTrue)\n\t})\n}\n"
        },
        {
          "name": "return_handler.go",
          "type": "blob",
          "size": 2.1201171875,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"net/http\"\n\t\"reflect\"\n\n\t\"github.com/go-macaron/inject\"\n)\n\n// ReturnHandler is a service that Martini provides that is called\n// when a route handler returns something. The ReturnHandler is\n// responsible for writing to the ResponseWriter based on the values\n// that are passed into this function.\ntype ReturnHandler func(*Context, []reflect.Value)\n\nfunc canDeref(val reflect.Value) bool {\n\treturn val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr\n}\n\nfunc isError(val reflect.Value) bool {\n\t_, ok := val.Interface().(error)\n\treturn ok\n}\n\nfunc isByteSlice(val reflect.Value) bool {\n\treturn val.Kind() == reflect.Slice && val.Type().Elem().Kind() == reflect.Uint8\n}\n\nfunc defaultReturnHandler() ReturnHandler {\n\treturn func(ctx *Context, vals []reflect.Value) {\n\t\trv := ctx.GetVal(inject.InterfaceOf((*http.ResponseWriter)(nil)))\n\t\tresp := rv.Interface().(http.ResponseWriter)\n\t\tvar respVal reflect.Value\n\t\tif len(vals) > 1 && vals[0].Kind() == reflect.Int {\n\t\t\tresp.WriteHeader(int(vals[0].Int()))\n\t\t\trespVal = vals[1]\n\t\t} else if len(vals) > 0 {\n\t\t\trespVal = vals[0]\n\n\t\t\tif isError(respVal) {\n\t\t\t\terr := respVal.Interface().(error)\n\t\t\t\tif err != nil {\n\t\t\t\t\tctx.internalServerError(ctx, err)\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t} else if canDeref(respVal) {\n\t\t\t\tif respVal.IsNil() {\n\t\t\t\t\treturn // Ignore nil error\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif canDeref(respVal) {\n\t\t\trespVal = respVal.Elem()\n\t\t}\n\t\tif isByteSlice(respVal) {\n\t\t\t_, _ = resp.Write(respVal.Bytes())\n\t\t} else {\n\t\t\t_, _ = resp.Write([]byte(respVal.String()))\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "return_handler_test.go",
          "type": "blob",
          "size": 3.083984375,
          "content": "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\ntype r1Invoker func() (int, string)\n\nfunc (l r1Invoker) Invoke(p []interface{}) ([]reflect.Value, error) {\n\tret, str := l()\n\treturn []reflect.Value{reflect.ValueOf(ret), reflect.ValueOf(str)}, nil\n}\n\nfunc Test_Return_Handler(t *testing.T) {\n\tConvey(\"Return with status and body\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() (int, string) {\n\t\t\treturn 418, \"i'm a teapot\"\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusTeapot)\n\t\tSo(resp.Body.String(), ShouldEqual, \"i'm a teapot\")\n\t})\n\n\tConvey(\"Return with status and body-FastInvoke\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", r1Invoker(func() (int, string) {\n\t\t\treturn 418, \"i'm a teapot\"\n\t\t}))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusTeapot)\n\t\tSo(resp.Body.String(), ShouldEqual, \"i'm a teapot\")\n\t})\n\n\tConvey(\"Return with error\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() error {\n\t\t\treturn errors.New(\"what the hell!!!\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusInternalServerError)\n\t\tSo(resp.Body.String(), ShouldEqual, \"what the hell!!!\\n\")\n\n\t\tConvey(\"Return with nil error\", func() {\n\t\t\tm := New()\n\t\t\tm.Get(\"/\", func() error {\n\t\t\t\treturn nil\n\t\t\t}, func() (int, string) {\n\t\t\t\treturn 200, \"Awesome\"\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t\tSo(resp.Body.String(), ShouldEqual, \"Awesome\")\n\t\t})\n\t})\n\n\tConvey(\"Return with pointer\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() *string {\n\t\t\tstr := \"hello world\"\n\t\t\treturn &str\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Body.String(), ShouldEqual, \"hello world\")\n\t})\n\n\tConvey(\"Return with byte slice\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() []byte {\n\t\t\treturn []byte(\"hello world\")\n\t\t})\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Body.String(), ShouldEqual, \"hello world\")\n\t})\n}\n"
        },
        {
          "name": "router.go",
          "type": "blob",
          "size": 9.9189453125,
          "content": "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"net/http\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar (\n\t// Known HTTP methods.\n\t_HTTP_METHODS = map[string]bool{\n\t\t\"GET\":     true,\n\t\t\"POST\":    true,\n\t\t\"PUT\":     true,\n\t\t\"DELETE\":  true,\n\t\t\"PATCH\":   true,\n\t\t\"OPTIONS\": true,\n\t\t\"HEAD\":    true,\n\t}\n)\n\n// routeMap represents a thread-safe map for route tree.\ntype routeMap struct {\n\tlock   sync.RWMutex\n\troutes map[string]map[string]*Leaf\n}\n\n// NewRouteMap initializes and returns a new routeMap.\nfunc NewRouteMap() *routeMap {\n\trm := &routeMap{\n\t\troutes: make(map[string]map[string]*Leaf),\n\t}\n\tfor m := range _HTTP_METHODS {\n\t\trm.routes[m] = make(map[string]*Leaf)\n\t}\n\treturn rm\n}\n\n// getLeaf returns Leaf object if a route has been registered.\nfunc (rm *routeMap) getLeaf(method, pattern string) *Leaf {\n\trm.lock.RLock()\n\tdefer rm.lock.RUnlock()\n\n\treturn rm.routes[method][pattern]\n}\n\n// add adds new route to route tree map.\nfunc (rm *routeMap) add(method, pattern string, leaf *Leaf) {\n\trm.lock.Lock()\n\tdefer rm.lock.Unlock()\n\n\trm.routes[method][pattern] = leaf\n}\n\ntype group struct {\n\tpattern  string\n\thandlers []Handler\n}\n\n// Router represents a Macaron router layer.\ntype Router struct {\n\tm        *Macaron\n\tautoHead bool\n\trouters  map[string]*Tree\n\t*routeMap\n\tnamedRoutes map[string]*Leaf\n\n\tgroups              []group\n\tnotFound            http.HandlerFunc\n\tinternalServerError func(*Context, error)\n\n\t// handlerWrapper is used to wrap arbitrary function from Handler to inject.FastInvoker.\n\thandlerWrapper func(Handler) Handler\n}\n\nfunc NewRouter() *Router {\n\treturn &Router{\n\t\trouters:     make(map[string]*Tree),\n\t\trouteMap:    NewRouteMap(),\n\t\tnamedRoutes: make(map[string]*Leaf),\n\t}\n}\n\n// SetAutoHead sets the value who determines whether add HEAD method automatically\n// when GET method is added.\nfunc (r *Router) SetAutoHead(v bool) {\n\tr.autoHead = v\n}\n\ntype Params map[string]string\n\n// Handle is a function that can be registered to a route to handle HTTP requests.\n// Like http.HandlerFunc, but has a third parameter for the values of wildcards (variables).\ntype Handle func(http.ResponseWriter, *http.Request, Params)\n\n// Route represents a wrapper of leaf route and upper level router.\ntype Route struct {\n\trouter *Router\n\tleaf   *Leaf\n}\n\n// Name sets name of route.\nfunc (r *Route) Name(name string) {\n\tif len(name) == 0 {\n\t\tpanic(\"route name cannot be empty\")\n\t} else if r.router.namedRoutes[name] != nil {\n\t\tpanic(\"route with given name already exists: \" + name)\n\t}\n\tr.router.namedRoutes[name] = r.leaf\n}\n\n// handle adds new route to the router tree.\nfunc (r *Router) handle(method, pattern string, handle Handle) *Route {\n\tmethod = strings.ToUpper(method)\n\n\tvar leaf *Leaf\n\t// Prevent duplicate routes.\n\tif leaf = r.getLeaf(method, pattern); leaf != nil {\n\t\treturn &Route{r, leaf}\n\t}\n\n\t// Validate HTTP methods.\n\tif !_HTTP_METHODS[method] && method != \"*\" {\n\t\tpanic(\"unknown HTTP method: \" + method)\n\t}\n\n\t// Generate methods need register.\n\tmethods := make(map[string]bool)\n\tif method == \"*\" {\n\t\tfor m := range _HTTP_METHODS {\n\t\t\tmethods[m] = true\n\t\t}\n\t} else {\n\t\tmethods[method] = true\n\t}\n\n\t// Add to router tree.\n\tfor m := range methods {\n\t\tif t, ok := r.routers[m]; ok {\n\t\t\tleaf = t.Add(pattern, handle)\n\t\t} else {\n\t\t\tt := NewTree()\n\t\t\tleaf = t.Add(pattern, handle)\n\t\t\tr.routers[m] = t\n\t\t}\n\t\tr.add(m, pattern, leaf)\n\t}\n\treturn &Route{r, leaf}\n}\n\n// Handle registers a new request handle with the given pattern, method and handlers.\nfunc (r *Router) Handle(method string, pattern string, handlers []Handler) *Route {\n\tif len(r.groups) > 0 {\n\t\tgroupPattern := \"\"\n\t\th := make([]Handler, 0)\n\t\tfor _, g := range r.groups {\n\t\t\tgroupPattern += g.pattern\n\t\t\th = append(h, g.handlers...)\n\t\t}\n\n\t\tpattern = groupPattern + pattern\n\t\th = append(h, handlers...)\n\t\thandlers = h\n\t}\n\thandlers = validateAndWrapHandlers(handlers, r.handlerWrapper)\n\n\treturn r.handle(method, pattern, func(resp http.ResponseWriter, req *http.Request, params Params) {\n\t\tc := r.m.createContext(resp, req)\n\t\tc.params = params\n\t\tc.handlers = make([]Handler, 0, len(r.m.handlers)+len(handlers))\n\t\tc.handlers = append(c.handlers, r.m.handlers...)\n\t\tc.handlers = append(c.handlers, handlers...)\n\t\tc.run()\n\t})\n}\n\nfunc (r *Router) Group(pattern string, fn func(), h ...Handler) {\n\tr.groups = append(r.groups, group{pattern, h})\n\tfn()\n\tr.groups = r.groups[:len(r.groups)-1]\n}\n\n// Get is a shortcut for r.Handle(\"GET\", pattern, handlers)\nfunc (r *Router) Get(pattern string, h ...Handler) (leaf *Route) {\n\tleaf = r.Handle(\"GET\", pattern, h)\n\tif r.autoHead {\n\t\tr.Head(pattern, h...)\n\t}\n\treturn leaf\n}\n\n// Patch is a shortcut for r.Handle(\"PATCH\", pattern, handlers)\nfunc (r *Router) Patch(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"PATCH\", pattern, h)\n}\n\n// Post is a shortcut for r.Handle(\"POST\", pattern, handlers)\nfunc (r *Router) Post(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"POST\", pattern, h)\n}\n\n// Put is a shortcut for r.Handle(\"PUT\", pattern, handlers)\nfunc (r *Router) Put(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"PUT\", pattern, h)\n}\n\n// Delete is a shortcut for r.Handle(\"DELETE\", pattern, handlers)\nfunc (r *Router) Delete(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"DELETE\", pattern, h)\n}\n\n// Options is a shortcut for r.Handle(\"OPTIONS\", pattern, handlers)\nfunc (r *Router) Options(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"OPTIONS\", pattern, h)\n}\n\n// Head is a shortcut for r.Handle(\"HEAD\", pattern, handlers)\nfunc (r *Router) Head(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"HEAD\", pattern, h)\n}\n\n// Any is a shortcut for r.Handle(\"*\", pattern, handlers)\nfunc (r *Router) Any(pattern string, h ...Handler) *Route {\n\treturn r.Handle(\"*\", pattern, h)\n}\n\n// Route is a shortcut for same handlers but different HTTP methods.\n//\n// Example:\n//\n//\tm.Route(\"/\", \"GET,POST\", h)\nfunc (r *Router) Route(pattern, methods string, h ...Handler) (route *Route) {\n\tfor _, m := range strings.Split(methods, \",\") {\n\t\troute = r.Handle(strings.TrimSpace(m), pattern, h)\n\t}\n\treturn route\n}\n\n// Combo returns a combo router.\nfunc (r *Router) Combo(pattern string, h ...Handler) *ComboRouter {\n\treturn &ComboRouter{r, pattern, h, map[string]bool{}, nil}\n}\n\n// NotFound configurates http.HandlerFunc which is called when no matching route is\n// found. If it is not set, http.NotFound is used.\n// Be sure to set 404 response code in your handler.\nfunc (r *Router) NotFound(handlers ...Handler) {\n\thandlers = validateAndWrapHandlers(handlers)\n\tr.notFound = func(rw http.ResponseWriter, req *http.Request) {\n\t\tc := r.m.createContext(rw, req)\n\t\tc.handlers = make([]Handler, 0, len(r.m.handlers)+len(handlers))\n\t\tc.handlers = append(c.handlers, r.m.handlers...)\n\t\tc.handlers = append(c.handlers, handlers...)\n\t\tc.run()\n\t}\n}\n\n// InternalServerError configurates handler which is called when route handler returns\n// error. If it is not set, default handler is used.\n// Be sure to set 500 response code in your handler.\nfunc (r *Router) InternalServerError(handlers ...Handler) {\n\thandlers = validateAndWrapHandlers(handlers)\n\tr.internalServerError = func(c *Context, err error) {\n\t\tc.index = 0\n\t\tc.handlers = handlers\n\t\tc.Map(err)\n\t\tc.run()\n\t}\n}\n\n// SetHandlerWrapper sets handlerWrapper for the router.\nfunc (r *Router) SetHandlerWrapper(f func(Handler) Handler) {\n\tr.handlerWrapper = f\n}\n\nfunc (r *Router) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\tif t, ok := r.routers[req.Method]; ok {\n\t\t// Fast match for static routes\n\t\tleaf := r.getLeaf(req.Method, req.URL.Path)\n\t\tif leaf != nil {\n\t\t\tleaf.handle(rw, req, nil)\n\t\t\treturn\n\t\t}\n\n\t\th, p, ok := t.Match(req.URL.EscapedPath())\n\t\tif ok {\n\t\t\tif splat, ok := p[\"*0\"]; ok {\n\t\t\t\tp[\"*\"] = splat // Easy name.\n\t\t\t}\n\t\t\th(rw, req, p)\n\t\t\treturn\n\t\t}\n\t}\n\n\tr.notFound(rw, req)\n}\n\n// URLFor builds path part of URL by given pair values.\nfunc (r *Router) URLFor(name string, pairs ...string) string {\n\tleaf, ok := r.namedRoutes[name]\n\tif !ok {\n\t\tpanic(\"route with given name does not exists: \" + name)\n\t}\n\treturn leaf.URLPath(pairs...)\n}\n\n// ComboRouter represents a combo router.\ntype ComboRouter struct {\n\trouter   *Router\n\tpattern  string\n\thandlers []Handler\n\tmethods  map[string]bool // Registered methods.\n\n\tlastRoute *Route\n}\n\nfunc (cr *ComboRouter) checkMethod(name string) {\n\tif cr.methods[name] {\n\t\tpanic(\"method '\" + name + \"' has already been registered\")\n\t}\n\tcr.methods[name] = true\n}\n\nfunc (cr *ComboRouter) route(fn func(string, ...Handler) *Route, method string, h ...Handler) *ComboRouter {\n\tcr.checkMethod(method)\n\tcr.lastRoute = fn(cr.pattern, append(cr.handlers, h...)...)\n\treturn cr\n}\n\nfunc (cr *ComboRouter) Get(h ...Handler) *ComboRouter {\n\tif cr.router.autoHead {\n\t\tcr.Head(h...)\n\t}\n\treturn cr.route(cr.router.Get, \"GET\", h...)\n}\n\nfunc (cr *ComboRouter) Patch(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Patch, \"PATCH\", h...)\n}\n\nfunc (cr *ComboRouter) Post(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Post, \"POST\", h...)\n}\n\nfunc (cr *ComboRouter) Put(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Put, \"PUT\", h...)\n}\n\nfunc (cr *ComboRouter) Delete(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Delete, \"DELETE\", h...)\n}\n\nfunc (cr *ComboRouter) Options(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Options, \"OPTIONS\", h...)\n}\n\nfunc (cr *ComboRouter) Head(h ...Handler) *ComboRouter {\n\treturn cr.route(cr.router.Head, \"HEAD\", h...)\n}\n\n// Name sets name of ComboRouter route.\nfunc (cr *ComboRouter) Name(name string) {\n\tif cr.lastRoute == nil {\n\t\tpanic(\"no corresponding route to be named\")\n\t}\n\tcr.lastRoute.Name(name)\n}\n"
        },
        {
          "name": "router_test.go",
          "type": "blob",
          "size": 8.89453125,
          "content": "// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"errors\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"reflect\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_Router_Handle(t *testing.T) {\n\ttest_Router_Handle(t, false)\n}\nfunc Test_Router_FastInvoker_Handle(t *testing.T) {\n\ttest_Router_Handle(t, true)\n}\n\n// handlerFunc0Invoker func()string Invoker Handler\ntype handlerFunc0Invoker func() string\n\n// Invoke handlerFunc0Invoker\nfunc (l handlerFunc0Invoker) Invoke(p []interface{}) ([]reflect.Value, error) {\n\tret := l()\n\treturn []reflect.Value{reflect.ValueOf(ret)}, nil\n}\n\nfunc test_Router_Handle(t *testing.T, isFast bool) {\n\tConvey(\"Register all HTTP methods routes\", t, func() {\n\t\tm := New()\n\n\t\tif isFast {\n\t\t\t// FastInvoker Handler Wrap Action\n\t\t\tm.Router.SetHandlerWrapper(func(h Handler) Handler {\n\t\t\t\tswitch v := h.(type) {\n\t\t\t\tcase func() string:\n\t\t\t\t\treturn handlerFunc0Invoker(v)\n\t\t\t\t}\n\t\t\t\treturn h\n\t\t\t})\n\t\t}\n\n\t\tm.Get(\"/get\", func() string {\n\t\t\treturn \"GET\"\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/get\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"GET\")\n\n\t\tm.Patch(\"/patch\", func() string {\n\t\t\treturn \"PATCH\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"PATCH\", \"/patch\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"PATCH\")\n\n\t\tm.Post(\"/post\", func() string {\n\t\t\treturn \"POST\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"POST\", \"/post\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"POST\")\n\n\t\tm.Put(\"/put\", func() string {\n\t\t\treturn \"PUT\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"PUT\", \"/put\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"PUT\")\n\n\t\tm.Delete(\"/delete\", func() string {\n\t\t\treturn \"DELETE\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"DELETE\", \"/delete\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"DELETE\")\n\n\t\tm.Options(\"/options\", func() string {\n\t\t\treturn \"OPTIONS\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"OPTIONS\", \"/options\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"OPTIONS\")\n\n\t\tm.Head(\"/head\", func() string {\n\t\t\treturn \"HEAD\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"HEAD\", \"/head\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldHaveLength, 0)\n\n\t\tm.Any(\"/any\", func() string {\n\t\t\treturn \"ANY\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"GET\", \"/any\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"ANY\")\n\n\t\tm.Route(\"/route\", \"GET,POST\", func() string {\n\t\t\treturn \"ROUTE\"\n\t\t})\n\t\tresp = httptest.NewRecorder()\n\t\treq, err = http.NewRequest(\"POST\", \"/route\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"ROUTE\")\n\n\t\tif isFast {\n\t\t\t//remove Handler Wrap Action\n\t\t\tm.Router.SetHandlerWrapper(nil)\n\t\t}\n\t})\n\n\tConvey(\"Register with or without auto head\", t, func() {\n\t\tConvey(\"Without auto head\", func() {\n\t\t\tm := New()\n\t\t\tm.Get(\"/\", func() string {\n\t\t\t\treturn \"GET\"\n\t\t\t})\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"HEAD\", \"/\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Code, ShouldEqual, 404)\n\t\t})\n\n\t\tConvey(\"With auto head\", func() {\n\t\t\tm := New()\n\t\t\tm.SetAutoHead(true)\n\t\t\tm.Get(\"/\", func() string {\n\t\t\t\treturn \"GET\"\n\t\t\t})\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"HEAD\", \"/\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Code, ShouldEqual, 200)\n\t\t})\n\t})\n\n\tConvey(\"Register all HTTP methods routes with combo\", t, func() {\n\t\tm := New()\n\t\tm.SetURLPrefix(\"/prefix\")\n\t\tm.Use(Renderer())\n\t\tm.Combo(\"/\", func(ctx *Context) {\n\t\t\tctx.Data[\"prefix\"] = \"Prefix_\"\n\t\t}).\n\t\t\tGet(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"GET\" }).\n\t\t\tPatch(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"PATCH\" }).\n\t\t\tPost(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"POST\" }).\n\t\t\tPut(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"PUT\" }).\n\t\t\tDelete(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"DELETE\" }).\n\t\t\tOptions(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"OPTIONS\" }).\n\t\t\tHead(func(ctx *Context) string { return ctx.Data[\"prefix\"].(string) + \"HEAD\" })\n\n\t\tfor name := range _HTTP_METHODS {\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(name, \"/\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tif name == \"HEAD\" {\n\t\t\t\tSo(resp.Body.String(), ShouldHaveLength, 0)\n\t\t\t} else {\n\t\t\t\tSo(resp.Body.String(), ShouldEqual, \"Prefix_\"+name)\n\t\t\t}\n\t\t}\n\n\t\tdefer func() {\n\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t}()\n\t\tm.Combo(\"/\").Get(func() {}).Get(nil)\n\t})\n\n\tConvey(\"Register duplicated routes\", t, func() {\n\t\tr := NewRouter()\n\t\tr.Get(\"/\")\n\t\tr.Get(\"/\")\n\t})\n\n\tConvey(\"Register invalid HTTP method\", t, func() {\n\t\tdefer func() {\n\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t}()\n\t\tr := NewRouter()\n\t\tr.Handle(\"404\", \"/\", nil)\n\t})\n}\n\nfunc Test_Route_Name(t *testing.T) {\n\tConvey(\"Set route name\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() {}).Name(\"home\")\n\n\t\tdefer func() {\n\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t}()\n\t\tm.Get(\"/\", func() {}).Name(\"home\")\n\t})\n\n\tConvey(\"Set combo router name\", t, func() {\n\t\tm := New()\n\t\tm.Combo(\"/\").Get(func() {}).Name(\"home\")\n\n\t\tdefer func() {\n\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t}()\n\t\tm.Combo(\"/\").Name(\"home\")\n\t})\n}\n\nfunc Test_Router_URLFor(t *testing.T) {\n\tConvey(\"Build URL path\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/user/:id\", func() {}).Name(\"user_id\")\n\t\tm.Get(\"/user/:id/:name\", func() {}).Name(\"user_id_name\")\n\t\tm.Get(\"cms_:id_:page.html\", func() {}).Name(\"id_page\")\n\n\t\tSo(m.URLFor(\"user_id\", \"id\", \"12\"), ShouldEqual, \"/user/12\")\n\t\tSo(m.URLFor(\"user_id_name\", \"id\", \"12\", \"name\", \"unknwon\"), ShouldEqual, \"/user/12/unknwon\")\n\t\tSo(m.URLFor(\"id_page\", \"id\", \"12\", \"page\", \"profile\"), ShouldEqual, \"/cms_12_profile.html\")\n\n\t\tConvey(\"Number of pair values does not match\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm.URLFor(\"user_id\", \"id\")\n\t\t})\n\n\t\tConvey(\"Empty pair value\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm.URLFor(\"user_id\", \"\", \"\")\n\t\t})\n\n\t\tConvey(\"Empty route name\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm.Get(\"/user/:id\", func() {}).Name(\"\")\n\t\t})\n\n\t\tConvey(\"Invalid route name\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\t\t\tm.URLFor(\"404\")\n\t\t})\n\t})\n}\n\nfunc Test_Router_Group(t *testing.T) {\n\tConvey(\"Register route group\", t, func() {\n\t\tm := New()\n\t\tm.Group(\"/api\", func() {\n\t\t\tm.Group(\"/v1\", func() {\n\t\t\t\tm.Get(\"/list\", func() string {\n\t\t\t\t\treturn \"Well done!\"\n\t\t\t\t})\n\t\t\t})\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/api/v1/list\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"Well done!\")\n\t})\n}\n\nfunc Test_Router_NotFound(t *testing.T) {\n\tConvey(\"Custom not found handler\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() {})\n\t\tm.NotFound(func() string {\n\t\t\treturn \"Custom not found\"\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/404\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"Custom not found\")\n\t})\n}\n\nfunc Test_Router_InternalServerError(t *testing.T) {\n\tConvey(\"Custom internal server error handler\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/\", func() error {\n\t\t\treturn errors.New(\"Custom internal server error\")\n\t\t})\n\t\tm.InternalServerError(func(rw http.ResponseWriter, err error) {\n\t\t\trw.WriteHeader(500)\n\t\t\t_, _ = rw.Write([]byte(err.Error()))\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, 500)\n\t\tSo(resp.Body.String(), ShouldEqual, \"Custom internal server error\")\n\t})\n}\n\nfunc Test_Router_splat(t *testing.T) {\n\tConvey(\"Register router with glob\", t, func() {\n\t\tm := New()\n\t\tm.Get(\"/*\", func(ctx *Context) string {\n\t\t\treturn ctx.Params(\"*\")\n\t\t})\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"/hahaha\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Body.String(), ShouldEqual, \"hahaha\")\n\t})\n}\n"
        },
        {
          "name": "static.go",
          "type": "blob",
          "size": 5.9580078125,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n)\n\n// StaticOptions is a struct for specifying configuration options for the macaron.Static middleware.\ntype StaticOptions struct {\n\t// Prefix is the optional prefix used to serve the static directory content\n\tPrefix string\n\t// SkipLogging will disable [Static] log messages when a static file is served.\n\tSkipLogging bool\n\t// IndexFile defines which file to serve as index if it exists.\n\tIndexFile string\n\t// Expires defines which user-defined function to use for producing a HTTP Expires Header\n\t// https://developers.google.com/speed/docs/insights/LeverageBrowserCaching\n\tExpires func() string\n\t// ETag defines if we should add an ETag header\n\t// https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching#validating-cached-responses-with-etags\n\tETag bool\n\t// FileSystem is the interface for supporting any implmentation of file system.\n\tFileSystem http.FileSystem\n}\n\n// FIXME: to be deleted.\ntype staticMap struct {\n\tlock sync.RWMutex\n\tdata map[string]*http.Dir\n}\n\nfunc (sm *staticMap) Set(dir *http.Dir) {\n\tsm.lock.Lock()\n\tdefer sm.lock.Unlock()\n\n\tsm.data[string(*dir)] = dir\n}\n\nfunc (sm *staticMap) Get(name string) *http.Dir {\n\tsm.lock.RLock()\n\tdefer sm.lock.RUnlock()\n\n\treturn sm.data[name]\n}\n\nfunc (sm *staticMap) Delete(name string) {\n\tsm.lock.Lock()\n\tdefer sm.lock.Unlock()\n\n\tdelete(sm.data, name)\n}\n\nvar statics = staticMap{sync.RWMutex{}, map[string]*http.Dir{}}\n\n// staticFileSystem implements http.FileSystem interface.\ntype staticFileSystem struct {\n\tdir *http.Dir\n}\n\nfunc newStaticFileSystem(directory string) staticFileSystem {\n\tif !filepath.IsAbs(directory) {\n\t\tdirectory = filepath.Join(Root, directory)\n\t}\n\tdir := http.Dir(directory)\n\tstatics.Set(&dir)\n\treturn staticFileSystem{&dir}\n}\n\nfunc (fs staticFileSystem) Open(name string) (http.File, error) {\n\treturn fs.dir.Open(name)\n}\n\nfunc prepareStaticOption(dir string, opt StaticOptions) StaticOptions {\n\t// Defaults\n\tif len(opt.IndexFile) == 0 {\n\t\topt.IndexFile = \"index.html\"\n\t}\n\t// Normalize the prefix if provided\n\tif opt.Prefix != \"\" {\n\t\t// Ensure we have a leading '/'\n\t\tif opt.Prefix[0] != '/' {\n\t\t\topt.Prefix = \"/\" + opt.Prefix\n\t\t}\n\t\t// Remove any trailing '/'\n\t\topt.Prefix = strings.TrimRight(opt.Prefix, \"/\")\n\t}\n\tif opt.FileSystem == nil {\n\t\topt.FileSystem = newStaticFileSystem(dir)\n\t}\n\treturn opt\n}\n\nfunc prepareStaticOptions(dir string, options []StaticOptions) StaticOptions {\n\tvar opt StaticOptions\n\tif len(options) > 0 {\n\t\topt = options[0]\n\t}\n\treturn prepareStaticOption(dir, opt)\n}\n\nfunc staticHandler(ctx *Context, log *log.Logger, opt StaticOptions) bool {\n\tif ctx.Req.Method != \"GET\" && ctx.Req.Method != \"HEAD\" {\n\t\treturn false\n\t}\n\n\tfile := ctx.Req.URL.Path\n\t// if we have a prefix, filter requests by stripping the prefix\n\tif opt.Prefix != \"\" {\n\t\tif !strings.HasPrefix(file, opt.Prefix) {\n\t\t\treturn false\n\t\t}\n\t\tfile = file[len(opt.Prefix):]\n\t\tif file != \"\" && file[0] != '/' {\n\t\t\treturn false\n\t\t}\n\t}\n\n\tf, err := opt.FileSystem.Open(file)\n\tif err != nil {\n\t\treturn false\n\t}\n\tdefer f.Close()\n\n\tfi, err := f.Stat()\n\tif err != nil {\n\t\treturn true // File exists but fail to open.\n\t}\n\n\t// Try to serve index file\n\tif fi.IsDir() {\n\t\tredirPath := path.Clean(ctx.Req.URL.Path)\n\t\t// path.Clean removes the trailing slash, so we need to add it back when\n\t\t// the original path has it.\n\t\tif strings.HasSuffix(ctx.Req.URL.Path, \"/\") {\n\t\t\tredirPath = redirPath + \"/\"\n\t\t}\n\t\t// Redirect if missing trailing slash.\n\t\tif !strings.HasSuffix(redirPath, \"/\") {\n\t\t\thttp.Redirect(ctx.Resp, ctx.Req.Request, redirPath+\"/\", http.StatusFound)\n\t\t\treturn true\n\t\t}\n\n\t\tfile = path.Join(file, opt.IndexFile)\n\t\tf, err = opt.FileSystem.Open(file)\n\t\tif err != nil {\n\t\t\treturn false // Discard error.\n\t\t}\n\t\tdefer f.Close()\n\n\t\tfi, err = f.Stat()\n\t\tif err != nil || fi.IsDir() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tif !opt.SkipLogging {\n\t\tlog.Println(\"[Static] Serving \" + file)\n\t}\n\n\t// Add an Expires header to the static content\n\tif opt.Expires != nil {\n\t\tctx.Resp.Header().Set(\"Expires\", opt.Expires())\n\t}\n\n\tif opt.ETag {\n\t\ttag := `\"` + GenerateETag(fmt.Sprintf(\"%d\", fi.Size()), fi.Name(), fi.ModTime().UTC().Format(http.TimeFormat)) + `\"`\n\t\tctx.Resp.Header().Set(\"ETag\", tag)\n\t\tif ctx.Req.Header.Get(\"If-None-Match\") == tag {\n\t\t\tctx.Resp.WriteHeader(http.StatusNotModified)\n\t\t\treturn true\n\t\t}\n\t}\n\n\thttp.ServeContent(ctx.Resp, ctx.Req.Request, file, fi.ModTime(), f)\n\treturn true\n}\n\n// GenerateETag generates an ETag based on size, filename and file modification time\nfunc GenerateETag(fileSize, fileName, modTime string) string {\n\tetag := fileSize + fileName + modTime\n\treturn base64.StdEncoding.EncodeToString([]byte(etag))\n}\n\n// Static returns a middleware handler that serves static files in the given directory.\nfunc Static(directory string, staticOpt ...StaticOptions) Handler {\n\topt := prepareStaticOptions(directory, staticOpt)\n\n\treturn func(ctx *Context, log *log.Logger) {\n\t\tstaticHandler(ctx, log, opt)\n\t}\n}\n\n// Statics registers multiple static middleware handlers all at once.\nfunc Statics(opt StaticOptions, dirs ...string) Handler {\n\tif len(dirs) == 0 {\n\t\tpanic(\"no static directory is given\")\n\t}\n\topts := make([]StaticOptions, len(dirs))\n\tfor i := range dirs {\n\t\topts[i] = prepareStaticOption(dirs[i], opt)\n\t}\n\n\treturn func(ctx *Context, log *log.Logger) {\n\t\tfor i := range opts {\n\t\t\tif staticHandler(ctx, log, opts[i]) {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "static_test.go",
          "type": "blob",
          "size": 8.8046875,
          "content": "// Copyright 2013 Martini Authors\n// Copyright 2014 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"path\"\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nvar currentRoot, _ = os.Getwd()\n\nfunc Test_Static(t *testing.T) {\n\tConvey(\"Serve static files\", t, func() {\n\t\tm := New()\n\t\tm.Use(Static(\"./\"))\n\n\t\tresp := httptest.NewRecorder()\n\t\tresp.Body = new(bytes.Buffer)\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(\"Expires\"), ShouldBeBlank)\n\t\tSo(resp.Body.Len(), ShouldBeGreaterThan, 0)\n\n\t\tConvey(\"Change static path\", func() {\n\t\t\tm.Get(\"/\", func(ctx *Context) {\n\t\t\t\tctx.ChangeStaticPath(\"./\", \"fixtures/basic2\")\n\t\t\t})\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"/\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\tresp.Body = new(bytes.Buffer)\n\t\t\treq, err = http.NewRequest(\"GET\", \"http://localhost:4000/hello.tmpl\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t\tSo(resp.Header().Get(\"Expires\"), ShouldBeBlank)\n\t\t\tSo(resp.Body.Len(), ShouldBeGreaterThan, 0)\n\t\t})\n\t})\n\n\tConvey(\"Serve static files with local path\", t, func() {\n\t\tRoot = os.TempDir()\n\t\tf, err := os.CreateTemp(Root, \"static_content\")\n\t\tSo(err, ShouldBeNil)\n\t\t_, _ = f.WriteString(\"Expected Content\")\n\t\tf.Close()\n\n\t\tm := New()\n\t\tm.Use(Static(\".\"))\n\n\t\tresp := httptest.NewRecorder()\n\t\tresp.Body = new(bytes.Buffer)\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/\"+path.Base(strings.Replace(f.Name(), \"\\\\\", \"/\", -1)), nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Header().Get(\"Expires\"), ShouldBeBlank)\n\t\tSo(resp.Body.String(), ShouldEqual, \"Expected Content\")\n\t})\n\n\tConvey(\"Serve static files with head\", t, func() {\n\t\tm := New()\n\t\tm.Use(Static(currentRoot))\n\n\t\tresp := httptest.NewRecorder()\n\t\tresp.Body = new(bytes.Buffer)\n\t\treq, err := http.NewRequest(\"HEAD\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(resp.Body.Len(), ShouldEqual, 0)\n\t})\n\n\tConvey(\"Serve static files as post\", t, func() {\n\t\tm := New()\n\t\tm.Use(Static(currentRoot))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"POST\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldEqual, http.StatusNotFound)\n\t})\n\n\tConvey(\"Serve static files with bad directory\", t, func() {\n\t\tm := Classic()\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\tSo(resp.Code, ShouldNotEqual, http.StatusOK)\n\t})\n}\n\nfunc Test_Static_Options(t *testing.T) {\n\tConvey(\"Serve static files with options logging\", t, func() {\n\t\tvar buf bytes.Buffer\n\t\tm := NewWithLogger(&buf)\n\t\topt := StaticOptions{}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(buf.String(), ShouldEqual, \"[Macaron] [Static] Serving /macaron.go\\n\")\n\n\t\t// Not disable logging.\n\t\tm.Handlers()\n\t\tbuf.Reset()\n\t\topt.SkipLogging = true\n\t\tm.Use(Static(currentRoot, opt))\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(buf.Len(), ShouldEqual, 0)\n\t})\n\n\tConvey(\"Serve static files with options serve index\", t, func() {\n\t\tvar buf bytes.Buffer\n\t\tm := NewWithLogger(&buf)\n\t\topt := StaticOptions{IndexFile: \"macaron.go\"}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(buf.String(), ShouldEqual, \"[Macaron] [Static] Serving /macaron.go\\n\")\n\t})\n\n\tConvey(\"Serve static files with options prefix\", t, func() {\n\t\tvar buf bytes.Buffer\n\t\tm := NewWithLogger(&buf)\n\t\topt := StaticOptions{Prefix: \"public\"}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/public/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\tSo(buf.String(), ShouldEqual, \"[Macaron] [Static] Serving /macaron.go\\n\")\n\t})\n\n\tConvey(\"Serve static files with options expires\", t, func() {\n\t\tm := New()\n\t\topt := StaticOptions{Expires: func() string { return \"46\" }}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Header().Get(\"Expires\"), ShouldEqual, \"46\")\n\t})\n\n\tConvey(\"Serve static files with options ETag\", t, func() {\n\t\tm := New()\n\t\topt := StaticOptions{ETag: true}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\ttag := GenerateETag(fmt.Sprintf(\"%d\", resp.Body.Len()), \"macaron.go\", resp.Header().Get(\"last-modified\"))\n\n\t\tSo(resp.Header().Get(\"ETag\"), ShouldEqual, `\"`+tag+`\"`)\n\t})\n\n\tConvey(\"Serve static files with ETag in If-None-Match\", t, func() {\n\t\tm := New()\n\t\topt := StaticOptions{ETag: true}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\t\ttag := GenerateETag(fmt.Sprintf(\"%d\", resp.Body.Len()), \"macaron.go\", resp.Header().Get(\"last-modified\"))\n\n\t\t// Second request with ETag in If-None-Match\n\t\tresp = httptest.NewRecorder()\n\t\treq.Header.Add(\"If-None-Match\", `\"`+tag+`\"`)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusNotModified)\n\t\tSo(len(resp.Body.Bytes()), ShouldEqual, 0)\n\t})\n}\n\nfunc Test_Static_Redirect(t *testing.T) {\n\tConvey(\"Serve static files with prefix without redirect\", t, func() {\n\t\tm := New()\n\t\topt := StaticOptions{Prefix: \"/public\"}\n\t\tm.Use(Static(currentRoot, opt))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/public/\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusNotFound)\n\t})\n\n\tConvey(\"Serve static files with redirect\", t, func() {\n\t\tm := New()\n\t\tm.Use(Static(currentRoot, StaticOptions{Prefix: \"/public\"}))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/public\", nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusFound)\n\t\tSo(resp.Header().Get(\"Location\"), ShouldEqual, \"/public/\")\n\t})\n\n\tConvey(\"Serve static files with improper request\", t, func() {\n\t\tm := New()\n\t\tm.Use(Static(currentRoot))\n\n\t\tresp := httptest.NewRecorder()\n\t\treq, err := http.NewRequest(\"GET\", `http://localhost:4000//example.com%2f..`, nil)\n\t\tSo(err, ShouldBeNil)\n\t\tm.ServeHTTP(resp, req)\n\n\t\tSo(resp.Code, ShouldEqual, http.StatusNotFound)\n\t})\n}\n\nfunc Test_Statics(t *testing.T) {\n\tConvey(\"Serve multiple static routers\", t, func() {\n\t\tConvey(\"Register empty directory\", func() {\n\t\t\tdefer func() {\n\t\t\t\tSo(recover(), ShouldNotBeNil)\n\t\t\t}()\n\n\t\t\tm := New()\n\t\t\tm.Use(Statics(StaticOptions{}))\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\t\t})\n\n\t\tConvey(\"Serve normally\", func() {\n\t\t\tvar buf bytes.Buffer\n\t\t\tm := NewWithLogger(&buf)\n\t\t\tm.Use(Statics(StaticOptions{}, currentRoot, currentRoot+\"/fixtures/basic\"))\n\n\t\t\tresp := httptest.NewRecorder()\n\t\t\treq, err := http.NewRequest(\"GET\", \"http://localhost:4000/macaron.go\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t\tSo(buf.String(), ShouldEqual, \"[Macaron] [Static] Serving /macaron.go\\n\")\n\n\t\t\tresp = httptest.NewRecorder()\n\t\t\treq, err = http.NewRequest(\"GET\", \"http://localhost:4000/admin/index.tmpl\", nil)\n\t\t\tSo(err, ShouldBeNil)\n\t\t\tm.ServeHTTP(resp, req)\n\n\t\t\tSo(resp.Code, ShouldEqual, http.StatusOK)\n\t\t\tSo(buf.String(), ShouldEndWith, \"[Macaron] [Static] Serving /admin/index.tmpl\\n\")\n\t\t})\n\t})\n}\n"
        },
        {
          "name": "tree.go",
          "type": "blob",
          "size": 10.2666015625,
          "content": "// Copyright 2015 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\tgourl \"net/url\"\n\t\"regexp\"\n\t\"strings\"\n\n\t\"github.com/unknwon/com\"\n)\n\ntype patternType int8\n\nconst (\n\t_PATTERN_STATIC    patternType = iota // /home\n\t_PATTERN_REGEXP                       // /:id([0-9]+)\n\t_PATTERN_PATH_EXT                     // /*.*\n\t_PATTERN_HOLDER                       // /:user\n\t_PATTERN_MATCH_ALL                    // /*\n)\n\n// Leaf represents a leaf route information.\ntype Leaf struct {\n\tparent *Tree\n\n\ttyp        patternType\n\tpattern    string\n\trawPattern string // Contains wildcard instead of regexp\n\twildcards  []string\n\treg        *regexp.Regexp\n\toptional   bool\n\n\thandle Handle\n}\n\nvar wildcardPattern = regexp.MustCompile(`:[a-zA-Z0-9]+`)\n\nfunc isSpecialRegexp(pattern, regStr string, pos []int) bool {\n\treturn len(pattern) >= pos[1]+len(regStr) && pattern[pos[1]:pos[1]+len(regStr)] == regStr\n}\n\n// getNextWildcard tries to find next wildcard and update pattern with corresponding regexp.\nfunc getNextWildcard(pattern string) (wildcard, _ string) {\n\tpos := wildcardPattern.FindStringIndex(pattern)\n\tif pos == nil {\n\t\treturn \"\", pattern\n\t}\n\twildcard = pattern[pos[0]:pos[1]]\n\n\t// Reach last character or no regexp is given.\n\tif len(pattern) == pos[1] {\n\t\treturn wildcard, strings.Replace(pattern, wildcard, `(.+)`, 1)\n\t} else if pattern[pos[1]] != '(' {\n\t\tswitch {\n\t\tcase isSpecialRegexp(pattern, \":int\", pos):\n\t\t\tpattern = strings.Replace(pattern, \":int\", \"([0-9]+)\", 1)\n\t\tcase isSpecialRegexp(pattern, \":string\", pos):\n\t\t\tpattern = strings.Replace(pattern, \":string\", \"([\\\\w]+)\", 1)\n\t\tdefault:\n\t\t\treturn wildcard, strings.Replace(pattern, wildcard, `(.+)`, 1)\n\t\t}\n\t}\n\n\t// Cut out placeholder directly.\n\treturn wildcard, pattern[:pos[0]] + pattern[pos[1]:]\n}\n\nfunc getWildcards(pattern string) (string, []string) {\n\twildcards := make([]string, 0, 2)\n\n\t// Keep getting next wildcard until nothing is left.\n\tvar wildcard string\n\tfor {\n\t\twildcard, pattern = getNextWildcard(pattern)\n\t\tif len(wildcard) > 0 {\n\t\t\twildcards = append(wildcards, wildcard)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn pattern, wildcards\n}\n\n// getRawPattern removes all regexp but keeps wildcards for building URL path.\nfunc getRawPattern(rawPattern string) string {\n\trawPattern = strings.Replace(rawPattern, \":int\", \"\", -1)\n\trawPattern = strings.Replace(rawPattern, \":string\", \"\", -1)\n\n\tfor {\n\t\tstartIdx := strings.Index(rawPattern, \"(\")\n\t\tif startIdx == -1 {\n\t\t\tbreak\n\t\t}\n\n\t\tcloseIdx := strings.Index(rawPattern, \")\")\n\t\tif closeIdx > -1 {\n\t\t\trawPattern = rawPattern[:startIdx] + rawPattern[closeIdx+1:]\n\t\t}\n\t}\n\treturn rawPattern\n}\n\nfunc checkPattern(pattern string) (typ patternType, rawPattern string, wildcards []string, reg *regexp.Regexp) {\n\tpattern = strings.TrimLeft(pattern, \"?\")\n\trawPattern = getRawPattern(pattern)\n\n\tif pattern == \"*\" {\n\t\ttyp = _PATTERN_MATCH_ALL\n\t} else if pattern == \"*.*\" {\n\t\ttyp = _PATTERN_PATH_EXT\n\t} else if strings.Contains(pattern, \":\") {\n\t\ttyp = _PATTERN_REGEXP\n\t\tpattern, wildcards = getWildcards(pattern)\n\t\tif pattern == \"(.+)\" {\n\t\t\ttyp = _PATTERN_HOLDER\n\t\t} else {\n\t\t\treg = regexp.MustCompile(pattern)\n\t\t}\n\t}\n\treturn typ, rawPattern, wildcards, reg\n}\n\nfunc NewLeaf(parent *Tree, pattern string, handle Handle) *Leaf {\n\ttyp, rawPattern, wildcards, reg := checkPattern(pattern)\n\toptional := false\n\tif len(pattern) > 0 && pattern[0] == '?' {\n\t\toptional = true\n\t}\n\treturn &Leaf{parent, typ, pattern, rawPattern, wildcards, reg, optional, handle}\n}\n\n// URLPath build path part of URL by given pair values.\nfunc (l *Leaf) URLPath(pairs ...string) string {\n\tif len(pairs)%2 != 0 {\n\t\tpanic(\"number of pairs does not match\")\n\t}\n\n\turlPath := l.rawPattern\n\tparent := l.parent\n\tfor parent != nil {\n\t\turlPath = parent.rawPattern + \"/\" + urlPath\n\t\tparent = parent.parent\n\t}\n\tfor i := 0; i < len(pairs); i += 2 {\n\t\tif len(pairs[i]) == 0 {\n\t\t\tpanic(\"pair value cannot be empty: \" + com.ToStr(i))\n\t\t} else if pairs[i][0] != ':' && pairs[i] != \"*\" && pairs[i] != \"*.*\" {\n\t\t\tpairs[i] = \":\" + pairs[i]\n\t\t}\n\t\turlPath = strings.Replace(urlPath, pairs[i], pairs[i+1], 1)\n\t}\n\treturn urlPath\n}\n\n// Tree represents a router tree in Macaron.\ntype Tree struct {\n\tparent *Tree\n\n\ttyp        patternType\n\tpattern    string\n\trawPattern string\n\twildcards  []string\n\treg        *regexp.Regexp\n\n\tsubtrees []*Tree\n\tleaves   []*Leaf\n}\n\nfunc NewSubtree(parent *Tree, pattern string) *Tree {\n\ttyp, rawPattern, wildcards, reg := checkPattern(pattern)\n\treturn &Tree{parent, typ, pattern, rawPattern, wildcards, reg, make([]*Tree, 0, 5), make([]*Leaf, 0, 5)}\n}\n\nfunc NewTree() *Tree {\n\treturn NewSubtree(nil, \"\")\n}\n\nfunc (t *Tree) addLeaf(pattern string, handle Handle) *Leaf {\n\tfor i := 0; i < len(t.leaves); i++ {\n\t\tif t.leaves[i].pattern == pattern {\n\t\t\treturn t.leaves[i]\n\t\t}\n\t}\n\n\tleaf := NewLeaf(t, pattern, handle)\n\n\t// Add exact same leaf to grandparent/parent level without optional.\n\tif leaf.optional {\n\t\tparent := leaf.parent\n\t\tif parent.parent != nil {\n\t\t\tparent.parent.addLeaf(parent.pattern, handle)\n\t\t} else {\n\t\t\tparent.addLeaf(\"\", handle) // Root tree can add as empty pattern.\n\t\t}\n\t}\n\n\ti := 0\n\tfor ; i < len(t.leaves); i++ {\n\t\tif leaf.typ < t.leaves[i].typ {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif i == len(t.leaves) {\n\t\tt.leaves = append(t.leaves, leaf)\n\t} else {\n\t\tt.leaves = append(t.leaves[:i], append([]*Leaf{leaf}, t.leaves[i:]...)...)\n\t}\n\treturn leaf\n}\n\nfunc (t *Tree) addSubtree(segment, pattern string, handle Handle) *Leaf {\n\tfor i := 0; i < len(t.subtrees); i++ {\n\t\tif t.subtrees[i].pattern == segment {\n\t\t\treturn t.subtrees[i].addNextSegment(pattern, handle)\n\t\t}\n\t}\n\n\tsubtree := NewSubtree(t, segment)\n\ti := 0\n\tfor ; i < len(t.subtrees); i++ {\n\t\tif subtree.typ < t.subtrees[i].typ {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif i == len(t.subtrees) {\n\t\tt.subtrees = append(t.subtrees, subtree)\n\t} else {\n\t\tt.subtrees = append(t.subtrees[:i], append([]*Tree{subtree}, t.subtrees[i:]...)...)\n\t}\n\treturn subtree.addNextSegment(pattern, handle)\n}\n\nfunc (t *Tree) addNextSegment(pattern string, handle Handle) *Leaf {\n\tpattern = strings.TrimPrefix(pattern, \"/\")\n\n\ti := strings.Index(pattern, \"/\")\n\tif i == -1 {\n\t\treturn t.addLeaf(pattern, handle)\n\t}\n\treturn t.addSubtree(pattern[:i], pattern[i+1:], handle)\n}\n\nfunc (t *Tree) Add(pattern string, handle Handle) *Leaf {\n\tpattern = strings.TrimSuffix(pattern, \"/\")\n\treturn t.addNextSegment(pattern, handle)\n}\n\nfunc (t *Tree) matchLeaf(globLevel int, url string, params Params) (Handle, bool) {\n\turl, err := gourl.PathUnescape(url)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\tfor i := 0; i < len(t.leaves); i++ {\n\t\tswitch t.leaves[i].typ {\n\t\tcase _PATTERN_STATIC:\n\t\t\tif t.leaves[i].pattern == url {\n\t\t\t\treturn t.leaves[i].handle, true\n\t\t\t}\n\t\tcase _PATTERN_REGEXP:\n\t\t\tresults := t.leaves[i].reg.FindStringSubmatch(url)\n\t\t\t// Number of results and wildcasrd should be exact same.\n\t\t\tif len(results)-1 != len(t.leaves[i].wildcards) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(t.leaves[i].wildcards); j++ {\n\t\t\t\tparams[t.leaves[i].wildcards[j]] = results[j+1]\n\t\t\t}\n\t\t\treturn t.leaves[i].handle, true\n\t\tcase _PATTERN_PATH_EXT:\n\t\t\tj := strings.LastIndex(url, \".\")\n\t\t\tif j > -1 {\n\t\t\t\tparams[\":path\"] = url[:j]\n\t\t\t\tparams[\":ext\"] = url[j+1:]\n\t\t\t} else {\n\t\t\t\tparams[\":path\"] = url\n\t\t\t}\n\t\t\treturn t.leaves[i].handle, true\n\t\tcase _PATTERN_HOLDER:\n\t\t\tparams[t.leaves[i].wildcards[0]] = url\n\t\t\treturn t.leaves[i].handle, true\n\t\tcase _PATTERN_MATCH_ALL:\n\t\t\tparams[\"*\"] = url\n\t\t\tparams[\"*\"+com.ToStr(globLevel)] = url\n\t\t\treturn t.leaves[i].handle, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (t *Tree) matchSubtree(globLevel int, segment, url string, params Params) (Handle, bool) {\n\tunescapedSegment, err := gourl.PathUnescape(segment)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\tfor i := 0; i < len(t.subtrees); i++ {\n\t\tswitch t.subtrees[i].typ {\n\t\tcase _PATTERN_STATIC:\n\t\t\tif t.subtrees[i].pattern == unescapedSegment {\n\t\t\t\tif handle, ok := t.subtrees[i].matchNextSegment(globLevel, url, params); ok {\n\t\t\t\t\treturn handle, true\n\t\t\t\t}\n\t\t\t}\n\t\tcase _PATTERN_REGEXP:\n\t\t\tresults := t.subtrees[i].reg.FindStringSubmatch(unescapedSegment)\n\t\t\tif len(results)-1 != len(t.subtrees[i].wildcards) {\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tfor j := 0; j < len(t.subtrees[i].wildcards); j++ {\n\t\t\t\tparams[t.subtrees[i].wildcards[j]] = results[j+1]\n\t\t\t}\n\t\t\tif handle, ok := t.subtrees[i].matchNextSegment(globLevel, url, params); ok {\n\t\t\t\treturn handle, true\n\t\t\t}\n\t\tcase _PATTERN_HOLDER:\n\t\t\tif handle, ok := t.subtrees[i].matchNextSegment(globLevel+1, url, params); ok {\n\t\t\t\tparams[t.subtrees[i].wildcards[0]] = unescapedSegment\n\t\t\t\treturn handle, true\n\t\t\t}\n\t\tcase _PATTERN_MATCH_ALL:\n\t\t\tif handle, ok := t.subtrees[i].matchNextSegment(globLevel+1, url, params); ok {\n\t\t\t\tparams[\"*\"+com.ToStr(globLevel)] = unescapedSegment\n\t\t\t\treturn handle, true\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(t.leaves) > 0 {\n\t\tleaf := t.leaves[len(t.leaves)-1]\n\t\tunescapedURL, err := gourl.PathUnescape(segment + \"/\" + url)\n\t\tif err != nil {\n\t\t\treturn nil, false\n\t\t}\n\t\tif leaf.typ == _PATTERN_PATH_EXT {\n\t\t\tj := strings.LastIndex(unescapedURL, \".\")\n\t\t\tif j > -1 {\n\t\t\t\tparams[\":path\"] = unescapedURL[:j]\n\t\t\t\tparams[\":ext\"] = unescapedURL[j+1:]\n\t\t\t} else {\n\t\t\t\tparams[\":path\"] = unescapedURL\n\t\t\t}\n\t\t\treturn leaf.handle, true\n\t\t} else if leaf.typ == _PATTERN_MATCH_ALL {\n\t\t\tparams[\"*\"] = unescapedURL\n\t\t\tparams[\"*\"+com.ToStr(globLevel)] = unescapedURL\n\t\t\treturn leaf.handle, true\n\t\t}\n\t}\n\treturn nil, false\n}\n\nfunc (t *Tree) matchNextSegment(globLevel int, url string, params Params) (Handle, bool) {\n\ti := strings.Index(url, \"/\")\n\tif i == -1 {\n\t\treturn t.matchLeaf(globLevel, url, params)\n\t}\n\treturn t.matchSubtree(globLevel, url[:i], url[i+1:], params)\n}\n\nfunc (t *Tree) Match(url string) (Handle, Params, bool) {\n\turl = strings.TrimPrefix(url, \"/\")\n\turl = strings.TrimSuffix(url, \"/\")\n\tparams := make(Params)\n\thandle, ok := t.matchNextSegment(0, url, params)\n\treturn handle, params, ok\n}\n\n// MatchTest returns true if given URL is matched by given pattern.\nfunc MatchTest(pattern, url string) bool {\n\tt := NewTree()\n\tt.Add(pattern, nil)\n\t_, _, ok := t.Match(url)\n\treturn ok\n}\n"
        },
        {
          "name": "tree_test.go",
          "type": "blob",
          "size": 7.818359375,
          "content": "// Copyright 2015 The Macaron Authors\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"): you may\n// not use this file except in compliance with the License. You may obtain\n// a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n// License for the specific language governing permissions and limitations\n// under the License.\n\npackage macaron\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t. \"github.com/smartystreets/goconvey/convey\"\n)\n\nfunc Test_getWildcards(t *testing.T) {\n\ttype result struct {\n\t\tpattern   string\n\t\twildcards string\n\t}\n\tcases := map[string]result{\n\t\t\"admin\":                             {\"admin\", \"\"},\n\t\t\":id\":                               {\"(.+)\", \":id\"},\n\t\t\":id:int\":                           {\"([0-9]+)\", \":id\"},\n\t\t\":id([0-9]+)\":                       {\"([0-9]+)\", \":id\"},\n\t\t\":id([0-9]+)_:name\":                 {\"([0-9]+)_(.+)\", \":id :name\"},\n\t\t\"article_:id_:page.html\":            {\"article_(.+)_(.+).html\", \":id :page\"},\n\t\t\"article_:id:int_:page:string.html\": {\"article_([0-9]+)_([\\\\w]+).html\", \":id :page\"},\n\t\t\"*\":                                 {\"*\", \"\"},\n\t\t\"*.*\":                               {\"*.*\", \"\"},\n\t}\n\tConvey(\"Get wildcards\", t, func() {\n\t\tfor key, result := range cases {\n\t\t\tpattern, wildcards := getWildcards(key)\n\t\t\tSo(pattern, ShouldEqual, result.pattern)\n\t\t\tSo(strings.Join(wildcards, \" \"), ShouldEqual, result.wildcards)\n\t\t}\n\t})\n}\n\nfunc Test_getRawPattern(t *testing.T) {\n\tcases := map[string]string{\n\t\t\"admin\":                                  \"admin\",\n\t\t\":id\":                                    \":id\",\n\t\t\":id:int\":                                \":id\",\n\t\t\":id([0-9]+)\":                            \":id\",\n\t\t\":id([0-9]+)_:name\":                      \":id_:name\",\n\t\t\"article_:id_:page.html\":                 \"article_:id_:page.html\",\n\t\t\"article_:id:int_:page:string.html\":      \"article_:id_:page.html\",\n\t\t\"article_:id([0-9]+)_:page([\\\\w]+).html\": \"article_:id_:page.html\",\n\t\t\"*\":                                      \"*\",\n\t\t\"*.*\":                                    \"*.*\",\n\t}\n\tConvey(\"Get raw pattern\", t, func() {\n\t\tfor k, v := range cases {\n\t\t\tSo(getRawPattern(k), ShouldEqual, v)\n\t\t}\n\t})\n}\n\nfunc Test_Tree_Match(t *testing.T) {\n\tConvey(\"Match route in tree\", t, func() {\n\t\tConvey(\"Match static routes\", func() {\n\t\t\tt := NewTree()\n\t\t\tSo(t.Add(\"/\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/user\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/user/unknwon\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/user/unknwon/profile\", nil), ShouldNotBeNil)\n\n\t\t\tSo(t.Add(\"/\", nil), ShouldNotBeNil)\n\n\t\t\t_, _, ok := t.Match(\"/\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\t_, _, ok = t.Match(\"/user\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\t_, _, ok = t.Match(\"/user/unknwon\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\t_, _, ok = t.Match(\"/user/unknwon/profile\")\n\t\t\tSo(ok, ShouldBeTrue)\n\n\t\t\t_, _, ok = t.Match(\"/404\")\n\t\t\tSo(ok, ShouldBeFalse)\n\t\t})\n\n\t\tConvey(\"Match optional routes\", func() {\n\t\t\tt := NewTree()\n\t\t\tSo(t.Add(\"/?:user\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/user/?:name\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/user/list/?:page:int\", nil), ShouldNotBeNil)\n\n\t\t\t_, params, ok := t.Match(\"/\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":user\"], ShouldBeEmpty)\n\t\t\t_, params, ok = t.Match(\"/unknwon\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":user\"], ShouldEqual, \"unknwon\")\n\t\t\t_, params, ok = t.Match(\"/hello%2Fworld\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":user\"], ShouldEqual, \"hello/world\")\n\n\t\t\t_, params, ok = t.Match(\"/user\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":name\"], ShouldBeEmpty)\n\t\t\t_, params, ok = t.Match(\"/user/unknwon\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":name\"], ShouldEqual, \"unknwon\")\n\t\t\t_, params, ok = t.Match(\"/hello%20world\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":user\"], ShouldEqual, \"hello world\")\n\n\t\t\t_, params, ok = t.Match(\"/user/list/\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":page\"], ShouldBeEmpty)\n\t\t\t_, params, ok = t.Match(\"/user/list/123\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":page\"], ShouldEqual, \"123\")\n\t\t})\n\n\t\tConvey(\"Match with regexp\", func() {\n\t\t\tt := NewTree()\n\t\t\tSo(t.Add(\"/v1/:year:int/6/23\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/v2/2015/:month:int/23\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/v3/2015/6/:day:int\", nil), ShouldNotBeNil)\n\n\t\t\t_, params, ok := t.Match(\"/v1/2015/6/23\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(MatchTest(\"/v1/:year:int/6/23\", \"/v1/2015/6/23\"), ShouldBeTrue)\n\t\t\tSo(params[\":year\"], ShouldEqual, \"2015\")\n\t\t\t_, _, ok = t.Match(\"/v1/year/6/23\")\n\t\t\tSo(ok, ShouldBeFalse)\n\t\t\tSo(MatchTest(\"/v1/:year:int/6/23\", \"/v1/year/6/23\"), ShouldBeFalse)\n\n\t\t\t_, params, ok = t.Match(\"/v2/2015/6/23\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":month\"], ShouldEqual, \"6\")\n\t\t\t_, _, ok = t.Match(\"/v2/2015/month/23\")\n\t\t\tSo(ok, ShouldBeFalse)\n\n\t\t\t_, params, ok = t.Match(\"/v3/2015/6/23\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":day\"], ShouldEqual, \"23\")\n\t\t\t_, _, ok = t.Match(\"/v2/2015/6/day\")\n\t\t\tSo(ok, ShouldBeFalse)\n\n\t\t\tSo(t.Add(\"/v1/shop/cms_:id(.+)_:page(.+).html\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/v1/:v/cms/aaa_:id(.+)_:page(.+).html\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/v1/:v/cms_:id(.+)_:page(.+).html\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/v1/:v(.+)_cms/ttt_:id(.+)_:page:string.html\", nil), ShouldNotBeNil)\n\n\t\t\t_, params, ok = t.Match(\"/v1/shop/cms_123_1.html\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":id\"], ShouldEqual, \"123\")\n\t\t\tSo(params[\":page\"], ShouldEqual, \"1\")\n\n\t\t\t_, params, ok = t.Match(\"/v1/2/cms/aaa_124_2.html\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":v\"], ShouldEqual, \"2\")\n\t\t\tSo(params[\":id\"], ShouldEqual, \"124\")\n\t\t\tSo(params[\":page\"], ShouldEqual, \"2\")\n\n\t\t\t_, params, ok = t.Match(\"/v1/3/cms_125_3.html\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":v\"], ShouldEqual, \"3\")\n\t\t\tSo(params[\":id\"], ShouldEqual, \"125\")\n\t\t\tSo(params[\":page\"], ShouldEqual, \"3\")\n\n\t\t\t_, params, ok = t.Match(\"/v1/4_cms/ttt_126_4.html\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":v\"], ShouldEqual, \"4\")\n\t\t\tSo(params[\":id\"], ShouldEqual, \"126\")\n\t\t\tSo(params[\":page\"], ShouldEqual, \"4\")\n\t\t})\n\n\t\tConvey(\"Match with path and extension\", func() {\n\t\t\tt := NewTree()\n\t\t\tSo(t.Add(\"/*.*\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/docs/*.*\", nil), ShouldNotBeNil)\n\n\t\t\t_, params, ok := t.Match(\"/profile.html\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":path\"], ShouldEqual, \"profile\")\n\t\t\tSo(params[\":ext\"], ShouldEqual, \"html\")\n\n\t\t\t_, params, ok = t.Match(\"/profile\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":path\"], ShouldEqual, \"profile\")\n\t\t\tSo(params[\":ext\"], ShouldBeEmpty)\n\n\t\t\t_, params, ok = t.Match(\"/docs/framework/manual.html\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":path\"], ShouldEqual, \"framework/manual\")\n\t\t\tSo(params[\":ext\"], ShouldEqual, \"html\")\n\n\t\t\t_, params, ok = t.Match(\"/docs/framework/manual\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\":path\"], ShouldEqual, \"framework/manual\")\n\t\t\tSo(params[\":ext\"], ShouldBeEmpty)\n\t\t})\n\n\t\tConvey(\"Match all\", func() {\n\t\t\tt := NewTree()\n\t\t\tSo(t.Add(\"/*\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/*/123\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/*/123/*\", nil), ShouldNotBeNil)\n\t\t\tSo(t.Add(\"/*/*/123\", nil), ShouldNotBeNil)\n\n\t\t\t_, params, ok := t.Match(\"/1/2/3\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\"*0\"], ShouldEqual, \"1/2/3\")\n\n\t\t\t_, params, ok = t.Match(\"/4/123\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\"*0\"], ShouldEqual, \"4\")\n\n\t\t\t_, params, ok = t.Match(\"/5/123/6\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\"*0\"], ShouldEqual, \"5\")\n\t\t\tSo(params[\"*1\"], ShouldEqual, \"6\")\n\n\t\t\t_, params, ok = t.Match(\"/7/8/123\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\"*0\"], ShouldEqual, \"7\")\n\t\t\tSo(params[\"*1\"], ShouldEqual, \"8\")\n\t\t})\n\n\t\tConvey(\"Complex tests\", func() {\n\t\t\tt := NewTree()\n\t\t\tSo(t.Add(\"/:username/:reponame/commit/*\", nil), ShouldNotBeNil)\n\n\t\t\t_, params, ok := t.Match(\"/unknwon/com/commit/d855b6c9dea98c619925b7b112f3c4e64b17bfa8\")\n\t\t\tSo(ok, ShouldBeTrue)\n\t\t\tSo(params[\"*\"], ShouldEqual, \"d855b6c9dea98c619925b7b112f3c4e64b17bfa8\")\n\t\t})\n\t})\n}\n"
        }
      ]
    }
  ]
}