{
  "metadata": {
    "timestamp": 1736567252037,
    "page": 850,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg1MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "kisielk/errcheck",
      "stars": 2369,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.03125,
          "content": "Copyright (c) 2013 Kamil Kisiel\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.912109375,
          "content": "# errcheck\n\nerrcheck is a program for checking for unchecked errors in Go code.\n\n![errcheck](https://github.com/kisielk/errcheck/workflows/errcheck/badge.svg)\n\n## Install\n\n    go install github.com/kisielk/errcheck@latest\n\nerrcheck requires Go 1.18 or newer.\n\n## Use\n\nFor basic usage, just give the package path of interest as the first argument:\n\n    errcheck github.com/kisielk/errcheck/testdata\n\nTo check all packages beneath the current directory:\n\n    errcheck ./...\n\nOr check all packages in your `$GOPATH` and `$GOROOT`:\n\n    errcheck all\n\nerrcheck also recognizes the following command-line options:\n\nThe `-tags` flag takes a space-separated list of build tags, just like `go\nbuild`. If you are using any custom build tags in your code base, you may need\nto specify the relevant tags here.\n\nThe `-asserts` flag enables checking for ignored type assertion results. It\ntakes no arguments.\n\nThe `-blank` flag enables checking for assignments of errors to the\nblank identifier. It takes no arguments.\n\nThe `-abspath` flag prints the absolute paths to files with unchecked errors.\n\nThe `-mod` flag sets the module download mode to use: `readonly` or `vendor`.\n\n### go/analysis\n\nThe package provides `Analyzer` instance that can be used with\n[go/analysis](https://pkg.go.dev/golang.org/x/tools/go/analysis) API.\n\nCurrently supported flags are `blank`, `assert`, `exclude`, and `excludeonly`.\nJust as the API itself, the analyzer is experimental and may change in the\nfuture.\n\n## Excluding functions\n\nUse the `-exclude` flag to specify a path to a file containing a list of functions to\nbe excluded.\n\n    errcheck -exclude errcheck_excludes.txt path/to/package\n\nThe file should contain one function signature per line. The format for function signatures is\n`package.FunctionName` while for methods it's `(package.Receiver).MethodName` for value receivers\nand `(*package.Receiver).MethodName` for pointer receivers. If the function name is followed by string of form `(TYPE)`, then\nthe the function call is excluded only if the type of the first argument is `TYPE`. It also accepts a special suffix\n`(os.Stdout)` and `(os.Stderr)`, which excludes the function only when the first argument is a literal `os.Stdout` or `os.Stderr`.\n\nAn example of an exclude file is:\n\n    io.Copy(*bytes.Buffer)\n    io.Copy(os.Stdout)\n    os.ReadFile\n\n    // Sometimes we don't care if a HTTP request fails.\n    (*net/http.Client).Do\n\nBy default, the exclude list is combined with an internal list for functions in\nthe Go standard library that have an error return type but are documented to never\nreturn an error. To disable the built-in exclude list, pass the `-excludeonly` flag.\n\nRun errcheck in `-verbose` mode to see the resulting list of added excludes.\n\nWhen using vendored dependencies, specify the full import path. For example:\n* Your project's import path is `example.com/yourpkg`\n* You've vendored `example.net/fmt2` as `vendor/example.net/fmt2`\n* You want to exclude `fmt2.Println` from error checking\n\nIn this case, add this line to your exclude file:\n```\nexample.com/yourpkg/vendor/example.net/fmt2.Println\n```\n\nEmpty lines and lines starting with `//` are ignored.\n\n### The deprecated method\n\nThe `-ignore` flag takes a comma-separated list of pairs of the form package:regex.\nFor each package, the regex describes which functions to ignore within that package.\nThe package may be omitted to have the regex apply to all packages.\n\nFor example, you may wish to ignore common operations like Read and Write:\n\n    errcheck -ignore '[rR]ead|[wW]rite' path/to/package\n\nor you may wish to ignore common functions like the `print` variants in `fmt`:\n\n    errcheck -ignore 'fmt:[FS]?[Pp]rint*' path/to/package\n\nThe `-ignorepkg` flag takes a comma-separated list of package import paths\nto ignore:\n\n    errcheck -ignorepkg 'fmt,encoding/binary' path/to/package\n\nNote that this is equivalent to:\n\n    errcheck -ignore 'fmt:.*,encoding/binary:.*' path/to/package\n\nIf a regex is provided for a package `pkg` via `-ignore`, and `pkg` also appears\nin the list of packages passed to `-ignorepkg`, the latter takes precedence;\nthat is, all functions within `pkg` will be ignored.\n\nNote that by default the `fmt` package is ignored entirely, unless a regex is\nspecified for it. To disable this, specify a regex that matches nothing:\n\n    errcheck -ignore 'fmt:a^' path/to/package\n\nThe `-ignoretests` flag disables checking of `_test.go` files. It takes\nno arguments.\n\nThe `-ignoregenerated` flag disables checking of generated source code. It takes no arguments.\n\n## Exit Codes\n\nerrcheck returns 1 if any problems were found in the checked files.\nIt returns 2 if there were any other failures.\n\n# Editor Integration\n\n## Emacs\n\n[go-errcheck.el](https://github.com/dominikh/go-errcheck.el)\nintegrates errcheck with Emacs by providing a `go-errcheck` command\nand customizable variables to automatically pass flags to errcheck.\n\n## Vim\n\n[vim-go](https://github.com/fatih/vim-go) can run errcheck via both its `:GoErrCheck`\nand `:GoMetaLinter` commands.\n"
        },
        {
          "name": "errcheck",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.123046875,
          "content": "module github.com/kisielk/errcheck\n\ngo 1.18\n\nrequire golang.org/x/tools v0.17.0\n\nrequire golang.org/x/mod v0.14.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.3740234375,
          "content": "golang.org/x/mod v0.14.0 h1:dGoOF9QVLYng8IHTm7BAyWqCqSheQ5pYWGhzW00YJr0=\ngolang.org/x/mod v0.14.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/sync v0.6.0 h1:5BMeUDZ7vkXGfEr1x9B4bRcTH4lpkTkpdh0T/J+qjbQ=\ngolang.org/x/tools v0.17.0 h1:FvmRgNOcs3kOa+T20R1uhfP9F6HgG2mfxDv1vrx1Htc=\ngolang.org/x/tools v0.17.0/go.mod h1:xsh6VxdV005rRVaS6SSAf9oiAqljS7UZUacMZ8Bnsps=\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 5.712890625,
          "content": "package main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"runtime\"\n\t\"strings\"\n\t\"sync\"\n\n\t\"github.com/kisielk/errcheck/errcheck\"\n\t\"golang.org/x/tools/go/packages\"\n)\n\nconst (\n\texitCodeOk int = iota\n\texitUncheckedError\n\texitFatalError\n)\n\ntype ignoreFlag map[string]*regexp.Regexp\n\n// global flags\nvar (\n\tabspath bool\n\tverbose bool\n)\n\nfunc (f ignoreFlag) String() string {\n\tpairs := make([]string, 0, len(f))\n\tfor pkg, re := range f {\n\t\tprefix := \"\"\n\t\tif pkg != \"\" {\n\t\t\tprefix = pkg + \":\"\n\t\t}\n\t\tpairs = append(pairs, prefix+re.String())\n\t}\n\treturn fmt.Sprintf(\"%q\", strings.Join(pairs, \",\"))\n}\n\nfunc (f ignoreFlag) Set(s string) error {\n\tif s == \"\" {\n\t\treturn nil\n\t}\n\tfor _, pair := range strings.Split(s, \",\") {\n\t\tcolonIndex := strings.Index(pair, \":\")\n\t\tvar pkg, re string\n\t\tif colonIndex == -1 {\n\t\t\tpkg = \"\"\n\t\t\tre = pair\n\t\t} else {\n\t\t\tpkg = pair[:colonIndex]\n\t\t\tre = pair[colonIndex+1:]\n\t\t}\n\t\tregex, err := regexp.Compile(re)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf[pkg] = regex\n\t}\n\treturn nil\n}\n\ntype tagsFlag []string\n\nfunc (f *tagsFlag) String() string {\n\treturn fmt.Sprintf(\"%q\", strings.Join(*f, \",\"))\n}\n\nfunc (f *tagsFlag) Set(s string) error {\n\tif s == \"\" {\n\t\treturn nil\n\t}\n\ttags := strings.FieldsFunc(s, func(c rune) bool {\n\t\treturn c == ' ' || c == ','\n\t})\n\tfor _, tag := range tags {\n\t\tif tag != \"\" {\n\t\t\t*f = append(*f, tag)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc reportResult(e errcheck.Result) {\n\twd, err := os.Getwd()\n\tif err != nil {\n\t\twd = \"\"\n\t}\n\tfor _, uncheckedError := range e.UncheckedErrors {\n\t\tpos := uncheckedError.Pos.String()\n\t\tif !abspath {\n\t\t\tnewPos, err := filepath.Rel(wd, pos)\n\t\t\tif err == nil {\n\t\t\t\tpos = newPos\n\t\t\t}\n\t\t}\n\n\t\tif verbose && uncheckedError.FuncName != \"\" {\n\t\t\tfmt.Printf(\"%s:\\t%s\\t%s\\n\", pos, uncheckedError.FuncName, uncheckedError.Line)\n\t\t} else {\n\t\t\tfmt.Printf(\"%s:\\t%s\\n\", pos, uncheckedError.Line)\n\t\t}\n\t}\n}\n\nfunc logf(msg string, args ...interface{}) {\n\tif verbose {\n\t\tfmt.Fprintf(os.Stderr, msg+\"\\n\", args...)\n\t}\n}\n\nfunc mainCmd(args []string) int {\n\tvar checker errcheck.Checker\n\tpaths, rc := parseFlags(&checker, args)\n\tif rc != exitCodeOk {\n\t\treturn rc\n\t}\n\n\tresult, err := checkPaths(&checker, paths...)\n\tif err != nil {\n\t\tif err == errcheck.ErrNoGoFiles {\n\t\t\tfmt.Fprintln(os.Stderr, err)\n\t\t\treturn exitCodeOk\n\t\t}\n\t\tfmt.Fprintf(os.Stderr, \"error: failed to check packages: %s\\n\", err)\n\t\treturn exitFatalError\n\t}\n\tif len(result.UncheckedErrors) > 0 {\n\t\treportResult(result)\n\t\treturn exitUncheckedError\n\t}\n\treturn exitCodeOk\n}\n\nfunc checkPaths(c *errcheck.Checker, paths ...string) (errcheck.Result, error) {\n\tpkgs, err := c.LoadPackages(paths...)\n\tif err != nil {\n\t\treturn errcheck.Result{}, err\n\t}\n\t// Check for errors in the initial packages.\n\twork := make(chan *packages.Package, len(pkgs))\n\tfor _, pkg := range pkgs {\n\t\tif len(pkg.Errors) > 0 {\n\t\t\treturn errcheck.Result{}, fmt.Errorf(\"errors while loading package %s: %v\", pkg.ID, pkg.Errors)\n\t\t}\n\t\twork <- pkg\n\t}\n\tclose(work)\n\n\tvar wg sync.WaitGroup\n\tresult := &errcheck.Result{}\n\tmu := &sync.Mutex{}\n\tfor i := 0; i < runtime.NumCPU(); i++ {\n\t\twg.Add(1)\n\n\t\tgo func() {\n\t\t\tdefer wg.Done()\n\t\t\tfor pkg := range work {\n\t\t\t\tlogf(\"checking %s\", pkg.Types.Path())\n\t\t\t\tr := c.CheckPackage(pkg)\n\t\t\t\tmu.Lock()\n\t\t\t\tresult.Append(r)\n\t\t\t\tmu.Unlock()\n\t\t\t}\n\t\t}()\n\t}\n\n\twg.Wait()\n\treturn result.Unique(), nil\n}\n\nfunc parseFlags(checker *errcheck.Checker, args []string) ([]string, int) {\n\tflags := flag.NewFlagSet(args[0], flag.ContinueOnError)\n\n\tvar checkAsserts, checkBlanks bool\n\n\tflags.BoolVar(&checkBlanks, \"blank\", false, \"if true, check for errors assigned to blank identifier\")\n\tflags.BoolVar(&checkAsserts, \"asserts\", false, \"if true, check for ignored type assertion results\")\n\tflags.BoolVar(&checker.Exclusions.TestFiles, \"ignoretests\", false, \"if true, checking of _test.go files is disabled\")\n\tflags.BoolVar(&checker.Exclusions.GeneratedFiles, \"ignoregenerated\", false, \"if true, checking of files with generated code is disabled\")\n\tflags.BoolVar(&verbose, \"verbose\", false, \"produce more verbose logging\")\n\n\tflags.BoolVar(&abspath, \"abspath\", false, \"print absolute paths to files\")\n\n\ttags := tagsFlag{}\n\tflags.Var(&tags, \"tags\", \"comma or space-separated list of build tags to include\")\n\tignorePkg := flags.String(\"ignorepkg\", \"\", \"comma-separated list of package paths to ignore\")\n\tignore := ignoreFlag(map[string]*regexp.Regexp{})\n\tflags.Var(ignore, \"ignore\", \"[deprecated] comma-separated list of pairs of the form pkg:regex\\n\"+\n\t\t\"            the regex is used to ignore names within pkg.\")\n\n\tvar excludeFile string\n\tflags.StringVar(&excludeFile, \"exclude\", \"\", \"Path to a file containing a list of functions to exclude from checking\")\n\n\tvar excludeOnly bool\n\tflags.BoolVar(&excludeOnly, \"excludeonly\", false, \"Use only excludes from -exclude file\")\n\n\tflags.StringVar(&checker.Mod, \"mod\", \"\", \"module download mode to use: readonly or vendor. See 'go help modules' for more.\")\n\n\tif err := flags.Parse(args[1:]); err != nil {\n\t\treturn nil, exitFatalError\n\t}\n\n\tchecker.Exclusions.BlankAssignments = !checkBlanks\n\tchecker.Exclusions.TypeAssertions = !checkAsserts\n\n\tif !excludeOnly {\n\t\tchecker.Exclusions.Symbols = append(checker.Exclusions.Symbols, errcheck.DefaultExcludedSymbols...)\n\t}\n\n\tif excludeFile != \"\" {\n\t\texcludes, err := errcheck.ReadExcludes(excludeFile)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"Could not read exclude file: %v\\n\", err)\n\t\t\treturn nil, exitFatalError\n\t\t}\n\t\tchecker.Exclusions.Symbols = append(checker.Exclusions.Symbols, excludes...)\n\t}\n\n\tchecker.Tags = tags\n\tfor _, pkg := range strings.Split(*ignorePkg, \",\") {\n\t\tif pkg != \"\" {\n\t\t\tchecker.Exclusions.Packages = append(checker.Exclusions.Packages, pkg)\n\t\t}\n\t}\n\n\tchecker.Exclusions.SymbolRegexpsByPackage = ignore\n\n\tpaths := flags.Args()\n\tif len(paths) == 0 {\n\t\tpaths = []string{\".\"}\n\t}\n\n\treturn paths, exitCodeOk\n}\n\nfunc main() {\n\tos.Exit(mainCmd(os.Args))\n}\n"
        },
        {
          "name": "main_test.go",
          "type": "blob",
          "size": 6.0732421875,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/kisielk/errcheck/errcheck\"\n)\n\nvar dotStar = regexp.MustCompile(\".*\")\n\nfunc TestMainFunc(t *testing.T) {\n\tsaveStderr := os.Stderr\n\tsaveStdout := os.Stdout\n\tsaveCwd, err := os.Getwd()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot receive current directory: %v\", err)\n\t}\n\n\tr, w, err := os.Pipe()\n\tif err != nil {\n\t\tt.Errorf(\"Cannot create pipe: %v\", err)\n\t}\n\n\tos.Stderr = w\n\tos.Stdout = w\n\n\tbufChannel := make(chan string)\n\n\tgo func() {\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err = io.Copy(buf, r)\n\t\tr.Close()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Cannot copy to buffer: %v\", err)\n\t\t}\n\n\t\tbufChannel <- buf.String()\n\t}()\n\n\texitCode := mainCmd([]string{\"cmd name\", \"github.com/kisielk/errcheck/testdata\"})\n\n\tw.Close()\n\n\tos.Stderr = saveStderr\n\tos.Stdout = saveStdout\n\t_ = os.Chdir(saveCwd)\n\n\tout := <-bufChannel\n\n\tif exitCode != exitUncheckedError {\n\t\tt.Errorf(\"Exit code is %d, expected %d\", exitCode, exitUncheckedError)\n\t}\n\n\texpectUnchecked := 29\n\tif got := strings.Count(out, \"UNCHECKED\"); got != expectUnchecked {\n\t\tt.Errorf(\"Got %d UNCHECKED errors, expected %d in:\\n%s\", got, expectUnchecked, out)\n\t}\n}\n\ntype parseTestCase struct {\n\targs    []string\n\tpaths   []string\n\tignore  map[string]string // Exclusions.SymbolRegexpsByPackage\n\tpkgs    []string          // Exclusions.Packages\n\ttags    []string          // Tags\n\tblank   bool              // !BlankAssignments\n\tasserts bool              // !TypeAssertions\n\terror   int\n}\n\nfunc TestParseFlags(t *testing.T) {\n\tcases := []parseTestCase{\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-blank\", \"-asserts\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{},\n\t\t\tblank:   true,\n\t\t\tasserts: true,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"foo\", \"bar\"},\n\t\t\tpaths:   []string{\"foo\", \"bar\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-ignore\", \"fmt:.*,encoding/binary:.*\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{\"fmt\": \".*\", \"encoding/binary\": dotStar.String()},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-ignore\", \"fmt:[FS]?[Pp]rint*\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{\"fmt\": \"[FS]?[Pp]rint*\"},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-ignore\", \"[rR]ead|[wW]rite\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{\"\": \"[rR]ead|[wW]rite\"},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-ignorepkg\", \"testing\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{\"testing\"},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-ignorepkg\", \"testing,foo\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{\"testing\", \"foo\"},\n\t\t\ttags:    []string{},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-tags\", \"foo\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{\"foo\"},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-tags\", \"foo bar !baz\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{\"foo\", \"bar\", \"!baz\"},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-tags\", \"foo,bar,!baz\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{\"foo\", \"bar\", \"!baz\"},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t\tparseTestCase{\n\t\t\targs:    []string{\"errcheck\", \"-tags\", \"foo   bar   !baz\"},\n\t\t\tpaths:   []string{\".\"},\n\t\t\tignore:  map[string]string{},\n\t\t\tpkgs:    []string{},\n\t\t\ttags:    []string{\"foo\", \"bar\", \"!baz\"},\n\t\t\tblank:   false,\n\t\t\tasserts: false,\n\t\t\terror:   exitCodeOk,\n\t\t},\n\t}\n\n\tslicesEqual := func(a, b []string) bool {\n\t\tif len(a) != len(b) {\n\t\t\treturn false\n\t\t}\n\t\tfor i := range a {\n\t\t\tif a[i] != b[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tignoresEqual := func(a map[string]*regexp.Regexp, b map[string]string) bool {\n\t\tif (a == nil && b != nil) || (a != nil && b == nil) || (len(a) != len(b)) {\n\t\t\treturn false\n\t\t}\n\t\tfor k, v := range a {\n\t\t\tif v.String() != b[k] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\tfor _, c := range cases {\n\t\tvar checker errcheck.Checker\n\t\tp, e := parseFlags(&checker, c.args)\n\n\t\targsStr := strings.Join(c.args, \" \")\n\t\tif !slicesEqual(p, c.paths) {\n\t\t\tt.Errorf(\"%q: path got %q want %q\", argsStr, p, c.paths)\n\t\t}\n\t\tif ign := checker.Exclusions.SymbolRegexpsByPackage; !ignoresEqual(ign, c.ignore) {\n\t\t\tt.Errorf(\"%q: ignore got %q want %q\", argsStr, ign, c.ignore)\n\t\t}\n\t\tif pkgs := checker.Exclusions.Packages; !slicesEqual(pkgs, c.pkgs) {\n\t\t\tt.Errorf(\"%q: packages got %v want %v\", argsStr, pkgs, c.pkgs)\n\t\t}\n\t\tif tags := checker.Tags; !slicesEqual(tags, c.tags) {\n\t\t\tt.Errorf(\"%q: tags got %v want %v\", argsStr, tags, c.tags)\n\t\t}\n\t\tif b := checker.Exclusions.BlankAssignments; b != !c.blank {\n\t\t\tt.Errorf(\"%q: BlankAssignments got %v want %v\", argsStr, b, !c.blank)\n\t\t}\n\t\tif a := checker.Exclusions.TypeAssertions; a != !c.asserts {\n\t\t\tt.Errorf(\"%q: TypeAssertions got %v want %v\", argsStr, a, !c.asserts)\n\t\t}\n\t\tif e != c.error {\n\t\t\tt.Errorf(\"%q: error got %q want %q\", argsStr, e, c.error)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}