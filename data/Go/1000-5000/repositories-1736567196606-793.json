{
  "metadata": {
    "timestamp": 1736567196606,
    "page": 793,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjgwMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "docker/libchan",
      "stars": 2466,
      "defaultBranch": "master",
      "files": [
        {
          "name": "AUTHORS",
          "type": "blob",
          "size": 0.0341796875,
          "content": "Solomon Hykes <solomon@docker.com>\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.4208984375,
          "content": "# Contributing to libchan\n\nWant to hack on libchan? Awesome! Here are instructions to get you\nstarted.\n\nlibchan is a part of the [Docker](https://docker.io) project, and follows\nthe same rules and principles. If you're already familiar with the way\nDocker does things, you'll feel right at home.\n\nOtherwise, go read\n[Docker's contributions guidelines](https://github.com/docker/docker/blob/master/CONTRIBUTING.md).\n\nHappy hacking!\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 10.505859375,
          "content": "\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n   1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n   2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n   3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n   4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n   5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n   6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n   7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n   8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n   9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n   END OF TERMS AND CONDITIONS\n\n   Copyright 2014 Docker, Inc.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n"
        },
        {
          "name": "MAINTAINERS",
          "type": "blob",
          "size": 0.8505859375,
          "content": "# Libchan maintainers file\n#\n# This file describes who runs the docker/libchan project and how.\n# This is a living document - if you see something out of date or missing, speak up!\n#\n# It is structured to be consumable by both humans and programs.\n# To extract its contents programmatically, use any TOML-compliant parser.\n#\n# This file is compiled into the MAINTAINERS file in docker/opensource.\n#\n[Org]\n\t[Org.\"Core maintainers\"]\n\t\tpeople = [\n\t\t\t\"dmcgowan\",\n\t\t\t\"shykes\",\n\t\t]\n\n[people]\n\n# A reference list of all people associated with the project.\n# All other sections should refer to people by their canonical key\n# in the people section.\n\n\t# ADD YOURSELF HERE IN ALPHABETICAL ORDER\n\n\t[people.dmcgowan]\n\tName = \"Derek McGowan\"\n\tEmail = \"derek@mcgstyle.net\"\n\tGitHub = \"dmcgowan\"\n\n\t[people.shykes]\n\tName = \"Solomon Hykes\"\n\tEmail = \"solomon@docker.com\"\n\tGitHub = \"shykes\"\n"
        },
        {
          "name": "NOTICE",
          "type": "blob",
          "size": 0.5078125,
          "content": "libchan\nCopyright 2012-2014 Docker, Inc.\n\nThis product includes software developed at Docker, Inc. (http://www.docker.com).\n\nThe following is courtesy of our legal counsel:\n\n\nUse and transfer of Docker may be subject to certain restrictions by the\nUnited States and other governments.  \nIt is your responsibility to ensure that your use and/or transfer does not\nviolate applicable laws. \n\nFor more information, please see http://www.bis.doc.gov\n\nSee also http://www.apache.org/dev/crypto.html and/or seek legal counsel.\n"
        },
        {
          "name": "PROTOCOL.md",
          "type": "blob",
          "size": 7.400390625,
          "content": "# libchan protocol specification\n\nExtreme portability is a key design goal of libchan.\n\nThis document specifies the libchan protocol to allow multiple implementations to co-exist with\nfull interoperability.\n\n## Version\n\nNo version yet.\n\n## Author\n\nSolomon Hykes <solomon@docker.com>\n\n## Status\n\nThis specification is still work in progress. Things will change, probably in reverse-incompatible ways.\nWe hope to reach full API stability soon.\n\n## Terminology\n\n### Channel\n\nA `channel` is an object which allows 2 concurrent programs to communicate with each other. The semantics\nof a libchan channel are very similar (but not identical) to those of Go's native channels.\n\nA channel has 2 ends: a `Sender` end and a `Receiver` end. The Sender can send messages and close the channel.\nThe Receiver can receive messages. Messages arrive in the same order they were sent.\n\nA channel is uni-directional: messages can only flow in one direction. So channels are more similar to pipes\nthan to sockets.\n\n### Message\n\nA message is a discrete packet of data which can be sent on a channel. Messages are structured into multiple\nfields. The protocol defines which data types can be carried by a message, and how transports should encode and\ndecode them.\n\n### Byte stream\n\nA byte stream is an object which implements raw IO with `Read`, `Write` and `Close` methods.\nTypical byte streams are text files, network sockets, memory buffers, pipes, and so on.\n\nOne distinct characteristic of libchan is that it can encode byte streams as first class fields\nin a message, alongside more basic types like integers or strings.\n\n### Nesting\n\nLibchan supports nesting. This means that a libchan message can include a channel, which itself\ncan be used to send and receive messages, and so on all the way down.\n\nNesting is a fundamental property of libchan.\n\n## Underlying transport\n\nThe libchan protocol requires a reliable, 2-way byte stream as a transport.\nThe most popular options are TCP connections, unix stream sockets and TLS sessions. \n\nIt is also possible to use websocket as an underlying transport, which allows exposing\na libchan endpoint at an HTTP1 url.\n\n## Authentication and encryption\n\nLibchan can optionally use TLS to authenticate and encrypt communications. After the initial\nhandshake and protocol negotiation, the TLS session is simply used as the transport for\nthe libchan wire protocol.\n\n## Wire protocol\n\nLibchan uses SPDY (protocol draft 3) as its wire protocol, with no modification.\n\n## Control protocol\n\nOnce 2 libchan endpoints have established a SPDY session, they communicate with the following\ncontrol protocol.\n\n### Top-level channels\n\nEach SPDY session may carry multiple concurrent channels, in both directions, using standard\nSPDY framing and stream multiplexing. Each libchan channel is implemented by an underlying\nSPDY stream.\n\nTo use a SPDY session, either endpoint may initiate new channels, wait for its peer to\ninitiate new channels, or a combination of both. Channels initiated in this way are called\n*top-level channels*.\n\n* To initiate a new top-level channel, either endpoint may initiate a new SPDY stream, then\nstart sending messages to it (see *\"sending messages\"*).\n\n* The endpoint initiating a top-level channel MAY NOT allow the application to receive messages\nfrom it and MUST ignore inbound messages received on that stream.\n\n* When an endpoint receives a new inbound SPDY stream, and the initial headers DO NOT include\nthe key `libchan-ref`, it MUST queue a new `Receiver` channel to pass to the application.\n\n* The endpoint receiving a top-level channel MAY NOT allow the application to send messages to\nit.\n\n\n### Sending messages on a channel\n\nOnce a SPDY stream is initiated, it can be used as a channel, with the initiating endpoint holding\nthe `Sender` end of the channel, and the recipient endpoint holding the `Receiver` end.\n\n* To send a message, the sender MUST encode it using the [msgpack](https://msgpack.org) encoding format, and\nsend a single data frame on the corresponding SPDY stream, with the encoded message as the exact content of\nthe frame.\n\n* When receiving a data frame on any active SPDY stream, the receiver MUST decode it using msgpack. If\nthe decoding fails, the receiver MUST close the underlying stream, and future calls to `Receive` on that\nchannel MUST return an error.\n\n* A valid msgpack decode operation with leftover trailing or leading data is considered an *invalid* msgpack\ndecode operation, and MUST yield the corresponding error.\n\n### Closing a channel\n\nThe endpoint which initiated a channel MAY close it by closing the underlying SPDY stream.\n\n*FIXME: provide more details*\n\n### Sending byte streams\n\nLibchan messages support a special type called *byte streams*. Unlike regular types like integers or strings,\nbyte streams are not fully encoded in the message. Instead, the message encodes a *reference* which allows\nthe receiving endpoint to reconstitute the byte stream after receiving the message, and pass it to the\napplication.\n\n*FIXME: specify use of msgpack extended types to encode byte streams*\n\nLibchan supports 2 methods for sending byte streams: a default method which is supported on all transports,\nand an optional method which requires unix stream sockets. All implementations MUST support both methods.\n\n#### Default method: SPDY streams\n\nThe primary method for sending a byte stream is to send it over a SPDY stream, with the following protocol:\n\n* When encoding a message including 1 or more byte stream values, the sender MUST assign to each value\nan identifier unique to the session, and store these identifiers for future use.\n\n* After sending the encoded message, the sender MUST initiate 1 new SPDY stream for each byte stream value\nin the message.\n\n* Each of those SPDY stream MUST include an initial header with as a key the string \"*libchan-ref*\", and\nas a value the identifier of the corresponding byte stream.\n\nConversely, the receiver must follow this protocol:\n\n* When decoding a message including 1 or more byte stream values, the receiver MUST store the unique identifier\nof each value in a session-wide table of pending byte streams. It MAY then immediately pass the decoded message to the application.\n\n* The sender SHOULD cap the size of its pending byte streams table to a reasonable value. It MAY make that value\nconfigurable by the application. If it receives a message with 1 or more byte stream references, and the table\nis full, the sender MAY suspend processing of the message until there is room in the table.\n\n* When receiving new SPDY streams which include the header key \"*libchan-ref*\", the receiver MUST lookup that\nheader value in the table of pending byte streams. If the value is registered in the table, that SPDY stream\nMUST be passed to the application.\n\nOn either end, once the SPDY stream for a byte-stream value is established, it MUST be exposed to the application\nas follows:\n\n* After sending each of those SPDY streams, each write operation by the application to a byte-stream field MUST\ntrigger the sending of a single data frame on the corresponding SPDY stream.\n\n* Each read operation by the application from a byte-stream field MUST yield the content of the next\ndata frame received on the corresponding SPDY stream. If the reading end of the SPDY stream is closed,\nthe read operation MUST yield EOF.\n\n* A close operation by the application on the a byte-stream field MUST trigger the closing of the writing end\nof the corresponding SPDY stream.\n\n#### Optional method: file descriptor passing\n\n*FIXME*\n\n### Sending nested channels\n\n*FIXME*\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5,
          "content": "# libchan: like Go channels over the network\n[![Circle CI](https://circleci.com/gh/docker/libchan.svg?style=svg)](https://circleci.com/gh/docker/libchan)\n\nLibchan is an ultra-lightweight networking library which lets network services communicate\nin the same way that goroutines communicate using channels:\n\n* Simple message passing\n* Synchronization for concurrent programming\n* Nesting: channels can send channels\n\nLibchan supports the following transports out of the box:\n\n* In-memory Go channel\n* Unix socket\n* Raw TCP\n* TLS\n* HTTP2/SPDY\n* Websocket\n\nThis provides great flexibility in scaling an application by breaking it down into\nloosely coupled concurrent services. The same application could be composed of\ngoroutines communicating over in-memory channels; then transition to separate\nunix processes, each assigned to a processor core, and communicating over\nhigh-performance IPC; then to a cluster of machines communicating over\nauthenticated TLS sessions. All along it benefits from the concurrency model\nwhich has made Go so popular.\n\nNot all transports have the same semantics. In-memory Go channels guarantee\nexactly-once delivery; TCP, TLS, and the various HTTP socket families do not\nguarantee delivery. Messages arrive in order but may be arbitrarily delayed or\nlost. There are no ordering invariants across channels.\n\nAn explicit goal of libchan is simplicity of implementation and clarity of\nspec. Porting it to any language should be as effortless as humanly possible.\n\n## Focused on not reinventing the wheel\n\nBecause remote libchan sessions are regular HTTP2 over TLS sessions, they can\nbe used in combination with any standard proxy or authentication\nmiddleware. This means libchan, when configured properly, can be safely exposed\non the public Internet. It can also be embedded in an existing rest API\nusing an http1 and websocket fallback.\n\n## How is it different from RPC or REST?\n\nModern micro-services are not a great fit for classical RPC or REST\nprotocols because they often rely heavily on events, bi-directional\ncommunication, stream multiplexing, and some form of data synchronization.\nSometimes these services have a component which requires raw socket access,\neither for performance (file transfer, event firehose, database access) or\nsimply because they have their own protocol (dns, smtp, sql, ssh,\nzeromq, etc). These components typically need a separate set of tools\nbecause they are outside the scope of the REST and RPC tools. If there is\nalso a websocket or ServerEvents transport, those require yet another layer\nof tools.\n\nInstead of a clunky patchwork of tools, libchan implements in a single\nminimalistic library all the primitives needed by modern micro-services:\n\n* Request/response with arbitrary structured data\n\n* Asynchronous events flowing in real-time in both directions\n\n* Requests and responses can flow in any direction, and can be arbitrarily\nnested, for example to implement a self-registering worker model\n\n* Any message serialization format can be plugged in: json, msgpack, xml,\nprotobuf.\n\n* Raw file descriptors can be \"attached\" to any message, and passed under\nthe hood using the best method available to each transport. The Go channel\ntransport just passes os.File pointers around. The unix socket transport\nuses fd passing which makes it suitable for high-performance IPC. The\ntcp transport uses dedicated http2 streams. And as a bonus extension, a\nbuilt-in  tcp gateway can be used to proxy raw network sockets without\nextra overhead. That means libchan services can be used as smart gateways to a\nsql database, ssh or file transfer service, with unified auth, discovery\nand tooling and without performance penalty.\n\n## Example usage\n\nHere's an example implementing basic RPC-style request/response.  We gloss over error handling to tersely demonstrate the core concepts.\n\nOn the client:\n\n```go\nvar ch libchan.Sender\n\n// Send a message, indicate that we want a return channel to be automatically created\nret1, err := ch.Send(&libchan.Message{Data: []byte(\"request 1!\"), Ret: libchan.RetPipe})\n\n// Send another message on the same channel\nret2, err := ch.Send(&libchan.Message{Data: []byte(\"request 2!\"), Ret: libchan.RetPipe})\n\n// Wait for an answer from the first request.  Set flags to zero\n// to indicate we don't want a nested return channel.\nmsg, err := ret1.Receive(0)\n```\n\nOn the server:\n\n```go\nvar ch libchan.Receiver\n\n// Wait for messages in a loop\n// Set the return channel flag to indicate that we\n// want to receive nested channels (if any).\n// Note: we don't send a nested return channel, but we could.\nfor {\n\tmsg, err := ch.Receive(libchan.Ret)\n\tmsg.Ret.Send(&libchan.Message{Data: []byte(\"this is an extremely useful response\")});\n}\n```\n\n## Creators\n\n**Solomon Hykes**\n\n- <http://twitter.com/solomonstre>\n- <http://github.com/shykes>\n\n## Additional Implementations\n\n### Java\n- https://github.com/ndeloof/jchan\n\n### Javascript / Node.js\n- https://github.com/GraftJS/jschan\n\n## Copyright and license\n\nCode and documentation copyright 2013-2014 Docker, inc. Code released under the Apache 2.0 license.\nDocs released under Creative commons.\n"
        },
        {
          "name": "circle.yml",
          "type": "blob",
          "size": 0.55859375,
          "content": "machine:\n  pre:\n    - curl -o go.tar.gz -sL https://golang.org/dl/go1.4.linux-amd64.tar.gz\n    - sudo rm -rf /usr/local/go\n    - sudo tar -C /usr/local -xzf go.tar.gz\n    - sudo chmod a+w /usr/local/go/src/\n\ndependencies:\n  post:\n    - go get github.com/axw/gocov/gocov\n    - go get github.com/mattn/goveralls\n    - go get github.com/golang/lint/golint\n\ntest:\n  pre:\n    - go version\n  override:\n    - test -z \"$(gofmt -s -l . | tee /dev/stderr)\"\n    - go vet ./...\n    - test -z \"$(golint ./... | tee /dev/stderr)\"\n    - go test -race -test.v ./...:\n        timeout: 600\n"
        },
        {
          "name": "copy.go",
          "type": "blob",
          "size": 1.6845703125,
          "content": "package libchan\n\nimport (\n\t\"errors\"\n\t\"io\"\n)\n\nvar (\n\t// ErrIncompatibleSender is used when an object cannot support\n\t// SendTo for its given argument.\n\tErrIncompatibleSender = errors.New(\"incompatible sender\")\n\t// ErrIncompatibleReceiver is used when an object cannot support\n\t// ReceiveFrom for its given argument.\n\tErrIncompatibleReceiver = errors.New(\"incompatible receiver\")\n)\n\n// ReceiverFrom defines a type which can directly receive objects\n// from a receiver.\ntype ReceiverFrom interface {\n\t// ReceiveFrom receives object from the given receiver. If the given\n\t// receiver is not a supported type, this function should return\n\t// ErrIncompatibleReceiver.\n\tReceiveFrom(Receiver) (int, error)\n}\n\n// SenderTo defines a type which can directly send objects\n// from a sender.\ntype SenderTo interface {\n\t// SendTo sends object to the given sender. If the given\n\t// sender is not a supported type, this function should return\n\t// ErrIncompatibleSender.\n\tSendTo(Sender) (int, error)\n}\n\n// Copy copies from a receiver to a sender until an EOF is\n// received.  The number of copies made is returned along\n// with any error that may have halted copying prior to an EOF.\nfunc Copy(w Sender, r Receiver) (int, error) {\n\tif senderTo, ok := r.(SenderTo); ok {\n\t\tif n, err := senderTo.SendTo(w); err != ErrIncompatibleSender {\n\t\t\treturn n, err\n\t\t}\n\t}\n\tif receiverFrom, ok := w.(ReceiverFrom); ok {\n\t\tif n, err := receiverFrom.ReceiveFrom(r); err != ErrIncompatibleReceiver {\n\t\t\treturn n, err\n\t\t}\n\t}\n\n\tvar n int\n\tfor {\n\t\tvar m interface{}\n\t\terr := r.Receive(&m)\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\treturn n, err\n\t\t\t}\n\t\t}\n\n\t\terr = w.Send(m)\n\t\tif err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tn++\n\t}\n\treturn n, nil\n}\n"
        },
        {
          "name": "copy_test.go",
          "type": "blob",
          "size": 4.1240234375,
          "content": "package libchan\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"runtime/pprof\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype ProxiedMessage struct {\n\tMessage string\n\tRet     Sender\n}\n\ntype ProxyAckMessage struct {\n\tN          int\n\tMessageLen int\n}\n\nfunc TestChannelProxy(t *testing.T) {\n\tmessages := []string{\n\t\t\"Proxied messages\",\n\t\t\"Another proxied message\",\n\t\t\"Far less interesting message\",\n\t\t\"This was ALSO sent over the proxy\",\n\t}\n\tclient := func(t *testing.T, sender Sender) {\n\t\tfor i, m := range messages {\n\t\t\tnestedReceiver, remoteSender := Pipe()\n\n\t\t\tmessage := &ProxiedMessage{\n\t\t\t\tMessage: m,\n\t\t\t\tRet:     remoteSender,\n\t\t\t}\n\n\t\t\terr := sender.Send(message)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error sending message: %s\", err)\n\t\t\t}\n\n\t\t\tack := &ProxyAckMessage{}\n\t\t\terr = nestedReceiver.Receive(ack)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error receiving ack: %s\", err)\n\t\t\t}\n\n\t\t\tif ack.N != i {\n\t\t\t\tt.Fatalf(\"Unexpected ack value\\n\\tExpected: %d\\n\\tActual: %d\", i, ack.N)\n\t\t\t}\n\n\t\t\tif ack.MessageLen != len(m) {\n\t\t\t\tt.Fatalf(\"Unexpected ack value\\n\\tExpected: %d\\n\\tActual: %d\", len(m), ack.MessageLen)\n\t\t\t}\n\t\t}\n\n\t}\n\tserver := func(t *testing.T, receiver Receiver) {\n\t\tfor i, m := range messages {\n\t\t\tmessage := &ProxiedMessage{}\n\t\t\terr := receiver.Receive(message)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error receiving message: %s\", err)\n\t\t\t}\n\n\t\t\tif message.Message != m {\n\t\t\t\tt.Fatalf(\"Unexpected message:\\n\\tExpected: %s\\n\\tActual: %s\", m, message.Message)\n\t\t\t}\n\n\t\t\tack := &ProxyAckMessage{N: i, MessageLen: len(message.Message)}\n\t\t\terr = message.Ret.Send(ack)\n\t\t\tif err != nil {\n\t\t\t\tt.Fatalf(\"Error sending ack: %s\", err)\n\t\t\t}\n\t\t}\n\t}\n\tSpawnProxyTest(t, client, server, 4)\n}\n\ntype ProxiedStreamMessage struct {\n\tStream io.ReadWriteCloser\n}\n\nfunc TestByteStreamProxy(t *testing.T) {\n\tsendString := \"Sending a string\"\n\tretString := \"Returned string\"\n\tclient := func(t *testing.T, sender Sender) {\n\t\tbs, bsRemote := net.Pipe()\n\n\t\tmessage := &ProxiedStreamMessage{\n\t\t\tStream: bsRemote,\n\t\t}\n\n\t\terr := sender.Send(message)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error sending message: %s\", err)\n\t\t}\n\n\t\t_, err = bs.Write([]byte(sendString))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error writing bytes: %s\", err)\n\t\t}\n\n\t\tbuf := make([]byte, 30)\n\t\tn, err := bs.Read(buf)\n\t\tif string(buf[:n]) != retString {\n\t\t\tt.Fatalf(\"Unexpected string value:\\n\\tExpected: %s\\n\\tActual: %s\", retString, string(buf[:n]))\n\t\t}\n\t}\n\tserver := func(t *testing.T, receiver Receiver) {\n\t\tmessage := &ProxiedStreamMessage{}\n\t\terr := receiver.Receive(message)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error receiving message: %s\", err)\n\t\t}\n\n\t\tbuf := make([]byte, 30)\n\t\tn, err := message.Stream.Read(buf)\n\t\tif string(buf[:n]) != sendString {\n\t\t\tt.Fatalf(\"Unexpected string value:\\n\\tExpected: %s\\n\\tActual: %s\", sendString, string(buf[:n]))\n\t\t}\n\n\t\t_, err = message.Stream.Write([]byte(retString))\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error writing bytes: %s\", err)\n\t\t}\n\t}\n\tSpawnProxyTest(t, client, server, 1)\n}\n\nfunc SpawnProxyTest(t *testing.T, client SendTestRoutine, server ReceiveTestRoutine, proxyCount int) {\n\tendClient := make(chan bool)\n\tendServer := make(chan bool)\n\tendProxy := make(chan bool)\n\n\treceiver1, sender1 := Pipe()\n\treceiver2, sender2 := Pipe()\n\n\tgo func() {\n\t\tdefer close(endProxy)\n\t\tn, err := Copy(sender2, receiver1)\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error proxying: %s\", err)\n\t\t}\n\t\terr = sender2.Close()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error closing sender: %s\", err)\n\t\t}\n\t\tif n != proxyCount {\n\t\t\tt.Errorf(\"Wrong proxy count\\n\\tExpected: %d\\n\\tActual: %d\", proxyCount, n)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer close(endClient)\n\t\tclient(t, sender1)\n\t\terr := sender1.Close()\n\t\tif err != nil {\n\t\t\tt.Errorf(\"Error closing sender: %s\", err)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer close(endServer)\n\t\tserver(t, receiver2)\n\t}()\n\n\ttimeout := time.After(RoutineTimeout)\n\n\tfor endClient != nil || endServer != nil {\n\t\tselect {\n\t\tcase <-endProxy:\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatal(\"Proxy failed\")\n\t\t\t}\n\t\t\tendClient = nil\n\t\tcase <-endClient:\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatal(\"Client failed\")\n\t\t\t}\n\t\t\tendClient = nil\n\t\tcase <-endServer:\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatal(\"Server failed\")\n\t\t\t}\n\t\t\tendServer = nil\n\t\tcase <-timeout:\n\t\t\tif DumpStackOnTimeout {\n\t\t\t\tpprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n\t\t\t}\n\t\t\tt.Fatal(\"Timeout\")\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "inmem.go",
          "type": "blob",
          "size": 1.3525390625,
          "content": "package libchan\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"reflect\"\n)\n\ntype pSender chan<- interface{}\ntype pReceiver <-chan interface{}\n\nfunc (s pSender) Close() error {\n\tclose(s)\n\treturn nil\n}\n\nfunc (s pSender) Send(msg interface{}) error {\n\ts <- msg\n\treturn nil\n}\n\ntype messageDecoder interface {\n\tDecode(v ...interface{}) error\n}\n\nfunc (r pReceiver) Receive(msg interface{}) error {\n\trmsg, ok := <-r\n\tif !ok {\n\t\treturn io.EOF\n\t}\n\n\t// check type\n\tv := reflect.ValueOf(msg)\n\trv := reflect.ValueOf(rmsg)\n\tif v.Type() == rv.Type() {\n\t\tif v.Kind() == reflect.Ptr {\n\t\t\tv.Elem().Set(rv.Elem())\n\t\t} else {\n\t\t\tv.Set(rv)\n\t\t}\n\t} else {\n\t\tswitch msg.(type) {\n\t\tcase *interface{}:\n\t\t\tv.Elem().Set(rv)\n\t\tdefault:\n\t\t\tswitch rval := rmsg.(type) {\n\t\t\tcase messageDecoder:\n\t\t\t\treturn rval.Decode(msg)\n\t\t\tdefault:\n\t\t\t\treturn fmt.Errorf(\"Cannot receive %T into %T\", rmsg, msg)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (r pReceiver) SendTo(dst Sender) (int, error) {\n\tvar n int\n\tfor {\n\t\tpmsg, ok := <-r\n\t\tif !ok {\n\t\t\tbreak\n\t\t}\n\t\tif err := dst.Send(pmsg); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tn++\n\t}\n\treturn n, nil\n}\n\n// Pipe returns an inmemory Sender/Receiver pair.\nfunc Pipe() (Receiver, Sender) {\n\tc := make(chan interface{})\n\treturn pReceiver(c), pSender(c)\n}\n\n// BufferedPipe returns an inmemory buffered pipe.\nfunc BufferedPipe(n int) (Receiver, Sender) {\n\tc := make(chan interface{}, n)\n\treturn pReceiver(c), pSender(c)\n}\n"
        },
        {
          "name": "inmem_test.go",
          "type": "blob",
          "size": 8.5078125,
          "content": "package libchan\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"runtime/pprof\"\n\t\"testing\"\n\t\"time\"\n)\n\ntype InMemMessage struct {\n\tData   string\n\tStream io.ReadWriteCloser\n\tRet    Sender\n}\n\nfunc TestInmemRetPipe(t *testing.T) {\n\tclient := func(t *testing.T, w Sender) {\n\t\tret, retPipe := Pipe()\n\t\tmessage := &InMemMessage{Data: \"hello\", Ret: retPipe}\n\n\t\terr := w.Send(message)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tmsg := &InMemMessage{}\n\t\terr = ret.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif msg.Data != \"this better not crash\" {\n\t\t\tt.Fatalf(\"%#v\", msg)\n\t\t}\n\n\t}\n\tserver := func(t *testing.T, r Receiver) {\n\t\tmsg := &InMemMessage{}\n\t\terr := r.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif msg.Data != \"hello\" {\n\t\t\tt.Fatalf(\"Wrong message:\\n\\tExpected: %s\\n\\tActual: %s\", \"hello\", msg.Data)\n\t\t}\n\t\tif msg.Ret == nil {\n\t\t\tt.Fatal(\"Message Ret is nil\")\n\t\t}\n\n\t\tmessage := &InMemMessage{Data: \"this better not crash\"}\n\t\tif err := msg.Ret.Send(message); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tSpawnPipeTestRoutines(t, client, server)\n\n}\n\nfunc TestSimpleSend(t *testing.T) {\n\tclient := func(t *testing.T, w Sender) {\n\t\tmessage := &InMemMessage{Data: \"hello world\"}\n\t\tif err := w.Send(message); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tserver := func(t *testing.T, r Receiver) {\n\t\tmsg := &InMemMessage{Data: \"hello world\"}\n\t\terr := r.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif msg.Data != \"hello world\" {\n\t\t\tt.Fatalf(\"%#v\", *msg)\n\t\t}\n\t}\n\tSpawnPipeTestRoutines(t, client, server)\n}\n\nfunc TestSendReply(t *testing.T) {\n\tclient := func(t *testing.T, w Sender) {\n\t\tret, retPipe := Pipe()\n\t\tmessage := &InMemMessage{Data: \"this is the request\", Ret: retPipe}\n\t\terr := w.Send(message)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\t// Read for a reply\n\t\tmsg := &InMemMessage{}\n\t\terr = ret.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif msg.Data != \"this is the reply\" {\n\t\t\tt.Fatalf(\"%#v\", msg)\n\t\t}\n\t}\n\tserver := func(t *testing.T, r Receiver) {\n\t\t// Receive a message with mode=Ret\n\t\tmsg := &InMemMessage{}\n\t\terr := r.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif msg.Data != \"this is the request\" {\n\t\t\tt.Fatalf(\"%#v\", msg)\n\t\t}\n\t\tif msg.Ret == nil {\n\t\t\tt.Fatalf(\"%#v\", msg)\n\t\t}\n\t\t// Send a reply\n\t\tmessage := &InMemMessage{Data: \"this is the reply\"}\n\t\terr = msg.Ret.Send(message)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t}\n\tSpawnPipeTestRoutines(t, client, server)\n}\n\nfunc TestSendFile(t *testing.T) {\n\ttmp, err := ioutil.TempFile(\"\", \"libchan-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tmp.Name())\n\tfmt.Fprintf(tmp, \"hello world\\n\")\n\ttmp.Sync()\n\ttmp.Seek(0, 0)\n\n\tclient := func(t *testing.T, w Sender) {\n\t\tmessage := &InMemMessage{Data: \"path=\" + tmp.Name(), Stream: tmp}\n\t\terr = w.Send(message)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tserver := func(t *testing.T, r Receiver) {\n\t\tmsg := &InMemMessage{}\n\t\terr := r.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif msg.Data != \"path=\"+tmp.Name() {\n\t\t\tt.Fatalf(\"%#v\", msg)\n\t\t}\n\t\ttxt, err := ioutil.ReadAll(msg.Stream)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(txt) != \"hello world\\n\" {\n\t\t\tt.Fatalf(\"%s\\n\", txt)\n\t\t}\n\n\t}\n\tSpawnPipeTestRoutines(t, client, server)\n}\n\ntype ComplexMessage struct {\n\tMessage  string\n\tSender   Sender\n\tReceiver Receiver\n\tStream   io.ReadWriteCloser\n}\n\ntype SimpleMessage struct {\n\tMessage string\n}\n\nfunc TestComplexMessage(t *testing.T) {\n\tclient := func(t *testing.T, w Sender) {\n\t\tremoteRecv, send := Pipe()\n\t\trecv, remoteSend := Pipe()\n\t\tbs, bsRemote := net.Pipe()\n\n\t\tm1 := &ComplexMessage{\n\t\t\tMessage:  \"This is a complex message\",\n\t\t\tSender:   remoteSend,\n\t\t\tReceiver: remoteRecv,\n\t\t\tStream:   bsRemote,\n\t\t}\n\n\t\tsendErr := w.Send(m1)\n\t\tif sendErr != nil {\n\t\t\tt.Fatalf(\"Error sending: %s\", sendErr)\n\t\t}\n\n\t\tm2 := &SimpleMessage{}\n\t\treceiveErr := recv.Receive(m2)\n\t\tif receiveErr != nil {\n\t\t\tt.Fatalf(\"Error receiving from message: %s\", receiveErr)\n\t\t}\n\n\t\tif expected := \"Return to sender\"; expected != m2.Message {\n\t\t\tt.Fatalf(\"Unexpected message\\n\\tExpected: %s\\n\\tActual: %s\", expected, m2.Message)\n\t\t}\n\n\t\tm3 := &SimpleMessage{\"Receive returned\"}\n\t\tsendErr = send.Send(m3)\n\t\tif sendErr != nil {\n\t\t\tt.Fatalf(\"Error sending return: %s\", sendErr)\n\t\t}\n\n\t\t_, writeErr := bs.Write([]byte(\"Hello there server!\"))\n\t\tif writeErr != nil {\n\t\t\tt.Fatalf(\"Error writing to byte stream: %s\", writeErr)\n\t\t}\n\n\t\treadBytes := make([]byte, 30)\n\t\tn, readErr := bs.Read(readBytes)\n\t\tif readErr != nil {\n\t\t\tt.Fatalf(\"Error reading from byte stream: %s\", readErr)\n\t\t}\n\t\tif expected := \"G'day client ☺\"; string(readBytes[:n]) != expected {\n\t\t\tt.Fatalf(\"Unexpected read value:\\n\\tExpected: %q\\n\\tActual: %q\", expected, string(readBytes[:n]))\n\t\t}\n\n\t\tcloseErr := bs.Close()\n\t\tif closeErr != nil {\n\t\t\tt.Fatalf(\"Error closing byte stream: %s\", closeErr)\n\t\t}\n\t}\n\tserver := func(t *testing.T, r Receiver) {\n\t\tm1 := &ComplexMessage{}\n\t\treceiveErr := r.Receive(m1)\n\t\tif receiveErr != nil {\n\t\t\tt.Fatalf(\"Error receiving: %s\", receiveErr)\n\t\t}\n\n\t\tif expected := \"This is a complex message\"; m1.Message != expected {\n\t\t\tt.Fatalf(\"Unexpected message\\n\\tExpected: %s\\n\\tActual: %s\", expected, m1.Message)\n\t\t}\n\n\t\tm2 := &SimpleMessage{\"Return to sender\"}\n\t\tsendErr := m1.Sender.Send(m2)\n\t\tif sendErr != nil {\n\t\t\tt.Fatalf(\"Error sending return: %s\", sendErr)\n\t\t}\n\n\t\tm3 := &SimpleMessage{}\n\t\treceiveErr = m1.Receiver.Receive(m3)\n\t\tif receiveErr != nil {\n\t\t\tt.Fatalf(\"Error receiving from message: %s\", receiveErr)\n\t\t}\n\n\t\tif expected := \"Receive returned\"; expected != m3.Message {\n\t\t\tt.Fatalf(\"Unexpected message\\n\\tExpected: %s\\n\\tActual: %s\", expected, m3.Message)\n\t\t}\n\n\t\treadBytes := make([]byte, 30)\n\t\tn, readErr := m1.Stream.Read(readBytes)\n\t\tif readErr != nil {\n\t\t\tt.Fatalf(\"Error reading from byte stream: %s\", readErr)\n\t\t}\n\t\tif expected := \"Hello there server!\"; string(readBytes[:n]) != expected {\n\t\t\tt.Fatalf(\"Unexpected read value:\\n\\tExpected: %q\\n\\tActual: %q\", expected, string(readBytes[:n]))\n\t\t}\n\n\t\t_, writeErr := m1.Stream.Write([]byte(\"G'day client ☺\"))\n\t\tif writeErr != nil {\n\t\t\tt.Fatalf(\"Error writing to byte stream: %s\", writeErr)\n\t\t}\n\n\t\tcloseErr := m1.Stream.Close()\n\t\tif closeErr != nil {\n\t\t\tt.Fatalf(\"Error closing byte stream: %s\", closeErr)\n\t\t}\n\n\t}\n\tSpawnPipeTestRoutines(t, client, server)\n}\n\nfunc TestInmemWrappedSend(t *testing.T) {\n\ttmp, err := ioutil.TempFile(\"\", \"libchan-test-\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer os.RemoveAll(tmp.Name())\n\tfmt.Fprintf(tmp, \"hello through a wrapper\\n\")\n\ttmp.Sync()\n\ttmp.Seek(0, 0)\n\n\tclient := func(t *testing.T, w Sender) {\n\t\tmessage := &InMemMessage{Data: \"path=\" + tmp.Name(), Stream: tmp}\n\t\terr = w.Send(message)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tserver := func(t *testing.T, r Receiver) {\n\t\tmsg := &InMemMessage{}\n\t\terr := r.Receive(msg)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif msg.Data != \"path=\"+tmp.Name() {\n\t\t\tt.Fatalf(\"%#v\", msg)\n\t\t}\n\t\ttxt, err := ioutil.ReadAll(msg.Stream)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif string(txt) != \"hello through a wrapper\\n\" {\n\t\t\tt.Fatalf(\"%s\\n\", txt)\n\t\t}\n\n\t}\n\tSpawnPipeTestRoutines(t, client, server)\n}\n\ntype SendTestRoutine func(*testing.T, Sender)\ntype ReceiveTestRoutine func(*testing.T, Receiver)\n\nvar RoutineTimeout = 300 * time.Millisecond\nvar DumpStackOnTimeout = true\n\nfunc SpawnPipeTestRoutines(t *testing.T, s SendTestRoutine, r ReceiveTestRoutine) {\n\tend1 := make(chan bool)\n\tend2 := make(chan bool)\n\n\treceiver, sender := Pipe()\n\n\tgo func() {\n\t\tdefer close(end1)\n\t\ts(t, sender)\n\t\terr := sender.Close()\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"Error closing sender: %s\", err)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\tdefer close(end2)\n\t\tr(t, receiver)\n\t}()\n\n\ttimeout := time.After(RoutineTimeout)\n\n\tfor end1 != nil || end2 != nil {\n\t\tselect {\n\t\tcase <-end1:\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatal(\"Send routine failed\")\n\t\t\t}\n\t\t\tend1 = nil\n\t\tcase <-end2:\n\t\t\tif t.Failed() {\n\t\t\t\tt.Fatal(\"Receive routine failed\")\n\t\t\t}\n\t\t\tend2 = nil\n\t\tcase <-timeout:\n\t\t\tif DumpStackOnTimeout {\n\t\t\t\tpprof.Lookup(\"goroutine\").WriteTo(os.Stdout, 1)\n\t\t\t}\n\t\t\tt.Fatal(\"Timeout\")\n\t\t}\n\t}\n}\n\ntype BenchMessage struct {\n\tI int\n}\n\nfunc BenchmarkRoundTrip(b *testing.B) {\n\tr1, s1 := Pipe()\n\tr2, s2 := Pipe()\n\tgo func() {\n\t\tvar m BenchMessage\n\t\tfor {\n\t\t\tif err := r1.Receive(&m); err != nil {\n\t\t\t\tb.Fatalf(\"Error receiving BenchMessage: %s\", err)\n\t\t\t}\n\t\t\tif err := s2.Send(&m); err != nil {\n\t\t\t\tb.Fatalf(\"Error sending BenchMessage: %s\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tvar sm BenchMessage\n\tvar rm BenchMessage\n\tfor i := 0; i < b.N; i++ {\n\t\tsm.I = i\n\t\tif err := s1.Send(&sm); err != nil {\n\t\t\tb.Fatalf(\"Error sending bench message: %s\", err)\n\t\t}\n\t\tif err := r2.Receive(&rm); err != nil {\n\t\t\tb.Fatalf(\"Error receiving bench message: %s\", err)\n\t\t}\n\t\tif rm.I != sm.I {\n\t\t\tb.Errorf(\"Wrong int received: %d, expecting: %d\", rm.I, sm.I)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "libchan.go",
          "type": "blob",
          "size": 1.404296875,
          "content": "package libchan\n\n// Transport represents a connection which can multiplex channels and\n// bytestreams.\ntype Transport interface {\n\t// NewSendChannel creates and returns a new send channel.  The receive\n\t// end will get picked up on the remote end of the transport through\n\t// the remote calling WaitReceiveChannel.\n\tNewSendChannel() (Sender, error)\n\n\t// WaitReceiveChannel waits for a new channel be created by the\n\t// remote end of the transport calling NewSendChannel.\n\tWaitReceiveChannel() (Receiver, error)\n}\n\n// Sender is a channel which sent messages of any content\n// including other channels and bytestreams.\ntype Sender interface {\n\t// Send sends a message across the channel to a receiver on the\n\t// other side of the underlying transport.\n\tSend(message interface{}) error\n\n\t// Close closes the channel.\n\tClose() error\n}\n\n// Receiver is a channel which can receive messages of any\n// content including other channels and bytestreams.\ntype Receiver interface {\n\t// Receive receives a message sent across the channel from\n\t// a sender on the other side of the underlying transport.\n\t// Receive is expected to receive the same object that was\n\t// sent by the Sender, any differences between the\n\t// receive and send type should be handled carefully.  It is\n\t// up to the application to determine type compatibility, if\n\t// the receive object is incompatible, Receiver will\n\t// throw an error.\n\tReceive(message interface{}) error\n}\n"
        },
        {
          "name": "spdy",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}