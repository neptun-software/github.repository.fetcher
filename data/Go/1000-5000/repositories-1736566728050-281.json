{
  "metadata": {
    "timestamp": 1736566728050,
    "page": 281,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gliderlabs/ssh",
      "stars": 3771,
      "defaultBranch": "master",
      "files": [
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.44140625,
          "content": "Copyright (c) 2016 Glider Labs. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n   * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n   * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n   * Neither the name of Glider Labs nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.4453125,
          "content": "# gliderlabs/ssh\n\n[![GoDoc](https://godoc.org/github.com/gliderlabs/ssh?status.svg)](https://godoc.org/github.com/gliderlabs/ssh) \n[![CircleCI](https://img.shields.io/circleci/project/github/gliderlabs/ssh.svg)](https://circleci.com/gh/gliderlabs/ssh)\n[![Go Report Card](https://goreportcard.com/badge/github.com/gliderlabs/ssh)](https://goreportcard.com/report/github.com/gliderlabs/ssh) \n[![OpenCollective](https://opencollective.com/ssh/sponsors/badge.svg)](#sponsors)\n[![Slack](http://slack.gliderlabs.com/badge.svg)](http://slack.gliderlabs.com) \n[![Email Updates](https://img.shields.io/badge/updates-subscribe-yellow.svg)](https://app.convertkit.com/landing_pages/243312)\n\n> The Glider Labs SSH server package is dope.  &mdash;[@bradfitz](https://twitter.com/bradfitz), Go team member\n\nThis Go package wraps the [crypto/ssh\npackage](https://godoc.org/golang.org/x/crypto/ssh) with a higher-level API for\nbuilding SSH servers. The goal of the API was to make it as simple as using\n[net/http](https://golang.org/pkg/net/http/), so the API is very similar:\n\n```go\n package main\n\n import (\n     \"github.com/gliderlabs/ssh\"\n     \"io\"\n     \"log\"\n )\n\n func main() {\n     ssh.Handle(func(s ssh.Session) {\n         io.WriteString(s, \"Hello world\\n\")\n     })  \n\n     log.Fatal(ssh.ListenAndServe(\":2222\", nil))\n }\n\n```\nThis package was built by [@progrium](https://twitter.com/progrium) after working on nearly a dozen projects at Glider Labs using SSH and collaborating with [@shazow](https://twitter.com/shazow) (known for [ssh-chat](https://github.com/shazow/ssh-chat)).\n\n## Examples\n\nA bunch of great examples are in the `_examples` directory.\n\n## Usage\n\n[See GoDoc reference.](https://godoc.org/github.com/gliderlabs/ssh)\n\n## Contributing\n\nPull requests are welcome! However, since this project is very much about API\ndesign, please submit API changes as issues to discuss before submitting PRs.\n\nAlso, you can [join our Slack](http://slack.gliderlabs.com) to discuss as well.\n\n## Roadmap\n\n* Non-session channel handlers\n* Cleanup callback API\n* 1.0 release\n* High-level client?\n\n## Sponsors\n\nBecome a sponsor and get your logo on our README on Github with a link to your site. [[Become a sponsor](https://opencollective.com/ssh#sponsor)]\n\n<a href=\"https://opencollective.com/ssh/sponsor/0/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/0/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/1/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/1/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/2/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/2/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/3/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/3/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/4/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/4/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/5/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/5/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/6/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/6/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/7/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/7/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/8/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/8/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/9/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/9/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/10/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/10/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/11/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/11/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/12/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/12/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/13/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/13/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/14/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/14/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/15/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/15/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/16/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/16/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/17/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/17/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/18/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/18/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/19/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/19/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/20/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/20/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/21/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/21/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/22/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/22/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/23/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/23/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/24/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/24/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/25/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/25/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/26/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/26/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/27/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/27/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/28/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/28/avatar.svg\"></a>\n<a href=\"https://opencollective.com/ssh/sponsor/29/website\" target=\"_blank\"><img src=\"https://opencollective.com/ssh/sponsor/29/avatar.svg\"></a>\n\n## License\n\n[BSD](LICENSE)\n"
        },
        {
          "name": "_examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "agent.go",
          "type": "blob",
          "size": 1.990234375,
          "content": "package ssh\n\nimport (\n\t\"io\"\n\t\"net\"\n\t\"os\"\n\t\"path\"\n\t\"sync\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nconst (\n\tagentRequestType = \"auth-agent-req@openssh.com\"\n\tagentChannelType = \"auth-agent@openssh.com\"\n\n\tagentTempDir    = \"auth-agent\"\n\tagentListenFile = \"listener.sock\"\n)\n\n// contextKeyAgentRequest is an internal context key for storing if the\n// client requested agent forwarding\nvar contextKeyAgentRequest = &contextKey{\"auth-agent-req\"}\n\n// SetAgentRequested sets up the session context so that AgentRequested\n// returns true.\nfunc SetAgentRequested(ctx Context) {\n\tctx.SetValue(contextKeyAgentRequest, true)\n}\n\n// AgentRequested returns true if the client requested agent forwarding.\nfunc AgentRequested(sess Session) bool {\n\treturn sess.Context().Value(contextKeyAgentRequest) == true\n}\n\n// NewAgentListener sets up a temporary Unix socket that can be communicated\n// to the session environment and used for forwarding connections.\nfunc NewAgentListener() (net.Listener, error) {\n\tdir, err := os.MkdirTemp(\"\", agentTempDir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tl, err := net.Listen(\"unix\", path.Join(dir, agentListenFile))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn l, nil\n}\n\n// ForwardAgentConnections takes connections from a listener to proxy into the\n// session on the OpenSSH channel for agent connections. It blocks and services\n// connections until the listener stop accepting.\nfunc ForwardAgentConnections(l net.Listener, s Session) {\n\tsshConn := s.Context().Value(ContextKeyConn).(gossh.Conn)\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tgo func(conn net.Conn) {\n\t\t\tdefer conn.Close()\n\t\t\tchannel, reqs, err := sshConn.OpenChannel(agentChannelType, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefer channel.Close()\n\t\t\tgo gossh.DiscardRequests(reqs)\n\t\t\tvar wg sync.WaitGroup\n\t\t\twg.Add(2)\n\t\t\tgo func() {\n\t\t\t\tio.Copy(conn, channel)\n\t\t\t\tconn.(*net.UnixConn).CloseWrite()\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\tgo func() {\n\t\t\t\tio.Copy(channel, conn)\n\t\t\t\tchannel.CloseWrite()\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t\twg.Wait()\n\t\t}(conn)\n\t}\n}\n"
        },
        {
          "name": "circle.yml",
          "type": "blob",
          "size": 0.466796875,
          "content": "version: 2\njobs:\n  build-go-latest:\n    docker:\n    - image: golang:latest\n    working_directory: /go/src/github.com/gliderlabs/ssh\n    steps:\n    - checkout\n    - run: go get\n    - run: go test -v -race\n\n  build-go-1.20:\n    docker:\n    - image: golang:1.20\n    working_directory: /go/src/github.com/gliderlabs/ssh\n    steps:\n    - checkout\n    - run: go get\n    - run: go test -v -race\n\nworkflows:\n  version: 2\n  build:\n    jobs:\n      - build-go-latest\n      - build-go-1.20\n"
        },
        {
          "name": "conn.go",
          "type": "blob",
          "size": 1.015625,
          "content": "package ssh\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"time\"\n)\n\ntype serverConn struct {\n\tnet.Conn\n\n\tidleTimeout   time.Duration\n\tmaxDeadline   time.Time\n\tcloseCanceler context.CancelFunc\n}\n\nfunc (c *serverConn) Write(p []byte) (n int, err error) {\n\tc.updateDeadline()\n\tn, err = c.Conn.Write(p)\n\tif _, isNetErr := err.(net.Error); isNetErr && c.closeCanceler != nil {\n\t\tc.closeCanceler()\n\t}\n\treturn\n}\n\nfunc (c *serverConn) Read(b []byte) (n int, err error) {\n\tc.updateDeadline()\n\tn, err = c.Conn.Read(b)\n\tif _, isNetErr := err.(net.Error); isNetErr && c.closeCanceler != nil {\n\t\tc.closeCanceler()\n\t}\n\treturn\n}\n\nfunc (c *serverConn) Close() (err error) {\n\terr = c.Conn.Close()\n\tif c.closeCanceler != nil {\n\t\tc.closeCanceler()\n\t}\n\treturn\n}\n\nfunc (c *serverConn) updateDeadline() {\n\tswitch {\n\tcase c.idleTimeout > 0:\n\t\tidleDeadline := time.Now().Add(c.idleTimeout)\n\t\tif idleDeadline.Unix() < c.maxDeadline.Unix() || c.maxDeadline.IsZero() {\n\t\t\tc.Conn.SetDeadline(idleDeadline)\n\t\t\treturn\n\t\t}\n\t\tfallthrough\n\tdefault:\n\t\tc.Conn.SetDeadline(c.maxDeadline)\n\t}\n}\n"
        },
        {
          "name": "context.go",
          "type": "blob",
          "size": 5.3046875,
          "content": "package ssh\n\nimport (\n\t\"context\"\n\t\"encoding/hex\"\n\t\"net\"\n\t\"sync\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\n// contextKey is a value for use with context.WithValue. It's used as\n// a pointer so it fits in an interface{} without allocation.\ntype contextKey struct {\n\tname string\n}\n\nvar (\n\t// ContextKeyUser is a context key for use with Contexts in this package.\n\t// The associated value will be of type string.\n\tContextKeyUser = &contextKey{\"user\"}\n\n\t// ContextKeySessionID is a context key for use with Contexts in this package.\n\t// The associated value will be of type string.\n\tContextKeySessionID = &contextKey{\"session-id\"}\n\n\t// ContextKeyPermissions is a context key for use with Contexts in this package.\n\t// The associated value will be of type *Permissions.\n\tContextKeyPermissions = &contextKey{\"permissions\"}\n\n\t// ContextKeyClientVersion is a context key for use with Contexts in this package.\n\t// The associated value will be of type string.\n\tContextKeyClientVersion = &contextKey{\"client-version\"}\n\n\t// ContextKeyServerVersion is a context key for use with Contexts in this package.\n\t// The associated value will be of type string.\n\tContextKeyServerVersion = &contextKey{\"server-version\"}\n\n\t// ContextKeyLocalAddr is a context key for use with Contexts in this package.\n\t// The associated value will be of type net.Addr.\n\tContextKeyLocalAddr = &contextKey{\"local-addr\"}\n\n\t// ContextKeyRemoteAddr is a context key for use with Contexts in this package.\n\t// The associated value will be of type net.Addr.\n\tContextKeyRemoteAddr = &contextKey{\"remote-addr\"}\n\n\t// ContextKeyServer is a context key for use with Contexts in this package.\n\t// The associated value will be of type *Server.\n\tContextKeyServer = &contextKey{\"ssh-server\"}\n\n\t// ContextKeyConn is a context key for use with Contexts in this package.\n\t// The associated value will be of type gossh.ServerConn.\n\tContextKeyConn = &contextKey{\"ssh-conn\"}\n\n\t// ContextKeyPublicKey is a context key for use with Contexts in this package.\n\t// The associated value will be of type PublicKey.\n\tContextKeyPublicKey = &contextKey{\"public-key\"}\n)\n\n// Context is a package specific context interface. It exposes connection\n// metadata and allows new values to be easily written to it. It's used in\n// authentication handlers and callbacks, and its underlying context.Context is\n// exposed on Session in the session Handler. A connection-scoped lock is also\n// embedded in the context to make it easier to limit operations per-connection.\ntype Context interface {\n\tcontext.Context\n\tsync.Locker\n\n\t// User returns the username used when establishing the SSH connection.\n\tUser() string\n\n\t// SessionID returns the session hash.\n\tSessionID() string\n\n\t// ClientVersion returns the version reported by the client.\n\tClientVersion() string\n\n\t// ServerVersion returns the version reported by the server.\n\tServerVersion() string\n\n\t// RemoteAddr returns the remote address for this connection.\n\tRemoteAddr() net.Addr\n\n\t// LocalAddr returns the local address for this connection.\n\tLocalAddr() net.Addr\n\n\t// Permissions returns the Permissions object used for this connection.\n\tPermissions() *Permissions\n\n\t// SetValue allows you to easily write new values into the underlying context.\n\tSetValue(key, value interface{})\n}\n\ntype sshContext struct {\n\tcontext.Context\n\t*sync.Mutex\n\n\tvalues   map[interface{}]interface{}\n\tvaluesMu sync.Mutex\n}\n\nfunc newContext(srv *Server) (*sshContext, context.CancelFunc) {\n\tinnerCtx, cancel := context.WithCancel(context.Background())\n\tctx := &sshContext{Context: innerCtx, Mutex: &sync.Mutex{}, values: make(map[interface{}]interface{})}\n\tctx.SetValue(ContextKeyServer, srv)\n\tperms := &Permissions{&gossh.Permissions{}}\n\tctx.SetValue(ContextKeyPermissions, perms)\n\treturn ctx, cancel\n}\n\n// this is separate from newContext because we will get ConnMetadata\n// at different points so it needs to be applied separately\nfunc applyConnMetadata(ctx Context, conn gossh.ConnMetadata) {\n\tif ctx.Value(ContextKeySessionID) != nil {\n\t\treturn\n\t}\n\tctx.SetValue(ContextKeySessionID, hex.EncodeToString(conn.SessionID()))\n\tctx.SetValue(ContextKeyClientVersion, string(conn.ClientVersion()))\n\tctx.SetValue(ContextKeyServerVersion, string(conn.ServerVersion()))\n\tctx.SetValue(ContextKeyUser, conn.User())\n\tctx.SetValue(ContextKeyLocalAddr, conn.LocalAddr())\n\tctx.SetValue(ContextKeyRemoteAddr, conn.RemoteAddr())\n}\n\nfunc (ctx *sshContext) Value(key interface{}) interface{} {\n\tctx.valuesMu.Lock()\n\tdefer ctx.valuesMu.Unlock()\n\tif v, ok := ctx.values[key]; ok {\n\t\treturn v\n\t}\n\treturn ctx.Context.Value(key)\n}\n\nfunc (ctx *sshContext) SetValue(key, value interface{}) {\n\tctx.valuesMu.Lock()\n\tdefer ctx.valuesMu.Unlock()\n\tctx.values[key] = value\n}\n\nfunc (ctx *sshContext) User() string {\n\treturn ctx.Value(ContextKeyUser).(string)\n}\n\nfunc (ctx *sshContext) SessionID() string {\n\treturn ctx.Value(ContextKeySessionID).(string)\n}\n\nfunc (ctx *sshContext) ClientVersion() string {\n\treturn ctx.Value(ContextKeyClientVersion).(string)\n}\n\nfunc (ctx *sshContext) ServerVersion() string {\n\treturn ctx.Value(ContextKeyServerVersion).(string)\n}\n\nfunc (ctx *sshContext) RemoteAddr() net.Addr {\n\tif addr, ok := ctx.Value(ContextKeyRemoteAddr).(net.Addr); ok {\n\t\treturn addr\n\t}\n\treturn nil\n}\n\nfunc (ctx *sshContext) LocalAddr() net.Addr {\n\treturn ctx.Value(ContextKeyLocalAddr).(net.Addr)\n}\n\nfunc (ctx *sshContext) Permissions() *Permissions {\n\treturn ctx.Value(ContextKeyPermissions).(*Permissions)\n}\n"
        },
        {
          "name": "context_test.go",
          "type": "blob",
          "size": 1.87890625,
          "content": "package ssh\n\nimport (\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestSetPermissions(t *testing.T) {\n\tt.Parallel()\n\tpermsExt := map[string]string{\n\t\t\"foo\": \"bar\",\n\t}\n\tsession, _, cleanup := newTestSessionWithOptions(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\tif _, ok := s.Permissions().Extensions[\"foo\"]; !ok {\n\t\t\t\tt.Fatalf(\"got %#v; want %#v\", s.Permissions().Extensions, permsExt)\n\t\t\t}\n\t\t},\n\t}, nil, PasswordAuth(func(ctx Context, password string) bool {\n\t\tctx.Permissions().Extensions = permsExt\n\t\treturn true\n\t}))\n\tdefer cleanup()\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSetValue(t *testing.T) {\n\tt.Parallel()\n\tvalue := map[string]string{\n\t\t\"foo\": \"bar\",\n\t}\n\tkey := \"testValue\"\n\tsession, _, cleanup := newTestSessionWithOptions(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\tv := s.Context().Value(key).(map[string]string)\n\t\t\tif v[\"foo\"] != value[\"foo\"] {\n\t\t\t\tt.Fatalf(\"got %#v; want %#v\", v, value)\n\t\t\t}\n\t\t},\n\t}, nil, PasswordAuth(func(ctx Context, password string) bool {\n\t\tctx.SetValue(key, value)\n\t\treturn true\n\t}))\n\tdefer cleanup()\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestSetValueConcurrency(t *testing.T) {\n\tctx, cancel := newContext(nil)\n\tdefer cancel()\n\n\tgo func() {\n\t\tfor { // use a loop to access context.Context functions to make sure they are thread-safe with SetValue\n\t\t\t_, _ = ctx.Deadline()\n\t\t\t_ = ctx.Err()\n\t\t\t_ = ctx.Value(\"foo\")\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}()\n\tctx.SetValue(\"bar\", -1) // a context value which never changes\n\tnow := time.Now()\n\tvar cnt int64\n\tgo func() {\n\t\tfor time.Since(now) < 100*time.Millisecond {\n\t\t\tcnt++\n\t\t\tctx.SetValue(\"foo\", cnt) // a context value which changes a lot\n\t\t}\n\t\tcancel()\n\t}()\n\t<-ctx.Done()\n\tif ctx.Value(\"foo\") != cnt {\n\t\tt.Fatal(\"context.Value(foo) doesn't match latest SetValue\")\n\t}\n\tif ctx.Value(\"bar\") != -1 {\n\t\tt.Fatal(\"context.Value(bar) doesn't match latest SetValue\")\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 1.7353515625,
          "content": "/*\nPackage ssh wraps the crypto/ssh package with a higher-level API for building\nSSH servers. The goal of the API was to make it as simple as using net/http, so\nthe API is very similar.\n\nYou should be able to build any SSH server using only this package, which wraps\nrelevant types and some functions from crypto/ssh. However, you still need to\nuse crypto/ssh for building SSH clients.\n\nListenAndServe starts an SSH server with a given address, handler, and options. The\nhandler is usually nil, which means to use DefaultHandler. Handle sets DefaultHandler:\n\n  ssh.Handle(func(s ssh.Session) {\n      io.WriteString(s, \"Hello world\\n\")\n  })\n\n  log.Fatal(ssh.ListenAndServe(\":2222\", nil))\n\nIf you don't specify a host key, it will generate one every time. This is convenient\nexcept you'll have to deal with clients being confused that the host key is different.\nIt's a better idea to generate or point to an existing key on your system:\n\n  log.Fatal(ssh.ListenAndServe(\":2222\", nil, ssh.HostKeyFile(\"/Users/progrium/.ssh/id_rsa\")))\n\nAlthough all options have functional option helpers, another way to control the\nserver's behavior is by creating a custom Server:\n\n  s := &ssh.Server{\n      Addr:             \":2222\",\n      Handler:          sessionHandler,\n      PublicKeyHandler: authHandler,\n  }\n  s.AddHostKey(hostKeySigner)\n\n  log.Fatal(s.ListenAndServe())\n\nThis package automatically handles basic SSH requests like setting environment\nvariables, requesting PTY, and changing window size. These requests are\nprocessed, responded to, and any relevant state is updated. This state is then\nexposed to you via the Session interface.\n\nThe one big feature missing from the Session abstraction is signals. This was\nstarted, but not completed. Pull Requests welcome!\n*/\npackage ssh\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 0.806640625,
          "content": "package ssh_test\n\nimport (\n\t\"io\"\n\t\"os\"\n\n\t\"github.com/gliderlabs/ssh\"\n)\n\nfunc ExampleListenAndServe() {\n\tssh.ListenAndServe(\":2222\", func(s ssh.Session) {\n\t\tio.WriteString(s, \"Hello world\\n\")\n\t})\n}\n\nfunc ExamplePasswordAuth() {\n\tssh.ListenAndServe(\":2222\", nil,\n\t\tssh.PasswordAuth(func(ctx ssh.Context, pass string) bool {\n\t\t\treturn pass == \"secret\"\n\t\t}),\n\t)\n}\n\nfunc ExampleNoPty() {\n\tssh.ListenAndServe(\":2222\", nil, ssh.NoPty())\n}\n\nfunc ExamplePublicKeyAuth() {\n\tssh.ListenAndServe(\":2222\", nil,\n\t\tssh.PublicKeyAuth(func(ctx ssh.Context, key ssh.PublicKey) bool {\n\t\t\tdata, _ := os.ReadFile(\"/path/to/allowed/key.pub\")\n\t\t\tallowed, _, _, _, _ := ssh.ParseAuthorizedKey(data)\n\t\t\treturn ssh.KeysEqual(key, allowed)\n\t\t}),\n\t)\n}\n\nfunc ExampleHostKeyFile() {\n\tssh.ListenAndServe(\":2222\", nil, ssh.HostKeyFile(\"/path/to/host/key\"))\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.189453125,
          "content": "module github.com/gliderlabs/ssh\n\ngo 1.20\n\nrequire (\n\tgithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be\n\tgolang.org/x/crypto v0.31.0\n)\n\nrequire golang.org/x/sys v0.28.0 // indirect\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.6005859375,
          "content": "github.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=\ngithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=\ngolang.org/x/crypto v0.31.0 h1:ihbySMvVjLAeSH1IbfcRTkD/iNscyz8rGzjF/E5hV6U=\ngolang.org/x/crypto v0.31.0/go.mod h1:kDsLvtWBEx7MV9tJOj9bnXsPbxwJQ6csT/x4KIN4Ssk=\ngolang.org/x/sys v0.28.0 h1:Fksou7UEQUWlKvIdsqzJmUmCX3cZuD2+P3XyyzwMhlA=\ngolang.org/x/sys v0.28.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.27.0 h1:WP60Sv1nlK1T6SupCHbXzSaN0b9wUmsPoRS9b61A23Q=\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 1.7607421875,
          "content": "package ssh\n\nimport (\n\t\"os\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\n// PasswordAuth returns a functional option that sets PasswordHandler on the server.\nfunc PasswordAuth(fn PasswordHandler) Option {\n\treturn func(srv *Server) error {\n\t\tsrv.PasswordHandler = fn\n\t\treturn nil\n\t}\n}\n\n// PublicKeyAuth returns a functional option that sets PublicKeyHandler on the server.\nfunc PublicKeyAuth(fn PublicKeyHandler) Option {\n\treturn func(srv *Server) error {\n\t\tsrv.PublicKeyHandler = fn\n\t\treturn nil\n\t}\n}\n\n// HostKeyFile returns a functional option that adds HostSigners to the server\n// from a PEM file at filepath.\nfunc HostKeyFile(filepath string) Option {\n\treturn func(srv *Server) error {\n\t\tpemBytes, err := os.ReadFile(filepath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsigner, err := gossh.ParsePrivateKey(pemBytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsrv.AddHostKey(signer)\n\n\t\treturn nil\n\t}\n}\n\nfunc KeyboardInteractiveAuth(fn KeyboardInteractiveHandler) Option {\n\treturn func(srv *Server) error {\n\t\tsrv.KeyboardInteractiveHandler = fn\n\t\treturn nil\n\t}\n}\n\n// HostKeyPEM returns a functional option that adds HostSigners to the server\n// from a PEM file as bytes.\nfunc HostKeyPEM(bytes []byte) Option {\n\treturn func(srv *Server) error {\n\t\tsigner, err := gossh.ParsePrivateKey(bytes)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsrv.AddHostKey(signer)\n\n\t\treturn nil\n\t}\n}\n\n// NoPty returns a functional option that sets PtyCallback to return false,\n// denying PTY requests.\nfunc NoPty() Option {\n\treturn func(srv *Server) error {\n\t\tsrv.PtyCallback = func(ctx Context, pty Pty) bool {\n\t\t\treturn false\n\t\t}\n\t\treturn nil\n\t}\n}\n\n// WrapConn returns a functional option that sets ConnCallback on the server.\nfunc WrapConn(fn ConnCallback) Option {\n\treturn func(srv *Server) error {\n\t\tsrv.ConnCallback = fn\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 2.4794921875,
          "content": "package ssh\n\nimport (\n\t\"net\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"testing\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nfunc newTestSessionWithOptions(t *testing.T, srv *Server, cfg *gossh.ClientConfig, options ...Option) (*gossh.Session, *gossh.Client, func()) {\n\tfor _, option := range options {\n\t\tif err := srv.SetOption(option); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\treturn newTestSession(t, srv, cfg)\n}\n\nfunc TestPasswordAuth(t *testing.T) {\n\tt.Parallel()\n\ttestUser := \"testuser\"\n\ttestPass := \"testpass\"\n\tsession, _, cleanup := newTestSessionWithOptions(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\t// noop\n\t\t},\n\t}, &gossh.ClientConfig{\n\t\tUser: testUser,\n\t\tAuth: []gossh.AuthMethod{\n\t\t\tgossh.Password(testPass),\n\t\t},\n\t\tHostKeyCallback: gossh.InsecureIgnoreHostKey(),\n\t}, PasswordAuth(func(ctx Context, password string) bool {\n\t\tif ctx.User() != testUser {\n\t\t\tt.Fatalf(\"user = %#v; want %#v\", ctx.User(), testUser)\n\t\t}\n\t\tif password != testPass {\n\t\t\tt.Fatalf(\"user = %#v; want %#v\", password, testPass)\n\t\t}\n\t\treturn true\n\t}))\n\tdefer cleanup()\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPasswordAuthBadPass(t *testing.T) {\n\tt.Parallel()\n\tl := newLocalListener()\n\tsrv := &Server{Handler: func(s Session) {}}\n\tsrv.SetOption(PasswordAuth(func(ctx Context, password string) bool {\n\t\treturn false\n\t}))\n\tgo srv.serveOnce(l)\n\t_, err := gossh.Dial(\"tcp\", l.Addr().String(), &gossh.ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []gossh.AuthMethod{\n\t\t\tgossh.Password(\"testpass\"),\n\t\t},\n\t\tHostKeyCallback: gossh.InsecureIgnoreHostKey(),\n\t})\n\tif err != nil {\n\t\tif !strings.Contains(err.Error(), \"unable to authenticate\") {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\ntype wrappedConn struct {\n\tnet.Conn\n\twritten int32\n}\n\nfunc (c *wrappedConn) Write(p []byte) (n int, err error) {\n\tn, err = c.Conn.Write(p)\n\tatomic.AddInt32(&(c.written), int32(n))\n\treturn\n}\n\nfunc TestConnWrapping(t *testing.T) {\n\tt.Parallel()\n\tvar wrapped *wrappedConn\n\tsession, _, cleanup := newTestSessionWithOptions(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\t// nothing\n\t\t},\n\t}, &gossh.ClientConfig{\n\t\tUser: \"testuser\",\n\t\tAuth: []gossh.AuthMethod{\n\t\t\tgossh.Password(\"testpass\"),\n\t\t},\n\t\tHostKeyCallback: gossh.InsecureIgnoreHostKey(),\n\t}, PasswordAuth(func(ctx Context, password string) bool {\n\t\treturn true\n\t}), WrapConn(func(ctx Context, conn net.Conn) net.Conn {\n\t\twrapped = &wrappedConn{conn, 0}\n\t\treturn wrapped\n\t}))\n\tdefer cleanup()\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif atomic.LoadInt32(&(wrapped.written)) == 0 {\n\t\tt.Fatal(\"wrapped conn not written to\")\n\t}\n}\n"
        },
        {
          "name": "server.go",
          "type": "blob",
          "size": 12.9375,
          "content": "package ssh\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\t\"time\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\n// ErrServerClosed is returned by the Server's Serve, ListenAndServe,\n// and ListenAndServeTLS methods after a call to Shutdown or Close.\nvar ErrServerClosed = errors.New(\"ssh: Server closed\")\n\ntype SubsystemHandler func(s Session)\n\nvar DefaultSubsystemHandlers = map[string]SubsystemHandler{}\n\ntype RequestHandler func(ctx Context, srv *Server, req *gossh.Request) (ok bool, payload []byte)\n\nvar DefaultRequestHandlers = map[string]RequestHandler{}\n\ntype ChannelHandler func(srv *Server, conn *gossh.ServerConn, newChan gossh.NewChannel, ctx Context)\n\nvar DefaultChannelHandlers = map[string]ChannelHandler{\n\t\"session\": DefaultSessionHandler,\n}\n\n// Server defines parameters for running an SSH server. The zero value for\n// Server is a valid configuration. When both PasswordHandler and\n// PublicKeyHandler are nil, no client authentication is performed.\ntype Server struct {\n\tAddr        string   // TCP address to listen on, \":22\" if empty\n\tHandler     Handler  // handler to invoke, ssh.DefaultHandler if nil\n\tHostSigners []Signer // private keys for the host key, must have at least one\n\tVersion     string   // server version to be sent before the initial handshake\n\tBanner      string   // server banner\n\n\tBannerHandler                 BannerHandler                 // server banner handler, overrides Banner\n\tKeyboardInteractiveHandler    KeyboardInteractiveHandler    // keyboard-interactive authentication handler\n\tPasswordHandler               PasswordHandler               // password authentication handler\n\tPublicKeyHandler              PublicKeyHandler              // public key authentication handler\n\tPtyCallback                   PtyCallback                   // callback for allowing PTY sessions, allows all if nil\n\tConnCallback                  ConnCallback                  // optional callback for wrapping net.Conn before handling\n\tLocalPortForwardingCallback   LocalPortForwardingCallback   // callback for allowing local port forwarding, denies all if nil\n\tReversePortForwardingCallback ReversePortForwardingCallback // callback for allowing reverse port forwarding, denies all if nil\n\tServerConfigCallback          ServerConfigCallback          // callback for configuring detailed SSH options\n\tSessionRequestCallback        SessionRequestCallback        // callback for allowing or denying SSH sessions\n\n\tConnectionFailedCallback ConnectionFailedCallback // callback to report connection failures\n\n\tIdleTimeout time.Duration // connection timeout when no activity, none if empty\n\tMaxTimeout  time.Duration // absolute connection timeout, none if empty\n\n\t// ChannelHandlers allow overriding the built-in session handlers or provide\n\t// extensions to the protocol, such as tcpip forwarding. By default only the\n\t// \"session\" handler is enabled.\n\tChannelHandlers map[string]ChannelHandler\n\n\t// RequestHandlers allow overriding the server-level request handlers or\n\t// provide extensions to the protocol, such as tcpip forwarding. By default\n\t// no handlers are enabled.\n\tRequestHandlers map[string]RequestHandler\n\n\t// SubsystemHandlers are handlers which are similar to the usual SSH command\n\t// handlers, but handle named subsystems.\n\tSubsystemHandlers map[string]SubsystemHandler\n\n\tlistenerWg sync.WaitGroup\n\tmu         sync.RWMutex\n\tlisteners  map[net.Listener]struct{}\n\tconns      map[*gossh.ServerConn]struct{}\n\tconnWg     sync.WaitGroup\n\tdoneChan   chan struct{}\n}\n\nfunc (srv *Server) ensureHostSigner() error {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\tif len(srv.HostSigners) == 0 {\n\t\tsigner, err := generateSigner()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsrv.HostSigners = append(srv.HostSigners, signer)\n\t}\n\treturn nil\n}\n\nfunc (srv *Server) ensureHandlers() {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\tif srv.RequestHandlers == nil {\n\t\tsrv.RequestHandlers = map[string]RequestHandler{}\n\t\tfor k, v := range DefaultRequestHandlers {\n\t\t\tsrv.RequestHandlers[k] = v\n\t\t}\n\t}\n\tif srv.ChannelHandlers == nil {\n\t\tsrv.ChannelHandlers = map[string]ChannelHandler{}\n\t\tfor k, v := range DefaultChannelHandlers {\n\t\t\tsrv.ChannelHandlers[k] = v\n\t\t}\n\t}\n\tif srv.SubsystemHandlers == nil {\n\t\tsrv.SubsystemHandlers = map[string]SubsystemHandler{}\n\t\tfor k, v := range DefaultSubsystemHandlers {\n\t\t\tsrv.SubsystemHandlers[k] = v\n\t\t}\n\t}\n}\n\nfunc (srv *Server) config(ctx Context) *gossh.ServerConfig {\n\tsrv.mu.RLock()\n\tdefer srv.mu.RUnlock()\n\n\tvar config *gossh.ServerConfig\n\tif srv.ServerConfigCallback == nil {\n\t\tconfig = &gossh.ServerConfig{}\n\t} else {\n\t\tconfig = srv.ServerConfigCallback(ctx)\n\t}\n\tfor _, signer := range srv.HostSigners {\n\t\tconfig.AddHostKey(signer)\n\t}\n\tif srv.PasswordHandler == nil && srv.PublicKeyHandler == nil && srv.KeyboardInteractiveHandler == nil {\n\t\tconfig.NoClientAuth = true\n\t}\n\tif srv.Version != \"\" {\n\t\tconfig.ServerVersion = \"SSH-2.0-\" + srv.Version\n\t}\n\tif srv.Banner != \"\" {\n\t\tconfig.BannerCallback = func(_ gossh.ConnMetadata) string {\n\t\t\treturn srv.Banner\n\t\t}\n\t}\n\tif srv.BannerHandler != nil {\n\t\tconfig.BannerCallback = func(conn gossh.ConnMetadata) string {\n\t\t\tapplyConnMetadata(ctx, conn)\n\t\t\treturn srv.BannerHandler(ctx)\n\t\t}\n\t}\n\tif srv.PasswordHandler != nil {\n\t\tconfig.PasswordCallback = func(conn gossh.ConnMetadata, password []byte) (*gossh.Permissions, error) {\n\t\t\tapplyConnMetadata(ctx, conn)\n\t\t\tif ok := srv.PasswordHandler(ctx, string(password)); !ok {\n\t\t\t\treturn ctx.Permissions().Permissions, fmt.Errorf(\"permission denied\")\n\t\t\t}\n\t\t\treturn ctx.Permissions().Permissions, nil\n\t\t}\n\t}\n\tif srv.PublicKeyHandler != nil {\n\t\tconfig.PublicKeyCallback = func(conn gossh.ConnMetadata, key gossh.PublicKey) (*gossh.Permissions, error) {\n\t\t\tapplyConnMetadata(ctx, conn)\n\t\t\tif ok := srv.PublicKeyHandler(ctx, key); !ok {\n\t\t\t\treturn ctx.Permissions().Permissions, fmt.Errorf(\"permission denied\")\n\t\t\t}\n\t\t\tctx.SetValue(ContextKeyPublicKey, key)\n\t\t\treturn ctx.Permissions().Permissions, nil\n\t\t}\n\t}\n\tif srv.KeyboardInteractiveHandler != nil {\n\t\tconfig.KeyboardInteractiveCallback = func(conn gossh.ConnMetadata, challenger gossh.KeyboardInteractiveChallenge) (*gossh.Permissions, error) {\n\t\t\tapplyConnMetadata(ctx, conn)\n\t\t\tif ok := srv.KeyboardInteractiveHandler(ctx, challenger); !ok {\n\t\t\t\treturn ctx.Permissions().Permissions, fmt.Errorf(\"permission denied\")\n\t\t\t}\n\t\t\treturn ctx.Permissions().Permissions, nil\n\t\t}\n\t}\n\treturn config\n}\n\n// Handle sets the Handler for the server.\nfunc (srv *Server) Handle(fn Handler) {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\tsrv.Handler = fn\n}\n\n// Close immediately closes all active listeners and all active\n// connections.\n//\n// Close returns any error returned from closing the Server's\n// underlying Listener(s).\nfunc (srv *Server) Close() error {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\tsrv.closeDoneChanLocked()\n\terr := srv.closeListenersLocked()\n\tfor c := range srv.conns {\n\t\tc.Close()\n\t\tdelete(srv.conns, c)\n\t}\n\treturn err\n}\n\n// Shutdown gracefully shuts down the server without interrupting any\n// active connections. Shutdown works by first closing all open\n// listeners, and then waiting indefinitely for connections to close.\n// If the provided context expires before the shutdown is complete,\n// then the context's error is returned.\nfunc (srv *Server) Shutdown(ctx context.Context) error {\n\tsrv.mu.Lock()\n\tlnerr := srv.closeListenersLocked()\n\tsrv.closeDoneChanLocked()\n\tsrv.mu.Unlock()\n\n\tfinished := make(chan struct{}, 1)\n\tgo func() {\n\t\tsrv.listenerWg.Wait()\n\t\tsrv.connWg.Wait()\n\t\tfinished <- struct{}{}\n\t}()\n\n\tselect {\n\tcase <-ctx.Done():\n\t\treturn ctx.Err()\n\tcase <-finished:\n\t\treturn lnerr\n\t}\n}\n\n// Serve accepts incoming connections on the Listener l, creating a new\n// connection goroutine for each. The connection goroutines read requests and then\n// calls srv.Handler to handle sessions.\n//\n// Serve always returns a non-nil error.\nfunc (srv *Server) Serve(l net.Listener) error {\n\tsrv.ensureHandlers()\n\tdefer l.Close()\n\tif err := srv.ensureHostSigner(); err != nil {\n\t\treturn err\n\t}\n\tif srv.Handler == nil {\n\t\tsrv.Handler = DefaultHandler\n\t}\n\tvar tempDelay time.Duration\n\n\tsrv.trackListener(l, true)\n\tdefer srv.trackListener(l, false)\n\tfor {\n\t\tconn, e := l.Accept()\n\t\tif e != nil {\n\t\t\tselect {\n\t\t\tcase <-srv.getDoneChan():\n\t\t\t\treturn ErrServerClosed\n\t\t\tdefault:\n\t\t\t}\n\t\t\tif ne, ok := e.(net.Error); ok && ne.Temporary() {\n\t\t\t\tif tempDelay == 0 {\n\t\t\t\t\ttempDelay = 5 * time.Millisecond\n\t\t\t\t} else {\n\t\t\t\t\ttempDelay *= 2\n\t\t\t\t}\n\t\t\t\tif max := 1 * time.Second; tempDelay > max {\n\t\t\t\t\ttempDelay = max\n\t\t\t\t}\n\t\t\t\ttime.Sleep(tempDelay)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\treturn e\n\t\t}\n\t\tgo srv.HandleConn(conn)\n\t}\n}\n\nfunc (srv *Server) HandleConn(newConn net.Conn) {\n\tctx, cancel := newContext(srv)\n\tif srv.ConnCallback != nil {\n\t\tcbConn := srv.ConnCallback(ctx, newConn)\n\t\tif cbConn == nil {\n\t\t\tnewConn.Close()\n\t\t\treturn\n\t\t}\n\t\tnewConn = cbConn\n\t}\n\tconn := &serverConn{\n\t\tConn:          newConn,\n\t\tidleTimeout:   srv.IdleTimeout,\n\t\tcloseCanceler: cancel,\n\t}\n\tif srv.MaxTimeout > 0 {\n\t\tconn.maxDeadline = time.Now().Add(srv.MaxTimeout)\n\t}\n\tdefer conn.Close()\n\tsshConn, chans, reqs, err := gossh.NewServerConn(conn, srv.config(ctx))\n\tif err != nil {\n\t\tif srv.ConnectionFailedCallback != nil {\n\t\t\tsrv.ConnectionFailedCallback(conn, err)\n\t\t}\n\t\treturn\n\t}\n\n\tsrv.trackConn(sshConn, true)\n\tdefer srv.trackConn(sshConn, false)\n\n\tctx.SetValue(ContextKeyConn, sshConn)\n\tapplyConnMetadata(ctx, sshConn)\n\t//go gossh.DiscardRequests(reqs)\n\tgo srv.handleRequests(ctx, reqs)\n\tfor ch := range chans {\n\t\thandler := srv.ChannelHandlers[ch.ChannelType()]\n\t\tif handler == nil {\n\t\t\thandler = srv.ChannelHandlers[\"default\"]\n\t\t}\n\t\tif handler == nil {\n\t\t\tch.Reject(gossh.UnknownChannelType, \"unsupported channel type\")\n\t\t\tcontinue\n\t\t}\n\t\tgo handler(srv, sshConn, ch, ctx)\n\t}\n}\n\nfunc (srv *Server) handleRequests(ctx Context, in <-chan *gossh.Request) {\n\tfor req := range in {\n\t\thandler := srv.RequestHandlers[req.Type]\n\t\tif handler == nil {\n\t\t\thandler = srv.RequestHandlers[\"default\"]\n\t\t}\n\t\tif handler == nil {\n\t\t\treq.Reply(false, nil)\n\t\t\tcontinue\n\t\t}\n\t\t/*reqCtx, cancel := context.WithCancel(ctx)\n\t\tdefer cancel() */\n\t\tret, payload := handler(ctx, srv, req)\n\t\treq.Reply(ret, payload)\n\t}\n}\n\n// ListenAndServe listens on the TCP network address srv.Addr and then calls\n// Serve to handle incoming connections. If srv.Addr is blank, \":22\" is used.\n// ListenAndServe always returns a non-nil error.\nfunc (srv *Server) ListenAndServe() error {\n\taddr := srv.Addr\n\tif addr == \"\" {\n\t\taddr = \":22\"\n\t}\n\tln, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn srv.Serve(ln)\n}\n\n// AddHostKey adds a private key as a host key. If an existing host key exists\n// with the same algorithm, it is overwritten. Each server config must have at\n// least one host key.\nfunc (srv *Server) AddHostKey(key Signer) {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\t// these are later added via AddHostKey on ServerConfig, which performs the\n\t// check for one of every algorithm.\n\n\t// This check is based on the AddHostKey method from the x/crypto/ssh\n\t// library. This allows us to only keep one active key for each type on a\n\t// server at once. So, if you're dynamically updating keys at runtime, this\n\t// list will not keep growing.\n\tfor i, k := range srv.HostSigners {\n\t\tif k.PublicKey().Type() == key.PublicKey().Type() {\n\t\t\tsrv.HostSigners[i] = key\n\t\t\treturn\n\t\t}\n\t}\n\n\tsrv.HostSigners = append(srv.HostSigners, key)\n}\n\n// SetOption runs a functional option against the server.\nfunc (srv *Server) SetOption(option Option) error {\n\t// NOTE: there is a potential race here for any option that doesn't call an\n\t// internal method. We can't actually lock here because if something calls\n\t// (as an example) AddHostKey, it will deadlock.\n\n\t//srv.mu.Lock()\n\t//defer srv.mu.Unlock()\n\n\treturn option(srv)\n}\n\nfunc (srv *Server) getDoneChan() <-chan struct{} {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\treturn srv.getDoneChanLocked()\n}\n\nfunc (srv *Server) getDoneChanLocked() chan struct{} {\n\tif srv.doneChan == nil {\n\t\tsrv.doneChan = make(chan struct{})\n\t}\n\treturn srv.doneChan\n}\n\nfunc (srv *Server) closeDoneChanLocked() {\n\tch := srv.getDoneChanLocked()\n\tselect {\n\tcase <-ch:\n\t\t// Already closed. Don't close again.\n\tdefault:\n\t\t// Safe to close here. We're the only closer, guarded\n\t\t// by srv.mu.\n\t\tclose(ch)\n\t}\n}\n\nfunc (srv *Server) closeListenersLocked() error {\n\tvar err error\n\tfor ln := range srv.listeners {\n\t\tif cerr := ln.Close(); cerr != nil && err == nil {\n\t\t\terr = cerr\n\t\t}\n\t\tdelete(srv.listeners, ln)\n\t}\n\treturn err\n}\n\nfunc (srv *Server) trackListener(ln net.Listener, add bool) {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\tif srv.listeners == nil {\n\t\tsrv.listeners = make(map[net.Listener]struct{})\n\t}\n\tif add {\n\t\t// If the *Server is being reused after a previous\n\t\t// Close or Shutdown, reset its doneChan:\n\t\tif len(srv.listeners) == 0 && len(srv.conns) == 0 {\n\t\t\tsrv.doneChan = nil\n\t\t}\n\t\tsrv.listeners[ln] = struct{}{}\n\t\tsrv.listenerWg.Add(1)\n\t} else {\n\t\tdelete(srv.listeners, ln)\n\t\tsrv.listenerWg.Done()\n\t}\n}\n\nfunc (srv *Server) trackConn(c *gossh.ServerConn, add bool) {\n\tsrv.mu.Lock()\n\tdefer srv.mu.Unlock()\n\n\tif srv.conns == nil {\n\t\tsrv.conns = make(map[*gossh.ServerConn]struct{})\n\t}\n\tif add {\n\t\tsrv.conns[c] = struct{}{}\n\t\tsrv.connWg.Add(1)\n\t} else {\n\t\tdelete(srv.conns, c)\n\t\tsrv.connWg.Done()\n\t}\n}\n"
        },
        {
          "name": "server_test.go",
          "type": "blob",
          "size": 2.2421875,
          "content": "package ssh\n\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"io\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc TestAddHostKey(t *testing.T) {\n\ts := Server{}\n\tsigner, err := generateSigner()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts.AddHostKey(signer)\n\tif len(s.HostSigners) != 1 {\n\t\tt.Fatal(\"Key was not properly added\")\n\t}\n\tsigner, err = generateSigner()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\ts.AddHostKey(signer)\n\tif len(s.HostSigners) != 1 {\n\t\tt.Fatal(\"Key was not properly replaced\")\n\t}\n}\n\nfunc TestServerShutdown(t *testing.T) {\n\tl := newLocalListener()\n\ttestBytes := []byte(\"Hello world\\n\")\n\ts := &Server{\n\t\tHandler: func(s Session) {\n\t\t\ts.Write(testBytes)\n\t\t\ttime.Sleep(50 * time.Millisecond)\n\t\t},\n\t}\n\tgo func() {\n\t\terr := s.Serve(l)\n\t\tif err != nil && err != ErrServerClosed {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\tsessDone := make(chan struct{})\n\tsess, _, cleanup := newClientSession(t, l.Addr().String(), nil)\n\tgo func() {\n\t\tdefer cleanup()\n\t\tdefer close(sessDone)\n\t\tvar stdout bytes.Buffer\n\t\tsess.Stdout = &stdout\n\t\tif err := sess.Run(\"\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif !bytes.Equal(stdout.Bytes(), testBytes) {\n\t\t\tt.Fatalf(\"expected = %s; got %s\", testBytes, stdout.Bytes())\n\t\t}\n\t}()\n\n\tsrvDone := make(chan struct{})\n\tgo func() {\n\t\tdefer close(srvDone)\n\t\terr := s.Shutdown(context.Background())\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\ttimeout := time.After(2 * time.Second)\n\tselect {\n\tcase <-timeout:\n\t\tt.Fatal(\"timeout\")\n\t\treturn\n\tcase <-srvDone:\n\t\t// TODO: add timeout for sessDone\n\t\t<-sessDone\n\t\treturn\n\t}\n}\n\nfunc TestServerClose(t *testing.T) {\n\tl := newLocalListener()\n\ts := &Server{\n\t\tHandler: func(s Session) {\n\t\t\ttime.Sleep(5 * time.Second)\n\t\t},\n\t}\n\tgo func() {\n\t\terr := s.Serve(l)\n\t\tif err != nil && err != ErrServerClosed {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tclientDoneChan := make(chan struct{})\n\tcloseDoneChan := make(chan struct{})\n\n\tsess, _, cleanup := newClientSession(t, l.Addr().String(), nil)\n\tgo func() {\n\t\tdefer cleanup()\n\t\tdefer close(clientDoneChan)\n\t\t<-closeDoneChan\n\t\tif err := sess.Run(\"\"); err != nil && err != io.EOF {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tgo func() {\n\t\terr := s.Close()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tclose(closeDoneChan)\n\t}()\n\n\ttimeout := time.After(100 * time.Millisecond)\n\tselect {\n\tcase <-timeout:\n\t\tt.Error(\"timeout\")\n\t\treturn\n\tcase <-s.getDoneChan():\n\t\t<-clientDoneChan\n\t\treturn\n\t}\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 9.2958984375,
          "content": "package ssh\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n\n\t\"github.com/anmitsu/go-shlex\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\n// Session provides access to information about an SSH session and methods\n// to read and write to the SSH channel with an embedded Channel interface from\n// crypto/ssh.\n//\n// When Command() returns an empty slice, the user requested a shell. Otherwise\n// the user is performing an exec with those command arguments.\n//\n// TODO: Signals\ntype Session interface {\n\tgossh.Channel\n\n\t// User returns the username used when establishing the SSH connection.\n\tUser() string\n\n\t// RemoteAddr returns the net.Addr of the client side of the connection.\n\tRemoteAddr() net.Addr\n\n\t// LocalAddr returns the net.Addr of the server side of the connection.\n\tLocalAddr() net.Addr\n\n\t// Environ returns a copy of strings representing the environment set by the\n\t// user for this session, in the form \"key=value\".\n\tEnviron() []string\n\n\t// Exit sends an exit status and then closes the session.\n\tExit(code int) error\n\n\t// Command returns a shell parsed slice of arguments that were provided by the\n\t// user. Shell parsing splits the command string according to POSIX shell rules,\n\t// which considers quoting not just whitespace.\n\tCommand() []string\n\n\t// RawCommand returns the exact command that was provided by the user.\n\tRawCommand() string\n\n\t// Subsystem returns the subsystem requested by the user.\n\tSubsystem() string\n\n\t// PublicKey returns the PublicKey used to authenticate. If a public key was not\n\t// used it will return nil.\n\tPublicKey() PublicKey\n\n\t// Context returns the connection's context. The returned context is always\n\t// non-nil and holds the same data as the Context passed into auth\n\t// handlers and callbacks.\n\t//\n\t// The context is canceled when the client's connection closes or I/O\n\t// operation fails.\n\tContext() Context\n\n\t// Permissions returns a copy of the Permissions object that was available for\n\t// setup in the auth handlers via the Context.\n\tPermissions() Permissions\n\n\t// Pty returns PTY information, a channel of window size changes, and a boolean\n\t// of whether or not a PTY was accepted for this session.\n\tPty() (Pty, <-chan Window, bool)\n\n\t// Signals registers a channel to receive signals sent from the client. The\n\t// channel must handle signal sends or it will block the SSH request loop.\n\t// Registering nil will unregister the channel from signal sends. During the\n\t// time no channel is registered signals are buffered up to a reasonable amount.\n\t// If there are buffered signals when a channel is registered, they will be\n\t// sent in order on the channel immediately after registering.\n\tSignals(c chan<- Signal)\n\n\t// Break regisers a channel to receive notifications of break requests sent\n\t// from the client. The channel must handle break requests, or it will block\n\t// the request handling loop. Registering nil will unregister the channel.\n\t// During the time that no channel is registered, breaks are ignored.\n\tBreak(c chan<- bool)\n}\n\n// maxSigBufSize is how many signals will be buffered\n// when there is no signal channel specified\nconst maxSigBufSize = 128\n\nfunc DefaultSessionHandler(srv *Server, conn *gossh.ServerConn, newChan gossh.NewChannel, ctx Context) {\n\tch, reqs, err := newChan.Accept()\n\tif err != nil {\n\t\t// TODO: trigger event callback\n\t\treturn\n\t}\n\tsess := &session{\n\t\tChannel:           ch,\n\t\tconn:              conn,\n\t\thandler:           srv.Handler,\n\t\tptyCb:             srv.PtyCallback,\n\t\tsessReqCb:         srv.SessionRequestCallback,\n\t\tsubsystemHandlers: srv.SubsystemHandlers,\n\t\tctx:               ctx,\n\t}\n\tsess.handleRequests(reqs)\n}\n\ntype session struct {\n\tsync.Mutex\n\tgossh.Channel\n\tconn              *gossh.ServerConn\n\thandler           Handler\n\tsubsystemHandlers map[string]SubsystemHandler\n\thandled           bool\n\texited            bool\n\tpty               *Pty\n\twinch             chan Window\n\tenv               []string\n\tptyCb             PtyCallback\n\tsessReqCb         SessionRequestCallback\n\trawCmd            string\n\tsubsystem         string\n\tctx               Context\n\tsigCh             chan<- Signal\n\tsigBuf            []Signal\n\tbreakCh           chan<- bool\n}\n\nfunc (sess *session) Write(p []byte) (n int, err error) {\n\tif sess.pty != nil {\n\t\tm := len(p)\n\t\t// normalize \\n to \\r\\n when pty is accepted.\n\t\t// this is a hardcoded shortcut since we don't support terminal modes.\n\t\tp = bytes.Replace(p, []byte{'\\n'}, []byte{'\\r', '\\n'}, -1)\n\t\tp = bytes.Replace(p, []byte{'\\r', '\\r', '\\n'}, []byte{'\\r', '\\n'}, -1)\n\t\tn, err = sess.Channel.Write(p)\n\t\tif n > m {\n\t\t\tn = m\n\t\t}\n\t\treturn\n\t}\n\treturn sess.Channel.Write(p)\n}\n\nfunc (sess *session) PublicKey() PublicKey {\n\tsessionkey := sess.ctx.Value(ContextKeyPublicKey)\n\tif sessionkey == nil {\n\t\treturn nil\n\t}\n\treturn sessionkey.(PublicKey)\n}\n\nfunc (sess *session) Permissions() Permissions {\n\t// use context permissions because its properly\n\t// wrapped and easier to dereference\n\tperms := sess.ctx.Value(ContextKeyPermissions).(*Permissions)\n\treturn *perms\n}\n\nfunc (sess *session) Context() Context {\n\treturn sess.ctx\n}\n\nfunc (sess *session) Exit(code int) error {\n\tsess.Lock()\n\tdefer sess.Unlock()\n\tif sess.exited {\n\t\treturn errors.New(\"Session.Exit called multiple times\")\n\t}\n\tsess.exited = true\n\n\tstatus := struct{ Status uint32 }{uint32(code)}\n\t_, err := sess.SendRequest(\"exit-status\", false, gossh.Marshal(&status))\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn sess.Close()\n}\n\nfunc (sess *session) User() string {\n\treturn sess.conn.User()\n}\n\nfunc (sess *session) RemoteAddr() net.Addr {\n\treturn sess.conn.RemoteAddr()\n}\n\nfunc (sess *session) LocalAddr() net.Addr {\n\treturn sess.conn.LocalAddr()\n}\n\nfunc (sess *session) Environ() []string {\n\treturn append([]string(nil), sess.env...)\n}\n\nfunc (sess *session) RawCommand() string {\n\treturn sess.rawCmd\n}\n\nfunc (sess *session) Command() []string {\n\tcmd, _ := shlex.Split(sess.rawCmd, true)\n\treturn append([]string(nil), cmd...)\n}\n\nfunc (sess *session) Subsystem() string {\n\treturn sess.subsystem\n}\n\nfunc (sess *session) Pty() (Pty, <-chan Window, bool) {\n\tif sess.pty != nil {\n\t\treturn *sess.pty, sess.winch, true\n\t}\n\treturn Pty{}, sess.winch, false\n}\n\nfunc (sess *session) Signals(c chan<- Signal) {\n\tsess.Lock()\n\tdefer sess.Unlock()\n\tsess.sigCh = c\n\tif len(sess.sigBuf) > 0 {\n\t\tgo func() {\n\t\t\tfor _, sig := range sess.sigBuf {\n\t\t\t\tsess.sigCh <- sig\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc (sess *session) Break(c chan<- bool) {\n\tsess.Lock()\n\tdefer sess.Unlock()\n\tsess.breakCh = c\n}\n\nfunc (sess *session) handleRequests(reqs <-chan *gossh.Request) {\n\tfor req := range reqs {\n\t\tswitch req.Type {\n\t\tcase \"shell\", \"exec\":\n\t\t\tif sess.handled {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar payload = struct{ Value string }{}\n\t\t\tgossh.Unmarshal(req.Payload, &payload)\n\t\t\tsess.rawCmd = payload.Value\n\n\t\t\t// If there's a session policy callback, we need to confirm before\n\t\t\t// accepting the session.\n\t\t\tif sess.sessReqCb != nil && !sess.sessReqCb(sess, req.Type) {\n\t\t\t\tsess.rawCmd = \"\"\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsess.handled = true\n\t\t\treq.Reply(true, nil)\n\n\t\t\tgo func() {\n\t\t\t\tsess.handler(sess)\n\t\t\t\tsess.Exit(0)\n\t\t\t}()\n\t\tcase \"subsystem\":\n\t\t\tif sess.handled {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar payload = struct{ Value string }{}\n\t\t\tgossh.Unmarshal(req.Payload, &payload)\n\t\t\tsess.subsystem = payload.Value\n\n\t\t\t// If there's a session policy callback, we need to confirm before\n\t\t\t// accepting the session.\n\t\t\tif sess.sessReqCb != nil && !sess.sessReqCb(sess, req.Type) {\n\t\t\t\tsess.rawCmd = \"\"\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\thandler := sess.subsystemHandlers[payload.Value]\n\t\t\tif handler == nil {\n\t\t\t\thandler = sess.subsystemHandlers[\"default\"]\n\t\t\t}\n\t\t\tif handler == nil {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tsess.handled = true\n\t\t\treq.Reply(true, nil)\n\n\t\t\tgo func() {\n\t\t\t\thandler(sess)\n\t\t\t\tsess.Exit(0)\n\t\t\t}()\n\t\tcase \"env\":\n\t\t\tif sess.handled {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar kv struct{ Key, Value string }\n\t\t\tgossh.Unmarshal(req.Payload, &kv)\n\t\t\tsess.env = append(sess.env, fmt.Sprintf(\"%s=%s\", kv.Key, kv.Value))\n\t\t\treq.Reply(true, nil)\n\t\tcase \"signal\":\n\t\t\tvar payload struct{ Signal string }\n\t\t\tgossh.Unmarshal(req.Payload, &payload)\n\t\t\tsess.Lock()\n\t\t\tif sess.sigCh != nil {\n\t\t\t\tsess.sigCh <- Signal(payload.Signal)\n\t\t\t} else {\n\t\t\t\tif len(sess.sigBuf) < maxSigBufSize {\n\t\t\t\t\tsess.sigBuf = append(sess.sigBuf, Signal(payload.Signal))\n\t\t\t\t}\n\t\t\t}\n\t\t\tsess.Unlock()\n\t\tcase \"pty-req\":\n\t\t\tif sess.handled || sess.pty != nil {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tptyReq, ok := parsePtyRequest(req.Payload)\n\t\t\tif !ok {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif sess.ptyCb != nil {\n\t\t\t\tok := sess.ptyCb(sess.ctx, ptyReq)\n\t\t\t\tif !ok {\n\t\t\t\t\treq.Reply(false, nil)\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tsess.pty = &ptyReq\n\t\t\tsess.winch = make(chan Window, 1)\n\t\t\tsess.winch <- ptyReq.Window\n\t\t\tdefer func() {\n\t\t\t\t// when reqs is closed\n\t\t\t\tclose(sess.winch)\n\t\t\t}()\n\t\t\treq.Reply(ok, nil)\n\t\tcase \"window-change\":\n\t\t\tif sess.pty == nil {\n\t\t\t\treq.Reply(false, nil)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\twin, ok := parseWinchRequest(req.Payload)\n\t\t\tif ok {\n\t\t\t\tsess.pty.Window = win\n\t\t\t\tsess.winch <- win\n\t\t\t}\n\t\t\treq.Reply(ok, nil)\n\t\tcase agentRequestType:\n\t\t\t// TODO: option/callback to allow agent forwarding\n\t\t\tSetAgentRequested(sess.ctx)\n\t\t\treq.Reply(true, nil)\n\t\tcase \"break\":\n\t\t\tok := false\n\t\t\tsess.Lock()\n\t\t\tif sess.breakCh != nil {\n\t\t\t\tsess.breakCh <- true\n\t\t\t\tok = true\n\t\t\t}\n\t\t\treq.Reply(ok, nil)\n\t\t\tsess.Unlock()\n\t\tdefault:\n\t\t\t// TODO: debug log\n\t\t\treq.Reply(false, nil)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "session_test.go",
          "type": "blob",
          "size": 10.046875,
          "content": "package ssh\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"testing\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nfunc (srv *Server) serveOnce(l net.Listener) error {\n\tsrv.ensureHandlers()\n\tif err := srv.ensureHostSigner(); err != nil {\n\t\treturn err\n\t}\n\tconn, e := l.Accept()\n\tif e != nil {\n\t\treturn e\n\t}\n\tsrv.ChannelHandlers = map[string]ChannelHandler{\n\t\t\"session\":      DefaultSessionHandler,\n\t\t\"direct-tcpip\": DirectTCPIPHandler,\n\t}\n\tsrv.HandleConn(conn)\n\treturn nil\n}\n\nfunc newLocalListener() net.Listener {\n\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\tif err != nil {\n\t\tif l, err = net.Listen(\"tcp6\", \"[::1]:0\"); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"failed to listen on a port: %v\", err))\n\t\t}\n\t}\n\treturn l\n}\n\nfunc newClientSession(t *testing.T, addr string, config *gossh.ClientConfig) (*gossh.Session, *gossh.Client, func()) {\n\tif config == nil {\n\t\tconfig = &gossh.ClientConfig{\n\t\t\tUser: \"testuser\",\n\t\t\tAuth: []gossh.AuthMethod{\n\t\t\t\tgossh.Password(\"testpass\"),\n\t\t\t},\n\t\t}\n\t}\n\tif config.HostKeyCallback == nil {\n\t\tconfig.HostKeyCallback = gossh.InsecureIgnoreHostKey()\n\t}\n\tclient, err := gossh.Dial(\"tcp\", addr, config)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsession, err := client.NewSession()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn session, client, func() {\n\t\tsession.Close()\n\t\tclient.Close()\n\t}\n}\n\nfunc newTestSession(t *testing.T, srv *Server, cfg *gossh.ClientConfig) (*gossh.Session, *gossh.Client, func()) {\n\tl := newLocalListener()\n\tgo srv.serveOnce(l)\n\treturn newClientSession(t, l.Addr().String(), cfg)\n}\n\nfunc TestStdout(t *testing.T) {\n\tt.Parallel()\n\ttestBytes := []byte(\"Hello world\\n\")\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\ts.Write(testBytes)\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\tvar stdout bytes.Buffer\n\tsession.Stdout = &stdout\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(stdout.Bytes(), testBytes) {\n\t\tt.Fatalf(\"stdout = %#v; want %#v\", stdout.Bytes(), testBytes)\n\t}\n}\n\nfunc TestStderr(t *testing.T) {\n\tt.Parallel()\n\ttestBytes := []byte(\"Hello world\\n\")\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\ts.Stderr().Write(testBytes)\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\tvar stderr bytes.Buffer\n\tsession.Stderr = &stderr\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(stderr.Bytes(), testBytes) {\n\t\tt.Fatalf(\"stderr = %#v; want %#v\", stderr.Bytes(), testBytes)\n\t}\n}\n\nfunc TestStdin(t *testing.T) {\n\tt.Parallel()\n\ttestBytes := []byte(\"Hello world\\n\")\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\tio.Copy(s, s) // stdin back into stdout\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\tvar stdout bytes.Buffer\n\tsession.Stdout = &stdout\n\tsession.Stdin = bytes.NewBuffer(testBytes)\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(stdout.Bytes(), testBytes) {\n\t\tt.Fatalf(\"stdout = %#v; want %#v given stdin = %#v\", stdout.Bytes(), testBytes, testBytes)\n\t}\n}\n\nfunc TestUser(t *testing.T) {\n\tt.Parallel()\n\ttestUser := []byte(\"progrium\")\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\tio.WriteString(s, s.User())\n\t\t},\n\t}, &gossh.ClientConfig{\n\t\tUser: string(testUser),\n\t})\n\tdefer cleanup()\n\tvar stdout bytes.Buffer\n\tsession.Stdout = &stdout\n\tif err := session.Run(\"\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(stdout.Bytes(), testUser) {\n\t\tt.Fatalf(\"stdout = %#v; want %#v given user = %#v\", stdout.Bytes(), testUser, string(testUser))\n\t}\n}\n\nfunc TestDefaultExitStatusZero(t *testing.T) {\n\tt.Parallel()\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\t// noop\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\terr := session.Run(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n}\n\nfunc TestExplicitExitStatusZero(t *testing.T) {\n\tt.Parallel()\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\ts.Exit(0)\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\terr := session.Run(\"\")\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n}\n\nfunc TestExitStatusNonZero(t *testing.T) {\n\tt.Parallel()\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\ts.Exit(1)\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\terr := session.Run(\"\")\n\te, ok := err.(*gossh.ExitError)\n\tif !ok {\n\t\tt.Fatalf(\"expected ExitError but got %T\", err)\n\t}\n\tif e.ExitStatus() != 1 {\n\t\tt.Fatalf(\"exit-status = %#v; want %#v\", e.ExitStatus(), 1)\n\t}\n}\n\nfunc TestPty(t *testing.T) {\n\tt.Parallel()\n\tterm := \"xterm\"\n\twinWidth := 40\n\twinHeight := 80\n\tdone := make(chan bool)\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\tptyReq, _, isPty := s.Pty()\n\t\t\tif !isPty {\n\t\t\t\tt.Fatalf(\"expected pty but none requested\")\n\t\t\t}\n\t\t\tif ptyReq.Term != term {\n\t\t\t\tt.Fatalf(\"expected term %#v but got %#v\", term, ptyReq.Term)\n\t\t\t}\n\t\t\tif ptyReq.Window.Width != winWidth {\n\t\t\t\tt.Fatalf(\"expected window width %#v but got %#v\", winWidth, ptyReq.Window.Width)\n\t\t\t}\n\t\t\tif ptyReq.Window.Height != winHeight {\n\t\t\t\tt.Fatalf(\"expected window height %#v but got %#v\", winHeight, ptyReq.Window.Height)\n\t\t\t}\n\t\t\tclose(done)\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\tif err := session.RequestPty(term, winHeight, winWidth, gossh.TerminalModes{}); err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\t<-done\n}\n\nfunc TestPtyResize(t *testing.T) {\n\tt.Parallel()\n\twinch0 := Window{40, 80}\n\twinch1 := Window{80, 160}\n\twinch2 := Window{20, 40}\n\twinches := make(chan Window)\n\tdone := make(chan bool)\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\tptyReq, winCh, isPty := s.Pty()\n\t\t\tif !isPty {\n\t\t\t\tt.Fatalf(\"expected pty but none requested\")\n\t\t\t}\n\t\t\tif ptyReq.Window != winch0 {\n\t\t\t\tt.Fatalf(\"expected window %#v but got %#v\", winch0, ptyReq.Window)\n\t\t\t}\n\t\t\tfor win := range winCh {\n\t\t\t\twinches <- win\n\t\t\t}\n\t\t\tclose(done)\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\t// winch0\n\tif err := session.RequestPty(\"xterm\", winch0.Height, winch0.Width, gossh.TerminalModes{}); err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\tif err := session.Shell(); err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\tgotWinch := <-winches\n\tif gotWinch != winch0 {\n\t\tt.Fatalf(\"expected window %#v but got %#v\", winch0, gotWinch)\n\t}\n\t// winch1\n\twinchMsg := struct{ w, h uint32 }{uint32(winch1.Width), uint32(winch1.Height)}\n\tok, err := session.SendRequest(\"window-change\", true, gossh.Marshal(&winchMsg))\n\tif err == nil && !ok {\n\t\tt.Fatalf(\"unexpected error or bad reply on send request\")\n\t}\n\tgotWinch = <-winches\n\tif gotWinch != winch1 {\n\t\tt.Fatalf(\"expected window %#v but got %#v\", winch1, gotWinch)\n\t}\n\t// winch2\n\twinchMsg = struct{ w, h uint32 }{uint32(winch2.Width), uint32(winch2.Height)}\n\tok, err = session.SendRequest(\"window-change\", true, gossh.Marshal(&winchMsg))\n\tif err == nil && !ok {\n\t\tt.Fatalf(\"unexpected error or bad reply on send request\")\n\t}\n\tgotWinch = <-winches\n\tif gotWinch != winch2 {\n\t\tt.Fatalf(\"expected window %#v but got %#v\", winch2, gotWinch)\n\t}\n\tsession.Close()\n\t<-done\n}\n\nfunc TestSignals(t *testing.T) {\n\tt.Parallel()\n\n\t// errChan lets us get errors back from the session\n\terrChan := make(chan error, 5)\n\n\t// doneChan lets us specify that we should exit.\n\tdoneChan := make(chan interface{})\n\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\t// We need to use a buffered channel here, otherwise it's possible for the\n\t\t\t// second call to Signal to get discarded.\n\t\t\tsignals := make(chan Signal, 2)\n\t\t\ts.Signals(signals)\n\n\t\t\tselect {\n\t\t\tcase sig := <-signals:\n\t\t\t\tif sig != SIGINT {\n\t\t\t\t\terrChan <- fmt.Errorf(\"expected signal %v but got %v\", SIGINT, sig)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-doneChan:\n\t\t\t\terrChan <- fmt.Errorf(\"Unexpected done\")\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase sig := <-signals:\n\t\t\t\tif sig != SIGKILL {\n\t\t\t\t\terrChan <- fmt.Errorf(\"expected signal %v but got %v\", SIGKILL, sig)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\tcase <-doneChan:\n\t\t\t\terrChan <- fmt.Errorf(\"Unexpected done\")\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\n\tgo func() {\n\t\tsession.Signal(gossh.SIGINT)\n\t\tsession.Signal(gossh.SIGKILL)\n\t}()\n\n\tgo func() {\n\t\terrChan <- session.Run(\"\")\n\t}()\n\n\terr := <-errChan\n\tclose(doneChan)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n}\n\nfunc TestBreakWithChanRegistered(t *testing.T) {\n\tt.Parallel()\n\n\t// errChan lets us get errors back from the session\n\terrChan := make(chan error, 5)\n\n\t// doneChan lets us specify that we should exit.\n\tdoneChan := make(chan interface{})\n\n\tbreakChan := make(chan bool)\n\n\treadyToReceiveBreak := make(chan bool)\n\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\ts.Break(breakChan) // register a break channel with the session\n\t\t\treadyToReceiveBreak <- true\n\n\t\t\tselect {\n\t\t\tcase <-breakChan:\n\t\t\t\tio.WriteString(s, \"break\")\n\t\t\tcase <-doneChan:\n\t\t\t\terrChan <- fmt.Errorf(\"Unexpected done\")\n\t\t\t\treturn\n\t\t\t}\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\tvar stdout bytes.Buffer\n\tsession.Stdout = &stdout\n\tgo func() {\n\t\terrChan <- session.Run(\"\")\n\t}()\n\n\t<-readyToReceiveBreak\n\tok, err := session.SendRequest(\"break\", true, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\tif ok != true {\n\t\tt.Fatalf(\"expected true but got %v\", ok)\n\t}\n\n\terr = <-errChan\n\tclose(doneChan)\n\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\tif !bytes.Equal(stdout.Bytes(), []byte(\"break\")) {\n\t\tt.Fatalf(\"stdout = %#v, expected 'break'\", stdout.Bytes())\n\t}\n}\n\nfunc TestBreakWithoutChanRegistered(t *testing.T) {\n\tt.Parallel()\n\n\t// errChan lets us get errors back from the session\n\terrChan := make(chan error, 5)\n\n\t// doneChan lets us specify that we should exit.\n\tdoneChan := make(chan interface{})\n\n\twaitUntilAfterBreakSent := make(chan bool)\n\n\tsession, _, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {\n\t\t\t<-waitUntilAfterBreakSent\n\t\t},\n\t}, nil)\n\tdefer cleanup()\n\tvar stdout bytes.Buffer\n\tsession.Stdout = &stdout\n\tgo func() {\n\t\terrChan <- session.Run(\"\")\n\t}()\n\n\tok, err := session.SendRequest(\"break\", true, nil)\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n\tif ok != false {\n\t\tt.Fatalf(\"expected false but got %v\", ok)\n\t}\n\twaitUntilAfterBreakSent <- true\n\n\terr = <-errChan\n\tclose(doneChan)\n\tif err != nil {\n\t\tt.Fatalf(\"expected nil but got %v\", err)\n\t}\n}\n"
        },
        {
          "name": "ssh.go",
          "type": "blob",
          "size": 4.0712890625,
          "content": "package ssh\n\nimport (\n\t\"crypto/subtle\"\n\t\"net\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\ntype Signal string\n\n// POSIX signals as listed in RFC 4254 Section 6.10.\nconst (\n\tSIGABRT Signal = \"ABRT\"\n\tSIGALRM Signal = \"ALRM\"\n\tSIGFPE  Signal = \"FPE\"\n\tSIGHUP  Signal = \"HUP\"\n\tSIGILL  Signal = \"ILL\"\n\tSIGINT  Signal = \"INT\"\n\tSIGKILL Signal = \"KILL\"\n\tSIGPIPE Signal = \"PIPE\"\n\tSIGQUIT Signal = \"QUIT\"\n\tSIGSEGV Signal = \"SEGV\"\n\tSIGTERM Signal = \"TERM\"\n\tSIGUSR1 Signal = \"USR1\"\n\tSIGUSR2 Signal = \"USR2\"\n)\n\n// DefaultHandler is the default Handler used by Serve.\nvar DefaultHandler Handler\n\n// Option is a functional option handler for Server.\ntype Option func(*Server) error\n\n// Handler is a callback for handling established SSH sessions.\ntype Handler func(Session)\n\n// BannerHandler is a callback for displaying the server banner.\ntype BannerHandler func(ctx Context) string\n\n// PublicKeyHandler is a callback for performing public key authentication.\ntype PublicKeyHandler func(ctx Context, key PublicKey) bool\n\n// PasswordHandler is a callback for performing password authentication.\ntype PasswordHandler func(ctx Context, password string) bool\n\n// KeyboardInteractiveHandler is a callback for performing keyboard-interactive authentication.\ntype KeyboardInteractiveHandler func(ctx Context, challenger gossh.KeyboardInteractiveChallenge) bool\n\n// PtyCallback is a hook for allowing PTY sessions.\ntype PtyCallback func(ctx Context, pty Pty) bool\n\n// SessionRequestCallback is a callback for allowing or denying SSH sessions.\ntype SessionRequestCallback func(sess Session, requestType string) bool\n\n// ConnCallback is a hook for new connections before handling.\n// It allows wrapping for timeouts and limiting by returning\n// the net.Conn that will be used as the underlying connection.\ntype ConnCallback func(ctx Context, conn net.Conn) net.Conn\n\n// LocalPortForwardingCallback is a hook for allowing port forwarding\ntype LocalPortForwardingCallback func(ctx Context, destinationHost string, destinationPort uint32) bool\n\n// ReversePortForwardingCallback is a hook for allowing reverse port forwarding\ntype ReversePortForwardingCallback func(ctx Context, bindHost string, bindPort uint32) bool\n\n// ServerConfigCallback is a hook for creating custom default server configs\ntype ServerConfigCallback func(ctx Context) *gossh.ServerConfig\n\n// ConnectionFailedCallback is a hook for reporting failed connections\n// Please note: the net.Conn is likely to be closed at this point\ntype ConnectionFailedCallback func(conn net.Conn, err error)\n\n// Window represents the size of a PTY window.\ntype Window struct {\n\tWidth  int\n\tHeight int\n}\n\n// Pty represents a PTY request and configuration.\ntype Pty struct {\n\tTerm   string\n\tWindow Window\n\t// HELP WANTED: terminal modes!\n}\n\n// Serve accepts incoming SSH connections on the listener l, creating a new\n// connection goroutine for each. The connection goroutines read requests and\n// then calls handler to handle sessions. Handler is typically nil, in which\n// case the DefaultHandler is used.\nfunc Serve(l net.Listener, handler Handler, options ...Option) error {\n\tsrv := &Server{Handler: handler}\n\tfor _, option := range options {\n\t\tif err := srv.SetOption(option); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn srv.Serve(l)\n}\n\n// ListenAndServe listens on the TCP network address addr and then calls Serve\n// with handler to handle sessions on incoming connections. Handler is typically\n// nil, in which case the DefaultHandler is used.\nfunc ListenAndServe(addr string, handler Handler, options ...Option) error {\n\tsrv := &Server{Addr: addr, Handler: handler}\n\tfor _, option := range options {\n\t\tif err := srv.SetOption(option); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn srv.ListenAndServe()\n}\n\n// Handle registers the handler as the DefaultHandler.\nfunc Handle(handler Handler) {\n\tDefaultHandler = handler\n}\n\n// KeysEqual is constant time compare of the keys to avoid timing attacks.\nfunc KeysEqual(ak, bk PublicKey) bool {\n\t// avoid panic if one of the keys is nil, return false instead\n\tif ak == nil || bk == nil {\n\t\treturn false\n\t}\n\n\ta := ak.Marshal()\n\tb := bk.Marshal()\n\treturn (len(a) == len(b) && subtle.ConstantTimeCompare(a, b) == 1)\n}\n"
        },
        {
          "name": "ssh_test.go",
          "type": "blob",
          "size": 0.2373046875,
          "content": "package ssh\n\nimport (\n\t\"testing\"\n)\n\nfunc TestKeysEqual(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"The code did panic\")\n\t\t}\n\t}()\n\n\tif KeysEqual(nil, nil) {\n\t\tt.Error(\"two nil keys should not return true\")\n\t}\n}\n"
        },
        {
          "name": "tcpip.go",
          "type": "blob",
          "size": 4.521484375,
          "content": "package ssh\n\nimport (\n\t\"io\"\n\t\"log\"\n\t\"net\"\n\t\"strconv\"\n\t\"sync\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nconst (\n\tforwardedTCPChannelType = \"forwarded-tcpip\"\n)\n\n// direct-tcpip data struct as specified in RFC4254, Section 7.2\ntype localForwardChannelData struct {\n\tDestAddr string\n\tDestPort uint32\n\n\tOriginAddr string\n\tOriginPort uint32\n}\n\n// DirectTCPIPHandler can be enabled by adding it to the server's\n// ChannelHandlers under direct-tcpip.\nfunc DirectTCPIPHandler(srv *Server, conn *gossh.ServerConn, newChan gossh.NewChannel, ctx Context) {\n\td := localForwardChannelData{}\n\tif err := gossh.Unmarshal(newChan.ExtraData(), &d); err != nil {\n\t\tnewChan.Reject(gossh.ConnectionFailed, \"error parsing forward data: \"+err.Error())\n\t\treturn\n\t}\n\n\tif srv.LocalPortForwardingCallback == nil || !srv.LocalPortForwardingCallback(ctx, d.DestAddr, d.DestPort) {\n\t\tnewChan.Reject(gossh.Prohibited, \"port forwarding is disabled\")\n\t\treturn\n\t}\n\n\tdest := net.JoinHostPort(d.DestAddr, strconv.FormatInt(int64(d.DestPort), 10))\n\n\tvar dialer net.Dialer\n\tdconn, err := dialer.DialContext(ctx, \"tcp\", dest)\n\tif err != nil {\n\t\tnewChan.Reject(gossh.ConnectionFailed, err.Error())\n\t\treturn\n\t}\n\n\tch, reqs, err := newChan.Accept()\n\tif err != nil {\n\t\tdconn.Close()\n\t\treturn\n\t}\n\tgo gossh.DiscardRequests(reqs)\n\n\tgo func() {\n\t\tdefer ch.Close()\n\t\tdefer dconn.Close()\n\t\tio.Copy(ch, dconn)\n\t}()\n\tgo func() {\n\t\tdefer ch.Close()\n\t\tdefer dconn.Close()\n\t\tio.Copy(dconn, ch)\n\t}()\n}\n\ntype remoteForwardRequest struct {\n\tBindAddr string\n\tBindPort uint32\n}\n\ntype remoteForwardSuccess struct {\n\tBindPort uint32\n}\n\ntype remoteForwardCancelRequest struct {\n\tBindAddr string\n\tBindPort uint32\n}\n\ntype remoteForwardChannelData struct {\n\tDestAddr   string\n\tDestPort   uint32\n\tOriginAddr string\n\tOriginPort uint32\n}\n\n// ForwardedTCPHandler can be enabled by creating a ForwardedTCPHandler and\n// adding the HandleSSHRequest callback to the server's RequestHandlers under\n// tcpip-forward and cancel-tcpip-forward.\ntype ForwardedTCPHandler struct {\n\tforwards map[string]net.Listener\n\tsync.Mutex\n}\n\nfunc (h *ForwardedTCPHandler) HandleSSHRequest(ctx Context, srv *Server, req *gossh.Request) (bool, []byte) {\n\th.Lock()\n\tif h.forwards == nil {\n\t\th.forwards = make(map[string]net.Listener)\n\t}\n\th.Unlock()\n\tconn := ctx.Value(ContextKeyConn).(*gossh.ServerConn)\n\tswitch req.Type {\n\tcase \"tcpip-forward\":\n\t\tvar reqPayload remoteForwardRequest\n\t\tif err := gossh.Unmarshal(req.Payload, &reqPayload); err != nil {\n\t\t\t// TODO: log parse failure\n\t\t\treturn false, []byte{}\n\t\t}\n\t\tif srv.ReversePortForwardingCallback == nil || !srv.ReversePortForwardingCallback(ctx, reqPayload.BindAddr, reqPayload.BindPort) {\n\t\t\treturn false, []byte(\"port forwarding is disabled\")\n\t\t}\n\t\taddr := net.JoinHostPort(reqPayload.BindAddr, strconv.Itoa(int(reqPayload.BindPort)))\n\t\tln, err := net.Listen(\"tcp\", addr)\n\t\tif err != nil {\n\t\t\t// TODO: log listen failure\n\t\t\treturn false, []byte{}\n\t\t}\n\t\t_, destPortStr, _ := net.SplitHostPort(ln.Addr().String())\n\t\tdestPort, _ := strconv.Atoi(destPortStr)\n\t\th.Lock()\n\t\th.forwards[addr] = ln\n\t\th.Unlock()\n\t\tgo func() {\n\t\t\t<-ctx.Done()\n\t\t\th.Lock()\n\t\t\tln, ok := h.forwards[addr]\n\t\t\th.Unlock()\n\t\t\tif ok {\n\t\t\t\tln.Close()\n\t\t\t}\n\t\t}()\n\t\tgo func() {\n\t\t\tfor {\n\t\t\t\tc, err := ln.Accept()\n\t\t\t\tif err != nil {\n\t\t\t\t\t// TODO: log accept failure\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\toriginAddr, orignPortStr, _ := net.SplitHostPort(c.RemoteAddr().String())\n\t\t\t\toriginPort, _ := strconv.Atoi(orignPortStr)\n\t\t\t\tpayload := gossh.Marshal(&remoteForwardChannelData{\n\t\t\t\t\tDestAddr:   reqPayload.BindAddr,\n\t\t\t\t\tDestPort:   uint32(destPort),\n\t\t\t\t\tOriginAddr: originAddr,\n\t\t\t\t\tOriginPort: uint32(originPort),\n\t\t\t\t})\n\t\t\t\tgo func() {\n\t\t\t\t\tch, reqs, err := conn.OpenChannel(forwardedTCPChannelType, payload)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\t// TODO: log failure to open channel\n\t\t\t\t\t\tlog.Println(err)\n\t\t\t\t\t\tc.Close()\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tgo gossh.DiscardRequests(reqs)\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tdefer ch.Close()\n\t\t\t\t\t\tdefer c.Close()\n\t\t\t\t\t\tio.Copy(ch, c)\n\t\t\t\t\t}()\n\t\t\t\t\tgo func() {\n\t\t\t\t\t\tdefer ch.Close()\n\t\t\t\t\t\tdefer c.Close()\n\t\t\t\t\t\tio.Copy(c, ch)\n\t\t\t\t\t}()\n\t\t\t\t}()\n\t\t\t}\n\t\t\th.Lock()\n\t\t\tdelete(h.forwards, addr)\n\t\t\th.Unlock()\n\t\t}()\n\t\treturn true, gossh.Marshal(&remoteForwardSuccess{uint32(destPort)})\n\n\tcase \"cancel-tcpip-forward\":\n\t\tvar reqPayload remoteForwardCancelRequest\n\t\tif err := gossh.Unmarshal(req.Payload, &reqPayload); err != nil {\n\t\t\t// TODO: log parse failure\n\t\t\treturn false, []byte{}\n\t\t}\n\t\taddr := net.JoinHostPort(reqPayload.BindAddr, strconv.Itoa(int(reqPayload.BindPort)))\n\t\th.Lock()\n\t\tln, ok := h.forwards[addr]\n\t\th.Unlock()\n\t\tif ok {\n\t\t\tln.Close()\n\t\t}\n\t\treturn true, nil\n\tdefault:\n\t\treturn false, nil\n\t}\n}\n"
        },
        {
          "name": "tcpip_test.go",
          "type": "blob",
          "size": 1.8408203125,
          "content": "package ssh\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"net\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nvar sampleServerResponse = []byte(\"Hello world\")\n\nfunc sampleSocketServer() net.Listener {\n\tl := newLocalListener()\n\n\tgo func() {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn\n\t\t}\n\t\tconn.Write(sampleServerResponse)\n\t\tconn.Close()\n\t}()\n\n\treturn l\n}\n\nfunc newTestSessionWithForwarding(t *testing.T, forwardingEnabled bool) (net.Listener, *gossh.Client, func()) {\n\tl := sampleSocketServer()\n\n\t_, client, cleanup := newTestSession(t, &Server{\n\t\tHandler: func(s Session) {},\n\t\tLocalPortForwardingCallback: func(ctx Context, destinationHost string, destinationPort uint32) bool {\n\t\t\taddr := net.JoinHostPort(destinationHost, strconv.FormatInt(int64(destinationPort), 10))\n\t\t\tif addr != l.Addr().String() {\n\t\t\t\tpanic(\"unexpected destinationHost: \" + addr)\n\t\t\t}\n\t\t\treturn forwardingEnabled\n\t\t},\n\t}, nil)\n\n\treturn l, client, func() {\n\t\tcleanup()\n\t\tl.Close()\n\t}\n}\n\nfunc TestLocalPortForwardingWorks(t *testing.T) {\n\tt.Parallel()\n\n\tl, client, cleanup := newTestSessionWithForwarding(t, true)\n\tdefer cleanup()\n\n\tconn, err := client.Dial(\"tcp\", l.Addr().String())\n\tif err != nil {\n\t\tt.Fatalf(\"Error connecting to %v: %v\", l.Addr().String(), err)\n\t}\n\tresult, err := io.ReadAll(conn)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif !bytes.Equal(result, sampleServerResponse) {\n\t\tt.Fatalf(\"result = %#v; want %#v\", result, sampleServerResponse)\n\t}\n}\n\nfunc TestLocalPortForwardingRespectsCallback(t *testing.T) {\n\tt.Parallel()\n\n\tl, client, cleanup := newTestSessionWithForwarding(t, false)\n\tdefer cleanup()\n\n\t_, err := client.Dial(\"tcp\", l.Addr().String())\n\tif err == nil {\n\t\tt.Fatalf(\"Expected error connecting to %v but it succeeded\", l.Addr().String())\n\t}\n\tif !strings.Contains(err.Error(), \"port forwarding is disabled\") {\n\t\tt.Fatalf(\"Expected permission error but got %#v\", err)\n\t}\n}\n"
        },
        {
          "name": "util.go",
          "type": "blob",
          "size": 1.2900390625,
          "content": "package ssh\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"encoding/binary\"\n\n\t\"golang.org/x/crypto/ssh\"\n)\n\nfunc generateSigner() (ssh.Signer, error) {\n\tkey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn ssh.NewSignerFromKey(key)\n}\n\nfunc parsePtyRequest(s []byte) (pty Pty, ok bool) {\n\tterm, s, ok := parseString(s)\n\tif !ok {\n\t\treturn\n\t}\n\twidth32, s, ok := parseUint32(s)\n\tif !ok {\n\t\treturn\n\t}\n\theight32, _, ok := parseUint32(s)\n\tif !ok {\n\t\treturn\n\t}\n\tpty = Pty{\n\t\tTerm: term,\n\t\tWindow: Window{\n\t\t\tWidth:  int(width32),\n\t\t\tHeight: int(height32),\n\t\t},\n\t}\n\treturn\n}\n\nfunc parseWinchRequest(s []byte) (win Window, ok bool) {\n\twidth32, s, ok := parseUint32(s)\n\tif width32 < 1 {\n\t\tok = false\n\t}\n\tif !ok {\n\t\treturn\n\t}\n\theight32, _, ok := parseUint32(s)\n\tif height32 < 1 {\n\t\tok = false\n\t}\n\tif !ok {\n\t\treturn\n\t}\n\twin = Window{\n\t\tWidth:  int(width32),\n\t\tHeight: int(height32),\n\t}\n\treturn\n}\n\nfunc parseString(in []byte) (out string, rest []byte, ok bool) {\n\tif len(in) < 4 {\n\t\treturn\n\t}\n\tlength := binary.BigEndian.Uint32(in)\n\tif uint32(len(in)) < 4+length {\n\t\treturn\n\t}\n\tout = string(in[4 : 4+length])\n\trest = in[4+length:]\n\tok = true\n\treturn\n}\n\nfunc parseUint32(in []byte) (uint32, []byte, bool) {\n\tif len(in) < 4 {\n\t\treturn 0, nil, false\n\t}\n\treturn binary.BigEndian.Uint32(in), in[4:], true\n}\n"
        },
        {
          "name": "wrap.go",
          "type": "blob",
          "size": 1.0625,
          "content": "package ssh\n\nimport gossh \"golang.org/x/crypto/ssh\"\n\n// PublicKey is an abstraction of different types of public keys.\ntype PublicKey interface {\n\tgossh.PublicKey\n}\n\n// The Permissions type holds fine-grained permissions that are specific to a\n// user or a specific authentication method for a user. Permissions, except for\n// \"source-address\", must be enforced in the server application layer, after\n// successful authentication.\ntype Permissions struct {\n\t*gossh.Permissions\n}\n\n// A Signer can create signatures that verify against a public key.\ntype Signer interface {\n\tgossh.Signer\n}\n\n// ParseAuthorizedKey parses a public key from an authorized_keys file used in\n// OpenSSH according to the sshd(8) manual page.\nfunc ParseAuthorizedKey(in []byte) (out PublicKey, comment string, options []string, rest []byte, err error) {\n\treturn gossh.ParseAuthorizedKey(in)\n}\n\n// ParsePublicKey parses an SSH public key formatted for use in\n// the SSH wire protocol according to RFC 4253, section 6.6.\nfunc ParsePublicKey(in []byte) (out PublicKey, err error) {\n\treturn gossh.ParsePublicKey(in)\n}\n"
        }
      ]
    }
  ]
}