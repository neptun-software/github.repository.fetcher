{
  "metadata": {
    "timestamp": 1736566978972,
    "page": 560,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU2MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "gorilla/sessions",
      "stars": 2965,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".editorconfig",
          "type": "blob",
          "size": 0.3173828125,
          "content": "; https://editorconfig.org/\n\nroot = true\n\n[*]\ninsert_final_newline = true\ncharset = utf-8\ntrim_trailing_whitespace = true\nindent_style = space\nindent_size = 2\n\n[{Makefile,go.mod,go.sum,*.go,.gitmodules}]\nindent_style = tab\nindent_size = 4\n\n[*.md]\nindent_size = 4\ntrim_trailing_whitespace = false\n\neclint_indent_style = unset\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.021484375,
          "content": "coverage.coverprofile\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.4462890625,
          "content": "Copyright (c) 2024 The Gorilla Authors. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n\n\t * Redistributions of source code must retain the above copyright\nnotice, this list of conditions and the following disclaimer.\n\t * Redistributions in binary form must reproduce the above\ncopyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the\ndistribution.\n\t * Neither the name of Google Inc. nor the names of its\ncontributors may be used to endorse or promote products derived from\nthis software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.927734375,
          "content": "GO_LINT=$(shell which golangci-lint 2> /dev/null || echo '')\nGO_LINT_URI=github.com/golangci/golangci-lint/cmd/golangci-lint@latest\n\nGO_SEC=$(shell which gosec 2> /dev/null || echo '')\nGO_SEC_URI=github.com/securego/gosec/v2/cmd/gosec@latest\n\nGO_VULNCHECK=$(shell which govulncheck 2> /dev/null || echo '')\nGO_VULNCHECK_URI=golang.org/x/vuln/cmd/govulncheck@latest\n\n.PHONY: golangci-lint\ngolangci-lint:\n\t$(if $(GO_LINT), ,go install $(GO_LINT_URI))\n\t@echo \"##### Running golangci-lint\"\n\tgolangci-lint run -v\n\n.PHONY: gosec\ngosec:\n\t$(if $(GO_SEC), ,go install $(GO_SEC_URI))\n\t@echo \"##### Running gosec\"\n\tgosec ./...\n\n.PHONY: govulncheck\ngovulncheck:\n\t$(if $(GO_VULNCHECK), ,go install $(GO_VULNCHECK_URI))\n\t@echo \"##### Running govulncheck\"\n\tgovulncheck ./...\n\n.PHONY: verify\nverify: golangci-lint gosec govulncheck\n\n.PHONY: test\ntest:\n\t@echo \"##### Running tests\"\n\tgo test -race -cover -coverprofile=coverage.coverprofile -covermode=atomic -v ./...\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 5.470703125,
          "content": "# Gorilla Sessions\n\n> [!IMPORTANT]\n> The latest version of this repository requires go 1.23 because of the new partitioned attribute. The last version that is compatible with older versions of go is v1.3.0.\n\n![testing](https://github.com/gorilla/sessions/actions/workflows/test.yml/badge.svg)\n[![codecov](https://codecov.io/github/gorilla/sessions/branch/main/graph/badge.svg)](https://codecov.io/github/gorilla/sessions)\n[![godoc](https://godoc.org/github.com/gorilla/sessions?status.svg)](https://godoc.org/github.com/gorilla/sessions)\n[![sourcegraph](https://sourcegraph.com/github.com/gorilla/sessions/-/badge.svg)](https://sourcegraph.com/github.com/gorilla/sessions?badge)\n\n![Gorilla Logo](https://github.com/gorilla/.github/assets/53367916/d92caabf-98e0-473e-bfbf-ab554ba435e5)\n\ngorilla/sessions provides cookie and filesystem sessions and infrastructure for\ncustom session backends.\n\nThe key features are:\n\n- Simple API: use it as an easy way to set signed (and optionally\n  encrypted) cookies.\n- Built-in backends to store sessions in cookies or the filesystem.\n- Flash messages: session values that last until read.\n- Convenient way to switch session persistency (aka \"remember me\") and set\n  other attributes.\n- Mechanism to rotate authentication and encryption keys.\n- Multiple sessions per request, even using different backends.\n- Interfaces and infrastructure for custom session backends: sessions from\n  different stores can be retrieved and batch-saved using a common API.\n\nLet's start with an example that shows the sessions API in a nutshell:\n\n```go\n\timport (\n\t\t\"net/http\"\n\t\t\"github.com/gorilla/sessions\"\n\t)\n\n\t// Note: Don't store your key in your source code. Pass it via an\n\t// environmental variable, or flag (or both), and don't accidentally commit it\n\t// alongside your code. Ensure your key is sufficiently random - i.e. use Go's\n\t// crypto/rand or securecookie.GenerateRandomKey(32) and persist the result.\n\tvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\n\tfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t\t// Get a session. We're ignoring the error resulted from decoding an\n\t\t// existing session: Get() always returns a session, even if empty.\n\t\tsession, _ := store.Get(r, \"session-name\")\n\t\t// Set some session values.\n\t\tsession.Values[\"foo\"] = \"bar\"\n\t\tsession.Values[42] = 43\n\t\t// Save it before we write to the response/return from the handler.\n\t\terr := session.Save(r, w)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n```\n\nFirst we initialize a session store calling `NewCookieStore()` and passing a\nsecret key used to authenticate the session. Inside the handler, we call\n`store.Get()` to retrieve an existing session or create a new one. Then we set\nsome session values in session.Values, which is a `map[interface{}]interface{}`.\nAnd finally we call `session.Save()` to save the session in the response.\n\nMore examples are available at [package documentation](https://pkg.go.dev/github.com/gorilla/sessions).\n\n## Store Implementations\n\nOther implementations of the `sessions.Store` interface:\n\n- [github.com/starJammer/gorilla-sessions-arangodb](https://github.com/starJammer/gorilla-sessions-arangodb) - ArangoDB\n- [github.com/yosssi/boltstore](https://github.com/yosssi/boltstore) - Bolt\n- [github.com/srinathgs/couchbasestore](https://github.com/srinathgs/couchbasestore) - Couchbase\n- [github.com/denizeren/dynamostore](https://github.com/denizeren/dynamostore) - Dynamodb on AWS\n- [github.com/savaki/dynastore](https://github.com/savaki/dynastore) - DynamoDB on AWS (Official AWS library)\n- [github.com/bradleypeabody/gorilla-sessions-memcache](https://github.com/bradleypeabody/gorilla-sessions-memcache) - Memcache\n- [github.com/dsoprea/go-appengine-sessioncascade](https://github.com/dsoprea/go-appengine-sessioncascade) - Memcache/Datastore/Context in AppEngine\n- [github.com/kidstuff/mongostore](https://github.com/kidstuff/mongostore) - MongoDB\n- [github.com/srinathgs/mysqlstore](https://github.com/srinathgs/mysqlstore) - MySQL\n- [github.com/danielepintore/gorilla-sessions-mysql](https://github.com/danielepintore/gorilla-sessions-mysql) - MySQL\n- [github.com/EnumApps/clustersqlstore](https://github.com/EnumApps/clustersqlstore) - MySQL Cluster\n- [github.com/antonlindstrom/pgstore](https://github.com/antonlindstrom/pgstore) - PostgreSQL\n- [github.com/boj/redistore](https://github.com/boj/redistore) - Redis\n- [github.com/rbcervilla/redisstore](https://github.com/rbcervilla/redisstore) - Redis (Single, Sentinel, Cluster)\n- [github.com/boj/rethinkstore](https://github.com/boj/rethinkstore) - RethinkDB\n- [github.com/boj/riakstore](https://github.com/boj/riakstore) - Riak\n- [github.com/michaeljs1990/sqlitestore](https://github.com/michaeljs1990/sqlitestore) - SQLite\n- [github.com/wader/gormstore](https://github.com/wader/gormstore) - GORM (MySQL, PostgreSQL, SQLite)\n- [github.com/gernest/qlstore](https://github.com/gernest/qlstore) - ql\n- [github.com/quasoft/memstore](https://github.com/quasoft/memstore) - In-memory implementation for use in unit tests\n- [github.com/lafriks/xormstore](https://github.com/lafriks/xormstore) - XORM (MySQL, PostgreSQL, SQLite, Microsoft SQL Server, TiDB)\n- [github.com/GoogleCloudPlatform/firestore-gorilla-sessions](https://github.com/GoogleCloudPlatform/firestore-gorilla-sessions) - Cloud Firestore\n- [github.com/stephenafamo/crdbstore](https://github.com/stephenafamo/crdbstore) - CockroachDB\n- [github.com/ryicoh/tikvstore](github.com/ryicoh/tikvstore) - TiKV\n\n## License\n\nBSD licensed. See the LICENSE file for details.\n"
        },
        {
          "name": "cookie.go",
          "type": "blob",
          "size": 0.6298828125,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport \"net/http\"\n\n// newCookieFromOptions returns an http.Cookie with the options set.\nfunc newCookieFromOptions(name, value string, options *Options) *http.Cookie {\n\treturn &http.Cookie{\n\t\tName:        name,\n\t\tValue:       value,\n\t\tPath:        options.Path,\n\t\tDomain:      options.Domain,\n\t\tMaxAge:      options.MaxAge,\n\t\tSecure:      options.Secure,\n\t\tHttpOnly:    options.HttpOnly,\n\t\tPartitioned: options.Partitioned,\n\t\tSameSite:    options.SameSite,\n\t}\n\n}\n"
        },
        {
          "name": "cookie_test.go",
          "type": "blob",
          "size": 2.2626953125,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport (\n\t\"testing\"\n)\n\n// Test for creating new http.Cookie from name, value and options\nfunc TestNewCookieFromOptions(t *testing.T) {\n\ttests := []struct {\n\t\tname        string\n\t\tvalue       string\n\t\tpath        string\n\t\tdomain      string\n\t\tmaxAge      int\n\t\tsecure      bool\n\t\thttpOnly    bool\n\t\tpartitioned bool\n\t}{\n\t\t{\"\", \"bar\", \"/foo/bar\", \"foo.example.com\", 3600, true, true, true},\n\t\t{\"foo\", \"\", \"/foo/bar\", \"foo.example.com\", 3600, true, true, true},\n\t\t{\"foo\", \"bar\", \"\", \"foo.example.com\", 3600, true, true, true},\n\t\t{\"foo\", \"bar\", \"/foo/bar\", \"\", 3600, true, true, true},\n\t\t{\"foo\", \"bar\", \"/foo/bar\", \"foo.example.com\", 0, true, true, true},\n\t\t{\"foo\", \"bar\", \"/foo/bar\", \"foo.example.com\", 3600, false, true, true},\n\t\t{\"foo\", \"bar\", \"/foo/bar\", \"foo.example.com\", 3600, true, false, true},\n\t\t{\"foo\", \"bar\", \"/foo/bar\", \"foo.example.com\", 3600, true, true, false},\n\t}\n\tfor i, v := range tests {\n\t\toptions := &Options{\n\t\t\tPath:        v.path,\n\t\t\tDomain:      v.domain,\n\t\t\tMaxAge:      v.maxAge,\n\t\t\tSecure:      v.secure,\n\t\t\tHttpOnly:    v.httpOnly,\n\t\t\tPartitioned: v.partitioned,\n\t\t}\n\t\tcookie := newCookieFromOptions(v.name, v.value, options)\n\t\tif cookie.Name != v.name {\n\t\t\tt.Fatalf(\"%v: bad cookie name: got %q, want %q\", i+1, cookie.Name, v.name)\n\t\t}\n\t\tif cookie.Value != v.value {\n\t\t\tt.Fatalf(\"%v: bad cookie value: got %q, want %q\", i+1, cookie.Value, v.value)\n\t\t}\n\t\tif cookie.Path != v.path {\n\t\t\tt.Fatalf(\"%v: bad cookie path: got %q, want %q\", i+1, cookie.Path, v.path)\n\t\t}\n\t\tif cookie.Domain != v.domain {\n\t\t\tt.Fatalf(\"%v: bad cookie domain: got %q, want %q\", i+1, cookie.Domain, v.domain)\n\t\t}\n\t\tif cookie.MaxAge != v.maxAge {\n\t\t\tt.Fatalf(\"%v: bad cookie maxAge: got %q, want %q\", i+1, cookie.MaxAge, v.maxAge)\n\t\t}\n\t\tif cookie.Secure != v.secure {\n\t\t\tt.Fatalf(\"%v: bad cookie secure: got %v, want %v\", i+1, cookie.Secure, v.secure)\n\t\t}\n\t\tif cookie.HttpOnly != v.httpOnly {\n\t\t\tt.Fatalf(\"%v: bad cookie httpOnly: got %v, want %v\", i+1, cookie.HttpOnly, v.httpOnly)\n\t\t}\n\t\tif cookie.Partitioned != v.partitioned {\n\t\t\tt.Fatalf(\"%v: bad cookie partitioned: got %v, want %v\", i+1, cookie.Partitioned, v.partitioned)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 7.3681640625,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n/*\nPackage sessions provides cookie and filesystem sessions and\ninfrastructure for custom session backends.\n\nThe key features are:\n\n\t* Simple API: use it as an easy way to set signed (and optionally\n\t  encrypted) cookies.\n\t* Built-in backends to store sessions in cookies or the filesystem.\n\t* Flash messages: session values that last until read.\n\t* Convenient way to switch session persistency (aka \"remember me\") and set\n\t  other attributes.\n\t* Mechanism to rotate authentication and encryption keys.\n\t* Multiple sessions per request, even using different backends.\n\t* Interfaces and infrastructure for custom session backends: sessions from\n\t  different stores can be retrieved and batch-saved using a common API.\n\nLet's start with an example that shows the sessions API in a nutshell:\n\n\timport (\n\t\t\"net/http\"\n\t\t\"github.com/gorilla/sessions\"\n\t)\n\n\t// Note: Don't store your key in your source code. Pass it via an\n\t// environmental variable, or flag (or both), and don't accidentally commit it\n\t// alongside your code. Ensure your key is sufficiently random - i.e. use Go's\n\t// crypto/rand or securecookie.GenerateRandomKey(32) and persist the result.\n\t// Ensure SESSION_KEY exists in the environment, or sessions will fail.\n\tvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\n\tfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t\t// Get a session. Get() always returns a session, even if empty.\n\t\tsession, err := store.Get(r, \"session-name\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Set some session values.\n\t\tsession.Values[\"foo\"] = \"bar\"\n\t\tsession.Values[42] = 43\n\t\t// Save it before we write to the response/return from the handler.\n\t\terr = session.Save(r, w)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\nFirst we initialize a session store calling NewCookieStore() and passing a\nsecret key used to authenticate the session. Inside the handler, we call\nstore.Get() to retrieve an existing session or a new one. Then we set some\nsession values in session.Values, which is a map[interface{}]interface{}.\nAnd finally we call session.Save() to save the session in the response.\n\nNote that in production code, we should check for errors when calling\nsession.Save(r, w), and either display an error message or otherwise handle it.\n\nSave must be called before writing to the response, otherwise the session\ncookie will not be sent to the client.\n\nThat's all you need to know for the basic usage. Let's take a look at other\noptions, starting with flash messages.\n\nFlash messages are session values that last until read. The term appeared with\nRuby On Rails a few years back. When we request a flash message, it is removed\nfrom the session. To add a flash, call session.AddFlash(), and to get all\nflashes, call session.Flashes(). Here is an example:\n\n\tfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t\t// Get a session.\n\t\tsession, err := store.Get(r, \"session-name\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Get the previous flashes, if any.\n\t\tif flashes := session.Flashes(); len(flashes) > 0 {\n\t\t\t// Use the flash values.\n\t\t} else {\n\t\t\t// Set a new flash.\n\t\t\tsession.AddFlash(\"Hello, flash messages world!\")\n\t\t}\n\t\terr = session.Save(r, w)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\nFlash messages are useful to set information to be read after a redirection,\nlike after form submissions.\n\nThere may also be cases where you want to store a complex datatype within a\nsession, such as a struct. Sessions are serialised using the encoding/gob package,\nso it is easy to register new datatypes for storage in sessions:\n\n\timport(\n\t\t\"encoding/gob\"\n\t\t\"github.com/gorilla/sessions\"\n\t)\n\n\ttype Person struct {\n\t\tFirstName\tstring\n\t\tLastName \tstring\n\t\tEmail\t\tstring\n\t\tAge\t\t\tint\n\t}\n\n\ttype M map[string]interface{}\n\n\tfunc init() {\n\n\t\tgob.Register(&Person{})\n\t\tgob.Register(&M{})\n\t}\n\nAs it's not possible to pass a raw type as a parameter to a function, gob.Register()\nrelies on us passing it a value of the desired type. In the example above we've passed\nit a pointer to a struct and a pointer to a custom type representing a\nmap[string]interface. (We could have passed non-pointer values if we wished.) This will\nthen allow us to serialise/deserialise values of those types to and from our sessions.\n\nNote that because session values are stored in a map[string]interface{}, there's\na need to type-assert data when retrieving it. We'll use the Person struct we registered above:\n\n\tfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t\tsession, err := store.Get(r, \"session-name\")\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\t// Retrieve our struct and type-assert it\n\t\tval := session.Values[\"person\"]\n\t\tvar person = &Person{}\n\t\tif person, ok := val.(*Person); !ok {\n\t\t\t// Handle the case that it's not an expected type\n\t\t}\n\n\t\t// Now we can use our person object\n\t}\n\nBy default, session cookies last for a month. This is probably too long for\nsome cases, but it is easy to change this and other attributes during\nruntime. Sessions can be configured individually or the store can be\nconfigured and then all sessions saved using it will use that configuration.\nWe access session.Options or store.Options to set a new configuration. The\nfields are basically a subset of http.Cookie fields. Let's change the\nmaximum age of a session to one week:\n\n\tsession.Options = &sessions.Options{\n\t\tPath:     \"/\",\n\t\tMaxAge:   86400 * 7,\n\t\tHttpOnly: true,\n\t}\n\nSometimes we may want to change authentication and/or encryption keys without\nbreaking existing sessions. The CookieStore supports key rotation, and to use\nit you just need to set multiple authentication and encryption keys, in pairs,\nto be tested in order:\n\n\tvar store = sessions.NewCookieStore(\n\t\t[]byte(\"new-authentication-key\"),\n\t\t[]byte(\"new-encryption-key\"),\n\t\t[]byte(\"old-authentication-key\"),\n\t\t[]byte(\"old-encryption-key\"),\n\t)\n\nNew sessions will be saved using the first pair. Old sessions can still be\nread because the first pair will fail, and the second will be tested. This\nmakes it easy to \"rotate\" secret keys and still be able to validate existing\nsessions. Note: for all pairs the encryption key is optional; set it to nil\nor omit it and and encryption won't be used.\n\nMultiple sessions can be used in the same request, even with different\nsession backends. When this happens, calling Save() on each session\nindividually would be cumbersome, so we have a way to save all sessions\nat once: it's sessions.Save(). Here's an example:\n\n\tvar store = sessions.NewCookieStore([]byte(\"something-very-secret\"))\n\n\tfunc MyHandler(w http.ResponseWriter, r *http.Request) {\n\t\t// Get a session and set a value.\n\t\tsession1, _ := store.Get(r, \"session-one\")\n\t\tsession1.Values[\"foo\"] = \"bar\"\n\t\t// Get another session and set another value.\n\t\tsession2, _ := store.Get(r, \"session-two\")\n\t\tsession2.Values[42] = 43\n\t\t// Save all sessions.\n\t\terr = sessions.Save(r, w)\n\t\tif err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\nThis is possible because when we call Get() from a session store, it adds the\nsession to a common registry. Save() uses it to save all registered sessions.\n*/\npackage sessions\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.08984375,
          "content": "module github.com/gorilla/sessions\n\ngo 1.23\n\nrequire github.com/gorilla/securecookie v1.1.2\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 0.2548828125,
          "content": "github.com/google/gofuzz v1.2.0 h1:xRy4A+RhZaiKjJ1bPfwQ8sedCA+YS2YcCHW6ec7JMi0=\ngithub.com/gorilla/securecookie v1.1.2 h1:YCIWL56dvtr73r6715mJs5ZvhtnY73hBvEF8kXD8ePA=\ngithub.com/gorilla/securecookie v1.1.2/go.mod h1:NfCASbcHqRSY+3a8tlWJwsQap2VX5pwzwo4h3eOamfo=\n"
        },
        {
          "name": "lex.go",
          "type": "blob",
          "size": 1.4697265625,
          "content": "// This file contains code adapted from the Go standard library\n// https://github.com/golang/go/blob/39ad0fd0789872f9469167be7fe9578625ff246e/src/net/http/lex.go\n\npackage sessions\n\nimport \"strings\"\n\nvar isTokenTable = [127]bool{\n\t'!':  true,\n\t'#':  true,\n\t'$':  true,\n\t'%':  true,\n\t'&':  true,\n\t'\\'': true,\n\t'*':  true,\n\t'+':  true,\n\t'-':  true,\n\t'.':  true,\n\t'0':  true,\n\t'1':  true,\n\t'2':  true,\n\t'3':  true,\n\t'4':  true,\n\t'5':  true,\n\t'6':  true,\n\t'7':  true,\n\t'8':  true,\n\t'9':  true,\n\t'A':  true,\n\t'B':  true,\n\t'C':  true,\n\t'D':  true,\n\t'E':  true,\n\t'F':  true,\n\t'G':  true,\n\t'H':  true,\n\t'I':  true,\n\t'J':  true,\n\t'K':  true,\n\t'L':  true,\n\t'M':  true,\n\t'N':  true,\n\t'O':  true,\n\t'P':  true,\n\t'Q':  true,\n\t'R':  true,\n\t'S':  true,\n\t'T':  true,\n\t'U':  true,\n\t'W':  true,\n\t'V':  true,\n\t'X':  true,\n\t'Y':  true,\n\t'Z':  true,\n\t'^':  true,\n\t'_':  true,\n\t'`':  true,\n\t'a':  true,\n\t'b':  true,\n\t'c':  true,\n\t'd':  true,\n\t'e':  true,\n\t'f':  true,\n\t'g':  true,\n\t'h':  true,\n\t'i':  true,\n\t'j':  true,\n\t'k':  true,\n\t'l':  true,\n\t'm':  true,\n\t'n':  true,\n\t'o':  true,\n\t'p':  true,\n\t'q':  true,\n\t'r':  true,\n\t's':  true,\n\t't':  true,\n\t'u':  true,\n\t'v':  true,\n\t'w':  true,\n\t'x':  true,\n\t'y':  true,\n\t'z':  true,\n\t'|':  true,\n\t'~':  true,\n}\n\nfunc isToken(r rune) bool {\n\ti := int(r)\n\treturn i < len(isTokenTable) && isTokenTable[i]\n}\n\nfunc isNotToken(r rune) bool {\n\treturn !isToken(r)\n}\n\nfunc isCookieNameValid(raw string) bool {\n\tif raw == \"\" {\n\t\treturn false\n\t}\n\treturn strings.IndexFunc(raw, isNotToken) < 0\n}\n"
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 0.6806640625,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport \"net/http\"\n\n// Options stores configuration for a session or session store.\n//\n// Fields are a subset of http.Cookie fields.\ntype Options struct {\n\tPath   string\n\tDomain string\n\t// MaxAge=0 means no Max-Age attribute specified and the cookie will be\n\t// deleted after the browser session ends.\n\t// MaxAge<0 means delete cookie immediately.\n\t// MaxAge>0 means Max-Age attribute present and given in seconds.\n\tMaxAge      int\n\tSecure      bool\n\tHttpOnly    bool\n\tPartitioned bool\n\tSameSite    http.SameSite\n}\n"
        },
        {
          "name": "sessions.go",
          "type": "blob",
          "size": 5.7177734375,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport (\n\t\"context\"\n\t\"encoding/gob\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n)\n\n// Default flashes key.\nconst flashesKey = \"_flash\"\n\n// Session --------------------------------------------------------------------\n\n// NewSession is called by session stores to create a new session instance.\nfunc NewSession(store Store, name string) *Session {\n\treturn &Session{\n\t\tValues:  make(map[interface{}]interface{}),\n\t\tstore:   store,\n\t\tname:    name,\n\t\tOptions: new(Options),\n\t}\n}\n\n// Session stores the values and optional configuration for a session.\ntype Session struct {\n\t// The ID of the session, generated by stores. It should not be used for\n\t// user data.\n\tID string\n\t// Values contains the user-data for the session.\n\tValues  map[interface{}]interface{}\n\tOptions *Options\n\tIsNew   bool\n\tstore   Store\n\tname    string\n}\n\n// Flashes returns a slice of flash messages from the session.\n//\n// A single variadic argument is accepted, and it is optional: it defines\n// the flash key. If not defined \"_flash\" is used by default.\nfunc (s *Session) Flashes(vars ...string) []interface{} {\n\tvar flashes []interface{}\n\tkey := flashesKey\n\tif len(vars) > 0 {\n\t\tkey = vars[0]\n\t}\n\tif v, ok := s.Values[key]; ok {\n\t\t// Drop the flashes and return it.\n\t\tdelete(s.Values, key)\n\t\tflashes = v.([]interface{})\n\t}\n\treturn flashes\n}\n\n// AddFlash adds a flash message to the session.\n//\n// A single variadic argument is accepted, and it is optional: it defines\n// the flash key. If not defined \"_flash\" is used by default.\nfunc (s *Session) AddFlash(value interface{}, vars ...string) {\n\tkey := flashesKey\n\tif len(vars) > 0 {\n\t\tkey = vars[0]\n\t}\n\tvar flashes []interface{}\n\tif v, ok := s.Values[key]; ok {\n\t\tflashes = v.([]interface{})\n\t}\n\ts.Values[key] = append(flashes, value)\n}\n\n// Save is a convenience method to save this session. It is the same as calling\n// store.Save(request, response, session). You should call Save before writing to\n// the response or returning from the handler.\nfunc (s *Session) Save(r *http.Request, w http.ResponseWriter) error {\n\treturn s.store.Save(r, w, s)\n}\n\n// Name returns the name used to register the session.\nfunc (s *Session) Name() string {\n\treturn s.name\n}\n\n// Store returns the session store used to register the session.\nfunc (s *Session) Store() Store {\n\treturn s.store\n}\n\n// Registry -------------------------------------------------------------------\n\n// sessionInfo stores a session tracked by the registry.\ntype sessionInfo struct {\n\ts *Session\n\te error\n}\n\n// contextKey is the type used to store the registry in the context.\ntype contextKey int\n\n// registryKey is the key used to store the registry in the context.\nconst registryKey contextKey = 0\n\n// GetRegistry returns a registry instance for the current request.\nfunc GetRegistry(r *http.Request) *Registry {\n\tvar ctx = r.Context()\n\tregistry := ctx.Value(registryKey)\n\tif registry != nil {\n\t\treturn registry.(*Registry)\n\t}\n\tnewRegistry := &Registry{\n\t\trequest:  r,\n\t\tsessions: make(map[string]sessionInfo),\n\t}\n\t*r = *r.WithContext(context.WithValue(ctx, registryKey, newRegistry))\n\treturn newRegistry\n}\n\n// Registry stores sessions used during a request.\ntype Registry struct {\n\trequest  *http.Request\n\tsessions map[string]sessionInfo\n}\n\n// Get registers and returns a session for the given name and session store.\n//\n// It returns a new session if there are no sessions registered for the name.\nfunc (s *Registry) Get(store Store, name string) (session *Session, err error) {\n\tif !isCookieNameValid(name) {\n\t\treturn nil, fmt.Errorf(\"sessions: invalid character in cookie name: %s\", name)\n\t}\n\tif info, ok := s.sessions[name]; ok {\n\t\tsession, err = info.s, info.e\n\t} else {\n\t\tsession, err = store.New(s.request, name)\n\t\tsession.name = name\n\t\ts.sessions[name] = sessionInfo{s: session, e: err}\n\t}\n\tsession.store = store\n\treturn\n}\n\n// Save saves all sessions registered for the current request.\nfunc (s *Registry) Save(w http.ResponseWriter) error {\n\tvar errMulti MultiError\n\tfor name, info := range s.sessions {\n\t\tsession := info.s\n\t\tif session.store == nil {\n\t\t\terrMulti = append(errMulti, fmt.Errorf(\n\t\t\t\t\"sessions: missing store for session %q\", name))\n\t\t} else if err := session.store.Save(s.request, w, session); err != nil {\n\t\t\terrMulti = append(errMulti, fmt.Errorf(\n\t\t\t\t\"sessions: error saving session %q -- %v\", name, err))\n\t\t}\n\t}\n\tif errMulti != nil {\n\t\treturn errMulti\n\t}\n\treturn nil\n}\n\n// Helpers --------------------------------------------------------------------\n\nfunc init() {\n\tgob.Register([]interface{}{})\n}\n\n// Save saves all sessions used during the current request.\nfunc Save(r *http.Request, w http.ResponseWriter) error {\n\treturn GetRegistry(r).Save(w)\n}\n\n// NewCookie returns an http.Cookie with the options set. It also sets\n// the Expires field calculated based on the MaxAge value, for Internet\n// Explorer compatibility.\nfunc NewCookie(name, value string, options *Options) *http.Cookie {\n\tcookie := newCookieFromOptions(name, value, options)\n\tif options.MaxAge > 0 {\n\t\td := time.Duration(options.MaxAge) * time.Second\n\t\tcookie.Expires = time.Now().Add(d)\n\t} else if options.MaxAge < 0 {\n\t\t// Set it to the past to expire now.\n\t\tcookie.Expires = time.Unix(1, 0)\n\t}\n\treturn cookie\n}\n\n// Error ----------------------------------------------------------------------\n\n// MultiError stores multiple errors.\n//\n// Borrowed from the App Engine SDK.\ntype MultiError []error\n\nfunc (m MultiError) Error() string {\n\ts, n := \"\", 0\n\tfor _, e := range m {\n\t\tif e != nil {\n\t\t\tif n == 0 {\n\t\t\t\ts = e.Error()\n\t\t\t}\n\t\t\tn++\n\t\t}\n\t}\n\tswitch n {\n\tcase 0:\n\t\treturn \"(0 errors)\"\n\tcase 1:\n\t\treturn s\n\tcase 2:\n\t\treturn s + \" (and 1 other error)\"\n\t}\n\treturn fmt.Sprintf(\"%s (and %d other errors)\", s, n-1)\n}\n"
        },
        {
          "name": "sessions_test.go",
          "type": "blob",
          "size": 5.9169921875,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport (\n\t\"bytes\"\n\t\"encoding/gob\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"strings\"\n\t\"testing\"\n)\n\n// NewRecorder returns an initialized ResponseRecorder.\nfunc NewRecorder() *httptest.ResponseRecorder {\n\treturn &httptest.ResponseRecorder{\n\t\tHeaderMap: make(http.Header),\n\t\tBody:      new(bytes.Buffer),\n\t}\n}\n\n// ----------------------------------------------------------------------------\n\ntype FlashMessage struct {\n\tType    int\n\tMessage string\n}\n\nfunc TestFlashes(t *testing.T) {\n\tvar req *http.Request\n\tvar rsp *httptest.ResponseRecorder\n\tvar hdr http.Header\n\tvar err error\n\tvar ok bool\n\tvar cookies []string\n\tvar session *Session\n\tvar flashes []interface{}\n\n\tstore := NewCookieStore([]byte(\"secret-key\"))\n\n\tif store.Options.SameSite != http.SameSiteNoneMode {\n\t\tt.Fatalf(\"cookie store error: default same site is not set to None\")\n\t}\n\n\t// Round 1 ----------------------------------------------------------------\n\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:8080/\", nil)\n\trsp = NewRecorder()\n\t// Get a session.\n\tif session, err = store.Get(req, \"session-key\"); err != nil {\n\t\tt.Fatalf(\"Error getting session: %v\", err)\n\t}\n\t// Get a flash.\n\tflashes = session.Flashes()\n\tif len(flashes) != 0 {\n\t\tt.Errorf(\"Expected empty flashes; Got %v\", flashes)\n\t}\n\t// Add some flashes.\n\tsession.AddFlash(\"foo\")\n\tsession.AddFlash(\"bar\")\n\t// Custom key.\n\tsession.AddFlash(\"baz\", \"custom_key\")\n\t// Save.\n\tif err = Save(req, rsp); err != nil {\n\t\tt.Fatalf(\"Error saving session: %v\", err)\n\t}\n\thdr = rsp.Header()\n\tcookies, ok = hdr[\"Set-Cookie\"]\n\tif !ok || len(cookies) != 1 {\n\t\tt.Fatal(\"No cookies. Header:\", hdr)\n\t}\n\n\tif !strings.Contains(cookies[0], \"SameSite=None\") || !strings.Contains(cookies[0], \"Secure\") {\n\t\tt.Fatal(\"Set-Cookie does not contains SameSite=None with Secure, cookie string:\", cookies[0])\n\t}\n\n\tif _, err = store.Get(req, \"session:key\"); err.Error() != \"sessions: invalid character in cookie name: session:key\" {\n\t\tt.Fatalf(\"Expected error due to invalid cookie name\")\n\t}\n\n\t// Round 2 ----------------------------------------------------------------\n\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:8080/\", nil)\n\treq.Header.Add(\"Cookie\", cookies[0])\n\t// Get a session.\n\tif session, err = store.Get(req, \"session-key\"); err != nil {\n\t\tt.Fatalf(\"Error getting session: %v\", err)\n\t}\n\t// Check all saved values.\n\tflashes = session.Flashes()\n\tif len(flashes) != 2 {\n\t\tt.Fatalf(\"Expected flashes; Got %v\", flashes)\n\t}\n\tif flashes[0] != \"foo\" || flashes[1] != \"bar\" {\n\t\tt.Errorf(\"Expected foo,bar; Got %v\", flashes)\n\t}\n\tflashes = session.Flashes()\n\tif len(flashes) != 0 {\n\t\tt.Errorf(\"Expected dumped flashes; Got %v\", flashes)\n\t}\n\t// Custom key.\n\tflashes = session.Flashes(\"custom_key\")\n\tif len(flashes) != 1 {\n\t\tt.Errorf(\"Expected flashes; Got %v\", flashes)\n\t} else if flashes[0] != \"baz\" {\n\t\tt.Errorf(\"Expected baz; Got %v\", flashes)\n\t}\n\tflashes = session.Flashes(\"custom_key\")\n\tif len(flashes) != 0 {\n\t\tt.Errorf(\"Expected dumped flashes; Got %v\", flashes)\n\t}\n\n\t// Round 3 ----------------------------------------------------------------\n\t// Custom type\n\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:8080/\", nil)\n\trsp = NewRecorder()\n\t// Get a session.\n\tif session, err = store.Get(req, \"session-key\"); err != nil {\n\t\tt.Fatalf(\"Error getting session: %v\", err)\n\t}\n\t// Get a flash.\n\tflashes = session.Flashes()\n\tif len(flashes) != 0 {\n\t\tt.Errorf(\"Expected empty flashes; Got %v\", flashes)\n\t}\n\t// Add some flashes.\n\tsession.AddFlash(&FlashMessage{42, \"foo\"})\n\t// Save.\n\tif err = Save(req, rsp); err != nil {\n\t\tt.Fatalf(\"Error saving session: %v\", err)\n\t}\n\thdr = rsp.Header()\n\tcookies, ok = hdr[\"Set-Cookie\"]\n\tif !ok || len(cookies) != 1 {\n\t\tt.Fatal(\"No cookies. Header:\", hdr)\n\t}\n\n\t// Round 4 ----------------------------------------------------------------\n\t// Custom type\n\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:8080/\", nil)\n\treq.Header.Add(\"Cookie\", cookies[0])\n\t// Get a session.\n\tif session, err = store.Get(req, \"session-key\"); err != nil {\n\t\tt.Fatalf(\"Error getting session: %v\", err)\n\t}\n\t// Check all saved values.\n\tflashes = session.Flashes()\n\tif len(flashes) != 1 {\n\t\tt.Fatalf(\"Expected flashes; Got %v\", flashes)\n\t}\n\tcustom := flashes[0].(FlashMessage)\n\tif custom.Type != 42 || custom.Message != \"foo\" {\n\t\tt.Errorf(\"Expected %#v, got %#v\", FlashMessage{42, \"foo\"}, custom)\n\t}\n\n\t// Round 5 ----------------------------------------------------------------\n\t// Check if a request shallow copy resets the request context data store.\n\n\treq, _ = http.NewRequest(\"GET\", \"http://localhost:8080/\", nil)\n\n\t// Get a session.\n\tif session, err = store.Get(req, \"session-key\"); err != nil {\n\t\tt.Fatalf(\"Error getting session: %v\", err)\n\t}\n\n\t// Put a test value into the session data store.\n\tsession.Values[\"test\"] = \"test-value\"\n\n\t// Create a shallow copy of the request.\n\treq = req.WithContext(req.Context())\n\n\t// Get the session again.\n\tif session, err = store.Get(req, \"session-key\"); err != nil {\n\t\tt.Fatalf(\"Error getting session: %v\", err)\n\t}\n\n\t// Check if the previous inserted value still exists.\n\tif session.Values[\"test\"] == nil {\n\t\tt.Fatalf(\"Session test value is lost in the request context!\")\n\t}\n\n\t// Check if the previous inserted value has the same value.\n\tif session.Values[\"test\"] != \"test-value\" {\n\t\tt.Fatalf(\"Session test value is changed in the request context!\")\n\t}\n}\n\nfunc TestCookieStoreMapPanic(t *testing.T) {\n\tdefer func() {\n\t\terr := recover()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}()\n\n\tstore := NewCookieStore([]byte(\"aaa0defe5d2839cbc46fc4f080cd7adc\"))\n\treq, err := http.NewRequest(\"GET\", \"http://www.example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"failed to create request\", err)\n\t}\n\tw := httptest.NewRecorder()\n\n\tsession := NewSession(store, \"hello\")\n\n\tsession.Values[\"data\"] = \"hello-world\"\n\n\terr = session.Save(req, w)\n\tif err != nil {\n\t\tt.Fatal(\"failed to save session\", err)\n\t}\n}\n\nfunc init() {\n\tgob.Register(FlashMessage{})\n}\n"
        },
        {
          "name": "store.go",
          "type": "blob",
          "size": 8.626953125,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport (\n\t\"encoding/base32\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"sync\"\n\n\t\"github.com/gorilla/securecookie\"\n)\n\nconst (\n\t// File name prefix for session files.\n\tsessionFilePrefix = \"session_\"\n)\n\n// Store is an interface for custom session stores.\n//\n// See CookieStore and FilesystemStore for examples.\ntype Store interface {\n\t// Get should return a cached session.\n\tGet(r *http.Request, name string) (*Session, error)\n\n\t// New should create and return a new session.\n\t//\n\t// Note that New should never return a nil session, even in the case of\n\t// an error if using the Registry infrastructure to cache the session.\n\tNew(r *http.Request, name string) (*Session, error)\n\n\t// Save should persist session to the underlying store implementation.\n\tSave(r *http.Request, w http.ResponseWriter, s *Session) error\n}\n\n// CookieStore ----------------------------------------------------------------\n\n// NewCookieStore returns a new CookieStore.\n//\n// Keys are defined in pairs to allow key rotation, but the common case is\n// to set a single authentication key and optionally an encryption key.\n//\n// The first key in a pair is used for authentication and the second for\n// encryption. The encryption key can be set to nil or omitted in the last\n// pair, but the authentication key is required in all pairs.\n//\n// It is recommended to use an authentication key with 32 or 64 bytes.\n// The encryption key, if set, must be either 16, 24, or 32 bytes to select\n// AES-128, AES-192, or AES-256 modes.\nfunc NewCookieStore(keyPairs ...[]byte) *CookieStore {\n\tcs := &CookieStore{\n\t\tCodecs: securecookie.CodecsFromPairs(keyPairs...),\n\t\tOptions: &Options{\n\t\t\tPath:     \"/\",\n\t\t\tMaxAge:   86400 * 30,\n\t\t\tSameSite: http.SameSiteNoneMode,\n\t\t\tSecure:   true,\n\t\t},\n\t}\n\n\tcs.MaxAge(cs.Options.MaxAge)\n\treturn cs\n}\n\n// CookieStore stores sessions using secure cookies.\ntype CookieStore struct {\n\tCodecs  []securecookie.Codec\n\tOptions *Options // default configuration\n}\n\n// Get returns a session for the given name after adding it to the registry.\n//\n// It returns a new session if the sessions doesn't exist. Access IsNew on\n// the session to check if it is an existing session or a new one.\n//\n// It returns a new session and an error if the session exists but could\n// not be decoded.\nfunc (s *CookieStore) Get(r *http.Request, name string) (*Session, error) {\n\treturn GetRegistry(r).Get(s, name)\n}\n\n// New returns a session for the given name without adding it to the registry.\n//\n// The difference between New() and Get() is that calling New() twice will\n// decode the session data twice, while Get() registers and reuses the same\n// decoded session after the first call.\nfunc (s *CookieStore) New(r *http.Request, name string) (*Session, error) {\n\tsession := NewSession(s, name)\n\topts := *s.Options\n\tsession.Options = &opts\n\tsession.IsNew = true\n\tvar err error\n\tif c, errCookie := r.Cookie(name); errCookie == nil {\n\t\terr = securecookie.DecodeMulti(name, c.Value, &session.Values,\n\t\t\ts.Codecs...)\n\t\tif err == nil {\n\t\t\tsession.IsNew = false\n\t\t}\n\t}\n\treturn session, err\n}\n\n// Save adds a single session to the response.\nfunc (s *CookieStore) Save(r *http.Request, w http.ResponseWriter,\n\tsession *Session) error {\n\tencoded, err := securecookie.EncodeMulti(session.Name(), session.Values,\n\t\ts.Codecs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\thttp.SetCookie(w, NewCookie(session.Name(), encoded, session.Options))\n\treturn nil\n}\n\n// MaxAge sets the maximum age for the store and the underlying cookie\n// implementation. Individual sessions can be deleted by setting Options.MaxAge\n// = -1 for that session.\nfunc (s *CookieStore) MaxAge(age int) {\n\ts.Options.MaxAge = age\n\n\t// Set the maxAge for each securecookie instance.\n\tfor _, codec := range s.Codecs {\n\t\tif sc, ok := codec.(*securecookie.SecureCookie); ok {\n\t\t\tsc.MaxAge(age)\n\t\t}\n\t}\n}\n\n// FilesystemStore ------------------------------------------------------------\n\nvar fileMutex sync.RWMutex\n\n// NewFilesystemStore returns a new FilesystemStore.\n//\n// The path argument is the directory where sessions will be saved. If empty\n// it will use os.TempDir().\n//\n// See NewCookieStore() for a description of the other parameters.\nfunc NewFilesystemStore(path string, keyPairs ...[]byte) *FilesystemStore {\n\tif path == \"\" {\n\t\tpath = os.TempDir()\n\t}\n\tfs := &FilesystemStore{\n\t\tCodecs: securecookie.CodecsFromPairs(keyPairs...),\n\t\tOptions: &Options{\n\t\t\tPath:   \"/\",\n\t\t\tMaxAge: 86400 * 30,\n\t\t},\n\t\tpath: path,\n\t}\n\n\tfs.MaxAge(fs.Options.MaxAge)\n\treturn fs\n}\n\n// FilesystemStore stores sessions in the filesystem.\n//\n// It also serves as a reference for custom stores.\n//\n// This store is still experimental and not well tested. Feedback is welcome.\ntype FilesystemStore struct {\n\tCodecs  []securecookie.Codec\n\tOptions *Options // default configuration\n\tpath    string\n}\n\n// MaxLength restricts the maximum length of new sessions to l.\n// If l is 0 there is no limit to the size of a session, use with caution.\n// The default for a new FilesystemStore is 4096.\nfunc (s *FilesystemStore) MaxLength(l int) {\n\tfor _, c := range s.Codecs {\n\t\tif codec, ok := c.(*securecookie.SecureCookie); ok {\n\t\t\tcodec.MaxLength(l)\n\t\t}\n\t}\n}\n\n// Get returns a session for the given name after adding it to the registry.\n//\n// See CookieStore.Get().\nfunc (s *FilesystemStore) Get(r *http.Request, name string) (*Session, error) {\n\treturn GetRegistry(r).Get(s, name)\n}\n\n// New returns a session for the given name without adding it to the registry.\n//\n// See CookieStore.New().\nfunc (s *FilesystemStore) New(r *http.Request, name string) (*Session, error) {\n\tsession := NewSession(s, name)\n\topts := *s.Options\n\tsession.Options = &opts\n\tsession.IsNew = true\n\tvar err error\n\tif c, errCookie := r.Cookie(name); errCookie == nil {\n\t\terr = securecookie.DecodeMulti(name, c.Value, &session.ID, s.Codecs...)\n\t\tif err == nil {\n\t\t\terr = s.load(session)\n\t\t\tif err == nil {\n\t\t\t\tsession.IsNew = false\n\t\t\t}\n\t\t}\n\t}\n\treturn session, err\n}\n\nvar base32RawStdEncoding = base32.StdEncoding.WithPadding(base32.NoPadding)\n\n// Save adds a single session to the response.\n//\n// If the Options.MaxAge of the session is <= 0 then the session file will be\n// deleted from the store path. With this process it enforces the properly\n// session cookie handling so no need to trust in the cookie management in the\n// web browser.\nfunc (s *FilesystemStore) Save(r *http.Request, w http.ResponseWriter,\n\tsession *Session) error {\n\t// Delete if max-age is <= 0\n\tif session.Options.MaxAge <= 0 {\n\t\tif err := s.erase(session); err != nil && !os.IsNotExist(err) {\n\t\t\treturn err\n\t\t}\n\t\thttp.SetCookie(w, NewCookie(session.Name(), \"\", session.Options))\n\t\treturn nil\n\t}\n\n\tif session.ID == \"\" {\n\t\t// Because the ID is used in the filename, encode it to\n\t\t// use alphanumeric characters only.\n\t\tsession.ID = base32RawStdEncoding.EncodeToString(\n\t\t\tsecurecookie.GenerateRandomKey(32))\n\t}\n\tif err := s.save(session); err != nil {\n\t\treturn err\n\t}\n\tencoded, err := securecookie.EncodeMulti(session.Name(), session.ID,\n\t\ts.Codecs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\thttp.SetCookie(w, NewCookie(session.Name(), encoded, session.Options))\n\treturn nil\n}\n\n// MaxAge sets the maximum age for the store and the underlying cookie\n// implementation. Individual sessions can be deleted by setting Options.MaxAge\n// = -1 for that session.\nfunc (s *FilesystemStore) MaxAge(age int) {\n\ts.Options.MaxAge = age\n\n\t// Set the maxAge for each securecookie instance.\n\tfor _, codec := range s.Codecs {\n\t\tif sc, ok := codec.(*securecookie.SecureCookie); ok {\n\t\t\tsc.MaxAge(age)\n\t\t}\n\t}\n}\n\n// save writes encoded session.Values to a file.\nfunc (s *FilesystemStore) save(session *Session) error {\n\tencoded, err := securecookie.EncodeMulti(session.Name(), session.Values,\n\t\ts.Codecs...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfilename := filepath.Join(s.path, sessionFilePrefix+filepath.Base(session.ID))\n\tfileMutex.Lock()\n\tdefer fileMutex.Unlock()\n\treturn os.WriteFile(filename, []byte(encoded), 0600)\n}\n\n// load reads a file and decodes its content into session.Values.\nfunc (s *FilesystemStore) load(session *Session) error {\n\tfilename := filepath.Join(s.path, sessionFilePrefix+filepath.Base(session.ID))\n\tfileMutex.RLock()\n\tdefer fileMutex.RUnlock()\n\tfdata, err := os.ReadFile(filepath.Clean(filename))\n\tif err != nil {\n\t\treturn err\n\t}\n\tif err = securecookie.DecodeMulti(session.Name(), string(fdata),\n\t\t&session.Values, s.Codecs...); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n// delete session file\nfunc (s *FilesystemStore) erase(session *Session) error {\n\tfilename := filepath.Join(s.path, sessionFilePrefix+filepath.Base(session.ID))\n\n\tfileMutex.RLock()\n\tdefer fileMutex.RUnlock()\n\n\terr := os.Remove(filename)\n\treturn err\n}\n"
        },
        {
          "name": "store_test.go",
          "type": "blob",
          "size": 3.2841796875,
          "content": "// Copyright 2012 The Gorilla Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage sessions\n\nimport (\n\t\"encoding/base64\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"testing\"\n)\n\n// Test for GH-8 for CookieStore\nfunc TestGH8CookieStore(t *testing.T) {\n\toriginalPath := \"/\"\n\tstore := NewCookieStore()\n\tstore.Options.Path = originalPath\n\treq, err := http.NewRequest(\"GET\", \"http://www.example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"failed to create request\", err)\n\t}\n\n\tsession, err := store.New(req, \"hello\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to create session\", err)\n\t}\n\n\tstore.Options.Path = \"/foo\"\n\tif session.Options.Path != originalPath {\n\t\tt.Fatalf(\"bad session path: got %q, want %q\", session.Options.Path, originalPath)\n\t}\n}\n\n// Test for GH-8 for FilesystemStore\nfunc TestGH8FilesystemStore(t *testing.T) {\n\toriginalPath := \"/\"\n\tstore := NewFilesystemStore(\"\")\n\tstore.Options.Path = originalPath\n\treq, err := http.NewRequest(\"GET\", \"http://www.example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"failed to create request\", err)\n\t}\n\n\tsession, err := store.New(req, \"hello\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to create session\", err)\n\t}\n\n\tstore.Options.Path = \"/foo\"\n\tif session.Options.Path != originalPath {\n\t\tt.Fatalf(\"bad session path: got %q, want %q\", session.Options.Path, originalPath)\n\t}\n}\n\n// Test for GH-2.\nfunc TestGH2MaxLength(t *testing.T) {\n\tstore := NewFilesystemStore(\"\", []byte(\"some key\"))\n\treq, err := http.NewRequest(\"GET\", \"http://www.example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"failed to create request\", err)\n\t}\n\tw := httptest.NewRecorder()\n\n\tsession, err := store.New(req, \"my session\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to create session\", err)\n\t}\n\n\tsession.Values[\"big\"] = make([]byte, base64.StdEncoding.DecodedLen(4096*2))\n\terr = session.Save(req, w)\n\tif err == nil {\n\t\tt.Fatal(\"expected an error, got nil\")\n\t}\n\n\tstore.MaxLength(4096 * 3) // A bit more than the value size to account for encoding overhead.\n\terr = session.Save(req, w)\n\tif err != nil {\n\t\tt.Fatal(\"failed to Save:\", err)\n\t}\n}\n\n// Test delete filesystem store with max-age: -1\nfunc TestGH8FilesystemStoreDelete(t *testing.T) {\n\tstore := NewFilesystemStore(\"\", []byte(\"some key\"))\n\treq, err := http.NewRequest(\"GET\", \"http://www.example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"failed to create request\", err)\n\t}\n\tw := httptest.NewRecorder()\n\n\tsession, err := store.New(req, \"hello\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to create session\", err)\n\t}\n\n\terr = session.Save(req, w)\n\tif err != nil {\n\t\tt.Fatal(\"failed to save session\", err)\n\t}\n\n\tsession.Options.MaxAge = -1\n\terr = session.Save(req, w)\n\tif err != nil {\n\t\tt.Fatal(\"failed to delete session\", err)\n\t}\n}\n\n// Test delete filesystem store with max-age: 0\nfunc TestGH8FilesystemStoreDelete2(t *testing.T) {\n\tstore := NewFilesystemStore(\"\", []byte(\"some key\"))\n\treq, err := http.NewRequest(\"GET\", \"http://www.example.com\", nil)\n\tif err != nil {\n\t\tt.Fatal(\"failed to create request\", err)\n\t}\n\tw := httptest.NewRecorder()\n\n\tsession, err := store.New(req, \"hello\")\n\tif err != nil {\n\t\tt.Fatal(\"failed to create session\", err)\n\t}\n\n\terr = session.Save(req, w)\n\tif err != nil {\n\t\tt.Fatal(\"failed to save session\", err)\n\t}\n\n\tsession.Options.MaxAge = 0\n\terr = session.Save(req, w)\n\tif err != nil {\n\t\tt.Fatal(\"failed to delete session\", err)\n\t}\n}\n"
        }
      ]
    }
  ]
}