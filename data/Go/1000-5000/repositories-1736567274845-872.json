{
  "metadata": {
    "timestamp": 1736567274845,
    "page": 872,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjg4MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nlf/dlite",
      "stars": 2338,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.0322265625,
          "content": "dlite\nassets.go\nassets\n.DS_Store\n"
        },
        {
          "name": ".gitmodules",
          "type": "blob",
          "size": 0.078125,
          "content": "[submodule \"hyperkit\"]\n\tpath = hyperkit\n\turl = git://github.com/docker/hyperkit\n"
        },
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.4482421875,
          "content": "os: osx\nlanguage: go\nosx_image: xcode8\n\nbefore_install:\n  - brew update\n  - brew outdated golang || brew upgrade golang\n  - brew install opam libev\n  - opam init -y\n  - go version\n\ninstall:\n  - eval `opam config env`\n  - opam install -y uri qcow.0.7.0 conf-libev logs fmt\n  - go get -u github.com/jteeuwen/go-bindata/...\n\nscript:\n  - go generate\n  - go build\n  - ./dlite --version || true\n\nnotifications:\n  email:\n    on_success: never\n    on_failure: always\n"
        },
        {
          "name": "LICENSE.md",
          "type": "blob",
          "size": 1.05859375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Nathan LaFreniere\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 0.7099609375,
          "content": "# DLite\n\nTHIS PROJECT NEEDS A NEW MAINTAINER - I have stopped using OSX and no longer have time to continue to work on this. Open an issue if you're interested.\n\nthis branch represents the latest *beta* version. the stable version can be found in the legacy branch.\n\n## Building\n\ninstall dependencies\n\n```sh\nbrew install opam golang libev\nopam init\neval `opam config env`\nopam install uri qcow.0.7.0 conf-libev logs fmt qcow-format\ngo get -u github.com/jteeuwen/go-bindata/...\ngit submodule init\ngit submodule update\n```\n\nupdate dependencies (use this if you've already built the project before)\n\n```sh\ngit submodule foreach git pull origin master\nopam update\nopam upgrade\n```\n\nbuild the binary\n\n```sh\ngo generate\ngo build\n```\n"
        },
        {
          "name": "api.go",
          "type": "blob",
          "size": 3.9609375,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype API struct {\n\tdone   chan bool\n\tdaemon *Daemon\n}\n\nfunc extractUser(r *http.Request) (*User, error) {\n\tuserHeader, ok := r.Header[\"X-Username\"]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"Missing X-Username header\")\n\t}\n\n\treturn lookupUser(userHeader[0])\n}\n\nfunc (a *API) start(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"Method not allowed\"))\n\t\treturn\n\t}\n\n\tif a.daemon.VM != nil {\n\t\tw.WriteHeader(http.StatusConflict)\n\t\tw.Write([]byte(\"Conflict\"))\n\t\treturn\n\t}\n\n\tuser, err := extractUser(r)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\tw.Write([]byte(\"Unauthorized\"))\n\t\treturn\n\t}\n\n\ta.daemon.VM, err = NewVM(user)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\terr = a.daemon.VM.Start()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write([]byte(err.Error()))\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\t// w.Write([]byte(fmt.Sprintf(\"Virtual machine started, tty available at %s\", a.daemon.VM.TTY)))\n}\n\nfunc (a *API) started(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"Method not allowed\"))\n\t\treturn\n\t}\n\n\tif a.daemon.VM == nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"Virtual machine has not been started\"))\n\t\treturn\n\t}\n\n\ta.daemon.VM.Started = true\n\tw.Write([]byte(\"Virtual machine flagged as started\"))\n}\n\nfunc (a *API) stop(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\tw.WriteHeader(http.StatusMethodNotAllowed)\n\t\tw.Write([]byte(\"Method not allowed\"))\n\t\treturn\n\t}\n\n\tif a.daemon.VM == nil {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]byte(\"Virtual machine is not running\"))\n\t\treturn\n\t}\n\n\ta.daemon.VM.Started = false\n\ta.daemon.VM.Ready = false\n\ta.daemon.VM.Stop()\n\ta.daemon.VM = nil\n\n\tw.WriteHeader(http.StatusOK)\n\t// w.Write([]byte(\"Virtual machine shut down\"))\n}\n\nfunc (a *API) status(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tif a.daemon.VM == nil {\n\t\tuser, err := extractUser(r)\n\t\tif err != nil {\n\t\t\tw.WriteHeader(http.StatusUnauthorized)\n\t\t\tw.Write([]byte(\"\\\"message\\\": \\\"Unauthorized\\\"\"))\n\t\t\treturn\n\t\t}\n\n\t\tstatus, err := EmptyStatus(*user)\n\t\tif err != nil {\n\t\t\tstatusErr := VMStatusError{\n\t\t\t\tStatus:  \"error\",\n\t\t\t\tMessage: err.Error(),\n\t\t\t}\n\t\t\tjs, _ := json.Marshal(statusErr)\n\n\t\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\t\tw.Write(js)\n\t\t\treturn\n\t\t}\n\n\t\tjs, _ := json.Marshal(status)\n\n\t\tw.WriteHeader(http.StatusOK)\n\t\tw.Write(js)\n\t\treturn\n\t}\n\n\tstatus, err := a.daemon.VM.Status()\n\tif err != nil {\n\t\tstatusErr := VMStatusError{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: err.Error(),\n\t\t}\n\t\tjs, _ := json.Marshal(statusErr)\n\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write(js)\n\t\treturn\n\t}\n\n\tjs, err := json.Marshal(status)\n\tif err != nil {\n\t\tstatusErr := VMStatusError{\n\t\t\tStatus:  \"error\",\n\t\t\tMessage: err.Error(),\n\t\t}\n\t\tjs, _ := json.Marshal(statusErr)\n\n\t\tw.WriteHeader(http.StatusInternalServerError)\n\t\tw.Write(js)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tw.Write(js)\n}\n\nfunc (a *API) Listen() error {\n\taddr, err := net.ResolveTCPAddr(\"tcp\", \"0.0.0.0:1050\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\traw, err := net.ListenTCP(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlistener := &tcpListener{\n\t\tTCPListener: raw,\n\t\tdone:        a.done,\n\t}\n\n\tmux := http.NewServeMux()\n\tmux.HandleFunc(\"/start\", a.start)\n\tmux.HandleFunc(\"/started\", a.started)\n\tmux.HandleFunc(\"/stop\", a.stop)\n\tmux.HandleFunc(\"/status\", a.status)\n\tmux.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tw.WriteHeader(http.StatusNotFound)\n\t})\n\n\tloggedMux := newLoggedHandler(mux, os.Stdout)\n\tserver := &http.Server{\n\t\tHandler: loggedMux,\n\t}\n\n\treturn server.Serve(listener)\n}\n\nfunc (a *API) Stop() {\n\ta.done <- true\n}\n\nfunc NewAPI(daemon *Daemon) *API {\n\treturn &API{\n\t\tdaemon: daemon,\n\t\tdone:   make(chan bool),\n\t}\n}\n"
        },
        {
          "name": "assets",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd_cleanup.go",
          "type": "blob",
          "size": 1.009765625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar cleanupCommand = cli.Command{\n\tName:   \"cleanup\",\n\tHidden: true,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"hostname\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"home\",\n\t\t},\n\t},\n\tAction: func(ctx *cli.Context) error {\n\t\terr := ensureRoot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thostname := ctx.String(\"hostname\")\n\t\tif hostname == \"\" {\n\t\t\treturn cli.NewExitError(\"Must specify hostname\", 1)\n\t\t}\n\t\tdomain := getDomain(hostname)\n\n\t\thome := ctx.String(\"home\")\n\t\tif home == \"\" {\n\t\t\treturn cli.NewExitError(\"Must specify home\", 1)\n\t\t}\n\n\t\tif err := spin(fmt.Sprintf(\"Removing /etc/resolver/%s\", domain), func() error {\n\t\t\treturn os.Remove(fmt.Sprintf(\"/etc/resolver/%s\", domain))\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Modifying /etc/exports\", func() error {\n\t\t\treturn removeNFS(home)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\treturn spin(\"Removing /Library/LaunchDaemons/local.dlite.plist\", func() error {\n\t\t\treturn removeDaemon()\n\t\t})\n\t},\n}\n"
        },
        {
          "name": "cmd_daemon.go",
          "type": "blob",
          "size": 0.3720703125,
          "content": "package main\n\nimport (\n\t\"github.com/urfave/cli\"\n)\n\nvar daemonCommand = cli.Command{\n\tName:   \"daemon\",\n\tHidden: true,\n\tAction: func(ctx *cli.Context) error {\n\t\td := NewDaemon()\n\t\td.Start()\n\t\terrs := d.Wait()\n\t\tfor _, err := range errs {\n\t\t\tif err != nil && err.Error() != \"Shutting down privileged daemon\" {\n\t\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t\t}\n\t\t}\n\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "cmd_dlite.go",
          "type": "blob",
          "size": 0.4765625,
          "content": "package main\n\nimport (\n\t\"os\"\n\n\t\"github.com/urfave/cli\"\n)\n\nconst VERSION = \"2.0.0-beta9\"\n\nfunc main() {\n\tapp := cli.NewApp()\n\tapp.Version = VERSION\n\tapp.Usage = \"the easiest way to use docker on macOS\"\n\tapp.HideHelp = true\n\tapp.UsageText = \"dlite <command>\"\n\n\tapp.Commands = []cli.Command{\n\t\tdaemonCommand,\n\t\tsetupCommand,\n\t\tinitCommand,\n\t\tcleanupCommand,\n\t\tuninstallCommand,\n\t\tstartCommand,\n\t\tstopCommand,\n\t\tstatusCommand,\n\t\tipCommand,\n\t\tsshCommand,\n\t\tttyCommand,\n\t}\n\n\tapp.Run(os.Args)\n}\n"
        },
        {
          "name": "cmd_init.go",
          "type": "blob",
          "size": 3.037109375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/satori/go.uuid\"\n\t\"github.com/tsuru/config\"\n\t\"github.com/urfave/cli\"\n)\n\nvar initCommand = cli.Command{\n\tName:        \"init\",\n\tUsage:       \"initialize your dlite installation\",\n\tDescription: \"perform setup of dlite for the currently logged in user\",\n\tAction: func(ctx *cli.Context) error {\n\t\tcurrentUser := getUser()\n\t\tconfigPath := getPath(currentUser)\n\t\tbinPath := filepath.Join(configPath, \"bin\")\n\t\tconfigFile := filepath.Join(configPath, \"config.yaml\")\n\t\tdiskFile := filepath.Join(configPath, \"disk.qcow\")\n\t\tcfg := Config{}\n\n\t\terr := config.ReadConfigFile(configFile)\n\t\tif err == nil {\n\t\t\tfmt.Println(\"WARNING: It appears you have already initialized dlite. Continuing will destroy your current virtual machine and its configuration.\")\n\t\t\tif !confirm(\"Continue? (y/n)\") {\n\t\t\t\treturn cli.NewExitError(\"Aborting initialization...\", 1)\n\t\t\t}\n\t\t}\n\n\t\tfmt.Println(\"\")\n\n\t\terr = os.RemoveAll(configPath)\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\terr = os.MkdirAll(configPath, 0755)\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\tcfg.Id = uuid.NewV1().String()\n\n\t\tcfg.Hostname = askString(\"Virtual machine hostname\", \"local.docker\")\n\t\tcfg.Disk = askInt(\"Disk size (in gigabytes)\", 20)\n\t\tcfg.Cpu = askInt(\"CPU cores to allocate to VM\", 2)\n\t\tcfg.Memory = askInt(\"Memory to allocate to VM (in gigabytes)\", 2)\n\n\t\thost, _ := getHostAddress()\n\t\tcfg.DNS = askString(\"DNS server\", host)\n\t\tcfg.Docker = askString(\"Docker version\", \"latest\")\n\t\tcfg.Extra = ask(\"Extra flags to pass to the docker daemon\")\n\t\tcfg.Route = askBool(\"Allow direct connections to containers\", true)\n\n\t\tfmt.Println(\"\")\n\n\t\tif err := spin(\"Saving configuration\", func() error {\n\t\t\treturn writeConfig(configPath, cfg)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Creating ssh key pair\", func() error {\n\t\t\treturn generateKeys(currentUser)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Adding host to ssh config\", func() error {\n\t\t\treturn addSSHConfig(currentUser, cfg.Hostname)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Creating tool binaries\", func() error {\n\t\t\terr := os.MkdirAll(binPath, 0755)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tfor _, tool := range []string{\"com.docker.hyperkit\", \"qcow-tool\"} {\n\t\t\t\tbin, err := Asset(tool)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\terr = ioutil.WriteFile(filepath.Join(binPath, tool), bin, 0755)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Creating disk\", func() error {\n\t\t\treturn buildDisk(filepath.Join(binPath, \"qcow-tool\"), diskFile, cfg.Disk, currentUser.Uid, currentUser.Gid)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Downloading OS\", func() error {\n\t\t\treturn downloadOS(configPath)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println(\"\")\n\t\tfmt.Println(\"Next we'll run a few steps that require sudo, you may be prompted for your password.\")\n\t\treturn runSetup(cfg.Hostname, currentUser.Home)\n\t},\n}\n"
        },
        {
          "name": "cmd_ip.go",
          "type": "blob",
          "size": 0.4619140625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar ipCommand = cli.Command{\n\tName:        \"ip\",\n\tUsage:       \"display the virtual machine's IP\",\n\tDescription: \"lookup and print the IP address of the virtual machine\",\n\tAction: func(ctx *cli.Context) error {\n\t\tstatus, err := statusRequest()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif !status.Started {\n\t\t\treturn cli.NewExitError(\"Virtual machine not running\", 1)\n\t\t}\n\n\t\tfmt.Println(status.IP)\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "cmd_setup.go",
          "type": "blob",
          "size": 0.9765625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar setupCommand = cli.Command{\n\tName:   \"setup\",\n\tHidden: true,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName: \"hostname\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName: \"home\",\n\t\t},\n\t},\n\tAction: func(ctx *cli.Context) error {\n\t\terr := ensureRoot()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\thostname := ctx.String(\"hostname\")\n\t\tif hostname == \"\" {\n\t\t\treturn cli.NewExitError(\"Must specify hostname\", 1)\n\t\t}\n\t\tdomain := getDomain(hostname)\n\n\t\thome := ctx.String(\"home\")\n\t\tif home == \"\" {\n\t\t\treturn cli.NewExitError(\"Must specify home\", 1)\n\t\t}\n\n\t\tif err := spin(fmt.Sprintf(\"Creating /etc/resolver/%s\", domain), func() error {\n\t\t\treturn installResolver(hostname)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := spin(\"Modifying /etc/exports\", func() error {\n\t\t\treturn ensureNFS(home)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\treturn spin(\"Creating /Library/LaunchDaemons/local.dlite.plist\", func() error {\n\t\t\treturn installDaemon()\n\t\t})\n\t},\n}\n"
        },
        {
          "name": "cmd_ssh.go",
          "type": "blob",
          "size": 0.6923828125,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"syscall\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar sshCommand = cli.Command{\n\tName:        \"ssh\",\n\tUsage:       \"start an ssh session with your vm\",\n\tDescription: \"login to your virtual machine using ssh, this is a convenience shortcut\",\n\tAction: func(ctx *cli.Context) error {\n\t\tcurrentUser := getUser()\n\n\t\tcfg, err := readConfig(getPath(currentUser))\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\tbin, err := exec.LookPath(\"ssh\")\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\terr = syscall.Exec(bin, []string{\"ssh\", cfg.Hostname}, os.Environ())\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "cmd_start.go",
          "type": "blob",
          "size": 0.3603515625,
          "content": "package main\n\nimport (\n\t\"github.com/urfave/cli\"\n)\n\nvar startCommand = cli.Command{\n\tName:        \"start\",\n\tUsage:       \"start the virtual machine\",\n\tDescription: \"start the virtual machine, exits once booting is complete\",\n\tAction: func(ctx *cli.Context) error {\n\t\treturn spin(\"Starting the virtual machine\", func() error {\n\t\t\treturn stringRequest(\"start\")\n\t\t})\n\t},\n}\n"
        },
        {
          "name": "cmd_status.go",
          "type": "blob",
          "size": 1.037109375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar statusCommand = cli.Command{\n\tName:        \"status\",\n\tUsage:       \"print the virtual machine's status\",\n\tDescription: \"fetch and print the configuration and status of the virtual machine\",\n\tAction: func(ctx *cli.Context) error {\n\t\tstatus, err := statusRequest()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif status.Started {\n\t\t\tfmt.Println(\"vm_state:       started\")\n\t\t\tfmt.Printf(\"ip_address:     %s\\n\", status.IP)\n\t\t\tfmt.Printf(\"pid:            %d\\n\", status.Pid)\n\t\t} else {\n\t\t\tfmt.Println(\"vm_state:       stopped\")\n\t\t}\n\t\tfmt.Printf(\"id:             %s\\n\", status.Id)\n\t\tfmt.Printf(\"hostname:       %s\\n\", status.Hostname)\n\t\tfmt.Printf(\"disk_size:      %d\\n\", status.Disk)\n\t\tfmt.Printf(\"disk_path:      %s\\n\", status.DiskPath)\n\t\tfmt.Printf(\"cpu_cores:      %d\\n\", status.Cpu)\n\t\tfmt.Printf(\"memory:         %d\\n\", status.Memory)\n\t\tfmt.Printf(\"dns_server:     %s\\n\", status.DNS)\n\t\tfmt.Printf(\"docker_version: %s\\n\", status.Docker)\n\t\tfmt.Printf(\"docker_args:    %s\\n\", status.Extra)\n\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "cmd_stop.go",
          "type": "blob",
          "size": 0.357421875,
          "content": "package main\n\nimport (\n\t\"github.com/urfave/cli\"\n)\n\nvar stopCommand = cli.Command{\n\tName:        \"stop\",\n\tUsage:       \"stop the virtual machine\",\n\tDescription: \"stop the virtual machine, exits once the process has ended\",\n\tAction: func(ctx *cli.Context) error {\n\t\treturn spin(\"Stopping the virtual machine\", func() error {\n\t\t\treturn stringRequest(\"stop\")\n\t\t})\n\t},\n}\n"
        },
        {
          "name": "cmd_tty.go",
          "type": "blob",
          "size": 0.724609375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"syscall\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar ttyCommand = cli.Command{\n\tName:        \"tty\",\n\tUsage:       \"open a terminal to the virtual machine\",\n\tDescription: \"use screen to open a virtual terminal connected to the dlite vm, for most cases SSH is recommended but this can be useful for debugging\",\n\tAction: func(ctx *cli.Context) error {\n\t\tcurrentUser := getUser()\n\n\t\tttyPath := filepath.Join(getPath(currentUser), \"vm.tty\")\n\t\tbin, err := exec.LookPath(\"screen\")\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\terr = syscall.Exec(bin, []string{\"screen\", ttyPath}, os.Environ())\n\t\tif err != nil {\n\t\t\treturn cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\treturn nil\n\t},\n}\n"
        },
        {
          "name": "cmd_uninstall.go",
          "type": "blob",
          "size": 0.9560546875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli\"\n)\n\nvar uninstallCommand = cli.Command{\n\tName:        \"uninstall\",\n\tUsage:       \"completely remove dlite\",\n\tDescription: \"remove the user's virtual machine as well as the system service and reset all configuration changes\",\n\tAction: func(ctx *cli.Context) error {\n\t\tvar hostname string\n\t\tvar home string\n\n\t\tif err := spin(\"Removing virtual machine\", func() error {\n\t\t\tstringRequest(\"stop\")\n\n\t\t\tcurrentUser := getUser()\n\t\t\thome = currentUser.Home\n\n\t\t\tbasePath := getPath(currentUser)\n\t\t\tcfg, err := readConfig(basePath)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\thostname = cfg.Hostname\n\n\t\t\terr = removeSSHConfig(currentUser, hostname)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\treturn os.RemoveAll(basePath)\n\t\t}); err.ExitCode() != 0 {\n\t\t\treturn err\n\t\t}\n\n\t\tfmt.Println(\"\")\n\t\tfmt.Println(\"Next we'll run a few steps that require sudo, you may be prompted for your password.\")\n\t\treturn runCleanup(hostname, home)\n\t},\n}\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 1.7958984375,
          "content": "package main\n\nimport (\n\t\"path/filepath\"\n\n\t\"github.com/tsuru/config\"\n)\n\ntype Config struct {\n\tId       string `json:\"id\"`\n\tHostname string `json:\"hostname\"`\n\tDisk     int    `json:\"disk_size\"`\n\tDiskPath string `json:\"disk_path\"`\n\tCpu      int    `json:\"cpu_cores\"`\n\tMemory   int    `json:\"memory\"`\n\tDNS      string `json:\"dns_server\"`\n\tDocker   string `json:\"docker_version\"`\n\tExtra    string `json:\"docker_args\"`\n\tRoute    bool   `json:\"route\"`\n}\n\nfunc readConfig(path string) (Config, error) {\n\tcfg := Config{}\n\tconfigFile := filepath.Join(path, \"config.yaml\")\n\n\terr := config.ReadConfigFile(configFile)\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Id, err = config.GetString(\"id\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Hostname, err = config.GetString(\"hostname\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.DiskPath = filepath.Join(path, \"disk.qcow\")\n\tcfg.Disk, err = config.GetInt(\"disk\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Cpu, err = config.GetInt(\"cpu\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Memory, err = config.GetInt(\"memory\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.DNS, err = config.GetString(\"dns\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Docker, err = config.GetString(\"docker\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Extra, err = config.GetString(\"extra\")\n\tif err != nil {\n\t\treturn cfg, err\n\t}\n\n\tcfg.Route, err = config.GetBool(\"route\")\n\treturn cfg, err\n}\n\nfunc writeConfig(path string, cfg Config) error {\n\tconfigFile := filepath.Join(path, \"config.yaml\")\n\n\tconfig.Set(\"id\", cfg.Id)\n\tconfig.Set(\"hostname\", cfg.Hostname)\n\tconfig.Set(\"disk\", cfg.Disk)\n\tconfig.Set(\"cpu\", cfg.Cpu)\n\tconfig.Set(\"memory\", cfg.Memory)\n\tconfig.Set(\"dns\", cfg.DNS)\n\tconfig.Set(\"docker\", cfg.Docker)\n\tconfig.Set(\"extra\", cfg.Extra)\n\tconfig.Set(\"route\", cfg.Route)\n\n\treturn config.WriteConfigFile(configFile, 0644)\n}\n"
        },
        {
          "name": "daemon.go",
          "type": "blob",
          "size": 2.146484375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/kardianos/osext\"\n)\n\ntype Daemon struct {\n\tProxy *Proxy\n\tAPI   *API\n\tVM    *VM\n\tDNS   *DNS\n\tError chan error\n}\n\nfunc (d *Daemon) Start() {\n\tshutdown := make(chan os.Signal, 1)\n\tsignal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM, syscall.SIGKILL)\n\tgo func() {\n\t\t<-shutdown\n\t\td.Shutdown()\n\t}()\n\n\tgo func() {\n\t\terr := d.Proxy.Listen()\n\t\tif err != nil {\n\t\t\tif err.Error() != \"Server closed\" {\n\t\t\t\td.Error <- err\n\t\t\t\td.Shutdown()\n\t\t\t} else {\n\t\t\t\td.Error <- nil\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\terr := d.API.Listen()\n\t\tif err != nil {\n\t\t\tif err.Error() != \"Server closed\" {\n\t\t\t\td.Error <- err\n\t\t\t\td.Shutdown()\n\t\t\t} else {\n\t\t\t\td.Error <- nil\n\t\t\t}\n\t\t}\n\t}()\n\n\tgo func() {\n\t\terr := d.DNS.Start()\n\t\tif err != nil {\n\t\t\td.Shutdown()\n\t\t}\n\t}()\n}\n\nfunc (d *Daemon) Shutdown() {\n\tif d.VM != nil {\n\t\td.VM.Stop()\n\t}\n\td.Proxy.Stop()\n\td.API.Stop()\n\td.DNS.Stop()\n\td.Error <- fmt.Errorf(\"Shutting down privileged daemon\")\n}\n\nfunc (d *Daemon) Wait() []error {\n\terr1 := <-d.Error\n\terr2 := <-d.Error\n\treturn []error{err1, err2}\n}\n\nfunc NewDaemon() *Daemon {\n\tdaemon := &Daemon{}\n\tproxy := NewProxy(daemon)\n\tapi := NewAPI(daemon)\n\tdns := NewDNS(daemon)\n\n\tdaemon.Proxy = proxy\n\tdaemon.API = api\n\tdaemon.DNS = dns\n\tdaemon.Error = make(chan error, 2)\n\treturn daemon\n}\n\nconst template = `\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">\n  <dict>\n\t  <key>Label</key>\n\t\t<string>local.dlite</string>\n\t\t<key>ProgramArguments</key>\n\t\t<array>\n\t\t  <string>%s</string>\n\t\t\t<string>daemon</string>\n\t\t</array>\n\t\t<key>RunAtLoad</key>\n\t\t<true/>\n  </dict>\n</plist>\n`\n\nconst plistPath = \"/Library/LaunchDaemons/local.dlite.plist\"\n\nfunc installDaemon() error {\n\texe, err := osext.Executable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tplist := fmt.Sprintf(template, exe)\n\terr = ioutil.WriteFile(plistPath, []byte(plist), 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn exec.Command(\"launchctl\", \"load\", plistPath).Run()\n}\n\nfunc removeDaemon() error {\n\texec.Command(\"lauunchctl\", \"unload\", plistPath).Run()\n\treturn os.Remove(plistPath)\n}\n"
        },
        {
          "name": "disk.go",
          "type": "blob",
          "size": 0.185546875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os/exec\"\n)\n\nfunc buildDisk(bin, path string, size, uid, gid int) error {\n\treturn exec.Command(bin, \"create\", fmt.Sprintf(\"--size=%dGiB\", size), path).Run()\n}\n"
        },
        {
          "name": "dns.go",
          "type": "blob",
          "size": 2.2890625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/miekg/dns\"\n)\n\ntype DNS struct {\n\tdaemon *Daemon\n\tserver *dns.Server\n}\n\nfunc (d *DNS) handleRequest(w dns.ResponseWriter, r *dns.Msg) {\n\tmsg := &dns.Msg{}\n\tmsg.SetReply(r)\n\n\tif d.daemon.VM == nil {\n\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\tw.WriteMsg(msg)\n\t\treturn\n\t}\n\n\tuserPath := getPath(*d.daemon.VM.Owner)\n\tcfg, err := readConfig(userPath)\n\tif err != nil {\n\t\tmsg.SetRcode(r, dns.RcodeServerFailure)\n\t\tw.WriteMsg(msg)\n\t\treturn\n\t}\n\n\thostname := fmt.Sprintf(\"%s.\", cfg.Hostname)\n\tdomain := fmt.Sprintf(\"%s.\", getDomain(cfg.Hostname))\n\n\tq := r.Question[0]\n\tif q.Qtype != dns.TypeA {\n\t\tmsg.SetRcode(r, dns.RcodeNotImplemented)\n\t} else {\n\t\tif !strings.HasSuffix(q.Name, domain) {\n\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t\tw.WriteMsg(msg)\n\t\t\treturn\n\t\t}\n\n\t\tif q.Name == hostname {\n\t\t\tip, err := d.daemon.VM.IP()\n\t\t\tif err != nil {\n\t\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t\t\tw.WriteMsg(msg)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trecord := &dns.A{\n\t\t\t\tHdr: dns.RR_Header{\n\t\t\t\t\tName:   q.Name,\n\t\t\t\t\tRrtype: dns.TypeA,\n\t\t\t\t\tClass:  dns.ClassINET,\n\t\t\t\t\tTtl:    0,\n\t\t\t\t},\n\t\t\t\tA: net.ParseIP(ip).To4(),\n\t\t\t}\n\n\t\t\tmsg.Answer = append(msg.Answer, record)\n\t\t} else if cfg.Route {\n\t\t\tcleaned := strings.TrimSuffix(q.Name, fmt.Sprintf(\".%s\", domain))\n\t\t\tip, err := d.daemon.VM.findContainer(cleaned)\n\t\t\tif err != nil {\n\t\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t\t\tw.WriteMsg(msg)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\trecord := &dns.A{\n\t\t\t\tHdr: dns.RR_Header{\n\t\t\t\t\tName:   q.Name,\n\t\t\t\t\tRrtype: dns.TypeA,\n\t\t\t\t\tClass:  dns.ClassINET,\n\t\t\t\t\tTtl:    0,\n\t\t\t\t},\n\t\t\t\tA: net.ParseIP(ip).To4(),\n\t\t\t}\n\n\t\t\tmsg.Answer = append(msg.Answer, record)\n\t\t} else {\n\t\t\tmsg.SetRcode(r, dns.RcodeNameError)\n\t\t}\n\t}\n\n\tw.WriteMsg(msg)\n}\n\nfunc (d *DNS) Start() error {\n\tdns.HandleFunc(\".\", d.handleRequest)\n\td.server = &dns.Server{\n\t\tAddr: \":1053\",\n\t\tNet:  \"udp\",\n\t}\n\n\treturn d.server.ListenAndServe()\n}\n\nfunc (d *DNS) Stop() error {\n\treturn d.server.Shutdown()\n}\n\nfunc NewDNS(daemon *Daemon) *DNS {\n\treturn &DNS{\n\t\tdaemon: daemon,\n\t}\n}\n\nfunc installResolver(hostname string) error {\n\terr := os.MkdirAll(\"/etc/resolver\", 0755)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdomain := getDomain(hostname)\n\tfile := fmt.Sprintf(\"/etc/resolver/%s\", domain)\n\tresolver := \"nameserver 127.0.0.1\\nport 1053\"\n\treturn ioutil.WriteFile(file, []byte(resolver), 0644)\n}\n"
        },
        {
          "name": "gen_assets.go",
          "type": "blob",
          "size": 0.2890625,
          "content": "package main\n\n// build hyperkit\n//go:generate make -C hyperkit\n\n// copy binary assets\n//go:generate sh -c \"cp `which qcow-tool` assets/\"\n//go:generate cp hyperkit/build/com.docker.hyperkit assets/\n\n// generate bundled assets\n//go:generate go-bindata -pkg main -o assets.go -prefix assets assets/\n"
        },
        {
          "name": "helpers.go",
          "type": "blob",
          "size": 3.9052734375,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/user\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"syscall\"\n\n\t\"github.com/kardianos/osext\"\n\t\"github.com/urfave/cli\"\n)\n\ntype User struct {\n\tName string\n\tHome string\n\tUid  int\n\tGid  int\n}\n\nfunc lookupUser(username string) (*User, error) {\n\trawUser, err := user.Lookup(username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuid, err := strconv.Atoi(rawUser.Uid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tgid, err := strconv.Atoi(rawUser.Gid)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &User{\n\t\tName: rawUser.Username,\n\t\tHome: rawUser.HomeDir,\n\t\tUid:  uid,\n\t\tGid:  gid,\n\t}, nil\n}\n\nfunc getUser() User {\n\tcurrentUser, err := user.Current()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tuid, err := strconv.Atoi(currentUser.Uid)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tgid, err := strconv.Atoi(currentUser.Gid)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\treturn User{\n\t\tName: currentUser.Username,\n\t\tHome: currentUser.HomeDir,\n\t\tUid:  uid,\n\t\tGid:  gid,\n\t}\n}\n\nfunc getPath(user User) string {\n\treturn filepath.Join(user.Home, \".dlite\")\n}\n\nfunc getRequestError(err error) string {\n\turlError, ok := err.(*url.Error)\n\tif ok {\n\t\tnetError, ok := urlError.Err.(*net.OpError)\n\t\tif ok {\n\t\t\tsysError, ok := netError.Err.(*os.SyscallError)\n\t\t\tif ok {\n\t\t\t\tif sysError.Err == syscall.ECONNREFUSED {\n\t\t\t\t\treturn \"Connection refused - is the dlite daemon running?\"\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif netError.Timeout() {\n\t\t\t\treturn \"Request timed out, please try again\"\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err.Error()\n}\n\nfunc statusRequest() (*VMStatus, *cli.ExitError) {\n\tuser := getUser()\n\treq, err := http.NewRequest(\"GET\", \"http://127.0.0.1:1050/status\", nil)\n\tif err != nil {\n\t\treturn nil, cli.NewExitError(err.Error(), 1)\n\t}\n\n\treq.Header.Add(\"X-Username\", user.Name)\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn nil, cli.NewExitError(getRequestError(err), 1)\n\t}\n\n\tdefer res.Body.Close()\n\tdecoder := json.NewDecoder(res.Body)\n\tif res.StatusCode < 200 || res.StatusCode >= 400 {\n\t\tstatus := VMStatusError{}\n\t\terr := decoder.Decode(&status)\n\t\tif err != nil {\n\t\t\treturn nil, cli.NewExitError(err.Error(), 1)\n\t\t}\n\n\t\treturn nil, cli.NewExitError(status.Message, 1)\n\t}\n\n\tstatus := VMStatus{}\n\terr = decoder.Decode(&status)\n\tif err != nil {\n\t\treturn nil, cli.NewExitError(err.Error(), 1)\n\t}\n\n\treturn &status, nil\n}\n\nfunc stringRequest(action string) *cli.ExitError {\n\tuser := getUser()\n\treq, err := http.NewRequest(\"POST\", fmt.Sprintf(\"http://127.0.0.1:1050/%s\", action), nil)\n\tif err != nil {\n\t\treturn cli.NewExitError(err.Error(), 1)\n\t}\n\n\treq.Header.Add(\"X-Username\", user.Name)\n\tclient := &http.Client{}\n\tres, err := client.Do(req)\n\tif err != nil {\n\t\treturn cli.NewExitError(err.Error(), 1)\n\t}\n\n\tdefer res.Body.Close()\n\tbody, err := ioutil.ReadAll(res.Body)\n\tif err != nil {\n\t\treturn cli.NewExitError(err.Error(), 1)\n\t}\n\n\tcode := 0\n\tif res.StatusCode < 200 || res.StatusCode >= 400 {\n\t\tcode = 1\n\t}\n\n\treturn cli.NewExitError(string(body), code)\n}\n\nfunc runSetup(hostname, home string) *cli.ExitError {\n\texe, err := osext.Executable()\n\tif err != nil {\n\t\treturn cli.NewExitError(err.Error(), 1)\n\t}\n\n\toutput, err := exec.Command(\"sudo\", exe, \"setup\", \"--hostname\", hostname, \"--home\", home).Output()\n\tcode := 0\n\tif err != nil {\n\t\tcode = 1\n\t}\n\treturn cli.NewExitError(string(output), code)\n}\n\nfunc runCleanup(hostname, home string) *cli.ExitError {\n\texe, err := osext.Executable()\n\tif err != nil {\n\t\treturn cli.NewExitError(err.Error(), 1)\n\t}\n\n\toutput, err := exec.Command(\"sudo\", exe, \"cleanup\", \"--hostname\", hostname, \"--home\", home).Output()\n\tcode := 0\n\tif err != nil {\n\t\tcode = 1\n\t}\n\treturn cli.NewExitError(string(output), code)\n}\n\nfunc ensureRoot() *cli.ExitError {\n\tif uid := os.Geteuid(); uid != 0 {\n\t\treturn cli.NewExitError(\"This command requires sudo\", 1)\n\t}\n\n\tif uid := os.Getenv(\"SUDO_UID\"); uid == \"\" {\n\t\treturn cli.NewExitError(\"This command requires sudo\", 1)\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "http_logger.go",
          "type": "blob",
          "size": 1.16796875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"strings\"\n\t\"time\"\n)\n\ntype LoggedRequest struct {\n\thttp.ResponseWriter\n\n\treq    *http.Request\n\toutput io.Writer\n\tcode   int\n\tstart  time.Time\n\tfinish time.Time\n}\n\nfunc (l *LoggedRequest) WriteHeader(code int) {\n\tl.code = code\n\tl.ResponseWriter.WriteHeader(code)\n}\n\nfunc (l *LoggedRequest) printLog() {\n\tip := l.req.RemoteAddr\n\tif colon := strings.LastIndex(ip, \":\"); colon > -1 {\n\t\tip = ip[:colon]\n\t}\n\n\telapsed := l.finish.Sub(l.start).Nanoseconds() / 1000\n\tfinish := l.finish.Format(\"010206.150405\")\n\tfmt.Fprintf(l.output, \"%s %s %s %s [%d] %dms\\n\", ip, finish, l.req.Method, l.req.RequestURI, l.code, elapsed)\n}\n\ntype LoggingHandler struct {\n\thandler http.Handler\n\toutput  io.Writer\n}\n\nfunc (h *LoggingHandler) ServeHTTP(rw http.ResponseWriter, r *http.Request) {\n\tentry := &LoggedRequest{\n\t\tResponseWriter: rw,\n\t\toutput:         h.output,\n\t\treq:            r,\n\t\tstart:          time.Now(),\n\t}\n\n\tentry.start = time.Now()\n\th.handler.ServeHTTP(entry, r)\n\tentry.finish = time.Now()\n\tentry.printLog()\n}\n\nfunc newLoggedHandler(handler http.Handler, output io.Writer) http.Handler {\n\treturn &LoggingHandler{\n\t\thandler: handler,\n\t\toutput:  output,\n\t}\n}\n"
        },
        {
          "name": "hyperkit",
          "type": "commit",
          "content": null
        },
        {
          "name": "listeners.go",
          "type": "blob",
          "size": 1.060546875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n)\n\ntype tcpListener struct {\n\t*net.TCPListener\n\tdone chan bool\n}\n\nfunc (l *tcpListener) Accept() (net.Conn, error) {\n\tfor {\n\t\tl.SetDeadline(time.Now().Add(time.Second))\n\t\tselect {\n\t\tcase <-l.done:\n\t\t\treturn nil, fmt.Errorf(\"Server closed\")\n\t\tdefault:\n\t\t}\n\n\t\tnewConn, err := l.TCPListener.Accept()\n\t\tif err != nil {\n\t\t\tnetErr, ok := err.(net.Error)\n\t\t\tif ok && netErr.Timeout() && netErr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\treturn newConn, err\n\t}\n}\n\nfunc (l *tcpListener) Close() error {\n\tclose(l.done)\n\treturn nil\n}\n\ntype unixListener struct {\n\t*net.UnixListener\n\tdone chan bool\n}\n\nfunc (s *unixListener) Accept() (net.Conn, error) {\n\tfor {\n\t\ts.SetDeadline(time.Now().Add(time.Second))\n\t\tselect {\n\t\tcase <-s.done:\n\t\t\treturn nil, fmt.Errorf(\"Server closed\")\n\t\tdefault:\n\t\t}\n\n\t\tnewConn, err := s.UnixListener.Accept()\n\t\tif err != nil {\n\t\t\tnetErr, ok := err.(net.Error)\n\t\t\tif ok && netErr.Timeout() && netErr.Temporary() {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t}\n\n\t\treturn newConn, err\n\t}\n}\n\nfunc (s *unixListener) Close() error {\n\tclose(s.done)\n\treturn nil\n}\n"
        },
        {
          "name": "net.go",
          "type": "blob",
          "size": 1.0166015625,
          "content": "package main\n\nimport (\n\t\"net\"\n\t\"os/exec\"\n\t\"strings\"\n)\n\nfunc getNetAddress() (string, error) {\n\trawAddr, _ := getHostAddress()\n\taddr := net.ParseIP(rawAddr)\n\n\trawMask, _ := getNetMask()\n\tmask := net.IPMask(net.ParseIP(rawMask).To4())\n\n\treturn addr.Mask(mask).String(), nil\n}\n\nfunc getHostAddress() (string, error) {\n\taddr, err := exec.Command(\"defaults\", \"read\", \"/Library/Preferences/SystemConfiguration/com.apple.vmnet.plist\", \"Shared_Net_Address\").Output()\n\tif err != nil {\n\t\treturn \"192.168.64.1\", err\n\t}\n\n\treturn strings.TrimSpace(string(addr)), nil\n}\n\nfunc getNetMask() (string, error) {\n\tmask, err := exec.Command(\"defaults\", \"read\", \"/Library/Preferences/SystemConfiguration/com.apple.vmnet.plist\", \"Shared_Net_Mask\").Output()\n\tif err != nil {\n\t\treturn \"255.255.255.0\", err\n\t}\n\n\treturn strings.TrimSpace(string(mask)), nil\n}\n\nfunc getDomain(hostname string) string {\n\tvar domain string\n\n\tlastDot := strings.LastIndex(hostname, \".\")\n\tif lastDot > -1 {\n\t\tdomain = hostname[lastDot+1:]\n\t} else {\n\t\tdomain = hostname\n\t}\n\n\treturn domain\n}\n"
        },
        {
          "name": "nfs.go",
          "type": "blob",
          "size": 2.3828125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nfunc ensureNFS(home string) error {\n\taddr, err := getNetAddress()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmask, _ := getNetMask()\n\texport := fmt.Sprintf(\"%s -network %s -mask %s -alldirs -maproot=root:wheel\", home, addr, mask)\n\n\tif _, err = os.Stat(\"/etc/exports\"); os.IsNotExist(err) {\n\t\terr := ioutil.WriteFile(\"/etc/exports\", []byte(\"\"), 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\trawExports, err := ioutil.ReadFile(\"/etc/exports\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tneedsExport := true\n\tfor _, line := range strings.Split(string(rawExports), \"\\n\") {\n\t\tif strings.HasPrefix(line, export) {\n\t\t\tneedsExport = false\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif needsExport {\n\t\tfile, err := os.OpenFile(\"/etc/exports\", os.O_APPEND|os.O_WRONLY, 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tdefer file.Close()\n\n\t\t_, err = file.WriteString(export + \"\\n\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\toutput, err := exec.Command(\"nfsd\", \"checkexports\").Output()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"There was a problem updating the /etc/exports file, please resolve the issue and run 'sudo nfsd restart'\\n%s\", string(output))\n\t}\n\n\toutput, _ = exec.Command(\"nfsd\", \"status\").Output()\n\tenabled := false\n\trunning := false\n\tfor _, line := range strings.Split(string(output), \"\\n\") {\n\t\tif strings.Contains(line, \"is enabled\") {\n\t\t\tenabled = true\n\t\t} else if strings.Contains(line, \"is running\") {\n\t\t\trunning = true\n\t\t}\n\t}\n\n\tif !enabled {\n\t\toutput, err = exec.Command(\"nfsd\", \"enable\").Output()\n\t} else if !running {\n\t\toutput, err = exec.Command(\"nfsd\", \"start\").Output()\n\t} else {\n\t\toutput, err = exec.Command(\"nfsd\", \"restart\").Output()\n\t}\n\n\tif err != nil {\n\t\treturn fmt.Errorf(string(output))\n\t}\n\treturn nil\n}\n\nfunc removeNFS(home string) error {\n\taddr, err := getNetAddress()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmask, _ := getNetMask()\n\texport := fmt.Sprintf(\"%s -network %s -mask %s -alldirs -maproot=root:wheel\", home, addr, mask)\n\n\trawExports, err := ioutil.ReadFile(\"/etc/exports\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\texportMatcher := regexp.MustCompile(fmt.Sprintf(\"(?m)^%s\\n?$\", export))\n\tnewExports := exportMatcher.ReplaceAllString(string(rawExports), \"\")\n\n\terr = ioutil.WriteFile(\"/etc/exports\", []byte(newExports), 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toutput, err := exec.Command(\"nfsd\", \"restart\").Output()\n\tif err != nil {\n\t\treturn fmt.Errorf(string(output))\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "os.go",
          "type": "blob",
          "size": 1.931640625,
          "content": "package main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"path\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/blang/semver\"\n)\n\nvar allowedRange = semver.MustParseRange(\">=1.0.0-beta0\")\n\ntype File struct {\n\tName string `json:\"name\"`\n\tUrl  string `json:\"browser_download_url\"`\n}\n\ntype Release struct {\n\tVersion semver.Version\n\tTag     string `json:\"tag_name\"`\n\tFiles   []File `json:\"assets\"`\n}\ntype Releases []Release\n\nfunc (rs Releases) Len() int {\n\treturn len(rs)\n}\n\nfunc (rs Releases) Less(i, j int) bool {\n\treturn rs[i].Version.LT(rs[j].Version)\n}\n\nfunc (rs Releases) Swap(i, j int) {\n\trs[i], rs[j] = rs[j], rs[i]\n}\n\nfunc getOSReleases() (Releases, error) {\n\tres, err := http.Get(\"https://api.github.com/repos/nlf/dlite-os/releases\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdefer res.Body.Close()\n\treleases := Releases{}\n\tdecoder := json.NewDecoder(res.Body)\n\terr = decoder.Decode(&releases)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tallowedReleases := Releases{}\n\tfor _, release := range releases {\n\t\trelease.Version = semver.MustParse(strings.TrimPrefix(release.Tag, \"v\"))\n\t\tif allowedRange(release.Version) {\n\t\t\tallowedReleases = append(allowedReleases, release)\n\t\t}\n\t}\n\n\tsort.Sort(allowedReleases)\n\treturn allowedReleases, nil\n}\n\nfunc getLatestOSRelease() (Release, error) {\n\treleases, err := getOSReleases()\n\tif err != nil {\n\t\treturn Release{}, err\n\t}\n\n\treturn releases[len(releases)-1], nil\n}\n\nfunc downloadOS(target string) error {\n\tlatest, err := getLatestOSRelease()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tfor _, file := range latest.Files {\n\t\ttempPath := path.Join(target, file.Name)\n\t\toutput, err := os.Create(tempPath)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tres, err := http.Get(file.Url)\n\t\tdefer res.Body.Close()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tlength, err := strconv.ParseInt(res.Header.Get(\"Content-Length\"), 10, 64)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t_, err = io.CopyN(output, res.Body, length)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "proxy.go",
          "type": "blob",
          "size": 2.40234375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype Proxy struct {\n\tdone   chan bool\n\tdaemon *Daemon\n}\n\nfunc (p *Proxy) cleanup() error {\n\t_, err := os.Stat(\"/var/run/docker.sock\")\n\tif err == nil {\n\t\terr = os.Remove(\"/var/run/docker.sock\")\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (p *Proxy) proxy(w http.ResponseWriter, r *http.Request) {\n\tif p.daemon.VM == nil {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\tw.Write([]byte(\"The virtual machine has not been started\"))\n\t\treturn\n\t}\n\n\taddr, err := p.daemon.VM.Address()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\tw.Write([]byte(\"Unable to locate the virtual machine\"))\n\t\treturn\n\t}\n\n\tbackend, err := net.DialTCP(\"tcp\", nil, addr)\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\tw.Write([]byte(\"Unable to connect to the virtual machine\"))\n\t\treturn\n\t}\n\tdefer backend.Close()\n\n\tr.URL.Scheme = \"http\"\n\tr.URL.Host = fmt.Sprintf(\"%s:%d\", addr.IP.String(), addr.Port)\n\n\thijacker, ok := w.(http.Hijacker)\n\tif !ok {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\tw.Write([]byte(\"Unable to create hijacker\"))\n\t\treturn\n\t}\n\n\tconn, _, err := hijacker.Hijack()\n\tif err != nil {\n\t\tw.WriteHeader(http.StatusServiceUnavailable)\n\t\tw.Write([]byte(\"Unable to hijack connection\"))\n\t\treturn\n\t}\n\n\tr.Write(backend)\n\tfinished := make(chan error, 1)\n\n\tgo func(backend *net.TCPConn, conn net.Conn, finished chan error) {\n\t\tbuf := make([]byte, 8092)\n\t\t_, err := io.CopyBuffer(backend, conn, buf)\n\t\tbackend.CloseWrite()\n\t\tfinished <- err\n\t}(backend, conn, finished)\n\n\tgo func(backend *net.TCPConn, conn net.Conn, finished chan error) {\n\t\tbuf := make([]byte, 8092)\n\t\t_, err := io.CopyBuffer(conn, backend, buf)\n\t\tconn.Close()\n\t\tfinished <- err\n\t}(backend, conn, finished)\n\n\t<-finished\n\t<-finished\n}\n\nfunc (p *Proxy) Listen() error {\n\terr := p.cleanup()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\taddr, err := net.ResolveUnixAddr(\"unix\", \"/var/run/docker.sock\")\n\tif err != nil {\n\t\treturn err\n\t}\n\n\traw, err := net.ListenUnix(\"unix\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlistener := &unixListener{\n\t\tUnixListener: raw,\n\t\tdone:         p.done,\n\t}\n\n\terr = os.Chmod(\"/var/run/docker.sock\", 0777)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tserver := http.Server{\n\t\tHandler: http.HandlerFunc(p.proxy),\n\t}\n\n\treturn server.Serve(listener)\n}\n\nfunc (p *Proxy) Stop() {\n\tp.done <- true\n\tp.cleanup()\n}\n\nfunc NewProxy(daemon *Daemon) *Proxy {\n\treturn &Proxy{\n\t\tdaemon: daemon,\n\t\tdone:   make(chan bool),\n\t}\n}\n"
        },
        {
          "name": "ssh.go",
          "type": "blob",
          "size": 1.5224609375,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n)\n\nfunc generateKeys(user User) error {\n\tbase := getPath(user)\n\toutput, err := exec.Command(\"ssh-keygen\", \"-f\", fmt.Sprintf(\"%s/key\", base), \"-P\", \"\").CombinedOutput()\n\tif err != nil {\n\t\treturn fmt.Errorf(string(output))\n\t}\n\n\treturn nil\n}\n\nfunc addSSHConfig(user User, hostname string) error {\n\tconfigPath := filepath.Join(user.Home, \".ssh\", \"config\")\n\tif _, err := os.Stat(configPath); os.IsNotExist(err) {\n\t\terr := ioutil.WriteFile(configPath, []byte(\"\"), 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tconfig, err := ioutil.ReadFile(configPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\thasHost := strings.Index(string(config), fmt.Sprintf(\"Host %s\", hostname))\n\tif hasHost != -1 {\n\t\treturn nil\n\t}\n\n\tkeyfile := filepath.Join(getPath(user), \"key\")\n\tnewConfig := string(config)\n\tnewConfig += fmt.Sprintf(\"Host %s\\n  User docker\\n  IdentityFile %s\", hostname, keyfile)\n\treturn ioutil.WriteFile(configPath, []byte(newConfig), 0644)\n}\n\nfunc removeSSHConfig(user User, hostname string) error {\n\tconfigPath := filepath.Join(user.Home, \".ssh\", \"config\")\n\tconfig, err := ioutil.ReadFile(configPath)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkeyfile := filepath.Join(getPath(user), \"key\")\n\thostConfig := fmt.Sprintf(\"Host %s\\n  User docker\\n  IdentityFile %s\", hostname, keyfile)\n\n\thostMatcher := regexp.MustCompile(fmt.Sprintf(\"(?m)^%s?$\", hostConfig))\n\tnewConfig := hostMatcher.ReplaceAllString(string(config), \"\")\n\n\treturn ioutil.WriteFile(configPath, []byte(newConfig), 0644)\n}\n"
        },
        {
          "name": "tar.go",
          "type": "blob",
          "size": 4.25390625,
          "content": "package main\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc generateTarball(user User) ([]byte, error) {\n\tbasePath := getPath(user)\n\tcfg, err := readConfig(basePath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tbuf := &bytes.Buffer{}\n\tgz := gzip.NewWriter(buf)\n\ttarball := tar.NewWriter(gz)\n\n\thostname := []byte(cfg.Hostname)\n\thostnameHeader := &tar.Header{\n\t\tName: \"/etc/hostname\",\n\t\tMode: 0644,\n\t\tSize: int64(len(hostname)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(hostnameHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(hostname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thosts := []byte(fmt.Sprintf(\"127.0.0.1 localhost %s\", cfg.Hostname))\n\thostsHeader := &tar.Header{\n\t\tName: \"/etc/hosts\",\n\t\tMode: 0644,\n\t\tSize: int64(len(hosts)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(hostsHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(hosts)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tifaces := []byte(fmt.Sprintf(\"auto lo\\niface lo inet loopback\\n\\nauto eth0\\niface eth0 inet dhcp\\nhostname %s\", cfg.Id))\n\tifacesHeader := &tar.Header{\n\t\tName: \"/etc/network/interfaces\",\n\t\tMode: 0644,\n\t\tSize: int64(len(ifaces)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(ifacesHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(ifaces)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdns := []byte(fmt.Sprintf(\"nameserver %s\", cfg.DNS))\n\tdnsHeader := &tar.Header{\n\t\tName: \"/etc/resolv.conf\",\n\t\tMode: 0644,\n\t\tSize: int64(len(dns)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(dnsHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(dns)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\thostIp, _ := getHostAddress()\n\thostIpBytes := []byte(hostIp)\n\thostIpHeader := &tar.Header{\n\t\tName: \"/etc/dlite/host_ip\",\n\t\tMode: 0600,\n\t\tSize: int64(len(hostIpBytes)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(hostIpHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(hostIpBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tusername := []byte(user.Name)\n\tusernameHeader := &tar.Header{\n\t\tName: \"/etc/dlite/username\",\n\t\tMode: 0600,\n\t\tSize: int64(len(username)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(usernameHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(username)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tuserId := []byte(fmt.Sprintf(\"%d\", user.Uid))\n\tuserIdHeader := &tar.Header{\n\t\tName: \"/etc/dlite/userid\",\n\t\tMode: 0600,\n\t\tSize: int64(len(userId)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(userIdHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(userId)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdockerVersion := []byte(cfg.Docker)\n\tdockerVersionHeader := &tar.Header{\n\t\tName: \"/etc/dlite/docker_version\",\n\t\tMode: 0600,\n\t\tSize: int64(len(dockerVersion)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(dockerVersionHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(dockerVersion)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdockerArgs := []byte(cfg.Extra)\n\tdockerArgsHeader := &tar.Header{\n\t\tName: \"/etc/dlite/docker_args\",\n\t\tMode: 0600,\n\t\tSize: int64(len(dockerArgs)),\n\t\tUid:  0,\n\t\tGid:  10,\n\t}\n\n\terr = tarball.WriteHeader(dockerArgsHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = tarball.Write(dockerArgs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsshDirHeader := &tar.Header{\n\t\tName:     \"/home/docker/.ssh\",\n\t\tMode:     0700,\n\t\tTypeflag: tar.TypeDir,\n\t\tUid:      1000,\n\t\tGid:      1000,\n\t}\n\n\terr = tarball.WriteHeader(sshDirHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeyFile, err := os.Open(filepath.Join(basePath, \"key.pub\"))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeyStat, err := keyFile.Stat()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkeysHeader := &tar.Header{\n\t\tName: \"/home/docker/.ssh/authorized_keys\",\n\t\tMode: 0600,\n\t\tSize: keyStat.Size(),\n\t\tUid:  1000,\n\t\tGid:  1000,\n\t}\n\n\terr = tarball.WriteHeader(keysHeader)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t_, err = io.Copy(tarball, keyFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ttarball.Close()\n\tgz.Close()\n\n\treturn buf.Bytes(), nil\n}\n\nfunc GetBootstrapData(user User) (string, error) {\n\ttarball, err := generateTarball(user)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn base64.StdEncoding.EncodeToString(tarball), nil\n}\n"
        },
        {
          "name": "ui.go",
          "type": "blob",
          "size": 1.78125,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/briandowns/spinner\"\n\t\"github.com/urfave/cli\"\n)\n\nfunc ask(question string) string {\n\tvar answer string\n\tfmt.Printf(\"%s: \", question)\n\tfmt.Scanln(&answer)\n\treturn answer\n}\n\nfunc askString(question, def string) string {\n\tprompt := question\n\tif def != \"\" {\n\t\tprompt += fmt.Sprintf(\" [%s]\", def)\n\t}\n\tres := ask(prompt)\n\tif res == \"\" {\n\t\treturn def\n\t}\n\n\treturn res\n}\n\nfunc askInt(question string, def int) int {\n\tprompt := fmt.Sprintf(\"%s [%d]\", question, def)\n\tres := ask(prompt)\n\tif res == \"\" {\n\t\treturn def\n\t}\n\n\ti, err := strconv.Atoi(res)\n\tif err != nil {\n\t\treturn askInt(question, def)\n\t}\n\n\treturn i\n}\n\nfunc askBool(question string, def bool) bool {\n\tdefString := \"yes\"\n\tif !def {\n\t\tdefString = \"no\"\n\t}\n\n\tprompt := fmt.Sprintf(\"%s [%v]\", question, defString)\n\tres := ask(prompt)\n\n\tswitch strings.ToLower(res) {\n\tcase \"yes\", \"y\":\n\t\treturn true\n\tcase \"no\", \"n\":\n\t\treturn false\n\tcase \"\":\n\t\treturn def\n\tdefault:\n\t\treturn askBool(question, def)\n\t}\n}\n\nfunc confirm(question string) bool {\n\tanswer := ask(question)\n\n\tswitch strings.ToLower(answer) {\n\tcase \"yes\", \"y\":\n\t\treturn true\n\tcase \"no\", \"n\":\n\t\treturn false\n\tdefault:\n\t\treturn confirm(question)\n\t}\n}\n\nfunc spin(prefix string, f func() error) *cli.ExitError {\n\tspin := spinner.New(spinner.CharSets[9], time.Millisecond*100)\n\tspin.Prefix = fmt.Sprintf(\"%s: \", prefix)\n\tspin.Start()\n\terr := f()\n\tspin.Stop()\n\tif err != nil {\n\t\tcliError, ok := err.(*cli.ExitError)\n\t\tif ok {\n\t\t\tif cliError.ExitCode() != 0 {\n\t\t\t\tfmt.Printf(\"\\r%s: ERROR!\\n\", prefix)\n\t\t\t\treturn cliError\n\t\t\t}\n\n\t\t\tfmt.Printf(\"\\r%s: done\\n\", prefix)\n\t\t\treturn cli.NewExitError(\"\", 0)\n\t\t}\n\t\tfmt.Printf(\"\\r%s: ERROR!\\n\", prefix)\n\t\treturn cli.NewExitError(err.Error(), 1)\n\t}\n\n\tfmt.Printf(\"\\r%s: done\\n\", prefix)\n\treturn cli.NewExitError(\"\", 0)\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "vm.go",
          "type": "blob",
          "size": 7.259765625,
          "content": "package main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strings\"\n\t\"syscall\"\n\t\"time\"\n)\n\nvar (\n\tblockMatcher = regexp.MustCompile(`\\{((?s)[^\\{]*)\\}`)\n\tnameMatcher  = regexp.MustCompile(`(?s).*name=([a-fA-F0-9\\-]+)`)\n\tipMatcher    = regexp.MustCompile(`(?s).*ip_address=([0-9\\.]+)`)\n)\n\ntype dockerNetwork struct {\n\tDriver string\n\tIPAM   struct {\n\t\tConfig []struct {\n\t\t\tSubnet string\n\t\t}\n\t}\n}\n\ntype containerNetwork struct {\n\tNetworkSettings struct {\n\t\tIPAddress string\n\t}\n}\n\ntype VMStatusError struct {\n\tStatus  string `json:\"status\"`\n\tMessage string `json:\"message\"`\n}\n\ntype VMStatus struct {\n\tConfig\n\n\tStarted bool   `json:\"started\"`\n\tIP      string `json:\"ip\"`\n\tPid     int    `json:\"pid\"`\n}\n\ntype VM struct {\n\tConfig  Config\n\tOwner   *User\n\tTTY     string\n\tLog     string\n\tPath    string\n\tBin     string\n\tArgs    []string\n\tProcess *exec.Cmd\n\tStarted bool\n\tReady   bool\n\tip      string\n}\n\nfunc (vm *VM) Start() error {\n\tif vm.Process != nil {\n\t\treturn fmt.Errorf(\"Virtual machine is already running\")\n\t}\n\n\tvm.Process = exec.Command(vm.Bin, vm.Args...)\n\terr := vm.Process.Start()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = vm.waitForBoot()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = os.Chown(filepath.Join(vm.Path, \"vm.tty\"), vm.Owner.Uid, vm.Owner.Gid)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif vm.Config.Route {\n\t\terr = vm.Route()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (vm *VM) waitForBoot() error {\n\tattempts := 0\n\tsuccess := fmt.Sprintf(\"%s login:\", vm.Config.Hostname)\n\n\tfor {\n\t\tif attempts >= 30 {\n\t\t\treturn fmt.Errorf(\"Timed out waiting for virtual machine\")\n\t\t}\n\n\t\ttime.Sleep(time.Second)\n\n\t\tfile, err := os.Open(vm.Log)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\treturn err\n\t\t}\n\t\tdefer file.Close()\n\n\t\tscanner := bufio.NewScanner(file)\n\t\tfor scanner.Scan() {\n\t\t\tif strings.Contains(scanner.Text(), success) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t}\n\n\t\tattempts++\n\t}\n}\n\nfunc (vm *VM) Route() error {\n\tsubnet, err := vm.dockerSubnet()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = exec.Command(\"route\", \"-n\", \"add\", subnet, vm.Config.Hostname).Run()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trouteBytes, err := exec.Command(\"route\", \"-n\", \"get\", vm.Config.Hostname).Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\trouteIfaceMatcher := regexp.MustCompile(`(?m)^\\s*interface:\\s*(\\w+)$`)\n\trouteIfaceMatches := routeIfaceMatcher.FindAllStringSubmatch(string(routeBytes), -1)\n\tif routeIfaceMatches == nil {\n\t\treturn fmt.Errorf(\"Unable to find interface\")\n\t}\n\n\trouteIface := routeIfaceMatches[0][1]\n\n\tmemberBytes, err := exec.Command(\"ifconfig\", routeIface).Output()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tmemberMatcher := regexp.MustCompile(`(?m)^\\s*member:\\s*(.*) flags.*$`)\n\tmemberMatches := memberMatcher.FindAllStringSubmatch(string(memberBytes), -1)\n\tif memberMatches == nil {\n\t\treturn fmt.Errorf(\"Unable to find interface members\")\n\t}\n\n\tmembers := strings.Split(memberMatches[0][1], \" \")\n\tfor _, member := range members {\n\t\terr := exec.Command(\"ifconfig\", routeIface, \"-hostfilter\", member).Run()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc (vm *VM) dockerSubnet() (string, error) {\n\tip, err := vm.IP()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tres, err := http.Get(fmt.Sprintf(\"http://%s:2375/networks?filter={\\\"type\\\":{\\\"builtin\\\":true}}\", ip))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tdefer res.Body.Close()\n\n\tnetworks := []dockerNetwork{}\n\tdecoder := json.NewDecoder(res.Body)\n\terr = decoder.Decode(&networks)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tfor _, network := range networks {\n\t\tif network.Driver == \"bridge\" {\n\t\t\treturn network.IPAM.Config[0].Subnet, nil\n\t\t}\n\t}\n\n\treturn \"\", fmt.Errorf(\"Unable to find bridge network\")\n}\n\nfunc (vm *VM) findContainer(name string) (string, error) {\n\tip, err := vm.IP()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tres, err := http.Get(fmt.Sprintf(\"http://%s:2375/containers/%s/json\", ip, name))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tdefer res.Body.Close()\n\n\tcontainer := containerNetwork{}\n\tdecoder := json.NewDecoder(res.Body)\n\terr = decoder.Decode(&container)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tif container.NetworkSettings.IPAddress != \"\" {\n\t\treturn container.NetworkSettings.IPAddress, nil\n\t}\n\n\treturn \"\", fmt.Errorf(\"Unable to find container\")\n}\n\nfunc (vm *VM) Stop() error {\n\tif vm.Process == nil {\n\t\treturn nil\n\t}\n\n\terr := vm.Process.Process.Signal(syscall.SIGTERM)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\terr = vm.Process.Wait()\n\tvm.Process = nil\n\tos.RemoveAll(filepath.Join(vm.Path, \"vm.tty\"))\n\treturn err\n}\n\nfunc (vm *VM) IP() (string, error) {\n\tif vm.ip != \"\" {\n\t\treturn vm.ip, nil\n\t}\n\n\ttype result struct {\n\t\tvalue string\n\t\terr   error\n\t}\n\n\tvalue := make(chan result, 1)\n\n\tgo func() {\n\t\tattempts := 0\n\t\tfor {\n\t\t\tif attempts >= 15 {\n\t\t\t\tvalue <- result{\"\", fmt.Errorf(\"Timed out waiting for IP address\")}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\ttime.Sleep(time.Second)\n\n\t\t\tfile, err := os.Open(\"/var/db/dhcpd_leases\")\n\t\t\tif err != nil {\n\t\t\t\tif os.IsNotExist(err) {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tvalue <- result{\"\", err}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tdefer file.Close()\n\t\t\tleases, err := ioutil.ReadAll(file)\n\t\t\tif err != nil {\n\t\t\t\tvalue <- result{\"\", err}\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\tblocks := blockMatcher.FindAllStringSubmatch(string(leases), -1)\n\t\t\tfor _, block := range blocks {\n\t\t\t\tname := nameMatcher.FindStringSubmatch(block[1])\n\t\t\t\tif name != nil && name[1] == vm.Config.Id {\n\t\t\t\t\tip := ipMatcher.FindStringSubmatch(block[1])\n\t\t\t\t\tif ip != nil {\n\t\t\t\t\t\tvalue <- result{ip[1], nil}\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tattempts++\n\t\t}\n\t}()\n\n\tres := <-value\n\tif res.err == nil {\n\t\tvm.ip = res.value\n\t}\n\n\treturn res.value, res.err\n}\n\nfunc (vm *VM) Address() (*net.TCPAddr, error) {\n\tip, err := vm.IP()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn net.ResolveTCPAddr(\"tcp\", ip+\":2375\")\n}\n\nfunc (vm *VM) Status() (VMStatus, error) {\n\tstatus := VMStatus{}\n\tcfg, err := readConfig(getPath(*vm.Owner))\n\tif err != nil {\n\t\treturn status, err\n\t}\n\n\tstatus.Config = cfg\n\n\tif vm.Process != nil {\n\t\tip, err := vm.IP()\n\t\tif err != nil {\n\t\t\treturn status, nil\n\t\t}\n\n\t\tstatus.IP = ip\n\t\tstatus.Started = true\n\t\tstatus.Pid = vm.Process.Process.Pid\n\t}\n\n\treturn status, nil\n}\n\nfunc EmptyStatus(owner User) (VMStatus, error) {\n\tstatus := VMStatus{}\n\tcfg, err := readConfig(getPath(owner))\n\tif err != nil {\n\t\treturn status, err\n\t}\n\n\tstatus.Config = cfg\n\treturn status, nil\n}\n\nfunc NewVM(owner *User) (*VM, error) {\n\tpath := getPath(*owner)\n\tcfg, err := readConfig(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tkernel := filepath.Join(path, \"bzImage\")\n\trootfs := filepath.Join(path, \"rootfs.cpio.xz\")\n\tdisk := filepath.Join(path, \"disk.qcow\")\n\ttty := filepath.Join(path, \"vm.tty\")\n\tlog := filepath.Join(path, \"vm.log\")\n\tbootstrapData, err := GetBootstrapData(*owner)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &VM{\n\t\tOwner:  owner,\n\t\tConfig: cfg,\n\t\tPath:   path,\n\t\tBin:    filepath.Join(path, \"bin\", \"com.docker.hyperkit\"),\n\t\tTTY:    tty,\n\t\tLog:    log,\n\t\tArgs: []string{\n\t\t\t\"-A\",\n\t\t\t\"-u\",\n\t\t\t\"-U\", cfg.Id,\n\t\t\t\"-c\", fmt.Sprintf(\"%d\", cfg.Cpu),\n\t\t\t\"-m\", fmt.Sprintf(\"%dG\", cfg.Memory),\n\t\t\t\"-l\", fmt.Sprintf(\"com1,autopty=%s,log=%s\", tty, log),\n\t\t\t\"-s\", \"0:0,hostbridge\",\n\t\t\t\"-s\", \"5,virtio-rnd\",\n\t\t\t\"-s\", \"31,lpc\",\n\t\t\t\"-s\", \"2:0,virtio-net\",\n\t\t\t\"-s\", fmt.Sprintf(\"4:0,virtio-blk,file://%s,format=qcow\", disk),\n\t\t\t\"-f\", fmt.Sprintf(\"kexec,%s,%s,earlyprintk=serial console=ttyS0 no_timer_check config=%s\", kernel, rootfs, bootstrapData),\n\t\t},\n\t}, nil\n}\n"
        }
      ]
    }
  ]
}