{
  "metadata": {
    "timestamp": 1736566579107,
    "page": 130,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjEzMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "go-gomail/gomail",
      "stars": 4432,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.064453125,
          "content": "language: go\n\ngo:\n  - 1.2\n  - 1.3\n  - 1.4\n  - 1.5\n  - 1.6\n  - tip\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.9541015625,
          "content": "# Change Log\nAll notable changes to this project will be documented in this file.\nThis project adheres to [Semantic Versioning](http://semver.org/).\n\n## [2.0.0] - 2015-09-02\n\n- Mailer has been removed. It has been replaced by Dialer and Sender.\n- `File` type and the `CreateFile` and `OpenFile` functions have been removed.\n- `Message.Attach` and `Message.Embed` have a new signature.\n- `Message.GetBodyWriter` has been removed. Use `Message.AddAlternativeWriter`\ninstead.\n- `Message.Export` has been removed. `Message.WriteTo` can be used instead.\n- `Message.DelHeader` has been removed.\n- The `Bcc` header field is no longer sent. It is far more simpler and\nefficient: the same message is sent to all recipients instead of sending a\ndifferent email to each Bcc address.\n- LoginAuth has been removed. `NewPlainDialer` now implements the LOGIN\nauthentication mechanism when needed.\n- Go 1.2 is now required instead of Go 1.3. No external dependency are used when\nusing Go 1.5.\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 0.607421875,
          "content": "Thank you for contributing to Gomail! Here are a few guidelines:\n\n## Bugs\n\nIf you think you found a bug, create an issue and supply the minimum amount\nof code triggering the bug so it can be reproduced.\n\n\n## Fixing a bug\n\nIf you want to fix a bug, you can send a pull request. It should contains a\nnew test or update an existing one to cover that bug.\n\n\n## New feature proposal\n\nIf you think Gomail lacks a feature, you can open an issue or send a pull\nrequest. I want to keep Gomail code and API as simple as possible so please\ndescribe your needs so we can discuss whether this feature should be added to\nGomail or not.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0576171875,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2014 Alexandre Cesaro\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 2.1845703125,
          "content": "# Gomail\n[![Build Status](https://travis-ci.org/go-gomail/gomail.svg?branch=v2)](https://travis-ci.org/go-gomail/gomail) [![Code Coverage](http://gocover.io/_badge/gopkg.in/gomail.v2)](http://gocover.io/gopkg.in/gomail.v2) [![Documentation](https://godoc.org/gopkg.in/gomail.v2?status.svg)](https://godoc.org/gopkg.in/gomail.v2)\n\n## Introduction\n\nGomail is a simple and efficient package to send emails. It is well tested and\ndocumented.\n\nGomail can only send emails using an SMTP server. But the API is flexible and it\nis easy to implement other methods for sending emails using a local Postfix, an\nAPI, etc.\n\nIt is versioned using [gopkg.in](https://gopkg.in) so I promise\nthere will never be backward incompatible changes within each version.\n\nIt requires Go 1.2 or newer. With Go 1.5, no external dependencies are used.\n\n\n## Features\n\nGomail supports:\n- Attachments\n- Embedded images\n- HTML and text templates\n- Automatic encoding of special characters\n- SSL and TLS\n- Sending multiple emails with the same SMTP connection\n\n\n## Documentation\n\nhttps://godoc.org/gopkg.in/gomail.v2\n\n\n## Download\n\n    go get gopkg.in/gomail.v2\n\n\n## Examples\n\nSee the [examples in the documentation](https://godoc.org/gopkg.in/gomail.v2#example-package).\n\n\n## FAQ\n\n### x509: certificate signed by unknown authority\n\nIf you get this error it means the certificate used by the SMTP server is not\nconsidered valid by the client running Gomail. As a quick workaround you can\nbypass the verification of the server's certificate chain and host name by using\n`SetTLSConfig`:\n\n    package main\n\n    import (\n    \t\"crypto/tls\"\n\n    \t\"gopkg.in/gomail.v2\"\n    )\n\n    func main() {\n    \td := gomail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\")\n    \td.TLSConfig = &tls.Config{InsecureSkipVerify: true}\n\n        // Send emails using d.\n    }\n\nNote, however, that this is insecure and should not be used in production.\n\n\n## Contribute\n\nContributions are more than welcome! See [CONTRIBUTING.md](CONTRIBUTING.md) for\nmore info.\n\n\n## Change log\n\nSee [CHANGELOG.md](CHANGELOG.md).\n\n\n## License\n\n[MIT](LICENSE)\n\n\n## Contact\n\nYou can ask questions on the [Gomail\nthread](https://groups.google.com/d/topic/golang-nuts/jMxZHzvvEVg/discussion)\nin the Go mailing-list.\n"
        },
        {
          "name": "auth.go",
          "type": "blob",
          "size": 1.017578125,
          "content": "package gomail\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net/smtp\"\n)\n\n// loginAuth is an smtp.Auth that implements the LOGIN authentication mechanism.\ntype loginAuth struct {\n\tusername string\n\tpassword string\n\thost     string\n}\n\nfunc (a *loginAuth) Start(server *smtp.ServerInfo) (string, []byte, error) {\n\tif !server.TLS {\n\t\tadvertised := false\n\t\tfor _, mechanism := range server.Auth {\n\t\t\tif mechanism == \"LOGIN\" {\n\t\t\t\tadvertised = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !advertised {\n\t\t\treturn \"\", nil, errors.New(\"gomail: unencrypted connection\")\n\t\t}\n\t}\n\tif server.Name != a.host {\n\t\treturn \"\", nil, errors.New(\"gomail: wrong host name\")\n\t}\n\treturn \"LOGIN\", nil, nil\n}\n\nfunc (a *loginAuth) Next(fromServer []byte, more bool) ([]byte, error) {\n\tif !more {\n\t\treturn nil, nil\n\t}\n\n\tswitch {\n\tcase bytes.Equal(fromServer, []byte(\"Username:\")):\n\t\treturn []byte(a.username), nil\n\tcase bytes.Equal(fromServer, []byte(\"Password:\")):\n\t\treturn []byte(a.password), nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"gomail: unexpected server challenge: %s\", fromServer)\n\t}\n}\n"
        },
        {
          "name": "auth_test.go",
          "type": "blob",
          "size": 2.0283203125,
          "content": "package gomail\n\nimport (\n\t\"net/smtp\"\n\t\"testing\"\n)\n\nconst (\n\ttestUser = \"user\"\n\ttestPwd  = \"pwd\"\n\ttestHost = \"smtp.example.com\"\n)\n\ntype authTest struct {\n\tauths      []string\n\tchallenges []string\n\ttls        bool\n\twantData   []string\n\twantError  bool\n}\n\nfunc TestNoAdvertisement(t *testing.T) {\n\ttestLoginAuth(t, &authTest{\n\t\tauths:     []string{},\n\t\ttls:       false,\n\t\twantError: true,\n\t})\n}\n\nfunc TestNoAdvertisementTLS(t *testing.T) {\n\ttestLoginAuth(t, &authTest{\n\t\tauths:      []string{},\n\t\tchallenges: []string{\"Username:\", \"Password:\"},\n\t\ttls:        true,\n\t\twantData:   []string{\"\", testUser, testPwd},\n\t})\n}\n\nfunc TestLogin(t *testing.T) {\n\ttestLoginAuth(t, &authTest{\n\t\tauths:      []string{\"PLAIN\", \"LOGIN\"},\n\t\tchallenges: []string{\"Username:\", \"Password:\"},\n\t\ttls:        false,\n\t\twantData:   []string{\"\", testUser, testPwd},\n\t})\n}\n\nfunc TestLoginTLS(t *testing.T) {\n\ttestLoginAuth(t, &authTest{\n\t\tauths:      []string{\"LOGIN\"},\n\t\tchallenges: []string{\"Username:\", \"Password:\"},\n\t\ttls:        true,\n\t\twantData:   []string{\"\", testUser, testPwd},\n\t})\n}\n\nfunc testLoginAuth(t *testing.T, test *authTest) {\n\tauth := &loginAuth{\n\t\tusername: testUser,\n\t\tpassword: testPwd,\n\t\thost:     testHost,\n\t}\n\tserver := &smtp.ServerInfo{\n\t\tName: testHost,\n\t\tTLS:  test.tls,\n\t\tAuth: test.auths,\n\t}\n\tproto, toServer, err := auth.Start(server)\n\tif err != nil && !test.wantError {\n\t\tt.Fatalf(\"loginAuth.Start(): %v\", err)\n\t}\n\tif err != nil && test.wantError {\n\t\treturn\n\t}\n\tif proto != \"LOGIN\" {\n\t\tt.Errorf(\"invalid protocol, got %q, want LOGIN\", proto)\n\t}\n\n\ti := 0\n\tgot := string(toServer)\n\tif got != test.wantData[i] {\n\t\tt.Errorf(\"Invalid response, got %q, want %q\", got, test.wantData[i])\n\t}\n\n\tfor _, challenge := range test.challenges {\n\t\ti++\n\t\tif i >= len(test.wantData) {\n\t\t\tt.Fatalf(\"unexpected challenge: %q\", challenge)\n\t\t}\n\n\t\ttoServer, err = auth.Next([]byte(challenge), true)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"loginAuth.Auth(): %v\", err)\n\t\t}\n\t\tgot = string(toServer)\n\t\tif got != test.wantData[i] {\n\t\t\tt.Errorf(\"Invalid response, got %q, want %q\", got, test.wantData[i])\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.1708984375,
          "content": "// Package gomail provides a simple interface to compose emails and to mail them\n// efficiently.\n//\n// More info on Github: https://github.com/go-gomail/gomail\npackage gomail\n"
        },
        {
          "name": "example_test.go",
          "type": "blob",
          "size": 5.029296875,
          "content": "package gomail_test\n\nimport (\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"log\"\n\t\"time\"\n\n\t\"gopkg.in/gomail.v2\"\n)\n\nfunc Example() {\n\tm := gomail.NewMessage()\n\tm.SetHeader(\"From\", \"alex@example.com\")\n\tm.SetHeader(\"To\", \"bob@example.com\", \"cora@example.com\")\n\tm.SetAddressHeader(\"Cc\", \"dan@example.com\", \"Dan\")\n\tm.SetHeader(\"Subject\", \"Hello!\")\n\tm.SetBody(\"text/html\", \"Hello <b>Bob</b> and <i>Cora</i>!\")\n\tm.Attach(\"/home/Alex/lolcat.jpg\")\n\n\td := gomail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\")\n\n\t// Send the email to Bob, Cora and Dan.\n\tif err := d.DialAndSend(m); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// A daemon that listens to a channel and sends all incoming messages.\nfunc Example_daemon() {\n\tch := make(chan *gomail.Message)\n\n\tgo func() {\n\t\td := gomail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\")\n\n\t\tvar s gomail.SendCloser\n\t\tvar err error\n\t\topen := false\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase m, ok := <-ch:\n\t\t\t\tif !ok {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif !open {\n\t\t\t\t\tif s, err = d.Dial(); err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t\topen = true\n\t\t\t\t}\n\t\t\t\tif err := gomail.Send(s, m); err != nil {\n\t\t\t\t\tlog.Print(err)\n\t\t\t\t}\n\t\t\t// Close the connection to the SMTP server if no email was sent in\n\t\t\t// the last 30 seconds.\n\t\t\tcase <-time.After(30 * time.Second):\n\t\t\t\tif open {\n\t\t\t\t\tif err := s.Close(); err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t\topen = false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\t// Use the channel in your program to send emails.\n\n\t// Close the channel to stop the mail daemon.\n\tclose(ch)\n}\n\n// Efficiently send a customized newsletter to a list of recipients.\nfunc Example_newsletter() {\n\t// The list of recipients.\n\tvar list []struct {\n\t\tName    string\n\t\tAddress string\n\t}\n\n\td := gomail.NewDialer(\"smtp.example.com\", 587, \"user\", \"123456\")\n\ts, err := d.Dial()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tm := gomail.NewMessage()\n\tfor _, r := range list {\n\t\tm.SetHeader(\"From\", \"no-reply@example.com\")\n\t\tm.SetAddressHeader(\"To\", r.Address, r.Name)\n\t\tm.SetHeader(\"Subject\", \"Newsletter #1\")\n\t\tm.SetBody(\"text/html\", fmt.Sprintf(\"Hello %s!\", r.Name))\n\n\t\tif err := gomail.Send(s, m); err != nil {\n\t\t\tlog.Printf(\"Could not send email to %q: %v\", r.Address, err)\n\t\t}\n\t\tm.Reset()\n\t}\n}\n\n// Send an email using a local SMTP server.\nfunc Example_noAuth() {\n\tm := gomail.NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetHeader(\"Subject\", \"Hello!\")\n\tm.SetBody(\"text/plain\", \"Hello!\")\n\n\td := gomail.Dialer{Host: \"localhost\", Port: 587}\n\tif err := d.DialAndSend(m); err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Send an email using an API or postfix.\nfunc Example_noSMTP() {\n\tm := gomail.NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetHeader(\"Subject\", \"Hello!\")\n\tm.SetBody(\"text/plain\", \"Hello!\")\n\n\ts := gomail.SendFunc(func(from string, to []string, msg io.WriterTo) error {\n\t\t// Implements you email-sending function, for example by calling\n\t\t// an API, or running postfix, etc.\n\t\tfmt.Println(\"From:\", from)\n\t\tfmt.Println(\"To:\", to)\n\t\treturn nil\n\t})\n\n\tif err := gomail.Send(s, m); err != nil {\n\t\tpanic(err)\n\t}\n\t// Output:\n\t// From: from@example.com\n\t// To: [to@example.com]\n}\n\nvar m *gomail.Message\n\nfunc ExampleSetCopyFunc() {\n\tm.Attach(\"foo.txt\", gomail.SetCopyFunc(func(w io.Writer) error {\n\t\t_, err := w.Write([]byte(\"Content of foo.txt\"))\n\t\treturn err\n\t}))\n}\n\nfunc ExampleSetHeader() {\n\th := map[string][]string{\"Content-ID\": {\"<foo@bar.mail>\"}}\n\tm.Attach(\"foo.jpg\", gomail.SetHeader(h))\n}\n\nfunc ExampleRename() {\n\tm.Attach(\"/tmp/0000146.jpg\", gomail.Rename(\"picture.jpg\"))\n}\n\nfunc ExampleMessage_AddAlternative() {\n\tm.SetBody(\"text/plain\", \"Hello!\")\n\tm.AddAlternative(\"text/html\", \"<p>Hello!</p>\")\n}\n\nfunc ExampleMessage_AddAlternativeWriter() {\n\tt := template.Must(template.New(\"example\").Parse(\"Hello {{.}}!\"))\n\tm.AddAlternativeWriter(\"text/plain\", func(w io.Writer) error {\n\t\treturn t.Execute(w, \"Bob\")\n\t})\n}\n\nfunc ExampleMessage_Attach() {\n\tm.Attach(\"/tmp/image.jpg\")\n}\n\nfunc ExampleMessage_Embed() {\n\tm.Embed(\"/tmp/image.jpg\")\n\tm.SetBody(\"text/html\", `<img src=\"cid:image.jpg\" alt=\"My image\" />`)\n}\n\nfunc ExampleMessage_FormatAddress() {\n\tm.SetHeader(\"To\", m.FormatAddress(\"bob@example.com\", \"Bob\"), m.FormatAddress(\"cora@example.com\", \"Cora\"))\n}\n\nfunc ExampleMessage_FormatDate() {\n\tm.SetHeaders(map[string][]string{\n\t\t\"X-Date\": {m.FormatDate(time.Now())},\n\t})\n}\n\nfunc ExampleMessage_SetAddressHeader() {\n\tm.SetAddressHeader(\"To\", \"bob@example.com\", \"Bob\")\n}\n\nfunc ExampleMessage_SetBody() {\n\tm.SetBody(\"text/plain\", \"Hello!\")\n}\n\nfunc ExampleMessage_SetDateHeader() {\n\tm.SetDateHeader(\"X-Date\", time.Now())\n}\n\nfunc ExampleMessage_SetHeader() {\n\tm.SetHeader(\"Subject\", \"Hello!\")\n}\n\nfunc ExampleMessage_SetHeaders() {\n\tm.SetHeaders(map[string][]string{\n\t\t\"From\":    {m.FormatAddress(\"alex@example.com\", \"Alex\")},\n\t\t\"To\":      {\"bob@example.com\", \"cora@example.com\"},\n\t\t\"Subject\": {\"Hello\"},\n\t})\n}\n\nfunc ExampleSetCharset() {\n\tm = gomail.NewMessage(gomail.SetCharset(\"ISO-8859-1\"))\n}\n\nfunc ExampleSetEncoding() {\n\tm = gomail.NewMessage(gomail.SetEncoding(gomail.Base64))\n}\n\nfunc ExampleSetPartEncoding() {\n\tm.SetBody(\"text/plain\", \"Hello!\", gomail.SetPartEncoding(gomail.Unencoded))\n}\n"
        },
        {
          "name": "message.go",
          "type": "blob",
          "size": 8.001953125,
          "content": "package gomail\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n)\n\n// Message represents an email.\ntype Message struct {\n\theader      header\n\tparts       []*part\n\tattachments []*file\n\tembedded    []*file\n\tcharset     string\n\tencoding    Encoding\n\thEncoder    mimeEncoder\n\tbuf         bytes.Buffer\n}\n\ntype header map[string][]string\n\ntype part struct {\n\tcontentType string\n\tcopier      func(io.Writer) error\n\tencoding    Encoding\n}\n\n// NewMessage creates a new message. It uses UTF-8 and quoted-printable encoding\n// by default.\nfunc NewMessage(settings ...MessageSetting) *Message {\n\tm := &Message{\n\t\theader:   make(header),\n\t\tcharset:  \"UTF-8\",\n\t\tencoding: QuotedPrintable,\n\t}\n\n\tm.applySettings(settings)\n\n\tif m.encoding == Base64 {\n\t\tm.hEncoder = bEncoding\n\t} else {\n\t\tm.hEncoder = qEncoding\n\t}\n\n\treturn m\n}\n\n// Reset resets the message so it can be reused. The message keeps its previous\n// settings so it is in the same state that after a call to NewMessage.\nfunc (m *Message) Reset() {\n\tfor k := range m.header {\n\t\tdelete(m.header, k)\n\t}\n\tm.parts = nil\n\tm.attachments = nil\n\tm.embedded = nil\n}\n\nfunc (m *Message) applySettings(settings []MessageSetting) {\n\tfor _, s := range settings {\n\t\ts(m)\n\t}\n}\n\n// A MessageSetting can be used as an argument in NewMessage to configure an\n// email.\ntype MessageSetting func(m *Message)\n\n// SetCharset is a message setting to set the charset of the email.\nfunc SetCharset(charset string) MessageSetting {\n\treturn func(m *Message) {\n\t\tm.charset = charset\n\t}\n}\n\n// SetEncoding is a message setting to set the encoding of the email.\nfunc SetEncoding(enc Encoding) MessageSetting {\n\treturn func(m *Message) {\n\t\tm.encoding = enc\n\t}\n}\n\n// Encoding represents a MIME encoding scheme like quoted-printable or base64.\ntype Encoding string\n\nconst (\n\t// QuotedPrintable represents the quoted-printable encoding as defined in\n\t// RFC 2045.\n\tQuotedPrintable Encoding = \"quoted-printable\"\n\t// Base64 represents the base64 encoding as defined in RFC 2045.\n\tBase64 Encoding = \"base64\"\n\t// Unencoded can be used to avoid encoding the body of an email. The headers\n\t// will still be encoded using quoted-printable encoding.\n\tUnencoded Encoding = \"8bit\"\n)\n\n// SetHeader sets a value to the given header field.\nfunc (m *Message) SetHeader(field string, value ...string) {\n\tm.encodeHeader(value)\n\tm.header[field] = value\n}\n\nfunc (m *Message) encodeHeader(values []string) {\n\tfor i := range values {\n\t\tvalues[i] = m.encodeString(values[i])\n\t}\n}\n\nfunc (m *Message) encodeString(value string) string {\n\treturn m.hEncoder.Encode(m.charset, value)\n}\n\n// SetHeaders sets the message headers.\nfunc (m *Message) SetHeaders(h map[string][]string) {\n\tfor k, v := range h {\n\t\tm.SetHeader(k, v...)\n\t}\n}\n\n// SetAddressHeader sets an address to the given header field.\nfunc (m *Message) SetAddressHeader(field, address, name string) {\n\tm.header[field] = []string{m.FormatAddress(address, name)}\n}\n\n// FormatAddress formats an address and a name as a valid RFC 5322 address.\nfunc (m *Message) FormatAddress(address, name string) string {\n\tif name == \"\" {\n\t\treturn address\n\t}\n\n\tenc := m.encodeString(name)\n\tif enc == name {\n\t\tm.buf.WriteByte('\"')\n\t\tfor i := 0; i < len(name); i++ {\n\t\t\tb := name[i]\n\t\t\tif b == '\\\\' || b == '\"' {\n\t\t\t\tm.buf.WriteByte('\\\\')\n\t\t\t}\n\t\t\tm.buf.WriteByte(b)\n\t\t}\n\t\tm.buf.WriteByte('\"')\n\t} else if hasSpecials(name) {\n\t\tm.buf.WriteString(bEncoding.Encode(m.charset, name))\n\t} else {\n\t\tm.buf.WriteString(enc)\n\t}\n\tm.buf.WriteString(\" <\")\n\tm.buf.WriteString(address)\n\tm.buf.WriteByte('>')\n\n\taddr := m.buf.String()\n\tm.buf.Reset()\n\treturn addr\n}\n\nfunc hasSpecials(text string) bool {\n\tfor i := 0; i < len(text); i++ {\n\t\tswitch c := text[i]; c {\n\t\tcase '(', ')', '<', '>', '[', ']', ':', ';', '@', '\\\\', ',', '.', '\"':\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n// SetDateHeader sets a date to the given header field.\nfunc (m *Message) SetDateHeader(field string, date time.Time) {\n\tm.header[field] = []string{m.FormatDate(date)}\n}\n\n// FormatDate formats a date as a valid RFC 5322 date.\nfunc (m *Message) FormatDate(date time.Time) string {\n\treturn date.Format(time.RFC1123Z)\n}\n\n// GetHeader gets a header field.\nfunc (m *Message) GetHeader(field string) []string {\n\treturn m.header[field]\n}\n\n// SetBody sets the body of the message. It replaces any content previously set\n// by SetBody, AddAlternative or AddAlternativeWriter.\nfunc (m *Message) SetBody(contentType, body string, settings ...PartSetting) {\n\tm.parts = []*part{m.newPart(contentType, newCopier(body), settings)}\n}\n\n// AddAlternative adds an alternative part to the message.\n//\n// It is commonly used to send HTML emails that default to the plain text\n// version for backward compatibility. AddAlternative appends the new part to\n// the end of the message. So the plain text part should be added before the\n// HTML part. See http://en.wikipedia.org/wiki/MIME#Alternative\nfunc (m *Message) AddAlternative(contentType, body string, settings ...PartSetting) {\n\tm.AddAlternativeWriter(contentType, newCopier(body), settings...)\n}\n\nfunc newCopier(s string) func(io.Writer) error {\n\treturn func(w io.Writer) error {\n\t\t_, err := io.WriteString(w, s)\n\t\treturn err\n\t}\n}\n\n// AddAlternativeWriter adds an alternative part to the message. It can be\n// useful with the text/template or html/template packages.\nfunc (m *Message) AddAlternativeWriter(contentType string, f func(io.Writer) error, settings ...PartSetting) {\n\tm.parts = append(m.parts, m.newPart(contentType, f, settings))\n}\n\nfunc (m *Message) newPart(contentType string, f func(io.Writer) error, settings []PartSetting) *part {\n\tp := &part{\n\t\tcontentType: contentType,\n\t\tcopier:      f,\n\t\tencoding:    m.encoding,\n\t}\n\n\tfor _, s := range settings {\n\t\ts(p)\n\t}\n\n\treturn p\n}\n\n// A PartSetting can be used as an argument in Message.SetBody,\n// Message.AddAlternative or Message.AddAlternativeWriter to configure the part\n// added to a message.\ntype PartSetting func(*part)\n\n// SetPartEncoding sets the encoding of the part added to the message. By\n// default, parts use the same encoding than the message.\nfunc SetPartEncoding(e Encoding) PartSetting {\n\treturn PartSetting(func(p *part) {\n\t\tp.encoding = e\n\t})\n}\n\ntype file struct {\n\tName     string\n\tHeader   map[string][]string\n\tCopyFunc func(w io.Writer) error\n}\n\nfunc (f *file) setHeader(field, value string) {\n\tf.Header[field] = []string{value}\n}\n\n// A FileSetting can be used as an argument in Message.Attach or Message.Embed.\ntype FileSetting func(*file)\n\n// SetHeader is a file setting to set the MIME header of the message part that\n// contains the file content.\n//\n// Mandatory headers are automatically added if they are not set when sending\n// the email.\nfunc SetHeader(h map[string][]string) FileSetting {\n\treturn func(f *file) {\n\t\tfor k, v := range h {\n\t\t\tf.Header[k] = v\n\t\t}\n\t}\n}\n\n// Rename is a file setting to set the name of the attachment if the name is\n// different than the filename on disk.\nfunc Rename(name string) FileSetting {\n\treturn func(f *file) {\n\t\tf.Name = name\n\t}\n}\n\n// SetCopyFunc is a file setting to replace the function that runs when the\n// message is sent. It should copy the content of the file to the io.Writer.\n//\n// The default copy function opens the file with the given filename, and copy\n// its content to the io.Writer.\nfunc SetCopyFunc(f func(io.Writer) error) FileSetting {\n\treturn func(fi *file) {\n\t\tfi.CopyFunc = f\n\t}\n}\n\nfunc (m *Message) appendFile(list []*file, name string, settings []FileSetting) []*file {\n\tf := &file{\n\t\tName:   filepath.Base(name),\n\t\tHeader: make(map[string][]string),\n\t\tCopyFunc: func(w io.Writer) error {\n\t\t\th, err := os.Open(name)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, err := io.Copy(w, h); err != nil {\n\t\t\t\th.Close()\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn h.Close()\n\t\t},\n\t}\n\n\tfor _, s := range settings {\n\t\ts(f)\n\t}\n\n\tif list == nil {\n\t\treturn []*file{f}\n\t}\n\n\treturn append(list, f)\n}\n\n// Attach attaches the files to the email.\nfunc (m *Message) Attach(filename string, settings ...FileSetting) {\n\tm.attachments = m.appendFile(m.attachments, filename, settings)\n}\n\n// Embed embeds the images to the email.\nfunc (m *Message) Embed(filename string, settings ...FileSetting) {\n\tm.embedded = m.appendFile(m.embedded, filename, settings)\n}\n"
        },
        {
          "name": "message_test.go",
          "type": "blob",
          "size": 20.87109375,
          "content": "package gomail\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"path/filepath\"\n\t\"regexp\"\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n)\n\nfunc init() {\n\tnow = func() time.Time {\n\t\treturn time.Date(2014, 06, 25, 17, 46, 0, 0, time.UTC)\n\t}\n}\n\ntype message struct {\n\tfrom    string\n\tto      []string\n\tcontent string\n}\n\nfunc TestMessage(t *testing.T) {\n\tm := NewMessage()\n\tm.SetAddressHeader(\"From\", \"from@example.com\", \"Señor From\")\n\tm.SetHeader(\"To\", m.FormatAddress(\"to@example.com\", \"Señor To\"), \"tobis@example.com\")\n\tm.SetAddressHeader(\"Cc\", \"cc@example.com\", \"A, B\")\n\tm.SetAddressHeader(\"X-To\", \"ccbis@example.com\", \"à, b\")\n\tm.SetDateHeader(\"X-Date\", now())\n\tm.SetHeader(\"X-Date-2\", m.FormatDate(now()))\n\tm.SetHeader(\"Subject\", \"¡Hola, señor!\")\n\tm.SetHeaders(map[string][]string{\n\t\t\"X-Headers\": {\"Test\", \"Café\"},\n\t})\n\tm.SetBody(\"text/plain\", \"¡Hola, señor!\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto: []string{\n\t\t\t\"to@example.com\",\n\t\t\t\"tobis@example.com\",\n\t\t\t\"cc@example.com\",\n\t\t},\n\t\tcontent: \"From: =?UTF-8?q?Se=C3=B1or_From?= <from@example.com>\\r\\n\" +\n\t\t\t\"To: =?UTF-8?q?Se=C3=B1or_To?= <to@example.com>, tobis@example.com\\r\\n\" +\n\t\t\t\"Cc: \\\"A, B\\\" <cc@example.com>\\r\\n\" +\n\t\t\t\"X-To: =?UTF-8?b?w6AsIGI=?= <ccbis@example.com>\\r\\n\" +\n\t\t\t\"X-Date: Wed, 25 Jun 2014 17:46:00 +0000\\r\\n\" +\n\t\t\t\"X-Date-2: Wed, 25 Jun 2014 17:46:00 +0000\\r\\n\" +\n\t\t\t\"X-Headers: Test, =?UTF-8?q?Caf=C3=A9?=\\r\\n\" +\n\t\t\t\"Subject: =?UTF-8?q?=C2=A1Hola,_se=C3=B1or!?=\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"=C2=A1Hola, se=C3=B1or!\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestCustomMessage(t *testing.T) {\n\tm := NewMessage(SetCharset(\"ISO-8859-1\"), SetEncoding(Base64))\n\tm.SetHeaders(map[string][]string{\n\t\t\"From\":    {\"from@example.com\"},\n\t\t\"To\":      {\"to@example.com\"},\n\t\t\"Subject\": {\"Café\"},\n\t})\n\tm.SetBody(\"text/html\", \"¡Hola, señor!\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Subject: =?ISO-8859-1?b?Q2Fmw6k=?=\\r\\n\" +\n\t\t\t\"Content-Type: text/html; charset=ISO-8859-1\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"wqFIb2xhLCBzZcOxb3Ih\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestUnencodedMessage(t *testing.T) {\n\tm := NewMessage(SetEncoding(Unencoded))\n\tm.SetHeaders(map[string][]string{\n\t\t\"From\":    {\"from@example.com\"},\n\t\t\"To\":      {\"to@example.com\"},\n\t\t\"Subject\": {\"Café\"},\n\t})\n\tm.SetBody(\"text/html\", \"¡Hola, señor!\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Subject: =?UTF-8?q?Caf=C3=A9?=\\r\\n\" +\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: 8bit\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"¡Hola, señor!\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestRecipients(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeaders(map[string][]string{\n\t\t\"From\":    {\"from@example.com\"},\n\t\t\"To\":      {\"to@example.com\"},\n\t\t\"Cc\":      {\"cc@example.com\"},\n\t\t\"Bcc\":     {\"bcc1@example.com\", \"bcc2@example.com\"},\n\t\t\"Subject\": {\"Hello!\"},\n\t})\n\tm.SetBody(\"text/plain\", \"Test message\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\", \"cc@example.com\", \"bcc1@example.com\", \"bcc2@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Cc: cc@example.com\\r\\n\" +\n\t\t\t\"Subject: Hello!\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test message\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestAlternative(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", \"¡Hola, señor!\")\n\tm.AddAlternative(\"text/html\", \"¡<b>Hola</b>, <i>señor</i>!</h1>\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/alternative;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"=C2=A1Hola, se=C3=B1or!\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"=C2=A1<b>Hola</b>, <i>se=C3=B1or</i>!</h1>\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestPartSetting(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain; format=flowed\", \"¡Hola, señor!\", SetPartEncoding(Unencoded))\n\tm.AddAlternative(\"text/html\", \"¡<b>Hola</b>, <i>señor</i>!</h1>\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/alternative;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; format=flowed; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: 8bit\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"¡Hola, señor!\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"=C2=A1<b>Hola</b>, <i>se=C3=B1or</i>!</h1>\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestBodyWriter(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.AddAlternativeWriter(\"text/plain\", func(w io.Writer) error {\n\t\t_, err := w.Write([]byte(\"Test message\"))\n\t\treturn err\n\t})\n\tm.AddAlternativeWriter(\"text/html\", func(w io.Writer) error {\n\t\t_, err := w.Write([]byte(\"Test HTML\"))\n\t\treturn err\n\t})\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/alternative;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test message\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test HTML\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestAttachmentOnly(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.Attach(mockCopyFile(\"/tmp/test.pdf\"))\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: application/pdf; name=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.pdf\")),\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestAttachment(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", \"Test\")\n\tm.Attach(mockCopyFile(\"/tmp/test.pdf\"))\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/mixed;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/pdf; name=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.pdf\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestRename(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", \"Test\")\n\tname, copy := mockCopyFile(\"/tmp/test.pdf\")\n\trename := Rename(\"another.pdf\")\n\tm.Attach(name, copy, rename)\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/mixed;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/pdf; name=\\\"another.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"another.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.pdf\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestAttachmentsOnly(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.Attach(mockCopyFile(\"/tmp/test.pdf\"))\n\tm.Attach(mockCopyFile(\"/tmp/test.zip\"))\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/mixed;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/pdf; name=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.pdf\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/zip; name=\\\"test.zip\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.zip\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.zip\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestAttachments(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", \"Test\")\n\tm.Attach(mockCopyFile(\"/tmp/test.pdf\"))\n\tm.Attach(mockCopyFile(\"/tmp/test.zip\"))\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/mixed;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/pdf; name=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.pdf\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/zip; name=\\\"test.zip\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.zip\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.zip\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestEmbedded(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.Embed(mockCopyFileWithHeader(m, \"image1.jpg\", map[string][]string{\"Content-ID\": {\"<test-content-id>\"}}))\n\tm.Embed(mockCopyFile(\"image2.jpg\"))\n\tm.SetBody(\"text/plain\", \"Test\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/related;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: image/jpeg; name=\\\"image1.jpg\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: inline; filename=\\\"image1.jpg\\\"\\r\\n\" +\n\t\t\t\"Content-ID: <test-content-id>\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of image1.jpg\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: image/jpeg; name=\\\"image2.jpg\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: inline; filename=\\\"image2.jpg\\\"\\r\\n\" +\n\t\t\t\"Content-ID: <image2.jpg>\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of image2.jpg\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 1, want)\n}\n\nfunc TestFullMessage(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", \"¡Hola, señor!\")\n\tm.AddAlternative(\"text/html\", \"¡<b>Hola</b>, <i>señor</i>!</h1>\")\n\tm.Attach(mockCopyFile(\"test.pdf\"))\n\tm.Embed(mockCopyFile(\"image.jpg\"))\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: multipart/mixed;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: multipart/related;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_2_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_2_\\r\\n\" +\n\t\t\t\"Content-Type: multipart/alternative;\\r\\n\" +\n\t\t\t\" boundary=_BOUNDARY_3_\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_3_\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"=C2=A1Hola, se=C3=B1or!\\r\\n\" +\n\t\t\t\"--_BOUNDARY_3_\\r\\n\" +\n\t\t\t\"Content-Type: text/html; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"=C2=A1<b>Hola</b>, <i>se=C3=B1or</i>!</h1>\\r\\n\" +\n\t\t\t\"--_BOUNDARY_3_--\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_2_\\r\\n\" +\n\t\t\t\"Content-Type: image/jpeg; name=\\\"image.jpg\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: inline; filename=\\\"image.jpg\\\"\\r\\n\" +\n\t\t\t\"Content-ID: <image.jpg>\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of image.jpg\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_2_--\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_\\r\\n\" +\n\t\t\t\"Content-Type: application/pdf; name=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Disposition: attachment; filename=\\\"test.pdf\\\"\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tbase64.StdEncoding.EncodeToString([]byte(\"Content of test.pdf\")) + \"\\r\\n\" +\n\t\t\t\"--_BOUNDARY_1_--\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 3, want)\n\n\twant = &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\t\"Test reset\",\n\t}\n\tm.Reset()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", \"Test reset\")\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestQpLineLength(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\",\n\t\tstrings.Repeat(\"0\", 76)+\"\\r\\n\"+\n\t\t\tstrings.Repeat(\"0\", 75)+\"à\\r\\n\"+\n\t\t\tstrings.Repeat(\"0\", 74)+\"à\\r\\n\"+\n\t\t\tstrings.Repeat(\"0\", 73)+\"à\\r\\n\"+\n\t\t\tstrings.Repeat(\"0\", 72)+\"à\\r\\n\"+\n\t\t\tstrings.Repeat(\"0\", 75)+\"\\r\\n\"+\n\t\t\tstrings.Repeat(\"0\", 76)+\"\\n\")\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 75) + \"=\\r\\n0\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 75) + \"=\\r\\n=C3=A0\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 74) + \"=\\r\\n=C3=A0\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 73) + \"=\\r\\n=C3=A0\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 72) + \"=C3=\\r\\n=A0\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 75) + \"\\r\\n\" +\n\t\t\tstrings.Repeat(\"0\", 75) + \"=\\r\\n0\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestBase64LineLength(t *testing.T) {\n\tm := NewMessage(SetCharset(\"UTF-8\"), SetEncoding(Base64))\n\tm.SetHeader(\"From\", \"from@example.com\")\n\tm.SetHeader(\"To\", \"to@example.com\")\n\tm.SetBody(\"text/plain\", strings.Repeat(\"0\", 58))\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tto:   []string{\"to@example.com\"},\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"To: to@example.com\\r\\n\" +\n\t\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\t\"Content-Transfer-Encoding: base64\\r\\n\" +\n\t\t\t\"\\r\\n\" +\n\t\t\tstrings.Repeat(\"MDAw\", 19) + \"\\r\\nMA==\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestEmptyName(t *testing.T) {\n\tm := NewMessage()\n\tm.SetAddressHeader(\"From\", \"from@example.com\", \"\")\n\n\twant := &message{\n\t\tfrom:    \"from@example.com\",\n\t\tcontent: \"From: from@example.com\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc TestEmptyHeader(t *testing.T) {\n\tm := NewMessage()\n\tm.SetHeaders(map[string][]string{\n\t\t\"From\":    {\"from@example.com\"},\n\t\t\"X-Empty\": nil,\n\t})\n\n\twant := &message{\n\t\tfrom: \"from@example.com\",\n\t\tcontent: \"From: from@example.com\\r\\n\" +\n\t\t\t\"X-Empty:\\r\\n\",\n\t}\n\n\ttestMessage(t, m, 0, want)\n}\n\nfunc testMessage(t *testing.T, m *Message, bCount int, want *message) {\n\terr := Send(stubSendMail(t, bCount, want), m)\n\tif err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc stubSendMail(t *testing.T, bCount int, want *message) SendFunc {\n\treturn func(from string, to []string, m io.WriterTo) error {\n\t\tif from != want.from {\n\t\t\tt.Fatalf(\"Invalid from, got %q, want %q\", from, want.from)\n\t\t}\n\n\t\tif len(to) != len(want.to) {\n\t\t\tt.Fatalf(\"Invalid recipient count, \\ngot %d: %q\\nwant %d: %q\",\n\t\t\t\tlen(to), to,\n\t\t\t\tlen(want.to), want.to,\n\t\t\t)\n\t\t}\n\t\tfor i := range want.to {\n\t\t\tif to[i] != want.to[i] {\n\t\t\t\tt.Fatalf(\"Invalid recipient, got %q, want %q\",\n\t\t\t\t\tto[i], want.to[i],\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err := m.WriteTo(buf)\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t\tgot := buf.String()\n\t\twantMsg := string(\"Mime-Version: 1.0\\r\\n\" +\n\t\t\t\"Date: Wed, 25 Jun 2014 17:46:00 +0000\\r\\n\" +\n\t\t\twant.content)\n\t\tif bCount > 0 {\n\t\t\tboundaries := getBoundaries(t, bCount, got)\n\t\t\tfor i, b := range boundaries {\n\t\t\t\twantMsg = strings.Replace(wantMsg, \"_BOUNDARY_\"+strconv.Itoa(i+1)+\"_\", b, -1)\n\t\t\t}\n\t\t}\n\n\t\tcompareBodies(t, got, wantMsg)\n\n\t\treturn nil\n\t}\n}\n\nfunc compareBodies(t *testing.T, got, want string) {\n\t// We cannot do a simple comparison since the ordering of headers' fields\n\t// is random.\n\tgotLines := strings.Split(got, \"\\r\\n\")\n\twantLines := strings.Split(want, \"\\r\\n\")\n\n\t// We only test for too many lines, missing lines are tested after\n\tif len(gotLines) > len(wantLines) {\n\t\tt.Fatalf(\"Message has too many lines, \\ngot %d:\\n%s\\nwant %d:\\n%s\", len(gotLines), got, len(wantLines), want)\n\t}\n\n\tisInHeader := true\n\theaderStart := 0\n\tfor i, line := range wantLines {\n\t\tif line == gotLines[i] {\n\t\t\tif line == \"\" {\n\t\t\t\tisInHeader = false\n\t\t\t} else if !isInHeader && len(line) > 2 && line[:2] == \"--\" {\n\t\t\t\tisInHeader = true\n\t\t\t\theaderStart = i + 1\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\tif !isInHeader {\n\t\t\tmissingLine(t, line, got, want)\n\t\t}\n\n\t\tisMissing := true\n\t\tfor j := headerStart; j < len(gotLines); j++ {\n\t\t\tif gotLines[j] == \"\" {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif gotLines[j] == line {\n\t\t\t\tisMissing = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif isMissing {\n\t\t\tmissingLine(t, line, got, want)\n\t\t}\n\t}\n}\n\nfunc missingLine(t *testing.T, line, got, want string) {\n\tt.Fatalf(\"Missing line %q\\ngot:\\n%s\\nwant:\\n%s\", line, got, want)\n}\n\nfunc getBoundaries(t *testing.T, count int, m string) []string {\n\tif matches := boundaryRegExp.FindAllStringSubmatch(m, count); matches != nil {\n\t\tboundaries := make([]string, count)\n\t\tfor i, match := range matches {\n\t\t\tboundaries[i] = match[1]\n\t\t}\n\t\treturn boundaries\n\t}\n\n\tt.Fatal(\"Boundary not found in body\")\n\treturn []string{\"\"}\n}\n\nvar boundaryRegExp = regexp.MustCompile(\"boundary=(\\\\w+)\")\n\nfunc mockCopyFile(name string) (string, FileSetting) {\n\treturn name, SetCopyFunc(func(w io.Writer) error {\n\t\t_, err := w.Write([]byte(\"Content of \" + filepath.Base(name)))\n\t\treturn err\n\t})\n}\n\nfunc mockCopyFileWithHeader(m *Message, name string, h map[string][]string) (string, FileSetting, FileSetting) {\n\tname, f := mockCopyFile(name)\n\treturn name, f, SetHeader(h)\n}\n\nfunc BenchmarkFull(b *testing.B) {\n\tdiscardFunc := SendFunc(func(from string, to []string, m io.WriterTo) error {\n\t\t_, err := m.WriteTo(ioutil.Discard)\n\t\treturn err\n\t})\n\n\tm := NewMessage()\n\tb.ResetTimer()\n\tfor n := 0; n < b.N; n++ {\n\t\tm.SetAddressHeader(\"From\", \"from@example.com\", \"Señor From\")\n\t\tm.SetHeaders(map[string][]string{\n\t\t\t\"To\":      {\"to@example.com\"},\n\t\t\t\"Cc\":      {\"cc@example.com\"},\n\t\t\t\"Bcc\":     {\"bcc1@example.com\", \"bcc2@example.com\"},\n\t\t\t\"Subject\": {\"¡Hola, señor!\"},\n\t\t})\n\t\tm.SetBody(\"text/plain\", \"¡Hola, señor!\")\n\t\tm.AddAlternative(\"text/html\", \"<p>¡Hola, señor!</p>\")\n\t\tm.Attach(mockCopyFile(\"benchmark.txt\"))\n\t\tm.Embed(mockCopyFile(\"benchmark.jpg\"))\n\n\t\tif err := Send(discardFunc, m); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tm.Reset()\n\t}\n}\n"
        },
        {
          "name": "mime.go",
          "type": "blob",
          "size": 0.3095703125,
          "content": "// +build go1.5\n\npackage gomail\n\nimport (\n\t\"mime\"\n\t\"mime/quotedprintable\"\n\t\"strings\"\n)\n\nvar newQPWriter = quotedprintable.NewWriter\n\ntype mimeEncoder struct {\n\tmime.WordEncoder\n}\n\nvar (\n\tbEncoding     = mimeEncoder{mime.BEncoding}\n\tqEncoding     = mimeEncoder{mime.QEncoding}\n\tlastIndexByte = strings.LastIndexByte\n)\n"
        },
        {
          "name": "mime_go14.go",
          "type": "blob",
          "size": 0.4345703125,
          "content": "// +build !go1.5\n\npackage gomail\n\nimport \"gopkg.in/alexcesaro/quotedprintable.v3\"\n\nvar newQPWriter = quotedprintable.NewWriter\n\ntype mimeEncoder struct {\n\tquotedprintable.WordEncoder\n}\n\nvar (\n\tbEncoding     = mimeEncoder{quotedprintable.BEncoding}\n\tqEncoding     = mimeEncoder{quotedprintable.QEncoding}\n\tlastIndexByte = func(s string, c byte) int {\n\t\tfor i := len(s) - 1; i >= 0; i-- {\n\n\t\t\tif s[i] == c {\n\t\t\t\treturn i\n\t\t\t}\n\t\t}\n\t\treturn -1\n\t}\n)\n"
        },
        {
          "name": "send.go",
          "type": "blob",
          "size": 2.3896484375,
          "content": "package gomail\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"net/mail\"\n)\n\n// Sender is the interface that wraps the Send method.\n//\n// Send sends an email to the given addresses.\ntype Sender interface {\n\tSend(from string, to []string, msg io.WriterTo) error\n}\n\n// SendCloser is the interface that groups the Send and Close methods.\ntype SendCloser interface {\n\tSender\n\tClose() error\n}\n\n// A SendFunc is a function that sends emails to the given addresses.\n//\n// The SendFunc type is an adapter to allow the use of ordinary functions as\n// email senders. If f is a function with the appropriate signature, SendFunc(f)\n// is a Sender object that calls f.\ntype SendFunc func(from string, to []string, msg io.WriterTo) error\n\n// Send calls f(from, to, msg).\nfunc (f SendFunc) Send(from string, to []string, msg io.WriterTo) error {\n\treturn f(from, to, msg)\n}\n\n// Send sends emails using the given Sender.\nfunc Send(s Sender, msg ...*Message) error {\n\tfor i, m := range msg {\n\t\tif err := send(s, m); err != nil {\n\t\t\treturn fmt.Errorf(\"gomail: could not send email %d: %v\", i+1, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc send(s Sender, m *Message) error {\n\tfrom, err := m.getFrom()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tto, err := m.getRecipients()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.Send(from, to, m); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (m *Message) getFrom() (string, error) {\n\tfrom := m.header[\"Sender\"]\n\tif len(from) == 0 {\n\t\tfrom = m.header[\"From\"]\n\t\tif len(from) == 0 {\n\t\t\treturn \"\", errors.New(`gomail: invalid message, \"From\" field is absent`)\n\t\t}\n\t}\n\n\treturn parseAddress(from[0])\n}\n\nfunc (m *Message) getRecipients() ([]string, error) {\n\tn := 0\n\tfor _, field := range []string{\"To\", \"Cc\", \"Bcc\"} {\n\t\tif addresses, ok := m.header[field]; ok {\n\t\t\tn += len(addresses)\n\t\t}\n\t}\n\tlist := make([]string, 0, n)\n\n\tfor _, field := range []string{\"To\", \"Cc\", \"Bcc\"} {\n\t\tif addresses, ok := m.header[field]; ok {\n\t\t\tfor _, a := range addresses {\n\t\t\t\taddr, err := parseAddress(a)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\tlist = addAddress(list, addr)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn list, nil\n}\n\nfunc addAddress(list []string, addr string) []string {\n\tfor _, a := range list {\n\t\tif addr == a {\n\t\t\treturn list\n\t\t}\n\t}\n\n\treturn append(list, addr)\n}\n\nfunc parseAddress(field string) (string, error) {\n\taddr, err := mail.ParseAddress(field)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"gomail: invalid address %q: %v\", field, err)\n\t}\n\treturn addr.Address, nil\n}\n"
        },
        {
          "name": "send_test.go",
          "type": "blob",
          "size": 1.6826171875,
          "content": "package gomail\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"reflect\"\n\t\"testing\"\n)\n\nconst (\n\ttestTo1  = \"to1@example.com\"\n\ttestTo2  = \"to2@example.com\"\n\ttestFrom = \"from@example.com\"\n\ttestBody = \"Test message\"\n\ttestMsg  = \"To: \" + testTo1 + \", \" + testTo2 + \"\\r\\n\" +\n\t\t\"From: \" + testFrom + \"\\r\\n\" +\n\t\t\"Mime-Version: 1.0\\r\\n\" +\n\t\t\"Date: Wed, 25 Jun 2014 17:46:00 +0000\\r\\n\" +\n\t\t\"Content-Type: text/plain; charset=UTF-8\\r\\n\" +\n\t\t\"Content-Transfer-Encoding: quoted-printable\\r\\n\" +\n\t\t\"\\r\\n\" +\n\t\ttestBody\n)\n\ntype mockSender SendFunc\n\nfunc (s mockSender) Send(from string, to []string, msg io.WriterTo) error {\n\treturn s(from, to, msg)\n}\n\ntype mockSendCloser struct {\n\tmockSender\n\tclose func() error\n}\n\nfunc (s *mockSendCloser) Close() error {\n\treturn s.close()\n}\n\nfunc TestSend(t *testing.T) {\n\ts := &mockSendCloser{\n\t\tmockSender: stubSend(t, testFrom, []string{testTo1, testTo2}, testMsg),\n\t\tclose: func() error {\n\t\t\tt.Error(\"Close() should not be called in Send()\")\n\t\t\treturn nil\n\t\t},\n\t}\n\tif err := Send(s, getTestMessage()); err != nil {\n\t\tt.Errorf(\"Send(): %v\", err)\n\t}\n}\n\nfunc getTestMessage() *Message {\n\tm := NewMessage()\n\tm.SetHeader(\"From\", testFrom)\n\tm.SetHeader(\"To\", testTo1, testTo2)\n\tm.SetBody(\"text/plain\", testBody)\n\n\treturn m\n}\n\nfunc stubSend(t *testing.T, wantFrom string, wantTo []string, wantBody string) mockSender {\n\treturn func(from string, to []string, msg io.WriterTo) error {\n\t\tif from != wantFrom {\n\t\t\tt.Errorf(\"invalid from, got %q, want %q\", from, wantFrom)\n\t\t}\n\t\tif !reflect.DeepEqual(to, wantTo) {\n\t\t\tt.Errorf(\"invalid to, got %v, want %v\", to, wantTo)\n\t\t}\n\n\t\tbuf := new(bytes.Buffer)\n\t\t_, err := msg.WriteTo(buf)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tcompareBodies(t, buf.String(), wantBody)\n\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "smtp.go",
          "type": "blob",
          "size": 4.4130859375,
          "content": "package gomail\n\nimport (\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"net\"\n\t\"net/smtp\"\n\t\"strings\"\n\t\"time\"\n)\n\n// A Dialer is a dialer to an SMTP server.\ntype Dialer struct {\n\t// Host represents the host of the SMTP server.\n\tHost string\n\t// Port represents the port of the SMTP server.\n\tPort int\n\t// Username is the username to use to authenticate to the SMTP server.\n\tUsername string\n\t// Password is the password to use to authenticate to the SMTP server.\n\tPassword string\n\t// Auth represents the authentication mechanism used to authenticate to the\n\t// SMTP server.\n\tAuth smtp.Auth\n\t// SSL defines whether an SSL connection is used. It should be false in\n\t// most cases since the authentication mechanism should use the STARTTLS\n\t// extension instead.\n\tSSL bool\n\t// TSLConfig represents the TLS configuration used for the TLS (when the\n\t// STARTTLS extension is used) or SSL connection.\n\tTLSConfig *tls.Config\n\t// LocalName is the hostname sent to the SMTP server with the HELO command.\n\t// By default, \"localhost\" is sent.\n\tLocalName string\n}\n\n// NewDialer returns a new SMTP Dialer. The given parameters are used to connect\n// to the SMTP server.\nfunc NewDialer(host string, port int, username, password string) *Dialer {\n\treturn &Dialer{\n\t\tHost:     host,\n\t\tPort:     port,\n\t\tUsername: username,\n\t\tPassword: password,\n\t\tSSL:      port == 465,\n\t}\n}\n\n// NewPlainDialer returns a new SMTP Dialer. The given parameters are used to\n// connect to the SMTP server.\n//\n// Deprecated: Use NewDialer instead.\nfunc NewPlainDialer(host string, port int, username, password string) *Dialer {\n\treturn NewDialer(host, port, username, password)\n}\n\n// Dial dials and authenticates to an SMTP server. The returned SendCloser\n// should be closed when done using it.\nfunc (d *Dialer) Dial() (SendCloser, error) {\n\tconn, err := netDialTimeout(\"tcp\", addr(d.Host, d.Port), 10*time.Second)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif d.SSL {\n\t\tconn = tlsClient(conn, d.tlsConfig())\n\t}\n\n\tc, err := smtpNewClient(conn, d.Host)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif d.LocalName != \"\" {\n\t\tif err := c.Hello(d.LocalName); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tif !d.SSL {\n\t\tif ok, _ := c.Extension(\"STARTTLS\"); ok {\n\t\t\tif err := c.StartTLS(d.tlsConfig()); err != nil {\n\t\t\t\tc.Close()\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\tif d.Auth == nil && d.Username != \"\" {\n\t\tif ok, auths := c.Extension(\"AUTH\"); ok {\n\t\t\tif strings.Contains(auths, \"CRAM-MD5\") {\n\t\t\t\td.Auth = smtp.CRAMMD5Auth(d.Username, d.Password)\n\t\t\t} else if strings.Contains(auths, \"LOGIN\") &&\n\t\t\t\t!strings.Contains(auths, \"PLAIN\") {\n\t\t\t\td.Auth = &loginAuth{\n\t\t\t\t\tusername: d.Username,\n\t\t\t\t\tpassword: d.Password,\n\t\t\t\t\thost:     d.Host,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\td.Auth = smtp.PlainAuth(\"\", d.Username, d.Password, d.Host)\n\t\t\t}\n\t\t}\n\t}\n\n\tif d.Auth != nil {\n\t\tif err = c.Auth(d.Auth); err != nil {\n\t\t\tc.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &smtpSender{c, d}, nil\n}\n\nfunc (d *Dialer) tlsConfig() *tls.Config {\n\tif d.TLSConfig == nil {\n\t\treturn &tls.Config{ServerName: d.Host}\n\t}\n\treturn d.TLSConfig\n}\n\nfunc addr(host string, port int) string {\n\treturn fmt.Sprintf(\"%s:%d\", host, port)\n}\n\n// DialAndSend opens a connection to the SMTP server, sends the given emails and\n// closes the connection.\nfunc (d *Dialer) DialAndSend(m ...*Message) error {\n\ts, err := d.Dial()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer s.Close()\n\n\treturn Send(s, m...)\n}\n\ntype smtpSender struct {\n\tsmtpClient\n\td *Dialer\n}\n\nfunc (c *smtpSender) Send(from string, to []string, msg io.WriterTo) error {\n\tif err := c.Mail(from); err != nil {\n\t\tif err == io.EOF {\n\t\t\t// This is probably due to a timeout, so reconnect and try again.\n\t\t\tsc, derr := c.d.Dial()\n\t\t\tif derr == nil {\n\t\t\t\tif s, ok := sc.(*smtpSender); ok {\n\t\t\t\t\t*c = *s\n\t\t\t\t\treturn c.Send(from, to, msg)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn err\n\t}\n\n\tfor _, addr := range to {\n\t\tif err := c.Rcpt(addr); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tw, err := c.Data()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif _, err = msg.WriteTo(w); err != nil {\n\t\tw.Close()\n\t\treturn err\n\t}\n\n\treturn w.Close()\n}\n\nfunc (c *smtpSender) Close() error {\n\treturn c.Quit()\n}\n\n// Stubbed out for tests.\nvar (\n\tnetDialTimeout = net.DialTimeout\n\ttlsClient      = tls.Client\n\tsmtpNewClient  = func(conn net.Conn, host string) (smtpClient, error) {\n\t\treturn smtp.NewClient(conn, host)\n\t}\n)\n\ntype smtpClient interface {\n\tHello(string) error\n\tExtension(string) (bool, string)\n\tStartTLS(*tls.Config) error\n\tAuth(smtp.Auth) error\n\tMail(string) error\n\tRcpt(string) error\n\tData() (io.WriteCloser, error)\n\tQuit() error\n\tClose() error\n}\n"
        },
        {
          "name": "smtp_test.go",
          "type": "blob",
          "size": 5.5595703125,
          "content": "package gomail\n\nimport (\n\t\"bytes\"\n\t\"crypto/tls\"\n\t\"io\"\n\t\"net\"\n\t\"net/smtp\"\n\t\"reflect\"\n\t\"testing\"\n\t\"time\"\n)\n\nconst (\n\ttestPort    = 587\n\ttestSSLPort = 465\n)\n\nvar (\n\ttestConn    = &net.TCPConn{}\n\ttestTLSConn = &tls.Conn{}\n\ttestConfig  = &tls.Config{InsecureSkipVerify: true}\n\ttestAuth    = smtp.PlainAuth(\"\", testUser, testPwd, testHost)\n)\n\nfunc TestDialer(t *testing.T) {\n\td := NewDialer(testHost, testPort, \"user\", \"pwd\")\n\ttestSendMail(t, d, []string{\n\t\t\"Extension STARTTLS\",\n\t\t\"StartTLS\",\n\t\t\"Extension AUTH\",\n\t\t\"Auth\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Rcpt \" + testTo1,\n\t\t\"Rcpt \" + testTo2,\n\t\t\"Data\",\n\t\t\"Write message\",\n\t\t\"Close writer\",\n\t\t\"Quit\",\n\t\t\"Close\",\n\t})\n}\n\nfunc TestDialerSSL(t *testing.T) {\n\td := NewDialer(testHost, testSSLPort, \"user\", \"pwd\")\n\ttestSendMail(t, d, []string{\n\t\t\"Extension AUTH\",\n\t\t\"Auth\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Rcpt \" + testTo1,\n\t\t\"Rcpt \" + testTo2,\n\t\t\"Data\",\n\t\t\"Write message\",\n\t\t\"Close writer\",\n\t\t\"Quit\",\n\t\t\"Close\",\n\t})\n}\n\nfunc TestDialerConfig(t *testing.T) {\n\td := NewDialer(testHost, testPort, \"user\", \"pwd\")\n\td.LocalName = \"test\"\n\td.TLSConfig = testConfig\n\ttestSendMail(t, d, []string{\n\t\t\"Hello test\",\n\t\t\"Extension STARTTLS\",\n\t\t\"StartTLS\",\n\t\t\"Extension AUTH\",\n\t\t\"Auth\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Rcpt \" + testTo1,\n\t\t\"Rcpt \" + testTo2,\n\t\t\"Data\",\n\t\t\"Write message\",\n\t\t\"Close writer\",\n\t\t\"Quit\",\n\t\t\"Close\",\n\t})\n}\n\nfunc TestDialerSSLConfig(t *testing.T) {\n\td := NewDialer(testHost, testSSLPort, \"user\", \"pwd\")\n\td.LocalName = \"test\"\n\td.TLSConfig = testConfig\n\ttestSendMail(t, d, []string{\n\t\t\"Hello test\",\n\t\t\"Extension AUTH\",\n\t\t\"Auth\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Rcpt \" + testTo1,\n\t\t\"Rcpt \" + testTo2,\n\t\t\"Data\",\n\t\t\"Write message\",\n\t\t\"Close writer\",\n\t\t\"Quit\",\n\t\t\"Close\",\n\t})\n}\n\nfunc TestDialerNoAuth(t *testing.T) {\n\td := &Dialer{\n\t\tHost: testHost,\n\t\tPort: testPort,\n\t}\n\ttestSendMail(t, d, []string{\n\t\t\"Extension STARTTLS\",\n\t\t\"StartTLS\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Rcpt \" + testTo1,\n\t\t\"Rcpt \" + testTo2,\n\t\t\"Data\",\n\t\t\"Write message\",\n\t\t\"Close writer\",\n\t\t\"Quit\",\n\t\t\"Close\",\n\t})\n}\n\nfunc TestDialerTimeout(t *testing.T) {\n\td := &Dialer{\n\t\tHost: testHost,\n\t\tPort: testPort,\n\t}\n\ttestSendMailTimeout(t, d, []string{\n\t\t\"Extension STARTTLS\",\n\t\t\"StartTLS\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Extension STARTTLS\",\n\t\t\"StartTLS\",\n\t\t\"Mail \" + testFrom,\n\t\t\"Rcpt \" + testTo1,\n\t\t\"Rcpt \" + testTo2,\n\t\t\"Data\",\n\t\t\"Write message\",\n\t\t\"Close writer\",\n\t\t\"Quit\",\n\t\t\"Close\",\n\t})\n}\n\ntype mockClient struct {\n\tt       *testing.T\n\ti       int\n\twant    []string\n\taddr    string\n\tconfig  *tls.Config\n\ttimeout bool\n}\n\nfunc (c *mockClient) Hello(localName string) error {\n\tc.do(\"Hello \" + localName)\n\treturn nil\n}\n\nfunc (c *mockClient) Extension(ext string) (bool, string) {\n\tc.do(\"Extension \" + ext)\n\treturn true, \"\"\n}\n\nfunc (c *mockClient) StartTLS(config *tls.Config) error {\n\tassertConfig(c.t, config, c.config)\n\tc.do(\"StartTLS\")\n\treturn nil\n}\n\nfunc (c *mockClient) Auth(a smtp.Auth) error {\n\tif !reflect.DeepEqual(a, testAuth) {\n\t\tc.t.Errorf(\"Invalid auth, got %#v, want %#v\", a, testAuth)\n\t}\n\tc.do(\"Auth\")\n\treturn nil\n}\n\nfunc (c *mockClient) Mail(from string) error {\n\tc.do(\"Mail \" + from)\n\tif c.timeout {\n\t\tc.timeout = false\n\t\treturn io.EOF\n\t}\n\treturn nil\n}\n\nfunc (c *mockClient) Rcpt(to string) error {\n\tc.do(\"Rcpt \" + to)\n\treturn nil\n}\n\nfunc (c *mockClient) Data() (io.WriteCloser, error) {\n\tc.do(\"Data\")\n\treturn &mockWriter{c: c, want: testMsg}, nil\n}\n\nfunc (c *mockClient) Quit() error {\n\tc.do(\"Quit\")\n\treturn nil\n}\n\nfunc (c *mockClient) Close() error {\n\tc.do(\"Close\")\n\treturn nil\n}\n\nfunc (c *mockClient) do(cmd string) {\n\tif c.i >= len(c.want) {\n\t\tc.t.Fatalf(\"Invalid command %q\", cmd)\n\t}\n\n\tif cmd != c.want[c.i] {\n\t\tc.t.Fatalf(\"Invalid command, got %q, want %q\", cmd, c.want[c.i])\n\t}\n\tc.i++\n}\n\ntype mockWriter struct {\n\twant string\n\tc    *mockClient\n\tbuf  bytes.Buffer\n}\n\nfunc (w *mockWriter) Write(p []byte) (int, error) {\n\tif w.buf.Len() == 0 {\n\t\tw.c.do(\"Write message\")\n\t}\n\tw.buf.Write(p)\n\treturn len(p), nil\n}\n\nfunc (w *mockWriter) Close() error {\n\tcompareBodies(w.c.t, w.buf.String(), w.want)\n\tw.c.do(\"Close writer\")\n\treturn nil\n}\n\nfunc testSendMail(t *testing.T, d *Dialer, want []string) {\n\tdoTestSendMail(t, d, want, false)\n}\n\nfunc testSendMailTimeout(t *testing.T, d *Dialer, want []string) {\n\tdoTestSendMail(t, d, want, true)\n}\n\nfunc doTestSendMail(t *testing.T, d *Dialer, want []string, timeout bool) {\n\ttestClient := &mockClient{\n\t\tt:       t,\n\t\twant:    want,\n\t\taddr:    addr(d.Host, d.Port),\n\t\tconfig:  d.TLSConfig,\n\t\ttimeout: timeout,\n\t}\n\n\tnetDialTimeout = func(network, address string, d time.Duration) (net.Conn, error) {\n\t\tif network != \"tcp\" {\n\t\t\tt.Errorf(\"Invalid network, got %q, want tcp\", network)\n\t\t}\n\t\tif address != testClient.addr {\n\t\t\tt.Errorf(\"Invalid address, got %q, want %q\",\n\t\t\t\taddress, testClient.addr)\n\t\t}\n\t\treturn testConn, nil\n\t}\n\n\ttlsClient = func(conn net.Conn, config *tls.Config) *tls.Conn {\n\t\tif conn != testConn {\n\t\t\tt.Errorf(\"Invalid conn, got %#v, want %#v\", conn, testConn)\n\t\t}\n\t\tassertConfig(t, config, testClient.config)\n\t\treturn testTLSConn\n\t}\n\n\tsmtpNewClient = func(conn net.Conn, host string) (smtpClient, error) {\n\t\tif host != testHost {\n\t\t\tt.Errorf(\"Invalid host, got %q, want %q\", host, testHost)\n\t\t}\n\t\treturn testClient, nil\n\t}\n\n\tif err := d.DialAndSend(getTestMessage()); err != nil {\n\t\tt.Error(err)\n\t}\n}\n\nfunc assertConfig(t *testing.T, got, want *tls.Config) {\n\tif want == nil {\n\t\twant = &tls.Config{ServerName: testHost}\n\t}\n\tif got.ServerName != want.ServerName {\n\t\tt.Errorf(\"Invalid field ServerName in config, got %q, want %q\", got.ServerName, want.ServerName)\n\t}\n\tif got.InsecureSkipVerify != want.InsecureSkipVerify {\n\t\tt.Errorf(\"Invalid field InsecureSkipVerify in config, got %v, want %v\", got.InsecureSkipVerify, want.InsecureSkipVerify)\n\t}\n}\n"
        },
        {
          "name": "writeto.go",
          "type": "blob",
          "size": 6.5654296875,
          "content": "package gomail\n\nimport (\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"time\"\n)\n\n// WriteTo implements io.WriterTo. It dumps the whole message into w.\nfunc (m *Message) WriteTo(w io.Writer) (int64, error) {\n\tmw := &messageWriter{w: w}\n\tmw.writeMessage(m)\n\treturn mw.n, mw.err\n}\n\nfunc (w *messageWriter) writeMessage(m *Message) {\n\tif _, ok := m.header[\"Mime-Version\"]; !ok {\n\t\tw.writeString(\"Mime-Version: 1.0\\r\\n\")\n\t}\n\tif _, ok := m.header[\"Date\"]; !ok {\n\t\tw.writeHeader(\"Date\", m.FormatDate(now()))\n\t}\n\tw.writeHeaders(m.header)\n\n\tif m.hasMixedPart() {\n\t\tw.openMultipart(\"mixed\")\n\t}\n\n\tif m.hasRelatedPart() {\n\t\tw.openMultipart(\"related\")\n\t}\n\n\tif m.hasAlternativePart() {\n\t\tw.openMultipart(\"alternative\")\n\t}\n\tfor _, part := range m.parts {\n\t\tw.writePart(part, m.charset)\n\t}\n\tif m.hasAlternativePart() {\n\t\tw.closeMultipart()\n\t}\n\n\tw.addFiles(m.embedded, false)\n\tif m.hasRelatedPart() {\n\t\tw.closeMultipart()\n\t}\n\n\tw.addFiles(m.attachments, true)\n\tif m.hasMixedPart() {\n\t\tw.closeMultipart()\n\t}\n}\n\nfunc (m *Message) hasMixedPart() bool {\n\treturn (len(m.parts) > 0 && len(m.attachments) > 0) || len(m.attachments) > 1\n}\n\nfunc (m *Message) hasRelatedPart() bool {\n\treturn (len(m.parts) > 0 && len(m.embedded) > 0) || len(m.embedded) > 1\n}\n\nfunc (m *Message) hasAlternativePart() bool {\n\treturn len(m.parts) > 1\n}\n\ntype messageWriter struct {\n\tw          io.Writer\n\tn          int64\n\twriters    [3]*multipart.Writer\n\tpartWriter io.Writer\n\tdepth      uint8\n\terr        error\n}\n\nfunc (w *messageWriter) openMultipart(mimeType string) {\n\tmw := multipart.NewWriter(w)\n\tcontentType := \"multipart/\" + mimeType + \";\\r\\n boundary=\" + mw.Boundary()\n\tw.writers[w.depth] = mw\n\n\tif w.depth == 0 {\n\t\tw.writeHeader(\"Content-Type\", contentType)\n\t\tw.writeString(\"\\r\\n\")\n\t} else {\n\t\tw.createPart(map[string][]string{\n\t\t\t\"Content-Type\": {contentType},\n\t\t})\n\t}\n\tw.depth++\n}\n\nfunc (w *messageWriter) createPart(h map[string][]string) {\n\tw.partWriter, w.err = w.writers[w.depth-1].CreatePart(h)\n}\n\nfunc (w *messageWriter) closeMultipart() {\n\tif w.depth > 0 {\n\t\tw.writers[w.depth-1].Close()\n\t\tw.depth--\n\t}\n}\n\nfunc (w *messageWriter) writePart(p *part, charset string) {\n\tw.writeHeaders(map[string][]string{\n\t\t\"Content-Type\":              {p.contentType + \"; charset=\" + charset},\n\t\t\"Content-Transfer-Encoding\": {string(p.encoding)},\n\t})\n\tw.writeBody(p.copier, p.encoding)\n}\n\nfunc (w *messageWriter) addFiles(files []*file, isAttachment bool) {\n\tfor _, f := range files {\n\t\tif _, ok := f.Header[\"Content-Type\"]; !ok {\n\t\t\tmediaType := mime.TypeByExtension(filepath.Ext(f.Name))\n\t\t\tif mediaType == \"\" {\n\t\t\t\tmediaType = \"application/octet-stream\"\n\t\t\t}\n\t\t\tf.setHeader(\"Content-Type\", mediaType+`; name=\"`+f.Name+`\"`)\n\t\t}\n\n\t\tif _, ok := f.Header[\"Content-Transfer-Encoding\"]; !ok {\n\t\t\tf.setHeader(\"Content-Transfer-Encoding\", string(Base64))\n\t\t}\n\n\t\tif _, ok := f.Header[\"Content-Disposition\"]; !ok {\n\t\t\tvar disp string\n\t\t\tif isAttachment {\n\t\t\t\tdisp = \"attachment\"\n\t\t\t} else {\n\t\t\t\tdisp = \"inline\"\n\t\t\t}\n\t\t\tf.setHeader(\"Content-Disposition\", disp+`; filename=\"`+f.Name+`\"`)\n\t\t}\n\n\t\tif !isAttachment {\n\t\t\tif _, ok := f.Header[\"Content-ID\"]; !ok {\n\t\t\t\tf.setHeader(\"Content-ID\", \"<\"+f.Name+\">\")\n\t\t\t}\n\t\t}\n\t\tw.writeHeaders(f.Header)\n\t\tw.writeBody(f.CopyFunc, Base64)\n\t}\n}\n\nfunc (w *messageWriter) Write(p []byte) (int, error) {\n\tif w.err != nil {\n\t\treturn 0, errors.New(\"gomail: cannot write as writer is in error\")\n\t}\n\n\tvar n int\n\tn, w.err = w.w.Write(p)\n\tw.n += int64(n)\n\treturn n, w.err\n}\n\nfunc (w *messageWriter) writeString(s string) {\n\tn, _ := io.WriteString(w.w, s)\n\tw.n += int64(n)\n}\n\nfunc (w *messageWriter) writeHeader(k string, v ...string) {\n\tw.writeString(k)\n\tif len(v) == 0 {\n\t\tw.writeString(\":\\r\\n\")\n\t\treturn\n\t}\n\tw.writeString(\": \")\n\n\t// Max header line length is 78 characters in RFC 5322 and 76 characters\n\t// in RFC 2047. So for the sake of simplicity we use the 76 characters\n\t// limit.\n\tcharsLeft := 76 - len(k) - len(\": \")\n\n\tfor i, s := range v {\n\t\t// If the line is already too long, insert a newline right away.\n\t\tif charsLeft < 1 {\n\t\t\tif i == 0 {\n\t\t\t\tw.writeString(\"\\r\\n \")\n\t\t\t} else {\n\t\t\t\tw.writeString(\",\\r\\n \")\n\t\t\t}\n\t\t\tcharsLeft = 75\n\t\t} else if i != 0 {\n\t\t\tw.writeString(\", \")\n\t\t\tcharsLeft -= 2\n\t\t}\n\n\t\t// While the header content is too long, fold it by inserting a newline.\n\t\tfor len(s) > charsLeft {\n\t\t\ts = w.writeLine(s, charsLeft)\n\t\t\tcharsLeft = 75\n\t\t}\n\t\tw.writeString(s)\n\t\tif i := lastIndexByte(s, '\\n'); i != -1 {\n\t\t\tcharsLeft = 75 - (len(s) - i - 1)\n\t\t} else {\n\t\t\tcharsLeft -= len(s)\n\t\t}\n\t}\n\tw.writeString(\"\\r\\n\")\n}\n\nfunc (w *messageWriter) writeLine(s string, charsLeft int) string {\n\t// If there is already a newline before the limit. Write the line.\n\tif i := strings.IndexByte(s, '\\n'); i != -1 && i < charsLeft {\n\t\tw.writeString(s[:i+1])\n\t\treturn s[i+1:]\n\t}\n\n\tfor i := charsLeft - 1; i >= 0; i-- {\n\t\tif s[i] == ' ' {\n\t\t\tw.writeString(s[:i])\n\t\t\tw.writeString(\"\\r\\n \")\n\t\t\treturn s[i+1:]\n\t\t}\n\t}\n\n\t// We could not insert a newline cleanly so look for a space or a newline\n\t// even if it is after the limit.\n\tfor i := 75; i < len(s); i++ {\n\t\tif s[i] == ' ' {\n\t\t\tw.writeString(s[:i])\n\t\t\tw.writeString(\"\\r\\n \")\n\t\t\treturn s[i+1:]\n\t\t}\n\t\tif s[i] == '\\n' {\n\t\t\tw.writeString(s[:i+1])\n\t\t\treturn s[i+1:]\n\t\t}\n\t}\n\n\t// Too bad, no space or newline in the whole string. Just write everything.\n\tw.writeString(s)\n\treturn \"\"\n}\n\nfunc (w *messageWriter) writeHeaders(h map[string][]string) {\n\tif w.depth == 0 {\n\t\tfor k, v := range h {\n\t\t\tif k != \"Bcc\" {\n\t\t\t\tw.writeHeader(k, v...)\n\t\t\t}\n\t\t}\n\t} else {\n\t\tw.createPart(h)\n\t}\n}\n\nfunc (w *messageWriter) writeBody(f func(io.Writer) error, enc Encoding) {\n\tvar subWriter io.Writer\n\tif w.depth == 0 {\n\t\tw.writeString(\"\\r\\n\")\n\t\tsubWriter = w.w\n\t} else {\n\t\tsubWriter = w.partWriter\n\t}\n\n\tif enc == Base64 {\n\t\twc := base64.NewEncoder(base64.StdEncoding, newBase64LineWriter(subWriter))\n\t\tw.err = f(wc)\n\t\twc.Close()\n\t} else if enc == Unencoded {\n\t\tw.err = f(subWriter)\n\t} else {\n\t\twc := newQPWriter(subWriter)\n\t\tw.err = f(wc)\n\t\twc.Close()\n\t}\n}\n\n// As required by RFC 2045, 6.7. (page 21) for quoted-printable, and\n// RFC 2045, 6.8. (page 25) for base64.\nconst maxLineLen = 76\n\n// base64LineWriter limits text encoded in base64 to 76 characters per line\ntype base64LineWriter struct {\n\tw       io.Writer\n\tlineLen int\n}\n\nfunc newBase64LineWriter(w io.Writer) *base64LineWriter {\n\treturn &base64LineWriter{w: w}\n}\n\nfunc (w *base64LineWriter) Write(p []byte) (int, error) {\n\tn := 0\n\tfor len(p)+w.lineLen > maxLineLen {\n\t\tw.w.Write(p[:maxLineLen-w.lineLen])\n\t\tw.w.Write([]byte(\"\\r\\n\"))\n\t\tp = p[maxLineLen-w.lineLen:]\n\t\tn += maxLineLen - w.lineLen\n\t\tw.lineLen = 0\n\t}\n\n\tw.w.Write(p)\n\tw.lineLen += len(p)\n\n\treturn n + len(p), nil\n}\n\n// Stubbed out for testing.\nvar now = time.Now\n"
        }
      ]
    }
  ]
}