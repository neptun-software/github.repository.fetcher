{
  "metadata": {
    "timestamp": 1736566820585,
    "page": 387,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjM5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "jasonlvhit/gocron",
      "stars": 3473,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.279296875,
          "content": "# Compiled Object files, Static and Dynamic libs (Shared Objects)\n*.o\n*.a\n*.so\n\n# Folders\n_obj\n_test\n\n# Architecture specific extensions/prefixes\n*.[568vq]\n[568vq].out\n\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n\n_testmain.go\n\n*.exe\n*.test\n\n# IDE project files\n.idea\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2626953125,
          "content": "Copyright (c) 2014, 辣椒面\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.5087890625,
          "content": "### Note from current maintainers:\nA currently maintained fork of this project has been migrated to https://github.com/go-co-op/gocron\n\nDisclaimer: we (the maintainers) tried, with no luck, to get in contact with Jason (the repository owner) in order to add new maintainers or leave the project within an organization. Unfortunately, he hasn't replied for months now (March, 2020). \n\nSo, we decided to move the project to a new repository (as stated above), in order to keep the evolution of the project coming from as many people as possible. Feel free to reach over!\n \n## goCron: A Golang Job Scheduling Package.\n\nThis package is currently looking for new maintainers (cause @jasonlvhit is in [ICU](https://github.com/996icu/996.ICU)). Please message @jasonlvhit if you are interested.\n\n[![GgoDoc](https://godoc.org/github.com/golang/gddo?status.svg)](http://godoc.org/github.com/jasonlvhit/gocron)\n[![Go Report Card](https://goreportcard.com/badge/github.com/jasonlvhit/gocron)](https://goreportcard.com/report/github.com/jasonlvhit/gocron)\n\ngoCron is a Golang job scheduling package which lets you run Go functions periodically at pre-determined interval using a simple, human-friendly syntax.\n\ngoCron is a Golang implementation of Ruby module [clockwork](https://github.com/tomykaira/clockwork) and Python job scheduling package [schedule](https://github.com/dbader/schedule), and personally, this package is my first Golang program, just for fun and practice.\n\nSee also this two great articles:\n\n- [Rethinking Cron](http://adam.herokuapp.com/past/2010/4/13/rethinking_cron/)\n- [Replace Cron with Clockwork](http://adam.herokuapp.com/past/2010/6/30/replace_cron_with_clockwork/)\n\nIf you want to chat, you can find us at Slack! [<img src=\"https://img.shields.io/badge/gophers-gocron-brightgreen?logo=slack\">](https://gophers.slack.com/archives/CQ7T0T1FW)\n\n\nBack to this package, you could just use this simple API as below, to run a cron scheduler.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/jasonlvhit/gocron\"\n)\n\nfunc task() {\n\tfmt.Println(\"I am running task.\")\n}\n\nfunc taskWithParams(a int, b string) {\n\tfmt.Println(a, b)\n}\n\nfunc main() {\n\t// Do jobs without params\n\tgocron.Every(1).Second().Do(task)\n\tgocron.Every(2).Seconds().Do(task)\n\tgocron.Every(1).Minute().Do(task)\n\tgocron.Every(2).Minutes().Do(task)\n\tgocron.Every(1).Hour().Do(task)\n\tgocron.Every(2).Hours().Do(task)\n\tgocron.Every(1).Day().Do(task)\n\tgocron.Every(2).Days().Do(task)\n\tgocron.Every(1).Week().Do(task)\n\tgocron.Every(2).Weeks().Do(task)\n\n\t// Do jobs with params\n\tgocron.Every(1).Second().Do(taskWithParams, 1, \"hello\")\n\n\t// Do jobs on specific weekday\n\tgocron.Every(1).Monday().Do(task)\n\tgocron.Every(1).Thursday().Do(task)\n\n\t// Do a job at a specific time - 'hour:min:sec' - seconds optional\n\tgocron.Every(1).Day().At(\"10:30\").Do(task)\n\tgocron.Every(1).Monday().At(\"18:30\").Do(task)\n\tgocron.Every(1).Tuesday().At(\"18:30:59\").Do(task)\n\n\t// Begin job immediately upon start\n\tgocron.Every(1).Hour().From(gocron.NextTick()).Do(task)\n\n\t// Begin job at a specific date/time\n\tt := time.Date(2019, time.November, 10, 15, 0, 0, 0, time.Local)\n\tgocron.Every(1).Hour().From(&t).Do(task)\n\n\t// NextRun gets the next running time\n\t_, time := gocron.NextRun()\n\tfmt.Println(time)\n\n\t// Remove a specific job\n\tgocron.Remove(task)\n\n\t// Clear all scheduled jobs\n\tgocron.Clear()\n\n\t// Start all the pending jobs\n\t<- gocron.Start()\n\n\t// also, you can create a new scheduler\n\t// to run two schedulers concurrently\n\ts := gocron.NewScheduler()\n\ts.Every(3).Seconds().Do(task)\n\t<- s.Start()\n}\n```\n\nand full test cases and [document](http://godoc.org/github.com/jasonlvhit/gocron) will be coming soon (help is wanted! If you want to contribute, pull requests are welcome).\n\nIf you need to prevent a job from running at the same time from multiple cron instances (like running a cron app from multiple servers),\nyou can provide a [Locker implementation](example/lock.go) and lock the required jobs.\n\n```go\ngocron.SetLocker(lockerImplementation)\ngocron.Every(1).Hour().Lock().Do(task)\n```\n\nOnce again, thanks to the great works of Ruby clockwork and Python schedule package. BSD license is used, see the file License for detail.\n\nLooking to contribute? Try to follow these guidelines:\n * Use issues for everything\n * For a small change, just send a PR!\n * For bigger changes, please open an issue for discussion before sending a PR.\n * PRs should have: tests, documentation and examples (if it makes sense)\n * You can also contribute by:\n    * Reporting issues\n    * Suggesting new features or enhancements\n    * Improving/fixing documentation\n\nHave fun!\n"
        },
        {
          "name": "example",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.0869140625,
          "content": "module github.com/jasonlvhit/gocron\n\ngo 1.13\n\nrequire github.com/stretchr/testify v1.7.0\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1,
          "content": "github.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gocron.go",
          "type": "blob",
          "size": 3.6142578125,
          "content": "// Package gocron : A Golang Job Scheduling Package.\n//\n// Note from current maintainers:\n//\n// A currently maintained fork of this project has been migrated to https://github.com/go-co-op/gocron\n//\n// Disclaimer: we (the maintainers) tried, with no luck, to get in contact with Jason (the repository owner) in order to add new maintainers or leave the project within an organization. Unfortunately, he hasn't replied for months now (March, 2020).\n//\n// So, we decided to move the project to a new repository (as stated above), in order to keep the evolution of the project coming from as many people as possible. Feel free to reach over!\n//\n// An in-process scheduler for periodic jobs that uses the builder pattern\n// for configuration. Schedule lets you run Golang functions periodically\n// at pre-determined intervals using a simple, human-friendly syntax.\n//\n// Inspired by the Ruby module clockwork <https://github.com/tomykaira/clockwork>\n// and\n// Python package schedule <https://github.com/dbader/schedule>\n//\n// See also\n// http://adam.heroku.com/past/2010/4/13/rethinking_cron/\n// http://adam.heroku.com/past/2010/6/30/replace_cron_with_clockwork/\n//\n// Copyright 2014 Jason Lyu. jasonlvhit@gmail.com .\n// All rights reserved.\n// Use of this source code is governed by a BSD-style .\n// license that can be found in the LICENSE file.\npackage gocron\n\nimport (\n\t\"crypto/sha256\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\n// Locker provides a method to lock jobs from running\n// at the same time on multiple instances of gocron.\n// You can provide any locker implementation you wish.\ntype Locker interface {\n\tLock(key string) (bool, error)\n\tUnlock(key string) error\n}\n\ntype timeUnit int\n\n// MAXJOBNUM max number of jobs, hack it if you need.\nconst MAXJOBNUM = 10000\n\n//go:generate stringer -type=timeUnit\nconst (\n\tseconds timeUnit = iota + 1\n\tminutes\n\thours\n\tdays\n\tweeks\n)\n\nvar (\n\tloc    = time.Local // Time location, default set by the time.Local (*time.Location)\n\tlocker Locker\n)\n\n// ChangeLoc change default the time location\nfunc ChangeLoc(newLocation *time.Location) {\n\tloc = newLocation\n\tdefaultScheduler.ChangeLoc(newLocation)\n}\n\n// SetLocker sets a locker implementation\nfunc SetLocker(l Locker) {\n\tlocker = l\n}\n\nfunc callJobFuncWithParams(jobFunc interface{}, params []interface{}) ([]reflect.Value, error) {\n\tf := reflect.ValueOf(jobFunc)\n\tif len(params) != f.Type().NumIn() {\n\t\treturn nil, ErrParamsNotAdapted\n\t}\n\tin := make([]reflect.Value, len(params))\n\tfor k, param := range params {\n\t\tin[k] = reflect.ValueOf(param)\n\t}\n\treturn f.Call(in), nil\n}\n\n// for given function fn, get the name of function.\nfunc getFunctionName(fn interface{}) string {\n\treturn runtime.FuncForPC(reflect.ValueOf(fn).Pointer()).Name()\n}\n\nfunc getFunctionKey(funcName string) string {\n\th := sha256.New()\n\th.Write([]byte(funcName))\n\treturn fmt.Sprintf(\"%x\", h.Sum(nil))\n}\n\n// Jobs returns the list of Jobs from the defaultScheduler\nfunc Jobs() []*Job {\n\treturn defaultScheduler.Jobs()\n}\n\nfunc formatTime(t string) (hour, min, sec int, err error) {\n\tts := strings.Split(t, \":\")\n\tif len(ts) < 2 || len(ts) > 3 {\n\t\treturn 0, 0, 0, ErrTimeFormat\n\t}\n\n\tif hour, err = strconv.Atoi(ts[0]); err != nil {\n\t\treturn 0, 0, 0, err\n\t}\n\tif min, err = strconv.Atoi(ts[1]); err != nil {\n\t\treturn 0, 0, 0, err\n\t}\n\tif len(ts) == 3 {\n\t\tif sec, err = strconv.Atoi(ts[2]); err != nil {\n\t\t\treturn 0, 0, 0, err\n\t\t}\n\t}\n\n\tif hour < 0 || hour > 23 || min < 0 || min > 59 || sec < 0 || sec > 59 {\n\t\treturn 0, 0, 0, ErrTimeFormat\n\t}\n\n\treturn hour, min, sec, nil\n}\n\n// NextTick returns a pointer to a time that will run at the next tick\nfunc NextTick() *time.Time {\n\tnow := time.Now().Add(time.Second)\n\treturn &now\n}\n"
        },
        {
          "name": "gocron_test.go",
          "type": "blob",
          "size": 18.244140625,
          "content": "package gocron\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc task() {\n\tfmt.Println(\"I am a running job.\")\n}\n\nfunc taskWithParams(a int, b string) {\n\tfmt.Println(a, b)\n}\n\nfunc TestSecond(t *testing.T) {\n\tsched := NewScheduler()\n\tjob := sched.Every(1).Second()\n\ttestJobWithInterval(t, sched, job, 1)\n}\n\nfunc TestSeconds(t *testing.T) {\n\tsched := NewScheduler()\n\tjob := sched.Every(2).Seconds()\n\ttestJobWithInterval(t, sched, job, 2)\n}\n\nfunc testJobWithInterval(t *testing.T, sched *Scheduler, job *Job, expectedTimeBetweenRuns int64) {\n\tjobDone := make(chan bool)\n\texecutionTimes := make([]int64, 0)\n\tnumberOfIterations := 2\n\n\tjob.Do(func() {\n\t\texecutionTimes = append(executionTimes, time.Now().Unix())\n\t\tif len(executionTimes) >= numberOfIterations {\n\t\t\tjobDone <- true\n\t\t}\n\t})\n\n\tstop := sched.Start()\n\t<-jobDone // Wait job done\n\tclose(stop)\n\n\tassert.Equal(t, numberOfIterations, len(executionTimes), \"did not run expected number of times\")\n\n\tfor i := 1; i < numberOfIterations; i++ {\n\t\tdurationBetweenExecutions := executionTimes[i] - executionTimes[i-1]\n\t\tassert.Equal(t, expectedTimeBetweenRuns, durationBetweenExecutions, \"Duration between tasks does not correspond to expectations\")\n\t}\n}\n\nfunc TestSafeExecution(t *testing.T) {\n\tsched := NewScheduler()\n\tsuccess := false\n\tvar wc sync.WaitGroup\n\twc.Add(1)\n\n\tsched.Every(1).Second().Do(func(mutableValue *bool) {\n\t\t*mutableValue = !*mutableValue\n\t\twc.Done()\n\t}, &success)\n\n\tsched.RunAll()\n\twc.Wait()\n\n\tassert.Equal(t, true, success, \"Task did not get called\")\n}\n\nfunc TestSafeExecutionWithPanic(t *testing.T) {\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tt.Errorf(\"Unexpected internal panic occurred: %s\", r)\n\t\t}\n\t}()\n\n\tsched := NewScheduler()\n\tsched.Every(1).Second().DoSafely(func() {\n\t\tlog.Panic(\"I am panicking!\")\n\t})\n\tsched.RunAll()\n}\n\nfunc TestScheduled(t *testing.T) {\n\tn := NewScheduler()\n\tn.Every(1).Second().Do(task)\n\tif !n.Scheduled(task) {\n\t\tt.Fatal(\"Task was scheduled but function couldn't find it\")\n\t}\n}\n\n// This is a basic test for the issue described here: https://github.com/jasonlvhit/gocron/issues/23\nfunc TestScheduler_Weekdays(t *testing.T) {\n\tscheduler := NewScheduler()\n\n\tjob1 := scheduler.Every(1).Monday().At(\"23:59\")\n\tjob2 := scheduler.Every(1).Wednesday().At(\"23:59\")\n\tjob1.Do(task)\n\tjob2.Do(task)\n\tt.Logf(\"job1 scheduled for %s\", job1.NextScheduledTime())\n\tt.Logf(\"job2 scheduled for %s\", job2.NextScheduledTime())\n\tassert.NotEqual(t, job1.NextScheduledTime(), job2.NextScheduledTime(), \"Two jobs scheduled at the same time on two different weekdays should never run at the same time\")\n}\n\n// This ensures that if you schedule a job for today's weekday, but the time is already passed, it will be scheduled for\n// next week at the requested time.\nfunc TestScheduler_WeekdaysTodayAfter(t *testing.T) {\n\tscheduler := NewScheduler()\n\n\tnow := time.Now()\n\ttimeToSchedule := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute()-1, 0, 0, time.Local)\n\n\tjob := callTodaysWeekday(scheduler.Every(1)).At(fmt.Sprintf(\"%02d:%02d\", timeToSchedule.Hour(), timeToSchedule.Minute()))\n\tjob.Do(task)\n\tt.Logf(\"job is scheduled for %s\", job.NextScheduledTime())\n\tif job.NextScheduledTime().Weekday() != timeToSchedule.Weekday() {\n\t\tt.Errorf(\"Job scheduled for current weekday for earlier time, should still be scheduled for current weekday (but next week)\")\n\t}\n\tnextWeek := time.Date(now.Year(), now.Month(), now.Day()+7, now.Hour(), now.Minute()-1, 0, 0, time.Local)\n\tif !job.NextScheduledTime().Equal(nextWeek) {\n\t\tt.Errorf(\"Job should be scheduled for the correct time next week.\\nGot %+v, expected %+v\", job.NextScheduledTime(), nextWeek)\n\t}\n}\n\nfunc TestScheduler_JobLocsSetProperly(t *testing.T) {\n\tdefaultScheduledJob := NewJob(10)\n\tassert.Equal(t, defaultScheduledJob.loc, time.Local)\n\tdefaultScheduledJobFromScheduler := Every(10)\n\tassert.Equal(t, defaultScheduledJobFromScheduler.loc, time.Local)\n\n\tlaLocation, err := time.LoadLocation(\"America/Los_Angeles\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable to load America/Los_Angeles time location\")\n\t}\n\n\tChangeLoc(laLocation)\n\tmodifiedGlobalLocJob := NewJob(10)\n\tassert.Equal(t, modifiedGlobalLocJob.loc, laLocation)\n\tmodifiedGlobalLocJobFromScheduler := Every(10)\n\tassert.Equal(t, modifiedGlobalLocJobFromScheduler.loc, laLocation)\n\n\tchiLocation, err := time.LoadLocation(\"America/Chicago\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable to load America/Chicago time location\")\n\t}\n\n\tscheduler := NewScheduler()\n\tscheduler.ChangeLoc(chiLocation)\n\tmodifiedGlobalLocJobFromScheduler = scheduler.Every(10)\n\tassert.Equal(t, modifiedGlobalLocJobFromScheduler.loc, chiLocation)\n\n\t// other tests depend on global state :(\n\tChangeLoc(time.Local)\n}\n\nfunc TestScheduleNextRunLoc(t *testing.T) {\n\tlaLocation, err := time.LoadLocation(\"America/Los_Angeles\")\n\tif err != nil {\n\t\tt.Fatalf(\"unable to load America/Los_Angeles time location\")\n\t}\n\n\tsched := NewScheduler()\n\tsched.ChangeLoc(time.UTC)\n\n\tjob := sched.Every(1).Day().At(\"20:44\")\n\n\t// job just ran (this is 20:45 UTC), so next run should be tomorrow\n\ttoday := time.Now().In(laLocation)\n\tjob.lastRun = time.Date(today.Year(), today.Month(), today.Day(), 13, 45, 0, 0, laLocation)\n\tjob.Do(task)\n\n\ttomorrow := today.AddDate(0, 0, 1)\n\tassert.Equal(t, 20, job.NextScheduledTime().UTC().Hour())\n\tassert.Equal(t, 44, job.NextScheduledTime().UTC().Minute())\n\tassert.Equal(t, tomorrow.Day(), job.NextScheduledTime().UTC().Day())\n}\n\nfunc TestScheduleNextRunFromNow(t *testing.T) {\n\tnow := time.Now()\n\n\tsched := NewScheduler()\n\tsched.ChangeLoc(time.UTC)\n\n\tjob := sched.Every(1).Hour().From(NextTick())\n\tjob.Do(task)\n\n\tnext := job.NextScheduledTime()\n\tnextRounded := time.Date(next.Year(), next.Month(), next.Day(), next.Hour(), next.Minute(), next.Second(), 0, time.UTC)\n\n\texpected := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute(), now.Second(), 0, time.UTC).Add(time.Second)\n\n\tassert.Exactly(t, expected, nextRounded)\n}\n\n// This is to ensure that if you schedule a job for today's weekday, and the time hasn't yet passed, the next run time\n// will be scheduled for today.\nfunc TestScheduler_WeekdaysTodayBefore(t *testing.T) {\n\tscheduler := NewScheduler()\n\n\tnow := time.Now()\n\ttimeToSchedule := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Minute()+1, 0, 0, time.Local)\n\n\tjob := callTodaysWeekday(scheduler.Every(1)).At(fmt.Sprintf(\"%02d:%02d\", timeToSchedule.Hour(), timeToSchedule.Minute()))\n\tjob.Do(task)\n\tt.Logf(\"job is scheduled for %s\", job.NextScheduledTime())\n\tif !job.NextScheduledTime().Equal(timeToSchedule) {\n\t\tt.Error(\"Job should be run today, at the set time.\")\n\t}\n}\n\nfunc Test_formatTime(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\targs     string\n\t\twantHour int\n\t\twantMin  int\n\t\twantSec  int\n\t\twantErr  bool\n\t}{\n\t\t{\n\t\t\tname:     \"normal\",\n\t\t\targs:     \"16:18\",\n\t\t\twantHour: 16,\n\t\t\twantMin:  18,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"normal_with_second\",\n\t\t\targs:     \"6:18:01\",\n\t\t\twantHour: 6,\n\t\t\twantMin:  18,\n\t\t\twantSec:  1,\n\t\t\twantErr:  false,\n\t\t},\n\t\t{\n\t\t\tname:     \"not_a_number\",\n\t\t\targs:     \"e:18\",\n\t\t\twantHour: 0,\n\t\t\twantMin:  0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"out_of_range_hour\",\n\t\t\targs:     \"25:18\",\n\t\t\twantHour: 0,\n\t\t\twantMin:  0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"out_of_range_minute\",\n\t\t\targs:     \"23:60\",\n\t\t\twantHour: 0,\n\t\t\twantMin:  0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"wrong_format\",\n\t\t\targs:     \"19:18:17:17\",\n\t\t\twantHour: 0,\n\t\t\twantMin:  0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"wrong_minute\",\n\t\t\targs:     \"19:1e\",\n\t\t\twantHour: 19,\n\t\t\twantMin:  0,\n\t\t\twantErr:  true,\n\t\t},\n\t\t{\n\t\t\tname:     \"wrong_hour\",\n\t\t\targs:     \"1e:10\",\n\t\t\twantHour: 11,\n\t\t\twantMin:  0,\n\t\t\twantErr:  true,\n\t\t},\n\t}\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tgotHour, gotMin, gotSec, err := formatTime(tt.args)\n\t\t\tif tt.wantErr {\n\t\t\t\tassert.NotEqual(t, nil, err, tt.args)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tassert.Equal(t, tt.wantHour, gotHour, tt.args)\n\t\t\tassert.Equal(t, tt.wantMin, gotMin, tt.args)\n\t\t\tif tt.wantSec != 0 {\n\t\t\t\tassert.Equal(t, tt.wantSec, gotSec)\n\t\t\t} else {\n\t\t\t\tassert.Zero(t, gotSec)\n\t\t\t}\n\t\t})\n\t}\n}\n\n// utility function for testing the weekday functions *on* the current weekday.\nfunc callTodaysWeekday(job *Job) *Job {\n\tswitch time.Now().Weekday() {\n\tcase 0:\n\t\tjob.Sunday()\n\tcase 1:\n\t\tjob.Monday()\n\tcase 2:\n\t\tjob.Tuesday()\n\tcase 3:\n\t\tjob.Wednesday()\n\tcase 4:\n\t\tjob.Thursday()\n\tcase 5:\n\t\tjob.Friday()\n\tcase 6:\n\t\tjob.Saturday()\n\t}\n\treturn job\n}\n\nfunc TestScheduler_Remove(t *testing.T) {\n\tscheduler := NewScheduler()\n\tscheduler.Every(1).Minute().Do(task)\n\tscheduler.Every(1).Minute().Do(taskWithParams, 1, \"hello\")\n\n\tassert.Equal(t, 2, scheduler.Len(), \"Incorrect number of jobs\")\n\n\tscheduler.Remove(task)\n\n\tassert.Equal(t, 1, scheduler.Len(), \"Incorrect number of jobs after removing 1 job\")\n\n\tscheduler.Remove(task)\n\n\tassert.Equal(t, 1, scheduler.Len(), \"Incorrect number of jobs after removing non-existent job\")\n}\n\nfunc TestScheduler_RemoveByRef(t *testing.T) {\n\tscheduler := NewScheduler()\n\tjob1 := scheduler.Every(1).Minute()\n\tjob1.Do(task)\n\tjob2 := scheduler.Every(1).Minute()\n\tjob2.Do(taskWithParams, 1, \"hello\")\n\n\tassert.Equal(t, 2, scheduler.Len(), \"Incorrect number of jobs\")\n\n\tscheduler.RemoveByRef(job1)\n\tassert.ElementsMatch(t, []*Job{job2}, scheduler.Jobs())\n}\n\nfunc TestTaskAt(t *testing.T) {\n\t// Create new scheduler to have clean test env\n\ts := NewScheduler()\n\n\t// Schedule to run in next minute\n\tnow := time.Now()\n\t// Schedule every day At\n\tstartAt := fmt.Sprintf(\"%02d:%02d\", now.Hour(), now.Add(time.Minute).Minute())\n\tdayJob := s.Every(1).Day().At(startAt)\n\n\tdayJobDone := make(chan bool, 1)\n\tdayJob.Do(func() {\n\t\tdayJobDone <- true\n\t})\n\n\t// Expected start time\n\texpectedStartTime := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Add(time.Minute).Minute(), 0, 0, loc)\n\tnextRun := dayJob.NextScheduledTime()\n\tassert.Equal(t, expectedStartTime, nextRun)\n\n\tsStop := s.Start()\n\t<-dayJobDone // Wait job done\n\tclose(sStop)\n\ttime.Sleep(time.Second) // wait for scheduler to reschedule job\n\n\t// Expected next start time 1 day after\n\texpectedNextRun := expectedStartTime.AddDate(0, 0, 1)\n\tnextRun = dayJob.NextScheduledTime()\n\tassert.Equal(t, expectedNextRun, nextRun)\n}\n\nfunc TestTaskAtFuture(t *testing.T) {\n\t// Create new scheduler to have clean test env\n\ts := NewScheduler()\n\n\tnow := time.Now()\n\n\t// Schedule to run in next minute\n\tnextMinuteTime := now.Add(time.Duration(1 * time.Minute))\n\tstartAt := fmt.Sprintf(\"%02d:%02d\", nextMinuteTime.Hour(), nextMinuteTime.Minute())\n\tdayJob := s.Every(1).Day().At(startAt)\n\tshouldBeFalse := false\n\n\tdayJob.Do(func() {\n\t\tshouldBeFalse = true\n\t})\n\n\t// Check first run\n\texpectedStartTime := time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), now.Add(time.Minute).Minute(), 0, 0, loc)\n\tnextRun := dayJob.NextScheduledTime()\n\tassert.Equal(t, expectedStartTime, nextRun)\n\n\ts.RunPending()\n\n\t// Check next run's scheduled time\n\tnextRun = dayJob.NextScheduledTime()\n\tassert.Equal(t, expectedStartTime, nextRun)\n\tassert.Equal(t, false, shouldBeFalse, \"Day job was not expected to run as it was in the future\")\n}\n\nfunc TestDaily(t *testing.T) {\n\tnow := time.Now()\n\n\t// Create new scheduler to have clean test env\n\ts := NewScheduler()\n\n\t// schedule next run 1 day\n\tdayJob := s.Every(1).Day()\n\tdayJob.scheduleNextRun()\n\ttomorrow := now.AddDate(0, 0, 1)\n\texpectedTime := time.Date(tomorrow.Year(), tomorrow.Month(), tomorrow.Day(), 0, 0, 0, 0, loc)\n\tassert.Equal(t, expectedTime, dayJob.nextRun)\n\n\t// schedule next run 2 days\n\tdayJob = s.Every(2).Days()\n\tdayJob.scheduleNextRun()\n\ttwoDaysFromNow := now.AddDate(0, 0, 2)\n\texpectedTime = time.Date(twoDaysFromNow.Year(), twoDaysFromNow.Month(), twoDaysFromNow.Day(), 0, 0, 0, 0, loc)\n\tassert.Equal(t, expectedTime, dayJob.nextRun)\n\n\t// Job running longer than next schedule 1day 2 hours\n\tdayJob = s.Every(1).Day()\n\ttwoHoursFromNow := now.Add(2 * time.Hour)\n\tdayJob.lastRun = time.Date(twoHoursFromNow.Year(), twoHoursFromNow.Month(), twoHoursFromNow.Day(), twoHoursFromNow.Hour(), 0, 0, 0, loc)\n\tdayJob.scheduleNextRun()\n\texpectedTime = time.Date(twoHoursFromNow.Year(), twoHoursFromNow.Month(), twoHoursFromNow.AddDate(0, 0, 1).Day(), 0, 0, 0, 0, loc)\n\tassert.Equal(t, expectedTime, dayJob.nextRun)\n\n\t// At() 2 hours before now\n\ttwoHoursBefore := now.Add(time.Duration(-2 * time.Hour))\n\tstartAt := fmt.Sprintf(\"%02d:%02d\", twoHoursBefore.Hour(), twoHoursBefore.Minute())\n\tdayJob = s.Every(1).Day().At(startAt)\n\tdayJob.scheduleNextRun()\n\n\texpectedTime = time.Date(twoHoursBefore.Year(), twoHoursBefore.Month(),\n\t\ttwoHoursBefore.AddDate(0, 0, 1).Day(),\n\t\ttwoHoursBefore.Hour(), twoHoursBefore.Minute(), 0, 0, loc)\n\n\tassert.Equal(t, expectedTime, dayJob.nextRun)\n}\n\nfunc TestWeekdayAfterToday(t *testing.T) {\n\tnow := time.Now()\n\n\t// Create new scheduler to have clean test env\n\ts := NewScheduler()\n\n\t// Schedule job at next week day\n\tvar weekJob *Job\n\tswitch now.Weekday() {\n\tcase time.Monday:\n\t\tweekJob = s.Every(1).Tuesday()\n\tcase time.Tuesday:\n\t\tweekJob = s.Every(1).Wednesday()\n\tcase time.Wednesday:\n\t\tweekJob = s.Every(1).Thursday()\n\tcase time.Thursday:\n\t\tweekJob = s.Every(1).Friday()\n\tcase time.Friday:\n\t\tweekJob = s.Every(1).Saturday()\n\tcase time.Saturday:\n\t\tweekJob = s.Every(1).Sunday()\n\tcase time.Sunday:\n\t\tweekJob = s.Every(1).Monday()\n\t}\n\n\t// First run\n\tweekJob.scheduleNextRun()\n\texp := time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, loc)\n\tassert.Equal(t, exp, weekJob.nextRun)\n\n\t// Simulate job run 7 days before\n\tweekJob.lastRun = weekJob.nextRun.AddDate(0, 0, -7)\n\t// Next run\n\tweekJob.scheduleNextRun()\n\texp = time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, loc)\n\tassert.Equal(t, exp, weekJob.nextRun)\n}\n\nfunc TestWeekdayBeforeToday(t *testing.T) {\n\tnow := time.Now()\n\n\t// Create new scheduler to have clean test env\n\ts := NewScheduler()\n\n\t// Schedule job at day before\n\tvar weekJob *Job\n\tswitch now.Weekday() {\n\tcase time.Monday:\n\t\tweekJob = s.Every(1).Sunday()\n\tcase time.Tuesday:\n\t\tweekJob = s.Every(1).Monday()\n\tcase time.Wednesday:\n\t\tweekJob = s.Every(1).Tuesday()\n\tcase time.Thursday:\n\t\tweekJob = s.Every(1).Wednesday()\n\tcase time.Friday:\n\t\tweekJob = s.Every(1).Thursday()\n\tcase time.Saturday:\n\t\tweekJob = s.Every(1).Friday()\n\tcase time.Sunday:\n\t\tweekJob = s.Every(1).Saturday()\n\t}\n\n\tweekJob.scheduleNextRun()\n\tsixDaysFromNow := now.AddDate(0, 0, 6)\n\n\texp := time.Date(sixDaysFromNow.Year(), sixDaysFromNow.Month(), sixDaysFromNow.Day(), 0, 0, 0, 0, loc)\n\tassert.Equal(t, exp, weekJob.nextRun)\n\n\t// Simulate job run 7 days before\n\tweekJob.lastRun = weekJob.nextRun.AddDate(0, 0, -7)\n\t// Next run\n\tweekJob.scheduleNextRun()\n\texp = time.Date(sixDaysFromNow.Year(), sixDaysFromNow.Month(), sixDaysFromNow.Day(), 0, 0, 0, 0, loc)\n\tassert.Equal(t, exp, weekJob.nextRun)\n}\n\nfunc TestWeekdayAt(t *testing.T) {\n\tnow := time.Now()\n\n\thour := now.Hour()\n\tminute := now.Minute()\n\tstartAt := fmt.Sprintf(\"%02d:%02d\", hour, minute)\n\n\t// Create new scheduler to have clean test env\n\ts := NewScheduler()\n\n\t// Schedule job at next week day\n\tvar weekJob *Job\n\tswitch now.Weekday() {\n\tcase time.Monday:\n\t\tweekJob = s.Every(1).Tuesday().At(startAt)\n\tcase time.Tuesday:\n\t\tweekJob = s.Every(1).Wednesday().At(startAt)\n\tcase time.Wednesday:\n\t\tweekJob = s.Every(1).Thursday().At(startAt)\n\tcase time.Thursday:\n\t\tweekJob = s.Every(1).Friday().At(startAt)\n\tcase time.Friday:\n\t\tweekJob = s.Every(1).Saturday().At(startAt)\n\tcase time.Saturday:\n\t\tweekJob = s.Every(1).Sunday().At(startAt)\n\tcase time.Sunday:\n\t\tweekJob = s.Every(1).Monday().At(startAt)\n\t}\n\n\t// First run\n\tweekJob.scheduleNextRun()\n\texp := time.Date(now.Year(), now.Month(), now.AddDate(0, 0, 1).Day(), hour, minute, 0, 0, loc)\n\tassert.Equal(t, exp, weekJob.nextRun)\n\n\t// Simulate job run 7 days before\n\tweekJob.lastRun = weekJob.nextRun.AddDate(0, 0, -7)\n\t// Next run\n\tweekJob.scheduleNextRun()\n\texp = time.Date(now.Year(), now.Month(), now.AddDate(0, 0, 1).Day(), hour, minute, 0, 0, loc)\n\tassert.Equal(t, exp, weekJob.nextRun)\n}\n\ntype lockerMock struct {\n\tcache map[string]struct{}\n\tl     sync.Mutex\n}\n\nfunc (l *lockerMock) Lock(key string) (bool, error) {\n\tl.l.Lock()\n\tdefer l.l.Unlock()\n\tif _, ok := l.cache[key]; ok {\n\t\treturn false, nil\n\t}\n\tl.cache[key] = struct{}{}\n\treturn true, nil\n}\n\nfunc (l *lockerMock) Unlock(key string) error {\n\tl.l.Lock()\n\tdefer l.l.Unlock()\n\tdelete(l.cache, key)\n\treturn nil\n}\n\nfunc TestSetLocker(t *testing.T) {\n\tif locker != nil {\n\t\tt.Fail()\n\t\tt.Log(\"Expected locker to not be set by default\")\n\t}\n\n\tSetLocker(&lockerMock{})\n\n\tif locker == nil {\n\t\tt.Fail()\n\t\tt.Log(\"Expected locker to be set\")\n\t}\n}\n\ntype lockerResult struct {\n\tkey   string\n\tcycle int\n\ts, e  time.Time\n}\n\nfunc TestLocker(t *testing.T) {\n\tl := sync.Mutex{}\n\n\tresult := make([]lockerResult, 0)\n\ttask := func(key string, i int) {\n\t\ts := time.Now()\n\t\ttime.Sleep(time.Millisecond * 100)\n\t\te := time.Now()\n\t\tl.Lock()\n\t\tresult = append(result, lockerResult{\n\t\t\tkey:   key,\n\t\t\tcycle: i,\n\t\t\ts:     s,\n\t\t\te:     e,\n\t\t})\n\t\tl.Unlock()\n\t}\n\n\tSetLocker(&lockerMock{\n\t\tmake(map[string]struct{}),\n\t\tsync.Mutex{},\n\t})\n\n\tfor i := 0; i < 5; i++ {\n\t\ts1 := NewScheduler()\n\t\ts1.Every(1).Seconds().Lock().Do(task, \"A\", i)\n\n\t\ts2 := NewScheduler()\n\t\ts2.Every(1).Seconds().Lock().Do(task, \"B\", i)\n\n\t\ts3 := NewScheduler()\n\t\ts3.Every(1).Seconds().Lock().Do(task, \"C\", i)\n\n\t\tstop1 := s1.Start()\n\t\tstop2 := s2.Start()\n\t\tstop3 := s3.Start()\n\n\t\ttime.Sleep(time.Millisecond * 100)\n\n\t\tclose(stop1)\n\t\tclose(stop2)\n\t\tclose(stop3)\n\n\t\tfor i := 0; i < len(result)-1; i++ {\n\t\t\tfor j := i + 1; j < len(result); j++ {\n\t\t\t\tiBefJ := result[i].s.Before(result[j].s) && result[i].e.Before(result[j].s)\n\t\t\t\tjBefI := result[j].s.Before(result[i].s) && result[j].e.Before(result[i].s)\n\t\t\t\tif !iBefJ && !jBefI {\n\t\t\t\t\tt.Fatalf(\"\\n2 operations ran concurrently:\\n%s\\n%d\\n%s\\n%s\\n**********\\n%s\\n%d\\n%s\\n%s\\n\",\n\t\t\t\t\t\tresult[i].key, result[i].cycle, result[i].s, result[i].e,\n\t\t\t\t\t\tresult[j].key, result[j].cycle, result[j].s, result[j].e)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestGetAllJobs(t *testing.T) {\n\tdefaultScheduler = NewScheduler()\n\tEvery(1).Minute().Do(task)\n\tEvery(2).Minutes().Do(task)\n\tEvery(3).Minutes().Do(task)\n\tEvery(4).Minutes().Do(task)\n\tjs := Jobs()\n\tassert.Len(t, js, 4)\n}\n\nfunc TestTags(t *testing.T) {\n\tj := Every(1).Minute()\n\tj.Tag(\"some\")\n\tj.Tag(\"tag\")\n\tj.Tag(\"more\")\n\tj.Tag(\"tags\")\n\n\tassert.ElementsMatch(t, j.Tags(), []string{\"tags\", \"tag\", \"more\", \"some\"})\n\n\tj.Untag(\"more\")\n\tassert.ElementsMatch(t, j.Tags(), []string{\"tags\", \"tag\", \"some\"})\n}\n\nfunc TestGetAt(t *testing.T) {\n\tj := Every(1).Minute().At(\"10:30\")\n\tassert.Equal(t, \"10:30\", j.GetAt())\n}\n\nfunc TestGetWeekday(t *testing.T) {\n\tj := Every(1).Weekday(time.Wednesday)\n\tassert.Equal(t, time.Wednesday, j.GetWeekday())\n}\n"
        },
        {
          "name": "job.go",
          "type": "blob",
          "size": 9.0634765625,
          "content": "package gocron\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\t\"reflect\"\n\t\"time\"\n)\n\nvar (\n\tErrTimeFormat           = errors.New(\"time format error\")\n\tErrParamsNotAdapted     = errors.New(\"the number of params is not adapted\")\n\tErrNotAFunction         = errors.New(\"only functions can be schedule into the job queue\")\n\tErrPeriodNotSpecified   = errors.New(\"unspecified job period\")\n\tErrParameterCannotBeNil = errors.New(\"nil paramaters cannot be used with reflection\")\n)\n\n// Job struct keeping information about job\ntype Job struct {\n\tinterval uint64                   // pause interval * unit between runs\n\tjobFunc  string                   // the job jobFunc to run, func[jobFunc]\n\tunit     timeUnit                 // time units, ,e.g. 'minutes', 'hours'...\n\tatTime   time.Duration            // optional time at which this job runs\n\terr      error                    // error related to job\n\tloc      *time.Location           // optional timezone that the atTime is in\n\tlastRun  time.Time                // datetime of last run\n\tnextRun  time.Time                // datetime of next run\n\tstartDay time.Weekday             // Specific day of the week to start on\n\tfuncs    map[string]interface{}   // Map for the function task store\n\tfparams  map[string][]interface{} // Map for function and  params of function\n\tlock     bool                     // lock the job from running at same time form multiple instances\n\ttags     []string                 // allow the user to tag jobs with certain labels\n}\n\n// NewJob creates a new job with the time interval.\nfunc NewJob(interval uint64) *Job {\n\treturn &Job{\n\t\tinterval: interval,\n\t\tloc:      loc,\n\t\tlastRun:  time.Unix(0, 0),\n\t\tnextRun:  time.Unix(0, 0),\n\t\tstartDay: time.Sunday,\n\t\tfuncs:    make(map[string]interface{}),\n\t\tfparams:  make(map[string][]interface{}),\n\t\ttags:     []string{},\n\t}\n}\n\n// True if the job should be run now\nfunc (j *Job) shouldRun() bool {\n\treturn time.Now().Unix() >= j.nextRun.Unix()\n}\n\n//Run the job and immediately reschedule it\nfunc (j *Job) run() ([]reflect.Value, error) {\n\tif j.lock {\n\t\tif locker == nil {\n\t\t\treturn nil, fmt.Errorf(\"trying to lock %s with nil locker\", j.jobFunc)\n\t\t}\n\t\tkey := getFunctionKey(j.jobFunc)\n\n\t\tlocker.Lock(key)\n\t\tdefer locker.Unlock(key)\n\t}\n\tresult, err := callJobFuncWithParams(j.funcs[j.jobFunc], j.fparams[j.jobFunc])\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn result, nil\n}\n\n// Err should be checked to ensure an error didn't occur creating the job\nfunc (j *Job) Err() error {\n\treturn j.err\n}\n\n// Do specifies the jobFunc that should be called every time the job runs\nfunc (j *Job) Do(jobFun interface{}, params ...interface{}) error {\n\tif j.err != nil {\n\t\treturn j.err\n\t}\n\n\ttyp := reflect.TypeOf(jobFun)\n\tif typ.Kind() != reflect.Func {\n\t\treturn ErrNotAFunction\n\t}\n\tfname := getFunctionName(jobFun)\n\tj.funcs[fname] = jobFun\n\tj.fparams[fname] = params\n\tj.jobFunc = fname\n\n\tnow := time.Now().In(j.loc)\n\tif !j.nextRun.After(now) {\n\t\tj.scheduleNextRun()\n\t}\n\n\treturn nil\n}\n\n// DoSafely does the same thing as Do, but logs unexpected panics, instead of unwinding them up the chain\n// Deprecated: DoSafely exists due to historical compatibility and will be removed soon. Use Do instead\nfunc (j *Job) DoSafely(jobFun interface{}, params ...interface{}) error {\n\trecoveryWrapperFunc := func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\tlog.Printf(\"Internal panic occurred: %s\", r)\n\t\t\t}\n\t\t}()\n\n\t\t_, _ = callJobFuncWithParams(jobFun, params)\n\t}\n\n\treturn j.Do(recoveryWrapperFunc)\n}\n\n// At schedules job at specific time of day\n//\ts.Every(1).Day().At(\"10:30:01\").Do(task)\n//\ts.Every(1).Monday().At(\"10:30:01\").Do(task)\nfunc (j *Job) At(t string) *Job {\n\thour, min, sec, err := formatTime(t)\n\tif err != nil {\n\t\tj.err = ErrTimeFormat\n\t\treturn j\n\t}\n\t// save atTime start as duration from midnight\n\tj.atTime = time.Duration(hour)*time.Hour + time.Duration(min)*time.Minute + time.Duration(sec)*time.Second\n\treturn j\n}\n\n// GetAt returns the specific time of day the job will run at\n//\ts.Every(1).Day().At(\"10:30\").GetAt() == \"10:30\"\nfunc (j *Job) GetAt() string {\n\treturn fmt.Sprintf(\"%d:%d\", j.atTime/time.Hour, (j.atTime%time.Hour)/time.Minute)\n}\n\n// Loc sets the location for which to interpret \"At\"\n//\ts.Every(1).Day().At(\"10:30\").Loc(time.UTC).Do(task)\nfunc (j *Job) Loc(loc *time.Location) *Job {\n\tj.loc = loc\n\treturn j\n}\n\n// Tag allows you to add labels to a job\n// they don't impact the functionality of the job.\nfunc (j *Job) Tag(t string, others ...string) {\n\tj.tags = append(j.tags, t)\n\tfor _, tag := range others {\n\t\tj.tags = append(j.tags, tag)\n\t}\n}\n\n// Untag removes a tag from a job\nfunc (j *Job) Untag(t string) {\n\tnewTags := []string{}\n\tfor _, tag := range j.tags {\n\t\tif t != tag {\n\t\t\tnewTags = append(newTags, tag)\n\t\t}\n\t}\n\n\tj.tags = newTags\n}\n\n// Tags returns the tags attached to the job\nfunc (j *Job) Tags() []string {\n\treturn j.tags\n}\n\nfunc (j *Job) periodDuration() (time.Duration, error) {\n\tinterval := time.Duration(j.interval)\n\tvar periodDuration time.Duration\n\n\tswitch j.unit {\n\tcase seconds:\n\t\tperiodDuration = interval * time.Second\n\tcase minutes:\n\t\tperiodDuration = interval * time.Minute\n\tcase hours:\n\t\tperiodDuration = interval * time.Hour\n\tcase days:\n\t\tperiodDuration = interval * time.Hour * 24\n\tcase weeks:\n\t\tperiodDuration = interval * time.Hour * 24 * 7\n\tdefault:\n\t\treturn 0, ErrPeriodNotSpecified\n\t}\n\treturn periodDuration, nil\n}\n\n// roundToMidnight truncate time to midnight\nfunc (j *Job) roundToMidnight(t time.Time) time.Time {\n\treturn time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, j.loc)\n}\n\n// scheduleNextRun Compute the instant when this job should run next\nfunc (j *Job) scheduleNextRun() error {\n\tnow := time.Now()\n\tif j.lastRun == time.Unix(0, 0) {\n\t\tj.lastRun = now\n\t}\n\n\tperiodDuration, err := j.periodDuration()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tswitch j.unit {\n\tcase seconds, minutes, hours:\n\t\tj.nextRun = j.lastRun.Add(periodDuration)\n\tcase days:\n\t\tj.nextRun = j.roundToMidnight(j.lastRun)\n\t\tj.nextRun = j.nextRun.Add(j.atTime)\n\tcase weeks:\n\t\tj.nextRun = j.roundToMidnight(j.lastRun)\n\t\tdayDiff := int(j.startDay)\n\t\tdayDiff -= int(j.nextRun.Weekday())\n\t\tif dayDiff != 0 {\n\t\t\tj.nextRun = j.nextRun.Add(time.Duration(dayDiff) * 24 * time.Hour)\n\t\t}\n\t\tj.nextRun = j.nextRun.Add(j.atTime)\n\t}\n\n\t// advance to next possible schedule\n\tfor j.nextRun.Before(now) || j.nextRun.Before(j.lastRun) {\n\t\tj.nextRun = j.nextRun.Add(periodDuration)\n\t}\n\n\treturn nil\n}\n\n// NextScheduledTime returns the time of when this job is to run next\nfunc (j *Job) NextScheduledTime() time.Time {\n\treturn j.nextRun\n}\n\n// set the job's unit with seconds,minutes,hours...\nfunc (j *Job) mustInterval(i uint64) error {\n\tif j.interval != i {\n\t\treturn fmt.Errorf(\"interval must be %d\", i)\n\t}\n\treturn nil\n}\n\n// From schedules the next run of the job\nfunc (j *Job) From(t *time.Time) *Job {\n\tj.nextRun = *t\n\treturn j\n}\n\n// setUnit sets unit type\nfunc (j *Job) setUnit(unit timeUnit) *Job {\n\tj.unit = unit\n\treturn j\n}\n\n// Seconds set the unit with seconds\nfunc (j *Job) Seconds() *Job {\n\treturn j.setUnit(seconds)\n}\n\n// Minutes set the unit with minute\nfunc (j *Job) Minutes() *Job {\n\treturn j.setUnit(minutes)\n}\n\n// Hours set the unit with hours\nfunc (j *Job) Hours() *Job {\n\treturn j.setUnit(hours)\n}\n\n// Days set the job's unit with days\nfunc (j *Job) Days() *Job {\n\treturn j.setUnit(days)\n}\n\n// Weeks sets the units as weeks\nfunc (j *Job) Weeks() *Job {\n\treturn j.setUnit(weeks)\n}\n\n// Second sets the unit with second\nfunc (j *Job) Second() *Job {\n\tj.mustInterval(1)\n\treturn j.Seconds()\n}\n\n// Minute sets the unit  with minute, which interval is 1\nfunc (j *Job) Minute() *Job {\n\tj.mustInterval(1)\n\treturn j.Minutes()\n}\n\n// Hour sets the unit with hour, which interval is 1\nfunc (j *Job) Hour() *Job {\n\tj.mustInterval(1)\n\treturn j.Hours()\n}\n\n// Day sets the job's unit with day, which interval is 1\nfunc (j *Job) Day() *Job {\n\tj.mustInterval(1)\n\treturn j.Days()\n}\n\n// Week sets the job's unit with week, which interval is 1\nfunc (j *Job) Week() *Job {\n\tj.mustInterval(1)\n\treturn j.Weeks()\n}\n\n// Weekday start job on specific Weekday\nfunc (j *Job) Weekday(startDay time.Weekday) *Job {\n\tj.mustInterval(1)\n\tj.startDay = startDay\n\treturn j.Weeks()\n}\n\n// GetWeekday returns which day of the week the job will run on\n// This should only be used when .Weekday(...) was called on the job.\nfunc (j *Job) GetWeekday() time.Weekday {\n\treturn j.startDay\n}\n\n// Monday set the start day with Monday\n// - s.Every(1).Monday().Do(task)\nfunc (j *Job) Monday() (job *Job) {\n\treturn j.Weekday(time.Monday)\n}\n\n// Tuesday sets the job start day Tuesday\nfunc (j *Job) Tuesday() *Job {\n\treturn j.Weekday(time.Tuesday)\n}\n\n// Wednesday sets the job start day Wednesday\nfunc (j *Job) Wednesday() *Job {\n\treturn j.Weekday(time.Wednesday)\n}\n\n// Thursday sets the job start day Thursday\nfunc (j *Job) Thursday() *Job {\n\treturn j.Weekday(time.Thursday)\n}\n\n// Friday sets the job start day Friday\nfunc (j *Job) Friday() *Job {\n\treturn j.Weekday(time.Friday)\n}\n\n// Saturday sets the job start day Saturday\nfunc (j *Job) Saturday() *Job {\n\treturn j.Weekday(time.Saturday)\n}\n\n// Sunday sets the job start day Sunday\nfunc (j *Job) Sunday() *Job {\n\treturn j.Weekday(time.Sunday)\n}\n\n// Lock prevents job to run from multiple instances of gocron\nfunc (j *Job) Lock() *Job {\n\tj.lock = true\n\treturn j\n}\n"
        },
        {
          "name": "scheduler.go",
          "type": "blob",
          "size": 5.5791015625,
          "content": "package gocron\n\nimport (\n\t\"sort\"\n\t\"time\"\n)\n\n// Scheduler struct, the only data member is the list of jobs.\n// - implements the sort.Interface{} for sorting jobs, by the time nextRun\ntype Scheduler struct {\n\tjobs [MAXJOBNUM]*Job // Array store jobs\n\tsize int             // Size of jobs which jobs holding.\n\tloc  *time.Location  // Location to use when scheduling jobs with specified times\n}\n\nvar (\n\tdefaultScheduler = NewScheduler()\n)\n\n// NewScheduler creates a new scheduler\nfunc NewScheduler() *Scheduler {\n\treturn &Scheduler{\n\t\tjobs: [MAXJOBNUM]*Job{},\n\t\tsize: 0,\n\t\tloc:  loc,\n\t}\n}\n\n// Jobs returns the list of Jobs from the Scheduler\nfunc (s *Scheduler) Jobs() []*Job {\n\treturn s.jobs[:s.size]\n}\n\nfunc (s *Scheduler) Len() int {\n\treturn s.size\n}\n\nfunc (s *Scheduler) Swap(i, j int) {\n\ts.jobs[i], s.jobs[j] = s.jobs[j], s.jobs[i]\n}\n\nfunc (s *Scheduler) Less(i, j int) bool {\n\treturn s.jobs[j].nextRun.Unix() >= s.jobs[i].nextRun.Unix()\n}\n\n// ChangeLoc changes the default time location\nfunc (s *Scheduler) ChangeLoc(newLocation *time.Location) {\n\ts.loc = newLocation\n}\n\n// Get the current runnable jobs, which shouldRun is True\nfunc (s *Scheduler) getRunnableJobs() (runningJobs [MAXJOBNUM]*Job, n int) {\n\trunnableJobs := [MAXJOBNUM]*Job{}\n\tn = 0\n\tsort.Sort(s)\n\tfor i := 0; i < s.size; i++ {\n\t\tif s.jobs[i].shouldRun() {\n\t\t\trunnableJobs[n] = s.jobs[i]\n\t\t\tn++\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn runnableJobs, n\n}\n\n// NextRun datetime when the next job should run.\nfunc (s *Scheduler) NextRun() (*Job, time.Time) {\n\tif s.size <= 0 {\n\t\treturn nil, time.Now()\n\t}\n\tsort.Sort(s)\n\treturn s.jobs[0], s.jobs[0].nextRun\n}\n\n// Every schedule a new periodic job with interval\nfunc (s *Scheduler) Every(interval uint64) *Job {\n\tjob := NewJob(interval).Loc(s.loc)\n\ts.jobs[s.size] = job\n\ts.size++\n\treturn job\n}\n\n// RunPending runs all the jobs that are scheduled to run.\nfunc (s *Scheduler) RunPending() {\n\trunnableJobs, n := s.getRunnableJobs()\n\n\tif n != 0 {\n\t\tfor i := 0; i < n; i++ {\n\t\t\tgo runnableJobs[i].run()\n\t\t\trunnableJobs[i].lastRun = time.Now()\n\t\t\trunnableJobs[i].scheduleNextRun()\n\t\t}\n\t}\n}\n\n// RunAll run all jobs regardless if they are scheduled to run or not\nfunc (s *Scheduler) RunAll() {\n\ts.RunAllwithDelay(0)\n}\n\n// RunAllwithDelay runs all jobs with delay seconds\nfunc (s *Scheduler) RunAllwithDelay(d int) {\n\tfor i := 0; i < s.size; i++ {\n\t\tgo s.jobs[i].run()\n\t\tif 0 != d {\n\t\t\ttime.Sleep(time.Duration(d))\n\t\t}\n\t}\n}\n\n// Remove specific job j by function\nfunc (s *Scheduler) Remove(j interface{}) {\n\ts.removeByCondition(func(someJob *Job) bool {\n\t\treturn someJob.jobFunc == getFunctionName(j)\n\t})\n}\n\n// RemoveByRef removes specific job j by reference\nfunc (s *Scheduler) RemoveByRef(j *Job) {\n\ts.removeByCondition(func(someJob *Job) bool {\n\t\treturn someJob == j\n\t})\n}\n\n// RemoveByTag removes specific job j by tag\nfunc (s *Scheduler) RemoveByTag(t string) {\n\ts.removeByCondition(func(someJob *Job) bool {\n\t\tfor _, a := range someJob.tags {\n\t\t\tif a == t {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t\treturn false\n\t})\n}\n\nfunc (s *Scheduler) removeByCondition(shouldRemove func(*Job) bool) {\n\ti := 0\n\n\t// keep deleting until no more jobs match the criteria\n\tfor {\n\t\tfound := false\n\n\t\tfor ; i < s.size; i++ {\n\t\t\tif shouldRemove(s.jobs[i]) {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !found {\n\t\t\treturn\n\t\t}\n\n\t\tfor j := (i + 1); j < s.size; j++ {\n\t\t\ts.jobs[i] = s.jobs[j]\n\t\t\ti++\n\t\t}\n\t\ts.size--\n\t\ts.jobs[s.size] = nil\n\t}\n}\n\n// Scheduled checks if specific job j was already added\nfunc (s *Scheduler) Scheduled(j interface{}) bool {\n\tfor _, job := range s.jobs {\n\t\tif job.jobFunc == getFunctionName(j) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// Clear delete all scheduled jobs\nfunc (s *Scheduler) Clear() {\n\tfor i := 0; i < s.size; i++ {\n\t\ts.jobs[i] = nil\n\t}\n\ts.size = 0\n}\n\n// Start all the pending jobs\n// Add seconds ticker\nfunc (s *Scheduler) Start() chan bool {\n\tstopped := make(chan bool, 1)\n\tticker := time.NewTicker(1 * time.Second)\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-ticker.C:\n\t\t\t\ts.RunPending()\n\t\t\tcase <-stopped:\n\t\t\t\tticker.Stop()\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn stopped\n}\n\n// The following methods are shortcuts for not having to\n// create a Scheduler instance\n\n// Every schedules a new periodic job running in specific interval\nfunc Every(interval uint64) *Job {\n\treturn defaultScheduler.Every(interval)\n}\n\n// RunPending run all jobs that are scheduled to run\n//\n// Please note that it is *intended behavior that run_pending()\n// does not run missed jobs*. For example, if you've registered a job\n// that should run every minute and you only call run_pending()\n// in one hour increments then your job won't be run 60 times in\n// between but only once.\nfunc RunPending() {\n\tdefaultScheduler.RunPending()\n}\n\n// RunAll run all jobs regardless if they are scheduled to run or not.\nfunc RunAll() {\n\tdefaultScheduler.RunAll()\n}\n\n// RunAllwithDelay run all the jobs with a delay in seconds\n//\n// A delay of `delay` seconds is added between each job. This can help\n// to distribute the system load generated by the jobs more evenly over\n// time.\nfunc RunAllwithDelay(d int) {\n\tdefaultScheduler.RunAllwithDelay(d)\n}\n\n// Start run all jobs that are scheduled to run\nfunc Start() chan bool {\n\treturn defaultScheduler.Start()\n}\n\n// Clear all scheduled jobs\nfunc Clear() {\n\tdefaultScheduler.Clear()\n}\n\n// Remove a specific job\nfunc Remove(j interface{}) {\n\tdefaultScheduler.Remove(j)\n}\n\n// Scheduled checks if specific job j was already added\nfunc Scheduled(j interface{}) bool {\n\tfor _, job := range defaultScheduler.jobs {\n\t\tif job.jobFunc == getFunctionName(j) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// NextRun gets the next running time\nfunc NextRun() (job *Job, time time.Time) {\n\treturn defaultScheduler.NextRun()\n}\n"
        }
      ]
    }
  ]
}