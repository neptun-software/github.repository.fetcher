{
  "metadata": {
    "timestamp": 1736566543548,
    "page": 88,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjkw",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "tidwall/buntdb",
      "stars": 4619,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0517578125,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2016 Josh Baker\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 20.2060546875,
          "content": "<p align=\"center\">\n<img\n    src=\"logo.png\"\n    width=\"307\" height=\"150\" border=\"0\" alt=\"BuntDB\">\n<br>\n<a href=\"https://godoc.org/github.com/tidwall/buntdb\"><img src=\"https://img.shields.io/badge/go-documentation-blue.svg?style=flat-square\" alt=\"Godoc\"></a>\n<a href=\"https://github.com/tidwall/buntdb/blob/master/LICENSE\"><img src=\"https://img.shields.io/github/license/tidwall/buntdb.svg?style=flat-square\" alt=\"LICENSE\"></a>\n</p>\n\nBuntDB is a low-level, in-memory, key/value store in pure Go.\nIt persists to disk, is ACID compliant, and uses locking for multiple\nreaders and a single writer. It supports custom indexes and geospatial\ndata. It's ideal for projects that need a dependable database and favor\nspeed over data size.\n\nFeatures\n========\n\n- In-memory database for [fast reads and writes](#performance)\n- Embeddable with a [simple API](https://godoc.org/github.com/tidwall/buntdb)\n- [Spatial indexing](#spatial-indexes) for up to 20 dimensions; Useful for Geospatial data\n- Index fields inside [JSON](#json-indexes) documents\n- [Collate i18n Indexes](#collate-i18n-indexes) using the optional [collate package](https://github.com/tidwall/collate)\n- Create [custom indexes](#custom-indexes) for any data type\n- Support for [multi value indexes](#multi-value-index); Similar to a SQL multi column index\n- [Built-in types](#built-in-types) that are easy to get up & running; String, Uint, Int, Float\n- Flexible [iteration](#iterating) of data; ascending, descending, and ranges\n- [Durable append-only file](#append-only-file) format for persistence\n- Option to evict old items with an [expiration](#data-expiration) TTL\n- ACID semantics with locking [transactions](#transactions) that support rollbacks\n\n\nGetting Started\n===============\n\n## Installing\n\nTo start using BuntDB, install Go and run `go get`:\n\n```sh\n$ go get -u github.com/tidwall/buntdb\n```\n\nThis will retrieve the library.\n\n\n## Opening a database\n\nThe primary object in BuntDB is a `DB`. To open or create your\ndatabase, use the `buntdb.Open()` function:\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/tidwall/buntdb\"\n)\n\nfunc main() {\n\t// Open the data.db file. It will be created if it doesn't exist.\n\tdb, err := buntdb.Open(\"data.db\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n\n\t...\n}\n```\n\nIt's also possible to open a database that does not persist to disk by using `:memory:` as the path of the file.\n\n```go\nbuntdb.Open(\":memory:\") // Open a file that does not persist to disk.\n```\n\n## Transactions\nAll reads and writes must be performed from inside a transaction. BuntDB can have one write transaction opened at a time, but can have many concurrent read transactions. Each transaction maintains a stable view of the database. In other words, once a transaction has begun, the data for that transaction cannot be changed by other transactions.\n\nTransactions run in a function that exposes a `Tx` object, which represents the transaction state. While inside a transaction, all database operations should be performed using this object. You should never access the origin `DB` object while inside a transaction. Doing so may have side-effects, such as blocking your application.\n\nWhen a transaction fails, it will roll back, and revert all changes that occurred to the database during that transaction. There's a single return value that you can use to close the transaction. For read/write transactions, returning an error this way will force the transaction to roll back. When a read/write transaction succeeds all changes are persisted to disk.\n\n### Read-only Transactions\nA read-only transaction should be used when you don't need to make changes to the data. The advantage of a read-only transaction is that there can be many running concurrently.\n\n```go\nerr := db.View(func(tx *buntdb.Tx) error {\n\t...\n\treturn nil\n})\n```\n\n### Read/write Transactions\nA read/write transaction is used when you need to make changes to your data. There can only be one read/write transaction running at a time. So make sure you close it as soon as you are done with it.\n\n```go\nerr := db.Update(func(tx *buntdb.Tx) error {\n\t...\n\treturn nil\n})\n```\n\n## Setting and getting key/values\n\nTo set a value you must open a read/write transaction:\n\n```go\nerr := db.Update(func(tx *buntdb.Tx) error {\n\t_, _, err := tx.Set(\"mykey\", \"myvalue\", nil)\n\treturn err\n})\n```\n\n\nTo get the value:\n\n```go\nerr := db.View(func(tx *buntdb.Tx) error {\n\tval, err := tx.Get(\"mykey\")\n\tif err != nil{\n\t\treturn err\n\t}\n\tfmt.Printf(\"value is %s\\n\", val)\n\treturn nil\n})\n```\n\nGetting non-existent values will cause an `ErrNotFound` error.\n\n### Iterating\nAll keys/value pairs are ordered in the database by the key. To iterate over the keys:\n\n```go\nerr := db.View(func(tx *buntdb.Tx) error {\n\terr := tx.Ascend(\"\", func(key, value string) bool {\n\t\tfmt.Printf(\"key: %s, value: %s\\n\", key, value)\n\t\treturn true // continue iteration\n\t})\n\treturn err\n})\n```\n\nThere is also `AscendGreaterOrEqual`, `AscendLessThan`, `AscendRange`, `AscendEqual`, `Descend`, `DescendLessOrEqual`, `DescendGreaterThan`, `DescendRange`, and `DescendEqual`. Please see the [documentation](https://godoc.org/github.com/tidwall/buntdb) for more information on these functions.\n\n\n## Custom Indexes\nInitially all data is stored in a single [B-tree](https://en.wikipedia.org/wiki/B-tree) with each item having one key and one value. All of these items are ordered by the key. This is great for quickly getting a value from a key or [iterating](#iterating) over the keys. Feel free to peruse the [B-tree implementation](https://github.com/tidwall/btree).\n\nYou can also create custom indexes that allow for ordering and [iterating](#iterating) over values. A custom index also uses a B-tree, but it's more flexible because it allows for custom ordering.\n\nFor example, let's say you want to create an index for ordering names:\n\n```go\ndb.CreateIndex(\"names\", \"*\", buntdb.IndexString)\n```\n\nThis will create an index named `names` which stores and sorts all values. The second parameter is a pattern that is used to filter on keys. A `*` wildcard argument means that we want to accept all keys. `IndexString` is a built-in function that performs case-insensitive ordering on the values\n\nNow you can add various names:\n\n```go\ndb.Update(func(tx *buntdb.Tx) error {\n\ttx.Set(\"user:0:name\", \"tom\", nil)\n\ttx.Set(\"user:1:name\", \"Randi\", nil)\n\ttx.Set(\"user:2:name\", \"jane\", nil)\n\ttx.Set(\"user:4:name\", \"Janet\", nil)\n\ttx.Set(\"user:5:name\", \"Paula\", nil)\n\ttx.Set(\"user:6:name\", \"peter\", nil)\n\ttx.Set(\"user:7:name\", \"Terri\", nil)\n\treturn nil\n})\n```\n\nFinally you can iterate over the index:\n\n```go\ndb.View(func(tx *buntdb.Tx) error {\n\ttx.Ascend(\"names\", func(key, val string) bool {\n\tfmt.Printf(buf, \"%s %s\\n\", key, val)\n\t\treturn true\n\t})\n\treturn nil\n})\n```\nThe output should be:\n```\nuser:2:name jane\nuser:4:name Janet\nuser:5:name Paula\nuser:6:name peter\nuser:1:name Randi\nuser:7:name Terri\nuser:0:name tom\n```\n\nThe pattern parameter can be used to filter on keys like this:\n\n```go\ndb.CreateIndex(\"names\", \"user:*\", buntdb.IndexString)\n```\n\nNow only items with keys that have the prefix `user:` will be added to the `names` index.\n\n\n### Built-in types\nAlong with `IndexString`, there is also `IndexInt`, `IndexUint`, and `IndexFloat`.\nThese are built-in types for indexing. You can choose to use these or create your own.\n\nSo to create an index that is numerically ordered on an age key, we could use:\n\n```go\ndb.CreateIndex(\"ages\", \"user:*:age\", buntdb.IndexInt)\n```\n\nAnd then add values:\n\n```go\ndb.Update(func(tx *buntdb.Tx) error {\n\ttx.Set(\"user:0:age\", \"35\", nil)\n\ttx.Set(\"user:1:age\", \"49\", nil)\n\ttx.Set(\"user:2:age\", \"13\", nil)\n\ttx.Set(\"user:4:age\", \"63\", nil)\n\ttx.Set(\"user:5:age\", \"8\", nil)\n\ttx.Set(\"user:6:age\", \"3\", nil)\n\ttx.Set(\"user:7:age\", \"16\", nil)\n\treturn nil\n})\n```\n\n```go\ndb.View(func(tx *buntdb.Tx) error {\n\ttx.Ascend(\"ages\", func(key, val string) bool {\n\tfmt.Printf(buf, \"%s %s\\n\", key, val)\n\t\treturn true\n\t})\n\treturn nil\n})\n```\n\nThe output should be:\n```\nuser:6:age 3\nuser:5:age 8\nuser:2:age 13\nuser:7:age 16\nuser:0:age 35\nuser:1:age 49\nuser:4:age 63\n```\n\n## Spatial Indexes\nBuntDB has support for spatial indexes by storing rectangles in an [R-tree](https://en.wikipedia.org/wiki/R-tree). An R-tree is organized in a similar manner as a [B-tree](https://en.wikipedia.org/wiki/B-tree), and both are balanced trees. But, an R-tree is special because it can operate on data that is in multiple dimensions. This is super handy for Geospatial applications.\n\nTo create a spatial index use the `CreateSpatialIndex` function:\n\n```go\ndb.CreateSpatialIndex(\"fleet\", \"fleet:*:pos\", buntdb.IndexRect)\n```\n\nThen `IndexRect` is a built-in function that converts rect strings to a format that the R-tree can use. It's easy to use this function out of the box, but you might find it better to create a custom one that renders from a different format, such as [Well-known text](https://en.wikipedia.org/wiki/Well-known_text) or [GeoJSON](http://geojson.org/).\n\nTo add some lon,lat points to the `fleet` index:\n\n```go\ndb.Update(func(tx *buntdb.Tx) error {\n\ttx.Set(\"fleet:0:pos\", \"[-115.567 33.532]\", nil)\n\ttx.Set(\"fleet:1:pos\", \"[-116.671 35.735]\", nil)\n\ttx.Set(\"fleet:2:pos\", \"[-113.902 31.234]\", nil)\n\treturn nil\n})\n```\n\nAnd then you can run the `Intersects` function on the index:\n\n```go\ndb.View(func(tx *buntdb.Tx) error {\n\ttx.Intersects(\"fleet\", \"[-117 30],[-112 36]\", func(key, val string) bool {\n\t\t...\n\t\treturn true\n\t})\n\treturn nil\n})\n```\n\nThis will get all three positions.\n\n### k-Nearest Neighbors\n\nUse the `Nearby` function to get all the positions in order of nearest to farthest :\n\n```go\ndb.View(func(tx *buntdb.Tx) error {\n\ttx.Nearby(\"fleet\", \"[-113 33]\", func(key, val string, dist float64) bool {\n\t\t...\n\t\treturn true\n\t})\n\treturn nil\n})\n```\n\n### Spatial bracket syntax\n\nThe bracket syntax `[-117 30],[-112 36]` is unique to BuntDB, and it's how the built-in rectangles are processed. But, you are not limited to this syntax. Whatever Rect function you choose to use during `CreateSpatialIndex` will be used to process the parameter, in this case it's `IndexRect`.\n\n- **2D rectangle:** `[10 15],[20 25]`\n*Min XY: \"10x15\", Max XY: \"20x25\"*\n\n- **3D rectangle:** `[10 15 12],[20 25 18]`\n*Min XYZ: \"10x15x12\", Max XYZ: \"20x25x18\"*\n\n- **2D point:** `[10 15]`\n*XY: \"10x15\"*\n\n- **LonLat point:** `[-112.2693 33.5123]`\n*LatLon: \"33.5123 -112.2693\"*\n\n- **LonLat bounding box:** `[-112.26 33.51],[-112.18 33.67]`\n*Min LatLon: \"33.51 -112.26\", Max LatLon: \"33.67 -112.18\"*\n\n**Notice:** The longitude is the Y axis and is on the left, and latitude is the X axis and is on the right.\n\nYou can also represent `Infinity` by using `-inf` and `+inf`.\nFor example, you might have the following points (`[X Y M]` where XY is a point and M is a timestamp):\n```\n[3 9 1]\n[3 8 2]\n[4 8 3]\n[4 7 4]\n[5 7 5]\n[5 6 6]\n```\n\nYou can then do a search for all points with `M` between 2-4 by calling `Intersects`.\n\n```go\ntx.Intersects(\"points\", \"[-inf -inf 2],[+inf +inf 4]\", func(key, val string) bool {\n\tprintln(val)\n\treturn true\n})\n```\n\nWhich will return:\n\n```\n[3 8 2]\n[4 8 3]\n[4 7 4]\n```\n\n## JSON Indexes\nIndexes can be created on individual fields inside JSON documents. BuntDB uses [GJSON](https://github.com/tidwall/gjson) under the hood.\n\nFor example:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/tidwall/buntdb\"\n)\n\nfunc main() {\n\tdb, _ := buntdb.Open(\":memory:\")\n\tdb.CreateIndex(\"last_name\", \"*\", buntdb.IndexJSON(\"name.last\"))\n\tdb.CreateIndex(\"age\", \"*\", buntdb.IndexJSON(\"age\"))\n\tdb.Update(func(tx *buntdb.Tx) error {\n\t\ttx.Set(\"1\", `{\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}`, nil)\n\t\ttx.Set(\"2\", `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`, nil)\n\t\ttx.Set(\"3\", `{\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}`, nil)\n\t\ttx.Set(\"4\", `{\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}`, nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *buntdb.Tx) error {\n\t\tfmt.Println(\"Order by last name\")\n\t\ttx.Ascend(\"last_name\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Println(\"Order by age\")\n\t\ttx.Ascend(\"age\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Println(\"Order by age range 30-50\")\n\t\ttx.AscendRange(\"age\", `{\"age\":30}`, `{\"age\":50}`, func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n}\n```\n\nResults:\n\n```\nOrder by last name\n3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n\nOrder by age\n4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n\nOrder by age range 30-50\n1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n```\n\n## Multi Value Index\nWith BuntDB it's possible to join multiple values on a single index.\nThis is similar to a [multi column index](http://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html) in a traditional SQL database.\n\nIn this example we are creating a multi value index on \"name.last\" and \"age\":\n\n```go\ndb, _ := buntdb.Open(\":memory:\")\ndb.CreateIndex(\"last_name_age\", \"*\", buntdb.IndexJSON(\"name.last\"), buntdb.IndexJSON(\"age\"))\ndb.Update(func(tx *buntdb.Tx) error {\n\ttx.Set(\"1\", `{\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}`, nil)\n\ttx.Set(\"2\", `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`, nil)\n\ttx.Set(\"3\", `{\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}`, nil)\n\ttx.Set(\"4\", `{\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}`, nil)\n\ttx.Set(\"5\", `{\"name\":{\"first\":\"Sam\",\"last\":\"Anderson\"},\"age\":51}`, nil)\n\ttx.Set(\"6\", `{\"name\":{\"first\":\"Melinda\",\"last\":\"Prichard\"},\"age\":44}`, nil)\n\treturn nil\n})\ndb.View(func(tx *buntdb.Tx) error {\n\ttx.Ascend(\"last_name_age\", func(key, value string) bool {\n\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\treturn true\n\t})\n\treturn nil\n})\n\n// Output:\n// 5: {\"name\":{\"first\":\"Sam\",\"last\":\"Anderson\"},\"age\":51}\n// 3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n// 4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n// 1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n// 6: {\"name\":{\"first\":\"Melinda\",\"last\":\"Prichard\"},\"age\":44}\n// 2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n```\n\n## Descending Ordered Index\nAny index can be put in descending order by wrapping it's less function with `buntdb.Desc`.\n\n```go\ndb.CreateIndex(\"last_name_age\", \"*\",\n    buntdb.IndexJSON(\"name.last\"),\n    buntdb.Desc(buntdb.IndexJSON(\"age\")),\n)\n```\n\nThis will create a multi value index where the last name is ascending and the age is descending.\n\n## Collate i18n Indexes\n\nUsing the external [collate package](https://github.com/tidwall/collate) it's possible to create\nindexes that are sorted by the specified language. This is similar to the [SQL COLLATE keyword](https://msdn.microsoft.com/en-us/library/ms174596.aspx) found in traditional databases.\n\nTo install:\n\n```\ngo get -u github.com/tidwall/collate\n```\n\nFor example:\n\n```go\nimport \"github.com/tidwall/collate\"\n\n// To sort case-insensitive in French.\ndb.CreateIndex(\"name\", \"*\", collate.IndexString(\"FRENCH_CI\"))\n\n// To specify that numbers should sort numerically (\"2\" < \"12\")\n// and use a comma to represent a decimal point.\ndb.CreateIndex(\"amount\", \"*\", collate.IndexString(\"FRENCH_NUM\"))\n```\n\nThere's also support for Collation on JSON indexes:\n\n```go\ndb.CreateIndex(\"last_name\", \"*\", collate.IndexJSON(\"CHINESE_CI\", \"name.last\"))\n```\n\nCheck out the [collate project](https://github.com/tidwall/collate) for more information.\n\n## Data Expiration\nItems can be automatically evicted by using the `SetOptions` object in the `Set` function to set a `TTL`.\n\n```go\ndb.Update(func(tx *buntdb.Tx) error {\n\ttx.Set(\"mykey\", \"myval\", &buntdb.SetOptions{Expires:true, TTL:time.Second})\n\treturn nil\n})\n```\n\nNow `mykey` will automatically be deleted after one second. You can remove the TTL by setting the value again with the same key/value, but with the options parameter set to nil.\n\n## Delete while iterating\nBuntDB does not currently support deleting a key while in the process of iterating.\nAs a workaround you'll need to delete keys following the completion of the iterator.\n\n```go\nvar delkeys []string\ntx.AscendKeys(\"object:*\", func(k, v string) bool {\n\tif someCondition(k) == true {\n\t\tdelkeys = append(delkeys, k)\n\t}\n\treturn true // continue\n})\nfor _, k := range delkeys {\n\tif _, err = tx.Delete(k); err != nil {\n\t\treturn err\n\t}\n}\n```\n\n## Append-only File\n\nBuntDB uses an AOF (append-only file) which is a log of all database changes that occur from operations like `Set()` and `Delete()`.\n\nThe format of this file looks like:\n```\nset key:1 value1\nset key:2 value2\nset key:1 value3\ndel key:2\n...\n```\n\nWhen the database opens again, it will read back the aof file and process each command in exact order.\nThis read process happens one time when the database opens.\nFrom there on the file is only appended.\n\nAs you may guess this log file can grow large over time.\nThere's a background routine that automatically shrinks the log file when it gets too large.\nThere is also a `Shrink()` function which will rewrite the aof file so that it contains only the items in the database.\nThe shrink operation does not lock up the database so read and write transactions can continue while shrinking is in process.\n\n### Durability and fsync\n\nBy default BuntDB executes an `fsync` once every second on the [aof file](#append-only-file). Which simply means that there's a chance that up to one second of data might be lost. If you need higher durability then there's an optional database config setting `Config.SyncPolicy` which can be set to `Always`.\n\nThe `Config.SyncPolicy` has the following options:\n\n- `Never` - fsync is managed by the operating system, less safe\n- `EverySecond` - fsync every second, fast and safer, this is the default\n- `Always` - fsync after every write, very durable, slower\n\n## Config\n\nHere are some configuration options that can be use to change various behaviors of the database.\n\n- **SyncPolicy** adjusts how often the data is synced to disk. This value can be Never, EverySecond, or Always. Default is EverySecond.\n- **AutoShrinkPercentage** is used by the background process to trigger a shrink of the aof file when the size of the file is larger than the percentage of the result of the previous shrunk file. For example, if this value is 100, and the last shrink process resulted in a 100mb file, then the new aof file must be 200mb before a shrink is triggered. Default is 100.\n- **AutoShrinkMinSize** defines the minimum size of the aof file before an automatic shrink can occur. Default is 32MB.\n- **AutoShrinkDisabled** turns off automatic background shrinking. Default is false.\n\nTo update the configuration you should call `ReadConfig` followed by `SetConfig`. For example:\n\n```go\n\nvar config buntdb.Config\nif err := db.ReadConfig(&config); err != nil{\n\tlog.Fatal(err)\n}\nif err := db.SetConfig(config); err != nil{\n\tlog.Fatal(err)\n}\n```\n\n## Performance\n\nHow fast is BuntDB?\n\nHere are some example [benchmarks](https://github.com/tidwall/raft-buntdb#raftstore-performance-comparison) when using BuntDB in a Raft Store implementation.\n\nYou can also run the standard Go benchmark tool from the project root directory:\n\n```\ngo test --bench=.\n```\n\n### BuntDB-Benchmark\n\nThere's a [custom utility](https://github.com/tidwall/buntdb-benchmark) that was created specifically for benchmarking BuntDB.\n\n*These are the results from running the benchmarks on a MacBook Pro 15\" 2.8 GHz Intel Core i7:*\n\n```\n$ buntdb-benchmark -q\nGET: 4609604.74 operations per second\nSET: 248500.33 operations per second\nASCEND_100: 2268998.79 operations per second\nASCEND_200: 1178388.14 operations per second\nASCEND_400: 679134.20 operations per second\nASCEND_800: 348445.55 operations per second\nDESCEND_100: 2313821.69 operations per second\nDESCEND_200: 1292738.38 operations per second\nDESCEND_400: 675258.76 operations per second\nDESCEND_800: 337481.67 operations per second\nSPATIAL_SET: 134824.60 operations per second\nSPATIAL_INTERSECTS_100: 939491.47 operations per second\nSPATIAL_INTERSECTS_200: 561590.40 operations per second\nSPATIAL_INTERSECTS_400: 306951.15 operations per second\nSPATIAL_INTERSECTS_800: 159673.91 operations per second\n```\n\nTo install this utility:\n\n```\ngo get github.com/tidwall/buntdb-benchmark\n```\n\n\n\n## Contact\nJosh Baker [@tidwall](http://twitter.com/tidwall)\n\n## License\n\nBuntDB source code is available under the MIT [License](/LICENSE).\n"
        },
        {
          "name": "buntdb.go",
          "type": "blob",
          "size": 69.7490234375,
          "content": "// Package buntdb implements a low-level in-memory key/value store in pure Go.\n// It persists to disk, is ACID compliant, and uses locking for multiple\n// readers and a single writer. Bunt is ideal for projects that need a\n// dependable database, and favor speed over data size.\npackage buntdb\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"runtime\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/tidwall/btree\"\n\t\"github.com/tidwall/gjson\"\n\t\"github.com/tidwall/grect\"\n\t\"github.com/tidwall/match\"\n\t\"github.com/tidwall/rtred\"\n)\n\nvar (\n\t// ErrTxNotWritable is returned when performing a write operation on a\n\t// read-only transaction.\n\tErrTxNotWritable = errors.New(\"tx not writable\")\n\n\t// ErrTxClosed is returned when committing or rolling back a transaction\n\t// that has already been committed or rolled back.\n\tErrTxClosed = errors.New(\"tx closed\")\n\n\t// ErrNotFound is returned when an item or index is not in the database.\n\tErrNotFound = errors.New(\"not found\")\n\n\t// ErrInvalid is returned when the database file is an invalid format.\n\tErrInvalid = errors.New(\"invalid database\")\n\n\t// ErrDatabaseClosed is returned when the database is closed.\n\tErrDatabaseClosed = errors.New(\"database closed\")\n\n\t// ErrIndexExists is returned when an index already exists in the database.\n\tErrIndexExists = errors.New(\"index exists\")\n\n\t// ErrInvalidOperation is returned when an operation cannot be completed.\n\tErrInvalidOperation = errors.New(\"invalid operation\")\n\n\t// ErrInvalidSyncPolicy is returned for an invalid SyncPolicy value.\n\tErrInvalidSyncPolicy = errors.New(\"invalid sync policy\")\n\n\t// ErrShrinkInProcess is returned when a shrink operation is in-process.\n\tErrShrinkInProcess = errors.New(\"shrink is in-process\")\n\n\t// ErrPersistenceActive is returned when post-loading data from an database\n\t// not opened with Open(\":memory:\").\n\tErrPersistenceActive = errors.New(\"persistence active\")\n\n\t// ErrTxIterating is returned when Set or Delete are called while iterating.\n\tErrTxIterating = errors.New(\"tx is iterating\")\n)\n\nconst useAbsEx = true\n\n// DB represents a collection of key-value pairs that persist on disk.\n// Transactions are used for all forms of data access to the DB.\ntype DB struct {\n\tmu        sync.RWMutex      // the gatekeeper for all fields\n\tfile      *os.File          // the underlying file\n\tbuf       []byte            // a buffer to write to\n\tkeys      *btree.BTree      // a tree of all item ordered by key\n\texps      *btree.BTree      // a tree of items ordered by expiration\n\tidxs      map[string]*index // the index trees.\n\tinsIdxs   []*index          // a reuse buffer for gathering indexes\n\tflushes   int               // a count of the number of disk flushes\n\tclosed    bool              // set when the database has been closed\n\tconfig    Config            // the database configuration\n\tpersist   bool              // do we write to disk\n\tshrinking bool              // when an aof shrink is in-process.\n\tlastaofsz int               // the size of the last shrink aof size\n}\n\n// SyncPolicy represents how often data is synced to disk.\ntype SyncPolicy int\n\nconst (\n\t// Never is used to disable syncing data to disk.\n\t// The faster and less safe method.\n\tNever SyncPolicy = 0\n\t// EverySecond is used to sync data to disk every second.\n\t// It's pretty fast and you can lose 1 second of data if there\n\t// is a disaster.\n\t// This is the recommended setting.\n\tEverySecond = 1\n\t// Always is used to sync data after every write to disk.\n\t// Slow. Very safe.\n\tAlways = 2\n)\n\n// Config represents database configuration options. These\n// options are used to change various behaviors of the database.\ntype Config struct {\n\t// SyncPolicy adjusts how often the data is synced to disk.\n\t// This value can be Never, EverySecond, or Always.\n\t// The default is EverySecond.\n\tSyncPolicy SyncPolicy\n\n\t// AutoShrinkPercentage is used by the background process to trigger\n\t// a shrink of the aof file when the size of the file is larger than the\n\t// percentage of the result of the previous shrunk file.\n\t// For example, if this value is 100, and the last shrink process\n\t// resulted in a 100mb file, then the new aof file must be 200mb before\n\t// a shrink is triggered.\n\tAutoShrinkPercentage int\n\n\t// AutoShrinkMinSize defines the minimum size of the aof file before\n\t// an automatic shrink can occur.\n\tAutoShrinkMinSize int\n\n\t// AutoShrinkDisabled turns off automatic background shrinking\n\tAutoShrinkDisabled bool\n\n\t// OnExpired is used to custom handle the deletion option when a key\n\t// has been expired.\n\tOnExpired func(keys []string)\n\n\t// OnExpiredSync will be called inside the same transaction that is\n\t// performing the deletion of expired items. If OnExpired is present then\n\t// this callback will not be called. If this callback is present, then the\n\t// deletion of the timeed-out item is the explicit responsibility of this\n\t// callback.\n\tOnExpiredSync func(key, value string, tx *Tx) error\n}\n\n// exctx is a simple b-tree context for ordering by expiration.\ntype exctx struct {\n\tdb *DB\n}\n\n// Open opens a database at the provided path.\n// If the file does not exist then it will be created automatically.\nfunc Open(path string) (*DB, error) {\n\tdb := &DB{}\n\t// initialize trees and indexes\n\tdb.keys = btreeNew(lessCtx(nil))\n\tdb.exps = btreeNew(lessCtx(&exctx{db}))\n\tdb.idxs = make(map[string]*index)\n\t// initialize default configuration\n\tdb.config = Config{\n\t\tSyncPolicy:           EverySecond,\n\t\tAutoShrinkPercentage: 100,\n\t\tAutoShrinkMinSize:    32 * 1024 * 1024,\n\t}\n\t// turn off persistence for pure in-memory\n\tdb.persist = path != \":memory:\"\n\tif db.persist {\n\t\tvar err error\n\t\t// hardcoding 0666 as the default mode.\n\t\tdb.file, err = os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0666)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// load the database from disk\n\t\tif err := db.load(); err != nil {\n\t\t\t// close on error, ignore close error\n\t\t\t_ = db.file.Close()\n\t\t\treturn nil, err\n\t\t}\n\t}\n\t// start the background manager.\n\tgo db.backgroundManager()\n\treturn db, nil\n}\n\n// Close releases all database resources.\n// All transactions must be closed before closing the database.\nfunc (db *DB) Close() error {\n\tdb.mu.Lock()\n\tdefer db.mu.Unlock()\n\tif db.closed {\n\t\treturn ErrDatabaseClosed\n\t}\n\tdb.closed = true\n\tif db.persist {\n\t\tdb.file.Sync() // do a sync but ignore the error\n\t\tif err := db.file.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// Let's release all references to nil. This will help both with debugging\n\t// late usage panics and it provides a hint to the garbage collector\n\tdb.keys, db.exps, db.idxs, db.file = nil, nil, nil, nil\n\treturn nil\n}\n\n// Save writes a snapshot of the database to a writer. This operation blocks all\n// writes, but not reads. This can be used for snapshots and backups for pure\n// in-memory databases using the \":memory:\". Database that persist to disk\n// can be snapshotted by simply copying the database file.\nfunc (db *DB) Save(wr io.Writer) error {\n\tvar err error\n\tdb.mu.RLock()\n\tdefer db.mu.RUnlock()\n\t// use a buffered writer and flush every 4MB\n\tvar buf []byte\n\tnow := time.Now()\n\t// iterated through every item in the database and write to the buffer\n\tbtreeAscend(db.keys, func(item interface{}) bool {\n\t\tdbi := item.(*dbItem)\n\t\tbuf = dbi.writeSetTo(buf, now)\n\t\tif len(buf) > 1024*1024*4 {\n\t\t\t// flush when buffer is over 4MB\n\t\t\t_, err = wr.Write(buf)\n\t\t\tif err != nil {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tbuf = buf[:0]\n\t\t}\n\t\treturn true\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\t// one final flush\n\tif len(buf) > 0 {\n\t\t_, err = wr.Write(buf)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n// Load loads commands from reader. This operation blocks all reads and writes.\n// Note that this can only work for fully in-memory databases opened with\n// Open(\":memory:\").\nfunc (db *DB) Load(rd io.Reader) error {\n\tdb.mu.Lock()\n\tdefer db.mu.Unlock()\n\tif db.persist {\n\t\t// cannot load into databases that persist to disk\n\t\treturn ErrPersistenceActive\n\t}\n\t_, err := db.readLoad(rd, time.Now())\n\treturn err\n}\n\n// index represents a b-tree or r-tree index and also acts as the\n// b-tree/r-tree context for itself.\ntype index struct {\n\tbtr     *btree.BTree                           // contains the items\n\trtr     *rtred.RTree                           // contains the items\n\tname    string                                 // name of the index\n\tpattern string                                 // a required key pattern\n\tless    func(a, b string) bool                 // less comparison function\n\trect    func(item string) (min, max []float64) // rect from string function\n\tdb      *DB                                    // the origin database\n\topts    IndexOptions                           // index options\n}\n\n// match matches the pattern to the key\nfunc (idx *index) match(key string) bool {\n\tif idx.pattern == \"*\" {\n\t\treturn true\n\t}\n\tif idx.opts.CaseInsensitiveKeyMatching {\n\t\tfor i := 0; i < len(key); i++ {\n\t\t\tif key[i] >= 'A' && key[i] <= 'Z' {\n\t\t\t\tkey = strings.ToLower(key)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn match.Match(key, idx.pattern)\n}\n\n// clearCopy creates a copy of the index, but with an empty dataset.\nfunc (idx *index) clearCopy() *index {\n\t// copy the index meta information\n\tnidx := &index{\n\t\tname:    idx.name,\n\t\tpattern: idx.pattern,\n\t\tdb:      idx.db,\n\t\tless:    idx.less,\n\t\trect:    idx.rect,\n\t\topts:    idx.opts,\n\t}\n\t// initialize with empty trees\n\tif nidx.less != nil {\n\t\tnidx.btr = btreeNew(lessCtx(nidx))\n\t}\n\tif nidx.rect != nil {\n\t\tnidx.rtr = rtred.New(nidx)\n\t}\n\treturn nidx\n}\n\n// rebuild rebuilds the index\nfunc (idx *index) rebuild() {\n\t// initialize trees\n\tif idx.less != nil {\n\t\tidx.btr = btreeNew(lessCtx(idx))\n\t}\n\tif idx.rect != nil {\n\t\tidx.rtr = rtred.New(idx)\n\t}\n\t// iterate through all keys and fill the index\n\tbtreeAscend(idx.db.keys, func(item interface{}) bool {\n\t\tdbi := item.(*dbItem)\n\t\tif !idx.match(dbi.key) {\n\t\t\t// does not match the pattern, continue\n\t\t\treturn true\n\t\t}\n\t\tif idx.less != nil {\n\t\t\tidx.btr.Set(dbi)\n\t\t}\n\t\tif idx.rect != nil {\n\t\t\tidx.rtr.Insert(dbi)\n\t\t}\n\t\treturn true\n\t})\n}\n\n// CreateIndex builds a new index and populates it with items.\n// The items are ordered in an b-tree and can be retrieved using the\n// Ascend* and Descend* methods.\n// An error will occur if an index with the same name already exists.\n//\n// When a pattern is provided, the index will be populated with\n// keys that match the specified pattern. This is a very simple pattern\n// match where '*' matches on any number characters and '?' matches on\n// any one character.\n// The less function compares if string 'a' is less than string 'b'.\n// It allows for indexes to create custom ordering. It's possible\n// that the strings may be textual or binary. It's up to the provided\n// less function to handle the content format and comparison.\n// There are some default less function that can be used such as\n// IndexString, IndexBinary, etc.\nfunc (db *DB) CreateIndex(name, pattern string,\n\tless ...func(a, b string) bool) error {\n\treturn db.Update(func(tx *Tx) error {\n\t\treturn tx.CreateIndex(name, pattern, less...)\n\t})\n}\n\n// ReplaceIndex builds a new index and populates it with items.\n// The items are ordered in an b-tree and can be retrieved using the\n// Ascend* and Descend* methods.\n// If a previous index with the same name exists, that index will be deleted.\nfunc (db *DB) ReplaceIndex(name, pattern string,\n\tless ...func(a, b string) bool) error {\n\treturn db.Update(func(tx *Tx) error {\n\t\terr := tx.CreateIndex(name, pattern, less...)\n\t\tif err != nil {\n\t\t\tif err == ErrIndexExists {\n\t\t\t\terr := tx.DropIndex(name)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn tx.CreateIndex(name, pattern, less...)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// CreateSpatialIndex builds a new index and populates it with items.\n// The items are organized in an r-tree and can be retrieved using the\n// Intersects method.\n// An error will occur if an index with the same name already exists.\n//\n// The rect function converts a string to a rectangle. The rectangle is\n// represented by two arrays, min and max. Both arrays may have a length\n// between 1 and 20, and both arrays must match in length. A length of 1 is a\n// one dimensional rectangle, and a length of 4 is a four dimension rectangle.\n// There is support for up to 20 dimensions.\n// The values of min must be less than the values of max at the same dimension.\n// Thus min[0] must be less-than-or-equal-to max[0].\n// The IndexRect is a default function that can be used for the rect\n// parameter.\nfunc (db *DB) CreateSpatialIndex(name, pattern string,\n\trect func(item string) (min, max []float64)) error {\n\treturn db.Update(func(tx *Tx) error {\n\t\treturn tx.CreateSpatialIndex(name, pattern, rect)\n\t})\n}\n\n// ReplaceSpatialIndex builds a new index and populates it with items.\n// The items are organized in an r-tree and can be retrieved using the\n// Intersects method.\n// If a previous index with the same name exists, that index will be deleted.\nfunc (db *DB) ReplaceSpatialIndex(name, pattern string,\n\trect func(item string) (min, max []float64)) error {\n\treturn db.Update(func(tx *Tx) error {\n\t\terr := tx.CreateSpatialIndex(name, pattern, rect)\n\t\tif err != nil {\n\t\t\tif err == ErrIndexExists {\n\t\t\t\terr := tx.DropIndex(name)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\treturn tx.CreateSpatialIndex(name, pattern, rect)\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n}\n\n// DropIndex removes an index.\nfunc (db *DB) DropIndex(name string) error {\n\treturn db.Update(func(tx *Tx) error {\n\t\treturn tx.DropIndex(name)\n\t})\n}\n\n// Indexes returns a list of index names.\nfunc (db *DB) Indexes() ([]string, error) {\n\tvar names []string\n\tvar err = db.View(func(tx *Tx) error {\n\t\tvar err error\n\t\tnames, err = tx.Indexes()\n\t\treturn err\n\t})\n\treturn names, err\n}\n\n// ReadConfig returns the database configuration.\nfunc (db *DB) ReadConfig(config *Config) error {\n\tdb.mu.RLock()\n\tdefer db.mu.RUnlock()\n\tif db.closed {\n\t\treturn ErrDatabaseClosed\n\t}\n\t*config = db.config\n\treturn nil\n}\n\n// SetConfig updates the database configuration.\nfunc (db *DB) SetConfig(config Config) error {\n\tdb.mu.Lock()\n\tdefer db.mu.Unlock()\n\tif db.closed {\n\t\treturn ErrDatabaseClosed\n\t}\n\tswitch config.SyncPolicy {\n\tdefault:\n\t\treturn ErrInvalidSyncPolicy\n\tcase Never, EverySecond, Always:\n\t}\n\tdb.config = config\n\treturn nil\n}\n\n// insertIntoDatabase performs inserts an item in to the database and updates\n// all indexes. If a previous item with the same key already exists, that item\n// will be replaced with the new one, and return the previous item.\nfunc (db *DB) insertIntoDatabase(item *dbItem) *dbItem {\n\tvar pdbi *dbItem\n\t// Generate a list of indexes that this item will be inserted in to.\n\tidxs := db.insIdxs\n\tfor _, idx := range db.idxs {\n\t\tif idx.match(item.key) {\n\t\t\tidxs = append(idxs, idx)\n\t\t}\n\t}\n\tprev := db.keys.Set(item)\n\tif prev != nil {\n\t\t// A previous item was removed from the keys tree. Let's\n\t\t// fully delete this item from all indexes.\n\t\tpdbi = prev.(*dbItem)\n\t\tif pdbi.opts != nil && pdbi.opts.ex {\n\t\t\t// Remove it from the expires tree.\n\t\t\tdb.exps.Delete(pdbi)\n\t\t}\n\t\tfor _, idx := range idxs {\n\t\t\tif idx.btr != nil {\n\t\t\t\t// Remove it from the btree index.\n\t\t\t\tidx.btr.Delete(pdbi)\n\t\t\t}\n\t\t\tif idx.rtr != nil {\n\t\t\t\t// Remove it from the rtree index.\n\t\t\t\tidx.rtr.Remove(pdbi)\n\t\t\t}\n\t\t}\n\t}\n\tif item.opts != nil && item.opts.ex {\n\t\t// The new item has eviction options. Add it to the\n\t\t// expires tree\n\t\tdb.exps.Set(item)\n\t}\n\tfor i, idx := range idxs {\n\t\tif idx.btr != nil {\n\t\t\t// Add new item to btree index.\n\t\t\tidx.btr.Set(item)\n\t\t}\n\t\tif idx.rtr != nil {\n\t\t\t// Add new item to rtree index.\n\t\t\tidx.rtr.Insert(item)\n\t\t}\n\t\t// clear the index\n\t\tidxs[i] = nil\n\t}\n\t// reuse the index list slice\n\tdb.insIdxs = idxs[:0]\n\t// we must return the previous item to the caller.\n\treturn pdbi\n}\n\n// deleteFromDatabase removes and item from the database and indexes. The input\n// item must only have the key field specified thus \"&dbItem{key: key}\" is all\n// that is needed to fully remove the item with the matching key. If an item\n// with the matching key was found in the database, it will be removed and\n// returned to the caller. A nil return value means that the item was not\n// found in the database\nfunc (db *DB) deleteFromDatabase(item *dbItem) *dbItem {\n\tvar pdbi *dbItem\n\tprev := db.keys.Delete(item)\n\tif prev != nil {\n\t\tpdbi = prev.(*dbItem)\n\t\tif pdbi.opts != nil && pdbi.opts.ex {\n\t\t\t// Remove it from the exipres tree.\n\t\t\tdb.exps.Delete(pdbi)\n\t\t}\n\t\tfor _, idx := range db.idxs {\n\t\t\tif !idx.match(pdbi.key) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif idx.btr != nil {\n\t\t\t\t// Remove it from the btree index.\n\t\t\t\tidx.btr.Delete(pdbi)\n\t\t\t}\n\t\t\tif idx.rtr != nil {\n\t\t\t\t// Remove it from the rtree index.\n\t\t\t\tidx.rtr.Remove(pdbi)\n\t\t\t}\n\t\t}\n\t}\n\treturn pdbi\n}\n\n// backgroundManager runs continuously in the background and performs various\n// operations such as removing expired items and syncing to disk.\nfunc (db *DB) backgroundManager() {\n\tflushes := 0\n\tt := time.NewTicker(time.Second)\n\tdefer t.Stop()\n\tfor range t.C {\n\t\tvar shrink bool\n\t\t// Open a standard view. This will take a full lock of the\n\t\t// database thus allowing for access to anything we need.\n\t\tvar onExpired func([]string)\n\t\tvar expired []*dbItem\n\t\tvar onExpiredSync func(key, value string, tx *Tx) error\n\t\terr := db.Update(func(tx *Tx) error {\n\t\t\tonExpired = db.config.OnExpired\n\t\t\tif onExpired == nil {\n\t\t\t\tonExpiredSync = db.config.OnExpiredSync\n\t\t\t}\n\t\t\tif db.persist && !db.config.AutoShrinkDisabled {\n\t\t\t\tpos, err := db.file.Seek(0, 1)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\taofsz := int(pos)\n\t\t\t\tif aofsz > db.config.AutoShrinkMinSize {\n\t\t\t\t\tprc := float64(db.config.AutoShrinkPercentage) / 100.0\n\t\t\t\t\tshrink = aofsz > db.lastaofsz+int(float64(db.lastaofsz)*prc)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// produce a list of expired items that need removing\n\t\t\tbtreeAscendLessThan(db.exps, &dbItem{\n\t\t\t\topts: &dbItemOpts{ex: true, exat: time.Now()},\n\t\t\t}, func(item interface{}) bool {\n\t\t\t\texpired = append(expired, item.(*dbItem))\n\t\t\t\treturn true\n\t\t\t})\n\t\t\tif onExpired == nil && onExpiredSync == nil {\n\t\t\t\tfor _, itm := range expired {\n\t\t\t\t\tif _, err := tx.Delete(itm.key); err != nil {\n\t\t\t\t\t\t// it's ok to get a \"not found\" because the\n\t\t\t\t\t\t// 'Delete' method reports \"not found\" for\n\t\t\t\t\t\t// expired items.\n\t\t\t\t\t\tif err != ErrNotFound {\n\t\t\t\t\t\t\treturn err\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if onExpiredSync != nil {\n\t\t\t\tfor _, itm := range expired {\n\t\t\t\t\tif err := onExpiredSync(itm.key, itm.val, tx); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err == ErrDatabaseClosed {\n\t\t\tbreak\n\t\t}\n\n\t\t// send expired event, if needed\n\t\tif onExpired != nil && len(expired) > 0 {\n\t\t\tkeys := make([]string, 0, 32)\n\t\t\tfor _, itm := range expired {\n\t\t\t\tkeys = append(keys, itm.key)\n\t\t\t}\n\t\t\tonExpired(keys)\n\t\t}\n\n\t\t// execute a disk sync, if needed\n\t\tfunc() {\n\t\t\tdb.mu.Lock()\n\t\t\tdefer db.mu.Unlock()\n\t\t\tif db.persist && db.config.SyncPolicy == EverySecond &&\n\t\t\t\tflushes != db.flushes {\n\t\t\t\t_ = db.file.Sync()\n\t\t\t\tflushes = db.flushes\n\t\t\t}\n\t\t}()\n\t\tif shrink {\n\t\t\tif err = db.Shrink(); err != nil {\n\t\t\t\tif err == ErrDatabaseClosed {\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Shrink will make the database file smaller by removing redundant\n// log entries. This operation does not block the database.\nfunc (db *DB) Shrink() error {\n\tdb.mu.Lock()\n\tif db.closed {\n\t\tdb.mu.Unlock()\n\t\treturn ErrDatabaseClosed\n\t}\n\tif !db.persist {\n\t\t// The database was opened with \":memory:\" as the path.\n\t\t// There is no persistence, and no need to do anything here.\n\t\tdb.mu.Unlock()\n\t\treturn nil\n\t}\n\tif db.shrinking {\n\t\t// The database is already in the process of shrinking.\n\t\tdb.mu.Unlock()\n\t\treturn ErrShrinkInProcess\n\t}\n\tdb.shrinking = true\n\tdefer func() {\n\t\tdb.mu.Lock()\n\t\tdb.shrinking = false\n\t\tdb.mu.Unlock()\n\t}()\n\tfname := db.file.Name()\n\ttmpname := fname + \".tmp\"\n\t// the endpos is used to return to the end of the file when we are\n\t// finished writing all of the current items.\n\tendpos, err := db.file.Seek(0, 2)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdb.mu.Unlock()\n\ttime.Sleep(time.Second / 4) // wait just a bit before starting\n\tf, err := os.Create(tmpname)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\t_ = f.Close()\n\t\t_ = os.RemoveAll(tmpname)\n\t}()\n\n\t// we are going to read items in as chunks as to not hold up the database\n\t// for too long.\n\tvar buf []byte\n\tpivot := \"\"\n\tdone := false\n\tfor !done {\n\t\terr := func() error {\n\t\t\tdb.mu.RLock()\n\t\t\tdefer db.mu.RUnlock()\n\t\t\tif db.closed {\n\t\t\t\treturn ErrDatabaseClosed\n\t\t\t}\n\t\t\tdone = true\n\t\t\tvar n int\n\t\t\tnow := time.Now()\n\t\t\tbtreeAscendGreaterOrEqual(db.keys, &dbItem{key: pivot},\n\t\t\t\tfunc(item interface{}) bool {\n\t\t\t\t\tdbi := item.(*dbItem)\n\t\t\t\t\t// 1000 items or 64MB buffer\n\t\t\t\t\tif n > 1000 || len(buf) > 64*1024*1024 {\n\t\t\t\t\t\tpivot = dbi.key\n\t\t\t\t\t\tdone = false\n\t\t\t\t\t\treturn false\n\t\t\t\t\t}\n\t\t\t\t\tbuf = dbi.writeSetTo(buf, now)\n\t\t\t\t\tn++\n\t\t\t\t\treturn true\n\t\t\t\t},\n\t\t\t)\n\t\t\tif len(buf) > 0 {\n\t\t\t\tif _, err := f.Write(buf); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tbuf = buf[:0]\n\t\t\t}\n\t\t\treturn nil\n\t\t}()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\t// We reached this far so all of the items have been written to a new tmp\n\t// There's some more work to do by appending the new line from the aof\n\t// to the tmp file and finally swap the files out.\n\treturn func() error {\n\t\t// We're wrapping this in a function to get the benefit of a defered\n\t\t// lock/unlock.\n\t\tdb.mu.Lock()\n\t\tdefer db.mu.Unlock()\n\t\tif db.closed {\n\t\t\treturn ErrDatabaseClosed\n\t\t}\n\t\t// We are going to open a new version of the aof file so that we do\n\t\t// not change the seek position of the previous. This may cause a\n\t\t// problem in the future if we choose to use syscall file locking.\n\t\taof, err := os.Open(fname)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer func() { _ = aof.Close() }()\n\t\tif _, err := aof.Seek(endpos, 0); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Just copy all of the new commands that have occurred since we\n\t\t// started the shrink process.\n\t\tif _, err := io.Copy(f, aof); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Close all files\n\t\tif err := aof.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := f.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := db.file.Close(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Any failures below here are really bad. So just panic.\n\t\tif err := renameFile(tmpname, fname); err != nil {\n\t\t\tpanicErr(err)\n\t\t}\n\t\tdb.file, err = os.OpenFile(fname, os.O_CREATE|os.O_RDWR, 0666)\n\t\tif err != nil {\n\t\t\tpanicErr(err)\n\t\t}\n\t\tpos, err := db.file.Seek(0, 2)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdb.lastaofsz = int(pos)\n\t\treturn nil\n\t}()\n}\n\nfunc panicErr(err error) error {\n\tpanic(fmt.Errorf(\"buntdb: %w\", err))\n}\n\nfunc renameFile(src, dest string) error {\n\tvar err error\n\tif err = os.Rename(src, dest); err != nil {\n\t\tif runtime.GOOS == \"windows\" {\n\t\t\tif err = os.Remove(dest); err == nil {\n\t\t\t\terr = os.Rename(src, dest)\n\t\t\t}\n\t\t}\n\t}\n\treturn err\n}\n\n// readLoad reads from the reader and loads commands into the database.\n// modTime is the modified time of the reader, should be no greater than\n// the current time.Now().\n// Returns the number of bytes of the last command read and the error if any.\nfunc (db *DB) readLoad(rd io.Reader, modTime time.Time) (n int64, err error) {\n\tdefer func() {\n\t\tif err == io.EOF {\n\t\t\terr = io.ErrUnexpectedEOF\n\t\t}\n\t}()\n\ttotalSize := int64(0)\n\tdata := make([]byte, 4096)\n\tparts := make([]string, 0, 8)\n\tr := bufio.NewReader(rd)\n\tfor {\n\t\t// peek at the first byte. If it's a 'nul' control character then\n\t\t// ignore it and move to the next byte.\n\t\tc, err := r.ReadByte()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\terr = nil\n\t\t\t}\n\t\t\treturn totalSize, err\n\t\t}\n\t\tif c == 0 {\n\t\t\t// ignore nul control characters\n\t\t\tn += 1\n\t\t\tcontinue\n\t\t}\n\t\tif err := r.UnreadByte(); err != nil {\n\t\t\treturn totalSize, err\n\t\t}\n\n\t\t// read a single command.\n\t\t// first we should read the number of parts that the of the command\n\t\tcmdByteSize := int64(0)\n\t\tline, err := r.ReadBytes('\\n')\n\t\tif err != nil {\n\t\t\treturn totalSize, err\n\t\t}\n\t\tif line[0] != '*' {\n\t\t\treturn totalSize, ErrInvalid\n\t\t}\n\t\tcmdByteSize += int64(len(line))\n\n\t\t// convert the string number to and int\n\t\tvar n int\n\t\tif len(line) == 4 && line[len(line)-2] == '\\r' {\n\t\t\tif line[1] < '0' || line[1] > '9' {\n\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t}\n\t\t\tn = int(line[1] - '0')\n\t\t} else {\n\t\t\tif len(line) < 5 || line[len(line)-2] != '\\r' {\n\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t}\n\t\t\tfor i := 1; i < len(line)-2; i++ {\n\t\t\t\tif line[i] < '0' || line[i] > '9' {\n\t\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t\t}\n\t\t\t\tn = n*10 + int(line[i]-'0')\n\t\t\t}\n\t\t}\n\t\t// read each part of the command.\n\t\tparts = parts[:0]\n\t\tfor i := 0; i < n; i++ {\n\t\t\t// read the number of bytes of the part.\n\t\t\tline, err := r.ReadBytes('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn totalSize, err\n\t\t\t}\n\t\t\tif line[0] != '$' {\n\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t}\n\t\t\tcmdByteSize += int64(len(line))\n\t\t\t// convert the string number to and int\n\t\t\tvar n int\n\t\t\tif len(line) == 4 && line[len(line)-2] == '\\r' {\n\t\t\t\tif line[1] < '0' || line[1] > '9' {\n\t\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t\t}\n\t\t\t\tn = int(line[1] - '0')\n\t\t\t} else {\n\t\t\t\tif len(line) < 5 || line[len(line)-2] != '\\r' {\n\t\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t\t}\n\t\t\t\tfor i := 1; i < len(line)-2; i++ {\n\t\t\t\t\tif line[i] < '0' || line[i] > '9' {\n\t\t\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t\t\t}\n\t\t\t\t\tn = n*10 + int(line[i]-'0')\n\t\t\t\t}\n\t\t\t}\n\t\t\t// resize the read buffer\n\t\t\tif len(data) < n+2 {\n\t\t\t\tdataln := len(data)\n\t\t\t\tfor dataln < n+2 {\n\t\t\t\t\tdataln *= 2\n\t\t\t\t}\n\t\t\t\tdata = make([]byte, dataln)\n\t\t\t}\n\t\t\tif _, err = io.ReadFull(r, data[:n+2]); err != nil {\n\t\t\t\treturn totalSize, err\n\t\t\t}\n\t\t\tif data[n] != '\\r' || data[n+1] != '\\n' {\n\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t}\n\t\t\t// copy string\n\t\t\tparts = append(parts, string(data[:n]))\n\t\t\tcmdByteSize += int64(n + 2)\n\t\t}\n\t\t// finished reading the command\n\n\t\tif len(parts) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif (parts[0][0] == 's' || parts[0][0] == 'S') &&\n\t\t\t(parts[0][1] == 'e' || parts[0][1] == 'E') &&\n\t\t\t(parts[0][2] == 't' || parts[0][2] == 'T') {\n\t\t\t// SET\n\t\t\tif len(parts) < 3 || len(parts) == 4 || len(parts) > 5 {\n\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t}\n\t\t\tif len(parts) == 5 {\n\t\t\t\targ := strings.ToLower(parts[3])\n\t\t\t\tif arg != \"ex\" && arg != \"ae\" {\n\t\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t\t}\n\t\t\t\tex, err := strconv.ParseInt(parts[4], 10, 64)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn totalSize, err\n\t\t\t\t}\n\t\t\t\tvar exat time.Time\n\t\t\t\tnow := time.Now()\n\t\t\t\tif arg == \"ex\" {\n\t\t\t\t\tdur := (time.Duration(ex) * time.Second) - now.Sub(modTime)\n\t\t\t\t\texat = now.Add(dur)\n\t\t\t\t} else {\n\t\t\t\t\texat = time.Unix(ex, 0)\n\t\t\t\t}\n\t\t\t\tif exat.After(now) {\n\t\t\t\t\tdb.insertIntoDatabase(&dbItem{\n\t\t\t\t\t\tkey: parts[1],\n\t\t\t\t\t\tval: parts[2],\n\t\t\t\t\t\topts: &dbItemOpts{\n\t\t\t\t\t\t\tex:   true,\n\t\t\t\t\t\t\texat: exat,\n\t\t\t\t\t\t},\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tdb.deleteFromDatabase(&dbItem{\n\t\t\t\t\t\tkey: parts[1],\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdb.insertIntoDatabase(&dbItem{key: parts[1], val: parts[2]})\n\t\t\t}\n\t\t} else if (parts[0][0] == 'd' || parts[0][0] == 'D') &&\n\t\t\t(parts[0][1] == 'e' || parts[0][1] == 'E') &&\n\t\t\t(parts[0][2] == 'l' || parts[0][2] == 'L') {\n\t\t\t// DEL\n\t\t\tif len(parts) != 2 {\n\t\t\t\treturn totalSize, ErrInvalid\n\t\t\t}\n\t\t\tdb.deleteFromDatabase(&dbItem{key: parts[1]})\n\t\t} else if (parts[0][0] == 'f' || parts[0][0] == 'F') &&\n\t\t\tstrings.ToLower(parts[0]) == \"flushdb\" {\n\t\t\tdb.keys = btreeNew(lessCtx(nil))\n\t\t\tdb.exps = btreeNew(lessCtx(&exctx{db}))\n\t\t\tdb.idxs = make(map[string]*index)\n\t\t} else {\n\t\t\treturn totalSize, ErrInvalid\n\t\t}\n\t\ttotalSize += cmdByteSize\n\t}\n}\n\n// load reads entries from the append only database file and fills the database.\n// The file format uses the Redis append only file format, which is and a series\n// of RESP commands. For more information on RESP please read\n// http://redis.io/topics/protocol. The only supported RESP commands are DEL and\n// SET.\nfunc (db *DB) load() error {\n\tfi, err := db.file.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\tn, err := db.readLoad(db.file, fi.ModTime())\n\tif err != nil {\n\t\tif err == io.ErrUnexpectedEOF {\n\t\t\t// The db file has ended mid-command, which is allowed but the\n\t\t\t// data file should be truncated to the end of the last valid\n\t\t\t// command\n\t\t\tif err := db.file.Truncate(n); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t} else {\n\t\t\treturn err\n\t\t}\n\t}\n\tif _, err := db.file.Seek(n, 0); err != nil {\n\t\treturn err\n\t}\n\tvar estaofsz int\n\tdb.keys.Walk(func(items []interface{}) {\n\t\tfor _, v := range items {\n\t\t\testaofsz += v.(*dbItem).estAOFSetSize()\n\t\t}\n\t})\n\tdb.lastaofsz += estaofsz\n\treturn nil\n}\n\n// managed calls a block of code that is fully contained in a transaction.\n// This method is intended to be wrapped by Update and View\nfunc (db *DB) managed(writable bool, fn func(tx *Tx) error) (err error) {\n\tvar tx *Tx\n\ttx, err = db.Begin(writable)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer func() {\n\t\tif err != nil {\n\t\t\t// The caller returned an error. We must rollback.\n\t\t\t_ = tx.Rollback()\n\t\t\treturn\n\t\t}\n\t\tif writable {\n\t\t\t// Everything went well. Lets Commit()\n\t\t\terr = tx.Commit()\n\t\t} else {\n\t\t\t// read-only transaction can only roll back.\n\t\t\terr = tx.Rollback()\n\t\t}\n\t}()\n\ttx.funcd = true\n\tdefer func() {\n\t\ttx.funcd = false\n\t}()\n\terr = fn(tx)\n\treturn\n}\n\n// View executes a function within a managed read-only transaction.\n// When a non-nil error is returned from the function that error will be return\n// to the caller of View().\n//\n// Executing a manual commit or rollback from inside the function will result\n// in a panic.\nfunc (db *DB) View(fn func(tx *Tx) error) error {\n\treturn db.managed(false, fn)\n}\n\n// Update executes a function within a managed read/write transaction.\n// The transaction has been committed when no error is returned.\n// In the event that an error is returned, the transaction will be rolled back.\n// When a non-nil error is returned from the function, the transaction will be\n// rolled back and the that error will be return to the caller of Update().\n//\n// Executing a manual commit or rollback from inside the function will result\n// in a panic.\nfunc (db *DB) Update(fn func(tx *Tx) error) error {\n\treturn db.managed(true, fn)\n}\n\n// get return an item or nil if not found.\nfunc (db *DB) get(key string) *dbItem {\n\titem := db.keys.Get(&dbItem{key: key})\n\tif item != nil {\n\t\treturn item.(*dbItem)\n\t}\n\treturn nil\n}\n\n// Tx represents a transaction on the database. This transaction can either be\n// read-only or read/write. Read-only transactions can be used for retrieving\n// values for keys and iterating through keys and values. Read/write\n// transactions can set and delete keys.\n//\n// All transactions must be committed or rolled-back when done.\ntype Tx struct {\n\tdb       *DB             // the underlying database.\n\twritable bool            // when false mutable operations fail.\n\tfuncd    bool            // when true Commit and Rollback panic.\n\twc       *txWriteContext // context for writable transactions.\n}\n\ntype txWriteContext struct {\n\t// rollback when deleteAll is called\n\trbkeys *btree.BTree      // a tree of all item ordered by key\n\trbexps *btree.BTree      // a tree of items ordered by expiration\n\trbidxs map[string]*index // the index trees.\n\n\trollbackItems   map[string]*dbItem // details for rolling back tx.\n\tcommitItems     map[string]*dbItem // details for committing tx.\n\titercount       int                // stack of iterators\n\trollbackIndexes map[string]*index  // details for dropped indexes.\n}\n\n// DeleteAll deletes all items from the database.\nfunc (tx *Tx) DeleteAll() error {\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn ErrTxNotWritable\n\t} else if tx.wc.itercount > 0 {\n\t\treturn ErrTxIterating\n\t}\n\n\t// check to see if we've already deleted everything\n\tif tx.wc.rbkeys == nil {\n\t\t// we need to backup the live data in case of a rollback.\n\t\ttx.wc.rbkeys = tx.db.keys\n\t\ttx.wc.rbexps = tx.db.exps\n\t\ttx.wc.rbidxs = tx.db.idxs\n\t}\n\n\t// now reset the live database trees\n\ttx.db.keys = btreeNew(lessCtx(nil))\n\ttx.db.exps = btreeNew(lessCtx(&exctx{tx.db}))\n\ttx.db.idxs = make(map[string]*index)\n\n\t// finally re-create the indexes\n\tfor name, idx := range tx.wc.rbidxs {\n\t\ttx.db.idxs[name] = idx.clearCopy()\n\t}\n\n\t// always clear out the commits\n\ttx.wc.commitItems = make(map[string]*dbItem)\n\n\treturn nil\n}\n\n// Begin opens a new transaction.\n// Multiple read-only transactions can be opened at the same time but there can\n// only be one read/write transaction at a time. Attempting to open a read/write\n// transactions while another one is in progress will result in blocking until\n// the current read/write transaction is completed.\n//\n// All transactions must be closed by calling Commit() or Rollback() when done.\nfunc (db *DB) Begin(writable bool) (*Tx, error) {\n\ttx := &Tx{\n\t\tdb:       db,\n\t\twritable: writable,\n\t}\n\ttx.lock()\n\tif db.closed {\n\t\ttx.unlock()\n\t\treturn nil, ErrDatabaseClosed\n\t}\n\tif writable {\n\t\t// writable transactions have a writeContext object that\n\t\t// contains information about changes to the database.\n\t\ttx.wc = &txWriteContext{}\n\t\ttx.wc.rollbackItems = make(map[string]*dbItem)\n\t\ttx.wc.rollbackIndexes = make(map[string]*index)\n\t\tif db.persist {\n\t\t\ttx.wc.commitItems = make(map[string]*dbItem)\n\t\t}\n\t}\n\treturn tx, nil\n}\n\n// lock locks the database based on the transaction type.\nfunc (tx *Tx) lock() {\n\tif tx.writable {\n\t\ttx.db.mu.Lock()\n\t} else {\n\t\ttx.db.mu.RLock()\n\t}\n}\n\n// unlock unlocks the database based on the transaction type.\nfunc (tx *Tx) unlock() {\n\tif tx.writable {\n\t\ttx.db.mu.Unlock()\n\t} else {\n\t\ttx.db.mu.RUnlock()\n\t}\n}\n\n// rollbackInner handles the underlying rollback logic.\n// Intended to be called from Commit() and Rollback().\nfunc (tx *Tx) rollbackInner() {\n\t// rollback the deleteAll if needed\n\tif tx.wc.rbkeys != nil {\n\t\ttx.db.keys = tx.wc.rbkeys\n\t\ttx.db.idxs = tx.wc.rbidxs\n\t\ttx.db.exps = tx.wc.rbexps\n\t}\n\tfor key, item := range tx.wc.rollbackItems {\n\t\ttx.db.deleteFromDatabase(&dbItem{key: key})\n\t\tif item != nil {\n\t\t\t// When an item is not nil, we will need to reinsert that item\n\t\t\t// into the database overwriting the current one.\n\t\t\ttx.db.insertIntoDatabase(item)\n\t\t}\n\t}\n\tfor name, idx := range tx.wc.rollbackIndexes {\n\t\tdelete(tx.db.idxs, name)\n\t\tif idx != nil {\n\t\t\t// When an index is not nil, we will need to rebuilt that index\n\t\t\t// this could be an expensive process if the database has many\n\t\t\t// items or the index is complex.\n\t\t\ttx.db.idxs[name] = idx\n\t\t\tidx.rebuild()\n\t\t}\n\t}\n}\n\n// Commit writes all changes to disk.\n// An error is returned when a write error occurs, or when a Commit() is called\n// from a read-only transaction.\nfunc (tx *Tx) Commit() error {\n\tif tx.funcd {\n\t\tpanic(\"managed tx commit not allowed\")\n\t}\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn ErrTxNotWritable\n\t}\n\tvar err error\n\tif tx.db.persist && (len(tx.wc.commitItems) > 0 || tx.wc.rbkeys != nil) {\n\t\ttx.db.buf = tx.db.buf[:0]\n\t\t// write a flushdb if a deleteAll was called.\n\t\tif tx.wc.rbkeys != nil {\n\t\t\ttx.db.buf = append(tx.db.buf, \"*1\\r\\n$7\\r\\nflushdb\\r\\n\"...)\n\t\t}\n\t\tnow := time.Now()\n\t\t// Each committed record is written to disk\n\t\tfor key, item := range tx.wc.commitItems {\n\t\t\tif item == nil {\n\t\t\t\ttx.db.buf = (&dbItem{key: key}).writeDeleteTo(tx.db.buf)\n\t\t\t} else {\n\t\t\t\ttx.db.buf = item.writeSetTo(tx.db.buf, now)\n\t\t\t}\n\t\t}\n\t\t// Flushing the buffer only once per transaction.\n\t\t// If this operation fails then the write did failed and we must\n\t\t// rollback.\n\t\tvar n int\n\t\tn, err = tx.db.file.Write(tx.db.buf)\n\t\tif err != nil {\n\t\t\tif n > 0 {\n\t\t\t\t// There was a partial write to disk.\n\t\t\t\t// We are possibly out of disk space.\n\t\t\t\t// Delete the partially written bytes from the data file by\n\t\t\t\t// seeking to the previously known position and performing\n\t\t\t\t// a truncate operation.\n\t\t\t\t// At this point a syscall failure is fatal and the process\n\t\t\t\t// should be killed to avoid corrupting the file.\n\t\t\t\tpos, err := tx.db.file.Seek(-int64(n), 1)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanicErr(err)\n\t\t\t\t}\n\t\t\t\tif err := tx.db.file.Truncate(pos); err != nil {\n\t\t\t\t\tpanicErr(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\ttx.rollbackInner()\n\t\t}\n\t\tif tx.db.config.SyncPolicy == Always {\n\t\t\t_ = tx.db.file.Sync()\n\t\t}\n\t\t// Increment the number of flushes. The background syncing uses this.\n\t\ttx.db.flushes++\n\t}\n\t// Unlock the database and allow for another writable transaction.\n\ttx.unlock()\n\t// Clear the db field to disable this transaction from future use.\n\ttx.db = nil\n\treturn err\n}\n\n// Rollback closes the transaction and reverts all mutable operations that\n// were performed on the transaction such as Set() and Delete().\n//\n// Read-only transactions can only be rolled back, not committed.\nfunc (tx *Tx) Rollback() error {\n\tif tx.funcd {\n\t\tpanic(\"managed tx rollback not allowed\")\n\t}\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t}\n\t// The rollback func does the heavy lifting.\n\tif tx.writable {\n\t\ttx.rollbackInner()\n\t}\n\t// unlock the database for more transactions.\n\ttx.unlock()\n\t// Clear the db field to disable this transaction from future use.\n\ttx.db = nil\n\treturn nil\n}\n\n// dbItemOpts holds various meta information about an item.\ntype dbItemOpts struct {\n\tex   bool      // does this item expire?\n\texat time.Time // when does this item expire?\n}\ntype dbItem struct {\n\tkey, val string      // the binary key and value\n\topts     *dbItemOpts // optional meta information\n\tkeyless  bool        // keyless item for scanning\n}\n\n// estIntSize returns the string representions size.\n// Has the same result as len(strconv.Itoa(x)).\nfunc estIntSize(x int) int {\n\tn := 1\n\tif x < 0 {\n\t\tn++\n\t\tx *= -1\n\t}\n\tfor x >= 10 {\n\t\tn++\n\t\tx /= 10\n\t}\n\treturn n\n}\n\nfunc estArraySize(count int) int {\n\treturn 1 + estIntSize(count) + 2\n}\n\nfunc estBulkStringSize(s string) int {\n\treturn 1 + estIntSize(len(s)) + 2 + len(s) + 2\n}\n\n// estAOFSetSize returns an estimated number of bytes that this item will use\n// when stored in the aof file.\nfunc (dbi *dbItem) estAOFSetSize() int {\n\tvar n int\n\tif dbi.opts != nil && dbi.opts.ex {\n\t\tn += estArraySize(5)\n\t\tn += estBulkStringSize(\"set\")\n\t\tn += estBulkStringSize(dbi.key)\n\t\tn += estBulkStringSize(dbi.val)\n\t\tn += estBulkStringSize(\"ex\")\n\t\tn += estBulkStringSize(\"99\") // estimate two byte bulk string\n\t} else {\n\t\tn += estArraySize(3)\n\t\tn += estBulkStringSize(\"set\")\n\t\tn += estBulkStringSize(dbi.key)\n\t\tn += estBulkStringSize(dbi.val)\n\t}\n\treturn n\n}\n\nfunc appendArray(buf []byte, count int) []byte {\n\tbuf = append(buf, '*')\n\tbuf = strconv.AppendInt(buf, int64(count), 10)\n\tbuf = append(buf, '\\r', '\\n')\n\treturn buf\n}\n\nfunc appendBulkString(buf []byte, s string) []byte {\n\tbuf = append(buf, '$')\n\tbuf = strconv.AppendInt(buf, int64(len(s)), 10)\n\tbuf = append(buf, '\\r', '\\n')\n\tbuf = append(buf, s...)\n\tbuf = append(buf, '\\r', '\\n')\n\treturn buf\n}\n\n// writeSetTo writes an item as a single SET record to the a bufio Writer.\nfunc (dbi *dbItem) writeSetTo(buf []byte, now time.Time) []byte {\n\tif dbi.opts != nil && dbi.opts.ex {\n\t\tbuf = appendArray(buf, 5)\n\t\tbuf = appendBulkString(buf, \"set\")\n\t\tbuf = appendBulkString(buf, dbi.key)\n\t\tbuf = appendBulkString(buf, dbi.val)\n\t\tif useAbsEx {\n\t\t\tex := dbi.opts.exat.Unix()\n\t\t\tbuf = appendBulkString(buf, \"ae\")\n\t\t\tbuf = appendBulkString(buf, strconv.FormatUint(uint64(ex), 10))\n\t\t} else {\n\t\t\tex := dbi.opts.exat.Sub(now) / time.Second\n\t\t\tbuf = appendBulkString(buf, \"ex\")\n\t\t\tbuf = appendBulkString(buf, strconv.FormatUint(uint64(ex), 10))\n\t\t}\n\t} else {\n\t\tbuf = appendArray(buf, 3)\n\t\tbuf = appendBulkString(buf, \"set\")\n\t\tbuf = appendBulkString(buf, dbi.key)\n\t\tbuf = appendBulkString(buf, dbi.val)\n\t}\n\treturn buf\n}\n\n// writeSetTo writes an item as a single DEL record to the a bufio Writer.\nfunc (dbi *dbItem) writeDeleteTo(buf []byte) []byte {\n\tbuf = appendArray(buf, 2)\n\tbuf = appendBulkString(buf, \"del\")\n\tbuf = appendBulkString(buf, dbi.key)\n\treturn buf\n}\n\n// expired evaluates id the item has expired. This will always return false when\n// the item does not have `opts.ex` set to true.\nfunc (dbi *dbItem) expired() bool {\n\treturn dbi.opts != nil && dbi.opts.ex && time.Now().After(dbi.opts.exat)\n}\n\n// MaxTime from http://stackoverflow.com/questions/25065055#32620397\n// This is a long time in the future. It's an imaginary number that is\n// used for b-tree ordering.\nvar maxTime = time.Unix(1<<63-62135596801, 999999999)\n\n// expiresAt will return the time when the item will expire. When an item does\n// not expire `maxTime` is used.\nfunc (dbi *dbItem) expiresAt() time.Time {\n\tif dbi.opts == nil || !dbi.opts.ex {\n\t\treturn maxTime\n\t}\n\treturn dbi.opts.exat\n}\n\n// Less determines if a b-tree item is less than another. This is required\n// for ordering, inserting, and deleting items from a b-tree. It's important\n// to note that the ctx parameter is used to help with determine which\n// formula to use on an item. Each b-tree should use a different ctx when\n// sharing the same item.\nfunc (dbi *dbItem) Less(dbi2 *dbItem, ctx interface{}) bool {\n\tswitch ctx := ctx.(type) {\n\tcase *exctx:\n\t\t// The expires b-tree formula\n\t\tif dbi2.expiresAt().After(dbi.expiresAt()) {\n\t\t\treturn true\n\t\t}\n\t\tif dbi.expiresAt().After(dbi2.expiresAt()) {\n\t\t\treturn false\n\t\t}\n\tcase *index:\n\t\tif ctx.less != nil {\n\t\t\t// Using an index\n\t\t\tif ctx.less(dbi.val, dbi2.val) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif ctx.less(dbi2.val, dbi.val) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\t// Always fall back to the key comparison. This creates absolute uniqueness.\n\tif dbi.keyless {\n\t\treturn false\n\t} else if dbi2.keyless {\n\t\treturn true\n\t}\n\treturn dbi.key < dbi2.key\n}\n\nfunc lessCtx(ctx interface{}) func(a, b interface{}) bool {\n\treturn func(a, b interface{}) bool {\n\t\treturn a.(*dbItem).Less(b.(*dbItem), ctx)\n\t}\n}\n\n// Rect converts a string to a rectangle.\n// An invalid rectangle will cause a panic.\nfunc (dbi *dbItem) Rect(ctx interface{}) (min, max []float64) {\n\tswitch ctx := ctx.(type) {\n\tcase *index:\n\t\treturn ctx.rect(dbi.val)\n\t}\n\treturn nil, nil\n}\n\n// SetOptions represents options that may be included with the Set() command.\ntype SetOptions struct {\n\t// Expires indicates that the Set() key-value will expire\n\tExpires bool\n\t// TTL is how much time the key-value will exist in the database\n\t// before being evicted. The Expires field must also be set to true.\n\t// TTL stands for Time-To-Live.\n\tTTL time.Duration\n}\n\n// GetLess returns the less function for an index. This is handy for\n// doing ad-hoc compares inside a transaction.\n// Returns ErrNotFound if the index is not found or there is no less\n// function bound to the index\nfunc (tx *Tx) GetLess(index string) (func(a, b string) bool, error) {\n\tif tx.db == nil {\n\t\treturn nil, ErrTxClosed\n\t}\n\tidx, ok := tx.db.idxs[index]\n\tif !ok || idx.less == nil {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn idx.less, nil\n}\n\n// GetRect returns the rect function for an index. This is handy for\n// doing ad-hoc searches inside a transaction.\n// Returns ErrNotFound if the index is not found or there is no rect\n// function bound to the index\nfunc (tx *Tx) GetRect(index string) (func(s string) (min, max []float64),\n\terror) {\n\tif tx.db == nil {\n\t\treturn nil, ErrTxClosed\n\t}\n\tidx, ok := tx.db.idxs[index]\n\tif !ok || idx.rect == nil {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn idx.rect, nil\n}\n\n// Set inserts or replaces an item in the database based on the key.\n// The opt params may be used for additional functionality such as forcing\n// the item to be evicted at a specified time. When the return value\n// for err is nil the operation succeeded. When the return value of\n// replaced is true, then the operaton replaced an existing item whose\n// value will be returned through the previousValue variable.\n// The results of this operation will not be available to other\n// transactions until the current transaction has successfully committed.\n//\n// Only a writable transaction can be used with this operation.\n// This operation is not allowed during iterations such as Ascend* & Descend*.\nfunc (tx *Tx) Set(key, value string, opts *SetOptions) (previousValue string,\n\treplaced bool, err error) {\n\tif tx.db == nil {\n\t\treturn \"\", false, ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn \"\", false, ErrTxNotWritable\n\t} else if tx.wc.itercount > 0 {\n\t\treturn \"\", false, ErrTxIterating\n\t}\n\titem := &dbItem{key: key, val: value}\n\tif opts != nil {\n\t\tif opts.Expires {\n\t\t\t// The caller is requesting that this item expires. Convert the\n\t\t\t// TTL to an absolute time and bind it to the item.\n\t\t\titem.opts = &dbItemOpts{ex: true, exat: time.Now().Add(opts.TTL)}\n\t\t}\n\t}\n\t// Insert the item into the keys tree.\n\tprev := tx.db.insertIntoDatabase(item)\n\n\t// insert into the rollback map if there has not been a deleteAll.\n\tif tx.wc.rbkeys == nil {\n\t\tif prev == nil {\n\t\t\t// An item with the same key did not previously exist. Let's\n\t\t\t// create a rollback entry with a nil value. A nil value indicates\n\t\t\t// that the entry should be deleted on rollback. When the value is\n\t\t\t// *not* nil, that means the entry should be reverted.\n\t\t\tif _, ok := tx.wc.rollbackItems[key]; !ok {\n\t\t\t\ttx.wc.rollbackItems[key] = nil\n\t\t\t}\n\t\t} else {\n\t\t\t// A previous item already exists in the database. Let's create a\n\t\t\t// rollback entry with the item as the value. We need to check the\n\t\t\t// map to see if there isn't already an item that matches the\n\t\t\t// same key.\n\t\t\tif _, ok := tx.wc.rollbackItems[key]; !ok {\n\t\t\t\ttx.wc.rollbackItems[key] = prev\n\t\t\t}\n\t\t\tif !prev.expired() {\n\t\t\t\tpreviousValue, replaced = prev.val, true\n\t\t\t}\n\t\t}\n\t}\n\t// For commits we simply assign the item to the map. We use this map to\n\t// write the entry to disk.\n\tif tx.db.persist {\n\t\ttx.wc.commitItems[key] = item\n\t}\n\treturn previousValue, replaced, nil\n}\n\n// Get returns a value for a key. If the item does not exist or if the item\n// has expired then ErrNotFound is returned. If ignoreExpired is true, then\n// the found value will be returned even if it is expired.\nfunc (tx *Tx) Get(key string, ignoreExpired ...bool) (val string, err error) {\n\tif tx.db == nil {\n\t\treturn \"\", ErrTxClosed\n\t}\n\tvar ignore bool\n\tif len(ignoreExpired) != 0 {\n\t\tignore = ignoreExpired[0]\n\t}\n\titem := tx.db.get(key)\n\tif item == nil || (item.expired() && !ignore) {\n\t\t// The item does not exists or has expired. Let's assume that\n\t\t// the caller is only interested in items that have not expired.\n\t\treturn \"\", ErrNotFound\n\t}\n\treturn item.val, nil\n}\n\n// Delete removes an item from the database based on the item's key. If the item\n// does not exist or if the item has expired then ErrNotFound is returned.\n//\n// Only a writable transaction can be used for this operation.\n// This operation is not allowed during iterations such as Ascend* & Descend*.\nfunc (tx *Tx) Delete(key string) (val string, err error) {\n\tif tx.db == nil {\n\t\treturn \"\", ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn \"\", ErrTxNotWritable\n\t} else if tx.wc.itercount > 0 {\n\t\treturn \"\", ErrTxIterating\n\t}\n\titem := tx.db.deleteFromDatabase(&dbItem{key: key})\n\tif item == nil {\n\t\treturn \"\", ErrNotFound\n\t}\n\t// create a rollback entry if there has not been a deleteAll call.\n\tif tx.wc.rbkeys == nil {\n\t\tif _, ok := tx.wc.rollbackItems[key]; !ok {\n\t\t\ttx.wc.rollbackItems[key] = item\n\t\t}\n\t}\n\tif tx.db.persist {\n\t\ttx.wc.commitItems[key] = nil\n\t}\n\t// Even though the item has been deleted, we still want to check\n\t// if it has expired. An expired item should not be returned.\n\tif item.expired() {\n\t\t// The item exists in the tree, but has expired. Let's assume that\n\t\t// the caller is only interested in items that have not expired.\n\t\treturn \"\", ErrNotFound\n\t}\n\treturn item.val, nil\n}\n\n// TTL returns the remaining time-to-live for an item.\n// A negative duration will be returned for items that do not have an\n// expiration.\nfunc (tx *Tx) TTL(key string) (time.Duration, error) {\n\tif tx.db == nil {\n\t\treturn 0, ErrTxClosed\n\t}\n\titem := tx.db.get(key)\n\tif item == nil {\n\t\treturn 0, ErrNotFound\n\t} else if item.opts == nil || !item.opts.ex {\n\t\treturn -1, nil\n\t}\n\tdur := time.Until(item.opts.exat)\n\tif dur < 0 {\n\t\treturn 0, ErrNotFound\n\t}\n\treturn dur, nil\n}\n\n// scan iterates through a specified index and calls user-defined iterator\n// function for each item encountered.\n// The desc param indicates that the iterator should descend.\n// The gt param indicates that there is a greaterThan limit.\n// The lt param indicates that there is a lessThan limit.\n// The index param tells the scanner to use the specified index tree. An\n// empty string for the index means to scan the keys, not the values.\n// The start and stop params are the greaterThan, lessThan limits. For\n// descending order, these will be lessThan, greaterThan.\n// An error will be returned if the tx is closed or the index is not found.\nfunc (tx *Tx) scan(desc, gt, lt bool, index, start, stop string,\n\titerator func(key, value string) bool) error {\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t}\n\t// wrap a btree specific iterator around the user-defined iterator.\n\titer := func(item interface{}) bool {\n\t\tdbi := item.(*dbItem)\n\t\tif dbi.expired() {\n\t\t\treturn true\n\t\t}\n\t\treturn iterator(dbi.key, dbi.val)\n\t}\n\tvar tr *btree.BTree\n\tif index == \"\" {\n\t\t// empty index means we will use the keys tree.\n\t\ttr = tx.db.keys\n\t} else {\n\t\tidx := tx.db.idxs[index]\n\t\tif idx == nil {\n\t\t\t// index was not found. return error\n\t\t\treturn ErrNotFound\n\t\t}\n\t\ttr = idx.btr\n\t\tif tr == nil {\n\t\t\treturn nil\n\t\t}\n\t}\n\t// create some limit items\n\tvar itemA, itemB *dbItem\n\tif gt || lt {\n\t\tif index == \"\" {\n\t\t\titemA = &dbItem{key: start}\n\t\t\titemB = &dbItem{key: stop}\n\t\t} else {\n\t\t\titemA = &dbItem{val: start}\n\t\t\titemB = &dbItem{val: stop}\n\t\t\tif desc {\n\t\t\t\titemA.keyless = true\n\t\t\t\titemB.keyless = true\n\t\t\t}\n\t\t}\n\t}\n\t// execute the scan on the underlying tree.\n\tif tx.wc != nil {\n\t\ttx.wc.itercount++\n\t\tdefer func() {\n\t\t\ttx.wc.itercount--\n\t\t}()\n\t}\n\tif desc {\n\t\tif gt {\n\t\t\tif lt {\n\t\t\t\tbtreeDescendRange(tr, itemA, itemB, iter)\n\t\t\t} else {\n\t\t\t\tbtreeDescendGreaterThan(tr, itemA, iter)\n\t\t\t}\n\t\t} else if lt {\n\t\t\tbtreeDescendLessOrEqual(tr, itemA, iter)\n\t\t} else {\n\t\t\tbtreeDescend(tr, iter)\n\t\t}\n\t} else {\n\t\tif gt {\n\t\t\tif lt {\n\t\t\t\tbtreeAscendRange(tr, itemA, itemB, iter)\n\t\t\t} else {\n\t\t\t\tbtreeAscendGreaterOrEqual(tr, itemA, iter)\n\t\t\t}\n\t\t} else if lt {\n\t\t\tbtreeAscendLessThan(tr, itemA, iter)\n\t\t} else {\n\t\t\tbtreeAscend(tr, iter)\n\t\t}\n\t}\n\treturn nil\n}\n\n// Match returns true if the specified key matches the pattern. This is a very\n// simple pattern matcher where '*' matches on any number characters and '?'\n// matches on any one character.\nfunc Match(key, pattern string) bool {\n\treturn match.Match(key, pattern)\n}\n\n// AscendKeys allows for iterating through keys based on the specified pattern.\nfunc (tx *Tx) AscendKeys(pattern string,\n\titerator func(key, value string) bool) error {\n\tif pattern == \"\" {\n\t\treturn nil\n\t}\n\tif pattern[0] == '*' {\n\t\tif pattern == \"*\" {\n\t\t\treturn tx.Ascend(\"\", iterator)\n\t\t}\n\t\treturn tx.Ascend(\"\", func(key, value string) bool {\n\t\t\tif match.Match(key, pattern) {\n\t\t\t\tif !iterator(key, value) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t}\n\tmin, max := match.Allowable(pattern)\n\treturn tx.AscendGreaterOrEqual(\"\", min, func(key, value string) bool {\n\t\tif key > max {\n\t\t\treturn false\n\t\t}\n\t\tif match.Match(key, pattern) {\n\t\t\tif !iterator(key, value) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}\n\n// DescendKeys allows for iterating through keys based on the specified pattern.\nfunc (tx *Tx) DescendKeys(pattern string,\n\titerator func(key, value string) bool) error {\n\tif pattern == \"\" {\n\t\treturn nil\n\t}\n\tif pattern[0] == '*' {\n\t\tif pattern == \"*\" {\n\t\t\treturn tx.Descend(\"\", iterator)\n\t\t}\n\t\treturn tx.Descend(\"\", func(key, value string) bool {\n\t\t\tif match.Match(key, pattern) {\n\t\t\t\tif !iterator(key, value) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true\n\t\t})\n\t}\n\tmin, max := match.Allowable(pattern)\n\treturn tx.DescendLessOrEqual(\"\", max, func(key, value string) bool {\n\t\tif key < min {\n\t\t\treturn false\n\t\t}\n\t\tif match.Match(key, pattern) {\n\t\t\tif !iterator(key, value) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t})\n}\n\n// Ascend calls the iterator for every item in the database within the range\n// [first, last], until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) Ascend(index string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(false, false, false, index, \"\", \"\", iterator)\n}\n\n// AscendGreaterOrEqual calls the iterator for every item in the database within\n// the range [pivot, last], until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) AscendGreaterOrEqual(index, pivot string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(false, true, false, index, pivot, \"\", iterator)\n}\n\n// AscendLessThan calls the iterator for every item in the database within the\n// range [first, pivot), until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) AscendLessThan(index, pivot string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(false, false, true, index, pivot, \"\", iterator)\n}\n\n// AscendRange calls the iterator for every item in the database within\n// the range [greaterOrEqual, lessThan), until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) AscendRange(index, greaterOrEqual, lessThan string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(\n\t\tfalse, true, true, index, greaterOrEqual, lessThan, iterator,\n\t)\n}\n\n// Descend calls the iterator for every item in the database within the range\n// [last, first], until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) Descend(index string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(true, false, false, index, \"\", \"\", iterator)\n}\n\n// DescendGreaterThan calls the iterator for every item in the database within\n// the range [last, pivot), until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) DescendGreaterThan(index, pivot string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(true, true, false, index, pivot, \"\", iterator)\n}\n\n// DescendLessOrEqual calls the iterator for every item in the database within\n// the range [pivot, first], until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) DescendLessOrEqual(index, pivot string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(true, false, true, index, pivot, \"\", iterator)\n}\n\n// DescendRange calls the iterator for every item in the database within\n// the range [lessOrEqual, greaterThan), until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) DescendRange(index, lessOrEqual, greaterThan string,\n\titerator func(key, value string) bool) error {\n\treturn tx.scan(\n\t\ttrue, true, true, index, lessOrEqual, greaterThan, iterator,\n\t)\n}\n\n// AscendEqual calls the iterator for every item in the database that equals\n// pivot, until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) AscendEqual(index, pivot string,\n\titerator func(key, value string) bool) error {\n\tvar err error\n\tvar less func(a, b string) bool\n\tif index != \"\" {\n\t\tless, err = tx.GetLess(index)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn tx.AscendGreaterOrEqual(index, pivot, func(key, value string) bool {\n\t\tif less == nil {\n\t\t\tif key != pivot {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if less(pivot, value) {\n\t\t\treturn false\n\t\t}\n\t\treturn iterator(key, value)\n\t})\n}\n\n// DescendEqual calls the iterator for every item in the database that equals\n// pivot, until iterator returns false.\n// When an index is provided, the results will be ordered by the item values\n// as specified by the less() function of the defined index.\n// When an index is not provided, the results will be ordered by the item key.\n// An invalid index will return an error.\nfunc (tx *Tx) DescendEqual(index, pivot string,\n\titerator func(key, value string) bool) error {\n\tvar err error\n\tvar less func(a, b string) bool\n\tif index != \"\" {\n\t\tless, err = tx.GetLess(index)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn tx.DescendLessOrEqual(index, pivot, func(key, value string) bool {\n\t\tif less == nil {\n\t\t\tif key != pivot {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else if less(value, pivot) {\n\t\t\treturn false\n\t\t}\n\t\treturn iterator(key, value)\n\t})\n}\n\n// rect is used by Intersects and Nearby\ntype rect struct {\n\tmin, max []float64\n}\n\nfunc (r *rect) Rect(ctx interface{}) (min, max []float64) {\n\treturn r.min, r.max\n}\n\n// Nearby searches for rectangle items that are nearby a target rect.\n// All items belonging to the specified index will be returned in order of\n// nearest to farthest.\n// The specified index must have been created by AddIndex() and the target\n// is represented by the rect string. This string will be processed by the\n// same bounds function that was passed to the CreateSpatialIndex() function.\n// An invalid index will return an error.\n// The dist param is the distance of the bounding boxes. In the case of\n// simple 2D points, it's the distance of the two 2D points squared.\nfunc (tx *Tx) Nearby(index, bounds string,\n\titerator func(key, value string, dist float64) bool) error {\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t}\n\tif index == \"\" {\n\t\t// cannot search on keys tree. just return nil.\n\t\treturn nil\n\t}\n\t// // wrap a rtree specific iterator around the user-defined iterator.\n\titer := func(item rtred.Item, dist float64) bool {\n\t\tdbi := item.(*dbItem)\n\t\treturn iterator(dbi.key, dbi.val, dist)\n\t}\n\tidx := tx.db.idxs[index]\n\tif idx == nil {\n\t\t// index was not found. return error\n\t\treturn ErrNotFound\n\t}\n\tif idx.rtr == nil {\n\t\t// not an r-tree index. just return nil\n\t\treturn nil\n\t}\n\t// execute the nearby search\n\tvar min, max []float64\n\tif idx.rect != nil {\n\t\tmin, max = idx.rect(bounds)\n\t}\n\t// set the center param to false, which uses the box dist calc.\n\tidx.rtr.KNN(&rect{min, max}, false, iter)\n\treturn nil\n}\n\n// Intersects searches for rectangle items that intersect a target rect.\n// The specified index must have been created by AddIndex() and the target\n// is represented by the rect string. This string will be processed by the\n// same bounds function that was passed to the CreateSpatialIndex() function.\n// An invalid index will return an error.\nfunc (tx *Tx) Intersects(index, bounds string,\n\titerator func(key, value string) bool) error {\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t}\n\tif index == \"\" {\n\t\t// cannot search on keys tree. just return nil.\n\t\treturn nil\n\t}\n\t// wrap a rtree specific iterator around the user-defined iterator.\n\titer := func(item rtred.Item) bool {\n\t\tdbi := item.(*dbItem)\n\t\treturn iterator(dbi.key, dbi.val)\n\t}\n\tidx := tx.db.idxs[index]\n\tif idx == nil {\n\t\t// index was not found. return error\n\t\treturn ErrNotFound\n\t}\n\tif idx.rtr == nil {\n\t\t// not an r-tree index. just return nil\n\t\treturn nil\n\t}\n\t// execute the search\n\tvar min, max []float64\n\tif idx.rect != nil {\n\t\tmin, max = idx.rect(bounds)\n\t}\n\tidx.rtr.Search(&rect{min, max}, iter)\n\treturn nil\n}\n\n// Len returns the number of items in the database\nfunc (tx *Tx) Len() (int, error) {\n\tif tx.db == nil {\n\t\treturn 0, ErrTxClosed\n\t}\n\treturn tx.db.keys.Len(), nil\n}\n\n// IndexOptions provides an index with additional features or\n// alternate functionality.\ntype IndexOptions struct {\n\t// CaseInsensitiveKeyMatching allow for case-insensitive\n\t// matching on keys when setting key/values.\n\tCaseInsensitiveKeyMatching bool\n}\n\n// CreateIndex builds a new index and populates it with items.\n// The items are ordered in an b-tree and can be retrieved using the\n// Ascend* and Descend* methods.\n// An error will occur if an index with the same name already exists.\n//\n// When a pattern is provided, the index will be populated with\n// keys that match the specified pattern. This is a very simple pattern\n// match where '*' matches on any number characters and '?' matches on\n// any one character.\n// The less function compares if string 'a' is less than string 'b'.\n// It allows for indexes to create custom ordering. It's possible\n// that the strings may be textual or binary. It's up to the provided\n// less function to handle the content format and comparison.\n// There are some default less function that can be used such as\n// IndexString, IndexBinary, etc.\nfunc (tx *Tx) CreateIndex(name, pattern string,\n\tless ...func(a, b string) bool) error {\n\treturn tx.createIndex(name, pattern, less, nil, nil)\n}\n\n// CreateIndexOptions is the same as CreateIndex except that it allows\n// for additional options.\nfunc (tx *Tx) CreateIndexOptions(name, pattern string,\n\topts *IndexOptions,\n\tless ...func(a, b string) bool) error {\n\treturn tx.createIndex(name, pattern, less, nil, opts)\n}\n\n// CreateSpatialIndex builds a new index and populates it with items.\n// The items are organized in an r-tree and can be retrieved using the\n// Intersects method.\n// An error will occur if an index with the same name already exists.\n//\n// The rect function converts a string to a rectangle. The rectangle is\n// represented by two arrays, min and max. Both arrays may have a length\n// between 1 and 20, and both arrays must match in length. A length of 1 is a\n// one dimensional rectangle, and a length of 4 is a four dimension rectangle.\n// There is support for up to 20 dimensions.\n// The values of min must be less than the values of max at the same dimension.\n// Thus min[0] must be less-than-or-equal-to max[0].\n// The IndexRect is a default function that can be used for the rect\n// parameter.\nfunc (tx *Tx) CreateSpatialIndex(name, pattern string,\n\trect func(item string) (min, max []float64)) error {\n\treturn tx.createIndex(name, pattern, nil, rect, nil)\n}\n\n// CreateSpatialIndexOptions is the same as CreateSpatialIndex except that\n// it allows for additional options.\nfunc (tx *Tx) CreateSpatialIndexOptions(name, pattern string,\n\topts *IndexOptions,\n\trect func(item string) (min, max []float64)) error {\n\treturn tx.createIndex(name, pattern, nil, rect, nil)\n}\n\n// createIndex is called by CreateIndex() and CreateSpatialIndex()\nfunc (tx *Tx) createIndex(name string, pattern string,\n\tlessers []func(a, b string) bool,\n\trect func(item string) (min, max []float64),\n\topts *IndexOptions,\n) error {\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn ErrTxNotWritable\n\t} else if tx.wc.itercount > 0 {\n\t\treturn ErrTxIterating\n\t}\n\tif name == \"\" {\n\t\t// cannot create an index without a name.\n\t\t// an empty name index is designated for the main \"keys\" tree.\n\t\treturn ErrIndexExists\n\t}\n\t// check if an index with that name already exists.\n\tif _, ok := tx.db.idxs[name]; ok {\n\t\t// index with name already exists. error.\n\t\treturn ErrIndexExists\n\t}\n\t// genreate a less function\n\tvar less func(a, b string) bool\n\tswitch len(lessers) {\n\tdefault:\n\t\t// multiple less functions specified.\n\t\t// create a compound less function.\n\t\tless = func(a, b string) bool {\n\t\t\tfor i := 0; i < len(lessers)-1; i++ {\n\t\t\t\tif lessers[i](a, b) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif lessers[i](b, a) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn lessers[len(lessers)-1](a, b)\n\t\t}\n\tcase 0:\n\t\t// no less function\n\tcase 1:\n\t\tless = lessers[0]\n\t}\n\tvar sopts IndexOptions\n\tif opts != nil {\n\t\tsopts = *opts\n\t}\n\tif sopts.CaseInsensitiveKeyMatching {\n\t\tpattern = strings.ToLower(pattern)\n\t}\n\t// intialize new index\n\tidx := &index{\n\t\tname:    name,\n\t\tpattern: pattern,\n\t\tless:    less,\n\t\trect:    rect,\n\t\tdb:      tx.db,\n\t\topts:    sopts,\n\t}\n\tidx.rebuild()\n\t// save the index\n\ttx.db.idxs[name] = idx\n\tif tx.wc.rbkeys == nil {\n\t\t// store the index in the rollback map.\n\t\tif _, ok := tx.wc.rollbackIndexes[name]; !ok {\n\t\t\t// we use nil to indicate that the index should be removed upon\n\t\t\t// rollback.\n\t\t\ttx.wc.rollbackIndexes[name] = nil\n\t\t}\n\t}\n\treturn nil\n}\n\n// DropIndex removes an index.\nfunc (tx *Tx) DropIndex(name string) error {\n\tif tx.db == nil {\n\t\treturn ErrTxClosed\n\t} else if !tx.writable {\n\t\treturn ErrTxNotWritable\n\t} else if tx.wc.itercount > 0 {\n\t\treturn ErrTxIterating\n\t}\n\tif name == \"\" {\n\t\t// cannot drop the default \"keys\" index\n\t\treturn ErrInvalidOperation\n\t}\n\tidx, ok := tx.db.idxs[name]\n\tif !ok {\n\t\treturn ErrNotFound\n\t}\n\t// delete from the map.\n\t// this is all that is needed to delete an index.\n\tdelete(tx.db.idxs, name)\n\tif tx.wc.rbkeys == nil {\n\t\t// store the index in the rollback map.\n\t\tif _, ok := tx.wc.rollbackIndexes[name]; !ok {\n\t\t\t// we use a non-nil copy of the index without the data to indicate\n\t\t\t// that the index should be rebuilt upon rollback.\n\t\t\ttx.wc.rollbackIndexes[name] = idx.clearCopy()\n\t\t}\n\t}\n\treturn nil\n}\n\n// Indexes returns a list of index names.\nfunc (tx *Tx) Indexes() ([]string, error) {\n\tif tx.db == nil {\n\t\treturn nil, ErrTxClosed\n\t}\n\tnames := make([]string, 0, len(tx.db.idxs))\n\tfor name := range tx.db.idxs {\n\t\tnames = append(names, name)\n\t}\n\tsort.Strings(names)\n\treturn names, nil\n}\n\n// Rect is helper function that returns a string representation\n// of a rect. IndexRect() is the reverse function and can be used\n// to generate a rect from a string.\nfunc Rect(min, max []float64) string {\n\tr := grect.Rect{Min: min, Max: max}\n\treturn r.String()\n}\n\n// Point is a helper function that converts a series of float64s\n// to a rectangle for a spatial index.\nfunc Point(coords ...float64) string {\n\treturn Rect(coords, coords)\n}\n\n// IndexRect is a helper function that converts string to a rect.\n// Rect() is the reverse function and can be used to generate a string\n// from a rect.\nfunc IndexRect(a string) (min, max []float64) {\n\tr := grect.Get(a)\n\treturn r.Min, r.Max\n}\n\n// IndexString is a helper function that return true if 'a' is less than 'b'.\n// This is a case-insensitive comparison. Use the IndexBinary() for comparing\n// case-sensitive strings.\nfunc IndexString(a, b string) bool {\n\tfor i := 0; i < len(a) && i < len(b); i++ {\n\t\tif a[i] >= 'A' && a[i] <= 'Z' {\n\t\t\tif b[i] >= 'A' && b[i] <= 'Z' {\n\t\t\t\t// both are uppercase, do nothing\n\t\t\t\tif a[i] < b[i] {\n\t\t\t\t\treturn true\n\t\t\t\t} else if a[i] > b[i] {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// a is uppercase, convert a to lowercase\n\t\t\t\tif a[i]+32 < b[i] {\n\t\t\t\t\treturn true\n\t\t\t\t} else if a[i]+32 > b[i] {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t} else if b[i] >= 'A' && b[i] <= 'Z' {\n\t\t\t// b is uppercase, convert b to lowercase\n\t\t\tif a[i] < b[i]+32 {\n\t\t\t\treturn true\n\t\t\t} else if a[i] > b[i]+32 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t} else {\n\t\t\t// neither are uppercase\n\t\t\tif a[i] < b[i] {\n\t\t\t\treturn true\n\t\t\t} else if a[i] > b[i] {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn len(a) < len(b)\n}\n\n// IndexBinary is a helper function that returns true if 'a' is less than 'b'.\n// This compares the raw binary of the string.\nfunc IndexBinary(a, b string) bool {\n\treturn a < b\n}\n\n// IndexInt is a helper function that returns true if 'a' is less than 'b'.\nfunc IndexInt(a, b string) bool {\n\tia, _ := strconv.ParseInt(a, 10, 64)\n\tib, _ := strconv.ParseInt(b, 10, 64)\n\treturn ia < ib\n}\n\n// IndexUint is a helper function that returns true if 'a' is less than 'b'.\n// This compares uint64s that are added to the database using the\n// Uint() conversion function.\nfunc IndexUint(a, b string) bool {\n\tia, _ := strconv.ParseUint(a, 10, 64)\n\tib, _ := strconv.ParseUint(b, 10, 64)\n\treturn ia < ib\n}\n\n// IndexFloat is a helper function that returns true if 'a' is less than 'b'.\n// This compares float64s that are added to the database using the\n// Float() conversion function.\nfunc IndexFloat(a, b string) bool {\n\tia, _ := strconv.ParseFloat(a, 64)\n\tib, _ := strconv.ParseFloat(b, 64)\n\treturn ia < ib\n}\n\n// IndexJSON provides for the ability to create an index on any JSON field.\n// When the field is a string, the comparison will be case-insensitive.\n// It returns a helper function used by CreateIndex.\nfunc IndexJSON(path string) func(a, b string) bool {\n\treturn func(a, b string) bool {\n\t\treturn gjson.Get(a, path).Less(gjson.Get(b, path), false)\n\t}\n}\n\n// IndexJSONCaseSensitive provides for the ability to create an index on\n// any JSON field.\n// When the field is a string, the comparison will be case-sensitive.\n// It returns a helper function used by CreateIndex.\nfunc IndexJSONCaseSensitive(path string) func(a, b string) bool {\n\treturn func(a, b string) bool {\n\t\treturn gjson.Get(a, path).Less(gjson.Get(b, path), true)\n\t}\n}\n\n// Desc is a helper function that changes the order of an index.\nfunc Desc(less func(a, b string) bool) func(a, b string) bool {\n\treturn func(a, b string) bool { return less(b, a) }\n}\n\n//// Wrappers around btree Ascend/Descend\n\nfunc bLT(tr *btree.BTree, a, b interface{}) bool { return tr.Less(a, b) }\nfunc bGT(tr *btree.BTree, a, b interface{}) bool { return tr.Less(b, a) }\n\n// func bLTE(tr *btree.BTree, a, b interface{}) bool { return !tr.Less(b, a) }\n// func bGTE(tr *btree.BTree, a, b interface{}) bool { return !tr.Less(a, b) }\n\n// Ascend\n\nfunc btreeAscend(tr *btree.BTree, iter func(item interface{}) bool) {\n\ttr.Ascend(nil, iter)\n}\n\nfunc btreeAscendLessThan(tr *btree.BTree, pivot interface{},\n\titer func(item interface{}) bool,\n) {\n\ttr.Ascend(nil, func(item interface{}) bool {\n\t\treturn bLT(tr, item, pivot) && iter(item)\n\t})\n}\n\nfunc btreeAscendGreaterOrEqual(tr *btree.BTree, pivot interface{},\n\titer func(item interface{}) bool,\n) {\n\ttr.Ascend(pivot, iter)\n}\n\nfunc btreeAscendRange(tr *btree.BTree, greaterOrEqual, lessThan interface{},\n\titer func(item interface{}) bool,\n) {\n\ttr.Ascend(greaterOrEqual, func(item interface{}) bool {\n\t\treturn bLT(tr, item, lessThan) && iter(item)\n\t})\n}\n\n// Descend\n\nfunc btreeDescend(tr *btree.BTree, iter func(item interface{}) bool) {\n\ttr.Descend(nil, iter)\n}\n\nfunc btreeDescendGreaterThan(tr *btree.BTree, pivot interface{},\n\titer func(item interface{}) bool,\n) {\n\ttr.Descend(nil, func(item interface{}) bool {\n\t\treturn bGT(tr, item, pivot) && iter(item)\n\t})\n}\n\nfunc btreeDescendRange(tr *btree.BTree, lessOrEqual, greaterThan interface{},\n\titer func(item interface{}) bool,\n) {\n\ttr.Descend(lessOrEqual, func(item interface{}) bool {\n\t\treturn bGT(tr, item, greaterThan) && iter(item)\n\t})\n}\n\nfunc btreeDescendLessOrEqual(tr *btree.BTree, pivot interface{},\n\titer func(item interface{}) bool,\n) {\n\ttr.Descend(pivot, iter)\n}\n\nfunc btreeNew(less func(a, b interface{}) bool) *btree.BTree {\n\t// Using NewNonConcurrent because we're managing our own locks.\n\treturn btree.NewNonConcurrent(less)\n}\n"
        },
        {
          "name": "buntdb_test.go",
          "type": "blob",
          "size": 69.8349609375,
          "content": "package buntdb\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"math/rand\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/tidwall/assert\"\n\t\"github.com/tidwall/lotsa\"\n)\n\nfunc testOpen(t testing.TB) *DB {\n\tif err := os.RemoveAll(\"data.db\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn testReOpen(t, nil)\n}\nfunc testReOpen(t testing.TB, db *DB) *DB {\n\treturn testReOpenDelay(t, db, 0)\n}\n\nfunc testReOpenDelay(t testing.TB, db *DB, dur time.Duration) *DB {\n\tif db != nil {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\ttime.Sleep(dur)\n\tdb, err := Open(\"data.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\treturn db\n}\n\nfunc testClose(db *DB) {\n\t_ = db.Close()\n\t_ = os.RemoveAll(\"data.db\")\n}\n\nfunc TestBackgroundOperations(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tfor i := 0; i < 1000; i++ {\n\t\tif err := db.Update(func(tx *Tx) error {\n\t\t\tfor j := 0; j < 200; j++ {\n\t\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"hello%d\", j), \"planet\", nil); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"hi\", \"world\", &SetOptions{Expires: true, TTL: time.Second / 2}); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tn := 0\n\terr := db.View(func(tx *Tx) error {\n\t\tvar err error\n\t\tn, err = tx.Len()\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif n != 201 {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", 201, n)\n\t}\n\ttime.Sleep(time.Millisecond * 1500)\n\tdb = testReOpen(t, db)\n\tdefer testClose(db)\n\tn = 0\n\terr = db.View(func(tx *Tx) error {\n\t\tvar err error\n\t\tn, err = tx.Len()\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif n != 200 {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", 200, n)\n\t}\n}\nfunc TestSaveLoad(t *testing.T) {\n\tdb, _ := Open(\":memory:\")\n\tdefer db.Close()\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 20; i++ {\n\t\t\t_, _, err := tx.Set(fmt.Sprintf(\"key:%d\", i), fmt.Sprintf(\"planet:%d\", i), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tf, err := os.Create(\"temp.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() {\n\t\tf.Close()\n\t\tos.RemoveAll(\"temp.db\")\n\t}()\n\tif err := db.Save(f); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := f.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.Close()\n\tdb, _ = Open(\":memory:\")\n\tdefer db.Close()\n\tf, err = os.Open(\"temp.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tif err := db.Load(f); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.View(func(tx *Tx) error {\n\t\tfor i := 0; i < 20; i++ {\n\t\t\tex := fmt.Sprintf(\"planet:%d\", i)\n\t\t\tval, err := tx.Get(fmt.Sprintf(\"key:%d\", i))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif ex != val {\n\t\t\t\tt.Fatalf(\"expected %s, got %s\", ex, val)\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestMutatingIterator(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tcount := 1000\n\tif err := db.CreateIndex(\"ages\", \"user:*:age\", IndexInt); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tif err := db.Update(func(tx *Tx) error {\n\t\t\tfor j := 0; j < count; j++ {\n\t\t\t\tkey := fmt.Sprintf(\"user:%d:age\", j)\n\t\t\t\tval := fmt.Sprintf(\"%d\", rand.Intn(100))\n\t\t\t\tif _, _, err := tx.Set(key, val, nil); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\n\t\tif err := db.Update(func(tx *Tx) error {\n\t\t\treturn tx.Ascend(\"ages\", func(key, val string) bool {\n\t\t\t\t_, err := tx.Delete(key)\n\t\t\t\tif err != ErrTxIterating {\n\t\t\t\t\tt.Fatal(\"should not be able to call Delete while iterating.\")\n\t\t\t\t}\n\t\t\t\t_, _, err = tx.Set(key, \"\", nil)\n\t\t\t\tif err != ErrTxIterating {\n\t\t\t\t\tt.Fatal(\"should not be able to call Set while iterating.\")\n\t\t\t\t}\n\t\t\t\treturn true\n\t\t\t})\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc TestCaseInsensitiveIndex(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tcount := 1000\n\tif err := db.Update(func(tx *Tx) error {\n\t\topts := &IndexOptions{\n\t\t\tCaseInsensitiveKeyMatching: true,\n\t\t}\n\t\treturn tx.CreateIndexOptions(\"ages\", \"User:*:age\", opts, IndexInt)\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor j := 0; j < count; j++ {\n\t\t\tkey := fmt.Sprintf(\"user:%d:age\", j)\n\t\t\tval := fmt.Sprintf(\"%d\", rand.Intn(100))\n\t\t\tif _, _, err := tx.Set(key, val, nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.View(func(tx *Tx) error {\n\t\tvar vals []string\n\t\terr := tx.Ascend(\"ages\", func(key, value string) bool {\n\t\t\tvals = append(vals, value)\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(vals) != count {\n\t\t\treturn fmt.Errorf(\"expected '%v', got '%v'\", count, len(vals))\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n}\n\nfunc TestIndexTransaction(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tvar errFine = errors.New(\"this is fine\")\n\tascend := func(tx *Tx, index string) ([]string, error) {\n\t\tvar vals []string\n\t\tif err := tx.Ascend(index, func(key, val string) bool {\n\t\t\tvals = append(vals, key, val)\n\t\t\treturn true\n\t\t}); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn vals, nil\n\t}\n\tascendEqual := func(tx *Tx, index string, vals []string) error {\n\t\tvals2, err := ascend(tx, index)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(vals) != len(vals2) {\n\t\t\treturn errors.New(\"invalid size match\")\n\t\t}\n\t\tfor i := 0; i < len(vals); i++ {\n\t\t\tif vals[i] != vals2[i] {\n\t\t\t\treturn errors.New(\"invalid order\")\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}\n\t// test creating an index and adding items\n\tif err := db.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", \"3\", nil)\n\t\ttx.Set(\"2\", \"2\", nil)\n\t\ttx.Set(\"3\", \"1\", nil)\n\t\tif err := tx.CreateIndex(\"idx1\", \"*\", IndexInt); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test to see if the items persisted from previous transaction\n\t// test add item.\n\t// test force rollback.\n\tif err := db.Update(func(tx *Tx) error {\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ttx.Set(\"4\", \"0\", nil)\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"4\", \"0\", \"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn errFine\n\t}); err != errFine {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errFine, err)\n\t}\n\n\t// test to see if the rollback happened\n\tif err := db.View(func(tx *Tx) error {\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", nil, err)\n\t}\n\n\t// del item, drop index, rollback\n\tif err := db.Update(func(tx *Tx) error {\n\t\tif err := tx.DropIndex(\"idx1\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn errFine\n\t}); err != errFine {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errFine, err)\n\t}\n\n\t// test to see if the rollback happened\n\tif err := db.View(func(tx *Tx) error {\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", nil, err)\n\t}\n\n\tvarious := func(reterr error) error {\n\t\t// del item 3, add index 2, add item 4, test index 1 and 2.\n\t\t// flushdb, test index 1 and 2.\n\t\t// add item 1 and 2, add index 2 and 3, test index 2 and 3\n\t\treturn db.Update(func(tx *Tx) error {\n\t\t\ttx.Delete(\"3\")\n\t\t\ttx.CreateIndex(\"idx2\", \"*\", IndexInt)\n\t\t\ttx.Set(\"4\", \"0\", nil)\n\t\t\tif err := ascendEqual(tx, \"idx1\", []string{\"4\", \"0\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t\t}\n\t\t\tif err := ascendEqual(tx, \"idx2\", []string{\"4\", \"0\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t\t}\n\t\t\ttx.DeleteAll()\n\t\t\tif err := ascendEqual(tx, \"idx1\", []string{}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t\t}\n\t\t\tif err := ascendEqual(tx, \"idx2\", []string{}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t\t}\n\t\t\ttx.Set(\"1\", \"3\", nil)\n\t\t\ttx.Set(\"2\", \"2\", nil)\n\t\t\ttx.CreateIndex(\"idx1\", \"*\", IndexInt)\n\t\t\ttx.CreateIndex(\"idx2\", \"*\", IndexInt)\n\t\t\tif err := ascendEqual(tx, \"idx1\", []string{\"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t\t}\n\t\t\tif err := ascendEqual(tx, \"idx2\", []string{\"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t\t}\n\t\t\treturn reterr\n\t\t})\n\t}\n\t// various rollback\n\tif err := various(errFine); err != errFine {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", errFine, err)\n\t}\n\t// test to see if the rollback happened\n\tif err := db.View(func(tx *Tx) error {\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t}\n\t\tif err := ascendEqual(tx, \"idx2\", []string{\"3\", \"1\", \"2\", \"2\", \"1\", \"3\"}); err != ErrNotFound {\n\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", nil, err)\n\t}\n\n\t// various commit\n\tif err := various(nil); err != nil {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", nil, err)\n\t}\n\n\t// test to see if the commit happened\n\tif err := db.View(func(tx *Tx) error {\n\t\tif err := ascendEqual(tx, \"idx1\", []string{\"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t}\n\t\tif err := ascendEqual(tx, \"idx2\", []string{\"2\", \"2\", \"1\", \"3\"}); err != nil {\n\t\t\treturn fmt.Errorf(\"err: %v\", err)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", nil, err)\n\t}\n}\n\nfunc TestDeleteAll(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"hello1\", \"planet1\", nil)\n\t\ttx.Set(\"hello2\", \"planet2\", nil)\n\t\ttx.Set(\"hello3\", \"planet3\", nil)\n\t\treturn nil\n\t})\n\tdb.CreateIndex(\"all\", \"*\", IndexString)\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"hello1\", \"planet1.1\", nil)\n\t\ttx.DeleteAll()\n\t\ttx.Set(\"bb\", \"11\", nil)\n\t\ttx.Set(\"aa\", \"**\", nil)\n\t\ttx.Delete(\"aa\")\n\t\ttx.Set(\"aa\", \"22\", nil)\n\t\treturn nil\n\t})\n\tvar res string\n\tvar res2 string\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"\", func(key, val string) bool {\n\t\t\tres += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\ttx.Ascend(\"all\", func(key, val string) bool {\n\t\t\tres2 += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\tif res != \"aa:22\\nbb:11\\n\" {\n\t\tt.Fatal(\"fail\")\n\t}\n\tif res2 != \"bb:11\\naa:22\\n\" {\n\t\tt.Fatal(\"fail\")\n\t}\n\tdb = testReOpen(t, db)\n\tdefer testClose(db)\n\tres = \"\"\n\tres2 = \"\"\n\tdb.CreateIndex(\"all\", \"*\", IndexString)\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"\", func(key, val string) bool {\n\t\t\tres += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\ttx.Ascend(\"all\", func(key, val string) bool {\n\t\t\tres2 += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\tif res != \"aa:22\\nbb:11\\n\" {\n\t\tt.Fatal(\"fail\")\n\t}\n\tif res2 != \"bb:11\\naa:22\\n\" {\n\t\tt.Fatal(\"fail\")\n\t}\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", \"1\", nil)\n\t\ttx.Set(\"2\", \"2\", nil)\n\t\ttx.Set(\"3\", \"3\", nil)\n\t\ttx.Set(\"4\", \"4\", nil)\n\t\treturn nil\n\t})\n\terr := db.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", \"a\", nil)\n\t\ttx.Set(\"5\", \"5\", nil)\n\t\ttx.Delete(\"2\")\n\t\ttx.Set(\"6\", \"6\", nil)\n\t\ttx.DeleteAll()\n\t\ttx.Set(\"7\", \"7\", nil)\n\t\ttx.Set(\"8\", \"8\", nil)\n\t\ttx.Set(\"6\", \"c\", nil)\n\t\treturn errors.New(\"please rollback\")\n\t})\n\tif err == nil || err.Error() != \"please rollback\" {\n\t\tt.Fatal(\"expecteding 'please rollback' error\")\n\t}\n\n\tres = \"\"\n\tres2 = \"\"\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"\", func(key, val string) bool {\n\t\t\tres += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\ttx.Ascend(\"all\", func(key, val string) bool {\n\t\t\tres2 += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\tif res != \"1:1\\n2:2\\n3:3\\n4:4\\naa:22\\nbb:11\\n\" {\n\t\tt.Fatal(\"fail\")\n\t}\n\tif res2 != \"1:1\\nbb:11\\n2:2\\naa:22\\n3:3\\n4:4\\n\" {\n\t\tt.Fatal(\"fail\")\n\t}\n}\n\nfunc TestAscendEqual(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 300; i++ {\n\t\t\t_, _, err := tx.Set(fmt.Sprintf(\"key:%05dA\", i), fmt.Sprintf(\"%d\", i+1000), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, _, err = tx.Set(fmt.Sprintf(\"key:%05dB\", i), fmt.Sprintf(\"%d\", i+1000), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn tx.CreateIndex(\"num\", \"*\", IndexInt)\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar res []string\n\tif err := db.View(func(tx *Tx) error {\n\t\treturn tx.AscendEqual(\"\", \"key:00055A\", func(key, value string) bool {\n\t\t\tres = append(res, key)\n\t\t\treturn true\n\t\t})\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(res) != 1 {\n\t\tt.Fatalf(\"expected %v, got %v\", 1, len(res))\n\t}\n\tif res[0] != \"key:00055A\" {\n\t\tt.Fatalf(\"expected %v, got %v\", \"key:00055A\", res[0])\n\t}\n\tres = nil\n\tif err := db.View(func(tx *Tx) error {\n\t\treturn tx.AscendEqual(\"num\", \"1125\", func(key, value string) bool {\n\t\t\tres = append(res, key)\n\t\t\treturn true\n\t\t})\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(res) != 2 {\n\t\tt.Fatalf(\"expected %v, got %v\", 2, len(res))\n\t}\n\tif res[0] != \"key:00125A\" {\n\t\tt.Fatalf(\"expected %v, got %v\", \"key:00125A\", res[0])\n\t}\n\tif res[1] != \"key:00125B\" {\n\t\tt.Fatalf(\"expected %v, got %v\", \"key:00125B\", res[1])\n\t}\n}\nfunc TestDescendEqual(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 300; i++ {\n\t\t\t_, _, err := tx.Set(fmt.Sprintf(\"key:%05dA\", i), fmt.Sprintf(\"%d\", i+1000), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\t_, _, err = tx.Set(fmt.Sprintf(\"key:%05dB\", i), fmt.Sprintf(\"%d\", i+1000), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn tx.CreateIndex(\"num\", \"*\", IndexInt)\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar res []string\n\tif err := db.View(func(tx *Tx) error {\n\t\treturn tx.DescendEqual(\"\", \"key:00055A\", func(key, value string) bool {\n\t\t\tres = append(res, key)\n\t\t\treturn true\n\t\t})\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(res) != 1 {\n\t\tt.Fatalf(\"expected %v, got %v\", 1, len(res))\n\t}\n\tif res[0] != \"key:00055A\" {\n\t\tt.Fatalf(\"expected %v, got %v\", \"key:00055A\", res[0])\n\t}\n\tres = nil\n\tif err := db.View(func(tx *Tx) error {\n\t\treturn tx.DescendEqual(\"num\", \"1125\", func(key, value string) bool {\n\t\t\tres = append(res, key)\n\t\t\treturn true\n\t\t})\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif len(res) != 2 {\n\t\tt.Fatalf(\"expected %v, got %v\", 2, len(res))\n\t}\n\tif res[0] != \"key:00125B\" {\n\t\tt.Fatalf(\"expected %v, got %v\", \"key:00125B\", res[0])\n\t}\n\tif res[1] != \"key:00125A\" {\n\t\tt.Fatalf(\"expected %v, got %v\", \"key:00125A\", res[1])\n\t}\n}\nfunc TestVariousTx(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tif err := db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"hello\", \"planet\", nil)\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\terrBroken := errors.New(\"broken\")\n\tif err := db.Update(func(tx *Tx) error {\n\t\t_, _, _ = tx.Set(\"hello\", \"world\", nil)\n\t\treturn errBroken\n\t}); err != errBroken {\n\t\tt.Fatalf(\"did not correctly receive the user-defined transaction error.\")\n\t}\n\tvar val string\n\terr := db.View(func(tx *Tx) error {\n\t\tvar err error\n\t\tval, err = tx.Get(\"hello\")\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif val == \"world\" {\n\t\tt.Fatal(\"a rollbacked transaction got through\")\n\t}\n\tif val != \"planet\" {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", \"planet\", val)\n\t}\n\tif err := db.Update(func(tx *Tx) error {\n\t\ttx.db = nil\n\t\tif _, _, err := tx.Set(\"hello\", \"planet\", nil); err != ErrTxClosed {\n\t\t\tt.Fatal(\"expecting a tx closed error\")\n\t\t}\n\t\tif _, err := tx.Delete(\"hello\"); err != ErrTxClosed {\n\t\t\tt.Fatal(\"expecting a tx closed error\")\n\t\t}\n\t\tif _, err := tx.Get(\"hello\"); err != ErrTxClosed {\n\t\t\tt.Fatal(\"expecting a tx closed error\")\n\t\t}\n\t\ttx.db = db\n\t\ttx.writable = false\n\t\tif _, _, err := tx.Set(\"hello\", \"planet\", nil); err != ErrTxNotWritable {\n\t\t\tt.Fatal(\"expecting a tx not writable error\")\n\t\t}\n\t\tif _, err := tx.Delete(\"hello\"); err != ErrTxNotWritable {\n\t\t\tt.Fatal(\"expecting a tx not writable error\")\n\t\t}\n\t\ttx.writable = true\n\t\tif _, err := tx.Get(\"something\"); err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting not found error\")\n\t\t}\n\t\tif _, err := tx.Delete(\"something\"); err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting not found error\")\n\t\t}\n\t\tif _, _, err := tx.Set(\"var\", \"val\", &SetOptions{Expires: true, TTL: 0}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif _, err := tx.Get(\"var\"); err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting not found error\")\n\t\t}\n\t\tif _, err := tx.Delete(\"var\"); err != ErrNotFound {\n\t\t\ttx.unlock()\n\t\t\tt.Fatalf(\"expecting not found error\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test non-managed transactions\n\ttx, err := db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\t_, _, err = tx.Set(\"howdy\", \"world\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttx, err = db.Begin(false)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\tv, err := tx.Get(\"howdy\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != \"world\" {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", \"world\", v)\n\t}\n\tif err := tx.Rollback(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\ttx, err = db.Begin(true)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer tx.Rollback()\n\tv, err = tx.Get(\"howdy\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif v != \"world\" {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", \"world\", v)\n\t}\n\t_, err = tx.Delete(\"howdy\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := tx.Commit(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test for invalid commits\n\tif err := db.Update(func(tx *Tx) error {\n\t\t// we are going to do some hackery\n\t\tdefer func() {\n\t\t\tif v := recover(); v != nil {\n\t\t\t\tif v.(string) != \"managed tx commit not allowed\" {\n\t\t\t\t\tt.Fatal(v.(string))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\treturn tx.Commit()\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test for invalid commits\n\tif err := db.Update(func(tx *Tx) error {\n\t\t// we are going to do some hackery\n\t\tdefer func() {\n\t\t\tif v := recover(); v != nil {\n\t\t\t\tif v.(string) != \"managed tx rollback not allowed\" {\n\t\t\t\t\tt.Fatal(v.(string))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\treturn tx.Rollback()\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test for closed transactions\n\tif err := db.Update(func(tx *Tx) error {\n\t\ttx.db = nil\n\t\treturn nil\n\t}); err != ErrTxClosed {\n\t\tt.Fatal(\"expecting tx closed error\")\n\t}\n\tdb.mu.Unlock()\n\n\t// test for invalid writes\n\tif err := db.Update(func(tx *Tx) error {\n\t\ttx.writable = false\n\t\treturn nil\n\t}); err != ErrTxNotWritable {\n\t\tt.Fatal(\"expecting tx not writable error\")\n\t}\n\tdb.mu.Unlock()\n\t// test for closed transactions\n\tif err := db.View(func(tx *Tx) error {\n\t\ttx.db = nil\n\t\treturn nil\n\t}); err != ErrTxClosed {\n\t\tt.Fatal(\"expecting tx closed error\")\n\t}\n\tdb.mu.RUnlock()\n\t// flush to unwritable file\n\tif err := db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"var1\", \"val1\", nil)\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\treturn tx.db.file.Close()\n\t}); err == nil {\n\t\tt.Fatal(\"should not be able to commit when the file is closed\")\n\t}\n\tdb.file, err = os.OpenFile(\"data.db\", os.O_CREATE|os.O_RDWR, 0666)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif _, err := db.file.Seek(0, 2); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb.buf = nil\n\tif err := db.CreateIndex(\"blank\", \"*\", nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.CreateIndex(\"real\", \"*\", IndexInt); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// test scanning\n\tif err := db.Update(func(tx *Tx) error {\n\t\tless, err := tx.GetLess(\"junk\")\n\t\tif err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting a not found, got %v\", err)\n\t\t}\n\t\tif less != nil {\n\t\t\tt.Fatal(\"expecting nil, got a less function\")\n\t\t}\n\t\tless, err = tx.GetLess(\"blank\")\n\t\tif err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting a not found, got %v\", err)\n\t\t}\n\t\tif less != nil {\n\t\t\tt.Fatal(\"expecting nil, got a less function\")\n\t\t}\n\t\tless, err = tx.GetLess(\"real\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif less == nil {\n\t\t\tt.Fatal(\"expecting a less function, got nil\")\n\t\t}\n\t\t_, _, err = tx.Set(\"nothing\", \"here\", nil)\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.View(func(tx *Tx) error {\n\t\ts := \"\"\n\t\terr := tx.Ascend(\"\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s != \"hello:planet\\nnothing:here\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\t\ttx.db = nil\n\t\terr = tx.Ascend(\"\", func(key, val string) bool { return true })\n\t\tif err != ErrTxClosed {\n\t\t\ttx.unlock()\n\t\t\tt.Fatal(\"expecting tx closed error\")\n\t\t}\n\t\ttx.db = db\n\t\terr = tx.Ascend(\"na\", func(key, val string) bool { return true })\n\t\tif err != ErrNotFound {\n\t\t\tt.Fatal(\"expecting not found error\")\n\t\t}\n\t\terr = tx.Ascend(\"blank\", func(key, val string) bool { return true })\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\ts = \"\"\n\t\terr = tx.AscendLessThan(\"\", \"liger\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s != \"hello:planet\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\n\t\ts = \"\"\n\t\terr = tx.Descend(\"\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s != \"nothing:here\\nhello:planet\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\n\t\ts = \"\"\n\t\terr = tx.DescendLessOrEqual(\"\", \"liger\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif s != \"hello:planet\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\n\t\ts = \"\"\n\t\terr = tx.DescendGreaterThan(\"\", \"liger\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif s != \"nothing:here\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\t\ts = \"\"\n\t\terr = tx.DescendRange(\"\", \"liger\", \"apple\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s != \"hello:planet\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test some spatial stuff\n\tif err := db.CreateSpatialIndex(\"spat\", \"rect:*\", IndexRect); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.CreateSpatialIndex(\"junk\", \"rect:*\", nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.Update(func(tx *Tx) error {\n\t\trect, err := tx.GetRect(\"spat\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rect == nil {\n\t\t\tt.Fatal(\"expecting a rect function, got nil\")\n\t\t}\n\t\trect, err = tx.GetRect(\"junk\")\n\t\tif err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting a not found, got %v\", err)\n\t\t}\n\t\tif rect != nil {\n\t\t\tt.Fatal(\"expecting nil, got a rect function\")\n\t\t}\n\t\trect, err = tx.GetRect(\"na\")\n\t\tif err != ErrNotFound {\n\t\t\tt.Fatalf(\"expecting a not found, got %v\", err)\n\t\t}\n\t\tif rect != nil {\n\t\t\tt.Fatal(\"expecting nil, got a rect function\")\n\t\t}\n\t\tif _, _, err := tx.Set(\"rect:1\", \"[10 10],[20 20]\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"rect:2\", \"[15 15],[25 25]\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"shape:1\", \"[12 12],[25 25]\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\ts := \"\"\n\t\terr = tx.Intersects(\"spat\", \"[5 5],[13 13]\", func(key, val string) bool {\n\t\t\ts += key + \":\" + val + \"\\n\"\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif s != \"rect:1:[10 10],[20 20]\\n\" {\n\t\t\tt.Fatal(\"invalid scan\")\n\t\t}\n\t\ttx.db = nil\n\t\terr = tx.Intersects(\"spat\", \"[5 5],[13 13]\", func(key, val string) bool {\n\t\t\treturn true\n\t\t})\n\t\tif err != ErrTxClosed {\n\t\t\tt.Fatal(\"expecting tx closed error\")\n\t\t}\n\t\ttx.db = db\n\t\terr = tx.Intersects(\"\", \"[5 5],[13 13]\", func(key, val string) bool {\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = tx.Intersects(\"na\", \"[5 5],[13 13]\", func(key, val string) bool {\n\t\t\treturn true\n\t\t})\n\t\tif err != ErrNotFound {\n\t\t\tt.Fatal(\"expecting not found error\")\n\t\t}\n\t\terr = tx.Intersects(\"junk\", \"[5 5],[13 13]\", func(key, val string) bool {\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tn, err := tx.Len()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n != 5 {\n\t\t\tt.Fatalf(\"expecting %v, got %v\", 5, n)\n\t\t}\n\t\ttx.db = nil\n\t\t_, err = tx.Len()\n\t\tif err != ErrTxClosed {\n\t\t\tt.Fatal(\"expecting tx closed error\")\n\t\t}\n\t\ttx.db = db\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// test after closing\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *Tx) error { return nil }); err != ErrDatabaseClosed {\n\t\tt.Fatalf(\"should not be able to perform transactionso on a closed database.\")\n\t}\n}\n\nfunc TestNearby(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\tN := 100000\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateSpatialIndex(\"points\", \"*\", IndexRect)\n\tdb.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < N; i++ {\n\t\t\tp := Point(\n\t\t\t\trand.Float64()*100,\n\t\t\t\trand.Float64()*100,\n\t\t\t\trand.Float64()*100,\n\t\t\t\trand.Float64()*100,\n\t\t\t)\n\t\t\ttx.Set(fmt.Sprintf(\"p:%d\", i), p, nil)\n\t\t}\n\t\treturn nil\n\t})\n\tvar keys, values []string\n\tvar dists []float64\n\tvar pdist float64\n\tvar i int\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Nearby(\"points\", Point(0, 0, 0, 0), func(key, value string, dist float64) bool {\n\t\t\tif i != 0 && dist < pdist {\n\t\t\t\tt.Fatal(\"out of order\")\n\t\t\t}\n\t\t\tkeys = append(keys, key)\n\t\t\tvalues = append(values, value)\n\t\t\tdists = append(dists, dist)\n\t\t\tpdist = dist\n\t\t\ti++\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\tif len(keys) != N {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", N, len(keys))\n\t}\n}\n\nfunc Example_descKeys() {\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateIndex(\"name\", \"*\", IndexString)\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"user:100:first\", \"Tom\", nil)\n\t\ttx.Set(\"user:100:last\", \"Johnson\", nil)\n\t\ttx.Set(\"user:101:first\", \"Janet\", nil)\n\t\ttx.Set(\"user:101:last\", \"Prichard\", nil)\n\t\ttx.Set(\"user:102:first\", \"Alan\", nil)\n\t\ttx.Set(\"user:102:last\", \"Cooper\", nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *Tx) error {\n\t\ttx.AscendKeys(\"user:101:*\",\n\t\t\tfunc(key, value string) bool {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\t\treturn true\n\t\t\t})\n\t\ttx.AscendKeys(\"user:10?:*\",\n\t\t\tfunc(key, value string) bool {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\t\treturn true\n\t\t\t})\n\t\ttx.AscendKeys(\"*2*\",\n\t\t\tfunc(key, value string) bool {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\t\treturn true\n\t\t\t})\n\t\ttx.DescendKeys(\"user:101:*\",\n\t\t\tfunc(key, value string) bool {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\t\treturn true\n\t\t\t})\n\t\ttx.DescendKeys(\"*\",\n\t\t\tfunc(key, value string) bool {\n\t\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\t\treturn true\n\t\t\t})\n\t\treturn nil\n\t})\n\n\t// Output:\n\t// user:101:first: Janet\n\t// user:101:last: Prichard\n\t// user:100:first: Tom\n\t// user:100:last: Johnson\n\t// user:101:first: Janet\n\t// user:101:last: Prichard\n\t// user:102:first: Alan\n\t// user:102:last: Cooper\n\t// user:102:first: Alan\n\t// user:102:last: Cooper\n\t// user:101:last: Prichard\n\t// user:101:first: Janet\n\t// user:102:last: Cooper\n\t// user:102:first: Alan\n\t// user:101:last: Prichard\n\t// user:101:first: Janet\n\t// user:100:last: Johnson\n\t// user:100:first: Tom\n}\n\nfunc ExampleDesc() {\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateIndex(\"last_name_age\", \"*\", IndexJSON(\"name.last\"), Desc(IndexJSON(\"age\")))\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", `{\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}`, nil)\n\t\ttx.Set(\"2\", `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`, nil)\n\t\ttx.Set(\"3\", `{\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}`, nil)\n\t\ttx.Set(\"4\", `{\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}`, nil)\n\t\ttx.Set(\"5\", `{\"name\":{\"first\":\"Sam\",\"last\":\"Anderson\"},\"age\":51}`, nil)\n\t\ttx.Set(\"6\", `{\"name\":{\"first\":\"Melinda\",\"last\":\"Prichard\"},\"age\":44}`, nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"last_name_age\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\n\t// Output:\n\t//3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n\t//5: {\"name\":{\"first\":\"Sam\",\"last\":\"Anderson\"},\"age\":51}\n\t//4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n\t//1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n\t//2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n\t//6: {\"name\":{\"first\":\"Melinda\",\"last\":\"Prichard\"},\"age\":44}\n}\n\nfunc ExampleDB_CreateIndex_jSON() {\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateIndex(\"last_name\", \"*\", IndexJSON(\"name.last\"))\n\tdb.CreateIndex(\"age\", \"*\", IndexJSON(\"age\"))\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", `{\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}`, nil)\n\t\ttx.Set(\"2\", `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`, nil)\n\t\ttx.Set(\"3\", `{\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}`, nil)\n\t\ttx.Set(\"4\", `{\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}`, nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *Tx) error {\n\t\tfmt.Println(\"Order by last name\")\n\t\ttx.Ascend(\"last_name\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Println(\"Order by age\")\n\t\ttx.Ascend(\"age\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Println(\"Order by age range 30-50\")\n\t\ttx.AscendRange(\"age\", `{\"age\":30}`, `{\"age\":50}`, func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\n\t// Output:\n\t// Order by last name\n\t// 3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n\t// 4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n\t// 1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n\t// 2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n\t// Order by age\n\t// 4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n\t// 1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n\t// 2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n\t// 3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n\t// Order by age range 30-50\n\t// 1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n\t// 2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n}\n\nfunc ExampleDB_CreateIndex_strings() {\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateIndex(\"name\", \"*\", IndexString)\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", \"Tom\", nil)\n\t\ttx.Set(\"2\", \"Janet\", nil)\n\t\ttx.Set(\"3\", \"Carol\", nil)\n\t\ttx.Set(\"4\", \"Alan\", nil)\n\t\ttx.Set(\"5\", \"Sam\", nil)\n\t\ttx.Set(\"6\", \"Melinda\", nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"name\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\n\t// Output:\n\t//4: Alan\n\t//3: Carol\n\t//2: Janet\n\t//6: Melinda\n\t//5: Sam\n\t//1: Tom\n}\n\nfunc ExampleDB_CreateIndex_ints() {\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateIndex(\"age\", \"*\", IndexInt)\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", \"30\", nil)\n\t\ttx.Set(\"2\", \"51\", nil)\n\t\ttx.Set(\"3\", \"16\", nil)\n\t\ttx.Set(\"4\", \"76\", nil)\n\t\ttx.Set(\"5\", \"23\", nil)\n\t\ttx.Set(\"6\", \"43\", nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"age\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\n\t// Output:\n\t//3: 16\n\t//5: 23\n\t//1: 30\n\t//6: 43\n\t//2: 51\n\t//4: 76\n}\nfunc ExampleDB_CreateIndex_multipleFields() {\n\tdb, _ := Open(\":memory:\")\n\tdb.CreateIndex(\"last_name_age\", \"*\", IndexJSON(\"name.last\"), IndexJSON(\"age\"))\n\tdb.Update(func(tx *Tx) error {\n\t\ttx.Set(\"1\", `{\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}`, nil)\n\t\ttx.Set(\"2\", `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`, nil)\n\t\ttx.Set(\"3\", `{\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}`, nil)\n\t\ttx.Set(\"4\", `{\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}`, nil)\n\t\ttx.Set(\"5\", `{\"name\":{\"first\":\"Sam\",\"last\":\"Anderson\"},\"age\":51}`, nil)\n\t\ttx.Set(\"6\", `{\"name\":{\"first\":\"Melinda\",\"last\":\"Prichard\"},\"age\":44}`, nil)\n\t\treturn nil\n\t})\n\tdb.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"last_name_age\", func(key, value string) bool {\n\t\t\tfmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\n\t// Output:\n\t//5: {\"name\":{\"first\":\"Sam\",\"last\":\"Anderson\"},\"age\":51}\n\t//3: {\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52}\n\t//4: {\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28}\n\t//1: {\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38}\n\t//6: {\"name\":{\"first\":\"Melinda\",\"last\":\"Prichard\"},\"age\":44}\n\t//2: {\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}\n}\n\nfunc TestNoExpiringItem(t *testing.T) {\n\titem := &dbItem{key: \"key\", val: \"val\"}\n\tif !item.expiresAt().Equal(maxTime) {\n\t\tt.Fatal(\"item.expiresAt() != maxTime\")\n\t}\n\tif min, max := item.Rect(nil); min != nil || max != nil {\n\t\tt.Fatal(\"item min,max should both be nil\")\n\t}\n}\nfunc TestAutoShrink(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tfor i := 0; i < 1000; i++ {\n\t\terr := db.Update(func(tx *Tx) error {\n\t\t\tfor i := 0; i < 20; i++ {\n\t\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"HELLO:%d\", i), \"WORLD\", nil); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tdb = testReOpen(t, db)\n\tdefer testClose(db)\n\tdb.config.AutoShrinkMinSize = 64 * 1024 // 64K\n\tfor i := 0; i < 2000; i++ {\n\t\terr := db.Update(func(tx *Tx) error {\n\t\t\tfor i := 0; i < 20; i++ {\n\t\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"HELLO:%d\", i), \"WORLD\", nil); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\ttime.Sleep(time.Second * 3)\n\tdb = testReOpen(t, db)\n\tdefer testClose(db)\n\terr := db.View(func(tx *Tx) error {\n\t\tn, err := tx.Len()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n != 20 {\n\t\t\tt.Fatalf(\"expecting 20, got %v\", n)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// test database format loading\nfunc TestDatabaseFormat(t *testing.T) {\n\t// should succeed\n\tfunc() {\n\t\tresp := strings.Join([]string{\n\t\t\t\"*3\\r\\n$3\\r\\nset\\r\\n$4\\r\\nvar1\\r\\n$4\\r\\n1234\\r\\n\",\n\t\t\t\"*3\\r\\n$3\\r\\nset\\r\\n$4\\r\\nvar2\\r\\n$4\\r\\n1234\\r\\n\",\n\t\t\t\"*2\\r\\n$3\\r\\ndel\\r\\n$4\\r\\nvar1\\r\\n\",\n\t\t\t\"*5\\r\\n$3\\r\\nset\\r\\n$3\\r\\nvar\\r\\n$3\\r\\nval\\r\\n$2\\r\\nex\\r\\n$2\\r\\n10\\r\\n\",\n\t\t}, \"\")\n\t\tif err := os.RemoveAll(\"data.db\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif err := ioutil.WriteFile(\"data.db\", []byte(resp), 0666); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdb := testOpen(t)\n\t\tdefer testClose(db)\n\t}()\n\ttestFormat := func(t *testing.T, expectValid bool, resp string, do func(db *DB) error) {\n\t\tt.Helper()\n\t\tos.RemoveAll(\"data.db\")\n\t\tif err := ioutil.WriteFile(\"data.db\", []byte(resp), 0666); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdefer os.RemoveAll(\"data.db\")\n\n\t\tdb, err := Open(\"data.db\")\n\t\tif err == nil {\n\t\t\tif do != nil {\n\t\t\t\tif err := do(db); err != nil {\n\t\t\t\t\tt.Fatal(err)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif err := db.Close(); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}\n\t\tif err == nil && !expectValid {\n\t\t\tt.Fatalf(\"expected invalid database\")\n\t\t} else if err != nil && expectValid {\n\t\t\tt.Fatalf(\"expected valid database, got '%s'\", err)\n\t\t}\n\t}\n\n\t// basic valid commands\n\ttestFormat(t, true, \"*2\\r\\n$3\\r\\nDEL\\r\\n$5\\r\\nHELLO\\r\\n\", nil)\n\ttestFormat(t, true, \"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, true, \"*1\\r\\n$7\\r\\nFLUSHDB\\r\\n\", nil)\n\n\t// commands with invalid names or arguments\n\ttestFormat(t, false, \"*3\\r\\n$3\\r\\nDEL\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*2\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n\", nil)\n\ttestFormat(t, false, \"*1\\r\\n$6\\r\\nSET123\\r\\n\", nil)\n\n\t// partial tail commands should be ignored but allowed\n\tpcmd := \"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\"\n\tfor i := 1; i < len(pcmd); i++ {\n\t\tcmd := \"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nJELLO\\r\\n\"\n\t\ttestFormat(t, true, cmd+pcmd[:len(pcmd)-i],\n\t\t\tfunc(db *DB) error {\n\t\t\t\treturn db.View(func(tx *Tx) error {\n\t\t\t\t\tval, err := tx.Get(\"HELLO\")\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif val != \"JELLO\" {\n\t\t\t\t\t\treturn fmt.Errorf(\"expected '%s', got '%s'\", \"JELLO\", val)\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t})\n\t}\n\n\t// commands with invalid formatting\n\ttestFormat(t, false, \"^3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*3\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*3\\r\\n^3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*3\\r\\n$\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*3\\r\\n$3\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*3\\r\\n$3SET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\", nil)\n\ttestFormat(t, false, \"*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n123\\n\", nil)\n\n\t// commands with nuls\n\ttestFormat(t, true, \"\\u0000*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nWORLD\\r\\n\"+\n\t\t\"\\u0000\\u0000*3\\r\\n$3\\r\\nSET\\r\\n$5\\r\\nHELLO\\r\\n$5\\r\\nJELLO\\r\\n\\u0000\", func(db *DB) error {\n\t\treturn db.View(func(tx *Tx) error {\n\t\t\tval, err := tx.Get(\"HELLO\")\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif val != \"JELLO\" {\n\t\t\t\treturn fmt.Errorf(\"expected '%s', got '%s'\", \"JELLO\", val)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t})\n\n}\n\nfunc TestInsertsAndDeleted(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tif err := db.CreateIndex(\"any\", \"*\", IndexString); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.CreateSpatialIndex(\"rect\", \"*\", IndexRect); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Update(func(tx *Tx) error {\n\t\tif _, _, err := tx.Set(\"item1\", \"value1\", &SetOptions{Expires: true, TTL: time.Second}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"item2\", \"value2\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"item3\", \"value3\", &SetOptions{Expires: true, TTL: time.Second}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// test replacing items in the database\n\tif err := db.Update(func(tx *Tx) error {\n\t\tif _, _, err := tx.Set(\"item1\", \"nvalue1\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"item2\", \"nvalue2\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := tx.Delete(\"item3\"); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestInsertDoesNotMisuseIndex(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tfail := func(a, b string) bool { t.Fatal(\"Misused index\"); return false }\n\tif err := db.CreateIndex(\"some\", \"a*\", fail); err != nil {\n\t\t// Only one item is eligible for the index, so no comparison is necessary.\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Update(func(tx *Tx) error {\n\t\tif _, _, err := tx.Set(\"a\", \"1\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"b\", \"1\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"b\", \"2\", nil)\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestDeleteDoesNotMisuseIndex(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tfail := func(a, b string) bool { t.Fatal(\"Misused index\"); return false }\n\tif err := db.CreateIndex(\"some\", \"a*\", fail); err != nil {\n\t\t// Only one item is eligible for the index, so no comparison is necessary.\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Update(func(tx *Tx) error {\n\t\tif _, _, err := tx.Set(\"a\", \"1\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"b\", \"1\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif err := db.Update(func(tx *Tx) error {\n\t\t_, err := tx.Delete(\"b\")\n\t\treturn err\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// test index compare functions\nfunc TestIndexCompare(t *testing.T) {\n\tif !IndexFloat(\"1.5\", \"1.6\") {\n\t\tt.Fatalf(\"expected true, got false\")\n\t}\n\tif !IndexInt(\"-1\", \"2\") {\n\t\tt.Fatalf(\"expected true, got false\")\n\t}\n\tif !IndexUint(\"10\", \"25\") {\n\t\tt.Fatalf(\"expected true, got false\")\n\t}\n\tif !IndexBinary(\"Hello\", \"hello\") {\n\t\tt.Fatalf(\"expected true, got false\")\n\t}\n\tif IndexString(\"hello\", \"hello\") {\n\t\tt.Fatalf(\"expected false, got true\")\n\t}\n\tif IndexString(\"Hello\", \"hello\") {\n\t\tt.Fatalf(\"expected false, got true\")\n\t}\n\tif IndexString(\"hello\", \"Hello\") {\n\t\tt.Fatalf(\"expected false, got true\")\n\t}\n\tif !IndexString(\"gello\", \"Hello\") {\n\t\tt.Fatalf(\"expected true, got false\")\n\t}\n\tif IndexString(\"Hello\", \"gello\") {\n\t\tt.Fatalf(\"expected false, got true\")\n\t}\n\tif Rect(IndexRect(\"[1 2 3 4],[5 6 7 8]\")) != \"[1 2 3 4],[5 6 7 8]\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"[1 2 3 4],[5 6 7 8]\", Rect(IndexRect(\"[1 2 3 4],[5 6 7 8]\")))\n\t}\n\tif Rect(IndexRect(\"[1 2 3 4]\")) != \"[1 2 3 4]\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"[1 2 3 4]\", Rect(IndexRect(\"[1 2 3 4]\")))\n\t}\n\tif Rect(nil, nil) != \"[]\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"\", Rect(nil, nil))\n\t}\n\tif Point(1, 2, 3) != \"[1 2 3]\" {\n\t\tt.Fatalf(\"expected '%v', got '%v'\", \"[1 2 3]\", Point(1, 2, 3))\n\t}\n}\n\n// test opening a folder.\nfunc TestOpeningAFolder(t *testing.T) {\n\tif err := os.RemoveAll(\"dir.tmp\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := os.Mkdir(\"dir.tmp\", 0700); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() { _ = os.RemoveAll(\"dir.tmp\") }()\n\tdb, err := Open(\"dir.tmp\")\n\tif err == nil {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatalf(\"opening a directory should not be allowed\")\n\t}\n}\n\n// test opening an invalid resp file.\nfunc TestOpeningInvalidDatabaseFile(t *testing.T) {\n\tif err := os.RemoveAll(\"data.db\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := ioutil.WriteFile(\"data.db\", []byte(\"invalid\\r\\nfile\"), 0666); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() { _ = os.RemoveAll(\"data.db\") }()\n\tdb, err := Open(\"data.db\")\n\tif err == nil {\n\t\tif err := db.Close(); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tt.Fatalf(\"invalid database should not be allowed\")\n\t}\n}\n\n// test closing a closed database.\nfunc TestOpeningClosedDatabase(t *testing.T) {\n\tif err := os.RemoveAll(\"data.db\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb, err := Open(\"data.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() { _ = os.RemoveAll(\"data.db\") }()\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"should not be able to close a closed database\")\n\t}\n\tdb, err = Open(\":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Close(); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"should not be able to close a closed database\")\n\t}\n}\n\n// test shrinking a database.\nfunc TestShrink(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tif err := db.Shrink(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfi, err := os.Stat(\"data.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif fi.Size() != 0 {\n\t\tt.Fatalf(\"expected %v, got %v\", 0, fi.Size())\n\t}\n\t// add 10 items\n\terr = db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"key%d\", i), fmt.Sprintf(\"val%d\", i), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// add the same 10 items\n\t// this will create 10 duplicate log entries\n\terr = db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"key%d\", i), fmt.Sprintf(\"val%d\", i), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfi, err = os.Stat(\"data.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsz1 := fi.Size()\n\tif sz1 == 0 {\n\t\tt.Fatalf(\"expected > 0, got %v\", sz1)\n\t}\n\tif err := db.Shrink(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tfi, err = os.Stat(\"data.db\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tsz2 := fi.Size()\n\tif sz2 >= sz1 {\n\t\tt.Fatalf(\"expected < %v, got %v\", sz1, sz2)\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Shrink(); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"shrink on a closed databse should not be allowed\")\n\t}\n\t// Now we will open a db that does not persist\n\tdb, err = Open(\":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer func() { _ = db.Close() }()\n\t// add 10 items\n\terr = db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"key%d\", i), fmt.Sprintf(\"val%d\", i), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// add the same 10 items\n\t// this will create 10 duplicate log entries\n\terr = db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 10; i++ {\n\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"key%d\", i), fmt.Sprintf(\"val%d\", i), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.View(func(tx *Tx) error {\n\t\tn, err := tx.Len()\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif n != 10 {\n\t\t\tt.Fatalf(\"expecting %v, got %v\", 10, n)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// this should succeed even though it's basically a noop.\n\tif err := db.Shrink(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestVariousIndexOperations(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\t// test creating an index with no index name.\n\terr := db.CreateIndex(\"\", \"\", nil)\n\tif err == nil {\n\t\tt.Fatal(\"should not be able to create an index with no name\")\n\t}\n\t// test creating an index with a name that has already been used.\n\terr = db.CreateIndex(\"hello\", \"\", nil)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.CreateIndex(\"hello\", \"\", nil)\n\tif err == nil {\n\t\tt.Fatal(\"should not be able to create a duplicate index\")\n\t}\n\terr = db.Update(func(tx *Tx) error {\n\n\t\tif _, _, err := tx.Set(\"user:1\", \"tom\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"user:2\", \"janet\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"alt:1\", \"from\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"alt:2\", \"there\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"rect:1\", \"[1 2],[3 4]\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"rect:2\", \"[5 6],[7 8]\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// test creating an index after adding items. use pattern matching. have some items in the match and some not.\n\tif err := db.CreateIndex(\"string\", \"user:*\", IndexString); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// test creating a spatial index after adding items. use pattern matching. have some items in the match and some not.\n\tif err := db.CreateSpatialIndex(\"rect\", \"rect:*\", IndexRect); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// test dropping an index\n\tif err := db.DropIndex(\"hello\"); err != nil {\n\t\tt.Fatal(err)\n\t}\n\t// test dropping an index with no name\n\tif err := db.DropIndex(\"\"); err == nil {\n\t\tt.Fatal(\"should not be allowed to drop an index with no name\")\n\t}\n\t// test dropping an index with no name\n\tif err := db.DropIndex(\"na\"); err == nil {\n\t\tt.Fatal(\"should not be allowed to drop an index that does not exist\")\n\t}\n\t// test retrieving index names\n\tnames, err := db.Indexes()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif strings.Join(names, \",\") != \"rect,string\" {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", \"rect,string\", strings.Join(names, \",\"))\n\t}\n\t// test creating an index after closing database\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.CreateIndex(\"new-index\", \"\", nil); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"should not be able to create an index on a closed database\")\n\t}\n\t// test getting index names after closing database\n\tif _, err := db.Indexes(); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"should not be able to get index names on a closed database\")\n\t}\n\t// test dropping an index after closing database\n\tif err := db.DropIndex(\"rect\"); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"should not be able to drop an index on a closed database\")\n\t}\n}\n\nfunc test(t *testing.T, a, b bool) {\n\tif a != b {\n\t\tt.Fatal(\"failed, bummer...\")\n\t}\n}\n\nfunc TestBasic(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\n\t// create a simple index\n\tif err := db.CreateIndex(\"users\", \"fun:user:*\", IndexString); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\t// create a spatial index\n\tif err := db.CreateSpatialIndex(\"rects\", \"rect:*\", IndexRect); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif true {\n\t\terr := db.Update(func(tx *Tx) error {\n\t\t\tif _, _, err := tx.Set(\"fun:user:0\", \"tom\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"fun:user:1\", \"Randi\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"fun:user:2\", \"jane\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"fun:user:4\", \"Janet\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"fun:user:5\", \"Paula\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"fun:user:6\", \"peter\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"fun:user:7\", \"Terri\", nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\t// add some random items\n\t\tstart := time.Now()\n\t\tif err := db.Update(func(tx *Tx) error {\n\t\t\tfor _, i := range rand.Perm(100) {\n\t\t\t\tif _, _, err := tx.Set(fmt.Sprintf(\"tag:%d\", i+100), fmt.Sprintf(\"val:%d\", rand.Int()%100+100), nil); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif false {\n\t\t\tprintln(time.Since(start).String(), db.keys.Len())\n\t\t}\n\t\t// add some random rects\n\t\tif err := db.Update(func(tx *Tx) error {\n\t\t\tif _, _, err := tx.Set(\"rect:1\", Rect([]float64{10, 10}, []float64{20, 20}), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"rect:2\", Rect([]float64{15, 15}, []float64{24, 24}), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif _, _, err := tx.Set(\"rect:3\", Rect([]float64{17, 17}, []float64{27, 27}), nil); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\t// verify the data has been created\n\tbuf := &bytes.Buffer{}\n\terr := db.View(func(tx *Tx) error {\n\t\terr := tx.Ascend(\"users\", func(key, val string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s %s\\n\", key, val)\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = tx.AscendRange(\"\", \"tag:170\", \"tag:172\", func(key, val string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s\\n\", key)\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = tx.AscendGreaterOrEqual(\"\", \"tag:195\", func(key, val string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s\\n\", key)\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\terr = tx.AscendGreaterOrEqual(\"\", \"rect:\", func(key, val string) bool {\n\t\t\tif !strings.HasPrefix(key, \"rect:\") {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tmin, max := IndexRect(val)\n\t\t\tfmt.Fprintf(buf, \"%s: %v,%v\\n\", key, min, max)\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\texpect := make([]string, 2)\n\t\tn := 0\n\t\terr = tx.Intersects(\"rects\", \"[0 0],[15 15]\", func(key, val string) bool {\n\t\t\tif n == 2 {\n\t\t\t\tt.Fatalf(\"too many rects where received, expecting only two\")\n\t\t\t}\n\t\t\tmin, max := IndexRect(val)\n\t\t\ts := fmt.Sprintf(\"%s: %v,%v\\n\", key, min, max)\n\t\t\tif key == \"rect:1\" {\n\t\t\t\texpect[0] = s\n\t\t\t} else if key == \"rect:2\" {\n\t\t\t\texpect[1] = s\n\t\t\t}\n\t\t\tn++\n\t\t\treturn true\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tfor _, s := range expect {\n\t\t\tif _, err := buf.WriteString(s); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tres := `\nfun:user:2 jane\nfun:user:4 Janet\nfun:user:5 Paula\nfun:user:6 peter\nfun:user:1 Randi\nfun:user:7 Terri\nfun:user:0 tom\ntag:170\ntag:171\ntag:195\ntag:196\ntag:197\ntag:198\ntag:199\nrect:1: [10 10],[20 20]\nrect:2: [15 15],[24 24]\nrect:3: [17 17],[27 27]\nrect:1: [10 10],[20 20]\nrect:2: [15 15],[24 24]\n`\n\tres = strings.Replace(res, \"\\r\", \"\", -1)\n\tif strings.TrimSpace(buf.String()) != strings.TrimSpace(res) {\n\t\tt.Fatalf(\"expected [%v], got [%v]\", strings.TrimSpace(res), strings.TrimSpace(buf.String()))\n\t}\n}\n\nfunc TestIndexAscend(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\n\t// create a simple index\n\tif err := db.CreateIndex(\"usr\", \"usr:*\", IndexInt); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor i := 10; i > 0; i-- {\n\t\t\ttx.Set(fmt.Sprintf(\"usr:%d\", i), fmt.Sprintf(\"%d\", 10-i), nil)\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tbuf := &bytes.Buffer{}\n\terr := db.View(func(tx *Tx) error {\n\t\ttx.Ascend(\"usr\", func(key, value string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Fprintln(buf)\n\n\t\ttx.AscendGreaterOrEqual(\"usr\", \"8\", func(key, value string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Fprintln(buf)\n\n\t\ttx.AscendLessThan(\"usr\", \"3\", func(key, value string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\tfmt.Fprintln(buf)\n\n\t\ttx.AscendRange(\"usr\", \"4\", \"8\", func(key, value string) bool {\n\t\t\tfmt.Fprintf(buf, \"%s %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tres := `\nusr:10 0\nusr:9 1\nusr:8 2\nusr:7 3\nusr:6 4\nusr:5 5\nusr:4 6\nusr:3 7\nusr:2 8\nusr:1 9\n\nusr:2 8\nusr:1 9\n\nusr:10 0\nusr:9 1\nusr:8 2\n\nusr:6 4\nusr:5 5\nusr:4 6\nusr:3 7\n`\n\tres = strings.Replace(res, \"\\r\", \"\", -1)\n\ts1 := strings.TrimSpace(buf.String())\n\ts2 := strings.TrimSpace(res)\n\tif s1 != s2 {\n\t\tt.Fatalf(\"expected [%v], got [%v]\", s1, s2)\n\t}\n}\n\nfunc testRectStringer(min, max []float64) error {\n\tnmin, nmax := IndexRect(Rect(min, max))\n\tif len(nmin) != len(min) {\n\t\treturn fmt.Errorf(\"rect=%v,%v, expect=%v,%v\", nmin, nmax, min, max)\n\t}\n\tfor i := 0; i < len(min); i++ {\n\t\tif min[i] != nmin[i] || max[i] != nmax[i] {\n\t\t\treturn fmt.Errorf(\"rect=%v,%v, expect=%v,%v\", nmin, nmax, min, max)\n\t\t}\n\t}\n\treturn nil\n}\nfunc TestRectStrings(t *testing.T) {\n\ttest(t, Rect(IndexRect(Point(1))) == \"[1]\", true)\n\ttest(t, Rect(IndexRect(Point(1, 2, 3, 4))) == \"[1 2 3 4]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[1 2],[1 2]\")))) == \"[1 2]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[1 2],[2 2]\")))) == \"[1 2],[2 2]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[1 2],[2 2],[3]\")))) == \"[1 2],[2 2]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[1 2]\")))) == \"[1 2]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[1.5 2 4.5 5.6]\")))) == \"[1.5 2 4.5 5.6]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[1.5 2 4.5 5.6 -1],[]\")))) == \"[1.5 2 4.5 5.6 -1]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"[]\")))) == \"[]\", true)\n\ttest(t, Rect(IndexRect(Rect(IndexRect(\"\")))) == \"[]\", true)\n\tif err := testRectStringer(nil, nil); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := testRectStringer([]float64{}, []float64{}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := testRectStringer([]float64{1}, []float64{2}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := testRectStringer([]float64{1, 2}, []float64{3, 4}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := testRectStringer([]float64{1, 2, 3}, []float64{4, 5, 6}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := testRectStringer([]float64{1, 2, 3, 4}, []float64{5, 6, 7, 8}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := testRectStringer([]float64{1, 2, 3, 4, 5}, []float64{6, 7, 8, 9, 10}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\n// TestTTLReOpen test setting a TTL and then immediately closing the database and\n// then waiting the TTL before reopening. The key should not be accessible.\nfunc TestTTLReOpen(t *testing.T) {\n\tttl := time.Second * 3\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\terr := db.Update(func(tx *Tx) error {\n\t\tif _, _, err := tx.Set(\"key1\", \"val1\", &SetOptions{Expires: true, TTL: ttl}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb = testReOpenDelay(t, db, ttl/4)\n\terr = db.View(func(tx *Tx) error {\n\t\tval, err := tx.Get(\"key1\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val != \"val1\" {\n\t\t\tt.Fatalf(\"expecting '%v', got '%v'\", \"val1\", val)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdb = testReOpenDelay(t, db, ttl-ttl/4)\n\tdefer testClose(db)\n\terr = db.View(func(tx *Tx) error {\n\t\tval, err := tx.Get(\"key1\")\n\t\tif err == nil || err != ErrNotFound || val != \"\" {\n\t\t\tt.Fatal(\"expecting not found\")\n\t\t}\n\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestTTL(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\terr := db.Update(func(tx *Tx) error {\n\t\tif _, _, err := tx.Set(\"key1\", \"val1\", &SetOptions{Expires: true, TTL: time.Second}); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, _, err := tx.Set(\"key2\", \"val2\", nil); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.View(func(tx *Tx) error {\n\t\tdur1, err := tx.TTL(\"key1\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif dur1 > time.Second || dur1 <= 0 {\n\t\t\tt.Fatalf(\"expecting between zero and one second, got '%v'\", dur1)\n\t\t}\n\t\tdur1, err = tx.TTL(\"key2\")\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif dur1 >= 0 {\n\t\t\tt.Fatalf(\"expecting a negative value, got '%v'\", dur1)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestConfig(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\n\terr := db.SetConfig(Config{SyncPolicy: SyncPolicy(-1)})\n\tif err == nil {\n\t\tt.Fatal(\"expecting a config syncpolicy error\")\n\t}\n\terr = db.SetConfig(Config{SyncPolicy: SyncPolicy(3)})\n\tif err == nil {\n\t\tt.Fatal(\"expecting a config syncpolicy error\")\n\t}\n\terr = db.SetConfig(Config{SyncPolicy: Never})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.SetConfig(Config{SyncPolicy: EverySecond})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr = db.SetConfig(Config{AutoShrinkMinSize: 100, AutoShrinkPercentage: 200, SyncPolicy: Always})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tvar c Config\n\tif err := db.ReadConfig(&c); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif c.AutoShrinkMinSize != 100 || c.AutoShrinkPercentage != 200 && c.SyncPolicy != Always {\n\t\tt.Fatalf(\"expecting %v, %v, and %v, got %v, %v, and %v\", 100, 200, Always, c.AutoShrinkMinSize, c.AutoShrinkPercentage, c.SyncPolicy)\n\t}\n}\nfunc testUint64Hex(n uint64) string {\n\ts := strconv.FormatUint(n, 16)\n\ts = \"0000000000000000\" + s\n\treturn s[len(s)-16:]\n}\nfunc textHexUint64(s string) uint64 {\n\tn, _ := strconv.ParseUint(s, 16, 64)\n\treturn n\n}\nfunc benchClose(t *testing.B, persist bool, db *DB) {\n\tif persist {\n\t\tif err := os.RemoveAll(\"data.db\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tif err := db.Close(); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc benchOpenFillData(t *testing.B, N int,\n\tset, persist, random bool,\n\tgeo bool,\n\tbatch int) (db *DB, keys, vals []string) {\n\t///\n\tt.StopTimer()\n\trand.Seed(time.Now().UnixNano())\n\tvar err error\n\tif persist {\n\t\tif err := os.RemoveAll(\"data.db\"); err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tdb, err = Open(\"data.db\")\n\t} else {\n\t\tdb, err = Open(\":memory:\")\n\t}\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tkeys = make([]string, N)\n\tvals = make([]string, N)\n\tperm := rand.Perm(N)\n\tfor i := 0; i < N; i++ {\n\t\tif random && set {\n\t\t\tkeys[perm[i]] = testUint64Hex(uint64(i))\n\t\t\tvals[perm[i]] = strconv.FormatInt(rand.Int63()%1000+1000, 10)\n\t\t} else {\n\t\t\tkeys[i] = testUint64Hex(uint64(i))\n\t\t\tvals[i] = strconv.FormatInt(rand.Int63()%1000+1000, 10)\n\t\t}\n\t}\n\tif set {\n\t\tt.StartTimer()\n\t}\n\tfor i := 0; i < N; {\n\t\terr := db.Update(func(tx *Tx) error {\n\t\t\tvar err error\n\t\t\tfor j := 0; j < batch && i < N; j++ {\n\t\t\t\t_, _, err = tx.Set(keys[i], vals[i], nil)\n\t\t\t\ti++\n\t\t\t}\n\t\t\treturn err\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t}\n\tif set {\n\t\tt.StopTimer()\n\t}\n\tvar n uint64\n\terr = db.View(func(tx *Tx) error {\n\t\terr := tx.Ascend(\"\", func(key, value string) bool {\n\t\t\tn2 := textHexUint64(key)\n\t\t\tif n2 != n {\n\t\t\t\tt.Fatalf(\"expecting '%v', got '%v'\", n2, n)\n\t\t\t}\n\t\t\tn++\n\t\t\treturn true\n\t\t})\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif n != uint64(N) {\n\t\tt.Fatalf(\"expecting '%v', got '%v'\", N, n)\n\t}\n\tt.StartTimer()\n\treturn db, keys, vals\n}\n\nfunc benchSetGet(t *testing.B, set, persist, random bool, batch int) {\n\tN := t.N\n\tfor N > 0 {\n\t\tn := 0\n\t\tif N >= 100000 {\n\t\t\tn = 100000\n\t\t} else {\n\t\t\tn = N\n\t\t}\n\t\tfunc() {\n\t\t\tdb, keys, _ := benchOpenFillData(t, n, set, persist, random, false, batch)\n\t\t\tdefer benchClose(t, persist, db)\n\t\t\tif !set {\n\t\t\t\tfor i := 0; i < n; {\n\t\t\t\t\terr := db.View(func(tx *Tx) error {\n\t\t\t\t\t\tvar err error\n\t\t\t\t\t\tfor j := 0; j < batch && i < n; j++ {\n\t\t\t\t\t\t\t_, err = tx.Get(keys[i])\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn err\n\t\t\t\t\t})\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\tt.Fatal(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t\tN -= n\n\t}\n}\n\n// Set Persist\nfunc Benchmark_Set_Persist_Random_1(t *testing.B) {\n\tbenchSetGet(t, true, true, true, 1)\n}\nfunc Benchmark_Set_Persist_Random_10(t *testing.B) {\n\tbenchSetGet(t, true, true, true, 10)\n}\nfunc Benchmark_Set_Persist_Random_100(t *testing.B) {\n\tbenchSetGet(t, true, true, true, 100)\n}\nfunc Benchmark_Set_Persist_Sequential_1(t *testing.B) {\n\tbenchSetGet(t, true, true, false, 1)\n}\nfunc Benchmark_Set_Persist_Sequential_10(t *testing.B) {\n\tbenchSetGet(t, true, true, false, 10)\n}\nfunc Benchmark_Set_Persist_Sequential_100(t *testing.B) {\n\tbenchSetGet(t, true, true, false, 100)\n}\n\n// Set NoPersist\nfunc Benchmark_Set_NoPersist_Random_1(t *testing.B) {\n\tbenchSetGet(t, true, false, true, 1)\n}\nfunc Benchmark_Set_NoPersist_Random_10(t *testing.B) {\n\tbenchSetGet(t, true, false, true, 10)\n}\nfunc Benchmark_Set_NoPersist_Random_100(t *testing.B) {\n\tbenchSetGet(t, true, false, true, 100)\n}\nfunc Benchmark_Set_NoPersist_Sequential_1(t *testing.B) {\n\tbenchSetGet(t, true, false, false, 1)\n}\nfunc Benchmark_Set_NoPersist_Sequential_10(t *testing.B) {\n\tbenchSetGet(t, true, false, false, 10)\n}\nfunc Benchmark_Set_NoPersist_Sequential_100(t *testing.B) {\n\tbenchSetGet(t, true, false, false, 100)\n}\n\n// Get\nfunc Benchmark_Get_1(t *testing.B) {\n\tbenchSetGet(t, false, false, false, 1)\n}\nfunc Benchmark_Get_10(t *testing.B) {\n\tbenchSetGet(t, false, false, false, 10)\n}\nfunc Benchmark_Get_100(t *testing.B) {\n\tbenchSetGet(t, false, false, false, 100)\n}\n\nfunc benchScan(t *testing.B, asc bool, count int) {\n\tN := count\n\tdb, _, _ := benchOpenFillData(t, N, false, false, false, false, 100)\n\tdefer benchClose(t, false, db)\n\tfor i := 0; i < t.N; i++ {\n\t\tcount := 0\n\t\terr := db.View(func(tx *Tx) error {\n\t\t\tif asc {\n\t\t\t\treturn tx.Ascend(\"\", func(key, val string) bool {\n\t\t\t\t\tcount++\n\t\t\t\t\treturn true\n\t\t\t\t})\n\t\t\t}\n\t\t\treturn tx.Descend(\"\", func(key, val string) bool {\n\t\t\t\tcount++\n\t\t\t\treturn true\n\t\t\t})\n\n\t\t})\n\t\tif err != nil {\n\t\t\tt.Fatal(err)\n\t\t}\n\t\tif count != N {\n\t\t\tt.Fatalf(\"expecting '%v', got '%v'\", N, count)\n\t\t}\n\t}\n}\n\nfunc Benchmark_Ascend_1(t *testing.B) {\n\tbenchScan(t, true, 1)\n}\nfunc Benchmark_Ascend_10(t *testing.B) {\n\tbenchScan(t, true, 10)\n}\nfunc Benchmark_Ascend_100(t *testing.B) {\n\tbenchScan(t, true, 100)\n}\nfunc Benchmark_Ascend_1000(t *testing.B) {\n\tbenchScan(t, true, 1000)\n}\nfunc Benchmark_Ascend_10000(t *testing.B) {\n\tbenchScan(t, true, 10000)\n}\n\nfunc Benchmark_Descend_1(t *testing.B) {\n\tbenchScan(t, false, 1)\n}\nfunc Benchmark_Descend_10(t *testing.B) {\n\tbenchScan(t, false, 10)\n}\nfunc Benchmark_Descend_100(t *testing.B) {\n\tbenchScan(t, false, 100)\n}\nfunc Benchmark_Descend_1000(t *testing.B) {\n\tbenchScan(t, false, 1000)\n}\nfunc Benchmark_Descend_10000(t *testing.B) {\n\tbenchScan(t, false, 10000)\n}\n\n/*\n\tfunc Benchmark_Spatial_2D(t *testing.B) {\n\t\tN := 100000\n\t\tdb, _, _ := benchOpenFillData(t, N, true, true, false, true, 100)\n\t\tdefer benchClose(t, false, db)\n\n}\n*/\nfunc TestCoverCloseAlreadyClosed(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\t_ = db.file.Close()\n\tif err := db.Close(); err == nil {\n\t\tt.Fatal(\"expecting an error\")\n\t}\n}\n\nfunc TestCoverConfigClosed(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\t_ = db.Close()\n\tvar config Config\n\tif err := db.ReadConfig(&config); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"expecting database closed error\")\n\t}\n\tif err := db.SetConfig(config); err != ErrDatabaseClosed {\n\t\tt.Fatal(\"expecting database closed error\")\n\t}\n}\nfunc TestCoverShrinkShrink(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor i := 0; i < 10000; i++ {\n\t\t\t_, _, err := tx.Set(fmt.Sprintf(\"%d\", i), fmt.Sprintf(\"%d\", i), nil)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tif err := db.Update(func(tx *Tx) error {\n\t\tfor i := 250; i < 250+100; i++ {\n\t\t\t_, err := tx.Delete(fmt.Sprintf(\"%d\", i))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n\tvar err1, err2 error\n\tvar wg sync.WaitGroup\n\twg.Add(2)\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terr1 = db.Shrink()\n\t}()\n\tgo func() {\n\t\tdefer wg.Done()\n\t\terr2 = db.Shrink()\n\t}()\n\twg.Wait()\n\t//println(123)\n\t//fmt.Printf(\"%v\\n%v\\n\", err1, err2)\n\tif err1 != ErrShrinkInProcess && err2 != ErrShrinkInProcess {\n\t\tt.Fatal(\"expecting a shrink in process error\")\n\t}\n\tdb = testReOpen(t, db)\n\tdefer testClose(db)\n\tif err := db.View(func(tx *Tx) error {\n\t\tn, err := tx.Len()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif n != 9900 {\n\t\t\tt.Fatal(\"expecting 9900 items\")\n\t\t}\n\t\treturn nil\n\t}); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestPreviousItem(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\terr := db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"hello\", \"world\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tprev, replaced, err := tx.Set(\"hello\", \"planet\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif !replaced {\n\t\t\tt.Fatal(\"should be replaced\")\n\t\t}\n\t\tif prev != \"world\" {\n\t\t\tt.Fatalf(\"expecting '%v', got '%v'\", \"world\", prev)\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestJSONIndex(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\n\t_ = db.CreateIndex(\"last_name\", \"*\", IndexJSON(\"name.last\"))\n\t_ = db.CreateIndex(\"last_name_cs\", \"*\", IndexJSONCaseSensitive(\"name.last\"))\n\t_ = db.CreateIndex(\"age\", \"*\", IndexJSON(\"age\"))\n\t_ = db.CreateIndex(\"student\", \"*\", IndexJSON(\"student\"))\n\t_ = db.Update(func(tx *Tx) error {\n\t\t_, _, _ = tx.Set(\"1\", `{\"name\":{\"first\":\"Tom\",\"last\":\"Johnson\"},\"age\":38,\"student\":false}`, nil)\n\t\t_, _, _ = tx.Set(\"2\", `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47,\"student\":true}`, nil)\n\t\t_, _, _ = tx.Set(\"3\", `{\"name\":{\"first\":\"Carol\",\"last\":\"Anderson\"},\"age\":52,\"student\":true}`, nil)\n\t\t_, _, _ = tx.Set(\"4\", `{\"name\":{\"first\":\"Alan\",\"last\":\"Cooper\"},\"age\":28,\"student\":false}`, nil)\n\t\t_, _, _ = tx.Set(\"5\", `{\"name\":{\"first\":\"bill\",\"last\":\"frank\"},\"age\":21,\"student\":true}`, nil)\n\t\t_, _, _ = tx.Set(\"6\", `{\"name\":{\"first\":\"sally\",\"last\":\"randall\"},\"age\":68,\"student\":false}`, nil)\n\t\treturn nil\n\t})\n\tvar keys []string\n\t_ = db.View(func(tx *Tx) error {\n\t\t_ = tx.Ascend(\"last_name_cs\", func(key, value string) bool {\n\t\t\t//fmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\tkeys = append(keys, key)\n\t\t\treturn true\n\t\t})\n\t\t_ = tx.Ascend(\"last_name\", func(key, value string) bool {\n\t\t\t//fmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\tkeys = append(keys, key)\n\t\t\treturn true\n\t\t})\n\t\t_ = tx.Ascend(\"age\", func(key, value string) bool {\n\t\t\t//fmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\tkeys = append(keys, key)\n\t\t\treturn true\n\t\t})\n\t\t_ = tx.Ascend(\"student\", func(key, value string) bool {\n\t\t\t//fmt.Printf(\"%s: %s\\n\", key, value)\n\t\t\tkeys = append(keys, key)\n\t\t\treturn true\n\t\t})\n\t\treturn nil\n\t})\n\texpect := \"3,4,1,2,5,6,3,4,5,1,2,6,5,4,1,2,3,6,1,4,6,2,3,5\"\n\tif strings.Join(keys, \",\") != expect {\n\t\tt.Fatalf(\"expected %v, got %v\", expect, strings.Join(keys, \",\"))\n\t}\n}\n\nfunc TestOnExpiredSync(t *testing.T) {\n\tdb := testOpen(t)\n\tdefer testClose(db)\n\n\tvar config Config\n\tif err := db.ReadConfig(&config); err != nil {\n\t\tt.Fatal(err)\n\t}\n\thits := make(chan int, 3)\n\tconfig.OnExpiredSync = func(key, value string, tx *Tx) error {\n\t\tn, err := strconv.Atoi(value)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer func() { hits <- n }()\n\t\tif n >= 2 {\n\t\t\t_, err = tx.Delete(key)\n\t\t\tif err != ErrNotFound {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t\tn++\n\t\t_, _, err = tx.Set(key, strconv.Itoa(n), &SetOptions{Expires: true, TTL: time.Millisecond * 100})\n\t\treturn err\n\t}\n\tif err := db.SetConfig(config); err != nil {\n\t\tt.Fatal(err)\n\t}\n\terr := db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"K\", \"0\", &SetOptions{Expires: true, TTL: time.Millisecond * 100})\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fail()\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\tticks := time.NewTicker(time.Millisecond * 50)\n\t\tdefer ticks.Stop()\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase <-done:\n\t\t\t\treturn\n\t\t\tcase <-ticks.C:\n\t\t\t\terr := db.View(func(tx *Tx) error {\n\t\t\t\t\tv, err := tx.Get(\"K\", true)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tn, err := strconv.Atoi(v)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tif n < 0 || n > 2 {\n\t\t\t\t\t\tt.Fail()\n\t\t\t\t\t}\n\t\t\t\t\treturn nil\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tt.Fail()\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\nOUTER1:\n\tfor {\n\t\tselect {\n\t\tcase <-time.After(time.Second * 2):\n\t\t\tt.Fail()\n\t\tcase v := <-hits:\n\t\t\tif v >= 2 {\n\t\t\t\tbreak OUTER1\n\t\t\t}\n\t\t}\n\t}\n\terr = db.View(func(tx *Tx) error {\n\t\tdefer close(done)\n\t\tv, err := tx.Get(\"K\")\n\t\tif err != nil {\n\t\t\tt.Fail()\n\t\t\treturn err\n\t\t}\n\t\tif v != \"2\" {\n\t\t\tt.Fail()\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fail()\n\t}\n}\n\nfunc TestTransactionLeak(t *testing.T) {\n\t// This tests an bug identified in Issue #69. When inside a Update\n\t// transaction, a Set after a Delete for a key that previously exists will\n\t// remove the key when the transaction was rolledback.\n\tbuntDB, err := Open(\":memory:\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbd := buntDB\n\terr = bd.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"a\", \"a\", nil)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbd.View(func(tx *Tx) error {\n\t\tval, err := tx.Get(\"a\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val != \"a\" {\n\t\t\treturn errors.New(\"mismatch\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbd.Update(func(tx *Tx) error {\n\t\tval, err := tx.Delete(\"a\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val != \"a\" {\n\t\t\treturn errors.New(\"mismatch\")\n\t\t}\n\t\tval, err = tx.Get(\"a\")\n\t\tif err != ErrNotFound {\n\t\t\treturn fmt.Errorf(\"expected NotFound, got %v\", err)\n\t\t}\n\t\tif val != \"\" {\n\t\t\treturn errors.New(\"mismatch\")\n\t\t}\n\t\tval, rep, err := tx.Set(\"a\", \"b\", nil)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif rep {\n\t\t\treturn errors.New(\"replaced\")\n\t\t}\n\t\tif val != \"\" {\n\t\t\treturn errors.New(\"mismatch\")\n\t\t}\n\t\tval, err = tx.Get(\"a\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val != \"b\" {\n\t\t\treturn errors.New(\"mismatch\")\n\t\t}\n\t\treturn errors.New(\"rollback\")\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tbd.View(func(tx *Tx) error {\n\t\tval, err := tx.Get(\"a\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif val != \"a\" {\n\t\t\treturn errors.New(\"mismatch\")\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestReloadNotInvalid(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\tos.RemoveAll(\"data.db\")\n\tdefer os.RemoveAll(\"data.db\")\n\tstart := time.Now()\n\tii := 0\n\tfor time.Since(start) < time.Second*5 {\n\t\tfunc() {\n\t\t\tdb, err := Open(\"data.db\")\n\t\t\tif err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err := db.Close(); err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\t// truncate at a random point in the file\n\t\t\t\tf, err := os.OpenFile(\"data.db\", os.O_RDWR, 0666)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\tdefer f.Close()\n\t\t\t\tsz, err := f.Seek(0, 2)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t\tn := sz/2 + int64(rand.Intn(int(sz/2)))\n\t\t\t\terr = f.Truncate(n)\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tN := 500\n\t\t\tlotsa.Ops(N, 16, func(i, t int) {\n\t\t\t\tif i == N/2 && ii&7 == 0 {\n\t\t\t\t\tif err := db.Shrink(); err != nil {\n\t\t\t\t\t\tpanic(err)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\terr := db.Update(func(tx *Tx) error {\n\t\t\t\t\t_, _, err := tx.Set(fmt.Sprintf(\"key:%d\", i), fmt.Sprintf(\"val:%d\", i), &SetOptions{\n\t\t\t\t\t\tExpires: true,\n\t\t\t\t\t\tTTL:     30,\n\t\t\t\t\t})\n\t\t\t\t\treturn err\n\t\t\t\t})\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanic(err)\n\t\t\t\t}\n\t\t\t})\n\t\t}()\n\t\tii++\n\t}\n}\n\nfunc TestEstSize(t *testing.T) {\n\tt.Run(\"estIntSize\", func(t *testing.T) {\n\t\tassert.Assert(estIntSize(0) == 1)\n\t\tassert.Assert(estIntSize(1) == 1)\n\t\tassert.Assert(estIntSize(9) == 1)\n\t\tassert.Assert(estIntSize(10) == 2)\n\t\tassert.Assert(estIntSize(11) == 2)\n\t\tassert.Assert(estIntSize(19) == 2)\n\t\tassert.Assert(estIntSize(20) == 2)\n\t\tassert.Assert(estIntSize(113) == 3)\n\t\tassert.Assert(estIntSize(3822) == 4)\n\t\tassert.Assert(estIntSize(-1) == 2)\n\t\tassert.Assert(estIntSize(-12) == 3)\n\t\tassert.Assert(estIntSize(-124) == 4)\n\t})\n}\n\nfunc TestWrappedError(t *testing.T) {\n\tdefer func() {\n\t\tif err, ok := recover().(error); ok {\n\t\t\tif strings.HasPrefix(err.Error(), \"buntdb: \") {\n\t\t\t\terr := errors.Unwrap(err)\n\t\t\t\tif err.Error() != \"my fake error\" {\n\t\t\t\t\tt.Fatal(\"!\")\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\tpanicErr(errors.New(\"my fake error\"))\n}\n\nfunc TestIssue112(t *testing.T) {\n\tdefer os.RemoveAll(\"data.db\")\n\tdb, err := Open(\"data.db\")\n\tif err != nil {\n\t\tpanicErr(err)\n\t}\n\terr = db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"key:112\", \"value:112-old\", nil)\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tpanicErr(err)\n\t}\n\terr = db.Update(func(tx *Tx) error {\n\t\t_, _, err := tx.Set(\"key:112\", \"value:112\", &SetOptions{Expires: true, TTL: time.Second})\n\t\treturn err\n\t})\n\tif err != nil {\n\t\tpanicErr(err)\n\t}\n\tdb.Close()\n\ttime.Sleep(time.Second)\n\tdb, err = Open(\"data.db\")\n\tif err != nil {\n\t\tpanicErr(err)\n\t}\n\terr = db.View(func(tx *Tx) error {\n\t\t_, err := tx.Get(\"key:112\")\n\t\treturn err\n\t})\n\tassert.Assert(err == ErrNotFound)\n\tdb.View(func(tx *Tx) error {\n\t\terr := tx.Ascend(\"\", func(key, value string) bool {\n\t\t\tt.Fatalf(\"key: %s, value: %s\\n\", key, value)\n\t\t\treturn true\n\t\t})\n\t\treturn err\n\t})\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.38671875,
          "content": "module github.com/tidwall/buntdb\n\ngo 1.18\n\nrequire (\n\tgithub.com/tidwall/assert v0.1.0\n\tgithub.com/tidwall/btree v1.4.2\n\tgithub.com/tidwall/gjson v1.14.3\n\tgithub.com/tidwall/grect v0.1.4\n\tgithub.com/tidwall/lotsa v1.0.2\n\tgithub.com/tidwall/match v1.1.1\n\tgithub.com/tidwall/rtred v0.1.2\n)\n\nrequire (\n\tgithub.com/tidwall/pretty v1.2.0 // indirect\n\tgithub.com/tidwall/tinyqueue v0.1.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.5673828125,
          "content": "github.com/tidwall/assert v0.1.0 h1:aWcKyRBUAdLoVebxo95N7+YZVTFF/ASTr7BN4sLP6XI=\ngithub.com/tidwall/assert v0.1.0/go.mod h1:QLYtGyeqse53vuELQheYl9dngGCJQ+mTtlxcktb+Kj8=\ngithub.com/tidwall/btree v1.4.2 h1:PpkaieETJMUxYNADsjgtNRcERX7mGc/GP2zp/r5FM3g=\ngithub.com/tidwall/btree v1.4.2/go.mod h1:LGm8L/DZjPLmeWGjv5kFrY8dL4uVhMmzmmLYmsObdKE=\ngithub.com/tidwall/gjson v1.12.1/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=\ngithub.com/tidwall/gjson v1.14.3 h1:9jvXn7olKEHU1S9vwoMGliaT8jq1vJ7IH/n9zD9Dnlw=\ngithub.com/tidwall/gjson v1.14.3/go.mod h1:/wbyibRr2FHMks5tjHJ5F8dMZh3AcwJEMf5vlfC0lxk=\ngithub.com/tidwall/grect v0.1.4 h1:dA3oIgNgWdSspFzn1kS4S/RDpZFLrIxAZOdJKjYapOg=\ngithub.com/tidwall/grect v0.1.4/go.mod h1:9FBsaYRaR0Tcy4UwefBX/UDcDcDy9V5jUcxHzv2jd5Q=\ngithub.com/tidwall/lotsa v1.0.2 h1:dNVBH5MErdaQ/xd9s769R31/n2dXavsQ0Yf4TMEHHw8=\ngithub.com/tidwall/lotsa v1.0.2/go.mod h1:X6NiU+4yHA3fE3Puvpnn1XMDrFZrE9JO2/w+UMuqgR8=\ngithub.com/tidwall/match v1.1.1 h1:+Ho715JplO36QYgwN9PGYNhgZvoUSc9X2c80KVTi+GA=\ngithub.com/tidwall/match v1.1.1/go.mod h1:eRSPERbgtNPcGhD8UCthc6PmLEQXEWd3PRB5JTxsfmM=\ngithub.com/tidwall/pretty v1.2.0 h1:RWIZEg2iJ8/g6fDDYzMpobmaoGh5OLl4AXtGUGPcqCs=\ngithub.com/tidwall/pretty v1.2.0/go.mod h1:ITEVvHYasfjBbM0u2Pg8T2nJnzm8xPwvNhhsoaGGjNU=\ngithub.com/tidwall/rtred v0.1.2 h1:exmoQtOLvDoO8ud++6LwVsAMTu0KPzLTUrMln8u1yu8=\ngithub.com/tidwall/rtred v0.1.2/go.mod h1:hd69WNXQ5RP9vHd7dqekAz+RIdtfBogmglkZSRxCHFQ=\ngithub.com/tidwall/tinyqueue v0.1.1 h1:SpNEvEggbpyN5DIReaJ2/1ndroY8iyEGxPYxoSaymYE=\ngithub.com/tidwall/tinyqueue v0.1.1/go.mod h1:O/QNHwrnjqr6IHItYrzoHAKYhBkLI67Q096fQP5zMYw=\n"
        },
        {
          "name": "logo.png",
          "type": "blob",
          "size": 93.4892578125,
          "content": null
        }
      ]
    }
  ]
}