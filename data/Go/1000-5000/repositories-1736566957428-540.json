{
  "metadata": {
    "timestamp": 1736566957428,
    "page": 540,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjU0MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "nfnt/resize",
      "stars": 3024,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".travis.yml",
          "type": "blob",
          "size": 0.0576171875,
          "content": "language: go\n\ngo:\n  - \"1.x\"\n  - \"1.1\"\n  - \"1.4\"\n  - \"1.10\"\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 0.73828125,
          "content": "Copyright (c) 2012, Jan Schlicht <jan.schlicht@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 4.7763671875,
          "content": "# This package is no longer being updated! Please look for alternatives if that bothers you.\n\nResize\n======\n\nImage resizing for the [Go programming language](http://golang.org) with common interpolation methods.\n\n[![Build Status](https://travis-ci.org/nfnt/resize.svg)](https://travis-ci.org/nfnt/resize)\n\nInstallation\n------------\n\n```bash\n$ go get github.com/nfnt/resize\n```\n\nIt's that easy!\n\nUsage\n-----\n\nThis package needs at least Go 1.1. Import package with\n\n```go\nimport \"github.com/nfnt/resize\"\n```\n\nThe resize package provides 2 functions:\n\n* `resize.Resize` creates a scaled image with new dimensions (`width`, `height`) using the interpolation function `interp`.\n  If either `width` or `height` is set to 0, it will be set to an aspect ratio preserving value.\n* `resize.Thumbnail` downscales an image preserving its aspect ratio to the maximum dimensions (`maxWidth`, `maxHeight`).\n  It will return the original image if original sizes are smaller than the provided dimensions.\n\n```go\nresize.Resize(width, height uint, img image.Image, interp resize.InterpolationFunction) image.Image\nresize.Thumbnail(maxWidth, maxHeight uint, img image.Image, interp resize.InterpolationFunction) image.Image\n```\n\nThe provided interpolation functions are (from fast to slow execution time)\n\n- `NearestNeighbor`: [Nearest-neighbor interpolation](http://en.wikipedia.org/wiki/Nearest-neighbor_interpolation)\n- `Bilinear`: [Bilinear interpolation](http://en.wikipedia.org/wiki/Bilinear_interpolation)\n- `Bicubic`: [Bicubic interpolation](http://en.wikipedia.org/wiki/Bicubic_interpolation)\n- `MitchellNetravali`: [Mitchell-Netravali interpolation](http://dl.acm.org/citation.cfm?id=378514)\n- `Lanczos2`: [Lanczos resampling](http://en.wikipedia.org/wiki/Lanczos_resampling) with a=2\n- `Lanczos3`: [Lanczos resampling](http://en.wikipedia.org/wiki/Lanczos_resampling) with a=3\n\nWhich of these methods gives the best results depends on your use case.\n\nSample usage:\n\n```go\npackage main\n\nimport (\n\t\"github.com/nfnt/resize\"\n\t\"image/jpeg\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\t// open \"test.jpg\"\n\tfile, err := os.Open(\"test.jpg\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// decode jpeg into image.Image\n\timg, err := jpeg.Decode(file)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfile.Close()\n\n\t// resize to width 1000 using Lanczos resampling\n\t// and preserve aspect ratio\n\tm := resize.Resize(1000, 0, img, resize.Lanczos3)\n\n\tout, err := os.Create(\"test_resized.jpg\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer out.Close()\n\n\t// write new image to file\n\tjpeg.Encode(out, m, nil)\n}\n```\n\nCaveats\n-------\n\n* Optimized access routines are used for `image.RGBA`, `image.NRGBA`, `image.RGBA64`, `image.NRGBA64`, `image.YCbCr`, `image.Gray`, and `image.Gray16` types. All other image types are accessed in a generic way that will result in slow processing speed.\n* JPEG images are stored in `image.YCbCr`. This image format stores data in a way that will decrease processing speed. A resize may be up to 2 times slower than with `image.RGBA`. \n\n\nDownsizing Samples\n-------\n\nDownsizing is not as simple as it might look like. Images have to be filtered before they are scaled down, otherwise aliasing might occur.\nFiltering is highly subjective: Applying too much will blur the whole image, too little will make aliasing become apparent.\nResize tries to provide sane defaults that should suffice in most cases.\n\n### Artificial sample\n\nOriginal image\n![Rings](http://nfnt.github.com/img/rings_lg_orig.png)\n\n<table>\n<tr>\n<th><img src=\"http://nfnt.github.com/img/rings_300_NearestNeighbor.png\" /><br>Nearest-Neighbor</th>\n<th><img src=\"http://nfnt.github.com/img/rings_300_Bilinear.png\" /><br>Bilinear</th>\n</tr>\n<tr>\n<th><img src=\"http://nfnt.github.com/img/rings_300_Bicubic.png\" /><br>Bicubic</th>\n<th><img src=\"http://nfnt.github.com/img/rings_300_MitchellNetravali.png\" /><br>Mitchell-Netravali</th>\n</tr>\n<tr>\n<th><img src=\"http://nfnt.github.com/img/rings_300_Lanczos2.png\" /><br>Lanczos2</th>\n<th><img src=\"http://nfnt.github.com/img/rings_300_Lanczos3.png\" /><br>Lanczos3</th>\n</tr>\n</table>\n\n### Real-Life sample\n\nOriginal image  \n![Original](http://nfnt.github.com/img/IMG_3694_720.jpg)\n\n<table>\n<tr>\n<th><img src=\"http://nfnt.github.com/img/IMG_3694_300_NearestNeighbor.png\" /><br>Nearest-Neighbor</th>\n<th><img src=\"http://nfnt.github.com/img/IMG_3694_300_Bilinear.png\" /><br>Bilinear</th>\n</tr>\n<tr>\n<th><img src=\"http://nfnt.github.com/img/IMG_3694_300_Bicubic.png\" /><br>Bicubic</th>\n<th><img src=\"http://nfnt.github.com/img/IMG_3694_300_MitchellNetravali.png\" /><br>Mitchell-Netravali</th>\n</tr>\n<tr>\n<th><img src=\"http://nfnt.github.com/img/IMG_3694_300_Lanczos2.png\" /><br>Lanczos2</th>\n<th><img src=\"http://nfnt.github.com/img/IMG_3694_300_Lanczos3.png\" /><br>Lanczos3</th>\n</tr>\n</table>\n\n\nLicense\n-------\n\nCopyright (c) 2012 Jan Schlicht <janschlicht@gmail.com>\nResize is released under a MIT style license.\n"
        },
        {
          "name": "converter.go",
          "type": "blob",
          "size": 11.603515625,
          "content": "/*\nCopyright (c) 2012, Jan Schlicht <jan.schlicht@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport \"image\"\n\n// Keep value in [0,255] range.\nfunc clampUint8(in int32) uint8 {\n\t// casting a negative int to an uint will result in an overflown\n\t// large uint. this behavior will be exploited here and in other functions\n\t// to achieve a higher performance.\n\tif uint32(in) < 256 {\n\t\treturn uint8(in)\n\t}\n\tif in > 255 {\n\t\treturn 255\n\t}\n\treturn 0\n}\n\n// Keep value in [0,65535] range.\nfunc clampUint16(in int64) uint16 {\n\tif uint64(in) < 65536 {\n\t\treturn uint16(in)\n\t}\n\tif in > 65535 {\n\t\treturn 65535\n\t}\n\treturn 0\n}\n\nfunc resizeGeneric(in image.Image, out *image.RGBA64, scale float64, coeffs []int32, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]int64\n\t\t\tvar sum int64\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase xi < 0:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = maxX\n\t\t\t\t\t}\n\n\t\t\t\t\tr, g, b, a := in.At(xi+in.Bounds().Min.X, x+in.Bounds().Min.Y).RGBA()\n\n\t\t\t\t\trgba[0] += int64(coeff) * int64(r)\n\t\t\t\t\trgba[1] += int64(coeff) * int64(g)\n\t\t\t\t\trgba[2] += int64(coeff) * int64(b)\n\t\t\t\t\trgba[3] += int64(coeff) * int64(a)\n\t\t\t\t\tsum += int64(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*8\n\n\t\t\tvalue := clampUint16(rgba[0] / sum)\n\t\t\tout.Pix[offset+0] = uint8(value >> 8)\n\t\t\tout.Pix[offset+1] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[1] / sum)\n\t\t\tout.Pix[offset+2] = uint8(value >> 8)\n\t\t\tout.Pix[offset+3] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[2] / sum)\n\t\t\tout.Pix[offset+4] = uint8(value >> 8)\n\t\t\tout.Pix[offset+5] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[3] / sum)\n\t\t\tout.Pix[offset+6] = uint8(value >> 8)\n\t\t\tout.Pix[offset+7] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc resizeRGBA(in *image.RGBA, out *image.RGBA, scale float64, coeffs []int16, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]int32\n\t\t\tvar sum int32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 4\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 4 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\n\t\t\t\t\trgba[0] += int32(coeff) * int32(row[xi+0])\n\t\t\t\t\trgba[1] += int32(coeff) * int32(row[xi+1])\n\t\t\t\t\trgba[2] += int32(coeff) * int32(row[xi+2])\n\t\t\t\t\trgba[3] += int32(coeff) * int32(row[xi+3])\n\t\t\t\t\tsum += int32(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*4\n\n\t\t\tout.Pix[xo+0] = clampUint8(rgba[0] / sum)\n\t\t\tout.Pix[xo+1] = clampUint8(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = clampUint8(rgba[2] / sum)\n\t\t\tout.Pix[xo+3] = clampUint8(rgba[3] / sum)\n\t\t}\n\t}\n}\n\nfunc resizeNRGBA(in *image.NRGBA, out *image.RGBA, scale float64, coeffs []int16, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]int32\n\t\t\tvar sum int32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 4\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 4 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\n\t\t\t\t\t// Forward alpha-premultiplication\n\t\t\t\t\ta := int32(row[xi+3])\n\t\t\t\t\tr := int32(row[xi+0]) * a\n\t\t\t\t\tr /= 0xff\n\t\t\t\t\tg := int32(row[xi+1]) * a\n\t\t\t\t\tg /= 0xff\n\t\t\t\t\tb := int32(row[xi+2]) * a\n\t\t\t\t\tb /= 0xff\n\n\t\t\t\t\trgba[0] += int32(coeff) * r\n\t\t\t\t\trgba[1] += int32(coeff) * g\n\t\t\t\t\trgba[2] += int32(coeff) * b\n\t\t\t\t\trgba[3] += int32(coeff) * a\n\t\t\t\t\tsum += int32(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*4\n\n\t\t\tout.Pix[xo+0] = clampUint8(rgba[0] / sum)\n\t\t\tout.Pix[xo+1] = clampUint8(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = clampUint8(rgba[2] / sum)\n\t\t\tout.Pix[xo+3] = clampUint8(rgba[3] / sum)\n\t\t}\n\t}\n}\n\nfunc resizeRGBA64(in *image.RGBA64, out *image.RGBA64, scale float64, coeffs []int32, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]int64\n\t\t\tvar sum int64\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 8\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 8 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\n\t\t\t\t\trgba[0] += int64(coeff) * (int64(row[xi+0])<<8 | int64(row[xi+1]))\n\t\t\t\t\trgba[1] += int64(coeff) * (int64(row[xi+2])<<8 | int64(row[xi+3]))\n\t\t\t\t\trgba[2] += int64(coeff) * (int64(row[xi+4])<<8 | int64(row[xi+5]))\n\t\t\t\t\trgba[3] += int64(coeff) * (int64(row[xi+6])<<8 | int64(row[xi+7]))\n\t\t\t\t\tsum += int64(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*8\n\n\t\t\tvalue := clampUint16(rgba[0] / sum)\n\t\t\tout.Pix[xo+0] = uint8(value >> 8)\n\t\t\tout.Pix[xo+1] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = uint8(value >> 8)\n\t\t\tout.Pix[xo+3] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[2] / sum)\n\t\t\tout.Pix[xo+4] = uint8(value >> 8)\n\t\t\tout.Pix[xo+5] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[3] / sum)\n\t\t\tout.Pix[xo+6] = uint8(value >> 8)\n\t\t\tout.Pix[xo+7] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc resizeNRGBA64(in *image.NRGBA64, out *image.RGBA64, scale float64, coeffs []int32, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]int64\n\t\t\tvar sum int64\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 8\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 8 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\n\t\t\t\t\t// Forward alpha-premultiplication\n\t\t\t\t\ta := int64(uint16(row[xi+6])<<8 | uint16(row[xi+7]))\n\t\t\t\t\tr := int64(uint16(row[xi+0])<<8|uint16(row[xi+1])) * a\n\t\t\t\t\tr /= 0xffff\n\t\t\t\t\tg := int64(uint16(row[xi+2])<<8|uint16(row[xi+3])) * a\n\t\t\t\t\tg /= 0xffff\n\t\t\t\t\tb := int64(uint16(row[xi+4])<<8|uint16(row[xi+5])) * a\n\t\t\t\t\tb /= 0xffff\n\n\t\t\t\t\trgba[0] += int64(coeff) * r\n\t\t\t\t\trgba[1] += int64(coeff) * g\n\t\t\t\t\trgba[2] += int64(coeff) * b\n\t\t\t\t\trgba[3] += int64(coeff) * a\n\t\t\t\t\tsum += int64(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*8\n\n\t\t\tvalue := clampUint16(rgba[0] / sum)\n\t\t\tout.Pix[xo+0] = uint8(value >> 8)\n\t\t\tout.Pix[xo+1] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = uint8(value >> 8)\n\t\t\tout.Pix[xo+3] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[2] / sum)\n\t\t\tout.Pix[xo+4] = uint8(value >> 8)\n\t\t\tout.Pix[xo+5] = uint8(value)\n\t\t\tvalue = clampUint16(rgba[3] / sum)\n\t\t\tout.Pix[xo+6] = uint8(value >> 8)\n\t\t\tout.Pix[xo+7] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc resizeGray(in *image.Gray, out *image.Gray, scale float64, coeffs []int16, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[(x-newBounds.Min.X)*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar gray int32\n\t\t\tvar sum int32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase xi < 0:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = maxX\n\t\t\t\t\t}\n\t\t\t\t\tgray += int32(coeff) * int32(row[xi])\n\t\t\t\t\tsum += int32(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset := (y-newBounds.Min.Y)*out.Stride + (x - newBounds.Min.X)\n\t\t\tout.Pix[offset] = clampUint8(gray / sum)\n\t\t}\n\t}\n}\n\nfunc resizeGray16(in *image.Gray16, out *image.Gray16, scale float64, coeffs []int32, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar gray int64\n\t\t\tvar sum int64\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 2\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 2 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\tgray += int64(coeff) * int64(uint16(row[xi+0])<<8|uint16(row[xi+1]))\n\t\t\t\t\tsum += int64(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*2\n\t\t\tvalue := clampUint16(gray / sum)\n\t\t\tout.Pix[offset+0] = uint8(value >> 8)\n\t\t\tout.Pix[offset+1] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc resizeYCbCr(in *ycc, out *ycc, scale float64, coeffs []int16, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar p [3]int32\n\t\t\tvar sum int32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tcoeff := coeffs[ci+i]\n\t\t\t\tif coeff != 0 {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 3\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 3 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\tp[0] += int32(coeff) * int32(row[xi+0])\n\t\t\t\t\tp[1] += int32(coeff) * int32(row[xi+1])\n\t\t\t\t\tp[2] += int32(coeff) * int32(row[xi+2])\n\t\t\t\t\tsum += int32(coeff)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*3\n\t\t\tout.Pix[xo+0] = clampUint8(p[0] / sum)\n\t\t\tout.Pix[xo+1] = clampUint8(p[1] / sum)\n\t\t\tout.Pix[xo+2] = clampUint8(p[2] / sum)\n\t\t}\n\t}\n}\n\nfunc nearestYCbCr(in *ycc, out *ycc, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar p [3]float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 3\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 3 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\tp[0] += float32(row[xi+0])\n\t\t\t\t\tp[1] += float32(row[xi+1])\n\t\t\t\t\tp[2] += float32(row[xi+2])\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*3\n\t\t\tout.Pix[xo+0] = floatToUint8(p[0] / sum)\n\t\t\tout.Pix[xo+1] = floatToUint8(p[1] / sum)\n\t\t\tout.Pix[xo+2] = floatToUint8(p[2] / sum)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "converter_test.go",
          "type": "blob",
          "size": 0.6064453125,
          "content": "package resize\n\nimport (\n\t\"testing\"\n)\n\nfunc Test_ClampUint8(t *testing.T) {\n\tvar testData = []struct {\n\t\tin       int32\n\t\texpected uint8\n\t}{\n\t\t{0, 0},\n\t\t{255, 255},\n\t\t{128, 128},\n\t\t{-2, 0},\n\t\t{256, 255},\n\t}\n\tfor _, test := range testData {\n\t\tactual := clampUint8(test.in)\n\t\tif actual != test.expected {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc Test_ClampUint16(t *testing.T) {\n\tvar testData = []struct {\n\t\tin       int64\n\t\texpected uint16\n\t}{\n\t\t{0, 0},\n\t\t{65535, 65535},\n\t\t{128, 128},\n\t\t{-2, 0},\n\t\t{65536, 65535},\n\t}\n\tfor _, test := range testData {\n\t\tactual := clampUint16(test.in)\n\t\tif actual != test.expected {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "filters.go",
          "type": "blob",
          "size": 3.693359375,
          "content": "/*\nCopyright (c) 2012, Jan Schlicht <jan.schlicht@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport (\n\t\"math\"\n)\n\nfunc nearest(in float64) float64 {\n\tif in >= -0.5 && in < 0.5 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\nfunc linear(in float64) float64 {\n\tin = math.Abs(in)\n\tif in <= 1 {\n\t\treturn 1 - in\n\t}\n\treturn 0\n}\n\nfunc cubic(in float64) float64 {\n\tin = math.Abs(in)\n\tif in <= 1 {\n\t\treturn in*in*(1.5*in-2.5) + 1.0\n\t}\n\tif in <= 2 {\n\t\treturn in*(in*(2.5-0.5*in)-4.0) + 2.0\n\t}\n\treturn 0\n}\n\nfunc mitchellnetravali(in float64) float64 {\n\tin = math.Abs(in)\n\tif in <= 1 {\n\t\treturn (7.0*in*in*in - 12.0*in*in + 5.33333333333) * 0.16666666666\n\t}\n\tif in <= 2 {\n\t\treturn (-2.33333333333*in*in*in + 12.0*in*in - 20.0*in + 10.6666666667) * 0.16666666666\n\t}\n\treturn 0\n}\n\nfunc sinc(x float64) float64 {\n\tx = math.Abs(x) * math.Pi\n\tif x >= 1.220703e-4 {\n\t\treturn math.Sin(x) / x\n\t}\n\treturn 1\n}\n\nfunc lanczos2(in float64) float64 {\n\tif in > -2 && in < 2 {\n\t\treturn sinc(in) * sinc(in*0.5)\n\t}\n\treturn 0\n}\n\nfunc lanczos3(in float64) float64 {\n\tif in > -3 && in < 3 {\n\t\treturn sinc(in) * sinc(in*0.3333333333333333)\n\t}\n\treturn 0\n}\n\n// range [-256,256]\nfunc createWeights8(dy, filterLength int, blur, scale float64, kernel func(float64) float64) ([]int16, []int, int) {\n\tfilterLength = filterLength * int(math.Max(math.Ceil(blur*scale), 1))\n\tfilterFactor := math.Min(1./(blur*scale), 1)\n\n\tcoeffs := make([]int16, dy*filterLength)\n\tstart := make([]int, dy)\n\tfor y := 0; y < dy; y++ {\n\t\tinterpX := scale*(float64(y)+0.5) - 0.5\n\t\tstart[y] = int(interpX) - filterLength/2 + 1\n\t\tinterpX -= float64(start[y])\n\t\tfor i := 0; i < filterLength; i++ {\n\t\t\tin := (interpX - float64(i)) * filterFactor\n\t\t\tcoeffs[y*filterLength+i] = int16(kernel(in) * 256)\n\t\t}\n\t}\n\n\treturn coeffs, start, filterLength\n}\n\n// range [-65536,65536]\nfunc createWeights16(dy, filterLength int, blur, scale float64, kernel func(float64) float64) ([]int32, []int, int) {\n\tfilterLength = filterLength * int(math.Max(math.Ceil(blur*scale), 1))\n\tfilterFactor := math.Min(1./(blur*scale), 1)\n\n\tcoeffs := make([]int32, dy*filterLength)\n\tstart := make([]int, dy)\n\tfor y := 0; y < dy; y++ {\n\t\tinterpX := scale*(float64(y)+0.5) - 0.5\n\t\tstart[y] = int(interpX) - filterLength/2 + 1\n\t\tinterpX -= float64(start[y])\n\t\tfor i := 0; i < filterLength; i++ {\n\t\t\tin := (interpX - float64(i)) * filterFactor\n\t\t\tcoeffs[y*filterLength+i] = int32(kernel(in) * 65536)\n\t\t}\n\t}\n\n\treturn coeffs, start, filterLength\n}\n\nfunc createWeightsNearest(dy, filterLength int, blur, scale float64) ([]bool, []int, int) {\n\tfilterLength = filterLength * int(math.Max(math.Ceil(blur*scale), 1))\n\tfilterFactor := math.Min(1./(blur*scale), 1)\n\n\tcoeffs := make([]bool, dy*filterLength)\n\tstart := make([]int, dy)\n\tfor y := 0; y < dy; y++ {\n\t\tinterpX := scale*(float64(y)+0.5) - 0.5\n\t\tstart[y] = int(interpX) - filterLength/2 + 1\n\t\tinterpX -= float64(start[y])\n\t\tfor i := 0; i < filterLength; i++ {\n\t\t\tin := (interpX - float64(i)) * filterFactor\n\t\t\tif in >= -0.5 && in < 0.5 {\n\t\t\t\tcoeffs[y*filterLength+i] = true\n\t\t\t} else {\n\t\t\t\tcoeffs[y*filterLength+i] = false\n\t\t\t}\n\t\t}\n\t}\n\n\treturn coeffs, start, filterLength\n}\n"
        },
        {
          "name": "nearest.go",
          "type": "blob",
          "size": 8.7470703125,
          "content": "/*\nCopyright (c) 2014, Charlie Vieth <charlie.vieth@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport \"image\"\n\nfunc floatToUint8(x float32) uint8 {\n\t// Nearest-neighbor values are always\n\t// positive no need to check lower-bound.\n\tif x > 0xfe {\n\t\treturn 0xff\n\t}\n\treturn uint8(x)\n}\n\nfunc floatToUint16(x float32) uint16 {\n\tif x > 0xfffe {\n\t\treturn 0xffff\n\t}\n\treturn uint16(x)\n}\n\nfunc nearestGeneric(in image.Image, out *image.RGBA64, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase xi < 0:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = maxX\n\t\t\t\t\t}\n\t\t\t\t\tr, g, b, a := in.At(xi+in.Bounds().Min.X, x+in.Bounds().Min.Y).RGBA()\n\t\t\t\t\trgba[0] += float32(r)\n\t\t\t\t\trgba[1] += float32(g)\n\t\t\t\t\trgba[2] += float32(b)\n\t\t\t\t\trgba[3] += float32(a)\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*8\n\t\t\tvalue := floatToUint16(rgba[0] / sum)\n\t\t\tout.Pix[offset+0] = uint8(value >> 8)\n\t\t\tout.Pix[offset+1] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[1] / sum)\n\t\t\tout.Pix[offset+2] = uint8(value >> 8)\n\t\t\tout.Pix[offset+3] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[2] / sum)\n\t\t\tout.Pix[offset+4] = uint8(value >> 8)\n\t\t\tout.Pix[offset+5] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[3] / sum)\n\t\t\tout.Pix[offset+6] = uint8(value >> 8)\n\t\t\tout.Pix[offset+7] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc nearestRGBA(in *image.RGBA, out *image.RGBA, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 4\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 4 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\trgba[0] += float32(row[xi+0])\n\t\t\t\t\trgba[1] += float32(row[xi+1])\n\t\t\t\t\trgba[2] += float32(row[xi+2])\n\t\t\t\t\trgba[3] += float32(row[xi+3])\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*4\n\t\t\tout.Pix[xo+0] = floatToUint8(rgba[0] / sum)\n\t\t\tout.Pix[xo+1] = floatToUint8(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = floatToUint8(rgba[2] / sum)\n\t\t\tout.Pix[xo+3] = floatToUint8(rgba[3] / sum)\n\t\t}\n\t}\n}\n\nfunc nearestNRGBA(in *image.NRGBA, out *image.NRGBA, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 4\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 4 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\trgba[0] += float32(row[xi+0])\n\t\t\t\t\trgba[1] += float32(row[xi+1])\n\t\t\t\t\trgba[2] += float32(row[xi+2])\n\t\t\t\t\trgba[3] += float32(row[xi+3])\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*4\n\t\t\tout.Pix[xo+0] = floatToUint8(rgba[0] / sum)\n\t\t\tout.Pix[xo+1] = floatToUint8(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = floatToUint8(rgba[2] / sum)\n\t\t\tout.Pix[xo+3] = floatToUint8(rgba[3] / sum)\n\t\t}\n\t}\n}\n\nfunc nearestRGBA64(in *image.RGBA64, out *image.RGBA64, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 8\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 8 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\trgba[0] += float32(uint16(row[xi+0])<<8 | uint16(row[xi+1]))\n\t\t\t\t\trgba[1] += float32(uint16(row[xi+2])<<8 | uint16(row[xi+3]))\n\t\t\t\t\trgba[2] += float32(uint16(row[xi+4])<<8 | uint16(row[xi+5]))\n\t\t\t\t\trgba[3] += float32(uint16(row[xi+6])<<8 | uint16(row[xi+7]))\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*8\n\t\t\tvalue := floatToUint16(rgba[0] / sum)\n\t\t\tout.Pix[xo+0] = uint8(value >> 8)\n\t\t\tout.Pix[xo+1] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = uint8(value >> 8)\n\t\t\tout.Pix[xo+3] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[2] / sum)\n\t\t\tout.Pix[xo+4] = uint8(value >> 8)\n\t\t\tout.Pix[xo+5] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[3] / sum)\n\t\t\tout.Pix[xo+6] = uint8(value >> 8)\n\t\t\tout.Pix[xo+7] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc nearestNRGBA64(in *image.NRGBA64, out *image.NRGBA64, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar rgba [4]float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 8\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 8 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\trgba[0] += float32(uint16(row[xi+0])<<8 | uint16(row[xi+1]))\n\t\t\t\t\trgba[1] += float32(uint16(row[xi+2])<<8 | uint16(row[xi+3]))\n\t\t\t\t\trgba[2] += float32(uint16(row[xi+4])<<8 | uint16(row[xi+5]))\n\t\t\t\t\trgba[3] += float32(uint16(row[xi+6])<<8 | uint16(row[xi+7]))\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\txo := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*8\n\t\t\tvalue := floatToUint16(rgba[0] / sum)\n\t\t\tout.Pix[xo+0] = uint8(value >> 8)\n\t\t\tout.Pix[xo+1] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[1] / sum)\n\t\t\tout.Pix[xo+2] = uint8(value >> 8)\n\t\t\tout.Pix[xo+3] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[2] / sum)\n\t\t\tout.Pix[xo+4] = uint8(value >> 8)\n\t\t\tout.Pix[xo+5] = uint8(value)\n\t\t\tvalue = floatToUint16(rgba[3] / sum)\n\t\t\tout.Pix[xo+6] = uint8(value >> 8)\n\t\t\tout.Pix[xo+7] = uint8(value)\n\t\t}\n\t}\n}\n\nfunc nearestGray(in *image.Gray, out *image.Gray, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar gray float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase xi < 0:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = maxX\n\t\t\t\t\t}\n\t\t\t\t\tgray += float32(row[xi])\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset := (y-newBounds.Min.Y)*out.Stride + (x - newBounds.Min.X)\n\t\t\tout.Pix[offset] = floatToUint8(gray / sum)\n\t\t}\n\t}\n}\n\nfunc nearestGray16(in *image.Gray16, out *image.Gray16, scale float64, coeffs []bool, offset []int, filterLength int) {\n\tnewBounds := out.Bounds()\n\tmaxX := in.Bounds().Dx() - 1\n\n\tfor x := newBounds.Min.X; x < newBounds.Max.X; x++ {\n\t\trow := in.Pix[x*in.Stride:]\n\t\tfor y := newBounds.Min.Y; y < newBounds.Max.Y; y++ {\n\t\t\tvar gray float32\n\t\t\tvar sum float32\n\t\t\tstart := offset[y]\n\t\t\tci := y * filterLength\n\t\t\tfor i := 0; i < filterLength; i++ {\n\t\t\t\tif coeffs[ci+i] {\n\t\t\t\t\txi := start + i\n\t\t\t\t\tswitch {\n\t\t\t\t\tcase uint(xi) < uint(maxX):\n\t\t\t\t\t\txi *= 2\n\t\t\t\t\tcase xi >= maxX:\n\t\t\t\t\t\txi = 2 * maxX\n\t\t\t\t\tdefault:\n\t\t\t\t\t\txi = 0\n\t\t\t\t\t}\n\t\t\t\t\tgray += float32(uint16(row[xi+0])<<8 | uint16(row[xi+1]))\n\t\t\t\t\tsum++\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toffset := (y-newBounds.Min.Y)*out.Stride + (x-newBounds.Min.X)*2\n\t\t\tvalue := floatToUint16(gray / sum)\n\t\t\tout.Pix[offset+0] = uint8(value >> 8)\n\t\t\tout.Pix[offset+1] = uint8(value)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "nearest_test.go",
          "type": "blob",
          "size": 1.3583984375,
          "content": "/*\nCopyright (c) 2014, Charlie Vieth <charlie.vieth@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport \"testing\"\n\nfunc Test_FloatToUint8(t *testing.T) {\n\tvar testData = []struct {\n\t\tin       float32\n\t\texpected uint8\n\t}{\n\t\t{0, 0},\n\t\t{255, 255},\n\t\t{128, 128},\n\t\t{1, 1},\n\t\t{256, 255},\n\t}\n\tfor _, test := range testData {\n\t\tactual := floatToUint8(test.in)\n\t\tif actual != test.expected {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n\nfunc Test_FloatToUint16(t *testing.T) {\n\tvar testData = []struct {\n\t\tin       float32\n\t\texpected uint16\n\t}{\n\t\t{0, 0},\n\t\t{65535, 65535},\n\t\t{128, 128},\n\t\t{1, 1},\n\t\t{65536, 65535},\n\t}\n\tfor _, test := range testData {\n\t\tactual := floatToUint16(test.in)\n\t\tif actual != test.expected {\n\t\t\tt.Fail()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "resize.go",
          "type": "blob",
          "size": 19.865234375,
          "content": "/*\nCopyright (c) 2012, Jan Schlicht <jan.schlicht@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\n// Package resize implements various image resizing methods.\n//\n// The package works with the Image interface described in the image package.\n// Various interpolation methods are provided and multiple processors may be\n// utilized in the computations.\n//\n// Example:\n//     imgResized := resize.Resize(1000, 0, imgOld, resize.MitchellNetravali)\npackage resize\n\nimport (\n\t\"image\"\n\t\"runtime\"\n\t\"sync\"\n)\n\n// An InterpolationFunction provides the parameters that describe an\n// interpolation kernel. It returns the number of samples to take\n// and the kernel function to use for sampling.\ntype InterpolationFunction int\n\n// InterpolationFunction constants\nconst (\n\t// Nearest-neighbor interpolation\n\tNearestNeighbor InterpolationFunction = iota\n\t// Bilinear interpolation\n\tBilinear\n\t// Bicubic interpolation (with cubic hermite spline)\n\tBicubic\n\t// Mitchell-Netravali interpolation\n\tMitchellNetravali\n\t// Lanczos interpolation (a=2)\n\tLanczos2\n\t// Lanczos interpolation (a=3)\n\tLanczos3\n)\n\n// kernal, returns an InterpolationFunctions taps and kernel.\nfunc (i InterpolationFunction) kernel() (int, func(float64) float64) {\n\tswitch i {\n\tcase Bilinear:\n\t\treturn 2, linear\n\tcase Bicubic:\n\t\treturn 4, cubic\n\tcase MitchellNetravali:\n\t\treturn 4, mitchellnetravali\n\tcase Lanczos2:\n\t\treturn 4, lanczos2\n\tcase Lanczos3:\n\t\treturn 6, lanczos3\n\tdefault:\n\t\t// Default to NearestNeighbor.\n\t\treturn 2, nearest\n\t}\n}\n\n// values <1 will sharpen the image\nvar blur = 1.0\n\n// Resize scales an image to new width and height using the interpolation function interp.\n// A new image with the given dimensions will be returned.\n// If one of the parameters width or height is set to 0, its size will be calculated so that\n// the aspect ratio is that of the originating image.\n// The resizing algorithm uses channels for parallel computation.\n// If the input image has width or height of 0, it is returned unchanged.\nfunc Resize(width, height uint, img image.Image, interp InterpolationFunction) image.Image {\n\tscaleX, scaleY := calcFactors(width, height, float64(img.Bounds().Dx()), float64(img.Bounds().Dy()))\n\tif width == 0 {\n\t\twidth = uint(0.7 + float64(img.Bounds().Dx())/scaleX)\n\t}\n\tif height == 0 {\n\t\theight = uint(0.7 + float64(img.Bounds().Dy())/scaleY)\n\t}\n\n\t// Trivial case: return input image\n\tif int(width) == img.Bounds().Dx() && int(height) == img.Bounds().Dy() {\n\t\treturn img\n\t}\n\n\t// Input image has no pixels\n\tif img.Bounds().Dx() <= 0 || img.Bounds().Dy() <= 0 {\n\t\treturn img\n\t}\n\n\tif interp == NearestNeighbor {\n\t\treturn resizeNearest(width, height, scaleX, scaleY, img, interp)\n\t}\n\n\ttaps, kernel := interp.kernel()\n\tcpus := runtime.GOMAXPROCS(0)\n\twg := sync.WaitGroup{}\n\n\t// Generic access to image.Image is slow in tight loops.\n\t// The optimal access has to be determined from the concrete image type.\n\tswitch input := img.(type) {\n\tcase *image.RGBA:\n\t\t// 8-bit precision\n\t\ttemp := image.NewRGBA(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights8(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights8(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.NRGBA:\n\t\t// 8-bit precision\n\t\ttemp := image.NewRGBA(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights8(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeNRGBA(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights8(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\n\tcase *image.YCbCr:\n\t\t// 8-bit precision\n\t\t// accessing the YCbCr arrays in a tight loop is slow.\n\t\t// converting the image to ycc increases performance by 2x.\n\t\ttemp := newYCC(image.Rect(0, 0, input.Bounds().Dy(), int(width)), input.SubsampleRatio)\n\t\tresult := newYCC(image.Rect(0, 0, int(width), int(height)), image.YCbCrSubsampleRatio444)\n\n\t\tcoeffs, offset, filterLength := createWeights8(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\tin := imageYCbCrToYCC(input)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*ycc)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeYCbCr(in, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\tcoeffs, offset, filterLength = createWeights8(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*ycc)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeYCbCr(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result.YCbCr()\n\tcase *image.RGBA64:\n\t\t// 16-bit precision\n\t\ttemp := image.NewRGBA64(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA64(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights16(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA64(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights16(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA64(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.NRGBA64:\n\t\t// 16-bit precision\n\t\ttemp := image.NewRGBA64(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA64(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights16(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeNRGBA64(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights16(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA64(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.Gray:\n\t\t// 8-bit precision\n\t\ttemp := image.NewGray(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewGray(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights8(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.Gray)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeGray(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights8(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.Gray)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeGray(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.Gray16:\n\t\t// 16-bit precision\n\t\ttemp := image.NewGray16(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewGray16(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights16(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.Gray16)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeGray16(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights16(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.Gray16)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeGray16(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tdefault:\n\t\t// 16-bit precision\n\t\ttemp := image.NewRGBA64(image.Rect(0, 0, img.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA64(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeights16(temp.Bounds().Dy(), taps, blur, scaleX, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeGeneric(img, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeights16(result.Bounds().Dy(), taps, blur, scaleY, kernel)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tresizeRGBA64(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\t}\n}\n\nfunc resizeNearest(width, height uint, scaleX, scaleY float64, img image.Image, interp InterpolationFunction) image.Image {\n\ttaps, _ := interp.kernel()\n\tcpus := runtime.GOMAXPROCS(0)\n\twg := sync.WaitGroup{}\n\n\tswitch input := img.(type) {\n\tcase *image.RGBA:\n\t\t// 8-bit precision\n\t\ttemp := image.NewRGBA(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestRGBA(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestRGBA(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.NRGBA:\n\t\t// 8-bit precision\n\t\ttemp := image.NewNRGBA(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewNRGBA(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.NRGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestNRGBA(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.NRGBA)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestNRGBA(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.YCbCr:\n\t\t// 8-bit precision\n\t\t// accessing the YCbCr arrays in a tight loop is slow.\n\t\t// converting the image to ycc increases performance by 2x.\n\t\ttemp := newYCC(image.Rect(0, 0, input.Bounds().Dy(), int(width)), input.SubsampleRatio)\n\t\tresult := newYCC(image.Rect(0, 0, int(width), int(height)), image.YCbCrSubsampleRatio444)\n\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\tin := imageYCbCrToYCC(input)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*ycc)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestYCbCr(in, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*ycc)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestYCbCr(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result.YCbCr()\n\tcase *image.RGBA64:\n\t\t// 16-bit precision\n\t\ttemp := image.NewRGBA64(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA64(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestRGBA64(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestRGBA64(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.NRGBA64:\n\t\t// 16-bit precision\n\t\ttemp := image.NewNRGBA64(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewNRGBA64(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.NRGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestNRGBA64(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.NRGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestNRGBA64(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.Gray:\n\t\t// 8-bit precision\n\t\ttemp := image.NewGray(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewGray(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.Gray)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestGray(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.Gray)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestGray(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tcase *image.Gray16:\n\t\t// 16-bit precision\n\t\ttemp := image.NewGray16(image.Rect(0, 0, input.Bounds().Dy(), int(width)))\n\t\tresult := image.NewGray16(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.Gray16)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestGray16(input, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.Gray16)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestGray16(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\tdefault:\n\t\t// 16-bit precision\n\t\ttemp := image.NewRGBA64(image.Rect(0, 0, img.Bounds().Dy(), int(width)))\n\t\tresult := image.NewRGBA64(image.Rect(0, 0, int(width), int(height)))\n\n\t\t// horizontal filter, results in transposed temporary image\n\t\tcoeffs, offset, filterLength := createWeightsNearest(temp.Bounds().Dy(), taps, blur, scaleX)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(temp, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestGeneric(img, slice, scaleX, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\n\t\t// horizontal filter on transposed image, result is not transposed\n\t\tcoeffs, offset, filterLength = createWeightsNearest(result.Bounds().Dy(), taps, blur, scaleY)\n\t\twg.Add(cpus)\n\t\tfor i := 0; i < cpus; i++ {\n\t\t\tslice := makeSlice(result, i, cpus).(*image.RGBA64)\n\t\t\tgo func() {\n\t\t\t\tdefer wg.Done()\n\t\t\t\tnearestRGBA64(temp, slice, scaleY, coeffs, offset, filterLength)\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\treturn result\n\t}\n\n}\n\n// Calculates scaling factors using old and new image dimensions.\nfunc calcFactors(width, height uint, oldWidth, oldHeight float64) (scaleX, scaleY float64) {\n\tif width == 0 {\n\t\tif height == 0 {\n\t\t\tscaleX = 1.0\n\t\t\tscaleY = 1.0\n\t\t} else {\n\t\t\tscaleY = oldHeight / float64(height)\n\t\t\tscaleX = scaleY\n\t\t}\n\t} else {\n\t\tscaleX = oldWidth / float64(width)\n\t\tif height == 0 {\n\t\t\tscaleY = scaleX\n\t\t} else {\n\t\t\tscaleY = oldHeight / float64(height)\n\t\t}\n\t}\n\treturn\n}\n\ntype imageWithSubImage interface {\n\timage.Image\n\tSubImage(image.Rectangle) image.Image\n}\n\nfunc makeSlice(img imageWithSubImage, i, n int) image.Image {\n\treturn img.SubImage(image.Rect(img.Bounds().Min.X, img.Bounds().Min.Y+i*img.Bounds().Dy()/n, img.Bounds().Max.X, img.Bounds().Min.Y+(i+1)*img.Bounds().Dy()/n))\n}\n"
        },
        {
          "name": "resize_test.go",
          "type": "blob",
          "size": 8.568359375,
          "content": "package resize\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nvar img = image.NewGray16(image.Rect(0, 0, 3, 3))\n\nfunc init() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n\timg.Set(1, 1, color.White)\n}\n\nfunc Test_Param1(t *testing.T) {\n\tm := Resize(0, 0, img, NearestNeighbor)\n\tif m.Bounds() != img.Bounds() {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_Param2(t *testing.T) {\n\tm := Resize(100, 0, img, NearestNeighbor)\n\tif m.Bounds() != image.Rect(0, 0, 100, 100) {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_ZeroImg(t *testing.T) {\n\tzeroImg := image.NewGray16(image.Rect(0, 0, 0, 0))\n\n\tm := Resize(0, 0, zeroImg, NearestNeighbor)\n\tif m.Bounds() != zeroImg.Bounds() {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_HalfZeroImg(t *testing.T) {\n\tzeroImg := image.NewGray16(image.Rect(0, 0, 0, 100))\n\n\tm := Resize(0, 1, zeroImg, NearestNeighbor)\n\tif m.Bounds() != zeroImg.Bounds() {\n\t\tt.Fail()\n\t}\n\n\tm = Resize(1, 0, zeroImg, NearestNeighbor)\n\tif m.Bounds() != zeroImg.Bounds() {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_CorrectResize(t *testing.T) {\n\tzeroImg := image.NewGray16(image.Rect(0, 0, 256, 256))\n\n\tm := Resize(60, 0, zeroImg, NearestNeighbor)\n\tif m.Bounds() != image.Rect(0, 0, 60, 60) {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_SameColorWithRGBA(t *testing.T) {\n\timg := image.NewRGBA(image.Rect(0, 0, 20, 20))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\t\timg.SetRGBA(x, y, color.RGBA{0x80, 0x80, 0x80, 0xFF})\n\t\t}\n\t}\n\tout := Resize(10, 10, img, Lanczos3)\n\tfor y := out.Bounds().Min.Y; y < out.Bounds().Max.Y; y++ {\n\t\tfor x := out.Bounds().Min.X; x < out.Bounds().Max.X; x++ {\n\t\t\tcolor := out.At(x, y).(color.RGBA)\n\t\t\tif color.R != 0x80 || color.G != 0x80 || color.B != 0x80 || color.A != 0xFF {\n\t\t\t\tt.Errorf(\"%+v\", color)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_SameColorWithNRGBA(t *testing.T) {\n\timg := image.NewNRGBA(image.Rect(0, 0, 20, 20))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\t\timg.SetNRGBA(x, y, color.NRGBA{0x80, 0x80, 0x80, 0xFF})\n\t\t}\n\t}\n\tout := Resize(10, 10, img, Lanczos3)\n\tfor y := out.Bounds().Min.Y; y < out.Bounds().Max.Y; y++ {\n\t\tfor x := out.Bounds().Min.X; x < out.Bounds().Max.X; x++ {\n\t\t\tcolor := out.At(x, y).(color.RGBA)\n\t\t\tif color.R != 0x80 || color.G != 0x80 || color.B != 0x80 || color.A != 0xFF {\n\t\t\t\tt.Errorf(\"%+v\", color)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_SameColorWithRGBA64(t *testing.T) {\n\timg := image.NewRGBA64(image.Rect(0, 0, 20, 20))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\t\timg.SetRGBA64(x, y, color.RGBA64{0x8000, 0x8000, 0x8000, 0xFFFF})\n\t\t}\n\t}\n\tout := Resize(10, 10, img, Lanczos3)\n\tfor y := out.Bounds().Min.Y; y < out.Bounds().Max.Y; y++ {\n\t\tfor x := out.Bounds().Min.X; x < out.Bounds().Max.X; x++ {\n\t\t\tcolor := out.At(x, y).(color.RGBA64)\n\t\t\tif color.R != 0x8000 || color.G != 0x8000 || color.B != 0x8000 || color.A != 0xFFFF {\n\t\t\t\tt.Errorf(\"%+v\", color)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_SameColorWithNRGBA64(t *testing.T) {\n\timg := image.NewNRGBA64(image.Rect(0, 0, 20, 20))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\t\timg.SetNRGBA64(x, y, color.NRGBA64{0x8000, 0x8000, 0x8000, 0xFFFF})\n\t\t}\n\t}\n\tout := Resize(10, 10, img, Lanczos3)\n\tfor y := out.Bounds().Min.Y; y < out.Bounds().Max.Y; y++ {\n\t\tfor x := out.Bounds().Min.X; x < out.Bounds().Max.X; x++ {\n\t\t\tcolor := out.At(x, y).(color.RGBA64)\n\t\t\tif color.R != 0x8000 || color.G != 0x8000 || color.B != 0x8000 || color.A != 0xFFFF {\n\t\t\t\tt.Errorf(\"%+v\", color)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_SameColorWithGray(t *testing.T) {\n\timg := image.NewGray(image.Rect(0, 0, 20, 20))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\t\timg.SetGray(x, y, color.Gray{0x80})\n\t\t}\n\t}\n\tout := Resize(10, 10, img, Lanczos3)\n\tfor y := out.Bounds().Min.Y; y < out.Bounds().Max.Y; y++ {\n\t\tfor x := out.Bounds().Min.X; x < out.Bounds().Max.X; x++ {\n\t\t\tcolor := out.At(x, y).(color.Gray)\n\t\t\tif color.Y != 0x80 {\n\t\t\t\tt.Errorf(\"%+v\", color)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_SameColorWithGray16(t *testing.T) {\n\timg := image.NewGray16(image.Rect(0, 0, 20, 20))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\tfor x := img.Bounds().Min.X; x < img.Bounds().Max.X; x++ {\n\t\t\timg.SetGray16(x, y, color.Gray16{0x8000})\n\t\t}\n\t}\n\tout := Resize(10, 10, img, Lanczos3)\n\tfor y := out.Bounds().Min.Y; y < out.Bounds().Max.Y; y++ {\n\t\tfor x := out.Bounds().Min.X; x < out.Bounds().Max.X; x++ {\n\t\t\tcolor := out.At(x, y).(color.Gray16)\n\t\t\tif color.Y != 0x8000 {\n\t\t\t\tt.Errorf(\"%+v\", color)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc Test_Bounds(t *testing.T) {\n\timg := image.NewRGBA(image.Rect(20, 10, 200, 99))\n\tout := Resize(80, 80, img, Lanczos2)\n\tout.At(0, 0)\n}\n\nfunc Test_SameSizeReturnsOriginal(t *testing.T) {\n\timg := image.NewRGBA(image.Rect(0, 0, 10, 10))\n\tout := Resize(0, 0, img, Lanczos2)\n\n\tif img != out {\n\t\tt.Fail()\n\t}\n\n\tout = Resize(10, 10, img, Lanczos2)\n\n\tif img != out {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_PixelCoordinates(t *testing.T) {\n\tcheckers := image.NewGray(image.Rect(0, 0, 4, 4))\n\tcheckers.Pix = []uint8{\n\t\t255, 0, 255, 0,\n\t\t0, 255, 0, 255,\n\t\t255, 0, 255, 0,\n\t\t0, 255, 0, 255,\n\t}\n\n\tresized := Resize(12, 12, checkers, NearestNeighbor).(*image.Gray)\n\n\tif resized.Pix[0] != 255 || resized.Pix[1] != 255 || resized.Pix[2] != 255 {\n\t\tt.Fail()\n\t}\n\n\tif resized.Pix[3] != 0 || resized.Pix[4] != 0 || resized.Pix[5] != 0 {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_ResizeWithPremultipliedAlpha(t *testing.T) {\n\timg := image.NewRGBA(image.Rect(0, 0, 1, 4))\n\tfor y := img.Bounds().Min.Y; y < img.Bounds().Max.Y; y++ {\n\t\t// 0x80 = 0.5 * 0xFF.\n\t\timg.SetRGBA(0, y, color.RGBA{0x80, 0x80, 0x80, 0x80})\n\t}\n\n\tout := Resize(1, 2, img, MitchellNetravali)\n\n\toutputColor := out.At(0, 0).(color.RGBA)\n\tif outputColor.R != 0x80 {\n\t\tt.Fail()\n\t}\n}\n\nfunc Test_ResizeWithTranslucentColor(t *testing.T) {\n\timg := image.NewNRGBA(image.Rect(0, 0, 1, 2))\n\n\t// Set the pixel colors to an \"invisible green\" and white.\n\t// After resizing, the green shouldn't be visible.\n\timg.SetNRGBA(0, 0, color.NRGBA{0x00, 0xFF, 0x00, 0x00})\n\timg.SetNRGBA(0, 1, color.NRGBA{0x00, 0x00, 0x00, 0xFF})\n\n\tout := Resize(1, 1, img, Bilinear)\n\n\t_, g, _, _ := out.At(0, 0).RGBA()\n\tif g != 0x00 {\n\t\tt.Errorf(\"%+v\", g)\n\t}\n}\n\nconst (\n\t// Use a small image size for benchmarks. We don't want memory performance\n\t// to affect the benchmark results.\n\tbenchMaxX = 250\n\tbenchMaxY = 250\n\n\t// Resize values near the original size require increase the amount of time\n\t// resize spends converting the image.\n\tbenchWidth  = 200\n\tbenchHeight = 200\n)\n\nfunc benchRGBA(b *testing.B, interp InterpolationFunction) {\n\tm := image.NewRGBA(image.Rect(0, 0, benchMaxX, benchMaxY))\n\t// Initialize m's pixels to create a non-uniform image.\n\tfor y := m.Rect.Min.Y; y < m.Rect.Max.Y; y++ {\n\t\tfor x := m.Rect.Min.X; x < m.Rect.Max.X; x++ {\n\t\t\ti := m.PixOffset(x, y)\n\t\t\tm.Pix[i+0] = uint8(y + 4*x)\n\t\t\tm.Pix[i+1] = uint8(y + 4*x)\n\t\t\tm.Pix[i+2] = uint8(y + 4*x)\n\t\t\tm.Pix[i+3] = uint8(4*y + x)\n\t\t}\n\t}\n\n\tvar out image.Image\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tout = Resize(benchWidth, benchHeight, m, interp)\n\t}\n\tout.At(0, 0)\n}\n\n// The names of some interpolation functions are truncated so that the columns\n// of 'go test -bench' line up.\nfunc Benchmark_Nearest_RGBA(b *testing.B) {\n\tbenchRGBA(b, NearestNeighbor)\n}\n\nfunc Benchmark_Bilinear_RGBA(b *testing.B) {\n\tbenchRGBA(b, Bilinear)\n}\n\nfunc Benchmark_Bicubic_RGBA(b *testing.B) {\n\tbenchRGBA(b, Bicubic)\n}\n\nfunc Benchmark_Mitchell_RGBA(b *testing.B) {\n\tbenchRGBA(b, MitchellNetravali)\n}\n\nfunc Benchmark_Lanczos2_RGBA(b *testing.B) {\n\tbenchRGBA(b, Lanczos2)\n}\n\nfunc Benchmark_Lanczos3_RGBA(b *testing.B) {\n\tbenchRGBA(b, Lanczos3)\n}\n\nfunc benchYCbCr(b *testing.B, interp InterpolationFunction) {\n\tm := image.NewYCbCr(image.Rect(0, 0, benchMaxX, benchMaxY), image.YCbCrSubsampleRatio422)\n\t// Initialize m's pixels to create a non-uniform image.\n\tfor y := m.Rect.Min.Y; y < m.Rect.Max.Y; y++ {\n\t\tfor x := m.Rect.Min.X; x < m.Rect.Max.X; x++ {\n\t\t\tyi := m.YOffset(x, y)\n\t\t\tci := m.COffset(x, y)\n\t\t\tm.Y[yi] = uint8(16*y + x)\n\t\t\tm.Cb[ci] = uint8(y + 16*x)\n\t\t\tm.Cr[ci] = uint8(y + 16*x)\n\t\t}\n\t}\n\tvar out image.Image\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tout = Resize(benchWidth, benchHeight, m, interp)\n\t}\n\tout.At(0, 0)\n}\n\nfunc Benchmark_Nearest_YCC(b *testing.B) {\n\tbenchYCbCr(b, NearestNeighbor)\n}\n\nfunc Benchmark_Bilinear_YCC(b *testing.B) {\n\tbenchYCbCr(b, Bilinear)\n}\n\nfunc Benchmark_Bicubic_YCC(b *testing.B) {\n\tbenchYCbCr(b, Bicubic)\n}\n\nfunc Benchmark_Mitchell_YCC(b *testing.B) {\n\tbenchYCbCr(b, MitchellNetravali)\n}\n\nfunc Benchmark_Lanczos2_YCC(b *testing.B) {\n\tbenchYCbCr(b, Lanczos2)\n}\n\nfunc Benchmark_Lanczos3_YCC(b *testing.B) {\n\tbenchYCbCr(b, Lanczos3)\n}\n"
        },
        {
          "name": "thumbnail.go",
          "type": "blob",
          "size": 1.7978515625,
          "content": "/*\nCopyright (c) 2012, Jan Schlicht <jan.schlicht@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport (\n\t\"image\"\n)\n\n// Thumbnail will downscale provided image to max width and height preserving\n// original aspect ratio and using the interpolation function interp.\n// It will return original image, without processing it, if original sizes\n// are already smaller than provided constraints.\nfunc Thumbnail(maxWidth, maxHeight uint, img image.Image, interp InterpolationFunction) image.Image {\n\torigBounds := img.Bounds()\n\torigWidth := uint(origBounds.Dx())\n\torigHeight := uint(origBounds.Dy())\n\tnewWidth, newHeight := origWidth, origHeight\n\n\t// Return original image if it have same or smaller size as constraints\n\tif maxWidth >= origWidth && maxHeight >= origHeight {\n\t\treturn img\n\t}\n\n\t// Preserve aspect ratio\n\tif origWidth > maxWidth {\n\t\tnewHeight = uint(origHeight * maxWidth / origWidth)\n\t\tif newHeight < 1 {\n\t\t\tnewHeight = 1\n\t\t}\n\t\tnewWidth = maxWidth\n\t}\n\n\tif newHeight > maxHeight {\n\t\tnewWidth = uint(newWidth * maxHeight / newHeight)\n\t\tif newWidth < 1 {\n\t\t\tnewWidth = 1\n\t\t}\n\t\tnewHeight = maxHeight\n\t}\n\treturn Resize(newWidth, newHeight, img, interp)\n}\n"
        },
        {
          "name": "thumbnail_test.go",
          "type": "blob",
          "size": 1.0419921875,
          "content": "package resize\n\nimport (\n\t\"image\"\n\t\"runtime\"\n\t\"testing\"\n)\n\nfunc init() {\n\truntime.GOMAXPROCS(runtime.NumCPU())\n}\n\nvar thumbnailTests = []struct {\n\torigWidth      int\n\torigHeight     int\n\tmaxWidth       uint\n\tmaxHeight      uint\n\texpectedWidth  uint\n\texpectedHeight uint\n}{\n\t{5, 5, 10, 10, 5, 5},\n\t{10, 10, 5, 5, 5, 5},\n\t{10, 50, 10, 10, 2, 10},\n\t{50, 10, 10, 10, 10, 2},\n\t{50, 100, 60, 90, 45, 90},\n\t{120, 100, 60, 90, 60, 50},\n\t{200, 250, 200, 150, 120, 150},\n}\n\nfunc TestThumbnail(t *testing.T) {\n\tfor i, tt := range thumbnailTests {\n\t\timg := image.NewGray16(image.Rect(0, 0, tt.origWidth, tt.origHeight))\n\n\t\toutImg := Thumbnail(tt.maxWidth, tt.maxHeight, img, NearestNeighbor)\n\n\t\tnewWidth := uint(outImg.Bounds().Dx())\n\t\tnewHeight := uint(outImg.Bounds().Dy())\n\t\tif newWidth != tt.expectedWidth ||\n\t\t\tnewHeight != tt.expectedHeight {\n\t\t\tt.Errorf(\"%d. Thumbnail(%v, %v, img, NearestNeighbor) => \"+\n\t\t\t\t\"width: %v, height: %v, want width: %v, height: %v\",\n\t\t\t\ti, tt.maxWidth, tt.maxHeight,\n\t\t\t\tnewWidth, newHeight, tt.expectedWidth, tt.expectedHeight,\n\t\t\t)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "ycc.go",
          "type": "blob",
          "size": 9.0224609375,
          "content": "/*\nCopyright (c) 2014, Charlie Vieth <charlie.vieth@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport (\n\t\"image\"\n\t\"image/color\"\n)\n\n// ycc is an in memory YCbCr image.  The Y, Cb and Cr samples are held in a\n// single slice to increase resizing performance.\ntype ycc struct {\n\t// Pix holds the image's pixels, in Y, Cb, Cr order. The pixel at\n\t// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*3].\n\tPix []uint8\n\t// Stride is the Pix stride (in bytes) between vertically adjacent pixels.\n\tStride int\n\t// Rect is the image's bounds.\n\tRect image.Rectangle\n\t// SubsampleRatio is the subsample ratio of the original YCbCr image.\n\tSubsampleRatio image.YCbCrSubsampleRatio\n}\n\n// PixOffset returns the index of the first element of Pix that corresponds to\n// the pixel at (x, y).\nfunc (p *ycc) PixOffset(x, y int) int {\n\treturn (y-p.Rect.Min.Y)*p.Stride + (x-p.Rect.Min.X)*3\n}\n\nfunc (p *ycc) Bounds() image.Rectangle {\n\treturn p.Rect\n}\n\nfunc (p *ycc) ColorModel() color.Model {\n\treturn color.YCbCrModel\n}\n\nfunc (p *ycc) At(x, y int) color.Color {\n\tif !(image.Point{x, y}.In(p.Rect)) {\n\t\treturn color.YCbCr{}\n\t}\n\ti := p.PixOffset(x, y)\n\treturn color.YCbCr{\n\t\tp.Pix[i+0],\n\t\tp.Pix[i+1],\n\t\tp.Pix[i+2],\n\t}\n}\n\nfunc (p *ycc) Opaque() bool {\n\treturn true\n}\n\n// SubImage returns an image representing the portion of the image p visible\n// through r. The returned value shares pixels with the original image.\nfunc (p *ycc) SubImage(r image.Rectangle) image.Image {\n\tr = r.Intersect(p.Rect)\n\tif r.Empty() {\n\t\treturn &ycc{SubsampleRatio: p.SubsampleRatio}\n\t}\n\ti := p.PixOffset(r.Min.X, r.Min.Y)\n\treturn &ycc{\n\t\tPix:            p.Pix[i:],\n\t\tStride:         p.Stride,\n\t\tRect:           r,\n\t\tSubsampleRatio: p.SubsampleRatio,\n\t}\n}\n\n// newYCC returns a new ycc with the given bounds and subsample ratio.\nfunc newYCC(r image.Rectangle, s image.YCbCrSubsampleRatio) *ycc {\n\tw, h := r.Dx(), r.Dy()\n\tbuf := make([]uint8, 3*w*h)\n\treturn &ycc{Pix: buf, Stride: 3 * w, Rect: r, SubsampleRatio: s}\n}\n\n// Copy of image.YCbCrSubsampleRatio constants - this allows us to support\n// older versions of Go where these constants are not defined (i.e. Go 1.4)\nconst (\n\tycbcrSubsampleRatio444 image.YCbCrSubsampleRatio = iota\n\tycbcrSubsampleRatio422\n\tycbcrSubsampleRatio420\n\tycbcrSubsampleRatio440\n\tycbcrSubsampleRatio411\n\tycbcrSubsampleRatio410\n)\n\n// YCbCr converts ycc to a YCbCr image with the same subsample ratio\n// as the YCbCr image that ycc was generated from.\nfunc (p *ycc) YCbCr() *image.YCbCr {\n\tycbcr := image.NewYCbCr(p.Rect, p.SubsampleRatio)\n\tswitch ycbcr.SubsampleRatio {\n\tcase ycbcrSubsampleRatio422:\n\t\treturn p.ycbcr422(ycbcr)\n\tcase ycbcrSubsampleRatio420:\n\t\treturn p.ycbcr420(ycbcr)\n\tcase ycbcrSubsampleRatio440:\n\t\treturn p.ycbcr440(ycbcr)\n\tcase ycbcrSubsampleRatio444:\n\t\treturn p.ycbcr444(ycbcr)\n\tcase ycbcrSubsampleRatio411:\n\t\treturn p.ycbcr411(ycbcr)\n\tcase ycbcrSubsampleRatio410:\n\t\treturn p.ycbcr410(ycbcr)\n\t}\n\treturn ycbcr\n}\n\n// imageYCbCrToYCC converts a YCbCr image to a ycc image for resizing.\nfunc imageYCbCrToYCC(in *image.YCbCr) *ycc {\n\tw, h := in.Rect.Dx(), in.Rect.Dy()\n\tp := ycc{\n\t\tPix:            make([]uint8, 3*w*h),\n\t\tStride:         3 * w,\n\t\tRect:           image.Rect(0, 0, w, h),\n\t\tSubsampleRatio: in.SubsampleRatio,\n\t}\n\tswitch in.SubsampleRatio {\n\tcase ycbcrSubsampleRatio422:\n\t\treturn convertToYCC422(in, &p)\n\tcase ycbcrSubsampleRatio420:\n\t\treturn convertToYCC420(in, &p)\n\tcase ycbcrSubsampleRatio440:\n\t\treturn convertToYCC440(in, &p)\n\tcase ycbcrSubsampleRatio444:\n\t\treturn convertToYCC444(in, &p)\n\tcase ycbcrSubsampleRatio411:\n\t\treturn convertToYCC411(in, &p)\n\tcase ycbcrSubsampleRatio410:\n\t\treturn convertToYCC410(in, &p)\n\t}\n\treturn &p\n}\n\nfunc (p *ycc) ycbcr422(ycbcr *image.YCbCr) *image.YCbCr {\n\tvar off int\n\tPix := p.Pix\n\tY := ycbcr.Y\n\tCb := ycbcr.Cb\n\tCr := ycbcr.Cr\n\tfor y := 0; y < ycbcr.Rect.Max.Y-ycbcr.Rect.Min.Y; y++ {\n\t\tyy := y * ycbcr.YStride\n\t\tcy := y * ycbcr.CStride\n\t\tfor x := 0; x < ycbcr.Rect.Max.X-ycbcr.Rect.Min.X; x++ {\n\t\t\tci := cy + x/2\n\t\t\tY[yy+x] = Pix[off+0]\n\t\t\tCb[ci] = Pix[off+1]\n\t\t\tCr[ci] = Pix[off+2]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn ycbcr\n}\n\nfunc (p *ycc) ycbcr420(ycbcr *image.YCbCr) *image.YCbCr {\n\tvar off int\n\tPix := p.Pix\n\tY := ycbcr.Y\n\tCb := ycbcr.Cb\n\tCr := ycbcr.Cr\n\tfor y := 0; y < ycbcr.Rect.Max.Y-ycbcr.Rect.Min.Y; y++ {\n\t\tyy := y * ycbcr.YStride\n\t\tcy := (y / 2) * ycbcr.CStride\n\t\tfor x := 0; x < ycbcr.Rect.Max.X-ycbcr.Rect.Min.X; x++ {\n\t\t\tci := cy + x/2\n\t\t\tY[yy+x] = Pix[off+0]\n\t\t\tCb[ci] = Pix[off+1]\n\t\t\tCr[ci] = Pix[off+2]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn ycbcr\n}\n\nfunc (p *ycc) ycbcr440(ycbcr *image.YCbCr) *image.YCbCr {\n\tvar off int\n\tPix := p.Pix\n\tY := ycbcr.Y\n\tCb := ycbcr.Cb\n\tCr := ycbcr.Cr\n\tfor y := 0; y < ycbcr.Rect.Max.Y-ycbcr.Rect.Min.Y; y++ {\n\t\tyy := y * ycbcr.YStride\n\t\tcy := (y / 2) * ycbcr.CStride\n\t\tfor x := 0; x < ycbcr.Rect.Max.X-ycbcr.Rect.Min.X; x++ {\n\t\t\tci := cy + x\n\t\t\tY[yy+x] = Pix[off+0]\n\t\t\tCb[ci] = Pix[off+1]\n\t\t\tCr[ci] = Pix[off+2]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn ycbcr\n}\n\nfunc (p *ycc) ycbcr444(ycbcr *image.YCbCr) *image.YCbCr {\n\tvar off int\n\tPix := p.Pix\n\tY := ycbcr.Y\n\tCb := ycbcr.Cb\n\tCr := ycbcr.Cr\n\tfor y := 0; y < ycbcr.Rect.Max.Y-ycbcr.Rect.Min.Y; y++ {\n\t\tyy := y * ycbcr.YStride\n\t\tcy := y * ycbcr.CStride\n\t\tfor x := 0; x < ycbcr.Rect.Max.X-ycbcr.Rect.Min.X; x++ {\n\t\t\tci := cy + x\n\t\t\tY[yy+x] = Pix[off+0]\n\t\t\tCb[ci] = Pix[off+1]\n\t\t\tCr[ci] = Pix[off+2]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn ycbcr\n}\n\nfunc (p *ycc) ycbcr411(ycbcr *image.YCbCr) *image.YCbCr {\n\tvar off int\n\tPix := p.Pix\n\tY := ycbcr.Y\n\tCb := ycbcr.Cb\n\tCr := ycbcr.Cr\n\tfor y := 0; y < ycbcr.Rect.Max.Y-ycbcr.Rect.Min.Y; y++ {\n\t\tyy := y * ycbcr.YStride\n\t\tcy := y * ycbcr.CStride\n\t\tfor x := 0; x < ycbcr.Rect.Max.X-ycbcr.Rect.Min.X; x++ {\n\t\t\tci := cy + x/4\n\t\t\tY[yy+x] = Pix[off+0]\n\t\t\tCb[ci] = Pix[off+1]\n\t\t\tCr[ci] = Pix[off+2]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn ycbcr\n}\n\nfunc (p *ycc) ycbcr410(ycbcr *image.YCbCr) *image.YCbCr {\n\tvar off int\n\tPix := p.Pix\n\tY := ycbcr.Y\n\tCb := ycbcr.Cb\n\tCr := ycbcr.Cr\n\tfor y := 0; y < ycbcr.Rect.Max.Y-ycbcr.Rect.Min.Y; y++ {\n\t\tyy := y * ycbcr.YStride\n\t\tcy := (y / 2) * ycbcr.CStride\n\t\tfor x := 0; x < ycbcr.Rect.Max.X-ycbcr.Rect.Min.X; x++ {\n\t\t\tci := cy + x/4\n\t\t\tY[yy+x] = Pix[off+0]\n\t\t\tCb[ci] = Pix[off+1]\n\t\t\tCr[ci] = Pix[off+2]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn ycbcr\n}\n\nfunc convertToYCC422(in *image.YCbCr, p *ycc) *ycc {\n\tvar off int\n\tPix := p.Pix\n\tY := in.Y\n\tCb := in.Cb\n\tCr := in.Cr\n\tfor y := 0; y < in.Rect.Max.Y-in.Rect.Min.Y; y++ {\n\t\tyy := y * in.YStride\n\t\tcy := y * in.CStride\n\t\tfor x := 0; x < in.Rect.Max.X-in.Rect.Min.X; x++ {\n\t\t\tci := cy + x/2\n\t\t\tPix[off+0] = Y[yy+x]\n\t\t\tPix[off+1] = Cb[ci]\n\t\t\tPix[off+2] = Cr[ci]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn p\n}\n\nfunc convertToYCC420(in *image.YCbCr, p *ycc) *ycc {\n\tvar off int\n\tPix := p.Pix\n\tY := in.Y\n\tCb := in.Cb\n\tCr := in.Cr\n\tfor y := 0; y < in.Rect.Max.Y-in.Rect.Min.Y; y++ {\n\t\tyy := y * in.YStride\n\t\tcy := (y / 2) * in.CStride\n\t\tfor x := 0; x < in.Rect.Max.X-in.Rect.Min.X; x++ {\n\t\t\tci := cy + x/2\n\t\t\tPix[off+0] = Y[yy+x]\n\t\t\tPix[off+1] = Cb[ci]\n\t\t\tPix[off+2] = Cr[ci]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn p\n}\n\nfunc convertToYCC440(in *image.YCbCr, p *ycc) *ycc {\n\tvar off int\n\tPix := p.Pix\n\tY := in.Y\n\tCb := in.Cb\n\tCr := in.Cr\n\tfor y := 0; y < in.Rect.Max.Y-in.Rect.Min.Y; y++ {\n\t\tyy := y * in.YStride\n\t\tcy := (y / 2) * in.CStride\n\t\tfor x := 0; x < in.Rect.Max.X-in.Rect.Min.X; x++ {\n\t\t\tci := cy + x\n\t\t\tPix[off+0] = Y[yy+x]\n\t\t\tPix[off+1] = Cb[ci]\n\t\t\tPix[off+2] = Cr[ci]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn p\n}\n\nfunc convertToYCC444(in *image.YCbCr, p *ycc) *ycc {\n\tvar off int\n\tPix := p.Pix\n\tY := in.Y\n\tCb := in.Cb\n\tCr := in.Cr\n\tfor y := 0; y < in.Rect.Max.Y-in.Rect.Min.Y; y++ {\n\t\tyy := y * in.YStride\n\t\tcy := y * in.CStride\n\t\tfor x := 0; x < in.Rect.Max.X-in.Rect.Min.X; x++ {\n\t\t\tci := cy + x\n\t\t\tPix[off+0] = Y[yy+x]\n\t\t\tPix[off+1] = Cb[ci]\n\t\t\tPix[off+2] = Cr[ci]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn p\n}\n\nfunc convertToYCC411(in *image.YCbCr, p *ycc) *ycc {\n\tvar off int\n\tPix := p.Pix\n\tY := in.Y\n\tCb := in.Cb\n\tCr := in.Cr\n\tfor y := 0; y < in.Rect.Max.Y-in.Rect.Min.Y; y++ {\n\t\tyy := y * in.YStride\n\t\tcy := y * in.CStride\n\t\tfor x := 0; x < in.Rect.Max.X-in.Rect.Min.X; x++ {\n\t\t\tci := cy + x/4\n\t\t\tPix[off+0] = Y[yy+x]\n\t\t\tPix[off+1] = Cb[ci]\n\t\t\tPix[off+2] = Cr[ci]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn p\n}\n\nfunc convertToYCC410(in *image.YCbCr, p *ycc) *ycc {\n\tvar off int\n\tPix := p.Pix\n\tY := in.Y\n\tCb := in.Cb\n\tCr := in.Cr\n\tfor y := 0; y < in.Rect.Max.Y-in.Rect.Min.Y; y++ {\n\t\tyy := y * in.YStride\n\t\tcy := (y / 2) * in.CStride\n\t\tfor x := 0; x < in.Rect.Max.X-in.Rect.Min.X; x++ {\n\t\t\tci := cy + x/4\n\t\t\tPix[off+0] = Y[yy+x]\n\t\t\tPix[off+1] = Cb[ci]\n\t\t\tPix[off+2] = Cr[ci]\n\t\t\toff += 3\n\t\t}\n\t}\n\treturn p\n}\n"
        },
        {
          "name": "ycc_test.go",
          "type": "blob",
          "size": 6.76953125,
          "content": "// +build go1.5\n\n/*\nCopyright (c) 2014, Charlie Vieth <charlie.vieth@gmail.com>\n\nPermission to use, copy, modify, and/or distribute this software for any purpose\nwith or without fee is hereby granted, provided that the above copyright notice\nand this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS\nOF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\nTHIS SOFTWARE.\n*/\n\npackage resize\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"testing\"\n)\n\ntype Image interface {\n\timage.Image\n\tSubImage(image.Rectangle) image.Image\n}\n\nfunc TestImage(t *testing.T) {\n\ttestImage := []Image{\n\t\tnewYCC(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio420),\n\t\tnewYCC(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio422),\n\t\tnewYCC(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio440),\n\t\tnewYCC(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio444),\n\t\tnewYCC(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio411),\n\t\tnewYCC(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio410),\n\t}\n\tfor _, m := range testImage {\n\t\tif !image.Rect(0, 0, 10, 10).Eq(m.Bounds()) {\n\t\t\tt.Errorf(\"%T: want bounds %v, got %v\",\n\t\t\t\tm, image.Rect(0, 0, 10, 10), m.Bounds())\n\t\t\tcontinue\n\t\t}\n\t\tm = m.SubImage(image.Rect(3, 2, 9, 8)).(Image)\n\t\tif !image.Rect(3, 2, 9, 8).Eq(m.Bounds()) {\n\t\t\tt.Errorf(\"%T: sub-image want bounds %v, got %v\",\n\t\t\t\tm, image.Rect(3, 2, 9, 8), m.Bounds())\n\t\t\tcontinue\n\t\t}\n\t\t// Test that taking an empty sub-image starting at a corner does not panic.\n\t\tm.SubImage(image.Rect(0, 0, 0, 0))\n\t\tm.SubImage(image.Rect(10, 0, 10, 0))\n\t\tm.SubImage(image.Rect(0, 10, 0, 10))\n\t\tm.SubImage(image.Rect(10, 10, 10, 10))\n\t}\n}\n\nfunc TestConvertYCbCr(t *testing.T) {\n\ttestImage := []Image{\n\t\timage.NewYCbCr(image.Rect(0, 0, 50, 50), image.YCbCrSubsampleRatio420),\n\t\timage.NewYCbCr(image.Rect(0, 0, 50, 50), image.YCbCrSubsampleRatio422),\n\t\timage.NewYCbCr(image.Rect(0, 0, 50, 50), image.YCbCrSubsampleRatio440),\n\t\timage.NewYCbCr(image.Rect(0, 0, 50, 50), image.YCbCrSubsampleRatio444),\n\t\timage.NewYCbCr(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio411),\n\t\timage.NewYCbCr(image.Rect(0, 0, 10, 10), image.YCbCrSubsampleRatio410),\n\t}\n\tfor _, img := range testImage {\n\t\tm := img.(*image.YCbCr)\n\t\tfor y := m.Rect.Min.Y; y < m.Rect.Max.Y; y++ {\n\t\t\tfor x := m.Rect.Min.X; x < m.Rect.Max.X; x++ {\n\t\t\t\tyi := m.YOffset(x, y)\n\t\t\t\tci := m.COffset(x, y)\n\t\t\t\tm.Y[yi] = uint8(16*y + x)\n\t\t\t\tm.Cb[ci] = uint8(y + 16*x)\n\t\t\t\tm.Cr[ci] = uint8(y + 16*x)\n\t\t\t}\n\t\t}\n\n\t\t// test conversion from YCbCr to ycc\n\t\tyc := imageYCbCrToYCC(m)\n\t\tfor y := m.Rect.Min.Y; y < m.Rect.Max.Y; y++ {\n\t\t\tfor x := m.Rect.Min.X; x < m.Rect.Max.X; x++ {\n\t\t\t\tystride := 3 * (m.Rect.Max.X - m.Rect.Min.X)\n\t\t\t\txstride := 3\n\t\t\t\tyi := m.YOffset(x, y)\n\t\t\t\tci := m.COffset(x, y)\n\t\t\t\tsi := (y * ystride) + (x * xstride)\n\t\t\t\tif m.Y[yi] != yc.Pix[si] {\n\t\t\t\t\tt.Errorf(\"Err Y - found: %d expected: %d x: %d y: %d yi: %d si: %d\",\n\t\t\t\t\t\tm.Y[yi], yc.Pix[si], x, y, yi, si)\n\t\t\t\t}\n\t\t\t\tif m.Cb[ci] != yc.Pix[si+1] {\n\t\t\t\t\tt.Errorf(\"Err Cb - found: %d expected: %d x: %d y: %d ci: %d si: %d\",\n\t\t\t\t\t\tm.Cb[ci], yc.Pix[si+1], x, y, ci, si+1)\n\t\t\t\t}\n\t\t\t\tif m.Cr[ci] != yc.Pix[si+2] {\n\t\t\t\t\tt.Errorf(\"Err Cr - found: %d expected: %d x: %d y: %d ci: %d si: %d\",\n\t\t\t\t\t\tm.Cr[ci], yc.Pix[si+2], x, y, ci, si+2)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// test conversion from ycc back to YCbCr\n\t\tym := yc.YCbCr()\n\t\tfor y := m.Rect.Min.Y; y < m.Rect.Max.Y; y++ {\n\t\t\tfor x := m.Rect.Min.X; x < m.Rect.Max.X; x++ {\n\t\t\t\tyi := m.YOffset(x, y)\n\t\t\t\tci := m.COffset(x, y)\n\t\t\t\tif m.Y[yi] != ym.Y[yi] {\n\t\t\t\t\tt.Errorf(\"Err Y - found: %d expected: %d x: %d y: %d yi: %d\",\n\t\t\t\t\t\tm.Y[yi], ym.Y[yi], x, y, yi)\n\t\t\t\t}\n\t\t\t\tif m.Cb[ci] != ym.Cb[ci] {\n\t\t\t\t\tt.Errorf(\"Err Cb - found: %d expected: %d x: %d y: %d ci: %d\",\n\t\t\t\t\t\tm.Cb[ci], ym.Cb[ci], x, y, ci)\n\t\t\t\t}\n\t\t\t\tif m.Cr[ci] != ym.Cr[ci] {\n\t\t\t\t\tt.Errorf(\"Err Cr - found: %d expected: %d x: %d y: %d ci: %d\",\n\t\t\t\t\t\tm.Cr[ci], ym.Cr[ci], x, y, ci)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestYCbCr(t *testing.T) {\n\trects := []image.Rectangle{\n\t\timage.Rect(0, 0, 16, 16),\n\t\timage.Rect(1, 0, 16, 16),\n\t\timage.Rect(0, 1, 16, 16),\n\t\timage.Rect(1, 1, 16, 16),\n\t\timage.Rect(1, 1, 15, 16),\n\t\timage.Rect(1, 1, 16, 15),\n\t\timage.Rect(1, 1, 15, 15),\n\t\timage.Rect(2, 3, 14, 15),\n\t\timage.Rect(7, 0, 7, 16),\n\t\timage.Rect(0, 8, 16, 8),\n\t\timage.Rect(0, 0, 10, 11),\n\t\timage.Rect(5, 6, 16, 16),\n\t\timage.Rect(7, 7, 8, 8),\n\t\timage.Rect(7, 8, 8, 9),\n\t\timage.Rect(8, 7, 9, 8),\n\t\timage.Rect(8, 8, 9, 9),\n\t\timage.Rect(7, 7, 17, 17),\n\t\timage.Rect(8, 8, 17, 17),\n\t\timage.Rect(9, 9, 17, 17),\n\t\timage.Rect(10, 10, 17, 17),\n\t}\n\tsubsampleRatios := []image.YCbCrSubsampleRatio{\n\t\timage.YCbCrSubsampleRatio444,\n\t\timage.YCbCrSubsampleRatio422,\n\t\timage.YCbCrSubsampleRatio420,\n\t\timage.YCbCrSubsampleRatio440,\n\t}\n\tdeltas := []image.Point{\n\t\timage.Pt(0, 0),\n\t\timage.Pt(1000, 1001),\n\t\timage.Pt(5001, -400),\n\t\timage.Pt(-701, -801),\n\t}\n\tfor _, r := range rects {\n\t\tfor _, subsampleRatio := range subsampleRatios {\n\t\t\tfor _, delta := range deltas {\n\t\t\t\ttestYCbCr(t, r, subsampleRatio, delta)\n\t\t\t}\n\t\t}\n\t\tif testing.Short() {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc testYCbCr(t *testing.T, r image.Rectangle, subsampleRatio image.YCbCrSubsampleRatio, delta image.Point) {\n\t// Create a YCbCr image m, whose bounds are r translated by (delta.X, delta.Y).\n\tr1 := r.Add(delta)\n\timg := image.NewYCbCr(r1, subsampleRatio)\n\n\t// Initialize img's pixels. For 422 and 420 subsampling, some of the Cb and Cr elements\n\t// will be set multiple times. That's OK. We just want to avoid a uniform image.\n\tfor y := r1.Min.Y; y < r1.Max.Y; y++ {\n\t\tfor x := r1.Min.X; x < r1.Max.X; x++ {\n\t\t\tyi := img.YOffset(x, y)\n\t\t\tci := img.COffset(x, y)\n\t\t\timg.Y[yi] = uint8(16*y + x)\n\t\t\timg.Cb[ci] = uint8(y + 16*x)\n\t\t\timg.Cr[ci] = uint8(y + 16*x)\n\t\t}\n\t}\n\n\tm := imageYCbCrToYCC(img)\n\n\t// Make various sub-images of m.\n\tfor y0 := delta.Y + 3; y0 < delta.Y+7; y0++ {\n\t\tfor y1 := delta.Y + 8; y1 < delta.Y+13; y1++ {\n\t\t\tfor x0 := delta.X + 3; x0 < delta.X+7; x0++ {\n\t\t\t\tfor x1 := delta.X + 8; x1 < delta.X+13; x1++ {\n\t\t\t\t\tsubRect := image.Rect(x0, y0, x1, y1)\n\t\t\t\t\tsub := m.SubImage(subRect).(*ycc)\n\n\t\t\t\t\t// For each point in the sub-image's bounds, check that m.At(x, y) equals sub.At(x, y).\n\t\t\t\t\tfor y := sub.Rect.Min.Y; y < sub.Rect.Max.Y; y++ {\n\t\t\t\t\t\tfor x := sub.Rect.Min.X; x < sub.Rect.Max.X; x++ {\n\t\t\t\t\t\t\tcolor0 := m.At(x, y).(color.YCbCr)\n\t\t\t\t\t\t\tcolor1 := sub.At(x, y).(color.YCbCr)\n\t\t\t\t\t\t\tif color0 != color1 {\n\t\t\t\t\t\t\t\tt.Errorf(\"r=%v, subsampleRatio=%v, delta=%v, x=%d, y=%d, color0=%v, color1=%v\",\n\t\t\t\t\t\t\t\t\tr, subsampleRatio, delta, x, y, color0, color1)\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}