{
  "metadata": {
    "timestamp": 1736566762780,
    "page": 316,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjMyMA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "rfjakob/gocryptfs",
      "stars": 3646,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.3251953125,
          "content": "# the gocryptfs executable\n/gocryptfs\n\n# temporary files created by the tests\n/tmp\n\n# binary releases and signatiures\n/*.tar.gz\n/*.asc\n\n# Binaries created for cpu profiling\n*.test\n\n# Rendered manpage\ngocryptfs.1\n\n# Dependencies copied by \"dep\"\n/vendor\n/_vendor-*\n\n# Source tarball version. Should never be committed to git.\n/VERSION\n"
        },
        {
          "name": "Documentation",
          "type": "tree",
          "content": null
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0615234375,
          "content": "The MIT License (MIT)\n\nCopyright (c) 2015 Jakob Unterwurzacher\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 1.5947265625,
          "content": ".phony: build\nbuild:\n\t./build.bash\n\t./Documentation/MANPAGE-render.bash\n\n.phony: test\ntest:\n\t./test.bash\n\n.phony: root_test\nroot_test:\n\t./build.bash\n\n# Need to use TMPDIR=/var/tmp as TestOverlay fails on tmpfs.\n\tcd tests/root_test && go test -c && sudo TMPDIR=/var/tmp ./root_test.test -test.v\n\n\tcd tests/cli && go test -c && sudo ./cli.test -test.v -test.run=TestDirectMount\n\n.phony: format\nformat:\n\tgo fmt ./...\n\n# Keep in sync with uninstall!\n.phony: install\ninstall:\n\tinstall -Dm755 -t \"$(DESTDIR)/usr/bin/\" gocryptfs\n\tinstall -Dm755 -t \"$(DESTDIR)/usr/bin/\" gocryptfs-xray/gocryptfs-xray\n\tinstall -Dm644 -t \"$(DESTDIR)/usr/share/man/man1/\" Documentation/gocryptfs.1\n\tinstall -Dm644 -t \"$(DESTDIR)/usr/share/man/man1/\" Documentation/gocryptfs-xray.1\n\tinstall -Dm644 -t \"$(DESTDIR)/usr/share/licenses/gocryptfs\" LICENSE\n\n.phony: uninstall\nuninstall:\n\trm -f \"$(DESTDIR)/usr/bin/gocryptfs\"\n\trm -f \"$(DESTDIR)/usr/bin/gocryptfs-xray\"\n\trm -f \"$(DESTDIR)/usr/share/man/man1/gocryptfs.1\"\n\trm -f \"$(DESTDIR)/usr/share/man/man1/gocryptfs-xray.1\"\n\trm -f \"$(DESTDIR)/usr/share/licenses/gocryptfs/LICENSE\"\n\n.phony: ci\nci:\n\tuname -a ; go version ; openssl version\n\tdf -Th / /tmp /var/tmp\n\n\t./build-without-openssl.bash\n\t./build.bash\n\t./test.bash\n\tmake root_test\n\t./crossbuild.bash\n\n\techo \"Rebuild with locked dependencies\"\n\t# Download dependencies to \"vendor\" directory\n\tgo mod vendor\n\t# Delete global cache\n\tgo clean -modcache\n\t# GOPROXY=off makes sure we fail instead of making network requests\n\t# (we should not need any!)\n\t# \"-mod=vendor\" is required for Go 1.13\n\tGOPROXY=off ./build.bash -mod=vendor\n\t# Delete \"vendor\" dir\n\trm -R vendor\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 41.5810546875,
          "content": "[![gocryptfs](Documentation/gocryptfs-logo.png)](https://nuetzlich.net/gocryptfs/)\n[![CI](https://github.com/rfjakob/gocryptfs/actions/workflows/ci.yml/badge.svg)](https://github.com/rfjakob/gocryptfs/actions/workflows/ci.yml)\n[![MIT License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)\n[![Go Report Card](https://goreportcard.com/badge/github.com/rfjakob/gocryptfs)](https://goreportcard.com/report/github.com/rfjakob/gocryptfs)\n[![Latest release](https://img.shields.io/github/release/rfjakob/gocryptfs.svg)](https://github.com/rfjakob/gocryptfs/releases)\n[![Homebrew version](https://img.shields.io/homebrew/v/gocryptfs.svg)](https://formulae.brew.sh/formula/gocryptfs#default)\n\nAn encrypted overlay filesystem written in Go.\nOfficial website: https://nuetzlich.net/gocryptfs ([markdown source](https://github.com/rfjakob/gocryptfs-website/blob/master/docs/index.md)).\n\n![Folders side-by-side animation](Documentation/folders-side-by-side.gif)\n\ngocryptfs is built on top the excellent\n[go-fuse](https://github.com/hanwen/go-fuse) FUSE library.\nThis project was inspired by EncFS and strives to fix its security\nissues while providing good performance\n([benchmarks](https://nuetzlich.net/gocryptfs/comparison/#performance)).\nFor details on the security of gocryptfs see the\n[Security](https://nuetzlich.net/gocryptfs/security/) design document.\n\nAll tags from v0.4 onward are signed by the *gocryptfs signing key*.\nPlease check [Signed Releases](https://nuetzlich.net/gocryptfs/releases/)\nfor details.\n\nCurrent Status\n--------------\n\ngocryptfs has reached version 1.0 on July 17, 2016. It has gone through\nhours and hours of stress (fsstress, extractloop.bash) and correctness\ntesting (xfstests). It is now considered ready for general consumption.\n\nThe old principle still applies: Important data should have a backup.\nAlso, keep a copy of your master key (printed on mount) in a safe place.\nThis allows you to access the data even if the gocryptfs.conf config\nfile is damaged or you lose the password.\n\nThe security of gocryptfs has been audited in March 3, 2017. The audit\nis available [here (defuse.ca)](https://defuse.ca/audits/gocryptfs.htm).\n\nPlatforms\n---------\n\nLinux is gocryptfs' native platform.\n\nBeta-quality macOS support is available, which means most things work\nfine but you may hit an occasional problem. Check out\n[ticket #15](https://github.com/rfjakob/gocryptfs/issues/15) for the history\nof macOS support but please create a new ticket if you hit a problem.\n\nFor Windows, an independent C++ reimplementation can be found here:\n[cppcryptfs](https://github.com/bailey27/cppcryptfs)\n\nA standalone Python tool that can decrypt files & file names is here:\n[gocryptfs-inspect](https://github.com/slackner/gocryptfs-inspect)\n\nInstallation\n------------\nPrecompiled binaries that work on all x86_64 Linux systems are available\nfor download from the github releases page. The `fuse` package from your\ndistribution must be installed for mounting to work.\n\ngocryptfs is also available as a package in most distributions. Examples:\n\n* Debian, Ubuntu: `apt install gocryptfs`\n* Arch: `pacman -S gocryptfs`\n* MacPorts: `port install gocryptfs`\n\nSee the [Quickstart](https://nuetzlich.net/gocryptfs/quickstart/) page for more info.\n\nTesting\n-------\n\ngocryptfs comes with is own test suite that is constantly expanded as features are\nadded. Run it using `./test.bash`. It takes about 1 minute and requires FUSE\nas it mounts several test filesystems.\n\nThe `stress_tests` directory contains stress tests that run indefinitely.\n\nIn addition, I have ported `xfstests` to FUSE, the result is the\n[fuse-xfstests](https://github.com/rfjakob/fuse-xfstests) project. gocryptfs\npasses the \"generic\" tests with one exception, results:  [XFSTESTS.md](Documentation/XFSTESTS.md)\n\nA lot of work has gone into this. The testing has found bugs in gocryptfs\nas well as in the go-fuse library.\n\nCompile\n-------\n\nInstall Go 1.13 or higher:\n\n* Debian/Ubuntu: `apt install golang`\n* Fedora: `dnf install golang`\n\nThen, download the source code and compile:\n\n\t$ git clone https://github.com/rfjakob/gocryptfs.git\n\t$ cd gocryptfs\n\t$ ./build-without-openssl.bash\n\nThis will compile a static binary that uses the Go stdlib crypto backend.\n\nIf you want to use the OpenSSL crypto backend (faster on\nold CPUs lacking AES-NI), you have to install a few dependencies:\n\n* Debian/Ubuntu: `apt install libssl-dev gcc pkg-config`\n* Fedora: `dnf install openssl-devel gcc pkg-config`\n\nThen, run:\n\n\t$ ./build.bash\n\nUse\n---\n\n\t$ mkdir cipher plain\n\t$ ./gocryptfs -init cipher\n\t$ ./gocryptfs cipher plain\n\nSee the [Quickstart](https://nuetzlich.net/gocryptfs/quickstart/) page for more info.\n\nThe [MANPAGE.md](Documentation/MANPAGE.md) describes all available command-line options.\n\nUse: Reverse Mode\n-----------------\n\n    $ mkdir cipher plain\n    $ ./gocryptfs -reverse -init plain\n    $ ./gocryptfs -reverse plain cipher\n\nGraphical Interface\n-------------------\n\nThe [SiriKali](https://mhogomchungu.github.io/sirikali/) project supports\ngocryptfs and runs on Linux and OSX.\n\n[cppcryptfs](https://github.com/bailey27/cppcryptfs) on Windows provides\nits own GUI.\n\nStable CLI ABI\n--------------\n\nIf you want to call gocryptfs from your app or script, see\n[CLI_ABI.md](Documentation/CLI_ABI.md) for the official stable\nABI. This ABI is regression-tested by the test suite.\n\nStorage Overhead\n----------------\n\n* Empty files take 0 bytes on disk\n* 18 byte file header for non-empty files (2 bytes version, 16 bytes random file id)\n* 32 bytes of storage overhead per 4kB block (16 byte nonce, 16 bytes auth tag)\n\n[file-format.md](Documentation/file-format.md) contains a more detailed description.\n\nPerformance\n-----------\n\nSince version 0.7.2, gocryptfs is as fast as EncFS in the default mode,\nand significantly faster than EncFS' \"paranoia\" mode that provides\na security level comparable to gocryptfs.\n\nOn CPUs without AES-NI, gocryptfs uses OpenSSL through a thin wrapper called `stupidgcm`.\nThis provides a 4x speedup compared to Go's builtin AES-GCM\nimplementation. See [CPU-Benchmarks](https://github.com/rfjakob/gocryptfs/wiki/CPU-Benchmarks)\nfor details, or run `gocryptfs -speed` to see the encryption performance of your CPU.\nExample for a CPU with AES-NI:\n\n```\n$ ./gocryptfs -speed\ngocryptfs v2.2.0-beta1-5-g52b0444-dirty; go-fuse v2.1.1-0.20210825171523-3ab5d95a30ae; 2021-09-14 go1.17.1 linux/amd64\ncpu: Intel(R) Core(TM) i5-3470 CPU @ 3.20GHz; with AES acceleration\nAES-GCM-256-OpenSSL              862.79 MB/s\nAES-GCM-256-Go                   997.71 MB/s    (selected in auto mode)\nAES-SIV-512-Go                   159.58 MB/s\nXChaCha20-Poly1305-OpenSSL   729.65 MB/s\nXChaCha20-Poly1305-Go            843.97 MB/s    (selected in auto mode)\n```\n\nYou can run `./benchmark.bash` to run gocryptfs' canonical set of\nbenchmarks that include streaming write, extracting a linux kernel\ntarball, recursively listing and finally deleting it. The output will\nlook like this:\n\n```\n$ ./benchmark.bash\nTesting gocryptfs at /tmp/benchmark.bash.xFD: gocryptfs v2.0; go-fuse v2.1.1-0.20210508151621-62c5aa1919a7; 2021-06-06 go1.16.5 linux/amd64\nWRITE: 262144000 bytes (262 MB, 250 MiB) copied, 0,698174 s, 375 MB/s\nREAD:  262144000 bytes (262 MB, 250 MiB) copied, 0,268916 s, 975 MB/s\nUNTAR: 8,970\nMD5:   4,846\nLS:    1,851\nRM:    2,367\n```\n\nChangelog\n---------\n\n#### v2.4.0, 2023-06-10\n* Try the `mount(2)` syscall before falling back to `fusermount(1)`. This means we\n  don't need `fusermount(1)` at all if running as root or in a root-like namespace\n  ([#697](https://github.com/rfjakob/gocryptfs/issues/697))\n* Fix `-extpass` mis-parsing commas ([#730](https://github.com/rfjakob/gocryptfs/issues/730))\n* Fix `rm -R` mis-reporting `write-protected directory` on gocryptfs on sshfs\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/09954c4bdecf0ca6da65776f176dc934ffced2b0))\n\n#### v2.3.2, 2023-04-29\n* Fix incorrect file size reported after hard link creation\n  ([#724](https://github.com/rfjakob/gocryptfs/issues/724))\n\n#### v2.3.1, 2023-03-04\n* Optimize NFS streaming write performance ([#712](https://github.com/rfjakob/gocryptfs/issues/712),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/8f3ec5dcaa6eb18d11746675190a7aaceb422764)).\n  You should see about a 4x performance increase.\n* Use `debug.ReadBuildInfo()` to provide some\n  version information even when not built with `build.bash` ([#701](https://github.com/rfjakob/gocryptfs/pull/701)) .\n* Fix bug that caused the `logger` process to be killed when started from `xfce4-terminal`,\n  and that terminal window was closed ([#660](https://github.com/rfjakob/gocryptfs/issues/660),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/ff32e9979130e6237b0d97ef88304fa79ce61b06)).\n* MacOS: Fix reverse mount failing with `read-only file system` ([#690](https://github.com/rfjakob/gocryptfs/pull/690))\n* Make gocryptfs compile on riscv64 by switching from [jacobsa/crypto](https://github.com/jacobsa/crypto)\n  to maintained fork [aperturerobotics/jacobsa-crypto](https://github.com/aperturerobotics/jacobsa-crypto)\n  ([#674](https://github.com/rfjakob/gocryptfs/pull/674))\n\n#### v2.3.0, 2022-10-21\n* Identical to v2.3, just tagged once more in full semver x.y.z format. This make Go's fetching logic happy,\n  which ignores v2.3 (without the third digit) completely.\n  Fixes [#694](https://github.com/rfjakob/gocryptfs/issues/694), [#688](https://github.com/rfjakob/gocryptfs/issues/688).\n\n#### v2.3, 2022-08-28\n* Add **`-longnamemax`** flag to `-init` ([#499](https://github.com/rfjakob/gocryptfs/issues/499)).\n  Can be used to work around file or path length restrictions on online storage.\n  See the [man page](https://github.com/rfjakob/gocryptfs/blob/master/Documentation/MANPAGE.md#-longnamemax)\n  for details.\n* Support for [`NO_COLOR`](https://no-color.org/) env variable ([#617](https://github.com/rfjakob/gocryptfs/issues/617))\n* Fix `-force_owner` not not affecting socket files ([#629](https://github.com/rfjakob/gocryptfs/issues/629)\n* MacOS: fix inaccessible `gocryptfs.conf` in reverse mode ([commit](https://github.com/rfjakob/gocryptfs/commit/c9e4e4f74150d2734496e90a4c442a17b79f52c1))\n* Raise ctlsock operation timeout from 1 to 10 seconds ([#683](https://github.com/rfjakob/gocryptfs/issues/683))\n\n#### v2.2.1, 2021-10-20\n* Fix `-force_owner` only taking effect after 2 seconds ([#609](https://github.com/rfjakob/gocryptfs/issues/609)).\n  This was a regression introduced in v2.0.\n* MacOS: Fix build.bash failure with error `date: illegal option -- -` when `SOURCE_DATE_EPOCH` is set\n  ([#570](https://github.com/rfjakob/gocryptfs/issues/570))\n* `-init`: suggest xchacha on CPUs without AES acceleration ([commit](https://github.com/rfjakob/gocryptfs/commit/e8e35982845f36e714b915350eaf6855487aa0e8))\n* `-info`: add contentEncryption to output\n\n#### v2.2.0, 2021-09-25\n* **`-deterministic-names`: new option for `-init`**, both for reverse and forward mode.\n   Disables file name randomisation & `gocryptfs.diriv` files\n   ([#151](https://github.com/rfjakob/gocryptfs/issues/151), [#402](https://github.com/rfjakob/gocryptfs/issues/402), [#592](https://github.com/rfjakob/gocryptfs/pull/592))\n   * New feature flag! You need gocryptfs v2.2 or higher to mount a filesystem that uses this flag.\n* **`-xchacha`: new option for `-init`** (forward mode only). Selects XChaCha20-Poly1305 for content encryption.\n  Gives *much* better performance on CPUs without AES acceleration\n  ([#452](https://github.com/rfjakob/gocryptfs/issues/452)).\n   * New feature flag! You need gocryptfs v2.2 or higher to mount a filesystem that uses this flag.\n   * Test with `gocryptfs -speed` what is fastest for your CPU, or read [here](https://github.com/rfjakob/gocryptfs/issues/452#issuecomment-908559414)\n* Rewrite [OpenSSL backend](https://pkg.go.dev/github.com/rfjakob/gocryptfs/v2/internal/stupidgcm)\n  for better performance on AES-GCM-256-OpenSSL and XChaCha20-Poly1305-OpenSSL\n* `-serialize_reads`: get rid of delay logic by taking advantage of the kernel flag\n  `FUSE_CAP_ASYNC_READ`\n  ([go-fuse commit](https://github.com/hanwen/go-fuse/commit/15a8bb029a4e1a51e10043c370970596b1fbb737),\n  [gocryptfs commit](https://github.com/rfjakob/gocryptfs/commit/a99051b32452c9a781efe248c0014b65d4abddf7))\n* Make obsolete `-devrandom` flag a no-op ([commit](https://github.com/rfjakob/gocryptfs/commit/61ef6b00a675456ee05d40f1ce44d693bc4be350))\n* Make `-forcedecode` flag a no-op ([commit](https://github.com/rfjakob/gocryptfs/commit/d023cd6c95fcbc6b5056ba1f425d2ac3df4abc5a))\n* Fix reverse mode sometimes remapping most inode numbers to >281474976710656 ([commit](https://github.com/rfjakob/gocryptfs/commit/c9b825c58a9f996379108926754513bca03bb306))\n* This version will be called v2.2.0 (instead of v2.2) to comply with\n  the [Go module versioning](https://golang.org/doc/modules/version-numbers) convention.\n  Later releases will also follow the convention.\n\n#### v2.1, 2021-08-18\n* `-fido2`: do not request PIN on `gocryptfs -init` fixing `FIDO_ERR_UNSUPPORTED_OPTION` with YubiKey\n  ([#571](https://github.com/rfjakob/gocryptfs/issues/571))\n* `-sharedstorage`: present stable inode numbers, fixing getcwd failures\n  ([#584](https://github.com/rfjakob/gocryptfs/issues/584))\n* `-badname`: make it possible to access content of invalid file names ([#568](https://github.com/rfjakob/gocryptfs/pull/568)).\n  Thanks @DerDonut!\n* Implement recursive `gocryptfs.diriv` caching to fix exponential runtime with deep directories\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/84e702126ac4f017e12150532bfaed675dee2927)])\n* Implements fsync on directories ([#587](https://github.com/rfjakob/gocryptfs/issues/587))\n* `-reverse`: implement `-one-file-system` ([#475](https://github.com/rfjakob/gocryptfs/issues/475))\n* `-reverse`: allow exclude-all-but ([#588](https://github.com/rfjakob/gocryptfs/issues/588))\n  * Example: `gocryptfs -reverse -exclude-wildcard '*' -exclude-wildcard '!/my-important-files' /home/user /mnt/user.encrypted`\n* macOS: Fix `panic: using reserved ID 1` on ExFAT ([#585](https://github.com/rfjakob/gocryptfs/issues/585))\n* Switch to `pflag` cli parsing library to support flags and arguments in any order\n  ([#590](https://github.com/rfjakob/gocryptfs/issues/590))\n* Drop support for Go 1.11 & Go 1.12 ([commit](https://github.com/rfjakob/gocryptfs/commit/a5f88e86d186cdbc67e1efabd7aacf389775e027))\n  * You must have Go 1.13 or newer now\n\n#### v2.0.1, 2021-06-07\n* Fix symlink creation reporting the wrong size, causing git to report it as modified\n  ([#574](https://github.com/rfjakob/gocryptfs/issues/574))\n\n#### v2.0, 2021-06-05\n* Fix a few [issues discovered by xfstests](https://github.com/rfjakob/fuse-xfstests/wiki/results_2021-05-19)\n  * Biggest change: rewrite SEEK_HOLE / SEEK_DATA logic (now emulates 4k alignment)\n\n#### v2.0-beta4, 2021-05-15\n* **Make ACLs *actually* work (pass `-acl` to enable)** ([#536](https://github.com/rfjakob/gocryptfs/issues/536))\n* Blocklist `RENAME_EXCHANGE` and `RENAME_WHITEOUT` (broken as discovered by [fuse-xfstest/gocryptfs-2019-12](https://github.com/rfjakob/fuse-xfstests/tree/gocryptfs-2019-12))\n\n#### v2.0-beta3, 2021-04-24\n* MANPAGE: Split options into sections acc. to where they apply ([#517](https://github.com/rfjakob/gocryptfs/issues/517))\n* `-idle`: count cwd inside the mount as busy ([#533](https://github.com/rfjakob/gocryptfs/issues/533))\n* Make `gocryptfs.diriv` and `gocryptfs.xxx.name` files world-readable to make encrypted backups easier\n  when mounting via [/etc/fstab](Documentation/MANPAGE.md#fstab) ([#539](https://github.com/rfjakob/gocryptfs/issues/539))\n* Make it work with MacFUSE v4.x ([#524](https://github.com/rfjakob/gocryptfs/issues/524))\n* **Disable ACL encryption**, it causes a lot of problems ([#543](https://github.com/rfjakob/gocryptfs/issues/543),\n  [#536](https://github.com/rfjakob/gocryptfs/issues/536))\n  * Old encrypted ACLs are reported by `gocryptfs -fsck` but otherwise ignored\n  * This fixes inheritance, but does not yet enforce them correctly\n* Include `gocryptfs-xray` in binary releases ([#496](https://github.com/rfjakob/gocryptfs/issues/496))\n* go-fuse: track *most recent* parent. This improves robustness when the filesystem is modified behind\n  the back of gocryptfs. Helps both with `-sharedstorage` and also without.\n  ([commit 1](https://github.com/hanwen/go-fuse/commit/c3186132bf8b7a04b5e5bc27489d88181f92e4e0),\n  [commit 2](https://github.com/hanwen/go-fuse/commit/a90e1f463c3f172a7690a6449fe5955a180dfec3),\n  [#549](https://github.com/rfjakob/gocryptfs/issues/549))\n* Add directory fd caching for 2x - 3x speed boost in small file ops compared to v2.0-beta2\n  ([performance numbers](https://github.com/rfjakob/gocryptfs/blob/5cb1e55714aa92a848c0fb5fc3fa7b91625210fe/Documentation/performance.txt#L73))\n\n#### v2.0-beta2, 2020-11-14\n* Improve [performance](Documentation/performance.txt#L69)\n* Fix [GETATTR panic](https://github.com/rfjakob/gocryptfs/issues/519#issuecomment-718790790) in reverse mode\n\n#### v2.0-beta1, 2020-10-15\n* **Switch to the improved go-fuse [v2 API](https://pkg.go.dev/github.com/hanwen/go-fuse/v2@v2.0.3/fs)**\n  * This is a big change, a lot of code has been reorganized or rewritten\n    to fit the v2 API model.\n  * Please test & report bugs\n  * No changes to the on-disk format\n  * File descriptor caching is not yet implemented,\n    causing a slowdown. Caching will be implemented for v2.0 final.\n* **Add support for FIDO2 tokens (`-fido2`, [#505](https://github.com/rfjakob/gocryptfs/pull/505))**\n* Add `-encrypt-paths` / `-decrypt-paths` functionality to `gocryptfs-xray`\n  ([#416](https://github.com/rfjakob/gocryptfs/issues/416))\n* Accept multiple `-passfile`s\n  ([#288](https://github.com/rfjakob/gocryptfs/issues/288))\n* Make `-masterkey=stdin` work together with `-passwd`\n  ([#461](https://github.com/rfjakob/gocryptfs/issues/461))\n* Fix `Unknown opcode 2016` crash on Google Cloud\n  ([go-fuse #276](https://github.com/hanwen/go-fuse/issues/276),\n  [gocryptfs commit ec74d1d](https://github.com/rfjakob/gocryptfs/commit/ec74d1d2f4217a9a337d1db9902f32ae2aecaf33))\n\n#### v1.8.0, 2020-05-09\n* Enable ACL support ([#453](https://github.com/rfjakob/gocryptfs/issues/453))\n  * **Warning 2021-02-07**: This feature is incomplete! Do not use ACLs before gocryptfs v2.0 final!\n    Reading and writing ACLs works, but they are not enforced or inherited ([#542](https://github.com/rfjakob/gocryptfs/issues/542))\n* Ignore `.nfsXXX` temporary files\n  ([#367](https://github.com/rfjakob/gocryptfs/issues/431))\n* Handle inode number collisions from multiple devices\n  ([#435](https://github.com/rfjakob/gocryptfs/issues/435))\n* Drop `-nonempty` for fusermount3\n  ([#440](https://github.com/rfjakob/gocryptfs/pull/440))\n* Reverse mode: improve inode number mapping and max=1000000000000000000 limitation\n  ([#457](https://github.com/rfjakob/gocryptfs/issues/457))\n* Enable `--buildmode=pie` ([#460](https://github.com/rfjakob/gocryptfs/pull/460))\n* Migrate from dep to Go Modules\n  ([commit cad711993](https://github.com/rfjakob/gocryptfs/commit/cad711993d67dd920f9749a09414dbbba6ab8136))\n* go mod: update dependencies\n  ([commit b23f77c](https://github.com/rfjakob/gocryptfs/commit/b23f77c8ead0dbb5ed59dd50e94f13aacf7dbaf1))\n* `gocryptfs -speed`: add XChaCha20-Poly1305-Go\n  ([#452](https://github.com/rfjakob/gocryptfs/issues/452))\n* Respect `GOMAXPROCS` environment variable\n  ([commit ff210a06f](https://github.com/rfjakob/gocryptfs/commit/ff210a06fb3097eecd5668ddb3ace9c76873eb00)\n* Completely remove Trezor-related code (commit 1364b44ae356da31e24e5605fe73a307e9d6fb03)\n  * Has been disabled since v1.7 due to issues a third-party module.\n  * Please use FIDO2 instead (gocryptfs v2.0)\n\n#### v1.7.1, 2019-10-06\n* Support wild cards in reverse mode via `--exclude-wildcard`\n  ([#367](https://github.com/rfjakob/gocryptfs/pull/367)). Thanks @ekalin!\n* Create `gocryptfs.diriv` files with 0440 permissions to make it easier to\n  share an encrypted folder via a network drive\n  ([#387](https://github.com/rfjakob/gocryptfs/issues/387)).\n  Note: as a security precaution, the owner must still manually\n  `chmod gocryptfs.conf 0440` to allow mounting.\n* Allow the `nofail` option in `/etc/fstab`\n* `-passwd` can now change the `-scryptn` parameter for existing filesystems\n  ([#400](https://github.com/rfjakob/gocryptfs/issues/400))\n* Fix `-idle` unmounting the filesystem despite recent activity\n  ([#421](https://github.com/rfjakob/gocryptfs/issues/421))\n* **Fix a race condition related to inode number reuse\n  ([#363](https://github.com/rfjakob/gocryptfs/issues/363))**.\n  It could be triggered by concurrently creating and deleting files and can lead to data loss\n  in the affected file. This bug was found by the automated tests on Travis\n  and was very hard to trigger locally.\n* tests: use /var/tmp instead of /tmp by default\n  ([commit 8c4429](https://github.com/rfjakob/gocryptfs/commit/8c4429408716d9890a98a48c246d616dbfea7e31))\n\n#### v1.7, 2019-03-17\n* **Fix possible symlink race attacks in forward mode** when using allow_other + plaintextnames\n  * If you use *both* `-allow_other` *and* `-plaintextnames`, you should upgrade.\n    Malicious users could trick gocryptfs into modifying files outside of `CIPHERDIR`,\n\tor reading files inside `CIPHERDIR` that they should not have access to.\n  * If you do not use `-plaintextnames` (disabled per default), these attacks do\n    not work as symlinks are encrypted.\n  * Forward mode has been reworked to use the \"\\*at\" family of system calls everywhere\n    (`Openat/Unlinkat/Symlinkat/...`).\n  * As a result, gocryptfs may run slightly slower, as the caching logic has been\n    replaced and is very simple at the moment.\n  * The possibility for such attacks was found during an internal code review.\n* Reverse mode: fix excluded, unaccessible files showing up in directory listings\n  ([#285](https://github.com/rfjakob/gocryptfs/issues/285),\n  [#286](https://github.com/rfjakob/gocryptfs/issues/286))\n* gocryptfs-xray: add `-aessiv` flag for correctly parsing AES-SIV format files\n  ([#299](https://github.com/rfjakob/gocryptfs/issues/299))\n* Ensure that standard fds 0,1,2 are always initialized\n  ([#320](https://github.com/rfjakob/gocryptfs/issues/320)).\n  Prevents trouble in the unlikely case that gocryptfs is called with\n  stdin,stdout and/or stderr closed.\n* `-extpass` now can be specified multiple times to support arguments containing spaces\n  ([#289](https://github.com/rfjakob/gocryptfs/issues/289))\n* Drop Fstatat, Mkdirat, Syslinkat, Fchownat, Unlinkat, Renameat, Openat emulation of MacOS\n  and instead use native functions (thanks @slackner !)\n* Use `Setreuid` to robustly set the owner with allow_other (@slackner,\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/03b9d65cce53fb95b7d489ecd03d0853b9b923fb)))\n* Pack the rendered man page into the source code archive for user convenience\n  ([issue 355](https://github.com/rfjakob/gocryptfs/issues/355))\n* Disable Trezor support again (commit 16fac26c57ba303bf60266d24c17f5243e5ea376)\n  * Trezor support has been broken since Sept 2018 due to issues\n    in a third-party module ([#261](https://github.com/rfjakob/gocryptfs/issues/261))\n\n#### v1.6.1, 2018-12-12\n* Fix \"Operation not supported\" chmod errors on Go 1.11\n  ([#271](https://github.com/rfjakob/gocryptfs/issues/271))\n\n#### v1.6, 2018-08-18\n* **Add `-e` / `-exclude` option** for reverse mode\n  ([#235](https://github.com/rfjakob/gocryptfs/issues/235),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/ec2fdc19cf9358ae7ba09c528a5807b6b0760f9b))\n* Add support for the Trezor One HSM [PR#247](https://github.com/rfjakob/gocryptfs/pull/247), thanks @xaionaro!\n  * Use `./build.bash -tags enable_trezor` to compile with Trezor support\n  * Then, use `gocryptfs -init -trezor` to create a filesystem locked with a physical Trezor device.\n  * Note 2021-01-31: Support was removed again in gocryptfs v1.7. Please use `-fido2` in gocryptfs v2.0.\n* Only print master key once, on init\n  ([#76](https://github.com/rfjakob/gocryptfs/issues/76),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/6d64dfe8f7acd8e9ca4a659d26318e442c2db85a))\n* Fall back to buffered IO even when passed `O_DIRECT`\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/893e41149ed353f355047003b89eeff456990e76))\n\n#### v1.5, 2018-06-12\n* **Support extended attributes (xattr)** in forward mode\n  ([#217](https://github.com/rfjakob/gocryptfs/issues/217)). Older gocryptfs versions\n  will ignore the extended attributes.\n* **Add `-fsck` function**\n  ([#191](https://github.com/rfjakob/gocryptfs/issues/191))\n* Fix clobbered timestamps on MacOS High Sierra\n  ([#229](https://github.com/rfjakob/gocryptfs/issues/229))\n* Add `-masterkey=stdin` functionality\n  ([#218](https://github.com/rfjakob/gocryptfs/issues/218))\n* Accept `-dev`/`-nodev`, `suid`/`nosuid`, `-exec`/`-noexec`,\n  `-ro`/`-rw` flags to make mounting via `/etc/fstab` possible.\n  Thanks @mahkoh! ([#233](https://github.com/rfjakob/gocryptfs/pull/233),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/53d6a9999dd0e4c31636d16179f284fff35a35d9),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/10212d791a3196c2c8705a7a3cccdeb14a8efdbe))\n* Fix a `logger` path issue on SuSE\n  [#225](https://github.com/rfjakob/gocryptfs/issues/225)\n* Stop printing the help text on a \"flag provided but not defined\"\n  error ([commit](https://github.com/rfjakob/gocryptfs/commit/5ad26495fc86527bbfe75ac6b46528d49a373676))\n\n#### v1.4.4, 2018-03-18\n* Overwrite secrets in memory with zeros as soon as possible\n  ([#211](https://github.com/rfjakob/gocryptfs/issues/211))\n* Fix Getdents problems on i386 and mips64le\n  ([#197](https://github.com/rfjakob/gocryptfs/issues/197),\n  [#200](https://github.com/rfjakob/gocryptfs/issues/200))\n* Make building with gccgo work\n  ([#201](https://github.com/rfjakob/gocryptfs/issues/201))\n* MacOS: fix `osxfuse: vnode changed generation` / `Error code -36` issue in go-fuse\n  ([#213](https://github.com/rfjakob/gocryptfs/issues/213),\n  [commit](https://github.com/hanwen/go-fuse/commit/a9ddcb8a4b609500fc59c89ccc9ee05f00a5fefd))\n* Fix various test issues on MacOS\n\n#### v1.4.3, 2018-01-21\n* **Fix several symlink race attacks** in connection with reverse mode\n  and allow_other. Thanks to @slackner for reporting and helping to fix\n  the issues:\n  * Fix symlink races in reverse mode\n    ([issue #165](https://github.com/rfjakob/gocryptfs/issues/165))\n  * Fix symlink races in connection with `-allow_other`\n    ([issue #177](https://github.com/rfjakob/gocryptfs/issues/177))\n* Fix problems with special names when using `-plaintextnames`\n  ([issue #174](https://github.com/rfjakob/gocryptfs/issues/174))\n* Add `-devrandom` command-line option\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/f3c777d5eaa682d878c638192311e52f9c204294))\n* Add `-sharedstorage` command-line option\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/e36a0ebf189a826aaa63909c5518c16356f5f903),\n  [issue #156](https://github.com/rfjakob/gocryptfs/issues/156))\n* MacOS: let OSXFuse create the mountpoint if it does not exist\n  ([issue #194](https://github.com/rfjakob/gocryptfs/issues/194))\n\n#### v1.4.2, 2017-11-01\n* Add `Gopkg.toml` file for `dep` vendoring and reproducible builds\n  ([issue #142](https://github.com/rfjakob/gocryptfs/issues/142))\n* MacOS: deal with `.DS_Store` files inside CIPHERDIR\n  ([issue #140](https://github.com/rfjakob/gocryptfs/issues/140))\n* Reverse mode: fix ENOENT error affecting names exactly 176 bytes long\n  ([issue #143](https://github.com/rfjakob/gocryptfs/issues/143))\n* Support kernels compiled with > 128 kiB FUSE request size (Synology NAS)\n  ([issue #145](https://github.com/rfjakob/gocryptfs/issues/145),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/4954c87979efaf5b8184efccc7d9a38c21e4209b))\n* Fix a startup hang when `$PATH` contains the mountpoint\n  ([issue #146](https://github.com/rfjakob/gocryptfs/issues/146))\n\n#### v1.4.1, 2017-08-21\n* **Use memory pools for buffer handling** (\n  [3c6fe98](https://github.com/rfjakob/gocryptfs/commit/3c6fe98),\n  [b2a23e9](https://github.com/rfjakob/gocryptfs/commit/b2a23e9),\n  [12c0101](https://github.com/rfjakob/gocryptfs/commit/12c0101))\n  * On my machine, this **doubles** the streaming read speed\n    (see [performance.txt](https://github.com/rfjakob/gocryptfs/blob/v1.4.1/Documentation/performance.txt#L38))\n* Implement and use the getdents(2) syscall for a more efficient\n  OpenDir implementation\n  ([e50a6a5](https://github.com/rfjakob/gocryptfs/commit/e50a6a5))\n* Purge masterkey from memory as soon as possible\n  ([issue #137](https://github.com/rfjakob/gocryptfs/issues/137))\n* Reverse mode: fix inode number collision between .name and .diriv\n  files\n  ([d12aa57](https://github.com/rfjakob/gocryptfs/commit/d12aa57))\n* Prevent the logger from holding stdout open\n  ([issue #130](https://github.com/rfjakob/gocryptfs/issues/130))\n* MacOS: make testing without openssl work properly\n  ([ccf1a84](https://github.com/rfjakob/gocryptfs/commit/ccf1a84))\n* MacOS: specify a volume name\n  ([9f8e19b](https://github.com/rfjakob/gocryptfs/commit/9f8e19b))\n* Enable writing to write-only files\n  ([issue #125](https://github.com/rfjakob/gocryptfs/issues/125))\n\n#### v1.4, 2017-06-20\n* **Switch to static binary releases**\n  * From gocryptfs v1.4, I will only release statically-built binaries.\n    These support all Linux distributions but cannot use OpenSSL.\n  * OpenSSL is still supported - just compile from source!\n* Add `-force_owner` option to allow files to be presented as owned by a\n  different user or group from the user running gocryptfs. Please see caveats\n  and guidance in the man page before using this functionality.\n* Increase open file limit to 4096 ([#82](https://github.com/rfjakob/gocryptfs/issues/82)).\n* Implement path decryption via ctlsock ([#84](https://github.com/rfjakob/gocryptfs/issues/84)).\n  Previously, decryption was only implemented for reverse mode. Now both\n  normal and reverse mode support both decryption and encryption of\n  paths via ctlsock.\n* Add more specific exit codes for the most common failure modes,\n  documented in [CLI_ABI.md](Documentation/CLI_ABI.md)\n* Reverse mode: make sure hard-linked files always return the same\n  ciphertext\n  ([commit 9ecf2d1a](https://github.com/rfjakob/gocryptfs/commit/9ecf2d1a3f69e3d995012073afe3fc664bd928f2))\n* Display a shorter, friendlier help text by default.\n* **Parallelize file content encryption** by splitting data blocks into two\n  threads ([ticket#116](https://github.com/rfjakob/gocryptfs/issues/116))\n* Prefetch random nonces in the background\n  ([commit 80516ed](https://github.com/rfjakob/gocryptfs/commit/80516ed3351477793eec882508969b6b29b69b0a))\n* Add `-info` option to pretty-print infos about a filesystem.\n\n#### v1.3, 2017-04-29\n* **Use HKDF to derive separate keys for GCM and EME**\n  * New feature flag: `HKDF` (enabled by default)\n  * This is a forwards-compatible change. gocryptfs v1.3 can mount\n   filesystems created by earlier versions but not the other way round.\n* **Enable Raw64 filename encoding by default (gets rid of trailing `==` characters)**\n  * This is a forwards-compatible change. gocryptfs v1.3 can mount\n   filesystems created by earlier versions but not the other way round.\n* Drop Go 1.4 compatibility. You now need Go 1.5 (released 2015-08-19)\n  or higher to build gocryptfs.\n* Add `-serialize_reads` command-line option\n  * This can greatly improve performance on storage\n    that is very slow for concurrent out-of-order reads. Example:\n    Amazon Cloud Drive ([#92](https://github.com/rfjakob/gocryptfs/issues/92))\n* Reject file-header-only files\n  ([#90 2.2](https://github.com/rfjakob/gocryptfs/issues/90),\n  [commit](https://github.com/rfjakob/gocryptfs/commit/14038a1644f17f50b113a05d09a2a0a3b3e973b2))\n* Increase max password size to 2048 bytes ([#93](https://github.com/rfjakob/gocryptfs/issues/93))\n* Use stable 64-bit inode numbers in reverse mode\n  * This may cause problems for very old 32-bit applications\n    that were compiled without Large File Support.\n* Passing \"--\" now also blocks \"-o\" parsing\n\n#### v1.2.1, 2017-02-26\n* Add an integrated speed test, `gocryptfs -speed`\n* Limit password size to 1000 bytes and reject trailing garbage after the newline\n* Make the test suite work on [Mac OS X](https://github.com/rfjakob/gocryptfs/issues/15)\n* Handle additional corner cases in `-ctlsock` path sanitization\n* Use dedicated exit code 12 on \"password incorrect\"\n\n#### v1.2, 2016-12-04\n* Add a control socket interface. Allows to encrypt and decrypt filenames.\n  For details see [backintime#644](https://github.com/bit-team/backintime/issues/644#issuecomment-259835183).\n  * New command-line option: `-ctlsock`\n* Under certain circumstances, concurrent truncate and read could return\n  an I/O error. This is fixed by introducing a global open file table\n  that stores the file IDs\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/0489d08ae21107990d0efd0685443293aa26b35f)).\n* Coalesce 4kB ciphertext block writes up to the size requested through\n  the write FUSE call\n  ([commit with benchmarks](https://github.com/rfjakob/gocryptfs/commit/024511d9c71558be4b1169d6bb43bd18d65539e0))\n* Add `-noprealloc` command-line option\n  * Greatly speeds up writes on Btrfs\n    ([#63](https://github.com/rfjakob/gocryptfs/issues/63))\n    at the cost of reduced out-of-space robustness.\n  * This is a workaround for Btrfs' slow fallocate(2)\n* Preserve owner for symlinks an device files (fixes bug [#64](https://github.com/rfjakob/gocryptfs/issues/64))\n* Include rendered man page `gocryptfs.1` in the release tarball\n\n#### v1.1.1, 2016-10-30\n* Fix a panic on setting file timestamps ([go-fuse#131](https://github.com/hanwen/go-fuse/pull/131))\n* Work around an issue in tmpfs that caused a panic in xfstests generic/075\n  ([gocryptfs#56](https://github.com/rfjakob/gocryptfs/issues/56))\n* Optimize NFS streaming writes\n  ([commit](https://github.com/rfjakob/gocryptfs/commit/a08d55f42d5b11e265a8617bee16babceebfd026))\n\n#### v1.1, 2016-10-19\n* **Add reverse mode ([#19](https://github.com/rfjakob/gocryptfs/issues/19))**\n  * AES-SIV (RFC5297) encryption to implement deterministic encryption\n    securely. Uses the excellent\n    [jacobsa/crypto](https://github.com/aperturerobotics/jacobsa-crypto) library.\n    The corresponding feature flag is called `AESSIV`.\n  * New command-line options: `-reverse`, `-aessiv`\n  * Filesystems using reverse mode can only be mounted with gocryptfs v1.1\n    and later.\n  * The default, forward mode, stays fully compatible with older versions.\n    Forward mode will keep using GCM because it is much faster.\n* Accept `-o foo,bar,baz`-style options that are passed at the end of\n  the command-line, like mount(1) does. All other options must still\n  precede the passed paths.\n  * This allows **mounting from /etc/fstab**. See\n    [#45](https://github.com/rfjakob/gocryptfs/issues/45) for details.\n  * **Mounting on login using pam_mount** works as well. It is\n    [described in the wiki](https://github.com/rfjakob/gocryptfs/wiki/Mounting-on-login-using-pam_mount).\n* To prevent confusion, the old `-o` option had to be renamed. It is now\n  called `-ko`. Arguments to `-ko` are passed directly to the kernel.\n* New `-passfile` command-line option. Provides an easier way to read\n  the password from a file. Internally, this is equivalent to\n  `-extpass \"/bin/cat FILE\"`.\n* Enable changing the password when you only know the master key\n  ([#28](https://github.com/rfjakob/gocryptfs/issues/28))\n\n#### v1.0, 2016-07-17\n* Deprecate very old filesystems, stage 3/3\n  * Filesystems created by v0.6 can no longer be mounted\n  * Drop command-line options `-gcmiv128`, `-emenames`, `-diriv`. These\n    are now always enabled.\n* Add fallocate(2) support\n* New command-line option `-o`\n  * Allows to pass mount options directly to the kernel\n* Add support for device files and suid binaries\n  * Only works when running as root\n  * Must be explicitly enabled by passing \"-o dev\" or \"-o suid\" or \"-o suid,dev\"\n* Experimental Mac OS X support. See\n  [ticket #15](https://github.com/rfjakob/gocryptfs/issues/15) for details.\n\n#### v0.12, 2016-06-19\n* Deprecate very old filesystems, stage 2/3\n  * Filesystems created by v0.6 and older can only be mounted read-only\n  * A [message](https://github.com/rfjakob/gocryptfs/blob/v0.12/internal/configfile/config_file.go#L120)\n    explaining the situation is printed as well\n* New command line option: `-ro`\n  * Mounts the filesystem read-only\n* Accept password from stdin as well ([ticket #30](https://github.com/rfjakob/gocryptfs/issues/30))\n\n#### v0.11, 2016-06-10\n* Deprecate very old filesystems, stage 1/3\n  * Filesystems created by v0.6 and older can still be mounted but a\n    [warning](https://github.com/rfjakob/gocryptfs/blob/v0.11/internal/configfile/config_file.go#L120)\n    is printed\n  * See [ticket #29](https://github.com/rfjakob/gocryptfs/issues/29) for details and\n    join the discussion\n* Add rsync stress test \"pingpong-rsync.bash\"\n  * Fix chown and utimens failures that caused rsync to complain\n* Build release binaries with Go 1.6.2\n  * Big speedup for CPUs with AES-NI, see [ticket #23](https://github.com/rfjakob/gocryptfs/issues/23)\n\n#### v0.10, 2016-05-30\n* **Replace `spacemonkeygo/openssl` with `stupidgcm`**\n  * gocryptfs now has its own thin wrapper to OpenSSL's GCM implementation\n    called `stupidgcm`.\n  * This should fix the [compile issues](https://github.com/rfjakob/gocryptfs/issues/21)\n    people are seeing with `spacemonkeygo/openssl`. It also gets us\n    a 20% performance boost for streaming writes.\n* **Automatically choose between OpenSSL and Go crypto** [issue #23](https://github.com/rfjakob/gocryptfs/issues/23)\n  * Go 1.6 added an optimized GCM implementation in amd64 assembly that uses AES-NI.\n    This is faster than OpenSSL and is used if available. In all other\n    cases OpenSSL is much faster and is used instead.\n  * `-openssl=auto` is the new default\n  * Passing `-openssl=true/false` overrides the autodetection.\n* Warn but continue anyway if fallocate(2) is not supported by the\n  underlying filesystem, see [issue #22](https://github.com/rfjakob/gocryptfs/issues/22)\n  * Enables to use gocryptfs on ZFS and ext3, albeit with reduced out-of-space safety.\n* [Fix statfs](https://github.com/rfjakob/gocryptfs/pull/27), by @lxp\n* Fix a fsstress [failure](https://github.com/hanwen/go-fuse/issues/106)\n  in the go-fuse library.\n\n#### v0.9, 2016-04-10\n* **Long file name support**\n  * gocryptfs now supports file names up to 255 characters.\n  * This is a forwards-compatible change. gocryptfs v0.9 can mount filesystems\n   created by earlier versions but not the other way round.\n* Refactor gocryptfs into multiple \"internal\" packages\n* New command-line options:\n  * `-longnames`: Enable long file name support (default true)\n  * `-nosyslog`: Print messages to stdout and stderr instead of syslog (default false)\n  * `-wpanic`: Make warning messages fatal (used for testing)\n  * `-d`: Alias for `-debug`\n  * `-q`: Alias for `-quiet`\n\n#### v0.8, 2016-01-23\n* Redirect output to syslog when running in the background\n* New command-line option:\n  * `-memprofile`: Write a memory allocation debugging profile the specified\n    file\n\n#### v0.7.2, 2016-01-19\n* **Fix performance issue in small file creation**\n  * This brings performance on-par with EncFS paranoia mode, with streaming writes\n    significantly faster\n  * The actual [fix](https://github.com/hanwen/go-fuse/commit/c4b6b7949716d13eec856baffc7b7941ae21778c)\n    is in the go-fuse library. There are no code changes in gocryptfs.\n\n#### v0.7.1, 2016-01-09\n* Make the `build.bash` script compatible with Go 1.3\n* Disable fallocate on OSX (system call not available)\n* Introduce pre-built binaries for Fedora 23 and Debian 8\n\n#### v0.7, 2015-12-20\n* **Extend GCM IV size to 128 bit from Go's default of 96 bit**\n  * This pushes back the birthday bound to make IV collisions virtually\n    impossible\n  * This is a forwards-compatible change. gocryptfs v0.7 can mount filesystems\n    created by earlier versions but not the other way round.\n* New command-line option:\n  * `-gcmiv128`: Use 128-bit GCM IVs (default true)\n\n#### v0.6, 2015-12-08\n* **Wide-block filename encryption using EME + DirIV**\n  * EME (ECB-Mix-ECB) provides even better security than CBC as it fixes\n    the prefix leak. The used Go EME implementation is\n    https://github.com/rfjakob/eme which is, as far as I know, the first\n    implementation of EME in Go.\n  * This is a forwards-compatible change. gocryptfs v0.6 can mount filesystems\n    created by earlier versions but not the other way round.\n* New command-line option:\n  * `-emenames`: Enable EME filename encryption (default true)\n\n#### v0.5.1, 2015-12-06\n* Fix a rename regression caused by DirIV and add test case\n* Use fallocate to guard against out-of-space errors\n\n#### v0.5, 2015-12-04\n* **Stronger filename encryption: DirIV**\n  * Each directory gets a random 128 bit file name IV on creation,\n    stored in `gocryptfs.diriv`\n  * This makes it impossible to identify identically-named files across\n    directories\n  * A single-entry IV cache brings the performance cost of DirIV close to\n    zero for common operations (see performance.txt)\n  * This is a forwards-compatible change. gocryptfs v0.5 can mount filesystems\n    created by earlier versions but not the other way round.\n* New command-line option:\n  * `-diriv`: Use the new per-directory IV file name encryption (default true)\n  * `-scryptn`: allows to set the scrypt cost parameter N. This option\n    can be used for faster mounting at the cost of lower brute-force\n    resistance. It was mainly added to speed up the automated tests.\n\n#### v0.4, 2015-11-15\n* New command-line options:\n  * `-plaintextnames`: disables filename encryption, added on user request\n  * `-extpass`: calls an external program for prompting for the password\n  * `-config`: allows to specify a custom gocryptfs.conf path\n* Add `FeatureFlags` gocryptfs.conf parameter\n  * This is a config format change, hence the on-disk format is incremented\n  * Used for ext4-style filesystem feature flags. This should help avoid future\n    format changes. The first user is `-plaintextnames`.\n* On-disk format 2\n\n#### v0.3, 2015-11-01\n* **Add a random 128 bit file header to authenticate file->block ownership**\n  * This is an on-disk-format change\n* On-disk format 1\n\n#### v0.2, 2015-10-11\n* Replace bash daemonization wrapper with native Go implementation\n* Better user feedback on mount failures\n\n#### v0.1, 2015-10-07\n* First release\n* On-disk format 0\n"
        },
        {
          "name": "benchmark-reverse.bash",
          "type": "blob",
          "size": 1.0498046875,
          "content": "#!/bin/bash -eu\n\n# Benchmark gocryptfs' reverse mode\n\ncd \"$(dirname \"$0\")\"\nMYNAME=$(basename \"$0\")\nsource tests/fuse-unmount.bash\n\n# Download /tmp/linux-3.0.tar.gz\n./tests/dl-linux-tarball.bash\n\ncd /tmp\nPLAIN=linux-3.0\n\nSIZE=0\nif [[ -d $PLAIN ]]; then\n\tSIZE=$(du -s --apparent-size \"$PLAIN\" | cut -f1)\nfi\n\n\nif [[ $SIZE -ne 412334 ]] ; then\n\techo \"Extracting linux-3.0.tar.gz\"\n\trm -Rf \"$PLAIN\"\n\ttar xf linux-3.0.tar.gz\nfi\n\nrm -f \"$PLAIN/.gocryptfs.reverse.conf\"\ngocryptfs -q -init -reverse -extpass=\"echo test\" -scryptn=10 \"$PLAIN\"\n\nMNT=$(mktemp -d /tmp/linux-3.0.reverse.mnt.XXX)\n\n# Cleanup trap\ntrap 'rm -f \"$PLAIN/.gocryptfs.reverse.conf\" ; fuse-unmount -z \"$MNT\" ; rmdir \"$MNT\"' EXIT\n\n# Mount\ngocryptfs -q -reverse -extpass=\"echo test\" \"$PLAIN\" \"$MNT\"\n\n# Execute command, discard all stdout output, print elapsed time\n# (to stderr, unfortunately).\netime() {\n\t# Make the bash builtin \"time\" print out only the elapse wall clock\n\t# seconds\n\tTIMEFORMAT=%R\n\ttime \"$@\" > /dev/null\n}\n\necho -n \"LS:  \"\netime ls -lR \"$MNT\"\necho -n \"CAT: \"\netime find \"$MNT\" -type f -exec cat {} +\n"
        },
        {
          "name": "benchmark.bash",
          "type": "blob",
          "size": 2.013671875,
          "content": "#!/bin/bash -eu\n\n# Run the set of \"canonical\" benchmarks that are shown on\n# https://nuetzlich.net/gocryptfs/comparison/\n\ncd \"$(dirname \"$0\")\"\nMYNAME=$(basename \"$0\")\nsource tests/fuse-unmount.bash\n\nusage() {\n\techo \"Usage: $MYNAME [-encfs] [-openssl=true] [-openssl=false] [-dd] [DIR]\"\n}\n\nOPT_ENCFS=0\nOPT_LOOPBACK=0\nOPT_OPENSSL=\"\"\nOPT_DIR=\"\"\nDD_ONLY=\"\"\nOPT_XCHACHA=\"\"\n\nwhile [[ $# -gt 0 ]] ; do\n\tcase $1 in\n\t\t-h)\n\t\t\tusage\n\t\t\texit 1\n\t\t\t;;\n\t\t-encfs)\n\t\t\tOPT_ENCFS=1\n\t\t\t;;\n\t\t-openssl=true)\n\t\t\tOPT_OPENSSL=\"-openssl=true\"\n\t\t\t;;\n\t\t-openssl=false)\n\t\t\tOPT_OPENSSL=\"-openssl=false\"\n\t\t\t;;\n\t\t-dd)\n\t\t\tDD_ONLY=1\n\t\t\t;;\n\t\t-loopback)\n\t\t\tOPT_LOOPBACK=1\n\t\t\t;;\n\t\t-xchacha)\n\t\t\tOPT_XCHACHA=\"-xchacha\"\n\t\t\t;;\n\t\t-*)\n\t\t\techo \"Invalid option: $1\"\n\t\t\tusage\n\t\t\texit 2\n\t\t\t;;\n\t\t*)\n\t\t\tif [[ -n $OPT_DIR ]] ; then\n\t\t\t\techo \"Duplicate DIR argument: $1\"\n\t\t\t\tusage\n\t\t\t\texit 3\n\t\t\tfi\n\t\t\tOPT_DIR=$1\n\t\t\t;;\n\tesac\n\tshift\ndone\n\nif [[ -z $OPT_DIR ]] ; then\n\tOPT_DIR=/tmp\nfi\n\n# Create directories\nCRYPT=$(mktemp -d \"$OPT_DIR/$MYNAME.XXX\")\nMNT=$CRYPT.mnt\nmkdir \"$MNT\"\n\n# Mount\nif [[ $OPT_ENCFS -eq 1 ]]; then\n\tif [[ -n $OPT_OPENSSL ]] ; then\n\t\techo \"The option $OPT_OPENSSL only works with gocryptfs\"\n\t\texit 1\n\tfi\n\techo -n \"Testing EncFS at $CRYPT: \"\n\tencfs --version\n\tencfs --extpass=\"echo test\" --standard \"$CRYPT\" \"$MNT\" > /dev/null\nelif [[ $OPT_LOOPBACK -eq 1 ]]; then\n\techo \"Testing go-fuse loopback\"\n\t\"$HOME/go/src/github.com/hanwen/go-fuse/example/loopback/loopback\" \"$MNT\" \"$CRYPT\" &\n\tsleep 0.5\nelse\n\techo -n \"Testing gocryptfs $OPT_XCHACHA $OPT_OPENSSL at $CRYPT: \"\n\tgocryptfs -version\n\tgocryptfs $OPT_XCHACHA -q -init -extpass=\"echo test\" -scryptn=10 \"$CRYPT\"\n\tgocryptfs $OPT_OPENSSL -q -extpass=\"echo test\" \"$CRYPT\" \"$MNT\"\nfi\n\n# Make sure we have actually mounted something\nif ! mountpoint \"$MNT\" ; then\n\texit 1\nfi\n\n# Cleanup trap\ntrap 'cd /; fuse-unmount -z \"$MNT\"; rm -rf \"$CRYPT\" \"$MNT\"' EXIT\n\n# Benchmarks\nif [[ $DD_ONLY -eq 1 ]]; then\n\techo -n \"WRITE: \"\n\tdd if=/dev/zero \"of=$MNT/zero\" bs=131072 count=20000 2>&1 | tail -n 1\n\trm \"$MNT/zero\"\nelse\n\t./tests/canonical-benchmarks.bash \"$MNT\"\nfi\n"
        },
        {
          "name": "build-without-openssl.bash",
          "type": "blob",
          "size": 0.2119140625,
          "content": "#!/bin/bash -eu\n\ncd \"$(dirname \"$0\")\"\n\nCGO_ENABLED=0 source ./build.bash -tags without_openssl\n\nif ldd gocryptfs 2> /dev/null ; then\n\techo \"build-without-openssl.bash: error: compiled binary is not static\"\n\texit 1\nfi\n"
        },
        {
          "name": "build.bash",
          "type": "blob",
          "size": 2.974609375,
          "content": "#!/bin/bash -eu\n#\n# Compile gocryptfs and bake the git version string of itself and the go-fuse\n# library into the binary.\n#\n# If you want to fake a build date to reproduce a specific build,\n# you can use:\n#  BUILDDATE=2017-02-03 ./build.bash\n# or\n#  SOURCE_DATE_EPOCH=1544192417 ./build.bash\n# .\n\ncd \"$(dirname \"$0\")\"\n\n# $0 does not work because we may have been sourced\nMYNAME=build.bash\n\n# Make sure we have the go binary\ngo version > /dev/null\n\n# GOPATH may contain multiple paths separated by \":\"\nGOPATH1=$(go env GOPATH | cut -f1 -d:)\n\n# gocryptfs version according to git or a VERSION file\nif [[ -d .git ]] ; then\n\tGITVERSION=$(git describe --tags --dirty || echo \"[no_tags_found]\")\n\tGITBRANCH=$(git rev-parse --abbrev-ref HEAD)\n\tif [[ -n $GITBRANCH && $GITBRANCH != master ]] ; then\n\t\tGITVERSION=\"$GITVERSION.$GITBRANCH\"\n\tfi\nelif [[ -f VERSION ]] ; then\n\tGITVERSION=$(cat VERSION)\nelse\n\techo \"$MYNAME: warning: could not determine gocryptfs version\"\n\tGITVERSION=\"[unknown]\"\nfi\n\n# go-fuse version, if available\nif [[ -d vendor/github.com/hanwen/go-fuse ]] ; then\n\tGITVERSIONFUSE=\"[vendored]\"\nelse\n\t# go-fuse version according to Go Modules\n\tFAIL=0\n\tOUT=$(go list -m github.com/hanwen/go-fuse/v2 | cut -d' ' -f2-) || FAIL=1\n\tif [[ $FAIL -eq 0 ]]; then\n\t\tGITVERSIONFUSE=$OUT\n\telse\n\t\techo \"$MYNAME: warning: could not determine go-fuse version\"\n\t\tGITVERSIONFUSE=\"[unknown]\"\n\tfi\nfi\n\n# Build date, something like \"2017-09-06\". Don't override BUILDDATE\n# if it is already set. This may be done for reproducible builds.\nif [[ -z ${BUILDDATE:-} ]] ; then\n\tBUILDDATE=$(date +%Y-%m-%d)\nfi\n\n# If SOURCE_DATE_EPOCH is set, it overrides BUILDDATE. This is the\n# standard environment variable for faking the date in reproducible builds.\nif [[ -n ${SOURCE_DATE_EPOCH:-} ]] ; then\n\tif ! BUILDDATE=$(date -u --date=\"@${SOURCE_DATE_EPOCH}\" +%Y-%m-%d) ; then\n\t\techo \"$MYNAME: info: retrying with BSD date syntax...\"\n\t\tBUILDDATE=$(date -u -r \"$SOURCE_DATE_EPOCH\" +%Y-%m-%d)\n\tfi\nfi\n\n# Only set GOFLAGS if it is not already set by the user\nif [[ -z ${GOFLAGS:-} ]] ; then\n\tGOFLAGS=\"-trimpath\"\n\t# Also, Fedora and Arch want pie enabled, so enable it.\n\t# * https://fedoraproject.org/wiki/Changes/golang-buildmode-pie\n\t# * https://github.com/rfjakob/gocryptfs/pull/460\n\t# But not with CGO_ENABLED=0 (https://github.com/golang/go/issues/30986)!\n\tif [[ ${CGO_ENABLED:-1} -ne 0 ]] ; then\n\t\tGOFLAGS=\"$GOFLAGS -buildmode=pie\"\n\tfi\n\texport GOFLAGS\nfi\n\nGO_LDFLAGS=\"-X \\\"main.GitVersion=$GITVERSION\\\" -X \\\"main.GitVersionFuse=$GITVERSIONFUSE\\\" -X \\\"main.BuildDate=$BUILDDATE\\\"\"\n\n# If LDFLAGS is set, add it as \"-extldflags\".\nif [[ -n ${LDFLAGS:-} ]] ; then\n\tGO_LDFLAGS=\"$GO_LDFLAGS \\\"-extldflags=$LDFLAGS\\\"\"\nfi\n\n# Set GOAMD64 version to v2\nexport GOAMD64=v2\n\n# Actual \"go build\" call for gocryptfs\ngo build \"-ldflags=$GO_LDFLAGS\" \"$@\"\n# Additional binaries\nfor d in gocryptfs-xray contrib/statfs contrib/findholes contrib/atomicrename ; do\n\t(cd \"$d\"; go build \"-ldflags=$GO_LDFLAGS\" \"$@\")\ndone\n\n./gocryptfs -version\n\nmkdir -p \"$GOPATH1/bin\"\ncp -af gocryptfs \"$GOPATH1/bin\"\n"
        },
        {
          "name": "cli_args.go",
          "type": "blob",
          "size": 14.138671875,
          "content": "package main\n\nimport (\n\t// Should be initialized before anything else.\n\t// This import line MUST be in the alphabetically first source code file of\n\t// package main!\n\t_ \"github.com/rfjakob/gocryptfs/v2/internal/ensurefds012\"\n\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tflag \"github.com/spf13/pflag\"\n\n\t\"github.com/hanwen/go-fuse/v2/fuse\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/configfile\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/stupidgcm\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// argContainer stores the parsed CLI options and arguments\ntype argContainer struct {\n\tdebug, init, zerokey, fusedebug, openssl, passwd, fg, version,\n\tplaintextnames, quiet, nosyslog, wpanic,\n\tlongnames, allow_other, reverse, aessiv, nonempty, raw64,\n\tnoprealloc, speed, hkdf, serialize_reads, hh, info,\n\tsharedstorage, fsck, one_file_system, deterministic_names,\n\txchacha bool\n\t// Mount options with opposites\n\tdev, nodev, suid, nosuid, exec, noexec, rw, ro, kernel_cache, acl bool\n\tmasterkey, mountpoint, cipherdir, cpuprofile,\n\tmemprofile, ko, ctlsock, fsname, force_owner, trace string\n\t// FIDO2\n\tfido2 string\n\tfido2_assert_options []string\n\t// -extpass, -badname, -passfile can be passed multiple times\n\textpass, badname, passfile []string\n\t// For reverse mode, several ways to specify exclusions. All can be specified multiple times.\n\texclude, excludeWildcard, excludeFrom []string\n\t// Configuration file name override\n\tconfig             string\n\tnotifypid, scryptn int\n\t// Idle time before autounmount\n\tidle time.Duration\n\t// -longnamemax (hash encrypted names that are longer than this)\n\tlongnamemax uint8\n\t// Helper variables that are NOT cli options all start with an underscore\n\t// _configCustom is true when the user sets a custom config file name.\n\t_configCustom bool\n\t// _ctlsockFd stores the control socket file descriptor (ctlsock stores the path)\n\t_ctlsockFd net.Listener\n\t// _forceOwner is, if non-nil, a parsed, validated Owner (as opposed to the string above)\n\t_forceOwner *fuse.Owner\n\t// _explicitScryptn is true then the user passed \"-scryptn=xyz\"\n\t_explicitScryptn bool\n}\n\nvar flagSet *flag.FlagSet\n\n// prefixOArgs transform options passed via \"-o foo,bar\" into regular options\n// like \"-foo -bar\" and prefixes them to the command line.\n// Testcases in TestPrefixOArgs().\nfunc prefixOArgs(osArgs []string) ([]string, error) {\n\t// Need at least 3, example: gocryptfs -o    foo,bar\n\t//                               ^ 0    ^ 1    ^ 2\n\tif len(osArgs) < 3 {\n\t\treturn osArgs, nil\n\t}\n\t// Passing \"--\" disables \"-o\" parsing. Ignore element 0 (program name).\n\tfor _, v := range osArgs[1:] {\n\t\tif v == \"--\" {\n\t\t\treturn osArgs, nil\n\t\t}\n\t}\n\t// Find and extract \"-o foo,bar\"\n\tvar otherArgs, oOpts []string\n\tfor i := 1; i < len(osArgs); i++ {\n\t\tif osArgs[i] == \"-o\" {\n\t\t\t// Last argument?\n\t\t\tif i+1 >= len(osArgs) {\n\t\t\t\treturn nil, fmt.Errorf(\"The \\\"-o\\\" option requires an argument\")\n\t\t\t}\n\t\t\toOpts = strings.Split(osArgs[i+1], \",\")\n\t\t\t// Skip over the arguments to \"-o\"\n\t\t\ti++\n\t\t} else if strings.HasPrefix(osArgs[i], \"-o=\") {\n\t\t\toOpts = strings.Split(osArgs[i][3:], \",\")\n\t\t} else {\n\t\t\totherArgs = append(otherArgs, osArgs[i])\n\t\t}\n\t}\n\t// Start with program name\n\tnewArgs := []string{osArgs[0]}\n\t// Add options from \"-o\"\n\tfor _, o := range oOpts {\n\t\tif o == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif o == \"o\" || o == \"-o\" {\n\t\t\ttlog.Fatal.Printf(\"You can't pass \\\"-o\\\" to \\\"-o\\\"\")\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\tnewArgs = append(newArgs, \"-\"+o)\n\t}\n\t// Add other arguments\n\tnewArgs = append(newArgs, otherArgs...)\n\treturn newArgs, nil\n}\n\n// convertToDoubleDash converts args like \"-debug\" (Go stdlib `flag` style)\n// into \"--debug\" (spf13/pflag style).\n// gocryptfs v2.1 switched from `flag` to `pflag`, but we obviously want to stay\n// cli-compatible, and this is the hack to do it.\n//\n// BUG: In `-extpass -X`, the `-X` gets transformed `--X`.\n// See \"Dash duplication\" in the man page and\n// https://github.com/rfjakob/gocryptfs/issues/621 .\nfunc convertToDoubleDash(osArgs []string) (out []string) {\n\tout = append(out, osArgs...)\n\tfor i, v := range out {\n\t\t// Leave \"-h\" alone so the help text keeps working\n\t\tif v == \"-h\" {\n\t\t\tcontinue\n\t\t}\n\t\t// Don't touch anything after \"--\"\n\t\tif v == \"--\" {\n\t\t\tbreak\n\t\t}\n\t\t// Convert \"-foo\" to \"--foo\"\n\t\tif len(v) >= 2 && v[0] == '-' && v[1] != '-' {\n\t\t\tout[i] = \"-\" + out[i]\n\t\t}\n\t}\n\treturn out\n}\n\n// parseCliOpts - parse command line options (i.e. arguments that start with \"-\")\nfunc parseCliOpts(osArgs []string) (args argContainer) {\n\tvar err error\n\tvar opensslAuto string\n\n\tosArgsPreprocessed, err := prefixOArgs(osArgs)\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\tosArgsPreprocessed = convertToDoubleDash(osArgsPreprocessed)\n\n\tflagSet = flag.NewFlagSet(tlog.ProgramName, flag.ContinueOnError)\n\tflagSet.Usage = func() {}\n\tflagSet.BoolVar(&args.debug, \"d\", false, \"\")\n\tflagSet.BoolVar(&args.debug, \"debug\", false, \"Enable debug output\")\n\tflagSet.BoolVar(&args.fusedebug, \"fusedebug\", false, \"Enable fuse library debug output\")\n\tflagSet.BoolVar(&args.init, \"init\", false, \"Initialize encrypted directory\")\n\tflagSet.BoolVar(&args.zerokey, \"zerokey\", false, \"Use all-zero dummy master key\")\n\t// Tri-state true/false/auto\n\tflagSet.StringVar(&opensslAuto, \"openssl\", \"auto\", \"Use OpenSSL instead of built-in Go crypto\")\n\tflagSet.BoolVar(&args.passwd, \"passwd\", false, \"Change password\")\n\tflagSet.BoolVar(&args.fg, \"f\", false, \"\")\n\tflagSet.BoolVar(&args.fg, \"fg\", false, \"Stay in the foreground\")\n\tflagSet.BoolVar(&args.version, \"version\", false, \"Print version and exit\")\n\tflagSet.BoolVar(&args.plaintextnames, \"plaintextnames\", false, \"Do not encrypt file names\")\n\tflagSet.BoolVar(&args.quiet, \"q\", false, \"\")\n\tflagSet.BoolVar(&args.quiet, \"quiet\", false, \"Quiet - silence informational messages\")\n\tflagSet.BoolVar(&args.nosyslog, \"nosyslog\", false, \"Do not redirect output to syslog when running in the background\")\n\tflagSet.BoolVar(&args.wpanic, \"wpanic\", false, \"When encountering a warning, panic and exit immediately\")\n\tflagSet.BoolVar(&args.longnames, \"longnames\", true, \"Store names longer than 175 bytes in extra files\")\n\tflagSet.BoolVar(&args.allow_other, \"allow_other\", false, \"Allow other users to access the filesystem. \"+\n\t\t\"Only works if user_allow_other is set in /etc/fuse.conf.\")\n\tflagSet.BoolVar(&args.reverse, \"reverse\", false, \"Reverse mode\")\n\tflagSet.BoolVar(&args.aessiv, \"aessiv\", false, \"AES-SIV encryption\")\n\tflagSet.BoolVar(&args.nonempty, \"nonempty\", false, \"Allow mounting over non-empty directories\")\n\tflagSet.BoolVar(&args.raw64, \"raw64\", true, \"Use unpadded base64 for file names\")\n\tflagSet.BoolVar(&args.noprealloc, \"noprealloc\", false, \"Disable preallocation before writing\")\n\tflagSet.BoolVar(&args.speed, \"speed\", false, \"Run crypto speed test\")\n\tflagSet.BoolVar(&args.hkdf, \"hkdf\", true, \"Use HKDF as an additional key derivation step\")\n\tflagSet.BoolVar(&args.serialize_reads, \"serialize_reads\", false, \"Try to serialize read operations\")\n\tflagSet.BoolVar(&args.hh, \"hh\", false, \"Show this long help text\")\n\tflagSet.BoolVar(&args.info, \"info\", false, \"Display information about CIPHERDIR\")\n\tflagSet.BoolVar(&args.sharedstorage, \"sharedstorage\", false, \"Make concurrent access to a shared CIPHERDIR safer\")\n\tflagSet.BoolVar(&args.fsck, \"fsck\", false, \"Run a filesystem check on CIPHERDIR\")\n\tflagSet.BoolVar(&args.one_file_system, \"one-file-system\", false, \"Don't cross filesystem boundaries\")\n\tflagSet.BoolVar(&args.deterministic_names, \"deterministic-names\", false, \"Disable diriv file name randomisation\")\n\tflagSet.BoolVar(&args.xchacha, \"xchacha\", false, \"Use XChaCha20-Poly1305 file content encryption\")\n\n\t// Mount options with opposites\n\tflagSet.BoolVar(&args.dev, \"dev\", false, \"Allow device files\")\n\tflagSet.BoolVar(&args.nodev, \"nodev\", false, \"Deny device files\")\n\tflagSet.BoolVar(&args.suid, \"suid\", false, \"Allow suid binaries\")\n\tflagSet.BoolVar(&args.nosuid, \"nosuid\", false, \"Deny suid binaries\")\n\tflagSet.BoolVar(&args.exec, \"exec\", false, \"Allow executables\")\n\tflagSet.BoolVar(&args.noexec, \"noexec\", false, \"Deny executables\")\n\tflagSet.BoolVar(&args.rw, \"rw\", false, \"Mount the filesystem read-write\")\n\tflagSet.BoolVar(&args.ro, \"ro\", false, \"Mount the filesystem read-only\")\n\tflagSet.BoolVar(&args.kernel_cache, \"kernel_cache\", false, \"Enable the FUSE kernel_cache option\")\n\tflagSet.BoolVar(&args.acl, \"acl\", false, \"Enforce ACLs\")\n\n\tflagSet.StringVar(&args.masterkey, \"masterkey\", \"\", \"Mount with explicit master key\")\n\tflagSet.StringVar(&args.cpuprofile, \"cpuprofile\", \"\", \"Write cpu profile to specified file\")\n\tflagSet.StringVar(&args.memprofile, \"memprofile\", \"\", \"Write memory profile to specified file\")\n\tflagSet.StringVar(&args.config, \"config\", \"\", \"Use specified config file instead of CIPHERDIR/gocryptfs.conf\")\n\tflagSet.StringVar(&args.ko, \"ko\", \"\", \"Pass additional options directly to the kernel, comma-separated list\")\n\tflagSet.StringVar(&args.ctlsock, \"ctlsock\", \"\", \"Create control socket at specified path\")\n\tflagSet.StringVar(&args.fsname, \"fsname\", \"\", \"Override the filesystem name\")\n\tflagSet.StringVar(&args.force_owner, \"force_owner\", \"\", \"uid:gid pair to coerce ownership\")\n\tflagSet.StringVar(&args.trace, \"trace\", \"\", \"Write execution trace to file\")\n\tflagSet.StringVar(&args.fido2, \"fido2\", \"\", \"Protect the masterkey using a FIDO2 token instead of a password\")\n\tflagSet.StringArrayVar(&args.fido2_assert_options, \"fido2-assert-option\", nil, \"Options to be passed with `fido2-assert -t`\")\n\n\t// Exclusion options\n\tflagSet.StringArrayVar(&args.exclude, \"e\", nil, \"Alias for -exclude\")\n\tflagSet.StringArrayVar(&args.exclude, \"exclude\", nil, \"Exclude relative path from reverse view\")\n\tflagSet.StringArrayVar(&args.excludeWildcard, \"ew\", nil, \"Alias for -exclude-wildcard\")\n\tflagSet.StringArrayVar(&args.excludeWildcard, \"exclude-wildcard\", nil, \"Exclude path from reverse view, supporting wildcards\")\n\tflagSet.StringArrayVar(&args.excludeFrom, \"exclude-from\", nil, \"File from which to read exclusion patterns (with -exclude-wildcard syntax)\")\n\n\t// multipleStrings options ([]string)\n\tflagSet.StringArrayVar(&args.extpass, \"extpass\", nil, \"Use external program for the password prompt\")\n\tflagSet.StringArrayVar(&args.badname, \"badname\", nil, \"Glob pattern invalid file names that should be shown\")\n\tflagSet.StringArrayVar(&args.passfile, \"passfile\", nil, \"Read password from file\")\n\n\tflagSet.Uint8Var(&args.longnamemax, \"longnamemax\", 255, \"Hash encrypted names that are longer than this\")\n\n\tflagSet.IntVar(&args.notifypid, \"notifypid\", 0, \"Send USR1 to the specified process after \"+\n\t\t\"successful mount - used internally for daemonization\")\n\tconst scryptn = \"scryptn\"\n\tflagSet.IntVar(&args.scryptn, scryptn, configfile.ScryptDefaultLogN, \"scrypt cost parameter logN. Possible values: 10-28. \"+\n\t\t\"A lower value speeds up mounting and reduces its memory needs, but makes the password susceptible to brute-force attacks\")\n\n\tflagSet.DurationVar(&args.idle, \"i\", 0, \"Alias for -idle\")\n\tflagSet.DurationVar(&args.idle, \"idle\", 0, \"Auto-unmount after specified idle duration (ignored in reverse mode). \"+\n\t\t\"Durations are specified like \\\"500s\\\" or \\\"2h45m\\\". 0 means stay mounted indefinitely.\")\n\n\tvar dummyString string\n\tflagSet.StringVar(&dummyString, \"o\", \"\", \"For compatibility with mount(1), options can be also passed as a comma-separated list to -o on the end.\")\n\n\t// Ignored flags\n\t{\n\t\tvar tmp bool\n\t\tflagSet.BoolVar(&tmp, \"nofail\", false, \"Ignored for /etc/fstab compatibility\")\n\t\tflagSet.BoolVar(&tmp, \"devrandom\", false, \"Obsolete, ignored for compatibility\")\n\t\tflagSet.BoolVar(&tmp, \"forcedecode\", false, \"Obsolete, ignored for compatibility\")\n\t}\n\n\t// Actual parsing\n\terr = flagSet.Parse(osArgsPreprocessed[1:])\n\tif err == flag.ErrHelp {\n\t\thelpShort()\n\t\tos.Exit(0)\n\t}\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"Invalid command line: %s: %v. Try '%s -help'.\", prettyArgs(), err, tlog.ProgramName)\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\t// We want to know if -scryptn was passed explicitly\n\tif isFlagPassed(flagSet, scryptn) {\n\t\targs._explicitScryptn = true\n\t}\n\t// \"-openssl\" needs some post-processing\n\tif opensslAuto == \"auto\" {\n\t\tif args.xchacha {\n\t\t\targs.openssl = stupidgcm.PreferOpenSSLXchacha20poly1305()\n\t\t} else {\n\t\t\targs.openssl = stupidgcm.PreferOpenSSLAES256GCM()\n\t\t}\n\t} else {\n\t\targs.openssl, err = strconv.ParseBool(opensslAuto)\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"Invalid \\\"-openssl\\\" setting: %v\", err)\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t}\n\tif len(args.extpass) > 0 && len(args.passfile) != 0 {\n\t\ttlog.Fatal.Printf(\"The options -extpass and -passfile cannot be used at the same time\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\tif len(args.passfile) != 0 && args.masterkey != \"\" {\n\t\ttlog.Fatal.Printf(\"The options -passfile and -masterkey cannot be used at the same time\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\tif len(args.extpass) > 0 && args.masterkey != \"\" && !args.init {\n\t\ttlog.Fatal.Printf(\"The options -extpass and -masterkey cannot be used at the same time\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\tif len(args.extpass) > 0 && args.fido2 != \"\" {\n\t\ttlog.Fatal.Printf(\"The options -extpass and -fido2 cannot be used at the same time\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\tif args.idle < 0 {\n\t\ttlog.Fatal.Printf(\"Idle timeout cannot be less than 0\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\t// Make sure all badname patterns are valid\n\tfor _, pattern := range args.badname {\n\t\t_, err := filepath.Match(pattern, \"\")\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"-badname: invalid pattern %q supplied\", pattern)\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t}\n\tif args.longnamemax > 0 && args.longnamemax < 62 {\n\t\ttlog.Fatal.Printf(\"-longnamemax: value %d is outside allowed range 62 ... 255\", args.longnamemax)\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\n\treturn args\n}\n\n// prettyArgs pretty-prints the command-line arguments.\nfunc prettyArgs() string {\n\tpa := fmt.Sprintf(\"%q\", os.Args)\n\t// Get rid of \"[\" and \"]\"\n\tpa = pa[1 : len(pa)-1]\n\treturn pa\n}\n\n// countOpFlags counts the number of operation flags we were passed.\nfunc countOpFlags(args *argContainer) int {\n\tvar count int\n\tif args.info {\n\t\tcount++\n\t}\n\tif args.passwd {\n\t\tcount++\n\t}\n\tif args.init {\n\t\tcount++\n\t}\n\tif args.fsck {\n\t\tcount++\n\t}\n\treturn count\n}\n\n// isFlagPassed finds out if the flag was explicitly passed on the command line.\n// https://stackoverflow.com/a/54747682/1380267\nfunc isFlagPassed(flagSet *flag.FlagSet, name string) bool {\n\tfound := false\n\tflagSet.Visit(func(f *flag.Flag) {\n\t\tif f.Name == name {\n\t\t\tfound = true\n\t\t}\n\t})\n\treturn found\n}\n"
        },
        {
          "name": "cli_args_test.go",
          "type": "blob",
          "size": 3.98046875,
          "content": "package main\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/stupidgcm\"\n)\n\n// TestPrefixOArgs checks that the \"-o x,y,z\" parsing works correctly.\nfunc TestPrefixOArgs(t *testing.T) {\n\ttestcases := []struct {\n\t\t// i is the input\n\t\ti []string\n\t\t// o is the expected output\n\t\to []string\n\t\t// Do we expect an error?\n\t\te bool\n\t}{\n\t\t{\n\t\t\ti: nil,\n\t\t\to: nil,\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\"},\n\t\t\to: []string{\"gocryptfs\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"-v\"},\n\t\t\to: []string{\"gocryptfs\", \"-v\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"-v\"},\n\t\t\to: []string{\"gocryptfs\", \"foo\", \"bar\", \"-v\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"-o\", \"a\"},\n\t\t\to: []string{\"gocryptfs\", \"-a\", \"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"-o\", \"a,b,xxxxx\"},\n\t\t\to: []string{\"gocryptfs\", \"-a\", \"-b\", \"-xxxxx\", \"foo\", \"bar\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"-d\", \"-o=a,b,xxxxx\"},\n\t\t\to: []string{\"gocryptfs\", \"-a\", \"-b\", \"-xxxxx\", \"foo\", \"bar\", \"-d\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"-oooo\", \"a,b,xxxxx\"},\n\t\t\to: []string{\"gocryptfs\", \"foo\", \"bar\", \"-oooo\", \"a,b,xxxxx\"},\n\t\t},\n\t\t// https://github.com/mhogomchungu/sirikali/blob/a36d91d3e39f0c1eb9a79680ed6c28ddb6568fa8/src/siritask.cpp#L192\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"-o\", \"rw\", \"--config\", \"fff\", \"ccc\", \"mmm\"},\n\t\t\to: []string{\"gocryptfs\", \"-rw\", \"--config\", \"fff\", \"ccc\", \"mmm\"},\n\t\t},\n\t\t// \"--\" should also block \"-o\" parsing.\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"--\", \"-o\", \"a\"},\n\t\t\to: []string{\"gocryptfs\", \"foo\", \"bar\", \"--\", \"-o\", \"a\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"--\", \"-o\", \"a\"},\n\t\t\to: []string{\"gocryptfs\", \"--\", \"-o\", \"a\"},\n\t\t},\n\t\t// This should error out\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\", \"bar\", \"-o\"},\n\t\t\te: true,\n\t\t},\n\t}\n\tfor _, tc := range testcases {\n\t\to, err := prefixOArgs(tc.i)\n\t\te := (err != nil)\n\t\tif !reflect.DeepEqual(o, tc.o) || e != tc.e {\n\t\t\tt.Errorf(\"\\n  in=%q\\nwant=%q err=%v\\n got=%q err=%v\", tc.i, tc.o, tc.e, o, e)\n\t\t}\n\t}\n}\n\nfunc TestConvertToDoubleDash(t *testing.T) {\n\ttestcases := []struct {\n\t\t// i is the input\n\t\ti []string\n\t\t// o is the expected output\n\t\to []string\n\t}{\n\t\t{\n\t\t\ti: nil,\n\t\t\to: nil,\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\"},\n\t\t\to: []string{\"gocryptfs\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"foo\"},\n\t\t\to: []string{\"gocryptfs\", \"foo\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"-v\", \"-quiet\"},\n\t\t\to: []string{\"gocryptfs\", \"--v\", \"--quiet\"},\n\t\t},\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"--\", \"-foo\"},\n\t\t\to: []string{\"gocryptfs\", \"--\", \"-foo\"},\n\t\t},\n\t}\n\tfor _, tc := range testcases {\n\t\to := convertToDoubleDash(tc.i)\n\t\tif !reflect.DeepEqual(o, tc.o) {\n\t\t\tt.Errorf(\"in=%q\\nwant=%q\\nhave=%q\", tc.i, tc.o, o)\n\t\t}\n\t}\n}\n\nfunc TestParseCliOpts(t *testing.T) {\n\tdefaultArgs := argContainer{\n\t\tlongnames:   true,\n\t\tlongnamemax: 255,\n\t\traw64:       true,\n\t\thkdf:        true,\n\t\topenssl:     stupidgcm.PreferOpenSSLAES256GCM(), // depends on CPU and build flags\n\t\tscryptn:     16,\n\t}\n\n\ttype testcaseContainer struct {\n\t\t// i is the input\n\t\ti []string\n\t\t// o is the expected output\n\t\to argContainer\n\t}\n\n\ttestcases := []testcaseContainer{\n\t\t{\n\t\t\ti: []string{\"gocryptfs\"},\n\t\t\to: defaultArgs,\n\t\t},\n\t}\n\n\to := defaultArgs\n\to.quiet = true\n\ttestcases = append(testcases, []testcaseContainer{\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"-q\"},\n\t\t\to: o,\n\t\t}, {\n\t\t\ti: []string{\"gocryptfs\", \"--q\"},\n\t\t\to: o,\n\t\t}, {\n\t\t\ti: []string{\"gocryptfs\", \"-quiet\"},\n\t\t\to: o,\n\t\t}, {\n\t\t\ti: []string{\"gocryptfs\", \"--quiet\"},\n\t\t\to: o,\n\t\t},\n\t}...)\n\n\to = defaultArgs\n\to.exclude = []string{\"foo\", \"bar\", \"baz,boe\"}\n\ttestcases = append(testcases, []testcaseContainer{\n\t\t{\n\t\t\ti: []string{\"gocryptfs\", \"-e\", \"foo\", \"-e\", \"bar\", \"-e\", \"baz,boe\"},\n\t\t\to: o,\n\t\t}, {\n\t\t\ti: []string{\"gocryptfs\", \"--exclude\", \"foo\", \"--exclude\", \"bar\", \"--exclude\", \"baz,boe\"},\n\t\t\to: o,\n\t\t}, /* TODO BROKEN {\n\t\t\ti: []string{\"gocryptfs\", \"--exclude\", \"foo\", \"-e\", \"bar\"},\n\t\t\to: o,\n\t\t},*/\n\t}...)\n\n\tfor _, tc := range testcases {\n\t\to := parseCliOpts(tc.i)\n\t\tif !reflect.DeepEqual(o, tc.o) {\n\t\t\tt.Errorf(\"in=%v\\nwant=%v\\nhave=%v\", tc.i, tc.o, o)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "codelingo.yaml",
          "type": "blob",
          "size": 0.1171875,
          "content": "tenets:\n- import: codelingo/effective-go\n- import: codelingo/code-review-comments\n- import: codelingo/rfjakob-gocryptfs\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "crossbuild.bash",
          "type": "blob",
          "size": 0.9150390625,
          "content": "#!/bin/bash\n#\n# Build on all supported architectures & operating systems\n\nfunction build {\n\t# Discard resulting binary by writing to /dev/null\n\tgo build -tags without_openssl -o /dev/null\n}\n\nfunction compile_tests {\n\tfor i in $(go list ./...) ; do\n\t\tgo test -c -tags without_openssl -o /dev/null \"$i\" > /dev/null\n\tdone\n}\n\nset -eux\n\nexport GO111MODULE=on\nexport CGO_ENABLED=0\n\nGOOS=linux  GOARCH=amd64         build\n\n# See https://github.com/golang/go/wiki/GoArm\nGOOS=linux  GOARCH=arm   GOARM=7 build\nGOOS=linux  GOARCH=arm64         build\n\n# MacOS on Intel\nGOOS=darwin GOARCH=amd64 build\n# Catch tests that don't work on MacOS (takes a long time so we only run it once)\ntime GOOS=darwin GOARCH=amd64 compile_tests\n\n# MacOS on Apple Silicon M1.\n# Go 1.16 added support for the M1 and added ios/arm64,\n# so we use this to check if we should attempt a build.\nif go tool dist list | grep ios/arm64 ; then\n\tGOOS=darwin GOARCH=arm64 build\nfi\n"
        },
        {
          "name": "ctlsock",
          "type": "tree",
          "content": null
        },
        {
          "name": "daemonize.go",
          "type": "blob",
          "size": 2.998046875,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"syscall\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/syscallcompat\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// The child sends us USR1 if the mount was successful. Exit with error code\n// 0 if we get it.\nfunc exitOnUsr1() {\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGUSR1)\n\tgo func() {\n\t\t<-c\n\t\tos.Exit(0)\n\t}()\n}\n\n// forkChild - execute ourselves once again, this time with the \"-fg\" flag, and\n// wait for SIGUSR1 or child exit.\n// This is a workaround for the missing true fork function in Go.\nfunc forkChild() int {\n\tname := os.Args[0]\n\t// Use the full path to our executable if we can get if from /proc.\n\tbuf := make([]byte, syscallcompat.PATH_MAX)\n\tn, err := syscall.Readlink(\"/proc/self/exe\", buf)\n\tif err == nil {\n\t\tname = string(buf[:n])\n\t\ttlog.Debug.Printf(\"forkChild: readlink worked: %q\", name)\n\t}\n\tnewArgs := []string{\"-fg\", fmt.Sprintf(\"-notifypid=%d\", os.Getpid())}\n\tnewArgs = append(newArgs, os.Args[1:]...)\n\tc := exec.Command(name, newArgs...)\n\tc.Stdout = os.Stdout\n\tc.Stderr = os.Stderr\n\tc.Stdin = os.Stdin\n\texitOnUsr1()\n\terr = c.Start()\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"forkChild: starting %s failed: %v\", name, err)\n\t\treturn exitcodes.ForkChild\n\t}\n\terr = c.Wait()\n\tif err != nil {\n\t\tif exiterr, ok := err.(*exec.ExitError); ok {\n\t\t\tif waitstat, ok := exiterr.Sys().(syscall.WaitStatus); ok {\n\t\t\t\tos.Exit(waitstat.ExitStatus())\n\t\t\t}\n\t\t}\n\t\ttlog.Fatal.Printf(\"forkChild: wait returned an unknown error: %v\", err)\n\t\treturn exitcodes.ForkChild\n\t}\n\t// The child exited with 0 - let's do the same.\n\treturn 0\n}\n\n// redirectStdFds redirects stderr and stdout to syslog; stdin to /dev/null\nfunc redirectStdFds() {\n\t// Create a pipe pair \"pw\" -> \"pr\" and start logger reading from \"pr\".\n\t// We do it ourselves instead of using StdinPipe() because we need access\n\t// to the fd numbers.\n\tpr, pw, err := os.Pipe()\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"redirectStdFds: could not create pipe: %v\\n\", err)\n\t\treturn\n\t}\n\ttag := fmt.Sprintf(\"gocryptfs-%d-logger\", os.Getpid())\n\tcmd := exec.Command(\"logger\", \"-t\", tag)\n\tcmd.Stdin = pr\n\terr = cmd.Start()\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"redirectStdFds: could not start logger: %v\\n\", err)\n\t\treturn\n\t}\n\t// The logger now reads on \"pr\". We can close it.\n\tpr.Close()\n\t// Redirect stout and stderr to \"pw\".\n\terr = syscallcompat.Dup3(int(pw.Fd()), 1, 0)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"redirectStdFds: stdout dup error: %v\\n\", err)\n\t}\n\tsyscallcompat.Dup3(int(pw.Fd()), 2, 0)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"redirectStdFds: stderr dup error: %v\\n\", err)\n\t}\n\t// Our stdout and stderr point to \"pw\". We can close the original copy.\n\tpw.Close()\n\t// Redirect stdin to /dev/null\n\tnullFd, err := os.Open(\"/dev/null\")\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"redirectStdFds: could not open /dev/null: %v\\n\", err)\n\t\treturn\n\t}\n\terr = syscallcompat.Dup3(int(nullFd.Fd()), 0, 0)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"redirectStdFds: stdin dup error: %v\\n\", err)\n\t}\n\tnullFd.Close()\n}\n"
        },
        {
          "name": "fsck.go",
          "type": "blob",
          "size": 8.7705078125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"sort\"\n\t\"sync\"\n\t\"syscall\"\n\n\t\"github.com/hanwen/go-fuse/v2/fuse\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/fusefrontend\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/syscallcompat\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\ntype fsckObj struct {\n\trootNode *fusefrontend.RootNode\n\t// mnt is the mountpoint of the temporary mount\n\tmnt string\n\t// List of corrupt files\n\tcorruptList []string\n\t// List of skipped files\n\tskippedList []string\n\t// Protects corruptList\n\tlistLock sync.Mutex\n\t// stop a running watchMitigatedCorruptions thread\n\twatchDone chan struct{}\n\t// Inode numbers of hard-linked files (Nlink > 1) that we have already checked\n\tseenInodes map[uint64]struct{}\n\t// abort the running fsck operation? Checked in a few long-running loops.\n\tabort bool\n}\n\nfunc runsAsRoot() bool {\n\treturn syscall.Geteuid() == 0\n}\n\nfunc (ck *fsckObj) markCorrupt(path string) {\n\tck.listLock.Lock()\n\tck.corruptList = append(ck.corruptList, path)\n\tck.listLock.Unlock()\n}\n\nfunc (ck *fsckObj) markSkipped(path string) {\n\tck.listLock.Lock()\n\tck.skippedList = append(ck.skippedList, path)\n\tck.listLock.Unlock()\n}\n\nfunc (ck *fsckObj) abs(relPath string) (absPath string) {\n\treturn filepath.Join(ck.mnt, relPath)\n}\n\n// Watch for mitigated corruptions that occur during OpenDir()\nfunc (ck *fsckObj) watchMitigatedCorruptionsOpenDir(path string) {\n\tfor {\n\t\tselect {\n\t\tcase item := <-ck.rootNode.MitigatedCorruptions:\n\t\t\tfmt.Printf(\"fsck: corrupt entry in dir %q: %q\\n\", path, item)\n\t\t\tck.markCorrupt(filepath.Join(path, item))\n\t\tcase <-ck.watchDone:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Recursively check dir for corruption\nfunc (ck *fsckObj) dir(relPath string) {\n\ttlog.Debug.Printf(\"ck.dir %q\\n\", relPath)\n\tck.xattrs(relPath)\n\t// Run OpenDir and catch transparently mitigated corruptions\n\tgo ck.watchMitigatedCorruptionsOpenDir(relPath)\n\tf, err := os.Open(ck.abs(relPath))\n\tck.watchDone <- struct{}{}\n\tif err != nil {\n\t\tfmt.Printf(\"fsck: error opening dir %q: %v\\n\", relPath, err)\n\t\tif err == os.ErrPermission && !runsAsRoot() {\n\t\t\tck.markSkipped(relPath)\n\t\t} else {\n\t\t\tck.markCorrupt(relPath)\n\t\t}\n\t\treturn\n\t}\n\tgo ck.watchMitigatedCorruptionsOpenDir(relPath)\n\tentries, err := f.Readdirnames(0)\n\tck.watchDone <- struct{}{}\n\tif err != nil {\n\t\tfmt.Printf(\"fsck: error reading dir %q: %v\\n\", relPath, err)\n\t\tck.markCorrupt(relPath)\n\t\treturn\n\t}\n\t// Sort alphabetically to make fsck runs deterministic\n\tsort.Strings(entries)\n\tfor _, entry := range entries {\n\t\tif ck.abort {\n\t\t\treturn\n\t\t}\n\t\tif entry == \".\" || entry == \"..\" {\n\t\t\tcontinue\n\t\t}\n\t\tnextPath := filepath.Join(relPath, entry)\n\t\tvar st syscall.Stat_t\n\t\terr := syscall.Lstat(ck.abs(nextPath), &st)\n\t\tif err != nil {\n\t\t\tck.markCorrupt(filepath.Join(relPath, entry))\n\t\t\tcontinue\n\t\t}\n\t\tfiletype := st.Mode & syscall.S_IFMT\n\t\t//fmt.Printf(\"  %q %x\\n\", entry.Name, entry.Mode)\n\t\tswitch filetype {\n\t\tcase syscall.S_IFDIR:\n\t\t\tck.dir(nextPath)\n\t\tcase syscall.S_IFREG:\n\t\t\tck.file(nextPath)\n\t\tcase syscall.S_IFLNK:\n\t\t\tck.symlink(nextPath)\n\t\tcase syscall.S_IFIFO, syscall.S_IFSOCK, syscall.S_IFBLK, syscall.S_IFCHR:\n\t\t\t// nothing to check\n\t\tdefault:\n\t\t\tfmt.Printf(\"fsck: unhandled file type %x\\n\", filetype)\n\t\t}\n\t}\n}\n\nfunc (ck *fsckObj) symlink(relPath string) {\n\t_, err := os.Readlink(ck.abs(relPath))\n\tif err != nil {\n\t\tck.markCorrupt(relPath)\n\t\tfmt.Printf(\"fsck: error reading symlink %q: %v\\n\", relPath, err)\n\t}\n}\n\n// Watch for mitigated corruptions that occur during Read()\nfunc (ck *fsckObj) watchMitigatedCorruptionsRead(path string) {\n\tfor {\n\t\tselect {\n\t\tcase item := <-ck.rootNode.MitigatedCorruptions:\n\t\t\tfmt.Printf(\"fsck: corrupt file %q (inode %s)\\n\", path, item)\n\t\t\tck.markCorrupt(path)\n\t\tcase <-ck.watchDone:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Check file for corruption\nfunc (ck *fsckObj) file(relPath string) {\n\ttlog.Debug.Printf(\"ck.file %q\\n\", relPath)\n\tvar st syscall.Stat_t\n\terr := syscall.Lstat(ck.abs(relPath), &st)\n\tif err != nil {\n\t\tck.markCorrupt(relPath)\n\t\tfmt.Printf(\"fsck: error stating file %q: %v\\n\", relPath, err)\n\t\treturn\n\t}\n\tif st.Nlink > 1 {\n\t\t// Due to hard links, we may have already checked this file.\n\t\tif _, ok := ck.seenInodes[st.Ino]; ok {\n\t\t\ttlog.Debug.Printf(\"ck.file : skipping %q (inode number %d already seen)\\n\", relPath, st.Ino)\n\t\t\treturn\n\t\t}\n\t\tck.seenInodes[st.Ino] = struct{}{}\n\t}\n\tck.xattrs(relPath)\n\tf, err := os.Open(ck.abs(relPath))\n\tif err != nil {\n\t\tfmt.Printf(\"fsck: error opening file %q: %v\\n\", relPath, err)\n\t\tif err == os.ErrPermission && !runsAsRoot() {\n\t\t\tck.markSkipped(relPath)\n\t\t} else {\n\t\t\tck.markCorrupt(relPath)\n\t\t}\n\t\treturn\n\t}\n\tdefer f.Close()\n\t// 128 kiB of zeros\n\tallZero := make([]byte, fuse.MAX_KERNEL_WRITE)\n\tbuf := make([]byte, fuse.MAX_KERNEL_WRITE)\n\tvar off int64\n\t// Read() through the whole file and catch transparently mitigated corruptions\n\tgo ck.watchMitigatedCorruptionsRead(relPath)\n\tdefer func() { ck.watchDone <- struct{}{} }()\n\tfor {\n\t\tif ck.abort {\n\t\t\treturn\n\t\t}\n\t\ttlog.Debug.Printf(\"ck.file: read %d bytes from offset %d\\n\", len(buf), off)\n\t\tn, err := f.ReadAt(buf, off)\n\t\tif err != nil && err != io.EOF {\n\t\t\tck.markCorrupt(relPath)\n\t\t\tfmt.Printf(\"fsck: error reading file %q (inum %d): %v\\n\", relPath, inum(f), err)\n\t\t\treturn\n\t\t}\n\t\t// EOF\n\t\tif err == io.EOF {\n\t\t\treturn\n\t\t}\n\t\toff += int64(n)\n\t\t// If we seem to be in the middle of a file hole, try to skip to the next\n\t\t// data section.\n\t\tdata := buf[:n]\n\t\tif bytes.Equal(data, allZero) {\n\t\t\ttlog.Debug.Printf(\"ck.file: trying to skip file hole\\n\")\n\t\t\tconst SEEK_DATA = 3\n\t\t\tnextOff, err := syscall.Seek(int(f.Fd()), off, SEEK_DATA)\n\t\t\tif err == nil {\n\t\t\t\toff = nextOff\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Watch for mitigated corruptions that occur during ListXAttr()\nfunc (ck *fsckObj) watchMitigatedCorruptionsListXAttr(path string) {\n\tfor {\n\t\tselect {\n\t\tcase item := <-ck.rootNode.MitigatedCorruptions:\n\t\t\tfmt.Printf(\"fsck: corrupt xattr name on file %q: %q\\n\", path, item)\n\t\t\tck.markCorrupt(path + \" xattr:\" + item)\n\t\tcase <-ck.watchDone:\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// Check xattrs on file/dir at path\nfunc (ck *fsckObj) xattrs(relPath string) {\n\t// Run ListXAttr() and catch transparently mitigated corruptions\n\tgo ck.watchMitigatedCorruptionsListXAttr(relPath)\n\tattrs, err := syscallcompat.Llistxattr(ck.abs(relPath))\n\tck.watchDone <- struct{}{}\n\tif err != nil {\n\t\tfmt.Printf(\"fsck: error listing xattrs on %q: %v\\n\", relPath, err)\n\t\tck.markCorrupt(relPath)\n\t\treturn\n\t}\n\t// Try to read all xattr values\n\tfor _, a := range attrs {\n\t\t_, err := syscallcompat.Lgetxattr(ck.abs(relPath), a)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"fsck: error reading xattr %q from %q: %v\\n\", a, relPath, err)\n\t\t\tif err == syscall.EACCES && !runsAsRoot() {\n\t\t\t\tck.markSkipped(relPath)\n\t\t\t} else {\n\t\t\t\tck.markCorrupt(relPath)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// entrypoint from main()\nfunc fsck(args *argContainer) (exitcode int) {\n\tif args.reverse {\n\t\ttlog.Fatal.Printf(\"Running -fsck with -reverse is not supported\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\targs.allow_other = false\n\targs.ro = true\n\tvar err error\n\targs.mountpoint, err = ioutil.TempDir(\"\", \"gocryptfs.fsck.\")\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"fsck: TmpDir: %v\", err)\n\t\tos.Exit(exitcodes.MountPoint)\n\t}\n\tpfs, wipeKeys := initFuseFrontend(args)\n\trn := pfs.(*fusefrontend.RootNode)\n\trn.MitigatedCorruptions = make(chan string)\n\tck := fsckObj{\n\t\tmnt:        args.mountpoint,\n\t\trootNode:   rn,\n\t\twatchDone:  make(chan struct{}),\n\t\tseenInodes: make(map[uint64]struct{}),\n\t}\n\tif args.quiet {\n\t\t// go-fuse throws a lot of these:\n\t\t//   writer: Write/Writev failed, err: 2=no such file or directory. opcode: INTERRUPT\n\t\t// This is ugly and causes failures in xfstests. Hide them away in syslog.\n\t\ttlog.SwitchLoggerToSyslog()\n\t}\n\t// Mount\n\tsrv := initGoFuse(pfs, args)\n\t// Handle SIGINT & SIGTERM\n\tch := make(chan os.Signal, 1)\n\tsignal.Notify(ch, os.Interrupt)\n\tsignal.Notify(ch, syscall.SIGTERM)\n\tgo func() {\n\t\t<-ch\n\t\tck.abort = true\n\t}()\n\tdefer func() {\n\t\terr = srv.Unmount()\n\t\tif err != nil {\n\t\t\ttlog.Warn.Printf(\"failed to unmount %q: %v\", ck.mnt, err)\n\t\t} else {\n\t\t\tif err := syscall.Rmdir(ck.mnt); err != nil {\n\t\t\t\ttlog.Warn.Printf(\"cleaning up %q failed: %v\", ck.mnt, err)\n\t\t\t}\n\t\t}\n\t}()\n\t// Recursively check the root dir\n\ttlog.Info.Println(tlog.ColorGreen + \"Checking filesystem...\" + tlog.ColorReset)\n\tck.dir(\"\")\n\t// Report results\n\twipeKeys()\n\tif ck.abort {\n\t\ttlog.Info.Printf(\"fsck: aborted\")\n\t\treturn exitcodes.Other\n\t}\n\tif len(ck.corruptList) == 0 && len(ck.skippedList) == 0 {\n\t\ttlog.Info.Printf(\"fsck summary: no problems found\\n\")\n\t\treturn 0\n\t}\n\tif len(ck.skippedList) > 0 {\n\t\ttlog.Warn.Printf(\"fsck: re-run this program as root to check all files!\\n\")\n\t}\n\tfmt.Printf(\"fsck summary: %d corrupt files, %d files skipped\\n\", len(ck.corruptList), len(ck.skippedList))\n\treturn exitcodes.FsckErrors\n}\n\nfunc inum(f *os.File) uint64 {\n\tvar st syscall.Stat_t\n\terr := syscall.Fstat(int(f.Fd()), &st)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"inum: fstat failed: %v\", err)\n\t\treturn 0\n\t}\n\treturn st.Ino\n}\n"
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.4189453125,
          "content": "module github.com/rfjakob/gocryptfs/v2\n\ngo 1.19\n\nrequire (\n\tgithub.com/aperturerobotics/jacobsa-crypto v1.0.2\n\tgithub.com/hanwen/go-fuse/v2 v2.5.0\n\tgithub.com/moby/sys/mountinfo v0.6.2\n\tgithub.com/pkg/xattr v0.4.9\n\tgithub.com/rfjakob/eme v1.1.2\n\tgithub.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06\n\tgithub.com/spf13/pflag v1.0.5\n\tgolang.org/x/crypto v0.18.0\n\tgolang.org/x/sys v0.16.0\n\tgolang.org/x/term v0.16.0\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 3.6572265625,
          "content": "github.com/aperturerobotics/jacobsa-crypto v1.0.2 h1:tNvVy1rev9FagnOyBmTcI6d23FfNceG9IujZROTRtlc=\ngithub.com/aperturerobotics/jacobsa-crypto v1.0.2/go.mod h1:buWU1iY+FjIcfpb1aYfFJZfl07WlS7O30lTyC2iwjv8=\ngithub.com/davecgh/go-spew v1.1.0 h1:ZDRjVQ15GmhC3fiQ8ni8+OwkZQO4DARzQgrnXU1Liz8=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/hanwen/go-fuse/v2 v2.5.0 h1:JSJcwHQ1V9EGRy6QsosoLDMX6HaLdzyLOJpKdPqDt9k=\ngithub.com/hanwen/go-fuse/v2 v2.5.0/go.mod h1:xKwi1cF7nXAOBCXujD5ie0ZKsxc8GGSA1rlMJc+8IJs=\ngithub.com/jacobsa/oglematchers v0.0.0-20150720000706-141901ea67cd h1:9GCSedGjMcLZCrusBZuo4tyKLpKUPenUUqi34AkuFmA=\ngithub.com/jacobsa/oglemock v0.0.0-20150831005832-e94d794d06ff h1:2xRHTvkpJ5zJmglXLRqHiZQNjUoOkhUyhTAhEQvPAWw=\ngithub.com/jacobsa/ogletest v0.0.0-20170503003838-80d50a735a11 h1:BMb8s3ENQLt5ulwVIHVDWFHp8eIXmbfSExkvdn9qMXI=\ngithub.com/jacobsa/reqtrace v0.0.0-20150505043853-245c9e0234cb h1:uSWBjJdMf47kQlXMwWEfmc864bA1wAC+Kl3ApryuG9Y=\ngithub.com/kylelemons/godebug v0.0.0-20170820004349-d65d576e9348 h1:MtvEpTB6LX3vkb4ax0b5D2DHbNAUsen0Gx5wZoq3lV4=\ngithub.com/kylelemons/godebug v0.0.0-20170820004349-d65d576e9348/go.mod h1:B69LEHPfb2qLo0BaaOLcbitczOKLWTsrBG9LczfCD4k=\ngithub.com/moby/sys/mountinfo v0.6.2 h1:BzJjoreD5BMFNmD9Rus6gdd1pLuecOFPt8wC+Vygl78=\ngithub.com/moby/sys/mountinfo v0.6.2/go.mod h1:IJb6JQeOklcdMU9F5xQ8ZALD+CUr5VlGpwtX+VE0rpI=\ngithub.com/pkg/xattr v0.4.9 h1:5883YPCtkSd8LFbs13nXplj9g9tlrwoJRjgpgMu1/fE=\ngithub.com/pkg/xattr v0.4.9/go.mod h1:di8WF84zAKk8jzR1UBTEWh9AUlIZZ7M/JNt8e9B6ktU=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rfjakob/eme v1.1.2 h1:SxziR8msSOElPayZNFfQw4Tjx/Sbaeeh3eRvrHVMUs4=\ngithub.com/rfjakob/eme v1.1.2/go.mod h1:cVvpasglm/G3ngEfcfT/Wt0GwhkuO32pf/poW6Nyk1k=\ngithub.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06 h1:OkMGxebDjyw0ULyrTYWeN0UNCCkmCWfjPnIA2W6oviI=\ngithub.com/sabhiram/go-gitignore v0.0.0-20210923224102-525f6e181f06/go.mod h1:+ePHsJ1keEjQtpvf9HHw0f4ZeJ0TLRsxhunSI2hYJSs=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.6.1 h1:hDPOHmpOpP40lSULcqw7IrRb/u7w6RpDC9399XyoNd0=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngolang.org/x/crypto v0.18.0 h1:PGVlW0xEltQnzFZ55hkuX5+KLyrMYhHld1YHO4AKcdc=\ngolang.org/x/crypto v0.18.0/go.mod h1:R0j02AL6hcrfOiy9T4ZYp/rcWeMxM3L6QYxlOuEG1mg=\ngolang.org/x/net v0.15.0 h1:ugBLEUaxABaB5AJqW9enI0ACdci2RUd4eP51NTBvuJ8=\ngolang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20220408201424-a24fb2fb8a0f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.16.0 h1:xWw16ngr6ZMtmxDyKyIgsE93KNKz5HKmMa3b8ALHidU=\ngolang.org/x/sys v0.16.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.16.0 h1:m+B6fahuftsE9qjo0VWp2FW0mB3MTJvR0BaMQrq0pmE=\ngolang.org/x/term v0.16.0/go.mod h1:yn7UURbUtPyrVJPGPq404EukNFxcm/foM+bV/bfcDsY=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c h1:dUUwHk2QECo/6vqA44rthZ8ie2QXMNeKRTHCNY2nXvo=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "gocryptfs-xray",
          "type": "tree",
          "content": null
        },
        {
          "name": "golint.bash",
          "type": "blob",
          "size": 0.3076171875,
          "content": "#!/bin/bash -u\n\nOUTPUT=$(\n\tgolint ./... | \\\n\t grep -v \"don't use an underscore in package name\" | \\\n\t grep -v \"don't use ALL_CAPS in Go names; use CamelCase\" |\n\t grep -v \"don't use underscores in Go names\"\n)\n\n# No output --> all good\nif [[ -z $OUTPUT ]] ; then\n\texit 0\nfi\n\necho \"golint.bash:\"\necho \"$OUTPUT\"\nexit 1\n"
        },
        {
          "name": "help.go",
          "type": "blob",
          "size": 2.03515625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\nconst tUsage = \"\" +\n\t\"Usage: \" + tlog.ProgramName + \" -init|-passwd|-info [OPTIONS] CIPHERDIR\\n\" +\n\t\"  or   \" + tlog.ProgramName + \" [OPTIONS] CIPHERDIR MOUNTPOINT\\n\"\n\n// helpShort is what gets displayed when passed \"-h\" or on syntax error.\nfunc helpShort() {\n\tprintVersion()\n\tfmt.Printf(\"\\n\")\n\tfmt.Printf(tUsage)\n\tfmt.Printf(`\nCommon Options (use -hh to show all):\n  -aessiv            Use AES-SIV encryption (with -init)\n  -allow_other       Allow other users to access the mount\n  -i, -idle          Unmount automatically after specified idle duration\n  -config            Custom path to config file\n  -ctlsock           Create control socket at location\n  -extpass           Call external program to prompt for the password\n  -fg                Stay in the foreground\n  -fsck              Check filesystem integrity\n  -fusedebug         Debug FUSE calls\n  -h, -help          This short help text\n  -hh                Long help text with all options\n  -init              Initialize encrypted directory\n  -info              Display information about encrypted directory\n  -masterkey         Mount with explicit master key instead of password\n  -nonempty          Allow mounting over non-empty directory\n  -nosyslog          Do not redirect log messages to syslog\n  -passfile          Read password from plain text file(s)\n  -passwd            Change password\n  -plaintextnames    Do not encrypt file names (with -init)\n  -q, -quiet         Silence informational messages\n  -reverse           Enable reverse mode\n  -ro                Mount read-only\n  -speed             Run crypto speed test\n  -version           Print version information\n  --                 Stop option parsing\n`)\n}\n\n// helpLong gets only displayed on \"-hh\"\nfunc helpLong() {\n\tprintVersion()\n\tfmt.Printf(\"\\n\")\n\tfmt.Printf(tUsage)\n\tfmt.Printf(`\nNotes: All options can equivalently use \"-\" (single dash) or \"--\" (double dash).\n       A standalone \"--\" stops option parsing.\n`)\n\tfmt.Printf(\"\\nOptions:\\n\")\n\tflagSet.PrintDefaults()\n}\n"
        },
        {
          "name": "info.go",
          "type": "blob",
          "size": 0.94140625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/configfile\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n)\n\n// info pretty-prints the contents of the config file at \"filename\" for human\n// consumption, stripping out sensitive data.\n// This is called when you pass the \"-info\" option.\nfunc info(filename string) {\n\tcf, err := configfile.Load(filename)\n\tif err != nil {\n\t\tfmt.Printf(\"Loading config file failed: %v\\n\", err)\n\t\tos.Exit(exitcodes.LoadConf)\n\t}\n\ts := cf.ScryptObject\n\talgo, _ := cf.ContentEncryption()\n\t// Pretty-print\n\tfmt.Printf(\"Creator:           %s\\n\", cf.Creator)\n\tfmt.Printf(\"FeatureFlags:      %s\\n\", strings.Join(cf.FeatureFlags, \" \"))\n\tfmt.Printf(\"EncryptedKey:      %dB\\n\", len(cf.EncryptedKey))\n\tfmt.Printf(\"ScryptObject:      Salt=%dB N=%d R=%d P=%d KeyLen=%d\\n\",\n\t\tlen(s.Salt), s.N, s.R, s.P, s.KeyLen)\n\tfmt.Printf(\"contentEncryption: %s\\n\", algo.Algo) // lowercase because not in JSON\n}\n"
        },
        {
          "name": "init_dir.go",
          "type": "blob",
          "size": 4.7275390625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"syscall\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/configfile\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/cryptocore\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/fido2\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/nametransform\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/readpassword\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/stupidgcm\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/syscallcompat\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// isEmptyDir checks if \"dir\" exists and is an empty directory.\n// Returns an *os.PathError if Stat() on the path fails.\nfunc isEmptyDir(dir string) error {\n\terr := isDir(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tentries, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(entries) == 0 {\n\t\treturn nil\n\t}\n\treturn fmt.Errorf(\"directory %s not empty\", dir)\n}\n\n// isDir checks if \"dir\" exists and is a directory.\nfunc isDir(dir string) error {\n\tfi, err := os.Stat(dir)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif !fi.IsDir() {\n\t\treturn fmt.Errorf(\"%s is not a directory\", dir)\n\t}\n\treturn nil\n}\n\n// initDir handles \"gocryptfs -init\". It prepares a directory for use as a\n// gocryptfs storage directory.\n// In forward mode, this means creating the gocryptfs.conf and gocryptfs.diriv\n// files in an empty directory.\n// In reverse mode, we create .gocryptfs.reverse.conf and the directory does\n// not need to be empty.\nfunc initDir(args *argContainer) {\n\tvar err error\n\tif args.reverse {\n\t\t_, err = os.Stat(args.config)\n\t\tif err == nil {\n\t\t\ttlog.Fatal.Printf(\"Config file %q already exists\", args.config)\n\t\t\tos.Exit(exitcodes.Init)\n\t\t}\n\t} else {\n\t\terr = isEmptyDir(args.cipherdir)\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"Invalid cipherdir: %v\", err)\n\t\t\tos.Exit(exitcodes.CipherDir)\n\t\t}\n\t\tif !args.xchacha && !stupidgcm.HasAESGCMHardwareSupport() {\n\t\t\ttlog.Info.Printf(tlog.ColorYellow +\n\t\t\t\t\"Notice: Your CPU does not have AES-GCM acceleration. Consider using -xchacha for better performance.\" +\n\t\t\t\ttlog.ColorReset)\n\t\t}\n\t}\n\t// Choose password for config file\n\tif len(args.extpass) == 0 && args.fido2 == \"\" {\n\t\ttlog.Info.Printf(\"Choose a password for protecting your files.\")\n\t}\n\t{\n\t\tvar password []byte\n\t\tvar fido2CredentialID, fido2HmacSalt []byte\n\t\tif args.fido2 != \"\" {\n\t\t\tfido2CredentialID = fido2.Register(args.fido2, filepath.Base(args.cipherdir))\n\t\t\tfido2HmacSalt = cryptocore.RandBytes(32)\n\t\t\tpassword = fido2.Secret(args.fido2, args.fido2_assert_options, fido2CredentialID, fido2HmacSalt)\n\t\t} else {\n\t\t\t// normal password entry\n\t\t\tpassword, err = readpassword.Twice([]string(args.extpass), []string(args.passfile))\n\t\t\tif err != nil {\n\t\t\t\ttlog.Fatal.Println(err)\n\t\t\t\tos.Exit(exitcodes.ReadPassword)\n\t\t\t}\n\t\t\tfido2CredentialID = nil\n\t\t\tfido2HmacSalt = nil\n\t\t}\n\t\tcreator := tlog.ProgramName + \" \" + GitVersion\n\t\terr = configfile.Create(&configfile.CreateArgs{\n\t\t\tFilename:           args.config,\n\t\t\tPassword:           password,\n\t\t\tPlaintextNames:     args.plaintextnames,\n\t\t\tLogN:               args.scryptn,\n\t\t\tCreator:            creator,\n\t\t\tAESSIV:             args.aessiv,\n\t\t\tFido2CredentialID:  fido2CredentialID,\n\t\t\tFido2HmacSalt:      fido2HmacSalt,\n\t\t\tFido2AssertOptions: args.fido2_assert_options,\n\t\t\tDeterministicNames: args.deterministic_names,\n\t\t\tXChaCha20Poly1305:  args.xchacha,\n\t\t\tLongNameMax:        args.longnamemax,\n\t\t\tMasterkey:          handleArgsMasterkey(args),\n\t\t})\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Println(err)\n\t\t\tos.Exit(exitcodes.WriteConf)\n\t\t}\n\t\tfor i := range password {\n\t\t\tpassword[i] = 0\n\t\t}\n\t\t// password runs out of scope here\n\t}\n\t// Forward mode with filename encryption enabled needs a gocryptfs.diriv file\n\t// in the root dir\n\tif !args.plaintextnames && !args.reverse && !args.deterministic_names {\n\t\t// Open cipherdir (following symlinks)\n\t\tdirfd, err := syscall.Open(args.cipherdir, syscall.O_DIRECTORY|syscallcompat.O_PATH, 0)\n\t\tif err == nil {\n\t\t\terr = nametransform.WriteDirIVAt(dirfd)\n\t\t\tsyscall.Close(dirfd)\n\t\t}\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Println(err)\n\t\t\tos.Exit(exitcodes.Init)\n\t\t}\n\t}\n\tmountArgs := \"\"\n\tfsName := \"gocryptfs\"\n\tif args.reverse {\n\t\tmountArgs = \" -reverse\"\n\t\tfsName = \"gocryptfs-reverse\"\n\t}\n\ttlog.Info.Printf(tlog.ColorGreen+\"The %s filesystem has been created successfully.\"+tlog.ColorReset,\n\t\tfsName)\n\twd, _ := os.Getwd()\n\tfriendlyPath, _ := filepath.Rel(wd, args.cipherdir)\n\tif strings.HasPrefix(friendlyPath, \"../\") {\n\t\t// A relative path that starts with \"../\" is pretty unfriendly, just\n\t\t// keep the absolute path.\n\t\tfriendlyPath = args.cipherdir\n\t}\n\tif strings.Contains(friendlyPath, \" \") {\n\t\tfriendlyPath = \"\\\"\" + friendlyPath + \"\\\"\"\n\t}\n\ttlog.Info.Printf(tlog.ColorGrey+\"You can now mount it using: %s%s %s MOUNTPOINT\"+tlog.ColorReset,\n\t\ttlog.ProgramName, mountArgs, friendlyPath)\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 8.818359375,
          "content": "// gocryptfs is an encrypted overlay filesystem written in Go.\n// See README.md ( https://github.com/rfjakob/gocryptfs/blob/master/README.md )\n// and the official website ( https://nuetzlich.net/gocryptfs/ ) for details.\npackage main\n\nimport (\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/hanwen/go-fuse/v2/fuse\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/configfile\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/contentenc\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/fido2\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/readpassword\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/speed\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// loadConfig loads the config file `args.config` and decrypts the masterkey,\n// or gets via the `-masterkey` or `-zerokey` command line options, if specified.\nfunc loadConfig(args *argContainer) (masterkey []byte, cf *configfile.ConfFile, err error) {\n\t// First check if the file can be read at all.\n\tcf, err = configfile.Load(args.config)\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"Cannot open config file: %v\", err)\n\t\treturn nil, nil, err\n\t}\n\t// The user may have passed the master key on the command line (probably because\n\t// he forgot the password).\n\tmasterkey = handleArgsMasterkey(args)\n\tif masterkey != nil {\n\t\treturn masterkey, cf, nil\n\t}\n\tvar pw []byte\n\tif cf.IsFeatureFlagSet(configfile.FlagFIDO2) {\n\t\tif args.fido2 == \"\" {\n\t\t\ttlog.Fatal.Printf(\"Masterkey encrypted using FIDO2 token; need to use the --fido2 option.\")\n\t\t\treturn nil, nil, exitcodes.NewErr(\"\", exitcodes.Usage)\n\t\t}\n\t\tpw = fido2.Secret(args.fido2, cf.FIDO2.AssertOptions, cf.FIDO2.CredentialID, cf.FIDO2.HMACSalt)\n\t} else {\n\t\tpw, err = readpassword.Once([]string(args.extpass), []string(args.passfile), \"\")\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Println(err)\n\t\t\treturn nil, nil, exitcodes.NewErr(\"\", exitcodes.ReadPassword)\n\t\t}\n\t}\n\ttlog.Info.Println(\"Decrypting master key\")\n\tmasterkey, err = cf.DecryptMasterKey(pw)\n\tfor i := range pw {\n\t\tpw[i] = 0\n\t}\n\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\treturn nil, nil, err\n\t}\n\treturn masterkey, cf, nil\n}\n\n// changePassword - change the password of config file \"filename\"\n// Does not return (calls os.Exit both on success and on error).\nfunc changePassword(args *argContainer) {\n\tvar confFile *configfile.ConfFile\n\t{\n\t\tvar masterkey []byte\n\t\tvar err error\n\t\tmasterkey, confFile, err = loadConfig(args)\n\t\tif err != nil {\n\t\t\texitcodes.Exit(err)\n\t\t}\n\t\tif len(masterkey) == 0 {\n\t\t\tlog.Panic(\"empty masterkey\")\n\t\t}\n\t\tif confFile.IsFeatureFlagSet(configfile.FlagFIDO2) {\n\t\t\ttlog.Fatal.Printf(\"Password change is not supported on FIDO2-enabled filesystems.\")\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\ttlog.Info.Println(\"Please enter your new password.\")\n\t\tnewPw, err := readpassword.Twice(nil, nil)\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Println(err)\n\t\t\tos.Exit(exitcodes.ReadPassword)\n\t\t}\n\t\tlogN := confFile.ScryptObject.LogN()\n\t\tif args._explicitScryptn {\n\t\t\tlogN = args.scryptn\n\t\t}\n\t\tconfFile.EncryptKey(masterkey, newPw, logN)\n\t\tfor i := range newPw {\n\t\t\tnewPw[i] = 0\n\t\t}\n\t\tfor i := range masterkey {\n\t\t\tmasterkey[i] = 0\n\t\t}\n\t\t// masterkey and newPw run out of scope here\n\t}\n\t// Are we resetting the password without knowing the old one using\n\t// \"-masterkey\"?\n\tif args.masterkey != \"\" {\n\t\tbak := args.config + \".bak\"\n\t\terr := os.Link(args.config, bak)\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"Could not create backup file: %v\", err)\n\t\t\tos.Exit(exitcodes.Init)\n\t\t}\n\t\ttlog.Info.Printf(tlog.ColorGrey+\n\t\t\t\"A copy of the old config file has been created at %q.\\n\"+\n\t\t\t\"Delete it after you have verified that you can access your files with the new password.\"+\n\t\t\ttlog.ColorReset, bak)\n\t}\n\terr := confFile.WriteFile()\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.WriteConf)\n\t}\n\ttlog.Info.Printf(tlog.ColorGreen + \"Password changed.\" + tlog.ColorReset)\n}\n\nfunc main() {\n\tmxp := runtime.GOMAXPROCS(0)\n\tif mxp < 4 && os.Getenv(\"GOMAXPROCS\") == \"\" {\n\t\t// On a 2-core machine, setting maxprocs to 4 gives 10% better performance.\n\t\t// But don't override an explicitly set GOMAXPROCS env variable.\n\t\truntime.GOMAXPROCS(4)\n\t}\n\t// mount(1) unsets PATH. Since exec.Command does not handle this case, we set\n\t// PATH to a default value if it's empty or unset.\n\tif os.Getenv(\"PATH\") == \"\" {\n\t\tos.Setenv(\"PATH\", \"/usr/sbin:/usr/bin:/sbin:/bin\")\n\t}\n\t// Show microseconds in go-fuse debug output (-fusedebug)\n\tlog.SetFlags(log.Lmicroseconds)\n\tvar err error\n\t// Parse all command-line options (i.e. arguments starting with \"-\")\n\t// into \"args\". Path arguments are parsed below.\n\targs := parseCliOpts(os.Args)\n\t// Fork a child into the background if \"-fg\" is not set AND we are mounting\n\t// a filesystem. The child will do all the work.\n\tif !args.fg && flagSet.NArg() == 2 {\n\t\tret := forkChild()\n\t\tos.Exit(ret)\n\t}\n\tif args.debug {\n\t\ttlog.Debug.Enabled = true\n\t}\n\ttlog.Debug.Printf(\"cli args: %q\", os.Args)\n\t// \"-v\"\n\tif args.version {\n\t\ttlog.Debug.Printf(\"openssl=%v\\n\", args.openssl)\n\t\ttlog.Debug.Printf(\"on-disk format %d\\n\", contentenc.CurrentVersion)\n\t\tprintVersion()\n\t\tos.Exit(0)\n\t}\n\t// \"-hh\"\n\tif args.hh {\n\t\thelpLong()\n\t\tos.Exit(0)\n\t}\n\t// \"-speed\"\n\tif args.speed {\n\t\tprintVersion()\n\t\tspeed.Run()\n\t\tos.Exit(0)\n\t}\n\tif args.wpanic {\n\t\ttlog.Warn.Wpanic = true\n\t\ttlog.Debug.Printf(\"Panicking on warnings\")\n\t}\n\t// Every operation below requires CIPHERDIR. Exit if we don't have it.\n\tif flagSet.NArg() == 0 {\n\t\tif flagSet.NFlag() == 0 {\n\t\t\t// Naked call to \"gocryptfs\". Just print the help text.\n\t\t\thelpShort()\n\t\t} else {\n\t\t\t// The user has passed some flags, but CIPHERDIR is missing. State\n\t\t\t// what is wrong.\n\t\t\ttlog.Fatal.Printf(\"CIPHERDIR argument is missing\")\n\t\t}\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\t// Check that CIPHERDIR exists\n\targs.cipherdir, _ = filepath.Abs(flagSet.Arg(0))\n\terr = isDir(args.cipherdir)\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"Invalid cipherdir: %v\", err)\n\t\tos.Exit(exitcodes.CipherDir)\n\t}\n\t// \"-q\"\n\tif args.quiet {\n\t\ttlog.Info.Enabled = false\n\t}\n\t// \"-reverse\" implies \"-aessiv\"\n\tif args.reverse {\n\t\targs.aessiv = true\n\t} else {\n\t\tif args.exclude != nil {\n\t\t\ttlog.Fatal.Printf(\"-exclude only works in reverse mode\")\n\t\t\tos.Exit(exitcodes.ExcludeError)\n\t\t}\n\t}\n\t// \"-config\"\n\tif args.config != \"\" {\n\t\targs.config, err = filepath.Abs(args.config)\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"Invalid \\\"-config\\\" setting: %v\", err)\n\t\t\tos.Exit(exitcodes.Init)\n\t\t}\n\t\ttlog.Info.Printf(\"Using config file at custom location %s\", args.config)\n\t\targs._configCustom = true\n\t} else if args.reverse {\n\t\targs.config = filepath.Join(args.cipherdir, configfile.ConfReverseName)\n\t} else {\n\t\targs.config = filepath.Join(args.cipherdir, configfile.ConfDefaultName)\n\t}\n\t// \"-force_owner\"\n\tif args.force_owner != \"\" {\n\t\tvar uidNum, gidNum int64\n\t\townerPieces := strings.SplitN(args.force_owner, \":\", 2)\n\t\tif len(ownerPieces) != 2 {\n\t\t\ttlog.Fatal.Printf(\"force_owner must be in form UID:GID\")\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\tuidNum, err = strconv.ParseInt(ownerPieces[0], 0, 32)\n\t\tif err != nil || uidNum < 0 {\n\t\t\ttlog.Fatal.Printf(\"force_owner: Unable to parse UID %v as positive integer\", ownerPieces[0])\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\tgidNum, err = strconv.ParseInt(ownerPieces[1], 0, 32)\n\t\tif err != nil || gidNum < 0 {\n\t\t\ttlog.Fatal.Printf(\"force_owner: Unable to parse GID %v as positive integer\", ownerPieces[1])\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\targs._forceOwner = &fuse.Owner{Uid: uint32(uidNum), Gid: uint32(gidNum)}\n\t}\n\t// \"-cpuprofile\"\n\tif args.cpuprofile != \"\" {\n\t\tonExitFunc := setupCpuprofile(args.cpuprofile)\n\t\tdefer onExitFunc()\n\t}\n\t// \"-memprofile\"\n\tif args.memprofile != \"\" {\n\t\tonExitFunc := setupMemprofile(args.memprofile)\n\t\tdefer onExitFunc()\n\t}\n\t// \"-trace\"\n\tif args.trace != \"\" {\n\t\tonExitFunc := setupTrace(args.trace)\n\t\tdefer onExitFunc()\n\t}\n\tif args.cpuprofile != \"\" || args.memprofile != \"\" || args.trace != \"\" {\n\t\ttlog.Info.Printf(\"Note: You must unmount gracefully, otherwise the profile file(s) will stay empty!\\n\")\n\t}\n\t// Operation flags\n\tnOps := countOpFlags(&args)\n\tif nOps == 0 {\n\t\t// Default operation: mount.\n\t\tif flagSet.NArg() != 2 {\n\t\t\tprettyArgs := prettyArgs()\n\t\t\ttlog.Info.Printf(\"Wrong number of arguments (have %d, want 2). You passed: %s\",\n\t\t\t\tflagSet.NArg(), prettyArgs)\n\t\t\ttlog.Fatal.Printf(\"Usage: %s [OPTIONS] CIPHERDIR MOUNTPOINT [-o COMMA-SEPARATED-OPTIONS]\", tlog.ProgramName)\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\tdoMount(&args)\n\t\t// Don't call os.Exit to give deferred functions a chance to run\n\t\treturn\n\t}\n\tif nOps > 1 {\n\t\ttlog.Fatal.Printf(\"At most one of -info, -init, -passwd, -fsck is allowed\")\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\tif flagSet.NArg() != 1 {\n\t\ttlog.Fatal.Printf(\"The options -info, -init, -passwd, -fsck take exactly one argument, %d given\",\n\t\t\tflagSet.NArg())\n\t\tos.Exit(exitcodes.Usage)\n\t}\n\t// \"-info\"\n\tif args.info {\n\t\tinfo(args.config)\n\t\tos.Exit(0)\n\t}\n\t// \"-init\"\n\tif args.init {\n\t\tinitDir(&args)\n\t\tos.Exit(0)\n\t}\n\t// \"-passwd\"\n\tif args.passwd {\n\t\tchangePassword(&args)\n\t\tos.Exit(0)\n\t}\n\t// \"-fsck\"\n\tif args.fsck {\n\t\tcode := fsck(&args)\n\t\tos.Exit(code)\n\t}\n}\n"
        },
        {
          "name": "masterkey.go",
          "type": "blob",
          "size": 2.0810546875,
          "content": "package main\n\nimport (\n\t\"encoding/hex\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/cryptocore\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/readpassword\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// unhexMasterKey - Convert a hex-encoded master key to binary.\n// Calls os.Exit on failure.\nfunc unhexMasterKey(masterkey string, fromStdin bool) []byte {\n\tmasterkey = strings.Replace(masterkey, \"-\", \"\", -1)\n\tkey, err := hex.DecodeString(masterkey)\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"Could not parse master key: %v\", err)\n\t\tos.Exit(exitcodes.MasterKey)\n\t}\n\tif len(key) != cryptocore.KeyLen {\n\t\ttlog.Fatal.Printf(\"Master key has length %d but we require length %d\", len(key), cryptocore.KeyLen)\n\t\tos.Exit(exitcodes.MasterKey)\n\t}\n\ttlog.Info.Printf(\"Using explicit master key.\")\n\tif !fromStdin {\n\t\ttlog.Info.Printf(tlog.ColorYellow +\n\t\t\t\"THE MASTER KEY IS VISIBLE VIA \\\"ps ax\\\" AND MAY BE STORED IN YOUR SHELL HISTORY!\\n\" +\n\t\t\t\"ONLY USE THIS MODE FOR EMERGENCIES\" + tlog.ColorReset)\n\t}\n\treturn key\n}\n\n// handleArgsMasterkey looks at `args.masterkey` and `args.zerokey`, gets the\n// masterkey from the source the user wanted (string on the command line, stdin, all-zero),\n// and returns it in binary. Returns nil if no masterkey source was specified.\nfunc handleArgsMasterkey(args *argContainer) (masterkey []byte) {\n\t// \"-masterkey=stdin\"\n\tif args.masterkey == \"stdin\" {\n\t\tin, err := readpassword.Once(nil, nil, \"Masterkey\")\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Println(err)\n\t\t\tos.Exit(exitcodes.ReadPassword)\n\t\t}\n\t\treturn unhexMasterKey(string(in), true)\n\t}\n\t// \"-masterkey=941a6029-3adc6a1c-...\"\n\tif args.masterkey != \"\" {\n\t\treturn unhexMasterKey(args.masterkey, false)\n\t}\n\t// \"-zerokey\"\n\tif args.zerokey {\n\t\ttlog.Info.Printf(\"Using all-zero dummy master key.\")\n\t\ttlog.Info.Printf(tlog.ColorYellow +\n\t\t\t\"ZEROKEY MODE PROVIDES NO SECURITY AT ALL AND SHOULD ONLY BE USED FOR TESTING.\" +\n\t\t\ttlog.ColorReset)\n\t\treturn make([]byte, cryptocore.KeyLen)\n\t}\n\t// No master key source specified on the command line. Caller must parse\n\t// the config file.\n\treturn nil\n}\n"
        },
        {
          "name": "mount.go",
          "type": "blob",
          "size": 18.9189453125,
          "content": "package main\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\t\"log/syslog\"\n\t\"math\"\n\t\"os\"\n\t\"os/exec\"\n\t\"os/signal\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strings\"\n\t\"sync/atomic\"\n\t\"syscall\"\n\t\"time\"\n\n\t\"golang.org/x/crypto/chacha20poly1305\"\n\n\t\"github.com/hanwen/go-fuse/v2/fs\"\n\t\"github.com/hanwen/go-fuse/v2/fuse\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/configfile\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/contentenc\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/cryptocore\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/ctlsocksrv\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/fusefrontend\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/fusefrontend_reverse\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/nametransform\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/openfiletable\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// AfterUnmount is called after the filesystem has been unmounted.\n// This can be used for cleanup and printing statistics.\ntype AfterUnmounter interface {\n\tAfterUnmount()\n}\n\n// doMount mounts an encrypted directory.\n// Called from main.\nfunc doMount(args *argContainer) {\n\t// Check mountpoint\n\tvar err error\n\targs.mountpoint, err = filepath.Abs(flagSet.Arg(1))\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"Invalid mountpoint: %v\", err)\n\t\tos.Exit(exitcodes.MountPoint)\n\t}\n\t// We cannot mount \"/home/user/.cipher\" at \"/home/user\" because the mount\n\t// will hide \".cipher\" also for us.\n\tif args.cipherdir == args.mountpoint || strings.HasPrefix(args.cipherdir, args.mountpoint+\"/\") {\n\t\ttlog.Fatal.Printf(\"Mountpoint %q would shadow cipherdir %q, this is not supported\",\n\t\t\targs.mountpoint, args.cipherdir)\n\t\tos.Exit(exitcodes.MountPoint)\n\t}\n\t// Reverse-mounting \"/foo\" at \"/foo/mnt\" means we would be recursively\n\t// encrypting ourselves.\n\tif strings.HasPrefix(args.mountpoint, args.cipherdir+\"/\") {\n\t\ttlog.Fatal.Printf(\"Mountpoint %q is contained in cipherdir %q, this is not supported\",\n\t\t\targs.mountpoint, args.cipherdir)\n\t\tos.Exit(exitcodes.MountPoint)\n\t}\n\tif args.nonempty {\n\t\terr = isDir(args.mountpoint)\n\t} else if strings.HasPrefix(args.mountpoint, \"/dev/fd/\") {\n\t\t// Magic fuse fd syntax, do nothing and let go-fuse figure it out.\n\t\t//\n\t\t// See https://github.com/libfuse/libfuse/commit/64e11073b9347fcf9c6d1eea143763ba9e946f70\n\t\t// and `drop_privileges` in `man mount.fuse3` for background.\n\t} else {\n\t\terr = isEmptyDir(args.mountpoint)\n\t\t// OSXFuse will create the mountpoint for us ( https://github.com/rfjakob/gocryptfs/issues/194 )\n\t\tif runtime.GOOS == \"darwin\" && os.IsNotExist(err) {\n\t\t\ttlog.Info.Printf(\"Mountpoint %q does not exist, but should be created by OSXFuse\",\n\t\t\t\targs.mountpoint)\n\t\t\terr = nil\n\t\t}\n\t}\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"Invalid mountpoint: %v\", err)\n\t\tos.Exit(exitcodes.MountPoint)\n\t}\n\t// Open control socket early so we can error out before asking the user\n\t// for the password\n\tif args.ctlsock != \"\" {\n\t\t// We must use an absolute path because we cd to / when daemonizing.\n\t\t// This messes up the delete-on-close logic in the unix socket object.\n\t\targs.ctlsock, _ = filepath.Abs(args.ctlsock)\n\n\t\targs._ctlsockFd, err = ctlsocksrv.Listen(args.ctlsock)\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"ctlsock: %v\", err)\n\t\t\tos.Exit(exitcodes.CtlSock)\n\t\t}\n\t\t// Close also deletes the socket file\n\t\tdefer func() {\n\t\t\terr = args._ctlsockFd.Close()\n\t\t\tif err != nil {\n\t\t\t\ttlog.Warn.Printf(\"ctlsock close: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n\t// Initialize gocryptfs (read config file, ask for password, ...)\n\tfs, wipeKeys := initFuseFrontend(args)\n\t// Try to wipe secret keys from memory after unmount\n\tdefer wipeKeys()\n\t// Initialize go-fuse FUSE server\n\tsrv := initGoFuse(fs, args)\n\tif x, ok := fs.(AfterUnmounter); ok {\n\t\tdefer x.AfterUnmount()\n\t}\n\n\ttlog.Info.Println(tlog.ColorGreen + \"Filesystem mounted and ready.\" + tlog.ColorReset)\n\t// We have been forked into the background, as evidenced by the set\n\t// \"notifypid\".\n\t// Do what daemons should do: https://man7.org/linux/man-pages/man7/daemon.7.html\n\tif args.notifypid > 0 {\n\t\t// Chdir to the root directory so we don't block unmounting the CWD\n\t\tos.Chdir(\"/\")\n\t\t// Disconnect from the controlling terminal by creating a new session.\n\t\t// This prevents us from getting SIGINT when the user presses Ctrl-C\n\t\t// to exit a running script that has called gocryptfs, or SIGHUP when\n\t\t// xfce4-terminal closes itself ( https://github.com/rfjakob/gocryptfs/issues/660 ).\n\t\t_, err = syscall.Setsid()\n\t\tif err != nil {\n\t\t\ttlog.Warn.Printf(\"Setsid: %v\", err)\n\t\t}\n\t\t// Switch to syslog\n\t\tif !args.nosyslog {\n\t\t\t// Switch all of our logs and the generic logger to syslog\n\t\t\ttlog.Info.SwitchToSyslog(syslog.LOG_USER | syslog.LOG_INFO)\n\t\t\ttlog.Debug.SwitchToSyslog(syslog.LOG_USER | syslog.LOG_DEBUG)\n\t\t\ttlog.Warn.SwitchToSyslog(syslog.LOG_USER | syslog.LOG_WARNING)\n\t\t\ttlog.Fatal.SwitchToSyslog(syslog.LOG_USER | syslog.LOG_CRIT)\n\t\t\ttlog.SwitchLoggerToSyslog()\n\t\t\t// Daemons should redirect stdin, stdout and stderr\n\t\t\tredirectStdFds()\n\t\t}\n\t\t// Send SIGUSR1 to our parent\n\t\tsendUsr1(args.notifypid)\n\t}\n\t// Increase the open file limit to 4096. This is not essential, so do it after\n\t// we have switched to syslog and don't bother the user with warnings.\n\tsetOpenFileLimit()\n\t// Wait for SIGINT in the background and unmount ourselves if we get it.\n\t// This prevents a dangling \"Transport endpoint is not connected\"\n\t// mountpoint if the user hits CTRL-C.\n\thandleSigint(srv, args.mountpoint)\n\t// Return memory that was allocated for scrypt (64M by default!) and other\n\t// stuff that is no longer needed to the OS\n\tdebug.FreeOSMemory()\n\t// Set up autounmount, if requested.\n\tif args.idle > 0 && !args.reverse {\n\t\t// Not being in reverse mode means we always have a forward file system.\n\t\tfwdFs := fs.(*fusefrontend.RootNode)\n\t\tgo idleMonitor(args.idle, fwdFs, srv, args.mountpoint)\n\t}\n\t// Wait for unmount.\n\tsrv.Wait()\n}\n\n// Based on the EncFS idle monitor:\n// https://github.com/vgough/encfs/blob/1974b417af189a41ffae4c6feb011d2a0498e437/encfs/main.cpp#L851\n// idleMonitor is a function to be run as a thread that checks for\n// filesystem idleness and unmounts if we've been idle for long enough.\nconst checksDuringTimeoutPeriod = 4\n\nfunc idleMonitor(idleTimeout time.Duration, fs *fusefrontend.RootNode, srv *fuse.Server, mountpoint string) {\n\t// sleepNs is the sleep time between checks, in nanoseconds.\n\tsleepNs := contentenc.MinUint64(\n\t\tuint64(idleTimeout/checksDuringTimeoutPeriod),\n\t\tuint64(2*time.Minute))\n\ttimeoutCycles := int(math.Ceil(float64(idleTimeout) / float64(sleepNs)))\n\tidleCount := 0\n\tidleTime := func() time.Duration {\n\t\treturn time.Duration(sleepNs * uint64(idleCount))\n\t}\n\tfor {\n\t\t// Atomically check whether the flag is 0 and reset it to 1 if so.\n\t\tisIdle := !atomic.CompareAndSwapUint32(&fs.IsIdle, 0, 1)\n\t\t// Any form of current or recent access resets the idle counter.\n\t\topenFileCount := openfiletable.CountOpenFiles()\n\t\tif !isIdle || openFileCount > 0 {\n\t\t\tidleCount = 0\n\t\t} else {\n\t\t\tidleCount++\n\t\t}\n\t\ttlog.Debug.Printf(\n\t\t\t\"idleMonitor: idle for %v (idleCount = %d, isIdle = %t, open = %d)\",\n\t\t\tidleTime(), idleCount, isIdle, openFileCount)\n\t\tif idleCount > 0 && idleCount%timeoutCycles == 0 {\n\t\t\ttlog.Info.Printf(\"idleMonitor: filesystem idle; unmounting: %s\", mountpoint)\n\t\t\terr := srv.Unmount()\n\t\t\tif err != nil {\n\t\t\t\t// We get \"Device or resource busy\" when a process has its\n\t\t\t\t// working directory on the mount. Log the event at Info level\n\t\t\t\t// so the user finds out why their filesystem does not get\n\t\t\t\t// unmounted.\n\t\t\t\ttlog.Info.Printf(\"idleMonitor: unmount failed: %v. Resetting idle time.\", err)\n\t\t\t\tidleCount = 0\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(time.Duration(sleepNs))\n\t}\n}\n\n// setOpenFileLimit tries to increase the open file limit to 4096 (the default hard\n// limit on Linux).\nfunc setOpenFileLimit() {\n\tvar lim syscall.Rlimit\n\terr := syscall.Getrlimit(syscall.RLIMIT_NOFILE, &lim)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"Getting RLIMIT_NOFILE failed: %v\", err)\n\t\treturn\n\t}\n\tif lim.Cur >= 4096 {\n\t\treturn\n\t}\n\tlim.Cur = 4096\n\terr = syscall.Setrlimit(syscall.RLIMIT_NOFILE, &lim)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"Setting RLIMIT_NOFILE to %+v failed: %v\", lim, err)\n\t\t//         %+v output: \"{Cur:4097 Max:4096}\" ^\n\t}\n}\n\n// initFuseFrontend - initialize gocryptfs/internal/fusefrontend\n// Calls os.Exit on errors\nfunc initFuseFrontend(args *argContainer) (rootNode fs.InodeEmbedder, wipeKeys func()) {\n\tvar err error\n\tvar confFile *configfile.ConfFile\n\t// Get the masterkey from the command line if it was specified\n\tmasterkey := handleArgsMasterkey(args)\n\t// Otherwise, load masterkey from config file (normal operation).\n\t// Prompts the user for the password.\n\tif masterkey == nil {\n\t\tmasterkey, confFile, err = loadConfig(args)\n\t\tif err != nil {\n\t\t\tif args._ctlsockFd != nil {\n\t\t\t\t// Close the socket file (which also deletes it)\n\t\t\t\targs._ctlsockFd.Close()\n\t\t\t}\n\t\t\texitcodes.Exit(err)\n\t\t}\n\t}\n\t// Reconciliate CLI and config file arguments into a fusefrontend.Args struct\n\t// that is passed to the filesystem implementation\n\tcryptoBackend := cryptocore.BackendGoGCM\n\tIVBits := contentenc.DefaultIVBits\n\tif args.openssl {\n\t\tcryptoBackend = cryptocore.BackendOpenSSL\n\t}\n\tif args.aessiv {\n\t\tcryptoBackend = cryptocore.BackendAESSIV\n\t}\n\tif args.xchacha {\n\t\tif args.openssl {\n\t\t\tcryptoBackend = cryptocore.BackendXChaCha20Poly1305OpenSSL\n\t\t} else {\n\t\t\tcryptoBackend = cryptocore.BackendXChaCha20Poly1305\n\t\t}\n\t\tIVBits = chacha20poly1305.NonceSizeX * 8\n\t}\n\t// forceOwner implies allow_other, as documented.\n\t// Set this early, so args.allow_other can be relied on below this point.\n\tif args._forceOwner != nil {\n\t\targs.allow_other = true\n\t}\n\tfrontendArgs := fusefrontend.Args{\n\t\tCipherdir:          args.cipherdir,\n\t\tPlaintextNames:     args.plaintextnames,\n\t\tLongNames:          args.longnames,\n\t\tConfigCustom:       args._configCustom,\n\t\tNoPrealloc:         args.noprealloc,\n\t\tForceOwner:         args._forceOwner,\n\t\tExclude:            args.exclude,\n\t\tExcludeWildcard:    args.excludeWildcard,\n\t\tExcludeFrom:        args.excludeFrom,\n\t\tSuid:               args.suid,\n\t\tKernelCache:        args.kernel_cache,\n\t\tSharedStorage:      args.sharedstorage,\n\t\tOneFileSystem:      args.one_file_system,\n\t\tDeterministicNames: args.deterministic_names,\n\t}\n\t// confFile is nil when \"-zerokey\" or \"-masterkey\" was used\n\tif confFile != nil {\n\t\t// Settings from the config file override command line args\n\t\tfrontendArgs.PlaintextNames = confFile.IsFeatureFlagSet(configfile.FlagPlaintextNames)\n\t\tfrontendArgs.DeterministicNames = !confFile.IsFeatureFlagSet(configfile.FlagDirIV)\n\t\t// Things that don't have to be in frontendArgs are only in args\n\t\targs.longnamemax = confFile.LongNameMax\n\t\targs.raw64 = confFile.IsFeatureFlagSet(configfile.FlagRaw64)\n\t\targs.hkdf = confFile.IsFeatureFlagSet(configfile.FlagHKDF)\n\t\t// Note: this will always return the non-openssl variant\n\t\tcryptoBackend, err = confFile.ContentEncryption()\n\t\tif err != nil {\n\t\t\ttlog.Fatal.Printf(\"%v\", err)\n\t\t\tos.Exit(exitcodes.DeprecatedFS)\n\t\t}\n\t\tIVBits = cryptoBackend.NonceSize * 8\n\t\tif cryptoBackend != cryptocore.BackendAESSIV && args.reverse {\n\t\t\ttlog.Fatal.Printf(\"AES-SIV is required by reverse mode, but not enabled in the config file\")\n\t\t\tos.Exit(exitcodes.Usage)\n\t\t}\n\t\t// Upgrade to OpenSSL variant if requested\n\t\tif args.openssl {\n\t\t\tswitch cryptoBackend {\n\t\t\tcase cryptocore.BackendGoGCM:\n\t\t\t\tcryptoBackend = cryptocore.BackendOpenSSL\n\t\t\tcase cryptocore.BackendXChaCha20Poly1305:\n\t\t\t\tcryptoBackend = cryptocore.BackendXChaCha20Poly1305OpenSSL\n\t\t\t}\n\t\t}\n\t}\n\t// If allow_other is set and we run as root, try to give newly created files to\n\t// the right user.\n\tif args.allow_other && os.Getuid() == 0 {\n\t\tfrontendArgs.PreserveOwner = true\n\t}\n\n\t// Init crypto backend\n\tcCore := cryptocore.New(masterkey, cryptoBackend, IVBits, args.hkdf)\n\tcEnc := contentenc.New(cCore, contentenc.DefaultBS)\n\tnameTransform := nametransform.New(cCore.EMECipher, frontendArgs.LongNames, args.longnamemax,\n\t\targs.raw64, []string(args.badname), frontendArgs.DeterministicNames)\n\t// After the crypto backend is initialized,\n\t// we can purge the master key from memory.\n\tfor i := range masterkey {\n\t\tmasterkey[i] = 0\n\t}\n\tmasterkey = nil\n\t// Spawn fusefrontend\n\ttlog.Debug.Printf(\"frontendArgs: %s\", tlog.JSONDump(frontendArgs))\n\tif args.reverse {\n\t\tif cryptoBackend != cryptocore.BackendAESSIV {\n\t\t\tlog.Panic(\"reverse mode must use AES-SIV, everything else is insecure\")\n\t\t}\n\t\trootNode = fusefrontend_reverse.NewRootNode(frontendArgs, cEnc, nameTransform)\n\t} else {\n\t\trootNode = fusefrontend.NewRootNode(frontendArgs, cEnc, nameTransform)\n\t}\n\t// We have opened the socket early so that we cannot fail here after\n\t// asking the user for the password\n\tif args._ctlsockFd != nil {\n\t\tgo ctlsocksrv.Serve(args._ctlsockFd, rootNode.(ctlsocksrv.Interface))\n\t}\n\treturn rootNode, func() { cCore.Wipe() }\n}\n\ntype RootInoer interface {\n\tRootIno() uint64\n}\n\n// initGoFuse calls into go-fuse to mount `rootNode` on `args.mountpoint`.\n// The mountpoint is ready to use when the functions returns.\n// On error, it calls os.Exit and does not return.\nfunc initGoFuse(rootNode fs.InodeEmbedder, args *argContainer) *fuse.Server {\n\tvar fuseOpts *fs.Options\n\tsec := time.Second\n\tif args.sharedstorage {\n\t\t// sharedstorage mode sets all cache timeouts to zero so changes to the\n\t\t// backing shared storage show up immediately.\n\t\t// Hard links are disabled by using automatically incrementing\n\t\t// inode numbers provided by go-fuse.\n\t\tfuseOpts = &fs.Options{\n\t\t\tFirstAutomaticIno: 1000,\n\t\t}\n\t} else {\n\t\tfuseOpts = &fs.Options{\n\t\t\t// These options are to be compatible with libfuse defaults,\n\t\t\t// making benchmarking easier.\n\t\t\tNegativeTimeout: &sec,\n\t\t\tAttrTimeout:     &sec,\n\t\t\tEntryTimeout:    &sec,\n\t\t}\n\t}\n\tfuseOpts.NullPermissions = true\n\t// The inode number for the root node must be manually set on mount\n\t// https://github.com/hanwen/go-fuse/issues/399\n\tfuseOpts.RootStableAttr = &fs.StableAttr{Ino: rootNode.(RootInoer).RootIno()}\n\t// Enable go-fuse warnings\n\tfuseOpts.Logger = log.New(os.Stderr, \"go-fuse: \", log.Lmicroseconds)\n\tfuseOpts.MountOptions = fuse.MountOptions{\n\t\t// Writes and reads are usually capped at 128kiB on Linux through\n\t\t// the FUSE_MAX_PAGES_PER_REQ kernel constant in fuse_i.h. Our\n\t\t// sync.Pool buffer pools are sized acc. to the default. Users may set\n\t\t// the kernel constant higher, and Synology NAS kernels are known to\n\t\t// have it >128kiB. We cannot handle more than 128kiB, so we tell\n\t\t// the kernel to limit the size explicitly.\n\t\tMaxWrite: fuse.MAX_KERNEL_WRITE,\n\t\tDebug:    args.fusedebug,\n\t\t// The kernel usually submits multiple read requests in parallel,\n\t\t// which means we serve them in any order. Out-of-order reads are\n\t\t// expensive on some backing network filesystems\n\t\t// ( https://github.com/rfjakob/gocryptfs/issues/92 ).\n\t\t//\n\t\t// Setting SyncRead disables FUSE_CAP_ASYNC_READ. This makes the kernel\n\t\t// do everything in-order without parallelism.\n\t\tSyncRead: args.serialize_reads,\n\t\t// Attempt to directly call mount(2) before trying fusermount. This means we\n\t\t// can do without fusermount if running as root.\n\t\tDirectMount: true,\n\t}\n\n\tmOpts := &fuseOpts.MountOptions\n\topts := make(map[string]string)\n\tif args.allow_other {\n\t\ttlog.Info.Printf(tlog.ColorYellow + \"The option \\\"-allow_other\\\" is set. Make sure the file \" +\n\t\t\t\"permissions protect your data from unwanted access.\" + tlog.ColorReset)\n\t\tmOpts.AllowOther = true\n\t\t// Make the kernel check the file permissions for us\n\t\topts[\"default_permissions\"] = \"\"\n\t}\n\tif args.acl {\n\t\tmOpts.EnableAcl = true\n\t}\n\t// fusermount from libfuse 3.x removed the \"nonempty\" option and exits\n\t// with an error if it sees it. Only add it to the options on libfuse 2.x.\n\tif args.nonempty && haveFusermount2() {\n\t\topts[\"nonempty\"] = \"\"\n\t}\n\t// Set values shown in \"df -T\" and friends\n\t// First column, \"Filesystem\"\n\tfsname := args.cipherdir\n\tif args.fsname != \"\" {\n\t\tfsname = args.fsname\n\t}\n\tfsname2 := strings.Replace(fsname, \",\", \"_\", -1)\n\tif fsname2 != fsname {\n\t\ttlog.Warn.Printf(\"Warning: %q will be displayed as %q in \\\"df -T\\\"\", fsname, fsname2)\n\t\tfsname = fsname2\n\t}\n\tmOpts.FsName = fsname\n\t// Second column, \"Type\", will be shown as \"fuse.\" + Name\n\tmOpts.Name = \"gocryptfs\"\n\tif args.reverse {\n\t\tmOpts.Name += \"-reverse\"\n\t}\n\t// Add a volume name if running osxfuse. Otherwise the Finder will show it as\n\t// something like \"osxfuse Volume 0 (gocryptfs)\".\n\tif runtime.GOOS == \"darwin\" {\n\t\topts[\"volname\"] = strings.Replace(path.Base(args.mountpoint), \",\", \"_\", -1)\n\t}\n\t// The kernel enforces read-only operation, we just have to pass \"ro\".\n\t// Reverse mounts are always read-only.\n\tif args.ro || args.reverse {\n\t\topts[\"ro\"] = \"\"\n\t} else if args.rw {\n\t\topts[\"rw\"] = \"\"\n\t}\n\t// If both \"nosuid\" & \"suid\", \"nodev\" & \"dev\", etc were passed, the safer\n\t// option wins.\n\tif args.nosuid {\n\t\topts[\"nosuid\"] = \"\"\n\t} else if args.suid {\n\t\topts[\"suid\"] = \"\"\n\t}\n\tif args.nodev {\n\t\topts[\"nodev\"] = \"\"\n\t} else if args.dev {\n\t\topts[\"dev\"] = \"\"\n\t}\n\tif args.noexec {\n\t\topts[\"noexec\"] = \"\"\n\t} else if args.exec {\n\t\topts[\"exec\"] = \"\"\n\t}\n\t// Add additional mount options (if any) after the stock ones, so the user has\n\t// a chance to override them.\n\tif args.ko != \"\" {\n\t\tparts := strings.Split(args.ko, \",\")\n\t\ttlog.Debug.Printf(\"Adding -ko mount options: %v\", parts)\n\t\tfor _, part := range parts {\n\t\t\tkv := strings.SplitN(part, \"=\", 2)\n\t\t\tif len(kv) == 2 {\n\t\t\t\topts[kv[0]] = kv[1]\n\t\t\t} else {\n\t\t\t\topts[kv[0]] = \"\"\n\t\t\t}\n\t\t}\n\t}\n\tfor k, v := range opts {\n\t\tif v == \"\" {\n\t\t\tmOpts.Options = append(mOpts.Options, k)\n\t\t} else {\n\t\t\tmOpts.Options = append(mOpts.Options, k+\"=\"+v)\n\t\t}\n\t}\n\n\tsrv, err := fs.Mount(args.mountpoint, rootNode, fuseOpts)\n\tif err != nil {\n\t\ttlog.Fatal.Printf(\"fs.Mount failed: %s\", strings.TrimSpace(err.Error()))\n\t\tif runtime.GOOS == \"darwin\" {\n\t\t\ttlog.Info.Printf(\"Maybe you should run: /Library/Filesystems/osxfuse.fs/Contents/Resources/load_osxfuse\")\n\t\t}\n\t\tos.Exit(exitcodes.FuseNewServer)\n\t}\n\n\t// All FUSE file and directory create calls carry explicit permission\n\t// information. We need an unrestricted umask to create the files and\n\t// directories with the requested permissions.\n\tsyscall.Umask(0000)\n\n\treturn srv\n}\n\n// haveFusermount2 finds out if the \"fusermount\" binary is from libfuse 2.x.\nfunc haveFusermount2() bool {\n\tpath, err := exec.LookPath(\"fusermount\")\n\tif err != nil {\n\t\tpath = \"/bin/fusermount\"\n\t}\n\tcmd := exec.Command(path, \"-V\")\n\tvar out bytes.Buffer\n\tcmd.Stdout = &out\n\terr = cmd.Run()\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"warning: haveFusermount2: %v\", err)\n\t\treturn false\n\t}\n\t// libfuse 2: fusermount version: 2.9.9\n\t// libfuse 3: fusermount3 version: 3.9.0\n\tv := out.String()\n\treturn strings.HasPrefix(v, \"fusermount version\")\n}\n\nfunc handleSigint(srv *fuse.Server, mountpoint string) {\n\tch := make(chan os.Signal, 1)\n\tsignal.Notify(ch, os.Interrupt)\n\tsignal.Notify(ch, syscall.SIGTERM)\n\tgo func() {\n\t\t<-ch\n\t\tunmount(srv, mountpoint)\n\t\tos.Exit(exitcodes.SigInt)\n\t}()\n}\n\n// unmount() calls srv.Unmount(), and if that fails, calls \"fusermount -u -z\"\n// (lazy unmount).\nfunc unmount(srv *fuse.Server, mountpoint string) {\n\terr := srv.Unmount()\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"unmount: srv.Unmount returned %v\", err)\n\t\tif runtime.GOOS == \"linux\" {\n\t\t\t// MacOSX does not support lazy unmount\n\t\t\ttlog.Info.Printf(\"Trying lazy unmount\")\n\t\t\tcmd := exec.Command(\"fusermount\", \"-u\", \"-z\", mountpoint)\n\t\t\tcmd.Stdout = os.Stdout\n\t\t\tcmd.Stderr = os.Stderr\n\t\t\tcmd.Run()\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "package-release-tarballs.bash",
          "type": "blob",
          "size": 2.3466796875,
          "content": "#!/bin/bash\n\nset -eu\n\ncd \"$(dirname \"$0\")\"\n\nSIGNME=\"\"\n\n# git_archive_extra PREFIX EXTRA1 [EXTRA2 ...]\n#\n# Call git-archive and add additional files to the tarball.\n# Output tarball is called \"$PREFIX.tar.gz\" and contains one folder\n# called \"$PREFIX\".\ngit_archive_extra() {\n\tlocal PREFIX=$1\n\tshift\n\t# Add files tracked in git\n\tgit archive --prefix \"$PREFIX/\" -o \"$PREFIX.tar\" HEAD\n\t# Add \"extra\" files\n\ttar --owner=root --group=root --transform \"s!^!$PREFIX/!\" --append -f \"$PREFIX.tar\" \"$@\"\n\t# Compress\n\tgzip -f \"$PREFIX.tar\"\n}\n\npackage_source() {\n\tlocal GITVERSION\n\tGITVERSION=$(git describe --tags --dirty)\n\techo \"$GITVERSION\" > VERSION\n\n\t# Render the manpages and include them in the tarball. This\n\t# avoids a build-dependency to pandoc.\n\t./Documentation/MANPAGE-render.bash\n\n\t# gocryptfs source tarball\n\tlocal PREFIX_SRC_ONLY=gocryptfs_${GITVERSION}_src\n\tgit_archive_extra \"$PREFIX_SRC_ONLY\" VERSION Documentation/*.1\n\n\t# gocryptfs source + dependencies tarball\n\tgo mod vendor\n\tlocal PREFIX_SRC_DEPS=gocryptfs_${GITVERSION}_src-deps\n\tgit_archive_extra \"$PREFIX_SRC_DEPS\" VERSION Documentation/*.1 vendor\n\n\trm VERSION\n\trm -R vendor\n\n\techo \"Tars created.\"\n\tSIGNME+=\" $PREFIX_SRC_ONLY.tar.gz $PREFIX_SRC_DEPS.tar.gz\"\n}\n\npackage_static_binary() {\n\t# Compiles the gocryptfs binary and sets $GITVERSION\n\tsource build-without-openssl.bash\n\n\tif ldd gocryptfs > /dev/null ; then\n\t\techo \"error: compiled gocryptfs binary is not static\"\n\t\texit 1\n\tfi\n\n\t# Build man pages gocryptfs.1 & gocryptfs-xray.1\n\t./Documentation/MANPAGE-render.bash > /dev/null\n\n\tlocal ARCH\n\tARCH=$(go env GOARCH)\n\tlocal OS\n\tOS=$(go env GOOS)\n\n\tlocal TARBALL\n\tTARBALL=gocryptfs_${GITVERSION}_${OS}-static_${ARCH}.tar\n\tlocal TARGZ\n\tTARGZ=$TARBALL.gz\n\n\ttar --owner=root --group=root --create -vf \"$TARBALL\" gocryptfs\n\ttar --owner=root --group=root --append -vf \"$TARBALL\" -C gocryptfs-xray gocryptfs-xray\n\ttar --owner=root --group=root --append -vf \"$TARBALL\" -C Documentation gocryptfs.1 gocryptfs-xray.1\n\n\tgzip -f \"$TARBALL\"\n\n\techo \"Tar created.\"\n\tSIGNME+=\" $TARGZ\"\n}\n\nsigning_hint() {\n\tlocal GITVERSION\n\tGITVERSION=$(git describe --tags --dirty)\n\n\techo \"Hint for signing:\"\n\techo \"  for i in gocryptfs_${GITVERSION}_*.tar.gz ; do gpg -u 23A02740 --armor --detach-sig \\$i ; done\"\n}\n\nif git describe --dirty | grep dirty ; then\n\techo \"Tree is dirty - I will not package this!\"\n\texit 1\nfi\n\npackage_source\npackage_static_binary\nsigning_hint\n"
        },
        {
          "name": "profiling.go",
          "type": "blob",
          "size": 2.197265625,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"runtime/pprof\"\n\t\"runtime/trace\"\n\t\"time\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/exitcodes\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// setupCpuprofile is called to handle a non-empty \"-cpuprofile\" cli argument\nfunc setupCpuprofile(cpuprofileArg string) func() {\n\ttlog.Info.Printf(\"Writing CPU profile to %s\", cpuprofileArg)\n\tf, err := os.Create(cpuprofileArg)\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.Profiler)\n\t}\n\terr = pprof.StartCPUProfile(f)\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.Profiler)\n\t}\n\treturn func() {\n\t\tpprof.StopCPUProfile()\n\t}\n}\n\n// setupTrace is called to handle a non-empty \"-memprofile\" cli argument\nfunc setupMemprofile(memprofileArg string) func() {\n\ttlog.Info.Printf(\"Will write memory profile to %q\", memprofileArg)\n\tf, err := os.Create(memprofileArg)\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.Profiler)\n\t}\n\texiting := false\n\t// Write the memory profile to disk every 60 seconds to get the in-use\n\t// memory stats.\n\tgo func() {\n\t\tfor {\n\t\t\ttime.Sleep(60 * time.Second)\n\t\t\tif exiting {\n\t\t\t\treturn\n\t\t\t}\n\t\t\t_, err = f.Seek(0, 0)\n\t\t\tif err != nil {\n\t\t\t\ttlog.Warn.Printf(\"memprofile: Seek failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = f.Truncate(0)\n\t\t\tif err != nil {\n\t\t\t\ttlog.Warn.Printf(\"memprofile: Truncate failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr = pprof.WriteHeapProfile(f)\n\t\t\tif err == nil {\n\t\t\t\ttlog.Info.Printf(\"memprofile: periodic write to %q succeeded\",\n\t\t\t\t\tmemprofileArg)\n\t\t\t} else {\n\t\t\t\ttlog.Warn.Printf(\"memprofile: periodic WriteHeapProfile failed: %v\", err)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}()\n\t// Final write on exit.\n\treturn func() {\n\t\texiting = true\n\t\terr = pprof.WriteHeapProfile(f)\n\t\tif err != nil {\n\t\t\ttlog.Warn.Printf(\"memprofile: on-exit WriteHeapProfile failed: %v\", err)\n\t\t}\n\t\tf.Close()\n\t}\n}\n\n// setupTrace is called to handle a non-empty \"-trace\" cli argument\nfunc setupTrace(traceArg string) func() {\n\ttlog.Info.Printf(\"Writing execution trace to %s\", traceArg)\n\tf, err := os.Create(traceArg)\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.Profiler)\n\t}\n\terr = trace.Start(f)\n\tif err != nil {\n\t\ttlog.Fatal.Println(err)\n\t\tos.Exit(exitcodes.Profiler)\n\t}\n\treturn func() {\n\t\ttrace.Stop()\n\t}\n}\n"
        },
        {
          "name": "profiling",
          "type": "tree",
          "content": null
        },
        {
          "name": "race.go",
          "type": "blob",
          "size": 0.1357421875,
          "content": "//go:build race\n// +build race\n\npackage main\n\nfunc init() {\n\t// adds \" -race\" to the output of \"gocryptfs -version\"\n\traceDetector = true\n}\n"
        },
        {
          "name": "sendusr1.go",
          "type": "blob",
          "size": 0.4521484375,
          "content": "package main\n\nimport (\n\t\"os\"\n\t\"syscall\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\n// Send signal USR1 to \"pid\" (usually our parent process). This notifies it\n// that the mounting has completed successfully.\nfunc sendUsr1(pid int) {\n\tp, err := os.FindProcess(pid)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"sendUsr1: FindProcess: %v\\n\", err)\n\t\treturn\n\t}\n\terr = p.Signal(syscall.SIGUSR1)\n\tif err != nil {\n\t\ttlog.Warn.Printf(\"sendUsr1: Signal: %v\\n\", err)\n\t}\n}\n"
        },
        {
          "name": "test-without-openssl.bash",
          "type": "blob",
          "size": 0.076171875,
          "content": "#!/bin/bash -eu\n\ncd \"$(dirname \"$0\")\"\n\n./test.bash -tags without_openssl \"$@\"\n"
        },
        {
          "name": "test.bash",
          "type": "blob",
          "size": 3.5986328125,
          "content": "#!/bin/bash\n#\n# test.bash runs the gocryptfs test suite against $TMPDIR,\n# or, if unset, /var/tmp.\n\nset -eu\n\nVERBOSE=0\nfor i in \"$@\" ; do\n\tif [[ $i == \"-v\" ]] ; then\n\t\tVERBOSE=1\n\t\tset -x\n\t\tbreak\n\tfi\ndone\n\nif [[ -z ${TMPDIR:-} ]]; then\n\tTMPDIR=/var/tmp\n\texport TMPDIR\nelse\n\techo \"Using TMPDIR=$TMPDIR\"\nfi\n\ncd \"$(dirname \"$0\")\"\nexport GO111MODULE=on\nMYNAME=$(basename \"$0\")\nTESTDIR=$TMPDIR/gocryptfs-test-parent-$UID\nmkdir -p \"$TESTDIR\"\nLOCKFILE=$TESTDIR/$MYNAME.lock\n\nunmount_leftovers() {\n\tRET=0\n\tfor i in $(mount | grep \"$TESTDIR\" | cut -f3 -d\" \"); do\n\t\techo \"Warning: unmounting leftover filesystem: $i\"\n\t\ttests/fuse-unmount.bash \"$i\"\n\t\tRET=1\n\tdone\n\treturn $RET\n}\n\n(\n# Prevent multiple parallel test.bash instances as this causes\n# all kinds of mayhem\nif ! command -v flock > /dev/null ; then\n\techo \"flock is not available, skipping\"\nelif ! flock -n 200 ; then\n\techo \"Could not acquire lock on $LOCKFILE - already running?\"\n\texit 1\nfi\n\n# Clean up dangling filesystems and don't exit if we found some\nunmount_leftovers || true\n\n./build-without-openssl.bash || {\n\techo \"$MYNAME: build-without-openssl.bash failed\"\n\texit 1\n}\n# Don't build with openssl if we were passed \"-tags without_openssl\"\nif [[ \"$*\" != *without_openssl* ]] ; then\n\t./build.bash\nfi\n\nif ! go tool | grep vet > /dev/null ; then\n\techo \"'go tool vet' not available - skipping\"\nelif [[ -d vendor ]] ; then\n\techo \"vendor directory exists, skipping 'go tool vet'\"\nelse\n\tgo vet ./...\nfi\n\nif command -v shellcheck > /dev/null ; then\n\t# SC2002 = useless cat. Does no harm, disable the check.\n\tshellcheck -x -e SC2002 ./*.bash\nelse\n\techo \"shellcheck not installed - skipping\"\nfi\n\necho -n \"Testing on TMPDIR=$TMPDIR, filesystem: \"\nfindmnt --noheadings --target \"$TESTDIR\" --output FSTYPE,OPTIONS || true\n\nEXTRA_ARGS=\"\"\nif [[ $VERBOSE -eq 1 ]]; then\n\t# Disabling parallelism disables per-package output buffering, hence enabling\n\t# live streaming of result output. And seeing where things hang.\n\tEXTRA_ARGS=\"-p 1\"\nfi\n\n#                         We don't want all the subprocesses\n#                              holding the lock file open\n#                                       vvvvv\n# shellcheck disable=SC2086\ngo test -count 1 $EXTRA_ARGS ./... \"$@\" 200>&-\n#       ^^^^^^^^\n#   Disable result caching\n\n# Clean up dangling filesystems but do exit with an error if we found one\nunmount_leftovers || { echo \"Error: the tests left mounted filesystems behind\" ; exit 1 ; }\n\n# The tests cannot to this themselves as they are run in parallel.\n# Don't descend into possibly still mounted example filesystems.\nif [[ $OSTYPE == *linux* ]] ; then\n\trm -Rf --one-file-system \"$TESTDIR\"\nelse\n\t# MacOS \"rm\" does not understand \"--one-file-system\"\n\trm -Rf \"$TESTDIR\"\nfi\n\nif find internal -type f -name \\*.go -print0 | xargs -0 grep \"panic(\"; then\n\techo \"$MYNAME: Please use log.Panic instead of naked panic!\"\n\texit 1\nfi\n\n# All functions from the commit msg in https://go-review.googlesource.com/c/go/+/210639\nif find . -type f -name \\*.go -print0 | xargs -0 grep -E 'syscall.(Setegid|Seteuid|Setgroups|Setgid|Setregid|Setreuid|Setresgid|Setresuid|Setuid)\\(' ; then\n\techo \"$MYNAME: You probably want to use unix.Setgroups and friends. See the comments in OpenatUser() for why.\"\n\texit 1\nfi\n\nif find . -type f -name \\*.go -print0 | xargs -0 grep '\\.Creat('; then\n\t# MacOS does not have syscall.Creat(). Creat() is equivalent to Open(..., O_CREAT|O_WRONLY|O_TRUNC, ...),\n\t# but usually you want O_EXCL instead of O_TRUNC because it is safer, so that's what we suggest\n\t# instead.\n\techo \"$MYNAME: Please use Open(..., O_CREAT|O_WRONLY|O_EXCL, ...) instead of Creat()! https://github.com/rfjakob/gocryptfs/issues/623\"\n\texit 1\nfi\n\n) 200> \"$LOCKFILE\"\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 2.1181640625,
          "content": "package main\n\nimport (\n\t\"fmt\"\n\t\"runtime\"\n\t\"runtime/debug\"\n\t\"strings\"\n\n\t\"github.com/rfjakob/gocryptfs/v2/internal/stupidgcm\"\n\t\"github.com/rfjakob/gocryptfs/v2/internal/tlog\"\n)\n\nconst (\n\tgitVersionNotSet     = \"[GitVersion not set - please compile using ./build.bash]\"\n\tgitVersionFuseNotSet = \"[GitVersionFuse not set - please compile using ./build.bash]\"\n\tbuildDateNotSet      = \"0000-00-00\"\n)\n\nvar (\n\t// GitVersion is the gocryptfs version according to git, set by build.bash\n\tGitVersion = gitVersionNotSet\n\t// GitVersionFuse is the go-fuse library version, set by build.bash\n\tGitVersionFuse = gitVersionFuseNotSet\n\t// BuildDate is a date string like \"2017-09-06\", set by build.bash\n\tBuildDate = buildDateNotSet\n)\n\nfunc init() {\n\tversionFromBuildInfo()\n}\n\n// raceDetector is set to true by race.go if we are compiled with \"go build -race\"\nvar raceDetector bool\n\n// printVersion prints a version string like this:\n// gocryptfs v1.7-32-gcf99cfd; go-fuse v1.0.0-174-g22a9cb9; 2019-05-12 go1.12 linux/amd64\nfunc printVersion() {\n\tvar tagsSlice []string\n\tif stupidgcm.BuiltWithoutOpenssl {\n\t\ttagsSlice = append(tagsSlice, \"without_openssl\")\n\t}\n\ttags := \"\"\n\tif tagsSlice != nil {\n\t\ttags = \" \" + strings.Join(tagsSlice, \" \")\n\t}\n\tbuilt := fmt.Sprintf(\"%s %s\", BuildDate, runtime.Version())\n\tif raceDetector {\n\t\tbuilt += \" -race\"\n\t}\n\tfmt.Printf(\"%s %s%s; go-fuse %s; %s %s/%s\\n\",\n\t\ttlog.ProgramName, GitVersion, tags, GitVersionFuse, built,\n\t\truntime.GOOS, runtime.GOARCH)\n}\n\n// versionFromBuildInfo tries to get some information out of the information baked in\n// by the Go compiler. Does nothing when build.bash was used to build.\nfunc versionFromBuildInfo() {\n\tinfo, ok := debug.ReadBuildInfo()\n\tif !ok {\n\t\ttlog.Debug.Println(\"versionFromBuildInfo: ReadBuildInfo() failed\")\n\t\treturn\n\t}\n\t// Fill our version strings\n\tif GitVersion == gitVersionNotSet && info.Main.Version != \"(devel)\" {\n\t\tGitVersion = info.Main.Version\n\t}\n\tif GitVersionFuse == gitVersionFuseNotSet {\n\t\tfor _, m := range info.Deps {\n\t\t\tif m.Path == \"github.com/hanwen/go-fuse/v2\" {\n\t\t\t\tGitVersionFuse = m.Version\n\t\t\t\tif m.Replace != nil {\n\t\t\t\t\tGitVersionFuse = m.Replace.Version\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n"
        }
      ]
    }
  ]
}