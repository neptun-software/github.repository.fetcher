{
  "metadata": {
    "timestamp": 1736567358579,
    "page": 965,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjk3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "cosmos72/gomacro",
      "stars": 2187,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.2373046875,
          "content": "/gomacro\n/gomacro.debug\na.out\n*~\n*.o\n*.exe\n*.test\n*.dump\n_gen_*.s\n/_example/example\n/_example/interrupt/interrupt\n/jit/**/test\n/jit/**/_template/_template\n/jit/arm64/_template/_bitwise_immediate/_bitwise_immediate\n/jit/arm64/_template/_go/_go\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 16.333984375,
          "content": "Mozilla Public License Version 2.0\n==================================\n\n1. Definitions\n--------------\n\n1.1. \"Contributor\"\n    means each individual or legal entity that creates, contributes to\n    the creation of, or owns Covered Software.\n\n1.2. \"Contributor Version\"\n    means the combination of the Contributions of others (if any) used\n    by a Contributor and that particular Contributor's Contribution.\n\n1.3. \"Contribution\"\n    means Covered Software of a particular Contributor.\n\n1.4. \"Covered Software\"\n    means Source Code Form to which the initial Contributor has attached\n    the notice in Exhibit A, the Executable Form of such Source Code\n    Form, and Modifications of such Source Code Form, in each case\n    including portions thereof.\n\n1.5. \"Incompatible With Secondary Licenses\"\n    means\n\n    (a) that the initial Contributor has attached the notice described\n        in Exhibit B to the Covered Software; or\n\n    (b) that the Covered Software was made available under the terms of\n        version 1.1 or earlier of the License, but not also under the\n        terms of a Secondary License.\n\n1.6. \"Executable Form\"\n    means any form of the work other than Source Code Form.\n\n1.7. \"Larger Work\"\n    means a work that combines Covered Software with other material, in \n    a separate file or files, that is not Covered Software.\n\n1.8. \"License\"\n    means this document.\n\n1.9. \"Licensable\"\n    means having the right to grant, to the maximum extent possible,\n    whether at the time of the initial grant or subsequently, any and\n    all of the rights conveyed by this License.\n\n1.10. \"Modifications\"\n    means any of the following:\n\n    (a) any file in Source Code Form that results from an addition to,\n        deletion from, or modification of the contents of Covered\n        Software; or\n\n    (b) any new file in Source Code Form that contains any Covered\n        Software.\n\n1.11. \"Patent Claims\" of a Contributor\n    means any patent claim(s), including without limitation, method,\n    process, and apparatus claims, in any patent Licensable by such\n    Contributor that would be infringed, but for the grant of the\n    License, by the making, using, selling, offering for sale, having\n    made, import, or transfer of either its Contributions or its\n    Contributor Version.\n\n1.12. \"Secondary License\"\n    means either the GNU General Public License, Version 2.0, the GNU\n    Lesser General Public License, Version 2.1, the GNU Affero General\n    Public License, Version 3.0, or any later versions of those\n    licenses.\n\n1.13. \"Source Code Form\"\n    means the form of the work preferred for making modifications.\n\n1.14. \"You\" (or \"Your\")\n    means an individual or a legal entity exercising rights under this\n    License. For legal entities, \"You\" includes any entity that\n    controls, is controlled by, or is under common control with You. For\n    purposes of this definition, \"control\" means (a) the power, direct\n    or indirect, to cause the direction or management of such entity,\n    whether by contract or otherwise, or (b) ownership of more than\n    fifty percent (50%) of the outstanding shares or beneficial\n    ownership of such entity.\n\n2. License Grants and Conditions\n--------------------------------\n\n2.1. Grants\n\nEach Contributor hereby grants You a world-wide, royalty-free,\nnon-exclusive license:\n\n(a) under intellectual property rights (other than patent or trademark)\n    Licensable by such Contributor to use, reproduce, make available,\n    modify, display, perform, distribute, and otherwise exploit its\n    Contributions, either on an unmodified basis, with Modifications, or\n    as part of a Larger Work; and\n\n(b) under Patent Claims of such Contributor to make, use, sell, offer\n    for sale, have made, import, and otherwise transfer either its\n    Contributions or its Contributor Version.\n\n2.2. Effective Date\n\nThe licenses granted in Section 2.1 with respect to any Contribution\nbecome effective for each Contribution on the date the Contributor first\ndistributes such Contribution.\n\n2.3. Limitations on Grant Scope\n\nThe licenses granted in this Section 2 are the only rights granted under\nthis License. No additional rights or licenses will be implied from the\ndistribution or licensing of Covered Software under this License.\nNotwithstanding Section 2.1(b) above, no patent license is granted by a\nContributor:\n\n(a) for any code that a Contributor has removed from Covered Software;\n    or\n\n(b) for infringements caused by: (i) Your and any other third party's\n    modifications of Covered Software, or (ii) the combination of its\n    Contributions with other software (except as part of its Contributor\n    Version); or\n\n(c) under Patent Claims infringed by Covered Software in the absence of\n    its Contributions.\n\nThis License does not grant any rights in the trademarks, service marks,\nor logos of any Contributor (except as may be necessary to comply with\nthe notice requirements in Section 3.4).\n\n2.4. Subsequent Licenses\n\nNo Contributor makes additional grants as a result of Your choice to\ndistribute the Covered Software under a subsequent version of this\nLicense (see Section 10.2) or under the terms of a Secondary License (if\npermitted under the terms of Section 3.3).\n\n2.5. Representation\n\nEach Contributor represents that the Contributor believes its\nContributions are its original creation(s) or it has sufficient rights\nto grant the rights to its Contributions conveyed by this License.\n\n2.6. Fair Use\n\nThis License is not intended to limit any rights You have under\napplicable copyright doctrines of fair use, fair dealing, or other\nequivalents.\n\n2.7. Conditions\n\nSections 3.1, 3.2, 3.3, and 3.4 are conditions of the licenses granted\nin Section 2.1.\n\n3. Responsibilities\n-------------------\n\n3.1. Distribution of Source Form\n\nAll distribution of Covered Software in Source Code Form, including any\nModifications that You create or to which You contribute, must be under\nthe terms of this License. You must inform recipients that the Source\nCode Form of the Covered Software is governed by the terms of this\nLicense, and how they can obtain a copy of this License. You may not\nattempt to alter or restrict the recipients' rights in the Source Code\nForm.\n\n3.2. Distribution of Executable Form\n\nIf You distribute Covered Software in Executable Form then:\n\n(a) such Covered Software must also be made available in Source Code\n    Form, as described in Section 3.1, and You must inform recipients of\n    the Executable Form how they can obtain a copy of such Source Code\n    Form by reasonable means in a timely manner, at a charge no more\n    than the cost of distribution to the recipient; and\n\n(b) You may distribute such Executable Form under the terms of this\n    License, or sublicense it under different terms, provided that the\n    license for the Executable Form does not attempt to limit or alter\n    the recipients' rights in the Source Code Form under this License.\n\n3.3. Distribution of a Larger Work\n\nYou may create and distribute a Larger Work under terms of Your choice,\nprovided that You also comply with the requirements of this License for\nthe Covered Software. If the Larger Work is a combination of Covered\nSoftware with a work governed by one or more Secondary Licenses, and the\nCovered Software is not Incompatible With Secondary Licenses, this\nLicense permits You to additionally distribute such Covered Software\nunder the terms of such Secondary License(s), so that the recipient of\nthe Larger Work may, at their option, further distribute the Covered\nSoftware under the terms of either this License or such Secondary\nLicense(s).\n\n3.4. Notices\n\nYou may not remove or alter the substance of any license notices\n(including copyright notices, patent notices, disclaimers of warranty,\nor limitations of liability) contained within the Source Code Form of\nthe Covered Software, except that You may alter any license notices to\nthe extent required to remedy known factual inaccuracies.\n\n3.5. Application of Additional Terms\n\nYou may choose to offer, and to charge a fee for, warranty, support,\nindemnity or liability obligations to one or more recipients of Covered\nSoftware. However, You may do so only on Your own behalf, and not on\nbehalf of any Contributor. You must make it absolutely clear that any\nsuch warranty, support, indemnity, or liability obligation is offered by\nYou alone, and You hereby agree to indemnify every Contributor for any\nliability incurred by such Contributor as a result of warranty, support,\nindemnity or liability terms You offer. You may include additional\ndisclaimers of warranty and limitations of liability specific to any\njurisdiction.\n\n4. Inability to Comply Due to Statute or Regulation\n---------------------------------------------------\n\nIf it is impossible for You to comply with any of the terms of this\nLicense with respect to some or all of the Covered Software due to\nstatute, judicial order, or regulation then You must: (a) comply with\nthe terms of this License to the maximum extent possible; and (b)\ndescribe the limitations and the code they affect. Such description must\nbe placed in a text file included with all distributions of the Covered\nSoftware under this License. Except to the extent prohibited by statute\nor regulation, such description must be sufficiently detailed for a\nrecipient of ordinary skill to be able to understand it.\n\n5. Termination\n--------------\n\n5.1. The rights granted under this License will terminate automatically\nif You fail to comply with any of its terms. However, if You become\ncompliant, then the rights granted under this License from a particular\nContributor are reinstated (a) provisionally, unless and until such\nContributor explicitly and finally terminates Your grants, and (b) on an\nongoing basis, if such Contributor fails to notify You of the\nnon-compliance by some reasonable means prior to 60 days after You have\ncome back into compliance. Moreover, Your grants from a particular\nContributor are reinstated on an ongoing basis if such Contributor\nnotifies You of the non-compliance by some reasonable means, this is the\nfirst time You have received notice of non-compliance with this License\nfrom such Contributor, and You become compliant prior to 30 days after\nYour receipt of the notice.\n\n5.2. If You initiate litigation against any entity by asserting a patent\ninfringement claim (excluding declaratory judgment actions,\ncounter-claims, and cross-claims) alleging that a Contributor Version\ndirectly or indirectly infringes any patent, then the rights granted to\nYou by any and all Contributors for the Covered Software under Section\n2.1 of this License shall terminate.\n\n5.3. In the event of termination under Sections 5.1 or 5.2 above, all\nend user license agreements (excluding distributors and resellers) which\nhave been validly granted by You or Your distributors under this License\nprior to termination shall survive termination.\n\n************************************************************************\n*                                                                      *\n*  6. Disclaimer of Warranty                                           *\n*  -------------------------                                           *\n*                                                                      *\n*  Covered Software is provided under this License on an \"as is\"       *\n*  basis, without warranty of any kind, either expressed, implied, or  *\n*  statutory, including, without limitation, warranties that the       *\n*  Covered Software is free of defects, merchantable, fit for a        *\n*  particular purpose or non-infringing. The entire risk as to the     *\n*  quality and performance of the Covered Software is with You.        *\n*  Should any Covered Software prove defective in any respect, You     *\n*  (not any Contributor) assume the cost of any necessary servicing,   *\n*  repair, or correction. This disclaimer of warranty constitutes an   *\n*  essential part of this License. No use of any Covered Software is   *\n*  authorized under this License except under this disclaimer.         *\n*                                                                      *\n************************************************************************\n\n************************************************************************\n*                                                                      *\n*  7. Limitation of Liability                                          *\n*  --------------------------                                          *\n*                                                                      *\n*  Under no circumstances and under no legal theory, whether tort      *\n*  (including negligence), contract, or otherwise, shall any           *\n*  Contributor, or anyone who distributes Covered Software as          *\n*  permitted above, be liable to You for any direct, indirect,         *\n*  special, incidental, or consequential damages of any character      *\n*  including, without limitation, damages for lost profits, loss of    *\n*  goodwill, work stoppage, computer failure or malfunction, or any    *\n*  and all other commercial damages or losses, even if such party      *\n*  shall have been informed of the possibility of such damages. This   *\n*  limitation of liability shall not apply to liability for death or   *\n*  personal injury resulting from such party's negligence to the       *\n*  extent applicable law prohibits such limitation. Some               *\n*  jurisdictions do not allow the exclusion or limitation of           *\n*  incidental or consequential damages, so this exclusion and          *\n*  limitation may not apply to You.                                    *\n*                                                                      *\n************************************************************************\n\n8. Litigation\n-------------\n\nAny litigation relating to this License may be brought only in the\ncourts of a jurisdiction where the defendant maintains its principal\nplace of business and such litigation shall be governed by laws of that\njurisdiction, without reference to its conflict-of-law provisions.\nNothing in this Section shall prevent a party's ability to bring\ncross-claims or counter-claims.\n\n9. Miscellaneous\n----------------\n\nThis License represents the complete agreement concerning the subject\nmatter hereof. If any provision of this License is held to be\nunenforceable, such provision shall be reformed only to the extent\nnecessary to make it enforceable. Any law or regulation which provides\nthat the language of a contract shall be construed against the drafter\nshall not be used to construe this License against a Contributor.\n\n10. Versions of the License\n---------------------------\n\n10.1. New Versions\n\nMozilla Foundation is the license steward. Except as provided in Section\n10.3, no one other than the license steward has the right to modify or\npublish new versions of this License. Each version will be given a\ndistinguishing version number.\n\n10.2. Effect of New Versions\n\nYou may distribute the Covered Software under the terms of the version\nof the License under which You originally received the Covered Software,\nor under the terms of any subsequent version published by the license\nsteward.\n\n10.3. Modified Versions\n\nIf you create software not governed by this License, and you want to\ncreate a new license for such software, you may create and use a\nmodified version of this License if you rename the license and remove\nany references to the name of the license steward (except to note that\nsuch modified license differs from this License).\n\n10.4. Distributing Source Code Form that is Incompatible With Secondary\nLicenses\n\nIf You choose to distribute Source Code Form that is Incompatible With\nSecondary Licenses under the terms of this version of the License, the\nnotice described in Exhibit B of this License must be attached.\n\nExhibit A - Source Code Form License Notice\n-------------------------------------------\n\n  This Source Code Form is subject to the terms of the Mozilla Public\n  License, v. 2.0. If a copy of the MPL was not distributed with this\n  file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nIf it is not possible or desirable to put the notice in a particular\nfile, then You may include the notice in a location (such as a LICENSE\nfile in a relevant directory) where a recipient would be likely to look\nfor such a notice.\n\nYou may add additional accurate notices of copyright ownership.\n\nExhibit B - \"Incompatible With Secondary Licenses\" Notice\n---------------------------------------------------------\n\n  This Source Code Form is \"Incompatible With Secondary Licenses\", as\n  defined by the Mozilla Public License, v. 2.0.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 22.5849609375,
          "content": "## gomacro - interactive Go interpreter and debugger with generics and macros\n\ngomacro is an almost complete Go interpreter, implemented in pure Go. It offers both\nan interactive REPL and a scripting mode, and does not require a Go toolchain at runtime\n(except in one very specific case: import of a 3<sup>rd</sup> party package at runtime).\n\nIt has two dependencies beyond the Go standard library:\n<a href=\"https://github.com/peterh/liner\">github.com/peterh/liner</a>\nand\n<a href=\"https://golang.org/x/tools/go/packages\">golang.org/x/tools/go/packages</a>\n\nGomacro can be used as:\n* a standalone executable with interactive Go REPL, line editing and code completion:\n  just run `gomacro` from your command line, then type Go code. Example:\n    ```\n    $ gomacro\n    [greeting message...]\n\n    gomacro> import \"fmt\"\n    gomacro> fmt.Println(\"hello, world!\")\n    hello, world!\n    14      // int\n    <nil>   // error\n    gomacro>\n    ```\n  press TAB to autocomplete a word, and press it again to cycle on possible completions.\n\n  Line editing follows mostly Emacs: Ctrl+A or Home jumps to start of line,\n  Ctrl+E or End jumps to end of line, Ald+D deletes word starting at cursor...\n  For the full list of key bindings, see https://github.com/peterh/liner\n\n* a tool to experiment with Go **generics**: see [Generics](#generics)\n\n* a Go source code debugger: see [Debugger](#debugger)\n\n* an interactive tool to make science more productive and more fun.\n  If you use compiled Go with scientific libraries (physics, bioinformatics, statistics...)\n  you can import the same libraries from gomacro REPL (immediate on Linux and Mac OS X,\n  requires restarting on other platforms,\n  see [Importing packages](#importing-packages) below), call them interactively,\n  inspect the results, feed them to other functions/libraries, all in a single session.\n  The imported libraries will be **compiled**, not interpreted,\n  so they will be as fast as in compiled Go.\n\n  For a graphical user interface on top of gomacro, see [Gophernotes](https://github.com/gopherdata/gophernotes).\n  It is a Go kernel for Jupyter notebooks and nteract, and uses gomacro for Go code evaluation.\n\n* a library that adds Eval() and scripting capabilities to your Go programs in few lines\n  of code:\n\t```go\n\tpackage main\n\timport (\n\t\t\"fmt\"\n\t\t\"reflect\"\n\t\t\"github.com/cosmos72/gomacro/fast\"\n\t)\n\tfunc RunGomacro(toeval string) reflect.Value {\n\t\tinterp := fast.New()\n\t\tvals, _ := interp.Eval(toeval)\n\t\t// for simplicity, only use the first returned value\n\t\treturn vals[0].ReflectValue()\n\t}\n\tfunc main() {\n\t\tfmt.Println(RunGomacro(\"1+1\"))\n\t}\n\t```\n  Also, [github issue #13](https://github.com/cosmos72/gomacro/issues/13) explains\n  how to have your application's functions, variable, constants and types\n  available in the interpreter.\n\n  Note: gomacro license is [MPL 2.0](LICENSE), which imposes some restrictions\n  on programs that use gomacro.\n  See [MPL 2.0 FAQ](https://www.mozilla.org/en-US/MPL/2.0/FAQ/) for common questions\n  regarding the license terms and conditions.\n\n* a way to execute Go source code on-the-fly without a Go compiler:\n  you can either run `gomacro FILENAME.go` (works on every supported platform)\n\n  or you can insert a line `#!/usr/bin/env gomacro` at the beginning of a Go source file,\n  then mark the file as executable with `chmod +x FILENAME.go` and finally execute it\n  with `./FILENAME.go` (works only on Unix-like systems: Linux, *BSD, Mac OS X ...)\n\n* a Go code generation tool:\n  gomacro was started as an experiment to add Lisp-like macros to Go, and they are\n  extremely useful (in the author's opinion) to simplify code generation.\n  Macros are normal Go functions, they are special only in one aspect:\n  they are executed **before** compiling code, and their input and output **is** code\n  (abstract syntax trees, in the form of go/ast.Node)\n\n  Don't confuse them with C preprocessor macros: in Lisp, Scheme and now in Go,\n  macros are regular functions written in the same programming language\n  as the rest of the source code. They can perform arbitrary computations\n  and call any other function or library: they can even read and write files,\n  open network connections, etc... as a normal Go function can do.\n\n  See [doc/code_generation.pdf](https://github.com/cosmos72/gomacro/blob/master/doc/code_generation.pdf)\n  for an introduction to the topic.\n\n## Installation\n\n### Prerequites\n\n- [Go 1.18+](https://golang.org/doc/install)\n\n### Supported platforms\n\nGomacro is pure Go, and in theory it should work on any platform supported by the Go compiler.\nThe following combinations are tested and known to work:\n\n- Linux: amd64, 386, arm64, arm, mips, ppc64le\n- Mac OS X: amd64, 386 (386 binaries running on amd64 system)\n- Windows: amd64, 386\n- FreeBSD: amd64, 386\n- Android: arm64, arm (tested with [Termux](https://termux.com/) and the Go compiler distributed with it)\n\n### How to install\n\n  The command\n  ```\n  go install github.com/cosmos72/gomacro@latest\n  ```\n  downloads, compiles and installs gomacro and its dependencies\n\n## Current Status\n\nAlmost complete.\n\nThe main limitations and missing features are:\n\n* importing 3<sup>rd</sup> party libraries at runtime currently only works on Linux, Mac OS X and *BSD.\n  On other systems as Windows and Android it is cumbersome and requires recompiling - see [Importing packages](#importing-packages).\n* when importing packages, both from standard library or from 3<sup>rd</sup> party libraries, generics are not imported.\n* defining generic functions and types in interpreted code is experimental and incomplete - see [Generics](#generics)\n* conversions from/to unsafe.Pointer are not supported.\n* some corner cases using interpreted interfaces, as interface -> interface type assertions and type switches, are not implemented yet.\n* some corner cases using recursive types may not work correctly.\n* goto can only jump backward, not forward\n* out-of-order code is under testing - some corner cases, as for example out-of-order declarations\n  used in keys of composite literals, are not supported.\n  Clearly, at REPL code is still executed as soon as possible, so it makes a difference mostly\n  if you separate multiple declarations with ; on a single line. Example: `var a = b; var b = 42`\\\n  Support for \"batch mode\" is in progress - it reads as much source code as possible before executing it,\n  and it's useful mostly to execute whole files or directories.\n\nThe [documentation](doc/) also contains the [full list of features and limitations](doc/features-and-limitations.md)\n\n## Extensions\n\nCompared to compiled Go, gomacro supports several extensions:\n\n* an integrated debugger, see [Debugger](#debugger)\n\n* configurable special commands. Type `:help` at REPL to list them,\n  and see [cmd.go:37](https://github.com/cosmos72/gomacro/blob/master/fast/cmd.go#L37)\n  for the documentation and API to define new ones.\n\n* untyped constants can be manipulated directly at REPL. Examples:\n    ```\n\tgomacro> 1<<100\n\t{int 1267650600228229401496703205376}\t// untyped.Lit\n\tgomacro> const c = 1<<100; c * c / 100000000000\n\t{int 16069380442589902755419620923411626025222029937827}\t// untyped.Lit\n\t```\n  This provides a handy arbitrary-precision calculator.\n\n  Note: operations on large untyped integer constants are always exact,\n  while operations on large untyped float constants are implemented with `go/constant.Value`,\n  and are exact as long as both numerator and denominator are <= 5e1232.\n\n  Beyond that, `go/constant.Value` switches from `*big.Rat` to `*big.Float`\n  with precision = 512, which can accumulate rounding errors.\n\n  If you need **exact** results, convert the untyped float constant to `*big.Rat`\n  (see next item) before exceeding 5e1232.\n\n* untyped constants can be converted implicitly to `*big.Int`, `*big.Rat` and `*big.Float`. Examples:\n    ```go\n\timport \"math/big\"\n\tvar i *big.Int = 1<<1000                 // exact - would overflow int\n\tvar r *big.Rat = 1.000000000000000000001 // exact - different from 1.0\n\tvar s *big.Rat = 5e1232                  // exact - would overflow float64\n\tvar t *big.Rat = 1e1234                  // approximate, exceeds 5e1232\n\tvar f *big.Float = 1e646456992           // largest untyped float constant that is different from +Inf\n    ```\n  Note: every time such a conversion is evaluated, it creates a new value - no risk to modify the constant.\n\n  Be aware that converting a huge value to string, as typing `f` at REPL would do, can be very slow.\n\n* zero value constructors: for any type `T`, the expression `T()`\n  returns the zero value of the type\n\n* macros, quoting and quasiquoting: see\n  [doc/code_generation.pdf](https://github.com/cosmos72/gomacro/blob/master/doc/code_generation.pdf)\n\nand slightly relaxed checks:\n\n* unused variables and unused return values never cause errors\n\n## Examples\n\nSome short, notable examples - to run them on non-Linux platforms, see [Importing packages](#importing-packages) first.\n\n### plot mathematical functions\n\n* install libraries: `go get gonum.org/v1/plot gonum.org/v1/plot/plotter gonum.org/v1/plot/vg`\n* start the interpreter: `gomacro`\n* at interpreter prompt, paste the whole Go code listed at https://github.com/gonum/plot/wiki/Example-plots#functions\n  (the source code starts after the picture under the section \"Functions\", and ends just before the section \"Histograms\")\n* still at interpreter prompt, enter `main()`\n  If all goes well, it will create a file named \"functions.png\" in current directory containing the plotted functions.\n\n### simple mandelbrot web server\n\n* install libraries: `go get github.com/sverrirab/mandelbrot-go`\n* chdir to mandelbrot-go source folder: `cd; cd go/src/github.com/sverrirab/mandelbrot-go`\n* start interpreter with arguments: `gomacro -i mbrot.go`\n* at interpreter prompt, enter `init(); main()`\n* visit http://localhost:8090/\n  Be patient, rendering and zooming mandelbrot set with an interpreter is a little slow.\n\nFurther examples are listed by [Gophernotes](https://github.com/gopherdata/gophernotes/#example-notebooks-dowload-and-run-them-locally-follow-the-links-to-view-in-github-or-use-the-jupyter-notebook-viewer)\n\n## Importing packages\n\nGomacro supports the standard Go syntax `import`, including package renaming. Examples:\n```go\nimport \"fmt\"\nimport (\n    \"io\"\n    \"net/http\"\n    r \"reflect\"\n)\n```\nThird party packages - i.e. packages not in Go standard library - can also be imported with the same syntax.\n\nExtension: unpublished packages can also be imported from a local filesystem directory (implemented on 2022-05-28). Supported syntaxes are:\n```go\nimport (\n     \".\"                             // imports the package in current directory\n     \"..\"                            // imports the package in parent directory\n     \"./some/relative/path\"          // \"./\"  means relative to current directory\n     \"../some/other/relative/path\"   // \"../\" means relative to parent directory\n     \"/some/absolute/path\"           // \"/\"   means absolute\n)\n```\n\nFor an import to work, you usually need to follow its installation procedure: sometimes there are additional prerequisites to install, and the typical command `go get PACKAGE-PATH` may or may not be needed.\n\nThe next steps depend on the system you are running gomacro on:\n\n### Linux, Mac OS X and *BSD\n\nIf you are running gomacro on Linux, Mac OS X or *BSD, `import` will then just work:\nit will automatically download, compile and import a package. Example:\n```\n$ gomacro\n[greeting message...]\n\ngomacro> import ( \"gonum.org/v1/gonum/floats\"; \"gonum.org/v1/plot\" )\n// debug: running \"go get gonum.org/v1/plot gonum.org/v1/gonum/floats\" ...\ngo: downloading gonum.org/v1/gonum v0.12.0\ngo: downloading gonum.org/v1/plot v0.12.0\n[ more \"go: downloading \" messages for dependencies...]\ngo: added gonum.org/v1/gonum v0.12.0\ngo: added gonum.org/v1/plot v0.12.0\n// debug: running \"go mod tidy\" ...\ngo: downloading golang.org/x/exp v0.0.0-20220827204233-334a2380cb91\ngo: downloading github.com/go-fonts/latin-modern v0.2.0\ngo: downloading rsc.io/pdf v0.1.1\ngo: downloading github.com/go-fonts/dejavu v0.1.0\n// debug: compiling plugin \"/home/max/go/src/gomacro.imports/gomacro_pid_44092/import_1\" ...\n\ngomacro> floats.Sum([]float64{1,2,3})\n6       // float64\n```\n\nNote: internally, gomacro will compile and load a **single** Go plugin containing the exported declarations\nof all the packages listed in `import ( ... )`.\n\nThe command `go mod tidy` is automatically executed before compiling the plugin, and it tries - among other things -\nto resolve any version conflict due to different versions of the same package being imported directly\n(i.e. listed in `import ( ... )`) or indirectly (i.e. as a required dependency).\n\nGo plugins are currently supported only on Linux and Mac OS X.\n\n**WARNING** On Mac OS X, **never** execute `strip gomacro`: it breaks plugin support,\n            and loading third party packages stops working.\n\n\n### Other systems\n\nOn all other systems as Windows, Android and *BSD you can still use `import`,\nbut there are more steps: you need to manually download the package,\nand you also need to recompile gomacro after the `import` (it will tell you).\nExample:\n```\n$ go get gonum.org/v1/plot\n$ gomacro\n[greeting message...]\n\ngomacro> import \"gonum.org/v1/plot\"\n// warning: created file \"/home/max/go/src/github.com/cosmos72/gomacro/imports/thirdparty/gonum_org_v1_plot.go\", recompile gomacro to use it\n```\n\nNow quit gomacro, recompile and reinstall it:\n```\ngomacro> :quit\n$ go install github.com/cosmos72/gomacro\n```\n\nFinally restart it. Your import is now linked **inside** gomacro and will work:\n```\n$ gomacro\n[greeting message...]\n\ngomacro> import \"gonum.org/v1/plot\"\ngomacro> plot.New()\n&{...} // *plot.Plot\n<nil>  // error\n```\n\nNote: if you need several packages, you can first `import` all of them,\nthen quit and recompile gomacro only once.\n\n## Generics\n\ngomacro contains two alternative, experimental versions of Go generics:\n\n* the first version is modeled after C++ templates, and is appropriately named \"C++ style\"\\\n  See [doc/generics-c++.md](doc/generics-c++.md) for how to enable and use them.\n\n* the second version is named \"contracts are interfaces\" - or more briefly \"CTI\".\n  It is modeled after several preliminary proposals for Go generics,\n  most notably Ian Lance Taylor's [Type Parameters in Go](https://github.com/golang/proposal/blob/master/design/15292/2013-12-type-params.md)\n  It has some additions inspired from [Haskell generics](https://wiki.haskell.org/Generics)\n  and original contributions from the author - in particular to create a simpler alternative to\n  [Go 2 contracts](https://go.googlesource.com/proposal/+/master/design/go2draft-contracts.md)\n\n  For their design document and reasoning behind some of the design choices, see [doc/generics-cti.md](doc/generics-cti.md)\n\nThe second version of generics \"CTI\" is enabled by default in gomacro.\n\nThey are in beta status, and at the moment only generic types and functions are supported.\nSyntax and examples:\n```go\n// declare a generic type with two type arguments T and U\ntype Pair#[T,U] struct {\n\tFirst T\n\tSecond U\n}\n\n// instantiate the generic type using explicit types for T and U,\n// and create a variable of such type.\nvar pair Pair#[complex64, struct{}]\n\n// equivalent:\npair := Pair#[complex64, struct{}] {}\n\n// a more complex example, showing higher-order functions\nfunc Transform#[T,U](slice []T, trans func(T) U) []U {\n\tret := make([]U, len(slice))\n\tfor i := range slice {\n\t\tret[i] = trans(slice[i])\n\t}\n\treturn ret\n}\nTransform#[string,int] // returns func([]string, func(string) int) []int\n\n// returns []int{3, 2, 1} i.e. the len() of each string in input slice:\nTransform#[string,int]([]string{\"abc\",\"xy\",\"z\"}, func(s string) int { return len(s) })\n```\nContracts specify the available methods of a generic type.\nFor simplicity, they do not introduce a new syntax or new language concepts:\ncontracts are just (generic) interfaces.\nWith a tiny addition, actually: the ability to optionally indicate the receiver type.\n\nFor example, the contract specifying that values of type `T` can be compared with each other\nto determine if the first is less, equal or greater than the second is:\n```Go\ntype Comparable#[T] interface {\n\t// returns -1 if a is less than b\n\t// returns  0 if a is equal to b\n\t// returns  1 if a is greater than b\n\tfunc (a T) Cmp(b T) int\n}\n```\nA type `T` implements `Comparable#[T]` if it has a method `func (T) Cmp(T) int`.\nThis interface is carefully chosen to match the existing methods of\n`*math/big.Float`, `*math/big.Int` and `*math/big.Rat`.\nIn other words, `*math/big.Float`, `*math/big.Int` and `*math/big.Rat` already implement it.\n\nWhat about basic types as `int8`, `int16`, `int32`, `uint`... `float*`, `complex*` ... ?\nGomacro extends them, automatically adding many methods equivalent to the ones declared\non `*math/big.Int` to perform arithmetic and comparison, including `Cmp` which is\ninternally defined as (no need to define it yourself):\n```Go\nfunc (a int) Cmp(b int) int {\n\tif a < b {\n\t\treturn -1\n\t} else if a > b {\n\t\treturn 1\n\t} else {\n\t\treturn 0\n\t}\n}\n```\nThus the generic functions `Min` and `Max` can be written as\n```Go\nfunc Min#[T: Comparable] (a, b T) T {\n\tif a.Cmp(b) < 0 { // also <= would work\n\t\treturn a\n\t}\n\treturn b\n}\nfunc Max#[T: Comparable] (a, b T) T {\n\tif a.Cmp(b) > 0 { // also >= would work\n\t\treturn a\n\t}\n\treturn b\n}\n```\nWhere the syntax `#[T: Comparable]` or equivalently `#[T: Comparable#[T]]`\nindicates that `T` must satisfy the contract (implement the interface) `Comparable#[T]`\n\nSuch functions `Min` and `Max` will then work automatically for every type `T`\nthat satisfies the contract (implements the interface) `Comparable#[T]`:\\\nall basic integers and floats, plus `*math/big.Float`, `*math/big.Int` and `*math/big.Rat`,\nplus every user-defined type `T` that has a method `func (T) Cmp(T) int`\n\nIf you do not specify the contract(s) that a type must satisfy, generic functions\ncannot access the fields and methods of a such type, which is then treated\nas a \"black box\", similarly to `interface{}`.\n\nTwo values of type `T` can be added if `T` has an appropriate method.\nBut which name and signature should we choose to add values?\nCopying again from `math/big`, the method we choose is `func (T) Add(T,T) T`\nIf receiver is a pointer, it will be set to the result - in any case,\nthe result will also be returned.\nSimilarly to `Comparable`, the contract `Addable` is then\n```Go\ntype Addable#[T] interface {\n\t// Add two values a, b and return the result.\n\t// If recv is a pointer, it must be non-nil\n\t// and it will be set to the result\n\tfunc (recv T) Add(a, b T) T\n}\n```\nWith such a contract, a generic function `Sum` is quite straightforward:\n```Go\nfunc Sum#[T: Addable] (args ...T) T {\n\t// to create the zero value of T,\n\t// one can write 'var sum T' or equivalently 'sum := T()'\n\t// Unluckily, that's not enough for math/big numbers, which require\n\t// the receiver of method calls to be created with a function `New()`\n\t// Once math/big numbers have such method, the following\n\t// will be fully general - currently it works only on basic types.\n\tsum := T().New()\n\n\tfor _, elem := range args {\n\t\t// use the method T.Add(T, T)\n\t\t//\n\t\t// as an optimization, relevant at least for math/big numbers,\n\t\t// also use sum as the receiver where result of Add will be stored\n\t\t// if the method Add has pointer receiver.\n\t\t//\n\t\t// To cover the case where method Add has instead value receiver,\n\t\t// also assign the returned value to sum\n\t\tsum = sum.Add(sum, elem)\n\t}\n\treturn sum\n}\nSum#[int]         // returns func(...int) int\nSum#[int] (1,2,3) // returns int(6)\n\nSum#[complex64]                 // returns func(...complex64) complex64\nSum#[complex64] (1.1+2.2i, 3.3) // returns complex64(4.4+2.2i)\n\nSum#[string]                         // returns func(...string) string\nSum#[string](\"abc.\",\"def.\",\"xy\",\"z\") // returns \"abc.def.xyz\"\n\n```\nPartial and full specialization of generics is **not** supported in CTI generics,\nboth for simplicity and to avoid accidentally providing Turing completeness at compile-time.\n\nInstantiation of generic types and functions is on-demand.\n\nCurrent limitations:\n* type inference on generic arguments #[...] is not yet implemented,\n  thus generic arguments #[...] must be explicit.\n* generic methods are not yet implemented.\n* types are not checked to actually satisfy contracts.\n\n## Debugger\n\nSince version 2.6, gomacro also has an integrated debugger.\nThere are three ways to enter it:\n* hit CTRL+C while interpreted code is running.\n* type `:debug STATEMENT-OR-FUNCTION-CALL` at the prompt.\n* add a statement (an expression is not enough) `\"break\"` or `_ = \"break\"` to your code, then execute it normally.\n\nIn all cases, execution will be suspended and you will get a `debug>` prompt, which accepts the following commands:\\\n`step`, `next`, `finish`, `continue`, `env [NAME]`, `inspect EXPR`, `list`, `print EXPR-OR-STATEMENT`\n\nAlso,\n* commands can be abbreviated.\n* `print` fully supports expressions or statements with side effects, including function calls and modifying local variables.\n* `env` without arguments prints all global and local variables.\n* an empty command (i.e. just pressing enter) repeats the last command.\n\nOnly interpreted statements can be debugged: expressions and compiled code will be executed, but you cannot step into them.\n\nThe debugger is quite new, and may have some minor glitches.\n\n## Why it was created\n\nFirst of all, to experiment with Go :)\n\nSecond, to simplify Go code generation tools (keep reading for the gory details)\n\n---\n\nProblem: \"go generate\" and many other Go tools automatically create\nGo source code from some kind of description - usually an interface\nspecifications as WSDL, XSD, JSON...\n\nSuch specification may be written in Go, for example when creating JSON\nmarshallers/unmarshallers from Go structs, or in some other language,\nfor example when creating Go structs from JSON sample data.\n\nIn both cases, a variety of external programs are needed to\ngenerate Go source code: such programs need to be installed\nseparately from the code being generated and compiled.\n\nAlso, Go is currently lacking generics (read: C++-like templates)\nbecause of the rationale \"we do not yet know how to do them right,\nand once you do them wrong everybody is stuck with them\"\n\nThe purpose of Lisp-like macros is to execute arbitrary code\nwhile compiling, **in particular** to generate source code.\n\nThis makes them very well suited (although arguably a bit low level)\nfor both purposes: code generation and C++-like templates, which\nare a special case of code generation - for a demonstration of how\nto implement C++-like templates on top of Lisp-like macros,\nsee for example the project https://github.com/cosmos72/cl-parametric-types\nfrom the same author.\n\nBuilding a Go interpreter that supports Lisp-like macros,\nallows to embed all these code-generation activities\ninto regular Go source code, without the need for external programs\n(except for the interpreter itself).\n\nAs a free bonus, we get support for Eval()\n\n## LEGAL\n\nGomacro is distributed under the terms of [Mozilla Public License 2.0](LICENSE)\nor any later version.\n"
        },
        {
          "name": "TrickyGo.md",
          "type": "blob",
          "size": 0.841796875,
          "content": "A collection of tricky go code\n\n```\n// change the meaning of true\nconst true = false\nprintln(true)\n```\n\n```\n// change the meaning of uint\ntype uint int\nprintln(uint(1))\n```\n\n```\n// change the meaning of uint (again)\nfunc uint(x int) int { return x + 7 }\nprintln(uint(1))\n```\n\n```\n// nil interface values don't implement interfaces\nvar x error\ny := x.(error) // panic!\n```\n\n```\n// except that nil interface{} implements interface{}\nvar x interface{}\ny := x.(interface{}) // works\n```\n\n```\nimport \"os\"\nfunc getGoPath() string {\n\tdir := os.Getenv(\"GOPATH\")\n\tif len(dir) == 0 {\n\t\tdir := os.Getenv(\"HOME\") // shadows outer \"dir\", does NOT modify it\n\t\tif len(dir) == 0 {\n\t\t\tpanic(\"cannot determine go source directory: both $GOPATH and $HOME are unset or empty\")\n\t\t}\n\t\tdir += \"/go\"\n\t}\n\treturn dir // inner \"dir\" is not seen -> always returns os.Getenv(\"GOPATH\")\n}\n```\n"
        },
        {
          "name": "_example",
          "type": "tree",
          "content": null
        },
        {
          "name": "_experiments",
          "type": "tree",
          "content": null
        },
        {
          "name": "all_test.go",
          "type": "blob",
          "size": 71.1943359375,
          "content": "/*\n * gomacro - A Go interpreter with Lisp-like macros\n *\n * Copyright (C) 2017-2019 Massimiliano Ghilardi\n *\n *     This Source Code Form is subject to the terms of the Mozilla Public\n *     License, v. 2.0. If a copy of the MPL was not distributed with this\n *     file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n *\n * all_test.go\n *\n *  Created on: Mar 06 2017\n *      Author: Massimiliano Ghilardi\n */\n\npackage main\n\nimport (\n\t\"go/ast\"\n\t\"go/constant\"\n\t\"go/token\"\n\t\"math/big\"\n\tr \"reflect\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t. \"github.com/cosmos72/gomacro/ast2\"\n\t. \"github.com/cosmos72/gomacro/base\"\n\t\"github.com/cosmos72/gomacro/base/reflect\"\n\t\"github.com/cosmos72/gomacro/base/untyped\"\n\t\"github.com/cosmos72/gomacro/classic\"\n\t\"github.com/cosmos72/gomacro/fast\"\n\t\"github.com/cosmos72/gomacro/go/etoken\"\n\t\"github.com/cosmos72/gomacro/go/parser\"\n\txr \"github.com/cosmos72/gomacro/xreflect\"\n)\n\nvar enable_generics_v2_cti = func() bool {\n\t// enable generics v2 CTI before creating test cases\n\tetoken.GENERICS = etoken.GENERICS_V2_CTI\n\treturn true\n}()\n\n// -----------------------------------------------------------------------------\ntype TestFlag uint8\n\nconst (\n\tS  TestFlag = 1 << iota // set option OptDebugSleepOnSwitch\n\tC                       // test for classic interpreter\n\tF                       // test for fast interpreter\n\tG1                      // test requires generics v1 (C++-style)\n\tG2                      // test requires generics v2 \"contracts are interfaces\"\n\tU                       // test returns untyped constant (relevant only for fast interpreter)\n\tZ                       // temporary override: run only these tests, on fast interpreter only\n\tA  = C | F              // test for both interpreters\n\tG  = G1 | G2\n)\n\nfunc (config TestFlag) initClassic(ir *classic.Interp) {}\nfunc (config TestFlag) initFast(ir *fast.Interp)       {}\nfunc (config TestFlag) containsFlag(flag TestFlag) bool {\n\treturn config&flag != 0\n}\nfunc (config TestFlag) shouldRun(interp TestFlag) bool {\n\tif config&interp == 0 {\n\t\treturn false\n\t}\n\tif config&G1 != 0 && etoken.GENERICS.V1_CXX() {\n\t\treturn true\n\t}\n\tif config&G2 != 0 && etoken.GENERICS.V2_CTI() {\n\t\treturn true\n\t}\n\treturn config&(G1|G2) == 0\n}\n\n// -----------------------------------------------------------------------------\ntype TestFlagAndInit struct {\n\tTestFlag\n\tfuncInitClassic func(ir *classic.Interp)\n\tfuncInitFast    func(ir *fast.Interp)\n}\n\nfunc (config TestFlagAndInit) initClassic(ir *classic.Interp) {\n\tif config.funcInitClassic != nil {\n\t\tconfig.funcInitClassic(ir)\n\t}\n}\nfunc (config TestFlagAndInit) initFast(ir *fast.Interp) {\n\tif config.funcInitFast != nil {\n\t\tconfig.funcInitFast(ir)\n\t}\n}\n\n// -----------------------------------------------------------------------------\ntype TestConfig interface {\n\tcontainsFlag(flag TestFlag) bool\n\tshouldRun(interp TestFlag) bool\n\tinitClassic(ir *classic.Interp)\n\tinitFast(ir *fast.Interp)\n}\n\ntype TestCase struct {\n\tconfig  TestConfig\n\tname    string\n\tprogram string\n\tresult0 interface{}\n\tresults []interface{}\n}\n\nfunc (tc *TestCase) shouldRun(interp TestFlag) bool {\n\treturn tc.config.shouldRun(interp)\n}\n\nvar foundZ bool\n\nfunc (tc *TestCase) containsFlag(flag TestFlag) bool {\n\treturn tc.config.containsFlag(flag)\n}\n\nfunc init() {\n\tfor i := range testcases {\n\t\tif testcases[i].containsFlag(Z) {\n\t\t\tfoundZ = true\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc TestClassic(t *testing.T) {\n\tif foundZ {\n\t\tt.Skip(\"one or more tests marked with 'Z' i.e. run only those and only on fast interpreter\")\n\t}\n\tir := classic.New()\n\t// ir.Options |= OptDebugCallStack | OptDebugPanicRecover\n\tfor i := range testcases {\n\t\ttest := &testcases[i]\n\t\tif test.shouldRun(C) {\n\t\t\tt.Run(test.name, func(t *testing.T) { test.classic(t, ir) })\n\t\t}\n\t}\n}\n\nfunc TestFast(t *testing.T) {\n\tir := fast.New()\n\tfor i := range testcases {\n\t\ttest := &testcases[i]\n\t\tif (!foundZ || test.containsFlag(Z)) && test.shouldRun(F) {\n\t\t\tt.Run(test.name, func(t *testing.T) { test.fast(t, ir) })\n\t\t}\n\t}\n}\n\ntype shouldpanic struct{}\n\nfunc (shouldpanic) String() string {\n\treturn \"shouldpanic\"\n}\n\n// a value that the interpreter cannot produce.\n// only matches if the interpreter panicked\nvar panics shouldpanic\n\nvar none = []interface{}{}\n\nfunc (test *TestCase) classic(t *testing.T, ir *classic.Interp) {\n\tvar rets []r.Value\n\tpanicking := true\n\tif test.result0 == panics {\n\t\tdefer func() {\n\t\t\tif panicking {\n\t\t\t\trecover()\n\t\t\t}\n\t\t}()\n\t}\n\ttest.config.initClassic(ir)\n\n\trets = reflect.PackValuesR(ir.Eval(test.program))\n\tpanicking = false\n\ttest.compareResults(t, rets)\n}\n\nfunc (test *TestCase) fast(t *testing.T, ir *fast.Interp) {\n\tif test.containsFlag(S) {\n\t\tir.Comp.Options |= OptDebugSleepOnSwitch\n\t} else {\n\t\tir.Comp.Options &^= OptDebugSleepOnSwitch\n\t}\n\tif test.containsFlag(U) {\n\t\tir.Comp.Options |= OptKeepUntyped\n\t} else {\n\t\tir.Comp.Options &^= OptKeepUntyped\n\t}\n\t// ir.Comp.Universe.DebugDepth = 1 // only for debugging\n\n\tpanicking := true\n\tif test.result0 == panics {\n\t\tdefer func() {\n\t\t\tif panicking {\n\t\t\t\trecover()\n\t\t\t}\n\t\t}()\n\t}\n\ttest.config.initFast(ir)\n\n\trets, _ := ir.Eval(test.program)\n\trrets := xr.ToReflectValues(rets)\n\tpanicking = false\n\ttest.compareResults(t, rrets)\n}\n\nconst sum_source_string = \"func sum(n int) int { total := 0; for i := 1; i <= n; i++ { total += i }; return total }\"\nconst fibonacci_source_string = \"func fibonacci(n int) int { if n <= 2 { return 1 }; return fibonacci(n-1) + fibonacci(n-2) }\"\n\nconst switch_source_string = `func bigswitch(n int) int {\n\tfor i := 0; i < 1000; i++ {\n\t\tswitch n&15 {\n\t\tcase 0: n++\n\t\tcase 1: n+=2\n\t\tcase 2: n+=3\n\t\tcase 3: n+=4\n\t\tcase 4: n+=5\n\t\tcase 5: n+=6\n\t\tcase 6: n+=7\n\t\tcase 7: n+=8\n\t\tcase 8: n+=9\n\t\tcase 9: n+=10\n\t\tcase 10: n+=11\n\t\tcase 11: n+=12\n\t\tcase 12: n+=13\n\t\tcase 13: n+=14\n\t\tcase 14: n+=15\n\t\tcase 15: n--\n\t\t}\n\t}\n\treturn n\n}`\n\nconst interface_interpreted_1_source_string = `\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n)\n\ntype R interface {\n\tRead([]uint8) (int, error)\n}\n\ntype DevNull struct{}\n\nfunc (d DevNull) Read(b []byte) (int, error) {\n\treturn 0, io.EOF\n}\n\ntype DevZero struct{}\n\nfunc (d DevZero) Read(b []byte) (int, error) {\n\tfor i := range b {\n\t\tb[i] = 0\n\t}\n\treturn len(b), nil\n}\n\ntrue`\n\nconst interface_interpreted_2_source_string = `\n(func() bool {\n\n\tfail := func(format string, args ...interface{}) {\n\t\tpanic(fmt.Errorf(format, args...))\n\t}\n\n\tf, _ := os.Open(\"README.md\")\n\tbytes := make([]uint8, 80)\n\n\trs := [3]R{f, DevNull{}, DevZero{}}\n\tlens := [3]int{80, 0, 80}\n\terrs := [3]error{nil, io.EOF, nil}\n\n\tfor i, r := range rs {\n\t\tlen, err := r.Read(bytes)\n\t\tif len != lens[i] || err != errs[i] {\n\t\t\tfail(\"Read(): expecting (%v, %v), returned (%v, %v)\", lens[i], errs[i], len, err)\n\t\t}\n\t\tj := -1\n\t\tswitch r := r.(type) {\n\t\tcase *os.File:\n\t\t\tj = 0\n\t\t\tif r != rs[i] {\n\t\t\t\tfail(\"typeswitch: expecting %v, found %v\", rs[i], r)\n\t\t\t}\n\t\tcase DevNull:\n\t\t\tj = 1\n\t\t\tif r != rs[i] {\n\t\t\t\tfail(\"typeswitch: expecting %v, found %v\", rs[i], r)\n\t\t\t}\n\t\tcase DevZero:\n\t\t\tj = 2\n\t\t\tif r != rs[i] {\n\t\t\t\tfail(\"typeswitch: expecting %v, found %v\", rs[i], r)\n\t\t\t}\n\t\t}\n\t\tif i != j {\n\t\t\tfail(\"typeswitch: expecting j=%d, found j=%d\", i, j)\n\t\t}\n\t}\n\treturn true\n})()\n`\n\nvar (\n\tclassicInterfHeader = r.StructField{Name: StrGensymInterface, Type: r.TypeOf((*interface{})(nil)).Elem()}\n\tfastInterfHeader    = r.StructField{Name: StrGensymInterface, Type: r.TypeOf(xr.InterfaceHeader{})}\n\n\tclassicTypStringer = r.StructOf(\n\t\t[]r.StructField{\n\t\t\tclassicInterfHeader,\n\t\t\tr.StructField{Name: \"String\", Type: r.TypeOf((*func() string)(nil)).Elem()},\n\t\t},\n\t)\n\tfastTypeStringer = r.StructOf(\n\t\t[]r.StructField{\n\t\t\tfastInterfHeader,\n\t\t\tr.StructField{Name: \"String\", Type: r.TypeOf((*func() string)(nil)).Elem()},\n\t\t},\n\t)\n\tfastTypeEqint = r.StructOf(\n\t\t[]r.StructField{\n\t\t\tfastInterfHeader,\n\t\t\tr.StructField{Name: \"Equal\", Type: r.TypeOf((*func(int) bool)(nil)).Elem()},\n\t\t},\n\t)\n\tclassicObjStringer = r.Zero(classicTypStringer).Interface()\n\tfastObjStringer    = r.Zero(r.PtrTo(fastTypeStringer)).Interface()\n\tfastObjEqint       = r.Zero(r.PtrTo(fastTypeEqint)).Interface()\n)\n\nvar nil_map_int_string map[int]string\n\nfunc for_range_string(s string) int32 {\n\tvar v0 int32\n\tfor i, r := range s {\n\t\tv0 += r << (uint8(i) * 8)\n\t}\n\treturn v0\n}\n\nfunc makeQuote(node ast.Node) *ast.UnaryExpr {\n\treturn makequote2(etoken.QUOTE, node)\n}\n\nfunc makeQUASIQUOTE(node ast.Node) *ast.UnaryExpr {\n\treturn makequote2(etoken.QUASIQUOTE, node)\n}\n\nfunc makeUNQUOTE(node ast.Node) *ast.UnaryExpr {\n\treturn makequote2(etoken.UNQUOTE, node)\n}\n\nfunc makeUNQUOTE_SPLICE(node ast.Node) *ast.UnaryExpr {\n\treturn makequote2(etoken.UNQUOTE_SPLICE, node)\n}\n\nfunc makequote2(op token.Token, node ast.Node) *ast.UnaryExpr {\n\tunary, _ := parser.MakeQuote(nil, op, token.NoPos, node)\n\treturn unary\n}\n\ntype Pair = struct { // unnamed!\n\tA rune\n\tB string\n}\n\ntype PairX2 = struct { // unnamed!\n\tFirst  complex64\n\tSecond struct{}\n}\n\ntype PairX3 = struct { // unnamed!\n\tFirst  bool\n\tSecond interface{}\n}\n\ntype ListX2 = struct { // unnamed!\n\tFirst error\n\tRest  xr.Forward\n}\n\ntype ListX3 = struct { // unnamed!\n\tFirst interface{}\n\tRest  xr.Forward\n}\n\ntype TagPair = struct { // unnamed!\n\tA rune   `json:\"foo\"`\n\tB string `json:\"bar\"`\n}\n\ntype TagTriple = struct { // unnamed!\n\tA    rune\n\tB, C string `json:\"baz\"`\n}\n\n// used by test inject_recursive_type_issue_133\ntype Recursive struct {\n\tA *Recursive\n\tB int\n}\n\n// used by test inject_recursive_type_issue_133\nfunc decl_recursive_type_issue_133(ir *fast.Interp) {\n\tir.DeclType(ir.TypeOf(Recursive{}))\n}\n\n// approximate 'type X struct { *X }'\ntype structX = struct {\n\tX xr.Forward\n}\n\n// approximate 'type F func(F); var f F; &f'\nfunc makeYCombinator1() interface{} {\n\tvar f func(xr.Forward)\n\tvar fwd xr.Forward = f\n\treturn &fwd\n}\n\nvar bigInt = new(big.Int)\nvar bigRat = new(big.Rat)\nvar bigFloat = new(big.Float)\n\nfunc init() {\n\tbigInt.SetInt64(1)\n\tbigInt.Lsh(bigInt, 1000)\n\n\tbigRat.SetFrac64(1000000001, 1000000000)\n\tbigRat.Mul(bigRat, bigRat)\n\tbigRat.Mul(bigRat, bigRat)\n\n\t// use the same precision as constant.Value\n\tbigFloat.SetPrec(512)\n\tbigFloat.SetString(\"1e1234\")\n\tbigFloat.Mul(bigFloat, bigFloat)\n\tbigFloat.Mul(bigFloat, bigFloat)\n}\n\nfunc decl_generic_type_pair_str() string {\n\tif etoken.GENERICS.V1_CXX() {\n\t\treturn \"~quote{template [T1,T2] type Pair struct { First T1; Second T2 }}\"\n\t} else if etoken.GENERICS.V2_CTI() {\n\t\treturn \"~quote{type Pair#[T1,T2] struct { First T1; Second T2 }}\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nfunc decl_generic_func_sum_str() string {\n\tif etoken.GENERICS.V1_CXX() {\n\t\treturn \"~quote{template [T] func Sum([]T) T { }}\"\n\t} else if etoken.GENERICS.V2_CTI() {\n\t\treturn \"~quote{~func Sum#[T] ([]T) T { }}\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nfunc decl_generic_method_rest_str() string {\n\tif etoken.GENERICS.V1_CXX() {\n\t\treturn \"~quote{template [T] func (x Pair) Rest() T { }}\"\n\t} else if etoken.GENERICS.V2_CTI() {\n\t\treturn \"~quote{~func (x Pair) Rest#[T] () T { }}\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nfunc generic_func(name string, generic_args string) string {\n\tif etoken.GENERICS.V1_CXX() {\n\t\treturn \"template[\" + generic_args + \"] func \" + name + \" \"\n\t} else if etoken.GENERICS.V2_CTI() {\n\t\treturn \"func \" + name + \"#[\" + generic_args + \"]\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nfunc generic_type(name string, generic_args string) string {\n\tif etoken.GENERICS.V1_CXX() {\n\t\treturn \"template[\" + generic_args + \"] type \" + name + \" \"\n\t} else if etoken.GENERICS.V2_CTI() {\n\t\treturn \"type \" + name + \"#[\" + generic_args + \"]\"\n\t} else {\n\t\treturn \"\"\n\t}\n}\n\nvar testcases = []TestCase{\n\tTestCase{A, \"1+1\", \"1+1\", 1 + 1, nil},\n\tTestCase{A, \"1+'A'\", \"1+'A'\", 'B', nil}, // rune i.e. int32 should win over untyped constant (or int)\n\tTestCase{A, \"int8+1\", \"int8(1)+1\", int8(1) + 1, nil},\n\tTestCase{A, \"int8_overflow\", \"int8(64)+64\", int8(-128), nil},\n\tTestCase{A, \"string\", \"\\\"foobar\\\"\", \"foobar\", nil},\n\tTestCase{A, \"expr_and\", \"3 & 6\", 3 & 6, nil},\n\tTestCase{A, \"expr_or\", \"7 | 8\", 7 | 8, nil},\n\tTestCase{A, \"expr_xor\", \"0x1f ^ 0xf1\", 0x1f ^ 0xf1, nil},\n\tTestCase{A, \"expr_arith\", \"((1+2)*3^4|99)%112\", ((1+2)*3 ^ 4 | 99) % 112, nil},\n\tTestCase{A, \"expr_shift\", \"7<<(10>>1)\", 7 << (10 >> 1), nil},\n\tTestCase{A, \"complex_1\", \"7i\", 7i, nil},\n\tTestCase{A, \"complex_2\", \"0.5+1.75i\", 0.5 + 1.75i, nil},\n\tTestCase{A, \"complex_3\", \"1i * 2i\", 1i * 2i, nil},\n\tTestCase{A, \"const_0\", \"const c0 rune = 'x'; c0\", 'x', nil},\n\tTestCase{A, \"const_1\", \"const c1 = 11; c1\", 11, nil},\n\tTestCase{A, \"const_2\", \"const c2 = 0xff&555+23/12.2; c2\", 0xff&555 + 23/12.2, nil},\n\n\t// the classic interpreter is not accurate in these cases... missing exact arithmetic on constants\n\tTestCase{C, \"const_3\", \"const c3 = 0.1+0.2; c3\", float64(0.1) + float64(0.2), nil},\n\tTestCase{C, \"const_4\", \"const c4 = c3/3; c4\", (float64(0.1) + float64(0.2)) / 3, nil},\n\n\t// the fast interpreter instead *IS* accurate, thanks to exact arithmetic on untyped constants\n\tTestCase{F, \"const_3\", \"const c3 = 0.1+0.2; c3\", 0.1 + 0.2, nil},\n\tTestCase{F, \"const_4\", \"const c4 = c3/3; c4\", (0.1 + 0.2) / 3, nil},\n\n\tTestCase{F, \"const_complex_1\", \"const c5 = complex(c3, c4); c5\", 0.3 + 0.1i, nil},\n\tTestCase{F | U, \"untyped_const_complex_1\", \"c5\",\n\t\tuntyped.MakeLit(\n\t\t\tuntyped.Complex,\n\t\t\tconstant.BinaryOp(\n\t\t\t\tconstant.MakeFromLiteral(\"0.3\", token.FLOAT, 0),\n\t\t\t\ttoken.ADD,\n\t\t\t\tconstant.MakeFromLiteral(\"0.1i\", token.IMAG, 0)),\n\t\t\tnil),\n\t\tnil,\n\t},\n\n\tTestCase{F, \"untyped_1\", \"2.0 >> 1\", 1, nil},\n\tTestCase{A, \"untyped_2\", \"1/2\", 0, nil},\n\tTestCase{A, \"untyped_unary\", \"-+^6\", -+^6, nil},\n\tTestCase{F | U, \"untyped_const_large\", \"1<<100\",\n\t\tuntyped.MakeLit(untyped.Int, constant.Shift(constant.MakeInt64(1), token.SHL, 100), nil),\n\t\tnil,\n\t},\n\tTestCase{A, \"go1_13_binary_lit\", \"int(0b101)\", int(5), nil},\n\tTestCase{A, \"go1_13_octal_lit\", \"int(0o377)\", int(255), nil},\n\tTestCase{A, \"go1_13_hex_floating_point\", \"float32(0x1.Fp+0)\", float32(1.9375), nil},\n\tTestCase{A, \"go1_13_underscore_separator\", \"int(1_2_34)\", int(1234), nil},\n\tTestCase{F, \"go1_18_var_any\", \"var any_7 any = any(7); any_7\", 7, nil},\n\n\tTestCase{A, \"iota_1\", \"const c5 = iota^7; c5\", 7, nil},\n\tTestCase{A, \"iota_2\", \"const ( c6 = iota+6; c7=iota+6 ); c6\", 6, nil},\n\tTestCase{A, \"iota_3\", \"c7\", 7, nil},\n\tTestCase{A, \"iota_implicit_1\", \"const ( c8 uint = iota+8; c9 ); c8\", uint(8), nil},\n\tTestCase{A, \"iota_implicit_2\", \"c9\", uint(9), nil},\n\n\tTestCase{F, \"zero_value_constructor_1\", \"int()\", int(0), nil},\n\tTestCase{F, \"zero_value_constructor_2\", \"uint16()\", uint16(0), nil},\n\tTestCase{F, \"zero_value_constructor_3\", \"float32()\", float32(0), nil},\n\tTestCase{F, \"zero_value_constructor_4\", \"complex128()\", complex128(0), nil},\n\tTestCase{F, \"zero_value_constructor_5\", \"string()\", \"\", nil},\n\tTestCase{F, \"zero_value_constructor_6\", \"[]int()\", ([]int)(nil), nil},\n\tTestCase{F, \"zero_value_constructor_7\", \"[2]int()\", [2]int{0, 0}, nil},\n\tTestCase{F, \"zero_value_constructor_8\", \"map[int]int()\", (map[int]int)(nil), nil},\n\tTestCase{F, \"zero_value_constructor_9\", \"chan string()\", (chan string)(nil), nil},\n\tTestCase{F, \"zero_value_constructor_10\", \"(*bool)()\", (*bool)(nil), nil},\n\tTestCase{F, \"zero_value_constructor_11\", \"struct{Foo int}()\", struct{ Foo int }{}, nil},\n\n\tTestCase{A, \"var_0\", \"var v0 int = 11; v0\", 11, nil},\n\tTestCase{A, \"var_1\", \"var v1 bool; v1\", false, nil},\n\tTestCase{A, \"var_2\", \"var v2 uint8 = 7; v2\", uint8(7), nil},\n\tTestCase{A, \"var_3\", \"var v3 uint16 = 12; v3\", uint16(12), nil},\n\tTestCase{A, \"var_4\", \"var v uint32 = 99; v\", uint32(99), nil},\n\tTestCase{A, \"var_5\", \"var vs string; vs\", \"\", nil},\n\tTestCase{A, \"var_6\", \"var v6 float32; v6\", float32(0), nil},\n\tTestCase{A, \"var_7\", \"var v7 complex64; v7\", complex64(0), nil},\n\tTestCase{A, \"var_8\", \"var v8 complex128; v8\", complex128(0), nil},\n\tTestCase{A, \"var_9\", \"var err error; err\", nil, nil},\n\tTestCase{A, \"var_10\", `ve, vf := \"\", 1.23; ve`, \"\", nil},\n\tTestCase{A, \"var_pointer\", \"var vp *string; vp\", (*string)(nil), nil},\n\tTestCase{A, \"var_map\", \"var vm *map[error]bool; vm\", (*map[error]bool)(nil), nil},\n\tTestCase{A, \"var_slice\", \"var vbs []byte; vbs\", ([]byte)(nil), nil},\n\tTestCase{A, \"var_named_slice\", \"type Bytes []byte; var vns Bytes; vns\", ([]byte)(nil), nil},\n\tTestCase{A, \"var_array\", \"var va [2]rune; va\", [2]rune{}, nil},\n\tTestCase{A, \"var_interface_1\", \"var vi interface{} = 1; vi\", 1, nil},\n\tTestCase{A, \"var_interface_2\", \"var vnil interface{}; vnil\", nil, nil},\n\tTestCase{A, \"var_shift_1\", \"7 << 8\", 7 << 8, nil},\n\tTestCase{A, \"var_shift_2\", \"-9 >> 2\", -9 >> 2, nil},\n\tTestCase{A, \"var_shift_3\", \"v2 << 3\", uint8(7) << 3, nil},\n\tTestCase{A, \"var_shift_4\", \"v2 >> 1\", uint8(7) >> 1, nil},\n\tTestCase{A, \"var_shift_5\", \"0xff << v2\", 0xff << 7, nil},\n\tTestCase{A, \"var_shift_6\", \"0x12345678 >> v2\", 0x12345678 >> uint8(7), nil},\n\tTestCase{A, \"var_shift_7\", \"v << v2\", uint32(99) << uint8(7), nil},\n\tTestCase{A, \"var_shift_8\", \"v3 << v3 >> v2\", uint16(12) << 12 >> uint8(7), nil},\n\tTestCase{A, \"var_shift_9\", \"v3 << 0\", uint16(12), nil},\n\tTestCase{A, \"var_signed_shift_1\", \"v3 << v0\", uint16(12) << 11, nil},\n\tTestCase{A, \"var_signed_shift_2\", \"v3 >> v0\", uint16(12) >> 11, nil},\n\tTestCase{A, \"var_signed_shift_3\", \"v3 >> int(2)\", uint16(12) >> 2, nil},\n\tTestCase{A, \"var_signed_shift_4\", \"v3 << int(2)\", uint16(12) << 2, nil},\n\tTestCase{A, \"var_signed_shift_5\", \"v0 << v0\", int(11) << 11, nil},\n\tTestCase{A, \"var_signed_shift_6\", \"v0 >> v0\", int(11) >> 11, nil},\n\tTestCase{A, \"var_signed_shift_7\", \"v0 >>= int(1); v0\", int(11) >> 1, nil},\n\tTestCase{A, \"var_signed_shift_8\", \"v0 <<= int(1); v0\", int(11) >> 1 << 1, nil},\n\tTestCase{A, \"var_shift_overflow\", \"v3 << 13\", uint16(32768), nil},\n\t// test division by constant power-of-two\n\tTestCase{C, \"var_div_1\", \"v3 = 11; v3 / 2\", uint64(11) / 2, nil}, // classic interpreter is not type-accurate here\n\tTestCase{C, \"var_div_2\", \"v3 = 63; v3 / 8\", uint64(63) / 8, nil},\n\tTestCase{F, \"var_div_1\", \"v3 = 11; v3 / 2\", uint16(11) / 2, nil},\n\tTestCase{F, \"var_div_2\", \"v3 = 63; v3 / 8\", uint16(63) / 8, nil},\n\n\tTestCase{A, \"var_div_3\", \"v3 = 11; v3 /=2; v3\", uint16(11) / 2, nil},\n\tTestCase{A, \"var_div_4\", \"v3 = 63; v3 /=8; v3\", uint16(63) / 8, nil},\n\n\tTestCase{A, \"var_div_5\", \"v0 =+7; v0 /-1\", -7, nil},\n\tTestCase{A, \"var_div_6\", \"v0 =-7; v0 /+1\", -7, nil},\n\tTestCase{A, \"var_div_7\", \"v0 =-7; v0 /-1\", +7, nil},\n\tTestCase{A, \"var_div_8\", \"v0 =+11; v0 /-2\", +11 / -2, nil},\n\tTestCase{A, \"var_div_9\", \"v0 =-11; v0 /+2\", -11 / +2, nil},\n\tTestCase{A, \"var_div_10\", \"v0 =-11; v0 /-2\", -11 / -2, nil},\n\tTestCase{A, \"var_div_11\", \"v0 =+63; v0 /-8\", +63 / -8, nil},\n\tTestCase{A, \"var_div_12\", \"v0 =-63; v0 /+8\", -63 / +8, nil},\n\tTestCase{A, \"var_div_13\", \"v0 =-63; v0 /-8\", -63 / -8, nil},\n\n\t// test remainder by constant power-of-two\n\tTestCase{C, \"var_rem_1\", \"v3 = 17; v3 % 4\", uint64(17) % 4, nil}, // classic interpreter is not type-accurate here\n\tTestCase{C, \"var_rem_2\", \"v3 = 61; v3 % 8\", uint64(61) % 8, nil},\n\tTestCase{F, \"var_rem_1\", \"v3 = 17; v3 % 4\", uint16(17) % 4, nil},\n\tTestCase{F, \"var_rem_2\", \"v3 = 61; v3 % 8\", uint16(61) % 8, nil},\n\n\tTestCase{A, \"var_rem_3\", \"v0 =+17; v0 %-4\", +17 % -4, nil},\n\tTestCase{A, \"var_rem_4\", \"v0 =-17; v0 %+4\", -17 % +4, nil},\n\tTestCase{A, \"var_rem_5\", \"v0 =-17; v0 %-4\", -17 % -4, nil},\n\tTestCase{A, \"var_rem_6\", \"v0 =+61; v0 %-8\", +61 % -8, nil},\n\tTestCase{A, \"var_rem_7\", \"v0 =-61; v0 %+8\", -61 % +8, nil},\n\tTestCase{A, \"var_rem_8\", \"v0 =-61; v0 %-8\", -61 % -8, nil},\n\n\tTestCase{A, \"eql_nil_1\", \"err == nil\", true, nil},\n\tTestCase{A, \"eql_nil_2\", \"vp == nil\", true, nil},\n\tTestCase{A, \"eql_nil_3\", \"vm == nil\", true, nil},\n\tTestCase{A, \"eql_nil_4\", \"vbs == nil\", true, nil},\n\tTestCase{A, \"eql_nil_5\", \"vi == nil\", false, nil},\n\tTestCase{A, \"eql_nil_6\", \"vnil == nil\", true, nil},\n\tTestCase{A, \"eql_halfnil_1\", \"var vhalfnil interface{} = vm; vhalfnil == nil\", false, nil},\n\tTestCase{A, \"eql_halfnil_2\", \"vm = nil; vhalfnil = vm; vhalfnil == nil\", false, nil},\n\tTestCase{A, \"eql_interface\", \"vi == 1\", true, nil},\n\n\tTestCase{A, \"typed_unary_1\", \"!!!v1\", true, nil},\n\tTestCase{A, \"typed_unary_2\", \"+-^v2\", uint8(8), nil},\n\tTestCase{A, \"typed_unary_3\", \"v3 = 12; +^-v3\", uint16(11), nil},\n\tTestCase{A, \"typed_unary_4\", \"v7 = 2.5i; -v7\", complex64(-2.5i), nil},\n\tTestCase{A, \"typed_unary_5\", \"v8 = 3.75i; -v8\", complex128(-3.75i), nil},\n\n\tTestCase{A, \"type_int8\", \"type t8 int8; var u8 t8; u8\", int8(0), nil},\n\tTestCase{A, \"type_complicated\", \"type tfff func(int,int) func(error, func(bool)) string; var vfff tfff; vfff\", (func(int, int) func(error, func(bool)) string)(nil), nil},\n\tTestCase{C, \"type_interface_1\", \"type Stringer interface { String() string }; var s Stringer; s\", classicObjStringer, nil},\n\tTestCase{F, \"type_interface_1\", \"type Stringer interface { String() string }; var s Stringer; s\", fastObjStringer, nil},\n\tTestCase{F, \"type_struct_0\", \"type PairPrivate struct { a, b rune }; var pp PairPrivate; pp.a+pp.b\", rune(0), nil},\n\tTestCase{A, \"type_struct_1\", \"type Pair struct { A rune; B string}; var pair Pair; pair\", Pair{}, nil},\n\tTestCase{A, \"type_struct_2\", \"type Triple struct { Pair; C float32 }; var triple Triple; triple.C\", float32(0), nil},\n\tTestCase{A, \"type_struct_3\", \"type TripleP struct { *Pair; D float64 }; var tp TripleP; tp.D\", float64(0), nil},\n\tTestCase{F, \"tagged_struct_1\", \"type TagPair struct { A rune `json:\\\"foo\\\"`; B string `json:\\\"bar\\\"`}; var tagpair TagPair; tagpair\", TagPair{}, nil},\n\tTestCase{F, \"tagged_struct_2\", \"type TagTriple struct { A rune; B, C string `json:\\\"baz\\\"`}; TagTriple{}\", TagTriple{}, nil},\n\n\tTestCase{A, \"field_get_1\", \"pair.A\", rune(0), nil},\n\tTestCase{A, \"field_get_2\", \"pair.B\", \"\", nil},\n\tTestCase{F, \"field_anonymous_1\", \"triple.Pair\", Pair{}, nil},\n\tTestCase{F, \"field_anonymous_2\", \"type X struct { *X }; X{}\", structX{(*structX)(nil)}, nil},\n\tTestCase{F, \"field_embedded_1\", \"triple.A\", rune(0), nil},\n\tTestCase{F, \"field_embedded_2\", \"triple.B\", \"\", nil},\n\tTestCase{F, \"field_embedded_3\", \"triple.Pair.A\", rune(0), nil},\n\tTestCase{F, \"field_embedded_4\", \"triple.Pair.B\", \"\", nil},\n\tTestCase{F, \"field_embedded_5\", \"tp.A\", panics, nil},\n\tTestCase{F, \"field_embedded_6\", \"tp.Pair = &triple.Pair; tp.B\", \"\", nil},\n\n\tTestCase{F, \"self_embedded_1\", \"X{}.X\", (*structX)(nil), nil},\n\tTestCase{F, \"self_embedded_2\", \"var x X; x.X = &x; x.X.X.X.X.X.X.X.X == &x\", true, nil},\n\tTestCase{F, \"self_embedded_3\", \"x.X.X.X == x.X.X.X.X.X\", true, nil},\n\n\tTestCase{F, \"recursive_type_gomacro_issue_44\", `{\n\t\ttype FS struct { slice []FS }\n\t\tfs := make([]FS, 8)\n\t\tfs[0].slice = fs[1:8]\n\t}`, nil, none},\n\n\tTestCase{F, \"recursive_type_gomacro_issue_110\", `{\n\t\ttype ListNode struct { Next *ListNode }\n\t\ttype LinkedList struct { Head *ListNode }\n\t\tvar node ListNode\n\t\tvar list LinkedList\n\t\tlist.Head = &node\n\t}`, nil, none},\n\n\tTestCase{F, \"recursive_type_gophernotes_issue_208\", `{\n\t\ttype Item struct {\n\t\t    Name               string\n\t\t    Children           []Item\n\t\t}\n\t\tgraph := Item{\n\t\t    Name: \"my-name\",\n\t\t    Children: []Item{\n\t\t        {Name: \"other-name\"},\n\t\t    },\n\t\t}\n\t}`, nil, none},\n\n\tTestCase{A, \"address_0\", \"var vf = 1.25; *&vf == vf\", true, nil},\n\tTestCase{A, \"address_1\", \"var pvf = &vf; *pvf\", 1.25, nil},\n\tTestCase{A, \"address_2\", \"&*pvf == *&pvf\", true, nil},\n\tTestCase{A, \"address_3\", \"var pvs = &vbs; v1 = (*pvs == nil); v1\", true, nil},\n\n\tTestCase{A, \"make_chan\", \"cx := make(chan interface{}, 2); cx\", make(chan interface{}, 2), nil},\n\tTestCase{A, \"make_map\", \"m := make(map[int]string); m\", make(map[int]string), nil},\n\tTestCase{A, \"make_slice\", \"y := make([]uint8, 7); y[0] = 100; y[3] = 103; y\", []uint8{100, 0, 0, 103, 0, 0, 0}, nil},\n\tTestCase{A, \"expr_index_string_1\", `\"abc\"[2]`, byte('c'), nil},\n\tTestCase{A, \"expr_index_string_2\", `vs = \"foo\"; v0 = 0; vs[v0]`, byte('f'), nil},\n\tTestCase{A, \"expr_index_array_1\", `va[1]`, rune(0), nil},\n\tTestCase{A, \"expr_index_array_2\", `(&va)[0]`, rune(0), nil},\n\tTestCase{A, \"expr_index_map\", `var m2 map[rune]string; m2['x']`, nil, []interface{}{\"\", false}},\n\tTestCase{A, \"expr_slice_0\", \"y[:]\", []uint8{100, 0, 0, 103, 0, 0, 0}, nil},\n\tTestCase{A, \"expr_slice_1\", \"y[1:]\", []uint8{0, 0, 103, 0, 0, 0}, nil},\n\tTestCase{A, \"expr_slice_2\", \"y[2:4]\", []uint8{0, 103}, nil},\n\tTestCase{A, \"expr_slice_3\", \"y[:3]\", []uint8{100, 0, 0}, nil},\n\tTestCase{A, \"expr_slice_4\", \"y = y[:3:7]; y\", []uint8{100, 0, 0}, nil},\n\tTestCase{A, \"expr_slice_5\", `\"abc\"[:]`, \"abc\", nil},\n\tTestCase{A, \"expr_slice_6\", `\"abc\"[1:]`, \"bc\", nil},\n\tTestCase{A, \"expr_slice_7\", `\"abc\"[1:2]`, \"b\", nil},\n\n\tTestCase{A, \"set_const_1\", \"v1 = true;    v1\", true, nil},\n\tTestCase{A, \"set_const_2\", \"v2 = 9;       v2\", uint8(9), nil},\n\tTestCase{A, \"set_const_3\", \"v3 = 60000;   v3\", uint16(60000), nil},\n\tTestCase{A, \"set_const_4\", \"v  = 987;      v\", uint32(987), nil},\n\tTestCase{A, \"set_const_5\", `vs = \"8y57r\"; vs`, \"8y57r\", nil},\n\tTestCase{A, \"set_const_6\", \"v6 = 0.12345678901234; v6\", float32(0.12345678901234), nil},  // v6 is declared float32\n\tTestCase{A, \"set_const_7\", \"v7 = 0.98765432109i;   v7\", complex64(0.98765432109i), nil},  // v7 is declared complex64\n\tTestCase{A, \"set_const_8\", \"v8 = 0.98765432109i;   v8\", complex128(0.98765432109i), nil}, // v8 is declared complex128\n\n\tTestCase{A, \"set_expr_1\", \"v1 = v1 == v1;    v1\", true, nil},\n\tTestCase{A, \"set_expr_2\", \"v2 -= 7;          v2\", uint8(2), nil},\n\tTestCase{A, \"set_expr_3\", \"v3 %= 7;          v3\", uint16(60000) % 7, nil},\n\tTestCase{A, \"set_expr_4\", \"v  = v * 10;       v\", uint32(9870), nil},\n\tTestCase{A, \"set_expr_5\", `vs = vs + \"iuh\";  vs`, \"8y57riuh\", nil},\n\tTestCase{A, \"set_expr_6\", \"v6 = 1/v6;        v6\", 1 / float32(0.12345678901234), nil},                          // v6 is declared float32\n\tTestCase{A, \"set_expr_7\", \"v7 = v7 * v7;     v7\", -complex64(0.98765432109) * complex64(0.98765432109), nil},   // v7 is declared complex64\n\tTestCase{A, \"set_expr_8\", \"v8 = v8 * v8;     v8\", -complex128(0.98765432109) * complex128(0.98765432109), nil}, // v8 is declared complex64\n\tTestCase{A, \"set_expr_9\", `v9 := 0; { a := 1; { b := a+1; { c := b+1; { v9 = c+1 } } } }; v9`, int(4), nil},\n\n\tTestCase{A, \"add_2\", \"v2 += 255;    v2\", uint8(1), nil}, // overflow\n\tTestCase{A, \"add_3\", \"v3 += 536;    v3\", uint16(60000)%7 + 536, nil},\n\tTestCase{A, \"add_4\", \"v  += 111;     v\", uint32(9870 + 111), nil},\n\tTestCase{A, \"add_5\", `vs += \"@#$\";  vs`, \"8y57riuh@#$\", nil},\n\tTestCase{A, \"add_6\", \"v6 += 0.975319; v6\", 1/float32(0.12345678901234) + float32(0.975319), nil}, // v6 is declared float32\n\tTestCase{A, \"add_7\", \"v7 = 1; v7 += 0.999999i; v7\", complex(float32(1), float32(0.999999)), nil}, // v7 is declared complex64\n\tTestCase{A, \"add_8\", \"v8 = 1; v8 += 0.999999i; v8\", complex(1, 0.999999), nil},                   // v8 is declared complex128\n\n\tTestCase{A, \"mul_1\", \"v2 = 4;  v2 *= 3; v2\", uint8(12), nil},\n\tTestCase{A, \"rem_1\", \"v3 = 12; v3 %= 7; v3\", uint16(5), nil},\n\tTestCase{A, \"and_1\", \"v3 &= 9;          v3\", uint16(1), nil},\n\n\tTestCase{A, \"shift_1\", \"v3 <<= 7;       v3\", uint16(128), nil},\n\tTestCase{A, \"shift_2\", \"v3 >>= (v3>>5); v3\", uint16(128 >> (128 >> 5)), nil},\n\n\tTestCase{A, \"if_1\", \"v2 = 1; if v2 < 1 { v2 = v2-1 } else { v2 = v2+1 }; v2\", uint8(2), nil},\n\tTestCase{A, \"if_2\", \"if v2 < 5 { v2 = v2+2 } else { v2 = v2-2 }; v2\", uint8(4), nil},\n\tTestCase{A, \"for_1\", \"var i, j, k int; for i=1; i<=2; i=i+1 { if i<2 {j=i} else {k=i} }; i\", 3, nil},\n\tTestCase{A, \"for_2\", \"j\", 1, nil},\n\tTestCase{A, \"for_3\", \"k\", 2, nil},\n\tTestCase{A, \"for_nested\", `x := 0\n\t\t{\n\t\t\tvar n1, n2, n3 = 2, 3, 5\n\t\t\tfor i := 0; i < n1; i++ {\n\t\t\t\tfor j := 0; j < n2; j++ {\n\t\t\t\t\tfor k := 0; k < n3; k++ {\n\t\t\t\t\t\tx++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tx`, 2 * 3 * 5, nil},\n\tTestCase{A, \"continue_1\", \"j=0; k=0; for i:=1; i<=7; i=i+1 { if i==3 {j=i; continue}; k=k+i }; j\", 3, nil},\n\tTestCase{A, \"continue_2\", \"k\", 25, nil},\n\tTestCase{A, \"continue_3\", \"j=0; k=0; for i:=1; i<=7; i=i+1 { var ii = i; if ii==3 {j=ii; continue}; k=k+ii }; j\", 3, nil},\n\tTestCase{A, \"continue_4\", \"k\", 25, nil},\n\n\tTestCase{A, \"for_range_array\", `v0 = 0; for _, s := range [2]string{\"a\", \"bc\"} { v0 += len(s); continue }; v0`, 3, nil},\n\tTestCase{A, \"for_range_ptr_array\", `v0 = 0; var vis string; for _, vis = range &[...]string{\"999\", \"1234\"} { v0 += len(vis); continue }; v0`, 7, nil},\n\tTestCase{A, \"for_range_chan\", `v0 = 0; c := make(chan int, 2); c <- 1; c <- 2; close(c); for e := range c { v0 += e; continue }; v0`, 3, nil},\n\tTestCase{A, \"for_range_map\", `var vrune rune; m2 = map[rune]string{'x':\"x\", 'y':\"y\", 'z':\"z\"}; for k,v := range m2 { vrune += k + rune(v[0]); continue }; vrune`,\n\t\t('x' + 'y' + 'z') * 2, nil},\n\tTestCase{A, \"for_range_slice\", `v0 = 0; for _, s := range [ ]string{\"a\", \"bc\"} { v0 += len(s); continue }; v0`, 3, nil},\n\tTestCase{A, \"for_range_string\", `vrune = 0; for i, r := range \"abc\\u00ff\" { vrune += r << (uint8(i)*8); continue }; vrune`, for_range_string(\"abc\\u00ff\"), nil},\n\n\tTestCase{A, \"function_0\", \"func nop() { }; nop()\", nil, none},\n\tTestCase{A, \"function_1\", \"func seven() int { return 7 }; seven()\", 7, nil},\n\tTestCase{A, \"function_2\", \"i=0; func seti(ii int) { i=ii }; seti(-493); i\", -493, nil},\n\tTestCase{A, \"function_3\", \"func ident(x uint) uint { return x }; ident(42)\", uint(42), nil},\n\tTestCase{A, \"function_4\", \"func equal(x, y float32) bool { return x == y }; equal(1.1, 1.1)\", true, nil},\n\tTestCase{A, \"function_5\", \"func swap(x, y int) (int,int) { return y, x }; swap(88,99)\", nil, []interface{}{99, 88}},\n\tTestCase{A, \"function_6\", \"i=0; func seti2() { i=2 }; seti2(); i\", 2, nil},\n\tTestCase{A, \"function_7\", \"i=0; func setiadd(x, y int) { i=x+y }; setiadd(7,8); i\", 15, nil},\n\n\t// bool is the param name, NOT its type!\n\tTestCase{F, \"function_named_return\", \"func add3(bool, x, y int) (z int) { z=bool+x+y; return }; add3(1,2,3)\", 6, nil},\n\n\tTestCase{A, \"function_variadic_1\", \"func list_args(args ...interface{}) []interface{} { return args }; list_args(1,2,3)\", []interface{}{1, 2, 3}, nil},\n\tTestCase{A, \"function_variadic_2\", \"si := make([]interface{}, 4); si[1]=1; si[2]=2; si[3]=3; list_args(si...)\", []interface{}{nil, 1, 2, 3}, nil},\n\tTestCase{A, \"fibonacci\", fibonacci_source_string + \"; fibonacci(13)\", 233, nil},\n\tTestCase{A, \"function_literal\", \"adder := func(a,b int) int { return a+b }; adder(-7,-9)\", -16, nil},\n\n\tTestCase{F, \"y_combinator_1\", \"type F func(F); var f F; &f\", makeYCombinator1(), nil},\n\tTestCase{F, \"y_combinator_2\", \"func Y(f F) { }; Y\", func(xr.Forward) {}, nil}, // avoid the infinite recursion, only check the types\n\tTestCase{F, \"y_combinator_3\", \"Y(Y)\", nil, none},                              // also check actual invokations\n\tTestCase{F, \"y_combinator_4\", \"f=Y; f(Y)\", nil, none},\n\tTestCase{F, \"y_combinator_5\", \"Y(f)\", nil, none},\n\tTestCase{F, \"y_combinator_6\", \"f(f)\", nil, none},\n\n\tTestCase{A, \"closure_1\", `\n\t\tfunc test_closure_1() int {\n\t\t\tvar x int\n\t\t\tfunc() {\n\t\t\t\tx = 1\n\t\t\t}()\n\t\t\treturn x\n\t\t}\n\t\ttest_closure_1()`, 1, nil},\n\n\tTestCase{F, \"closure_2\", `\n\t\tfunc test_closure_2() (x int) {\n\t\t\tfunc() {\n\t\t\t\tx = 2\n\t\t\t}()\n\t\t}\n\t\ttest_closure_2()`, 2, nil},\n\n\tTestCase{A, \"setvar_deref_1\", `vstr := \"foo\"; pvstr := &vstr; *pvstr = \"bar\"; vstr`, \"bar\", nil},\n\tTestCase{A, \"setvar_deref_2\", `vint := 5; pvint := &vint; *pvint = 6; vint`, 6, nil},\n\tTestCase{A, \"setplace_deref_1\", `func vstr_addr() *string { return &vstr }; *vstr_addr() = \"qwerty\"; vstr`, \"qwerty\", nil},\n\tTestCase{A, \"setplace_deref_2\", `*vstr_addr() += \"uiop\"; vstr`, \"qwertyuiop\", nil},\n\tTestCase{A, \"setplace_deref_3\", `func vint_addr() *int { return &vint }; *vint_addr() = 7; vint`, 7, nil},\n\tTestCase{A, \"setplace_deref_4\", `*vint_addr() %= 4; vint`, 3, nil},\n\n\tTestCase{A, \"setmap_1\", `m[1]=\"x\"; m[2]=\"y\"; m`, map[int]string{1: \"x\", 2: \"y\"}, nil},\n\tTestCase{A, \"setmap_2\", `m[2]+=\"z\"; m`, map[int]string{1: \"x\", 2: \"yz\"}, nil},\n\tTestCase{A, \"setmap_3\", `mi := make(map[rune]byte); mi['@']+=2; mi`, map[rune]byte{'@': 2}, nil},\n\tTestCase{A, \"setmap_4\", `mi['a'] |= 7; mi`, map[rune]byte{'@': 2, 'a': 7}, nil},\n\tTestCase{A, \"getmap_1\", `m[1]`, nil, []interface{}{\"x\", true}},\n\tTestCase{A, \"getmap_2\", `m1 := m[1]; m1`, \"x\", nil},\n\tTestCase{A, \"getmap_3\", `mi['b']`, nil, []interface{}{byte(0), false}},\n\tTestCase{A, \"getmap_4\", `v2 = mi['@']; v2`, byte(2), nil},\n\n\tTestCase{A, \"divmap_1\", \"mi['@'] = 99; mi['@'] /= 3; v2 = mi['@']; v2\", byte(33), nil},\n\tTestCase{A, \"divmap_2\", \"mi['@'] /= 4; v2 = mi['@']; v2\", byte(8), nil},\n\n\tTestCase{A, \"swap_assignment\", `i=1;j=2;  i,j=j,i;  list_args(i, j)`, []interface{}{2, 1}, nil},\n\tTestCase{A, \"evil_assignment_1\", `i=0; si[0]=7; si[1]=8\n\t\ti, si[i] = 1, 2\n\t\tlist_args(i,si[0],si[1])`, []interface{}{1, 2, 8}, nil},\n\tTestCase{A, \"evil_assignment_2\", `i=0; m=make(map[int]string); mcopy:=m;\n\t\ti, m, m[i] = 1, nil, \"foo\"\n\t\tlist_args(i,m,mcopy)`,\n\t\t[]interface{}{1, nil_map_int_string, map[int]string{0: \"foo\"}}, nil},\n\tTestCase{F, \"multi_assignment_1\", \"v7, v8 = func () (complex64, complex128) { return 1.0, 2.0 }(); v7\", complex64(1.0), nil},\n\tTestCase{F, \"multi_assignment_2\", \"v8 \", complex128(2.0), nil},\n\t// gophernotes issue 175\n\tTestCase{F, \"multi_assignment_3\", `\n\t\tarr := [2]struct{X int}{{3},{4}}\n\t\tarr[0], arr[1] = arr[1], arr[0]\n\t\tarr`, [2]struct{ X int }{{4}, {3}}, nil},\n\n\tTestCase{A, \"field_set_1\", `pair.A = 'k'; pair.B = \"m\"; pair`, Pair{'k', \"m\"}, nil},\n\tTestCase{A, \"field_set_2\", `pair.A, pair.B = 'x', \"y\"; pair`, Pair{'x', \"y\"}, nil},\n\tTestCase{F, \"field_set_3\", `triple.Pair.A, triple.C = 'a', 1.0; triple.Pair`, Pair{'a', \"\"}, nil},\n\tTestCase{F, \"field_set_embedded_1\", `triple.A, triple.B = 'b', \"xy\"; triple.Pair`, Pair{'b', \"xy\"}, nil},\n\tTestCase{F, \"field_addr_1\", \"ppair := &triple.Pair; ppair.A\", 'b', nil},\n\tTestCase{F, \"field_addr_2\", \"ppair.A++; triple.Pair.A\", 'c', nil},\n\n\tTestCase{F, \"infer_type_compositelit_1\", `[]Pair{{'a', \"b\"}, {'c', \"d\"}}`, []Pair{{'a', \"b\"}, {'c', \"d\"}}, nil},\n\tTestCase{F, \"infer_type_compositelit_2\", `[]*Pair{{'a', \"b\"}, {'c', \"d\"}}`, []*Pair{{'a', \"b\"}, {'c', \"d\"}}, nil},\n\tTestCase{F, \"infer_type_compositelit_3\", `[...]Pair{{'e', \"f\"}, {'g', \"h\"}}`, [...]Pair{{'e', \"f\"}, {'g', \"h\"}}, nil},\n\tTestCase{F, \"infer_type_compositelit_4\", `map[int]Pair{1:{'i', \"j\"}, 2:{}}`, map[int]Pair{1: {'i', \"j\"}, 2: {}}, nil},\n\tTestCase{F, \"infer_type_compositelit_5\", `map[int]map[int]int{1:{2:3}}`, map[int]map[int]int{1: {2: 3}}, nil},\n\tTestCase{F, \"infer_type_compositelit_6\", `map[int]*map[int]int{1:{2:3}}`, map[int]*map[int]int{1: {2: 3}}, nil},\n\n\tTestCase{A, \"import\", `import ( \"errors\"; \"fmt\"; \"io\"; \"math/big\"; \"math/rand\"; \"net/http\"; \"reflect\"; \"time\" )`, nil, none},\n\tTestCase{A, \"import_name\", `import _big \"math/big\"; _big.MaxBase`, big.MaxBase, nil},\n\tTestCase{A, \"import_constant\", `const micro = time.Microsecond; micro`, time.Microsecond, nil},\n\tTestCase{A, \"dot_import_1\", `import . \"errors\"`, nil, none},\n\tTestCase{A, \"dot_import_2\", `reflect.ValueOf(New) == reflect.ValueOf(errors.New)`, true, nil}, // a small but very strict check... good\n\n\tTestCase{A, \"goroutine_1\", `go seti(9); time.Sleep(time.Second/50); i`, 9, nil},\n\n\tTestCase{F, \"big.Int\", `(func() *big.Int { return 1<<1000 })()`, bigInt, nil},\n\tTestCase{F, \"big.Rat\", `(func() *big.Rat { var x *big.Rat = 1.000000001; x.Mul(x,x); x.Mul(x,x); return x })()`, bigRat, nil},\n\tTestCase{F, \"big.Float\", `(func() *big.Float { var x *big.Float = 1e1234; x.Mul(x,x); x.Mul(x,x); return x })()`, bigFloat, nil},\n\n\tTestCase{A, \"builtin_append_1\", \"append(vbs,0,1,2)\", []byte{0, 1, 2}, nil},\n\tTestCase{A, \"builtin_append_2\", \"append(vns,3,4)\", []byte{3, 4}, nil},\n\tTestCase{A, \"builtin_cap\", \"cap(va)\", 2, nil},\n\tTestCase{A, \"builtin_len_1\", \"len(vs)\", len(\"8y57riuh@#$\"), nil},\n\tTestCase{A, \"builtin_len_2\", \"{ a := [...]int{1,2,3}; len(a) }\", nil, none},\n\tTestCase{A, \"builtin_new\", \"new(int)\", new(int), nil},\n\tTestCase{A, \"builtin_make_1\", \"make(map[int]int)\", make(map[int]int), nil},\n\tTestCase{A, \"builtin_make_2\", \"make(map[int]int, 10)\", make(map[int]int), nil}, // capacity is ignored\n\tTestCase{A, \"builtin_make_4\", \"make([]*error, 2)\", make([]*error, 2), nil},\n\tTestCase{A, \"builtin_make_5\", \"make([]rune, 3, 4)\", make([]rune, 3, 4), nil},\n\tTestCase{A, \"builtin_make_6\", \"make(chan byte)\", make(chan byte), nil},\n\tTestCase{A, \"builtin_make_7\", \"make(chan byte, 2)\", make(chan byte, 2), nil},\n\tTestCase{A, \"builtin_make_8\", \"vbs = make([]byte, 5); vbs\", make([]byte, 5), nil},\n\tTestCase{A, \"builtin_copy_1\", \"copy(vbs, vs)\", 5, nil},\n\tTestCase{A, \"builtin_copy_2\", \"vbs\", []byte(\"8y57r\"), nil},\n\tTestCase{A, \"builtin_copy_3\", \"ints1 := []int{1,2,3}; ints2 := []int{0,0,0}; copy(ints2,ints1); ints2\", []int{1, 2, 3}, nil},\n\tTestCase{A, \"builtin_delete_1\", \"delete(mi,64); mi\", map[rune]byte{'a': 7}, nil},\n\tTestCase{A, \"builtin_real_1\", \"real(0.5+1.75i)\", real(0.5 + 1.75i), nil},\n\tTestCase{A, \"builtin_real_2\", \"const cplx complex64 = 1.5+0.25i; real(cplx)\", real(complex64(1.5 + 0.25i)), nil},\n\tTestCase{A, \"builtin_imag_1\", \"imag(0.5+1.75i)\", imag(0.5 + 1.75i), nil},\n\tTestCase{A, \"builtin_imag_2\", \"imag(cplx)\", imag(complex64(1.5 + 0.25i)), nil},\n\tTestCase{A, \"builtin_complex_1\", \"complex(0,1)\", complex(0, 1), nil},\n\tTestCase{A, \"builtin_complex_2\", \"v6 = 0.1; complex(v6,-v6)\", complex(float32(0.1), -float32(0.1)), nil},\n\n\tTestCase{F | U, \"untyped_builtin_real_1\", \"real(0.5+1.75i)\",\n\t\tuntyped.MakeLit(untyped.Float, constant.MakeFloat64(0.5), nil), // 0.5 is exactly representable by float64\n\t\tnil},\n\tTestCase{F | U, \"untyped_builtin_imag_1\", \"imag(1.5+0.25i)\",\n\t\tuntyped.MakeLit(untyped.Float, constant.MakeFloat64(0.25), nil), // 0.25 is exactly representable by float64\n\t\tnil},\n\tTestCase{F | U, \"untyped_builtin_complex_1\", \"complex(1, 2)\",\n\t\tuntyped.MakeLit(\n\t\t\tuntyped.Complex,\n\t\t\tconstant.BinaryOp(\n\t\t\t\tconstant.MakeInt64(1),\n\t\t\t\ttoken.ADD,\n\t\t\t\tconstant.MakeFromLiteral(\"2i\", token.IMAG, 0)),\n\t\t\tnil),\n\t\tnil,\n\t},\n\n\tTestCase{A, \"time_duration_0\", `var td time.Duration = 1; td`, time.Duration(1), nil},\n\tTestCase{A, \"time_duration_1\", `- td`, time.Duration(-1), nil},\n\tTestCase{A, \"time_duration_2\", `td + 1`, time.Duration(2), nil},\n\tTestCase{A, \"time_duration_3\", `4 - td`, time.Duration(3), nil},\n\tTestCase{A, \"time_duration_4\", `td * 4`, time.Duration(4), nil},\n\tTestCase{A, \"time_duration_5\", `5 / td`, time.Duration(5), nil},\n\tTestCase{A, \"time_duration_6\", `&td`, func() *time.Duration { td := time.Duration(1); return &td }(), nil},\n\tTestCase{A, \"time_duration_method\", ` td = time.Second; td.String()`, \"1s\", nil},\n\tTestCase{A, \"time_duration_closure\", ` tds := td.String; tds()`, \"1s\", nil},\n\tTestCase{A, \"time_utc\", ` utc := time.UTC; utc.String()`, \"UTC\", nil},\n\tTestCase{A, \"time_utc_addr\", ` utcaddr := &time.UTC; *utcaddr == utc`, true, nil},\n\tTestCase{A, \"time_utc_set_1\", ` time.UTC = nil; time.UTC == nil`, true, nil},\n\tTestCase{A, \"time_utc_set_2\", ` time.UTC = utc; time.UTC.String()`, \"UTC\", nil},\n\n\tTestCase{A, \"index_is_named_type\", `\"abc\"[time.Nanosecond]`, uint8('b'), nil},\n\tTestCase{A, \"panic_at_runtime\", `\"abc\"[micro]`, panics, nil},\n\tTestCase{F, \"panic_oob_at_compile\", `(func() uint8 { return \"abc\"[micro] })`, panics, nil}, // string index out of range\n\tTestCase{F, \"panic_non_const_initialization\", `const _ = rand.Int()`, panics, nil},         // const initializer is not a constant\n\n\tTestCase{A, \"literal_array\", \"[3]int{1,2:3}\", [3]int{1, 0, 3}, nil},\n\tTestCase{A, \"literal_array_address\", \"&[...]int{3:4,5:6}\", &[...]int{3: 4, 5: 6}, nil},\n\tTestCase{A, \"literal_map\", `map[int]string{1: \"foo\", 2: \"bar\"}`, map[int]string{1: \"foo\", 2: \"bar\"}, nil},\n\tTestCase{A, \"literal_map_address\", `&map[int]byte{6:7, 8:9}`, &map[int]byte{6: 7, 8: 9}, nil},\n\tTestCase{A, \"literal_slice\", \"[]rune{'a','b','c'}\", []rune{'a', 'b', 'c'}, nil},\n\tTestCase{A, \"literal_slice_address\", \"&[]rune{'x','y'}\", &[]rune{'x', 'y'}, nil},\n\tTestCase{A, \"literal_struct\", `Pair{A: 0x73, B: \"\\x94\"}`, Pair{A: 0x73, B: \"\\x94\"}, nil},\n\tTestCase{A, \"literal_struct_address\", `&Pair{1,\"2\"}`, &Pair{A: 1, B: \"2\"}, nil},\n\n\t// gomacro issue #103\n\tTestCase{A, \"named_const_type_1\", `type Int int\n\t\t\t\t const namedOne Int = Int(1); namedOne`, int(1), nil},\n\n\tTestCase{A, \"named_func_type_1\", `import \"context\"\n\t\t\t\t _, cancel := context.WithCancel(context.Background())\n\t\t\t\t cancel()`, nil, none},\n\n\tTestCase{A, \"method_decl_1\", `func (p *Pair) SetA(a rune) { p.A = a }; nil`, nil, nil},\n\tTestCase{A, \"method_decl_2\", `func (p Pair) SetAV(a rune) { p.A = a }; nil`, nil, nil},\n\tTestCase{A, \"method_decl_3\", `func (p Pair) String() string { return fmt.Sprintf(\"%c %s\", p.A, p.B) }; nil`, nil, nil},\n\n\tTestCase{A, \"method_on_ptr\", `pair.SetA(33); pair.A`, rune(33), nil},\n\tTestCase{A, \"method_on_val_1\", `pair.SetAV(11); pair.A`, rune(33), nil}, // method on value gets a copy of the receiver - changes to not propagate\n\tTestCase{A, \"method_on_val_2\", `pair.String()`, \"! y\", nil},\n\t// gophernotes issue 174\n\tTestCase{F, \"method_decl_and_use\", `type person struct{}; func (p person) speak() {}; person.speak`, func(struct{}) {}, nil},\n\tTestCase{F, \"method_embedded=val_recv=ptr\", `triple.SetA('1'); triple.A`, '1', nil},\n\tTestCase{F, \"method_embedded=val_recv=val\", `triple.SetAV('2'); triple.A`, '1', nil},\n\tTestCase{F, \"method_embedded=ptr_recv=val\", `tp.SetAV('3'); tp.A`, '1', nil}, // set by triple.SetA('1') above\n\tTestCase{F, \"method_embedded=ptr_recv=ptr\", `tp.SetA('4'); tp.A`, '4', nil},\n\n\tTestCase{F, \"concrete_method_to_func_1\", `cf0 := time.Duration.Seconds; cf0(time.Hour)`, 3600.0, nil},\n\tTestCase{F, \"concrete_method_to_closure_1\", `cl1 := time.Hour.Seconds; cl1()`, 3600.0, nil},\n\tTestCase{F, \"concrete_method_to_func_2\", `import \"sync\"; sync.WaitGroup.Done`, (*sync.WaitGroup).Done, nil},\n\tTestCase{F, \"concrete_method_to_closure_2\", `var wg sync.WaitGroup; wg.Done`, func() {}, nil},\n\n\t// tricky because Comp.compileObjGetMethod() asks for the package path of 'error', which has nil package\n\tTestCase{A, \"interface_0\", `errors.New(\"abc\").Error()`, \"abc\", nil},\n\n\tTestCase{A, \"nil_to_interface\", `interface{}(nil)`, nil, nil},\n\tTestCase{A, \"nil_to_error\", `error(nil)`, nil, nil},\n\tTestCase{A, \"nil_to_pointer\", `(*int)(nil)`, (*int)(nil), nil},\n\n\tTestCase{A, \"interface_1\", \"var st fmt.Stringer = time.Second; st\", time.Second, nil},\n\tTestCase{A, \"interface_method_to_closure_1\", \"bind := st.String; bind()\", \"1s\", nil},\n\tTestCase{F, \"interface_2\", \"st = pair; nil\", nil, nil},\n\tTestCase{F, \"interface_method_to_closure_2\", \"bind = st.String; bind()\", \"! y\", nil},\n\tTestCase{F, \"interface_method_to_closure_3\", \"st = nil; bind = st.String\", panics, nil},\n\t// interpreted interface\n\tTestCase{F, \"interface_3\", \"type IStringer interface { String() string }; nil\", nil, nil},\n\tTestCase{F, \"interface_method_to_closure_4\", \"var ist IStringer; nil\", nil, nil},\n\tTestCase{F, \"interface_method_to_closure_5\", \"ist.String\", panics, nil},\n\tTestCase{F, \"interface_4\", `\n\t\ttype IncAdd interface { Inc(int); Add(int) int }\n\t\tfunc (i Int)  Add(j int) int { return int(i) + j }\n\t\tfunc (i *Int) Inc(j int) { *i += Int(j) }\n\t\tvar ia IncAdd\n\t\tvar ii Int = 7`, nil, none},\n\tTestCase{F, \"interface_5\", `ia = &ii`, nil, none},\n\n\tTestCase{F, \"interface_method_to_func_1\", \"f1 := fmt.Stringer.String; f1(time.Hour)\", \"1h0m0s\", nil},\n\tTestCase{F, \"interface_method_to_func_2\", \"f2 := io.ReadWriter.Read; f2 != nil\", true, nil},\n\tTestCase{F, \"interface_method_to_func_3\", \"type Fooer interface { Foo() }; Fooer.Foo != nil\", true, nil},\n\tTestCase{F, \"interface_method_to_func_4\", \"type RW interface { io.Reader; io.Writer }; RW.Read != nil && RW.Write != nil\", true, nil},\n\n\tTestCase{F, \"interface_interpreted_1\", interface_interpreted_1_source_string, true, nil},\n\tTestCase{F, \"interface_interpreted_2\", interface_interpreted_2_source_string, true, nil},\n\t// gophernotes issue 176\n\tTestCase{F, \"interface_interpreted_3\", `\n\t\ttype xerror struct { }\n\t\tfunc (x xerror) Error() string {\n\t\t  return \"some error\"\n\t\t}\n\t\tvar xe error = xerror{}\n\t\txe.Error()`, \"some error\", nil},\n\t// gomacro issue 127\n\t// actually does not trigger the bug because for some reason\n\t// method is found also on xr.Type having .Kind() == xr.Ptr\n\tTestCase{F, \"interface_interpreted_4\", `\n\t\timport \"fmt\"\n\t\ttype V1Data struct { I int }\n\t\tfunc (t *V1Data) String() string { return \"<>\" }\n\t\tfmt.Stringer(&V1Data{})\n\t\tnil`, nil, nil},\n\n\tTestCase{A, \"multiple_values_1\", \"func twins(x float32) (float32,float32) { return x, x+1 }; twins(17.0)\", nil, []interface{}{float32(17.0), float32(18.0)}},\n\tTestCase{A, \"multiple_values_2\", \"func twins2(x float32) (float32,float32) { return twins(x) }; twins2(19.0)\", nil, []interface{}{float32(19.0), float32(20.0)}},\n\tTestCase{A, \"multiple_values_3\", \"f1, f2 := twins(23.0); list_args(f1, f2)\", []interface{}{float32(23.0), float32(24.0)}, nil},\n\tTestCase{A, \"multiple_values_4\", \"fm := make(map[int]float32); fm[1], fm[2] = twins(3.0); fm\", map[int]float32{1: 3.0, 2: 4.0}, nil},\n\tTestCase{A, \"multiple_values_5\", \"swap(swap(3,4))\", nil, []interface{}{3, 4}},\n\tTestCase{F, \"multiple_values_6\", `fmt.Sprintf(\"foo\")`, \"foo\", nil},\n\tTestCase{A, \"multiple_values_7\", `func args() (string, interface{}, interface{}) { return \"%v %v\", 5, 6 }; nil`, nil, nil},\n\tTestCase{A, \"multiple_values_8\", `fmt.Sprintf(args())`, \"5 6\", nil},\n\n\tTestCase{A, \"pred_bool_1\", \"false==false && true==true && true!=false\", true, nil},\n\tTestCase{A, \"pred_bool_2\", \"false!=false || true!=true || true==false\", false, nil},\n\tTestCase{A, \"pred_int\", \"1==1 && 1<=1 && 1>=1 && 1!=2 && 1<2 && 2>1 || 0==1\", true, nil},\n\tTestCase{A, \"pred_string_1\", `\"\"==\"\" && \"\">=\"\" && \"\"<=\"\" && \"\"<\"a\" && \"\"<=\"b\" && \"a\">\"\" && \"b\">=\"\"`, true, nil},\n\tTestCase{A, \"pred_string_2\", `ve==\"\" && ve>=\"\" && ve<=\"\" && ve<\"a\" && ve<=\"b\" && \"a\">ve && \"b\">=ve`, true, nil},\n\tTestCase{A, \"pred_string_3\", `\"x\"==\"x\" && \"x\"<=\"x\" && \"x\">=\"x\" && \"x\"!=\"y\" && \"x\"<\"y\" && \"y\">\"x\"`, true, nil},\n\tTestCase{A, \"pred_string_4\", `\"x\"!=\"x\" || \"y\"!=\"y\" || \"x\">=\"y\" || \"y\"<=\"x\"`, false, nil},\n\n\t// gomacro issue 122\n\t// removing wrapper methods for embedded fields did remove them from xreflect/xtype.methodvalue[]\n\t// causing lexicographically greater methods to panic due to mismatched signature\n\tTestCase{F, \"wrapper_methods_1\", `\n\t\timport pkg \"test/issue122\"\n\t\tfunc callWrapper() bool { wrapper := pkg.Wrapper{&pkg.Base{}}; return wrapper.IsWrapper() }\n\t\tcallWrapper()\n\t`, true, nil},\n\n\t// gomacro issue 133\n\t// injecting recursive types with Interp.DeclType() caused the creation\n\t// of pointer to such type having option == OptIncomplete\n\t// which caused lots of panics\n\tTestCase{TestFlagAndInit{F, nil, decl_recursive_type_issue_133},\n\t\t\"inject_recursive_type_1\",\n\t\t`func Execute() []*Recursive { return nil }`,\n\t\tnil, none},\n\n\t// gomacro issue 142\n\t// method lookup always failed for pointers to named array types, named slice types,\n\t// and all other named non-struct types if generics v2 are disabled\n\t// TODO: add test for such issue.\n\t//       TestCase must disable generics, import a non-struct type having methods\n\t//       with pointer receiver, and invoke one of those methods\n\n\tTestCase{A, \"defer_1\", `\n\t\tvi = nil\n\t\tfunc test_defer_1() {\n\t\t\tdefer func() {\n\t\t\t\tvi = 1\n\t\t\t}()\n\t\t}\n\t\ttest_defer_1(); vi`, 1, nil},\n\t// classic does not fully support named return types\n\tTestCase{F, \"defer_2\", `\n\t\tfunc test_defer_2() (x int) {\n\t\t\tdefer func() {\n\t\t\t\tx = 2\n\t\t\t}()\n\t\t}\n\t\ttest_defer_2()`, 2, nil},\n\tTestCase{A, \"defer_3\", `\n\t\tv = 0\n\t\tfunc test_defer_3(x uint32) {\n\t\t\tif x != 0 {\n\t\t\t\tdefer func(y uint32) {\n\t\t\t\t\t v = y\n\t\t\t\t}(x)\n\t\t\t}\n\t\t}\n\t\ttest_defer_3(3); v`, uint32(3), nil},\n\tTestCase{A, \"defer_4\", \"v = 4; test_defer_3(0); v\", uint32(4), nil},\n\tTestCase{A, \"defer_5\", `\n\t\tv = 0\n\t\tfunc test_defer_5(x uint32) {\n\t\t\tif x != 0 {\n\t\t\t\tdefer func() {\n\t\t\t\t\t v = x\n\t\t\t\t}()\n\t\t\t}\n\t\t}\n\t\ttest_defer_5(5); v`, uint32(5), nil},\n\tTestCase{A, \"defer_6\", \"v = 6; test_defer_5(0); v\", uint32(6), nil},\n\tTestCase{A, \"recover_1\", `var vpanic interface{}\n\t\tfunc test_recover(rec bool, panick interface{}) {\n\t\t\tdefer func() {\n\t\t\t\tif rec {\n\t\t\t\t\tvpanic = recover()\n\t\t\t\t}\n\t\t\t}()\n\t\t\tpanic(panick)\n\t\t}\n\t\ttest_recover(true, -1)\n\t\tvpanic`, -1, nil},\n\tTestCase{A, \"recover_2\", `var vpanic2, vpanic3 interface{}\n\t\tfunc test_nested_recover(repanic bool, panick interface{}) {\n\t\t\tdefer func() {\n\t\t\t\tvpanic = recover()\n\t\t\t}()\n\t\t\tdefer func() {\n\t\t\t\tfunc() {\n\t\t\t\t\tvpanic3 = recover()\n\t\t\t\t}()\n\t\t\t\tvpanic2 = recover()\n\t\t\t\tif repanic {\n\t\t\t\t\tpanic(vpanic2)\n\t\t\t\t}\n\t\t\t}()\n\t\t\tpanic(panick)\n\t\t}\n\t\ttest_nested_recover(false, -2)\n\t\tlist_args(vpanic, vpanic2, vpanic3)\n\t\t`, []interface{}{nil, -2, nil}, nil},\n\tTestCase{A, \"recover_3\", `vpanic, vpanic2, vpanic3 = nil, nil, nil\n\t\ttest_nested_recover(true, -3)\n\t\tlist_args(vpanic, vpanic2, vpanic3)\n\t\t`, []interface{}{-3, -3, nil}, nil},\n\tTestCase{A, \"recover_4\", `vpanic = nil\n\t\tfunc test_defer_panic(panick interface{}) {\n\t\t\tdefer func() {\n\t\t\t\tvpanic = recover()\n\t\t\t}()\n\t\t\tdefer func() {\n\t\t\t\tpanic(panick)\n\t\t\t}()\n\t\t}\n\t\ttest_defer_panic(-4)\n\t\tvpanic\n\t\t`, -4, nil},\n\tTestCase{A, \"send_recv\", `cx <- \"x\"; <-cx`, nil, []interface{}{\"x\", true}},\n\tTestCase{A, \"sum\", sum_source_string + \"; sum(100)\", 5050, nil},\n\n\tTestCase{A, \"select_1\", \"vi = nil; cx <- 1; { var x interface{}; select { case x=<-cx: vi=x; default: } }; vi\", 1, nil},\n\tTestCase{A, \"select_2\", \"vi = nil; cx <- map[int]int{1:2}; select { case x:=<-cx: vi=x; default: }; vi\", map[int]int{1: 2}, nil},\n\tTestCase{A, \"select_3\", \"vi = nil; select { case cx<-1: vi=1; default: vi=0 }; vi\", 1, nil},\n\tTestCase{A, \"select_4\", \"vi = nil; select { case cx<-2: vi=2; default: vi=0 }; vi\", 2, nil},\n\tTestCase{A, \"select_5\", \"vi = nil; select { case cx<-3: vi=3; default: vi=0 }; vi\", 0, nil},\n\tTestCase{A, \"select_6\", \"vi = nil; select { case cx<-4: vi=4; case x:=<-cx: vi=x; default: vi=0 }; vi\", 1, nil},\n\tTestCase{A, \"for_select_1\", \"for { select { }; break }\", nil, none},\n\t// FIXME: break is confused by select { default: }\n\tTestCase{C, \"for_select_2\", \"for { select { default: }; break }\", nil, none},\n\t// non-empty 'select' needs a local bind, and 'for' must know it\n\tTestCase{A, \"for_select_3\", \"_ = func() { for { select { }; return } }\", nil, none},\n\tTestCase{A, \"for_select_4\", \"_ = func() { for { select { case <-cx: default: return } } }\", nil, none},\n\n\tTestCase{A, \"switch_1\", \"vi=nil; switch { case false: ; default: vi='1' }; vi\", '1', nil},\n\tTestCase{A, \"switch_2\", \"vi=nil; switch v:=20; v { case 20: vi='2'; vi='3' }; vi\", '3', nil},\n\tTestCase{A, \"switch_3\", `v3=0; vi=nil\n\t\tfunc inc_u16(addr *uint16, n uint16) uint16 { *addr += n; return *addr }\n\t\tswitch v3++; inc_u16(&v3, 2) { case 1: ; case 2: ; case 3: vi='3'; default: }; vi`, '3', nil},\n\tTestCase{A, \"switch_4\", \"v0=7; switch v:=7; v { default: vi=0; case 1: vi=1; case v0: vi=7; case 7: vi=-7 }; vi\", 7, nil},\n\tTestCase{A, \"switch_fallthrough\", `vi=nil; switch v:=0; v {\n\t\tdefault:       fallthrough\n\t\tcase 1: vi=10; fallthrough\n\t\tcase 2: vi=20; break\n\t\tcase 3: vi=30\n\t}; vi`, 20, nil},\n\tTestCase{A | S, \"switch_multithread\", `func doswitch(i, j int) { switch i { case 1: v0 = j; case 2: vi = j } }\n\t\tv0, vi = 0, nil\n\t\tgo doswitch(1, 10)\n\t\tdoswitch(2, 20)\n\t\ttime.Sleep(time.Second/10)\n\t\tlist_args(v0, vi)\n\t`, []interface{}{10, 20}, nil},\n\tTestCase{A, \"for_switch_1\", \"for { switch { }; break }\", nil, none},\n\tTestCase{A, \"for_switch_2\", \"for { switch { default: }; break }\", nil, none},\n\n\tTestCase{A, \"typeswitch_1\", `vi = nil; var x interface{} = \"abc\"; switch y := x.(type) { default: vi = 0; case string: vi = len(y) }; vi`, 3, nil},\n\tTestCase{A, \"typeswitch_2\", `vi = nil; switch x.(type) { default: vi = 0; case byte, bool: vi = 1; case interface{}: vi = 2 }; vi`, 2, nil},\n\tTestCase{A, \"typeswitch_3\", `vi = nil; switch x.(type) { default: vi = 0; case int:         vi = 3 }; vi`, 0, nil},\n\tTestCase{A, \"typeswitch_4\", `vi = nil; switch x.(type) { default: vi = 0; case string:      vi = 4 }; vi`, 4, nil},\n\tTestCase{A, \"typeswitch_5\", `vi,x = nil,nil; switch x.(type) { default: vi=0; case nil:     vi = 5 }; vi`, 5, nil},\n\tTestCase{A, \"typeswitch_6\", `var stringer fmt.Stringer = time.Minute\n\t\tswitch s := stringer.(type) {\n\t\t\tcase nil:           vi = 0\n\t\t\tdefault:            vi = 1\n\t\t\tcase time.Duration: vi = 6\n\t\t\tcase fmt.Stringer:  vi = 7\n\t\t}; vi`, 6, nil},\n\n\tTestCase{A, \"typeassert_1\", `var xi interface{} = \"abc\"; yi := xi.(string); yi`, \"abc\", nil},\n\tTestCase{A, \"typeassert_2\", `xi.(string)`, nil, []interface{}{\"abc\", true}},\n\tTestCase{A, \"typeassert_3\", `xi.(int)`, nil, []interface{}{0, false}},\n\tTestCase{A, \"typeassert_4\", `xi = nil; xi.(error)`, nil, []interface{}{error(nil), false}},\n\tTestCase{A, \"typeassert_5\", `xi = 7; xi.(int)+2`, 9, nil},\n\tTestCase{F, \"typeassert_6\", `type T struct { Val int }; func (t T) String() string { return \"T\" }`, nil, none},\n\tTestCase{F, \"typeassert_7\", `stringer = T{}; nil`, nil, nil},\n\tTestCase{F, \"typeassert_8\", `st1 := stringer.(T); st1`, struct{ Val int }{0}, nil},\n\tTestCase{F, \"typeassert_9\", `stringer.(T)`, nil, []interface{}{struct{ Val int }{0}, true}},\n\t// can interpreted type assertions distinguish between emulated named types with identical underlying type?\n\tTestCase{F, \"typeassert_10\", `type U struct { Val int }; func (u U) String() string { return \"U\" }; nil`, nil, nil},\n\tTestCase{F, \"typeassert_11\", `stringer.(U)`, nil, []interface{}{struct{ Val int }{0}, false}},\n\tTestCase{F, \"typeassert_12\", `xi = []int(nil); ys:= xi.([]int); ys`, ([]int)(nil), nil},\n\tTestCase{F, \"typeassert_13\", `xi.([]int)`, nil, []interface{}{([]int)(nil), true}},\n\n\tTestCase{A, \"quote_1\", `~quote{7}`, &ast.BasicLit{Kind: token.INT, Value: \"7\"}, nil},\n\tTestCase{A, \"quote_2\", `~quote{x}`, &ast.Ident{Name: \"x\"}, nil},\n\tTestCase{A, \"quote_3\", `var ab = ~quote{a;b}; ab`, &ast.BlockStmt{List: []ast.Stmt{\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"a\"}},\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"b\"}},\n\t}}, nil},\n\tTestCase{A, \"quote_4\", `~'{\"foo\"+\"bar\"}`, &ast.BinaryExpr{\n\t\tX:  &ast.BasicLit{Kind: token.STRING, Value: `\"foo\"`},\n\t\tOp: token.ADD,\n\t\tY:  &ast.BasicLit{Kind: token.STRING, Value: `\"bar\"`},\n\t}, nil},\n\tTestCase{A, \"quasiquote_1\", `~quasiquote{1 + ~unquote{2+3}}`, &ast.BinaryExpr{\n\t\tX:  &ast.BasicLit{Kind: token.INT, Value: \"1\"},\n\t\tOp: token.ADD,\n\t\tY:  &ast.BasicLit{Kind: token.INT, Value: \"5\"},\n\t}, nil},\n\tTestCase{A, \"quasiquote_2\", `~\"{2 * ~,{3<<1}}`, &ast.BinaryExpr{\n\t\tX:  &ast.BasicLit{Kind: token.INT, Value: \"2\"},\n\t\tOp: token.MUL,\n\t\tY:  &ast.BasicLit{Kind: token.INT, Value: \"6\"},\n\t}, nil},\n\tTestCase{A, \"quasiquote_3\", `~\"{func(int) {}}`, &ast.FuncLit{\n\t\tType: &ast.FuncType{\n\t\t\tParams: &ast.FieldList{\n\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t{\n\t\t\t\t\t\tNames: nil,\n\t\t\t\t\t\tType: &ast.Ident{\n\t\t\t\t\t\t\tName: \"int\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tBody: &ast.BlockStmt{},\n\t}, nil},\n\tTestCase{A, \"quasiquote_func\", `func qq_func(x interface{}) interface{} { y := ~\"~,x; return y }; qq_func(123)`,\n\t\t&ast.BasicLit{Kind: token.INT, Value: \"123\"}, nil},\n\tTestCase{A, \"quasiquote_case\", `~\"{case xy: nil}`,\n\t\t&ast.CaseClause{\n\t\t\tList: []ast.Expr{&ast.Ident{Name: \"xy\"}},\n\t\t\tBody: []ast.Stmt{&ast.ExprStmt{&ast.Ident{Name: \"nil\"}}},\n\t\t}, nil,\n\t},\n\n\tTestCase{A, \"unquote_splice_1\", `~quasiquote{~unquote_splice ab ; c}`, &ast.BlockStmt{List: []ast.Stmt{\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"a\"}},\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"b\"}},\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"c\"}},\n\t}}, nil},\n\tTestCase{A, \"unquote_splice_2\", `~\"{zero ; ~,@ab ; one}`, &ast.BlockStmt{List: []ast.Stmt{\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"zero\"}},\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"a\"}},\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"b\"}},\n\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"one\"}},\n\t}}, nil},\n\tTestCase{A, \"unquote_splice_3\", `~\"~\"{zero ; ~,~,@ab ; one}`,\n\t\tmakeQUASIQUOTE(&ast.BlockStmt{List: []ast.Stmt{\n\t\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"zero\"}},\n\t\t\t&ast.ExprStmt{X: makeUNQUOTE(&ast.Ident{Name: \"a\"})},\n\t\t\t&ast.ExprStmt{X: makeUNQUOTE(&ast.Ident{Name: \"b\"})},\n\t\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"one\"}},\n\t\t}}), nil},\n\tTestCase{A, \"unquote_splice_4\", `~\"~\"{zero ; ~,@~,@ab ; one}`,\n\t\tmakeQUASIQUOTE(&ast.BlockStmt{List: []ast.Stmt{\n\t\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"zero\"}},\n\t\t\t&ast.ExprStmt{X: makeUNQUOTE_SPLICE(&ast.Ident{Name: \"a\"})},\n\t\t\t&ast.ExprStmt{X: makeUNQUOTE_SPLICE(&ast.Ident{Name: \"b\"})},\n\t\t\t&ast.ExprStmt{X: &ast.Ident{Name: \"one\"}},\n\t\t}}), nil},\n\tTestCase{A, \"macro\", \"~macro second_arg(a,b,c interface{}) interface{} { return b }; v = 98; v\", uint32(98), nil},\n\tTestCase{A, \"macro_call\", \"second_arg;1;v;3\", uint32(98), nil},\n\tTestCase{A, \"macro_nested\", \"second_arg;1;{second_arg;2;3;4};5\", 3, nil},\n\tTestCase{C, \"values\", \"Values(3,4,5)\", nil, []interface{}{3, 4, 5}},\n\tTestCase{A, \"eval\", \"Eval(~quote{1+2})\", 3, nil},\n\tTestCase{C, \"eval_quote\", \"Eval(~quote{Values(3,4,5)})\", nil, []interface{}{3, 4, 5}},\n\n\tTestCase{A | G1 | G2, \"parse_decl_generic_type_1\", decl_generic_type_pair_str(),\n\t\t&ast.GenDecl{\n\t\t\tTok: token.TYPE,\n\t\t\tSpecs: []ast.Spec{\n\t\t\t\t&ast.TypeSpec{\n\t\t\t\t\tName: &ast.Ident{Name: \"Pair\"},\n\t\t\t\t\tType: &ast.CompositeLit{\n\t\t\t\t\t\tType: &ast.StructType{\n\t\t\t\t\t\t\tFields: &ast.FieldList{\n\t\t\t\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tNames: []*ast.Ident{{Name: \"First\"}},\n\t\t\t\t\t\t\t\t\t\tType:  &ast.Ident{Name: \"T1\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tNames: []*ast.Ident{{Name: \"Second\"}},\n\t\t\t\t\t\t\t\t\t\tType:  &ast.Ident{Name: \"T2\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t&ast.Ident{Name: \"T1\"},\n\t\t\t\t\t\t\t&ast.Ident{Name: \"T2\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\n\tTestCase{A | G1 | G2, \"parse_decl_generic_func_1\", decl_generic_func_sum_str(),\n\t\t&ast.FuncDecl{\n\t\t\tRecv: &ast.FieldList{\n\t\t\t\tList: []*ast.Field{\n\t\t\t\t\tnil,\n\t\t\t\t\t{\n\t\t\t\t\t\tType: &ast.CompositeLit{\n\t\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t\t&ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: &ast.Ident{Name: \"Sum\"},\n\t\t\tType: &ast.FuncType{\n\t\t\t\tParams: &ast.FieldList{\n\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType: &ast.ArrayType{\n\t\t\t\t\t\t\t\tElt: &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tResults: &ast.FieldList{\n\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType: &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tBody: &ast.BlockStmt{},\n\t\t}, nil},\n\n\tTestCase{A | G1 | G2, \"parse_decl_generic_method\", decl_generic_method_rest_str(),\n\t\t&ast.FuncDecl{\n\t\t\tRecv: &ast.FieldList{\n\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t{\n\t\t\t\t\t\tNames: []*ast.Ident{{Name: \"x\"}},\n\t\t\t\t\t\tType:  &ast.Ident{Name: \"Pair\"},\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tType: &ast.CompositeLit{\n\t\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t\t&ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tName: &ast.Ident{Name: \"Rest\"},\n\t\t\tType: &ast.FuncType{\n\t\t\t\tParams: &ast.FieldList{\n\t\t\t\t\tList: []*ast.Field{},\n\t\t\t\t},\n\t\t\t\tResults: &ast.FieldList{\n\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tType: &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tBody: &ast.BlockStmt{},\n\t\t}, nil},\n\n\tTestCase{A | G1 | G2, \"parse_qual_generic_name_1\", \"~quote{Pair#[]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX:     &ast.Ident{Name: \"Pair\"},\n\t\t\tIndex: &ast.CompositeLit{},\n\t\t}, nil},\n\n\tTestCase{A | G1 | G2, \"parse_qual_generic_name_2\", \"~quote{Pair#[x + 1]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX: &ast.Ident{Name: \"Pair\"},\n\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t&ast.BinaryExpr{\n\t\t\t\t\t\tX:  &ast.Ident{Name: \"x\"},\n\t\t\t\t\t\tOp: token.ADD,\n\t\t\t\t\t\tY: &ast.BasicLit{\n\t\t\t\t\t\t\tKind:  token.INT,\n\t\t\t\t\t\t\tValue: \"1\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\n\tTestCase{A | G1 | G2, \"parse_qual_generic_name_3\", \"~quote{Pair#[T1, T2]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX: &ast.Ident{Name: \"Pair\"},\n\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t&ast.Ident{Name: \"T1\"},\n\t\t\t\t\t&ast.Ident{Name: \"T2\"},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\n\tTestCase{F | G1 | G2, \"generic_func_1\",\n\t\tgeneric_func(\"Identity\", \"T\") + `(arg T) T {\n\t\t\treturn arg\n\t\t}`, nil, none,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_2\",\n\t\t`Identity#[float64](1.5)`,\n\t\tfloat64(1.5), nil,\n\t},\n\tTestCase{F | G1, \"generic_func_3\",\n\t\t`Identity#[func()]`,\n\t\tfunc(func()) func() { return nil }, nil,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_4\",\n\t\tgeneric_func(\"Sum\", \"T\") + `(args ...T) T {\n\t\t\tvar sum T\n\t\t\tfor _, elem := range args {\n\t\t\t\tsum += elem\n\t\t\t}\n\t\t\treturn sum\n\t\t}`, nil, none,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_5\", `Sum#[int]`, func(...int) int { return 0 }, nil},\n\tTestCase{F | G1 | G2, \"generic_func_6\", `Sum#[complex64]`, func(...complex64) complex64 { return 0 }, nil},\n\tTestCase{F | G1 | G2, \"generic_func_7\", `Sum#[int](1, 2, 3)`, 6, nil},\n\tTestCase{F | G1 | G2, \"generic_func_8\", `Sum#[complex64](1.1+2.2i, 3.3)`, complex64(1.1+2.2i) + complex64(3.3), nil},\n\tTestCase{F | G1 | G2, \"generic_func_9\", `Sum#[string](\"abc\",\"def\",\"xy\",\"z\")`, \"abcdefxyz\", nil},\n\n\tTestCase{F | G1 | G2, \"generic_func_10\",\n\t\tgeneric_func(\"MapSlice\", \"T,U\") + ` (slice []T, trans func(T) U) []U {\n\t\t\tret := make([]U, len(slice))\n\t\t\tfor i := range slice {\n\t\t\t\tret[i] = trans(slice[i])\n\t\t\t}\n\t\t\treturn ret\n\t\t}\n\t\tfunc stringLen(s string) int { return len(s) }`, nil, none,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_11\", `MapSlice#[string,int]([]string{\"abc\",\"xy\",\"z\"}, stringLen)`,\n\t\t[]int{3, 2, 1}, nil,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_12\",\n\t\tgeneric_func(\"SwapArgs\", \"A,B,C\") + ` (f func(A, B) C) func(B,A) C {\n\t\t\treturn func (b B, a A) C {\n\t\t\t\treturn f(a, b)\n\t\t\t}\n\t\t}`, nil, none,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_13\", `\n\t\tSwapArgs#[float64,float64,float64](func (a float64, b float64) float64 { return a/b })(2.0, 3.0)\n\t    `, 1.5, nil,\n\t},\n\tTestCase{F | G1 | G2, \"generic_func_curry_1\",\n\t\tgeneric_func(\"Curry\", \"A,B,C\") + ` (f func(A, B) C) func(A) func(B) C {\n\t\t\treturn func (a A) func (B) C {\n\t\t\t\treturn func (b B) C {\n\t\t\t\t\treturn f(a, b)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t` + generic_func(\"add2\", \"T\") + ` (a,b T) T { return a+b }\n\t\tCurry#[int,int,int](add2#[int])(2)(3)\n\t`,\n\t\t5, nil},\n\n\tTestCase{F | G2, \"generic_func_curry_2\",\n\t\tgeneric_func(\"add2m\", \"T\") + ` (a,b T) T { return T().Add(a,b) }\n\t\tCurry#[uint,uint,uint](add2m#[uint])(5)(6)\n\t`,\n\t\tuint(11), nil},\n\n\tTestCase{F | G1 | G2, \"generic_func_lift_1\",\n\t\tgeneric_func(\"Lift1\", \"A,B\") + ` (trans func(A) B) func([]A) []B {\n\t\t\treturn func(slice []A) []B {\n\t\t\t\tret := make([]B, len(slice))\n\t\t\t\tfor i := range slice {\n\t\t\t\t\tret[i] = trans(slice[i])\n\t\t\t\t}\n\t\t\t\treturn ret\n\t\t\t}\n\t\t}\n\t\tLift1#[string,int](stringLen)([]string{\"a\",\"bc\",\"def\"})\n\t`,\n\t\t[]int{1, 2, 3}, nil},\n\n\t// quite a convoluted test\n\tTestCase{F | G1 | G2, \"generic_func_lift_2\",\n\t\tgeneric_func(\"Lift2\", \"A,B\") + ` (trans func(A) B) func([]A) []B {\n\t\t\treturn Curry#[func(A)B, []A, []B](\n\t\t\t\tSwapArgs#[[]A, func(A)B, []B](MapSlice#[A,B]),\n\t\t\t)(trans)\n\t\t}\n\t\tLift2#[string,int](stringLen)([]string{\"xy\",\"z\",\"\"})\n\t`,\n\t\t[]int{2, 1, 0}, nil},\n\n\tTestCase{F | G2, \"generic_func_infer_1\", `Identity(true)`, true, nil},\n\tTestCase{F | G2, \"generic_func_infer_2\", `Identity(1)`, 1, nil},\n\tTestCase{F | G2, \"generic_func_infer_3\", `Identity('x')`, 'x', nil},\n\tTestCase{F | G2, \"generic_func_infer_4\", `Identity(2.0)`, 2.0, nil},\n\tTestCase{F | G2, \"generic_func_infer_5\", `Identity(3.0i)`, 3.0i, nil},\n\tTestCase{F | G2, \"generic_func_infer_6\", `Identity(\"abc\")`, \"abc\", nil},\n\tTestCase{F | G2, \"generic_func_infer_7\", `Curry(add2m#[uint32])(7)(10)`, uint32(17), nil},\n\tTestCase{F | G2, \"generic_func_infer_8\", `Lift1(stringLen)([]string{\"foo\",\"ba\",\"z\"})`, []int{3, 2, 1}, nil},\n\tTestCase{F | G2, \"generic_func_infer_9\",\n\t\tgeneric_func(\"Lift3\", \"A,B\") + ` (trans func(A) B) func([]A) []B {\n\t\t\treturn Curry(\n\t\t\t\tSwapArgs(MapSlice#[A,B]),\n\t\t\t)(trans)\n\t\t}\n\t\tLift3(stringLen)([]string{\"qwerty\",\"asdf\"})\n\t`,\n\t\t[]int{6, 4}, nil},\n\n\tTestCase{F | G1 | G2, \"recursive_generic_func_1\",\n\t\tgeneric_func(\"count\", \"T\") + ` (a, b T) T { if a <= 0 { return b }\n\t\treturn count#[T](a-1,b+1) }`,\n\t\tnil, none,\n\t},\n\tTestCase{F | G1 | G2, \"recursive_generic_func_2\", `count#[uint16]`, func(uint16, uint16) uint16 { return 0 }, nil},\n\tTestCase{F | G1 | G2, \"recursive_generic_func_3\", `count#[uint32](2,3)`, uint32(5), nil},\n\n\tTestCase{F | G1, \"specialized_generic_func_1\", `template[] for[bool] func count(a, b bool) bool { return a || b }`, nil, none},\n\tTestCase{F | G1, \"specialized_generic_func_2\", `count#[bool]`, func(bool, bool) bool { return false }, nil},\n\tTestCase{F | G1, \"specialized_generic_func_3\", `count#[bool](false, true)`, true, nil},\n\tTestCase{F | G1, \"specialized_generic_func_4\", `template[T] for[*T] func count(a, b *T) *T { return a }`, nil, none},\n\tTestCase{F | G1, \"specialized_generic_func_5\", `count#[*int]`, func(*int, *int) *int { return nil }, nil},\n\n\tTestCase{F | G1 | G2, \"generic_type_1\",\n\t\tgeneric_type(\"PairX\", \"T1,T2\") + `struct { First T1; Second T2 }`,\n\t\tnil, none,\n\t},\n\tTestCase{F | G1 | G2, \"generic_type_2\", `var px PairX#[complex64, struct{}]; px`, PairX2{}, nil},\n\tTestCase{F | G1 | G2, \"generic_type_3\", `PairX#[bool, interface{}] {true, \"foo\"}`, PairX3{true, \"foo\"}, nil},\n\n\tTestCase{F | G1 | G2, \"recursive_generic_type_1\",\n\t\tgeneric_type(\"ListX\", \"T\") + `struct { First T; Rest *ListX#[T] }\n\t\tvar lx ListX#[error]; lx`, ListX2{nil, (*ListX2)(nil)}, nil},\n\tTestCase{F | G1 | G2, \"recursive_generic_type_2\", `ListX#[interface{}]{}`,\n\t\tListX3{nil, (*ListX3)(nil)}, nil},\n\n\tTestCase{F | G1, \"specialized_generic_type_1\", `\n\t\ttemplate[] for[struct{}] type ListX struct { }\n\t\ttemplate[T] for[T,T] type PairX struct { Left, Right T }\n\t\tPairX#[bool,bool]{false,true}`, struct{ Left, Right bool }{false, true}, nil},\n\n\tTestCase{F | G1, \"turing_complete_generic_1\", `\n\t\ttemplate[N] type Fib [len((*Fib#[N-1])(nil)) + len((*Fib#[N-2])(nil))] int\n\t\ttemplate[] for[1] type Fib [1]int\n\t\ttemplate[] for[0] type Fib [0]int\n\t\tconst Fib30 = len((*Fib#[30])(nil)); Fib30`, 832040, nil},\n\n\tTestCase{F | G2, \"cti_basic_method_1\", `1 .Add(2, 3)`, 2 + 3, nil},\n\tTestCase{F | G2, \"cti_basic_method_2\", `1.2 .Mul(2.3, 3.4)`, float64(2.3) * float64(3.4), nil},\n\tTestCase{F | G2, \"cti_basic_method_3\", `false.Not(true)`, false, nil},\n\tTestCase{F | G2, \"cti_basic_method_4\", `uint64(7).Less(7)`, false, nil},\n\tTestCase{F | G2, \"cti_basic_method_5\", `int.Cmp(1, 2)`, -1, nil},\n\tTestCase{F | G2, \"cti_basic_method_6\", `8 .Equal(8)`, true, nil},\n\tTestCase{F | G2, \"cti_basic_method_7\", `8.9i .Imag()`, 8.9, nil},\n\tTestCase{F | G2, \"cti_basic_method_8\", `\"abc\".Index(2)`, \"abc\"[2], nil},\n\tTestCase{F | G2, \"cti_basic_method_9\", `\"abcdefgh\".Len()`, len(\"abcdefgh\"), nil},\n\tTestCase{F | G2, \"cti_basic_method_10\", `\"wxyz\".Slice(1,2)`, \"wxyz\"[1:2], nil},\n\n\tTestCase{F | G2, \"cti_method_array_len\", `[...]int{1,2}.Len()`, len([...]int{1, 2}), nil},\n\tTestCase{F | G2, \"cti_method_array_index\", `[...]int{999:1}.Index(999)`, 1, nil},\n\tTestCase{F | G2, \"cti_method_array_slice\", `[...]int{0,1,2,3,4,5}.Slice(2,5)`, []int{2, 3, 4}, nil},\n\tTestCase{F | G2, \"cti_method_chan_cap\", `make(chan int).Cap()`, cap(make(chan int)), nil},\n\tTestCase{F | G2, \"cti_method_slice_len\", `[]int{3,4,5}.Len()`, len([]int{3, 4, 5}), nil},\n\tTestCase{F | G2, \"cti_method_slice_slice\", `[]int{0,1,2,3,4,5}.Slice(1,4)`, []int{1, 2, 3}, nil},\n\tTestCase{F | G2, \"cti_method_map_index\", `map[int]uint{1:1,-2:2}.Index(-2)`, map[int]uint{1: 1, -2: 2}[-2], nil},\n\n\tTestCase{A | G2, \"parse_constrained_generic_1\", \"~quote{Set#[T: Eq]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX: &ast.Ident{Name: \"Set\"},\n\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t&ast.KeyValueExpr{\n\t\t\t\t\t\tKey:   &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\tValue: &ast.Ident{Name: \"Eq\"},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\tTestCase{A | G2, \"parse_constrained_generic_2\", \"~quote{Set#[T: Eq && Ord]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX: &ast.Ident{Name: \"Set\"},\n\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t&ast.KeyValueExpr{\n\t\t\t\t\t\tKey: &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\tValue: &ast.BinaryExpr{\n\t\t\t\t\t\t\tX:  &ast.Ident{Name: \"Eq\"},\n\t\t\t\t\t\t\tOp: token.LAND,\n\t\t\t\t\t\t\tY:  &ast.Ident{Name: \"Ord\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\tTestCase{A | G2, \"parse_constrained_generic_3\", \"~quote{Set#[T: Eq#[T] && Ord#[T]]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX: &ast.Ident{Name: \"Set\"},\n\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t&ast.KeyValueExpr{\n\t\t\t\t\t\tKey: &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\tValue: &ast.BinaryExpr{\n\t\t\t\t\t\t\tX: &ast.IndexExpr{\n\t\t\t\t\t\t\t\tX: &ast.Ident{Name: \"Eq\"},\n\t\t\t\t\t\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tOp: token.LAND,\n\t\t\t\t\t\t\tY: &ast.IndexExpr{\n\t\t\t\t\t\t\t\tX: &ast.Ident{Name: \"Ord\"},\n\t\t\t\t\t\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\tTestCase{A | G2, \"parse_constrained_generic_4\", \"~quote{SortedMap#[K: Ord, V: Container#[SortedMap#[K,V],K,V]]}\",\n\t\t&ast.IndexExpr{\n\t\t\tX: &ast.Ident{Name: \"SortedMap\"},\n\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t&ast.KeyValueExpr{\n\t\t\t\t\t\tKey:   &ast.Ident{Name: \"K\"},\n\t\t\t\t\t\tValue: &ast.Ident{Name: \"Ord\"},\n\t\t\t\t\t},\n\t\t\t\t\t&ast.KeyValueExpr{\n\t\t\t\t\t\tKey: &ast.Ident{Name: \"V\"},\n\t\t\t\t\t\tValue: &ast.IndexExpr{\n\t\t\t\t\t\t\tX: &ast.Ident{Name: \"Container\"},\n\t\t\t\t\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t\t\t&ast.IndexExpr{\n\t\t\t\t\t\t\t\t\t\tX: &ast.Ident{Name: \"SortedMap\"},\n\t\t\t\t\t\t\t\t\t\tIndex: &ast.CompositeLit{\n\t\t\t\t\t\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"K\"},\n\t\t\t\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"V\"},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"K\"},\n\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"V\"},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\tTestCase{A | G2, \"parse_generic_contract_1\", `~quote{\n\t\ttype Eq#[T] interface{\n\t\t\tfunc (T) Equal(T) bool\n\t\t}}`,\n\t\t&ast.GenDecl{\n\t\t\tTok: token.TYPE,\n\t\t\tSpecs: []ast.Spec{\n\t\t\t\t&ast.TypeSpec{\n\t\t\t\t\tName: &ast.Ident{Name: \"Eq\"},\n\t\t\t\t\tType: &ast.CompositeLit{\n\t\t\t\t\t\tType: &ast.InterfaceType{\n\t\t\t\t\t\t\tMethods: &ast.FieldList{\n\t\t\t\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t\t\t\t&ast.Field{\n\t\t\t\t\t\t\t\t\t\tNames: []*ast.Ident{\n\t\t\t\t\t\t\t\t\t\t\t&ast.Ident{Name: \"Equal\"},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\tType: &ast.MapType{\n\t\t\t\t\t\t\t\t\t\t\tKey: &ast.Ident{Name: \"T\"}, // receiver\n\t\t\t\t\t\t\t\t\t\t\tValue: &ast.FuncType{\n\t\t\t\t\t\t\t\t\t\t\t\tParams: &ast.FieldList{\n\t\t\t\t\t\t\t\t\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&ast.Field{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tType: &ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\tResults: &ast.FieldList{\n\t\t\t\t\t\t\t\t\t\t\t\t\tList: []*ast.Field{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t&ast.Field{\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tType: &ast.Ident{Name: \"bool\"},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t\tElts: []ast.Expr{\n\t\t\t\t\t\t\t&ast.Ident{Name: \"T\"},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, nil},\n\tTestCase{F | G2, \"generic_contract_1\", `\n\t\ttype Eq#[T] interface{\n\t\t\tfunc (T) Equal(T) bool\n\t\t}\n\t\tvar xg1 Eq#[int]\n\t\txg1`, fastObjEqint, nil},\n\tTestCase{F | G2, \"generic_contract_2\", `\n\t\ttype UInt uint\n\t\tfunc (i UInt) Equal(j UInt) bool {\n\t\t\treturn i == j\n\t\t}`, nil, none},\n\tTestCase{F | G2, \"generic_contract_3\", `\n\t\txg2 := UInt(9)\n\t\tvar xg3 Eq#[UInt]\n\t\txg3 = xg2\n\t\txg2`, uint(9), nil},\n}\n\nfunc (c *TestCase) compareResults(t *testing.T, actual []r.Value) {\n\texpected := c.results\n\tif expected == nil {\n\t\texpected = []interface{}{c.result0}\n\t}\n\tif len(actual) != len(expected) {\n\t\tc.fail(t, actual, expected)\n\t\treturn\n\t}\n\tfor i := range actual {\n\t\tc.compareResult(t, actual[i], expected[i])\n\t}\n}\n\nfunc (c *TestCase) compareResult(t *testing.T, actualv r.Value, expected interface{}) {\n\tif actualv == NilR || actualv == NoneR {\n\t\tif expected != nil {\n\t\t\tc.fail(t, nil, expected)\n\t\t}\n\t\treturn\n\t}\n\tactual := actualv.Interface()\n\tif actual == nil || expected == nil {\n\t\tif actual != nil || expected != nil {\n\t\t\tc.fail(t, actual, expected)\n\t\t}\n\t\treturn\n\t}\n\tif !r.DeepEqual(actual, expected) {\n\t\tif r.TypeOf(actual) == r.TypeOf(expected) {\n\t\t\tif actualNode, ok := actual.(ast.Node); ok {\n\t\t\t\tif expectedNode, ok := expected.(ast.Node); ok {\n\t\t\t\t\tc.compareAst(t, ToAst(actualNode), ToAst(expectedNode))\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if actualUntyped, ok := actual.(untyped.Lit); ok {\n\t\t\t\tif expectedUntyped, ok := expected.(untyped.Lit); ok {\n\t\t\t\t\tc.compareUntyped(t, actualUntyped, expectedUntyped)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if actualv.Kind() == r.Chan {\n\t\t\t\t// for channels just check the type, length and capacity\n\t\t\t\texpectedv := r.ValueOf(expected)\n\t\t\t\tif actualv.Len() == expectedv.Len() && actualv.Cap() == expectedv.Cap() {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t} else if actualv.Kind() == r.Func {\n\t\t\t\t// for functions just check the type\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tc.fail(t, actual, expected)\n\t}\n}\n\nfunc (c *TestCase) compareAst(t *testing.T, actual Ast, expected Ast) {\n\tif actual == nil || expected == nil {\n\t\tif actual != nil || expected != nil {\n\t\t\tc.fail(t, actual, expected)\n\t\t}\n\t\treturn\n\t}\n\tif r.TypeOf(actual) == r.TypeOf(expected) {\n\t\tswitch actual := actual.(type) {\n\t\tcase BadDecl, BadExpr, BadStmt:\n\t\t\treturn\n\t\tcase Ident:\n\t\t\tif actual.X.Name == expected.(Ident).X.Name {\n\t\t\t\treturn\n\t\t\t}\n\t\tcase BasicLit:\n\t\t\tactualp := actual.X\n\t\t\texpectedp := expected.(BasicLit).X\n\t\t\tif actualp == expectedp || (actualp != nil && expectedp != nil && actualp.Kind == expectedp.Kind && actualp.Value == expectedp.Value) {\n\t\t\t\treturn\n\t\t\t}\n\t\tdefault:\n\t\t\tna := actual.Size()\n\t\t\tne := expected.Size()\n\t\t\tif actual.Op() == expected.Op() && na == ne {\n\t\t\t\tfor i := 0; i < na; i++ {\n\t\t\t\t\tc.compareAst(t, actual.Get(i), expected.Get(i))\n\t\t\t\t}\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n\tc.fail(t, actual.Interface(), expected.Interface())\n}\n\nfunc (c *TestCase) compareUntyped(t *testing.T, actual untyped.Lit, expected untyped.Lit) {\n\tif actual.Kind == expected.Kind && actual.Val.Kind() == expected.Val.Kind() && constant.Compare(actual.Val, token.EQL, expected.Val) {\n\t\treturn\n\t}\n\tc.fail(t, actual, expected)\n}\n\nfunc (c *TestCase) fail(t *testing.T, actual interface{}, expected interface{}) {\n\tt.Errorf(\"expecting %v <%T>, found %v <%T>\\n\", expected, expected, actual, actual)\n}\n"
        },
        {
          "name": "ast2",
          "type": "tree",
          "content": null
        },
        {
          "name": "atomic",
          "type": "tree",
          "content": null
        },
        {
          "name": "base",
          "type": "tree",
          "content": null
        },
        {
          "name": "bench_sort_test.go",
          "type": "blob",
          "size": 6.095703125,
          "content": "/*\n * gomacro - A Go interpreter with Lisp-like macros\n *\n * Copyright (C) 2018-2019 Massimiliano Ghilardi\n *\n *     This Source Code Form is subject to the terms of the Mozilla Public\n *     License, v. 2.0. If a copy of the MPL was not distributed with this\n *     file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n *\n * bench_sort_test.go\n *\n *  Created on: Jun 09 2018\n *      Author: Massimiliano Ghilardi\n */\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n\t\"testing\"\n\n\t\"github.com/cosmos72/gomacro/classic\"\n\t\"github.com/cosmos72/gomacro/fast\"\n)\n\nvar verbosesort = verbose\n\nfunc quicksortInts(v []int) {\n\tfor len(v) >= 30 {\n\t\tn := len(v)\n\n\t\tleft, right := 0, n-1\n\n\t\tpivot := rand.Intn(n)\n\n\t\tv[pivot], v[right] = v[right], v[pivot]\n\n\t\tfor i, _ := range v {\n\t\t\tif v[i] < v[right] {\n\t\t\t\tv[left], v[i] = v[i], v[left]\n\t\t\t\tleft++\n\t\t\t}\n\t\t}\n\n\t\tv[left], v[right] = v[right], v[left]\n\n\t\tif left < n-left {\n\t\t\tquicksortInts(v[:left])\n\t\t\tv = v[left+1:]\n\t\t} else {\n\t\t\tquicksortInts(v[left+1:])\n\t\t\tv = v[:left]\n\t\t}\n\t}\n\tif n := len(v); n >= 3 {\n\t\tshellsortInts(v)\n\t} else if n == 2 {\n\t\tif v[0] > v[1] {\n\t\t\tv[0], v[1] = v[1], v[0]\n\t\t}\n\t}\n}\n\n// ---------------------- arrays: shellsort ------------------------\n\n// array indexing is faster that slice indexing,\n// provided the array is *not* copied. so use a pointer to array\nvar shellshort_gaps = &[...]int{8839, 3797, 1631, 701, 301, 132, 57, 23, 10, 4, 1}\n\nfunc shellsortInts(v []int) {\n\tvar i, j, n, gap, temp int\n\tn = len(v)\n\tfor _, gap = range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\ttemp = v[i]\n\t\t\tfor j = i; j >= gap && v[j-gap] > temp; j -= gap {\n\t\t\t\tv[j] = v[j-gap]\n\t\t\t}\n\t\t\tv[j] = temp\n\t\t}\n\t}\n}\n\nfunc shellsortIntSlice(ints []int) {\n\tvar v sort.IntSlice = ints\n\tvar i, j, n, gap int\n\tn = v.Len()\n\tfor _, gap = range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\tfor j = i; j >= gap && v.Less(j, j-gap); j -= gap {\n\t\t\t\tv.Swap(j, j-gap)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc shellsortInterfaces(ints []int) {\n\t// if v is declared with type sort.IntSlice, performance reaches shellsortInts() above\n\tvar v sort.Interface = sort.IntSlice(ints)\n\tvar i, j, n, gap int\n\tn = v.Len()\n\tfor _, gap = range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\tfor j = i; j >= gap && v.Less(j, j-gap); j -= gap {\n\t\t\t\tv.Swap(j, j-gap)\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst shellsort_ints_source_string = `\nvar shellshort_gaps = [...]int{8839, 3797, 1631, 701, 301, 132, 57, 23, 10, 4, 1}\n\nfunc shellsort(v []int) {\n\tvar i, j, n, temp int\n\tn = len(v)\n\tfor _, gap := range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\ttemp = v[i]\n\t\t\tfor j = i; j >= gap && v[j-gap] > temp; j -= gap {\n\t\t\t\tv[j] = v[j-gap]\n\t\t\t}\n\t\t\tv[j] = temp\n\t\t}\n\t}\n}`\n\nconst shellsort_intslice_source_string = `\nimport \"sort\"\n\nvar shellshort_gaps = [...]int{8839, 3797, 1631, 701, 301, 132, 57, 23, 10, 4, 1}\n\nfunc shellsort(ints []int) {\n\tvar v sort.IntSlice = ints\n\tvar i, j, n, gap int\n\tn = v.Len()\n\tfor _, gap = range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\tfor j = i; j >= gap && v.Less(j, j-gap); j -= gap {\n\t\t\t\tv.Swap(j, j-gap)\n\t\t\t}\n\t\t}\n\t}\n}`\n\nconst shellsort_interfaces_source_string = `\nimport \"sort\"\n\nvar shellshort_gaps = [...]int{8839, 3797, 1631, 701, 301, 132, 57, 23, 10, 4, 1}\n\nfunc shellsort(ints []int) {\n\tvar v sort.Interface = sort.IntSlice(ints)\n\tvar i, j, n, gap int\n\tn = v.Len()\n\tfor _, gap = range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\tfor j = i; j >= gap && v.Less(j, j-gap); j -= gap {\n\t\t\t\tv.Swap(j, j-gap)\n\t\t\t}\n\t\t}\n\t}\n}`\n\nvar shellsort_generic_source_string = `\nvar shellshort_gaps = [...]int{8839, 3797, 1631, 701, 301, 132, 57, 23, 10, 4, 1}\n\n` + generic_func(\"shellsort\", \"T\") + ` (v []T) {\n\tvar i, j, n int\n\tvar temp T\n\tn = len(v)\n\tfor _, gap := range shellshort_gaps {\n\t\tfor i = gap; i < n; i++ {\n\t\t\ttemp = v[i]\n\t\t\tfor j = i; j >= gap && v[j-gap] > temp; j -= gap {\n\t\t\t\tv[j] = v[j-gap]\n\t\t\t}\n\t\t\tv[j] = temp\n\t\t}\n\t}\n}`\n\nfunc BenchmarkQuickSortCompilerInts(b *testing.B) {\n\tbenchmark_sort(b, quicksortInts)\n}\n\nfunc BenchmarkShellSortCompilerInts(b *testing.B) {\n\tbenchmark_sort(b, shellsortInts)\n}\n\nfunc BenchmarkShellSortCompilerIntSlice(b *testing.B) {\n\tbenchmark_sort(b, shellsortIntSlice)\n}\n\nfunc BenchmarkShellSortCompilerInterfaces(b *testing.B) {\n\tbenchmark_sort(b, shellsortInterfaces)\n}\n\nfunc BenchmarkStdSortCompilerInterfaces(b *testing.B) {\n\t// use standard library sort\n\tbenchmark_sort(b, sort.Ints)\n}\n\nfunc BenchmarkShellSortFastInts(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(shellsort_ints_source_string)\n\n\t// extract the function shellsort()\n\tsort := ir.ValueOf(\"shellsort\").Interface().(func([]int))\n\n\tbenchmark_sort(b, sort)\n}\n\nfunc BenchmarkShellSortFastGeneric(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(shellsort_generic_source_string)\n\n\t// extract the function shellsort#[int]()\n\tvs, _ := ir.Eval(\"shellsort#[int]\")\n\tsort := vs[0].Interface().(func([]int))\n\n\tbenchmark_sort(b, sort)\n}\n\nfunc BenchmarkShellSortFastInterfaces(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(shellsort_interfaces_source_string)\n\n\t// extract the function shellsort()\n\tsort := ir.ValueOf(\"shellsort\").Interface().(func([]int))\n\n\tbenchmark_sort(b, sort)\n}\n\nfunc BenchmarkShellSortFastIntSlice(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(shellsort_intslice_source_string)\n\n\t// extract the function shellsort()\n\tsort := ir.ValueOf(\"shellsort\").Interface().(func([]int))\n\n\tbenchmark_sort(b, sort)\n}\n\nfunc BenchmarkShellSortFastCompileLoop(b *testing.B) {\n\tir := fast.New()\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tir.Comp.Binds = make(map[string]*fast.Bind)\n\t\tir.Comp.BindNum = fast.NoIndex\n\t\tir.Compile(shellsort_ints_source_string)\n\t}\n}\n\nfunc BenchmarkShellSortClassicInts(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(shellsort_ints_source_string)\n\n\t// extract the function shellsort()\n\tsort := ir.ValueOf(\"shellsort\").Interface().(func([]int))\n\n\tbenchmark_sort(b, sort)\n}\n\nvar sort_data = make_sort_data()\n\nfunc make_sort_data() []int {\n\tconst n = 10000\n\tv := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tv[i] = rand.Int()\n\t}\n\treturn v\n}\n\nfunc benchmark_sort(b *testing.B, sort func([]int)) {\n\t// call sort once for warm-up\n\tv := make([]int, len(sort_data))\n\tcopy(v, sort_data)\n\tsort(v)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tcopy(v, sort_data)\n\t\tsort(v)\n\t}\n\tif verbosesort {\n\t\tfmt.Println(v)\n\t}\n}\n"
        },
        {
          "name": "bench_test.go",
          "type": "blob",
          "size": 12.1806640625,
          "content": "/*\n * gomacro - A Go interpreter with Lisp-like macros\n *\n * Copyright (C) 2017-2019 Massimiliano Ghilardi\n *\n *     This Source Code Form is subject to the terms of the Mozilla Public\n *     License, v. 2.0. If a copy of the MPL was not distributed with this\n *     file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n *\n * bench_test.go\n *\n *  Created on: Mar 06 2017\n *      Author: Massimiliano Ghilardi\n */\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\tr \"reflect\"\n\t\"testing\"\n\n\t\"github.com/cosmos72/gomacro/classic\"\n\t\"github.com/cosmos72/gomacro/fast\"\n)\n\nvar (\n\tcollatz_arg     = uint(837799) // sequence climbs to 1487492288, which also fits 32-bit ints\n\tcollatz_arg_int = int(837799)\n\tsum_arg         = 1000\n\tfib_arg         = 12\n\tbigswitch_arg   = 100\n\n\tverbose = len(os.Args) == 0\n)\n\n/*\n\t--------- 2017-05-21: results on Intel Core i7 4770 ---------------\n\n\tBenchmarkFibonacciCompiler-8            \t 3000000\t       501 ns/op\n\tBenchmarkFibonacciFast-8                \t  100000\t     15774 ns/op\n\tBenchmarkFibonacciFast2-8               \t  100000\t     15141 ns/op\n\tBenchmarkFibonacciClassic-8             \t    2000\t    915990 ns/op\n\tBenchmarkFibonacciClassic2-8            \t    2000\t    912180 ns/op\n\tBenchmarkFibonacciClosureValues-8       \t    5000\t    259074 ns/op\n\tBenchmarkFibonacciClosureInterfaces-8   \t   10000\t    193098 ns/op\n\tBenchmarkFibonacciClosureMaps-8         \t    5000\t    358345 ns/op\n\tBenchmarkShellSortCompiler-8            \t20000000\t        74.0 ns/op\n\tBenchmarkShellSortFast-8                \t  200000\t      7790 ns/op\n\tBenchmarkShellSortClassic-8             \t    5000\t    276673 ns/op\n\tBenchmarkSwitchCompiler-8               \t 1000000\t      2363 ns/op\n\tBenchmarkSwitchFast-8                   \t   50000\t     37773 ns/op\n\tBenchmarkSwitchClassic-8                \t     500\t   3454461 ns/op\n\tBenchmarkArithCompiler1-8               \t200000000\t         8.41 ns/op\n\tBenchmarkArithCompiler2-8               \t200000000\t         8.41 ns/op\n\tBenchmarkArithFast-8                    \t50000000\t        30.8 ns/op\n\tBenchmarkArithFast2-8                   \t30000000\t        50.6 ns/op\n\tBenchmarkArithFastConst-8               \t100000000\t        15.2 ns/op\n\tBenchmarkArithFastCompileLoop-8         \t  100000\t     21442 ns/op\n\tBenchmarkArithClassic-8                 \t 1000000\t      1686 ns/op\n\tBenchmarkArithClassic2-8                \t  500000\t      2916 ns/op\n\tBenchmarkCollatzCompiler-8              \t 5000000\t       265 ns/op\n\tBenchmarkCollatzFast-8                  \t  200000\t     11812 ns/op\n\tBenchmarkCollatzClassic-8               \t    2000\t    654139 ns/op\n\tBenchmarkCollatzBytecodeInterfaces-8    \t   50000\t     30203 ns/op\n\tBenchmarkCollatzClosureValues-8         \t  100000\t     16570 ns/op\n\tBenchmarkSumCompiler-8                  \t 5000000\t       294 ns/op\n\tBenchmarkSumFast-8                      \t  100000\t     20789 ns/op\n\tBenchmarkSumFast2-8                     \t  100000\t     20720 ns/op\n\tBenchmarkSumClassic-8                   \t    1000\t   1223624 ns/op\n\tBenchmarkSumBytecodeValues-8            \t   20000\t     76201 ns/op\n\tBenchmarkSumBytecodeInterfaces-8        \t   30000\t     53031 ns/op\n\tBenchmarkSumClosureValues-8             \t   30000\t     41124 ns/op\n\tBenchmarkSumClosureInterfaces-8         \t   10000\t    147109 ns/op\n\tBenchmarkSumClosureMaps-8               \t   20000\t     93320 ns/op\n*/\n\n// ---------------------- recursion: fibonacci ----------------------\n\nfunc fibonacci(n int) int {\n\tif n <= 2 {\n\t\treturn 1\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}\n\nfunc BenchmarkFibonacciCompiler(b *testing.B) {\n\tvar total int\n\tn := fib_arg\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fibonacci(n)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkFibonacciFast(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(fibonacci_source_string)\n\n\t// compile the call to fibonacci(fib_n)\n\texpr := ir.Compile(fmt.Sprintf(\"fibonacci(%d)\", fib_arg))\n\tfun := expr.Fun.(func(*fast.Env) int)\n\tenv := ir.PrepareEnv()\n\n\tfun(env) // warm up\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(env)\n\t}\n}\n\nfunc BenchmarkFibonacciFast2(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(fibonacci_source_string)\n\n\t// alternative: extract the function fibonacci, and call it ourselves\n\t//\n\t// ValueOf is the method to retrieve constants, functions and variables from the classic and fast interpreters\n\t// (if you are going to read or write the same interpreter variable repeatedly,\n\t// dereferencing the address returned by AddressOfVar is faster)\n\tfun := ir.ValueOf(\"fibonacci\").Interface().(func(int) int)\n\n\tfun(fib_arg) // warm up\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(fib_arg)\n\t}\n}\n\nfunc BenchmarkFibonacciClassic(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(fibonacci_source_string)\n\n\t// compile the call to fibonacci(fib_n)\n\tform := ir.Parse(fmt.Sprintf(\"fibonacci(%d)\", fib_arg))\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += int(ir.EvalAst1(form).Int())\n\t}\n}\n\nfunc BenchmarkFibonacciClassic2(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(fibonacci_source_string)\n\n\t// alternative: extract the function fibonacci, and call it ourselves\n\tfun := ir.ValueOf(\"fibonacci\").Interface().(func(int) int)\n\n\tfun(fib_arg) // warm up\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(fib_arg)\n\t}\n}\n\n// ---------------------- switch ------------------------\n\nfunc bigswitch(n int) int {\n\tfor i := 0; i < 1000; i++ {\n\t\tswitch n & 15 {\n\t\tcase 0:\n\t\t\tn++\n\t\tcase 1:\n\t\t\tn += 2\n\t\tcase 2:\n\t\t\tn += 3\n\t\tcase 3:\n\t\t\tn += 4\n\t\tcase 4:\n\t\t\tn += 5\n\t\tcase 5:\n\t\t\tn += 6\n\t\tcase 6:\n\t\t\tn += 7\n\t\tcase 7:\n\t\t\tn += 8\n\t\tcase 8:\n\t\t\tn += 9\n\t\tcase 9:\n\t\t\tn += 10\n\t\tcase 10:\n\t\t\tn += 11\n\t\tcase 11:\n\t\t\tn += 12\n\t\tcase 12:\n\t\t\tn += 13\n\t\tcase 13:\n\t\t\tn += 14\n\t\tcase 14:\n\t\t\tn += 15\n\t\tcase 15:\n\t\t\tn--\n\t\t}\n\t}\n\treturn n\n}\n\nfunc BenchmarkSwitchCompiler(b *testing.B) {\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += bigswitch(bigswitch_arg)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkSwitchFast(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(switch_source_string)\n\n\tfun := ir.ValueOf(\"bigswitch\").Interface().(func(int) int)\n\tfun(bigswitch_arg)\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(bigswitch_arg)\n\t}\n}\n\nfunc BenchmarkSwitchClassic(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(switch_source_string)\n\n\tfun := ir.ValueOf(\"bigswitch\").Interface().(func(int) int)\n\tfun(bigswitch_arg)\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(bigswitch_arg)\n\t}\n}\n\n// ---------------- simple arithmetic ------------------\n\n//go:noinline\nfunc arith(n int) int {\n\treturn ((((n*2 + 3) | 4) &^ 5) ^ 6) - ((n & 2) | 1)\n}\n\nconst arith_source = \"((((n*2+3)|4) &^ 5) ^ 6) - ((n & 2) | 1)\"\n\nfunc BenchmarkArithCompiler1(b *testing.B) {\n\ttotal := 0\n\tfor i := 0; i < b.N; i++ {\n\t\tn := b.N\n\t\ttotal += ((((n*2 + 3) | 4) &^ 5) ^ 6) - ((n & 2) | 1)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkArithCompiler2(b *testing.B) {\n\ttotal := 0\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += arith(b.N)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkArithFast(b *testing.B) {\n\tir := fast.New()\n\tir.DeclVar(\"n\", nil, int(0))\n\n\taddr := ir.AddressOfVar(\"n\").Interface().(*int)\n\n\texpr := ir.Compile(arith_source)\n\tfun := expr.Fun.(func(*fast.Env) int)\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\n\t// interpreted code performs only arithmetic - iteration performed here\n\tb.ResetTimer()\n\ttotal := 0\n\tfor i := 0; i < b.N; i++ {\n\t\t*addr = b.N\n\t\ttotal += fun(env)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkArithFast2(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(\"var i, n, total int\")\n\n\tn := ir.AddressOfVar(\"n\").Interface().(*int)\n\ttotal := ir.AddressOfVar(\"total\").Interface().(*int)\n\n\t// interpreted code performs iteration and arithmetic\n\tfun := ir.Compile(\"for i = 0; i < n; i++ { total += \" + arith_source + \" }\").AsX()\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\n\tb.ResetTimer()\n\n\t*n = b.N\n\t*total = 0\n\tfun(env)\n\n\tif verbose {\n\t\tprintln(*total)\n\t}\n}\n\nfunc BenchmarkArithFastConst(b *testing.B) {\n\tir := fast.New()\n\t// \"cheat\" a bit and declare n as a constant. checks if constant propagation works :)\n\tir.DeclConst(\"n\", nil, b.N)\n\n\t// interpreted code performs only arithmetic - iteration performed here\n\texpr := ir.Compile(arith_source)\n\tfun := expr.WithFun().(func(*fast.Env) int)\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\n\tb.ResetTimer()\n\ttotal := 0\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(env)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkArithFastConst2(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(\"var i, total int\")\n\t// \"cheat\" a bit and declare n as a constant. checks if constant propagation works :)\n\tir.DeclConst(\"n\", nil, int(b.N))\n\ttotal := ir.AddressOfVar(\"total\").Interface().(*int)\n\n\t// interpreted code performs iteration and arithmetic\n\tfun := ir.Compile(\"for i = 0; i < n; i++ { total += \" + arith_source + \" }\").AsX()\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\n\tb.ResetTimer()\n\n\t*total = 0\n\tfun(env)\n\n\tif verbose {\n\t\tprintln(*total)\n\t}\n}\n\nfunc BenchmarkArithFastCompileLoop(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(\"var i, n, total int\")\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tir.Compile(\"total = 0; for i = 0; i < n; i++ { total += \" + arith_source + \" }; total\")\n\t}\n}\n\nfunc BenchmarkArithClassic(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(\"n:=0\")\n\n\tform := ir.Parse(arith_source)\n\n\tvalue := ir.ValueOf(\"n\")\n\tvar ret r.Value\n\tir.EvalAst(form)\n\n\t// interpreted code performs only arithmetic - iteration performed here\n\tb.ResetTimer()\n\ttotal := 0\n\tfor i := 0; i < b.N; i++ {\n\t\tvalue.SetInt(int64(b.N))\n\t\tret, _ = ir.EvalAst(form)\n\t\ttotal += int(ret.Int())\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkArithClassic2(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(\"var n, total int\")\n\n\t// interpreted code performs iteration and arithmetic\n\tform := ir.Parse(\"total = 0; for i:= 0; i < n; i++ { total += \" + arith_source + \" }; total\")\n\n\tvalue := ir.ValueOf(\"n\")\n\tir.EvalAst(form)\n\n\tb.ResetTimer()\n\tvalue.SetInt(int64(b.N))\n\tret, _ := ir.EvalAst(form)\n\n\tif verbose {\n\t\tprintln(ret.Int())\n\t}\n}\n\n// ---------------- collatz conjecture --------------------\n\nfunc collatz(n uint) uint {\n\tfor n > 1 {\n\t\tif n&1 != 0 {\n\t\t\tn = ((n * 3) + 1) >> 1\n\t\t} else {\n\t\t\tn >>= 1\n\t\t}\n\t}\n\treturn n\n}\n\nfunc BenchmarkCollatzCompiler(b *testing.B) {\n\tvar n uint = collatz_arg\n\tfor i := 0; i < b.N; i++ {\n\t\tcollatz(n)\n\t}\n}\n\nfunc BenchmarkCollatzFast(b *testing.B) {\n\tir := fast.New()\n\tir.DeclVar(\"n\", nil, uint(0))\n\taddr := ir.AddressOfVar(\"n\").Interface().(*uint)\n\n\tfun := ir.Compile(\"for n > 1 { if n&1 != 0 { n = ((n * 3) + 1) >> 1 } else { n >>= 1 } }\").AsX()\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t*addr = collatz_arg\n\t\tfun(env)\n\t}\n}\n\nfunc BenchmarkCollatzClassic(b *testing.B) {\n\tir := classic.New()\n\tir.EvalAst(ir.Parse(\"var n uint\"))\n\taddr := ir.ValueOf(\"n\").Addr().Interface().(*uint)\n\n\tform := ir.Parse(\"for n > 1 { if n&1 != 0 { n = ((n * 3) + 1) >> 1 } else { n >>= 1 } }\")\n\tir.EvalAst(form)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t*addr = collatz_arg\n\t\tir.EvalAst(form)\n\t}\n}\n\n// ------------- looping: sum the integers from 1 to N -------------------\n\nfunc sum(n int) int {\n\ttotal := 0\n\tfor i := 1; i <= n; i++ {\n\t\ttotal += i\n\t}\n\treturn total\n}\n\nfunc BenchmarkSumCompiler(b *testing.B) {\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += sum(sum_arg)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkSumFast(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(\"var i, total uint\")\n\tir.DeclConst(\"n\", nil, uint(sum_arg))\n\n\texpr := ir.Compile(\"total = 0; for i = 1; i <= n; i++ { total += i }; total\")\n\tfun := expr.Fun.(func(*fast.Env) uint)\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\n\tvar total uint\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += fun(env)\n\t}\n\tif verbose {\n\t\tprintln(total)\n\t}\n}\n\nfunc BenchmarkSumFast2(b *testing.B) {\n\tir := fast.New()\n\tir.Eval(\"var i, total uint\")\n\tir.DeclConst(\"n\", nil, uint(sum_arg))\n\n\tfun := ir.Compile(\"for i = 1; i <= n; i++ { total += i }\").AsX()\n\tenv := ir.PrepareEnv()\n\tfun(env)\n\ttotal := ir.AddressOfVar(\"total\").Interface().(*uint)\n\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\t*total = 0\n\t\tfun(env)\n\t}\n\tif verbose {\n\t\tprintln(*total)\n\t}\n}\n\nfunc BenchmarkSumClassic(b *testing.B) {\n\tir := classic.New()\n\tir.Eval(\"var i, n, total int\")\n\tir.ValueOf(\"n\").SetInt(int64(sum_arg))\n\tform := ir.Parse(\"total = 0; for i = 1; i <= n; i++ { total += i }; total\")\n\n\tb.ResetTimer()\n\tvar total int\n\tfor i := 0; i < b.N; i++ {\n\t\ttotal += int(ir.EvalAst1(form).Int())\n\t}\n}\n"
        },
        {
          "name": "classic",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd_classic",
          "type": "tree",
          "content": null
        },
        {
          "name": "doc",
          "type": "tree",
          "content": null
        },
        {
          "name": "fast",
          "type": "tree",
          "content": null
        },
        {
          "name": "gls",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.28125,
          "content": "module github.com/cosmos72/gomacro\n\ngo 1.18\n\nrequire (\n\tgithub.com/mattn/go-runewidth v0.0.15\n\tgithub.com/peterh/liner v1.2.2\n\tgolang.org/x/tools v0.14.0\n)\n\nrequire (\n\tgithub.com/rivo/uniseg v0.2.0 // indirect\n\tgolang.org/x/mod v0.13.0 // indirect\n\tgolang.org/x/sys v0.13.0 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.212890625,
          "content": "github.com/mattn/go-runewidth v0.0.3/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/peterh/liner v1.2.2 h1:aJ4AOodmL+JxOZZEL2u9iJf8omNRpqHc/EbrK+3mAXw=\ngithub.com/peterh/liner v1.2.2/go.mod h1:xFwJyiKIXJZUKItq5dGHZSTBRAuG/CpeNpWLyiNRNwI=\ngithub.com/rivo/uniseg v0.2.0 h1:S1pD9weZBuJdFmowNwbpi7BJ8TNftyUImj/0WQi72jY=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngolang.org/x/mod v0.13.0 h1:I/DsJXRlw/8l/0c24sM9yb0T4z9liZTduXvdAWYiysY=\ngolang.org/x/mod v0.13.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/sync v0.4.0 h1:zxkM55ReGkDlKSM+Fu41A+zmbZuaPVbGMzvvdUPznYQ=\ngolang.org/x/sys v0.0.0-20211117180635-dee7805ff2e1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.13.0 h1:Af8nKPmuFypiUBjVoU9V20FiaFXOcuZI21p0ycVYYGE=\ngolang.org/x/sys v0.13.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/tools v0.14.0 h1:jvNa2pY0M4r62jkRQ6RwEZZyPcymeL9XZMLBbV7U2nc=\ngolang.org/x/tools v0.14.0/go.mod h1:uYBEerGOWcJyEORxN+Ek8+TT266gXkNlHdJBwexUsBg=\n"
        },
        {
          "name": "go",
          "type": "tree",
          "content": null
        },
        {
          "name": "imports",
          "type": "tree",
          "content": null
        },
        {
          "name": "issue122_test.go",
          "type": "blob",
          "size": 0.9169921875,
          "content": "/*\n * gomacro - A Go interpreter with Lisp-like macros\n *\n * Copyright (C) 2017-2019 Massimiliano Ghilardi\n *\n *     This Source Code Form is subject to the terms of the Mozilla Public\n *     License, v. 2.0. If a copy of the MPL was not distributed with this\n *     file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n *\n * issue122_test.go\n *\n *  Created on: Jun 25 2022\n *      Author: Massimiliano Ghilardi\n */\n\npackage main\n\nimport (\n\t\"reflect\"\n\n\t\"github.com/cosmos72/gomacro/imports\"\n)\n\ntype Base struct{}\ntype Wrapper struct{ *Base }\n\nfunc (f *Base) IsBase(struct{}) bool {\n\treturn true\n}\n\nfunc (b *Wrapper) IsWrapper() bool {\n\treturn true\n}\n\nfunc init() {\n\timports.Packages[\"test/issue122\"] = imports.Package{\n\t\tTypes: map[string]reflect.Type{\n\t\t\t\"Base\":    reflect.TypeOf((*Base)(nil)).Elem(),\n\t\t\t\"Wrapper\": reflect.TypeOf((*Wrapper)(nil)).Elem(),\n\t\t},\n\t\tWrappers: map[string][]string{\n\t\t\t\"Wrapper\": {\"IsBase\"},\n\t\t},\n\t}\n}\n"
        },
        {
          "name": "main.go",
          "type": "blob",
          "size": 0.6474609375,
          "content": "/*\n * gomacro - A Go interpreter with Lisp-like macros\n *\n * Copyright (C) 2017-2019 Massimiliano Ghilardi\n *\n *     This Source Code Form is subject to the terms of the Mozilla Public\n *     License, v. 2.0. If a copy of the MPL was not distributed with this\n *     file, You can obtain one at http://mozilla.org/MPL/2.0/.\n *\n *\n * main.go\n *\n *  Created on: Feb 13, 2017\n *      Author: Massimiliano Ghilardi\n */\n\npackage main\n\nimport (\n\t\"os\"\n\n\t\"github.com/cosmos72/gomacro/cmd\"\n)\n\nfunc main() {\n\targs := os.Args[1:]\n\n\tcmd := cmd.New()\n\n\terr := cmd.Main(args)\n\tif err != nil {\n\t\to := &cmd.Interp.Comp.Output\n\t\to.Fprintf(o.Stderr, \"%s\\n\", err)\n\t\tos.Exit(1)\n\t}\n}\n"
        },
        {
          "name": "xreflect",
          "type": "tree",
          "content": null
        }
      ]
    }
  ]
}