{
  "metadata": {
    "timestamp": 1736566713999,
    "page": 265,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "olahol/melody",
      "stars": 3818,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.046875,
          "content": ".DS_Store\nbenchmark\n*.swp\ncoverage.out\nMakefile\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 0.8876953125,
          "content": "## 2022-09-12 (v1.1.0)\n\n* Create Go module.\n* Update examples.\n* Fix concurrent panic (PR-65).\n* Add `Sessions` to get all sessions (PR-53).\n* Add `LocalAddr` and `RemoteAddr` (PR-55).\n\n## 2017-05-18\n\n* Fix `HandleSentMessageBinary`.\n\n## 2017-04-11\n\n* Allow any origin by default.\n* Add `BroadcastMultiple`.\n\n## 2017-04-09\n\n* Add control message support.\n* Add `IsClosed` to Session.\n\n## 2017-02-10\n\n* Return errors for some exposed methods.\n* Add `HandleRequestWithKeys`.\n* Add `HandleSentMessage` and `HandleSentMessageBinary`.\n\n## 2017-01-20\n\n* Add `Len()` to fetch number of connected sessions.\n\n## 2016-12-09\n\n* Add metadata management for sessions.\n\n## 2016-05-09\n\n* Add method `HandlePong` to melody instance.\n\n## 2015-10-07\n\n* Add broadcast methods for binary messages.\n\n## 2015-09-03\n\n* Add `Close` method to melody instance.\n\n### 2015-06-10\n\n* Support for binary messages.\n* BroadcastOthers method.\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2666015625,
          "content": "Copyright (c) 2015 Ola Holmström. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n  Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n\n  Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 3.3740234375,
          "content": "# melody\n\n![Build Status](https://github.com/olahol/melody/actions/workflows/test.yml/badge.svg)\n[![Codecov](https://img.shields.io/codecov/c/github/olahol/melody)](https://app.codecov.io/github/olahol/melody)\n[![Go Report Card](https://goreportcard.com/badge/github.com/olahol/melody)](https://goreportcard.com/report/github.com/olahol/melody)\n[![GoDoc](https://godoc.org/github.com/olahol/melody?status.svg)](https://godoc.org/github.com/olahol/melody)\n\n> :notes: Minimalist websocket framework for Go.\n\nMelody is websocket framework based on [github.com/gorilla/websocket](https://github.com/gorilla/websocket)\nthat abstracts away the tedious parts of handling websockets. It gets out of\nyour way so you can write real-time apps. Features include:\n\n* [x] Clear and easy interface similar to `net/http` or Gin.\n* [x] A simple way to broadcast to all or selected connected sessions.\n* [x] Message buffers making concurrent writing safe.\n* [x] Automatic handling of sending ping/pong heartbeats that timeout broken sessions.\n* [x] Store data on sessions.\n\n## Install\n\n```bash\ngo get github.com/olahol/melody\n```\n\n## [Example: chat](https://github.com/olahol/melody/tree/master/examples/chat)\n\n[![Chat](https://cdn.rawgit.com/olahol/melody/master/examples/chat/demo.gif \"Demo\")](https://github.com/olahol/melody/tree/master/examples/chat)\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/olahol/melody\"\n)\n\nfunc main() {\n\tm := melody.New()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"index.html\")\n\t})\n\n\thttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\tm.HandleRequest(w, r)\n\t})\n\n\tm.HandleMessage(func(s *melody.Session, msg []byte) {\n\t\tm.Broadcast(msg)\n\t})\n\n\thttp.ListenAndServe(\":5000\", nil)\n}\n```\n\n## [Example: gophers](https://github.com/olahol/melody/tree/master/examples/gophers)\n\n[![Gophers](https://cdn.rawgit.com/olahol/melody/master/examples/gophers/demo.gif \"Demo\")](https://github.com/olahol/melody/tree/master/examples/gophers)\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"sync/atomic\"\n\n\t\"github.com/olahol/melody\"\n)\n\nvar idCounter atomic.Int64\n\nfunc main() {\n\tm := melody.New()\n\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\thttp.ServeFile(w, r, \"index.html\")\n\t})\n\n\thttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n\t\tm.HandleRequest(w, r)\n\t})\n\n\tm.HandleConnect(func(s *melody.Session) {\n\t\tid := idCounter.Add(1)\n\n\t\ts.Set(\"id\", id)\n\n\t\ts.Write([]byte(fmt.Sprintf(\"iam %d\", id)))\n\t})\n\n\tm.HandleDisconnect(func(s *melody.Session) {\n\t\tif id, ok := s.Get(\"id\"); ok {\n\t\t\tm.BroadcastOthers([]byte(fmt.Sprintf(\"dis %d\", id)), s)\n\t\t}\n\t})\n\n\tm.HandleMessage(func(s *melody.Session, msg []byte) {\n\t\tif id, ok := s.Get(\"id\"); ok {\n\t\t\tm.BroadcastOthers([]byte(fmt.Sprintf(\"set %d %s\", id, msg)), s)\n\t\t}\n\t})\n\n\thttp.ListenAndServe(\":5000\", nil)\n}\n```\n\n### [More examples](https://github.com/olahol/melody/tree/master/examples)\n\n## [Documentation](https://godoc.org/github.com/olahol/melody)\n\n## Contributors\n\n<a href=\"https://github.com/olahol/melody/graphs/contributors\">\n\t<img src=\"https://contrib.rocks/image?repo=olahol/melody\" />\n</a>\n\n## FAQ\n\nIf you are getting a `403` when trying  to connect to your websocket you can [change allow all origin hosts](http://godoc.org/github.com/gorilla/websocket#hdr-Origin_Considerations):\n\n```go\nm := melody.New()\nm.Upgrader.CheckOrigin = func(r *http.Request) bool { return true }\n```\n"
        },
        {
          "name": "config.go",
          "type": "blob",
          "size": 0.8134765625,
          "content": "package melody\n\nimport \"time\"\n\n// Config melody configuration struct.\ntype Config struct {\n\tWriteWait                 time.Duration // Duration until write times out.\n\tPongWait                  time.Duration // Timeout for waiting on pong.\n\tPingPeriod                time.Duration // Duration between pings.\n\tMaxMessageSize            int64         // Maximum size in bytes of a message.\n\tMessageBufferSize         int           // The max amount of messages that can be in a sessions buffer before it starts dropping them.\n\tConcurrentMessageHandling bool          // Handle messages from sessions concurrently.\n}\n\nfunc newConfig() *Config {\n\treturn &Config{\n\t\tWriteWait:         10 * time.Second,\n\t\tPongWait:          60 * time.Second,\n\t\tPingPeriod:        54 * time.Second,\n\t\tMaxMessageSize:    512,\n\t\tMessageBufferSize: 256,\n\t}\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.5703125,
          "content": "// Copyright 2015 Ola Holmström. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// Package melody implements a framework for dealing with WebSockets.\n//\n// Example\n//\n// A broadcasting echo server:\n//\n//  func main() {\n//  \tm := melody.New()\n//  \thttp.HandleFunc(\"/ws\", func(w http.ResponseWriter, r *http.Request) {\n//  \t\tm.HandleRequest(w, r)\n//  \t})\n//  \tm.HandleMessage(func(s *melody.Session, msg []byte) {\n//  \t\tm.Broadcast(msg)\n//  \t})\n//  \thttp.ListenAndServe(\":5000\", nil)\n//  }\n\npackage melody\n"
        },
        {
          "name": "envelope.go",
          "type": "blob",
          "size": 0.0849609375,
          "content": "package melody\n\ntype envelope struct {\n\tt      int\n\tmsg    []byte\n\tfilter filterFunc\n}\n"
        },
        {
          "name": "errors.go",
          "type": "blob",
          "size": 0.2958984375,
          "content": "package melody\n\nimport \"errors\"\n\nvar (\n\tErrClosed            = errors.New(\"melody instance is closed\")\n\tErrSessionClosed     = errors.New(\"session is closed\")\n\tErrWriteClosed       = errors.New(\"tried to write to closed a session\")\n\tErrMessageBufferFull = errors.New(\"session message buffer is full\")\n)\n"
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 0.267578125,
          "content": "module github.com/olahol/melody\n\ngo 1.19\n\nrequire (\n\tgithub.com/gorilla/websocket v1.5.0\n\tgithub.com/stretchr/testify v1.8.0\n)\n\nrequire (\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 1.48046875,
          "content": "github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/gorilla/websocket v1.5.0 h1:PPwGk2jz7EePpoHN/+ClbZu8SPxiqlu12wZP/3sWmnc=\ngithub.com/gorilla/websocket v1.5.0/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=\ngithub.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.8.0 h1:pSgiaMZlXftHpm5L7V1+rVB+AZJydKsMxsQBIJw4PKk=\ngithub.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405 h1:yhCVgyC4o1eVCa2tZl7eS0r+SDo693bJlVdllGtEeKM=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "hub.go",
          "type": "blob",
          "size": 1.9345703125,
          "content": "package melody\n\nimport (\n\t\"sync\"\n\t\"sync/atomic\"\n)\n\ntype sessionSet struct {\n\tmu      sync.RWMutex\n\tmembers map[*Session]struct{}\n}\n\nfunc (ss *sessionSet) add(s *Session) {\n\tss.mu.Lock()\n\tdefer ss.mu.Unlock()\n\n\tss.members[s] = struct{}{}\n}\n\nfunc (ss *sessionSet) del(s *Session) {\n\tss.mu.Lock()\n\tdefer ss.mu.Unlock()\n\n\tdelete(ss.members, s)\n}\n\nfunc (ss *sessionSet) clear() {\n\tss.mu.Lock()\n\tdefer ss.mu.Unlock()\n\n\tss.members = make(map[*Session]struct{})\n}\n\nfunc (ss *sessionSet) each(cb func(*Session)) {\n\tss.mu.RLock()\n\tdefer ss.mu.RUnlock()\n\n\tfor s := range ss.members {\n\t\tcb(s)\n\t}\n}\n\nfunc (ss *sessionSet) len() int {\n\tss.mu.RLock()\n\tdefer ss.mu.RUnlock()\n\n\treturn len(ss.members)\n}\n\nfunc (ss *sessionSet) all() []*Session {\n\tss.mu.RLock()\n\tdefer ss.mu.RUnlock()\n\n\ts := make([]*Session, 0, len(ss.members))\n\tfor k := range ss.members {\n\t\ts = append(s, k)\n\t}\n\n\treturn s\n}\n\ntype hub struct {\n\tsessions   sessionSet\n\tbroadcast  chan envelope\n\tregister   chan *Session\n\tunregister chan *Session\n\texit       chan envelope\n\topen       atomic.Bool\n}\n\nfunc newHub() *hub {\n\treturn &hub{\n\t\tsessions: sessionSet{\n\t\t\tmembers: make(map[*Session]struct{}),\n\t\t},\n\t\tbroadcast:  make(chan envelope),\n\t\tregister:   make(chan *Session),\n\t\tunregister: make(chan *Session),\n\t\texit:       make(chan envelope),\n\t}\n}\n\nfunc (h *hub) run() {\n\th.open.Store(true)\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase s := <-h.register:\n\t\t\th.sessions.add(s)\n\t\tcase s := <-h.unregister:\n\t\t\th.sessions.del(s)\n\t\tcase m := <-h.broadcast:\n\t\t\th.sessions.each(func(s *Session) {\n\t\t\t\tif m.filter == nil {\n\t\t\t\t\ts.writeMessage(m)\n\t\t\t\t} else if m.filter(s) {\n\t\t\t\t\ts.writeMessage(m)\n\t\t\t\t}\n\t\t\t})\n\t\tcase m := <-h.exit:\n\t\t\th.open.Store(false)\n\n\t\t\th.sessions.each(func(s *Session) {\n\t\t\t\ts.writeMessage(m)\n\t\t\t\ts.Close()\n\t\t\t})\n\n\t\t\th.sessions.clear()\n\n\t\t\tbreak loop\n\t\t}\n\t}\n}\n\nfunc (h *hub) closed() bool {\n\treturn !h.open.Load()\n}\n\nfunc (h *hub) len() int {\n\treturn h.sessions.len()\n}\n\nfunc (h *hub) all() []*Session {\n\treturn h.sessions.all()\n}\n"
        },
        {
          "name": "melody.go",
          "type": "blob",
          "size": 8.6904296875,
          "content": "package melody\n\nimport (\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// Close codes defined in RFC 6455, section 11.7.\n// Duplicate of codes from gorilla/websocket for convenience.\nconst (\n\tCloseNormalClosure           = 1000\n\tCloseGoingAway               = 1001\n\tCloseProtocolError           = 1002\n\tCloseUnsupportedData         = 1003\n\tCloseNoStatusReceived        = 1005\n\tCloseAbnormalClosure         = 1006\n\tCloseInvalidFramePayloadData = 1007\n\tClosePolicyViolation         = 1008\n\tCloseMessageTooBig           = 1009\n\tCloseMandatoryExtension      = 1010\n\tCloseInternalServerErr       = 1011\n\tCloseServiceRestart          = 1012\n\tCloseTryAgainLater           = 1013\n\tCloseTLSHandshake            = 1015\n)\n\ntype handleMessageFunc func(*Session, []byte)\ntype handleErrorFunc func(*Session, error)\ntype handleCloseFunc func(*Session, int, string) error\ntype handleSessionFunc func(*Session)\ntype filterFunc func(*Session) bool\n\n// Melody implements a websocket manager.\ntype Melody struct {\n\tConfig                   *Config\n\tUpgrader                 *websocket.Upgrader\n\tmessageHandler           handleMessageFunc\n\tmessageHandlerBinary     handleMessageFunc\n\tmessageSentHandler       handleMessageFunc\n\tmessageSentHandlerBinary handleMessageFunc\n\terrorHandler             handleErrorFunc\n\tcloseHandler             handleCloseFunc\n\tconnectHandler           handleSessionFunc\n\tdisconnectHandler        handleSessionFunc\n\tpongHandler              handleSessionFunc\n\thub                      *hub\n}\n\n// New creates a new melody instance with default Upgrader and Config.\nfunc New() *Melody {\n\tupgrader := &websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin:     func(r *http.Request) bool { return true },\n\t}\n\n\thub := newHub()\n\n\tgo hub.run()\n\n\treturn &Melody{\n\t\tConfig:                   newConfig(),\n\t\tUpgrader:                 upgrader,\n\t\tmessageHandler:           func(*Session, []byte) {},\n\t\tmessageHandlerBinary:     func(*Session, []byte) {},\n\t\tmessageSentHandler:       func(*Session, []byte) {},\n\t\tmessageSentHandlerBinary: func(*Session, []byte) {},\n\t\terrorHandler:             func(*Session, error) {},\n\t\tcloseHandler:             nil,\n\t\tconnectHandler:           func(*Session) {},\n\t\tdisconnectHandler:        func(*Session) {},\n\t\tpongHandler:              func(*Session) {},\n\t\thub:                      hub,\n\t}\n}\n\n// HandleConnect fires fn when a session connects.\nfunc (m *Melody) HandleConnect(fn func(*Session)) {\n\tm.connectHandler = fn\n}\n\n// HandleDisconnect fires fn when a session disconnects.\nfunc (m *Melody) HandleDisconnect(fn func(*Session)) {\n\tm.disconnectHandler = fn\n}\n\n// HandlePong fires fn when a pong is received from a session.\nfunc (m *Melody) HandlePong(fn func(*Session)) {\n\tm.pongHandler = fn\n}\n\n// HandleMessage fires fn when a text message comes in.\n// NOTE: by default Melody handles messages sequentially for each\n// session. This has the effect that a message handler exceeding the\n// read deadline (Config.PongWait, by default 1 minute) will time out\n// the session. Concurrent message handling can be turned on by setting\n// Config.ConcurrentMessageHandling to true.\nfunc (m *Melody) HandleMessage(fn func(*Session, []byte)) {\n\tm.messageHandler = fn\n}\n\n// HandleMessageBinary fires fn when a binary message comes in.\nfunc (m *Melody) HandleMessageBinary(fn func(*Session, []byte)) {\n\tm.messageHandlerBinary = fn\n}\n\n// HandleSentMessage fires fn when a text message is successfully sent.\nfunc (m *Melody) HandleSentMessage(fn func(*Session, []byte)) {\n\tm.messageSentHandler = fn\n}\n\n// HandleSentMessageBinary fires fn when a binary message is successfully sent.\nfunc (m *Melody) HandleSentMessageBinary(fn func(*Session, []byte)) {\n\tm.messageSentHandlerBinary = fn\n}\n\n// HandleError fires fn when a session has an error.\nfunc (m *Melody) HandleError(fn func(*Session, error)) {\n\tm.errorHandler = fn\n}\n\n// HandleClose sets the handler for close messages received from the session.\n// The code argument to h is the received close code or CloseNoStatusReceived\n// if the close message is empty. The default close handler sends a close frame\n// back to the session.\n//\n// The application must read the connection to process close messages as\n// described in the section on Control Frames above.\n//\n// The connection read methods return a CloseError when a close frame is\n// received. Most applications should handle close messages as part of their\n// normal error handling. Applications should only set a close handler when the\n// application must perform some action before sending a close frame back to\n// the session.\nfunc (m *Melody) HandleClose(fn func(*Session, int, string) error) {\n\tif fn != nil {\n\t\tm.closeHandler = fn\n\t}\n}\n\n// HandleRequest upgrades http requests to websocket connections and dispatches them to be handled by the melody instance.\nfunc (m *Melody) HandleRequest(w http.ResponseWriter, r *http.Request) error {\n\treturn m.HandleRequestWithKeys(w, r, nil)\n}\n\n// HandleRequestWithKeys does the same as HandleRequest but populates session.Keys with keys.\nfunc (m *Melody) HandleRequestWithKeys(w http.ResponseWriter, r *http.Request, keys map[string]any) error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tconn, err := m.Upgrader.Upgrade(w, r, w.Header())\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tsession := &Session{\n\t\tRequest:    r,\n\t\tKeys:       keys,\n\t\tconn:       conn,\n\t\toutput:     make(chan envelope, m.Config.MessageBufferSize),\n\t\toutputDone: make(chan struct{}),\n\t\tmelody:     m,\n\t\topen:       true,\n\t\trwmutex:    &sync.RWMutex{},\n\t}\n\n\tm.hub.register <- session\n\n\tm.connectHandler(session)\n\n\tgo session.writePump()\n\n\tsession.readPump()\n\n\tif !m.hub.closed() {\n\t\tm.hub.unregister <- session\n\t}\n\n\tsession.close()\n\n\tm.disconnectHandler(session)\n\n\treturn nil\n}\n\n// Broadcast broadcasts a text message to all sessions.\nfunc (m *Melody) Broadcast(msg []byte) error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tmessage := envelope{t: websocket.TextMessage, msg: msg}\n\tm.hub.broadcast <- message\n\n\treturn nil\n}\n\n// BroadcastFilter broadcasts a text message to all sessions that fn returns true for.\nfunc (m *Melody) BroadcastFilter(msg []byte, fn func(*Session) bool) error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tmessage := envelope{t: websocket.TextMessage, msg: msg, filter: fn}\n\tm.hub.broadcast <- message\n\n\treturn nil\n}\n\n// BroadcastOthers broadcasts a text message to all sessions except session s.\nfunc (m *Melody) BroadcastOthers(msg []byte, s *Session) error {\n\treturn m.BroadcastFilter(msg, func(q *Session) bool {\n\t\treturn s != q\n\t})\n}\n\n// BroadcastMultiple broadcasts a text message to multiple sessions given in the sessions slice.\nfunc (m *Melody) BroadcastMultiple(msg []byte, sessions []*Session) error {\n\tfor _, sess := range sessions {\n\t\tif writeErr := sess.Write(msg); writeErr != nil {\n\t\t\treturn writeErr\n\t\t}\n\t}\n\treturn nil\n}\n\n// BroadcastBinary broadcasts a binary message to all sessions.\nfunc (m *Melody) BroadcastBinary(msg []byte) error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tmessage := envelope{t: websocket.BinaryMessage, msg: msg}\n\tm.hub.broadcast <- message\n\n\treturn nil\n}\n\n// BroadcastBinaryFilter broadcasts a binary message to all sessions that fn returns true for.\nfunc (m *Melody) BroadcastBinaryFilter(msg []byte, fn func(*Session) bool) error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tmessage := envelope{t: websocket.BinaryMessage, msg: msg, filter: fn}\n\tm.hub.broadcast <- message\n\n\treturn nil\n}\n\n// BroadcastBinaryOthers broadcasts a binary message to all sessions except session s.\nfunc (m *Melody) BroadcastBinaryOthers(msg []byte, s *Session) error {\n\treturn m.BroadcastBinaryFilter(msg, func(q *Session) bool {\n\t\treturn s != q\n\t})\n}\n\n// Sessions returns all sessions. An error is returned if the melody session is closed.\nfunc (m *Melody) Sessions() ([]*Session, error) {\n\tif m.hub.closed() {\n\t\treturn nil, ErrClosed\n\t}\n\treturn m.hub.all(), nil\n}\n\n// Close closes the melody instance and all connected sessions.\nfunc (m *Melody) Close() error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tm.hub.exit <- envelope{t: websocket.CloseMessage, msg: []byte{}}\n\n\treturn nil\n}\n\n// CloseWithMsg closes the melody instance with the given close payload and all connected sessions.\n// Use the FormatCloseMessage function to format a proper close message payload.\nfunc (m *Melody) CloseWithMsg(msg []byte) error {\n\tif m.hub.closed() {\n\t\treturn ErrClosed\n\t}\n\n\tm.hub.exit <- envelope{t: websocket.CloseMessage, msg: msg}\n\n\treturn nil\n}\n\n// Len return the number of connected sessions.\nfunc (m *Melody) Len() int {\n\treturn m.hub.len()\n}\n\n// IsClosed returns the status of the melody instance.\nfunc (m *Melody) IsClosed() bool {\n\treturn m.hub.closed()\n}\n\n// FormatCloseMessage formats closeCode and text as a WebSocket close message.\nfunc FormatCloseMessage(closeCode int, text string) []byte {\n\treturn websocket.FormatCloseMessage(closeCode, text)\n}\n"
        },
        {
          "name": "melody_test.go",
          "type": "blob",
          "size": 15.712890625,
          "content": "package melody\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"net/http/httptest\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"testing\"\n\t\"testing/quick\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\nvar TestMsg = []byte(\"test\")\n\ntype TestServer struct {\n\twithKeys bool\n\tm        *Melody\n}\n\nfunc NewTestServerHandler(handler handleMessageFunc) *TestServer {\n\tm := New()\n\tm.HandleMessage(handler)\n\treturn &TestServer{\n\t\tm: m,\n\t}\n}\n\nfunc NewTestServer() *TestServer {\n\tm := New()\n\treturn &TestServer{\n\t\tm: m,\n\t}\n}\n\nfunc (s *TestServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tif s.withKeys {\n\t\ts.m.HandleRequestWithKeys(w, r, make(map[string]any))\n\t} else {\n\t\ts.m.HandleRequest(w, r)\n\t}\n}\n\nfunc NewDialer(url string) (*websocket.Conn, error) {\n\tdialer := &websocket.Dialer{}\n\tconn, _, err := dialer.Dial(strings.Replace(url, \"http\", \"ws\", 1), nil)\n\treturn conn, err\n}\n\nfunc MustNewDialer(url string) *websocket.Conn {\n\tconn, err := NewDialer(url)\n\n\tif err != nil {\n\t\tpanic(\"could not dail websocket\")\n\t}\n\n\treturn conn\n}\n\nfunc TestEcho(t *testing.T) {\n\tws := NewTestServerHandler(func(session *Session, msg []byte) {\n\t\tsession.Write(msg)\n\t})\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tfn := func(msg string) bool {\n\t\tconn := MustNewDialer(server.URL)\n\t\tdefer conn.Close()\n\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\n\t\t_, ret, err := conn.ReadMessage()\n\n\t\tassert.Nil(t, err)\n\n\t\tassert.Equal(t, msg, string(ret))\n\n\t\treturn true\n\t}\n\n\terr := quick.Check(fn, nil)\n\n\tassert.Nil(t, err)\n}\n\nfunc TestEchoBinary(t *testing.T) {\n\tws := NewTestServerHandler(func(session *Session, msg []byte) {\n\t\tsession.WriteBinary(msg)\n\t})\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tfn := func(msg string) bool {\n\t\tconn := MustNewDialer(server.URL)\n\t\tdefer conn.Close()\n\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\n\t\t_, ret, err := conn.ReadMessage()\n\n\t\tassert.Nil(t, err)\n\n\t\tassert.True(t, bytes.Equal([]byte(msg), ret))\n\n\t\treturn true\n\t}\n\n\terr := quick.Check(fn, nil)\n\n\tassert.Nil(t, err)\n}\n\nfunc TestWriteClosedServer(t *testing.T) {\n\tdone := make(chan bool)\n\n\tws := NewTestServer()\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tws.m.HandleConnect(func(s *Session) {\n\t\ts.Close()\n\t})\n\n\tws.m.HandleDisconnect(func(s *Session) {\n\t\terr := s.Write(TestMsg)\n\n\t\tassert.NotNil(t, err)\n\t\tclose(done)\n\t})\n\n\tconn := MustNewDialer(server.URL)\n\tconn.ReadMessage()\n\tdefer conn.Close()\n\n\t<-done\n}\n\nfunc TestWriteClosedClient(t *testing.T) {\n\tdone := make(chan bool)\n\n\tws := NewTestServer()\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tws.m.HandleDisconnect(func(s *Session) {\n\t\terr := s.Write(TestMsg)\n\n\t\tassert.NotNil(t, err)\n\t\tclose(done)\n\t})\n\n\tconn := MustNewDialer(server.URL)\n\tconn.Close()\n\n\t<-done\n}\n\nfunc TestUpgrader(t *testing.T) {\n\tws := NewTestServer()\n\tws.m.HandleMessage(func(session *Session, msg []byte) {\n\t\tsession.Write(msg)\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tws.m.Upgrader = &websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin:     func(r *http.Request) bool { return false },\n\t}\n\n\t_, err := NewDialer(server.URL)\n\n\tassert.ErrorIs(t, err, websocket.ErrBadHandshake)\n}\n\nfunc TestBroadcast(t *testing.T) {\n\tn := 10\n\tmsg := \"test\"\n\n\ttest := func(h func(*TestServer), w func(*websocket.Conn)) {\n\n\t\tws := NewTestServer()\n\n\t\th(ws)\n\n\t\tserver := httptest.NewServer(ws)\n\t\tdefer server.Close()\n\n\t\tconn := MustNewDialer(server.URL)\n\t\tdefer conn.Close()\n\n\t\tlisteners := make([]*websocket.Conn, n)\n\t\tfor i := range listeners {\n\t\t\tlistener := MustNewDialer(server.URL)\n\t\t\tlisteners[i] = listener\n\t\t\tdefer listeners[i].Close()\n\t\t}\n\n\t\tw(conn)\n\n\t\tfor _, listener := range listeners {\n\t\t\t_, ret, err := listener.ReadMessage()\n\n\t\t\tassert.Nil(t, err)\n\n\t\t\tassert.Equal(t, msg, string(ret))\n\t\t}\n\t}\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessage(func(s *Session, msg []byte) {\n\t\t\tws.m.Broadcast(msg)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t})\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessageBinary(func(s *Session, msg []byte) {\n\t\t\tws.m.BroadcastBinary(msg)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.BinaryMessage, []byte(msg))\n\t})\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessage(func(s *Session, msg []byte) {\n\t\t\tws.m.BroadcastFilter(msg, func(s *Session) bool {\n\t\t\t\treturn true\n\t\t\t})\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t})\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessageBinary(func(s *Session, msg []byte) {\n\t\t\tws.m.BroadcastBinaryFilter(msg, func(s *Session) bool {\n\t\t\t\treturn true\n\t\t\t})\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.BinaryMessage, []byte(msg))\n\t})\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessage(func(s *Session, msg []byte) {\n\t\t\tws.m.BroadcastOthers(msg, s)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t})\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessageBinary(func(s *Session, msg []byte) {\n\t\t\tws.m.BroadcastBinaryOthers(msg, s)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.BinaryMessage, []byte(msg))\n\t})\n\n\ttest(func(ws *TestServer) {\n\t\tws.m.HandleMessage(func(s *Session, msg []byte) {\n\t\t\tss, _ := ws.m.Sessions()\n\t\t\tws.m.BroadcastMultiple(msg, ss)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\t})\n}\n\nfunc TestClose(t *testing.T) {\n\tws := NewTestServer()\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tn := 10\n\n\tconns := make([]*websocket.Conn, n)\n\tfor i := range conns {\n\t\tconn := MustNewDialer(server.URL)\n\t\tconns[i] = conn\n\t\tdefer conns[i].Close()\n\t}\n\n\tq := make(chan bool)\n\tws.m.HandleDisconnect(func(s *Session) {\n\t\tq <- true\n\t})\n\n\tws.m.Close()\n\n\tfor _, conn := range conns {\n\t\tconn.ReadMessage()\n\t}\n\n\tassert.Zero(t, ws.m.Len())\n\n\tm := 0\n\tfor range q {\n\t\tm += 1\n\t\tif m == n {\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc TestLen(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\n\tconnect := int(rand.Int31n(100))\n\tdisconnect := rand.Float32()\n\tconns := make([]*websocket.Conn, connect)\n\n\tdefer func() {\n\t\tfor _, conn := range conns {\n\t\t\tif conn != nil {\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\tws := NewTestServer()\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tdisconnected := 0\n\tfor i := 0; i < connect; i++ {\n\t\tconn := MustNewDialer(server.URL)\n\n\t\tif rand.Float32() < disconnect {\n\t\t\tconns[i] = nil\n\t\t\tdisconnected++\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tconns[i] = conn\n\t}\n\n\ttime.Sleep(time.Millisecond)\n\n\tconnected := connect - disconnected\n\n\tassert.Equal(t, ws.m.Len(), connected)\n}\n\nfunc TestSessions(t *testing.T) {\n\trand.Seed(time.Now().UnixNano())\n\n\tconnect := int(rand.Int31n(100))\n\tdisconnect := rand.Float32()\n\tconns := make([]*websocket.Conn, connect)\n\tdefer func() {\n\t\tfor _, conn := range conns {\n\t\t\tif conn != nil {\n\t\t\t\tconn.Close()\n\t\t\t}\n\t\t}\n\t}()\n\n\tws := NewTestServer()\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tdisconnected := 0\n\tfor i := 0; i < connect; i++ {\n\t\tconn, err := NewDialer(server.URL)\n\n\t\tif err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\n\t\tif rand.Float32() < disconnect {\n\t\t\tconns[i] = nil\n\t\t\tdisconnected++\n\t\t\tconn.Close()\n\t\t\tcontinue\n\t\t}\n\n\t\tconns[i] = conn\n\t}\n\n\ttime.Sleep(time.Millisecond)\n\n\tconnected := connect - disconnected\n\n\tss, err := ws.m.Sessions()\n\n\tassert.Nil(t, err)\n\n\tassert.Equal(t, len(ss), connected)\n}\n\nfunc TestPingPong(t *testing.T) {\n\tdone := make(chan bool)\n\n\tws := NewTestServer()\n\tws.m.Config.PingPeriod = time.Millisecond\n\n\tws.m.HandlePong(func(s *Session) {\n\t\tclose(done)\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\tgo conn.NextReader()\n\n\t<-done\n}\n\nfunc TestHandleClose(t *testing.T) {\n\tdone := make(chan bool)\n\n\tws := NewTestServer()\n\tws.m.Config.PingPeriod = time.Millisecond\n\n\tws.m.HandleClose(func(s *Session, code int, text string) error {\n\t\tclose(done)\n\t\treturn nil\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\n\tconn.WriteMessage(websocket.CloseMessage, nil)\n\n\t<-done\n}\n\nfunc TestHandleError(t *testing.T) {\n\tdone := make(chan bool)\n\n\tws := NewTestServer()\n\n\tws.m.HandleError(func(s *Session, err error) {\n\t\tvar closeError *websocket.CloseError\n\t\tassert.ErrorAs(t, err, &closeError)\n\t\tclose(done)\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\n\tconn.Close()\n\n\t<-done\n}\n\nfunc TestHandleErrorWrite(t *testing.T) {\n\twriteError := make(chan struct{})\n\tdisconnect := make(chan struct{})\n\n\tws := NewTestServer()\n\tws.m.Config.WriteWait = 0\n\n\tws.m.HandleConnect(func(s *Session) {\n\t\terr := s.Write(TestMsg)\n\t\tassert.Nil(t, err)\n\t})\n\n\tws.m.HandleError(func(s *Session, err error) {\n\t\tassert.NotNil(t, err)\n\n\t\tif os.IsTimeout(err) {\n\t\t\tclose(writeError)\n\t\t}\n\t})\n\n\tws.m.HandleDisconnect(func(s *Session) {\n\t\tclose(disconnect)\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\tgo conn.NextReader()\n\n\t<-writeError\n\t<-disconnect\n}\n\nfunc TestErrClosed(t *testing.T) {\n\tres := make(chan *Session)\n\n\tws := NewTestServer()\n\n\tws.m.HandleConnect(func(s *Session) {\n\t\tws.m.CloseWithMsg(TestMsg)\n\t})\n\n\tws.m.HandleDisconnect(func(s *Session) {\n\t\tres <- s\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\tgo conn.ReadMessage()\n\n\ts := <-res\n\n\tassert.True(t, s.IsClosed())\n\tassert.True(t, ws.m.IsClosed())\n\t_, err := ws.m.Sessions()\n\tassert.ErrorIs(t, err, ErrClosed)\n\tassert.ErrorIs(t, ws.m.Close(), ErrClosed)\n\tassert.ErrorIs(t, ws.m.CloseWithMsg(TestMsg), ErrClosed)\n\n\tassert.ErrorIs(t, ws.m.Broadcast(TestMsg), ErrClosed)\n\tassert.ErrorIs(t, ws.m.BroadcastBinary(TestMsg), ErrClosed)\n\tassert.ErrorIs(t, ws.m.BroadcastFilter(TestMsg, func(s *Session) bool { return true }), ErrClosed)\n\tassert.ErrorIs(t, ws.m.BroadcastBinaryFilter(TestMsg, func(s *Session) bool { return true }), ErrClosed)\n\tassert.ErrorIs(t, ws.m.HandleRequest(nil, nil), ErrClosed)\n}\n\nfunc TestErrSessionClosed(t *testing.T) {\n\tres := make(chan *Session)\n\n\tws := NewTestServer()\n\n\tws.m.HandleConnect(func(s *Session) {\n\t\ts.CloseWithMsg(TestMsg)\n\t})\n\n\tws.m.HandleDisconnect(func(s *Session) {\n\t\tres <- s\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\tgo conn.ReadMessage()\n\n\ts := <-res\n\n\tassert.True(t, s.IsClosed())\n\tassert.ErrorIs(t, s.Write(TestMsg), ErrSessionClosed)\n\tassert.ErrorIs(t, s.WriteBinary(TestMsg), ErrSessionClosed)\n\tassert.ErrorIs(t, s.CloseWithMsg(TestMsg), ErrSessionClosed)\n\tassert.ErrorIs(t, s.Close(), ErrSessionClosed)\n\tassert.ErrorIs(t, ws.m.BroadcastMultiple(TestMsg, []*Session{s}), ErrSessionClosed)\n\n\tassert.ErrorIs(t, s.writeRaw(envelope{}), ErrWriteClosed)\n\ts.writeMessage(envelope{})\n}\n\nfunc TestErrMessageBufferFull(t *testing.T) {\n\tdone := make(chan bool)\n\n\tws := NewTestServerHandler(func(session *Session, msg []byte) {\n\t\tsession.Write(msg)\n\t\tsession.Write(msg)\n\t})\n\tws.m.Config.MessageBufferSize = 0\n\tws.m.HandleError(func(s *Session, err error) {\n\t\tif errors.Is(err, ErrMessageBufferFull) {\n\t\t\tclose(done)\n\t\t}\n\t})\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\tconn.WriteMessage(websocket.TextMessage, TestMsg)\n\n\t<-done\n}\n\nfunc TestSessionKeys(t *testing.T) {\n\tws := NewTestServer()\n\n\tws.m.HandleConnect(func(session *Session) {\n\t\tsession.Set(\"stamp\", time.Now().UnixNano())\n\t})\n\tws.m.HandleMessage(func(session *Session, msg []byte) {\n\t\tstamp := session.MustGet(\"stamp\").(int64)\n\t\tsession.Write([]byte(strconv.Itoa(int(stamp))))\n\t})\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tfn := func(msg string) bool {\n\t\tconn := MustNewDialer(server.URL)\n\t\tdefer conn.Close()\n\n\t\tconn.WriteMessage(websocket.TextMessage, []byte(msg))\n\n\t\t_, ret, err := conn.ReadMessage()\n\n\t\tassert.Nil(t, err)\n\n\t\tstamp, err := strconv.Atoi(string(ret))\n\n\t\tassert.Nil(t, err)\n\n\t\tdiff := int(time.Now().UnixNano()) - stamp\n\n\t\tassert.Greater(t, diff, 0)\n\n\t\treturn true\n\t}\n\n\tassert.Nil(t, quick.Check(fn, nil))\n}\n\nfunc TestSessionKeysConcurrent(t *testing.T) {\n\tss := make(chan *Session)\n\n\tws := NewTestServer()\n\n\tws.m.HandleConnect(func(s *Session) {\n\t\tss <- s\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\ts := <-ss\n\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\n\t\tgo func() {\n\t\t\ts.Set(\"test\", TestMsg)\n\n\t\t\tv1, exists := s.Get(\"test\")\n\n\t\t\tassert.True(t, exists)\n\t\t\tassert.Equal(t, v1, TestMsg)\n\n\t\t\tv2 := s.MustGet(\"test\")\n\n\t\t\tassert.Equal(t, v1, v2)\n\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\twg.Wait()\n\n\tfor i := 0; i < 100; i++ {\n\t\twg.Add(1)\n\n\t\tgo func() {\n\t\t\ts.UnSet(\"test\")\n\n\t\t\t_, exists := s.Get(\"test\")\n\n\t\t\tassert.False(t, exists)\n\n\t\t\twg.Done()\n\t\t}()\n\t}\n\n\twg.Wait()\n}\n\nfunc TestMisc(t *testing.T) {\n\tres := make(chan *Session)\n\n\tws := NewTestServer()\n\n\tws.m.HandleConnect(func(s *Session) {\n\t\tres <- s\n\t})\n\n\tserver := httptest.NewServer(ws)\n\tdefer server.Close()\n\n\tconn := MustNewDialer(server.URL)\n\tdefer conn.Close()\n\n\tgo conn.ReadMessage()\n\n\ts := <-res\n\n\tassert.Contains(t, s.LocalAddr().String(), \"127.0.0.1\")\n\tassert.Contains(t, s.RemoteAddr().String(), \"127.0.0.1\")\n\tassert.Equal(t, FormatCloseMessage(websocket.CloseMessage, \"test\"), websocket.FormatCloseMessage(websocket.CloseMessage, \"test\"))\n\tassert.Panics(t, func() {\n\t\ts.MustGet(\"test\")\n\t})\n}\n\nfunc TestHandleSentMessage(t *testing.T) {\n\ttest := func(h func(*TestServer, chan bool), w func(*websocket.Conn)) {\n\t\tdone := make(chan bool)\n\n\t\tws := NewTestServer()\n\t\tserver := httptest.NewServer(ws)\n\t\tdefer server.Close()\n\n\t\th(ws, done)\n\n\t\tconn := MustNewDialer(server.URL)\n\t\tdefer conn.Close()\n\n\t\tw(conn)\n\n\t\t<-done\n\t}\n\n\ttest(func(ws *TestServer, done chan bool) {\n\t\tws.m.HandleMessage(func(s *Session, msg []byte) {\n\t\t\ts.Write(msg)\n\t\t})\n\n\t\tws.m.HandleSentMessage(func(s *Session, msg []byte) {\n\t\t\tassert.Equal(t, TestMsg, msg)\n\t\t\tclose(done)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.TextMessage, TestMsg)\n\t})\n\n\ttest(func(ws *TestServer, done chan bool) {\n\t\tws.m.HandleMessageBinary(func(s *Session, msg []byte) {\n\t\t\ts.WriteBinary(msg)\n\t\t})\n\n\t\tws.m.HandleSentMessageBinary(func(s *Session, msg []byte) {\n\t\t\tassert.Equal(t, TestMsg, msg)\n\t\t\tclose(done)\n\t\t})\n\t}, func(conn *websocket.Conn) {\n\t\tconn.WriteMessage(websocket.BinaryMessage, TestMsg)\n\t})\n}\n\nfunc TestConcurrentMessageHandling(t *testing.T) {\n\ttestTimeout := func(cmh bool, msgType int) bool {\n\t\tbase := time.Millisecond * 100\n\t\tdone := make(chan struct{})\n\n\t\thandler := func(s *Session, msg []byte) {\n\t\t\tif len(msg) == 0 {\n\t\t\t\tdone <- struct{}{}\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\ttime.Sleep(base * 2)\n\t\t}\n\n\t\tws := NewTestServerHandler(func(session *Session, msg []byte) {})\n\t\tif msgType == websocket.TextMessage {\n\t\t\tws.m.HandleMessage(handler)\n\t\t} else {\n\t\t\tws.m.HandleMessageBinary(handler)\n\t\t}\n\n\t\tws.m.Config.ConcurrentMessageHandling = cmh\n\t\tws.m.Config.PongWait = base\n\n\t\tvar errorSet atomic.Bool\n\t\tws.m.HandleError(func(s *Session, err error) {\n\t\t\terrorSet.Store(true)\n\t\t\tdone <- struct{}{}\n\t\t})\n\n\t\tserver := httptest.NewServer(ws)\n\t\tdefer server.Close()\n\n\t\tconn := MustNewDialer(server.URL)\n\t\tdefer conn.Close()\n\n\t\tconn.WriteMessage(msgType, TestMsg)\n\t\tconn.WriteMessage(msgType, TestMsg)\n\n\t\ttime.Sleep(base / 4)\n\n\t\tconn.WriteMessage(msgType, nil)\n\n\t\t<-done\n\n\t\treturn errorSet.Load()\n\t}\n\n\tt.Run(\"text should error\", func(t *testing.T) {\n\t\terrorSet := testTimeout(false, websocket.TextMessage)\n\n\t\tif !errorSet {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n\n\tt.Run(\"text should not error\", func(t *testing.T) {\n\t\terrorSet := testTimeout(true, websocket.TextMessage)\n\n\t\tif errorSet {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n\n\tt.Run(\"binary should error\", func(t *testing.T) {\n\t\terrorSet := testTimeout(false, websocket.BinaryMessage)\n\n\t\tif !errorSet {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n\n\tt.Run(\"binary should not error\", func(t *testing.T) {\n\t\terrorSet := testTimeout(true, websocket.BinaryMessage)\n\n\t\tif errorSet {\n\t\t\tt.FailNow()\n\t\t}\n\t})\n}\n"
        },
        {
          "name": "session.go",
          "type": "blob",
          "size": 5.201171875,
          "content": "package melody\n\nimport (\n\t\"net\"\n\t\"net/http\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\n// Session wrapper around websocket connections.\ntype Session struct {\n\tRequest    *http.Request\n\tKeys       map[string]any\n\tconn       *websocket.Conn\n\toutput     chan envelope\n\toutputDone chan struct{}\n\tmelody     *Melody\n\topen       bool\n\trwmutex    *sync.RWMutex\n}\n\nfunc (s *Session) writeMessage(message envelope) {\n\tif s.closed() {\n\t\ts.melody.errorHandler(s, ErrWriteClosed)\n\t\treturn\n\t}\n\n\tselect {\n\tcase s.output <- message:\n\tdefault:\n\t\ts.melody.errorHandler(s, ErrMessageBufferFull)\n\t}\n}\n\nfunc (s *Session) writeRaw(message envelope) error {\n\tif s.closed() {\n\t\treturn ErrWriteClosed\n\t}\n\n\ts.conn.SetWriteDeadline(time.Now().Add(s.melody.Config.WriteWait))\n\terr := s.conn.WriteMessage(message.t, message.msg)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (s *Session) closed() bool {\n\ts.rwmutex.RLock()\n\tdefer s.rwmutex.RUnlock()\n\n\treturn !s.open\n}\n\nfunc (s *Session) close() {\n\ts.rwmutex.Lock()\n\topen := s.open\n\ts.open = false\n\ts.rwmutex.Unlock()\n\tif open {\n\t\ts.conn.Close()\n\t\tclose(s.outputDone)\n\t}\n}\n\nfunc (s *Session) ping() {\n\ts.writeRaw(envelope{t: websocket.PingMessage, msg: []byte{}})\n}\n\nfunc (s *Session) writePump() {\n\tticker := time.NewTicker(s.melody.Config.PingPeriod)\n\tdefer ticker.Stop()\n\nloop:\n\tfor {\n\t\tselect {\n\t\tcase msg := <-s.output:\n\t\t\terr := s.writeRaw(msg)\n\n\t\t\tif err != nil {\n\t\t\t\ts.melody.errorHandler(s, err)\n\t\t\t\tbreak loop\n\t\t\t}\n\n\t\t\tif msg.t == websocket.CloseMessage {\n\t\t\t\tbreak loop\n\t\t\t}\n\n\t\t\tif msg.t == websocket.TextMessage {\n\t\t\t\ts.melody.messageSentHandler(s, msg.msg)\n\t\t\t}\n\n\t\t\tif msg.t == websocket.BinaryMessage {\n\t\t\t\ts.melody.messageSentHandlerBinary(s, msg.msg)\n\t\t\t}\n\t\tcase <-ticker.C:\n\t\t\ts.ping()\n\t\tcase _, ok := <-s.outputDone:\n\t\t\tif !ok {\n\t\t\t\tbreak loop\n\t\t\t}\n\t\t}\n\t}\n\n\ts.close()\n}\n\nfunc (s *Session) readPump() {\n\ts.conn.SetReadLimit(s.melody.Config.MaxMessageSize)\n\ts.conn.SetReadDeadline(time.Now().Add(s.melody.Config.PongWait))\n\n\ts.conn.SetPongHandler(func(string) error {\n\t\ts.conn.SetReadDeadline(time.Now().Add(s.melody.Config.PongWait))\n\t\ts.melody.pongHandler(s)\n\t\treturn nil\n\t})\n\n\tif s.melody.closeHandler != nil {\n\t\ts.conn.SetCloseHandler(func(code int, text string) error {\n\t\t\treturn s.melody.closeHandler(s, code, text)\n\t\t})\n\t}\n\n\tfor {\n\t\tt, message, err := s.conn.ReadMessage()\n\n\t\tif err != nil {\n\t\t\ts.melody.errorHandler(s, err)\n\t\t\tbreak\n\t\t}\n\n\t\tif s.melody.Config.ConcurrentMessageHandling {\n\t\t\tgo s.handleMessage(t, message)\n\t\t} else {\n\t\t\ts.handleMessage(t, message)\n\t\t}\n\t}\n}\n\nfunc (s *Session) handleMessage(t int, message []byte) {\n\tswitch t {\n\tcase websocket.TextMessage:\n\t\ts.melody.messageHandler(s, message)\n\tcase websocket.BinaryMessage:\n\t\ts.melody.messageHandlerBinary(s, message)\n\t}\n}\n\n// Write writes message to session.\nfunc (s *Session) Write(msg []byte) error {\n\tif s.closed() {\n\t\treturn ErrSessionClosed\n\t}\n\n\ts.writeMessage(envelope{t: websocket.TextMessage, msg: msg})\n\n\treturn nil\n}\n\n// WriteBinary writes a binary message to session.\nfunc (s *Session) WriteBinary(msg []byte) error {\n\tif s.closed() {\n\t\treturn ErrSessionClosed\n\t}\n\n\ts.writeMessage(envelope{t: websocket.BinaryMessage, msg: msg})\n\n\treturn nil\n}\n\n// Close closes session.\nfunc (s *Session) Close() error {\n\tif s.closed() {\n\t\treturn ErrSessionClosed\n\t}\n\n\ts.writeMessage(envelope{t: websocket.CloseMessage, msg: []byte{}})\n\n\treturn nil\n}\n\n// CloseWithMsg closes the session with the provided payload.\n// Use the FormatCloseMessage function to format a proper close message payload.\nfunc (s *Session) CloseWithMsg(msg []byte) error {\n\tif s.closed() {\n\t\treturn ErrSessionClosed\n\t}\n\n\ts.writeMessage(envelope{t: websocket.CloseMessage, msg: msg})\n\n\treturn nil\n}\n\n// Set is used to store a new key/value pair exclusively for this session.\n// It also lazy initializes s.Keys if it was not used previously.\nfunc (s *Session) Set(key string, value any) {\n\ts.rwmutex.Lock()\n\tdefer s.rwmutex.Unlock()\n\n\tif s.Keys == nil {\n\t\ts.Keys = make(map[string]any)\n\t}\n\n\ts.Keys[key] = value\n}\n\n// Get returns the value for the given key, ie: (value, true).\n// If the value does not exists it returns (nil, false)\nfunc (s *Session) Get(key string) (value any, exists bool) {\n\ts.rwmutex.RLock()\n\tdefer s.rwmutex.RUnlock()\n\n\tif s.Keys != nil {\n\t\tvalue, exists = s.Keys[key]\n\t}\n\n\treturn\n}\n\n// MustGet returns the value for the given key if it exists, otherwise it panics.\nfunc (s *Session) MustGet(key string) any {\n\tif value, exists := s.Get(key); exists {\n\t\treturn value\n\t}\n\n\tpanic(\"Key \\\"\" + key + \"\\\" does not exist\")\n}\n\n// UnSet will delete the key and has no return value\nfunc (s *Session) UnSet(key string) {\n\ts.rwmutex.Lock()\n\tdefer s.rwmutex.Unlock()\n\tif s.Keys != nil {\n\t\tdelete(s.Keys, key)\n\t}\n}\n\n// IsClosed returns the status of the connection.\nfunc (s *Session) IsClosed() bool {\n\treturn s.closed()\n}\n\n// LocalAddr returns the local addr of the connection.\nfunc (s *Session) LocalAddr() net.Addr {\n\treturn s.conn.LocalAddr()\n}\n\n// RemoteAddr returns the remote addr of the connection.\nfunc (s *Session) RemoteAddr() net.Addr {\n\treturn s.conn.RemoteAddr()\n}\n\n// WebsocketConnection returns the underlying websocket connection.\n// This can be used to e.g. set/read additional websocket options or to write sychronous messages.\nfunc (s *Session) WebsocketConnection() *websocket.Conn {\n\treturn s.conn\n}\n"
        }
      ]
    }
  ]
}