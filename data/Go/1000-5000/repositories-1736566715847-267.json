{
  "metadata": {
    "timestamp": 1736566715847,
    "page": 267,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjI3MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "charmbracelet/wish",
      "stars": 3814,
      "defaultBranch": "main",
      "files": [
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.1826171875,
          "content": "examples/bubbletea/bubbletea\nexamples/bubbletea/.ssh\nexamples/git/git\nexamples/git/.ssh\nexamples/git/.repos\n.repos\n.ssh\ncoverage.txt\nid_ed25519\nid_ed25519.pub\n\n# MacOS specific\n.DS_Store\n"
        },
        {
          "name": ".golangci.yml",
          "type": "blob",
          "size": 0.6318359375,
          "content": "run:\n  tests: false\n\nissues:\n  include:\n    - EXC0001\n    - EXC0005\n    - EXC0011\n    - EXC0012\n    - EXC0013\n\n  max-issues-per-linter: 0\n  max-same-issues: 0\n\nlinters:\n  enable:\n    - bodyclose\n    - depguard\n    - dupl\n    - exportloopref\n    - goconst\n    - godot\n    - godox\n    - gofumpt\n    - goimports\n    - goprintffuncname\n    - gosec\n    - misspell\n    - prealloc\n    - revive\n    - rowserrcheck\n    - sqlclosecheck\n    - unconvert\n    - unparam\n    - whitespace\n\nlinters-settings:\n  depguard:\n    rules:\n      main:\n        deny:\n          - pkg: \"github.com/gliderlabs/ssh\"\n            desc: \"use github.com/charmbracelet/ssh instead\"\n"
        },
        {
          "name": ".goreleaser.yml",
          "type": "blob",
          "size": 0.1640625,
          "content": "# yaml-language-server: $schema=https://goreleaser.com/static/schema-pro.json\nversion: 2\nincludes:\n  - from_url:\n      url: charmbracelet/meta/main/goreleaser-lib.yaml\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.0546875,
          "content": "MIT License\n\nCopyright (c) 2019-2023 Charmbracelet, Inc\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.265625,
          "content": "# Wish\n\n<p>\n    <img style=\"width: 247px\" src=\"https://stuff.charm.sh/wish/wish-header.png\" alt=\"A nice rendering of a star, anthropomorphized somewhat by means of a smile, with the words ‚ÄòCharm Wish‚Äô next to it\">\n    <br>\n    <a href=\"https://github.com/charmbracelet/wish/releases\"><img src=\"https://img.shields.io/github/release/charmbracelet/wish.svg\" alt=\"Latest Release\"></a>\n    <a href=\"https://pkg.go.dev/github.com/charmbracelet/wish?tab=doc\"><img src=\"https://godoc.org/github.com/golang/gddo?status.svg\" alt=\"GoDoc\"></a>\n    <a href=\"https://github.com/charmbracelet/wish/actions\"><img src=\"https://github.com/charmbracelet/wish/workflows/Build/badge.svg\" alt=\"Build Status\"></a>\n    <a href=\"https://codecov.io/gh/charmbracelet/wish\"><img alt=\"Codecov branch\" src=\"https://img.shields.io/codecov/c/github/charmbracelet/wish/main.svg\"></a>\n    <a href=\"https://goreportcard.com/report/github.com/charmbracelet/wish\"><img alt=\"Go Report Card\" src=\"https://goreportcard.com/badge/github.com/charmbracelet/wish\"></a>\n</p>\n\n\nMake SSH apps, just like that! üí´\n\nSSH is an excellent platform for building remotely accessible applications. It\noffers:\n* secure communication without the hassle of HTTPS certificates\n* user identification with SSH keys\n* access from any terminal\n\nPowerful protocols like Git work over SSH and you can even render TUIs directly over an SSH connection.\n\nWish is an SSH server with sensible defaults and a collection of middlewares that\nmakes building SSH apps really easy. Wish is built on [gliderlabs/ssh][gliderlabs/ssh]\nand should be easy to integrate into any existing projects.\n\n## What are SSH Apps?\n\nUsually, when we think about SSH, we think about remote shell access into servers,\nmost commonly through `openssh-server`.\n\nThat's a perfectly valid (and probably the most common) use of SSH, but it can do so much more than that.\nJust like HTTP, SMTP, FTP and others, SSH is a protocol!\nIt is a cryptographic network protocol for operating network services securely over an unsecured network. [^1]\n\n[^1]: https://en.wikipedia.org/wiki/Secure_Shell\n\nThat means, among other things, that we can write custom SSH servers without touching `openssh-server`,\nso we can securely do more things than just providing a shell.\n\nWish is a library that helps writing these kind of apps using Go.\n\n## Middleware\n\nWish middlewares are analogous to those in several HTTP frameworks.\nThey are essentially SSH handlers that you can use to do specific tasks,\nand then call the next middleware.\n\nNotice that middlewares are composed from first to last,\nwhich means the last one is executed first.\n\n### Bubble Tea\n\nThe [`bubbletea`](bubbletea) middleware makes it easy to serve any\n[Bubble Tea][bubbletea] application over SSH. Each SSH session will get their own\n`tea.Program` with the SSH pty input and output connected. Client window\ndimension and resize messages are also natively handled by the `tea.Program`.\n\nYou can see a demo of the Wish middleware in action at: `ssh git.charm.sh`\n\n### Git\n\nThe [`git`](git) middleware adds `git` server functionality to any ssh server.\nIt supports repo creation on initial push and custom public key based auth.\n\nThis middleware requires that `git` is installed on the server.\n\n### Logging\n\nThe [`logging`](logging)  middleware provides basic connection logging. Connects\nare logged with the remote address, invoked command, TERM setting, window\ndimensions and if the auth was public key based. Disconnect will log the remote\naddress and connection duration.\n\n### Access Control\n\nNot all applications will support general SSH connections. To restrict access\nto supported methods, you can use the [`activeterm`](activeterm) middleware to\nonly allow connections with active terminals connected and the\n[`accesscontrol`](accesscontrol) middleware that lets you specify allowed\ncommands.\n\n## Default Server\n\nWish includes the ability to easily create an always authenticating default SSH\nserver with automatic server key generation.\n\n## Examples\n\nThere are examples for a standalone [Bubble Tea application](examples/bubbletea)\nand [Git server](examples/git) in the [examples](examples) folder.\n\n## Apps Built With Wish\n\n* [Soft Serve](https://github.com/charmbracelet/soft-serve)\n* [Wishlist](https://github.com/charmbracelet/wishlist)\n* [SSHWordle](https://github.com/davidcroda/sshwordle)\n* [clidle](https://github.com/ajeetdsouza/clidle)\n* [ssh-warm-welcome](https://git.coopcloud.tech/decentral1se/ssh-warm-welcome)\n\n[bubbletea]: https://github.com/charmbracelet/bubbletea\n[gliderlabs/ssh]: https://github.com/gliderlabs/ssh\n\n## Pro tip\n\nWhen building various Wish applications locally you can add the following to\nyour `~/.ssh/config` to avoid having to clear out `localhost` entries in your\n`~/.ssh/known_hosts` file:\n\n```\nHost localhost\n    UserKnownHostsFile /dev/null\n```\n\n## How it works?\n\nWish uses [gliderlabs/ssh][gliderlabs/ssh] to implement its SSH server, and\nOpenSSH is never used nor needed ‚Äî you can even uninstall it if you want to.\n\nIncidentally, there's no risk of accidentally sharing a shell because there's no\ndefault behavior that does that on Wish.\n\n## Running with SystemD\n\nIf you want to run a Wish app with `systemd`, you can create an unit like so:\n\n`/etc/systemd/system/myapp.service`:\n```service\n[Unit]\nDescription=My App\nAfter=network.target\n\n[Service]\nType=simple\nUser=myapp\nGroup=myapp\nWorkingDirectory=/home/myapp/\nExecStart=/usr/bin/myapp\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\nYou can tune the values below, and once you're happy with them, you can run:\n\n```bash\n# need to run this every time you change the unit file\nsudo systemctl daemon-reload\n\n# start/restart/stop/etc:\nsudo systemctl start myapp\n```\n\nIf you use a new user for each app (which is good), you'll need to create them\nfirst:\n\n```bash\nuseradd --system --user-group --create-home myapp\n```\n\nThat should do it.\n\n###\n\n## Feedback\n\nWe‚Äôd love to hear your thoughts on this project. Feel free to drop us a note!\n\n* [Twitter](https://twitter.com/charmcli)\n* [The Fediverse](https://mastodon.social/@charmcli)\n* [Discord](https://charm.sh/chat)\n\n## License\n\n[MIT](https://github.com/charmbracelet/wish/raw/main/LICENSE)\n\n***\n\nPart of [Charm](https://charm.sh).\n\n<a href=\"https://charm.sh/\"><img alt=\"The Charm logo\" src=\"https://stuff.charm.sh/charm-badge.jpg\" width=\"400\"></a>\n\nCharmÁÉ≠Áà±ÂºÄÊ∫ê ‚Ä¢ Charm loves open source\n"
        },
        {
          "name": "accesscontrol",
          "type": "tree",
          "content": null
        },
        {
          "name": "activeterm",
          "type": "tree",
          "content": null
        },
        {
          "name": "bubbletea",
          "type": "tree",
          "content": null
        },
        {
          "name": "cmd.go",
          "type": "blob",
          "size": 1.7265625,
          "content": "package wish\n\nimport (\n\t\"context\"\n\t\"io\"\n\t\"os/exec\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/ssh\"\n)\n\n// CommandContext is like Command but includes a context.\n//\n// If the current session does not have a PTY, it sets them to the session\n// itself.\nfunc CommandContext(ctx context.Context, s ssh.Session, name string, args ...string) *Cmd {\n\tcmd := exec.CommandContext(ctx, name, args...)\n\treturn &Cmd{s, cmd}\n}\n\n// Command sets stdin, stdout, and stderr to the current session's PTY.\n//\n// If the current session does not have a PTY, it sets them to the session\n// itself.\n//\n// This will use the session's context as the context for exec.Command.\nfunc Command(s ssh.Session, name string, args ...string) *Cmd {\n\treturn CommandContext(s.Context(), s, name, args...)\n}\n\n// Cmd wraps a *exec.Cmd and a ssh.Pty so a command can be properly run.\ntype Cmd struct {\n\tsess ssh.Session\n\tcmd  *exec.Cmd\n}\n\n// SetDir set the underlying exec.Cmd env.\nfunc (c *Cmd) SetEnv(env []string) {\n\tc.cmd.Env = env\n}\n\n// Environ returns the underlying exec.Cmd environment.\nfunc (c *Cmd) Environ() []string {\n\treturn c.cmd.Environ()\n}\n\n// SetDir set the underlying exec.Cmd dir.\nfunc (c *Cmd) SetDir(dir string) {\n\tc.cmd.Dir = dir\n}\n\n// Run runs the program and waits for it to finish.\nfunc (c *Cmd) Run() error {\n\tppty, winCh, ok := c.sess.Pty()\n\tif !ok {\n\t\tc.cmd.Stdin, c.cmd.Stdout, c.cmd.Stderr = c.sess, c.sess, c.sess.Stderr()\n\t\treturn c.cmd.Run()\n\t}\n\treturn c.doRun(ppty, winCh)\n}\n\nvar _ tea.ExecCommand = &Cmd{}\n\n// SetStderr conforms with tea.ExecCommand.\nfunc (*Cmd) SetStderr(io.Writer) {}\n\n// SetStdin conforms with tea.ExecCommand.\nfunc (*Cmd) SetStdin(io.Reader) {}\n\n// SetStdout conforms with tea.ExecCommand.\nfunc (*Cmd) SetStdout(io.Writer) {}\n"
        },
        {
          "name": "cmd_test.go",
          "type": "blob",
          "size": 3.283203125,
          "content": "package wish\n\nimport (\n\t\"bytes\"\n\t\"runtime\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/charmbracelet/wish/testsession\"\n)\n\nfunc TestCommandNoPty(t *testing.T) {\n\ttmp := t.TempDir()\n\tsess := testsession.New(t, &ssh.Server{\n\t\tHandler: func(s ssh.Session) {\n\t\t\trunEcho(s, \"hello\")\n\t\t\trunEnv(s, []string{\"HELLO=world\"})\n\t\t\trunPwd(s, tmp)\n\t\t},\n\t}, nil)\n\tvar stdout bytes.Buffer\n\tvar stderr bytes.Buffer\n\tsess.Stdout = &stdout\n\tsess.Stderr = &stderr\n\tif err := sess.Run(\"\"); err != nil {\n\t\tt.Errorf(\"expected no error, got %v: %s\", err, stderr.String())\n\t}\n\tout := stdout.String()\n\texpectContains(t, out, \"hello\")\n\texpectContains(t, out, \"HELLO=world\")\n\texpectContains(t, out, tmp)\n}\n\nfunc TestCommandPty(t *testing.T) {\n\ttmp := t.TempDir()\n\tsrv := &ssh.Server{\n\t\tHandler: func(s ssh.Session) {\n\t\t\trunEcho(s, \"hello\")\n\t\t\trunEnv(s, []string{\"HELLO=world\"})\n\t\t\trunPwd(s, tmp)\n\t\t\t// for some reason sometimes on macos github action runners,\n\t\t\t// it cuts parts of the output.\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t},\n\t}\n\tif err := ssh.AllocatePty()(srv); err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n\n\tsess := testsession.New(t, srv, nil)\n\tif err := sess.RequestPty(\"xterm\", 500, 200, nil); err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n\n\tvar stdout bytes.Buffer\n\tvar stderr bytes.Buffer\n\tsess.Stdout = &stdout\n\tsess.Stderr = &stderr\n\tif err := sess.Run(\"\"); err != nil {\n\t\tt.Errorf(\"expected no error, got %v: %s\", err, stderr.String())\n\t}\n\tout := stdout.String()\n\texpectContains(t, out, \"hello\")\n\texpectContains(t, out, \"HELLO=world\")\n\texpectContains(t, out, tmp)\n}\n\nfunc TestCommandPtyError(t *testing.T) {\n\tif runtime.GOOS == \"windows\" {\n\t\tt.Skip()\n\t}\n\tsrv := &ssh.Server{\n\t\tHandler: func(s ssh.Session) {\n\t\t\tif err := Command(s, \"nopenopenope\").Run(); err != nil {\n\t\t\t\tFatal(s, err)\n\t\t\t}\n\t\t},\n\t}\n\tif err := ssh.AllocatePty()(srv); err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n\n\tsess := testsession.New(t, srv, nil)\n\tif err := sess.RequestPty(\"xterm\", 500, 200, nil); err != nil {\n\t\tt.Fatalf(\"expected no error, got %v\", err)\n\t}\n\n\tvar stderr bytes.Buffer\n\tsess.Stderr = &stderr\n\tif err := sess.Run(\"\"); err == nil {\n\t\tt.Errorf(\"expected an error, got nil\")\n\t}\n\texpect := `exec: \"nopenopenope\"`\n\tif s := stderr.String(); !strings.Contains(s, expect) {\n\t\tt.Errorf(\"expected output to contain %q, got %q\", expect, s)\n\t}\n}\n\nfunc runEcho(s ssh.Session, str string) {\n\tcmd := Command(s, \"echo\", str)\n\tif runtime.GOOS == \"windows\" {\n\t\tcmd = Command(s, \"cmd\", \"/C\", \"echo\", str)\n\t}\n\t// these should do nothing...\n\tcmd.SetStderr(nil)\n\tcmd.SetStdin(nil)\n\tcmd.SetStdout(nil)\n\tif err := cmd.Run(); err != nil {\n\t\tFatal(s, err)\n\t}\n}\n\nfunc runEnv(s ssh.Session, env []string) {\n\tcmd := Command(s, \"env\")\n\tif runtime.GOOS == \"windows\" {\n\t\tcmd = Command(s, \"cmd\", \"/C\", \"set\")\n\t}\n\tcmd.SetEnv(env)\n\tif err := cmd.Run(); err != nil {\n\t\tFatal(s, err)\n\t}\n\tif len(cmd.Environ()) == 0 {\n\t\tFatal(s, \"cmd.Environ() should not be empty\")\n\t}\n}\n\nfunc runPwd(s ssh.Session, dir string) {\n\tcmd := Command(s, \"pwd\")\n\tif runtime.GOOS == \"windows\" {\n\t\tcmd = Command(s, \"cmd\", \"/C\", \"cd\")\n\t}\n\tcmd.SetDir(dir)\n\tif err := cmd.Run(); err != nil {\n\t\tFatal(s, err)\n\t}\n}\n\nfunc expectContains(tb testing.TB, s, substr string) {\n\tif !strings.Contains(s, substr) {\n\t\ttb.Errorf(\"expected output %q to contain %q\", s, substr)\n\t}\n}\n"
        },
        {
          "name": "cmd_unix.go",
          "type": "blob",
          "size": 0.337890625,
          "content": "//go:build darwin || dragonfly || freebsd || linux || netbsd || openbsd || solaris\n// +build darwin dragonfly freebsd linux netbsd openbsd solaris\n\npackage wish\n\nimport \"github.com/charmbracelet/ssh\"\n\nfunc (c *Cmd) doRun(ppty ssh.Pty, _ <-chan ssh.Window) error {\n\tif err := ppty.Start(c.cmd); err != nil {\n\t\treturn err\n\t}\n\treturn c.cmd.Wait()\n}\n"
        },
        {
          "name": "cmd_windows.go",
          "type": "blob",
          "size": 0.541015625,
          "content": "//go:build windows\n// +build windows\n\npackage wish\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/ssh\"\n)\n\nfunc (c *Cmd) doRun(ppty ssh.Pty, _ <-chan ssh.Window) error {\n\tif err := ppty.Start(c.cmd); err != nil {\n\t\treturn err\n\t}\n\n\tstart := time.Now()\n\tfor c.cmd.ProcessState == nil {\n\t\tif time.Since(start) > time.Second*10 {\n\t\t\treturn fmt.Errorf(\"could not start process\")\n\t\t}\n\t\ttime.Sleep(100 * time.Millisecond)\n\t}\n\tif !c.cmd.ProcessState.Success() {\n\t\treturn fmt.Errorf(\"process failed: exit %d\", c.cmd.ProcessState.ExitCode())\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "comment",
          "type": "tree",
          "content": null
        },
        {
          "name": "elapsed",
          "type": "tree",
          "content": null
        },
        {
          "name": "examples",
          "type": "tree",
          "content": null
        },
        {
          "name": "git",
          "type": "tree",
          "content": null
        },
        {
          "name": "go.mod",
          "type": "blob",
          "size": 2.7041015625,
          "content": "module github.com/charmbracelet/wish\n\ngo 1.21\n\nrequire (\n\tgithub.com/charmbracelet/bubbletea v1.2.4\n\tgithub.com/charmbracelet/keygen v0.5.1\n\tgithub.com/charmbracelet/lipgloss v1.0.0\n\tgithub.com/charmbracelet/log v0.4.0\n\tgithub.com/charmbracelet/ssh v0.0.0-20241211182756-4fe22b0f1b7c\n\tgithub.com/charmbracelet/x/ansi v0.4.5\n\tgithub.com/charmbracelet/x/input v0.2.0\n\tgithub.com/charmbracelet/x/term v0.2.1\n\tgithub.com/go-git/go-git/v5 v5.13.1\n\tgithub.com/google/go-cmp v0.6.0\n\tgithub.com/hashicorp/golang-lru/v2 v2.0.7\n\tgithub.com/lucasb-eyer/go-colorful v1.2.0\n\tgithub.com/matryer/is v1.4.1\n\tgithub.com/muesli/termenv v0.15.3-0.20240509142007-81b8f94111d5\n\tgolang.org/x/crypto v0.32.0\n\tgolang.org/x/sync v0.10.0\n\tgolang.org/x/time v0.9.0\n)\n\nrequire (\n\tdario.cat/mergo v1.0.0 // indirect\n\tgithub.com/Microsoft/go-winio v0.6.1 // indirect\n\tgithub.com/ProtonMail/go-crypto v1.1.3 // indirect\n\tgithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be // indirect\n\tgithub.com/aymanbagabas/go-osc52/v2 v2.0.1 // indirect\n\tgithub.com/charmbracelet/x/conpty v0.1.0 // indirect\n\tgithub.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 // indirect\n\tgithub.com/charmbracelet/x/termios v0.1.0 // indirect\n\tgithub.com/cloudflare/circl v1.3.7 // indirect\n\tgithub.com/creack/pty v1.1.21 // indirect\n\tgithub.com/cyphar/filepath-securejoin v0.3.6 // indirect\n\tgithub.com/emirpasic/gods v1.18.1 // indirect\n\tgithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f // indirect\n\tgithub.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 // indirect\n\tgithub.com/go-git/go-billy/v5 v5.6.1 // indirect\n\tgithub.com/go-logfmt/logfmt v0.6.0 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect\n\tgithub.com/kevinburke/ssh_config v1.2.0 // indirect\n\tgithub.com/mattn/go-isatty v0.0.20 // indirect\n\tgithub.com/mattn/go-localereader v0.0.1 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.15 // indirect\n\tgithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 // indirect\n\tgithub.com/muesli/cancelreader v0.2.2 // indirect\n\tgithub.com/pjbgf/sha1cd v0.3.0 // indirect\n\tgithub.com/rivo/uniseg v0.4.7 // indirect\n\tgithub.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 // indirect\n\tgithub.com/skeema/knownhosts v1.3.0 // indirect\n\tgithub.com/xanzy/ssh-agent v0.3.3 // indirect\n\tgithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e // indirect\n\tgolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 // indirect\n\tgolang.org/x/mod v0.19.0 // indirect\n\tgolang.org/x/net v0.33.0 // indirect\n\tgolang.org/x/sys v0.29.0 // indirect\n\tgolang.org/x/text v0.21.0 // indirect\n\tgolang.org/x/tools v0.23.0 // indirect\n\tgopkg.in/warnings.v0 v0.1.2 // indirect\n)\n"
        },
        {
          "name": "go.sum",
          "type": "blob",
          "size": 14.8642578125,
          "content": "dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=\ndario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=\ngithub.com/Microsoft/go-winio v0.5.2/go.mod h1:WpS1mjBmmwHBEWmogvA2mj8546UReBk4v8QkMxJ6pZY=\ngithub.com/Microsoft/go-winio v0.6.1 h1:9/kr64B9VUZrLm5YYwbGtUJnMgqWVOdUAXu6Migciow=\ngithub.com/Microsoft/go-winio v0.6.1/go.mod h1:LRdKpFKfdobln8UmuiYcKPot9D2v6svN5+sAH+4kjUM=\ngithub.com/ProtonMail/go-crypto v1.1.3 h1:nRBOetoydLeUb4nHajyO2bKqMLfWQ/ZPwkXqXxPxCFk=\ngithub.com/ProtonMail/go-crypto v1.1.3/go.mod h1:rA3QumHc/FZ8pAHreoekgiAbzpNsfQAosU5td4SnOrE=\ngithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be h1:9AeTilPcZAjCFIImctFaOjnTIavg87rW78vTPkQqLI8=\ngithub.com/anmitsu/go-shlex v0.0.0-20200514113438-38f4b401e2be/go.mod h1:ySMOLuWl6zY27l47sB3qLNK6tF2fkHG55UZxx8oIVo4=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1 h1:HwpRHbFMcZLEVr42D4p7XBqjyuxQH5SMiErDT4WkJ2k=\ngithub.com/aymanbagabas/go-osc52/v2 v2.0.1/go.mod h1:uYgXzlJ7ZpABp8OJ+exZzJJhRNQ2ASbcXHWsFqH8hp8=\ngithub.com/charmbracelet/bubbletea v1.2.4 h1:KN8aCViA0eps9SCOThb2/XPIlea3ANJLUkv3KnQRNCE=\ngithub.com/charmbracelet/bubbletea v1.2.4/go.mod h1:Qr6fVQw+wX7JkWWkVyXYk/ZUQ92a6XNekLXa3rR18MM=\ngithub.com/charmbracelet/keygen v0.5.1 h1:zBkkYPtmKDVTw+cwUyY6ZwGDhRxXkEp0Oxs9sqMLqxI=\ngithub.com/charmbracelet/keygen v0.5.1/go.mod h1:zznJVmK/GWB6dAtjluqn2qsttiCBhA5MZSiwb80fcHw=\ngithub.com/charmbracelet/lipgloss v1.0.0 h1:O7VkGDvqEdGi93X+DeqsQ7PKHDgtQfF8j8/O2qFMQNg=\ngithub.com/charmbracelet/lipgloss v1.0.0/go.mod h1:U5fy9Z+C38obMs+T+tJqst9VGzlOYGj4ri9reL3qUlo=\ngithub.com/charmbracelet/log v0.4.0 h1:G9bQAcx8rWA2T3pWvx7YtPTPwgqpk7D68BX21IRW8ZM=\ngithub.com/charmbracelet/log v0.4.0/go.mod h1:63bXt/djrizTec0l11H20t8FDSvA4CRZJ1KH22MdptM=\ngithub.com/charmbracelet/ssh v0.0.0-20241211182756-4fe22b0f1b7c h1:treQxMBdI2PaD4eOYfFux8stfCkUxhuUxaqGcxKqVpI=\ngithub.com/charmbracelet/ssh v0.0.0-20241211182756-4fe22b0f1b7c/go.mod h1:CY1xbl2z+ZeBmNWItKZyxx0zgDgnhmR57+DTsHOobJ4=\ngithub.com/charmbracelet/x/ansi v0.4.5 h1:LqK4vwBNaXw2AyGIICa5/29Sbdq58GbGdFngSexTdRM=\ngithub.com/charmbracelet/x/ansi v0.4.5/go.mod h1:dk73KoMTT5AX5BsX0KrqhsTqAnhZZoCBjs7dGWp4Ktw=\ngithub.com/charmbracelet/x/conpty v0.1.0 h1:4zc8KaIcbiL4mghEON8D72agYtSeIgq8FSThSPQIb+U=\ngithub.com/charmbracelet/x/conpty v0.1.0/go.mod h1:rMFsDJoDwVmiYM10aD4bH2XiRgwI7NYJtQgl5yskjEQ=\ngithub.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86 h1:JSt3B+U9iqk37QUU2Rvb6DSBYRLtWqFqfxf8l5hOZUA=\ngithub.com/charmbracelet/x/errors v0.0.0-20240508181413-e8d8b6e2de86/go.mod h1:2P0UgXMEa6TsToMSuFqKFQR+fZTO9CNGUNokkPatT/0=\ngithub.com/charmbracelet/x/input v0.2.0 h1:1Sv+y/flcqUfUH2PXNIDKDIdT2G8smOnGOgawqhwy8A=\ngithub.com/charmbracelet/x/input v0.2.0/go.mod h1:KUSFIS6uQymtnr5lHVSOK9j8RvwTD4YHnWnzJUYnd/M=\ngithub.com/charmbracelet/x/term v0.2.1 h1:AQeHeLZ1OqSXhrAWpYUtZyX1T3zVxfpZuEQMIQaGIAQ=\ngithub.com/charmbracelet/x/term v0.2.1/go.mod h1:oQ4enTYFV7QN4m0i9mzHrViD7TQKvNEEkHUMCmsxdUg=\ngithub.com/charmbracelet/x/termios v0.1.0 h1:y4rjAHeFksBAfGbkRDmVinMg7x7DELIGAFbdNvxg97k=\ngithub.com/charmbracelet/x/termios v0.1.0/go.mod h1:H/EVv/KRnrYjz+fCYa9bsKdqF3S8ouDK0AZEbG7r+/U=\ngithub.com/cloudflare/circl v1.3.7 h1:qlCDlTPz2n9fu58M0Nh1J/JzcFpfgkFHHX3O35r5vcU=\ngithub.com/cloudflare/circl v1.3.7/go.mod h1:sRTcRWXGLrKw6yIGJ+l7amYJFfAXbZG0kBSc8r4zxgA=\ngithub.com/creack/pty v1.1.21 h1:1/QdRyBaHHJP61QkWMXlOIBfsgdDeeKfK8SYVUWJKf0=\ngithub.com/creack/pty v1.1.21/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=\ngithub.com/cyphar/filepath-securejoin v0.3.6 h1:4d9N5ykBnSp5Xn2JkhocYDkOpURL/18CYMpo6xB9uWM=\ngithub.com/cyphar/filepath-securejoin v0.3.6/go.mod h1:Sdj7gXlvMcPZsbhwhQ33GguGLDGQL7h7bg04C/+u9jI=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/elazarl/goproxy v1.2.3 h1:xwIyKHbaP5yfT6O9KIeYJR5549MXRQkoQMRXGztz8YQ=\ngithub.com/elazarl/goproxy v1.2.3/go.mod h1:YfEbZtqP4AetfO6d40vWchF3znWX7C7Vd6ZMfdL8z64=\ngithub.com/emirpasic/gods v1.18.1 h1:FXtiHYKDGKCW2KzwZKx0iC0PQmdlorYgdFG9jPXJ1Bc=\ngithub.com/emirpasic/gods v1.18.1/go.mod h1:8tpGGwCnJ5H4r6BWwaV6OrWmMoPhUl5jm/FMNAnJvWQ=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f h1:Y/CXytFA4m6baUTXGLOoWe4PQhGxaX0KpnayAqC48p4=\ngithub.com/erikgeiser/coninput v0.0.0-20211004153227-1c3628e74d0f/go.mod h1:vw97MGsxSvLiUE2X8qFplwetxpGLQrlU1Q9AUEIzCaM=\ngithub.com/gliderlabs/ssh v0.3.8 h1:a4YXD1V7xMF9g5nTkdfnja3Sxy1PVDCj1Zg4Wb8vY6c=\ngithub.com/gliderlabs/ssh v0.3.8/go.mod h1:xYoytBv1sV0aL3CavoDuJIQNURXkkfPA/wxQ1pL1fAU=\ngithub.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376 h1:+zs/tPmkDkHx3U66DAb0lQFJrpS6731Oaa12ikc+DiI=\ngithub.com/go-git/gcfg v1.5.1-0.20230307220236-3a3c6141e376/go.mod h1:an3vInlBmSxCcxctByoQdvwPiA7DTK7jaaFDBTtu0ic=\ngithub.com/go-git/go-billy/v5 v5.6.1 h1:u+dcrgaguSSkbjzHwelEjc0Yj300NUevrrPphk/SoRA=\ngithub.com/go-git/go-billy/v5 v5.6.1/go.mod h1:0AsLr1z2+Uksi4NlElmMblP5rPcDZNRCD8ujZCRR2BE=\ngithub.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399 h1:eMje31YglSBqCdIqdhKBW8lokaMrL3uTkpGYlE2OOT4=\ngithub.com/go-git/go-git-fixtures/v4 v4.3.2-0.20231010084843-55a94097c399/go.mod h1:1OCfN199q1Jm3HZlxleg+Dw/mwps2Wbk9frAWm+4FII=\ngithub.com/go-git/go-git/v5 v5.13.1 h1:DAQ9APonnlvSWpvolXWIuV6Q6zXy2wHbN4cVlNR5Q+M=\ngithub.com/go-git/go-git/v5 v5.13.1/go.mod h1:qryJB4cSBoq3FRoBRf5A77joojuBcmPJ0qu3XXXVixc=\ngithub.com/go-logfmt/logfmt v0.6.0 h1:wGYYu3uicYdqXVgoYbvnkrPVXkuLM1p1ifugDMEdRi4=\ngithub.com/go-logfmt/logfmt v0.6.0/go.mod h1:WYhtIu8zTZfxdn5+rREduYbwxfcBr/Vr6KEVveWlfTs=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=\ngithub.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=\ngithub.com/hashicorp/golang-lru/v2 v2.0.7 h1:a+bsQ5rvGLjzHuww6tVxozPZFVghXaHOwFs4luLUK2k=\ngithub.com/hashicorp/golang-lru/v2 v2.0.7/go.mod h1:QeFd9opnmA6QUJc5vARoKUSoFhyfM2/ZepoAG6RGpeM=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=\ngithub.com/kevinburke/ssh_config v1.2.0 h1:x584FjTGwHzMwvHx18PXxbBVzfnxogHaAReU4gf13a4=\ngithub.com/kevinburke/ssh_config v1.2.0/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=\ngithub.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/lucasb-eyer/go-colorful v1.2.0 h1:1nnpGOrhyZZuNyfu1QjKiUICQ74+3FNCN69Aj6K7nkY=\ngithub.com/lucasb-eyer/go-colorful v1.2.0/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/matryer/is v1.4.1 h1:55ehd8zaGABKLXQUe2awZ99BD/PTc2ls+KV/dXphgEQ=\ngithub.com/matryer/is v1.4.1/go.mod h1:8I/i5uYgLzgsgEloJE1U6xx5HkBQpAZvepWuujKwMRU=\ngithub.com/mattn/go-isatty v0.0.20 h1:xfD0iDuEKnDkl03q4limB+vH+GxLEtL/jb4xVJSWWEY=\ngithub.com/mattn/go-isatty v0.0.20/go.mod h1:W+V8PltTTMOvKvAeJH7IuucS94S2C6jfK/D7dTCTo3Y=\ngithub.com/mattn/go-localereader v0.0.1 h1:ygSAOl7ZXTx4RdPYinUpg6W99U8jWvWi9Ye2JC/oIi4=\ngithub.com/mattn/go-localereader v0.0.1/go.mod h1:8fBrzywKY7BI3czFoHkuzRoWE9C+EiG4R1k4Cjx5p88=\ngithub.com/mattn/go-runewidth v0.0.15 h1:UNAjwbU9l54TA3KzvqLGxwWjHmMgBUVhBiTjelZgg3U=\ngithub.com/mattn/go-runewidth v0.0.15/go.mod h1:Jdepj2loyihRzMpdS35Xk/zdY8IAYHsh153qUoGf23w=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6 h1:ZK8zHtRHOkbHy6Mmr5D264iyp3TiX5OmNcI5cIARiQI=\ngithub.com/muesli/ansi v0.0.0-20230316100256-276c6243b2f6/go.mod h1:CJlz5H+gyd6CUWT45Oy4q24RdLyn7Md9Vj2/ldJBSIo=\ngithub.com/muesli/cancelreader v0.2.2 h1:3I4Kt4BQjOR54NavqnDogx/MIoWBFa0StPA8ELUXHmA=\ngithub.com/muesli/cancelreader v0.2.2/go.mod h1:3XuTXfFS2VjM+HTLZY9Ak0l6eUKfijIfMUZ4EgX0QYo=\ngithub.com/muesli/termenv v0.15.3-0.20240509142007-81b8f94111d5 h1:NiONcKK0EV5gUZcnCiPMORaZA0eBDc+Fgepl9xl4lZ8=\ngithub.com/muesli/termenv v0.15.3-0.20240509142007-81b8f94111d5/go.mod h1:hxSnBBYLK21Vtq/PHd0S2FYCxBXzBua8ov5s1RobyRQ=\ngithub.com/onsi/gomega v1.34.1 h1:EUMJIKUjM8sKjYbtxQI9A4z2o+rruxnzNvpknOXie6k=\ngithub.com/onsi/gomega v1.34.1/go.mod h1:kU1QgUvBDLXBJq618Xvm2LUX6rSAfRaFRTcdOeDLwwY=\ngithub.com/pjbgf/sha1cd v0.3.0 h1:4D5XXmUUBUl/xQ6IjCkEAbqXskkq/4O7LmGn0AqMDs4=\ngithub.com/pjbgf/sha1cd v0.3.0/go.mod h1:nZ1rrWOcGJ5uZgEEVL1VUM9iRQiZvWdbZjkKyFzPPsI=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/rivo/uniseg v0.2.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/rivo/uniseg v0.4.7 h1:WUdvkW8uEhrYfLC4ZzdpI2ztxP1I582+49Oc5Mq64VQ=\ngithub.com/rivo/uniseg v0.4.7/go.mod h1:FN3SvrM+Zdj16jyLfmOkMNblXMcoc8DfTHruCPUcx88=\ngithub.com/rogpeppe/go-internal v1.12.0 h1:exVL4IDcn6na9z1rAb56Vxr+CgyK3nn3O+epU5NdKM8=\ngithub.com/rogpeppe/go-internal v1.12.0/go.mod h1:E+RYuTGaKKdloAfM02xzb0FW3Paa99yedzYV+kq4uf4=\ngithub.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3 h1:n661drycOFuPLCN3Uc8sB6B/s6Z4t2xvBgU1htSHuq8=\ngithub.com/sergi/go-diff v1.3.2-0.20230802210424-5b0b94c5c0d3/go.mod h1:A0bzQcvG0E7Rwjx0REVgAGH58e96+X0MeOfepqsbeW4=\ngithub.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/skeema/knownhosts v1.3.0 h1:AM+y0rI04VksttfwjkSTNQorvGqmwATnvnAHpSgc0LY=\ngithub.com/skeema/knownhosts v1.3.0/go.mod h1:sPINvnADmT/qYH1kfv+ePMmOBTH6Tbl7b5LvTDjFK7M=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.10.0 h1:Xv5erBjTwe/5IxqUQTdXv5kgmIvbHo3QQyRwhJsOfJA=\ngithub.com/stretchr/testify v1.10.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=\ngithub.com/xanzy/ssh-agent v0.3.3 h1:+/15pJfg/RsTxqYcX6fHqOXZwwMP+2VyYWJeWM2qQFM=\ngithub.com/xanzy/ssh-agent v0.3.3/go.mod h1:6dzNDKs0J9rVPHPhaGCukekBHKqfl+L3KghI1Bc68Uw=\ngithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e h1:JVG44RsyaB9T2KIHavMF/ppJZNG9ZpyihvCd0w101no=\ngithub.com/xo/terminfo v0.0.0-20220910002029-abceb7e1c41e/go.mod h1:RbqR21r5mrJuqunuUZ/Dhy/avygyECGrLceyNeo4LiM=\ngolang.org/x/crypto v0.0.0-20220622213112-05595931fe9d/go.mod h1:IxCIyHEi3zRg3s0A5j5BB6A9Jmi73HwBIUl50j+osU4=\ngolang.org/x/crypto v0.32.0 h1:euUpcYgM8WcP71gNpTqQCn6rC2t6ULUPiOzfWaXVVfc=\ngolang.org/x/crypto v0.32.0/go.mod h1:ZnnJkOaASj8g0AjIduWNlq2NRxL0PlBrbKVyZ6V/Ugc=\ngolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56 h1:2dVuKD2vS7b0QIHQbpyTISPd0LeHDbnYEryqj5Q1ug8=\ngolang.org/x/exp v0.0.0-20240719175910-8a7402abbf56/go.mod h1:M4RDyNAINzryxdtnbRXRL/OHtkFuWGRjvuhBJpk2IlY=\ngolang.org/x/mod v0.19.0 h1:fEdghXQSo20giMthA7cd28ZC+jts4amQ3YMXiP5oMQ8=\ngolang.org/x/mod v0.19.0/go.mod h1:hTbmBsO62+eylJbnUtE2MGJUyE7QWk4xUqPFrRgJ+7c=\ngolang.org/x/net v0.0.0-20211112202133-69e39bad7dc2/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.33.0 h1:74SYHlV8BIgHIFC/LrYkOGIwL19eTYXQ5wc6TBuO36I=\ngolang.org/x/net v0.33.0/go.mod h1:HXLR5J+9DxmrqMwG9qjGCxZ+zKXxBru04zlTvWlWuN4=\ngolang.org/x/sync v0.10.0 h1:3NQrjDixjgGwUOCaF8w2+VYHv0Ve/vGYSbdkTa98gmQ=\ngolang.org/x/sync v0.10.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.6.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.29.0 h1:TPYlXGxvx1MGTn2GiZDhnjPA9wZzZeGKHHmKhHYvgaU=\ngolang.org/x/sys v0.29.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.28.0 h1:/Ts8HFuMR2E6IP/jlo7QVLZHggjKQbhu/7H0LJFr3Gg=\ngolang.org/x/term v0.28.0/go.mod h1:Sw/lC2IAUZ92udQNf3WodGtn4k/XoLyZoh8v/8uiwek=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.21.0 h1:zyQAAkrwaneQ066sspRyJaG9VNi/YJ1NfzcGB3hZ/qo=\ngolang.org/x/text v0.21.0/go.mod h1:4IBbMaMmOPCJ8SecivzSH54+73PCFmPWxNTLm+vZkEQ=\ngolang.org/x/time v0.9.0 h1:EsRrnYcQiGH+5FfbgvV4AP7qEZstoyrHB0DzarOQ4ZY=\ngolang.org/x/time v0.9.0/go.mod h1:3BpzKBy/shNhVucY/MWOyx10tF3SFh9QdLuxbVysPQM=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.23.0 h1:SGsXPZ+2l4JsgaCKkx+FQ9YZ5XEtA1GZYuoDjenLjvg=\ngolang.org/x/tools v0.23.0/go.mod h1:pnu6ufv6vQkll6szChhK3C3L/ruaIv5eBeztNG8wtsI=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=\ngopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=\ngopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\n"
        },
        {
          "name": "logging",
          "type": "tree",
          "content": null
        },
        {
          "name": "options.go",
          "type": "blob",
          "size": 5.3828125,
          "content": "package wish\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/keygen\"\n\t\"github.com/charmbracelet/log\"\n\t\"github.com/charmbracelet/ssh\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\n// WithAddress returns an ssh.Option that sets the address to listen on.\nfunc WithAddress(addr string) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\ts.Addr = addr\n\t\treturn nil\n\t}\n}\n\n// WithVersion returns an ssh.Option that sets the server version.\nfunc WithVersion(version string) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\ts.Version = version\n\t\treturn nil\n\t}\n}\n\n// WithBanner return an ssh.Option that sets the server banner.\nfunc WithBanner(banner string) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\ts.Banner = banner\n\t\treturn nil\n\t}\n}\n\n// WithBannerHandler return an ssh.Option that sets the server banner handler,\n// overriding WithBanner.\nfunc WithBannerHandler(h ssh.BannerHandler) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\ts.BannerHandler = h\n\t\treturn nil\n\t}\n}\n\n// WithMiddleware composes the provided Middleware and returns an ssh.Option.\n// This is useful if you manually create an ssh.Server and want to set the\n// Server.Handler.\n//\n// Notice that middlewares are composed from first to last, which means the last one is executed first.\nfunc WithMiddleware(mw ...Middleware) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\th := func(ssh.Session) {}\n\t\tfor _, m := range mw {\n\t\t\th = m(h)\n\t\t}\n\t\ts.Handler = h\n\t\treturn nil\n\t}\n}\n\n// WithHostKeyFile returns an ssh.Option that sets the path to the private key.\nfunc WithHostKeyPath(path string) ssh.Option {\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\t_, err := keygen.New(path, keygen.WithKeyType(keygen.Ed25519), keygen.WithWrite())\n\t\tif err != nil {\n\t\t\treturn func(*ssh.Server) error {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\treturn ssh.HostKeyFile(path)\n}\n\n// WithHostKeyPEM returns an ssh.Option that sets the host key from a PEM block.\nfunc WithHostKeyPEM(pem []byte) ssh.Option {\n\treturn ssh.HostKeyPEM(pem)\n}\n\n// WithAuthorizedKeys allows the use of an SSH authorized_keys file to allowlist users.\nfunc WithAuthorizedKeys(path string) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\tif _, err := os.Stat(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn WithPublicKeyAuth(func(_ ssh.Context, key ssh.PublicKey) bool {\n\t\t\treturn isAuthorized(path, func(k ssh.PublicKey) bool {\n\t\t\t\treturn ssh.KeysEqual(key, k)\n\t\t\t})\n\t\t})(s)\n\t}\n}\n\n// WithTrustedUserCAKeys authorize certificates that are signed with the given\n// Certificate Authority public key, and are valid.\n// Analogous to the TrustedUserCAKeys OpenSSH option.\nfunc WithTrustedUserCAKeys(path string) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\tif _, err := os.Stat(path); err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn WithPublicKeyAuth(func(ctx ssh.Context, key ssh.PublicKey) bool {\n\t\t\tcert, ok := key.(*gossh.Certificate)\n\t\t\tif !ok {\n\t\t\t\t// not a certificate...\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\treturn isAuthorized(path, func(k ssh.PublicKey) bool {\n\t\t\t\tchecker := &gossh.CertChecker{\n\t\t\t\t\tIsUserAuthority: func(auth gossh.PublicKey) bool {\n\t\t\t\t\t\t// its a cert signed by one of the CAs\n\t\t\t\t\t\treturn bytes.Equal(auth.Marshal(), k.Marshal())\n\t\t\t\t\t},\n\t\t\t\t}\n\n\t\t\t\tif !checker.IsUserAuthority(cert.SignatureKey) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\tif err := checker.CheckCert(ctx.User(), cert); err != nil {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\n\t\t\t\treturn true\n\t\t\t})\n\t\t})(s)\n\t}\n}\n\nfunc isAuthorized(path string, checker func(k ssh.PublicKey) bool) bool {\n\tf, err := os.Open(path)\n\tif err != nil {\n\t\tlog.Warn(\"failed to parse\", \"path\", path, \"error\", err)\n\t\treturn false\n\t}\n\tdefer f.Close() // nolint: errcheck\n\n\trd := bufio.NewReader(f)\n\tfor {\n\t\tline, _, err := rd.ReadLine()\n\t\tif err != nil {\n\t\t\tif errors.Is(err, io.EOF) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tlog.Warn(\"failed to parse\", \"path\", path, \"error\", err)\n\t\t\treturn false\n\t\t}\n\t\tif strings.TrimSpace(string(line)) == \"\" {\n\t\t\tcontinue\n\t\t}\n\t\tif bytes.HasPrefix(line, []byte{'#'}) {\n\t\t\tcontinue\n\t\t}\n\t\tupk, _, _, _, err := ssh.ParseAuthorizedKey(line)\n\t\tif err != nil {\n\t\t\tlog.Warn(\"failed to parse\", \"path\", path, \"error\", err)\n\t\t\treturn false\n\t\t}\n\t\tif checker(upk) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// WithPublicKeyAuth returns an ssh.Option that sets the public key auth handler.\nfunc WithPublicKeyAuth(h ssh.PublicKeyHandler) ssh.Option {\n\treturn ssh.PublicKeyAuth(h)\n}\n\n// WithPasswordAuth returns an ssh.Option that sets the password auth handler.\nfunc WithPasswordAuth(p ssh.PasswordHandler) ssh.Option {\n\treturn ssh.PasswordAuth(p)\n}\n\n// WithKeyboardInteractiveAuth returns an ssh.Option that sets the keyboard interactive auth handler.\nfunc WithKeyboardInteractiveAuth(h ssh.KeyboardInteractiveHandler) ssh.Option {\n\treturn ssh.KeyboardInteractiveAuth(h)\n}\n\n// WithIdleTimeout returns an ssh.Option that sets the connection's idle timeout.\nfunc WithIdleTimeout(d time.Duration) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\ts.IdleTimeout = d\n\t\treturn nil\n\t}\n}\n\n// WithMaxTimeout returns an ssh.Option that sets the connection's absolute timeout.\nfunc WithMaxTimeout(d time.Duration) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\ts.MaxTimeout = d\n\t\treturn nil\n\t}\n}\n\n// WithSubsystem returns an ssh.Option that sets the subsystem\n// handler for a given protocol.\nfunc WithSubsystem(key string, h ssh.SubsystemHandler) ssh.Option {\n\treturn func(s *ssh.Server) error {\n\t\tif s.SubsystemHandlers == nil {\n\t\t\ts.SubsystemHandlers = map[string]ssh.SubsystemHandler{}\n\t\t}\n\t\ts.SubsystemHandlers[key] = h\n\t\treturn nil\n\t}\n}\n"
        },
        {
          "name": "options_test.go",
          "type": "blob",
          "size": 6.2255859375,
          "content": "package wish\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/charmbracelet/wish/testsession\"\n\tgossh \"golang.org/x/crypto/ssh\"\n)\n\nfunc TestWithSubsystem(t *testing.T) {\n\tsrv := &ssh.Server{\n\t\tHandler: func(s ssh.Session) {},\n\t}\n\trequireNoError(t, WithSubsystem(\"foo\", func(s ssh.Session) {})(srv))\n\tif srv.SubsystemHandlers == nil {\n\t\tt.Fatalf(\"should not have been nil\")\n\t}\n\tif _, ok := srv.SubsystemHandlers[\"foo\"]; !ok {\n\t\tt.Fatalf(\"should have set the foo subsystem handler\")\n\t}\n}\n\nfunc TestWithBanner(t *testing.T) {\n\tconst banner = \"a banner\"\n\tvar got string\n\n\tsrv := &ssh.Server{\n\t\tHandler: func(s ssh.Session) {},\n\t}\n\trequireNoError(t, WithBanner(banner)(srv))\n\n\trequireNoError(t, testsession.New(t, srv, &gossh.ClientConfig{\n\t\tBannerCallback: func(message string) error {\n\t\t\tgot = message\n\t\t\treturn nil\n\t\t},\n\t}).Run(\"\"))\n\trequireEqual(t, banner, got)\n}\n\nfunc TestWithBannerHandler(t *testing.T) {\n\tvar got string\n\n\tsrv := &ssh.Server{\n\t\tHandler: func(s ssh.Session) {},\n\t}\n\trequireNoError(t, WithBannerHandler(func(ctx ssh.Context) string {\n\t\treturn fmt.Sprintf(\"banner for %s\", ctx.User())\n\t})(srv))\n\n\trequireNoError(t, testsession.New(t, srv, &gossh.ClientConfig{\n\t\tUser: \"fulano\",\n\t\tBannerCallback: func(message string) error {\n\t\t\tgot = message\n\t\t\treturn nil\n\t\t},\n\t}).Run(\"\"))\n\trequireEqual(t, \"banner for fulano\", got)\n}\n\nfunc TestWithIdleTimeout(t *testing.T) {\n\ts := ssh.Server{}\n\trequireNoError(t, WithIdleTimeout(time.Second)(&s))\n\trequireEqual(t, time.Second, s.IdleTimeout)\n}\n\nfunc TestWithMaxTimeout(t *testing.T) {\n\ts := ssh.Server{}\n\trequireNoError(t, WithMaxTimeout(time.Second)(&s))\n\trequireEqual(t, time.Second, s.MaxTimeout)\n}\n\nfunc TestIsAuthorized(t *testing.T) {\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\trequireEqual(t, true, isAuthorized(\"testdata/authorized_keys\", func(k ssh.PublicKey) bool { return true }))\n\t})\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\trequireEqual(t, false, isAuthorized(\"testdata/invalid_authorized_keys\", func(k ssh.PublicKey) bool { return true }))\n\t})\n\n\tt.Run(\"file not found\", func(t *testing.T) {\n\t\trequireEqual(t, false, isAuthorized(\"testdata/nope_authorized_keys\", func(k ssh.PublicKey) bool { return true }))\n\t})\n}\n\nfunc TestWithAuthorizedKeys(t *testing.T) {\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\ts := ssh.Server{}\n\t\trequireNoError(t, WithAuthorizedKeys(\"testdata/authorized_keys\")(&s))\n\n\t\tfor key, authorize := range map[string]bool{\n\t\t\t`ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMJlb/qf2B2kMNdBxfpCQqI2ctPcsOkdZGVh5zTRhKtH k3@test`: true,\n\t\t\t`ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOhsthN+zSFSJF7V2HFSO4+2OJYRghuAA43CIbVyvzF8 k7@test`: false,\n\t\t} {\n\t\t\tparts := strings.Fields(key)\n\t\t\tt.Run(parts[len(parts)-1], func(t *testing.T) {\n\t\t\t\tkey, _, _, _, err := ssh.ParseAuthorizedKey([]byte(key))\n\t\t\t\trequireNoError(t, err)\n\t\t\t\trequireEqual(t, authorize, s.PublicKeyHandler(nil, key))\n\t\t\t})\n\t\t}\n\t})\n\n\tt.Run(\"invalid\", func(t *testing.T) {\n\t\ts := ssh.Server{}\n\t\trequireNoError(\n\t\t\tt,\n\t\t\tWithAuthorizedKeys(\"testdata/invalid_authorized_keys\")(&s),\n\t\t)\n\t})\n\n\tt.Run(\"file not found\", func(t *testing.T) {\n\t\ts := ssh.Server{}\n\t\tif err := WithAuthorizedKeys(\"testdata/nope_authorized_keys\")(&s); err == nil {\n\t\t\tt.Fatal(\"expected an error, got nil\")\n\t\t}\n\t})\n}\n\nfunc TestWithTrustedUserCAKeys(t *testing.T) {\n\tsetup := func(tb testing.TB, certPath string) (*ssh.Server, *gossh.ClientConfig) {\n\t\ttb.Helper()\n\t\ts := &ssh.Server{\n\t\t\tHandler: func(s ssh.Session) {\n\t\t\t\tcert, ok := s.PublicKey().(*gossh.Certificate)\n\t\t\t\tfmt.Fprintf(s, \"cert? %v - principals: %v - type: %v\", ok, cert.ValidPrincipals, cert.CertType)\n\t\t\t},\n\t\t}\n\t\trequireNoError(tb, WithTrustedUserCAKeys(\"testdata/ca.pub\")(s))\n\n\t\tsigner, err := gossh.ParsePrivateKey(getBytes(tb, \"testdata/foo\"))\n\t\trequireNoError(tb, err)\n\n\t\tcert, _, _, _, err := gossh.ParseAuthorizedKey(getBytes(tb, certPath))\n\t\trequireNoError(tb, err)\n\n\t\tcertSigner, err := gossh.NewCertSigner(cert.(*gossh.Certificate), signer)\n\t\trequireNoError(tb, err)\n\t\treturn s, &gossh.ClientConfig{\n\t\t\tUser: \"foo\",\n\t\t\tAuth: []gossh.AuthMethod{\n\t\t\t\tgossh.PublicKeys(certSigner),\n\t\t\t},\n\t\t}\n\t}\n\n\tt.Run(\"invalid ca key\", func(t *testing.T) {\n\t\ts := &ssh.Server{}\n\t\tif err := WithTrustedUserCAKeys(\"testdata/invalid-path\")(s); err == nil {\n\t\t\tt.Fatal(\"expected an error, got nil\")\n\t\t}\n\t})\n\n\tt.Run(\"valid\", func(t *testing.T) {\n\t\ts, cc := setup(t, \"testdata/valid-cert.pub\")\n\t\tsess := testsession.New(t, s, cc)\n\t\tvar b bytes.Buffer\n\t\tsess.Stdout = &b\n\t\trequireNoError(t, sess.Run(\"\"))\n\t\trequireEqual(t, \"cert? true - principals: [foo] - type: 1\", b.String())\n\t})\n\n\tt.Run(\"valid wrong principal\", func(t *testing.T) {\n\t\ts, cc := setup(t, \"testdata/valid-cert.pub\")\n\t\tcc.User = \"not-foo\"\n\t\t_, err := testsession.NewClientSession(t, testsession.Listen(t, s), cc)\n\t\trequireAuthError(t, err)\n\t})\n\n\tt.Run(\"expired\", func(t *testing.T) {\n\t\ts, cc := setup(t, \"testdata/expired-cert.pub\")\n\t\t_, err := testsession.NewClientSession(t, testsession.Listen(t, s), cc)\n\t\trequireAuthError(t, err)\n\t})\n\n\tt.Run(\"signed by another ca\", func(t *testing.T) {\n\t\ts, cc := setup(t, \"testdata/another-ca-cert.pub\")\n\t\t_, err := testsession.NewClientSession(t, testsession.Listen(t, s), cc)\n\t\trequireAuthError(t, err)\n\t})\n\n\tt.Run(\"not a cert\", func(t *testing.T) {\n\t\ts := &ssh.Server{\n\t\t\tHandler: func(s ssh.Session) {\n\t\t\t\tfmt.Fprintln(s, \"hello\")\n\t\t\t},\n\t\t}\n\t\trequireNoError(t, WithTrustedUserCAKeys(\"testdata/ca.pub\")(s))\n\n\t\tsigner, err := gossh.ParsePrivateKey(getBytes(t, \"testdata/foo\"))\n\t\trequireNoError(t, err)\n\n\t\t_, err = testsession.NewClientSession(t, testsession.Listen(t, s), &gossh.ClientConfig{\n\t\t\tUser: \"foo\",\n\t\t\tAuth: []gossh.AuthMethod{\n\t\t\t\tgossh.PublicKeys(signer),\n\t\t\t},\n\t\t})\n\t\trequireAuthError(t, err)\n\t})\n}\n\nfunc getBytes(tb testing.TB, path string) []byte {\n\ttb.Helper()\n\tbts, err := os.ReadFile(path)\n\trequireNoError(tb, err)\n\treturn bts\n}\n\nfunc requireEqual(tb testing.TB, a, b interface{}) {\n\ttb.Helper()\n\tif a != b {\n\t\ttb.Fatalf(\"expected %v, got %v\", a, b)\n\t}\n}\n\nfunc requireNoError(tb testing.TB, err error) {\n\ttb.Helper()\n\tif err != nil {\n\t\ttb.Fatalf(\"expected no error, got %v\", err)\n\t}\n}\n\nfunc requireAuthError(tb testing.TB, err error) {\n\tif err == nil {\n\t\ttb.Fatal(\"required an error, got nil\")\n\t}\n\trequireEqual(tb, \"ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain\", err.Error())\n}\n"
        },
        {
          "name": "ratelimiter",
          "type": "tree",
          "content": null
        },
        {
          "name": "recover",
          "type": "tree",
          "content": null
        },
        {
          "name": "scp",
          "type": "tree",
          "content": null
        },
        {
          "name": "testdata",
          "type": "tree",
          "content": null
        },
        {
          "name": "testsession",
          "type": "tree",
          "content": null
        },
        {
          "name": "wish.go",
          "type": "blob",
          "size": 2.775390625,
          "content": "package wish\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/charmbracelet/keygen\"\n\t\"github.com/charmbracelet/ssh\"\n)\n\n// Middleware is a function that takes an ssh.Handler and returns an\n// ssh.Handler. Implementations should call the provided handler argument.\ntype Middleware func(next ssh.Handler) ssh.Handler\n\n// NewServer is returns a default SSH server with the provided Middleware. A\n// new SSH key pair of type ed25519 will be created if one does not exist. By\n// default this server will accept all incoming connections, password and\n// public key.\nfunc NewServer(ops ...ssh.Option) (*ssh.Server, error) {\n\ts := &ssh.Server{}\n\tfor _, op := range ops {\n\t\tif err := s.SetOption(op); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tif len(s.HostSigners) == 0 {\n\t\tk, err := keygen.New(\"id_ed25519\", keygen.WithKeyType(keygen.Ed25519), keygen.WithWrite())\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\terr = s.SetOption(WithHostKeyPEM(k.RawPrivateKey()))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn s, nil\n}\n\n// Fatal prints to the given session's STDERR and exits 1.\nfunc Fatal(s ssh.Session, v ...interface{}) {\n\tError(s, v...)\n\t_ = s.Exit(1)\n\t_ = s.Close()\n}\n\n// Fatalf formats according to the given format, prints to the session's STDERR\n// followed by an exit 1.\n//\n// Notice that this might cause formatting issues if you don't add a \\r\\n in the end of your string.\nfunc Fatalf(s ssh.Session, f string, v ...interface{}) {\n\tErrorf(s, f, v...)\n\t_ = s.Exit(1)\n\t_ = s.Close()\n}\n\n// Fatalln formats according to the default format, prints to the session's\n// STDERR, followed by a new line and an exit 1.\nfunc Fatalln(s ssh.Session, v ...interface{}) {\n\tErrorln(s, v...)\n\tErrorf(s, \"\\r\")\n\t_ = s.Exit(1)\n\t_ = s.Close()\n}\n\n// Error prints the given error the the session's STDERR.\nfunc Error(s ssh.Session, v ...interface{}) {\n\t_, _ = fmt.Fprint(s.Stderr(), v...)\n}\n\n// Errorf formats according to the given format and prints to the session's STDERR.\nfunc Errorf(s ssh.Session, f string, v ...interface{}) {\n\t_, _ = fmt.Fprintf(s.Stderr(), f, v...)\n}\n\n// Errorf formats according to the default format and prints to the session's STDERR.\nfunc Errorln(s ssh.Session, v ...interface{}) {\n\t_, _ = fmt.Fprintln(s.Stderr(), v...)\n}\n\n// Print writes to the session's STDOUT followed.\nfunc Print(s ssh.Session, v ...interface{}) {\n\t_, _ = fmt.Fprint(s, v...)\n}\n\n// Printf formats according to the given format and writes to the session's STDOUT.\nfunc Printf(s ssh.Session, f string, v ...interface{}) {\n\t_, _ = fmt.Fprintf(s, f, v...)\n}\n\n// Println formats according to the default format and writes to the session's STDOUT.\nfunc Println(s ssh.Session, v ...interface{}) {\n\t_, _ = fmt.Fprintln(s, v...)\n}\n\n// WriteString writes the given string to the session's STDOUT.\nfunc WriteString(s ssh.Session, v string) (int, error) {\n\treturn io.WriteString(s, v)\n}\n"
        },
        {
          "name": "wish_test.go",
          "type": "blob",
          "size": 1.466796875,
          "content": "// go:generate mockgen -package mocks -destination mocks/session.go github.com/charmbracelet/ssh Session\npackage wish\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/charmbracelet/ssh\"\n\t\"github.com/charmbracelet/wish/testsession\"\n)\n\nfunc TestNewServer(t *testing.T) {\n\tfp := filepath.Join(t.TempDir(), \"id_ed25519\")\n\t_, err := NewServer(WithHostKeyPath(fp))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestNewServerWithOptions(t *testing.T) {\n\tfp := filepath.Join(t.TempDir(), \"id_ed25519\")\n\tif _, err := NewServer(\n\t\tWithHostKeyPath(fp),\n\t\tWithMaxTimeout(time.Second),\n\t\tWithBanner(\"welcome\"),\n\t\tWithAddress(\":2222\"),\n\t); err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc TestError(t *testing.T) {\n\teerr := errors.New(\"foo err\")\n\tsess := testsession.New(t, &ssh.Server{\n\t\tHandler: func(s ssh.Session) {\n\t\t\tError(s, eerr)\n\t\t},\n\t}, nil)\n\tvar out bytes.Buffer\n\tsess.Stderr = &out\n\tif err := sess.Run(\"\"); err != nil {\n\t\tt.Errorf(\"expected no error, got %s\", err)\n\t}\n\tif s := strings.TrimSpace(out.String()); s != eerr.Error() {\n\t\tt.Errorf(\"expected %s, got %s\", s, eerr)\n\t}\n}\n\nfunc TestFatal(t *testing.T) {\n\terr := errors.New(\"foo err\")\n\tsess := testsession.New(t, &ssh.Server{\n\t\tHandler: func(s ssh.Session) {\n\t\t\tFatal(s, err)\n\t\t},\n\t}, nil)\n\tvar out bytes.Buffer\n\tsess.Stderr = &out\n\tif err := sess.Run(\"\"); err == nil {\n\t\tt.Error(\"expected an error, got nil\")\n\t}\n\tif s := strings.TrimSpace(out.String()); s != err.Error() {\n\t\tt.Errorf(\"expected %s, got %s\", s, err)\n\t}\n}\n"
        }
      ]
    }
  ]
}