{
  "metadata": {
    "timestamp": 1736567097823,
    "page": 689,
    "hasNextPage": true,
    "endCursor": "Y3Vyc29yOjY5MA==",
    "completionStatus": "IN_PROGRESS"
  },
  "repositories": [
    {
      "nameWithOwner": "remind101/empire",
      "stars": 2685,
      "defaultBranch": "master",
      "files": [
        {
          "name": ".bumpversion.cfg",
          "type": "blob",
          "size": 0.2236328125,
          "content": "[bumpversion]\ncurrent_version = 0.13.0\ncommit = True\ntag = False\n\n[bumpversion:file:version.go]\n\n[bumpversion:file:cmd/emp/dev.go]\n\n[bumpversion:file:cmd/emp/README.md]\n\n[bumpversion:file:Dockerfile]\n\n[bumpversion:file:VERSION]\n\n"
        },
        {
          "name": ".circleci",
          "type": "tree",
          "content": null
        },
        {
          "name": ".dockerignore",
          "type": "blob",
          "size": 0.119140625,
          "content": "Godeps/_workspace/src/github.com/fsouza/go-dockerclient/testing/data/symlink\nGodeps/_workspace/pkg\ntests\n.git\nbuild\n.env*\n"
        },
        {
          "name": ".github",
          "type": "tree",
          "content": null
        },
        {
          "name": ".gitignore",
          "type": "blob",
          "size": 0.072265625,
          "content": "build\n.env*\n*.swp\n*.dump\n*.key\n*.cert\n\n# Emacs temporary files\n\\#*\\#\n.\\#*\n"
        },
        {
          "name": "CHANGELOG.md",
          "type": "blob",
          "size": 16.5615234375,
          "content": "# Changelog\n\n## HEAD\n\n**Improvements**\n\n* [cmd/empire] The internal upper bound constraint for CPU shares was removed. [#1124](https://github.com/remind101/empire/pull/1124)\n\n## 0.13.1\n\n**Bugs**\n\n* [cmd/empire] Fixed a bug that caused `emp run` to pull multiple tags at once. [#1112](https://github.com/remind101/empire/pull/1112)\n* [cmd/empire] Fixed a bug that caused `emp run` to lock up. [#1125](https://github.com/remind101/empire/pull/1125)\n\n## 0.13.0\n\n**Features**\n\n* [cmd/empire] Empire now supports a new (experimental) feature to enable attached processes to be ran with ECS. [#1043](https://github.com/remind101/empire/pull/1043)\n* [cmd/emp,cmd/empire] Empire now supports \"maintenance mode\" for applications. [#1086](https://github.com/remind101/empire/pull/1086)\n* [cmd/empire] Added a new configuration option for controlling the generated CloudFormation stack names. [#1094](https://github.com/remind101/empire/pull/1094)\n* [cmd/empire] Empire now supports ECS placement constraints and strategies in the extended Procfile format. [#1059](https://github.com/remind101/empire/pull/1059)\n\n**Bugs**\n\n* [cmd/emp] Fixed a regression in env-load, which caused it to set keys to random values. [#1062](https://github.com/remind101/empire/pull/1062)\n* [cmd/empire] Fixed an issue where the ECS task role was not set on tasks started from `emp run`. [#1063](https://github.com/remind101/empire/pull/1063)\n* [cmd/empire] Fixed a bug that prevented Docker images using a digest as a reference from being deployed. [#1104](https://github.com/remind101/empire/pull/1104)\n\n**Improvements**\n\n* [cmd/empire] Processes can now be scaled down to a negative value to prevent AWS resources from being created. [#1064](https://github.com/remind101/empire/pull/1064)\n* [cmd/empire] AWS resources for scheduled processes are now always created, unless scaled down to a negative value. [#1064](https://github.com/remind101/empire/pull/1064)\n* [cmd/empire] Empire now supports reporting its own errors to [Rollbar](https://rollbar.com) in addition to Honeybadger. [#1075](https://github.com/remind101/empire/pull/1075)\n* [cmd/empire]It's now possible to configure the pool of ports that the `Custom::InstancePort` resource allocates ports from. [#1096](https://github.com/remind101/empire/pull/1096)\n* [cmd/emp] STDOUT and STDERR in `emp run`'s now show up on STDOUT and STDERR in the terminal, instead of being merged on STDOUT. [#1101](https://github.com/remind101/empire/pull/1101)\n\n**Security**\n\n* [cmd/empire] Empire can now automatically resolve a Docker tag to it's immutable content addressable identifier. [#1104](https://github.com/remind101/empire/pull/1104)\n\n## 0.12.0 (2017-03-10)\n\n**Features**\n\n* The extended Procfile format now allows you to attach a load balancer to any process in the Procfile. [#800](https://github.com/remind101/empire/pull/800)\n* An ALIAS record is now created for `<process>.<app>.<zone>` [#1005](https://github.com/remind101/empire/pull/1005)\n* You can now provide a `-p` flag to the `emp cert-attach` command to attach a certificate to a specific process (instead of just `web`). [#1014](https://github.com/remind101/empire/pull/1014)\n* Empire now supports a SAML authentication backend. [#1017](https://github.com/remind101/empire/pull/1017)\n\n**Improvements**\n\n* `emp ps` now displays the task's host. [#983](https://github.com/remind101/empire/pull/983)\n* The `empire` and `emp` binaries are now built with Go 1.7 [#971](https://github.com/remind101/empire/pull/971)\n* `emp env-load` now handles multi-line environment variables. [#990](https://github.com/remind101/empire/pull/990)\n* In preparation for the 0.12 release, the legacy ECS scheduler has been removed. [#1001](https://github.com/remind101/empire/pull/1001)\n* All application labels are set on the CloudFormation stack, rather than just `empire.app.id` and `empire.app.name`. In addition, ALB's will get stack tags applied to them. [#1004](https://github.com/remind101/empire/pull/1004)\n* The lock timeout for CloudFormation stack operations has been increased [#1030](https://github.com/remind101/empire/pull/1030)\n\n**Bugs**\n\n* `emp deploy` will now prompt for a commit message if one is required but not provided. [#994](https://github.com/remind101/empire/issues/994)\n* Fixed a bug where the GitHub authentication backend would sometimes return unauthenticated errors randomly. [#1029](https://github.com/remind101/empire/pull/1029)\n\n**Security**\n\n* It's now possible to set a maximum session duration, to ensure that users have to periodically re-authenticate with credentials and MFA [#1024](https://github.com/remind101/empire/pull/1024)\n\n## 0.11.1 (2017-03-10)\n\n**Bugs**\n\n* Fixed a regression from 0.10.1 where migrating apps from the legacy backend to CloudFormation would fail [#1046](https://github.com/remind101/empire/pull/1046)\n\n## 0.11.0 (2016-08-22)\n\n**Features**\n\n* Empire now includes experimental support for showing attached runs in `emp ps`. This can be enabled with the `--x.showattached` flag, or `EMPIRE_X_SHOW_ATTACHED` [#911](https://github.com/remind101/empire/pull/911)\n* Empire now includes experimental support for scheduled tasks [#919](https://github.com/remind101/empire/pull/919)\n* Empire now supports streaming status updates from the scheduler while deploying [#888](https://github.com/remind101/empire/issues/888)\n* You can now provision Empire applications and set environment variables from CloudFormation stacks using the `Custom::EmpireApp` and `Custom::EmpireAppEnvironment` resources [#819](https://github.com/remind101/empire/pull/819)\n* Empire now supports sending internal metrics to statsd or dogstatsd [#953](https://github.com/remind101/empire/pull/953)\n* Attached and detached runs now have an `empire.user` label attached to them [#965](https://github.com/remind101/empire/pull/965)\n* You can now provide the name of a process defined in the Procfile when calling `emp run` [#967](https://github.com/remind101/empire/pull/967)\n* Empire now includes experimental support for the new [Application Load Balancers](https://aws.amazon.com/blogs/aws/new-aws-application-load-balancer/) by setting the `LOAD_BALANCER_TYPE=alb` environment variable. [#969](https://github.com/remind101/empire/pull/969)\n* Empire now also sets an `EMPIRE_PROCESS_SCALE` environment variable, which includes the desired number of processes [#964](https://github.com/remind101/empire/issues/964)\n\n**Improvements**\n\n* The Custom::ECSService custom resource now waits for newly created ECS services to stabilize [#878](https://github.com/remind101/empire/pull/878)\n* The CloudFormation backend now uses the Custom::ECSService resource instead of AWS::ECS::Service, by default [#877](https://github.com/remind101/empire/pull/877)\n* The database schema version is now checked at boot, as well as in the http health checks. [#893](https://github.com/remind101/empire/pull/893)\n* The log level within empire can now be configured when starting the service. [#929](https://github.com/remind101/empire/issues/929)\n* The CloudFormation backend now has experimental support for a `Custom::ECSTaskDefinition` resource that greatly reduces the size of generated templates. [#935](https://github.com/remind101/empire/pull/935)\n* The Scheduler now has a `Restart` method which will trigger a restart of all the processes within an app. Previously, a \"Restart\" just re-released the app. Now schedulers like the cloudformation backend can optimize how the restart is handled. [#697](https://github.com/remind101/empire/issues/697)\n* `emp run` now publishes an event when it is ran. [#954](https://github.com/remind101/empire/pull/954)\n* `emp rollback` requires confirmation if rolling back more than 9 versions. [#975](https://github.com/remind101/empire/pull/975)\n\n**Bugs**\n\n* Fixed a bug where multiple duplicate ECS services could be created by the CloudFormation backend, when using the `Custom::ECSService` resource [#884](https://github.com/remind101/empire/pull/884).\n* Fixed a bug where the lock obtained during stack operations was not always unlocked. [#892](https://github.com/remind101/empire/pull/892)\n* Fixed an issue where Procfile's would not be extracted when Docker 1.12+ was used. [#915](https://github.com/remind101/empire/pull/915)\n* Fixed a bug where the failed creation of a custom resources could cause a CloudFormation stack to fail to rollback. [#938](https://github.com/remind101/empire/pull/938)\n* Fixed a bug where waiting for a deploy to stabilize was failing if you had more than 10 services. [#944](https://github.com/remind101/empire/issues/944)\n* Fixed an issue in the Tugboat integration where the log stream to a Tugboat instance could be closed. [#950](https://github.com/remind101/empire/pull/950)\n* Fixed an issue where typing commit message does not allow user to use arrow keys, etc. [#958](https://github.com/remind101/empire/pull/958)\n\n**Performance**\n\n* Performance of creating/updating/deleting custom resources in the CloudFormation backend has been improved. [#942](https://github.com/remind101/empire/pull/942)\n* ECS Task Definitions are now cached in memory for improved `emp ps` performance. [#902](https://github.com/remind101/empire/pull/902)\n\n**Security**\n\n* Empire now has a new `commands.allowed` flag that controls the behavior of what commands are allowed with `emp run`. This can be set to `procfile` to limit `emp run` to only allow commands defined in the Procfile.\n\n## 0.10.1 (2016-06-14)\n\n**Features**\n\n* Empire now contains expiremental support for using CloudFormation to provision resources for applications [#814](https://github.com/remind101/empire/pull/814), [#803](https://github.com/remind101/empire/pull/803).\n* Empire now supports requiring commit messages for all actions that emit an event via `--messages.required`. If a commit message is required for an action, emp will gracefully handle it and ask the user to input a value [#767](https://github.com/remind101/empire/issues/767).\n* You can now supply a commit message to any event that is published by Empire [#767](https://github.com/remind101/empire/issues/767).\n* Empire now supports deploying Docker images from the EC2 Container Registry [#730](https://github.com/remind101/empire/pull/730).\n* The Docker logging driver that the ECS backend uses is now configurable via the `--ecs.logdriver` flag [#731](https://github.com/remind101/empire/pull/731).\n* It's now possible to lock down the GitHub authorization to a specific team via the `--github.team.id` flag [#745](https://github.com/remind101/empire/pull/745).\n* Empire can now integrate with Conveyor to build Docker images on demand when using the GitHub Deployments integration [#747](https://github.com/remind101/empire/pull/747).\n* Stdout and Stdin from interactive run sessions can now be sent to CloudWatch Logs for longterm storage and auditing [#757](https://github.com/remind101/empire/pull/757).\n* Add `Environment` and `Release` to Deploy Events. `--environment` will likely be used for tagging resources later. [#758](https://github.com/remind101/empire/pull/758)\n* Add constraint changes to scale events [#773](https://github.com/remind101/empire/pull/773)\n* You can now specify the CPU and memory constraints for attached one-off tasks with the `-s` flag to `emp run` [#809](https://github.com/remind101/empire/pull/809)\n* You can now provide a duration to `emp log` with the `-d` flag to start streaming logs from a specific point in time ie (5m, 10m, 1h) [#829](https://github.com/remind101/empire/issues/829)\n* If log streaming is enabled, Empire will attempt to write events to the kinesis stream for the application [#832](https://github.com/remind101/empire/issues/832)\n* Added Stdout event stream [#874](https://github.com/remind101/empire/issues/874)\n\n**Bugs**\n\n* `emp run` now works with unofficial Docker registries [#740](https://github.com/remind101/empire/pull/740).\n* `emp scale -l` now lists configured scale, not the running processes [#769](https://github.com/remind101/empire/pull/769)\n* Fixed a bug where it was previously possible to create a signed access token with an empty username [#780](https://github.com/remind101/empire/pull/780)\n* ECR authentication now supports multiple regions, and works independently of ECS region [#784](https://github.com/remind101/empire/pull/784)\n* Provisioned ELB's are only destroyed when the entire app is removed [#801](https://github.com/remind101/empire/pull/801)\n* Docker containers started by attached runs now have labels, cpu and memory constraints applied to them [#809](https://github.com/remind101/empire/pull/809)\n* Fixed a bug where interactive `emp run` would get stuck attempting to read bytes after an error from the initial request [#795](https://github.com/remind101/empire/issues/795)\n\n**Performance**\n\n* `emp ps` should be significantly faster for services running a lot of processes [#781](https://github.com/remind101/empire/pull/781)\n* Scaling multiple processes within the Cloudformation scheduler results in 1 update now instead of N [#844](https://github.com/remind101/empire/pull/844)\n\n**Security**\n\n* Empire is now built with Go 1.5.3 to address [CVE-2015-8618](https://groups.google.com/forum/#!topic/golang-announce/MEATuOi_ei4) [#737](https://github.com/remind101/empire/pull/737).\n\n## 0.10.0 (2016-01-13)\n\n**Features**\n\n* `emp ps` now shows the correct uptime of the process thanks to ECS support [#683](https://github.com/remind101/empire/pull/683).\n* `emp run` now supports the `-d` flag for detached processes [#695](https://github.com/remind101/empire/pull/695).\n* You can now deploy images from unofficial Docker registries, such as Quay.io [#692](https://github.com/remind101/empire/pull/692).\n* Empire now allows you to \"attach\" existing IAM certificates. This replaces the old `ssl-*` commands in the `emp` CLI [#701](https://github.com/remind101/empire/pull/701).\n* You can now have Empire publish events to an SNS topic [#698](https://github.com/remind101/empire/pull/698).\n* Empire now supports environement aliases for Github Deployments [#681](https://github.com/remind101/empire/pull/681)\n\n**Bugs**\n\n* Allow floating point numbers to be provided when scaling the memory on a process [#694](https://github.com/remind101/empire/pull/694).\n* Empire will now update the SSL certificate on the associated ELB if it changes from `emp cert-attach` [#700](https://github.com/remind101/empire/pull/700).\n* The Tugboat integration now updates the deployment status with any errors that occurred [#709](https://github.com/remind101/empire/pull/709).\n* Deploying a non-existent docker image to Empire will no longer create an app [#713](https://github.com/remind101/empire/pull/713).\n* It's no longer necessary to re-deploy an application when scaling a process with new CPU or memory constraints [#713](https://github.com/remind101/empire/pull/713).\n\n**Security**\n\n* GitHub Organization membership is now checked on every request, not just at access token creation time [#687](https://github.com/remind101/empire/pull/687).\n\n**Internal**\n\n* The `emp` CLI has been moved to the primary [remind101/empire](https://github.com/remind101/empire/tree/master/cmd/emp) repo [#712](https://github.com/remind101/empire/pull/712).\n\n## 0.9.2 (2015-10-27)\n\n**Documentation**\n\n* Added doc on enabling log tailing #671.\n* Added doc on deploying an application #642.\n* Added doc on exposing an app publicly #668.\n* Added doc on known limitations #672.\n\n**Features**\n\n* Added log tailing from Kinesis #651.\n* Added AWS API errors exposition when deploying #628.\n* Added CrossZoneLoadBalancing to ELBs #641.\n* Added the process type in the get processes endpoint #649.\n* Reversed process and version in SOURCE environment variable #652.\n* Set empire.* labels on containers #679.\n\n**Bugs**\n\n* Added more specific load balancer error messages #629\n* Update aws-sdk-go to v0.9.15. Fixed ThrottlingExceptions during restart #645.\n* Fixed pagination when listing processes (tasks) #648.\n* Fixed release description for config updates (`set` and `unset` env variables) #678.\n\n## 0.9.1 (2015-07-31)\n\n**Documentation**\n\n* Updated demo to support private registries other than the official registry #528.\n* General updates to documentation.\n* Changed ELB health check thresholds in example CloudFormation stack to follow AWS defaults.\n\n**Features**\n\n* Implemented support for attached one-off commands #568.\n* Added support for GitHub Deployments #602.\n* Added support for deploying a docker image to a specific app #622.\n* Added support for `emp info` command #619.\n* Added pagination support for `/apps/{app}/releases` endpoint #591.\n\n**Bugs**\n\n* Fixed a bug that caused containers launched by one-off tasks to stay around if the client disconnected. #589.\n* Fixed an issue where deploying an app to an AWS account with no ELB's would cause an infinite loop #623.\n* Fixed a bug that prevented scaling a processes memory to more than 1GB #593.\n\n## 0.9.0 (2015-06-16)\n\nInitial public release\n"
        },
        {
          "name": "CODE_OF_CONDUCT.md",
          "type": "blob",
          "size": 3.138671875,
          "content": "# Contributor Covenant Code of Conduct\n\n## Our Pledge\n\nIn the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.\n\n## Our Standards\n\nExamples of behavior that contributes to creating a positive environment include:\n\n* Using welcoming and inclusive language\n* Being respectful of differing viewpoints and experiences\n* Gracefully accepting constructive criticism\n* Focusing on what is best for the community\n* Showing empathy towards other community members\n\nExamples of unacceptable behavior by participants include:\n\n* The use of sexualized language or imagery and unwelcome sexual attention or advances\n* Trolling, insulting/derogatory comments, and personal or political attacks\n* Public or private harassment\n* Publishing others' private information, such as a physical or electronic address, without explicit permission\n* Other conduct which could reasonably be considered inappropriate in a professional setting\n\n## Our Responsibilities\n\nProject maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.\n\nProject maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.\n\n## Scope\n\nThis Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.\n\n## Enforcement\n\nInstances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at opseng@remind.com. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.\n\nProject maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.\n\n## Attribution\n\nThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available at [http://contributor-covenant.org/version/1/4][version]\n\n[homepage]: http://contributor-covenant.org\n[version]: http://contributor-covenant.org/version/1/4/\n"
        },
        {
          "name": "CONTRIBUTING.md",
          "type": "blob",
          "size": 6.3837890625,
          "content": "# Contributing to Empire\n\n## Topics\n\n* [Reporting Issues](#reporting-issues)\n* [Submitting Pull Requests](#submitting-pull-requests)\n\n## Reporting Issues\n\nA great way to contribute to the project is to send a detailed report when you encounter an issue. We always appreciate a well-written, thorough bug report, and will thank you for it!\nCheck that [our issue database](https://github.com/remind101/empire/issues) doesn't already include that problem or suggestion before submitting an issue. If you find a match, add a quick \"+1\" or \"I have this problem too.\" Doing this helps prioritize the most common problems and requests.\n\nPlease also include the steps required to reproduce the problem if possible and applicable. This information will help us review and fix your issue faster.\n\n## Submitting Pull Requests\n\nWe want the development of Empire to be driven by the needs of the community, so pull requests are highly encouraged. We do have some guidelines that we would like people to follow:\n\n* If your change is non-trivial, or implements a new feature, please create an issue first so the community and maintainers can discuss the change before implementation happens.\n\nWhen submitting a pull request, here are some things to keep in mind:\n\n* Is your change backwards compatible? Would this require any migration steps? Will any changes be required in the [CLI](https://github.com/remind101/empire/tree/master/cmd/emp)?\n* Does your change require changes to the documentation? Does the quickstart guide need to be updated?\n* Did you add appropriate test coverage? Submissions that add features or change core functionality will not be accepted without sufficient tests. We favor stability over anything else.\n* Did you update the CHANGELOG?\n\n## Code Structure\n\nEmpire is a fairly large codebase, separated into packages that depend on each other. In a nutshell, the most important packages are:\n\n* **[github.com/remind101/empire](./)**: This is the \"core\" internal API of Empire, which \"control\" layers (like the REST API) consume.\n* **[github.com/remind101/empire/server](./server)**: This contains an [http.Handler](https://golang.org/pkg/net/http/#Handler) implementation for serving the Empire API, which is what the `emp` CLI communicates with.\n* **[github.com/remind101/empire/scheduler](./scheduler)**: This is the layer that the core of Empire interacts with for submitting releases to be scheduled on a cluster of machines. The canonical implementation uses CloudFormation + ECS to run applications.\n* **[github.com/remind101/empire/cmd](./cmd)**: Holds both the [empire](./cmd/empire) (daemon) command and [emp](./cmd/emp) (client) command.\n\nThe dependency graph for the packages above, and how they interact with each other looks like this:\n\n![](./docs/deps.png)\n\n## Tests\n\nUnit tests live alongside each go file as `_test.go`.\n\nThere is also a `tests` directory that contains integration and functional tests that tests the system using the [heroku-go][heroku-go] client and the [emp][emp] command.\n\nThe easiest way to run the tests is by using [docker-compose](https://docs.docker.com/compose/).\n\n### Docker Compose\n\nTo get started, run:\n\n```console\n$ docker-compose -f docker-compose.test.yml build\n$ docker-compose -f docker-compose.test.yml up -d db\n```\n\nThen run the tests with:\n\n```console\n$ docker-compose -f docker-compose.test.yml run tests\n```\n\n### Mac\n\nTo get started, run:\n\n```console\n$ make bootstrap\n```\n\nThe bootstrap command assumes you have a running postgres server. It will create a database called `empire`\nusing the postgres client connection defaults.\n\nTo run the tests:\n\n```console\n$ make test\n```\n\n**NOTE**: You may need to install libxmlsec1 for the tests to run. You can do this with:\n\n```console\n$ brew install libxmlsec1 libxml2 pkg-config\n```\n\n## Development\n\nIf you want to contribute to Empire, you may end up wanting to run a local instance against an ECS cluster. Doing this is relatively easy:\n\n1. Ensure that you have the AWS CLI installed and configured.\n2. Ensure that you accepted the terms and conditions for the official ECS AMI:\n\n   https://aws.amazon.com/marketplace/fulfillment?productId=52d5fd7f-92c7-4d60-a830-41a596f4d8f3&region=us-east-1\n\n   Also check that the offical ECS AMI ID for US East matches with the one in [cloudformation.json](./docs/cloudformation.json): https://github.com/remind101/empire/blob/master/docs/cloudformation.json#L20\n\n3. Run docker-machine and export the environment variables so Empire can connect:\n\n   ```console\n   $ docker-machine start default\n   $ eval \"$(docker-machine env default)\"\n   ```\n4. Run the bootstrap script, which will create a cloudformation stack, ecs cluster and populate a .env file:\n\n   ```console\n   $ ./bin/bootstrap\n   ```\n5. Run Empire with [docker-compose](https://docs.docker.com/compose/):\n\n   ```console\n   $ docker-compose up db # Only need to do this the first time, so that the db can initialize.\n   $ docker-compose up\n   ```\n\n   **NOTE**: You might need to run this twice the first time you start it up, to give the postgres container time to initialize.\n6. [Install the emp CLI](./cmd/emp#installation).\n\nEmpire will be available at `http://$(docker-machine ip default):8080` and you can point the CLI there.\n\n```console\n$ export EMPIRE_API_URL=http://$(docker-machine ip default):8080\n$ emp deploy remind101/acme-inc\n```\n\n### Vendoring\n\nEmpire follows Go's convention of vendoring third party dependencies. We use the Go 1.5+ [vendor expirement](https://blog.gopheracademy.com/advent-2015/vendor-folder/), and manage the `./vendor/` directory via [govendor](https://github.com/kardianos/govendor).\n\nWhen you add a new dependency, be sure to vendor it with govendor:\n\n```console\n$ govendor add <package>\n```\n\n### Releasing\n\nPerform the following steps when releasing a new version:\n\n1. Create a new branch `release-VERSION`.\n2. Bump the version number with `make bump` (this will add a commit to the branch).\n3. Change `HEAD` -> `VERSION` in [CHANGELOG.md](./CHANGELOG.md).\n4. Open a PR to review.\n5. Once merged into master, wait for the Conveyor build to complete.\n6. Finally, tag the commit with the version as `v<VERSION>`. This will trigger CircleCI to:\n   * Tag the image in Docker Hub with the version.\n   * Build Linux and OS X versions of the CLI and Daemon.\n   * Create a new GitHub Release and upload the artifacts.\n7. Update the new GitHub Release to be human readable.\n8. Open a PR against Homebrew to update the emp CLI: https://github.com/Homebrew/homebrew-core/blob/master/Formula/emp.rb\n"
        },
        {
          "name": "Dockerfile",
          "type": "blob",
          "size": 0.3603515625,
          "content": "FROM golang:1.10.8\n\nLABEL version 0.13.0\n\nRUN apt-get update -yy && \\\n  apt-get install -yy git make curl libxml2-dev libxmlsec1-dev liblzma-dev pkg-config xmlsec1\n\nADD . /go/src/github.com/remind101/empire\nWORKDIR /go/src/github.com/remind101/empire\nRUN go install ./cmd/empire\nRUN ldd /go/bin/empire || true\n\nENTRYPOINT [\"/go/bin/empire\"]\nCMD [\"server\"]\n\nEXPOSE 8080\n"
        },
        {
          "name": "Dockerfile.test",
          "type": "blob",
          "size": 0.2333984375,
          "content": "FROM golang:1.10.8\n\nRUN apt-get update -yy && \\\n  apt-get install -yy git make curl libxml2-dev libxmlsec1-dev liblzma-dev pkg-config xmlsec1 postgresql-client\n\nWORKDIR /go/src/github.com/remind101/empire\n\nENTRYPOINT [\"make\"]\nCMD [\"test\"]\n"
        },
        {
          "name": "LICENSE",
          "type": "blob",
          "size": 1.2724609375,
          "content": "Copyright (c) 2015, Remind101, Inc.\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this\n   list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
        },
        {
          "name": "Makefile",
          "type": "blob",
          "size": 0.876953125,
          "content": ".PHONY: build test bootstrap\n\nREPO = remind101/empire\nTYPE ?= patch\nARTIFACTS ?= build\n\ncmds: build/empire build/emp\n\nclean:\n\trm -rf build/*\n\nbuild/empire:\n\tgo build -o build/empire ./cmd/empire\n\nbuild/emp:\n\tgo build -o build/emp ./cmd/emp\n\nbootstrap: cmds\n\tcreatedb empire || true\n\t./build/empire migrate\n\nbuild: Dockerfile\n\tdocker build -t ${REPO} .\n\ntest: build/emp\n\tgo test -race $(shell go list ./... | grep -v /vendor/)\n\t./tests/deps\n\nvet:\n\tgo vet $(shell go list ./... | grep -v /vendor/)\n\nbump:\n\tpip install --upgrade bumpversion\n\tbumpversion ${TYPE}\n\n$(ARTIFACTS)/all: $(ARTIFACTS)/emp-Linux-x86_64 $(ARTIFACTS)/emp-Darwin-x86_64 $(ARTIFACTS)/empire-Linux-x86_64\n\n$(ARTIFACTS)/emp-Linux-x86_64:\n\tenv GOOS=linux go build -o $@ ./cmd/emp\n$(ARTIFACTS)/emp-Darwin-x86_64:\n\tenv GOOS=darwin go build -o $@ ./cmd/emp\n\n$(ARTIFACTS)/empire-Linux-x86_64:\n\tenv GOOS=linux go build -o $@ ./cmd/empire\n"
        },
        {
          "name": "README.md",
          "type": "blob",
          "size": 6.775390625,
          "content": "# Empire\n\n[![readthedocs badge](https://readthedocs.org/projects/pip/badge/?version=latest)](http://empire.readthedocs.org/en/latest/)\n[![Circle CI](https://circleci.com/gh/remind101/empire.svg?style=shield)](https://circleci.com/gh/remind101/empire)\n[![Slack Status](https://empire-slack.herokuapp.com/badge.svg)](https://empire-slack.herokuapp.com)\n\n![Empire](empire.png)\n\nEmpire is a control layer on top of [Amazon EC2 Container Service (ECS)][ecs] that provides a Heroku like workflow. It conforms to a subset of the [Heroku Platform API][heroku-api], which means you can use the same tools and processes that you use with Heroku, but with all the power of EC2 and [Docker][docker].\n\nEmpire is targeted at small to medium sized startups that are running a large number of microservices and need more flexibility than what Heroku provides. You can read the original blog post about why we built empire on the [Remind engineering blog](http://engineering.remind.com/introducing-empire/).\n\n## Quickstart\n\n[![Install](https://s3.amazonaws.com/cloudformation-examples/cloudformation-launch-stack.png)](https://console.aws.amazon.com/cloudformation/home?region=us-east-1#cstack=sn%7Eempire%7Cturl%7Ehttps://s3.amazonaws.com/empirepaas/cloudformation.json)\n\nTo use Empire, you'll need to have an ECS cluster running. See the [quickstart guide][guide] for more information.\n\n## Architecture\n\nEmpire aims to make it trivially easy to deploy a container based microservices architecture, without all of the complexities of managing systems like Mesos or Kubernetes. ECS takes care of much of that work, but Empire attempts to enhance the interface to ECS for deploying and maintaining applications, allowing you to deploy Docker images as easily as:\n\n```console\n$ emp deploy remind101/acme-inc:master\n```\n\n### Heroku API compatibility\n\nEmpire supports a subset of the [Heroku Platform API][heroku-api], which means any tool that uses the Heroku API can probably be used with Empire, if the endpoint is supported.\n\nAs an example, you can use the `hk` CLI with Empire like this:\n\n```console\n$ HEROKU_API_URL=<empire_url> hk ...\n```\n\nHowever, the best user experience will be by using the [emp](https://github.com/remind101/empire/tree/master/cmd/emp) command, which is a fork of `hk` with Empire specific features.\n\n### Routing\n\nEmpire's routing layer is backed by internal ELBs. Any application that specifies a web process will get an internal ELB attached to its associated ECS Service. When a new version of the app is deployed, ECS manages spinning up the new versions of the process, waiting for old connections to drain, then killing the old release.\n\nWhen a new internal ELB is created, an associated CNAME record will be created in Route53 under the internal TLD, which means you can use DNS for service discovery. If we deploy an app named `feed` then it will be available at `http://feed` within the ECS cluster.\n\nApps default to only being exposed internally, unless you add a custom domain to them. Adding a custom domain will create a new external ELB for the ECS service.\n\n### Deploying\n\nAny tagged Docker image can be deployed to Empire as an app. Empire doesn't enforce how you tag your Docker images, but we recommend tagging the image with the git sha that it was built from (any any immutable identifier), and deploying that.\n\nWhen you deploy a Docker image to Empire, it will extract a `Procfile` from the WORKDIR. Like Heroku, you can specify different process types that compose your service (e.g. `web` and `worker`), and scale them individually. Each process type in the Procfile maps directly to an ECS Service.\n\n## Contributing\n\nPull requests are more than welcome! For help with setting up a development environment, see [CONTRIBUTING.md](./CONTRIBUTING.md)\n\n## Community\n\nWe have a google group, [empire-dev][empire-dev], where you can ask questions and engage with the Empire community.\n\nYou can also [join](https://empire-slack.herokuapp.com/) our Slack team for discussions and support.\n\n[ecs]: http://aws.amazon.com/ecs/\n[docker]: https://github.com/docker/docker\n[heroku-api]: https://devcenter.heroku.com/articles/platform-api-reference\n[tugboat]: https://github.com/remind101/tugboat\n[heroku-go]: https://github.com/bgentry/heroku-go\n[hk]: https://github.com/heroku/hk\n[emp]: https://github.com/remind101/emp\n[guide]: http://empire.readthedocs.org/en/latest/\n[empire-dev]: https://groups.google.com/forum/#!forum/empire-dev\n\n## Auth Flow\n\nThe current authentication model used by `emp login` relies on a [deprecated](https://developer.github.com/changes/2020-02-14-deprecating-oauth-auth-endpoint/) GitHub endpoint that is scheduled to be deactivated in November 2020.  Therefore both the client and the server need to be updated to support the [web authentication flow](https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#web-application-flow)\n\nThe web flow works like this\n\n1. The user runs a command like `emp web-login`\n1. The client starts up a HTTP listener on a free local port\n1. The client opens a browser window on the local machine to `$EMPIRE_API_URL/oauth/start?port=?????`\n    * The port parameter specifies where the client is listening\n1. The browser executes a GET against the URL\n1. The Empire server sees the request and constructs an OAuth request URL that will hit the GitHub OAuth endpoint and returns it as a redirect\n1. The browser makes the request to the GitHub auth endpoint, which shows the UI a request to authorize the application\n    * If they've previously authorized it will just immediately grant the request\n1. GitHub redirects the browser back to the redirect URL specified in the configuration, meaning back to the Empire server\n1. The Empire server receives the browser request and can now perform the [code exchange](https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps/#2-users-are-redirected-back-to-your-site-by-github) to turn the provided code into an actual authentication token\n    * This is just like it would have received from the old endpoint.  However, it's not usable yet because it still isn't in the possession of the client, only the browser\n1. The Empire server now redirects the browser back to `localhost` on the original port provided by the client\n1. The client receives the token, but can't use it directly.  The Empire server expects it to be wrapped in a JSON Web Token that only the server can create.\n1. The client can now make a request directly to the Empire server (its first in this sequence) providing the token and requesting a JSON Web Token in response\n1. The client stores the received token just as it would have with the response to an `emp login` command\n1. The client is authenticated    \n\nIn theory the Empire server could construct the JWT directly after the code exchange and push that directly to the client, but the abstraction doesn't really seem to easily support that flow\n"
        },
        {
          "name": "VERSION",
          "type": "blob",
          "size": 0.005859375,
          "content": "0.13.0"
        },
        {
          "name": "apps.go",
          "type": "blob",
          "size": 6.0400390625,
          "content": "package empire\n\nimport (\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n\t\"strings\"\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/pkg/timex\"\n\t\"golang.org/x/net/context\"\n)\n\nconst (\n\texposePrivate = \"private\"\n\texposePublic  = \"public\"\n)\n\n// NamePattern is a regex pattern that app names must conform to.\nvar NamePattern = regexp.MustCompile(`^[a-z][a-z0-9-]{2,30}$`)\n\n// appNameFromRepo generates a name from a Repo\n//\n//\tremind101/r101-api => r101-api\nfunc appNameFromRepo(repo string) string {\n\tp := strings.Split(repo, \"/\")\n\treturn p[len(p)-1]\n}\n\n// Certs maps a process name to a certificate to use for any SSL listeners.\ntype Certs map[string]string\n\n// Scan implements the sql.Scanner interface.\nfunc (c *Certs) Scan(src interface{}) error {\n\tbytes, ok := src.([]byte)\n\tif !ok {\n\t\treturn error(errors.New(\"Scan source was not []bytes\"))\n\t}\n\n\tcerts := make(Certs)\n\tif err := json.Unmarshal(bytes, &certs); err != nil {\n\t\treturn err\n\t}\n\t*c = certs\n\n\treturn nil\n}\n\n// Value implements the driver.Value interface.\nfunc (c Certs) Value() (driver.Value, error) {\n\tif c == nil {\n\t\treturn nil, nil\n\t}\n\n\traw, err := json.Marshal(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn driver.Value(raw), nil\n}\n\n// App represents an Empire application.\ntype App struct {\n\t// A unique uuid that identifies the application.\n\tID string\n\n\t// The name of the application.\n\tName string\n\n\t// If provided, the Docker repo that this application is linked to.\n\t// Deployments to Empire, which don't specify an application, will use\n\t// this field to determine what app an image should be deployed to.\n\tRepo *string\n\n\t// Valid values are exposePrivate and exposePublic.\n\tExposure string\n\n\t// Maps a process name to an SSL certificate to use for the SSL listener\n\t// of the load balancer.\n\tCerts Certs\n\n\t// The time that this application was created.\n\tCreatedAt *time.Time\n\n\t// If this is non-nil, the app was deleted at this time.\n\tDeletedAt *time.Time\n\n\t// Maintenance defines whether the app is in maintenance mode or not.\n\tMaintenance bool\n}\n\n// IsValid returns an error if the app isn't valid.\nfunc (a *App) IsValid() error {\n\tif !NamePattern.Match([]byte(a.Name)) {\n\t\treturn ErrInvalidName\n\t}\n\n\treturn nil\n}\n\nfunc (a *App) BeforeCreate() error {\n\tt := timex.Now()\n\ta.CreatedAt = &t\n\n\tif a.Exposure == \"\" {\n\t\ta.Exposure = exposePrivate\n\t}\n\n\treturn a.IsValid()\n}\n\n// AppsQuery is a scope implementation for common things to filter releases\n// by.\ntype AppsQuery struct {\n\t// If provided, an App ID to find.\n\tID *string\n\n\t// If provided, finds apps matching the given name.\n\tName *string\n\n\t// If provided, finds apps with the given repo attached.\n\tRepo *string\n}\n\n// scope implements the scope interface.\nfunc (q AppsQuery) scope(db *gorm.DB) *gorm.DB {\n\tscope := composedScope{isNull(\"deleted_at\")}\n\n\tif q.ID != nil {\n\t\tscope = append(scope, idEquals(*q.ID))\n\t}\n\n\tif q.Name != nil {\n\t\tscope = append(scope, fieldEquals(\"name\", *q.Name))\n\t}\n\n\tif q.Repo != nil {\n\t\tscope = append(scope, fieldEquals(\"repo\", *q.Repo))\n\t}\n\n\treturn scope.scope(db)\n}\n\ntype appsService struct {\n\t*Empire\n}\n\n// Destroy destroys removes an app from the scheduler, then destroys it here.\nfunc (s *appsService) Destroy(ctx context.Context, db *gorm.DB, app *App) error {\n\tif err := appsDestroy(db, app); err != nil {\n\t\treturn err\n\t}\n\n\treturn s.Scheduler.Remove(ctx, app.ID)\n}\n\nfunc (s *appsService) Restart(ctx context.Context, db *gorm.DB, opts RestartOpts) error {\n\tif opts.PID != \"\" {\n\t\treturn s.Scheduler.Stop(ctx, opts.PID)\n\t}\n\n\treturn s.releases.Restart(ctx, db, opts.App)\n}\n\nfunc (s *appsService) Scale(ctx context.Context, db *gorm.DB, opts ScaleOpts) ([]*Process, error) {\n\tapp := opts.App\n\n\trelease, err := releasesFind(db, ReleasesQuery{App: app})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif release == nil {\n\t\treturn nil, &ValidationError{Err: fmt.Errorf(\"no releases for %s\", app.Name)}\n\t}\n\n\tevent := opts.Event()\n\n\tvar ps []*Process\n\tfor i, up := range opts.Updates {\n\t\tt, q, c := up.Process, up.Quantity, up.Constraints\n\n\t\tp, ok := release.Formation[t]\n\t\tif !ok {\n\t\t\treturn nil, &ValidationError{Err: fmt.Errorf(\"no %s process type in release\", t)}\n\t\t}\n\n\t\teventUpdate := event.Updates[i]\n\t\teventUpdate.PreviousQuantity = p.Quantity\n\t\teventUpdate.PreviousConstraints = p.Constraints()\n\n\t\t// Update quantity for this process in the formation\n\t\tp.Quantity = q\n\t\tif c != nil {\n\t\t\tp.SetConstraints(*c)\n\t\t}\n\n\t\trelease.Formation[t] = p\n\t\tps = append(ps, &p)\n\t}\n\n\t// Save the new formation.\n\tif err := releasesUpdate(db, release); err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = s.releases.Release(ctx, release, nil)\n\tif err != nil {\n\t\treturn ps, err\n\t}\n\n\treturn ps, s.PublishEvent(event)\n}\n\n// appsEnsureRepo will set the repo if it's not set.\nfunc appsEnsureRepo(db *gorm.DB, app *App, repo string) error {\n\tif app.Repo != nil {\n\t\treturn nil\n\t}\n\n\tapp.Repo = &repo\n\n\treturn appsUpdate(db, app)\n}\n\n// appsFindOrCreateByRepo first attempts to find an app by repo, falling back to\n// creating a new app.\nfunc appsFindOrCreateByRepo(db *gorm.DB, repo string) (*App, error) {\n\tn := appNameFromRepo(repo)\n\ta, err := appsFind(db, AppsQuery{Name: &n})\n\tif err != nil && err != gorm.RecordNotFound {\n\t\treturn a, err\n\t}\n\n\t// If the app wasn't found, create a new app.\n\tif err != gorm.RecordNotFound {\n\t\treturn a, appsEnsureRepo(db, a, repo)\n\t}\n\n\ta = &App{\n\t\tName: n,\n\t\tRepo: &repo,\n\t}\n\n\treturn appsCreate(db, a)\n}\n\n// appsFind finds a single app given the scope.\nfunc appsFind(db *gorm.DB, scope scope) (*App, error) {\n\tvar app App\n\treturn &app, first(db, scope, &app)\n}\n\n// apps finds all apps matching the scope.\nfunc apps(db *gorm.DB, scope scope) ([]*App, error) {\n\tvar apps []*App\n\t// Default to ordering by name.\n\tscope = composedScope{order(\"name\"), scope}\n\treturn apps, find(db, scope, &apps)\n}\n\n// appsCreate inserts the app into the database.\nfunc appsCreate(db *gorm.DB, app *App) (*App, error) {\n\treturn app, db.Create(app).Error\n}\n\n// appsUpdate updates an app.\nfunc appsUpdate(db *gorm.DB, app *App) error {\n\treturn db.Save(app).Error\n}\n\n// appsDestroy destroys an app.\nfunc appsDestroy(db *gorm.DB, app *App) error {\n\tnow := timex.Now()\n\tapp.DeletedAt = &now\n\treturn appsUpdate(db, app)\n}\n"
        },
        {
          "name": "apps_test.go",
          "type": "blob",
          "size": 0.947265625,
          "content": "package empire\n\nimport (\n\t\"testing\"\n)\n\nfunc TestIsValid(t *testing.T) {\n\ttests := []struct {\n\t\tapp App\n\t\terr error\n\t}{\n\t\t{App{}, ErrInvalidName},\n\t\t{App{Name: \"api\"}, nil},\n\t\t{App{Name: \"r101-api\"}, nil},\n\t}\n\n\tfor _, tt := range tests {\n\t\tif err := tt.app.IsValid(); err != tt.err {\n\t\t\tt.Fatalf(\"%v.IsValid() => %v; want %v\", tt.app, err, tt.err)\n\t\t}\n\t}\n}\n\nfunc TestAppsQuery(t *testing.T) {\n\tid := \"1234\"\n\tname := \"acme-inc\"\n\trepo := \"remind101/acme-inc\"\n\n\ttests := scopeTests{\n\t\t{AppsQuery{}, \"WHERE (deleted_at is null)\", []interface{}{}},\n\t\t{AppsQuery{ID: &id}, \"WHERE (deleted_at is null) AND (id = $1)\", []interface{}{id}},\n\t\t{AppsQuery{Name: &name}, \"WHERE (deleted_at is null) AND (name = $1)\", []interface{}{name}},\n\t\t{AppsQuery{Repo: &repo}, \"WHERE (deleted_at is null) AND (repo = $1)\", []interface{}{repo}},\n\t\t{AppsQuery{Name: &name, Repo: &repo}, \"WHERE (deleted_at is null) AND (name = $1) AND (repo = $2)\", []interface{}{name, repo}},\n\t}\n\n\ttests.Run(t)\n}\n"
        },
        {
          "name": "bin",
          "type": "tree",
          "content": null
        },
        {
          "name": "certs.go",
          "type": "blob",
          "size": 0.5908203125,
          "content": "package empire\n\nimport (\n\t\"github.com/jinzhu/gorm\"\n\t\"golang.org/x/net/context\"\n)\n\ntype certsService struct {\n\t*Empire\n}\n\nfunc (s *certsService) CertsAttach(ctx context.Context, db *gorm.DB, opts CertsAttachOpts) error {\n\tapp := opts.App\n\tif app.Certs == nil {\n\t\tapp.Certs = make(Certs)\n\t}\n\n\tprocess := opts.Process\n\tif process == \"\" {\n\t\tprocess = webProcessType\n\t}\n\n\tapp.Certs[process] = opts.Cert\n\n\tif err := appsUpdate(db, app); err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.releases.ReleaseApp(ctx, db, app, nil); err != nil {\n\t\tif err == ErrNoReleases {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "cmd",
          "type": "tree",
          "content": null
        },
        {
          "name": "configs.go",
          "type": "blob",
          "size": 4.6416015625,
          "content": "package empire\n\nimport (\n\t\"database/sql\"\n\t\"database/sql/driver\"\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/lib/pq/hstore\"\n\t\"golang.org/x/net/context\"\n)\n\n// Config represents a collection of environment variables.\ntype Config struct {\n\t// A unique uuid representing this Config.\n\tID string\n\n\t// The environment variables in this config.\n\tVars Vars\n\n\t// The id of the app that this config relates to.\n\tAppID string\n\n\t// The app that this config relates to.\n\tApp *App\n}\n\n// newConfig initializes a new config based on the old config, with the new\n// variables provided.\nfunc newConfig(old *Config, vars Vars) *Config {\n\tv := mergeVars(old.Vars, vars)\n\n\treturn &Config{\n\t\tAppID: old.AppID,\n\t\tVars:  v,\n\t}\n}\n\n// Variable represents the name of an environment variable.\ntype Variable string\n\n// Vars represents a variable -> value mapping.\ntype Vars map[Variable]*string\n\n// Scan implements the sql.Scanner interface.\nfunc (v *Vars) Scan(src interface{}) error {\n\th := hstore.Hstore{}\n\tif err := h.Scan(src); err != nil {\n\t\treturn err\n\t}\n\n\tvars := make(Vars)\n\n\tfor k, v := range h.Map {\n\t\t// Go reuses the same address space for v, so &v.String would always\n\t\t// return the same address\n\t\ttmp := v.String\n\t\tvars[Variable(k)] = &tmp\n\t}\n\n\t*v = vars\n\n\treturn nil\n}\n\n// Value implements the driver.Value interface.\nfunc (v Vars) Value() (driver.Value, error) {\n\tm := make(map[string]sql.NullString)\n\n\tfor k, v := range v {\n\t\tm[string(k)] = sql.NullString{\n\t\t\tValid:  true,\n\t\t\tString: *v,\n\t\t}\n\t}\n\n\th := hstore.Hstore{\n\t\tMap: m,\n\t}\n\n\treturn h.Value()\n}\n\n// ConfigsQuery is a scope implementation for common things to filter releases\n// by.\ntype ConfigsQuery struct {\n\t// If provided, returns finds the config with the given id.\n\tID *string\n\n\t// If provided, filters configs for the given app.\n\tApp *App\n}\n\n// scope implements the scope interface.\nfunc (q ConfigsQuery) scope(db *gorm.DB) *gorm.DB {\n\tvar scope composedScope\n\n\tif q.ID != nil {\n\t\tscope = append(scope, idEquals(*q.ID))\n\t}\n\n\tif q.App != nil {\n\t\tscope = append(scope, forApp(q.App))\n\t}\n\n\treturn scope.scope(db)\n}\n\n// configsFind returns the first matching config.\nfunc configsFind(db *gorm.DB, scope scope) (*Config, error) {\n\tvar config Config\n\tscope = composedScope{order(\"created_at desc\"), scope}\n\treturn &config, first(db, scope, &config)\n}\n\n// ConfigsCreate inserts a Config in the database.\nfunc configsCreate(db *gorm.DB, config *Config) (*Config, error) {\n\treturn config, db.Create(config).Error\n}\n\ntype configsService struct {\n\t*Empire\n}\n\nfunc (s *configsService) Set(ctx context.Context, db *gorm.DB, opts SetOpts) (*Config, error) {\n\tapp, vars := opts.App, opts.Vars\n\n\told, err := s.Config(db, app)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tc, err := configsCreate(db, newConfig(old, vars))\n\tif err != nil {\n\t\treturn c, err\n\t}\n\n\trelease, err := releasesFind(db, ReleasesQuery{App: app})\n\tif err != nil {\n\t\tif err == gorm.RecordNotFound {\n\t\t\terr = nil\n\t\t}\n\n\t\treturn c, err\n\t}\n\n\t// Create new release based on new config and old slug\n\t_, err = s.releases.CreateAndRelease(ctx, db, &Release{\n\t\tApp:         release.App,\n\t\tConfig:      c,\n\t\tSlug:        release.Slug,\n\t\tDescription: configsApplyReleaseDesc(opts),\n\t}, nil)\n\treturn c, err\n}\n\n// Returns configs for latest release or the latest configs if there are no releases.\nfunc (s *configsService) Config(db *gorm.DB, app *App) (*Config, error) {\n\tr, err := releasesFind(db, ReleasesQuery{App: app})\n\tif err != nil {\n\t\tif err == gorm.RecordNotFound {\n\t\t\t// It's possible to have config without releases, this handles that.\n\t\t\tc, err := configsFind(db, ConfigsQuery{App: app})\n\t\t\tif err != nil {\n\t\t\t\tif err == gorm.RecordNotFound {\n\t\t\t\t\t// Return an empty config.\n\t\t\t\t\treturn &Config{\n\t\t\t\t\t\tAppID: app.ID,\n\t\t\t\t\t\tApp:   app,\n\t\t\t\t\t\tVars:  make(Vars),\n\t\t\t\t\t}, nil\n\t\t\t\t}\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\treturn c, nil\n\t\t}\n\n\t\treturn nil, err\n\t}\n\n\treturn r.Config, nil\n}\n\n// mergeVars copies all of the vars from a, and merges b into them, returning a\n// new Vars.\nfunc mergeVars(old, new Vars) Vars {\n\tvars := make(Vars)\n\n\tfor n, v := range old {\n\t\tvars[n] = v\n\t}\n\n\tfor n, v := range new {\n\t\tif v == nil {\n\t\t\tdelete(vars, n)\n\t\t} else {\n\t\t\tvars[n] = v\n\t\t}\n\t}\n\n\treturn vars\n}\n\n// configsApplyReleaseDesc formats a release description based on the config variables\n// being applied.\nfunc configsApplyReleaseDesc(opts SetOpts) string {\n\tvars := opts.Vars\n\tverb := \"Set\"\n\tplural := \"\"\n\tif len(vars) > 1 {\n\t\tplural = \"s\"\n\t}\n\n\tkeys := make(sort.StringSlice, 0, len(vars))\n\tfor k, v := range vars {\n\t\tkeys = append(keys, string(k))\n\t\tif v == nil {\n\t\t\tverb = \"Unset\"\n\t\t}\n\t}\n\tkeys.Sort()\n\tdesc := fmt.Sprintf(\"%s %s config var%s\", verb, strings.Join(keys, \", \"), plural)\n\treturn appendMessageToDescription(desc, opts.User, opts.Message)\n}\n"
        },
        {
          "name": "configs_test.go",
          "type": "blob",
          "size": 2.1845703125,
          "content": "package empire\n\nimport (\n\t\"reflect\"\n\t\"testing\"\n)\n\nfunc TestConfigsQuery(t *testing.T) {\n\tid := \"1234\"\n\tapp := &App{ID: \"4321\"}\n\n\ttests := scopeTests{\n\t\t{ConfigsQuery{}, \"\", []interface{}{}},\n\t\t{ConfigsQuery{ID: &id}, \"WHERE (id = $1)\", []interface{}{id}},\n\t\t{ConfigsQuery{App: app}, \"WHERE (app_id = $1)\", []interface{}{app.ID}},\n\t}\n\n\ttests.Run(t)\n}\n\nfunc TestMergeVars(t *testing.T) {\n\tvar (\n\t\tPRODUCTION   = \"production\"\n\t\tSTAGING      = \"staging\"\n\t\tEMPTY        = \"\"\n\t\tDATABASE_URL = \"postgres://localhost\"\n\t)\n\n\t// Old vars\n\tvars := Vars{\n\t\t\"RAILS_ENV\":    &PRODUCTION,\n\t\t\"DATABASE_URL\": &DATABASE_URL,\n\t}\n\n\ttests := []struct {\n\t\tin  Vars\n\t\tout Vars\n\t}{\n\t\t// Removing a variable\n\t\t{\n\t\t\tVars{\n\t\t\t\t\"RAILS_ENV\": nil,\n\t\t\t},\n\t\t\tVars{\n\t\t\t\t\"DATABASE_URL\": &DATABASE_URL,\n\t\t\t},\n\t\t},\n\n\t\t// Setting an empty variable\n\t\t{\n\t\t\tVars{\n\t\t\t\t\"RAILS_ENV\": &EMPTY,\n\t\t\t},\n\t\t\tVars{\n\t\t\t\t\"RAILS_ENV\":    &EMPTY,\n\t\t\t\t\"DATABASE_URL\": &DATABASE_URL,\n\t\t\t},\n\t\t},\n\n\t\t// Updating a variable\n\t\t{\n\t\t\tVars{\n\t\t\t\t\"RAILS_ENV\": &STAGING,\n\t\t\t},\n\t\t\tVars{\n\t\t\t\t\"RAILS_ENV\":    &STAGING,\n\t\t\t\t\"DATABASE_URL\": &DATABASE_URL,\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tv := mergeVars(vars, tt.in)\n\n\t\tif got, want := v, tt.out; !reflect.DeepEqual(got, want) {\n\t\t\tt.Errorf(\"mergeVars => want %v; got %v\", want, got)\n\t\t}\n\t}\n}\n\nfunc TestReleaseDesc(t *testing.T) {\n\tconfigVal := \"test\"\n\n\ttests := []struct {\n\t\tin  SetOpts\n\t\tout string\n\t}{\n\t\t{\n\t\t\tSetOpts{\n\t\t\t\tUser: &User{Name: \"fake\"},\n\t\t\t\tVars: Vars{\"FOO\": &configVal},\n\t\t\t},\n\t\t\t\"Set FOO config var (fake)\",\n\t\t},\n\t\t{\n\t\t\tSetOpts{\n\t\t\t\tUser:    &User{Name: \"fake\"},\n\t\t\t\tVars:    Vars{\"FOO\": &configVal, \"BAR\": &configVal},\n\t\t\t\tMessage: \"important things\",\n\t\t\t},\n\t\t\t\"Set BAR, FOO config vars (fake: 'important things')\",\n\t\t},\n\t\t{\n\t\t\tSetOpts{\n\t\t\t\tUser: &User{Name: \"fake\"},\n\t\t\t\tVars: Vars{\"FOO\": nil},\n\t\t\t},\n\t\t\t\"Unset FOO config var (fake)\",\n\t\t},\n\t\t{\n\t\t\tSetOpts{\n\t\t\t\tUser:    &User{Name: \"fake\"},\n\t\t\t\tVars:    Vars{\"FOO\": nil, \"BAR\": nil},\n\t\t\t\tMessage: \"important things\",\n\t\t\t},\n\t\t\t\"Unset BAR, FOO config vars (fake: 'important things')\",\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\td := configsApplyReleaseDesc(tt.in)\n\n\t\tif got, want := d, tt.out; got != want {\n\t\t\tt.Errorf(\"configsApplyReleaseDesc => want %v; got %v\", want, got)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "constraints.go",
          "type": "blob",
          "size": 1.673828125,
          "content": "package empire\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t. \"github.com/remind101/empire/pkg/bytesize\"\n\t\"github.com/remind101/empire/pkg/constraints\"\n)\n\nvar (\n\tConstraints1X = Constraints{constraints.CPUShare(256), constraints.Memory(512 * MB), constraints.Nproc(256)}\n\tConstraints2X = Constraints{constraints.CPUShare(512), constraints.Memory(1 * GB), constraints.Nproc(512)}\n\tConstraintsPX = Constraints{constraints.CPUShare(1024), constraints.Memory(6 * GB), 0}\n\n\t// NamedConstraints maps a heroku dynos size to a Constraints.\n\tNamedConstraints = map[string]Constraints{\n\t\t\"1X\": Constraints1X,\n\t\t\"2X\": Constraints2X,\n\t\t\"PX\": ConstraintsPX,\n\t}\n\n\t// DefaultConstraints defaults to 1X process size.\n\tDefaultConstraints = Constraints1X\n)\n\n// Constraints aliases the constraints.Constraints type to implement the\n// json.Unmarshaller interface.\ntype Constraints constraints.Constraints\n\nfunc parseConstraints(con string) (*Constraints, error) {\n\tif con == \"\" {\n\t\treturn nil, nil\n\t}\n\n\tif n, ok := NamedConstraints[con]; ok {\n\t\tc := Constraints(n)\n\t\treturn &c, nil\n\t}\n\n\tc, err := constraints.Parse(con)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tr := Constraints(c)\n\treturn &r, nil\n}\n\nfunc (c *Constraints) UnmarshalJSON(b []byte) error {\n\tvar s string\n\n\tif err := json.Unmarshal(b, &s); err != nil {\n\t\treturn err\n\t}\n\n\tcc, err := parseConstraints(s)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif cc != nil {\n\t\t*c = *cc\n\t}\n\n\treturn nil\n}\n\nfunc (c Constraints) String() string {\n\tfor n, constraint := range NamedConstraints {\n\t\tif c == Constraints(constraint) {\n\t\t\treturn n\n\t\t}\n\t}\n\n\tif c.Nproc == 0 {\n\t\treturn fmt.Sprintf(\"%d:%s\", c.CPUShare, c.Memory)\n\t} else {\n\t\treturn fmt.Sprintf(\"%d:%s:nproc=%d\", c.CPUShare, c.Memory, c.Nproc)\n\t}\n}\n"
        },
        {
          "name": "constraints_test.go",
          "type": "blob",
          "size": 1.4052734375,
          "content": "package empire\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"testing\"\n\n\t. \"github.com/remind101/empire/pkg/bytesize\"\n\t\"github.com/remind101/empire/pkg/constraints\"\n)\n\nfunc TestConstraints_UnmarshalJSON(t *testing.T) {\n\ttests := []struct {\n\t\tin  string\n\t\tout Constraints\n\t\terr error\n\t}{\n\t\t{\"512:1KB\", Constraints{512, 1024, 0}, nil},\n\t\t{\"512:1KB:nproc=512\", Constraints{512, 1024, 512}, nil},\n\t\t{\"1025:1KB\", Constraints{1025, 1024, 0}, nil},\n\t\t{\"0:1KB\", Constraints{}, constraints.ErrInvalidCPUShare},\n\n\t\t{\"1024\", Constraints{}, constraints.ErrInvalidConstraint},\n\t}\n\n\tfor i, tt := range tests {\n\t\tvar c Constraints\n\n\t\terr := json.Unmarshal([]byte(fmt.Sprintf(`\"%s\"`, tt.in)), &c)\n\t\tif err != tt.err {\n\t\t\tt.Fatalf(\"#%d: err => %v; want %v\", i, err, tt.err)\n\t\t}\n\n\t\tif tt.err != nil {\n\t\t\tcontinue\n\t\t}\n\n\t\tif got, want := c, tt.out; !reflect.DeepEqual(got, want) {\n\t\t\tt.Fatalf(\"#%d: Constraints => %v; want %v\", i, got, want)\n\t\t}\n\t}\n}\n\nfunc TestConstraints_String(t *testing.T) {\n\ttests := []struct {\n\t\tin  Constraints\n\t\tout string\n\t}{\n\t\t// Named constraints\n\t\t{Constraints1X, \"1X\"},\n\t\t{Constraints2X, \"2X\"},\n\t\t{ConstraintsPX, \"PX\"},\n\n\t\t{Constraints{100, constraints.Memory(1 * MB), 0}, \"100:1.00mb\"},\n\t\t{Constraints{100, constraints.Memory(1 * MB), 512}, \"100:1.00mb:nproc=512\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tout := tt.in.String()\n\n\t\tif got, want := out, tt.out; got != want {\n\t\t\tt.Fatalf(\".String() => %s; want %s\", got, want)\n\t\t}\n\t}\n}\n"
        },
        {
          "name": "contrib",
          "type": "tree",
          "content": null
        },
        {
          "name": "db.go",
          "type": "blob",
          "size": 6.193359375,
          "content": "package empire\n\nimport (\n\t\"database/sql\"\n\t\"fmt\"\n\t\"net/url\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/internal/migrate\"\n\t\"github.com/remind101/empire/pkg/headerutil\"\n)\n\n// Empire only supports postgres at the moment.\nconst DBDriver = \"postgres\"\n\n// IncompatibleSchemaError is an error that gets returned from\n// CheckSchemaVersion.\ntype IncompatibleSchemaError struct {\n\tSchemaVersion         int\n\tExpectedSchemaVersion int\n}\n\n// Error implements the error interface.\nfunc (e *IncompatibleSchemaError) Error() string {\n\treturn fmt.Sprintf(\"expected database schema to be at version %d, but was %d\", e.ExpectedSchemaVersion, e.SchemaVersion)\n}\n\n// DB wraps a gorm.DB and provides the datastore layer for Empire.\ntype DB struct {\n\t// Schema is the Schema instance that will be used to migrate the\n\t// database to the latest schema. The zero value is DefaultSchema.\n\tSchema *Schema\n\n\t*gorm.DB\n\n\turi string\n\n\tmigrator *migrate.Migrator\n}\n\n// OpenDB returns a new gorm.DB instance.\nfunc OpenDB(uri string) (*DB, error) {\n\t_, err := url.Parse(uri)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tconn, err := sql.Open(DBDriver, uri)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn NewDB(conn)\n}\n\n// NewDB wraps a sql.DB instance as a DB.\nfunc NewDB(conn *sql.DB) (*DB, error) {\n\tdb, err := gorm.Open(DBDriver, conn)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tm := migrate.NewPostgresMigrator(conn)\n\t// Run all migrations in a single transaction, so they will be rolled\n\t// back as one. This is almost always the behavior that users would want\n\t// when upgrading Empire. If a new release has multiple migrations, and\n\t// one of those fails, it's easier for them if the entire upgrade rolls\n\t// back instead of getting stuck in failed state.\n\tm.TransactionMode = migrate.SingleTransaction\n\n\treturn &DB{\n\t\tDB:       &db,\n\t\tmigrator: m,\n\t}, nil\n}\n\n// MigrateUp migrates the database to the latest version of the schema.\nfunc (db *DB) MigrateUp() error {\n\treturn db.migrator.Exec(migrate.Up, db.migrations()...)\n}\n\nfunc (db *DB) migrations() []migrate.Migration {\n\treturn db.schema().migrations()\n}\n\n// Reset resets the database to a pristine state.\nfunc (db *DB) Reset() error {\n\tvar err error\n\texec := func(sql string) {\n\t\tif err == nil {\n\t\t\terr = db.Exec(sql).Error\n\t\t}\n\t}\n\n\texec(`TRUNCATE TABLE apps CASCADE`)\n\texec(`TRUNCATE TABLE ports CASCADE`)\n\texec(`TRUNCATE TABLE slugs CASCADE`)\n\texec(`UPDATE ports SET app_id = NULL`)\n\n\treturn err\n}\n\n// IsHealthy checks that we can connect to the database.\nfunc (db *DB) IsHealthy() error {\n\tif err := db.DB.DB().Ping(); err != nil {\n\t\treturn err\n\t}\n\n\tif err := db.CheckSchemaVersion(); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// CheckSchemaVersion verifies that the actual database schema matches the\n// version that this version of Empire expects.\nfunc (db *DB) CheckSchemaVersion() error {\n\tschemaVersion, err := db.SchemaVersion()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error fetching schema version: %v\", err)\n\t}\n\n\texpectedSchemaVersion := db.schema().latestSchema()\n\tif schemaVersion != expectedSchemaVersion {\n\t\treturn &IncompatibleSchemaError{\n\t\t\tSchemaVersion:         schemaVersion,\n\t\t\tExpectedSchemaVersion: expectedSchemaVersion,\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// SchemaVersion returns the current schema version.\nfunc (db *DB) SchemaVersion() (int, error) {\n\tsql := `select version from schema_migrations order by version desc limit 1`\n\tvar schemaVersion int\n\terr := db.DB.DB().QueryRow(sql).Scan(&schemaVersion)\n\treturn schemaVersion, err\n}\n\n// Debug puts the db in debug mode, which logs all queries.\nfunc (db *DB) Debug() {\n\tdb.DB = db.DB.Debug()\n}\n\nfunc (db *DB) schema() *Schema {\n\tif db.Schema == nil {\n\t\treturn DefaultSchema\n\t}\n\treturn db.Schema\n}\n\n// scope is an interface that scopes a gorm.DB. Scopes are used in\n// ThingsFirst and ThingsAll methods on the store for filtering/querying.\ntype scope interface {\n\tscope(*gorm.DB) *gorm.DB\n}\n\n// scopeFunc implements the scope interface for functions.\ntype scopeFunc func(*gorm.DB) *gorm.DB\n\n// scope implements the scope interface.\nfunc (f scopeFunc) scope(db *gorm.DB) *gorm.DB {\n\treturn f(db)\n}\n\n// idEquals returns a scope that will find the item by id.\nfunc idEquals(id string) scope {\n\treturn fieldEquals(\"id\", id)\n}\n\n// forApp returns a scope that will filter items belonging the the given app.\nfunc forApp(app *App) scope {\n\treturn fieldEquals(\"app_id\", app.ID)\n}\n\n// composedScope is an implementation of the Scope interface that chains the\n// scopes together.\ntype composedScope []scope\n\n// scope implements the scope interface.\nfunc (s composedScope) scope(db *gorm.DB) *gorm.DB {\n\tfor _, s := range s {\n\t\tdb = s.scope(db)\n\t}\n\n\treturn db\n}\n\n// fieldEquals returns a scope that filters on a field.\nfunc fieldEquals(field string, v interface{}) scope {\n\treturn scopeFunc(func(db *gorm.DB) *gorm.DB {\n\t\treturn db.Where(fmt.Sprintf(\"%s = ?\", field), v)\n\t})\n}\n\nfunc isNull(field string) scope {\n\treturn scopeFunc(func(db *gorm.DB) *gorm.DB {\n\t\treturn db.Where(fmt.Sprintf(\"%s is null\", field))\n\t})\n}\n\n// preload returns a scope that preloads the associations.\nfunc preload(associations ...string) scope {\n\tvar scope composedScope\n\n\tfor _, a := range associations {\n\t\taa := a\n\t\tscope = append(scope, scopeFunc(func(db *gorm.DB) *gorm.DB {\n\t\t\treturn db.Preload(aa)\n\t\t}))\n\t}\n\n\treturn scope\n}\n\n// order returns a scope that orders the results.\nfunc order(order string) scope {\n\treturn scopeFunc(func(db *gorm.DB) *gorm.DB {\n\t\treturn db.Order(order)\n\t})\n}\n\n// limit returns a scope that limits the results.\nfunc limit(limit int) scope {\n\treturn scopeFunc(func(db *gorm.DB) *gorm.DB {\n\t\treturn db.Limit(limit)\n\t})\n}\n\n// inRange returns a scope that limits and orders the results.\nfunc inRange(r headerutil.Range) scope {\n\tvar scope composedScope\n\n\tif r.Max != nil {\n\t\tscope = append(scope, limit(*r.Max))\n\t}\n\n\tif r.Sort != nil && r.Order != nil {\n\t\to := fmt.Sprintf(\"%s %s\", *r.Sort, *r.Order)\n\t\tscope = append(scope, order(o))\n\t}\n\n\treturn scope\n}\n\n// first is a small helper that finds the first record matching a scope, and\n// returns the error.\nfunc first(db *gorm.DB, scope scope, v interface{}) error {\n\treturn scope.scope(db).First(v).Error\n}\n\n// find is a small helper that finds records matching the scope, and returns the\n// error.\nfunc find(db *gorm.DB, scope scope, v interface{}) error {\n\treturn scope.scope(db).Find(v).Error\n}\n"
        },
        {
          "name": "db_test.go",
          "type": "blob",
          "size": 1.701171875,
          "content": "package empire\n\nimport (\n\t\"reflect\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\tgosql \"database/sql\"\n\n\t\"github.com/jinzhu/gorm\"\n)\n\nfunc TestComposedScope(t *testing.T) {\n\tvar scope composedScope\n\n\ta, b := make(chan struct{}), make(chan struct{})\n\n\tscope = append(scope, MockScope(a))\n\tscope = append(scope, MockScope(b))\n\n\tdb := &gorm.DB{}\n\n\tgo scope.scope(db)\n\n\tselect {\n\tcase <-a:\n\tcase <-time.After(time.Second):\n\t\tt.Fatal(\"Expected a to be called\")\n\t}\n\n\tselect {\n\tcase <-b:\n\tdefault:\n\t\tt.Fatal(\"Expected b to be called\")\n\t}\n}\n\n// MockScope is a Scope implementation that closes the channel when it is\n// called.\nfunc MockScope(called chan struct{}) scope {\n\treturn scopeFunc(func(db *gorm.DB) *gorm.DB {\n\t\tclose(called)\n\t\treturn db\n\t})\n}\n\n// scopeTest is a struct for testing scopes.\ntype scopeTest struct {\n\tscope scope\n\tsql   string\n\tvars  []interface{}\n}\n\n// scopeTests provides a convenient way to run assertScopeSql on multiple\n// scopeTest instances.\ntype scopeTests []scopeTest\n\n// Run calls assertScopeSql for each scopeTest.\nfunc (tests scopeTests) Run(t testing.TB) {\n\tfor i, tt := range tests {\n\t\tsql, vars := conditionSql(tt.scope)\n\n\t\tif got, want := sql, tt.sql; got != want {\n\t\t\tt.Fatalf(\"#%d: SQL => %v; want %v\", i, got, want)\n\t\t}\n\n\t\tif got, want := vars, tt.vars; !reflect.DeepEqual(got, want) {\n\t\t\tif len(got) > 0 && len(want) > 0 {\n\t\t\t\tt.Fatalf(\"#%d: Vars => %v; want %v\", i, got, want)\n\t\t\t}\n\t\t}\n\t}\n}\n\n// conditionSql takes a scope and generates the condition sql that gorm will use\n// for the query.\nfunc conditionSql(scope scope) (sql string, vars []interface{}) {\n\tdb, _ := gorm.Open(\"postgres\", &gosql.DB{})\n\tds := scope.scope(&db).NewScope(nil)\n\tsql = strings.TrimSpace(ds.CombinedConditionSql())\n\tvars = ds.SqlVars\n\treturn\n}\n"
        },
        {
          "name": "dbtest",
          "type": "tree",
          "content": null
        },
        {
          "name": "deployments.go",
          "type": "blob",
          "size": 3.5849609375,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/pkg/jsonmessage\"\n\t\"github.com/remind101/empire/twelvefactor\"\n\t\"golang.org/x/net/context\"\n)\n\n// deployerService is an implementation of the deployer interface that performs\n// the core business logic to deploy.\ntype deployerService struct {\n\t*Empire\n}\n\n// createRelease creates a new release that can be deployed\nfunc (s *deployerService) createRelease(ctx context.Context, db *gorm.DB, ss twelvefactor.StatusStream, opts DeployOpts) (*Release, error) {\n\tapp, img := opts.App, opts.Image\n\n\t// If no app is specified, attempt to find the app that relates to this\n\t// images repository, or create it if not found.\n\tif app == nil {\n\t\tvar err error\n\t\tapp, err = appsFindOrCreateByRepo(db, img.Repository)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// If the app doesn't already have a repo attached to it, we'll attach\n\t\t// this image's repo.\n\t\tif err := appsEnsureRepo(db, app, img.Repository); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Grab the latest config.\n\tconfig, err := s.configs.Config(db, app)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new slug for the docker image.\n\tslug, err := s.slugs.Create(ctx, db, img, opts.Output)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new release for the Config\n\t// and Slug.\n\tdesc := fmt.Sprintf(\"Deploy %s\", img.String())\n\tdesc = appendMessageToDescription(desc, opts.User, opts.Message)\n\n\tr, err := s.releases.Create(ctx, db, &Release{\n\t\tApp:         app,\n\t\tConfig:      config,\n\t\tSlug:        slug,\n\t\tDescription: desc,\n\t})\n\treturn r, err\n}\n\nfunc (s *deployerService) createInTransaction(ctx context.Context, stream twelvefactor.StatusStream, opts DeployOpts) (*Release, error) {\n\ttx := s.db.Begin()\n\tr, err := s.createRelease(ctx, tx, stream, opts)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn r, err\n\t}\n\treturn r, tx.Commit().Error\n}\n\n// Deploy is a thin wrapper around deploy to that adds the error to the\n// jsonmessage stream.\nfunc (s *deployerService) Deploy(ctx context.Context, opts DeployOpts) (*Release, error) {\n\tw := opts.Output\n\n\tvar stream twelvefactor.StatusStream\n\tif opts.Stream {\n\t\tstream = w\n\t}\n\n\tr, err := s.createInTransaction(ctx, stream, opts)\n\tif err != nil {\n\t\treturn r, w.Error(err)\n\t}\n\n\tif err := w.Status(fmt.Sprintf(\"Created new release v%d for %s\", r.Version, r.App.Name)); err != nil {\n\t\treturn r, err\n\t}\n\n\tif err := s.releases.Release(ctx, r, stream); err != nil {\n\t\treturn r, w.Error(err)\n\t}\n\n\treturn r, w.Status(fmt.Sprintf(\"Finished processing events for release v%d of %s\", r.Version, r.App.Name))\n}\n\n// DeploymentStream provides a wrapper around an io.Writer for writing\n// jsonmessage statuses, and implements the scheduler.StatusStream interface.\ntype DeploymentStream struct {\n\t*jsonmessage.Stream\n}\n\n// NewDeploymentStream wraps the io.Writer as a DeploymentStream.\nfunc NewDeploymentStream(w io.Writer) *DeploymentStream {\n\treturn &DeploymentStream{jsonmessage.NewStream(w)}\n}\n\n// Publish implements the scheduler.StatusStream interface.\nfunc (w *DeploymentStream) Publish(status twelvefactor.Status) error {\n\treturn w.Status(status.Message)\n}\n\n// Status writes a simple status update to the jsonmessage stream.\nfunc (w *DeploymentStream) Status(message string) error {\n\tm := jsonmessage.JSONMessage{Status: fmt.Sprintf(\"Status: %s\", message)}\n\treturn w.Encode(m)\n}\n\n// Error writes the error to the jsonmessage stream. The error that is provided\n// is also returned, so that Error() can be used in return values.\nfunc (w *DeploymentStream) Error(err error) error {\n\tif encErr := w.Encode(jsonmessage.NewError(err)); encErr != nil {\n\t\treturn encErr\n\t}\n\treturn err\n}\n"
        },
        {
          "name": "doc.go",
          "type": "blob",
          "size": 0.4150390625,
          "content": "// Package empire provides the core internal API to Empire. This provides a\n// simple API for performing actions like creating applications, setting\n// environment variables and performing deployments.\n//\n// Consumers of this API are usually in-process control layers, like the Heroku\n// Platform API compatibility layer, and the GitHub Deployments integration,\n// which can be found under the server package.\npackage empire\n"
        },
        {
          "name": "docker-compose.test.yml",
          "type": "blob",
          "size": 0.4814453125,
          "content": "version: '2'\n\nservices:\n  tests:\n    build:\n      context: .\n      dockerfile: Dockerfile.test\n    entrypoint: make\n    command: test\n    links:\n      - db:db\n    volumes:\n      - \".:/go/src/github.com/remind101/empire\"\n    environment:\n      TEST_DATABASE_URL: \"postgres://postgres:postgres@db/postgres?sslmode=disable\"\n  db:\n    # Postgres 9\n    image: postgres@sha256:9aa0b86ae3be8de6f922441b913e8914e840c652b6880a642f42f98f5e2aaeaf\n    environment:\n      POSTGRES_HOST_AUTH_METHOD: trust\n\n"
        },
        {
          "name": "docker-compose.yml",
          "type": "blob",
          "size": 0.4775390625,
          "content": "version: '2'\n\nservices:\n  server:\n    build: .\n    command: server -automigrate=true\n    links:\n      - db:db\n    ports:\n      - \"8080:8080\"\n    volumes:\n      - ~/.dockercfg:/root/.dockercfg\n      - \"/var/run/docker.sock:/var/run/docker.sock\"\n    env_file: .env\n    user: root\n    environment:\n      EMPIRE_DATABASE_URL: postgres://postgres:postgres@db/postgres?sslmode=disable\n      DOCKER_HOST: unix:///var/run/docker.sock\n      EMPIRE_X_SHOW_ATTACHED: 'true'\n  db:\n    image: postgres\n"
        },
        {
          "name": "docs",
          "type": "tree",
          "content": null
        },
        {
          "name": "domains.go",
          "type": "blob",
          "size": 2.8935546875,
          "content": "package empire\n\nimport (\n\t\"golang.org/x/net/context\"\n\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/pkg/timex\"\n)\n\ntype Domain struct {\n\tID        string\n\tHostname  string\n\tCreatedAt *time.Time\n\n\tAppID string\n\tApp   *App\n}\n\nfunc (d *Domain) BeforeCreate() error {\n\tt := timex.Now()\n\td.CreatedAt = &t\n\treturn nil\n}\n\ntype domainsService struct {\n\t*Empire\n}\n\nfunc (s *domainsService) DomainsCreate(ctx context.Context, db *gorm.DB, domain *Domain) (*Domain, error) {\n\td, err := domainsFind(db, DomainsQuery{Hostname: &domain.Hostname})\n\tif err != nil && err != gorm.RecordNotFound {\n\t\treturn domain, err\n\t}\n\n\tif err != gorm.RecordNotFound {\n\t\tif d.AppID == domain.AppID {\n\t\t\treturn domain, ErrDomainAlreadyAdded\n\t\t} else {\n\t\t\treturn domain, ErrDomainInUse\n\t\t}\n\t}\n\n\t_, err = domainsCreate(db, domain)\n\tif err != nil {\n\t\treturn domain, err\n\t}\n\n\tif err := makePublic(db, domain.AppID); err != nil {\n\t\treturn domain, err\n\t}\n\n\treturn domain, err\n}\n\nfunc (s *domainsService) DomainsDestroy(ctx context.Context, db *gorm.DB, domain *Domain) error {\n\tif err := domainsDestroy(db, domain); err != nil {\n\t\treturn err\n\t}\n\n\t// If app has no domains associated, make it private\n\td, err := domains(db, DomainsQuery{App: domain.App})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif len(d) == 0 {\n\t\tif err := makePrivate(db, domain.AppID); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// DomainsQuery is a scope implementation for common things to filter releases\n// by.\ntype DomainsQuery struct {\n\t// If provided, finds domains matching the given hostname.\n\tHostname *string\n\n\t// If provided, filters domains belonging to the given app.\n\tApp *App\n}\n\n// scope implements the scope interface.\nfunc (q DomainsQuery) scope(db *gorm.DB) *gorm.DB {\n\tvar scope composedScope\n\n\tif q.Hostname != nil {\n\t\tscope = append(scope, fieldEquals(\"hostname\", *q.Hostname))\n\t}\n\n\tif q.App != nil {\n\t\tscope = append(scope, forApp(q.App))\n\t}\n\n\treturn scope.scope(db)\n}\n\n// domainsFind returns the first matching domain.\nfunc domainsFind(db *gorm.DB, scope scope) (*Domain, error) {\n\tvar domain Domain\n\treturn &domain, first(db, scope, &domain)\n}\n\n// domains returns all domains matching the scope.\nfunc domains(db *gorm.DB, scope scope) ([]*Domain, error) {\n\tvar domains []*Domain\n\treturn domains, find(db, scope, &domains)\n}\n\nfunc domainsCreate(db *gorm.DB, domain *Domain) (*Domain, error) {\n\treturn domain, db.Create(domain).Error\n}\n\nfunc domainsDestroy(db *gorm.DB, domain *Domain) error {\n\treturn db.Delete(domain).Error\n}\n\nfunc makePublic(db *gorm.DB, appID string) error {\n\ta, err := appsFind(db, AppsQuery{ID: &appID})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.Exposure = \"public\"\n\tif err := appsUpdate(db, a); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc makePrivate(db *gorm.DB, appID string) error {\n\ta, err := appsFind(db, AppsQuery{ID: &appID})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\ta.Exposure = \"private\"\n\tif err := appsUpdate(db, a); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "domains_test.go",
          "type": "blob",
          "size": 0.3740234375,
          "content": "package empire\n\nimport \"testing\"\n\nfunc TestDomainsQuery(t *testing.T) {\n\thostname := \"acme-inc.classchirp.com\"\n\tapp := &App{ID: \"1234\"}\n\n\ttests := scopeTests{\n\t\t{DomainsQuery{}, \"\", []interface{}{}},\n\t\t{DomainsQuery{Hostname: &hostname}, \"WHERE (hostname = $1)\", []interface{}{hostname}},\n\t\t{DomainsQuery{App: app}, \"WHERE (app_id = $1)\", []interface{}{app.ID}},\n\t}\n\n\ttests.Run(t)\n}\n"
        },
        {
          "name": "empire.go",
          "type": "blob",
          "size": 18.123046875,
          "content": "package empire // import \"github.com/remind101/empire\"\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/pkg/image\"\n\t\"golang.org/x/net/context\"\n)\n\nconst (\n\t// webProcessType is the process type we assume are web server processes.\n\twebProcessType = \"web\"\n)\n\n// Various errors that may be returned.\nvar (\n\tErrDomainInUse        = errors.New(\"Domain currently in use by another app.\")\n\tErrDomainAlreadyAdded = errors.New(\"Domain already added to this app.\")\n\tErrDomainNotFound     = errors.New(\"Domain could not be found.\")\n\tErrUserName           = errors.New(\"Name is required\")\n\tErrNoReleases         = errors.New(\"no releases\")\n\t// ErrInvalidName is used to indicate that the app name is not valid.\n\tErrInvalidName = &ValidationError{\n\t\terrors.New(\"An app name must be alphanumeric and dashes only, 3-30 chars in length.\"),\n\t}\n)\n\n// AllowedCommands specifies what commands are allowed to be Run with Empire.\ntype AllowedCommands int\n\nconst (\n\t// AllowCommandAny will allow any command to be run.\n\tAllowCommandAny AllowedCommands = iota\n\t// AllowCommandProcfile will only allow commands specified in the\n\t// Procfile (the key itself) to be run. Any other command will return an\n\t// error.\n\tAllowCommandProcfile\n)\n\n// An error that is returned when a command is not whitelisted to be Run.\ntype CommandNotAllowedError struct {\n\tCommand Command\n}\n\n// commandNotInFormation returns a new CommandNotAllowedError for a command\n// that's not in the formation.\nfunc commandNotInFormation(command Command, formation Formation) *CommandNotAllowedError {\n\treturn &CommandNotAllowedError{Command: command}\n}\n\n// Error implements the error interface.\nfunc (c *CommandNotAllowedError) Error() string {\n\treturn fmt.Sprintf(\"command not allowed: %v\\n\", c.Command)\n}\n\n// NoCertError is returned when the Procfile specifies an https/ssl listener but\n// there is no attached certificate.\ntype NoCertError struct {\n\tProcess string\n}\n\nfunc (e *NoCertError) Error() string {\n\treturn fmt.Sprintf(\"the %s process does not have a certificate attached\", e.Process)\n}\n\n// Empire provides the core public API for Empire. Refer to the package\n// documentation for details.\ntype Empire struct {\n\tDB *DB\n\tdb *gorm.DB\n\n\tapps     *appsService\n\tconfigs  *configsService\n\tdomains  *domainsService\n\ttasks    *tasksService\n\treleases *releasesService\n\tdeployer *deployerService\n\trunner   *runnerService\n\tslugs    *slugsService\n\tcerts    *certsService\n\n\t// Scheduler is the backend scheduler used to run applications.\n\tScheduler Scheduler\n\n\t// LogsStreamer is the backend used to stream application logs.\n\tLogsStreamer LogsStreamer\n\n\t// ImageRegistry is used to interract with container images.\n\tImageRegistry ImageRegistry\n\n\t// Environment represents the environment this Empire server is responsible for\n\tEnvironment string\n\n\t// EventStream service for publishing Empire events.\n\tEventStream\n\n\t// RunRecorder is used to record the logs from interactive runs.\n\tRunRecorder RunRecorder\n\n\t// MessagesRequired is a boolean used to determine if messages should be required for events.\n\tMessagesRequired bool\n\n\t// Configures what type of commands are allowed to be run with the Run\n\t// method. The zero value allows all commands to be run.\n\tAllowedCommands AllowedCommands\n}\n\n// New returns a new Empire instance.\nfunc New(db *DB) *Empire {\n\te := &Empire{\n\t\tLogsStreamer: logsDisabled,\n\t\tEventStream:  NullEventStream,\n\n\t\tDB: db,\n\t\tdb: db.DB,\n\t}\n\n\te.apps = &appsService{Empire: e}\n\te.configs = &configsService{Empire: e}\n\te.deployer = &deployerService{Empire: e}\n\te.domains = &domainsService{Empire: e}\n\te.slugs = &slugsService{Empire: e}\n\te.tasks = &tasksService{Empire: e}\n\te.runner = &runnerService{Empire: e}\n\te.releases = &releasesService{Empire: e}\n\te.certs = &certsService{Empire: e}\n\treturn e\n}\n\n// AppsFind finds the first app matching the query.\nfunc (e *Empire) AppsFind(q AppsQuery) (*App, error) {\n\treturn appsFind(e.db, q)\n}\n\n// Apps returns all Apps.\nfunc (e *Empire) Apps(q AppsQuery) ([]*App, error) {\n\treturn apps(e.db, q)\n}\n\nfunc (e *Empire) requireMessages(m string) error {\n\tif e.MessagesRequired && m == \"\" {\n\t\treturn &MessageRequiredError{}\n\t}\n\treturn nil\n}\n\n// CreateOpts are options that are provided when creating a new application.\ntype CreateOpts struct {\n\t// User performing the action.\n\tUser *User\n\n\t// Name of the application.\n\tName string\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts CreateOpts) Event() CreateEvent {\n\treturn CreateEvent{\n\t\tUser:    opts.User.Name,\n\t\tName:    opts.Name,\n\t\tMessage: opts.Message,\n\t}\n}\n\nfunc (opts CreateOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Create creates a new app.\nfunc (e *Empire) Create(ctx context.Context, opts CreateOpts) (*App, error) {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn nil, err\n\t}\n\n\ta, err := appsCreate(e.db, &App{Name: opts.Name})\n\tif err != nil {\n\t\treturn a, err\n\t}\n\n\treturn a, e.PublishEvent(opts.Event())\n}\n\n// DestroyOpts are options provided when destroying an application.\ntype DestroyOpts struct {\n\t// User performing the action.\n\tUser *User\n\n\t// The associated app.\n\tApp *App\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts DestroyOpts) Event() DestroyEvent {\n\treturn DestroyEvent{\n\t\tUser:    opts.User.Name,\n\t\tApp:     opts.App.Name,\n\t\tMessage: opts.Message,\n\t}\n}\n\nfunc (opts DestroyOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Destroy destroys an app.\nfunc (e *Empire) Destroy(ctx context.Context, opts DestroyOpts) error {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn err\n\t}\n\n\ttx := e.db.Begin()\n\n\tif err := e.apps.Destroy(ctx, tx, opts.App); err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn e.PublishEvent(opts.Event())\n}\n\n// Config returns the current Config for a given app.\nfunc (e *Empire) Config(app *App) (*Config, error) {\n\ttx := e.db.Begin()\n\n\tc, err := e.configs.Config(tx, app)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn c, err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn c, err\n\t}\n\n\treturn c, nil\n}\n\ntype SetMaintenanceModeOpts struct {\n\t// User performing the action.\n\tUser *User\n\n\t// The associated app.\n\tApp *App\n\n\t// Wheather maintenance mode should be enabled or not.\n\tMaintenance bool\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts SetMaintenanceModeOpts) Event() MaintenanceEvent {\n\treturn MaintenanceEvent{\n\t\tUser:        opts.User.Name,\n\t\tApp:         opts.App.Name,\n\t\tMaintenance: opts.Maintenance,\n\t\tMessage:     opts.Message,\n\t}\n}\n\nfunc (opts SetMaintenanceModeOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// SetMaintenanceMode enables or disables \"maintenance mode\" on the app. When an\n// app is in maintenance mode, all processes will be scaled down to 0. When\n// taken out of maintenance mode, all processes will be scaled up back to their\n// existing values.\nfunc (e *Empire) SetMaintenanceMode(ctx context.Context, opts SetMaintenanceModeOpts) error {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn err\n\t}\n\n\ttx := e.db.Begin()\n\n\tapp := opts.App\n\n\tapp.Maintenance = opts.Maintenance\n\n\tif err := appsUpdate(tx, app); err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n\n\tif err := e.releases.ReleaseApp(ctx, tx, app, nil); err != nil {\n\t\ttx.Rollback()\n\t\tif err == ErrNoReleases {\n\t\t\treturn nil\n\t\t}\n\n\t\treturn err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn e.PublishEvent(opts.Event())\n}\n\n// SetOpts are options provided when setting new config vars on an app.\ntype SetOpts struct {\n\t// User performing the action.\n\tUser *User\n\n\t// The associated app.\n\tApp *App\n\n\t// The new vars to merge into the old config.\n\tVars Vars\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts SetOpts) Event() SetEvent {\n\tvar changed []string\n\tfor k := range opts.Vars {\n\t\tchanged = append(changed, string(k))\n\t}\n\n\treturn SetEvent{\n\t\tUser:    opts.User.Name,\n\t\tApp:     opts.App.Name,\n\t\tChanged: changed,\n\t\tMessage: opts.Message,\n\t\tapp:     opts.App,\n\t}\n}\n\nfunc (opts SetOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Set applies the new config vars to the apps current Config, returning the new\n// Config. If the app has a running release, a new release will be created and\n// run.\nfunc (e *Empire) Set(ctx context.Context, opts SetOpts) (*Config, error) {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttx := e.db.Begin()\n\n\tc, err := e.configs.Set(ctx, tx, opts)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn c, err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn c, err\n\t}\n\n\treturn c, e.PublishEvent(opts.Event())\n}\n\n// DomainsFind returns the first domain matching the query.\nfunc (e *Empire) DomainsFind(q DomainsQuery) (*Domain, error) {\n\treturn domainsFind(e.db, q)\n}\n\n// Domains returns all domains matching the query.\nfunc (e *Empire) Domains(q DomainsQuery) ([]*Domain, error) {\n\treturn domains(e.db, q)\n}\n\n// DomainsCreate adds a new Domain for an App.\nfunc (e *Empire) DomainsCreate(ctx context.Context, domain *Domain) (*Domain, error) {\n\ttx := e.db.Begin()\n\n\td, err := e.domains.DomainsCreate(ctx, tx, domain)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn d, err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn d, err\n\t}\n\n\treturn d, nil\n}\n\n// DomainsDestroy removes a Domain for an App.\nfunc (e *Empire) DomainsDestroy(ctx context.Context, domain *Domain) error {\n\ttx := e.db.Begin()\n\n\tif err := e.domains.DomainsDestroy(ctx, tx, domain); err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\n// Tasks returns the Tasks for the given app.\nfunc (e *Empire) Tasks(ctx context.Context, app *App) ([]*Task, error) {\n\treturn e.tasks.Tasks(ctx, app)\n}\n\n// RestartOpts are options provided when restarting an app.\ntype RestartOpts struct {\n\t// User performing the action.\n\tUser *User\n\n\t// The associated app.\n\tApp *App\n\n\t// If provided, a PID that will be killed. Generally used for killing\n\t// detached processes.\n\tPID string\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts RestartOpts) Event() RestartEvent {\n\treturn RestartEvent{\n\t\tUser:    opts.User.Name,\n\t\tApp:     opts.App.Name,\n\t\tPID:     opts.PID,\n\t\tMessage: opts.Message,\n\t\tapp:     opts.App,\n\t}\n}\n\nfunc (opts RestartOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Restart restarts processes matching the given prefix for the given Release.\n// If the prefix is empty, it will match all processes for the release.\nfunc (e *Empire) Restart(ctx context.Context, opts RestartOpts) error {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn err\n\t}\n\n\tif err := e.apps.Restart(ctx, e.db, opts); err != nil {\n\t\treturn err\n\t}\n\n\treturn e.PublishEvent(opts.Event())\n\n}\n\n// RunOpts are options provided when running an attached/detached process.\ntype RunOpts struct {\n\t// User performing this action.\n\tUser *User\n\n\t// Related app.\n\tApp *App\n\n\t// The command to run.\n\tCommand Command\n\n\t// Commit message\n\tMessage string\n\n\t// Input/Output streams. The caller is responsible for closing these\n\t// streams.\n\tStdin          io.Reader\n\tStdout, Stderr io.Writer\n\n\t// Extra environment variables to set.\n\tEnv map[string]string\n\n\t// Optional memory/cpu/nproc constraints.\n\tConstraints *Constraints\n}\n\nfunc (opts RunOpts) Event() RunEvent {\n\tvar attached bool\n\tif opts.Stdout != nil || opts.Stderr != nil {\n\t\tattached = true\n\t}\n\n\treturn RunEvent{\n\t\tUser:     opts.User.Name,\n\t\tApp:      opts.App.Name,\n\t\tCommand:  opts.Command,\n\t\tAttached: attached,\n\t\tMessage:  opts.Message,\n\t\tapp:      opts.App,\n\t}\n}\n\nfunc (opts RunOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Run runs a one-off process for a given App and command.\nfunc (e *Empire) Run(ctx context.Context, opts RunOpts) error {\n\tevent := opts.Event()\n\n\tif err := opts.Validate(e); err != nil {\n\t\treturn err\n\t}\n\n\tif e.RunRecorder != nil && (opts.Stdout != nil || opts.Stderr != nil) {\n\t\tw, err := e.RunRecorder()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Add the log url to the event, if there is one.\n\t\tif w, ok := w.(interface {\n\t\t\tURL() string\n\t\t}); ok {\n\t\t\tevent.URL = w.URL()\n\t\t}\n\n\t\tmsg := fmt.Sprintf(\"Running `%s` on %s as %s\", opts.Command, opts.App.Name, opts.User.Name)\n\t\tmsg = appendCommitMessage(msg, opts.Message)\n\t\tio.WriteString(w, fmt.Sprintf(\"%s\\n\", msg))\n\n\t\t// Write output to both the original output as well as the\n\t\t// record.\n\t\tif opts.Stdout != nil {\n\t\t\topts.Stdout = io.MultiWriter(w, opts.Stdout)\n\t\t}\n\t\tif opts.Stderr != nil {\n\t\t\topts.Stderr = io.MultiWriter(w, opts.Stderr)\n\t\t}\n\t}\n\n\tif err := e.PublishEvent(event); err != nil {\n\t\treturn err\n\t}\n\n\tif err := e.runner.Run(ctx, opts); err != nil {\n\t\treturn err\n\t}\n\n\tevent.Finish()\n\treturn e.PublishEvent(event)\n}\n\n// Releases returns all Releases for a given App.\nfunc (e *Empire) Releases(q ReleasesQuery) ([]*Release, error) {\n\treturn releases(e.db, q)\n}\n\n// ReleasesFind returns the first releases for a given App.\nfunc (e *Empire) ReleasesFind(q ReleasesQuery) (*Release, error) {\n\treturn releasesFind(e.db, q)\n}\n\n// RollbackOpts are options provided when rolling back to an old release.\ntype RollbackOpts struct {\n\t// The user performing the action.\n\tUser *User\n\n\t// The associated app.\n\tApp *App\n\n\t// The release version to rollback to.\n\tVersion int\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts RollbackOpts) Event() RollbackEvent {\n\treturn RollbackEvent{\n\t\tUser:    opts.User.Name,\n\t\tApp:     opts.App.Name,\n\t\tVersion: opts.Version,\n\t\tMessage: opts.Message,\n\t\tapp:     opts.App,\n\t}\n}\n\nfunc (opts RollbackOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Rollback rolls an app back to a specific release version. Returns a\n// new release.\nfunc (e *Empire) Rollback(ctx context.Context, opts RollbackOpts) (*Release, error) {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttx := e.db.Begin()\n\n\tr, err := e.releases.Rollback(ctx, tx, opts)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn r, err\n\t}\n\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn r, err\n\t}\n\n\treturn r, e.PublishEvent(opts.Event())\n}\n\n// DeployOpts represents options that can be passed when deploying to\n// an application.\ntype DeployOpts struct {\n\t// User the user that is triggering the deployment.\n\tUser *User\n\n\t// App is the app that is being deployed to.\n\tApp *App\n\n\t// Image is the image that's being deployed.\n\tImage image.Image\n\n\t// Environment is the environment where the image is being deployed\n\tEnvironment string\n\n\t// Output is a DeploymentStream where deployment output and events will\n\t// be streamed in jsonmessage format.\n\tOutput *DeploymentStream\n\n\t// Commit message\n\tMessage string\n\n\t// Stream boolean for whether or not a status stream should be created.\n\tStream bool\n}\n\nfunc (opts DeployOpts) Event() DeployEvent {\n\te := DeployEvent{\n\t\tUser:    opts.User.Name,\n\t\tImage:   opts.Image.String(),\n\t\tMessage: opts.Message,\n\t}\n\tif opts.App != nil {\n\t\te.App = opts.App.Name\n\t\te.app = opts.App\n\t}\n\n\treturn e\n}\n\nfunc (opts DeployOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Deploy deploys an image and streams the output to w.\nfunc (e *Empire) Deploy(ctx context.Context, opts DeployOpts) (*Release, error) {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn nil, err\n\t}\n\n\tr, err := e.deployer.Deploy(ctx, opts)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\n\tevent := opts.Event()\n\tevent.Release = r.Version\n\tevent.Environment = e.Environment\n\t// Deals with new app creation on first deploy\n\tif event.App == \"\" && r.App != nil {\n\t\tevent.App = r.App.Name\n\t\tevent.app = r.App\n\t}\n\n\treturn r, e.PublishEvent(event)\n}\n\ntype ProcessUpdate struct {\n\t// The process to scale.\n\tProcess string\n\n\t// The desired quantity of processes.\n\tQuantity int\n\n\t// If provided, new memory and CPU constraints for the process.\n\tConstraints *Constraints\n}\n\n// ScaleOpts are options provided when scaling a process.\ntype ScaleOpts struct {\n\t// User that's performing the action.\n\tUser *User\n\n\t// The associated app.\n\tApp *App\n\n\tUpdates []*ProcessUpdate\n\n\t// Commit message\n\tMessage string\n}\n\nfunc (opts ScaleOpts) Event() ScaleEvent {\n\te := ScaleEvent{\n\t\tUser:    opts.User.Name,\n\t\tApp:     opts.App.Name,\n\t\tMessage: opts.Message,\n\t\tapp:     opts.App,\n\t}\n\n\tvar updates []*ScaleEventUpdate\n\tfor _, up := range opts.Updates {\n\t\tevent := &ScaleEventUpdate{\n\t\t\tProcess:  up.Process,\n\t\t\tQuantity: up.Quantity,\n\t\t}\n\t\tif up.Constraints != nil {\n\t\t\tevent.Constraints = *up.Constraints\n\t\t}\n\t\tupdates = append(updates, event)\n\t}\n\te.Updates = updates\n\treturn e\n}\n\nfunc (opts ScaleOpts) Validate(e *Empire) error {\n\treturn e.requireMessages(opts.Message)\n}\n\n// Scale scales an apps processes.\nfunc (e *Empire) Scale(ctx context.Context, opts ScaleOpts) ([]*Process, error) {\n\tif err := opts.Validate(e); err != nil {\n\t\treturn nil, err\n\t}\n\n\ttx := e.db.Begin()\n\n\tps, err := e.apps.Scale(ctx, tx, opts)\n\tif err != nil {\n\t\ttx.Rollback()\n\t\treturn ps, err\n\t}\n\n\treturn ps, tx.Commit().Error\n}\n\n// ListScale lists the current scale settings for a given App\nfunc (e *Empire) ListScale(ctx context.Context, app *App) (Formation, error) {\n\treturn currentFormation(e.db, app)\n}\n\n// Streamlogs streams logs from an app.\nfunc (e *Empire) StreamLogs(app *App, w io.Writer, duration time.Duration) error {\n\tif err := e.LogsStreamer.StreamLogs(app, w, duration); err != nil {\n\t\treturn fmt.Errorf(\"error streaming logs: %v\", err)\n\t}\n\n\treturn nil\n}\n\ntype CertsAttachOpts struct {\n\t// The certificate to attach.\n\tCert string\n\t// The app to attach the cert to.\n\tApp *App\n\n\t// An optional process to attach the cert to. If not provided, \"web\"\n\t// will be used.\n\tProcess string\n}\n\n// CertsAttach attaches an SSL certificate to the app.\nfunc (e *Empire) CertsAttach(ctx context.Context, opts CertsAttachOpts) error {\n\ttx := e.db.Begin()\n\n\tif err := e.certs.CertsAttach(ctx, tx, opts); err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n\n\treturn tx.Commit().Error\n}\n\n// Reset resets empire.\nfunc (e *Empire) Reset() error {\n\treturn e.DB.Reset()\n}\n\n// IsHealthy returns true if Empire is healthy, which means it can connect to\n// the services it depends on.\nfunc (e *Empire) IsHealthy() error {\n\treturn e.DB.IsHealthy()\n}\n\n// ValidationError is returned when a model is not valid.\ntype ValidationError struct {\n\tErr error\n}\n\nfunc (e *ValidationError) Error() string {\n\treturn e.Err.Error()\n}\n\n// MessageRequiredError is an error implementation, which is returned by Empire\n// when a commit message is required for the operation.\ntype MessageRequiredError struct{}\n\nfunc (e *MessageRequiredError) Error() string {\n\treturn \"Missing required option: 'Message'\"\n}\n"
        },
        {
          "name": "empire.png",
          "type": "blob",
          "size": 23.8935546875,
          "content": null
        },
        {
          "name": "empire_test.go",
          "type": "blob",
          "size": 0.4228515625,
          "content": "package empire_test\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/remind101/empire\"\n\t\"github.com/remind101/empire/dbtest\"\n)\n\nfunc Example() {\n\t// Open a postgres connection.\n\tdb, _ := empire.OpenDB(*dbtest.DatabaseURL)\n\n\t// Migrate the database schema.\n\t_ = db.MigrateUp()\n\n\t// Initialize a new Empire instance.\n\te := empire.New(db)\n\n\t// Run operations against Empire.\n\tapps, _ := e.Apps(empire.AppsQuery{})\n\tfmt.Println(apps)\n\t// Output:\n\t// []\n}\n"
        },
        {
          "name": "empiretest",
          "type": "tree",
          "content": null
        },
        {
          "name": "events.go",
          "type": "blob",
          "size": 7.8583984375,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"strings\"\n)\n\ntype multiError struct {\n\tErrors []error\n}\n\nfunc (e *multiError) Error() string {\n\tpoints := make([]string, len(e.Errors))\n\tfor i, err := range e.Errors {\n\t\tpoints[i] = fmt.Sprintf(\"* %s\", err)\n\t}\n\n\treturn fmt.Sprintf(\n\t\t\"%d error(s) occurred:\\n\\n%s\",\n\t\tlen(e.Errors), strings.Join(points, \"\\n\"))\n}\n\nfunc appendCommitMessage(main, commit string) string {\n\toutput := main\n\tif commit != \"\" {\n\t\toutput = fmt.Sprintf(\"%s: '%s'\", main, commit)\n\t}\n\treturn output\n}\n\n// RunEvent is triggered when a user starts or stops a one off process.\ntype RunEvent struct {\n\tUser     string\n\tApp      string\n\tCommand  Command\n\tURL      string\n\tAttached bool\n\tMessage  string\n\tFinished bool\n\n\tapp *App\n}\n\nfunc (e RunEvent) Event() string {\n\treturn \"run\"\n}\n\nfunc (e *RunEvent) Finish() {\n\te.Finished = true\n}\n\nfunc (e RunEvent) String() string {\n\tattachment := \"detached\"\n\tif e.Attached {\n\t\tattachment = \"attached\"\n\t}\n\n\taction := \"started running\"\n\tif e.Finished {\n\t\taction = \"ran\"\n\t}\n\tmsg := fmt.Sprintf(\"%s %s `%s` (%s) on %s\", e.User, action, e.Command.String(), attachment, e.App)\n\tif e.URL != \"\" {\n\t\tmsg = fmt.Sprintf(\"%s (<%s|logs>)\", msg, e.URL)\n\t}\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e RunEvent) GetApp() *App {\n\treturn e.app\n}\n\n// RestartEvent is triggered when a user restarts an application.\ntype RestartEvent struct {\n\tUser    string\n\tApp     string\n\tPID     string\n\tMessage string\n\n\tapp *App\n}\n\nfunc (e RestartEvent) Event() string {\n\treturn \"restart\"\n}\n\nfunc (e RestartEvent) String() string {\n\tmsg := \"\"\n\tif e.PID == \"\" {\n\t\tmsg = fmt.Sprintf(\"%s restarted %s\", e.User, e.App)\n\t} else {\n\t\tmsg = fmt.Sprintf(\"%s restarted `%s` on %s\", e.User, e.PID, e.App)\n\t}\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e RestartEvent) GetApp() *App {\n\treturn e.app\n}\n\ntype MaintenanceEvent struct {\n\tUser        string\n\tApp         string\n\tMaintenance bool\n\tMessage     string\n\n\tapp *App\n}\n\nfunc (e MaintenanceEvent) Event() string {\n\treturn \"maintenance\"\n}\n\nfunc (e MaintenanceEvent) String() string {\n\tstate := \"disabled\"\n\tif e.Maintenance {\n\t\tstate = \"enabled\"\n\t}\n\tmsg := fmt.Sprintf(\"%s %s maintenance mode on %s\", e.User, state, e.App)\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e MaintenanceEvent) GetApp() *App {\n\treturn e.app\n}\n\ntype ScaleEventUpdate struct {\n\tProcess             string\n\tQuantity            int\n\tPreviousQuantity    int\n\tConstraints         Constraints\n\tPreviousConstraints Constraints\n}\n\n// ScaleEvent is triggered when a manual scaling event happens.\ntype ScaleEvent struct {\n\tUser    string\n\tApp     string\n\tUpdates []*ScaleEventUpdate\n\tMessage string\n\n\tapp *App\n}\n\nfunc (e ScaleEvent) Event() string {\n\treturn \"scale\"\n}\n\nfunc (e ScaleEvent) String() string {\n\tvar msg, sep string\n\tfor _, up := range e.Updates {\n\t\t// Deal with no new constraints by copying previous constraint settings.\n\t\tnewConstraints := up.Constraints\n\t\tpreviousConstraints := up.PreviousConstraints\n\t\tif newConstraints.CPUShare == 0 {\n\t\t\tnewConstraints.CPUShare = previousConstraints.CPUShare\n\t\t}\n\n\t\tif newConstraints.Memory == 0 {\n\t\t\tnewConstraints.Memory = previousConstraints.Memory\n\t\t}\n\n\t\tif newConstraints.Nproc == 0 {\n\t\t\tnewConstraints.Nproc = previousConstraints.Nproc\n\t\t}\n\n\t\tmsg += fmt.Sprintf(\n\t\t\t\"%s%s scaled `%s` on %s from %d(%s) to %d(%s)\",\n\t\t\tsep,\n\t\t\te.User,\n\t\t\tup.Process,\n\t\t\te.App,\n\t\t\tup.PreviousQuantity,\n\t\t\tup.PreviousConstraints,\n\t\t\tup.Quantity,\n\t\t\tnewConstraints,\n\t\t)\n\t\tsep = \"\\n\"\n\t}\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e ScaleEvent) GetApp() *App {\n\treturn e.app\n}\n\n// DeployEvent is triggered when a user deploys a new image to an app.\ntype DeployEvent struct {\n\tUser        string\n\tApp         string\n\tImage       string\n\tEnvironment string\n\tRelease     int\n\tMessage     string\n\n\tapp *App\n}\n\nfunc (e DeployEvent) Event() string {\n\treturn \"deploy\"\n}\n\nfunc (e DeployEvent) String() string {\n\tmsg := \"\"\n\tif e.App == \"\" {\n\t\tmsg = fmt.Sprintf(\"%s deployed %s\", e.User, e.Image)\n\t} else {\n\t\tmsg = fmt.Sprintf(\"%s deployed %s to %s %s (v%d)\", e.User, e.Image, e.App, e.Environment, e.Release)\n\t}\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e DeployEvent) GetApp() *App {\n\treturn e.app\n}\n\n// RollbackEvent is triggered when a user rolls back to an old version.\ntype RollbackEvent struct {\n\tUser    string\n\tApp     string\n\tVersion int\n\tMessage string\n\n\tapp *App\n}\n\nfunc (e RollbackEvent) Event() string {\n\treturn \"rollback\"\n}\n\nfunc (e RollbackEvent) String() string {\n\tmsg := fmt.Sprintf(\"%s rolled back %s to v%d\", e.User, e.App, e.Version)\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e RollbackEvent) GetApp() *App {\n\treturn e.app\n}\n\n// SetEvent is triggered when environment variables are changed on an\n// application.\ntype SetEvent struct {\n\tUser    string\n\tApp     string\n\tChanged []string\n\tMessage string\n\n\tapp *App\n}\n\nfunc (e SetEvent) Event() string {\n\treturn \"set\"\n}\n\nfunc (e SetEvent) String() string {\n\tmsg := fmt.Sprintf(\"%s changed environment variables on %s (%s)\", e.User, e.App, strings.Join(e.Changed, \", \"))\n\treturn appendCommitMessage(msg, e.Message)\n}\n\nfunc (e SetEvent) GetApp() *App {\n\treturn e.app\n}\n\n// CreateEvent is triggered when a user creates a new application.\ntype CreateEvent struct {\n\tUser    string\n\tName    string\n\tMessage string\n}\n\nfunc (e CreateEvent) Event() string {\n\treturn \"create\"\n}\n\nfunc (e CreateEvent) String() string {\n\tmsg := fmt.Sprintf(\"%s created %s\", e.User, e.Name)\n\treturn appendCommitMessage(msg, e.Message)\n}\n\n// DestroyEvent is triggered when a user destroys an application.\ntype DestroyEvent struct {\n\tUser    string\n\tApp     string\n\tMessage string\n}\n\nfunc (e DestroyEvent) Event() string {\n\treturn \"destroy\"\n}\n\nfunc (e DestroyEvent) String() string {\n\tmsg := fmt.Sprintf(\"%s destroyed %s\", e.User, e.App)\n\treturn appendCommitMessage(msg, e.Message)\n}\n\n// Event represents an event triggered within Empire.\ntype Event interface {\n\t// Returns the name of the event.\n\tEvent() string\n\n\t// Returns a human readable string about the event.\n\tString() string\n}\n\n// AppEvent is an Event that relates to a specific App.\ntype AppEvent interface {\n\tEvent\n\tGetApp() *App\n}\n\n// EventStream is an interface for publishing events that happen within\n// Empire.\ntype EventStream interface {\n\tPublishEvent(Event) error\n}\n\n// EventStreamFunc is a function that implements the Events interface.\ntype EventStreamFunc func(Event) error\n\nfunc (fn EventStreamFunc) PublishEvent(event Event) error {\n\treturn fn(event)\n}\n\n// NullEventStream an events service that does nothing.\nvar NullEventStream = EventStreamFunc(func(event Event) error {\n\treturn nil\n})\n\n// MultiEventStream is an EventStream implementation that publishes the event to multiple EventStreams, returning any errors after publishing to all streams.\ntype MultiEventStream []EventStream\n\nfunc (streams MultiEventStream) PublishEvent(e Event) error {\n\tresult := new(multiError)\n\tfor _, s := range streams {\n\t\tif err := s.PublishEvent(e); err != nil {\n\t\t\tresult.Errors = append(result.Errors, err)\n\t\t}\n\t}\n\tif len(result.Errors) == 0 {\n\t\treturn nil\n\t}\n\treturn result\n}\n\n// asyncEventStream wraps an array of EventStreams to publish events\n// asynchronously in a goroutine\ntype asyncEventStream struct {\n\te      EventStream\n\tevents chan Event\n}\n\n// AsyncEvents returns a new AsyncEventStream that will buffer upto 100 events\n// before applying backpressure.\nfunc AsyncEvents(e EventStream) EventStream {\n\ts := &asyncEventStream{\n\t\te:      e,\n\t\tevents: make(chan Event, 100),\n\t}\n\tgo s.start()\n\treturn s\n}\n\nfunc (e *asyncEventStream) PublishEvent(event Event) error {\n\te.events <- event\n\treturn nil\n}\n\nfunc (e *asyncEventStream) start() {\n\tfor event := range e.events {\n\t\terr := e.publishEvent(event)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"event stream error: %v\\n\", err)\n\t\t}\n\t}\n}\n\nfunc (e *asyncEventStream) publishEvent(event Event) (err error) {\n\tdefer func() {\n\t\tif v := recover(); v != nil {\n\t\t\tvar ok bool\n\t\t\tif err, ok = v.(error); ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\terr = fmt.Errorf(\"panic: %v\", v)\n\t\t}\n\t}()\n\terr = e.e.PublishEvent(event)\n\treturn\n}\n"
        },
        {
          "name": "events",
          "type": "tree",
          "content": null
        },
        {
          "name": "events_test.go",
          "type": "blob",
          "size": 7.849609375,
          "content": "package empire\n\nimport (\n\t\"errors\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestMultiEventStream(t *testing.T) {\n\tboom := errors.New(\"boom\")\n\ts := MultiEventStream{EventStreamFunc(func(event Event) error {\n\t\treturn boom\n\t})}\n\terr := s.PublishEvent(RunEvent{User: \"ejholmes\", App: \"acme-inc\", Command: []string{\"bash\"}})\n\tassert.EqualError(t, err, \"1 error(s) occurred:\\n\\n* boom\")\n\n}\n\nfunc TestEvents_String(t *testing.T) {\n\ttests := []struct {\n\t\tevent Event\n\t\tout   string\n\t}{\n\t\t// RunEvent\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", Command: []string{\"bash\"}}, \"ejholmes started running `bash` (detached) on acme-inc\"},\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", Command: []string{\"bash\"}, Finished: true}, \"ejholmes ran `bash` (detached) on acme-inc\"},\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", Attached: true, Command: []string{\"bash\"}}, \"ejholmes started running `bash` (attached) on acme-inc\"},\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", URL: \"https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#logEvent:group=runs;stream=dac6eaff-6e0b-4708-9277-9f38aea2f528\", Attached: true, Command: []string{\"bash\"}}, \"ejholmes started running `bash` (attached) on acme-inc (<https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#logEvent:group=runs;stream=dac6eaff-6e0b-4708-9277-9f38aea2f528|logs>)\"},\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", Command: []string{\"bash\"}, Message: \"commit message\"}, \"ejholmes started running `bash` (detached) on acme-inc: 'commit message'\"},\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", Attached: true, Command: []string{\"bash\"}, Message: \"commit message\"}, \"ejholmes started running `bash` (attached) on acme-inc: 'commit message'\"},\n\t\t{RunEvent{User: \"ejholmes\", App: \"acme-inc\", URL: \"https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#logEvent:group=runs;stream=dac6eaff-6e0b-4708-9277-9f38aea2f528\", Attached: true, Command: []string{\"bash\"}, Message: \"commit message\"}, \"ejholmes started running `bash` (attached) on acme-inc (<https://console.aws.amazon.com/cloudwatch/home?region=us-east-1#logEvent:group=runs;stream=dac6eaff-6e0b-4708-9277-9f38aea2f528|logs>): 'commit message'\"},\n\n\t\t// RestartEvent\n\t\t{RestartEvent{User: \"ejholmes\", App: \"acme-inc\"}, \"ejholmes restarted acme-inc\"},\n\t\t{RestartEvent{User: \"ejholmes\", App: \"acme-inc\", PID: \"abcd\"}, \"ejholmes restarted `abcd` on acme-inc\"},\n\t\t{RestartEvent{User: \"ejholmes\", App: \"acme-inc\", Message: \"commit message\"}, \"ejholmes restarted acme-inc: 'commit message'\"},\n\t\t{RestartEvent{User: \"ejholmes\", App: \"acme-inc\", PID: \"abcd\", Message: \"commit message\"}, \"ejholmes restarted `abcd` on acme-inc: 'commit message'\"},\n\n\t\t// MaintenanceEvent\n\t\t{MaintenanceEvent{User: \"ejholmes\", App: \"acme-inc\", Maintenance: false}, \"ejholmes disabled maintenance mode on acme-inc\"},\n\t\t{MaintenanceEvent{User: \"ejholmes\", App: \"acme-inc\", Maintenance: true}, \"ejholmes enabled maintenance mode on acme-inc\"},\n\t\t{MaintenanceEvent{User: \"ejholmes\", App: \"acme-inc\", Maintenance: true, Message: \"upgrading db\"}, \"ejholmes enabled maintenance mode on acme-inc: 'upgrading db'\"},\n\n\t\t// ScaleEvent\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 10, Constraints: Constraints{CPUShare: 1024, Memory: 1024}, PreviousQuantity: 5, PreviousConstraints: Constraints{CPUShare: 1024, Memory: 1024}},\n\t\t\t},\n\t\t}, \"ejholmes scaled `web` on acme-inc from 5(1024:1.00kb) to 10(1024:1.00kb)\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 5, Constraints: Constraints{CPUShare: 1024, Memory: 1024}, PreviousQuantity: 10, PreviousConstraints: Constraints{CPUShare: 1024, Memory: 1024}},\n\t\t\t},\n\t\t}, \"ejholmes scaled `web` on acme-inc from 10(1024:1.00kb) to 5(1024:1.00kb)\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 5, Constraints: Constraints{CPUShare: 1024, Memory: 1024}, PreviousQuantity: 5, PreviousConstraints: Constraints{CPUShare: 512, Memory: 1024}},\n\t\t\t},\n\t\t}, \"ejholmes scaled `web` on acme-inc from 5(512:1.00kb) to 5(1024:1.00kb)\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 10, PreviousQuantity: 5, PreviousConstraints: Constraints{CPUShare: 512, Memory: 1024}},\n\t\t\t},\n\t\t}, \"ejholmes scaled `web` on acme-inc from 5(512:1.00kb) to 10(512:1.00kb)\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 10, Constraints: Constraints{CPUShare: 1024, Memory: 1024}, PreviousQuantity: 5, PreviousConstraints: Constraints{CPUShare: 1024, Memory: 1024}},\n\t\t\t},\n\t\t\tMessage: \"commit message\",\n\t\t}, \"ejholmes scaled `web` on acme-inc from 5(1024:1.00kb) to 10(1024:1.00kb): 'commit message'\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 5, Constraints: Constraints{CPUShare: 1024, Memory: 1024}, PreviousQuantity: 10, PreviousConstraints: Constraints{CPUShare: 1024, Memory: 1024}},\n\t\t\t},\n\t\t\tMessage: \"commit message\",\n\t\t}, \"ejholmes scaled `web` on acme-inc from 10(1024:1.00kb) to 5(1024:1.00kb): 'commit message'\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 5, Constraints: Constraints{CPUShare: 1024, Memory: 1024}, PreviousQuantity: 5, PreviousConstraints: Constraints{CPUShare: 512, Memory: 1024}},\n\t\t\t},\n\t\t\tMessage: \"commit message\",\n\t\t}, \"ejholmes scaled `web` on acme-inc from 5(512:1.00kb) to 5(1024:1.00kb): 'commit message'\"},\n\t\t{ScaleEvent{\n\t\t\tUser: \"ejholmes\",\n\t\t\tApp:  \"acme-inc\",\n\t\t\tUpdates: []*ScaleEventUpdate{\n\t\t\t\t&ScaleEventUpdate{Process: \"web\", Quantity: 10, PreviousQuantity: 5, PreviousConstraints: Constraints{CPUShare: 512, Memory: 1024}},\n\t\t\t},\n\t\t\tMessage: \"commit message\",\n\t\t}, \"ejholmes scaled `web` on acme-inc from 5(512:1.00kb) to 10(512:1.00kb): 'commit message'\"},\n\n\t\t// DeployEvent\n\t\t{DeployEvent{User: \"ejholmes\", App: \"acme-inc\", Image: \"remind101/acme-inc:master\", Environment: \"production\", Release: 32}, \"ejholmes deployed remind101/acme-inc:master to acme-inc production (v32)\"},\n\t\t{DeployEvent{User: \"ejholmes\", Image: \"remind101/acme-inc:master\"}, \"ejholmes deployed remind101/acme-inc:master\"},\n\t\t{DeployEvent{User: \"ejholmes\", App: \"acme-inc\", Image: \"remind101/acme-inc:master\", Environment: \"production\", Release: 32, Message: \"commit message\"}, \"ejholmes deployed remind101/acme-inc:master to acme-inc production (v32): 'commit message'\"},\n\t\t{DeployEvent{User: \"ejholmes\", Image: \"remind101/acme-inc:master\", Message: \"commit message\"}, \"ejholmes deployed remind101/acme-inc:master: 'commit message'\"},\n\n\t\t// RollbackEvent\n\t\t{RollbackEvent{User: \"ejholmes\", App: \"acme-inc\", Version: 1}, \"ejholmes rolled back acme-inc to v1\"},\n\t\t{RollbackEvent{User: \"ejholmes\", App: \"acme-inc\", Version: 1, Message: \"commit message\"}, \"ejholmes rolled back acme-inc to v1: 'commit message'\"},\n\n\t\t// SetEvent\n\t\t{SetEvent{User: \"ejholmes\", App: \"acme-inc\", Changed: []string{\"RAILS_ENV\"}}, \"ejholmes changed environment variables on acme-inc (RAILS_ENV)\"},\n\t\t{SetEvent{User: \"ejholmes\", App: \"acme-inc\", Changed: []string{\"RAILS_ENV\"}, Message: \"commit message\"}, \"ejholmes changed environment variables on acme-inc (RAILS_ENV): 'commit message'\"},\n\n\t\t// CreateEvent\n\t\t{CreateEvent{User: \"ejholmes\", Name: \"acme-inc\"}, \"ejholmes created acme-inc\"},\n\t\t{CreateEvent{User: \"ejholmes\", Name: \"acme-inc\", Message: \"commit message\"}, \"ejholmes created acme-inc: 'commit message'\"},\n\n\t\t// DestroyEvent\n\t\t{DestroyEvent{User: \"ejholmes\", App: \"acme-inc\", Message: \"commit message\"}, \"ejholmes destroyed acme-inc: 'commit message'\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tout := tt.event.String()\n\t\tassert.Equal(t, tt.out, out)\n\t}\n}\n"
        },
        {
          "name": "internal",
          "type": "tree",
          "content": null
        },
        {
          "name": "logs.go",
          "type": "blob",
          "size": 0.337890625,
          "content": "package empire\n\nimport (\n\t\"io\"\n\t\"time\"\n)\n\ntype LogsStreamer interface {\n\tStreamLogs(*App, io.Writer, time.Duration) error\n}\n\nvar logsDisabled = &nullLogsStreamer{}\n\ntype nullLogsStreamer struct{}\n\nfunc (s *nullLogsStreamer) StreamLogs(app *App, w io.Writer, duration time.Duration) error {\n\tio.WriteString(w, \"Logs are disabled\\n\")\n\treturn nil\n}\n"
        },
        {
          "name": "logs",
          "type": "tree",
          "content": null
        },
        {
          "name": "migrations.go",
          "type": "blob",
          "size": 18.916015625,
          "content": "package empire\n\nimport (\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"sort\"\n\n\t\"github.com/lib/pq/hstore\"\n\t\"github.com/remind101/empire/internal/migrate\"\n\t\"github.com/remind101/empire/pkg/constraints\"\n\t\"github.com/remind101/empire/procfile\"\n)\n\nconst (\n\tDefaultInstancePortPoolStart = 9000\n\tDefaultInstancePortPoolEnd   = 10000\n)\n\n// DefaultSchema is the default Schema that will be used to migrate the database\n// if none is provided.\nvar DefaultSchema = &Schema{\n\tInstancePortPool: &InstancePortPool{\n\t\tStart: DefaultInstancePortPoolStart,\n\t\tEnd:   DefaultInstancePortPoolEnd,\n\t},\n}\n\ntype InstancePortPool struct {\n\tStart, End uint\n}\n\ntype Schema struct {\n\t// For legacy ELB's (not ALB) Empire manages a pool of host ports to\n\t// ensure that all applications have a unique port on the EC2 instance.\n\t// This option specifies the beginning and end of that range.\n\tInstancePortPool *InstancePortPool\n}\n\n// latestSchema returns the schema version that this version of Empire should be\n// using.\nfunc (s *Schema) latestSchema() int {\n\tmigrations := s.migrations()\n\treturn migrations[len(migrations)-1].ID\n}\n\nfunc (s *Schema) migrations() []migrate.Migration {\n\tports := migrate.Migration{\n\t\tID: 4,\n\t\tUp: func(tx *sql.Tx) error {\n\t\t\tconst table = `CREATE TABLE ports (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  port integer,\n  app_id uuid references apps(id) ON DELETE SET NULL\n)`\n\t\t\tif _, err := tx.Exec(table); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to create ports table: %v\", err)\n\t\t\t}\n\n\t\t\tports := fmt.Sprintf(`INSERT INTO ports (port) (SELECT generate_series(%d,%d))`, s.InstancePortPool.Start, s.InstancePortPool.End)\n\n\t\t\tif _, err := tx.Exec(ports); err != nil {\n\t\t\t\treturn fmt.Errorf(\"unable to generate a series of instance ports: %v\", err)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE ports CASCADE`,\n\t\t}),\n\t}\n\n\tmigrations := migrate.ByID(append(migrations, ports))\n\tsort.Sort(migrations)\n\n\treturn migrations\n}\n\nvar migrations = []migrate.Migration{\n\t{\n\t\tID: 1,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`CREATE EXTENSION IF NOT EXISTS hstore`,\n\t\t\t`CREATE EXTENSION IF NOT EXISTS \"uuid-ossp\"`,\n\t\t\t`CREATE TABLE apps (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  name varchar(30) NOT NULL,\n  github_repo text,\n  docker_repo text,\n  created_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t\t`CREATE TABLE configs (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id uuid NOT NULL references apps(id) ON DELETE CASCADE,\n  vars hstore,\n  created_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t\t`CREATE TABLE slugs (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  image text NOT NULL,\n  process_types hstore NOT NULL\n)`,\n\t\t\t`CREATE TABLE releases (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id uuid NOT NULL references apps(id) ON DELETE CASCADE,\n  config_id uuid NOT NULL references configs(id) ON DELETE CASCADE,\n  slug_id uuid NOT NULL references slugs(id) ON DELETE CASCADE,\n  version int NOT NULL,\n  description text,\n  created_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t\t`CREATE TABLE processes (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  release_id uuid NOT NULL references releases(id) ON DELETE CASCADE,\n  \"type\" text NOT NULL,\n  quantity int NOT NULL,\n  command text NOT NULL\n)`,\n\t\t\t`CREATE TABLE jobs (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id uuid NOT NULL references apps(id) ON DELETE CASCADE,\n  release_version int NOT NULL,\n  process_type text NOT NULL,\n  instance int NOT NULL,\n\n  environment hstore NOT NULL,\n  image text NOT NULL,\n  command text NOT NULL,\n  updated_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t\t`CREATE TABLE deployments (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id uuid NOT NULL references apps(id) ON DELETE CASCADE,\n  release_id uuid references releases(id),\n  image text NOT NULL,\n  status text NOT NULL,\n  error text,\n  created_at timestamp without time zone default (now() at time zone 'utc'),\n  finished_at timestamp without time zone\n)`,\n\t\t\t`CREATE UNIQUE INDEX index_apps_on_name ON apps USING btree (name)`,\n\t\t\t`CREATE UNIQUE INDEX index_apps_on_github_repo ON apps USING btree (github_repo)`,\n\t\t\t`CREATE UNIQUE INDEX index_apps_on_docker_repo ON apps USING btree (docker_repo)`,\n\t\t\t`CREATE UNIQUE INDEX index_processes_on_release_id_and_type ON processes USING btree (release_id, \"type\")`,\n\t\t\t`CREATE UNIQUE INDEX index_slugs_on_image ON slugs USING btree (image)`,\n\t\t\t`CREATE UNIQUE INDEX index_releases_on_app_id_and_version ON releases USING btree (app_id, version)`,\n\t\t\t`CREATE UNIQUE INDEX index_jobs_on_app_id_and_release_version_and_process_type_and_instance ON jobs (app_id, release_version, process_type, instance)`,\n\t\t\t`CREATE INDEX index_configs_on_created_at ON configs (created_at)`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE apps CASCADE`,\n\t\t\t`DROP TABLE configs CASCADE`,\n\t\t\t`DROP TABLE slugs CASCADE`,\n\t\t\t`DROP TABLE releases CASCADE`,\n\t\t\t`DROP TABLE processes CASCADE`,\n\t\t\t`DROP TABLE jobs CASCADE`,\n\t\t\t`DROP TABLE deployments CASCADE`,\n\t\t}),\n\t},\n\t{\n\t\tID: 2,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`CREATE TABLE domains (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id uuid NOT NULL references apps(id) ON DELETE CASCADE,\n  hostname text NOT NULL,\n  created_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t\t`CREATE INDEX index_domains_on_app_id ON domains USING btree (app_id)`,\n\t\t\t`CREATE UNIQUE INDEX index_domains_on_hostname ON domains USING btree (hostname)`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE domains CASCADE`,\n\t\t}),\n\t},\n\t{\n\t\tID: 3,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`DROP TABLE jobs`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`CREATE TABLE jobs (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id text NOT NULL references apps(name) ON DELETE CASCADE,\n  release_version int NOT NULL,\n  process_type text NOT NULL,\n  instance int NOT NULL,\n\n  environment hstore NOT NULL,\n  image text NOT NULL,\n  command text NOT NULL,\n  updated_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t}),\n\t},\n\t{\n\t\tID: 5,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps DROP COLUMN docker_repo`,\n\t\t\t`ALTER TABLE apps DROP COLUMN github_repo`,\n\t\t\t`ALTER TABLE apps ADD COLUMN repo text`,\n\t\t\t`DROP TABLE deployments`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps DROP COLUMN repo`,\n\t\t\t`ALTER TABLE apps ADD COLUMN docker_repo text`,\n\t\t\t`ALTER TABLE apps ADD COLUMN github_repo text`,\n\t\t\t`CREATE TABLE deployments (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id text NOT NULL references apps(name) ON DELETE CASCADE,\n  release_id uuid references releases(id),\n  image text NOT NULL,\n  status text NOT NULL,\n  error text,\n  created_at timestamp without time zone default (now() at time zone 'utc'),\n  finished_at timestamp without time zone\n)`,\n\t\t}),\n\t},\n\t{\n\t\tID: 6,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`DROP INDEX index_slugs_on_image`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`CREATE UNIQUE INDEX index_slugs_on_image ON slugs USING btree (image)`,\n\t\t}),\n\t},\n\t{\n\t\tID: 7,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`-- Values: private, public\nALTER TABLE apps ADD COLUMN exposure TEXT NOT NULL default 'private'`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps DROP COLUMN exposure`,\n\t\t}),\n\t},\n\t{\n\t\tID: 8,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`CREATE TABLE certificates (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  app_id uuid NOT NULL references apps(id) ON DELETE CASCADE,\n  name text,\n  certificate_chain text,\n  created_at timestamp without time zone default (now() at time zone 'utc'),\n  updated_at timestamp without time zone default (now() at time zone 'utc')\n)`,\n\t\t\t`CREATE UNIQUE INDEX index_certificates_on_app_id ON certificates USING btree (app_id)`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE certificates CASCADE`,\n\t\t}),\n\t},\n\t{\n\t\tID: 9,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes ADD COLUMN cpu_share int`,\n\t\t\t`ALTER TABLE processes ADD COLUMN memory int`,\n\t\t\t`UPDATE processes SET cpu_share = 256, memory = 1073741824`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes DROP COLUMN cpu_share`,\n\t\t\t`ALTER TABLE processes DROP COLUMN memory`,\n\t\t}),\n\t},\n\t{\n\t\tID: 10,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes ALTER COLUMN memory TYPE bigint`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes ALTER COLUMN memory TYPE integer`,\n\t\t}),\n\t},\n\t{\n\t\tID: 11,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps ADD COLUMN cert text`,\n\t\t\t`UPDATE apps SET cert = (select name from certificates where certificates.app_id = apps.id)`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps DROP COLUMN cert`,\n\t\t}),\n\t},\n\t{\n\t\tID: 12,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes ADD COLUMN nproc bigint`,\n\t\t\t`UPDATE processes SET nproc = 0`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes DROP COLUMN nproc`,\n\t\t}),\n\t},\n\t{\n\t\tID: 13,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE ports ADD COLUMN taken text`,\n\t\t\t`UPDATE ports SET taken = 't' FROM (SELECT port FROM ports WHERE app_id is not NULL) as used_ports WHERE ports.port = used_ports.port`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE ports DROP column taken`,\n\t\t}),\n\t},\n\n\t// This migration changes how we store commands from a plain string to a\n\t// []string.\n\t{\n\t\tID: 14,\n\t\tUp: func(tx *sql.Tx) error {\n\t\t\t_, err := tx.Exec(`ALTER TABLE slugs ADD COLUMN process_types_json json`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE processes ADD COLUMN command_json json`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Migrate the data in the slugs table\n\t\t\trows, err := tx.Query(`SELECT id, process_types FROM slugs`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tslugs := make(map[string]map[string]Command)\n\t\t\tfor rows.Next() {\n\t\t\t\tvar id string\n\t\t\t\tvar ptypes hstore.Hstore\n\t\t\t\tif err := rows.Scan(&id, &ptypes); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tm := make(map[string]Command)\n\t\t\t\tfor k, v := range ptypes.Map {\n\t\t\t\t\tcommand, err := ParseCommand(v.String)\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\tm[k] = command\n\t\t\t\t}\n\t\t\t\tslugs[id] = m\n\t\t\t}\n\n\t\t\tif err := rows.Err(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trows.Close()\n\n\t\t\tfor id, ptypes := range slugs {\n\t\t\t\traw, err := json.Marshal(ptypes)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t_, err = tx.Exec(`UPDATE slugs SET process_types_json = $1 WHERE id = $2`, raw, id)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE slugs DROP COLUMN process_types`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE slugs RENAME COLUMN process_types_json to process_types`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE slugs ALTER COLUMN process_types SET NOT NULL`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Migrate the data in the processes table.\n\t\t\trows, err = tx.Query(`SELECT id, command FROM processes`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcommands := make(map[string]string)\n\t\t\tfor rows.Next() {\n\t\t\t\tvar id, command string\n\t\t\t\tif err := rows.Scan(&id, &command); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tcommands[id] = command\n\t\t\t}\n\n\t\t\tif err := rows.Err(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trows.Close()\n\n\t\t\tfor id, command := range commands {\n\t\t\t\tcmd, err := ParseCommand(command)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tquery := `UPDATE processes SET command_json = $1 WHERE id = $2`\n\t\t\t\t_, err = tx.Exec(query, cmd, id)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE processes DROP COLUMN command`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE processes RENAME COLUMN command_json TO command`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE processes ALTER COLUMN command SET NOT NULL`)\n\t\t\treturn err\n\t\t},\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE processes DROP COLUMN command`,\n\t\t\t`ALTER TABLE processes ADD COLUMN command text not null`,\n\t\t\t`ALTER TABLE slugs DROP COLUMN process_types`,\n\t\t\t`ALTER TABLE slugs ADD COLUMN process_types hstore not null`,\n\t\t}),\n\t},\n\n\t// This migration changes that way we store process configuration for\n\t// releases and slugs, to instead store a Formation in JSON format.\n\t{\n\t\tID: 15,\n\t\tUp: func(tx *sql.Tx) error {\n\t\t\t_, err := tx.Exec(`ALTER TABLE slugs ADD COLUMN procfile bytea`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE releases ADD COLUMN formation json`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trows, err := tx.Query(`SELECT id, process_types FROM slugs`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tslugs := make(map[string]procfile.Procfile)\n\t\t\tfor rows.Next() {\n\t\t\t\tvar id string\n\t\t\t\tvar ptypes []byte\n\t\t\t\tif err := rows.Scan(&id, &ptypes); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tm := make(map[string][]string)\n\t\t\t\tif err := json.Unmarshal(ptypes, &m); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tp := make(procfile.ExtendedProcfile)\n\t\t\t\tfor name, command := range m {\n\t\t\t\t\tp[name] = procfile.Process{\n\t\t\t\t\t\tCommand: command,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tslugs[id] = p\n\t\t\t}\n\n\t\t\tif err := rows.Err(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trows.Close()\n\n\t\t\tfor id, p := range slugs {\n\t\t\t\traw, err := procfile.Marshal(p)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\t_, err = tx.Exec(`UPDATE slugs SET procfile = $1 WHERE id = $2`, raw, id)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE slugs DROP COLUMN process_types`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE slugs ALTER COLUMN procfile SET NOT NULL`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trows, err = tx.Query(`SELECT release_id, id, type, quantity, command, memory, cpu_share, nproc FROM processes`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tformations := make(map[string]Formation)\n\t\t\tfor rows.Next() {\n\t\t\t\tvar release, id, ptype string\n\t\t\t\tvar command Command\n\t\t\t\tvar quantity, memory, cpu, nproc int\n\t\t\t\tif err := rows.Scan(&release, &id, &ptype, &quantity, &command, &memory, &cpu, &nproc); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif formations[release] == nil {\n\t\t\t\t\tformations[release] = make(Formation)\n\t\t\t\t}\n\n\t\t\t\tf := formations[release]\n\t\t\t\tf[ptype] = Process{\n\t\t\t\t\tCommand:  command,\n\t\t\t\t\tQuantity: quantity,\n\t\t\t\t\tMemory:   constraints.Memory(memory),\n\t\t\t\t\tCPUShare: constraints.CPUShare(cpu),\n\t\t\t\t\tNproc:    constraints.Nproc(nproc),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif err := rows.Err(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\trows.Close()\n\n\t\t\tfor id, f := range formations {\n\t\t\t\t_, err = tx.Exec(`UPDATE releases SET formation = $1 WHERE id = $2`, f, id)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE releases ALTER COLUMN formation SET NOT NULL`)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`DROP TABLE processes`)\n\n\t\t\treturn err\n\t\t},\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE releases DROP COLUMN formation`,\n\t\t\t`ALTER TABLE slugs DROP COLUMN procfile`,\n\t\t\t`ALTER TABLE slugs ADD COLUMN process_types hstore not null`,\n\t\t\t`CREATE TABLE processes (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  release_id uuid NOT NULL references releases(id) ON DELETE CASCADE,\n  \"type\" text NOT NULL,\n  quantity int NOT NULL,\n  command text NOT NULL,\n  cpu_share int,\n  memory bigint,\n  nproc bigint\n)`,\n\t\t\t`CREATE UNIQUE INDEX index_processes_on_release_id_and_type ON processes USING btree (release_id, \"type\")`,\n\t\t}),\n\t},\n\n\t// This migration changes that way we store process configuration for\n\t// releases and slugs, to instead store a Formation in JSON format.\n\t{\n\t\tID: 16,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`CREATE TABLE stacks (\n  app_id text NOT NULL,\n  stack_name text NOT NULL\n)`,\n\t\t\t`CREATE UNIQUE INDEX index_stacks_on_app_id ON stacks USING btree (app_id)`,\n\t\t\t`CREATE UNIQUE INDEX index_stacks_on_stack_name ON stacks USING btree (stack_name)`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE stacks`,\n\t\t}),\n\t},\n\n\t// This migration adds a table that gets used to migrate apps from the\n\t// old ECS backend to the shiny new CloudFormation backend.\n\t{\n\t\tID: 17,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`CREATE TABLE scheduler_migration (app_id text NOT NULL, backend text NOT NULL)`,\n\t\t\t`INSERT INTO scheduler_migration (app_id, backend) SELECT id, 'ecs' FROM apps`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE scheduler_migration`,\n\t\t}),\n\t},\n\n\t// This migration adds a table that stores environment variables for the\n\t// Custom::ECSEnvironment resource.\n\t{\n\t\tID: 18,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`CREATE TABLE ecs_environment (\n  id uuid NOT NULL DEFAULT uuid_generate_v4() primary key,\n  environment json NOT NULL\n)`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP TABLE ecs_environment`,\n\t\t}),\n\t},\n\n\t// This migration migrates the cert storage from a single string column\n\t// to a mapping of process name to cert name.\n\t{\n\t\tID: 19,\n\t\tUp: func(tx *sql.Tx) error {\n\t\t\t_, err := tx.Exec(`ALTER TABLE apps ADD COLUMN certs json`)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error adding certs column: %v\", err)\n\t\t\t}\n\n\t\t\trows, err := tx.Query(`SELECT id, cert FROM apps WHERE cert is not null and cert != ''`)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error querying app certs: %v\", err)\n\t\t\t}\n\t\t\tdefer rows.Close()\n\n\t\t\t// maps an app id to it's cert.\n\t\t\tcerts := make(map[string]string)\n\t\t\tfor rows.Next() {\n\t\t\t\tvar appID, cert string\n\t\t\t\tif err := rows.Scan(&appID, &cert); err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error scanning row: %v\", err)\n\t\t\t\t}\n\t\t\t\tcerts[appID] = cert\n\t\t\t}\n\n\t\t\tfor appID, cert := range certs {\n\t\t\t\traw, err := json.Marshal(map[string]string{\"web\": cert})\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error generating cert map for app %s: %v\", appID, err)\n\t\t\t\t}\n\n\t\t\t\t_, err = tx.Exec(`UPDATE apps SET certs = $1 WHERE id = $2`, raw, appID)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"error updating certs column on app %s: %v\", appID, err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t_, err = tx.Exec(`ALTER TABLE apps DROP COLUMN cert`)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error dropping old cert column: %v\", err)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps DROP COLUMN certs`,\n\t\t\t`ALTER TABLE apps ADD COLUMN cert text`,\n\t\t}),\n\t},\n\n\t// This migration migrates the cert storage from a single string column\n\t// to a mapping of process name to cert name.\n\t{\n\t\tID: 20,\n\t\tUp: func(tx *sql.Tx) error {\n\t\t\t_, err := tx.Exec(`ALTER TABLE apps ADD COLUMN maintenance bool NOT NULL DEFAULT false`)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error adding maintenance column: %v\", err)\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t\tDown: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps DROP COLUMN maintenance`,\n\t\t}),\n\t},\n\n\t// Enables support for soft deletion.\n\t{\n\n\t\tID: 21,\n\t\tUp: migrate.Queries([]string{\n\t\t\t`ALTER TABLE apps ADD COLUMN deleted_at timestamp without time zone`,\n\t\t\t`CREATE UNIQUE INDEX unique_app_name ON apps USING btree (name) WHERE deleted_at is null`,\n\t\t\t`DROP INDEX index_apps_on_name`,\n\t\t}),\n\t\tDown: migrate.Queries([]string{\n\t\t\t`DROP INDEX unique_app_name`,\n\t\t\t`CREATE UNIQUE INDEX index_apps_on_name ON apps USING btree (name)`,\n\t\t\t`ALTER TABLE apps DROP COLUMN deleted_at`,\n\t\t}),\n\t},\n}\n"
        },
        {
          "name": "migrations_test.go",
          "type": "blob",
          "size": 1.38671875,
          "content": "package empire\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n\t\"testing\"\n\n\t_ \"github.com/lib/pq\"\n\t\"github.com/remind101/empire/dbtest\"\n\t\"github.com/remind101/empire/internal/migrate\"\n\t\"github.com/stretchr/testify/assert\"\n)\n\n// Tests migrating the database down, then back up again.\nfunc TestMigrations(t *testing.T) {\n\tdb, err := NewDB(dbtest.Open(t))\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tmigrations := DefaultSchema.migrations()\n\n\terr = db.migrator.Exec(migrate.Up, migrations...)\n\tassert.NoError(t, err)\n\n\terr = db.Reset()\n\tassert.NoError(t, err)\n\n\terr = db.migrator.Exec(migrate.Down, migrations...)\n\tassert.NoError(t, err)\n\n\terr = db.migrator.Exec(migrate.Up, migrations...)\n\tassert.NoError(t, err)\n\n\tf, err := os.Create(\"schema.sql\")\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tdefer f.Close()\n\tcmd := exec.Command(\"pg_dump\", \"--schema-only\", \"--no-owner\", \"--no-acl\", *dbtest.DatabaseURL)\n\tcmd.Stdout = f\n\tcmd.Stderr = os.Stderr\n\tassert.NoError(t, cmd.Run())\n}\n\nfunc TestLatestSchema(t *testing.T) {\n\tassert.Equal(t, 21, DefaultSchema.latestSchema())\n}\n\nfunc TestNoDuplicateMigrations(t *testing.T) {\n\tvisited := make(map[int]bool)\n\texpectedID := 1\n\tfor _, m := range DefaultSchema.migrations() {\n\t\tif visited[m.ID] {\n\t\t\tt.Fatalf(\"Migration %d appears more than once\", m.ID)\n\t\t}\n\t\tvisited[m.ID] = true\n\t\tif m.ID != expectedID {\n\t\t\tt.Fatalf(\"Expected migration %d after %d, but got %d\", expectedID, expectedID-1, m.ID)\n\t\t}\n\t\texpectedID++\n\t}\n}\n"
        },
        {
          "name": "mkdocs.yml",
          "type": "blob",
          "size": 0.7431640625,
          "content": "site_name: Empire Documentation\ntheme: readthedocs\npages:\n  - 'Introduction': 'index.md'\n  - Getting Started:\n    - \"Quickstart: Installing\": \"quickstart_installing.md\"\n    - \"Quickstart: Using\": \"quickstart_using.md\"\n    - \"Configuration\": \"configuration.md\"\n    - \"Production Best Practices\": \"production_best_practices.md\"\n    - \"SAML Authentication\": \"saml.md\"\n  - Users Guide:\n    - \"Deploying an Application\": \"deploying_an_application.md\"\n    - \"Exposing an app publicly\": \"exposing_an_app_publicly.md\"\n    - \"SSL Certs\": \"ssl_certs.md\"\n    - \"CloudFormation Resources\": \"cloudformation_resources.md\"\n  - Hacking on Empire:\n    - \"Contribution Guidelines & Bug Reporting\": \"contributing.md\"\n  - Reference:\n    - \"Troubleshooting\": \"troubleshooting.md\"\n\n\n"
        },
        {
          "name": "pkg",
          "type": "tree",
          "content": null
        },
        {
          "name": "processes.go",
          "type": "blob",
          "size": 4.91015625,
          "content": "package empire\n\nimport (\n\t\"database/sql/driver\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/remind101/empire/internal/shellwords\"\n\t\"github.com/remind101/empire/pkg/constraints\"\n\t\"github.com/remind101/empire/procfile\"\n)\n\n// DefaultQuantities maps a process type to the default number of instances to\n// run.\nvar DefaultQuantities = map[string]int{\n\t\"web\": 1,\n}\n\n// Command represents a command and it's arguments. For example:\ntype Command []string\n\n// ParseCommand parses a string into a Command, taking quotes and other shell\n// words into account. For example:\nfunc ParseCommand(command string) (Command, error) {\n\treturn shellwords.Parse(command)\n}\n\n// MustParseCommand parses the string into a Command, panicing if there's an\n// error. This method should only be used in tests for convenience.\nfunc MustParseCommand(command string) Command {\n\tc, err := ParseCommand(command)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn c\n}\n\n// Scan implements the sql.Scanner interface.\nfunc (c *Command) Scan(src interface{}) error {\n\tbytes, ok := src.([]byte)\n\tif !ok {\n\t\treturn error(errors.New(\"Scan source was not []bytes\"))\n\t}\n\n\tvar cmd Command\n\tif err := json.Unmarshal(bytes, &cmd); err != nil {\n\t\treturn err\n\t}\n\t*c = cmd\n\n\treturn nil\n}\n\n// Value implements the driver.Value interface.\nfunc (c Command) Value() (driver.Value, error) {\n\traw, err := json.Marshal(c)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn driver.Value(raw), nil\n}\n\n// String returns the string reprsentation of the command.\nfunc (c Command) String() string {\n\treturn strings.Join([]string(c), \" \")\n}\n\n// Process holds configuration information about a Process.\ntype Process struct {\n\t// Command is the command to run.\n\tCommand Command `json:\"Command,omitempty\"`\n\n\t// Signifies that this is a named one off command and not a long lived\n\t// service.\n\tNoService bool `json:\"Run,omitempty\"`\n\n\t// Quantity is the desired number of instances of this process.\n\tQuantity int `json:\"Quantity,omitempty\"`\n\n\t// The memory constraints, in bytes.\n\tMemory constraints.Memory `json:\"Memory,omitempty\"`\n\n\t// The amount of CPU share to give.\n\tCPUShare constraints.CPUShare `json:\"CPUShare,omitempty\"`\n\n\t// The allow number of unix processes within the container.\n\tNproc constraints.Nproc `json:\"Nproc,omitempty\"`\n\n\t// A cron expression. If provided, the process will be run as a\n\t// scheduled task.\n\tCron *string `json:\"cron,omitempty\"`\n\n\t// Port mappings from container to load balancer.\n\tPorts []Port `json:\"Ports,omitempty\"`\n\n\t// An process specific environment variables.\n\tEnvironment map[string]string `json:\"Environment,omitempty\"`\n\n\t// ECS specific parameters.\n\tECS *procfile.ECS `json:\"ECS,omitempty\"`\n}\n\ntype Port struct {\n\tHost      int    `json:\"Host\"`\n\tContainer int    `json:\"Container\"`\n\tProtocol  string `json:\"Protocol\"`\n}\n\n// IsValid returns nil if the Process is valid.\nfunc (p *Process) IsValid() error {\n\t// Ensure that processes marked as NoService can't be scaled up.\n\tif p.NoService {\n\t\tif p.Quantity != 0 {\n\t\t\treturn errors.New(\"non-service processes cannot be scaled up\")\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Constraints returns a constraints.Constraints from this Process definition.\nfunc (p *Process) Constraints() Constraints {\n\treturn Constraints{\n\t\tMemory:   p.Memory,\n\t\tCPUShare: p.CPUShare,\n\t\tNproc:    p.Nproc,\n\t}\n}\n\n// SetConstraints sets the memory/cpu/nproc for this Process to the given\n// constraints.\nfunc (p *Process) SetConstraints(c Constraints) {\n\tp.Memory = c.Memory\n\tp.CPUShare = c.CPUShare\n\tp.Nproc = c.Nproc\n}\n\n// Formation represents a collection of named processes and their configuration.\ntype Formation map[string]Process\n\n// IsValid returns nil if all of the Processes are valid.\nfunc (f Formation) IsValid() error {\n\tfor n, p := range f {\n\t\tif err := p.IsValid(); err != nil {\n\t\t\treturn fmt.Errorf(\"process %s is not valid: %v\", n, err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// Scan implements the sql.Scanner interface.\nfunc (f *Formation) Scan(src interface{}) error {\n\tbytes, ok := src.([]byte)\n\tif !ok {\n\t\treturn error(errors.New(\"Scan source was not []bytes\"))\n\t}\n\n\tformation := make(Formation)\n\tif err := json.Unmarshal(bytes, &formation); err != nil {\n\t\treturn err\n\t}\n\t*f = formation\n\n\treturn nil\n}\n\n// Value implements the driver.Value interface.\nfunc (f Formation) Value() (driver.Value, error) {\n\tif f == nil {\n\t\treturn nil, nil\n\t}\n\n\traw, err := json.Marshal(f)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn driver.Value(raw), nil\n}\n\n// Merge merges in the existing quantity and constraints from the old Formation\n// into this Formation.\nfunc (f Formation) Merge(other Formation) Formation {\n\tnew := make(Formation)\n\n\tfor name, p := range f {\n\t\tif existing, found := other[name]; found {\n\t\t\t// If the existing Formation already had a process\n\t\t\t// configuration for this process type, copy over the\n\t\t\t// instance count.\n\t\t\tp.Quantity = existing.Quantity\n\t\t\tp.SetConstraints(existing.Constraints())\n\t\t} else {\n\t\t\tp.Quantity = DefaultQuantities[name]\n\t\t\tp.SetConstraints(DefaultConstraints)\n\t\t}\n\n\t\tnew[name] = p\n\t}\n\n\treturn new\n}\n"
        },
        {
          "name": "processes_test.go",
          "type": "blob",
          "size": 2.634765625,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\t\"github.com/stretchr/testify/assert\"\n)\n\nfunc TestNewFormation(t *testing.T) {\n\ttests := []struct {\n\t\tf     Formation\n\t\tother Formation\n\n\t\texpected Formation\n\t}{\n\n\t\t// Check that default quantity and constraints are merged in.\n\t\t{\n\t\t\tf: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tCommand: Command{\"./bin/web\"},\n\t\t\t\t},\n\t\t\t\t\"worker\": Process{\n\t\t\t\t\tCommand: Command{\"sidekiq\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tother: nil,\n\t\t\texpected: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tQuantity: 1,\n\t\t\t\t\tCommand:  Command{\"./bin/web\"},\n\t\t\t\t\tMemory:   NamedConstraints[\"1X\"].Memory,\n\t\t\t\t\tCPUShare: NamedConstraints[\"1X\"].CPUShare,\n\t\t\t\t\tNproc:    NamedConstraints[\"1X\"].Nproc,\n\t\t\t\t},\n\t\t\t\t\"worker\": Process{\n\t\t\t\t\tQuantity: 0,\n\t\t\t\t\tCommand:  Command{\"sidekiq\"},\n\t\t\t\t\tMemory:   NamedConstraints[\"1X\"].Memory,\n\t\t\t\t\tCPUShare: NamedConstraints[\"1X\"].CPUShare,\n\t\t\t\t\tNproc:    NamedConstraints[\"1X\"].Nproc,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t// Check that the quantity and constraints from the existing\n\t\t// configuration are used.\n\t\t{\n\t\t\tf: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tCommand: Command{\"./bin/web\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tother: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tCommand:  Command{\"./bin/web\"},\n\t\t\t\t\tQuantity: 2,\n\t\t\t\t\tMemory:   NamedConstraints[\"PX\"].Memory,\n\t\t\t\t\tCPUShare: NamedConstraints[\"PX\"].CPUShare,\n\t\t\t\t\tNproc:    NamedConstraints[\"PX\"].Nproc,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tQuantity: 2,\n\t\t\t\t\tCommand:  Command{\"./bin/web\"},\n\t\t\t\t\tMemory:   NamedConstraints[\"PX\"].Memory,\n\t\t\t\t\tCPUShare: NamedConstraints[\"PX\"].CPUShare,\n\t\t\t\t\tNproc:    NamedConstraints[\"PX\"].Nproc,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\n\t\t// Check that removed processes are ignored.\n\t\t{\n\t\t\tf: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tCommand: Command{\"./bin/web\"},\n\t\t\t\t},\n\t\t\t},\n\t\t\tother: Formation{\n\t\t\t\t\"worker\": Process{\n\t\t\t\t\tCommand:  Command{\"sidekiq\"},\n\t\t\t\t\tQuantity: 2,\n\t\t\t\t\tMemory:   NamedConstraints[\"PX\"].Memory,\n\t\t\t\t\tCPUShare: NamedConstraints[\"PX\"].CPUShare,\n\t\t\t\t\tNproc:    NamedConstraints[\"PX\"].Nproc,\n\t\t\t\t},\n\t\t\t},\n\t\t\texpected: Formation{\n\t\t\t\t\"web\": Process{\n\t\t\t\t\tQuantity: 1,\n\t\t\t\t\tCommand:  Command{\"./bin/web\"},\n\t\t\t\t\tMemory:   NamedConstraints[\"1X\"].Memory,\n\t\t\t\t\tCPUShare: NamedConstraints[\"1X\"].CPUShare,\n\t\t\t\t\tNproc:    NamedConstraints[\"1X\"].Nproc,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tfor _, tt := range tests {\n\t\tf := tt.f.Merge(tt.other)\n\t\tassert.Equal(t, tt.expected, f)\n\t}\n}\n\nfunc ExampleCommand() {\n\tcmd := Command{\"/bin/ls\", \"-h\"}\n\tfmt.Println(cmd)\n}\n\nfunc ExampleParseCommand() {\n\tcmd1, _ := ParseCommand(`/bin/ls -h`)\n\tcmd2, _ := ParseCommand(`/bin/echo 'hello world'`)\n\tfmt.Printf(\"%#v\\n\", cmd1)\n\tfmt.Printf(\"%#v\\n\", cmd2)\n\t// Output:\n\t// empire.Command{\"/bin/ls\", \"-h\"}\n\t// empire.Command{\"/bin/echo\", \"hello world\"}\n\n}\n"
        },
        {
          "name": "procfile",
          "type": "tree",
          "content": null
        },
        {
          "name": "registry.go",
          "type": "blob",
          "size": 3.34375,
          "content": "package empire\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\n\t\"golang.org/x/net/context\"\n\n\t\"github.com/remind101/empire/pkg/image\"\n\t\"github.com/remind101/empire/pkg/jsonmessage\"\n\t\"github.com/remind101/empire/procfile\"\n)\n\n// Example instance: Procfile doesn't exist\ntype ProcfileError struct {\n\tErr error\n}\n\nfunc (e *ProcfileError) Error() string {\n\treturn fmt.Sprintf(\"Procfile not found: %s\", e.Err)\n}\n\n// Procfile is the name of the Procfile file that Empire will use to\n// determine the process formation.\nconst Procfile = \"Procfile\"\n\n// ProcfileExtractor represents something that can extract a Procfile from an image.\ntype ProcfileExtractor interface {\n\t// ExtractProcfile should return extracted a Procfile from an image, returning\n\t// it's YAML representation.\n\tExtractProcfile(context.Context, image.Image, *jsonmessage.Stream) ([]byte, error)\n}\n\n// ProcfileExtractorFunc implements the ProcfileExtractor interface.\ntype ProcfileExtractorFunc func(context.Context, image.Image, *jsonmessage.Stream) ([]byte, error)\n\nfunc (fn ProcfileExtractorFunc) ExtractProcfile(ctx context.Context, image image.Image, w *jsonmessage.Stream) ([]byte, error) {\n\treturn fn(ctx, image, w)\n}\n\n// ImageRegistry represents something that can interact with container images.\ntype ImageRegistry interface {\n\tProcfileExtractor\n\n\t// Resolve should resolve an image to an \"immutable\" reference of the\n\t// image.\n\tResolve(context.Context, image.Image, *jsonmessage.Stream) (image.Image, error)\n}\n\nfunc formationFromProcfile(p procfile.Procfile) (Formation, error) {\n\tswitch p := p.(type) {\n\tcase procfile.StandardProcfile:\n\t\treturn formationFromStandardProcfile(p)\n\tcase procfile.ExtendedProcfile:\n\t\treturn formationFromExtendedProcfile(p)\n\tdefault:\n\t\treturn nil, &ProcfileError{\n\t\t\tErr: errors.New(\"unknown Procfile format\"),\n\t\t}\n\t}\n}\n\nfunc formationFromStandardProcfile(p procfile.StandardProcfile) (Formation, error) {\n\tf := make(Formation)\n\n\tfor name, command := range p {\n\t\tcmd, err := ParseCommand(command)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tf[name] = Process{\n\t\t\tCommand: cmd,\n\t\t}\n\t}\n\n\treturn f, nil\n}\n\nfunc formationFromExtendedProcfile(p procfile.ExtendedProcfile) (Formation, error) {\n\tf := make(Formation)\n\n\tfor name, process := range p {\n\t\tvar cmd Command\n\t\tvar err error\n\n\t\tswitch command := process.Command.(type) {\n\t\tcase string:\n\t\t\tcmd, err = ParseCommand(command)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\tcase []interface{}:\n\t\t\tfor _, v := range command {\n\t\t\t\tcmd = append(cmd, v.(string))\n\t\t\t}\n\t\tdefault:\n\t\t\treturn nil, errors.New(\"unknown command format\")\n\t\t}\n\n\t\tvar ports []Port\n\n\t\tfor _, port := range process.Ports {\n\t\t\tprotocol := port.Protocol\n\t\t\tif protocol == \"\" {\n\t\t\t\tprotocol = protocolFromPort(port.Host)\n\t\t\t}\n\n\t\t\tports = append(ports, Port{\n\t\t\t\tHost:      port.Host,\n\t\t\t\tContainer: port.Container,\n\t\t\t\tProtocol:  protocol,\n\t\t\t})\n\t\t}\n\n\t\tf[name] = Process{\n\t\t\tCommand:     cmd,\n\t\t\tCron:        process.Cron,\n\t\t\tNoService:   process.NoService,\n\t\t\tPorts:       ports,\n\t\t\tEnvironment: process.Environment,\n\t\t\tECS:         process.ECS,\n\t\t}\n\t}\n\n\treturn f, nil\n}\n\n// protocolFromPort attempts to automatically determine what protocol a port\n// should use. For example, port 80 is well known to be http, so we can assume\n// that http should be used. Defaults to \"tcp\" if unknown.\nfunc protocolFromPort(port int) string {\n\tswitch port {\n\tcase 80, 8080:\n\t\treturn \"http\"\n\tcase 443:\n\t\treturn \"https\"\n\tdefault:\n\t\treturn \"tcp\"\n\t}\n}\n"
        },
        {
          "name": "registry",
          "type": "tree",
          "content": null
        },
        {
          "name": "releases.go",
          "type": "blob",
          "size": 11.9951171875,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/pkg/headerutil\"\n\t\"github.com/remind101/empire/pkg/timex\"\n\t\"github.com/remind101/empire/procfile\"\n\t\"github.com/remind101/empire/twelvefactor\"\n\t\"golang.org/x/net/context\"\n)\n\n// Release is a combination of a Config and a Slug, which form a deployable\n// release. Releases are generally considered immutable, the only operation that\n// changes a release is when altering the Quantity or Constraints inside the\n// Formation.\ntype Release struct {\n\t// A unique uuid to identify this release.\n\tID string\n\n\t// An auto incremented ID for this release, scoped to the application.\n\tVersion int\n\n\t// The id of the application that this release relates to.\n\tAppID string\n\n\t// The application that this release relates to.\n\tApp *App\n\n\t// The id of the config that this release uses.\n\tConfigID string\n\n\t// The config that this release uses.\n\tConfig *Config\n\n\t// The id of the slug that this release uses.\n\tSlugID string\n\n\t// The Slug that this release uses.\n\tSlug *Slug\n\n\t// The process formation to use.\n\tFormation Formation\n\n\t// A description for the release. Usually contains the reason for why\n\t// the release was created (e.g. deployment, config changes, etc).\n\tDescription string\n\n\t// The time that this release was created.\n\tCreatedAt *time.Time\n}\n\n// Procfile returns the Procfile that generated this Release.\nfunc (r *Release) Procfile() (procfile.Procfile, error) {\n\treturn r.Slug.ParsedProcfile()\n}\n\n// BeforeCreate sets created_at before inserting.\nfunc (r *Release) BeforeCreate() error {\n\tt := timex.Now()\n\tr.CreatedAt = &t\n\treturn nil\n}\n\n// ReleasesQuery is a scope implementation for common things to filter releases\n// by.\ntype ReleasesQuery struct {\n\t// If provided, an app to filter by.\n\tApp *App\n\n\t// If provided, a version to filter by.\n\tVersion *int\n\n\t// If provided, uses the limit and sorting parameters specified in the range.\n\tRange headerutil.Range\n}\n\n// scope implements the scope interface.\nfunc (q ReleasesQuery) scope(db *gorm.DB) *gorm.DB {\n\tvar scope composedScope\n\n\tif app := q.App; app != nil {\n\t\tscope = append(scope, fieldEquals(\"app_id\", app.ID))\n\t}\n\n\tif version := q.Version; version != nil {\n\t\tscope = append(scope, fieldEquals(\"version\", *version))\n\t}\n\n\tscope = append(scope, inRange(q.Range.WithDefaults(q.DefaultRange())))\n\n\treturn scope.scope(db)\n}\n\n// DefaultRange returns the default headerutil.Range used if values aren't\n// provided.\nfunc (q ReleasesQuery) DefaultRange() headerutil.Range {\n\tsort, order := \"version\", \"desc\"\n\treturn headerutil.Range{\n\t\tSort:  &sort,\n\t\tOrder: &order,\n\t}\n}\n\n// releasesService is a service for creating and rolling back a Release.\ntype releasesService struct {\n\t*Empire\n}\n\n// CreateAndRelease creates a new release then submits it to the scheduler.\nfunc (s *releasesService) CreateAndRelease(ctx context.Context, db *gorm.DB, r *Release, ss twelvefactor.StatusStream) (*Release, error) {\n\tr, err := s.Create(ctx, db, r)\n\tif err != nil {\n\t\treturn r, err\n\t}\n\t// Schedule the new release onto the cluster.\n\treturn r, s.Release(ctx, r, ss)\n}\n\n// Create creates a new release.\nfunc (s *releasesService) Create(ctx context.Context, db *gorm.DB, r *Release) (*Release, error) {\n\t// Lock all releases for the given application to ensure that the\n\t// release version is updated automically.\n\tif err := db.Exec(`select 1 from releases where app_id = ? for update`, r.App.ID).Error; err != nil {\n\t\treturn r, err\n\t}\n\n\t// During rollbacks, we can just provide the existing Formation for the\n\t// old release. For new releases, we need to create a new formation by\n\t// merging the formation from the extracted Procfile, and the Formation\n\t// from the existing release.\n\tif r.Formation == nil {\n\t\tif err := buildFormation(db, r); err != nil {\n\t\t\treturn r, err\n\t\t}\n\t}\n\n\treturn releasesCreate(db, r)\n}\n\n// Rolls back to a specific release version.\nfunc (s *releasesService) Rollback(ctx context.Context, db *gorm.DB, opts RollbackOpts) (*Release, error) {\n\tapp, version := opts.App, opts.Version\n\tr, err := releasesFind(db, ReleasesQuery{App: app, Version: &version})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdesc := fmt.Sprintf(\"Rollback to v%d\", version)\n\tdesc = appendMessageToDescription(desc, opts.User, opts.Message)\n\treturn s.CreateAndRelease(ctx, db, &Release{\n\t\tApp:         app,\n\t\tConfig:      r.Config,\n\t\tSlug:        r.Slug,\n\t\tFormation:   r.Formation,\n\t\tDescription: desc,\n\t}, nil)\n}\n\n// Release submits a release to the scheduler.\nfunc (s *releasesService) Release(ctx context.Context, release *Release, ss twelvefactor.StatusStream) error {\n\ta, err := newSchedulerApp(release)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn s.Scheduler.Submit(ctx, a, ss)\n}\n\nfunc (s *releasesService) ReleaseApp(ctx context.Context, db *gorm.DB, app *App, ss twelvefactor.StatusStream) error {\n\trelease, err := releasesFind(db, ReleasesQuery{App: app})\n\tif err != nil {\n\t\tif err == gorm.RecordNotFound {\n\t\t\treturn ErrNoReleases\n\t\t}\n\n\t\treturn err\n\t}\n\n\tif release == nil {\n\t\treturn nil\n\t}\n\n\treturn s.Release(ctx, release, ss)\n}\n\n// Restart will find the last release for an app and submit it to the scheduler\n// to restart the app.\nfunc (s *releasesService) Restart(ctx context.Context, db *gorm.DB, app *App) error {\n\treturn s.Scheduler.Restart(ctx, app.ID, nil)\n}\n\n// These associations are always available on a Release.\nvar releasesPreload = preload(\"App\", \"Config\", \"Slug\")\n\n// releasesFind returns the first matching release.\nfunc releasesFind(db *gorm.DB, scope scope) (*Release, error) {\n\tvar release Release\n\n\tscope = composedScope{releasesPreload, scope}\n\tif err := first(db, scope, &release); err != nil {\n\t\treturn &release, err\n\t}\n\n\treturn &release, nil\n}\n\n// releases returns all releases matching the scope.\nfunc releases(db *gorm.DB, scope scope) ([]*Release, error) {\n\tvar releases []*Release\n\tscope = composedScope{releasesPreload, scope}\n\treturn releases, find(db, scope, &releases)\n}\n\nfunc releasesUpdate(db *gorm.DB, release *Release) error {\n\treturn db.Save(release).Error\n}\n\nfunc buildFormation(db *gorm.DB, release *Release) error {\n\tvar existing Formation\n\n\t// Get the old release, so we can copy the Formation.\n\tlast, err := releasesFind(db, ReleasesQuery{App: release.App})\n\tif err != nil {\n\t\tif err != gorm.RecordNotFound {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\texisting = last.Formation\n\t}\n\n\tf, err := release.Slug.Formation()\n\tif err != nil {\n\t\treturn err\n\t}\n\trelease.Formation = f.Merge(existing)\n\n\treturn nil\n}\n\n// currentFormations gets the current formations for an app\nfunc currentFormation(db *gorm.DB, app *App) (Formation, error) {\n\t// Get the current release\n\tcurrent, err := releasesFind(db, ReleasesQuery{App: app})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tf := current.Formation\n\treturn f, nil\n}\n\n// ReleasesLastVersion returns the last ReleaseVersion for the given App.\nfunc releasesLastVersion(db *gorm.DB, appID string) (int, error) {\n\tvar version int\n\n\trows, err := db.Raw(`select version from releases where app_id = ? order by version desc`, appID).Rows()\n\tif err != nil {\n\t\treturn version, err\n\t}\n\tdefer rows.Close()\n\n\tfor rows.Next() {\n\t\terr := rows.Scan(&version)\n\t\treturn version, err\n\t}\n\n\treturn version, nil\n}\n\n// releasesCreate creates a new Release and inserts it into the database.\nfunc releasesCreate(db *gorm.DB, release *Release) (*Release, error) {\n\t// Get the last release version for this app.\n\tv, err := releasesLastVersion(db, release.App.ID)\n\tif err != nil {\n\t\treturn release, err\n\t}\n\n\t// Increment the release version.\n\trelease.Version = v + 1\n\n\tif err := db.Create(release).Error; err != nil {\n\t\treturn release, err\n\t}\n\n\treturn release, nil\n}\n\nfunc newSchedulerApp(release *Release) (*twelvefactor.Manifest, error) {\n\tvar processes []*twelvefactor.Process\n\n\tfor name, p := range release.Formation {\n\t\tif p.NoService {\n\t\t\t// If the entry is marked as \"NoService\", don't send it\n\t\t\t// to the backend.\n\t\t\tcontinue\n\t\t}\n\n\t\tif p.Quantity < 0 {\n\t\t\t// If the process is scaled to a negative value, don't\n\t\t\t// send it to the backend.\n\t\t\tcontinue\n\t\t}\n\n\t\tprocess, err := newSchedulerProcess(release, name, p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tprocesses = append(processes, process)\n\t}\n\n\tenv := environment(release.Config.Vars)\n\tenv[\"EMPIRE_APPID\"] = release.App.ID\n\tenv[\"EMPIRE_APPNAME\"] = release.App.Name\n\tenv[\"EMPIRE_RELEASE\"] = fmt.Sprintf(\"v%d\", release.Version)\n\n\tlabels := map[string]string{\n\t\t\"empire.app.id\":      release.App.ID,\n\t\t\"empire.app.name\":    release.App.Name,\n\t\t\"empire.app.release\": fmt.Sprintf(\"v%d\", release.Version),\n\t}\n\n\treturn &twelvefactor.Manifest{\n\t\tAppID:     release.App.ID,\n\t\tName:      release.App.Name,\n\t\tRelease:   fmt.Sprintf(\"v%d\", release.Version),\n\t\tProcesses: processes,\n\t\tEnv:       env,\n\t\tLabels:    labels,\n\t}, nil\n}\n\nfunc newSchedulerProcess(release *Release, name string, p Process) (*twelvefactor.Process, error) {\n\tenv := make(map[string]string)\n\tfor k, v := range p.Environment {\n\t\tenv[k] = v\n\t}\n\n\tenv[\"EMPIRE_PROCESS\"] = name\n\tenv[\"EMPIRE_PROCESS_SCALE\"] = fmt.Sprintf(\"%d\", p.Quantity)\n\tenv[\"SOURCE\"] = fmt.Sprintf(\"%s.%s.v%d\", release.App.Name, name, release.Version)\n\n\tlabels := map[string]string{\n\t\t\"empire.app.process\": name,\n\t}\n\n\tvar (\n\t\texposure *twelvefactor.Exposure\n\t\terr      error\n\t)\n\t// For `web` processes defined in the standard procfile, we'll\n\t// generate a default exposure setting and also set the PORT\n\t// environment variable for backwards compatability.\n\tif name == webProcessType && len(p.Ports) == 0 {\n\t\texposure = standardWebExposure(release.App)\n\t\tenv[\"PORT\"] = \"8080\"\n\t} else {\n\t\texposure, err = processExposure(release.App, name, p)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tquantity := p.Quantity\n\tif release.App.Maintenance {\n\t\tquantity = 0\n\t}\n\n\treturn &twelvefactor.Process{\n\t\tType:      name,\n\t\tEnv:       env,\n\t\tLabels:    labels,\n\t\tCommand:   []string(p.Command),\n\t\tImage:     release.Slug.Image,\n\t\tQuantity:  quantity,\n\t\tMemory:    uint(p.Memory),\n\t\tCPUShares: uint(p.CPUShare),\n\t\tNproc:     uint(p.Nproc),\n\t\tExposure:  exposure,\n\t\tSchedule:  processSchedule(name, p),\n\t\tECS:       p.ECS,\n\t}, nil\n}\n\n// environment coerces a Vars into a map[string]string.\nfunc environment(vars Vars) map[string]string {\n\tenv := make(map[string]string)\n\n\tfor k, v := range vars {\n\t\tenv[string(k)] = string(*v)\n\t}\n\n\treturn env\n}\n\n// standardWebExposure generates a scheduler.Exposure for a web process in the\n// standard Procfile format.\nfunc standardWebExposure(app *App) *twelvefactor.Exposure {\n\tports := []twelvefactor.Port{\n\t\t{\n\t\t\tContainer: 8080,\n\t\t\tHost:      80,\n\t\t\tProtocol:  &twelvefactor.HTTP{},\n\t\t},\n\t}\n\n\t// If a certificate is attached to the \"web\" process, add an SSL port.\n\tif cert, ok := app.Certs[webProcessType]; ok {\n\t\tports = append(ports, twelvefactor.Port{\n\t\t\tContainer: 8080,\n\t\t\tHost:      443,\n\t\t\tProtocol: &twelvefactor.HTTPS{\n\t\t\t\tCert: cert,\n\t\t\t},\n\t\t})\n\t}\n\n\treturn &twelvefactor.Exposure{\n\t\tExternal: app.Exposure == exposePublic,\n\t\tPorts:    ports,\n\t}\n}\n\nfunc processExposure(app *App, name string, process Process) (*twelvefactor.Exposure, error) {\n\t// No ports == not exposed\n\tif len(process.Ports) == 0 {\n\t\treturn nil, nil\n\t}\n\n\tvar ports []twelvefactor.Port\n\tfor _, p := range process.Ports {\n\t\tvar protocol twelvefactor.Protocol\n\t\tswitch p.Protocol {\n\t\tcase \"http\":\n\t\t\tprotocol = &twelvefactor.HTTP{}\n\t\tcase \"https\":\n\t\t\tcert, ok := app.Certs[name]\n\t\t\tif !ok {\n\t\t\t\treturn nil, &NoCertError{Process: name}\n\t\t\t}\n\t\t\tprotocol = &twelvefactor.HTTPS{\n\t\t\t\tCert: cert,\n\t\t\t}\n\t\tcase \"tcp\":\n\t\t\tprotocol = &twelvefactor.TCP{}\n\t\tcase \"ssl\":\n\t\t\tcert, ok := app.Certs[name]\n\t\t\tif !ok {\n\t\t\t\treturn nil, &NoCertError{Process: name}\n\t\t\t}\n\t\t\tprotocol = &twelvefactor.SSL{\n\t\t\t\tCert: cert,\n\t\t\t}\n\t\t}\n\t\tports = append(ports, twelvefactor.Port{\n\t\t\tHost:      p.Host,\n\t\t\tContainer: p.Container,\n\t\t\tProtocol:  protocol,\n\t\t})\n\t}\n\treturn &twelvefactor.Exposure{\n\t\tExternal: app.Exposure == exposePublic,\n\t\tPorts:    ports,\n\t}, nil\n}\n\nfunc processSchedule(name string, p Process) twelvefactor.Schedule {\n\tif p.Cron != nil {\n\t\treturn twelvefactor.CRONSchedule(*p.Cron)\n\t}\n\n\treturn nil\n}\n\nfunc appendMessageToDescription(main string, user *User, message string) string {\n\tvar formatted string\n\tif message != \"\" {\n\t\tformatted = fmt.Sprintf(\": '%s'\", message)\n\t}\n\treturn fmt.Sprintf(\"%s (%s%s)\", main, user.Name, formatted)\n}\n"
        },
        {
          "name": "releases_test.go",
          "type": "blob",
          "size": 0.91796875,
          "content": "package empire\n\nimport (\n\t\"testing\"\n\n\t\"github.com/remind101/empire/pkg/headerutil\"\n)\n\nfunc TestReleasesQuery(t *testing.T) {\n\tvar (\n\t\tapp     = &App{ID: \"1234\"}\n\t\tversion = 1\n\t\tsort    = \"version\"\n\t\tmax     = 20\n\t\torder   = \"desc\"\n\t)\n\n\trangeHeader := headerutil.Range{\n\t\tSort:  &sort,\n\t\tMax:   &max,\n\t\tOrder: &order,\n\t}\n\n\ttests := scopeTests{\n\t\t{ReleasesQuery{}, \"ORDER BY version desc\", []interface{}{}},\n\t\t{ReleasesQuery{Range: rangeHeader}, \"ORDER BY version desc LIMIT 20\", []interface{}{}},\n\t\t{ReleasesQuery{App: app, Range: rangeHeader}, \"WHERE (app_id = $1) ORDER BY version desc LIMIT 20\", []interface{}{\"1234\"}},\n\t\t{ReleasesQuery{Version: &version, Range: rangeHeader}, \"WHERE (version = $1) ORDER BY version desc LIMIT 20\", []interface{}{1}},\n\t\t{ReleasesQuery{App: app, Version: &version, Range: rangeHeader}, \"WHERE (app_id = $1) AND (version = $2) ORDER BY version desc LIMIT 20\", []interface{}{\"1234\", 1}},\n\t}\n\n\ttests.Run(t)\n}\n"
        },
        {
          "name": "runner.go",
          "type": "blob",
          "size": 2.13671875,
          "content": "package empire\n\nimport (\n\t\"io\"\n\n\t\"golang.org/x/net/context\"\n)\n\nconst (\n\t// GenericProcessName is the process name for `emp run` processes not defined in the procfile.\n\tGenericProcessName = \"run\"\n)\n\n// RunRecorder is a function that returns an io.Writer that will be written to\n// to record Stdout and Stdin of interactive runs.\ntype RunRecorder func() (io.Writer, error)\n\ntype runnerService struct {\n\t*Empire\n}\n\nfunc (r *runnerService) Run(ctx context.Context, opts RunOpts) error {\n\trelease, err := releasesFind(r.db, ReleasesQuery{App: opts.App})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tprocName := opts.Command[0]\n\tvar proc Process\n\n\t// First, let's check if the command we're running matches a defined\n\t// process in the Procfile/Formation. If it does, we'll replace the\n\t// command, with the one in the procfile and expand it's arguments.\n\t//\n\t// For example, given a procfile like this:\n\t//\n\t//\tpsql:\n\t//\t  command: ./bin/psql\n\t//\n\t// Calling `emp run psql DATABASE_URL` will expand the command to\n\t// `./bin/psql DATABASE_URL`.\n\tif cmd, ok := release.Formation[procName]; ok {\n\t\tproc = cmd\n\t\tproc.Command = append(cmd.Command, opts.Command[1:]...)\n\t\tproc.NoService = false\n\t} else {\n\t\t// If we've set the flag to only allow `emp run` on commands\n\t\t// defined in the procfile, return an error since the command is\n\t\t// not defined in the procfile.\n\t\tif r.AllowedCommands == AllowCommandProcfile {\n\t\t\treturn commandNotInFormation(Command{procName}, release.Formation)\n\t\t}\n\n\t\t// This is an unnamed command, fallback to a generic proc name.\n\t\tprocName = GenericProcessName\n\t\tproc.Command = opts.Command\n\t\tproc.SetConstraints(DefaultConstraints)\n\t}\n\n\tproc.Quantity = 1\n\n\t// Set the size of the process.\n\tif opts.Constraints != nil {\n\t\tproc.SetConstraints(*opts.Constraints)\n\t}\n\n\trelease.Formation = Formation{procName: proc}\n\ta, err := newSchedulerApp(release)\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, p := range a.Processes {\n\t\tp.Stdin = opts.Stdin\n\t\tp.Stdout = opts.Stdout\n\t\tp.Stderr = opts.Stderr\n\t\tp.Labels[\"empire.user\"] = opts.User.Name\n\n\t\t// Add additional environment variables to the process.\n\t\tfor k, v := range opts.Env {\n\t\t\tp.Env[k] = v\n\t\t}\n\t}\n\n\treturn r.Scheduler.Run(ctx, a)\n}\n"
        },
        {
          "name": "scheduler.go",
          "type": "blob",
          "size": 1.7421875,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"github.com/remind101/empire/pkg/timex\"\n\t\"github.com/remind101/empire/twelvefactor\"\n\t\"golang.org/x/net/context\"\n)\n\ntype Scheduler twelvefactor.Scheduler\n\ntype FakeScheduler struct {\n\tsync.Mutex\n\tapps map[string]*twelvefactor.Manifest\n}\n\nfunc NewFakeScheduler() *FakeScheduler {\n\treturn &FakeScheduler{\n\t\tapps: make(map[string]*twelvefactor.Manifest),\n\t}\n}\n\nfunc (m *FakeScheduler) Submit(ctx context.Context, app *twelvefactor.Manifest, ss twelvefactor.StatusStream) error {\n\tm.Lock()\n\tdefer m.Unlock()\n\tm.apps[app.AppID] = app\n\treturn nil\n}\n\nfunc (m *FakeScheduler) Restart(ctx context.Context, appID string, ss twelvefactor.StatusStream) error {\n\treturn nil\n}\n\nfunc (m *FakeScheduler) Remove(ctx context.Context, appID string) error {\n\tdelete(m.apps, appID)\n\treturn nil\n}\n\nfunc (m *FakeScheduler) Tasks(ctx context.Context, appID string) ([]*twelvefactor.Task, error) {\n\tvar instances []*twelvefactor.Task\n\tif a, ok := m.apps[appID]; ok {\n\t\tfor _, p := range a.Processes {\n\t\t\tpp := *p\n\t\t\tpp.Env = twelvefactor.Env(a, p)\n\t\t\tfor i := 1; i <= p.Quantity; i++ {\n\t\t\t\tinstances = append(instances, &twelvefactor.Task{\n\t\t\t\t\tID:        fmt.Sprintf(\"%d\", i),\n\t\t\t\t\tHost:      twelvefactor.Host{ID: \"i-aa111aa1\"},\n\t\t\t\t\tState:     \"running\",\n\t\t\t\t\tProcess:   &pp,\n\t\t\t\t\tUpdatedAt: timex.Now(),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\treturn instances, nil\n}\n\nfunc (m *FakeScheduler) Stop(ctx context.Context, instanceID string) error {\n\treturn nil\n}\n\nfunc (m *FakeScheduler) Run(ctx context.Context, app *twelvefactor.Manifest) error {\n\tfor _, p := range app.Processes {\n\t\tif p.Stderr != nil {\n\t\t\tfmt.Fprintf(p.Stdout, \"Attaching to container\\n\")\n\t\t}\n\n\t\tif p.Stdout != nil {\n\t\t\tfmt.Fprintf(p.Stdout, \"Fake output for `%s` on %s\\n\", p.Command, app.Name)\n\t\t}\n\t}\n\treturn nil\n}\n"
        },
        {
          "name": "scheduler",
          "type": "tree",
          "content": null
        },
        {
          "name": "schema.sql",
          "type": "blob",
          "size": 8.2724609375,
          "content": "--\n-- PostgreSQL database dump\n--\n\n-- Dumped from database version 9.6.1\n-- Dumped by pg_dump version 9.6.1\n\nSET statement_timeout = 0;\nSET lock_timeout = 0;\nSET idle_in_transaction_session_timeout = 0;\nSET client_encoding = 'UTF8';\nSET standard_conforming_strings = on;\nSET check_function_bodies = false;\nSET client_min_messages = warning;\nSET row_security = off;\n\n--\n-- Name: plpgsql; Type: EXTENSION; Schema: -; Owner: -\n--\n\nCREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;\n\n\n--\n-- Name: EXTENSION plpgsql; Type: COMMENT; Schema: -; Owner: -\n--\n\nCOMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';\n\n\n--\n-- Name: hstore; Type: EXTENSION; Schema: -; Owner: -\n--\n\nCREATE EXTENSION IF NOT EXISTS hstore WITH SCHEMA public;\n\n\n--\n-- Name: EXTENSION hstore; Type: COMMENT; Schema: -; Owner: -\n--\n\nCOMMENT ON EXTENSION hstore IS 'data type for storing sets of (key, value) pairs';\n\n\n--\n-- Name: uuid-ossp; Type: EXTENSION; Schema: -; Owner: -\n--\n\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\" WITH SCHEMA public;\n\n\n--\n-- Name: EXTENSION \"uuid-ossp\"; Type: COMMENT; Schema: -; Owner: -\n--\n\nCOMMENT ON EXTENSION \"uuid-ossp\" IS 'generate universally unique identifiers (UUIDs)';\n\n\nSET search_path = public, pg_catalog;\n\nSET default_tablespace = '';\n\nSET default_with_oids = false;\n\n--\n-- Name: apps; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE apps (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    name character varying(30) NOT NULL,\n    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()),\n    repo text,\n    exposure text DEFAULT 'private'::text NOT NULL,\n    certs json,\n    maintenance boolean DEFAULT false NOT NULL,\n    deleted_at timestamp without time zone\n);\n\n\n--\n-- Name: certificates; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE certificates (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    app_id uuid NOT NULL,\n    name text,\n    certificate_chain text,\n    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()),\n    updated_at timestamp without time zone DEFAULT timezone('utc'::text, now())\n);\n\n\n--\n-- Name: configs; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE configs (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    app_id uuid NOT NULL,\n    vars hstore,\n    created_at timestamp without time zone DEFAULT timezone('utc'::text, now())\n);\n\n\n--\n-- Name: domains; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE domains (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    app_id uuid NOT NULL,\n    hostname text NOT NULL,\n    created_at timestamp without time zone DEFAULT timezone('utc'::text, now())\n);\n\n\n--\n-- Name: ecs_environment; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE ecs_environment (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    environment json NOT NULL\n);\n\n\n--\n-- Name: ports; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE ports (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    port integer,\n    app_id uuid,\n    taken text\n);\n\n\n--\n-- Name: releases; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE releases (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    app_id uuid NOT NULL,\n    config_id uuid NOT NULL,\n    slug_id uuid NOT NULL,\n    version integer NOT NULL,\n    description text,\n    created_at timestamp without time zone DEFAULT timezone('utc'::text, now()),\n    formation json NOT NULL\n);\n\n\n--\n-- Name: scheduler_migration; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE scheduler_migration (\n    app_id text NOT NULL,\n    backend text NOT NULL\n);\n\n\n--\n-- Name: schema_migrations; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE schema_migrations (\n    version integer NOT NULL\n);\n\n\n--\n-- Name: slugs; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE slugs (\n    id uuid DEFAULT uuid_generate_v4() NOT NULL,\n    image text NOT NULL,\n    procfile bytea NOT NULL\n);\n\n\n--\n-- Name: stacks; Type: TABLE; Schema: public; Owner: -\n--\n\nCREATE TABLE stacks (\n    app_id text NOT NULL,\n    stack_name text NOT NULL\n);\n\n\n--\n-- Name: apps apps_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY apps\n    ADD CONSTRAINT apps_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: certificates certificates_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY certificates\n    ADD CONSTRAINT certificates_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: configs configs_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY configs\n    ADD CONSTRAINT configs_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: domains domains_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY domains\n    ADD CONSTRAINT domains_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: ecs_environment ecs_environment_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY ecs_environment\n    ADD CONSTRAINT ecs_environment_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: ports ports_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY ports\n    ADD CONSTRAINT ports_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: releases releases_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY releases\n    ADD CONSTRAINT releases_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: schema_migrations schema_migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY schema_migrations\n    ADD CONSTRAINT schema_migrations_pkey PRIMARY KEY (version);\n\n\n--\n-- Name: slugs slugs_pkey; Type: CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY slugs\n    ADD CONSTRAINT slugs_pkey PRIMARY KEY (id);\n\n\n--\n-- Name: index_certificates_on_app_id; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE UNIQUE INDEX index_certificates_on_app_id ON certificates USING btree (app_id);\n\n\n--\n-- Name: index_configs_on_created_at; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE INDEX index_configs_on_created_at ON configs USING btree (created_at);\n\n\n--\n-- Name: index_domains_on_app_id; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE INDEX index_domains_on_app_id ON domains USING btree (app_id);\n\n\n--\n-- Name: index_domains_on_hostname; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE UNIQUE INDEX index_domains_on_hostname ON domains USING btree (hostname);\n\n\n--\n-- Name: index_releases_on_app_id_and_version; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE UNIQUE INDEX index_releases_on_app_id_and_version ON releases USING btree (app_id, version);\n\n\n--\n-- Name: index_stacks_on_app_id; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE UNIQUE INDEX index_stacks_on_app_id ON stacks USING btree (app_id);\n\n\n--\n-- Name: index_stacks_on_stack_name; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE UNIQUE INDEX index_stacks_on_stack_name ON stacks USING btree (stack_name);\n\n\n--\n-- Name: unique_app_name; Type: INDEX; Schema: public; Owner: -\n--\n\nCREATE UNIQUE INDEX unique_app_name ON apps USING btree (name) WHERE (deleted_at IS NULL);\n\n\n--\n-- Name: certificates certificates_app_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY certificates\n    ADD CONSTRAINT certificates_app_id_fkey FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE CASCADE;\n\n\n--\n-- Name: configs configs_app_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY configs\n    ADD CONSTRAINT configs_app_id_fkey FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE CASCADE;\n\n\n--\n-- Name: domains domains_app_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY domains\n    ADD CONSTRAINT domains_app_id_fkey FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE CASCADE;\n\n\n--\n-- Name: ports ports_app_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY ports\n    ADD CONSTRAINT ports_app_id_fkey FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE SET NULL;\n\n\n--\n-- Name: releases releases_app_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY releases\n    ADD CONSTRAINT releases_app_id_fkey FOREIGN KEY (app_id) REFERENCES apps(id) ON DELETE CASCADE;\n\n\n--\n-- Name: releases releases_config_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY releases\n    ADD CONSTRAINT releases_config_id_fkey FOREIGN KEY (config_id) REFERENCES configs(id) ON DELETE CASCADE;\n\n\n--\n-- Name: releases releases_slug_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: -\n--\n\nALTER TABLE ONLY releases\n    ADD CONSTRAINT releases_slug_id_fkey FOREIGN KEY (slug_id) REFERENCES slugs(id) ON DELETE CASCADE;\n\n\n--\n-- PostgreSQL database dump complete\n--\n\n"
        },
        {
          "name": "server",
          "type": "tree",
          "content": null
        },
        {
          "name": "slugs.go",
          "type": "blob",
          "size": 1.9755859375,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\n\t\"github.com/jinzhu/gorm\"\n\t\"github.com/remind101/empire/pkg/image\"\n\t\"github.com/remind101/empire/procfile\"\n\t\"golang.org/x/net/context\"\n)\n\n// Slug represents a container image with the extracted ProcessType.\ntype Slug struct {\n\t// A unique uuid that identifies this slug.\n\tID string\n\n\t// The Docker image that this slug is for.\n\tImage image.Image\n\n\t// The raw Procfile that was extracted from the Docker image.\n\tProcfile []byte\n}\n\n// ParsedProcfile returns the parsed Procfile.\nfunc (s *Slug) ParsedProcfile() (procfile.Procfile, error) {\n\treturn procfile.ParseProcfile(s.Procfile)\n}\n\n// Formation returns a new Formation built from the extracted Procfile.\nfunc (s *Slug) Formation() (Formation, error) {\n\tp, err := s.ParsedProcfile()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn formationFromProcfile(p)\n}\n\n// slugsService provides convenience methods for creating slugs.\ntype slugsService struct {\n\t*Empire\n}\n\n// SlugsCreateByImage creates a Slug for the given image.\nfunc (s *slugsService) Create(ctx context.Context, db *gorm.DB, img image.Image, w *DeploymentStream) (*Slug, error) {\n\treturn slugsCreateByImage(ctx, db, s.ImageRegistry, img, w)\n}\n\n// slugsCreate inserts a Slug into the database.\nfunc slugsCreate(db *gorm.DB, slug *Slug) (*Slug, error) {\n\treturn slug, db.Create(slug).Error\n}\n\n// SlugsCreateByImage first attempts to find a matching slug for the image. If\n// it's not found, it will fallback to extracting the process types using the\n// provided extractor, then create a slug.\nfunc slugsCreateByImage(ctx context.Context, db *gorm.DB, r ImageRegistry, img image.Image, w *DeploymentStream) (*Slug, error) {\n\tvar (\n\t\tslug Slug\n\t\terr  error\n\t)\n\n\tslug.Image, err = r.Resolve(ctx, img, w.Stream)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"resolving %s: %v\", img, err)\n\t}\n\n\tslug.Procfile, err = r.ExtractProcfile(ctx, slug.Image, w.Stream)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"extracting Procfile from %s: %v\", slug.Image, err)\n\t}\n\n\treturn slugsCreate(db, &slug)\n}\n"
        },
        {
          "name": "stats",
          "type": "tree",
          "content": null
        },
        {
          "name": "tasks.go",
          "type": "blob",
          "size": 1.7880859375,
          "content": "package empire\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/remind101/empire/pkg/constraints\"\n\t\"github.com/remind101/empire/twelvefactor\"\n\t\"golang.org/x/net/context\"\n)\n\n// Host represents the host of the task\ntype Host struct {\n\t// the host id\n\tID string\n}\n\n// Task represents a running process.\ntype Task struct {\n\t// The name of the task.\n\tName string\n\n\t// The name of the process that this task is for.\n\tType string\n\n\t// The task id\n\tID string\n\n\t// The host of the task\n\tHost Host\n\n\t// The command that this task is running.\n\tCommand Command\n\n\t// The state of the task.\n\tState string\n\n\t// The time that the state was recorded.\n\tUpdatedAt time.Time\n\n\t// The constraints of the Process.\n\tConstraints Constraints\n}\n\ntype tasksService struct {\n\t*Empire\n}\n\nfunc (s *tasksService) Tasks(ctx context.Context, app *App) ([]*Task, error) {\n\tvar tasks []*Task\n\n\tinstances, err := s.Scheduler.Tasks(ctx, app.ID)\n\tif err != nil {\n\t\treturn tasks, err\n\t}\n\n\tfor _, i := range instances {\n\t\ttasks = append(tasks, taskFromInstance(i))\n\t}\n\n\treturn tasks, nil\n}\n\n// taskFromInstance converts a scheduler.Instance into a Task.\n// It pulls some of its data from empire specific environment variables if they have been set.\n// Once ECS supports this data natively, we can stop doing this.\nfunc taskFromInstance(i *twelvefactor.Task) *Task {\n\tversion := i.Process.Env[\"EMPIRE_RELEASE\"]\n\tif version == \"\" {\n\t\tversion = \"v0\"\n\t}\n\n\treturn &Task{\n\t\tName:    fmt.Sprintf(\"%s.%s.%s\", version, i.Process.Type, i.ID),\n\t\tType:    string(i.Process.Type),\n\t\tHost:    Host{ID: i.Host.ID},\n\t\tCommand: Command(i.Process.Command),\n\t\tConstraints: Constraints{\n\t\t\tCPUShare: constraints.CPUShare(i.Process.CPUShares),\n\t\t\tMemory:   constraints.Memory(i.Process.Memory),\n\t\t\tNproc:    constraints.Nproc(i.Process.Nproc),\n\t\t},\n\t\tState:     i.State,\n\t\tUpdatedAt: i.UpdatedAt,\n\t}\n}\n"
        },
        {
          "name": "tests",
          "type": "tree",
          "content": null
        },
        {
          "name": "twelvefactor",
          "type": "tree",
          "content": null
        },
        {
          "name": "users.go",
          "type": "blob",
          "size": 0.3359375,
          "content": "package empire\n\n// User represents a user of Empire.\ntype User struct {\n\t// Name is the users username.\n\tName string `json:\"name\"`\n\n\t// GitHubToken is a GitHub access token.\n\tGitHubToken string `json:\"-\"`\n}\n\n// IsValid returns nil if the User is valid.\nfunc (u *User) IsValid() error {\n\tif u.Name == \"\" {\n\t\treturn ErrUserName\n\t}\n\n\treturn nil\n}\n"
        },
        {
          "name": "vendor",
          "type": "tree",
          "content": null
        },
        {
          "name": "version.go",
          "type": "blob",
          "size": 0.0654296875,
          "content": "package empire\n\n// The version of Empire.\nconst Version = \"0.13.0\"\n"
        }
      ]
    }
  ]
}